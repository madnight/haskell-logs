00:00:06 <Kaidelong> discarding parameters and only consuming their type is actually a pretty common pattern in haskell
00:00:26 <orion> That feels greasy.
00:00:49 <Kaidelong> well it often lets you use the type system to reject code that may be accepted with approaches that don't do that
00:00:55 <Kaidelong> phantom types get used for the same end
00:01:32 <orion> If I were to call randomNonce from an IO do-block, I would have to do something like: nonce <- randomNonce :: IO (Nonce Box) -- right?
00:01:54 <Kaidelong> yeah there's also
00:01:58 <Kaidelong> @hoogle asTypeOf
00:01:59 <lambdabot> Prelude asTypeOf :: a -> a -> a
00:02:11 <orion> OH, interesting.
00:02:22 <Kaidelong> > mzero `asTypeOf` repeat 1
00:02:24 <lambdabot>  []
00:03:11 <Kaidelong> > mappend `asTypeOf` zip
00:03:12 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ (a, a)
00:03:13 <lambdabot>  Expected type: [a] -> [a] -> [a]
00:03:13 <lambdabot>    Actual type: [a] -> [a] -> [(a, a)]
00:03:22 <Kaidelong> oh I guess that doesn't work
00:03:30 <mwhit> which, interestingly, also throws away its second parameter, using it only for its type
00:03:36 <mwhit> probably, i guess
00:03:38 <mwhit> @src asTypeOf
00:03:39 <lambdabot> asTypeOf = const
00:03:56 <Kaidelong> const x _ = x
00:04:17 <Kaidelong> although that's a bit misleading
00:04:22 <Kaidelong> asTypeOf is not const
00:04:35 <Kaidelong> it has a more restrictive type
00:04:40 <Kaidelong> @type const
00:04:41 <lambdabot> a -> b -> a
00:04:44 <Kaidelong> @type asTypeOf
00:04:45 <lambdabot> a -> a -> a
00:04:56 <mwhit> well yeah but it's just const restricted by an explicit type signature
00:12:46 <hamid_> :t (|||)
00:12:47 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
00:15:57 <Maerten> Hi, does anyone know how to use Data.Thyme.Time with Database.Persistent? I get the error "No instance for (PersistFieldSql UTCTime)" but i wouldnt know how to proceed from here.. Any help would be appreciated!
00:34:08 <trap_exit> i have a dumb question
00:34:18 <trap_exit> does it seem in haskell, that the order of the args are "backwards" vs object oriented programming
00:34:28 <trap_exit> in oo, we tend to do stuff like obj.func(arg1, arg2, arg3)
00:34:42 <trap_exit> which one can "naturally" change into func :: obj -> arg1 -> arg2 -> arg3 -> obj
00:34:53 <trap_exit> however, since we want to functions of type obj -> obj (to pass to modify/alter)
00:35:04 <trap_exit> it seems that the haskell version ends up being func :: arg1 -> arg2 -> arg3 -> obj -> obj
00:35:13 <trap_exit> so that (func arg1 arg2 arg3) curries to obj -> obj
00:35:15 <trap_exit> and everyone is happy
00:35:16 <trap_exit> is this correct?
00:35:36 <platz> i.e. tendancy to put the data structures last?
00:35:39 <trap_exit> is anyone even awake, ? if a newb asks a question in a pure channel, does anyone hear it?
00:35:45 <trap_exit> platz: yes, putting the "container / data structure" last
00:35:51 <trap_exit> is this a haskell convention?
00:36:45 <platz> i'm not sure, i've heard that before, yet sometimes it makes sense IMHO to put the data structure first if you want that curried
00:37:21 <mwhit> i don't think you can necessarily generalize like that, i mean what if the return type isn't one of the arguments
00:37:38 <mwhit> i think people pretty much pick whichever one seems like it will be most convenient, and switch it if it proves wrong
00:37:46 <mwhit> it's pretty much ad-hoc afaik
00:49:37 <randen> edwardk: Should lens-4.3.3 be dependent on >= semigroupoids-4.2? I'm hitting a Duplicate instance declaration if I try to (inadvertently) nail down lens while letting semigroupoids version float in my cabal file.
00:51:16 <nathanielchannin> Which version of GHC should I be using?
00:54:31 <randen> nathanielchannin: GHC 7.8.3 is the latest, greatest.
00:59:03 <endlesswoe> anyone know of Humasect?
01:11:01 <Th3On> Hello everyone!
01:11:19 <Th3On> How can I mark my function as unused for GHC so I suppress the warning for that function?
01:16:06 <c_wraith> Th3On: GHC suppresses unused warnings for identifiers that start with _
01:16:47 <kvanb> TIL
01:16:53 <kvanb> thanks c_wraith
01:20:14 <angerman> So I tried yesod with fay and fay-jquery, but the resulting (generated) javascript ends somewhere in the middle.
01:20:24 <angerman> rendering the generated javascript invalid :(
01:22:46 <dmwit> trap_exit: A good rule of thumb is to put the argument that varies most last.
01:23:39 <dmwit> trap_exit: For functions that "modify an object", that generally happens to coincide with your suggestion that argument order is "backwards" compared to, say, Java.
01:24:01 <dmwit> (Since it's quite normal to apply the same modification to many objects, this generally means the object varies most.)
01:24:13 <trap_exit> dmwit: that makers sense
01:24:15 <trap_exit> I like the "modifies most" metric
01:24:39 <trap_exit> dmwit: why is your nick dmwit, you're more than a letter away from dimwit
01:24:48 <dmwit> thanks =)
01:24:53 <trap_exit> (sorry, bad pun, late at night)
01:25:14 <trap_exit> dmwit: what should I do for objects that have type IO ()
01:25:18 <trap_exit> so I have something that's like
01:25:25 <trap_exit> thread_send :: Msg -> ThreadState -> IO ()
01:25:30 <trap_exit> or thread_send :: ThreadState -> Msg -> IO ()
01:25:44 <dmwit> Well.
01:25:47 <trap_exit> so the "ThreadState" is some structure that has a TBQueue buried inside of it
01:25:54 <dmwit> The return type must always be in the return type position of the type.
01:25:56 <trap_exit> technically, it doesn't change, but it's got something that changes buried inside of it
01:26:07 <trap_exit> the return type is IO () ... nothing is returned
01:26:21 <dmwit> Oh, I think you misunderstood my proposed rule of thumb.
01:26:38 <trap_exit> http://www.haskell.org/hoogle/?hoogle=putMVar ... seems inconsistent
01:26:41 <trap_exit> it's MVar a -> a -> IO ()
01:26:41 <dmwit> When I say "varies most" I don't mean "which bit gets changed before returning".
01:26:59 <trap_exit> is putMVar consistent with your rule of thumb ?
01:27:05 <dmwit> I mean "which bit is most likely to change if we call this function again?".
01:27:17 <trap_exit> oh
01:27:45 <dmwit> It's quite common to write to a single MVar many times.
01:27:53 <dmwit> So the "written value" varies most.
01:27:56 <trap_exit> so it's not _the arg_ that is changed, it's "suppose we traced 10000 calls to this function; which arg has the largest # of different values it's called with"
01:28:01 <trap_exit> then, put that argument last ?
01:28:04 <dmwit> right
01:28:17 <dmwit> The idea being that this makes your function "work with currying" the best.
01:28:58 <trap_exit> dmwit: hmm, that makes sense; thanks :-)
01:29:41 <kvanb> https://github.com/haskell/bytestring/blob/2530b1c28f15d0f320a84701bf507d5650de6098/Data/ByteString/Internal.hs#L599-L634
01:30:05 <kvanb> I have never seen such evil
01:30:17 <kvanb> as that which I do gaze upon now
01:30:56 <dmwit> I don't really understand why it's so evil.
01:30:56 <ddere> lol
01:31:08 <dmwit> So I just avoid unsafePerformIO and its friends entirely.
01:31:20 <kvanb> dmwit: it tears apart ghcs representation of IO
01:31:25 <kvanb> and throws away the stateful part
01:31:48 <dmwit> That sounds bad and all. But I don't understand GHC well enough to truly appreciate how awful, I suspect.
01:31:56 <kvanb> it's just inlinePerformIO
01:32:05 <kvanb> with a really dangerous sounding name
01:32:09 <trap_exit> yeah
01:32:10 <trap_exit> why is this bad
01:32:11 <kvanb> and they DEPRECATED the original below
01:32:24 <trap_exit> is this #define TRUE FALSE bad, or #define while if bad ?
01:32:28 <c_wraith> trap_exit: it links to a bunch of bugs it's caused
01:32:40 <kvanb> it causes order of operations to break
01:32:41 <kvanb> basically
01:32:49 <c_wraith> trap_exit: ultimately, it's subverting assumptions GHC makes about purity.
01:32:50 <dmwit> trap_exit: Oh, no, I understand enough to answer that. It's a completely different kind of bad than what you get with #define.
01:32:53 <kvanb> its nothing like lazy IO or unsafe IO
01:32:56 <kvanb> it's out of order IO!
01:33:14 <dmwit> trap_exit: It's like, reach into your memory and rearrange where pointers point in the middle of program operation bad.
01:33:16 <kvanb> that could be thrown away
01:33:21 <kvanb> or ignored by the gc
01:33:33 <kvanb> or done immediately or even in 10 years time
01:33:43 <dfeuer_> kvanb, what there looks evil to you?
01:34:06 <kvanb> huh?
01:34:25 <trap_exit> wait
01:34:28 <trap_exit> so all it does is rearrange IO ?
01:34:30 <kvanb> (IO m) = case m realWorld# of is what I think is most evil
01:34:39 <kvanb> trap_exit: read about inlinePerformIO
01:35:48 <dfeuer_> Oh my. That is pretty scary.
01:36:02 <dfeuer_> That's reminiscent of the acme-realworld package.
01:37:12 <dfeuer_> I love that comment that ends "If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
01:38:17 <kvanb> haha yeh
01:38:19 <kvanb> *yeah
01:38:30 <merijn> kvanb: inlinePerformIO is no accursedUnutterablePerformIO :p
01:38:34 <merijn> awww, too slow
01:39:04 <kvanb> merijn: isn't that the intention?
01:39:04 <kvanb> inlinePerformIO = accursedUnutterablePerformIO
01:39:13 <kvanb> {-# DEPRECATED inlinePerformIO ... #-}
01:39:16 <merijn> s/no/now
01:39:25 <kvanb> oh
01:40:35 <dfeuer_> What does accursedUnutterablePerformIO even do?
01:42:02 <lfairy> dfeuer_: it tells the compiler to treat IO as pure code
01:42:25 <lfairy> including optimizing it as such
01:43:24 <dfeuer_> lfairy, what guarantees does unsafePerformIO offer that accursedUnutterablePerformIO does not?
01:44:05 <lfairy> dfeuer_: 1) the thunk is only evaluated once, and 2) anything in the IO block can't be lifted out of it
01:44:29 <lfairy> (1) is important for global IORefs
01:44:51 <lfairy> (2) is important for anything that calls malloc
01:44:52 <dfeuer_> lfairy, huh, I didn't realize unsafePerformIO guaranteed that the IO would only happen once.
01:45:05 <shachaf> It doesn't.
01:45:22 <dfeuer_> OK. So what am I missing?
01:45:35 <lfairy> I mean if two threads force the same thunk, the second will block rather than re-executing it
01:45:44 <shachaf> Yes, that's true.
01:46:10 <shachaf> But something defined with unsafePerofmrIO can still get inlined and then you just end up with two thunks.
01:46:15 <lfairy> Yeah, that
01:46:45 <dfeuer_> Ugh.
01:47:00 <shachaf> You need to understand GHC black hole behavior.
01:47:09 <dfeuer_> So why does bytestring use this accursed one?
01:47:26 <shachaf> Sometimes you don't care if IO happens twice.
01:47:27 <lfairy> Because reading from a buffer requires neither of the guarantees
01:47:37 <dfeuer_> The accursed one preserves the blackholing thing, right? Or does it completely scribble RAM?
01:47:49 <dfeuer_> Ah.
01:48:55 <dfeuer_> So what makes the Dupable different from the accursed?
01:49:14 <lfairy> Dupable still preserves (2)
01:50:08 <dfeuer_> *shudder*
01:50:25 <merijn> dfeuer_: There's a reason for the name :)
01:50:51 <merijn> dfeuer_: Another fun name (unfortunately it has since been removed from the quicktest API) was "morallyDubiousIOProperty" :)
01:51:18 <lfairy> dfeuer_: :D
01:53:22 <dfeuer_> I just didn't realize there was actual production code doing the sort of thing you find in acme-realworld.
01:53:28 <Iceland_jack> merijn: You mean QuickCheck :)
01:53:53 <dfeuer_> What was morallyDubiousIOProperty?
01:54:05 <merijn> dfeuer_: Pretended IO was pure and tested it :p
01:54:18 <merijn> Iceland_jack: It's 10 11 AM on saturday, typing is hard :p
01:54:21 <dfeuer_> Uh ... how?
01:54:32 <merijn> "just run it and see if it matches"
01:55:19 <Iceland_jack> dfeuer_: You can check the source! It still exists but under a different name
01:55:22 <Iceland_jack> ‘ioProperty’
01:55:23 <dfeuer_> Speaking of weird functions, I encountered a sort of unsafe address-hashing "function" and couldn't figure out what it could be good for. Two things hashing to the same value doesn't mean they're equal, and hashing to different values doesn't mean they're different.
01:55:37 <angerman> can I change within the repl into a module to call a function, even though that module does not export that function?
01:55:53 <Iceland_jack> dfeuer_: http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Property.html#ioProperty
01:56:09 <merijn> angerman: Yes, if you load the source file, rather than importing
01:56:12 <Iceland_jack> But you should seriously consider using Test.QuickCheck.Monadic if you want to test IO actions
01:56:31 <dfeuer_> THanks, Iceland_jack.
01:57:14 * hackagebot cndict 0.2.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.0 (DavidHimmelstrup)
01:57:36 <Iceland_jack> dfeuer_: I wrote modest documentation for Test.QuickCheck.Monadic and some other modules since it's not as well known as it deserves to be imo
01:57:53 <angerman> merijn, hmm it's a package from cabal
01:57:57 <jle`> do you guys think the new HP will come out before sunday is out
01:58:01 <Iceland_jack> hasn't made it to Hackage but it's on the GitHub repository
01:58:05 <jle`> so i can download it before i leave on vacation
01:58:26 <dmwit> angerman: Assuming module Foo is loaded, :m *Foo will put everything in Foo in scope, ignoring export lists.
01:58:32 <lfairy> jle`: Since there's already an RC, it could have come out already!
01:58:35 <lfairy> Nobody knows!
01:58:44 <dmwit> angerman: But you need the source to load a file.
01:58:52 <dmwit> s/file/module/
01:59:22 <jle`> :O
01:59:32 <jle`> i wonder if i should just download the RC
01:59:39 <dfeuer_> Iceland_jack, I don't have any immediate plans to quickcheck any IO, but I'll try to keep it in mind.
01:59:43 <angerman> dmwit: ahh thanks. damn :(
01:59:56 <jle`> i'm going to be going places without internet so i was hoping i could download enough of hackage onto my laptop to not need the server
02:00:08 <dfeuer_> Without Internet?
02:00:14 <dfeuer_> Where are you going jle`?
02:00:20 <trap_exit> yeah
02:00:22 <trap_exit> do you have cell service
02:00:31 <trap_exit> I installed ghcjs, three times, over cell phone tethering
02:00:36 <dmwit> yes... let's recommend downloading the HP over the cell network
02:00:36 <jle`> well, i'll have internet, but it might be choppy
02:00:38 <dmwit> good thinking
02:00:48 <jle`> i'll be heading around asia
02:00:52 <dfeuer_> Satellite phone? Modem over POTS?
02:00:58 <trap_exit> haskell platform is what, 200 MB?
02:01:02 <trap_exit> that's not much over tethering
02:01:09 <dmwit> Why not go straight to IP over carrier pigeon?
02:01:29 <jle`> so that's what TCP means
02:01:29 <trap_exit> I'm pretty sure it's easier to buy a cell phone
02:01:31 <trap_exit> than to train pigeons
02:01:37 <jle`> trained carrier pidgeons
02:01:37 <dmwit> Methinks sneakernet -- essentially what jle` is proposing anyway -- is a pretty good tradeoff in lots of situations.
02:01:43 <dfeuer_> dmwit, that'd be much faster than a 9600 baud modem.
02:02:00 <jle`> it's just i usually do 100% of my dev over ssh on my stateside server
02:02:10 * dfeuer_ can't remember how fast his first modem was. It was definitely between 2400 and 9600.
02:02:15 <jle`> so i'm a little freaked out about doing haskell dev on my laptop alone
02:02:20 <jle`> i've never tried it before
02:02:21 <angerman> dmwit, can I somehow instruct cabal, to install a package as source/
02:02:24 <trap_exit> oh, I can't develop over tethering
02:02:30 <trap_exit> but I have a virtual box VM that has all my ashekll stuff
02:02:37 <dmwit> angerman: You can use "cabal unpack".
02:02:47 <dmwit> angerman: Which will create a directory with a package's source in it.
02:03:23 <merijn> dmwit: cabal unpack is deprecated, cabal get is the new way, iirc
02:03:53 <dmwit> oh
02:04:00 <dmwit> Alright, then. Why?
02:05:48 <merijn> God knows, I just remember cabal starting to yell at me around 1.18 or so :p
02:06:52 <alpounet> dmwit: cabal get also supports fetching from git/darcs repos
02:06:59 * angerman is stuck again.  Yikes, what am I doding?  So here's my issue, the javascript source, that yesod produces for fay, is trunacated, in Yesod.Fay is a function compileFayFile, which looks like a good fist step to see where things go wrong.  But compileFayFile is not exported.  Now I have yesod-fay-0.5.2 in my direcotry, and feel stupid for now knwing how to make the repl get me in there :(
02:07:04 <alpounet> so here 'get' is more general than unpack
02:08:08 <jle`> trap_exit: oh that's a nice idea
02:08:13 <vlatkoB> Can someone explain the reasoning why traversal for tuple is defined as "traverse f (x, y) = (,) x <$> f y"? Why not "(,) f x <$> f y"?
02:08:14 <dmwit> angerman: cd yesod-fay-0.5.2, then cabal repl
02:08:47 <shachaf> vlatkoB: Simplify by understanding Functor rather than Traversable.
02:08:56 <angerman> dmwit does that workw ith the cabal sandbox in the parent folder?
02:08:58 <shachaf> (What you wrote is a type error anyway.)
02:09:06 <dmwit> vlatkoB: Easy answer: because only the last type variable actually varies.
02:09:13 <shachaf> It works that way because that's the only way it could work. Try writing your instance, see what happens.
02:09:21 <dmwit> angerman: I don't know anything about sandboxes.
02:09:52 <dmwit> vlatkoB: The instance is for Applicative ((,) a), not Applicative (,) (and the latter would be a kind error).
02:10:16 <dmwit> vlatkoB: You could perhaps define data Pair a = Pair a a and then make an instance Applicative Pair with behavior like you described.
02:10:35 <shachaf> Or you could give up on the type class approach and define your traversals explicitly.
02:10:39 <vlatkoB> Again I missed the obvious. Spend some time yesterday with similar for (Const a).
02:11:20 <dmwit> Ooops, this is about Traversable instead of Applicative. I'm glad you figured it out anyway.
02:11:30 <zq> i need o(1) char access
02:11:34 <zq> what do
02:11:43 <jle`> text?
02:11:55 <dmwit> zq: Enjoy your vector of Word32's.
02:11:56 <zq> data.text? linear time access
02:12:05 <shachaf> little o of 1? You can't get that, sorry.
02:12:22 <zq> shachaf: my capslock is broken
02:12:39 <zq> dmwit: is that really the only option? to resort to vectors?
02:13:09 <dmwit> or Array
02:13:26 <dmwit> ...or a HashMap, I suppose, if you're feeling a bit pythonic.
02:13:35 <zq> luls
02:13:38 <zq> hashmap
02:15:10 <zq> "A time and space-efficient implementation of Unicode text using lists of packed arrays" <- why can't i just access the underlying array?
02:15:33 <dmwit> If you could, what good would that do you?
02:15:43 <zq> o(1) access!
02:15:52 <dmwit> no
02:15:57 <dmwit> lern2unicode
02:16:29 <dmwit> I am assuming you are referring to the "text" package here.
02:16:54 <zq> yessir
02:16:56 <dmwit> Actually, I guess even a packed array of Char/Word32 isn't good enough to get O(1) access.
02:17:01 <dmwit> Because Unicode.
02:17:06 <dmwit> text is complicated
02:17:19 <zq> why word32? doesn't data.text use utf-16?
02:17:45 <dmwit> Data.Text doesn't offer O(1) access. So if you want that, you'll have to do *something* differently than text does.
02:18:19 <zq> i should rephrase: wouldn't word16 be sufficient?
02:18:23 <dmwit> no
02:18:30 <dmwit> Any other questions?
02:18:59 <shachaf> dmwit: I'd object, but zq started with the 4chanisms in the first place.
02:19:29 <dmwit> Alright, alright, I repent.
02:19:38 <dmwit> zq: The thing is that UTF-16 is a variable-length encoding.
02:19:46 <zq> what what no
02:19:51 <zq> i thought that was utf-8
02:19:52 <dmwit> That's (one) core reason you can't get O(1) access with it.
02:20:00 <dmwit> UTF-8 is also variable-length, yes.
02:20:08 <zq> meh, got it
02:20:14 <dmwit> > logBase 2 (ord maxBound) > 16
02:20:15 <zq> thanks.
02:20:16 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
02:20:17 <lambdabot>    arising from a use of ‘GHC.Float.logBase’
02:20:27 <dmwit> > logBase 2 (fromIntegral (ord maxBound)) > 16
02:20:29 <lambdabot>  True
02:20:35 <shachaf> I don't think you're obligated to explain this in much detail, especially with the person you're explaining to being pretty rude, but "lern2unicode" is a bit rude in its own right.
02:20:51 <dmwit> Yes, I agree.
02:20:53 <dmwit> That wasn't nice.
02:24:16 <dmwit> > ord maxBound > 2^16 -- much more beautiful
02:24:18 <lambdabot>  True
02:25:06 <Trollinator> is there a way to find out whether an operator is infixl or infixr in ghci?
02:25:12 <shachaf> :i
02:25:13 <zq> Trollinator: :i
02:25:31 <Trollinator> cool
02:25:35 <Trollinator> thanks.
02:41:23 <tac> Is there an option to allow orphan instances of typeclasses?
02:42:24 <tac> -fno-warn-orphans
02:43:39 <hask3> Can someone explain to me what mechanism actually exists this program when END-OF-FILE is reached? https://pastee.org/exgyy
02:43:39 <hask3> I don't see where that could occur.
02:44:12 <hask3> Does getContents exit the program when that happens?
02:45:51 <earthy> nope. The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin).
02:46:21 <earthy> i.e.: the result of getContents is a lazy string that is defined to only end when the input ends.
02:46:42 <hask3> earthy: ok, i see.
02:47:41 <earthy> EOF signals end of input, so signals the end of the string
02:48:09 <hask3> earthy: my other question is, when I type the input myself, what mechanism causes it to process the string line-by-line? Does getContents do that internally?
02:48:10 <hask3> And, when I instead redirect a file to the program "program < file.txt", does getContents automatically divide it into chunks, some kind of maximum sized buffers?
02:48:29 <ph88> hey guys. I have made an important function in one file. And now i would like to use it in another file. How can i do this ?
02:48:32 <Chousuke> hask3: some sort of buffering probably.
02:48:43 <earthy> um. not necessarily. that is an implementation detail that you are not informed of.
02:48:53 <hask3> ok
02:49:16 <earthy> and it might not, if you later require access to the entire string at once.
02:49:22 <earthy> and it might, if you don't.
02:49:34 <earthy> and the *compiler* is allowed to optimize for both cases for you :)
02:49:53 <hask3> earthy: cool
02:49:53 <ClaudiusMaximus> ph88: put  module Foo where  at the top of Foo.hs, then in Bar.hs add   import Foo  before the first definition
02:50:23 <earthy> hask3: if you want more control, look into Data.ByteString and Data.ByteString.Lazy
02:50:27 <Chousuke> the contract for the function says that you get the entire contents as a lazy string, so you shouldn't depend on any behaviour on how much input is actually processed at one time.
02:50:54 <hask3> earthly, i'm starting to get it. but: after the program processes "contents <- getContents" and goes to the next line, where does it actually "store" the input for later ACTUAL reading of it?
02:50:56 <earthy> Chousuke: you *can't* even :)
02:50:59 <hask3> that confuses me
02:51:08 <ClaudiusMaximus> hask3: what about   main = interact (map toUpper)  -- shorter and less confusing lazy IO issues
02:51:09 <earthy> hask3: it might not even 'store' it at all
02:51:14 <Chousuke> earthy: you can, but then the program would have a bug :P
02:51:26 <hask3> so how does it know where to get the input again, after it discarded the input?
02:51:36 <hask3> it just made it "lazy", so where did the input go
02:51:45 <earthy> hask3: it won't discard the input if you may still reference it
02:52:07 <earthy> basically it builds an intermediate structure containing as much of the input as you can still reference
02:53:24 <earthy> the map defines a transformation over that structure, the putStr then walks that structure
02:53:53 <earthy> the trick is that the putStr 'drives' the 'construction' of the structure
02:54:10 <earthy> ofcourse, this can just be a simple buffer that is read in a loop
02:54:24 <earthy> but that is an implementation detail that you are not made aware of
02:54:33 <hask3> ok, i see
02:54:35 <earthy> it might also simply read everything in memory and process it afterwards.
02:54:45 <hask3> earthy: yeah if it's small enough
02:55:00 <Chousuke> hask3: Lazy IO has some caveats that the basic IO functions don't even try to solve. It's fine for simple stuff, but there are better libraries for real applications.
02:55:02 <earthy> well, the compiler would be buggy if it did that. ;)
02:55:25 <earthy> unless the system you are on never has files bigger than memory ;)
02:56:04 <hask3> I'm wondering, is getContents aware of the fact that the program is running in user-input mode (where it reads line-by-line) or file redirection mode (where it uses buffering/whatever)?
02:56:17 <earthy> hask3: probably.
02:56:19 <hask3> ok
02:56:26 <earthy> once again: that is an implementation detail. :)
02:56:35 <hask3> lol ok
02:56:42 <hask3> i worry too much
02:56:54 <earthy> you are not given any guarantee beyond 'eventually you're given everything'
02:57:20 * hackagebot pathtype 0.5.4 - Type-safe replacement for System.FilePath etc  http://hackage.haskell.org/package/pathtype-0.5.4 (BenMoseley)
02:57:22 <earthy> not even that it will fit in memory :)
02:57:44 <hask3> i see
02:58:00 <hask3> thanks, this helped
02:58:03 <hask3> a lot
03:07:37 <dmwit> erm
03:08:47 <dmwit> Depends what level you operate at, I guess, but at some levels what buffering is being used is definitely not just an implementation detail.
03:09:36 <dmwit> You can choose which kind of buffering you want.
03:10:01 <dmwit> If you don't choose, I think the defaults are line-buffered for compiled programs and unbuffered for ghci.
03:10:02 <hask3> dmwit: well all i really need to know personally is, it won't be like huge 1 GB buffers will they? they're probably less than 1 MB each?
03:10:08 <hask3> just wanna know if things are "reasonable"
03:10:43 <dmwit> You can ask for block buffering of a preferred size if that's a concern.
03:10:44 <hask3> but for me it will be truly convenient to get this laziness for free
03:11:06 <hask3> dmwit: ok
03:11:35 <dmwit> There's something funny about how that interacts with encoding that I haven't bothered to look into, but could be something to think about briefly if you anticipate problems there.
03:12:10 <latk> What is the simplest way to convert a lazy bytestring to a strict bytestring ?
03:13:09 <dmwit> latk: mconcat . toChunks
03:13:59 <dmwit> latk: But even simpler is to produce a strict bytestring in the first place.
03:14:08 <dmwit> (not always possible)
03:15:10 <latk> dmwit: Sadly not possible in this case. I'm sure there are good reasons for it, but there isn't much consistency between libraries for use of lazy vs strict bytestrings.
03:15:24 * dmwit nods agreeably
03:16:42 <hask3> i will at some point want to read csv files. are there good fast ready-made functions for that or should i make my own?
03:16:44 <hask3> using getContents?
03:17:00 <dmwit> There are a few CSV parsers on Hackage.
03:17:30 <dmwit> http://hackage.haskell.org/packages/search?terms=csv <- ouch, maybe there's even too many
03:17:40 <hask3> dmwit: but i assume these really have nothing to do with IO, right? it's just functions that reads strings and parses them. so getContents would be called first to get the string. and then the csv parsers
03:17:42 <dmwit> I'm not experienced here, so I can't make a good recommendation.
03:17:56 <dmwit> hask3: Yes, that's the usual pattern.
03:17:59 <hask3> ok thanks
03:18:19 <dmwit> hask3: It looks like there are a few there designed to work with pipes/conduits, in which case you use a pipe/conduit instead of getContents.
03:18:58 <hask3> ok
03:27:21 <trap_exit> is there a way to go haskell => android app without going through ghcjs? My current approach is haskell => ghcjs => javascript => phonegap => android app. I would prefer something slightly more direct, like "haskell => android app"
03:29:17 <jle`> due to referential transparency, those should be semantically identical ;)
03:31:08 <angerman> So how do I figure out where haskell truncates a file (or better why? It looks like it generates most of the time only 6826 byte large files for me.)
03:39:51 <merijn> trap_exit: People are working on compiling haskell to ARM (so iOS, but also some android), but it's all rather experimental and brittle still
03:46:56 <trap_exit> merijn: best = ajhc ?
03:47:05 <kvanb> ajhc is great
03:47:10 <kvanb> beats ghc in some tiny benchmarks
03:47:20 <kvanb> it does a better job of deep nested data
03:47:27 <latk> Is it possible to have multiple testsuites in a .cabal file ?
03:49:37 <merijn> trap_exit: I meant people working on using GHC to cross-compile to ARM
03:49:49 <merijn> latk: I think so? Just try :p
03:52:11 <trap_exit> damn it, does https://hackage.haskell.org/package/containers-0.3.0.0/docs/Data-Map.html have a "empty" as in create an empty map function?
03:52:38 <trap_exit> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html#v:empty
03:52:40 <trap_exit> I'm an idiot
03:53:35 <merijn> Also pretty sure that Control.Applicative.empty also works
03:53:53 <merijn> > Control.Applicative.empty :: M.Map Int Char
03:53:55 <lambdabot>  No instance for (Control.Applicative.Alternative
03:53:56 <lambdabot>                     (Data.Map.Base.Map GHC.Types.Int))
03:53:56 <lambdabot>    arising from a use of ‘Control.Applicative.empty’
03:53:57 <merijn> aww
03:54:03 <trap_exit> merijn -- :-)
03:54:36 <merijn> Map is not an Applicative? I though it would be...
03:54:52 <merijn> oh, just Functor
03:55:31 <latk> merijn: Hah, yeah fair point :P
03:55:46 <merijn> Shouldn't it be possible to define an Applicative? I'm too lazy to go and check the laws (or rather, I have to work :\)
03:56:10 <gfixler> jle`: thanks for pointing me to adit's pictures tutorial; I feel like I've grokked functors, applicatives, and monads all in one day
03:56:22 <merijn> latk: I think the only restriction is that cabal files can have at most 1 library, they can have any number of executables, so I don't see why not test suites
03:56:22 <gfixler> (I'm sure that's not actually true)
03:56:37 <supki> merijn: it's not possible to define pure for Map
03:56:50 <merijn> supki: Good point
03:56:55 <jle`> gfixler: np :)  glad it helped!  just remember the warnings i suggested
03:57:04 <merijn> supki: Couldn't you define "instance Monoid k => Applicative (Map k)"?
03:57:27 <merijn> Although I guess that's probably not very useful :D
03:58:33 <gfixler> jle`: yep, but it was a very good starting point
03:58:40 <merijn> gfixler: Quick homework as test for understanding them: Figure out why "data Const a b = Const a" 1) can be a functor 2) Can be an applicative IFF 'a' is a Monoid and 3) why it can't be a monad
03:58:58 <gfixler> ooh, homework - I was hoping for some, believe it or not
03:59:08 <merijn> gfixler: Easiest way is to try and implement those things and prove the relevant laws
03:59:59 <supki> merijn: what would <*> do?
04:00:12 <merijn> supki: ZipList for Map?
04:00:26 <merijn> Actually
04:00:43 <merijn> Wait, I think you totally could implement pure, just perhaps not with the current definition
04:00:56 <merijn> i.e. "pure x" is the Map that has 'x' for every key
04:01:02 <merijn> That'd be a much nicer definition
04:01:24 <merijn> Although I guess we'd needa "default map" like python's "defaultdict" for that
04:01:53 <jle`> how about type Map = (->)
04:01:55 <jle`> ;)
04:02:21 <merijn> See, I knew that Applicative for Map made sense, I'm just not sure it's implementable in Haskell with the current definition of Map
04:04:06 <merijn> jle`: Not good enough
04:04:31 <merijn> jle`: You'd need "type Map = Kleisli Maybe"
04:06:34 <merijn> I guess "newtype DefaultMap k a = DefaultMap (Maybe a, Map k a)" is good enough to implement Applicative and using findWithDefault if the first is "Just x"
04:12:26 * hackagebot lens 4.3.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.2 (EdwardKmett)
04:12:28 * hackagebot lens 4.3.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.1 (EdwardKmett)
04:13:56 <edwardk> merijn: its sort of good enough to do so. but the cost is Foldable/Traversable make no sense now
04:14:01 <beaky> hello
04:14:26 <beaky> should i ever define a typeclass or instance one
04:15:19 <gfixler> merijn: speedbump right out of the gate
04:15:25 <gfixler> instance Functor (Const a) where fmap f (Const a) = Const (f a)
04:15:37 <gfixler> this does not work
04:15:55 <edwardk> gfixler: its already defined in base
04:16:05 <edwardk> but its not that functor
04:16:40 <gfixler> edwardk: I'm not sure that that means
04:16:50 <darthdeus> is there a division function that works both for Int and Float?
04:16:54 <edwardk> gfixler: newtype Const a b = Const a
04:17:00 <edwardk> fmap changes the second arg
04:17:10 <edwardk> what does it change the right hand side to?
04:17:27 * hackagebot lens 4.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3 (EdwardKmett)
04:17:29 * hackagebot lens 4.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.2 (EdwardKmett)
04:17:31 * hackagebot lens 4.1.2.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.2.1 (EdwardKmett)
04:17:33 * hackagebot lens 4.1.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.2 (EdwardKmett)
04:17:34 <darthdeus> I have a data type which has both Int and Float and I need to pass in a funciton that I apply to both of it's values, and that function needs to be doing division :|
04:17:35 * hackagebot lens 4.1.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1.1 (EdwardKmett)
04:18:13 <gfixler> edwardk: instance Functor (Const a) where fmap f (Const a) = Const a
04:18:16 <gfixler> ?
04:18:18 <edwardk> yep
04:18:22 <gfixler> doh
04:18:25 <gfixler> it's even called Const
04:18:26 <edwardk> that is the definition in base
04:18:29 <edwardk> =)
04:18:33 <edwardk> the other one is called Identity
04:18:36 <gfixler> in my defense it's after 4AM here :)
04:18:41 <edwardk> and has no second arg
04:18:58 <edwardk> if you want two args and be missing the first one the tagged package has "Tagged"
04:19:41 <jle`> beaky: it's uncommon to need to write a typeclass in almost all of beginning/intermediate haskell.  writing instances is probably more common
04:19:55 <beaky> ah
04:20:12 <beaky> so i shouldnt feel bad if i never define my own typeclasses
04:20:14 <gfixler> edwardk: is the b in there for fmap's sake?
04:20:44 <edwardk> gfixler: no you can have a thing that has nothing in it too
04:20:44 <jle`> beaky: in fact, you really need really really really good excuses before you even think about writing a typeclass
04:20:49 <edwardk> data Proxy a = Proxy
04:20:52 <beaky> what kind of excuse
04:21:01 <edwardk> instance Functor Proxy where fmap _ Proxy = Proxy
04:21:11 <edwardk> that i have in tagged as well, but we moved it to base in 7.8
04:21:18 <edwardk> under Data.Proxy
04:21:48 <jle`> beaky: heh.  it varies.  but the point was that your "default" should be not making a typeclass, and making a typeclass is the last-resort kinda thing.
04:22:08 <gfixler> edwardk: I guess what I'm wondering is why Const a b and not just Const a?
04:22:25 <jle`> at least until you one day understand why new typeclasses are a bad idea for almost all situations
04:22:31 <edwardk> we need an arg to fmap over if you want it to be a functor
04:22:31 <gfixler> was it just merijn's homework problem, or is there a reason for that b to be in there?
04:22:37 * hackagebot lens 4.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.1 (EdwardKmett)
04:22:39 * hackagebot lens 4.0.7 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.7 (EdwardKmett)
04:22:39 <edwardk> we want a functor that doesn't use its argument
04:22:41 * hackagebot lens 4.0.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.6 (EdwardKmett)
04:22:43 * hackagebot lens 4.0.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.5 (EdwardKmett)
04:22:45 * hackagebot lens 4.0.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.4 (EdwardKmett)
04:22:46 <merijn> gfixler: That b was there intentionally, yeah
04:22:47 <edwardk> it is actually a big part of how lens works
04:22:53 <merijn> gfixler: Sorry, was looking a way
04:22:58 <gfixler> merijn: no worries
04:23:01 <edwardk> :t traverse
04:23:03 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:23:07 <edwardk> :t getConst . traverse Const
04:23:08 <lambdabot> (Monoid c, Traversable t) => t c -> c
04:23:35 <gfixler> I think part of the confusion for me sometimes is these non-descriptive letters
04:23:36 <edwardk> > getConst (traverse Const ["hi","gfixler"])
04:23:38 <lambdabot>  "higfixler"
04:23:41 <merijn> gfixler: Oh, edwardk already explained :)
04:23:49 <edwardk> > runIdentity (traverse Identity ["hi","gfixler"])
04:23:51 <lambdabot>  ["hi","gfixler"]
04:24:09 <edwardk> > runIdentity (traverse (Identity . succ) ["hi","gfixler"])
04:24:11 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
04:24:11 <lambdabot>    arising from a use of ‘GHC.Enum.succ’
04:24:14 * gfixler is now shoveling this into his 4:22AM brain...
04:24:26 <merijn> gfixler: The use of Const is not immediately obvious (but it does a lot of heavy lifting in lens, for example, so edwardk is the prime person to ask about it's uses ;)
04:24:31 <edwardk> > runIdentity (traverse (traverse (Identity . succ)) ["hi","gfixler"])
04:24:33 <lambdabot>  ["ij","hgjymfs"]
04:24:51 <merijn> gfixler: The reason I picked it is that it's a very "easy" type, but it immediately trashes this whole "Functors are containers" idea :)
04:24:58 <gfixler> merijn: yeah, I'm gathering that edwardk is a library author
04:24:59 <edwardk> > getConst (traverse (traverse (Const . succ)) ["hi","gfixler"])
04:25:01 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Char)
04:25:01 <lambdabot>    arising from a use of ‘Data.Traversable.traverse’
04:25:18 <merijn> gfixler: Because the fmap type works on Const's b and Const doesn't actually have a 'b' value :)
04:25:20 <edwardk> > getConst (traverse (Const . succ)) ["hi","gfixler"])
04:25:22 <lambdabot>  <hint>:1:52: parse error on input ‘)’
04:25:23 <gfixler> merijn: cool - I'm totally down with functors not being containers
04:25:30 <edwardk> > getConst (traverse (Const . succ) ["hi","gfixler"])
04:25:32 <lambdabot>  No instance for (GHC.Enum.Enum [GHC.Types.Char])
04:25:32 <lambdabot>    arising from a use of ‘GHC.Enum.succ’
04:25:35 <merijn> gfixler: This, incidentally is also the reason why Const can't be a Monad, but no spoilers on that front yet :)
04:25:47 <edwardk> > getConst (traverse (Const . (fmap succ)) ["hi","gfixler"])
04:25:49 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
04:26:08 <edwardk> anyways, Const can be used to read from traverse/mapM   while Identity can be used to write
04:26:12 <edwardk> we have Data.Traversable
04:26:15 <edwardk> it provides traverse
04:26:21 <edwardk> but the class in it has two superclasses
04:26:46 <gfixler> merijn: no worries - I'm not keeping up at the moment, so spoilers would pass right over me :)
04:26:55 <edwardk> class (Functor t, Traversable t) => Traversable t where traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
04:27:39 <edwardk> now, given traverse, we want to implement fmapDefault :: Traversable t => (a -> b) -> t a -> t b   and foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
04:27:43 <jle`> darthdeus: i don't think there is one, but you can probably toIntegral . f . fromIntegral, even thgouh it's not too efficient
04:27:47 * hackagebot lens 4.0.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.3 (EdwardKmett)
04:27:49 * hackagebot lens 4.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.2 (EdwardKmett)
04:27:51 * hackagebot lens 4.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0.1 (EdwardKmett)
04:27:51 <edwardk> these provide proofs that everything traversable should be able to be instances of the two superclasses
04:27:53 * hackagebot lens 4.0 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0 (EdwardKmett)
04:27:55 <edwardk> 'traverse is enough'
04:28:11 <edwardk> the proof uses Identity for one and Const m -- for some monoid for the other
04:28:27 <edwardk> as shown above i can change out the values like fmap with traverse using Identity
04:28:43 <edwardk> and i can smash things together in a monoid using Const
04:29:06 <edwardk> > fold ["hi","gfixler"]
04:29:07 <lambdabot>  "higfixler"
04:29:18 <edwardk> > fmap (fmap succ) ["hi","gfixler"]
04:29:20 <lambdabot>  ["ij","hgjymfs"]
04:29:35 <edwardk> > foldMap (fmap succ) ["hi","gfixler"]
04:29:37 <lambdabot>  "ijhgjymfs"
04:29:39 <edwardk> etc
04:29:54 <edwardk> above i defined those using traverse and those functors under discussion
04:32:28 * hackagebot lens 3.10.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.2 (EdwardKmett)
04:32:30 * hackagebot lens 3.10.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.1 (EdwardKmett)
04:32:32 * hackagebot lens 3.10.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.3 (EdwardKmett)
04:32:34 * hackagebot lens 3.10 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10 (EdwardKmett)
04:32:47 <jle`> edwardk are you a robot
04:33:04 <edwardk> i can neither confirm nor deny that
04:33:05 <jle`> how are you giving a full on tutorial on irc and then pushing lens at the same time
04:33:18 <jle`> :|
04:33:38 <jle`> oh something must be weird with hackagebot
04:33:54 <edwardk> no these are happening right now
04:34:21 <edwardk> hackagebot batches up every 5 minutes or so, but otherwise its going as i go
04:34:22 <jle`> is lens's versions in reverse numerical order?
04:34:35 <jle`> that must sort of throw off the whole SVP
04:34:49 <gfixler> edwardk: I'm too sleepy and tapped-out to grok all that you wrote tonight, but I've saved it, and I will be going through it soon - thanks for the help!
04:34:50 <edwardk> no, these are me patching out older releases to make them not blow up users
04:35:05 <jle`> ah i see
04:35:08 <gfixler> and merijn: thanks for the homework!
04:35:25 <jle`> i forgot that you could upload older versions to hackage
04:35:27 <edwardk> just capping older versions on older semigroupoids
04:35:32 <jle`> (of course, why not?)
04:35:43 <hask3> LYAH, only in the paper version (page 177), he says: "Your program may terminate if you try to open a file whose handle hasn't been closed."
04:35:43 <jle`> ic
04:35:44 <hask3> What does he mean?
04:36:35 <hask3> It's in the "More Input and More Output" chapter
04:36:55 <merijn> hask3: I'm guessing "crash"
04:37:08 <hask3> yes, but what causes it? what do i have to do to crash it?
04:37:24 <hask3> a file can have two handles simultatiously
04:37:28 * hackagebot lens 3.10.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.10.0.1 (EdwardKmett)
04:37:32 <hask3> so i don't know what he means
04:38:15 <edwardk> hask3: doesn't make sense to me either fwiw
04:38:29 <hask3> Here is more context: "You need to close the file yourself after opening it with openFile! Your program may terminate if you try to open a file whose handle hasn't been closed."
04:38:49 <hask3> Here, http://learnyouahaskell.com/input-and-output#files-and-streams he writes only "You have to close the file yourself after opening it with openFile!" but nothing after that
04:38:54 <hask3> maybe it's a mistake in the paper version?
04:39:25 <merijn> hask3: The documentation for openFile says: "isAlreadyInUseError if the file is already open and cannot be reopened;"
04:39:49 <merijn> hask3: It doesn't specify what "cannot be reopened" means, though, I'm guessing a permission change or something
04:40:03 <trap_exit> https://www.youtube.com/watch?v=ZR3Jirqk6W8#t=2148 <-- is quick check reall this fucking awesome ?
04:40:07 <trap_exit> what's so great about it
04:41:30 <vlatkoB> hask3: It means that if you have a file open (say a logger file), you cannot reopen it in another function (say to parse it).
04:41:46 <vlatkoB> opened
04:44:04 <hask3> import System.IO
04:44:05 <hask3> main = do
04:44:06 <hask3>   handle <- openFile "haiku.txt" WriteMode
04:44:07 <hask3>   handle2 <- openFile "haiku.txt" ReadMode
04:44:08 <hask3>   putStrLn "Hello"
04:44:18 <hask3> (sorry should have pastebinned that)
04:44:23 <hask3> vlatkoB: yeah you're right, that program errors!
04:46:56 <vlatkoB> hask3: It is possible, though. You can use System.Posix.IO and openFd in such cases.
04:47:09 <hask3> ok
04:57:25 <savask> Hello. Are there any works going on turning GHC into a supercompiler? I found a 5 year old TODO page and nothing more - does that mean that the idea was abandoned?
04:59:11 <edwardk> savask: it means the guy who was doing it is now making a bunch of money behind closed doors at standard chartered working on their stuff rather than ghc out in the public sphere ;)
04:59:51 <savask> edwardk: Oh, well :C I thought a couple of people were working on that.
04:59:52 <edwardk> there's been some work on alternate backends for ghc, folks working on an optimizing haskell compiler at intel that picks up from there, etc.
05:02:59 <orion> edwardk: Is Haskell proficiency proportional to salary in the real world?
05:03:34 <zomg> orion: I would imagine that depends on whether you're getting hired to write haskell or not
05:03:39 <Trollinator> if I had the chance to do haskell for a living, I wouldn't worry about the salary too much
05:04:23 <zomg> Same for me. It would probably pay at least the same as any other programming job, which in general has been good enough in my experience :)
05:05:20 <Trollinator> unfortunately, the best that seems to actually be used out there is Scala
05:05:27 <orion> I am still relatively new to Haskell, but from what I've experienced if someone said that they were an advanced Haskeller, I would have them at the top of my resume stack, even if we were using a different language.
05:06:01 <orion> I fee like Haskell separates the boys from the men.
05:06:03 <orion> feel
05:06:20 <Trollinator> isToyLanguage = (/= Haskell)
05:07:11 <orion> It's a weeding out language, much like organic chemistry is a weeding out course for chemists.
05:07:49 <hpc> i always throught physics was the weeding out course for chemistry :P
05:07:50 <zomg> Yeah I suppose that's true, it is still a bit of a niche language so if someone knows haskell it's probably a sign that they're interested in software dev in general
05:08:02 <hask3> Does a Haskell program automatically close open files if it terminates?
05:08:03 <Trollinator> actually that fact that this is so indicates that there isn't enough math in a CS curriculum
05:08:11 <hask3> (Or does the Unix system take care of that?)
05:08:17 <Trollinator> The kernel does that.
05:08:18 <merijn> hask3: unix takes care of that
05:08:29 <hask3> merijn: ok cool
05:08:30 <hpc> windows will take care of it too
05:08:35 <hask3> sweet
05:08:40 <Trollinator> that is, if there are no other processes that hold file descriptors for the same file
05:08:43 <hpc> but with some issues iirc
05:08:49 <k00mi> orion: that in turn would mean that haskell will never be a mainstream language because most programmers are by definition mediocre
05:09:19 <hask3> Trollinator: what do you mean other processes? i was talking about my particular haskell program..
05:09:26 <hask3> close those handles only
05:09:30 <hask3> from the haskell prog
05:09:51 <Trollinator> hask3: you might inherit a file descriptor when your program is launched.
05:10:04 <orion> k00mi: Good! I want to remain a Haskell Hipster.
05:10:16 <hask3> ok
05:10:38 <tcsavage> I'm currently profiling a program with -hy and it seems ->>(#,#) and MUT_ARR_PTRS_FROZEN are eating up most of my heap. Can somebody tell me what this means exactly?
05:10:40 <Trollinator> Or you might have passed the file descriptor to another process through an AF_UNIX socket.
05:11:11 * haasn prefers “(avoid success) at all costs” over “avoid (success at all costs)”
05:11:19 <k00mi> orion: just yesterday this blog post was published: http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
05:11:22 <k00mi> you should read that
05:11:43 <haasn> The former is the motto I follow; even though it was originally just a misinterpretation of SPJ's famous (latter) mantra
05:13:05 <merijn> I don't believe math has anything do with haskell
05:13:07 <edwardk> orion: i'd say there are some pretty darn good haskell folks out there making a lot of money, and then there are a few out there who don't really get motivated by money, it correlates pretty well to me
05:13:22 <merijn> I think people should learn math and I think people should learn haskell, but those opinions are mostly orthogonal :)
05:14:24 <edwardk> the way i see it 'avoid success at all costs' is just saying you don't want to get locked into owning the wrong choice forever. it's a way of talking about the sulk cost fallacy. programmers suck at calculating the total cost of ownership of their worst ideas
05:14:46 <orion> k00mi: Wow, the fact that he wrote a blog post about this tells me that this seems to be a real issue.
05:14:57 <Trollinator> merijn: have you never heard of the Curry-Howard isomorphism?
05:15:09 <edwardk> without success you can freely refactor and choose alternate paths, once you get users people start putting pressures on you to keep things stable
05:15:15 <Trollinator> (which incidentally was not invented by Curry or Howard and is not an isomorphism)
05:15:53 <Trollinator> edwardk: but Haskell already has that kind of pressure
05:16:04 <edwardk> Trollinator: the question is how much we yield to it.
05:16:12 <merijn> Trollinator: I have, but I don't see how that has any relevance to my statement?
05:16:34 <Trollinator> that's a strong connection between Haskell types and logic right there, isn't it?
05:16:45 <edwardk> You know the phrase "dance like nobody is watching"? Refactor like nobody is using.
05:17:06 <merijn> orion: The post is essentially a very verbose way of saying: http://xkcd.com/1053
05:17:15 <Trollinator> that's hard when the users are the ones paying you.
05:17:28 <Trollinator> Though I approve of the sentiment.
05:17:45 <merijn> orion: Rather than feeling smugly superior or getting drawn into flamewars, ignore the haters and be like SPJ, sharing your enthusiasm with the people that *are* interested
05:18:27 <merijn> Haskell is much better served by helpful people, good tutorials and blogposts than yet another 500 post flamewar on HN/reddit where everyone is feeding the "haskell is a useless academic language" trolls
05:18:55 <orion> edwardk: The ends don't justify the means. The only exception to that rule is if you need to make a breaking API change which will improve your interface by a large degree.
05:19:24 <merijn> Trollinator: I'm not saying there's no connection, I'm just saying that connection is useless to people just starting to learn either and therefore reinforcing the stereotype that that connection is there scares away intimidated newcomers
05:19:42 <merijn> Trollinator: Therefore I'm in favour of not pointing it out when trying to convince people to learn either
05:19:44 <edwardk> orion: that is a perfectly reasonable opinion held by the vast majority of software developers. I'd just like to point out that if you never make the painful moves because they remain sub-threshold then your API will forever remain less than what it could be
05:20:07 <merijn> Once they drank the koolaid and here asking about type theory, etc. THEN it's useful to start pointing out the similarities
05:20:31 <merijn> edwardk: "then you end up with C11/C++" :p
05:20:37 <edwardk> Now, optimizing for stability is a balancing act. You are balancing pain for your current users against the potential benefit for all users in the future. If you expect that you will never have more users than you have now? By all means cater to them by fixing your code in concrete.
05:21:00 <Trollinator> well, I feel the mathyness flies in the face of everybody trying to learn haskell
05:21:10 <edwardk> If you plan to have more users next year? Then in raw utilitarian terms you are executing a strategy that increases pain.
05:21:25 <merijn> "Most code that will ever exist has not yet been written"
05:21:40 <merijn> It makes sense to make the production of that future code nicer, simpler and better :)
05:21:51 <Trollinator> the whole idea of functions – values parametrized by other values – is fundamental to math and Haskell
05:22:01 <orion> I'd just release a new package with the new API and abandon the old users.
05:22:12 <edwardk> Trollinator: i write math in haskell because i can. i just can't say the thing in other languages that i want to say. Haskell isn't Mathy. It is just capable of expressing math in ways other languages largely can't, so you find a large concentration of us mathematically inclined folks here, calling a spade a spade, because we can build the spade here and use it
05:23:02 <edwardk> orion: that has worked so well for perl 6 and python 3
05:23:13 <orion> edwardk: I am half joking.
05:23:21 <benzrf> bbl
05:23:44 <edwardk> orion: there is a real notion that a community needs a certain critical mass to survive, and forking is a way to kill both halves of the fork as often as not
05:24:25 <edwardk> ayways 'avoid success at all costs' is one side of the coin
05:24:35 <edwardk> you also need eyeballs on code to know its actually working
05:24:58 <edwardk> so if you gratuitously change things for the sake of change you compromise the supply of eyeballs resulting in worse code
05:25:24 <Trollinator> It would be interesting to research possibilities of automatic refactoring. I. e. change the interface of your module, and write some code that automatically rewrites client code to be compatible.
05:25:24 <edwardk> so if your goal is to optimize for long term code quality, then needless change is also suboptimal
05:26:15 <edwardk> but given the slope of user pool expansion i tend to err on the side of being rather more liberal about changes i accept than most in my own code
05:26:33 <edwardk> in the world of ghc, with the core libraries committee cap on, we're pretty conservative
05:27:04 <edwardk> but there is still a sense that the _right_ solution should win in the end
05:27:10 <orion> k00mi: That was a nice article, thanks for sharing.
05:28:11 <TheKing444> What type extension allows conflicting family instance declarations?
05:28:19 <TheKing444> By allowing the more specific version.
05:29:29 <orion> edwardk: I am not advocating change for the sake of change, only change for the sake of making a product which if more effective/concise/elegant.
05:29:48 <orion> If it ain't broke, don't fix it.
05:30:09 <merijn> TheKing444: If you want overlapping type families you probably wanna switch to closed typefamilies
05:30:14 <edwardk> then i think we are in violent agreement =P
05:30:16 <TheKing444> okay
05:30:35 <merijn> TheKing444: Those can have arbitrary overlap and have a fixed order for checking, see my example: https://gist.github.com/merijn/6130082
05:30:39 <hask3> if withFile fails, does the crash the program?
05:30:46 <hask3> or does it continue?
05:31:04 <hask3> i guess it has to continue. otherwise closing the file would be kind of pointless wouldn't it
05:31:06 <merijn> TheKing444: The downside of closed type families is that you can't have other instances elsewhere in your code, but generally if you want overlap you don't want that anyway :)
05:31:15 <merijn> hask3: It depends on how it fails
05:31:19 <orion> edwardk: :p I've been on projects where they try so hard to maintain backwards compatibility that they retain a user base for a product that in general sucks (from an engineering standpoint).
05:31:28 <merijn> hask3: IO operations like file ops can throw exceptions and you can catch those
05:31:33 <edwardk> orion: so have i
05:31:34 <TheKing444> Actually, I think I can just use phantom tag types.
05:31:37 <merijn> hask3: If you don't catch them, your program crashes
05:32:02 <hask3> merijn: yes but isn't writeFile supposed to catch exceptions?
05:32:10 <merijn> Why?
05:32:10 <edwardk> orion: The idea that i might be solving the same problems in seven years using the same tools i was using seven years ago would drive me to drink. =P
05:32:23 <hask3> merijn: i mean withFile
05:32:30 <hask3> merijn: isn't that the point of withFile?
05:32:41 <merijn> hask3: withFile doesn't catch them, it just closes the file in case of error
05:32:41 <edwardk> orion: so i really care to push forward the state of the art
05:32:53 <merijn> hask3: Think of withFile as having a "finally" clause for file closing
05:33:05 <orion> edwardk: Protocol spec: "This field in this packet means W -- unless the remote client is running version 0.8.13, in which case that field means X. But on Tuesdays it means Y and after version 0.9.10 it means Z." -- that enrages me.
05:33:08 <merijn> hask3: So it prevents resource leaks, but doesn't catch exceptions, it will just rethrow them
05:33:15 <hask3> merijn: ok thanks
05:33:43 <merijn> hask3: It's very similar to "with" blocks in python, if you know those
05:33:56 <hask3> merijn: bracket is used to catch all exceptions?
05:35:33 <merijn> hask3: bracket is similar to withFile, but for custom allocation/cleanup
05:35:52 <merijn> hask3: i.e. bracket guarantees that the cleanup gets run, even if an exception is thrown
05:36:09 <merijn> hask3: For *catching* exceptions you want Control.Exception.catch or Control.Exception.handle
05:36:11 <orion> edwardk: I also get infuriated by the fact that software engineers will use an old version of a library which is known to contain bugs, have a horrible, API, etc, solely because "it's such a common library" and "everyone has it".
05:36:19 <hask3> merijn: ok thanks
05:36:36 <edwardk> ok, off to set up hac boston day 2
05:36:45 <orion> Especially if the authors of said library release a wonderful new version which has been tested and verified.
05:36:49 <angerman> how do I make cabal install a package from a different location into my sandbox? (e.g. I have patched a package, and would like to use that instead of the one cabal installed. Or even better, can I include the package as source somehow and hack on it from there?)
05:37:22 <hask3> merijn: so bracket also rethrows the exception like writeFile
05:37:25 <merijn> angerman: add-source :)
05:37:30 <hask3> s/writeFile/withFile
05:37:31 <merijn> hask3: Yes
05:37:33 <hask3> ok thanks
05:37:55 <merijn> angerman: You can just do "add-source /path/to/unpacked/cabal/dir" and your sandbox will use that one
05:38:10 <angerman> merijn... things can be so easy. ouch.
05:38:34 <merijn> angerman: Learn to use "cabal help sandbox" ;)
05:39:01 <merijn> It's a rather common usecase to want that :p
05:39:09 <Th3On> So is bracket the recommended way to deal with resources, or is there something better? I'm asking because I'm using C api (which sometimes needs to have things freed)
05:40:05 <merijn> Th3On: Bracket is recommended in the presence of exceptions yeah, for C you may want to check out ForeignPtr
05:40:21 <angerman> merijn: i guessed so.
05:40:21 <merijn> Th3On: Which lets you attach cleanup actions to a pointer that the GC will run for you
05:40:36 <Th3On> merijn: oh thanks, that sounds like exactly what i need
05:42:34 * hackagebot timeout 0.1.1 - Generalized sleep and timeout functions  http://hackage.haskell.org/package/timeout-0.1.1 (FedorGogolev)
05:43:31 <Th3On> merijn: hmm, but does Haskell's GC always run at the end? I mean do I have a guarantee that finalizer functions will be run?
05:44:01 <merijn> Th3On: No, but for malloced pointers that doesn't matter anyway, all memory of a process is freed when it exits
05:44:27 <Th3On> merijn: yeah, but I guess for things allocated on GPU I'll need to manually delete
05:44:33 <merijn> Th3On: It won't work for external resources like files, though. For that you really need something like bracket (even though even that doesn't necessarily guarantee anything)
05:45:06 <merijn> Th3On: oh, you're doing GPU in haskell? OpenCL or CUDA?
05:45:24 <Th3On> merijn: Currently just GL, but may do some CUDA later
05:46:31 <Th3On> Th3On: I'm still a student so I decided to mix learning OpenGL (I do have some projects in GL with C++) with Haskell
05:47:15 <Th3On> merijn: I should just type out people's names instead of clicking with mouse xD
05:47:57 <merijn> Aww, I was wondering if you'd find some decent CUDA bindings, I wasn't happy with the existing ones, so I'm currently coding in C++ instead because I don't have time to implement CUDA bindings
05:48:34 <Th3On> merijn: Ah, too bad. I guess I'll do the same then, previously I had ATI cards so I wanted to try CUDA with new nVidia
05:49:12 <Darwin226> Hey guys. If any of you are on Windows, I've released the first version of my Haskell integration package for Visual Studio. Tested only on VS2013 Ultimate. It's on GitHub (but you DO NOT want to see the code) https://github.com/LukaHorvat/HaskellPackage Hope it works for you.
05:49:38 <Th3On> Darwin226: LukaHorvat? Where is he from, Croatia?
05:49:45 <Darwin226> Yeah
05:49:49 <Darwin226> How'd you know?
05:49:55 <Th3On> Darwin226: I'm from Croatia also
05:50:03 <Darwin226> Cool :D
05:50:21 <Th3On> Darwin226: I might try the integration, but don't bet on it. I'm 99% on Linux
05:50:22 <mpankov> hi. can anyone help me out with 'where' in ghci?
05:51:14 <mpankov> i'm doing
05:51:14 <mpankov> :{
05:51:15 <mpankov> let a x = g
05:51:15 <mpankov>   where
05:51:15 <mpankov>     g = p x x;
05:51:15 <mpankov>     p a b = a + b
05:51:15 <mpankov> :}
05:51:16 <mpankov> and it says "parse error on input where"
05:51:38 <mpankov> ghc 7.6.3 in case that matters
05:53:09 <benmachine> mpankov: curious. "let a x = g where g = p x x; p a b = a + b" works fine
05:53:24 <jle`> mpankov: you probably have to indent past the `a`
05:53:33 <jle`> let a x = ...
05:53:36 <merijn> benmachine: Easy, where is not indented past a
05:53:38 <jle`>     where  ...
05:53:43 <jle`> oops, forgot a space there
05:53:46 <benmachine> merijn: yeah but I don't think :{ and :} work like that
05:53:46 <ReinH> In ghci?
05:54:01 <jle`> :{ is just normal alignment stuff right?
05:54:01 * benmachine docs
05:54:40 <merijn> Lack of ; means it's switching to layout inside {}
05:54:45 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
05:54:59 <benmachine> "Such multiline commands can be used with any GHCi command, and the lines between :{ and :} are simply merged into a single line for interpretation. That implies that each such group must form a single valid command when merged, and that no layout rule is used."
05:55:22 <jle`> that's weird, everything is weird
05:55:28 <merijn> hmmm
05:55:30 <jle`> i don't know what's normal anymore
05:57:08 <benmachine> what the manual says doesn't seem 100% consistent with the behaviour I observe
05:57:10 <benmachine> maybe it's a bug
05:57:23 <Th3On> merijn: I found this in the docs: There is no guarantee of promptness, however the finalizer will be executed before the program exits.
05:57:30 <Th3On> merijn: http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-ForeignPtr.html
05:57:41 <Th3On> merijn: under newForeignPtr function
05:58:15 <Th3On> merijn: But as you said, it doesn't really matter for malloced stuff
05:58:24 <CaptainK> Anyone here working with STM module?
05:59:01 <merijn> Th3On: Ah, good :)
06:02:52 <mpankov> sorry got disconnected
06:03:53 <mpankov> putting where on same line as 'let' works indeed
06:04:13 <mpankov> but putting on next line and indenting is past 'a' doesn't
06:05:27 <benmachine> mpankov: yeah, seems like the section of the manual I quoted is inaccurate
06:09:08 <mpankov> it's just inconvenient to put 'where' on same line since you have to indent a lot then
06:17:35 <Philonous> I understand that a Prism a b is isomorphic to (a -> b, b -> Maybe a), but is there a Van-Laarhoven representation for (a -> b, b -> Either e a) for some error type e?
06:21:29 <hask3> Does writeFile write a string laziliy? What buffer size does it use? Smaller than 1 MB?
06:21:45 <hask3> i.e., can I reasonably count on it being relatively small, max a few megabytes?
06:21:50 <hpc> :t writeFile
06:21:51 <lambdabot> FilePath -> String -> IO ()
06:21:55 <hpc> @src writeFile
06:21:56 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
06:22:14 <hpc> looks like it does the write immediately
06:22:56 <hask3> yeah but i'm talking if the string is large and the string itself is lazy
06:23:00 <Philonous> What would it even mean to write a file lazily?
06:23:14 <hask3> Philonous: keep appending until done
06:23:33 <Philonous> hask3, How is that different from a strict mode of operation?
06:24:42 <hask3> Philonous: if the string itself is lazily computed. So "lazy" writing would be it writes the file in reasonably sized chunks. "strict" would be it first loads the whole damn string into memory and writes it all at once
06:24:59 <hask3> wondering which happens
06:25:04 <Philonous> Ah, I see
06:26:16 <haasn> hask3: That can depend as much on the rest of your program as on writeFile
06:26:39 <haasn> hask3: do { let str = longThing; writeFile "foo" str; writeFile "bar" str }
06:26:46 <haasn> -- str will (probably) not be garbage collected
06:26:56 <haasn> And will this stick around in memory in its entirety
06:26:58 <haasn> thus
06:27:06 <Philonous> hask3, Quick glance at the source seems to say it depends on the buffering mode of the handle. WIthout any buffering it will write it one char at a time, with line and block buffering it will write (and thus force) entire lines (or blocks, respectively) at once
06:28:14 <haasn> Philonous: I think buffering just determines when the buffer is necessarily *flushed* to STDOUT; I think GHC still buffers I/O internally and when its buffers overflow it will automatically output even in line buffering mode - but I could be mistaken
06:28:39 <hask3> haasn: so after the first writeFile, the string will take the whole memory?
06:28:49 <hask3> (since it's used later)
06:28:57 <Philonous> hask3, Oh, yes
06:29:15 <Philonous> hask3, writeFile will necessarily force the entire string
06:29:18 <haasn> hask3: Strictly speaking it depends on the implementation but, yes, GHC is probably not smart enough to eliminate it here
06:29:46 <hask3> What if it isn't used later? Would the string then be garbage collected on the fly, or would it still take up the whole memory temporarily before it's garbage collected?
06:30:15 <Philonous> hask3, It should be garbage collected
06:30:18 <haasn> It will most likely be garbage collected on the fly, but there's no way to guarantee that
06:30:22 <hask3> ok
06:30:33 <haasn> I do think there's a guarantee that it will be garbage collected if it lying around would otherwise prevent new allocations from being made, though
06:30:36 <haasn> But I'm not sure
06:30:53 <haasn> (Note: This is hard to argue about formally because Haskell does not have garbage collection)
06:31:26 <haasn> in fact, Haskell doesn't care about memory at all
06:31:35 <Philonous> hask3, If you want better control over resources while retaining streaming semantics, I would recommend conduits or pipes
06:31:41 <hask3> Philonous: ok
06:31:49 <hask3> yeah writeFile probably ain't suitable for large things
06:31:58 <raveline> Hello there, I have a question about applicative and Parsec, is there someone to give me some pointers ?
06:32:14 <Philonous> raveline, Don't ask to ask, just ask.
06:32:16 <haasn> writeFile is perfectly suitable for large things; but writeFile is not suitable for precision
06:32:30 <hask3> haasn: what do you mean?
06:32:35 <raveline> OK, philonous, sorry !
06:32:55 <Philonous> raveline, No need to apologize, either ;)
06:33:16 <raveline> Let's say I have a simple type called Test, defined as data Test = Test String String
06:33:29 <hask3> haasn: we already saw that two consequtive writeFile of the same string will put the whole string in memory. so i guess writeFile *can* be suitable for large things *sometimes* ?
06:33:33 <raveline> And I want to build a parser that will return a Maybe Test
06:34:00 <raveline> I've tried to do something like this : Just <$> Test <$> string "a" <*> string "b"
06:34:12 <raveline> The compiler is not too happy with it, and I don't understand the error.
06:34:28 <raveline> What am I missing ?
06:34:52 <benmachine> raveline: what are you aiming for exactly?
06:35:02 <statusfailed> I'm having a lot of trouble with the pipes hackage documentation, is there an easier tutorial somewhere?
06:35:03 <benmachine> oh wait you might have already said
06:35:08 * benmachine reads up a bit
06:35:24 <haasn> hask3: Well, lazy I/O “works” fine - the problem with lazy I/O is that you can never be *sure* about things. “Is my program really safe/sane here? It works, but are there unexpected possibilities like race conditions or other nasties?” - pipes, conduits and the like are all about giving you more *control* over things - instead of leaving it to some abstract lazy I/O mechanism, you can actually state
06:35:26 <haasn> that you want to write your data to the handle - and perhaps others - in 1,000,000-character sized chunks. These libraries give you a very tight control over the *order* in which things happen, including stuff like writing blocks to disk and advancing to the next element of a stream
06:35:42 <haasn> hask3: “it *can* be suitable for large things *sometimes*” is most certainly true
06:35:45 <haasn> Probably true of most things :)
06:35:48 <benmachine> raveline: hm, I would expect your example to work (but only because <$> is . for functions) -- summarise the error for me
06:36:03 <Philonous> raveline, You need parens to make that type check:  Just <$> (Test <$> string "a" <*> string "b")
06:36:05 <hask3> haasn: thanks
06:36:09 <hask3> helpful info
06:36:26 <benmachine> oh, Philonous is right and I am wrong
06:36:33 <Philonous> raveline, Since (<$>) is left-associative
06:36:44 <raveline> benmachine :     Expected type: String -> String -> b
06:36:44 <raveline>       Actual type: String -> Maybe (String -> Test)
06:37:03 <raveline> I'm under the impression I'm in a Maybe functor, not in the ParsecT one.
06:37:25 <raveline> <$> is left associative !
06:37:27 <benmachine> raveline: right, so your expression parses like (((Just <$> Test) <$> string "a") <*> string "b")
06:37:31 <benmachine> yes, it is
06:37:53 <raveline> OK, Philonous and benmachine, I did not think about that... stupid brain of mine !
06:38:05 <benmachine> easy mistake to make :)
06:38:58 <raveline> OK, it works, and even better, I understand now why it didn't, thank you so much !
06:39:06 <Philonous> You're welcome
06:39:13 <Javran> hello, I'm installed a lambdabot, how can I connect it to another irc channel?
06:40:00 <Javran> I find there's a "irc-connect" command, but haven't figured out how to use it.
06:40:18 <latk> Could anyone point me at some more complicated examples of fromfield / fromrow instances for postgres-simple ?
06:53:20 <angerman> getting to learn more about a project, by digging through it to find a bug... #onewaytodoit :D
06:55:11 <rufs> latk: You have some examples in the source https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/FromRow.hs
06:56:50 <rufs> those pre-made instances at the bottom
06:57:16 <latk> rufs: Ah, true. Very useful!
06:57:26 <latk> Incidentally, could anyone tell me what an orphan instance is ?
06:57:51 <mwhit> an instance declared in a different module than the datatype for which the instance is being made
06:58:00 <mwhit> don't write them
06:58:04 <latk> mwhit: Right, makes sense.
06:59:32 <benmachine> so it turns out I have misunderstood for a long time how overlapping instances work
06:59:40 <benmachine> is anyone else surprised by the fact that
06:59:47 <benmachine> instance Show [Int] where show = undefined
06:59:55 <benmachine> is accepted with only FlexibleInstances enabled?
07:00:16 <hpc> not surprised
07:00:19 <mwhit> no
07:00:22 <hpc> you should look at what FlexibleInstances does
07:00:32 <hpc> and specifically the rules it replaces
07:01:00 <Philonous> benmachine, Actually, yes.
07:01:06 <benmachine> hpc: I think of FlexibleInstances as allowing instance C [Int] in general, but I was expecting this instance to overlap
07:01:17 <benmachine> hpc: and therefore be rejected, because I have NoOverlappingInstances
07:01:51 <benmachine> hpc: FlexibleInstances being necessary because that's the only way you can even *write* an overlapping instance that is not identical
07:01:56 <hpc> iirc it won't say the instances are overlapping until you try and use it?
07:02:38 <benmachine> hpc: ah, that much is true
07:02:58 <benmachine> hpc: however, the original thing is permitted only because Show [a] is an overlapping instance
07:03:16 <benmachine> hpc: if you define your own class and define overlapping instances of it, they will be rejected at the instance declaration
07:03:21 <latk> Is there some way to integrate running an attoparsec parser into postgres simple fromfield instances ?
07:03:48 <hpc> benmachine: gonna hpaste an example of where OverlappingInstances makes your stuff work
07:04:40 <hpc> benmachine: http://lpaste.net/108629
07:05:06 <hpc> if you add OverlappingInstances, then t :: Int = 5
07:05:45 <hpc> so you can write your extra instances just fine
07:05:54 <hpc> and you can use t :: forall a. a
07:06:01 <hpc> because it only resolves to one instance
07:06:07 <hpc> the C Int instance doesn't unify
07:06:19 <hpc> but t :: Int overlaps
07:06:28 <hpc> haskell is sometimes weird
07:06:31 <benmachine> it is!
07:06:47 <benmachine> I guess FlexibleInstances is more powerful than I appreciated
07:06:53 <benmachine> it allows a limited form of overlap
07:07:01 <benmachine> this makes me sad :(
07:07:06 <hpc> it doesn't allow any overlap
07:07:13 <hpc> it just lets you write more sophisticated instances
07:07:28 <hpc> so you could do instance C [Int] and instance C [String]
07:07:37 <hpc> but not instance Show [Int] because that would overlap
07:07:54 <benmachine> sure it does, it lets you write instances with heads that can be unified
07:07:59 <benmachine> to me that sounds like overlapping
07:08:15 <benmachine> brb brunch
07:08:22 <hpc> you /can/ but then you get a type error when you use them
07:08:28 <hpc> so i don't count that
07:09:50 <hpc> it's like the type class version of data Void
07:10:08 <hpc> you can define it just fine, but you can't use it
07:10:14 <hpc> (pretend for a moment we don't have bottom)
07:12:43 <latk> In https://github.com/lpsmith/postgresql-simple/blob/72b06bd79cbfd1754d72d503262a3281f2071981/src/Database/PostgreSQL/Simple/FromField.hs I keep seeing this function ff, but can't find what it is. What is it ?
07:13:19 <latk> ..Yeah if I just scrolled down a bit more I would have found out
07:13:20 <latk> never mind.
07:13:58 <hpc> :P
07:20:15 <latk> So I can see that internally postgres simple uses attoparsec to parse results from the database into types, but I can't see some exposed way that I can do it. Anyone know if there is one ?
07:20:33 <latk> in e.g. fromField
07:30:10 <benzrf> @hoogle a -> (a -> Maybe a) -> a
07:30:13 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
07:30:14 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
07:30:14 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
07:30:28 <benzrf> @hoogle (a -> Maybe a) -> a -> a
07:30:29 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
07:30:29 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
07:30:29 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
07:31:00 <benzrf> :t maybe
07:31:02 <kvanb> how do I compare 2 criterion runs?
07:31:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:31:12 <kvanb> I'm trying to improve bytestring performance
07:31:24 <kvanb> but the whole bench process is a little bit of a mess
07:35:35 <Maerten> Hi, does anyone have a suggestion on how to use Data.Thyme.Time with Database.Persistent? I get this error: No instance for (PersistFieldSql UTCTime) arising from a use of `sqlType'
07:36:15 <Maerten> I was told to add the instance declarations for Thyme's UTCTime  / PersistFieldSql but i have no idea on how to do that..
07:37:03 <darthdeus> is there something like "get documentation for a function under the cursor" in haskell-mode?
07:37:43 <int3__> darthdeus: I thought you used vim
07:38:01 <int3__> there's something to fire up haddock documentation in haskellmode-vim
07:38:05 <darthdeus> int3__: not anymore :)
07:38:14 <int3__> darthdeus: lol I see
07:38:51 <darthdeus> hah https://github.com/haskell/haskell-mode/blob/master/haskell-doc.el
07:40:37 <darthdeus> int3__: i still use vim to browse code though
07:40:48 <darthdeus> int3__: aren't you using vim2hs?
07:41:25 <gn0> Hello!
07:41:31 <int3__> darthdeus: I installed both haskellmode-vim and vim2hs, but I am more or less not using any of haskellmode's features at this point
07:41:37 <darthdeus> gn0: hi :)
07:41:41 <gn0> hi darthdeus
07:41:46 <gn0> how´s that going?
07:42:07 <darthdeus> both awesome and not awesome :P
07:42:22 <darthdeus> i'm finding myself a but frustrated with haskell tools after having worked with intellij for a few hours
07:46:39 <gn0> darthdeus, I´m new to Haskell and played just a bit with Haskell + intellij so I´ve never found any issue. what limitations did you found?
07:46:53 <darthdeus> gn0: is there actually a plugin for intellij that works?
07:47:19 <darthdeus> wow therei s
07:47:19 <gn0> I could compile some basic programs with a plugin
07:47:24 <gn0> let me find which one I´m using
07:47:29 <darthdeus> it is even official
07:47:36 <darthdeus> http://i.imgur.com/m8VqxNc.png ?
07:47:38 <gn0> I think it´s not
07:48:06 <gn0> yep, that one, the most recent
07:48:06 <darthdeus> hmm there is also another one which isn't official but hasn't been updated in 2 years
07:48:17 <darthdeus> wow
07:48:19 <darthdeus> i must try
07:48:49 <gn0> it uses GHC so it should compile anything GHC does
07:49:04 <gn0> but I don´t know if it´s good, as I said, I´m new to Haskell
07:52:31 <darthdeus> wow it seems to work
07:52:53 <gn0> :)
07:53:50 <benzrf> @hoogle findWithIndex
07:53:51 <lambdabot> No results found
07:54:23 <darthdeus> gn0: though it doesn't seem to support "goto definition" outside the current module :\
07:54:25 <CaptainK> @hoogle STM
07:54:26 <lambdabot> Control.Concurrent.STM module Control.Concurrent.STM
07:54:26 <lambdabot> Control.Monad.STM module Control.Monad.STM
07:54:26 <lambdabot> GHC.Conc.Sync STM :: (State# RealWorld -> (# State# RealWorld, a #)) -> STM a
07:55:00 <gn0> darthdeus, I don´t know haha
07:55:12 <gn0> sorry
07:55:26 <mmaruseacph2> I tend to use ctags/cscope for that
07:55:40 <mmaruseacph2> even though it's for C, it worked for my haskell code so far
07:55:59 <darthdeus> yeah ctags work, that's true
08:03:42 <latk> When importing Data.Time.Calendar, I get told that there is no Read instance for Day. But there is..
08:04:17 <latk> When I import Data.Time, the instance gets imported
08:08:57 <darthdeus> hah, ctags really do make it better :)
08:09:05 <darthdeus> now i just need a non-shitty directory tree for emacs
08:11:08 <mwhit> latk: looking at the source, it's a mess
08:11:15 <mwhit> read and show are both orphan instances for Day
08:11:22 <mwhit> show is in Data.Time.Calendar.Gregorian
08:11:26 <mwhit> read is in Data.Time.Format
08:17:27 <aarvar> J
08:33:35 <mietek>     let det' = det { _detailAmount = _detailAmount det * (-1) }
08:33:35 <mietek>     let det' = det & detailAmount *~ (-1)
08:33:49 <mietek> Is this correct lens usage?
08:34:50 <benmachine> mietek: correct in what sense?
08:35:16 <mietek> benmachine: I mean, proper
08:35:30 <tdammers> does it compile? does it look readable? then it's proper ;)
08:35:37 <benmachine> do you mean "does it work"? do you mean "is it good style"?
08:35:43 <mietek> It does work.
08:35:50 <mietek> I'm wondering if it's a good idea.
08:35:55 <benmachine> oh
08:36:08 <benmachine> do you have any specific concerns?
08:37:49 <mietek> I'm teetering between "hey, this is cool" and "waiter, there's Perl in my Haskell!"
08:38:18 <supki> :t negate
08:38:19 <lambdabot> Num a => a -> a
08:38:27 <vanila> lol
08:38:48 <benmachine> mietek: lens perhaps takes some getting used to
08:38:54 <benmachine> but I think you're fine
08:38:57 <benzrf> benmachine: 'perhaps'
08:38:58 <benzrf> lmao
08:39:25 <benmachine> benzrf: well, all the cool things about Haskell do :P
08:40:19 <monochrom> it is not Perl in Haskell. it has uniform semantics.
08:40:38 <mietek> Fair enough
08:40:46 <mietek> I do mean the readability aspects
08:41:08 <tdammers> lens code can look a bit like character vomit
08:41:26 <monochrom> I have grown out of judging by surface syntax.
08:42:06 <mietek> Grown out you have?
08:42:12 <monochrom> yes
08:42:30 <tdammers> monochrom: so have I
08:42:36 <mietek> monochrom: oh, I meant to thank you for the Cabal of Cabal
08:42:42 <goobypls> Hello everyone, I was setting up a small Snap app and upon adding snap-coffee to my cabal file, cabal complained that the package process (1.2.0.0) was too new for haskell-coffee, which depends on process>=1.1 && <=1.2. It should be building since technically 1.2.0.0 is equivilant to 1.2, right?
08:42:51 * hackagebot unbounded-delays 0.1.0.8 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.8 (BasVanDijk)
08:43:27 <monochrom> when I see a language or a library, first thing I ask is "what is its semantics? does it consist of a million corner cases or is it one regular unification?"
08:45:22 <benmachine> monochrom: certainly semantics is important, but syntax is important too
08:45:27 <benmachine> it is often underrated
08:45:31 <benmachine> it is also often overrated
08:45:40 <vanila> both?
08:45:47 <benmachine> by different people, usually :P
08:45:50 <benmachine> but still, human-computer interface is a thing that matters
08:46:01 <monochrom> for syntax I stick with Dijkstra's advice and be done with it
08:46:20 <benmachine> which advice would that be
08:46:54 <monochrom> for example 2-ary associative functions are better off infix, everything else is better off prefix.
08:47:19 <vanila> im not sure I believe that :|
08:47:23 <monochrom> after a while you see how semantics drives syntax design, not the other way round
08:47:28 <benmachine> monochrom: that would mean giving up f <$> x <*> y <*> z
08:47:57 <vanila> it would mean making zip infix
08:48:18 <benmachine> vanila: I might be okay with that :P
08:48:45 <monochrom> I don't put it as a law. he doesn't either. he still accepts "4 - 5 - 6" afterall
08:51:40 <monochrom> you do realize that beginners are confused by f <$> x <*> y <*> z because they think it's f <$> (x <*> y <*> z)
08:52:59 <beaky> i thought its (((f <$> x) <*> y) <*> z)
08:53:21 <monochrom> you were smart
08:53:50 <Philonous> So, we need liskell.
08:54:26 <beaky> i love do notation
08:54:36 <beaky> because i lets me do stuff :D
08:55:06 <vanila> heh
08:58:20 <modeller> Hi. Can I ask a question regarding ghci command editing?
08:59:10 <Fuuzetsu> @justask
08:59:10 <lambdabot> Unknown command, try @list
08:59:12 <Fuuzetsu> fug
08:59:12 <modeller> After entering a command in ghci, is it necessary to move the cursor to the end of command before entering?
08:59:14 <geekosaur> one can always ask (don't ask to ask) --- if someone can answer, they will
08:59:20 <geekosaur> no
08:59:35 <modeller> Thanks. Just spent some time to articulate the question.
09:00:28 <modeller> Ok. Just wanted to confirm.
09:01:25 <geekosaur> that strikes me as the sort of question that's easier to just test than ask
09:02:18 <Javran> why is the leading "/" missing from the result of absNormPath (System.Path) ? for example ` absNormPath "/tmp/" "../usr/bin" ` returns `Just "usr/bin"` .
09:03:41 <modeller> @geekosaur Thanks for the suggestion. I tested it out and it works. But I was just unsure whether it is safe.
09:03:41 <lambdabot> Unknown command, try @list
09:03:55 <modeller> geekosaur Thanks for the suggestion. I tested it out and it works. But I was just unsure whether it is safe.
09:04:33 <geekosaur> if it lret you do it but it was unsafe, that'd be a pretty serious bug
09:04:59 <modeller> what is lret?
09:05:19 <geekosaur> a typo. "if it let you..."
09:05:32 * geekosaur kinda multitasking at the moment, sorry
09:05:48 <modeller> ok. lol
09:16:38 <TheKing44> > undefined
09:16:40 <lambdabot>  *Exception: Prelude.undefined
09:17:27 <merijn> modeller: Generally most people I know prefer just editing in a text editor and then just using :l/:r to load the file into GHCI to play around
09:18:16 <modeller> merijn, thanks for the tips. I actually uses emacs and bash to do that.
09:18:51 <beaky> > let f=(+1) in f 1+2
09:18:53 <lambdabot>  4
09:19:08 <beaky> > let f=(*5) in f 1+2
09:19:10 <lambdabot>  7
09:19:15 <vanila> f 1+2 = (f 1)+2
09:19:20 <beaky> oh
09:19:45 <beaky> so functions eat things before operators
09:19:53 <vanila> yes!
09:19:57 <vanila> function application has tighest precidence
09:27:14 <deets> hi, total haskell noob here. I'm having troubles building a haskell app (implicitcad) under os x GHC 7.6.3 installed via homebrew. There are dependencies missing when I invoke make: Setup: At least the following dependencies are missing:
09:27:14 <deets> JuicyPixels -any …. if you guys have any suggestion (yes, I googled) - that would be awesom. thanks!
09:31:08 <matheus23> Cabal won't recognize that I configured my project: http://lpaste.net/108636
09:31:31 <mwhit> deets: just run 'cabal install implicit' instead
09:31:54 <mwhit> also, don't use homebrew ghc. too late now obviously, but if you run into problems switch to this
09:31:58 <mwhit> @where ghcformc
09:31:59 <lambdabot> I know nothing about ghcformc.
09:32:00 <mwhit> @where ghcformac
09:32:01 <lambdabot> http://ghcformacosx.github.io/
09:32:23 <mwhit> nobody maintains the brew formula for ghc right now
09:34:45 <merijn> Or just wait a few days for the new Haskell Platform with proper mac support :)
09:34:58 <mwhit> ^^^ or that
09:37:00 <dottedmag> few days?
09:38:04 <Fuuzetsu> it's in RC3
09:38:24 <isBEKaml_mobile> dottedmag: yes, it's on the third release candidate.
09:38:25 <dottedmag> Well, I have seen software stuck in RC status for years.
09:38:42 <Fuuzetsu> it went through three RCs in a week
09:38:53 <Fuuzetsu> basically it should be out soon
09:41:22 <c74d> which parameter of `logBase` is the base?
09:41:23 <deets> thanks for all the suggestions. I'll try them, and wayt otherwise.
09:41:46 <Fuuzetsu> I'm guessing the latter one
09:41:57 <mwhit> :t logBase
09:41:59 <lambdabot> Floating a => a -> a -> a
09:42:06 <mwhit> > logBase 2 4
09:42:08 <lambdabot>  2.0
09:42:23 <BMeph_> > logBase 2 10
09:42:25 <lambdabot>  3.3219280948873626
09:42:36 <BMeph_> > logBase 102
09:42:38 <lambdabot>  <Double -> Double>
09:42:40 <BMeph_> > logBase 10 2
09:42:41 <lambdabot>  0.30102999566398114
09:43:09 <BMeph_> The first one.
09:43:17 <c74d> I assumed it’s the latter parameter, but then I tried `logBase 4 2` and `logBase 2 4` and I thought 2 is the base-2 log of 4, but I wasn’t sure, so here I am asking
09:43:21 <c74d> okay, thanks
09:43:33 <Fuuzetsu> well, it was easy to check and I'm user it's documented too
09:43:49 <Fuuzetsu> I'm sure*
09:44:33 <c74d> (and I searched in Google and Hoogle, but <https://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:logBase> doesn’t say)
09:44:49 <c74d> (is there other documentation I should have read?)
09:45:10 <latk> I'm attempting to work out how to use persistent, and get an error when I try to insert a value about the table not existing. I presume this because I didn't run any function to create the tables - how do I do so ?
09:46:23 <dottedmag> c74d: Currying is easier this way.
09:46:30 <dottedmag> c74d: log10 = logBase 10
09:46:38 <c74d> mm, makes sense
09:46:46 <dottedmag> Otherwise it would be log10 = \x -> logBase x 10
09:47:42 <mwhit> i guess they figured "you write it like you say it" was documentation enough
09:48:20 <c74d> and I suppose the base would come first too if it’s written as a subscript after `log`
10:13:29 <merijn> c74d: Please make a ticket on the GHC trac with a documentation clarification :) No use letting unclear docs like that persist!
10:23:56 <c74d> merijn: Okay, I’m trying; I submitted a registration form, and received “Trac thinks your submission might be Spam. To prove otherwise please provide a response to the following. zero minus two plus seven”. Should I answer “5” or “five”?
10:31:27 <osfameron> or 9?
10:32:50 <merijn> eh, five, I guess?
10:33:01 * hackagebot gtk2hs-buildtools 0.13.0.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.1 (HamishMackenzie)
10:33:03 * hackagebot glib 0.13.0.0 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.0 (HamishMackenzie)
10:33:38 <c74d> “CAPTCHA verification failed”; now it wants “six minus five multiplied by nine”.
10:33:44 <c74d> osfameron: I took whatever GHCi said `0-2+7` is. :p
10:34:22 <c74d> trying `-39` now…
10:34:32 <c74d> wait what?
10:34:37 <osfameron> c74d: heh, yeah, it's the *sensible* answer admittedly :D
10:34:38 <c74d> oh, never mind
10:34:50 <monochrom> > 6 - 5*9
10:34:52 <lambdabot>  -39
10:35:20 <c74d> okay, I guess that failed too
10:35:43 <c74d> “Submission rejected as potential spam • BotScout says this is spam (Y|MULTI|IP|1|MAIL|1|NAME|3)”
10:35:43 <merijn> heh
10:36:12 <mwhit> who's out there spamming bug trackers anyway
10:36:14 <merijn> If you lpaste the text I can make a ticket for you, I was just too lazy to write out a report :>
10:36:35 <c74d> what text?
10:36:43 <c74d> oh, the text of my report?
10:36:44 <negatratoron> :t (:@:)
10:36:45 <lambdabot> Not in scope: data constructor ‘:@:’
10:36:47 <merijn> Yeah
10:37:06 <negatratoron> What's the :@: operator?  Some kind of deconstructable function application?
10:37:27 <monochrom> the like of “six minus five multiplied by nine” reject too many humans and accept too many bots.
10:38:02 * hackagebot cairo 0.13.0.0 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.0 (HamishMackenzie)
10:38:04 * hackagebot gio 0.13.0.0 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.0.0 (HamishMackenzie)
10:38:06 * hackagebot pango 0.13.0.0 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.0 (HamishMackenzie)
10:38:08 * hackagebot gtk3 0.13.0.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.0.0 (HamishMackenzie)
10:38:10 * hackagebot gtk 0.13.0.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.0.0 (HamishMackenzie)
10:38:37 <monochrom> it is more apt to be called HumanScout
10:39:59 <monochrom> then again some governments call you anti-revolutionary when you are revolutionary.
10:40:51 <c74d> it’d be something like “I found which of `logBase`’s parameters is the base to be unclear and apparently undocumented; after I inquired in <ircs://chat.freenode.net/haskell>, ‘merijn’ asked me to file a bug report asking that which of `logBase`’s parameters is the base to be documented.”
10:41:55 <beaky> what ist he differnece between currying and partial function application
10:42:00 <c74d> eh, s/to be documented/be documented/ , or s/asking that/asking for/
10:42:13 <c74d> (not that that text makes sense anyway if it’s not me posting it)
10:46:03 <McManiaC> hi, i'm trying to implement the closed type family version (variation #4 a bit down there) for avoiding overlapping instances, but my code won't compile, complaining about some missing contexts: http://npaste.de/p/OB/
10:46:08 <mwhit> beaky: currying turns a function of multiple arguments into a function which takes the first argument, which yields a function that takes the second argument, which...
10:46:15 <McManiaC> why won't this work/what am I doing wrong?
10:46:51 <Ch0c0late> beaky: All haskell in Function takes only one parameter. So, partial application means that you call a function with this signature a-> a-> a such as + partially. As an example (+3) can be partially applied.
10:47:02 <mwhit> so f (x, y, z) is (curry(f))(x)(y)(z)
10:47:17 <Ch0c0late> s/all haskell/ In haskell all functions/g
10:47:28 <Ch0c0late> s/takes/take/g
10:47:50 <mwhit> basically it just transforms the function into one that partially applies each argument in turn
10:48:14 <tsani> It is possible to write any function in the point-free form ?
10:48:15 <mwhit> too be loose with terminology probably
10:48:30 <mwhit> tsani: i think yes? but it gets ugly fast
10:48:50 <beaky> how do i write a RESTful api in haskell
10:48:52 <tsani> Of course it gets ugly :P But I mean, is it proven that any function can be written that way ?
10:49:26 <Ch0c0late> beaky: Take a look at HTTP and other related modules and then start writing it.
10:49:48 <beaky> i love partial function application because its like having the factory and abstract factory design patterns by default
10:49:57 <beaky> but not sure why currying is useful
10:50:17 <beaky> is there something like node.js and express, but in haskell?
10:50:21 <mwhit> tsani: yes
10:50:48 <mwhit> currying just makes partial application completely automatic
10:51:37 <Ch0c0late> tsnai: Lambda Calculus is equivalent to combinatory logic, so yes.
10:51:47 <Ch0c0late> tsani Lambda Calculus is equivalent to combinatory logic, so yes.
10:52:32 <tsani> Ch0c0late, mwhit: aha, thanks
10:53:46 <Ch0c0late> beaky: Please refer http://www.haskell.org/haskellwiki/Currying# in order to get why currying is useful
10:53:51 <cmccann> tsani: given an appropriate minimal set of primitives everything can be written pointfree using them, yes
10:53:55 <beaky> i love curry
10:54:25 <mwhit> just made a great homemade thai red curry the other day
10:54:26 <mwhit> so good
10:54:32 <joelteon> can i get any better error info from reads than just "no parse"?
10:54:37 <joelteon> i'd like to know where it's failing
10:54:48 <HeladoDeBrownie> joelteon, nope, try using Parsec or the like
10:54:52 <joelteon> rats
10:55:03 <joelteon> this situation was ideal for read because it looks like an ordinary haskell datatype
10:55:09 <joelteon> but clearly not quite
10:55:24 <mmmm> where have you got this datatype from
10:55:32 <joelteon> from nix
10:55:34 <cmccann> I don't think read is really meant for parsing anything other than certain literals and the output of show
10:55:51 <joelteon> well, nix derivations look almost exactly like a "show"ed Haskell value
10:55:55 <HeladoDeBrownie> Generally with read the input looks like a Haskell expression that would evaluate to the data in question
10:55:56 <joelteon> almost exactly but not quite
10:56:13 <HeladoDeBrownie> And for that matter it's uncommon not to simply derive Read
10:56:17 <joelteon> yeah, it's a big tuple that looks like Derive([("foo","bar")],...)
10:56:24 <joelteon> but it just doesn't parse properly
10:56:44 <beaky> is haskell the best programming language
10:56:47 <prophile> is this one specific input you're trying to debug?
10:56:51 <joelteon> yeah
10:56:53 <HeladoDeBrownie> beaky, define "good"
10:56:57 <prophile> could you just dump it into ghci
10:57:13 <joelteon> maybe I could
10:57:18 <beaky> good is a relative term
10:57:35 <HeladoDeBrownie> beaky, it's subjective, yes, which is why it would need to be defined to answer your question
10:57:37 <cmccann> beaky: no, haskell is just less awful than most languages
10:57:38 <joelteon> oh, neat
10:57:48 <cmccann> I have yet to be convinced that a "good" programming language exists :]
10:57:59 <joelteon> oh, I forgot to write the file :)
10:58:03 <joelteon> it does work after all
10:58:03 <beaky> i think a good programming language should make programing easy
10:58:04 <tac> I think you can apply a diagonalization argument cmccann
10:58:06 <HeladoDeBrownie> Yeah, I tend to think that the "best" language, in my approximations, has yet to be discovered
10:58:08 * hpc nominates perl
10:58:18 <mwhit> "computer, make me an app"
10:58:21 <tac> Assume you have a good language. You can find a program you want to write that that particular language is just balls at.
10:58:24 <prophile> okay, you're an app
10:58:30 <prophile> no wait
10:58:43 <systemfault> beaky: A good language should make correct programming easy.
10:59:02 <vanila> tac: Doesn't turing equivalence break that? since you can simulate any other language in O(1)
10:59:19 <benmachine> who said in O(1)?
10:59:23 <vanila> me
10:59:23 <cmccann> joelteon: rule #1 of troubleshooting, the simplest problems are also the most likely, especially the ones so simple you haven't even considered them
10:59:36 <benmachine> vanila: I don't think that's true
10:59:42 <tac> vanila: it's not O(1) and just because you can encode your program in another language doesn't mean it's not a balls program
10:59:54 <vanila> benmachine, I mean in terms of source code length
11:00:20 <benmachine> vanila: oh, right, although that does assume the presence of efficient string literals :)
11:00:22 <cmccann> simulating any language in O(1) seems to imply that all parsers are O(1)...
11:00:45 <benmachine> you cannot encode a Haskell program in a brainfuck program of asymptotically the same length
11:00:54 <HeladoDeBrownie> cmccann, or that there exists an O(1) parser in any given language of any given language, I think
11:01:12 <benmachine> in any case, the translation, as others have pointed out, certainly doesn't preserve resource usage
11:01:19 <vanila> benmachine, I think that you can - like, this is what I'm claiming
11:01:22 <cmccann> true, I guess that only assumes a single-purpose parser for the language exists, not a general parser.
11:01:30 <hpc> benmachine: strings are really that bad in bf?
11:01:42 <benmachine> hpc: they're not that bad, but they're at least a constant factor longer
11:01:54 <vanila> you can input any number from O to 255 in bf using <= 3+255 symbols
11:02:03 <benmachine> right
11:02:06 <vanila> so it's stillO(1)
11:02:12 <benmachine> so say you have a program in Haskell of length n
11:02:33 <benmachine> you may need a brainfuck program of length up to 255n to encode it
11:02:34 <vanila> I certainly agree that there is overhead in interpretation
11:02:44 <cmccann> brainfuck has a looping construct, right?
11:02:54 <benmachine> actually shorter because you can be cleverer, but still not the same length
11:02:58 <jrm2k6_> Hi guys! I have an issue when passing around a Maybe element https://gist.github.com/jrm2k6/dd71615ee2b794675fa4
11:03:18 <jrm2k6_> How am I supposed to pass my ActivityElem to my generateCode function in the gist linked?
11:03:21 <benmachine> I mean, this follows from brainfuck having only six program instructions, right, you *must* need more of them
11:03:26 <vanila> you're right, but a program that's a constant factor (like 255) larger is still O(1)
11:03:28 <mwhit> you could just write the haskell program, and then a brainfuck program that compiles haskell to brainfuck
11:03:31 <cmccann> what you probably want is a language that makes loops/recursion harder to specify as the body of the loop grows
11:03:44 <benmachine> vanila: ah, then we're just counting differently
11:03:51 <vanila> I'm using big O notation
11:03:54 <benmachine> yes, I get that
11:03:58 <benmachine> but wrt what variables
11:04:03 <vanila> source code length
11:04:13 <yukko> jrm2k6_ what's TopLevelActivity?
11:04:29 <jrm2k6_> yukko: data TopLevelActivity = TopLevelActivity ActivityElem [ExtraElem]
11:04:52 <jrm2k6_> Oh, should I specify that it is a Either ActivityElem?
11:05:21 <benmachine> vanila: I thought you were claiming that the length of the target program was at most a constant number of characters more than the length of the source program
11:05:36 <benmachine> vanila: but you were instead claiming that it was at most a constant multiplier longer?
11:05:44 <monochrom> jrm2k6_: you don't have enough context for the error you see. but I see another error. extraStatement has type IO (). therefore, "putStrLn extraStatement" makes no sense.
11:06:05 <jrm2k6_> monochrom: you're right
11:06:40 <jrm2k6_> monochrom: should I just put a return in this case?
11:06:52 <jrm2k6_> I need to return as it is in a do statement
11:07:07 <vanila> benmachine, yeah, big-O absorbs constant factors
11:07:13 <monochrom> no. you should rethink what you really want.
11:07:32 <benmachine> vanila: but constant *what* with respect to *what*
11:07:59 <vanila> hmm good question
11:08:07 <HeladoDeBrownie> jrm2k6_, return is unrelated to the return statements from many other languages.
11:08:12 <benmachine> vanila: when you say "source code length", you migh mean "how much longer the encoded version is than the original" or "how many times longer"
11:08:14 <cmccann> all programs run in O(1) with respect to execution time
11:08:18 <benmachine> those are already different
11:08:26 <benmachine> cmccann: surely O(n)
11:08:27 <jrm2k6_> HeladoDeBrownie: yes I know
11:08:29 <benmachine> cmccann: i.e. n
11:08:41 <cmccann> oh right
11:08:52 <HeladoDeBrownie> jrm2k6_, okay, it just sounded like you were trying to apply the same intuition to it, which would cause problems.
11:09:25 <jrm2k6_> HeladoDeBrownie: thanks for helping though. But I guess if I am in a situation where the end of my do statement will never be reached, something is definitely wrong.
11:10:03 <haasn> all programs run in O(1) with respect to the number of times they need to run to complete
11:10:20 <hpc> haasn: challenge accepted
11:10:55 <haasn> hpc: Haha, some crazy self-restarting, self-modifyingh interpreter?
11:11:00 <cmccann> haasn: what if the program invokes itself on the first execution
11:11:20 <haasn> (“program” here meaning “turing machine configuration”)
11:11:38 <haasn> A more pressing question may be “what if they don't halt?”
11:13:13 <TheKing444> I am trying to download download-curl (https://hackage.haskell.org/package/download-curl-0.1.4), but it says I need the curl libraries.
11:13:16 <Ch0c0late> jrm2k6_: No, nothing is wrong. Imagine you call a recursive function that never ends(definitely your patterns are not exhaustive) in do block. What will happen?
11:13:24 <TheKing444> I have curl, where are the "curl libraries?"
11:13:38 <TheKing444> configure: error: curl libraries not found, so curl package cannot be built
11:13:39 <jrm2k6_> I guess I understand why I have this error, because the compiler infers that it is a Either because of my case statement
11:13:45 <jrm2k6_> I just dont know how to fix tha
11:13:46 <jrm2k6_> t
11:14:08 <TheKing444> (curl the program, not curl the haskell package)
11:15:40 <mietek> hm
11:15:51 <jrm2k6_> ANybody with a hint?
11:16:09 <mietek> Is tehre a way to say something like "class (MonadState s m) => MyClass x", where x determines both s and m?
11:16:13 <monochrom> no, since no one knows your program specification.
11:16:37 <monochrom> I'm serious. it looks like even you haven't sorted it out. the specification.
11:16:49 <mietek> I tried some fundeps, but I don't think I'm getting it right.
11:17:20 <pavonia> mietek: "x -> s m" doesn't work?
11:17:36 <dfeuer_> OK, so is it possible to write unfoldr1, defined as in http://www.haskell.org/pipermail/libraries/2014-August/023461.html  using unfold?
11:17:51 <jrm2k6_> monochrom: OK I see, back to the keyboard then
11:17:52 <jrm2k6_> :)
11:17:52 <mietek> pavonia: no, it says: "not in scope: type variable" for both s and m
11:17:54 <TheKing444> New stackoverflow question: http://stackoverflow.com/q/25098045/1172541
11:17:56 <mwhit> mietek: fundeps don't make sense if s and m aren't in the actual isntance head
11:18:09 <mietek> mwhit: I understood some of those words
11:18:25 <mwhit> mietek: Probably you need a type family
11:18:35 <pavonia> mietek: I guess you have to make MyClass use all three parameters
11:18:43 <mwhit> or you can have like
11:18:51 <mietek> The concept I'm trying to express is, "if x is a MonadState then MyClass has this nice function"
11:19:17 <mwhit> but you said "s m" is a MonadState, not x
11:19:22 <mwhit> how are the two related
11:19:32 <mietek> type Session = StateT SessionState IO
11:19:37 <mietek> Session is a MonadState
11:19:40 <angerman> Say I have [Record, Record, Record, Record, ...] where Record { ..., name :: Maybe String, ... } how would I create a [(name, frequency)] list?
11:20:00 <mwhit> ok, yes
11:20:01 <mietek> By saying Session, I am saying s=SessionState and m=IO
11:20:06 <mwhit> so what's x in this situation
11:20:07 <opqdonut> mietek: I wonder, would something like "class MyClass x where fun :: MonadState y => y x -> x" work?
11:20:13 <mietek> Now, I want to make instance MyClass Session
11:20:24 <mwhit> no, you're saying m = StateT SessionState IO
11:20:27 <haasn> angerman: I would totally use TransformListComp for this
11:20:40 <mietek> mwhit: ?!
11:21:06 <haasn> angerman: [ (the n, length n) | Record { name = Just n } <- records, then group by n using groupWith ]
11:21:08 <haasn> Something like that
11:21:16 <mietek> instance Monad m => MonadState s (Lazy.StateT s m)
11:21:28 <mwhit> right
11:21:29 <angerman> haasn: hmm.
11:21:33 <mwhit> IO is not an instance of MonadState
11:21:36 <haasn> angerman: But you can also use something like catMaybes . map name to get a list of [String]s
11:21:36 <mwhit> StateT s IO is
11:21:40 <haasn> Which reduces the problem a bit
11:21:46 <haasn> You could then sort and group this using “sort” and “group”
11:21:50 <haasn> To find consecutive lengths
11:22:00 <mietek> mwhit: OK, I was trying to say that both m and s are determined by saying Session
11:22:37 <mwhit> ok, so we have "s = SessionState, m = StateT SessionState IO, x = Session"
11:22:42 <haasn> (In fact, after sorting, what you technically want to do is not dissimilar from a “run-length encoding” of the input list - this is a problem that appears in H-99 among other places)
11:22:42 <angerman> haasn: the list format looks pretty nice.
11:22:44 <mietek> Yes
11:22:50 <mwhit> but session is just an alias for StateT SessionState IO
11:22:55 <mwhit> it's not a separate type variable here
11:22:57 <mietek> Yes
11:23:06 <mwhit> you just need MonadState s m => MyClass m where
11:23:19 <haasn> angerman: eg. http://www.haskell.org/haskellwiki/99_questions/Solutions/10
11:23:34 <mietek> mwhit: well, that complains s is not in scope
11:23:42 <angerman> haasn thanks!
11:24:20 <haasn> but I think the “straightforward” map (head &&& length) . group . sort . catMaybes . map name -- is the simplest approach
11:24:41 <mwhit> mietek: do you need to use the type of s in the instance functions?
11:24:54 <haasn> angerman: But note that this can be quite slow. Do you need the solution to be O(n) or O(n log n) instead of O(n²)?
11:25:00 <haasn> Wait, never mind
11:25:03 <haasn> That's already O(n log n)
11:25:07 <mwhit> or rather, does it matter what s is or can it be anything
11:25:21 <mietek> mwhit: in the type of the instance function? Anything
11:25:25 <angerman> haasn, performance is not that much of an issue right now, it's like 50 records or so
11:25:45 <mietek> What, Rank2Types and a forall?
11:26:17 <mietek> No.
11:26:28 <orloc> .
11:26:30 <mwhit> mietek: FlexibleInstances should do it
11:26:31 <mwhit> then
11:26:45 <mietek> mwhit: I already have that. Doesn't do it.
11:27:00 <haasn> angerman: There are other ways you could approach this, too; one way would be building up a Map of name->count pairs, like with   fromListWith (+) :: [(String, Int)] -> Map String Int  and then turning that back into a list using toList :: Map String Int -> [(String, Int)]
11:27:17 <haasn> eg. toList . fromListWith (+) . map (\r -> (name r, 1))
11:27:43 <haasn> I would still use TransformListComp :)
11:28:07 * hackagebot swish 0.9.0.15 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.15 (DouglasBurke)
11:28:23 <angerman> haasn, I need to read up on the TransformListComp
11:28:32 <haasn> angerman: https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/list-comprehension-extensions#transformlistcomp
11:28:51 <latk> Could anyone point me at some examples of non-yesod projects using persistent ?
11:29:40 <julianb> uhm Hi. I'm trying to create a function that memoizes other function's arguments and values. The following code snippet seems to more or less do that: http://lpaste.net/108643 . The problem is that it runs much slower than a normal recursive function. Hence, I'm not actually sure it is doing what I expect it to.
11:29:42 <haasn> angerman: also http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
11:30:20 <mietek> mwhit: http://lpaste.net/108645 -- here is the mini-source
11:30:39 <mwhit> mietek: Then there's always UndecidableInstances, as long as MyClass is a closed class you could probably get away with it
11:31:01 <angerman> haasn: thank you so much![!]
11:31:39 <mmmm> julianb: Can you paste your code at lpaste please
11:32:03 <julianb> mmmm, I did! http://lpaste.net/108643
11:32:32 <mwhit> mietek: You could also probably reconsider whether this really needs to be a typeclass
11:32:58 <mietek> Ahh, Rank2Types *and* FlexibleInstances
11:33:22 <haasn> (I think RankNTypes deprecated Rank2Types, but I'm not sure)
11:33:48 <benmachine> I have a vague recollection that nowadays Rank2Types might just imply RankN
11:33:50 <mietek> opqdonut: thanks for the idea
11:33:56 <mietek> mwhit: thanks
11:33:57 <mietek> http://lpaste.net/108645
11:34:03 <benmachine> because the effort of identifying and forbidding precisely rank 3 types was deemed not worth it
11:34:07 <mietek> Right
11:34:18 <haasn> benmachine: rank-3-and-above
11:34:27 <benmachine> yeah
11:34:35 <benmachine> that's what I meant :P
11:34:37 <haasn> http://stackoverflow.com/questions/15020428/are-there-any-advantages-of-using-rank2types-in-favor-of-rankntypes
11:34:53 <mietek> mwhit: yeah, I thought it could make things more convenient
11:34:59 <mietek> It's just sketching around
11:35:22 <haasn> Ah, it's not marked as deprecated due to historical reasons
11:35:33 <haasn> But making more code us Rank2Types is not helping the cause :)
11:35:39 <mwhit> yeah, i know what you mean, but people tend to frown on overusing typeclasses
11:35:49 <mwhit> generally you want to ask yourself if there are actual laws for it
11:36:10 <mietek> Laws?
11:36:16 <mietek> There ain't no laws here. This is a web scraper.
11:36:29 <mwhit> exactly
11:36:51 <haasn> “A type class abstracts over types. These types have something in common. Are there any rules or predictable behavior they all follow?”
11:37:03 <mietek> Yep.
11:37:18 <mwhit> yeah i mean presumably there's some common behavior you expect these `fnord` values to have
11:37:36 <mietek> "Does this particular session have a way to get the last response, parsed as tags?"
11:38:26 <Cale> fnord's type is kind of interesting.
11:38:34 <mietek> It's also probably not 100% what I want
11:38:55 <Cale> It means you need to know you're working with a state monad, but you don't care what the state type is.
11:39:02 <mietek> It looks like I'll have to keep saying more than just "(MyClass m) => ..." in functions which use fnord
11:39:06 <Cale> Which is an odd position to be in
11:39:07 <mietek> Cale: exactly
11:39:23 <mietek> Why? I just know there is a state, and there should be a way to get something specific out of it
11:39:28 <Cale> (since you can't really affect or examine the state)
11:39:29 <haasn> At that point, why not just make it Monad m => m ()?
11:39:37 <mwhit> shouldn't that something specific need a specific type?
11:39:48 <mietek> Yes, the type is MyClass, or rather, HasResponseTags
11:40:00 <Cale> You can get the state, but since you don't know what type it has, there are no operations that you can apply to it.
11:40:10 <mietek> I'm not getting *the* state
11:40:15 <mietek> I'm getting a particular piece of the state
11:40:34 <Cale> Well then, you'll need to know something more about s
11:40:53 <mwhit> how is m () getting anything?
11:41:21 <Cale> Perhaps you really want  fnord :: (MonadState SessionState m) => m ...
11:41:45 <monochrom> there are always laws. perhaps sometimes you don't bother writing them down
11:41:59 <Cale> So that fnord will be allowed to take apart the SessionState value
11:42:53 <platz> Would it be liked if there was a searchable index of haskell irc logs, or is that creepy
11:42:58 <mietek> Cale: I'm not sure if the type I have right now is right.
11:43:01 <mwhit> or at the very least it would have to be constrained to something for which "response tags" makes sense
11:43:12 <mietek> Cale: an instance of MyClass should make the s type parameter concrete.
11:43:13 <mwhit> surely MonadState Int foo can't have response tags
11:43:34 <mietek> mwhit: they could conceivably be encoded in an Integer ;)
11:43:36 <monochrom> as long as your program specification is not "do a random thing" you have lawas
11:43:44 <Cale> mietek: Well, then you need either a multiparameter type class with a fundep, or you need an associated type
11:43:53 <monochrom> even if your program specification is "do a random thing" you still have probability laws
11:44:09 <mietek> Cale: cool! I was trying to get fundeps to work, but I wasn't able to express what I want
11:44:18 <Cale> Or you can piggyback on the fact that MonadState already has that
11:44:19 <mwhit> mietek: ok, but MonadState () foo *definitely* couldn't, and moreover it wouldn't matter if you don't have some way to make sense of that Integer encoding
11:44:32 <mwhit> which you don't if the state is just "s"
11:44:33 <monochrom> so, as long as your program source code is not to be randomly generated, you have laws
11:44:42 <mmmm> platz: http://ircbrowse.net/browse/haskell
11:44:49 <Cale> class (MonadState s m) => MyClass m where fnord :: m ()
11:45:14 <platz> mmmm: oh I didn't see the search box there before
11:45:29 <mietek> Cale: that's where I started
11:45:34 <mietek> Cale: s is not in scope
11:45:51 <Cale> mietek: Well, that still has the issue that your original thing had
11:45:57 <Cale> In that you don't know anything about s
11:46:09 <Cale> Well, actually, no
11:46:22 <Cale> When you go to implement an instance of the class for specific m
11:46:24 <mietek> I don't know anything about s in the definition of the typeclass, but I do know s in the definition of an instance of the typeclass
11:46:31 <Cale> you'll be allowed to assume that s is the appropriate thing
11:46:53 <mietek> So, what's the right syntax?
11:46:54 <mwhit> oh wait
11:47:04 <mwhit> in my head, the constraint has been on the instance declaration this whole time
11:47:10 <mwhit> i'm not sure how that happened
11:47:33 <mietek> Can you perhaps try to annotate my tiny paste? http://lpaste.net/108645
11:48:31 <Cale> oh, that's interesting
11:49:34 <Cale> I would have expected that to be allowed due to the fundep
11:49:39 <Cale> but perhaps not!
11:49:56 <mietek> Cale: just -- how do you write the fundep?
11:50:07 <mietek> There is no fundep in my paste
11:50:23 <beaky> whats a fundep
11:50:23 <oisin643> I'm having some trouble using the bind operator. I need a function that does: Maybe a -> (a -> IO ()) -> IO (). I'm not sure how to "mix" monads, though... What direction should I head?
11:50:24 <Cale> There's a fundep in MonadState
11:50:30 <mietek> Ah, OK
11:50:32 <Cale> You could do this...
11:50:43 <mietek> beaky: functional dependencies
11:50:44 <Cale> class (MonadState s m) => MyClass s m | m -> s
11:51:32 <mietek> Cale: this runs into kind errors later on
11:51:36 <frerich_> Is there a module which provides types much like Either, except that they represent any of three, four, five etc. types? Like ‘Choice3 a b c = A a | B b | C c’ or so?
11:51:40 <mwhit> is the fundep not, uh... transitive? there?
11:51:49 <pavonia> oisin643: You don't really need bind here, you can just use maybe
11:51:52 <pavonia> :t maybe
11:51:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:52:33 <benmachine> frerich_: you can nest eithers, of course, although that's probably a bad idea
11:52:48 <frerich_> benmachine: Right, I could do it myself, but it’s cumbersome.
11:52:51 <benmachine> I don't know of a good place to get a generic sum-of-three type
11:53:01 <Cale> mwhit: It might be carried along, but I'm not sure whether GHC is clever enough to use the superclass' fundep to make inferences only involving the subclass
11:53:05 <mietek> Cale: annotated with the error
11:53:06 <benmachine> but maybe someone else does
11:53:16 <Cale> {-# LANGUAGE MultiParamTypeClasses, FunctionalDependencies, TypeSynonymInstances, FlexibleInstances #-}
11:53:17 <mietek> Now, Session is actually supposed to take one more argument
11:53:29 <Cale> mietek: Of course, because we added another argument to it
11:53:40 <Cale> instance MyClass SessionState Session
11:53:44 <mwhit> don't type aliases have to be fully applied?
11:53:48 <genericpersona> at the byte level, how is a thunk represented?
11:54:03 <Cale> mwhit: In Haskell 98, yes
11:54:03 <mietek> ohhh, this way.
11:54:15 <mwhit> Cale: ahh
11:54:15 <genericpersona> is it stored as a string or is there some other data structure that's used?
11:54:16 <Cale> mwhit: Well, also, this type alias is fully applied
11:54:19 <frerich_> benmachine: Hm, ‘sum-of-three’ made me think of some new terms to google for and I found https://hackage.haskell.org/package/anonymous-sums-0.4.0.0/docs/Data-Sums.html
11:54:21 <cmccann> genericpersona: however the implementation wants to represent it
11:54:29 <cmccann> genericpersona: are you asking about GHC specifically?
11:54:37 <Cale> mwhit: In fact, it can't be otherwise, since it has no parameters
11:54:39 <frerich_> benmachine: So thanks for the inspiration :-)
11:54:41 <mwhit> Cale: or, kind * is what i meant i guess
11:54:48 <benmachine> frerich_: :)
11:54:49 <mwhit> guess i was mistaken
11:54:54 <Cale> mwhit: Oh, no, even in Haskell 98 you can have aliases for other kinds
11:55:04 <benmachine> frerich_: I think I'd just define my own, though, they're so lightweight
11:55:04 <beaky> when should i use bytestrings over text or vice-versa
11:55:19 <beaky> i find bytestrings perform beter
11:55:20 <Cale> beaky: When you're talking about bytestrings and not text.
11:55:29 <mietek> Cale: amazing! Compiles!
11:55:32 <frerich_> benmachine: There’s so much boilerplate though. I wonder whether some clever TH could help with this...
11:55:33 <benmachine> beaky: text is for language, writing, etc.
11:55:37 <oisin643> pavonia: Thanks - I'm  just a bit confused as to how I represent the IO () in: maybe ___ fn value
11:55:42 <oisin643> pavonia: What replaces the underscore?
11:55:47 <benmachine> beaky: bytestrings are just for sequences of 8-bit values
11:56:13 <mietek> And even works!
11:56:13 <Cale> beaky: Usually if you're using text, you'll also use bytestring a bit, because at some point you'll likely want to serialise the text in some encoding.
11:56:14 <pavonia> oisin643: What should the function return if the Maybe value is Nothing?
11:56:15 <benmachine> frerich_: is it really that bad? isn't it a one-liner, basically?
11:56:28 <oisin643> pavonia: It should do nothing at all
11:56:42 <mwhit> oisin643: then an IO () that does nothing: return ()
11:56:57 <frerich_> benmachine: If you just need pattern matching, I guess you’re right. I wast thinking of functions like ‘either’ (or ‘maybe’) which provide some functionality on top.
11:57:06 <benmachine> frerich_: ah, right, I guess so
11:57:13 <Cale> beaky: But most useful encodings aren't one byte per character, so they're awkward to work with directly as bytestrings.
11:57:16 <oisin643> mwhit: pavonia: Agh - thanks! :D
11:57:37 <benmachine> Cale: when you've got a moment I would like your opinion on something
11:57:41 <Cale> benmachine: okay
11:57:41 <frerich_> benmachine: but you’re probably right, I was overgeneralizing, I think ‘data Choice3 a b c = C3A a | C3B b | C3C c’ would work just fine...
11:58:12 <mietek> mwhit, Cale: thanks again; https://github.com/mietek/catools - this is the thing, working now.
11:58:16 <benmachine> Cale: what would you expect to happen if I enabled FlexibleInstances and wrote in a file, instance Show [Int] where show _ = ""
11:58:24 <Cale> frerich_: Usually if you're going to have more cases like that, it's worthwhile to invent a type with real names for what the cases mean.
11:58:31 <benmachine> Cale: I found it surprising and want to know if it's just me
11:58:40 <mietek> mwhit, Cale: https://github.com/mietek/catools/blob/master/src/cascrape.hs#L190-L213 - these are the now-more-generic functions, thanks to your help
11:58:45 <mwhit> it always stuck out to me that arity is the one thing you can't really abstract over. zip3 is silly
11:58:54 <Cale> benmachine: That's an overlapping instance
11:59:06 <Cale> benmachine: There's already an instance of show for lists
11:59:08 <benmachine> Cale: agreed
11:59:17 <Cale> So you *should* get an error.
11:59:27 <benmachine> Cale: you don't
11:59:32 <Cale> report a bug
11:59:35 <benmachine> you get an error if you try to use it
11:59:36 <MP2E> ^
11:59:41 <MP2E> sounds like a bug :V
11:59:44 <benmachine> but just defining it you don't
12:00:05 <benmachine> I think this behaviour is intentional, although I don't like it
12:00:29 <Cale> Well, if you write an overlapping instance without having that extension turned on, the compiler should shout at you.
12:00:40 <Cale> and if it doesn't, that's a bug
12:00:40 <benmachine> I think it's because if OverlappingInstances is enabled when you define an instance, that means not only that that instance can overlap others, but that others can overlap *it*
12:01:04 <benmachine> OverlappingInstances seems to mean not only "my instances can overlap" but "my instances can be overlapped"
12:01:07 <Cale> But OverlappingInstances shouldn't be turned on in the Prelude
12:01:22 <Cale> So if that's the case, then we know what the bug is
12:01:43 <benmachine> well, I think I agree there as well, but I wonder if the whole idea of overlappable instances is unsavoury
12:01:48 <Cale> It is
12:01:55 <Cale> But sometimes it's useful
12:02:03 <benmachine> ah, this is what I'm missing
12:02:55 <benmachine> it seems to be supporting a scenario where A defines and instance when B's instance is in scope, and they overlap
12:03:07 <benmachine> and A does not have OverlappingInstances on, but B does
12:03:23 <benmachine> GHC says this is fine, but I can't see what's wrong with just making A set OverlappingInstances on
12:04:21 <benmachine> hmm. actually, I'm now confused
12:04:22 <Cale> oh, I see what you mean
12:04:38 <benmachine> seems like the point of failure is *always* where the instance is used
12:04:44 <benmachine> ...maybe?
12:05:00 <benmachine> I can write class C a where... and instance C a where.. and instance C Int where... all in the same file
12:05:03 <benmachine> and it's fine
12:05:09 <benmachine> the first instance needs Flexibility
12:05:37 <benmachine> (without FlexibleInstances, the only overlapping instances have identical heads, and even IncoherentInstances rejects them)
12:07:06 <Cale> Yeah, I just tried defining a new  class C a where c :: a -> String; instance C a => C [a] where ...; instance C [Int] where ...
12:07:14 <Cale> and it doesn't complain
12:07:19 <Cale> But I think it really ought to
12:07:54 <benmachine> I agree
12:07:54 <SrPx> How do I properly type something that is a state monad? Ie, `foo = do { put 5; get }` ... how do I type `foo`?
12:08:11 <Cale> SrPx: foo :: State Int Int
12:08:47 <Cale> SrPx: Or more generally,  foo :: (MonadState a m, Num a) => m a
12:09:10 <cschneid> I have a record type, where all elements are monoids, is there a way to automatically derive the monoid instance of the record type?
12:09:13 <Cale> (which will be the inferred type)
12:09:17 <mr-> @let foo = do { put "x"; get }
12:09:19 <lambdabot>  Defined.
12:09:23 <mr-> :t foo
12:09:25 <lambdabot> MonadState [Char] m => m [Char]
12:09:43 <mr-> SrPx: you could also have asked ghci :-)
12:09:44 <SrPx> codehero: and how do I alias that? `type Foo = (MonadState a m) => m a` ?
12:09:47 <Cale> cschneid: Not automatically, unless someone's written some TH for it
12:10:01 <SrPx> mr-: but that is the problem, ghci didn't make sense /\
12:10:04 <codehero> SrPx: i don't know haskell :P
12:10:14 <SrPx> codehero: sorry, I meant Cale
12:10:21 <Cale> cschneid: http://hackage.haskell.org/package/derive-2.5.16/docs/Data-Derive-Monoid.html
12:10:26 <codehero> no problem ^^
12:10:33 <cschneid> Cale: ok, I don't need it that badly, I'll just type it out :)
12:10:59 <Cale> cschneid: Yeah, that derive library has a thing for it
12:11:13 <flebron> Is there a memoizing combinator that would take fib n = let fib' = memo fib in fib' n + fib' (n - 1) and "work"?
12:11:29 <Cale> flebron: data-memocombinators
12:11:33 <flebron> (Preferrably pure)
12:12:23 <Cale> flebron: Though, I think you want  fib = memo fib' where fib' n = fib n + fib (n-1)
12:12:46 <flebron> Err, yeah, that.
12:15:25 <flebron> And fib (n - 1) + fib (n - 2), at that.
12:15:40 <Cale> flebron: yes :)
12:16:12 <mietek> So.
12:16:14 <Cale> http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html
12:16:20 <Cale> flebron: ^^
12:16:35 <mietek> What's the current best choice library for writing parsers with human-readable error messages?
12:16:49 <Cale> The way the memoisers are implemented is very clever, it abuses the properties of lazy evaluation :)
12:16:50 <cschneid> cale / whoever - is there a quicker way to write this? https://gist.github.com/anonymous/6e0e489da8cf4ffca306
12:16:50 <mietek> Because Text.ParserCombinators.ReadP is not it.
12:17:52 <Cale> cschneid: Well, you could grab that derive package from hackage, and write $(derive makeMonoid ''Counts)
12:17:58 <mietek> Data.Attoparsec also does not seem to be it; at least I was unable to get it to emit anything except, roughly, "error: end of input"
12:18:03 <cschneid> ok, but without TH, no :)?
12:18:33 <Cale> cschneid: you could use mempty in the fields rather than (Sum 0)
12:18:33 <mietek> Parsec... I tried to get started with Parsec.
12:18:42 <mietek> It looks like the documentation was last updated in 2001?
12:18:52 <MP2E> o.o
12:18:53 <flebron> Cale: If I were to do it myself using ST, there'd be an issue because if I write fib (n - 1) +  fib (n - 2), by the time I'm requesting the second value, the first one has no visible side-effects, to my cache must be cleared, right?
12:18:59 <MP2E> google may have given you an old hackage link mietek
12:18:59 <mietek> (http://legacy.cs.uu.nl/daan/download/parsec/parsec.html)
12:19:02 <mmmm> mietek: What is your problem with parsec?
12:19:05 <Cale> mietek: Which documentation are you...
12:19:08 <MP2E> https://hackage.haskell.org/package/parsec
12:19:20 <mietek> MP2E: and ...
12:19:21 <nomeata> eek. the new hackage package updating feature is nice, but very opaque. http://hackage.haskell.org/package/lens-4.1.2.1 has been changed, but there is no indication of that at all!
12:19:26 <mietek> MP2E: look at the home page link
12:19:38 <Cale> mietek: Click on the module names there for documentation
12:19:40 <mietek> MP2E: then, look at the documentation link
12:19:42 <nomeata> And our local patches against the .cabal files do not apply any more :-(
12:19:43 <MP2E> ah okay
12:19:48 <MP2E> the homepage has not been updated in a long time, you're right
12:19:50 <mietek> Cale: really.
12:19:50 <MP2E> the library is still maintained though
12:19:53 <MP2E> and the docs are on hackage
12:20:21 <Cale> mietek: Yeah, the modern documentation is generated from the source automatically
12:20:27 <mietek> I do know this.
12:20:46 <mmmm> yes, parsec isn't the prettiest library anymore but it works and is very stable
12:20:46 <mietek> The documentation visible directly on Hackage does not appear to be much at all.
12:20:53 <Cale> mietek: The old tutorial is still useful, but the library has undergone a lot of revision since it was written
12:20:59 <mietek> Cale: precisely my point.
12:21:06 <mietek> There is now Parsec3
12:21:17 <mietek> And I was trying to find any example at all of threading state through parsing, using Parsec3
12:21:23 <mietek> I challenge you to find one.
12:22:07 <mmmm> You just use the internal state
12:22:37 <Cale> getState :: Monad m => ParsecT s u m u
12:22:37 <Cale> Returns the current user state.
12:22:52 <mmmm> Parsec String UserState a would be your type for example
12:22:52 <Cale> putState :: Monad m => u -> ParsecT s u m ()
12:22:52 <Cale> putState st set the user state to st.
12:23:52 <SrPx> How do I shuffle a list? /: I've looked through 15 google results already...
12:24:17 <benzrf> :t shuffle
12:24:19 <lambdabot> Not in scope: ‘shuffle’
12:24:21 <benzrf> meh
12:24:26 <flebron> http://www.haskell.org/haskellwiki/Random_shuffle
12:24:27 <Cale> SrPx: https://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
12:24:58 <SrPx> Cale: how do I install that package? I've ran "cabal install Shuffle", "cabal install System.Random.Shuffle", none worked
12:25:18 <mietek> edk: how about trifecta?
12:25:18 <pantsman_> cabal install random-shuffle
12:25:19 <Cale> The package name is random-shuffle, so cabal install random-shuffle
12:26:46 <SrPx> thanks guys
12:29:19 <mietek> So, is Parsec the best choice wrt error messages?
12:29:26 <Cale> mietek: Probably
12:29:36 <mietek> I was interested in https://hackage.haskell.org/package/trifecta
12:29:54 <mietek> But it looks researchy
12:30:14 <Cale> Oh, trifecta might be great, I haven't tried it.
12:30:33 <SrPx> is there an example? I have no idea how to use it
12:30:55 <mietek> I found one; https://github.com/ekmett/trifecta/blob/master/examples/RFC2616.hs
12:31:17 <Cale> SrPx: The shuffle function?
12:31:39 <mietek> Ah, nm.
12:31:41 <SrPx> Cale: yes, it wants a list and a "a sequence (r1,...r[n-1]) of numbers such that r[i] is an independent sample from a uniform random distribution [0..n-i]".
12:31:57 <Cale> yeah, you don't want to use that, use shuffle'
12:32:22 <Cale> SrPx: you'd do something like  g <- newStdGen  from main, and then shuffle' xs (length xs) g
12:32:41 <SrPx> hmm..
12:32:52 <Cale> It's a little silly
12:33:31 <Cale> shuffleM is a bit prettier, you'll need to import Control.Monad.Random though
12:33:52 <Cale> xs' <- evalRandIO (shuffleM xs)
12:34:41 <Cale> Or you could use  g <- newStdGen; let xs' = evalRand (shuffleM xs) g; ...
12:35:19 <Cale> (but probably evalRandIO will be fine)
12:36:14 <DarkCat26> Haskell software on http://gthotel.org
12:36:34 <Cale> DarkCat26: ???
12:36:50 * geekosaur not loading that outside of a honeypot vm
12:36:59 <Cale> DarkCat26: Their backend is written in Haskell?
12:37:00 <MP2E> probably smart
12:37:19 <MP2E> I've learned to be disdainful of links posted by bots with 2 numbers suffixed
12:38:05 <Cale> It's just some Swedish forum
12:38:08 <DarkCat26> yes its written in haskell Cale
12:38:13 <MP2E> oh shit not a bot
12:38:14 <MP2E> !
12:38:16 <MP2E> sorry DarkCat26
12:38:18 <MP2E> :P
12:38:22 <SrPx> Cale: yea that works, thanks. But what if I have to call `shuffle'` inside a unrelated state monad values outside IO? Do I have to send `g` to all of them? Something like: initGame g = do { put (shuffle'  deck (length deck) g } ?
12:38:37 <SrPx> a few *
12:38:50 <Cale> SrPx: You have to keep track of the state of the random generator somehow.
12:39:37 <SrPx> (does "g" stands for stdGen? or seed? I'm not sure what it is)
12:39:44 <Cale> It's the generator state
12:39:53 <Cale> its type will be StdGen in my examples
12:40:39 <Cale> It's not quite the same thing as a seed, but you can get one from a specific seed using mkStdGen
12:40:43 <Cale> :t mkStdGen
12:40:44 <lambdabot> Int -> StdGen
12:40:52 <Cale> > mkStdGen 42
12:40:54 <lambdabot>  43 1
12:40:58 <SrPx> hmm interesting... the "newStdGen" uses the time or what?
12:41:10 <Cale> yeah, in part, it probably shouldn't
12:41:33 <Cale> actually, it's been long enough that I checked that I probably should look again
12:41:41 <SrPx> I see
12:42:41 <Cale> mkStdRNG o = do
12:42:41 <Cale>     ct          <- getCPUTime
12:42:41 <Cale>     (sec, psec) <- getTime
12:42:41 <Cale>     return (createStdGen (sec * 12345 + psec + ct + o))
12:42:42 <Cale> ugh
12:42:49 <SrPx> ah that is it
12:42:57 <MP2E> o.o
12:43:08 <Cale> Really ought to be using a system-specific source of entropy
12:43:23 <SrPx> weeell... anyway, why stdGen not rndGen?
12:43:41 <MP2E> that is worse than I thought it would be :<
12:43:53 <Cale> I don't know why it's named that. It's the one which is specified by the standard, but... that's not really an excuse.
12:44:21 <benmachine> Cale: oh, FYI, looks like Prelude (or at least Show [a]) is not compiled with OverlappingInstances, I was just confused because the error is not at instance declaration time
12:44:35 <SrPx> I see! I'll call it rndGen then. Still a little weird that I have to pass it to everything but well, alright
12:44:55 <Cale> MP2E: It gets worse. That's only ever evaluated once using unsafePerformIO, and then newStdGen splits the RNG state.
12:45:24 <Cale> theStdGen :: IORef StdGen
12:45:24 <Cale> theStdGen  = unsafePerformIO $ do
12:45:24 <Cale>    rng <- mkStdRNG 0
12:45:24 <Cale>    newIORef rng
12:45:29 <Cale> So evil
12:45:33 <MP2E> ugh :(
12:45:37 <Cale> But it's evil which is implied by the standard
12:46:00 <Cale> There's no real good reason that there ought to be a global RNG state
12:46:12 <cmccann> standardized evil is the worst kind of evil
12:46:21 <hpc> it's there for C, i would expect
12:46:24 <Cale> Apart from the way that getStdGen/setStdGen are specified to work
12:46:41 <benmachine> huh, I never knew setStdGen existed
12:46:43 <Cale> hpc: But the implementation doesn't involve C at all
12:47:38 <benmachine> this is like when I discovered that the result of string_of_bool in OCaml is mutable
12:47:53 <benmachine> that was a fun day.
12:48:12 <Cale> System.Random was never a really well-thought-out library compared to the others in the standard
12:48:14 * hackagebot zendesk-api 0.1.0.0 - Zendesk API for Haskell programming language.  http://hackage.haskell.org/package/zendesk-api-0.1.0.0 (VictorDenisov)
12:48:15 <benzrf> :t setStdGen
12:48:16 <lambdabot> StdGen -> IO ()
12:48:19 <tdammers> benmachine: mutable and global? o_O
12:48:33 <benmachine> tdammers: yep.
12:48:38 <tdammers> benmachine: oy vey
12:49:00 <benzrf> :t getStdGen
12:49:01 <lambdabot> IO StdGen
12:49:09 <benmachine> you can do let x = string_of_bool true in x.[0] <- 'T' and then for the rest of your program, string_of_bool true is True :D
12:49:09 <benzrf> ew
12:49:40 <Cale> and then you have other libraries with better RNGs which don't make use of System.Random's classes, because nobody knows how to implement split correctly, since apparently everyone who had studied PRNGs in the past overlooked this critical fundamental operation.
12:50:00 <hpc> benmachine: it's obviously meant for localization
12:50:01 <hpc> or something
12:50:04 <hpc> yeah
12:50:11 <Cale> and only recently there has been some work on how to actually implement a PRNG with quality requirements on split
12:50:32 <benmachine> hpc: fortunate that "vrai" also has four letters, I guess
12:50:39 <Cale> http://hackage.haskell.org/package/tf-random
12:50:42 <MP2E> There has? That's good news :>
12:50:46 <MP2E> thanks for the link *booksmarks*
12:50:51 <MP2E> bookmarks*
12:53:32 <MP2E> yeah this looks much better
12:53:39 <Cale> http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf -- paper describing it
12:53:55 <SrPx> Okay now, I have a game that is running using a State monad. Suppose the state consists of a `type Deck = [Int]`, nothing else. So, for example, `initGame = do { let deck = newDeck; put newDeck }`. How do I shuffle the deck after creating it? It seems like I need to fit a IO monad inside the state monad...
12:54:06 <SrPx> but I can't get the value out IO anyway. So ... what
12:54:29 <benzrf> SrPx: make the function take an arg which is a source of randomness
12:54:30 <Cale> SrPx: You need a random number generator state.
12:54:37 <benzrf> then from IO get the randomness and pass it in
12:55:18 <SrPx> wait let me think... a sec
12:56:10 <latro`a> either you thread the RNG state through your program (thus having State (g,Deck) as your monad), or you call your function from inside an IO computation, or you use StateT
12:56:20 <vanila> what's wrong with just randomly generating two new seeds?
12:56:49 <latro`a> er, my comment was @ SrPx
12:56:52 <MP2E> "Splittable
12:56:53 <MP2E> PRNG
12:56:53 <MP2E> s are very useful for structuring purely functional
12:56:55 <MP2E> programs, as they avoid the need for threading around state."
12:56:58 <MP2E> wow sorry for the line split there
12:57:00 <MP2E> I copied from the PDF
12:57:10 <SrPx> wait I guess I get it, I don't need the IO monad after I've passed the stdGen to a pure function, is that right? I can use "shuffle'" inside a pure function after I've passed stdGen to it
12:57:26 <Cale> SrPx: right
12:57:37 <SrPx> okay that was stupid of me then, ignore. thanks
12:57:37 <Cale> SrPx: You just need IO to get one of those things in the first place
12:57:45 <SrPx> cool (:
12:57:51 <latro`a> and you need return to lift your pure function back to IO
12:57:55 <vanila> Cale, do you happen to know? or is that not what split is baout
12:58:06 <latro`a> (or fmap, of course)
12:58:41 <Cale> vanila: The problem is that you don't want the two generators you get to be correlated
12:59:24 <Cale> vanila: and if you do that kind of thing, then most PRNG algorithms don't guarantee much about what happens once you split like that 30 or so times.
12:59:45 <vanila> I see
12:59:50 <vanila> that souds really difficult
12:59:50 <Cale> vanila: It might be the case that you push yourself into a smaller and smaller fraction of possible states
13:00:02 <vanila> ahh
13:00:10 <Cale> and this was harming QuickCheck
13:00:13 <vanila> kind of life iterating a hash
13:00:22 <Cale> yes
13:00:24 <Cale> just like that
13:00:33 <mwhit> http://lpaste.net/108653 << GHC is claiming that a valid typeclass instance overlaps with one for which the datatype in question doesn't satisfy the constraints. why?
13:01:20 <Cale> mwhit: Because constraints have nothing to do with whether they overlap
13:01:35 <Cale> mwhit: Those constraints aren't (and can't be) used during instance selection
13:02:10 <mwhit> hm
13:02:15 <Cale> Instance selection is done on the structure of the type alone, and not which instances are or aren't present, because future modules can always define instances.
13:02:23 <Cale> (ones that you haven't compiled yet)
13:02:24 <latro`a> this is the same reason why you can't "fix" the Functor-Applicative-Monad hierarchy without rewriting base code, right?
13:02:26 <latro`a> @ Cale
13:03:09 <latro`a> that is, you can't "inherit" an Applicative instance from ap/return, because the instance head would be arbitrary
13:03:23 <latro`a> instance Monad m => Applicative m where ... matches any m
13:03:39 <Cale> Well, yes, that overlaps with everything
13:03:54 <Cale> (I wasn't sure what you meant at first, but yeah)
13:04:04 <mwhit> hm, that makes sense i suppose
13:04:18 <mwhit> it seems like worrying about the possibility of future orphan instances is overly restrictive thoough
13:04:32 <mwhit> since orphans can make instances undecidable regardless
13:04:39 <Cale> mwhit: hm?
13:04:46 <contiver> Hello there. I'm slowly learning Haskell and wrote a module in which I used String. I'm now trying to switch to ByteString to learn how to use it, since I understand it's generally more efficient, but I'm not sure what to do with some data types which I made instances of Show, since show returns a String. Is there a way to have show return ByteStrings ? or should I be doing something else?
13:05:05 <mwhit> i mean the scenario you're giving is only possible if there's some orphan 'instance Bar FooButNoBar' somewhere
13:05:29 <chrisdotcode> contiver: have you tried searching hoogle?
13:05:30 <Cale> contiver: ByteString isn't exactly a replacement for String... Text is better for stuff that's actually text.
13:05:36 <chrisdotcode> String -> ByteString ?
13:05:39 <chrisdotcode> but Cale's right, use Text
13:05:48 <Cale> contiver: but regardless, you'll want to use pack.
13:06:39 <contiver> so I guess I can't just simply replace String for ByteString, right? I'll take a look into Text, thanks!
13:07:03 <tdammers> a ByteString contains bytes; a String and a Text contain characters.
13:07:05 <Cale> both ByteString (the .Char8 module, which really nobody should use, but if you really don't care about unicode, then go ahead), and Text, include a pack function for converting from String
13:07:21 <tdammers> bytestring-utf8 though
13:07:31 <tdammers> no reason to use .Char8 when you can have .UTF8
13:08:05 <Cale> Right, there's also that, though in most cases, you might as well encode to ByteString via the Text type.
13:08:25 <contiver> well I'm mainly doing this for a css minifier I'm writing to learn a bit more about Haskell and FP in general, so I should be aiming at UTF-8
13:09:28 <Cale> contiver: Generally, try to use ByteString once you're thinking about it as binary data, so immediately before things go out over the network or into a file, for instance.
13:09:45 <Cale> and Text for when you're still thinking of it as human-readable text
13:10:22 <contiver> so should I work with Text and later change everything into ByteString before writing to a file?
13:11:30 <Cale> Possibly. The text package includes its own readFile and writeFile, but if you're doing more complicated stuff, you might just want to encode to ByteString first
13:12:03 <Cale> (for a CSS minifier, probably writeFile will be fine on its own)
13:12:14 <trap_exit> I know that sometimes, it is convenient to not write all patterns, ... and get an runtime error when it does not match any pattern. However, is there a way to tel lhaskell "warn me about incomplete patterns" ? I'd prefer to know about them at compile time.
13:12:24 <trap_exit> (and put _ = erro "blah blah blah") to get rid of the compile error
13:12:29 <Cale> -fwarn-incomplete-patterns
13:12:31 <Cale> I think
13:12:49 <Cale> yes, that's right
13:13:25 <mwhit> i just throw -Wall into all my cabal files
13:14:43 <contiver> what I wanted to do was parse the whole file, and rebuilt it from scratch, grouping selectors with the same declarations. I started with Parsec to learn about parsing in Haskell, and was hoping to transition to attoparsec, which I understand uses ByteStrings...
13:14:57 <Cale> You can also do -Wall, but that has things like -fwarn-unused-binds
13:15:33 <trap_exit> Cale, mwhit: I like -Wall .. thanks!
13:15:52 <Cale> trap_exit: Just be warned that it'll warn you about stuff that might actually be fine
13:16:01 <Cale> (even stylistically fine)
13:16:18 <trap_exit> Cale: if it becomes annoying, I'll complain here in a few hours :-)
13:17:23 <Cale> -fwarn-unused-do-bind in particular is obnoxious
13:17:27 <contiver> anyway, I'll read about Text, either way I'll learn something new :). Thanks
13:17:31 <contiver> Cale++
13:17:37 <Cale> I don't think it should be included in -Wall even
13:19:01 <mwhit> is there a way to have -Wall but exclude specific ones?
13:19:21 <benmachine> I think -fno-whatever will do that
13:19:23 <mwhit> otherwise i feel like it's easier to just write "_ <-" a few times than to go through and list everything
13:19:24 <Cale> yeah
13:19:25 <benmachine> after -Wall
13:19:26 <mwhit> oh
13:19:28 <mwhit> cool
13:20:05 <benmachine> (I don't think unused binds are so terrible though, it's nice to be explicit when you throw stuff away
13:20:54 <trap_exit> holy shit, -Wall just caught an error (unused variable ==> I wrote a Monad wrong)
13:21:08 <trap_exit> I am now a believer.
13:21:15 <benmachine> :)
13:25:32 <trap_exit> hmm, "the binding for blah shadows the existing binding" is sorta annoying
13:26:57 <gbwey> hey guys. Is there some way to have the fn return type reflect the Expr return type in this code http://lpaste.net/108655
13:27:44 <gbwey> this code doesnt compile but it was a bad stab at it
13:28:17 <Pythonfant> trap_exit: real believers use -Werr
13:28:36 <Pythonfant> -Werror i mean
13:28:46 <trap_exit> Pythonfant: zealots use -W_rm_src_files_with_warnings
13:29:07 <Pythonfant> :)
13:29:33 <Pythonfant> yeah code that contains warnings should definitly be rewritten from scratch
13:29:43 <opqdonut> gbwey: you could try making fn a type class
13:30:02 <MP2E> rm_src_files_with_warnings... That would be pretty intense. Programming russian roulette :P
13:30:06 <opqdonut> gbwey: but it'll be hard to distinguish between One (x,y) and And ex ey
13:30:34 <mwhit> PythonFant: i used to but then `cabal check` pointed out to me that ghc updates could break the build
13:30:35 <trap_exit> MP2E: well, I think Russian Roulette has a source of randomness, this is like RR with 6 full chambers
13:30:43 <MP2E> Hahha
13:30:43 <opqdonut> gbwey: what if And, Or and One were single-constructor types instead of constructors of a common type?
13:31:10 <gbwey> sure, anything can be changed
13:31:34 <mwhit> by the way guys, that language already exists
13:31:35 <mwhit> https://github.com/munificent/vigil
13:32:51 <gbwey> i think that might work: I'll give that a try
13:33:07 <gbwey> thanks opqdonut
13:34:42 <SrPx> Suppose I have 2 types, "MonsterCard" and "ItemCard". Both of them share some properties (ie, having a name). I also want some functions to accept any of them. What is the most logical way to implement that?
13:35:00 <mmaruseacph2> should TemplateHaskell expand splices with content from the comments?
13:35:12 <mmaruseacph2> that is, I have some prop_ and case_ in comments and using tasty-th
13:35:20 <mmaruseacph2> and I get an error that those are not defined
13:35:29 <SrPx> At this point I am doing something like: "data Monster = Monster { name :: String, ... }; data Item = Item { name :: String, .. }; data Card = ItemCard Item | MonsterCard Monster", but that seems wrong
13:36:12 <mmaruseacph2> SrPx: I'd go with class Nameable a where name :: a -> String
13:36:36 <mmaruseacph2> ignore the last one, I didn't understood your question
13:36:44 <SrPx> okayy
13:36:51 <mmaruseacph2> you have to have different names for the 2 record fields
13:36:59 <mmaruseacph2> so, monster_name and item_name
13:37:14 <Sibi__> Is there a function like this Num a => a -> Text which doesn't use String transformation internally ? ( I have heard converting to String doesn't help much with performance)
13:37:15 <SrPx> woops, true. sorry, I mean: monsterName and itemName. Still, is this the right way to do it?
13:37:36 <Guest69037> Or you can put the records in different modules and use qualified imports
13:37:37 <mmaruseacph2> I think it is
13:37:57 <SrPx> Maybe I should put the records inside a single type? "data Card = Monster { name :: String, ... } | Item { name :: String, ... }"
13:38:33 <mwhit> you could, though that means any function that operates on only one card type becomes an Either/Maybe
13:38:42 <mmaruseacph2> that has a problem though: "data Card = Mosnter { ... x :: Int ...} | Item { ... -- no x --- }"
13:38:47 <td123> Sibi__: hmm, I've also been in search of something like that but I have not found anything, I think what we're looking for is a type class Show a with show :: Show a => a -> Text
13:38:48 <mmaruseacph2> and later you do x (Item ..)
13:39:22 <mmaruseacph2> from the type-level's point of vie x (Item _) is ok even though x is defined only for Monster
13:39:26 <td123> Sibi__: what I've been doing is T.pack . show whenever I need something like that
13:39:42 <Exio4> the type of card could be a phantom type
13:39:59 <Sibi__> td123: Yeah, I'm doing the same. But unfortunately that involves String conversion.
13:40:42 <SrPx> ah I see
13:40:45 <SrPx> Thanks!
13:50:25 <bitemyapp> ozataman: hello
13:50:36 <ozataman> bitemyapp: Hey
13:50:46 <bitemyapp> ozataman: so, I don't totally understand the code, but it looks super promising
13:50:58 <bitemyapp> ozataman: I've been learning the auth/signing stuff so I can send a query over to the local DynDB server :P
13:51:05 <bitemyapp> ozataman: I was thinking I could add tests though.
13:51:57 <ozataman> yeah, working well so far - I have example datasets I run through it to test.
13:52:06 <ozataman> That would be very helpful!
13:52:40 <bitemyapp> ozataman: do you have example code?
13:53:03 <ozataman> Yeah, compile with -fexamples to get an executable w/ some basic cases
13:53:16 <ozataman> I make a point to add an example for each command I implement
13:53:55 <ozataman> It works agains the actual dynamodb service and you'll need a table called "devel-1"
13:54:10 <bitemyapp> ozataman: Examples/DynamoDb.hs?
13:54:13 <ozataman> Yeah
13:54:19 <bitemyapp> cool, thanks.
14:13:34 <benzrf> @hoogle zipDefault
14:13:36 <lambdabot> No results found
14:15:15 <gfixler> I've decided after reading this letter to try to stop thinking of myself as special because I'm learning Haskell: http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
14:15:55 <gfixler> oops - replying to something from yesterday (didn't realize I was so far scrolled up in this window)
14:16:16 <MP2E> a good link, nonetheless
14:16:17 * gfixler was replying to the notion that "Haskell separates the men from the boys"
14:16:46 <gfixler> I fell into that trap - "OO is crap, we've been doing it wrong" - and offending everyone I've ever worked with :)
14:20:56 <oisin634> I'm having a bit of a problem using MVars in multiple threads: http://lpaste.net/108656  My second putStrLn statement is never called - but I'm unsure what would block it?
14:21:00 <SrPx> Is there any (derivable) typeclass for box types? Like this: "data Card = MonsterCard Monster | ItemCard Item deriving (extract); extract (MonsterCard myMonster) == myMonster"
14:24:14 <tgeeky> SrPx: do you want View Patterns?
14:24:23 <tgeeky> I am not sure if the boxed/unboxed part is important here; yet
14:25:15 <Saizan> SrPx: extract there would be like head for lists, something you shouldn't use
14:26:06 <Saizan> SrPx: also, no, there's no such class, the closest would be deriving prisms with the lens package
14:27:40 <SrPx> tgeeky: I've just read the page on View paterns. Very nice to know about it, but I can't see how it applies here.
14:27:45 <SrPx> Saizan: I see, thanks.
14:29:21 * tgeeky wonders what Derivable_ would be called in this case
14:31:53 <OscarZ> whats ment with monads having to be associative?
14:32:17 <jle`> SrPx: would you want it to be a partial function?
14:32:38 <jle`> OscarZ: (f >=> g) >=> h has to be equal to f >=> (g >=> h)
14:33:05 <jle`> er, equivalent/replaceable with
14:37:15 <gbwey> is there a way to create a function that translates data Expr a = And (Expr a) (Expr a) | Or (Expr a) (Expr a) into the equivalent tuples and Eithers: or is that a dependent types thing?
14:38:33 <k00mi> gbwey: do you mean a way to derive that function automatically
14:38:49 <gbwey> yes but not using TH
14:39:39 <gbwey> so given an Expr the fn will convert that to its equivalent Either (a,b) c
14:39:56 <glguy_> You could get there using GHC.Generics, but that's a bit like using TH because you have to automatically derive the Generics instance
14:39:59 <gbwey> where Expr would be Or (And a b) c
14:40:31 <gbwey> so is there really no way to do this?
14:40:43 <gbwey> outside of TH i mean
14:40:49 <k00mi> well, generics
14:40:51 <k00mi> http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html
14:40:57 <gbwey> but thats TH
14:41:04 <k00mi> no
14:41:26 <gbwey> ok maybe that would work
14:41:53 <gbwey> is there any examples of doing something like this using generics
14:42:09 <k00mi> look at that link
14:43:12 <gbwey> thanks i'll take a look
14:43:13 <glguy_> edwardk: How's your hac going?
14:43:27 <edwardk> going well, added coapplicatives to contravariant
14:47:10 <Pal5> hi
14:47:36 <glguy_> Yeah, I saw that commit go by when you logged in today :) I have some staring to do
14:48:46 <trap_exit> haskell is like the 'and they lived happily ever after' of programming langauges
14:48:59 <trap_exit> after slaying the dragon (overcoming biases against type system + laziness), everything just gets better day by day
14:49:28 <Pal5> what are the problems with union types?
14:51:42 <pjdelport> @remember trap_exit haskell is like the 'and they lived happily ever after' of programming languages
14:51:43 <lambdabot> Done.
14:52:09 <monochrom> that depends on what is "union types" you're referring to
14:52:41 <monochrom> to put it more carefully: that depends on the details. the devil is in the details.
14:53:26 <monochrom> my dragon is biased against one kind of laziness, trap_exit. http://www.vex.net/~trebla/photo/unorganized/dragon.jpg
14:53:45 <MP2E> haha
14:53:55 <monochrom> but my dragon is so cute, you wouldn't slay it
14:53:58 <trap_exit> monochrom: is this when you try to read a file, and it returns without reading the entire file?
14:54:06 <monochrom> yes
14:54:23 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#lazynot
14:56:36 <SrPx> This is not working. I'm not sure this is the right way to represent inheritance in Haskell. If anyone has a better solution please tell me: http://lpaste.net/108657
14:57:38 <monochrom> firstly, please reconsider forgetting inheritance altogether
14:58:05 <ryantm> SrPx, consider using type classes
14:59:47 <erisco> > let makeFlush as bs x = (as ++ replicate (length bs - length as) x, bs ++ replicate (length as - length bs) x) in makeFlush [1..3] [1..10] -1
14:59:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:59:49 <lambdabot>    arising from a use of ‘M846295063300315108929127.show_M8462950633003151089...
14:59:49 <lambdabot>  The type variable ‘a0’ is ambiguous
14:59:49 <lambdabot>  Note: there are several potential instances:
14:59:49 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:00:04 <SrPx> monochrom: sure, I know what I shouldn't do. Now I need to know what I should. I am aware typeclasses probably help here, but how? That would eliminate the "Card" type in favor of a "Card" class, I guess. But this wouldn't eliminate the need to write all the boilerplate, right?
15:00:13 <SrPx> ryantm: /\ *
15:00:13 <monochrom> secondly, perhaps you can re-arrange your types a bit differently
15:00:51 <SrPx> monochrom: certainly! how would you do it?
15:00:59 <erisco> > let makeFlush as bs x = (as ++ replicate (length bs - length as) x, bs ++ replicate (length as - length bs) x) in makeFlush [1..3] [1..10] (-1)
15:01:00 <lambdabot>  ([1,2,3,-1,-1,-1,-1,-1,-1,-1],[1,2,3,4,5,6,7,8,9,10])
15:01:06 <roboguy_> SrPx: it can be tricky to represent a subtype relationship in haskell
15:01:20 <monochrom> data Card = Card { name :: String, desc :: String, more :: More }; data More = Monster { hp :: Int, ... } | Item { effect :: String } | Power
15:01:27 <erisco> any betters ideas on how to implement this? typically 'x' will be mempty
15:02:00 <erisco> and a typical use would be in conjunction with zip so that both lists are consumed entirely
15:02:49 <EvilMachine> Hi. I’m looking for something like a file system, with an efficient equivalent of “inodes”, but with no concept of “files” or “directories” whatsoever.
15:03:05 <EvilMachine> Preferably easy to use in Haskell.
15:03:08 <Pal5> untagged union types
15:03:38 <monochrom> untagged has the problem that you need to hand-tag and hand-check the tags yourself, and you are error-prone
15:03:56 <SrPx> monochrom: hmm makes sense
15:04:07 <mornfall> EvilMachine: if you don't have directories, what would refer to those inodes?
15:04:22 <mornfall> EvilMachine: wouldn't that just be a vector then?
15:04:34 <mornfall> (an array if you like)
15:04:55 <tertl3> hi
15:05:16 <tertl3> im having trouble install terminfo in cabal and its stoping me from install elm-lang
15:05:46 <SrPx> monochrom: would it be bad design to just have a "Card" type with every possible field for a card, and just a simple tag, `data Tag = Monster | Item | Power` ? So the "atk" field of an "Item" card is simply set as "Nothing"
15:05:55 <EvilMachine> mornfall: Every inode has a number, right?
15:06:06 <SrPx> monochrom: or 0
15:06:20 <tertl3> it seems to be a problem with ncurses and curses
15:06:26 <monochrom> I'll tell you a story, SrPx.
15:06:48 <pjdelport> SrPx: It's better to make invalid data unrepresentable.
15:07:02 <EvilMachine> mornfall: Well, it should be on the hard disk, and it should be a bit smarter and more efficient than a bare-bones vector. Like file systems, which handle things like a block/inode map.
15:07:02 * SrPx feels like he said something really really wrong
15:07:25 <Pal5> monochrom: did you tell me something about union types?
15:07:26 <roboguy_> > let { makeFlush' [] [] x = []; makeFlush' [] (b:bs) x = (x,b) : makeFlush' [] bs x; makeFlush' (a:as) (b:bs) x = (a, b) : makeFlush' as bs x; makeFlush as bs x = unzip (makeFlush' as bs x) } in makeFlush [1..3] [1..10] (-1)
15:07:28 <lambdabot>  ([1,2,3,-1,-1,-1,-1,-1,-1,-1],[1,2,3,4,5,6,7,8,9,10])
15:07:30 <tippenein> ugh, I hate that cabal generates the .cabal file with trailing whitespace
15:07:43 <roboguy_> erisco: ^ I might just go for explicit recursion
15:07:55 <monochrom> one day, John received the job of designing a data structure for "there are two cases: if the flag is off, there is no extra data; if the flag is true, there is an extra int".
15:07:59 <tertl3> im having trouble install terminfo in cabal and its stoping me from install elm-lang
15:08:05 <EvilMachine> tippenein: You could patch cabal. :)
15:08:07 <pjdelport> SrPx: Having a "Card" type class is probably not a bad idea.
15:08:24 <erisco> roboguy_, thanks
15:08:30 <monochrom> John was a Java-only programmer. or something. he immediately wrote "public class X { private bool flag; private int extra; }
15:08:46 <monochrom> we in Haskell know better and can do better: it's Maybe Int.
15:09:09 <pjdelport> SrPx: Something like: class Card a where { getName :: a -> String, getDesc :: a -> String, ... }
15:09:38 <roboguy_> erisco: also, I suspect that it would be nicer if x was the first argument. Then you can just use "makeFlush mempty" to as a new function that always uses mempty
15:09:45 <monochrom> which comes to what pjdelport says. the tuple (Bool, Int) allows invalid cases. Maybe Int fits exactly the requirement.
15:09:58 <pjdelport> SrPx: then instance Card Monster where { getName = getMonsterName; getDesc = getMonsterDesc }, and so on
15:10:08 <erisco> monochrom, though in languages like Java that is a valid way to implement sum types (unfortunately)
15:10:09 <tippenein> EvilMachine: heh, you think they've already turned down that issue before?
15:10:11 <EvilMachine> monochrom: How can you make lambdabot remember a quote again? ^^
15:10:17 <SrPx> pjdelport: yes I thought about that, I just felt that the fact I was still defining the same fields on each instance (ie, monsterName, itemName...) sounded like some kind of red flag. I guess I'll just shut up and accept that is OK
15:10:22 <mwhit>  @remember
15:10:27 <SrPx> well, thanks (:
15:10:28 <monochrom> we avoid invalid cases because Murphy's Law: if you allow invalid cases, they will happen, they will bugger your program.
15:10:32 <pjdelport> SrPx: That's a *little* bit of boilerplate, but it also gives you the freedom to change how the implementation works for various card types.
15:10:37 <EvilMachine> tippenein: Since when do you need their approval to patch something on your own box? :)
15:10:37 <tippenein> with 500+ open issues for cabal, probably
15:11:05 <tippenein> true, I don't have to be a samaritan about it. keep the fix all for myself
15:11:17 <SrPx> pjdelport: makes sense.
15:11:28 <erisco> roboguy_, nah, just need to (flip .) . flip :)
15:11:45 <EvilMachine> tippenein: Or just fork it, apply that one patch, call it “cabal-ti”, and get it into all the repositories. That will show ’em! :D
15:12:05 <Pal5> what is the problem with something like `data One =One Int; data Two= Two Char; data Three = One U Two`
15:12:27 <roboguy_> erisco: haha, oh pl
15:12:40 <monochrom> Pal5: yes, I replied to you about untagged unions
15:12:56 <mwhit> Pal5: then what operations can you perform on a Three?
15:13:14 <monochrom> I do not understand the exact semantics of "data Three = One U Two". at some point syntax does not tell me anything.
15:13:24 <trap_exit> within the context of https://gist.github.com/anonymous/ef3e31e166b48f6790c2 ... which 'pack' do I want from http://www.haskell.org/hoogle/?hoogle=pack ?
15:13:36 <monochrom> which is what mwhit says concretely. semantics = what can you do with it?
15:13:59 <gamegoblin> Just had the realization that types are to programming what units are to math/science
15:14:06 <SrPx> monochrom: (: thanks
15:14:24 <gamegoblin> Now dynamic typing feels a lot more gross when you think about it being akin to doing physics equations without units
15:14:35 <trap_exit> gamegoblin: welcome to haskell!
15:14:39 <erisco> roboguy_, it would actually be more flexible to only flush the length of one array to at least the length of the other
15:14:59 <gamegoblin> trap_exit: Been here for a while, just didn’t think about that analogy before :P
15:15:00 <erisco> roboguy_, then you can commute the arguments
15:15:06 <roboguy_> erisco: hmm, true
15:15:26 <Pythonfant> :t (.:)
15:15:27 <Pal5> let f :: Three -> String; f x = case x of {One _ -> "Hello one"; Two _ -> "Hello two"}
15:15:27 <roboguy_> you could probably just add one more pattern match for that
15:15:28 <lambdabot>     Not in scope: ‘.:’
15:15:28 <lambdabot>     Perhaps you meant one of these:
15:15:28 <lambdabot>       ‘.’ (imported from Data.Function),
15:15:36 <Pythonfant> hm that's the wron one
15:15:43 <mwhit> Pal5: that's not a union type
15:15:45 <Pythonfant> trap_exit: it should be the one from text
15:15:47 <mwhit> that's a sum type
15:16:02 <trap_exit> Pythonfant: agreed,
15:16:03 <mwhit> data Three = One' One | Two' Two
15:16:28 <Pal5> but then you need a wrapper redundant constructor
15:16:30 <trap_exit> Pythonfant: declare your allegiance! static or dynamic typing?
15:16:41 <roboguy_> Pythonfant: (.:) is just fmap fmap fmap
15:16:42 <roboguy_> haha
15:16:53 <Pythonfant> trap_exit: the type of (.:) from aeson is FromJSON a => Object -> Text -> Parser a, so you definitly need text
15:16:59 <Pythonfant> roboguy_: the one from aeson?
15:17:06 <Pythonfant> trap_exit: static, sir!
15:17:07 <EvilMachine> gamegoblin: Did you watch that video about type algebra? :D
15:17:10 <roboguy_> Pythonfant: oh, nope. I thought you meant the function composition thing
15:17:26 <gamegoblin> EvilMachine: What video?
15:17:28 <Pal5> mwhit: One' One ~ One
15:17:37 <pjdelport> @hackage composition
15:17:37 <lambdabot> http://hackage.haskell.org/package/composition
15:17:47 <EvilMachine> gamegoblin: The one linked at the top of this blog post: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
15:18:08 <gamegoblin> EvilMachine: Haven’t seen it, is it worth watching?
15:18:12 <trap_exit> Pythonfant: some day, when you are ready, may you return to the last you came from and preach the gospel of haskell
15:18:21 <Pal5> let one = One' (One 5)
15:18:24 <Pythonfant> trap_exit: well the nick is mostly a relict from old times
15:18:34 <Pythonfant> I don't like changing it because people get confused
15:18:46 <EvilMachine> gamegoblin: Very much. Example: To find the zipper of a data type, you find its derivative. :)
15:18:59 <monochrom> you can just say: python refers to a kind of snakes :)
15:19:14 <gamegoblin> EvilMachine: Oh god the background buzzing in that video it hurts
15:19:28 <Pythonfant> monochrom: ah good idea, haven't thought of that :D
15:19:32 <EvilMachine> gamegoblin: Just the first 3 minutes.
15:19:35 <Pal5> mwhit: ?
15:19:37 <monochrom> this is what's wrong with videos
15:19:59 <EvilMachine> gamegoblin: There’s a comment saying where it stops buzzing
15:20:03 <monochrom> with html, if you hate its background colour, you can tell your web browser to suppress it
15:20:15 <Pythonfant> roboguy_: hm I need to take a look at that tomorrow, I don't see immediately why the composition is fmap fmap fmap
15:20:19 <monochrom> with video, if you hates its colouring or noise, you can do nothing
15:20:27 <EvilMachine> gamegoblin: Alternatively you can just read the blog posts. But the last part of the video doesn’t exist as a blog post yet. It suffices though.
15:20:51 <Pal5> one -> [ One' tag * ] -> [ One tag *] -> #Int 5
15:21:04 <cmccann> monochrom: untrue. you can not watch the video, that is always an option.
15:21:09 <EvilMachine> monochrom: Remember Opera, where you could set the site style to “C64”? It was so perfect! :)
15:21:09 <cmccann> and it is my preferred one
15:21:29 <trap_exit> https://gist.github.com/anonymous/24243953cd4c5ee5f287 <-- how do I make this compile? I get a parse error on input 'Data.Functor.<$>'
15:21:47 <briennetheblue> fmap fmap fmap is just a silly way of saying fmap . fmap
15:21:59 <cmccann> trap_exit: add more parens, probably
15:22:01 <monochrom> I take the option of skipping the video, too
15:22:19 <roboguy_> Pythonfant: it's the composition that composes a one argument function with a two argument function in the way that ((.) . (.)) does
15:22:28 <roboguy_> (.) = fmap
15:22:40 <EvilMachine> monochrom: I guess your audio system doesn’t offer the ability to plug in audio filters? :) (PulseAudio has a feature, and Veromix makes it easy to use. Any LADSPA/… filter works)
15:22:44 <roboguy_> :t ((.) . (.))
15:22:46 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:22:52 <erisco> > (<!>) = (Data.Functor.<$>) -- trap_exit
15:22:54 <lambdabot>  <hint>:1:7: parse error on input ‘=’
15:22:56 <EvilMachine> monochrom: It was very useful against those Vuvuzelas. :)
15:22:56 <Pal5> mwhit: can you help me?
15:23:13 <cmccann> trap_exit: an operator with a qualified name is still an operator afaik, so you probably want "= (Data.functor.<$>)"
15:23:19 <erisco> > let (<!>) = (Data.Functor.<$>) in (+1) <!> Just 5 -- trap_exit
15:23:20 <Pal5> I know I'm missing something
15:23:20 <lambdabot>  Not in scope: ‘Data.Functor.<$>’
15:23:21 <lambdabot>  Perhaps you meant ‘Data.Function.$’ (imported from Data.Function)
15:23:23 <cmccann> I forget the picky details of syntax here though
15:23:25 <monochrom> but I like Vuvuzelas
15:23:28 <trap_exit> erisco, cmcann: noted, thanks!
15:23:32 <Pal5> > 1+2
15:23:34 <lambdabot>  3
15:23:41 <erisco> I tried
15:23:48 <briennetheblue> fmap . fmap is more general than (.) . (.) but fmap fmap fmap is not more general than fmap . fmap
15:23:51 <geekosaur> didn't you want Control.Applicative?
15:24:06 <tippenein> what does conduit need for system packages? Getting failure on osx
15:24:06 <EvilMachine> monochrom: Lol. Do you happen to live next to a set of colonies of angry bees? :)
15:24:14 <monochrom> no
15:24:18 <EvilMachine> :(
15:24:47 <geekosaur> power line buzz?
15:24:55 <Pal5> monochrom: what did you tell me?
15:25:17 <monochrom> <monochrom> untagged has the problem that you need to hand-tag and hand-check the tags yourself, and you are error-prone
15:25:25 <trap_exit> damn it, is there a way, in Wall, to turn off "Local definition of BLAH clashes with a future Prelude name" ?
15:25:36 <trap_exit> it doesn't clash hyet, so I'd prefer if ghc just stfu and let me do my work :-)
15:25:56 <Pal5> monochrom: can you give an example please?
15:26:07 <monochrom> C has untagged union
15:26:26 <Pal5> monochrom: but unsafe
15:26:39 <Exio4> are pointers safe?
15:26:55 <monochrom> idiomatic C using untagged union is adding tags yourself. struct xxx { int flag; union ... }
15:26:59 <roboguy_> briennetheblue: fmap is one of those functions that you can have probably have any number of repetitions mixed with const and id and it would probably still type check (given some type annotations to disambiguate some stuff)
15:27:11 <Pythonfant> roboguy_: I don't understand why I need 3 dots if I want to write out this manually two are enough, e.g. ((+1) .) . (+)
15:27:12 <Pal5> http://docs.racket-lang.org/ts-guide/types.html#%28part._.Union_.Types%29
15:27:33 <monochrom> I am not sure why I am answering these questions. apparently you already know how to answer them.
15:27:34 <roboguy_> Pythonfant: oh, I wouldn't use either in any actual code
15:27:35 * EvilMachine shudders at the word “idiomatic”…
15:28:05 <foiwjefoiwjeoifo> If you had union types with type classes couldn't that potentially offer a solution to the expression problem?
15:28:14 <Pal5> monochrom: no
15:28:15 <Pythonfant> ah now I got it
15:28:49 <Pal5> I know there must be problems, but I don't see them
15:29:15 <HeladoDeBrownie> briennetheblue, I disagree that fmap fmap fmap is more general than fmap . fmap, unless you allow unlawful Functor instances. Or did you mean something else?
15:29:56 <foiwjefoiwjeoifo> arent fmap fmap fmap and fmap . fmap identical?
15:30:02 <roboguy_> :t fmap fmap fmap fmap id id const (fmap `asTypeOf` (.)) fmap id id fmap
15:30:03 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
15:30:08 <HeladoDeBrownie> foiwjefoiwjeoifo, given the instance in Prelude, yes.
15:30:22 <roboguy_> foiwjefoiwjeoifo: yep!
15:30:30 <cmccann> when did anyone claim fmap fmap fmap was more general than fmap . fmap?
15:30:33 <briennetheblue> HeladoDeBrownie: i said fmap fmap fmap is not more general than fmap . fmap
15:30:52 <HeladoDeBrownie> briennetheblue, ah, my mistake, I missed the "not". Sorry.
15:30:57 <briennetheblue> np
15:31:24 <foiwjefoiwjeoifo> If they're identical then how could one be more general
15:32:09 <Pal5> monochrom: what do ghc do with things like One' (One 5)?
15:32:09 <roboguy_> foiwjefoiwjeoifo: briennetheblue said that fmap fmap fmap *isn't* more general than fmap . fmap
15:32:12 <HeladoDeBrownie> foiwjefoiwjeoifo, well, in the case of certain other typeclasses, there might be more than one valid instance. However, in this case, one is not more general than the other.
15:32:12 <roboguy_> and visa-versa
15:32:25 <HeladoDeBrownie> foiwjefoiwjeoifo, yeah, I misread and caused confusion, sorry.
15:32:27 <roboguy_> foiwjefoiwjeoifo: however, fmap . fmap *is* more general than (.) . (.)
15:32:42 <foiwjefoiwjeoifo> of course
15:32:55 <briennetheblue> which is why i was calling "fmap fmap fmap" silly :p
15:33:16 <foiwjefoiwjeoifo> why does haskell have fmap and (.), why not just make (.) an alias for fmap
15:33:28 * cmccann prefers (<<<) >>> (<<<) 
15:33:29 * HeladoDeBrownie thinks we should make (.) the Functor method and just use (.) everywhere</facetious>
15:33:41 <roboguy_> foiwjefoiwjeoifo: more confusing type errors
15:33:42 * foiwjefoiwjeoifo agrees
15:33:50 <mwhit> doesn't some enhanced prelude do that
15:33:57 <foiwjefoiwjeoifo> well then make a function called compose or something
15:34:02 <cmccann> lambdabot used to do that, actually.
15:34:03 <roboguy_> foiwjefoiwjeoifo: also, (.) fits better as method of the Category typeclass
15:34:03 <cmccann> it was annoying.
15:34:24 <foiwjefoiwjeoifo> ah true
15:34:48 <roboguy_> fmap in general doesn't represent something that could easily be thought of as a composition
15:34:48 <HeladoDeBrownie> foiwjefoiwjeoifo, when you said you agreed, were you also agreeing with the facetiousness of my statement? :P
15:35:02 <shachaf> mpose :: p b a -> Either (p x a) (p b x)
15:36:01 <cmccann> shachaf: sadly that's not going to work very well for (->)
15:36:27 <foiwjefoiwjeoifo> Also, why is there fmap and map instead of something like map and listmap
15:36:28 <shachaf> cmccann: Well, (->) has composition. Why should it have mposition?
15:36:43 <mwhit> foiwjefoiwjeoifo: historical reasons
15:36:44 <foiwjefoiwjeoifo> It seems like you would want the better names to be for the polymorphic functions
15:37:00 <mwhit> also your name makes it really hard to address you :)
15:37:11 <foiwjefoiwjeoifo> well, apparently my nick is temporarily unavailable
15:37:12 <HeladoDeBrownie> mwhit, get a client with tab complete :)
15:37:14 <MP2E> tab completion?
15:37:14 <foiwjefoiwjeoifo> so I typed some random letters
15:37:16 <MP2E> :P
15:37:25 <foiwjefoiwjeoifo> hhhmm what to change it to
15:37:28 <c74d> foiwjefoiwjeoifo: have you tried releasing it?
15:37:30 <shachaf> cmccann: The type I gave sort of arises naturally when you're dealing with unlenses.
15:37:45 <simplename> How do I do that
15:37:49 <simplename> I have no idea how to use irc
15:37:50 <c74d> `/quote nickserv release <nick>`
15:37:59 <simplename> What does that do
15:38:02 <shachaf> cmccann: It's one of the laws of https://en.wikipedia.org/wiki/Apartness_relation
15:38:08 <roboguy_> shachaf: what are unlenses?
15:38:15 <monochrom> I just type "foi<tab>", it's easy and unique
15:38:28 <c74d> simplename: asks NickServ to release <nick>
15:38:41 <cmccann> shachaf: ah yes I think we've talked about this before
15:38:46 <roboguy_> irc without tab completion would be such a pain...
15:38:50 <shachaf> Probably.
15:39:03 <shachaf> But the Either is too strong when you want to be constructive, of course.
15:39:19 <simplename> and what's the difference between quote and msg
15:39:24 <simplename> I should jsut google it
15:39:30 <c74d> you’ll need to be registered, though
15:39:44 <beaky> what are common mistakes when writing haskell
15:39:45 <HeladoDeBrownie> simplename, different clients have different commands. /quote might be inappropriate for your client. For example, in irssi, it sends raw data.
15:39:59 <beaky> apart from blowing out the stack ^^
15:40:17 <aarvar> ah magic
15:40:25 <HeladoDeBrownie> beaky, it might not be very common, but on multiple occasions I've seen people use a monad when a monoid would do.
15:40:40 <beaky> but monads have syntactic sugar
15:40:40 <monochrom> /quote is for writing the IRC protocol raw.
15:40:40 <roboguy_> beaky: improper use of laziness is kinda common
15:40:45 <HeladoDeBrownie> beaky, e.g., define a type like F a and always use it at a ~ (). That's a warning sign
15:40:46 <roboguy_> HeladoDeBrownie: how does that work?
15:40:53 <c74d> Guest98056: `/quote` generally sends a raw command to the server; `/msg` sends a personal message (“query”) to another user
15:41:17 <c74d> Guest98056: you may be thinking of `/query`, which is pretty much the same as `/msg`
15:41:32 <roboguy_> oh
15:41:37 <HeladoDeBrownie> roboguy_, did I answer your question?
15:41:54 <monochrom> so apparently "nickserv" is both a raw command name and a nick you can talk to. but this doesn't generalize.
15:42:05 <roboguy_> HeladoDeBrownie: yeah. I don't know if I've seen that before, but yeah that would be a problem
15:42:36 <monochrom> let me use another example
15:42:41 <cmccann> shachaf: with enough continuation juggling you could make something that looks like that work. it looks reasonable in a dual-intuitionistic sort of setting.
15:42:49 <monochrom> /quote privmsg #haskell hello
15:42:55 <monochrom> /msg #haskell hello
15:43:11 <shachaf> cmccann: whoa, i had questions about dual-intuitionistic logic at one point but you weren't around
15:43:15 <shachaf> and now i've forgotten the questiosn
15:43:22 <HeladoDeBrownie> And as I implied F would have a Monad instance but you wouldn't define an interpreter or the like for it at anything but a ~ (), so it might as well have not been polymorphic
15:43:54 <cmccann> shachaf: disappointing. not that I'm in any way an expert on that stuff, but it is fun.
15:44:30 <shachaf> cmccann: There's also "dual intuitionistic linear logic" which is apparently not the same sense of "dual". :-(
15:44:57 <bb010g> When is the new HP being released?
15:45:48 <shachaf> cmccann: Aha, I had something like uncompose :: (p y e -> p b a) -> (p e x -> p b a) -> p y x -> p b a
15:45:50 <cmccann> shachaf: you could probably make mpose work in classical linear logic, for that matter, given the right choice of connectives. probably everything multiplicative
15:46:05 <shachaf> cmccann: I don't know what the question is but I'm sure the answer is Chu spaces.
15:46:22 <cmccann> sounds reasonable.
15:46:33 <shachaf> Anyway the uncompose I have there actually kind of works in Haskell.
15:47:27 <shachaf> Similarly I had unliftA2 :: (a -> b -> c) -> (p a -> p r) -> (p b -> p r) -> p c -> p r
15:48:19 <shachaf> Instead of something like (a -> b -> c) -> p c -> Either (p a) (p b) which is too strong.
15:48:39 <cmccann> right
15:48:56 <cmccann> instead you have the church encoding of Either hiding in there with a fixed result type
15:49:33 <shachaf> Well, except for the p.
15:49:51 <cmccann> which is the aforementioned "enough continuation juggling"
15:49:53 <shachaf> p c -> (p a -> r) -> (p b -> r) -> r wouldn't help you any, of course.
15:51:33 <cmccann> depends on what "p" is doing, which I have no idea about
15:52:04 <shachaf> I don't know either.
15:52:14 <shachaf> I barely knew when I wrote the code.
15:52:21 <shachaf> All I know is it's contravariant.
15:52:49 <shachaf> My strategy was to define "newtype Un1 p a s = Un1 { unUn1 :: p s -> p a }" and make instances for it and see what happens.
15:53:44 <cmccann> sounds like a good strategy.
15:53:45 <shachaf> And the same for "newtype Un2 p a b s t = Un2 { unUn2 :: p t s -> p b a }"
15:53:47 <cmccann> what happened?
15:54:04 <shachaf> I don't remember.
15:54:27 <SrPx> ahhh System.Random is absolutely genius
15:54:41 <SrPx> wow
15:54:48 <shachaf> A version of the code as it existed once is at http://slbkbs.org/un.hs
15:56:44 <cmccann> shachaf: you should invent a programming language based on dual-intuitionistic logic. I was going to do it but then I got distracted.
15:57:07 <shachaf> cmccann: I would have to understand dual-intuitionistic logic to do that.
15:57:10 <shachaf> (Or would I?)
15:57:31 <Cale> SrPx: hehe, what are you being impressed by?
15:57:32 <cmccann> do you normally understand things before you start doing them?
15:57:43 <cmccann> shachaf: I thought that was not, in general, your policy
15:57:54 <shachaf> looj cmccann
15:57:57 <Cale> SrPx: There's a fair amount about System.Random which isn't very good, but there's at least one really important idea in there too :)
15:58:04 <shachaf> Being entirely consistent is also not my policy.
15:58:20 <SrPx> Cale: split
15:58:40 <cmccann> shachaf: good point
15:58:47 <Cale> SrPx: yes, split is the important operation which everyone ought to have been focusing on for all PRNGs ever
15:59:20 <vanila> is it really that fundamental?
15:59:54 <codygman> > (\x -> init x ++ [(+1) . last $ x]) [1..3]
15:59:56 <lambdabot>  [1,2,4]
16:00:01 <Cale> vanila: yes
16:00:18 <vanila> I think ill looka t that paper
16:00:45 <SrPx> Cale: I was wondering how that rndGen could work, in my view it would either always return the same thing, or beat referential transparency. Then I was writing a recursive function for reshuffling a deck until a condition is met, and I noticed that it does return the same thing ever. Then I noticed what next is for. Then I wondered what would happen if you had a binary recursion and now I read about split (:
16:01:09 <jle`> many of my 'random' code hinges on split working as it should
16:01:11 <m4farrel>  
16:01:25 <jle`> much
16:01:31 <monochrom> if you write functionally, you will really like split
16:01:37 <Cale> jle`: In that case, you should probably use tf-random
16:01:39 <jle`> i haven't done too much analysis on my results though
16:01:46 <vanila> what about the forking bug in libressl?
16:01:51 <jle`> Cale: i'll look into that :)
16:01:59 <jle`> if i notice any irregularities with my results
16:02:03 <vanila> there was an issueon the linux port that, if you fork() - both processes give the same random numbers from then on
16:02:04 <jle`> or maybe i should just look into it anyway
16:02:15 <vanila> but they don't fix this using split, I thik
16:02:24 <HeladoDeBrownie> Cale, I don't get it, why is split special?
16:03:48 <Cale> HeladoDeBrownie: Well, it's needed for a whole bunch of applications, but poorly studied in most cases.
16:05:01 <HeladoDeBrownie> Cale, what's an example?
16:05:06 <Cale> HeladoDeBrownie: If you have a computation with tree-like recursion that requires random generator states, you need an operation of that sort to be able to deliver fresh PRNG states to each branch of the computation.
16:05:23 <jle`> hm
16:05:35 <HeladoDeBrownie> Cale, ah, as opposed to potentially repeating random picks by using the same initial generator?
16:05:39 <jle`> i wonder if you could make that Rand monad use split for the Applicative instance, instead of normal apping
16:05:51 <phaazon> @src (>>=) (->a)
16:05:51 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:05:55 <phaazon> wat.
16:06:01 <jle`> @src (>>=) (->)
16:06:01 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:06:03 <jle`> idk
16:06:20 <cmccann> @src (>>=) ((->) a)
16:06:21 <lambdabot> Source not found. My pet ferret can type better than you!
16:06:27 <cmccann> shrug
16:06:27 <Cale> With a sequential generator, you could pass back the final state from the left branch of the computation to use with the right branch, which works, but is more awkward and defeats parallelism.
16:06:28 <joelteon> the usage is @src (->) (>>=)
16:06:32 <joelteon> take it to PM though
16:06:40 <jle`> HeladoDeBrownie: as opposed to, say, having going down one branch completely, getting the final seed, then going to the next branch
16:06:48 <HeladoDeBrownie> Okay, makes sense.
16:06:49 <jle`> which is what you get if you do a state monad approach
16:06:55 <Cale> HeladoDeBrownie: and yeah, passing the same generator to both branches will result in the same results of course
16:06:55 <Phoenix22>  Here some videos. I hope you like them! http://j.mp/1ALEmBS
16:06:59 <jle`> using only Gen -> (res, gen)
16:08:08 <jle`> in my own particular usage, i initialize entropy generators with seeds and compose them, so if i want a function to produce two entropy generators or compose two independent entropy generators, i need to split
16:08:26 <jle`> (if i want my function to take only one seed)
16:08:55 <vanila> What was the paper on split?
16:09:22 <Cale> http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
16:09:26 <vanila> thanks very much
16:11:41 <Cale> The bad implementation of split in System.Random resulted in some QuickCheck tests passing when they shouldn't have.
16:12:08 <vanila> yikes
16:12:20 <vanila> amazing that someone noticed it!
16:12:39 <Cale> There's a rather embarrassing example at the start of that paper
16:15:58 <vanila> so this issue might apply to software that forks a lot?
16:16:15 <vanila> because forking a process is like splitting a rng
16:16:33 <roboguy_> Cale: it hasn't been fixed yet?
16:16:36 <Cale> Just forking will result in the generator state simply being duplicated rather than split
16:16:46 <vanila> yes that was the bug in libressl
16:16:49 <Cale> roboguy_: It has been fixed, by switching to tf-random
16:17:05 <kadoban> What's (+5) called, the general syntax of specifying one arguemnt of an infix function like that?
16:17:10 <roboguy_> ah
16:17:15 <kadoban> I forgot the term
16:17:16 <HeladoDeBrownie> kadoban, a section
16:17:21 <kadoban> Ah section, thanks.
16:17:22 <roboguy_> kadoban: (`f` x)
16:17:34 <Cale> But sure, if you do something stupid to tweak the PRNG state in one of the forks, then you can end up with similar issues
16:17:34 <roboguy_> is the general syntax for a non-operator named function
16:18:29 <kadoban> Right, thanks
16:19:24 <phaazon> hm
16:19:31 <phaazon> functions as monads is a weeeeird thing :D
16:19:34 <phaazon> but powerful :D
16:19:53 <phaazon> > tail >>= flip zip $ "hello"
16:19:55 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
16:20:07 <roboguy_> > ((*10) >>= (+)) 5
16:20:09 <lambdabot>  55
16:20:16 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
16:20:17 <lambdabot>  ("hello","olleh","HELLO")
16:20:21 <phaazon> yeah roboguy_
16:20:23 <MP2E> haha
16:20:25 <phaazon> who does that? :D
16:20:43 <Cale> Functions themselves aren't monads, it's the type constructor for functions from a given type.
16:20:56 <Cale> i.e. (->) e is a monad for each type e
16:21:49 <Cale> Of course, every monad is also a type-level function: it takes a type and produces another.
16:21:58 <phaazon> 01:18 < Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))  "hello"
16:22:01 <phaazon> ahahah
16:22:03 <phaazon> that’s so great :D
16:22:14 <Cale> That should hopefully reduce the weirdness?
16:22:38 <Cale> I think that example is pretty good at showing what's going on with the definition
16:22:39 <roboguy_> Cale: that's a really good example
16:22:43 <MP2E> weird-be-gone
16:22:49 <MP2E> I agree, it's quite clear what is happening there :)
16:23:05 <phaazon> yeah, it shares something :)
16:23:23 <phaazon> the definition of >>= is somehow weirder
16:23:23 <Cale> > sequence [id,(+2),(*2),(^2),(2^)] 5
16:23:25 <lambdabot>  [5,7,10,25,32]
16:23:36 <phaazon> a >>= f = \r -> f (a r) r
16:23:40 <Cale> Well, when you remember that x >>= f = do v <- x; f v
16:24:05 <Cale> You should be able to recover what x >>= f ought to be by thinking about it :)
16:24:08 <nitrix> So, after couple of years of C and a stepback, I finally have a good picture of its flaws, and recently I've been reading about functional languages (like a lot) every little detail seems like a dream come true.
16:24:48 <nitrix> Would Haskell be the ideal first stop? Anything I should be aware, recommendations to make it easier, etc
16:24:56 <Cale> nitrix: Sure!
16:24:58 <Welkin2> nitrix: I just started writing some python scripts last night after not having touched it for 4 months
16:24:59 <jle`> yea :D
16:25:08 <Welkin2> it felt strange
16:25:12 <jle`> nitrix: Haskell specifically addresses a lot of the flaws of C
16:25:14 <Welkin2> but it's like riding a bicycle
16:25:16 <phaazon> > do { t <- tail; zip t } $ "hello"
16:25:18 <lambdabot>  [('e','h'),('l','e'),('l','l'),('o','l')]
16:25:21 <phaazon> ahah
16:25:22 <Cale> @where lyah
16:25:22 <lambdabot> http://www.learnyouahaskell.com/
16:25:23 <phaazon> <3
16:25:33 <nitrix> Right.
16:25:35 <jle`> nitrix: just be aware that haskell is very much unlike most other functional languages
16:25:40 <phaazon> > tail >=> zip $ "hello"
16:25:41 <lambdabot>  Couldn't match type ‘[c]’ with ‘[b0] -> [(a0, b0)]’
16:25:42 <Cale> nitrix: Feel free to ask lots of questions here
16:25:42 <lambdabot>  Expected type: [a0] -> [c]
16:25:42 <lambdabot>    Actual type: [a0] -> [b0] -> [(a0, b0)]Couldn't match type ‘GHC.Types.Char...
16:25:42 <lambdabot>  Expected type: [[a0]]
16:25:42 <lambdabot>    Actual type: [GHC.Types.Char]
16:25:42 <jle`> that you normalyl hear about
16:25:43 <MP2E> nitrix : I think that Haskell is a great stop :) If you're interested in Functional Languages, you can't really get more functional than purely functional
16:26:01 <Cale> nitrix: and don't be too put off by all the code golf and random mathematics :)
16:26:07 <Welkin2> haskell ruins programming in other languages
16:26:11 <Cale> (that goes on in this channel)
16:26:13 <jle`> nitrix: haskell is a functional language, but that's only a small part about why it's useful and/or an alternative to C
16:26:14 <Welkin2> it's just not as fun
16:26:21 <Welkin2> in other languages
16:26:38 <jle`> i've come to see functional as a superficial distinction for languages :|
16:26:50 <mwhit> i have to go back to Java every weekday :\
16:26:51 <Cale> Welkin2: Well, depending on what you find fun, there might be a few other functional programming languages that are fun :)
16:26:52 <Welkin2> javascript is often referred to as "functional"
16:26:55 <nitrix> jle`: That's what I heard. I figured I might just tackle the beast first and see what my shortcomings are to better understand what I'm getting into. There's also Scheme but Haskell (particularly that Learn You A Haskell) seems really good.
16:27:01 <phaazon> Welkin2: haskell makes you hate other languages. :D
16:27:02 <Cale> Welkin2: especially Coq, Agda and Idris
16:27:08 <benmachine> javascript has lightweight first-class functions
16:27:11 <nitrix> Is it true that it's more of an academic language though?
16:27:17 <benmachine> more than can be said for some of its competitors
16:27:20 <phaazon> nitrix: not anymore I guess
16:27:22 <jle`> Scheme and Haskell i think represent two different spectrums of languages commonly called 'funcitonal'
16:27:23 <Welkin2> Cale: I'd love to play with those some day, but I am busy with haskell
16:27:24 <phaazon> I’d say industrial.
16:27:30 <jle`> nitrix: i don't really think of haskell as an academic language
16:27:32 <vanila> Another really fun functional  language is Cryptol!
16:27:39 <phaazon> and Ook!
16:27:45 <vanila> not Ook
16:27:48 <phaazon> :D
16:27:52 <nitrix> Compared to Go ?
16:27:53 <vanila> http://cryptol.net/ This is the site
16:27:56 <vanila> Go is bad
16:28:00 <vanila> and horrible community
16:28:09 <phaazon> Go is C++ without parens :D
16:28:12 <Welkin2> what's popular is bad
16:28:18 <phaazon> ridiculous
16:28:19 <Welkin2> typically
16:28:22 <roboguy_> Welkin2: agda and idris are pretty much haskell + dependent types (from what I know of them)
16:28:23 <cmccann> there's always unlambda, that's a very functional language. for certain definitions of such.
16:28:30 <jle`> nitrix: you'll find that lispy languages are functional, but much of their power is derived from their awesome metaprogramming capabilities, and how it is such an integral part of the language
16:28:37 <mwhit> i don't understand why Go is all over HN lately
16:28:37 <MP2E> nitrix : Go is a language that doesn't add anything new is the problem, all the features that exist in it existed in 1980
16:28:39 <vanila> Coq is SML/Ocaml + dependent types
16:28:46 <vanila> + automatic theorem proving
16:28:47 <mwhit> i guess it's the new hip lang now that node is "over"
16:28:48 <Welkin2> mwhit: hipsters?
16:28:49 <nitrix> I saw problems in Go, but I kind of liked it over C. It's being used quite widely, but it's so young. I suppose Haskell compared to them must be in a good shape by now.
16:29:01 <jle`> nitrix: in haskell and related camps, their power comes from the strong and expressive type system
16:29:01 <nitrix> MP2E: Yes, that's my understanding of it so far.
16:29:12 <nitrix> jle`: Right <3
16:29:15 <vanila> MP2E, Go also cannot do type safe polymorphic programming
16:29:21 <MP2E> Yes, completely correct
16:29:28 <phaazon> nitrix: Haskell is a UFO :)
16:29:28 <MP2E> which is partly what killed the language for me
16:29:40 <hyPiRion> MP2E: not just for you, I think.
16:29:40 <nitrix> Polymorphic and type safe in the same sentence? what the...
16:29:44 <jle`> i don't really see haskell as academic; i really only see real world uses for it everywhere i go.
16:29:51 <MP2E> nitrix: Haskell makes it easy
16:29:59 <phaazon> what MP2E said
16:29:59 <vanila> MP2E, There is a very simple way to fix this, and I raised this issue in the channel but I was called a troll and bullied for trying to give constructive feedback on their language
16:30:02 <cmccann> haskell lets you actually benefit from static types in the ways that java programmers pretend they do when they want to feel superior to python programmers
16:30:04 <roboguy_> nitrix: polymorphism can actually make things *more* safe in haskell
16:30:10 <Axman6> I think Go would be nice with generics
16:30:17 <roboguy_> nitrix: because it restricts possible definitions of a function
16:30:24 <Welkin2> cmccann: haha
16:30:27 <MP2E> vanila : that's a shame :(
16:30:27 <vanila> MP2E, even barring that, I had to hack the compiler a bunch just make the compiler accept reasonable code
16:30:36 <bitemyapp> cmccann: we get to leverage patterns that they cannot because of the more expressive type system as well.
16:30:46 <bitemyapp> cmccann: such as higher-kinded types making things like Functor/Applicative/Monad more practical.
16:30:48 <Welkin2> cmccann: I have actually been in them iddle of an argument about how java is better than python because of "static typing"
16:30:50 <vanila> yeah, so I cant recommend go to anyone which is a shame because I erally wanted a "safe C" language to replace the use of C!
16:30:56 <jle`> consider a function like a -> b -> a; (a function that can take something of *any* type a, something of *any* type b, and return something of that original type)
16:30:58 <nitrix> Alright guys. I'm sold. The articles were great, the field seems nice, and this channel also looks on point. I'm giving it a try.
16:30:59 <roboguy_> nitrix: for instance, if we exclude things like infinite loops, there is only one implementation of a function of type "a -> a".
16:31:08 <jle`> you'll find that there is only one possible implementation of that function
16:31:11 <Welkin2> like it makes any difference when your type system is essentially useless
16:31:13 <nitrix> I start with Learn You a Haskell?
16:31:22 <bitemyapp> nitrix: https://github.com/bitemyapp/learnhaskell
16:31:24 <phaazon> nitrix: you’ll find a lot of help here then :)
16:31:28 <vanila> Java is a lot better than Python though
16:31:32 <Welkin2> nitrix: I loved LYAH
16:31:34 <phaazon> lyah is a must-read :)
16:31:37 <vanila> it has a better language design and compiler
16:31:41 <Welkin2> also, "haskell hard and fast" was good
16:31:43 <bitemyapp> nitrix: I use my guide to teach people Haskell, we're in #haskell-beginners as well.
16:32:07 <bitemyapp> nitrix: usually we have somebody do some warm-up with LYAH and then flip over to cis194.
16:32:09 <vanila> that said, I would not want to use either
16:32:09 <roboguy_> nitrix: that's one good starting point. regardless of what you choose, I recommend coming back visit #haskell! there's almost always someone happy to answer any questions
16:32:11 <bitemyapp> nitrix: you'll see in the guide what I mean.
16:32:22 <Welkin2> you can also find some lectures by Philip Wadler on youtube
16:32:30 <roboguy_> nitrix: (sometimes many people as you can see right now, haha)
16:32:37 <phaazon> nitrix: you’ll also find Haskell’s basis very simple to understand, even simplier than C’s or any other languages ; the hard gap is the abstraction way of thinking, and the mathematical concepts :)
16:32:48 <Welkin2> undergraduate lectures
16:33:01 <cmccann> yes, #haskell is aggressively helpful at potentially exhausting length
16:33:04 <vanila> Welkin2, I heard strong criticism of those videos
16:33:22 <roboguy_> bitemyapp: that github repo is a good idea
16:33:26 <cmccann> the nice thing about LYAH is that when you need a break it doesn't follow you around and keep explaining things ;]
16:33:28 <phaazon> cmccann: we’re good people <3
16:33:32 <mwhit> everything being said is true, but
16:33:38 <bitemyapp> roboguy_: I hope so.
16:33:39 <nitrix> phaazon: The mathematical concepts scares me the most, but it'll be for the best I think.
16:33:43 <mwhit> i'll say there's a tendency in the community to pretend haskell doesn't have a high learning curve
16:33:46 <mwhit> it definitely does
16:33:46 <bitemyapp> roboguy_: it's helped me continually refine how I teach people a lot.
16:33:47 <vanila> cmears, haha
16:33:52 <mwhit> it's more like learning programming all over again from the stary
16:33:55 <mwhit> t
16:33:58 <mwhit> but definitely worth it
16:34:03 <nitrix> Awesome. See you soon then. (Hopefully this willl make me want to transfer the ownership of ##c to someone else, ah ah).
16:34:08 <bitemyapp> mwhit: I don't think it's quite that bad, but there's a lot of unfamiliar stuff and as you said it's well worth it.
16:34:15 <phaazon> nitrix: you don’t have to worry actually, you’ll understand stuff with examples, like monoids -> lists, or semigroups -> non-empty-lists, and so on
16:34:18 <phaazon> :)
16:34:32 <hyPiRion> bitemyapp: you think learning to program all over again is bad? D=
16:34:33 <nitrix> What's that monad thing...
16:34:34 <roboguy_> nitrix: the mathematical concepts come with time, don't worry about them. I've found you end up learning about them if you don't specifically set out too
16:34:45 <phaazon> nitrix: you’ll discover that in time :)
16:34:49 <Axman6> nitrix: the maths isn't like the maths you're used to. it's much more fun and useful. It is basically just formalising programming itself
16:34:49 <nitrix> Alright.
16:34:50 <hyPiRion> I really enjoy feeling like a complete noob. At least I have something to learn.
16:34:52 <HeladoDeBrownie> nitrix, it'd be best if you learned some about the type system and typeclasses before that's explained.
16:35:00 <ptc_> Have people successfully used Kind-promoted data types with GADT's where the promoted data types are used within a tuple?
16:35:04 <Axman6> nitrix: it's also not necessary to use or think about any of the maths
16:35:18 <MP2E> yeah monads don't really mean anything until you've gotten your feet wet with Haskell a bit :P
16:35:26 <phaazon> Axman6: true, but a good haskeller has to ;)
16:35:27 <Welkin2> nitrix: the typeclassopedia will be your friend while reading LYAH, or afterward
16:35:30 <nitrix> Great! Really great :)
16:35:37 <mwhit> learning monads before you need them is pointless
16:35:44 <phaazon> mwhit: +1
16:35:46 <mwhit> just start writing and it will become obvious when it's time to learn them
16:35:52 <kazagistar> nitrix: the haskell community loves monads, and realized attempting to explain them is silly. The modern method of learning them is by using them in various places without having them thrown in your face
16:35:55 <roboguy_> Axman6: well... at least not use any math in the way that people would be uncomfortable with. ultimately, you would be using math in *some* sense but not necessarily in a super technical way
16:36:04 <Axman6> phaazon: I disagree
16:36:11 <nitrix> I just heard the word, I really have no damn clue what they are, but it seemed to be a point people ranted about so I'm keeping this in mind.
16:36:12 <phaazon> kazagistar: yeah! like Maybe or Either :)
16:36:15 <Axman6> roboguy_: sure
16:36:27 <roboguy_> Axman6: of course, that's a bit needlessly pedantic of me haha
16:36:28 <Welkin2> nitrix: they are pretty simple once you start using them
16:36:34 <nitrix> Alright.
16:36:44 <phaazon> Axman6: maths are key to abstractions
16:36:45 * nitrix goes on reading LYAH :)
16:36:48 <phaazon> they’re useful
16:37:01 <hyPiRion> kazagistar: apparently a lot of people learn what a monad is by writing a blogpost on what they are. At least it seems like it
16:37:12 <Welkin2> yes
16:37:12 <MP2E> haha
16:37:14 <phaazon> of course you can go on and write some haskell code without knowing any of them
16:37:16 <Axman6> phaazon: I've been using Haskell for about 7 years, and it's never been a big issue for me. I know next to no CT and it's never hurt
16:37:16 <Welkin2> they are burritos
16:37:19 <phaazon> I guess it’s a pity then :(
16:37:26 <jle`> which is unfortunate, because the #1 rule about monads is that you aren't allowed to write a blog post about it
16:37:29 <phaazon> CT?
16:37:33 <roboguy_> nitrix: once you have learned about Functor and Applicative, it Monad is easier. so you need to work on the groundwork first (the basics of haskell, then types and type classes, etc)
16:37:34 <MP2E> phaazon: category theory
16:37:37 <Axman6> category theory
16:37:38 <phaazon> oh, ok
16:37:41 <phaazon> well
16:37:44 <bitemyapp> hyPiRion: no, just not how I'd think of it.
16:37:45 <Welkin2> category theory is fun though
16:37:52 <phaazon> as said earlier, I find CT quite fun in Haskell :)
16:37:56 <bitemyapp> hyPiRion: you do get to reuse some intuitions from other languages when learning Haskell. it's not a reset to zero.
16:38:18 <HeladoDeBrownie> For me, the connection to programming is mostly what makes CT fun.
16:38:22 <phaazon> knowing what a “morphism over category is” and that Functor is the category of endofunctors is quite fun :)
16:38:27 <kazagistar> well, a parser is built as a two continuations (success and failure) around a state, so its like... enchilatas! ... or something
16:38:29 <MP2E> I had little interest in learning math and I was in fact intimidated when I started learning this language, now I'm reading books like Homotopy Type Theory and I can't get enough
16:38:34 <MP2E> What have you done to me Haskell?!? :P
16:38:38 <bitemyapp> hyPiRion: I'm teaching somebody from zero right now, no programming experience just basic computer competency.
16:38:40 <MP2E> hehe
16:38:47 <phaazon> :P
16:38:51 <bitemyapp> hyPiRion: we take a lot of things for granted that this from-zero student cannot/does not.
16:38:58 <bitemyapp> hyPiRion: here, want an example?
16:39:12 <bitemyapp> hyPiRion: she wanted to know what the "bar" function was and what it did. LYAH didn't explain foo and bar weren't supposed to mean anything.
16:39:13 <hyPiRion> bitemyapp: fire away
16:39:15 <roboguy_> HeladoDeBrownie: that's how I thought originally too, but I'm starting to realize that some of the other connections are pretty cool too. There's an interesting relationship to rational tangles
16:39:15 <Welkin2> bitemyapp: but do they have an advantage?
16:39:18 <cmccann> bitemyapp: that depends partly on what languages and how you used them. I've met some programmers whose prior experience would be a net negative when learning haskell
16:39:22 <bitemyapp> Welkin2: It's too early to say.
16:39:32 <Welkin2> they don't have years of imperative practice drilled into them
16:39:34 <bitemyapp> cmccann: I've taught people like that. I'm reserving judgment for now.
16:39:39 <bitemyapp> Welkin2: it's not as much of a win as you think.
16:39:42 <ptc_> Anyone know why I'd be getting errors with DataKinds + GADTs with tuples? https://gist.github.com/paulcavallaro/0aa86fa9735d167699a1
16:39:44 <Welkin2> "I'll use a loop with an index counter"
16:39:46 <HeladoDeBrownie> roboguy_, that's why I included the "mostly"; it's also kind of fun in itself.
16:39:52 <bitemyapp> My from-zero student has less unlearning to do, but much more actual work to do.
16:39:55 <vanila> x<Welkin2> "I'll use a loop with an index counter" <-- I do this a lot in haskel
16:39:55 <Welkin2> like when C programmers first learn Python
16:39:56 <nitrix> roboguy_: Oh, so haskell has category theory. I suppose that makes sense if it has lot of mathematical concepts.
16:40:01 <Axman6> ptc_: #ghc might be a better place to ask
16:40:10 <vanila> f x y z = loop 0 where loop i ...
16:40:11 <ptc_> Axman6: thx
16:40:17 <Axman6> though it's probably pretty quiet at the moment
16:40:23 <roboguy_> nitrix: yeah. it's not necessary to know any category theory to learn haskell though. but it can be fun to learn (at some point)
16:40:25 <bitemyapp> Welkin2: this person understands neither iteration nor recursion.
16:40:27 <Axman6> or not, seems a few people are there
16:40:32 <bitemyapp> Welkin2: there's nothing at all for them to work with.
16:40:39 <shachaf> Axman6: #ghc is for GHC development, not user questions.
16:40:49 <HeladoDeBrownie> nitrix, I think it'd be more accurate to say that Haskell borrows some concepts from category theory. Although it's in a somewhat limited form.
16:40:59 <nitrix> Okay.
16:41:04 <jle`> you guys should just the guy learn now ;)
16:41:07 <jle`> or girl
16:41:10 <jle`> or girls
16:41:10 <Welkin2> shachaf: I have used it for help with the clang/gcc mess
16:41:11 <nitrix> Yes, ah ah. Please.
16:41:21 <jle`> i don't think anything said after this will do anything more than overload
16:41:22 <Axman6> shachaf: it's also full of the people who would know why certain GHC specific features might not interract well.
16:41:40 <hyPiRion> jle`: I think we've managed to do that 5 minutes ago
16:41:43 <MP2E> ^
16:41:55 <MP2E> #haskell information explosion
16:41:56 <bitemyapp> ^^
16:41:58 <nitrix> It's re-assuring in a way.
16:42:00 <nitrix> :)
16:42:00 <roboguy_> ptc_: what's IntTy?
16:42:09 <bitemyapp> lets all be thunks pointing to the same value!
16:42:12 <ptc_> roboguy_: sorry, refresh updated gist
16:42:12 <jle`> Axman6: still, it is probably considered off-topic
16:42:16 <Welkin2> #haskell-in-depth?
16:42:21 <Welkin2> I have never been there actually
16:42:22 <MP2E> bitemyapp : indirection is fun!
16:42:25 <Welkin2> what do they discuss?
16:42:32 <bitemyapp> MP2E: triple-star programmer!
16:42:52 <roboguy_> :k (,)
16:42:54 <lambdabot> * -> * -> *
16:42:59 <shachaf> Axman6: Yes, but for the most part those people would rather see those questions elsewhere.
16:43:00 <roboguy_> huh, not polykinded
16:43:19 <roboguy_> I guess that makes sense
16:43:23 <jle`> Axman6: a lot of people here might know about vim, but we're not going to have people in #vim refer users to #haskell, are we? :)
16:43:28 <Axman6> shachaf: we don't really have an appropriate place to ask though. #haskell is too loud
16:43:43 <Axman6> jle`: that seems like the opposite of what I did
16:43:44 <ptc_> roboguy_: please to explain fully?
16:44:11 <cmccann> jle`: we've had non-Haskell-programmers come here asking for help using xmonad on occasion
16:44:12 <roboguy_> ptc_: well, I suspect that the reason (,) only works with the kind * is because that's the only kind that has inhabited types
16:44:15 <jle`> Axman6: someone asked a question about haskell and you referred him to a channel that is specifically about compiler development?
16:44:22 <roboguy_> ptc_: all other kinds only contain uninhabited types
16:44:25 <shachaf> ptc_: You seem to be missing some code, or something. I don't get the same error from your file, I get "Not in scope".
16:44:35 <roboguy_> shachaf: he updated it
16:44:37 <ptc_> shachaf: sorry, refresh,
16:44:41 <ptc_> yeah what roboguy_  said
16:45:10 <bss03> Where do I go to browse stackage provide by FPComplete in a certain build?
16:45:21 <roboguy_> ptc_: try using this:  data Pair :: i -> j -> *
16:45:23 <roboguy_> with PolyKinds
16:45:24 <ptc_> roboguy_: OHHHH, so I can hack this with (undefined :: IntTy) no?
16:45:28 <roboguy_> ptc_: no
16:45:29 <nitrix> One last thing, I assume Haskell would be a bad thing for, say, a FUSE file-system? Since I/O are involved and has a tendency to make things impure?
16:45:40 <bss03> I'm thinking ghc-7.4 might still use old-time, and I want to print some timing information in one of the examples I'm composing.
16:45:44 <jle`> nitrix: IO is great at impure stuff and imperative stuff
16:45:44 <benmachine> nitrix: well, there are already bindings for FUSE, make of that what you will
16:45:45 <shachaf> ptc_: What is the kind of Op?
16:45:45 <roboguy_> ptc_: wait
16:45:47 <HeladoDeBrownie> nitrix, Haskell has no problem with I/O.
16:45:50 <roboguy_> ptc_: what are you trying to do?
16:45:57 <jle`> nitrix: haskell probably deals with IO better than any language I know
16:46:04 <jle`> it deaps with it in probably the only sane way possible, heh.
16:46:05 <nitrix> Okay, interesting.
16:46:11 <jle`> deals
16:46:13 <MP2E> nitrix: you should look at xmonad
16:46:19 <MP2E> :P
16:46:25 <benmachine> nitrix: http://hackage.haskell.org/package/HFuse
16:46:27 <mwhit> nitrix: haskell makes you be explicit about the I/O you do. People who don't know haskell often interpret this fact as "haskell doesn't want to do I/O and making it do so is a hack"
16:46:28 <vanila> Cale, that trick with hashing paths is really beautiful :)
16:46:29 <Axman6> jle`: someone asked a question about some features that are sopecific to GHC, and I referred them to a channel with experts in those features
16:46:31 <mwhit> they are very wrong
16:46:39 <nitrix> Actually, since the operations are probably given to you in a form of callback, from that point on, there's not really anything impure involved.
16:46:40 <roboguy_> nitrix: IO actions are first class which is really handy. they're also statically typed
16:46:43 <cmccann> nitrix: in Haskell it's really easy (in fact, obligatory) to treat "imperative actions" as first-class values
16:46:54 <nitrix> Nice.
16:47:05 <jle`> Axman6: the channel has people who know about the features, but asking about hwo to use them is explicitly off-topic
16:47:11 <cmccann> nitrix: so you can manipulate them in ways that impure languages can't even talk about in a straightforward way
16:47:19 <benmachine> thing is, I actually find that other languages also have concepts of pure and impure values
16:47:26 <nitrix> Hackage!? A package manager <3 oh mah.
16:47:29 <ptc_> roboguy_: trying constrain the construction of operations on a vm stack by encoding for each operation what it consumes and what it produces
16:47:30 <roboguy_> benmachine: hmm, how so?
16:47:36 <mwhit> nitrix: well, not exactly
16:47:38 <MP2E> well cabal is the package manager, hackage is the place to host the pakcages
16:47:39 <mwhit> it's a package database
16:47:39 <shachaf> Axman6: The topic of #ghc says "Please ask user questions in #haskell".
16:47:40 <MP2E> packages*
16:47:44 <mwhit> and cabal is a build tool
16:47:45 <benmachine> roboguy_: well, you have certain concepts where you know it is safe to evaluate this or that
16:47:45 <shachaf> ptc_: It looks like there are a couple of issues.
16:47:46 <glguy_> ptc_: Try to write the kind signature you think "Op" should have
16:47:54 <mwhit> there's no proper "package manager" for haskell really
16:47:55 <MP2E> right *facepalm* shouldn't have said package manager :P
16:47:56 <benmachine> roboguy_: it's just that Haskell has them typed, so you can't get it wrong
16:47:59 <nitrix> I see. This is looking great ! :)
16:48:02 <roboguy_> benmachine: ahh, right
16:48:11 <shachaf> ptc_: What I (and glguy) said is one of them.
16:48:29 <Axman6> -_- fine. ptc_ don't ask in #ghc, keep repeating your question in here for hours until no one responds
16:48:35 <roboguy_> nitrix: also, personally, learning about haskell is probably some of the most fun I've had learning about programming (and I do enjoy programming in general too)
16:48:36 <shachaf> ptc_: You might have a better time with the other one if you write something like '( 'IntTy, 'IntTy).
16:48:37 <glguy_> Ah, sorry, channel was moving faster that I was reading
16:48:59 <ptc_> shachaf: mm, k, let me stare at this for a sec
16:49:02 <mwhit> yeah i love how "tell me why haskell is great" ramps up activity by about an order of magnitude
16:49:09 <MP2E> hahaha
16:49:13 <MP2E> yeah
16:49:21 <benmachine> well, we all have opinions on it :P
16:49:26 <jle`> i don't
16:49:27 <roboguy_> shachaf: oh, I totally forgot about that
16:49:30 <shachaf> Axman6: The solution to "this channel is terrible" isn't "go make that other channel terrible too".
16:49:34 <jle`> (jk)
16:49:40 <MP2E> jle` has facts 8)
16:49:57 <tertl3> is this the room for C++?
16:50:04 <Axman6> yes
16:50:08 <mwhit> yes, i love templates!
16:50:10 <Trollinator> that must be the dumbest question ever.
16:50:17 <aarvar> No, this is for javascript
16:50:19 <jle`> i've used c++
16:50:32 <Rarrikins> tertl3: Try room 12.
16:50:33 <jle`> you've found a room full of c++ users :D
16:50:41 <nitrix> No, this is patrick :3
16:50:51 <hpc> welcome to #perl, where everything's made up and the punctuation doesn't matter
16:50:53 <benmachine> I had some C++ but I didn't inhale, or something
16:50:55 <tertl3> awesome, so i heard that ++x id different from x++, is this true?
16:51:06 <benmachine> tertl3: yeah, ++C isn't even a thing
16:51:07 <roboguy_> tertl3: yes
16:51:13 <MP2E> lol?
16:51:36 <roboguy_> tertl3: pre-increment and post-increment are the keywords to look up
16:51:37 <Axman6> why would there be two different shorthand ways of doing the same thing?
16:51:45 <Axman6> of course they're different
16:51:56 <jle`> Axman6: tell that to python users ;)
16:51:57 <benmachine> Axman6: never written perl, huh
16:52:09 <jle`> oh i mean
16:52:10 <tertl3> tell that to english users :\
16:52:12 <jle`> ruby users, sorry
16:52:20 <jle`> python is the one that believes there is only one true way to do anything
16:52:22 <mwhit> list comprehensions
16:52:26 <Axman6> I'm seeing a trend here
16:52:27 <jle`> ruby is the one where you can do anything a hundred ways
16:52:51 <Trollinator> every useful language is like that.
16:53:05 <Exio4> i prefer one hundred ways to do something instead of a single way that doesn't fit everywhere
16:53:07 <jle`> Trollinator: not to the extent that they have 10 aliases for the same function in a library
16:53:12 <Axman6> lens is probably a good example of that too
16:53:12 * shachaf sighs
16:53:23 <vanila> Cale, will this replace GHCs current RNG?
16:53:24 <Trollinator> jle`: what function would that be?
16:53:40 <hpc> fleeting thought: language where there really is only one way to do anything
16:53:41 <Cale> vanila: Well, it's available on hackage
16:53:41 <tertl3> im gonna go to fpcomplete and make a program
16:53:55 <Cale> vanila: Hopefully it'll eventually be standard
16:53:55 <hpc> every unique program has only one valid representation in source code
16:53:58 <HeladoDeBrownie> hpc, there's a language like that, it's a combinator calculus of a single combinator
16:54:04 <HeladoDeBrownie> hpc, multiple, I think
16:54:08 <vanila> Koen Claessen <- Oh he wrote ReadP!
16:54:19 <benmachine> hpc: depends how you define equality on programs, I guess
16:54:20 <hpc> HeladoDeBrownie: i mean like, if you want to define id, there's only one way to do it
16:54:25 <jle`> Trollinator: how many alias of map and fold are there in Array?
16:54:31 <hpc> it'd definitely not be turing complete
16:54:35 <hpc> but it might be funny
16:54:38 <benmachine> heh
16:54:41 <vanila> I think
16:54:47 <shachaf> ptc_: I can't help you anymore. Hopefully your problem is resolved.
16:54:50 <glguy_> ptc_: http://lpaste.net/108664
16:54:51 <HeladoDeBrownie> hpc, including having no non-normal forms?
16:54:54 <roboguy_> ptc_: I think you might need to do "data IntTy; data BoolTy"
16:55:01 <Trollinator> jle`: I was asking about ruby.
16:55:10 <jle`> Trollinator: yeah, in ruby
16:55:10 <roboguy_> ptc_: ghc doesn't like things that are GADTs in their kind arguments
16:55:11 <mmaruseacph2> non_standard_id x = head $ cycle [x]
16:55:19 <mmaruseacph2> a different way to write id :)
16:55:27 <hpc> HeladoDeBrownie: there can be one non-normal form :P
16:55:28 <ptc_> glguy_: nice, not sure I can adapt that though
16:55:33 <Trollinator> jle`: I don't know, you tell me.
16:55:45 <roboguy_> ptc_: then get rid of the 's
16:55:51 <vanila> https://hackage.haskell.org/package/tf-random
16:56:00 <glguy_> ptc_: That proably about as good as you'll get. You have to pick one kind for each argument shared across all constructors
16:56:05 <HeladoDeBrownie> hpc, well, this didn't really need saying and still doesn't, but that sounds more like a toy language than anything :P
16:56:13 <hpc> yeah
16:56:15 <mmaruseacph2> is tf-random better than the current System.Random?
16:56:24 <ptc_> glguy_: wonder if I could use HLists for this?
16:56:34 <hpc> tf-random? is that how valve got past having to count to three?
16:56:41 <benmachine> it would be kind of briefly interesting to see how rich a language for defining functions you could have while still having extensional and intensional equality be the same thing
16:56:49 <Trollinator> anyway, there are quite a few aliases in Haskell's standard library, often type-restricted ones.
16:56:51 <ptc_> glguy_: then everything is just a HList of ValTy and then things can consume arbitrary things off the stack and put back an arbitrary number...
16:56:52 <Axman6> ptc_: pretty sure you need to prefix your types with ' no?
16:57:02 <Trollinator> <$>, map, fmap
16:57:09 <Trollinator> or ($) and id
16:57:11 <Axman6> NewInt :: Int -> Op UnitTy IntTy ==> NewInt :: Int -> Op 'UnitTy 'IntTy
16:57:30 <mmaruseacph2> ah, I see, it's only another instance of RandomGen
16:57:32 <benzrf> Axman6: *unity
16:57:36 <glguy_> depends on what you're trying to do, this is your other option : http://lpaste.net/108664
16:58:02 <Axman6> benzrf: ?
16:58:49 <roboguy_> mmaruseacph2: there used to be a problem with the built in RandomGen instance, I don't know if that's still the case
16:59:16 <jle`> Trollinator: point taken :)
16:59:21 <roboguy_> mmaruseacph2: http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
16:59:39 <bss03> Does UTCTime have a Show instance?
16:59:39 <mmaruseacph2> thanks
16:59:43 <bss03> example here: https://www.fpcomplete.com/tutorial-preview/4412/jrYbqhM0L8
17:00:07 <hpc> bss03: if it does, i don't think it has a very useful one
17:00:15 <bss03> haddocks says it does: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/time/Data-Time-Clock.html#t:UTCTime
17:00:17 <hpc> there's a class somewhere for time formatting
17:00:30 <bss03> I don't need a very useful one.
17:00:43 <stalintrotsky> If I put a StateT s IO in a evalStateT . forever, will the IO actions inside the StateT get evaluated as it loops?
17:00:48 <bss03> It's just show that 0 seconds passes vs. 5 seconds passes.
17:00:51 <benzrf> bbl
17:01:02 <hpc> btw, there's http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html#v:formatTime
17:02:06 <hpc> also http://hackage.haskell.org/package/old-locale-1.0.0.6/docs/System-Locale.html#v:rfc822DateFormat
17:02:42 <bss03> So, it this a haddock bug?  haddock shows a Show instance, but using print fails with a there-no-Show-instance error. :(
17:02:58 <mwhit> it might be an orphan instance in a different module
17:03:18 <roboguy_> > show (undefined :: UTCTime)
17:03:20 <lambdabot>  Not in scope: type constructor or class ‘UTCTime’
17:03:23 <mwhit> in fact it definitely is
17:03:36 <mwhit> all the time package read instances are in data.time.format
17:03:39 <mwhit> not sure about show
17:04:02 <roboguy_> mwhit: it looks like that has show too
17:04:44 <bss03> mwhit: Ugh.  That's not a very good UX.  Figuring out where to import instances from is a pain, sometimes.
17:04:48 <mwhit> yeah so basically just import from Data.Time, i think that just reexports everything
17:04:57 <l0cust> yep
17:04:58 <mwhit> this actually just came up earlier today for DAy
17:05:40 <glguy_> bss03: The instance is in "Data.Time.LocalTime" . No, that isn't a good thing.
17:06:18 <bss03> Thanks all.
17:06:18 <mwhit> bss03: yeah a stdlib package probably shouldn't do something as unnecessary as orphan instances
17:06:29 <bss03> IS this worth filing a bug against the time package?
17:06:39 <bss03> Assuming I can replicate with that latest versions.
17:13:25 <sclv_> bss03: i think there was some ridiculous design decision reason for it
17:13:45 <sclv_> but its worth reopening a discussion
17:13:59 <sclv_> something about factoring dependencies...
17:17:33 <bss03> sclv_: Hrm.  Okay.  Where's the best place to bring that up and possibly proffer a patch?  Haskell-cafe?
17:17:55 <bss03> sclv_: I didn't see a bug tracker or mailing list linked form the hackage package page.
17:18:22 <sclv_> i’d do the libraries list and make sure you cc the maintainer
17:19:16 <glguy_> The reason for the bug is another bug. Instead of offering a matching Read/Show pair suitable for read show it uses the localized time printing functions in local time to make a "pretty" output
17:21:24 <teakay> hey all
17:21:34 <bergmark_> bss03: https://github.com/haskell/time
17:22:02 <teakay> anybody here use emacs for haskell?
17:22:13 <mietek> ugh
17:22:18 <mietek> > readP_to_S P.decimal "1.276741"
17:22:18 <mietek> [(1,".276741"),(1.276741,"")]
17:22:19 <roboguy_> teakay: I do sometimes
17:22:20 <lambdabot>  Not in scope: ‘readP_to_S’Not in scope: ‘P.decimal’
17:22:30 <mietek> Why does this return more than 1 parse?
17:22:44 <teakay> im having a major struggle getting it all set up
17:22:46 <mietek> The parser succeeded right up to the end of input
17:22:55 <vanila> mietek, that's just what readp is like
17:23:04 <bergmark_> teakay: what's "all"?
17:23:04 <bss03> bergmark_: Thanks! http://hackage.haskell.org/package/time still lists the darcs repo.  I guess that's another patch to proffer the maintainer.
17:23:05 <mietek> Is there a way to tell it "ReadP, you're drunk, stop here already"
17:23:06 <vanila> you can add an eof to the parser, if you want only the full parse to succeed
17:23:23 <mietek> vanila: I did try adding eof... but I don't think this composes well
17:23:27 <bergmark_> bss03: yeah, i just guessed that it might be mirrored or moved to the haskell org :-)
17:23:28 <mietek> Or perhaps I did it wrong
17:23:35 <mietek> Should it compose well?
17:23:40 <vanila> dont put the eof whe you copse it with other things
17:23:45 <mietek> haha
17:23:47 <mietek> Well, that sucks
17:23:50 <vanila> no
17:23:50 <teakay> specifically, at the moment i cant get flymake to show errors. or rather, it shows syntax errors, but no type errors whatsoever
17:24:07 <vanila> it doesn't suck
17:24:14 <glguy_> mietek: Did you write P.decimal?
17:24:18 <mietek> Yes
17:24:28 <teakay> also not sure whether i should be using flymake or flycheck
17:24:32 <sclv_> it looks like the repo is patched to the new repo, but it hasn’t been uploaded yet?
17:24:33 <glguy_> Post that definition, that's where the bug is
17:24:52 <glguy_> mietek: At some point you need to use <++ instead of +++, most likely
17:24:54 <vanila> ReadP, unlike parsec, handles multiple possiblities with backtracking correctly
17:25:12 <mietek> I am not actually using +++ at all
17:25:17 <mietek> Oh, but I am using choice.
17:25:21 <bergmark_> teakay: ok, i don't use flymake
17:25:25 <mietek> hm
17:25:30 <bergmark_> i just use ghci
17:26:03 <glguy_> choice returns all parses. if you have an ambiguity you'll have to resolve it
17:26:19 <teakay> bergmark: alright. at least the repl seems to be working well, though it was a struggle to get that running as well
17:26:29 <mietek> glguy_, vanila: http://lpaste.net/108666
17:26:57 <vanila> you can use your parser as is
17:27:11 <vanila> consider (decimal >> plusSign >> decimal)
17:27:30 <vanila> 1.276741+3 is going to return the parse Plus 1.276741 3
17:27:33 <teakay> out of interest, what do the rest of you use to write haskell in?
17:27:41 <vanila> the parse that stops at "1" isn't going to occur, so it doesn't matter
17:27:50 <mietek> vanila: so I thought
17:27:57 <mietek> But I am running into an issue later
17:28:20 <mietek> Can you clarify the difference between "many1 . satisfy" and "munch1" for me, please?
17:28:31 <mietek> Does munch1 return only a single parse?
17:28:43 <teakay> i assume you are the haskell-on-heroku mietek?
17:28:50 <mietek> teakay: hi :)
17:29:08 <roboguy_> teakay: these days, depending on my mood, I use FPComplete's Haskell center, sublime, lighttable and I'm starting to figure out vim
17:29:17 <ddrone> Hi everyone! Is there a package which defines functor fixpoint?
17:29:19 <roboguy_> (and sometimes emacs)
17:29:24 <glguy_> mietek: from the haddock: Parses the first one or more characters satisfying the predicate. Fails if none, else succeeds exactly once having consumed all the characters Hence NOT the same as (many1 (satisfy p))
17:29:49 <teakay> great work on haskell-on-heroku! :)
17:29:49 <glguy_> gtg
17:29:54 <mietek> glguy_: well, I did read the haddock...
17:30:12 <mietek> teakay: thanks. It still needs more. What are you using it for?
17:30:16 <roboguy_> ddrone: recursion-schemes
17:30:33 <roboguy_> ddrone: recursion schemes defines all three actually
17:30:35 <ddrone> Thanks!
17:30:44 <teakay> im using it with rehno, who youve been in contact with i believe
17:30:48 <roboguy_> (Fix, Mu and Nu)
17:30:49 <mietek> Aha, right, yep
17:31:02 <roboguy_> unfortunately, the docs are a bit lacking though
17:31:31 <mietek> teakay: sadly I am delayed with releasing 1.0
17:32:41 <teakay> ive been using haskell with sublime up until now, but getting horrible performance so ive switched back to emacs, it just always takes so long to get set up :/
17:33:05 <teakay> roboguy_: much support for haskell in lighttable?
17:33:17 <mietek> vanila: ping
17:33:38 <roboguy_> teakay: there's some. I haven't tried to use anything like flycheck with it though
17:37:48 <ryantm> teakay, http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html
17:38:40 * hackagebot fb 1.0.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.4 (FelipeLessa)
17:40:39 <teakay> ryantm: yea thanks. i was following that, but my experience hasnt lined up unfortunately. he mentions things should work which just dont for me
17:41:08 <bitemyapp> cmccann: http://stackoverflow.com/questions/2899278/using-items-in-a-list-as-arguments this was terrifying btw.
17:42:26 <erisco> bitemyapp, awesome :)
17:42:39 <bitemyapp> erisco: "this that are really cool but you should never do"
17:42:41 <erisco> Haskell now has call_user_func_array almost
17:43:02 <lfairy> bitemyapp reminds me of the implementation printf
17:43:03 <bitemyapp> erisco: I'm sure acme-php would love this as a contribution.
17:43:13 <bitemyapp> lfairy: there are type-safe printfs for Haskell.
17:43:26 <bitemyapp> lfairy: Cf. Holey monoid
17:43:44 <erisco> bitemyapp, lol I had no idea that was a thing
17:43:56 <erisco> Mr Quinn you are a funny man
17:43:57 <Welkin2> holey?
17:45:21 <bitemyapp> Welkin2: Holey.
17:45:25 <erisco> bitemyapp, I have done silly metaprogramming things like this before... I kinda wish it did not have to be silly
17:45:27 <cmccann> bitemyapp: as well it should be
17:45:41 <bitemyapp> Welkin2: http://hackage.haskell.org/package/formatting http://hackage.haskell.org/package/HoleyMonoid
17:46:23 <lfairy> bitemyapp: acme-php is horrifying
17:46:26 <cmccann> and yes, the implementation of printf works similarly but that has a better reason for it
17:46:33 <cmccann> lfairy: it's a work of art
17:46:38 <lfairy> bugs... bugs everywhere
17:46:39 <luite> cmccann: i suspect that can be implemented more cleanly with a closed type family
17:46:59 <bitemyapp> luite: cleaner than the holey monoids based one?
17:47:04 <cmccann> luite: most likely. it predates a lot of nifty GHC extensions that would probably help.
17:47:30 <luite> bitemyapp: oh i'm not sure if i recall how that was done
17:47:45 <bitemyapp> luite: http://hackage.haskell.org/package/formatting http://hackage.haskell.org/package/HoleyMonoid
17:47:47 <erisco> dependent Haskell, one day
17:47:55 <luite> cmccann: ah 2010, didn't realise the date :)
17:47:55 <bitemyapp> erisco: well, Liquid Haskell exists.
17:48:07 * benmachine giggles at "oh well, in /that/ case" followed by five pragmas
17:48:44 <cmccann> lfairy: acme-php was written by hpc, so if you find anything in it that works correctly he's the one to tell so it can be "fixed"
17:48:54 <hpc> yo
17:48:57 <erisco> bitemyapp, interesting, never heard of it. no idea what a refinement type is
17:49:00 <bitemyapp> hpc: your work is getting some love.
17:49:14 <bitemyapp> erisco: it's part of what people want dependent types for. related to path spaces/type families.
17:49:15 <hpc> pull requests go here: https://github.com/headprogrammingczar/php-haskell-prelude
17:50:02 <hpc> especially if you find any language misfeatures like that overlapping/flexible instances stuff from this morning
17:50:06 <hpc> those are encouraged
17:50:23 <hpc> there's a fantastic one in there already for import lists
17:50:26 <hpc> see if you can find it :D
17:50:56 <hpc> HoleyMonoid is the best damn package name
17:51:32 <lfairy> hpc: the correct implementation of foldr made me do a double take ;)
17:52:01 <hpc> is it correct though?
17:52:31 <hpc> lol i forgot about foldl
17:52:41 <tac> can someone help me diagnose this error?
17:52:42 <tac> http://lpaste.net/108668
17:53:04 <tac> I am not sure why this doesn't work. And if I change the Data.ByteString import to Data.ByteString.Lazy, I get a different error
17:53:16 <hpc> (<>) = getLine
17:53:33 <hpc> i keep forgetting parts of that package, and they are always still hilarious
17:54:16 <luite> bitemyapp: oh that's not list apply though but the other way around, building the function instad of applying it. should be fun to try to list-apply one with a variable number of laters, i'm not sure if it's possible to satify the constraints
17:54:39 <bitemyapp> luite: yeah I thought maybe you were referring to the printf stuff.
17:54:43 <bitemyapp> luite: I see what you mean now.
17:55:03 <lfairy> tac: the error is in decodeUtf8
17:55:30 <lfairy> tac: either decodeUtf8 requires a strict ByteString and it got given a lazy one, or the other way round
17:55:48 <lfairy> there should be another encoding function that does what you want
17:55:51 <tac> ahh
17:56:08 <bitemyapp> tac: there is more than one decodeUtf8
17:56:16 <bitemyapp> tac: you might be able to just swap that one out for the one you actually want.
17:56:20 <tac> hmm
17:56:27 <tac> That kind of stuff is really hard to tell from the docs
17:56:30 <bitemyapp> well
17:56:35 <tac> Could you provide an explicit fix?
17:56:37 <bitemyapp> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
17:56:37 <bitemyapp> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
17:56:44 <bitemyapp> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
17:56:44 <bitemyapp> Data.Text.Lazy.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
17:56:49 <tac> ah tyty
17:56:51 <bitemyapp> so we see there are lazy and non-lazy variants
17:57:00 <roboguy_> hpc: (<>) = getLine?
17:57:05 <bitemyapp> I've no idea what the non-Either versions are supposed to do when the content is mangled.
17:57:11 <tac> also, somewhat related
17:57:19 <tac> How does the wreq library signal errors?
17:57:24 <bitemyapp> tac: exceptions I think
17:57:35 <bitemyapp> tac: do you have hoogle installed locally? I have it installed with "data all" and integrated into my ghci. life-saver.
17:57:36 <tac> like if I have a 404 error, does a lens into the contents just give me an empty bytestring?
17:57:49 <tac> bitemyapp: I do not. cabal install hoogle?
17:58:01 <bitemyapp> tac: I install it into a sandbox.
17:58:02 <tac> (and hoogle seems like something best to do system-wide, right?)
17:58:06 <jle`> bitemyapp: they are exceptions
17:58:07 <tac> ah
17:58:07 <tac> ok
17:58:21 <bitemyapp> mkdir hoogle && cd hoogle && cabal sandbox init && cabal install -j3 hoogle && .cabal-sandbox/bin/hoogle data all
17:58:28 <bitemyapp> tac: ^^ then go make tea. and lunch.
17:58:32 <tac> heh
17:58:37 <bitemyapp> tac: then:
17:58:38 <tac> unfortunately, I already started the tea
17:58:39 <tac> and it just finished
17:58:54 <bitemyapp> tac: https://github.com/bitemyapp/dotfiles/blob/master/.ghci#L1
17:59:02 <dreams> is the term "closure" in the context of lazy functional languages used for all functions?
17:59:03 <bitemyapp> tac: I can ":hoogle" from my ghci.
17:59:08 <bitemyapp> tac: after sym-linking it into my path.
17:59:08 <tac> neat
17:59:15 <tac> that is many steps though
17:59:21 <tac> I will have to take a bit to get that
17:59:26 <bitemyapp> dreams: closure imples there ie scope enclosing the function object
17:59:35 <bitemyapp> dreams: because it's a reference to lexical scope
17:59:37 <tac> although gdi, this lazy-vs-strict library stuff pisses me off :(
17:59:42 <tac>     Couldn't match type `Data.Text.Internal.Text' with `Text'
17:59:52 <bitemyapp> dreams: if you're returning a function object that isn't closed-over, I'm not sure it's a closure even if it could've been.
17:59:58 <bitemyapp> dreams: it's not a distinction most bother to make.
18:00:03 <bitemyapp> dreams: they usually just say "function"
18:01:06 <tac> _String from Data.Aeson.Lens looks like maybe it's returning a strict Text
18:01:16 <dreams> bitemyapp: Ah, hmm, there some papers that talks about closure like all functions are closures. I guess they mean functions.
18:01:24 <tac> this is probably better if I change the Wreq call to strict bytestring though
18:01:33 <bitemyapp> dreams: possibly. I can't be too sure really. It's a very common term.
18:02:01 <jle`> you know what would be cool
18:02:02 <tac> how do you convert lazy BS to strict BS?
18:02:14 <jle`> @hoogle toStrict
18:02:15 <tac> ah
18:02:16 <tac> yeah
18:02:17 <lambdabot> Data.ByteString.Lazy toStrict :: ByteString -> ByteString
18:02:17 <lambdabot> Data.ByteString.Lazy.Char8 toStrict :: ByteString -> ByteString
18:02:17 <lambdabot> Data.Text.Lazy toStrict :: Text -> Text
18:02:17 <tac> just found it
18:02:27 <jle`> a -> IO (b -> IO (c -> IO d))
18:02:30 <jle`> is that any common pattern
18:03:08 <lfairy> tac: I recommend just using strict stuff for everything
18:03:18 <lfairy> there's not much to gain from the lazy ones
18:03:21 <roboguy_> jle`: reminds me a little of Free
18:03:34 <jle`> it's like some sort of monadic partial application
18:03:39 <tac> lfairy: I don't want to be using the lazy one to begin with
18:03:44 <tac> but it looks like wreq chooses lazy
18:03:50 <tac> because it's a stream
18:03:52 <jle`> like you have a -> (b -> (c -> d)), except you don't get the "next" functions until you execute
18:03:54 <roboguy_> jle`: it looks like a computation broken into steps
18:04:04 <roboguy_> or an IO action broken into steps
18:04:08 <jle`> it's the same as a -> b -> c -> d, except you need to execute to get the next part
18:04:14 <jle`> hm
18:04:20 <jle`> yeah it does sound like that too
18:04:22 <roboguy_> what's the best way to reinstall yesod?
18:04:51 <roboguy_> jle`: that's why it reminds me of a free monad
18:04:54 <joelteon> how'd you do it the first time
18:05:00 <jle`> hm
18:05:08 <roboguy_> joelteon: well, the problem is getting rid of it in order to get it again
18:05:12 <roboguy_> I got a new version of ghc
18:05:14 <joelteon> okay
18:05:16 <roboguy_> which screwed things up a little
18:05:17 <joelteon> well how did you do it the first time
18:05:19 <joelteon> just undo that
18:05:58 <lfairy> tac: well, what you should do depends on your use case
18:05:59 <roboguy_> I tried ghc-pkg unregister yesod, but that didn't seem to get rid of the yesod executable
18:06:08 <joelteon> just remove the yesod executable
18:06:13 <joelteon> or don't, if you install yesod again it'll overwrite it
18:06:20 <lfairy> tac: if you're loading the whole thing into memory anyway, might as well call Data.ByteString.Lazy.toStrict on it
18:07:00 <tac> Call this an opinion, but I think it's stupid that they use the same name for both types >__>
18:07:23 <roboguy_> joelteon: hmm, it didn't seem to overwrite it when I installed it again before. maybe there's something else going wrong.  it's giving me the error "ERROR: Yesod has been compiled with a different GHC version, please reinstall" when I try yesod devel
18:07:38 <joelteon> did you reinstall yesod-bin
18:07:44 <tac> but
18:07:49 <tac> it looks like this is compiling
18:07:51 <tac> so cool
18:07:55 <roboguy_> joelteon: oh, maybe not. I'll try that
18:08:33 <tac> like, why not ByteString vs ByteStream?
18:08:45 <tac> Text vs TextStream
18:08:57 <joelteon> ask bos
18:09:28 <roboguy_> jle`: it looks kinda similar to Free (Compose ((->) a) IO)
18:09:44 <roboguy_> except the types can change
18:11:39 <ab9rf> hrmph.  the sqlite package seems to have a minor problem for me
18:11:40 <jle`> hmmmm
18:12:11 <ab9rf> it lets me insert data, but query statements always return rows containing empty data (albeit the correct number of such rows)
18:12:50 <mietek> vanila, glguy_: thanks, your hints were quite helpful.  I understand Text.ParserCombinators.ReadP much better now.
18:13:36 <marchelzo_>  /join #c++
18:13:37 <roboguy_> joelteon: ahh, that fixed it. thanks! it looks like the problem was that I was trying to reinstall yesod-bin in a sandbox
18:13:38 <mietek> Optimised my parsers not to return needless extra parses.
18:13:48 <marchelzo_> >.<
18:13:58 <mietek> marchelzo_: we all know now.
18:14:36 <roboguy_> haha
18:15:20 <marchelzo_> mietek: oh no my worst secret is out!
18:16:01 <jle`> @djinn s -> ( s -> (a, s), s )
18:16:02 <lambdabot> -- f cannot be realized.
18:16:12 <jle`> wat
18:16:32 <jle`> oh yeah
18:16:44 <jle`> @djinn (s -> ( s -> (a, s), s )) -> (s -> (a, s))
18:16:45 <lambdabot> f a b =
18:16:45 <lambdabot>     case a b of
18:16:45 <lambdabot>     (c, d) -> c d
18:17:27 <jle`> cool, join for State s
18:17:33 <jle`> why do we even write programs ourselves
18:17:35 <MP2E> djinn <3
18:17:39 <jle`> (the answer is: to write djinn)
18:19:03 <roboguy_> I hope djinn is updated one of these days
18:19:48 <gamegoblin> So I’m trying to replace a bunch of IO (Either a b) with some sort of EitherT. How would one define my EitherIO type?
18:19:58 <jle`> gamegoblin: from scratch?
18:20:04 <jle`> @unmtl EitherT e m a
18:20:04 <lambdabot> EitherT e m a
18:20:07 <gamegoblin> jle`: Does there exist something I want?
18:20:13 <jle`> there's EitherT and ErrorT
18:20:17 <Abathurr> women can be very strange.
18:20:17 <gamegoblin> Basically IO actions with short-circuit failure
18:20:24 <jle`> ErrorT has some sort of weird constraint on the error type
18:20:29 <gamegoblin> Abathurr: ??
18:20:30 <jle`> gamegoblin: yeah, ErrorT and EitherT will have those for you
18:20:51 <jle`> EitherT e m a = IO (Either e a)
18:20:55 <jle`> so literally what you want :)
18:20:57 <jle`> er
18:21:01 <jle`> EitherT e IO a = IO (Either e a)
18:21:06 <jle`> @unmtil ErrorT e m a
18:21:07 <lambdabot> m (Either e a)
18:21:26 <jle`> EitherT e IO a defines sensible definitions of (>>=)/return for an IO (Either e a) type
18:21:45 <jle`> but you should really have no problems defining them yourself, either
18:23:34 <jle`> ex >>= ef = do { x <- ex; case ex of Left l -> return (Left l); Right r -> ef r }
18:24:37 <jle`> you'd use EitherT, the constructor, to turn your IO (Either a b) into an EitherT e IO b, and you'd use liftIO to turn an IO b into an EitherT e IO b
18:26:05 <Abathurr> excuse my ignorance but what is a point-wise function
18:26:37 <yoeluk> roboguy_: have you tried snap? I haven't used any but install both and my take was that snap had fewer hurdles and it stared a new projects in a blink while yesod was slow
18:27:12 <roboguy_> yoeluk: not yet. I'm planning on trying both eventually
18:27:30 <gamegoblin> jle`: yeah doing type EitherIO a b = EitherT a IO b is working fine
18:28:06 <jle`> gamegoblin: the you'll need a newtype if you want to do the short circuiting
18:28:12 <jle`> because you need to define a new monad instance
18:28:16 <yoeluk> roboguy_: ok thanks... I am myself wondering what's the correct choice since things might not be what they think :)
18:28:30 <gamegoblin> jle`: No I don’t? It’s working just fine...
18:28:50 <yoeluk> roboguy_: what they seems*
18:29:05 <gamegoblin> jle`: Because EitherT is a member of MonadIO, I think?
18:29:12 <jle`> gamegoblin: oh yeah, sorry
18:29:13 <jle`> i misread
18:29:26 <jle`> yeah, that works :)
18:35:36 <nezt> How do monads prevent side effects?
18:36:14 <mwhit> they don't.
18:36:57 <platz> I believe even the term "side effects" is under-specified around here
18:37:32 <vanila> monads let you express effectful computations using a pure functional language
18:37:33 <platz> depending on how rigorous one is
18:37:50 <Peaker> nezt: I wouldn't say "monads" do that.  Haskell has side-effect-free "evaluation" and execution of "IO".  IO has all the ordinary effects, but Haskell makes those explicit in the types, so they're more "effects" than "side-effects".  IO programs are explicitly composed with an operator that happens to be monadic, but the fact its monadic is pretty irrelevant
18:38:32 <mwhit> monads are a system for managing compmlexity, like any design pattern
18:38:36 <nezt> so monads don't do anything specifically to separate pure and impure code ?
18:38:42 <mwhit> the fact that haskell uses monads to manage IO is incidental to this
18:38:54 <mwhit> no, the IO monad specifically does
18:39:40 <mwhit> but its ability to do this is not just because it is a monad
18:39:53 <mwhit> but also because there's no way to extract a value from that monadic context
18:39:57 <mwhit> no constructors are exported, etc
18:40:05 <Peaker> nezt: The IO type (and some other types) separate pure code from effectful code.  When you want to compose pure programs, you do that directly, via function application/composition. When you want to compose impure/IO programs, you use an operator/combinators which happens to be inside an interface/typeclass called "Monad", but IO could have its own composition operators that aren't of that interface
18:40:27 <roboguy_> nezt: there is a lot of confusion regarding IO and it's relationship to the idea of Monad. IO is only one example of a Monad
18:40:30 <haasn> I don't like this phrasing
18:40:36 <haasn> in my opinion, there is no such thing as “effectful code”
18:40:38 <haasn> Haskell is always pure
18:40:47 <haasn> IO doesn't separate anything, because there's nothing to separate
18:41:11 <Peaker> nezt: so, composing a pure function (a -> b) with (b -> c)   you can use (.).    Composing an effectful action described by (IO a) with an effectful function described by (IO b) uses an operator (>>) ::  IO a -> IO b -> IO b
18:41:16 <joelteon> IO is a DSL that describes how to do effectful things
18:41:21 <mwhit> IO is unique in that once a computation enters an IO context, there is no "leaving" it
18:41:37 <Peaker> haasn: I disagree, pure functions and effectful procedures. The latter are represented/described by IO-typed values
18:42:01 <haasn> Disagree, since (IO a) is a pure value
18:42:07 <Peaker> nezt: "effectful action" is what I meant above rather than "effectful function"
18:42:17 <Peaker> haasn: it's a pure value that describes an impure procedure
18:42:59 <Peaker> There are two levels at play here, and the level you're focusing on is the less interesting one, that doesn't describe the semantics the programmer is interested in
18:43:06 <platz> I prefer "datastructures" to "procedure" because procedure implies execution
18:43:38 <Peaker> At a lower level, "IO a" is just a pure value, composed with pure operators. But the *meaning* of that pure value and that composition, is an impure procedure and composition of impure programs
18:43:51 <mwhit> but the point is that outside of the actual haskell community, people talk about "monads" and "haskell IO" as though they are interchangeable
18:43:54 <mwhit> and they are not
18:44:00 <Peaker> platz: What we have here is a data structure that represents a procedure
18:44:07 <jle`> Peaker: but that seems to suggest that there is some sort of "divide" in Haskell between "pure code" and "impure code"
18:44:39 <nezt> a lot of reading on haskell mentions how it forces the functional style, which allows for pure code that is stateless and isolated from side effects. but obviously a program needs to be stateful to interact with the outside world (IO ) so i guess i'm confused how the separation of these two (via monads?) is meaningful .
18:45:00 <Peaker> jle`: I'd say there is -- code in IO and code that isn't.. Like most DSLs, the integration is quite smooth, but IO is still a separate DSL/sub-language
18:45:13 <bitemyapp> nezt: http://bitemyapp.com/posts/2014-03-25-when-nested-io-actions-are-wanted.html
18:45:27 <bitemyapp> nezt: doesn't seem very stateless :)
18:46:31 <Peaker> nezt: basically the "top-level" of your program called "main" is a procedure of type: "IO a" (for some a).  It can be generated by your program by composing various IO values, which is equivalent to a C program's main() calling other procedures.  However, all of these IO actions can also apply/use pure functions. These pure functions may not do IO, and that's where the interesting part is, as most of your program will be there
18:46:47 <cmccann> nezt: the key point is that Haskell requires (via the type system) that you be explicit about which expressions have side-effects and when they're executed
18:47:09 <cmccann> nezt: the rest of it is all implementation details, including the use of a monad
18:47:12 <mwhit> all of which actually has nothing to do with monads
18:48:06 <dmj`> nezt: if you transform monads you can simulate mutable state and perform IO, StateT IO () is a good example
18:49:12 <Peaker> nezt: The "Monad" part is connected to this very weakly, because it happens that the way you compose smaller IO programs into larger ones is using a standard, general interface called "Monad", that can compose various other things and not just IO programs.
18:49:46 <Peaker> nezt: of course IO composition operators could have been specific to IO rather than special cases of a more general thing, but to understand IO/effects, it's not relevant
18:50:17 <nezt> Ah
18:50:19 <nezt> thanks everyone
18:52:33 <platz> the thing that makes an 'IO t' data structure different from some arbitrary java bytecode, is that bytecode is an opaque black box, and represents commands that will be executed immediately, whereas an 'IO t' just "describes" the intended action, remains composable and is a first-class value in your program
18:55:43 <platz> and I think the part that isn't mentioned as much is that it's necessary to draw a distinction between the "runtime" and "evaluation", but it's not ever necessary to draw this distinction in other languages, which I think is where the confusion comes from
18:56:25 <platz> and this gets all conflated with monads
18:57:03 <vanila> why do you have to distinguish runtime and evaluation?
18:57:48 <gamegoblin> @pl \a b -> return b
18:57:49 <lambdabot> const return
18:58:34 <platz> side note - it's not something you have to think about when writing programs, but it comes up when pressing into details about haskell, IO, and purity
18:59:52 <platz> vanila: evaluation is pure, the runtime is not (the runtime cannot otherwise it wouldn't be able to interact with the actual world)
19:00:53 <platz> but evaluation is what allows you to reason about your program
19:02:26 <vanila> ok that's a good point
19:16:12 <solatis> i'm starting to get the feeling that cloud-haskell (a.k.a. distributed-process) is still lacking a lot of polishing, and can easily be considered overkill. is this true?
19:18:09 <Axman6> overkill for what?
19:18:53 <platz> solatis: if you really want to bite this bullet, it's hard not to just use erlang
19:19:08 <solatis> yeah i don't really like erlang
19:19:11 <solatis> feels too much like perl
19:19:26 <platz> syntax = skin-deep
19:19:39 <solatis> that's true
19:20:58 <vanila> isn't erlangs syntax more like prolog than perl?
19:21:31 <platz> vanila: yeah definitely prolog-inspired
19:21:31 <solatis> yeah i got severely disappointed when i found out that records were merely a hack on top of the preprocessor
19:22:08 <platz> hrmm, i have yet to really dig into it but I plan to
19:22:12 <solatis> anyway, for me the point of this excercise is to learn haskell, not to be pargmatic :)
19:22:40 <platz> hahahah
19:22:56 <Axman6> why do you need distributed-process?
19:23:40 <solatis> ah i'm porting an application which uses a central redis pub/sub queue to haskell.. i'm trying to figure out all options, and a stream-based approach using cloud haskell seems like the 'holy grail'
19:24:00 <nezt> so i downloaded a hackage package, it shows up as an installed package... i'm confused on how to run it.. sorry, i'm a serious noob
19:24:15 <solatis> nezt: #haskell-beginners also exists :)
19:24:49 <platz> netj: try looking in .cabal/bin/
19:24:53 <roboguy_> nezt: which package?
19:25:03 <nezt> learn-physics-0.5
19:25:07 <bss03> nezt: Well, if it is just a library, you won't run it directly.  If it does install executables, look for them in ~/.cabal/bin
19:25:11 <nezt> it has a main function
19:25:18 <nezt> i did cabal install
19:26:22 <nezt> bss03: that answered my question thanks!
19:29:50 <stalintrotsky> I have two instances of a class C, for String and C a => [a]. It says that there's overlapping instances for String, but there is no instance for Char. What am I doing wrong?
19:30:18 <roboguy_> stalintrotsky: well, for one thing String is a type synonym for [Char]
19:31:01 <roboguy_> another thing is, instance matching doesn't work like pattern matching. if two instances can match a certain case, it's considered overlapping instead of picking the first one
19:31:29 <stalintrotsky> Shouldn't the type constraint prevent [a] from matching String?
19:31:32 <roboguy_> constraints are not taken into account when looking for overlapping instances, I think
19:31:38 <stalintrotsky> Oh
19:31:41 <mwhit> correct
19:31:43 <lfairy> roboguy_: ^
19:31:43 <stalintrotsky> is there a way to fix that?
19:31:55 <mwhit> i had a more complex version of this exact question like a few hours ago
19:32:14 <roboguy_> stalintrotsky: turning on OverlappingInstances doesn't work?
19:32:30 <stalintrotsky> I didn't know that option existed, thanks
19:32:46 <stalintrotsky> It worke
19:32:47 <stalintrotsky> d
19:34:18 <nitrix> Is haskell lazy evaluation a language specification requirement or a frequent implementation optimization?
19:35:20 <roboguy_> nitrix: non-strict evaluation is a language spec requirement. lazy evaluation is a kind of non-strict evaluation
19:35:28 <solatis> nitrix: i find it hard to believe that it would not be a language req
19:35:28 <roboguy_> lazy evaluation is non-strict evaluation with sharing
19:35:44 <nitrix> I see, so it's required with the specs but the proper name would be non-strict evaluation.
19:35:45 <roboguy_> the most popular implementations are lazy
19:35:54 <roboguy_> nitrix: sharing is not required by the spec
19:36:06 <roboguy_> but all the popular implementations have it
19:36:17 <nitrix> What about call tail optimization?
19:36:17 <roboguy_> and that's what makes lazy more specific than non-strict
19:36:23 <roboguy_> I believe that's required
19:37:02 <roboguy_> sharing just means if we have a binding called "x" and we need to evaluate it at some point, we never have to evaluate the binding "x" again
19:37:11 <nitrix> Because it seems like these details are very important as they would dictate the use of recursion and similar.
19:37:34 <nitrix> I'll keep reading.
19:37:36 <roboguy_> tail recursion isn't as necessary as it is in a strict functional programming language
19:37:42 <roboguy_> but it is good to be aware of that issue
19:38:18 <nitrix> So far I like the guide, I'm making progress :)
19:38:21 <Total_1mmersion> Is it possible to write this function? http://lpaste.net/108670
19:40:17 <roboguy_> Total_1mmersion: I don't know very much about ST, but I suspect it isn't because STVars can't escape an ST
19:40:18 <Total_1mmersion> Oops, there was a mistake. The paste is updated.
19:40:26 <roboguy_> or STRefs
19:40:33 <c_wraith> Total_1mmersion: ok, that makes way more sense now.
19:40:44 <Total_1mmersion> I don't think the problem is related to that, roboguy_
19:40:56 <c_wraith> yeah, that's perfectly implementable
19:40:57 <Total_1mmersion> The problem is that modifySTRef takes a function (a -> a)
19:41:09 <roboguy_> oh
19:41:11 <Total_1mmersion> I want to pass a function (a -> b)
19:41:31 <c_wraith> Oh, wait..  There is a problem.
19:41:45 <c_wraith> You lack a base case.  The Fix can't bottom out.
19:42:05 <Total_1mmersion> My first thought was to put all the STRefs in an association list and look them up, but that doesn't feel right
19:42:22 <Total_1mmersion> Ah you're right, I forgot that, let me update the past quite
19:42:24 <Total_1mmersion> quick*
19:42:58 <Total_1mmersion> Updated to include NoPlain and NoNumbered
19:43:04 <Total_1mmersion> so the recursion can bottom out
19:43:22 <c_wraith> It can be implemented, yes.
19:43:30 <Total_1mmersion> Do you know how?
19:43:33 <Total_1mmersion> I would love to know =)
19:45:31 <c_wraith> Exact implementation depends kind of heavily on the definition of Fix and Compose..  Where are they?
19:46:32 <Total_1mmersion> Data.Fix and Data.Functor.Compose
19:47:08 <c_wraith> What package?
19:47:10 <Total_1mmersion> The hardest part of the implemenation is handling cycles
19:47:51 <Total_1mmersion> data-fix
19:48:26 <Total_1mmersion> transformers
19:48:32 <Total_1mmersion> those two
19:52:20 <trap_exit> does anyone have an exakple of using Aeson + FromJson on a sum_type ?
19:55:09 <NemesisD> trap_exit: here's one I dug up https://github.com/MichaelXavier/librato-haskell/blob/master/src/Network/Librato/Types.hs#L152
19:56:28 <Ankhers> Could someone please help me speed this up? http://lpaste.net/108675
19:56:34 <trap_exit> NemesisD: How do you search for something like this?
19:56:34 <c_wraith> Total_1mmersion: http://lpaste.net/108670 compiles, and looks right.  It's kind of annoying to actually test. :)
19:56:57 <NemesisD> trap_exit: you mean search for the code? i wrote it some time ago
19:57:05 <trap_exit> Ankhers: I think you're using a O(n^2) algorithm -- instead you should use a O(n log n) algorithm, by using a Map
19:57:19 <trap_exit> NemesisD: ah, that would explain how you found it
19:57:56 <Ankhers> trap_exit: Could you please explain how I could change this to a map?
19:58:12 <roboguy_> Ankhers: I think trap_exit means the Map data type, not the function 'map'
19:58:19 <Ankhers> oh
19:58:20 <trap_exit> roboguy_: exactly
19:58:27 <Ankhers> That makes more sense.
19:58:29 <trap_exit> you want to keep a map of Map elem-type Int
19:58:33 <NemesisD> trap_exit: to write it initially i just looked at the type, parseJSON :: Value -> Parser a, you can just pattern match on the value and use pure if your ADT are simple tokens, applicative is your friend here. i could help you figure out the parser you want if you'd like, but I need more info
19:58:36 <trap_exit> where the Int stores how many time the var has occured
19:59:09 <trap_exit> NemesisD: I think I'll be find; I have a basic parser working; I was jut not aware of "withText" + parseTaggedEntitytType "tag-name"
19:59:18 <trap_exit> NemesisD: I will bother you later if I fail to get it to work
20:01:22 <NemesisD> trap_exit: that may be a bad example, your parser is likely to be much simpler, i just scanned through code I wrote to find one
20:01:40 <trap_exit> NemesisD: alright, let me put something on gist that you can help jme with
20:01:41 <trap_exit> give me 2 mins
20:02:30 <NemesisD> general question: i see so many packages with very search-friendly names like URI, that were written years ago and use String for everything. seems like the current thinking is that String is considered harmful. is this a problem?
20:02:51 <trap_exit> String is slow
20:02:56 <NemesisD> seems like it may be a bad idea for library authors to use data types with performance problems like String
20:02:57 <trap_exit> I've been told to use LazyText
20:02:59 <lispy> String is great for many things
20:03:12 <lispy> It's bad when you have a lot of Strings
20:03:16 <lispy> or very large Strings
20:03:34 <NemesisD> lispy: but thats the trick. if you're a library author you don't know what the final use case will be
20:03:47 <trap_exit> NemesisD: https://gist.github.com/anonymous/25dd96829f15d989225a ... okay, so the KeyDownEvent used to work. However, now, I want to represent a "GUI Event", which can either tbe a "KeyDown" or a "Mouse" -- and I want to be able to dispatch on the "tag" field. I'm using ghcjs -- so the JS code ends up creating the proper Haskell types
20:05:03 <NemesisD> trap_exit: ok i've got a couple suggestions. let me get this in my editor
20:05:30 <trap_exit> NemesisD: great, looking forward to it
20:07:05 <roboguy_> welp, this is ridiculous. this guy's not going to concede. oh well http://www.reddit.com/r/programming/comments/2cbjcc/the_comonadreader_letter_to_a_young_haskell/cje62bt
20:08:28 <vanila> does anyone know waht promted edwardk to write that
20:09:19 <NemesisD> trap_exit: i'd do something like this https://gist.github.com/MichaelXavier/d331d9817f120daf5a65
20:10:03 <roboguy_> vanila: I don't think he wrote it
20:10:32 <roboguy_> I think it's just on the blog site he owns
20:10:36 <trap_exit> NemesisD: loet me try this out
20:10:38 <vanila> really?
20:10:50 <vanila> oh it's by Gershom Bazerman
20:10:57 <vanila> well why did he write it?
20:11:40 <NemesisD> roboguy_: i've never gone on /r/programming but just been linked to it. seems like a place where haskell people get in fights over things?
20:12:01 <vanila> reddit is a bad site with a really horrible community
20:12:07 <roboguy_> NemesisD: sometimes. they are actually mostly more acceptive of haskell than I would have expected
20:12:07 <geekosaur> s/haskell//
20:12:19 <roboguy_> NemesisD: /r/haskell is obviously more receptive though
20:12:36 <NemesisD> trap_exit: so to explain some things, aeson expors withObject, withArray, etc to capture the pattern of parsing an object that must be of a certain JSON type and give a useful error message otherwise
20:12:44 <platz> each subreddit has it's own norms and feel to it
20:12:45 <solatis> NemesisD: no that's news.ycombinator.com , they fight over haskell versus lisp versus ruby versus node.js all the time over there :)
20:12:56 <trap_exit> NemesisD: so it appears that in this case, isntead of dispatching on tag
20:12:56 <NemesisD> trap_exit: the other part to note is that parsers are instances of alternative so you can <|> between them on failure
20:13:00 <roboguy_> vanila: yeah, but every once in a while I can't resist a good internet argument (even though *nothing* nice ever comes from it haha)
20:13:01 <trap_exit> we try one parser, and if it fials, we try the next parser?
20:13:13 <vanila> haha
20:13:24 <roboguy_> every time I think I'm out, *they pull me back in*
20:13:35 <NemesisD> trap_exit: oh, i somehow missed the tag thing. you could write it differently to use tags, hold on
20:13:58 <NemesisD> solatis: i haven't been able to stomach hacker news for a long time
20:15:03 <roboguy_> the article has a little joke about being constructive and not use "proof by contradiction" (because Haskell types have a close connection to constructive math) and this person on reddit keeps insisting that this is a "useless metaphor" (which is apparently a big problem for the article)
20:15:32 <roboguy_> and I keep telling him that he's reading *way* too much into a simple joke haha
20:15:57 <vanila> i don't get the point of the article
20:16:30 <d_m> vanila: i really like the article. i think it's about being positive/constructive and not confrontational in programming discussions
20:16:36 <NemesisD> trap_exit: maybe something like this https://gist.github.com/MichaelXavier/d331d9817f120daf5a65
20:16:39 <d_m> roboguy_: i agreed with you
20:16:47 <NemesisD> trap_exit: parser is also monad and monadplus so you could guard
20:16:48 <trap_exit> NemesisD: le tme try it out
20:20:30 <trap_exit> NemesisD: any chance we can make https://gist.github.com/anonymous/5e5564a26f71800b6819 compile? I'd really prefer to "dispatch on the tag"
20:20:45 <trap_exit> I currently get error:     Couldn't match type `Value                          -> aeson-0.8.0.0:Data.Aeson.Types.Internal.Parser GuiEvent'                   with `aeson-0.8.0.0:Data.Aeson.Types.Internal.Parser GuiEvent'
20:21:13 <NemesisD> trap_exit: i was avoiding have to setup a whole sandbox with aeson to solve this
20:21:40 <NemesisD> trap_exit: that one doesn't dispatch on the tag. the one i sent you after that one did
20:21:41 <trap_exit> ah, n/m, I'll dig into the docs; thanks for your help :-)
20:22:02 <trap_exit> hmm
20:22:04 <trap_exit> do you dispatch on the tags
20:22:07 <NemesisD> or rather doesn't dispatch on the tag but fails the parser if the tag doesn't match, which is morally equivalent
20:22:09 <trap_exit> or do you try all parsers until one succeeds?
20:22:18 <trap_exit> it seems like if there are n options, this solution would be O(n) time
20:22:23 <trap_exit> since we try them in sequence until one tag matches
20:22:26 <NemesisD> trap_exit: correct
20:22:30 <trap_exit> whereas the 'correct' appraoch should be "read tag; pick function absed on tag"
20:22:43 <trap_exit> this is silly and pre-mature optimizations, but O(n) vs O(1) is sorta non-trivial
20:23:32 <NemesisD> trap_exit: if that factor *really* matters for your program (and I don't think it does), you could put your parse functions into a map based on the tag, pull the value of the tag out as i do in the second linke i gave and do a lookup
20:23:49 <NemesisD> trap_exit: the code will likely be messier
20:24:18 <trap_exit> NemesisD: what you posted is enough to get me started
20:24:21 <trap_exit> I'll finish it, thanks :-)
20:24:46 <NemesisD> trap_exit: you could also use a case statement, but that's still O(n) but when your N is 2 and your constant factor is probably nanoseconds who cares :P
20:24:53 <NemesisD> trap_exit: np. good luck!
20:28:13 <bb010g> Is there a way to implement the standard Data.List tail function in terms of a fold?
20:31:19 <latro`a> you mean tail [] = []; tail (_:xs) = xs?
20:31:42 <latro`a> if so, I think probably not, at least not with foldr
20:31:54 <latro`a> because how would the function be able to tell the difference between the first and other elements?
20:32:03 <vanila> you can do it, but it's very hard
20:32:50 <bb010g> I was thinking it would be possible if you made the end result a function of some sort that could then dispose of the first, but I'm a bit fuzzy on it...
20:32:55 <latro`a> I suppose I could see how it might be done with foldl
20:32:59 <vanila> > foldr (\x (p,q) -> (x:p,p)) ([],[]) "foobar"
20:33:01 <lambdabot>  ("foobar","oobar")
20:33:11 <vanila> xjust to completely ruin the fun for everyone
20:33:16 <bb010g> :)
20:33:29 <latro`a> ah, with two
20:33:32 <bb010g> That's a lot simpler than I was thinking.
20:33:34 <latro`a> then you can distinguish
20:34:15 <bb010g> You can replace q with _
20:50:47 <dibblego> every function that can possibly be written on list can be written using foldr
20:51:20 <vanila> what do you mean exactly?
20:51:56 <dibblego> data List a = List (forall b. (a -> b -> a) -> b -> b) -- this is same structure as []
20:52:52 <vanila> ah i see
20:53:24 <vanila> listToFoldr = \cons nil -> foldr cons nil ; foldrToList l = l (:) nil
20:53:52 <vanila> but what about case expressions? you can't do that on the foldr version
20:53:56 * hackagebot unix-time 0.3.3 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.3.3 (KazuYamamoto)
20:54:14 <dibblego> that type is a bit wrong
20:54:34 <dibblego> data List a = List (forall b. (a -> b -> b) -> b -> b) -- this is same structure as []
20:55:39 <gamegoblin> Hmmm… I find myself defining my own type that’s like TripleEither a b = Left a | Right b | HardRight b, where the monad definition short circuits on both Left and HardRight values. Is this dumb?
20:56:06 <vanila> gamegoblin, it's not dumb but you could just use Either, with the error part being Either a b
20:56:13 <vanila> that saves you reimplementing the monad
20:56:20 <dibblego> Either a (Bool, b)
20:56:24 <gamegoblin> vanila: So Either (Either a b) b ?
20:56:27 <vanila> yes
20:56:31 <gamegoblin> dibblego: that works too, clever
20:56:32 <vanila> oh wait a sec
20:56:47 <dibblego> b+b = 2*b
20:56:48 <vanila> im not sure if that would work, you'd have t try
21:03:12 <benzrf> aaand it dropped the buffer
21:03:14 <benzrf> q.q
21:04:50 <benzrf> oups, wrong channel
21:06:18 <nullbyte> is writing a json parser fairly nontrivial in haskell? in terms of LOC
21:06:40 <vanila> nullbyte, I am confident i could do it better from scratch in haskell than any other language
21:06:47 <vanila> except prolog
21:06:51 <Zekka> nullbyte: It's probably not too hard
21:06:55 <vanila> if you count a parser combinator library, they're equal
21:07:08 <mmaruseacph2> http://hackage.haskell.org/package/aeson says it's pretty easy and fast
21:07:27 <nullbyte> better from scratch, strong claim but definitely believable... could you guesstimate how long it would take you?
21:07:43 <mwhit> parsing is something that always felt very natural in a functional setting from the very start of learning it
21:07:53 <vanila> well that's hard, if I started in the morning it would be done befor the day was over
21:08:19 <dmwit> vanila: For case expressions, case xs of [] -> e1; h:t -> e2 is like \List xs -> f (\h t -> e2) e1
21:08:25 <nullbyte> sweet, i like that
21:08:54 <dmwit> er
21:09:04 <dmwit> \List xs -> xs (\h t -> e2) e1 -- I mean
21:09:06 <dibblego> there is an exercise to write a JSON parser on http://github.com/nicta/course
21:10:41 <nullbyte> i'm pretty new to haskell, so i wouldn't try it right off, but i'd like to get to a level where writing one can be done in a couple sitting by the end of the month or so
21:10:51 <nullbyte> sittings&
21:10:53 <nullbyte> *
21:11:43 <vanila> nullbyte, you could try using parsec or readp or something, to implement this
21:11:50 <Welkin2> is there any way to get a listing of intermediate values during execution?
21:12:01 <dmwit> Welkin2: hat does something like that.
21:12:02 <dibblego> Welkin2: Debug.Trace
21:12:14 <nullbyte> vanila, i'm not interested in libraries right now, but i appreciate the tip
21:12:16 <Welkin2> ah, I forgot about that
21:12:21 <Welkin2> flip . trace
21:12:23 <Welkin2> isi t?
21:13:00 <vanila> nullbyte, oh if you wanted to go from scratch then you could either implement a parser monad or use direct recursive decent (but this code will look horrible: source - I had do this for somethin yesterday)
21:13:23 <vanila> there's a paper explaining in a really simple way how to build a parser monad
21:13:28 <Welkin2> what about for a library function?
21:13:43 <nullbyte> i totally think the monadic route would be the way to go
21:14:00 <Welkin2> I'm trying to understand how sequence works on lists
21:14:06 <nullbyte> i'm considering this an exercise more than the utility, maintainability, etc.
21:14:11 <vanila> nullbyte, well my advice woudl b to follow along with this , programming as you read http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf
21:14:20 <nullbyte> wow cool, thank you vanila
21:14:43 <Welkin2> I tried desugaring the do notation into nested lambdas that wrap foldr, but it seems wrong
21:14:56 <Welkin2> from the source code for `sequence`
21:15:03 <Total_1mmersion> c_wraith, it looks like you're creating a new STRef each time, which would break the data structure if two Plains point to the same one or a cycle occurs.
21:15:48 <c_wraith> Total_1mmersion: I suppose that's a case where you actually *can* preserve sharing without dirty hacks.
21:15:55 <bb010g> Erg. My code compiles fine _without_ explicit type signatures, but when I stick the ones GHCi _gives me_ in there, it fails to compile. ???
21:16:25 <Welkin2> bb010g: read the error messages
21:16:50 <c_wraith> Total_1mmersion: so just throw in a cache.
21:16:52 <Total_1mmersion> c_wraith, what do you mean? I don't think that your implementation would preserve sharing, but I don't know how to preserve sharing.
21:17:30 <bb010g> Welkin2: I have been. They're complaining about not being able to decide on an instance. I don't get why they don't show up without the signature, though.
21:18:05 <Total_1mmersion> Like an association list? And if the current reference is already in the list, use the value associated with it instead of a new one?
21:18:13 <Welkin2> paste your errors and code on lpaste
21:18:15 <Welkin2> @lpaste
21:18:16 <lambdabot> Haskell pastebin: http://lpaste.net/
21:18:29 <trap_exit> https://gist.github.com/anonymous/07158f3354b8aedae7ea <-- how do I make this compile? tags: Aeson
21:18:41 <c_wraith> Total_1mmersion: well, an association list would really slow it down.  Data.Map would slow it down less, but it would still be a slowdown.
21:19:16 <l0cust> trap_exit: well, you'll have to give more information
21:19:26 <l0cust> What does "GUIEvent" look like
21:19:38 <trap_exit> oh, I think that's iirelevant given the "error fialeD"
21:19:42 <trap_exit> so I have a tag in the json
21:19:48 <trap_exit> which either says "KeyDownEvent" or "MouseEvent"
21:19:51 <trap_exit> and I want to retrieve this tag as a string
21:20:01 <l0cust> ah
21:20:05 <trap_exit> see https://gist.github.com/anonymous/25dd96829f15d989225a for the js side
21:20:14 <trap_exit> so right now, I want to just retrieve the tag and dispatch on which consructor
21:20:24 <trap_exit> but I think Aeson is complaining to me saying "dude, I have no idea wtf the tyhpe of tag should be"
21:20:28 <Total_1mmersion> c_wraith, is the only way to avoid a list/map/cache to use only one data type by merging Plain and Numbered? That way you could just use modifySTRef. The inconvenience of that solution is the need for a Maybe Int in there.
21:20:32 <trap_exit> so I'm like "well, good sir, it should be a String"
21:20:43 <trap_exit> the aeson is like "wtf, ....  Core/FFI.hs:95:12:     Couldn't match type `[]'                   with `aeson-0.8.0.0:Data.Aeson.Types.Internal.Parser'     Expected type: aeson-0.8.0.0:Data.Aeson.Types.Internal.Parser Char       Actual type: String     In a stmt of a 'do' block: tag <- (v .: "tag") :: String     In the expression:       do { tag <- (v .: "tag") :: String;            error "failed" }     In an equation for `parseJSON
21:21:09 <pavonia> trap_exit: Are you sure you're in the list monad in that function?
21:21:12 <trap_exit> and I'm like "Aeson, we're not on friendly terms; I'm going to go ask my friend l0cust in #haskell for help"
21:21:20 <nullbyte> this paper is sweet, i'm going to take a stab at it (need refresher on combinators, etc., first)
21:21:31 <Welkin2> nullbyte: which paper?
21:21:36 <trap_exit> pavonia: what? list monad? I just know that I have a "do" at the top
21:21:45 <c_wraith> Total_1mmersion: if you need to do that conversion, yes.
21:22:00 <l0cust> trap_exit: is GUIEvent an instance of Read
21:22:09 <trap_exit> now
21:22:12 <trap_exit> I'no
21:22:13 <trap_exit> it needs not be
21:22:19 <trap_exit> I'm doing json parsing
21:22:21 <trap_exit> not string parsing
21:22:23 <trap_exit> read / show is slow
21:22:26 <trap_exit> aeson is the future
21:22:56 <pavonia> trap_exit: tag <- (v .: "tag") :: String <-- that String applies to the right-hand part, not to tag
21:23:13 <pavonia> (I think)
21:23:22 <Welkin2> therefore you am
21:23:25 <dmwit> trap_exit: I suspect you want ... :: Aeson String or some such thing (don't know what monad Aeson actually uses).
21:24:02 <trap_exit> can I type the "tag" rather than the "(v .: "tag")" ?
21:24:26 <trap_exit> Prelude Data.Aeson> :t parseJSON parseJSON   :: FromJSON a =>      Value -> aeson-0.7.0.6:Data.Aeson.Types.Internal.Parser a Prelude Data.Aeson>
21:24:26 <dmwit> trap_exit: Parser String, it seems, from the type of (.:).
21:24:38 <trap_exit> ah, so the monad is "Data.Aeson.Types.Internal.Parser" ?
21:24:50 <Total_1mmersion> c_wraith, ok, thanks for the help
21:24:53 <dmwit> probably (tm)
21:24:57 <c_wraith> Total_1mmersion: you're welcome
21:26:22 <bb010g> Welkin2: http://lpaste.net/108681
21:26:41 <l0cust> trap_exit: I'm working on it, give me a minute
21:26:46 <bb010g> I thought lpaste notified a channel if you selected it.
21:27:08 <trap_exit> https://gist.github.com/anonymous/d416dfec1153db0591ee <-- this appears to ahve solved my problem
21:27:10 <trap_exit> "solved"
21:27:24 <trap_exit> also, I can't import Data.Aeson.Types.Internal (Parser) <-- hidden package or something
21:27:49 <dmwit> I expect the Parser type is exported elsewhere.
21:28:06 <bb010g> Welkin2: I don't get why it works fine without it, though. Shouldn't it complain there also if it's a problem?
21:28:18 <dmwit> trap_exit: http://www.haskell.org/hoogle/?q=Parser+%2Baeson
21:29:09 <l0cust> trap_exit: I got this to work - http://lpaste.net/108682
21:29:09 <l0cust> trap_exit: or, rather, compile
21:29:09 <l0cust> trap_exit: that works, I like my solution a little better
21:30:11 <trap_exit> l0cust: also appears to compile for me (have some warnings; but unrelated); I also like yours more than mine
21:30:16 <trap_exit> l0cust: thanks!
21:30:34 <trap_exit> in particular, I like the fact it's (tag :: Text) rather than ("KeyDownEvent" :: Text) + ScopedTypeVariables (whatever tha tis)
21:31:07 <l0cust> trap_exit: mine probably isn't what you want, but it's closer than your solution
21:31:07 <l0cust> trap_exit: actually, it's not even close, one second
21:31:16 <bb010g> trap_exit: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
21:31:54 <trap_exit> l0cust: https://gist.github.com/anonymous/6fa2eafe0f46ffabb6b0 now compiles .. .and since the hard part in haskell is getting it to compile; the only things left to do is to setup a minimal test case
21:33:16 <trap_exit> bb010g: why can't it infer that ys is [a] ?
21:33:21 <trap_exit> since the output is [a], and the result is ys ++ ys
21:33:26 <trap_exit> it seems that it must follow that ys is [a]
21:33:59 <l0cust> trap_exit: this is probably closer to what you want - http://lpaste.net/108683
21:36:02 <gamegoblin> is there any function in base that’s like `   (a -> Bool) -> Maybe a -> Bool   ` where Nothing values return False?
21:36:16 <dmwit> trap_exit: In fact it can infer that. The question is: can you write the type signature for that?
21:36:38 <dmwit> trap_exit: Without ScopedTypeVariables, the type signature in the "where" clause says that "ys" can be a list containing *any* type of element.
21:36:43 <bb010g> trap_exit: Here's what happens without ScopedTypeVariables:
21:36:47 <Welkin2> gamegoblin: http://www.haskell.org/hoogle/?hoogle=%28a%20-%3E%20Bool%29-%3E%20Maybe%20a%20-%3E%20Bool
21:36:54 <bb010g> https://www.irccloud.com/pastebin/bJdkDIsQ
21:37:03 <dmwit> trap_exit: But this is not true: we in fact know that ys contains a particular type of element: specifically, they all have the same type as the elements provided to f.
21:37:16 <vanila> gamegoblin, there's maybe, which is close
21:37:16 <gamegoblin> Welkin2: Huh, had no idea there was an `all` and `any` for foldable
21:37:17 <vanila> :t maybe
21:37:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:37:30 <vanila> so maybe False would do it
21:37:31 <Welkin2> bb010g: I don't think I can help with that, sorry
21:37:38 <gamegoblin> using all from Data.Foldable works
21:37:41 <dmwit> trap_exit: ScopedTypeVariables lets you say that the type variable in the "ys" type signature and the type variable in the "f" type signature coincide.
21:37:52 <bb010g> trap_exit: It reads as ys :: forall a. [a] (the forall is implicit), and it's not because it's restricted to the type of xs. ScopedTypeVariables lets that restriction be expressed.
21:37:55 <trap_exit> dmwit : ah, I get it now, it's lexical scoping for type sigantures :-)
21:38:02 <dmwit> trap_exit: exactly =)
21:38:04 <trap_exit> bb010g : understood
21:38:11 <dmwit> trap_exit: Hence "scoped type variables"... ;-)
21:39:45 <trap_exit> it's amazing, it as as if the name explains what it's doing
21:42:20 <l0cust> trap_exit: Your json is structured poorly if that's how you're parsing her
21:42:20 <l0cust> *it
21:42:20 <l0cust> trap_exit: Let me work on it for a second, I'll explain how it should be done
21:43:08 <trap_exit> what is swrong with https://gist.github.com/anonymous/7d665cde21d179fdb144 ?
21:43:27 <trap_exit> we read the tag first; and based on the tag, we dispatch on whether it's a KeyDown or a Mouse event
21:43:41 <trap_exit> are tagged objects bad in Haskell? :-)
21:44:50 <l0cust> trap_exit: it's not that, it's that your code is messy
21:45:06 <trap_exit> l0cust: ah, please correct it
21:45:10 <trap_exit> this is my first time really writing Aeson
21:45:13 <trap_exit> I'd like to develop the "right style"
21:49:12 <l0cust> trap_exit: are you committed to KeyDownEvent and MouseEvent being of the same type?
21:49:12 <l0cust> trap_exit: or can they be separate types?
21:49:12 <l0cust> trap_exit: they really should be separate types
21:49:29 <trap_exit> I'd prefer they be the same type
21:49:36 <trap_exit> since I have thisevent handler queue
21:49:42 <trap_exit> which has a bunch of GUIType
21:49:49 <trap_exit> however
21:49:52 <trap_exit> suppose we lifted this restriction
21:49:56 <trap_exit> how would you make the code more elegant?
21:50:00 <trap_exit> I'm open to learning new ideas
21:50:12 <trap_exit> I want to see what the swarm is capable of
21:54:28 <l0cust> trap_exit: If you insist on having them be the same type, then http://lpaste.net/108684
21:54:28 <l0cust> trap_exit: that's a bit cleaner
21:54:28 <l0cust> trap_exit: oh shit, I forgot to add in error handling, one second
21:55:07 <trap_exit> parseJson _ = mzero
21:55:11 <trap_exit> there we go, error handling :-)
21:55:14 <trap_exit> cool, thanks :-)
21:57:07 <l0cust> trap_exit: it's helpful if you have error messages
21:57:51 <trap_exit> l0cust: I don't like future me very much. I do all the hardwork with learning, he gets all the benefits of knowing. That dude's spoiled.
21:57:55 <l0cust> trap_exit: http://lpaste.net/108685
21:59:16 <l0cust> trap_exit: It would be a lot better, and more json-esque, if you did it by making guievent a typeclass
21:59:16 <l0cust> trap_exit: or an Either Type
22:01:54 <trap_exit> this is ghcjs
22:01:58 <trap_exit> I control the js that genrates the json
22:02:00 <trap_exit> I wnat fast failure
22:02:46 <l0cust> trap_exit: one second
22:06:54 <l0cust> trap_exit: this is a better way to do it
22:06:54 <l0cust> trap_exit: http://lpaste.net/108687
22:07:20 <Lindia22>  Hi! I give you some videos. I hope you like! http://j.mp/1pQkKUG
22:07:28 <l0cust> trap_exit: this way you can send both keydownevents and mouseevents
22:07:36 <bb010g> @mods
22:07:37 <lambdabot> Maybe you meant: todo more docs
22:07:45 <l0cust> @where ops
22:07:45 <l0cust> @where mods
22:07:46 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:07:46 <lambdabot> I know nothing about mods.
22:07:58 <trap_exit> l0cust: I think data GuiEvent = GuiEvent (Maybe KeyDownEvent) (Maybe MouseEvent) is wrong
22:08:04 <l0cust> there we go
22:08:25 <l0cust> trap_exit: I was thinking a newtype wrapper, or an either type
22:08:36 <l0cust> trap_exit: I don't think you're right to group the two, though
22:11:26 <l0cust> oh know hackagebot is down
22:11:37 <l0cust> how are we to know about random packages?
22:12:07 <l0cust> *oh no
22:12:18 * l0cust is getting too tired for this shit
22:12:23 <l0cust> imma go to bed
22:16:38 <gamegoblin> Can one have two files that mutually refer to each others’ types (but not data)?
22:17:06 <gamegoblin> Without doing a lot of ghc nonsense
22:19:32 <dmwit> gamegoblin: Yes, read about .hs-boot files.
22:19:41 <gamegoblin> “without doing a lot of ghc nonsense"
22:19:44 <gamegoblin> it’s fine
22:19:49 <dmwit> It's really not a lot.
22:19:56 <lfairy> just factor it out into another module
22:20:18 <gamegoblin> I’m just gonna refactor
22:21:44 <gamegoblin> I had a single config file which referred to a few other types in some other modules which used various bits of data from the config file
22:21:50 <gamegoblin> just going to make several specific config files, I guess
22:30:06 <augur> what's the canonical reference for haskell, if i need to cite some aspects of the language?
22:30:23 <jle`> augur: the report?
22:31:38 <augur> jle`: ok
22:31:56 <jle`> ghc has some decent documentation on the ghc extensions i think
22:32:01 <jle`> but i'm not sure if that's what you are looking for
22:32:06 <augur> i just need to point to type classes
22:44:53 <stalintrotsky> How do I make cabal copy assets (e.g. default configurations) into the install directory?
22:45:32 <dmwit> stalintrotsky: Look into the documentation. I can't remember exactly what the field is called, but it's something like extra-files, data-files, extra-sources.
22:45:44 <stalintrotsky> ok, thanks
22:45:51 <dmwit> stalintrotsky: Another keyword to read about in the docs is prefix independence.
22:45:56 <augur> stalintrotsky: you crush the working class under the guise of socialism, thats how! >|
22:46:00 <augur> oh sorry, wrong question
22:46:02 <dmwit> (If you want to use those files in your program.)
22:46:17 <stalintrotsky> only half of me
22:46:23 <stalintrotsky> the other half gets killed with an icepick
22:47:31 <augur> can overlapping instances be used collaboratively to resolve to single solutions?
22:47:53 <dmwit> augur: That question is pretty dense. Will you unpack it a bit?
22:48:01 <augur> like, could you have two instances for a constraint which, when combined with other constraints, yield only a single solution?
22:48:23 <augur> suppose that in C a => ..., C a has multiple possible solutions due to overlapping instances
22:48:51 <dmwit> Not in GHC Haskell, I think.
22:48:56 <augur> is it possible to have something like... (C a, C' a) => ... for some clever choice of C' which leads to only one solution for the first constraint?
22:48:57 <dmwit> GHC doesn't do backtracking search ever.
22:48:58 <augur> hmm
22:49:08 <dmwit> Compilers for other languages do; e.g. Prolog. ;-)
22:49:17 <augur> well but in this case its not a matter of backtracking, is it? because there are solutions
22:49:18 <augur> just too many
22:49:36 <augur> or but they get whittled down by the additional constraints
22:49:50 <dmwit> "whittled down" sounds like a synonym for "search" to me
22:50:02 <augur> nah not search!
22:50:08 <augur> just.. constraint!
22:50:10 <augur> :p
22:50:32 <augur> i cant think of an example here, unfortunately
22:50:43 <augur> oh well
22:50:45 <augur> it doesnt matter
22:51:35 <Welkin2> constraint breeds creativity
22:52:15 <dmwit> If you think of a use case, perhaps our discussion can be more productive than "it's backtracking! it's not!". =)
22:52:16 <augur> well, im nearly done with this paper
22:52:27 <augur> dmwit: well, the use case is natural language :)
22:52:50 <dmwit> That's much too broad to be what I would call a use case.
22:53:02 <augur> i just wanted to preface with a warning!
22:53:18 <augur> she :: (x :: Entity, Fem x) => Entity
22:53:22 <augur> she = x
22:53:47 <augur> there might be multiple Entities in scope, but only one with a Fem x proof
22:54:04 <augur> so these should resolve, because there's only one solution for both things simultaneously
22:54:36 <dmwit> Surely only having one Fem x proof in scope is not a good guarantee than there is only one x which satisfies the Fem constraint.
22:54:46 <augur> thats true
22:54:54 <nezt> how do monads isolate side effects (in layman)
22:55:02 <augur> but then, only having one Monoid instance in scope isnt either :)
22:55:21 <dmwit> nezt: Monads are irrelevant for that. The type system tracks effects, and it turns out many effects have monadic structure.
22:56:49 <joelteon> nezt, IO side effects are isolated because you can't get a out of IO a
23:00:14 <tac> Has anyone used HSLogger much?
23:00:26 <tac> I'm having trouble figuring out how to initialize the loggers
23:00:44 <HeladoDeBrownie> nezt, evaluation of expressions alone causes no effects. It's the I/O system, which runs a specific IO action, that executes I/O.
23:00:58 <Welkin2> desugaring, expanding to lambda form, and computing functions on paper sure can be frustrating, but it's rewarding
23:00:59 <pingu> tac: I've used it a bit.
23:01:22 <Welkin2> pingu: the german penguin? or the megaman character?
23:01:34 <pingu> Welkin2: I thought it was a sweedish penguin
23:01:39 <Welkin2> oh, perhaps
23:01:47 <pingu> oh, it's swiss
23:01:50 <tac> pingu: So there's the root logger. How do you append a child logger to the root?
23:01:51 <pingu> and british
23:02:11 <pingu> tac: Ah. I've not done that. I'm not sure what that would even mean
23:02:17 <pingu> child logger?
23:02:38 <tac> so HSLogger apparently uses a tree
23:02:45 <tac> There's a Logger object called the root logger
23:02:50 <tac> and it sits at the top of the tree.
23:03:06 <pingu> this sounds horribly like python's logging system
23:03:13 <tac> I think it's based on Python's
23:03:19 <pingu> :\
23:03:19 <tac> yep
23:03:28 <tac> "This system is patterned after Python's logging module, http://www.python.org/doc/current/lib/module-logging.html and some of the documentation here was based on documentation there."
23:03:53 <tac> I don't mind it as long as I can get it set up at all.
23:03:53 <Welkin2> haha
23:04:01 <tac> I could just log directly to the root logger
23:04:07 <pingu> right, it looks quite... implicit for setting up child loggers
23:04:13 <pingu> I think the naming does it.
23:04:32 <pingu> I.e. you just set things on childlike named things and it "goes".
23:05:02 <pingu> are there any good alternatives out there for hs-logger? I might have to roll my own at some point.
23:05:06 <pingu> that's a little more 'haskelly'
23:05:14 <tac> hmm
23:05:17 <Welkin2> haskelly?
23:05:18 <tac> Yeah. This one is very not haskelly
23:05:27 <tac> I see it unsafePerformingIOing
23:05:28 <Welkin2> I don't think there is a name for idiomatic haskell yet
23:05:38 <tac> haskellesque
23:05:39 <Welkin2> like there is for python (e.g. pythonic)
23:06:25 <tac> I guess the one thing I really need to figure out is how to define my own log handler
23:06:31 <tac> since I want the log piping to IRC as well as a text file
23:06:34 <Welkin2> oh man
23:06:45 <pingu> Welkin2: I think it might just be 'over-engineered' ;)
23:06:47 <Welkin2> that reminded me just now of "googly" and other stupid words that google uses
23:07:06 <pingu> monad-logger looks interesting
23:07:30 <jmcarthur> nezt: the "trick" is just that IO doesn't perform any effects but instead is just a way to construct a value that represents the effects you want. it's kind of like generating a C program using Haskell (as opposed to executing it).
23:08:03 <Welkin2> a monadic computation
23:08:40 <tac> the only thing that gets "executed" in a haskell program is main
23:08:48 <jle`> is it safe to have two projects share the same sandbox
23:09:00 <tac> and if main is defined in terms of other IO a's, then those IO a's get executed in turn, producing whatever side-effects they might
23:09:22 <pingu> jle`: I don't see why not, many projects used to have to share an entire system before sandboxes.
23:09:23 <tac> but it's good to try and keep in mind the distnction between execution (which only happens at runtime) and evaluation
23:09:24 <Welkin2> jle`: I don't see why not, but I havent done it before
23:09:27 <pingu> I'm not sure how you'd set that out, though.
23:10:13 <jle`> thanks all pingu Welkin2
23:10:27 <jle`> i'd just set the sandbox path
23:11:05 <Welkin2> are there any good curl libraries?
23:11:14 <Welkin2> Network.Curl?
23:11:32 <Welkin2> or libcurl
23:11:36 <tac> hmm
23:11:44 <tac> are there any better logging libraries for Haskell?
23:12:18 <Welkin2> tac: https://github.com/kazu-yamamoto/logger
23:12:27 <Welkin2> from a quick search of github
23:12:58 <tac> A quick search on github doesn't give me an immediate sense of confidence
23:13:03 <tac> especially since it's not even on hackage :X
23:13:03 <Welkin2> haha
23:13:27 <tac> but thank you. I have been googling an awful lot today and I don't know if I have it in me to google any more ;P
23:13:55 <tac> If there's no preferred logging solution, I should just stick with the crufty home-grown one I have
23:14:24 <Welkin2> http://hackage.haskell.org/package/monad-logger
23:14:25 <pingu> I'm considering writing a "metrics" system for haskell codebases.
23:14:26 <Welkin2> it is on hackage
23:14:41 <pingu> Has anyone else thought of doing this or seen anything like it?
23:14:43 <Welkin2> part of it, at least
23:14:56 <pingu> for recording things like counters, guages, statuses, etc.
23:15:26 <Welkin2> what do you mean pingu ?
23:15:36 <pingu> you could do things like x <- recordTimeTaken "expensiveOperation" someExpensiveOperation
23:16:00 <pingu> and inc "someCounter"
23:16:17 <pingu> and after sprinkling these through your codebases you get free metrics.
23:16:24 <pingu> on some port
23:16:34 <pingu> it's been done for most languages, not seen it for haskell though
23:16:51 <pingu> (for insight into running daemons)
23:16:53 <Axman6> pingu: I think the EGK package gives you that
23:16:54 <Welkin2> go ahead and do it then
23:16:57 <Axman6> EKG*
23:17:02 <Welkin2> I'm sure if you want it, other people do too
23:17:16 <pingu> Welkin2: well I would so long as nobody else has, but aparrently they have ;)
23:17:20 <pingu> Axman6: thanks, I'll take a look
23:17:22 <Axman6> https://hackage.haskell.org/package/ekg
23:17:53 <Axman6> you can drop it into any haskell app quite easily
23:17:54 <pingu> Axman6: yes this looks like exactly what I want, thanks
23:18:19 <Axman6> no worries. glad I could remember the name of it
23:18:24 <Welkin2> nice name
23:21:42 <ddellacosta_> Is it most common to create a set by creating a list and calling fromList on it?  I didn't see another method indicated in the docs, but I may have missed something.
23:22:09 <augur> ddellacosta: yes, thats pretty much the standard way
23:22:10 <vanila> ddellacosta, you can also just add single elements to the empty set
23:22:47 <HeladoDeBrownie> They amount to the same thing
23:23:33 <jmcarthur> if the list is already sorted then generating the set from it instead of inserting elements one by one can be faster
23:23:57 <ddellacosta> gotcha, thanks all
23:24:20 <ddellacosta> jmcarthur: ah, good tip, thanks
23:25:04 <lfairy> ddellacosta: fromAscList, I think?
23:25:17 <lfairy> you need to be careful that it's actually sorted though
23:25:36 <lfairy> :t Data.Set.fromAscList
23:25:38 <lambdabot> Eq a => [a] -> S.Set a
23:25:47 <pjdelport> There's fromAscList and fromDistinctAscList, depending on what preconditions you have.
23:26:14 <lfairy> cool
23:26:25 <dfeuer_> Well, that's interesting.
23:26:47 <ddellacosta> huh, I always learn tons just by asking basic questions in here
23:27:21 <pjdelport> OTOH, fromList actually has some cleverness in the implementation to check whether the input is ordered and distinct, so it should be equivalent to fromDistinctAscList if your input is distinct and ascending.
23:27:24 <dfeuer_> I was expecting my code to be bigger or to allocate more than the hand-optimized code in GHC-Enum, but in fact it is (very slightly) smaller and allocates a little less.
23:27:34 <pjdelport> So you can probably just use fromList. :)
23:28:36 <deaddork> Hi there. Quick question: why can’t I have a `where` after an if-then-else? E.G. http://lpaste.net/108688
23:29:01 <c_wraith> deaddork: where clauses go on pattern matches
23:29:11 <jle`> deaddork: where is a part of declaration syntax
23:29:23 <jle`> but nothing is being declared/defined there
23:30:16 <goglosh> just starting out.. so... what's the /= operator?
23:30:22 <jle`> goglosh: not equals to
23:30:28 <goglosh> oh thx
23:30:34 <jle`> deaddork: you can actually move your let .. in .. thing into your if branch
23:30:45 <jle`> deaddork: because (let ... in ...) is an expression and can go anywhere an expression goes
23:30:56 <jle`> oh wait nvm, you can't, because you refer to a in the condition
23:31:42 <deaddork> This seems to work, though… http://lpaste.net/108689
23:31:57 <gamegoblin> Just learned the magic of Zippers… those are some clever clever things.
23:32:01 <Axman6> @sec (/=)
23:32:01 <lambdabot> x /= y = not (x == y)
23:32:19 <dfeuer_> @help sec
23:32:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:32:24 <ab9rf> deaddork: the where attaches to the definition of test
23:32:27 <Axman6> typo of src =)
23:32:36 <deaddork> Ah, I see
23:32:49 <deaddork> Thanks ab9rf!
23:32:51 <dfeuer_> Axman6, I had no idea lambdabot accepted misspelled commands.
23:32:52 <ab9rf> deaddork: it doesn't attach to any particular expression
23:33:10 <Axman6> if it's close then it'll accept it
23:33:59 <Welkin2> lambdabot is always watching
23:34:06 <ab9rf> laughing at you
23:34:16 <Welkin2> it's soon take over all the world's infrastructure
23:34:33 <dv-> @botsnack
23:34:34 <lambdabot> :)
23:34:34 <Welkin2> and we will be cowering in the corner scribbling type declarations into the dirt
23:34:39 <Axman6> i'm not sure if @pl is act5ually a command in lambdabot or if it just corrects for @pf
23:34:55 <deaddork> Where can I read more about `where`? I feel like LYAHFGG was a bit light on explanation...
23:35:08 <Welkin2> @hoogle where
23:35:12 <lambdabot> keyword where
23:35:12 <lambdabot> Language.Haskell.TH.Ppr where_clause :: [Dec] -> Doc
23:35:12 <lambdabot> Language.Haskell.Pretty whereIndent :: PPHsMode -> Indent
23:35:28 <Axman6> heh, that was more helpful than I was expecting
23:35:55 <Welkin2> http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
23:37:36 <ab9rf> Axman6: pl being short for "pointless" i think :)
23:37:44 <platz> this is what I imagine lambdabots to look like http://i.imgur.com/UnmbN5U.png
23:37:50 <Axman6> right, a joke on "pointfree"
23:38:06 <ab9rf> Axman6: i actually use @pl instead of @pf
23:38:15 <Welkin2> everyone does
23:38:18 <Axman6> most people do
23:38:35 <ab9rf> i think that says something about us people :)
23:39:26 <HeladoDeBrownie> deaddork, well, this gives you the syntax http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-830004.4.3
23:39:31 <jle`> deaddork: the haskell report is nice
23:39:40 <jle`> oh HeladoDeBrownie posted it
23:39:54 <HeladoDeBrownie> deaddork, basically, "where" is tied to a declaration, not to just any expression.
23:40:05 <jle`> deaddork: basically, where is a part of declaration syntax.  when you declare something, you can add 'where' to define things you use in your declaration
23:40:12 <jle`> (let .. in ..) is literally an expression(TM)
23:40:19 <jle`> it can go where any other expression goes
23:40:23 <tramjoe> Out of curiosity, from someone who has just started learning/evaluating Haskell for real-world usage (not academic), does anyone know if IO and Strings have been improved since 2010? (re. http://jlouisramblings.blogspot.fr/2010/04/haskell-vs-erlang-for-bittorent-clients.html)
23:40:37 <deaddork> So you can’t stick where somewhere in the middle of things like an expression ;)
23:41:07 <Axman6> tramjoe: in the "real world" people use Text or ByteString for text or binary data.
23:41:08 <HeladoDeBrownie> deaddork, right. For that there's let, or you just use where but at the declaration level.
23:41:14 <Axman6>  IO doesn't need improving ;)
23:41:25 <deaddork> Thanks Helado
23:41:26 <HeladoDeBrownie> deaddork, though for things like the middle of do blocks, the latter is often less an option than the former.
23:41:50 <tramjoe> Axman6, thanks, that confirms what jlouis suggested back in 2010. Just wanted to check what is the current status quo.
23:42:25 <jle`> GHC's io manager and runtime system is constantly improving
23:42:36 <jle`> so IO can improve ;)
23:42:44 <HeladoDeBrownie> tramjoe, Strings tend to be used for more things than they should be. They're really just lists of Char, with all that entails.
23:42:56 <platz> and then we'll finally beat the crap out of those techempower benchmarks
23:43:01 <Axman6> a lot has changed though. There's far more libraries for streaming IO actions a la iteratees (see pipes and conduit for the more popular inplementations)
23:43:16 <jle`> they're actually linked lists of unicode code points...so...literally one of the worst possible ways to encode text conceivable
23:43:28 <jle`> they're good for streaming :)
23:43:35 <deaddork> Oh boy, I’m going to have to work through the standard, aren’t I…
23:43:36 <HeladoDeBrownie> tramjoe, lists are not good if you need random access, for example. You tend to want to use them to embody iteration, hitting each element (up to) once.
23:43:36 <Axman6> jle`: I see that distinct from improving "IO" itself in haskell, it's just performance tuning
23:44:04 <tramjoe> HeladoDeBrownie, yes, this is similar to the situation these days in Erlang (which I use. We have "strings" of sorts (lists of ints, not even a char type) but use binaries everywhere some heavy lifting is required.
23:44:16 <Axman6> String is factastic if you don't want to care about encoding for most of your work
23:44:32 <HeladoDeBrownie> tramjoe, it's also not just a matter of "heavy lifting"; Strings are actually incorrect for things like Unicode and byte representation.
23:44:53 <dfeuer_> @src genericLength
23:44:54 <lambdabot> genericLength []    = 0
23:44:54 <lambdabot> genericLength (_:l) = 1 + genericLength l
23:45:10 <jle`> encoding isn't the problem about String
23:45:23 <jle`> String actually handles encoding a lot better than many other language's string implementations
23:45:42 <jle`> you can reverse a Haskell string naively
23:45:46 <tramjoe> HeladoDeBrownie, I don;t get that. I thought that Strings were UTF-8 from the start?
23:45:47 <Welkin2> I like the fact that strings are list of characters
23:45:52 <jle`> and slice arbitrarily
23:45:54 <Welkin2> because, conceptually, that is exactly what they are
23:46:01 <tramjoe> (and that this was the whole point in using them, not having to worry about encoding)
23:46:02 <jle`> without worrying about code points being separated and stuff
23:46:09 <Axman6> utf is an encoding of unicode characters right?
23:46:13 <Axman6> uh, UTF-8
23:46:16 <glguy> You can't with combining characters
23:46:20 <HeladoDeBrownie> tramjoe, they're lists of Chars, which are in fact code points.
23:46:24 <tramjoe> ok
23:46:29 <trap_exit> hmm, in haskell, is it imp[ossible to declare: (1) global IORef or (2) global MVar ? since all constructors are stuck in IO ( ... ) ?
23:46:51 <Axman6> > (minBound, maxBound) :: (Char, Char)
23:46:52 <HeladoDeBrownie> tramjoe, as was just implied, there are cases where naively manipulating a list of codepoints breaks encoding.
23:46:53 <lambdabot>  ('\NUL','\1114111')
23:47:14 <Axman6> tramjoe: not impossible, but also not a good idea
23:47:18 <Axman6> uh, trap_exit
23:47:31 <jle`> trap_exit: there's a haskellwiki article on that exact thing, but...yeah, you usually want to rephrase your problem if you think that's what you want
23:47:34 <tramjoe> I'll be back to the list at a later point to harass you guys with more questions, but now my daughter require me to get my ass up and move to the park! Thanks for the fast replies though (I'll read the remainder of the comments on this when I get back, keep chatting! :-) ):-)
23:47:43 <trap_exit> I want to create this global list of TBQueues
23:47:47 <HeladoDeBrownie> tramjoe, have fun
23:48:08 <Axman6> tramjoe: you probably don't, you just haven't realised yet ;)
23:48:16 <HeladoDeBrownie> Axman6, mishighlight?
23:48:28 <Axman6> uh, yes
23:48:49 <jle`> tra<tab> is like a russian roulette
23:49:04 <Axman6> t<tab> >_>
23:49:07 * Axman6 is a monster
23:49:26 <Axman6> trap_exit: why do you want to do that?
23:50:11 <trap_exit> I have a bunch of forkIO threads
23:50:13 <trap_exit> that have input mailboxes
23:50:20 <trap_exit> I want each of these thread to have global names
23:50:22 <trap_exit> so I can refernce them
23:50:26 <augur> i think it takes like
23:50:28 <augur> 2 seconds
23:50:28 <trap_exit> be like "send this message to thread gui_event_handler"
23:50:34 <trap_exit> and "send this msg to thread render_handler"
23:50:34 <augur> for my client to go through all of the t names
23:51:02 <HeladoDeBrownie> trap_exit, why not pass the containers as arguments?
23:51:10 <Axman6> trap_exit: why not create the ref in main and pass it to each thread at forkIO?
23:51:15 <trap_exit> seems repetitive
23:51:16 <trap_exit> hmm
23:51:22 <trap_exit> Axman6: taht soudns reasonable
23:51:31 <l0cust> Trying to think of a name for a content management system
23:51:52 <Welkin2> l0cust: who is it for?
23:51:52 <HeladoDeBrownie> trap_exit, you could potentially use StateT to reduce repetition
23:51:57 <l0cust> The best thing I've come up with is "mstrkh", which means "restful" in Arabic (I speak a small quantity of arabic)
23:52:03 <l0cust> Welkin2: It's for my own personal use
23:52:13 <HeladoDeBrownie> trap_exit, sorry, ReaderT
23:52:21 <Welkin2> l0cust: okay, otherwise I would say choose something easy to spell/pronounce
23:52:31 <Axman6> you could automate it somewhat: main = do ref <- newIORef M.empty; let forkIO' :: (IORef (Map k v) -> IO ()) -> IO ThreadId; forkIO' f = f ref; forkIO' t1; forkIO' t2
23:52:48 <l0cust> Welkin2: How is "mstrkh" hard to pronounce? Jeez, you people
23:53:04 <HeladoDeBrownie> trap_exit, alternatively, declare the functions needing it where the container is in scope
23:53:45 <ddellacosta> is there a decent tutorial for dealing with numeric types in Haskell?  I am always stumbling over Integral, Num, Integer, Int, etc.
23:54:04 <HeladoDeBrownie> ddellacosta, well those first two are typeclasses, not types
23:54:20 <ddellacosta> HeladoDeBrownie: thereby illustrating why I need a tutorial. :-)
23:54:22 <Axman6> ddellacosta: how so? there's lots of things you could be having problems with
23:54:22 <HeladoDeBrownie> I don't specifically know of such a tutorial but the typeclassopedia might contain something on those
23:54:32 <ddellacosta> HeladoDeBrownie: okay, I'll check it out, thanks
23:54:36 <Axman6> ddellacosta: sounds like you need a haskell tutorial ;)
23:54:45 <HeladoDeBrownie> Never mind, I don't think it does?
23:54:54 <Axman6> ddellacosta: http://www.cse.chalmers.se/edu/year/2013/course/TDA452/Haskell-Prelude-Tour-A4.pdf has some explanation of the types and classes IIRC
23:55:40 <ddellacosta> Axman6: I don't deny I'm still learning, but I'm specifically interested in numeric typeclasses and types now, not a general guide to Prelude
23:55:47 <l0cust> Welkin2: how about "repozisto"? In Esperanto, it means "one who rests"
23:56:06 <Axman6> ddellacosta: it has a guide to the prelude typeclasses at the end, as well as their heirarchy
23:56:34 <Welkin2> l0cust: like a rest api? or resting your body?
23:56:40 <HeladoDeBrownie> l0cust, would an English speaker seeing that pronounce it correctly? :P
23:56:46 <ddellacosta> Axman6: ah okay, I see--thanks, that is indeed helpful!
23:57:06 <l0cust> Welkin2: ack, I meant "ripozisto"
23:57:17 <l0cust> HeladoDeBrownie: Probably, it's phonetic.
23:57:34 <HeladoDeBrownie> l0cust, "it's phonetic" doesn't really imply that, because "phonetic" is relative
23:57:42 <l0cust> HeladoDeBrownie: "ree poh zeest oh"
23:58:08 <HeladoDeBrownie> Well no, maybe not relative so much as it doesn't say *what* the sounds are
23:58:12 <Welkin2> l0cust: how about "isto"?
23:59:38 <l0cust> Welkin2: eh. I like the full word better
23:59:48 <l0cust> Welkin2: "zisto" might not be bad
