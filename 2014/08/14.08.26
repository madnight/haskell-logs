00:00:08 <dfeuer_> marchelzo_, you use isEOF.
00:01:29 <marchelzo_> dfeuer_: perfect. thanks
00:01:32 <dfeuer_> marchelzo_, you could also use some stuff from pipes or conduit, but I don't know how. There are a lot of ways to read/process files/input. Much depends on what you want to do with it.
00:01:45 * dfeuer_ needs to go sleep now.
00:01:48 <marchelzo_> this will work fine for me
00:01:48 <dfeuer_> Good night.
00:01:50 <marchelzo_> night
00:02:14 <dolio> If you just want to read all of stdin until the EOF, you can use getContents.
00:03:02 <marchelzo_> dolio: oh. even simpler. thanks
00:11:22 <trap_Exit> you know what's fucking crazy about haskell? this piece of code -- took me a week to get ghcjs to stop complainig about compile errors / warnings .... and it worked the first time
00:11:37 <trap_exit> this isn't even using quickcheck yet either
00:14:46 <pjdelport> trap_exit: The type system makes you do your debugging up front. :)
00:14:58 <pjdelport> Haskell: Lazy evaluation, eager debugging.
00:17:19 <t4nk749> hi
00:17:19 <t4nk749> i have this function that parses data in int and float
00:17:19 <t4nk749> parseline :: String -> (String, String) parseline input =     let fields = splitOn "|" input         in (fields !! 1, fields !! 3)
00:17:19 <trap_exit> @quote pjdelport: Haskell: Lazy evaluation, eager debugging.
00:17:19 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
00:17:19 <t4nk749> i am getting error when the data has blank values
00:17:19 <trap_exit> @quote pjdelport Haskell: Lazy evaluation, eager debugging. pjdelport
00:17:19 <lambdabot> No quotes match. It can only be attributed to human error.
00:17:19 <pjdelport> @help remember
00:17:19 <lambdabot> remember <nick> <quote>: Remember that <nick> said <quote>.
00:17:33 <trap_exit> remember pjdelport trap_exit can't read docs
00:17:34 <trap_exit> remember pjdelport Haskell: Lazy evaluation, eager debugging.
00:17:51 <trap_exit> @remember pjdelport Haskell: Lazy evaluation, eager debugging.
00:17:52 <lambdabot> Nice!
00:18:00 <trap_exit> well, taht was embrassing
00:18:00 <trap_exit> back to coding :-)
00:18:09 <marchelzo_> t4nk749: what do you expect to get? You are trying to access the 3rd element of a list with 0 elements
00:18:17 <t4nk749> sorry the function is parseline :: String -> (Integer, Float) parseline input =     let fields = splitOn "|" input         in (read (fields !! 1), read(fields !! 3))
00:18:35 <t4nk749> how do i handle blank spaces while parsing
00:19:04 <marchelzo_> what do you want to do the its blank
00:19:11 <marchelzo_> s/the/if
00:19:16 <t4nk749> i just want 0 value for that
00:20:23 <t4nk749> for input like12|45 it works but fails in case of |12 or12|
00:20:57 <marchelzo_> in if length fields > 3 then (read (fields !! 1), read (fields !! 3)) else (0, 0)
00:21:55 <marchelzo_> splitOn "|" "12|45" only has two elements, though
00:22:01 <t4nk749> ya
00:22:18 <t4nk749> it has four fields but upto 3 can be blank
00:22:31 <marchelzo_> ok
00:23:21 <marchelzo_> what does it look like when they are blank? 1 | | | ?
00:24:00 <t4nk749> yup
00:24:24 <marchelzo_> why does it only return 2 values if they can pass 4?
00:25:12 <t4nk749> i want to extract only 2 values
00:25:17 <t4nk749> 2nd and 4th
00:25:35 <t4nk749> and i want the value to be zero if it is lank
00:25:41 <t4nk749> blank
00:26:11 <marchelzo_> ok. so is this how it looks when the first and third are blank? "|2||2"
00:26:42 <t4nk749> ya
00:26:57 <t4nk749> but I am only worried about 2 nd and 4th
00:31:01 <Typheus> Wow, Haskell's more popular than I thought it'd be
00:31:49 <dmj`> Typheus: how so?
00:32:10 <marchelzo_> t4nk749: ok then after your let: in (f 1, f 3) where f x = case (readMaybe (fields !! x)) of Just num -> num; _ -> 0
00:32:11 <Typheus> Well I never even heard of it before recently xD
00:32:29 <sivteck> we need tv commercials!
00:32:30 <merijn> Typheus: First time for everything ;)
00:32:45 <joelteon> what would our target audience be?
00:32:49 <marchelzo_> readMaybe is from Text.Read
00:32:58 <Typheus> People going into creating AI?
00:33:03 <Typheus> That's what got me interested :P
00:33:29 <forgottenone> hi in python you can get help about function by writing help(function_name) is there anything similar in ghci
00:33:50 <joelteon> hoogle
00:33:54 <shachaf> No.
00:34:12 <Typheus> One of the things MIRI suggested learning was Haskell, and since I was in my final semester of Computer Science, I figured it wouldn't hurt to learn.
00:35:23 <forgottenone> joelteon,shachaf; thanks both of you i guess will use vim-hoogle for that
00:36:15 <t4nk749> it says fields not in scope
00:40:03 <t4nk749> function is parseline :: String -> (Integer, Float) parseline input =     let fields = splitOn "|" input         in (read (fields !! 1), read(fields !! 3))
00:40:13 <t4nk749> how do i handle blank spaces while parsing
00:40:57 <merijn> uhoh, move some files around, 1300 linker errors >.>
00:42:37 <joelteon> once you've seen one linker error you've seen them all
00:43:59 <merijn> uh, ok, so how do I trace down what causes a bunch of missing symbol errors during linking?
00:45:06 <merijn> oh, nvm, I think I have the culprit
00:45:49 <merijn> Accidentally deleted an exposed module field >.>
00:46:21 <jkarni> t4nk749: you might want to take a look at parsec/attoparsec
00:46:24 * hackagebot simple-pipe 0.0.0.24 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.24 (YoshikuniJujo)
00:47:50 <jkarni> t4nk749: but if not, dropWhile ((==) ' ')?
00:48:17 <jkarni> t4nk749: or use elem if you also want to drop tabs/newlines
00:48:18 <makalu> why can Control.Exception.throw throw an exception from pure code? Is a function pure if it throws? I always liked knowing that pure code can't throw exceptions (except 'error' of course) but know I can't.
00:49:57 <chrisdotcode> is there a list of lambdabot commands anywhere?
00:50:05 <chrisdotcode> (or a !help, I could ask her in private?)
00:50:09 <merijn> makalu: throw is *really* unreliable
00:50:32 <merijn> makalu: It only throws if the pure code is evaluated, which may be 1) never or 2) later after it escaped outside of your bracket/catch
00:50:48 <merijn> makalu: So, like error, you really shouldn't use it
00:51:11 <merijn> makalu: For reliable exception throwing, use throwIO (or the throwM from edwardk's exceptions package)
00:51:32 <glguy> The important bit is that you can't catch exceptions in pure code
00:51:45 <makalu> and I thought Control.Exception was the solution to the mess of multiple ways of handling errors :(
00:52:12 <merijn> makalu: Which mess? Different kinds of errors, different kinds of solutions
00:53:00 <Typheus> See you all later
00:53:06 <glguy> Allowing more structured failure than calling error on a string in truly exceptional cases is a good thing
00:53:26 <glguy> And you can't eliminate bottom altogether
00:54:18 <chrisdotcode> @pointfree f x y = x + y
00:54:18 <lambdabot> Unknown command, try @list
00:54:38 <Haskellfant> @pl (\x y -> x + y)
00:54:38 <lambdabot> (+)
00:54:42 <Haskellfant> ^ chrisdotcode
00:54:55 <chrisdotcode> Haskellfant: *that's* what it's called
00:54:56 <chrisdotcode> thanks
00:55:05 <chrisdotcode> what does pl stand for though?
00:55:08 <chrisdotcode> 'pointless'?
00:55:34 <lpvb> polish
00:55:51 <Haskellfant> chrisdotcode: I would think it's pointless but I'm not sure
00:56:25 * hackagebot vty 5.2.1 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.1 (CoreyOConnor)
00:57:41 <Haskellfant> What's the reason that there is no filterA (at least I couldn't find it) in the standard library?
00:57:58 <merijn> Haskellfant: Which type would that have?
00:58:37 <nilg> it's strange multimat-1.2.1 doesn't seem to have a show function, any way to display it?
00:59:02 <nilg> well I guess I'll convert it to a list...
00:59:23 <merijn> nilg: You could try StandaloneDeriving the show instance (it may not be very useful)
00:59:46 <makalu> I'll use Edward's exceptions. I've had good experiences with it in the past. Thanks merijn.
01:00:06 <Haskellfant> merijn: filterA :: Applicative f => (a -> f Bool) -> [a] -> f [a]
01:00:17 <Haskellfant> just like filterM but with applicative instead of monads
01:00:30 <merijn> Haskellfant: Mostly historical reasons, I guess?
01:00:36 <Haskellfant> it is possible to implement this:
01:00:38 <Haskellfant> filterA pred = foldr (\x -> liftA2 (\p -> if p then (x:) else id) (pred x)) (pure [])
01:00:49 <Haskellfant> merijn: hm k
01:00:56 <merijn> Haskellfant: Applicative didn't exist until after Monad and by then I guess people were just using filterM
01:01:18 <Haskellfant> are there any applicatives that are not monads?
01:02:12 <merijn> Yes
01:02:43 <Haskellfant> well then you can't always use filterM
01:03:23 <merijn> Haskellfant: Sure, but if no one ever needed to filter an Applicative that is not a Monad, then no one would have motivation to write it
01:03:39 <Haskellfant> fair enough :)
01:03:41 <Haskellfant> thx
01:03:51 <merijn> I'm not saying filterA shouldn't exist, just that no one needed it enough to write it
01:16:29 * hackagebot spoty 0.1.0.2 - Spotify web API wrapper  http://hackage.haskell.org/package/spoty-0.1.0.2 (DavidNilsson)
01:20:04 <funfunctor> hi
01:20:56 <johnw> merijn: filtering a ZipList...?
01:21:30 <funfunctor> good monad for writing out C headers generated from some haskell functions?
01:22:07 <johnw> funfunctor: you could use Writer to build strings, or just IO to write directly to a file
01:22:33 <johnw> but really I wouldn't use a monad at all
01:22:48 <johnw> just a non-monadic function from HaskellFunction -> Text
01:22:49 <funfunctor> johnw: yea but that would suck.. I want to give it some AST and it to pretty print
01:48:51 <Arunabha> Hi, I have a question on the definition of the [] type in GHC.Types. :show [] gives data [] a = [] | a : [a]. In this case why isn't [a] written as ([] a) ?
01:49:37 <Maxdamantus> It could be.
01:49:53 <Maxdamantus> > [1, 2, 3] :: ([] Float)
01:49:55 <lambdabot>  [1.0,2.0,3.0]
01:50:05 <aidid> Am I missing any abstraction here? http://lpaste.net/110037 I am new to hakell, somehow not getting feel of good code
01:52:48 <Fuuzetsu> is there a good way to see what TH expands to?
01:52:58 <Fuuzetsu> preferably inside GHCi
01:54:03 <Arunabha> Maxdamantus: Thanks, so [] is actually special in Haskell ?
01:54:30 <johnw> aidid: that all looks pretty clear to me
01:54:36 <Maxdamantus> Arunabha: yes.
01:54:50 <Maxdamantus> aidid: line 34 looks wrong btw
01:55:30 <Fuuzetsu> oh actually my Q was fine, just forgot to call it in the right place ;P
01:56:12 <aidid> Maxdamantus: yeah, I have missed W :)
01:56:38 <aidid> thanks guys Maxdamantus and johnw
01:56:54 <bennofs> Fuuzetsu: you can use -ddump-splices to show TH output
01:57:28 <Fuuzetsu> where would I add that for least hassle?
01:57:33 <Fuuzetsu> cabal file? Can I just :set it in GHCi?
01:58:04 <Fuuzetsu> TH is kind of nice, now I can read in Haskell datatypes from files at compile time
01:58:32 <NeverW8> Dear lord
01:58:56 <bennofs> Fuuzetsu: I'd :set it in GHCi and then :load a file testing the Q
01:59:09 <Fuuzetsu> ok, so you can just :set it, good to know
01:59:15 <johnw> Fuuzetsu: yeah, it can really be good for things like that
01:59:46 <Fuuzetsu> johnw: now I want to pile up more TH on top to figure out the filenames ;P
01:59:52 <dpwright> I have a type synonym: "type TypeTransverser m s e t t' = forall a. (t -> m t') -> s e t a -> m (s e t' a)"
01:59:58 <zwer> aidid you could derive from Read and either read from string or use read to implement toDirection
02:00:07 <Fuuzetsu> in the end I could sit on my ivory tower of TH, compile and have all the tests appear
02:00:15 <Arunabha> Maxdamantus: is : special too then, given that its written as infix ? Or is it possible do have user defined infix data constructors ?
02:00:33 <dpwright> looks a bit complicated, but ignoring that for a moment, I know that my "e" type parameter will always be of kind * -> * -> *, and thus my "s" parameter will always be (* -> * -> *) -> * -> * -> *
02:00:44 <johnw> Arunabha: in modern GHC you can do that
02:00:45 <zwer> aidid also try using -fwarn-incomplete-patterns flag, you have quite a few non-exhaustive pattern matches
02:00:52 <johnw> data Foo a b = a :>>: b
02:01:08 <bennofs> :t (<:)
02:01:09 <lambdabot>     Not in scope: ‘<:’
02:01:09 <lambdabot>     Perhaps you meant one of these:
02:01:09 <lambdabot>       ‘<’ (imported from Data.Ord), ‘<=’ (imported from Data.Ord),
02:01:18 <dpwright> is there any way I can encode this in the type synonym?  Right now I get an error saying it's expecting s to be of kind "* -> * -> * -> *" but I'm passing in "(* -> * -> *) -> * -> * -> *"
02:01:19 <Maxdamantus> Arunabha: [] is special for additional reasons.
02:01:26 <Fuuzetsu> are there any good TH guides? Anything I've seen is fairly out of date
02:01:46 <aidid> zwer: cool, Read make sense to me, will use -fwarn-incomplete-patterns flag and check
02:01:49 <johnw> dpwright: you could try adding kind annotations on the parameters
02:01:56 <aidid> zwer: thanks
02:02:05 <dpwright> johnw: Ah, I was hoping there would be a way to do that
02:02:06 <Maxdamantus> Arunabha: [a] means the same thing as ([] a), which can't really be explained by other syntax.
02:02:20 <bennofs> Fuuzetsu: I think the best guide is to just look at the haddocks for template-haskell. There is not so much special about TH (other than that you can splice it)
02:02:25 <dpwright> is it literally just "(s : (* -> * -> *) -> * -> * -> *)", like a type annotation?
02:02:34 <dpwright> ::, rather
02:02:43 <Fuuzetsu> ok thought so
02:02:51 <Fuuzetsu> it's still nice to have examples and all that
02:02:53 <johnw> type TypeTransverser (m :: * -> *) (s : * -> * -> *-> *) e t t', etc.
02:02:54 <Maxdamantus> Arunabha: you can always use even non-symbolic constructors as infix: data Foo = String `Bar` String
02:03:00 <adas> is there a way to export everything from a module?
02:03:11 <Fuuzetsu> yes, put ‘module Foo’ in the export list
02:03:49 <Fuuzetsu> module Bar (module Foo, somethingFromBar) where import Foo; somethingFromBar = ()
02:03:49 <adas> you mean "module Foo where" without the "()"
02:03:55 <Fuuzetsu> no
02:04:19 <Fuuzetsu> oh, unless you actuall do mean just export everything from current module then yeah, skip parens
02:04:28 <Fuuzetsu> that doesn't re-export other modules you imported though
02:04:30 <dpwright> johnw: Excellent, thanks!  Just adding a kind signature for e was enough for it to figure out the rest
02:05:18 <adas> Fuuzetsu: thanks..
02:06:23 <bennofs> adas: http://www.vex.net/~trebla/haskell/module.xhtml explains the syntax more in-depth (and also pitfalls)
02:07:46 <adas> bennofs: im using a sandbox and want to do "cabal repl" on a module to test some functions. But this module in question does not have "main :: IO ()"
02:08:29 <adas> so when i do cabal repl.. i only get the main function
02:08:32 <bennofs> adas: oh, thought you were looking for module re-exports. Sorry. But it's still an interesting read :)
02:09:04 <bennofs> adas: do :m +*<module you want to test>
02:09:09 <Arunabha> Maxdamantus , johnw, Thanks folks
02:09:30 <adas> bennofs: ah yes : ). thanks muhc
02:16:24 <Fuuzetsu> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html is there no UnicodeSyntax for -<< and ->> or do I just not have the font?
02:16:38 * hackagebot cabal-rpm 0.9.1 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.1 (JensPetersen)
02:17:10 <bennofs> Fuuzetsu: hmm, I also don't see it
02:17:30 <Fuuzetsu> guess I'll have to peak into the GHC lexer
02:17:50 <Fuuzetsu>        ,("⤛",   ITLarrowtail, \i -> unicodeSyntaxEnabled i && arrowsEnabled i)
02:17:50 <Fuuzetsu>        ,("⤜",   ITRarrowtail, \i -> unicodeSyntaxEnabled i && arrowsEnabled i)
02:17:54 <Fuuzetsu> I can see that one
02:17:56 <johnw> I only have 4 fonts on my system with those characters
02:18:06 <bennofs> Fuuzetsu: here is how it should look: http://unicode-table.com/de/291B/
02:18:13 <johnw> btw, STIXGeneral is freely downloadable and has nearly every mathematical or technical character in it
02:18:39 <bennofs> johnw: nice, I was looking for a font to use as fallback for these symbols
02:19:02 <Fuuzetsu> interesting, my browser must do some nasty swapping, the arrow that shows in the lexer and the arrow I copied from the page are not the same…
02:19:13 <Fuuzetsu> johnw: is it in nixpkgs
02:19:29 <johnw> i don't think so
02:19:38 <johnw> http://www.stixfonts.org/
02:31:08 <Fuuzetsu> even haskell-mode implements it wrong…
02:31:21 <Fuuzetsu> GHC should expose its Lexer
02:31:40 * hackagebot postgresql-simple 0.4.4.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.4.0 (LeonSmith)
02:37:39 <Guest72778> (map read (map toString (concat $ lines contents)) :: [Direction])
02:38:07 <cow_2001> sometimes haskell looks like lisp :|
02:39:05 <Guest72778> :) I will simplify this, but question is is there any way to get rid of type annotation here
02:39:40 <tero-> is FRP.Sodium.snapshot the only way to change the type of the Event?
02:39:45 <kruchy> @pl scale sx sy = | sx > 0 && sy > 0 = if sx > sy then sx else (-sy)| sx > 0 && sy < 0 = max sx (-sy) | sx < 0 && sy > 0 = min sx (-sy)  | otherwise = if sx > sy then (-sy) else sx
02:39:45 <lambdabot> (line 1, column 14):
02:39:45 <lambdabot> unexpected " "
02:39:46 <lambdabot> expecting operator
02:40:40 <cow_2001> Guest72778: i hear that if you type anotate all of your top level definitions, you can get the compiler's type inference to work better
02:40:57 <Haskellfant> Guest72778: it's not really possible to tell with only this code. if you have more code that expects [Direction] it should be possible to infere the type
02:41:06 <kruchy> @pl scale sx sy  | sx > 0 && sy > 0 = if sx > sy then sx else (-sy)| sx > 0 && sy < 0 = max sx (-sy) | sx < 0 && sy > 0 = min sx (-sy)  | otherwise = if sx > sy then (-sy)
02:41:07 <lambdabot> (line 1, column 34):
02:41:07 <lambdabot> unexpected " "
02:41:07 <lambdabot> expecting operator
02:42:42 <Haskellfant> Guest72778: you can also simplify this code a bit to "map (read . toString) (concat $ lines contents)"
02:43:46 <Guest72778> cow_2001: Haskellfant; thanks
02:45:48 <cow_2001> Guest72778: did type anotating the top-level work? my code editor always complains when i don't do that
02:46:23 <cow_2001> guis, what's a really friendly FOSS project a newbie might be able to contribute to?
02:46:26 <cow_2001> guise
02:46:34 <doismellburning> "guise"?
02:46:37 <Guest72778> cow_2001: I am doing that, but might have missed something somewhere ;) emac?
02:46:44 * hackagebot genifunctors 0.2.0.0 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.2.0.0 (DanRosen)
02:47:33 <cow_2001> doismellburning: it's colloquial in some other channel... i guess it's their personal joke and doesn't translate here very well...
02:48:35 <cow_2001> Guest72778: I love both emacs and vim, but I have more experience using vim
02:48:48 <cow_2001> Guest72778: got a good guide for emacs?
02:50:20 <Haskellfant> type annotating the top level instructions is good practise but it doesn't necessarily remove the need for additional type annotations
02:50:56 <cow_2001> Haskellfant: could you expand on that? where are the cases in which that won't work?
02:51:08 <Guest72778> cow_2001: not really, just started with haskell-mode, customising as per my need, working good till now :)
02:52:29 <Haskellfant> cow_2001: well it's up to you what you write at top level instructions, so if you choose to write something in a where and don't type annotate it because it's not top level it might not be possible for the compiler to infere it
02:52:44 <dramforever> Hi, I'm having problems with bytestrings efficiency
02:52:58 <cow_2001> ah, where clauses
02:53:51 <Haskellfant> type annotating top level annotations is important for not breaking apis
02:53:56 <alpounet> dramforever: paste the code on http://lpaste.net/
02:53:57 <dramforever> I want to make a funcion that takes a int-ish i and a bytestring b, and returns b' which has all i-byte chunks reversed
02:54:13 <kruchy> @pl scale sx sy = if (sx > 0 && sy > 0) then (if sx > sy then sx else (-sy)) else if (sx > 0 && sy < 0) then (max sx (-sy)) else if (sx < 0 && sy > 0) then (min sx (-sy)) else if (sx > sy) then (-sy) else 0
02:54:17 <lambdabot> scale = ap (ap . ap (ap . (if' .) . (. (> 0)) . (&&) . (> 0)) ((`ap` negate) . (flip =<< (if' .) . (>)))) (ap (ap . ap (ap . (if' .) . (. (< 0)) . (&&) . (> 0)) ((. negate) . max)) (ap (ap . ap (ap . (if' .) . (. (> 0)) . (&&) . (< 0)) ((. negate) . min)) (flip flip 0 . (`ap` negate) . (if' .) . (>))))
02:54:17 <lambdabot> optimization suspended, use @pl-resume to continue.
02:54:32 <cow_2001> Haskellfant: ooh, that's interesting. how can that break APIs?
02:54:44 <kruchy> @pl-resume scale sx sy = if (sx > 0 && sy > 0) then (if sx > sy then sx else (-sy)) else if (sx > 0 && sy < 0) then (max sx (-sy)) else if (sx < 0 && sy > 0) then (min sx (-sy)) else if (sx > sy) then (-sy) else 0
02:54:46 <lambdabot> scale = ap (ap . ap (ap . (if' .) . (. (> 0)) . (&&) . (> 0)) ((`ap` negate) . (flip =<< (if' .) . (>)))) (ap (ap . ap (ap . (if' .) . (. (< 0)) . (&&) . (> 0)) ((. negate) . max)) (ap (ap . ap (ap . (if' .) . (. (> 0)) . (&&) . (< 0)) ((. negate) . min)) (flip flip 0 . (`ap` negate) . (if' .) . (>))))
02:55:01 <bernalex> kruchy: no. ;-)
02:55:07 <Haskellfant> cow_2001: well if you change the type of a function you most likely break the code that is using this function
02:55:12 <Guest72778> Haskellfant: cow_2001: got rid of annotation :) thanks for ur inputs
02:55:13 <dramforever> for example i = 2, b = "abababab", then it should return "babababa"
02:55:54 <dramforever> I found that (list) map + index + pack is *really* slow
02:56:22 <dramforever> I think if I can get a way to interleave the bytestrings then I would not have a problem
02:56:45 <dramforever> like "abacad" -> ["aaa", "bcd"]
02:56:53 <cow_2001> Guest72778: I'm happy to have been of service :D
02:57:19 <dramforever> In my program i is usually small (< 10), but b is like 20MB
02:57:47 <dramforever> alpounet, wait for a while..
02:59:20 <dramforever> ... cannot find old code ... hid very well in ghci history...
03:00:30 <alpounet> dramforever: oh you were running this in ghci? if you want to measure performance, you should not run things in ghci, it's not designed to run haskell code efficiently
03:00:36 <gregnwosu> hi when trying to run cabal install im getting /usr/bin/ld: cannot find -lHScpphs-1.18.5-ghc
03:00:44 <alpounet> build with ghc, preferably with -O2
03:00:59 <dramforever> Yes, I built it
03:01:04 <dramforever> but removed it...
03:01:15 <alpounet> ah.
03:01:24 <gregnwosu> however when i look inside my .cabal/lib folder I can see the cpphs library
03:01:29 <dramforever> I first made it in ghci, so I thought I could find it here
03:01:59 <dramforever> (ouch, my right hand keeps trying to reach shift to type in camel case)
03:02:56 <alpounet> dramforever: anyway, I suggest looking at Data.ByteString's haddocks. you may want to use 'splitAt' and 'reverse' from this module, for instance
03:03:15 <hexagoxel> gregnwosu: did you recently upgrade ghc?
03:03:21 <dramforever> `i` is very small, but `b` is very big
03:03:22 <alpounet> (or Data.ByteString.Lazy if you work on a lazy bytestring)
03:03:33 <alpounet> dramforever: splitAt is O(1) on bytestrings
03:04:30 <dramforever> but are you sure we should concat like 10M of small bytestrings?
03:05:07 <alpounet> dramforever: if that proves to be slow, you can use the Builder module from bytestring
03:05:35 <alpounet> which prepares a plan for concatenating a bunch of bytestrings together, and will then concatente them all at once when you're done "preparing your plan", so to speak
03:05:48 <dramforever> Lazy Bytestrings?
03:06:04 <dramforever> are they for lazy bytestrings?
03:06:15 <alpounet> for both
03:06:20 <alpounet> strict and lazy
03:06:45 <alpounet> dramforever: http://hackage.haskell.org/package/bytestring -> there's Data.ByteString.Builder and Data.ByteString.Lazy.Builder
03:07:00 <dramforever> alpounet, can you suggest a name for my "reverser"? :)
03:07:22 <alpounet> dramforever: i think you just suggested one ;)
03:07:28 <BoR0> dramforever, resrever
03:07:45 <alpounet> hah
03:07:47 <dramforever> Maybe flipper?
03:08:06 <alpounet> like the dolphin
03:08:24 <dramforever> I think my ide spell-checker will like flipper better
03:08:46 <dramforever> s/ide/emacs/
03:09:49 <dramforever> alpounet, is there a Get/Put combined stuff for haskell?
03:10:06 <dramforever> Otherwise I think making a list of 10M elements is not very good
03:10:27 <dramforever> neither good for builder nor concat <--- just I think
03:10:52 <alpounet> dramforever: the builder is optimized for building a big bytestring from a bunch of smaller ones (and I do mean *a bunch*)
03:10:56 <alpounet> don't prematurely optimize things
03:11:42 <alpounet> try it out first, if it's too slow, spot the bottleneck with profiling tools and only then you should optimize things
03:12:08 <dramforever> alpounet, how I'm supposed to *decode* it? splitAt?
03:12:31 <alpounet> dramforever: decode? you didn't mention any decoding in your problem statement
03:12:50 <dramforever> alpounet, b is a bytestring
03:13:03 <dramforever> lazy bytestring
03:13:23 <alpounet> yeah, and you want to reverse the bytes of every chunk of 'i' bytes
03:13:38 <alpounet> no decoding is necessary here AFAICT
03:13:46 <dramforever> alpounet, so I have to de-byte them
03:13:54 <alpounet> uh?
03:13:54 <dramforever> or did I miss something?
03:14:32 <alpounet> dramforever: should these bytes eventually be considered as text (as in, say, utf8 chars)
03:14:36 <alpounet> ?
03:14:53 <Twey> Can I tell cabal to run only a specific benchmark stanza rather than all of them?
03:14:58 <dramforever> no, just binary
03:15:17 <Iceland_jack> dramforever: What did you mean by de-byte?
03:15:40 <alpounet> dramforever: then you're good to go, no decoding necessary if you want to consider the bytes as... just bytes
03:15:55 <dramforever> maybe I used the wrong word...
03:15:57 * Iceland_jack . o ( ByteString should really just be called Bytes )
03:17:00 <alpounet> Twey: yes, you can specify a "pattern" and all the benchmarks whose name match the pattern will be run, and no others. just run --help on your criterion bench executable for more details
03:17:05 <dramforever> oh! got it! just a "loop" over the bytestring that splits and reverses segments, and building a builder along the way
03:17:12 <alpounet> dramforever: exactly :)
03:17:25 <Twey> alpounet: But I don't want to build the other stanzas, either
03:17:43 <dramforever> alpounet, I'll certainly thank you after I finish this...
03:17:56 <alpounet> Twey: then you want them in a separate bench i guess?
03:18:11 <Twey> alpounet: I have a stanza that builds a set of Criterion benchmarks, all of which I want to run — but there are other benchmark stanzas that build other kinds of benchmarks, and I don't want to build or run them
03:18:45 <alpounet> Twey: for these cases I generally put them in a separate benchmark (i.e separate file and separate bench section in the cabal file)
03:19:06 <Twey> alpounet: Right, they are, but I don't know how to tell Cabal to build only that benchmark
03:19:22 <Twey> There only seems to be an --enable-benchmarks option
03:19:24 <alpounet> Twey: i'm afraid there is no other vaguely handy way to do that
03:19:45 <dramforever> Hey, another question, how I'm supposed to tell if a lazy bytestring is *longer* than some Int64?
03:19:52 <Twey> Hrm, okay, thanks
03:20:07 <dramforever> Because I'm afraid that BL.length is O(n)
03:20:51 <jkarni> Twey: if you have a separate executable, cabal build <name> should work
03:20:51 <Axman6> dramforever: you could use toChunks and then fold over that
03:21:07 <Cale> Or just drop some elements and see if it's empty
03:21:26 <Axman6> that too
03:21:29 <dramforever> Axman6, Cale, I think I will see if the first chunk is longer than that
03:21:51 <Cale> dramforever: I think my way is the easiest way to be efficient about it
03:22:12 <Twey> jkarni: Oho
03:22:13 <dramforever> Cale, my int64 is small...and length on a chunk is O(1)
03:22:15 <alpounet> Twey: what jkarni just suggested might work, and if it doesn't you may play with flags that set buildable:true/false for the benchmarks, depending on what you want to build, but that's getting quite ugly in my opinion
03:23:00 <Cale> dramforever: yeah, but if the chunk is smaller than your Int64, there still might be another chunk to look at
03:23:17 <Cale> dramforever: and there are no particular guarantees about chunk size
03:23:17 <dramforever> My Int64 is like <10
03:24:07 * Axman6 would also use Cale's method anyway
03:25:15 <Twey> jkarni: Seems to do the trick; thanks!
03:25:45 <jkarni> Twey: no problem
03:25:58 <dramforever> Axman6, Cale, okay, I'll uses Cale's method
03:26:28 * dramforever just typed "import B" in ghci
03:28:41 <dramforever> Just curious: what's ShortByteString?
03:28:46 <dramforever> I think I need this
03:28:58 <dramforever> since those segments are really short
03:31:49 * hackagebot yi-language 0.1.0.3 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.3 (MateuszKowalczyk)
03:33:54 <dramforever> alpounet, that was impressive...thank to you
03:34:10 <dramforever> more thanks to builder, it deserves more attention
03:34:35 <alpounet> I take it that you're satisfied with the performance?
03:34:55 <dramforever> I just made a 40s program into 1.9s!!!! (measured with time command)
03:35:22 <dramforever> alpounet, way too much satisfaction
03:35:54 <dramforever> Now I can tell my friend that his 4s python program is too slow
03:36:49 * hackagebot bcrypt 0.0.5 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.5 (AndrewMiller)
03:44:04 <light_> so newtype is good for things like the Sum monoid?
03:44:36 <light_> Because you just want it to be a bit different to a normal number
03:45:00 <Fuuzetsu> it's good for anything you might want to have multiple typeclass instances for
03:45:24 <Fuuzetsu> also just in general good for anything that you want to distinguish from other things that are effectively the same under the hood
03:45:54 <light_> Yep sweet
03:46:29 * dramforever sometimes think that C programmers (and some C++ programmers) are not making enough use of the type system
03:46:40 <Fuuzetsu> I always think that
03:46:50 <Fuuzetsu> more like, C programmers don't have a typesystem to use
03:47:09 <trap_exit> anyone have a good example of using haskell as a layer that sits right in front of a DB?
03:47:17 <trap_exit> i.e. I don't want othe rprocesses to access DB directly
03:47:19 <dramforever> for example why "typedef int SOCKET" when you can "typedef struct {int num} SOCKET"?
03:47:23 <trap_exit> so I want them to talk to haskell, which then talks to the DB
03:47:23 <Fuuzetsu> anything using esqueleto?
03:47:48 <trap_exit> dramforever: pick me pick me! latter lets type checker do more for you
03:48:06 <Fuuzetsu> trap_exit: pshft, that makes your compiles slow and bloated!
03:48:23 <trap_exit> Fuuzetsu: I'm sure the haskell guys have a compiler flag to unbox this or something
03:48:23 <Fuuzetsu> just #define SOCKET int
03:48:39 <dramforever> trap_exit, this struct has *no* runtime cost, just like haskell newtype
03:48:52 <trap_exit> dramforever: I never claimed it has runtime cost
03:50:05 <dramforever> trap_exit, sorry, I thought you said "makes program slow and bloated"
03:50:18 <trap_exit> dramforever: I love haskell. I would never say that.
03:50:57 * dramforever goes and cleans his glasses
03:51:06 <light_> This learning curve though
03:53:16 <alpounet> trap_exit: i've written servant for that, to have webservices wrap databases in a straightforward way
03:53:31 <alpounet> not sure this fits your question
03:53:32 <trap_exit> alpounet: "servant" is a package?
03:53:42 <Fuuzetsu> yes
03:53:50 <trap_exit> http://hackage.haskell.org/package/servant ?
03:54:09 <alpounet> trap_exit: yes
03:54:18 <alpounet> it's several packages actually
03:54:23 <alpounet> that's the core one
03:54:42 <trap_exit> alpounet: hmm, this soudns right, I want "type-safe REST-y service"
03:54:43 <trap_exit> so far so good
03:55:14 <trap_exit> alpounet: do you have a blog post of some sort which shows how all the pieces work togeher under optimal conditions?
03:55:37 <alpounet> trap_exit: i'm in the process of rewriting it with some additional goodness, what you see is a 0.1, keep that in mind :) but if you're interested and want to talk about it, we can take that conversation to private messages
03:58:08 <k_bx> Is there a practical reason why newtype's are limited to hold a single value only? I mean, it seems like a usable thing to me.
03:58:57 <dmwit> There is a practical reason: because they hold only a single value, no new representation for the value need be created by the compiler.
03:59:38 <dmwit> If you need more, consider using a tuple or similar. Or just using a real data type.
04:00:15 <k_bx> dmwit: I mean, real data type would add overhead of it's data-constructor, which, if you only have one, you might not need at runtime. Right?
04:00:38 <dmwit> That sounds right to me.
04:01:02 <k_bx> Probably you're right and using something like strict tuple inside newtype will be similar to what I want
04:01:16 <dmwit> Actually, maybe I misunderstood your claim.
04:01:29 <dmwit> Are you talking about multiple constructors, or multiple values within a single constructor?
04:02:40 <dmwit> Maybe one should also ask: what is it that you want?
04:03:29 <k_bx> dmwit: multiple values within single data-constructor
04:03:49 <k_bx> dmwit: I want to omit runtime-cost by still having type-safety, as we all do! :)
04:04:12 <dmwit> What runtime cost, in particular?
04:04:45 <dramforever> k_bx, I think (# Unboxed, Tuples #) might do
04:04:57 <dramforever> but you cannot put it in a newtype...
04:04:59 <dv-> is there something like ByteString -> (Char -> IO ()) -> IO () ?
04:05:08 <dv-> or Word8 rather
04:05:57 <k_bx> dmwit: packing/unpacking from data-constructur, I believe. I'm far from understanding how things work, but I've read newtypes have no impact on performance, so I thought something similar can be done if you represent multiple-valued single-data-constructor type as newtype. Am I wrong here?
04:06:15 * dramforever read too much stuff about continuations and think that the type dv- gave is ByteString -> ContT () IO Char
04:06:19 <k_bx> dramforever: why wouldn't I be able to use http://hackage.haskell.org/package/strict inside newtype?
04:06:44 <k_bx> dramforever: (I meant Data.Strict.Tuple)
04:06:46 <light_> Cause they're not base types?
04:06:56 <dramforever> I think you can...
04:07:00 <nilg> can pattern matching be used for function defined inside a where?
04:07:11 <dramforever> nilg, yes
04:07:37 <nilg> thanks
04:07:39 * dramforever uses it often
04:07:43 <k_bx> Am I confusing "strict" and "unboxed"? light_: is that what you mean?
04:08:13 * dramforever doesn't really know the difference between strict and unboxed
04:08:15 <light_> I'm just taking guesses, I know next to nothing about this
04:08:34 * dramforever got some enlightment
04:08:46 <dramforever> Unboxed lazy value is possible!
04:09:06 <dramforever> so strict undefined will die, unboxed undefined will not
04:09:29 <dramforever> nilg, you can even use guards like this: (posting code to lpaste...)
04:10:39 <jmcarthur> eh
04:10:55 <jmcarthur> you can have unboxed *tuples* that have lazy fields
04:11:21 <lpaste> dramforever pasted “Some guards stuff” at http://lpaste.net/110054
04:11:42 <jmcarthur> but boxing is necessary in ghc to have laziness. indeed, the lazy fields in an unboxed tuple are in fact boxed.
04:12:07 <k_bx> jmcarthur: question is, how is single-constructor datatype with multiple fields represented at runtime. What's the runtime-difference between newtype with strict tuple and "real" datatype?
04:12:12 <jmcarthur> the tuple is only unboxed in the sense that there is not an extra constructor for it
04:12:51 <dramforever> IIRC, newtypes are gone very early when compiling
04:13:03 <jmcarthur> k_bx: a type defined with data is represented as a constructor and pointers to its fields
04:13:26 <jmcarthur> k_bx: defined with newtype, it's just the representating of the underlying value
04:13:31 <jmcarthur> *representating
04:13:33 <jmcarthur> ugh
04:13:35 <jmcarthur> *representation
04:13:46 <k_bx> jmcarthur: so, it seems like there *is* a sense of having multiple-field newtype that would be desugared to strict tuple, is there?
04:13:58 <k_bx> (from runtime perspective)
04:14:02 <jmcarthur> what do you mean by a strict tuple?
04:14:13 <jmcarthur> data StrictTuple a b = StrictTuple !a !b   ?
04:14:33 * dramforever thinks k_bx meant (# unboxed, tuples #)
04:14:56 <jmcarthur> ah. yeah, i kind of think of unboxed tuples as being a sort of weird newtype, sometimes
04:15:02 <jmcarthur> but they don't work in all the same places
04:15:14 <k_bx> jmcarthur: probably I wanted to say unboxed tuple
04:15:18 <dramforever> like you cannot put it in a new type
04:15:24 <jmcarthur> the compiler assumes that newtypes just have one field
04:15:38 <jmcarthur> but if you tried to make a newtype wrapper around an unboxed tuple, that wouldn't true
04:15:43 <dramforever> jmcarthue, *ensures*
04:15:50 <jmcarthur> dramforever: both
04:16:23 * dramforever is still smiling about bytestring builder
04:16:33 <t7> someone actually asked about haskell on my VC at a job interview :O
04:16:38 <jmcarthur> dramforever: the code generator would have to take into account the possibility of multiple fields if that was allowed
04:16:53 <dramforever> t7 did you talk about GADTs?
04:16:55 <jmcarthur> dramforever: also... how would you represent a list of such values?
04:17:10 <jhrcek> @pl (\c acc -> 10 * acc + digitToInt c)
04:17:10 <dramforever> jmcarthue, a cons cell will do
04:17:10 <lambdabot> (. (10 *)) . (+) . digitToInt
04:17:19 <jmcarthur> dramforever: not if it's an unboxed tuple
04:17:23 <dramforever> @help pl
04:17:24 <lambdabot> pointless <expr>. Play with pointfree code.
04:17:27 <t7> dramforever: nah i talked about monomorphism
04:17:34 <jmcarthur> dramforever: you can only store one pointer to an element in the cons node
04:17:35 <Fuuzetsu> it feels like there exists a better way to write ‘modeKeymapA .~ topKeymapA %~ homeBinding’, ideas?
04:17:45 <jmcarthur> dramforever: you'd have to box the tuple so that one pointer would suffice
04:18:00 <Fuuzetsu> I wish there was a tool to simplify lens expressions
04:18:09 <dramforever> jmcarthur, yeah that's what newtype does
04:18:15 <jmcarthur> no it's not
04:18:19 <jmcarthur> newtype does not introduce boxes
04:18:25 <dramforever> newtype S = S Something will just be a pointer to Somethin
04:18:27 <jmcarthur> it has no runtime representation
04:18:36 <jmcarthur> no, it's just a Something
04:18:58 <jmcarthur> it happens that Something is usually a pointer to a heap object anyway, but the newtype doesn't add another level of indirection
04:19:01 * dramforever thinks that in the haskell runtime it's the same thing
04:19:30 <jmcarthur> the point is that S has the exact same representation as Something
04:19:42 <dramforever> wait did you mean newtype Tuple a b = Tuple a b ?
04:19:58 <jmcarthur> that is not possible
04:20:05 * dramforever just said lots of nonsense-ish...
04:20:29 <dramforever> jmcarthur, yeah, that's the answer to k_bx's question
04:20:39 <jmcarthur> consider this:    newtype Foo = Foo (# Int, String #)    -- my question was, if such a thing were possible, how would you represent a list of Foos?
04:21:24 <dramforever> Yeah, I know you can't if you meant this
04:21:29 <jmcarthur> ah
04:21:37 <jmcarthur> then i guess i was confused about what you were talking about
04:21:52 * dramforever is more confused
04:22:22 <dramforever> hey, how about lua's multiple return values?
04:22:40 <dramforever> can we do that in haskell? is that just a function returning an unboxed tuple?
04:22:43 <jmcarthur> that sounds like what we call unboxed tuples, or at least that's what unboxed tuples are intended for
04:23:06 <dramforever> oh, so you cannot point to two things in one pointer
04:23:15 * dramforever is more "un"-confused
04:23:54 <xash> Hey. I'm trying to get used to ST & do notation. Is there a way to make http://lpaste.net/110051 look nicer – i.e. 1.) something else for the if block and 2.) stop using the temporary variables e and c?
04:24:03 <jmcarthur> right. a pointer already implies it is boxed, in fact.
04:24:58 <Iceland_jack> xash: you can use 'when'
04:25:06 <k_bx> Trying unboxed inside newtype gives "Expecting a lifted type, but `(# Int, Int #)' is unlifted", and trying list of unboxed gives "Couldn't match kind `*' against `#'".
04:25:33 <Iceland_jack>     when (x == e) $
04:25:33 <Iceland_jack>       modifySTRef count (+1)
04:25:33 <Iceland_jack>     when (c == 0) $
04:25:33 <Iceland_jack>       readSTRef elem x
04:25:49 <Iceland_jack> oops, *writeSTRef
04:26:10 <Iceland_jack> xash: note that 'modifySTRef ref (const x)' is the same as 'writeSTRef ref x'
04:27:23 <Iceland_jack> @ty \ref x -> modifySTRef ref (const x)
04:27:24 <lambdabot> STRef s a -> a -> ST s ()
04:27:26 <Iceland_jack> @ty writeSTRef
04:27:28 <lambdabot> STRef s a -> a -> ST s ()
04:27:40 <xash> Iceland_jack: Cool, thanks!
04:27:51 <jmcarthur> k_bx: yup
04:27:52 <BoR0> :t const
04:27:53 <lambdabot> a -> b -> a
04:27:53 <Iceland_jack> no prob
04:28:00 <Iceland_jack> @src const
04:28:00 <lambdabot> const x _ = x
04:29:38 <Iceland_jack>     when (x == e) (modifySTRef count (+1))
04:29:38 <Iceland_jack> is the same as
04:29:38 <Iceland_jack>     if x == e
04:29:38 <Iceland_jack>     then modifySTRef count (+1)
04:29:41 <Iceland_jack>     else return ()
04:31:56 * hackagebot friday 0.1.2 - A functionnal image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.1.2 (RaphaelJavaux)
04:32:10 <zwer> @src when
04:32:11 <lambdabot> when p s = if p then s else return ()
04:33:03 <Fuuzetsu> is there a lens operator for p <- view myLens <$> foo such that I could just do myLens `someOp` foo ?
04:36:57 * hackagebot quickspec 0.9.6 - Equational laws for free!  http://hackage.haskell.org/package/quickspec-0.9.6 (NickSmallbone)
04:38:50 <prophile> ooh
04:39:50 <bennofs> Fuuzetsu: I don't think lens provides combinators that take monadic input
04:41:00 <Fuuzetsu>   p <- view GHCi.ghciProcessName <$> withEditor getDynamic is a little ugly, 'tis all
04:58:39 <Fuuzetsu> @pl mkModeHL f l = ExtHL $ Driver.mkHighlighter (f . IncrParser.scanner Paren.parse . Paren.indentScanner . l)
04:58:40 <lambdabot> mkModeHL = ((ExtHL . Driver.mkHighlighter) .) . (. ((IncrParser.scanner Paren.parse . Paren.indentScanner) .)) . (.)
05:07:01 * hackagebot http-client-request-modifiers 0.1 - Convenient monadic HTTP request modifiers  http://hackage.haskell.org/package/http-client-request-modifiers-0.1 (SeanLeather)
05:13:14 <Algebr> What are the headers for the stuff that cabal makes when doing cabal install in a sandbox?
05:20:08 <Algebr> or the difference between cabal making a build directory and dist-sandbox directory under /dist...
05:25:50 <sgronblo> I'm still trying to get all the source for my newly generated yesod app
05:26:24 <sgronblo> I tried cabal install --reinstall --haddock-hyperlink-source but I'm not sure it helped. I expected my .cabal to be full of .hs files if it had worked.
05:27:21 <sgronblo> I mean the .cabal-sandbox dir
05:30:09 <sgronblo> https://github.com/haskell/cabal/issues/1829 oh eh, wtf
05:32:25 <Axman6> @hoogle Int -> [a] -> [[a]]
05:32:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:32:29 <lambdabot> Data.List drop :: Int -> [a] -> [a]
05:32:29 <lambdabot> Prelude take :: Int -> [a] -> [a]
05:33:12 <steffen`> When using FFI to interface C, I understood that for char* I'll have to use CString (if there is no integer following it indecating its length).   When it says 'const char *' can I still use CString?
05:35:28 <joshc> steffen`: yes, I would expect it to work just fine
05:36:38 <jollygood> [e| 1+2 |] <- is this computed at compile time?
05:37:33 <sgronblo> No vim users here who are using ctags to navigate to cabal-installed packages source code?
05:41:29 <CapitalS1gma> is there anything i can read for "software engineering best practices in functional languages"? like the java-oriented "Clean Code"?
05:42:03 <cow_2001> there are style guides
05:42:26 <cow_2001> i wouldn't say they are "engineering best practices", though...
05:42:35 <cow_2001> still a good read
05:43:01 <jollygood> x = $([e| unsafePerformIO $ do putStrLn "hello"; return 2 |])
05:43:23 <systemfault> Is that a haskell jquery plugin? :P
05:43:25 <jollygood> why doesn't this print "hello" when I compile source file?
05:49:55 <sgronblo> no. its template haskell?
05:50:18 <jollygood> yes template haskell
05:56:17 <makalu> I installed company-ghc for Emacs and it only completes when I'm typing something on the top level. Anyone had this issue?
05:57:32 <Fuuzetsu> tfw no dependent typess
06:10:46 <davd> is 1 == 1.0 according to cabal?
06:11:12 <dcoutts> davd: no
06:11:21 <dcoutts> > [1] == [1,0]
06:11:22 <lambdabot>  False
06:11:33 <davd> oh
06:11:38 <davd> great, thx
06:12:09 <dcoutts> davd: to a first approximation: data Version = Version [Int] deriving (Eq, Ord)
06:12:28 <dcoutts> so it's the Ord instance for [Int]
06:20:09 <amar^> anyone using/contributing to purescript?
06:20:35 <amar^> any links to good documentation of it?
06:20:45 <bergmark> seen the book?
06:21:19 <amar^> not yet, is it good to start with?
06:21:25 * dramforever just looked at ghc-iphone mailing list and was suprised to find lots of chinese spam there
06:21:31 <bergmark> probably
06:21:49 * dramforever can read Chinese
06:22:10 <amar^> cool thanks
06:22:27 <bergmark> 90% of my spam is in chinese
06:22:34 <dramforever> I think I saw many marketing lecture ads
06:22:43 <dramforever> maybe somebody is helping us marketing?
06:25:02 * dramforever just switched to laptop and cannot find ghc-iphone anymore
06:25:40 <dramforever> Maybe they spam because they saw "iphone"?
06:27:31 * dramforever found it
06:30:19 <dramforever> some of the subjects says "酒店"(hotel), but inside they are all marketing ads...
06:31:24 * dramforever was suprised seeing "Jewelry Supplier from china
06:31:28 <dramforever> "
06:41:19 <dramforever> bizarre bytestring question: is it possible to track the progress of a bytestring builder?
06:41:31 <dramforever> length already known
06:44:44 <c_wraith> dramforever: a bytestring builder should be too fast to be worth tracking
06:45:23 <dramforever> c_wraith, that's true
06:46:22 <c_wraith> dramforever: but to actually answer the question - I don't believe there's any way
06:46:57 <dramforever> c_wraith, maybe track by un-chunking the lazy bytestring when writing to a file?
06:48:24 <fractalsea> Hi, I'm an emacs newbie. I'm trying to set up haskell-mode. When I type C-c C-l, I get an error saying an imported cabal module cannot be found. It is there though, and it can be loaded fine in ghci. Does anyone know how I can correctly set up the include paths for the interactive buffer in emacs?
06:49:14 <dramforever> fractalsea, I got this error once too, because it invoked hugs...are you sure you got ghci?
06:49:23 <dcoutts_> dramforever: when you say track the progress, what do you want exactly?
06:49:45 <dramforever> dcoutts_, just like forall a. a-processing software
06:49:54 <dcoutts_> dramforever: you can track the progress as you take a builder an write it out to some sink (like a handle)
06:49:55 <fractalsea> yeah. If I run ghci and type import <package-name> it loads fine
06:50:00 <dramforever> like file format conversion
06:50:21 <dcoutts_> dramforever: but you cannot from within the builder, or without running the builder
06:50:31 <dramforever> dcoutts_, I guess I could track while unchunking and writing
06:50:40 <bergey> fractalsea: What command does C-c C-l run (you can find out with C-h C-k C-c C-l)
06:51:13 <dcoutts_> dramforever: that's the point when you're really running the builder, so that's the appropriate time to do it
06:51:16 <bergey> (There are at least two common bindings in haskell-mode.)
06:51:44 <dramforever> dcoutts_, and all, thanks for all your advice
06:52:02 <lpaste> Crockeo pasted “Texturing” at http://lpaste.net/110065
06:52:15 <Crockeo> Hey so I was in here a little while ago and I had a problem with textures in the OpenGL binding. I ended up loading textures through GLUtil, so I know (or at least I'm guessing) that the Texture is valid, but it's still rendering as a white square.
06:52:30 <Crockeo> The lpaste is my texture code
06:52:37 <fractalsea> bergy, it's haskell-process-load-or-reload
06:52:43 <Crockeo> Could someone in here take a look at it?
06:52:49 <albeit> If I have a type like :: m (m a)  (in this case Vector (Vector Double), from hstats), is there an easy way to convert it to [[a]] given there is a function Vector a -> [a]?
06:53:13 <fractalsea> bergey, so it's meant to load up my current file in an interactive prompt
06:53:28 <Tuplanolla> Yes, <$>, albeit.
06:54:33 <dramforever> albeit, map toList . toList, if m supports it
06:55:06 <albeit> Tuplanolla: So something like Vector.toList <$> Vector.toList data?
06:55:21 <dramforever> albeit, I think so
06:55:27 <Tuplanolla> It's a generalization of map, as dramforever hinted.
06:55:34 <albeit> Great, thanks!
06:56:14 * dramforever finally found someone who doesn't misspell my nickname
06:57:51 <doismellburning> dramforever: I hear modern (c. 1990ish) irc clients have tab completion for nicks
06:58:18 <dramforever> doismellburning, people think I'm dreamforever
06:58:46 <dramforever> and my ******* autocorrect does this too...
06:59:01 <bergmark> admittedly i read "dreamforever" 3 times after you commented on misspellings
06:59:14 <doismellburning> dramforever: I used to have the nick Maior, and a filter to mute anyone who called me "Major"
06:59:37 <dramforever> dram == DoRAeMon
07:00:00 <arianvp> Anyone here using  haskell-mode in emacs?
07:00:23 <dramforever> doismellburning, hahaha
07:00:46 <albeit> Another question, does something like (a -> a -> b) -> [a] -> [[b]], where [b] is result of apply the function to each pair of [a]?
07:00:48 <fractalsea> arianvp, just trying to set it up myself...
07:01:10 <arianvp> M-x <RET> hoogle <RET>   tells me
07:01:15 <arianvp> zsh:1: command not found: hoogle
07:01:26 <Algebr> lol.
07:01:38 <arianvp> whilst   M-: <RET> (executable-find "hoogle")
07:01:48 <arianvp> returns ~/.cabal/bin/hoogle
07:02:02 <arianvp> and really clueless
07:02:03 <arianvp> :/
07:02:26 <Ankhers> arianvp: What command are you running with M-x <RET>?
07:02:34 <arianvp> hoogle
07:02:42 <arianvp> haskell-hoogle*
07:02:47 <arianvp> but that's an alias for the same thing
07:03:17 <Ankhers> Works fine for me. I'm not using zsh though.
07:03:28 <Ankhers> Don't know if that has anything to do with it.
07:03:45 <Ankhers> arianvp: Do you have the latest haskell-mode?
07:03:52 <arianvp> How can I ensure that?
07:04:07 <dramforever> Ankhers, where did you set up your PATH?
07:04:28 <arianvp> I got the latest version from MELPA
07:04:38 <Ankhers> dramforever: I feel like about about to answer this incorrectly. But I set it up in my .bash_profile
07:04:49 <arianvp> the weird thing is. i'm debugging the command.   and
07:04:49 <arianvp> https://github.com/haskell/haskell-mode/blob/master/haskell-mode.el#L632
07:05:00 <arianvp> this returns false. so emacs can find the command ...
07:05:23 <Ankhers> What is the date on M-x haskell-version
07:06:07 <arianvp> haskell-mode version @VERSION@ (@GIT_VERSION@ @ /home/arian/.emacs.d/elpa/haskell-mode-20140823.1148/)
07:06:20 <bergey> is $HOME/.cabal/bin in your exec-path.  I think shell-command-to-string uses that, not $PATH.
07:06:57 <arianvp> let me check
07:07:27 <arianvp> (add-to-list 'exec-path "~/.cabal/bin")
07:07:32 <arianvp> that seems okay, right?
07:07:51 <Ankhers> Should be. You executed that?
07:07:55 <arianvp> yep
07:08:08 <arianvp> M-: <RET> exec-path also returns ~/.cabal/bin
07:08:11 <arianvp> :/
07:08:39 * geekosaur wonders if an expand-file-name is needed in there somewhere, or if it's integrated now
07:08:41 <bergey> Does exec-path interpret ~?  I don't know.
07:09:05 <c_wraith> dramforever: oh.  I thought you were pushing a certain type of RAM. :)
07:09:05 <arianvp> i'll try expand-file-name
07:09:29 <dramforever> c_wraith, huh?
07:09:37 <fractalsea> How do I change the include directories emacs looks in for haskell libraries?
07:09:51 <arianvp> bergey: that didnt work either.
07:09:57 <arianvp> still : zsh:1 command not found: hoogle
07:10:14 <c_wraith> dramforever: your username. DRAM is the most commonly used type of RAM.  I though you were advocating sticking with it forever. :)
07:10:20 <dramforever> oh
07:10:22 <geekosaur> oh, it's handing off to a shell. you'll need to set it in the shell
07:10:34 <Algebr> arianvp: are you on os x?
07:10:40 <arianvp> nope. ubuntu
07:10:46 <geekosaur> setting PATH in .zshrc / .zshenv is not recommended but may be the right thing to do for now
07:11:05 <Algebr> geekosaur: why is that not recommended?
07:11:21 <arianvp> M-: <RET>  (shell-command-to-string "hoogle") doesn't work either
07:11:33 <dramforever> Algebr, because it only affects the shell
07:11:43 <bergey> Well, I'm out of bad advice, then. :(
07:11:55 <Algebr> dramforever: where should it be set then? In some /etc?
07:11:57 <arianvp> geekosaur: it's already in my PATH in zsh ...
07:11:58 <arianvp> WTF
07:12:07 <dramforever> Algebr, that would be worse
07:12:12 <arianvp> export PATH="/home/arian/.cabal/bin:/
07:12:15 <dramforever> You should set it in .progile
07:12:15 <geekosaur> Algebr: correct way to do it is .zprofile during session startup, but the way linux starts desktop environments means it doesn't get used where it needs to be. meanwhile doing it in the per-shell file breaks things like rvm
07:12:19 <dramforever> .profile
07:12:55 <arianvp> darmforever.  .profile isn't used by zsh if I recall correctly
07:12:57 <geekosaur> also shell *windows* are usually login shells and read .profile. emacs is typically started fromt he GUI and linux desktop environments don't set the environment from shell dotfiles
07:13:02 <dramforever> darm...
07:13:05 <bennofs> arianvp: try changing exec-path in emacs
07:13:13 <Ankhers> arianvp: What is the value of haskell-hoogle-command?
07:13:16 <arianvp> bennofs: I tried that already
07:13:19 <dramforever> arianvp, but it's used when you login, so it affects everything
07:13:26 <geekosaur> so emacs and the shells it starts will not see anything form .zprofile / .profile
07:13:31 <bennofs> oh, sorry then. Didn't read the full backlog :)
07:14:38 <arianvp> Ankhers: "hoogle"
07:15:51 <geekosaur> setting PATH in the per-shell dotfiles works around linux desktop environments not paying attention to login dotfiles but breaks most sandboxes (cabal sandbox is generally ok with it, rvm / perlbrew / virtualenv / hsenv will usually have their sandbox config overridden and become somewhar useless)
07:16:18 <arianvp> but why cant  shell-command not find hoogle?
07:16:18 <arianvp> :/
07:16:42 <dramforever> geekosaur, sorry if I was misleading, but I think .profile works in (at least) my (fedora 20) gnome 3(.10)
07:17:10 <Ankhers> arianvp: M-: (executable-find "hoogle")
07:17:13 <Ankhers> Does it find it?
07:17:30 <geekosaur> it can work if you coinfigure it properly, or if they've started doing the right thing in session startup finally (they have resisted this in the past)
07:17:49 <arianvp> Ankhers: yes
07:17:53 * dramforever saw coinfigure
07:18:20 <Ankhers> arianvp: I am out of ideas. Sorry.
07:18:32 <dramforever> I actually "figured out" that I should use .profile if I'm not dealing with shells
07:18:38 <arianvp> yes same
07:19:10 <Ankhers> arianvp: If it doesn't matter, you can set haskell-hoogle-command to nil and it will open in a browser.
07:19:27 <arianvp> But I want to use the commandline version :P
07:19:30 <dramforever> I figured out while "configuring" java
07:19:30 <arianvp> i'll check #emacs
07:19:46 <dramforever> I thought yum/rpm did this for me
07:19:50 <Ankhers> Try just setting haskell-hoogle-command to the full path of the binary.
07:20:06 <Algebr> yea, wouldn't a setq just do the trick?
07:20:30 <joe9> I am trying to find out how I can get argv[0](of shell) in haskell. I found this http://haskell.1045720.n5.nabble.com/How-to-get-a-file-path-to-the-program-invoked-td5039164i20.html. Just wanted to check if that is still the only way or if there is any new functionality to do that.
07:20:33 * dramforever wonders how does login managers preserve the environment of shell scripts
07:20:47 <dramforever> maybe they put themselves after .profile?
07:21:55 <kstt> joe9: pardon me, but as we are on #haskell, I will mention that using executable path is a code smell most of the time
07:22:45 <joe9> kstt: I am writing a program that can restart itself on receiving a signal, hence, the need for executable path.
07:22:57 <joe9> not sure how xmonad does it though.
07:23:07 <dramforever> joe9 I think you need another program
07:23:12 <arianvp> how would I set haskell-hoogle-command ?  elisp nooby :)
07:23:42 <kstt> joe9: having an other process is much better
07:24:18 <pepijn> can anyone help me with some problems with haskell-mode? it keeps reporting that 'The Haskell process ... has died. Restart?' at any point where the code doesn't parse/typecheck, drawing focus to the minibuffer and making it basically unusable...
07:24:26 <dramforever> kstt +1, so even if your process was SIGKILL'ed it still works
07:24:57 <arianvp> today is the haskell-mode problems day I think
07:25:09 <dramforever> does anyone if it's okay to exec when processing SIGSEGV?
07:25:22 <dramforever> arianvp, no, today is executable problems day
07:25:24 <arianvp> okay setting haskell-hoogle-command worked :)
07:25:40 <arianvp> not pretty.  fine
07:25:40 <Ankhers> pepijn: Are you using structured-haskell-mode?
07:26:50 <pepijn> Ankhers: let me check, I don't think so.
07:28:04 <pepijn> Ankhers: no, I'm not using structured-haskell-mode.
07:28:24 <joe9> http://hackage.haskell.org/package/pseudomacros-0.0.1/docs/PseudoMacros.html seems the only reliable method to get the argv[0]
07:29:45 <dramforever> joe9 System.Environment.getProgName
07:29:53 <dramforever> or System.Environment.getExecutablePath
07:30:02 <dramforever> How about that?
07:30:51 <Ankhers> pepijn: You should be able to press l to open a log of why the process died. Can you do that?
07:31:20 <Ankhers> (lowercase L)
07:32:44 <pepijn> Ahkhers: yes, I can do that; it will report a parse error or some other legitimate reason for not compiling.
07:32:47 <bennofs> pepijn: if you can't do what Ankhers said, you need to set haskell-process-log to t
07:33:02 <bennofs> pepijn: are you using cabal repl?
07:33:05 <pepijn> yes.
07:33:35 <Ankhers> I don't think I have seen it crash for not compiling.
07:33:38 <bennofs> pepijn: then it's a bug in cabal repl. If you try cabal repl on command line, it will also fail to start an interpreter
07:34:21 <bennofs> cabal repl shouldn't try to compile the library/executable at all
07:34:35 <pepijn> bennofs: indeed, from the command-line it will also fail to start a repl... so it's not a haskell-mode thing, but a cabal repl thing?
07:34:48 <bennofs> pepijn: yes, cabal repl or ghc (i don't remember)
07:34:56 <pepijn> bennofs: any recommended configurations to work around this for the time being?
07:35:10 <bennofs> pepijn: no, I'm facing the same issue :(
07:35:20 <Ankhers> What are the conditions that this happens?
07:35:35 <pepijn> bennofs: well, boo. :(
07:35:37 <bennofs> Ankhers: I think cabal install 1.20 + ghc 7.8.3
07:35:56 <Ankhers> Well than. I guess I'm glad I didn't upgrade to 7.8.x yet
07:36:08 <Ankhers> Not that I currently do a lot of Haskell work :(
07:36:24 <bennofs> Ankhers: yes, I think the problem only appears with ghc 7.8
07:37:18 <pepijn> bennofs: would you guess there's any chance of a downgrade of cabal fixing this issue? maybe all the way down to 1.18... or am I inviting in a whole host of different problems then?
07:37:58 <bennofs> pepijn: i don't know. iirc it was a ghc 7.8 problem, so downgrading cabal will not help
07:39:32 <joe9> dramforever: http://haskell.1045720.n5.nabble.com/How-to-get-a-file-path-to-the-program-invoked-td5039164i20.html
07:39:57 <pepijn> bennofs: well, i'll just have to toss all of cabal and cabal-mode out, then. :(
07:40:34 <bennofs> pepijn: well, it works if you start the REPL once when the program compiles, and then leave it open (you can still reload, and it will then also show errors and stay open)
07:41:06 <pepijn> bennofs: that... may be an inconvenient but somewhat acceptable workaround. hadn't realised that yet, thanks.
07:41:10 <bennofs> pepijn: for example, you could comment out the errors, then start the repl, remove comment, and reload
07:43:55 <dramforever> weird, where's withBinaryFile?
07:44:08 <bennofs> @hoogle withBinaryFile
07:44:10 <lambdabot> System.IO withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
07:44:19 <dramforever> oh, firefox did not finish loading the page...
07:51:19 <dramforever> anyone tried wavy? how I'm supposed to encode a WaveFile to a L.Bytestring?
07:53:37 <dramforever> @hackage wavy
07:53:38 <lambdabot> http://hackage.haskell.org/package/wavy
07:57:36 <c_wraith> dramforever: the Binary instance
07:58:00 <c_wraith> dramforever: remember to look at instance lists!  (haddock output makes them too easy to ignore)
07:58:10 <dramforever> c_wraith, thank...
07:58:12 <dramforever> thanks
07:58:45 <dramforever> btw WaveFile's Show instance sucks
07:58:55 <c_wraith> dramforever: in particular, the encode function in Data.Binary will convert a WaveFile to a lazy ByteString
08:01:41 <dramforever> c_wraith, already found that myself
08:01:45 <dramforever> thanks anyway
08:07:24 * dramforever is still having problems with strictness
08:08:28 <dramforever> does forM_ (BL.toChunks data) $ \h -> do {BS.hPut h ch; logProgress}
08:08:35 <dramforever> does this work?
08:08:58 <dramforever> I think it just logs all the progress in the end
08:10:12 <daimonos> bitemyapp: Wassup?
08:10:55 <bitemyapp> urbanslug: about to begin my workday.
08:12:01 <dramforever> I think that forM_ is not very good at this...
08:12:36 <dramforever> is Data.Binary.encode strict?
08:14:02 <c_wraith> By the exact technical definition - it depends on the instance, but most will be strict.
08:14:33 <dramforever> c_wraith, how can I tell?
08:14:42 <c_wraith> But the exact technical definition of strict is encode _|_ = _|_
08:14:53 <dramforever> for example forM_ (BL.toChunks data) $ \h -> do {BS.hPut h ch; logProgress}
08:15:03 <dramforever> where data = encode something
08:15:32 <c_wraith> that *should* stream chunks
08:15:51 <dramforever> it just stops for a while, then calls many logProcess's really quickly
08:16:12 <dramforever> here my something is a WaveFile from...
08:16:15 <dramforever> @hackage wavy
08:16:15 <lambdabot> http://hackage.haskell.org/package/wavy
08:16:16 <c_wraith> congratulations, you've implemented windows installer progress bars. :)
08:16:42 <dramforever> c_wraith, yeah, exactly
08:17:12 <urbanslug> Thanks to whoever wrote this https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
08:17:26 <dramforever> c_wraith, I found out that my code needs the length of the data....so it's not suprising...
08:18:00 <urbanslug> bitemyapp: Mine is ending. :) I wish you a great day. I watched your demo. Thanks a ton man.
08:20:30 <dramforever> c_wraith, I think I can make do with a windows-installer-ish progress bar...
08:27:15 <arianvp> Say I have a simple interpreter for my toy language. how abouts would I implement Tail call optimisation in haskell?
08:28:04 <Clarice> arianvp: make sure that the interpreter is running a command as a tail call
08:28:31 <arianvp> what do you mean?
08:29:26 <dramforever> arianvp, return function(args) -> push args on to stack, goto function
08:30:19 <dramforever> does anyone know why B.reverse is so fast?
08:30:29 <dramforever> it's unacceptably fast
08:30:59 <smitzer> Anyone did software defined radio in haskell? not running the haskell runtime but maybe a dsl or codegen tool.
08:31:51 <marchelzo_> dramforever: B as in ByteString?
08:32:16 <dramforever> yeah
08:32:42 <levi> I think there's a DSP DSL... that might be relevant. http://feldspar.github.io/
08:32:42 <dramforever> it seems that the library uses something called "c_reverse"
08:32:48 <dfeuer_> dolio, I think the trick must be to (somehow) allow the necessary functions to be inlined before the initial full laziness transformation, or possibly to limit that transformation further, or something.
08:33:20 <Tuplanolla> I don't know what the library does, but one way of doing that is changing the internal indexer, dramforever.
08:33:51 <dfeuer_> dramforever, unacceptably fast reversing is usually accomplished by using a flag to indicate whether the thing is forwards or backwards.
08:33:57 <dramforever> Tuplanolla, it seems that it reverses a memory buffer
08:34:44 <dramforever> but maybe ghc optimizer did something?
08:34:57 <Tuplanolla> You can put any bijective function between requested and actual indices, one of the most obvious ones being n -> length xs - n.
08:35:02 <dfeuer_> dramforever, the GHC optimizer probably did not do something.
08:35:10 <dramforever> reverse (PS x s l) = unsafeCreate l $ \p -> withForeignPtr x $ \f -> c_reverse p (f `plusPtr` s) (fromIntegral l)
08:35:56 <dramforever> Tuplanolla, dfeuer_, I think bytestrings are honest and are just bytes
08:36:13 <dfeuer_> Also, dramforever, the ByteString code is, as a general rule, somewhat insane. You might want to shield your eyes. It uses things like accursedUnutterablePerformIO....
08:36:26 <Tuplanolla> The mystery is yours to explain.
08:36:44 <dramforever> But it's proabably okay
08:36:58 <dramforever> at least no segfaults seen till now
08:37:09 <dfeuer_> dramforever, one question might be whether the fast reversing scales. Does it stay fast if the bytestring is much larger than L2 cache?
08:37:30 <dramforever> how about 10M? is that large?
08:38:15 <dfeuer_> Not that that will necessarily tell you anything; if it does a lot of sequential stuff the CPU will likely prefetch well and keep things up to date....
08:38:38 <dramforever> dfeuer_, so it means that it's proabably okay?
08:38:41 <dfeuer_> So I don't really know how to test it.
08:38:48 <dfeuer_> dramforever, what do you mean by okay?
08:39:28 <dramforever> dfeuer_, not like Data.Vector.reverse, which takes loads of ram and is very slow
08:39:57 <dfeuer_> dramforever, the documentation for Data.Bytestring is over here: http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html  It says that reverse is O(n)
08:40:14 <dramforever> reversing a 50M-ish (byte size) Int64 vector took 3G of ram, 1 minute
08:40:32 <dramforever> dfeuer_, Data.Vector.reverse is also said to be O(n)
08:40:43 <c_wraith> something is terribly wrong.
08:40:56 <dfeuer_> dramforever, something went very wrong with that vector reverse... unless you are actually seeing something else blow up.....
08:41:00 <c_wraith> reversing a 50 MB vector should be on the order of milliseconds
08:41:04 <dfeuer_> Which is my guess.
08:42:05 <dfeuer_> You'd have to be doing something very very strange to make reversing a 50 MB vector take that long.
08:42:28 <dramforever> file -> bytestring -> wavefile -> bytestring(data part) -> [vector] -> [reversed vector] -> bytestring(reversed data) -> wavefile -> bytestring -> reversed file
08:42:51 <dramforever> where bytestring is Lazy, vector is Vector Int64
08:42:55 <dramforever> wavefile is from...
08:43:01 <dramforever> @hackage wavy
08:43:01 <lambdabot> http://hackage.haskell.org/package/wavy
08:44:52 <dramforever> I'm basically trying to write https://github.com/xmcp/ReVoice/ in haskell
08:45:07 <dfeuer_> dramforever, based only on that description, my guess is that something is being too lazy. You don't (can't) actually make use of that laziness, if you're reversing the entire thing.
08:45:31 <dramforever> maybe, but I just reversed it
08:45:34 <dramforever> did no more
08:45:44 <dramforever> other than writing it out
08:46:34 <dramforever> I thought laziness was the problem, but fixing it would involve reinventing Data.Vector.reverse
08:46:35 <dfeuer_> My best bet for right now is that GHC's strictness analyzer may have recognized that you don't use the laziness when you just did it with ByteString, but that you blinded it by going to and from Vector. Only a guess.
08:47:19 <dfeuer_> If my guess is correct, then you can probably fix it by explicitly forcing some things along the way.
08:47:30 <dfeuer_> dramforever, can you show us the code?
08:47:43 <dramforever> I'm not sure...The vector code is too slow to be kept on my hard disk (fancy way of saying I deleted it), but It's really easy and I think I can recreate it quickly
08:47:55 <dfeuer_> *sigh*
08:48:12 <dramforever> don't worry, I'll do it quickly
08:48:43 <arianvp> Why would one use Alex and Happy if  we have something like Parsec?
08:48:47 <dfeuer_> c_wraith, maybe you can come up with an idea for preventing full laziness from trashing list fusion code? Because I haven't a frickin' clue how.
08:48:50 <arianvp> I like the fact that we have a strong EDSL for parsing..
08:49:21 <c_wraith> dfeuer_: nope. I've never had to defeat the full laziness transform firing inappropriately.  I just know it's hard.
08:49:23 <dolio> Maybe you should ask people who know more about the compiler phases how to run things before the floating happens.
08:49:25 <dramforever> arianvp, maybe because some people like lex and yacc?
08:49:27 <dfeuer_> arianvp, I think the main reason is that parser combinator libraries are not (yet) as efficient as generated parsers.
08:49:28 <dolio> If it's even possible.
08:50:11 <fread2282> arianvp: maybe it's easier to transcode existing grammars into Alex and Happy?
08:50:11 <dfeuer_> dolio, I don't think it's possible with the current code, because the inlining required (of, e.g., $) doesn't happen until it's too late, if I'm reading it right.
08:50:28 <dfeuer_> dolio, who are the people you would suggest?
08:50:50 <arianvp> fread2282:  the Applicative instance of Parser   is basically   grammar syntax
08:50:53 <c_wraith> dfeuer_: have you talked to dcoutts? He's done a fair amount of work on fusion, iirc
08:50:56 <dfeuer_> dolio, but you did just give me one idea....
08:50:58 <arianvp> it looks and feels very similar
08:51:04 <dfeuer_> c_wraith, good idea.
08:51:19 <dolio> People who hang out in #ghc.
08:51:22 <dfeuer_> Oh, that is so ugly.
08:51:35 <dfeuer_> *shudder*
08:54:25 <dramforever> dfeuer_, ready
08:54:41 <lpaste> dramforever pasted “slow vector reverse” at http://lpaste.net/110068
08:55:22 <dramforever> dfeuer_, are you still there?
08:55:29 <dfeuer_> This is so so disgusting I can't even.
08:55:36 <dramforever> oh, it did not take 1min
08:55:42 <dramforever> but still 19 secs
08:55:43 <dfeuer_> dramforever, no I died of the pain of thinking.
08:56:15 <dramforever> oops, lpaste suggests me clean up my code...
08:56:48 <dramforever> specifically, "do case" -> "case"
08:57:14 <dfeuer_> Yes, good idea.
08:57:21 <dfeuer_> Not that it will change anything.
08:57:37 <dramforever> dfeuer_, good thing that the slow code produces correct result
08:57:37 <fread2282> dramforever: use <$> from Control.Applicative instaed of `fmap`
08:57:59 <dfeuer_> fread2282, that will not change the speed either, will it?
08:58:13 <fread2282> no
08:58:24 <dramforever> <$> = fmap by definition
08:58:50 <dramforever> and the compiler will almost certainly inline this
08:59:14 <dramforever> but haskellers seem to hate redundant do
08:59:33 <dmj`> dramforever: hlint hates it
08:59:41 * dramforever , for example, hates main = do putStrLn "hello world"
08:59:47 <dramforever> bet you all hate it
09:00:15 * dfeuer_ loves  main = do putStrLn "hello world"  but only if there's a line break after the do.
09:00:22 <dramforever> dfeuer_ and all, can we focus back on the vector?
09:00:27 <bennofs> I use both fmap and (<$>). I only use fmap in cases like: fmap someFunction $ ..., it allows to avoid parentheses
09:00:30 * dfeuer_ loves it because it makes it easier to add some more lines before or after.
09:00:38 <dfeuer_> OK.
09:00:46 <dfeuer_> dramforever, you still haven't shown us the code!
09:00:47 <l0cust> dramforever: It often makes it much more clear that you're writing monadic code
09:00:58 <fread2282> redundant do on main is fine
09:01:13 <dramforever> dfeuer_, I thought you saw the message from lpaste...
09:01:43 <dramforever> dfeuer_, there you go http://lpaste.net/110068
09:01:51 <dfeuer_> dramforever, I missed it. Sorry. Also, how do you get it to do that? I've never been able to, even when I make it "public" and indicate the channel....
09:02:03 <dramforever> I don't know
09:02:09 <dramforever> Lets focus on the code
09:02:25 <T_S__> T_S_
09:02:37 <smitzer> Anyone did software defined radio in haskell? not running the haskell runtime but maybe a dsl or codegen tool.
09:02:38 <dramforever> WARNING: PROCESSING A NORMAL 4MIN WAV FILE TAKES *3 GIGS* OF RAM
09:02:45 <dramforever> USE WITH CARE!
09:03:14 <dramforever> tweak with no other important documents unsaved
09:03:38 <T_S__> “ulimit -m <mem>” can help there
09:03:40 <c_wraith> smitzer: I think the MIO paper talked about benchmarking on an SDR app
09:04:17 <dramforever> dfeuer_ I commented out the efficient code
09:04:21 <c_wraith> smitzer: nevermind, that was software defined networking.  entirely wrong software-defined. :)
09:04:27 * dfeuer_ is looking.
09:04:51 <dfeuer_> dramforever, or better, just use an RTS option to limit the heap.....
09:05:04 <dramforever> it's efficient with the cost of not known to be safe when dealing with data
09:05:39 <dramforever> only "pcm 16bit little-endian 2 chans" is tested
09:06:00 <dramforever> dfeuer_, I have 8 gigs of ram...
09:06:19 <steffen`> how can I use FFI to be able to use a fictitious function like the following from haskell:    char* readNext (Connection conn)
09:06:55 <dramforever> steffen`, you'd want a pointer or marshalling
09:07:17 <steffen`> dramforever: okay, let me just read up on marshalling :)
09:07:31 * hackagebot combinat 0.2.6.0 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.6.0 (BalazsKomuves)
09:07:40 <dramforever> warning: only marshall trivial data
09:08:04 <dramforever> like marshalling data P = P Int | PF Double Double
09:08:22 <dfeuer_> dramforever, what package does Sound.Wav come from?
09:08:30 <dramforever> @hackage wavy
09:08:30 <lambdabot> http://hackage.haskell.org/package/wavy
09:08:44 <dramforever> I think I posted this command 4 times today...
09:09:02 <steffen`> dramforever: hmm I'd like to use a pointer because it seems easier but how would i define the wrapper in haskell so that in haskell, it would look like i'll get back an additional "new" connection to pass around?
09:09:29 <steffen`> dramforever: or maybe I have to read more, if the question makes no sense xD
09:10:20 <dramforever> steffen, like Connection -> IO ByteString --> char* read(connection c)
09:10:32 <dramforever> where typedef void* connection;
09:10:48 * dramforever hates that but that's what all C programmers do
09:11:18 <steffen`> dramforever: okay :) thank you, I'll check it out
09:11:46 <dramforever> steffen`, newtype Connection = Connection {unConnection :: Ptr ()}
09:11:53 <dramforever> may be what you want
09:12:27 <dramforever> steffen`, is connection defined in haskell or C?
09:12:48 <dramforever> hint: hslua does this kind of wrapping
09:12:53 <dramforever> @hackage hslua
09:12:53 <lambdabot> http://hackage.haskell.org/package/hslua
09:13:22 <steffen`> dramforever: its in C and I just want to use it, i have to built a wrapper from a library
09:13:30 <dramforever> if you want to pass something from C around then that's it
09:13:34 <steffen`> for*
09:13:47 <steffen`> dramforever: okay, thanks :)
09:13:48 <dramforever> steffen for C??
09:14:00 <dramforever> you mean for C?
09:14:19 <steffen`> in haskell i have to wrap the functions which are there in C
09:14:29 <dramforever> so call C from haskell?
09:14:34 <steffen`> yes
09:14:49 <dramforever> then that's right
09:15:08 <dramforever> you can look at hslua source code, maybe together with lua source code
09:15:28 <dramforever> they are both small, unlike SDL or OpenGL or ...
09:15:41 <dfeuer_> dramforever, does it change anything if you use map instead of fmap?
09:15:48 <steffen`> okay, I think with the cookbook and what you wrote above, I'll find my way
09:15:48 <dramforever> where?
09:16:02 <steffen`> dramforever: thank you very much for your kind help :D
09:16:06 <dramforever> steffen`, I think real world haskell has a great chapter on FFI
09:16:23 <steffen`> dramforever: okay
09:16:25 <dramforever> it teaches you to call pcre from haskell
09:16:26 <dfeuer_> dramforever, with all those things that are type synonyms for lists?
09:16:34 <dramforever> that's much much much shorter
09:16:50 <dfeuer_> dramforever, I don't think it *should* make a difference; I'm wondering if it *does*.
09:17:03 <dramforever> dfeuer_, data IntegralWaveData = IntegralWaveData [Vector Int64]
09:17:25 <dramforever> which fmap to change?
09:17:58 <dramforever> dfeuer_, those `fmap`s are all to map over the Either
09:18:13 <dramforever> map won't work
09:19:06 <dramforever> maybe if I put type sigs on those "where" stuff you will understand
09:19:24 <dfeuer_> dramforever, not the first one. What if you change *all* the fmaps to whatever maps over the relevant type? (Again, I don't think it will make a difference, but at least it will clarify.)
09:19:37 <dfeuer_> How many channels does this thing have, by the way?
09:19:43 <dramforever> 2
09:19:50 <dramforever> ...
09:20:13 <dramforever> I think I talked about "i very small" in the(my) afternoon
09:20:19 <dramforever> It's midnight here
09:20:36 * dramforever does not feel sleepy, thoudh
09:20:38 <dramforever> though
09:20:39 * dfeuer_ is still staring at it.
09:21:00 <dramforever> dfeuer_, maybe I edit it to include type sigs?
09:21:15 <dfeuer_> dramforever, that will probably help.
09:21:55 <lpaste> hseg pasted “Deforestation through lambda” at http://lpaste.net/110069
09:22:08 <hseg> Hi. I'm stuck trying to deforest an expression of the form cata . f . cata How do I do this?
09:22:51 <dfeuer_> hseg, that doesn't sound generally possible. Even cata . cata doesn't work, does it?
09:23:29 <dfeuer_> Whoa, taht code is way over my head.
09:23:53 <dramforever> there you go
09:23:58 <dramforever> posting...
09:24:07 <hseg> no. but the specific expression lasted above seems fusible.
09:24:27 <dramforever> hey, lpaste sooooooo slooooow
09:25:08 <hseg> dfeuer_: it's just a cata. I'm converting from a come list to a snoc list. that's it
09:25:25 <dfeuer_> hseg, forget I said anything. I don't understand what you're doing.
09:25:25 <dramforever> https://gist.github.com/dramforever/861ca9a743426f705abb can't bear with lpaste
09:25:49 <dramforever> ouch didn't copy everything
09:26:23 <dramforever> dfeuer_, see my gist for type sigs
09:26:34 <hseg> dfeuer_: a cata is just foldr generalised to other data structures
09:26:39 <dramforever> and a better highlighting
09:26:46 <dfeuer_> hseg, that's the limit of what I know about it.
09:27:03 <dramforever> dfeuer_, saw my gist?
09:27:10 <dfeuer_> Yes, dramforever
09:27:52 <dramforever> summary: map for lists, fmap for Either, no more maps
09:27:53 <hseg> that's the extent of what you need to know for this code. the TF are just in order to implement the type class.
09:28:21 <dramforever> maybe decoding and/or encoding too inefficient??
09:29:50 <arianvp> Why isn't bytestring just a synonym of    Vector Byte ?
09:30:14 <merijn> arianvp: Because they serve different purposes and Vector Byte isn't good for all usecases?
09:30:19 <dramforever> arianvp, because at least you want UVector Word8
09:30:43 <dramforever> And you do not have lazy chunked vectors
09:30:48 <dfeuer_> dramforever, what does encodeIntegralWaveData do with its wf argument?
09:30:59 <dolio> bytestring predates vector.
09:31:03 <merijn> arianvp: ByteStrings are meant for data up to GBs, you don't necessarily want that densely packed, also they need to support things like append, etc.
09:31:07 <dramforever> dfeuer_, replaces the data
09:31:34 <dramforever> arianvp, You don't have Vector Builders, I think
09:31:55 <dfeuer_> dramforever, what does that mean, exactly? Replaces the data, that is?
09:32:17 <dramforever> dfeuer_, you saw the commented code?
09:32:31 <dramforever> wf' = wf { waveData = wd }
09:32:50 <dramforever> encodeIntegralWaveData does something like that
09:33:47 <dramforever> dfeuer_, now I'm worrying that this and decode is inefficient
09:34:05 <texasmynsted> I did not see an FAQ for this channel….   Here http://www.haskell.org/haskellwiki/IRC_channel  or anywhere.
09:34:09 * dramforever might go to sleep soon, depending on the progress of vector optimizing
09:34:20 <texasmynsted> What would you recommend as the best way to learn Haskell?
09:34:38 <dramforever> texasmynsted, learn you a haskell for great good
09:34:46 <texasmynsted> ok
09:34:50 <simpson> texasmynsted: Read code, write code, be patient.
09:34:56 <texasmynsted> I have started going through learn you
09:34:56 * dramforever recommends reading the *whole*  thing before writing code
09:35:22 <dramforever> lyah teaches more deep things later
09:35:39 <dramforever> so I read everything, then I skip the silly stage
09:35:43 <texasmynsted> I stopped because it was getting confusing with syntax differences with scala.  I will simply go back a do it anyway.
09:36:08 <texasmynsted> what is "skip the silly stage"?
09:36:53 <dramforever> writing code that could be simplified and/or optimized using some higher level techniques
09:37:01 <dramforever> like monad transformers
09:37:21 <dramforever> IORef MyState -> Foo -> Bar -> IO Sth
09:37:38 <texasmynsted> that is a problem for all languages right?
09:37:41 <dramforever> turns into Foo -> Bar -> ReaderT (IORef MyState) IO Sth
09:37:48 <dramforever> texasmynsted: yeah
09:37:59 <texasmynsted> ensuring that you are only solving exactly the current problem?
09:38:17 <dfeuer_> dramforever, still no clue about the efficiency, but you should be able to collapse all those fmaps down to just one.
09:38:23 <texasmynsted> ok.  I guess learn you is the way then
09:38:26 <dramforever> texasmynsted: but it might *not* be suitable for everyone
09:38:50 <dramforever> dfeuer_: yeah, and I think ghc can do that
09:38:59 <texasmynsted> well nothing is suitable for everyone, but what are you getting at?
09:39:00 <dramforever> dfeuer_: did you prof my code?
09:39:14 <dfeuer_> dramforever, I don't have your data files or anything....
09:39:36 <dramforever> texasmynsted: I did not even install a haskell environment before finishing reading except the last 1 or 2 chaps...
09:39:48 <dramforever> dfeuer_: just a random wav file will do...
09:40:10 <texasmynsted> hmm.  I like the idea of trying the examples as I go along
09:40:33 <Tuplanolla> People have different preferences.
09:40:36 <dramforever> hint: run it on your favourite music (*not* songs) will make really weird
09:40:51 <texasmynsted> was considering taking detailed notes, but that may not be compatible with the way material is introduced in "learn you"
09:41:03 <joe9> I am trying to use MVar to communicate when a signal is raised. But, am doing something wrong. I do not get the value set in the signal handler when I readMVar in the main thread. test program: http://codepad.org/cGNEDbwr. can anyone please help?
09:42:54 <joe9> this is how the output looks like http://codepad.org/0OUXHuXy . ifHupped is not called with False.
09:43:08 <joe9> sorry, I meant True not False.
09:46:34 <dramforever> dfeuer_: Thanks for all your help for now
09:46:43 <dramforever> I'm going to sleep...
09:46:46 <dfeuer_> dramforever, good night.
09:46:58 <dramforever> feel free to ignore my problem if you want to
09:47:11 <dramforever> or memo me if you got anything
09:47:39 <dramforever> (I just came back to irc to say this...before shutdown...)
09:55:27 <hseg> need to go. perhaps we'll figure this out later?
10:05:39 <joe9> What mechanism is used when communicating with Signal hAndlers? I tried MVar's but could not get it to work.
10:05:59 <dmj`> joe9: are you sure the signal handler is getting called?
10:07:02 <c_wraith> Oh hey.  I'd been wondering where kmc had gone to these days.  It appears he's working on servo and rust at mozilla.
10:07:16 <joe9> dmj`: this is the output: http://codepad.org/KgXqFoRp , program: http://codepad.org/xFdQ6ZqR
10:07:23 <bjz> c_wraith: he is
10:07:47 <joe9> I am sure the signal is getting called. But, the MVar value read in the main program is not being updated though.
10:08:10 <bjz> c_wraith: I saw him at the office ^_^
10:08:19 <c_wraith> bjz: :)
10:08:41 <bjz> the more haskellers on Rust the better
10:08:45 <c_wraith> I agree.
10:09:12 <bjz> He does more servo work than the language side of things though
10:09:15 <c_wraith> Rust is showing a lot of promise, but a bit more inspiration from haskell (higher-kinded abstraction facilities, in particular) would help it a bunch.
10:09:30 <bjz> yeah
10:09:32 <bjz> I agree
10:09:58 <cite-reader> They want higher-kinded types, if I recall correctly, they're just not blocking 1.0 on it.
10:10:01 <shapr> yay code?
10:10:35 <c_wraith> cite-reader: last I saw, it was more split than desired - too many people involved don't see the value, so it's not a priority.
10:15:19 <joe9> what is the recommended approach to update state in a signal handler?
10:17:14 <steffen`> what do I have to do, that ghc can see a C library in /usr/include/somedir/lib.h? (I get 'undfined reverfrence to c_function', I use FFI)
10:17:29 <joe9> It looks like I am missing a takeMVar. sorry about that?
10:18:42 <merijn> joe9: I was just about to point that out :)
10:18:55 <merijn> joe9: Also, if you don't intend to take and block on empty, consider using IORef?
10:19:27 <merijn> joe9: Your signal handler is currently blocking trying to write to a full MVar and failing :)
10:20:56 <joe9> merijn, How do you know that it is failing? (I am trying to learn, maybe I could catch or output that failing)
10:23:31 <osa1> I installed some libs in a sandbox, can I somehow make ghc to use those libs? by modifying some env variables or sourcing some premade shell script etc.
10:25:34 <merijn> joe9: How do *I* know or how does one in general know?
10:26:13 <bam365> osa1: I would create a .cabal file for your project and then use cabal instead of ghc/ghci
10:26:32 <merijn> joe9: I know because I never see a "takeMVar" in your code ;) It's hard to detect blocking like this, unless you somehow start working with timeouts
10:26:34 <joe9> merijn: sorry did not mean to phrase it as a personal question.
10:26:53 <joe9> merijn: I am just trying to figure out how I can know it in the program.
10:27:16 <merijn> joe9: You can use tryTakeMVar and tryPutMVar which are unblocking
10:27:20 <ew0000> people, I'm reading some json strings with Aeson, but now I have 2 jsons with the same field. This makes GHC spit this: Multiple declarations of ‘part_number’
10:27:26 <ew0000> is there a way to save me?
10:27:53 <joe9> merijn: quick question, Would you recommend to stick with MVar or will it be easier to use TVar or some other mechanism here?
10:27:53 <merijn> joe9: THey return Maybe/Bool instead of blocking
10:28:07 <hexagoxel> steffen`: undefined references are linker errors, right? so the header file is probably not the problem, but linking the .so file (?)
10:28:10 <Algebr> the application exectuable says that it listens to 0.0.0.0:<somePort>, but in production, does it listen on that port as well? I'm unclear about this.
10:28:31 <merijn> joe9: If you have state that is only ever updated (i.e. you don't care about atomicity complex, just overwriting) I'd just use IORef
10:30:29 <hexagoxel> osa1: "cabal exec" allows you to run commands with the necessary environment variables set
10:30:41 <jollygood> why doesn't this print "hello" when I compile source file?  x = $([e| unsafePerformIO $ do putStrLn "hello"; return 2 |])
10:31:08 <jollygood> it is printed when I evaluate x.. so I don't see what difference template haskell made there?
10:31:49 <merijn> jollygood: There's a runIO function for TH
10:32:04 <merijn> jollygood: unsafePerformIO is, as always, unreliable
10:33:45 <joe9> merijn: thanks, let me read up on IO Ref.
10:34:27 <osa1> hexagoxel: right but cabal repo is in a different directory so I'd like to permanently set those variables otherwise my commands will get very long
10:40:24 <hexagoxel> osa1: there is a way to link cabal sandbox (called shared sandbox), but then you still would need to use cabal in the target. otherwise,
10:40:56 <hexagoxel> just compare the differences of "set" and "cabal exec -- sh -c set"
10:41:32 <hexagoxel> to find out which env variables exactly are set
10:42:16 <osa1> hexagoxel: awesome. that worked. thanks
10:42:26 <osa1> so the variable was GHC_PACKAGE_PATH
10:42:45 <osa1> I actually searched for an argument for that in man(1) but couldn't find anything
10:42:58 <osa1> I found -l -L etc. but they didn't work
10:43:14 <steffen`> hexagoxel: thank you, so I have to tell ghc where to find the so file right? or how can I fix the problem?
10:44:27 <hexagoxel> steffen`: right; but sorry, i have no idea how to do that
10:45:09 <steffen`> hexagoxel: okay, I'll find it out :) thank you
10:57:11 <McManiaC> phantom types: is there any way around this code? http://puu.sh/b8MWj/ac4af76711.png
10:57:44 * hackagebot charsetdetect-ae 1.0 - Character set detection using Mozilla's Universal Character Set Detector  http://hackage.haskell.org/package/charsetdetect-ae-1.0 (ArtyomKazak)
10:57:49 <conubiaac> test
10:58:38 <merijn> McManiaC: unsafeCoerce, but you're probably better of never writing that in your source :)
10:59:21 <McManiaC> hm :/
10:59:29 <McManiaC> guess i'll leave it like that
11:02:05 <t7> :t String -> Text
11:02:06 <lambdabot> parse error on input ‘->’
11:02:11 <t7> @hoogle String -> Text
11:02:13 <lambdabot> Data.Text.Lazy pack :: String -> Text
11:02:13 <lambdabot> Data.Text pack :: String -> Text
11:02:13 <lambdabot> Prelude read :: Read a => String -> a
11:09:07 <bam365> McManiaC: I think you could also abbreviate that code by testing for only AddAttribute and AddCustomAttribute and using a catch-all to pass through the rest
11:09:20 <bam365> but then of course the compiler couldn't help you if you added new MarkupM's
11:10:14 <McManiaC> bam365: no, i have to use a "new" type constructors, otherwise the phantom type will be the same
11:10:30 <bam365> oh right, nvm
11:13:07 <carter> McManiaC: not true
11:13:22 <carter> if you use ghc 7.8, you can use the safe coerce primitive
11:13:34 <carter> OR you could make a custom "cast" on the indices
11:13:49 * carter that internally uses unsafeCoerce
11:13:58 <McManiaC> safe coerce?
11:14:52 <carter> http://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/GHC-Prim.html#g:26
11:15:53 <carter> McManiaC: the docs are slightly wrong, I don't think you EVER have to write an instance
11:16:10 <carter> its that having the constructor in scope grants you the "instance"
11:17:04 <merijn> carter: Well, having a phantom type is kinda useless if it's not nominal, no?
11:17:05 <McManiaC> carter: oh sweet
11:17:09 <monochrom> safeCoerce :: a -> Maybe b; safeCoerce _ = Nothing :)
11:17:11 <carter> merijn: whys that
11:17:14 <merijn> carter: Which would mean it can't be safeCoerced
11:17:21 <carter> merijn: why would i want it to be nominal?
11:17:53 <carter> nominal would mean theres a change in internal rep / invariants when i vary the index
11:17:55 <carter> not so in this case
11:17:58 <carter> or may other case
11:18:02 <merijn> hmm
11:18:02 <carter> merijn: you also didn't read the docs
11:18:05 <carter> i can tell
11:18:11 <carter> because the docs say quite the opposite :)
11:18:19 <merijn> I did, but months ago so I don't remember :)
11:19:01 <fread2282> is there a common name for flipped (.) that is shorter that 3 characters?
11:20:11 <merijn> So not >>> ?
11:20:25 <merijn> I wouldn't think so
11:20:37 <carter> why not make one up
11:20:41 <carter> like !.
11:20:42 <carter> :)
11:20:44 <merijn> :t (Control.Category..)
11:20:45 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
11:20:49 <carter> oh
11:20:51 <joe9> Any comments on this program, please? http://codepad.org/5pwWwf8K
11:20:55 <merijn> Nope, not that either :)
11:20:58 <joe9> merijn: I got it working using the above
11:21:09 <carter> joe9: indet more?
11:21:10 <carter> :)
11:21:23 <joe9> carter: ok, thanks.
11:21:24 <McManiaC> fread2282: & is used in lens
11:21:27 <monochrom> > let a » b = a . b in (id » id) True
11:21:28 <lambdabot>  <hint>:1:7: lexical error at character '\187'
11:21:33 <monochrom> to bad
11:21:37 <fread2282> McManiaC: & is flipped $
11:21:47 <carter> joe9: mind you ,  i do shallow indents in my complicated codes
11:21:59 <McManiaC> fread2282: true
11:22:14 <fread2282> merijn: too long for use as a replacement for (.)
11:22:29 <monochrom> > let a → b = b . a in (id → id) True
11:22:30 <lambdabot>  <hint>:1:7: parse error on input ‘→’
11:22:38 <monochrom> that's too bad too
11:23:06 <Mysterious> searching for unusual characters for infix operators?
11:24:39 <t7> @hoogle ([a] -> (a, [a])) -> [a] -> (a, [a])
11:24:40 <lambdabot> No results found
11:24:45 <t7> :t unfold
11:24:46 <lambdabot>     Not in scope: ‘unfold’
11:24:47 <lambdabot>     Perhaps you meant one of these:
11:24:47 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
11:24:49 <t7> :t unfoldr
11:24:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:25:08 <fread2282> I'd like a usual character
11:25:25 <fread2282> ideally |, but that's not a valid operator :|
11:29:23 <josephle> I would've proposed HoTT's path concatenation operator "@", but that's not valid too :(
11:29:47 <josephle> ...or is it?
11:30:17 <josephle> nope, it's not :(
11:30:19 <freetip> visit   http://tinyurl.com/p5bpscx    soccer tips
11:34:53 <oisin7888> I have a function with a signature of ... -> IO (). Inside the function I want to run fmap (a -> ()) m a where m isn't the IO monad. It seems that fmap expects it to be, though. Is there some way to alleviate this?
11:34:59 <haasn> josephle: @ is reserved for at-patterns
11:35:08 <josephle> yeah, I just remembered
11:36:10 <RchrdB> oisin7888, put your code on lpaste.net please?
11:36:39 <RchrdB> oisin7888, the type of fmap's result will be inferred depending on where you use it.
11:36:51 <oisin7888> RchrdB: It's a bit messy: http://lpaste.net/110074 The fmap in question is the giant function in the middle.
11:37:23 <RchrdB> Okay. What Monad instance do you want that to run in?
11:37:36 <oisin7888> RchrdB: I'm not sure if I should say QuadTree or Functor
11:37:56 <RchrdB> Functor isn't an instance, it's a typeclass.
11:38:08 <RchrdB> mm
11:38:33 <oisin7888> RchrdB: Then, I believe this: http://hackage.haskell.org/package/QuadTree-0.10.0/docs/Data-QuadTree.html
11:38:34 <RchrdB> Okay so on line 14, you write "fmap f x", where x = quadtree, and f is that big function
11:38:52 <oisin7888> Right
11:38:55 <RchrdB> you've put that fmap on a line by itself in the middle of an IO 'do'.
11:39:11 <RchrdB> so Haskell infers that the result of that fmap must be an IO ().
11:39:32 <RchrdB> er, it infers that it must be (IO a), because you don't bind the result anywhere.
11:40:26 <RchrdB> oisin7888, so you want to either "let someIdentifier = fmap f x", if f is pure, or "runSomething $ fmap f x" instead.
11:40:50 <RchrdB> where runSomething is some function with a type like F a -> IO a
11:41:25 <nateb> Is there a go-to typeclass whose interface is basically (empty :: f a, pure :: a -> f a)?
11:41:47 <monochrom> Alternative has them, but also other things.
11:41:47 <RchrdB> which GL library are you using, Graphics.Rendering.OpenGL?
11:42:03 <oisin7888> RchrdB: OpenGLRaw - sorry I'm just trying to understand the last bit
11:43:23 <nshepperd> what's the type of 'quadtree' here
11:43:47 <oisin7888> nshepperd: http://hackage.haskell.org/package/QuadTree-0.10.0/docs/Data-QuadTree.html
11:44:18 <nshepperd> it's a QuadTree?
11:44:37 <oisin7888> nshepperd: Yep, although I want to iterate over all the leaves
11:45:16 <nateb> monochrom: okay, I looked at Alternative... as you said it comes with other things.  Is that pretty much the only... alternative?
11:45:43 <monochrom> heh, yes, as far as wide-available typeclasses are concerned
11:46:35 <nateb> Fair deal, thanks!
11:46:52 <nshepperd> okay, but you want to do an IO action on each leaf it looks like
11:47:24 <oisin7888> nshepperd: Yes
11:47:27 <RchrdB> oisin7888, oh! your (\(Just chunk) -> ...) function probably has type (a -> IO ()), given which GL library you're using.
11:47:51 * hackagebot combinat 0.2.6.1 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.6.1 (BalazsKomuves)
11:47:56 <RchrdB> You can use the Foldable instance.
11:48:05 <nshepperd> oisin7888: I think you want mapM_ from Foldable
11:48:34 <oisin7888> :t mapM_
11:48:35 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:48:40 <oisin7888> I think I want fmapM_
11:48:44 <oisin7888> Or something like that
11:48:55 <nshepperd> :t Foldable.mapM_
11:48:57 <lambdabot> Not in scope: ‘Foldable.mapM_’
11:48:58 <RchrdB> There's a different one.
11:49:02 <nshepperd> :t Data.Foldable.mapM_
11:49:03 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
11:49:04 <RchrdB> Data.Foldable.mapM_ :: (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
11:49:10 <oisin7888> Oh :)
11:49:21 <bam365> oisin7888: in this case, forM_ might be nicer
11:49:27 <bam365> it's just mapM_ with args switched
11:49:49 <nshepperd> mapM_ (\(Just chunk) -> ...) quadtree
11:50:09 <RchrdB> forM_ quadtree (\(Just chunk) -> ...)
11:50:23 <nshepperd> or that L)
11:50:24 <bam365> since the function is so long, forM quadtree $ \(Just chunk) -> ...
11:50:48 <oisin7888> Awesome - I'm going to use forM_. Thank you all for helping!
11:51:14 <nshepperd> types are so handy
11:54:31 <oisin7888> nshepperd: I agree! Sometimes I try to flesh out something with a lambda and fmap before pulling it into a function - but sometimes it blows up :D
11:58:54 <sm> does the GHC 7.8 binary for linux include cabal-install these days ?
11:59:24 <carter> sm: no
11:59:33 <carter> but you CAN dl one from the cabal site
11:59:50 <sm> ah, thanks
12:00:59 <gdoteof> i have ->>   map (\a $(staticFiles a)) staticFolders
12:01:11 <gdoteof> and i am getting     Couldn't match type `[Language.Haskell.TH.Syntax.Dec]' with `Exp'
12:01:41 <carter> gdoteof: add a space
12:01:46 <carter> after the $ and before the (
12:01:49 <carter> :)
12:02:43 <gdoteof> where staticFolders is an [FilePath] and staticFiles is ->> FilePath -> Q [Dec]
12:02:47 <gdoteof> carter: are you teasing me?
12:03:17 <athan> gdoteof: maybe (\a -> ... ?
12:03:38 <gdoteof> i get parse error on input $ .. but that changes the template haskell uh.. unpacking to just a `$` operator
12:03:41 <athan> gdoteof: Are you working with yesod?
12:03:47 <gdoteof> athan: yes
12:04:07 <carter> gdoteof: i'm telling you how to fix it
12:04:08 <athan> yeah I think you need the ->, that's all
12:04:08 <carter> do it
12:04:12 <athan> DO ITTT
12:04:16 <carter> oh
12:04:23 <carter> you' deliberately using TH?
12:04:24 <carter> nvm
12:04:25 <carter> :)
12:04:26 <athan> yeah, it's TH carter :P
12:04:29 <athan> hahah
12:04:36 <carter> i thought it was "accidental TH"
12:04:38 <gdoteof> the default static subsite is making identifiers for all my npm workflow stuff
12:04:43 <carter> hence $ *
12:04:48 <gdoteof> makes sense
12:04:53 <gdoteof> uhh.. the arrow is there in my code
12:04:59 <gdoteof> idk why its not coming through
12:05:10 <gdoteof> oh.. i typed it :P
12:05:15 <gdoteof> map (\a -> $ (staticFiles a)) vmxStaticFolders
12:05:28 <gdoteof> that's what it is now with the space ia dded for carter
12:05:34 <athan> hmm
12:05:48 <athan> where is vmxStaticFolders defined?
12:06:02 <athan> i don't think this will work
12:06:12 <athan> hmm
12:06:19 <gdoteof> athan: if youa re familiar with yesod scaffolding, i have it in the settings.hs
12:06:26 <gdoteof> and this code is 'top level' in StaticFiles.hs
12:06:37 <gdoteof> which, i am not surprised if it doesn't work
12:06:50 <gdoteof> but it seems like there must be a way to map over TH?
12:07:07 <athan> gdoteof: Well, you see
12:07:17 <athan> TH is the haskell AST
12:07:24 <athan> er, something similar anyway
12:07:47 <athan> so you can really only map over haskell types, not the AST (unless, that's what you were trying to do :S)
12:07:53 <athan> yesod can be a pain
12:08:00 <jude> is there a better/right'r/builtin way to do?
12:08:00 <jude> map (:[]) "list"
12:08:28 <gdoteof> athan: i am trying to take a [FileType] and for each one, apply a TH $()
12:08:58 <athan> gdoteof: Read into TH :/ it's not that simple
12:09:12 <shachaf> jude: That way seems pretty good.
12:09:36 <shachaf> You can use pure/return instead of (:[]) but I don't know that that's an improvement.
12:10:03 <jude> k, i was just wondering if i was overlooking some sort of builtin way of doing the
12:10:03 <jude> map (:[])
12:10:35 <athan> dcoutts_: I might have a pretty crazy cabal bug in an hour or so, if you're interested :D
12:10:53 <jude> thanks shachaf
12:11:00 <athan> jude: (\a -> [a]) might be clearer :/
12:11:11 <athan> to show it's a singleton per character
12:11:16 <carter> so i was right?
12:11:27 <athan> carter: No!... maybe...
12:11:35 <carter> time will tell
12:11:36 <carter> :)
12:11:50 <athan> =V
12:13:08 <athan> It sucks how closely tied nearly all results are to serving them, in yesod I mean
12:13:22 <jude> thanks athan yea you are probably right
12:13:23 <athan> I can't look into any HandlerT, ResourceT, WidgetT, nothing...
12:13:42 <athan> without it being explicitly served over http :S
12:14:15 <athan> jude: No prob! :)
12:23:47 <Xechas> I have a question about Control.Monad.Catch. I am trying to use a WriterT to record exceptions and then use throwM to rethrow the exception. When I do this, the exception never gets written. Even if I try running `tell undefined` followed by throwM, I only get the exception raised by the throwM. Any idea why this is happening?
12:25:56 <pablo|> Xechas: can you post the code?
12:27:26 <daimonos> When cabal repl compiles the files in the directory where are these compiled packages stored? Because when I quit from the repl I can't see the compiled executables.
12:27:44 <Xechas> tell undefined
12:27:45 <pablo|> Xechas: you could try to reorder the monads in your stack.. may be that
12:27:51 <daimonos> Like where are the files that cabal repl compiles stored?
12:28:01 <daimonos> Because after I quit I can't see them.
12:28:17 <daimonos> I can see .o  and .hi in /build but that's it.
12:35:14 <geekosaur> daimonos, cabal repl is ghci and it compiles in memory to bytecode
12:35:17 <geekosaur> it is not saved
12:35:41 <geekosaur> and if it were, you couldn't do anything with it because there is no facility to load bytecode
12:53:29 <steffen`> is there a way to dertermine the type of something without the Prelude, meaning like a breakpoint in a file?
12:54:11 <steffen`> kind of like telling ghc: when you hit this line, abort and tell me the type of that expression" ?
12:54:19 <c_wraith> why at runtime?
12:54:26 <steffen`> no at compiletime
12:54:27 <c_wraith> The type never changes
12:54:29 <c_wraith> Ah.
12:54:33 <c_wraith> What version of GHC?
12:54:49 <steffen`> 7.8.2
12:55:11 <c_wraith> you should probably upgrade to 7.8.3, since 7.8.2 had some bad bugs.  But that's not relevant here.
12:55:24 <steffen`> okay :)
12:55:40 <c_wraith> Just insert any undefined name into the code you want to know more about
12:56:01 <c_wraith> _ is a good choice
12:56:19 <c_wraith> The compiler will give you a message including the types of the various names in local scope
12:56:36 <steffen`> okay, I'll try that
12:57:30 <steffen`> mhm I'll only get "not in scope"
12:57:36 <steffen`> I guess I'm doing it wrong
12:57:55 <c_wraith> Ok, let me make sure I'm telling the truth about how that feature works. :)
12:58:10 <steffen`> xD don't worry
12:58:13 <sm> it needs to be _ right
12:58:59 <c_wraith> Ah.  It needs to *start* with _
12:59:16 <c_wraith> it can be just _ or it could be _foo, or whateverr.
12:59:49 <bergmark> i just realized the other day that you can do _foo and not just _
13:00:30 <sm> and that's good if.. you have a lot of holes in your code at the same time ?
13:00:47 <Mokosha> #join snap-framework
13:00:50 <Mokosha> whoops
13:01:02 <bergmark> sm: yes
13:01:59 <alorente> Mokosha: #snapframework
13:02:45 <c_wraith> steffen`: http://lpaste.net/110080
13:07:02 <steffen`> c_wraith: ahh, got it :)
13:07:07 <steffen`> c_wraith: thanks
13:07:27 <c_wraith> steffen`: you're welcome.  Sorry I got the description wrong the first time. :)
13:08:06 <steffen`> c_wraith: Or it was me, when I read it now, it makes sense :)
13:09:14 <gratatatata> whats a good setup for coq + vim?
13:10:44 <merijn> gratatatata: Coquille
13:11:10 <merijn> gratatatata: https://github.com/the-lambda-church/coquille don't forget to read the README, you need another plugin too
13:11:46 <merijn> gratatatata: And these bindings are nice (especially the . to update proofs while typing): https://github.com/merijn/dotfiles/blob/master/vim/ftplugin/coq.vim
13:15:50 <gratatatata> ah thanks merijn
13:21:02 <merijn> How does Ralph Lämmel's solution to the expression problem (http://userpages.uni-koblenz.de/~laemmel/TheEagle/resources/pdf/xproblem1.pdf) compare to Swierstra's (http://www.staff.science.uu.nl/~swier004/Publications/DataTypesALaCarte.pdf), in terms of performance?
13:27:10 <latk> I'm in a situation where I need something like Either, except with three options. Is this a sign that I should try and find a different way to solve the problem, or is there some way of doing this /
13:27:24 <vanila> Either a (Either b c)
13:27:29 <vanila> or define a new data type
13:28:24 <johnw> data Tri a b c = A a | B b | C c
13:28:25 <latk> vanila: Yeah, I'm currently using Either a (Either b c), but it feels a bit cumbersom..
13:28:34 <geekosaur> latk: usually it's a sign that you want an application specific ADT. Either is convenient but even there it's often better to do your own
13:29:38 <latk> johnw: Yeah, that will work!
13:29:46 <latk> geekosaur: I'll have a go at doing just that.
13:30:54 <geekosaur> it's like tuples, sometimes convenient for bundling unrelated things together but often you want to help Haskell help you by using appropriate types in appropriate places so it can catch you when you do something wrong by mistake
13:32:29 <merijn> No opinions on the expression problem stuff? (Alternatively, I'd be interested in a nice approach to do Entity-Component in Haskell, but I guess that and expression problem are mostly isomorphic)
13:33:03 <johnw> merijn: that was a lot of reading material :)
13:36:53 <codile> !help
13:36:55 <codile> hmm
13:36:57 <codile> ;help
13:36:59 <codile> $help
13:37:10 <johnw> do you need some help?
13:38:21 <codile> yeah
13:38:25 <johnw> what with?
13:38:31 <codile> how does quickcheck work with lambdabot?
13:39:07 <bennofs> @check \x -> x + 1 == x
13:39:09 <lambdabot>  *** Failed! Falsifiable (after 1 test):
13:39:10 <lambdabot>  0
13:39:12 <bennofs> @check \x -> x + 1 == x + 1
13:39:13 <lambdabot>  +++ OK, passed 100 tests.
13:39:18 <bennofs> codile: ^^^
13:39:35 <codile> ah, cool. thank you :)
13:40:18 <nkhodyunya> http://puu.sh/b93Lj/9954f8a5c9.png Can someone explain please what's the purpose of while function? I've implemented it, but can't do anything useful with it because i have no idea how to make such IO Bool that will contain True or False depending on some condition. Hope this doesn't sound nonsense.
13:40:24 <gratatatata> hey merijn have you used coquille on windows?
13:40:52 <johnw> nkhodyunya: just use "return True"
13:41:03 <dolio> Discussions of coq would probably be more appropriate for #coq.
13:41:19 <johnw> nkhodyunya: although, that will cause an infinite loop, so maybe not...
13:42:05 <nkhodyunya> johnw: yes, this is where i get stucked. I get either an infinite loop or exactly 1 iteration.
13:42:24 <johnw> you could based it on a value of time
13:42:34 <johnw> so, take a start time, then loop for at most 60 seconds
13:42:43 <johnw> where your conditional will keep checking the time
13:44:05 <codile> quicktest proves to be useful even for math :P
13:44:44 <pavonia> nkhodyunya: Think of  fmap (== "END") getLine
13:44:50 <nkhodyunya> johnw: I need some actual code hint here
13:45:32 <johnw> start <- currentTime ; while ((< start + 60) <$> currentTime) (...)
13:45:38 <johnw> not syntactically correct, but that's the essence
13:46:30 <cpennington> merijn: Are there implementations of both of those? Perf performance seems hard in absence of something a bit more concrete
13:47:09 <nkhodyunya> Thanks guys, this helps.
13:48:05 * hackagebot haskell-neo4j-client 0.2.0.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.0.0 (asilvestre)
13:49:36 <pyon> I have just read http://brianmckenna.org/blog/type_annotation_cofree , which is a neat approach to uniformly annotating each node of a tree. (In this case, the type of every subterm of a syntax tree.) However, this only works if the annotations are always of the same type, regardless of the node being annotated. Is there any way to make different types of annotation depending on the node being annotated?
13:49:38 <frerich> nkhodyunya: You could also do something like ‘while (fmap (/= “quit”) getLine) foo’ which will execute ‘foo’ until ‘quit’ is entered.
13:52:17 <Nopik> hi, haskell newbie here.. i have this function: http://pastebin.com/Rd9A8anD  which apparently returns correct results for some input (e.g. [1,2,3]), but skips one element for other inputs (e.g. [2,1,3] returns only 2 elements).. any idea why?
13:53:06 <Nopik> I'm trying to debug this, but I fail miserably
13:53:09 <pyon> Nopik: What is your program supposed to do to begin with?
13:54:24 <Nopik> pyon: well, I have a list of numbers from 1 to N, I want to have list of positions of those numbers. I.e. if 1 is on 5th place in the input, i want to have 5 as first element on output
13:54:54 <Nopik> the implementation is naive, I know, most likely there is way better (at least O(n) instead of O(n^2)) algorithm
13:55:07 <pyon> Nopik: What if there are duplicated elements in the original list?
13:55:14 <Nopik> pyon: there is none
13:56:47 <Nopik> in C I would have something like for( int i=0;i<n;i++ ) { res[ input[ i ] ] = i; }
13:57:20 <codile> @check \x -> 0.5*(x-3)+(1.5-x) == 0.5*x - 1.5 + (1.5 - x)
13:57:22 <lambdabot>  +++ OK, passed 100 tests.
13:57:37 <codile> @check \x -> 0.5*(x-3)+(1.5-x) == 0.5*x - 1.5 + 1.5 - x
13:57:39 <lambdabot>  *** Failed! Falsifiable (after 29 tests and 1070 shrinks):
13:57:40 <lambdabot>  5.0e-324
13:57:41 <codile> this is so weird
13:58:00 <codile> why do the parenthesis make a difference?
13:58:08 <pyon> codile: Because floating point arithmetic is not exact.
13:58:15 <codile> oh, okay
13:58:22 <codile> thanks
13:58:32 <josephle> I think floating point arithmetic does not respect associativity
13:58:40 <codile> hmm
13:58:43 <pyon> @info Rational
13:58:43 <lambdabot> Rational
13:58:48 <pyon> @kind Rational
13:58:50 <lambdabot> *
13:58:54 <dolio> Yes. It is commutative but not associative.
13:59:00 <pyon> @check \x -> 0.5*(x-3)+(1.5-x) == (0.5*x - 1.5 + 1.5 - x :: Rational)
13:59:01 <codile> @check \x -> 1%2*(x-3)+(1.5-x) == 1%2*x - 1.5 + 1.5 - x
13:59:01 <lambdabot>  +++ OK, passed 100 tests.
13:59:03 <lambdabot>  +++ OK, passed 100 tests.
13:59:03 <codile> aha
13:59:11 <codile> so that's how it works
13:59:27 <Nopik> pyon: any idea how my function may result in one element being skipped? it seems that the element where 1 is on the input is ignored, only if 1 is not at start
14:00:17 <Nopik> and since this is my first haskell approach after very short 'adventure' many years ago I dont know anything ;(
14:00:56 <pyon> Nopik: Your "take-and-drop" approach seems to assume that the rest of the whole list has already been constructed.
14:01:42 <Nopik> hm
14:02:33 <pyon> Nopik: For example, what happens if the list begins with 5?
14:02:38 <pyon> Nopik: res is initially []
14:03:03 <pyon> Nopik: You want to insert an 1 (the initial value of "pos") at the position 5 in the empty list.
14:03:10 <pyon> Nopik: Which is... well... not possible.
14:03:22 <Nopik> pyon: this is it, thanks
14:07:12 <sm> wow, codeworld is awesome
14:07:19 <sm> lots of things coming together in haskell-land
14:08:02 <latk> Uh, stupid question - what is that syntax involving an @ to keep the whole list when pattern matching (e.g. (x:xs)) ?
14:08:15 <c_wraith> xxs@(x:xs)
14:08:18 <latk> ..doh
14:08:24 <latk> c_wraith: thanks :p
14:08:30 <c_wraith> the @ binds as tightly as possible
14:08:52 <c_wraith> So you need the parens around the whole application of the constructor.
14:23:11 * hackagebot memcached-binary 0.1.0 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.1.0 (HirotomoMoriwaki)
14:23:13 * hackagebot bytestring-conversion 0.1 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.1 (ToralfWittner)
14:23:15 * hackagebot memcached-binary 0.1.0.1 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.1.0.1 (HirotomoMoriwaki)
14:28:12 * hackagebot wai-predicates 0.8 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.8 (ToralfWittner)
14:28:14 * hackagebot wai-routing 0.10 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.10 (ToralfWittner)
14:29:43 <Nopik> now, I'm suspecting that something is wrong with my haskell installation, but maybe I'm doing just something wrong. When I'm trying to add e.g. 'import Data.List' line to my program, ghc (called as this: ghc foo.hs -o foo) says that 'Failed to load interface for List.Data'. Is that normal? e.g. do I need to call ghc in a different way, or my installation is
14:29:44 <Nopik> broken?
14:32:28 <c_wraith> Nopik: sounds suspicious.  My first question though is where the typo came from..  "List.Data" isn't a module in a standard library.
14:32:49 <Nopik> I mean, Data.List
14:33:21 <c_wraith> Just so long as you transcribed the error message incorrectly, instead of had an error in the code. :)
14:33:34 <c_wraith> Nopik: run "ghc-pkg check"
14:33:35 <Nopik> yes, the error is only on the irc ;)
14:34:01 <Nopik> ghc-pkg check ran for a second, then quit without printing anything
14:34:09 <Nopik> echo $? gives 0
14:34:13 <c_wraith> Ok, that means it didn't detect an error
14:34:19 <c_wraith> If it had, it'd produce output
14:34:26 <c_wraith> But it doesn't detect everything broken
14:34:39 <c_wraith> Does "ghc-pkg list" give you a big list of packages?
14:34:56 <Tuplanolla> How about :m + Data.List in GHCi?
14:35:44 <Nopik> c_wraith: probably not: http://lpaste.net/110084
14:36:12 <Nopik> oh, in ghci it works (:m + Data.List)
14:36:13 <c_wraith> Nopik: that's expected output, but *wow* is that an old version of GHC
14:36:21 <bmuk> I now have access to a large database of research papers through my university. Are there any gems related to haskell/functional programming I should search for that aren't publicly available?
14:36:33 <Nopik> c_wraith: I can't even remember how many years ago I've installed it :)
14:36:35 <c_wraith> yeah, it looks like your version of GHC predates when you could just say "import Module" in GHC
14:36:38 <c_wraith> err, in ghci
14:38:00 <Nopik> trying to upgrade it now, but it might end in bigger disaster ;)
14:38:02 <RchrdB> Nopik, you couldn't write "import Module" in GHCi until about version 7.something; GHC 6.10 was released in late 2008.
14:38:14 * hackagebot tinylog 0.10.3 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.10.3 (ToralfWittner)
14:38:22 <Nopik> RchrdB: what was the syntax befor ghc 7?
14:38:29 <Nopik> *before
14:38:30 <c_wraith> it was the :module stuff
14:38:34 <c_wraith> or :m for short
14:38:34 <RchrdB> You had to use ":m Module" when in GHCi.
14:38:43 <Nopik> and when in *.hs file?
14:38:51 <RchrdB> "import Module", as it should be.
14:39:06 <Nopik> no luck for me, then
14:39:15 <RchrdB> The fact that it was different between GHCi and *.hs files was a bug that was removed in a later version.
14:39:49 <RchrdB> What is your computer? I expect you ought to be able to get a newer version of GHC somehow.
14:40:18 <Nopik> RchrdB: I'm on mac, doing brew install ghc now, installed a number of deps already, now downloading ghc 7.6.3
14:40:44 <RchrdB> Cool, that's a reasonably modern GHC.
14:40:55 <RchrdB> Where did you even get the 6.10 version from?
14:41:16 <c_wraith> RchrdB: installation many years ago, I think
14:41:37 <Nopik> I think I've installed this ghc around 2010, on a different mac. Then when purchased this one, I've migrated everything. Mac migration between machines works awesomely, but I wouldn't be surprised if it would break something in ghc (so far it works, though)
14:41:49 <Nopik> it could be 2008 or 2009 too, though
14:41:55 <Nopik> didn't touched it since
14:42:00 <RchrdB> Oh that makes perfect sense.
14:42:23 <RchrdB> I was worrying that maybe someone had accidentally misled you into installing an ancient version. ;)
14:42:56 <Nopik> nah, I wouldn't do that without really good reason ;)
14:43:15 * hackagebot mangopay 1.8.2 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.8.2 (FelipeLessa)
14:43:33 <RchrdB> It's not unheard of for Google to accidentally pick out some really bizarre and random page on a given website for a common search query. :)
14:45:19 <gregnwosu> hi im getting an issue when installing ghc-mod, its saying "cannot find -lHScpphs-1.18.5-ghc7.8.3.220140804"
14:45:33 <magicman> ... I still :m things out of habit >_<
14:45:38 <gregnwosu> but i see cpphs folder in my .cabal/lib
14:46:20 <Nopik> yay, it works :)
14:46:30 <Nopik> thanks guys
14:48:16 * hackagebot mangopay 1.9.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.1 (FelipeLessa)
14:49:24 <nomeata> Hi. Is there a way to link libgmp statically, but not other libs (like libpq)?
14:50:03 <Nopik> is Data.List.Split a standard package? I can now import Data.List, but not Data.List.Split
14:50:55 <Peaker> Nopik: cabal install split
14:56:09 <heiz> Hello! I cant find in mtl-2.0.1.0 sources any monad transformer definition e.g. "newtype StateT s m a". (https://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-State-Lazy.html#t:StateT) In what file I can find this definition?
14:56:36 <Nopik> Peaker: ok, thanks
14:56:55 <Peaker> heiz: it's imported from the transformers package
14:58:17 * hackagebot bytestring-conversion 0.1.1 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.1.1 (ToralfWittner)
15:04:38 <joe9> need some advice, please? I have 3 signal handlers. The main loop signalWait's for the next signal to arrive, and, does some processing based on the signal. I tried with 3 different MVar's, one for each signal handler. But, before I do signalWait, I have no way of knowing if any signal just arrived.
15:05:15 <joe9> I cannot use just 1 MVar for all 3 signal handlers, as, I could probably block up any other signal handlers that might fire.
15:06:20 <joe9> Is there a block'ing queue-like data structure for this kind of communication?
15:07:51 <geekosaur> sounds like you want a Chan to me
15:08:24 <Peaker> joe9: another option I really like is atomicModifyIORef
15:08:30 <geekosaur> MVar's pretty low level; most times when people think they want an MVar, they actually want Chan
15:08:55 <joe9> geekosaur: thanks. let me check on Chan. Any tutorials that you would recommend?
15:09:00 <Peaker> geekosaur: MVar has the nice property of synchronizing the threads' rates simply by being bounded
15:09:58 <luite> hmm, in most of my use cases i don't want an unbounded chan
15:10:40 <geekosaur> there are limited implementations on hackage as well
15:10:47 <geekosaur> but MVar is usually a bit too low level
15:11:21 <SrPx> What exactly is the difference of the colon and the `|-` in http://imgur.com/DwEo67f ?
15:11:57 <yyttr3> Does anyone know if there is a complementary answer book to Spivak's Category theory for Scientists?
15:13:02 <yyttr3> Even partial answers would be nice, I just want to know if i'm doing anything right.
15:13:19 * hackagebot tinylog 0.10.4 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.10.4 (ToralfWittner)
15:13:41 <nomeata> With a cabal sandbox, how do I run "ghc" with this sandbox active?
15:13:55 <josephle> SrPx: "A |- B" means "A entails B", while "x : t" means "x has type t"
15:14:18 <SrPx> josephle: damn I mean comma not colon, sorry
15:14:48 <Tuplanolla> Isn't it "and"?
15:14:50 <SrPx> for me, both `a |- b:t` and `a, b:t` are saying the same thing...
15:15:03 <bennofs> nomeata: ghc -package-db .cabal-sandbox/<some directory containing the system name (like x86_64-linux) and ghc version>
15:15:15 <josephle> SrPx: "," is basically list notation
15:15:26 <josephle> mainly used to create contexts (Gamma)
15:15:41 <josephle> Gamma ::= empty | Gamma, x:t
15:16:18 <SrPx> josephle: I don't get it. `C, x:t` means x has type t in context C. `C |- x:t` means x has type t in context C. What is the difference?
15:16:24 <josephle> so you'd parse the judgement in your link as "(Gamma, x: sigma) |- e : tau"
15:16:38 <shachaf> yyttr3: http://math.mit.edu/~dspivak/ says that the MIT Press version includes exercise solutions.
15:16:42 <triliyn> SrPx: "C, x:t" means "Context C extended with the assumption that x has type t"
15:16:44 <josephle> SrPx: that's not correct. "C, x:t" means you are extending context C with "x:t"
15:17:19 <nomeata> bennofs: ok, thx
15:18:26 <yyttr3> shachaf: I see, so it's not available free anywhere? Thank you.
15:19:13 <SrPx> Okay, so we can say that "if C, x:a |- y:b then C |- (λx.y):(a→b)` means pretty much "if in a context C extended with x:t, y has type b, then, in that same context *WITHOUT* x:a, then (λx.y) has type a→b" ?
15:19:33 <Tuplanolla> "Anywhere" is an overstatement, yyttr3.
15:20:06 <josephle> SrPx: that's right :)
15:20:28 <SrPx> So I get it now, thanks guys!
15:20:58 <yyttr3> Tuplanolla: Well, if you know of any sources I would be appreciative :)
15:21:21 <Tuplanolla> You should be able to come by shady digital libraries.
15:25:21 <yyttr3> Is the Hom_set(A,X) isomorphic to X is A is a singleton set?
15:25:39 <yyttr3> They would have the same cardinality
15:25:52 <yyttr3> if A is a singleton set*
15:39:46 <joe9> geekosaur: Chan is a very good idea. exactly what I need. Thanks a lot for that suggestion.
15:41:27 <josephle> yyttr3: this is very related to the notion of a generalized element
15:48:27 * hackagebot binary-list 0.3.1.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.1.0 (DanielDiaz)
15:53:10 <parc> is there anything wrong with the documentation for Data.Binary for deriving the Binary typeclass? I get "No explicit method or default declaration for `put' in the instance declaration for `Binary Foo'" when i try to use it
15:57:00 <pavonia> parc: Do you actually derive an instance?
15:57:05 <merijn> parc: Does your class derive Generic?
15:57:14 <merijn> eh
15:57:14 <merijn> s/class/datatype
15:57:34 <parc> i derive Generic, and then try to do "instance Foo Binary". i just tried copying the example they provide and got an error
15:58:12 <parc> import Data.Binary; import GHC.Generics (Generic); data Foo = Foo deriving (Generic); instance Binary Foo
15:58:39 <pavonia> That's just an instance declaration
15:58:54 <merijn> pavonia: Right, because he wants to use the generic implementation
15:59:03 <merijn> parc: Did you turn on -XDeriveGeneric ?
15:59:13 <merijn> Or whatever it's called
15:59:22 <pavonia> Hhm, maybe I misunderstand then
15:59:23 <parc> merijn: yeah
16:01:35 <cmccann> parc: do you have an outdated version of binary or one compiled without generics support?
16:01:46 <merijn> parc: This works for me: http://lpaste.net/110088
16:02:03 <merijn> parc: Which version of GHC/binary are you using?
16:02:07 <parc> cmccann: oh, that might be it. i'm using 0.5.1.1, i'll try updating
16:02:36 <cmccann> binary-0.5.1.1? yeah that's hella antique
16:03:23 <parc> yeah, i updated and it works now. thanks :)
16:05:01 <cmccann> welcome to haskell, where code goes from strange and new to trendy and popular to obsolete and broken in under two years
16:05:36 <merijn> cmccann: But the bleeding edge is so awesome! :(
16:06:18 <merijn> And it makes me sad when I can't use awesome stuff because it's too new :\
16:06:20 <jxv> cmccann, growing pains
16:07:17 <Tuplanolla> I wouldn't mind it breaking more often since it's a research language.
16:07:20 <cmccann> in haskell we don't do bleeding edge. we do the faint whisper of displaced air that precedes the blade.
16:08:56 <merijn> Just last night I got screwed over by GHC depending on binary 0.7.1, instead of 0.7.2
16:08:59 <merijn> :\
16:09:30 <bennofs> merijn: you're lucky that you can use such a recent GHC! I worked with ghc depending on binary 0.5 :/
16:12:19 <yyttr3> Is Hom_Set(A,X) isomorphic to X if A is a singleton set? It should be that |Hom_set(A,X)|=|X| in that case.
16:13:42 <josephle> yyttr3: yes, when we're in category Set
16:14:01 <yyttr3> That's what I thought, I just wasn't sure, thank you.
16:14:26 <yyttr3> I'm reading Spivak's category theory, and the free version doesn't have an answer set.
16:15:13 <josephle> so a cool result is you can consider an element in Hom_set(A,X) as a generalized element of X in Set
16:15:55 <merijn> bennofs: "lucky you can use such a recent GHC" <- I just decided not to support anything pre-7.8 :p
16:16:14 <yyttr3> josephle: What do you mean?
16:16:35 <cmccann> yyttr3: they're also isomorphic in Hask, as long you're consistent in accounting for bottoms
16:17:14 <josephle> yyttr3: the idea is that sometimes the morphisms from A -> X are more interesting than the elements of X
16:17:21 <yyttr3> cmccann: Is that not true of all categories?
16:17:26 <shachaf> This is true but also not a very CT-ish way of thinking about it.
16:17:34 <dolio> yyttr3: Correct.
16:18:05 <yyttr3> dolio: Can you give an example where that wouldn't be true?
16:18:24 <shachaf> Talking about an "element of an object" doesn't really make much sense (except if you say it's an arrow to that object).
16:18:43 <dolio> yyttr3: There is a category of monoids and monoid homomorphisms.
16:19:00 <Arunabha> Hi, I'm trying to defne a function to calculate the mean of a list (http://lpaste.net/110089) but I can't seem to get the type system to play ball. Both code and error are in the lpaste link. Any help is appreciated.
16:19:28 <dolio> Any singleton set has a monoid structure where the element is the unit element, and the binary operation is trivially determined.
16:19:49 <dolio> But, there is exactly one monoid homomorphism from such a monoid to any other monoid.
16:19:51 <josephle> shachaf: you're right, my claim is un-CTish
16:19:52 <cmccann> Arunabha: you need a fromIntegral on "sum lst" as well
16:20:13 <cmccann> and then probably more constraints in the type
16:20:26 <dolio> Or, more categorically, that sort of monoid is both initial and terminal in the category of monoids.
16:20:50 <josephle> yyttr3: it is enlightening if you think of A not as a singleton set but a terminal object
16:21:08 <Arunabha> cmccann: adding a fromIntegral does not help, I get a different error  Could not deduce (Integral a) arising from a use of `fromIntegral'  from the context (Num a, Fractional b)    bound by the type signature for               listMean :: (Num a, Fractional b) => [a] -> b
16:21:34 <yyttr3> I'm still new to both haskell and category theory, so i'm trying :D. Spivak has been enlightening so far.
16:21:45 <yyttr3> also LYAH
16:21:59 <cmccann> Arunabha: right, now add the Integral constraint it wants
16:22:14 <dolio> If 1 is a terminal object, then Hom(1, A) is often called the "global elements" of A.
16:22:30 <cmccann> Arunabha: after adding the fromIntegral it should also work if you remove the type signature entirely and ask GHCi what type it is
16:22:53 <yyttr3> But Hom(1,A) are morphisms to A, not elements of A?
16:23:03 <dolio> Yes.
16:23:26 <josephle> yyttr3: well, A is any object in the category
16:23:42 <dolio> In Set, though, there is a correspondence between Hom(1, A) and the elements of A, as you observed.
16:25:08 <Arunabha> cmccann: adding fromIntegral to the sum and removing the type decl helps, but the type inferred is listMean :: (Integral a1, Fractional a) => [a1] -> a, which seems to imply that we can only find the mean of integral lists and not lists of fractions
16:27:03 <yyttr3> Wait, is Hask = Hom( 1, Hask) ?
16:27:18 <carter> Arunabha: note quite,
16:27:20 <josephle> yyttr3: under what category?
16:27:25 <carter> Arunabha: every integral has a fractional sibling
16:27:47 <yyttr3> Isn't Hask the category? I might not understand.
16:27:53 <cmccann> Arunabha: oh, I guess I assumed you had integers in the list since you wanted different types. is there a reason the list elements and result need to be different types?
16:28:27 <shachaf> Hask is a category (or something close enough to a category). What does Hom(1, Hask) mean?
16:28:30 <cmccann> Arunabha: in any case, use realToFrac instead if you want
16:28:38 <josephle> yyttr3: so you're saying Hask = Hom_Hask(1, Hask)?
16:28:47 <yyttr3> No, nevermind. I'm wrong.
16:28:51 <Arunabha> cmccann: No, no reason
16:29:16 <josephle> yyttr3: the abstraction is a little tricky at first :)
16:30:16 <yyttr3> josephle: I know, I've taken abstract algebra and that was amazing and fun, but this is a little more interesting lol.
16:30:38 <cmccann> Arunabha: probably I'd personally make the type look like [a] -> a instead and then map fromIntegral over the list at the call site if I needed to use it on integers
16:32:16 <cmccann> Arunabha: at any rate, realToFrac will do what you originally wanted
16:32:52 <cmccann> as an aside, Real is possibly the worst-named type class in the Prelude
16:33:28 <Arunabha> cmccann: removing the fromIntegral on the sum produces the type listMean :: Fractional a => [a] -> a which seems to indicate that it will only work on lists of doubles or floats , but it seems to work on lists of integers as well... now I'm confused, but thanks for the help
16:33:34 <eitan_chatav> Hom_Cat(TerminalCategory,Hask) = Hask
16:34:19 <cmccann> Arunabha: on actual lists of type [Integer]? or on lists of integer literals?
16:34:54 <eitan_chatav> http://ncatlab.org/nlab/show/terminal+category
16:34:57 <Arunabha> cmccann: on lists of integer literals ghci> listMean [1,2] 1.5
16:35:11 <cmccann> :t [1, 2]
16:35:12 <lambdabot> Num t => [t]
16:35:19 <cmccann> [1, 2] :: [Double]
16:35:22 <cmccann> > [1, 2] :: [Double]
16:35:23 <lambdabot>  [1.0,2.0]
16:35:30 <cmccann> literals are polymorphic
16:35:43 <cmccann> if you give an Integer type annotation to the list it will complain
16:36:21 <yyttr3> eitan_chatav: That is what I was trying to say, but what is the difference between Hom_Cat and Hom_Set?
16:36:50 <josephle> yyttr3: Hom_Cat is describing a set of morphisms in the category Cat
16:37:03 <josephle> while Hom_Set is describing a set of morphisms in Set
16:37:08 <Arunabha> Ahh, I see so listMean ([1,2] :: [Int])  should not work
16:37:19 <Arunabha> and indeed it doesn't
16:37:37 <yyttr3> I don't know anything about Cat yet then :D thank you.
16:37:42 <cmccann> Arunabha: yep, exactly
16:37:54 <eitan_chatav> Cat is a 2-category
16:38:12 <eitan_chatav> it has objects like the terminal category and Hask
16:38:21 <Arunabha> cmccann: So how can I define a mean function that works on all numeric lists and produces a fraction as a result ?
16:38:36 <Arunabha> or any numeric value as a result
16:38:36 <eitan_chatav> 2-categories have 1-morphisms and 2-morphisms
16:38:37 <cmccann> Arunabha: with just the literals, it uses defaulting to pick a type that satisfies the constraints, which in the case of Fractional means it uses Double I think
16:38:47 <eitan_chatav> for Cat, 1-morphisms are functors
16:38:54 <eitan_chatav> 2-morphisms are natural transformations
16:38:57 <cmccann> Arunabha: use realToFrac on the sum
16:39:09 <cmccann> :t realToFrac
16:39:10 <lambdabot> (Real a, Fractional b) => a -> b
16:39:28 <josephle> eitan_chatav: this kind of reminds me of -1-types, 0-types, etc
16:39:28 <eitan_chatav> Hom_Cat(Cat1,Cat2) is the Category whose objects are functors from Cat1 to Cat2 and whose morphisms are natural transformations between such functors
16:39:35 <yyttr3> Cat is a category containing Categories and Functors between them as well as the objects within those categories?
16:39:47 <yyttr3> Oh I see.
16:39:54 <cmccann> Arunabha: that's doing a double conversion via Rational
16:40:27 <eitan_chatav> n-types are special kinds of n-categories
16:41:50 <eitan_chatav> Cat can be thought of as a category by ignoring natural transformations, but that's "evil"
16:43:15 <Arunabha> cmccann: Thanks a lot
16:45:09 <cmccann> Arunabha: no prob
16:48:31 * hackagebot memcached-binary 0.1.1 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.1.1 (HirotomoMoriwaki)
16:49:40 <SrPx> What do you guys think about hash consing every data structure? That is, making the whole memory shared. Huge savings, I thought it could be good for synchronising client-server applications. Thoughts?
16:56:40 <augur> yyttr3: did you get an answer to that question about isomorphism?
16:57:22 <yyttr3> I'm just reading now. I don't want to get caught up in my own questions before i've finished the book :)
16:57:54 <augur> yyttr3: well for when you're ready, the answer is yes:   Hom(1,X) ~ X like so:   take f in Hom(1,X), and <> as the element of 1. then f(<>) is in X
16:58:39 <augur> conversely, given x in X, the function   x^ = <> :-> x   is in Hom(1,X)
16:58:58 <yyttr3> In Cat?
16:59:10 <augur> and of course:   x^(<>) = x   and   f(<>)^ = f
16:59:37 <augur> yyttr3: in cat how?
16:59:59 <augur> f is in Hom(1,X), so its an element of that set (but also an arrow in the category Set)
17:00:06 <yyttr3> I don't really understand anything to any deep level so forgive me, but what category?
17:01:15 <augur> in haskell, you have   X ~ () -> X   like so:   delay : X -> (() -> X) ; delay x () = x   force : (() -> X) -> X ; force f = f ()
17:01:36 <augur> the isomorphism is what we usually use for creating thunks, sort of
17:02:36 <josephle> yyttr3: this is all in Hask
17:02:47 <carter> augur: you don't quite have  ()->x ~ x wrt to cost model though :)
17:02:59 <augur> yes, the haskell stuff is in Hask, but the Hom stuff is in Set
17:03:05 <augur> carter: yeah, hence the "sort of" :)
17:03:07 <carter> augur: are tehre any good docs on attribute grammars vs the head phased thingys/
17:03:18 <yyttr3> I was misusing the notation before then. I understand now :D I thought that was true!
17:03:24 <augur> carter: no, theyre not used in the same domains
17:03:30 <carter> oh?
17:03:33 <carter> how so?
17:03:34 <augur> HPSG is a linguistics framework, AGs are .. afaik barely used at all
17:03:42 <josephle> well, () is almost a terminal object in Hask... :P
17:03:50 <yyttr3> I said Hom( 1, Hask), not Hom_Hask( 1, X)
17:04:11 <augur> yyttr3: oh, i was responding to the question about Hom(1,X) not Hom(1,Hask)
17:04:11 <carter> augur: basically i want to figure out whats a nice "formal" setting for talking about "data cleaning" as an elboration/compilation process
17:04:35 <augur> but, that wouldnt change things, yyttr3. Hom(1,Hask) is still a set
17:04:50 <augur> carter: minimal example?
17:05:08 <yyttr3> I'm confused :D I should focus on the text right now. I don't really have the foundation to discuss this.
17:05:14 <carter> augur: imagine the shitties SQL Schema / CSV ofyour life
17:05:45 <augur> yyttr3: which text are you reading?
17:05:53 <augur> yyttr3: also, ##categorytheory
17:06:01 <yyttr3> Spivak's Category theory for scientists.
17:06:08 <augur> yyttr3: oh, gosh, hmm
17:06:14 <augur> i would suggest reading awodey instead
17:06:14 <yyttr3> Is that bad?
17:06:21 <augur> awodey also has a video lecture series you can watch
17:06:25 <yyttr3> Everything else i've read by spivak is amazing.
17:06:39 <josephle> I second the awodey recommendation
17:06:41 <yyttr3> Link?
17:06:47 <augur> yyttr3: its not the same spivak you're thinking of, i think
17:06:58 <yyttr3> To the video lecture that is
17:07:03 <augur> yeah, im getting it :)
17:07:47 <yyttr3> Oh god, It is a different spivak. I'm so oblivious xD
17:07:59 <augur> yyttr3: its ok, i didnt realize it at first either
17:08:10 <augur> https://www.youtube.com/watch?v=BF6kHD1DAeU&list=PLGCr8P_YncjVjwAxrifKgcQYtbZ3zuPlb
17:08:22 <augur> carter: more?
17:08:38 <josephle> imagine my disappointment when I realized Fortran and Rust are not created by related Hoares
17:08:50 <carter> josephle: heh
17:08:56 <carter> augur: i'll have to thnk about that
17:09:04 <yyttr3> Ohh! Thank you! This will be fun :D
17:09:19 <augur> carter: can you explain why you're looking into AGs for this purpose?
17:09:40 <carter> well, 3am carter was thinkign about how AGs seem to be used for "elaborating data"
17:09:49 <carter> 8pm carter is fuzzy on that
17:10:13 <carter> not sure if its the direction worth looking in
17:10:21 <carter> but was the closest notion i could thnk of
17:10:44 <augur> carter: do you have an elaboration example in mind?
17:12:45 <carter> hrm
17:13:06 <carter> AGs are probably totally unrelated to what i'm trying to figure out
17:13:17 <carter> augur: ask me in a few days and i'll be better equipped to explain what i want
17:13:20 <carter> after sunday
17:13:22 <augur> :)
17:13:24 <carter> giving a talk sunday at ICFP
17:14:03 <carter> focusing on how to explain my array types design wrt  motivating it via an "abstract interpreter" of memory locality quality
17:15:01 <carter> the abstract interpreter view perfectly explains my design
17:15:11 <carter> granted thats sort of a post facto formalization :)
17:15:29 <augur> carter: ill away the video eagerly!
17:15:29 <carter> but does give a good way to standarize some of my design ideas i guess
17:15:37 <carter> augur: its gonna SUCK
17:15:37 <carter> :)
17:15:42 <carter> only 30 min
17:15:58 <carter> so it'll be making sure they understand what i mean by memory locality
17:16:11 <carter> explaining my simplified locality model i can reflect into types
17:16:32 <carter> showing how i type operations via the Abstract interpretation of the locality info
17:16:37 <carter> and 1-2 boring examples
17:17:52 <carter> augur: i don't think the workshop will be recorded
17:17:56 <carter> meant to be informal
17:20:17 <augur> carter: luckily, smart phones can record video :)
17:20:21 <carter> lol
17:44:03 <yyttr3> What's an example of a morphism of a category that isn't a function?
17:44:18 <carter> stuff on sheaves
17:44:33 <cody__> ordered sets are categories
17:44:53 <cody__> there is a unique morphism a -> b iff a <= b
17:45:06 <cody__> reduction relations
17:45:15 <yyttr3> Isn't that a function?
17:45:22 <cody__> no...
17:45:26 <Cale> yyttr3: Take the category whose objects are the natural numbers and whose arrows n -> m are n-by-m matrices, and composition is matrix multiplication.
17:45:43 <cody__> Cale: that's kind of cheating
17:45:44 <haasn> (also known as composition of linear functions)
17:45:54 <Cale> Well, yes, it's cheating a little bit
17:46:04 <copumpkin> take a monoid :)
17:46:22 <coppro> yyttr3: Every category is isomorphic to some category whose morphisms are functions.
17:46:30 <Cale> You can turn any small category into a concrete category pretty easily
17:46:41 <ian_mi> entailment forms a category
17:46:50 <haasn> copumpkin: That's also cheating; since you can represent any element ‘m’ of a monoid as the function \x -> x++m
17:46:55 <cody__> ian_mi: great example!
17:46:56 <haasn> equivalently
17:47:30 <ian_mi> the category Cat is another example
17:47:34 <cody__> the opposite of any category with "function morphisms"
17:47:36 <copumpkin> haasn: is the new criterion a category whose morphisms are not iso to any set of functions?
17:47:38 <haasn> Those all seems like “functions” to me
17:48:01 <Cale> haasn: Well, these are only function-like in that anything which forms a category is sort of function-like.
17:48:02 <cody__> well "functions" maybe, but not functions :)
17:48:05 <haasn> cody__: That's what it seems like to me
17:48:08 <haasn> copumpkin: *
17:48:50 <cody__> every group forms a category with a single object
17:48:59 <Cale> haasn: Many of these are not so function-like, in that there's not really a reasonable notion of function application, unless you contrive one.
17:49:56 <haasn> How about “Categories which are not isomorphic to subcategories of Set” - do those exist?
17:50:16 <cody__> not really
17:50:21 <ian_mi> haasn: Large categories
17:50:22 <cody__> because of the Yoneda embedding
17:50:31 <ian_mi> e.g. Cat
17:50:44 <Cale> haasn: But you can pretty much always contrive one by taking each object X in the category and replacing it with the set of arrows {f : T -> X | T in C}, and then arrows X -> Y act on that set by composition.
17:51:28 <Cale> But that relies on that actually being a *set* of arrows
17:52:13 <ian_mi> The Yoneda embedding only applies to locally-small categories
17:52:16 <haasn> Interesting, thanks
17:52:24 <Cale> Of course, if you're working in a set or type theory where there's stratified universes, it'll typically at least be some sort of one-level-higher set.
17:54:05 <Cale> Yoneda is sort of a refined version of this
17:55:01 <Cale> Where you maintain more information about where the arrows came from in the form of a functor C^op -> Set, rather than just lumping all the T -> X arrows into a single set.
17:58:11 <tabemann> does anyone have any idea of what the interthread switching latency is in GHC Haskell 7.8?
18:02:36 <tabemann> hmm maybe I could figure it out by implementing a thread ring, timing it with criterion, and dividing the time by the number of transitions
18:03:01 <Cale> tabemann: Do you mean the time that it takes to switch between threads running on a single core?
18:03:47 <Cale> Or the interval between context switches?
18:04:16 <Cale> There's a default context switch interval of 0.02 seconds which can be configured by the -C RTS option.
18:04:23 <dfeuer_> Cale!
18:04:28 <tabemann> Cale: I'd want to measure both single core and intercore
18:04:29 <Cale> hi
18:05:21 <tabemann> I don't care about the default context switch interval, but rather the rate at which threads can switch if each thread actually gives up control
18:06:06 <tabemann> I care because I might be implementing something that'd take the form of a chain of threads each taking and then giving up control one after another, and I care that I can get sufficient performance out of that
18:06:45 <tabemann> why I'm implementing that is because I'm organizing my application in an actor-ish fashion (albeit using STM), with the thread being the basic unit of computation
18:10:00 <dreams> Hi, so what is balckholing?
18:10:27 <Cale> dreams: So, variables are represented at runtime by pointers to code
18:11:23 <dreams> Cale: pointer to code? hmm, don't get it. do you mean pointers to heap cells?
18:11:39 <Cale> dreams: When a bound variable is first evaluated (pattern matched on), the code is entered, and the first thing it does is to rewrite the pointer to point at a "black hole" which will throw an exception if entered, because that means in order to evaluate x, you needed to evaluate x, so you're in an infinite loop
18:12:14 <Cale> then it computes the value of the expression, and finally before returning it, rewrites the pointer to point at a short piece of code which will return the computed value immediately next time
18:12:58 <dfeuer_> But in a parallel program, the black hole doesn't actually eat your program; it just makes threads block.
18:13:19 <Cale> (I'm describing a non-threaded setting here, with threads, you need grey holes instead, which block and wait for the possibility of another thread which already started evaluating the value)
18:13:21 <dfeuer_> Because there could be a black hole there because somebody *else* is evaluating that thing.
18:13:37 <dfeuer_> Oh, OK. Different name, I guess.
18:13:47 <tabemann> one thing I've always wondered is what happens if a thunk is entered literally simultaneously in two different threads on two different cores, before one has the chance to blackhole it
18:14:23 <Cale> tabemann: It's possible you end up computing it twice, but this is so infrequent that solutions to the problem typically end up costing more on average
18:14:24 <carter> tabemann: thats called unsafeDupablePerformIO
18:15:02 <Cale> Well, unsafePerformIO contains a solution to this problem, while unsafeDupablePerformIO skips that
18:15:14 <dreams> Cale: "the first thing it does it to rewrite the pointer to point to a black hole. what is the pointer pointing to before rewriting?
18:15:17 <Cale> But this still happens in pure evaluation
18:15:26 <tabemann> dreams: the thunk
18:15:30 <Cale> dreams: The code we're executing
18:15:49 <Cale> dreams: more or less the code for the expression to be evaluated
18:16:08 <dreams> so by "the code is entered", you mean the thunk is forced?
18:16:13 <Cale> This setup is known as a "thunk" which is the general term for any data structure used to implement expressions at runtime.
18:16:18 <Cale> yes
18:16:30 <dreams> ok let me re-read.
18:16:33 <c_wraith> dreams: well.  it means the processing of forcing it has *started*
18:16:41 <dfeuer_> dreams, but the first *step* in "forcing the thunk" is actually doing that rewrite.
18:16:47 <c_wraith> dreams: it takes a non-zero amount of time
18:17:15 <Cale> I don't really like using the term "thunk" much in discussions, because usually you either want something more abstract like "expression" or else something more specific about what the thunk actually is.
18:18:15 <dreams> Cale: they sometime use the term unevaluated closure (in papers) which is more confusing for me.
18:18:21 <Cale> It's a bit like the word "closure" in that regard, in that it's an implementation detail with some design choices still left to be made.
18:18:43 <tabemann> closure doesn't indicate that it's overwritten with the evaluated value
18:18:52 <tabemann> expression doesn't indicate that it closes over its scope
18:19:05 <Cale> Closures aren't (typically) a language feature, but a mechanism used to implement one, such as function.
18:19:07 <Cale> functions*
18:19:56 <Cale> (and the term is used for a variety of closely related data structures consisting of code together with some kind of environment)
18:20:24 <tabemann> I hear "closure" being used in literature on different languages to indicate a function whose lexical scope is closed over explicitly, often being contrasted with "methods"
18:20:29 <Cale> Similarly, thunks aren't really a language feature either, but something used to implement expressions in a lazy evaluator, and there are a bunch of structures that will work.
18:20:40 <dreams> Cale: just by reading what you said again, got me thinking that, the thing that evaluate expressions are pattern matching?
18:20:54 <dreams> i.e. its the only way.
18:21:07 <Cale> dreams: Yes, at some level, pattern matching is the only reason to evaluate anything.
18:21:33 <Cale> I suppose there's also seq, but you could implement seq at individual types by pattern matching (except function and abstract types)
18:21:53 <tabemann> except there's ways of forcing a thunk without actually matching for its value, e.g. bang patterns, seq, and strict members of data types
18:21:57 <merijn> dreams: When talking about evaluation in haskell, we usefully refer to "weak head normal form", which can be interpreted as "exposing the outermost constructor"
18:22:01 <dreams> by at some level, you mean core?
18:22:06 <Cale> dreams: yeah
18:22:46 <Cale> dreams: By the time you get to core, all the pattern matching and evaluation comes in the form of case expressions that match on single constructors.
18:22:55 <dreams> merijn: I can't use that term since I read about it and still don't get it.
18:23:33 <Cale> An expression is in weak head normal form if either it's a data constructor applied to some expressions, or it is a lambda.
18:23:57 <Iceland_jack> From https://davidterei.com/talks/2014-05-cs240h/ghc.html:
18:23:57 <Iceland_jack>     • Language still lazy but `case` means evaluation.
18:24:13 <tabemann> to fully evaluate something one needs to use deepseq (not recommended), usually when something is said to be evaluated it only means the outermost constructor level
18:24:18 <dreams> oh wow
18:24:20 <int-e> > case undefined of _ -> ()
18:24:21 <lambdabot>  ()
18:24:28 <Iceland_jack> int-e: In core
18:24:30 <dfeuer_> I'm still trying to figure out why inlining isn't happening in a simplifier run I added between specialization and floating outwards... anyone know how that stuff works?
18:24:39 <dreams> I think now I understand the trick behind the GHCi debugger.
18:24:44 <Iceland_jack> That's why Core's `case` is actually binary
18:24:45 <int-e> (in Core that would evaluate the 'undefined', resulting in bottom)
18:25:01 <int-e> Iceland_jack: Heh, I wasn't finished.
18:25:16 <Iceland_jack> int-e: Sorry :) too eager to clarify
18:25:44 <Cale> Right, case expressions at the level of Haskell have the potential to not do evaluation, which on some days I wonder about. Really the thing which bothers me more is that bang patterns have the potential to force 'let' into evaluating things, which freaks me out.
18:26:02 <dreams> Cale: so if: (\x -> x) or head [1,3]
18:26:14 <int-e> (the case syntax is also a bit different in Core, but never mind)
18:26:25 <Cale> (\x -> x) is in WHNF, head [1,3] is not
18:26:50 <Cale> (because head is not a data constructor)
18:27:05 <dreams> but you said a data constructor applied to an expression
18:27:06 <dfeuer_> Iceland_jack, I don't see anything binary about Core's `case`.
18:27:37 <Cale> dreams: [1,3] is in WHNF because it's just notation for 1 : (3 : []), and (:) is a data constructor
18:27:46 <Iceland_jack> dfeuer_: To be more precise, it takes one extra argument whose meaning is the evaluated form
18:27:49 <dfeuer_> Cale, indeed, let and case are much more uniform in meaning in Core.
18:27:50 <dreams> oh ok
18:28:11 <dfeuer_> Iceland_jack, ah, I see what you mean. Yes it does.
18:28:12 <chrisdotcode> how do you hoogle search with lambdabot again?
18:28:18 <chrisdotcode> :h id
18:28:19 <dfeuer_> @hoogle chrisdotcode
18:28:21 <lambdabot> No results found
18:28:21 <Iceland_jack> So Haskell's case is the same as Core's with a wildcard pattern match
18:28:25 <chrisdotcode> @hoogle id
18:28:25 <lambdabot> Prelude id :: a -> a
18:28:26 <lambdabot> Data.Function id :: a -> a
18:28:26 <lambdabot> Control.Category id :: Category cat => cat a a
18:28:28 <Iceland_jack>     case expr of ... -> case expr _ -> ...
18:28:29 <chrisdotcode> thanks!
18:28:35 <Iceland_jack> *case expr of _
18:28:36 <dreams> Cale: thanks :)
18:28:50 <Cale> dfeuer_: Yeah, I really preferred the initial simple translation of bang patterns which meant that bang patterns on pattern bindings in a let essentially had no effect.
18:28:56 <dfeuer_> Iceland_jack, yes, I already figured that out; I just didn't understand what you were saying about it.
18:29:32 <dfeuer_> Cale, I think things with no effect probably shouldn't be there.
18:29:56 <Cale> dfeuer_: Well, we have lots of other stupid patterns you can write pattern bindings for
18:30:05 <Cale> > let 1 = 2 in 1
18:30:07 <lambdabot>  1
18:30:23 <Cale> (like any pattern which doesn't bind variables)
18:30:27 <carter> Iceland_jack: haskel case aint as strict as core case
18:30:30 <int-e> > let !1 = 2 in 1
18:30:32 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
18:31:20 <Cale> I think it's better to be uniform and admit some silly things than it is to make up contrived rules to ensure that everything you can write is somehow useful.
18:32:16 <int-e> Cale: hmm, I find the strict lets quite useful.
18:32:43 <Cale> I would usually just write a case rather than a strict let
18:32:56 <Cale> because that's what it'll desugar into anyway
18:33:12 <carter> int-e: Cale  the strict lets stuff will be fixed in 7.10
18:33:23 <Cale> carter: fixed in which way though?
18:33:29 <carter> making it work
18:33:29 <int-e> "fixed"?!
18:33:35 <Cale> One could say that it's fixed now?
18:33:47 <Cale> But which way is correct is a matter of opinion here
18:33:50 <carter> you cant do strict top level recursive lets
18:33:53 <carter> currently
18:33:56 <carter> i thnk
18:33:58 <carter> i forget
18:33:59 <carter> tehres a ticket
18:34:07 <carter> @google ghc let strict recursive
18:34:07 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
18:34:10 <Cale> Oh, top-level...
18:34:11 <Cale> hm
18:34:38 <Cale> Oh, that's weird
18:34:44 <int-e> but we meant the usual let construct in expressions.
18:34:45 <Cale> I didn't even know about this extension
18:34:51 <carter> https://ghc.haskell.org/trac/ghc/wiki/StrictPragma#Recursiveandpolymorphicletbindings
18:34:56 <carter> its not in yet
18:35:49 <Cale> But yeah, we were just talking about ordinary Haskell 98/2010
18:35:59 <Cale> and the bang patterns extension
18:36:19 <merijn> How does Ralph Lämmel's solution to the expression problem (http://userpages.uni-koblenz.de/~laemmel/TheEagle/resources/pdf/xproblem1.pdf) compare to Swierstra's (http://www.staff.science.uu.nl/~swier004/Publications/DataTypesALaCarte.pdf), in terms of performance?
18:36:53 <Cale> merijn: In terms of *performance*... hmm
18:38:24 <Cale> merijn: I can't really say for sure, but I'd expect them to be comparable
18:38:25 <merijn> Alternatively, I'd be interested in efficient ways to do an entity-component system in haskell, but I suspect that would be pretty identical to solving the expression problem
18:38:36 <Cale> I mean, in any case, it's like a couple function parameters
18:39:07 <SrPx> If I say this: `data A a = B a | C; x = C", then x's type is "B a". Does that mean that x's type is not a concrete type, but a type function that still needs an `a` to become an actual type? So `x` doesn't have a type?
18:39:29 <SrPx> woops, x's type is "A a", sorry
18:39:51 <jle`> SrPx: it's a "concrete type" (although that's not a very meanignful term these days), but it's polymorphic
18:40:00 <merijn> SrPx: I personally hate the term "concrete type" it's not a very technical term and it's meaning is very ill-defined
18:40:06 <Cale> SrPx: It's kind of like that, x's type is polymorphic.
18:40:07 <jle`> just like [] is polymorphic
18:40:16 <merijn> SrPx: Better (technical) terms would be: monomorphic type and/or type of kind *
18:40:17 <jle`> yeah, i probably shouildn't have said yes/no to "concrete type"
18:40:20 <Cale> SrPx: We could be explicit about the quantifier:
18:40:24 <Cale> x :: forall a. A a
18:41:06 <Cale> SrPx: Using x at a specific type, such as A Integer, will result in an implicit type application, which in core would look something like x @Integer
18:41:06 <Iceland_jack> ‘constant type’ is used
18:41:08 <merijn> SrPx: A monomorphic type is one that is not polymorphic, examples are: Int, Maybe Bool, [Char]. Things that are not monomorphic: 'a', Maybe a, [a], etc.
18:41:26 <Iceland_jack> That has many different meanings but it should be clear from context
18:41:41 <SrPx> Cale: which is the same as a function on type level that receives a type and returns a type, right? so "x :: forall a. A a" is just "x :: a → A a"
18:42:04 <jle`> er, not really.
18:42:05 <Cale> SrPx: x is something which accepts a type, and produces a value (of a type dependent on that parameter)
18:42:15 <jle`> forall a. A a has kind *
18:42:20 <jle`> A is * -> *
18:42:28 <Cale> SrPx: That is, if you want to think about it like that
18:42:40 <Cale> In a dependently typed language, you might write something like:
18:42:54 <Cale> x :: (t : Type) -> A t
18:43:00 <jle`> but the thing is that values like [] are of "actual types"
18:43:06 <Cale> Making the type parameter explicit
18:43:11 <jle`> values can only types of things having *
18:43:21 <jle`> you can't have a value with a kind * -> *
18:43:28 <Cale> jle`: Yeah, this isn't about kinds
18:43:44 <jle`> he mentioned type level functions, though
18:43:52 <jle`> i think he might be thinking that x :: A
18:43:58 <Cale> Well, this is a value level function accepting a type argument
18:44:06 <Cale> (secretly)
18:44:10 <SrPx> if x needs a type, why can't I type: (x Int)? To apply "x" to Int and get the value (x :: A Int) ?
18:44:18 <Cale> That's what I assumed he was kind of trying to get at anyway
18:44:29 <Cale> SrPx: Well, because Haskell doesn't have explicit type application
18:44:30 <Iceland_jack> SrPx: People are working on explicit type application
18:44:45 <Cale> SrPx: You can write (x :: A Int)
18:44:52 <Iceland_jack> For now you'll have to do what Cale suggests
18:44:52 <Cale> SrPx: which will accomplish the same thing
18:45:05 <Iceland_jack> But in future versions, possibly GHC 7.10 you can do https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication
18:45:09 <linman32> hi what does := do?
18:45:24 <SrPx> no problems I'm just trying to sort things, this is the part of the type system that always confuses me
18:45:24 <Iceland_jack> linman32: It's probably a value constructor defined by some library
18:45:31 <jle`> SrPx: you might have, in the past, done things like (5 :: Double)
18:45:31 <Cale> linman32: That's a valid name for a data constructor. It gets used in a number of different libraries...
18:45:34 <jle`> or (5 :: Int)
18:45:45 <jle`> it's a similar thing; 5 is a polymorphic literal
18:45:47 <Iceland_jack> Probably
18:45:47 <Iceland_jack>     data Statement = Var := Expr | ...
18:45:49 <jle`> [] is a polymorphic value
18:45:54 <linman32> Cale, Iceland_jack: thnx. it is found in gtk2hs
18:45:58 <prinsen> Maybe a strange question. I have several Producers and Consumers with an ReaderT r ... as the inner monad. The r:s are not concrete types but instead has different enforced class constraints, such as ServerSettings r => Producer ... (ReaderT r). This allows for nice constraint propagation when composing parts, but forces tedious creating of concrete data types that instantiates the different classes. Is there any way to automate this proces
18:46:02 <jle`> [] :: [Int]
18:46:20 <jle`> Right 5 :: Either String Int
18:46:31 <jle`> Right True is also polymorphic
18:46:42 <jle`> Right True :: forall a. Either a Bool
18:46:43 <Cale> linman32: In that case, http://hackage.haskell.org/package/glib-0.13.0.1/docs/System-Glib-Attributes.html#v::-61-
18:46:55 <Cale> linman32: It's part of the Attributes system in the glib binding
18:46:57 <Iceland_jack> > let a = ([] :: [a]) in (a :: [Int], a :: [()])
18:46:59 <lambdabot>  ([],[])
18:46:59 <SrPx> What is the type of 5, without a specification?
18:47:06 <Iceland_jack> SrPx: Num a => a
18:47:28 <prinsen> Like a type function that takes a set of class constraints and composes a concrete data type
18:47:28 <SrPx> which is `Num a => forall a. a` ?
18:47:29 <jle`> SrPx: well, if you use it in a program, it usually can be inferred.  but the 5 literal is of type Num a => a
18:47:31 <Iceland_jack> It's really
18:47:31 <Iceland_jack> > fromInteger (5 :: Integer)
18:47:33 <lambdabot>  5
18:47:40 <Cale> linman32: Basically, AttrOp is a datatype which represents a bunch of things which can be done to attributes, and 'set' will actually carry those things out. It's *mostly* just as a cute notational device here.
18:47:45 <Iceland_jack> SrPx: yes
18:47:55 <Iceland_jack> It's Rank-1
18:48:18 <SrPx> I just don't see how "forall x . x" isn't exactly the same as "λ x . x" just in a different level, we could say... but alright
18:48:33 <Cale> linman32: So that you can write  set button [ buttonLabel := value ]  to set the label on a button
18:49:00 <Cale> SrPx: Are you familiar with System F?
18:49:04 <SrPx> it looks just like the lambda calculus. is the type system actually a language by itself...? it looks a lot like simply typed lambda calculus?
18:49:16 <SrPx> Cale: not a lot
18:49:33 <Cale> SrPx: System F is like the simply typed lambda calculus, but it introduces a value-level type lambda
18:50:03 <jle`> some do consider there to be a separate mini-language at the type level in haskell
18:50:06 <Iceland_jack> ‘foralls’ just bind types to a scope
18:50:10 <linman32> Cale: how did you find the reference for it?
18:50:18 <Cale> SrPx: and things of type (forall a. ...) will be constructed by these value-level type lambdas
18:50:19 <int-e> merijn: Hmm, the two approaches are hard to compare. Anyway I think Laemmel's solution has a big problem, in that you have to anticipate all uses of an expression when you build it (note that the Exp class gives you no functionality at all; if you want to evaluate the term later, you'll have to build its Evaluate instance as you go, etc.); more fundamentally, it doesn't give you a data type for expressions even after you've...
18:50:25 <int-e> ...fixed the syntax. I also suspect that this process of building class dictionaries becomes rather expensive quickly. So I'd prefer Swierstra's approach.
18:50:48 <SrPx> mm...
18:50:48 <merijn> int-e: I'm not actually dealing with expressions, though
18:51:15 <merijn> int-e: Like I said, what I really want to implement is an entity-component system, but that has the exact same problems as the expression problem
18:51:17 <Cale> linman32: Well, I sort of knew what I was looking for. I searched for and clicked on the glib package on hackage, then on a random module, and then "Index" at the top, and picked : and then :=
18:51:22 <dmwit> SrPx: (forall a. a) looks a bit like (\x. x). But how far does the analogy go? What does ((\x. x) 3) look like?
18:51:22 <SrPx> well I must resume the study now, it was helpful. thanks guys
18:51:40 <merijn> int-e: Swierstra's approach has a whole ton of dictionaries to build as well, no?
18:52:06 <michaelt> prinsen: your question is kind of abstract ...
18:52:40 <int-e> merijn: but there is a finite set of them that covers the whole evaluation of Expr (Val :+: Add); in Laemmel's approach, every expression has its own type, more or less.
18:52:43 <merijn> int-e: Basically, my problem is just "I want to be able to add new cases/datatypes and new operations with the minimal amount of old-code rewriting"
18:52:56 <Cale> SrPx: Haskell is for the most part sort of a fancy version of System F with lots of syntax sugar and which makes these type-lambdas and type applications totally implicit.
18:53:00 <SrPx> dmwit: I'd just guess `((\x . x) 3) → 3` is the same logically as `((forall a . [a]) Int) → [Int]` which I kind of imagined was what happened internally when you typed `[] 1` but I don't know
18:53:20 <merijn> int-e: Yeah, but for anything non-trivial that "finite set" might still be large
18:53:29 <int-e> merijn: and it'll be very hard to write a parser for expressions in Laemmel's approach.
18:53:33 <Cale> SrPx: The type application here doesn't happen at the type level
18:53:42 <Cale> SrPx: You don't have (forall a. [a]) Int
18:53:44 <merijn> int-e: Like I said, I'm not dealing with actual expressions
18:53:45 <prinsen> michaelt: Ok. Basically when I compose components I end up with an Effect that has several constraints on its reader value. Its tedious work writing the concreate r and writing all the instances
18:53:55 <merijn> int-e: I don't need to write a parser because there's nothing to parse
18:54:00 <prinsen> michaelt: It seems like to process could be automated
18:54:15 <SrPx> Cale: oh that is true
18:54:37 <Cale> SrPx: Instead, you have stuff going on at the value level, something like: (/\a -> [] a) :: forall a. [a]
18:54:40 <Iceland_jack> SrPx: With the explicit type application proposal I meantioned earlier, that would be possible
18:55:05 <Iceland_jack>     ((forall a. [a]) @ Int) ~ [Int]
18:55:09 <merijn> int-e: This is less about expressions and more about "how to have an easily extensible program design"
18:55:25 <Cale> Iceland_jack: Oh, do they really introduce type-level notation for it too?
18:55:27 <Cale> Interesting
18:55:47 <SrPx> Iceland_jack: is that proposal coming any soon?
18:56:13 <Iceland_jack> Cale: I'm not sure if the type-level thing will happen actually but it should :)
18:56:22 <Iceland_jack> SrPx: Not sure
18:57:33 <Cale> SrPx: From the wikipedia page, there's the example of using functions of type forall a. a -> a -> a  as booleans
18:58:01 <Cale> SrPx: and you have T = /\a -> \(x::a) -> \(y::a) -> x
18:58:09 <Cale> SrPx: and F = /\a -> \(x::a) -> \(y::a) -> y
18:58:11 <merijn> bleh, sometimes the closed-ness of ADTs is really annoying :\
18:58:57 <SrPx> which just makes it sound more like the STLC ... :\
18:59:15 <Cale> SrPx: well, it is like that
18:59:37 <prinsen> michaelt: Any idea?
18:59:45 <Cale> SrPx: Only you don't need as many primitive types, because you can do similar things as are done in untyped lambda calculus, like these Church encodings.
19:00:30 <Cale> SrPx: You can define the type Boolean to mean forall a. a -> a -> a
19:00:47 <Cale> It doesn't need to be put in as some sort of primitive like with STLC
19:01:18 <Cale> Similarly, you can define the type Nat to be forall a. a -> (a -> a) -> a
19:01:51 <Cale> and then define specific naturals like  0 := /\a -> \(zero :: a) -> \(succ :: a -> a) -> zero
19:02:12 <Cale> and  3 := /\a -> \(zero :: a) -> \(succ :: a -> a) -> succ (succ (succ zero))
19:04:21 <Cale> and then we can do things like  isZero := \(n :: Nat) -> n Boolean True (\(x :: Boolean) -> False)
19:04:47 <Cale> Er, T and F, if we want to use my previous definitions, but whatever, you get the idea
19:05:01 <Iceland_jack> Put into Haskell code
19:05:01 <Iceland_jack>     newtype Nat = Nat (forall n. n -> (n -> n) -> n }
19:05:01 <Iceland_jack>     zero  = Nat (\z s -> z)
19:05:04 <Iceland_jack>     three = Nat (\z s -> s (s (s z)))
19:05:21 <Iceland_jack> and
19:05:21 <Iceland_jack>     isZero (Nat f) = f True (const False)
19:05:50 <Iceland_jack>     ghci> (isZero zero, isZero three)
19:05:50 <Iceland_jack>     (True, False)
19:05:53 <copumpkin> how about pred?
19:06:02 <Iceland_jack> I'm not sober enough to define that :)
19:06:07 <copumpkin> :)
19:06:18 <SrPx> Oh my...
19:06:21 <merijn> Iceland_jack: Or not drunk enough ;)
19:06:23 <int-e> merijn: I'm not sure that either approach gives you what you want. Datatypes ala carte  gives you a way to specify an ADT by defining various constructors and their behaviour separately, and finally combining them into a big Expr (Foo :+: Bar :+: Baz). It works well if you want parsers and various operations on expressions. Laemmel's approach, as far as I see it, works well whenever you can describe a common interface for...
19:06:25 <Iceland_jack> haha
19:06:29 <int-e> ...what you're going to do; data Expr where Expr :: Evaluate expr => expr -> Expr. In fact you can lift the constructors to such an existential easily, add :: Expr -> Expr -> Expr; add (Expr a) (Expr b) = Expr (Add a b). It doesn't work so well when there are many different evaluators, and the exisitential is essentially the only way (I think) to get a parser. None of this helps you with a collection of entitities that may...
19:06:35 <int-e> ...or may not implement a certain behaviour (component), I think.
19:06:39 <Iceland_jack> The easiest^Wlaziest way to define pred would be to define {to,from}Integral
19:07:15 <merijn> int-e: Maybe I need to dive into FRP again and see if that works >.>
19:07:16 <SrPx> Well I understand what you said.
19:07:25 <merijn> Anyway, first back to hacking my other code
19:07:49 <SrPx> Yet honestly this is still the way I wrap my mind around what is going on : http://lpaste.net/110092
19:08:17 <Cale> SrPx: At the kind level, (forall a. [a]) still has kind *
19:08:29 <Cale> SrPx: It doesn't take a type parameter at the type level
19:08:31 <lpaste> merijn pasted “config record” at http://lpaste.net/110094
19:08:36 <Iceland_jack> SrPx: What you're basically explaining is an application funtion
19:08:40 <merijn> Ok, so I need a design opinion
19:08:44 <Cale> But [] (the *type* constructor for list types) has kind * -> *
19:08:45 <Iceland_jack> but what you're saying isn't valid Haskell
19:08:49 * hackagebot simple-pipe 0.0.0.25 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.25 (YoshikuniJujo)
19:09:05 <Iceland_jack>     Apply :: (k -> *) -> k -> *
19:09:06 <merijn> I have a record (see paste) that I use both as type in a reader and as a way for users to specify some config parameters
19:09:22 <Cale> SrPx: Ignoring unboxed types, anything which is a value in Haskell has a type of kind *
19:09:55 <merijn> Now, the "socketType" field should never be specified by users, am I evil if I export all fields except that one and then only provide a "default" record which initialises socketType to undefined so I can later set it to the correct value?
19:10:35 <Cale> :k forall a. [a]
19:10:37 <lambdabot> *
19:10:45 <jle`> so there's a difference between a type-level function like Maybe and forall a. Maybe a
19:10:45 <Iceland_jack> :k forall a b c d. [a]
19:10:46 <lambdabot> *
19:10:56 <Cale> :k forall m. StateT Integer m a
19:10:58 <lambdabot> Not in scope: type variable ‘a’
19:11:01 <Cale> :k forall a. forall m. StateT Integer m a
19:11:03 <lambdabot> *
19:11:23 <merijn> jle`: The former is a type of kind "* -> *" and the latter a polymorphic type of kind *, so yes.
19:12:01 <jle`> yeah, it was a comment for SrPx. although there are multiple levels of meaning going on in this conversation so it's a bit cray
19:12:03 <Cale> :k []
19:12:04 <lambdabot> * -> *
19:12:11 <Cale> :k StateT
19:12:13 <lambdabot> * -> (* -> *) -> * -> *
19:12:15 <Cale> :k StateT Integer
19:12:16 <lambdabot> (* -> *) -> * -> *
19:12:56 <Welkin> :k forall a m. StateT Integer m a
19:12:57 <lambdabot> *
19:13:47 <Welkin> :k (>>=)
19:13:48 <lambdabot> Not in scope: type constructor or class ‘>>=’
19:13:58 <Welkin> oops
19:15:33 <jle`> @let type (>>=) = Free
19:15:34 <lambdabot>  .L.hs:162:14:
19:15:34 <lambdabot>      Not in scope: type constructor or class ‘Free’
19:15:34 <lambdabot>      Perhaps you meant ‘Tree’ (imported from Data.Tree)
19:16:00 <Welkin> jle`: you're back from vacation?
19:16:07 <jle`> yup
19:16:14 <Welkin> I gave up on netwire for now
19:16:35 <jle`> ;_;
19:16:55 <Welkin> I spent 5 days trying to get a collision response to work properly...
19:17:06 <Welkin> just bouncing a ball on a surface
19:17:41 <SrPx> so StateT receives a Type, an parametric type, another type and returns a type? \:
19:17:52 <Welkin> so... for now I'll stick with "imperative" haskell
19:18:06 <int-e> SrPx: right
19:18:24 <int-e> SrPx: the arguments are: a state type, a monad, a (return) value type
19:18:44 <jle`> Welkin: hm. i have been meaning to finish up that physics engine in netwire.  maybe i could work out collisions after that :) i had a primitive systme going on with impulses
19:18:50 * hackagebot BlogLiterately-diagrams 0.1.4.3 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.4.3 (BrentYorgey)
19:18:53 <int-e> (where a monad takes a (return value) type and returns a type)
19:18:54 <jle`> :k StateT Integer Maybe Bool
19:18:55 <lambdabot> *
19:19:00 <jle`> :k StateT Integer String Bool
19:19:01 <lambdabot>     The second argument of ‘StateT’ should have kind ‘* -> *’,
19:19:02 <lambdabot>       but ‘String’ has kind ‘*’
19:19:02 <lambdabot>     In a type in a GHCi command: StateT Integer String Bool
19:19:03 <tabemann> stupid question - is there a good function for inserting a value into the middle of a list?
19:19:34 <int-e> tabemann: no, but it's not to hard to build from  splitAt
19:19:34 <merijn> tabemann: Not really, it requires rebuilding the front half of the list
19:19:46 <jle`> if you need to do it, it's a good sign that lists might not be the appropriate data structure for your use case
19:19:59 <Welkin> represent the list as a tree
19:20:19 <merijn> tabemann: "insertAt n x l = take n ++ (x:drop n l)"
19:20:20 <vanila> > let insmid e l [] = e:l ; insmid e (a:as) (b:_:bs) = insmid e as bs in insmid 'x' "foobar" "foobar"
19:20:22 <lambdabot>  "xbar"
19:20:22 <int-e> or use Data.Sequence
19:20:32 <vanila> > let insmid e l [] = e:l ; insmid e (a:as) (b:_:bs) = a : insmid e as bs in insmid 'x' "foobar" "foobar"
19:20:34 <lambdabot>  "fooxbar"
19:21:08 <tabemann> thanks
19:21:32 <iancormac> Why does http://www.haskell.org/haskellwiki/Humor/1984 work?
19:22:14 <merijn> iancormac: You're defining a local function +
19:22:22 <iancormac> oh haha
19:22:27 <merijn> > let f 2 2 = 5 in f 2 2
19:22:28 <lambdabot>  5
19:22:31 <iancormac> How about the underscore one?
19:22:31 <merijn> > let f 2 2 = 5 in f 2 0
19:22:33 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function f
19:22:45 <merijn> > let (+) 2 2 = 5 in (+) 2 2
19:22:47 <lambdabot>  can't find file: L.hs
19:22:48 <int-e> and _'freedom' is an identifier in Haskell
19:22:53 <iancormac> Oh, it’s not really a string
19:22:53 <splintax> why the underscore?
19:22:54 <iancormac> right
19:22:59 <iancormac> because ‘ is a valid part of a function name
19:23:00 <iancormac> nice
19:23:15 <merijn> iancormac: Since + is just a normal function, it can be shadowed like any other :)
19:23:21 <iancormac> nice
19:23:25 <geekosaur> the underscore just forces the ' to be inside an identifier
19:23:32 <geekosaur> without adding too much visual clutter
19:23:33 <merijn> (Although you probably shouldn't, for obvious reasons!)
19:23:47 <int-e> > let (+) 2 2 = 5 in (+) 2 2
19:23:48 <lambdabot>  5
19:24:38 <haasn> Now wait until we get to the do (>>=) <- ...; ... tricks
19:24:40 <merijn> Any opinions on hiding record fields from users by initialising them to undefined and not exporting the field name? Good, bad, "oh god that's awful!"?
19:24:53 <int-e> I should look into that L.hs race at some point.
19:24:59 <merijn> haasn: Doesn't work, pretty sure that needs RebindableSyntax
19:25:17 <haasn> merijn: yes, it needs RebindableSyntax - but then it does work
19:25:18 <merijn> haasn: The desugarer by default inserts the fully qualified Control.Monad.>>=
19:25:25 <Welkin> when I first heard about how terrible record syntax is, I thought it was just a joke
19:25:35 <Welkin> but I recently discovered how terrible it is
19:25:35 <int-e> merijn: I think it's ok, though the "undefined" is a bit creepy.
19:25:38 <Welkin> and that makes me want to use lens
19:25:48 <merijn> Welkin: I don't think it's that terrible
19:25:54 <Iceland_jack> Welkin: It really isn't too bad when you have some extensions
19:25:56 <geekosaur> record syntax may be the #1 inducement to use lens
19:25:56 <merijn> Unless you have nested records
19:25:58 <Welkin> well, for accessing deeply nested data
19:26:09 * merijn rarely has nested records :)
19:26:09 <haasn> My favorite thing about record syntax is pattern matching on them
19:26:32 <haasn> I like Foo{..} type patterns, too
19:26:38 <geekosaur> it's fine for simple cases, for example xmonad uses config records extensively and the syntax doesn't get into the way much
19:26:44 <haasn> But I probably shouldn't
19:26:45 <geekosaur> but we don't nest records very much
19:26:46 <Iceland_jack> My favourite thing abuot record syntax is returning records like this
19:26:47 <Iceland_jack>     foo ... = let
19:26:47 <Iceland_jack>       name = "..."
19:26:47 <Iceland_jack>       age  = 24
19:26:50 <Iceland_jack>       in Person{..}
19:27:21 <haasn> Iceland_jack: I assume that works with “foo = Person{..} where name = "..."; age = 42” ?
19:27:27 <echo-area> I'm reading ghc's source code.  Is it some kind of literal programming practice?
19:27:31 <Iceland_jack> yes
19:27:40 <merijn> int-e: Basically, I have the following type: http://lpaste.net/110094 which I use in a ReaderT to provide some info, I figured I'd let the user use the same type to provide the configuration of a socket. Now the problem is that the "socketType" field should match whatever socket is being initialised, so I wanna stop users from "screwing it up"
19:27:50 <haasn> Although at that point you're not winning much over foo = Person { name = "..."; age = 42 }
19:28:01 <Iceland_jack> haasn: In simple cases that's right
19:28:03 <echo-area> Iceland_jack: Cool.
19:28:17 <merijn> int-e: I figure I can just provide a "default" record where users can update values and if I then hide the socketType field I can just manually set it to the right value in the socket creation function
19:28:39 <Iceland_jack> but it can be nice to build up your structure without having to cram it all into the record fields (for example defining functions without lambda abstractions isn't possible in record syntax haasn)
19:29:00 <haasn> Iceland_jack: Oh, that's an interesting example
19:29:08 <int-e> merijn: oh, note that it may not do what you want. A user might just use the constructor without the field names.
19:29:15 <Iceland_jack>     Foo { fn x = x + x * x }
19:29:15 <Iceland_jack> can be written
19:29:15 <Iceland_jack>     let fn x = x + x * n
19:29:15 <Iceland_jack>      in Foo{..}
19:29:23 <merijn> int-e: Not if I don't export that constructor :)
19:29:25 <haasn> let runIdentity x = y in Identity{..}
19:29:27 <int-e> merijn: err, right.
19:29:57 <merijn> Hence I'd give a default record
19:31:29 <merijn> I think I'm just gonna go with that, because otherwise I'd have to expose the sockettype in both the SocketConfig type and the socket type and enforce it that way, which becomes rather messy and clumsy
19:35:16 <merijn> Man, DataKinds and GADTs should just imply KindSignatures >.<
19:36:07 <c_wraith> you mean each should individually?
19:37:05 <mvc`> hey, has anyone been able to get copilot to build recently? (I'm on 7.8.3)
19:37:45 <cschneid> is there an alternate literal string syntax for when I have quotes in my string? in ruby I can do %w{"Whatever"}.  I'm writing a test w/ some literal json in it
19:38:34 <lispy> cschneid: no save for the quasiquoter
19:38:50 <cschneid> that's too bad :) no biggie, just wanted to avoid a ton of backslashes
19:39:04 <lispy> the quasiquoter is a ghc extension that lets you make your own syntax inside brackets
19:39:09 <merijn> cschneid: You can quasiquote it?
19:39:15 <lispy> So you could make an alternative string reader that supports it
19:39:25 <c_wraith> It's a pretty trivial quasiquoter!
19:40:14 <merijn> hmm, anyone got a good synonym for type that isn't a keyword? >.>
19:40:34 <Welkin> type'?
19:40:34 <lispy> then it would be like [w|"Whatever|]
19:40:45 <lispy> Typ
19:40:53 <Welkin> tvpe
19:41:07 <Welkin> those are all terrible though
19:41:15 <merijn> lispy: Typ is not a valid variable, plus it's terrible :)
19:41:44 <lispy> merijn: I've seen ty for type quite often
19:41:55 <lispy> While it's not the best it's sort of recognizable
19:41:58 <Welkin> mytype
19:42:15 <int-e> sort
19:42:18 <geekosaur> flavo(u)r?
19:42:37 <Welkin> this isn't particle physics
19:43:21 <geekosaur> variety
19:43:29 <croyd> Is it just me or does the last example given in the transformers library for the MonadTrans class fail to typecheck? http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Class.html
19:43:40 <cschneid> merijn: how will I quasiquote it?
19:43:45 <cschneid> I'm not sure how that works :)
19:43:50 <pavonia> тype
19:43:55 <croyd> It seems like the innermost monad of InterpM should be IO instead of []
19:44:22 <chirpsalot> Stupid question, but does pandoc require GHC 7.8 to build now?
19:44:46 <int-e> cschneid: http://hackage.haskell.org/package/raw-strings-qq-1.0.2/docs/Text-RawString-QQ.html looks usable
19:45:12 <cschneid> int-e: thanks - I'll just drop it as a separate file and read it in :) easier that way
19:45:22 <merijn> cschneid: QuasiQuoter are a TH haskell thing, they (at compile time) consume a String and produce quoted haskell as output and then your program will compile using that
19:46:02 <merijn> lispy: I feel like "ty" is not very explicit when it's a type variable occuring all over the place in a public API :)
19:47:25 <merijn> Hmm, maybe I should just go with the "sock" part of SocketType, rather than the type part
19:50:55 <merijn> My current haskell code: http://i.imgur.com/6GWGBQN.jpg
19:57:45 <bergey> chirpsalot: latest pandoc builds fine for me with 7.6.3
19:58:16 <benzrf> alright i have about 600,000 lines of Text in a variable
19:58:24 <benzrf> each line is a Read-able value
19:58:28 <benzrf> how can i get a list of them
20:02:46 <gfixler> benzrf: it's just one giant string?
20:03:28 <benzrf> one giant Text
20:03:31 <Welkin> just like makefiles!
20:04:39 <copumpkin> benzrf: apply lines to it, map read over the result?
20:04:48 <benzrf> copumpkin: there's no read on Text
20:04:52 <benzrf> im not sure i should unpack it all
20:04:58 <benzrf> @hoogle Read a => Text -> a
20:05:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:05:00 <lambdabot> Prelude id :: a -> a
20:05:01 <lambdabot> Data.Function id :: a -> a
20:05:03 <benzrf> :\
20:05:10 <benzrf> i'll try
20:05:10 <copumpkin> it's going to have to unpack it at some point if you want to use Read
20:05:15 <merijn> Write an attoparsec parser and stream it?
20:05:17 <copumpkin> since the Read interface specifies String
20:05:20 <merijn> Read sucks for this
20:05:24 <copumpkin> agreed
20:06:29 <benzrf> huh
20:06:30 <benzrf> it was fairly fast
20:06:32 <benzrf> :-D
20:07:14 <shachaf> benzrf: There's no reason to use @hoogle in the channel unless the response is relevant to someone else.
20:07:17 <Welkin> benzrf's face when
20:07:35 <shachaf> (Or any other lambdabot command, for that matter.)
20:07:45 <benzrf> Welkin: bls
20:07:46 <chirpsalot> bergey: thank you kindly :). I am trying to contribute a patch and I was in the middle of a long cabal build going "gee, it's going to suck if this fails."
20:08:31 <Welkin> bureau of labor statistics?
20:08:36 <Welkin> BLS?
20:09:26 <Welkin> bls = boys love?
20:09:59 <benzrf> please -> pls -> bls
20:10:09 <benzrf> yet more corrupted once-english
20:10:09 <Welkin> you kids and your slang
20:10:28 <Welkin> is this like "habeeb it"?
20:10:39 <benzrf> yepo
20:10:42 <benzrf> *yep
20:12:12 <benzrf> ugh
20:12:18 <benzrf> it failed to read when i tried to do the diff
20:12:23 <benzrf> how do i find out what failed to read?
20:12:27 <benzrf> is there an informative-error version
20:13:08 <tabemann> use readMaybe and then put the offending string on the left-hand side of an Either when it returns Nothing?
20:13:20 <benzrf> aha found the issue
20:13:24 <benzrf> bleh
20:14:09 <merijn> Chan doesn't have an Ord instance? :(
20:14:24 <tabemann> why would it?
20:14:35 <merijn> It has an Eq instance, so why not?
20:14:43 <merijn> Now I can't put it in a Set
20:14:47 <tabemann> well it has identity but not order
20:15:07 <merijn> Given a unique identity that's orderable you can define an order
20:15:17 <Welkin> what is Chan?
20:15:28 <Welkin> :info Chan
20:15:29 <tabemann> Chan is an unbounded channel
20:15:35 <Welkin> @info Chan
20:15:35 <lambdabot> Chan
20:15:41 <merijn> Welkin: lambdabot doesn't have an info command
20:16:33 <merijn> So...what do I use as an efficient container for things that don't have an Ord instance? I need efficient insertion, deletion and enumeration
20:16:35 <tabemann> what I'd do is tag each Chan with a unique Int, and then give the containing type an Ord reference
20:17:14 <tabemann> of course that has the result that you're going to have to manage keeping these Ints unique
20:17:25 <tabemann> s/reference/instance
20:18:01 <tabemann> data OrdChan a = OrdChan (Chan a, Int)
20:19:10 <tabemann> instance Eq (OrdChan a) where (_, x) == (_, y) = x == y
20:19:21 <shachaf> Either use newtype or don't use a tuple.
20:19:47 <tabemann> sorry, OCamlism
20:20:22 <tabemann> data OrdChan a = OrdChan (Chan a) Int
20:20:46 <tabemann> instance Eq (OrdChan a) where (OrdChan _ x) == (OrdChan _ y) = x == y
20:21:01 <BMeph>  data OrdChan a = Chan a `OrdChan` Int  -- Haskellism FTW ;þ
20:21:24 <merijn> Anyway, I just remembered unordered-containers, which is probably a way better solution
20:21:40 <tabemann> are Chans Hashable?
20:21:48 <trap_exit> is it possible to tell haskell, that : and [] should refer to the DiffList, rather than a normal list ?
20:21:53 <trap_exit> err, :, [], and ++, should be difflist rather than normal list ?
20:22:06 <trap_exit> I ahve some code, where I do't want to think deepl about optimizing how ++ is used
20:22:12 <merijn> tabemann: Can just make them hashable
20:22:22 <merijn> tabemann: standalone deriving + generic
20:22:34 <carter> tabemann merijn  are IORefs hashable?
20:22:36 <carter> ohhh
20:22:38 <carter> use StableName
20:22:41 <carter> to get hash
20:22:48 <tabemann> I was thinking StableName
20:22:53 <tabemann> but StableName is expensive
20:22:55 <geekosaur> (++) could be done fairly easily, (:) requires RebindableSyntax, I think [] is so deeply hardwired that you lose
20:22:59 <carter> tabemann: says who?
20:23:01 <carter> how?
20:23:09 <carter> tabemann: you just need to use it to extract a hash
20:23:11 <trap_exit> gekosaur: bnoted, thanks
20:23:23 <trap_exit> o right, ++ is just (++)
20:23:27 <carter> tabemann: but also, how do you define Eq for an IORef?
20:23:31 <tabemann> doesn't StableName mess with the garbage collection somehow
20:23:32 <carter> thats a weird thing
20:23:36 <trap_exit> yeah, [] is part of syntax
20:23:43 <carter> tabemann: if you dont knowhow it works, dont assume its slow
20:23:52 <carter> tabemann: its only slow if you use a buggy ghc build
20:23:57 <carter> like 7.8.1 or 7.8.2
20:24:06 <merijn> carter: I don't think StableName is good
20:24:19 <carter> merijn: well, Hashing on a mutable structure aint right iether
20:24:20 <merijn> carter: StableName doesn't guarantee an object always has the same StableName
20:24:32 <carter> merijn: well, what does? :p
20:25:06 <merijn> carter: I need to avoid not being able to insert or being unable to delete an element from a Set
20:25:11 <merijn> Because that's break my code
20:25:23 <carter> merijn: reallyUnsafePtrEquality ?
20:26:00 <merijn> carter: Can't implement that anyway, I can't get at the underlying MVar to compute that
20:26:16 <carter> copy and paste :)
20:26:21 <carter> and expose the innards
20:26:46 <merijn> carter: Even then I'm not sure it works, so time to go to the drawing board
20:27:02 <carter> merijn: the problem is you've not descirbed the high level goal
20:27:26 <shachaf> Isn't the fairly high-level goal "have a Set of Chans"?
20:27:41 <carter> well, depends on what the end application is right?
20:27:54 <merijn> carter: The high level goal is: I need a collection with efficient insertion, deletion and enumeration for Chan
20:28:01 <carter> ok
20:28:11 <carter> is this for multiplexing stuff for your native zmq thingy?
20:28:14 <nshepperd> if you use Seq you almost have a set, except you need to iterate to find the Chan you want to delete
20:28:25 <merijn> carter: Yes
20:28:29 <carter> hrm
20:28:29 <shachaf> That is pretty far from Set.
20:28:37 <carter> yeah
20:28:55 <nshepperd> well, it doesn't enforce uniqueness
20:28:59 * hackagebot simple-pipe 0.0.0.26 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.26 (YoshikuniJujo)
20:29:07 <shachaf> I think this is a performance thing.
20:29:20 <merijn> carter: Basically, clients can subscribe/cancel to notifications, so I need a Map of subscriptions and for every subscribtion a set of Chan that wants messages for it
20:29:37 <shachaf> Anyway, I don't think you're going to manage it easily with plain old Chans.
20:29:51 <merijn> nshepperd: O(n) is a pretty terrible asymptotic for deletion...
20:30:12 <carter> merijn: could you write down what the end structure  has to do? in a collected way?
20:30:13 <merijn> It seems odd, providing an Ord instance for Chan in base shouldn't be hard, no?
20:30:23 <shachaf> It has to do everything Set does.
20:30:25 <carter> merijn: .... how would you or di?
20:30:31 <shachaf> I don't think merijn's question is unreasonable.
20:30:41 <carter> i dont' disagree
20:30:46 <carter> i'm just tired and i should log out :)
20:30:47 <carter> night all
20:30:52 <merijn> carter: I just said what it had to do :)
20:31:08 <merijn> carter: For N subsriptions track which M clients are intereste in that "topic"
20:31:11 <tabemann> would Ord for something like a Chan break referential transparency?
20:31:12 <nshepperd> actually scratch that, there's no point using Seq when a plain list will do the same thing
20:31:19 <merijn> tabemann: No, why would it?
20:31:44 <shachaf> A Chan is made of MVars, and there's no Ord on MVar either.
20:31:55 <shachaf> An MVar is made of MVar#. MVar# equality is implemented with pointer equality.
20:31:55 <merijn> shachaf: Which should also be there, IMO
20:31:59 <tabemann> because multiple instances of the same newChan would result in multiple Chans that are not equal
20:32:07 <shachaf> Pointer comparison is trickier than pointer equality because the GC can move things around
20:32:09 <copumpkin> tabemann: it's an IO action
20:32:25 <merijn> tabemann: Right and this is a problem because?
20:32:26 <tabemann> but instead of them being all not equal, they have an order to them
20:32:45 <merijn> tabemann: Not equal things can have an order easily?
20:33:01 <tabemann> copumpkin: but compare doesn't return an IO monad
20:33:10 <shachaf> merijn: I would guess that your best bet is adding your own identifier that you can order things by.
20:33:23 <merijn> tabemann: Why would you need to be in the IO monad?
20:33:27 <copumpkin> tabemann: IORef has an Eq instance. Do you have a problem with that?
20:33:28 <merijn> tabemann: Chan is just a value
20:34:07 <tabemann> this is like how == can't do value equality on an IORef because that would break referential equality
20:34:22 <merijn> tabemann: It does do value equality on IORef...
20:34:23 <copumpkin> yes, but nobody's asking it to do value ordering
20:34:40 <merijn> tabemann: It just doesn't do equality on the value *inside* the IORef
20:34:45 <merijn> But that's irrelevant
20:35:20 <tabemann> forget my argument
20:35:53 <tabemann> you could do it, as if newChan tagged each of its Chans itself, and did equality on those
20:36:07 <tabemann> but it doesn't, so you'll have to add your own tags
20:36:14 <chirpsalot> "conduit-1.1.7 failed during the building phase." Ugh. Does this have external dependencies?
20:36:24 <chirpsalot> And how do I find out?
20:36:33 <Welkin> transformers?
20:36:38 <lpsmith> Hmm, is there a way to implement readMVar fdRef >>= threadWaitRead  atomically?
20:36:41 <Welkin> use -v
20:36:51 <Welkin> or --verbose[3]
20:37:00 <merijn> lpsmith: Define atomically?
20:37:13 <tabemann> you can't do anything with MVar atomically
20:37:21 <merijn> tabemann: Not true
20:37:35 <merijn> Since base 4.7 readMVar no longer does a take/put
20:37:36 <lpsmith> merijn, well, what I really need the putMVar fdRef fd >>= threadWaitRead fd  to be atomic
20:38:14 <tabemann> merijn: I mean you cannot combine it with other operations to make bigger things that're atomic
20:38:45 <merijn> lpsmith: You still haven't said what you mean by atomic
20:38:53 <merijn> What are you worried about happening
20:39:27 <Welkin> merijn: nuclear fission
20:39:43 <lpsmith> Given that there is some theoretical risk of putting the file descriptor back into the MVar,  yielding,  having another thread read the mvar,  close the descriptor,  and then perhaps a third thread creating a new descriptor,  then the original thread waiting on the new descriptor,  not the original descriptor.
20:40:25 <merijn> lpsmith: Use STM?
20:40:42 <lpsmith> You can't threadWaitRead from STM, can you/
20:41:00 <merijn> You can \o/
20:41:04 <merijn> Since base 4.6 or 4.7
20:41:15 <lpsmith> hmm, interesting.
20:41:20 <merijn> threadWaitReadSTM in GHC.Conc.IO
20:41:27 <chirpsalot> cabal fails here: https://github.com/snoyberg/conduit/blob/master/conduit/Data/Conduit/Internal.hs#L394 with "error: invalid preprocessing directive" on the #-}
20:42:04 <lpsmith> merijn, thanks
20:42:16 <Algebr> I can't seem to find good documentation about the stuff cabal makes/does after cabal install in a sandbox
20:43:19 <chirpsalot> Does conduit need newer fancy GHC stuff?
20:44:03 <merijn> shachaf: Ugh, even if I want to explicitly label Chan's I'd still need a global source of unique id's :\
20:44:09 <Welkin> I think I had an issue with conduit failing to build a while back
20:44:16 <chirpsalot> INLINE seems very old...
20:44:19 <Welkin> and it was because of an outdated transformers package
20:44:20 <chirpsalot> How strange.
20:44:37 <shachaf> merijn: Yep.
20:44:45 <chirpsalot> Welkin: I have transformers-0.3.0.0
20:44:53 <merijn> This sucks donkey balls
20:45:02 <merijn> I was so nice and bottleneck free :(
20:45:07 <Welkin> merijn: donkey balls are a delicacy in parts of the world
20:45:12 <nshepperd> merijn: you could have a next-id number stored together with the set of Chans, and give out an id when someone registers their Chan
20:45:12 <mokus_> copumpkin: wasn't around when you asked, but i am for a few moments now
20:45:16 <Welkin> so that may mean something wonderful
20:45:32 <copumpkin> mokus: just wanted to check that the BSD licensing of categories met with your approval
20:45:33 <merijn> nshepperd: Except that channels are being created constantly and concurrently :\
20:45:52 <Guest44944> copumpkin: definitely
20:45:57 <copumpkin> sweet :)
20:46:02 <copumpkin> thanks!
20:46:19 <mokus_> dang, not quick enough with nickserv
20:46:29 <nshepperd> merijn: that's okay, you only give a Chan an id when it gets registered for an notification
20:47:01 <chirpsalot> Welkin: what transformers version do you have? I just started building pandoc in a fresh cabal sandbox, so everything should be gravy?
20:47:08 <mokus_> copumpkin: i'm fine with pretty much any liberal license up to and including public domain, and would even consent to a more restrictive one if my particular contributions could be exempted ;)
20:47:18 <copumpkin> hah
20:47:27 <copumpkin> okay, commercial license on the agda category theory library
20:47:29 <tabemann> put the next-id number in a TVar, so you can update it atomically
20:47:30 * copumpkin will be rich
20:48:04 <merijn> nshepperd: Oh, actually, I can just use a map and return an unregister callback with whatever key I used, that'd work...
20:48:05 <copumpkin> :)
20:48:07 <mokus_> how's that library doing these days?  i haven't had a chance to play with it lately
20:48:30 <copumpkin> mokus_: not much activity recently, but Fuuzetsu wanted to package it for nix and asked about a license
20:48:43 <copumpkin> I haven't really done anything on it in a couple of years
20:49:23 <merijn> Plus, then I can't just use IntMap
20:49:29 <merijn> s/can't/can
20:49:43 <nshepperd> yes, that's a more haskelly way of doing it :)
20:56:20 <Javran> how can I make a binary tree zipper an instance of comonad?
20:57:21 <bobbbbbb> hi
20:57:26 <bobbbbbb> i found this https://github.com/jaspervdj/haskell-irc
20:57:35 <shachaf> That depends on what your data type is.
20:57:41 <Javran> http://lpaste.net/6768051319493099520 This is so far I have, I don't know how to implement "duplicate" properly so that (duplicate . duplicate) = (fmap duplicate . duplicate) holds
20:59:36 <benzrf> ugh
20:59:44 <jle`>  hi bobbbbbb
20:59:46 <benzrf> is there an implementation of diffing on *streams*
21:00:07 <benzrf> i.e., you feed it two pipes or conduits or whatever, and get a pipe or conduit or whatever of diff
21:00:20 <benzrf> i have something too long to comfortably fit in a linked list (or an array)
21:01:43 <benzrf> Javran: how do u envision this bein used
21:02:18 <bobbbbbb> ohai
21:02:33 <bobbbbbb> how r u jle`
21:03:06 <jle`> im ok bobbbbbb how are you
21:03:23 <jle`> benzrf: diff?
21:03:28 <bobbbbbb> im chillin
21:03:49 <bobbbbbb> im reading about elm but Im too lazy to comoile it
21:04:36 <Javran> benzrf: every node value is updated according to the value of itself, its children and its parent
21:04:38 <benzrf> jle`: https://hackage.haskell.org/package/Diff-0.3.0/docs/Data-Algorithm-Diff.html
21:04:56 <benzrf> Javran: ok, look at extend
21:04:59 <benzrf> i do
21:05:06 <benzrf> extend f someTree
21:05:13 <benzrf> what will f be given for a particular node?
21:05:33 <jle`> benzrf: looks like you could just chunk it up, right?
21:05:36 <benzrf> fyi this sounds more like a tree comonad than a zipper comonad...
21:05:37 <benzrf> jle`: oh?
21:05:46 <jle`> getDiff :: Eq t => [t] -> [t] -> [Diff t]
21:05:48 <jle`> hm
21:05:50 <jle`> maybe not
21:06:05 <benzrf> nah man i want the chunked version
21:06:07 <Javran> benzrf: I think that's a "tree zipper"
21:06:23 <benzrf> Javran: er, more like a tree comonad than a tree zipper comonad
21:06:24 <benzrf> w/e
21:06:53 <bobbbbbb> compiling is for the birds
21:07:08 <Javran> benzrf: but with a tree comonad, how can I access one's parent?
21:07:10 <bobbbbbb> im a theoretical computer programmer
21:07:13 <jle`> benzrf: you might be able to work with https://hackage.haskell.org/package/Diff-0.3.0/docs/src/Data-Algorithm-Diff.html#getDiffBy
21:07:42 <benzrf> Javran: huh?
21:07:50 <benzrf> oh i think i see your point
21:07:54 <benzrf> ooooooh i get it
21:07:58 <benzrf> right, ok
21:08:18 <benzrf> f receives a zipped-to-the-node zipper for each node?
21:08:46 <Javran> benzrf: yes
21:09:02 <shachaf> bobbbbbb: Please behave more constructively.
21:10:14 <Javran> benzrf: http://lpaste.net/6768051319493099520 here is my attempt, just toy code so sorry if that looks messy
21:10:32 <benzrf> Javran: hmm
21:10:50 <benzrf> Javran: it should only operate on child nodes of the currently-focused subtree, right?
21:11:05 <benzrf> or am i makin assumptions
21:11:43 <Javran> I want to use zipper here so I can also access its parent.
21:11:58 <benzrf> Javran: i mean
21:12:13 <benzrf> let's say you have a zipper zipped to some sub-bit of the tree
21:12:27 <bobbbbbb> shachaf: no problem brother
21:12:30 <benzrf> if you fmap, you only want to modify the focused tree, right?
21:12:37 <benzrf> not the parts you've zipped past
21:12:41 <benzrf> oh wait
21:12:45 <benzrf> no you cant get away with doing that
21:12:46 <bobbbbbb> you know i like to have some fun sometimes
21:12:48 <benzrf> bleh
21:15:34 <Javran> benzrf: I have no idea how can I make `[Partial BTZ]`properly to satisfy comonad properties
21:16:51 <benzrf> Javran: im not certain it works, man
21:17:00 <benzrf> @google comonad zipper
21:17:01 <lambdabot> http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
21:17:01 <lambdabot> Title: A Neighborhood of Infinity: The Monads Hidden Behind Every Zipper
21:17:06 <benzrf> hm
21:17:40 <benzrf> replace the value in each node with that subtree?
21:17:55 <benzrf> seems like the most obvious action...
21:21:34 <athan> let fibs n = take n $ foldr (*) 1 [1..]
21:21:34 <athan> @let fibs n = take n $ foldr (*) 1 [1..]
21:21:34 <lambdabot>  Defined.
21:21:34 <athan> > fibs 10
21:21:34 <lambdabot>  No instance for (GHC.Show.Show a0)
21:21:34 <lambdabot>    arising from a use of ‘M15526422869173776638586.show_M15526422869173776638...
21:21:34 <lambdabot>  The type variable ‘a0’ is ambiguous
21:21:34 <lambdabot>  Note: there are several potential instances:
21:21:34 <lambdabot>    instance [safe] GHC.Show.Show
21:21:34 <athan> ):
21:21:34 <jle`> :t fibs
21:21:34 <lambdabot> (Num [a], Enum [a]) => Int -> [a]
21:21:34 <athan> jle`: what did I do? :(
21:21:43 <jle`> :t foldr (*) 1 [1..]
21:21:44 <lambdabot> (Num b, Enum b) => b
21:22:04 <jle`> you are take n-ing a (Num b, Enum b) => b
21:22:06 <jle`> :t take 1
21:22:08 <lambdabot> [a] -> [a]
21:22:19 <jle`> so if you use something on take n, it is [a]
21:22:48 <danclien> Can someone help me decipher the type constraints for this function type? – insert :: (PersistMonadBackend m ~ PersistEntityBackend val, PersistEntity val) => val -> m (Key val)
21:23:06 <danclien> i.e. What does `PersistMonadBackend m ~ PersistEntityBackend val` do?
21:23:07 <jle`> so something can be both [a] and (Num b, Enum b) => b, if b ~ [a]
21:23:19 <shachaf> danclien: ~ means type equality.
21:23:19 <begriffs> I feel like I'm making a dumb mistake, can anyone spot it? JSON.eitherDecode "{\"a\":2}"  evaluates to Left "when expecting a (), encountered Object instead"
21:23:31 <jle`> danclien: i think in this context it's a type alias
21:23:31 <shachaf> So (a ~ b) => ... means the type a is equal to the type b.
21:23:42 <athan> jle`: !!
21:23:45 <athan> thank you :)
21:23:53 <jle`> although that's probably the wrong word to use for it
21:23:57 <athan> can I map into catamorphisms... :O
21:24:03 <jle`> i do stuff like (thing ~ SomethingComplex) => thing -> b
21:24:26 <jle`> i guess it means something like "`thing` is constrained to be equivalent to the type SomethingComplex"
21:24:50 <danclien> Could it be written as `(m ~ val, PersistMonadBackend, PersistEntityBackend val, PersistEntity val)`?
21:24:58 <jle`> hm no
21:25:01 <jle`> er
21:25:05 <danclien> `(m ~ val, PersistMonadBackend m, PersistEntityBackend val, PersistEntity val)`
21:25:11 <shachaf> Presumably m and val aren't the same type.
21:25:38 <shachaf> And PersistMonadBackend isn't a class.
21:25:43 <shachaf> So that constraint doesn't make sense.
21:25:53 <shachaf> Do you know what PersistMonadBackend and PersistEntityBackend are?
21:26:05 <danclien> shachaf: Not sure. Let me search real quick.
21:26:13 <shachaf> (I don't but I can guess. But you can do better than guess, you can look up the documentation.)
21:26:18 <danclien> I assumed it was a type class at first.
21:26:31 <begriffs> (Oh, JSON.eitherDecode requires a type hint that's all)
21:27:34 <Javran> benzrf: not sure if that works. but I have to leave, thanks for the help anyway!
21:30:32 <danclien> Hmm... class MonadIO m => PersistStore m where; type PersistMonadBackend m
21:30:46 <danclien> You can define a type for a type class?
21:32:37 <danclien> For PersistEntityBackend: class PersistEntity record where; type PersistEntityBackend record
21:33:05 <shachaf> Look up "type families" to understand this.
21:33:11 <shachaf> It's a GHC extension.
21:33:14 <danclien> shachaf: Thanks.
21:33:37 <shachaf> (Also, it's class ... where ..., no semicolon.)
21:34:08 * hackagebot wheb-redis 0.0.1.0 - Redis connection for Wheb  http://hackage.haskell.org/package/wheb-redis-0.0.1.0 (hansonkd)
21:35:03 <danclien> shachaf: Got it. :)
21:35:23 <danclien> The number of language extensions in GHC is starting to kick my butt.
21:49:10 * hackagebot wheb-mongo 0.0.3.0 - MongoDB plugin for Wheb  http://hackage.haskell.org/package/wheb-mongo-0.0.3.0 (hansonkd)
21:49:12 * hackagebot simple-pipe 0.0.0.27 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.27 (YoshikuniJujo)
21:53:51 <chrisdotcode> can lambdabot generate random numbers, or flip coins?
21:54:06 <copumpkin> @dice
21:54:07 <lambdabot> unexpected end of input: expecting number, "d" or "("
21:54:10 * hackagebot wheb-strapped 0.0.2.0 - Strapped templates for Wheb  http://hackage.haskell.org/package/wheb-strapped-0.0.2.0 (hansonkd)
21:54:18 <chrisdotcode> @dice 1d6
21:54:18 <lambdabot> chrisdotcode: 5
21:54:20 <shachaf> /msg lambdabot 1d12
21:54:22 <chrisdotcode> but no coin flip
21:54:30 <chrisdotcode> @dice 1d2
21:54:31 <lambdabot> chrisdotcode: 2
21:54:35 <chrisdotcode> guess that works
21:55:54 <glguy_> ?dice 4d5+6
21:55:54 <lambdabot> glguy_: 8 + 6 => 14
21:59:54 <echo-area> It is so similar to the notation in nethack
22:00:12 <ezrios> eh
22:00:39 <ezrios> I have a cabal project set up with one .hs file
22:00:56 <ezrios> it builds fine, but when I use `cabal repl` none of the top-level names in the .hs file are available
22:01:00 <ezrios> other than `main`
22:01:10 <ezrios> which I can evaluate and everything works normally
22:01:34 <ezrios> how can I get at the other top-level names in the file?
22:01:40 <ezrios> they're not in a module
22:01:52 <ezrios> this is the file https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/doc/examples/SlotMachine.hs
22:03:12 <ezrios> fucking cabal
22:03:18 <ezrios> nothing but problems
22:04:38 <joelteon> no kidding
22:05:05 <ezrios> no idea how the program is executable but none of the top-level names (which are used by main) are in scope
22:05:52 <Axman6> do you have module Main where up the top?
22:05:57 <ezrios> Axman6: no
22:06:02 <ezrios> it's not in a module
22:06:06 <Axman6> also, have you tried :l Main?
22:06:08 <Axman6> it is a module
22:06:30 <ezrios>     Could not find module `Main'
22:06:42 <glguy_> There's no "not in a module"
22:06:56 <glguy_> If you don't specify then you automatically get: module Main (main) where
22:07:15 <ezrios> glguy_: I've also tried qualifying the names
22:07:30 <ezrios> ah I'm a dumbass
22:07:59 <ezrios> wait no it still doesn't work ._>
22:08:00 <ezrios> ._.
22:08:03 <lpsmith> merijn, threadWaitReadSTM,  while definitely useful,  doesn't cover my use case,  as I would really need to read the file descriptor in STM.
22:08:11 <glguy_> Instead of blaming cabal, explain to us what you don't know how to do
22:08:16 <glguy_> and then we can help you
22:08:26 <glguy_> "I want to _____ but I don't know how"
22:08:35 <lpsmith> threadWaitReadSTM doesn't allow you to read a file descriptor from say a TMVar and then wait on it.
22:08:42 <lpsmith> can't be done in one transaction.
22:08:56 <ezrios> glguy_: I'm trying to get at the type of a top-level name in this (https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/doc/examples/SlotMachine.hs) file
22:09:07 <ezrios> I have a cabal project set up with only that file in it
22:09:11 <ezrios> the project builds
22:09:12 * hackagebot Wheb 0.3.0.0 - The frictionless WAI Framework  http://hackage.haskell.org/package/Wheb-0.3.0.0 (hansonkd)
22:09:14 <ezrios> the executable runs
22:09:22 <ezrios> but when I use `cabal repl` none of the top-level names are in scope
22:09:28 <glguy_> put your .cabal file on lpaste?
22:09:36 <glguy_> Oh, try this:
22:09:39 <glguy_> :m *Main
22:09:40 <Axman6> you are loading the file into the repl right?
22:10:12 <superlinux-hp> hi all. someone asked me whether haskell is the future in programming or whether it has a future. what can you say in this regards?
22:10:16 <ezrios> http://lpaste.net/6831545581966458880
22:10:30 <superlinux-hp> I am still a beginner.
22:10:30 <ezrios> Axman6: I invoke as `cabal repl`
22:10:33 <Axman6> superlinux-hp: yes
22:10:34 <dmj`> superlinux-hp: yes
22:10:39 <Axman6> ha
22:10:44 <ezrios> any additional filenames/arguments passed to `cabal repl` are just ignored with a warning
22:10:44 <dmj`> :P
22:10:48 <Axman6> @quote stereo
22:10:48 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
22:10:55 <Axman6> @quote stereo
22:10:56 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
22:11:03 <Axman6> bleh
22:11:12 <superlinux-hp> please don't say so just because you love/like haskell. just tell me why and how?
22:11:51 <superlinux-hp> I asked this question because I myself don't know what would such a future be.
22:12:05 <ezrios> glguy_: http://lpaste.net/6831545581966458880
22:12:44 <glguy_> ezrios: http://lpaste.net/6831545581966458880
22:13:03 <Axman6> superlinux-hp:  the most honest answer is no one knows. many languages have taken a lot of inspiration from haskell and the ideas are being more widely embraced
22:13:23 <dmj`> superlinux-hp: lots of reasons, the multicore age is upon us, haskell can distribute load evenly across processors, unlike conventional multicore lock-based programming that hasn't changed for decades. Also, types, you can remove all manner of bugs (a $20 billion industry), by enforcing invariants at compile time, it only gets better when you hit dependently typed programming.
22:13:23 <dmj`>  
22:13:27 <ezrios> glguy_: what the hell
22:13:32 <ezrios> I only have the symbol `main :: IO ()`
22:13:52 <glguy_> ezrios: did you try running the GHCi command,    :m *Main
22:13:53 <glguy_> ?
22:14:13 <superlinux-hp> I really liked the idea of haskell tries to clean the bad reputation about recursion
22:14:16 <ezrios> glguy_: tells me that Main is not interpreted, `:add *Main`
22:14:30 <ezrios> so I `:add *Main`, and:
22:14:40 <glguy_> ezrios: It's using the compiled version of the code. You can either add "module Main where" to the top
22:14:42 <glguy_> or cabal clean
22:14:51 <dmj`> superlinux-hp: never knew recursion had a bad reputation
22:14:52 <Axman6> no one worth listening to thinks recursion has a bad name. like all programming tools it can be ,isused but it can also lead to incredibly clear code
22:15:02 <ezrios> gah
22:15:03 <Axman6> misused*
22:15:05 <ezrios> glguy_: I see, thanks
22:15:35 <superlinux-hp> dmj`, you know.. it's preferred to use normal loops as much you canm because recursion has bad performance generally.
22:15:54 <superlinux-hp> that kind of reputation i am talking about.
22:15:57 <Axman6> superlinux-hp: thats not really true
22:17:19 <Axman6> firstly, any decent compiler will turn recursion that can be into nonallocating loops. secondly, there are plenty of algorithms which cannot be implemented using loops but can with recursion (for example the ackermann function)
22:17:19 <dmj`> superlinux-hp: stack overflows are possible with recursion, but you can also accumulate a variable in the same way with a loop during recursion (tail call optimization) to remedy that problem.
22:17:37 <Axman6> dmj`: sometimes
22:17:42 <dmj`> sure
22:18:15 <Axman6> recursion is strictly more powerful than looping because all loops can be implemented with recursion but not the other way around
22:18:20 <superlinux-hp> anyways.. I liked recursions in haskell. very easy to define.
22:18:42 <Axman6> its pretty easy in most languages =)
22:19:36 <dmj`> It's also easier to prove, since its induction. Proving program correctness with loop invariants doesn't seem as rigorous. Recursion can allow you to capture the recurrence relation, then find a closed form.
22:19:53 <superlinux-hp> I am reading the wikibook of haskell, and I record videos on youtube based on my understanding of the book.
22:20:21 <superlinux-hp> I am now in chapter 12 of the book "more about lists"
22:23:06 <superlinux-hp> If I want to make money from using haskell, what topics I should write apps using haskell? I know I can write generally anything using haskell, but there should be something haskell is known for commercially.
22:23:56 <dmj`> superlinux-hp: its a general purpose programming language, in the same way c and python are used to make money, so can haskell
22:24:55 <dmj`> superlinux-hp: the internet is super popular these days, maybe a website
22:25:45 <superlinux-hp> but there is no such case of "I have to hire a haskell programmer because i cannot finish this task unless I have him" , isn't?
22:26:48 <dmj`> superlinux-hp: sure there is, if the code base is in haskell. It's harder to find haskell code bases then say, python code bases, especially commercial code bases.
22:28:03 <pjdelport> superlinux-hp: Neat.
22:28:21 <superlinux-hp> pjdelport, what's neat?
22:28:27 <pjdelport> superlinux-hp: You videos. :)
22:28:32 <superlinux-hp> Ah thanks.
22:28:44 <superlinux-hp> I am following the book almost verbatim.
22:28:46 <dmj`> superlinux-hp: do you have links to your videos?
22:28:52 <superlinux-hp> yep!.
22:28:56 <superlinux-hp> just a sec
22:29:11 <pjdelport> superlinux-hp: For commercial Haskell use, by the way, see http://www.haskell.org/haskellwiki/Haskell_in_industry and http://cufp.org/
22:29:17 <superlinux-hp> This is in english: https://www.youtube.com/playlist?list=PLsAEIIjTPIo_4sCkXOPVzbgPCyqN-JSd8
22:29:32 <superlinux-hp> this is in Arabic: https://www.youtube.com/playlist?list=PLsAEIIjTPIo8HdQ-DniYSuNTp3Sw0vFNR
22:29:38 <superlinux-hp> I am an arab.
22:31:41 <superlinux-hp> what made me record the videos is that someone on some arab facebook group of novice programmers/students, asked to see such videos. so I said let's go after I made some statistics on the demand.
22:39:17 * hackagebot memcached-binary 0.1.1.1 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.1.1.1 (HirotomoMoriwaki)
23:14:07 <Sizur> question to somebody who knows ocaml here: is there a lib of modules that mimic haskell's monoids, functors, applicatives, monads, arrows, lenses, etc?
23:34:25 * hackagebot scotty 0.9.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.9.0 (AndrewFarmer)
23:39:20 <AshyIsMe> man scotty looks nice and simple
23:40:38 <jle`> my blog is on scotty
23:40:54 <jle`> simple enough project that i didn't have to worry about ugly real world stuff like authentication
23:41:38 <coppro> jle`: I've been looking for a blog platform for a while. How is it?
23:41:56 <jle`> it was my second haskell project, so if i were to do it again, i might have done it differently
23:41:59 <jle`> but
23:42:03 <jle`> i mean, there isn't that much complicated about a blog
23:42:07 <coppro> yeah
23:42:08 <jle`> i had no problems with scoty itself
23:42:26 <coppro> assuming you don't want things like searching
23:43:09 <jle`> i didn't, but if i did, i don't think it would be too much problem.  if anything, it wouldn't involve scotty
23:43:15 <jle`> scotty pretty much stays out of your way
23:47:12 <AshyIsMe> https://github.com/agrafix/Spock
23:47:20 <AshyIsMe> spock apparently has auth and other features
23:48:45 <jle`> scotty did pretty much all i needed and nothing more
23:49:26 * hackagebot xmpipe 0.0.0.0 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.0 (YoshikuniJujo)
