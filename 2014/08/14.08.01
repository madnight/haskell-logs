00:00:14 <trap_exit> glguy_: that's brilliant
00:00:18 <Zekka> Well, how do you go about understanding a feature of any language?
00:00:18 <trap_exit> glguy_: why did I not think of it?
00:00:29 <HeladoDeBrownie> jonathanj, one way might be to learn to do what the type checker does
00:00:43 <trap_exit> though there is the question of: does ghc , under some optimizations, rewrite monad ops
00:00:48 <trap_exit> since they're supposed to obey monad laws
00:01:00 <c_wraith> GHC doesn't assume the monad laws.
00:01:07 <HeladoDeBrownie> trap_exit, I was thinking of that too as a reason testing with GHC might be invalidated. So it seems we'll have to trust the report
00:01:13 <HeladoDeBrownie> Oh
00:01:28 <c_wraith> as far as GHC is concerned, a >> b >> c is not the same expression as do { a ; b ; c }
00:01:28 <HeladoDeBrownie> c_wraith, then if you want it to do so you could write your own pragmas I guess?
00:01:31 <glguy_> While we're exploring do-notation
00:01:42 <glguy_> > 1 + do 2 * 3
00:01:44 <lambdabot>  7
00:01:48 <c_wraith> HeladoDeBrownie: You could add RULES pragmas for that, yes
00:02:06 <trap_exit> HelaDeBrownie: which section of the report are we discussing ?
00:02:08 <HeladoDeBrownie> glguy_, do { expression } = expression :)
00:02:08 <Zekka> 1 + do 2 * 3; 4 * 5
00:02:13 <Zekka> > 1 + do 2 * 3; 4 * 5
00:02:15 <lambdabot>  Could not deduce (GHC.Num.Num (m a0))
00:02:15 <lambdabot>    arising from the ambiguity check for ‘e_112345’
00:02:15 <lambdabot>  from the context (GHC.Num.Num (m b),
00:02:15 <lambdabot>                    GHC.Num.Num (m a),
00:02:15 <lambdabot>                    GHC.Base.Monad m)
00:02:21 <HeladoDeBrownie> trap_exit, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
00:02:25 <Zekka> ^ the problem
00:02:48 <HeladoDeBrownie> trap_exit, does your client have tab complete? You might be able to type the first few characters of someone's nick then hit tab to finish it.
00:03:03 <HeladoDeBrownie> trap_exit, I mention this because you missed a few. :)
00:03:26 <trap_exit> Hela: I'm using webchat
00:03:30 <trap_exit> so no
00:04:06 <HeladoDeBrownie> Zekka, why's that a problem?
00:04:45 <Zekka> HeladoDeBrownie: Nothing, I was just giving an example of the caveat in glguy_'s trick
00:04:57 <Zekka> which is that it fails as soon as you start trying to compose things
00:05:17 <HeladoDeBrownie> I saw the "trick" as something of smaller scope, that you can write a single expression like that.
00:05:27 <HeladoDeBrownie> Yeah, you're totally correct.
00:05:29 <dmwit> > let be = id; lol = text "lol" in do be do be do lol
00:05:31 <lambdabot>  <hint>:1:40: parse error on input ‘do’
00:05:50 <trap_exit>  ... # haskell ... you next mission, should you choose to accept it, is to teach me how to change https://gist.github.com/anonymous/1d842cb01017127bc293 ... into a Monad Transformer
00:06:08 <Zekka> > let be = id; lol = text "lol" in do be $ do be $ do be $ do lol
00:06:10 <lambdabot>  lol
00:06:29 <trap_exit> lol
00:06:41 <glguy_> What's the caveat in my "trick"?
00:07:06 <glguy_> all that does is give you a way to see which way do-notation associated >>=
00:07:13 <trap_exit> glguy_: that ghc might assume monad laws and optimiez via reordering
00:07:44 <glguy_> You mean that it might implement do-notation wrong and then optimize it to trick you?
00:07:53 <dmwit> trap_exit: type Diff a b m = StateT a (WriterT b m) -- ?
00:08:02 <glguy_> instead of just desugaring directly to the right-associated version?
00:08:06 <dmwit> oops
00:08:18 <dmwit> type DiffT a b m = StateT a (WriterT [b] m)
00:08:19 <Zekka> glguy_: By "trick" I meant your 'put one expression in do-notation and GHC won't check if your type is a monad'
00:08:29 <glguy_> OH, that trick :)
00:08:51 * glguy_ catches up
00:09:11 * hackagebot tinylog 0.10.2 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.10.2 (ToralfWittner)
00:09:11 * hackagebot swagger 0.2 - Implementation of swagger data model  http://hackage.haskell.org/package/swagger-0.2 (ToralfWittner)
00:09:11 <trap_exit> dmwit: I want to enforce, statically, that code can not change the State in any other way
00:09:38 <Zekka> trap_exit: You could wrap it in a newtype and then not derive MonadState
00:09:41 <dmwit> trap_exit: So use a smart constructor.
00:09:55 <dmwit> trap_exit: There's no need to re-implement everything.
00:10:55 <HeladoDeBrownie> I just realized that until this moment I've been tightly equating "statically assured" and "evident from the type".
00:10:58 <glguy> Generally not a good idea to expose MonadState when making a custom monad anyway
00:14:46 <trap_exit> if I use a msart constructor
00:14:50 <trap_exit> don't I lose powers of pattern matching?
00:15:17 <trap_exit> dmwit: I'm not doubint ghtat you're right; I just don't fully understand your soultoin
00:15:22 <trap_exit> *solution*
00:16:04 <Iceland_jack> trap_exit: With the latest GHC's you can define your own patterns
00:16:16 <trap_exit> i'm on 7.8.3
00:16:25 <HeladoDeBrownie> That's the very latest
00:16:29 <Iceland_jack> right
00:16:52 <trap_exit> alright
00:16:55 <trap_exit> how do I define my onw patterns
00:17:18 <Iceland_jack> trap_exit: I wrote a short post about it https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
00:17:49 <Iceland_jack> since you want to hide the constructor you probably want unidirectional patterns
00:18:12 <trap_exit> Iceland_jack: damn that's awesome
00:19:11 <trap_exit> iceland_jack: https://www.fpcomplete.com/user/icelandj?show=all ... do you have a blog / more writings ?
00:19:41 <Iceland_jack> No I'm quite lazy publishing my own stuff :)
00:21:31 <trap_exit> dmwit; I'm now (finally) convinced you're right. Thanks!
00:23:26 * Iceland_jack might make a post about writing embedded DSLs..
01:04:12 * hackagebot ghc-mod 4.1.6 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.6 (KazuYamamoto)
01:21:44 <angerman> What is the reason for the postgres dependency in yesod with fay during the init?
01:22:05 <angerman> Can I not have no-database, but with fay, or sqlite with fay?
01:34:06 <hyPiRion> Hey there, is there any library out there which defines a Haskell language AST and makes it possible to emit as a string?
01:39:16 * hackagebot yesod-text-markdown 0.1.4 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.4 (ArashRouhani)
01:39:49 <CindyLinz> hyPiRion: like this? # https://hackage.haskell.org/package/haskell-src-exts
01:41:03 <hyPiRion> CindyLinz: that looks more or less exactly like what I need, thanks :)
01:41:17 <CindyLinz> ^^
01:52:20 <int3__> http://stackoverflow.com/questions/25076330/caching-intermediate-states-of-a-series-of-computations
01:52:32 <int3__> if thou couldst help, I would be much grateful
02:11:52 <prashant> Hi
02:12:20 <int3__> hi
02:22:07 <wirrbel> I am still a little confused about Linear Algebra and numerical array processing libraries in Haskell
02:22:22 <wirrbel> there seem to  be a few and I cannot really tell which one to choose
02:22:50 <wirrbel> I would like to use basic matrix processing (multiplication, inverse, pseudo-inverse), etc.
02:23:11 <merijn> wirrbel: Not an answer to your question, but all the people who know this stuff hang out in #numerical-haskell :)
02:24:04 <wirrbel> thats probably one of the best answers I got so far ;) thanks merijn
02:24:19 <merijn> I don't think there is a de facto standard library yet, although I'm assuming edwardk has one somewhere and I know carter is working on a bunch of cool stuff, but a lot of that is still alpha-ish
02:27:03 <ilmig_> isn't hmatrix the most popular linear algebra library at the moment?
02:27:07 <angerman> merijn: is there a channel for image processing and object recognition as well?
02:29:03 <merijn> angerman: Not that I know?
02:30:13 <angerman> merijn, good to know, so #haskell would be the canonical :D
02:34:17 <Th30n> Which MonadT is recommended for exception/error handling? ErrorT, EitherT or some other? (I'm new to Haskell obviously and am doing a hobby project to learn more)
02:35:44 <Iceland_jack> Th30n: Are the 'Maybe' or 'Either e' monads sufficient for your needs?
02:35:53 <Iceland_jack> ErrorT and EitherT are monad transformers
02:36:08 <Th30n> Yeah, I need those because I'm wrapping up IO monad in them
02:36:31 <Th30n> I'm working with OpenGL and SDL2 bindings and they sometimes return 0 or nullPtr as an error
02:37:22 <Iceland_jack> Have you considered simply returning 'IO (Maybe value)'?
02:37:45 <latk> Was there a haskell-mode channel somewhere ?
02:38:11 <Th30n> yeah I did that before, but then I decided the function should get the error message from API (using getError) and wrap that up in an error msg instead of just Nothing
02:41:36 <Javran> just a quick question: can a partial function whose domain is nonempty, codomain is empty called "injective"?
02:42:31 <shachaf> I would say that there's no such function.
02:42:36 <mr-> Javran: i.e. undefined?
02:42:45 <shachaf> There are no empty types in Haskell.
02:44:11 <jle`> Th30n: would a (Maybe a -> Either e a) function work for you?
02:44:28 <jle`> or IO (Maybe a) -> IO (Either e a) when you fmap it
02:45:02 <Th30n> Hmm, that's an interesting solution
02:45:03 <Javran> shachaf: I see, maybe I'll better ask can a partial function be injective?
02:45:49 <shachaf> Are you asking for definitions of "partial function" and/or "injective"?
02:47:42 <tac> Javran: There are no functions with an empty domain to a nonempty codomain, mathematically speaking.
02:47:58 <tac> And if you're not speaking mathematically, you need to formalize what you mean by "injective".
02:48:01 <shachaf> I think you mean the other way around.
02:48:12 <Javran> shachaf: I'm asking if "injective" implies "total", so I took an extreme case that the function was not defined on any value
02:48:13 <hyPiRion> Hrm.. Why is it that `gmapT (mkT (* 2)) [10, 10]` returns [20, 10], whereas `gmapT (mkT (* 2)) (10, 10)` returns `(20, 20)`? Is not the tail of a list an immediate subterm of the list?
02:48:19 <shachaf> Anyway, it sounds like Javran is asking for a definition. But I'd like to make sure.
02:48:58 <shachaf> Oh. Maybe not.
02:49:01 <tac> When you work in a language like Haskell, the definition of "injective" can get very funny very fast.
02:49:18 <shachaf> hyPiRion: Yes, but the tail of the list isn't the number 10.
02:49:20 <shachaf> It's the list [10]
02:49:40 <tac> If you're working with a type-level function, for instance, do coercable types qualify as equal?
02:49:41 <Javran> tac: oh, I was just asking injective in mathematical sense.
02:50:15 <tac> Naively, though, there are no such functions, so you don't need to worry :)
02:50:27 <shachaf> Javran: In the mathematical sense, a "partial function" isn't a function.
02:50:28 <tac> err, wait, maybe I have my facts backwards
02:50:40 <shachaf> You can talk about partial and injective relations, though.
02:50:42 <tac> Empty -> () would have exactly one total function
02:50:44 <hyPiRion> shachaf: right, I found out that it doesn't traverse the data constructors underneath itself
02:50:46 <tac> and it's injective, vacuously
02:50:47 <hyPiRion> thanks
02:51:15 <shachaf> hyPiRion: I liked SPJ's slides on SYB for explaining all this.
02:51:27 <tac> SYB?
02:51:28 <kuribas> shachaf: Isn't (1/x) a function?
02:51:37 <shachaf> http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
02:51:38 <hyPiRion> shachaf: do you have a link? I've just started with this
02:51:45 <hyPiRion> ah, beat me. Thanks1
02:52:06 * Iceland_jack just mounted a giant blue rhino head on the front of a house....
02:52:09 <shachaf> https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt
02:52:16 <shachaf> kuribas: With what domain?
02:52:40 <kuribas> The real numbers.
02:52:49 <Javran> tac: yeah, I'm playing with the definition and find I was wrong since I thought injective implies total.
02:53:12 <tac> well, injective isn't really well-defined unless you're talking about a total function
02:53:54 <tac> And again, how you define things can make a different. Usually, injective means if f(x) = f(y), then x = y.
02:54:03 <shachaf> kuribas: Then no, not with the usual definition of a function.
02:54:09 <kuribas> shachaf: So (1/x) is a function over the real numbers excluding 0, but not over the real numbers?
02:54:12 <tac> But then, if you have f(x) and f(y) undefined.... are you going to require x = y?
02:54:43 <shachaf> You can use some other definition of "function" if it's more convenient for you.
02:54:57 <Javran> I see
02:54:58 <shachaf> Or you can make the codomain bigger, which is what Haskell does.
02:55:33 <tac> 1/x is a formal "rational function", too. It's handy when you want to ignore division issues and treat the ratios of polynomials as a field
02:56:10 <dutchie> or just use the riemann sphere
03:13:15 <frerich> As an exercise, I'd like to define a value 'ruler :: [Integer]' which corresponds to the ruler functions (0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2...) where the nth element of the stream (assuming the first element corresponds to n=1) is the largest power of 2 which evenly devides n. To make it more interesting, I'm trying to implement 'ruler' without having to do any divisibility testing.
03:13:15 <frerich> I defined an 'interleave :: [a] -> [a] -> [a]' function which alternatves the elements from two lists and then my idea was to fold that over the value of 'map repeat [0..]', but alas it never terminates.
03:13:15 <frerich> I noticed that 'foldr1 interleave . map repeat $ [0..4]' works as expected, but as soon as I use '[0..]' instead it fails to terminate.
03:13:15 <frerich> Does anybody know why that is? I hoped that the fold would be able to produce the elements incrementally, but apparently that's not the case.
03:14:05 <tac> @src interleave
03:14:06 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:14:14 <tac> what does interleave do again?
03:14:44 <frerich> tac: It's not a standard function AFAIK, I defined it myself. If simply alternates the elements from two lists, e.g. "interleave [1..] (repeat 0)" yields [1,0,2,0,3,0,4,0,5,0...]
03:14:55 <frerich> s/If simply/It simply/
03:14:57 <tac> ahh
03:15:12 <jle`> hm
03:15:34 <jle`> @pl \x y -> [x,y]
03:15:35 <lambdabot> (. return) . (:)
03:16:19 <adimit> beautiful.
03:17:10 <jle`> > let interleave xs ys = concat (zipWith (\x y -> [x,y]) xs ys) in take 10 $ interlave [1..] (repeat 0)
03:17:12 <lambdabot>  Not in scope: ‘interlave’
03:17:12 <lambdabot>  Perhaps you meant ‘interleave’ (line 1)
03:17:16 <jle`> > let interleave xs ys = concat (zipWith (\x y -> [x,y]) xs ys) in take 10 $ interleave [1..] (repeat 0)
03:17:18 <lambdabot>  [1,0,2,0,3,0,4,0,5,0]
03:17:38 <jle`> adimit: waiting for the moment when we get list sections ;)
03:17:45 <jle`> [,] --> \x y -> [x,y]
03:17:53 <jle`> > [,3] --> \x -> [x,3]
03:17:55 <lambdabot>  <hint>:1:2: parse error on input ‘,’
03:19:00 <Iceland_jack> jle`: I proposed it once but nobody was really interested
03:19:15 <adimit> jle`: eh. well. I don't know. I've rarely needed one. I'd like better syntactic support for type-lit vectors, etc. first.
03:19:39 <adimit> i.e. when you have your own list-like type, being able to treat it pretty much as a list.
03:20:11 <Iceland_jack> I think I implemented it and it worked alright
03:20:19 <jle`> Iceland_jack: you were the person who gave me this idea, and i am interested ^_^
03:21:05 <Iceland_jack> Ah, I do like the idea of being able to write
03:21:05 <Iceland_jack>     ['a',,,'.'] :: Char -> Char -> String
03:22:39 <adimit> … it looks ugly, tbh. Though the alternative is cumbersome.
03:23:31 <Iceland_jack> I think [,] and [,,] look rather cute :)
03:24:12 <jle`> little zoidbergs
03:24:22 <Iceland_jack> woop woop
03:24:50 <jle`> @pl \x y -> ['a',x,y,'.']
03:24:50 <lambdabot> (('a' :) .) . (. (: ".")) . (:)
03:25:17 <jle`> @unpl (('a' :) .) . (. (: ".")) . (:)
03:25:18 <lambdabot> (\ g m -> 'a' : ((:)) g (m : "."))
03:25:18 <frerich> For what it's worth, my source code is at http://lpaste.net/108553 -- I experimented a bit but I'm still not sure whether this approach works at all, i.e. interleaving an infinite list of infinite lists.
03:25:48 <jle`> that's probably the first time i've seen ((:))
03:27:20 <vanila> @let interleave (x:xs) ys = x : head ys : interleave xs (tail ys)
03:27:23 <lambdabot>  Defined.
03:27:36 <vanila> > let ruler i = fix (:i) `interleave` ruler (i+1) in rule 0
03:27:38 <lambdabot>  Not in scope: ‘rule’
03:27:38 <lambdabot>  Perhaps you meant ‘ruler’ (line 1)
03:27:41 <vanila> > let ruler i = fix (:i) `interleave` ruler (i+1) in ruler 0
03:27:43 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ [a1]
03:27:43 <lambdabot>  Expected type: [a1] -> [a1]
03:27:44 <lambdabot>    Actual type: [a1] -> [[a1]]
03:27:44 <lambdabot>  Relevant bindings include
03:27:44 <lambdabot>    i :: [[a1]] (bound at <interactive>:1:11)
03:29:19 <vanila> > let ruler i = fix (i:) `interleave` ruler (i+1) in ruler 0
03:29:21 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
03:29:36 <Th30n> How can I add dependancy of running hlint before building with cabal? (Also any cabal as build system tutorials?)
03:30:03 <pertl> I installed a standard distribution of ghci 7.6.3 with cabal and all the other stuff on OS X and try to "import System.IO.Temp" ... somehow it's missing ... is this package platform dependent and missing on mac?
03:30:17 <pertl> ^ trying to use function "withTempFile"
03:30:40 <pertl> ^ part of the "real world haskell" intro on IO ()
03:32:08 <tac> @hoogle withTempFile
03:32:08 <lambdabot> No results found
03:32:11 <tac> hmm
03:32:18 <pertl> http://hackage.haskell.org/package/temporary-1.1/docs/System-IO-Temp.html
03:32:44 <pertl> tac: ^
03:33:30 <tac> I don't see where you see where it mentions System.IO.Temp. Maybe I'm looking at the wrong chapter though
03:34:26 <pertl> "System.IO.Temp" is the title of the web link I sent you
03:34:29 * hackagebot abc-puzzle 0.2.1 - Generate instances of the ABC Logic Puzzle.  http://hackage.haskell.org/package/abc-puzzle-0.2.1 (PatrickBahr)
03:36:05 <pertl> tac: I think I found the issue ... the function is defined in the book 2 pages later ... sorry and thanks for your time :-)
03:36:14 <tac> np np
03:37:14 <frerich> vanila: Hm. What's interesting that your definition of 'ruler' works as good as the one I proposed, using 'foldr1'. The key is that your definition of 'interleave' is different from all three I tried.
03:37:27 <vanila> > fix (>>= \i -> [0,i+1])
03:37:31 <lambdabot>  mueval-core: Time limit exceeded
03:37:58 <vanila> I wonder if that way can work too?
03:38:03 <frerich> vanila: I.e. with you definition of 'interleave' it works, with those definitions based on concat or dlists it doesn't.
03:38:07 <vanila> observation: drop every snd and subtract
03:38:07 <vanila> 1
03:39:05 <wz1000> Why is the record syntax so confusing? 'a' in 'data IntWrapper = I { a :: Int}' is stated to have type 'Int' in the code, but actually has type 'IntWrapper -> Int'
03:40:08 <tac> wz1000: no one knows why records are so horrible in Haskell, but they are ;<
03:40:13 <comerijn> wz1000: Record syntax does two things
03:40:29 <tac> wz1000: but yeah. All records implicitly take an argument of the type you're defining.
03:40:35 <comerijn> wz1000: 1) It defines a field of type Int and 2) defines an accessor function to get the value of that field
03:40:50 <zereraz> hello can someone tell me what is wrong with this http://lpaste.net/108554 , I think its the type problem. Also can I use map there?
03:41:19 <comerijn> wz1000: So you would write "I { a = 1 }" to define an IntWrapper, but you can use "a (I { a = 1 })" to get 1 out
03:41:33 <frerich> vanilla: Can you explain why using 'interleave (x:xs) ys = x : head ys : interleave xs (tail ys)' (what you wrote) works, but 'interleave  (x:xs) (y:ys) = x : y : interleave xs ys' doesn't?
03:41:37 <comerijn> @let data IntWrapper = I { getI :: Int}
03:41:38 <tac> wz1000: (The #1 most hated feature of the language, for me, is that fieldnames get defined globally and no two records may share a fieldname in the same module).
03:41:38 <lambdabot>  Defined.
03:41:45 <greato> Or you can use lens. They are the same thing except lenses are more developer-friendly.
03:41:47 <frerich> vanilla: I mean, both interleave the lists - but only the former works when used to define 'ruler'
03:41:52 <tac> @kind I
03:41:53 <comerijn> > getI (I { getI = 1)
03:41:53 <lambdabot>     Not in scope: type constructor or class ‘I’
03:41:54 <lambdabot>     A data constructor of that name is in scope; did you mean DataKinds?
03:41:55 <lambdabot>  <hint>:1:19: parse error on input ‘)’
03:42:11 <comerijn> > getI (I { getI = 1})
03:42:13 <lambdabot>  1
03:42:19 <frerich> vanilla: I'm using the definition 'ruler = foldr1 interleave . map repeat $ [0..]' -- which only works if 'interleave' is defined using head/tail
03:42:21 <tac> oh, I didn't know you could define types inline with lambdabot like that :O
03:42:33 <wz1000> comerijn: Yes, I get that. But wouldn't it be better to have a different syntax, so that '::' has a consistent meaning.
03:42:52 <comerijn> wz1000: Maybe, but it's unlikely to ever change now
03:43:03 <comerijn> wz1000: Too much code using this syntax
03:43:34 <zereraz> ?
03:43:47 <ClaudiusMaximus> zereraz: i think you want   mapM_ print xs
03:44:02 <zereraz> ClaudiusMaximus: will that work?
03:44:25 <comerijn> wz1000: Although I have a hard time thinking of what syntax would make more sense
03:44:45 <zereraz> ClaudiusMaximus: what about the type problem?
03:45:12 <comerijn> wz1000: Do you think "data IntWrapper = I { getI :: IntWrapper -> Int }" would be less confusing? You'd have to always add the IntWrapper while writing and always mentally ignore it while reading
03:45:12 <ClaudiusMaximus> zereraz: it will print each element of the list, if that's what you want
03:46:02 <zereraz> ClaudiusMaximus: yeah but I want each print to be n times, so I can do mapM_ (replicateM n print) xs
03:46:06 <wz1000> comerijn: No, that is as confusing. I was thinking about something without the '::' operator.
03:46:54 <comerijn> wz1000: FYI, :: is not an operator, it's just syntax :)
03:47:25 <ClaudiusMaximus> zereraz: oh ok, sure that would work i think, but maybe replicateM_ would be better as you don't really need the [()] from the prints
03:48:01 <zereraz> ClaudiusMaximus: I don't need the [()]
03:48:14 <zereraz> ClaudiusMaximus: I didn't know about replicateM_
03:48:47 <wz1000> comerijn: Yeah, I know that, but that is how you mentally treat it. It is like an operator in sense of operators in other languages, like the '=' operator in C.
03:50:28 <ClaudiusMaximus> zereraz: there's a convention that blahM_ does the same as blahM but discarding the results, as an optimisation
03:50:51 <zereraz> ClaudiusMaximus: blahM are monads right
03:50:57 <zereraz> because of Capital M
03:51:11 <zereraz> where as blah is just a function
03:51:50 <comerijn> zereraz: blahM is also just a function
03:52:04 <comerijn> Values can't be monads, only types can be monads
03:52:31 <wz1000> zereraz: blahM is the version of blah that acts on a monad.
03:52:42 <frerich> vanilla: For what it's worth, I now posted an SO question about this problem: http://stackoverflow.com/questions/25078598/why-would-using-head-tail-instead-of-pattern-matching-make-a-function-terminate
03:54:30 <ClaudiusMaximus> frerich: i'm guessing that lazy pattern matching like ~(y:ys) would also terminate ?
03:55:08 <frerich> ClaudiusMaximus : First time I see that syntax - and yes, it also terminates.
03:55:09 <wz1000> zereraz: It is not a monad. It is however a monadic value, because its type, the function is a Monad. However, in that way, blah is also a monadic value.
03:57:47 <comerijn> wz1000: Sorry to be pedantic, but I've decided unclear terminology isn't helping anyone, so to clarify: Functions are functions, they can't be monads (the partial application of the (->) type, that is "(->) r" is a monad, but that's not a function)
03:59:06 <comerijn> wz1000: A monad (in haskell) is "a type that takes one parameter and has an instance of the Monad typeclass", monadic values are not a very technical term, but can at least be unambiguously be described as "any value with type 'm a' where 'm' is a monad"
03:59:34 <comerijn> blahM functions are generally functions whose return value is a monadic value
04:02:52 <vanila> > let f xs = 0 : 1 + head xs : f (tail xs) in fix f
04:02:54 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
04:03:00 <vanila> frerich, there is another way
04:17:37 <kuribas> What I mis from Data.Map is a way to get all values to the left and to the right of a key.
04:18:20 <kuribas> For example: k -> Map k v -> ([(k,v)], [(k,v)])
04:18:59 <pavonia> There's such a function, split...something
04:19:05 <shachaf> There is split.
04:21:08 <kuribas> if I use head $ toDescList on the first map from split, will I get O(log n)?
04:22:12 <kuribas> toDescList is O(n), but if the list is generated lazily, shouldn't I get O(log n)?
04:22:27 <shachaf> You might want to use maxView instead.
04:22:49 <shachaf> Or at least maybe not head. :-(
04:23:02 <shachaf> But yes, toDescList will probably do what you want.
04:24:08 <kuribas> Let's say I want to first 3 items, isn't toDescList better than maxView in this case?
04:24:42 <shachaf> Sure.
04:24:51 <kuribas> ok, thanks.
04:25:45 <shachaf> You should double-check that it behaves lazily like you said.
04:26:14 <shachaf> But it looks like it does. toDescList just uses foldlWithKey.
04:26:38 <shachaf> edwardk: Hmm, should we have a toReversedListOf for lens?
04:31:57 <darthdeus> tac: JUST GOT THE BOOK DELIVERED :P
04:32:06 <tac> darthdeus: awesome
04:32:17 <tac> hope you enjoy it
04:32:27 <tac> the code is all online, too, if you want to run it
04:32:34 <darthdeus> looks very awesome so far
04:32:37 <tac> although we have to banish you from this channel, since it's all in Ocaml
04:32:47 <darthdeus> i've actually just noticed that i read his book on category theory
04:32:53 <darthdeus> by the same author
04:32:54 <darthdeus> haha
04:32:54 <darthdeus> :D
04:33:42 <bounb> what book
04:33:52 <tac> B. Pierce's books
04:34:02 <tac> Tapl and basic categories for CS
04:34:06 <darthdeus> bounb: http://www.amazon.co.uk/gp/product/0262162091/ref=s9_wishf_gw_d15_g14_i1?ie=UTF8&colid=8ULF2YUFD8OT&coliid=ISWZ2ZGPC2HUY&pf_rd_m=A3P5ROKL5A1OLE&pf_rd_s=right-3&pf_rd_r=0M0M34039F017Z754EE8&pf_rd_t=101&pf_rd_p=469296553&pf_rd_i=468294
04:34:21 <darthdeus> though the basic category theory is faaaar from basic
04:34:24 <bounb> cool
04:34:55 <tac> darthdeus: it's actually.... really basic as far as categories go.
04:35:03 <tac> I think more than anything else, it's just not his best book
04:35:16 <darthdeus> tac: it has a lot of prerequisites though :\
04:35:21 <tac> I got the feeling reading it, that he wrote it so that he could better understand the subject himself
04:35:25 <darthdeus> i've taken set theory last semester and still found it quite hard to follow
04:35:31 <darthdeus> yeah i agree
04:35:32 <raichoo> The Pierce CT book is good. For further research I recommend Awodey's book on category theory :)
04:35:44 <shachaf> What would you expect to see in a basic category theory book?
04:35:50 <raichoo> But only if you've been bittenbey the CT bug :D
04:35:56 <raichoo> bitten by
04:36:19 <darthdeus> shachaf: i dunno, but i expected to understand it a bit more since it's the most "basic" book i got recommended
04:36:33 <darthdeus> but i guess i'm too big noob to understand it yet
04:36:47 <tac> darthdeus: Naive set theory? Or a more rigrous version?
04:36:57 <tac> Naive set theory shouldn't be too bad, if taught properly
04:37:16 <darthdeus> tac: well it's not hard, but it's a lot of abstractions on abstractions on abstractions
04:37:46 <vlatkoB> How come ByteString is not Traversable?
04:38:01 * tac still doesn't know what a traversable is
04:38:23 <shachaf> vlatkoB: It has the wrong kind.
04:38:23 <darthdeus> vlatkoB: traversable is for containers
04:38:34 <darthdeus> tac: http://blog.jakubarnold.cz/2014/07/30/foldable-and-traversable.html :P
04:39:07 <vlatkoB> Isn't ByteString a container? Like Map?
04:39:11 <shachaf> You can write a function :: Applicative f => (Word8 -> f Word8) -> ByteString -> f ByteString, but that doesn't match the type of traverse.
04:39:22 <darthdeus> tac: just published that ysterday, hope it helps :)
04:39:32 <tac> vlatkoB: I think the problem is bytestring isn't a type constructor
04:39:46 <tac> You can't have a bytestring of a's for any type a.
04:40:20 <Twey> vlatkoB: It's a ‘monofunctor’ — it behaves as a container, but its element type is fixed
04:40:55 <Twey> vlatkoB: And, equivalently, it's a monotraversable: https://hackage.haskell.org/package/mono-traversable
04:41:15 <shachaf> If "wrong kind" is not informative enough you should say so so it can be clarified rather than ignore it.
04:41:45 <shachaf> I'm not sure "MonoFunctor" really deserves to be a class.
04:42:15 <vlatkoB> Yeah, got it. Forgot about it's fixed.
04:42:21 <tac> monofunctor tops off the slot for #1 most abusive pseudocategorical thing I've heard in the channel ;P
04:42:23 <Twey> It has the  omap id = id  law
04:42:41 <Twey> Which qualifies it by edwardk's standards :þ
04:42:54 <shachaf> Yes, but why a class and not a value?
04:42:59 <tac> The problem I have with Foldable and Traversable are I can't see where they came from.
04:43:08 <tac> They just seem very arbitrary in their defintions.
04:43:14 <tac> Traversable moreso
04:43:25 <shachaf> tac: Ignore Foldable for a bit, Traversable is the more important one.
04:43:27 <tac> but still, foldMap.... I just don't see where it came from
04:43:42 <shachaf> Functor is for things you can define "map" for. Traversable is (roughly) for things you can define "mapM" for.
04:43:59 <shachaf> It's more or less as justified as mapM.
04:44:03 <tac> for an applicative version of mapM?
04:44:08 <Twey> shachaf: As in, data MonoFunctor a = MonoFunctor { omap :: (Element a -> Element a) -> a -> a } ?
04:44:08 <shachaf> Yes.
04:44:11 <shachaf> (That's the "roughly".)
04:44:20 <Twey> shachaf: With a non-associated type family Element?
04:44:30 <shachaf> Twey: As in T.map :: (Char -> Char) -> Text -> Text
04:44:32 <tac> ah yes. I can see how you're working in a... well it's not a Kleisi category but....
04:44:44 <Twey> shachaf: Well, you lose genericity
04:45:07 <vlatkoB> Could ByteString made Traversable if newtyped with phantom type?
04:45:14 <Twey> vlatkoB: No
04:45:19 <shachaf> You would need to justify that "genericity".
04:45:29 <Twey> vlatkoB: The phantom type wouldn't match the element type
04:45:36 <tac> vlatkoB: No. It has the wrong kind.
04:45:44 <tac> Traversables must be * -> *
04:45:45 <shachaf> vlatkoB: What happens if you write fmap chr newtypedByteString?
04:45:48 <tac> ByteString is *
04:45:59 <shachaf> tac: That's why vlatkoB is proposing the newtype.
04:46:05 <tac> ah
04:46:16 <tac> that is just not a good idea :)
04:46:23 <shachaf> What you *can* do to make it a Functor is CoYoneda it.
04:47:01 <shachaf> That is, data T a = T ByteString (Word8 -> a)
04:47:22 <shachaf> And write lift :: ByteString -> T Word8 and lower :: T Word8 -> ByteString
04:47:25 <shachaf> T is a real functor.
04:47:34 <shachaf> But you don't gain very much from this exercise.
04:48:23 <vlatkoB> I'm trying to see Traversable as general way of traversing any structure. Though, not possible for any, obviously.
04:48:27 <tac> traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f
04:48:34 <tac> Where does Compose come from there?
04:48:36 <shachaf> vlatkoB: It's a good exercise to figure out why your newtype doesn't work, though.
04:48:47 <shachaf> Data.Functor.Compose
04:48:51 <vlatkoB> I'll do that.
04:49:19 <shachaf> vlatkoB: One way to traverse anything is to forget the type class and just specify how you want to traverse it explicitly.
04:49:23 <tac> ah, very good
04:49:33 <shachaf> You can define a type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
04:49:58 <shachaf> Then you can write something :: Traversal ByteString ByteString Word8 Word8, or something :: Traversal [a] [b] a b
04:50:39 <shachaf> And you can write _2 :: Traversal (e,a) (e,b) a b, which is like the Traversable instance for tuples.
04:50:49 <shachaf> But you can also write _1 :: Traversal (a,e) (b,e) a b, and both :: Traversal (a,a) (b,b) a b
04:51:19 <tac> Why is the Foldable constraint required for Traversable, then?
04:51:47 <shachaf> Have you decided that Traversable makes sense?
04:51:49 <merijn> tac: Same reason Applicative "requires" Functor
04:52:03 <shachaf> Same reason Traversable "requires" Functor, for that matter.
04:52:11 <merijn> And the same reason Monad will "require" Applicative in 7.10
04:52:25 <tac> shachaf: I am much happier with Traversable seeing that now
04:52:30 <shachaf> But one step at a time. Exercise: Write list :: Traversable f => f a -> [a]
04:53:57 <vlatkoB> f must be list, no
04:54:24 <shachaf> ?
04:54:52 <vlatkoB> for list :: Traversable f => f a -> [a], f must be [] ?
04:55:12 <shachaf> No.
04:55:19 <shachaf> It can be any Traversable instance.
04:55:51 <tac> Can you even write such a function?
04:55:55 <shachaf> You can.
04:56:04 <tac> oh, do you need to use the fact that you have a foldable?
04:56:09 <tac> that f is foldable*
04:56:11 <shachaf> No, you're not allowed to use that.
04:56:15 <shachaf> You can only use traverse
04:56:27 <shachaf> Evidence that you can do it: You can write traverse print [1,2,3], and it'll print out 1, 2, and 3.
04:56:47 <shachaf> So the information is available to you.
04:58:41 <tac> list :: Traversable f => f a -> [a]
04:58:47 <tac> are you not missing an f in there at the end?
04:58:55 <shachaf> I'm not.
04:59:38 <tac> well, using traverse, you can maybe produce f [a]
04:59:47 <tac> but I don't see how you can get rid of the f
05:00:07 <quchen> Shachaf's type riddles are fun.
05:00:08 <shachaf> I'll give you an implementation and then you can improve on it.
05:00:52 <shachaf> λ> let list :: Traversable f => f a -> [a]; list s = unsafePerformIO $ do { r <- newIORef []; traverse (\x -> modifyIORef r (++ [x])) s; readIORef r }
05:02:46 * frerich must be missing something, every traversable is also a foldable so you could have 'list = Foldable.foldr (:) []' no?
05:03:09 <shachaf> Yes, but you're not allowed to use Foldable.
05:03:11 <shachaf> Only traverse.
05:04:21 <quchen> It's pretty tricky to find out the solution because the concatenation of the elements to form the resulting list is well hidden.
05:04:23 <shachaf> (But foldr (:) [] is a good implementation otherwise. If you can implement foldr with traverse that's fine too.)
05:05:05 <shachaf> I don't think it's too tricky from the right perspective.
05:05:19 <shachaf> The trick is finding the right perspective, I suppose.
05:05:52 <shachaf> I think tac is gone, anyway.
05:06:03 <tac> still working on it
05:06:15 <shachaf> Ah.
05:06:16 <frerich> Hmmm, maybe if you did something with 'traverse (:[])' and then concatenate the results or so...
05:06:28 <tac> I mean, I see it works, and you could replace the IO with ST and have it compile
05:06:33 <tac> I'm trying to figure out where my mistake was
05:06:44 <shachaf> Yes, that's a good improvement.
05:07:14 <shachaf> :t let list :: Traversable f => f a -> [a]; list s = runST $ do { r <- newSTRef []; traverse (\x -> modifySTRef r (++ [x])) s; readSTRef r } in list
05:07:15 <lambdabot> Traversable f => f a -> [a]
05:07:55 <shachaf> This is only a bit less awful, though. ST does way too much for what you need.
05:08:27 <shachaf> What's a simpler monad you could use?
05:11:36 <tac> If I had to guess wildly, probably Cont or something
05:11:56 <tac> It looks like it would require something clever
05:12:11 <shachaf> Cont is one of the most complicated monads.
05:12:41 <tac> I guess you're dealing with lists, so maybe list?
05:13:19 <shachaf> If you use traverse with f=[], you get (a -> [b]) -> t a -> [t b]
05:13:31 <tac> I see that
05:13:38 <tac> which is why I originally thought it was impossible
05:13:39 <shachaf> Which leaves you back where you started. So that doesn't quite work.
05:13:49 <shachaf> But you can pick any f you like.
05:14:14 <shachaf> We see that it works with ST, but if we didn't have IO/ST, what could we use?
05:14:16 <tac> I'd want to pick a left-inverse of t, really
05:15:26 <tac> just State would do
05:15:46 <shachaf> How would you write it with State?
05:18:35 * mbrock knows the answer, but won't tell
05:18:56 <frerich> don't give it away, I'm trying to figure it out, too :)
05:19:09 <shachaf> I think I won't give it away by going to sleep.
05:19:26 <quchen> Noo I can't wait for the derivation
05:19:54 <quchen> I can see where you're coming from and going to, but I don't see how they're connected :-(
05:20:05 <tac> got it
05:20:23 <vlatkoB> Lucky you
05:20:39 <shachaf> Where am I going to?
05:20:57 <shachaf> I don't really know.
05:21:05 <frerich> What I'm trying to see is how any type 'f' can get rid of the 't' in 'f (t b)' "traverse :: Applicative f => (a -> f b) -> t a -> f (t b)". It could be [t b] or Maybe (t b) or something else.
05:21:11 <jesyspa> Sleep?
05:21:32 <frerich> Hmm maybe the reader monad?
05:21:35 * frerich tries that...
05:23:01 <tac> @src State
05:23:01 <lambdabot> Source not found. Sorry.
05:23:27 <tac> State s a ~ (s, a) or something, I thought
05:23:36 <jesyspa> s -> (s, a), IIRC.
05:23:39 <tac> yeah
05:23:44 <tac> I missed the arrow
05:23:49 <mbrock> frerich: you're not limited to only using `traverse`, for example shachaf's implementation uses `runST`
05:23:58 <tac> [b] -> ([b], t a)
05:24:20 <frerich> mbrock: Oh I misunderstood '<shachaf>You can only use traverse' then.
05:24:48 <quchen> I think that was in the "no fold" sense.
05:25:00 <mr-> shachaf: Was the point that every Traversable is a Foldable in that way?
05:25:05 <mbrock> I guess that means: of the various traverse/fold functions in the Traversable hierarchy, we only use traverse
05:25:21 <shachaf> Yes.
05:26:15 <shachaf> Foldable, by the way, means (almost) Listable.
05:26:31 <mr-> toList is not a minimal implementation? :-)
05:26:45 <shachaf> A type is Foldable if you can define "list" on it.
05:26:47 <shachaf> There are no laws.
05:26:56 * frerich decides this is too tricky to do while I'm at work :-}
05:27:27 <shachaf> mr-: ?
05:28:35 <mr-> shachaf: providing toList is not the same as providing a Foldable instance? I thought so.. why the (almost)?
05:28:43 <shachaf> Monoids can have funny shapes.
05:29:00 <shachaf> For example maybe you have a list which is infinite to the left but not to the right.
05:29:35 <tac> shachaf: ah, so Foldable just means any type with a canonical map into []?
05:29:39 <quchen> shachaf: What's the "almost" part? That lists can only be traversed left-to-right, while Foldable isn't necessarily directional?
05:29:39 <shachaf> You can still write a useful Foldable instance, but toList won't give you any values.
05:29:45 <tac> (is that incorrect to say that)?
05:31:53 <shachaf> tac: I don't think phrases like "left-inverse" and "canonical map" will help you here.
05:32:06 <tac> what's wrong with those terms?
05:32:20 <tac> Isn't that what list is doing? Picking out a map from f a into [a]?
05:32:21 <latk> I'm parsing some webpages, using a combination of xml conduit and attoparsec. If some text I'm looking for isn't in one location, it is likely to be in another. Is there some way, other than using case statements to check for failure, to glue them together?
05:32:36 <shachaf> quchen: Roughly that.
05:32:41 <TheKing44441> @fortune
05:32:42 <lambdabot> With clothes the new are best, with friends the old are best.
05:32:43 <shachaf> Nothing, they just won't help you.
05:33:33 <mbrock> latk: you can probably use (<|>)
05:33:55 <mr-> tac: baring weird cases at infinity, Foldable is the same as giving toList :: Foldable t => t a -> [a]
05:34:21 <latk> mbrock: I know that I can use this for the parser itself, but this is more like, if extracting from this tag and then parsing fails, try this next combo of extract and parse. Is that possible with <|> ?
05:34:23 <TheKing4444> @paste hi
05:34:24 <lambdabot> Haskell pastebin: http://lpaste.net/
05:34:37 <shachaf> TheKing4444: Please use /msg lambdabot to test your connection.
05:34:42 <tac> shachaf: so does that mean the Foldable constraint is redundant?
05:34:51 <TheKing4444> okay
05:34:55 <shachaf> It's as redundant as the Functor constraint.
05:35:35 <tac> I'm not sure that entirely answers my question.
05:35:42 <tac> Since you could be saying they are both redundant
05:35:45 <tac> or that both are required
05:36:12 <shachaf> I'm not sure what you mean by "redundant".
05:36:26 <shachaf> You can implement both fmap and foldMap using traverse.
05:37:06 <shachaf> Anyway, State isn't the simplest you can get.
05:37:12 <pjdelport> Foldable can also be seen as allowing a structure to be mapped to a monoid:
05:37:12 <pjdelport> :t foldMap
05:37:14 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
05:37:20 <shachaf> You can go two steps simpler.
05:37:23 <mbrock> latk: it's hard to say without knowing your code, but if you can write two separate things of some type like `Parser (Maybe x)`, then you should be able to use (<|>) (or perhaps mplus) to combine them
05:37:37 <shachaf> But I'll go to sleep in a moment.
05:37:42 <tac> kk
05:37:50 <tac> thanks for taking the time and have a good night
05:37:54 <latk> mbrock: Cool. I'll look into - thanks!
05:38:01 <mr-> shachaf: what are the steps? :-)
05:38:29 <shachaf> mr-: There are multiple paths.
05:38:52 <shachaf> State -> Writer -> Const, or State -> Endo -> Const
05:38:59 <TheKing4444> When is Haskell platform going the GHC 7.8?
05:39:01 <shachaf> You can draw a little commutative diagram if you're into that.
05:39:17 <merijn> tac: The superclass isn't there because it's needed, but because logically Traversable instances are a subset of Foldable instances
05:39:26 <quchen> TheKing4444: I think the second release candidate was published the other day, so it won't be long.
05:39:34 <shachaf> State s a = s -> (s, a). You can drop the (s ->) or the (, a) or both.
05:39:40 <merijn> tac: i.e. "every Traversable *can* be Foldable, therefore every Traversable is *enforced* to be Foldable"
05:39:42 <TheKing4444> okay
05:39:46 <shachaf> (But dropping the (, a) will make your thing no longer a monad.)
05:39:46 <mr-> shachaf: thanks
05:39:52 <shachaf> (Fortunately you didn't need the monad.)
05:39:59 <TheKing4444> :t sort
05:40:00 <lambdabot> Ord a => [a] -> [a]
05:40:10 <merijn> tac: This means you can just reuse Foldable functions, rather than redefining Traversable equivalents of Foldable
05:40:31 <merijn> tac: Monad doesn't have Applicative as a superclass and look at what a mess that became (and how it's retroactively being added)
05:40:51 <tac> that's true
05:41:06 <TheKing4444> :t sort :: (Eq a, Ord a) => [a] -> [a]
05:41:07 <lambdabot> Ord a => [a] -> [a]
05:41:17 * mbrock does not know how Const applies to shachaf's riddle...
05:41:27 <merijn> tac: So that's the only reason for having Functor/Foldable there, because logically anything Traversable *should* be those two things
05:42:41 <tac> ah, I think I understand where my confusion there comes from now
05:43:23 <quchen> It's fracdundant. Having the constraint is technically unnecessary, not having it is missing something.
05:44:15 <TheKing44> quechen look at this
05:44:53 <shachaf> In fact there might be a couple more steps.
05:45:05 <TheKing44> :t sort :: (Ord a, Eq a)=>[a]->[a]
05:45:07 <lambdabot> Ord a => [a] -> [a]
05:45:17 <TheKing44> eq is redundant
05:45:32 <TheKing44> it is implied
05:45:44 <shachaf> :t getConst . traverse (\x -> Const [x]) -- is what you might end up with
05:45:45 <lambdabot> Traversable t => t t1 -> [t1]
05:46:43 <mbrock> oh, er, yeah, that has the right type... :)
05:46:52 <shachaf> :t ($ []) . appEndo . getConst . traverse (\x -> Const (Endo (x:))) -- but you might prefer something like this
05:46:53 <lambdabot> Traversable t1 => t1 t -> [t]
05:48:47 <quchen> … to ensure left-associative concatenation?
05:48:51 <quchen> Eh, right
05:49:01 * tac punches monads
05:49:27 <tac> I got the Writer version working
05:49:33 <shachaf> Good.
05:49:41 <shachaf> Now since you don't like monads, stop using monads.
05:49:44 <ddellacosta> hahaha
05:49:46 <shachaf> But I'm done.
05:49:48 <tac> ;P
05:49:54 <tac> you've been going to bed for half an hour
05:50:02 <ddellacosta> monads, always steppin'
05:50:35 <TheKing44> did you try logarithms
05:51:44 <frerich> So the trick is to use any monad of a type with kind * -> * -> * and for which there's a function to get just one of the contained values? I.e. "Either" would work just as well?
05:52:40 <frerich> :t (\(Left x) -> x) . traverse (\x -> Left [x])
05:52:41 <lambdabot> Traversable t => t t1 -> [t1]
05:53:16 <shachaf> Did you try it?
05:53:39 <frerich> Try? What do you mean? It type-checks, it's perfect! ;-)
05:53:49 <frerich> but no, I can see that this version doesn't do what I'd hoped it would do.
05:53:58 <shachaf> The answer is no, and you should figure out what's going on.
05:54:19 <frerich> Actually, I should do a lot of things *except* figuring this out.... :-]
05:55:09 <quchen> frerich: Good, that'll make you more efficient
05:55:40 * mbrock just learned about the Applicative instance for Const
05:56:00 <mr-> err
05:56:07 <tac> got it down to const
05:56:09 <mr-> Const m for a monoid m?
05:56:15 <quchen> frerich: Your types check out, but the function doesn't really do a lot of useful work. "foo _ = []" satisfies the typechecker as well here, but hardly summarizes all elements.
05:56:31 <mbrock> mr-: yeah, that
05:56:34 <The_other_cat> Hi there. How can i transfom Foreign.C.Types.CInt to Int?
05:56:43 <shachaf> fromIntegral
05:57:46 <shachaf> This channel tends to have a low signal-to-noise ratio even when people are talking about Haskell, and even interesting parts of Haskell. :-(
05:57:50 <shachaf> Not that I help much.
05:58:52 <tac> hmm although, merijn, thinking about what you said earlier regarding Traversable and the necessity of the Foldable requirement
05:59:07 <tac> a type might be Foldable in multiple ways
05:59:22 <tac> and so having that constraint forces the "canonical"ness of one of those ways.
05:59:49 <tac> And you would think that it should agree with the function shachaf had us write just now.
06:00:21 <shachaf> Yes, a Traversable law is that foldMap = foldMapDefault
06:02:04 <The_other_cat> shachaf: thanks, works!
06:02:13 <Trollinator> suppose I have a type T and a newtype Foo for it. Is it possible to convert a [T] to [Foo] without overhead?
06:02:44 <tac> Trollinator: I believe that is a consequence of congruence of type equalities
06:02:49 <k00mi> tac: it's the same with Applicative and Monad
06:03:10 <Trollinator> i don't understand.
06:03:18 <tac> k00mi: as someone who hasn't figured out how to install the latest GHC, I wouldn't know :~P
06:03:22 <Trollinator> I don't know what congruence of type equalities is.
06:03:28 <tac> oh hm
06:03:38 <tac> at the language level, how do you do that?
06:03:52 <tac> I'm thinking of what it might look like in Core
06:04:08 <frerich> Trollinator: What do you mean by 'overhead'? "map Foo" wouldn't do?
06:04:18 <k00mi> tac: all I meant is that a type may have several Applicative instances but only one Monad instance
06:04:31 <Trollinator> frerich: runtime overhead.
06:04:32 <k00mi> theoretical instances, that is
06:04:43 <tac> frerich: he wants map Foo to compile to the identity funciton
06:04:46 * hackagebot fb 1.0.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.3 (FelipeLessa)
06:04:56 <Trollinator> tac: exactly
06:05:00 <quchen> frerich: `map <newtype (de)constructor>` works, but it's as "free" as `map id` is: it traverses the list, when operationally newtypes should be free.
06:05:08 <shachaf> Well, monad instances aren't generally unique.
06:05:12 <quchen> I think GHC's roles were introduced for that.
06:05:44 <Trollinator> quchen: not only does it traverse the list, it also allocates memory.
06:09:13 <Trollinator> quchen: reading up on roles now
06:09:23 <beaky> hello
06:11:09 <Trollinator> oh, so i just need to use GHC 7.8coerce
06:11:26 <Trollinator> err, GHC 7.8's coerce
06:14:54 <benzrf> quaestor: roles/
06:14:57 <benzrf> *roles
06:16:19 <benzrf> oh quchen left
06:27:22 <Shockk> hello, I'm writing some haskell code but I'm having a problem with cyclic module imports, and I don't know the best way to resolve it
06:27:50 <tac> Shockk: What module cycle do you have in your code?
06:27:53 <Shockk> I have two modules https://github.com/shockkolate/lambdircd/blob/new/src/IRCD/Types/Client.hs and https://github.com/shockkolate/lambdircd/blob/new/src/IRCD/Types/Channel.hs
06:29:01 <Shockk> the relevant parts are clients :: [Client] in Channel constructor, and channels :: [Channel] in Client constructor
06:30:21 <tac> What do you do when hoogle doesn't find a thing you know is on Hackage?
06:30:57 <pjdelport> Shockk: Do you really need them to be in separate modules?
06:31:24 <pjdelport> Shockk: It looks like you might want to collapse several of those Types.* modules together.
06:32:24 <Shockk> pjdelport: hmm, I could put them in a single module I guess, I was trying to avoid it to keep it well organized
06:33:21 <pjdelport> Shockk: A tight mutual dependency like that is probably (usually?) a sign that the things belong in the same module.
06:34:06 <byorgey> tac: hoogle doesn't search all of hackage
06:34:09 <tac> Shockk: My experience with that (to add to what pjdelport just said) is that you broke something into multiple files, but Haskell wants you to keep them together
06:34:17 <tac> byorgey: what is the extent of its search then?
06:34:35 <latk> Is there an easy way to filter non-ascii characters from a Text string ?
06:34:42 <byorgey> tac: just some list of common/standard packages by default.  If you know the package you can search for   searchTerm +packageName
06:34:46 <pjdelport> It's usually a good idea to factor separate things into separate modules, but you can overdo it too.
06:34:48 * hackagebot haskell-updater 1.2.3 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.3 (SergeiTrofimovich)
06:34:54 <byorgey> tac: alternatively, you can try hayoo, which does search all of Hackage
06:34:55 * Shockk nods
06:34:55 <allsystemsarego> hi all, is there a name for a function that turns the empty list into Nothing, and a non-empty list into Just . head $ theList?
06:34:59 <byorgey> but doesn't really do type search
06:35:14 <tac> @hoogle [a] -> Maybe a
06:35:17 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
06:35:17 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:35:18 <lambdabot> Prelude head :: [a] -> a
06:35:29 <tac> listToMaybe looks like what you said
06:35:34 <byorgey> allsystemsarego: yes, listToMaybe.  As tac has demonstrated, you could also find this yourself using hoogle
06:35:35 <Shockk> my only concern is that some of my record names will conflict with each other, which wouldn't be a problem across separate modules but would in a single module
06:35:51 <allsystemsarego> @src listToMaybe
06:35:51 <lambdabot> listToMaybe []    = Nothing
06:35:51 <lambdabot> listToMaybe (a:_) = Just a
06:36:39 <pjdelport> Shockk: I'm not very familiar with your code, but from the look of it, you might want to re-approach your module grouping by what the problem domain, rather than by the type of things.
06:36:48 <Shockk> ahh
06:36:50 <byorgey> latk: yes, Data.Text.filter (not . isAscii)
06:38:01 <Shockk> that sounds like a good approach
06:38:08 <Shockk> thanks, tac and pjdelport, for your help
06:38:29 <tac> I personally wish modules weren't locked at file boundaries
06:38:52 <pjdelport> Shockk: So for example, instead of splitting modules along lines like "Logic" and "Numeric", split them along lines like (for example) "Protocol" for all raw IRC protocol-level things, on top of which you might build Client and Server modules.
06:39:33 <pjdelport> A Protocol module, for example, would contain everything related to that level: types, constants, functions, helpers, etc. etc., rather than segragating those things by what kind of thing they are.
06:40:12 * Shockk nods
06:40:23 <pjdelport> A Client module might build on top of that with types, functions, and other things that are specific to IRC clients; same for a Server module.
06:40:49 <Shockk> I'll do that
06:41:52 <pjdelport> And the things that are shared between Client and Server should be in some shared module; either Protocol, or perhaps another "Common" or similar module that has all the domain-specific things that are shared between Client and Server, but aren't low-level enough to be in Protocol.
06:42:10 <ddellacosta> is there any canonical set of documentation for what various extensions provide?  I'm specifically looking at TypeOperators now, but I can't find anything other than this: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions
06:42:11 <TheKing44> Or you could use the Haste.App approach and maybe the client and server the same program.
06:43:01 <Shockk> client isn't an issue for me since it's only the server code that I'm writing
06:43:16 <Shockk> (the Client module there is for a client of the server)
06:44:39 <merijn> tac: Why? Do you want multiple modules per file?
06:44:47 <tac> merijn: not at all
06:45:14 <merijn> Multiple files per module?
06:45:34 <merijn> Because both you can essentially fake
06:45:50 <tac> but I also think Text.ParserCombinators.Parsec and Control.Monad.State are stupidly long and I've seen a handful of modules that declare only 2 or so top level bindings
06:46:09 <merijn> tac: Text.ParserCombinators.Parsec is deprecated
06:46:22 <tac> What's the new name for it?
06:46:25 <merijn> Text.Parsec
06:46:28 <tac> Oh
06:46:40 <merijn> Text.ParserCombinators.Parsec is still around for backwards compatibility, though
06:46:43 <tac> Yeah
06:46:54 <ddellacosta> ( this seems to be it, for the record: http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/flag-reference.html#idp14238080 )
06:47:57 <pjdelport> Shockk: The record name thing is a valid concern, and but the best approach when you have conflicts is probably just to give them unique prefixes or similar.
06:48:22 <Shockk> that's true
06:48:28 <merijn> Although the work-in-progress overloaded record fields and lenses should help there
06:50:57 <pjdelport> OverloadedRecordFields: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Design and http://www.well-typed.com/blog/84/
06:52:30 <tac> @type view
06:52:32 <lambdabot> MonadReader s m => Getting a s a -> m a
06:52:33 <tac> @type preview
06:52:34 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
06:53:35 <hyPiRion> Hrm, what would you call types which cannot be "Null"? That is, how would you convey the non-nullness of Haskell types in a formal way, to programmers of languages with null?
06:53:50 <tac> non-nullable?
06:54:03 <vanila> hyPiRion, any type can have "undefined" value, which is a bit like null
06:54:14 <vanila> hyPiRion, it's just that you can't check if something is undefined...
06:54:49 <vanila> you could say that th complete set of values for Bool is {undefined, True, False}
06:55:13 <tac> vanila: you probably shouldn't do that though
06:55:14 <hyPiRion> vanila: except undefined isn't really a value, it just typechecks
06:55:29 <vanila> it is a value
06:55:57 <tac> vanila: 1) You force your interpretation of Haskell types to be sets. This need not be the case. And
06:56:12 <tac> 2) With more interesting types, you end up with more than just "everything plus bottom".
06:56:34 <hyPiRion> vanila: Either way, what I am looking for is some word describing "this value will never be null/undefined/'unsound'"
06:56:39 <hyPiRion> some single word
06:56:52 <vanila> tac, I am not equating haskell types with sets - just saying that the set of values of that type, you could also say here's a list of all values of the type [undefined,True,False]
06:57:01 <vanila> hyPiRion, but it can be undefined
06:58:56 <mr-> tac: do you really think there is something wrong with choosing sets as a model of types when programming haskell?
06:59:24 <tac> not especially
06:59:29 <tac> but there are more interesting models
06:59:29 <hyPiRion> vanila: not in this specific case I have. Even though it technically *might* according to Haskell typechecking laws, assume I have proven it will not be undefined within the context of my use case.
06:59:55 <ChristianS> is haskell 2010 still the latest version of the haskell standard or has there been a newer one?
06:59:57 <vanila> hyPiRion, then you can say it will be a well defined value
07:00:22 <hyPiRion> vanila: thanks, that's the word I was looking for
07:01:06 <Hodapp> vanila: what is it with you silly Haskell folks that you also are familiar with Coq? :P
07:01:43 <vanila> Hodapp, I am not having much success with coq :S
07:02:02 <Hodapp> vanila: I'm getting through SF and I'd like to start CPDT
07:02:08 <Hodapp> but I'm finding SF plenty challenging
07:02:19 <vanila> yeah I started to look at SF, its very helpful
07:02:38 <Hodapp> I need to pick up Pierce's other book too (TAPL?)
07:03:21 <vanila> oh TAPL is great :)
07:03:24 <vanila> is that the same author?
07:03:28 <Shockk> I did end up with a name conflict, which was a bit tedious to change across my code by it works now
07:03:29 <Hodapp> I believe so
07:03:31 <merijn> vanila: Which book are you reading for Coq?
07:03:32 <Shockk> but it works now*
07:03:51 <merijn> vanila: We had a pretty good one at OPLSS and I think it's available for free
07:04:07 <vanila> merijn, Can I see? The things I did read didn'tgive me all the tools I needed
07:04:23 <Hodapp> I found some of the examples in SF to be quite good, e.g. one where it has you implement a primitive optimizer for some kinds of arithmetic, and then prove that the optimizer preserves correctness
07:04:35 <merijn> vanila: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html all the chapters are literate Coq with lots of exercises
07:04:44 <vanila> ok, ty!
07:04:51 <Hodapp> merijn: that's SF :P
07:05:22 <merijn> vanila: I recommand using either Proof General (or the vim equivalent) to let you do the exercises as interactive proofs
07:05:37 <merijn> Hodapp: Oh, I missed the start :)
07:05:53 <vanila> yeah, I have that! I dreamed about a similar editor for haskell
07:06:03 <merijn> SF has brought me full circle back to "videogame programming"
07:06:06 <vanila> where you can fill in holes and it shows you what types you have
07:06:23 <merijn> *randomly apply tactics until your proof is succesful
07:07:10 <vanila> lol
07:07:18 <vanila> I am familiar with that technique
07:07:25 <Hodapp> I try not to do that.
07:07:32 <vanila> eexcept the sucessful bit
07:07:43 <Hodapp> but sometimes, when I don't yet know what automation Coq has to further that, I will do that to get past some grunt work.
07:08:11 <danking> The time I wasted before I discovered omega ...
07:08:15 * Hodapp . o O ( is Haskell a gateway drug to harder drugs like Coq? )
07:08:25 <Twey> Hodapp: Yes.
07:08:31 <Twey> And Agda.
07:08:42 <Hodapp> what does that make Scala?
07:08:48 <Hodapp> I think Scala is what was my gateway to Haskell.
07:08:49 <Twey> Cola
07:09:07 <tac> ΩΩ=ΩΩ
07:09:10 <Hodapp> "Scala Cola: None of the calories, some of the flavor?"
07:09:20 <tac> aha! a palindrome that has no normal form!
07:09:20 <Hodapp> (all of the side effects)
07:10:17 <merijn> vanila: hdevtools lets you query type of expressions in your editor and you can just use "undefined" (or in 7.8 TypedHoles) as holes
07:10:35 <vanila> wow1
07:10:37 <vanila> :D
07:10:41 <merijn> Hodapp: No, the reverse ;)
07:10:45 <merijn> @quote roconnor coq
07:10:46 <lambdabot> roconnor says: My coq has failed me
07:10:48 <merijn> errr
07:10:53 <merijn> @quote roconnor merijn
07:10:54 <Hodapp> merijn: None of the flavor, all of the calories?
07:10:54 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
07:12:13 <Twey> Heh.
07:13:04 <Twey> I wish TypedHoles weren't an error.  Means that to play around with the hole in ghci I have to first replace the hole with undefined and then reload the file.
07:14:03 <Twey> vanila: Another classic (pre-7.8) trick is to put in something whose type is obviously wrong, like 'a', so that you get a type error detailing what GHC expected to find there
07:15:42 <merijn> Twey: It's easy
07:15:46 <Twey> (plus, errors of the form ‘Got type `Char', expected type `Wire (() → Timed NominalDiffTime) () IO Integer Integer → Wire (() → Timed NominalDiffTime) () IO () (Maybe [Foo])’ are kind of amusing)
07:15:53 <merijn> Twey: Just use -fdefer-type-errors :)
07:16:09 <Twey> merijn: But I want to *see* the error, I just don't want it to stop the file from loading :þ
07:16:33 <Twey> With -fdefer-type-errors I'd have to run the hole to get an error, I think?
07:16:42 <merijn> Ah, true
07:16:51 <Twey> Or, er, evaluate it in the general case.
07:20:28 <kstt> hi
07:21:08 <TheKing44> hello y'all
07:24:55 <TheKing44> :t unSafePerformIO getLine
07:24:57 <lambdabot> String
07:26:20 <TheKing44> When today are they releasing the new Haskell platform?
07:29:01 <tac> God bless type inference
07:29:38 <tac> I wrote [("a", thingA) ("b", thingB)] by accident, and the most logical thing is to assume I'm trying to use ("a", thingA) as a function which takes a tuple.
07:30:43 <tac> Why doesn't text have a serializable instance >____>
07:31:01 <merijn> tac: It does, it's called "encodeUtf8"
07:31:07 <ion> twey: I'm almost certain defer-type-errors still prints the errors at compile time. I don't have convenient access to ghc right now to verify it though.
07:31:39 <tac> merijn: sadly, using that jars with the generic programming ideals I was brought up on
07:33:15 <discipline> can anyone give me any hints on how to progress, I’ve spent the whole afternoon on this task yesterday, and feel I can’t progress without the help of more experient haskell programmer, the code is on the lpaste.net site: http://lpaste.net/9203982656105086976 :)
07:34:01 <joelteon> discipline, your use of $ is not correct
07:34:12 <joelteon> a $ b $ c is equivalent to a (b c)
07:34:36 <discipline> oh, I see, thanks for pointing it out
07:34:39 <joelteon> thus your usage can be expanded to replaceAtIndex (snd c (ch (m !! 0)))
07:35:01 <joelteon> if i were you, i'd just use replaceAtIndex (snd c) ch (m !! 0)
07:35:05 <joelteon> that way you don't even need to use $
07:35:09 <discipline> god, thank you so much
07:35:14 <mmachenry> discipline: Putting top-level type declarations on your two functions would help a lot.
07:35:24 <mmachenry> I think it would have caught that error.
07:35:25 <joelteon> in this case, I'm not sure it would
07:36:15 <discipline> joelteon: hurray! thank you!! it worked!!
07:36:19 <discipline> \o/
07:36:22 <joelteon> nice :)
07:37:13 <stelleg> is there a way to promote values to types at runtime, or does that even make sense?
07:37:24 <joelteon> stelleg, for what purpose?
07:37:42 <discipline> mmachenry: thanks for the tip, I didn’t put the type declarations because I was still changing the code
07:37:46 <joelteon> you can get types out of values with DataKinds, but not at runtime
07:37:53 <stelleg> joelteon: lets say I have an Vector (n :: Nat)
07:38:01 <merijn> stelleg: No, there is not, at least not a nice one
07:38:07 <joelteon> and you want to take an Int and make it :: Nat?
07:38:13 <stelleg> joelteon: yeah something like that
07:38:16 <merijn> stelleg: GHC does type erasure, so there are no types at runtime
07:38:30 <stelleg> merijn: yeah thats what I figured
07:38:31 <merijn> stelleg: So no "promoting values to types at runtime" is not very sensible
07:38:38 <stelleg> merijn: thanks
07:38:41 <anon567> what do you guys recommend reading after finishing learnyouahaskell?
07:38:44 <merijn> stelleg: Take a look at the stuff in GHC.TypeLits?
07:39:04 <stelleg> merijn: yeah I've poked around there a little, but I'll do that some more
07:39:21 <stelleg> I guess if I only care about small values
07:39:27 <merijn> anon567: Real World Haskell (skip the first few chapters on syntax), it has a decent overview of real world haskell libraries. The examples are a bit dated (i.e. API's changed), but they give a good idea of what real world code might look like
07:39:34 <merijn> anon567: Other than that, Typeclassopedia
07:39:35 <stelleg> I could do manual case splitting
07:39:39 <stolaruk> anon567: Real World Haskell, Paralell and Concurrent Programming in H, Typeclassopedia
07:39:47 <stelleg> e.g. case i of 1 -> Vec 1; 2 -> Vec 2 ..
07:39:59 * hackagebot twitter-types 0.3.20140801 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.3.20140801 (TakahiroHimura)
07:40:24 <anon567> thanks so much
07:40:43 <merijn> anon567: There's also a whole bunch of good blog posts/papers that are easy to read, depending on where your interests lie
07:40:52 <joelteon> anon567, i'd recommend trying to write something non-trivial in Haskell and see what problems you run into
07:41:06 <discipline> joelteon: I think you just changed my life, it works!!!    updateMap :: [[Char]] -> (Int, Int) -> Char -> [[Char]]            updateMap m c ch = replaceAtIndex (fst c) (replaceAtIndex (snd c) ch (m !! (fst c))) m
07:41:11 <discipline> :D
07:41:26 <joelteon> discipline, in your definition of updateMap, you can also pattern match on c
07:41:33 <stolaruk> anon567: If you've finished LYAH, I'd recommend jumping into coding a sizeable project.
07:41:39 <stolaruk> (as you read more)
07:41:42 <joelteon> updateMap m (c1, c2) ch = replaceAtIndex c1 (replaceAtIndex c2 ch (m !! c1)) m
07:41:46 <joelteon> helps remove some duplication
07:42:00 <merijn> anon567: Oh, "Write Yourself a Scheme in 48 Hours" might be good too
07:42:11 <discipline> joelteon:  thank you, I will look into that
07:42:50 <anon567> cool, i'll think up a few project ideas then
07:43:16 <discipline> joelteon: perfect, much more clear: updateMap m (y, x) ch = replaceAtIndex y (replaceAtIndex x ch (m !! y)) m
07:43:28 <discipline> joelteon: thanks once again
07:45:00 <georgiev> hello, my name is Georgi and I'm just starting out with Haskell
07:45:03 <georgiev> . I'm currently on the modules chapter where different modules and their functions are explained
07:45:25 <georgiev> do I need to go through all of them
07:45:33 <tac> http://lpaste.net/108566
07:45:37 <tac> What 's wrong here ^?
07:46:28 <c_wraith> tac: you declared an instance for every single type.  In general, GHC doesn't like that.
07:46:50 <tac> I did?
07:47:03 <tac> is that line 5 doing that?
07:47:13 <c_wraith> tac: yes.
07:47:39 <artemshitov> georgiev: you won't remember all the functions at the first read anyway, but it is good to at least get acquainted with what is available
07:47:40 <c_wraith> tac: that line says "every type is an instance of Storable that also adds a S.Serializable requirement"
07:48:02 <georgiev> thanks :)
07:49:44 <tac> c_wraith: is FlexibleInstances the right call here? I just want to create a duplicate class, but then add a new instance
07:50:03 <tac> rather than muck with Serializable, I just want to have a "copy" of that class, and extend it
07:50:08 <c_wraith> tac: In order to make that work, you'd need UndecideableInstances and OverlappingInstances
07:50:21 <tac> ah hmm
07:50:22 <c_wraith> tac: and that's very quickly headed down the path of "this is not going to be fun"
07:50:32 <tac> right
07:50:52 <tac> f it. I'll just add the serializable instance for Text...
07:53:26 <k00mi> tac: you can make a 'newtype Serializable a = Serializable a', then make an instance S.Serialize a => Storable (Serializable a) where
07:53:42 <discipline> guys, is there no visual debugging in haskell? I am using the Eclipse FP plugin, but debugging seems to be text-only
07:53:54 <discipline> would anyone recommend a better IDE?
07:53:56 <tac> k00mi: Yeah. I just find it frustrating that it's not just built in
07:55:34 <Exio4> visual debugging? like in leksah?
07:56:46 <angerman> if I change my .cabal file, I should run $ cabal install . right?
07:56:55 <latk> I'm trying to write something to go through a Text string, and remove certain characters. This is what I have so far: http://lpaste.net/108568 . I suspect I've kinda got the wrong end of the stick.
07:57:06 <k00mi> tac: it's a consequence of how typeclasses (specifically instance resolution works), if there were an easy way to make instances like that work it would probably have been implemented
07:57:08 <discipline> Exio4: will search for that, thanks
07:57:45 <tac> k00mi: I'm fine with the limitation. I just think it's obnoxious that there's no built-in instance for this.
07:57:55 <tac> because they wanted you to choose an encoding first
07:59:43 <k00mi> ah, I see
08:00:29 <tac> Is there a reason serialize is written in terms of these weird Put and Get monads rather than just a straight up encode decode function pair?
08:00:55 <tac> I really want to just define encode = encodeUtf8, but I really need to define put instead
08:01:23 <c_wraith> tac: you need your data to be delimited - assume it's in a stream of data.
08:01:29 <glguy> it's like that so you can efficiently get and put more than a single thing at a time
08:01:37 <plhk> latk: Data.Text.filter ?
08:01:56 <c_wraith> tac: that's the whole point of the monad instances, by the way.  So you can easily serialize an object that contains a Foo and a [Bar]
08:01:56 <tac> ah
08:02:27 <latk> plhk: Hah, that might be easier.
08:04:28 <nathanielchannin> Is there a ghci mode in emacs somewhere? I'm having trouble finding one D=
08:05:09 <c_wraith> There's a ghci interactive buffer mode in haskell-mode
08:05:53 <nathanielchannin> Win sauce
08:10:03 * hackagebot yesod-platform 1.2.12.3 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12.3 (MichaelSnoyman)
08:22:01 <AleksejsHome> Hi, here is a snippet from my code http://vpaste.net/kga7r . What I want to do is to perform that mapM_ in parallel thread so the main program is not blocked by it. Any advice?
08:26:28 <k00mi> AleksejsHome: mapConcurrently from the async package is a concurrent mapM
08:26:58 <AleksejsHome> @hoogle mapConcurrently
08:27:01 <lambdabot> No results found
08:30:05 <zereraz> hello, can you tell me what is wrong here http://lpaste.net/108554  the input code is written by someone else
08:30:41 <k00mi> AleksejsHome: hm, do you want to perform the entire map in parallel or each sendHistory in a seperate thread
08:30:51 <AleksejsHome> entire map
08:31:35 <AleksejsHome> that map takes up to 50 entries from history and sends them one by one with random interval 0.5 to 1.5 sec
08:31:50 <c_wraith> zereraz: well...  What's wrong with it?  From a very quick glance, it looks sane.
08:31:51 <AleksejsHome> and when it does that, program is blocked
08:32:50 <josephle> zereaz: what is the type of "f n $ map (read :: String -> Int) $ lines inputdata"?
08:33:06 <zereraz> sorry net problem
08:33:08 <c_wraith> zereraz: ah, the problem is that you're not supposed to be generating IO actions.
08:33:23 <zereraz> c_wraith: then?
08:33:31 <zereraz> c_wraith: do I need a do?
08:33:34 <TheKing444> :t f n $ map (read :: String -> Int) $ lines inputdata
08:33:36 <lambdabot> Not in scope: ‘inputdata’
08:33:50 <c_wraith> zereraz: look at how the output code is treating the result of your function.
08:34:05 <zereraz> oh
08:34:07 <zereraz> got it
08:34:13 <zereraz> c_wraith: they are printing it for me
08:34:42 <c_wraith> exactly
08:34:44 <zereraz> c_wraith: they wrote a comment that not to mess with the input code and I didn't read it
08:34:53 <zereraz> c_wraith: silly me
08:34:58 <zereraz> c_wraith: thanks allot!!
08:35:23 <c_wraith> zereraz: josephle also noticed it, he just only said something when you were disconnected. :)
08:35:36 <zereraz> josephle: thanks!
08:35:42 <zereraz> sorry about that!
08:36:00 <zereraz> does replicate only take functions as 2nd argument?
08:36:12 <zereraz> I want to repeat the number that many times
08:36:19 <zereraz> but now without printing it
08:37:24 <zereraz> how do I replicate things in a list
08:37:32 <eikke__> :t replicate
08:37:33 <lambdabot> Int -> a -> [a]
08:38:33 <zereraz> ok thanks
08:38:34 <AleksejsHome> zereraz: maybe you need cycle?
08:39:19 <glguy> zereraz: Did you figure out your 3/5 multiples summing problem?
08:39:40 <AleksejsHome> k00mi: any idea?
08:39:50 <zereraz> 1 sec guys sorry
08:40:54 <zereraz> ok back
08:41:14 <zereraz> AleksejsHome: I have not done much with cycle , I failed
08:41:20 <zereraz> glguy: I found a pattern
08:41:25 <zereraz> glguy: 2131 233
08:41:47 <zereraz> glguy: this repeats , each digit is difference of consecutive digits
08:42:26 <zereraz> glguy: I was trying to implement it with cycle [2,1,3,1,2,3,3] and was not able to code it, it was tough
08:42:34 <zereraz> glguy: is the pattern right?
08:42:51 <glguy> It happens to be right but it is hard to use it directly
08:42:57 <AleksejsHome> > take 10 $ cycle [2,1,3,1,2,3,3]
08:42:59 <lambdabot>  [2,1,3,1,2,3,3,2,1,3]
08:43:26 <glguy> You know there's a fast way to add up the multples of 3 without actually enumerating them all, right?
08:43:31 <glguy> (this is going somewhere)
08:43:54 <zereraz> glguy: multiplication
08:44:03 <glguy> and there's a fast way to add up the multiples of 5?
08:44:16 <zereraz> glguy: multiplication
08:44:34 <glguy> OK, but why can't you just add the first sum (3s) to the second sum (5s)?
08:44:47 <vanila> 5 + 10 + 15 + .. = 5*(1 + 2 + 3 + ...)
08:45:01 <orion> Are these type signatures all equivalent?: a -> b -> c -- a -> (b -> c) -- (a -> b) -> c -- ?
08:45:10 <glguy> orion: No, the first two ar ethe same
08:45:32 <zereraz> vanila: isn't that kind of enumeration
08:45:44 <vanila> it's called distributivity
08:45:52 <zereraz> vanila: yeah
08:45:57 <orion> glguy: So type signatures are right associative?
08:46:00 <glguy> Yes
08:46:02 <Ankhers> glguy: because you would be adding numbers like 15 twice
08:46:07 <glguy> well, the -> operation is right associative
08:46:27 <glguy> Right, so you have to correct for the 15s
08:46:32 <zereraz> glguy: I don't know why
08:46:47 <zereraz> glguy: multiply and add should work
08:46:49 <glguy> some of the numbers are duplicates in the 3s list and the 5s list
08:46:51 <Ankhers> glguy: oh. I didn't realize you were trying to tutor someone through the problem.
08:47:08 <zereraz> glguy: oh yeah
08:47:20 <zereraz> lcm
08:47:28 <AleksejsHome> zereraz: are you trying to get a sum of 3s and 5s?
08:47:47 <zereraz> AleksejsHome: not with the problem I had now
08:47:53 <glguy> zereraz: You only get to use basic arithmetic to solve this problem: +, -, *, `quot`
08:47:58 <zereraz> AleksejsHome: but I was
08:48:00 <glguy> So don't worry about any other functions
08:48:26 <ab9rf> is there a generic version of chunksOf from Data.Text?  i needed the same idea for [Word8] and didn't find it.
08:48:30 <zereraz> glguy: I am not able to understand how to do it without enumeration
08:48:49 <zereraz> glguy: so do we subtract the common elements
08:48:58 <glguy> yes
08:49:00 <zereraz> glguy: subtract the sum of common elements
08:49:07 <zereraz> is that it?
08:49:13 <glguy> basically
08:49:21 <ab9rf> i mean, it was trivial to pull the source from Data.Text and redefine it with a more generic type signature, but i don't want to reinvent the wheel
08:49:23 <zereraz> common elements are multiples of lcm right
08:49:38 <glguy> yeah
08:49:39 <zereraz> 15
08:49:49 <zereraz> multiples of 15 we sum and subtract!
08:50:08 <AleksejsHome> > sum $ map (\x -> x * (\n -> (1 + n) * n `div` 2) (1000 `div` x)) [3,5,-15]
08:50:10 <lambdabot>  234168
08:50:24 <TheKing444> New question on Stack Overflow: http://stackoverflow.com/q/25083979/1172541
08:50:42 <zereraz> AleksejsHome: wow
08:51:03 <zereraz> can someone explain the \n and \x , I know they are like the curry functions
08:51:06 <zereraz> that take 1 value
08:51:17 <zereraz> but I have never used them
08:51:28 <ab9rf> zereraz: \n -> ... is an anonymous function definition
08:51:29 <AleksejsHome> it's just a lambda function
08:51:39 <zereraz> AleksejsHome: oh
08:51:45 <zereraz> ab9rf: ok
08:51:50 <AleksejsHome> > (\x -> x*3) 2
08:51:52 <lambdabot>  6
08:51:55 <zereraz> something just made up in between
08:52:01 <AleksejsHome> yes
08:52:02 <zereraz> that works as function
08:52:06 <ab9rf> :t (\n -> x*3)
08:52:07 <lambdabot> t -> Expr
08:52:10 <zereraz> I have used them in javascrip
08:52:15 <zereraz> javascript*
08:52:17 <ab9rf> oops
08:52:19 <ab9rf> :t (\n -> n*3)
08:52:21 <lambdabot> Num a => a -> a
08:52:42 <zereraz> glguy: thank you very much!
08:52:48 <zereraz> thanks everyone who helped
08:52:51 <glguy> :)
08:53:00 <josephle> :t \f -> (\x -> f x x) (\x -> f x x)
08:53:01 <ab9rf> > map (\n -> n*3) [1..5]
08:53:02 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ t -> t1
08:53:02 <lambdabot>     Relevant bindings include
08:53:02 <lambdabot>       x :: t (bound at <interactive>:1:23)
08:53:03 <lambdabot>  [3,6,9,12,15]
08:53:06 <josephle> :(
08:53:07 <zereraz> I will go back to the 3 and 5 after I solve this repetition problem
08:53:42 <glguy> zereraz: If you're going through programming problems I recommend looking at: http://rosalind.info/problems/tree-view/?location=algorithmic-heights
08:53:54 <dfeuer_> @info Typable
08:53:55 <lambdabot> Typable
08:54:05 <glguy> the problems are focused on implementing common algorithms rather than math insights
08:54:13 <zereraz> glguy: I went there once
08:54:16 <TheKing444> @src map
08:54:16 <lambdabot> map _ []     = []
08:54:17 <lambdabot> map f (x:xs) = f x : map f xs
08:54:19 <zereraz> glguy: ok I will start using them
08:54:32 <zereraz> glguy: I am solving from hackerrank
08:54:35 <glguy> zereraz: Up to you, of course, I just found that it was well done
08:55:09 <zereraz> glguy: I am not very good at solving such questions
08:55:24 <ab9rf> a lot of these "problem" sites are really throwing discrete math problems at people, and the solutions hinge on finding the discrete math trick, rather than a programming trick
08:55:53 <zereraz> ab9rf: true but I just suck at problem solving in general, so I am practicing it
08:55:54 <k00mi> AleksejsHome: did you solve it yet? :)
08:56:01 <ab9rf> zereraz: nothing wrong with that
08:56:06 <AleksejsHome> k00mi: no
08:56:18 <ab9rf> zereraz: i did about 35 of the project euler problems when i was first learning haskell
08:56:53 <k00mi> AleksejsHome: ok, so basically you want to fork that action and not care about it anymore?
08:56:56 <ab9rf> hm, this code still sucks too much memory
08:56:58 <zereraz> ab9rf: I did 10 when I was learning other languages, I started haskell like 1 week or 2 ago
08:57:11 <AleksejsHome> k00mi: yes
08:57:50 <anon567> is there an irc for project euler?
08:57:55 <AleksejsHome> I want to let it work somehow and give the control to programm back immediately
08:58:23 <k00mi> AleksejsHome: the basic primitive for forking is forkIO from Control.Concurrent
08:58:41 <AleksejsHome> yes, but I stuck in implementing it in my code
08:58:42 <k00mi> AleksejsHome: but that takes an IO () but your action is not IO :/
08:58:49 <AleksejsHome> yes :(
08:59:02 <nick_named> anon567: I haven't been able to find one that is active.
08:59:18 <ab9rf> it's fairly trivial to make it into an IO, i should think
08:59:23 <glguy> AleksejsHome: It just means you'll need to "run" your Bot computation just before you call forkIO
08:59:30 <dfeuer_> That's hilarious. Facebook appears to be down.
08:59:36 <ab9rf> dfeuer_: about time!
08:59:39 <glguy> AleksejsHome: But that's OK because your computation has static data so you don't have to worry about folding that back in
09:00:18 <ab9rf> hrm, it's not quite half way and the working set is 1.2 gigabytes, i have a feeling this isn't going to work out well
09:01:05 <AleksejsHome> glguy: do you mean that I need to make all computations and then give it to forkIO?
09:01:50 <glguy> you'll have: hist x ys = forkNet (mapM_ (sendHistory x) ys)
09:02:19 <glguy> AleksejsHome: and then forkNet m = do e <- ask; forkIO (runRWST e () [] m)
09:02:22 <glguy> or something like that
09:02:36 <glguy> you'll have to liftIO that forkIO back into your Net monad
09:02:58 <AleksejsHome> makes sense
09:02:59 <glguy> but that's the basic pattern, run your computation inside the forkIO and rewrap it
09:03:24 <glguy> keeping in mind that the thread will have its own "MessageStack"
09:03:42 <AleksejsHome> that's ok
09:08:11 <dfeuer_> Is there a function     hylosomething c n f b = foldr c n (unfoldr f b)   in some common library? I'm not looking for something so general I can't understand it (yet).
09:08:57 <TheKing444> dfeuer_, this a hylo function Data.Functor.Fixedpoint
09:09:23 <TheKing444> hylo :: (a->f a)->(f b->b)->(a->b)
09:09:59 <TheKing444> @def hylo u d = let phi = d . fmap phi . u
09:09:59 <lambdabot>  Parse failed: Parse error: EOF
09:10:11 <TheKing444> @def hylo u d = let phi = d . fmap phi . u in phi
09:10:13 <lambdabot>  Defined.
09:10:16 <TheKing444> :t hylo
09:10:17 <lambdabot> Functor f => (a -> f a) -> (f b -> b) -> a -> b
09:10:37 <dfeuer_> How's that relate exactly, TheKing44?
09:10:53 <TheKing444> It has the word hylo in it.
09:10:58 <dfeuer_> OK.
09:11:05 <TheKing444> It is also about building stuff up and then breaking it down.
09:11:26 <dfeuer_> How do it do dat?
09:11:56 <TheKing444> let me think of an example
09:12:07 <TheKing444> ah, I think I got it
09:12:22 <TheKing444> > hylo tails (\x -> length x + sum x)
09:12:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:12:25 <lambdabot>    arising from a use of ‘M45827811199198639595605.show_M45827811199198639595...
09:12:25 <lambdabot>  The type variable ‘a0’ is ambiguous
09:12:25 <lambdabot>  Note: there are several potential instances:
09:12:25 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
09:12:34 <TheKing444> :t hylo tails (\x -> length x + sum x)
09:12:35 <lambdabot> [a] -> Int
09:13:00 <TheKing444> > hylo tails (\x -> length x + sum x) ["Hi", "I", "am", "Bob"]
09:13:06 <lambdabot>  mueval-core: Time limit exceeded
09:13:06 <lambdabot>  mueval: ExitFailure 1
09:13:14 <dfeuer_> That did not work.
09:13:22 <TheKing444> Well, it returned bottom.
09:13:29 <TheKing444> Hmm, but let me make a better one.
09:13:59 <TheKing444> > hylo (\x->[0..x-1]) (concat) 4
09:14:01 <lambdabot>  []
09:14:06 <TheKing444> wait no
09:14:50 <TheKing444> > hylo (\x->[0..x-1]) (\x -> length x + sum x) 4
09:14:52 <lambdabot>  15
09:14:57 <TheKing444> YEAH!
09:15:06 <TheKing444> what is another cool functor?
09:15:41 <TheKing444> Ohh, wait I got it
09:15:53 <TheKing444> @def data Nat = Zero | Succ Nat
09:15:55 <lambdabot>  Defined.
09:16:27 <TheKing444> :t toMaybe
09:16:28 <lambdabot> Not in scope: ‘toMaybe’
09:16:32 <TheKing444> :t safeHead
09:16:33 <lambdabot> Not in scope: ‘safeHead’
09:16:43 <TheKing444> What function turns list into maybe again?
09:17:05 <dfeuer_> > hylo sum (\n -> [1..n]) 12
09:17:07 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ f0 [t]
09:17:07 <lambdabot>  Relevant bindings include n :: f0 [t] (bound at <interactive>:1:12)
09:17:10 <Fuuzetsu> :t listToMaybe
09:17:11 <lambdabot> [a] -> Maybe a
09:17:54 <pjdelport> TheKing444: There's this example: http://www.reddit.com/r/programming/comments/2h0j2/real_quicksort_in_haskell/c2hwvl?context=3
09:17:55 <Fuuzetsu> > (listToMaybe [], listToMaybe [1 ..])
09:17:57 <lambdabot>  (Nothing,Just 1)
09:18:03 <TheKing444> > hylo listToMaybe (\x -> case x of; Just x -> Succ x; Nothing -> Zero) [6,8,2,8,2]
09:18:05 <lambdabot>  Occurs check: cannot construct the infinite type: a0 ~ [a0]
09:18:05 <lambdabot>  Expected type: [a0] -> Data.Maybe.Maybe [a0]
09:18:05 <lambdabot>    Actual type: [a0] -> Data.Maybe.Maybe a0
09:18:16 <TheKing444> darn
09:18:19 <TheKing444> :t hylo
09:18:20 <lambdabot> Functor f => (a -> f a) -> (f b -> b) -> a -> b
09:19:19 <TheKing444> :t listToMaybe
09:19:21 <lambdabot> [a] -> Maybe a
09:19:25 <dfeuer_> TheKing44, the type hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b  looks very weird.
09:19:38 <TheKing444> > hylo (map (:[]) . listToMaybe) (\x -> case x of; Just x -> Succ x; Nothing -> Zero) [6,8,2,8,2]
09:19:40 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe a0’ with ‘[a0]’
09:19:41 <lambdabot>  Expected type: [a0] -> [a0]
09:19:41 <lambdabot>    Actual type: [a0] -> Data.Maybe.Maybe a0Couldn't match type ‘Data.Maybe.Ma...
09:19:41 <lambdabot>  Expected type: [L.Nat]
09:19:41 <lambdabot>    Actual type: Data.Maybe.Maybe L.NatCouldn't match type ‘Data.Maybe.Maybe’ ...
09:19:45 <Fuuzetsu> you flipped the arguments dfeuer_
09:19:53 <TheKing444> > hylo (fmap (:[]) . listToMaybe) (\x -> case x of; Just x -> Succ x; Nothing -> Zero) [6,8,2,8,2]
09:19:55 <lambdabot>  No instance for (GHC.Show.Show L.Nat)
09:19:55 <lambdabot>    arising from a use of ‘M27925002665153991305822.show_M27925002665153991305...
09:20:18 <TheKing444> @def data Nat = Zero | Succ Nat deriving (Show, Eq, Ord)
09:20:19 <lambdabot>  .L.hs:153:1:
09:20:19 <lambdabot>      Multiple declarations of ‘Nat’
09:20:19 <lambdabot>      Declared at: .L.hs:150:1
09:20:19 <lambdabot>                   .L.hs:153:1
09:20:19 <lambdabot>  
09:20:20 <dfeuer_> Fuuzetsu, the type I just typed is what's in Data.Functor.Fixedpoint
09:20:25 <TheKing444> ah oh well
09:20:28 <Fuuzetsu> ah
09:20:33 <dfeuer_> :type hylo
09:20:37 <dfeuer_> :t hylo
09:20:38 <lambdabot> Functor f => (a -> f a) -> (f b -> b) -> a -> b
09:20:50 <dfeuer_> But this one is the other way.
09:20:50 <pqmodn__> > deriving instance Show Nat
09:20:52 <lambdabot>  <hint>:1:1: parse error on input ‘deriving’
09:21:02 <dfeuer_> > hylo (\n -> [1..n]) sum 12
09:21:08 <lambdabot>  mueval-core: Time limit exceeded
09:21:08 <lambdabot>  mueval: ExitFailure 1
09:21:22 <TheKing444> I should explain hylo.
09:21:36 <mietek> Is there a nice way to init a record with lenses?
09:21:43 <edwardk> no
09:21:53 <dfeuer_> I honestly don't see how that type could be inhabited.
09:22:01 <edwardk> you use the _'d evil normal things
09:22:05 <mietek> Right.
09:22:08 <TheKing444> hylo basically keeps doing it builder up thing with the first function until you hit all `[]`, and then it breaks it down with the breaker down function
09:22:27 <TheKing444> it is an anamorphism and catamorphism combined
09:23:09 <TheKing444> Except you don't need the intermediate Functor Fixed Point
09:23:17 <dfeuer_> TheKing44, with an (a->f a) and an a, you get an f a. But you don't have anything you can use with the f a to end up with a b.
09:23:18 <benzrf> metamorphism is the opposite rite
09:23:28 <TheKing444> I have no idea.
09:23:32 <dfeuer_> So what am I missing?
09:24:18 <dfeuer_> If you have an `f b`, you can get a `b`, but you only have an `f a`.
09:24:35 <pqmodn__> don't forget about anthropomorphisms
09:24:45 <dfeuer_> pqmodn__++
09:25:03 <Fuuzetsu> is there a morphism phobia?
09:25:18 <dfeuer_> TheKing44, so I really don't see how that hylo function can do anthing but produce bottoms. Am I missing something?
09:25:40 <dfeuer_> Morphisms are boring. _____morphisms are inscrutable.
09:25:55 <Fuuzetsu> Apparently not. I did come across something called MORPHISM OF FEAR though so I guess my time wasn't wholly wasted.
09:26:03 <benzrf> pqmodn__: anthro :: f a -> hello i can speak english
09:26:22 <dfeuer_> Fuuzetsu, can you find a way to make that hylo function return something other than bottom?
09:26:52 <{AS}> You could use the Id functor right?
09:28:22 <Fuuzetsu> I'd probably pop it into Agda and see what that comes up with rather than trying to think about it
09:28:33 <benzrf> > hylo (:[]) head 3
09:28:35 <lambdabot>  can't find file: L.hs
09:28:39 <Fuuzetsu> :^)
09:28:39 <benzrf> > hylo (:[]) head 3
09:28:43 <lambdabot>  mueval-core: Time limit exceeded
09:28:46 <benzrf> oh, right
09:28:47 <benzrf> :-o
09:29:02 <benzrf> > hylo (const []) (const 4) 4
09:29:04 <lambdabot>  4
09:29:05 <benzrf> i'm a genius!
09:29:47 <dfeuer_> Yes, benzrf. You are. How about a useful use?
09:30:58 <benzrf> :t listToMaybe
09:30:58 <dfeuer_> OK, I forgot the implicit argument fmap.
09:31:00 <lambdabot> [a] -> Maybe a
09:31:07 <dfeuer_> That must show up.
09:31:19 <Fuuzetsu> there's an example of hylo being used to implement factorial on Point-free Programming with Hylomorphisms presentation
09:32:59 <TheKing44> > hylo return join :: Maybe Char
09:33:00 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Char’
09:33:01 <lambdabot>              with actual type ‘a0 -> f0 a1’
09:33:14 <dfeuer_> With that, the type becomes  hylo :: Functor f => (forall c d . (c -> d) -> f c -> f d) -> (f b -> b) -> (a -> f a) -> a -> b
09:33:32 <TheKing44> > hylo return join 4
09:33:34 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
09:33:35 <lambdabot>    arising from a use of ‘M19502633608323796456218.show_M19502633608323796456...
09:33:35 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
09:33:35 <lambdabot>  Note: there are several potential instances:
09:33:35 <lambdabot>    instance [safe] GHC.Show.Show a =>
09:33:45 <dfeuer_> Which means the (a -> f a) argument can be used to get an f b.
09:34:29 <Pythonfant> damnit I think I killed my haskell-mode
09:34:43 <Fuuzetsu> I should update mine
09:34:47 <Pythonfant> I started using melpa instead of getting it from git
09:34:58 <Fuuzetsu> tsk tsk tsk
09:35:02 <Pythonfant> and now haskell-interactive-mode doesn't seem to recognize cabal sandboxes anymore
09:35:10 <Pythonfant> did anyone experience something similar?
09:35:21 <Fuuzetsu> maybe you have an old version now
09:35:58 <dfeuer_> Or .... no.
09:36:46 <Pythonfant> Fuuzetsu: I don't think so the version number suggests it's from the 26th of july
09:36:48 <iteratee> Fuuzetsu: I cabalized the bittorrent-tracker
09:36:58 <Fuuzetsu> I saw
09:36:59 <Fuuzetsu> thanks
09:37:23 <Fuuzetsu> are you planning to put it on hackage?
09:37:52 <ab9rf> i suppose i ought to packageize this code, once i'm satisfied that it works
09:40:12 * hackagebot geodetics 0.0.2 - Terrestrial coordinate systems and associated calculations.  http://hackage.haskell.org/package/geodetics-0.0.2 (PaulJohnson)
09:41:06 <danielsmw> Is there a simple way to lift a function argument into a monad? As in take (a -> m b) to (m (a -> b))?
09:41:37 <iteratee> I hadn't planned on doing it yet. I think it still needs some cleaning up.
09:41:45 <Fuuzetsu> @hoogle Monad m => (a -> m b) -> m (a -> b)
09:41:48 <lambdabot> No results found
09:41:59 <danielsmw> huh
09:41:59 <Pythonfant> hm removing the melpa version and using the one from github again doesn't change a thing
09:42:19 <MP2E> @hoogle Applicative f => (a -> f b) -> f (a -> b)
09:42:19 <lambdabot> No results found
09:42:21 <MP2E> o.o
09:42:26 <Fuuzetsu> iteratee: That's probably right, I'll almost certainly be asking for features/sending PRs your way anyway
09:42:41 <dfeuer_> What does absentError do?
09:43:08 <sipa> MP2E, Fuuzetsu, danielsmw: i do not believe it is possible
09:43:34 <sipa> how fo you turn a -> [b] into [a -> b]?
09:43:50 <sipa> the first can have a list length depending on a, the second can't
09:44:07 <Twey> Netwire question: I think I'm fundamentally misunderstanding either ‘at’ or ‘hold’.  Why does http://lpaste.net/8367860189814063104 keep printing 2 even after the third second has passed?  Shouldn't it update with the latest value when the RHS of the alternative fires?
09:44:15 <MP2E> danielsmw : Would bind work for your purposes?
09:44:27 <MP2E> In that case, the function a -> m b would take an m a and return an m b
09:44:27 <danielsmw> MP2E: I'm not sure what bind is.
09:44:33 <danielsmw> oh
09:44:34 <MP2E> (>>=)
09:44:39 <danielsmw> right :)
09:45:08 <danielsmw> No, I don't think so unfortunately. I have a function-builder inside a monad
09:45:12 <MP2E> Ahh
09:45:14 <MP2E> hmm
09:45:21 <danielsmw> nominally building a function of one variable which I want to use at the end
09:45:37 <danielsmw> but it turns out that "building" the function, it's more convenient to work with non-functions in the monad
09:45:38 <benzrf> @src on
09:45:39 <lambdabot> (*) `on` f = \x y -> f x * f y
09:46:53 <josephle> :t on
09:46:55 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:47:02 <pjdelport> > ((*) `on` f) x y :: Expr
09:47:04 <lambdabot>  f x * f y
09:47:07 <josephle> wow, you can use (*) as a function argument?
09:47:08 <lf94> Hey, I'm trying to run this example: https://github.com/timbod7/haskell-chart/wiki/example-1, but I get this error: No instance for (Default FileOptions) arising from a use of `def', am I missing something in my Haskell setup?
09:47:34 <pjdelport> josephle: You can use any function as a function argument, and all Haskell operators are just functions.
09:48:14 <joelteon> you can use anything with kind * as an argument
09:48:21 <pjdelport> josephle: The (*) syntax makes an infix function prefix, and the `map` syntax makes a prefix function infix. There's no other difference, really.
09:48:21 <josephle> pjdelport: I was referencing to the fact that the definition of on uses (*) as an argmuent variable
09:48:29 <josephle> not passing (*) to f
09:48:35 <josephle> but using (*) in the definition of f
09:48:37 <josephle> erm
09:48:38 <josephle> on
09:49:33 <MP2E> danielsmw : not sure without seeing the source, perhaps lpaste ?
09:49:43 <pjdelport> josephle: Right, but that comes down to the same thing. :) There's no difference between them, including being able to use both e.g. map and (*) as parameter names.
09:51:56 <amf> is there an easy way to get the nth field from my custom data type? without explicitly listing all the argument possibilities
09:52:11 <ab9rf> amf: lenses has a function for that iirc
09:52:34 <amf> oh, i thought lenses only worked on records? i shall do more research
09:52:39 <benzrf> > ((+) `on` f) x y
09:52:40 <lambdabot>  No instance for (GHC.Show.Show a0)
09:52:41 <lambdabot>    arising from a use of ‘M63601996556805628686479.show_M63601996556805628686...
09:52:41 <lambdabot>  The type variable ‘a0’ is ambiguous
09:52:41 <lambdabot>  Note: there are several potential instances:
09:52:41 <lambdabot>    instance [safe] GHC.Show.Show
09:52:44 <benzrf> > ((+) `on` f) x y :: Expr
09:52:46 <lambdabot>  f x + f y
09:53:00 <josephle> pjdelport: that's not quite what I meant. I meant I didn't realize you could use operator syntax on parameter names e.g. the parens
09:53:04 <ab9rf> amf: sorry, i misunderstood your question
09:53:21 <ab9rf> amf: i believe you're correct in that regard
09:54:03 <amf> ab9rf: it was a poorly worded question...
09:54:24 <amf> lets say my data type has 30 fields (i know, its a lot), and i want to access the 25th easily. is that possible?
09:54:34 <pjdelport> josephle: One way to think about it is that the () and `` aren't truly special, and that all functions have two opaque names: prefix f and infix `f`, or prefix (*) and infix *
09:55:01 <lf94> > def
09:55:03 <lambdabot>  ()
09:55:11 <lf94> > (def)
09:55:12 <josephle> ah, okay
09:55:13 <lambdabot>  ()
09:55:33 <Twey> The () isn't special, but the `` are magic for some reason.
09:55:35 <lf94> >:t Default FileOptions
09:55:52 <lf94> :t Default FileOptions
09:55:53 <lambdabot> Not in scope: data constructor ‘Default’
09:55:53 <lambdabot> Not in scope: data constructor ‘FileOptions’
09:56:11 <pjdelport> josephle: So the rule is just that for parameter names, you use the prefix form (whether it's alphabetic or symbolic)
09:56:23 <ab9rf> () are only special when they are adjacent to "punctuation"
09:56:25 <glguy> You can actually generically derive the lens _1 _2 _3... functions for your custom types
09:56:37 <lf94> :t FileOptions
09:56:38 <lambdabot> Not in scope: data constructor ‘FileOptions’
09:56:44 <lf94> What the heck
09:56:59 <lf94> :t (Default FileOptions)
09:57:00 <lambdabot> Not in scope: data constructor ‘Default’
09:57:00 <lambdabot> Not in scope: data constructor ‘FileOptions’
09:57:03 <supki> I don't think there's _25 though
09:57:08 <lf94> Haskell is lying to me
09:57:21 <lf94> "No instance for (Default FileOptions) arising from a use of `def'"
09:57:24 <Twey> lf94: Not everything that exists is in lambdabot…
09:57:36 <lf94> lambdabot is a demi god
09:57:38 <lf94> It should
09:57:40 <ab9rf> and lots of things that are in lambdabot probably shouldn't really exist :)
09:58:40 <ab9rf> wee
09:58:43 <ab9rf> out of memory again
09:58:50 <MP2E> :<
09:58:51 <MP2E> ouch
09:58:53 <MP2E> I hate when that happens
09:59:10 <ab9rf> i'm actually writing a reader for minecraft anvil files
09:59:46 <ab9rf> it does the reading just fine, but i'm obviously hanging on to too much deferred computation
10:00:14 * hackagebot djinn-ghc 0.0.1 - Generate Haskell code from a type. Bridge from Djinn to GHC API.  http://hackage.haskell.org/package/djinn-ghc-0.0.1 (AlejandroSerrano)
10:00:21 <MP2E> ooh neat, will it be a map editor?
10:00:35 <ab9rf> MP2E: i haven't written an NBT serializer yet
10:01:00 <ab9rf> MP2E: and writing chunks back to an anvil file is slightly tricky
10:01:20 <mmmm> @hoogle Word8 -> Word8 -> Word16
10:01:21 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:01:21 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
10:01:21 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
10:01:30 <ab9rf> MP2E: you might need to move it if the chunk to be written back is larger than what you pulled out
10:02:31 <enthropy> amf: gmapQ 24 (mkQ Nothing Just) :: (Data a, Typeable t) => a -> Maybe t
10:02:34 <tromp__> :t min
10:02:35 <lambdabot> Ord a => a -> a -> a
10:02:39 <enthropy> that will grab your 25'th field
10:02:40 <tromp__> :t minimum
10:02:41 <lambdabot> Ord a => [a] -> a
10:02:47 <enthropy> assuming it has type 't'
10:03:21 <enthropy> > gmapQ 1 (mkQ Nothing Just) (1,2) :: Maybe Int
10:03:23 <lambdabot>  Not in scope: ‘mkQ’
10:03:31 <enthropy> > gmapQ 1 (Data.Generics.mkQ Nothing Just) (1,2) :: Maybe Int
10:03:33 <lambdabot>  Not in scope: ‘Data.Generics.mkQ’
10:03:41 <ab9rf> mmmm: \x a b -> (a `shift` 8) .|. b
10:04:18 <orion> Why does this make sense?:
10:04:19 <orion> liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:04:19 <orion> liftA2 h fa fb = (h `fmap` fa) <*> fb
10:04:26 <amf> enthropy: awesome! thanks for pointing me in the right direction
10:04:36 <enthropy> oops I meant gmapQi, but for whatever reason lambdabot doesn't have syb
10:04:53 <orion> fmap has type (a -> b) -> f a -> f b, not (a -> b -> c) -> f a -> f b
10:05:03 <orion> So, I am confused why that code works
10:05:37 <ab9rf> mmmm: reverse a and b if you want the other endedness
10:05:53 <enthropy> amf: a separate class like Field4 will be safer, since  (gmapQi 1 (mkQ Nothing Just) (1,2) :: Maybe Int) == Nothing
10:06:04 <enthropy> but  (gmapQi 1 (mkQ Nothing Just) (1,2) :: Maybe Integer) == Just 2
10:06:50 <enthropy> hmm, mkQ Nothing Just == cast
10:06:59 <MP2E> orion : Well, consider function currying and the definition of (<*>) from Applicative :)
10:07:17 <MP2E> Basically say we have a function (a -> b -> c) and we want to apply it to f a and f b
10:07:36 <MP2E> So if we do fmap over our function what do we get?
10:08:06 <orion> I don't think (h `fmap` fa) should work
10:08:16 <orion> h has type (a -> b -> c), not (a -> b)
10:08:25 <amf> enthropy: where is field4 defined? (hoogle didnt know about it)
10:08:32 <orion> fmap takes as its first parameter something with type (a -> b)
10:08:40 <enthropy> orion: you can take "fmap :: (a -> b) -> f a -> f b" and set b ~ (d->e) to get   fmap :: (a -> (d -> e)) -> f a -> f (d->e)
10:08:50 <MP2E> exactly
10:08:58 <enthropy> but  a -> (d -> e) is the same as  a -> d -> e
10:09:07 <MP2E> and f ( d -> e ) is where we'd get stuck if not for (<*>)
10:09:09 <enthropy> amf: lens
10:10:14 <enthropy> amf: but they only go up to Field9, so you'd have to write some more of them (up to 25?)
10:11:08 <orion> MP2E: So (h `fmap` fa) has type f (b -> c) ?
10:11:20 <MP2E> exactly :)
10:11:33 <orion> Interesting!
10:11:54 <orion> Yay learning!
10:11:58 <amf> enthropy: ok, ill start going through these new libraries / docs. thanks again!
10:12:01 <MP2E> And since `fmap` == <$>, you may notice that things of the pattern "function <$> argument1 <*> argument2 <*> argument3" are really just using fmap to lift a function over multiple arguments
10:12:07 <MP2E> the more <*>, the more arguments you have :D
10:12:47 <orion> hmm
10:13:07 <TheKing44> @check fmap f x == f <$> x
10:13:09 <lambdabot>  Precedence parsing error
10:13:09 <lambdabot>  cannot mix ‘GHC.Classes.==’ [infix 4] and ‘Data.Functor.<$>’ [infixl 4] in t...
10:13:19 <MP2E> o.o
10:13:34 <MP2E> @check (fmap f x) == (f <$> x)
10:13:35 <lambdabot>  Couldn't match expected type ‘f0 a0’
10:13:35 <lambdabot>  with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match expected type...
10:13:56 <TheKing44> @check fmap f x == (f <$> x))
10:13:57 <lambdabot>  <unknown>.hs: 1: 22:Parse error: )
10:15:36 <orion> MP2E: So in other words, if my goal is to operate on values that exist within a computational context, I should write a generic function that doesn't limit me to one kind of context, and I should make use of that function via applicatives, right?
10:16:25 <MP2E> orion : exactly :) Functor and Applicatives do the 'heavy lifting' for you :P
10:17:06 <RyanGlScott> Is Haskell's FFI capable of marshalling stack-allocated arrays? e.g., struct foo { int bar[42]; }
10:17:33 <RyanGlScott> I have lots of trouble trying to get/set int bar[42], but no trouble getting/setting int *bar.
10:20:44 <orion> MP2E: Is it correct to say that if I write a function with type (a -> b -> c), it won't be callable from a function of type IO () unless I lift it in to the monadic context?
10:22:56 <pjdelport> orion: Another thing to note is that f <$> x <*> y is just short for: pure f <*> x <*> y
10:23:24 <MP2E> orion : You could call it normally if the types line up, but ultimately the result will become IO, because that is what main requires as its return value :) So the real answer is 'it depends'
10:23:34 <MP2E> If you're dealing with inputs that are in the IO context, then applicative would work just fine
10:23:35 <pjdelport> So you can think of <$> as just being a helper for <*> that inserts a "pure" on the left side for you.
10:24:03 <MP2E> Also, if you're dealing with pure inputs and simply want an IO return value, you can always do 'pure . function'
10:24:10 <MP2E> which also uses Applicative
10:24:24 <pjdelport> And viewing it this way makes it clearer how you can use "pure" anywhere to lift values into the functor.
10:24:31 <MP2E> I agree :)
10:24:45 <MP2E> it also makes it clear that for any Applicative, you have a Functor
10:24:57 <pjdelport> > pure (+) <*> [10,20] <*> pure 1
10:24:59 <lambdabot>  [11,21]
10:25:01 <RyanGlScott> Speaking of which, what is the current status of the proposed Applicative do-notation?
10:25:13 <orion> :t liftM
10:25:14 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:25:26 <pjdelport> > [(+),(-)] <*> pure 10 <*> pure 1
10:25:26 <orion> :t fmap
10:25:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:25:28 <lambdabot>  [11,9]
10:25:51 <orion> Why do liftM and fmap look so similar?
10:26:17 <vanila> :t liftM
10:26:19 <vanila> :t fmap
10:26:19 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:26:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:26:26 <vanila> it's the same thing
10:26:34 <pjdelport> > pure (+) <*> pure 10 <*> pure 1 :: Maybe Integer
10:26:36 <lambdabot>  Just 11
10:26:39 <pjdelport> > pure (+) <*> pure 10 <*> pure 1 :: [Integer]
10:26:40 <lambdabot>  [11]
10:26:47 <MP2E> orion : liftM *is* fmap, just defined for Monads :)
10:26:52 <MP2E> same with liftA
10:26:54 <orion> interesting
10:26:58 <MP2E> except for Applicatives, of course
10:27:53 <pjdelport> Regarding IO earlier, try this in ghci: (++) <$> getLine <*> getLine
10:28:06 <RyanGlScott> What will the status of liftA and liftM be when GHC 7.10 comes out?
10:28:59 <orion> :t liftIO
10:29:00 <lambdabot> MonadIO m => IO a -> m a
10:29:04 <RyanGlScott> Will they just be redefined to be fmap?
10:29:16 <MP2E> RyanGlScott : yep, according to the wiki page on it
10:29:20 <MP2E> they'll just be set to fmap by default
10:29:31 <benzrf> bye
10:29:34 <pjdelport> orion: Try this, too: let prompt s = putStr s *> readLn in pure (+) <*> prompt "First? " <*> prompt "Second? "
10:30:41 <orion> First? x
10:30:42 <orion> *** Exception: user error (Prelude.readIO: no parse)
10:30:51 <orion> oh, ha
10:31:05 <orion> You want a Num
10:32:32 <orion> In general, is it always best to use Applicatives unless you absolutely need to use a Monad?
10:32:41 <MP2E> I would say yes
10:32:57 <supki> RyanGlScott: they will serve as possible default definitions for fmap in the Functor instance for the type
10:33:13 <MP2E> I try to use Applicative whereever I can and it hasn't burned me yet :)
10:34:14 <orion> > let prompt s = putStr s *> readLn
10:34:15 <lambdabot>  not an expression: ‘let prompt s = putStr s *> readLn’
10:34:22 <orion> > prompt s = putStr s *> readLn
10:34:24 <lambdabot>  <hint>:1:10: parse error on input ‘=’
10:34:28 <orion> bah
10:35:02 <orion> prompt :: Read b => String -> IO b <-- This confuses me a bit... how can you get an IO from nothing?
10:35:26 <joshc> :t readLn
10:35:27 <lambdabot> Read a => IO a
10:35:28 <c_wraith> There are some bits of silliness, like StateT's Applicative instance depending on the underlying type's Monad instance.  You don't really gain anything from restricting StateT use to Applicative, because of that.
10:35:50 <c_wraith> (and that appears to be a fundamental limitation - StateT's Applicative really does require the underlying Monad)
10:35:51 <pjdelport> orion: prompt takes a prompt string, and constructs an IO action that prints the prompt and then reads and yields the read value.
10:35:53 <opqdonut> c_wraith: that sounds interesting
10:35:59 <pjdelport> :t putStrLn
10:36:00 <lambdabot> String -> IO ()
10:36:03 <MP2E> c_wraith : wow o.O Today I learned something :P
10:36:18 <MP2E> I did not know there were cases  where the Applicative *could* depend on the Monad
10:36:29 <pjdelport> orion: Not how putStrLn also takes a string, and uses it to construct an IO action (that will print the string, and yield ())
10:37:08 <c_wraith> MP2E: well, it's possible I missed something - but if so, everyone else has too. :)
10:37:10 <pjdelport> MP2E: That's what WrappedMonad does in general. :)
10:37:40 <joshc> the compiler has inferred which Applicative instance to use (IO) based on the types of putStr and readLn
10:37:57 <pjdelport> orion: Oh, if you wanted the type, earlier, you can tell lambdabot this:
10:37:57 <pjdelport> :t let prompt s = putStr s *> readLn in prompt
10:37:59 <lambdabot> Read b => String -> IO b
10:39:08 <opqdonut> c_wraith: right, in m <*> n the state from running m needs to be extracted and fed to n
10:42:43 <Fuuzetsu> I wish Haddock was faster.
10:43:16 * eikke__ too
10:44:11 <Fuuzetsu> The problem is that huge majority of the time (like 95%+) is spent in GHC API and I sure as hell can't optimise that…
10:45:22 <orion> MP2E: f :: Int -> Int -> Int -- in main I do: x <- f <$> 1 <*> 2 -- why is that wrong?
10:46:46 <MP2E> orion : It needs a Functor instance, so you could do :
10:47:28 <MP2E> f :: Identity Int -> Identity Int -> Identity Int -- in main I do: x <- f <$> Identity 1 <*> Identity 2
10:47:35 <MP2E> Identity is a simple functor that does nothing
10:47:42 <MP2E> It is also an Applicative and a Monad
10:48:43 <quchen> MP2E: Applicative can be written entirely in terms of Monad. `pure = return; (<*>) = ap` can be found in the GHC source quite a few times I imagine.
10:50:00 <TheKing44> Is there any Haskell library that allows your program to detect new items from an RSS feed (in the IO monad?)
10:50:15 <MP2E> Ah right, ap = liftM2 id
10:50:18 <MP2E> @src ap
10:50:19 <lambdabot> ap = liftM2 id
10:50:27 <TheKing44> (or (monadio m)=>m)
10:50:42 <TheKing44> like, for a long running program
10:51:36 <pjdelport> orion: You'd probably want: x <- f <$> pure 1 <*> pure 2
10:51:50 <MP2E> oh right and the return would be Int in that case
10:51:58 <MP2E> err wait no
10:52:37 <MP2E> oh it is do syntax
10:52:39 <pjdelport> orion: <*> itself only applies functorial values.
10:52:42 <MP2E> okay then yes, the return would be Int
10:52:50 <MP2E> I think? brb
10:52:53 <MP2E> I need some coffee :P
10:53:23 <pjdelport> Given f :: Int -> Int -> Int, then the above would bind x to an Int, yes.
10:54:10 <pjdelport> But if you're just using pure like that, there's probably no need for Applicative: to motivate the above, you'd want one of the arguments to be some other functorial value.
10:54:47 <pjdelport> For example f <$> readInt <*> readInt
10:56:08 <pjdelport> orion: In other words, "pure" is there to lift *pure* Haskell values (like f, or 1, or 2) into the functor.
10:56:37 <beaky> what are good examples of well designed haskell projects
10:56:41 <beaky> that i can learn from source
10:56:49 <pavonia> xmonad
10:56:54 <MP2E> beaky: I learned a ton from xmonad
10:57:01 <beaky> what is xmonad
10:57:08 <beaky> is it like the ultimate monad
10:57:16 <pavonia> @google xmonad
10:57:17 <lambdabot> http://xmonad.org/
10:57:17 <lambdabot> Title: xmonad | the tiling window manager that rocks
10:57:18 <MP2E> xmonad is a small window manager for the X Windows System that Linux uses
10:57:23 <MP2E> Windowing System*
10:57:35 <beaky> wow xmonad is awesome
10:57:36 <josephle> the way xmonad does plugins is pretty cool
10:58:03 <MP2E> I like everything about xmonad :) I have been a fan of tiling wms and used them exclusively since 2008
10:58:10 <MP2E> and I can say without a a doubt that xmonad is my favorite now
10:58:14 <MP2E> I used to just use dwm all the time though
10:58:17 <MP2E> so it fits my 'style'
10:58:33 <beaky> i like to use kde
10:59:39 <MP2E> xmonad can work with KDE actually, not sure how but XMonadContrib probably has an option to set
11:01:43 <tejing> am I correct in thinking that 'repeat ()' can be brought to normal form in finite time?
11:03:08 <tejing> ... yes it seems I am. in ghci I do let x = repeat ();head x;:sprint x and the sprint never returns
11:04:03 <MP2E> Indeed, reason being that repeat creates an infinite stream of whatever its argument is
11:04:14 <MP2E> so even if it is trivial trying to evaluate it to normal form will result in bottom
11:04:19 <MP2E> aka never terminate
11:05:22 <beaky> how do you guys deal with types that have lots of fields
11:05:32 <Fuuzetsu> I'm getting illegal instance declarations as seen at http://lpaste.net/108583 with GHC 7.8.3 but not with 7.6.3, is there something obvious I should be changing
11:05:33 <carter> beaky: by crying
11:05:36 <Fuuzetsu> I'll pull up the code, one second
11:05:42 <tejing> well what I was uncertain about is whether after calling head on x, there are any thunks left in memory, the answer appears to be no... there's only a self-referential data structure
11:06:09 <carter> beaky: it depends
11:06:20 <Fuuzetsu> file in question https://github.com/cobit/bittorrent/blob/dev/src/Network/BitTorrent/DHT/Message.hs
11:06:21 <carter> is it a closed universe of fields
11:06:21 <MP2E> tejing: ahh
11:06:22 <carter> or open?
11:06:24 <beaky> is there something like setters and getters for single field acess
11:06:34 <Fuuzetsu> lens
11:06:58 <beaky> whats a lens
11:07:06 <Fuuzetsu> comon…
11:07:15 <MP2E> a lens is a getter and setter over a structure that forms an Isomorphism
11:07:21 <beaky> ah
11:08:14 <Fuuzetsu> what's the pragma for GHC options again?
11:08:21 <Fuuzetsu> {-# GHC_OPTION … #-}?
11:08:28 <bennofs> Fuuzetsu: {-# OPTIONS_GHC -bla #-} iirc
11:08:36 <Fuuzetsu> ok
11:09:42 <Fuuzetsu> apparently {-# OPTIONS_GHC -fdefer-type-errors #-} doesn't defer instance declaration errors
11:10:46 <bennofs> MP2E: a lens isn't really an 'isomorphism'. an isomorphism has two functions f,g such that f . g = id = g . f   you cannot say that for the getter and the setter part of the lens
11:11:28 <edwardk> its an isomorphism to 'what you want and some other stuff you could use to rewrap it'
11:11:40 <MP2E> ^
11:11:43 <MP2E> I just said it terribly
11:21:58 <TheKing44> anyone know a good rss feed scraper?
11:22:17 <HeladoDeBrownie> bennofs, is it okay to write it that way if you're actually talking about two different typings of id?
11:23:14 * haasn .oO( they're = up to isomorphism )
11:23:44 <Fuuzetsu> ≡
11:23:51 <haasn> ≅
11:23:58 <Fuuzetsu> ;^)
11:24:09 <ReinH> HeladoDeBrownie: mathematicians like to be more precise. Haskell has a polymorphic id so we sometimes treat it that way.
11:24:35 <ReinH> also, without specifying the dom and codom of f and g, we can't really specify "where" the id functions live
11:24:46 <ReinH> (also isomorphisms are not just for functions)
11:26:09 <haasn> But if you're arguing with polymorphism, then we need to refine what = means; since f . g = id means id can be instantiated to a function equivalent to f.g - which is a one-sided relation; and furthermore f.g = id and id = g.f clearly does not imply that f.g = g.f in the general case
11:26:18 <haasn> Because neither can be instantiated to another, if f :: A -> B
11:26:30 <orion> If you're writing a monadic function and you require values from non-monadic functions, is it pretty much best to put "let x = f a b c" in your do block?
11:26:30 <kludgy> Any HXT experts in the house? Is it limited to strictly ordered serialization of elements, or is there a way to relax the ordering of subelements?
11:27:19 <l0cust> orion: yes
11:27:19 <TheKing44> hassn unless A=B
11:27:24 <haasn> orion: Keep in mind that, like other “let”-type definitions, this simply makes ‘x’ refer to ‘f a b c’; you could just as well write (f a b c) wherever you wrote (x)
11:27:27 <l0cust> orion: or use where
11:27:35 <orion> ok
11:27:53 <pjdelport> orion: Depends; unless it's very local, you might want to try and lift it out as a separate pure function.
11:28:08 <TheKing44> i prefer let
11:28:33 <pjdelport> orion: Separating your pure and functorial / monadic code is good practice in general.
11:28:57 <pjdelport> It keeps your pure code more reusable, and keeps the essence of your functorial / monadic code in sharper focus.
11:33:29 <orion> Am I correct in saying that the reason you can't have a function with type "(Monad m) => m a -> a" is because the only way to actually get `a' is to execute the program?
11:33:49 <haasn> orion: Not all monads are IO
11:34:04 <l0cust> orion: you can with non-IO monads
11:34:05 <MP2E> orion : Actually, interesting thought there, there is a structure called Comonad that does just that
11:34:10 <HeladoDeBrownie> orion, more like there simply isn't such a function, or any way to define that function, provided for Monads in general
11:34:11 <MP2E> Comonad w => w a -> a
11:34:24 <pjdelport> orion: That has nothing to with IO, and everything to do with the fact that the Monad type class has no function that lets you get an 'a' from 'm a'.
11:34:27 <haasn> orion: But it's correct to argue that this can't exist in general because IO *is* a Monad and IO a -> a is not possible
11:34:37 <haasn> orion: However, there *are* monads for which this is possible
11:34:53 <haasn> @@ orion @type runIdentity
11:34:54 <lambdabot>  orion Identity a -> a
11:34:56 <coppro> Another monad you can't do this for is (-> a)
11:34:56 <orion> Ah, so my logic only applies to IO, not all Monads in general.
11:35:05 <pjdelport> orion: So you can only do it by going outside the Monad type class; for example:
11:35:05 <pjdelport> :t fromJust
11:35:06 <lambdabot> Maybe a -> a
11:35:26 <haasn> note that fromJust is not a very good example
11:35:33 <sipa> orion: get me the Int out of the [Int] value []
11:35:34 <pjdelport> :t fromMaybe
11:35:35 <lambdabot> a -> Maybe a -> a
11:35:36 <bennofs> :t evalWriter
11:35:36 <haasn> I mean, it's not a very good function
11:35:37 <lambdabot>     Not in scope: ‘evalWriter’
11:35:37 <lambdabot>     Perhaps you meant one of these:
11:35:37 <lambdabot>       ‘execWriter’ (imported from Control.Monad.Writer),
11:35:47 <pjdelport> Right, s/fromJust/fromMaybe/ :)
11:35:48 <coppro> Given a (-> a) b, you can't just get a b out (unless the function happens to be constant, but you don't know that)
11:35:49 <bennofs> :t snd . runWriter
11:35:50 <lambdabot> Writer c a -> c
11:35:51 <jfeltz> is there an analogue to "ghc-pkg list" for cabal? I want to avoid having to enter the path to the package db that cabal resolves to, I know I can probably script this, but I'd thought I'd ask first
11:36:01 <sipa> orion: it's just incorrect to say that a monad of type m a "contains" a value of type a
11:36:06 <bennofs> jfeltz: cabal sandbox hc-pkg list
11:36:14 <coppro> what sipa said
11:36:21 <coppro> again, (-> a) is an excellent way to dispel that myth :)
11:36:23 <jfeltz> bennofs: thx
11:36:32 <bennofs> @quote /bin/ls
11:36:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:36:47 <pjdelport> orion: Don't think of functors or monads as a container; think of it as an opaque structure with typed slots that you can operate on.
11:37:01 * haasn misses the part where orion claimed functors or monads are containers
11:37:02 <coppro> The list monad will also throw you for a loop
11:37:35 <orion> So, there is only one function which DOES in fact do "IO () -> ()", and that's buried in the runtime.
11:37:41 <haasn> “opaque structure with typed slots that you can operate on” is meaningless to me
11:37:52 <haasn> orion: Yes and no; it's not a function
11:38:00 <haasn> Not in the Haskell sense - so calling it one, or even giving it a type, is nonsensical
11:38:08 <pjdelport> orion: There's also unsafePerformIO. But it's probably not a good idea to use it. :)
11:38:10 <haasn> orion: What actually happens is that main :: IO a gets executed and its result discarded
11:38:24 <HeladoDeBrownie> orion, you can write IO () -> () yourself. It's called const () :)
11:38:29 <haasn> This is what the RTS is in charge of doing
11:38:40 <haasn> No more, no less - evaluate ‘main’ and execute it
11:39:13 <orion> haasn: Do side effects happen during the course of the evaluation of main?
11:39:20 <orion> I would think not.
11:39:21 <sipa> orion: during evaluation: no
11:39:22 <haasn> orion: No; but during the course of execution
11:39:34 <sipa> main just produces a "program" (of type IO ()) to execute later
11:39:39 <haasn> orion: Note that evaluation is nonstrict; execution and evaluation can be interleaved
11:39:57 <sipa> executing that program will cause more evaluation to be performed, however
11:40:33 <orion> So, it's critical that IO is not strict.
11:40:41 <haasn> orion: So for example in the program print (fib 10) >> print (fib 20) GHC would see the “print (fib 10) >>” first; causing it to evaluate “fib 10” so it can print it out; then it would see the “print (fib 20)” next, causing it to evaluate “fib 20” so it can print that out.
11:40:42 <orion> Otherwise you'd get all sorts of weird effects.
11:40:50 <haasn> orion: No, that's also not true - IO is strict
11:40:59 <haasn> But strictness is a property of evaluation
11:41:00 <carter> io is very very strict
11:41:01 <haasn> Not execution
11:41:10 <carter> its a property of compilation :)
11:41:16 <carter> well
11:41:18 <pjdelport> orion: an IO action is a pure value that represents an effect without actually performing it.
11:41:18 <carter> hrmm
11:41:40 <orion> pjdelport: right ok
11:42:01 <carter> IO a ====   state# RealWorld# -> (# state# RealWorld# , a #)
11:42:07 <haasn> orion: You can think of it like this - let's pretend for a moment that IO is like a list of actions, and the only possible action is printing something. So we have data Action = Put String; data IO = [Action]
11:42:12 <tolt> is there a good way to supress the warning "Warning: the following files would be used as linker inputs"?
11:42:13 <carter> IO a is a thunked fellow
11:42:19 <pseudolio> That is not a good model.
11:42:26 <haasn> orion: putStrLn :: String -> IO -- no type parameter, but that's not relevant to the point
11:42:42 <gp5st> I've slowly been working through some tutorials and some project euler problems, and was wondering if anyone had a good idea of a project I could work at afterwards. I find that working on something is when I really start t get a feel for the language.
11:42:44 <haasn> orion: (>>) :: IO -> IO -> IO; (>>) = (++)
11:42:45 <pjdelport> orion: unsafePerformIO is an example of a function with side effects: when evaluated, it takes an IO action, and actually executes it.
11:43:14 <haasn> orion: Now we could write something like main = putStrLn "Hello" >> putStrLn "World" which would be *evaluated* to main = [Print "Hello", Print "World")
11:43:18 <haasn> err change that ) to ]
11:43:38 <pjdelport> orion: It's not entirely inaccurate to think of a Haskell executable as taking your "main" IO action, and then just doing "unsafePerformIO main".
11:43:49 <haasn> And GHC would see this result and execute it, first by printing "Hello" and then by printing "World" - this is independent of the evaluation of putStrLn "Hello" >> whatever
11:44:02 <haasn> Also, in a lazy fashion; GHC could first evaluate the first element: main = Print "Hello" : ...
11:44:19 <haasn> Execute that immediately, then evaluate the next element: main = Print "Hello" : Print "World" : ...
11:44:33 <haasn> Execute that again, then evaluate the next element: main = Print "Hello" : Print "World" : []
11:44:37 <haasn> And since it reached [], halt the program
11:44:40 <Th3On> haasn: Well I like working on a game, currently I'm experimenting with OpenGL and implementing some effects for fun as I learn Haskell. What do you like to work on?
11:44:56 <pjdelport> orion: The key is that the unsafe side effect of executing main doesn't leak into main itself, so your entire program inside main just works with pure, first-class effects, with no side effects (unless you use unsafePerformIO too).
11:44:56 <Th3On> gp5st: oops, that was for gp5st
11:46:05 <orion> haasn: Interesting description.
11:46:24 <haasn> orion: Of course, in reality; we can also have actions that return pure values from the real world like getLine; say we extend IO slightly to enable something like ‘interact’: data IO = Put String | InteractLine (String -> String)
11:46:27 <Fuuzetsu> I used the curly brace + semi-colon style just now
11:46:31 <Fuuzetsu> it feels… weird
11:46:47 <haasn> We could write a fully pure program like Put "What is your name?" >> InteractLine (\name -> "Hello, " ++ name)
11:47:07 <gp5st> Th3On: I don't know, actually. Mostly data analysis type things.  I could write something for solving routing problems in a public transit network, but I'm afraid that might be too ambitious for a project meant to learn a language?
11:47:08 <haasn> And the GHC RTS, when executing this; would first output "What is your name?" as expected
11:47:16 <orion> pjdelport: I think there's some unfortunate terminology floating around. For example, "runState" is misleading to beginners.
11:47:28 <orion> Nothing is actually being run.
11:47:57 <gp5st> Th3On: there's always the option of building a CRUD webapp:-p
11:48:02 <Th3On> gp5st: Well I would say nothing is too ambitious since you will learn a great deal
11:48:10 <haasn> Then, since the next action is our InteractLine f; it could query for a line of input from the console, evaluate the result of (f thatLine), which is completely pure since the side effect has already happened at this point, and then output the result of that
11:48:32 <Th3On> gp5st: and routing problems seem something that would work in haskell really well
11:48:42 <haasn> For example inputting Orion would result in GHC evaluating (\name -> "Hello, " ++ name) "Orion" = "Hello, Orion" and outputting that
11:48:57 <haasn> Again, "Orion" here is a fully pure string since the side effect has already happened by the time we continue evaluation
11:49:09 <orion> haasn: Haskellers often talk about "data flow". The (>>=) and (>>) operators serve as a way to structure such "data flow". Does that sound right?
11:49:16 <haasn> In fact, the major exception to this kind of system is what's known as lazy IO - where the “pure” value itself is what causes side-effects to happen
11:49:25 <orion> And "return" lift values in to the flow.
11:49:30 <haasn> orion: It certainly sounds right
11:50:55 <orion> I have an urge to make a Monad analogy, but I've read all too much about how that's a bad idea.
11:51:17 <haasn> Yes, best just avoid it
11:51:25 * ab9rf throws a burrito at orion 
11:51:32 * orion eats it
11:51:48 <stolaruk> A monad is capybara with a pelican sitting on its back.
11:52:08 <ab9rf> that is staggeringly unhelpful :)
11:52:14 <haasn> If you're interested in more of what I just presented to you, there are some interesting bits near the middle of http://comonad.com/reader/2011/free-monads-for-less-3/ (if you ignore the scary stuff surrounding it) about how IO could be structured as an alternative to GHC's really ugly internal (but efficient) representation
11:52:40 <orion> haasn: Cool, thanks!
11:52:43 <haasn> In particular, it proposes representing a value of type IO a as something like this
11:52:55 <pjdelport> orion: Have you studied Functor and Applicative yet? :)
11:53:10 <shouya1> hello, i got struggled in a simple case with parsec.
11:53:14 <haasn> data IO a = Pure a | forall i o. Effect (SideEffect i o) i (o -> IO a)
11:53:18 <shouya1> code goes first: http://lpaste.net/108590
11:53:37 <haasn> This means that IO a is either a “pure” value; or a description of a SideEffect with input ‘i’ and output ‘o’ that will produce another IO a action
11:53:46 <orion> pjdelport: Yes, I read Typeclassopedia and am working on this now: http://www.seas.upenn.edu/~cis194/lectures/10-applicative.html
11:54:08 <shouya1> i intended to parse a regular language of lambda calculus.
11:54:11 <haasn> To execute something like this; look up on how to execute the corresponding SideEffect i o with the given ‘i’; get some pure ‘o’ out of that and feed it to back to the program to get another IO - once you've reached Pure, you have a final, pure result and can halt
11:54:24 <paviana> someome to help a newbie trying to dealing with cabal and sublimehaskell?
11:54:29 <haasn> (Or in the case of >> or >>=, resume execution with the next action)
11:55:38 <haasn> I quite like this particular representation of IO because it allows you to clearly mark “side effects” with a special type like SideEffect i o and a primitive, unsafe function unsafePerformSideEffects :: SideEffect i o -> i -> o
11:55:56 * hackagebot saltine 0.0.0.3 - Cryptography that's easy to digest (NaCl/libsodium bindings).  http://hackage.haskell.org/package/saltine-0.0.0.3 (JosephAbrahamson)
11:56:31 <haasn> The GHC internal representation, I think, is much more confusing and only works because GHC allows actual impure functions internally - and instead of “execution flow” being explicit, it's left implicit using the hidden RealWorld parameter
11:56:56 <haasn> I recommend not even looking at it unless you want to hack on GHC or understand unsafePerformIO / unsafeInterleaveIO better
11:59:55 <shouya1> excuse me, anyone can give me a hand :)
12:00:46 <haasn> Is it just me or is lpaste.net down?
12:00:47 <dfeuer_> Here, shouya1.
12:00:55 <dfeuer_> You can have my left hand.
12:01:11 <dfeuer_> What do you need, shouya1?
12:01:12 <shouya1> dfeuer_: thanks XD, http://lpaste.net/108590
12:01:41 <shouya1> dfeuer_: i just want to know what's the wrong with my code :)
12:01:43 <haasn> Hmm, seems it didn't like my VPN
12:01:52 <dfeuer_> Yes, shouya1, as haasn said, lpaste.net is having some problems.
12:02:05 <dfeuer_> Oh, it's working now.
12:02:13 <shouya1> i can access it normally.
12:03:03 <dfeuer_> shouya1, I'm not exactly a parsing expert, but I would suggest you give us your module imports so we know what parsing library you're using.
12:03:14 <haasn> He did mention parsec
12:03:29 <dfeuer_> Oh, that must have been before what I saw.
12:04:06 <shouya1> dfeuer_: paste updated. full file shown now :p
12:04:38 <shouya1> dfeuer_: i'm quite inexperienced to parsec yet.
12:08:02 <haasn> I sort of have the feeling you need some “try” somewhere
12:09:23 <shouya1> haasn: hmm, i didn't even know where i made the mistake.
12:10:01 <haasn> Oh
12:10:12 <haasn> expr expects to end with “eof”; but you have “parens expr”
12:10:19 <haasn> So that's impossible; there should be an EOF before the )
12:10:31 <haasn> because parens expr is just symbol "(" *> expr <* symbol ")"
12:11:29 <haasn> Removing the “<* eof” bit and moving that somewhere else should fix it
12:11:34 <haasn> eg. program = expr <* eof
12:11:39 <shouya1> haasn: got it! thanks!
12:11:46 <shouya1> hmm yep.
12:14:30 <shouya1> cool it works perfectly now after the fix, thanks again :p
12:19:53 <orion> Is the word "mobits" in common usage?
12:20:18 <grayling_> Can someone show me an example of Control.Exception and readFile?
12:20:20 <bennofs> orion: what's that? :d
12:20:30 <dhrosa> it's like when you have bits... but you want more of them
12:21:04 <MP2E> haha
12:21:08 <MP2E> mobits plz
12:21:36 <orion> "(>>=) takes two arguments. The first one is a value of type m a. (Incidentally, such values are sometimes called monadic values, or computations. It has also been proposed to call them mobits."  --http://www.seas.upenn.edu/~cis194/lectures/12-monads.html
12:21:59 <MP2E> oh okay, huh
12:22:07 <orion> BTW, these lectures are really well written, IMO.
12:22:19 <jle`> i have heard them called motes heh
12:22:34 <jle`> but usually i see them called monadic values, or in some contexts, monadic actions
12:22:49 <jle`> both are pretty informal though and have a lot of room for misconception
12:22:56 <bennofs> :t (readFile "/proc/cpuinfo" >>= putStr) `Control.Exception.catch` \(SomeException e) -> print e
12:22:58 <lambdabot> IO ()
12:23:22 <bennofs> grayling_: ^^^ of course, it's not a good idea to unconditionally catch all exceptions
12:23:34 <jle`> m a's are motes, f a's are fots
12:23:36 <jle`> fotes
12:23:52 <jle`> there really isn't a term for `f a`, where f is a Functor
12:23:53 <haasn> This is one of the cases where I can't possibly imagine programming without use of Control.Exception.Lens
12:24:06 <bennofs> :t (readFile "/proc/cpuinfo" >>= putStr) `Control.Exception.catch` \e -> let _ = e :: IOException in print e
12:24:07 <lambdabot> IO ()
12:24:25 <trap_exit> I wanna be the very best, like no one ever was.
12:24:28 <bennofs> haasn: oh, I should use that module more.
12:24:32 <trap_exit> To cath them all is my real test, to train them is my cause.
12:24:45 <trap_exit> I will travel across the land, searching bar and wide. Teach Monads to understand the power that's inside.
12:25:03 <trap_exit> Monad, (gotta learn them all) its you and me I know its my destiny.
12:25:08 <trap_exit> Monad, oh, you're my best friend in a world we must defend.
12:25:14 <trap_exit> We need to write a Monad song. :-)
12:25:31 <haasn> catching_ (_PermissionDenied <> _NoSuchThing) (readFile "foo" >>= doStuff) (putStrLn "Error opening foo!")
12:25:49 <haasn> An example of Control.Exception.Lens usage; here seen catching a “permission denied” or “no such thing” exception
12:25:54 <haasn> (both of which are types of IOException)
12:26:18 <mutable> how does the IOException conceptually works? can I consider IO a as something like Either IOException (NoExceptionIO a)
12:26:20 <bennofs> :t catching
12:26:23 <lambdabot>     Ambiguous occurrence ‘catching’
12:26:23 <lambdabot>     It could refer to either ‘Control.Exception.Lens.catching’,
12:26:23 <lambdabot>                              imported from ‘Control.Exception.Lens’ at /home/lambda/.lambdabot/State/L.hs:40:1-29
12:26:39 <bennofs> :t Control.Exception.Lens.catching
12:26:42 <lambdabot> Control.Monad.Catch.MonadCatch m => Getting (First a) SomeException a -> m r -> (a -> m r) -> m r
12:27:21 <grayling_> bennofs: I agree that lens looks pretty elegant.
12:28:05 <haasn> mutable: I don't think so; the exception system is a bit more advanced in that you can throw exceptions from pure code
12:28:09 <grayling_> I just wonder why I can't find a single good example on readFile with exception handling...
12:28:09 <haasn> :t error
12:28:16 <lambdabot> [Char] -> a
12:28:25 <bennofs> grayling_: what is wrong with
12:28:29 <haasn> This throws an ErrorCall exception; but that's fundamentally not too dissimilar from IOException
12:28:33 <bennofs> :t (readFile "/proc/cpuinfo" >>= putStr) `Control.Exception.catch` \e -> let _ = e :: IOException in print e
12:28:36 <lambdabot> IO ()
12:28:37 <haasn> They're both just “exceptions”
12:28:41 <haasn> which are built into Haskell
12:29:17 <haasn> mutable: In fact, you can throw an IOException from pure code too
12:29:18 <trap_exit> when using Monads, should I use the Lazy or Strict version, and how should I decide?
12:29:19 <haasn> :t throw
12:29:24 <lambdabot> Exception e => e -> a
12:29:25 <haasn> :t throwIO
12:29:28 <trap_exit> I don't get why MTL, for eevery tansformer, seems to ahve both a lazy and a strict version
12:29:28 <haasn> These are nearly the same thing
12:29:30 <lambdabot> Exception e => e -> IO a
12:29:32 <haasn> The only difference is strictness
12:29:49 <trap_exit> no duh, lol
12:29:50 <haasn> The second throws when executing the IO action; the former throws when evaluating the resulting ‘a’
12:29:52 <mutable> hmm, feels like a hole without type safety. And that exception masking thing just make me feel more confused
12:30:42 <haasn> trap_exit: I think you should almost always use the strict version except where you can't; eg. if trying to use an infinite monad action - if that makes sense
12:30:58 <trap_exit> haasn that does not make sense
12:31:02 <trap_exit> which probabaly means I should use the strict version
12:32:15 <haasn> trap_exit: Well, in Haskell we can easily have infinite data structures like cat = "meow" ++ cat -- and we can have “infinite” functions, this is simply recursion, eg. repeat x = x : repeat x
12:32:32 <trap_exit> righ tright
12:32:33 <trap_exit> that I know
12:32:38 <trap_exit> you can define fib recursively like that
12:32:56 <haasn> An infinite monad action would be something similar to this, it makes sense for some monads
12:33:07 <haasn> I'm struggling to find a really good example off the top of my head but reverse state definitely applies
12:33:27 <haasn> So in those kinds of situations, the extra strictness from the strict versions can end up causing an infinite loop
12:33:45 <ab9rf> ah
12:33:52 <ab9rf> i need to rewrite this using conduit, apparently
12:33:59 <haasn> Imagine if [] was strict, the (cat) example couldn't be evaluated
12:34:13 <haasn> It's similar to that
12:34:21 <haasn> I hope that helps you understand why two versions exist
12:34:56 <bennofs> @source >>= State
12:34:56 <lambdabot> Unknown command, try @list
12:35:22 <haasn> trap_exit: Ah, the documentation has a good example - consider an infinite action like “foo = doSomething >> foo”; which makes sense in some monads
12:35:37 <Ankhers> I have a [[Int]]. How would I go about printing each [Int] onto its own line? EG [[1,5,3],[2,7]] -> 1 5 3\n2 7
12:36:01 <ab9rf> assuming i can figure out how to use conduits
12:36:56 <fizbin> Ankhers: forM_ lstOfLstOfInt \x -> putStrLn (intercalate " " x)
12:37:24 <fizbin> Oops, forgot a "$" before the start of the lambda
12:37:49 <int3___> suppose I have a `newtype StateFun a b = StateFun (a -> (StateFun a b, b))` -- is there any way to make it into a monad? it's kind of like Writer, except that 'bind' only works if we have `StateFun a b` and `StateFun b c`
12:37:57 <fizbin> > forM_ [[1,2,3],[4,5,6]] $ \x -> putStrLn (intercalate " " x)
12:38:01 <lambdabot>  mueval-core: Time limit exceeded
12:38:14 <quchen> Ankhers: You have two problems there. A) Output list elements, one per line. B) Convert a list of the form [a,b,c] to "a b c".
12:38:30 <fizbin> > 1+1
12:38:34 <lambdabot>  mueval-core: Time limit exceeded
12:38:47 <fizbin> Okay, lambdabot is hosed, clearly.
12:38:55 <shachaf> int3___: See e.g. http://hackage.haskell.org/package/machines-0.2.5/docs/Data-Machine-Mealy.html
12:39:10 <ab9rf> hah
12:39:16 <int3___> shachaf: thank you!
12:39:55 <fizbin> Anyone have a good expression for "largest power of 2 less than or equal to x"?  (where x :: Int)
12:40:31 <bennofs> trap_exit: try evalState (forever (put 3) >> return 4) 4
12:40:40 <bennofs> trap_exit: with both lazy/strict state
12:41:00 * hackagebot hspec-webdriver 0.3.0 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.3.0 (JohnLenz)
12:41:08 <ab9rf> hm
12:41:28 <int3___> shachaf: lol clearly I was reinventing the wheel there
12:41:28 <ab9rf> fizbin: i have an idea but it's quite ugly.  hang on.
12:44:18 <grayling_> Crap. Irssi sucks if you haven't used it for some time...
12:45:10 <orion> data Blah a = Man a | Bear a | Pig a -- How can I restrict `a' to Num>?
12:45:25 <ab9rf> orion: (Num a) => data ....
12:45:36 <orion> thank you
12:45:46 <pseudolio> That's not going to work. :)
12:45:56 <eikke__> and it's most likely not a great idea
12:45:58 <Ankhers> https://www.google.ca/maps/dir/1255+Bay+St,+Toronto,+ON,+Canada/TD+Echo+Beach,+909+Lake+Shore+Blvd+W,+Toronto,+ON+M6K+3L3/@43.6454644,-79.4047474,14z/data=!4m14!4m13!1m5!1m1!1s0x882b34afa0a56329:0xb2415d56e93c72c8!2m2!1d-79.3898798!2d43.6712101!1m5!1m1!1s0x882b350e113ebfff:0x85aa789c5eaaa873!2m2!1d-79.415201!2d43.629192!3e3
12:46:00 <Ankhers> miss
12:47:02 <trap_exit> why is https://gist.github.com/anonymous/1715b51d8a75ebd4ae6c a compile error?
12:47:10 <trap_exit> from where do I pull in 'get' ?
12:47:48 <jle`> orion: you shouldn't do that
12:47:50 <jle`> :)
12:48:12 <jle`> orion: the preferred choice is to just have the Num constraint on the functions that operate on Blah
12:48:22 <orion> jle`: ok
12:48:23 <mutable> orion: you should only restrict on the function that require a to be a Num
12:48:24 <ab9rf> fizbin: i'm close with take 20 $ (iterate (\x -> x .|. (x `shift` (-1)))) ....
12:48:43 <ab9rf> fizbin: basically repeat the lambda until it converges :)
12:48:46 <ab9rf> fizbin: then add one
12:49:09 <jle`> the reason why is that restricting data types is rarely what you actually want, if you think about what it implies
12:49:12 <fizbin> Actually, since I eventually need one less than the power of two...
12:49:40 <fizbin> Also, I think that Data.Bits.bitSize can be used instead of 20
12:49:59 <ab9rf> fizbin: i know there's some idiom for repeated-application-until-convergence but i'm forgetting what it is.  probably something with fix, which always confounds me
12:50:27 <fizbin> Yeah, that's for something that converges because it's self-referential.
12:51:02 <fizbin> With something like this, that converges because that's what the math does, fix isn't going to work.
12:52:10 <shachaf> "converges because it's self-referential"?
12:53:49 <ab9rf> got it
12:54:00 <fizbin> shachaf: As in this:
12:54:05 <fizbin> take 50 $ fix (\x -> 1: (1 : zipWith (+) x (tail x)))
12:54:06 <ab9rf> (\n -> let f x = x .|. (x `shift` (-1)) in until (\x -> f x == x) f)
12:54:15 <shachaf> I know what fix is.
12:54:20 <ab9rf> > (\n -> let f x = x .|. (x `shift` (-1)) in until (\x -> f x == x) f) 51241241
12:54:23 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:54:23 <lambdabot>    arising from a use of ‘M477140859416915791910258.show_M4771408594169157919...
12:54:23 <lambdabot>  The type variable ‘a0’ is ambiguous
12:54:23 <lambdabot>  Note: there are several potential instances:
12:54:23 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:54:27 <ab9rf> gort
12:54:30 <ab9rf> > (\n -> let f x = x .|. (x `shift` (-1)) in until (\x -> f x == x) f) 51241241 :: Int
12:54:32 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:54:32 <lambdabot>              with actual type ‘a0 -> a0’
12:54:53 <shachaf> You forgot to use n.
12:55:05 <ab9rf> yeah, i suck
12:55:13 <ab9rf> > (\n -> let f x = x .|. (x `shift` (-1)) in until (\x -> f x == x) f n) 51241241 :: Int
12:55:16 <lambdabot>  67108863
12:55:41 <ab9rf> > (\n -> let f x = x .|. (x `shift` (-1)) in until (\x -> f x == x) f n) 65502 :: Int
12:55:43 <lambdabot>  65535
12:55:47 <orion> Pattern bindings (except simple variables) not allowed in instance declarations <-- what is a "simple" variable?
12:55:53 <fizbin> shachaf:  Right, and what I'm saying is that in the expression fix (\x -> 1: (1 : zipWith (+) x (tail x))) what you have is ultimately a self-referential structure.
12:56:18 <ab9rf> fizbin: on some architectures there's a machine instruction to perform that operation
12:56:40 <trap_exit> why can't I do the following: https://gist.github.com/anonymous/1715b51d8a75ebd4ae6c ?
12:57:10 <shachaf> trap_exit: I don't know, what does GHC say?
12:57:28 <trap_exit> ] Compiling Core.Util        ( Core/Util.hs, /home/x/build-tmp/Core/Util.js_o )  Core/Util.hs:24:7:     Could not deduce (Control.Monad.State.Strict.MonadState s m)       arising from a use of `Control.Monad.State.Strict.get'     from the context (Monad m)       bound by the type signature for Core.Util.get :: Monad m => m s       at Core/Util.hs:23:8-23     Possible fix:       add (Control.Monad.State.Strict.MonadState s m) to th
12:57:33 <fizbin> ab9rf: Sure, but if there's no haskell library that does that I'm not going to break out the FFI for this totally non-speed-critical side bit of my code.
12:57:45 <trap_exit> https://gist.github.com/anonymous/2dc54b25f2cc53e8fd12
12:57:45 <shachaf> Give it a type signature or turn off the monomorphism restriction.
12:58:00 <Zekka> trap_exit: {-# LANGUAGE NoMonomorphismRestriction #-} to do the latter if you're in that mood
12:58:03 <ab9rf> heh
12:58:15 <pseudolio> Shifting by 1 each time isn't a great way to do that for a known size integer.
12:58:33 <pseudolio> Especially with until. :)
12:59:28 <ab9rf> fizbin: until ((==) =<< ap (.|.) (`shift` -1)) (ap (.|.) (`shift` -1))
12:59:36 <ab9rf> if you want a really ugly pointfree version L:)
12:59:37 <trap_exit> https://gist.github.com/anonymous/67fcdce22c083fc81e5f <-- I still has errors
12:59:56 <pqmodn_> ab9rf, what does that function do? i can't quite tell by reading it. returns the next highest power of two?
13:00:01 <fizbin> I also have this: let largestP2M1 x = foldr (.|.) 0 $ take (bitSize x) $ iterate (`shiftR` 1) (x `shiftR` 1)
13:00:04 <ab9rf> pqmodn_: one less than, yes
13:00:15 <trap_exit> Ladies and Gentlemen, how do I fix this: https://gist.github.com/anonymous/67fcdce22c083fc81e5f ?
13:00:28 <pavonia> trap_exit: Your type signature seems to be too general
13:00:29 <shachaf> Your type is wrong, and your language pragma is wrong.
13:00:43 <trap_exit> okay
13:00:46 <trap_exit> taht telles me wht is wrong
13:00:47 <trap_exit> how do I fix it?
13:00:51 <shachaf> If you write the pragma the way Zekka said, you don't need the type (but you should probably still write it).
13:01:19 <Zekka> trap_exit: First think about what happens if someone passes an object of a monadic type that doesn't support the state operations
13:01:21 <trap_exit> get :: (Control.Monad.State.Strict.MonadState s m) => m s get = Control.Monad.State.Strict.get
13:01:23 <shachaf> If you write the type correctly (use ghci to find out the type of get), you don't need the pragma.
13:01:26 <trap_exit> appears to have fixed it
13:01:28 <pqmodn_> ab9rf:, ah. you might look Data.Bits.Extras for the native op if you're interested. though i had to make minor changes to get it to work with clang (it only worked with gcc)
13:01:35 <Zekka> trap_exit: That's the correct type
13:01:45 <shachaf> And you don't need to do any of this because you can just have two import statements.
13:01:47 <Zekka> You should alsomake sure you know how to write pragmas thoguh
13:01:52 <bennofs> fizbin: just do this in haskell: http://www.hackersdelight.org/hdcodetxt/nlz.c.txt
13:02:03 <trap_exit> oh
13:02:04 <trap_exit> the "LANGUAGE" part ?
13:02:06 <ab9rf> pqmodn_: fixbin is the one interested
13:02:10 <ab9rf> pqmodn_: er, fizbin
13:02:19 <pqmodn_> oh, whoops :)
13:02:20 <Zekka> trap_exit: Yeah
13:02:23 <fizbin> pqmodn_: Wait, I looked all through Data.Bits
13:02:27 <fizbin> Oh, .Extra
13:02:27 <pqmodn_> fizbin, checkout Data.Bits.Extras
13:02:35 <Zekka> "LANGUAGE" tells GHC that it's a pragma indicating that you want to turn on a language extension
13:02:41 <pqmodn_> here's a repo where i fixed the clang issues, if you're interested https://github.com/kputnam/bits-extras/blob/master/Data/Bits/Extras.hs
13:03:46 <pqmodn_> i think you could implement it in terms of trailingZeros?
13:04:03 <pqmodn_> err, sorry, leadingZeros
13:04:21 <fizbin> pqmodn_: you mean Data.Bits.Extras.log2 ?
13:05:00 <pqmodn_> no, are we looking at the same class? http://hackage.haskell.org/package/bits-extras-0.1.3/docs/Data-Bits-Extras.html
13:05:43 <finlandssvensk> a friend and I are (trying to) make a virtual machine in Haskell
13:05:43 <bennofs> pqmodn_: there is also bits which provides Data.Bits.Extras
13:06:02 * hackagebot aeson-serialize 0.0.0 - Simple serialization functions for aeson types  http://hackage.haskell.org/package/aeson-serialize-0.0.0 (KevinCotrone)
13:06:10 <pqmodn_> bennofs: ah, sorry, i didn't realize that
13:06:31 <finlandssvensk> normally, in something like C or Python, I would update a global machine state
13:06:34 <fizbin> pqmodn_: I was looking at http://hackage.haskell.org/package/bits-0.3.3/docs/Data-Bits-Extras.html
13:06:44 <l0cust> fizbin: what are we talking about?
13:06:50 <l0cust> ack
13:06:52 <fizbin> This is why package names alone aren't enough.
13:07:03 <l0cust> finlandssvensk: what are we talking about?
13:07:32 <finlandssvensk> err
13:08:07 <finlandssvensk> I don't know what they're talking about, but i'm talking about a VM in haskell
13:08:48 <mike4> hi
13:08:54 <fizbin> pqmodn_: I don't see anything in that Data.Bits.Extras that would give me what I wanted (1 less than the largest power of 2 less than or equal to x)
13:09:18 <mike4> can i ask a question does anyone here use haskell at their work? Those who have a work?
13:09:36 <fizbin> mike4: Yes, though rather rarely.
13:10:12 <levi> I can now say yes, but only for drawing diagrams so far. :)
13:10:15 <pseudolio> > let smear n x = x .|. (x `shiftR` n) ; f :: Int -> Int; f = smear 32.smear 16.smear 8.smear 4.smear 2.smear 1; g x = let y = f x in y `xor` (y `shiftR` 1) in g 65535
13:10:17 <lambdabot>  32768
13:10:22 <mike4> on a minimum, minimalistic haskelling?
13:10:53 <fizbin> > let smear n x = x .|. (x `shiftR` n) ; f :: Int -> Int; f = smear 32.smear 16.smear 8.smear 4.smear 2.smear 1; g x = let y = f x in y `xor` (y `shiftR` 1) in g 65537
13:10:55 <lambdabot>  65536
13:11:24 <Ankhers> mike4: yes
13:15:03 <pqmodn_> fizbin, how about something like (\x -> let n = bitSize x - leadingZeros x in n `shiftL` (n-1))
13:15:16 <pqmodn_> :t leadingZeros
13:15:18 <lambdabot> Not in scope: ‘leadingZeros’
13:15:23 <ab9rf> fizbin: hah!
13:16:03 * hackagebot Bang 0.1.1.0 - A Drum Machine DSL for Haskell  http://hackage.haskell.org/package/Bang-0.1.1.0 (5outh)
13:16:05 <fizbin> pqmodn_: Maybe. I like the smear-by-factors-of-2 trick better though, since I know I'm actually dealing with Word16s, so that's pretty straightforward.
13:16:33 <ab9rf> the nice thing about the smear-by-powers of 2 is that it's a fixed set of operations
13:17:46 <ab9rf> fizbin: you could just take the base two logarithm, take the ceiling of that, exponentate, and subtract one.  but that hauls in floating point.
13:18:39 <fizbin> > largestP2M1 x = foldr1 (.|.) $ map (x `shiftR`) [1,2,4,8,16,32] in largestP2M1 65535
13:18:40 <lambdabot>  <hint>:1:15: parse error on input ‘=’
13:18:52 <ab9rf> forgot let
13:18:53 <fizbin> > let largestP2M1 x = foldr1 (.|.) $ map (x `shiftR`) [1,2,4,8,16,32] in largestP2M1 65535
13:18:55 <lambdabot>  32767
13:18:58 <ab9rf> oops!
13:19:57 <pseudolio> You don't want to (x `shiftR`) multiple times.
13:20:06 <pseudolio> It feeds back.
13:20:06 <fizbin> Oh, wait.
13:20:13 <fizbin> Yeah, oops.
13:20:52 <pseudolio> foldl smear x [1,2,4,8,16,32]
13:21:16 <pseudolio> That's backwards.
13:21:45 <pseudolio> foldr smear x [32,16,8,4,2,1]
13:22:07 <pseudolio> I wouldn't recommend that for performance, though.
13:22:27 <ab9rf> back to trying to understand conduits
13:27:21 <orion> In Haskell, if you specify a type signature such as a -> b, does the preclude `a' from being the exact same type as `b'?
13:27:28 <pqmodn_> no
13:27:30 <MP2E> nope
13:27:33 <MP2E> it can still be a -> a
13:27:44 <orion> Couldn't match expected type ‘b’ with actual type ‘a’ <-- then what does this mean?
13:27:54 <orion> ‘a’ is a rigid type variable bound by ...
13:28:01 <MP2E> Well, let me see the function :)
13:28:07 <quchen> orion: More accurately, this type signature reads `forall a b. a -> b`, i.e. something that has this type works for all `a` and `b`. `a = b` is a special case of this.
13:28:23 <orion> http://lpaste.net/4001951261128654848
13:30:20 <quchen> orion: Your (>>=) types don't check out.
13:30:34 <orion> Right, why?
13:31:14 <quchen> You have `Man  x >>= _ = Man  x`. The `Man x` on the LHS has type `Blah a`, with `x` having type `a`. On the RHS, you also have `Man x`, which of course also has type `Blah a`.
13:31:22 <quchen> But >>= expects a `Blah b` on the RHS.
13:31:28 <quchen> (Because of >>='s type.)
13:31:31 <quchen> :t (>>=)
13:31:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:32:06 <HeladoDeBrownie> orion, if in your type a and b are distinct, then the definition cannot rely on a and b being equal.
13:32:22 <HeladoDeBrownie> orion, however, the *user* of your thing can decide for them to be equal.
13:33:01 <quchen> In other words, you're trying to specify a specialized version of (>>=) here, but you cannot do that. You can *use* specialized version of (>>=) elsewhere, but when implementing a typeclass you have to be as general as possible.
13:35:09 <quchen> orion: What you're doing here is similar to writing a function with type signature `id' :: a -> a` and implementation `id True = True; id False = False`.
13:35:36 <quchen> You can use `id` on `Bool` of course, but when the type signature of something claims `a -> a` its implementation has to work for all a.
13:35:44 <quchen> The call site can then pick whatever `a` it wants.
13:37:20 <trap_exit> is there an easy way to go from "https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Strict.html" to the actual source ?
13:37:27 <trap_exit> I'd prefer to read the actual source than human descriptions
13:37:45 <MP2E> trap_exit: click the Source button the right
13:37:48 <eikke__> trap_exit: I see lots of 'Source' links on that page...
13:37:53 <josephle> upper right hand corner
13:38:01 <MP2E> on the right*
13:38:02 <trap_exit> well
13:38:03 <trap_exit> it's in grey
13:38:07 <MP2E> it works
13:38:08 <trap_exit> I auto assumed grey = not working
13:38:10 <trap_exit> but yeah, thanks :-)
13:38:11 * MP2E clicks it
13:38:48 <josephle> does this count as a failure in design? or is the grey meant to dissuade people from reading the source?
13:38:49 <trap_exit> alright alright, it works
13:40:49 <quchen> I wonder whether there's a really small solution to fizbin's problem (of finding the next power of 2 smaller or equal to a number).
13:41:33 <OscarZ> orion: maybe this will help: http://learnyouahaskell.com/a-fistful-of-monads
13:41:42 <quchen> Ever since learning about `x .&. (x-1)` to clear the least significant 1 from a number I wonder whether there is always a small non-obvious solution.
13:42:09 <fizbin> And the kicker? It turns out that my algorithm doesn't actually need that number after all. *sigh*
13:42:31 <fizbin> The lesson here is to implement up to the spot where you actually need what it is you think you'll need.
13:45:21 <orion> quchen: How come this type checks properly though?: Left  l >>= _ = Left l -- for Either
13:45:37 <HeladoDeBrownie> orion, l is neither a nor b
13:45:46 <HeladoDeBrownie> :: a nor :: b, that is
13:45:55 <quchen> orion: The type for "Left l" on the LHS is "Either a b", on the RHS it's "Either a c".
13:46:00 <quchen> The two "Left"s there are distinct.
13:46:11 <HeladoDeBrownie> (>>=) :: Either x a -> (a -> Either x b)
13:46:29 <quchen> You can check this by writing `l@(Left _) >>= _ = l`, which looks identical, but won't typecheck.
13:46:40 <quchen> (Since this would force the two "Left" to have the same type.)
13:46:46 <int3___> jle`: just found your blog. you sound remarkably enthusiastic in your posts :P
13:47:26 <orion> quchen: I don't understand... how does it change from Either a b to Either a c?
13:47:54 <HeladoDeBrownie> orion, the Left on the left side has a different type from the Left on the right side
13:47:55 <quchen> orion: The reason it works this way here is because the type the Monad instance is written for is (Either e), so your (>>=) has type `Either e a -> (a -> Either e b) -> Either e b`.
13:48:09 <fizbin> orion: It doesn't "change". There are two different Lefts.
13:48:22 <orion> I don't understand what makes them different.
13:48:32 <fizbin> @type Left 5 :: (Either Int String)
13:48:33 <lambdabot> Either Int String
13:48:34 <jedai> orion: they don't have the same type
13:48:43 <fizbin> @type Left 4 :: Either Int Char
13:48:45 <lambdabot> Either Int Char
13:49:35 <jedai> @type (Left  1, Left 1) :: (Either Int Bool, Either Int String)
13:49:37 <lambdabot> (Either Int Bool, Either Int String)
13:49:50 <fizbin> orion: I suspect you may be having trouble with the way Haskell imposes types on values. It can be very tricky when coming from other languages.
13:50:11 <jedai> orion: as you see, the two Left 1 are different, they don't have the same type, even though the expression is the same
13:50:15 <mmachenry> I'm having a lot of trouble comprehending all the different String types and how they interact in libraries that are using different kinds. I'm trying to parse JSON data from a network connection and for some reason it parses as a lazy byte string but not strict. But over the wire it works. http://lpaste.net/108596
13:50:34 <quchen> orion: The type of `Left (x::e)` is `Either e a`. Although in this "Left" value there is nothing of type `a` to be found, it appears in its type of `Either e a`.
13:51:56 <antho> I'm trying to get the ordered pair with the smallest y-value and the smallest x-value if more than one pair share the smallest y-value, but I'm having a lot of difficulty. I've tried grabbing the head from a list sorted by the x- and y-values, but I can't get the sorting function right. Does anyone have any suggestions?
13:52:00 <orion> Ok, so how does Haskell automatically decide that the second argument to "Left l" on the LHS is 'a', but the second argument to "Left l" on the RHS is 'c'?
13:52:16 <orion> Why didn't it put them as both 'a'>?
13:52:22 <jedai> antho: sort (comparing snd <> comparing fst)
13:52:53 <ydl> anyone using haskell on windows 8? I've successfully installed ghc and cabal, but do i also need other things to make it work? it seems to be working fine without cygwin, was wondering mainly if i needed that.
13:53:01 <quchen> orion: Because the typechecker specializes type variables so they stay as general as possible. There is no need for "a = b" here.
13:53:14 <jedai> antho: comparing is in Data.Ord and <> is an operator for mappend, it is in Data.Monid in old version of GHC
13:53:26 <antho> jedai: thanks, <> is an operator? I'm very new and haven't seen it before
13:53:41 <jedai> ydl: you should probably be using the platform, except if you have particular needs ?
13:53:41 <quchen> (<>) = mappend (from Monoid)
13:53:42 <orion> quchen: So why can't my "Man x" be of type Blah b instead of Blah a?
13:53:45 <MP2E> ydl: GHC includes a C and C++ compiler so you shouldn't need cygwin or MSYS, unless you're compiling something that requires a C library. But in that case, you'd need MinGW and Cygwin to install the C library and that's about it
13:53:53 <antho> jedai: thanks, you answered my second question before I asked it
13:54:23 <ydl> jedai, the ghc in the platform is too old for me
13:54:32 <ydl> jedai, i forget for what reason, but it exists :)
13:54:46 <jedai> ydl: maybe wait a week, or you could go get the RC since it contains 7.8.3
13:55:46 <ydl> MP2E, really? i just installed Data.Vector, i thought some C compilation went into that, didn't need anything besides the mingw set-up that comes with ghc
13:55:53 <jedai> ydl: http://www.ozonehouse.com/mark/platform/hskellPlatform-2014.2.0.0-x86_64-RC2-setup.exe
13:56:13 <MP2E> ydl : I was unclear, sorry, I meant any C library that isn't already included with the GCC that GHC provides :)
13:56:47 <quchen> orion: Your type is different from Either. What you have is "data Foo a = Foo a" (plus some more constructors). There is only a single type variable, "a". Either on the other hand has two type variables, "Either e a". This means that "Left"s will contain "e"s and "Right"s contain "a". Correct?
13:56:49 <MP2E> and if the haskell project contains C code, that is also fine
13:57:04 <pjdelport> orion: The actual letters of type variables don't really matter; generally speaking, saying "f :: a -> b" and saying "f :: x -> y" means exactly the same thing / type for f. All that matters is where the variables are the *same*, within a type.
13:57:06 <MP2E> it's more just if configure and friends get involved with external C dependancies that you have problems
13:57:45 <jedai> MP2E: just install a linux vm :-) that's way easier
13:57:58 <MP2E> I run Linux natively, I was merely answering a question :P
13:58:03 <MP2E> But yeah I agree
13:58:06 <pjdelport> orion: "g :: a -> a" and "g :: b -> b" are both equivalent declarations, but are different to the above, because the type of g says that the two types must match, whatever they are.
13:58:13 <MP2E> running Windows in a unix like way is pretty weird
13:58:21 <MP2E> But I'm not sure how else GHC would have done it, tbh
13:58:31 <ydl> unfortunately a VM is out of the question since i need my code to be "fast"
13:58:31 <orion> quchen: Yes.
13:58:34 <external-reality> is there anyone familiar with Jeremy Shaw's webroute package? I need help.
13:58:45 <jedai> MP2E: that's more of a C problem from what I understand
13:58:48 <zmbmartin> Is it possible in haskell to have a function that takes one argument but if the argument is not present when called a default value takes the place of that argument?
13:59:02 <pjdelport> orion: So when you say:
13:59:02 <pjdelport> :t Left 'x'
13:59:03 <HeladoDeBrownie> zmbmartin, not really
13:59:04 <lambdabot> Either Char b
13:59:19 <external-reality> Can't figure out why toPathInfo is printing special characters "%34" like that
13:59:22 <orion> :t Right 'x'
13:59:23 <lambdabot> Either a Char
13:59:36 <jedai> ydl: we were just saying that for some rare Haskell libraries that use complex C libraries, getting it to work on Windows is an adventure
13:59:44 <HeladoDeBrownie> zmbmartin, slightly off-topic, but you may be interested to know that the programming language Agda does allow something like that
13:59:51 <MP2E> jedai : Right. Either you try to write code that works with GCC and Visual C++ (not an easy task, trust me) or you just use the Windows version of GCC and the tools it depends on
13:59:56 <HeladoDeBrownie> Which is kind of like Haskell but dependently typed
14:00:03 <MP2E> Visual C++ support in my opinion, would be insane at this point
14:00:04 <pjdelport> orion: that constrains one of the type variables to Char, but the second one stays unbound, and can be any type. GHC just fills in a random letter, effectively, as a placeholder.
14:00:08 <jedai> ydl: and if you're just developping it and not deploying it it was easier to just use a Linux VM (or work on Linux directly)
14:00:22 <OscarZ> if it was Right l on the right side, then it wouldnt work ?
14:00:32 <pjdelport> orion: So the fact that it says "b" in particular does not mean anything; it could have used any other letter or name.
14:00:39 <zmbmartin> HeladoDeBrownie: So I should rethink what I am needing to do then.
14:00:53 <HeladoDeBrownie> zmbmartin, I'd imagine so. If you gave some details maybe we could help.
14:01:12 <jedai> zmbmartin: you often use records for "optional arguments" in Haskell
14:01:17 <pjdelport> :t [Left 'a',Left 'b']
14:01:18 <lambdabot> [Either Char b]
14:01:33 <pjdelport> :t [Left 'a',Left 'b',Right True]
14:01:35 <lambdabot> [Either Char Bool]
14:01:43 <zmbmartin> HeladoDeBrownie: I am writing a web api with scotty and I want to call orderBy on my db so the user can pass orderBy in but if they don't I want to pass a default value.
14:01:48 <zmbmartin> Something along those lines.
14:01:52 <jedai> zmbmartin: so you get "myFunction def {path="..."; style ="..."}
14:02:06 <pjdelport> orion: Note how as soon as i added a Right value, the type variable got instantiated to a concrete type (Bool).
14:02:32 <orion> Why are the "Left l"s of different types on both sides of the = sign though? -- Left  l >>= _ = Left l
14:02:45 <pjdelport> orion: In this case, the list itself constrains all the elements to have the same type, and type inference unifies the types of the individual elements.
14:02:45 <HeladoDeBrownie> zmbmartin, well, one thing that's done is to have two versions of the function, one with the default and the other with an extra parameter. Like sort versus sortBy.
14:02:50 <jedai> zmbmartin: this gives you namesd and optional arguments
14:03:05 <zmbmartin> jedai: Still new to haskell, coming from ruby, js
14:03:06 <pjdelport> orion: Where's that from?
14:03:16 <HeladoDeBrownie> zmbmartin, and the default one can easily be defined in terms of the other, like sort = sortBy (>=)
14:03:20 <jedai> zmbmartin: for your case, I would go with HeladoDeBrownie proposition
14:03:26 <orion> pjdelport: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Either.html#Either
14:03:35 <zmbmartin> HeladoDeBrownie: OK thanks!
14:03:37 <benjwadams> pjdelport: whoa, i never knew that about Either with the same type
14:03:39 <zmbmartin> jedai: Thanks
14:03:43 <zmbmartin> I will try that.
14:04:26 <pjdelport> orion: What do you mean with them being different? They should be the same.
14:05:18 <benjwadams> :k Either
14:05:19 <lambdabot> * -> * -> *
14:05:34 <benjwadams> Wild
14:05:48 <orion> pjdelport: < jedai> orion: as you see, the two Left 1 are different, they don't have the same type, even though the expression is the same
14:06:09 <benjwadams> :t Either Char Char
14:06:11 <lambdabot>     Not in scope: data constructor ‘Either’
14:06:11 <lambdabot>     Perhaps you meant ‘Other’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:06:11 <lambdabot>     Not in scope: data constructor ‘Char’
14:07:11 <pjdelport> jedai: What did you mean by that?
14:07:21 <jedai> pjdelport: they don't have the same type since (>>=) :: m a -> (a -> m b) -> m b
14:07:36 <jedai> pjdelport: and here m is Either e
14:08:03 <benjwadams> :t [Left 'a', Right 'b']
14:08:04 <lambdabot> [Either Char Char]
14:08:10 <jedai> so (>>=) :: Either e a -> (a -> Either e b) -> Either e b
14:08:24 <pjdelport> jedai: Oh, i see what you mean.
14:08:34 <jedai> and thus the first Left l is of type Either e a and the second is of type Either e b
14:08:51 <benjwadams> :t [Left (Right (Just 2)), Right 'b']
14:08:52 <lambdabot> Num a1 => [Either (Either a (Maybe a1)) Char]
14:09:09 <pjdelport> orion: That's a slightly more complicated case than before, because you're working with partially-applied types.
14:09:13 <orion> jedai: So why can't my definition Man  x >>= _ = Man x -- be Blah a and Blah b?
14:09:44 <jedai> orion: probably because x is of type a and your type is defined as data Blah a = Man a
14:10:04 <jedai> orion: in other word if x :: a then Man x :: Blah a
14:10:21 <int3__> jle`: is there some paper / resource on the whole 'locally stateful' idea? I've only seen the phrase on netwire's description and in your blog posts
14:10:39 <jedai> orion: in Either case, there are two type variables Either c d = Left c | Right d
14:11:22 <jedai> orion: and as you see in Left x, only the value of c is fixed, d can be anything absent other constraints
14:11:45 <pqmodn_> int3__: "Lazy Functional State Threads" by J. Launchbury and S P Jones is recommended
14:11:55 <int3__> pqmodn_: thank you!
14:12:29 <orion> So, Left x leaves me with a value whose type is incomplete.
14:12:31 <jedai> so "Left 3" can be Either Int Bool or Either Int String or Either Int a while Right True can be "Either String Bool" or Either Int Bool or Either a Bool
14:12:55 <jedai> orion: right, the type is not completely determined
14:13:28 <jedai> orion: so it can be used in several different context, with different type (though the c in Either c d is fixed by the type of x)
14:13:41 <pjdelport> orion: In one sense, the types of both "Left l" are the same in isolation, because they're both (Either e), with the right type unfixed.
14:13:42 <pjdelport> But in the context of >>=, their full types become linked by the function that gets passed to >>=
14:13:56 <ab9rf> back to trying to understand conduits
14:13:58 <jedai> pjdelport: I disagree
14:13:58 <ab9rf> erafqwrq
14:14:08 <jedai> pjdelport: Either e is not a type
14:14:28 <jedai> pjdelport: it's a type constructor, so no value can have it as its type
14:14:39 <pjdelport> jedai: Right, it's a partially-applied type.
14:14:57 <spott> for debugging purposes, I want to do something like: `traceShow V`, which prints V and returns V... is there a way to do that?
14:15:02 <jedai> pjdelport: it's a partially applied type _constructor_, not type
14:15:14 <spott> there isn't anything like the ',' operator in haskell.... because it makes no sense...
14:15:19 <koala_man> spott: yes, have you looked at Debug.Trace?
14:15:22 <pqmodn_> spott: check out Debug.Trace
14:15:25 <pjdelport> jedai: What I meant is that they're the same in isolation, but become linked by the definition of >>=.
14:15:26 <jedai> pjdelport: types have kind *, Either e has kind * -> * so is a type constructor
14:15:34 <OscarZ> in Either a b, does Monad only care about the first type a ?
14:16:02 <jedai> OscarZ: Monad only "care" about the last type variable, so b in your exemple
14:16:07 <pjdelport> OscarZ: Monad's type variable is the second type, b.
14:16:10 <spott> I did! they all take two arguments, the first that is printed, and then return the next argument... I want it to print the first argument AND return it
14:16:30 <jedai> OscarZ: the monad is (Either e) like, Maybe is a Monad or [], or IO
14:16:31 <latk> Does anyone know of a package that parses a html page, works out the character encoding (from the charset), and then converts the page to utf-8 ?
14:16:34 <pqmodn_> spott: perhaps something like let x = ... in trace x x
14:16:50 <sclv> in general i would love any package that could magically discern char encodings
14:17:07 <spott> pqmodn_: I was hoping to avoid doing that... but It looks like I'll have to.. Thanks
14:17:07 <latk> sclv: Well, you would just be going based on the charset :s
14:17:23 <jedai> OscarZ: all instances of Monad are type constructor of kind (* -> *) that is, they take a type in parameter to give a type
14:17:32 <sclv> latk: so read the first bit in as ascii, then choose how to read the rest?
14:17:35 <sclv> based on that char tag?
14:17:37 <latk> yeah
14:17:43 <sclv> yeah i'd love even that :-)
14:17:54 <latk> Hah, but you don't know of such a thing ?
14:18:01 <sclv> no, just want it :-(
14:18:11 <sclv> it wouldn't be too hard, but it would need a little cleverness
14:18:27 <latk> Yeah, I might have a go, but I have a poor understanding of character encoding.
14:18:29 <nadirs> do mtl and transformers clash against each other?
14:18:31 <sclv> because if you try to read a bytestring in it freaks out if it doesn't work with the encoding
14:18:38 <sclv> so you want to set the handle to be binary mode
14:18:42 <pjdelport> spott: Perhaps traced x = trace (show x) x
14:18:44 <sclv> then interpret the binary as ascii, forgivingly
14:18:54 <sclv> until you know better
14:18:55 <sclv> ick
14:19:14 <sclv> nadirs: as i recall mtl sits on top of transformers?
14:20:00 <nadirs> sclv: oh, you're right → "build-depends: base < 6, transformers == 0.4.*"
14:20:51 <jedai> latk: don't most html parser do that ?
14:22:18 <latk> jedai: For instance? I'm currently using Text.HTML.DOM, and it seems to be failing.
14:22:42 <pjdelport> orion: Here's another way to understand what's happening in the >>= case:
14:22:42 <pjdelport> :t let l = 'c' in ([Left l,Right True], [Left l,Right 'x'])
14:22:43 <lambdabot> ([Either Char Bool], [Either Char Char])
14:22:51 <jedai> latk: that would seem to be egregious failure..
14:23:17 <pjdelport> Compared to:
14:23:17 <pjdelport> let l = 'c' in ([Left l], [Left l])
14:23:25 <pjdelport> > let l = 'c' in ([Left l], [Left l])
14:23:27 <lambdabot>  ([Left 'c'],[Left 'c'])
14:23:33 <pjdelport> :t let l = 'c' in ([Left l], [Left l])
14:23:35 <lambdabot> ([Either Char b], [Either Char b1])
14:23:50 <jle`> int3__: thanks haha.  i'm glad it comes off, because i am pretty enthusiastic about the subjects
14:24:03 <jedai> latk: but looking at tagsoup it seems to have the same problem
14:24:12 <latk> jedai: Ah.
14:24:17 <macron> @pf \x y z -> x . y . z
14:24:18 <lambdabot> Maybe you meant: pl bf
14:24:27 <pjdelport> (Sorry for the spam.) orion: Note how in the second example, the types are only partially constrained, and potentially different.
14:24:46 <macron> @pl \x y z -> x . y . z
14:24:46 <lambdabot> (. (.)) . (.) . (.)
14:25:07 <jle`> int3__: i haven't any resources on the thing unfortunately, but pqmodn_'s link seems interesting, i'll try to get a hold of it.  i'm going to formalize the idea further in my upcoming/in-development locally stateful compositional library though
14:25:10 <pjdelport> orion: In the first example, we add Right values to actually constrain the types to different values for the right side of each Either type, even though the left side is the same (Char on both sides).
14:25:12 <macron> @pf \a b c d e f -> a . b . c . d . e . f
14:25:13 <lambdabot> Maybe you meant: pl bf
14:25:22 <macron> @pl \a b c d e f -> a . b . c . d . e . f
14:25:23 <lambdabot> (. ((. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.))) . (.) . (.) . (.) . (.) . (.)
14:25:25 <jedai> An html parser is supposed to start in ascii then switch to the right encoding as soon as there's an indication (except if you specify another encoding initially)
14:25:29 <nadirs> is "Functional Programming with Overloading and Higher-Order Polymorphism" (http://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf) the recommended way  to learn and understand the State monad?
14:25:34 <OscarZ> jedai: why is it the last type that it picks? is Either monad "implementation" defined so?
14:26:15 <jle`> nadirs: i would recommend just understanding what s -> (a, s) means, and implementing (>>=)/return/get/put yourself
14:26:22 <spott> pjdelport: thanks, that is what I ended up doing
14:26:49 <benzrf> nadirs: do you grok the reader monad at all?
14:26:54 <int3__> jle`: I found the link on google -- that paper is about the ST monad, I think; somewhat different from the automata / FRP stuff
14:26:55 <nadirs> jle`: ok!
14:26:57 <jle`> nadirs: except first without the newtype wrapper; "andThen" (>>) would be (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
14:27:00 <nadirs> benzrf: no :(
14:27:05 <benzrf> nadirs: i'd focus on that first if i were you
14:27:15 <benzrf> its a bit easier, and State is nearly an extension of it
14:27:16 <jle`> int3__: ah i see
14:27:27 <nadirs> benzrf: makes sense
14:27:36 <jedai> OscarZ: no, there are no lambda at type level, so a type constructor order of application is alway the same, thus when you have a type class that takes a type constructor, it always works with the lasts arguments
14:28:09 <jle`> int3__: if anything i am planning on formalizing the concept at some point in the process of releasing my library, because i don't think it has been rigorously formalized or anything yet so i might have the opportunity to go a bit more in depth into it
14:28:10 <jedai> OscarZ: so someone write "instance Monad (Either e) where"
14:28:27 <jedai> OscarZ: since Either e is of kind (* -> *)
14:28:42 <jle`> int3__: i have a couple of sections dedicated to it in the README of https://github.com/mstksg/auto
14:28:58 <benzrf> nadirs: state mobits and reader mobits are both basically functions, State just has a slightly more specific type
14:28:59 <jedai> OscarZ: the Monad class is class Monad m where (>>) :: m a -> m b
14:29:13 <benzrf> jedai: you what
14:29:56 <jedai> OscarZ: now you see that (Either e) play the role of m in this instance so the type of (>>) becomes Either e a -> Either e b
14:30:13 <jedai> benzrf: What ?
14:30:42 <nadirs> benzrf: I understand State (the newtype, that is) is a function, it's just that I have a hard time untangling it :P
14:30:50 <benzrf> nadirs: untangling what?
14:31:04 <nadirs> :t State
14:31:05 <jedai> oops (>>) is of type (m a -> m b -> m b)  but the same argument applies
14:31:06 <lambdabot>     Not in scope: data constructor ‘State’
14:31:06 <lambdabot>     Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
14:31:13 <benzrf> nadirs: again, i'd recommend approaching Reader first
14:31:23 <int3__> jle`: yup that would be cool :) a couple of weeks ago I was asking around for 'simpler' versions of FRP, and was surprised that it wasn't some common pattern already. and thanks, I'll read that README
14:31:48 <nadirs> benzrf: yes, definitely. I was trying to express what I don't understand :)
14:31:53 <jedai> OscarZ: As you see, the last type variable in Either c d is the one that change
14:31:56 <benzrf> nadirs: ok
14:32:03 <benzrf> nadirs: do you understand functions as functors?
14:32:15 <benzrf> i.e. the Functor instance for ((->) r)?
14:32:21 <nadirs> benzrf: I understand (.) but I don't know if that's enough
14:33:05 <benzrf> nadirs: ok, but you understand how fmap works and why it works that way on functions
14:33:37 <jedai> OscarZ: if we had lambda at type level, we could do "instance Monad (\c -> Either c d) where" but we don't so...
14:33:48 <nadirs> benzrf: not sure :/
14:34:07 <jedai> OscarZ: is it a bit more clear for you ?
14:34:13 <nadirs> benzrf: it maps a function over a function's result?
14:34:21 <benzrf> nadirs: yeah
14:34:35 <benzrf> nadirs: the metaphor i like is that a value of type 'r -> a' is a value of type 'a' that depends on a value of type r
14:34:48 <pyon> If anamorphism are a generalization of unfolds, what would be the term for something that is like an unfold, but in addition yields a "leftovers" value?
14:34:52 <benzrf> nadirs: same as how a value of type `Maybe a' is a value of type `a' that might or might not actually exist
14:35:09 <benzrf> nadirs: alternatively, it's a deferred value of a that may emerge at a later date
14:35:15 <nadirs> benzrf: a-ha, nice way of putting it!
14:35:25 <jedai> latk: xmlhtml seems to do the right thing
14:35:41 <pyon> I mean, something of type "(b -> Either (a, b) c) -> b -> ([a], c)".
14:36:14 <jedai> latk: it takes a ByteString as input and returns a Document that contains the encoding and Nodes that contains Text
14:36:17 <benzrf> nadirs: that's why pure/return is const
14:36:38 <benzrf> nadirs: it's a value that depends on another one, but actually it doesnt because you already said what the result should be
14:37:09 <nadirs> mh
14:37:33 <nadirs> maybe this question doesn't make sense but: why isn't pure = id?
14:37:44 <Trollinator> you're right, that question doesn't make sense.
14:37:58 <vanila> :t pure
14:37:59 <lambdabot> Applicative f => a -> f a
14:38:10 <benzrf> nadirs: id 3 has type Int, not f Int
14:38:10 <vanila> pure makes a into f a, so it canot be id which just gaves a back
14:38:31 <nadirs> oh, right
14:38:49 <benzrf> nadirs: so for Reader (which is just a type synonym for (->) in this case), (>>=) has the type:
14:39:03 <benzrf> Reader r a -> (a -> Reader r b) -> Reader r b
14:39:21 <benzrf> it takes a deferred `a' and a function from an `a' to a deferred `b'
14:39:25 <benzrf> then gives a deferred `b'
14:39:39 <OscarZ> jedai: sry got some coffee.. reading now
14:41:41 <nadirs> benzrf: I need some time to understand that
14:41:51 <benzrf> nadirs: have you ever used js?
14:41:57 <nadirs> benzrf: yes
14:42:02 <benzrf> have you used promises
14:42:14 <nadirs> sometimes, yes
14:42:18 <latk> jedai: Oh, awesome! I'll check it out.
14:42:32 <benjwadams> :t (>>)
14:42:32 <benzrf> promises are monadic (at least in Promises/A[+])
14:42:33 <lambdabot> Monad m => m a -> m b -> m b
14:43:06 <benzrf> nadirs: they are more like IO than anything else, but since they act like deferred values, this analogy sort of works with them
14:43:26 <benzrf> nadirs: you could think of a `Reader r a' as a promise resulting in `a'
14:43:29 <benzrf> ...sort of
14:43:30 <benjwadams> :t (<*>)
14:43:31 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:44:03 <benzrf> a promise that resolves when you introduce a value of type `r'
14:44:03 <jedai> latk: it's pretty limited in its support though, sorry
14:44:39 <nadirs> benzrf: yes, but promises are kind of like object with a "then" method that takes a function as an argument, right?
14:44:53 <benzrf> nadirs: then <-> (>>=)
14:45:15 <benzrf> nadirs: maybe i shouldntve brought up promises, they just add more half-right metaphor
14:45:18 <benzrf> s
14:46:26 <nadirs> benzrf: I see promises as the OO version of callbacks
14:46:37 <latk> jedai: If there were some way to read in a file, and then output it with the correct encodings, that would be good enough..
14:47:03 <jedai> latk: you want to convert some html files ?
14:47:21 <OscarZ> jedai: oh right... good explanation. got a bit further now..
14:48:00 <nadirs> benzrf: I need to play a bit with an instance of a Reader. So I can maybe understand how it begins
14:49:28 <latk> jedai: I have a load of (very poorly) encoded html files that I want to parse.
14:49:38 <latk> No requirement of real time or anything.
14:49:48 <jedai> latk: depending on how the encoding is indicated, you may use fast-tagsoup and ensureUtf8Xml
14:50:07 <Pythonfant> there is also html-conduit
14:50:21 <latk> Pythonfant: Using html-conduit now :)
14:50:29 <OscarZ> jedai: if you had some type with 4 parameters like Foo a b c d, then you could define it as a Monad with: instance Monad (Foo a b c) where ? Do you always have to list all the preceding type parameters there?
14:50:33 <jedai> latk: the basic problem is do those html files indicates their encoding ? and if yes, how ?
14:50:59 <latk> jedai: Yes, they do. e.g. "<META HTTP-EQUIV='Content-Type' CONTENT='text/html; CHARSET=ISO-8859-1'>"
14:51:10 <jedai> OscarZ: right, because m will be replaced by Foo a b c in the signature of the functions of the Monad class
14:51:41 <OscarZ> cool
14:52:11 <benzrf> nadirs: ok how about, like
14:52:35 <benzrf> @data Config = Config {username :: String, quiet :: Bool}
14:52:35 <lambdabot> Unknown command, try @list
14:52:38 <benzrf> @let data Config = Config {username :: String, quiet :: Bool}
14:52:41 <lambdabot>  Defined.
14:52:43 <jedai> latk: ok, so they use a Meta tag, if they're consistents, you can do it with any library, you just parse until you got the information, then you restart with the proper encode instruction (and you change the content of CHARSET I suppose)
14:52:50 <benzrf> :t username
14:52:51 <lambdabot> Config -> String
14:52:53 <benzrf> aka
14:52:55 <benzrf> Reader Config String
14:53:02 <mmachenry> Does anything know why my JSON will only parse Lazy byte strings? http://lpaste.net/108596
14:53:08 <benzrf> a value of type String that is deferred until the introduction of a Config value
14:53:35 <latk> jedai: Yeah, this is what I was thinking of doing. However, I couldn't see any option for choosing encoding with Text.HTML.DOM. This is likely me just being thick, thoug.
14:53:40 <nadirs> benzrf: ok, this is understandable
14:53:40 <OscarZ> jedai: not sure what you ment by the kind thing.. what does * -> * match? does it match any type with arbitrary number of type parameters?
14:53:46 <Fuuzetsu> is there a shorthand for foo `seq` retur n()
14:53:52 <Fuuzetsu> ‘foo `seq` return ()’*
14:53:59 <jedai> OscarZ: it doesn't match any type
14:54:15 <benzrf> nadirs: so i can fmap over it:
14:54:20 <benzrf> :t map toUpper
14:54:21 <lambdabot> [Char] -> [Char]
14:54:22 <jedai> latk: use the facilities of the text package (maybe icu)
14:54:39 <jedai> OscarZ: only type _constructor_ with one type argument
14:54:44 <benzrf> > let fmappedReader = fmap (toUpper) username in fmappedReader (Config "benzrf" False)
14:54:45 <latk> jedai: Yeah, you have pointed me at enough stuff that I think I can solve it now :). Thanks!
14:54:46 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
14:54:46 <lambdabot>  Expected type: L.Config -> GHC.Types.Char
14:54:46 <lambdabot>    Actual type: L.Config -> GHC.Base.String
14:54:49 <benzrf> oh wait
14:54:53 <benzrf> > let fmappedReader = fmap (map toUpper) username in fmappedReader (Config "benzrf" False)
14:54:55 <lambdabot>  "BENZRF"
14:55:40 <jedai> OscarZ: you need to be careful to make the difference between types like Int, Bool, Maybe String, Either Int Bool and type _constructors_ which doesn't have _values_
14:55:45 <nadirs> benzrf: good
14:56:24 <joelteon> if its type
14:56:26 <benzrf> :t upper
14:56:27 <jedai> OscarZ: there are no values of "type" Either or Maybe. There are only values of type Int, Bool, Maybe Int, Either String String and so on
14:56:28 <lambdabot> Not in scope: ‘upper’
14:56:28 <joelteon> whoops
14:56:35 <joelteon> premature enter!
14:56:38 <benzrf> :\
14:56:51 <nadirs> benzrf: so the Functor instance for Reader is function composition
14:56:58 <benzrf> nadirs: how about an applicative example?
14:57:02 <benzrf> nadirs: yep
14:57:03 <OscarZ> jedai: right ok..
14:57:04 <nadirs> benzrf: let me try
14:57:11 <Trollinator> perhaps they should do it like in math and use different kinds of letters for different kinds of things
14:57:17 <jedai> OscarZ: so at the "type-level" you have thing that we call types because value can be annotated by them and you have type constructors that don't
14:57:40 <cin> BENZRF
14:57:41 <jedai> OscarZ: to classify them, we have "kinds" which are "types of types"
14:57:41 <Trollinator> latin letters for variables, greek ones for type variables, russian ones for constructors…
14:57:44 <benzrf> cin: sup
14:57:50 <cin> his name was BENZR paulsson
14:57:56 <benzrf> cin: wha
14:58:16 <MP2E> lol
14:58:24 <nadirs> benzrf: pure f <*> g = fmap f g
14:58:24 <Trollinator> it would be awesome
14:58:25 <jedai> OscarZ: * is the kind of all types, * -> * is the kind of type constructor with one type argument; * -> * -> * with two, and so on
14:58:26 <OscarZ> jedai: whats the kind of say Foo a b ?
14:58:31 <nadirs> benzrf: is it correct?
14:58:35 <benzrf> nadirs: yeah
14:58:37 <jedai> OscarZ: * -> * -> *
14:58:44 <OscarZ> right
14:58:45 <Guest31186> Aren't there already enough people saying haskell is for academics without having greek letters?
14:58:46 <benzrf> > let upper = map toUpper; functionOnDeferredValues n q = if q then n else upper n; in (functionOnDeferredValues <$> username <*> quiet) (Config "benzrf" True)
14:58:46 <jedai> OscarZ: if Foo a b c d is a type
14:58:48 <lambdabot>  "benzrf"
14:58:50 <Fuuzetsu> jedai: Well, that depends on kind of ‘a’ and ‘b’…
14:58:52 <benzrf> > let upper = map toUpper; functionOnDeferredValues n q = if q then n else upper n; in (functionOnDeferredValues <$> username <*> quiet) (Config "benzrf" False)
14:58:54 <lambdabot>  "BENZRF"
14:58:58 <Trollinator> nadirs: though in an applicative context you'd often use <$>
14:59:10 <jedai> Fuuzetsu: right but we're trying to simplify here :)
14:59:21 <nadirs> Trollinator: yes, I was just trying to see fmap as decomposed in two more fundamental steps
14:59:22 <benzrf> nadirs: see how each `deferred value' gets the argument piped along to it before any operations are applied?
14:59:45 <Trollinator> Guest31186: perhaps that's the reason it sucks less.
14:59:51 <benzrf> nadirs: hence why it's called `Reader'; it lets functions read from a shared argument
14:59:54 <Guest31186> probably
15:00:05 <jedai> OscarZ: Fuuzetsu is right though, we can write : data Rec f a = One | Rec a (f a)
15:00:32 <Guest31186> lets change all the keywords to latin
15:00:39 <Trollinator> actually, if the sole purpose of using greek letters would be to keep PHP programmers out that would be enough.
15:00:48 <MP2E> haha :P
15:00:53 <jfischoff> Trollinator: tsk tsk
15:00:55 <jedai> OscarZ: and we see that f can't bve a type since we apply it to a, so the kind of f is (* -> *) and the kind of Rec is (* -> *) -> * -> *
15:00:57 <Trollinator> s/would be/were/
15:01:04 <Iceland_jack> This isn't #diss-php
15:01:05 <StoneCypher> <haskellperson> Blah blah PHP
15:01:09 <StoneCypher> Iceland_jack: you must be new here
15:01:18 <Fuuzetsu> Trollinator: ω‌ĥατ?
15:01:19 <Trollinator> :D
15:01:20 <Fuuzetsu> ;^)
15:01:20 <Iceland_jack> StoneCypher: I like to dream
15:01:31 <vanila> PHP is great
15:01:33 <StoneCypher> Iceland_jack: that haskell people will stop whining about successful languages they look down on?  me too.
15:01:43 <Trollinator> ‌ĥ isn't greek
15:02:03 <Fuuzetsu> Trollinator: I couldn't remember which letter looked like h so I went with the first Unicode ‘h’ I could think of
15:02:17 <jedai> OscarZ: anyway the Monad class could be written : class Monad (m :: * -> *) where"
15:02:34 <Trollinator> I don't think there is one in the greek alphabet.
15:02:57 <jedai> OscarZ: to precise that all instances of Monad have to be of the kind * -> * (so a type constructor with one argument)
15:03:17 <Fuuzetsu> Trollinator: Eta
15:03:22 <Fuuzetsu> Η
15:03:25 <StoneCypher> Fuuzetsu, Trollinator: that'd be eta
15:03:28 <Guest31186> αβψδεφηιξλμνοπ;ρστθωςχυζΑΒΨΔΕΦΓΗΙΞΚΛΜΝΟΠ:ΡΣΤΘΩΣΧΥΖ
15:03:51 <StoneCypher> pro tip: it looks like an H because that's where we get H
15:03:57 <Trollinator> eta looks more like n
15:04:03 <StoneCypher> no, it doesn't.
15:04:06 <StoneCypher> nu looks like an n
15:04:09 <StoneCypher> because nu is an n
15:04:16 <OscarZ> jedai: data Rec f a = One | Rec a (f a)   <-- what does it mean to "apply" here? what is f if not type?
15:04:16 <Trollinator> it does: η
15:04:20 * StoneCypher sighs
15:04:25 <StoneCypher> Trollinator: you don't speak greek.  just stop.
15:04:29 <vanila> HΔSΣΞΓΓ
15:04:29 <StoneCypher> Trollinator: capital eta is an h.
15:04:49 <StoneCypher> Trollinator: if you can't tell why that looks like a lower case h, then linguistic drift might not be for you
15:04:58 <vanila> OscarZ, f make a type out of a type
15:05:01 <jedai> OscarZ: for instance you could have values of the type Rec Maybe Int, like One or Rec 3 (Just 5)
15:05:28 <jedai> OscarZ: here f is Maybe, so it is not a type, it is a type constructor
15:05:30 <Trollinator> StoneCypher: not speaking greek doesn't stop me from judging the visual similarity of the glyphs.
15:05:40 <StoneCypher> no, but your lack of judgment might
15:05:48 <Trollinator> prick
15:05:52 <StoneCypher> mmm
15:06:03 <noobatron> Lively in here
15:06:08 <StoneCypher> i'm sure this is hard to figure out: H -> H, η -> h
15:06:13 <OscarZ> jedai: oh right... what you can do on type level always surprises me ;)
15:06:20 <jedai> OscarZ: we can be explicit and annotate all type variables with kind annotations, but GHC infer them for us
15:06:20 <Iceland_jack> Is there a reason this happens on the same day as http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/ ? :)
15:06:53 <vanila> What spawned that article?
15:07:03 <StoneCypher> Iceland_jack: probably because it happens every say
15:07:04 <StoneCypher> day*
15:07:08 <jedai> here data Rec (f :: * -> *) (a :: *) =  One | Rec a (f a)
15:07:26 <Trollinator> nu actually looks more like a v
15:07:42 <StoneCypher> Trollinator: that's nice
15:07:57 <vanila> Trollinator, let's stop about the greek letters, it's upsetting him
15:08:05 <StoneCypher> vanila: i'm not upset.  please don't speak for me.  thanks.
15:08:06 <mopiero> Iceland_jack: yeah, that's why I'm here :P
15:08:09 <HeladoDeBrownie> Stop feeding the StoneCypher troll
15:08:16 <jedai> Well I guess "type variables" is not exactly a good name since they can stand for type constructors, we would be better off calling them type-level variables but it's longer
15:08:20 <OscarZ> jedai: right.. that explains it nicely that kinds are types of types
15:08:22 <Trollinator> yes, I can see that.
15:08:26 * StoneCypher sighs
15:08:31 <vanila> StoneCypher, you are acting very upset
15:08:41 <vanila> I'm just trying to help here
15:08:47 <StoneCypher> vanila: i suggest that you work on your ability to interpret other people, then
15:08:52 <MP2E> :/
15:09:04 <StoneCypher> vanila: it is impolite to speak for people you don't know; it is moreso after they tell you that you're wrong to insist that you're correct
15:09:12 <Trollinator> StoneCypher: you've just proven his point.
15:09:23 <StoneCypher> Trollinator: weren't you mis-reading greek or something
15:09:33 <vanila> Trollinator, please give StoneCypher a break for a bit
15:09:33 <OscarZ> jedai: do you sometimes have to make those explicit kind annotations or does it always infer them ?
15:09:34 <geekosaur> enough already
15:09:44 <StoneCypher> vanila: stop
15:09:55 <StoneCypher> vanila: speak for yourself, not for others.
15:09:58 <geekosaur> that includes you, StoneCypher
15:10:00 <Guest31186> StoneCypher, vanila said you're upset, therefore you're upset. How hard is this to understand?
15:10:03 <jedai> OscarZ: of course here we're not even entering the fact that since a few ghc versions, we can "promote" some values to the type-level and thus have type constructor with strange kinds like "Vector :: Nat -> * -> *" (for vector types that are annotated by their length)
15:10:06 <MP2E> Jesus christ StoneCypher, we get it, you're better than eveyrone
15:10:10 <StoneCypher> Guest31186: huhuhuhu
15:10:19 --- mode: ChanServ set +o geekosaur
15:10:25 <geekosaur> enough already
15:10:33 <jedai> OscarZ: I think until very recently it could always infer them, I'm less sure of it now
15:11:12 * hackagebot hspec-webdriver 0.3.1 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-0.3.1 (JohnLenz)
15:11:42 <jedai> OscarZ: but as long as you remain in the bounds of reason on the type level tricks, you shouldn't need to put kind annotation anywhere
15:11:54 <dfeuer_> Is there a reason the unfoldr1 combinator in http://code.haskell.org/~dons/haskell-1990-2000/msg06775.html isn't in Data.List?
15:12:26 <jedai> OscarZ: though like types signatures, it may be worth it as documentatiuon of some types like Rec
15:18:13 <chrisdone> @botsnack
15:18:14 <lambdabot> :)
15:18:54 <Iceland_jack> @botsnack
15:18:54 <lambdabot> :)
15:19:08 <OscarZ> jedai: what can you do with such promotion? im confused about type constraints, arent they for that ?
15:19:44 --- mode: geekosaur set -o geekosaur
15:20:40 <jedai> OscarZ: that's another subject entirely, basically, the idea is to encode even more constraints to our type system to ensure even more proprieties of our programs and get even more assurance that our programs are corrects
15:21:19 <shachaf> dfeuer_: Is there a reason it's a "combinator" rather than a "function"?
15:21:36 <dfeuer_> Sorry, shachaf, I think that was the term used in that message.
15:21:41 <dfeuer_> I have no idea.
15:21:56 <beaky> whats the difference between a combinator and an ordinary function
15:22:02 <shachaf> This thing is :: (a -> Either b (b,a)) -> a -> [b]?
15:22:08 <jedai> OscarZ: for instance, with vectors that contains their length in their type, we could be sure when our program compile that we never tries to access out-of-bound indices
15:22:28 <jedai> OscarZ: that's pretty big in certain domains
15:22:46 <pjdelport> beaky: http://www.haskell.org/haskellwiki/Combinator
15:22:50 <jedai> OscarZ: and of course that's not the only benefits, though there are still problems
15:22:55 <dfeuer_> Yeah, something like that, shachaf.
15:22:58 <shachaf> (a -> (b, Maybe a)) -> a -> [b] seems more natural to me.
15:23:11 <shachaf> Anyway, why do we want it?
15:23:18 <dfeuer_>  I think it's *possible* to implement it in terms of unfoldr, but it looks funky.
15:23:32 <Guest31186>  Reading that article letter to a young haskell enthusiast, it doesn't really seem to be about haskell
15:23:45 <pjdelport> beaky: In common usage, people usually mean the the latter, informal sense of "combinator", as a function or operator that combines simpler values into more complex values.
15:24:02 <dfeuer_> shachaf, it seems a relatively natural way to write enumFromThenTo, and it fuses with foldr.
15:24:54 <pjdelport> beaky: So Functor/Applicative/Monad are effectively combinator plumbing.
15:24:55 <chrisdone> i typically see a notion of higher order functions for ‘combinator’
15:25:13 <jedai> OscarZ: think for instance of cases where you're getting those vectors after parsing some files, you of course can't be assured about their size during compilation... But maybe you can create a function that parse them and only returns if the resulting array is bigger than ten elements, if not, it returns Nothing, and so on
15:25:24 <chrisdone> but loads of functions in haskell are higher order, it's like walking into a forest and making up a name for trees with more than 5 branches
15:25:32 <pjdelport> Parser combinators are a classical example of this: constructing bigger parsers by combining smaller parsers.
15:25:55 <pjdelport> Right; it's just an informal term.
15:26:09 <shachaf> "combinator" has a lot of possible meanings but usually when people say it they don't mean anything and they'd probably be better served by "function" or "value".
15:26:20 <jedai> OscarZ: well anyway there are tons of research into making these concepts easier to use, writing libraries that make use of it (like linear algebra) and so on
15:26:27 <dfeuer_> OK, shachaf. To be totally generic, it's a VALUE.
15:26:37 <shachaf> dfeuer_: Anyway, that's the sort of function I'd expect to find in semigroups or something.
15:26:44 <shachaf> Since it's an unfold for nonempty lists.
15:26:56 <OscarZ> jedai: oh right..
15:27:18 <dfeuer_> Hmm.
15:27:18 <OscarZ> i understand type constraints cant do that of cos
15:27:22 <jedai> OscarZ: but that's definitely cutting edge right now, and not something to touch casually (except if you're interested intellectually)
15:27:24 <Guest31186> but combinator sounds so much cooler than function...
15:28:23 <dfeuer_> shachaf, it does indeed have something similar, but with the type you gave.
15:28:41 <dfeuer_> [except they're not lists]
15:28:45 <jedai> OscarZ: an example of a simple function that's better with length-encoded vectors is head, you can write : head :: (n > 0) => Vector n a -> a
15:28:45 <shachaf> Oh. Well then.
15:29:28 <jedai> OscarZ: or you could if the syntax was like that, though it's approaching now and better with every GHC version
15:29:29 <dfeuer_> They are, instead NonEmptys
15:29:55 <nadirs> benzrf: ok, it took a while but I managed to write the Applicative instance for Reader: http://lpaste.net/108599
15:31:27 <OscarZ> jedai: cool
15:31:42 <pjdelport> nadirs: Writing that like the following might make it a touch more intuitive: f <*> x -> \x -> (f x) (r x)
15:32:11 <pjdelport> err: f <*> r = \x -> (f x) (r x)
15:32:26 <dfeuer_> shachaf, your/edwardk's type does make more sense. I want to drag the function into Data.List and add the appropriate fusion rules.
15:32:48 <nadirs> pjdelport: right, because f is a deferred "->" while r is a deferred "a"
15:33:07 <shachaf> I think it probably doesn't belong in Data.List but I don't care very much.
15:33:09 <nadirs> pjdelport: is it correct?
15:33:29 <pjdelport> nadirs: In other words, it's taking the application "f <*> r" and transforming it into the application "(f x) $ (r x)", in the context of x.
15:34:39 <jedai> OscarZ: Sure it is :) though it will take some time before it is well integrated into Haskell and start being used as normally as type class actually
15:36:02 <pjdelport> nadirs: Another intuition that might help is to note that in the same way that (say) the list functor lets you operate on the list's elements as "slots", the reader functor lets you operate on a function's return value as a "slot".
15:36:47 <Trollinator> are you guys discussing dependent types?
15:37:13 <chrisdone> trollinator: depends
15:37:16 <jedai> Trollinator: a bit, more like the beginning of the integration in Haskell
15:37:19 <chrisdone> trollinator: who's askin?
15:37:57 <pjdelport> nadirs: So fmap for reader lets you take a function (a -> b) and effectively use it to "replace" the return value of another function.
15:38:53 <pjdelport> nadirs: And <*> for reader takes the return values of two functions, and "applies" them to each other.
15:39:08 <nadirs> pjdelport: click!!
15:39:19 <nadirs> pjdelport: your last sentence did the trick
15:40:05 <schell> i just ran into an error i’ve never seen before while writing an instance of Convertible “Only one type can be given in an instance head.”
15:40:23 <dfeuer_> shachaf, I don't care where it is, as long as I can import it into GHC.Enum.
15:40:27 <nadirs> pjdelport: the next step would be implementing the Monad instance, right?
15:40:33 <pjdelport> So you can think of all functors as abstract structures with some kind of parametric "slot" you can operate on; and in the case of reader, the exact meaning of that slot is the return value of a function from some environment.
15:40:40 <schell> but the instance is Convertible a b, which takes two types, correct?
15:41:07 <HeladoDeBrownie> schell, did the compiler also suggest an extension to enable? But let's see the instance head
15:41:39 <nadirs> pjdelport: but the two args of <*> have to be kinds * -> * -> * and * -> * respectively, right?
15:41:48 <schell> it did, but I’m looking at other instances that don’t use that ext (MultiParamTypeClasses)
15:41:53 <nadirs> pjdelport: you cannot have * -> * -> * -> * and * -> * -> *
15:42:10 <dfeuer_> I am trying to see if adding general-purpose RULES (and as necessary general-purpose functions to go with them)  will allow me to strip all the RULES and manual unboxing out of GHC.Enum without killing performance.
15:42:27 <nadirs> pjdelport: no, wait, cancel that, it doesn't make any sense
15:42:28 <HeladoDeBrownie> schell, it's entirely possible that the extension *is* enabled for those, just not in that particular source file.
15:42:38 <schell> HeladoDeBrownie: http://lpaste.net/108602
15:42:39 <schell> ahhhh
15:42:42 <shachaf> A lot of GHC code does manual unboxing that is unnecessary with the modern optimizations.
15:42:48 <schell> right - with cabal or something?
15:42:54 <HeladoDeBrownie> schell, right.
15:43:01 <dfeuer_> I'd rather have unfoldr1 with a fusion rule than have fusion rules for various enumFrom things.
15:43:01 <shachaf> For example the implementation of length can be made much simpler now that we have CPR analysis.
15:43:04 <HeladoDeBrownie> schell, as far as I know, you will want that, so throw a LANGUAGE pragma in there.
15:43:12 <Trollinator> the “hasochism” paper about dependently-typed programming in haskell is supposed to be very interesting.
15:43:34 <dfeuer_> Sorry, enumFromThenTo.
15:43:47 <dfeuer_> Not to mention that it's pleasant to write things pleasantly.
15:43:48 <schell> HeladoDeBrownie: boom - thanks
15:44:34 <meretrix> Is the haskell-cafe mailing list hosted on both haskell.org and google groups?  I joined the google group and see my message there, but also got a reject message from haskell.org..
15:46:34 <geekosaur> afaik it is only hosted on haskell.org; the google group is not officially related
15:47:38 <pjdelport> nadirs: If you understand a value Reader value m (m r) as a reader function whose return value is itself another reader function from the same environment, it should be more intuitive now how you'd implement join for that, to get a single function that takes the environment and returns r.
15:47:54 <OscarZ> jedai: that cant work compile time, right ?
15:48:33 <geekosaur> so as I understand it the google group is a read only external archive of the official list
15:52:49 <vanila> StoneCypher, sorry for speaking for you - I didn't intend to but that was pretty rude of me. I guess I made the situation worse instead of helping :S
15:52:59 <StoneCypher> vanila: i appreciate your kindness in sayign so
15:53:06 <StoneCypher> vanila: i accept your gesture with thanks
15:53:26 <vanila> alright! and good night #haskell
15:53:35 <Iceland_jack> night vanila
15:53:40 <MP2E> Haha, I was just about to type something alone those lines. :) At any rate.. I posted this earlier today in this channel :
15:53:43 <MP2E> 15:08 < MP2E> Jesus christ StoneCypher, we get it, you're better than eveyrone
15:53:45 <MP2E> I would like to apologize
15:53:48 <MP2E> this is a ridiculous statement
15:54:00 <MP2E> I also should have kept my big nose out of it ;)
15:54:01 <MP2E> hehe
15:54:03 <Guest31186> which part, the better than everyone?
15:54:14 <StoneCypher> MP2E: thank you as well for saying so.  i genuinely appreciate the amends.
15:54:23 <MP2E> Well the tone of the statement, the apparent sarcasm, and the way it singled out StoneCypher
15:54:32 <Guest31186> I know
15:54:34 <StoneCypher> for what it's worth i was kind of being a douchebag
15:55:06 <StoneCypher> i have a poor ability to tolerate what i perceive as fake knowledge, and i should work on that
15:56:12 <Guest31186> Or just go somewhere where theres tons of fake knowledge
15:56:16 * hackagebot webdriver-angular 0.1.5 - Webdriver actions to assist with testing a webpage which uses Angular.Js  http://hackage.haskell.org/package/webdriver-angular-0.1.5 (JohnLenz)
15:56:25 <haasn> This is off-topic in #haskell
15:56:29 <StoneCypher> Guest31186: but i don't like ##javascript :(
15:56:42 <Guest31186> lol
15:57:16 <yogurt_truck> did #haskell and #haskell-blah switch roles today or something? xD
15:58:05 <benzrf> yogurt_truck: yes
15:58:08 <benzrf> didnt you see the news post
15:58:48 <jedai> OscarZ: the head with the type I defined ? sure it can, it's just that when you get the vectors from the outside world, you'll have to sanitize them at this point, but you can be sure that you won't be able to call this head on an empty vector
15:59:00 <Fuuzetsu> proposal: make OverloadedBytestrings an alias for OverloadedStrings
15:59:39 <benzrf> Fuuzetsu: why
15:59:40 <jedai> OscarZ: at compile-time you're sure that no head call will call error (which would be better than the current situation)
16:00:19 <Fuuzetsu> benzrf: ease my development when I have the dumb
16:00:46 <shachaf> No, because you shouldn't use OverloadedStrings with ByteStrings almost ever.
16:00:57 <shachaf> The instance is a bad instance and it'll make you write bad code. ByteStrings aren't strings.
16:00:58 <benzrf> shachaf: b-but they're so convenient
16:01:12 <benzrf> shachaf: let me guess, you dislike php too
16:01:19 <benzrf> you ivory tower intellectual
16:01:22 <MP2E> hahah
16:01:40 <MP2E> ivory tower intellectual, I don't think I've heard that before :P
16:01:55 * yogurt_truck bets shachaf doesn't Get Shit Done ™
16:02:10 <benzrf> have u ever even made a website with more than 10 features
16:02:11 * StoneCypher is surprised to realize yogurt_truck and he share a value
16:02:16 <jedai> OscarZ: if you want to see how this can work in Haskell, read hasochism, if you want to see it in a more sane environment but not in Haskell (and so with the disadvantage of a new language like a slow compiler, few libraries and so on) you can look at Idris which seems really pretty good or Agda which is more Hardcore
16:02:21 <shachaf> Thank you for that contribution, both of you.
16:02:33 <MP2E> heh :V
16:03:00 <HeladoDeBrownie> I feel ashamed having just witnessed that exchange.
16:03:02 <ab9rf> i get so lost when there are three or more monads stacked together
16:03:06 <MP2E> poor shachaf, I hope he didn't take that seriously... #haskell should be renamed to #rage today :(
16:03:18 <OscarZ> jedai: i was actually looking at Agda but with my non-existent math background it was a bit too much.. started reading Types and Programming Languages from the beginning :)
16:03:25 <ab9rf> ok, conduits are awesome
16:03:26 <joelteon> nah, he'll be back after he complains in #haskell-lens for some 30 minutes
16:03:39 <ab9rf> this code that used to need a half gig now runs in 10 megs
16:03:41 <yogurt_truck> ab9rf: :D
16:03:50 <aarvar> If there was a new language which was effectively identical to haskell but renamed everything, would it be more succesful?
16:03:55 <jedai> Haha, right Agda can be pretty rude, TaPL is a really good book :-)
16:04:02 <josephle> OscarZ: Types and Programming Languages will get you the basics, but the road to dependent types goes further :)
16:04:09 <merijn> MP2E: The thing is, he's been here a long time, jokes like that aren't very funny after the 1000th time
16:04:14 <Fuuzetsu> reminder to not put ‘undefined’ in your code and then upload it somewhere and forget about it
16:04:18 <yogurt_truck> ab9rf: the tut on fpcomplete is also lovely
16:05:03 <OscarZ> i have a bad habit of just skimming through elementary stuff and going right into fancy stuff and failing miserably understanding them... have to do some work and exercises :)
16:05:55 <Fuuzetsu> I also have the bad habit of skipping exercises and even if I more or less get the stuff after, I get lost when it comes to doing a something on my own
16:06:09 <ab9rf> yogurt_truck: it helped some
16:06:51 <int3__> what's the syntax for extracting a type literal value? E.g. If I have a `Vector (n :: Nat) a` and I want a 'length' function to return the value n which I can then use at runtime
16:07:08 <josephle> OscarZ: which parts do you find difficult in TaPL?
16:07:16 <OscarZ> so is Haskell going in the direction of Agda ? in Agda i guess you have that sort of thing as the length of vectors as a type level thing.. i got that far
16:08:00 <HeladoDeBrownie> OscarZ, Haskell permits sequence types with length encoded in the type.
16:08:05 <jedai> OscarZ: right, Haskell is trying to get some of the power of dependent typing without paying too much in complexity
16:08:14 <dfeuer_> shachaf, is there any way to write this unfoldr1 as an unfoldr?
16:08:17 <int3__> I'm aware of natVal, but I don't know what the syntax for 'capturing' `n` is
16:08:21 <jedai> OscarZ: but that's not so easy :-(
16:08:22 <HeladoDeBrownie> dfeuer_, shachaf parted.
16:08:29 <dfeuer_> Oops.
16:08:36 <Trollinator> I just wonder if any actual complexity is saved.
16:08:44 <jedai> int3__: natVal (undef :: n)
16:08:57 <jedai> int3__: ?? I suppose with locally scoped type variable"s
16:09:17 <jedai> or maybe a proxy ?
16:09:18 <josephle> although the thing I like most from agda is typed holes, which haskell now has!
16:09:33 <jedai> int3__: from which library are you speaking ?
16:09:35 <Clint>  /win 23
16:09:53 <int3__> jedai: my own code. hmm let me lpaste a snippet
16:09:58 <OscarZ> josephle: i didnt get very far last time i read some of it.. ill get back to you soon ;)
16:10:00 <Trollinator> I also think that we need more than just dependent types.
16:10:11 <aarvar> Haskell needs to just write programs for us
16:10:30 <Trollinator> afaiu, dependent types don't prevent you from e. g. closing the same file handle twice
16:10:43 <josephle> Trollinator: are you asking for typestate?
16:10:53 <aarvar> Idris can do that right?
16:11:00 <OscarZ> how would you describe dependent types ? types that have some constraints from the value "level" ?
16:11:11 <int3__> jedai: http://lpaste.net/108603
16:11:16 <Trollinator> I don't know what typestate is.
16:11:16 <k00mi> int3__: there is no built-in syntax for that, you have to use something like singletons
16:11:22 <jedai> OscarZ: where type can depend on values
16:11:58 <josephle> actually, we can prevent double closes with linear types
16:12:06 <josephle> although I'm not as familiar with linear type systems
16:12:27 <Trollinator> I was thinking of linear types.
16:12:53 <josephle> haskell with linear types would be interesting
16:13:04 <MP2E> Is there a paper/blog post/anything about the interaction of Dependent types and Linear types?
16:13:15 <MP2E> Probably a silly question, but can you combine the two in any meaningful way?
16:13:22 <HeladoDeBrownie> Would that be better than, say, the file handle type including a parameter for Open or Closed and the close operation only operating on Open and producing Closed?
16:13:23 <augur> in short, linear types == vars can only appear once
16:13:24 <k00mi> Trollinator: have a look at idris' effects stuff
16:13:33 <Trollinator> MP2E: ATS does it.
16:13:41 <MP2E> good to know
16:13:58 <OscarZ> jedai: in what ways it can depend on the values? if you have something like natural numbers, can you put constraints on them ? i guess thats not possible
16:15:05 <josephle> OscarZ: another way of looking at dependent types is that they are type families indexed by values
16:15:10 <jedai> OscarZ: well a type like "Vector 15 Int" obviously depends on the value 15
16:15:12 <yogurt_truck> Trollinator: what languages implement them? I've only read the Wadler papers and am very interested about them, but I dn't see a direct connection with the dependent types in Idris, etc.
16:15:13 <Trollinator> but ATS' dependent types seem messy. ATS is divided into a compile-time language called statics and a runtime one called dynamics. And as far as I have seen, you often have to duplicate data structures in the two.
16:15:16 <josephle> although I guess that's a more mathy definition
16:15:23 <HeladoDeBrownie> OscarZ, you could encode a type where values are drawn from some type T but must satisfy some predicate P, for example.
16:15:50 <Trollinator> and that's made even harder by the fact that the statics of ATS is a simply-typed language.
16:15:55 <jedai> in the dependent world, you can write a function where one parameter is an Int and this Int is part of the type of the next argument
16:15:56 <k00mi> int3__: you have to use ScopedTypeVariables
16:16:09 <Trollinator> yogurt_truck: ATS is the only one I'm aware of.
16:16:17 <int3__> k00mi: I already have it turned on
16:16:41 <josephle> Trollinator: rust pointer ownership is a very specific instance of linear types
16:17:12 <k00mi> int3__: change the type of dims' to:  forall w h. ProtoBoard w h a -> (Integer, Integer)
16:17:19 <k00mi> int3__: the forall 'scopes the variables'
16:17:33 <dropdrive> Are there any examples of uses of free arrows?  Someone defined them on SO but seeing how it is used would be useful.
16:18:05 <Trollinator> josephle: they're said to be much less flexible than the ATS ones though.
16:18:26 <k00mi> int3__: and you might want to use Data.Proxy to avoid the usage of undefined
16:19:46 <k00mi> int3__: oh, and if you look at the type of natVal, it takes a 'proxy n'
16:20:12 <jedai> k00mi: though proxy can be anything
16:20:14 <int3__> k00mi: I got this to compile http://lpaste.net/108604
16:20:20 <k00mi> int3__: not just 'n', so you should change the local type sigs to 'proxy w'
16:20:21 <int3__> k00mi: can I remove those undefineds?
16:20:38 <k00mi> int3__: if you write Proxy instead
16:20:38 <jedai> int3__: you can write Proxy instead I guess
16:21:17 <jedai> Proxy is nothing magical here though, I think it would work even if you put Maybe w instead
16:21:41 <jedai> it's more of a convention to avoid confusion over the role of this expression
16:21:48 <k00mi> correct, you just have to pass some value
16:22:15 <int3__> oh okay
16:22:17 <int3__> I see
16:22:25 <int3__> thanks for the help!
16:22:41 <k00mi> glad to help :)
16:24:04 <OscarZ> jedai: can you have just a single value?
16:24:27 <k00mi> int3__: btw, you don't need the forall a. because you don't need that type variable inside the function
16:24:27 <jedai> OscarZ: I don't get your meaning ?
16:25:45 <DanielDiaz> if a program compiles successfully with -O1 but crashes after filling all my RAM with -O2, what can be happening here?
16:25:51 <jedai> Those TypeLits have evolved a lot, it's much clearer what's going on from the documentation than in the past !
16:26:08 <jedai> DanielDiaz: oversharing
16:26:28 <DanielDiaz> jedai: could you elaborate, please? :)
16:26:47 <joehillen> DanielDiaz: sounds like a ghc bug
16:26:49 <int3__> k00mi: here's what happened when I tried to take it out: http://lpaste.net/108605
16:26:50 <jedai> DanielDiaz: GHC got too greedy and tried to lift a common expression and share it between several local functions
16:26:51 <OscarZ> a single value like 15 in Vector 15 Int .. HeladoDeBrownie mentioned having a predicate..
16:27:30 <jedai> DanielDiaz: normally very rare, so it would be interesting to see the program (preferably the part that pose problem...)
16:27:33 <DanielDiaz> jedai: do note that I am referring to the compilation of the program, not its execution
16:27:49 <jedai> DanielDiaz: Ah ok, so not what I said :-)
16:27:59 <ab9rf> moo!
16:28:09 <kazagistar1> so I am poking around in attoparsec and trying to understand the type signature for Parser... it is a newtype wrapper around a type signature that takes 5 inputs to return incremental results, and I am trying to work out what those are... is this about right? "buffer with the input" (not sure how much is kept around) -> "index to start parsing" -> "boolean-like representing if all input is consumed yet or not" (not sure why this exists) -> "c
16:28:11 <kazagistar1> ontinuation representing what to do after the parse if parsing fails"(???) -> "continuation representing what to do after the parse if parsing succeeds"(???) -> Error information | function that allows you to provide more input | result
16:28:21 <k00mi> int3__: huh, seems I misremembered what ScopedTypeVariables does then!
16:28:29 <int3__> haha okay :)
16:29:39 <jedai> int3__: no, the a must remain in ProtoBoard w h a
16:29:41 <kazagistar1> source: https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/Internal/Types.hs#L104
16:29:58 <josephle> OscarZ: what do you mean a single value?
16:30:10 <jedai> int3__: k00mi was only saying you could omit it in the forall since you don't use it in the function
16:30:45 <int3__> jedai: right, I thought as much, but I figured I'd try all conceivable interpretations of his statement :P
16:31:20 <int3__> but yeah I'm familiar with how kind signatures must match up
16:31:22 <jedai> int3__: does it work this way ? (I thought it worked and a was just not in the scope but I may misremember)
16:31:43 <int3__> jedai: I tried both ways in the lpaste
16:31:51 <k00mi> jedai: that's what he did in lines 1-3
16:32:05 <jedai> OscarZ: well yes, Vector 15 Int will be a type
16:32:15 <HeladoDeBrownie> OscarZ, I may have accidentally misled you, I was referring to a fully dependently typed language, not Haskell
16:32:34 <jedai> int3__: oh I didn't see :-/ Sorry, and interesting
16:32:55 <ab9rf> https://gist.github.com/ab9rf/b58dfe2a6cc7c4535d05 <- ugly silly code to do evil things to minecraft savefiles
16:33:03 <jedai> HeladoDeBrownie: Today this works in Haskell though thanks to the type literals
16:33:39 <k00mi> kazagistar1: seems right to me so far
16:33:41 <OscarZ> jedai: im just confused how it can do it compile time... isnt it when the program in ran when it will be realized what length the vector is
16:34:03 <HeladoDeBrownie> jedai, in Haskell you can filter values from a type using an arbitrary predicate?
16:34:16 <HeladoDeBrownie> jedai, in the type system, that is
16:34:17 <k00mi> kazagistar1: this blog posts describes some of the internals: http://www.serpentine.com/blog/2014/05/31/attoparsec/
16:34:47 <jedai> OscarZ: Well, depends on the way the vector is defined. for instance "1 :< 2 :> 3 :> Null :: Vector 3 Int" could be made to work
16:34:49 <OscarZ> HeladoDeBrownie, no worries.. im so confused already that it doesnt matter :)
16:34:57 <jedai> HeladoDeBrownie: not arbitrary
16:35:08 <kazagistar1> k00mi: cool, ill take a look
16:35:26 <jedai> HeladoDeBrownie: but you can write some predicates in the type system, see https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html for some exemples
16:36:19 * hackagebot haddock 2.14.3 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.14.3 (MateuszKowalczyk)
16:37:21 <jedai> OscarZ: if a Vector is defined at compile time, its length can be checked at compile time, if it is constructed at runtime, you can nonetheless give guarantee over his type, for instance by returning a "(n >= 10) => Maybe (Vector n Int)"
16:38:37 <jedai> and then the type system can prove that if you return Just something, the something will indeed be a vector of more than 10 elements. Though it is not always easy to make in sort that the type system manage to prove that
16:39:13 <c_wraith> Yeah, actually satisfying that constraint can be difficult.
16:39:13 <josephle> OscarZ: in general, not all propositions are provable, so not all dependent types are inhabited
16:39:22 <jedai> OscarZ: which is why most serious dependent type system languages come with ways to prove things and automate trivial proofs
16:40:00 <OscarZ> yeah i guess i ment that sort of thing... thats cool if its possible
16:41:51 <gfixler> I'm making my way through the IO chapter of LYAH, starting to grok it
16:42:12 <gfixler> if main has a value of IO Something, does that mean that .hs files are composable?
16:42:37 <ab9rf> gfixler: that's up to your operating system
16:42:55 <gfixler> ab9rf: whoa, I didn't think I was going to end up at that level with this question
16:42:57 <jedai> gfixler: you can call main in main
16:43:06 <jedai> gfixler: so yes
16:43:13 <gfixler> jedai: I think that's all I meant
16:43:14 <ab9rf> main pretty much has to be IO ()... if main returns something other than IO () that return value will be discarded
16:43:23 <gfixler> okay
16:43:25 <hpc> the return value will be printed
16:43:35 <jedai> generally, nothing oppose the notion but convention and naming problems
16:43:46 <gfixler> jedai: those are always problems :(
16:43:55 <ab9rf> hpc: i knew it did that in the ghci repl, it does that in compiled code too?
16:44:06 <jedai> you can perfectly use the main function under ghci and compose it with others
16:44:33 <hpc> oh, guess not
16:44:38 * hpc is misremembering
16:44:52 <gfixler> It feels like main should be just about all there is in a file then
16:44:59 <OscarZ> thanks jedai & posse.. learned a little more of the type system.. i better get back to TaPL :)
16:45:00 <gfixler> aside from some specialized functions for that main
16:45:02 <ab9rf> i thought in compiled code that any value returned by main was discarded by the runtime
16:45:06 <gfixler> everything else should really go out to libraries
16:45:14 <jedai> People that want to make their "main" composable just call it by another name put it in another module they expose in a library and put main = myOtherMain in their executable
16:45:21 <ab9rf> gfixler: that's probably best practice, which i tend to ignore because i'm too lazy to write modules.
16:45:24 <gfixler> jedai: yeah, like that
16:45:47 <gfixler> ab9rf: understood - I like modules, but naming things and putting them somewhere is always a problem
16:46:51 <gfixler> so did we decide that composing things in compiled code does or doesn't print the results of the various mains?
16:47:12 <ab9rf> gfixler: does in ghci, not sure in ghc
16:47:25 <jedai> gfixler: nope, it don't
16:47:32 <gfixler> jedai: yay
16:47:42 <jedai> if your main returns something, it is discarded when you execute the program
16:48:19 <jedai> the IO a is just to avoid people finishing all their program with an useless return ()
16:49:01 <ab9rf> also, because it does not care
16:49:08 <benzrf> hmm
16:49:09 <Iceland_jack> or 'void'
16:49:10 <Iceland_jack> @ty void
16:49:11 <lambdabot> Functor f => f a -> f ()
16:49:13 <ab9rf> so IO a is the most general type that can be accepted
16:49:25 <ab9rf> using IO () would be overly picky
16:50:40 <ab9rf> why didn't someone tell me about conduits before now?
16:51:23 <benzrf> ab9rf: because pipes is also a thing
16:51:32 <benzrf> @src (.)
16:51:33 <lambdabot> (f . g) x = f (g x)
16:51:35 <benzrf> hmm
16:51:37 <benzrf> but what is the fixity?
16:51:57 <ab9rf> not sure lambdabot will tell you fixity
16:52:36 <benzrf> ah, :i has it
17:01:50 <Exio4> what library would you recommend for an irc bot?
17:02:07 <benzrf> Exio4: who knows :[
17:02:50 <hpc> library for what part of it?
17:03:06 <Exio4> the network part, mainly :P
17:03:19 <Exio4> i don't want to mess up with sockets/parsers
17:03:52 <glguy> sockets/parsers is most of the IRC bot, isn't it?
17:04:21 <Exio4> the boring part of an IRC bot
17:04:26 <hpc> http://hackage.haskell.org/package/network-2.5.0.0/docs/Network.html
17:04:28 <hpc> use connectTo
17:04:54 <Rarrikins> It's more of a library thing. An IRC bot should be the event handlers or something like that.
17:04:57 <hpc> you get back a plain jane Handle, with the same operations as file IO
17:05:51 <Exio4> i was thinking about something like "libircclient" in C
17:07:05 <benzrf> how can i get ghci to tell me what the type is for a particular instance of a type family
17:07:15 <benzrf> to be precise, how do i find out what 'IxValue (Tree a)' is
17:07:38 <Exio4> (i need the events and also send "commands" to a running connection)
17:10:16 <Rarrikins> Exio4: I'm not sure which are good, but you can examine the results: https://duckduckgo.com/html?kp=-1&kg=p&q=irc+site%3Ahackage.haskell.org
17:11:12 <glguy> benzrf: Try :kind!
17:11:22 * hackagebot jwt 0.4.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.0 (StefanSaasen)
17:11:31 <glguy> and it won't be happy about that free variable, so you'll have to pick one
17:12:01 <benzrf> glguy: it just says *
17:12:19 <ab9rf> wee
17:12:42 <Rarrikins> Exio4: There's also a tutorial from scratch at http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
17:12:54 <glguy> benzrf, no, :kind!
17:13:16 <glguy> Like this: Prelude Control.Lens Data.Tree> :kind! IxValue (Tree Int)
17:13:27 <benzrf> oh
17:13:30 <benzrf> haha
17:15:59 <ab9rf> the iron law of the internet: the first thing anybody wants to do when they find a new language is write an IRC bot in it
17:16:04 <ab9rf> that or an irc client
17:16:15 <cmccann> glguy: so if you want GHCi to give you more information, you have to yell at it?
17:16:38 <glguy> GHC responds positively to excitement
17:17:27 <kazagistar1> ab9rf: its a great project, since it is simple, but lets you play around with code organization and such
17:17:28 <cmccann> so basically it's like a puppy? ok then.
17:17:42 <StoneCypher> ab9rf: i tried to argue with that.  then i thought about it.
17:17:43 <Exio4> actually, i don't think what i'm trying to do for learning is normal!
17:17:51 <cmccann> I bet it wags its tail when something compiles successfully.
17:18:24 <MP2E> cmccann: the WagTail language pragma is still in development :P
17:18:38 <Exio4> kazagistar,  https://github.com/EXio4/IPoIRC/ :P
17:20:24 <Exio4> oh..
17:20:28 <Exio4> nevermind all i asked
17:21:16 <cmccann> hm. converting one binary format into another by using a script that runs an exporter written in one language, to generate something in another language, which then gets processed by a converter in yet another language to produce the final output.
17:21:22 <cmccann> modern technology is amazing.
17:22:38 <MP2E> Indeed
17:23:39 <MP2E> GHC compiles Haskell to Core, does Core to Core simplification passes, then simplifies the Core, then runs it through STGify to get STG and then the STG gets compiled into C--. From here it can either be translated to ASM, C, or LLVM which is *then* translated into binary, unless you count LLVM
17:23:44 * MP2E 's head spins
17:23:51 <MP2E> err I said core simplification twice
17:23:52 <MP2E> but yeah
17:24:10 <cmccann> that's still all intended as one pipeline though
17:24:15 <MP2E> true :)
17:24:19 <cmccann> not stitching together multiple unrelated things
17:25:07 <cmccann> I'm trying to get from point A to point D by way of existing ways to get from A to B and C to D because going from B to C is easier than A to D directly
17:25:39 <cmccann> since A and D are both essentially unspecified internal binary formats
17:25:47 <benzrf> cmccann: it's like function composition!
17:25:50 <benzrf> but weakly typed D:
17:26:21 <hellen_haskeller> Is that seriously what happens on a compile?  Makes it into C anyway?
17:26:32 <cmccann> I dunno. everything involved fails quickly and horribly if the inputs and outputs don't match up, which is kind of like getting a type error.
17:26:39 <MP2E> hellen_haskeller : It makes it into C--, it can be translated into C, but it usually isn't
17:26:47 <MP2E> it only is if you want to emit it as C in an unregistered build
17:26:52 <MP2E> which is very rarely useful because it is slow
17:26:59 <cmccann> actually sometimes things fail horribly even if the inputs and outputs DO match up so maybe that's not really helpful here.
17:27:11 <rudi_s> Hi. I'm looking for a way to serialize data which supports arbitrary binary data but is still mostly human readable, similar to show's output. For example it should work fine with Strings which ar encoded in arbitrary encodings and not touch them. I tried Data.Aeson but it seems to interprete the Strings. Any idea? Thanks.
17:27:43 <benzrf> rudi_s: msgpack?
17:27:47 <Rarrikins> rudi_s: You might be interested in the JSON library Aeson.
17:27:55 <benzrf> Rarrikins: shoo
17:28:02 <Rarrikins> :(
17:28:04 * Rarrikins shoos.
17:28:16 <rudi_s> Rarrikins: Already tried Aeson ...
17:28:20 <benzrf> < rudi_s> I tried Data.Aeson but it seems to interprete the Strings.
17:28:35 <Rarrikins> Ahh, I missed that part :)
17:29:47 <rudi_s> benzrf: Is that readable? Just glanced over its website and it doesn't look like it.
17:29:55 <cmccann> speaking of aeson, is there any way to make the Generic-based automatic instances handle optional fields? the docs are light on details which makes me think I should probably not be making assumptions about the behavior at all but...
17:30:18 <cmccann> this question may relate to the aforementioned horrible string of format conversions
17:30:21 <rudi_s> At the moment I'm using Binary, but I'd like to give users of my program a way to extract the data without my program.
17:30:23 <benzrf> rudi_s: oh, human readable
17:30:25 <benzrf> :S
17:30:32 <benzrf> rudi_s: well, iirc it's isomorphic to json
17:31:04 <benzrf> just binary, more compact, and saner in some areas (like encodings and ints)
17:31:53 * cmccann is reading data in with Aeson and producing output using both Data.Binary and show! it is a three-in-one spectacular.
17:31:53 <rudi_s> benzrf: Hm, but not really readable/usable with just a text editor.
17:32:05 <tertl3> hi
17:32:32 <rudi_s> The idea is if somebody loses the program he can still use the data (with some preprocessing) without having to parse a binary dump.
17:32:46 <tertl3> is this safe to continue? The following packages are likely to be broken by the reinstalls:
17:32:46 <tertl3> 3.1
17:33:12 <tertl3> im trying to install ELm
17:33:25 <rudi_s> The question is, how slow is show/read with more data? Like > 100K or so.
17:33:49 <rudi_s> Or maybe a few megabytes.
17:33:58 <merijn> hellen_haskeller: C-- is really utterly unlike C
17:34:05 <cmccann> rudi_s: probably depends on the nature of the data
17:34:07 <MP2E> I should have mentioned that
17:34:10 <merijn> hellen_haskeller: It is more comparable to LLVM assembler
17:34:11 <MP2E> C-- is very nice :)
17:34:21 <MP2E> in my opinion, and not to say C isn't
17:34:22 <MP2E> just ... yeah
17:34:25 <MP2E> different things
17:34:40 <tertl3> anyone tried elm?
17:34:54 <tertl3> does it break haskell cabal?
17:35:07 <cmccann> "not to say C isn't nice, just... pointedly not saying it is" :P
17:35:20 <slack1256> it is called C-- in the sense of being a "portable assambler" in the spirit of original C. Not of being similar to it.
17:35:46 <HeladoDeBrownie> tertl3, I'd avoid doing an install that gives that warning
17:35:53 <HeladoDeBrownie> tertl3, instead try installing it in a cabal sandbox
17:36:07 <HeladoDeBrownie> tertl3, are you familiar with those?
17:36:07 <tertl3> HeladoDeBrownie, im afarid its too late
17:36:09 <rudi_s> cmccann: It's mostly a "big" Map with string keys and string values (wrapped in a custom data type).
17:36:14 <tertl3> ive heard of them
17:36:22 <tertl3> is it like a seperate cabal instance?
17:36:33 <HeladoDeBrownie> tertl3, they're good to get used to. They make using cabal manageable. What's the output of `cabal sandbox` on your system?
17:36:42 <HeladoDeBrownie> tertl3, a separate set of packages per directory is what it is.
17:36:48 <HeladoDeBrownie> tertl3, well, sort of
17:36:51 <tertl3> ok
17:37:06 <tertl3> so how would i do it
17:37:08 <HeladoDeBrownie> You can do `cabal sandbox init` in a directory to setup a sandbox there
17:37:18 <tertl3> cabal sandbox install elm
17:37:45 <HeladoDeBrownie> No, you just install as normal but where the PWD is a directory containing a sandbox setup as I've just mentioned
17:37:52 <cmccann> rudi_s: ah, dunno about that. you'd have to test it, doesn't sound obviously good/bad to me.
17:38:28 <tertl3> so you think all the pros are using these "sandboxes"?
17:38:43 <benzrf> tertl3: REAL pros manually move files around
17:38:54 <tertl3> oh gawd
17:38:54 <benzrf> because people who call themselves 'REAL pros' have no common sense
17:39:01 <tertl3> lol
17:39:19 <HeladoDeBrownie> tertl3, I wouldn't worry about that, just decide whether it's easier than the alternative for *you* once you've tried it
17:39:20 <tertl3> there was some tutorial that used i forget which one
17:39:28 <tertl3> i guess its time to learn aboutit
17:39:42 <tertl3> it makes me sad that Elm breaks cabal though
17:39:52 <HeladoDeBrownie> tertl3, could you check if you have the sandbox feature? I'll help you set it up if not. Just tell me the output of `cabal sandbox`.
17:40:18 <tertl3> unrecognised command
17:40:28 <tertl3> im on windows 8
17:40:29 <HeladoDeBrownie> tertl3, okay, you don't. You'll want to `cabal install cabal-install`
17:40:38 <tertl3> ive done that
17:40:39 <HeladoDeBrownie> And then make sure that $HOME/.cabal/bin is in your $PATH
17:41:04 <rudi_s> cmccann: Thanks. Will test it.
17:41:13 <tertl3> let me check the PATH'
17:42:10 <k00mi> hey rudi_s :-)
17:42:34 <rudi_s> k00mi: Hi ;-)
17:42:50 <HeladoDeBrownie> tertl3, do you know how $PATH works in general?
17:42:57 <k00mi> Read is quite bad for complex parsers, but it might be ok if you have only one big datatype, depends on Map's read
17:43:09 <tertl3> yes but Im looking for the axact line to add
17:43:14 <tertl3> HeladoDeBrownie,
17:43:15 <k00mi> rudi_s: http://code.haskell.org/~duncan/binary-experiment/binary.pdf
17:43:25 <k00mi> is that roughly what you're looking for?
17:43:55 <trap_exit> intuitively, what should (StateT s IO) monad be?
17:44:05 <k00mi> standardized, efficient binary format
17:44:16 <k00mi> but I'm not sure if it's implemented yet
17:44:21 <HeladoDeBrownie> trap_exit, I don't understand the question. Any context?
17:45:04 <trap_exit> not really
17:45:08 <trap_exit> I understand the IO monad
17:45:10 <trap_exit> and the State monad
17:45:21 <trap_exit> I still don't have an intuitive grasp of what StaetT s IO does
17:45:24 <HeladoDeBrownie> Well StateT s IO a is just s -> IO (a, s)
17:45:32 <benzrf> trap_exit: newtype StateT s m a = s -> m (a, s)
17:45:36 <HeladoDeBrownie> In a newtype wrapper and with convenient ways to compose it
17:45:52 <cmccann> trap_exit: they don't really interact in a meaningful way. it's just IO with an extra bit of pure state passed around.
17:46:45 <trap_exit> benzrf: that's alL i needed to know
17:46:54 <trap_exit> benzrf: stupidly, after seeing the type, it all makes sense now :-)
17:46:59 <trap_exit> haskell's weired lie that
17:47:00 <cmccann> it's also a slightly suspect idea, I'm not sure why you'd want StateT on top of just IO instead of using IORefs or the like
17:47:09 * linda__ please visit new web: http://www.ChatSocial.org para conocer chicos y chicas de Bolivia!!! porfissss entrale shi? dale 2 clicks aqui http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org http://www.ChatSocial.org
17:47:18 <HeladoDeBrownie> cmccann, you don't always need a mutable container when dealing with IO
17:47:31 <trap_exit> isn't StateT .. IO more "local" than "IOREF" ?
17:47:34 <benzrf> trap_exit: you are not the erlanger u used to be. u must choose a new nick, symbolic of your new self
17:47:57 <HeladoDeBrownie> cmccann, in particular I found it useful to include StateT in a stack when only part of my composition pipeline made use of the state. The rest could simply be lifted.
17:48:15 <HeladoDeBrownie> trap_exit, you could say that
17:48:27 <cmccann> trap_exit: not really. an IORef is local to wherever the ref itself gets passed. StateT is available anywhere in that monad without passing in a reference.
17:48:29 <tertl3> HeladoDeBrownie, i think there is an issue with sandboxes in windows
17:48:35 <trap_exit> benzrf: do I need to burn my copies of LYSE / Programming Erlang / wooden effigy of Erlang great's ?
17:48:43 <tertl3> i dont want to install Linux again :(
17:48:51 <benzrf> tertl3: then install gnu/linux ;) ;) ;)
17:48:53 <cmccann> HeladoDeBrownie: that's why I said StateT on just IO. when there's a larger stack involved it can make sense.
17:49:02 <tertl3> ok RMS
17:49:05 <benzrf> trap_exit: no, just allow them to burt into flames when they realize their own inadequacy
17:49:06 <HeladoDeBrownie> tertl3, sorry, I assumed you were using Linux. I've never tried using cabal-install on Windows. Perhaps someone else can help.
17:49:17 <HeladoDeBrownie> tertl3, but I would try making sure where the cabal directory is
17:49:26 <benzrf> *burst
17:49:35 <tertl3> cabal install works but i think the issue is with the sandbox screwing up some cache or something
17:49:57 <rudi_s> k00mi: Sounds interesting. But in my current use case I'd prefer real ASCII data.
17:50:16 <HeladoDeBrownie> tertl3, do `cabal -V` and show first line here
17:50:41 <cmccann> my favorite trick for getting haskell stuff working when I'm using windows is to use linux instead.
17:50:51 <tertl3> 1.16
17:51:02 <HeladoDeBrownie> tertl3, that's not most recent, it might not be in your PATH correctly
17:51:05 <tertl3> HeladoDeBrownie, i installed the new HAskell platform today
17:51:28 <HeladoDeBrownie> tertl3, that's what I suspected when I suggested making sure where the directory is, it seems likely it's not precisely where I said on Windows
17:51:52 <tertl3> HeladoDeBrownie, i already considered that
17:52:34 <tertl3> C:\Users\William\AppData\Roaming\cabal\bin
17:54:39 <tertl3> i think the problem is that no one who uses haskelll uses winddows
17:54:50 <tertl3> at least not enough
17:54:53 <HeladoDeBrownie> That seems not *too* far from the truth
17:55:17 <HeladoDeBrownie> But I'd be surprised if no one had been able to setup cabal with sandboxes on Windows
17:55:32 <tertl3> i wish my cpu could handle a VM better
17:55:46 <tertl3> maybe ifd i just use console and vim
17:55:55 <davean> tertl3: what CPU/
17:56:05 <tertl3> and old core 2 quad
17:56:19 <tertl3> overclocked ofc
17:56:55 <tertl3> maybe I should rekindle my relationship with fedora
17:57:07 <davean> It should handle VMs decently. It even shouldn't need to use paravirtualization for it
17:57:09 <tertl3> or go with the free spirit of arch?
17:57:27 <davean> It has VT-x
17:57:33 <tertl3> well its a bit slow is all
17:57:36 <tertl3> it does?
17:57:44 <tertl3> well hot damn
17:58:10 <trap_exit> dumbass question ... where in https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Strict.html is StateT actually defined ?
17:58:13 <davean> If it didn't, you culd have just used Xen and paravirtualization
17:58:41 <davean> trap_exit: Control.Monad.Trans.State.Strict
17:59:26 <trap_exit> davean: that does not seem there https://hackage.haskell.org/package/mtl-2.2.1/docs/src/ ...
17:59:31 <trap_exit> is there a way I can look this up in ghci  ?
18:00:03 <HeladoDeBrownie> trap_exit, it's probably in the transformers package
18:00:22 <HeladoDeBrownie> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-State-Strict.html
18:01:00 <HeladoDeBrownie> mtl and transformers are intercompatible for the most part afaik
18:02:46 <k00mi> mtl sits on top of transformers
18:03:20 <trap_exit> is "a -> m (a, s)" less powerful than "m(a -> (a, s)) " ?
18:03:42 <orion> If "data X = Bird | Plane" is a sum type and "data Y = A Int Char String" is a product type, what is "data Z = A Int Char String | Bird | Plane" called?
18:04:21 <StoneCypher> orion: superman
18:05:05 <benmachine> orion: well, all three are algebraic data types
18:05:23 <benmachine> the third is a sum type, it is not a product type
18:06:07 <rudi_s> cmccann: Hm, just tried it and it already gets a little slow with only ~320K of data.
18:06:30 <rudi_s> I guess I'll have to use Binary until I have a better idea.
18:07:06 <cmccann> yeah, read/show are not exactly built for performance
18:08:55 <jle`> trap_exit: a -> m (a, s) is more "powerful"
18:09:14 <jle`> ...i think
18:09:17 <trap_exit> jle`: what does 'powerful' even m,ean?
18:09:23 <heatsink> It can use 'a' to decide what monadic action to execute
18:09:34 <jle`> i take it to mean that it can do averything the other one can do and more
18:09:38 <k00mi> no, you can turn "m (a -> (a, s))" into "a -> m (a, s)"
18:09:49 <trap_exit> oh right
18:09:50 <k00mi> but not the other way
18:09:51 <trap_exit> I see it now
18:09:53 <trap_exit> thanks :-)
18:10:40 <benmachine> e.g. [a -> (a,s)] has some fixed length, but a -> [(a,s)] can decide what length to be depending on what the argument is
18:21:47 <Luke> is there a way to add a type variable constraight to an Applicative instace?
18:22:02 <copumpkin> no
18:22:15 <mwhit> if it needs a constraint, it's not a valid Applicative
18:23:45 <Luke> yeah the type system told me that much. why is that though?
18:24:13 <mwhit> because a functor, by definition, has to be able to contain any type
18:24:21 <mwhit> if it can't, it's not a functor
18:24:24 <Luke> instance Arrow a => Applicative (ArrowMonad a) where
18:24:25 <mwhit> and so not an applicative
18:24:32 <Luke> looks like ArrowMonad does it?
18:26:04 <mwhit> ArrowMonad a is the functor there
18:26:06 <mwhit> not ArrowMonad
18:26:12 <Luke> gotcha
18:27:17 <Luke> I basically want to make an Applicative of Num and Ord only but I'm not sure that's a thing
18:27:31 <Luke> by "thing" i mean a sutable type class
18:28:05 <orion> Is there a drawback to using GADTs everywhere you can?
18:28:05 <mwhit> an applicative over what functor?
18:28:32 <copumpkin> orion: you mean the syntax?
18:29:03 <orion> copumpkin: Yes. Why not specify them for all my datatypes?
18:29:10 <copumpkin> no downside
18:29:13 <Luke> mwhit: well same idea then: a functor that can only hold a num, ord
18:29:20 <copumpkin> orion: some people like less noise for simple types, I don' really care
18:29:21 <mwhit> Luke: that's not a functor, then
18:29:40 <ab9rf> orion: it can make for namespace clutter
18:29:42 <k00mi> no record syntax
18:29:49 <mwhit> k00mi: i was just about to say that
18:29:50 <mwhit> but
18:29:52 <mwhit> you can apparently
18:30:01 <Luke> mwhit: but is there anything like that?
18:30:03 <copumpkin> yeah, there is
18:30:39 <mwhit> @hoogle MonoFunctor
18:30:41 <lambdabot> No results found
18:30:43 <mwhit> hmm
18:30:45 <mwhit> https://hackage.haskell.org/package/mono-traversable-0.1.0.0/docs/Data-MonoTraversable.html
18:30:53 <mwhit> Luke: ^^^
18:30:53 <k00mi> oh, I didn't know about that
18:30:59 <Luke> mwhit: ty
18:31:48 <mwhit> Luke: You need to know some moderately fancy type system stuff (type families)
18:31:51 <BSODInTheSky> Let's have some sh*t all over the house
18:31:54 <mwhit> but they're worth learning if you dont' know them
18:32:03 <BSODInTheSky> Hahahahaahaahahaahahhahauahahhh
18:32:14 <k00mi> orion: let's turn that question around: what advantage justifies using a non-standard syntax when it results in the same semantics?
18:33:15 <BSODInTheSky> /ping ChanServ
18:33:35 <copumpkin> k00mi: consistency with other declaration forms
18:33:43 <BSODInTheSky> /ping ChanServ
18:33:45 <BSODInTheSky> /ping ChanServ
18:33:46 <Luke> mwhit: thanks this is really helpful. exactly what I was looking for
18:33:50 <MP2E> lolol
18:37:01 <k00mi> copumpkin: I can accept that if a significant part of your types are GADTs
18:37:18 <copumpkin> you don't need to accept it :)
18:37:31 <copumpkin> my point is that there's nothing wrong with it
18:37:39 <copumpkin> there's even a separate extension less powerful than GADT
18:37:48 <copumpkin> for only enabling the GADT-style syntax
18:38:11 <shachaf> I,I {-# LANGUAGE GADTSemantics #-}
18:38:32 <copumpkin> I still personally write most types the other way unless I envision adding indices later
18:39:21 <heatsink> GADT syntax does emphasize the interpretation of data constructors as stuck functions.
18:40:42 <k00mi> copumpkin: I just wanted to emphasize that using GADT syntax deviates from the standard
18:40:52 <k00mi> I realize that's not a concern for everyone
18:40:54 <copumpkin> few people pay attention to the standard
18:41:05 <copumpkin> it hasn't been updated in years
18:42:26 <Luke> is there any way to use an Int64 with IntMap? Does it basically just become a 64bit int on a 64bit machine?
18:42:54 <heatsink> You can't unless you know it's safe to convert to Int
18:43:00 <mwhit> isn't ghc the *only* haskell2010 compiler anyway?
18:43:06 <mwhit> all the other ones seem to be 98
18:43:49 <copumpkin> Luke: nope, and it makes me sad
18:44:25 <heatsink> We should have unboxed type variables.
18:44:33 <Luke> looks like minBound of Int and Int64 are the same on the arch im running so maybe it doesn't matter
18:44:56 <copumpkin> Luke: yeah, probably not on most machines, but still
18:45:08 <Luke> yeah but my machines
18:45:25 <copumpkin> I mean it probably doesn't matter on most machines
18:45:28 <Luke> oh
18:45:32 <copumpkin> but on principle it bugs me
18:45:54 <Luke> i just want to know I can store 64bit keys in IntMap and it seems like it'd work on my machines
18:45:56 <heatsink> It's like assuming a C int is a 32 bit 2's complement number.
18:46:23 <Luke> heatsink: yeah
18:47:37 <lfairy> heatsink: are there issues with code bloat there?
18:48:02 <lfairy> since unboxed types do not have a uniform representation (by definition), the compiler will need to generate a new implementation every combination of types
18:48:07 <lfairy> *for every
18:48:08 <mkrtem> I thought I had read somewhere that Int had been changed to always be 64 bit regardless.
18:48:22 <heatsink> Microsoft's .NET actually does it
18:48:34 <heatsink> .NET runtime
18:48:54 <lfairy> I guess since there aren't that many unboxed types, it shouldn't matter
18:49:15 <copumpkin> well
18:49:23 <copumpkin> it's proportional to the number of functions that care about the structure, too
18:49:56 <heatsink> I'd think of it as being like INLINE annotations.  It can lead to code bloat if you rely on it too much.
18:51:48 <heatsink> In principle, you could have a typeclass-like system for passing around unboxed types' sizes at run time
18:52:19 <heatsink> and then code duplication wouldn't be required to handle different unboxed types
18:52:59 <heatsink> No language implementation in use does that though
18:57:15 <mwhit> what's the State version of 'over' (for lens)?
18:58:35 <mwhit> oh i guess there's only operators for those
18:58:39 <mwhit> :t (%=)
18:58:41 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
19:00:03 <Javran> hi, how can I deploy lambdabot on other irc channels?
19:00:12 <mwhit> i almost feel like lens signatures are starting to make some minimum level of sense finally
19:00:23 <rudi_s> I added an instance of UTCTime (and Day and DiffTime) for Binary with instance Binary UTCTime where ... and now ghc warns me with "Orphan instance". Is this something to worry about and if not can I suppress the warning for these instances?
19:00:45 <haasn> lens signatures' saving grace is the specialized versions listed in the haddocks
19:00:57 <mwhit> haasn: yeah i still use those constantly
19:01:11 <mwhit> haasn: but I'm getting to the point where i can guess and be right ~40-50% of the time
19:01:50 <haasn> rudi_s: an “orphan” instance is an instance definition that is neither in the same module as the class definition, nor in the same module as the type in the instance head
19:02:14 <haasn> rudi_s: For more information, you can see http://www.haskell.org/haskellwiki/Orphan_instance
19:02:25 <mwhit> rudi_s: generally if you find yourself wanting to add an orphan instance, you should be creating a newtype
19:02:53 <rudi_s> haasn: I see, thanks.
19:03:17 <rudi_s> mwhit: But I guess I can't avoid the orphan instance in this case because I need an instance for Binary to serialize the type.
19:03:20 <haasn> It can be something to worry about; in particular, you can't choose whether or not to import an orphan instance or not - normally, you can import a module hiding either the type or the class in question and that will also hide their associated instances; but for orphan instances neither apply
19:03:56 <haasn> rudi_s: This can cause tricky dependency issues - for example, consider package “foo” includes a Binary UTCTime instance, and a package “bar” also includes a Binary UTCTime instance
19:04:23 <haasn> Now you want to write a package which depends on “foo” and “bar”, but you can't choose to *not* import those instances - as a result, you have both in scope, and trying to use one will be impossible
19:04:56 <haasn> rudi_s: Even worse, if these instances *differ* in their implementation, you could sensibly have a tool “footool” that depends on “foo” which serializes UTCtime in one way, and a tool “bartool” that depends on “bar” which serializes UTCTime in a different way
19:05:00 <haasn> And they would be incompatible and blow up
19:05:59 <mwhit> ^^^
19:06:06 <haasn> The best thing to do about orphan instances is probably to not include them in your libraries
19:06:22 <haasn> Having some self-contained orphans in your program should be benign
19:06:36 <haasn> But exporting them to other users can cause unexpected issues
19:06:38 <rudi_s> haasn: Ah. Thanks for the detailed explanation, I'll remember that for the future. - So the correct solution would be to define the instance in Binary. But as long as I'm not writing a library, using them in my main program is fine?
19:06:48 <HeladoDeBrownie> rudi_s, one thing mwhit suggested was to create a newtype with the instance. That sounds like it'd apply in your situation.
19:07:03 <haasn> In this case I would say to go ahead, if you don't care about the warning. If you do, a newtype is definitely one way to silence it permanently
19:07:09 <mwhit> rudi_s: if you're not writing a library, yeah, you can probably "get away with it"
19:07:16 <rudi_s> HeladoDeBrownie: But then I'd have to use the wrapper type all over my program instead of just UTCTIme.
19:07:16 <haasn> Since I'm guessing you're only parsing your own serialized data either way
19:07:23 <mwhit> but the correct thing to do is to go back and replace all usages with the newtype
19:07:28 <mwhit> rudi_s: yes, exactly
19:07:41 <mwhit> it's not as big a deal as you make it sound
19:07:52 <rudi_s> True, but looks a bit ugly IMHO.
19:08:16 <mwhit> eh, just use GeneralizedNewtypeDeriving and that gets rid of most of your boilerplate
19:08:32 <haasn> rudi_s: Another deceptively simple solution could be to forgo the Binary's class and make your own put/get functions and simply use those
19:09:32 <haasn> ironically, GeneralizedNewtypeDeriving before 7.8 is way worse than orphan instances :)
19:09:38 <mwhit> well, yes
19:09:42 <mwhit> but that's in the past
19:10:07 <mzero> haasn, rudi_s - doing my own put/get is generally what I do...
19:10:10 <rudi_s> I see, still have 7.4 on some machines so I guess I'll have to live with some wrapping (or ignore the warning).
19:10:26 <rudi_s> But how can I use those get/put with the rest of Binary?
19:10:41 <mzero> or perhaps making my own typeclass if I need to do many data structures of a small number of types
19:10:44 <rudi_s> I like Binary to take of serializing e.g. Integers and stuff for me.
19:10:50 <rudi_s> *to take care
19:10:50 <haasn> Many successful libraries do in fact include some orphan instances; including ‘lens’, so it's not a huge no-no. But you have to be careful about it, and you probably have to advertise it well
19:11:08 <haasn> rudi_s: What's the context?
19:11:10 <rudi_s> I guess I can't just suppress those specific warnings?
19:11:22 <mwhit> the orphan warnings? sure
19:11:22 <haasn> You can in fact suppress specific warnings
19:11:27 <mwhit> -fno-warn-orphans
19:11:39 <cmccann> I still wish there was a solution to the problem of justifiable orphan instances that have no sensible place to live
19:11:51 <haasn> cmccann: like an instance Binary UTCTime? :)
19:11:54 <mwhit> i actually do use them a lot for testing
19:11:56 <rudi_s> haasn: I'm not sure what you mean.
19:12:06 <mwhit> i have a non-exported module full of nothing but orphan Arbitrary instances
19:12:19 <haasn> rudi_s: Well, what do you need the instance for?
19:12:20 <rudi_s> mwhit: Can I ignore this warning only for a specific file?
19:12:21 <cmccann> like an instance of "class from widely-used package" for "type from widely-used package" where neither package wants to depend on the other for that one reason
19:12:34 <haasn> rudi_s: Yes, using OPTIONS_GHC (or something like that)
19:12:36 <rudi_s> haasn: Serializing my program data to a file.
19:12:50 <mwhit> rudi_s: sure, '{-# OPTIONS_GHC -fno-warn-orphans #-}
19:13:02 <mwhit> minus that '
19:13:15 <haasn> rudi_s: data ProgramData = PD { foo :: Integer, bar :: UTCTime } -- like this?
19:14:10 <Fuuzetsu> where are the exceptions that can be thrown by things like Data.Text.IO.readFile documented?
19:14:37 <haasn> If so, instead of defining an instance Binary ProgramData where put (PD i u) = do put i; put u
19:14:47 <haasn> I can simply defien it as where put (PD i u) = do put i; putUTCTime u
19:14:53 <haasn> and define putUTCTime u as whatever
19:14:56 <rudi_s> haasn: Yeah.
19:14:57 <haasn> No Binary UTCTime instance required
19:16:03 <haasn> The Binary class only exists so you can ad-hoc overload the “put” and “get” functions to refer to whatever type the context needs them to; sort of like how “show” works on any type that has a Show instance
19:16:37 <haasn> If instead we had a showInteger and a showFloat and a showChar and used those where appropriate, we could achieve the same results with less convenience
19:16:59 <haasn> Same principle can apply here
19:17:28 <haasn> Fuuzetsu: the source code ;^)
19:17:34 <Fuuzetsu> ebin
19:18:33 <haasn> (What I said is note quite true; classes allow more power than simply ad-hoc overloading, they allow abstraction over a pattern as well - in this case stuff like encodeFile; but you can still write a Binary instance for your own data types and take advantage of that)
19:19:51 <rudi_s> haasn: Thanks. I'm not sure how I'd write a custom putUTCTime u so I'll stick with the orphan instance for now.
19:20:10 <mwhit> eh? exactly the same way you write the put
19:20:12 <mwhit> just change the name
19:21:39 <Fuuzetsu> I'm looking for fixed-size arrays with the regular O(1) access and safe indexing operation, anything around or will I just have to trust that I'm indexing correctly?
19:22:40 <haasn> Doesn't Array/Vector and whatnot provide checks on indexing?
19:23:35 <mwhit> i think he means statically-sized
19:23:39 <mwhit> in which case hmatrix has that now
19:26:03 <rudi_s> mwhit: Oh, I think now I understand. That was too easy. Thank you all for your great help.
19:26:04 <Fuuzetsu> yeah, static size
19:26:58 <haasn> I find that in Haskell, the moment of understanding is often coupled with “that was easier than I thought”
19:27:10 <goglosh> woah 1336 nicks, you guys are 1 short of being 1337
19:27:11 <mwhit> Fuuetzu: yeah, hmatrix >=0.16 has them
19:27:21 <mwhit> there's no docs on hackage for anything >=0.16 for some reason
19:27:28 <mwhit> only documentation AFAICT is here
19:27:29 <mwhit> http://dis.um.es/~alberto/hmatrix/hmatrix.html
19:27:40 <mwhit> and the source
19:28:04 <mzero> goglosh: Haskell's motto: "Avoid leet at all costs!"
19:29:07 <Fuuzetsu> I'll go with Vector and once I have the thing going I'll hop to hmatrix and see whether performance suffers
19:29:16 <rudi_s> haasn: ;-)
19:32:40 <goglosh> mzer but why? 1337 is love
19:33:08 <benzrf> goglosh: my brother says "good meme"
19:33:19 <mwhit> ok, I'm coming around on lens. The first 2 weeks writing a library with it seemed more cumbersome than helpful but it's starting to save my ass as complexity grows
19:33:23 <mwhit> ekmett++
19:33:39 <goglosh> uh, thanks?
19:33:55 <benzrf> goglosh: i only posted that to teach him a lesson for saying things like 'good meme'
19:34:24 <mzero> goglosh: it was a joke: SPJ used to say that the unofficial motto of Haskell was "avoid success at all costs"
19:35:17 <mwhit> someone said the more modern interpretation is "avoid (success at all costs)" rather than "(avoid success) at all costs"
19:35:20 <mwhit> which seems right
19:37:53 <goglosh> so... 1337=success?
19:37:59 <c74d> “avoid $ success at all costs”
19:38:00 <goglosh> isn't 1337=scriddiness?
19:42:37 <mwhit> ok, basic lens question: If I have a type a, with several separate lenses to _different_ fields of type b, how do i build a traversal of them?
19:44:44 <mwhit> all the methods in Lens.Traversable seem to just deal with functors over the type
19:44:44 <bitemyapp> mwhit: you might try #haskell-lens
19:44:52 <mwhit> fair
19:45:02 <bitemyapp> mwhit: not trying to punt you, just easier to get their attention there.
19:45:08 <bitemyapp> IME anyway
19:48:17 <Fuuzetsu> where can I find bitshifts on Word8/16 and all that?
19:51:22 <rudi_s> Fuuzetsu: Data.Bits
19:51:38 <Fuuzetsu> ah great
19:51:38 <Fuuzetsu> ty
19:51:43 <rudi_s> np
19:54:20 <goglosh> (nicks
19:54:23 <goglosh> damn sorry
20:07:39 <rudi_s> Is there a shorter/cleaner way to set file permissions than setFileMode from System.Posix.Files? setFileMode p (ownerReadMode `unionFileModes` ownerWriteMode) is quite long compared to chmod 0600.
20:08:20 <intrados`> Is anyone familiar with console-program? I'm trying to come up with a good way to handle multiple arguments. Here are a couple of ways I've come up with, but I'm not terribly satisfied with either: http://lpaste.net/108614
20:09:28 <Clint> rudi_s: FileMode is just an alias for CMode
20:11:14 <rudi_s> Clint: So I can just use setFilemode p (CMode 0600) with the same effect?
20:11:47 <Clint> rudi_s: no, because 0600 is not octal; use 0o600 or something
20:12:44 <rudi_s> Clint: Oh, I didn't know that. Thank you.
20:14:18 <rudi_s> I'm a little confused, setFileMode p 0o600 seems to work fine too. Why do I not need CMode 0o600?
20:16:14 <Clint> rudi_s: because there's a Num instance for CMode
20:16:15 <k00mi> rudi_s: CMode implements Num and integer literals have type Num a => a
20:16:25 <ab9rf> heh
20:16:47 <rudi_s> Clint, k00mi: Ah, makes sense. Thank you both.
20:39:07 <undata> hi, what is the rationale behind putting the comma in front aligned with the open bracket in records?
20:39:17 <undata> I've seen that in style guides
20:39:53 <pavonia> You don't have to touch adjacent lines if you add or remove fields
20:40:58 <undata> pavonia: ah, is there typically a return after the {   ?
20:41:28 <pavonia> Not sure
20:41:50 <undata> pavonia: it would make sense in that case; otherwise it's just a question of having to fiddle the first one or the last
20:42:28 <pavonia> Hhm, true
20:42:52 <cmccann> undata: I think it's mostly that Haskell programmers have a weird fixation with lining things up in columns
20:43:17 <pavonia> But I think that was a reason given in some guide I read once. Maybe I remember wrong
20:43:27 <benzrf> cmccann: more like haskell, perl, c, and ruby programmers
20:43:28 <cmccann> it's what happens when years of the layout rule have addled your brain I suppose
20:43:29 <benzrf> off the top of my head
20:43:34 <benzrf> i dont think python people do it
20:43:43 <undata> cmccann: haha, that was my assumption
20:43:45 <cmccann> python people are weird, so they don't count
20:43:46 <benzrf> i dunno about java
20:43:56 <MP2E> I'm guilty of obsessively lining up my columns
20:43:56 <shachaf> a weird fixation with functions returning the arguments passed to them
20:43:58 <MP2E> but they look so nice!
20:44:00 <undata> cmccann: as a weird guy, I've been formatting my haskell like python :)
20:44:07 <cmccann> the column fixation seems way more common in haskell than elsewhere in my experience
20:44:27 <haasn> It's a fixation I'm proud of
20:44:32 <undata> however in my python I tend to use spaces to align quite a bit, much to the offense of pep8
20:44:52 <kazagistar> yeah, I like strategies that line up, and require minimal effort
20:45:31 <platz> are there any other languages that can dispatch a return type besides haskell?
20:45:41 <cmccann> anyway, one nice thing about comma first is that it means a type signature will be the last thing on the line
20:45:59 <kazagistar> f x = stuff\n\twhere\n\t\tstuff = blah
20:46:02 <platz> as I understand typeclasses is how Haskell is even able to do it
20:46:09 <cmccann> (which makes it look prettier when you compulsively align all the ::s)
20:46:13 <platz> so perhaps scala can, but I'm not sure
20:46:37 <platz> and definitely not sure about ocaml... I've heard F# can't do it
20:46:53 <kazagistar> platz: depends on how picky you are. You can make something generic over return type, but it does not dispatch exactly
20:47:07 <cmccann> platz: I think perl has magic context-dependent behavior tricks which non-perl programmers hate that has some of the same effect
20:47:21 <benzrf> cmccann: list vs scalar ctx?
20:47:25 <cmccann> it's not dispatch on return type as such though
20:47:26 <cmccann> yeah
20:47:26 <platz> hrmm
20:47:35 <cmccann> sorry it's been ages since I touched perl, can't recall the terms they use
20:47:44 <platz> of course there are approximations in dynamic langs, but thats like reflection/cheating
20:49:14 <Javran> hi, I have many haskell packages and I have enabled some flag to allow them generate haddock document, now these documents are under directories like "/usr/share/doc/{package-name}-{version}". is there a tool to organize them? Better if hoogle can be told to use these documents. Thanks!
20:51:26 <platz> kazagistar: cmccann: thanks for the info
20:52:21 <monochrom> other languages could use our proxy type idea to help choose the return type. for example whereas we have "maxBound :: Bounded a => a" and "maxBound :: Int", they can have "maxBound :: forall a <: Bounded. Proxy a -> a" and "maxBound (Proxy :: Proxy Int)". (by <: I mean subtyping or subclassing etc)
20:53:11 <jle`> hm.  wait, does java not have return type polymorphism?
20:53:16 <jle`> and c++ etc.
20:53:41 <monochrom> not in my knowledge
20:53:47 <cmccann> how would it?
20:53:54 <jle`> you can define two methods with two different type signatures for the arguments and teh same name, and the type of the arguments determines which function is actually compiled
20:54:10 <cmccann> the subtype-y stuff dispatches on the object the method belongs to, overload resolution could take return type into account but doesn't
20:54:21 <jle`> it seems like it wouldn't be two ahrd to define two methods with two different type signatures for the return value, and have the expected return value determine which is compiled
20:54:31 <mwhit> well you can also have the return type depend on the argument type in a java generic function
20:54:33 <jle`> ah yeah, overloading is the term they use, isn't it
20:54:42 <mwhit> i don't know the formal classifications of polymorphism really so i dont know if that counts
20:54:44 <cmccann> that's more just ad-hoc overloading than polymorphism as such
20:54:53 <jle`> then i guess that's what i mean
20:54:59 <jle`> can you ad-hoc overload on return types in java?
20:55:16 <cmccann> but yeah AFAIK there's no reason it couldn't include return type, but it doesn't
20:55:18 <mwhit> no just arguments
20:55:22 <cmccann> you certainly can't in C#
20:55:32 <cmccann> pretty sure you can't in C either
20:55:34 <ab9rf> a java function can return any object that is assignment-compatible with its formal return type
20:56:04 <mwhit> but you can have like 'public <T> T foo (Bar<T> baz)'
20:56:13 <monochrom> if you have to say Integer.max() vs Double.max() to get different return types, you are no longer doing return type polymorphism. it's just vanilla "different classes/objects happen to have same method name"
20:56:15 <jle`> so i can't do like:  int foo(bool bar);
20:56:21 <jle`> and also bool foo(bool bar);
20:56:25 <mwhit> no
20:56:36 <jle`> and if i say bool x = foo(true);
20:56:42 <monochrom> real return-type polymorphism is when you just write "max()", no prefix.
20:56:43 <jle`> it won't decide which foo to compile/use
20:57:00 <ab9rf> jle`: only if you had int and bool types that were both descendants of a common class or interface.
20:57:19 <jle`> but there's no reason why it should be that way, it was just an arbitrary choice
20:57:26 <jle`> ...afaik
20:57:43 <ab9rf> jle`: and even then there'd be a namespace collision
20:57:54 <mwhit> yeah you can't have the same erasure on two methods
20:57:54 <jle`> just like how you can define foo(bool bar, int baz) and foo(int baz, bool bar)
20:58:00 <cmccann> jle`: that's my understanding, yes
20:58:13 <jle`> you can overload on the arguments arbitrarily, but not the return type
20:58:18 <cmccann> it's all compile-time which-function-goes-here stuff
20:58:22 <mwhit> correct
20:58:32 <mwhit> because argument overloading doesn't require real inference
20:58:37 <mwhit> it's just easier
20:58:44 <jle`> neither does return type overloading, does it?
20:58:46 <ab9rf> dunno for C++ or C# but for java the combination of method name and method argument formal types has to be unique.  return type is not part of that (evne though it is part of the method signature)
20:59:15 <mwhit> ^^^ exactly. "cant have the same erasure"
20:59:16 <jle`> today in #haskell we talk about java
21:00:09 <mwhit> well i guess that's not the same
21:00:21 <mwhit> i'm mediocre with java
21:00:35 <cmccann> you don't need real inference to allow return-type overloading in most situations
21:00:49 <ab9rf> mwhit: in java erasure specifically refers to the slightly braindamaged way java does genericism (due to limitations of the virtual machine)
21:01:10 <mwhit> yeah i just looked that up after i said it and felt silly
21:01:16 <cmccann> for example: anywhere you can use "var" to declare a variable in modern C# could have return-type overloading when not using "var" to declare it
21:02:14 <mwhit> it's weird, type systems for those languages are much less involved than haskell, but I don't understand them well because they just seem so ad-hoc
21:02:52 <cmccann> you could have return-type overloading almost everywhere without inference if you were willing to accept occasional ambiguity errors in hard-to-predict places
21:03:09 <MP2E> mwhit : in those languages, most interactions with the type system involve beating it into submission :P
21:03:18 <ab9rf> cmccann: what's life without a little unpredictable ambiguity?
21:04:04 <cmccann> ab9rf: predictably ambiguous, most likely
21:04:15 <cmccann> beyond that, I dunno. it's ambiguous.
21:07:15 <levi> In java, type erasure refers to... type erasure.
21:07:17 <monochrom> most languages are designed by "we only know how to implement this", "we think users only understand this", and "we believe in only this ideology". the result is bound to be ad-hoc.
21:08:23 <cmccann> monochrom: you forgot "we didn't even think about this and now everyone is relying on unspecified behavior"
21:08:34 <ab9rf> ghc doesn't like it when i tell it to relink an already-linked executable
21:25:48 <benzrf> g2g l8r
21:25:52 <benzrf> bye
21:26:30 <jle`> > foldr f x . map g [1,2,3]
21:26:32 <lambdabot>  Couldn't match expected type ‘a -> [a0]’ with actual type ‘[b0]’
21:26:35 <jle`> > foldr f x . map g $ [1,2,3]
21:26:36 <lambdabot>  No instance for (GHC.Show.Show a0)
21:26:37 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
21:26:37 <lambdabot>  The type variable ‘a0’ is ambiguous
21:26:37 <lambdabot>  Note: there are several potential instances:
21:26:37 <lambdabot>    instance [safe] GHC.Show.Show
21:26:44 <jle`> oops
21:26:48 <jle`> time to take it to pm
21:58:15 <joash> I'm trying to write a function castMessage :: Message -> a
21:58:55 <joash> where Messsage is a type containing a MessageType that maps onto an arbitrary type for a
21:59:06 <shachaf> Arbitrary?
21:59:11 <shachaf> How does that work?
21:59:12 <joash> so i can deserialize a Message into a type
21:59:25 <joash> well idk
21:59:31 <shachaf> What you wrote means: castMessage :: forall a. Message -> a
21:59:44 <mwhit> i'm not sure I understand what you mean by "a messagetype that maps onto an arbitrary type for a"
21:59:50 <shachaf> I.e. as the user of castMessage, I can choose any type "a" I want, say Int, and then castMessage :: Message -> Int
21:59:59 <mwhit> right but
22:00:02 <shachaf> I get to choose the type, not you. Is that what you want?
22:00:02 <mwhit> that's impossible
22:00:08 <mwhit> oh sorry
22:00:12 <joash> oh
22:00:13 <mwhit> i thought you were joash
22:00:13 <joash> no i mean
22:00:23 <joash> the Message
22:00:31 <joash> determines what type will be output
22:00:33 <joash> by this function
22:00:37 <mwhit> how?
22:00:42 <shachaf> OK.
22:00:59 <joash> i was thinking
22:01:06 <shachaf> Sometimes things like that are possible, but usually the right thing to do is to spend a bunch of time thinking about what's going on and what your function really means.
22:01:23 <joash> just a mapping of MessageType to other types
22:01:30 <joash> oh ok
22:01:32 <mwhit> i mean it depends on what you mean, but probably the right answer is that Message should be a a parametrized type, like castMessage :: Message a -> a
22:01:39 <joash> yeah
22:01:43 <shachaf> I don't think that's -- whatever.
22:01:52 <joash> but if i'm deserializing it
22:01:56 <joash> how do i know in advnace
22:02:02 <joash> what the parameteraized type is?
22:02:06 <mwhit> can you explain in more detail what message is?
22:02:12 <mwhit> and messagetype
22:02:27 <joash> well i'm trying to send messages across the network
22:02:28 <mwhit> as in give the actual declaration, preferably
22:02:38 <joash> oh ok
22:03:07 <joash> data MessageType = Ping | KeyExchange | PeerList deriving (Show, Generic)
22:03:24 <joash> and then Message is
22:03:45 <joash> data Message = Message { messageType :: MessageType, body :: I.ByteString }
22:03:52 <Welkin2> you can use lpaste
22:03:54 <Welkin2> @lpaste
22:03:55 <lambdabot> Haskell pastebin: http://lpaste.net/
22:03:57 <mwhit> okay, it seems like those message types would each deserialize to very specific things
22:04:00 <mwhit> not to any arbitrary thing
22:04:09 <joash> oh ok
22:04:15 <joash> bad choice of word
22:04:25 <joash> sorry :)
22:04:37 <mwhit> well, castMessage :: Message -> a means literally any message can give you any type you want
22:05:09 <joash> so it should be just
22:05:18 <joash> returning a parameterized type?
22:06:47 * hackagebot blas-hs 0.1.0.2 - Low-level Haskell bindings to Blas.  http://hackage.haskell.org/package/blas-hs-0.1.0.2 (Rufflewind)
22:22:52 <tac> Is quickcheck still the #1 testing framework?
22:23:06 <tac> Or are there cooler, hipper frameworks I shoud look into?
22:23:22 <jle`> joash: so what type do you think your Message -> function should have?
22:23:26 <jle`> we'll try to work with that
22:24:08 <jle`> (Message -> a) is actually function that is impossible to implement, btw
22:24:39 <jle`> that's because it can return *any* type...so if i ask it for a Double, it should return a Double, if i ask it for a Bool, it should return a Bool...if i ask it for a Void...
22:24:54 <jle`> what you can do is perhaps ParseableFromMessage a => Message -> a
22:25:12 <jle`> which is the path taken by the Read typelcass and the `read` function
22:25:22 <platz> tac: quickcheck does property-based testing, which is great for expressing invariants.  there are more traditional testing frameworks that feel like those in other languages when property-based testing isn't as appropraite, such as HSpec or HUnit
22:25:43 <jle`> joash: but usually, we don't like creating new typeclasses for specific situations like this
22:25:56 <jle`> it's a bit of a bad design practice
22:26:14 <tac> platz: property-based is the one I'm looking for anyway
22:26:18 <tac> thank you though!
22:26:58 <jle`> but if you want your user to derermine exactly what type to parse a message into, then that might be your best bet.  although i consider you look at your problem from a higher to level to see if you can avoid it in the first place
22:27:37 <jle`> actually maybe that's not your best bet, you can just do parseIntoInt, parseIntoString, parseIntoDoube :: Message -> Double, w/e
22:27:58 <bb010g> How should I structure a standalone Eq deriving for a data structure ``Rose t a = Rose a (t (Rose t a))``? I would think ``deriving instance (Eq a, Eq (t (Rose t a))) => Eq (Rose t a)``, but GHC doesn't like that (at least without UndecidableInstances magic).
22:28:06 <jle`> the result is more or less exactly the same, as far as the compiler can tell; you just don't have the neat polymorphism
22:29:41 <tac> ah, smallcheck was th other one I was thinking about
22:29:46 <tac> how do Smallcheck and Quickcheck compare?
22:30:30 <joash> jle`: thanks! i was writing a function for each deserialized type, and wondering if there was a neater way.
22:31:09 <jle`> joash: typeclasses are basically a mechanism to allow one function to "stand in" for each specific function, chosen based on the type signature desired
22:31:50 <jle`> so you could write a parse :: Parse a => Message a -> a, and compiler would choose which function (parseIntoInt, parseIntoString) to actually compile
22:31:54 <jle`> whenever parse is used
22:32:09 <joash> yeah
22:32:13 <jle`> but yeah, typeclasses are discouraged for small localized uses like this
22:32:29 <joash> i think you would still need to know the type of a in advance?
22:32:37 <jle`> it would work like `read`
22:32:44 <bb010g> joash: You could try something like this: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
22:32:47 <jle`> if you have had any expreience working with read and the Read typeclass
22:33:12 <mwhit> joash: if you can determine your MessageType at runtime, can't you determine the type of a the same way?
22:33:14 <jle`> bb010g: at this point though, if his typeclass only has one function in it, his application would basically just be `id`
22:33:17 <mwhit> every message type corresponds to one a
22:33:29 <joash> yeah
22:33:39 <jle`> joash: oh wait.  can any message correspond to *any* possible parsing type?
22:33:43 <joash> i can, just the way i'm doing it seems messy
22:33:44 <joash> nope
22:33:47 <joash> just one
22:33:47 <jle`> or can only some messages parse to some types
22:33:49 <jle`> oh
22:33:49 <joash> yeah
22:33:56 <jle`> well then you don't really want this, heh
22:34:18 <jle`> this would be if any message could be parsed into any `a`
22:34:24 <joash> oh ok
22:34:25 <joash> yeah
22:34:42 <jle`> that's what Foo a => Message -> a "means"
22:34:43 <joash> i said arbitrary
22:34:52 <jle`> arbitrary as in, arbitrarily chosen by the user
22:34:57 <jle`> so the user can choose any arbitrary type
22:34:58 <joash> and everyone got excited :(
22:35:00 <jle`> and it'll parse into it?
22:35:06 <jle`> ah, so no
22:35:09 <joash> nah
22:35:17 <jle`> consider using a sum type for an output
22:35:26 <jle`> data Output = OuputString String | OutputInt Int | ...
22:35:30 <mwhit> nah, he has each Message holding a MessageType, which is isomorphic to his desired a
22:35:32 <jle`> parseMsg :: Message -> Output
22:35:48 <orion> When writing example code in haddock, how do I have it merely print out the result of a function?
22:36:02 <jle`> orion: merely print out?
22:36:46 <jle`> print out in what way?
22:36:50 * hackagebot retry 0.5 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.5 (OzgunAtaman)
22:36:57 <orion> jle`: Yes, I want it to merely print the result of an expression when I build the documentation.
22:37:10 <jle`> does just typing out the result not work?
22:37:19 <jle`> what are you trying, what does it result in, and how does that differ from what you want?
22:37:20 <orion> I don't know what the result is ahead of time.
22:37:31 <orion> I am writing examples for how to use a crypto library.
22:37:33 <jle`> oh, you want haddock to evaluate the expression for you?
22:37:38 <jle`> haddock doesn't do that
22:37:48 <jle`> it's basically just an HTML formatter
22:37:53 <orion> I see.
22:37:58 <bb010g> orion: You aren't able to pre-evaluate? What's the type of the function?
22:38:00 <trap_exit> this is going to sound stupid, but I'm completely serious
22:38:04 <trap_exit> I need to find a good name for the following datatype
22:38:06 <jle`> orion: have you considered opening up ghci ?
22:38:11 <jle`> and evaluating it in ghci?
22:38:13 <jle`> or cabal repl?
22:38:17 <orion> bb010g: createKeypair :: IO (PublicKey Curve25519, SecretKey Curve25519)
22:38:20 <trap_exit> it's like a mix of State + MVar, except whenever the MVar is updated, there's a list of [IO ()] that get fired off
22:38:29 <trap_exit> so it's like  "WatchedVar"
22:38:37 <jle`> orion: even if it could evaluate that, IO has no Show instance
22:38:38 <trap_exit> I considered the name WVar, but on my monospace font, WVar and MVar look too similar
22:38:55 <trap_exit> and now I'm trying to find a good name for this object -- this 'watched state' --- ile a set of [IO ()] get fired off whenever it updates
22:38:59 <orion> jle`: Well the thing is, I don't know how to write the example and make it pass doctest.
22:39:02 <jle`> do you want haddock to execute arbitrary IO?
22:39:06 <jle`> that'd be scary ;)
22:39:14 <jle`> -- | hi this is my documentation
22:39:21 <jle`> -- >>> system "rm -rf /"
22:39:29 <joash> Observed Var
22:39:36 <joash> lol
22:39:41 <orion> > system "rm -rf /"
22:39:43 <lambdabot>  Not in scope: ‘system’
22:39:46 <orion> :<
22:39:49 <joash> Spied On var
22:39:56 <bb010g> orion: It's sandboxed anyhow
22:40:09 <bb010g> NSAVar
22:40:09 <trap_exit> ObservedVar hmm, Spied on Var
22:40:21 <trap_exit> maybe I should call it the Kim Kardashian Var; since it broadcasts minor changes
22:40:25 <trap_exit> KKBar
22:40:26 <trap_exit> KKVar
22:40:39 <joash> that's good
22:40:45 <mwhit> orion: that's not a testable property, that's why you can't write it to pass
22:40:53 <orion> ah
22:41:00 <trap_exit> SOVar is interesting too
22:41:17 <trap_exit> spied on Var ... can also be Significant Other Var, since it logs all changes too
22:41:19 <mwhit> i meant those in the colloquial, non-quickcheck sense
22:41:24 <mwhit> but you could write a quickcheck property for it
22:41:26 <mwhit> probably
22:41:46 <mwhit> and put that in the doctest
22:42:01 <orion> Can I get doctest to at least type check the example instead of doing a property test?
22:43:34 <trap_exit> is TVar already taken in Haskell ?
22:43:40 <trap_exit> this Var is sorta transactional
22:44:01 <trap_exit> http://hackage.haskell.org/package/stm-2.1.1.2/docs/Control-Concurrent-STM-TVar.html damn it
22:44:02 <joelteon> yeah TVar is for transactional vars
22:44:11 <joelteon> maybe TTVar
22:44:13 <joelteon> or TVarT
22:45:09 <mwhit> orion: what about just ">>> let createKeyPair = ..."?
22:45:37 <mwhit> that would fail if it doesn't typecheck
22:47:44 <orion> mwhit: hmm, true
22:49:03 <trap_exit> gentlemen
22:49:06 <trap_exit> I have decided, it's called a ZVar
22:49:10 <trap_exit> because no one uses Z
22:49:12 <mwhit> is there not a function like groupsOfN :: Int -> [a] -> [[a]]?
22:49:16 <mwhit> hoogle and Data.List have nothing
22:49:45 <trap_exit> partition comes to mind
22:49:46 <Exio4> chunksOf?
22:50:00 <dfeuer_> Is there a way to -fforce-recomp a module without recompiling the modules it includes?
22:50:06 <joash> Zuckerberg Var
22:50:07 <joelteon> we should rename aeson to json
22:50:21 <glguy> :t Data.List.Split.chunksOf
22:50:22 <lambdabot> Int -> [e] -> [[e]]
22:50:36 <mwhit> ah
22:50:37 <mwhit> thanks
22:51:08 <trap_exit> no no, the Zuckerberg Var can not be implemtned in haskell
22:51:12 <trap_exit> becuase Haskell would prevent information leaks
22:52:13 <jle`> :P
22:52:15 <l0cust> joelteon: already a package called "json" :(
22:52:23 <joelteon> kill it
22:52:23 <jle`> trap_exit: btw, why [IO ()] and not IO ()?  do you want to be able to break up the list later?
22:52:25 <joelteon> and replace it
22:52:34 <l0cust> joelteon: but aeson is already so well known
22:52:38 <platz> suprised it's not Æson
22:52:40 <trap_exit> jle`: oh, it's actually a Map Key (v -> IO ())
22:52:48 <trap_exit> jle`: so I can dynamically add/remove listenres
22:52:52 <jle`> ah i see
22:52:52 <trap_exit> [ IO() ] was a simplifying lie
22:52:55 <mwhit> i like aeson
22:53:03 <mwhit> so many haskell library names are too generic
22:53:07 <l0cust> joelteon: I do think that ByteString and Text should be implemented into the standard library
22:53:19 <l0cust> mwhit: I think you mean "descriptive"
22:53:26 <joelteon> well that's not even remotely the same thing
22:53:41 <mwhit> well we'd all love to nuke Prelude and have Prelude dunrite, but whatcha gonna do
22:54:00 <l0cust> mwhit: Snoyberg is working on an alternate prelude that looks promising
22:54:44 <mwhit> yeah but the "nuking and replacing" part is key
22:54:52 <l0cust> mwhit: yeah
22:54:54 <platz> I was kind of hopeful for String /= [Char] but that seems a bit drastic
22:54:55 <bb010g> Ok, UndecidableInstances seemed to fix the recursiveness of the Eq instance, but I can't figure out Typeable. I'm trying to derive Typeable from Rose t a = a (t (Rose t a)), and I don't know where to place the constraints in the deriving instance and not mess it up. (Should I even have constraints? What arity should the instance's kind be?)
22:55:31 <l0cust> platz: everyone uses text anyway
22:55:44 <mwhit> i mean it's only taken half a decade for Applicative => Monad and that's still not here
22:56:23 <platz> l0cust: I suppose it's hard to decide on the "best" type when there are a few choices too
22:56:35 <l0cust> platz: well, the typical way t
22:56:36 <Abathurr_> this is offtopic but does anyone know how to load a background image in irssi
22:56:48 <l0cust> Abathurr_: Not me, I use weechat
22:57:00 <l0cust> platz: with text, it's pretty simple
22:57:08 <bb010g> Abathurr_: Check your terminal conf.
22:57:10 <l0cust> platz: use ByteString for I/O, Text for internal shit
22:57:25 <Abathurr_> bb010g: thanks
22:57:41 <platz> l0cust: but you don't like String = Text
22:57:52 <l0cust> platz: what do you mean?
22:57:55 <gamegoblin> What’s the time complexity of doing a record lookup on an object?
22:58:11 <Exio4> for what is the offset in a bytestring (internal)?
22:58:13 <trap_exit> hmm; I need a way to do catchable error handling ... i.e. not using error ....
22:58:21 <trap_exit> what should I read up on ?
22:58:32 <platz> >:i String
22:58:34 <bb010g> trap_exit: Try Either or a custom sum type.
22:58:43 <l0cust> platz: you can just do
22:58:46 <l0cust> :i String
22:58:53 <l0cust> Well
22:58:56 <l0cust> never mind
22:59:12 <Exio4> @info String
22:59:13 <lambdabot> String
22:59:14 <platz> anyways, i mean wouldn't you rather that type String = Text then?
22:59:14 <zereraz> hello can someone tell me whats wrong here http://lpaste.net/108618
22:59:29 <l0cust> platz: no, I would rather that "Strings" be removed from the language
22:59:45 <l0cust> platz: I suppose "String = Text" would be mildly better
22:59:47 <platz> l0cust: I like that actually
22:59:53 <gamegoblin> :t readLn
22:59:55 <lambdabot> Read a => IO a
22:59:59 <platz> forces explicit choice
23:00:16 <gamegoblin> zereraz: I got it
23:00:22 <l0cust> platz: ByteStrings and Text have mildly separate use cases, and people need to learn them, especially in a strongly typed language like Haskell
23:00:24 <platz> because there is no one 'true' way to handle stringlike stuff and is context dependent
23:00:28 <gamegoblin> zereraz: Your last fibo line prints stuff. Your other fibo lines return ints.
23:00:35 <bb010g> zereraz: Run :t on print in GHCi.
23:00:48 <gamegoblin> :t print
23:00:49 <lambdabot> Show a => a -> IO ()
23:00:52 <zereraz> yea
23:00:59 <gamegoblin> So your last line returns IO ()
23:01:02 <gamegoblin> your others return Int
23:01:08 <zereraz> so IO Int?
23:01:11 <gamegoblin> no no
23:01:13 <trap_exit> hmm, I should use Either String () ?
23:01:16 <platz> it's kind of like how Python 3 forced everything to be UTF-8 internally, it's consistent but requires a lot of marshalling
23:01:17 <trap_exit> where Left = error, Right = a ok
23:01:30 <platz> so there isn't a *bets* way
23:01:32 <platz> best
23:01:33 <gamegoblin> zereraz: just make all of fibo return Ints
23:01:35 <bb010g> zereraz: If you want to print the result of the fibo on the list, try ``mapM_ print (fmap fibo [1..n])``
23:01:54 <zereraz> I've not used fmap
23:01:57 <l0cust> platz: exactly, it's context-dependent
23:02:05 <bb010g> zereraz: Sorry, map will do just fine. Habit.
23:02:08 <gamegoblin> zereraz: you can use map there
23:02:27 <gamegoblin> zereraz: fmap is a generalized form of map. map works on just lists, fmap works on anything that can be mapped over, say sets or trees, etc
23:02:37 <zereraz> ok
23:02:44 <bb010g> Or Maybe, Either...
23:02:56 <bb010g> IO... It'll come later.
23:03:02 <gamegoblin> bb010g: Trying to keep it relating to other programming languages ;)
23:03:13 <zereraz> mapM_ print (map  fibo [1..n])
23:03:18 <zereraz> ^is this correct
23:03:29 <gamegoblin> looks like it
23:03:46 <bb010g> zereraz: Try it out. :)
23:03:49 <zereraz> map return a []
23:03:56 <gamegoblin> so map fibo [1..] will return a list of fibo applied to all of those numbers
23:03:56 <zereraz> then why not use map twice
23:04:09 <gamegoblin> mapM_ print thatList will print everything in thatList
23:04:11 <bb010g> :t mapM_
23:04:12 <zereraz> map print (map fibo [1..n])
23:04:13 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
23:04:42 <zereraz> what about that^
23:04:48 <bb010g> mapM_ is a special type of lifted map for Monads (like IO) that throws away the result.
23:04:54 <zereraz> oh
23:04:54 <bb010g> :t mapM_ print
23:04:55 <lambdabot> Show a => [a] -> IO ()
23:05:05 <zereraz> because of print we have to use mapM_
23:05:11 <zereraz> what about mapM
23:05:15 <bb010g> :t mapM
23:05:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
23:05:23 <zereraz> oh
23:05:32 <zereraz> so no IO here too
23:05:59 <bb010g> It doesn't throw away the result. You could think of mapM_ as ``mapM_ f xs = mapM f xs >> return ()``
23:06:19 <zereraz> ok
23:06:21 <Exio4> @let fib = 1:2:zipWith (+) fib (tail fib)
23:06:22 <zereraz> thanks
23:06:23 <lambdabot>  Defined.
23:06:47 <bb010g> zereraz: That m parametrizes over any monad, per the ``Monad m =>`` constraint. So that m becomes IO in ``mapM print``:
23:06:51 <bb010g> :t mapM print
23:06:52 <Exio4> :t mapM_ print (take 10 fib)
23:06:52 <lambdabot> Show a => [a] -> IO [()]
23:06:53 <lambdabot> IO ()
23:07:23 <bb010g> @src mapM_
23:07:24 <lambdabot> mapM_ f as = sequence_ (map f as)
23:07:39 <bb010g> @src sequence_
23:07:39 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:07:45 <zereraz> oh
23:07:47 <bb010g> @src sequence
23:07:47 <lambdabot> sequence []     = return []
23:07:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:07:47 <lambdabot> --OR
23:07:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:08:02 <bb010g> @src mapM
23:08:02 <lambdabot> mapM f as = sequence (map f as)
23:08:10 <zereraz> I think I got it
23:08:20 <zereraz> I don't know much about mondas
23:08:23 <zereraz> monads*
23:08:35 <zereraz> but I got the IO monad part
23:08:38 <bb010g> zereraz: Have you read Learn You a Haskell for Great Good?
23:08:48 <zereraz> bb010g: not fully
23:09:00 <zereraz> bb010g: I read little bit once in a while
23:09:21 <bb010g> zereraz: It has a good section on them. Understanding will come with practice.
23:09:45 <zereraz> bb010g: I am totally new, will go to that a little later. Thanks
23:11:39 <SrPx> Is there any function that receives a list of monads and does something like `foldr1 (>>) monads` ?
23:11:48 <platz> is Repa still the best stream fusion combinator or are there newcomers on this block?
23:12:01 <joelteon> there is no value that can be described as a "monad"; monads are of kind * -> *
23:12:09 <joelteon> values inhabit types of kind *
23:12:10 <zereraz> still not working http://lpaste.net/108618
23:12:26 <SrPx> okay I mean monadic values
23:12:30 <SrPx> mobits, whatever
23:12:39 <bb010g> SrPx: Try sequence
23:12:51 <bb010g> SrPx: Sorry, sequence_
23:12:55 <bb010g> @src sequence_
23:12:56 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:13:00 <joelteon> SrPx, why don't you use foldr1 (>>) ?
23:13:24 <SrPx> for some reason `sequence_` works differently from `foldr (>>)` on my test case
23:13:26 <SrPx> k
23:13:32 <bb010g> zereraz: Look at your type annotation for fibo.
23:13:43 <zereraz> bb010g: 1 more mistake
23:13:47 <bb010g> zereraz: Try removing it and then asking GHCi.
23:13:48 <zereraz> bb010g: wrong brackets
23:14:11 <zereraz> bb010g: worked!
23:14:14 <zereraz> thanks
23:14:14 <Exio4> what does the offset mean? anyone knows? http://hackage.haskell.org/package/bytestring-0.9.1.4/docs/Data-ByteString-Internal.html#3
23:14:36 <SrPx> http://lpaste.net/108620 any idea ?
23:14:45 <bitemyapp> are the suggestions to learn System F in order to understand RankNTypes a sick joke?
23:15:02 <bitemyapp> because all the resources I've seen on System F/FC/Fw have made my eyes glaze over - violently.
23:15:16 <bitemyapp> the examples using id et al. have made more sense thus far.
23:15:55 <glguy> What aspect are you trying to learn about?
23:15:56 <platz> related - I've found trying to understand RankNTypes via stackoverflow is an exercise in futility
23:16:09 <bb010g> SrPx: The first keeps the last value, the latter throws it away.
23:16:20 <bb010g> However, the second is safe on [].
23:16:20 <platz> despite noble attempts at explanation
23:16:47 <bitemyapp> platz: I've had a mixed time with SO. Some answers have given me good examples, some have been confusing.
23:16:55 <mwhit> platz: let's say I have f :: (a -> b) -> c
23:17:09 <bitemyapp> glguy: I kinda get when I'd use RankNTypes but I know I'm nowhere near grokhood.
23:17:19 <platz> bitemyapp: agreed.  as far as i can tell, the "dumb" answer is that RankNTypes is just nested foralls
23:17:26 <bitemyapp> glguy: I sorta get forall, why the scoping affects when the type of the variable gets "fixed"
23:17:30 <mwhit> platz: f (g :: (Int -> String)) typechecks in this case
23:17:31 <bitemyapp> glguy: but that's as far as it goes.
23:17:46 <platz> but digging into exactly what forall is i think is tricky
23:17:49 <SrPx> bb010g: hmm I see, thanks. So `foldr1 (>>)` is the right way there, it seems
23:18:00 <mwhit> but if i do f :: (forall a. a -> b) -> c instead
23:18:04 <mwhit> then that does not check
23:18:09 <bb010g> :t foldr1 (>>)
23:18:10 <lambdabot> Monad m => [m a] -> m a
23:18:14 <bitemyapp> mwhit: because you can't know that.
23:18:19 <bb010g> :t sequence_
23:18:20 <lambdabot> Monad m => [m a] -> m ()
23:18:34 <bb010g> :t sequence
23:18:35 <lambdabot> Monad m => [m a] -> m [a]
23:18:42 <bitemyapp> bb010g: playing type tetris?
23:19:38 <bb010g> bitemyapp: On a different issue, a bit (although more kind Tetris). I was just checking there what SrPx was thinking about. :)
23:20:24 <trap_exit> is there a way to allow a MVar to do a non-blocking read, even when another thread is doing a takeMVar, ... , putMVar
23:20:31 <bitemyapp> bb010g: cool. always a fun game.
23:20:46 <trap_exit> i.e. during the time when a thread is doing (takeMVar, ..., putMVar) ... I want other threads to be able to do reads on the MVar
23:21:39 <bitemyapp> trap_exit: tryTakeMVar, but you have to be prepared to retry.
23:21:54 <trap_exit> no, I want non-blockingr eads
23:21:54 <bitemyapp> trap_exit: would STM serve your needs better?
23:22:06 <trap_exit> I just want a way for a reader to read an older value
23:22:10 <bitemyapp> trap_exit: tryTakeMVar is non-blocking, it's just not guaranteed to succeed.
23:22:10 <trap_exit> while another thread is atomically updating it
23:22:26 <trap_exit> I want non-blokcing guaranteed succeed, even if it occasionally gives me an older value
23:22:35 <bitemyapp> trap_exit: sounds a little STM'ish
23:23:23 <trap_exit> I dunno
23:23:25 <trap_exit> I'm rendering things to the screen
23:23:34 <trap_exit> I want a constanf rame rate, and I don't care if it's occasionally out dated
23:25:06 <platz> foralls here. Constructor <- rank-1
23:25:10 <platz> Constructor (foralls here. something) <- rank-more-than-1
23:25:55 <bitemyapp> platz: I got that much. I just feel like I'm missing something.
23:26:13 <platz> that's pretty much where I get lost too
23:26:35 <bitemyapp> like I said. I know how and to use it, roughly how deferring the "monomorphization" of the type variable works
23:26:40 <bitemyapp> but I think something's missing.
23:27:14 <mwhit> are we talking about understanding what that does, or how it works internally?
23:27:58 <bitemyapp> I know it means typeclass instances get bundled up with objects instead of getting pulled out of the aether.
23:28:13 <bitemyapp> I think I'd like a deeper semantic or operational understanding. Either seems profitable.
23:28:55 <mwhit> here's about as far as my understanding goes
23:29:13 <mwhit> @let rank1 = undefined :: Show a => (a -> String) -> String
23:29:14 <lambdabot>  Defined.
23:29:20 <platz> I've heard some say it's kind of like a lambda in the type system, but then others disagreed
23:29:29 <mwhit> @let rank2 = undefined :: (forall a. Show a => a -> String) -> String
23:29:31 <lambdabot>  Defined.
23:29:35 <mwhit> :t rank1 id
23:29:36 <lambdabot> String
23:29:38 <mwhit> :t rank2 id
23:29:40 <lambdabot>     Could not deduce (a ~ String)
23:29:40 <lambdabot>     from the context (Show a)
23:29:40 <lambdabot>       bound by a type expected by the context: Show a => a -> String
23:29:46 <mwhit> :t rank1 show
23:29:47 <lambdabot> String
23:29:48 <mwhit> :t rank2 show
23:29:49 <lambdabot> String
23:30:40 <platz> probably systemF would really make it the most clear because it will show how the binders work
23:31:16 <orion> What does this error mean?: Expected a type, but ‘Nonces Box’ has kind ‘Constraint’ In an expression type signature: Nonces Box
23:31:41 <mwhit> is Nonces a typeclass/
23:31:47 <orion> yes
23:31:58 <bitemyapp> platz: if you find a good resource for learning System F please let me know. Most I've found were *_*
23:32:03 <orion> randomNonce :: forall t. Nonces t => IO (Nonce t)
23:32:15 <tac> bitemyapp: I recommend Types and Programming Languages, if you can find a copy
23:32:16 <mwhit> then Nonces Box is not a type
23:32:22 <platz> bitemyapp: I'm interested myself, if I find something I'll share
23:32:23 <mwhit> any more than Num Int is a type
23:32:27 <orion> oh crap
23:32:49 <orion> Typo
23:33:06 <platz> tac: I know TAPL is theory but I think it also uses ocaml
23:33:14 <bitemyapp> tac: hrm. I wasn't aware TAPL covered System F.
23:33:14 <bb010g> bitemyapp: The Wikipedia page is a bit short but seems to cover it somewhat well. https://en.wikipedia.org/wiki/System_F
23:33:22 <trap_exit> in https://gist.github.com/anonymous/f5024f2947be435fe512 , is there a way to say diffable__apply_lst has a default implementation, which is just repetely applies diffable__apply ?
23:33:32 <bitemyapp> bb010g: I'd looked at it several times. Guess I'll give it another go.
23:33:55 <tac> platz: doesn't really matter if it's Ocaml. The book's code sections translate almost verbatim, since all they really use is static types, algebraic data types, and pattern-matching
23:35:04 <platz> tac: makes sense
23:35:30 <tac> bitemyapp: Yep. It's in there. It's pretty well done, too.
23:35:40 <bitemyapp> tac: cool, thanks.
23:36:08 <platz> i think the secret systemF sauce is "big-lambda" 𝚲 which allows one to bind over little lambda λ .
23:36:38 <platz> spj mentioned this briefly but i still know nothing
23:36:45 <trap_exit> kkhmm, figured it out :-)
23:37:23 <trap_exit> how can I make https://gist.github.com/anonymous/95236ec4247d1276dae1 constant space ?
23:37:25 <trap_exit> instead of linear space
23:37:42 <orion> https://github.com/centromere/hs-nacl/blob/master/src/Crypto/Nonce.hs#L55 <-- Why must forall t. be included in that type signature?
23:37:43 <t4nk032> hi has anyone made a maze solver in haskell?
23:39:52 <orion> If I remove it, I get this error: Could not deduce (Nonces t0) arising from a use of ‘nonceSize’
23:40:06 <Kaidelong> orion: because it needs l to match the type of t
23:40:25 <Kaidelong> I was confused at first but this is what ScopedTypeVariables allows
23:40:52 <bb010g> How exactly does Data work? I tried just normal deriving Data, but I couldn't get it to work, despite the type (kind * -> * -> *) being an instance of Typeable. From the Data.Data docs it looks like that should work.
23:41:07 <Kaidelong> if you have that where clause down there without that extension and without the forall it will assume (undefined :: t) really means "any t"
23:42:35 <orion> Kaidelong: But doesn't the type context restrict it from being any t? Doesn't it restrict t to any type that instantiates Nonces?
23:43:29 <Kaidelong> orion: haskell would see "l = nonceSize (undefined :: t)" and automatically instantiate that t as a free variable to give a meaning "l = nonceSize (undefined :: forall t. t)"
23:43:52 <Kaidelong> ScopedTypeVariables allows you to prevent that from happening by capturing the type levels from the top level and carrying them down to more local bindings
23:43:59 <Kaidelong> capturing the type variables*
23:44:56 <bb010g> What's the point of having ExplicitForAll? What's it do that makes it more useful than RankNTypes??
23:45:46 <orion> Kaidelong: Oh, very interesting.
23:46:19 <mwhit> bb010g: Nothing, it doesn't add any expressiveness
23:46:45 <mwhit> i think RankNTypes depends on it
23:46:46 <Kaidelong> I think this is a silly way to do this though, a better way would have been to make a method like "getRandomNonce" and then provide a helper (Nonced t) => Int -> IO t
23:47:20 <orion> Kaidelong: So, that means *without* ScopedTypeVariables I can have something like l = nonceSize (undefined :: t); m = nonceSize (undefined :: t) in the same function, and those t's would be distinct from one another, right?
23:47:30 <Kaidelong> yes
23:47:33 <orion> I see.
23:47:59 <orion> Yeah, it seems that there is a phantom variable for nonceSize.
23:48:03 <orion> I am not sure what purpose it serves.
23:49:57 <Kaidelong> I guess doing it the type driven way is better actually
23:50:31 <Kaidelong> randomNonce has an implementation that is guaranteed to be correct regardless of which particular Nonce instance you're talking of
23:50:39 <Kaidelong> more than making it an ad-hoc overload anyway
23:52:01 <orion> Kaidelong: https://github.com/centromere/hs-nacl/blob/master/src/Crypto/Encrypt/Box.hs#L112 <-- The parameter for the nonceSize function gets thrown out.
23:53:27 <orion> Kaidelong: type signature for nonceSize is t -> Int, but why have that sort of signature if the argument is just going to get thrown out anyway?
23:53:55 <mwhit> well that's just one instance
23:54:00 <mwhit> couldn't other instances use it?
23:54:09 <gamegoblin> What’s the computational complexity of a record field lookup?
23:54:23 <gamegoblin> log n?
23:54:30 <gamegoblin> Not sure how it’s stored
23:54:41 <Kaidelong> it should be O(1) but I have no idea what GHC actually does
23:54:56 <gamegoblin> I *could* be O(1) but I could see it being log n for some functional reason
23:55:10 <gamegoblin> it(
23:55:10 <gamegoblin> *
23:55:32 <gamegoblin> I know the runtime system uses a bunch of lookup tables or something
23:55:39 <gamegoblin> But I don’t know the details
23:55:55 <orion> mwhit: All instances throw the parameter away.
23:56:24 <Kaidelong> orion: then the parameter becomes convenient for choosing the right result
23:56:51 <Kaidelong> although then they could provide "nonceSize :: Int" as the method instead
23:57:06 <Kaidelong> and a getNonceSize :: (Nonces t) => t -> Int
23:57:30 <Kaidelong> oh wait no you couldn't
23:57:33 <Kaidelong> what am I thinking
23:57:35 <mwhit> oh wait duh, you do need it
23:57:37 <mwhit> haha
23:57:39 <Kaidelong> it has to be t -> Int
23:57:43 <orion> the t -> Int signature confuses me. Why is it necessary?
23:57:51 <mwhit> otherwise if some function doesn't know the Nonces at compile time
23:57:59 <mwhit> thre's no way to know which instance of nonceSize to use
23:58:02 <Kaidelong> because nonceSize is a method so it has to have t in the signature somehow
23:58:26 <Kaidelong> so that it can pick the right instance as mwhit said
23:58:33 <orion> hmm, seems hackish.
23:59:02 <mwhit> i mean you could set up a type family and use proxies and natVal, but that's even uglier
