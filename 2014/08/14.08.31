00:07:19 <lbstr> sure
00:07:41 <lbstr> Cale: https://github.com/ghulette/haskell-parser-examples/tree/master/src
00:07:48 <lbstr> i just use these
00:08:23 * hackagebot netwire-input-glfw 0.0.1 - GLFW instance of netwire-input  http://hackage.haskell.org/package/netwire-input-glfw-0.0.1 (Mokosha)
00:08:23 * hackagebot pandoc 1.13.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.13.1 (JohnMacFarlane)
00:28:19 * hackagebot maid 2014.8.31 - A simple static web server  http://hackage.haskell.org/package/maid-2014.8.31 (JinjingWang)
00:33:51 <filius> nshepperd: Thanks! Updated here: http://lpaste.net/110287  Still no luck. maybe it's time for a different data structure?
00:57:06 <nshepperd> filius: maybe change the order of the guards in go i j to stop it forcing the whole array (it should shortcut on (a' A.! i == b' A.! j) the same as d i j)
01:07:44 <dfeuer> Bitrot.
01:08:08 <dfeuer> Or something.
01:13:09 <filius> nshepperd: Indeed. I fixed that at http://lpaste.net/110287  but still it was killed while running ..
01:13:17 <augur> bitrot = bisexual trotskyist
01:17:48 <filius> also I looked again at the data, which is a random permutation of [1..8116]. The shortcut maynot be that frequent, as there's possibly only ~ 90 ~ sqrt(8116) matches...
01:40:15 <dmi3on> hey, everyone so I am about to start reading to write small app in haskell
01:40:58 <dmi3on> but first i want to find out if haskell is good for it, if not i just think of other real life project to write basic prototype in haskell
01:41:37 <Haskellfant> dmi3on: you mean a mobile app as in android,ios,… app?
01:41:38 <dmi3on> i have tcp/ip or udp feed around 0.20 - 1Mbps, local feed
01:42:28 <dmi3on> i need in real time filter data, like build arrays calcualte fair amout statitics build another arrays then using conditional statments filter data
01:42:42 <augur> do you know any haskell, dmi3on?
01:42:52 <dmi3on> it server side, finance/trading
01:42:55 <dmi3on> nooo
01:43:00 <augur> dmi3on: then dont try
01:43:13 <augur> haskell is way too complex to just jump into and write that sort of app
01:43:17 <dmi3on> today i start reading about erlang and like idea that code can be replaced realtime
01:43:25 <dmi3on> then reading more and got to haskell :)
01:43:25 <augur> youll end up angry and disgruntled and youll hate haskell
01:44:12 <augur> learning haskell takes time, because it requires a different thought process, and if you try to push yourself too hard, you'll just want to give up
01:44:43 <dmi3on> augur: i get use to it, i have a psychological disorder is its simple or i can see finish line i lose interest does not meter how much i can benifit kind of
01:45:34 <Taneb> Is there a library that provides a good multiset type?
01:45:38 <dmi3on> i have a bit time, will start from basic and slowly build i have like 3 month to build basic prototype I am intreasted in processing data from network mostly
01:46:01 <dmi3on> I know a bit C and have fair exp in python
01:46:04 <augur> Taneb: Map a Int ?
01:46:12 <augur> you'd need some wrapper functions tho
01:46:57 <augur> define something like   count :: a -> Map a Int -> Int   and when you lookup a, Nothing -> 0, Just n -> n
01:47:13 <augur> i think thats the best choice. i doubt there's a multiset type that can improve on that
01:47:27 <dmi3on> also i kind hate oop and i see everything in steps and kind haskell looks like its all done this way at least on my basic understanding heh
01:47:28 <augur> dmi3on: well good luck!
01:47:36 <augur> yeah haskell is good
01:47:41 <augur> its just very different
01:47:48 <dmi3on> augur: how complex is program in haskell that i want to write ?
01:48:09 <Lowl3v3l> dmi3on, what do you mean by complex?
01:48:10 <augur> im sure that in principle its simple
01:48:21 <dmi3on> like in C it probably will take me 3-10 days to write this
01:48:21 <augur> but also im sure that the concepts required to do it arent
01:48:33 <dmi3on> python i think like 2 days tops,
01:49:11 <augur> i'd be unsurprised if experienced haskellers could hack it out in a few hours. but theyll know all sorts of stuff that took a while to truly grasp
01:49:38 <dmi3on> what top 3 hardest things ?
01:49:55 <Lowl3v3l> dmi3on, the core-problem is : your expertise with other , non functional, languages won't help you much... In my experience FP is SIMPLER for people that never programmed before than for year long imperative programmers
01:50:07 <augur> i suspect youll need some lazy stream processing and thats a pain to grok
01:51:04 <dmi3on> to be fair i am slow some times, like it took me almost year to accept that i need some type of OOP in python and before that while i uderstood what means OOP i never was able to come up with code that would be really need to implement OOP
01:51:26 <pertl> anybody using the jetbrains idea haskell plugin? I can't figure out why I don't get tooltip informations on the function. any idea?
01:51:43 <dmi3on> but now its just click and i see part of code be better in OOP
01:53:03 <Lowl3v3l> dmi3on, you do NOT need OOP at all... it's just one paradigm in many, although it's nearly impossible to write python without having OOP in the background. But it's not a big deal to programm at least a little functional in python.
01:53:45 <ZeusMoose> Hi. It was suggested to me that I create an ADT using record syntax, with three fields, year, month and day, and to construct it using a 3-tuple. I can't figure out how to construct it using a 3-tuple. Could anyone point me in the right direction? http://lpaste.net/110296
01:53:58 <dmi3on> Lowl3v3l: i undertand this i just was trying to explain where i was slow before
01:54:55 <Haskellfant> :t curry
01:54:57 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:55:04 <dmi3on> i read little bit toturial about haskell and got it that is totaly diff like damm like hieroglyphs and latin alphabet
01:56:02 <Lowl3v3l> dmi3on, so i guess you havn't got a mathematical background?
01:56:29 <Lowl3v3l> when i first stumbled about haskell my thought was sth like "That's cool, i can just write down what i think"
01:57:06 <dmi3on> a bit calculus, lots of statitics and probablity i guess i can say all basics nothing advenced
01:57:16 <Haskellfant> ZeusMoose: you could use something like uncurry3 http://hackage.haskell.org/package/utility-ht-0.0.5.1/docs/Data-Tuple-HT.html
01:58:58 <dmi3on> i dont know how to mesaure it in acdiamia sence self-taught
02:00:10 <dmi3on> Lowl3v3l: i don't, but i am addicted to math
02:00:16 <Haskellfant> ZeusMoose: I am pretty sure you won't get around to either making Date accept a three tuple using uncurry or write some function that extracts the values from the tuple and passes them to Date
02:00:47 <dmi3on> i just never really studied, most learned that i need for work
02:01:22 <Lowl3v3l> here again dmi3on , in case yu didn't read it in ##c ;)
02:01:25 <Lowl3v3l> dmi3on, learning haskell is definitely worth i as it will ( like learning lisp or Caml) forever turn you to a better programmer even if you do not use it. But if you just want to get work done and not want to learn you won't become happy with haskell
02:01:33 <dmi3on> i just cant motivate my self to learn something without vision where i can apply it right now to make $$$ or increase chances of making more $$$
02:02:16 <Haskellfant> it's said if you only learn to make more money and not because you are interested in something
02:02:16 <Lowl3v3l> well in that case i think you didn't learn math, you learned how to calculate( sry, but the core of maths are axioms and proofs, and i doubt you learned them)
02:02:29 <Lowl3v3l> Haskellfant, i second that
02:03:25 <ZeusMoose> Haskellfant: thanks for the tips, but either one seems like more work than what i have now. Perhaps I'll leave the code how it is and see if I can better clarify what was suggested to me.
02:03:34 <ZeusMoose> Haskellfant: thanks a bunch for the suggestion
02:04:47 <dmi3on> Haskellfant: I am intreasted in general AI, CS and randomness
02:04:48 <zalatovo> dmi3on: there are many things you can learn which only provide real benefit in the long term
02:05:32 <Lowl3v3l> dmi3on, all of them won't bring you short-term-money... but i definitely think all of them are worth learning!!!
02:05:44 <dmi3on> zalatovo: i know but i guess its disorder hehe, i give up fighting my self just try to adapt knowing my limitations heh
02:05:45 <Haskellfant> ZeusMoose: it's not that much work tupleToDate (year, month, day) = Date year month day
02:05:45 <Lowl3v3l> dmi3on, and especially for them, haskell may be a great choice
02:07:04 <dmi3on> Lowl3v3l: that why i am here after reading a bit i kind of start feeling it
02:07:37 <Lowl3v3l> dmi3on, but just to say : even python is. I did a non-trivial machine-learning-exercise in uni just using python ;) So its more important to grasp maths and computer science than to get the one language^^
02:07:40 <ZeusMoose> Haskellfant: my noobness shines through
02:08:18 <dmi3on> i have good couple friends who have know lots of math
02:08:28 <ZeusMoose> Haskellfant: I have something similar now, I'll try modifying it to use the ADT.
02:08:32 <dmi3on> i got support there very nice one :)
02:08:36 <ZeusMoose> Haskellfant: thanks again
02:08:39 <Lowl3v3l> dmi3on, lot's of it isn't enough, they need to know the right one :D
02:08:43 <zalatovo> dmi3on: either way learning Haskell was *fun* for me in the short term, so maybe that can motivate you
02:09:09 <Lowl3v3l> dmi3on, there is, after Hilbert died, no person that had or has got a grasp of the whole maths ;)
02:10:32 <dmi3on> true
02:17:25 <dmi3on> i know is complicated and its mostly about imlementation, but in what application haskell programming is usefull. What i understand it good for data processing application
02:17:59 <dmi3on> where speed and stability is on high priority
02:19:21 <MP2E> It's good for every kind of userland application you can imagine, except possibly emulation(and that could change, it's still possible to write an emulator in Haskell it's just slow because large regions of mutable state are managed inefficiently by GHC)
02:19:54 <MP2E> Emulation is out, programming for tiny SoCs where RAM is a premium is out, and making operating systems in it is out
02:20:01 <MP2E> but other than that, you are probably able to use Haskell.
02:20:21 <MP2E> (and that hasn't stopped people from trying)
02:22:48 <dmi3on> MP2E: is there adventage, like python speed of prototyping devel speed, C execution speed, hardware control, C++ speed/hardwrae control and easier to implement/maintain huge apps (guess)
02:23:21 <dmi3on> what haskell, i guess i made a very crude list of advategies
02:23:28 <dmi3on> whats haskell ?
02:23:50 <MP2E> dmi3on : I would argue that with Haskell the speed to production quality code is the highest of any language. Note production quality, not prototyping :) The type-system wrangling slows you down more than python, but when your program compiles it often 'just works'
02:24:58 <Lowl3v3l> dmi3on, if a programm runs in haskell many errors are excluded. Haskell is mathematically beautiful. Haskell programms can be proven to be correct if you want to( in C etc it's nearly impossible)
02:25:22 <MP2E> And that is the magic of Haskell. The fact that the compiler is a co-author of your program, guiding you with type errors to make your program logically consistent, the fact that every single statement can be read without needing to know about the code using it, and the fact that you can equationally reason about your program and debug it with nothing more than a pen and paper (or ghci)
02:25:49 <MP2E> the execution speed is pretty good to boot
02:26:33 <dmi3on> what about amount of lines of code like C/C++ vs python at least in my exp
02:27:36 <dmj`> dmi3on: in some contrived examples you can get python code to be shorter, but when building large systems there's no comparison. It also makes refactoring a breeze
02:28:06 <Lowl3v3l> dmi3on, depends on what you want to do^^ a little example : when i do project-euler things it's about 1/10 of what i'd need in C++
02:28:11 <mgomezch> haskell gives you code that is shorter, clearer, faster to write and with lower number of defects than just about anything out there.
02:28:14 <dmi3on> so only hard think what i undestand so far is get use to think i haskell heh
02:28:38 <dmi3on> i like that a lot that is shorter code :)
02:28:55 <mgomezch> it’s as much shorter than python as python is shorter than C++.
02:29:03 <MP2E> ^ sounds about right
02:29:12 <mgomezch> often far more.
02:29:15 <dmi3on> that sounds so cool heh
02:30:07 <dmi3on> ok, what about speed like where speed is mission critical can haskell be optimized to that level. what i understand possible just mad complicated heh
02:31:03 <mgomezch> haskell applies to problems with more or less the same range of performance requirements as java, with normal optimization effort (ie almost none)
02:31:44 <dmi3on> mgomezch: what i understand java is become pritty fast in past couple years
02:31:49 <mgomezch> if you spend a lot of energy on optimization, then haskell applies to problems with same range of performance requirements as C does.
02:32:04 <jle`> dmi3on: haskell's killer app is safety
02:32:26 <jle`> let's say you write python code, and you have an error somewhere in your code
02:32:36 <mgomezch> dmi3on: yes.  Haskell is usually faster than that.  but if you’re sloppy, maybe it’ll be as slow as java.
02:32:38 <jle`> let's say this error pops up in obscure cases that might not come up in your test cases
02:32:47 <jle`> or you have to be smart with your tests
02:32:57 <jle`> you run your python code for a few days or a few months before the error pops up, and it's bad
02:33:01 <Lowl3v3l> dmi3on, 90% of optimization should be modelling the problem properly and finding the proper algorithm... nearly no programmer is faster than a good compiler today... ( i mean, my first and second language are c and assembler... i program both for more than 10 years. But i am nearly unable to produce code that is faster than gcc -O2
02:33:06 <jle`> let's imagine haskell code with the same error
02:33:16 <jle`> the error is caught by the compiler, when you first try to compile the code
02:33:23 <Lowl3v3l> dmi3on, and ghc is pretty good too
02:33:27 <jle`> and at no cost of prototyping and productivity
02:33:31 <jle`> "speed of prototyping"
02:33:59 <dmi3on> mgomezch: you mean as C does, like C optimized and really well write code or just C code written by person like me :)
02:34:14 <mgomezch> prototyping in haskell is faster than in any other language I know.  the type system does *not* get in the way — it helps make things faster since the rich compile-time type information helps the compiler write a lot of code for you automatically.
02:34:30 <Taneb> augur, I feel like someone clever than me could do a better Multiset type than Map a Int
02:34:32 <jle`> i couldn't imagine prototyping in anything other than haskell
02:34:35 <jle`> (and enjoying it)
02:34:40 <Lowl3v3l> dmi3on, i would say that nearly all programmers are unable for nearly all applications to produce c code that runs significantly slower than haskell...
02:34:42 <Taneb> I might give it a go next week
02:34:46 <mgomezch> dmi3on: well-optimized Haskell performs on par with well-optimized C.
02:35:01 <Lowl3v3l> dmi3on, sry, i meant faster
02:35:18 <mgomezch> dmi3on: casually optimized Haskell performs on par with well-optimized, fast Java.
02:35:19 <jle`> haskell prototypes faster and when you finish, your code is already guarunteed to be correct
02:35:40 <jle`> python prototypes and you don't really ever have any assurance that it'll be correct
02:35:44 <dmi3on> i undestand now when  someone in #programming was suggesting to use haskell for ditributed application where simulations will take days to run and every mistake can be very costly
02:35:59 <jle`> in haskell, the compiler practically writes the code for you in many ways
02:36:15 <augur> Taneb: why dont you like that approach?
02:36:22 <jle`> the type system is expressive and powerful enough that often times, fi you write out the type, there is only one possible implementation that fits that type
02:36:33 <Taneb> augur, it gives me a bad gut feeling, but nothing more
02:36:47 <dmi3on> this sounds so cool and intresting
02:36:51 <jle`> so it's as if you are walking through a maze, and the compiler closes off every bad branch, leaving only the direct path to the end
02:37:02 <jle`> you still have to walk through the maze...but it's not a maze anymore, is it? :P
02:37:16 <jle`> you could do it blindfolded
02:37:34 <dmi3on> jle`: i can see its very important for haskell and in general to know what is the end :)
02:37:55 <mgomezch> and you can often call some TemplateHaskell function walkTheMaze and just go read a good book with the time you saved.
02:37:59 <augur> Taneb: its one of the standard mathematical representations
02:38:21 <augur> Taneb: well, more or less. something analogous to a -> Int, or Map a Int, etc.
02:38:27 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
02:38:27 <lambdabot> f a b c =
02:38:28 <lambdabot>     case a c of
02:38:28 <lambdabot>     (d, e) -> b d e
02:38:39 <jle`> i gave djinn a type signature and it spat out the only possible implementation ;)
02:38:49 <jle`> or well. possible and meaningful
02:38:59 <dmi3on> i am not sure i undertand it correclty that in erlang you can replace part of code while program is running, is it possible to do same thing with haskell ?
02:39:06 <dmj`> dynamic languages really suck for refactoing too, things just fail silently everywhere and you don't know until runtime
02:39:15 <mgomezch> dmi3on: nope, that’s not really practical in haskell.
02:39:22 <augur> jle`: modulo let
02:39:35 <augur> jle`: f a b c = let (d, e) = a c in b d e
02:39:41 <augur> alternatively:
02:39:51 <augur> jle`: f a b c = b (fst (a c)) (snd (a c))
02:39:57 <Lowl3v3l> dmi3on, well if you rebuilt such a great infrastructure like erlangs in haskell yes it would be.... but thats just theoretical^^
02:39:59 <mgomezch> or where, or with different whitespace, or alpha-renaming...
02:40:04 <jle`> augur: :P
02:40:09 <mgomezch> the only language I know of that gets hot code reload right is Erlang.
02:40:10 <Lowl3v3l> dmi3on, haskell and erlang have completely different targets
02:40:17 <augur> but these are spiritually the same
02:40:31 <mgomezch> Cloud Haskell has similar infrastructure but it doesn’t solve the hot code reloading problem.
02:40:32 <jle`> haskell is said to be the language for people who aren't smart enough to program C
02:40:40 <dmi3on> Lowl3v3l: can you please explain what you mean by targets
02:40:40 <jle`> or python
02:40:42 <augur> well, actually the one with projectors is interestingly different, but
02:40:44 <jle`> or dynamic languages
02:40:50 <Lowl3v3l> dmi3on, haskell is a language for geniuses by geniuses(larry wall), erlang was designed to implement safe systems ;)
02:41:06 <mgomezch> there is nothing about haskell that makes it «for geniuses», no.
02:41:10 <Haskellfant> jle`: ofc, haskell is for stupid people who want to get help by the compiler :)
02:41:13 <jle`> Lowl3v3l: you sure you didn't swap that?
02:41:24 <Lowl3v3l> dmi3on, the aim in designing both was completely different.
02:41:46 <Lowl3v3l> jle`, the quote? yes i'm pretty sure Larry Wall said that^^
02:41:53 <dmi3on> Lowl3v3l: haha, i guess i find out that soon lol
02:42:04 <mgomezch> haskell is not for geniuses.  haskell is for people.
02:42:04 <eikke__> actually, I think it should be possible to have erlang-like code reloading in haskell
02:42:08 <jle`> it's not just the type system, it's the lack of implicit state that makes haskell be a language where you have to "think less"
02:42:08 <dmi3on> Lowl3v3l: and what haskell what designed for to implement
02:42:15 <dmi3on> just general purpose ?
02:42:19 <jle`> and purity, and referential transparency
02:42:25 <dmj`> the problem with programming is humans not computers, the compiler is really just trying to save you from yourself
02:42:28 <augur> haskell is not referentially transparent
02:42:30 <augur> no language is
02:42:42 <augur> :x
02:42:45 <jle`> :x
02:42:55 <Lowl3v3l> dmi3on, haskell is at first a language for teaching and research
02:43:03 <MP2E> I found the quote by Larry Wall
02:43:04 <augur> for two reasons: 1) binding breaks it, 2) referential transparency is not a property of languages
02:43:08 <MP2E> "askell is one of those languages that mathematician-type-minded people love; it's sort of a language for geniuses, by geniuses."
02:43:13 <MP2E> Haskell* but yeah.
02:43:23 <MP2E> http://bigthink.com/videos/5-programming-languages-everyone-should-know <-- source
02:43:32 <Lowl3v3l> MP2E, thank you just my source^^
02:43:34 <dmj`> you don't have to be a genius to program in haskell
02:43:35 <augur> actually
02:43:37 <augur> i take that back
02:43:53 <mgomezch> Haskell is not in any way «for geniuses».  Haskell is for people.  human beings.  being a genius is not required or especially helpful.
02:43:55 <jle`> in any case, haskell is structured so that reasoning about code becomes dead-simple compared to other languages, when you can limit or eliminate implicit state
02:43:56 <augur> the SKI calculus can be said to be referentially transparent if you have some language-general notion
02:43:58 <dmi3on> augur: here is said that haskell does transperacy (what ever that means) :)
02:44:07 <dmi3on> http://learnyouahaskell.com/introduction#so-whats-haskell
02:44:09 <Lowl3v3l> dmj`, no you don't. I suppose hemeans that you will fully enjoy it only if you got a mathematical or other scientific bckground
02:44:11 <augur> dmi3on: what people mean is something like "supports equational reasoning"
02:44:15 <augur> but then, so too does C
02:44:32 <mgomezch> you don’t need a mathematical or a scientific background to enjoy Haskell.
02:44:42 <jle`> it's just that equational reasoning in C is a bit less fun than it is in haskell ;)
02:44:53 <jle`> and a bit more of a headache
02:45:06 <jle`> and consequently a lot less useful
02:45:13 <dmi3on> hehe
02:45:14 <jle`> C...*that*'s a language where you have to be a genius to program
02:45:24 <augur> jle`: yes
02:45:26 <augur> thats correct
02:45:26 <mgomezch> yep.
02:45:55 <dmj`> jle`: yes
02:45:56 <mgomezch> to do so correctly, productively and efficiently, yeah.
02:45:56 <jle`> who can keep track of literally every aspect of state in their head, including all of the libraries they use mixing together
02:46:03 <dmi3on> what all mean by programm
02:46:14 <augur> jle`: equational reasoning in C is like equational reasoning in haskell in IO typed programs
02:46:16 <dmi3on> C is not complicated to write basic programm at all
02:46:29 <dmi3on> any one can learn i guess like 3 month and 10 hours a day
02:46:36 <mgomezch> dmi3on: it’s complicated to write complex programs in C that are correct
02:46:39 <MP2E> to write basic programs sure
02:46:39 <Lowl3v3l> dmi3on, we talk about non trivial programs... like parsers.
02:46:42 <edlinde> how should I understand the difference between
02:46:51 <edlinde> binding and assigment ?
02:46:54 <dmj`> Lowl3v3l: you don't need to be a mathematician or theorist to program in Haskell, it's a general purpose language for all
02:46:56 <jle`> it's very complicated to even write non-trivial programs that aren't correct
02:47:05 <jle`> er. are
02:47:07 <jle`> heh
02:47:15 <MP2E> edlinde : Hmm, in what context do you mean?
02:47:23 <Lowl3v3l> dmi3on, well then you are a genious... i program c for more then ten years and i would not use it for any bigger application if i had a choice
02:47:29 <mgomezch> edlinde: binding is associating a name with a value in a region of a program.  assigning is usually understood as putting a certain bit pattern in a certain position in memory.
02:47:31 <osfameron> when I last tried to work my way through K&R I gave up when it got to memory management... it's 2014, I really don't have room in my brain for that :-(
02:47:34 <edlinde> MP2E: I was thinking that assignment in imperative langs is quite different yeah
02:47:42 <dmj`> dmi3on: 10 hours a day lol
02:47:47 <augur> metric days
02:48:09 <MP2E> edlinde: Ahh assignment in imperative languages vs assigning(or binding) a value in something like Haskell?
02:48:17 <dmi3on> I think most understanding what program should do is harder then writing in any laguage that kind where i get bugged down mostly :)
02:48:35 <edlinde> yes MP2E
02:48:40 <augur> the use of assignment in imperative languages is the perfect example of why haskell is not referentially transparent
02:48:42 <dmi3on> dmj`: monitoring my self over like 2 years i still average to 10 hours a day lol
02:48:58 <augur> let -- while not actually assignment -- has the _exact_ same properties wrt referential transparency
02:49:11 <dmj`> dmi3on: :)
02:49:23 <dmi3on> and i work can work straight from office like 30 hours pritty easy for me
02:49:28 <dmi3on> at list for now heh
02:49:52 <dmj`> dmi3on: do you drink coffee
02:50:00 <MP2E> edlinde : The difference is that assignment in an imperative language creates a stack local object that can be rewritten (or maybe not, if it's marked const). In Haskell, binding a variable to a value means that that variable *is* that value. They are now 100% interchangable because they are equivalent.. The compiler could optimize it away, it could exist as an object.. many things could happen! Mostly because we can guarantee that it won't be mod
02:50:04 <jle`> edlinde: assignment is a state-changing action in the context of an algorithm.  its purpose and timing is a careful part of an imperative algorithm.  in haskell, a binding is something like a definition.  a CPP macro, almost
02:50:39 <jle`> #define PI 3.1416
02:50:45 <edlinde> i see
02:50:51 <jle`> this isn't a "part" of the algorithm to generate your result at the end
02:50:53 <edlinde> yeah that makes sense
02:50:58 <jle`> it's just a definition
02:50:59 <edlinde> its alsmost like we given it some alias
02:51:06 <edlinde> *almost*
02:51:12 <augur> edlinde: thats exactly what it is, actually
02:51:14 <mgomezch> please read this for clarification with regard to the meaning of «referential transparency» and its application in programming languages http://stackoverflow.com/a/9859966
02:51:25 <jle`> in haskell, evaluation pretty much feels like macro expansion
02:51:25 <edlinde> thanks
02:51:34 <jle`> @src take
02:51:34 <lambdabot> take n _      | n <= 0 = []
02:51:34 <lambdabot> take _ []              = []
02:51:34 <lambdabot> take n (x:xs)          = x : take (n-1) xs
02:51:47 <jle`> @src map
02:51:47 <lambdabot> map _ []     = []
02:51:47 <lambdabot> map f (x:xs) = f x : map f xs
02:51:52 <augur> if you really want a good discussion of RT, mgomezch, there's a paper by sorensen or something like that
02:51:59 <edlinde> I guess imperative is more like thinking like a computer
02:52:00 <jle`> take 1 (map (*2) [1,2])
02:52:01 <mgomezch> augur: I’m interested!
02:52:03 <jle`> what macro to expand first?
02:52:10 <dmi3on> like once a every 3 days heh, i drink a lot water, vitamine water and  soda ( cut down my self on soda latly) and relly take good pills if that what you asking :)
02:52:18 <edlinde> while haskell is just solving the problem like a mathematician
02:52:19 <edlinde> :)
02:52:43 <dmi3on> dmj`: answer is above
02:52:56 <augur> sondergaard sorry
02:53:02 <augur> mgomezch: http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf
02:53:18 <Cale> mgomezch: That seems like a lot of text to express something that otherwise should be pretty straightforward
02:53:20 <augur> basically, computer scientists dont know what the term means
02:53:21 <mgomezch> augur: thank you!  will check this out (:
02:53:28 <augur> its more or less nonsense whenever a computer scientist says it
02:53:35 <mgomezch> yep yep
02:53:58 <jle`> take 1 (map (*2) (1:2:[])) = take 1 (2 : map (*2) (2:[])) = 2 : take 0 (map (*2) (2:[])) = 2 : [] = [2]
02:54:07 <augur> that post tho, mgomezch, is good. from what i can tell, anyway
02:54:17 <jle`> expand the definition of map...expand the definition of take...expand the definitoin of take...and you're done
02:54:22 <mgomezch> yeah, it’s got pretty solid gounding
02:54:38 <augur> strachey botched his use of the term
02:54:43 <augur> then some other people botched it even more
02:54:46 <augur> its just a mess in CS
02:54:52 <mgomezch> yep yep
02:54:58 <Cale> augur: I don't see how that's a reasonable thing to say
02:55:04 <dmj`> haskell is just hard to learn since functions are defined in terms of functions which are defined in terms of functions etc.. and you have to know all of them and their types in your head in order for you to be productive
02:55:05 <augur> Cale: read that link i posted
02:55:16 <dmi3on> so this is my undertanding of haskell, very complicated like (warning risk of brian demage), but also super cool to code, has not many real life applications but its all possible not know any limitations, will for sure make person smarter general and specificly in programming. did i miss anything ?
02:55:23 <mgomezch> but still strachey’s use is about as close as it ever gets to the proper meaning of the term as used in linguistics
02:55:27 <jle`> dmi3on: i don't think haskell is very complicated
02:55:31 <jle`> to program, that is
02:55:35 <mgomezch> as close as it gets in CS, I mean
02:55:51 <jle`> and i don't think we really said any of that stuff :P
02:55:53 <augur> mgomezch: actually its really not. its a demonstrably different concept
02:55:54 <Lowl3v3l> dmi3on, it's not very complicated. It only seems complicated for imperative programmers^^
02:56:06 <jle`> i feel like none of those things were said during this discussion, heh
02:56:11 <mgomezch> dmi3on: plenty of real-life applications.  I’ve had three programming jobs and all three have been almost 100% haskell work.
02:56:12 <jle`> and in fact, the opposite of many of those things were stated
02:56:34 <MP2E> yeah 'not many real life applications'?
02:56:53 <MP2E> It works for everything sans when you need find-grained control of memory
02:56:58 <mgomezch> augur: right, but it’s less radically nonsense than most other uses of the term in CS, I mean (:
02:57:02 <MP2E> fine*
02:57:15 <MP2E> or kernel mode code, I suppose.
02:57:34 <Cale> augur: Different from "It's okay to substitute equals for equals"?
02:57:39 <augur> Cale: yes
02:58:00 <Cale> augur: Well, that's what I think most people mean by referential transparency regardless
02:58:11 <mgomezch> it’s an improper use of the term, really.
02:58:15 <augur> Cale: thats what a lot of people in CS say, yes
02:58:15 <Cale> Linguists might use some other definition
02:58:19 <mgomezch> «equational reasoning» is fine for that.
02:58:29 <augur> Cale: or they phrase it differently, and it turns out to be meaningfully different
02:58:31 <Cale> But it's okay for words in different contexts to have different definitions
02:58:49 <jle`> dmi3on: i can summarize what we said here :)  haskell is: simple.  expressive type system that ensures program correctness to surprising degrees.  many practical real world applications.  easier to reason about anything when you are programming, and be correct.
02:58:57 <augur> and more to the point, even if you accept that definition, it ends up being highly dependent on how you interpret the language
02:58:57 <Cale> In English :)
02:59:13 <augur> Cale: for instance, by that definition, C is referentially transparent. given the right understanding of C.
02:59:25 <jle`> dmi3on: oh, and writing programs is easy because the types basically write them for you :)
02:59:49 <jle`> dmi3on: i think a lot of those other things you wrote are commonly passed around, but i don't think they are too correct or relevant or useful
02:59:49 <Cale> augur: Well, if you give it the right sort of semantics which I don't think anyone has even attempted doing.
03:00:06 <augur> Cale: forget semantics, just deal with the manifest portions of C
03:00:20 <augur> Cale: ill give you a canonical example, right
03:00:27 <Cale> You need to know when two expressions have the same value
03:00:36 <augur> int square(int x) { return x * x; }
03:00:38 <Cale> But that means you need to be able to interpret them
03:00:45 <Cale> But C has no such interpretation
03:00:49 <augur> square(rand()) != rand() * rand()
03:00:50 <augur> right?
03:00:55 <Cale> It could have one
03:00:55 <mgomezch> referential transparency is not about two expressions being equal.  that’s not what the concept tries to address.
03:01:02 <Cale> But nobody's done it
03:01:02 <jle`> dmi3on: i'll also add one other major benefit of haskell: maintainability.  imagine working on a Java or Python project, dropping it for a few months, and then picking it back up later.
03:01:05 <augur> Cale: and people say "aha! see? C isn't RT!"
03:01:07 <mgomezch> that’s what denotational semantics tries to address.
03:01:26 <jle`> dmi3on: i would be afraid of touching *anything*.  any small change i amke could break something huge, and i would have no idea any more how to fix it
03:01:36 <augur> Cale: but that's not true at all. it's only true if you think that function application in C works by substitution, which of course it doesnt. therefore the conclusion that C is not RT is unjustified
03:01:42 <jle`> dmi3on: not so, in haskell.  in haskell, you can make changes to your old legacy program...and *instantly* be sure that things still work and are correct
03:01:47 <dmi3on> jle`: i do, many time i dont recognize my code, even hand notes sometimes
03:01:54 <dmi3on> time*
03:01:57 <jle`> you can do huge refactorings on old, old code
03:02:00 <augur> C's function application is like everywhere-always-already-monadic-application
03:02:01 <jle`> or even small things
03:02:02 <slyfox> Hi folks! I'm reading Ross's "Arrows and computations". Got to exercise 2 which suggests that 'newtype ListMap i o = LM ([i] -> [o]' is _almost_ an arrow type. Why almost? I've implemented simplistic arrow instance for it and fail to break arrows' laws.
03:02:06 <dmj`> dmi3on: types make large sweeping code base changes easy. What jle` says
03:02:26 <augur> there is literally no example in C that proves the language is not RT
03:02:26 <Cale> augur: The problem has nothing to do with the interaction between rand and square. It has to do with what value rand() has in the first place.
03:02:34 <jle`> dmi3on: the types give you a guideline to what goes where...and you can feel free to change things and be sure that nothing breaks
03:02:38 <jle`> and that it does what you want
03:02:38 <dmi3on> this is very cool, i guess what i will be able to learn i end up writing better code heh
03:02:51 <jle`> and some remort part of your program doesn't break surprisingly
03:02:56 <augur> Cale: it has a computation value, just like it does in haskell
03:03:03 <dmi3on> its like learning go and then by default chess skill impove :)
03:03:05 <jle`> dmi3on: this is hard to obtain in other languages besides haskell :)
03:03:25 <Cale> augur: If you take the value of rand() to be any one of its computed results, then you'll go wrong almost immediately.
03:03:26 <jle`> you'll get some benefits, but...it's really hard to get all of thise awesome stuff in most other languages
03:03:31 <augur> Cale: sure
03:03:35 <augur> Cale: so dont do that!
03:03:40 <augur> Cale: the same is true of haskell
03:03:47 <mgomezch> Cale: there is no «the value of rand()».  that concept makes no sense in C.
03:03:52 <augur> if you take the value of `get' to be any one of its computed results ...
03:03:56 <jle`> dmi3on: so for the most part, all of these things are benefits of the *language*.  not necessarily the thought that the language encourages
03:04:01 <augur> well ok sure, unsafePerformIO get :: String
03:04:13 <augur> but thats no reason to say haskell isn't RT now is it
03:04:20 <dmi3on> jle`: this part is exactly for me, because i am never statified how my code or other code is written or some times i just dont like how it looks and then find issues
03:04:21 <Cale> augur: But in order to make the claim that C is referentially transparent, per the definition that I use, you need to be able to assign a value to each expression.
03:04:32 <mgomezch> Cale: «rand()» in C is a C expression.  it does not denote a value.  it denotes a computation.
03:04:39 <augur> Cale: sure. assign denotations in the IO monad. problem solved.
03:04:46 <Cale> augur: In such a way that substitution of any two expressions with the same value won't affect the behaviour of the resulting program.
03:04:50 <jle`> dmi3on: you might be able to take some parts of the thought to other languages.  but most of what we are describing here cannot be applied to other languages meaningfully
03:04:51 <slyfox> jle`: how about bugs like "updated ghc and subtly broke darcs"? :]
03:04:56 <Cale> augur: Right, almost.
03:05:14 <jle`> slyfox: oh look it's time for bed :D
03:05:15 <Cale> augur: Apart from the hundreds of problems with that :)
03:05:20 <jle`> good night all :D
03:05:29 <augur> Cale: well, C is an ugly language and its hard to actually give it a semantics
03:05:36 <Cale> yes
03:05:42 <augur> Cale: but thats tangential. we can imagine a minimal LC + IO
03:05:56 <Cale> Yeah, I'd be totally okay with that
03:05:59 <augur> or any minimal langauge to make the point
03:06:19 <mgomezch> nonetheless, you do not write the denotational semantics of C by giving values to expressions.  expressions do not denote values in C, as in members of simple types.  expressions denote computations.
03:06:22 <Cale> Evaluation of expressions of type IO t is referentially transparent, after all
03:06:39 <augur> Cale: exactly, just like evaluation of C is
03:06:47 <augur> but C doesnt use evaluation for nearly anything at all
03:06:57 <Cale> Well, but not what C calls "evaluation"
03:07:06 <Cale> right
03:07:35 <dmi3on> thats it i am even more motivated to learn, but i looks like i need to do a bit reading before i start any coding
03:07:56 <augur> another canonical example is variable assignment, but that's also problematic
03:08:03 <dmi3on> I am going to use emacs for IDE or should i use vim ?
03:08:16 <augur> RT in the philosophical logic/philosophy of language sense is the right sense to use
03:08:17 <jle`> dmi3on: happy haskelling :D  either emacs or vim is fine
03:08:31 <jle`> i use vim but plenty of people use all sorts editors
03:08:43 <augur> the other concepts that sondergaard and whoever discuss deserve to have their own names
03:08:59 <mgomezch> re: evaluation of C: http://conal.net/blog/posts/the-c-language-is-purely-functional
03:09:05 <Cale> "the right sense"
03:09:06 <Cale> lol
03:09:07 <dmi3on> i <3 emacs :)
03:09:11 <augur> Cale: :)
03:09:16 <Cale> So opinionated
03:09:17 <augur> Cale: hey, we invented it. its our term!
03:09:19 <dmi3on> jle`: thank's !
03:09:32 <augur> Cale: but no i mean, strachey was explicitly trying to use Quine's concept, right
03:09:35 <augur> Cale: he just botched it
03:09:50 <augur> the _intention_ was always to mean "whatever Quine meant"
03:10:02 <augur> the problem is that Strachey's paraphrase did not, in fact, mean what Quine meant
03:10:05 <augur> even tho he thought it did
03:10:15 <mgomezch> and then everyone else paraphrased that
03:10:19 <mgomezch> and so on
03:10:24 <Cale> Well, okay
03:10:37 <augur> so even by the intentions of the first CSer to use it, the Quinean definition is the right one
03:10:42 <Cale> I think the definition in terms of a choice of denotational semantics is more straightforward.
03:11:15 <augur> thats more or less Quine's definition, but Quine was precise
03:11:16 <dmi3on> Thank you everyone for so much help !!! will be back soon with lots of questions :)
03:11:25 <jle`> well, if a word has such different meanings based on the context, pragmatically, i would just avoid using it if i could and either invent a new one or switch to one that is, for the time being, less embroiled in such problems
03:11:27 <augur> because you cant simply say, Cale, "substitute equals for equals"
03:11:36 <Cale> Why can't you?
03:11:42 <dmi3on> I wish math chanel was so friendly i would be already mathematician lol
03:11:56 <Cale> dmi3on: If ##math is ever not friendly, let me know
03:12:09 <jle`> dmi3on: :P  btw, if #haskell is too busy sometimes, you can always hop onto #haskell-beginners as well
03:12:10 <augur> Cale: Quine's definition is as follows:   a context K{_} is referentially transparent iff for all x, x' such that [[x]] = [[x']], it holds that [[K{x}]] = [[K{x'}]]
03:12:15 <Cale> dmi3on: I can't always keep an eye on it, but I have ops there
03:12:43 <augur> Cale: note crucially that RT is a property of contexts, firstly, and secondly that its defined in terms of relating syntax to semantics
03:12:56 <mgomezch> note that referential transparency is said of a *context*, not of a language
03:13:00 <dmi3on> Cale: in a good way not friendly :)
03:13:57 <augur> Cale: once you're precise like this, you also run into deeper questions like, how does [[_]] work, exactly? for languages with variables, for instance, denotations are non-trivial
03:14:05 <Cale> augur: Well, it's easy enough to extend that to languages that define expressions by insisting that it hold for any expression context.
03:14:12 <augur> typically you have something like   [[M]] : Env -> Val
03:14:23 <augur> yes, i agree Cale!
03:14:25 <dmi3on> jle`: got it :)
03:14:27 <augur> but then haskell isnt RT :)
03:14:42 <Cale> Oh?
03:14:55 <Cale> Are you going to complain about do-notation?
03:14:59 <augur> no
03:15:03 <augur> Cale: we can agree that [[x]] = [[x]], yes?
03:15:08 <Cale> (and fail)
03:15:17 <Cale> yes, that ought to hold
03:16:03 <augur> Cale: now: what is the denotation of `x' as a top-level variable?
03:16:05 <augur> its undefined
03:16:15 <augur> or, under Tarskian semantics, its anything at all
03:16:19 <augur> take your pick, really
03:16:27 <augur> [[x]] : Val -> Val
03:16:29 <Cale> hm?
03:16:33 <augur> > x
03:16:34 <lambdabot>  x
03:16:38 <Cale> :D
03:16:41 <augur> right
03:16:49 <augur> now: if [[x]] = undefined
03:17:10 <augur> now consider the context K{_} = `let x = 5 in _'
03:17:11 <Cale> [[x]] = "id"
03:17:13 <Cale> (sort of)
03:17:14 <Eliel> edlinde: I visualize the difference between binding and assignment like this. Binding: I have an apple and I decide to name it wuffie. The apple is now named wuffie. End of story. Assignment: I have an apple, I put it in a box and name the _box_ wuffie. The Apple is now in a box named wuffie. I can take it out and put something else in if I want to and the box will still be named wuffie.
03:17:50 <Cale> Rather, it's the function which maps an environment containing x to the value of x in that environment, no?
03:17:50 <augur> Cale: if [[x]] = undefined, then `let x = 5 in x' = `let x = 5 in undefined'
03:18:21 <Cale> I don't agree that [[x]] = undefined
03:18:27 <augur> thats fine
03:18:39 * hackagebot JuicyPixels 3.1.7.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.7.1 (VincentBerthoux)
03:18:40 <augur> my real point was to bring out the subtlety of the issue
03:18:48 <augur> what counts as a denotation is non-trivial
03:18:51 <Cale> I don't understand how this is subtle
03:18:58 <Eliel> edlinde: to express it in a shorter way. In assignment, you name the container. In binding, you name the value itself.
03:19:20 <Cale> If you screw up about free and bound variables, your interpreter doesn't work
03:19:22 <edlinde> Eliel: thanks
03:19:23 <augur> Cale: its subtle in that most people dont think like this. most people dont say "we have to define the denotations in this way"
03:20:19 <augur> so as a result, they use naive concepts like [[the capital of scotland]] = edinburgh
03:20:32 <augur> and not, say,   [[t.c.o.s.]] = \t -> ...
03:20:35 <augur> where t is a time
03:20:48 <augur> or whatever other alternatives you want to use
03:21:14 <Cale> I suppose most of the time we don't even really talk so much about denotations of expressions with free variables in them, but instead implicitly close over the bindings in whatever scope where we're making substitutions.
03:21:27 <mgomezch> yes, we do!
03:21:27 <augur> but, as soon as you admit that you have to _define_ [[_]], you lose the ability to talk about non-RT languages, because (modulo crappiness of the language) you can always give a denotational semantics
03:21:40 <mgomezch> but then we are not using contexts which are referentially transparent.
03:21:51 <mgomezch> because we need to close over the bindings in scope at that context.
03:22:10 <augur> Cale: but if you dont like that example, i can give you a _real_ clincher about haskell :)
03:22:21 <augur> Cale: 1 + 1 = 2, yes?
03:22:42 <augur> so take K{_} = "_", so now "1 + 1" = "2"
03:22:43 <Cale> augur: Only if the instance of Num is any good
03:22:44 <augur> obviously false
03:22:51 <augur> Cale: ;)
03:23:10 <augur> now you might want to say "hey no fair using quotation marks!"
03:23:22 <augur> but quotation was one of quines original examples!
03:23:25 <Cale> If we fix a scope, it's possible to simplify the semantics from being a function of the values of free variables used within that scope by simply applying that function to their values.
03:23:36 <augur> and i languages with code quoting, its obviously relevant
03:23:59 <augur> take lisp. (+ 1 1) = 2   but   (quote (+ 1 1)) /= (quote 2)
03:24:04 <Cale> augur: Obviously false, unless you have a shitty instance of IsString
03:24:11 <augur> Cale: :p
03:24:18 <augur> Cale: assume non-shitty instances
03:24:24 <mgomezch> I’d say string literals are not an useful example since what’s inside of them isn’t exactly objects of the language.
03:24:36 <mgomezch> but yeah, for code quotation, good example
03:24:39 <augur> Cale: but if you accept that 1 + 1 = 2, and "1 + 1" /= "2", then haskell cant be RT
03:24:52 <Cale> Obviously nobody's making claims that substitution is an operation at the level of concrete syntax
03:25:08 <mgomezch> an equivalent argument can be made about TH.
03:25:34 <augur> Cale: of course, but the notion of "context" is defined, at least in the Quinean sense, to include such things
03:25:35 <mgomezch> I do think the previous example is more helpful.
03:25:48 <Cale> I'm not sure that's terribly helpful
03:26:02 <Cale> I mean, to include strings in that way
03:26:09 <mgomezch> (the one with «let x = 5 in _», I mean)
03:26:11 <augur> Cale: its more relevant to natural language, of course, because we use quotes to do what lisp uses quote to do
03:26:16 <Cale> We're talking about expression contexts
03:26:37 <augur> Cale: sure. another subtlety, however
03:27:01 <Cale> But... is this nitpicking actually useful to anyone? The caveats here should be obvious, I think?
03:27:27 <Cale> I mean, maybe I can't really judge. They're obvious to me, but I'm not exactly unbiased.
03:27:39 <augur> "should be" and "are" are different things
03:27:42 <Cale> Obvious to anyone who has ever written an interpreter for a functional language, say.
03:27:58 <augur> well ok but thats not most people :)
03:28:10 <Cale> Really? What do you people do all day?
03:28:13 <Cale> :D
03:28:15 <augur> :)
03:28:27 <eikke__> sleep with my eyes open
03:28:29 <augur> Cale: also, consider languages like ruby, with interpolation.   "#{1 + 1}" = "#{2}"
03:28:40 <augur> Cale: you want to ban strings, and yet!
03:28:59 <augur> a language with interpolation has to treat strings as non-trivially atomic
03:29:10 <Cale> Yeah, there's an expression context *immediately outside* the quotes
03:29:20 <Cale> and so you need to be careful then
03:29:26 <augur> of course, a smart design would actually parse "x #{1 + 1} y" as sugar for, say,  "x " ++ (1 + 1) ++ " y"
03:30:00 <augur> but these are all subtleties that a naive "substitute equals for equals" approach can easily run afoul of
03:30:47 <augur> im not saying there isnt sense to be made, just that the concept has to be properly studied, and the "subst eqs for eqs" mantra is woefully insufficient
03:30:57 <augur> (as study, i mean)
03:31:00 <mgomezch> «substitute equals for equals assuming no template haskell and with proper renaming», perhaps
03:31:04 <Cale> Still, none of these are examples of things which someone reasonable would screw up
03:31:56 <mgomezch> Cale: it depends on the definition of «someone reasonable» of course, but lexical scoping was not always obvious, even to some who most of us would deem reasonable!
03:32:01 * dramforever suddenly felt that "(|" and "|)" are better called _bow brackets_
03:32:01 <Cale> Maybe someone writing a tool for operating on Haskell source who is a bit confused about the structure of the trees
03:32:27 <dramforever> Regular "(" and ")" already look like bananas
03:32:28 <augur> Cale: you're talking about professionals tho. im talking about average programmers
03:32:32 <Cale> dramforever: b..but bananas are tasty
03:32:50 <dramforever> and bows + arrows -> great weapon
03:32:50 <augur> Cale: the average programmer isnt going to screw these things up because they're not going to be doing this at all
03:33:03 <dramforever> Cale, ( and ) are bananas
03:33:15 <augur> Cale: also, another issue arises in the notion of equality, which is backgrounded in every discussion of RT ive seen
03:33:30 <Cale> augur: The people who are applying the concept of "referential transparency" to whatever it is they're doing, have to have some level of sophistication, I'd expect.
03:33:32 <augur> Cale: we presupposed statements like [[x]] = [[x']], but what is = here?
03:33:40 * hackagebot robots-txt 0.4.1.1 - Parser for robots.txt  http://hackage.haskell.org/package/robots-txt-0.4.1.1 (MarkWotton)
03:33:57 <augur> Cale: oh they definitely dont, trust me. ive read enough reddit to know that they dont. :p
03:33:57 <Cale> I mean, sure, you have to consider the audience
03:34:01 <Cale> heh
03:34:03 <Cale> okay!
03:34:07 <dramforever> Cale, like when they hit monomorphism restrictions they blame it on refrential transparency?
03:34:13 <augur> Cale: but, consider the old fregean origin of this
03:34:26 <augur> Cale: would you say this is true?  [[Hesperus]] = [[Phosphorus]] ?
03:34:36 <Cale> Maybe I haven't read enough reddit. Most of the people who are clueless never seem to be the same ones talking about referential transparency.
03:34:44 <augur> or if you're not into greek names,   [[the morning star]] = [[the evening star]]
03:35:03 <Cale> augur: It obviously depends on the definition of the interpretation brackets
03:35:12 <augur> yes, indeed
03:35:21 <augur> but it also depends on the definition of equality
03:35:29 <Cale> Yeah, sure
03:35:33 <augur> suppose you take a standard possible worlds semantics
03:35:43 <augur> so that [[H]], [[P]] : World -> Entity
03:35:51 <mgomezch> does *anything* in cs not boil down to something frege once worked on?
03:35:59 <Cale> and possibly lots of other aspects of your logic, once you unfold the definition of the interpretation
03:36:09 <augur> now, you might want to say [[H]] = [[P]] is just function equality, right?
03:36:21 <Cale> wtf is a standard possible worlds semantics?
03:36:39 <augur> Cale: more or less Kripke semantics for modal logic
03:36:42 <Guest30842> as opposed to the standard impossible semantics
03:37:06 <bennofs> Is there a nice way to write a function to convert hypen-separated to camelCase ?
03:37:12 <augur> Cale: denotations are parameterized by a "world", to handle sentences like "could", "might", etc.
03:37:13 <Cale> But sure, if you're going to say that the denotation of each is a function, I would demand that you use function equality. Otherwise, you should be using equivalence classes of functions or something.
03:37:28 <bennofs> I've only been able to write it as a foldr with a Bool indicating whether to upcase the next character or not
03:37:31 <augur> Cale: ok, so you say it should be function equality
03:37:39 <Cale> and the only reason I would demand that is just so as not to be needlessly confusing in how you're communicating ideas mathematically
03:37:47 <augur> Cale: but, there is a HUGE literature that argues function equality is just wrong wrong wrong
03:38:02 <Cale> So, use some other objects whose equality behaves properly?
03:38:24 <augur> Cale: instead they define equality of that type as something like   [[H]] = [[P]] iff  forall w : World, [[H]](w) ~ [[P]](w)
03:38:31 <augur> where ~ is some kind of counterpart relation
03:38:42 <Cale> That's kind of a shitty thing to do
03:38:47 <augur> but its necessary
03:38:53 <augur> at least for natural language
03:39:11 <Cale> Well, okay, perhaps it's not so bad
03:39:19 <augur> Cale: consider sentences like "If I were you, ..."
03:39:26 <augur> i mean, what does that even mean?
03:39:28 <augur> if i were you
03:39:34 <Cale> What you're doing is defining [[H]] to be an equivalence class of functions
03:39:39 <augur> or "If I had been born in the roman empire, ..."
03:39:39 <Cale> under the relation ~
03:39:49 <augur> or even!
03:39:53 <Cale> and its those equivalence classes which are being asserted to be equal
03:39:54 <augur> "If I had never been born, ..."
03:40:07 <augur> partial denotations!
03:40:14 <Cale> But then [[H]](w) is shitty notation
03:40:22 <osfameron> bennofs: split on '-', map uc of first chat, join all together?
03:40:26 <osfameron> *char
03:40:27 <augur> yes, you'd want to refine it for partiality
03:40:46 <bennofs> osfameron: oh, that's a nice idea. didn't think of that, thanks!
03:40:48 <augur> Cale: my point is tho, these are all veeeery subtle issues in the philosophy of language (which fortunately never arise in PLT)
03:41:05 <augur> Cale: kripke has a whole book on this, fwiw. Naming and Necessity
03:41:24 <augur> i dont know if he goes into counterpart theory, etc. but it deals with some of this stuff
03:41:34 <augur> its a very interesting issue
03:42:03 <Cale> But they kind of arise in PLT. The generic setting is just picking some class of mathematical objects to serve as interpretations for the things in some language, in some way that the interpretations correspond *somehow* to the manner in which the language is built up.
03:42:31 <Cale> It doesn't matter if these mathematical objects are functions or equivalence classes of topological spaces, or what
03:42:36 <augur> Cale: sure. i think once you're really precise about denotations, the concept of RTness ceases to be useful in PLT
03:42:36 <bennofs> osfameron: using Data.Text, I can even do: T.filter (== '-') . T.toTitle
03:42:44 <augur> Cale: because you can more or less always make every language RT
03:42:58 <Cale> augur: The important thing is whether or not you have done this
03:43:04 <augur> Cale: eg in the [[rand()]] : IO Int way
03:43:14 <augur> oh no, who actually does this for PLs? almost no one :)
03:43:21 <Cale> augur: Nobody has done this in an even halfway adequate way for C
03:43:34 <Cale> It's at least remotely doable for Haskell, and was done for early versions.
03:43:38 <augur> Cale: just make everything an IO denotation! 8D
03:43:42 * hackagebot xml-html-conduit-lens 0.3.2.1 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.1 (MatveyAksenov)
03:44:09 <osfameron> bennofs: that doesn't sound right.  doesn't that just give you the T.toTitle "-----"  ?
03:44:11 <augur> Cale: also cheekily, you might be able to take the initial model, which ought to be just C programs themselves :)
03:44:31 <bennofs> osfameron: oops, s|==|/= :)
03:44:41 <Cale> augur: Yeah, you could just take the denotation of any expression to be that expression.
03:44:42 <osfameron> bennofs: something like T.splitOn("-") surely?
03:45:01 <osfameron> bennofs: ok.  but then "foo-bar-baz" would give you "Foobarbaz" ?
03:45:06 <augur> Cale: at least, for the LC, the initial model is the (alpha-beta-eta equivalent) terms of the LC itself
03:45:14 <augur> which sort of deflates the whole thing
03:45:16 <Cale> augur: But when people make claims like this, there's an implicit understanding that there's a useful denotational semantics.
03:45:18 <bennofs> osfameron: no, toTile upcases everything following a non-letter+
03:45:43 <osfameron> ah! cunning
03:45:47 <osfameron> simples, then
03:45:47 <augur> Cale: sure. but now you're being rather cruel. you asked for _a_ denotation!
03:45:57 <augur> no fair changing the rules after you lose! ;)
03:46:35 <Cale> augur: But nobody was talking about the not-so-useful denotations, you're the one who brought them up
03:46:39 <augur> Cale: but probably regarding C, you could do the (honestly quite awful) "function from the world to the world" thing that people say about IO
03:46:51 <Cale> Including the people who probably haven't thought very hard about it
03:46:58 <bennofs> osfameron: hmm, that also changes the case of pt
03:47:06 <bennofs> osfameron: that also lowercases other letters
03:47:09 <Cale> augur: Do you think so?
03:47:11 <augur> Cale: you said we need to give _a_ denotation for C. i gave you one: C itself. thats a denotation.
03:47:13 <Cale> augur: I'd like to see it :)
03:47:16 <osfameron> pt?
03:47:22 <augur> Cale: i suspect so. im not saying definitely, but
03:47:35 <Cale> augur: I'd like to see a useful denotational semantics that let you make some nontrivial algebraic substitutions :)
03:47:40 <osfameron> oh, so you mean "foo-BAR-baz" will become FooBarBaz intead of FooBARBaz ?
03:47:59 <Cale> augur: Bonus points if your denotation works in the face of threads
03:47:59 <augur> Cale: i reject your demand for non-trivial algebraic substitutions :)
03:48:05 <bennofs> osfameron: yes, so I'll need to use the split approach :)
03:48:42 <Cale> augur: After all, when people say stuff like "expression evaluation in Haskell is referentially transparent", what are they really talking about?
03:49:08 <Cale> augur: They're talking about the ability to make nontrivial algebraic substitutions to simplify and refactor programs.
03:49:13 <augur> Cale: something different from "evaluation in C"
03:49:37 <Cale> If you want to define a semantics for C which lets you do that, go ahead, I'd love to see it :D
03:49:39 <augur> Cale: C does not have evaluation, nor substitution (of any substance), so its unfair to demand it
03:50:04 <Cale> There are certainly substitutions which can be made on C programs which are valid
03:50:19 <Cale> It's just really hard to know what they are, and there are a lot of caveats
03:50:19 <augur> that doesnt mean that C itself has substitution
03:50:23 <augur> it means you the programmer are doing them
03:50:39 <Cale> If someone could come up with a decent denotational semantics, then maybe we could do a better job of that
03:50:46 <augur> but if you the programmer can choose to do "substitutions" then we're right back at the problem of substitution into strings in Haskell
03:50:51 <augur> because, hey, I can do it, right?
03:50:57 <Cale> I don't think anyone claims that this is totally impossible
03:51:12 <Cale> It just seems very very hard.
03:51:16 <augur> im sure it is
03:51:29 <augur> but again, look at all the side conditions you have to add on to this
03:51:32 <no-doz> what are we talking about?
03:51:35 <augur> you're not longer asking "show me a denotational semantics"
03:51:48 <augur> you're saying "show me a denotational semantics that has properties X, Y, Z, ..."
03:51:56 <Cale> augur: I'm just clarifying the side conditions which are obvious to apparently everyone but you :)
03:52:02 <augur> and now we're far afield from the requirements of boring referential transparency
03:52:09 <augur> Cale: are they?
03:52:14 <Cale> I think so!
03:52:31 <augur> show me one text on referential transparency that has discussed things in as much detail as we just have
03:52:32 * osfameron doesn't see who Cale is talking to... wonder if I have them on /ignore...
03:52:42 <Cale> Or at least they would be, only I don't know if anyone else is even following this discussion though :(
03:52:47 <augur> where they take it as obvious that these additions are relevant
03:52:47 <Cale> osfameron: augue
03:52:49 <Cale> augur*
03:53:28 <osfameron> augu*r* ?  I have on ignore, possibly a bad nick from another chan in the past
03:53:38 <Cale> augur: Most contexts about Haskell that make claims about referential transparency are taking these caveats about the semantics as implicit.
03:53:41 <augur> Cale: ive never seen a paper on RT that actually goes to the length of getting down into the logic of things
03:53:57 <augur> Cale: perhaps. but im skeptical of this
03:54:23 <augur> i suspect more likely that people are just using an unrefined notion of RT, together with a huge helping of lore
03:54:45 <Cale> It's not useful to say that anything about Haskell is referentially transparent if you're going to pick a crap semantics which doesn't let you make any interesting substitutions.
03:54:51 <osfameron> aha.  this makes much more sense now :-)
03:55:12 <Cale> So you just wouldn't say it, unless you had one
03:55:33 <augur> Cale: maybe you wouldnt, but people say all sorts of things
03:55:54 <Cale> There's an interpretation of C expressions such that C is referentially transparent, but there isn't a known useful one.
03:55:56 <augur> this is why i think its so important to be extremely clear on these subjects, because i see it _all_ the time when people discuss RT
03:56:32 <augur> Cale: sure, but so what? it only matters if you demand that referential transparency is useful to you!
03:56:41 <augur> Cale: yes, C is referentially transparent. and useless so. so what?
03:57:03 <augur> the same is true of any haskell program inside the IO monad
03:57:18 <augur> if we were all forced to program inside IO all the time, we'd be unable to use RT for anything useful
03:57:29 <Cale> The ways in which IO expressions are referentially transparent is still useful!
03:57:30 <augur> so what? that just means RT isnt useful in that setting
03:57:36 <Cale> It's perhaps not *as* useful as we'd like
03:57:41 <augur> Cale: not if _everything_ is in IO
03:57:47 <Cale> Eh, even so
03:57:51 <augur> example?
03:57:55 <Cale> You have the monad laws (at least more or less)
03:58:01 <Cale> which let you do lots of refactorings
03:58:19 <Cale> Associativity lets you pull out repeated blocks into definitions
03:58:26 <augur> i wonder to what extent you can do those refactorings in C
03:58:38 <Cale> Yeah, it's more tricky to justify them in C
03:58:42 <augur> can you construct a minimal example where they work in Haskell but not in C?
03:58:43 * hackagebot haroonga 0.1.5.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.5.0 (cosmo0920)
03:59:37 <augur> also we should totally do a reading group on the history of RT in philosophy of language. i bet it'd be very fun
03:59:45 <Cale> I'm not confident enough that I won't just write something which is undefined per the C standard to do that
04:00:03 <augur> well what is an example in haskell that you have in mind
04:00:05 <augur> we can work from there :p
04:00:07 <Cale> I honestly could not care any less about the philosophy of language
04:00:17 <augur> aww. but its interesting! :(
04:00:54 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation#The_monad_laws
04:01:04 <Cale> Look under 3. in the version with do notation
04:01:41 <augur> you mean something like  do { w <- return v; f w } = do { f v }
04:01:41 <Cale> The version on the 'left' of the = sign there is in a form where we can pull out the inner do-block and put it in its own definition.
04:01:52 <Cale> That's 1.
04:01:58 <Cale> a little below that
04:01:59 <Cale> but yeah
04:02:01 <Cale> things like that
04:02:07 <augur> oh sorry, i saw the wrong numbers :)
04:02:26 <augur> these are really tricky to translate to C precisely because they rely on function application
04:02:28 <augur> which C doesnt have
04:02:43 <Cale> The: do w <- do { v <- x ; f v } ; g w
04:02:58 <Cale> Is in a form which lets us pull out  do { v <- x ; f v }  into its own definition
04:03:33 <augur> the closest thing in C is something like...   C's   f(x) ~ f `ap` x or whatever
04:03:39 <Cale> So if we started with  do v <- x; w <- f v; g w
04:04:03 <Cale> and then used associativity to expose that chunk, and factored it out, we could be sure that we hadn't changed the meaning of the program
04:04:13 <Cale> while in C, similar refactorings have a bunch of issues
04:04:24 <augur> lets suppose that we translate f(x) in C into do { x' <- x ; f x }
04:04:34 <augur> would that be a fair translation do you think?
04:04:38 <Cale> Especially if you're not careful about return and break, but I think using those as an example is a bit of a cop-out
04:05:05 <augur> well yes, but this is why i keep bringing up application, because you cant just translate, say, the return one naively
04:05:24 <Cale> Every definition in C is implicitly wrapped in callCC
04:05:26 <Cale> :D
04:05:43 <augur> the example (1) there is not analogous to the C program  "w = v; f(w)" / "f(v)"
04:05:47 <augur> right
04:06:00 <augur> actually that might be analogous by accident, who knows
04:06:15 <Cale> Also, I'm not sure about the extent to which it's okay to screw around with the memory for the stack in C
04:06:27 <Cale> according to the C spec
04:06:38 <Cale> But possibly if we did some of that, we could break it
04:06:39 <augur> but my point is, f(x) in C is not the same thing as f x in haskell
04:06:54 <augur> f(x) ~ f `ap` x
04:07:00 <augur> and f x has no C analog
04:07:03 <Cale> Well, sure
04:07:26 <augur> so on the face of it, we'd need to invent a C analog before we can talk about validity of the equations
04:07:35 <Cale> The practical refactoring which this rule allows in Haskell has an analogue in C, which is done, but it's hard to justify
04:07:39 <augur> we could do this tho, i think. i dont think it'd be too excessive
04:08:09 <augur> i think it would be ok to define a new C construct f x which really does mean "do beta reduction on the definition of f"
04:08:13 <Cale> People take chunks of C procedures and rip them out and define new procedures all the time
04:08:23 <augur> and then f(x) is actually sugar in C for something like   w = x; f x
04:08:30 <Cale> But when they do it, they must be really careful
04:08:40 <Cale> More careful than the Haskell programmers have to be
04:08:47 <augur> yeah
04:08:50 <augur> definitely true
04:09:40 <augur> i think the main problem there is the silence of IO in C
04:10:08 <augur> haskell's type discipline lets you actually state your effects in the types, so youll get type errors if you try to refactor wrongly
04:13:56 <Cale> augur: But yeah, with all that said, I will say one thing on your side: I think we should be more careful to avoid buzzwords and marketing speak in explaining Haskell to others.
04:14:13 <augur> Cale: :)
04:14:15 <augur> thats all i ask!
04:14:25 <augur> that, and people reading philosophy of language :x
04:14:27 <Cale> augur: I'm just not willing to go so far as to intentionally misunderstand people :D
04:14:55 <augur> Cale: well, i try to give people the benefit of the doubt, but i also try to elaborate as much as possible on the nuances
04:15:17 <Cale> But yeah, there's too much marketing lately. Let the language live or die on natural selection, screw marketing.
04:15:31 <augur> i try not to say "no you're wrong, end of convo" but more "thats not quite right, on the face of it. <10 paragraphs more>"
04:15:58 <augur> Cale: lets read the quine paper!
04:16:06 <Cale> There's way too much "Haskell is super great" and not enough "Avoid success at all costs" these days
04:16:33 <augur> im honestly convinced that there could be some really interesting stuff to say about RT in PLT, due to things like code quoting, interpolation, etc.
04:16:47 <augur> i bet there are other interesting possibilities too
04:16:54 <Cale> augur: I mostly like to avoid those things as much as possible
04:16:57 <Cale> heh
04:16:58 <doismellburning> Cale: "avoid success at all costs"?
04:16:58 <augur> TH as mentioned earlier
04:17:05 <trap_exit> anyone awake?
04:17:10 <trap_exit> so I have a function a -> [a]
04:17:21 <augur> doismellburning: thats SPJs description of the goal of haskell
04:17:23 <trap_exit> and I know I'm supposed ot use the Writer + List monads, but I'm not sure how to fit this all together
04:17:25 <trap_exit> I have a function a -> [a]
04:17:28 <trap_exit> and I want to do a -> [[a]]
04:17:42 <trap_exit> where it basically involves calling this functino 10 times inside a List monad and logging all the intermediate states
04:18:02 <doismellburning> trap_exit: do you really mean `a -> [a]` or did you skip something?
04:18:10 <trap_exit> so suppose my functino was (i -> [2*i, 2*i+1])
04:18:32 <trap_exit> then my output, oninput "0", should be [ [0], [0,1], [0, 1, 2, 3], [0, 1, 2, 3, 4, 5, 6, 7, 8]]
04:18:38 <augur> Cale: why do you avoid quoting/interpolation?
04:18:40 <trap_exit> so I'm running thi sinside a list monad, and I call my functno 3 times
04:18:41 <doismellburning> trap_exit: so `Num a => a => [a]` you mean?
04:18:41 <Cale> doismellburning: It's a half-joking nod to the fact that popular languages become stuck in a quagmire of users who don't want anything to change, and so fail to improve the things which everyone knows could be better.
04:18:47 <doismellburning> Cale: ah
04:18:48 <trap_exit> but I want to log all the intermediate lists
04:19:03 <trap_exit> doismellburning: the Num part is irreletant, I need this to work for a -> [a] in general
04:19:14 <jle`> the default Monad instance for List doesn't really do "logging", but you can use iterate
04:19:29 <trap_exit> jle`: that is why I said List + Writer
04:19:43 <trap_exit> jle`: englitehn me
04:19:53 <trap_exit> > :t iterate
04:19:55 <lambdabot>  <hint>:1:1: parse error on input ‘:’
04:20:03 * trap_exit pokes lambdabot with a stick
04:20:08 <augur> :t iterate
04:20:09 <lambdabot> (a -> a) -> a -> [a]
04:20:18 <jle`> > let f i = [2 * i, 2 * i + 1] in iterate (>>= f) [1]
04:20:19 <lambdabot>  [[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15],[16,17,18,19,20,21,22,23,24,25,...
04:20:20 <augur> trap_exit: > is for evaluation, : is for meta commands
04:20:33 <jle`> oops
04:20:36 <jle`> > let f i = [2 * i, 2 * i + 1] in iterate (>>= f) [0]
04:20:38 <lambdabot>  [[0],[0,1],[0,1,2,3],[0,1,2,3,4,5,6,7],[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,1...
04:20:52 <trap_exit> whoa, the slicing and (>>= f)
04:20:52 <trap_exit> this is magic
04:20:55 <jle`> maybe (return 0) is better in this case
04:20:59 <jle`> becase then
04:21:00 <trap_exit> is haskell inferring to use the List monad ?
04:21:05 <Cale> I'd personally almost always take a language with a relatively small community where people care about improving the language itself, over a stagnant language with a gigantic community, that's why I'm here in the first place.
04:21:09 <jle`> :t \f x -> iterate (>>= f) (return x)
04:21:10 <lambdabot> Monad m => (a -> m a) -> a -> [m a]
04:21:13 <trap_exit> so haskell looks at this and is like "f :: Num a => a -> [a]"
04:21:15 <augur> Cale: so why no quotes/interpolation?
04:21:25 <trap_exit> which means that the "(>>= f)" should use list monad ?
04:21:25 <augur> Cale: is it the lack of typeliness?
04:21:26 <trap_exit> jle`: is this what's going on?
04:21:28 <jle`> trap_exit: yes.  and also i did [0] as the first value, too
04:21:31 <Cale> augur: In part, yeah
04:21:52 <jle`> but if we generalize to (return x), we actually get a nice and useful generic monad combinator
04:21:57 <trap_exit> wow
04:21:57 <trap_exit> I like this 1 liner
04:21:59 <augur> Cale: pfenning has a nice modal type theory that gives a very good meaning to quoting, and probably can be extended to interpolation
04:22:05 <Cale> augur: and that those things make it awkward to make substitutions and refactor
04:22:08 <jle`> i think there are some libraries that provide this
04:22:13 <jle`> anyways this doesn't involve writer
04:22:29 <Cale> (whether or not there's a technical way that someone has worked out to do it)
04:22:30 <trap_exit> jle`: how long have you been using haskell?
04:22:35 <trap_exit> how do I think of code like this?
04:22:42 <trap_exit> my code would have been atleast 3-4 lines
04:23:03 <augur> Cale: i suspect that his work actually can make it easier to refactor because it really does make sense of things
04:23:03 <jle`> about a year and a half now...and only because i've used iterate several times before :)
04:23:12 <jle`> > iterate (*2) 1
04:23:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:23:30 <jle`> also i've specifically written iterate (>>= f) (return x) multiple times
04:23:32 <jle`> heh
04:23:42 <jle`> but i think there's a library out there that provides it as a utility function
04:23:50 * hackagebot hindent 2.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-2.0 (ChrisDone)
04:23:52 <Eliel> What's the reason Haskell isn't good for writing operating systems?
04:23:58 <augur> Cale: do you have an example of a hard-to-refactor quote example?
04:23:58 <trap_exit> jle`: why did you specifically write "iterate (>>= f) return x" multiple times?
04:24:01 <trap_exit> jle`: was this part of a collection of ahskell exercises?
04:24:05 <augur> too many examples :(
04:24:19 <trap_exit> Eliel: google "House", see garbage collection
04:24:42 <trap_exit> Eliel: http://en.wikipedia.org/wiki/House_(operating_system)
04:24:43 <jle`> trap_exit: because i've needed to "chain f multiple times" a bunch of times
04:24:55 <trap_exit> Eliel: http://stackoverflow.com/questions/6638080/is-there-os-written-in-haskell
04:25:02 <trap_exit> jle`: hmm, this actually makes sense, thanks
04:25:06 <jle`> x >>= f >>= ... (n times) ... >>= f
04:25:09 <jle`> pops up pretty often
04:25:39 <jle`> it's in monad-extras
04:25:41 <jle`> http://hackage.haskell.org/package/monad-extras-0.5.9/docs/Control-Monad-Extra.html
04:25:42 <trap_exit> jle`: I'm hereby downgrading you from magical to smart
04:25:56 <trap_exit> jle`: this is eactly what I needed though, thanks
04:25:58 <jle`> called `iterateM`
04:26:26 <jle`> np :)
04:27:38 <augur> oh Cale, unrelatedly, do you know how to tell ghc to compile a C file together with a haskell lib?
04:27:58 <augur> i know how to do it for one haskell file, but not for a while haskell lib :(
04:28:05 <Cale> hmm
04:28:12 <trap_exit> augur: "man cat"
04:28:15 <trap_exit> I kid I kid :-)
04:28:27 <Cale> What happens when you just give the c file on the commandline and then let the resulting .o file sit there?
04:28:43 <augur> Cale: im not sure what you mean
04:28:53 <Cale> ghc myfile.c
04:29:10 <augur> the problem seems to arise from the fact that i need the haskell file to compile to (multiple???) .o's, and then the C file needs to know about them all
04:29:19 <Cale> oh, hmm
04:29:46 <Cale> I've done very little with foreign exports
04:29:56 <augur> but maybe not, im not entirely sure how this whole ghc thing works, tbh
04:30:05 <nshepperd>  7dxs'
04:30:13 <Cale> Yeah, I would try just using GHC to compile your C program
04:30:19 <augur> well i want to
04:30:20 <Cale> and see if magic happens
04:30:22 <augur> but i dont know how! :)
04:30:45 <augur> im basically writing a C wrapper around a haskell lib, so i need to get the haskell and the C together somehow
04:31:00 <Cale> Well, what errors do you get when you just give the .c file on the commandline to ghc?
04:31:25 <augur> i havent even tried, because i dont know what to do with the Haskell part
04:31:29 <Cale> Maybe if you include all the .hs files on the commandline as well, it'll figure it out
04:31:47 <augur> i mean, i dont think i can _merely_ compile the C, because i need to import haskell junk too
04:32:29 <augur> like... merely having Foo.hs in the dir doesnt make it possible to write "#import Foo" in Foo.c, right
04:33:05 <Odda> Hi, I've loaded a Document from MongoDB, converted it to an aeson Object, how do I get it back to the original type? I can't seem to get my FromJSON to give me a helping hand.
04:33:07 <augur> i think i need to like.. compile the haskell stuff first, to a .o or .a or something? and then somehow include that when i compile the .c
04:33:08 <Cale> right
04:33:24 <augur> but i dont know how to do this
04:33:54 <augur> ghc Foo.c -shared -what-do-i-write-here Foo.a
04:33:55 <augur> ??
04:34:19 <augur> its all very mysterious :(
04:34:42 <augur> i have a .a already, via cabal's build of this, but im not sure what to do with it once ive got it done
04:34:45 <augur> thats the mystery
04:41:32 <burp> given an expression tree like data Expr = Plus [Expr] | Times [Expr] | Log Expr | Symbol String | Rational Int Int, I want to write an evaluation function evalExpr :: [(Symbol,Double)] -> Double (or MPFR). How do you recommend to do this? My naive approach would be to store the (Symbol,Double) pairs in a Map, and perform the evaluation in a Reader monad where I lookup the symbols in the map and insert their values; this seems to be inefficient though.
04:41:32 <burp> Possibly I should write a code generator for it, and compile that code.
04:46:21 <Cale> augur: okay, so I tried, and figured it out
04:46:39 <Cale> augur: You need -no-hs-main or you'll get duplicate symbol errors
04:46:41 <augur> Cale: which part?
04:46:48 <augur> oh, yes, you do need that somewhere
04:46:50 <Cale> augur: let me make an hpaste
04:46:55 <augur> i think when compiling the haskell lib
04:46:58 <Cale> er, lpaste :)
04:47:04 <augur> tho i used cabal to do the lib itself
04:49:08 <mads-> So I have been learning coq, the proof assistant. And I get the feel that I could something somewhat similar in Haskell - like proving stuff. Can anyone tell me if that's true?
04:49:13 <echo-area> Hi, is fromInt non-standard, and is fromIntegral should be used instead in ghc?
04:49:15 <Cale> augur: Here's what I did (not with cabal): http://lpaste.net/110298
04:49:44 <augur> Cale: i agree thats possible
04:49:48 <Cale> mads-: Sort of, except that the logic which Haskell's type system corresponds to is inconsistent, because Haskell has general recursion
04:50:00 <Cale> echo-area: yes
04:50:17 <jle`> burp: what part do you think would make it inefficient?
04:50:23 <Cale> burp: Those both seem like reasonable options
04:50:28 <echo-area> Cale: Thank you.
04:50:45 <augur> Cale: however, thats just one .hs file. im compiling a whole haskell library. which i think means i need to do something else, because there are lots of .o's that are produced
04:51:00 <jle`> burp: also, in this case, i think that Reader is a bit overkill
04:51:06 <Cale> augur: Well, the naive thing would be just to supply all the .hs files at once...
04:51:17 <mads-> Cale: Do you know of a good place to read about it? I feel like I'm hitting a wall when googling it
04:51:28 <augur> Cale: but wont it also produce multiple .o's? then i guess i could provide all those at once too
04:51:34 <Cale> augur: Or compile a haskell library and then do the foreign exports all in one file?
04:51:49 <augur> Cale: thats how i currently have it set up
04:51:59 <augur> i have a main .hs file that exports all the things
04:52:02 <jle`> burp: just change the type signature to evalExpr :: Map Symbol Double -> Expr -> Double, and then write your recursive helper function inside a where clause.  it should have access to the map passed in
04:52:23 <Cale> mads-: Well, in Haskell we have:
04:52:25 <Cale> :t fix
04:52:26 <lambdabot> (a -> a) -> a
04:52:32 <jle`> Reader by itself is rarely worth the effort in practice
04:52:45 <burp> jle`: ok, the map part made me think of efficiency
04:52:47 <Cale> mads-: and that means we can write fix id, which is a "proof of anything"
04:54:20 <burp> jle`: I guess I'll improve it by your suggestion of putting the main recursive part into such a where clause
04:54:44 <Cale> mads-: We also don't have dependent types, so the kinds of theorems we can prove can't really easily say as much
04:55:15 <Cale> mads-: But those things aside, it's fine to think of Haskell types as propositions to be proved
04:55:22 <burp> I just wanted to make sure that there is no other trivial better way that I'm not aware of before putting more work into it ;)
04:55:22 <augur> Cale: iinm, if i compile with cabal to output a .a, i can then use the stub header in the C code, and then just include the .a when i compile the C code, right?
04:55:27 <Cale> djinn does this
04:55:29 <augur> and that should be like including all the .o's?
04:55:43 <augur> no that cant be right
04:55:49 <augur> the .a is tiny compared to the .o's
04:56:01 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> (b -> r) -> r
04:56:01 <lambdabot> f a b c = a (\ d -> b d c)
04:56:20 <augur> this is very confusing :(
04:56:53 <augur> all of the things ive seen only mention single files, nothing ever explains how to compile whole libraries
04:56:55 <Cale> djinn does a proof search in a small logical system and translates to Haskell :)
04:57:22 <Cale> augur: I honestly don't know very well
04:57:41 <Cale> augur: Pretty much all my experience with FFI has been in the other direction
04:58:06 <augur> yeah
04:58:16 <augur> im trying to write a core library in haskell because haskell makes it nice
04:58:24 <augur> and then expose the functionality to other languages
04:58:52 <augur> basically i wrote a dynamically typed LC type checker, and writing that in haskell is nice
04:58:57 <augur> but imagine writing in in C/ObjC
04:59:07 <augur> so now i just need to expose it to C
05:05:49 <augur> i mean maybe all i need to do is compile the one file, i dunno
05:06:23 <augur> i dont think so tho. it seems like every .hs file generates its own .o file, rather than producing one big .o at the end
05:08:57 * hackagebot haddock-library 1.1.1 - Library exposing some functionality of Haddock.  http://hackage.haskell.org/package/haddock-library-1.1.1 (MateuszKowalczyk)
05:08:59 * hackagebot haddock-api 2.15.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-api-2.15.0 (MateuszKowalczyk)
05:09:01 * hackagebot haddock 2.15.0 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.15.0 (MateuszKowalczyk)
05:39:04 <augur> Cale: so i tried to compile your code
05:39:09 <augur> and i get an undefined symbol error
05:39:21 <Cale> augur: Did you follow the same two steps I did?
05:39:27 <augur> i copy and pasted
05:39:40 <Cale> augur: You need to compile Foo.hs first just to get the .h file which defines the symbol...
05:39:46 <augur> yep
05:39:49 <augur> i did exactly that
05:39:53 <Cale> hm
05:40:03 <Cale> so which symbol isn't being defined?
05:40:15 <augur> i added an annotation
05:40:19 <augur> http://lpaste.net/110298
05:40:51 <Cale> oh, maybe it's because mac
05:41:07 <Cale> Ah, clang, wtf?
05:41:22 <augur> i have the newest haskell platform
05:41:26 <augur> which iinm uses clang on mac
05:41:30 <Cale> hm
05:41:33 <Cale> Yeah, I dunno
05:41:47 <augur> this is so frustrating :(
05:41:59 <augur> all of the people who would know arent around :(
05:42:03 <augur> no mzero
05:44:19 <bennofs> augur: it's weird that it says that Foo.o has a _main. Can you try calling the .c file differently (maybe bar.c)?
05:44:31 <bennofs> Looks like it confused Foo.o and foo.o to me
05:45:07 <augur> ok lemme try that
05:46:54 <augur> bennofs: same error
05:47:08 <augur> only with Bar.o in place of foo.o
05:47:14 <augur> (annotated again)
05:49:28 <augur> :(
05:49:52 <augur> no wonder ive been banging my head against a wall for a week. the whole darn thing is busted
05:50:14 <augur> Cale: truly, this is how haskell can avoid success at all costs. %_%
05:50:32 <augur> just guarantee that people literally cannot use haskell! \o/
05:52:43 <bennofs> augur: it works on linux :|
05:52:50 <augur> bennofs: i know!
05:53:34 <augur> thats why im so frustrated
05:53:51 <augur> i cant even try to poke around with Cale's minimalist code, nevermind my big honkin' library
05:54:06 <augur> i no longer know where any of the errors i encountered are coming from
05:54:14 <bennofs> augur: can you do objdump -t Foo.o ?
05:54:19 <augur> because even a simple example that _should_ work doesnt
05:54:39 <augur> deni: no command objdump
05:54:45 <augur> er, bennofs^
05:54:49 <augur> sorry deni, ignore that :x
05:57:31 <bennofs> augur: ok, try nm Foo.o
05:58:41 <augur> bennofs: annotated
05:59:36 <bennofs> augur: rm Foo.o; ghc Foo.hs; nm Foo.o
05:59:54 <bennofs> or just -fforce-recomp to ghc
06:00:23 <bennofs> augur: Foo.o looks much more like the output of compiling your c file than compiling your haskell code
06:01:06 <augur> bennofs: now its very different. annotated
06:01:13 <augur> lets try compiling the C again now
06:01:30 <bennofs> that looks much better
06:02:05 <augur> huzzah!
06:02:13 <augur> ok so it was a weird issue with the capitalization i guess?
06:02:18 <bennofs> yes
06:02:32 <augur> so now, is a.out something i can run to see if it works?
06:02:47 <augur> yes ok
06:02:49 <augur> so it works
06:02:50 <bennofs> :)
06:03:12 <augur> now to experiment!
06:03:18 <augur> thank you bennofs, Cale <3
06:03:37 <wz1000> 'Implies' is a weird operation.
06:07:36 <funfunctor> :t io
06:07:38 <lambdabot>     Not in scope: ‘io’
06:07:38 <lambdabot>     Perhaps you meant one of these:
06:07:38 <lambdabot>       ‘id’ (imported from Data.Function),
06:07:47 <nicoo> :k IO
06:07:48 <lambdabot> * -> *
06:07:49 <funfunctor> :t liftIO
06:07:50 <lambdabot> MonadIO m => IO a -> m a
06:08:03 <Lilly22>  Here some videos. I hope you like them! http://bit.ly/1mFMmyS
06:08:43 <wz1000> If you define a set type as 'type Set = a -> Bool', then a lot of Boolean functions transalate neatly to their 'Set' counterparts. Intersection is 'liftM2 (&&)', and Union is 'liftM2 (||)'. Implies doesn't translate into 'isSubsetOf' so well.
06:09:17 <augur> wz1000: that type wont work but
06:09:23 <augur> type Set a = a -> Bool   should
06:10:27 <splintax1> in the phrase "P implies Q" we don't normally think about what happens when P is false
06:11:00 <augur> bennofs, Cale: ok, so i can get a thing to compile almost exactly as i want
06:11:36 <augur> i modified Cale's example to instead have two modules A.B which defines `add', and C.D which defines `sub', and Foo.hs exports those
06:11:47 <wz1000> augur: yes, my bad. It was a typo.
06:11:48 <augur> and also Bar.c uses both. it works.
06:12:03 <augur> now the question becomes: how to compile this to a self-contained library
06:12:34 <funfunctor> if I have a type-signature of  :: String -> REPL () and I want to lift the string to be printed as the IO () monad inside REPL (), is liftIO the right thing to do?
06:13:04 <funfunctor> i.e. foo s = liftIO (putStrLn s)
06:13:09 <wz1000> :t lift
06:13:11 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
06:13:48 <funfunctor> isn't liftIO a multi iteration version of lift ?
06:13:58 <bennofs> :t liftIO -- yes
06:13:59 <lambdabot> MonadIO m => IO a -> m a
06:14:07 * hackagebot stateWriter 0.2.2 - A faster variant of the RWS monad transformers.  http://hackage.haskell.org/package/stateWriter-0.2.2 (SimonMarechal)
06:14:09 * hackagebot language-puppet 1.0.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.0.0 (SimonMarechal)
06:14:17 <funfunctor> so you could just use liftIO in the place of lift
06:14:41 <bennofs> funfunctor: in fact, lift won't work ín your case probably
06:14:57 <bennofs> funfunctor: what is REPL? (how is it defined?)
06:15:02 <funfunctor> well that is why I asked about liftIO
06:15:03 <funfunctor> :)
06:15:27 <funfunctor> newtype REPL a = REPL { unREPL :: IORef RW -> IO a }
06:16:13 <funfunctor> eval :: String -> REPL ()
06:16:26 <funfunctor> eval s = io (putStrLn s)
06:16:35 <funfunctor> works sort of, but it keeps printing ()
06:18:01 <tsousa> what is the real world advantage of curried functions or it is juts a clever trick?
06:18:43 <Rembane> tsousa: You can apply them on lists of tuples, it's quite handy.
06:19:48 <tsousa> but there isnt a real advantage of using curried or normal functions right?
06:19:48 <pjdelport> tsousa: From a practical perspective, curried functions often lets you express things very succinctly; for example evens = filter isEven
06:20:13 <Rembane> tsousa: No. I usually use curry and uncurry instead.
06:20:14 <Rembane> :t curry
06:20:16 <lambdabot> ((a, b) -> c) -> a -> b -> c
06:20:21 <Rembane> :t uncurry
06:20:22 <lambdabot> (a -> b -> c) -> (a, b) -> c
06:20:51 <Rembane> BTW, are we speaking about the same kind of curry?
06:20:57 <pjdelport> tsousa: From a more theoretical perspective, it also simplifies and regularizes things, because you can think of *all* functions as just being unary: from a single value to a single value (which may be a further function)
06:21:11 <pjdelport> :t map
06:21:13 <lambdabot> (a -> b) -> [a] -> [b]
06:21:17 <nateb> Hi.  I aksed a question the other day, but something came up and I had to run off.  I still can't come up with the solution.  My problem is that I have a large group of ADTs who are chained together, like `A = Aa B | ...; B = Bb C | ...; C = Cc D | ...; ...; Y = Yy Z`.  Right now, in order to make one, I am doing `A $ B $ C $ ... $ Z blah`.  It feels like there must be a simpler way.  Is there some method of doing this like `magicallyMakeAfromZ $ Z b
06:21:56 <funfunctor> tsousa: allows you to take a function apart into paritial functions and compute them sperately then put it back together
06:23:00 <pjdelport> tsousa: So currying lets you think of map not only as simply mapping a function over a list, but *equally* as a function that takes a plain function (a -> b) and lifts it into a new function from *lists* of a to lists of b:
06:23:00 <pjdelport> map :: (a -> b) -> ([a] -> [b])
06:23:55 <tsousa> ah nice pretty clever
06:24:32 <pjdelport> tsousa: And that generalizes to all other functions too, of course.
06:25:20 <funfunctor> tsousa: also take a look at the Curry–Howard correspondence as uncarrying/currying is equivalent to logical conjunction, meaning function type-signatures correspond to implications
06:25:26 <funfunctor> *partial
06:25:40 <tsousa> funfunctor, ok thanks i will
06:27:00 <nateb> In a language like C++, I would probably turn to template metaprogramming to solve my problem.  Do I need to use template Haskell, or can I do this a simpler way?
06:27:26 <statusfailed> edwardk: Is it possible to write a groupBy transducer with machines?
06:27:41 <statusfailed> edwardk: slightly more in-depth version of that question: https://gist.github.com/statusfailed/8e6f79d35e89acc5bb3d
06:29:05 <Fuuzetsu> does someone know how to get a text file on haskell.org not come out with garbled unicode? See http://www.haskell.org/haddock/CHANGES.txt for an example
06:29:15 <augur> bennofs: ok. im almost there. now to just figure out how to compile a C file to a library instead of an executable :)
06:29:22 <Fuuzetsu> I'm just scp'ing the file up and it comes out ugly
06:29:44 <bennofs> augur: I have no idea how libraries work on OSX
06:29:54 <augur> bennofs: yeah. its mysterious.
06:30:02 <augur> i just need a static lib (which iinm is a .a)
06:30:57 <bennofs> augur: can't you let cabal build it? just set ghc-options: -no-hs-main and be done?
06:31:09 <bennofs> augur: (also use c-sources: bar.c)
06:31:24 <augur> bennofs: ive tried that but the lib files that it spits out end up being way too small to be correct
06:31:57 <bennofs> augur: have you tested that the lib indeed doesn't work ? :p
06:32:00 <augur> i mean, the .o files are each larger than the resulting library files, so there's no way its combining them all
06:32:18 <bennofs> augur: maybe it stripped debugging information or something
06:32:27 <augur> bennofs: ill try given this new insight into how to get ghc to do this
06:32:45 <dramforever> Just in case somebody remember that I wrote a wav reverser thing
06:33:02 <dramforever> Just tested it on Hatsune Miku's pi song...
06:33:17 <dramforever> Just in case you don't know, it's 68 minutes lone
06:33:40 <dramforever> long
06:34:11 <augur> bennofs: there was a haskell-cafe post from 8 years ago about making .a's. apparently the output .a's from ghc were, at the time, not also including the RTS, etc.
06:34:49 <augur> bennofs: so you'd have to dig up libHSrts.a and libHSbase.a and libHShaskell98.a, unpack them, then repack them with your new .a
06:34:52 <augur> what a bummer
06:35:03 <dramforever> And when I timed it with "time", and watched it with "gnome-system-monitor", it first used 1.3G mem for a while, then 1.5G, then 1.7G. but it's not like increasing, but constant-ish
06:35:11 <dramforever> And it finished in 56s???
06:35:13 <dramforever> It
06:35:14 <augur> i wonder if this has been fixed lately
06:35:34 <dramforever> It's waaaay faster even than my first slow version
06:35:50 <bennofs> augur: I think it's still the case. At least it was that way with ghc 7.6.3 iirc
06:35:54 <augur> but if not, that at least makes things clearer
06:36:01 <dramforever> so thanks to alpounet, et al for telling me about bytestring builders
06:36:40 <bennofs> augur: yeah, the ar file for a lib I just tested only contains the .o files of the lib itself, nothing more
06:36:52 <bennofs> that is, with ghc 7.8.3
06:36:56 <augur> bennofs: how did you unpack the archive?
06:37:03 <bennofs> augur: ar x archive.a
06:37:15 <augur> ok lemme see what this says for the cabal stuff i did before
06:39:47 <bennofs> augur: you can also use ar to create archives, but you'd need to look at the man pages / help to find out how (idk)
06:40:22 <augur> bennofs: so, it incluced a .o for the file i targeted with cabal, and a file called "__.SYMDEF SORTED"
06:41:02 <augur> no .o's for the other haskell files that cabal compiled
06:41:34 <bennofs> there is no __.SYMDEF_SORTED for the lib I tested (i didn't use c-sources though in that lib(
06:42:37 <augur> bennofs: me neither
06:42:38 <augur> hm
06:49:18 <funfunctor> how does one hook up haddock with cabal so docs are generated for my project? (looking for a good url as a entry-point to learning this..)
06:50:41 <barrucadu> funfunctor: `cabal haddock`
06:51:31 <qsuscs> i want to learn haskell, and i’m a native speaker of german. has anybody read this book and can comment on it or recommend something else? http://www.amazon.de/dp/3486714171
06:51:54 <qsuscs> i could also take an english book, of course, but i’d prefer german
06:54:21 <funfunctor> barrucadu: I want it to build LaTeX documentation
06:57:21 <funfunctor> barrucadu: I also want documentation to be built as part of 'build'
06:58:11 <Tuplanolla> I'd recommend English for that very reason, qsuscs. It is important to be fluent in it if you write programs or documentation.
07:01:21 <NickHu> Hi, can anyone help me debug an issue I'm having with hdevtools dependencies?
07:01:23 <NickHu> http://lpaste.net/110304
07:01:45 <NickHu> I can't see which package - if any - that require transformers-3 rather than the later version I have installed
07:03:04 <qsuscs> Tuplanolla: hmm. any objections against “Learn You a Haskell for Great Good!” http://www.nostarch.com/lyah.htm ? it’s available in the local library
07:03:32 <Tuplanolla> It seems pretty good.
07:04:50 <NickHu> qsuscs: Lyah is great!
07:04:59 <NickHu> It's quite an entertaining read too, pretty funny
07:05:12 <NickHu> I would say just use the website though, pretty much exact same content
07:05:18 <augur> bennofs: do you know how to compile to .o but not link?
07:05:27 <bennofs> augur: pass -c to ghc
07:05:35 <augur> cool, thanks
07:05:59 <qsuscs> NickHu: yes, but usually, i have a 12″ notebook, which is too small for ghci, vim and browser, and it could lead me just to copy-paste the code examples
07:07:43 <augur> bennofs: so close!
07:07:58 <NickHu> qsuscs: Hah, I read most of the book on my phone
07:08:00 <augur> bennofs: so ive hand-constructed a .a from the modified Cale example
07:08:24 <qsuscs> NickHu: been there, done that. once was enough. now i bought a kindle
07:08:30 <augur> bennofs: and the only symbole its not finding is "_ZCMain_main_closure", which i suspect is due to my not including the libHS stuff
07:08:44 <augur> so now i just have to figure out where that lives so i can copy it
07:09:10 <bennofs> augur: ghc --print-libdir
07:09:15 <augur> :o
07:09:41 <bennofs> augur: there your find rts-1.0/libHSrts.a
07:10:00 <augur> aha, yep. its where i thought:   /Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/lib/ghc-7.8.3
07:10:26 <bennofs> augur: you'll probably also need to include base-*/libHSbase-*.a
07:10:37 <NickHu> qsuscs: Yeah, well lyah is the best intro to haskell I've read
07:10:50 <NickHu> Stay away from Real World Haskell because it assumes too much knowledge
07:10:55 <augur> bennofs: yeah, thats what Simon Marlow says in the cafe post
07:11:28 <augur> bennofs: hm. i have two versions of libHSbase, one with _p at the end of the number
07:11:39 <bennofs> augur: p is the profiling version. you can ignore it
07:11:43 <augur> ahh ok
07:12:58 <qsuscs> NickHu: of haskell? i couldn’t do a hello world. of programming? well, a bit (pascal at school, very basic shell and c and other stuff by myself). of mathematics? well, german highschool with math extra course
07:14:52 <NickHu> qsuscs: Yeah, Real World Haskell jumps all around and assumes you know about what various haskell libraries do and various fp concepts too
07:15:29 <augur> bennofs: ok, lets see how this goes. :D
07:15:36 <augur> bennofs: if this works, im writing a tutorial <3
07:16:03 <augur> aghhh no, still missing that symbol :(
07:16:17 <augur> maybe .a's cant be recursively searched? lets find out
07:16:19 <mokkake> hey, i pretty sure i saw whenM :: (Monad m) -> m Bool -> m a in hackage somewhere, but i can't remember the library. Does someone have a clue ?
07:16:33 <systemfault> hoogle could tell you :P
07:16:49 <systemfault> Or not :/
07:16:51 <mokkake> systemfault: no, he didn't :/
07:19:22 <mokkake> got it :p Control.Cond
07:19:31 <bennofs> augur: do you have a Main module?
07:19:51 <augur> oh, wait, i didnt do -no-hs-main did i? :O
07:20:00 <nateb> Since I didn't have any takers, let me ask another way: is it possible to pattern match a function on the type?  Something like `f :: (Eq a) => a -> a -> Bool` that has one behavior for most types, but does something different for Floats, say?
07:20:07 <bennofs> augur: idk, but that symbol is not vge
07:20:12 <bennofs> augur: is not in any rts file
07:20:24 <ChristianS> mokkake: it's also in the IfElse package
07:21:03 <bennofs> augur: ah hmm, but you might also need integer-gmp to do the addition
07:21:19 <augur> bennofs: cross your fingers
07:21:22 <hexagoxel> NickHu: hdevtools compiled in sandbox with ghc-7.6.3 (not with 7.8.3)
07:21:41 <NickHu> hexagoxel: I'm sorry, I don't really understand what that means
07:21:52 <augur> bennofs: \o/
07:21:55 <augur> hahahaaaaaaaaaaa!!!!!!!!!!!!
07:22:02 <Phillemann> When I generate lenses for a record using makeLenses, how do I export all of them without explicitly mentioning them in the "module foo(...)" directive?
07:22:29 <bennofs> Phillemann: you can't if you don't want to export all of the module
07:22:32 * augur grabs bennofs's hands and dances 
07:22:33 <augur> :DDDDDDDDDDDDDDDDDDDDDDDDDD
07:22:41 <bennofs> @botsnack
07:22:41 <lambdabot> :)
07:22:44 <nyuszika7h> I have haskell-platform installed on my Debian server, how can I compile a newer version? the README is talking about some GHC bindist
07:22:47 <Phillemann> bennofs: Oh, ok.
07:23:02 <augur> bennofs: you've made my fucking day
07:23:05 <augur> hooooly shit
07:23:28 <augur> in two hours youve gotten me to my solution :D
07:27:37 <burp> nyuszika7h: http://www.haskell.org/platform/linux.html
07:27:58 <burp> and/or http://www.haskell.org/ghc/download
07:28:15 <nyuszika7h> I downloaded the source, but the README is talking about some GHC bindist - the binaries seem to have hardcoded path so they break when I try to install them with stow
07:28:55 <burp> dunno, I'd just install ghc and install packages with cabal
07:29:16 * hackagebot ghcjs-dom-hello 1.1.0.0 - GHCJS DOM Hello World, an example package  http://hackage.haskell.org/package/ghcjs-dom-hello-1.1.0.0 (HamishMackenzie)
07:32:54 <qsuscs> a tutorial just made me do this: let x = 4 in x * x
07:33:30 <qsuscs> so x is like a local varia… er, whatever with the scope of the rest of the line after “in”?
07:34:06 <mokkake> qsuscs: yes
07:34:19 <Phillemann> A state monad "is" a reader monad too, right?
07:34:20 <Tuplanolla> You can call them variables even if they don't vary.
07:34:42 <Phillemann> I'm trying to "deriving(MonadReader Mystate)" from a newtype for a monad transformer, but ghc won't let me.
07:34:58 <qsuscs> Tuplanolla: this perfectly makes sense. ahem. :D
07:35:18 <mokkake> i think the right term is "binding"
07:37:25 <Phillemann> More generally, I'm trying to use "view" with a lens to get a field from a record that's stored in a StateT monad.
07:37:55 <Phillemann> Which fails because my newtyped monad transformer stack doesn't have a MonadReader instance.
07:38:06 <Phillemann> s/generally/specifically/
07:38:25 <triliyn> Phillemann: are you using the GeneralizedNewtypeDeriving extension?
07:38:40 <Phillemann> Yes, which works for MonadState, for example.
07:38:42 <bennofs> Phillemann: Use the function 'use' from lens instead of view
07:38:58 <bennofs> Phillemann: 'use' is like 'view' just for MonadState
07:39:13 <triliyn> hmm
07:39:18 <Phillemann> bennofs: I _just_ found that, and it's right below view. Stupid of me. Thanks :)
07:39:20 <mokkake> is there an infix for that ?
07:39:48 <bennofs> mokkake: 'use' is unary, so no infix
07:39:56 <mokkake> bennofs: oh okay
07:49:17 * hackagebot hdocs 0.4.1.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.1.0 (AlexandrRuchkin)
07:49:57 <bhuemer> hi! does anyone know a paper that describes how haskell has non-blocking IO by default?
07:51:01 <bhuemer> or maybe something else I could read, other than say stack overflow threads - some background?
08:01:13 <pjdelport> bhuemer: Maybe start at https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts for some context, and pointers?
08:02:39 <pjdelport> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler probably and https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/IOManager are probably most relevant
08:02:40 <bhuemer> pjdelport: thanks, that's a good start! :)
08:03:24 <bhuemer> I also found this now: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf .. that should be enough reading material for now! thanks again
08:07:44 <augur> hmm
08:08:17 <augur> bennofs: if i try to run the same stuff, but finish using clang instead of ghc on the main C file, clang complains about all sorts of symbols being missing, even tho they should be in the archive
08:08:46 <augur> bennofs: is there a way to find out which archive has a symbol?
08:09:21 <McManiaC> why wont catchError catch this IOException inside the ExceptT? http://puu.sh/bfvq9/8513ff08ea.png
08:09:39 <bennofs> augur: I don't think there is, but you can guess and then check with nm archive | grep symbol
08:09:46 <ClaudiusMaximus> augur: maybe ranlib can help?  just a guess, might be order of objects in the archive matters more with clang
08:09:52 <bennofs> augur: (or do that in a script if you need to try much)
08:09:58 <augur> ClaudiusMaximus: oh maybe thats it, yeah
08:10:01 <augur> lemme try to reorder them
08:11:11 <Mathnerd314> so GHC has extensible exceptions; how similar are they to C++ exceptions?
08:11:55 <augur> ClaudiusMaximus: well, that got me a little closer! :)
08:11:59 <augur> maybe
08:12:56 <geekosaur> McManiaC, if I had to guess... it's not actually evaluated until the runExceptT gets it, but the catchError is out of scope at that point. (laziness *does* apply to IO)
08:13:28 <geekosaur> Mathnerd314, in general any question like that is answered "not very"... but what exactly do you mean?
08:15:57 <mokkake> hey, i got a monad stack "type Px a = ReaderT PConf (State Pstate) a", and i don't get how i should construct a "initial test type", providing an initial PConf and PState
08:16:44 <Mathnerd314> geekosaur: well, I was wondering how inheritance worked; can I make an exception 'class' that adds information and has subtypes?
08:17:36 <Mathnerd314> geekosaur: e.g. MyExceptionType { randomData :: X } and then a sub-exception-type SpecificException
08:17:53 <geekosaur> it's based on typeclasses, so it has the usual caveats about trying to treat it like OO classes
08:18:58 <Mathnerd314> I was thinking about something like data X = forall e . (Exception e, MyX e) => X e
08:19:05 <geekosaur> the haddock for Control.Exception should give you some pointers. yes you can add information and have subtypes, but it's still not OO
08:19:33 <geekosaur> that looks more like old-style exceptions
08:20:54 <Mathnerd314> I was going off of this: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception.html
08:21:11 <Mathnerd314> are there newer exceptions somewhere? :p
08:21:44 <brycelane> does anybody have a pointer to an example of using QuickCheck2 with `$quickCheckAll` and cabal?
08:22:36 <geekosaur> Mathnerd314, exceptions wrapped in existentials is how old exceptions worked. why do you want to bring that back?
08:22:59 <geekosaur> (you will be much happier in the long run if you do not try to force Haskell to behave like C++)
08:24:46 <Mathnerd314> geekosaur: well, how do I get a Java-style exception hierarchy like in http://www.programcreek.com/wp-content/uploads/2009/02/Exception-Hierarchy-Diagram.jpeg ?
08:25:36 <Mathnerd314> the stuff in Control.Exception seems to be only 2-level, SomeException -> IOError -> <constructor>
08:26:01 <geekosaur> by programming in Java. yes, if you absolutely insist, you can simulate OO in Haskell; it will be painful and require a lot of work and special cases, but if you absolutely insist then it can be done.
08:26:20 <geekosaur> (and I cannot help you with it)
08:26:59 <augur> bennofs: ahhh hmm maybe this is partly responsible:
08:27:00 <augur> ld: warning: ignoring file archives/archive.a, file was built for archive which is not the architecture being linked (x86_64): archives/archive.a
08:27:22 <geekosaur> also there is no particular reason it has to be limited to 2 levels in the current system, look for "In more complicated examples, you may wish to define a whole hierarchy of exceptions:"
08:28:09 <Tuplanolla> You should get used to the idea of free functions and explicit data flow instead of objects, Mathnerd314. It's nice.
08:29:04 <Mathnerd314> geekosaur: right. But those don't have data attached. e.g. if I have an IndexOutOfBounds exception, and subtypes for Array, Vector, etc., there should be some generic way to get the index
08:31:34 <Mathnerd314> geekosaur: in this case though, all I need is some way of providing informative backtraces
08:31:34 <geekosaur> Mathnerd314, all the examples have no data but there is nothing stopping you from using data MyException = MyException { data :: whatever }
08:32:32 <geekosaur> Mathnerd314, see for example http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/src/GHC-IO-Exception.html#IOException
08:32:44 <geekosaur> lots of added data there
08:33:20 <Mathnerd314> I want something like catch (\ (e :: SomeException) -> addStackInfo "blah blah" e
08:36:36 <geekosaur> so you throw your new exception type with the added data
08:37:12 <geekosaur> catch *consumes* the exception, you can't just modify it as it goes by. (think immutability...)
08:37:43 <Mathnerd314> sure, catch (\e -> throw (addStackinfo e))
08:37:50 <Mathnerd314> but I don't see a way to add a new constructor to IOErrorType, except by hacking base...
08:39:23 <geekosaur> you are still thinking in terms of OO instead of functiona;
08:41:02 <Mathnerd314> no, I'm thinking "why do I have to copy-paste IOException, when it could just have an extra type parameter..."
08:41:11 <hellertime1> is there a straight forward way to convert a [Bool] (or a Vector Bool) to a Word64? the vector library has a function `convert`, but I'm not sure how it can be used
08:42:56 * geekosaur is pretty sure he is completely failing at this, and hopes someone else can do it more successfully
08:43:14 <mokkake> hey, i got a monad stack "type Px a = ReaderT PConf (State Pstate) a", and i don't get how i should construct a "initial test type", providing an initial PConf and PState
08:43:18 <geekosaur> because yes, that is essentially OO think"I want an OO siubclass nothing else could ever possibly work"
08:44:15 <Hodapp> "Some people, when confronted with a problem, think, "I know, I'll use OO subclassing." Now they have two problems."
08:47:23 <hellertime> nevermind. I just discovered the bitwise package… seems that hasn't made it into Hoogle yet
08:51:13 <tlo> hey, beginner problem: I have "data Person = Person { firstName :: String, id :: Int }" and "data Animal = Animal { name :: String, id :: Int }". Now I get "Couldn't match expected type `Animal' with actual type `Person'" if I try to call "id guy". How can I call "id" for Person?
08:52:22 <Taneb> tlo, Haskell lacks that kind of overloading
08:52:51 <Fuuzetsu> solutions: type classes, vinyl
08:53:09 <tlo> Taneb: oh, so I schould name it personId and animalId for example?
08:53:35 <Taneb> tlo, that's the easiest solution
08:53:38 <Taneb> And a decent on e
08:53:55 <hpc> also, your id is going to be annoying for users of your code
08:53:56 <hpc> :t id
08:53:58 <lambdabot> a -> a
08:54:28 * hackagebot qc-oi-testgenerator 1.2.0.2 - Compile time generation of operation invariance tests for QuickCheck  http://hackage.haskell.org/package/qc-oi-testgenerator-1.2.0.2 (goedderz)
08:55:06 <tlo> hpc: I see, so one should really be careful with names
08:55:47 <nshepperd> @pl \f h g -> curry f h <$> g h
08:55:47 <lambdabot> (`ap` flip id) . (((.) . (<$>)) .) . curry
09:01:40 <Tuplanolla> @pl let f = flap in \ x y -> f y $ \ z -> f z x
09:01:40 <lambdabot> flip flap . flip flap
09:03:58 <nshepperd> hehe
09:04:29 * hackagebot directory-layout 0.7.4.1 - Directory layout DSL  http://hackage.haskell.org/package/directory-layout-0.7.4.1 (MatveyAksenov)
09:09:30 * hackagebot hemokit 0.6.3 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.3 (NiklasHambuechen)
09:25:00 <xxlsize> any girl wanna skype?
09:25:00 <xxlsize> :)
09:25:06 <Fuuzetsu> ;^)
09:28:17 <fruitz> lol
09:29:56 <meoblast001> relrod: Haskellfant has a question for you
09:29:58 <identity> xxlsize: maybe not the best place to look bro.
09:30:21 <Fuuzetsu> identity: you don't pick up girls in #haskell?
09:31:52 <identity> Fuuzetsu: In my time as a computer scientist I found overwhelming evidence that the women in the field are not ones I find particularly interesting nor attractive. :P
09:32:03 <identity> not that everyone here is in CS, but you get the point.
09:32:22 <Fuuzetsu> now now, you have to be careful or you'll get jumped by SJWs
09:32:55 <fruitz> there are some hot CS girls on reddit
09:33:03 <pjdelport> Come on guys, don't be asses. This is #haskell.
09:33:11 <Algebr`> +1
09:33:15 <bennofs> pjdelport++
09:33:18 <geekosaur> agreed, please take this elsewhere
09:33:24 <dfeuer> Mmmmhmmm.
09:33:25 * Fuuzetsu called it
09:33:40 <identity> I'm not pursuing the conversation, merely responding to a question. :)
09:33:43 <dfeuer> I don't know what SJWs are, but this is far off-topic.
09:33:53 <geekosaur> ...right, being boorish is clearly a right that must be supported
09:33:56 <Fuuzetsu> yeah yeah, we're done
09:34:07 <meoblast001> picking up girls in #haskell?
09:34:32 <meoblast001> that sounsd like a great idea
09:34:54 <geekosaur> look. I know you all have it as a law of nature that you have the right and possibly responsibility to demonstrate that women exist solely for you to prey on them
09:34:58 <geekosaur> DO IT ELSEWHERE
09:35:10 <vanila> relax dude
09:35:10 <geekosaur> if you absolutely must demonstrate that only males are fully human
09:35:15 <ChristianS> geekosaur++
09:35:21 <geekosaur> vanila. no. get over yourself
09:35:23 <Algebr`> Is System.Cmd basically deprecated in favor of System.Process?
09:35:57 <identity> geekosaur: yes, that is exactly what I was doing.
09:36:36 <pjdelport> (Please, take this off-channel?)
09:36:54 <meoblast001> do we have an offtopic channel?
09:37:10 <Haskellfant> #haskell-blah
09:37:22 <meoblast001> beautiful. thanks Haskellfant
09:37:35 <quchen> That is also not the channel to have this discussion. It would be called #trash if it was.
09:37:39 <meoblast001> may the cookie gods bless your soul
09:38:29 <geekosaur> treating women as objects first and people only secondarily is never on topic imo
09:40:36 <pjdelport> Yup.
09:41:41 * meoblast001 thinks people are just too easily offended.. but oh well
09:41:58 <dfeuer> @ops
09:41:59 <lambdabot> Maybe you meant: pl oeis docs
09:42:01 <meoblast001> let's drop the topic
09:42:26 <zwarn> I have haskell code from a 2004 paper i want play with
09:42:39 <Algebr`> Is default a keyword?
09:42:48 <hpc> yes
09:42:48 <zwarn> the paper mentions the use of MultiParamTypeClasses and OverlappingInstances
09:42:49 <quchen> Algebr`: Yes. Very rarely used though.
09:42:52 <benmachine> I think it's important that Haskell remains welcoming to people of any gender and that whenever people say something that threatens that the rest of us tell them they are being terrible
09:42:59 <Algebr`> What is it for?
09:43:00 <bennofs> Algebr`: commonly also used with -XDefaultSignatures
09:43:20 <hpc> it tells the monomorphism restriction what to pick as the type
09:43:27 <quchen> Algebr`: "default" is what makes "1+1" work. 1+1 in GHCi is ambiguous since it has type `Num a => a`, which you cannot print. "default" makes it default to Integer if an ambiguity arises.
09:43:40 <benmachine> hpc: the monomorphism restriction isn't the only use of defaulting
09:43:55 <hpc> eh?
09:44:04 <quchen> dfeuer: It's @where ops
09:44:21 <dfeuer> Thanks, quchen. Hopefully that's passed.
09:44:27 <benmachine> hpc: "print 1" is technically ambiguous, but made possible by defaulting
09:44:50 <zwarn> after i do this there are still some errors left calling for FlexibleInstances FlexibleContext and UndecidableInstances
09:44:51 <benmachine> that said, many people enable -fwarn-defaulting and observe that it's basically not a problem
09:45:16 <benmachine> it would be quite possible to write Haskell without defaulting with only a handful of extra type annotations
09:45:21 <dfeuer> > (1::Rational, 1::Double, 1::Int)
09:45:22 <lambdabot>  (1 % 1,1.0,1)
09:45:33 <dfeuer> That's more than "technically" ambiguous!
09:45:45 <benmachine> dfeuer: true
09:45:54 <HeladoDeBrownie> I'm trying to pick at random a value from a probability mass function pmf :: Integer -> Rational with its given probability. However, my implementation, probably due to floating-point imprecision, can only return part of the domain. Any ideas on how else I could do this? http://lpaste.net/110306
09:46:02 <benmachine> zwarn: those are probably fine, MultiParamTypeClasses is basically unusable without the FlexibleBlah extensions
09:46:23 <HeladoDeBrownie> I'm also not confident pick is implemented as well as it could be.
09:46:56 <haasn> zwarn: UndecidableInstances is the only one on that list that deserves special attention
09:47:00 <dfeuer> -fwarn-defaulting is a good idea. You wouldn't want to accidentally use Integer when you meant Int or Double when you meant Rational...
09:47:04 <haasn> FlexibleBlah is mostly benign
09:47:25 <pjdelport> HeladoDeBrownie: MonadRandom has a utility function that might be relevant? http://hackage.haskell.org/package/MonadRandom-0.2.0.1/docs/Control-Monad-Random.html#v:fromList
09:47:39 <haasn> UndecidableInstances can actually cause instance resolution to enter an infinite loop at compile time, so keep that in mind
09:47:43 <pjdelport> (not sure if it's exactly the same as what you have: fromList picks an element from a weighted list)
09:47:45 <McManiaC> is there a template haskell function that gives you access to all declarations in the current module?
09:47:57 <quchen> dfeuer: Especially when it creates a type error that propagates around before the compiler complains
09:47:59 <HeladoDeBrownie> pjdelport, cool, thanks. Even though it's not the same, I should be able to change my implementation to match.
09:48:00 <zwarn> after I enable all this extensions i still get "No instance for (SubType a b) arising from a use of `prj' Possible fix:   add (SubType a b) to the context of the instance declaration"
09:48:53 <dfeuer> haasn, does Undecidable Instances make the type system Turing complete?
09:49:19 <haasn> dfeuer: Yes
09:49:30 <benmachine> modulo the finite resource limits
09:49:38 <haasn> Haskell has no finite resource limits
09:49:59 <benmachine> haasn: well, as implemented by GHC, I believe there's a limit to context resolution recursion
09:50:04 <benmachine> -fcontext-stack or something
09:50:10 <haasn> That's a divergence from the report, surely
09:50:19 <benmachine> UndecidableInstances isn't in the report
09:50:23 <statusfailed> I want to learn a Lisp- does anyone have any recommendations for an intermediate-ish haskeller? (focusing less on practical usage and more on theory of computation a plus)
09:50:36 <benmachine> (I'm not sure whether the finite limit is used without it)
09:50:41 <haasn> Oh, true
09:50:47 <dfeuer> statusfailed, Racket is pretty popular these days.
09:50:52 <yukko> statusfailed scheme is nice
09:51:08 <statusfailed> yukko: is scheme a single language?
09:51:18 <pjdelport> statusfailed: Scheme is a great lisp for learning; probably the de facto choice.
09:51:19 <vanila> yukko++ the  SICP book is very god for leaning it
09:51:20 <yukko> r5rs is very simple, r6rs is not so simple
09:51:39 <yukko> but in general yes
09:51:41 <haasn> benmachine: But that still leaves the type system turing complete; since you can make the stack arbitrarily large
09:51:43 <haasn> (in theory)
09:51:44 <dfeuer> statusfailed, not really. It's a core language and philosophy with multiple branches off.
09:51:54 <pjdelport> statusfailed: Seconding SICP; you'll definitely want to look at that: http://mitpress.mit.edu/sicp/
09:52:05 <dfeuer> The various Scheme "implementations" have substantial differences.
09:52:11 <hakujin1> +1 vote for Racket
09:52:12 <pjdelport> There are video lectures by the authors available online too.
09:52:20 <pjdelport> Racket has a SICP mode :)
09:52:23 <benmachine> haasn: I guess if you accept your execution method as "compile program, check for error, if error increase stack and compile again"
09:52:51 <haasn> benmachine: ”compile program, check for memory exhaustion, if error increase RAM and compile again” :)
09:52:59 <benmachine> :)
09:53:03 <statusfailed> OK, I will go with reading SICP and doing whatever it tells me :P
09:53:05 <statusfailed> thanks all!
09:53:05 <benmachine> fair point
09:54:34 <haasn> But the matter of fact is that UndecidableInstances will let you encode any computable function in the type system
09:54:37 * hackagebot Chart 1.3 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.3 (TimDocker)
09:54:39 * hackagebot Chart-cairo 1.3 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.3 (TimDocker)
09:54:41 * hackagebot Chart-gtk 1.3 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.3 (TimDocker)
09:54:43 * hackagebot Chart-diagrams 1.3 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.3 (TimDocker)
09:54:45 * hackagebot Chart-simple 1.3 - A wrapper for the chart library to assist with basic plots (Deprecated - use the Easy module instead)  http://hackage.haskell.org/package/Chart-simple-1.3 (TimDocker)
09:54:52 <haasn> So it's turing complete in what you can do in practice
09:55:27 <benmachine> yes, I think you're right
09:55:34 <c_wraith> well.  UndecidableInstances lets you loop, but it doesn't let you compute.  You need functional dependencies or type families for that
09:55:41 <benmachine> right
09:56:12 <haasn> I wonder if that can be worked around
09:56:37 <haasn> My gut instinct is “yes” but I'm too tired to think about this right now
09:57:22 <Algebr`> Is the RTS responsible for handling OS signals?
09:57:58 <bennofs> Algebr`: it handles some specific signals that are used internally
09:58:02 <benmachine> Algebr`: in what sense responsible? it handles some of them, I believe
09:58:14 <haasn> It throws the rest as IO exceptions to your main thread
09:58:15 <benmachine> e.g. SIGINT might be turned into that exception
09:58:30 <haasn> Or ignores them. I don't know the exact permutation
09:58:46 <Algebr`> like if I do ^d to a program, can my program react to that?
09:58:57 <benmachine> ^D doesn't send a signal
09:59:09 <Algebr`> EOF isn't a signal?
09:59:19 <benmachine> it just makes a call to the read system call return
09:59:20 <bennofs> Algebr`: it's a character
09:59:30 <haasn> I thought EOF is a property of handles
09:59:34 <haasn> And neither a character nor a signal
09:59:35 <benmachine> which, if no bytes have been written, looks like an EOF
09:59:55 <benmachine> there are at least two different things called EOF
09:59:57 <haasn> But I'm sure https://en.wikipedia.org/wiki/End-of-file knows
10:01:06 <dfeuer> ^D only turns into EOF if the terminal is in the right sort of mode and such.
10:01:10 <benmachine> (to test what I just said, try running 'cat' and writing 'blah^D' into it)
10:04:02 * haasn .oO( blah^V^D )
10:08:05 <qsuscs> haasn: did you use something german to learn haskell?
10:08:13 <haasn> qsuscs: No
10:13:32 <deni> when using aeson and doing an instance for ToJSON is there a way to say Person {..} where ".." would mean all record fields? So i don't have to enumerate them all?
10:15:25 <hpc> {-# LANGUAGE RecordWildCards #-}
10:15:36 <hpc> iirc it uses that exact syntax
10:16:29 <Haskellfant> catch is defined as catch = catchException according to http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Exception-Base.html#catch but I can't find the definition of catchException, where is this defined?
10:18:03 <monochrom> no matter where that is defined, it will eventually trace down to GHC RTS internals. Do you really want it?
10:18:16 <Haskellfant> monochrom: in this case probably not :)
10:24:17 <vanila> monads vs exteff? What's the best
10:25:08 <monochrom> writing your own, tailor-making to your job, is the best.
10:25:24 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:26:01 <quchen> Haskellfant: You can use Github's nice search to find things like these. https://github.com/ghc/ghc/search?utf8=%E2%9C%93&q=catchException&type=Code
10:26:33 <Haskellfant> quchen: ah thx, I didn't think about that. only tried hoogle and hayoo
10:28:29 <Algebr`> What is the point of const?
10:28:45 <c_wraith> it's shorter than writing (\a b -> a)
10:28:49 <monochrom> to show that it can be done
10:29:09 <MitchellSalad> it's longer than writing (\_ -> x) though if x isn't free :P
10:29:25 <c_wraith> :t \n -> zipWith const <*> drop n
10:29:26 <lambdabot> Int -> [b] -> [b]
10:29:49 <c_wraith> err.  whoops, that's backwards
10:30:16 <c_wraith> Oh, no it's not.  That's the correct definition
10:30:35 <MitchellSalad> huh, that's neat
10:30:36 <c_wraith> That's more or less as efficient as possible for what it does..  and it uses const!
10:30:41 <MitchellSalad> what does it do?
10:30:53 <c_wraith> drops the last n elements of a list
10:30:59 <c_wraith> lazily
10:31:29 <c_wraith> well, sorta-lazily.  It needs to keep n elements of the list in memory
10:31:52 <Tuplanolla> Stopped by to say that's cool.
10:32:15 <MitchellSalad> i'm still confused :P is it the (->) instance of (<*>) you're using?
10:32:20 <c_wraith> yes
10:32:30 <MitchellSalad> ah
10:32:30 <c_wraith> I just was too lazy to put a second arg in the lambda. :)
10:32:36 <MitchellSalad> gotcha
10:33:08 <c_wraith> :t \n xs -> zipWith const xs $ drop n xs
10:33:09 <lambdabot> Int -> [b] -> [b]
10:34:00 <monochrom> interesting
10:35:12 <c_wraith> It's a cute trick, and I like it because it uses const in a non-trivial way to do something useful
10:38:38 <c_wraith> and of course Algebr` was timing out during that discussion
10:40:02 <deni> hpc: yep that's what i was missing. tnx.
10:49:46 * hackagebot irc-ctcp 0.1.1.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.1.0 (barrucadu)
10:59:46 * hackagebot c2hs 0.18.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.18.1 (IanRoss)
11:15:41 * dfeuer benchmarks Cale.
11:19:48 * hackagebot recaptcha 0.1.0.3 - Functions for using the reCAPTCHA service in web applications.  http://hackage.haskell.org/package/recaptcha-0.1.0.3 (JohnMacFarlane)
11:23:15 <Mathnerd314> hmm, so now I need an argument parsing library. which library can parse --option name value, -cvx, and also modes like --store/--retrieve?
11:24:00 <hakujin> Mathnerd314: lots. optparse-applicative is popular
11:25:29 <hakujin> System.Console.GetOpt is built in
11:27:38 <sveit_> is there some instance of foldable for a pair (a,a) lying around, or should I write my own?
11:27:56 <Mathnerd314> hakujin: but System.Console.GetOpt doesn't do --option name value
11:30:12 <Mathnerd314> optparse-applicative looks OK, I guess I can write my own in there
11:31:48 <mauke> yay, non-standard option syntax :-/
11:33:50 <Mathnerd314> mauke: I guess Git uses -c name=value. Which would you prefer?
11:36:26 <mauke> -c name=value
11:36:30 <trattore450> ciao a tutti
11:36:36 <trattore450> !list
11:36:37 <mauke> inb4 list
11:36:37 <monochrom> trattore450: http://hackage.haskell.org/packages/archive/pkg-list.html
11:36:41 <trattore450> list
11:37:09 <merijn> mauke: too slow :)
11:37:09 <mauke> why do italians do this?
11:37:16 <trattore450> yes
11:37:18 <mauke> join a random channel and type "!list", I mean
11:37:25 <mauke> is there a tutorial somewhere?
11:37:55 <zomg> It could be some warez script
11:38:11 <zomg> I recall there used to be a bunch of scripts that would automate joining channels and getting fileserve listings
11:40:58 <amar^> so thinking about performance of Maybe vs Union Types, any opinions?
11:41:28 <merijn> amar^: Sure: "It depends"
11:41:55 <merijn> amar^: Or: "It probably doesn't matter and you shouldn't worry until you've profiled and have evidence there is a problem"
11:43:47 <dfeuer> Can anyone explain why initsT'  as written in http://www.haskell.org/pipermail/libraries/2014-August/023610.html  gets a (small, but consistent) benefit from its local copy of `take`?
11:44:11 <Mathnerd314> mauke: either way though, I do need some sort of parser for handling double arguments
11:44:37 <amar^> merijn: kool, but at (Maybe NotPractical) benchmarking purpose, do you have any obseravation?
11:46:22 <merijn> Not really
11:49:36 <amar^> merijn: okay, thanks though
11:50:22 <statusfailed> What is an example of 'codata' in haskell? Is that a meaningful question?
11:50:29 <statusfailed> does [1..] count?
11:50:51 <quchen> dfeuer: Maybe the standard take is better in the general case due to its heavy optimization?
11:50:54 <HeladoDeBrownie> statusfailed, lists themselves, and many other structures – Haskell conflates data and codata
11:51:56 <statusfailed> HeladoDeBrownie: what about some languages (i.e. Idris) makes that distinction necessary?
11:52:10 <statusfailed> I know "totality" is probably the correct magic word, but i'm not sure what it means :p
11:53:10 <HeladoDeBrownie> statusfailed, Idris and Agda and such have rules that require you to consume codata in a certain way so as to guarantee that you couldn't return a bottom value of some sort (which I'm given to believe those languages lack)
11:53:24 <dfeuer> quchen, I was thinking it could be a case where fusion leads to reboxing, but ... I think the allocation differences would probably be much bigger if that were the case.
11:53:38 <HeladoDeBrownie> Here's an example: You should not be able to get the length of an infinite list. Yet in Haskell, you can easily request it:
11:53:41 <HeladoDeBrownie> > length [1..]
11:53:45 <lambdabot>  mueval-core: Time limit exceeded
11:53:54 <statusfailed> HeladoDeBrownie: I think that's what they call "productiveness" right?
11:53:57 <statusfailed> HeladoDeBrownie: ok, that makes sense :)
11:53:58 <statusfailed> thanks
11:54:02 <HeladoDeBrownie> I'm not the best person to ask
11:54:08 <HeladoDeBrownie> However this post might help http://blog.sigfpe.com/2007/07/data-and-codata.html
11:54:37 <statusfailed> HeladoDeBrownie: Looks good, thanks!
11:55:25 <HeladoDeBrownie> Although conceivably you could have a type of lazy naturals and return a value of that type for the length of a potentially infinite list
11:55:30 <HeladoDeBrownie> Then you just trade one infinite structure for another
11:55:38 <HeladoDeBrownie> Well, they wouldn't be naturals exactly
11:55:43 <HeladoDeBrownie> There's no "infinite natural number"
11:56:06 <HeladoDeBrownie> But in Haskell, again, you can produce it even though it might not make sense to want to
11:56:17 <HeladoDeBrownie> data Nat = Zero | Succ Nat ; let x = Succ x in x
11:56:32 <pjdelport> statusfailed: So data is finite, and you're guaranteed to always be able to consume it using recursion. codata is potentially infinite, but you're guaranteed to always be able to *produce* it using corecursion.
11:57:06 <pjdelport> (That's hand-wavey and informal, but the gist as far as i understand it.)
11:58:47 <pjdelport> So by formally distinguishing data and codata (and by association recursion and corecursion) you gain the ability to rule out non-terminating functions.
11:59:30 <HeladoDeBrownie> I think the main reason bottom is necessary is because of that ability to recurse arbitrarily
11:59:43 <HeladoDeBrownie> In which case if you get rid of the latter, you can get rid of the former
11:59:51 <HeladoDeBrownie> Of course not being able to recurse at all would be boring
12:00:17 <pjdelport> statusfailed: By the way, the linked http://www.jucs.org/jucs_10_7/total_functional_programming is a very good paper!
12:01:04 <pjdelport> statusfailed: It makes a very good case for why total function programming matters
12:04:05 <frainfreeze_> I hear dfor haskell, and was told to learn it to easy my life in CS
12:04:06 <frainfreeze_> just heard*
12:04:23 <frainfreeze_> any warnings and things I should look for? good tutorial? or book? paid /free
12:05:01 <carter> @google learn haskell
12:05:02 <Taneb> @where lyah
12:05:02 <lambdabot> http://learnyouahaskell.com/
12:05:02 <hakujin> http://www.haskell.org/haskellwiki/Tutorials
12:05:02 <lambdabot> Title: Learn You a Haskell for Great Good!
12:05:02 <lambdabot> http://www.learnyouahaskell.com/
12:05:06 <carter> @google learnhaskell
12:05:07 <lambdabot> http://learnyouahaskell.com/
12:05:07 <lambdabot> Title: Learn You a Haskell for Great Good!
12:05:30 <carter> i meant http://bit.ly/1o0TJwB
12:05:41 <carter> links to a WHOLE bunch fo resource
12:05:42 <carter> s
12:05:52 <carter> @google learn haskell github
12:05:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:13:21 <frainfreeze_> thank you very much :)
12:13:24 <phserr> is there a function on the standard library that works like iterate but only returns the last value?
12:13:36 <phserr> just the repeated application of a function
12:13:53 <quchen> iterate f x !! n -- phserr
12:14:36 <HeladoDeBrownie> If you meant literally the last value of the infinite list, unfortunately there isn't one
12:14:46 <phserr> quchen: yes, but doesn't that make it store the whole list while doing this?
12:14:53 <HeladoDeBrownie> But there are other ways to approximate infinite applications depending on what you're doing
12:15:06 <HeladoDeBrownie> phserr, no, it's non-strictly evaluated
12:15:16 <phserr> HeladoDeBrownie: sorry, I meant for a given number of applications
12:15:29 <HeladoDeBrownie> Then yeah, quchen's suggestion would be it
12:15:57 <phserr> ok, thanks - still wrapping my head around laziness
12:16:02 <frainfreeze_> how is haskell comapred to python ?
12:16:33 <fruitz> two different programming pardigms
12:16:45 <fruitz> haskel is functional, while python is object oriented
12:16:45 <mauke> frainfreeze_: bearable
12:17:23 <frainfreeze_> i will learn haskell because of fucntional, but i m interested in speed and wrapping c++ libraries
12:17:29 <HeladoDeBrownie> frainfreeze_, if Haskell has many types, then Python has only one. Haskell also makes equational reasoning easy whereas Python doesn't. However, Python programs can more easily modify themselves than Haskell ones can.
12:17:52 <mauke> haskell doesn't require string eval to create a local scope
12:18:10 <frainfreeze_> i see
12:18:16 <frainfreeze_> well thanks a lot
12:18:38 <frainfreeze_> see ya :)
12:19:32 <HeladoDeBrownie> phserr, by the way, consider the implications of storing an entire infinite list in memory :)
12:20:28 <monochrom> self-modifying program is an ability I don't want.
12:20:39 <mauke> > cycle "ha"
12:20:40 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
12:20:49 <mauke> infinite list in finite memory
12:20:51 <HeladoDeBrownie> monochrom, not even to update modules while still running?
12:21:34 <merijn> monochrom: Not even Erlang style hot-code updates?
12:21:42 <chirpsalot> monochrom: It's an ability you always have in a Turing complete language.
12:21:59 <merijn> chirpsalot: No it isn't
12:22:05 <phserr> HeladoDeBrownie, haha - yeah, I see
12:22:39 <quchen> Brainfuck is a very simple complete language that makes it very obvious that you cannot modify the program using the program: data tape and instruction tape are strictly separate.
12:22:40 <phserr>  
12:23:00 <chirpsalot> merijn: yes it is. Implement an interpreter for a language that allows self modification?
12:23:00 <monochrom> I concede that hot update has benefits in limited situations
12:23:15 <merijn> monochrom: I've actually been thinking about type-safe self-modifying languages and how you could do something lisp machine-y with that, but it's hard to implement something like that sanely
12:23:26 <merijn> chirpsalot: That doesn't allow the interpreter to modify itself
12:23:33 <merijn> chirpsalot: So it's not self-modifying code at all
12:23:37 <chirpsalot> merijn: no, but it's effectively the same?
12:23:46 <merijn> chirpsalot: It just happens to be an interpreter that runs self-modifying code
12:24:09 <chirpsalot> merijn: I guess that's true, but it still gets you to the same problems.
12:24:21 <merijn> chirpsalot: Not really, because I can still verify the soundness of my interpreter, not of the language running inside it
12:24:22 <mauke> C is a purely functional language because you can write a Haskell interpreter in it
12:24:30 <Algebr`> editing .cabal files is so painful, feels like editing a makefile but worse
12:24:33 <monochrom> but bear in mind that if you even have reservations on mutable data, you should have more reservations on mutating programs.
12:24:47 <merijn> mauke: C is purely functional, didn't you read Conal's blog? ;)
12:25:24 <dv-> you can make pure functions with gcc
12:25:31 <pjdelport> It's all about which level of the onion you're at.
12:25:32 <dv-> with __attribute__ ((pure))
12:25:43 <mauke> dv-: or without
12:25:50 <bennofs> dv-: but gcc won't check that ot's actually pure, will it?
12:26:09 <hakujin> pure is a perf annotation iirc
12:26:23 <merijn> monochrom: Well, like I said, I like the idea of the lisp machines where the OS doesn't crash and just dumps you into a debugger to fix things. I'd like to have a staticaly typed variation of that, but without self-modifying code such a thing makes little sense
12:26:40 <dv-> bennofs: i don't think so. you can have it suggest which functions could be pure, but it won't contradict you
12:26:49 <Tuplanolla> That attribute allows reading mutable global variables if I'm not mistaken, dv-.
12:26:51 <merijn> monochrom: So the question is then: How to sanely model and restrict the effects of self-modification in the type system :)
12:27:16 <dv-> Tuplanolla: there's also the const attribute, which doesn't
12:27:26 <quchen> merijn: unsafeModifySelfIO? :-D
12:27:29 <Tuplanolla> Yes.
12:27:53 <exio4> and after 50 attributes, you're coding in java?
12:28:10 <quchen> merijn: Executing typed TH and splicing the result in at runtime is something that sounds like what you described
12:28:13 <dv-> an extremely fast and lean java, sure
12:28:17 <merijn> quchen: The biggest problem I'm having is that if you have something like Erlang processes (which seem nice) in a lazy language, how do you stop bottoms/bugs from leaking from process to process
12:28:46 <merijn> Speaking of which...
12:28:57 <merijn> Is anyone aware of any work on error handling in CSP?
12:29:11 <merijn> Or pi calculus, or whatever similar framework
12:29:16 <HeladoDeBrownie> Cerbel Space Program?
12:29:26 <monochrom> communicating sequential processes
12:30:15 <earthy> the erlang way is 'terminate process on fault' IIRC, and have a supervising process detect terminations
12:30:29 <monochrom> I know none other than "an error is just another possible message you receive"
12:31:01 * earthy nods
12:31:37 <merijn> monochrom: I was thinking "just deepseq/enforce totality outgoing messages"
12:31:51 <merijn> Although that still leaves you with byzantine errors, so it might not even help
12:32:09 <monochrom> it seems the poster-child example of CSP is the guts of a vending machine. wrong coin is then an example error. but you specify how to handle wrong coin in the same style as how to handle good coin.
12:33:31 <c_wraith> merijn: deepseq can also lie
12:33:52 <c_wraith> instance NFData Foo where rnf _ = ()
12:33:58 <merijn> c_wraith: In haskell, but I'm talking about a non-existent language I'm thinking of implementing
12:34:01 <c_wraith> ah
12:34:35 <monochrom> in other words from the calculus's point of view there is no such thing as error. there is only "if wrong coin, output one thing (give back the wrong coin); if good coin, output another thing (give back candies)". only us humans think of one of them as an error.
12:34:38 <merijn> monochrom: Sure, that's the "use an ADT" type of error
12:34:59 <squidz> what is the best way to write this line in haskell? someFn (someFn (someFn someFnData)) ? Any way to do this without the parenthesis?
12:35:10 <mauke> that is the best way
12:35:13 <Rembane> squidz: $ to the rescue!
12:35:23 <merijn> Rembane: I hope you mean . to the rescue
12:35:25 <c_wraith> squidz: there's always ways to do it without parens.  *always*.  that doesn't mean they're better. :)
12:35:27 <monochrom> but who knows, a dentist such as the one in Charlie and the Chocolate Factory thinks that the good coin is an error, because it gives back teeth-damaging candies.
12:35:40 <c_wraith> squidz: you can always use local name bindings to avoid parens, in any situation
12:35:45 <Rembane> merijn: Nope, it will need more characters. :)
12:36:07 <shachaf> c_wraith: Always?
12:36:10 <merijn> monochrom: Like, I don't know if there's any work on trying to enforce properties on a concurrent system
12:36:18 <platz> there's a thread with simon marlow compraing some of the channels in go with haskell https://plus.google.com/109566665911385859313/posts/FAmNTExSLtz
12:36:42 <shachaf> c_wraith: OK, local bindings is a pretty good (awful) trick, but what about a case where you have an uninferrable rank-n type?
12:36:43 <merijn> Rembane: . is better because you can *always* replace a dot composition with a local name binding, that's not true for $
12:36:45 <c_wraith> shachaf: Hmm.  Except for tuples.  Every *other* use of parens can be eliminated.  Unless I'm forgetting something else
12:36:56 <platz> One question is if you want asynchronous channels or not
12:36:58 <Rembane> merijn: That's very nice. I haven't thought of that.
12:37:05 <squidz> c_wraith: how would local bindings prevent the parenthesis?
12:37:06 <platz> I think CSP is synchronous by default
12:37:21 <shachaf> convert f (g x) into let y = g x in f y
12:37:34 <merijn> platz: That I haven't even considered yet
12:37:36 <platz> but the cases where you actually want asynchronous may be less
12:37:48 <c_wraith> squidz: let x = someFn someData ; y = someFn x in someFn y
12:38:03 <c_wraith> squidz: it's terrible, but there aren't parens!
12:38:12 <Tuplanolla> Consider f . g . h $ x or f . g $ h x, squidz.
12:38:19 <merijn> Actually, I think I've nailed down the problem I was having trouble thinking about
12:38:24 <monochrom> then look for "CSP model checking". you specify temporal properties like "always (leads-to input-wrong-coin output-coin)"
12:38:45 <merijn> Of course, now I realise that problem is nearly intractably hard, but, oh well, gotta do something with your spare time... :p
12:38:56 <platz> I copied some of marlow's code here http://lpaste.net/110311
12:39:04 <squidz> okay, in clojure they have something called the threading macro which looks looks like: (-> SomeFnData someFn someFn someFn) I assume there is nothing like that in haskell right?
12:39:20 <c_wraith> squidz: just use . to do that
12:39:30 <merijn> monochrom: Yeah, I've done mu calculus style formal verification for distributed systems before, but that does offline model checking and requires insane amount of resources
12:39:36 <squidz> c_wraith: okay thanks
12:39:43 <c_wraith> squidz: the . operator has the advantage of working with functions to create functions.
12:39:48 <hakujin> someFn . someFn . someFn $ SomeFnData
12:39:51 <c_wraith> squidz: so there's nothing magical going on
12:40:00 <monochrom> oh, runtime verification exists too, CSP or finite automata or anything really
12:40:01 <squidz> yeah of course normal functions are preferable
12:40:03 <c_wraith> squidz: unlike macro expansion, which is basically always magic
12:40:03 <merijn> I wonder if there's a way to semi-sanely embed properties about this in a type system...
12:40:21 <monochrom> look for the conference called "RV" (runtime verification)
12:40:45 <merijn> monochrom: ok, thanks
12:41:14 <monochrom> generally, leave behind the functional programming community and join the formal methods community (which is mainly imperative) :)
12:41:28 <monochrom> all the functional programming community knows is Coq. very limiting.
12:41:42 <monochrom> they haven't even heard of PVS, for God's sake.
12:41:50 <statusfailed> what's PVS?
12:41:58 <monochrom> (which has dependent typing and predicate subtyping)
12:42:08 <oleo> proof verification system ?
12:42:26 <monochrom> PVS is at http://pvs.csl.sri.com/
12:43:03 <squidz> okay so then I am looking for: (someFn . someFn .... someFn) SomeFnData thanks
12:43:34 <merijn> monochrom: :(
12:43:42 <hakujin> squidz: you can use $ to avoid the parens around (someFn . someFn ..) SomeFnData if you prefer
12:43:53 <hakujin> someFn . someFn $ SomeFnData
12:44:29 <hakujin> the parens make it obvious that you're using function composition though
12:45:00 <squidz> hakujin: ah that's even better thanks
12:45:13 <squidz> exactly what I came in to ask. Thanks
12:51:25 <hakujin> will someone explain the advantage of getChanContents vs a looped readChan?
12:52:03 <hakujin> from Control.Concurrent.Chan
12:52:05 <merijn> hakujin: You can pass the list to a pure function expecting a list
12:52:06 <yesthisisuser> What is the most sensible way to keep track of version number in an application where you'd have various references to it, such as from a command line --version invocation, server response headers etc.
12:52:26 <mauke> global variable
12:52:30 <merijn> yesthisisuser: Cabal provides you with a Paths_foo module that exports a variable for the version number
12:52:50 <merijn> yesthisisuser: I forget the details, but that way it'll automatically be in sync with your cabal version
12:53:00 <chrizz> hello, I'm new to GADTs, trying to write a parser where the type I'm parsing is a GADT. Is this a good idea? Running into a type error... http://lpaste.net/110312
12:53:12 <yesthisisuser> merijn: sounds like what i need.. thanks
12:53:38 <vanila> chrizz, you can't really do this
12:53:59 <vanila> chrizz, parseFoo would have to have type String -> Foo A or String -> Foo B, but you don't know hwich when you're looking at the string
12:54:14 <hakujin> merijn: yeah that's great but say I pass it to foldM, when observing the side effects (let's say IO for each chan item) it seems like they're basically identical
12:54:26 <chrizz> vanila: right, so i have to stick with an ADT then? are there any other "tricks" i can employ here?
12:54:56 <vanila> chrizz, It's a good idea to use an ADT for parsing, thne you can have another 'typechecking' stage that attempts to produce a GADT from that "untyped" ADT
12:55:10 <monochrom> chrizz: I think that in practice you may not need to actually solve this example
12:55:36 <vanila> I'm assuming this code is a simplified example of the problem :p
12:55:51 <hakujin> merijn: I guess my question is better stated as 'what is unsafeInterleaveIO doing here?'. I'll go read up. thanks.
12:56:01 <chrizz> monochrom: here's my use case, I'd like a client to handle certain Foos but not have to pattern match on every sum. something like: handleFooA :: Foo A -> IO ()
12:56:10 <merijn> hakujin: unsafeInterleaveIO is like lazy file IO
12:56:23 <chrizz> monochrom: where 'Foo B' for whatever reason doesn't concern the client
12:56:35 <merijn> hakujin: Basically you execute the action and get a list and the list is "secretly" doing IO to fetch items on demand from the Chan
12:56:47 <monochrom> then the parser is String -> Maybe (Foo A), no?
12:56:50 <chrizz> right
12:56:52 <vanila> your client is a programmer?
12:56:56 <merijn> hakujin: So it pretends to give you an infinite lazy list of all items ever written to the Chan
12:57:03 <hakujin> merijn: assuming one producer to a bunch of dupChans they should be identical in practice right?
12:57:15 <monochrom> so you don't really need a type variable
12:57:36 <chrizz> well, an attoparsec Parser
12:57:42 <funfunctor> howdy
12:57:45 <vanila> hi
12:57:45 <chrizz> vanila: yeah
12:57:53 <monochrom> by that I mean: the parser's type does not really need a type variable. nothing wrong with using GADT for this.
12:58:12 <chrizz> monochrom: ?
12:58:35 <monochrom> String -> Maybe (Foo A) does not contain a type variable
12:58:51 <chrizz> monochrom: but the overall parser might return a Foo A or a Foo B
12:58:52 <monochrom> and you can pretty much say that "b" is a parse error
12:59:39 <vanila> Or you could keep it String -> Foo, then have a separate stage checkA :: Foo -> GADTFoo A
12:59:40 <yesthisisuser> aah.. foo = myproject .. (Paths_foo) ... it took me some time .. :) LOL
12:59:42 <vanila> sorry
12:59:47 <monochrom> perhaps don't use the overall parser.
12:59:54 <vanila>  checkA :: Foo -> Maybe (GADTFoo A) as monochrom said
13:01:34 <monochrom> perhaps vanila's two stages (an untyped stage and a typed stage) is best afterall
13:02:20 <merijn> Sounds like someone other than me wants impredicative types :p
13:02:36 <merijn> I really need to convince someone to get a phd by implementing those in Haskell :<
13:02:41 <chrizz> vanila: let's say there are 10 sums, and 5 of which are interesting to the client, for example. wouldn't I have to run a checkFooA :: Foo -> Maybe (GADTFoo A), checkFooB :: Foo -> Maybe (GADTFoo B), etc. on every Foo, and then if it's Just, pass the un-Maybe'd GADTFoo to the client?
13:02:51 <monochrom> no no, even in the worst case, an existential type can solve this one. I just don't want to get to that too soon.
13:02:51 <chrizz> that seems wrong to me
13:03:41 <merijn> monochrom: Sure, but impredicative types would too and impredicative types always struck me as more principled than existentials
13:03:58 <chrizz> how could an existential help here?
13:04:04 <vanila> chrizz, it's hard for me to understand this being phrased in terms of client
13:04:09 <vanila> why don't you just give them the whole GADT
13:04:14 <merijn> chrizz: Wrap Foo with an existential hiding the phantom?
13:04:18 <monochrom> there are a lot of people who want to get a PhD related to Haskell. I think you will find limitless supply. but I can't assure you about quality.
13:04:36 <merijn> monochrom: Then why are none of them implementing impredicative types? :(
13:04:59 <monochrom> they haven't heard that it's needed. you need advertise more. :)
13:05:03 <chrizz> vanila: ok, concrete case: an IRC 'Message' type is a big sum type (PING, PRIVMSG, TOPIC, etc.). an IRC client, however, really only cares about privmsgs, so I'd like to let the client write a handler function like: handlePrivMsg :: Message PrivMsg -> IO (), for example
13:05:20 <chrizz> without having to write an empty case for handling a TOPIC message which the server would never send it
13:06:02 <vanila> chrizz, okay so you have a data type and wish to carve out parts with a type index. a GADT does this well
13:06:08 <monochrom> I wouldn't even do that.
13:06:14 <merijn> chrizz: The problem is that without dependent types, parsing a GADT like that is really messy
13:06:21 <chrizz> vanila: but then how do i write the parse function ByteString -> Message, :P
13:06:41 <merijn> vanila: Sure, but parsing a GADT is messy without dependent types
13:07:06 <monochrom> presumably the PRIVMSG case has 3 parameters: Nick, Host, Msg. then I would simply do handlePrivMsg :: Nick -> Host -> Msg -> IO ()
13:07:31 <monochrom> that is, handlePrivMsg does not even know the sum type
13:07:52 <chrizz> monochrom: yeah... that will work just fine. I
13:07:56 <chrizz> I'm dumb. Thanks
13:08:16 <Markz> GHCi runtime linker: fatal error: I found a duplicate definition for symbol _hs_text_memcpy
13:08:20 <Markz> any ideas?
13:08:28 <HeladoDeBrownie> chrizz, there's no need to disparage yourself like that, this is a learning process
13:09:11 * monochrom does not like this "everyone has high self-esteem" Brave New World dystopia
13:09:24 <chrizz> thank you, Ice Cream of Brownie - and I know, I just had an 'aha' moment with monochrom's comment so it made me feel dumb
13:09:34 <monochrom> it's normal and healthy to go low and then rebounce
13:10:03 <merijn> chrizz: tbh, the "tagging message types with a GADT" approach makes total sense and I've used it in 3 projects so far :)
13:10:13 <monochrom> it's as abnormal and unhealthy to always stay high as to always stay low
13:10:22 <merijn> chrizz: The only problem is that it doesn't work very well with messages/data that comes from the network/disk/etc.
13:10:33 <chrizz> merijin: did you have to parse any of those messages, though?
13:10:37 <chrizz> ah
13:10:46 <Odda> I can't seem to get my head around how do deserialize back from BSON. Is there a mechanism like with Aeson, parseJSON (Object v) ..., or do I have to write one myself?
13:11:09 <HeladoDeBrownie> monochrom, I don't think I was saying otherwise, however it's entirely possible I have some cognitive dissonance on this topic.
13:11:37 <merijn> chrizz: Because then you want to write something like "Parser (forall (a :: MsgType) . Message a)", which is not something haskell's type system is powerful enough to express
13:11:58 <chrizz> merijin: even with DataKinds and ConstraintKinds?
13:12:07 <merijn> chrizz: Even then
13:12:18 <chrizz> ok, I believe you, I've never tried
13:12:31 <merijn> chrizz: If you find you want that, you might wanna start looking into Idris ;)
13:12:58 <chrizz> It's on my to-do list, right after Haskell
13:13:06 <chrizz> which will only take another 8 years
13:13:49 <chrizz> thanks all, battery is about to die!
13:13:51 <chrizz> bye
13:20:01 <anannie> I have a math heavy question. If someone is trying to figure out the "influence" of an individual node within a social network by tracking how articles are shared can this problem not be visualised as an inverse of the path finding problem? By tracking the path taken by a particular piece of content through the graph and associating individual weights with nodes through which the content was propagated, we are in a way creating the basis of a
13:20:01 <anannie> weighted graph through which we can predict content propogation or the biggest path that an item will take when dropped onto the graph?
13:20:08 <anannie> Is my understanding wrong?
13:26:28 <merijn> anannie: You're probably thinking of something along the lines of betweenness centrality, which can be implemented as doing a bunch of BFS traversals, yes
13:27:38 <merijn> anannie: Betweenness centrality is a measure that indicates "of all shortest paths between nodes, how many paths is this node part of"
13:27:42 <anannie> merijn: Yes, I am.
13:28:36 <merijn> anannie: So I'm not sure if it can be called "the inverse of path finding" as it involves just ordinary path finding for the cartesian product of all nodes in the graph
13:29:46 <anannie> merijn: So the example I'm looking at tries to figure outif a node is important within a social network by looking at the number of shares and other stuff. I called it inverse of path finding, because they track the spread of an item and they try to correlate influence  or betweeness centrality with the spread. I think that it can be improved, because if fundamentally this is pathfinding then there are far more direct measures that can be used
13:29:47 <anannie> beyond tracking content labouriously
13:30:41 <merijn> anannie: I think the problem you'll run into in social networks is that people distribute content on some sort of grouping of social circles among their connections
13:31:06 <merijn> anannie: So the tracking of content distribution tracks this grouping, just the path component doesn't tell you that grouping
13:31:41 <anannie> merijn: But if you are indeed finding the path, then is it not possible to do clique detection as well?
13:34:49 <merijn> I have yet to find a thorough (that is, non-handwavey heuristic-y) definition of clique detection :)
13:34:52 <merijn> So "maybe"?
13:36:44 <anannie> merijn: I'm trying to learn, so a maybe is good enough for me to proceed with. Thank you.
13:36:56 <anannie> merijn: Either way I learn something and it's all good
13:38:48 <funfunctor> hi I built https://gist.github.com/victoredwardocallaghan/e8efa1225f658c2c0a3b to test my haddock coverage at build time to ensure my project maintains good documentation.
13:39:10 <fizbin> Is there a better/more recommended way to get access to MonadIO than:
13:39:12 <fizbin> import Control.Monad.IO.Class (MonadIO, liftIO)
13:39:25 <funfunctor> problem is I have a couple of files generated at build time that don't need docs, how could I avoid scanning those?
13:39:28 <Algebr> What is the intuitive defintiion of a combinator?
13:39:47 <funfunctor> e.g. Paths_consoleui
13:40:42 <funfunctor> I tried {-# OPTIONS_HADDOCK hide, prune #-} at the top of the generated files with no such luck
13:40:42 <quchen> Algebr: A combinator is a lambda expression without free variables, also known as a closed lambda expression.
13:40:58 <quchen> Algebr: In Haskell land, the term is often misused to say "a function that combines stuff".
13:42:01 <anannie> merijn: Ha I just realised that for Facebook, doing this in a naive way would require me to find the shortest path 9.8 * 10e8565705522 times
13:42:22 <monochrom> heh
13:42:31 <merijn> anannie: :)
13:42:52 <anannie> I wonder if that's bigger or smaller than the age of the universe.
13:42:59 <anannie> (in terms of computation time)
13:43:05 <merijn> anannie: Did you plan to actually run this on the facebook graph? :p
13:43:16 <anannie> merijn: Of course not.
13:43:26 <anannie> merijn: I'm just fooling around...
13:43:57 <fizbin> What graph library are you using?
13:43:58 <merijn> anannie: Well, if you're interested in real world test data: http://snap.stanford.edu/data/ :)
13:44:28 <lakers282> @search triumph of the spirit
13:44:29 <lambdabot> Unknown command, try @list
13:44:44 <lakers282> @list triumph of the spirit
13:44:45 <lambdabot> No module "triumph of the spirit" loaded
13:44:50 <lakers282> @list
13:44:50 <lambdabot> What module?  Try @listmodules for some ideas.
13:44:57 <lakers282> @listmodules
13:44:58 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:45:00 <anannie> fizbin: Right now, I'm not using any. I'm reading code.
13:45:34 <lakers282> @list search triumph of the spirit
13:45:34 <lambdabot> No module "search triumph of the spirit" loaded
13:45:50 <geekosaur> lakers282, this bot is not your warez/piracy search tool, please stop
13:46:59 <fizbin> I've been using fgl for some internal graph-heavy stuff. I go from thinking it's okay, to thinking it's a pretty neat way to do graphs in an immutable-data-structures language, to thinking it's a steaming pile of inadequacy multiple times per day.
13:47:18 <dlnx`> geekosaur: let the poor guy fiddle with the bot :v
13:47:42 <hakujin> dlnx`: why? he's searching for a movie, not haskell
13:47:48 <anannie> fizbin: :(
13:47:49 <geekosaur> they can do it in pm if they need to prove to themselves that this is not whatever bot they think it is
13:48:03 <dlnx`> well
13:48:25 <fizbin> anannie: Well, on the other hand I'm now most often in "okay" mode, since I figured out how to do what I wanted to do and the result is fast enough.
13:48:27 <merijn> fizbin: Like a lot of libraries it seems to designed for mostly tiny graphs
13:48:32 <Tuplanolla> What do you expect to get from searching a movie anyway?
13:49:28 <fizbin> So I might grumble that its organized in a way that makes some thing I'm doing horribly inefficient, but it's never been so bad that I've actually gone and rolled my own IntMap-based representation.
13:50:04 * hackagebot git-annex 5.20140831 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140831 (JoeyHess)
13:50:25 <fizbin> merijn: I'm mostly dealing with "small" graphs anyway, on the order of 5K-100K nodes.
13:51:37 <kyfho> how important is it to use haskell platform vs ghc by itself?
13:53:13 <monochrom> that depends on which libraries you want
13:54:29 <kyfho> I am primarily interested in happstack
13:55:38 <kyfho> cant you use ghc to download from hackage anything you want?
13:55:44 <kyfho> hm
13:55:52 <kyfho> haskell does seem really cool
13:55:52 <kyfho> :)
13:56:14 <heatsink> Cabal is an installer and build system that can download packages from hackage.
13:56:18 <fizbin> kyfho: ghc by itself doesn't come with cabal.
13:56:40 <fizbin> kyfho: And cabal is the tool that pulls in extra packages.
13:57:30 <fizbin> If you're not on a Linux system, you really want the haskell platform. On linux, you probably want both ghc and cabal however your distro has packaged them.
13:57:41 <kyfho> openbsd here
13:57:43 <monochrom> happstack uses a few libs included in Haskell Platform. but probably not many enough to say you must start with Haskell Platform.
13:57:53 <kyfho> it has haskell platform 2013.2 I think not 2014
13:58:07 <kyfho> Installing now..
13:58:09 <fizbin> Then use that.
13:58:13 <kyfho> k
13:58:21 <fizbin> From the openbsd ports system, yes?
13:58:29 <kyfho> no just packages
13:58:41 <kyfho> hmm god point maybe ports has newer..
14:08:54 <bydo> last time I tried on OpenBSD I couldn't cabal install cabal-install, but didn't try hard enough to make it work
14:10:17 <kyfho> hm
14:10:34 <kyfho> perhaps I have pain ahead
14:10:48 <kyfho> what nix is haskell developed on ? if linux what distro?
14:12:07 <halvorg> Hi, I have a map m :: Data.Map.Strict K V and a function f :: K -> V -> Bool. I want to delete every element from the map where f == True, how do I do that?
14:12:39 <halvorg> uh, filterWithKey .D
14:12:42 <simpson> :t M.filterWithKey -- halvorg
14:12:43 <lambdabot> (k -> a -> Bool) -> M.Map k a -> M.Map k a
14:13:01 <halvorg> yeah I just realized it, thanks
14:13:10 <monochrom> nice
14:19:52 <ij> I was just wondering, how does Data.Map store stuff inside it? I have an idea how hashmaps work, but this doesn't seem like a hashmap.
14:20:15 <simpson> ij: It's a tree.
14:20:34 <monochrom> balanced binary search tree
14:21:06 <coppro> red-black, probably?
14:21:27 <monochrom> actually no, some other balance criterion
14:21:41 <quchen> The docs mention the paper it was built after. http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
14:22:43 <ij> Almost all Map functions have Ord restriction on key. Wouldn't it be more sensible to put it in the data definition?
14:22:58 <coppro> ij: No, because the functions would need the constraints anyway
14:23:06 <coppro> it's a limitation of the languag
14:23:08 <coppro> *language
14:23:11 <HeladoDeBrownie> ij, no, because some operations don't require those constraints and it wouldn't obviate the others needing them
14:23:25 <quchen> ij: That's a question often asked. This might help. https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
14:23:50 <HeladoDeBrownie> That is a helpful url to know, I'll have to keep it in mind for next time.
14:24:11 <monochrom> even if I have a choice, I still like the constraint repeated at every function type.
14:24:29 <coppro> it's kind of annoying when dealing with complex classes
14:24:51 <monochrom> I'm a reader and I want to read less and deduce more.
14:25:30 <monochrom> by "less" I should word precisely as "more locally"
14:26:39 <jjohnsson> Does anyone know how to match a whole line in attoparsec if it contains a certain substring (like grep)? I have read a couple of tutorials and tried a few things myself but have failed, though I feel it should be simple. :(
14:27:54 <quchen> do { x <- parseLine; if "foo" `isSubstringOf` x then … else … }
14:28:06 <quchen> Conceptually.
14:29:45 <jjohnsson> thanks, I’ll try that. :)
14:29:47 <ij> quchen, I see, thanks. Your page is cool.
14:30:23 <quchen> jjohnsson: This won't backtrack though. It will parse one line and then work with whatever was in there.
14:30:47 <jjohnsson> ok.
14:51:49 <Algebr```> is there utility that given a file, it tells you what program and use it?
14:51:55 <Algebr```> can*
14:52:42 <HeladoDeBrownie> Algebr```, I can think of something close, the file utility, which tells you what format a file is in.
14:53:12 <HeladoDeBrownie> Comes standard with most Linux distros as far as I'm aware.
14:55:01 <geekosaur> xdg-mime maybe
14:55:25 <geekosaur> (xdg-mime query filetype and then xdg-mime query default)
14:59:19 <tlo> again a beginner question, thanks for your patience! Looking at http://www.haskell.org/haskellwiki/99_questions/Solutions/7 (the solution without concatMap), I can run "flatten (List [])" successfully in ghci. But if I call this in "main" and try to print the result I get "No instance for (Show a0) arising from a use of `print'".
15:00:05 <tlo> ... while "print $ flatten (Elem 5)" does work.
15:00:39 <geekosaur> tlo: an empty list is a list of an unknown type
15:01:00 <Algebr```> can point free style be used with do notation?
15:01:30 <geekosaur> for some things Haskell will try to infer a type anyway (for example, if it uses math functions it will infer Double or Integer), but in your case all it knows is "a list of something"
15:01:36 <HeladoDeBrownie> Algebr```, the question doesn't quite make sense, but to roll with the intent, do notation desugars to function applications that can be used in a point-free manner.
15:02:13 <tlo> geekosaur: hm, but in ghci I can do "print []"
15:02:58 <geekosaur> tlo: yes. the rules for when it can infer types are somewhat strange
15:03:29 <geekosaur> (some of us think they were ill-considered, specifically because of confusion like this)
15:04:14 <tlo> geekosaur: ok, thanks for the information
15:05:00 <geekosaur> I'd have to refer you to the haskell language report for more. just try to keep in mind that sometimes it will guess types and other times it'll give you an error saying that you need to tell it which type to use
15:05:37 <geekosaur> most commonly with things like empty collections (lists, sets, maps, etc.) which tend to break the defaulting rules
15:06:05 <trap_exit> in haskell, is there a way to store Haskell-pattern-matching "as data" ?
15:06:18 <geekosaur> ("break" in the sense that depending on how they occur they will prevent application of defaulting)
15:07:18 <geekosaur> trap_exit, they're not first class, no
15:07:30 <geekosaur> ignoring something like template haskell
15:07:33 <trap_exit> geekosaur: damn, this makes it harder to write a theorem prover
15:07:45 <trap_exit> I miss lisp "code is data; data is code"
15:08:12 * geekosaur wonders what the type of a pattern-as-data would be. and how one would apply it
15:09:05 <trap_exit> Given (1) an instance of a recursive data structure, (2) a 'regex/cfg over data types', (3) tell me if (1) matches (2)
15:09:18 <trap_exit> and if so, what the vars/holes in (2) are bound to
15:11:20 <geekosaur> trap_exit, I don;t think there's a need to use haskell's built in pattern matching to implement your own
15:11:47 <geekosaur> think of it this way: that would be what interpreters call "eval"
15:11:55 <trap_exit> so a "tactic langauge" is like a DSL in haskell
15:12:07 <trap_exit> and I need to decide whether to embed 'deeply' or 'shallowly' in haskell
15:12:08 <geekosaur> (and that also tells you one way you could do it, if you think you need to)
15:12:24 <trap_exit> I'd prefer shallow so I can use as much of Haskell myself as possible, rather than implement as-complicated-an-interpreter myself
15:12:40 <trap_exit> oh, eval is easy
15:12:45 <trap_exit> is System.IO ("ghc .... ")
15:12:58 <simpson> Design your language, then design a language that is good for implementing that language.
15:13:04 <geekosaur> I was thinking hint or ghc-api
15:13:42 <trap_exit> simpson: oh, the language is _not_ clear in my mind yet
15:13:50 <geekosaur> but, I think you don't necessarily want Haskell pattern matching directly, because it does more than just pattern matching. I called it "eval" for a reason: it's what forces evaluation to happen at all
15:13:51 <trap_exit> I was hoping haskell's compiler would help me flesh out the data types
15:14:05 <simpson> trap_exit: No worries. It takes a year or two to design a good language. Sometimes longer.
15:14:36 <trap_exit> well, if that's the case, I should cook lunch first
15:14:55 <simpson> Lunch is a great idea. And requires no extra parsing.
15:15:49 <tel> I was fiddling with finally tagless de bruijn lambda calculus and made something weird. I'd appreciate any analysis or recognized connections
15:15:51 <tel> https://gist.github.com/tel/8afd2058dd3fc73c10b2
15:16:33 <tel> In particular, I'm curious what's going on with that Loop constructor and how this relates to profunctors
15:22:23 <ramfjord> Hey guys
15:22:35 <ramfjord> I'm completely new to haskell
15:22:52 <ramfjord> trying to learn about about it through writing a sql formatter
15:22:59 <ramfjord> a bit about*
15:23:24 <jle`> ramfjord: cool :D
15:23:28 <Iceland_jack> Welcome ramfjord
15:23:36 <ramfjord> can explain why this line is giving me these errors?
15:23:40 <ramfjord> data ColumnArg :: ColumnArg String (Maybe String)
15:23:41 <trap_exit> hmm, in Haskell, is Exception just a monad
15:23:48 <trap_exit> since it's just another way of composing computations?
15:23:59 <Iceland_jack> ramfjord: You need "=" instead of "::"
15:24:16 <ramfjord> ugh....
15:24:17 <ramfjord> thanks
15:24:23 <jle`> ramfjord: i might suggest following some sort of guide or lesson plan if you are completely new, though...it'll get a lot of small questions like this out of the way
15:24:32 <jle`> like a book
15:24:43 <jle`> not that we aren't happy to answer them :)
15:24:59 <ramfjord> I've gone through a couple of them
15:25:03 <jle`> ah, ok
15:25:07 <jle`> so not 'completely new'? :)
15:25:24 <ramfjord> well, only things I've written previously were project euler probs
15:25:24 <Iceland_jack> ^
15:25:36 <Iceland_jack> ramfjord: Did you finish the books?
15:25:36 <jle`> ah
15:25:59 <ramfjord> Iceland_jack: most of the way through learn you a haskell
15:26:15 <jle`> trap_exit: a monad in what sense?
15:26:15 <ramfjord> recently a co-worker made a good effort of drunkenly explaining monads
15:26:19 <ramfjord> rekindled interest
15:26:28 <jle`> trap_exit: does it have return and join/bind?
15:26:36 <trap_exit> jle`: a monad in the sense of http://www.haskell.org/haskellwiki/Exception
15:27:06 <Iceland_jack> ramfjord: You might benefit going through those books again and writing code to go along with it
15:27:36 <jollygood> is there a foldM equivalent that takes a function as the last parameter? mapM -> forM, foldM -> ??
15:28:23 <jle`> trap_exit: well, (Either e) is a Monad
15:28:47 <jle`> and so is EitherT e m/ErrorT e m, where m is a Monad
15:28:54 <jle`> but GHC exceptions are a different matter altogether
15:29:00 <jle`> "Exception"
15:29:03 <jollygood> @hoogle a -> [b] -> m a -> (a -> b -> m a)
15:29:06 <lambdabot> Text.Parsec.Error showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
15:29:06 <lambdabot> Text.ParserCombinators.Parsec.Error showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
15:29:06 <lambdabot> GHC.IO.Buffer Buffer :: RawBuffer e -> BufferState -> Int -> Int -> Int -> Buffer e
15:29:09 <trap_exit> hmm
15:29:11 <Iceland_jack> trap_exit: Monads can represent failure so you can reify certain errors as monads, but exceptions as a concept are not monads
15:29:21 <trap_exit> you inow, for my need, Either with suffice
15:29:32 <trap_exit> jle`, Iceland_jack: however, for sake of knowledge, tell mea bout GHC excpetions
15:29:41 * Haskellfant listens up
15:29:52 <Haskellfant> I haven't really understood ghc exceptions so far
15:29:55 <Iceland_jack> trap_exit: They're quite similar to exceptions you'd see in other languages
15:30:06 <jle`> GHC Exceptions are a neat tool provided by GHC's haskell runtime system
15:30:12 <trap_exit> that is useless
15:30:12 <trap_exit> the first rule of haskell
15:30:15 <trap_exit> is give up all pre-conveiced notions
15:30:27 <Iceland_jack> Except GHC also has excellent support for asynchronous exceptions
15:30:33 <blablaa> someone knows the haskell repa package?
15:30:43 <blablaa> i'm wondering if it can be used together Eval monad
15:31:01 <jollygood> @hoogle  Monad m => a -> [b] -> (a -> b -> m a) -> m a
15:31:02 <Iceland_jack> Chapter 9 of Parallel and Concurrent Programming in Haskell talks about (async) exceptions: http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
15:31:02 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:31:02 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
15:31:03 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
15:31:41 <blablaa> Iceland_jack, we're reading same book it seems :)
15:31:45 <jle`> when you compile/execute an IO action, the IO action is executed in a runtime environment, which provides a lot of neat things for building a useful program.  exceptions is one such tool.  the link that Iceland_jack posted is a really good introduction
15:31:47 <Haskellfant> doesn't haskell kinda loose it's error safeness with exceptions?
15:31:48 <blablaa> Iceland_jack, what about combining repa with Eval? is it possible?
15:32:24 <simpson> Haskellfant: Hm. What kind of error safety are you thinking of?
15:32:35 <blablaa> Haskellfant, no because haskell functions are *partial* anyway
15:32:53 <blablaa> Haskellfant, a pure function throwing an exception is no worse than one divering
15:32:59 <blablaa> divergin
15:33:17 <Iceland_jack> blablaa: It's possible to evaluate two repa computations using Eval sure
15:33:34 <blablaa> Iceland_jack, but will they create too many threads overall?
15:33:34 <Haskellfant> simpson: e.g. null pointer exceptions. typically I cannot get them and if I need something like that I have an explicit maybe which forces me to handle the Nothing case (or at least explicitly ignore it using fromJust)
15:33:41 <Haskellfant> blablaa: hm k
15:33:46 <blablaa> Iceland_jack, i'm afraid Eval makes N threads, repa N too, we've 2N instead of N
15:33:49 <Iceland_jack> blablaa: Won't create threads but sparks
15:33:59 <Iceland_jack> Haskell threads are cheaper than OS threads
15:34:01 <blablaa> Iceland_jack, ok but there are sparsk evaluators
15:34:04 <Iceland_jack> Sparks are cheaper still
15:34:16 <blablaa> Iceland_jack, i was referring to system threads in fact
15:34:46 <jle`> Haskellfant: if you already understand how fromJust fits into things, then..
15:34:48 <jle`> hm
15:34:50 <jle`> @src fromJust
15:34:50 <lambdabot> fromJust Nothing  = undefined
15:34:50 <lambdabot> fromJust (Just x) = x
15:34:54 <jle`> @src undefined
15:34:54 <lambdabot> undefined = error "Prelude.undefined"
15:35:21 <jle`> (...i hope that's nto how it's actually implemented)
15:35:35 <simpson> Those look about right.
15:35:39 <jle`> ok, it's not
15:35:45 <jle`> good
15:35:54 <jle`> fromJust Nothing = error "Maybe.fromJust: Nothing"
15:35:55 <jollygood> while we are on that fromJust definition, according to documentation compiler is supposed to replace "undefined" with more meaningful error messages,but I have not found that to be the case whenever I tried to use undefine
15:36:10 <jollygood> why is that?
15:36:27 <simpson> Haskellfant: Well, IO can have errors that can't be handled outside of IO. This isn't a problem since IO is generally where people are running code.
15:36:30 <c_wraith> jollygood: it says that the compiler *may* replace undefined with something more meaningful.  GHC doesn't.
15:36:54 <jollygood> why doesn't it?
15:36:58 <ryantrinkle> given a live weak reference to a haskell value, how would i go about determining what's retaining it?
15:37:01 <c_wraith> jollygood: remember, GHC is only an implementation of the standard, not the definition of it
15:37:07 <jollygood> yeah
15:37:10 <ryantrinkle> (not retainer profiling - i'm looking to do this for a particular object, not the entire heap)
15:37:29 <d-snp> anyone know if I can use Data.Aeson to read in a YAML file, and output it as JSON, without typing its structure?
15:37:30 <Haskellfant> simpson: I guess what I don't like (probably because I haven't understood it) is that I need to look at the docs or the source of a function to see which exceptions it can throw or just catch all exceptions  when I do
15:37:43 <Haskellfant> call a function that could throw one
15:37:54 <jollygood> c_wraith hackage docs make a bit stronger claim than "it may". it says it is expected that implementations do this
15:38:18 <c_wraith> d-snp: if it's using the subset of YAML that is JSON, sure.  remember that aeson provides the Value type for all JSON
15:38:27 <simpson> Haskellfant: Well, why would you catch an exception if you don't intend to handle it?
15:39:17 <c_wraith> simpson: the standard reason is stuff like finally
15:39:25 <Haskellfant> I'm fine with catching it. I guess what I would really want is checked exceptions to see which exceptions a function is supposed to throw
15:40:04 <jle`> yeah, runtime exceptions aren't quite encoded in the type, so it can be a bit unlike working with other haskell things
15:40:09 <d-snp> c_wraith: ohh so I should decode as FromJSON Value, and then I can easily just encode it again?
15:40:25 <jollygood> Haskellfant I thought I wanted that as well.. Until I used them in Java
15:40:28 <c_wraith> d-snp: err.  Just decode as a Value.  FromJSON is the class
15:41:49 <nh2> does `cabal haddock` have CPP support?
15:41:58 <jollygood> thing is, you don't usually want to catch exceptions only one level below, so vast majority of the time you end up catching and then rethrowing them
15:42:12 <nh2> when I have a CPP variable behind a flag, then cabal haddock seems to ignore that
15:42:27 <hseg> Is it possible to write a function withEqDict :: (a -> a -> Bool) -> (Eq b => c) -> c which instantiates the Eq instance that the second parameter expects so that (==) is the first parameter?
15:42:42 <jollygood> think of readLine implemented with readChar. it can't do anything more sensible than just rethrow all the IO exceptions
15:42:53 <hseg> i.e. create a function-local instance and evaluate a function using it?
15:43:29 <c_wraith> hseg: I believe it is with enough extensions - and that it breaks every assumption about instances that people rely on.
15:43:46 <hseg> Oh? What are some of these assumptions?
15:44:03 <c_wraith> hseg: that if a type has an instance, it always has the same instance.
15:44:31 <hseg> But it doesn't *have* to break this rule.
15:44:33 <simpson> Haskellfant: Ah. Yeah, there are good arguments both for and against that.
15:44:37 <Clint> is there a good working example of "foreign ccall export" somewhere?
15:44:44 <c_wraith> hseg: no, but it allows it.  Sufficiently bad.
15:44:57 <Fuuzetsu> I know there's a name for ‘f ∘ f = f’ but I forgot what it was, does anyone remember?
15:45:08 <hseg> Fuuzetsu: idempotency
15:45:13 <Fuuzetsu> ah that's it, thanks
15:45:46 <Algebr```> haskell's equvialent of ocaml's List.iter would be mapM_?
15:45:50 <hseg> c_wraith: Why? I have an implementation in mind that, at least to me, doesn't allow for that.
15:46:31 <c_wraith> hseg: if you provide the function you mentioned, you allow for it.
15:48:15 <jle`> Algebr```: roughtly, it seems
15:48:41 <c_wraith> hseg: You can use a local Ord instance to build a Set, then pass that Set to something using a different local Ord instance
15:48:56 <jle`> the literal equivalent would be iter f = const () . map f
15:49:08 <jle`> based on the types
15:49:18 <jle`> but not the functionality :)
15:50:10 <c_wraith> Algebr```: I think you timed out before the example of using const I provided earlier:  \n xs -> zipWith const xs $ drop n xs
15:51:08 <Algebr```> c_wraith: ya, didn't see that, thank you
15:51:54 <listofoptions> ok so i just switched to xmonad on debian wheezy, whenever i run a terminal I dont have any text present. any ideas?
15:52:27 <Algebr```> listofoptions: What do you mean no text present?
15:52:28 <c_wraith> listofoptions: someone else just reported a similar problem, where it turned out the problem was that they had the foreground and background colors set to the same color by default
15:52:37 <Algebr```> oh
15:53:12 <listofoptions> I'll check that but i have text on my gnome 3 session
15:53:36 <hseg> c_wraith: What about this: (assuming a haskell dialect that allows for local type and instance declarations, as long as they aren't leaked through the result):
15:53:44 <hseg> http://lpaste.net/110317
15:54:08 <hseg> What would the problems with that be?
15:54:22 <nh2> Fuuzetsu: I bet you know whether cabal haddock supports CPP
15:54:30 <listofoptions> yup Algebr``` and c_wraith it was my terminal profile
15:54:30 <c_wraith> hseg: if you can forbid *every* kind of leaking, there wouldn't be any.  But how are you going to do that?
15:54:31 <hseg> (and yes, I changed the type of g a little to make it easier to work with)
15:54:53 <c_wraith> listofoptions: I think it's a collision of defaults between xmonad and the terminal that just happens to work.. terribly
15:55:18 <listofoptions> c_wraith, yeah it was set to use the gnome 3 system default
15:55:24 <hseg> What I mean by leaking is that the result type of f cannot contain values of types local to f
15:55:37 <Tuplanolla> Sounds reasonable, hseg.
15:55:49 <jle`> hseg: presumably you mean (forall b. Eq b => b -> c), right?
15:55:58 <hseg> yes
15:56:32 <c_wraith> hseg: How are you going to prevent that, though?  I can't see any way to statically prevent types.
15:56:44 <c_wraith> hseg: err.  I mind quit in the middle of that sentence.
15:56:59 <c_wraith> hseg: I see no way to statically prevent values from sneaking out instances of arbitrary concrete types
15:57:04 <Fuuzetsu> nh2: I bet I don't ;P
15:57:33 <Fuuzetsu> nh2: I don't see a reason why it would not, I certainly know of cabal haddock running over files using CPP so why not
15:58:03 <nh2> Fuuzetsu: I've read here (https://github.com/haskell/cabal/issues/1808) that it even did it too much
15:58:14 <hseg> c_wraith: Why? All you need to check is that the type returned by f doesn't contain fields of local types or typevars instantiated to local types, no?
15:58:19 <listofoptions> now i just need to get used to the keyboard commands
15:58:40 <nh2> Fuuzetsu: but I try to do
15:58:40 <nh2> # ifndef ...
15:58:40 <nh2> -- | Some Haddocks
15:58:40 <nh2> #else
15:58:40 <nh2> -- | Some other haddocks
15:58:41 <nh2> #endif
15:58:41 <nh2> mycode :: ..
15:58:53 <nh2> and it doesn't work, just picks the first one
15:58:59 <Algebr```> listofoptions: I think #xmonad has a nice link to a png thats like a cheatsheet
15:59:28 <Fuuzetsu> nh2: then I don't know, as far as I'm concerned this is a cabal problem, sorry
16:00:02 <nh2> actually no, it doesn't pick the first one, it just doesn't see the variable I give in #ifdef
16:01:33 <c_wraith> hseg: You might be able to make it work if you also forbid existential quantification from packing up instances with it.
16:01:50 <c_wraith> hseg: and also used *way* more complicated types.
16:02:52 <hseg> didn't think of quantification. *that* would be slightly problematic, although allowing that doesn't seem to be such a big problem as long as the typeclass isn't local to the function.
16:03:05 <hseg> And why do the types need to be more complicated?
16:03:16 <c_wraith> that type doesn't actually... work.
16:03:45 <hseg> OK, so we had to stick a forall in there. My mistake. Besides that?
16:04:20 <c_wraith> hseg: well, it doesn't fit that implementation.  There are no values of type b being passed in to anything
16:04:53 <c_wraith> hseg: but the implementation assumes there are..  It's returning something more like (c -> c) than c
16:05:19 <hseg> Right. Again, my mistake. Is this better: http://lpaste.net/110317
16:05:21 <hseg> ?
16:06:11 <c_wraith> hseg: No.  a = Foo, b = Set Foo
16:06:18 <c_wraith> err, c = Set Foo
16:06:33 <c_wraith> hseg: for one, your implementation still assumes a = c
16:06:47 <c_wraith> hseg: for another, it doesn't prevent broken instances from leaking.
16:07:23 <hseg> Right.
16:07:49 <nh2> Fuuzetsu: ah. It all does work, but `cabal haddock` doesn't notice when you change a cabal flag. Only after you run cabal configure. So no haddock problem indeed
16:08:08 <c_wraith> hseg: now, in the case where a = c, I think it might actually work. :)
16:08:23 <c_wraith> hseg: so maybe it does do what you need, if a and c are always the same type
16:09:00 <Fuuzetsu> yeah, cabal configure is the guy generating all the nasty symbols
16:09:15 <hseg> Ugh. The more I think of the problem the uglier my solution gets.
16:09:39 <c_wraith> hseg: I think that means you're thinking about it properly. :)
16:09:52 <hseg> No wonder this isn't a feature of GHC yet.
16:10:57 <c_wraith> hseg: you *can* do it unsafely with enough existing extensions.  edwardk had an example of doing so, though I'm having trouble tracking it down
16:12:07 <hseg> Really? Then again, edwardk does do some pretty weird stuff. I wouldn't be surprised to hear he'd written a library implementing either ZFC or ETCS.
16:12:12 <hseg> or both
16:12:38 <c_wraith> hseg: ah, I think it's in here http://comonad.com/reader/2011/what-constraints-entail-part-2/
16:13:24 <c_wraith> hseg: hmm, maybe not
16:38:01 <goglosh> where can I find prelude.hs if I have ghc installed?
16:38:15 <shachaf> On the Internet.
16:38:20 <geekosaur> it's not provided in source form
16:38:32 <goglosh> oh alright
16:39:08 <goglosh> oh yeah nother question, hughs or ghc?
16:39:11 <goglosh> hugs*
16:39:37 <geekosaur> hugs is long obsolete and unmaintained
16:39:45 <MP2E> ghc, unless you're okay with writing in Haskell 98 with no extensions :)
16:39:46 <shachaf> John Hughes or GHC?
16:39:55 <goglosh> oh I see. thanksz
16:40:21 <shachaf> @google hugs or ghc?
16:40:22 <lambdabot> http://www.haskell.org/haskellwiki/Implementations
16:40:22 <lambdabot> Title: Implementations - HaskellWiki
16:40:38 <goglosh> thx
16:49:49 <bms1> I've got a question about inlining. Does that belong here or in #ghc?
16:50:34 <Iceland_jack> ya
16:50:34 <shachaf> Is it about GHC development?
16:50:42 <Iceland_jack> oops, wrong channel
16:50:58 <bms1> no, just usage of GHC
16:51:42 <shachaf> #ghc is for "GHC Development | ... | Please ask user questions in #haskell"
16:52:09 <bms1> In the documentation about the INLINE pragma (https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/pragmas.html) it says that a function with an INLINE pragma is only inlined if it is fully applied (which is determined syntactically)
16:52:39 <bms1> That statement is only about the INLINE pragma, though, right? A function without the pragma can still be inlined, even if it isn't fully applied?
16:53:09 <shachaf> As far as I know adding the INLINE pragma will only make things inline more.
16:53:47 <bms1> Let's say I have homogenous pairs: data Pair a = Pair a a
16:54:11 <bms1> pair :: (a -> a -> b) -> Pair a -> b; pair f (Pair x y) = f x y
16:54:50 <nexx> shanse are you a politician? :D
16:54:54 <bms1> oh; nevermind!
16:56:33 <nexx> sorry I meant shachaf
17:07:33 <jollygood> how can I turn full paths into paths relative to the current working directory?
17:09:40 <dfeuer> What just happened/is happening? Netsplit?
17:11:11 <trap_exit> how do I figure out how to make something people will pay $10 for?
17:11:13 <trap_exit> wrong channel
17:11:14 <trap_exit> sorry
17:12:39 <hellertime> @type popCount . xor
17:12:41 <lambdabot> (Bits (a -> a), Bits a) => a -> Int
17:14:58 <hellertime> weird. I would expect that to be, a -> a -> Int
17:15:03 <hellertime> @type xor
17:15:04 <lambdabot> Bits a => a -> a -> a
17:15:11 <hellertime> @type popCount
17:15:12 <lambdabot> Bits a => a -> Int
17:16:27 <trillioneyes> hellertime: popCount . xor is \x -> popCount (xor x)
17:16:35 <trillioneyes> xor x is a function
17:16:42 <trillioneyes> But popCount's type requires it to have a Bits instance
17:16:49 <hellertime> oh. yes. that is a problem :)
17:17:51 <hellertime> @pl foo x y = popCount $ xor x y
17:17:51 <lambdabot> foo = (popCount .) . xor
17:17:57 <hellertime> ah.
17:18:48 <trillioneyes> If you really want to write it point-free, some people like to define f .: g = (f .) . g
17:19:07 <trillioneyes> Others feel like it's best to not write such functions in point-free style
17:19:32 <hellertime> Yeah. I don't think making this point-free lends to any sort of clarity…
17:19:39 <hellertime> it did in the broken form, but well…
17:22:35 <dfeuer> hellertime, cute trick: if x is a power of 2, then popCount x = 1.
17:23:37 <hellertime> that is a neat shortcut. this is computing hamming distance though, so I don't think I can take it
17:23:44 <augur> hello!
17:24:35 <hellertime> dfeuer: I mean I certainly could if everything was x^2, but its unlikely
17:24:53 <dfeuer> hellertime, I used it recently to check if something was a power of 2.
17:25:28 <dfeuer> And you mean 2^x, not x^2, I think.
17:25:41 * dfeuer is waiting waiting waiting for nofib.
17:25:48 <dfeuer> WAAAAAAAAITING for nofib.
17:26:07 <hellertime> dfeuer: indeed I do.
17:35:55 <augur> hm. ive narrowed me clang problem down a little bit. its not because of how im creating archives, but because of something in them
17:37:42 <geekosaur> yes, archives are pretty much the same format everywhere, one of the object files in it is probably the wrong type. (very low probability: there is a difference between i386 and x86_64 archive symbol tables and you are getting the wrong one. this seems highly unlikely to me)
17:38:06 <geekosaur> (that is, there is no good reason for such a difference and it would just be kinda strange)
17:39:19 <trap_exit> in haskell, can I do pattern matching on anonymous functions, ? I know that I can do (\x -> case x of PATTERN MATCH ) .... but I'm wondering if I can do (\ PATTERN MATCH .... )
17:39:46 <geekosaur> trap_exit, sort of. you can't provide multiple patterns
17:39:51 <trap_exit> hmm, i'm *not* pattern matching in anonymous functions; I want to use Pattern Matching in _defining_ anonymous functions
17:40:06 <trap_exit> geekosaur: what is the use of pattern matching if I can not provide multiple patterns?
17:40:09 <trap_exit> with all due repsect, that seems very limited
17:40:25 <HeladoDeBrownie> You can provide multiple patterns if you use case
17:40:30 <geekosaur> you seem to think I had some say in the matter?
17:40:40 <HeladoDeBrownie> There's the LambdaCase extension for that matter
17:40:48 <trap_exit> geekosaur: I thought you were the CEO of Haskell Incorporated
17:41:21 <geekosaur> anyway I think they ran out of syntax. every so often someone proposes a way to do it and someone else shows how it conflicts with existing syntax
17:41:47 <trap_exit> I hear we live in a world that is no longer limitd to ASCII and can use unicode.
17:41:49 <roboguy_> trap_exit: sometimes types have only one constructor. also, like HeladoDeBrownie said, LambdaCase
17:41:50 <geekosaur> so we ended up with lambdacase which is kinda sucky syntax but doesn't have weird corner cases
17:41:51 <trap_exit> Haven't we learned anything from the power of APL ?
17:42:07 <HeladoDeBrownie> geekosaur, what's bad about it?
17:42:09 <geekosaur> trap_exit, fine until you have to *type* it
17:42:11 <David> I have a tree where each node has two fields, i1 and i2 (with all i2s being zero). I want to create a new tree with each node's i2 being the sum of its i1 in addition to the i1s of all its children.
17:42:20 <David> what's the most efficient way to do this efficiently?
17:42:25 <David> (oh, and hi, trap_exit)
17:42:27 <trap_exit> I press C-x 8 <return> 2203 all the time in emacs
17:42:41 <David> zippers?
17:42:45 <trap_exit> David: are you from dogecoin?
17:42:48 <David> yes
17:42:59 <geekosaur> if youre used to emacs I suppose you wouldn't see what's wrong with that monstrosity :p
17:44:34 <geekosaur> if I have to resort to hex entry to use a programming language, I'm unlikely to use it. at least until I can come up with a halfway sane keyboard layout in place of the hex
17:47:25 <augur> aha! i've narrowed down the error (tho now im getting it in ghc too! how weird)
17:47:33 <merijn> geekosaur: Oh god, Ulf Norrel gave a tutorial on Agda, so much unicode :<
17:47:50 <geekosaur> HeladoDeBrownie, http://unknownparallel.wordpress.com/2012/07/09/the-long-and-epic-journey-of-lambdacase-2/ see discussion of alternative syntaxes.
17:48:10 <geekosaur> (hopefully that provides some links to the list discussion somewhere)
17:48:18 <Gurkenglas> :t liftM2
17:48:19 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:48:23 <roboguy_> doesn't Agda's emacs mode automatically convert certain keywords into unicode for you?
17:48:23 <Gurkenglas> :t liftM2 (==) id reverse
17:48:24 <lambdabot> Eq a => [a] -> Bool
17:48:37 <Gurkenglas> So if I'm getting this right
17:48:38 <merijn> geekosaur: I shit you not, his tutorial at some point contained (as answer to the question "it doesn't work for me") the sentence: "Oh, yes, I guess I should have said that's the unicode vertical bar, not ascii..." >.>
17:48:50 <geekosaur> guuuh
17:49:15 <merijn> roboguy_: Only if you know the magic thing to type for that
17:49:26 <Gurkenglas> m a1 is [a]->[a], m a2 is [a]->[a], and m r is [a]->Bool
17:49:26 <geekosaur> I am not averse to unicode as long as (a) it's recognizeable, unlike that (b) there are ascii alternatives for people who do not have control-meta-cokebottle on all keyboards
17:49:40 <roboguy_> merijn: wouldn't that be pretty similar to just learning the keywords of the language in the first place though?
17:50:01 <merijn> roboguy_: Why? You can just write the exact same agda without those symbols...
17:50:04 <Gurkenglas> But shouldn'r m r be [a]->[Bool]?
17:50:49 <roboguy_> merijn: hmm, I was under the impression that you just hit a certain chord before typing a normal keyword and it would do it for you. I've never used it though, so maybe it's not that easy
17:51:17 <merijn> roboguy_: The built-in keywords don't require unicode
17:51:17 <Gurkenglas> After all, m ? seems to be [a]->[?]
17:51:26 <geekosaur> the emacs major mode for agda has a fair amount of that, but you still need to know the chord
17:51:58 <roboguy_> merijn: yeah
17:52:22 <roboguy_> but I'm saying, I thought there was a single chord that turned any keyword into the corresponding unicode
17:52:47 <geekosaur> Gurkenglas, what's throwing you is that m is []
17:53:13 <geekosaur> (`[] a` is a funny way of writing `[a]`)
17:53:32 <roboguy_> geekosaur: isn't it ((->) r)?
17:53:33 <Gurkenglas> But reverse isn't a list, it's a function
17:53:43 <geekosaur> hm, maybe
17:54:01 <geekosaur> then the analysis is completely wrong, I think
17:54:44 <Gurkenglas> Which one?
17:54:47 <roboguy_> Gurkenglas: r matches with the Bool in the type of (==)
17:54:53 <roboguy_> so m r is [a] -> Bool
17:55:15 <Gurkenglas> By that logic, m a2 (the reverse) should be [a]->a
17:55:40 <roboguy_> Gurkenglas: why? a2 matches with [a] not a
17:56:06 <Gurkenglas> Oh, you can do (==) on lists. Well that clears it up
17:56:16 <Gurkenglas> > [2,3,4] == [2,3,4]
17:56:17 <lambdabot>  True
17:56:28 <trillioneyes> :t (==)
17:56:29 <lambdabot> Eq a => a -> a -> Bool
17:56:37 <trillioneyes> There's an instance Eq a => Eq [a]
17:57:01 <Iceland_jack> :t (==) :: Eq a => [a] -> [a] -> Bool
17:57:02 <Gurkenglas> Yea that's what I just said
17:57:02 <lambdabot> Eq a => [a] -> [a] -> Bool
17:57:17 <roboguy_> here's another way
17:57:18 <merijn> Gurkenglas: You can do comparison on lists too :)
17:57:23 <roboguy_> :t (==) <$> id <*> reverse
17:57:24 <lambdabot> Eq a => [a] -> Bool
17:57:35 <Iceland_jack> :t (==) =<< reverse
17:57:36 <lambdabot> Eq a => [a] -> Bool
17:57:49 <Iceland_jack> > ((==) =<< reverse) "abba"
17:57:50 <lambdabot>  True
17:58:50 <Gurkenglas> Thanks for the :55:51 trick
18:02:09 <Gurkenglas> My :55:51 was too hostile, comments like :55:26 are generally useful.
18:03:01 <vanila> Gurkenglas, what are you using to talk here?
18:03:23 <vanila> it's inserting weird numeric references to previous lines of chat?
18:03:54 <Gurkenglas> XChat allows you to display timestamps for each line, I was referencing minute:second because hours are not well-defined.
18:04:02 <vanila> oh
18:04:09 <vanila> but you know with timezones everyone has different times showing
18:04:19 <Hafydd> Minutes and seconds are well-defined either.
18:04:32 <Hafydd> *aren't
18:05:20 <Gurkenglas> Not everyone receives this post at  I just tried to look at the timestamp of this line before posting it.
18:05:35 <Gurkenglas> 04:08?
18:05:41 <roboguy_> I would be pretty surprised if everyone here had exactly the same minutes and seconds
18:05:54 <merijn> lol
18:05:54 <roboguy_> Gurkenglas: 20:04 for me
18:05:58 <merijn> @hackage acme-stringly-typed
18:05:58 <lambdabot> http://hackage.haskell.org/package/acme-stringly-typed
18:06:07 <roboguy_> Gurkenglas: so I don't think that's going to work haha
18:06:12 <Gurkenglas> roboguy_, you forgot the seconds
18:06:13 <Hafydd> Not to mention that some timezones differ by a non-whole number of hours from others.
18:06:19 <roboguy_> Gurkenglas: my client doesn't show them
18:06:24 <roboguy_> oh, I see
18:06:27 <merijn> Gurkenglas: I (and lots of others) don't have seconds showing :)
18:07:03 <Fuuzetsu> ‘latter’ and ‘former’, no need to discuss it ;P
18:08:29 <roboguy_> yeah, I feel like this isn't a very robust way to determine messages. Also it frankly just sounds weird to me, ha. I like it to feel more like natural conversation
18:09:09 <Gurkenglas> Good ol' natural=good argument :D
18:12:46 <HeladoDeBrownie> geekosaur, I took a look at some of the discussion but don't see anything obviously wrong with the current LambdaCase syntax
18:13:07 <goglosh> what's the best library for drawing primitives on screen?
18:13:08 <HeladoDeBrownie> I'm not saying it can't be improved, just that I personally would be okay with it as it is
18:13:28 <codygman> Any suggestions on this approach for fuzzy matching file paths, advice, code review? http://lpaste.net/110321
18:13:33 <Gurkenglas> Hmm, that was unfair as liking it more naturally was justified
18:14:27 <bitemyapp> I need advice on structuring a service wrapper around a library.
18:14:40 <HeladoDeBrownie> goglosh, I can't reasonably call it "best", but gloss has facilities for that.
18:14:52 <HeladoDeBrownie> (Because I've yet to try many other libraries that accomplish similar)
18:14:58 <HeladoDeBrownie> @hackage gloss
18:14:58 <lambdabot> http://hackage.haskell.org/package/gloss
18:15:04 <bitemyapp> The service kinda has to be a singleton, but I'd like to be able to support multiple protocols for accessing the service with the option of not building the parts that expose a protocol not being used.
18:15:06 <roboguy_> codygman: my first thought is definitely add top-level type signatures
18:15:17 <roboguy_> (that's always my first thought if they're not there though)
18:15:19 <bitemyapp> I'd rather not ifdef the crap out of everything either.
18:16:10 <HeladoDeBrownie> What's up with the latest documentation not being available on Hackage in many cases, even though the next oldest version's is?
18:16:43 <codygman> roboguy_: Alright, thanks. Right now I'm trying to wrap my head around the logic of this. I know there has to be a way to recursivley iterate up a directory tree accumulating filepath parts but I just can't put it into code.
18:17:12 <bitemyapp> codygman: fold?
18:17:19 <merijn> Does anyone have a good cost intuition for threads? Would 4 threads per network connection be reasonable for a networking library?
18:17:28 <bitemyapp> merijn: you have to test.
18:17:38 <merijn> HeladoDeBrownie: Hackage uses a batch process for building docs
18:18:09 <bitemyapp> merijn: sparks in Haskell are really cheap in terms of memory pressure and context switching. You've seen the MIO paper right?
18:18:34 <merijn> bitemyapp: Sparks are not forkIO threads, though
18:19:22 <roboguy_> codygman: I would probably also separate out those functions into either top-level definitions or put them into a where clause. Either way, I'd put type signatures on them as well, so it's easier to see how the types fit together
18:20:07 <roboguy_> for me at least, it's harder for me to mentally separate functions in let statements than if they're in where clauses generally
18:20:28 <bitemyapp> merijn: the per forkIO thread overhead in Haskell is lower than Erlang's for memory use IIRC
18:20:55 <bitemyapp> it's possible you could create too much memory pressure and choke on GC, but given what the MIO paper did, I wouldn't be worried about it.
18:21:07 <bitemyapp> merijn: why are you allocating a specific number of threads per connection?
18:21:45 <merijn> bitemyapp: Well, I have 2 for the socket reading/writing (because bidirectional blocking in a single thread isn't doable) and those write to a local (bounded) queue
18:22:35 <merijn> bitemyapp: I've spend 2 weeks trying to think of a way to implement efficient fair queueing for these queues and I'm right now considering the simplest way might be to simply have an extra thread that reads from the queue and does a putMVar on a single global MVar
18:23:10 <HeladoDeBrownie> merijn, you've probably thought about this more than I have, but why would you need more than two threads per incoming connection? One reads the connection and writes a queue, the other reads a queue and writes the connection?
18:23:13 <merijn> bitemyapp: MVar's are fairly queued internally, the read/puts on the MVar will result in fair queueing with easy preemption (just async exception the blocked writing thread)
18:23:33 <HeladoDeBrownie> I ask partly because I'm writing a network application that works the way I describe and am wondering if I'm missing something.
18:23:35 <bitemyapp> merijn: seems reasonable, just wondering where the 4 came from.
18:23:42 <dfeuer> What is fair queueing?
18:24:00 <merijn> dfeuer: Guarantees progress
18:24:03 <bitemyapp> dfeuer: http://en.wikipedia.org/wiki/Fair_queuing
18:24:08 <bitemyapp> merijn: uh, qualify that.
18:24:15 <bitemyapp> dfeuer: guarantees progress on a unit of work basis.
18:24:37 <bitemyapp> you can guarantee "progress" with STM, you cannot guarantee progress for all threads transacting against it.
18:24:42 <dfeuer> Meaning it's lock-free but not necessarily wait-free?
18:24:54 <merijn> dfeuer: Basically, if you have 2 connections, one producing 1 million packets per second and the other 1 packet per minute you want to stop the first connection from starving the second
18:25:03 <merijn> dfeuer: No, this is not about locking
18:25:24 <merijn> dfeuer: The simplest fair queue is round-robin where you skip idle connections
18:25:47 <merijn> dfeuer: Because it guarantees every other ready connection will have 1 message processed before the 1 million per sec connection gets another turn
18:26:11 <monsterInParasol> does anyone know the url to a haskell joke which is a comparison of how programmers in different languages see each other and all of them see haskellers as einstein :)
18:26:11 <merijn> HeladoDeBrownie: No, that good enough for doing your own simple networking :)
18:26:15 <dfeuer> merijn, I mean that it the technical sense -- lock free guarantees *something* will make progress at each step; wait-free guarantees no starvation.
18:26:40 <merijn> HeladoDeBrownie: I'm working on a zeromq implementation where every socket has N network queues and reads to the socket needs fair bounded queueing for all the connections
18:26:43 <dfeuer> Well, guarantees everything makes progress within so many units of work.
18:27:00 <HeladoDeBrownie> merijn, ah, something complex I'd as of yet have no idea how to use, it seems :)
18:27:02 <merijn> dfeuer: Why would wait-free guarantee no starvation?
18:27:21 <dfeuer> Sorry, forget "no starvation". I don't know enough about starvation....
18:28:13 <dfeuer> Wait-free generally means that each thread has to "help" other threads make progress. It doesn't look likely to be efficient very often--inappropriate outside of hard realtime, probably.
18:28:13 <merijn> dfeuer: Simple case: two unbounded queues (writing never blocks, so no waiting) and the algorithm that first reads all messages from the first non-empty queue before moving on to the next
18:28:44 <merijn> dfeuer: No thread ever blocks (well, unless there's no work, but you could spinloop) but a fast writer on the first queue could starve the writer on the second queue
18:29:30 <dfeuer> Yes, it would.
18:32:54 <merijn> Anyway, I will go with the double threaded design for now then and if someone else feels compelled to implement a more efficient queue, I'll change the code then :p
18:33:11 <dfeuer> merijn, this looks kind of interesting: www.cs.technion.ac.il/~erez/Papers/wf-methodology-ppopp12.pdf‎
18:33:27 <dfeuer> And wait-free guarantees no starvation because that's the definition of wait-free :P
18:35:05 <dfeuer> Look what Haskell has done to me! My /home is 87% full!
18:35:27 <merijn> dfeuer: The problem is that I need 1) fair queueing and 2) preemption of queued items
18:35:51 <merijn> Efficient fair queueing is still doable to implement efficiently, it's the preemption that has killed all my past attempts
18:36:09 <dfeuer> Preemption by what?
18:36:10 <merijn> With a single MVar + extra threads approach preemption is easy, just kill the blocked thread :)
18:36:24 <merijn> dfeuer: Network connection dying => remove buffer from ready queue
18:36:29 <HeladoDeBrownie> dfeuer, me too, and my /garage especially, full of mini Haskell projects
18:38:23 <Denommus> hm, anyone has a good paper on AFRP?
18:39:14 <trap_exit> Main: Prelude.foldl1': empty list make: *** [default] Error 1 <-- how do I get haskell to output a more informative error, say *.hs file name and line number?
18:39:44 <HeladoDeBrownie> trap_exit, the informative error will likely be before that; I'm guessing you're running cabal, right?
18:39:57 <trap_exit> no
18:39:57 <trap_exit> I use ghc
18:39:58 <dfeuer> merijn, these kinds of things generally seem very hard, and most of them seem to be open problems....
18:40:00 <HeladoDeBrownie> Ah
18:40:07 <trap_exit> should be using cabal ?
18:40:10 <HeladoDeBrownie> trap_exit, what's the entire output?
18:40:16 <HeladoDeBrownie> trap_exit, well, it can certainly be useful
18:40:23 <augur> hmm
18:40:27 <augur> mystery mystery
18:40:52 <dfeuer> I think it's been too long since my last update ... yum upgrade is pulling several hundred megabytes.
18:41:00 <augur> ghc/clang is complaining about symbols being missing even tho they're in an archive that it should be able to see
18:41:03 <Denommus> trap_exit: well, cabal is certainly more featureful than ad-hoc makefiles
18:41:25 <trap_exit> https://gist.github.com/anonymous/3ea7e87f282c527a85e9 <-- entire output
18:41:29 <trap_exit> oh
18:41:32 <trap_exit> +RTS -xc
18:41:45 <trap_exit> I win
18:42:00 <merijn> dfeuer: Oh, I know :)
18:42:04 <HeladoDeBrownie> trap_exit, oh, I see. Your program tried to evaluate bottom. I'm not sure how to get it to be more specific, but do you know where you're using foldl1'?
18:42:36 <dfeuer> OK, merijn. You were talking like you knew even less than I do, but that must have been modesty on your part.
18:42:39 <HeladoDeBrownie> If you're going to pass an empty list to the fold, you probably shouldn't be using any fold*1* function.
18:42:49 <trap_exit> I got https://gist.github.com/anonymous/06cb58b5e47b6eb1ba20
18:42:49 <trap_exit> which is good enough
18:42:54 <trap_exit> the lists are not supposed to be empty
18:43:36 * dfeuer knows virtually nothing about such things, but has seen a definite pattern in publication suggesting that wait-free data structures pretty much have to be traversed top-down only to avoid issues.
18:43:41 <merijn> dfeuer: I've worked on two separate concurrent runtime systems for languages, I guess by now I can call myself an expert in that stuff. But being an expert just means I know it's near impossible to get this stuff right :p
18:44:14 <merijn> dfeuer: And no one else seems to have implemented anything like this, I just wasn't sure about the overhead of forkIO these days
18:44:17 <dfeuer> When people try to go two-way on them, they seem universally to make mistakes.
18:44:35 <dfeuer> Or get stuck, or something.....
18:44:49 <dfeuer> There's probably a theorem in there somewher.
18:45:36 <merijn> dfeuer: Unfortunately there's not really much tools for formal proofs of this stuff either :p
18:46:42 <jayunit100h> hi hasekll.  anyone ever see the --  The IO action ‘main’ is not defined in module ‘Main’
18:46:54 <shachaf> Yes.
18:46:57 <jayunit100h> im getting this on a mac, using ghci
18:47:09 <jayunit100h> shachaf: :) great .  any idea where that comes from?
18:47:09 <Cale> jayunit100h: Did you define main?
18:47:16 <jayunit100h> yup
18:47:29 <jayunit100h> main = putStrLn "..."
18:47:36 <shachaf> jayunit100h: Please post complete code and exactly what you're doing on hpaste.org
18:47:37 <Cale> jayunit100h: A module which doesn't have a module declaration at the top of it is automatically named Main
18:47:49 <merijn> Semi-relatedly: Does anyone have experience building ThreadScope on OSX?
18:48:09 <Cale> shachaf: I was about to correct you, but there's a redirect now :D
18:48:57 <dfeuer> merijn, I read a little bit of an early paper, which went to a lot of trouble to prove that any data structure can be made wait-free using CAS, in a theoretically satisfactory but *extremely* inefficient fashion. It seems that every further development has been with far more sweat and blood and tears.
18:48:58 <shachaf> Cale: It's been there for a while. I don't think people should abandon the domain hpaste.org just because chrisdone doesn't like the name anymore.
18:49:35 <blast_hardcheese> I suspect I'm missing something-- I'm writing a simple base64 parser. I have a Char -> Maybe Int, but then later I'd like to have [Maybe Int] -> BitString. I don't see anything from Int to Word8 or anything similar.
18:49:37 <Cale> shachaf: I don't think so either :)
18:50:19 * dfeuer just started a full-on nofib run to see if some unfortunate-looking time changes are real.
18:50:20 <Cale> blast_hardcheese: There's fromIntegral...
18:50:44 <merijn> blast_hardcheese: With the usual truncation warnings, of course :)
18:50:44 <Cale> blast_hardcheese: also, surely you mean ByteString?
18:51:15 <blast_hardcheese> Cale: Ah, yes, ByteString :)
18:51:47 <merijn> Would't you want to properly encode the unicode and then base64 the resulting encoded bytes?
18:51:51 <Cale> blast_hardcheese: How to handle occurrences of Nothing?
18:52:20 <jayunit100h> ohhhh
18:52:22 <blast_hardcheese> Cale: Using catMaybes, [Maybe a] -> [a]
18:52:23 <jayunit100h> dump error
18:52:36 <ion> cale: A ByteString with a null ForeignPtr of course.
18:52:43 <Cale> ion: lol
18:52:52 <blast_hardcheese> ion: nuuuu
18:52:57 <jayunit100h> dumb error, sorry.  I actually was compiling the wrong file.  the main method signature was off .  thanks though the help folks.
18:53:16 <Cale> BS.pack [fromIntegral n | Just n <- map base64Char xs]
18:53:20 <Cale> something like that perhaps
18:53:31 <Cale> jayunit100h: no problem :)
18:54:12 <augur> hey Cale, can i poke you some more about ghc? or did you say you dont know much about .a archives?
18:54:31 <Cale> augur: I'm honestly the wrong person to talk to about that stuff
18:54:40 <augur> :(
18:54:43 <Cale> I've only ever messed around with small examples like the one I gave you
18:54:48 <augur> fair enough
18:54:54 <augur> bennofs has gone offline :(
18:54:59 <Cale> (When it comes to exporting from Haskell, anyway)
19:01:55 * dfeuer goes to update his little foldr/build commentary. I just implemented nomeata's improvement of the fusible scanr I wrote, with all the gory write-back stuff (the gore here suggesting more commentary!).  http://lpaste.net/110326 
19:04:18 <codygman> bitemyapp: Yeah, I'm trying to basically make a function that takes a filepath and case insensitive matches that entire filepath. It starts by checking if the entire path is already right, then goes up a directory, insensitive search for exact folder name, all the way back up to root.
19:21:37 <Algebr```> I'm thinking about using wreq instead of HTTP but am slightly nervous about having to deal with lens related stuff. Is lens all that bad? It seems like its marching relentlessly into every new library.
19:22:19 <Cale> Algebr```: It's not so bad if you just use it tastefully.
19:22:56 <jle`> no reason to be scared of lens if a library you are using uses it
19:23:02 <Cale> Algebr```: It's really easy to go insane and end up using complicated lens machinery to do things which can be more easily accomplished another way
19:23:02 <jle`> it's not particularly complicated or "bad"
19:23:09 <Cale> But the basics are simple
19:25:07 <bitemyapp> codygman: sounds like a fold.
19:25:43 <bitemyapp> codygman: in fact, if your recursive tree had a foldable instance the monoid was the concat operation you want, you could probably literally just call `fold` and then go get yourself a cup of coffee because winners get coffee.
19:25:53 <bitemyapp> and the monoid instance*
19:26:21 <bitemyapp> codygman: but uh, you know, baby steps or whatever :)
19:26:49 <merijn> bitemyapp: I thought winners did beer + concurrent programming? :p
19:27:00 <merijn> If not, I need to reevaluate my life's choices...
19:29:43 <bitemyapp> merijn: I usually drink scotch when I'm doing concurrent programming.
19:30:09 <merijn> bitemyapp: Oh, good point
19:30:22 <merijn> bitemyapp: But all my good scotch is on the other side of the Atlantic :(
19:30:35 <merijn> Plus I don't even have Scotch glasses here :\
19:32:41 <bitemyapp> merijn: pity that
19:32:52 <bitemyapp> merijn: I don't think I have proper scotch glasses, but I think they suffice.
19:32:57 <bitemyapp> don't care, have scotch.
19:33:06 <bitemyapp> sipping tea at the moment, flip over to scotch soon.
19:33:32 <merijn> bitemyapp: I just have mugs and big plastic glasses, they don't feel right for Scotch
19:33:41 <merijn> I should've remembered to buy glasses today...
19:33:42 <merijn> oh well
19:34:35 <Algebr```> Is there ever a future where String is removed and Text becomes the default?
19:35:22 <roboguy_> Algebr```: probably not. String can be really nice for small sized strings
19:35:46 <bitemyapp> Algebr```: nope.
19:35:53 <bitemyapp> Algebr```: I've seen code that was faster with String than Text.
19:35:57 <bitemyapp> Algebr```: RIDDLE ME THAT, MR WIZARD
19:36:36 <zwer> how big of a difference was it?
19:36:46 <merijn> Not only that, it would gratuitously break 80% of hackage
19:36:57 <bitemyapp> zwer: way beyond the minimums of statistical significance
19:36:59 <Algebr```> but for a language is seems okay with breaking existing code, why not make a clean break from String? Seems annoying to always have to do that OverloadedStrings pragma
19:37:04 <bitemyapp> Algebr```: nope.
19:37:11 <bitemyapp> Algebr```: and that wouldn't eliminate OverloadedStrings
19:37:14 <bitemyapp> Algebr```: we still have ByteString.
19:37:22 <Algebr```> merijn: but what % of hackage actually isn't just abandoned anyway
19:37:25 <bitemyapp> Algebr```: you're trying to totalize things that don't need totalized, wasting human labor in the process.
19:37:26 <merijn> Algebr```: You could just use a nice quasiquoter for Text :)
19:37:37 <roboguy_> Algebr```: pattern matching is nice
19:37:39 <bitemyapp> Algebr```: it doesn't matter, it has uses, etc etc
19:38:33 <merijn> Algebr```: The community doesn't have problems with breaking existing code IF there is sufficient incentive to do so
19:38:38 <Algebr```> I see, so then for the forseable future, we have three different types of strings.
19:38:40 <merijn> There's basically 0 incentive to remove String
19:38:55 <merijn> 5, actually
19:38:56 <roboguy_> Algebr```: well, they correspond to (at least) three different use patterns
19:39:09 <Algebr```> merijn: what 5?
19:39:11 <haasn> We have three? I thought we just had two
19:39:24 <merijn> haasn: I'm guessing he's including ByteString
19:39:27 <roboguy_> Algebr```: this is pretty similar to saying we should get rid of lists in favor of Vector
19:39:30 <merijn> which I would agree is not a String
19:39:43 <roboguy_> when they both are useful for different things
19:39:44 <merijn> So depending on your point of view we have 3 or 5
19:40:03 <merijn> String, Text, Text.Lazy and also ByteString and ByteString.Lazy
19:40:21 <merijn> Algebr```: Different types, different use cases
19:40:37 <merijn> And honestly, the difference between String, Text and ByteString is really simple
19:41:49 <Makoryu> If there was a way to overload list-style pattern matching, the other string types would be quite painless to use
19:42:14 <HeladoDeBrownie> What would be a case where String is the most appropriate? Text and ByteString are pretty obvious to me but not String.
19:42:18 <haasn> Makoryu: But there is
19:42:22 <haasn> Oh, you mean list-style
19:42:26 <haasn> But there is a way to overload that ,too
19:42:38 <Iceland_jack> Makoryu: There is the PatternSynonyms extension
19:42:51 <Makoryu> Iceland_jack: Haven't heard of it. Hmmm...
19:42:53 <merijn> Makoryu: See PatternSynonyms and OverloadedLists :)
19:42:55 <shachaf> ByteString isn't even related to String.
19:43:08 <Iceland_jack> soon with associated patterns and explicitely bi-directional patterns
19:43:52 <jle`> HeladoDeBrownie: perhaps when you are dealing with character streams
19:44:14 <HeladoDeBrownie> jle`, I thought Char were code points
19:44:29 <codehero> is this good for learning haskell? http://www.cis.upenn.edu/~cis194/
19:45:15 <jle`> HeladoDeBrownie: s/character/code points ...?
19:45:22 <jle`> codehero: i've heard good things about it
19:45:28 <codehero> okay ^^
19:45:53 <codehero> i looked on fpcomplete and this was linked
19:45:58 <HeladoDeBrownie> jle`, I suppose.
19:46:17 <codehero> this one seems to be incomplete https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
19:46:38 <jle`> HeladoDeBrownie: sorry, i'm just not sure what point you were trying to get across :|
19:46:48 <jle`> codehero: it is the recommended course from https://github.com/bitemyapp/learnhaskell
19:46:48 <codehero> unless they intentionally didn't cover monads
19:46:59 <jle`> why is monad important?
19:47:00 <HeladoDeBrownie> jle`, even hearing your suggestion I find myself struggling to come up with an actual usage.
19:47:22 <HeladoDeBrownie> jle`, I didn't really have a point, I was merely curious.
19:47:22 <merijn> HeladoDeBrownie: Simple to pattern match, easy to manipulate
19:47:43 <HeladoDeBrownie> merijn, I'm not sure what you're responding to
19:47:53 <merijn> HeladoDeBrownie: Why Strings are useful
19:48:16 <HeladoDeBrownie> So would you argue that usefulness also contributes to being the most appropriate?
19:48:27 <codehero> jle`: well, i'd like a complete intro to haskell
19:48:34 <merijn> "It depends" TM :)
19:48:38 <codehero> and afaik monads are a pretty big part of it
19:48:41 <HeladoDeBrownie> I suppose it does.
19:49:01 <jle`> codehero: hmm
19:49:03 <HeladoDeBrownie> It just seems to me like most of the ways I've seen String used, something else might've been better but String was convenient.
19:49:06 <jle`> codehero: that's debatable
19:49:06 <roboguy_> codehero: well...
19:49:08 <merijn> codehero: Monads are overrated and fascination with them tends to lead to more frustration than necessary for learning haskell :)
19:49:27 <codehero> hmm
19:49:31 <roboguy_> codehero: do you know about functor and applicative?
19:49:34 <jle`> codehero: i...don't think that moands are a useful or meaningful or practical thing to include in an introduction to haskell
19:49:41 <codehero> roboguy_: yeah, sort of
19:50:39 <roboguy_> codehero: monad is a bit of an extension of applicative. but the best way to learn about it is to use specific instances of Monad and eventually it will start to make sense (in my experience). I would say that's how to learn about most type classes
19:50:44 <codehero> jle`: so should i do this one https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell? or the other one?
19:51:19 <roboguy_> Monads are good, but they got a overhyped and now it needs to be dialed back a bit
19:51:36 <jle`> codehero: i haven't gone through either, but if you do the other one you'll have a lot of classmates on #haskell-beginner :)
19:52:08 <jle`> um #haskell-beginners
19:52:23 <codehero> jle`: oh, that's cool :)
19:52:44 <codehero> then i'll do the cis194 ^^
19:52:50 <jle`> you can do either, i think, and people will be able to help you
19:52:55 <jle`> but a lot of people seem to have gone with cis194
19:53:00 * jle` shrugs
19:53:32 <codehero> i think i'm going to do the 2014 one. that way i won't try to do all of it in one week :D
19:53:34 * dfeuer is sick /join #haskell-beginners
19:56:26 <Algebr```> whoa, the wreq library has a very nice api.
19:58:09 <Ca3sar> Hi
19:58:38 <Ca3sar> I connected to this and the person next to me called me a hacker
19:59:14 <Cale> Ca3sar: heh
19:59:16 <MP2E> Ca3sar: maybe they misread #haskell as #hacker
20:00:15 <Algebr```> because using irc immediately increases your 1337ness.
20:00:19 <Cale> IRC, Internet Relay Chat protocol, a pretty primitive chat program. It's how hackers talk when they don't want to be overheard.
20:00:20 <MP2E> haha
20:00:41 * hackagebot btrfs 0.1.0.0 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.1.0.0 (MariosTitas)
20:01:02 <Ca3sar> Though ironically a lot of hackers were caught because they were bragging on IRC rooms lol
20:02:47 <HeladoDeBrownie> Ca3sar, I've noticed that looking at screens full of monospaced text tends to incite that reaction
20:02:50 <codehero> Ca3sar: XD
20:02:57 <codehero> i love that scene
20:03:08 <codehero> or the one with the Vbasic GUI
20:03:13 <codehero> to find the criminals!
20:03:15 <Ca3sar> It really is lol
20:03:49 <codehero> http://www.cracked.com/article_19160_8-scenes-that-prove-hollywood-doesnt-get-technology_p2.html
20:03:52 <blast_hardcheese> Why isn't there a Int -> [a] -> Maybe a in Prelude? This seems like an odd omission
20:04:14 <codehero> https://www.youtube.com/watch?v=hkDD03yeLnU
20:04:20 <codehero> CSIXD
20:04:25 <codehero> oh man
20:04:32 <codehero> this is in real time...
20:04:33 <zq> blast_hardcheese: what would it do?
20:04:35 <codehero> no shit
20:04:56 <HeladoDeBrownie> blast_hardcheese, indeed it is. Although if you're indexing lists a lot you might consider one of the other sequence structures, like vector. Anyway, there's the safe package or lens.
20:04:59 <Ca3sar> codehero: LOL I SAW THAT
20:05:08 <merijn> Cale: Did you see the Numb3rs description of IRC? :)
20:05:22 <Cale> merijn: That's where I stole that line from
20:05:30 <codehero> with those pirate ships
20:05:32 <merijn> :)
20:05:35 <codehero> those damn pirates dem
20:05:51 <blast_hardcheese> HeladoDeBrownie: Do people just normally not do this, or do they rewrite that for every project?
20:05:57 <merijn> the pirates on IRC was the most accurate bit :)
20:06:07 <zq> blast_hardcheese: lists aren't meant to be indexed
20:06:10 <blast_hardcheese> I'm still very much learning Haskell, trying to figure out how people usually solve problems.
20:06:15 <zq> indexing is linear time access
20:06:20 <blast_hardcheese> zq: Hmm
20:06:24 <zq> :t Data.Vector.(!)
20:06:25 <lambdabot> Not in scope: data constructor ‘Data.Vector’
20:06:29 <zq> :t (!)
20:06:30 <lambdabot> Ix i => Array i e -> i -> e
20:06:34 <zq> ugh
20:06:38 <merijn> blast_hardcheese: If you want indexing you probably want something like Array, Vector or IntMap
20:06:50 <blast_hardcheese> Understood, I'll look at Vector
20:06:54 <zq> blast_hardcheese: hold up
20:07:07 <zq> blast_hardcheese: https://hackage.haskell.org/package/vector-0.10.11.0/docs/src/Data-Vector.html#!%3F
20:07:21 <zq> there's the fn you want
20:07:37 <blast_hardcheese> oh, great!
20:07:44 <HeladoDeBrownie> blast_hardcheese, sorry, I'm not sure how to answer that question without repeating myself :) Did you need me to clarify part of my response?
20:08:12 <kgadek> hi, could you help me? my creativity is low (5am here), yet I need a "most basic" example of code that uses defaulting to resolve ambiguities. I have `rms x y = sqrt ((x^2 + y^2) * 0.5)`, anything simpler? As few operations as possible, preferably only "Num" class used
20:08:20 <zq> tfw haskell has no indexed vectors
20:08:47 <blast_hardcheese> HeladoDeBrownie: Completely understandable, I guess the answer to my question would be "using the safe package or lenses"
20:09:11 <zq> blast_hardcheese: lists are haskell's for loops
20:09:34 <blast_hardcheese> HeladoDeBrownie: although merijn and zq's responses were closer to what I was looking for-- Why is the thing I want not available? Because you shouldn't index lists
20:09:44 <codehero> kgadek: any reason the function is called rms?
20:10:02 <zq> codehero: root mean square
20:10:04 <kgadek> codehero: no idea, found that here: http://www.haskell.org/tutorial/numbers.html
20:10:11 <zq> wait no there's no mean going on
20:10:15 <codehero> ah, okay
20:10:17 <roboguy_> :t (Data.Vector.!)
20:10:18 <lambdabot> Data.Vector.Vector a -> Int -> a
20:10:19 <HeladoDeBrownie> blast_hardcheese, sorry, apparently my response was unclear in that regard, because I thought I also touched on that. I can see how it might not have come across though.
20:10:21 <codehero> hmm
20:11:11 <blast_hardcheese> HeladoDeBrownie: Looking back now, it's all very clear. I was looking at your answer expecting something different, overlooking what you were actually saying
20:11:17 <HeladoDeBrownie> blast_hardcheese, anyway, there are cases in which you do want to index a list, like you're handed one and you just want one specific element from it. In cases like that, lens and such can come in handy. Here's an example: xs ^? ix 0 gets either the 0th element or Nothing if there isn't one.
20:12:36 <roboguy_> codehero, zq: rms is the mean of the squares of the values multiplied by 0.5 and then square rooted (which is what that function is doing)
20:13:05 <codehero> okay. good to know ^^
20:13:12 <roboguy_> http://en.wikipedia.org/wiki/Root_mean_square
20:13:27 <zq> roboguy_: didn't i say root mean square like 5 minutes ago
20:13:38 <roboguy_> zq: yeah, but then you said there was no mean happening
20:14:12 <zq> roboguy_: that was before my wits re-coalesced and i noticed the 0.5 and presence of only two terms
20:14:52 <roboguy_> kgadek: how about something like [] == []?
20:15:12 <roboguy_> that's ambiguous without either defaulting or an explicit signature somewhere
20:16:19 <kgadek> roboguy_: hmr, defaulting probably does not goes here
20:16:20 <roboguy_> lambdabot has some automatic defaulting enabled (more than ghci I think) so it will work here though
20:16:29 <roboguy_> kgadek: ?
20:16:41 <kgadek> one moment
20:17:13 <kgadek> from Haskell Report, ch. 4.3.3
20:17:15 <kgadek> "at least one of these classes is a numeric class, (that is, Num or a subclass of Num), and"
20:17:28 <kgadek> one of the rules to fire defaulting
20:18:32 <kgadek> …and now I have no idea why [] == [] works
20:19:05 <kgadek> why does [] == [] work? how typechecker resolves this?
20:19:29 <roboguy_> kgadek: it doesn't work unless there is defaulting
20:19:40 <roboguy_> ghci defaults those []s to have the type [()]
20:19:41 <shachaf> It doesn't.
20:20:18 <Makoryu> :t let x = []; y = [] == x in x
20:20:19 <lambdabot> [t]
20:20:24 * Makoryu shrugs
20:22:13 <kgadek> shachaf: you're right, GHC complains.
20:22:42 <Ca3sar> What client is everyone using?
20:22:55 <HeladoDeBrownie> IRC client? irssi here
20:23:06 <roboguy_> LimeChat for me
20:23:07 <mayski> irssi
20:23:15 <Axman6> irssi
20:23:18 <kgadek> Ca3sar: Colloquy, but on Linux I use either irssi or weechat
20:23:32 <shachaf> kgadek: https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/interactive-evaluation.html#extended-default-rules
20:23:56 <Ca3sar> I'm on mac and don't know how to get Irssi to work so I'm using Thunderbird :P
20:24:11 <kgadek> Ca3sar: Colloquy is nice on OS X
20:24:20 <Ca3sar> I'll check it out
20:24:30 <kgadek> I have small perf. issues when my bouncer gives me a lot of history at once
20:24:53 <kgadek> but that's only happening once, when connecting so… meh
20:25:00 <Algebr```> erc
20:25:26 <roboguy_> I forget how to see defaulting in progress
20:25:39 <roboguy_> I just saw a stackoverflow question about it earlier too, but I can't find it
20:25:39 <shachaf> Ca3sar: Do you have any Haskell questions?
20:25:53 <merijn> roboguy_: -Wall should warn about defaulting
20:26:22 <kgadek> do I see well that this uses defaulting? `fromIntegral ( 2 + 3 )`
20:26:25 <roboguy_> merijn: oh yeah, there is that. but I was thinking somehow using :t
20:26:40 <geekosaur> kgadek, it does, yes.
20:26:40 <shachaf> Yes, that defaults (to Integer by default).
20:27:24 <kgadek> merijn: you're right, -Wall complains
20:27:32 <Ca3sar> shachaf: No I don't haha.
20:27:51 <shachaf> OK. That's the topic of this channel.
20:29:49 <jayunit100h> how is the 2nd field in the "data" syntax used?
20:30:03 <roboguy_> jayunit100h: what do you mean by the 2nd field?
20:30:06 <jayunit100h> i.e. data Book = Book author title -- makes sense
20:30:11 <jayunit100h> but...
20:30:28 <jayunit100h> data List a = Cons a (List a) -- makes no sense ?
20:30:31 <HeladoDeBrownie> jayunit100h, a is a type parameter
20:30:46 <jayunit100h> ohhh
20:30:47 <roboguy_> jayunit100h: it is a parameter just like how x is a parameter in the function definition f x = x + 1
20:30:48 <jayunit100h> ok i see
20:30:53 <HeladoDeBrownie> List String is a concrete type, and so is List Int, and List Bool, etc.
20:30:55 <roboguy_> but instead of taking a value, it takes a type
20:31:17 <HeladoDeBrownie> So on the right side, substitute a for whatever type you chose
20:31:20 <Axman6> data List<A> = ...
20:31:21 <jayunit100h> so the syntax of "data" is:
20:31:25 <HeladoDeBrownie> So List String has Cons String (List String)
20:31:26 <roboguy_> you can have zero or more parameters
20:31:31 <kgadek> merijn, geekosaur, shachaf, roboguy_: thanks all. Now I can get back to more "mechanical" part of writing...
20:31:33 <HeladoDeBrownie> Meaning you give it a String and another List String
20:31:51 <jayunit100h> data NAAME t1 t2 t3 t4 ... tn , where t1-n are type paratmers?
20:31:59 <Axman6> yes
20:32:00 <HeladoDeBrownie> jayunit100h, that's right.
20:32:05 <jayunit100h> roboguy_: ah okay thanks
20:32:11 <jayunit100h> #haskell is very helpful !
20:32:15 <HeladoDeBrownie> \o/
20:32:23 <jayunit100h> :)
20:35:49 * hackagebot doctest 0.9.11.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.11.1 (SimonHengel)
20:39:23 <bluebelle> how to represent a foldr as foldl again?
20:39:43 <bluebelle> *rewrite
20:40:39 <copumpkin> you can write foldl as a foldr
20:40:45 <roboguy_> bluebelle: that's not possible. the other way is though
20:40:49 <copumpkin> the other one isn't generally possible except in a "lossy" manner
20:41:07 <roboguy_> http://www.haskell.org/haskellwiki/Foldl_as_foldr
20:43:03 <bluebelle> ah yes, what I need is for the finite list one, thanks roboguy.
20:43:42 <bluebelle> doing an OcaML assignment lol
20:45:45 <roboguy_> bluebelle: ah, then laziness might not help any way
21:06:25 <zzo38> It look like the Template Haskell is much improved now; is there still the problem of not being able to have stuff that references other stuff which is found after a TH code? Also, does it work better now so that typechecking is not done when not necessary?
21:10:43 <aegray_> is there anything like hothasktags that can handle .lhs files?
21:20:32 <zzo38> I don't know what hothasktags means?
21:36:02 * hackagebot http-client 0.3.8.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.8.1 (MichaelSnoyman)
21:38:55 <zzo38> Is there any (TExp a -> Type) function?
21:51:48 <int-e> zzo38: Not in a meaningful way; there is no information about 'a' at runtime. It should be possible to write  typeableType :: Typeable a => a -> Type  or ... -> Q Type  (I don't know whether this functionality requires any lookups.)
21:52:07 <int-e> I do not know whether this has been done.
21:52:52 <zzo38> Actually (TExp a -> Q Type) is what I would have wanted if (TExp a -> Type) is not possible
21:53:20 <kgadek> is there a way to tell GHCi to load whole module via :m, not only its exported defs? or only possible via :load?
21:53:51 <shachaf> Only :load. :m doesn't load modules, it imports them.
21:54:03 <kgadek> uch. ok
21:54:21 <kgadek> or maybe you have a cool protip on how to help debug things?
21:54:33 <kgadek> I'm digging through the internals
21:54:41 <kgadek> will need to load everything
21:54:46 <kgadek> or maybe there's a better way?
21:55:10 <kgadek> to begin with: my quickcheck found a bug, trying to find where things are not looking well
21:56:00 <zzo38> Other thing is, is there a simple way to make "label types" using TH in a short kind of code?
21:57:36 <zzo38> (A "label type" is a data type used only to create a globally unique Typeable instance, and possibly may have other instances too which is used by the program.)
22:07:22 <Oksana> I am asking about PanDoc. It is said in User's Guide that LaTeX reader does pass through untranslatable LaTeX commands, even if -R is not specified. I do not see it in reality. An example is converting X\hl{Y}Z from tex to docx. Line 368, function inlineCommand in https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
22:09:29 <sgwizdak> hi -- so I'm using a fresh install of haskell platform (2014.2.0.0) and trying to do cabal install diagrams gets me a "The following packages are likely to be broken by the reinstalls" for network-2.4.2.3 and HTTP-4000.2.10. Bit of a cabal n00b, wondering what to do?
22:11:00 <dpn`> what would be the best x-platform GUI lib to use for a chat client style thing?
22:11:16 <dpn`> I'm leaning towards htk, but that's because of previous experiences in other languages
22:11:34 <ramfjord> hey guys
22:11:37 <dpn`> ideally something that can either be easily linked to - or statically linked for windows/osx
22:11:53 <zzo38> I find just using a terminal emulator works fine for that kind of stuff and you don't need a GUI, but if you want a GUI then I don't really know.
22:12:17 <zzo38> Something working on Windows, OS X, and Linux would be best, I suppose; if it is Windows/OS X only then it would not be as good.
22:13:14 <zzo38> (But I do know that terminal emulation works on all three systems.)
22:13:34 <dpn`> zzo38, ya.. gui implies for non-programmery types :)
22:13:34 <zwer> gtk2hs is one possibility
22:13:55 <dpn`> yeah that would be my second choice after htk
22:14:23 <dpn`> but gtk on windows tends to be a bit meh compared to modern versions of tk
22:15:03 <zzo38> Well, I am running my IRC client in a terminal emulator (specifically, PuTTY)
22:15:31 <zzo38> I also think IRC works fine and is pretty good internet chat protocol
22:16:12 * hackagebot hermit 0.6.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.6.0.0 (AndrewFarmer)
22:16:53 <ramfjord> Is there way to make a data type that is either of two other data types?
22:16:57 <zwer> dpn` out of curiosity what issues did you have with gtk2hs on windows? ugly/non-native, hard to install, something else?
22:16:59 <ramfjord> I'm aware Either
22:17:06 <ramfjord> but I mean something like a supercass
22:17:08 <ramfjord> class*
22:17:11 <ramfjord> as this code is trying to do
22:17:32 <ramfjord> http://pastebin.com/NS3B3vWz
22:18:33 <dpn`> zwer, that just about enumerates them!
22:20:24 <dpn`> zzo38, yeah I wanna make a flowdock client - you can use flowdock with an irc client, but it does a bunch of stuff that doesnt fit into the IRC protocol nicely, so it's a subpar experience
22:27:38 <Heffalump> dpn`: why not just use Either?
22:42:14 <jle`> const is kinda lame
22:42:32 <jle`> at least in the fully applied form
22:42:40 <jle`> i mean, the one argument applied form
22:42:46 <jle`> why use const x when you can just do (\_ -> x)
22:42:54 <jle`> i think the latter is a bit clearer
22:43:08 <jle`> down with const
22:43:25 <jle`> the movement begins today
22:43:49 <MP2E> But you can do fun things with Applicatives + Const http://comonad.com/reader/2012/abstracting-with-applicatives/
22:44:05 <MP2E> admittedly a little bit contrived, but there are still fun things to be done with const :V
22:44:12 <jle`> not the Const type
22:44:14 <bernalex> jle`: I don't think that's clearer than const
22:44:24 <MP2E> oh i see
22:44:30 <jle`> bernalex: you don't?
22:44:58 <jle`> well then we are at an impasse
22:45:15 <bernalex> I saw SPJ give a talk at the scala exchange or something. he was gobsmacked that there is no const function in the main scala libraries. (at least not that anyone in the audience could recall.) "well then, friends, get yourselves a better library then! how can you not have it! it's massively useful!"
22:45:33 <dibblego> it's massively difficult in Scala
22:45:39 <bernalex> dibblego: seriously?
22:45:39 <dibblego> @google apocalisp scala const
22:45:41 <lambdabot> http://apocalisp.wordpress.com/2010/04/21/a-proper-constant-function-in-scala/
22:45:41 <lambdabot> Title: A Proper Constant Function in Scala | Apocalisp
22:45:42 <dibblego> Yes seriously
22:45:53 <bernalex> lolwat
22:45:55 <jle`> maybe i should appreciate how far we have come to have even been able to write const
22:45:58 <jle`> but still
22:46:00 <dibblego> Scala does not do lazy evaluation properly
22:46:04 <bernalex> dibblego: I'm inclined to agree with SPJ then
22:46:15 <jle`> > length "const x"
22:46:16 <bernalex> I'll read that blog post when I get to work -- thanks
22:46:17 <lambdabot>  7
22:46:22 <jle`> > length "(\_ -> x)"
22:46:24 <lambdabot>  <hint>:1:11:
22:46:24 <lambdabot>      lexical error in string/character literal at character '_'
22:46:24 <dibblego> SPJ has the naive view that "we should just fix that thing in Scala" — I had that view in ~2006
22:46:30 <jle`> > length "(\\_ -> x)"
22:46:32 <lambdabot>  9
22:46:34 <jle`> o
22:46:40 <dibblego> it is an excessively optimistic view
22:46:58 <jle`> idk, when i see "const 5", i have to actually read and parse an english word to understand it
22:47:02 <jle`> (\_ -> x) is all symbols
22:47:09 <jle`> and commonly used symbols
22:47:11 <jle`> who doesn't love symbols
22:47:16 <jle`> i love symbols, you love symbols
22:47:18 <jle`> we all love symbols
22:47:49 <jle`> down with const
22:47:58 <bernalex> dibblego: also, hey. I don't think I've seen you in #haskell before for some reason. but I really liked your list reverse project example during that one talk about how monads are kind of just APIs.
22:48:37 <dibblego> bernalex: great
22:48:40 <bernalex> jle`: SPJ has my all-time favourite way of summing up every haskell program ever: "bleurgh open angle bracket dollar sign close angle bracket bleurgh"
22:48:59 <jle`> :)
22:49:46 <bernalex> dibblego: it perfectly sums up why the "well if hurr durr is so great, why doesn't derp use them???" argument is utterly myopic and broken.
22:50:36 <zzo38> dpn`: I don't know how flowdock works though
22:50:38 <bernalex> & with that I'm off to work
22:52:35 <zzo38> But what I like about IRC is it is a command text protocol and simply consists of commands with a given syntax
22:53:44 <zzo38> And it isn't difficult either; just PRIVMSG to send a message, JOIN to access channel, SUMMON to ask someone to access the IRC, etc with no kind of headers or whatever are needed; it is pretty simple really.
22:54:21 <dpn`> zzo38, yeah - me too, flowdock has threaded conversations and other HTML stuff.. good as a team chat tool, but using it via IRC can leave you looking like a bit of a leper (can't reply to threaded conversations in the right place etc)
22:55:30 <zzo38> If I want threaded conversations I wouldn't use a chat protocol (NNTP can perhaps be used?), and we don't need such HTML stuff either
22:56:25 <zzo38> (I also don't know many IRC servers actually implement SUMMON; does flowdock even have anything similar?)
23:10:00 <Oksana> I am asking about PanDoc. How do I make it Verbose? How can I get it to tell me about each single problem it encountered, ever? Each file it could not find, each LaTeX command it could not parse?
23:13:56 <MR4Y> I don't know if this is in topic, but why the vast majority of linux distros has haskell 2013.2.0.0 instead of 2014.2.0.0?
23:14:27 <merijn> MR4Y: Because linux distros are slow :)
23:17:07 <MR4Y> Then people with no compile experience like me has to bang their heads against the wall just to have the latest stuff installed.
23:17:29 <merijn> MR4Y: Why? You can just download GHC binaries from the GHC site?
23:18:18 <MR4Y> Last time I tried, hptool didn't compiled correctly therefore didn't installed.
23:18:44 <MR4Y> because the README instrudtions aren't clear for someone that never compiled anything before.
23:18:50 <MR4Y> *instructions
23:19:34 <merijn> I have no clue what hptool is
23:19:56 <adas> MR4Y: why don't you install your packages piece meal instaed of using the haskell platform?
23:20:43 <MR4Y> adas: Tried that as well. Win32 package didn't compiled properly under Linux using cabal
23:21:46 <int-e> that's unsurprising
23:21:50 <MR4Y> merijn: hptool is the thing you compile first before compiling haskell-platform from source
23:21:56 <int-e> why did you try to install Win32?
23:22:08 <merijn> MR4Y: Why are you compiling haskell-platform?
23:22:14 <int-e> (it's for windows, not for linux)
23:22:38 <MR4Y> As I said before, I've never compiled anything before, so I don't know.
23:23:17 <merijn> MR4Y: That's for compiling distributions of the Haskell platform, which you shouldn't be doing
23:23:22 <merijn> http://www.haskell.org/ghc/
23:23:35 <trap_exit> is there a tutorial on haskell -> app store that is more recent than 2011? (http://thechangelog.com/using-haskell-to-make-a-mac-app-store-app/) ?
23:23:42 <MR4Y> merijn: Because I wanted 2014.2.0.0 under linux. No distro has this version of haskell-platform, which no distro has atm.
23:23:43 <merijn> And then follow the link for cabal-install too
23:24:15 <MR4Y> Even the so-called NixOS has all version of haskell-platform...except the latest.
23:24:19 <merijn> MR4Y: The haskell platform is just a bunch of pre-built binaries, if the platform isn't up to date for your platform you're usually better off just downloading binary GHC/cabal and building libraries as you go
23:25:20 <MR4Y> merijn: So, I have to download 2013 to have 2014. Is there a way for me to do that without compiling?
23:25:43 <merijn> MR4Y: You don't need 2013 to have 2014
23:26:00 <MR4Y> merjin: Then how I do it?
23:26:01 <merijn> MR4Y: But you need a working haskell compiler to build the platform (which you shouldn't be doing, as previously mentioned)
23:26:20 <merijn> So, regardless of whether you plan to continue you will still need to download GHC
23:27:45 <Cale> trap_exit: https://pbs.twimg.com/media/BipGrLMCEAAnUfQ.png:large
23:28:25 <trap_exit> Cale ?
23:28:34 <Cale> It's a joke :P
23:28:35 <trap_exit> Cale: please enlighten me
23:28:46 <trap_exit> Cale: great
23:28:56 <trap_exit> anyone here writing Mac OSX apps in Haskell ?
23:29:05 <trap_exit> if so, canyou post link to tutoria? :-)
23:29:11 <MR4Y> merijn: Guess I'll have to stay on windows a little longer.
23:29:26 <trap_exit> unless you're Cale ... in which case you can go get stuck in an infinite loop :-)
23:29:59 <Cale> trap_exit: Is there any reason to believe that tutorial is out of date?
23:30:23 <trap_exit> absolutely none
23:30:23 <trap_exit> maybe I should read it
23:31:32 <MR4Y> "Linux is better for programming." they said. *facedesk*
23:32:07 <trap_exit> Linux is great
23:32:10 <trap_exit> if you like recompiling kernels for fun
23:32:30 <vanila> MR4Y, which GNU/linux distribution is this?
23:33:02 <MR4Y> vanila: either Lubuntu or Archlinux
23:33:42 <vanila> MR4Y, arch has a stupid bug where any cabal packages with non 7-bit ascii in the .cabal files break unless you do some weird workaround
23:34:53 <MR4Y> vanila: Great. I'm glad I uninstalled it before I was able to successfully compile something haskell realted on it.
23:35:51 <vanila> well it's a bug in cabal that just happens to show up on this distro, im sure it breaks elsewhere too
23:36:35 <dmj`> why does the haskell mailing list membership emails passwords in plain text?
23:36:51 <MR4Y> makes sense why otherp packages wouldn't compile as well.
23:37:01 <dmj`> why are*
23:37:12 <dmj`> eh poor english
23:45:50 <adas> is it worth going to this event (http://functionalconf.com/schedule.html) for an intermediate haskeller. i checked out the contents of the event, to see if it might be useful for me. Can't make up my mind...
23:52:06 <jle`> down with filter
23:52:32 <jle`> mapMaybe is the way to go
23:52:40 <jle`> fight boolean blindness in your codebase today
23:52:51 <jle`> you have the power
