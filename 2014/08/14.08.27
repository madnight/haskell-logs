00:08:11 * hackagebot scotty 0.9.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.9.0 (AndrewFarmer)
00:08:11 * hackagebot xmpipe 0.0.0.0 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.0 (YoshikuniJujo)
00:23:08 * hackagebot wai-predicates 0.8.1 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.8.1 (ToralfWittner)
00:23:10 * hackagebot wai-routing 0.10.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.10.1 (ToralfWittner)
00:24:42 <numberten> conduit question: is there a way to zipSink two sinks where one is the result of a 'sinkFile'?
00:24:57 <numberten> i've been having trouble with it due to the MonadResource constraint
00:35:24 <lfairy> numberten: can you show us your code? I don't see the problem
00:38:22 <numberten> zipSinks stdout (sinkFile "foo")
00:42:42 <numberten> the stdout Sink has MonadIO constraint and the sinkFile has a MonadResource constraint
00:43:08 <lfairy> numberten: you need to put runResourceT at the start of the whole thing
00:43:14 <lfairy> runResourceT $ blahblahblah $$ zipSinks ...
00:43:46 <numberten> ahh
00:43:49 <numberten> i feel silly
00:43:58 <numberten> I factored out everything but the runResourceT
00:44:12 <numberten> for some reason I thought I'd be able to make it typecheck w/o that
00:44:14 <numberten> lfairy: thank you
00:44:14 <Wizek> Good morning
00:44:21 <lfairy> numberten :D
00:44:25 <Wizek> Anyone knows how to install Chart-gtk?
00:44:25 <lfairy> morning
00:45:21 <Wizek> I tried to do it using `cabal install Chart-gtk`, but it just keeps telling me dependencies failed to install
00:45:43 <Wizek> Chart-gtk-1.2.4 depends on cairo-0.13.0.0 which failed to install.
00:46:00 <Wizek> Using cabal sometimes is so frustrating :(
00:46:37 <lfairy> do you have a log for cairo?
00:47:53 <Wizek> lfairy: You mean this? https://gist.github.com/Wizek/b1b15cef3321bbdf02da
00:48:53 <nilg> I need something like forM, but returning a Map associating the input to the output, instead of a list of the outputs, any idea?
00:48:57 <lfairy> Wizek: ooh I haven't seen that kind of error before
00:49:07 <Wizek> It could also be that my local cabal is entirely corrupted
00:49:16 <Wizek> I was having a lot of strange errors
00:49:19 <Wizek> since my last upgrade
00:49:44 <Wizek> ...of ghc. Is there a way to uninstall EVERYTHING haskell related?
00:49:58 <Wizek> then I'll try to reinstall and see if that solves it
00:50:14 <mr-> Wizek: delete .ghc and .cabal
00:50:19 <mr-> this might not be a cabal issue, though
00:51:12 <nilg> the type of what I am looking for is: Monad m => [a] -> (a -> m b) -> m (Data.Map a b)
00:51:20 <nilg> but hoogle says there is a syntax error
00:51:35 <nilg> anyway, I don't think it's in the library
00:51:55 <lfairy> hmm
00:53:02 <lfairy> :t (\f -> mapM (\x -> (,) x <$> f x))
00:53:04 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> [a1] -> m [(a1, a)]
00:53:11 * hackagebot alfred 0.2.1 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.2.1 (PatrickBahr)
00:53:55 <lfairy> :t \f -> fmap Map.fromList . mapM (\x -> (,) x <$> f x)
00:53:56 <lambdabot>     Not in scope: ‘Map.fromList’
00:53:57 <lambdabot>     Perhaps you meant one of these:
00:53:57 <lambdabot>       ‘M.fromList’ (imported from Data.Map),
00:54:02 <lfairy> :t \f -> fmap M.fromList . mapM (\x -> (,) x <$> f x)
00:54:04 <lambdabot> (Ord k, Functor f, Monad f) => (k -> f a) -> [k] -> f (M.Map k a)
00:55:29 <nilg> oh, thanks (I'm new to haskell it's gonna take me while to parse that)
00:56:04 <Wizek> mr-: I removed those 2 folders, and ghc --version still executes
00:56:53 <Wizek> $ where ghc \n /usr/bin/ghc \n /usr/local/bin/ghc \n /usr/bin/ghc
00:56:57 <mr-> Wizek: that removed everything that cabal could have messed up
00:57:21 <Wizek> I am also afraid that my GHC installation is messed up
00:57:30 <mr-> Wizek: how did you install ghc?
00:57:37 <Wizek> since it was a GHC upgrade that started the wierdness after all
00:57:46 <Wizek> I think I used brew first
00:57:54 <Wizek> then installed haskell-platform on top
00:58:12 <Wizek> I want to start from scratch
00:58:25 <mr-> what is brew?
00:58:34 <Wizek> OS X package manager
00:59:52 <mr-> Oh, sorry. I don't know how package management on OS X works. In any case, after you have reinstalled everything, it's good to run cabal update and update cabal-install (via cabal install cabal-install)
01:02:33 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
01:02:33 --- topic: set by glguy on [Fri Aug 15 13:29:35 2014]
01:04:55 <tomboy64> i need to solve a simple linear equation system
01:05:15 <tomboy64> someone care to recommend a library?
01:05:51 <MP2E> makalu: i don't get it, I found the source for GHC.Float just fine but docs seem to be missing
01:06:12 <MP2E> makalu: http://www.haskell.org/ghc/docs/7.8.3/html/libraries/base/src/GHC-Float.html
01:06:42 <makalu> thanks, that will do for now
01:07:36 <makalu> does anyone know how to construct infinity of Float or Double?
01:07:55 <makalu> nvm, 1/0 works :)
01:08:51 <Wizek> Ok, I think I now have a clean install of 7.8.3 via haskell platform
01:09:07 <Wizek>     Could not find module ‘Graphics.Rendering.Chart.Gtk.Simple’
01:09:29 <Wizek> $ cabal install Chart-gtk
01:18:27 <merijn> makalu: I think you can read Infinity too
01:18:34 <merijn> > read "Infinity" :: Double
01:18:36 <lambdabot>  Infinity
01:19:12 <merijn> Wizek: Which version of OSX?
01:19:24 <MP2E> > maxBound :: Double
01:19:25 <merijn> oh, you installed platform already
01:19:25 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
01:19:26 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
01:19:35 <merijn> MP2E: Double isn't bounded :)
01:19:46 <MP2E> Ah, I had thought maxBound would be Infinity :P
01:20:03 <Wizek> 10.9.4
01:20:05 <MP2E> guess that doesn't really make sense
01:20:09 <Wizek> merijn: ^
01:25:13 <mr-> Wizek: weird.. installation works for me. Have you tried to install it in a sandbox? (I know, the error does not look like that should help..)
01:27:26 <halvorg>  Module ‘Data.Aeson’ does not export ‘FromJson’
01:27:33 <halvorg> any tips? aeson 0.8.00
01:28:00 <halvorg> http://hackage.haskell.org/package/aeson-0.8.0.0/docs/src/Data-Aeson.html FromJson seems to be exported there?
01:28:01 <brbblnch> Hi
01:28:27 <shachaf> halvorg: Check your capitalization.
01:28:35 <halvorg> meh
01:28:36 <halvorg> thanks
01:29:21 <Odda> Hi all. Haskell beginner here. I'm trying to run the cqrs-example project through ghci (it works nicely if I build it with runhaskell Setup.hs build). I naively tried to :l Main.hs, but it complains about not finding CQRSExample.Routing. Calling 'main' after loading Setup.hs a few steps up just gives me 'no command given'. What am I missing?
01:30:09 <Wizek> https://gist.github.com/Wizek/b1b15cef3321bbdf02da#file-after-clean-install-shell
01:30:20 <Wizek> mr-: Even clean isntall didn't help
01:30:31 <brbblnch> Assume I have bound "x = 4" in some code, and later, I define a function "f :: Maybe Int -> Int" with the definition "f (Just x) = x" . It seems to me that haskell considers the variable x to be matched to whatever it can, so that my old binding isn't used. Is there a way to force the old value in the matching ?
01:31:44 <shachaf> No. The new x "shadows" the old x.
01:31:59 <shachaf> You can write f (Just y) | y == x = ..., if you want.
01:32:11 <mr-> Wizek: "Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH" have you done that?
01:32:17 <shachaf> But pattern-matching doesn't check equality -- in fact there's no built-in notion of equality in the language.
01:33:40 <brbblnch> shachaf: Thanks! Do you have any link on the 'checking equality' part ?
01:33:54 <makalu> has anyone used company-ghc? I can't type anything while it searches for completions. Is that normal?
01:33:58 <shachaf> What sorts of links?
01:34:12 <brbblnch> developement, explanation
01:34:43 <shachaf> There's no notion of equality built into the language. There's only Eq, which is just a regular type class (with a bit of compiler support for autoderiving it), and pattern-matching, which is structural.
01:35:21 <shachaf> I think I liked the discussion of it in SPJ's book, The Implementation of Functional Programming Languages.
01:35:32 <shachaf> @where ifpl
01:35:32 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
01:35:36 <shachaf> But that's maybe a bit specialized.
01:37:11 <brbblnch> shachaf: So, pattern matching only matches on type constructors, so that trying to match *values* isn't doable ?
01:37:35 <jle`> brbblnch: well, sometimes constructors are actual values, too
01:37:39 <shachaf> It matches on data constructors (type constructors are things like Maybe that exist at the type level).
01:37:53 <jle`> boolToInt False = 0
01:37:56 <jle`> boolToInt True = 1
01:38:05 <jle`> i matched on a value :)
01:38:16 <shachaf> But you can't "match on values", yes. There's no general notion of two values being equal.
01:38:33 <shachaf> There are some special cases for things like numeric literals.
01:39:06 <brbblnch> nice, thanks!
01:39:36 <jle`> foo 4 = ... is weird, yeah.  so that's a case that equality might be considered "built in".  but i think it is abstracting over the idea that Int/numbers are just "normal" data type with a bunch of constructors.
01:40:06 <jle`> but it requires Eq in practice
01:40:37 * hackagebot alfred 0.2.1 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.2.1 (PatrickBahr)
01:40:37 * hackagebot dns 1.4.4 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.4 (KazuYamamoto)
01:50:34 * hackagebot handle-like 0.1.0.2 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.1.0.2 (YoshikuniJujo)
01:59:14 <trap_exit> when programming in ahsekll, is it better to (1) write little increment parts, then test them or (2) write the entire program, and want it to run on the first try ?
02:00:05 <MP2E> incremental parts, imo. The type system is pretty conducive to building it up piece by piece
02:00:48 <MP2E> testing the little pieces isn't a bad idea either, if your program is just little actions composed into big actions, if the little actions are correct it's much easier to prove the big actions are correct too
02:05:53 <mr-> trap_exit: is there a programming language where (1) is not preferable over (2)?
02:06:08 <trap_exit> I dunno
02:06:13 <trap_exit> having read the biography of Tesla
02:06:17 <trap_exit> I get the impression taht he onlydid (2)
02:06:35 <trap_exit> (he claims) he would design + visualize machines in his head, ... debug them ... build them, and they'd work the first time
02:06:45 <eazar001> nikola tesla is a gneius
02:06:52 <trap_exit> also, I thikn most of mathematics is done via (2)
02:07:01 <trap_exit> and Haskell code almost feels more like math than programming
02:07:12 <doismellburning> trap_exit: I would disagree re maths, imle
02:07:16 <mr-> trap_exit: that's not at all true in math.
02:07:31 <trap_exit> in my experience, which is limited
02:07:33 <exio4> i normally write all the type signatures, and then start writing code that compiles!
02:07:34 <trap_exit> in math, you stare at the problem
02:07:37 <trap_exit> you goof around
02:07:41 <trap_exit> then you get th ehigh level intuition
02:07:46 <trap_exit> and bam, you define the right lemas and things fall into palce
02:07:48 <mr-> trap_exit: then break it up into smaller problems, solve those..
02:08:03 <trap_exit> mr-: yes ... but I fee like the way I do (1)
02:08:11 <trap_exit> is like defining lemmas w/o knowing the higher level intuition
02:09:09 <trap_exit> maybe I am just a not good at ahskell yet
02:09:13 <trap_exit> but I feel when I try to do (1), it's like
02:09:16 <trap_exit> I need to build a sky scraper
02:09:21 <trap_exit> so let' em lay bricks and build the first floor
02:09:28 <trap_exit> afte rthe first floor is done, let me build 2nd floor
02:09:30 <trap_exit> when I get to floor 10
02:09:31 <trap_exit> it's like
02:09:35 <trap_exit> oh shit, I need a deeper foundation
02:09:39 <trap_exit> let me tear everything down and dig deeper
02:10:06 <mr-> trap_exit: I think that's not really related to haskell that much. Try both styles, try something in the middle, try just writing type signatures at first, use undefined liberally
02:10:11 <simpson> trap_exit: This is actually a common problem! Think of it this way: The skills and structures needed to build a 20-line, 200-line, 2000-line, and 20000-line program are all different.
02:10:55 <Cale> trap_exit: Mathematics as published tends to look like (2), but nobody actually does it that way.
02:10:55 <trap_exit> simpson: ha, so true
02:11:24 <trap_exit> simpson: at around the 2k-lines-of-code, I start realizing taht my "incremental / intuitive next step" start falling apart. How do I get to 200,000 lines of haskell code program ?
02:11:33 <Cale> trap_exit: There's no way that you can know what the right definitions are that will make the solutions of the problems you want to solve clear at the beginning
02:11:54 <simpson> trap_exit: Planning, iteration, testing.
02:12:13 <trap_exit> Cale: right, so you "goof around" get the right intuition, then start defining stuff --- which imho, is different from "code taht compiles + runs at every incremental stage"
02:12:23 <Cale> Well, you can do a lot of things. You can build a sort of vertical thread from the highest level down to the foundation and get it to run, and then expand outward around that
02:12:29 <trap_exit> Cale: most "stages" in mathematics seems like ahskell code with blah = _ " all over the palce
02:12:37 <trap_exit> rather than code that compiles, runs, and makes a little piece of incremental progress
02:12:53 <Cale> You can indeed start out just by writing high level "code that you'd like to be able to write" and then see if you can actually implement something close to that
02:12:54 <adas> can someone please tell me whats (1) and (2)? i came in the middle of it all
02:12:54 <trap_exit> simpson: you know what? I'd love to read a literate haskell 200,000 line program
02:13:04 <Cale> adas: <trap_exit> when programming in ahsekll, is it better to (1) write little increment parts, then test them or (2) write the entire program, and want it to run on the first try ?
02:13:27 <trap_exit> where by ahskell, I meant haskell
02:13:37 <Cale> trap_exit: In my experience, you can make very significant refactorings to Haskell code and still have it work again on the other end once it compiles again.
02:14:06 <trap_exit> Cale: in my experiecne taht is true too, it's (1) change the types (2) get lots of compile errors, (3) fix them, (4) code probably works again
02:14:43 <MP2E> well, yeah.. What's the problem here? It can't work by magic :P
02:14:52 <Cale> trap_exit: I've worked on fairly large Haskell programs. At one point I was refactoring some things in our FRP system for a game, which was about 8000 lines of code, and the refactor touched hundreds of lines of code, and there were a lot of type errors to steamroll through, but at the end, it compiled and worked.
02:15:02 <Cale> Yeah, exactly
02:15:21 <Cale> So, you don't have to worry *that* much about having a perfect design at the outset
02:16:00 <Cale> This isn't actually too specific to Haskell, though the type system really makes refactorings possible that would instead be rewrites in an untyped language.
02:16:32 <trap_exit> MP2E: What? Not magic? My honeymoon with Haskell may have just come to an end
02:16:40 <MP2E> haha
02:16:43 <MP2E> It
02:16:46 <MP2E> It's awfully close*
02:16:55 <Cale> In any language, if your program takes weeks to write, probably it's not going to be ideal the first time you write it.
02:17:30 <trap_exit> I guess the problem is: I'm very familiar with monads + type classes + prelude builtins -- I fee like I should be more productive in ahskell
02:17:31 <Cale> You'll probably get to the end and have some new perspective on how to do it over better.
02:17:44 <trap_exit> but in mode (1), after every "little increment" I get into this coder's block in trying to figure out the next step
02:17:47 <trap_exit> and I feel like there should be a more productive way to do haskell coding
02:18:46 <Cale> Well, what is productivity? In many ways, thinking doesn't really work like, say, physical activities. If you're digging a trench, you can sort of tell how productive you're being.
02:19:16 <doismellburning> classic "throw the first one away"
02:19:24 <doismellburning> but also see "second system syndrome"
02:19:26 <Cale> But when most of the work you're doing is trying to get an idea into your head...
02:20:37 <trap_exit> "no silver bullet"
02:20:53 * eikke__ has a silver bullet
02:21:15 <halvorg> Are there any HDBC postgres examples?
02:21:16 <silver> woah woah
02:21:19 <halvorg> short and sweet preferably
02:21:54 <Cale> trap_exit: But yeah, focus on the bits that you know how to do, and then see if you can find a way to connect them together
02:22:00 <trap_exit> halvorg: RWH does sqlite3. what postgres specific feature do you need?
02:22:33 <halvorg> trap_exit: It's just the db we're familiar with.
02:22:51 <trap_exit> Cale: you know, I would like to be able to do the high level, top-down design in ahskell, with the compiler helpng me check type errors
02:23:03 <trap_exit> Cale: but "_" causes the compiler to throw an error, so it's hard to "make progress this way"
02:23:06 <trap_exit> since as I write more code, I get more, not less compiler errors
02:23:09 <Cale> trap_exit: hm?
02:23:17 <trap_exit> right now, it seems like I need to build all the little pieces before I can do the high level design
02:23:17 <Cale> trap_exit: You can always fill in any value with undefined
02:23:33 <trap_exit> blah = undefined; rather than blah = _ ?
02:23:37 <MP2E> yep
02:24:00 <trap_exit> hmm
02:24:37 <trap_exit> halvorg: I would try following the sqlite3 example, with postgres specific login procedures
02:24:51 <trap_exit> halvort: the chapter's rather quick/easy
02:25:23 <halvorg> Sounds great.
02:25:31 <doismellburning> trap_exit: oh right, I see what you mean now
02:25:45 <trap_exit> Cale, MP2E: this is intersting, undefined is useful,
02:26:03 <doismellburning> trap_exit: I'd describe "top down dev" as distinct from your (2)
02:26:17 <MP2E> trap_exit: I love undefined, I liter it throughout my code in the early stages
02:26:43 <trap_exit> haskell undefined is like 'wishful thinking' in mathematics
02:26:46 <sdx23> hi. Is there something like [(a -> m b)] -> a -> [m b] (applying multiple monadic functions to the same argument) - i'm trying to avoid some lambdas...
02:26:52 <trap_exit> if someone proivded me a function that did BLAH, then using it, I can do FOO BAR
02:27:10 <trap_exit> sdx23: this looks close to sequence
02:27:22 <trap_exit> oh, sequence does not have the ( a -> ... ) part, my bad
02:27:33 <sdx23> trap_exit: sequence is for multiple arguments - but you're right.
02:28:00 <trap_exit> doismellburning: in your mind, how does (2) differ from "top down dev" ?
02:28:07 <sdx23> trap_exit: maybe i could indeed use sequence in combination with the application operator.
02:28:23 <doismellburning> trap_exit: "want it to run on the first try"
02:28:34 <trap_exit> foo lst a = sequence [ f a | f <- lst] ?
02:28:36 <trap_exit> wait
02:28:48 <trap_exit> foo lst a = [ f a | f <- lst] <- this is what you want, right?
02:29:12 <trap_exit> f has type "a -> m b"
02:29:15 <trap_exit> so "f a" has type "m b"
02:29:44 <MP2E> Perhaps put 'a' as in a singleton list and use <*>?
02:29:49 <sgronblo> Isn't List Applicative?
02:29:56 <trap_exit> sdx23: tell me I'm right and I'm brilliant :-)
02:29:57 <sgronblo> like he said
02:30:16 <sgronblo> And I was trying to say "Isn't it List Applicative?"
02:30:28 <sdx23> trap_exit: you're right. for the brilliant - i hate liste comprehensions ;)
02:31:05 <trap_exit> sdx23: I hate multiline list comprehensions
02:31:10 <trap_exit> but single line I like :-)
02:31:33 <sdx23> thanks for the suggestions, i'll see how i can use that
02:31:36 <sdx23> trap_exit: haha, alright
02:32:00 <trap_exit> MP2E , doismellburning: alright, I'm goign to try this 'undefined' trick -- and if it doesn't work, I'm going to bother you guys on irc
02:32:38 <mr-> > map ($ 0) [(+1), (+2)] -- if you really don't like list comprehensions, sdx23
02:32:40 <lambdabot>  [1,2]
02:32:50 <sgronblo> try this one weird 'undefined' trick that makes imperative programmers hate him
02:32:59 <MP2E> haha
02:33:00 <doismellburning> relatedly, is there a tool to point at some haskell source and point out undefineds and partial functions?
02:33:15 <doismellburning> I realise thanks to laziness that they're "not always bad"
02:33:23 <sgronblo> maybe some ghc flag?
02:33:38 <sgronblo> grep? :)
02:33:40 <doismellburning> but I do tend to write relatively top-down code, with occasional quick fromJusts 'til I refactor
02:33:49 <doismellburning> hah yes, I use grep now, but it's a little...coarse
02:34:04 <dcoutts_> doismellburning: ghc -Wall gets some (incomplete pattern matching), hlint will point out ones from the standard lib
02:34:33 <MP2E> cgrep recognizes different programming languages and matches within them, and it recognizes haskell (since it is written in it)
02:34:38 <MP2E> maybe cgrep would be useful for this purpose?
02:34:52 <sgronblo> didnt know about cgrep
02:34:58 <sgronblo> is it solid?
02:35:15 <MP2E> I've used it a bit and I like it, though I keep reflexively using grep :P
02:35:21 <MP2E> hehe
02:35:28 <MP2E> gotta get it down to habit
02:35:33 <MP2E> or maybe alias grep to cgrep
02:35:51 <sgronblo> I tend to use mostly ack already
02:36:32 <doismellburning> dcoutts_: cheers
02:36:52 <doismellburning> `ghc-options:         -Wall -Werror -fno-warn-missing-signatures` ftw ;)
02:40:40 * hackagebot hakyll 4.5.4.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.4.0 (JasperVanDerJeugt)
02:41:18 <sdx23> mr-: aye, i think that's prettier
02:43:14 <trap_exit> what?
02:43:14 <trap_exit> you're kidding right?
02:43:43 <trap_exit> well, I guess "map ($ a) lst" hmm, is not too bad
02:51:06 <pjdelport> > [(+1), (+2), (+3)] <*> pure 10
02:51:08 <lambdabot>  [11,12,13]
02:52:31 <trap_exit> so I've decided
02:52:33 <trap_exit> I like this undefined trick
02:52:46 <trap_exit> however, I'd still love to read a literate haskell 200k prog
02:52:47 <trap_exit> just to see how it's done
03:05:06 <MichaelBurge> Hi all - I'm trying to 'cabal install gtk2hs' on a Windows machine and am getting an error like 'Missing C library: cairo', along with a few other libraries.
03:05:21 <MichaelBurge> I'm having trouble convincing cabal to use some compiled libraries and headers
03:06:01 <MichaelBurge> The gtk2hs package seems to declare its dependency with a 'pkgconfig-depends: cairo >= 1.2.0' line, and a 'pkg-config --cflags cairo' outputs reasonable cflags for including these headers
03:07:34 <MichaelBurge> Is there a way to get cabal to provide more information on what it's searching for?
03:09:02 <supki> MichaelBurge: -v3 will make its output more verbose
03:12:12 <MichaelBurge> supki: Thanks - that tells me that ld is skipping the libraries because they're incompatible.
03:19:03 <Twey> What happened to Tekmo?  Did he leave us?
03:24:21 <Dre3ml0rd> hi guys, Im starting to learn to use haskell, any tips?
03:24:47 <Iceland_jack> Write code and ask questions!
03:24:56 <Twey> Dre3ml0rd: Everything's easier than you think :þ
03:24:58 <pjdelport> Dre3ml0rd: Try many things and ask many questions!
03:25:22 <Dre3ml0rd> haha thanks guys, I heard this community was really helpful so I decided on Haskell
03:25:55 <doismellburning> Dre3ml0rd: I found reading LYAH + RWH to be very useful
03:27:01 <Dre3ml0rd> doismellburning: thanks Im using LYAH atm
03:27:52 <Iceland_jack> Dre3ml0rd: You can evaluate and check the type of expressions on #haskell with lambdabot and see the source of the more common functions as well
03:27:54 <Iceland_jack> > 5 + 10
03:27:56 <lambdabot>  15
03:27:57 <Iceland_jack> :t 'a'
03:27:59 <lambdabot> Char
03:28:21 <Iceland_jack> That can be useful
03:28:23 <Iceland_jack> @src map
03:28:23 <lambdabot> map _ []     = []
03:28:24 <lambdabot> map f (x:xs) = f x : map f xs
03:28:31 <Dre3ml0rd> ok so it just works on the irc
03:28:33 <Dre3ml0rd> thats cool
03:28:38 <Dre3ml0rd> 3 + 3
03:28:41 <Dre3ml0rd> fuck
03:28:48 <Iceland_jack> Dre3ml0rd: You need to add '> '
03:28:49 <lpaste> SwashBuckla pasted “fmap over tuple (Pair)” at http://lpaste.net/110097
03:28:54 <Dre3ml0rd> > 3 + 3
03:28:56 <lambdabot>  6
03:29:01 <Dre3ml0rd> ok great news
03:29:28 <SwashBuckla> hi there. How could I make the Functor instance work as I have indicated?
03:29:30 <a27764> > 3 + 3
03:29:32 <lambdabot>  6
03:29:37 <Iceland_jack> SwashBuckla: 'Pair' should only have a single parameter
03:29:55 <Iceland_jack> You may want to try
03:29:55 <Iceland_jack>     data Pair a = Pair a a
03:30:12 <Iceland_jack> SwashBuckla: the kind of Functor is
03:30:12 <Iceland_jack> @kind Functor
03:30:13 <lambdabot> (* -> *) -> Constraint
03:30:33 <Iceland_jack> So Pair needs to ‘fit’ (have the same kind) as * -> *
03:31:29 <lpaste> nyuszika7h pasted “No title” at http://lpaste.net/8942739865871581184
03:31:33 <nyuszika7h> what's wrong with this ^?
03:31:53 <nyuszika7h> FortyTwo.hs:21:23: parse error on input `='
03:32:09 <nyuszika7h> (yes, I did define symEq and then not use it, that's a recent addition >_>)
03:32:17 <Iceland_jack> nyuszika7h: You want (==) in 'x = 6' and 'x = 9'
03:32:19 <nyuszika7h> oh I see I'm using "=" instead of "++"
03:32:22 <nyuszika7h> *"=="
03:33:03 <lpaste> nyuszika7h revised “No title”: “No title” at http://lpaste.net/8942739865871581184
03:33:14 <nyuszika7h> shush lpaste :P
03:34:05 <Iceland_jack> nyuszika7h: You're also going to want an 'Eq a' constraint
03:34:13 <nyuszika7h> yeah, true
03:34:19 <Yep> TIA! So I'm thinking I need to use nested Attoparsec parsers for a data structure like "Word16 Word16 BASE64 Word16" etc where the BASE64 structure is then decoded and parsed (more binary data). Nested parsers seems like the simplest approach. Is there a common approach to nesting attoparsec parsers or do I just call "parseOnly" or similar twice (once on the data as a whole and once on the internal bytestring)?
03:35:19 <Iceland_jack> nyuszika7h: and when you have the constraint already you may want to write it as
03:35:19 <Iceland_jack>     6 * 9 = 42
03:35:19 <Iceland_jack>     9 * 6 = 42
03:35:19 <Iceland_jack>     x * y = x P.* y
03:35:42 <Iceland_jack> Which you may find clearer
03:35:47 * hackagebot references 0.2.1.1 - Generalization of lenses, folds and traversals to handle monads and addition.  http://hackage.haskell.org/package/references-0.2.1.1 (lazac)
03:35:54 <nyuszika7h> yep, forgot about that, thanks
03:36:38 <Iceland_jack> :t let { 6 ** 9 = 42; 9 ** 6 = 42; x ** y = x * y } in (**)
03:36:40 <lambdabot> (Num a, Eq a) => a -> a -> a
03:37:12 <iron_houzi> How do I make a set difference between two lists: foo = [ 1, 2 ] and bar = [ 2, 3 ] ? I've found that I can use set comprehensions for this like: [x | (x <- foo) && !(x <- bar)], but I don't know how to express "not an element of". I want foo \ bar btw..
03:37:45 <nyuszika7h> that would be (not . elem)
03:37:52 <Iceland_jack> or
03:37:52 <Iceland_jack> :t notElem
03:37:53 <lambdabot> Eq a => a -> [a] -> Bool
03:38:07 <MichaelBurge> > [1,2,3] \\ [2,3]
03:38:08 <lambdabot>  [1]
03:38:25 <solirc> With GHC now coming with `tranformers-0.3.0.0` doctest is effectively unusable for me now :(
03:38:52 <iron_houzi> MichaelBurge: I tried foo \\ bar, which didn't work ..
03:39:08 <a27764> > :t (\\)
03:39:09 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:39:32 <a27764> :t (\\)
03:39:33 <lambdabot> Eq a => [a] -> [a] -> [a]
03:39:45 <MichaelBurge> iron_houzi: Did you import Data.List? Or do you really want a set difference and not a list difference?
03:39:55 <lpaste> nyuszika7h revised “No title”: “No title” at http://lpaste.net/8942739865871581184
03:41:17 <iron_houzi> MichaelBurge: I really want a set difference and I didn't import Data.List.
03:42:58 <MichaelBurge> > (fromList [1,1,1,2,2,3]) \\ (fromList [1,2])
03:43:00 <lambdabot>  Not in scope: ‘fromList’
03:43:00 <lambdabot>  Perhaps you meant one of these:
03:43:00 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
03:43:00 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
03:43:00 <lambdabot>    ‘S.fromList’ (imported from Data.Set)Not in scope: ‘fromList’
03:43:13 <MichaelBurge> > (S.fromList [1,1,1,2,2,3]) \\ (S.fromList [1,2])
03:43:14 <lambdabot>  Couldn't match expected type ‘[a]’
03:43:14 <lambdabot>              with actual type ‘Data.Set.Base.Set a0’Couldn't match expected t...
03:43:14 <lambdabot>              with actual type ‘Data.Set.Base.Set a1’
03:43:30 <Iceland_jack> > S.fromList [1,1,1,2,2,3] S.\\ S.fromList [1,2]
03:43:32 <lambdabot>  fromList [3]
03:44:07 <iron_houzi> cool, what's 'S' ?
03:44:12 <MichaelBurge> Data.Set
03:44:17 <Iceland_jack> It's just the qualifier for Data.Set
03:44:57 <iron_houzi> OK
03:45:54 <Wizek> I'm starting to give up on using "Chart" (since I cant really install it). Are there any (simpler?) alternatives?
03:48:12 <MichaelBurge> Wizek: What was the problem you were having?
03:52:11 <kuribas> Which emacs interface to ghc is better, ghc-mod, or flycheck?
03:54:25 <bennofs> kuribas: ghc-mod can also provide type info and auto completion. You can also run it as a persistent process, so you don't need to startup GHC each time. This means that compiles will be faster (as fast as :reload in ghci) but it will require more memory.
03:55:49 * hackagebot uhc-util 0.1.3.7 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.7 (AtzeDijkstra)
03:57:28 <kuribas> bennofs: Does it have a persistent process by default?
03:58:01 <bennofs> kuribas: idk, but I know that it supports both (ghc-modi executable is persistent, ghc-mod executable not)
04:08:13 <kuribas> How can I install just the documentation of all packages?
04:08:53 <kuribas> Why is "documentation = False" the default?
04:09:16 <bergmark> it takes time
04:10:04 <kuribas> I don't mind...
04:10:38 <bergmark> i do :-)
04:11:05 <kuribas> bergmark: But then you have a good API documentation, with cross-references.
04:11:14 <bergmark> i just use hackage
04:11:46 <bergmark> and i reinstall things so many times in so many sandboxes so it's just extra time
04:13:58 <freeaaa> http://tinyurl.com/p5bpscx   safe soccer tips
04:14:24 <iron_houzi> How do I do set union and set intersection in haskell?
04:14:47 <iron_houzi> I've tried let foo = [x | x <- a && x <- b]
04:14:55 <kuribas> iron_houzi: Data.Set
04:15:19 <iron_houzi> I have imported that. I should learn how to lookup documentation for modules.
04:15:30 <kuribas> iron_houzi: You can just google :)
04:15:32 <Iceland_jack> @hoogle union
04:15:34 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
04:15:34 <lambdabot> Data.IntMap.Strict union :: IntMap a -> IntMap a -> IntMap a
04:15:34 <lambdabot> Data.IntMap.Lazy union :: IntMap a -> IntMap a -> IntMap a
04:15:46 <pjdelport> iron_houzi: Do you know Hackage and Hoogle?
04:15:50 <Iceland_jack> @hoogle Data.Set.union
04:15:50 <lambdabot> Data.Set union :: Ord a => Set a -> Set a -> Set a
04:15:50 <lambdabot> package union-find
04:15:50 <lambdabot> package union-find-array
04:15:53 <Iceland_jack> @hoogle Data.Set.intersect
04:15:53 <lambdabot> Data.Set intersection :: Ord a => Set a -> Set a -> Set a
04:16:02 <kuribas> http://www.haskell.org/ghc/docs/7.8.3/html/libraries/containers-0.5.5.1/Data-Set.html
04:16:06 <pavonia> > [1,2,3] `intersection` [3,4,5]
04:16:09 <lambdabot>  Not in scope: ‘intersection’
04:16:09 <lambdabot>  Perhaps you meant one of these:
04:16:09 <lambdabot>    ‘IM.intersection’ (imported from Data.IntMap),
04:16:09 <lambdabot>    ‘M.intersection’ (imported from Data.Map),
04:16:09 <lambdabot>    ‘S.intersection’ (imported from Data.Set)
04:16:15 <Iceland_jack> > [1,2,3] `intersect` [3,4,5]
04:16:17 <lambdabot>  [3]
04:16:33 <iron_houzi> thanks
04:16:48 <Iceland_jack> > S.fromList [1,2,3] `S.intersection` S.fromList [3,4,5]
04:16:50 <lambdabot>  fromList [3]
04:17:02 <pavonia> Why is it union but intersect!? :S
04:17:06 <kuribas> Why you should never use list set functions: https://github.com/nh2/haskell-ordnub
04:18:34 <Iceland_jack> Good point kuribas
04:18:40 <Iceland_jack> If you want set functionality, use Data.Set
04:18:43 <kuribas> pavonia: to save 3 chars :)
04:19:15 <kuribas> The interesting bit is that a tree is always faster, even for small lists!
04:24:40 <kuribas> Something I always wondered, if I put dependencies in my cabal file, how will I know that future version will support my library?
04:24:52 <bennofs> kuribas: you don't
04:25:16 <kuribas> bennofs: So I add a restriction only when it appears that a new version breaks the library?
04:25:21 <mmmm> anyone else had trouble compiling ghc with ubuntu 14.04?
04:26:29 <bennofs> kuribas: yes, with the new hackage you can edit the cabal file after the package was already released
04:26:45 <kuribas> oh, I see
04:28:41 <guhou> Does anyone have experience with using cabal sandbox?
04:30:28 <guhou> I've got a clean install of Haskell Platform and I'm using cabal sandbox, but I'm already getting warnings about reinstalls
04:30:58 <mmmm> hmmm, what commands have you used?
04:32:08 <guhou> I pulled a repo from git, then did a cabal sandbox init
04:32:26 <guhou> then cabal install --only-dep
04:33:02 <kuribas> Strange, I have base > 3 in my cabal file, but ghc-mod cannot find it...
04:34:50 <dramforever> Some people complain that the haskell platform is too big and bloated and slow to install
04:35:48 <dramforever> related: can I cross-compile to windows on a linux box?
04:35:52 <Tuplanolla> There's definitely some truth in that.
04:36:20 <dramforever> Tuplanolla: yeah, it even has opengl
04:36:24 <iron_houzi> If variables are immutable, how do I reassign a variable without restarting ghci?
04:36:34 <dramforever> iron_houzi, let again
04:36:38 <Iceland_jack> iron_houzi: You can shadow old variables
04:36:41 <dramforever> like this:
04:36:55 <dramforever> @let exampleForIronHouzi = 123
04:36:59 <lambdabot>  Defined.
04:37:07 <dramforever> > exampleForIronHouzi
04:37:09 <lambdabot>  123
04:37:14 <dramforever> @let exampleForIronHouzi = 567
04:37:16 <lambdabot>  .L.hs:162:1:
04:37:16 <lambdabot>      Multiple declarations of ‘exampleForIronHouzi’
04:37:16 <lambdabot>      Declared at: .L.hs:161:1
04:37:16 <lambdabot>                   .L.hs:162:1
04:37:20 <dramforever> oops...
04:37:22 <Iceland_jack> ...
04:37:24 <exio4> good lambdabot
04:37:25 <dbushenko> :-S
04:37:27 <dramforever> But ghci will let you do that
04:37:27 <iron_houzi> I see. I was sure I already tried to use let again..
04:37:43 <dramforever> @undef exampleForIronHouzi
04:37:43 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
04:37:57 <dramforever> iron_houzi: are you chinese?
04:37:58 <kuribas> iron_houzi: if you do that with -Wall, ghc will give a warning.  It's fine in ghci for testing though.
04:38:04 <Iceland_jack> ghci> let b = 'a'
04:38:05 <Iceland_jack> ghci> let b = 'b'
04:38:05 <Iceland_jack> <interactive>:5:5: Warning:
04:38:05 <Iceland_jack>     This binding for ‘b’ shadows the existing binding
04:38:06 <iron_houzi> dramforever: I am not
04:38:08 <Iceland_jack>       defined at <interactive>:4:5
04:38:10 <dramforever> I think houzi means monkey
04:38:17 <iron_houzi> dramforever: You are correct
04:38:41 <Iceland_jack> so when you ‘redefine’ a variable in GHCi, you're simply shadowing an old definition
04:38:51 <Iceland_jack> You're not mutating it
04:38:52 <iron_houzi> OK
04:38:59 <dramforever> Do we have #fedora-haskell or #haskell-fedora?
04:39:20 <dramforever> #fedora-haskell
04:40:24 <iron_houzi> So if I do 'let foo = [1, 2]` and then: 'let foo = S.fromList foo` <error!>
04:40:36 <iron_houzi> Why is this happening?
04:40:59 <Tuplanolla> It's a recursive definition.
04:41:01 <Iceland_jack> iron_houzi: The definition is recursive
04:41:04 <iron_houzi> ahh
04:41:23 <iron_houzi> Indeed. This is FP..
04:41:33 <dramforever> iron_houzi: the third foo is from the second foo...
04:41:55 <pjdelport> iron_houzi: Specifically, the second version defines foo recursively in terms of itself, rather than in terms of the earlier definition of foo (which simply gets ignored)
04:41:59 <iron_houzi> yes, so the best thing to do is just using an intermediary variable?
04:42:12 <dramforever> iron_houzi: the best way is not to do it...
04:42:16 <Iceland_jack> Well you shouldn't be shadowing to begin with
04:42:19 <Wizek> MichaelBurge: https://gist.github.com/Wizek/b1b15cef3321bbdf02da#file-3rd-attempt-shell
04:42:28 <Tuplanolla> There's a catch to shadowing things in GHCi too.
04:42:29 <dramforever> I remembered a quote about "let a = b; b = a in ..."
04:42:37 <iron_houzi> Iceland_jack: True! but just for scratch sessions in ghci ..
04:42:48 <Wizek> MichaelBurge: Do you know how to deal with this? Or an alternative to Chart?
04:42:58 <dramforever> When did ghc introduce -XHoles?
04:43:05 <dramforever> I think my 7.6.3 does not have it
04:43:18 <Tuplanolla> let g = 1; let f x = g; f 0; let g = 2; f 0 -- gives 1 and 1
04:43:37 <kuribas> bennofs: I get an error on "import Data.List as L", even though I have base in my cabal file.
04:43:39 <Tuplanolla> let g x = 1; let f x = g x; f 0; let g x = 2; f 0 -- gives 1 and 2
04:43:51 <Iceland_jack> iron_houzi: Since GHCi uses recursive bindings you'll have to define a new name, use Tuplanolla's trick or use 'x <- pure (f x)'
04:44:02 <Iceland_jack> ghci> let c = 'a'
04:44:03 <Iceland_jack> ghci> c <- pure (succ c)
04:44:03 <Iceland_jack> ghci> c
04:44:06 <Iceland_jack> 'b'
04:44:08 <kuribas> bennofs: I am not in the same directory as my cabal file though, maybe ghc-mod isn't clever enough to find it?
04:45:13 <ddrone> Hi everyone
04:45:34 <ddrone> What's the reason to use "import Module as Shorthand"? Notice there are no "qualified" in this statement
04:45:49 <dramforever> ddrone, to prevent clashes
04:46:00 <dramforever> for example SDL exports a function called "flip"
04:46:08 <MichaelBurge> Wizek: You're in luck because I spent the better part of yesterday trying to get Gtk installed on a windows machine, so these errors look pretty familiar
04:46:11 <dramforever> other than that there's no reason to qualify it
04:46:38 <Wizek> That sounds promising :)
04:46:47 <supki> ddrone: where do you see it?
04:46:50 <ddrone> dramforever, How unqualified imports helps to prevent clashes?
04:46:53 <MichaelBurge> the 'gtk2hs-buildtools' package installs an executable in your $HOME/.cabal/bin I believe
04:47:04 <supki> ddrone: usually this form is used to re-export a bunch of modules with a single line
04:47:11 <trap_exit> probably by using () to control what you import
04:47:24 <supki> because qualified modules can't be re-exported
04:47:44 <MichaelBurge> And one of the errors is that it's unable to find it - can you locate the 'gtk2hsC2hs' executable and ensure that the directory is in your PATH?
04:48:02 <ddrone> supki: For example https://github.com/purescript/purescript/blob/master/src/Language/PureScript/CodeGen.hs#L24-L25
04:48:05 <hs> hi everyone, can i ask general questions here about haskell
04:48:19 <Iceland_jack> hs: absolutely
04:48:33 <supki> ddrone: yeah, here it saves a line in the export list
04:49:03 <ddrone> supki, how about that https://github.com/purescript/purescript/blob/master/src/Language/PureScript/Sugar.hs#L26-L32
04:49:26 <supki> same thing
04:49:27 <hs> why does haskell have so many language extensions?
04:49:59 <ddrone> supki, Ok, so there's no reason to use them other than to re-export stuff?
04:50:02 <dramforever> hs, they are either missing fundamental stuffs, or syntactic sugars
04:50:06 <Iceland_jack> Because Haskell is a place for language research among other things
04:51:02 <dramforever> It turned out that right recursive bytestring builders are much more efficient than left recursive ones
04:51:09 <pjdelport> hs: Haskell is a bit of a functional programming laboratory, in addition to its industrial use.
04:51:47 <supki> ddrone: not really
04:52:05 <dramforever> +RTS -sstderr says that my program "11,261,945,336 bytes allocated in the heap"
04:52:19 <dramforever> while processing a 20MB file
04:52:26 <dramforever> how good/bad is that?
04:52:51 <ddrone> supki, I still don't get why this feature exist. What's going to change if "as Something" will be removed?
04:53:04 <ddrone> supki, I mean in those examples
04:53:14 <hs> is there a standard way to write haskell ext?
04:53:41 <dramforever> hs, I don't know, maybe look inside ghc
04:53:44 <Iceland_jack> hs: You have to muck about the compiler
04:53:58 <dramforever> they are not extendable, though
04:54:17 <dramforever> But template haskell may be your frienemy
04:55:19 <supki> ddrone: did you notice "module S" in the export list of the latter example?
04:55:26 <Iceland_jack> hs: Is there something in particular that you want to do? There are approaches that don't require changing the compiler (RULES pragmas, specialization, compiler passes, template Haskell, ...)
04:55:46 <supki> ddrone: it re-exports declarations from all modules imported "as S"
04:56:02 <Cale> dramforever: Note that's all the allocation, not the maximum amount of space required obviously. GHC's garbage collector is very good at picking up short-lived garbage.
04:56:03 <supki> ddrone: if you remove "as S" declarations from that module won't be re-exported
04:56:49 <Cale> dramforever: Is your program slow?
04:56:53 <dramforever> Cale, so total allocation == total memory used?
04:56:58 <dramforever> Cale, not really
04:57:02 <ddrone> supki, so this feature will give the same effects as writing "module X" inside export list?
04:57:10 <dramforever> but is using more ram than equivlant python script
04:57:29 <ddrone> supki, like here: https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound.hs
04:57:31 <Cale> dramforever: That's how much memory your program would have used if nothing was ever garbage collected
04:57:50 <supki> ddrone: yes, you can write a module X line for every module X you want to export
04:58:03 <dramforever> Cale, since haskell objects are immutable, such a usage is small??
04:58:09 <dramforever> or not?
04:58:27 <ddrone> supki, Ah, I think I get it. Do you know if it's possible to make these crappy imports as compiler warning?
04:58:28 <Cale> dramforever: Well, hard to say if it's small.
04:58:35 <Cale> dramforever: But it's not unreasonable
04:58:47 <dramforever> Cale, I was processing a 40MB wav file
04:58:56 <dramforever> in particular, *reversing* it
04:58:56 <supki> ddrone: I don't think there's a warning for that
04:59:16 <hs> Iceland_jack, nothing in particular, just seen them everywhere and enforced by some libs. makie things more complacted
04:59:18 <Cale> dramforever: Are you using ByteString?
04:59:23 <dramforever> yeah
04:59:28 <ddrone> supki, that's a shame. Thank you for your explanations nonetheless
04:59:35 <Iceland_jack> hs: What do you mean by ‘enforced by some libs’?
04:59:43 <Cale> dramforever: Are you constructing a list of samples or something like that?
04:59:47 <dramforever> Cale, and bytestring builder
04:59:49 <hs> and not mentioned by books
04:59:55 <Cale> Or operating directly on the ByteStrings?
05:00:04 <dramforever> Cale, no, just a loop to produce a builder
05:00:16 <dramforever> alpounet told me about this thing
05:00:31 <Iceland_jack> hs: Language extensions allow Haskell to grow without having to modify the standard, some extensions may turn out to be not that good ideas (like ImplicitParams) so it's a good way of weeding them out
05:00:42 <hs> sometimes they are required, even though i dont know about them
05:00:42 <dramforever> yesterday it was about speed, today is about memory usage
05:00:56 * hackagebot hlint 1.9.4 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.4 (NeilMitchell)
05:00:58 <dramforever> hs, FFI is required in some cases
05:01:18 <dramforever> ddrone, Oh, hlint might do this
05:01:21 <Iceland_jack> hs: Sometimes you don't actually have to understand them fully, but you should just treat them like a language feature
05:01:51 <dramforever> hs, FFI is required in *many many* places
05:01:51 <Cale> dramforever: Can I see the program?
05:02:00 <dramforever> Cale, okay posting...
05:02:09 <ddrone> dramforever, Thanks, I'll look into that
05:02:31 <dramforever> ddrone, FFI is not-so-safe but useful if you use it well
05:02:58 <lpaste> dramforever pasted “hrevoice fast but need mem optimization” at http://lpaste.net/110099
05:03:14 <dramforever> Cale, there you go
05:03:57 <hs> how can you read and understand some module if it starts with 4 or more exts
05:04:44 <thebnq> leanr the gist of each extension one by one :)
05:04:49 <Iceland_jack> hs: You can either:
05:04:49 <Iceland_jack>     ⅰ) Read the code until you don't understand it
05:04:49 <Iceland_jack>     ⅱ) Search for those extensions online and learn them
05:04:53 <dramforever> hs, I think NoMonomorphismRestrictions, BangPatterns, UnpackedTuples
05:04:56 <Iceland_jack> Or some middle ground
05:05:02 <dramforever> they are okay to understand
05:05:16 <dramforever> GADT, FFI, they are not so okay
05:05:17 <Iceland_jack> A *lot* of extensions are just syntactic
05:05:33 <Iceland_jack> Like
05:05:33 <Iceland_jack> @ty (, 'a')
05:05:35 <lambdabot> t -> (t, Char)
05:05:36 <dramforever> existentials are *hard* to understand
05:06:08 <dramforever> @ty (,,,,, 'a' ,,,,,,, 'b',,)
05:06:10 <lambdabot> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> (t, t1, t2, t3, t4, Char, t5, t6, t7, t8, t9, t10, Char, t11, t12)
05:06:21 <t7> what?
05:06:30 <dramforever> Iceland_jack: maybe you should never use sectioned tuples like that
05:07:09 <dramforever> Cale, forget about my problem, I think my code is fine...
05:07:16 <dramforever> Mem usage fine...
05:07:38 <Cale> dramforever: How much memory does it peak at?
05:07:46 <dramforever> 60/70MB
05:07:58 <dramforever> runtime 2s
05:08:17 <dramforever> python version 8s, 20 to 30 MB
05:08:40 <dramforever> Cale: my program is actually very fun to use
05:09:20 <dramforever> After reversing some english stuff they become like german...
05:09:31 <Cale> heh
05:10:27 <dramforever> Cale, just *feels* like German...
05:11:33 <pejo> I'm trying to set up a benchmark section in my cabal file. I'd like to compare something against some C implementations compiled with different compilers/flags. Is there some clever way to do that, or some example to look at somewhere?
05:12:13 <dramforever> Cale, python ver https://github.com/xmcp/ReVoice , iirc
05:17:19 <hs> ok, how many lang-ext dose haskell have?
05:19:00 <nexx> Do you mean GHC?
05:19:02 <pejo> First stumbling block is just selecting a different C-compiler. I'm not worried about error handling at this stage. There's a question on stack overflow from 2010 which is answered by "make your own buildhook in Setup.hs". Is that the simplest way?
05:19:03 <dcoutts> hs: ghc --supported-extensions | wc -l
05:19:19 <dcoutts> hs: but divide that by 2 because most have -XFoo and -XNoFoo forms
05:19:37 <dcoutts> so that's over 80
05:20:05 <hs> wow!
05:20:08 <pejo> hs, http://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3 lists them
05:20:42 <pjdelport> hs: They range from trivial to esoteric
05:22:23 <Iceland_jack> Don't get discouraged by the number of extensions
05:22:42 <LnL> Is there a way to reduce nested applicatives, or should I just use a where clause in this case?
05:22:43 <LnL> https://gist.github.com/LnL7/b0cd8e305a9bb68e6a52
05:23:14 <adas> i don't believe this.. i wrote a brainfuck interpreter. 250 lines. Never tested it iteratively. Wrote the whole code in one go. Wrote a few lame quickcheck properties. Made the code compile. Wrote a brainfuck program to print hello world. It works. I don't get it. how is it possible to work on the first try.?
05:23:56 <ij> I think it's pretty easy to write, the spec is very straight-forward.
05:24:10 <dcoutts> adas: strong types, pure functions and structured data is a pretty good combination :-)
05:24:12 <Dre3ml0rd> so I was wondering what the best application of haskell could be
05:24:29 <adas> ij: that must be the case. i aint no genius.
05:25:05 <pjdelport> adas: The type system is a brain amplifier. :)
05:25:16 <hs> how can those not interfere with each other
05:25:39 <dcoutts> hs: only a few of them interfere with each other
05:26:30 <exio4> the bad thing in haskell is that when stuff compiles and it doesn't work as expected, it means you're in trouble!
05:27:24 <adas> i am floored..at this point ... im beginngiin to believe that any random haskell code that compiles will work on the first try
05:28:03 <hs> is there a simpler environment?
05:28:31 <pejo> dcoutts, any advice on using icc with cabal bench?
05:28:34 <adas> i guess this is what is called a "mental orgasm"
05:28:43 <hs> ok, thank you all very much...
05:28:50 <hs> see u again
05:28:52 <dcoutts> pejo: you'd have to do it yourself in your benchmark prog, Cabal will not do anything for you there
05:29:00 <steffen> I know for  'Int -> CInt' I have to do 'fromIntegral' but how do I get 'CInt -> Int' ?
05:29:12 <dcoutts> steffen: same
05:29:26 <ij> adas, It's still something, don't forget that also.
05:29:38 <ij> I was very proud for the one I wrote.
05:29:49 <steffen> dcoutts thats what I thought, even though I don't really get it, maybe I should read up on the Num typeclass? Or what should I read to understand this?
05:30:02 <ij> adas, It wasn't in haskell and not written very well or fast. :P
05:30:18 <pejo> dcoutts, not sure I follow. Where do I hook into things?
05:30:25 <adas> ij: what language?
05:30:48 <dcoutts> pejo: the point is you'd run any C compilation from within your benchmark program. You have full control.
05:31:56 <ij> adas, Asm + c. First time I had written asm.
05:32:35 <adas> ij: did it work on the first attempt?
05:33:05 <ij> Hello world did, mandelbrot didn't.
05:33:13 <thebnq> LnL: in that case, why not uses a nested pattern match?
05:34:07 <ij> adas, I mean pretty close — I knew it wasn't done, so it didn't work before that because of that. But once I thought I was done there was only one thing stopping from being fully functional.
05:34:16 <adas> mandelbrot in brainfuc?
05:34:17 <pejo> dcoutts, and put my c-sources data-files?
05:34:31 <pejo> dcoutts, *as/in* data-files.
05:34:31 <ij> adas, Yeah, found it on the nets, i can lend you a copy.
05:34:38 <ij> You'll have to give it back. :D
05:34:49 <adas> haha
05:35:09 <ij> http://sprunge.us/baZS
05:35:15 <ij> adas, ^
05:35:29 <adas> if it was a mandelbrot bf program .. means all the output from the bfprogram was post processed?
05:35:37 <LnL> thebnq: Not sure what you mean
05:38:11 <thebnq> LnL: alloc (Heap (x:xs) m) = (x , Heap xs m)
05:38:37 <ij> adas, Kickstarted with C, here's the interpreter. https://github.com/siers/bf/blob/master/src/bf.asm
05:39:24 <adas> ij: thanks
05:39:40 <LnL> thebnq: Ah that's what you mean with nested pattern match
05:52:48 <osa1> any reasons to use array instead of vector? looks like vector also provides O(1) access.
05:53:36 <Axman6> Array is nice if you want non Int indices, are multi dimensional arrays
05:53:40 <Iceland_jack> osa1: Multidimensional arrays are one of the few reasons
05:54:09 <pejo> dcoutts, alright, will take a stab at that. Cheers.
05:54:17 <Axman6> but Repa overlays that on Vectors anyway (though it a bit strange for a lot of uses)
05:54:31 <osa1> but I can have multi-dimensional vectors too
05:54:36 <osa1> what's wrong with multi-dimensional vectors?
05:54:48 <Axman6> Data.Vector doesn;t support them
05:56:45 <nilg> it seems not all String functions have been ported to ByteString (like toLower), is it really the case? Why?
05:57:00 <osa1> Axman6: I can't see why it doesn't support them
05:57:07 <pablo|> nilg: because Data.Text is for text
05:57:16 <ion> nilg: What is the proper result of toLowering a WebM video?
05:57:20 <barrucadu> nilg: ByteString is a string of bytes, without any encoding data associated. What does toLower mean in that case?
05:57:27 <Axman6> osa1: because it's a package for Vectors, not multidimensional arrays
05:57:28 <nilg> oh!!!!
05:57:30 <Iceland_jack> nilg: You *can* do it, but you probably shouldn't
05:57:54 <Axman6> nilg: ByteString is for strings of bytes, not text
05:57:54 <nilg> OK, I misunderstood the function of ByteString then, thanks
05:57:55 <Iceland_jack> there is a reason why Data.ByteString.map has the type
05:57:55 <Iceland_jack>     (Word8 -> Word8) -> ByteString -> ByteString
05:58:14 <osa1> Axman6: do you mean I can't have `Vector (Vector Int)`? why?
05:58:15 * Iceland_jack . o O ( ByteString should /really/ be renamed Bytes )
05:58:53 <Iceland_jack> osa1: http://u.arboreus.com/2011/03/how-to-choose-haskell-array-library.html
06:00:50 <Wizek> MichaelBurge: Yes, I have the executable in /Library/Haskell/bin/gtk2hsC2hs . Tje error complains about a C lib missing called "initl"
06:01:15 <Wizek> sorry, it is called "intl"
06:05:18 <nilg> is haskell data.text.io lazy or "strict" (if that's the right term)?
06:06:02 <Axman6> there are both lazy and strict versions of Text, I would guess that one is strict
06:06:11 <nilg> thanks
06:06:14 <Axman6> see Data.Text.Lazy
06:07:47 <nilg> It seems Data.Text.Strict doesn't not exist, however Data.Text.Lazy exists, so I guess it means Data.Text is strict
06:09:25 <dcoutts_> nilg: right, just like Data.ByteString and Data.ByteString.Lazy
06:09:49 <friden> Im trying to define Eq for a function, and i can't get it right. example here: http://pastebin.com/zvvawuui
06:10:23 <friden> in my probram, i want to generate a list of functions, but i want to nub it
06:10:31 <barrucadu> friden: What does equality mean for a function?
06:10:41 <Axman6> it's not possible to test for equality of function in haskell, not in a meaningful way anyway
06:10:41 <Iceland_jack> friden: 'f1 == f1' and 'f2 == f2' are the same cases
06:10:42 <friden> just the function name in my case
06:10:54 <Axman6> many functions don't have names
06:10:56 <Iceland_jack> You're not actually comparing the functions f1 and f2
06:11:06 <Axman6> what's the name of (x -> x + x)?
06:11:08 <friden> i want Eq to say False if it does not have the same name, how do i make that happen? xD
06:11:12 <friden> yeah, i see what you mean
06:11:14 <Axman6> (\x -> x + x)*
06:11:14 <bennofs> Axman6: twice
06:11:15 <Iceland_jack> Axman6: join (+)!
06:11:23 <rom1504> Axman6: double
06:11:24 <Iceland_jack> (or double)
06:11:25 <bennofs> Axman6: or double
06:11:31 <Axman6> but twice /= join (+)!
06:11:33 <friden> yes, but I want to make something that kind of works like that xd
06:11:35 <Axman6> or double!
06:11:37 <friden> is it possible?
06:11:43 <Axman6> not really
06:11:47 <friden> dang
06:11:50 <Axman6> if it were possible, it would be implemented somewhere
06:12:01 <Iceland_jack> friden: Int is finite so you can do it, but don't do it
06:12:04 <luite> friden: you can't really do that, you can get some way with StableName, but you'll always have false negatives
06:12:29 <Axman6> you can do things like: instance (Bounded a, Eq b) => Eq (a -> b), but that's usually a silly thing to do
06:12:48 <Axman6> (so, you can check that all outputs are equal for all the bounded inputs)
06:13:15 <friden> i just really want to compare the function names xd
06:13:18 <friden> but thanks anyways :)
06:13:29 <mr-> friden: store your functions along with a name ;-)
06:13:36 <Axman6> friden: furthermore, what's the name of: map show
06:13:38 <Iceland_jack> friden: This sounds like an XY problem
06:13:50 <Axman6> it's a curried function, so what do you do then?
06:14:36 <Axman6> friden: that sort of introspection makes sense in many OO languages, but not as much in functional ones
06:14:50 <Axman6> if everything is an object, then everything has some kind of identity
06:14:53 <Iceland_jack> There are a lot of ways you can compare functions for equality and you don't really want to use any of them in functional programming
06:15:00 <awestroke> Axman6: what abot TH?
06:15:06 <awestroke> about*
06:15:08 <Axman6> but functions are things we happen to give names from time to time
06:15:16 <Axman6> awestroke: well, that's not a runtime thing for starters
06:15:21 <friden> mr-: i guess thats as close as i can get^^
06:15:39 <friden> but i wanted to get around that
06:16:34 <barrucadu> friden: What do you want to achieve by comparing function names? Perhaps there is a more idiomatic way
06:16:40 <friden> i guess ill have to use nubBy with a (Fun -> ?) where ? is some kind of identifier
06:16:42 <Axman6> it might be possible to make sure you never get false positives, but not false negatives
06:18:09 <friden> i have a set of functions [Int -> Int], and i want to make functions of all combinations of functions xd, kind of like [a,b,c] -> [a.a.a, a.a.b, a.a.c, a.b.a, a.b.b...]
06:18:52 <Axman6> that shouldn't be too hard, and there's no need for equality
06:19:08 <Axman6> :t replicateM
06:19:10 <lambdabot> Monad m => Int -> m a -> m [a]
06:19:19 <friden> i know, but i just thought of a way of doing it with nub and thought i wanted to learn to declare EQ for functions^^
06:19:24 <friden> i know its not really neccesary
06:19:29 <Iceland_jack> > replicateM 3 [a,b,c]
06:19:31 <lambdabot>  [[a,a,a],[a,a,b],[a,a,c],[a,b,a],[a,b,b],[a,b,c],[a,c,a],[a,c,b],[a,c,c],[b,...
06:19:32 <friden> but i wanted to know if it was possible^^
06:19:47 <Axman6> friden: it's a good learning exercise =)
06:21:13 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (langth xs) xs in map ($1) $ fun [(+1),(*2)]
06:21:16 <lambdabot>  Not in scope: ‘langth’
06:21:16 <lambdabot>  Perhaps you meant one of these:
06:21:16 <lambdabot>    ‘length’ (imported from Data.List),
06:21:16 <lambdabot>    ‘Seq.length’ (imported from Data.Sequence),
06:21:16 <lambdabot>    ‘BSLC.length’ (imported from Data.ByteString.Lazy.Char8)
06:21:22 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) $ fun [(+1),(*2)]
06:21:24 <lambdabot>  can't find file: L.hs
06:21:28 <Axman6> :(
06:21:38 <Axman6> @undefine
06:21:39 <lambdabot> Undefined.
06:21:42 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) $ fun [(+1),(*2)]
06:21:44 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
06:21:44 <lambdabot>              with actual type ‘a1 -> a1’Couldn't match expected type ‘GHC.Typ...
06:21:45 <lambdabot>              with actual type ‘a2 -> a2’
06:22:01 <Axman6> :t let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in funs
06:22:03 <lambdabot> [b -> b] -> [b -> b]
06:22:23 <Axman6> :t let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) . funs
06:22:25 <lambdabot> Num b => [b -> b] -> [b]
06:22:48 <Axman6> :t let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) . funs $ [(+1),(*2)]
06:22:50 <lambdabot> Num b => [b]
06:22:55 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) . funs $ [(+1),(*2)]
06:22:57 <lambdabot>  [3,3,4,4]
06:23:14 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in map ($1) . funs $ [(+1),(*7)]
06:23:16 <lambdabot>  [3,8,14,49]
06:23:55 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in funs [(+1),(*7)] <*> pure 3
06:23:56 <lambdabot>  [5,22,28,147]
06:24:16 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in funs [(1:),(2:)] <*> pure []
06:24:19 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
06:24:31 <Axman6> > let funs xs = map (foldr (.) id) $ replicateM (length xs) xs in funs [(1:),(2:),(3:)] <*> pure []
06:24:32 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
06:24:43 * Axman6 shuts up
06:25:01 * Iceland_jack doesn't mind
06:25:49 <Axman6> > let funs xs = (foldr (.) id) <$> replicateM (length xs) xs in funs [(1:),(2:),(3:)] <*> pure []
06:25:52 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
06:36:00 <nilg> is there any CSV library working with Text?
06:37:20 <nilg> oh sorry, I might have found http://hackage.haskell.org/package/csv-conduit-0.6.3/docs/doc-index.html
06:37:29 <ddrone> nilg, cassava?
06:44:10 <Kaidelong> https://ghc.haskell.org/trac/ghc/ticket/989 on point 1, is there anything stopping the use of Netwide Assembler?
06:44:15 <nilg> I just need to write the CSV file, not parse, so I won't rely on a libraies for now, thaks
06:44:26 <Kaidelong> or does NASM also rely on GCC?
06:45:39 <remdezx> Hello! How can I check which extensions are enabled in ghci by default?
06:46:11 * hackagebot project-template 0.1.4.2 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.4.2 (MichaelSnoyman)
06:46:28 <dfeuer_> remdezx, you could try the documentation. Alternatively, in the source code, you could read compiler/main/DynFlags.hs
06:48:09 <nilg> All this String vs Text thing is annoying, ultimately, maybe the compiler could optimize String, as to never have to worry about using Text
06:48:28 <nilg> I'm no compiler guru to say... maybe it's very hard...
06:48:48 <c_wraith> nilg: similarly, it's really annoying to have to choose the correct data structure all the time. why can't the compiler just optimize that out?
06:48:53 <dfeuer_> Why is it written  f$x=f x  instead of just ($) = id  ?
06:49:11 <Kaidelong> c_wraith: that's actually probably a question worth asking
06:49:16 <vanila> dfeuer_, it's to make the intention clearer
06:49:16 <dfeuer_> Hahahah.
06:49:26 <remdezx> dfeuer_: Found it in DynFlags, thanks!
06:49:28 <c_wraith> dfeuer_: something to do with eta contraction being a pessimization in some cases
06:49:47 <dfeuer_> c_wraith, do those cases ever apply to ($)?
06:50:17 <c_wraith> dfeuer_: I think so, actually - but I'm not the one to ask.
06:50:22 <dfeuer_> Oh, okay.
06:50:24 <Cale> dfeuer_: It probably makes no difference whatsoever
06:50:37 <Kaidelong> perhaps one approach would be to use a knowledge engine along the lines of Wolfram Alpha that finds an implementation for a specification as a web service
06:50:41 <nilg> c_wraith: but is there any good reason to use Text over String, if it's not for the fact that Text is optimized (I don't mention the Text libraries, since they exact for Text rather than String due to the convenience of the optimization)?
06:51:04 <Cale> dfeuer_: both the definition of ($) and of id will almost surely be inlined
06:51:12 * hackagebot yaml 0.8.9.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9.1 (MichaelSnoyman)
06:51:31 <c_wraith> nilg: well, Text also handles case transformations correctly, unlike String
06:51:38 <Kaidelong> I guess that would revive the Japanese dream of programming languages as requests for answers from AIs
06:51:44 <dfeuer_> Cale, I'm having a weird problem where I can't convince GHC to inline ($) early enough. I can work around it, but it's .... annoying and weird.
06:52:08 <c_wraith> nilg: it turns out that a sequence of codepoints isn't actually a good way to view unicode data - there's too much interdependence in the format
06:52:30 <c_wraith> nilg: Text provides you abstractions that deal with that properly.  String is just a sequence of codepoints.
06:52:36 <Cale> dfeuer_: That is weird
06:54:18 <luite> c_wraith: is that a weakness of the unicode spec or an intrinsic problem of the domain?
06:54:31 <c_wraith> luite: I'm not sure.  I think some of both.
06:54:39 <nilg> c_wraith: thanks that's a reasonable answer, I'm glad to know that
06:55:04 <c_wraith> luite: I mean, the spec is certainly unreasonably bad in some places..  like 'I' have a different lowercase in the turkish locale than anywhere else
06:55:30 <c_wraith> luite: but I think the domain is still vastly complex if you remove issues like that from the spec
06:56:12 * hackagebot http-conduit 2.1.4.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.2 (MichaelSnoyman)
06:56:38 <dfeuer_> c_wraith, if that's how it is in Turkish, how is the spec supposed to work for Turkish if it doesn't recognize that?
06:57:27 <c_wraith> dfeuer_: the sane way would be treating Turkish 'I' and Latin 'I' as different characters. It wouldn't be the only pair of different characters with the same glyph.
06:57:38 <dfeuer_> c_wraith, that makes sense.
07:00:23 <luite> c_wraith: hmm, but locale-dependent case mapping at least works char by char (and hopefully in most cases things that should be treated with different locale reuls can be separated into different text values), context dependence within the text data itself worries me more
07:01:13 * hackagebot twitter-conduit 0.0.5.7 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.7 (TakahiroHimura)
07:01:15 * hackagebot html-conduit 1.1.0.6 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.0.6 (MichaelSnoyman)
07:01:17 * hackagebot xml-conduit 1.2.1.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.1.1 (MichaelSnoyman)
07:01:19 * hackagebot xml-conduit 1.2.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.2 (MichaelSnoyman)
07:01:58 <c_wraith> luite: the context-dependence comes from things like non-canonical representations of data..  I suspect there's no way to get away from that when you're trying to encode all writing systems on earth.
07:02:19 <c_wraith> Or at least a large fraction of them
07:02:53 <kgadek> anybody here on OS X with GHC 7.8.3?
07:03:06 <kgadek> want to check if my problems are env ones or the bug in ghci
07:04:06 <kgadek> I've got GHC 7.8.3, cabal 1.20.0.3 and calling `ghci -XNoImplicitPrelude` yields errors that return, ($), (++), String, IO are not in scope. seems like a bug for me
07:05:15 <mr-> kgadek: it does the same on linux
07:05:29 <kgadek> ok, I'll report a bug then. Thanks
07:05:35 <mr-> kgadek: maybe there's something in your .ghci, though?
07:05:52 <kgadek> nearly empty
07:06:07 <mr-> I just commented everything out. It works fine now
07:06:17 <kgadek> oh? give me a moment
07:06:54 <kgadek> yeah
07:07:17 <kgadek> that was it. Thanks
07:12:20 <exfalso> hi, CmdArgs question: is there an existing way to reconstruct the original exec command from the parsed in cli arguments?
07:13:09 <prinsen> Is there any way to concatenate Symbol type literals?
07:17:05 <LnL> Is it correct that `Data.Map.Strict.insertWith f k x m` always evaluates x, even when f discards it?
07:18:55 <c_wraith> LnL: I think that might depend on the version of containers
07:21:59 <LnL> c_wraith: Oh well, I want to call error when updating a key that does not exist
07:22:13 <c_wraith> LnL: it's not true with version 0.5.5.1 of containers (which comes with ghc 7.8.3)
07:22:31 <c_wraith> LnL: you don't want insert, then
07:22:57 <LnL> c_wraith: what should I use then?
07:23:53 <c_wraith> LnL: depends on exactly what you want.  Do you *really* want it to call error?  That's sort of hostile...  But if it actually indicates a coding error, it's appropriate
07:26:32 <c_wraith> LnL: anyway, alter is the most flexible option.  You can certainly make it do what you want
07:26:47 <bmuk> I know integers are a monoid; do they have two instances of monoid (multiplication and addition?). I recognised the multiplication instance today during calc. * would be mappend and 1 would be mempty right?
07:27:19 <luite> bmuk: those instances are supplied through newtype wrappers
07:27:35 <LnL> c_wraith: That case might generate a corrupt datastructure so it seems fine, I'll take a look at alter
07:27:40 <luite> bmuk: see Sum
07:27:50 <luite> bmuk: but there are many more possible Monoid instances
07:28:37 <bmuk> There are more than addition and multiplication?
07:33:55 <luite> bmuk: for bounded things you could have Min/Max, i'm not sure if i know a natural example, but somthing like the rightmost nonzero value (or zero) is a monoid
07:34:53 <bmuk> luite++ It's really interesting how after you learn about them monoids start popping up everywhere.
07:37:17 <prinsen> Is it possible to concatenate Symbol literals as its possible to add Nats?
07:38:26 <c_wraith> prinsen: doesn't appear to be anything for that in GHC.TypeLits
07:39:08 <luite> bmuk: also gcd if you treat gcd 0 0 = 0, gcd 0 x = x, gcd x 0 = x
07:39:53 <prinsen> c_wraith: Could one write it?
07:41:50 <c_wraith> prinsen: It doesn't appear so.  Symbol would be a lot more useful as '[ 'Char ]
07:41:59 <c_wraith> prinsen: but there's no such thing as 'Char
07:49:26 <deni>  Microsoft filled patent applications for scoped and immutable types: https://news.ycombinator.com/item?id=8231501
07:49:29 <albeit> How could I do a sort of nested catMaybes... something that would produce :: [(a, Maybe b)] -> [(a, b)] ?
07:49:29 <deni> lol
07:52:24 <bergmark> > mapMaybe (\(a,b) -> (a,) <$> b) [(1,Nothing),(2,Just ())]
07:52:26 <lambdabot>  [(2,())]
07:52:30 <bergmark> is that what you mean?
07:52:54 <albeit> Ah yes! Thanks bergmark
07:56:22 <prinsen> c_wraith: data instance Settings (Settings s1 n1, Settings s2 n2) (n1 * n2), gives me  Illegal type synonym family application
07:56:24 * hackagebot conduit-combinators 0.2.8.3 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.8.3 (MichaelSnoyman)
08:00:16 <caumeslasal> Hi, I've just stumbled upon Hunt (https://github.com/hunt-framework/hunt), but I'm a little confused about it. Is there any documentation on how it works, or how it can be adapted. In particular, I am looking for something like a search engine on mbox/maildirs. Thx.
08:00:30 <deni> although that article I've linked has a popular sounding title but the actual filed patent doesn't mention immutable stuff by that name at al
08:00:30 <deni> *all
08:01:24 * hackagebot alfred 0.3 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.3 (PatrickBahr)
08:06:25 * hackagebot yesod-auth 1.3.4.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.3 (MichaelSnoyman)
08:06:27 * hackagebot yesod-bin 1.2.12.5 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.5 (MichaelSnoyman)
08:06:29 * hackagebot yesod-core 1.2.19.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.19.2 (MichaelSnoyman)
08:06:31 * hackagebot yesod-eventsource 1.1.1.1 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.1.1.1 (MichaelSnoyman)
08:06:33 * hackagebot yesod-form 1.3.15.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.15.3 (MichaelSnoyman)
08:07:44 <Laurine22>  Here some videos. I hope you like them! http://bit.ly/1mFMmyS
08:11:35 * hackagebot yesod-persistent 1.2.3.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.2.3.1 (MichaelSnoyman)
08:11:37 * hackagebot cereal-conduit 0.7.2.3 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.7.2.3 (MichaelSnoyman)
08:11:39 * hackagebot conduit 1.2.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.0 (MichaelSnoyman)
08:11:41 * hackagebot conduit-extra 1.1.3.3 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.3.3 (MichaelSnoyman)
08:16:26 * hackagebot bzlib-conduit 0.2.1.3 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.2.1.3 (MichaelSnoyman)
08:26:48 <monochrom> Pilato asks the public: "I have hackagebot spamming, and Laurine22 spamming. Which one do you want me to grant amnesty to? Which one do you want crucified?" The public cries: "Amnesty to Laurine22! Death to hackagebot!" Pilato says: "OMG, now I have wash my hands!"
08:26:54 <tomejaguar> Is there some relationship between DUALtree and attribute grammars?
08:28:50 <yyttr3> Does anyone know a good Category theory book other than Awodey, one with many problem sets would be nice
08:29:20 <ski> perhaps "Conceptual Mathematics" by Schanuel & Lawvere ?
08:29:36 <ski> tomejaguar : what's "DUALtree" ?
08:31:07 <ski> "Sets for Mathematics" by Lawvere & Rosebrugh is also interesting
08:31:41 <tomejaguar> ski: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/dual-tree/Data-Tree-DUAL.html
08:33:35 <LnL> guess I underestimated the build time of ghc
08:33:50 <ski> interesting
08:34:01 <bmuk> If I already have the haskell platform installed, but I would like a more up to date haskell environment what should I do? Uninstall and build from source? I'm only worried because I use xmonad and xmobar, so I would probably have to install them through cabal instead of my package manager?
08:36:19 <monochrom> you can install GHC without building GHC. http://www.haskell.org/ghc/download
08:36:46 <monochrom> the rest you can build
08:41:30 * hackagebot classy-prelude 0.9.4 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.4 (MichaelSnoyman)
08:41:32 * hackagebot classy-prelude-conduit 0.9.4 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.4 (MichaelSnoyman)
08:41:34 * hackagebot classy-prelude-yesod 0.9.4 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.4 (MichaelSnoyman)
08:49:11 <rrradical> Hi, I'm having trouble writing this abstraction: http://lpaste.net/110110 I'm not sure why the type checker doesn't allow it.
08:50:57 <monochrom> this is because: suppose I am a user of your foo. So I have to begin by choosing one type for a, one type for b.
08:51:07 <Iceland_jack> rrradical: The function would need to accept both Int and Double
08:51:29 <Iceland_jack> you can provide that with rank-2 types but it's possibly not what you want to do
08:51:33 <amar^> Does Maybe Maybe a make sense, is there any alternative design choice for such a scenarios?
08:51:48 <monochrom> I am free to choose a=Float. the type allows me that freedom. now f :: Float -> b, it is no good.
08:52:05 <rrradical> Iceland_jack: even though the function has a Num constraint? I would think that's all the information it needs
08:52:34 <monochrom> that is irrelevant.
08:52:37 <Iceland_jack> rrradical: Take monochrom's example, think of a function that works here: would 'f :: Int -> String' work?
08:53:24 <monochrom> mono :: (a -> a) -> Bool -> Char -> (Bool, Char); mono f b c = (f b, f c). same problem
08:53:27 <Iceland_jack> It would work for 'b ~ String' (b equal to String), but you can't apply it to Double since Double since f is expecting an Int
08:53:46 <eacameron> I'm running a profile with -hr and it clearly has a space leak because the graph just grows, but it simply says "main" is growing...Of course it is! How can I get more granularity?
08:53:51 <rrradical> Oh, hm, I think that makes sense
08:54:00 <Iceland_jack> See here rrradical:
08:54:00 <Iceland_jack> @ty \f a b -> (f a, f b)
08:54:01 <lambdabot> (t1 -> t) -> t1 -> t1 -> (t, t)
08:54:19 <Iceland_jack> The type inferred says that both arguments (second and third) must have the same type
08:54:36 <rrradical> I see.
08:54:41 <nshepperd> amar^: I think Maybe (Maybe a) is mostly equivalent to (Maybe a), unless you care about doing something special for the (Just Nothing) case
08:55:04 <rrradical> monochrom: Iceland_jack: thanks!
08:55:16 <monochrom> in "mono :: (a -> a) -> ...", the user, not the author, chooses a.
08:55:35 <monochrom> but in "mono f b c = (f b, f c)", the author tries to choose a. contradiction.
08:56:07 <monochrom> programming is a dialectic class struggle between authors and users.
08:56:15 <amar^> nshepperd: yeah I am asking for Just None case only, is there any better design choice for it?
08:56:17 <Iceland_jack> well put :)
08:56:49 <rrradical> yea that makes sense
08:56:52 <Iceland_jack> rrradical: We can pick a classic example
08:56:52 <Iceland_jack>     foo f = (f False, f 'a')
08:56:55 <rrradical> I think I need to rethink my design
08:57:10 <Iceland_jack> we would expect
08:57:10 <Iceland_jack>        foo id
08:57:10 <Iceland_jack>     => (False, 'a')
08:57:10 <Iceland_jack> right?
08:57:12 <monochrom> in "mono2 :: (forall a. a -> a) -> Bool -> Char -> (Bool, Char)", now the author chooses a.
08:58:21 <monochrom> (therefore the user cannot choose. the user cannot pass in Int->Int)
08:58:49 <rrradical> monochrom: oh woah
08:58:59 <rrradical> monochrom: and that's a rank2 type?
08:59:02 <monochrom> yes
08:59:02 <Iceland_jack> Yes
08:59:02 <josephle> dialectical programming, a radical way of thinking
08:59:12 <Iceland_jack> this will fail to type check:
08:59:12 <Iceland_jack> @ty \f -> (f False, f 'a')
08:59:13 <lambdabot>     Couldn't match expected type ‘Bool’ with actual type ‘Char’
08:59:13 <lambdabot>     In the first argument of ‘f’, namely ‘'a'’
08:59:13 <lambdabot>     In the expression: f 'a'
08:59:16 <rrradical> neat, I never understood those before
08:59:19 <pawel|> (forall a. a -> a) is not very useful though
08:59:26 <osfameron> josephle: thesis and cothesis ?
08:59:29 <pawel|> the only function with that signature is id
08:59:30 <Iceland_jack> pawel|: Except to introduce rank-2 types ;)
08:59:52 <augur> josephle: there's actually a paradigm around "dialects" but not "dialectics"
09:00:01 <augur> dialectical is .. very hegelian
09:00:19 <josephle> I was remarking on monochrom's observation of programming as a class struggle :P
09:00:31 <augur> monochrom: i think you've just connected hegel and game semantics
09:00:37 <Iceland_jack> rrradical: (This type checks:)
09:00:37 <Iceland_jack> @ty (\f -> (f False, f 'a')) :: (forall a. a -> a) -> (Bool, Char)
09:00:38 <lambdabot> (forall a. a -> a) -> (Bool, Char)
09:00:42 <augur> which is quite an accomplishment, given that its a valid connection 0_0
09:00:51 <monochrom> ah, but the adjective is "dialectic", no "al" necessary
09:00:57 <josephle> that is true
09:01:23 <augur> monochrom: is it? i thought dialectic was the noun
09:01:31 <monochrom> hrm!
09:01:37 * hackagebot binary-list 0.3.1.1 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.1.1 (DanielDiaz)
09:01:39 <augur> dialectical materialism
09:01:42 <augur> dialectical method
09:02:04 <monochrom> damn, it's dialetical class struggle then!
09:02:21 <monochrom> (and I missed a "c")
09:02:46 <augur> tho i do see dialectic as a modifier at times (which isnt a surprise, since nouns can modify), but i also see things like "the dialectic", "dialectics", etc. which i dont see with dialectical
09:02:50 <augur> anyway thats tangential
09:02:52 <augur> hegelian programming!
09:03:03 <monochrom> anyway, I began by learning that "forall" and "exists" are best explained by a 2-person game. the teacher vs the student.
09:03:28 <augur> yeah, the game semantic model of proving is _super_ useful
09:03:39 <augur> especially if you have an interactive theorem prover like agda-mode
09:03:49 <Iceland_jack> agda-mode turns programming into a video game
09:03:53 <augur> :)
09:04:09 <augur> i actually want to make an iOS game that teaches proof theory
09:04:14 <augur> i have some ideas for it too
09:04:16 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
09:05:10 <augur> josephle: i can recommend some good videos that can help illucidate this type theory stuff, if you'd like!
09:05:17 <augur> elucidate? thats the one
09:05:28 <nh2> is there a reason I can't derive Quickcheck arbitrary instances with GHC.Generics?
09:05:29 <augur> illucidate = illuminate + elucidate? hm
09:05:49 <Iceland_jack> augur: or Lucy + date
09:05:58 <augur> no no thats a lucidate
09:06:13 <augur> i suppose it could be an ill lucy date tho!
09:06:28 <Iceland_jack> I was thinking of the fruit but it could work in both senses I suppose
09:06:38 * hackagebot stm-conduit 2.5.2 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.5.2 (ClarkGaebel)
09:07:05 <Iceland_jack> ‘Lucidate’ is also the time when you're lucid
09:07:27 <Iceland_jack> As in ‘Fridays aren't really lucidates for me’ </offtopic>
09:07:27 <augur> this discussion is way more appropriate for #haskell-blah or perhaps even #esoteric lol
09:08:32 <josephle> augur: I am pretty familiar with type theory already, but thanks for the offer :)
09:09:04 <augur> josephle: ah, well, in that case the issue with (a -> a) -> ... should be easy to explain
09:09:19 <mr-> augur: video recommendations are always appreciated!
09:09:26 <augur> josephle: free vars are implicitly prenex quantified
09:09:27 <josephle> I think the original asker has gotten lost in our discussion...
09:09:32 <augur> haha maybe :D
09:09:47 <augur> mr-: let's see if this works!
09:09:51 <augur> @where oplss2012
09:09:52 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
09:09:53 <augur> \o/
09:10:12 <monochrom> anyway, my greatest achievement is realizing how to explain this: one group of people call a very statically safe language such as Haskell "powerful", and another group call a very unsafe language "powerful"
09:10:15 <augur> mr-: pfennings and harpers videos there. they're also on youtube, where they're much smaller size
09:11:18 <osfameron> monochrom: how?
09:11:53 <osfameron> on a slightly related note, I am planning a talk/blog post called "Haskell is an acceptable Perl" ;-)
09:12:08 <monochrom> the reader of a piece of code wants more predictive power, which is given by more static guarantees. the author wants more cavalier power, which is given by fewer static guarantees. programming is also a dialectical class struggle between the reader and the author.
09:13:36 <osfameron> monochrom: conversely, the author gains sanity and reassurance from the static guarantees.  While the reader can be confused by very generic code that has very specific behaviours depending on a strong understanding of types...
09:13:41 <prinsen> During compilation I get Declaration for R:Settings(,)n3: Iface type variable out of scope:  k
09:14:46 <pjdelport> monochrom: Another perspective: In the case of type-driven languages like Haskell, the *language* is powerful, and you wield it like an amplifying tool. In unrestricted languages, the language gets out of the way and allows your *brain* to be powerful.
09:14:50 <augur> monochrom: lmfao you're really hitting hard on the hegel :D
09:15:01 <pjdelport> (But your brain also has to do all the heavy lifting.)
09:15:08 <Xechas> Hi, I have a question. I am trying to use a writer monad to record exceptions by casing on an either, and if it is a left, use tell to record the value then throwM to rethrow the exception. When I do this however, the tell is never called (even with tell undefined). I was wondering if anyone knew why this was the case.
09:15:41 <Kaidelong> what does your transformer stack look like
09:15:42 <augur> i think a lot of people who like the ability to just much about probably would benefit from Haskell's use of type inference
09:15:44 <josephle> augur: I must figure out the Kierkegaardian counter-perspective to this hegelian programming :P
09:16:03 <augur> probably also monochrom i suspect better tools for mucking around would make type-safe mucking easier
09:16:16 <Kaidelong> @hoogle throwM
09:16:19 <lambdabot> No results found
09:17:17 <geekosaur> sue the one on fpcomplete, or hayoo
09:17:19 <geekosaur> er, yse
09:17:20 <geekosaur> use
09:17:25 * geekosaur glares at finfers
09:17:35 <Xechas> My monad stack is just a WriterT
09:18:01 <augur> geekosaur: uramess
09:18:20 * geekosaur kan tipe gud :p
09:18:23 <Kaidelong> Xechas: WriterT Identity or WriterT Either?
09:19:24 <Kaidelong> WriterT w Identity or WriterT w Either I mean
09:21:25 <Xechas> Oh sorry, it is a WriterT w ReaderT IO
09:21:55 <Kaidelong> Xechas: I think you might want to use ExceptT on the outside, something like ExceptT e (Writer e') t
09:22:35 <Kaidelong> you will then want to make a custom version of runExceptT that fmaps your tell over the result
09:23:17 <Kaidelong> oh mmm actually
09:23:23 <Kaidelong> perhaps catchE can do that for you
09:24:26 <Kaidelong> however you do need to get into Writer after you run your computation so that the log is accessible, so you want Writer as your inner monad so that it's on the outside when it's done
09:25:51 <Kaidelong> if you use WriterT everything you told gets lost in the event of a Left
09:26:59 <Xechas> Thanks for the advice! I will try it out.
09:27:02 <Kaidelong> one other approach might be using typecompose to get an applicative functor that combines writer and either more cleanly
09:27:17 <Kaidelong> but you will have an applicative as the result and not a monad
09:29:12 <Kaidelong> one other option is to wrap the stuff in a newtype and then roll your own MonadWriter and MonadError instances so that the error logging happens automagically
09:31:33 <athan> Is there a sqrt function for integers? I'm trying to do a simple `floor(sqrt(..))` hack, but there isn't a RealFrac Integer instance :/
09:33:36 <nshepperd> :t floor . sqrt . fromIntegral
09:33:38 <lambdabot> (Integral a, Integral c) => a -> c
09:33:42 <tromp__> > sqrt(length "doge")
09:33:44 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
09:33:44 <lambdabot>    arising from a use of ‘GHC.Float.sqrt’
09:33:57 <tromp__> > sqrt(fromIntegral $ length "doge")
09:33:59 <lambdabot>  2.0
09:34:29 <Kaidelong> using fromIntegral is probably best
09:35:17 <Kaidelong> you can probably find some integer square root implementations but floating point square root rounded back to an integer is less expensive and usually good enough
09:35:56 <Kaidelong> if you need integer roots then the numeric prelude has it
09:36:44 <sgronblo>  http://hackage.haskell.org/package/persistent-0.5.1/docs/src/Database-Persist-Quasi.html#parse is Haskell code usually this "free" from comments? Or is it just Persist? Or has the hyperlinked source on hackage been stripped from non documentational comments?
09:37:23 <nshepperd> there's an exact impl for Integers at http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot
09:37:26 <Kaidelong> that looks like a particularly bad case, even for haskell
09:38:43 <sgronblo> I mean in a way its good practice for my Haskell reading skills but...
09:39:22 <sgronblo> I don't think I will write Haskell code exactly like this when I grow up
09:39:46 <thebnq> at least the code is reasonably straight forward
09:40:24 <thebnq> not some scary lens TH knot tieing voodoo
09:40:27 <Kaidelong> killCarriage looks awfully inefficient, traversing the list twice
09:40:34 <tromp__> what's with all the !2 ?
09:40:51 <kuribas> I always wonder what order I should put my functions in.  I usually just write at the position my cursor happens to be in, without any plan.
09:40:56 <sgronblo> hehe, yeah i can understand most of it so far
09:41:43 <sgronblo> but it feels like it shouldnt be that hard to write a more proper parser either
09:42:04 <Iceland_jack> tromp__: You mean like in 'r^!2'?
09:42:12 <Iceland_jack> (^!) is the operator being defined
09:42:45 <tromp__>  > let n = 121 in iterate (\k->(k+n`div`k)`div`2) 121
09:42:52 <tromp__> yes, Iceland_jack
09:43:04 <Iceland_jack> tromp__: You can read it as: r ^! 2
09:43:10 <tromp__> ic
09:43:12 <Iceland_jack> the ^ and ! go together
09:43:28 <tromp__> > let n = 121 in iterate (\k->(k+n`div`k)`div`2) 121
09:43:30 <lambdabot>  [121,61,31,17,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11...
09:44:23 <tromp__> this always approaches sqrt(n) from above
09:45:57 <kuribas> let n = 2 in iterate (\k->(k+n/k)/2) 2
09:46:14 <tromp__>  > let n = 2 in iterate (\k->(k+n`div`k)`div`2) n
09:46:22 <tromp__> > let n = 2 in iterate (\k->(k+n`div`k)`div`2) n
09:46:24 <lambdabot>  [2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:46:27 <kuribas> > let n = 2 in iterate (\k->(k+n/k)/2) 2
09:46:29 <lambdabot>  [2.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.41421356...
09:46:36 <kuribas> > sqrt 2
09:46:37 <lambdabot>  1.4142135623730951
09:47:12 <dlnx`> hello all
09:48:04 <nshepperd> hmm, that iterate solution seems to converge pretty quickly
09:48:47 <nshepperd> oh, it's the same thing as newton's method
09:49:05 <tromp__> > let isqrt n = let is k = let k'=(k+n`div`k)`div`2 in if k`<k then is k' else k in is n
09:49:07 <lambdabot>  <hint>:1:59: parse error on input ‘<’
09:49:41 <tromp__> > let isqrt n = let is k = let k'=(k+n`div`k)`div`2 in if k'<k then is k' else k in is n
09:49:42 <lambdabot>  not an expression: ‘let isqrt n = let is k = let k'=(k+n`div`k)`div`2 in if ...
09:50:32 <dlnx`> I am looking for a haskell(or external w/ haskell bindings) lib to display music notation and 2nd one for plot display with easy manipulation from gui, I am using gtk2hs. Advice, anyone?
09:51:01 <tromp__> > let isqrt n = let f k = let k' =(k+n`div`k) `div` 2 in if k'<k then f k' else k in f n
09:51:03 <lambdabot>  not an expression: ‘let isqrt n = let f k = let k' =(k+n`div`k) `div` 2 in i...
09:51:20 <kuribas> dlnx`: I think there are libs that interface with lilypond
09:52:35 <dlnx`> kuribas: hly, looked it up, thanks, how about math plots with easy access to dynamic changes via gui (mouse cursor) ?
09:54:08 <kuribas> dlnx`: There are several plotting libraries on hackages, but idk which one are interactive.
09:54:29 <dlnx`> kuribas: I see, thanks anyway :)
09:54:55 <kuribas> https://hackage.haskell.org/packages/search?terms=plot
09:55:55 <sgronblo> "EntityDef name entattribs cols uniqs derives" how does this work again? Does Haskell match up properties according to types or?
09:56:38 <kuribas> dlnx`: this looks interesting also: music-suite.github.io/
09:57:43 <tromp__> @let isqrt n = let f k = let k' =(k+n`div`k) `div` 2 in if k'<k then f k' else k in f n
09:57:46 <lambdabot>  Defined.
09:58:02 <tromp__> > isqrt 120
09:58:04 <lambdabot>  10
09:58:06 <tromp__> > isqrt 121
09:58:08 <lambdabot>  11
09:58:23 <S11001001> hi lambdabot
09:58:58 <tromp__> that's a lot simpler than the one on the wiki
09:59:31 <kuribas> Does it give accurate rounding?
09:59:36 <tromp__> > isqrt 1
09:59:37 <lambdabot>  1
09:59:39 <tromp__> > isqrt 0
09:59:41 <lambdabot>  *Exception: divide by zero
09:59:47 <tromp__> needs a small fixup for 0 though
10:00:04 <tromp__> rounding shld be accurate
10:00:34 <pawel|> > isqrt (-1)
10:00:35 <lambdabot>  -1
10:00:41 <tromp__> > isqrt 99
10:00:43 <lambdabot>  9
10:00:48 <tromp__> > isqrt 100
10:00:50 <lambdabot>  10
10:01:49 <tromp__> > maxBound::Int
10:01:52 <lambdabot>  9223372036854775807
10:02:04 <tromp__> > isqrt $ maxBound::Int
10:02:06 <lambdabot>  -4611686018427387904
10:02:13 <tromp__> oops
10:02:32 <tromp__> overflow from adding to k
10:02:44 <tromp__> > isqrt $ maxBound::Int - 1
10:02:46 <lambdabot>  <hint>:1:25: Illegal literal in type (use DataKinds to enable): 1
10:02:56 <tromp__> > isqrt $ (maxBound-1)::Int
10:02:58 <lambdabot>  can't find file: L.hs
10:03:16 <tromp__> > isqrt $ (maxBound::Int) - 1
10:03:17 <lambdabot>  3037000499
10:03:44 <tromp__> anyway, shld work on all numbers from 1 through maxBound-1
10:06:22 <kuribas> map (\i -> isqrt i - round (sqrt $ fromInteger i)) [1..100]
10:06:28 <kuribas> > map (\i -> isqrt i - round (sqrt $ fromInteger i)) [1..100]
10:06:30 <lambdabot>  [0,0,-1,0,0,0,-1,-1,0,0,0,0,-1,-1,-1,0,0,0,0,0,-1,-1,-1,-1,0,0,0,0,0,0,-1,-1...
10:06:59 <tromp__> you want to use floor, not round
10:07:08 <kuribas> > map (\i -> isqrt i - floor (sqrt $ fromInteger i)) [1..100]
10:07:10 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:09:59 <pawel|> > and [isqrt i == floor (sqrt $ fromInteger i), i <- [1..1000000]]
10:10:01 <lambdabot>  <hint>:1:49: parse error on input ‘<-’
10:10:49 <pawel|> > and [isqrt i == floor (sqrt $ fromInteger i) | i <- [1..1000000]]
10:10:53 <lambdabot>  mueval-core: Time limit exceeded
10:11:01 <pawel|> > and [isqrt i == floor (sqrt $ fromInteger i) | i <- [1..10000]]
10:11:03 <lambdabot>  True
10:33:01 <hemc> i want to fetch whois data from godaddy , by pass their captcha
10:33:29 <hemc> arround 35 k request per day , can anyone guide
10:33:55 <johnw> is that a Haskell question?
10:34:24 <hemc> I don’t know, i am new here , just searched this channel on internet
10:34:40 <johnw> if you have a question about Haskell, we are happy to help, but otherwise you may wish to continue your search
10:35:07 <hemc> thanks
10:36:43 <kuribas> don't help spammers!
10:38:16 <dv-> spammers are people too
10:38:24 <etandel> are they? ARE they?
10:38:29 <Iceland_jack> Haskell is for people. Spammers are people.
10:39:01 <jophish_> Bought a domain! monoid.al
10:39:10 <Iceland_jack> Clever
10:39:15 <etandel> in any, case, hemc can try http://www.adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
10:39:20 <jophish_> mono.id was too expensive :/
10:39:30 <etandel> jophish_: ha, nice. What do you plan on hosting there?
10:39:34 <Iceland_jack> jophish_: What about 'groupo.id'?
10:39:55 <Iceland_jack> (semigroupo.id...)
10:40:00 <jophish_> Iceland_jack, unless you live in indonesia it costs a couple of hundred dollars to get a local presence
10:40:13 <etandel> I wonder if mon.ad is already registered.
10:40:20 <etandel> this TLC doesn't have a whois server. =/
10:40:35 <Iceland_jack> “MON.AD is personalized affiliated marketing and brand management portal. We bring ad serving for the masses.”
10:40:37 <Iceland_jack> What a shame :)
10:40:43 <etandel> sad
10:40:53 <etandel> basically spammin
10:40:55 <jophish_> etandel, yeah, monad.io too
10:41:18 <johnw> clearly there should be a .monad TLD
10:41:18 <etandel> what about comon.ad ? =D
10:41:39 <etandel> comon.ad does not host anything.
10:41:41 <jophish_> etandel, I think that's free
10:41:44 <etandel> yay
10:41:48 <jophish_> domai.nr
10:41:54 <jophish_> is good for checking this stuff
10:42:01 <johnw> edwar.dk
10:42:29 <etandel> I normally use the whois command, but some TLCs don't have whois servers. thanks for the tip
10:44:01 <jophish_> how about functor.io
10:44:18 <jophish_> more general than monad.io
10:44:20 <Iceland_jack>     instance.functor.io
10:44:27 <Iceland_jack>     /where
10:44:27 <jophish_> hahaah
10:45:49 * simpson resists urge to grab functor.house
10:46:22 <jophish_> morphi.sm
10:46:32 <jophish_> Samoa is expensive though I think
10:47:38 <jophish_> oh, that's San Marino, much cheaper
10:50:01 <etandel> i liked morphi.sm
10:58:53 <yogert> Hi all, whats the best practice for using the "unsafe" prefix? For instance, would a function using "fromJust" warrant the unsafe label?
11:00:00 <vanila> yogert, it's not usually for partial functions but things that potentially violate type safety
11:00:13 <vanila> or referential transparency
11:01:25 <johnw> yogert: usually I read unsafe as meaning that you have to ensure runtime invariants yourself (heap residency, lack of persistence, etc)
11:01:31 <yogert> so not functions that may throw an exception… okay. I'm a bit confused by your mention of partial functions. I don't see how that is relevant here
11:01:47 <Iceland_jack> yogert: ‘fromJust’ is a partial function
11:01:47 <jophish_> fromJust is a partial function
11:02:05 <Iceland_jack> jinx
11:02:09 <jophish_> !
11:03:31 <merijn> I think partial functions should be labelled unsafe too
11:03:38 <merijn> unsafeHead, unsafeFromJust, etc.
11:03:57 <yogert> sure… but this would apply to concrete (correct terminology?) functions as well, no? For example: "getFoo = fromJust maybeFoo"
11:04:14 <yogert> oh you do?err
11:04:16 <Iceland_jack> yogert: You mean total functions (opposite of partial functions)?
11:04:33 <yogert> yeah, after writing that out I understand the point : )
11:04:54 <Cale> I disagree with merijn, partial functions are somewhat dangerous, but not in the same way that the functions labelled unsafe are.
11:04:56 <Iceland_jack> merijn: I agree with johnw that unsafe should be reserved for messeing up the type system, otherwise it becomes slightly meaningless
11:05:09 <yogert> just to be clear, all functions that take arguments are partial… correct?
11:05:13 <Cale> no
11:05:16 <Iceland_jack> no
11:05:51 <vanila> yogert, a total function is one that always completes and gives a well defined value
11:06:08 <vanila> yogert, on the other hand fromJust is a partial function because it has no defined value when you pass in Nothing
11:06:12 <josephle> although the existence of undefined does make many haskell functions partial...
11:06:36 <Iceland_jack> josephle: The solution is obviously to add ‘undefined...’ to all functions
11:06:37 <exio4> @src undefined
11:06:37 <lambdabot> undefined = error "Prelude.undefined"
11:06:39 <yogert> ah, I thought partial function was related to partial application
11:06:50 <Iceland_jack> except maybe functions on unboxed values, (+#)
11:07:01 <Iceland_jack> :)
11:08:00 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
11:08:00 --- topic: set by glguy on [Fri Aug 15 13:29:35 2014]
11:08:01 <monochrom> @quote monochrom safeFromJust
11:08:02 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
11:09:50 <Cale> yogert: Not particularly, just documentation. If you really want to warn users forcefully, you can just use Maybe and write a total function instead.
11:09:53 <monochrom> I don't think there is a convention
11:11:29 <yogert> ok, well I learned something new anyways… thanks
11:11:58 * hackagebot hsdev 0.1.1.0 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.1.0 (AlexandrRuchkin)
11:15:07 <monochrom> hmm, today is HWN day!
11:15:29 <Iceland_jack> HardWare Normalization day?
11:15:37 <monochrom> Haskell Weekly News!
11:15:49 <Iceland_jack> ah
11:16:59 * hackagebot hdocs 0.4.0.4 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.0.4 (AlexandrRuchkin)
11:20:09 <seanparsons> I'm a bit baffled, System.Process.runInteractiveProcess appears to be a blocking call.
11:20:17 <seanparsons> Which would appear to defeat the point of it.
11:23:02 <merijn> What leads you to believe it's blocking?
11:23:52 <seanparsons> merijn: The line after the call to runInteractiveProcess doesn't execute.
11:24:33 <merijn> seanparsons: Write a minimal example?
11:25:06 <seanparsons> https://www.irccloud.com/pastebin/XlAalH2A
11:25:19 <seanparsons> That's a snippet from what I'm experimenting with.
11:25:40 <seanparsons> The second call to writeFile never happens.
11:25:58 <seanparsons> Ah, dammit.
11:26:13 <seanparsons> I may have undone too far.
11:27:36 <spaxxo> yo merijn
11:27:40 <seanparsons> Actually this still applies, as the behaviour is still the same with createProcess as it blocks just the same.
11:28:02 <spaxxo> merijn: what are the 3 windows in coquille and how do i use them? How do I run an eval expression for example?
11:28:21 <zygs-zegs> take 5 [1..5]
11:28:27 <zygs-zegs> > take 5 [1..5]
11:28:28 <lambdabot>  [1,2,3,4,5]
11:28:56 <zygs-zegs> > @hoogle [a] -> [a]
11:28:57 <lambdabot>  <hint>:1:1: parse error on input ‘@’
11:29:02 <zygs-zegs>  @hoogle [a] -> [a]
11:29:09 <zygs-zegs> @hoogle [a] -> [a]
11:29:11 <lambdabot> Prelude cycle :: [a] -> [a]
11:29:11 <lambdabot> Data.List cycle :: [a] -> [a]
11:29:11 <lambdabot> Prelude init :: [a] -> [a]
11:29:28 <seanparsons> merijn: In the end both invoke createProcess_ it would appear, so I think the behaviour is shared.
11:29:53 <zygs-zegs> @hoogle (a -> b -> c) -> a -> [b] -> [c]
11:29:53 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:29:53 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:29:53 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
11:31:31 <merijn> spaxxo: If you load a Coq file in the main window you can step through the proofs/code in that file, the top right window will show the current proof state and the bottom right prints info
11:32:07 <merijn> spaxxo: If you copied my '.' keybinding you can just type proof code in the main window and it will automatically update everytime you type a . in your proofs
11:32:28 <spaxxo> merijn: what is that keybinding again?
11:32:32 <zygs-zegs> > pl \a map ((*) a)
11:32:33 <lambdabot>  <hint>:1:4: parse error on input ‘\’
11:32:34 <merijn> seanparsons: I wouldn't expect createProcess to block either
11:32:41 <geekosaur> "@pl"
11:32:50 <zygs-zegs> > pl (\a -> map ((*) a))
11:32:51 <geekosaur> and other syntax issues
11:32:51 <lambdabot>  Not in scope: ‘pl’
11:32:51 <lambdabot>  Perhaps you meant one of these:
11:32:51 <lambdabot>    ‘pi’ (imported from Prelude),
11:32:51 <lambdabot>    ‘p’ (imported from Debug.SimpleReflect),
11:32:51 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect)
11:32:56 <geekosaur> oy
11:32:59 <zygs-zegs> pl (\a -> map ((*) a))
11:33:11 <josephle> @pl (\x -> x + 1)
11:33:12 <lambdabot> (1 +)
11:33:12 <merijn> spaxxo: https://github.com/merijn/dotfiles/blob/master/vim/ftplugin/coq.vim see also the Coquille helpfile for existing commands
11:33:20 <zygs-zegs> @pl (\a -> map ((*) a))
11:33:20 <lambdabot> map . (*)
11:33:20 <spaxxo> thanks merijn
11:34:49 <spaxxo> btw  merijn i get warnings when i put evals in my code, is there a work around for this?
11:35:57 <merijn> Don't rememeber of the top of my head
11:36:06 <seanparsons> merijn: That's what's baffling me.
11:36:38 <merijn> seanparsons: It works here
11:36:44 <merijn> seanparsons: But I need to run for lunch :)
11:37:00 * hackagebot cgi 3001.2.0.0 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.2.0.0 (cheecheeo)
11:39:35 <seanparsons> merijn: When I replace that command of mine with "ls" it magically doesn't block, so the app I'm invoking must be doing some nonsense.
11:41:31 <geekosaur> I would have to see more but can think of several possible issues depending on what else is going on
11:41:55 <eacameron> is it possible to run haskell code from stdin or similar? I want something like `$ runhaskell -c 'main = writeFile "file" "somestr"'`
11:42:09 <seanparsons> geekosaur: Was that directed at me?
11:42:18 <geekosaur> seanparsons, yes
11:42:24 <johnw> eacameron: can you redirect to runhaskell with <<EOF?
11:42:26 <geekosaur> eacameron, are you thinking of ghc -e ?
11:42:49 <seanparsons> geekosaur: Please tell me what you're thinking of at the very least.
11:43:43 <geekosaur> seanparsons, the big one is deadlocks when multiple processes are talking to each other (which you seemed to be implying).
11:43:49 <eacameron> geekosaur: ghc -e it is!
11:44:25 <eacameron> johnw: I'm not sure how I would do that; but ghc -e seems to do the trick
11:44:27 <seanparsons> geekosaur: I wasn't implying anything, this is just something I'm trying to run and then monitor the stdout of in the background, it runs totally fine outside of the code I'm writing.
11:44:32 <geekosaur> it is possible, when two processes are talking to each other over pipes, to get one to block on a full pipe because the other is not reading its side, but is writing to the first process. in which case both will block waiting for each other to read their pipes, which they will never do.\
11:44:45 <geekosaur> (also well known in the perl and python communities, because it's not a language thing, it's a unix thing)
11:44:51 <geekosaur> (really an IPC thing)
11:44:57 <osfameron> what's the nicest way to get a list of Show'able values?
11:45:07 <johnw> geekosaur: there is code in stm-conduit to do this that you could port of
11:45:09 <johnw> port over
11:45:13 <johnw> you need a buffering pipe
11:45:16 <geekosaur> again, otherwise I'd have to see more detail
11:45:31 <geekosaur> johnw, I'm not the one trying to do it...
11:45:34 <bennofs> osfameron: why do you need this?
11:46:09 <geekosaur> osfameron, usually the correct answer is a lazy list of String, where the elements are calls to show
11:46:58 <geekosaur> laziness makes it de facto a "list of Show a => a"
11:47:17 <osfameron> bennofs: curiosity really
11:47:22 <osfameron> geekosaur: ooo, that's a cute answer
11:47:36 <bennofs> osfameron: it's possible, but generally it's better to just have a lists of Strings
11:47:37 <ski> osfameron : the other answer is "existentials"
11:47:42 <osfameron> I was looking at http://www.haskell.org/haskellwiki/Heterogenous_collections#Existential_types and it seems somewhat complicated
11:47:59 <geekosaur> yes, it's not an easy thing to do if you try to do it that way
11:48:01 <ski> but as geekosaur and bennofs say, it's usually not needed to complicate stuff with existentials
11:48:04 <bennofs> osfameron: there are not many usecases where you really need existential types
11:48:17 <geekosaur> and laziness means it's rarely necessary or useful to do so
11:48:49 <ski> (even without laziness one could use `[() -> Blah]', i suppose)
11:50:01 <johnw> osfameron: there are 3 ways to do heterogenous list that I've used; in increasing order of complexity: sum types, type classes, data kinds
11:50:24 <vanila> how are data kinds used?
11:50:27 <osfameron> sum types makes sense
11:50:54 <johnw> vanila: https://gist.github.com/cbca2b0e95cef5aa22f9
11:51:05 <osfameron> "type classes" doesn't though -- surely my question "how do I get a list of Show?" was precisely "how do I get a list of {things of a type class}" ?
11:51:17 <johnw> vanila: for a longer explanation, see https://ocharles.org.uk/blog/posts/2014-06-10-reversible-serialization.html
11:51:26 <vanila> thank you
11:51:28 <johnw> he has a section there where he uses that construction
11:51:34 <vanila> very interestingG!
11:52:48 <johnw> ozataman: ping
11:54:27 <johnw> osfameron: I see what you mean
11:56:16 <johnw> osfameron: that haskellwiki page uses a "box" around the existential so that you can put anything that's showable into the box
11:56:37 <johnw> then you can have a list of those boxes; the only thing you can do to unbox them is to use "show"
11:56:44 <johnw> so it is effectively identical to a list of strings
11:57:08 <osfameron> ah, heh
11:57:10 <johnw> it gets more interesting if there are multilpe things you could do at unboxing
11:57:16 <osfameron> though presuambly for a different typeclass... yeah, that
11:59:21 <osfameron> oh ok, I get what that code is doing now
11:59:55 <int-index> lens are MAGIC
12:00:46 <int-index> I just wrote some code and it somehow works with all of the lens combinators.
12:00:51 <int-index> Need to check the laws, though.
12:01:04 <johnw> yep, checking the laws is a good thing
12:01:11 <johnw> I've written many a lens which did not pass muster
12:01:26 <c_wraith> That's the big win with the lens package.  Many things just work.
12:01:52 <edwardk> int-index: lens combinators just work even with illegal lenses the main thing you lose is canonicity of the way they work
12:02:18 <c_wraith> the lens package even contains some illegal lenses that are really handy, iirc.
12:02:31 <c_wraith> They work, they just are more fragile.
12:02:32 <edwardk> the code in lens is written in such a way that if your code respects the lens laws then they 'do the only thing they could possibly do', but if you don;t respect the lens laws you may have to care about how we chose to implement them
12:02:44 <johnw> I wrote a Python-eqsue "lens" that lets you extract and replace splices in lists; but it is as lawless as it gets
12:02:44 <int-index> edwardk, is it safe to rely upon this uncanonical behaviour?
12:03:14 <c_wraith> johnw: does it wear a bandana over its nose and mouth?
12:03:14 <edwardk> well, the combinators in lens 'maximally fuse stuff into one pass', so so long as that is what you are looking for, then its fine
12:03:44 <edwardk> the correctness of that choice if however predicated on the lens laws =)
12:03:48 <johnw> c_wraith: I wondered why it did that!
12:05:08 <MeatPuppet> what projects haskell are used in the real world?
12:05:22 <c_wraith> pandoc is probably the most widely used.
12:05:29 <c_wraith> But there are a lot more
12:05:31 <sivteck> xmonad
12:05:33 <bennofs> MeatPuppet: I use xmonad as a window manager
12:05:47 <int-index> MeatPuppet, I enjoy using xmonad
12:05:54 <bennofs> MeatPuppet: some people use darcs (dvcs)
12:06:10 <sivteck> there's also hledger
12:06:59 <c_wraith> A lot of commercial haskell code isn't in products that are distributed to end users, though.  All the financial stuff, all the web services..
12:07:08 <int-index> edwardk, I actually wrote a setter, and it complies the (over l id = id), but I'm not sure about (over l f . over l g = over l (f . g)). The second law is very likely does not work in my case.
12:07:44 <int-index> So I'm kinda afraid that if you change the implementation of some functions, they will stop as expected for me (right now it works perfectly well)
12:08:15 <sivteck> MeatPuppet, http://www.haskell.org/haskellwiki/Applications_and_libraries#Haskell_applications_and_libraries
12:12:42 <MeatPuppet> thanks
12:13:16 <MeatPuppet> what haskell is best for? Can I use on distributed applications?
12:13:21 <edwardk> int-index: in general i'm not going to go through and split apart code in there into multiple passes, it can't be done while retaining the generality of the existing implementation
12:16:58 <johnw> MeatPuppet: yes, there is Cloud Haskell for distributed applications
12:17:06 * dfeuer_ bangs his head against the wall.
12:20:45 <int-index> edwardk, does this mean that I am ok with breaking this law?
12:21:12 <johnw> better ot ask forgiveness from edwardk than permission
12:21:19 <edwardk> int-index: you sound like you are looking for an indulgence from a medieval pope
12:21:55 <int-index> edwardk, I'm looking for safety guarantees, because the internals of your library are as magical to me as its behavior
12:22:00 <edwardk> int-index: what i can say is 'it'll probably work', but that said, the laws are there for the users of a given lens, not for the author of a given lens-like
12:22:30 <monochrom> hrm! missed the earlier conversation about [exists a. Show a => a]!
12:22:44 <monochrom> because you know how I have a quote on that :)
12:22:50 <edwardk> i can say this, i won't go out of my way to break you, and its not easy for me to even consider doing so, so it probably won't happen, but what you are relying upon is definitely 'operational' behavior where you are outside of the specified range of applicability of the tools involved.
12:22:51 <monochrom> @quote monochrom boat
12:22:52 <lambdabot> No quotes match. Whoa.
12:22:56 <monochrom> @quote monochrom river
12:22:56 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
12:22:57 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
12:23:25 <simpson> Ugh. Is it possible to compare two values by identity?
12:23:36 <monochrom> no
12:23:39 <johnw> well
12:23:44 <bennofs> simpson: only if you can create the values in the IO monad
12:23:53 <johnw> you could use http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Unique.html
12:23:57 <bennofs> simpson: then you can use Foreign.StablePtr
12:24:03 <monochrom> http://ro-che.info/ccc/9 :)
12:24:09 <johnw> and associate that with your values
12:24:39 <simpson> johnw: That looks like my original idea of a serial number, but much better.
12:25:10 <johnw> simpson: see also http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Mem-StableName.html
12:26:26 <simpson> johnw: I'm implementing an object language that defines object equality for all objects, and identical objects are equal.
12:26:36 <simpson> Thus, I need to be able to determine whether two objects are identical.
12:26:48 <simpson> Looks like Unique fits my needs perfectly, thanks.
12:28:03 <Wizek> Can anyone recommend a haskell plotting lib that doesn't have external dependencies, e.g. cairo?
12:29:37 <augur> where do i get HsFFI.h to use for a C project?
12:31:29 <augur> or is HsFFI not a standard thing
12:31:45 <monochrom> if you use ghc to compile a C file, ghc will call gcc with the right -i<dir> flags, so that gcc knows where to find HsFFI.h
12:32:12 <augur> im using Xcode. i compiled to a library
12:32:37 <Wizek> Or, does anyone know what is going wrong in here? https://gist.github.com/Wizek/b1b15cef3321bbdf02da#file-3rd-attempt-shell
12:32:49 <Wizek> I am trying to install Chart-gtk
12:32:55 <monochrom> if not, then you can try to find HsFFI.h yourself under ghc's directories. an example installation has it in /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/include
12:33:10 <Wizek> butbut some kind of C lib "intl" is missing
12:35:20 <monochrom> however, I do not recommend relying on HsFFI.h at all. I recommend using standard C types on the C side, then using guaranteed corresponding Haskell types on the Haskell side, e.g., int on C, CInt on Haskell
12:36:14 <augur> monochrom: this is what was generated by Cabal+GHC
12:36:56 <augur> monochrom: mostly it seems to be for defining types?? HsPtr ~ void* etc?
12:38:24 <monochrom> if it is generated by Cabal+GHC, then Cabal+GHC knows how to build it. at least I presume.
12:38:55 <monochrom> as I said at the beginning, ghc passes the right flags to gcc.
12:39:25 <augur> monochrom: im not using Cabal+GHC, thats the problem
12:39:55 <monochrom> well then, you are on your own.
12:39:59 <augur> :P
12:40:06 <monochrom> everyone installs GHC in a different directory
12:40:16 <monochrom> everyone's HsFFI.h is in a different directory
12:40:24 <augur> i mean, what is the point of HsFFI in the stubs that Cabal+GHC produces?
12:40:41 <augur> is it just to get the types for the externs?
12:40:42 <monochrom> "where is HsFFI.h, without asking GHC?" answer: do an exhaustive search.
12:40:48 <augur> not where
12:40:50 <augur> what is it _for_
12:40:52 <monochrom> yes
12:41:11 <zygs-zegs> The function "bindM2" from Control.Monad.Parallel, does it perform the parallelism strictly, or lazily? Does "bindM2" ensure that both monadic computaions are completed before applying the parellel computation rezults to the "merging function" (1st argument)?
12:41:18 <tomejaguar> How do I use a type level tuple?
12:41:31 <augur> if its purpose is just to define types like HsPtr, etc. then i can do that by hand. if it does something more, then ill have to include it
12:41:31 <monochrom> GHC doesn't even generate C stubs these days
12:41:59 <augur> monochrom: well my version did
12:42:06 <augur> i dont know what version you're using that doesnt
12:42:23 <monochrom> since 7.6 or before
12:43:01 <augur> well thats definitely not true, since im on the pre-release of the most recent version
12:43:11 <monochrom> I was, actually, surprised that the user's guide still talked about M_stub.c. it no longer existed
12:43:34 <augur> so unless that was added in in the brief period between when i got my version, and when the final version was released, it definitely generates stubs
12:43:58 <monochrom> M_stub.h still exists. however, it can be safely ignored.
12:44:16 <augur> wait
12:44:31 <augur> so.. what do i include in my C project then
12:44:45 <monochrom> this is why I wrote my recommendation.
12:44:59 <augur> i have a dylib, and i was under the impression i needed to include the .h for the file that exports functions
12:45:09 <augur> which is, afaict, the stub.h
12:45:14 <monochrom> I recommend using standard C types on the C side, then using guaranteed corresponding Haskell types on the Haskell side, e.g., int on C, CInt on Haskell
12:45:22 <augur> yes yes yes
12:45:26 <augur> but thats not the question
12:45:27 <monochrom> this way, your C code need never know that Haskell ever existed
12:45:53 <augur> what files do i _import_? the stub seems to be what i need to import, given what i was previously told
12:46:07 <augur> but now i dont know, since you say i can ignor it
12:46:26 <monochrom> if you follow my recommendation, then M_stub.h can be ignored, it contains no new information
12:46:42 <monochrom> if you don't follow my recommendation, then I don't have another recommendation.
12:46:48 <augur> monochrom: that doesnt answer the question of "what should i import?"
12:46:48 <monochrom> THE END
12:47:00 <int-index> Where do I ask for help? I really can't check if a law holds for my function. (I feel it doesn't, but I can't find an example)
12:47:03 <Twey> @let x = (3, "Hi") :: (Integer, String) in x -- tomejaguar
12:47:03 <lambdabot>  Parse failed: Parse error: in
12:47:05 <bennofs> monochrom: which header defines the  prototypes for exported functions for haskell?
12:47:07 <monochrom> please just mark me as "failed to answer your question"
12:47:10 <Twey> ☹
12:47:15 <Twey> @let { x = (3, "Hi") :: (Integer, String) } in x -- tomejaguar
12:47:15 <lambdabot>  Parse failed: Parse error: in
12:47:25 <Twey> Oh
12:47:32 <Twey> > let { x = (3, "Hi") :: (Integer, String) } in x -- tomejaguar
12:47:33 <lambdabot>  (3,"Hi")
12:47:51 * Twey feels embarrassed
12:47:55 <bennofs> monochrom: doesn't the C compile need the declarations of the functions exported from haskell? otherwise, it cannot check that the arguments your passing it are of the correct type
12:48:03 <augur> monochrom: you're telling me to ignore stuff, but then how does the C side know what exists? i obviously need to #import _something_, so what? yes i can not-#import the stub and be fine, but what _do_ i use?
12:48:51 <monochrom> bennofs: you can handwrite them
12:49:15 <bennofs> monochrom: but ghc already generates them for you, so why introduce another step to make errors?
12:49:28 <tomejaguar> Twey: *Type level* tuple!
12:49:42 <monochrom> suppose your Haskell code exports a "mono :: CInt -> Cint". do you seriously need a computer to generate "extern int mono(int)" for you?
12:49:44 <Twey> tomejaguar: That is a type-level tuple
12:49:53 <augur> monochrom: i said i was handwriting them. but _what do i import_? again, i was informed i needed to add the dylib and an appropriate .h file to my project, and then import the .h. there is no other .h except the stub
12:49:57 <Twey> tomejaguar: (Integer, String) is a (type-level) tuple of types
12:50:02 <monochrom> well, yes yes, but now you have to find HsFFI.h
12:50:18 <bennofs> monochrom: well, but you could change mono :: CString -> CInt some time later, and then forgot to also change the c code
12:50:34 <monochrom> yes yes, I am aware of that
12:50:53 <augur> monochrom: so you're saying i need to find and add HsFFI.h? or.. what? doesnt C need to know what functions are declared?
12:51:12 <Twey> tomejaguar: Unless you mean you want to use the type-level lifting of the value-level tuples, in which case you just write something like: '(3, 5)
12:51:14 <monochrom> who will compile the C file? will he/she use ghc to do it? does he/she even has GHC?
12:51:18 <augur> monochrom: me
12:51:20 <augur> im compiling it
12:51:23 <augur> with Xcode
12:51:32 <monochrom> augur, I am no longer talking to you.
12:51:35 <augur> -_
12:51:38 <merijn> augur: I think you may need to read up on the basics of libraries and linking
12:52:00 <tomejaguar> Twey: I want a type level function that maps '(Int, Bool) to Int
12:52:01 <athan> is there a standard practice that you can use to evaluate strict recursions lazlly? For instance, if I have `foldr (+) 0 [1..]`, and I want to `take 7` from it, it's never going to cease (well, technically because [1..] never stops enumerating (right?)). How could I turn this into something I could evaluate lazilly? foldl?
12:52:08 <merijn> Learn C The Hard Way seems like a decent book and has at least some stuff on linking: http://c.learncodethehardway.org/book/
12:52:09 * hackagebot HueAPI 0.2.1 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2.1 (SjoerdVisscher)
12:52:12 <tomejaguar> Twey: What do you call '(Int, Bool)?  I thought that was a type level tuple.
12:52:25 <tomejaguar> Maybe it's a kind-level tuple.
12:53:03 <augur> merijn: yes, well, I've been in here asking for like the last week and people have told me all i needed to do was add the dylib and import the appropriate .h
12:53:06 <tomejaguar> Basically I want a type level function from (*,*) -> * that projects the first component.
12:53:09 <tomejaguar> Does such a thing exist?
12:53:35 <monochrom> bennofs: suppose the person who will compile the C side decides to not use GHC, for whatever reason. Then M_stub.h becomes a long series of XYZ problems that boil down to saying "extern int mono(int);" in a roundabout way
12:53:54 <tomejaguar> Can I make a type synonym of kind '(*,*) -> *?
12:54:17 <Iceland_jack> tomejaguar: It's trivial to implement
12:54:26 <shachaf> No.
12:54:29 <Iceland_jack>     type family Fst (k :: (a, b)) :: a where
12:54:29 <Iceland_jack>         Fst '(a, b) = a
12:54:33 <Twey> tomejaguar: Type-level functions are called ‘type families’
12:54:50 <Iceland_jack> This is a more general solution since it's polykinded
12:54:58 <tomejaguar> Twey: I want a parametrically polymorphic one.
12:55:03 <shachaf> Well, sure, you can make a type family, but that's more complicated than a synonym at that point.
12:55:23 <Twey> Right, you can make a type-level function that does that; that's not a type synonym.
12:55:44 <tomejaguar> How do I convince the compiler it's defined for all arguments?
12:55:55 <Twey> tomejaguar: http://lpaste.net/1887852801942355968
12:56:15 <Twey> tomejaguar: Why are you trying to do that?
12:56:39 <merijn> augur: None of this is really haskell specific, GHC links binary objects the exact same way as gcc, clang, etc. and there's tons of tutorials/documentation on the web on how to do that. I would recommend reading those and then if you get stuck on a GHC specific issue ask here
12:56:44 <Twey> (not saying you shouldn't, but I'm curious as to what led to it)
12:56:56 <tomejaguar> I'm trying to avoid ambigious type issues that occur if I use type families.  I didn't use higher level type families though.
12:57:00 <tomejaguar> I'll try it.
12:57:35 <Iceland_jack> tomejaguar: Can you be more explicit about which ambiguities?
12:57:52 <augur> merijn: i know its not haskell specific, but i ask in here because i figure people in here will have experience with this and know of any haskell-related nuances. if someone had told me before "its just like using a normal .dylib" i wouldve just looked that up
12:58:14 <tomejaguar> It's all explained here, but it's quite involved at this point ... augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
12:58:15 <Twey> tomejaguar: I don't think totality would help there
12:58:35 <tomejaguar> I don't think I want totality I think I want some sort of parametricity.
12:58:47 <Twey> tomejaguar: Parametricity over what?
12:59:00 <Twey> The examples I linked you show parametricity over types and kinds.
12:59:03 <merijn> augur: Cabal just has fields for specifying linker options and configure/install have flags for specifying extra search directories
12:59:28 <merijn> augur: if you compile to a dynamic library you can just use -L and -l like with GHC to link with it
12:59:32 <tomejaguar> Twey: Well I will give it a go ...
12:59:38 <athan> is there a way to lazilly enumerate the natural numbers?
12:59:49 <athan> for list comprehensions, for instance?
12:59:55 <Twey> athan: [0 ..]
12:59:55 <Iceland_jack> athan: [0..]?
13:00:08 <athan> That's lazy?? o.o
13:00:12 <Twey> (unfortunately we don't really have a ‘natural number’ type)
13:00:16 <Twey> athan: Of course.
13:00:23 <yukko> if it wasn't lazy then infinite lists would not work
13:00:26 <tomejaguar> Twey: Do I need 7.8 for your sample code?
13:00:31 <Twey> tomejaguar: Yep
13:00:36 <athan> how can we use them in list comprehensions?
13:00:41 <Twey> tomejaguar: You can do it with an open type family in 7.6
13:00:43 <Iceland_jack> athan: If you want a proper natural number it's quite easy
13:00:44 <Iceland_jack>     data Nat = Z | S Nat
13:00:44 <Iceland_jack>     lazyList = iterate S Z
13:00:47 <athan> :S
13:00:47 <Iceland_jack> athan: You sure can
13:00:57 <Tuplanolla> How? Just fine.
13:00:58 <Twey> athan: The same way you'd use any other list
13:01:15 <Iceland_jack> > [0..]
13:01:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:01:18 <Twey> > [ (x, y) | x ← [0 ..], y ← [2, 4 ..] ]
13:01:20 <lambdabot>  [(0,2),(0,4),(0,6),(0,8),(0,10),(0,12),(0,14),(0,16),(0,18),(0,20),(0,22),(0...
13:01:28 <athan> :O
13:01:32 <Twey> (it's never going to get to (1, x) though ;))
13:01:33 <athan> I dont even...
13:01:44 <tomejaguar> Twey: Indeed I can ...
13:02:09 <Iceland_jack> Twey: Sure it can!
13:02:11 <athan> Twey: Ahhh, that helps a lot. Thank you :)
13:02:11 * hackagebot servant-scotty 0.1.1 - Generate a web service for servant 'Resource's using scotty and JSON  http://hackage.haskell.org/package/servant-scotty-0.1.1 (AlpMestanogullari)
13:02:18 <Iceland_jack> If it's Word8 it gets there pretty fast :)
13:02:23 <Twey> Ha, fair point
13:02:36 <Iceland_jack> but assuming Integer yeah
13:02:40 <Twey> > [ (x, y) | x ← [0 ..], y ← [2, 4 ..] ] :: [((), ())]
13:02:41 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal ‘0’
13:02:45 <Twey> Aw, no Num ()
13:03:23 <codile> > filter (\x -> 30 >= -20 * 4x) [ x | x <- [1..100], x <= 13]
13:03:24 <Twey> athan: Everything in Haskell is lazy, except the things that aren't (and they're usually marked pretty explicitly).
13:03:25 <lambdabot>  Could not deduce (GHC.Classes.Ord a0)
13:03:25 <lambdabot>    arising from the ambiguity check for ‘e_130204110013’
13:03:25 <lambdabot>  from the context (GHC.Classes.Ord a1,
13:03:25 <lambdabot>                    GHC.Classes.Ord a,
13:03:25 <lambdabot>                    GHC.Num.Num (a -> a1),
13:03:28 <codile> what could be wrong?
13:03:30 <codile> i have no idea
13:03:34 <monochrom> bennofs: when it comes to using Haskell to export a C API and letting other people use it in C, between handwriting C externs and forcing people to install GHC, I choose handwritting C externs. this is because I don't want to force people to install GHC (a wholesome meal by itself), and when it comes to exposing an API, I will be unable to change the types anyway, by popular demand.
13:04:10 <Twey> codile: ‘4x’ is not valid syntax.  You have to write ‘4 * x’.
13:04:15 <codile> ah crap
13:04:17 <codile> thank you
13:04:21 <Tuplanolla> > [[(x, y) | x <- [0 .. n], y <- [2, 4 ..]] | n <- [1 ..]]
13:04:22 <codile> i always forget that :/
13:04:23 <lambdabot>  [[(0,2),(0,4),(0,6),(0,8),(0,10),(0,12),(0,14),(0,16),(0,18),(0,20),(0,22),(...
13:04:38 <Tuplanolla> > [[(x, y) | x <- [0 .. n], y <- [2, 4 .. n]] | n <- [1 ..]]
13:04:38 <Twey> codile: GHC thinks you're trying to apply the function 4 to the variable x, and to make that make sense it's assuming some pretty weird constraints.
13:04:39 <lambdabot>  [[],[(0,2),(1,2),(2,2)],[(0,2),(1,2),(2,2),(3,2)],[(0,2),(0,4),(1,2),(1,4),(...
13:04:53 <Tuplanolla> I forgot what I was trying to do here.
13:05:02 <Twey> codile: I.E. that there's a function type (a → a1) that can be written as 4.
13:05:03 <codile> Twey: wait a second. you can do that without a space?
13:05:14 <codile> huh
13:05:17 <Twey> codile: Yes, because identifiers can't start with numbers.
13:05:18 <codile> that's interesting
13:05:24 <Twey> (unfortunately)
13:05:33 <codile> heh
13:05:34 <athan> You can't make self-referencing list comprehensions, can you? S.T. `primes = [ x | x <- [2..], not (x hasMultipleOf primes) ]
13:05:34 <Ch0c0late> Is it really a good algorithm in order to take all possible path from one point namely x0, y0 to every point? Some would use single source shorts path but what about this method? As an example there is 6 possible paths from 0,0 to 2,2.
13:05:38 <Ch0c0late> > sort $ nub $ permutations "HVHV"
13:05:40 <lambdabot>  ["HHVV","HVHV","HVVH","VHHV","VHVH","VVHH"]
13:05:42 <Twey> athan: Yes, of course.
13:05:55 <athan> Twey: :::O
13:06:08 <Twey> You'll need backticks around that infix function, though.
13:06:09 <athan> bazingo
13:06:20 <athan> Twey: My goodness, thank you
13:06:46 <Twey> And you need to be careful when doing that not to accidentally depend on the item you're currently creating, which would give you an infinite loop.
13:07:19 <athan> Twey: Hmm, I'll watch out for that. Thankyouthankyouthankyou :)
13:07:23 <Iceland_jack> Twey: Haskell needs overloadable whitespace :)
13:07:36 <Twey> Haskell needs mandatory whitespace
13:07:42 <Twey> Overloadable whitespace would be pretty cool too.
13:07:47 <monochrom> "space, the final frontier"
13:07:51 <Iceland_jack> Yes!
13:07:59 <MP2E> hahah
13:08:07 <Iceland_jack> There was a paper ages ago by Stroustrup about overloading whitespace
13:08:14 <eacameron> Twey: OverloadedFunctionApplication would be nice
13:08:40 <Iceland_jack> I think it would make a whole lot more sense in Haskell (or Idris since they focus on EDSLs)
13:08:40 <monochrom> I was planning to do an April 1st joke on that. but I became sick just before.
13:10:05 <monochrom> the butterfly effect of my family infecting me with traveller's flu (I didn't travel, they did) is that the world has to see OverloadedJuxtaposition one year later!
13:10:47 <Twey> > let fibs = 0 : 1 : [ x + y | (x, y) ← zip fibs (tail fibs) ] in fibs -- this is a classic, athan
13:10:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:11:09 <Twey> eacameron: Haven't there been proposals for idiom brackets since the beginning of time?  :þ
13:12:31 <eacameron> Twey: I can't wait to see idiom brackets defined in terms of other idiom brackets.... [| f [| b c |] d |]....
13:12:51 <Twey> Well, it's just f <$> (b <$> c) <*> d
13:13:09 <Twey> … a pattern I very nearly used today, actually
13:14:02 <eacameron> it would indeed be nice....why don't we have it yet?
13:14:25 <Twey> eacameron: It turned out we didn't need them in the language: https://hackage.haskell.org/package/applicative-quoters
13:14:34 <athan> Twey: I think I'm shooting myself in the foot with map :(
13:14:40 <Iceland_jack> Twey: Almost nobody uses that and it has a pretty big dependency
13:15:00 <Twey> Conor McBride implemented them in SHE, and then we got TH
13:15:11 <Twey> Iceland_jack: You mean haskell-src-meta?
13:15:13 <Iceland_jack> yeah
13:15:15 <Twey> athan: Try not to do that ;)
13:15:35 <eacameron> Twey: sadly, it doesn't support nesting... ;)
13:15:46 <Twey> Oh, that's true :-\
13:16:00 <Iceland_jack> I've brought it up on #ghc and if we can agree on a syntax and someone is up for implementing it, it's in
13:16:15 <Twey> Ah, neat
13:16:24 <benzrf> what abt nested expressions in idiom brackts
13:16:25 <benzrf> i.e.
13:16:27 <Twey> Iceland_jack: OverloadableWhitespace or IdiomBrackets?
13:16:32 <benzrf> [| f (g a) (h b) |]
13:16:33 <Iceland_jack> Twey: haha IdiomBrackets
13:16:41 <Twey> I guess it should be BindableWhitespace after BindableSyntax
13:16:47 <Twey> Ah.  Aww.
13:17:25 <int-e> I sometimes wonder whether it's possible to disentangle compile time (template haskell) dependencies of a module (and library) from the others...
13:17:49 <merijn> int-e: There's some interest in that, yes
13:17:57 <benzrf> so how would the thing i said work P:
13:18:12 <benzrf> just top-level application gets translated?
13:18:19 <Iceland_jack> benzrf: yes
13:19:15 <athan> Twey: I don't think prime numbers can be enumerated with a comprehension :/
13:19:30 <Twey> benzrf: Yes, you can write [| f [| g a |] [| h b |] |] for the other interpretation.
13:19:46 * bennofs would like if TH splices were cached. This could greatly reduce compile time for some applications using lens th a lot ...
13:19:46 <simpson> Is there any documentation on writing Arbitrary instances for QuickCheck aside from QC's haddock docs?
13:20:25 <Iceland_jack> simpson: there is a tutorial
13:20:40 <Iceland_jack> you shouls find it by googling, bit busy atm
13:20:51 <Iceland_jack> Hosted at Chalmers I think
13:21:08 <athan> Twey: How could I do this without using map? http://lpaste.net/110114
13:21:49 <athan> er, anybody :(
13:23:28 <Twey> athan: That's going to fail because you test *all* the primes — including the one you're producing, and the ones after it
13:23:47 <Twey> FYI any f = or . map f
13:23:50 <athan> ><
13:24:11 <Twey> The usual formulation is something along the lines of: primes = sieve [2 ..] where sieve (p:xs) = p : sieve [ x | x ← xs, mod x p /= 0 ]
13:24:54 <athan> Twey: Gah, I need to get better at this. Thank you again
13:25:03 <lpaste> eacameron pasted “Program that eats memory for breakfast” at http://lpaste.net/110115
13:25:39 <eacameron> I cannot figure out why this little thing eats 600 MB of mem!
13:25:49 <eacameron> the input file is 38 MB
13:27:26 <lpaste> eacameron revised “Program that eats memory for breakfast”: “No title” at http://lpaste.net/110115
13:27:39 <eacameron> added prof info
13:35:49 <Algebr> I'm still having a hard time understanding the state monad, specifically the get magic which I guess is not magic because type classes?
13:36:40 <vanila> Algebr, well the first thing to understand is the definition of State s a itself
13:36:44 <merijn> Algebr: There is no typeclass magic
13:36:58 <levi> Algebr: What piece are you referring to as "get magic"? How the correct implementation of 'get' is selected?
13:36:58 <vanila> then 'get' is just a simple function with type State s s
13:37:12 <vanila> If you like I could explain
13:37:16 <merijn> Algebr: The only reason "get" is so cryptic is probably because you're importing "Control.Monad.State" instead of "Control.Monad.Trans.State"
13:37:24 <merijn> :t Control.Monad.State.get
13:37:25 <lambdabot> MonadState s m => m s
13:37:29 <merijn> :t Control.Monad.Trans.State.get
13:37:30 <lambdabot> Monad m => StateT s m s
13:37:36 <merijn> :t Control.Monad.Trans.State.get :: State s s
13:37:37 <lambdabot> State s s
13:38:58 <Algebr> merijn: yes, was using Control.State.Monad
13:41:17 <Algebr> err, rather control.monad.state. In any case, get gives back State, but where does that come from?
13:41:37 <merijn> Algebr: I recommend the following homework to figure out what's going on: https://gist.github.com/merijn/098106abd45c940dab09
13:41:55 <merijn> Algebr: Try and implement the type signatures in that file and see how far you get :)
13:42:34 <Algebr> k
13:42:42 <brycelane_> I'm reading about exceptions, that leads to monad transformers, and that leads to concerns about performance. In high performance code, is it a problem?
13:42:51 <merijn> brycelane_: "it depends"
13:43:21 <merijn> brycelane_: How high performance, for example, take a look at the streaming libraries they use transformers but their overhead is measured in nanoseconds per iteration
13:43:49 <athan> Is there a function something like tails that returns a list of fixed size substring of an input?
13:44:02 <merijn> brycelane_: If you would consider writing this same application in python/ruby/js, then the answer "is this a performance problem?" is "no"
13:44:18 <merijn> brycelane_: Now, if you're trying to do low level C-speed code? Then maybe
13:44:22 <athan> for instance, if acted upon "foobar" with size 3, you would get ["foo", "oob", "oba"...]
13:44:43 <brycelane_> how about this for a metric: Exceptions. How would it compare to say, java exceptions?
13:45:02 <benzrf> @let subs n = map (take n) . tails
13:45:04 <lambdabot>  Defined.
13:45:09 <benzrf> > subs 3 "foobar"
13:45:11 <lambdabot>  ["foo","oob","oba","bar","ar","r",""]
13:45:18 <benzrf> probably horribly inefficient
13:45:18 <merijn> brycelane_: Haskell exceptions (the IO ones that are from Control.Exception) are similar to java unchecked exceptions
13:45:38 <monochrom> eacameron: where is Control.Concurrent.STM.TMQueue from?
13:45:41 <vanila> benzrf, actually i think the efficiency is fine
13:45:45 <benzrf> oh?
13:45:53 <brycelane_> merijn, in performance?
13:45:54 <benzrf> ah yes laziness helps
13:45:57 <vanila> yeah i mean it's just doing what it has to
13:45:57 <athan> benzrf: hmm, alright. Thank you
13:46:00 <vanila> exactly because of lazyness
13:46:16 <merijn> brycelane_: I don't know anything about the performance of java exceptions
13:46:45 <merijn> brycelane_: But you shouldn't be throwing exceptions in tight inner loops and pure code anyway. In other situations I don't think it matters much
13:47:17 * hackagebot HueAPI 0.2.2 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2.2 (SjoerdVisscher)
13:47:46 <brycelane_> merijn, do you have any feeling for the difference in using a StateT and passing a state like structure in a loop?
13:47:55 <brycelane_> I suppose that is one I can easily check myself
13:48:08 <nh2> is there something that gives me Generic instances for the things in Language.Haskell.TH?
13:48:21 <merijn> brycelane_: I would estimate the difference to be in nano to microseconds
13:48:27 <merijn> brycelane_: i.e. not worth worrying about
13:48:44 <merijn> brycelane_: Probably still several order of magnitudes faster than, say, a python function call
13:48:49 <fread2282> brycelane_: depends what the loop is
13:49:06 <nh2> brycelane_: check the benchmarks in the `loop` package, maybe they are relevant to you
13:49:21 <brycelane_> merijn, I'm certainly not interested in python when it comes to performance ;) . I thinking in terms of scala/java/rust
13:49:42 <brycelane_> I don't expect it to be on the same level, but an order of magnitude is too much to pay.
13:50:07 <Algebr> merijn: How can I tell if my implementation of return / >>= is correct? I have to check if they hold up with the monad laws?
13:50:26 <bennofs> Algebr: yes
13:50:33 <merijn> Algebr: Well, you can try manually proving it for yourself (I recommend that) or you can just ask here
13:50:51 <Tuplanolla> QuickCheck helps too.
13:50:51 <merijn> Algebr: Note that it's really hard to implement something that typechecks and is wrong for State
13:51:35 <monochrom> there is also the question of "what is correct", or rather, "how correct is correct"?
13:51:38 <merijn> brycelane_: I'm not entirely sure, it depends on too many variables. In general I would expect haskell to be faster than equivalent scala
13:52:04 <monochrom> if your goal is to implement a sort of State monad, monad laws are only a start.
13:52:10 <merijn> brycelane_: Because Scala really has a lot of difficulty getting the JVM to do what it wants in a fast way
13:53:06 <Algebr> I just want to understand how the state monad works. it just looks like a type wrapper on a function.
13:53:26 <monochrom> yes
13:53:35 <MP2E> It is, a 'shape' of function
13:53:38 <merijn> Algebr: It is :)
13:53:49 <monochrom> if you only want a beginner's understanding, then you are done
13:53:53 <Algebr> How is that state then
13:53:57 <merijn> Algebr: The real one is actually implemented use a newtype (slightly faster)
13:54:09 <merijn> Algebr: It's just "faking" state, since you can get/put
13:54:12 <monochrom> if you want an expert understanding, then you have barely scratched the surface.
13:54:18 <MP2E> Algebr : It's a functional model of state, State goes in, result comes out with modified state. What more do you need? :)
13:54:20 <brycelane_> merijn, I think they typically are similar, but vary quite a bit depending on the specific situation. I'm interested in learning another tool to produce native binaries, and scala makes me love functional but I don't want to sink the time learning libraries if its not going to work out in the end.
13:54:26 <Algebr> I'd settle for a mid-level one..
13:54:55 <merijn> brycelane_: There's some people working on using conduits (a streaming IO library) to do streaming data analytics
13:55:26 <Algebr> MP2E: is that the purpose of the type classes, to abstract away having to thread through the state?
13:55:28 <Peaker> Algebr: "State" models stateful computations, not the state itself
13:55:34 <qrada__> hey, can anyone tell me how i can convert an Int64 to Int? i've imported Data.Int etc and no sure how to convert it. I'm getting the Int64 from Data.ByteString.Lazy
13:55:34 <Peaker> Algebr: the "s" in "State s" is the state itself
13:55:35 <merijn> brycelane_: They've managed to get conduit to compile inner loops into something whose overhead is like a few nanoseconds max
13:56:03 <eacameron> monochrom: stm-chans
13:56:09 <Algebr> Peaker: So if s was a String, then it would be like some String that was getting updated throughout the life of the program?
13:56:10 <MP2E> Algebr: Yep, that's exactly what the monad instance does for State :)
13:56:12 <Peaker> Algebr: no, the purpose of the "State" data-type and the existence of a function:  State s a -> (a -> State s b) -> State s b       is to abstract away the threading of the state
13:56:26 <merijn> brycelane_: Especially when combined with the LLVM backend you can get pretty zippy numerical code, in addition the new IO manager in GHC 7.8 is blazingly fast
13:56:33 <brycelane_> merijn, that is pretty good. Is that compiler extensions or just really detailed understanding of how ghc will spit out binary?
13:56:42 <Peaker> Algebr: yeah
13:56:51 <Peaker> Algebr: my "no" there was about the previous thing you said
13:56:52 <brycelane_> I've heard nothing but great things about the 7.8 IO manager.
13:57:05 <merijn> brycelane_: Probably uses compiler extensions too, just because GHC has lots of really useful ones
13:57:10 <Peaker> Algebr: to understand "State" you don't really need to understand type-classes
13:57:19 * hackagebot bytestring-conversion 0.2 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.2 (ToralfWittner)
13:57:30 <brycelane_> merijn, I mean't custom extensions just for the conduit work ;)
13:57:31 <merijn> brycelane_: The haskell standard is really rather conservative, most GHC extensions deal with things like fancy typing features, though
13:57:37 <merijn> brycelane_: Oh, no
13:57:39 <Peaker> Algebr: you could imagine there exists:   return :: a -> State s a    and    (>>=) :: State s a -> (a -> State s b) -> State s b           and the State operations, without type classes, and understand state
13:57:48 <eacameron> monochrom: I finally decided it was worth an SO: http://stackoverflow.com/questions/25536604/huge-memory-consumption-for-simple-multithreaded-haskell
13:58:23 <qrada__> sorry to be a nag but could anyone help me out for 1 sec? Just need to convert/cast Int64 to Int
13:58:27 <merijn> brycelane_: That's just native haskell, I mean it's riddled with like INLINE pragmas/rewrite rules to optimisations, but those you can use in any library
13:58:29 <qrada__> can't figi t out
13:58:39 <merijn> qrada__: Do you care about truncation?
13:58:47 <qrada__> nah, don't care at all
13:58:53 <merijn> qrada__: fromIntegral? :p
13:58:56 <qrada__> this is for a small demo i want to give for some people soon
13:58:56 <qrada__> hm
13:59:01 <qrada__> i tried..didnt work
13:59:03 <qrada__> maybe i nub'd.. sec
13:59:10 <merijn> > fromIntegral (200 :: Int64) :: Int
13:59:12 <lambdabot>  200
13:59:32 <qrada__> lmao....... typo'd when i was testing.. did fromInteger
13:59:34 <qrada__> wrecked..
13:59:37 <qrada__> thanks as always merijn
13:59:58 <Algebr> Peaker: so then what is the a for in State s a, if the s is the state being modeled
14:00:28 <merijn> Algebr: The return value of the stateful computation
14:00:47 <merijn> Algebr: "State s a" is a stateful computation with some state 's' that returns an 'a'
14:00:49 <monochrom> hmm, Haskell Platform 2014.2 is still at cabal-install 1.18? :)
14:00:57 <merijn> monochrom: Yup
14:00:59 <merijn> Sadly
14:01:01 <sm> euh
14:02:27 <monochrom> I don't mind, actually
14:04:54 <Algebr> Is return like a lambda abstraction?
14:04:55 <spaxxo> is simon peyton jones gay?
14:05:07 <Jeanne-Kamikaze> :/
14:05:30 <systemfault> spaxxo: Wikipedia exists, look him up.
14:05:42 <spaxxo> systemfault: wikipedia has no info on this
14:06:23 <levi> This channel isn't for speculation about the sexual orientation of people.
14:06:35 <systemfault> spaxxo: http://research.microsoft.com/en-us/people/simonpj/#who
14:06:53 <spaxxo> ah
14:06:57 <athan> ...why can't we directly compare Ints with Integers? :S
14:07:01 <spaxxo> still in the closet i see
14:07:11 <barrucadu> athan: BEcause they're different types
14:07:11 <MP2E> he has 3 kids >_>
14:07:14 <barrucadu> *Because
14:07:22 * hackagebot conduit-extra 1.1.3.4 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.3.4 (MichaelSnoyman)
14:07:44 <spaxxo> MP2E: he is careful
14:08:31 <spaxxo> i didnt know women could be priests
14:08:34 <spaxxo> fishy stuff
14:09:04 <Algebr> Is Cale a mod?
14:09:06 <levi> spaxxo: Again, not appropriate topics for discussion in this channel.
14:09:11 <spaxxo> okey
14:13:17 <d-snp_> ghc-options:         -threaded -with-rtsopts=-N <-- is what I put in my cabal file to make my app do M+N multithreading right?
14:17:23 * hackagebot wai-predicates 0.8.2 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.8.2 (ToralfWittner)
14:18:37 <monochrom> eacameron: a linked list of k items takes 16*k bytes, since each cell is "pointer to data, pointer to next", each pointer is 8 bytes. I want you to calculate: how many bytes are there in a linked list of 5000000 items?
14:18:56 <monochrom> > 5000000*16 / 1024 / 1024
14:18:58 <lambdabot>  76.2939453125
14:20:02 <monochrom> ok, that is not enough to account for 600MB
14:20:34 <eacameron> monochrom: +RTS -s is saying over 2GB total mem used... :(
14:24:21 <monochrom> perhaps TMQueue takes way more than 16 bytes per cell
14:24:25 <merijn> monochrom: Don't forget the pointer and boxes from the numbers themselves
14:24:52 <merijn> monochrom: TMQueue is basically a TQueue in a TMVar and TQueue uses a linked list internally too
14:24:55 <spaxxo> it also probably preallocates space of some size kn^2
14:27:44 <monochrom> hrm sweet, TQueue is two TVar[a]'s? the infamous amortized O(1), worst-case O(n) queue? :)
14:28:12 <merijn> monochrom: Yes :p
14:28:12 <monochrom> indeed, readTQueue contains "case xs of ... [] -> ... reverse ..." :)
14:28:37 <merijn> monochrom: The upside is that concurrent writes and reads don't interfere
14:29:04 <merijn> And especially for TBQueue (bounded) with small bounds reverse is guaranteed to be cheap
14:31:51 <monochrom> each bytestring has 24 bytes overhead: pointer to buffer, offset, length. we have 5000000 bytestrings
14:32:00 <monochrom> > 5000000*24 / 1024 / 1024
14:32:01 <lambdabot>  114.44091796875
14:32:55 <monochrom> ok, we have a buffer of 39MB. on top of that, 5000000 bytestrings of 114MB. on top of that, 5000000 linked list cells of 76MB.
14:33:05 <monochrom> > 39+114+76
14:33:07 <lambdabot>  229
14:33:18 <merijn> Twice, because the queue itself also uses a linked list
14:33:29 <merijn> Also, the initial thing was a list of integers
14:34:00 <merijn> Which takes up an extra pointer (integers are boxed) plus however much space a primitive gmp integer takes (probably another 8 bytes)
14:34:21 <monochrom> no no, there is no Integer anywhere
14:34:35 <merijn> oh, did we start talking about a different code example?
14:34:43 <merijn> Also, is this compiled with -O2?
14:34:51 <monochrom> http://lpaste.net/110115
14:34:55 <ew0000> Hey
14:34:57 <monochrom> I used -O
14:35:13 <ew0000> I'm getting a: Main.hs: recv: does not exist (Connection refused)
14:35:21 <ew0000> how can I debug this kind of exception?
14:35:46 <merijn> monochrom: "map show [1..5000000])" <- defaults to Int right? Probably still 16 bytes per Int on 64bit machine
14:36:03 <monochrom> that is just to create an input file, not the program measured
14:37:16 <merijn> ah
14:39:16 <ew0000> merijin, 8 bytes
14:39:25 <athan> Is the order of predicates in a list comprehension the order that they are actually tested?
14:39:31 <ew0000> there's an Int64 type if you are interested
14:39:46 <monochrom> here is the bottomline: I deparallelized the program (so, no async, just run 'producer q' first to queue up everything, then 'consumer q' to dequeue everything.)  this takes 1GB. I'm using /usr/bin/time to tell me this.
14:39:48 <athan> ie: [x | x <- stuff, pred1, pred2 ]
14:40:05 <athan> where pred1 could short-cut the computation before pred2 has a chance?
14:40:33 <monochrom> I can explain 200MB. (I just did.) I can't explain 1GB.
14:40:40 <ew0000> Probably there's an order, since they are a guard monad, or not?
14:40:41 <Peaker> Getting rid of TH with Generic is so nice. However, it exposes all data constructors to all malicious use :( Any solution that lets me eat my cake and still have it?
14:40:50 <ew0000> erm a guard, for the list monad?
14:42:01 <monochrom> the deparallelized story is important because it is an upper bound, and also a tight one, on what happens to the parallelized story. because of speed mismatch, the parallelized story gets anywhere between O(1) to O(n), and empirically indeed various runs yield various results
14:42:07 <SolitaryCipher> hah
14:42:12 <athan> ew000: .-.
14:42:17 <SolitaryCipher> technically GNU Makefile is a functional language.
14:42:23 <eacameron> monochrom: I missed the last 12 minutes; lost power...
14:42:24 <monochrom> however, anything above 300MB I cannot explain, parallel or sequential
14:42:25 <merijn> ew0000: Int on a 64bit machine is 16 bytes
14:42:25 <SolitaryCipher> It implements lamdba expressions as well
14:42:36 <SolitaryCipher> so makefiles are technically turing complete
14:42:39 <merijn> ew0000: 8 bytes for the primitive machine int and 8 bytes for the boxed pointer
14:42:46 <Tuplanolla> It's ridiculously powerful too, SolitaryCipher.
14:43:18 <SolitaryCipher> I just find that really entertaining
14:44:27 <ew0000> are you sure Int is boxed?
14:44:49 <merijn> ew0000: Yes
14:44:57 <merijn> All unboxed types have # in the name
14:45:03 <merijn> unboxed Int is Int#
14:45:20 <ew0000> uhmmmm
14:45:39 <merijn> ew0000: You can look at the base source if you don't believe me :)
14:45:40 <Iceland_jack>     data Int = I# Int#
14:45:40 <ew0000> you learn something new every day
14:45:48 <Iceland_jack> @src Int
14:45:48 <lambdabot> data Int = I# Int#
14:45:49 <Iceland_jack> @src Bool
14:45:50 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:46:30 <ew0000> my app keeps closing when connections are being closed U_U
14:46:38 <ew0000> and I don't know how to debug it
14:46:41 <ew0000> U_U
14:47:38 <merijn> ew0000: You seem to be doing a recv on a closed connection, which throws an exception and if that's in your main thread the program dies
14:47:43 <merijn> ew0000: Solution: catch the exception
14:47:45 <monochrom> eacameron: everything you missed is just more questions, not more answers. you didn't miss anything important. I can only calculate the upper bound to be 230MB. I cannot explain 1GB.
14:48:05 <ew0000> yes, but wich recv? I have like a 100
14:48:18 <ew0000> I thought I was catching them all
14:48:37 <monochrom> my calculation may also forget a few things, so let's say 300MB.
14:50:56 <eacameron1> monochrom: yes, the single-threaded case is bad enough, and I hope that 2 threads would reduce it at least a little
14:52:27 * hackagebot wai-routing 0.10.2 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.10.2 (ToralfWittner)
14:53:30 <monochrom> use a 32-bit GHC to half the memory usage :)
14:54:51 <eacameron> monochrom: hahaha...desperate times call for desperate measures
15:01:13 <ew0000> yay, I got it
15:04:00 <brycelane_> merijn, in a tight loop, there is effectively not difference in runtime between using the State monad as a counter and passing the counter as a variable to the function.
15:05:32 <brycelane_> clearly that is a microbenchmark, and real life is totally different, but that was an unexpected result.
15:06:36 <eacameron> monochrom: I tried also using Chan instead of TMQueue with better results as I recall. but I would like to use STM
15:06:50 <eacameron> monochrom: using Chan was still highly unsatisfactory
15:07:19 <monochrom> Chan has a different set of problems
15:07:39 <bennofs> brycelane_: I guess GHC just inlined the definition of >>= for StateT, so the resulting code is in effect the same
15:08:33 <brycelane_> is that a feature unique for StateT or for all monads with inlineable >>=?
15:08:53 <bennofs> brycelane_: I think all monads with inlinable >>=
15:09:25 <bennofs> brycelane_: but if you write very generic code, GHC might sometimes not see which instance of Monad you're using and thus it's unable to inline >>=
15:10:26 <brycelane_> well its better than I thought. I hate monad transformers, but things could be worse.
15:18:38 <trap_exit> as types get more complicated, should I (1) get a wider monitor, (2) allow type declarations of functions be multiline or (3) try to define intermedaite types to force all top-level func decl types to be single line (i.e. < 80 chars) ?
15:18:54 <trap_exit> (I like forcing of single line as it seems to make grepping for types easier)
15:19:48 <monochrom> I don't understand the relation between single-line and grepping
15:20:03 <monochrom> therefore I recommend 1 and 2
15:20:16 <monochrom> in fact, I find that 3 defeats grepping
15:20:42 <trap_exit> well, if it's multi line, grepping for shitngs like "A -> B"
15:20:47 <trap_exit> can become harder if in the source file it's "A -> \n B"
15:21:00 <athan> is there a `takeWhere`?
15:21:05 <monochrom> ok, then get a wide monitor
15:21:10 <athan> instead of a number argument, you pass a predicate?
15:21:43 <athan> and the first failure delimits the list
15:22:03 <vanila> wyh would you grep for type sigs
15:22:10 <monochrom> suppose I want to look for all functions that mention the type Mono. if you do 3, I cannot merely look for Mono.
15:22:39 <monochrom> I have to look for every type alias T that mentions Mono, and look for all functions that mention T.
15:22:51 <trap_exit> hmm
15:22:52 <monochrom> and I have to look for every type alias U that mentions T, and...
15:23:00 <trap_exit> monochrom: you're right
15:23:09 <monochrom> this is a bottomless job
15:23:10 <trap_exit> vanila: if you don't grep, how do you search?
15:23:34 <vanila> i tend to look through the docs
15:24:34 <SPLOOCH> multiline grep using -C,-B and -A
15:25:39 <Peaker> What does hClose block on?
15:26:33 <monochrom> hClose contains a flush buffer, flush buffer contains a write, a write may block
15:26:56 <Denommus> any simple FRP signal function library for Haskell?
15:27:07 <monochrom> Yoga says: hClose leads to writing, writing leads to blocking, blocking leads to anger :)
15:27:29 <MP2E> Yoda? :P
15:27:30 <monochrom> err, Yoda!
15:27:31 <MP2E> haha
15:27:40 <MP2E> anger leads to the IO monad!
15:27:41 <SPLOOCH> disks are fast
15:27:51 <MP2E> wait we were already there
15:27:56 * MP2E thinks of another Dark Side analogy
15:27:58 <SPLOOCH> only if writing to pipes/network
15:28:18 <monochrom> ooohhh, but you don't know whether the hClose is for a disk or a network
15:29:04 <monochrom> NFS and SMB say: you can have both :)
15:29:31 <Peaker> monochrom: what about hClose on an input stream (stdErr of a child process)?
15:29:53 <monochrom> Google Disk (is it called that?) says: you can have both, multiple unknown times :)
15:30:21 <SPLOOCH> is a close an implicit fsync?
15:30:26 <monochrom> hrm, that should not take long.
15:31:46 <SPLOOCH> don't think so.
15:32:05 <monochrom> I do not know how much counts as block. you still have to syscall into the OS. the OS still can say "I'll take this opportunity to suspend you because I like to"
15:36:51 <SPLOOCH> only in exceptional circumstances.
15:37:32 * hackagebot configuration-tools 0.2.4 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.4 (larsk)
15:38:53 <SPLOOCH> and you can be suspended during computation too. out of your control really.
15:41:55 <zmbmartin> Does anyone use the bcrypt library. I followed the exact example but I get a Nothing returned all the time.
15:43:53 <shachaf> zmbmartin: Which example?
15:44:09 * shachaf notes that Crypt.BCrypt documentation uses Data.ByteString.Char8 :-(
15:44:20 <shachaf> This is exactly an example of a place where you shouldn't use that.
15:50:19 <zmbmartin> shachaf:  the example here - https://hackage.haskell.org/package/bcrypt-0.0.5/docs/Crypto-BCrypt.html
15:51:05 <shachaf> Please say (or hpaste.org) exactly what you did and exactly what happened.
15:53:51 <zmbmartin> http://lpaste.net/110120 <- Nothing was the result
15:54:11 <zmbmartin> shachaf: Any other library I should look at for password hashing?
15:55:09 <shachaf> bcrypt is probably fine -- just don't use Data.ByteString.Char8.pack (or Data.ByteString.Char8 in general), since it's Unicode-broken.
15:55:41 <shachaf> When I cabal install bcrypt and then run your program, it prints Just ..., not Nothing.
15:57:15 <zmbmartin> shachaf: weird i get Nothing
16:04:37 <Peaker> Having debugged some nasty concurrency/async-exceptions bugs, I'm coming to the realization that you want a really strong invariant that every Haskell thread is only ever sent a single async exception, and no more..  I don't think I've seen this ever mentioned, but without this invariant, all hell breaks loose
16:05:15 <Peaker> (or rather, that if you ever send another async exception, the thread receiving the exception is involved in a way that guarantees it completed handling the previous exception)
16:05:40 <Peaker> Having all your brackets/finally clauses get flooded with async exceptions is not fun!
16:06:31 <Peaker> Async's "link" seems like a great way to break this invariant and wreck havoc
16:06:49 <Peaker> Is it a good idea?
16:08:47 <merijn> Peaker: Eh, handlers for async exceptions should be run masked
16:09:02 <Peaker> merijn: masking doesn't help much
16:09:20 <Peaker> if you do a blocking operation in a mask, you're unmasked there
16:09:31 <Peaker> unless you do uninterruptibleMask, in which case you're almost guaranteed to cause a deadlock
16:09:48 <Peaker> merijn: imagine a simple use of withMVar -- if you double-throw at it, you break the mvar's invariant
16:09:59 <merijn> Peaker: ok, sure
16:10:16 <merijn> So don't do blocking operations in handlers ;)
16:10:25 <Peaker> so "withMVar" is broken? :)
16:10:51 <Peaker> there are plenty of cleanups you need to do that block
16:10:58 <merijn> Peaker: Yes
16:11:02 <Peaker> I think this is a big hole in Haskell concurrency folklore
16:11:12 <merijn> There's "atomicWithMVar" or something, isn't there?
16:11:36 <Peaker> are you thinking of atomicModifyIORef?
16:12:24 <Peaker> I'm thinking of wrapping my threads with an only-once kill protection, and have killers go through that
16:12:47 <Peaker> alternatively, have designated "parents" to threads and only parents are allowed to kill children, and exactly once
16:14:05 <merijn> Peaker: I have a neat trick with two threads that depend on eachother and have to kill eachother when they die
16:14:17 <merijn> I'll paste it in a sec
16:14:20 <Peaker> merijn: that's fine, I think, as long as they're the only killers
16:14:31 <Peaker> the problem arises when there are multiple potential assasins
16:15:12 <merijn> Peaker: Put the "kill" throwTo in an MVar, have potential killers do "tryTakeMVar" if success, execute the IO throwTo, if failure, disregard?
16:15:51 <Peaker> merijn: yeah, except I prefer atomicModifyIORef to MVar
16:16:01 <Peaker> for whatever I can (and this can)
16:16:21 <Peaker> otherwise I'm exposed to another issue where the mvar handling is itself attacked
16:16:34 <Peaker> (also I am pretty sure atomicModifyIORef is faster, and it's not really harder to use correctly)
16:17:12 <Peaker> I think MVar is more useful for synchronizing sleeps/wake-ups, for content sync, atomicModifyIORef is excellent
16:17:48 <WraithM> Is there an io-streams aeson library?
16:19:55 <Peaker> these issues manifests as really annoying deadlocks in my Haskell build system :(
16:24:13 <rlts> hey friends, new to haskell and can't get my toy to work, not sure what i'm doing wrong in the list comprehension:
16:24:38 <rlts> let lineTest x = [3*a+1 | a <- [1..], 3*a+1 <=x] is the function. it stalls out in ghci when i think it should stop.
16:25:04 <shachaf> Why do you think it should stop?
16:25:26 <Dre3ml0rd> [1..]
16:25:31 <Dre3ml0rd> whats that going to achieve?
16:25:48 <rlts> my intuition is that the predicate (?) should make it stop when 3a+1 <= x
16:25:56 <gaze__> Hey what's this '[...] syntax. Type lists? Where's it documented?
16:25:58 <edwardk> > take 10 [1..]
16:26:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:26:09 <edwardk> > filter even [1..]
16:26:10 <levi> rlts: A guard doesn't stop the sequence; it just eliminates candidates from the result.
16:26:10 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
16:26:18 <shachaf> rlts: You're asking for all values a in [1..] such that 3*a+1 <= x
16:26:19 <edwardk> Dre3ml0rd: works fine
16:26:44 <Dre3ml0rd> edwardk: I just can't understand it in the context
16:26:45 <edwardk> Dre3ml0rd: the idea here is you can talk about infinitely large structures in haskell all day long so long as you only inspect a finite portion of them
16:27:02 <Dre3ml0rd> but the statement doesn't take a finite portion
16:27:06 <Dre3ml0rd> Maybe it does I can't tell
16:27:17 <shachaf> rlts: That's a lot of values to test.
16:27:21 <edwardk> Dre3ml0rd: if you did that at the repl it'd keep printing forever
16:27:22 <rlts> hmm, so should it instead be [1..3*x+1]?
16:27:24 <levi> rlts: Consider how you'd write a list comprehension with a guard that returned all even numbers. If it stopped at the first odd number, it wouldn't be very useful.
16:27:30 <edwardk> doing it here in IRC lambdabot truncates after a while
16:27:35 <shachaf> > [x | x <- [1..], even x] -- compare
16:27:36 <merijn> rlts: No, guards are filters
16:27:36 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
16:27:46 <Dre3ml0rd> edwardk: ok thanks got it
16:28:01 <merijn> rlts: What you want relies on GHC being able to prove that "3*a+1" will never be smaller than 'x' after a certain amount of time
16:32:54 <augur> anyone have experience using haskell libs in xcode?
16:33:43 <tulcod> nh2: wow timing, i was just looking if you were in this channel
16:36:14 <rlts> well, i've kludged it to the following, can anyone offer (basic) improvements?
16:36:20 <rlts> "let lineTest x = [3*a+1 | a <- [1..ceiling ((x-1)/3)]]"
16:36:57 <shachaf> I wouldn't use a list comprehension. They are overrated.
16:37:07 <shachaf> > takeWhile (<5) [1..] -- this function is useful
16:37:07 <nh2> tulcod: what's up? :)
16:37:09 <lambdabot>  [1,2,3,4]
16:37:59 <shachaf> How about something like: lineTest x = takeWhile (<= x) . map (\a -> 3*a+1) $ [1..]
16:38:37 <tulcod> nh2: saw you started looking into my wayland libraries. just wanted to tell you 1. i figured out the KeyboardListener bug, will think about a solution, and 2. if you have any feedback, it's most welcome
16:39:01 <rlts> shachaf: was about to suggest something similar (takewhile with lambda) but i need to read up on map again, hah. thanks
16:39:15 <tulcod> nh2: (the KeyboardListener thing is definitely a bug on my end)
16:39:33 <tulcod> nh2: (i'd love feedback on API design)
16:39:44 <shachaf> > [4,7..] -- another way
16:39:45 <lambdabot>  [4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79...
16:39:47 <tulcod> nh2: (e.g. would it be worth binding to reactive-banana or something like that?)
16:40:14 <rlts> wow, now i feel really dumb
16:49:11 <merijn> So, is there any papers on languages that mix lazy and strict evaluation?
16:49:24 <coppro> like haskell?
16:52:24 <MrBff> m
16:56:49 <merijn> coppro: Haskell doesn't mix lazy and strict
16:57:48 <monochrom> "how to be lazy without even being odd" is such a paper
16:57:55 <nh2> tulcod: ah, awesome that you found the bug. I can't give feedback on the API yet, first have to build a bit more with it
16:57:59 <merijn> You can use seq to selectively force something to whnf, but that's not what I mean
16:58:09 <merijn> monochrom: Ah, thanks :)
16:58:19 <merijn> Also, how our FP academics so witty? >.>
16:58:23 <monochrom> err, how to add laziness to a strict language
16:58:25 <nh2> tulcod: I'm also new to wayland style programming, so I can't tell yet if I like the wayland way of doing things or not
16:58:54 <monochrom> Phil Wadler is the culprit of popularizing pun titles
16:58:58 <tulcod> nh2: well primarily i'd like to write something that makes sense from a haskell point of view
16:59:06 <monochrom> "linear types can change the world!"
16:59:15 <tulcod> although there will be some areas (such as the wl_registry.global event stuff) that will be tough from that perspective
16:59:27 <monochrom> "comprehending monads" refers to monad comprehension
17:00:00 <shachaf> I prefer monochrom comprehensions.
17:00:04 <monochrom> "monads for functional programming" is an exceptionally boring title from Wadler
17:02:45 * hackagebot simple-sendfile 0.2.16 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.16 (KazuYamamoto)
17:04:43 <tulcod> nh2: anyway, nice to see that i didn't write it quite for nothing, so thanks :)
17:13:56 <athan> Is it smart to make an array of arrays, for a 2d matrix?
17:14:51 <MrBramard> You can use 2 vectors for more flexibility i think
17:15:31 <MrBramard> don't know in what language you're coding
17:16:15 <merijn> Eh, since this is #haskell presumably it's haskell?
17:16:36 <dmj`> how do I install test dependencies only
17:16:47 <augur> who does Platform again? i forget
17:17:07 <Clint> augur: mzero i think
17:17:12 <augur> yes! thats it
17:18:05 <augur> @ask mzero can we figure out a way to get Platform to include an Xcode framework for haskell so that using haskell in an Xcode project is nearly trivial
17:18:05 <lambdabot> Consider it noted.
17:18:26 <merijn> I thought there was already a way to build frameworks using cabal
17:18:55 <augur> merijn: what i mean is, getting haskell _into_ xcode seems to be a pain in the ass
17:19:04 <augur> a number of people have remarked over the last few years that its really obnoxious
17:19:38 <augur> the haskell site has a "tutorial" that basically says "run through your linker errors and import every possible file into your project that it cant find"
17:20:10 <augur> jfischoff tried something similar two years ago, and maybe eventually found a simpler solution, but its not clear that it was the one he mentioned in channel
17:20:52 <augur> so im going to poke him and figure it out, and i want to work with mzero to get it made part of the default OS X install so that this crap is never an issue ever again
17:22:48 * hackagebot simple-sendfile 0.2.17 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.17 (KazuYamamoto)
17:23:45 <sm> lately I very often get "Unhandled argument, none expected: ARG" when I run :main ARG in ghci. Changing a module and :reload fixes it temporarily. Would anyone know the cause ?
17:27:37 <tabemann> sm: that error seems to be generated by cmdargs
17:29:20 <sm> tabemann: aha, thank you. How did you find that out ?
17:29:57 <tabemann> http://stackoverflow.com/questions/22001726/cmdargs-value-arguments-without-equals-sign
17:30:52 <sm> thanks! my google fu is weak today
17:32:29 <merijn> augur: Why are you trying to get haskell into xcode? That doesn't seem to make any sense?
17:32:38 <merijn> augur: What does "getting haskell into xcode" even mean?
17:32:41 <augur> merijn: *sigh*
17:32:48 <augur> merijn: i made a library in haskell
17:33:04 <augur> that is supposed to be called from C, for an ObjC project im doing
17:33:09 <merijn> ok
17:33:28 <augur> but that requires me to start up the haskell runtime in the C code, which requires me to import some junk
17:33:33 <merijn> So, compile your haskell library and add the resulting library into xcode?
17:33:40 <augur> merijn: doesnt work
17:34:35 <merijn> augur: Although the easier solutions is probably to make the C/ObjC part the library and add that to cabal
17:35:22 <augur> merijn: that be an option if cabal knew how to do what i need it to do, which afaik it doesnt
17:35:35 <merijn> augur: And what is it that you need it to do?
17:35:53 <augur> merijn: i need it to be able to create ObjC frameworks
17:36:13 <merijn> Why does cabal need to do that?
17:36:22 <merijn> It can just link against whatever framework you have, no?
17:36:44 <augur> look, im making an ObjC framework, right
17:36:57 <augur> a wrapper around a haskell library
17:37:15 <augur> the only way i know of that makes sense is Haskell -> C/ObjC
17:37:43 <merijn> Why is that the only way that makes sense?
17:37:55 <augur> i said the only way i know of that makes sense
17:38:01 <augur> if you know of another way, please, by all means share
17:38:43 <napping> Can anyone take a look at https://github.com/neothemachine/monadiccp/issues/9
17:38:59 <napping> as far as I can tell, t' has to be universally quantified there
17:39:03 <merijn> compile haskell to dynamic library, copy it + relevant header files into ObjC project, compile. The other way around is: Compile ObjC to dynamic library, copy that into cabal and build
17:39:25 <merijn> augur: Either way, you have to tell one of the two sides about the stuff on the other
17:39:37 <augur> the dynamic library in the Haskell->C direction doesnt load properly for mysterious/unknown reasons
17:40:34 <Sgeo> If I have a thing like addEventHandler :: IO () -> IO (IO ()) that will add an event handler, and I want to stream data via pipes or conduit, am I better off looking for a push-based streaming library, or is it fine to have the event handler fill some sort of STM queue or channel and pull-based stream from there?
17:40:36 <augur> the static library doesnt load for clear reasons -- haskell symbols are missing, and can be made un-missing by importing the right headers and junk
17:42:50 * hackagebot aws-performance-tests 0.1 - Performance Tests for the Haskell bindings for Amazon Web Services (AWS)  http://hackage.haskell.org/package/aws-performance-tests-0.1 (larsk)
17:45:42 <merijn> augur: Are you exporting the haskell symbols?
17:46:04 <augur> merijn: you mean using export in Haskell? yes
17:46:12 <merijn> foreign export, yeah
17:46:20 <augur> the problem is not those symbols, its core haskell junk
17:48:02 <merijn> I don't have enough info to debug that other than "works for me" (well, I'm using clang directly, not xcode, but I don't see how that could matter)
17:53:02 <augur> merijn: i know. this is why im asking if anyone knows xcode-integration specifically
17:53:21 <hakujin> merijn: which parts of your ios apps are haskell? the uikit pieces need objective-c yeah?
17:54:08 <augur> merijn: i dont know how i would do this any ObjC stuff without using xcode. its never come up before
17:54:21 <augur> so all of the errors im getting are probably xcode specific and its very mysterious
17:55:16 <merijn> augur: The thing is, nothing should be stopping xcode from just compile to a dynamic library either
17:55:27 <merijn> hakujin: I don't write ios apps
17:55:38 <merijn> hakujin: I just wrote C code on OSX that needed to call haskell
17:55:39 <augur> merijn: and yet. :)
17:56:08 <merijn> hakujin: I did some objective-c in the past, calling C from it is pretty trivial, calling haskell from objective-c should be just as easy
17:58:14 <hakujin> merijn: I'm just curious what a real-world use would be. the network layer? I assume the rts is alive and well so maybe forkIO and friends are nice.
17:58:46 <hakujin> my limited exposure to ios apps had the majority of the work wrestling with the presentation layer stuff and only a fraction doing any real work
17:59:03 <merijn> hakujin: I dunno, like I said, I don't do iOS :)
18:08:13 <vanila> does anyone remember that theorem about planar graphs where you add up the number of sides for each face?
18:09:04 <augur> vanila: euler's law?
18:09:34 <vanila> oh that was it!
18:27:55 * hackagebot tighttp 0.0.0.1 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.1 (YoshikuniJujo)
18:28:38 <trap_exit_> if I have a function of type A -> B, is "a__b" or "b__a" a beter name? "a__b" captures the order of the types ,however (b__a a) <-- easir to know that this returns a "b"
18:29:11 <vanila> I don't often see either of those used
18:29:35 <trap_exit> well, I have things like MathExpr, TexExpr, SvgDoc
18:29:46 <trap_exit> and I have functions which go MathExpr -> TexExpr, TexExpr -> SvgDoc
18:29:58 <trap_exit> and these functions are unique
18:30:08 <trap_exit> i.e. I really only have one function which is TexExpr -> SvgDoc
18:30:11 <trap_exit> and I only have one function which is MathExpr -> TexExpr
18:30:21 <trap_exit> so the functions are 'defined by their type signature'
18:30:25 <trap_exit> now I'm trying to figure out how to name them in a consistent way
18:30:45 <vanila> maybe bFromA or aToB would work
18:30:59 <trap_exit> right, and I thikn __ look sbetter than either From or To
18:31:09 <vanila> you could also make a typeclass "convert" that just picks the right one
18:31:12 <trap_exit> so I'm trying to think mathExpr__texExpr or texExpr__mathExpr
18:31:25 <vanila> well it's just that __ doesn't tell you what direction it's happening
18:31:27 <trap_exit> f*ck you
18:31:27 <trap_exit> that's brilliant
18:31:36 <trap_exit> that is so brilliant
18:32:07 <vanila> no problem  :)
18:32:28 <augur> i do believe theres already a type class for that?
18:32:34 <augur> something like Castable?
18:32:43 <augur> @hoogle a -> b
18:32:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:32:45 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:32:45 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:32:55 <augur> guess hoogle doesnt know about it :(
18:33:37 <trap_exit> wait wait
18:33:46 <trap_exit> how do I use castable, and how does it relate to $ ?
18:33:48 <dfeuer_> augur, you're thinking about Coercible
18:33:55 <augur> it doesnt, trap_exit_
18:33:56 <trap_exit> I've used $ before, but not in the context of casting stuff around
18:33:58 <augur> dfeuer_: ah is that it?
18:34:01 <dfeuer_> Coercible is for safe coercions.
18:34:05 <augur> trap_exit: its unrelated
18:34:08 <augur> uts not*
18:34:18 <augur> trap_exit: pay no mind to lambdabot's answer
18:34:19 <geekosaur> trap_exit, that was just hoogle being a bit enthusiastic about similar type signatures
18:34:33 <trap_exit> actually, I probably don't want a single tyhpecass "convert"
18:34:39 <dfeuer_> unsafeCoerce is one of the fundamental *unsafe* operations, like unsafePerformIO.
18:34:40 <trap_exit> I probalgy want to__svgDoc and to__texExpr
18:34:58 <trap_exit> okay' this all makes sense
18:34:58 <trap_exit> time to code
18:34:58 <trap_exit> thanks all
18:38:17 <haasn> augur: Coercible is for a specific type of coercion
18:38:31 <haasn> Suggesting it for something that we don't know as anything other than “A -> B” seems misleading
18:38:35 <augur> ok
18:38:41 <haasn> Also, I don't think you can write your own Coercible instances
18:38:43 <haasn> Can you?
18:39:04 <haasn> (To clarify, Coercible is for cases where unsafeCoerce is safe. The semantics of Coercible is unsafeCoerce)
18:39:27 <haasn> “Coercible a b” means “a and b have the same internal representation”
18:39:37 <augur> ok
18:39:37 <shachaf> Funny to call unsafeCoerce "semantics".
18:39:48 <haasn> From the documentation: “Trying to manually declare an instance of Coercible is an error.”
18:40:25 <haasn> shachaf: Maybe “runtime behavior”​ would be better?
18:40:45 <merijn> "operational semantics"
18:46:32 <augur> merijn: the error im getting when i use the dylib is
18:46:36 <augur> dyld: Library not loaded: @rpath/libHSlanguage-engine-0.1.0.0-ghc7.8.3.dylib
18:46:37 <augur>   Referenced from: /Users/darryl/Library/Developer/Xcode/DerivedData/LanguageEngine-ekanoczhjhecnofdjtlsjcxdyqqk/Build/Products/Debug/LanguageEngine.app/Contents/MacOS/LanguageEngine
18:46:38 <augur>   Reason: image not found
18:46:40 <augur> (lldb)
18:47:19 <augur> merijn: which is mysterious, and not clear to me. the lib is in my project dir, but xcode just isnt seeing it for some unknown reason
18:50:25 <Arr_> http://lpaste.net/110122  How can I let >>= return on the first Just result, i.e. calling next function only when the previous is Nothing?
18:51:23 <shachaf> I'm not entirely sure what you mean, but I think the answer is that you can't. That's not the behavior of (>>=).
18:51:46 <Denommus> hi
18:51:47 <vanila> Arr_, that wouldn't be monad (>>=), instead you could make a list of the things and use msum on it
18:51:54 <vanila> > msum [Nothing,Nothing,Just 1, Just 3, Nothing]
18:51:55 <lambdabot>  Just 1
18:51:58 <vanila> hi
18:53:03 * hackagebot conduit 1.2.0.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.0.1 (MichaelSnoyman)
18:54:38 <jmcarthur> Arr_: what value could it pass to the next function?
18:54:42 <Arr_> I don't have to use >>=, what the common pattern to chaining a series functions like a -> m a, and return early?
18:55:25 <jmcarthur> Arr_: maybe you actually want the (Either e) monad? it stops on the first Left.
18:55:28 <Denommus> how to make a single element tuple?
18:55:45 <merijn> Denommus: There's no such thing
18:55:57 <merijn> Denommus: And it doesn't really make sense either
18:56:01 <Arr_> jmcarthur : thanks!
18:56:10 <Denommus> merijn: oh
18:56:13 <shachaf> Arr_: I think an example might help with asking your question.
18:56:28 <shachaf> merijn: It makes sense, except syntactically.
18:56:42 <merijn> shachaf: What is a single element tuple, then?
18:57:09 <merijn> Sure, you get an extra box to hide an undefined, but that doesn't seem very worthwhile?
18:57:19 <Sizur1> @pl f a = b * c $ d/e*g/h
18:57:19 <lambdabot> f = const (b * c $ d / e * g / h)
18:57:26 <shachaf> I don't know about worthwhile.
18:57:33 <Arr_> shachaf: actually I am dealing with a Scala problem, I have  a group functions of type: String -> Maybe String, I want to call the next only when the previous returns nothing
18:57:44 <Sizur1> @pl f a = b * c $ d/e*a/g
18:57:44 <lambdabot> f = (b * c) . (/ g) . ((d / e) *)
18:57:55 <shachaf> I don't think (Either e) will help you here.
18:58:03 * hackagebot conduit 1.2.0.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.0.2 (MichaelSnoyman)
18:58:06 <chrisdotcode> :t msum
18:58:06 <lambdabot> MonadPlus m => [m a] -> m a
18:58:13 <shachaf> merijn: I don't like cutting off an easy generalization just because it doesn't seem worthwhile.
18:58:24 <qrada__> yo
18:58:26 <qrada__> oops
18:58:44 <shachaf> There are n-tuples for all n other than 1. And we know what a 1-tuple would be. So it makes sense to have it.
18:59:01 <shachaf> If not for the data/newtype distinction, we could use it instead of Data.Functor.Identity, which is very useful.
19:00:57 <glguy__> :t \fs x -> catMaybes [f x | f <- fs]  -- given that it doesn't look like an example is going to be provided, here's a guess
19:00:58 <lambdabot> [t -> Maybe a] -> t -> [a]
19:01:19 <glguy__> oh, well, first of that <_<
19:02:40 <vanila> > msum [Nothing,Nothing,Just 1, Just 3, Nothing]
19:02:42 <lambdabot>  Just 1
19:02:47 <glguy__> :t \fs x -> msum [f x | f <- fs]
19:02:48 <lambdabot> MonadPlus m => [t -> m a] -> t -> m a
19:05:00 <Arr_> glguy: do fs need to be all evaluated? I want it stops on first "Just a" and the following functions doesn't even need to be computed.
19:05:33 <glguy__> Thanks to non-strict evaluation, that's not an issue here
19:05:48 <Sizur1> @pl f a = b * c $ d/e*a/b
19:05:48 <lambdabot> f = (b * c) . (/ b) . ((d / e) *)
19:06:44 <Arr_> glguy__: thanks, let me try to experiment using Scalaz.
19:06:53 <Sizur1> @pl f b a = b * c $ d/e*a/b
19:06:53 <lambdabot> f = liftM2 (.) (c *) (flip ((/) . ((d / e) *)))
19:07:20 <glguy__> Sizur1: If you need somewhere to explore ?pl you can use /msg
19:07:36 <Sizur1> sorry, will do
19:08:38 <Sizur1> glguy__: thank you, i did not even think about that...
19:08:45 <glguy__> You're welcome :)
19:10:09 <MattEZQ> coming from javascript, what's the best resource for getting my head around typeclasses? I'm about halfway through learnyouahaskell
19:10:26 <coppro> MattEZQ: you've gotten to the section on typeclasses?
19:10:49 <MattEZQ> yeah, but then the next section when it goes back kinda blows my mind
19:12:01 <MattEZQ> I it's the part where it gets into curried functions that I'm not getting
19:12:37 <MattEZQ> I think I sorta get the currying part, but I don't really understand the basic types that well
19:12:56 <monochrom> then it is not a typeclass problem, it's a currying problem.
19:13:24 <monochrom> you can get used to currying by more practice
19:13:49 <monochrom> it also helps to always calculate types
19:14:02 <Sizur1> i did not know about Ghci on Acid!  so awesome!
19:14:21 <glguy__> MattEZQ: Do you have an example of something you're struggling with?
19:14:33 <hakujin> MattEZQ: an example will help us help you
19:14:35 <hakujin> ^
19:14:47 <MattEZQ> yeah 1 sec, ty
19:16:48 <MattEZQ> so on http://learnyouahaskell.com/higher-order-functions#curried-functions
19:17:11 <MattEZQ> where it has multThree :: (Num a) => a -> a -> a -> a
19:17:32 <MattEZQ> I don't really understand the relationship between (Num a) => and the rest
19:17:58 <geekosaur> it limits what types a can be
19:18:02 <MattEZQ> specifically the part in the parens
19:18:07 <augur> merijn: i should add, its a runtime error, i think
19:18:20 <geekosaur> :t id
19:18:21 <lambdabot> a -> a
19:18:25 <geekosaur> a can be anything
19:18:28 <geekosaur> :t (+)
19:18:29 <lambdabot> Num a => a -> a -> a
19:18:41 <geekosaur> a must be a type for which an instance of Num exists
19:19:00 <geekosaur> > id "c"
19:19:02 <lambdabot>  "c"
19:19:11 <geekosaur> > (+) "c" 5
19:19:12 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
19:19:13 <lambdabot>    arising from a use of ‘GHC.Num.+’
19:20:32 <glguy__> There are a few types that satisfy the "Num" constraint: Integer, Int, Float, Double, Rational, etc.
19:20:43 <glguy__> but [Char] (list of Char) aka String isn't one of them
19:21:04 <MattEZQ> what about when you see something like (Num a, Ord a)? I take this to mean something that is a number and also able to be ordered. That seems redundant to me?
19:21:13 <geekosaur> it's not redundant
19:21:15 <MattEZQ> but when I try to just use Num it fails
19:21:18 <geekosaur> complex numbers have no ordering
19:21:33 <shachaf> Well, no canonical ordering.
19:21:53 <geekosaur> that is, you cannot say which of 4+3i or 3+4i is "smaller", because conceptually it's 2-dimensional while Ord is 1-dimensional
19:22:45 <shachaf> There are other conceivable Num instances which are even more problematic to order.
19:23:01 <MattEZQ> is that why the book tends to use RealFloat?
19:23:06 * hackagebot persistent 2.0.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.0 (MichaelSnoyman)
19:23:08 * hackagebot persistent-mongoDB 2.0.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.0 (MichaelSnoyman)
19:23:10 * hackagebot persistent-mysql 2.0.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.0.0 (MichaelSnoyman)
19:23:12 * hackagebot hsenv 0.5 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/hsenv-0.5 (TaylorHedberg)
19:23:14 * hackagebot persistent-postgresql 2.0.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.0 (MichaelSnoyman)
19:23:23 <geekosaur> Haskell being widely used for math, Complex comes with the standard ecosystem and there are even higher order numbers (quaternions, octonions, etc.) on Hackage
19:23:41 <geekosaur> and various numeric "laws" that you're used to fall apart as you move up the order
19:25:48 <MattEZQ> ok, so when I'm defining a function as foo (Ord a, Int a) => a ->a, I just make sure that I include the types with the properties I need in the parens?
19:26:03 <geekosaur> they're not types, they're type classes
19:26:04 <dfeuer_> I'm confused. There's a Crypto directory in nofib/fibon/Hackage, but I can't figure out how to get benchmark results from anything there.
19:26:16 <dfeuer_> I'd like to, because that's the only place I see unfoldr.
19:26:40 <geekosaur> in practice, the typeclasses say what operations you can use
19:26:57 <MattEZQ> what is the difference between a type and a typeclass?
19:27:04 <geekosaur> Ord allows use of comparisons other than == and /=; those being more fundamental, they're in a different typeclass, Eq
19:27:07 <glguy__> MattEZQ: Types might or might not be "instances" of a typeclass, Int is not a typeclass, so it doesn't go on the left side of the => like that
19:27:13 <geekosaur> Num allows use of (+) and a handful of other things
19:27:35 <geekosaur> but not all numeric operations; you need Fractional for (/), for example
19:28:16 * hackagebot persistent-sqlite 2.0.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.0.0 (MichaelSnoyman)
19:28:18 * hackagebot persistent-template 2.0.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.0 (MichaelSnoyman)
19:28:37 <benzrf> well..
19:28:39 <benzrf> .
19:28:51 <benzrf> @let foo :: Num Int => String; foo = "regular string"
19:28:53 <lambdabot>  Defined.
19:28:55 <benzrf> :t foo
19:28:56 <lambdabot> String
19:29:04 <geekosaur> that's a ghc bug, isn't it?
19:29:07 <benzrf> is it?
19:29:18 <glguy__> benzrf: That doesn't particularly help
19:29:38 <geekosaur> I believe so, it's supposed to complain that you didn't use a type variable, but 7.6.3 gets it wrong
19:29:50 <geekosaur> (possibly also other versions)
19:29:53 <MattEZQ> so Int is an instance of Num? and I guess Float etc would also be instances of Num?
19:29:58 <geekosaur> yes
19:30:14 <geekosaur> Float is also an instance of some other numeric typeclasses that add operations like (/) and sin
19:30:33 <geekosaur> you can use :info in ghci (but not in lambdabot) to see what typeclasses ghc knows a type to be in
19:30:36 <MattEZQ> and the Num typeclass instantiates the other types appropriately
19:30:46 <geekosaur> (this can change based on imports that bring typeclass instances into scope)
19:30:54 <Sizur1> well well, I am not "chris", that's for sure:
19:30:54 <Sizur1> Prelude GOA> :pl a = a
19:30:55 <Sizur1> *** Exception: /home/chris/.cabal/bin: changeWorkingDirectory: does not exist (No such file or directory)
19:32:03 <Sizur1> type-safety type-shmanfety
19:32:05 <geekosaur> Sizur1, I think you may have missed a configuration string somewhere that needed to be changed
19:32:06 <protein-jesus> Is there a fix for this State behavior https://github.com/yaccz/code-snippets/blob/master/haskell/state-monad-incrementor-with-IO/main.hs#L30 ?
19:32:22 <MattEZQ> I will work on this for a bit. Thanks!
19:32:30 <geekosaur> type safety goes only so far, since the OS doesn't provide a truly type safe interface to the filesystem :)
19:32:34 <Sizur1> geekosaur: whoops!
19:32:57 * geekosaur does kinda wonder if one could be written for, say, VMS
19:33:08 * hackagebot persistent 2.0.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.0.1 (MichaelSnoyman)
19:33:10 * hackagebot persistent-mongoDB 2.0.0.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.0.1 (MichaelSnoyman)
19:33:12 * hackagebot persistent-sqlite 2.0.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.0.0.1 (MichaelSnoyman)
19:33:14 * hackagebot persistent-template 2.0.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.0.1 (MichaelSnoyman)
19:33:29 <glguy__> protein-jesus: You'll have to tell us what you expected to happen and what didn't
19:33:59 <geekosaur> also I suspect it'd require dependent types so you'd still lose :p
19:34:21 <protein-jesus> glguy__: should be obvious from the comment?
19:35:03 <protein-jesus> glguy__: Now it behaves as expected from the outside. However, I'd like it to work this way without the extra `s2 <- get` business
19:35:24 <geekosaur> afaik that's not a bug; if foo mutates the state, then you need the new state
19:35:31 <Sizur1> what's the issue with installing lambdabot deps errors? is that known?
19:35:41 <geekosaur> also note that State is not *true* state; `s` is not magically a global variable
19:35:53 <protein-jesus> as it seems very fragile to refactoring/moving codelines around
19:36:02 <Sizur1> http://pastebin.com/iiNfbiYa
19:36:14 <protein-jesus> geekosaur: I understand why it works this way. I just expect a better solution to this to exist
19:36:37 <glguy__> protein-jesus: You shouldn't be using get/put everywhere
19:36:48 <glguy__> protein-jesus: Write the operation you need somewhere in terms of get/put somewhere
19:36:52 <glguy__> and then call that
19:37:04 <geekosaur> also I think that wants to be modify, which would fix it in this case
19:37:21 <glguy__> inc n = modify (\s -> s { count = count s + n })
19:37:29 <geekosaur> since it would operate on the current state, not the state you saved out of it
19:38:00 <NemesisD> hey guys, my brain is dragging today. I want something like (r -> r') -> ReaderT r m a -> ReaderT r' m a, but withReaderT is backwards. is it possible to write this function
19:38:09 * hackagebot interpolate 0.0.4 - String interpolation done right  http://hackage.haskell.org/package/interpolate-0.0.4 (SimonHengel)
19:38:41 <glguy__> and currentCount = gets count
19:38:54 <glguy__> and then only use those two operations. State is just a tool, not a recommendation
19:41:34 <protein-jesus> geekosaur: right. nice
19:42:22 <protein-jesus> glguy__: oooooooh, nice
19:44:20 <augur> anyone have experience using haskell in Xcode?
19:48:10 * hackagebot tighttp 0.0.0.2 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.2 (YoshikuniJujo)
19:58:11 * hackagebot linearEqSolver 1.3 - Use SMT solvers to solve linear systems over integers and rationals  http://hackage.haskell.org/package/linearEqSolver-1.3 (LeventErkok)
20:06:52 <augur> how do i switch to a new cabal config?
20:10:32 <augur> also, after installing the new haskell platform, cabal is now complaining   cannot satisfy -package-id mtl-2.1.3.1-8bcc0591131896cfc8761a93703d4c61
20:11:11 <augur> what does this mean and how can i make cabal just build?
20:11:51 * dfeuer_ wonders again if someone here knows more about running nofib than the GHC wiki.
20:12:11 <geekosaur> #ghc might be a better place to ask
20:12:27 <dfeuer_> OR alternatively someone who has an idea for a benchmark to test unfoldr performance.
20:12:48 <dfeuer_> Because it appears that the current unfoldr is so bad that no one even uses it.
20:13:11 <geekosaur> I am under the impression unfoldr isn't used because its interface is annoying
20:13:46 <geekosaur> there used to be regular requests on -cafe for alternatives, some years back
20:14:18 <dfeuer_> geekosaur, it's mildly annoying, perhaps, but the painful thing is that it currently allocates a bunch of Just constructors, and then doesn't fuse with whatever consumes the list it generates.
20:14:36 <dfeuer_> So it allocates absolutely like mad.
20:17:11 <augur> i just re-inited the project and cabal is still complaining about mtl
20:17:13 <augur> :(
20:17:57 <dfeuer_> Oh nowwwww I see.
20:18:56 <dfeuer_> nofib/fibon is actually a completely different benchmark suite, from 2010. Figuring out how to run it looks a little more challenging.
20:19:08 <flufflel> can someone recommend a good time series database/solution for storing and querying time-indexed data that has good haskell support?
20:22:20 <flufflel> has anyone worked with hdf5 + haskell?
20:28:15 <dfeuer_> geekosaur, the nice thing is if we fix those performance problems with unfoldr, then it becomes a fairly general-purpose "good producer", to go along with existing good transformers (map, filter, take, [soon, hopefully] takeWhile), and good consumers (foldr, foldl, sum, and, or, any, ...)
20:28:25 * dfeuer_ goes.
20:31:45 <KnightT> putStrLn "Hell World"
20:32:19 <KnightT> *hello ..
20:32:56 <KnightT> Just compiled my first haskell program.. was awesome
20:38:18 * hackagebot hspec-wai 0.3.0.1 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.3.0.1 (SimonHengel)
20:43:33 <glguy> Nemesisd no, you can't run the function "backwards"
20:45:01 <Fuuzetsu> damn, I would love to know how to go Bool -> a!
20:48:10 <MattEZQ> couldn't you do something like foo x | x == False = "string" | x == True = 1
20:48:11 <augur> how do i make cabal shut up about satisfying mtl? :(
20:48:30 <Fuuzetsu> sandbox everything
20:48:33 <Fuuzetsu> everything ever
20:48:39 <vanila> MattEZQ, that's a type error
20:48:49 <augur> Fuuzetsu: im not sure how thats going to help this but
20:48:50 <augur> ok how
20:49:03 <Fuuzetsu> ;P
20:49:06 <Fuuzetsu> what's your problem?
20:49:11 <MattEZQ> haha it's always a type error im not very good at this
20:49:29 <augur> Fuuzetsu: cannot satisfy -package-id mtl-2.1.3.1-8bcc0591131896cfc8761a93703d4c61
20:49:46 <Fuuzetsu> doesn't that mean it's fucked
20:50:04 <geekosaur> MattEZQ: a function can have one return type. typeclasses don't change this and can actually limit it more, because (a) the caller chooses the type (b) you cannot find out what type they chose
20:50:07 <merijn> hashes are never good
20:50:27 <merijn> augur: Have you used --force-reinstall in the past?
20:50:41 <augur> merijn: no, but i just tried and it doesnt change anything
20:50:49 <Fuuzetsu> don't try ;P
20:50:54 <geekosaur> that error says to me that you have somewhere a package which was built against a specific (binary, hence the hash) version of mtl
20:51:05 <geekosaur> and you need to find that and remove and possibly reinstall it
20:51:25 <Fuuzetsu> it's pretty comfy here in the nix laand
20:51:27 <Fuuzetsu> land*
20:51:55 * Fuuzetsu is trying to assimilate #haskell into #nixos
20:52:01 <MattEZQ> haskell has so many rules! I'm used to javascript where there are hardly any rules at all.
20:52:15 <MattEZQ> it's good tho!
20:52:29 <Fuuzetsu> oh no, JavaScript has a lot of rules
20:52:32 <merijn> augur: You should never try --force-reinstall
20:52:34 <vanila> MattEZQ, yeah it keeps you honest
20:52:36 <Fuuzetsu> the difference is that it's not obvious when you break them
20:52:36 <geekosaur> they;re just different rules
20:52:40 <merijn> augur: It will silently corrupt and break your stuff
20:52:46 <merijn> Hence my question
20:52:58 <augur> merijn: well like i said, i didnt do it until after the error showed up
20:53:09 <augur> merijn: i just installed the new platform and thats what broke things
20:53:41 <merijn> Did you clean up the old stuff before installing?
20:53:43 <MattEZQ> @Fuuzetsu I feel like JS is quite a bit more lenient than most other languages
20:53:43 <lambdabot> Unknown command, try @list
20:54:01 <augur> merijn: right after, i did remove-hs or whatever it is
20:54:06 <Fuuzetsu> yes, it makes it easy to write broken prograams
20:54:08 <Fuuzetsu> programs*
20:54:14 <geekosaur> JS happily pushes your type errors off until runtime
20:54:29 <MattEZQ> yeah for sure. it's so easy to write broken code
20:54:33 <merijn> hmm
20:54:34 <geekosaur> Haskell happily forces them to happen at compile time so you can find and fix them more easily
20:54:54 <merijn> "Foo -> Either e ()" seems like a silly type for errors
20:55:04 <merijn> Is there anything more sensible? Maybe feels wrong
20:55:36 <Fuuzetsu> Either e a is pretty much the standard isn't it
20:55:38 <haasn> I think it's silly because of the ()
20:55:46 <haasn> Not because of the Either e
20:55:50 <merijn> Fuuzetsu: Yes, but the return type I have is ()
20:55:56 <augur> geekosaur: how do i find this supposed binary version?
20:55:58 <merijn> That's what feels silly
20:56:03 <haasn> It looks like a function that can either do nothing, or.. fail doing nothing
20:56:16 <Fuuzetsu> perhaps make your type carry failure info
20:56:16 <merijn> Well, I guess it's IO (Either a ())
20:56:26 <Fuuzetsu> mhm
20:56:29 <merijn> But that still looks silly
20:56:34 <haasn> IO exceptions?
20:56:39 <merijn> haasn: No
20:56:48 <geekosaur> augur, afaik you use ghc-pkg list to find out the directories it's searching for installed packages, then grep in the package.conf.d/* files to find what's referring to that package-id
20:56:54 <Fuuzetsu> I pretend IO exceptions don't exist until they break my program
20:56:55 <merijn> I'm a firm believer the by default library/package APIs should not throw exceptions
20:57:55 <geekosaur> also make sure you don't have older ghc versions sitting around
20:58:15 <merijn> Well, I guess I could do "IO Bool" like "tryPutMVar" does
20:58:20 <geekosaur> since cabal can find them by accident and cause even more mayhem by trying to mix stuff built by / for different ghc versions
20:58:38 <Fuuzetsu> isn't that worse because you don't know what failed
20:59:05 <merijn> Fuuzetsu: I'm open to better suggestions
20:59:53 <Fuuzetsu> alias it to something nicer looking and stash it away where you can't see it
21:00:02 <merijn> I can't
21:00:17 <merijn> The function is part of my library's API
21:00:31 <Fuuzetsu> oh hm
21:00:57 <Fuuzetsu> sure am glad I'm not writing that library
21:01:16 <augur> geekosaur: is there a way to just wipe all of my haskell, and reinstall from nothing?
21:02:14 <merijn> Fuuzetsu: Basically I have a Chan like type with writes and need to signal errors if it fails for some reason
21:02:14 <geekosaur> the platform should come with an uninstall-hs script which looks for other ghc installations and with an option will remove them for you. stuff hanging around in package databases is your problem though
21:02:46 <augur> geekosaur: how can i wipe the package DBs
21:03:15 <geekosaur> "ghc-pkg list" tells you the directories to remove
21:03:41 <geekosaur> (the un-indented pathnames at the start of each output section)
21:04:55 <tabemann> merijn: what I'm doing with my current project is that (I'm using TChan), is that I package a TMVar with each message sent over the TChan which is written to to signal a response
21:05:12 <augur> geekosaur: do these contain core packages that haskell requires, or is it just additional stuff?
21:06:03 <augur> well, ill just wipe them, and haskell, and reinstall everything
21:06:10 <geekosaur> there are bootlibs and platform libs, yes; you'd need to reinstall the platform afterward. or clean up manually by finding and removing the bad package entries from package.conf.d and using "sudo ghc-pkg recache --global"
21:07:05 <Fuuzetsu> merijn: could you like make the user pass in a handler for the error
21:07:13 <Fuuzetsu> and if it doesn't error then don't call it
21:07:26 <Fuuzetsu> although I guess in the end the type is dumb anyway
21:07:35 <Fuuzetsu> and callbacks are rarely nice
21:08:01 <augur> i suspect this wont solve anything since the package dirs are all new from 7.8.3 but lets see just in case
21:08:24 * hackagebot mmorph 1.0.4 - Monad morphisms  http://hackage.haskell.org/package/mmorph-1.0.4 (GabrielGonzalez)
21:08:28 <MattEZQ> I.... I kinda like callbacks :)
21:08:56 <MattEZQ> i'm leavint
21:08:57 <MattEZQ> leaving
21:28:06 * dfeuer_ returns.
21:30:47 <augur> welp, that worked, geekosaur
21:30:51 <augur> complete wipe and reinstall :)
21:34:12 <dfeuer_> I just realized that the Ord instance for Bool is a nice thing for QuickCheck, because p < q demonstrates that p implies q.
21:34:37 <merijn> TQueue claims to be more efficient than TChan, anyone have any experience with how much the efficiency difference is and how the number of readers/writers impacts that?
21:35:05 <merijn> I'm assuming TQueue isn't always more efficient, because why keep TChan if it was...
21:35:56 <hakujin> merijn: also look at unagi-chan if perf is important and you're on x86 or x64
21:36:47 <Ralith> So how does one properly use 'cabal repl'? It doesn't seem to load any modules at all when I run it in my project.
21:36:53 <hakujin> http://hackage.haskell.org/package/unagi-chan-0.1.1.0
21:37:43 <merijn> hakujin: I need preemption, so I need to write my own queue type anyway, I'm just trying to figure out whether I should model mine on TQueue or TChan
21:37:51 <merijn> hakujin: Also, unagi-chan can't do STM :)
21:37:52 <dcoutts> Ralith: does your .cabal file list for your library/exe the modules that it contains?
21:38:26 <Ralith> oh, wait, I was in the wrong directory
21:38:27 <Ralith> nevermind!
21:38:29 * hackagebot pwstore-fast 2.4.2 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.4.2 (PeterScott)
21:38:31 * hackagebot pwstore-purehaskell 2.1.2 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.1.2 (PeterScott)
21:47:01 <protein-jesus> I have State monad combined with IO and now I want to pass it to forkIO
21:47:17 <protein-jesus> but it's not passing the typecheck as Alex () () is not IO ()
21:47:52 <merijn> protein-jesus: You'll have to run it
21:48:12 <merijn> protein-jesus: "forkIO $ runAlex myAction {- extra args here -}"
21:48:17 <protein-jesus> Alex s a = StateT (AlexState) IO a
21:48:18 <benzrf> @hoogle String -> ByteString
21:48:20 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
21:48:20 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
21:48:20 <lambdabot> Prelude error :: [Char] -> a
21:48:25 <benzrf> :\
21:48:51 <benzrf> oh wait
21:48:55 <merijn> benzrf: Data.Text.Encoding
21:49:13 <protein-jesus> merijn: it's already inside evalStateT
21:49:21 <protein-jesus> where would I get runAlex ?
21:49:27 <merijn> :t Data.Text.Encoding.encodeUtf8 . Data.Text.pack
21:49:29 <lambdabot> String -> BSC.ByteString
21:49:48 <merijn> protein-jesus: Well, presumably the "Alex () ()" has some way to run it, no?
21:50:04 <merijn> protein-jesus: You need a function "Alex () () -> IO ()" to run it in a thread
21:50:09 <protein-jesus> merijn: I just do evalState run (AlexState {})
21:50:35 <merijn> protein-jesus: Right, then you do "forkIO $ evalState run (AlexState {})"? :)
21:50:45 <benzrf> i assumed that the various ByteString versions made different kinds of bytestrings
21:50:56 <merijn> benzrf: There's only two bytestrings
21:50:59 <merijn> benzrf: Lazy and Strict
21:51:10 <merijn> benzrf: Well, that's a lie, there's also the special short bytestring
21:51:31 <merijn> benzrf: Char8 just has a pack function that silently truncates everything to ASCII (i.e., it's evil)
21:51:54 <protein-jesus> merijn: wouldn't that create a "new Alex monad" ?
21:52:13 <merijn> protein-jesus: Define "create a "new Alex monad""
21:52:17 <protein-jesus> I want those to share the state
21:52:22 <merijn> protein-jesus: Not possible
21:52:36 <protein-jesus> hrm
21:52:40 <merijn> protein-jesus: State is just a synonym for passing in extra arguments and returning extra values from a function
21:52:42 <benzrf> what is this Alex monad
21:52:51 <merijn> protein-jesus: They're immutable and only usable in a single thread
21:53:03 <merijn> protein-jesus: If you want communicating threads, look into Control.Concurrent
21:53:04 <protein-jesus> merijn: by share I mean to have `<- get` available
21:53:19 <merijn> protein-jesus: Right, you can't, you'll want IORef, MVar and friends
21:53:32 <protein-jesus> well those are lightweight threads so strict IPC shouldn't be neccessary
21:53:34 <merijn> protein-jesus: State just fakes mutable state, it isn't actual mutable state
21:53:45 <Fuuzetsu> I feel terrible whenever I use MVar &c
21:54:20 <merijn> protein-jesus: MVar and IORef provide *actual* mutable state (hence they require IO) and can be shared between threads (i.e. thread 1 can see updates made by thread 2)
21:54:22 <protein-jesus> merijn: right. So let's say I don't the state to mutate, it should work with the multiple monads via run
21:54:50 <protein-jesus> and then if I would want it to be shared/mutated I would need to implement some message passing between the [ThreadID] I have
21:54:54 <merijn> protein-jesus: If you don't mutate state, just do: "s <- get; forkIO $ runState run s"
21:55:22 <protein-jesus> ah, right, cool. Thanks
21:55:23 <merijn> protein-jesus: No, don't do "message passing between the [ThreadId]", use MVar or Chan :)
21:55:39 <merijn> Or the STM equivalents
21:57:34 <merijn> How do people here feel about long package names? Should package names be short or don't care?
21:58:13 <kvanb> please 5-10 characters
21:58:31 <merijn> I was thinking of "preemptible-fair-queues", but that seems a wee bit long :p
21:58:31 <kvanb> face it, we have to be able to spell them to put them in our cabal files
21:58:46 <kvanb> well, as long as it's a chain of rememberable words
21:59:33 <jle`> all the hip cool packages are two words or less
21:59:47 <jle`> it's some kind of unofficial convention
22:01:14 <Fuuzetsu> make it 81 characters long so no matter how hard people try, they can't have under 80C in their files
22:03:05 <merijn> jle`: Well, if you have any better suggestions, let me know :p
22:03:27 <jle`> merijn: preemptible-fairqueues
22:03:36 <merijn> >.>
22:03:44 <jle`> pf-queues
22:03:44 <Fuuzetsu> pfqs
22:04:28 <jle`> or come up with some unique branding
22:04:46 <jle`> skateboardz
22:14:19 <haasn> @freshname
22:14:19 <lambdabot> Hamy
22:16:37 <slack1256> I need to load ghc-mod to the ghci but it need the Paths_ghc_mod module which is generated by cabal by installation
22:16:50 <slack1256> How do I make it visible at module level?
22:17:50 <slack1256> no, basically I want to :load two different files without each other unloading the other
22:18:34 * hackagebot highlighting-kate 0.5.9 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.9 (JohnMacFarlane)
22:19:42 <slack1256> nevermind. I just needed :help to see my error
22:21:02 <qrada__> hi, i dont know how to use computers.. how od i find EVERY PACKAGE under Codec.Compression ? http://hackage.haskell.org/package/zlib-0.4.0.2/docs/Codec-Compression-GZip.html#v:decompress
22:21:06 <qrada__> for eample
22:21:29 <goorrff> What is "$" ?
22:22:05 <goorrff> specifically when used with case
22:22:14 <slack1256> goorrff: (f $ 2 +2) is equal to (f (2 + 2))
22:22:31 <slack1256> is just a way to avoid parenthesis because it function application with different associativity
22:22:53 <qrada__> i want to see every compression package avail under 'codec' because im adding them to some compression type class i made
22:22:56 <qrada__> ;f
22:24:01 <goorrff> :t ($) shows  ($) :: (a -> b) -> a -> b
22:24:02 <lambdabot>     Couldn't match type ‘[Char]’ with ‘a1 -> b1’
22:24:02 <lambdabot>     Expected type: ((a0 -> b0) -> a0 -> b0) -> (a1 -> b1) -> a1 -> b1
22:24:02 <lambdabot>       Actual type: ((a0 -> b0) -> a0 -> b0) -> ShowS
22:24:12 <goorrff> :t ($)
22:24:13 <lambdabot> (a -> b) -> a -> b
22:24:28 <goorrff> So it removes parens, not adds them
22:24:41 <slack1256> yep, let play a little with lambdabot shall we
22:24:54 <slack1256> :t ((+2) $)
22:24:55 <lambdabot> Num a => a -> a
22:25:10 <slack1256> :t ((*2) $)
22:25:11 <lambdabot> Num a => a -> a
22:25:18 <slack1256> :t ((*2) $) 5 + 3
22:25:19 <lambdabot> Num a => a
22:25:23 <slack1256> ((*2) $) 5 + 3
22:25:28 <slack1256> > ((*2) $) 5 + 3
22:25:30 <lambdabot>  13
22:25:41 <slack1256> > (*2) $ 5 + 3
22:25:42 <lambdabot>  16
22:25:48 <slack1256> > (*2) 5 + 3
22:25:49 <lambdabot>  13
22:25:59 <slack1256> check out the last two applications
22:26:21 <slack1256> is as if $ had put a parenthesis all the way to the right.
22:26:24 <goorrff> ok tks slack1256
22:26:37 <slack1256> no prob
22:26:39 <qrada__> ;f/win 3
22:26:41 <qrada__> ops
22:26:43 <qrada__> oops
22:28:37 <nilg> unwords with comma delimiter for Data.Text?
22:29:06 <shachaf> nilg: intercalate
22:29:54 <nilg> thanks :)
22:30:18 <nilg> I should have used hoogle... ;`)
22:30:58 <athan> Can any instance of Enum be used in a list-enum sytax, for comprehensions, like [1..8], etc?
22:31:18 <athan> ...and can you make circular enumerations? o.O
22:32:15 <jle`> athan: check out the desugaring of the enumeration syntax :)
22:32:24 <jle`> :t enumFrom
22:32:26 <lambdabot> Enum a => a -> [a]
22:32:30 <jle`> :t enumFromTo
22:32:31 <lambdabot> Enum a => a -> a -> [a]
22:33:31 <athan> jle`: Holeh crahp
22:33:54 <jle`> :t enumFromThen
22:33:55 <lambdabot> Enum a => a -> a -> [a]
22:33:59 <jle`> :t enumFromThenToo
22:34:00 <lambdabot>     Not in scope: ‘enumFromThenToo’
22:34:00 <lambdabot>     Perhaps you meant one of these:
22:34:00 <lambdabot>       ‘enumFromThenTo’ (imported from Prelude),
22:34:12 <athan> jle`: Thank you :)
22:34:21 <jle`> are there any Enum laws?
22:34:42 <augur> jle`: besides the equations, probably not
22:34:56 <athan> jle`: They would be similar to a monoid, wouldn't they?
22:35:55 <jle`> athan: how do you mean?
22:36:21 <jle`> hm. there doesn't seem to be any statement in the docs about non-Bounded Enums
22:36:34 <athan> enumerating itself being an embedded concatenation, jle`
22:36:38 <athan> wouldn't that be right?
22:36:56 <athan> eh...
22:37:09 <athan> I'll have to tinker with that
22:37:41 <nilg> well here (g|h)oogle don't help... how to get the OS carriage return Char or Text?
22:40:30 <nilg> I found it http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#t:Newline
22:40:42 <nilg> now I still have to understand how to use it...
22:41:28 <lpaste> DanZimm pasted “Halp” at http://lpaste.net/5514628507872788480
22:41:56 <DanZimm> Ok haskell gurus I've got a question referring to the above code snippet
22:43:10 <DanZimm> I'm trying to create a function (citer) which takes a function which maps R^2 -> R^2 and create a new function which composes the initial function with itself n times
22:43:52 <Enigmagic> DanZimm: like > citer f 0 = id
22:43:54 <Enigmagic> ?
22:43:58 <dpwright> I have a sort of design-y question I'm not sure quite how to express
22:44:02 <DanZimm> citer f 1 = id
22:44:04 <DanZimm> erm
22:44:07 <DanZimm> citer f 1 = f
22:44:14 <jle`> does lpaste bot finally work again
22:44:17 <jle`> hooray!
22:44:23 <dpwright> to do with extending sum types.   I'll start with some example code..
22:44:28 <DanZimm> and then citer f 2 = f (f)
22:44:29 <Enigmagic> DanZimm: what do you want it to do if n == 0 ?
22:44:32 <augur> @hoogle (a -> a) -> Int -> a -> a
22:44:33 <DanZimm> error
22:44:34 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
22:44:34 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
22:44:34 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
22:44:34 <lpaste> dpwright pasted “expressionExamples” at http://lpaste.net/110124
22:44:42 <augur> :t iterate
22:44:44 <lambdabot> (a -> a) -> a -> [a]
22:45:10 <augur> DanZimm: looks like youll have to write your own
22:45:24 <dpwright> in there I have an "Expression" type which is great, it's parameterised on the types and labels and it has various kinds of expressions
22:45:29 <augur> iterateN f 0 = id ; iterateN f n = f . iterateN f (n-1)
22:45:45 <phadej> :t foldr ((f :: Int -> Int) .) id
22:45:46 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘a0 -> a0’
22:45:47 <lambdabot>     Probable cause: ‘id’ is applied to too few arguments
22:45:47 <lambdabot>     In the second argument of ‘foldr’, namely ‘id’
22:45:49 <DanZimm> yea which I was trying to do over herehttp://lpaste.net/5514628507872788480
22:46:14 <dpwright> now, say I want to make some other Expression type, which is basically the same but has an extra alternative -- that's the ExpressionWithCase type listed.  Or, alternatively, I may want to remove an alternative, as in the ExpressionWithoutSeq example
22:46:30 <DanZimm> ok augur I had everything there except the `.'
22:46:38 <augur> . is compose :)
22:46:39 <DanZimm> what does this magical operator do? (I'm a newb)
22:46:47 <DanZimm> EXACTLY WHAT I WANTED TY
22:46:49 <augur> (f.g) x = f (g x)
22:46:54 <augur> alternatively:
22:47:04 <augur> iterateN f 0 x = x ; iterateN f n x = f (iterateN f (n-1) x)
22:47:33 <DanZimm> yea but then I'm not /really/ using curried functions am I?
22:47:43 <dpwright> I can do it as I did in that paste, but there's quite a lot of repeated code there -- in a way I'd like to be able to "compose" these things so say, "Expression is a type with Prim, Literal, Var, Lambda, Apply, Seq", "ExpressionWithCase is a type with Prim, Literal, Var, Lambda, Apply, Seq, Case"... and so forth
22:47:44 <DanZimm> I guess I am
22:47:56 <phadej> t \n f -> foldr (.) id (replicate n f)
22:48:03 <phadej> :t \n f -> foldr (.) id (replicate n f)
22:48:05 <lambdabot> Int -> (b -> b) -> b -> b
22:48:28 <Enigmagic> yep
22:48:32 <dpwright> there's no obvious way to do that, but I'm wondering if there are any patterns people tend to use in these sorts of scenarios
22:48:50 * DanZimm can't tell what's going on
22:48:53 <augur> DanZimm: sure you are. they're all curried in haskell, unless you use tuple types
22:48:55 <DanZimm> augur: thanks for the help!
22:49:02 <DanZimm> I see ok cool
22:49:24 <augur> DanZimm: basically in haskell you have only one functions of one argument
22:49:46 <augur> DanZimm: but they can _return_ functions, so when you have a function of type   A -> B -> C  this is really shorthand for   A -> (B -> C)
22:49:55 <augur> takes an A, and gives you back a B -> C
22:50:06 <augur> but its silent when you do applications
22:50:22 <augur> if you do (A,B) -> C its not a binary function, but a unary function that takes a _pair_ argument
22:54:41 <nshepperd> dpwright: data ExpressionWithCase = Case {...} | NotCase Expression?
22:56:22 <DanZimm> aight new question, let's say I have this iterateN function as before and I have the following basic code
22:56:35 <dpwright> nshepperd: That works, for this simple example, though it doesn't compose that nicely, I mean if I wanted to make a few different combinations of alternatives
22:56:45 <DanZimm> let f x = x + 5 ; iterateN f 5 5
22:56:45 <cerberusiscute> Heyo everyone!
22:56:46 <dpwright> I guess extracting each of the alternatives into a newtype would work
22:56:51 <dpwright> but be a bit verbose
22:57:26 <dpwright> ie data Expression = ExprLambda { exprLambda :: LambdaExpr } | ...
22:57:31 <nshepperd> dpwright: alternatively, maybe you could wrangle something with phantom types
22:57:43 <DanZimm> this is fine, but what if I want to create a new function asequence that takes some integer and places it in the second arg of the iterateN function
22:58:03 <DanZimm> oh wait I'm silly: seq n = iterateN f n 5
22:58:24 <nshepperd> but I'm not expert on phantom type (ab)use
22:58:48 <DanZimm> is there some sort of other way to create seq like that?
23:00:25 <dpwright> nshepperd: hmm, haven't done much with phantom types.  I'm guessing you'd have one massive datatype with all possible fields and then constructor/accessor functions written for each phantom type
23:02:36 <dpwright> sounds like it might lead to more boilerplate than just writing out the whole datatype for each alternative
23:04:41 <nshepperd> well, the example in haskellwiki defines operators in the DSL like (.&&.) :: Expr Bool -> Expr Bool -> Expr Bool
23:05:14 <nshepperd> here the type is Expr a, with Bool occupying the phantom type slot
23:06:54 <nshepperd> I think the idea being not to write accessor functions, but just write a few basic operations that conserve the useful information in the phantom type, and write the rest using those operations
23:13:23 <nshepperd> you can also use GADTs, I think, to write something like data Expression a where { ... ExprCase :: { _caseExpr ... } -> Expression CaseType; ... }
23:14:45 <shachaf> Note that anything that you can write with GADT syntax you can also write without GADT syntax.
23:15:33 <nshepperd> oh
23:15:48 <nshepperd> how do you restrict the phantom type with regular syntax?
23:16:10 <haasn> (x ~ Foo) => Constructor x
23:16:47 <shachaf> haasn: That's a bit confusing there because that x is the type of a field, not of the type you're defining.
23:17:06 <haasn> (x ~ Foo) => Constructor ...
23:17:20 <shachaf> Yes.
23:17:21 <shachaf> data Expression a = a ~ CaseType => ExprCase { _caseExpr ... } in your case
23:19:05 <nshepperd> ahh
23:29:34 <benzrf> just use GADTs, jeez
23:29:45 <om-foxy> I have hit cabal hell. I am trying to install system-wide packages like hoogle which I want to be available for all users and projects, hence I do not see how I can use a sandbox. The problem I have is that when I try to install ghc-mod a bunch of packages want to be downgraded to old versions. Is there a standard solution?
23:30:03 <benzrf> om-foxy: use Nix
23:30:12 * benzrf hides before he gets yelled at
23:31:10 <phadej> om-foxy: manual solution is to build hoogle in sandbox and manually move hoogle binary somewhere into $PATH
23:31:33 <phadej> IMHO that's the only reasonable solution for installing executables anyway, though requires manual steps
23:32:13 <benzrf> om-foxy: nix is the COOL solution B)
23:34:00 <dpwright> nshepperd, shachaf: Sorry, was afk for a bit.  Thanks, that's given me a couple of things to look into
23:41:45 <om-foxy> phadej: does that work if an executable is dynamically linked?
23:43:30 <phadej> om-foxy: probably not, but afaik cabal is smart enough not to dynlink if you build in a sandbox?
23:43:56 <om-foxy> phadej: okay, I'll give it a go.  Thanks for your help!
23:48:48 <trap_exit> anyone have days ... where you spend the entire day thining about the problem ... then in the end, you change some data types, fix some compile errors, and realize the functionality you wanted for the last 24 hours can be written in 10 lines of code?
23:49:50 <dmj`> less code is good code, if you don't sacrifice readability or performance
23:50:17 <trap_exit> over the past three weeks
23:50:21 <trap_exit> I've written a total of 1310 lines of code
23:50:46 <trap_exit> most of the 'work' involves me trashing around and realizing that the data structures aren't quite right
