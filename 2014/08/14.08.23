00:00:38 <Vulpyne> Hey, the hackage description said it was fast and easy!
00:01:35 <shachaf> Monoids are fast and easy. But sometimes you need trees.
00:02:17 <merijn> Trees are totally monoids!
00:02:29 <MP2E> I thought trees were just magmas
00:02:47 <Vulpyne> merijn: So, it all works perfectly just leaving r as a type variable rather than trying to specify it.
00:02:51 <stalintrotsky> What's a good guide on how to use acid-state? I just need to use it with a Map
00:03:01 <Vulpyne> merijn: Thanks to you especially, and everyone that helped.
00:03:33 <Vulpyne> I need to focus on getting better at the type stuff.
00:03:36 <merijn> hmm, the GHC manual claims there's a WARNING pragma, but it doesn't seem to produce a warning for me?
00:05:07 <shachaf> The great thing about an ERROR pragma is that GHC wouldn't even need to implement it.
00:05:46 <merijn> But I don't want an error, I just want to leave a FIXME not to myself that I won't forget :)
00:06:32 <shachaf> I,I _remindme
00:07:16 <merijn> But that would stop my code from running
00:07:35 <Vulpyne> The warning pragma seems to produce an error for me.
00:07:57 * hackagebot twitter-conduit 0.0.5.6 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.6 (TakahiroHimura)
00:07:57 * hackagebot xml-pipe 0.0.0.10 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.10 (YoshikuniJujo)
00:08:01 <haasn> {-# OPTION_GHC -fdefer-type-errors #-} ("remind me" :: ()) `seq` ...
00:08:31 <haasn> That still produces a warning during compilation, right?
00:09:11 <Vulpyne> Actually, the docs say you need to attach it to a module function/class/type/constructor.
00:09:18 <merijn> I have "-Wall -fno-warn-unused-do-bind", but that's apparently not sufficient
00:09:23 <merijn> It is attached to a function
00:10:18 <merijn> Maybe if I stuff it in the module header instead
00:11:49 <Vulpyne> It doesn't do anything for me either.
00:12:28 <Vulpyne> Maybe it only triggers from another module that imports functions with warnings attached.
00:15:30 <zenguine`> hey all, I'm trying to play with and reimplement free monad transformers for my own understanding
00:15:53 <zenguine`> and for the life of me, I can't get this last part to typecheck in writing an IO interpreter for a super simple TeletypeF style case
00:16:16 <zenguine`> can anyone point me in the right direction in filling out the undefined at the end of this paste, or tell me its too general and cant be done?
00:16:18 <zenguine`> http://pastebin.com/CfZ4N4Fr
00:17:22 <freet> best soccer tips http://tinyurl.com/p5bpscx free tips if lose
00:17:45 <Vulpyne> zenguine`: If you're using ghc 7.8.x, you could try using type holes to see what type it wants there.
00:17:56 <zenguine`> I have been doing that
00:18:07 <zenguine`> for a while, I could show a couple things that I've tried
00:18:19 <Vulpyne> zenguine`: I doubt I could help you, sorry.
00:18:23 <zenguine`> but I just can't get it to typecheck, been at it for over an hour heh
00:18:34 <zenguine`> thats okay, thanks
00:18:39 <dpwright> Does anybody have a good example of a class instance that fails to satisfy the laws specified for that class, and the problems it causes?
00:18:49 <Vulpyne> Good luck. Bed time for me!
00:19:34 <dpwright> I get that "all hell would break loose" if you had a monoid that wasn't associative or whatever, but I'm looking for a concrete example
00:20:17 <dpwright> (to use in a talk)
00:20:39 <merijn> zenguine`: I'm not really awake enough to help you with that, but have you seen Tekmo's free monad tutorial?
00:21:13 <zenguine`> Yeah I've got it open.  looking it over again now
00:21:23 <zenguine`> being too tired could be my problem as well..
00:21:24 <haasn> zenguine`: At first glance it seems impossible; the rest of the free monad structure (and hence the effects in ‘m’) depend on the actual string returned by the getLine or whatever
00:21:25 <merijn> ok, then I'm out of helpful advice :p
00:21:50 <pjdelport> dpwright: Monoid specifically?
00:22:19 <dpwright> doesn't have to be monoid, I just want something that's quick & easy to understand and see the problem with
00:23:00 <zenguine`> haasn: yeah I'm starting to think it might not be possible at this point.. I thought I could get away with lifting (getInput >>=) somehow
00:23:01 <dpwright> it's not the main focus of the talk, just want to have it as an aside to say "and this is why we have laws"
00:23:07 <zenguine`> but doesn't seem to work any which way I try it
00:23:09 <haasn> zenguine`: Consider m ~ Writer String; I could make my (String -> ...) function invoke ‘tell’ on the line I get, wrapping the “rest” of the program by that action
00:23:33 <haasn> zenguine`: But your runTTm returns a Writer String (IO a); so I essentially get (IO a, String) out of it
00:23:42 <haasn> Where does the String come from?
00:23:56 <haasn> If the only place is getLine :: IO String
00:24:05 <pjdelport> dpwright: The laws are ultimately an API / interface expectation, so you'd probably have to frame it in terms of a specific user of that interface.
00:24:15 <haasn> I believe the type would have to be IO (...) at least
00:24:45 <pjdelport> dpwright: That in turn might depend quite a bit on what the audience is already familiar with.
00:24:51 <zenguine`> haasn: ahhh, yeah I think you're right and that I've got the two monads flipped
00:25:27 <dolio> dpwright: Ord is expected to give answers that fit a total order. If they don't, using your type in Set and Map won't work.
00:25:27 <haasn> zenguine`: Unfortunately, I'm not awake enough to suggest a better type
00:25:49 <zenguine`> haasn: I suspect its as simple as making it runTTm :: (Monad m) => FreeT TeletypeF m a -> IO (m a)
00:25:57 <pjdelport> dpwright: For example, A broken Monoid instance will break Foldable, but that example only helps if you're familiar with what Foldable is supposed to do.
00:25:59 <zenguine`> haasn: let me give it a whirl like that
00:26:48 <haasn> zenguine`: While that may be inhabited, I'm not sure if it's what the real intent is. Considering that ‘m’ may be a monad that is used to determine the structure of the free program, such as State InternalState, we may want to use that monad solely to build a ‘free’ program which will later be interpreted
00:26:57 <dpwright> pjdelport: Yeah, that's the tricky bit... trying to figure out how much foundation I need to lay before I start talking about things like Monoid and the things that use them
00:27:23 <haasn> Oh, no; that doesn't really fit in line with the way GetInput is defined
00:27:27 <merijn> I think Ord and Set/Map is a good example :)
00:27:30 <haasn> The structure of ‘m’ also depends on GetInput
00:27:49 <dpwright> dolio: That's a pretty easy-to-understand one! Thanks :-)
00:27:50 <haasn> zenguine`: IO (m a) sounds like a good bet then, try it
00:28:08 * haasn is off to sleep
00:29:06 <shachaf> zenguine`: Do you even care about it being a transformer here? If not it's probably nicer to use the regular Free.
00:29:57 <zenguine`> haasn: thanks
00:30:15 <pjdelport> dpwright: If this is more of an introduction, I'd probably just explain the laws as part of the general interface documentation. You could say something like "In Haskell, equational reasoning actually allows us to express parts of our interface documentation as hard equations, or laws, that all instances must obey."
00:31:02 <zenguine`> shachaf: I do.  What I'm working towards is a Free monad like structure for describing hero abilities in a game I'm writing
00:31:05 <pjdelport> dpwright: Contrasting that with other languages where the same documentation might be a lot softer and hand-wavey, and unable to be put into the form of an equation.
00:31:21 <zenguine`> shachaf: and I want that to be a free monad transformer over a (Reader Gamestate)
00:31:51 <pjdelport> dpwright: Oh, a simpler example for Ord might just be sort :)
00:31:53 <zenguine`> shachaf: So moves can examine the gamestate but I can statically ensure that the only way to write it, is through the free monad interpreter
00:32:28 <dpwright> pjdelport: The focus of the talk is actually about equational reasoning, so that's probably quite a good way of looking at it.  I've got a slide on "why equational reasoning is useful" which lists "proving correctness" and "optimisation", and I was going to put "proving typeclass laws" (possibly as a sub-point of "correctness"), but then I thought, maybe I need to expand on "typeclass laws" a bit more
00:32:29 <zenguine`> shachaf: I guess I don't need a function with the generality of the one I'm trying to write here.. I just thought it would be easier.  I'm using this simple example to get a feel for how my eventual goal should work
00:33:20 <zenguine`> shachaf: but to answer your question, I do want it to be a transformer
00:33:41 <zenguine`> shachaf: I want to be able to do stuff like lift ask >>= displayString
00:33:56 <zenguine`> shachaf: In FreeT TeletypeF (Reader e)
00:34:43 <pjdelport> dpwright: Ah, yeah, that's something I'd put the other way around. "Laws" are not really special thing on their own: it's more that the language allows and encourages stating type class specifications as actual equational laws, wherever possible.
00:34:44 <dpwright> but yeah, describing laws as "really solid, concrete API documentation" rather than some abstract "mathematical properties you expect your data to adhere to" might make people more comfortable :-)
00:35:35 <pjdelport> dpwright: It's very similar to how many optimized functions will be documented as being equationally the same as some naive expression, but faster.
00:36:23 <pjdelport> dpwright: Consider the documentation for map: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:map
00:37:34 <pjdelport> dpwright: And further down, for example, where functions like scanr are documented with laws like:
00:37:34 <pjdelport> head (scanr f z xs) == foldr f z xs
00:37:58 <pjdelport> So equational laws are a pervasive thing, not type-class-specific.
00:38:43 <dpwright> pjdelport: Those are some really good examples, thank you!
00:38:57 <pjdelport> dpwright: Another one: span p xs == (takeWhile p xs, dropWhile p xs)
00:39:33 <pjdelport> partition p xs == (filter p xs, filter (not . p) xs)
00:39:34 <dpwright> yeah, the whole Data.List module is a bit of a treasure trove for these examples!
00:42:31 <jollygood> I asked the question earlier but the channel was busy and no one answered. why did they decide to create a strict version of foldl and name it foldl', instead of just fixing foldl? I was told to always use foldl', so why do we have both, causing crashes when not compiling with -O2 while using functions that use foldl (like sum in Prelude)
00:43:09 <shachaf> That is how the Report was written.
00:43:26 <shachaf> There are some places where foldl' is not correct, though they're not that common.
00:44:19 <jollygood> do you have an example? I was told that foldl' is always the better choice between the two
00:45:05 <shachaf> > foldl (\x y -> y) (error "empty list") [1,2,undefined,3,4]
00:45:07 <lambdabot>  4
00:45:08 <shachaf> > foldl' (\x y -> y) (error "empty list") [1,2,undefined,3,4]
00:45:09 <lambdabot>  *Exception: Prelude.undefined
00:46:13 <shachaf> There are some other examples. There's a wiki page about it.
00:47:37 <jollygood> ok.. so they are different when function is lazy in the first argument? is that the correct way to put it
00:48:39 <shachaf> @google foldl foldr foldl'
00:48:39 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
00:48:39 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
00:48:39 <haasn> iirc they are the same semantically when the function is strict in its first argument
00:48:43 <shachaf> I think that page explains it.
00:50:00 <sgronblo> Can I fetch the sources for all cabal build-depends packages?
00:50:12 <Cale> Well, the real reason is that the intention of the Report was to define a language without pinning down the operational details too strongly, because the whole point of Haskell was research into languages with non-strict semantics, including their implementation.
00:51:28 <Cale> The intention was that the implementation should take care of implementing uses of foldl efficiently, and if you have optimisations turned on, GHC typically will.
00:52:10 <jollygood> typically, but not always?
00:52:14 <Cale> (through strictness analysis)
00:53:36 <Cale> I'm sure there are cases where strictness analysis is imperfect, but I don't have examples handy.
00:55:26 <wirrbel> hi, can I use haddock to generate documentation not only for the public API of my modules but also for the private ones?
00:55:49 <wirrbel> I would like to use it to browse through my functions
00:56:59 <Cale> jollygood: But if you try something like  main = print (foldl (+) 0 [1..100000000]) -- this program when compiled with -O0 will consume lots of space, and probably stack overflow if it's not memkilled, while with -O it'll run just fine.
01:00:16 <Cale> wirrbel: I think the usual solution to that is to put internal things in their own module, export them from there (so that Haddock will document them), but don't re-export them in the main module.
01:01:35 <Cale> wirrbel: That's not terribly ideal. It would be nice if unexported declarations could be forcibly documented
01:02:37 <jollygood> Cale yeah I know, I experienced that few hours ago. my program was running out of memory when I used sum (that uses foldl) while processing a large log file. compiling with optimizations turned on fixed it
01:10:22 <akegalj> is it possible somehow to embed or implement some basic movie player (any simple format) with haskell gui libraries. I know it's kind of noobish but i don't have any experience with haskell gui libs nor randering video...
01:10:34 <akegalj> i'm just evaluating how hard wold it to implent it in haskell
01:10:53 <akegalj> would*
01:11:45 <akegalj> would it be to implement it*   ...
01:12:50 <akegalj> so i know it's not the right channel to ask, but maybe someone has experience and can gide me through
01:13:37 <akegalj> do i need some kind of SDL binding for this kind of work?
01:20:37 <stalintrotsky> how do I pull out my result from an acid-state EventResult event?
01:26:42 <solatis> hmmm if I'm inside a monad ZMQ z (), and I want to use the results of an IO (UUID) inside that monad, the thing I'm looking for are monad transformers eh?
01:28:23 <Haskellfant> solatis: from looking at the docs (hope I got the right once) it seems like zmq is already an instance of MonadIO so liftIO would be what you're looking for
01:29:50 <Haskellfant> @src ZMQ
01:29:50 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:30:14 <Haskellfant> solatis: if you look at the definition of the ZMQ type you can see that it already uses the transformer internally http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/src/System-ZMQ4-Monadic.html#ZMQ
01:31:31 <solatis> http://lpaste.net/109852
01:31:36 <solatis> that's the relevant code
01:31:42 <solatis> so liftIO is the proper way to do this?
01:33:40 <solatis> aren't monad transformer the way i should be approaching this problem?
01:34:29 <johnw> what is the type of ZMQ?
01:34:43 <johnw> i mean, how is it defined
01:34:51 <Haskellfant> newtype ZMQ z a = ZMQ { _unzmq :: ReaderT ZMQEnv IO a }
01:35:00 <johnw> yes, liftIO is the right thing to use
01:35:03 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/System-ZMQ4-Monadic.html
01:35:18 <johnw> it has an implementation of MonadIO, so you're good
01:35:21 <solatis> ok, liftIO always feels like a hack
01:35:29 <johnw> it's really the appropriate thing here
01:35:32 <Haskellfant> solatis: yes monad transformers are the right approach but you don't need to wrap ZMQ in a monad transformer because it already is defined as a monad transformer
01:35:46 <solatis> at least, there's always people telling me that i should never have to use lift because it's a hack
01:35:57 <solatis> aha i understand
01:37:08 <Haskellfant> solatis: I'm not quite sure but afaik even if you implement monad transformers yourself you still need to use lift
01:37:36 <solatis> ok
01:38:50 <sgronblo> Nobody knows how to get sources using cabal?
01:39:17 <sbrg> sgronblo: cabal fetch?
01:39:17 <johnw> cabal fetch?
01:39:26 <johnw> cabal get!
01:39:28 <sbrg> hint: cabal --help
01:39:34 <sbrg> oh, yeha.
01:42:01 <sgronblo> I need to explicitly specify the packages? I would like to get all the build-deps packages.
01:43:38 <merijn> solatis: Easy solution, wait 2 more years for me to finish my pure haskell ZMQ implementation :)
01:45:17 <merijn> Actually, I hope to finish implementing the remaining socket types this weekend and have a really buggy prototype on github :)
01:46:13 <solatis> just as a validation, this is what the code is supposed to look like?
01:46:14 <solatis> http://lpaste.net/109852
01:47:26 <merijn> solatis: Looks about right, yeah
01:47:33 <solatis> ok thanks
01:50:11 <jollygood> @hoogle Text -> Integer
01:50:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:50:14 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
01:50:14 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
01:50:32 <jollygood> is there such a function?
01:50:47 <johnw> read . unpack :: (Text -> Integer)
01:50:59 <jollygood> :/
01:51:19 <johnw> you could define a helper function
01:51:34 <jollygood> everyone says to switch to Text, but it seems to be a second class citizen in haskell
01:51:43 <johnw> it depends on the libraries you're using
01:53:27 <merijn> attoparsec should have parser for integers
01:53:48 <merijn> jollygood: The problem you're having is that you'r asking for an "Text -> Integer" function with no context
01:54:20 <merijn> Presumably you're trying to parse something, in which case you should probably use one of the parsing libraries, but we're not psychic and can't really recommend any without knowing what you're doing
01:54:27 <jollygood> merijn what context is needed? I have such a function, and a bunch of others, for String. -> read
01:55:02 * johnw gives merijn a big juicy piece of context
01:55:08 <jollygood> I wanted a read version that takes Text
01:55:18 <merijn> You shouldn't
01:55:23 <merijn> Because read sucks
01:55:25 <alpounet> http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Read.html use  that to read integers from text
01:59:12 <jollygood> alpounet that doesn't look half bad!
02:11:11 <WarzoneCommand> question: does anyone know how to do type classes with type inequality nowadays? I.e. using closed type families oid.
02:11:35 <WarzoneCommand> Or do we still need the HList way with overlapping instances etc
02:12:00 <WarzoneCommand> (to clarify: I'm trying to make something like type-level replace: http://lpaste.net/109855 )
02:12:04 <merijn> WarzoneCommand: I may have a useful example
02:12:26 <merijn> WarzoneCommand: https://gist.github.com/merijn/6130082
02:12:38 <WarzoneCommand> I'll have a look
02:12:42 <WarzoneCommand> thanks :)
02:13:08 <merijn> That's just a Constraint though, but you could use it to enforce type inequality in a typeclass by using the constraint as a class constraint
02:17:06 <akegalj> i have cabal sandbox, i need to install package from hackage but have to change few lines. I did "cabal get x", cd into x, change stuff.. how can i now install that changed package into sandbox?
02:18:01 <merijn> akegalj: cabal help sandbox
02:19:01 <akegalj> merijn: add-source?
02:19:39 <merijn> yeah
02:20:20 <akegalj> merijn: thnx :/
02:22:19 <NikolajK> why does there have to be an undefined term? I heard it's related to Turing completeness??
02:25:29 <jollygood> there's nothing special about undefined, you could have defined it yourself
02:25:32 <jollygood> @src undefined
02:25:33 <lambdabot> undefined = error "Prelude.undefined"
02:28:13 <Twey> NikolajK: There doesn't have to be, at all
02:28:23 <Twey> NikolajK: It's just convenient sometimes
02:28:39 <Twey> There doesn't have to be ‘error’, either (which really is special)
02:28:55 <Twey> Semantically, they're both equivalent to: let x = x in x
02:29:18 <Twey> (but with better behaviour when they're meant to indicate a failure)
02:29:27 <Twey> And *that*, i.e. arbitrary recursion, is necessary for Turing-completeness
02:29:57 <jollygood> what makes them semantically the same?
02:33:51 <pjdelport> jollygood: They're both "bottom" (⊥), or an invalid value: https://en.wikipedia.org/wiki/Bottom_type
02:36:37 <NikolajK> :quit
02:39:21 <pjdelport> jollygood: Bottom generally indicates anything that causes an evaluation to fail: an error or exception, resource exhaustion, an infinite diverging loop, and so on.
02:39:39 <jollygood> I think I got it. thanks
02:44:52 <shachaf> pjdelport: "Bottom type" doesn't have much to do with this "bottom value".
02:44:58 <shachaf> They have the same name, that's all.
02:45:17 <shachaf> There's a lattice of types with (forall a. a) at the bottom. And there's a lattice of definedness, with _|_ at the bottom.
02:47:01 <shachaf> But since calling the value _|_/bottom is so standard in Haskell, talking about the type is just confusing. The article isn't about the value.
02:47:47 <shachaf> (The type could also called "bottom" because it's initial, I guess. But either way it shouldn't.)
02:54:49 <akegalj> can anyone explain how come this dynamic linking is failing. http://pastebin.com/ekKpCqA0   I have installed sdl_ttf through package manager of arch linux. Is it versioning problem?
02:58:13 * hackagebot type-natural 0.2.3.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.3.0 (HiromiIshii)
03:03:17 <pjdelport> jollygood: What shachaf said. :)
03:06:38 <dario> akegalj: what does ldd /home/akegalj/projects/frp/.cabal-sandbox/lib/x86_64-linux-ghc-7.8.3/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.3.so give?
03:11:33 <henk> hi, I’m trying to run lambdabot on my debian stable server from the debian package lambdabot, but I fail to find good documentation on how its config is supposed to look like. Is there a manual anywhere?
03:12:07 <akegalj> dario: http://pastebin.com/jCJNUFuq
03:18:15 * hackagebot type-natural 0.2.3.1 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.3.1 (HiromiIshii)
03:19:07 <dario> hm damn, that looks good
03:21:07 <akegalj> dario: i don't really understand the linking phase to debug it well
03:21:19 <akegalj> dario: thnx for trying thou
03:25:01 <yesthisisuser> How do I implement a critical section using a IORef?
03:26:10 <yesthisisuser> Or should I use an MVar for that?
03:26:25 <MarcWeber> Is there any specialized package which provides sets of sets of elements representing them as tree internally?
03:26:42 <MarcWeber> yesthisisuser: You should talk about what your critical section does.
03:27:23 <yesthisisuser> I want to do some disk operations and make sure that they are atomic
03:28:09 <MarcWeber> That's not an IORef issue - but a "how to make disk access atomic" question.
03:28:33 <MarcWeber> Eg typically this is done by echo x > a then mv a target
03:28:59 <MarcWeber> Thus it depends on what you do exactly
03:29:59 <yesthisisuser> MarcWeber: Let's say my program writes a file to disk, and needs to keep track of the most recent change in that file
03:30:47 <yesthisisuser> I imagine a critical section would solve that by making the write operation and update of some internal variable atomic
03:30:54 <MarcWeber> THere are specialized implementations watching the filesystem, eg see FSEvetns or inotify
03:31:18 <MarcWeber> Thus you're still lacking context, eg whether you're the only one manipulating those files.
03:31:34 <yesthisisuser> only one application yes.. but multiple threads
03:32:07 <MarcWeber> Blocking and such can be done trivially by mvars, because you can "take" them only once to manipulate them.
03:32:28 <MarcWeber> IOVars are atomic for ints or such, but you need to block, thus IOVars will not help you.
03:34:48 <yesthisisuser> thanks..
03:34:49 <yesthisisuser> I was mixing up MVar and IORef
03:35:56 <MarcWeber> yesthisisuser: Maybe its easier to start a dedicated thread doing those file manipulations only and whenever you need to change the file handover the task to the thread.
03:36:10 <yesthisisuser> yes like a worker
03:36:16 <yesthisisuser> queue
03:36:59 <yesthisisuser> a message passing approach
03:52:08 <k00mi> MarcWeber: what do you mean by "sets of sets of elements"?
03:52:49 <k00mi> Data.Set is implemented as a tree
03:53:46 <wombawomba> I'm trying to solve https://www.hackerrank.com/challenges/filling-jars reasonably fast using Haskell. I've gone from https://gist.github.com/aeriksson/24d8bd78a723336b870f (way too slow) to https://gist.github.com/aeriksson/d93c8fa6f776e7301a09 (faster, but not fast enough).
03:54:05 <wombawomba> how do I make it faster?
03:55:01 <tryit> try it http://tinyurl.com/p5bpscx  free tips if lose
03:56:33 <ClaudiusMaximus> wombawomba: unboxed vector might help?
03:58:08 <k00mi> Data.Vector.Primitive is unboxed
03:58:35 <ClaudiusMaximus> oh ok
04:03:21 * hackagebot cabal-lenses 0.3.1 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.3.1 (DanielTrstenjak)
04:04:56 <ClaudiusMaximus> wombawomba: actually, the first version could be improved by finding sum and length in one pass over the list - something like  uncurry div . foldl' (\x (!s,!l) -> (s + x, l + 1)) (0,0)  (with -XBangPatterns)
04:08:12 <wombawomba> Alright
04:12:50 <k00mi> wombawomba: try thinking of a better algorithm that doesn't require actually doing all that work
04:23:23 * hackagebot Quickson 0.1 - Quick JSON extractions with Aeson  http://hackage.haskell.org/package/Quickson-0.1 (ssadler)
04:33:24 * hackagebot cabal-cargs 0.7.1 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.1 (DanielTrstenjak)
04:53:26 * hackagebot cabal-bounds 0.8.5 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.5 (DanielTrstenjak)
04:59:04 <mroman> what the hell is this functional dependency thing
04:59:20 <mroman>  Couldn't match type `[BlsqExp]' with `(BlsqStack, BlsqStack)'
04:59:20 <mroman>  When using functional dependencies to combine
05:02:09 <mroman> do { (st, _) <- get; return st }
05:02:12 <mroman> where's the problem
05:02:20 <mroman> my state is (BlsqStack, BlsqStack)
05:02:29 <mroman> so (st, _) <- get; should pretty much be legal
05:02:51 <chrisdone> mroman: do you have ghc 7.8?
05:03:07 <ClaudiusMaximus> mroman: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
05:03:28 * hackagebot Quickson 0.1.1 - Quick JSON extractions with Aeson  http://hackage.haskell.org/package/Quickson-0.1.1 (ssadler)
05:03:30 * hackagebot confsolve 0.5.1 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.5.1 (DanielTrstenjak)
05:06:43 <arianvp> is there a tool that can turn haskell source code into HTML with all the symbols clickable??
05:06:54 <arianvp> so that I can browse through code quickly?
05:07:06 <chrisdone> i saw something posted like that to /r/haskell a while back
05:07:18 <arianvp> yeh I remember something like it too.. but can't recall how it was called
05:08:01 <arianvp> I remember the Agda source code had a similar thing
05:08:14 <chrisdone> http://robinp.github.io/nemnem/
05:08:27 <arianvp> ah yeah awesome
05:08:37 <arianvp> thanks :)
05:08:41 <chrisdone> welcome
05:09:26 <arianvp> Someone had the whole Agda  Prelude published in such a format as well. Guess you don't magically know who that was right? :P
05:09:36 <chrisdone> never heard of that :p
05:09:52 <arianvp> Yeh I bumped into it one time and I was like "God this is magic" .  but I didn't bookmark it..
05:09:54 <arianvp> :(
05:11:26 <arianvp> FOUND IT
05:11:26 <arianvp> http://oleg.fi/free-applicative-agda/
05:11:30 <chrisdone> ヽ (＾▽＾) ﾉ
05:11:43 <arianvp> http://oleg.fi/free-applicative-agda/Prelude.html#1
05:11:45 <mroman> Ah. This is the worst thing I've ever done
05:11:47 <arianvp> :)
05:11:53 <mroman> It's just impossible to add state to it :(
05:12:04 <arianvp> to what?
05:12:11 <mroman> To my interpreter
05:12:19 <mroman> which wasn't meant to have IO nor State
05:12:32 <arianvp> Monad transformers to the rescue?
05:12:51 <mroman> I doubt that works ;)
05:12:59 <arianvp> why wouldn't it :P
05:13:00 <gallais> arianvp: http://www.cse.chalmers.se/~nad/listings/lib/README.html
05:13:03 <mroman> because
05:13:07 <mroman> that's like having a pure function
05:13:13 <mroman> which suddenly then needs IO
05:13:15 <arianvp> gallais: yes that was what I was looking for :)
05:13:19 <mroman> which changes it's type to :: ... -> IO ...
05:13:23 <mroman> which changes literally everything
05:13:40 <mroman> It requires 300 changes all over the freaking place
05:13:47 <arianvp> ugh. so much for haskell heh
05:13:48 <arianvp> :D
05:14:09 <mroman> because every function that calls the now IO-ish function needs to be changed as well
05:14:12 <mroman> and this really snowballs
05:14:47 <chrisdone> mroman: what was the IO added for?
05:14:51 <chrisdone> iorefs?
05:15:06 <arianvp> I still need to find a good way to add lexical scoping to my  toy lisp project
05:15:17 <arianvp> I was looking at ekmetts `bound` library .is it any good?
05:15:38 <mroman> I haven't added IO yet
05:15:41 <mroman> because I can't
05:15:55 <mroman> the compiler error log it produces is just too big :)
05:16:26 <mroman> but ok
05:16:28 <arianvp> yeh I should probably change my type signature as well :/
05:16:34 <arianvp> eval :: String -> Either SchemeError Expr    isn't very flexible
05:16:36 <mroman> I actually have a State-Monad
05:16:41 <mroman> that carries around a List
05:16:43 <mroman> (the stack)
05:17:03 <mroman> however, the interpreter uses execState to evaluate certain subexpressions
05:17:15 <mroman> which means they run on a temporary state
05:17:32 <mroman> which means that inside subexpressions you can't access state outside of that
05:17:55 <mroman> i.e. thats like a = 3; b = (5*3*a); <- nope, can't access a because it's in a subexpression
05:18:08 <chrisdone> so you want to mix two types of state with the same code that evaluates expressions?
05:18:33 <mroman> well... evalSubexpression is a pure function
05:18:51 <chrisdone> @paste
05:18:51 <lambdabot> Haskell pastebin: http://lpaste.net/
05:18:53 <mroman> so if I use a State-Monad there
05:18:58 <mroman> it's not
05:19:26 <mroman> i.e. it's not :: Type but becomes :: State Type Type
05:19:35 <chrisdone> sure. what's wrong with that?
05:19:39 <mroman> everything
05:19:49 <chrisdone> i see
05:19:53 <mroman> it requires me to change every other function that calls evalSubexpression
05:20:08 <chrisdone> sure
05:20:12 <mroman> yeah
05:20:14 <mroman> that's the problem ;)
05:20:35 <Axman6> that might be a lot easier than you think; the compile errors will lead you to a pretty mechanical translation
05:20:47 <arianvp> I wish there were some tutorials about writing interpreters beyond "simple toys" ..  Like how would one idiomatically implement static scoping etc
05:21:20 <Axman6> arianvp: seen the write a scheme in 48 hours tutorial?
05:21:26 <chrisdone> static scoping is straight-forwardly done with a reader monad
05:21:40 <arianvp> Axman6:  that doesnt implement static scoping though
05:22:11 <arianvp> chrisdone: could you lead me a bit in the right direction here?
05:22:14 <chrisdone> bind :: Binding -> (Reader Env a) -> Reader Env a
05:22:42 <chrisdone> arianvp: oh, well. there's the `local' function which is handy for this
05:22:43 <chrisdone> :t local
05:22:45 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
05:23:12 <chrisdone> are you already familiar with Reader?
05:23:24 <Axman6> :t local `asAppliedTo` (undefined :: Reader r a)
05:23:26 <lambdabot>     Couldn't match type ‘ReaderT r0 Identity a0’ with ‘r -> r’
05:23:26 <lambdabot>     Expected type: r -> r
05:23:26 <lambdabot>       Actual type: Reader r0 a0
05:23:37 <arianvp> yes. it's the mona instance for (-> r) right?
05:23:41 <Axman6> :t flip local `asAppliedTo` (undefined :: Reader r a)
05:23:42 <lambdabot> ReaderT r Identity a -> (r -> r) -> ReaderT r Identity a
05:23:49 <chrisdone> that's another instance
05:23:54 <chrisdone> :t runReader
05:23:55 <lambdabot> Reader r a -> r -> a
05:24:04 <chrisdone> > runReader (do v <- ask; return (v+1)) 123
05:24:05 <lambdabot>  124
05:24:23 <arianvp> yeh so basically it's a newtype wrapper around (-> r)
05:24:50 <Axman6> it's like State without put
05:24:57 <chrisdone> > runReader (do v <- ask; c <- local (*2) ask; return (v,c)) 123
05:24:59 <lambdabot>  (123,246)
05:25:55 <chrisdone> you can consider the `local` function as being like local binding in your interpreter, it's already scoped
05:27:21 <arianvp> I see
05:27:23 <mroman> Axman6: yeah. But this thing has 300 built-ins
05:27:29 <mroman> 300 functions I have to change :(
05:27:38 <arianvp> Why does it have 300 built-ins O:
05:27:50 <arianvp> just define a few primitives and define the rest in the language itself
05:27:56 <chrisdone> mroman: got keyboard macros? =p
05:28:04 <arianvp> vim to the rescue :)
05:28:07 <mroman> i.e. every occurence of modify (a:) is now broken :D
05:28:14 <trap_exit> does haskell have a data structure that is constant time insertion at both front nad end? (list is only constant time front)
05:28:40 <Axman6> Data.Seq
05:28:40 <chrisdone> arianvp: another way of modelling it is HOAS http://en.wikipedia.org/wiki/Higher-order_abstract_syntax
05:29:07 <chrisdone> arianvp: so instead of modelling a function like Abs [Param] Exp, you can model it like: Fun (a -> Exp)
05:29:08 <mroman> I admit that using modify directly was a mistake
05:29:09 <arianvp> trap_exit: http://hackage.haskell.org/package/dequeue-0.1.5/docs/Data-Dequeue.html
05:29:10 <Axman6> I _think_ it's constant time pre/append
05:29:16 <mroman> that should've been refactored out into a function :D
05:29:37 <arianvp> I think?
05:29:47 <trap_exit> arianvp: oksaki, should have guessed
05:29:51 <mroman> but yeah.
05:29:54 <trap_exit> arianvp: thanks!
05:29:57 <mroman> It's only 5k lines of code
05:30:05 <chrisdone> http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Sequence.html
05:30:06 <mroman> should be done by noon :D
05:30:19 <Axman6> my experience with those dequeues is that their constant factor is pretty high (the two list approach is often faster)
05:30:36 <Twey> shachaf: What's the ordering relation in the lattice of types with (forall a. a) at the bottom?
05:30:49 <Axman6> trap_exit: take a look at http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Sequence.html too
05:31:11 <Axman6> or... http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Sequence.html which is the most recent version. damn google
05:31:39 <hrt66> How did people learn Haskell without LYAH?????????????
05:31:42 <Axman6> constant time cons and snoc and viewL/R
05:31:48 <hrt66> I don't get it. It must have been confined to geniuses only.
05:31:57 <Twey> arianvp: ‘Someone had the Agda Prelude published in such a format’ — the Agda compiler actually supports generating that, so you can do it yourself (--html flag).
05:32:09 <arianvp> sweet
05:32:10 <Axman6> not really, it's pretty easy to teach to first year uni students in my experience
05:32:22 <Twey> hrt66: Slowly
05:32:29 <arianvp> hrt66:  The dude who wrote LYAH learned haskell by writing LYAH
05:32:32 <Twey> hrt66: Well, after RWH it was okay, I think.
05:32:33 <chrisdone> children have gone through tryhaskell successfully
05:32:43 <arianvp> iirc
05:32:44 <mroman> as for IO...
05:32:46 <hrt66> Hehe ok
05:32:51 <Twey> There was *someone* in here who taught Haskell to his eight-year-old son
05:32:52 <mroman> what's the worst thing that can happen with unsafePerformIO?
05:32:56 <Axman6> there were plenty of tutorials before LYAH and RWH that were quite good
05:32:59 <chrisdone> including a 7 year old
05:33:03 <Axman6> and a book or two
05:33:10 <arianvp> mroman: euhm quite a lot
05:33:10 <Twey> I think it was dibblego, but I also thought I asked dibblego and he said otherwise, so I'm at a loss.
05:33:26 <Axman6> mroman: what's the worst thing you can do with IO?
05:33:54 <chrisdone> launch puppy missiles
05:33:58 <Axman6> Twey: either erikd or TacticalGrace?
05:34:03 <arianvp> basically only use it  when you're 100% sure the effects are fully referentially transparent
05:34:06 <Twey> mroman: Now take it and multiply it by the fact that it's happening as part of a ‘pure’ computation that's subject to optimizations assuming that ;)
05:34:12 <Twey> Axman6: Maybe
05:34:15 <Axman6> Pretty Erik taught his daughter Haskell
05:34:19 <Twey> Pretty sure it was a d- name
05:34:19 <Axman6> sure*
05:34:31 <mroman> Axman6: the worst thing?
05:34:32 <Twey> Hehe, that was a much more amusing sentence without the ‘sure’
05:34:40 <mroman> readFile and writeFile
05:34:54 <Twey> mroman: You have no imagination ;)
05:35:01 <Axman6> mroman: start an nuclear holocaust perhaps? That's pretty bad, and IO lets you do that
05:35:07 <chrisdone> mroman: https://github.com/ghc/packages-bytestring/blob/master/Data/ByteString/Internal.hs#L599
05:35:21 <Twey> I'd have gone with *at least* "rm -rf ~"
05:35:24 <mroman> Twey: that's the only thing i'd to with unsafePerformIO
05:35:28 <mroman> *do
05:35:29 <chrisdone> @quote xeyes
05:35:30 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
05:35:47 <arianvp> hmm that HOAS approach seems interesting
05:35:48 <mroman> -- ^^(\/)[+\/.+{\/cm}.+
05:35:54 <Axman6> not xeyes! NOOOOO
05:35:55 <mroman> best. comment. ever.
05:36:04 <Twey> arianvp: HOAS is lovely.  Doesn't play well with total languages, though.
05:36:15 <Axman6> @quote unsafePerformIO
05:36:16 <lambdabot> bd says: as we can see here, unsafePerformIO constructs a new world and destroys it for the purpose of your debugging. Do you really want that on your conscience?
05:36:57 * Axman6 -> bed
05:37:02 <mroman> the question is from a technical standpoint
05:37:13 <mroman> Sure it's not "nice" to use unsafePeformIO
05:37:28 <mroman> but if I'd grep hackage for it
05:37:39 <mroman> I'd find lots of big popular packages using it at least once
05:37:57 <mroman> so even though it's bad, it can't be that bad :D
05:38:00 <arianvp> but  for some reason it feels a bit weird. how would I produce something of   (a -> Expr) when just parsing text tokens
05:38:05 <Axman6> mroman: inl;ining can cause big issues with some uses of unsafePerformIO. if you decide you want a global mutable variable, global = undsafePerformIO newEmptyMVar can do strange things if inlined
05:38:54 <Axman6> so if you ever want to use that hack, you need to also add {-# NOINLINE global #-}
05:39:05 <Twey> mroman: So, some bad things that can happen for you by reading/writing files in unsafePerformIO as a programmer are: 1) it can break your referential transparency, so the output of the function changes depending on how many times it's called, and that depends on optimizations, resulting in some truly spectacular Heisenbugs; 2) IO exceptions can occur in pure code, where you can't catch them; 3) you now have
05:39:06 <Twey> to think about the order of evaluation of your code, because the effects happen when (and if!) the value is evaluated.  Note that order of evaluation is explicitly undefined in Haskell, so the correctness of your code now depends on an implementation detail.
05:39:26 <Twey> mroman: Oh, 4) you can break the type system
05:39:34 <Twey> And get nice segfaults out of it
05:40:08 <mroman> you can crash the interpreter anyway with int("haha this is not an int")
05:40:09 <Axman6> yeah, unsafeCoerce is easily implementable via unsafePerformIO
05:40:14 <mroman> ;)
05:40:28 * Axman6 -> bed for real
05:40:36 <Twey> mroman: You mean GHCi…?
05:40:47 <mroman> No.
05:40:50 <mroman> My interpreter ;)
05:41:02 <Twey> Ah
05:41:07 <mroman> You don't want to know how I implemented pseudo-state in it :D
05:41:09 <Twey> But still, there's crashing and then there's crashing
05:41:10 <arianvp> https://github.com/ghcjs/ghcjs-vdom/blob/master/src/GHCJS/VDOM.hs#L63
05:41:17 <mroman> at the end of eval the interpreter prints the stack
05:41:31 <mroman> there's Type that's invisible when printed
05:41:40 <mroman> and that's "state" :D
05:41:41 <Twey> ‘Crashing immediately with a pattern match error’ is quite different to ‘overwriting a random value and continuing’
05:41:49 <arianvp> so many unsafe in that file it's scary
05:41:54 <chrisdone> :t let parse ["fn",[arg],body] = \x -> replace arg x body in parse ["fn","x","axy"]
05:41:55 <lambdabot> Char -> [Char]
05:41:58 <chrisdone> > let parse ["fn",[arg],body] = \x -> replace arg x body in parse ["fn","x","axy"] 'z'
05:41:59 <arianvp> but yeah. that's the wolrd of interfacing with javascript :/
05:42:00 <lambdabot>  "azy"
05:42:06 <Twey> The former lets you try again.  The latter potentially mutates your program into one that does "rm -rf /".
05:42:07 <chrisdone> arianvp: there's a dumb form of HOAS ^
05:42:26 <chrisdone> :t let parse ["fn",[arg],body] = \x -> replace arg x body in parse
05:42:27 <lambdabot> [[Char]] -> Char -> [Char]
05:42:54 <chrisdone> the "parser" takes some "AST" ([[Char]]) and produces a function from "param" to "expression" (Char -> [Char])
05:42:55 <Twey> chrisdone: Pretty sure that's just an interpreter?
05:43:09 <Twey> HOAS is when you encode binders directly as functions in your syntax
05:43:15 <chrisdone> Twey: it's hard to do more without defining some types
05:43:34 <chrisdone> it's not really an interpreter, it just looks like it
05:44:05 <mroman> http://codepad.org/UzKTAcPX ;P
05:44:38 <chrisdone> i'm converting the syntax Fun "x" (App (App "a" "x") "y") to HOASFun (\x -> (App "a" x) "y")
05:44:43 <mroman> I have like 5k lines of that ;D
05:44:47 <chrisdone> it's just a translation, no interpreting anywhere
05:44:50 <Twey> I think the HOAS equivalent would be defining it as ("fn", \arg x -> replace arg x body)
05:45:05 <Twey> chrisdone: That's what an interpreter does
05:45:15 <Twey> Er, oops
05:45:20 <Twey> I think the HOAS equivalent would be defining it as ("fn", \arg x -> replace arg x) **
05:45:29 <Twey> Or ("fn", replace) I guess.
05:47:25 <Twey> Hm, that's a primitive, though.
05:47:27 <mroman> Certain builtins just create code using other builtins on the fly to achieve the functionality
05:48:35 <Twey> interpret (name, f, args) = interpret (f args) — something like this — i.e. your binder produces more syntax
05:48:37 <arianvp> mroman: couldn't you move a lot of code out of the host language to the interpreted language?
05:48:59 <arianvp> make a sort of "prelude" for your language
05:49:14 <arianvp> that way you dont need to do that many refactors in your haskell code
05:49:27 <mroman> yeah
05:49:29 <mroman> I could
05:49:38 <mroman> I'm already doing that internall
05:49:40 <mroman> :)
05:49:42 <mroman> *internally
05:49:44 <arianvp> yeh true
05:49:55 <mroman> i.e. builtinFoo = eval "...."
05:50:08 <chrisdone> Twey: that's what my HOASFun does. eval = … where apply (HOASFun f) args = eval (f args)
05:50:09 <arianvp> well not fully. because your textual representation doesnt change whilst the way it is interepreted might ;)
05:50:31 <mroman> since you can't define functions in the interpreted language it'd be hard to move it :D
05:50:36 <arianvp> ah
05:50:43 <arianvp> what kind of language is it?
05:50:49 <mroman> well
05:50:50 <arianvp> i.e. what are you using it for?
05:50:51 <mroman> let's just say
05:50:53 <mroman> \/"~";;\/{Sh}m[**\[
05:51:04 <arianvp> oh looks PERLy
05:51:06 <arianvp> :D
05:51:10 <mroman> creates a list of frequencies of ocurrences in a list
05:51:11 <whfkvfszjibsaybx> How good is haskell for server programs
05:51:18 <arianvp> pretty darn good!
05:51:38 <arianvp> it's really easy to white performant code. because haskell has really nice concurrency primitives
05:51:43 <whfkvfszjibsaybx> Is it as fast as c++?
05:51:43 <arianvp> and a very good I/O manager
05:51:56 <chrisdone> Twey: you could embed the eval inside the HOASFun so that the latter eval isn't require, though i'm not sure it doesn't make a difference. in any case the key is not to have an explicit name -> exp mapping
05:52:13 <whfkvfszjibsaybx> I see.  What about garbage collection?
05:52:14 <Twey> chrisdone: Ah!  I misinterpreted your ‘replace’
05:52:24 <chrisdone> gotcha
05:52:34 <Twey> Yes, that sounds right
05:53:07 <whfkvfszjibsaybx> O
05:53:13 <chrisdone> no name carrying around
05:53:23 <arianvp> whfkvfszjibsaybx: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
05:53:34 <arianvp> fun read
05:53:43 <chrisdone> of course there's also the nice thing of using a GADT to get type-safety of these functions
05:53:47 <mroman> arianvp: http://codepad.org/y42g4Tmb <- that's a brainfuck interpreter in it ;P
05:53:56 <arianvp> so basically it's APL?
05:53:57 <arianvp> :P
05:54:04 <mroman> exactly
05:54:14 <mroman> it's like a really, really, really crappy version of J
05:54:26 <chrisdone> i fixed lpaste's irc announcer. seems it was broke for ages. i shuffled around my znc settings so it was borked
05:55:05 <arianvp> ohwell. time to dust off my old  scheme parser
05:55:18 <arianvp> and get it working
05:55:23 <arianvp> and intepretin
05:55:29 <arianvp> :)
05:55:30 <mroman> but in my defense I had financing lectures during that time
05:55:38 <arianvp> ahh
05:55:41 <chrisdone> they interpretin, evalin, trying to catch me applying dirty
05:55:50 * arianvp dances
05:55:51 <mroman> and rather than listening to 4h of financing lectures I wrote a crappy language :D
05:55:59 <mroman> 4h every monday
05:56:03 <arianvp> oh god
05:56:14 <arianvp> my lectures never last longer than 2h
05:56:20 <arianvp> and are usually interesting. so that's good
05:56:25 <arianvp> well 2 hours of listening, 2 hours of working
05:56:28 <chrisdone> a four hour lecture would end me
05:56:45 <arianvp> I've got ADD so my attention span is gone after 2 hours max
05:56:48 <chrisdone> i can only listen for about an hour before i need to go and absorb
05:57:00 <arianvp> yeh
05:57:02 <chrisdone> at least with a recording you can change it to 2x speed
05:57:02 <mroman> My attention span is gone after 30minutes :D
05:57:08 <chrisdone> listening to slow talkers is interminable
05:57:13 <mroman> well.. was
05:57:15 <mroman> I graduated
05:57:16 <mroman> so
05:57:18 <arianvp> sweet
05:57:22 <arianvp> I've still got some years to go
05:57:35 <arianvp> BUT we've got a haskell compiler to maintain. so must be fun
05:57:44 <arianvp> (ctional)
05:58:03 <arianvp> I'm actually wondering if our haskell compiler is still maintained ...
05:59:16 <arianvp>  last commit 3 months ag o
05:59:19 <arianvp> ok apparently sort of
05:59:19 <arianvp> :)
05:59:23 <chrisdone> what was the last comment?
05:59:25 <chrisdone> "typo"
06:00:02 <chrisdone> 1 in 3 repos you look at today will have "typo" as the last commit message
06:00:14 <mroman> damn
06:00:18 <arianvp> let me check
06:00:20 <mroman> matrix multiplication uses execState too
06:00:26 <mroman> wtf
06:00:33 <arianvp> "found a typo in the XREALLOC macro"
06:00:35 <arianvp> :D
06:00:49 <chrisdone> ( ͡ ͜ ͡)
06:00:54 <arianvp> nah that commit message is from 2005
06:01:00 <chrisdone> (￣ー￣)
06:01:23 <arianvp> las commit msg is : -O0 works (again)
06:01:47 <arianvp> snd-last : configures mentioned in README work (again)
06:02:12 <chrisdone> alright
06:02:17 <chrisdone> i get it, it's a repo =p
06:02:21 <arianvp> xD
06:03:10 <arianvp> I'm actually gonna start "introduction to functional programming" this semester.
06:03:12 <arianvp> :/
06:03:12 <mroman> yay. only 8 errors left
06:03:21 <arianvp> but I don't want an introduction :(
06:03:33 <mroman> yeah
06:03:44 <mroman> introductions are mostly useless if you already know a thing or two
06:03:47 <chrisdone> unless it's by oleg
06:03:52 <arianvp> OH SWEET. there's a  "Writing compilers in haskell" course next semester
06:03:53 <arianvp> damn
06:03:59 * arianvp drools
06:04:15 <chrisdone> "first chapter: compiling php"
06:04:20 <arianvp> FUBAR
06:04:22 <arianvp> :(
06:04:23 <chrisdone> :D  →  D:
06:04:35 <arianvp> well we've got acme-php for that right?
06:05:24 <arianvp> nope
06:05:25 <arianvp> C#
06:05:26 <arianvp> http://www.cs.uu.nl/foswiki/pub/TC/CourseAssignments/CSharp.pdf
06:05:30 <arianvp> C# is fun!
06:05:31 <mroman> hu
06:05:36 <mroman> ghc doesn't report all errors it sees?
06:05:58 <Guuf> Is there a course webpage for the course?
06:06:10 <arianvp> Guuf: www.cs.uu.nl/wiki/TC/
06:06:12 <arianvp> http://www.cs.uu.nl/wiki/TC/
06:06:23 <Guuf> Ah, thanks.
06:06:42 <mroman> ah. ok
06:06:47 <mroman> that's what I thought
06:06:53 <mroman> 2.3k lines error log :D
06:06:56 <arianvp> sweet
06:07:15 <Guuf> So you know what you will be doing. ;)
06:08:06 <arianvp> okay I'm off to the cinemas
06:08:27 <arianvp> thanks for the help chrisdone, Twey
06:08:33 <arianvp> :)
06:08:36 * hackagebot twitter-types 0.5.0 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.5.0 (TakahiroHimura)
06:08:54 <rene_> Is Integer type instance of several Type Classes?
06:09:09 <chrisdone> sure
06:10:58 <Twey> rene_: Type  :i Integer  in GHCi
06:12:22 <rene_> Whats the difference between Show type class and show function. How are these related to each other?
06:13:18 <chrisdone> Show is a class, show is a method of the class
06:13:25 <lpaste> Xeironis pasted “Parse error in do in let” at http://lpaste.net/109874
06:13:30 <chrisdone> class Show a where show :: a -> String
06:13:36 * hackagebot shelly 1.5.5 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.5.5 (GregWeber)
06:13:38 <Xeironis> I don't understand that Parse error...
06:14:03 <chrisdone> Xeironis: it's because your do extends too far backwards earlier than your "go"
06:14:13 <chrisdone> there's an extension to allow you to write like this, though
06:14:22 <Xeironis> Okay
06:14:29 <Xeironis> What's the name of that extension?
06:14:31 <lpaste> chrisdone revised “Parse error in do in let”: “Fix alignment” at http://lpaste.net/109874
06:14:39 <chrisdone> Xeironis: um...
06:14:45 <chrisdone> anyone know it?
06:15:14 <mgsloan> Maybe NonDecreasingIndentation ?
06:15:22 <Xeironis> So I basically have to indent it twice?
06:15:22 <chrisdone> perhaps http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#infelicities-syntax
06:15:36 <chrisdone> Xeironis: well, just one level after its parent
06:15:43 <Xeironis> OK
06:15:46 <Xeironis> thanks
06:15:59 <lpaste> Guuf annotated “Parse error in do in let” with “Parse error in do in let (annotation) - suggestion” at http://lpaste.net/109874#a109876
06:16:10 <lpaste> chrisdone revised “Parse error in do in let”: “Outlining syntactical node” at http://lpaste.net/109874
06:16:19 <Guuf> I prefer to write stuff with let as above.
06:16:38 <chrisdone> (oops, meant to annotate rather than revise)
06:17:29 <Xeironis> Guuf: Is the only difference the amount of spaces in one indentation?
06:18:18 <Guuf> Xeironis: I’ll paste another thing which hopefully will be clearer. Hold on.
06:18:43 <Xeironis> Oh, you put the definition on line below let, I see
06:18:49 <Guuf> Xeironis: Yes. :)
06:19:09 <Xeironis> Yes, I suppose doing it like that might prevent some confusion
06:19:09 <hrt66> Quote from http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
06:19:10 <hrt66> "Use pure if you're dealing with Maybe values in an applicative context (i.e. using them with <*>), otherwise stick to Just."
06:19:10 <hrt66> Question: Why would I use pure instead of using Just? Is this just a convention, or is there a better reason?
06:19:29 <Guuf> Xeironis: Especially if you define several things in your let.
06:19:55 <chrisdone> hrt66: it's generalizing the problem. pure will produce a Just x value for Maybe, Right x for Either, [x] for [a], etc.
06:20:06 <Xeironis> Yeah, that makes sense
06:20:19 <chrisdone> hrt66: it's style choice, choose whichever is clearer for you
06:20:21 <hrt66> chrisdone: ah, of course. thanks
06:20:29 <lpaste> zwarn pasted “an error in for monadtransformers i dont understand” at http://lpaste.net/109879
06:20:52 <chrisdone> hrt66: welcome
06:26:03 <lpaste> adas pasted “how is this valid?” at http://lpaste.net/109880
06:26:47 <adas> because the type of quickCheck is "prop -> IO ()" and "[Int] -> [Int] -> Bool" is not an instance of "Testable"
06:27:12 <mroman> pfee. 200 lines of compiler errors left
06:28:22 <Iceland_jack> adas: the property is wrong though
06:28:33 <Guuf> adas: It is an instance of Testable.
06:28:50 <Guuf> adas: (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)
06:30:13 <Iceland_jack>        Testable Bool, Show [Int]
06:30:13 <Iceland_jack>     => Testable ([Int] -> Bool)
06:30:13 <Iceland_jack>     => Testable ([Int] -> [Int] -> Bool)
06:30:26 <mroman> there isn't any sortByM?
06:30:33 <Iceland_jack> not in base
06:30:42 <adas> Guuf: i saw that .. which means "[Int] -> Bool" is an instance of Testable. But how come "[Int] -> [Int] -> Bool"?
06:30:56 <Iceland_jack> adas: see what I wrote earlier
06:31:32 <adas> Testable Bool, Show [Int]
06:32:35 <Guuf> adas: Insert ([Int] -> Bool) in place of prop and [Int] in place of a in  (Arbitrary a, Show a, Testable prop) => Testable (a -> prop).
06:32:42 <Iceland_jack> I wrote more than that
06:32:44 <mroman> hm
06:33:07 <adas> got it : ). got to recursively expand it
06:33:21 <Guuf> adas: Good. :)
06:33:21 <Iceland_jack> but basically, Bool is Testable and a function (a -> prop) is Testable if (Arbitrary a, Show a, Testable prop)
06:33:26 <Iceland_jack> good :)
06:38:35 <adas> thanks
06:38:57 <Guuf> You are welcome.
06:41:21 <jle`> @check \x y -> not (x && y) == (not x || not y)
06:41:23 <lambdabot>  +++ OK, passed 100 tests.
06:41:33 <jle`> QC can really make 100 tests for that?
06:41:38 <jle`> i guess it is duplicating tests
06:41:46 <jle`> oh yeah, it uses the arbitrary instance
06:46:32 <mroman> horray. It compiles
06:46:45 <mroman> now if I only had tests to check if I didn't screw things up :D
06:47:51 <dreams> pufft, optimizing Haskell is difficult.
06:48:18 <jle`> dreams: optimizing anything is difficult :)
06:48:40 * hackagebot cabalg 0.2.6 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.6 (DmitryMalikov)
06:48:59 <dreams> jle`: Indeed. Well, I am really speaking from the compiler side.
06:49:51 <dreams> jle`: no no, optimizing lazy languages is more difficult than imperative ones.
06:50:09 <chrisdone> mgsloan: lol, i tried to load our main codebase into ghc-server, it gets half way through and segfaults
06:50:23 <chrisdone> Debug: localhost:52850: 10 .. Result (LogResult SevInteractive (UnhelpfulSpan "<no location info>") "Loading package stm-2.4.2 ... ")
06:50:24 <chrisdone> Debug: localhost:52850: 10 .. Result (LogResult SevInteractiSegmentation fault (core dumped)
06:50:29 <chrisdone> (°¬°)
06:50:47 <dreams> jle`: Its almost like, well laziness is a problem, lets make it strict like conventional languages in some parts to reduce time & space.
06:50:56 <jle`> dreams: more difficult? sometimes i like to think it's just different.
06:51:16 <jle`> laziness improves performance just as much as it harms it
06:51:21 <mgsloan> chrisdone: Wow!  Not every day you get to see a segfault in haskell :)
06:51:26 <chrisdone> =)
06:51:47 <jle`> in my day to day i think laziness improves the performance of my programs in more areas than it harms it
06:51:55 <jle`> the trick is just to figure out which is which
06:52:11 <jle`> not more difficult...just, different :)
06:52:32 <dreams> jle`: you'd be surprised how laziness is harmless to space performance.
06:52:43 <Fuuzetsu> @tell byorgey is the testsuite of ‘split’ meant to run a long time? My buildbot timed it out…
06:52:44 <lambdabot> Consider it noted.
06:53:13 <jle`> it varies case by case
06:53:30 <jle`> but i take advantage of laziness's space performance improvements daily
06:53:54 <dreams> jle`: Its more difficult from the implementor side. All those optimization technique they come up with are either harmful to space or time.
06:53:57 <luite> Fuuzetsu: takes under a second here
06:54:17 <Fuuzetsu> can you try with 7.6.3
06:54:22 <jle`> dreams: the compiler implementor?
06:54:39 <dreams> jle`: what? tell me, what advantages are there to laziness from space performance side?
06:54:42 <dreams> jle`: yes.
06:54:51 <luite> Fuuzetsu: ah i'm not sure if i still have that anywhere, lemme check
06:54:56 <jle`> well, this is from the haskell user side, not the compiler side
06:55:09 <dreams> jle`: even the user, but the compiler implementor trying to optimize things for you under the hood is struggling.
06:55:29 <jle`> but consider the space performance in a strict language of something like take 2 (map (*2) [1..1000])
06:55:40 <jle`> and consider the space performance of a lazy language for the smae thing
06:55:51 <dreams> jle`: Just look at what they came up with "Optimistic evaluation", it does improve time & speed. But its heavy to implement in GHC for instance.
06:56:43 <nullremains> would a strict Haskell be "better"?
06:56:46 <luite> Fuuzetsu: same (7.6.3 from ubuntu 14.04 on x86_64 linux)
06:56:49 <dreams> jle`: you do realize that the expression you wrote suffers from space faults under lazy evaluation?
06:56:49 <jle`> i don't know too much about the implementation side of things so i can't comment too much :)
06:56:49 <Fuuzetsu> ok thanks
06:56:52 <chrisdone> nullremains: how do you like ML?
06:56:57 <Fuuzetsu> maybe my bot just choked…
06:57:07 <jle`> dreams: space faults?
06:57:34 <jle`> i can't imagine take 2 (map (*2) [1..100000000]) taking up more space in a lazy language than a strict language
06:57:46 <luite> Fuuzetsu: sometimes travis-ci times out seemingly randomly for me
06:57:56 <chrisdone> dreams: the expression he wrote only performs two constant factor steps
06:58:24 <yesthisisuser> I imagine using acid-state as a key-value store is not very efficient, given that the whole structure must be persisted to disk whenever a value changes. Is this a correct assumption?
06:58:26 <jle`> foo n = take 2 (map (*2) [1..n]) is O(n) in a strict language, and O(1) in a lazy language
06:58:31 <dreams> jle`: expressions are suspended thus accumulated in the heap, until when needed are evaluated. What is the solution you say? make them strict so that the garbage collector can de-allocate cells in the heap. Which is why we have strictness analyses.
06:58:34 <yesthisisuser> As opposed to something like a b-tree.
06:59:11 <luite> Fuuzetsu: i hope to add an alternative soon to the ghcjs repos, but nothing is as well-integrated with github i think
06:59:16 <chrisdone> take 2 (map (*2) [1..1000])
06:59:16 <yesthisisuser> Or am I misunderstanding how acid-state works?
06:59:16 <chrisdone> ((*2) 1) : take 1 (map (*2) [1..1000])
06:59:17 <chrisdone> ((*2) 1) : ((*2) 2) : []
06:59:17 <chrisdone> 2 : 4 : []
06:59:47 <luite> yesthisisuser: it's incorrect, the reason is purity
07:00:01 <dreams> nullremains: there is a strict haskell but its worse, because it evaluates everything eagerly but use a technique to detect which expressions are lazy, then the time spent trying to detect those causes overheads, depending how much laziness you have.
07:00:01 <jle`> nullremains: laziness allows for semantics of composability. i think much of the equational reasoning benefits from haskell fit in well with laziness semantics more than strict one.  math is lazy, after all
07:00:01 <yesthisisuser> luite: please explain.
07:00:06 <hpc> yesthisisuser: acid-state's storage model is snapshots plus a change log
07:00:26 <luite> yesthisisuser: acid-state saves a snapshot of the whole structure from time to time. changes are then just serialized as arguments to a pure function that updates the structure
07:00:32 <jle`> you can have equational reasoning with strict semantics too, though...but i like how well it all fits together with laziness/non-strictness
07:00:39 <jle`> haskell would be a completely different language
07:00:39 <luite> yesthisisuser: then you just need to load the latest snapshot and apply those changes
07:00:49 <hpc> yesthisisuser: the change log is a series of values like UpdateFooBar (Foo 5) (Bar "yes")
07:01:03 <yesthisisuser> ahh. great.. is there any detailed material on this online?
07:01:04 <hpc> which are usually generated by template haskell
07:01:11 <Fuuzetsu> luite: I have a local Hydra instanc that just polls repos and does thing how I tell it to
07:01:12 <nullremains> just asking a what if question, Idris has taken the strict route for example
07:01:14 <Fuuzetsu> instance*
07:01:19 <Fuuzetsu> things*
07:01:22 <hpc> from functions like updateFooBar :: Foo -> Bar -> Update YourState ()
07:01:59 <yesthisisuser> or maybe I should just "dig into" the code to really try to understand how it works
07:02:08 <dreams> jle`: from my understanding the whole argument with laziness is modularity .
07:02:25 <Fuuzetsu> luite: like so http://fuuzetsu.co.uk/images/1408802493.png
07:03:06 <mroman> Alright. Now I've a secondary global stack :)
07:03:16 <yesthisisuser> jle`: what do you mean by "math is layz".. just curious
07:03:19 <yesthisisuser> lazy
07:03:49 <yesthisisuser> with regards to composition or
07:04:16 <yesthisisuser> or in what sense is math closer to non-strict semantics
07:04:28 <mroman> > (a,b) <- ([],[])
07:04:29 <lambdabot>  not an expression: ‘(a,b) <- ([],[])’
07:04:38 <mroman> > let (a,b) <- ([],[]) in b
07:04:39 <lambdabot>  <hint>:1:11: parse error on input ‘<-’
07:04:48 <mroman> ah
07:04:54 <mroman> > let (a,b) = ([],[]) in b
07:04:55 <lambdabot>  []
07:05:03 <mroman> > let (a,(b:bs)) = ([],[]) in b
07:05:04 <lambdabot>  *Exception: <interactive>:3:5-24: Irrefutable pattern failed for pattern (a,...
07:05:08 <jle`> yesthisisuser: it was a bit of cheap and irresponsible reasoning ;)
07:05:14 <mroman> ^- you can't catch that?
07:05:48 <luite> Fuuzetsu: what are those numbers at the top?
07:05:50 <jle`> yesthisisuser: but when you consider something in math, you don't calculate the entire thing before reasoning about it
07:06:07 <jle`> it's not really something meaningful to say though >_>
07:06:12 <dreams> mroman: lol.
07:06:56 <dreams> jle`: that depends on the evaluation strategy no?
07:07:16 <dreams> jle`: i.e. applicative order.
07:07:36 <yesthisisuser> well at least a declaration, by itself does not imply any computation. but I guess that has nothing to do with laziness vs. strictness...
07:08:50 <basti_> hi people. I'm trying to use hastec. I'm getting a message that the type of a foreign declaration were unnacceptable, in the "ffi" example as well as in my code.
07:09:23 <basti_> according to this answer from the interwebs: https://ghc.haskell.org/trac/ghc/ticket/5610#comment:2 this could be due to a change in the handling of "newtype"
07:09:26 <jle`> if i said something like "consider all the natural numbers.  take the subset of all even numbers, and take the first two. what are they?".  it translates well into lazy semantics.  it can be said in strict semantics too but i think it is just a little less natural in my opinion.
07:09:40 <basti_> said newtype (JSString) ought to be in scope, but isn't.
07:10:15 <jle`> but like i said, it's not really a meaningful thing to talk about :/
07:10:25 <Fuuzetsu> luite: build number
07:10:31 <dreams> jle`: its natural with strict semantics when you're using a sequential machine.
07:10:33 <basti_> what was that change and how could i make the example work?
07:11:02 <Fuuzetsu> luite: anything in between is just cached result so it doesn't show up
07:11:04 <jle`> as in a sequential generator of natural numbers?
07:11:22 <dreams> jle`: Its unnatural with lazy semantics under a sequential machine. Because you're hacking an abstract machine just to get to the declarative level you're talking about.
07:11:23 <luite> Fuuzetsu: ah looks interesting
07:11:40 <jle`> dreams: talking about semantics and the language here, not about the implementation :)
07:12:09 <jle`> a language that for all intents and purposes could be evaluated by hand with a piece of paper
07:12:11 <jle`> and a pen
07:12:17 <jle`> (maybe more than one piece of paper)
07:12:48 <dreams> jle`: I get you, but we're going to applying them to the machines we have arn't we? I'm talking about how they fit in the machine.
07:13:48 <jle`> hm. i'm talking more about the expression of these things as a part of a language. when you get into the border between machine and language, then things start to get a bit tricky, i'll admit
07:13:59 <dreams> jle`: yes.
07:14:41 <dreams> jle`: I don't disagree, the semantics are beautiful. Its just tricky in practice.
07:19:54 <wirrbel> When building my cabl project I get the following error
07:20:04 <wirrbel> Warning: The documentation for the following packages are not installed. No links will be generated to these packages: llvm-general-pure-3.4.4.0
07:20:22 <wirrbel> how could I installl that documentation?
07:20:46 <dreams> jle`: I have a minor issue that annoys me about Haskell, if you have a way to deal with, please enlighten me. When I look at the source code of a program I didn't write, usually there are lots of functions that are imported from other modules, but its unclear which module they relate to, and I need to look at the definition of the function to reason about it. So the pain starts by trying to figure out which
07:20:48 <dreams> function relate with which module. Perhaps there is a tool that you could use to highlight a function?
07:21:41 <jle`> i usually just use hoogle or something like that :|
07:21:55 <jle`> admittedly my development cycle has places where it could be streamlined
07:21:55 <dreams> jle`: yeah but what if its a local implementation that isn't in hoogle?
07:22:18 <jle`> i think you can run ctags
07:22:58 <dreams> jle`: Ah, I'll have a look. Thanks.
07:23:16 <jle`> or whatever tags system you normally use in other languages
07:23:23 <jle`> ...i think they still work
07:23:36 <jle`> ? i havn't relied too much on it, although maybe i should, heh.
07:24:09 <dreams> jle`: I use Hat sometimes to step into the flow of the program.
07:24:18 <sgronblo> so does anyone know how to cabal get all the build-deps?
07:26:59 <dottedmag> sgronblo: cabal install --dependencies-only?
07:27:18 <dottedmag> *--only-dependencies
07:28:04 <Algebr> Why do many repos says to do this seqeuence, cabal install --only-dependencies;cabal build instead of just doing cabal install?
07:29:57 <dottedmag> Algebr: probably to make it easier to discern "deps are broken" and "$ourstuff is broken" => less bugs filed.
07:32:48 <Fuuzetsu> also because you might not want to actually install your own package, just build it so it's in dist/
07:32:53 <Fuuzetsu> such as if you're hacking on it
07:36:07 <hrt66> http://channel9.msdn.com/Blogs/Charles/YOW-2011-Simon-Peyton-Jones-and-John-Hughes-Its-Raining-Haskell
07:38:10 <Fuuzetsu> hrt66: wow, a video which they actually easily let you download
07:38:14 <Fuuzetsu> haven't see one of those for a while
07:38:21 <Algebr> Fuuzetsu: What's the difference of building and installing?
07:38:28 <hrt66> heh ok
07:38:58 <Fuuzetsu> one goes into the package database and one doesn't
07:46:30 <hexagoxel> hmm i want warnings for unused-non-toplevel-binds, but not for toplevel :/
07:46:41 <rodlogic> I think that
07:47:04 <rodlogic> 'cabal build' should automatically install dependencies
07:47:08 <hexagoxel> the former are mostly errors, the latter are just temporarily unused/unexported stuff
07:48:21 <dcoutts_> rodlogic: I agree
07:48:47 <dcoutts_> rodlogic: cabal configure should construct the install plan, and then build should install any of the deps that are not already installed.
07:49:43 <Fuuzetsu> I just avoid cabal where sensible
07:50:37 <Fuuzetsu> …says as he goes to cabal configure -fpango.
07:51:57 <jle`> i am forever tied to cabal for sandboxing
07:51:58 <rodlogic> Fuuzetsu: cabal has it's problems but I find it that it just needs a serious cleanup and simplification (from an UI pov).
07:53:03 <rodlogic> and cabal is usually blamed for a deeper problem that is shared with GHC: installing multiple package instances of the same version.
07:53:06 <dcoutts_> rodlogic: yes, historically we followed the "./configure; make; make install" UI design, but it's increasingly clear that we need to follow a new UI design for the world where we deal with collections of packages with deps.
07:53:48 <Fuuzetsu> rodlogic: Well, I use nix now so the second problem doesn't exist for me anymore
07:53:52 <rodlogic> dcoutts_: couldn't agree more. Sandboxing was a welcome addition, but it feels like it is at the margins
07:54:06 <jle`> oh yes that nix thing
07:54:16 <rodlogic> Fuuzetsu: yes, lucky you, but we can't expect everyone trying to solve these problems to install Nix
07:54:27 <yesthisisuser> wait. what is the difference between Data.Map and Data.HashMap?
07:54:29 <Fuuzetsu> I just don't like that it's difficult in projects to just use well-configured GHCi because projects depend on Paths_foo and other stuff generated by cabal
07:54:47 <Fuuzetsu> rodlogic: So we should instead implement something just like that in cabal itself?
07:54:56 <Fuuzetsu> that seems like worse solution
07:55:07 <dcoutts_> Fuuzetsu: that's the approach we're taking
07:55:17 <dcoutts_> Fuuzetsu: to steal the nix ideas and implement them in cabal
07:55:32 <Fuuzetsu> probably easier to bundle nix and not tell anyone
07:55:38 <dcoutts_> it's the approach we've been following (slowly) for several years
07:55:48 <yesthisisuser> ok. I guess my question is identical to this one: http://stackoverflow.com/questions/7894867/performant-haskell-hashed-structure
07:55:52 <dcoutts_> Fuuzetsu: sadly that wouldn't quite work
07:55:59 <rodlogic> Fuuzetsu: aside from disk space, 99% (the famous 99%) of the time a install plan should work even if we have to install dependences again and again.
07:56:05 <dcoutts_> rodlogic: yes, it is somewhat grafted on
07:56:54 <dcoutts_> Fuuzetsu: e.g. we cannot control system packages, we have to deal with "live" build trees and not just whole packages (not just tarballs)
07:57:01 <rodlogic> That's why I am really looking forward to the work and ezyang and dcoutts_ are putting into GHC and Cabal/GHC. It is going to be the basis for something beautifil :-)
07:57:19 <dcoutts_> rodlogic: it'll also need work at the UI level to expose it nicely
07:57:48 <rodlogic> dcoutts_: I can imagine. But it is approaching the problem fromthe root instead of adding workarounds.
07:57:54 <dcoutts_> rodlogic: the stuff we've been working on so far is the mechanisms but it's not yet very usable without Cabal/cabal-install knowing about it properly
07:58:27 <rodlogic> dcoutts_: I understand, It just seems that there is a nice seed being planted :-)
07:58:57 <dcoutts_> it's one of the things ezyang and I squabble about :-), he wants to get it into the UI ASAP, and I'm a bit more conservative and want to get it into the UI when it works and doesn't introduce extra problems
07:59:41 <dcoutts_> the main issue is that once you can have multiple instances of packages, it creates lots of other problems, unless your package manager knows how to deal with that (like nix does)
08:00:09 <rodlogic> dcoutts_: is this related to adding the notion of environments?
08:00:14 <dcoutts_> without a good higher level ui you don't know what packages you're actually using
08:00:17 <dcoutts_> rodlogic: exactly
08:01:28 <Fuuzetsu> hm, there's something pretty wrong with that split package, the tests just run and run…
08:01:55 <rodlogic> dcoutts_: I can see the squabble between ASAP and conservative. I find that GHC release cycle already is quite conservative (maybe not for the man power), so being conservative could mean 2-3 years.
08:02:31 <dcoutts_> rodlogic: not really, we're making it such that ghc has the mechanisms, but they'll be somewhat opt-in
08:02:37 <rodlogic> dcoutts_: I think that it should be aggressive as an experimental feature that can be turned on when possible and then in a following cycle make it permanent with improvements
08:02:55 <dcoutts_> rodlogic: and so once cabal-install is able to make use of them, then it can turn them on
08:02:56 <rodlogic> dcoutts_: by experiemntal I meant the UI side
08:03:28 <dcoutts_> rodlogic: so ghc will have the (low level) ui, in terms of extra ghc/ghc-pkg flags etc
08:03:42 <Fuuzetsu> seems fine on 7.8.3 though, just 7.6.3 times out…
08:03:42 <dcoutts_> rodlogic: so we will not be waiting on a ghc release cycle to enable further things
08:03:58 <Algebr> is ## something from template haskell/lens?
08:04:23 <rodlogic> dcoutts_: that would be good.
08:04:45 <dcoutts_> rodlogic: what ezyang and I have not always agreed on is enabling things now unconditionally, for the existing versions of tools that don't know about this stuff
08:05:59 <dcoutts_> Fuuzetsu: incidentally, when nix is being used as a secondary package manager on an existing system, do you know how it tracks deps on things from the system?
08:06:13 <dcoutts_> Fuuzetsu: e.g. system libc, gcc etc
08:06:32 <Fuuzetsu> AFAIK it just ignores them, the first thing nix does is install its own libc, gcc and all that and uses those
08:06:44 <MarcWeber> dcoutts_: Not at all (exception might be gcc on osx)
08:06:50 <dcoutts_> Fuuzetsu: ah ok, so that's one reason we couldn't just bundle nix :-)
08:06:59 <Fuuzetsu> I was half-joking.
08:07:01 <Fuuzetsu> Only half.
08:07:10 <MarcWeber> It just installs everthing into /nix/store/* additionally to the main system.
08:07:10 <dcoutts_> no, I know people have suggested it
08:07:33 <dcoutts_> Fuuzetsu: so it makes things harder for us in constructing the package hash
08:07:44 <Cailin22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
08:07:45 <rodlogic> dcoutts_: is this related to the distinction between global and user and project package dbs?
08:07:49 <Fuuzetsu> @where ops
08:07:49 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:08:11 <dcoutts_> rodlogic: not really
08:08:18 <dcoutts_> we will not be able to be quite as precise as nix with the dep tracking
08:08:25 <rodlogic> dcoutts_: i.e. there is a project environment thta depends on a user environment which depends on a global environment?
08:08:46 <rodlogic> dcoutts_: or are you referring to non haskell dependencies?
08:08:51 <dcoutts_> rodlogic: no, the idea is that each env is independent
08:09:03 <dcoutts_> rodlogic: yes, system deps, like gcc
08:09:17 <rodlogic> dcoutts_: but there will still be a stack of package dbs, right?
08:09:27 <dcoutts_> rodlogic: yes
08:09:44 <dcoutts_> rodlogic: but that just defines what's installed, not what's available in the environment
08:09:44 <MarcWeber> dcoutts_: I personally feel more and more that package management / description should be done independent form language. If I had the power I'd start a global datbase so that ruby and haskell packages could refer to mysql client libraries written in C for example.
08:10:10 <dcoutts_> MarcWeber: that'd be great, if the system package managers were powerful enough
08:10:14 <rodlogic> dcoutts_: so will an enviroment be specific to a package db or could contain packages spanning more than more package db in the stack (in the right dependency direction)
08:10:27 <dcoutts_> MarcWeber: but the system package managers mainly focus on system-wide installation, not per-user
08:10:39 <MarcWeber> Creating a usable set of versions end users can install - that would be a different task - but it would be much easier then probably.
08:11:12 <MarcWeber> dcoutts_: I'm thinking about a package description you could derive gentoo/debian/nix/.. packages from based on version constraints (like cabal).
08:11:40 <dcoutts_> MarcWeber: the Cabal format was designed to be able to be translated into other formats, e.g. for system package managers.
08:11:59 <dcoutts_> and indeed there are translation tools for gentoo/debian/nix
08:12:16 <MarcWeber> dcoutts_: But I can't create a ocaml vim plugin package which requires patched Vim and knows how to compile ocaml code  ..
08:12:31 <Fuuzetsu> cabal2nix still can't pick up anything behind flags because that would involve evaluating flags ;(
08:12:34 <MarcWeber> And such stuff should be "per user" eventually.
08:12:50 <dcoutts_> MarcWeber: right, that needs the language-agnostic one, and Cabal would fit nicely into such a world
08:13:18 <MarcWeber> Fuuzetsu: I wrote hack-nix long time ago, but I hardcoded flags because eg darcs has 8+ flags -> too many ways to build.
08:15:02 <Fuuzetsu> I actually read something about hack-nix last night but I was tired and a bit drunk so I forgot all about it ;P
08:15:27 <Fuuzetsu> oh right, it just sets up environments, right? You can do that with buildEnv can't you?
08:15:48 <MarcWeber> Fuuzetsu: It does a lot more: It dumps hackage to a .nix file because nix cannot read hackage's db format.
08:16:01 <MarcWeber> THen it implements an experimental brute force solver to find deependencies on its own.
08:16:23 <MarcWeber> However in practise I always told the db dump to only use latest versions and some additionall older versions to make things compile I care about.
08:16:43 <MarcWeber> Because having 10+ versions of a package would never evaluate in reasonable time..
08:17:34 <MarcWeber> I assumed that there are always conflicting ways to build package A (which might depend on FOO-1.0) and package B (which might depend on package Foo-2.0) and similar - which would be hard to track creating many .nix files.
08:17:37 <rodlogic> MarcWeber: "package management / description should be done independent form language" - if by package you meant OS packages, then I totally agree with
08:18:03 <MarcWeber> rodlogic: If you get to know the nix world thene there is no difference os / non os packages.
08:18:13 <MarcWeber> Its just a sane way to reproduce a setup (thus installed software).
08:18:30 <MarcWeber> Whether the system or the user actually uses that software doesn't matter than much anymore.
08:19:30 <MarcWeber> The only drawback is that its (almost) impossible to replace glibc fast, because it could break an exitsing firefox. Thus nix is conservative and intsalls a new glibc, a new libjpg, and a new firefox using the new versions keeping the old versions on disk till you run gc.
08:19:39 <rodlogic> MarcWeber: I can see that in an ideal world. I usually find the idea of a single package manager to rule them all quite distracting WHEN in the context of the whole multiple instances of the same version and multiproject support in cabal. These are Haskell specific issues/problems that must be addressed (I am not saying you are implying otherwise, btw)
08:20:38 <MarcWeber> rodlogic: But I'm pretty sure the same issues happen to almost every language out there.
08:21:46 <rodlogic> MarcWeber: to haskell to a greater extent, afaik, since when we compile a library we inline a lot. So we can't just reuse the same lib for another dependency
08:21:52 <MarcWeber> I totally agree that its hard to understand how a perfect system behaves - eg it sometimes makes sense to define standards such as the haskell platform ..
08:23:52 <MarcWeber> rodlogic: Till now I assumed ghc would not compile inlined code at all - just put info into the .hi files about how it should be done when it gets used. But I never read the code how it actually is done.
08:24:28 <MarcWeber> So you say if I have three executables each will build its own ByteString library (for instance)?
08:24:42 <rodlogic> I am perfectly happy with a world where: (a) I need to use whatever package management I have to install any non-haskell dependency for building haskell projects, (2) use whatever tool I have to package my shared lib or executable into a OS package. What I demand is that it must build in all cases except the ones where the dependencies have real API conflicts.
08:25:26 <rodlogic> MarcWeber: yes, I am not familiar wih the specific either.
08:26:44 <ricky____> New to Haskell question here; I'm going through exercism, and the test file that I have to create the module for has "import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist)." I've done a few that require creating a module, but I've never seen the nested syntax as in "Sublist(Equal, Sublist, Superlist, Unequal)." Can anyone offer some insight as to what that is?
08:28:18 <Heffalump> ricky____: that's importing a data type Sublist, along with its constructors Equal, etc.
08:28:22 <monochrom> if I create a type "data X = Ctor1 | Ctor2 | Ctor3", then the export syntax is "module M(X(Ctor1, Ctor2, Ctor3))", similarly the import syntax
08:28:38 <Heffalump> in another module,that'll be defined as data Sublist = Equal ... | Sublist ... | ...
08:28:57 <Heffalump> and there might be some other constructors in Sublist other than the ones that are being imported
08:29:51 <monochrom> the climax happens when I create a module M with type M defined by "data M = M". then you get to say import M(M(M)) :)
08:30:07 <ricky____> Awesome. Types is the next chapter for me in LYAH, so that explains why the syntax is so foreign. Thanks a lot, guys.
08:30:17 <ricky____> monochrom: Ha!
08:30:41 <rodlogic> dcoutts_: I just wish I had more time to really help.
08:32:04 <dcoutts_> rodlogic: :-)
08:32:12 <dcoutts_> rodlogic: do you have any time to help? :-)
08:36:49 <RedNifre> Good evening.
08:37:32 <RedNifre> What are your thoughts on using IDEs for Haskell? Any opinions on EclipseFP or IntelliJ? Or others?
08:39:17 <hpc> i prefer plain vim, so i can't really give an opinion on either of those
08:39:20 <tekul> RedNifre: I think most people use vim or emacs. There are quite a lot of useful plugins for them.
08:40:06 <joe9> Is there any way for a process to know if it has any children without having to parse the exception of getAnyProcessStatus?
08:40:16 <hpc> last time i used eclipsefp was something like 5 years ago, and it was missing a lot of basic stuff like keyboard shortcuts
08:40:25 <hpc> it's probably better now
08:40:28 <joe9> RedNifre: emacs + evil?
08:41:05 <Fuuzetsu> come help with Yi ;)
08:41:47 <tekul> Perhaps once I have nix working :)
08:42:19 <alanz_> Fuuzetsu: I wonder what it would take to embed elisp in Yi
08:42:27 <Fuuzetsu> alanz_: a gun and my dead body
08:43:04 <alanz_> apart from that, it could plug into a big source if usefulness immediately
08:43:07 <monochrom> embed elisp in haskell in elisp in haskell in ...
08:43:08 <alanz_> :)
08:43:39 <Fuuzetsu> alanz_: but it would require us to implement everything elisp comes to expect, every function, every stupid quirk
08:43:39 <monochrom> "it's Turing tarpits all the way down!"
08:43:43 <Fuuzetsu> we'd basically have to implement emacs
08:43:58 <alanz_> I guess.
08:44:28 <alanz_> But if I could use Yi but use the emacs ecosystem it would be cool.
08:44:59 <Fuuzetsu> alanz_: it's less effort to implement features to the editor needed and then port the modes than try to get it to play directly with elisp
08:45:03 <monochrom> chrisdone's emacs haskell-mode in yi?! :)
08:45:05 <alanz_> Doesn't emacs have a core in c and the rest in elisp? That would be a reasonable attack point
08:45:27 <Fuuzetsu> monochrom: we have a cool online parser!
08:45:53 <Fuuzetsu> alanz_: yes but you'd have to implement emacs as I said
08:46:02 <alanz_> Fuuzetsu, the support is a once off, emacs stuff is moving fast. And then we can ween people off emacs on to Yi
08:46:27 <Fuuzetsu> I use emacs, I'm using it right now to type this, I want absolutely no ELisp near me
08:46:33 <Fuuzetsu> I don't want emacs 2.0
08:46:38 <alanz_> But I am pretty sure it is full of horrible crufty stuff, being so old
08:46:45 <Fuuzetsu> yes, it is
08:46:57 <Fuuzetsu> also emacs stuff is horrible, look at the source for your modules one day
08:48:13 <alanz_> I know it is, but it is easier to do a gradual switch than a massive one.
08:48:43 <Fuuzetsu> implementing emacs is not a gradual switch
08:48:58 <Fuuzetsu> if we can implement more features for Yi, I personally plan to port a ton of emacs stuff
08:49:03 <alanz_> If most of the stuff I wanted worked with Yi I would use it, but realistically there is so much change happening on the established editor front that getting traction is going to be hard
08:49:21 <Fuuzetsu> right, which is why you probably want to wait
08:49:24 <alanz_> So maybe we need a elisp to haskell compiler
08:49:30 <Fuuzetsu> currenly we need hands to work hahahaha
08:49:36 <Fuuzetsu> please, no jokes
08:50:13 <monochrom> it took the Eclipse team quite a while to merely embed AWT in SWT. in comparison, embedding elisp in anything will be titanic.
08:50:21 <Fuuzetsu> it's an immense amount of work, we'd just end up with emacs with awkward interface and stupid implementation to accomodate elisp
08:50:24 <alanz_> but people won't work unless they use it. They wont use it without their favourite feature XXX. This wont come in due to lack of workers, rinse and repeat
08:50:58 <alanz_> Its more of a thought experiment than anything else, I guess.
08:51:41 <Fuuzetsu> alanz_: so let them not use it, if one is interested in Yi and wants to see it thrive then they'll come and help us develop the core; if they are only slightly interested then they'll not use it until there are modes for them to use
08:53:24 <alanz_> ok, but you may be walking a lonely path for a while .....
08:53:55 <Fuuzetsu> implementing elisp is stupid, a huge amount of effort with no advantage
08:54:14 <Fuuzetsu> alanz_: who's going to help us develop Yi if they can just plug everything in and pretend it's emacs? We don't want to make emacs
08:55:14 <alanz_> True, but if we get traction as a better emacs it could be good. But I guess the culture clash would be too much.
08:55:42 <Fuuzetsu> but it's not going to be a better emacs, it would be a bastard child of emacs with awkward interface for everything because it's actually Haskell
08:55:43 <alanz_> Some future importer of modes could be worthwhile though, but probably impractical
08:55:59 <rodlogic> dcoutts_: I just wish I had more time to really help.
08:56:00 <nitrix> Is there a command-line tool to query hackage?
08:56:09 <Fuuzetsu> nitrix: curl
08:56:09 <alanz_> Ok, I'll wind my neck in now.
08:56:27 <rodlogic> dcoutts_: :-) sorry, I guess I alread made that clear ... up+enter in the wrong window
08:56:28 <nitrix> I don't want vim plugins and openening up the browser is a pain.
08:56:50 <dcoutts_> rodlogic: :-)
08:57:18 <Fuuzetsu> alanz_: basically what I'm trying to say is that we can't try to reel people in with promise of modes because right now we need help getting the core to work properly, once that's done then writing the modes will be no problem
08:58:25 <alanz_> yes, makes sense
08:59:10 <monochrom> nitrix: does it count to use text-mode browsers? :)
09:02:52 <amf> with "type UTCTimestamp = Unbounded UTCTime", and a function of getTime :: UTCTimestamp -> UTCTime, how do i get the UTCTime value?
09:03:54 <nitrix> http://ideone.com/jU1SYl
09:04:01 <nitrix> Is there a way to make this cleaner?
09:04:11 <SwashBuckla> is there an automatic way of testing whether a functor abides by the 2 Functor Laws(TM) ?
09:04:16 <Fuuzetsu> amf: pattern match on Unbounded
09:04:26 <nitrix> vty-ui requires the user to work with Widgets when it comes to rendering, yet newButton creates an IO Button.
09:04:39 <Iceland_jack> SwashBuckla: You only need to check one law if you ignore some strictness issues
09:04:55 <Iceland_jack> because of parametricity, but you can always use QuickCheck
09:04:58 <nitrix> And you need buttonWidget to transform the Button to a Widget
09:05:06 <Fuuzetsu> nitrix: loginButtonWidget = buttonWidget <$> newButton …
09:05:16 <nitrix> Fuuzetsu: What is that <$> operator?
09:05:16 <Fuuzetsu> sorry, loginButtonWidget <- buttonWidget <$> newButton …
09:05:21 <Fuuzetsu> nitrix: infix fmap
09:05:28 <Iceland_jack> SwashBuckla: Test.QuickCheck.Function can test functions
09:05:29 <SwashBuckla> Iceland_jack: do you have an example?
09:06:20 <Iceland_jack> sure,
09:06:20 <Iceland_jack>     prop_idFunctor a = fmap id a == a
09:08:07 <Iceland_jack> if you want to test the other law (fmap (f . g) == fmap f . fmap g) you can do something like
09:08:08 <Iceland_jack>     prop_compFunctor (Fn _ f) (Fn _ g) a = fmap (f . g) a == fmap f (fmap g a)
09:08:37 <SwashBuckla> :O
09:08:40 <SwashBuckla> that's awesome
09:08:47 <c_wraith> Fortunately, in haskell, if the first one holds, the second one is automatic
09:09:02 <SwashBuckla> oh really, that's interesting
09:09:03 <Fuuzetsu> SwashBuckla: it might be easier to just reason yourself that it holds and save yourself time and resources from testing it
09:09:04 <Iceland_jack> yes, parametricity is nice :) (ignoring strictness)
09:09:11 <Fuuzetsu> especially for easy structures
09:09:30 <Iceland_jack> SwashBuckla: I added a patch so that if you have GHC 7.8 you can just pattern match on '(Fun f)', but it isn't part of QuickCheck yet
09:09:50 <Iceland_jack> Ah no sorry, I mixed them up
09:09:52 <nitrix> Fuuzetsu: It's not delared by default for me. Anything I should import?
09:10:03 <Fuuzetsu> Control.Applicative exports it
09:10:05 <Iceland_jack> Currently you have to write
09:10:06 <Iceland_jack>     prop_compFunctor (Fun _ f) (Fun _ g) = ...
09:10:07 <Fuuzetsu> Control.Functor too IIRC
09:11:10 <Iceland_jack> SwashBuckla: you may wanna read this buddy https://github.com/quchen/articles/blob/master/second_functor_law.md :)
09:12:03 * SwashBuckla reads
09:14:23 <jle`> > read "(Just) 5" :: Maybe Int
09:14:25 <lambdabot>  *Exception: Prelude.read: no parse
09:14:27 <jle`> what gives
09:14:41 <jle`> > (Just) 5 :: Maybe Int
09:14:43 <lambdabot>  Just 5
09:15:17 <Fuuzetsu> http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi now this is cool
09:15:25 <BMeph> > read "Just 5" :: Maybe Int
09:15:27 <lambdabot>  Just 5
09:15:58 <jle`> > read "Just (5)" :: Maybe Int
09:16:00 <lambdabot>  Just 5
09:16:07 <jle`> but i don't know why (Just) 5 would fail
09:16:10 <jle`> hm.
09:16:27 <tulcod> > read "(Just 5)" :: Maybe Int
09:16:28 <lambdabot>  Just 5
09:16:35 <hpc> derived read instances are a funny thing
09:16:44 <tulcod> > read "2+3" :: Int
09:16:45 <lambdabot>  *Exception: Prelude.read: no parse
09:16:47 <vanila> jle`, it's just a reader not a full blown parser
09:17:00 <jle`> but the specs say that it should allow unecessary parentheses
09:17:05 <vanila> oh really
09:17:05 <vanila> ok
09:17:15 <jle`> and also arbitrary whitespace
09:17:17 <vanila> this could be considered a bug
09:17:36 <jle`> http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Read.html#t:Read
09:19:15 <jle`> although i guess (Just) 5 is a different sort of extra parentheses than Just (5)
09:19:24 <jle`> but still
09:19:57 <hpc> i'd say it should still work with parens around the constructor
09:20:06 <hpc> > read "(5)" :: Int
09:20:08 <lambdabot>  5
09:20:22 <hpc> but it's easy to see how it would be omitted
09:20:28 <jle`> > read "(Nothing)" :: Maybe Int
09:20:29 <lambdabot>  Nothing
09:21:07 <jle`> yeah, i see why it'd be missed
09:22:07 <jle`> well
09:22:15 <jle`> Just (x) is a valid pattern, while (Just) x is not
09:22:19 <jle`> if that makes any difference
09:24:39 <mroman> > read "(Just) 5" :: Maybe Int
09:24:40 <lambdabot>  *Exception: Prelude.read: no parse
09:24:45 <mroman> > read "(Just 5)" :: Maybe Int
09:24:46 <lambdabot>  Just 5
09:24:52 <mroman> > read "((Just 5))" :: Maybe Int
09:24:54 <lambdabot>  Just 5
09:24:58 <mroman> > read "((Just (5)))" :: Maybe Int
09:25:00 <lambdabot>  Just 5
09:25:11 <mroman> read "Just $ 5" :: Mabye Int
09:25:18 <mroman> > read "Just $ 5" :: Mabye Int
09:25:19 <lambdabot>  Not in scope: type constructor or class ‘Mabye’
09:25:20 <lambdabot>  Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
09:25:25 <mroman> > read "Just $ 5" :: Maybe Int
09:25:26 <lambdabot>  *Exception: Prelude.read: no parse
09:25:36 <mroman> hm.
09:25:42 <mroman> > reads "Just $ 5"
09:25:44 <lambdabot>  []
09:25:47 <Iceland_jack> ($) is an operator
09:25:59 <mroman> > reads "Just $ 5" :: [(Maybe Int, String)]
09:26:01 <lambdabot>  []
09:26:05 <mroman> > reads "Just 5$" :: [(Maybe Int, String)]
09:26:07 <lambdabot>  [(Just 5,"$")]
09:26:16 <mroman> Iceland_jack: I know :)
09:26:29 <Iceland_jack> Just making sure
09:26:42 <mroman> > lex "Just $ 5"
09:26:44 <lambdabot>  [("Just"," $ 5")]
09:28:08 <bergey> d
09:31:49 <Fuuzetsu> This is a big problem, I'm into like 3rd year of Haskell and I still can't make up my mind on ‘x:xs’ vs ‘x : xs’; worse, I think in patterns the former style is better while on RHS the former style makes more sense…
09:32:03 <Fuuzetsu> whitespace around operators should be enforced damn it, choices are hard
09:32:51 <zomg> I just use x:xs because that's what I see being used everywhere
09:33:11 <Fuuzetsu> but look, actual code someone else wrote
09:33:13 <Fuuzetsu> alexCollectChar (_, b, (_,c):rest) = c : alexCollectChar (c,b,rest)
09:33:35 <NikolajK> could I define "data GeneralType a = GeneralType a" and write my whole code with just references to "GeneralType a"'s, never using just "a"?
09:33:36 <zomg> Yeah, I was just about to say that if it's something like that then it might make more sense to have spaces
09:33:37 <Fuuzetsu> it's worse if I'm refactoring and changing stuff around it, do I change the : style, do I leave it, oh the horror
09:33:55 <zomg> I think it's more a question of readability
09:34:00 <zomg> x:xs? works
09:34:09 <zomg> x:somethingAmazingGigaBalls not so well
09:34:28 <mroman> why not?
09:34:36 <mroman> somethingAmazingGigaBalls looks pretty much like java clean-code
09:34:42 <c_wraith> NikolajK: probably not.
09:34:51 <zomg> at a glance it's not as easy to spot the pattern of a:b especially if there's more stuff in it, like what Fuuzetsu showed
09:35:02 <NikolajK> why
09:35:34 <NikolajK> the question is motivated by thinking about the hierarchy of classes
09:36:11 <c_wraith> NikolajK: I guess it depends on what you mean.  Do you mean having all your top-level bindings have only GeneralType as their top-level constructor?  Sure.  It'd be silly, but you could do it.
09:36:23 <c_wraith> NikolajK: well, except for Main
09:36:27 <c_wraith> err, main
09:36:42 <NikolajK> I'm not completely familiar with the language
09:36:49 <NikolajK> top-level bindings
09:37:17 <c_wraith> NikolajK: name = value, not scoped inside another binding.
09:38:06 <NikolajK> the idea is to write code and always have it be
09:38:07 <NikolajK> "class GenericType a => MyNewType a where"
09:38:07 <NikolajK> avoid e.g. "class Functor f where", have it be
09:38:07 <NikolajK> "class GenericType f => MyFunctor f where"
09:38:24 <c_wraith> class and data are different
09:38:34 <c_wraith> I now have no idea what you mean
09:39:03 <NikolajK> mhm
09:39:18 <NikolajK> well I want to make every new class a subclass of another
09:39:22 <NikolajK> another named class
09:40:08 <NikolajK> the functor definition doesn't have the =>
09:40:11 <c_wraith> that can't be done.  You can't insert a class as a supertype of another class.
09:40:31 <Fuuzetsu> :t mempty `mempty` mempty
09:40:32 <lambdabot>     Could not deduce (Monoid a0) arising from a use of ‘mempty’
09:40:32 <lambdabot>     from the context (Monoid t)
09:40:32 <lambdabot>       bound by the inferred type of it :: Monoid t => t at Top level
09:41:47 <nitrix> http://ideone.com/WjZqXb
09:42:00 <nitrix> ^ Style question
09:42:12 <jle`> x:xs for patterns, x : xs for expressions
09:42:46 <jle`> x:xs for expressions sometimes >_>
09:43:17 <nitrix> `centered` and `bordered` both have type `Widget a -> IO (Widget a)` more or less, so how would I chain them without using a temporary binding?
09:43:34 <funnybutton> how do you make a function that tells you if you have an empty list?
09:43:40 <Fuuzetsu> nitrix: use >>=
09:43:42 <funnybutton> isn't there already one that is called null?
09:43:45 <jle`> nitrix: use (=<<)
09:43:47 <jle`> :)
09:43:54 <Fuuzetsu> don't listen to those =<< peoplel
09:43:55 <jle`> direct replacement of ($)
09:43:55 <zacharypch> HI i'm on day 2 of haskelling, working through "learn you a..."...  how do I deal with `> read s` where s is a string and i want to parse a Double.  I'd expect an Option or Validation type but it creates an exception on "" for example
09:44:00 <Fuuzetsu> people*
09:44:09 <nitrix> >>= or =<< ?
09:44:13 <Fuuzetsu> =<< just looks like a super sad person
09:44:19 <jle`> hehe
09:44:29 <Fuuzetsu> >>= looks like holy shit gotta bind fast
09:44:31 <jle`> (>>=) is a little nicer because the effects are ordered properly
09:44:35 <haasn> Fuuzetsu: cannot unsee
09:44:41 <Fuuzetsu> GOOD
09:44:45 <jle`> (=<<) is a little nicer because it is a drop-in replacement for ($) in your case
09:44:49 <haasn> Fuuzetsu: Cannot unsee it for >>= either
09:44:58 <Fuuzetsu> you'll live
09:45:07 <haasn> But regardless, all of these answers are incorrect/suboptimal
09:45:09 <haasn> nitrix: Use (>=>)
09:45:20 <Fuuzetsu> f >=> g $ x ;^)
09:45:21 <haasn> (Or (<=<), before I get on holy war territory)
09:45:27 <nitrix> Is >=> even a thing?
09:45:28 <enferex> Simple question.  I have a (foo . bar) where foo is type String and bar is type IO String.  How do I remove the application of bar from the IO monad so that (foo . bar) works?  I can do it in two lines, but wanted a solution inline
09:45:34 <haasn> :t (>=>)
09:45:36 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:45:39 <nitrix> What the heck.
09:45:46 <mroman> zacharypch: you could use reads
09:45:49 <Fuuzetsu> nitrix: yes, f >=> g is just \x -> f x >>= g
09:45:59 <nitrix> Ah, monads..
09:46:04 <Laquendi> +1 for >=>
09:46:07 <haasn> Plug IO into m; plug (Widget a) into a, b and c
09:46:09 <mroman> > reads "5.3" :: [(Double,String)]
09:46:11 <lambdabot>  [(5.3,"")]
09:46:19 <mroman> > reads "not a double" :: [(Double,String)]
09:46:21 <lambdabot>  []
09:46:23 <haasn> And voila, you get :: (Widget a -> IO (Widget a)) -> (Widget a -> IO (Widget a)) -> Widget a -> IO (Widget a)
09:46:28 <Fuuzetsu> hm, can we alias typeclasses yet
09:46:30 <haasn> The perfect function!
09:46:35 <Fuuzetsu> FuzzyWarmThing = Monad
09:46:37 <haasn> Fuuzetsu: class Foo a => Bar a
09:46:44 <Fuuzetsu> mhm
09:46:46 <haasn> Fuuzetsu: Or set ConstraintKinds and use type Bar = Foo
09:46:53 <c_wraith> :t readMaybe
09:46:54 <lambdabot> Not in scope: ‘readMaybe’
09:46:54 <haasn> Might need FlexibleContexts too
09:46:57 <haasn> And probably also TypeSynonymInstances
09:47:13 <Fuuzetsu> oh, what's that extension that lets you do stuff like type Foo a = (Bar a, Baz a) ; f :: Foo m => …?
09:47:20 <haasn> ConstraintKinds
09:47:21 <BMeph> enferx: Unless you have a different definition of '.', then that isn't "a simple question. ;)
09:47:23 <zacharypch> mroman : should I interpret that type as a list containing a 2 tuple?
09:47:30 <BMeph> "
09:47:42 <enferex> BMeph: thanks, i feel a bit more redeemed now
09:48:22 <Fuuzetsu> putting things on the same line as ‘where’ should be illegal, discuss
09:48:24 <mroman> zacharypch: It's a list containing a tuple
09:48:27 <haasn> enferex: That doesn't really make sense, (.) is used to compose functions; neither String nor IO String are functions
09:48:37 <mroman> @type reads
09:48:38 <lambdabot> Read a => ReadS a
09:48:49 <haasn> Fuuzetsu: Stop murdering my vertical space
09:49:05 <Fuuzetsu> stop holocausting my 80C
09:49:06 <mroman> I just know how to use reads. I have no idea what black magic is going on behind it
09:49:24 <mroman> @info ReadS
09:49:25 <lambdabot> ReadS
09:49:31 <mroman> Gee. thx :D
09:49:40 <haasn> Fuuzetsu: I only do that on haddock because haddock already goes into 200c or whatever :^)
09:49:48 <jle`> nomeata: compare the type signature of ($) with (=<<)
09:49:53 <Fuuzetsu> haasn: patches welcome
09:49:56 <jle`> ($) :: (a -> b) -> a -> b
09:49:59 <Fuuzetsu> I fix it up when I touch stuff
09:50:05 <jle`> (=<<) :: (a -> m b) -> m a -> m b
09:50:08 <haasn> Fuuzetsu: I already submitted patches breaking down all of the endless type signatures into multiple lines!
09:50:10 <dfeuer> When I type  _^7/100, I get "Found hole '_' with type: a
09:50:12 <jle`> it's basically the same thing, except with m b
09:50:15 <Fuuzetsu> haasn: where
09:50:15 <jle`> instead of b
09:50:20 <haasn> Fuuzetsu: Backend.Xhtml.Decl
09:50:25 <jle`> er, with an (a -> m b) instead of an (a -> b)
09:50:25 <Fuuzetsu> in those recent commits?
09:50:29 <haasn> nah
09:50:30 <haasn> ages ago
09:50:34 <Fuuzetsu> did I merge it
09:50:45 <dfeuer> I don't get that. Shouldn't there be a Fractional constraint on that?
09:51:19 <jle`> yeah um holes are still kinda weird
09:51:45 <zacharypch> mroman, ha i think i get it - it looks like it's giving me either `[]` or `[(2.2, "")], whats the point of the String part?
09:51:53 <jle`> try > _ / 100
09:51:57 <jle`> > _ / 100
09:51:58 <lambdabot>  Found hole ‘_’ with type: a
09:51:58 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:51:58 <lambdabot>             the inferred type of it :: a at Top level
09:52:02 <dfeuer> Nope.
09:52:02 <Fuuzetsu> haasn: you know the true holy war, the comma style on records and lists
09:52:23 <jle`> i don't think there is really a war in haskell, the winner is sort of decided
09:52:37 <jle`> unless you mean on one line
09:52:40 <haasn> I thought we *all* agreed on that being { foo\n, bar\n, bat\n}
09:52:44 <Fuuzetsu> tell that to people who put it after items
09:52:51 <jle`> find me some :P
09:52:53 <enferex> haasn: sorry, foo and bar are both functions, bar returns IO String and foo takes as input a String
09:53:04 <jle`> enferex: what is the type of the operator you desire?
09:53:14 <haasn> enferex: Then you probably want ‘fmap’
09:53:15 <Fuuzetsu> jle`: Yi code, Haddock code, anything Twey writes…
09:53:18 <haasn> or <$> in operator form
09:53:20 <haasn> :t (<$>)
09:53:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:53:26 <haasn> let f = IO, a = String
09:53:28 * Fuuzetsu changes with prejudice
09:53:33 <enferex> haasn: thanks
09:53:40 <haasn> This makes the type of (foo <$> bar) :: IO whateverfooreturns
09:53:46 <haasn> Oh, wait
09:53:47 <haasn> bar is a function too
09:53:52 <haasn> Then fmap foo . bar
09:54:04 <dfeuer> jle`, do type holes just not handle class constraints in 7.8.3?
09:54:06 <haasn> Either way, fmap foo :: IO String -> IO whateverfooreturns
09:54:09 <haasn> So you can compose them like that
09:54:09 <jle`> :t \op -> (foo :: String -> b) `op` (bar :: a -> IO String)
09:54:10 <lambdabot>     Not in scope: ‘foo’
09:54:11 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
09:54:11 <lambdabot>     Not in scope: ‘bar’
09:54:17 <BMeph> zacharypch: The string shows what's left after parsing out the first part of the pair.
09:54:25 <jle`> :t \op -> (undefined :: String -> b) `op` (undefined :: a -> IO String)
09:54:26 <lambdabot> ((String -> b) -> (a -> IO String) -> t) -> t
09:54:37 <jle`> ok that didn't turn out like i expected
09:54:58 <dfeuer> Hmm... Not in ~HEAD either, actually.
09:55:01 <enferex> jle`: thanks
09:55:02 <jle`> if you want to compose a (b -> c) and a (a -> b), use (.)
09:55:36 <jle`> if you want to compose a (b -> m c) and a (a -> m b) use (<=<)
09:55:46 <jle`> if you want to compose a (b -> c) and a (a -> m b), use....
09:56:05 <zacharypch> BMeph: interesting, so if the string starts with a double it works and puts the remaining junk in the String, but if it starts with junk then it gives me []
09:56:05 <jle`> i am draw blank
09:56:15 <zacharypch> i guess that makes sense, ok back to the book, thanks guys
09:56:35 <jle`> probably because i haven't written any haskell for three weeks >_>
09:56:43 <jle`> vacation kills the brain
09:56:59 <dfeuer> > _ >>= return 4
09:57:01 <lambdabot>  Found hole ‘_’ with type: m a0
09:57:01 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
09:57:01 <lambdabot>         ‘m’ is a rigid type variable bound by
09:57:01 <lambdabot>             the inferred type of it :: m b at Top level
09:57:13 <dfeuer> > _ >>= return (4::Int)
09:57:14 <lambdabot>  Couldn't match type ‘m b’ with ‘GHC.Types.Int’
09:57:15 <lambdabot>  Expected type: a0 -> m b
09:57:15 <lambdabot>    Actual type: a0 -> GHC.Types.Int
09:57:42 <dfeuer> > _ >> return (4::Int)
09:57:43 <lambdabot>  Found hole ‘_’ with type: m a0
09:57:44 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
09:57:44 <lambdabot>         ‘m’ is a rigid type variable bound by
09:57:44 <lambdabot>             the inferred type of it :: m GHC.Types.Int at Top level
09:57:46 <hpc> > _ >> return (4 :: Int)
09:57:47 <lambdabot>  Found hole ‘_’ with type: m a0
09:57:47 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
09:57:48 <lambdabot>         ‘m’ is a rigid type variable bound by
09:57:49 <lambdabot>             the inferred type of it :: m GHC.Types.Int at Top level
09:57:58 <dfeuer> Not very useful.
09:58:17 <jle`> :t fmap (undefined :: String -> b) . (undefined :: a -> IO String)
09:58:18 <lambdabot> a -> IO b
09:58:23 <jle`> there ya go
09:58:25 <jle`> fmap foo . bar
09:59:31 <Twey> Fuuzetsu: Actually I'm using before for now too
09:59:37 <Twey> Fuuzetsu: Ending brace on the same line, though ;)
09:59:52 <Fuuzetsu> why
09:59:57 <Twey> haasn: What is the point of that?  I don't understand.
10:00:20 <haasn> Twey: hm?
10:00:37 <Twey> Fuuzetsu: Because I don't like spending a whole line on one character :þ
10:01:07 <haasn> Alignment trumps saving vertical space
10:01:13 <NikolajK> the Haskell wiki often defines a class an then goes "it should also satisfy" and then conditions which aren't necessarily enforced like "pure id <*> v = v". They also write this in a code block. Like "fmap id  ==  id". Can I write this "fmap id  ==  id" into a file and compile the code? If not, what about "fmap id  =  id"?
10:01:27 <NikolajK> and I'm not speaking about Functor here, but generally.
10:01:27 <haasn> The #1 rule of haskell style guides should be “align all the things”
10:01:31 <haasn> and the #2 rule “ALL the things.”
10:01:41 <jle`> NikolajK: well, you can't write expressions at the top level
10:01:51 <Twey> Haha
10:01:57 <jle`> but fmap id == id woudln't compile as an expression
10:02:00 <jle`> because
10:02:03 <jle`> :t id
10:02:04 <lambdabot> a -> a
10:02:13 <jle`> ther eis no Eq instance for (a -> a)
10:02:19 <haasn> jle`: It can
10:02:25 <jle`> oh
10:02:31 <haasn> Well, in theory
10:02:48 <haasn> You don't need an Eq instance for (a -> a); you need it for (f a -> f a)
10:02:55 <jle`> oh yes ofc
10:03:05 <jle`> i guess you could define a silly one
10:03:20 <haasn> It makes sense for some ‘f’s, but then you'd probably need a type annotation to select the instance
10:03:33 <haasn> None of this is related to what NikolajK wanted to know, though
10:03:45 <jle`> i'm not sure what he is asking, exactly
10:04:03 <haasn> NikolajK: When people write that, they are not really writing literal Haskell code, more like pseudolanguage to demonstrate “equivalences” (not observed in Haskell itself)
10:04:05 <jle`> fmap id = id is a valad declaration
10:04:10 * hackagebot wl-pprint-terminfo 3.7.1.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1.1 (EdwardKmett)
10:04:23 <haasn> NikolajK: For example, we can say that (\x -> 1) == const 1
10:04:47 <haasn> And when I do this I do not mean that evaluating “(x -> 1) == const 1” in Haskell will produce any sensible result, if at all
10:04:54 <haasn> The == is meant to be taken more literally
10:05:26 <haasn> In this kind of context, that you can replace one by the other without changing semantics of your program
10:05:39 <haasn> Same goes for ‘fmap id == id’ - we mean that replacing ‘fmap id’ by ‘id’ shouldn't change the semantics of your program, ever
10:05:47 <jle`> perhaps it would be more clear to say "`fmap id` isalways replaceable by `id`"
10:05:59 <haasn> (And vice versa! Although this only holds true if they have the same type)
10:05:59 <jle`> instead of using tue (==) shorthand
10:06:08 <haasn> (For both directions, that is)
10:06:21 <jle`> but actually for some typeclasses, the (==) shorthand can actually be a valid expression that is throawable into quickcheck
10:06:33 <haasn> jle`: Right, but it's a convenience especially if trying to prove an equivalence over multiple lines
10:06:51 <jle`> maybe a different symbol than (==) is to be called for then
10:06:59 <haasn> =
10:07:19 <jle`> <-->
10:07:24 <jle`> hm, that is also a valid operator
10:07:32 <haasn> = is fine. They are equal; = is also not a valid operator
10:07:41 <jle`> oh i was referring to (<-->)
10:07:57 <jle`> = carries a bit of baggagethough, as it is a part of bhaskell syntax
10:08:25 <NikolajK> so generally, are there any of the "laws" which can be enforced completely be literally defining them as function declarations
10:09:02 <jle`> well the language doesn't allow any syntax constructs for specifying properties/laws that instances have to satisfy
10:09:29 <jle`> you can enforce some guaruntees to some extent by encoding the laws into the type signatures, if possible
10:09:57 <NikolajK> I take notes on type classes and am not sure how to write things down
10:10:07 <jle`> but how could a compiler prove (fmap id == id) and (fmap f . fmap g == fmap (f . g)) are equivalent for all f and g?
10:10:14 <NikolajK> writing stuff in code blocks like on the wiki is confusing
10:10:36 <jle`> at least in haskell
10:11:15 <jle`> these are things you can work out by hand
10:11:45 <jle`> fmap id (Just x) = Just (id x) = Just x = id (Just x)
10:11:56 <jle`> fmap id Nothing = Nothing = id Nothing
10:12:30 <shachaf> Twey: "subtyping"?
10:12:55 <shachaf> Twey: You can use (x :: forall a. a) as (x :: Int) or (x :: Char) or anything else.
10:13:12 <jle`> fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) = Just ((f . g) x) = fmap (f . g) (Just x)
10:13:25 <shachaf> Similarly if existentials existed exists a. a would be at the top.
10:13:34 <jle`> fmap f (fmap g Nothing) = fmap f Nothing = Nothing = fmap (f . g) Nothing
10:13:52 <Twey> shachaf: With an implicit application, sure
10:13:54 <Twey> Hm
10:13:54 <jle`> but it's a bit of a tall order to ask the compiler to make those proofs wheneve you declar an instance
10:14:06 <shachaf> And you could say (forall a. a) <= (forall a. C a => a) and (forall a. a) <= (forall a. D a => a)
10:14:19 <funnybutton> where are some exercises for beginning programmers learning Haskell?
10:14:20 <Twey> I wonder if it would be nice to use the implicit calculus or something like it in cases like these
10:14:52 <Twey> funnybutton: There are some scattered about LYAH, some bigger projects to follow along with in RWH, or you can use http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems perhaps
10:14:59 <jle`> funnybutton: the exercises from the NICTA course is hot as of late
10:15:07 <jle`> s/is/are
10:15:32 <jle`> exercises
10:15:40 <vanila> @googl NICTA course
10:15:41 <lambdabot> Maybe you meant: google googleit
10:15:56 <haasn> NikolajK: There are some laws Haskell can enforce, but many it cannot
10:16:44 <haasn> But one difficulty with enforcing any law in Haskell is the fact that you can substitute “undefined :: a” for anything, so something “compiling” doesn't necessarily mean it makes any sense at all
10:17:27 <NikolajK> on haskell.org/haskellwiki/Functor, they start out with "import http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t%3AFunctor". Isn't Functor so important that one would expect it to be definable without importing anything in the language?
10:17:46 <haasn> Functor is part of Prelude, isn't it?
10:17:57 <Twey> It is
10:18:11 <funnybutton> @google nicta course
10:18:12 <lambdabot> https://github.com/NICTA/course
10:18:25 <Twey> I don't know what that import is there for
10:18:38 <Twey> It isn't used anywhere in the page
10:18:52 <haasn> Perhaps cannibalized from a different page involving Monads as well
10:18:57 <haasn> And forgotten
10:18:58 <Twey> And the functor stuff is in Data.Functor anyway
10:19:01 <Twey> Perhaps
10:19:22 <haasn> Somebody should also add that fmap id = id implies the second law, because it makes defining instances much easier
10:19:34 <Twey> Oh, it's part of the template
10:19:36 <Twey> {{Standard class|Functor|module=Control.Monad|module-doc=Control-Monad|package=base}}
10:19:58 <Twey> Does it?
10:20:16 <haasn> Which part of the statement is that a response to?
10:20:26 <Twey> The first law implying the second
10:20:44 <haasn> https://github.com/quchen/articles/blob/master/second_functor_law.md
10:21:24 <shachaf> Someone should prove that's always true.
10:22:13 <haasn> Twey: But see the caveat at http://stackoverflow.com/questions/8305949/haskell-functor-implied-law/8323243#8323243
10:23:02 <NikolajK> do you guys edit the Wiki?
10:23:06 <shachaf> There's a caveat other than seq, which is that that free theorem assumes that F is a functor.
10:23:27 <NikolajK> I don't know which role/status the freenode channel has in the Haskell community - where is the who's who
10:23:38 <shachaf> That's fine when you're trying to implement fmap for something which you already know is a functor. But it doesn't help for proving it's a functor.
10:23:53 <Fuuzetsu> I had a dream where where Data.Functor was replaced with Control.Functor
10:24:02 <vanila> NikolajK, /msg chanserv access #haskell list
10:24:08 <haasn> shachaf: Does that mean you can make a type constructor F (that can't be a valid instance of Functor) with an implementation that follows the first law but not the second?
10:24:18 <shachaf> haasn: Probably not.
10:24:22 <haasn> What about if F *can* be made a functor?
10:24:35 <haasn> (In both, assuming we don't use seq/⊥ stuff)
10:24:45 <Twey> NikolajK: Anyone with an account can edit the wiki
10:24:53 <shachaf> If F is a functor, then the free theorem holds and you can use that reasoning.
10:25:26 <haasn> Does the free theorem have any connection to contravariant functors, by the way?
10:26:13 <shachaf> For (most) contravariant functors you can't write an fmap with that type in the first place.
10:26:41 <haasn> Right, but can it be used to prove that contramap id = id implies contramap f . contramap g = contramap (g.f) for things that are known contravariant functors?
10:26:43 <shachaf> But I'd assume a similar-looking contravariant free theorem holds.
10:27:05 <haasn> I don't know if duality applies here. What's Hask's dual?
10:27:15 <jidi> I am seek  for a partner
10:27:38 <SwashBuckla> > [(+),(*)] <*> [1,2] <*> [3,4]
10:27:39 <lambdabot>  can't find file: L.hs
10:27:48 <Iceland_jack> SwashBuckla: try again
10:27:54 <SwashBuckla> > [(+),(*)] <*> [1,2] <*> [3,4]
10:27:56 <lambdabot>  can't find file: L.hs
10:28:00 <Iceland_jack> (once more!)
10:28:00 <haasn> They still haven't fixed that bug :(
10:28:05 <SwashBuckla> ....
10:28:21 <SwashBuckla> > [(+),(*)] <*> [1,2] <*> [3,4]
10:28:23 <lambdabot>  [4,5,5,6,3,4,6,8]
10:28:29 <shachaf> haasn: A Contravariant is a functor : Hask^op -> Hask
10:28:31 <Iceland_jack> (third time's the charm)
10:28:48 <mroman> is that
10:28:55 <jidi> I am seek  for a partner
10:28:58 <haasn> Is ‘mueval’ maintained at all? I created a ticket pointing out the line causing the L.hs bug but it doesn't seem to have been responded to
10:29:05 <mroman> > [(x+y),(x*y),x<-[1,2],y<-[3,4]]
10:29:07 <lambdabot>  <hint>:1:15: parse error on input ‘<-’
10:29:12 <mroman> > [(x+y),(x*y)|x<-[1,2],y<-[3,4]]
10:29:14 <lambdabot>  <hint>:1:13: parse error on input ‘|’
10:29:16 <jidi> I am seek  for a partner
10:29:25 <mroman> > [((x+y),(x*y))|x<-[1,2],y<-[3,4]]
10:29:26 <Iceland_jack> > [(x+y,x*y)|x<-[1,2],y<-[3,4]]
10:29:26 <lambdabot>  [(4,3),(5,4),(5,6),(6,8)]
10:29:28 <lambdabot>  [(4,3),(5,4),(5,6),(6,8)]
10:29:53 <mroman> hm. the order is wrong
10:30:02 <SwashBuckla> what is going on in the code I pasted?
10:30:15 <Iceland_jack> SwashBuckla: that's the ((->) r) instance for applicative
10:30:17 <SwashBuckla> I don't see how the result is produced
10:30:20 <SwashBuckla> > [(+),(*)] <*> [1,2] <*> [3,4]
10:30:22 <lambdabot>  [4,5,5,6,3,4,6,8]
10:30:31 <haasn> Iceland_jack: No, it's the [] instance for Applicative
10:30:32 <Iceland_jack> SwashBuckla: take the type (<*>) and replace every f with ((->) r)
10:30:34 <Iceland_jack> ooh
10:30:43 <Iceland_jack> yes yes, absolutely
10:30:54 <Iceland_jack> @ty (<*>)
10:30:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:30:57 <haasn> > [(+),(*)] <*> [a,b] <*> [x,y] -- SwashBuckla
10:30:59 <lambdabot>  [a + x,a + y,b + x,b + y,a * x,a * y,b * x,b * y]
10:31:07 <Iceland_jack> So take my previous advice and replace every ((->) r) with [] ;)
10:31:48 <haasn> > [f,g] <*> [x,y]
10:31:50 <lambdabot>  No instance for (GHC.Show.Show b0)
10:31:50 <lambdabot>    arising from a use of ‘M881195985753295722524734.show_M8811959857532957225...
10:31:50 <lambdabot>  The type variable ‘b0’ is ambiguous
10:31:50 <lambdabot>  Note: there are several potential instances:
10:31:50 <lambdabot>    instance [safe] GHC.Show.Show
10:32:00 <haasn> > [f,g] <*> [x,y] :: [Expr]
10:32:02 <lambdabot>  [f x,f y,g x,g y]
10:32:17 <SwashBuckla> I can unpick the expression and arrive at
10:32:19 <SwashBuckla> > [(1+),(2+),(1*),(2*)] <*> [3,4]
10:32:21 <lambdabot>  [4,5,5,6,3,4,6,8]
10:32:30 <SwashBuckla> but how do I get that answer?!
10:33:13 <haasn> [1+3, 1+4, 2+3, 2+4, 1*3, 1*4, 2*3, 3*4]
10:33:20 <haasn> Just go one step further
10:33:30 <SwashBuckla> ah
10:33:34 <SwashBuckla> of course
10:33:39 <SwashBuckla> I just wasn't seeing it :\
10:34:03 <shachaf> haasn: So what's the "free theorem" for a contravariant type?
10:34:14 <haasn> shachaf: I don't really know what the “free theorem” states
10:34:16 * hackagebot friday 0.1.1 - A functionnal image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.1.1 (RaphaelJavaux)
10:35:11 * haasn looks at the paper
10:35:19 <shachaf> Usually, that something or other is a natural transformation. Or something.
10:41:21 <SwashBuckla> wot
10:45:58 <haasn> If the free theorem for covariant types of map g . f = f . map g, then I assume the only logical free theorem for contravariant types would be contramap g . f = f . contramap g
10:46:11 <haasn> (If it holds)
10:46:33 <haasn> The free theorem just states that you can commute polymorphic functions with maps, after all; so it would make sense to claim that you can commute polymorphic functions with contramaps
10:47:46 <shachaf> Yes.
10:48:03 <haasn> Applying this to newtype Contra b a = Contra (a -> b); with contramap f (Contra g) = Contra (g . f)
10:49:28 <theli0nheart> Hi all, running into a "No instance for (Monad 'm')" when trying to compile a module to access a remote API--can't seem to crack what's wrong. I'm a bit new at this :) http://lpaste.net/3790539720845426688
10:49:32 <glguy> Anyone know how to tell Vim that the single quote is part of a "word"
10:50:41 <glguy> theli0nheart: Try putting a type signature on "errorHandler"
10:50:48 <glguy> and see if that helps isolate the error
10:52:13 <theli0nheart> glguy: giving that a shot right now...
10:53:15 <Laquendi> glguy: set iskeyword+='
10:53:35 <haasn> Hmm, not really sure how to relate that to anything with Contra without invoking the postulated free theorem itself
10:53:56 <glguy> Laquendi: Thanks
10:54:00 <theli0nheart> glguy: tried errorHandler :: HTTPClient.HttpException -> IO (HTTPClient.Response LBS.ByteString)
10:54:21 <theli0nheart> glguy: still seeing the same compilation error...hrmmm
10:54:40 <shachaf> haasn: Well, the same goes for free theorems in general, right?
10:55:28 <glguy> theli0nheart: If HTTPClient.Response isn't a Monad, you can't construct one with "return"
10:55:35 <Welkin> has anyone implemented collision detection using netwire?
10:55:38 <platz> so, codensity is a lot like difference lists?  it doesn't have execute recursively, but it still builds up a series of thunks, which is guess if ok if you only run the monad once
10:55:52 <haasn> I'm not really sure how the article goes on to derive the free theorem for fmap, but I'll have to look at it later
10:56:25 <platz> and you loose the ability to write different "interpreters" for the monad, it just executes
10:56:37 <platz> because there is no longer any pattern matching on the bind op
10:56:42 <glguy> theli0nheart: so     return (return (transform "")) isn't going to have type:   IO (Response ByteString)
10:57:37 <theli0nheart> glguy: yikes. I assumed it was a monad...I probably should've checked! this makes sense. now I guess the question is how to wrap the ByteString in a Response...
10:57:55 <glguy> theli0nheart: This was your clue ;-)  --     No instance for (Monad HTTPClient.Response)
10:58:43 <glguy> theli0nheart: No, you probably don't want to wrap it in a Response, you want to consume the response in the case you have one and produce an ouput and then produce that same output in the case that it failed
10:59:00 <theli0nheart> glguy: heh. looking back on it, that makes perfect sense, not sure how I misinterpreted that. :)
10:59:02 <glguy> theli0nheart: Maybe that means returning an empty bytestring or the response bytestring, or it means returning a Maybe Response or something else
11:00:48 <theli0nheart> glguy: gotcha...this may be a quirk of the library I'm using too...it does not seem possible to re-construct the Response (unless I am just being silly)
11:01:22 <theli0nheart> glguy: http://hackage.haskell.org/package/http-streams-0.3.1.0/docs/Network-Http-Client.html#t:Response
11:02:45 <Laquendi> Welkin: really simple and bad one
11:04:50 <athan> Does anyone know if there's a #typesystems or #typetheory channel that's popular? Maybe even one for ML?
11:07:47 <athan> A monotone map is an equivalence that maintains the partial ordering of values in expressions/sub-expressions, correct? So if `f _|_ <= f x`, and `foo $ f _|_ <= foo $ f _|_`, would foo be monotone?
11:12:13 <lpaste> bitemyapp pasted “yissssss” at http://lpaste.net/109888
11:12:26 <bitemyapp> hrm.
11:14:17 <monochrom> athan: I think the word "equivalence" is wrong. why not just say "map" there?
11:14:21 * hackagebot gitit 0.10.5 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.5 (JohnMacFarlane)
11:15:05 <monochrom> and "expression/sub-expressions", why not just "argument"?
11:15:10 <NikolajK> @djinn MM -> Bool
11:15:11 <lambdabot> Error: Undefined type MM
11:15:25 <NikolajK> @djinn Int -> Bool
11:15:25 <lambdabot> Error: Undefined type Int
11:16:12 <monochrom> the examples are of course correct
11:16:40 <naudiz> I need an advise on recursive dependencies :/
11:16:59 <monochrom> a programming language cannot let you write non-monotone functions. every computable function is monotone.
11:17:03 <athan> monochrom: I think you're right in both proposals, I'm new to this! :/
11:17:19 <athan> That's interesting!
11:17:34 <naudiz> I've got a class and each instance of this class is its own module... but all instances need to know each other... so what to do about it?
11:17:43 <monochrom> I am assuming that the partial order used is the "information order", which is what you use too.
11:18:26 <athan> monochrom: Yes, you're exactly right. I didn't know how else to express it
11:18:43 <naudiz> I don't really want to put everything in just one file... are there other ways to deal with it?
11:19:27 <athan> monochrom: Wouldn't that imply that fully-featured haskell isn't technically a programming language, then?
11:19:51 <monochrom> fully-featured haskell is still a programming language. all writable functions are monotone.
11:19:57 <barrucadu> naudiz: Does every instance really need to know about every other instance?
11:20:10 <athan> monochrom: Even if you mess around with strictness or `const`?
11:20:16 <monochrom> yes
11:20:24 <mroman> what's "fully-featured"?
11:20:26 <athan> hm!! Thank you!
11:21:07 <naudiz> barrucadu: they need to know about each other pairwise. if A knows about B, then B needs to know about A. But B may also need to know about C and C about B. It's kind of a graph-like structure
11:21:56 <athan> mroman: ...nevermind. lol
11:21:59 <monochrom> tell me one cycle in the graph
11:22:23 <monochrom> err, I guess you just did.
11:23:07 <naudiz> monochrom: it's about replacing one instance by another in runtime to handle functions in a different way
11:25:22 <Laquendi> naudiz: could you make another module for the relation like ArelB BrelC etc.
11:25:37 <athan> In some texts, I keep seeing /pi_1, /pi_2 (in the context of value recursion in monadic computations, specifically). What exactly is /pi, when related to fixpoints? What meaning does it have? I feel like it's a critical piece
11:25:54 <mroman> A Haskell that has *all* the features isn't a programming language?
11:26:31 <athan> mroman: How experienced are you?
11:26:37 <Cale> athan: Which texts?
11:26:39 <athan> in haskell I mean
11:26:47 <monochrom> perhaps pi_1 is fst, pi_2 is snd
11:27:39 <naudiz> Laquendi: I'll give it a try
11:27:41 <mroman> athan: I can turn on my computer.
11:27:41 <athan> monochrom: Ahhhh, I think you're right. Cale: The one I'm reading is "Value Recursion in Monadic Computations", by Erkok, but I've seen it before
11:28:07 <mroman> I can write some simple stuff in Haskell
11:28:14 <mroman> Today I wrote something using Happstack
11:28:40 <Cale> yeah, that's definitely the first and second projections
11:28:43 <athan> mroman: Okay, nevermind what I said, then. I was trying to theorize proper deducability, and the monotone mapping property seems to be critical to the definition of a "programming language", so I was just toying around
11:28:54 <athan> er
11:28:55 <athan> yeah
11:29:04 <athan> awesome, thanks Cale :)
11:29:24 <monochrom> my http://www.haskell.org/haskellwiki/MonadFix is a good start on what mfix does, from the user's point of view. however, the paper is where you see how it can be done internally
11:29:27 <athan> Cale: Have you looked into pi calculus?
11:29:32 <Laquendi> naudiz: tell me how it went, if you get something done :)
11:29:35 <Cale> A little
11:29:44 <Cale> That's a very different kind of pi :)
11:29:52 <athan> I'm getting into spi-calculus right now :)
11:30:05 <NikolajK> what's not in djinn?
11:30:13 <NikolajK> I mean, what's "not" in djinn
11:30:14 <athan> I want to see if I can make some good modeling for web applications and distributed systems based on it
11:30:29 <athan> or something like it, at least :S
11:30:45 <nshepperd> in order to not prove that haskell is uncomputable, I suppose you might consider a non-strict function taking an argument to be a "real" function taking a thunk? does that work?
11:30:46 <athan> @djinn a -> b
11:30:46 <lambdabot> -- f cannot be realized.
11:31:13 <monochrom> spy-calculus is something you can tell me but then you will have to kill me :)
11:31:39 <athan> monochrom: That's a perfect name
11:31:49 * monochrom loves puns!
11:31:54 <athan> :V
11:32:09 <naudiz> Laquendi: I guess I'll have to redesign my project tree first :S but it's actually my game for ld48, if I don't remember telling you, I might have surrendered but you can look it up here if you want :) http://hg.ki-omniarts.de/ld48-2014
11:32:10 <Iceland_jack> They feel like punishment to me
11:32:17 * MP2E loves puns too
11:32:23 <monochrom> @quote monochrom CCCP
11:32:23 <lambdabot> monochrom says: in Soviet Russia, you have current-continuation-calls-procedure (CCCP)
11:32:25 <NikolajK> there is no empty type, so…
11:32:37 <benzrf> monochrom: thats perfect
11:32:39 <Iceland_jack> hah
11:33:16 <athan> Iceland_jack: That's the ultimate pun
11:33:33 <athan> HA HA HA HA HA *beep boop*
11:33:43 <theli0nheart> li/quit
11:33:49 <Cale> monochrom: I assume you're aware of http://apotheca.hpl.hp.com/ftp/pub/DEC/SRC/publications/ma/spi-dist2.pdf
11:34:07 <monochrom> I am not. haha
11:34:15 <monochrom> oh w00t Andrew Gordon!
11:34:23 * hackagebot poppler 0.13 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.13 (IanWooKim)
11:34:24 <Iceland_jack> athan: For what it's worth (regarding the earlier topic), there are 3 too many notations for the fst/snd projections
11:34:30 <monochrom> Abadi is also a big name
11:34:53 <athan> Iceland_jack: I'll live :) thanks for the heads up!
11:35:18 <yesthisisuser> Is MissingH considered "evil" or something?
11:35:57 <Welkin> athan: how did your interview go?
11:36:15 <pyon> Say I am implementing a language using Haskell. (For example, any of the systems described in TAPL.) Using Data Types à la Carte, would it be possible to add new features to an existing language in a modular fashion?
11:36:21 <athan> Welkin: =/
11:36:27 <athan> my hopes aren't high on that one
11:36:49 <Welkin> athan: there are always others
11:36:51 <athan> I'm working on a portfolio website now, hopefully that'll land me a good one
11:36:53 <Iceland_jack> pyon: Sure, you may want to look at compdata if you want to go down that path
11:37:01 <athan> Welkin: Yeah :)
11:37:14 <pyon> Iceland_jack: Ah, thanks!
11:37:46 <Twey> pyon: http://stackoverflow.com/questions/21394879/how-would-you-abstract-away-the-boilerplate-in-this-pair-of-similar-shaped-dat/21397322#21397322
11:37:49 <athan> pyon: TAPL? o.O
11:37:54 <Twey> (look, my one decent SO answer)
11:38:00 <pyon> Twey: Checking.
11:38:02 <Iceland_jack> Types and Programming Languages
11:38:13 <athan> lol
11:38:17 <athan> derp
11:38:21 <athan> sorry
11:38:28 <Iceland_jack> Speaking of puns
11:38:37 <arianvp> chrisdone:  Got my interpreter working :D
11:38:41 <Iceland_jack> APL stands for 'a programming language'
11:38:43 <arianvp> I chose for the Reader approach though
11:38:47 <Iceland_jack> so TAPL could stand for 'the APL'
11:39:08 <arianvp> Iceland_jack: needs more recursive definitions
11:39:12 <arianvp> :)
11:39:24 <Iceland_jack> I'm only human
11:39:33 <NikolajK> It appears you must replace p->absurdum with p->q, but it doesn't matter if you never use q in a non-"->q" way
11:39:39 <Iceland_jack> (who is bad a recursive definitions)
11:39:40 <arianvp> I wish APL stood for  APL Programming Language
11:39:44 <arianvp> :(
11:40:13 <athan> I wish we had a unicode for fix, or banana brackets or something
11:40:41 <Iceland_jack> athan: Y?
11:40:48 <Iceland_jack> (that's both a question and an answer)
11:41:03 <athan> >o< How did I miss that??
11:41:08 <athan> what about unfolds? :)
11:41:22 <NikolajK> in fact I complained about a related point here http://math.stackexchange.com/questions/606597/how-or-why-does-intutionistic-logic-proof-negations-from-within-the-theory-cons
11:41:25 <Iceland_jack> unfolds have a notation
11:41:26 <Twey> Y isn't allowed because case distinctions…
11:41:39 <athan> :/
11:41:59 <Iceland_jack> If you're talking Haskell I don't see what the problem is with typing 'fix'
11:42:19 <athan> Iceland_jack: I was talking about acronyms lol
11:42:20 <Iceland_jack> You can define
11:42:21 <Iceland_jack>     (•) = fix
11:42:21 <Iceland_jack> and use if postfix (fact•)
11:42:33 <athan> !!!
11:43:06 <monochrom> athan: usually the Greek letter μ is used for fix
11:43:12 <Twey> NikolajK: If you like, you can think of 0 as the proposition ‘this theory is inconsistent’
11:43:25 <athan> monochrom
11:43:32 <athan> monochrom: ahh okay,
11:43:39 <athan> >< fingers
11:43:40 <triliyn> Iceland_jack: that requires an extension I think
11:43:42 <Iceland_jack> You can use both μ and ν in Haskell athan :)
11:43:45 <Iceland_jack> triliyn: yes
11:43:59 <Twey> NikolajK: So, a constructive proof that ¬A is a function that will take you from an A to a proof of inconsistency, which is constructive in the usual sense of functions with hypotheses
11:44:01 <Iceland_jack> since they coincide
11:44:15 <athan> That's awesome!
11:44:27 <monochrom> this brings us to my great invention http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
11:44:28 <arianvp|afk> I dont get why people use 'qualified'  imports
11:44:30 <Twey> It's a bit evil, actually >.>
11:44:34 <arianvp|afk> why doesnnt just  'as' suffice?
11:44:42 <arianvp|afk> in that case non-colliding names can be accessed as normal
11:44:50 <arianvp|afk> and colliding names  with a  prefix
11:44:51 <arianvp|afk> :/
11:45:07 <Twey> arianvp|afk: One big advantage of ‘qualified’ is that a package imported qualified can never break your code by introducing new names
11:45:20 <Iceland_jack> arianvp|afk: collision of non-qualified libraries
11:45:22 <athan> Or the sharingan operator: ҉
11:45:26 <arianvp|afk> hmm
11:46:11 <Twey> > let ( ҉) = fix; f = show in f҉
11:46:13 <lambdabot>  <hint>:1:7: lexical error at character '\1161'
11:46:18 <Twey> Damn ☹
11:46:29 <athan> :P
11:46:34 <dmj`> woa
11:46:36 <NikolajK> Twey: you give this 0 a logical interpretation, but it's no a computational object. It's not like the logical rule that from 0 follows everything can be translated to a type or something, no?
11:46:44 <dmj`> ҉҉ ҉҉҉҉
11:46:48 <NikolajK> or something which lets you compute anything
11:46:50 <arianvp|afk> > let ( ҉) = fix; f = show in (f҉)
11:46:51 <athan> Twey: I feel like that should be callcc
11:46:52 <lambdabot>  <hint>:1:7: lexical error at character '\1161'
11:46:54 <arianvp|afk> :(
11:46:57 <Twey> NikolajK: 0 *is* a computational object.  *Proofs* of 0 are not computational objects, because there are none.
11:47:09 <arianvp|afk> apparently Zalgo is not upo us
11:47:33 <athan> dmj`: http://unicode-table.com/en :P
11:47:41 <Twey> NikolajK: But proofs of 0 *given some hypothesis* are real computational objects in the same sense as any other function: they're an algorithm to get from some hypothesis to a proof of 0
11:48:13 <Twey> NikolajK: In the same sense that any proof of A → B is an algorithm to get from an A to a B
11:48:18 <RedNifre> If I want to create a service oriented architecture where the services share some code, how would I do that regarding cabal? One project with multiple main IOs? Or several projects? How to share code then?
11:48:27 <Iceland_jack> arianvp|afk:
11:48:30 <Iceland_jack> ghci> :t map
11:48:30 <Iceland_jack> map :: (a -> b) -> [a] -> [b]
11:48:30 <Iceland_jack> ghci> import Data.Map as M
11:48:30 <Iceland_jack> ghci> :t map
11:48:33 <Iceland_jack> <interactive>:1:1:
11:48:37 <Iceland_jack>     Ambiguous occurrence ‘map’
11:48:44 <Twey> NikolajK: (alternatively, all proofs of 0 are computational objects ;))
11:49:03 <monochrom> I agree with that :)
11:49:16 <arianvp|afk> yes sure
11:49:19 <arianvp|afk> but  M.map will fix that
11:49:27 <dcoutts_> RedNifre: depends how closely integrated they are, if they're not close but simply share code then multiple packages sharing a lib would be appropriate
11:49:29 <arianvp|afk> without evenn using qualifieds
11:49:30 <Iceland_jack> arianvp|afk: not if you want to refer to the original map
11:49:34 <arianvp|afk> ahhh
11:49:36 <arianvp|afk> Prelude.map
11:49:37 <arianvp|afk> :)
11:49:46 <int-e> Iceland_jack: try import qualified Data.Map as M
11:49:55 <Iceland_jack> int-e: I was showing why that's not a good idea
11:50:00 <dcoutts_> RedNifre: if they're more closely integrated then it may make sense to have some in a single package with multiple exes (possibly sharing an internal lib)
11:50:01 <int-e> oh.
11:50:01 <arianvp|afk> haha int-e :)
11:50:06 <Iceland_jack> If you're okay with using a qualified Prelude, sure!
11:50:12 <monochrom> arianvp|afk: qualfied is really safe, lowest maintainance. but you are free to do whatever works for you.
11:50:19 <arianvp|afk> well I'd rather throw away Prelude
11:50:23 <arianvp|afk> :(
11:50:40 <arianvp|afk> XNoImplicitPrelude ftw
11:50:58 <Iceland_jack>     if (x floats your boat) { do x; }
11:51:34 <monochrom> this is the problem with questions of the form "why do people do/don't XXX".
11:51:39 <NikolajK> "data  http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Maybe a  =  Nothing | Just a      deriving (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq, http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord)" is the Ord it's deriving the order "Nothing > Just a" ?
11:51:42 <athan> This one could be a hylo: Ѧ
11:51:54 <Twey> arianvp|afk: If you have a module M with a name a then you can import M as M and talk about M.a to your heart's content.  If you also use the name ‘map’ (from Prelude, say), you can talk about it unqualified, no problem.  But if the author of M decides to add a name ‘map’, suddenly your code breaks, because in the presence of M.map you now have to explicitly qualify all your Prelude.maps.
11:52:17 <monochrom> everything that people do --- everything --- boils down to personal preferences after you understand and see through the trade-offs
11:52:42 <RedNifre> Well, ideally I would end up with separate executables, so the database related thing would run all the time, while the mulitple other services that sometimes query the database can be updated separately.
11:52:47 <Twey> arianvp|afk: But that doesn't have to be from Prelude.  Any unqualified name you use can in principle be broken by the packages you pull in.  Of course, some are less likely to do that than others.
11:52:52 <Iceland_jack> monochrom: Are you implying that the editor wars aren't grounded in reason and facts??
11:53:04 <monochrom> and there is no such thing as convincing you of my personal preference. there is only convincing you of leaving me alone.
11:53:05 <RedNifre> So I guess multiple packages with a common library might be best, right?
11:53:40 <joelteon> :t if that floats your boat then do that else don't
11:53:41 <lambdabot> t -> t1 -> t2 -> Bool
11:53:52 <Iceland_jack> hehe
11:54:33 <Twey> monochrom: Ehh.  Only principles (like less typing, or fewer brackets, or shorter lines) are preference.  If you can agree on those then you can have a fact-based discussion.
11:55:04 <Iceland_jack> > de gustibus
11:55:05 <lambdabot>  Not in scope: ‘gustibus’
11:55:06 <Iceland_jack> damn
11:55:10 <Iceland_jack> > de gustibus
11:55:11 <lambdabot>  what ever ya like
11:55:50 <RedNifre> > what
11:55:51 <lambdabot>  Not in scope: ‘what’
11:56:01 <RedNifre> > [1..]
11:56:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:56:52 <RedNifre> > rec = "a"
11:56:54 <lambdabot>  <hint>:1:5: parse error on input ‘=’
11:56:59 <RedNifre> > let rec = "a"
11:57:00 <lambdabot>  not an expression: ‘let rec = "a"’
11:57:05 <arianvp|afk> looking for a easy way to keep track of line numbers in interpreter errors
11:57:10 <mroman> > let rec = "a" in rec
11:57:11 <lambdabot>  "a"
11:57:37 <monochrom> Twey: do people agree on principles?
11:57:37 <arianvp|afk> guess I will need to annonate the line context of each expression when parsing or something
11:58:19 <bug2000> > random (getStdGen) :: (Bool, StdGen)
11:58:21 <lambdabot>  Couldn't match expected type ‘System.Random.StdGen’
11:58:21 <lambdabot>              with actual type ‘GHC.Types.IO System.Random.StdGen’
11:58:23 <monochrom> the principle "shorter code" conflicts with the principle "needs less education to read that code". two people are bound to make opposite choices on them.
11:59:08 <wombawomba> I'm trying to figure out how to work with mutable vectors, but it's not going so well. What's causing this error and how do I fix it? https://www.fpcomplete.com/project/58319/7JJR8vt1TF
12:00:11 <Twey> monochrom: Some people do, sure.  But that's not to say that you can never have a factual discussion about them with anyone.
12:05:11 <Fuuzetsu> hm, seems the ‘bittorrent’ library author is currently in poor health and can't continue development
12:05:26 <arianvp|afk> that is sad to hear ....
12:05:27 <arianvp|afk> :(
12:05:48 <Fuuzetsu> Seems we'll have to start a new effort after all…
12:05:55 <athan> We should make him/her a card or something :(((
12:06:16 <athan> "Hey get better soon... btw, what's the bug fix for..."
12:06:17 <chrisdone> unless his health is paper-related
12:06:21 <MP2E> haha
12:06:31 <Fuuzetsu> aversion to papers
12:06:37 <athan> lol
12:07:08 <Fuuzetsu> athan: The way I found out was by trying to find out why some stuff is commented out and whether I could fix it so it seems he can't be of much help right now.
12:07:24 <Fuuzetsu> I think looking at combinatorrent + bittorrent and getting some people to hack something new is for the best
12:07:34 <chrisdone> Abstract. First we explain how deeply we hope you will get well soon. After that, we discuss the relative merits of cards versus fruit baskets.
12:07:57 <Fuuzetsu> Don't forget contributions.
12:08:45 <athan> Hahahaha
12:09:01 <chrisdone> Authors: Athan Clark, Fuuzetsu, Chris Done, Oleg Kiselyov
12:09:03 <athan> please do this, I think it would really make his day
12:09:31 <Fuuzetsu> I think it's best to just not bother him
12:09:45 <Fuuzetsu> chrisdone: I have a real name!
12:09:50 <monochrom> the merit of card is that you can scan it into a PDF and send in email
12:09:53 <chrisdone> fuuzetsu: /whois doesn't say so
12:09:55 <athan> Is he hospitalized? :(
12:10:13 <monochrom> the merit of fruit basket is that you can snap it into a JPG and send in email
12:10:22 <Fuuzetsu> chrisdone: Fair point although I'm not changing that.
12:10:34 <athan> monochrom: And it can be lazilly parsed for sucessful communication
12:11:12 <arianvp|afk> I think he'd appreciate it. but you never know for sure.
12:11:20 <monochrom> @quote monochrom debates
12:11:20 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
12:11:24 <arianvp|afk> Guess you can only tell something like that if someone knows him in real life.
12:11:28 <Fuuzetsu> hm, I don't like to /whois myself, it tells me I'm in all those channels I totally forgot about
12:11:47 <athan> I think by making it in a thesis-like format, he'll get the joke :)
12:12:06 <arianvp|afk> Okay. lets get LaTeX'ing?
12:12:26 <chrisdone> “I don't like to /whois myself”
12:12:27 <chrisdone> so deep
12:12:45 <Fuuzetsu> #badmemory
12:13:35 <athan> arianvp|afk: I'm down. Start a repo?
12:13:48 <chrisdone> this is sure to succeed
12:14:00 <arianvp|afk> I'm not LaTeX hero though ..
12:14:04 <athan> chrisdone: xD
12:14:12 <arianvp|afk> so perhaps it would be better to put it on someone else's github account
12:14:16 <athan> arianvp|afk: You're not alone hahaha
12:14:27 * hackagebot goatee 0.2.0 - A monadic take on a 2,500-year-old board game - library.  http://hackage.haskell.org/package/goatee-0.2.0 (khumba)
12:14:33 <arianvp|afk> My brother just finished typesetting his 500 page thesis in it
12:14:36 <arianvp|afk> respect
12:14:38 <arianvp|afk> :/
12:14:41 <athan> chrisdone: ...care to take the honors?
12:14:49 <athan> :O
12:16:26 <athan> cmaaaaaaan, it would be fun :)
12:16:38 <chrisdone> nope, i was joking
12:16:53 <athan> :(
12:17:15 * chrisdone also takes athan's lunch money, for good measure
12:17:28 <athan> chrisdone: My glasses!
12:17:35 <chrisdone> my gleeesiz
12:17:48 <athan> :E
12:18:04 <lpaste> robbins pasted “Still not happy” at http://lpaste.net/8828016736730087424
12:18:14 <athan> I really want to make a combinator library that uses Tamil for symbols
12:18:23 <zomg> I've been thinking of writing a card game in Haskell, kinda like Hearthstone ;o
12:18:30 <zomg> Then format it into a haskell beginner tutorial
12:18:35 <athan> especially this guy: ௸
12:18:35 <zomg> because I kinda wanna write about something
12:18:38 <arianvp|afk> athan: but Tamil aren't symbols!
12:18:38 <zomg> =)
12:18:43 <arianvp|afk> they're letters right?
12:18:46 <athan> :(
12:18:52 <arianvp|afk> doesnt mean you can
12:18:56 <arianvp|afk> you can't use em*
12:19:04 <arianvp|afk> (I think)
12:19:17 <athan> arianvp|afk: Heck yeah!
12:19:33 <athan> knots everywhere
12:19:34 <arianvp|afk> > let தமிழ x = 3 in x
12:19:36 <lambdabot>  <hint>:1:7: lexical error at character '\3007'
12:19:38 <arianvp|afk> :(
12:19:46 <arianvp|afk> > let தமிழ x = 3 in தமிழ
12:19:47 <lambdabot>  <hint>:1:7: lexical error at character '\3007'
12:19:52 <arianvp|afk> darnit!
12:19:53 <arianvp|afk> WH
12:20:06 <phaazon> 21:19 < arianvp|afk> > let தமிழ x = 3 in தமிழ
12:20:08 <RedNifre> Hm, I'm not sure whether I understand the hidden constructor observer pattern. What exactly is the behaviour of the thing left of the -> in a case of statement?
12:20:08 <phaazon> ahah :D
12:20:30 <arianvp|afk> aha what? :)
12:21:23 <RedNifre> I mean, if I use case of with Data ... -> .. I assume it checks for equality. But what if the left side looks like (somefunction -> SomeData)? Does it apply the function to what the case of wants to match and compares the result to what is right of that arrow?
12:22:01 <Fuuzetsu> I don't know a thing about uniplate, does lens obsolete it?
12:22:18 <Fuuzetsu> we use lens in Yi now so maybe uniplate can go if that's the case
12:22:39 <int-e> RedNifre: the what pattern?
12:22:44 <edwardk> lens includes a copy of uniplate refactored as a set of combinators for working with traversals, and a couple of canonical choices for such traversals
12:23:09 <edwardk> its faster than uniplate for some purposes a little slower for others, within 30% variance either way
12:23:39 <edwardk> but importantly for me lens doesn't require you to use a package that has multiple 'global' instances and hope you don't accidentally import both sets of conflicting orphans anywhere in your program
12:24:00 <Fuuzetsu> OK, so to my understanding I can get rid of uniplate
12:24:00 <geekosaur> RedNifre: it matches structure, not equality. and the other is a view pattern, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
12:24:02 <RedNifre> What are your thoughts on Idris?
12:25:34 <athan> RedNifre: I think dependent typing principals are indespensible / really cool :)
12:26:16 <chrisdone> athan: http://en.wiktionary.org/wiki/principal#Usage_notes
12:26:30 <David> Hi guys! I have two linux machines (a big 40-core workstation and a tiny VPS) and I want to compile some packages on the workstation and move them to the VPS
12:26:41 <David> can I just build them and copy over .ghc and .cabal or do i need to do something else?
12:27:22 <vanila> RedNifre, Idris looks great, a lot of loose ends because it's just a research tool right now but i hope it becomes a real language
12:27:24 <c_wraith> David: depends on what libraries it uses, really.
12:27:41 <David> it's lambdabot
12:27:54 <David> I think the only system library that it needs is pcre
12:27:57 <RedNifre> Which languages do you use besides Haskell (if any) and for what?
12:28:05 <athan> chrisdone: You've been infected with the curse, haven't you?
12:28:09 <vanila> prolog and scheme
12:28:36 <c_wraith> David: well, it needs gmp like every haskell program, and libc, and..  I think there are about 10 system libraries.  Check the binary to see what it dynamically links against.
12:28:46 <chrisdone> athan: i have?
12:28:50 * chrisdone glances around nervously
12:28:52 <c_wraith> David: other than that, it should be relatively self-contained
12:29:01 <RedNifre> Huh. I thought those are somewhat similar to haskell? Why prolog/scheme?
12:30:30 <David> c_wraith: both are ubuntu systems (the workstation's running the old 12.04 lts and the vps is running 14.04)
12:30:48 <c_wraith> David: library incompatibilities between ubuntu versions are likely to cause some issues.
12:30:57 <athan> chrisdone: I'm not sure, we may have to do further tests. Do you ever find yourself measuring the ratio of creamer and sweeteners in your coffee? What about your shoes? Is their snugness perfectly symmetrical at all times?
12:31:16 <David> hmm. What about building only some stuff on the workstation?
12:31:57 <David> the main package I've had trouble building on the VPS is haskell-src-exts. int-e suggested that I unpack it and build it manually, but that's still going to take a few hours (if it works) whereas the workstation can build it in under a minute
12:32:05 <monochrom> on 12.04, is gmp gmp10 or gmp3?
12:32:09 <chrisdone> athan: i don't drink coffee. but i do drink shoes
12:32:15 <MP2E> o.o
12:32:22 <chrisdone> from shoes?
12:32:26 <MP2E> drinking shoes sounds intense.
12:32:28 <c_wraith> David: I bet it won't really help.  I'd say your best bet is to set up a VM using something like virtualbox to match the VPS environment as closely as possible.
12:32:55 <RedNifre> Meh, I don't like the temperature at which you can drink shoes. Too hot for me...
12:33:09 <l0cust> MP2E: drinking shoes, as in, shoes that you wear while drinking? Maybe to prevent you from falling down?
12:33:09 <chrisdone> chris@retina:~$ apt-cache search gmp
12:33:10 <chrisdone> lib32gmp-dev - Multi
12:33:19 <athan> *awards chrisdone for his heroic drinking game invention*
12:33:25 <David> ok, so set up a VM on the big machine with stock 14.04, build it there, and copy everything over?
12:33:25 <monochrom> David, c_wraith: I believe there is good hope that there will be no problem. Haskell Platform itself is built on 12.04 and the binary runs well on 14.04
12:33:29 <l0cust> MP2E: That actually seems like it would be profitable
12:33:32 <l0cust> athan: use /me
12:33:34 <chrisdone> well, i'm on 13.04. but earlier is likely to be similar
12:33:39 <monochrom> https://www.haskell.org/platform/linux.html#binary
12:33:44 <athan> l0cust: :D
12:33:52 <athan> l0cust: Have you been infected, too?
12:33:55 <l0cust> athan: I presume that's what You were trying to do
12:33:58 <c_wraith> David: well, give it a try.  See if it works.  If it doesn't, give us info on specific problems.
12:34:05 <athan> (thanks though :P)
12:34:08 <David> ok, thanks monochrom, c_wraith
12:34:24 <David> I'll try it on the 12.04 box first and if it fails, then it's VM time
12:34:39 <chrisdone> athan: i have one drinking game of “every time Vernor Vinge uses the phrase ‘hunker down’, take a shot”
12:35:23 <athan> oh god... redneck combinators?
12:35:35 <l0cust> chrisdone: I have a similar drinking game, but it involves watching Michele Bachmann speeches, and taking a shot whenever she quotes a false statistic
12:35:47 <athan> hunker = index
12:36:01 <l0cust> athan: are you athanclarke by any chance?
12:36:04 <athan> l0cust: Hahahaha
12:36:12 <athan> l0cust: without the e, but yeah!
12:36:24 <chrisdone> Clark is his alter ego
12:36:32 * athan poses
12:36:34 <RedNifre> Which type is suitable for money? Is there something like a decimal float? That I could limit to two decimal places?
12:36:46 * chrisdone shields eyes from blinding light of athan's prowess
12:36:46 <l0cust> athan: ah, you're the one person who has favourited one of my github repos.
12:36:57 * l0cust tips fedora
12:37:28 <athan> l0cust: :)
12:38:36 <l0cust> athan: if I recall correctly, you're from Colorado, so I just assumed you were high
12:39:15 <MP2E> hahahha
12:39:26 <athan> l0cust: Yeah, it's kinda hard not to be honestly. In Denver, it's like public potpourri (no pun intended) to cover up the smog
12:39:38 <chrisdone> but l0cust, you *are* from Colorado. *you're* high right now
12:39:55 * athan tries to not drool from sedation
12:39:56 <MP2E> what a twist!
12:39:59 <l0cust> chrisdone: I'm from Utah, sorry
12:40:28 <l0cust> chrisdone: It's basically Mormon Colorady
12:40:31 <l0cust> *Colorado
12:40:38 <athan> Colorady works too
12:40:54 <l0cust> chrisdone: But to address your other accusation, I am high right now
12:41:05 <monochrom> I am in Ontario. does that help?
12:41:36 <RedNifre> Hm, I'm not sure I understand the typechecking... I'm currently reading Beginning Haskell and it shows a function that takes a Number, and it tries to use it to fold a list of integers, which fails, so the solution is to map the list to Numbers first... why is that necessary?
12:41:39 <chrisdone> you are the only thing in Ontario
12:41:52 <naudiz> When I have a function foo :: a -> a -> a, is there a way to pass [a] into it as an argument?
12:41:59 <l0cust> naudiz: use map
12:42:17 <l0cust> naudiz: I presume you mean something like
12:42:27 <chrisdone> RedNifre: what's the type of the function in question?
12:42:40 <l0cust> map (\a -> foo a a) listOfAs
12:43:06 <RedNifre> it takes InfNumber, which is a custom data that is MinusInfinity | Number a | PlusInfinity
12:44:02 <RedNifre> What the book is doing here is building a maximum function for lists using a fold and the idea is to start the fold with MinusInfinity, so that the infMax function can be used.
12:44:08 <naudiz> l0cust: I don't want foo to be applied to each element of [a] but I want to be each element of [a] to be a single argument of foo
12:44:24 <l0cust> ah
12:44:39 <l0cust> (\(a:b:_) -> foo a b) listOfAs
12:45:10 * chrisdone doesn't understand the ‘ribbon’ metaphor used in HSE's pretty printer
12:45:13 <RedNifre> The list is [1,2,3], I don't understand why max Number [1,2,3] is necessary. I mean, if the function can deal with a Number, why can't it deal with an Integer?
12:45:31 <naudiz> l0cust: exactly but I'salso like foo to be any function that takes any number of arguments
12:45:38 <Iceland_jack> RedNifre: What if the list is empty?
12:45:43 <naudiz> s/I'salso/I'd also
12:46:00 <l0cust> naudiz: Oh, you mean something like Python's *x
12:46:11 <RedNifre> Iceland_jack I guess then it will be MinusInfinity, since that's the value the fold starts with?
12:46:23 <naudiz> l0cust: I don't know about python :D
12:46:33 <Iceland_jack> Yes, but that wouldn't work well with Integer
12:47:07 <l0cust> naudiz: Okay, in python, if you have a function f(a,b,c), you can run f(*[1,2,3]), and the arguments are applied respectively
12:47:23 <naudiz> l0cust: exactly
12:47:34 <chrisdone> hmmm
12:47:41 <l0cust> naudiz: basically * is the "unary unlistify" operator in python
12:47:48 <RedNifre> Iceland_jack, sure, that's the whole point of having data InfNumber a = MinusInfinity | Number a | PlusInfinity
12:47:51 <chrisdone> an editor function to expand a constructor into a record constructor with all the fields set to undefined would be neat
12:47:52 <l0cust> naudiz: I don't think there's anything similar in Haskell.
12:47:57 <l0cust> naudiz: there's curry and uncurry
12:48:00 <l0cust> :t uncurry
12:48:01 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:48:04 <zmbmartin> I have a data User = User {name :: String, email :: String} how do I pattern match name and/or email
12:48:07 <RedNifre> so that you can write foldr infMax MinusInfinity [1,2,3]
12:48:10 <l0cust> naudiz: that work with tuples
12:48:12 <zmbmartin> Or map over it.
12:48:23 <Iceland_jack> RedNifre: ah, I thought you were disputing the benefit of having InfNumber over Integer
12:48:27 <l0cust> zmbmartin: you mean
12:48:50 <l0cust> \(User nom eml) -> doSomething nom eml
12:48:56 <RedNifre> I don't understand why you map to Number first. I mean, I either think that it should work with Integer, or I think that you would have to map it to InfNumber ... hm...
12:49:06 <zmbmartin> l0cust: Yeah thanks!
12:49:06 <RedNifre> aaaaaaah...
12:49:12 <naudiz> l0cust: damn... so I have to think about some other way to handle my problem :/ but thanks
12:49:15 <Tuplanolla> You could make a Functor User instance, zmbmartin.
12:49:20 <RedNifre> So mapping to Number actually maps to InfNumber, since InfNumber can be a Number?
12:49:31 <zmbmartin> Tuplanolla: to be able to map over it?
12:49:31 * hackagebot goatee-gtk 0.2.0 - A monadic take on a 2,500-year-old board game - GTK+ UI.  http://hackage.haskell.org/package/goatee-gtk-0.2.0 (khumba)
12:49:40 <Tuplanolla> Yes.
12:50:03 <zmbmartin> Tuplanolla: Hmm…. OK haven't done that before. I will look into that. Thanks!
12:50:30 <bug2000> Hello. Is there something like lookup that compares to snd rather than fst?
12:50:52 <l0cust> :t lookup
12:50:53 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:51:11 <l0cust> well
12:51:16 <RedNifre> But I still don't get it. If a Number qualifies as an InfNumber, because data InfNumber a = MinusInfinity | Number a | PlusInfinity, then why doesn't Integer qualify as a Number and thus as an InfNumber? Isn't it sort of like data Number = Integer | Float....?
12:51:30 <l0cust> lookup_ = lookup . map (\(a, b) -> (b, a))
12:51:30 <vanila> :t \x -> lookup x . flip map
12:51:32 <lambdabot>     Couldn't match type ‘(a1 -> b0) -> [b0]’ with ‘[(a, b)]’
12:51:32 <lambdabot>     Expected type: [a1] -> [(a, b)]
12:51:32 <lambdabot>       Actual type: [a1] -> (a1 -> b0) -> [b0]
12:51:35 <vanila> oops
12:51:38 <vanila> :t \x -> lookup x . map flip
12:51:40 <lambdabot>     Couldn't match type ‘b1 -> a1 -> c’ with ‘(a, b)’
12:51:40 <lambdabot>     Expected type: (a1 -> b1 -> c) -> (a, b)
12:51:40 <lambdabot>       Actual type: (a1 -> b1 -> c) -> b1 -> a1 -> c
12:51:54 <vanila> oh it should be swap
12:52:02 <l0cust> bug2000: you could try something like this
12:52:07 <bug2000> Thank you
12:52:34 <NikolajK> what's wrong with this Functor instance for data Tree a = Node a [Tree a]: 	fmap f (Node x ys) = Node (f x) (map (fmap f) ys)
12:52:35 <RedNifre> \data InfNumber a = MinusInfinity | Number a | PlusInfinity deriving Show
12:52:53 <RedNifre> > data InfNumber a = MinusInfinity | Number a | PlusInfinity deriving Show
12:52:54 <lambdabot>  <hint>:1:1: parse error on input ‘data’
12:53:03 <Iceland_jack> @let data InfNumber a = MinusInfinity | Number a | PlusInfinity deriving Show
12:53:06 <lambdabot>  Defined.
12:53:09 <Iceland_jack> > Number 5
12:53:11 <lambdabot>  Number 5
12:53:26 <RedNifre> :t Number 5
12:53:27 <lambdabot> Num a => InfNumber a
12:53:36 <l0cust> bug2000: If you're doing heavy lookups, you should really be using Data.Map
12:53:36 <RedNifre> :t Integer 5
12:53:37 <lambdabot> Not in scope: data constructor ‘Integer’
12:53:48 <l0cust> bug2000: It's a lot faster
12:53:51 <RedNifre> :t [1,2,3]
12:53:52 <Iceland_jack> RedNifre: You're confusing types and value constructors
12:53:52 <lambdabot> Num t => [t]
12:54:10 <l0cust> RedNifre: it really bothers me that weechat made your nick blue
12:54:17 <Iceland_jack> haha
12:54:29 <RedNifre> Huh?
12:54:43 <naudiz> l0cust: why is it that applyList f (x:xs) = applyList (f x) xs won't work? (applyList f [] = f)
12:54:53 <RedNifre> I'm using WeeChat and it shows my own nick as white. I didn't even know that you could choose the color of your name.
12:54:57 <glguy> NikolajK: Nothing is wrong with it
12:55:07 <l0cust> naudiz: your pattern match needs to account for corner cases
12:55:21 <l0cust> RedNifre: http://i.imgur.com/rY6ko1p.png
12:55:45 <RedNifre> okay, how do I confuse types and value constructors? And why does lambdabot say that [1,2,3] is Num and not integer? And is Num something other than Number?
12:55:47 <bug2000> l0cust, A) Learning the language. Trying to make really simple stuff right now. B) I don't see Data.Map here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html
12:56:02 <c_wraith> RedNifre: you have classes and types confused now
12:56:05 <NikolajK> then instance Functor Tree a where is wrong
12:56:08 <l0cust> bug2000: it's in the package containers - http://hackage.haskell.org/package/containers
12:56:09 <c_wraith> RedNifre: Num is a class, not a type
12:56:10 <NikolajK> should I drop the a?
12:56:55 <c_wraith> RedNifre: classes are..  collections of types that guarantee all the types in that class can perform certain operations.
12:57:04 <NikolajK> I guess. Can	fmap f (Node x ys) = Node (f x) (map (fmap f) ys)   be written nicer
12:57:14 <bug2000> l0cust, Thank you (Oh yeah and it's a hard coded assoc list)
12:57:31 <vanila> NikolajK, that's perfect
12:57:39 <zmbmartin> Tuplanolla: Really what I would like to do is a simpler version of this -> https://gist.github.com/codedmart/3d5fa9ddf488f45f3d5a
12:57:41 <Xeironis> @pl fmap f (Node x ys) = Node (f x) (map (fmap f) ys)
12:57:42 <lambdabot> (line 1, column 21):
12:57:42 <lambdabot> unexpected " "
12:57:42 <lambdabot> expecting operator
12:57:57 <Xeironis> meh
12:58:01 <zmbmartin> When I convert to a doc I just want to leave out Nothing's
12:58:15 <chrisdone> does anyone know how to load .ly files in ghci?
12:58:16 <NikolajK> what's pl
12:58:27 <Xeironis> NikolajK: pointless, aka pointfree
12:58:27 <chrisdone> pl=pointless
12:58:27 <Tuplanolla> Simpler how, zmbmartin?
12:58:30 <Xeironis> for example
12:58:30 <zmbmartin> This code works but seems repetitive.
12:58:43 <Xeironis> @pl \f a b c = f b a c
12:58:43 <lambdabot> (line 1, column 10):
12:58:43 <lambdabot> unexpected "="
12:58:43 <lambdabot> expecting pattern or "->"
12:58:47 <Xeironis> @pl \f a b c -> f b a c
12:58:48 <lambdabot> flip
12:58:53 <NikolajK> @pl f n = n^2
12:58:53 <lambdabot> f = (^ 2)
12:59:01 <SwashBuckla> NikolajK: what is the type definition for Tree?
12:59:11 <zmbmartin> Tuplanolla: Something like map over the data members and skip if it is Nothing.
12:59:13 <RedNifre> Hm, so what exactly is the relation between integer, Num and Number?
12:59:17 <c_wraith> RedNifre: lambdabot says that [1,2,3] can have any type that unifies with Num a => [a].  That is, it's a list, but the type of each element is polymorphic.  However, the polymorphism is bounded - it can only be a type that supports the Num operations.
12:59:19 <l0cust> @@ SwashBuckla @src Tree
12:59:19 <lambdabot>  SwashBuckla Source not found. Maybe you made a typo?
12:59:35 <l0cust> @@ SwashBuckla @src Node
12:59:35 <lambdabot>  SwashBuckla Source not found. You type like i drive.
12:59:37 <chrisdone> @pl \f a b c d -> d (f a) (f b) (f c)
12:59:37 <lambdabot> flip =<< ((flip . (((.) . flip) .)) .) . (flip =<< (((.) . flip . flip id) .))
12:59:37 <SwashBuckla> NikolajK: or whatever Node belongs to
12:59:41 <l0cust> @@ SwashBuckla @src Data.Tree.Node
12:59:41 <lambdabot>  SwashBuckla Source not found. This mission is too important for me to allow you to jeopardize it.
13:00:03 <Xeironis> @pl while cond f = cond >>= postIf (f >> while cond f) (return ())
13:00:03 <lambdabot> while = fix (liftM2 (.) (>>=) . flip flip (return ()) . ((flip . (postIf .) . ap (>>)) .))
13:00:06 <stalintrotsky> Integer is an instance of Num, meaning that it has the operations that Num requires, and you can expect to be able to use those operations with it
13:00:08 <SwashBuckla> stop the channel spam l0cust :P
13:00:09 <c_wraith> RedNifre: Integer is a concrete type.  Num is a class defining a bunch of operations that things that we generally think of as "numbers" support.  number isn't anything
13:00:12 <stalintrotsky> I don't think Number is a type or a class
13:00:12 <NikolajK> @pl f (g::Int->Int) n = g $ g $ n^2
13:00:13 <lambdabot> (line 1, column 12):
13:00:13 <lambdabot> unexpected '>'
13:00:13 <lambdabot> expecting operator
13:00:15 <dmj`> if I have data A = A Text, and I want a function that goes from Maybe A -> ByteString, is there a nicer way to do that besides (\(A val) -> T.encodeUtf8 val) <$> (A "hey"))
13:00:25 <RedNifre> Ah, so when I ask lambdabot about [1,2,3], it is not yet decided what exactly is in that list... but when I use that list in a larger statement it turns into integers?
13:00:37 <stalintrotsky> yes
13:01:03 <stalintrotsky> the (Num a) => part at the beginning means that a has to be an instance of Num
13:01:06 <c_wraith> RedNifre: if it doesn't have enough context to make it something more specific, it picks Integer.  If it does have enough context, it goes with whatever fits the context.
13:01:08 <Tuplanolla> You can probably utilize Maybe being a Monoid to concatenate them, zmbmartin.
13:01:21 <stalintrotsky> class contraints show up before the =>, if it's a specific type it will appear after
13:01:26 <RedNifre> Oh, right. Number is just something that was defined in the book in the InfNumber data type. my mistake.
13:01:44 <RedNifre> I confused Number with Num.
13:02:01 <c_wraith> RedNifre: but yeah..  numeric literals are explicitly polymorphic in haskell, and can even be polymorphic over your types.
13:02:56 <zmbmartin> Tuplanolla: That is what I was thinking if I could map through the members and concat them that way.
13:03:08 <zmbmartin> I will try to figure that out. Thanks!
13:03:24 <RedNifre> My mistake was that I read the data as data InfNumber a = MinusInfinity | Num a | PlusInfinity, which caused me to expect that a function accepting an InfNumber should accept integers, but it's not possible to define data that way, right?
13:03:37 <Tuplanolla> First take the records and mconcat them, then zip that list together with their names.
13:03:49 <Tuplanolla> That might work the best, zmbmartin.
13:03:55 <c_wraith> RedNifre: correct.  You can make it accept literals, but the literals have the type InfNumber a (for whatever a)
13:04:09 <NikolajK> is there an inverse of @pl?
13:04:19 <c_wraith> there's @unpl
13:04:35 <Xeironis> @unpl flip
13:04:35 <lambdabot> (\ a b c -> a c b)
13:05:06 <c_wraith> RedNifre: and as you might guess, the way to make literals work for your type is to implement Num for your type.
13:05:23 <Xeironis> howener, using @unpl on results of @pl can make things a lot more complex than they were initially
13:05:32 <zmbmartin> Tuplanolla: ok I am still trying to grasp haskell, I will look at mconcat more thanks!
13:05:34 <Xeironis> s/howener/however
13:05:36 <c_wraith> RedNifre: the class, that is.  That data definition is a little annoying, reusing Num as the name of a data constructor.
13:05:46 <RedNifre> I did not guess that, since I'm very new to haskell :o) What exactly does that mean?
13:06:04 <RedNifre> I guess that would be my next question, how can I write MinusInfinity + 1+
13:06:12 <RedNifre> -++?
13:06:45 <c_wraith> RedNifre: I'm going to defer to a tutorial on this one.  There's a decent chunk of knowledge to implementing a class.  What book are you using?
13:06:55 <Tuplanolla> Check this out, zmbmartin.
13:07:00 <Tuplanolla> > mconcat [Nothing, Just $ Sum 1, Nothing, Just $ Sum 3, Just $ Sum 4]
13:07:02 <lambdabot>  Just (Sum {getSum = 8})
13:07:07 <RedNifre> I'm reading Beginning Haskell, but I'm only at the beginnig of Chapter 3 right now
13:07:21 <dmj`> nobody?
13:08:03 <RedNifre> > Sum 1
13:08:05 <lambdabot>  Sum {getSum = 1}
13:08:06 <cultofmetatron> hi
13:08:15 <RedNifre> :t Sum
13:08:16 <lambdabot> a -> Sum a
13:08:35 <NikolajK> but how is
13:08:36 <NikolajK> @pl f g x = g x
13:08:36 <lambdabot> f = id
13:08:44 <NikolajK> isn't it apply?
13:08:47 <NikolajK> or eval
13:09:01 <Iceland_jack> NikolajK: ($) is a specialized version of id
13:09:03 <Xeironis> f g x = g x is the same as f g = g
13:09:04 <cultofmetatron> I have a question regarding types, I'm trying to get the middle indexof a list so I wrote this function
13:09:06 <cultofmetatron> middleIndex :: (Ord a) => [a] -> Int middleIndex as = ceiling ((length as) / 2)
13:09:09 <Iceland_jack> :t [($), id]
13:09:09 <Xeironis> with eta reduction
13:09:10 <lambdabot> [(a -> b) -> a -> b]
13:09:21 <SwashBuckla> dmj`: I'm not sure. I can advise not to use pattern matching in lambdas however (can result in Runtime errors)
13:09:22 <cultofmetatron> middleIndex :: (Ord a) => [a] -> Int
13:09:23 <cultofmetatron> middleIndex as = ceiling ((length as) / 2)
13:09:31 <cultofmetatron> and it throw an error on compile
13:09:36 <SwashBuckla> dmj`: other than that, what you're doing looks fine
13:09:42 <cultofmetatron> Could not deduce (Fractional Int) arising from a use of `/'
13:09:48 <cultofmetatron> what do I do to make it work?
13:10:03 <NikolajK> Xeironis: "f g x = g x is the same as f g = g" but isn't the type of the first more restrictive?
13:10:10 <NikolajK> g must be a function
13:10:25 <Xeironis> NikolajK: Yes, but id allows for any type, so it also allows for functions
13:10:27 <Xeironis> :t id
13:10:28 <Iceland_jack> NikolajK: yes, exactly
13:10:28 <lambdabot> a -> a
13:10:32 <Iceland_jack> @ty \g x -> g x
13:10:33 <lambdabot> (t1 -> t) -> t1 -> t
13:10:35 <Iceland_jack> @ty \g -> g
13:10:36 <lambdabot> t -> t
13:11:22 <naudiz> Is there really no way to apply an array of arguments to a function? ._. I'm stuck with my parser
13:11:31 <c_wraith> RedNifre: Hmm.  I'm just really going to hope the book covers that very shortly.  If it doesn't, look into things online that say "instance Num .." or "instance (...) => Num ...".  Those are declarations that a type is in the Num class.
13:11:45 <Twey> naudiz: What are you trying to do?
13:11:46 <vanila> naudiz, there is not but maybe there's a way to od what you want - do you ahve some code to ask about?
13:11:47 <Iceland_jack> naudiz: there is a way but it's not something you do in Haskell, simply pass it the list
13:12:02 <Iceland_jack> naudiz: confer the minimum/maximum functions
13:12:04 <Iceland_jack> @ty minimum
13:12:05 <lambdabot> Ord a => [a] -> a
13:12:25 <NikolajK> so @pl doesn't give an equal substitute, but rather also more general functions
13:12:41 <NikolajK> f in "f g x = g x" is more special than id
13:12:52 <c_wraith> NikolajK: sometimes @pl lies entirely.
13:13:09 <c_wraith> NikolajK: it assumes things that aren't always true
13:13:19 <Twey> Like what?
13:13:21 <Xeironis> like that  f a means that f is a monad?
13:13:32 <c_wraith> Twey: commutativity of arithmetic, for instance
13:13:36 <Twey> Xeironis: f is a monadic value in that case, because all functions are
13:13:37 <zmbmartin> Tuplanolla: That is cool but I am not sure how to apply that to my situation yet. I will keep trying.
13:13:38 <Twey> c_wraith: Huh.
13:13:46 <Twey> Xeironis: (r ->) is a monad
13:13:49 <c_wraith> @pl \x -> 1 + x + 1
13:13:49 <lambdabot> (2 +)
13:13:53 <c_wraith> Twey: ^
13:14:00 <Xeironis> Right, I confused types with values for a second
13:14:01 <Twey> Wow, I didn't know it knew about numbers.
13:14:35 <Twey> @src (->) (>>=)
13:14:35 <lambdabot> f >>= k = \ r -> k (f r) r
13:14:38 <NikolajK> what's wrong with that?
13:14:59 <Xeironis> Oh, I didn't know you could ask for instances with @src
13:14:59 <naudiz> Twey vanila I've got a type Command = Cmd1 | Cmd2 | Cmd3 Text and a parsing function that takes a [Text], chooses a Constructor of Command by looking at head... but I don't know how to deal with different numbers of Constructor arguments
13:15:05 <Twey> @pl \x -> 2 * x * 2
13:15:05 <c_wraith> NikolajK: if you're using Integer or Int, it's fine.  It's not even neessarily true with Double.
13:15:06 <lambdabot> (4 *)
13:15:14 <Xeironis> @src (>>=)
13:15:14 <lambdabot> Source not found. You untyped fool!
13:15:16 <Twey> NikolajK: ^ this isn't true if 2 and x are matrices, for example
13:15:23 <dmj`> you untyped fool lol
13:15:36 <dmj`> gonna start using that
13:15:40 <Twey> Xeironis: (>>=) is a typeclass method, so you need to give it the instance
13:15:48 <naudiz> Iceland_jack: so you're saying, I shall change my type to type Command = Cmd1 [Text] | Cmd2 [Text] | Cmd3 [Text]? (see last post)
13:15:52 <Xeironis> Twey: Yeah, I just wanted to find out what happens if I try it anyway
13:15:56 <Twey> Ah ☺
13:16:13 <Iceland_jack> naudiz: I need to run now but you might want to pass it [Command]
13:16:28 <NikolajK> matrices? but 1 is a term of Num, no?
13:16:34 <NikolajK> :t 1
13:16:35 <lambdabot> Num a => a
13:16:47 <RedNifre> "Beginning Haskell" explains point-free style by writing 3x+7(x+2) as uncurry (+) . ( ((*7).(+2)) *** (*3) ) . duplicate. This doesn't make me see the benefit of point-free style... anyone know a better example?
13:17:03 <naudiz> Iceland_jack: I don't really get what you are trying to tell me, sorry
13:17:06 <c_wraith> RedNifre: yes, that's a horrible example. :)
13:17:12 <naudiz> but thanks anyway
13:17:16 <kristof> RedNifre: fun = otherfun
13:17:25 <kristof> RedNifre: Bam! Pointfree style.
13:17:29 <Twey> NikolajK: Num is a typeclass, not a type.  It's valid (I think) to define an instance of Num for matrices of size m×n, where e.g. 2 = 2I where I is the identity matrix for those dimensions
13:17:30 <c_wraith> RedNifre: sum = foldl' (+) 0
13:18:09 <Twey> RedNifre: mean = liftA2 (/) sum genericLength
13:18:20 <Twey> Hm
13:18:23 <Xeironis> @pl writeMyFile string = writeFile "myFile.jpg" string
13:18:24 <lambdabot> writeMyFile = writeFile "myFile.jpg"
13:18:30 <NikolajK> so you can redefine numbers like 5?
13:18:30 <kristof> Twey: But how would I derive a Num instance for *any* matrix of any dimension?
13:18:33 <Twey> RedNifre: mean = (/) <$> sum <*> genericLength -- I think I like this better
13:18:46 <vanila> NikolajK, if you make a num instance
13:18:48 <Twey> kristof: Unfortunately you can't — the kind of Num forbids it
13:18:48 <c_wraith> NikolajK: Not redefine.  Just explain what the literal "5" means as a value of your type
13:18:53 <Twey> kristof: Well, in any non-crazy way :þ
13:18:55 <RedNifre> oh, what do the <> mean?
13:19:10 <Xeironis> @src <$>
13:19:10 <lambdabot> f <$> a = fmap f a
13:19:11 <kristof> RedNifre: Nothing, but <$> and <*> are infix functions
13:19:14 <Xeironis> @src <*>
13:19:14 <lambdabot> Source not found. Are you on drugs?
13:19:17 <Twey> RedNifre: Nothing — <$> and <*> are operators on Applicative values
13:19:22 <Xeironis> oh, c'mon, lambdabot
13:19:33 <Xeironis> I guess it makes sense
13:19:45 <NikolajK> does @pl, if it "lies" sometimes, at least have any "best approximation" property? or how is it determined what it returns
13:19:48 <Twey> Xeironis: Again, (<*>) is a typeclass function
13:19:56 <Twey> @src (->) (<*>)
13:19:56 <lambdabot> (<*>) f g x = f x (g x)
13:20:10 <Xeironis> Twey: Yeah, I just realized that, hence the "I guess it makes sense"
13:21:18 * RedNifre is pondering...
13:21:26 <L8D> How should I go about shuffling a list in haskell?
13:21:38 * L8D is assuming to use the IO monad
13:21:48 <oleo> push the shuffle button!
13:21:50 <oleo> lol
13:22:07 <kristof> L8D: Fisher yates
13:22:07 <Xeironis> @src Maybe <*> -- am I doing something wrong?
13:22:07 <lambdabot> Source not found. :(
13:22:16 <L8D> Is there a library I can use that already has this implemented though?
13:22:23 <RedNifre> @src (->) (<$>)
13:22:23 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:22:27 <dmj`> L8D: generate a random list of numbers, then (zip . sort) randomNums yourList. This will shuffle them
13:22:38 <dmj`> and return yourList of course
13:22:44 <Xeironis> RedNifre: <$> is just defined as fmap, so you'd have to do @src (->) fmap
13:22:51 <L8D> dmj`: What's the library for random numbers again?
13:22:56 <dmj`> base
13:23:02 <dmj`> System.Random
13:23:06 <L8D> k thx
13:23:15 <nshepperd> L8D: http://hackage.haskell.org/package/random-shuffle
13:23:32 <dmj`> L8D
13:23:46 <L8D> dmj`: What?
13:23:53 <dmj`> System.Random is in random, not in base
13:23:56 <dmj`> my b
13:24:05 <Twey> dmj`: map snd . sort . zip randomNums  you mean?
13:24:43 <dmj`> Twey: oo yea, zip first, then sort
13:25:01 <dmj`> L8D: random isn't as performant as mwc-random, http://hackage.haskell.org/package/mwc-random
13:25:27 <L8D> Fuck. "System/Random.hs:217:12: parse error on input '<-'"
13:25:37 <kristof> You would think that truly random shuffling would be a solved problem, not subject to channel bickering.
13:25:48 <Twey> It is; see random-shuffle :þ
13:25:58 <MP2E> how does mwc-random compare to tf-random?
13:26:05 * MP2E 's head spins from all the random libraries
13:26:05 <kristof> Anyway, I had a question, but I can't seem to remember it.
13:26:15 <L8D> I'm on ghc 7.8.2
13:26:28 <erell> Hi there
13:26:33 <L8D> And I can't install text and now I can't install system.random for who knows what reason
13:26:37 <MP2E> L8D: might need to upgrade to 7.8.3, 7.8.2 has type checker bugs
13:26:55 <Twey> But if you don't care about security, something like  ($ nums) . fmap (map snd . sort) . zip <$> getStdGen  isn't bad
13:27:16 <erell> I just tried to install elm language as tell at https://github.com/elm-lang/elm-platform/blob/master/README.md#elm-platform
13:27:16 <L8D> Twey: I'm supposed to be building the backend to a casino
13:27:23 <Twey> L8D: Ah, you should probably care about security.
13:27:24 <L8D> an online casino*
13:27:49 <c_wraith> L8D: in that case, look into how the crypto packages manage randomness
13:28:02 <c_wraith> L8D: also, use a fischer-yates shuffle
13:28:09 <L8D> c_wraith:
13:28:15 <MP2E> L8D:
13:28:18 <L8D> I'm writing a prototype right now however
13:28:23 <MP2E> http://hackage.haskell.org/package/tf-random
13:28:26 <erell> Unfortunatly,  Memory(2Go) and swap(2Go) are full while "Compiling Text.Pandoc.Writers.Docx". I know there is a #elm but everybody's asleep for 10 hours.
13:28:44 <dmj`> > let randoms = [9,3,2,4,1,5,31,3,2,4]; sorted = [1..10] in map snd $ sort $ zip randoms sorted
13:28:46 <lambdabot>  [5,3,9,2,8,4,10,6,1,7]
13:29:11 <L8D> dmj`: I still want psuedo-randomness
13:29:21 <RedNifre> is infix a b * c or a * b c?
13:29:21 <erell> I will then precise my question : somebody here already installed elm-server?
13:29:29 <RedNifre> (i only know infix with two parameters)
13:29:50 <dmj`> L8D: then try mwc-random
13:30:02 <c_wraith> L8D: If you want to not be exploited, use something like http://hackage.haskell.org/package/crypto-random
13:30:08 <nshepperd> use the random-shuffle package, it already solved this...
13:30:11 <erell> Well, I will ask a second question, how can I clean cabal packages?
13:30:13 <c_wraith> L8D: if you're going to be secure, build it secure from the ground up
13:30:18 <c_wraith> nshepperd: that package is terrible
13:30:38 <nshepperd> ideally with some csprng, if you're running a casino
13:30:54 <c_wraith> nshepperd: it violates the use patterns expected with the RandomGen class, and it isn't even very good.
13:31:00 <L8D> c_wraith: K
13:31:24 <nshepperd> use patterns?
13:31:34 <c_wraith> nshepperd: operations *return the prng*
13:31:52 <c_wraith> nshepperd: the random-shuffle package does not
13:31:54 <vanila> http://lpaste.net/109895 How do I do a pure implementation of ST? I wrote the type sigs but i am stuck
13:31:55 <c_wraith> nshepperd: that's terrible
13:32:01 <nshepperd> oh, right, that
13:32:25 * RedNifre finishes pondering.
13:32:27 <Twey> vanila: You don't.  ST's magic.
13:32:45 <c_wraith> vanila: let me find an answer I wrote on SO about that
13:33:26 <L8D> Well shit. I can't upgrade to 7.8.3 because of parse errors
13:33:49 <Sizur> @t uncurry
13:33:49 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
13:33:51 <L8D> rm -rf ~/.cabal
13:34:26 <c_wraith> vanila: https://stackoverflow.com/questions/21612213/safe-use-of-unsafecoerce-from-gadt-existential/21616474#21616474
13:34:34 <Sizur> @djinn (a -> b -> c) -> ((a, b) -> c)
13:34:35 <lambdabot> f a (b, c) = a b c
13:34:53 <Xeironis> :t uncurry
13:34:54 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:35:35 <Sizur> @pl f a (b,c) = a b c
13:35:36 <lambdabot> f = (`ap` snd) . (. fst)
13:35:53 <L8D> :t ap
13:35:54 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:36:07 <L8D> :t push
13:36:09 <lambdabot> Not in scope: ‘push’
13:36:19 <L8D> What's the haskell version of push?
13:36:29 <Sizur> which push?
13:36:36 <Xeironis> :t (:)
13:36:37 <lambdabot> a -> [a] -> [a]
13:36:46 <RedNifre> So mean = (/) <$> sum <*> genericLength calculates the mean by using <*> to build something that takes the list parameter and calculate two values, and then the <$> puts those two values into the (/)... is this better than mean l = sum l / (genericLength l) ?
13:36:57 <c_wraith> RedNifre: it's identical
13:36:58 <nshepperd> oh, mwc-random provides uniformShuffle. I'll remember that for later
13:37:09 <c_wraith> RedNifre: they should compile to the exact same code
13:37:30 <RedNifre> c_wraith it does the same, but is the former code easy to read for experienced haskellers?
13:37:46 <Xeironis> L8D: push for what kind of stack?
13:37:47 <L8D> c_wraith: So for security I should go with system.random using seeds generated from cryptographically-secure randomness?
13:37:49 <vanila> How could we prove that it's impossible to implement ST in a pure way? Without unsafeCoerce?
13:37:56 <L8D> Xeironis: monads
13:38:08 <Xeironis> Monads are not inherently stacklike
13:38:25 <c_wraith> L8D: no, System.Random is insufficient, because StdGen isn't a CSPRNG
13:38:30 <RedNifre> As a beginner, the point-free one looks a lot harder to understand but I wonder if that's just because I'm new to Haskell.
13:38:39 <c_wraith> L8D: mwc-random doesn't provide a CSPRNG, either
13:38:44 <L8D> But I thought the counterpart to apply was push
13:38:59 <L8D> c_wraith: so where should I start/
13:39:17 <c_wraith> L8D: http://hackage.haskell.org/package/crypto-random
13:39:25 <L8D> c_wraith: awesome thanks
13:39:35 <c_wraith> L8D: it will be less convenient to use, but there are good reasons for that.
13:39:42 * hackagebot mqtt-hs 0.2.0 - A MQTT client library.  http://hackage.haskell.org/package/mqtt-hs-0.2.0 (LukasBraun)
13:39:43 <NikolajK> where to find <*> as induced by monads?
13:39:57 <Xeironis> RedNifre: simple applications of point-free style get quite easy to understand after a while, and can make things convenient. However, it's definitely possible to make the code unnecessarily complex by using point-free style where it's a lot easier to just use variables
13:39:59 <L8D> c_wraith: And I go with the list of random numbers getting zipped and sorted to perform shuffles?
13:40:14 <L8D> Or do I need to port code from random-shuffle?
13:40:19 <L8D> :s/need/should
13:40:39 <L8D> :s/do I should to/should I
13:41:01 <c_wraith> L8D: I don't see immediately where the zip/shuffle approach would go wrong.  Maybe it wouldn't.  But Fischer-Yates is simple and easy to prove correct.
13:41:14 <c_wraith> L8D: stick with things that are easy to prove are correct, instead of things you can't prove are wrong.
13:41:21 <L8D> c_wraith: Ok thanks
13:42:33 <c_wraith> Err.  Fisher-Yates.
13:44:16 <RedNifre> > foldr1 (+) [1,2,3]
13:44:18 <lambdabot>  6
13:44:42 <RedNifre> > foldr1 (+) []
13:44:43 <lambdabot>  *Exception: Prelude.foldr1: empty list
13:44:48 <RedNifre> > foldr (+) []
13:44:50 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
13:44:50 <lambdabot>    arising from a use of ‘M826547881056998445727779.show_M8265478810569984457...
13:44:50 <lambdabot>  The type variable ‘t0’ is ambiguous
13:44:50 <lambdabot>  Note: there are several potential instances:
13:44:50 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
13:44:53 <RedNifre> > foldr (+) 0 []
13:44:55 <lambdabot>  0
13:51:47 <Cale> It's amusing to think that it took two people to think of "Pick one thing at a time until all things are picked"
13:52:41 <kristof> Are we still talking about Fisher-Yates?
13:52:42 <kristof> ._.
13:53:13 <Xeironis> :t \mf ma -> mf >>= \f -> ma >>= f
13:53:14 <lambdabot> Monad m => m (a -> m b) -> m a -> m b
13:53:20 <Cale> Well, that's what my remark was directed at
13:53:22 <Xeironis> :t (<*>)
13:53:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:54:37 <Cale> It's sort of similar to Gram-Schmidt for being an algorithm with two people's names attached that has a really good chance of being the first thing that someone would think of.
13:55:12 <L8D> I don't know if my bosses are geniuses or not. They want all backend logic to be done in Haskell in simple stdin->stdout programs that get piped into websockets of node.
13:55:45 <L8D> Where node applies a filter to detect database calls
13:55:59 <Cale> heh
13:55:59 <L8D> And the client side code is done in elm...
13:56:13 <Cale> "We want all the backend logic in Haskell 1.0"
13:56:41 <silver> Floyd-Warshall? :D
13:56:51 <L8D> Cale: They think that simple IO programs are safer and easier to reason about
13:57:24 <L8D> I only know Haskell from reading through LYAHFGG
13:57:39 <L8D> And doing a bunch of weird side-project scripts
13:59:06 <Cale> Well, I can't say that I'd agree that letting node handle the I/O is any safer, but it is true that pure expression evaluation is simpler to reason about than code with lots of I/O in it.
13:59:44 * hackagebot xml-to-json 1.0.1 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-1.0.1 (NoamLewis)
13:59:46 <L8D> Cale: We're using Node since the rest of the app is already setup in node but they want all the casino game logic to be "safe"
13:59:59 <L8D> I'm not sure about the elm part though.
14:00:12 <kristof> That's not a bad thing.
14:00:43 <L8D> kristof: Well everything is already using JS and Backbone and now we're adding Elm to our stack of stuff to build.
14:00:44 <kristof> Let me say what you said differently: they want the logic of their game to be statically guaranteed to be correct.
14:01:07 <L8D> kristof: Yes. But I don't see why we need to use Elm on the client-side
14:01:20 <kristof> L8D: The client's browser is running too fast
14:01:29 <L8D> What?
14:01:56 <kristof> bad joke
14:02:10 <L8D> Elm is slow?
14:02:27 <kristof> not any slower than JS, I was kidding.
14:02:46 <L8D> I don't get the joke at all.
14:02:56 <kristof> Back me into a corner, why don't you? :)
14:03:16 <kristof> L8D: Since elm compiles to JS, I'm not sure why you're against adding something to the stack.
14:03:55 <dmj`> hey guys I'm having trouble getting at an Object inside of a Vector using Aeson. Here's my code, any advice on how to modify the parser? http://lpaste.net/109896, trying to return a [Type] instead of a Type.
14:04:14 <dmj`> I try to pattern match specifically on Array inside the parser as well
14:04:21 <L8D> kristof: Well, Elm is something that we have add to the technologies we're using and we have to add stuff to our codebase to properly support it
14:04:38 <L8D> kristof: And we already have a bunch of existing JS code that we're using (and not replacing with elm)
14:05:04 <kristof> L8D: What's it like trying to interop with elm from JS?
14:05:51 <L8D> I don't know yet.
14:05:54 <kristof> You're on the team, so I'm sure you know better than I do what kind of challenges there are in throwing a new technology on the stack :) I myself just can't see how it would complicate things very much.
14:05:58 <d-snp> hi guys, what is considered to be the most idiomatic library for executing shell commands from haskell? I want to execute them, give them a stdin stream and read their stdout, and also read their exit code
14:06:32 <kristof> d-snp: System.process
14:06:32 <RedNifre> When doing pattern matching, why are there brackets around lists? I.e. why f (x:xs) =... instead of f x:xs = ...?
14:06:33 <L8D> kristof: I have a problem with it because I don't see why we need it over the stuff we're already doing
14:06:58 <d-snp> thanks kristof, I'm currently looking at that one
14:07:09 <L8D> And I don't see any advantages of using it on the client-side
14:07:18 <Tuplanolla> Parentheses, to help the parser, RedNifre.
14:07:29 <Xeironis> RedNifre: That coudl be interpreted as f having three arguments, x, :, and xs.
14:07:31 <kristof> L8D: They like the static guarantees. I think that's fair. I've been bitten quite a few times by javascript semantics
14:07:49 <dmj`> d-np: I use io-streams since it wraps the handles in iteratees to avoid space leakage (System.IO.Streams.Process)
14:08:12 <dmj`> think there is conduit-process pkg that does something similar
14:08:14 <Tuplanolla> > let f ((:) x xs) = x in f "RedNifre"
14:08:15 <lambdabot>  'R'
14:09:13 <hodapp> I think everyone everywhere with any level of competence who has ever used JavaScript has been bitten by its semantics.
14:10:05 <kristof> hodapp: Precisely. :)
14:10:07 <Fuuzetsu> how can I export all lenses in a module where I do selective exports?
14:10:10 <Jodie22>  You can find funny videos here. http://bit.ly/1mFMmyS
14:10:22 <Fuuzetsu> Obviously I don't want to type it all out and have to update it by hand
14:10:32 <hodapp> Yeah, I bet the market for funny-video-consumers in #haskell is pretty huge.
14:10:32 <kristof> Fuuzetsu: Maybe you can use template haskell.
14:10:59 <Fuuzetsu> Well, that's what I assumed already, just wondering if anyone knows the magic incantation.
14:11:04 <kristof> *shrug*
14:11:04 <David> I just did cabal install lambdabot (via cabal) and I'm getting this error:
14:11:10 <dmj`> Fuuzetsu: you can use an intermediate module that you import selectively what you want, then re-export everything from there, then import the intermediate module elsewhere
14:11:11 <kristof> haskell metaprogramming is not my strong-suit
14:11:19 <RedNifre> Ah, so I can name arguments : ?
14:11:21 <David> [ERROR ] Plugin.djinnPluin: Djinn command failed: readProcess: djinn (exit 127): failed
14:11:24 <d-snp> ah System.Process is very nice indeed, very flexible
14:11:25 <Fuuzetsu> dmj`: OK, thought that might be the case
14:11:28 <David> when I do > 2 + 4, I just get "terminated"
14:12:10 <RedNifre> > let f x:xs = : in f "a" "b" "c"
14:12:11 <lambdabot>  <hint>:1:14: parse error on input ‘:’
14:12:26 <RedNifre> hm, apparently not...
14:12:40 <Tuplanolla> Define g = (:) and try with that first, RedNifre.
14:14:10 <RedNifre> Tuplanolla I don't understand what to do with that. And I don't understand why x:xs needs brackets if : is not a valid argument name.
14:15:04 <Tuplanolla> With that definition you have f (x : xs) = f ((:) x xs) = f (g x xs).
14:15:10 <Iceland_jack> RedNifre: because function application binds the tightest
14:15:22 <Tuplanolla> Just because (:) is infix doesn't change the rules.
14:16:06 <monochrom> > let {f ((:) x xs = ()} in f [1,2]
14:16:08 <lambdabot>  <hint>:1:18: parse error on input ‘=’
14:16:12 <Iceland_jack> If you read the definiendum as an expression you get how it associates
14:16:16 <monochrom> oops, my error
14:16:22 <monochrom> > let {f ((:) x xs) = ()} in f [1,2]
14:16:24 <lambdabot>  ()
14:16:27 <monochrom> nice
14:16:43 <L8D> I keep getting this: http://lpaste.net/109897
14:16:46 <L8D> I don't know what to do
14:17:41 <RedNifre> I still don't understand what f x:xs would mean.
14:17:42 <L8D> Wait nvm.
14:17:52 <L8D> RedNifre: f x:xs is a syntax error
14:17:58 <L8D> RedNifre: f (x:xs) is not
14:18:21 <vanila> f x:xs is (f x):xs
14:18:22 <Tuplanolla> It would be f x : xs, but the parser chokes on the fact it's not parenthesizes as f x (:) xs.
14:18:33 <Tuplanolla> Disregard that and listen to vanila.
14:18:34 <RedNifre> If it is a syntax error then it is unambiguous and I don't understand why I have to type the brackets.
14:18:44 <BMeph> RedNifre: f x:xs gets parsed as '(f x) : xs' FYI.
14:18:48 <vanila> > let f = (+1) ; x = 3 ; xs = [5,6,7] in   f x : xs
14:18:50 <lambdabot>  [4,5,6,7]
14:18:56 * RedNifre listens to vanilla
14:19:01 <RedNifre> *vanila
14:19:12 <Xeironis> RedNifre: Okay, maybe this is a better explanation. When you call a function f :: Maybe Int -> Int -> Int, you call it like f (Just 4) 4, because f Just 4 4 would be a function of type (a -> Maybe a) -> Int -> Int -> <something>. For consistency's sake, the same applies to function definition, not just function application. Again, for consistency's sake, the same also applies to constructors like (:)
14:19:27 <Iceland_jack> ghci> :paren f x:xs
14:19:27 <Iceland_jack> (f x) : xs
14:19:28 <Tuplanolla> > let f x (:) xs = x in f "RedNifre"
14:19:30 <lambdabot>  Constructor ‘:’ should have 2 arguments, but has been given none
14:20:18 <int-e> L8D: it looks like some of your installed packages are broken; have you run ghc-pkg check? and what are you trying to install?
14:20:19 <Xeironis> RedNifre: In addition to that, it's easier to implement the parser if parentheses are required
14:21:24 <RedNifre> Thanks, that makes sense.
14:21:46 <L8D> int-e: ghc-pkg just exploded a million lines of "x/x/x/x.hi is missing"
14:22:41 <Tuplanolla> I forgot you can't reuse the name of (:).
14:22:51 <Xeironis> I actually thought you could
14:23:04 <L8D> (:) is a type constructor, no?
14:23:08 <Tuplanolla> Yes.
14:23:09 <vanila> it's a data constructor
14:23:12 <L8D> ^
14:23:25 <Tuplanolla> :i :
14:23:26 <Xeironis> > isUpper (:)
14:23:27 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
14:23:27 <lambdabot>              with actual type ‘a0 -> [a0] -> [a0]’
14:23:29 <Xeironis> > isUpper ':'
14:23:31 <lambdabot>  False
14:23:46 <Tuplanolla> > :i :
14:23:47 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:23:58 <int-e> L8D: ok, how did you come by these packages, did you install them yourself or are they distribution packages? in the latter case, some -devel packages might be missing.
14:24:13 <Tuplanolla> @i :
14:24:13 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
14:24:22 <Xeironis> So does someone know why you can't use (:) as argument?
14:24:22 <Tuplanolla> I can't use this robotic maid.
14:24:31 <Xeironis> :t \a b (.) -> a
14:24:32 <lambdabot> t2 -> t -> t1 -> t2
14:24:36 <Xeironis> :t \a b (:) -> a
14:24:37 <lambdabot>     Constructor ‘:’ should have 2 arguments, but has been given none
14:24:37 <lambdabot>     In the pattern: (:)
14:24:37 <lambdabot>     In the expression: \ a b (:) -> a
14:24:40 <vanila> Xeironis, because it's a constructor
14:24:51 <Xeironis> vanila: So if I don't import Prelude, it would work?
14:24:54 <vanila> no
14:25:16 <vanila> Anything that starts with : is a constructor name in haskell
14:25:19 <L8D> int-e: I believe I removed ~/.cabal and install cabal-install
14:25:21 <Xeironis> ohh
14:25:23 <Xeironis> okay
14:25:24 <Xeironis> thanks
14:25:26 <L8D> installed*
14:25:29 <vanila> e.g. you can define data MyThing = X :+: Y
14:25:34 <vanila> and now  x :+: y :: MyThing
14:25:38 <L8D> installed cabal-install through a system package manager
14:25:40 <Xeironis> Yeah, okay
14:25:43 <int-e> L8D: oh, the package database is in ~/.ghc , you need to clean up there, too
14:25:50 <L8D> and downgraded ghc from 7.8 to 7.6 apparently
14:26:07 <L8D> int-e: ooh I missed that thanks
14:26:19 <dreams> Xeironis: what are you trying to do
14:26:36 <Xeironis> dreams: I don't think I'm trying to do anything
14:26:39 <monochrom> L8D: you may need to read my http://www.vex.net/~trebla/haskell/sicp.xhtml
14:27:22 <Xeironis> dreams: I just thought you could use (:) as argument name
14:27:54 <vanila> you can use operator names like (+)
14:28:02 <L8D> how do I open ghci in my cabal sandbox?
14:28:06 <vanila> > f (+) = 3 + 5 in f (*)
14:28:08 <lambdabot>  <hint>:1:7: parse error on input ‘=’
14:28:11 <vanila> > let f (+) = 3 + 5 in f (*)
14:28:13 <lambdabot>  15
14:28:40 <edwardk> Fuuzetsu: makeClassy instead of makeLenses then the lenses wind up bundled in the various HasFoo(..) classes.
14:28:58 <Tuplanolla> The simple explanation is that : is treated like capital letters, Xeironis.
14:29:07 <Tuplanolla> You can't do f X = X either.
14:29:24 <Xeironis> Tuplanolla: I thought it might have, that's why I tried isUpper ':' above, but I suppose it's an extra special case
14:29:26 <Fuuzetsu> I just dropped specific exports there, seems cleaner
14:29:35 <Xeironis> s/have/be
14:29:46 <Tuplanolla> My confusion had the same cause.
14:30:45 <dreams> :t \ ((:) a b) -> b
14:30:47 <lambdabot> [t] -> [t]
14:30:50 <dreams> Xeironis: ^
14:31:12 <Xeironis> dreams: You're not using (:) as an argument name, though, you're using a and b as argument names
14:32:43 <dreams> Xeironis: alright then:
14:32:46 <dreams> :t \ [] -> b
14:32:47 <lambdabot> [t] -> Expr
14:33:06 <dreams> this might give you a hint.
14:34:08 <Xeironis> I'm not sure what you're trying to give me a hint to, to be honest. It was established that it's not possible because : is treated like an uppercase character and therefore like a data constructor, which you can't use as argument name
14:34:35 <RedNifre> Hm... if I have a list of datas that all have the same field and I want to fold based on that field, but get the actual containing data as a result, how do I do that?
14:34:50 <vanila> Xeironis, I think dreams is implying that constructors must be fully applied to use in a pattern match
14:35:01 <Xeironis> ah
14:35:23 <vanila> RedNifre, you could first map unField
14:35:28 <vanila> where unField (Field d) = d
14:35:35 <L8D> How should I generate a random number from a ByteString?
14:35:55 <RedNifre> And please correct me whenever I use the wrong vocabularies, it's all very new to me :)
14:36:43 <RedNifre> What I currently have is this: foldl1 (\x y -> if (length (clientName x) < length (clientName y)) then x else y)  clients
14:36:46 <Tuplanolla> Data doesn't have a plural, but otherwise you're golden, RedNifre.
14:37:23 <Xeironis> I think data is plural, as well as singular
14:37:34 <RedNifre> singular is datum, but nobody uses that
14:37:36 <Tuplanolla> I tried to say that.
14:37:38 <vanila> RedNifre, that's fine as is
14:37:52 <Tuplanolla> No "datas".
14:38:07 <RedNifre> well, I'd like to replace the if < then a else b with something like min
14:38:36 <vanila> minBy f x y = if f x < f y then x else y
14:38:45 <vanila> foldl1 (minBy (length . clientName)) clients
14:39:35 <RedNifre> I mean, the feeling I get from what I know about Haskell so far tells me that there is a way to fold by applying a function to something that is inside the data in the list, but still return the data.
14:39:49 <vanila> there's not
14:40:15 <kristof> Is there any definitive literature to designing foreign function interfaces?
14:42:49 <Laquendi> does anyone have sane haskell configs for vim-easy-align or similar plugin?
14:44:53 <RedNifre> That one would work for both min and max: indirect function field a b = if function (field a) (field b) == field a then a else b
14:49:10 <L8D> How do I get an Int from Word8?
14:49:31 <Xeironis> :t fromInteger Word8
14:49:31 <Fuuzetsu> :t fromIntegral (1 :: Word8)
14:49:32 <lambdabot>     Not in scope: data constructor ‘Word8’
14:49:32 <lambdabot>     Perhaps you meant ‘Word’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:49:34 <lambdabot> Num b => b
14:49:38 <Iceland_jack> @ty fromIntegral (undefined :: Word8) :: Int
14:49:39 <lambdabot> Int
14:49:48 <Xeironis> oops
14:50:34 <L8D> thanks
15:00:14 <David> is it OK to remove ~/.cabal/packages to save space?
15:00:27 <RedNifre> What's up with "let" and "where"? Aren't those two the same thing?
15:00:38 <David> they're different, scoping wise
15:01:02 <David> http://www.haskell.org/haskellwiki/Let_vs._Where
15:01:31 <Tuplanolla> All these questions would vanish if Haskell had as much syntax as Scheme.
15:04:07 <L8D> @djinn \(x, y) -> (f x, y)
15:04:07 <lambdabot> Cannot parse command
15:04:23 <L8D> @djinn 1 + 1
15:04:24 <lambdabot> Cannot parse command
15:04:26 <L8D> what
15:04:49 <Tuplanolla> Djinn is a program generator. Give it a type.
15:04:58 <L8D> What's the other thing
15:05:03 <RedNifre> Thanks, but that link is too difficult for me. I'll ignore let vs where for now.
15:05:11 <Tuplanolla> @djinn (x, y) -> (Maybe x, y)
15:05:12 <lambdabot> f (a, b) = (Just a, b)
15:05:21 <L8D> The other command that makes code smaller
15:05:23 <Tuplanolla> @pl \ (x, y) -> (f x, y)
15:05:24 <lambdabot> first f
15:05:35 <Tuplanolla> The executable is called pointfree.
15:05:47 <L8D> @pl \(x, y) -> (f x, y)
15:05:48 <lambdabot> first f
15:06:25 <L8D> :t first
15:06:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
15:06:54 <David> is there a way to have lambdabot connect to a passworded server?
15:06:54 <Laquendi> RedNifre: where is arguably nicer syntax but you can't always use it, let is more general but not as nice
15:07:29 <L8D> @hoogle first
15:07:30 <Markz> is there an equiv put for gets?
15:07:32 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:07:32 <lambdabot> Text.PrettyPrint.HughesPJ first :: Doc -> Doc -> Doc
15:07:32 <lambdabot> package first-class-patterns
15:07:41 <L8D> Ugh
15:09:33 <barrucadu> L8D: Arrow is a generalisation of the function arrow (->), which also has an Arrow instance. So when talking about regular functions, you can read the type of first as "(->) b c -> (->) (b, d) (c, d)", or "(b -> c) -> (b, d) -> (c, d)"
15:10:01 <barrucadu> So, it applies a function to the first component of a tuple
15:10:07 <barrucadu> (a two-element tuple)
15:10:20 <L8D> barrucadu: Yeah I'm familiar with arrow
15:11:47 <barrucadu> Ah, right. Thought you were ughing at the type
15:12:47 * BMeph prefers the form, "first :: (b ~> c) -> ((b, d) ~> (c , d))" ;)
15:13:06 <kristof> Squiggly arrows :o
15:13:09 <kristof> only in Haskell.
15:13:33 <L8D> double-dash comments :o
15:13:36 <L8D> only in Haskell.
15:13:59 <zomg> ^ and SQL
15:14:20 <Tuplanolla> I wouldn't be surprised if Perl had ~> too.
15:14:30 <zomg> Tuplanolla: yeah I was about to suggest that... :D
15:15:03 <L8D> Tuplanolla: I believe that ~> is for piping output of system spawns in perl
15:15:10 <L8D> iirc
15:15:17 <L8D> Perl was such a nightmare
15:15:36 <kristof> A long time ago, people could pronounce the names of their functions.
15:15:42 <Tuplanolla> It still exists.
15:16:18 <L8D> kristof: have you ever written javascript?
15:16:27 <L8D> You can pronounce those function names pretty easily
15:16:35 <kristof> Say this out loud! <*$> = (<$>) . (<*>)
15:16:35 <zomg> My perl experience: Write an Irssi script in Perl, manage to lock up Irssi every time it loads
15:17:01 <L8D> especially since all variables are supposed to be 3-7 character long single words
15:17:17 <L8D> like config, database, callback, request, response
15:17:28 <L8D> or config, db, cb, req, res
15:17:41 <L8D>  and options -> opts
15:17:49 <zomg> convention similar to x:xs :p
15:18:01 <L8D> But my company's style guide always sticks to longer-ish variable names
15:18:09 <L8D> but never local variables with more than one word
15:18:31 <kristof> L8D: Good. If you through "res" at me and I couldn't see a "req" anywhere, then I would never have any idea what you're talking about
15:18:34 <kristof> *threw
15:19:14 <L8D> It becomes surprisingly readable when all the variables are just nouns
15:20:06 <L8D> The only exception is when we use the variables "x" and "y" when keeping track of coordinates on a canvas
15:20:08 <kristof> In other news: admittedly, to this day, I still don't know how dynamically constructing functions at runtime works.
15:20:30 <zomg> var butts = new Function('magic();');
15:20:39 <kristof> Especially in a non-interpreted, statically typed language.
15:21:00 <L8D> zomg: var butts = function() {
15:21:04 <L8D>   magic();
15:21:08 <L8D> };
15:21:22 <zomg> Yeah I tried to think of the worst way to do it
15:21:24 <zomg> =)
15:21:24 <L8D> But then our linter throws an error
15:21:39 <L8D> Because we do not allow functions that take no arguments and return nothing
15:21:57 <kristof> L8D: why not?
15:21:58 <zomg> I want to work at your company
15:22:03 <zomg> It sounds much better than the one I work at now
15:22:04 <zomg> lol
15:22:32 <L8D> kristof: Because that is inherently bad way to write code
15:22:48 <dreams> Which parser combinator tutorial would you recommend?
15:22:58 <kristof> L8D: public void fireMissiles() { launchMissiles(); launchMissilesAgain(); thisTimeatKorea(); }
15:23:01 <L8D> zomg: You can get an internship right now. But we don't have the budget to hire another programmer.
15:23:43 <L8D> Actually an unpaid internship wouldn't be official since our company hasn't done all the paperwork to be all official and hist
15:24:31 <Tuplanolla> Hist for histogram?
15:24:44 <zomg> I would probably be the best intern ever
15:24:45 <sbrg> an 'unpaid internship' in my country would get that company sued into the ground
15:24:48 <sbrg> and IMO, rightfully so.
15:25:12 <kristof> L8D: I'm writing a scheduler right now and that's exactly the type signature of my scheduling function. It takes no arguments because all it does is pop something off of the task queue. Then, it runs that missile launching task, and finally it returns nothing because nobody cares.
15:25:13 <zomg> zomg, senior developer/architect/cto intern
15:25:15 <zomg> lol
15:25:29 <kristof> L8D: Actually, more specifically it tail-calls itself but that's beyond the point. :)
15:26:03 <L8D> sbrg: Why so?
15:26:30 <Xeironis> > (1 / (-0)) == (1 / 0)
15:26:32 <lambdabot>  False
15:26:35 <Xeironis> teehee
15:27:07 <sbrg> because creating a market where companies can actually allow themselves to offer unpaid internships to get free labor, forcing a bunch of people to work for free in order to be competitive is just .. inhumane
15:28:07 <L8D> sbrg: Do you mind me asking which country? Because there are several companies in the US that offer unpaid internships
15:28:11 <sbrg> Denmark
15:28:13 <sbrg> Yes, I know.
15:28:16 <L8D> okay
15:28:23 <L8D> That makes sense
15:29:59 <zomg> Finland has something you could kinda-sorta compare to that
15:30:29 <zomg> but it's really more like on the job training during studies
15:32:16 <sbrg> That is paid here as well. Education is not only free, but you get paid for it(not a loan). Additionally, education that also consists of 'work training' means you either get paid more during those periods, or you get paid the normal study.. pay, or whatever. depends on the education.
15:32:21 <sbrg> anyway, probably #haskell-blah
15:35:44 <L8D> Wait...so what is the big point of haskell-blah? Is it just a casual channel for people with minds that like haskell?
15:35:53 <athan> Alright guys, I'm going to play with continuations for a second, I hope you all don't mind
15:36:12 <athan> @let add_c x y = \k -> k (x + y)
15:36:15 <lambdabot>  Defined.
15:36:27 <athan> > add_c 1 2 print
15:36:30 <lambdabot>  <IO ()>
15:36:38 <athan> > add_c 1 2 id
15:36:39 <lambdabot>  3
15:36:51 <athan> :t add_c 1 2 (&)
15:36:53 <lambdabot> Num a => (a -> b) -> b
15:36:57 <athan> :t add_c 1 2 (&) (&)
15:36:59 <lambdabot> Num a => (a -> b) -> b
15:37:09 <athan> > add_c 1 2 (&) (&) (&) (&) (&) id
15:37:12 <lambdabot>  3
15:37:16 <athan> awwww yisssss
15:37:25 <int-e> L8D: it's good to have a place where off-topic discussions can continue when they get out of hand here
15:37:39 <L8D> ah
15:44:06 <zq> is there a way to assert against integer underflow with a type system?
15:44:22 <zq> yes i know about refinement types
15:45:27 <Tuplanolla> Dependent types allow that, zq.
15:46:24 <Tuplanolla> That's outside Haskell though.
15:47:24 <Xeironis> athan: In case you ever want to do something with lambdabot that you don't to have in #haskell, you can always message lambdabot privately
15:48:32 <athan> Xeironis: Thanks, I kinda wanted to show noobs my little discovery :)
15:48:42 <Xeironis> Alright :)
15:49:06 <athan> Tupanolla: What about with DataKinds, TypeFamilies and GADTs, though? :P
15:53:07 <RedNifre> > group [1,2,2,2,3,2,2]
15:53:10 <lambdabot>  [[1],[2,2,2],[3],[2,2]]
15:55:11 <athan> @src group
15:55:11 <lambdabot> group = groupBy (==)
15:55:15 <athan> >_>
15:55:40 <athan> @src groupBy
15:55:41 <lambdabot> groupBy _  []     =  []
15:55:41 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
15:55:41 <lambdabot>     where (ys,zs) = span (eq x) xs
15:56:14 <RedNifre> Seems that there is an error in the Beginning Haskell book.
15:56:51 <RedNifre> The author assumes that group/groupBy actually group based on the whole list, similar to nub, but it seems that you have to sort the list first
15:57:14 <RedNifre> how counter intuitive. Why does group/groupBy only group consecutive elements?
15:57:23 <Xeironis> RedNifre: Because it's a useful function
15:57:34 <athan> RedNifre: Well, then you'd have to do some form of accumulation on the fold, also
15:57:54 <RedNifre> > nub [1,2,2,2,3,2,2]
15:57:56 <lambdabot>  [1,2,3]
15:58:08 <athan> @src nub
15:58:08 <lambdabot> nub = nubBy (==)
15:58:12 <athan> >>__>>
15:58:15 <athan> @src nubBy
15:58:15 <lambdabot> nubBy eq []     = []
15:58:16 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:58:16 <nedbat> RedNifre: isn't it because if you wanted it sorted, you could sort it, but if it always sorted, and you didn't want it, there'd be no way to avoid it?
15:58:17 <RedNifre> :D
15:58:44 <RedNifre> How can I get a nub that answers [1,2,3,2]?
15:59:00 <athan> RedNifre: That would be a good exercise :)
15:59:04 <RedNifre> Seems weird that nub and group differ in that way.
15:59:07 <nedbat> i'm in #python a lot, which doesn't have an execution bot like lambdabot.  Is it accepted here that people will execute things in the channel like this?
15:59:25 <hpc> yes
15:59:27 <RedNifre> I sure hope so, since I didn't ask :o
15:59:38 <hpc> there's security measures to prevent nefariousness
15:59:40 <athan> nedbat: So long as it's not excessive (I approach the line simetimes :/)
15:59:42 <hpc> first among them being the type system
15:59:52 <nedbat> hpc: it isn't considered noisy?
15:59:52 <Tuplanolla> There's a C bot on ##c, hpc.
16:00:02 <hpc> it's part of the conversation
16:00:19 <RedNifre> I usually don't use lambdabot while other people are discussing something.
16:00:21 <nedbat> hpc: ok, cool.  Interesting to see how different channels operate
16:00:28 <athan> foldr (forkIO) () [1..]...
16:00:42 <Nimatek> You can also pm lambdabot.
16:02:20 <Tuplanolla> There's another bot on #chicken, but they don't trust their own sandbox enough to run code in it.
16:03:38 <athan> ...? Chicken?
16:03:46 <Tuplanolla> It's a Scheme system.
16:04:07 <athan> That's cool haha
16:04:24 <Xeironis> huh, according to hoogle, the name `nub' means essence
16:05:03 <Xeironis> I don't quite see how those two words are related
16:06:22 <Xeironis> Oh, is it an actual English word?
16:06:28 <Xeironis> That would make sense, I suppose
16:13:42 <lpaste> d-snp pasted “Pipes type signature” at http://lpaste.net/109902
16:14:13 <d-snp> hi, can someone help me out with the above error, I'm not sure what's going wrong
16:15:07 <glguy> d-snp: Take the "MonadIO m =>" out of the result type put move it up to just after the ::
16:15:17 <d-snp> ohh
16:17:00 <RedNifre> > zip [1,1,1]
16:17:02 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
16:17:02 <lambdabot>    arising from a use of ‘M592992595655730205130791.show_M5929925956557302051...
16:17:02 <lambdabot>  The type variable ‘b0’ is ambiguous
16:17:02 <lambdabot>  Note: there are several potential instances:
16:17:02 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:17:09 <d-snp> hmm that didn't fix it glguy
16:17:18 <RedNifre> > zip [1,1,1] [1..]
16:17:19 <lambdabot>  [(1,1),(1,2),(1,3)]
16:17:22 <glguy> d-snp: Well, there were two of them, so do both
16:17:28 <glguy> or show me what you changed it to
16:18:01 <glguy> d-snp: Oh, so there's another issue
16:18:10 <glguy> but one is hidden from you
16:18:15 <glguy> type Producer' b m r = forall x' x. Proxy x' x () b m r
16:19:03 <glguy> You just need to memorize that this is not a normal type synonym
16:19:10 <d-snp> eh ok :P
16:19:10 <glguy> you can't put this inside a tuple
16:19:20 <glguy> notice the "forall" on the right side of the =
16:19:48 <glguy> What you can do is expand the type synonym
16:21:35 <d-snp> does the forall x' x. mean that I could just use Producer instead? it's been a while since I read about pipes, but I can't imagine I'd have to wrestle through complicated type stuff just to return a producer of strings
16:21:37 <lpaste> glguy annotated “Pipes type signature” with “Pipes type signature (annotation)” at http://lpaste.net/109902#a109904
16:22:04 <glguy> d-snp: Try something like that. I don't know what you're "supposed" to do, I don't use Pipes
16:22:24 <glguy> but I believe that's what you'll need to do to make what you wrote work
16:22:40 <d-snp> alright thanks, I'm going to try that
16:39:50 <dfeuer> Does anyone know whose work this is? http://www.cs.york.ac.uk/fp/darcs/fusion/
16:40:54 <djahandarie> dfeuer, Malcolm Wallace in all likelihood.
16:46:56 <lpaste> d-snp revised “Pipes type signature”: “No title” at http://lpaste.net/109902
16:48:15 <dfeuer> djahandarie: any idea what happened with that work?
16:48:52 <lpaste> d-snp revised “Pipes type signature”: “Closer just one erronous line left” at http://lpaste.net/109902
16:49:06 <djahandarie> dfeuer, no idea.
16:49:29 <d-snp> now just running the pipes is the problem
16:49:37 <sccrstud92> if I have a type with 3 type parameters, how can I define an Arrow instance for it using the first and second parameters
16:50:05 <vova> could someone help me with handling the type elements. Please see the example http://pastebin.com/XYLyW21M
16:50:17 <vova> I know that it's wrong
16:50:50 <vova> but how to do it right?
16:54:37 <sccrstud92> for example, if I want to create an Arrow instance for MyArrow a b c using a and b, how would I do that?
16:54:49 <d-snp> eh wtf, I changed >~ to >-> and it worked :P
16:56:02 <burp> vova: what do you mean with handling the type elements, doing it right?
16:57:12 <burp> seems the code you posted works, I'm not sure what you inteded to do instead of the code you posted
16:58:17 <vova> I would like to get the result as in the example. in my opinion such code is wrong because I change the type elements inside the function
16:58:19 <Markz> is there a way to handle hPutChar erroring?
16:59:25 <vova> Yes, the code works as i except, but seems it's not a good idea to do so
17:00:28 <vova> burp, :)
17:02:35 <burp> you can write like gigi x | some1 x == "one" = "one" ++ gigi (x { some1 = "" })
17:02:58 <burp> as an "alternative"
17:03:03 <burp> otherwise I don't know ;)
17:03:31 <burp> these are pattern guards
17:04:28 <vova> I wrote the same code with guards, it's almost the same. The input type elements are needed to change as well.
17:05:02 <burp> how would you want to have it, in principle?
17:05:25 <vova> Is there any way to make a recursion for type elements as it is for lists?
17:06:03 <hpc> there are types for that
17:06:08 <hpc> @src Free
17:06:08 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
17:06:17 <hpc> @src Mu
17:06:17 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:06:22 <hpc> there's one of them
17:07:48 <vova> burp: I would like to check the type elements one by one, and depends on their values generate the list
17:09:19 <vova> burp: I know that it can be done using monads, but as for me it's not a good idea too.
17:09:53 <burp> no idea from my side
17:10:46 <vova> ok, thanks anyway
17:12:51 <slack1256> what does seq do on functions?
17:12:59 <slack1256> let a = id . id
17:13:11 <slack1256> seq a () does something?
17:14:14 <hpc> slack1256: that's the same as just a ()
17:14:43 <hpc> on functions, seq is able to distinguish between _|_ and \_ -> _|_
17:15:13 <hpc> otherwise it's the same general idea as seq on anything else
17:15:44 <slack1256> Mmm I heard that, that is what people refer to breaking eta law right?
17:17:31 <hpc> yes
17:20:56 <athan> callCC is blowing my mind. Could case statements be implemented with callCC?
17:22:57 <hpc> there's a lot you can do with it
17:24:03 <athan> @src callCC
17:24:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:24:10 <athan> @src callcc
17:24:10 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:24:26 <hpc> yeah, the definition is awful
17:24:40 <hpc> if i had it in front of me i could tell you what each piece did, but writing it myself no way
17:24:55 <hpc> djinn figures it out fine though
17:25:32 <gdoteof> if i have a [FilePath] how can I filter out files that don't exist?   i tried `  sequence $ fmap (filter doesFileExist) filepaths
17:25:56 <gdoteof> but i can't get the types right without being verbose
17:26:14 <hpc> be verbose
17:26:44 <hpc> not everything has to be one line, and haskell actually is a great language to get liberal with imperative style
17:27:38 <athan> @djinn ((a -> m b) -> m a) -> m a
17:27:38 <lambdabot> -- f cannot be realized.
17:27:42 <athan> :(
17:27:49 <gdoteof> hpc, i am.. but am also trying to grok it.. and it is pretty straight forward "map the function, 'select only files that exist' over 'these files'
17:28:06 <hpc> @src filterM
17:28:06 <lambdabot> Source not found.
17:28:12 <hpc> :t filterM
17:28:13 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
17:28:19 <hpc> oh, there we go
17:28:41 <hpc> somehow i forgot filterM takes an action as the predicate
17:29:19 <RedNifre> Can you recommend any tutorials for using vim with the haskell plugin?
17:30:29 <gdoteof> hpc: thanks that is def what i needed
17:32:42 <dreams> hpc: Haskell program coverage?
17:32:58 <hpc> headprogrammingczar
17:33:16 <hpc> a friend called me that in high school and i thought "sure why not?"
17:33:59 <athan> not high performance computing o.O?
17:34:24 <hpc> maybe it stands for "haskell, perl, c" :P
17:35:20 <athan> :)
17:35:30 <hpc> the three major nerd groups
17:37:01 <dreams> hpc: that is a haskell tool btw.
17:37:14 <hpc> i know :P
17:37:20 <hpc> i get pinged for it frequently
17:45:26 <henk> hi, I’m trying to run lambdabot on my debian stable server from the debian package lambdabot, but I fail to find good documentation on how its config is supposed to look like. Is there a manual anywhere?
17:45:53 <hpc> lambdabot is our secret shame
17:47:11 <hpc> not finding any dedicated docs on the config in the usual places
17:47:15 <hpc> http://hackage.haskell.org/package/lambdabot
17:47:38 <hpc> see the home page and the source repo links, maybe something is there i missed in a quick glance
17:47:54 <hpc> otherwise perhaps check individual modules, or use the source luke
17:48:48 <benzrf> is there a replicateM but with mappend instead of sequence
17:49:07 <henk> hpc: ok, I will dig deeper, thanks
17:50:10 <benzrf> @hoogle Monoid m => Int -> m -> m
17:50:12 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
17:50:12 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
17:50:12 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
17:50:24 <benzrf> er mconcat not mappend
17:50:34 <benzrf> :t mconcat .: replicate
17:50:35 <lambdabot>     Not in scope: ‘.:’
17:50:35 <lambdabot>     Perhaps you meant one of these:
17:50:35 <lambdabot>       ‘.’ (imported from Data.Function),
17:50:42 <benzrf> @let (.:) = (.).(.)
17:50:45 <lambdabot>  Defined.
17:50:46 <benzrf> :t mconcat .: replicate
17:50:47 <lambdabot> Monoid c => Int -> c -> c
17:50:50 <benzrf> cool
17:53:52 <sgronblo> Anybody know how to "cabal get" all the build-deps?
18:00:35 <lispy> sgronblo: there is a flag. It's like --deps-only or something similar
18:06:39 <rola> i'm trying to get an recent version of ghc on debian jessie using http://deb.haskell.org/, but i'm getting: E: Package 'libffi5' has no installation candidate (i have libffi6 though)
18:07:33 <athan> So, with CPS, you can construct monads that use the continuation function parameter as the escaping method within the calculation - would `bind` propogate a called continuation?
18:08:11 <rola> actually: The following packages have unmet dependencies: ghc : Depends: libffi5 (>= 3.0.4) but it is not installable
18:08:48 <athan> so if I have `foo x = callCC $ \k -> if x > 5 then k "bar" else x-3`, and I do `(foo >>= foo) 7`, would the result still be "bar"?
18:09:13 <athan> (I doubt that code typechecks btw, sorry :/)
18:09:31 <athan> copumpkin: catapumpkin
18:10:00 <stalintrotsky> @pl (\x y -> x ++ '\n' : y)
18:10:01 <lambdabot> (. ('\n' :)) . (++)
18:10:06 <copumpkin> :)
18:11:22 <athan> :P
18:11:52 <sgronblo> lispy: maybe you are referring to cabal install?
18:13:00 <dreams> What is the top-level of an expression? the left outermost redex?
18:13:14 <lispy> sgronblo: ah yes, I am.
18:14:13 <lispy> sgronblo: adding that flag to cabal get would be a nice feature
18:14:24 <sgronblo> lispy: so... not possible?
18:14:44 <sgronblo> i would have to manually parse the file and call cabal get on each of the build-depends?
18:15:05 <lispy> sgronblo: if it's not in the output of cabal get --help, then probably not. You might be able to simulate it with the sandboxing.
18:15:29 <lispy> if you wanted to implement it, I think  you could basically do the same thing as cabal install but just don't build anything.
18:15:32 <sgronblo> What I wanted to do, is keep the source of all the build-deps and then create a special tags file for that so I can tagjump to the yesod source files etc.
18:15:47 <trap_exit> is there a ghc pragma to say "pretend all functions have been tagged {-# INLINE ... #-}" ?
18:15:56 <trap_exit> I really don'g care about code size, and just want to see what happens
18:16:19 <geekosaur> I don't think so; as a big hammer, it's very good at shattering stuff
18:17:16 <lispy> sgronblo: maybe look at the freeze stuff?
18:17:40 <carter> trap_exit: inlining aint safe/allowed for recursive stuff
18:17:42 <lispy> sgronblo: http://blog.johantibell.com/2014/04/announcing-cabal-120.html
18:17:53 <carter> trap_exit: there some flags to make it look cheaper to inline stuff
18:17:58 <trap_exit> carter: right, so in those cases, the compiler just ignores it, no ?
18:18:01 <geekosaur> (what happens is that stuff gets inlined that interferes with other things and you lose a lot of valuable optimizations. and yes, it fails with recursion)
18:18:08 <carter> trap_exit: not quite
18:18:13 <trap_exit> carter: i.e. I do not expect inlining an recursive function to infinite loop the compiler
18:18:20 <trap_exit> carter: can't it just do some type of directed acyclic graph of what function calls what
18:18:23 <trap_exit> carter: and then not allow loops ?
18:18:24 <carter> not quite
18:18:34 <trap_exit> carter: I thought this is cycle detection in graphs 101
18:18:35 <lispy> sgronblo: Maybe what you could do is configure it, freeze it, record/tag the specific versions, and do it that way?
18:18:35 <carter> trap_exit: if you write mutually recurisive stuff
18:18:48 <trap_exit> carter: yeah, those are cycles
18:18:49 <carter> you can break how it chooses to do the loop breaker
18:18:50 <trap_exit> like f -> g, and g -> f
18:18:52 <lispy> sgronblo: then later you can jump back to a specific configuration
18:19:07 <carter> even worse
18:19:09 <trap_exit> oh, as in do I inline f within g, or do I inline g within f ?
18:19:18 <carter> partly that
18:19:28 <carter> BUT also if you emulate ycombinatory things
18:19:32 <carter> they dont look cyclic
18:19:34 <trap_exit> hmm, there should be an option of -Xinline_all_functions_not_involved_in_recursive_calls
18:19:47 <trap_exit> carter: hmm
18:19:56 <trap_exit> carter: your log sounds reasonable
18:20:01 <joe9> In C programming language, when using signal handlers, the recommended action is to set a flag and execute an action in the main loop using that flag. How would that translate to haskell programming with signal handlers. Haskell does not have the concept of global flags. Should I just execute the action in the signal handler?
18:20:02 <trap_exit> s/log/logic
18:20:27 <carter> trap_exit: inlining can be a real perf loss
18:20:29 <trap_exit> joe9: err, I thikn it'd all be stuck in an IO(..) since settinga global flag modifies state
18:20:42 <carter> in fact, johnw hit that with some work code of his
18:20:46 <trap_exit> carter: why? I thought it just lets the compiler simply stuff before hand
18:20:57 <carter> trap_exit: inlining doesn't make stuff faster
18:21:01 <sgronblo> lispy: sounds like a lot of work for me at the moment
18:21:05 <trap_exit> inlining expands code
18:21:07 <carter> yes
18:21:09 <slack1256> joe9: there is installSigHandler function.
18:21:10 <trap_exit> which, in theory, sould allow pre-runtime simplifications
18:21:10 <carter> which makes it slower
18:21:14 <carter> nope
18:21:14 <sgronblo> I cant believe nobody needed this before me
18:21:24 <trap_exit> why does expanidng code in place make it slower?
18:21:25 <carter> trap_exit: only when it triggers simplifications
18:21:39 <carter> otherwise you spend all your time loading new code from memory so you can run it
18:21:40 <trap_exit> at the very least, it saves a pc-counter jump
18:21:43 <slack1256> the other is that in your main loop you do `catch` for UserError (that include some signals)
18:21:47 <trap_exit> carter: besides bloated code size, what iis the down side of inlining?
18:21:59 <carter> trap_exit: cpu caches are thing
18:22:11 <slack1256> yep
18:22:15 <carter> thats like saying "aside from being memory bandwidth bound, whats the problem"
18:22:27 <carter> being memory bandwidth bound === slow
18:22:41 <carter> trap_exit: inlining is only sound for nonrecursive computations
18:22:43 <joe9> slack1256: I know about installHandler. Is thare an installSigHandler too?
18:22:47 <carter> i abuuse it a lot in that case
18:22:49 <carter> but it has a cost
18:22:54 <joe9> trap_exit: thanks.
18:23:05 <slack1256> joe9: Yeah, I used it sometime ago, let me find that files and modules to tell you
18:23:10 <carter> trap_exit: anyways, theres flags that doe tha tfor ghc already
18:23:18 <trap_exit> carter: which fpags?
18:23:23 <joe9> slack1256: thanks.
18:23:35 <carter> trap_exit: a few in http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#options-f
18:23:39 <geekosaur> I alluded to something else earlier as well. indiscriminate inlining can cause ghc to miss fusion opportunities... so something that should compile to a tight loop instead does massive allocations
18:23:44 <carter> -fexpose-all-unfoldings is one
18:23:57 <carter> -funfolding-creation-threshold=n:
18:23:59 <trap_exit> carter: -fexpose-all-unfoldings ?
18:24:01 <carter> -funfolding-use-threshold=n
18:24:26 <carter> trap_exit: those three
18:24:32 <carter> plus a few other ones i can't find right now
18:24:57 <slack1256> joe9: I remembered incorrectly, I uses System.Posix.Signals and usually do a "installHandler sigTERM (Catch (exitImmediately ExitSuccess)) Nothing"
18:25:10 <carter> i think some of the flags elsewhere
18:25:12 <trap_exit> carter: got it, so keyword is "unfolding"
18:25:12 <carter> mebe things like
18:25:13 <carter> -fsimplifier-phases
18:25:13 <carter> -fmax-simplifier-iterations
18:25:14 <carter> -fsimpl-tick-factor
18:25:15 <carter> -fspec-constr-threshold
18:25:19 <trap_exit> carter: thanks for taking your time to walk me through the various tradeoffs
18:25:20 <trap_exit> I apprecaite it
18:25:28 <carter> hah
18:25:33 <carter> this is me being lazy
18:26:07 <joe9> slack1256: I think I need MVar : http://therning.org/magnus/archives/285
18:26:14 <carter> mvars are nice
18:26:38 <slack1256> joe9: there is also catching `data AsyncException' in Control.Exception
18:27:30 <joe9> slack1256: but, that seems to be too much work. I could just use MVar to set some flags. Isn't that easier?
18:27:59 <joe9> slack1256: have you used AsyncException?
18:28:19 <slack1256> only in a toy program
18:28:28 <slack1256> the installHandler works well though
18:28:43 <slack1256> you need to use the MVar to tell the threads that a signal has been sent
18:28:56 <slack1256> seems more useful that my original approach
18:29:02 * slack1256 learns new things everyday
18:29:53 <slack1256> you have to check everyone in a while in the threads if there are signals though, but you can do that once you have reached a safe point to deal with them
18:30:08 <joe9> slack1256: would you mind sharing the toy program with AsyncException?
18:30:31 <slack1256> I don't know if it is in this computer but I can re do it if you give some minutes
18:31:27 <bitemyapp> what's the sanest/most effective way to get a type like: Int64 -> Int48 -> Int16 -> Int128 ?
18:31:52 <bitemyapp> fully realizing the 48 is a bit silly (it's a mac address)
18:32:13 <bitemyapp> I'm looking at bytestring and binary but don't really want the bytestring intermediary if I can help it.
18:32:20 <carter> ahh
18:33:01 <bitemyapp> carter: suggestions? :)
18:33:05 <carter> bitemyapp: so
18:33:25 <carter> from a semantical or "clever bit banging"
18:33:26 <carter> approahc?
18:33:33 <bitemyapp> if I can pack the Int48 and Int16 into a Word64 I'll be good.
18:33:42 <bitemyapp> because Int128 is Int64 and Word64
18:33:50 <bitemyapp> carter: I want fast/correct.
18:34:01 <bitemyapp> carter: I'm trying to beat the original service at their own game.
18:34:24 <carter> ok
18:34:29 <lispy> bitemyapp: oh, there is a package that does this using Integer
18:34:29 <carter> bitemyapp: assuming 64bit machine
18:34:39 * lispy tries to remember what it's called
18:34:41 <joe9> slack1256: that's ok. I am going to use MVar.
18:34:43 <carter> lispy: theres one that uses Int/Word undernera
18:34:44 <bitemyapp> carter: yes assuming 64bit machine but we're declaring the sizes.
18:35:08 <carter> bitemyapp: ooo
18:35:12 <carter> you want Word* not Int*
18:35:14 <carter> right?
18:35:55 <bitemyapp> carter: well, so, I had planned to represent my unique Ids as Int128's that I convert to bytestring's for transport.
18:36:07 <carter> why not Word128?
18:36:07 <slack1256> joe9: yep use that
18:36:10 <bitemyapp> carter: DoubleWord represents Int128 as { Int64, Word64 }
18:36:34 <bitemyapp> carter: I mean, I could, but I still have an Int64, an Int16, and a Mac address.
18:36:34 <lispy> bitemyapp: ah, here is the one I was thinking of: https://hackage.haskell.org/package/bv-0.2.2/docs/Data-BitVector.html
18:36:42 <bitemyapp> carter: so I have to efficiently combine them into the representation I want.
18:36:49 <carter> why are the first two Ints?
18:36:59 <bitemyapp> I then go from this Int128 into base62 in some cases.
18:37:00 <carter> https://hackage.haskell.org/package/largeword
18:37:11 <bitemyapp> Int64 is epoch milliseconds
18:37:13 <bitemyapp> Int16 is sequence
18:37:19 <bitemyapp> (incremented sequencing)
18:37:24 <carter> hrm
18:37:28 <bitemyapp> 48-bits are mac address, 6 word8
18:37:32 <bitemyapp> 6 word8's IIRC
18:37:37 <bitemyapp> so, in full
18:37:37 <lispy> bitemyapp: anyway, what if you just use bit shifting for your specific case?
18:37:41 <lispy> seems straightforward
18:37:45 <bitemyapp> Int64, 6 * Word8, Int16
18:37:52 <bitemyapp> lispy: uh sure, but how?
18:38:06 <bitemyapp> I don't know if there's a particular library people use for that or not.
18:38:08 <carter> bitemyapp: cast to larger size
18:38:08 <merijn> Data.Bits?
18:38:10 <carter> then shift tem
18:38:17 <lpaste> slack1256 pasted “UserInterrup C-c” at http://lpaste.net/109910
18:38:18 <carter> merijn:++
18:38:26 <sbrg> remember the size casting, yes. otherwise it just overflows and truncates
18:38:29 <slack1256> joe9: there is the paste
18:38:30 <stalintrotsky> @pl (\x y z -> g . f x y z)
18:38:31 <lambdabot> (((g .) .) .) . f
18:38:31 <bitemyapp> okay, I'll use that, thanks. I didn't know if it was recommended or not.
18:38:39 <slack1256> is not that much difficult that dealing with normal exceptions
18:38:40 <merijn> bitemyapp: Seems like the only sane way to me
18:38:53 <lispy> bitemyapp: I don't see an Int128 but you could either make one or use Integer instead
18:39:04 <bitemyapp> lispy: Int128 is in DoubleWord
18:39:05 <carter> Integer will be pretty effiient
18:39:15 <lispy> ah, well there you go :)
18:39:15 <bitemyapp> carter: I kinda wanted the size declared.
18:39:18 <carter> yes
18:39:20 <slack1256> I don't know if UserInterrupt also gives a exception for when SIGSTOP is sent though
18:39:22 <carter> Newtype your Integer
18:39:27 <bitemyapp>  :\
18:39:30 <carter> bitemyapp: no
18:39:32 <bitemyapp> I'll think about it.
18:39:33 <carter> its effience
18:39:37 <carter> *effiicient
18:39:43 <bitemyapp> it's not really about efficiency in this case
18:39:45 <bitemyapp> I'll think about it.
18:39:53 <bitemyapp> carter: thank you
18:39:54 <sbrg> bitemyapp: if you store the 6 * Word8 as a list you can fold them into a Word64 where you only set 48 bits and then add the last 16
18:39:55 <bitemyapp> merijn: thank you
18:39:56 <carter> its also already written :)
18:39:56 <bitemyapp> lispy: thank you.
18:40:13 <merijn> slack1256: It won't, SIGSTOP is unhandleable
18:40:16 <carter> all thats left is the moding to get all the normal instances
18:40:20 <bitemyapp> sbrg: in that case, I'd turn Int16 -> Word16 then add it?
18:40:23 * hackagebot curl-aeson 0.0.4 - Communicate with HTTP service using JSON  http://hackage.haskell.org/package/curl-aeson-0.0.4 (JoelLehtonen)
18:40:25 * hackagebot peyotls 0.1.4.5 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.5 (YoshikuniJujo)
18:40:33 <carter> bitemyapp: embiggen them all to the max size
18:40:34 <merijn> slack1256: SIGSTOP and SIGKILL cannot have handlers installed, therefore haskell can't throw an async exception for them
18:40:37 <lispy> bitemyapp: and if you use bv I think it already has the logic and instances that you'd want. Not sure though.
18:40:38 <carter> shift em to the right possition
18:40:47 <carter> then you OR them
18:40:48 <lispy> bitemyapp: at any rate, you're welcome and good luck
18:40:48 <carter> well
18:40:50 <sbrg> bitemyapp: well, not add as in addition, unless you're left with the least significant 16 bits untouched
18:40:51 <carter> at least for Words*
18:40:55 <sgronblo> http://stackoverflow.com/questions/25467832/how-to-get-source-code-for-all-build-depends-using-cabal fishing for answers on SO as well
18:41:05 <bitemyapp> sbrg: yes, append
18:41:08 <bitemyapp> not "addition"
18:41:22 <merijn> slack1256: Or rather, it depends on whether you mean SIGSTOP or SIGSTP
18:41:23 <sbrg> addition works if it's the least significant, otherwise you need or
18:41:28 <sbrg> but yeah
18:41:32 <merijn> eh, SIGTSTP
18:41:46 <slack1256> merijn: the handler that can be installed are thrown as an exception UserInterrupt of type AsyncError?
18:41:48 <merijn> slack1256: The former is uncatchable, the latter you can just install a handler for like all signals
18:42:10 <slack1256> Right, I keep confusing signals
18:42:17 <merijn> slack1256: It appears the default handler just throws an async exception, but if you wanna be sure, install your own signal handlers
18:42:28 <David> int-e or other lambdabot gurus here: is there a way to have lambdabot connected to a passworded server (e.g. znc)?
18:42:49 <slack1256> and do as joe0 said, let the main thread installHandlers and tell the thread through mvars when received.
18:42:50 <David> I'm poking around in the source and don't see anything obvious, but I was wondering if there was some extension or trick to do it
18:43:26 <merijn> slack1256: That, or have the handler throw an async exception to the thread of your choice
18:44:14 <slack1256> !!!
18:44:21 <slack1256> I had forgotten about throwTo
18:44:39 <slack1256> Well, if joe9 comes back I will tell him about it.
18:46:53 <Kintin> Hey, I'm trying to get the SDL package to build, and am running into compile errors. Git repo: https://github.com/kevinm416/ehm, build error: http://lpaste.net/109911. Could anyone take a look?
18:47:13 <lispy> taking a look but no promises :)
18:47:26 <sbrg> @hoogle typeOf
18:47:27 <lispy> ah
18:47:29 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
18:47:29 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
18:47:29 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
18:47:40 <lispy> Kintin: it looks like that package doesn't match your ghc version.
18:47:47 <lispy> Kintin: what version of ghc is it?
18:48:13 <David> actually, forget what I said. I'll just set znc to reject connections coming from anything other than 127.0.0.1
18:48:14 <Kintin> lispy: 7.8.3, latest haskell platform
18:48:25 <David> that should keep everything but lambdabot out
18:48:47 <lispy> Kintin: maybe try sdl2?
18:49:31 <Kintin> lispy: how can you tell which ghc version the library supports?
18:49:53 <lispy> Kintin: in this case the library authors should have figured that out
18:50:10 <lispy> Upload dateThu Jul 11 12:20:09 UTC 2013
18:50:20 <lispy> That package was created before the current ghc
18:50:44 <lispy> Kintin: I'd try this one instead: https://hackage.haskell.org/package/sdl2-1.0.0
18:51:03 <Kintin> great, I'll give that one a shot
18:51:18 <lispy> Kintin: if you're open to using GLFW instead of SDL, I have these example programs: https://github.com/dagit/nehe-tuts
18:51:40 <lispy> They go with the 'Legacy Tutorials' from this website: http://nehe.gamedev.net/
18:51:46 <merijn> hmmm, I wonder if it'd make sense to add this to Control.Exception: http://lpaste.net/109912
18:53:14 <lispy> merijn: seems potentially useful. Can you make it so that it takes a list?
18:53:26 <lispy> everything except X, Y, and Z
18:54:17 <lispy> Kintin: GLFW doesn't do as much as SDL, but it's also easier to install and get going with. In particular, the Haskell package bundles the source so you just 'cabal install' and you don't have to worry about installing libGLFW or anything like that.
18:54:38 <lispy> Kintin: so depending on what your goals are it might be easier.
18:54:38 <merijn> lispy: That seems tricky
18:55:06 <lispy> Kintin: these examples might also interest you https://github.com/dagit/1GAM/tree/master/pong
18:55:11 <Kintin> lispy: I'm just trying to get something working, so I can try making some 2d games with haskell
18:55:13 <merijn> lispy: There's no way to iterate over a type level list at the value level, it'd require a GADT rather than newtype and some other ugliness
18:55:38 <merijn> Kintin: Have you looked into #haskell-game ?
18:55:39 <Kintin> so something that's easier to set up is definitely better
18:56:09 <lispy> Kintin: the biggest omissions to glfw (compared to sdl) is lack of sound/music and fonts.
18:58:56 <lispy> I have a binding to freetype to help with the font issue (but it's super lowlevel)
18:59:05 <lispy> I'm not sure what to do about the audio stuff
19:00:14 <kristof> Does order of substitution matter in the lambda calculus?
19:00:44 <David> aach, forget what I said about znc. I still need to find a way to get lambdabot to do /quote PASS user:pass
19:01:41 <lispy> kristof: for beta reduction?
19:02:51 <lispy> kristof: http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem
19:02:58 <Kintin> lispy: could you point me to the thing you were talking about for diplaying text in glfw?
19:03:56 <kristof> lispy: If only I knew theory
19:04:48 <lispy> kristof: basically, in the simply typed lambda calculus, the order of reduction does not matter (we say it's strongly normalizing)
19:04:58 <lispy> Kintin: Someone sent me this code once: https://github.com/blitzcode/haskell-gol/blob/master/parallel-glfwb/src/Font.hs
19:05:10 <lispy> Kintin: I've never tried it but they said it can be used standalone
19:05:23 <taktoa> stlc isn't even turing complete
19:05:30 <taktoa> why do people talk about it so much
19:05:41 <kristof> lispy: No, I understood what the Church Rosser theorem concludes. I just meant that if I had known of it beforehand, I wouldn't have had to ask such a silly question
19:06:01 <kristof> Anyway, this means that there's no good reason for Haskell to not have named arguments :P
19:06:18 <merijn> taktoa: Who cares about Turing completeness?
19:06:43 <kristof> the x86 mov instruction, by itself, is turing complete
19:06:45 <merijn> I'm much more interested in how flexible we can make total languages than I am in Turing completeness
19:06:46 <taktoa> most people, with regard to the computational model of a programming language
19:07:05 <merijn> I don't think so, most people don't need Turing completeness at all
19:07:34 <merijn> It's a mere intellectual curiosity, what people want is "sufficiently expressive languages", but there's no indication that Turing completeness is necessary for that
19:07:56 <merijn> People only claim to want Turing completeness because the non-Turing complete languages they know are toys
19:08:19 <kristof> Really? I think most people who know of any non-Turing complete language think first to Agda
19:08:56 <merijn> kristof: Really? I think there's far more who think of STLC
19:09:06 <merijn> i.e. anyone who got a basic theoretical CS course
19:09:21 <merijn> And STLC is fairly useless compared to Agda
19:09:42 <kristof> merijn: That's not me. :)
19:12:33 <jmcarthur> i think people just don't realize how useless most of the space of turing complete programs is
19:12:36 <David> hmm. There's an irc-password command, but I can't execute it...
19:12:40 <David> lambdabot> irc-password
19:12:40 <David> Unknown command, try @list
19:12:52 <David> is there something I'm missing here?
19:13:18 <lispy> Kintin: Hmm...I guess the other examples are 404s now. The freetype stuff is really in need of polish. If you're good at low level Haskell stuff I can show it to you but there is a lot of ForeinPtr stuff and you'll have to look at eaxmples code written in C to figure out how to use it. If you can use that Font.hs module above for now that's probably easier.
19:13:23 <int-e> David: I think you need the git version of lambdabot for that
19:13:55 <Kintin> lispy: Thank you! glfw is working for me. It's the only opengl/sdl/game-making haskell package that I could get to work, and had working examples.
19:14:05 <lispy> yay!
19:14:10 <David> oh, wrong version. thanks
19:14:28 * lispy worked pretty hard (with others) to make sure glfw-b 'just works'
19:14:47 <merijn> Kintin: Like I mentioned before, #haskell-game is fairly active and the people there should have more experience with these libraries :)
19:15:35 * lispy really should finish his high level wrapper for freetype
19:15:46 <carter> lispy: 7.8 makes a lot of lib support for OSX much nicer :)
19:15:52 <carter> is a biggy in my book
19:16:28 <lispy> cool
19:16:46 <lispy> ghc has been monotonically increasing in goodness for as long as I've been haskelling
19:16:55 <carter> yeah
19:16:57 <merijn> lispy: :)
19:17:04 <carter> eg, i gigle when people complain about "cabal hell"
19:17:27 <Iceland_jack> carter: It's more of a purgatory now
19:17:31 <carter> heh
19:17:31 <Kintin> merijn: cool, I'll head over to haskell-game if I run into issues.
19:17:39 <merijn> "cabal hell" usually seems to mean "I have unrealistic expectations about what I can install and like to blame cabal"
19:17:48 <carter> Iceland_jack: how pricey is grabbing a lunch or whatever in gothenburg?
19:18:07 <merijn> I've seen people use the term "cabal hell" to refer to something not installing with conflicting dependencies, which is so far from the origin of the term it's not even funny
19:18:10 <carter> merijn: Iceland_jack  i remember when i had to by hand all of teh libs I wanted to use in the same cabal install declaration
19:18:22 <carter> to make sure one install didn't rebuild the deps of another lib
19:18:36 <carter> because the rebuild would change the package hash
19:18:42 <Iceland_jack> Somewhere around 45-85 SEK
19:18:53 <merijn> I'm fairly convinced only like 1 in 50 uses of "cabal hell" have anything to do with cabal, rather than the ecosystem
19:19:04 <geekosaur> or with ghc
19:19:27 <geekosaur> given that cabal is tasked with managing a rather difficult to manage situation with how ghc deals with libraries
19:19:36 <carter> Iceland_jack:, thats much nicer than what the US GOV per diem rates indicated
19:20:33 <Iceland_jack> If you're eating somewhat fancy you may go to 100-150
19:20:46 <carter> 100-150 sek or dollars?
19:20:48 <Iceland_jack> SEK
19:20:55 <carter> so < 20 dollars?
19:20:58 <newbie227> What about Yen?
19:21:07 <Iceland_jack> newbie227: Only ISK or SEK :)
19:21:10 <carter> newbie227: sweden don't care about your yen for yen
19:21:12 <merijn> newbie227: Pretty sure they don't accept Yen in Sweden :p
19:21:59 <merijn> carter: Stuff is expensive, but not THAT expensive. Except for alcohol, which is insanely expensive :p
19:22:13 <carter> Iceland_jack: the per diem cost of food i found online on DOD / US Dept fo State was  as "139 dollars a day"
19:22:21 <Iceland_jack> Yes, you need to get drunk before you're ready to pay for more
19:22:23 <lispy> carter: the audio/music problem is really an issue of what library or API should we use? AFAIK there isn't really a good platform abstrating library. OpenAL is deprecated for example.
19:22:30 <merijn> Driving to Sweden from Germany/NL with a few crates of beer == great way to make friends :)
19:22:31 <carter> lispy:?
19:22:46 <lispy> carter: responding to your comment that using libraries on osx is eaiser now
19:22:55 <Iceland_jack> merijn: I see you've met my friend :)
19:23:09 <lispy> perhas a nonsequitor but I thought that's what you were getting at
19:23:13 <carter> how much for a pint of beer?
19:23:15 <carter> lispy: ah
19:23:16 <carter> no clue
19:23:17 <carter>  :)
19:23:18 <merijn> Iceland_jack: My brother's GF did her master project in Sweden ;)
19:23:25 <Iceland_jack> ah I see
19:23:51 <merijn> Iceland_jack: And no import tax for private use :D
19:24:07 <lispy> the right solution may well be writing a platform abstracting API in Haskell now that we can interface with the native audio support
19:24:09 <Iceland_jack> carter: A pint is something like 50-80 SEK
19:24:16 <lispy> Then you still need a way to deal with codects
19:24:20 <carter> so 8-12 dollars
19:24:31 <Iceland_jack> don't quote me on the beer though since I'm not much for it
19:24:40 <carter> Iceland_jack: i don't drink much
19:24:44 <carter> :)
19:24:49 <lispy> Kintin: oh, BTW if you need to deal with images use JuicyPixels
19:24:53 <carter> more of a caffeine fiend
19:24:58 <merijn> carter: That sounds about right, although I wouldn't be surprised by even higher
19:25:09 <carter> merijn: i'm used to NYC prices
19:25:13 <carter> sooo this doesn't sound too bonkers
19:25:19 <lispy> Kintin: 100% haskell image library. It's pretty awesome. I have some examples that use it and I think the docs have examples?
19:25:27 <carter> lispy: i think someting like fsnotify is a good example
19:25:29 <merijn> carter: Why do people wanna live in NYC again? :p
19:25:37 <carter> merijn: good public transit
19:25:44 <carter> and fewere dudes than SF?
19:25:48 <carter> idk
19:25:54 <lispy> dudebros
19:26:19 <carter> lispy: "our company is so cool, we use mongo and js to cure cancer"
19:26:25 <carter> or something
19:26:36 <lispy> and hold interviews in the "breakup room"
19:26:41 <merijn> carter: Ugh, I've run into 4 "we're doing a startup" people already :)
19:26:48 <carter> merijn: i'm doing a startup
19:26:56 <carter> don't recommend it
19:26:58 <carter> ever
19:27:07 <carter> "how much can you pay me in money"
19:27:25 <carter> and then cap your work to 40ish hours  a week and get a not ocmputer hobby to socialize aorund
19:27:27 <carter> is what i should do
19:27:43 <merijn> carter: Yeah, but at least you don't make something vapid like half of the bay appears to be :p
19:27:47 <dolio> Are we out of Haskell stuff to talk about?
19:27:56 <merijn> dolio: Yes!
19:28:09 <lispy> dolio++
19:28:23 <newbie227> carter: ?
19:28:29 <carter> merijn: so when is oracle gonna pay you to write a GHC JIT
19:29:10 <merijn> carter: Never? They're not even paying me to do haskell, sadly :(
19:29:13 <merijn> They totally should
19:29:19 <merijn> This stuff would be much easier!
19:29:24 <carter> merijn: demo them a better jvm jit
19:29:26 <carter> using haskell
19:29:32 <carter> C++ for a vm sounds stressful
19:29:46 <merijn> carter: Actually, have you seen the Graal/Truffle stuff from Oracle Labs? It's pretty freaking cool
19:29:58 <carter> probably not seen it because jvm
19:30:13 <merijn> carter: It runs on a stripped down hotspot
19:30:17 <carter> @google graal truffle
19:30:18 <lambdabot> https://wiki.openjdk.java.net/display/Graal/Truffle+FAQ+and+Guidelines
19:30:30 <lispy> Actually, wasn't there a reddit post about using Haskell to write the GHC rts?
19:30:40 <lispy> I didn't understand how that's even possible
19:30:46 <merijn> carter: Check out the talks at PLDI/ ARRAY2014 this year
19:30:54 <lispy> I could see using something like rust, but not Haskell
19:31:01 <dolio> You could embed a DSL.
19:31:04 <carter> yeah
19:31:06 <carter> an RHaskell
19:31:08 <merijn> carter: I can help you get the papers if you're paywalled
19:31:28 <lispy> dolio: so the rts would be generated from code written in the DSL?
19:31:37 <carter> http://www.sable.mcgill.ca/array/
19:31:37 <dolio> Yeah. Why not?
19:32:00 <lispy> That could work just fine. It's not what I thought they meant :)
19:32:02 <dolio> It's a lot of work, of course.
19:32:06 <merijn> carter: They have have a naive JS interpreter that gets results competitive with V8, a Ruby implementation that blows Ruby out of the watter and an APL/J thingy that does data parallelism
19:32:13 <lispy> Yeah, they should use ivory
19:32:20 <carter> merijn: http://www.sable.mcgill.ca/array/ ?
19:32:25 <merijn> carter: Yeah
19:32:27 <lispy> https://github.com/GaloisInc/ivory
19:32:57 <carter> merijn: aside from a paper that seems to have your name on it, nothing is notworthy
19:33:22 <dolio> You could maybe restrict yourself to a subset of Haskell that didn't need a garbage collector, but that'd be difficult.
19:33:32 <carter> dolio: Clean
19:33:33 <carter> :)
19:34:10 <dolio> Like, you wouldn't be using a regular Haskell compiler at that stage.
19:34:49 <lispy> I think it would be an interesting project for someone to rewrite the GHC rts in rust. I don't know if the performance would be any good or how much it would complicate the build, but I'd love to see how much the features of rust help or hinder the effort.
19:35:13 <carter> lispy: i know Ezyang mucked with doing a fragment a few months ago
19:35:24 <bjz> what is the rts currently written in?
19:35:27 <lispy> ah cool
19:35:32 <lispy> bjz: C
19:35:37 <lispy> C 99, IIRC
19:35:48 <merijn> No
19:35:54 <bjz> I don't see why the performance would be that different
19:35:55 <lispy> It's pretty clean code
19:35:57 <merijn> It's mix of haskell and Cmm
19:36:02 <bjz> ahh
19:36:10 <bjz> merijn: yeah that's what I thought
19:36:12 <merijn> Cmm being a GHC specific dialect of C--
19:36:19 <bjz> yep
19:36:19 <carter> the GC is still C
19:36:22 <carter> as is the scheduler
19:36:33 <lispy> There's like 50kLOC of C code, I thought
19:36:35 <carter> primops and some of the evaluation machinery are CMM
19:36:41 <bjz> carter: o/
19:38:15 <carter> lemmehttp://cloc.sourceforge.net v 1.60  T=63.46 s (137.1 files/s, 19633.8 lines/s)
19:38:15 <carter> --------------------------------------------------------------------------------
19:38:15 <carter> Language                      files          blank        comment           code
19:38:17 <carter> --------------------------------------------------------------------------------
19:38:18 <carter> Haskell                        7431         155586         196536         576804
19:38:19 <carter> C                               263          10812          13026          58021
19:38:20 <carter> Bourne Shell                     62          10535          15865          50560
19:38:34 <carter> this probably is off by a factor of 2x
19:38:37 <carter> because this isn't a clean tree
19:38:59 <carter> and the stag1 and 2 builds + all the libs throw things offf
19:39:07 <carter> "
19:39:07 <carter> Fortran 77                        6            662           1049           3527"
19:39:12 <carter> i know we dont got no fortran in that tree
19:41:39 <kuanyingchou> exit
19:41:56 <carter> bjz: how'd your internship go?
19:42:01 <lispy> carter: please use a pastbin next time
19:42:05 <dolio> 576,000 lines of Haskell is pretty crazy.
19:42:12 <carter> yeah, that stat is wrong
19:42:18 <carter> lispy: i'm usually better about that, long day
19:43:15 <dolio> compiler only has like 283,000 lines total.
19:43:19 <carter> yeah
19:43:25 <carter> i think its double counting somehow
19:43:30 <carter> was uing the CLOC tool
19:43:32 <carter> @google CLOC
19:43:33 <lambdabot> http://cloc.sourceforge.net/
19:43:33 <lambdabot> Title: CLOC -- Count Lines of Code
19:43:55 <dolio> It's 1,000,000 if you include all haskell files in the tree, including libraries.
19:44:20 <carter> really?
19:44:23 <carter> lemme double check
19:44:35 <dolio> I'm just doing cat | wc -l
19:44:40 <dolio> Nothing intelligent.
19:44:44 <carter> oh
19:44:48 <carter> i'm just using cloc
19:45:11 <merijn> ok, in the interest of actuall haskell discussion: API design question!
19:45:16 <carter> merijn: BRING IT ON
19:45:49 <merijn> So I have an enum of different authentication modes, and a datatype that has an authentication mode and needs additional parameters based on the mode
19:45:57 <carter> GADT?
19:46:03 <carter> or not GAD
19:46:04 <carter> T
19:46:12 <merijn> Adding the additional data to the authentication mode doesn't really work well, because then I can't really use it as an enum elsewhere
19:46:34 <carter> so you could have the params type be a gadt on the modes?
19:46:47 <carter> *indexed by
19:46:48 <merijn> But having the data seperate from the AuthMode makes guaranteeing the correctness hard
19:46:49 <carter> hrm
19:47:23 <merijn> carter: Right not it's a normal record type, making it a GADT indexed by the AuthMode would lead to a lot of duplication
19:47:40 <carter> data Params (a :: AuthMode) :: * where     modeFoo :: T1 -> T2 -> Params Foo
19:47:40 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
19:47:40 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
19:47:44 <carter> hah
19:47:56 <merijn> I'm thinking the simplest way it to have a second AuthMode data type that does have the different arguments I need
19:48:10 <merijn> But having two identical enums, one with data and one without feels dirty
19:48:12 <carter> merijn: yeah
19:48:19 <carter> you coudl type them together with indexing tricks mebe
19:48:19 <carter> idk
19:48:30 <carter> merijn: write all 3 different appraoches and pick the nicest
19:48:42 <merijn> carter: Getting sugegstions for tricks was exactly why I asked! :p
19:48:52 <carter> GADT it
19:48:53 <carter> :)
19:49:11 <merijn> carter: But "dat awful record field duplication" :(
19:49:17 <carter> well
19:49:19 <carter> factor it better
19:49:21 <platz> obviously there is a relationship between church encoding and codensity, but the types seem a bit different
19:49:28 <merijn> Oh
19:49:29 <merijn> Wait
19:49:40 <carter> ?
19:49:45 <platz> can't see it yet, hopefully soon though
19:49:55 <merijn> Now I get what you meant with "data Params (a :: AuthMode)", I was thinking the wrong way around
19:49:59 <lispy> platz: that sounds like something dolio or shachaf would know about
19:50:09 <merijn> Although I'm afraid that'd force all my users to DataKinds everything?
19:50:26 <carter> merijn: what ghc range do you wanna support?
19:50:30 <merijn> Is it possible to use DataKinds values without enabling it everywhere?
19:50:52 <merijn> carter: I only care about GHC 7.8+, but I feel it's a hassle to make users enable extensions in every single module
19:50:53 <carter> merijn: you could have each authmode be a different ype
19:51:21 <carter> and either a GADT or DataFam for the params info
19:51:25 <merijn> carter: But then I can't really have an "authmode" field in my configuration?
19:51:38 <carter> proxy :: Proxy Mode
19:51:49 <carter> merijn: first get it working
19:51:53 <carter> then figure out how to make it pretty
19:52:13 <carter> hrmm
19:52:15 <merijn> carter: "get it working" == "just have two fields that can get inconsistent and give me a headache"
19:52:15 <carter> wait
19:52:20 <carter> no
19:52:25 <carter> merijn: look at my hblas stuff
19:52:33 <carter> theres a commit by Stephen Diehl that works around that issue
19:52:47 <merijn> Actually, I think I'm first gonna test whether importing DataKinds GADTs requires users to use GADTs
19:52:56 <carter> https://github.com/wellposed/hblas/commit/d23418ac5d1d4b163bb0c5e472abcefddbca73ff
19:53:01 <carter> merijn: bam
19:53:26 <carter> https://github.com/wellposed/hblas#usage
19:53:49 <carter> you just type synonym the indexed version
19:53:54 <carter> and export the synonms
19:54:26 <merijn> carter: Hah "I have > 32bit size arrays, help!"
19:54:31 <merijn> "Congrats, you have ``big compute on big data''"
19:54:38 <simpleAJ> Hi, I am following http://learnyouahaskell.com/starting-out#im-a-list-comprehension ..however I am not able to understand why "length' xs = sum [1 | _ <- xs]   " is not working here.. It says input = error? any idea why?
19:55:00 <merijn> carter: The new favourite joke around here is that most of our "big data" clients have "medium data" at best :)
19:55:25 <dmj`> simpleAJ: can you paste code?
19:55:28 <carter> merijn: it broke excel, it must be big!
19:55:28 <merijn> simpleAJ: Is this in ghci?
19:55:34 <carter> merijn: do you see the type synonym trick?
19:55:37 <simpleAJ> yes
19:55:42 <merijn> carter: Yeah, that could work :)
19:55:53 <carter> merijn: thank stephen for that
19:55:54 <simpleAJ> http://lpaste.net/109913
19:55:55 <merijn> simpleAJ: ghci only accepts a subset of haskell syntax
19:56:00 <carter> didn' teven understand that initially
19:56:10 <merijn> simpleAJ: You can't write function definitions like that in ghci
19:56:17 <simpleAJ> oh didn't know that. well then will try in a file
19:56:30 <simpleAJ> yeah my bad. thanks for the clarification
19:56:35 <merijn> simpleAJ: You need to write "let length' xs = sum [1 | _ <- xs]", then it should work
19:56:39 <carter> dolio: lispy  http://lpaste.net/109914
19:56:45 <carter> is the statcs using CLOC on a fresh clone
19:56:55 <carter> including libs and test suite
19:56:59 <simpleAJ> ok great..i am just playing around..so that should help me
19:57:03 <simpleAJ> thanks
19:57:16 <merijn> simpleAJ: In general I would recommend just having a terminal and editor open and occasionally using ":r" in ghci to reload the file
19:57:40 <simpleAJ> ok will do
19:57:57 <merijn> simpleAJ: That way you can just write "proper" haskell and still play around with it (for example, ghci is also a bit weird about multiline definitions, etc)
19:58:15 <carter> http://lpaste.net/109917 dolio  lispy  thats with a deleted test suite and libraries folder
19:58:17 <simpleAJ> yeah ,makes sense
19:58:32 <carter> don't know why it thinks thres objective c
19:58:46 <michaelt> and lisp and matlab?
19:58:53 <merijn> carter: It seems silly that the type synonym makes GHC suddenly perfectly happy with using DataKinds in a non-DataKinds file, but if it works, who cares? :D
19:59:45 <merijn> carter: Do you know if that also works for TypeFamilies?
20:00:16 <merijn> Or ConstraintKinds? :D Because if so you just made my life so much better :D
20:01:25 <carter> merijn:  i don' tthink type familes needs to be enabled at the use site, just the definition site
20:01:29 <carter> constraint kinds, idk
20:01:34 <carter> merijn: that ones easy to test
20:01:39 <carter> go take 5 min and report back :)
20:01:42 <merijn> To the test mobile! *batman sound*
20:02:04 <carter> merijn: i wanna update my criteiron benchmarking template to 1.0 criteiron
20:02:07 <carter> but it means i have to JS
20:02:30 <carter> otoh,
20:02:39 <carter> @google effective javascript by david herman
20:02:42 <lambdabot> http://www.amazon.com/Effective-JavaScript-Specific-Software-Development/dp/0321812182
20:02:42 <lambdabot> Title: Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript (Ef...
20:02:55 <carter> does a pretty good job of documenting ALL the JS quirks
20:03:04 <carter> does make me scared to write large applications in js though
20:03:14 <David> int-e: how do you compile lambdabot-trusted?
20:03:30 <David> All the directories in your repo have Setup.hs
20:03:38 <Welkin> js needs a harness
20:03:39 <David> except for lambdabot-trusted
20:04:13 <David> can I reuse the Setup.hs from one of the other directories
20:04:19 <David> or do I need to install something else?
20:05:13 <solatis> other than `cabal test`, is there something better to run my test suites in? cabal seems to be incredibly annoying when you actually want to read / debug the test output, since it buffers *everything* before outputting the log
20:05:51 <platz> I'm starting to believe the best way to learn about haskell is to just search for terms on ircbrowse
20:06:39 <platz> 'best' may be a bit strong
20:06:41 <carter> solatis: theres a few test suite libs
20:07:22 <solatis> carter: yeah i've seen HSpec and such
20:07:50 <solatis> but they all seem to focus on unit testing
20:08:04 <solatis> i have more high-level integration tests
20:08:19 <solatis> (i'm not a fan of unit testing myself)
20:09:04 <platz> maybe there needs to be some kind of NLP/MachineLearning thing for irc logs
20:09:30 <merijn> carter: Aww :(
20:09:35 <carter> merijn:?
20:09:40 <merijn> carter: Looks like ConstraintKinds still needs it enabled
20:09:54 <merijn> But TypeFamilies are fine without anything and DataKinds with type synonym works :D
20:10:12 <carter> merijn: that sounds wrong
20:10:13 <carter> well
20:10:22 <merijn> It seems unlikely a user would manually write down my ConstraintKinds type anywhere anyway
20:10:27 <carter> merijn: vector uses DataFamilies
20:10:38 <carter> i dont' think you need data families on to use the constructor
20:10:39 <carter> s
20:10:40 <carter> or types
20:10:44 <carter> or maybei'm not undestanding
20:11:04 <merijn> carter: No, that bit works
20:11:13 <merijn> carter: I'm just said ConstraintKinds doesn't
20:11:15 <merijn> *sad
20:11:38 <merijn> This is still the best thing I've learned about in like months...
20:15:55 <carter> merijn: did i ever show my unrolling typeclasses?
20:16:00 <carter> i probab did
20:16:12 <merijn> carter: nope
20:16:36 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Shape.hs#L238-L244
20:16:45 <carter> i've a static sized list
20:16:53 <carter> and induction on the size vs type classes
20:16:57 <carter> === not recursive recursion
20:16:57 <carter> :)
20:18:43 <solatis> hmm
20:18:58 <solatis> am I correct that Control.Concurrent.MVar is actually simply a Barrier?
20:19:07 <carter> eh?
20:19:10 <carter> in what sense?
20:19:14 <solatis> https://en.wikipedia.org/wiki/Barrier_(computer_science)
20:19:17 <solatis> that sense
20:19:18 <carter> MVar == "Mutex Variable"
20:19:40 <carter> ahh
20:19:50 <carter> its not a CPU level atomic thing
20:19:55 <carter> but it does have atomic semantics
20:19:59 <merijn> carter: Mutable Variable, actually
20:20:06 <carter> merijn: are you sure
20:20:06 <merijn> Traditionally speaking, afaik
20:20:13 <merijn> Not one 100%
20:20:18 <carter> merijn: nah, 'cause sempahor is built using mvar
20:20:18 <Axman6> it is a synchronisation primitive, and can be used as a barrier if you want
20:20:33 <Axman6> MVar () is essentially the same thing I guess
20:20:38 <carter> either way, MVars are awesome
20:20:44 <merijn> carter: Well, they're mutex variables in haskell, sure
20:20:45 <solatis> they are very flexible yes
20:20:58 <solatis> "mutex variable" doesn't make sense
20:20:59 <Axman6> MVars are very awesome
20:21:15 <carter> solatis: why not?
20:21:19 <MP2E> It doesn't? 'Mutual Exclusion Variable' makes sense to me
20:21:26 <MP2E> which is what mutex means AFAIK
20:21:33 <carter> MP2E++
20:21:38 <Axman6> and can be extremely fast (because they're tied into the RTS)
20:21:40 <solatis> i thought mutex meant "mutually exclusive"
20:21:46 <platz> Are they too flexible?  for example with promises you can only write once, MVars can be re-used
20:21:47 <merijn> carter: No recursion on Nat, instead of your own nat-type? ;)
20:21:55 <carter> MP2E: well yeah, typlists are busted
20:22:00 <carter> merijn:
20:22:06 <merijn> carter: Although I guess that's because of the sucky solver?
20:22:10 <solatis> anyway, /bikeshed
20:22:11 <platz> I wonder if that encourages forkio and threads over things like monad-par
20:22:15 <merijn> platz: You can easily solve that with a newtype :)
20:22:27 <carter> platz: IVar  is  just a write once MVar
20:22:30 <platz> ahh
20:22:32 <carter> but promises are pretty weak
20:22:34 <solatis> platz: you can write a Promise on top of a MVar
20:22:41 <carter> they're neat for composing things
20:22:46 <platz> yeah but do people use that in haskell
20:22:49 <solatis> MVar is the primitive you can use for implementing a lot of things
20:22:58 <carter> but you can't build New abstractions with IVar
20:23:03 <carter> MVar is crazy general
20:23:13 * tabemann tends to like TVars himself
20:23:13 <merijn> platz: MVar's are really a building block for building things like Chan, etc.
20:23:19 <Axman6> carter: well, not necessarily. monad-par can have various schedulers
20:23:28 <carter> monad par uses MVar
20:23:39 <merijn> monad-par is for parallelism, forkIO and friends are for concurrency
20:23:43 <Axman6> the schedulers that currently exist use MVars
20:23:53 <solatis> merijn: people seem to be confusing those two a lot
20:23:54 <platz> yeah this is all true - but in the wild to folks actually build their abstractions ontop of MVar, or just use them direclty
20:23:58 <merijn> threads and mvars make sense during single threaded execution, monad-par not so much
20:24:02 <merijn> solatis: They always do :)
20:24:12 <solatis> paralellism /= concurrency
20:24:31 <solatis> well parallelism is a subset of concurrency
20:24:32 <merijn> platz: Because many people do concurrency and not parallelism and therefore monad-par makes little sense?
20:24:56 <merijn> solatis: parallelism is an implementation issue, concurrency a semantics issue
20:25:03 <platz> I'd agree concurrency is more valuable than parallelism yes
20:25:20 <Axman6> solatis: not always. SIMD is a form of parallelism which most woul;d not consider concurrent
20:25:22 <merijn> I don't think it's "more valuable", you just use them for different things
20:25:22 <carter> both are valuable
20:25:23 <solatis> merijn: correct. and MVar is at the level of concurrency, the same way for example a concept such as a 'semaphore' is
20:25:37 <carter> Axman6: simd aint paralle, more like "batch/pipelined"
20:25:48 <Axman6> it's definitely parallel
20:26:05 <solatis> Axman6: if you reason like that, nowadays every CPU is using paralellism
20:26:08 <merijn> Axman6: careful who you start arguing with :)
20:26:16 <Axman6> solatis: yes, they are
20:26:24 <solatis> CPUs using branch prediction etc and out-of-order execution
20:26:51 <Axman6> merijn: yeah I've done this before. it is a topic I have spent a considerable amount of my education learning about though :P
20:27:01 <carter> CPUS have ILP
20:27:07 <Axman6> SIMD is explicitly parallel though
20:27:09 <carter> but SIMD is more like batching
20:27:15 <carter> SIMD aint ILP
20:27:27 <solatis> it's actually amazing how few programmers realise CPU is not executing the instructions synchronously
20:27:27 <Axman6> super-scalar is implicit parallelism
20:27:47 <carter> eh, is it thought?
20:27:49 <carter> *though
20:28:00 <carter> its batch certainly
20:28:08 <carter> and in a metaphorical sense its parallel
20:28:13 <merijn> Right, back to hacking instead of discussions ;0
20:28:29 <carter> and in the circuit level definitely more than one electron at a time :)
20:28:47 <carter> i guess its paralle in the sense of a circuit being paralle
20:29:11 <tabemann> but this isn't the meaning of parallel we mean here
20:29:14 <Axman6> actually, perhaps super-scalar is better characterised as concurrency
20:29:25 <solatis> i
20:29:30 <kazagistar1> solatis: the fact that they don't realize it means that the abstraction (languages/compilers/hardware) is fairly effective for their uses
20:29:32 <Axman6> but SIMD sure is
20:29:33 <solatis> i'm talking about a higher level
20:29:48 <solatis> kazagistar1: for a lot of purposes yes
20:29:54 <tabemann> parallel here means running on multiple cores simultaneously
20:29:57 <solatis> kazagistar1: until you run into weird optimization issues
20:30:03 <pjdelport> carter: How do you mean SIMD is like batching? Isn't it the very definition of parallelism? (That is, one instruction applying to a vector of data in parallel.)
20:30:20 <carter> pjdelport: SIMD in the gpu sense in paralel
20:30:24 <Axman6> tabemann: nah, that's a terrible definition (because usually you're running distinct tasks concurrently)
20:30:45 <carter> not sure that having a really really wide adding / shuffle circuit counts as parallel in a software engineering sense
20:30:45 <Axman6> pjdelport: exactly
20:30:56 <merijn> carter: Aww, I just realised that even with the GADT/DataFamilies approach I still need to essentially duplicate the number of auth modes
20:30:56 <solatis> kazagistar1: https://stackoverflow.com/questions/8547778/why-is-one-loop-so-much-slower-than-two-loops
20:31:01 <solatis> just a simple example
20:31:18 <platz> i liked the parallelism=multiple-ops-in-a-moment and concurrency=multiple-ops-in-a-time-duration distinction
20:31:23 <solatis> putting multiple things in 1 loop is a LOT slower than doing small things but looping multiple times
20:31:25 <merijn> carter: Oh, actually, maybe not? Lemme try an evil hack
20:31:42 <Iceland_jack> platz: You really need some interaction in the concurrency definition
20:32:10 <Iceland_jack> Some specify determinism, others don't citing coroutines
20:32:58 <Axman6> concurrency: "two things are said to be concurrenct if from some observer, it cannot be said that one has has finished before the other has started". (which covers single core concurrency)
20:32:59 <kazagistar1> solarus: right, but people run into those with sufficient infrequency that their cost likely does not outweight the benefit of not having to reason about complexity that is abstracted away, that is my guess at least
20:33:26 <Axman6> parallelism is usually purely for increasing the performance of a computation
20:33:29 <carter> i wonder what simon marlow defines the words to mean for his book :)
20:33:36 <solatis> kazagistar1: i agree with that, i think it's actually pretty amazing how far we have come nowadays
20:34:31 <lpaste> merijn pasted “No title” at http://lpaste.net/109918
20:34:41 <merijn> carter: I think I'll just do that?
20:34:56 <merijn> carter: Then I don't have to define new constructors but still have type safety
20:35:08 <carter> merijn: but inference sucks
20:35:20 <solatis> hmmm
20:35:21 <carter> data familes woudl be beter
20:35:28 <solatis> totally different subject:
20:35:39 <solatis> haskell's laziness, how does it apply to sorting algorithms?
20:35:45 <merijn> carter: Also, am I alone in thinking that GHC should warn if I don't include a case for every possible value of AuthMode there?
20:36:02 <carter> merijn: dude, thats a closed type family
20:36:09 <carter> you're mising your tuff up
20:36:11 <carter> :)
20:36:17 <carter> you want a DATA family
20:36:18 <merijn> carter: Why?
20:36:20 <carter> if you're going that rought
20:36:40 <merijn> carter: DATA family means duplicating every constructor from my enum?
20:36:42 <carter> merijn: how do i figure out the mode from (ByteString, ByteString)
20:37:29 <Axman6> solatis: mergesort under haskell allows you to get k-select for free with O(n log k) runtime
20:37:32 <carter> idkd, youre code isn' tpublic soi don't know how many cosntructors you get
20:37:36 <kazagistar1> solarus: elegantly -> smallest = take 1 . mergesort -- O(1)
20:37:41 <kazagistar1> er
20:37:42 <merijn> carter: It's not userfacing, I just have a SocketConfig which needs to store "authentication parameters" and use them later
20:37:46 <kazagistar1> O(n)
20:37:48 <kazagistar1> derp
20:37:52 <solatis> Axman6: that's pretty awesome
20:37:58 <Axman6> sure is
20:38:08 <solatis> so it can work with infinite lists?
20:38:20 <michaelt> With data families, the instance would be ... where data AuthParams Plain = Plain ByteString ByteString, or something ?
20:38:23 <Axman6> so, head . sort gives you maximum in O(n)
20:38:28 <merijn> carter: So your not supposed to figure out the mode from (ByteString, ByteString), the code is supposed to figure out "ByteString, ByteString" from the mode
20:38:28 <carter> michaelt: yup
20:38:40 <carter> merijn: try i tout
20:38:44 <solatis> Axman6: great, that's what i was looking for
20:38:48 <Axman6> solatis: no, it's not possible to sort an infinite list without knowing anything about the contents
20:38:50 <merijn> carter, michaelt: But I already have an enum that defines Plain so that's a name collision
20:39:01 <carter> michaelt: then call it PlainCon
20:39:02 <michaelt> merijn: yeah, I figured
20:39:03 <carter> merijn:
20:39:05 <Axman6> you need to inspect all elements to produce the first element, for example
20:39:20 <solatis> Axman6: and if i put certain constraints on it, say, 0 <= i <= 9 ?
20:39:21 <carter> merijn: don't complain about lots and lots of construcros
20:39:34 <kazagistar1> solarus: you cannot use sort with an infinite list, because you can never find even a smallest value... you can find all permutations of an infinite list very elegantly though
20:39:34 <merijn> carter: I complain about repeating myself! :p
20:39:43 <michaelt> merijn: oh I guess it's obvious since Plain is a lifted constructor ...
20:39:45 <Axman6> solatis: then it's possible, but you might need to change the algorithm to take account of that
20:39:53 <solatis> Axman6: i understand, ok
20:40:22 <merijn> "Why can haskell just magically figure out what I want!" :)
20:40:22 <Axman6> like, if you know the minimum value that will ever be seen, you can emit the value as soon as you see one
20:41:39 <merijn> carter, michaelt: Wouldn't GADT be superior to data family? data family is extensible
20:41:43 <solatis> merijn: well the thing is, i'm actually amazed by the amount of things haskell is "magically" able to figure out
20:41:53 <solatis> so i try to understand the limits
20:41:55 <carter> merijn: sure, use the GADT i suggested 10 minutes ago
20:41:56 <carter> :)
20:42:53 <kazagistar1> solatis: if you have a list of all 1's so far, you cannot know that it will not have a 0 at some point further until you inspect the whole thing, which you can never do in an infinite list
20:43:09 <solatis> but the thing is, if i use the sorting agorithm described by Axman6, the sorting algorithm becomes 'lazy' and doesn't perform a full sort, only the parts i'm interested in
20:43:36 <Axman6> yep
20:43:37 <solatis> which is pretty amazing if you ask me :)
20:43:51 <Axman6> the rest is just a thunk that will produce more values when you need them
20:43:52 <kazagistar1> solatis: no, it still accesses the whole thing, but it does not *finish* sorting the parts you dont inspect
20:44:00 <solatis> kazagistar1: that's what i mean
20:44:07 <merijn> carter: But now I need to think up names and I suck at that :(
20:44:25 <solatis> it will have to have access to the full list, but it doesn't necessary need to sort the entire list -- just the parts i'm interested in
20:44:33 <Axman6> merijn: The three hardest problems in computer science: Naming things and off by one errors
20:44:33 <michaelt> carter: merijn this gadt from above? data Params (a :: AuthMode) :: * where     modeFoo :: T1 -> T2 -> Params Foo ?
20:44:33 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
20:44:34 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
20:44:46 <solatis> (so it will work properly when i only want the #1 result of a large, finite list)
20:44:55 <merijn> carter: I optimise for the minimal things to name ;)
20:45:00 <pjdelport> Axman6: The two hardest things are naming, cache invalidation, and off-by-one errors. :)
20:45:11 <solatis> pjdelport: ...
20:45:12 <Axman6> pjdelport: damn, that's the one =)
20:45:16 <Axman6> close enough!
20:45:29 <solatis> almost as bad as the 'there are only 10 types of people in the world..'
20:45:40 * hackagebot taffybar 0.4.1 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.1 (TristanRavitch)
20:46:11 <pjdelport> (obligatory original: http://martinfowler.com/bliki/TwoHardThings.html )
20:49:20 <slack1256> I am reading the ghc-mod code and I see `import Paths_ghc_mod' at the top. Such module is on ./dist/build/autogen. I don't understand how it all works
20:49:51 <merijn> slack1256: Paths_packagename is auto generated by cabal
20:50:10 <merijn> Consult cabal docs for details
20:50:18 <merijn> It contains stuff like version numbers, etc.
20:50:30 <slack1256> Oh, OK will check it out
20:55:00 <L8D> @pl \x y -> y
20:55:00 <lambdabot> const id
20:56:10 <solatis> can someone enlighten me how yesod relates to the haskell community? it appears to be a for-profit business contributing an opinionated ecosystem to the haskell community?
20:56:26 <merijn> carter: Oh, bollocks
20:56:57 <merijn> carter: Using DataKinds to indicate the mode ruins a bunch of other stuff from working >.<
20:57:31 <Axman6> solatis: the main developer has a company sure, but yesod is definitely an open project
20:58:21 <merijn> solatis: I don't understand the question?
20:58:34 <solatis> ok
20:59:03 <merijn> What's the problem with for-profit businesses contributing code?
20:59:11 <NemesisD> anyone use ghc-mod in emacs? the docs say it drops a bunch of el files in ~/.cabal/share, but im not sure if you're supposed to tell emacs to load those or what
20:59:13 <Axman6> yesod is just another open source web framework a la happs(tack), SNap and Scotty
20:59:17 <solatis> in other languages you sometimes have a company completely embracing a language and providing an ecosystem for it
20:59:38 <solatis> merijn: i never said i had a problem with it, i actually think its a good thing for the ecosystem to have for-profit businesses
20:59:56 <solatis> look at for example what Typesafe did to the Scala ecosystem
20:59:58 <solatis> it's wonderful
21:00:10 <echo-area> Hi, I am solving exercise 5.3 of /Programming in Haskell/.  I have a program here: http://pastebin.com/YSJDaRY5 but both attempt of writing `copy' fails.  What is the correct way of doing it?  Thanks
21:00:43 <monochrom> it seems clear to me the yesod suite is opinionated by its human author rather than by a company.
21:00:51 <solatis> ok
21:00:54 <Axman6> echo-area: you need brackets around x:xs
21:01:01 <Axman6> copy (x:xs)
21:01:43 <monochrom> it is sensational but unethical to combine "opinionated" and "affiliated to a company" together and try to make a scandulous headline
21:02:01 <pjdelport> echo-area: Function application binds most tightly, so without the parens it parses as (copy x):xs
21:02:06 <monochrom> almost every successful person is affiliated to a company
21:02:24 <echo-area> Axman6: Thanks, I added brackets then both ways work.
21:02:30 <echo-area> monochrom: Thank you
21:02:34 <echo-area> Noted
21:02:34 <kazagistar1> echo-area: { f x + y } is similar to { c x : y }, that might help your intuition?
21:03:11 <merijn> carter: I think the only option I have is actually to just use a normal ADT, not even a GADT
21:03:24 <Axman6> also, why do you need to pattern match on the tuple you've named x? you don't use the values: you could write copy (x:xs) = [x,x] ++ copy xs (or x:x:copy xs)
21:03:36 <merijn> carter: Because the DataKinds parameter leaks into my config record, which then wrecks the monad stack the config record is used in
21:03:43 <Yep> Hi, I found Data.Vector.fromList but there doesn't seem to be a Data.Vector.Mutable.fromList
21:04:26 <Yep> How do I create a mutable vector from a list? It's just for testing so I'm not worried about speed in converting from a list to mutable vector
21:04:54 <michaelt> Yep: thaw $ fromList ls
21:05:06 <Axman6> Yep: http://hackage.haskell.org/package/vector-0.10.9.3/docs/Data-Vector-Generic.html#g:36
21:05:13 <echo-area> Axman6: That was because the missing brackets made me think pattern matching did not work that way.  I now write copy ((a, b, c):xs)
21:05:15 <Axman6> using the Generic interface
21:05:47 <Axman6> echo-area: you don't need to look at the values in the tuple at all though
21:06:10 <Yep> Axman6: No instance for (Data.Vector.Generic.Vector                        (Data.Vector.Unboxed.Mutable.MVector Int) Int)       arising from a use of `Data.Vector.Generic.fromList'
21:06:15 <Yep> thanks michaelt
21:06:28 <echo-area> Axman6: Well I have a bad name for the function.  It actually does not replicate each element of the list twice
21:06:46 <Axman6> echo-area: heh, ok
21:06:59 <Axman6> Yep: that surprises me
21:07:01 <echo-area> kazagistar1: What do the brackets around { f x + y } mean?
21:07:27 <michaelt> Yes, so do write, say do { mv <- thaw $ fromList ls ; ... ending, say, ... freeze mv } so the whole block returns a non-mutable vector
21:07:34 <platz> some digging in the logs reveals that just sticking to mtl and monad transformers may be better than fancy free monads http://i.imgur.com/R01d2HG.png
21:08:27 <kazagistar1> echo-area: thats just how I put code inline in IRC comments, but brackets are a (rarely used) part of haskell... you just normally use whitespace and indentation instead
21:08:47 <platz> benchmark from here: https://github.com/feuerbach/freemonad-benchmark
21:08:58 <Axman6> Yep: unsafeThaw would be safe in that situation
21:09:38 <Axman6> hmmmm,. I swear that was a function
21:10:08 <echo-area> kazagistar1: Okay.  And { c x : y } means adding { c x } in front of the list { y }, right?
21:10:14 <Axman6> http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Generic.html#v:unsafeThaw
21:11:22 <lispy> echo-area: yeah it would parse as ((c x) : y)
21:11:37 <lispy> echo-area: function application has the highest precedence.
21:11:47 <echo-area> Got it.  Thank you guys
21:12:15 <kazagistar1> the "lispy" fully parenthesized and prefix version is ((:) (c x) y)
21:13:11 <echo-area> Well, in lispy it should be : instead of (:) unless : is a function returning a function that concatenate lists ;-)
21:13:36 <David> int-e: not sure why this happens, but I can run lambdabot and it works perfectly... the first time I run it after install. After that it complains " Could not find module `Lambdabot.Plugin.Eval.Trusted'" every time I try to do @run, but reinstalling it (cabal install from the git repo) lets it run again
21:14:00 <kazagistar1> right, that would be in lisp, but to turn infix into prefix in haskell, you just write parens around it and put it in front
21:14:04 <David> the failure seems to have something to do with nohup
21:14:59 <kazagistar1> > ((:) 1 [3,4])
21:15:01 <lambdabot>  [1,3,4]
21:15:10 <echo-area> kazagistar1: Oh, didn't know that.  That's cool
21:15:15 <kazagistar1> > ((+) 2 3)
21:15:17 <lambdabot>  5
21:15:36 <kazagistar1> its really just a special case of the way that currying works
21:15:47 <kazagistar1> > (2 + 3)
21:15:50 <lambdabot>  5
21:16:07 <kazagistar1> > map (+2) [1..5]
21:16:09 <lambdabot>  [3,4,5,6,7]
21:16:12 <merijn> carter: I take it back, I actually CAN make it work. Downside: polymorphic phantom parameter in half my types Upside: GHC statically verifies that all my authentication code paths are correct :D
21:16:19 <kazagistar1> :t (+2)
21:16:20 <lambdabot> Num a => a -> a
21:16:27 <kazagistar1> :t (+)
21:16:28 <lambdabot> Num a => a -> a -> a
21:17:10 <merijn> Although with this extra phantom type I *reall* need a better name for this type :\
21:17:18 <kazagistar1> echo-area: also, functions are made infix with backticks, which is handy sometimes
21:17:44 <kazagistar1> > 8 `mod` 3
21:17:46 <lambdabot>  2
21:18:26 <echo-area> kazagistar1: That is only for functions having two arguments, right?
21:18:50 <merijn> echo-area: You can have infix functions with more than two arguments, but the parsing usually makes it less useful
21:19:04 <merijn> :t foldr
21:19:05 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:19:16 <Iceland_jack> echo-area: You can also use them for unary operators with certain extensions
21:19:16 <merijn> :t (+) `foldr` 1
21:19:18 <lambdabot> Num b => [b] -> b
21:19:20 <carter> merijn: you can hide the param existentially
21:19:25 <merijn> carter: Nope
21:19:32 <merijn> carter: Then all my pipes code breaks
21:19:37 <carter> :)
21:19:53 <merijn> carter: Which makes sense, because doing that hides the GADT which lets GHC verify the code paths make sense
21:20:19 <echo-area> Still a lot of things to learn :)
21:20:38 <merijn> echo-area: Unfortunately "(+) `foldr` 1 []" parses as "(+) `foldr` (1 [])", hence why it's not very useful for more than 2 parameters :)
21:20:41 <kazagistar1> echo-area: the way currying works means that any function with at least 2 arguments will return something if you pass it only 2 values... the thing it returns might just be a function though
21:20:50 <merijn> > (+) `foldr` 1 $ [] -- this works, though
21:20:52 <lambdabot>  1
21:21:08 <merijn> > ((+) `foldr` 1) [] -- so does this
21:21:10 <lambdabot>  1
21:21:26 <merijn> Any naming suggestions for this type "type Parser m a = StateT (Producer a (SafeT IO) ()) (Producer a (ReaderT (SocketConfig m) (SafeT IO)))"
21:21:29 <merijn> ?
21:21:46 <merijn> It's a variations of pipes-parse Parser types, but I feel the name Parser gives the wrong impression :\
21:22:04 <echo-area> merijn: Does $ have a special meaning there?
21:22:14 <merijn> echo-area: $ is just another operator :)
21:22:17 <kazagistar1> @src ($)
21:22:18 <lambdabot> f $ x = f x
21:22:21 <merijn> echo-area: "f $ x = f x"
21:22:42 <merijn> echo-area: But $ has a really low precedence, so you can read "f $ x" as "(f) $ (x)"
21:22:55 <merijn> Hence why it makes that expression work, :)
21:23:11 <kazagistar1> echo-area: the only magical bit is that is has really really low precedence, so it evaluates last, and it is used to save parens (so we dont run out I guess)
21:23:59 <michaelt> merijn: the usual pipes Parser type would have forall x . (Producer a (SafeT IO) x) as the state, no?  Not that that help justify the decision to call them parsers
21:24:36 <merijn> michaelt: The regular one also forces the result monad to be the same as the base of the input producer
21:24:51 <michaelt> yes.
21:25:11 <merijn> michaelt: Which is really problematic if you want your result to be a producer :)
21:25:24 <echo-area> So I can put $s between every arguments to use the infix syntax.  Which is not a good way though, because it makes the code harder to read
21:25:25 <merijn> It cost me like 2 days of bothering Tekmo to come up with this formulation :)
21:25:56 <merijn> echo-area: . is usually better than $, . is function composition, that is "(f . g) x = f (g x)"
21:26:11 <merijn> echo-area: You can think of it as a (reversed) shell pipeline
21:26:26 <merijn> > let f = reverse . map (*2) in f [1..5]
21:26:38 <lambdabot>  [10,8,6,4,2]
21:27:09 <echo-area> Cool
21:27:32 <merijn> michaelt: I'm kinda tempted to call it "Pipe", but that may be confusing, given the usage of pipes in my library :\
21:28:28 <michaelt> merijn: It won't be a big deal if the user is not expected to be using the pipes library as well
21:28:35 <michaelt> merijn: if they are then call it a Conduit
21:28:44 <kazagistar1> lol
21:29:03 <merijn> michaelt: Well, it's an internal type for my library, but I plan to use the internals as topic for some haskell talks
21:29:11 <merijn> michaelt: So clear names are important
21:29:31 <michaelt> merijn:  I see, in that case yes.
21:29:45 <merijn> "Handshake", maybe? "Parser m a" is a type that receives a's, and outputs a's during a networking handshake
21:30:16 <merijn> (Hence the input producer and result producer having the same a)
21:30:48 <merijn> Maybe that usecase inspires someone with a better name?
21:31:32 <kazagistar1> HandPipe <_<
21:31:38 <michaelt> hah
21:32:35 <michaelt> type Shake m a = ... but that's taken too
21:34:12 <merijn> I think Handshake would be better than Shake
21:35:00 <kazagistar1> Would "HandshakeParser", "HandshakeProcessor", or something? a 2 word type?
21:35:22 <michaelt> Yes. The difficult thing about the type is that the monad thats being StateT-ified is itself Producer ...
21:35:32 <merijn> kazagistar1: Well, the parser is not really necessary, the only reasons it's called that now is because that's what pipes-parse uses
21:35:44 <kazagistar1> AbstractHandshakeProcessorParserMonadFactoryBean
21:36:09 <merijn> hmm, the more I think about it, the more I think Handshake is probably best
21:36:18 <merijn> It's at least significantly clearer than Parser
21:40:50 <michaelt> merijn: so when I apply one of your Handshakes to my Producer a (SafeT IO) () I get a Producer a (ReaderT (SocketConfig m) (SafeT IO)) (x, Producer a (SafeT IO) ())
21:41:42 <michaelt> I then run the first part of the producer somehow, and return to my Producer a (SafeT IO) ()
21:45:04 <merijn> michaelt: Basically what I do is: I accept a socket connection, I have a "Handshake m ByteString Version", you runStateT it inside a "Producer ByteString (ReaderT (SocketConfig m) (SafeT IO)", which will return "(Version, Producer ByteString (SafeT IO) ())" where the producer has the leftover data from the socket after handshaking
21:46:10 <merijn> The "Producer ByteString (ReaderT (SocketConfig m) (SafeT IO))" is itself hooked up to the same socket, so any ByteString's produced are written to socket, hence how it's a handshake :)
21:46:28 <michaelt> right
21:47:39 <merijn> michaelt: If you're interested, I hope to put the initial version of the source on bitbucket this weekend (which may or may not be a bit optimistic, given the amount of polishing needed)
21:47:59 <michaelt> oh cool. Youre going to give a talk about it?
21:51:11 <merijn> michaelt: I've been planning to give a "abusing advanced GHC typing features for extra safety" talk and given the amount of GHC extension abuse I put in here, I might as well use it as a running example :)
21:52:24 <trap_exit> if the following is off topic, please let me know: is there any haskell groups around Stanford?
21:52:31 <trap_exit> SF will do too
21:52:41 <trap_exit> I'm looking for a meetup of sorts, for ahskellers, in real life
21:52:41 <trap_exit> with wekely talks or something
21:52:44 <merijn> trap_exit: There was a haskell meetup in Mountain View last thursday
21:52:57 <trap_exit> merijn: URL ?
21:53:29 <carter> trap_exit: theres stuff near stanford
21:53:29 <carter> ask shachaf
21:53:29 <carter> hacker dojo once a month?
21:53:51 <trap_exit> hacker dojo? eh, those guys do not seem very rigorous in their work
21:53:56 <merijn> trap_exit: http://www.meetup.com/haskellhackersathackerdojo/events/195735192/
21:54:09 <merijn> >.>
21:54:20 <carter> @google haskell hacker dojo
21:54:20 <carter> @google haskell hacker dojo  meetup
21:54:22 <lambdabot> http://www.meetup.com/haskellhackersathackerdojo/
21:54:22 <lambdabot> Title: Haskell Hackers at Hacker Dojo (Mountain View, CA) - Meetup
21:54:23 <lambdabot> http://www.meetup.com/haskellhackersathackerdojo/
21:54:23 <lambdabot> Title: Haskell Hackers at Hacker Dojo (Mountain View, CA) - Meetup
21:54:30 <merijn> carter: That's the one I just linked :p
21:54:32 <trap_exit> ouch I just insulted the wrong group
21:55:30 <merijn> trap_exit: You say not very rigorous, but there's a whole bunch of people with >10 year of haskell experience there :p
21:55:38 <carter> hah
21:56:16 <trap_exit> hmm
21:56:16 <trap_exit> there's Conal Elliot
21:56:17 <trap_exit> he's pretty good
21:56:28 <carter> merijn: i just hit my 10 years of haskell mark i think
21:56:38 <trap_exit> there's "Merijn Verstraate­n" ... no idea if he's any good
21:56:55 <merijn> carter: There was someone who's first GHC was 5.x :>
21:57:00 <MP2E> wow congrats, a decade of Haskell... :)
21:57:06 <MP2E> Hope to get there one day :P
21:57:30 <trap_exit> Mp2E: !!!
21:57:32 <merijn> trap_exit: He's terrible :)
21:57:41 <trap_exit> has anyone upgrated nixos to 7.8.3 yet?
21:57:52 <trap_exit> merijn: if you ever meet him, tell him to stop spreading lies on irc
21:57:59 <carter> yeah merijn  is probably a newb compared with conal
21:57:59 <carter> Version 5.04.3 (released 11 March 2003)
21:57:59 <carter> hrm
21:58:11 <merijn> carter: hmm, maybe 4.x then?
21:58:13 <MP2E> ghc has been updated to 7.8.3, just nobody updated the Haskell Platform
21:58:16 <merijn> carter: I forget :p
21:58:17 <MP2E> and nah nobody has done it yet :P
21:58:30 * merijn always just installs Haskell Platform like a n00b
21:58:31 <carter> merijn: i might have tried using 5.X, i dont remembmer
21:58:31 <carter> i think hugs worked better on windows than ghc did
21:58:31 <carter> i forget
21:58:48 <trap_exit> mp2e: wait, so is there a wya to install 7.8.3 on nixos yet?
21:58:49 <carter> 1.5. Release notes for version 4.08 (July 2000)
21:59:30 <MP2E> trap_exit: yep! use 'nix-env -iA haskellPackages_ghc783.ghc' and when installing packages use 'nix-env -iA haskellPackages_ghc783.packageName'
21:59:40 <carter> trap_exit: probably dl the binary :)
21:59:55 <trap_exit> carter: this is nixos, it'll remove it on reboot
22:00:07 <merijn> Whoo!
22:00:12 <carter> trap_exit: dl it again each time you boot
22:00:13 <trap_exit> MP2E: this better install ghc, and not some MP2E_root-kit
22:00:17 <carter> and save the tarball somewhere
22:00:19 <MP2E> haha
22:00:26 <merijn> Now I get to play the "decide where to put a function so that it won't cause a recursive import"-game
22:00:27 <MP2E> I don't have enough influence on NixOS to do that :P
22:00:43 <merijn> If someone kickstarts a project to add recursive imports to GHC I'm backing it...
22:00:45 <trap_exit> merijn: I use the put each function in it's own module technique
22:00:53 <carter> merijn: one big ass module
22:00:58 <merijn> trap_exit: That just makes recursive imports *more* likely
22:01:06 <carter> merijn: i don't think you can afford the dev time that'd need
22:01:11 <merijn> carter: I already have a single huge module containing all my types
22:01:16 <trap_exit> merijn: hmm, yeah, my method can't handle mutually recursive functions
22:01:17 <carter> merijn: on big god module
22:01:17 <carter> or just write a boot file
22:01:17 <trap_exit> carter wins
22:01:49 <merijn> carter: A boot file would be fine if it was just one module, rather than inadvertently making half my modules recursive
22:01:57 <carter> :)
22:02:03 <carter> merijn: refactor mofo
22:02:23 <merijn> carter: Last 3 times I spend LITERALLY 3 days refactoring to a point where GHC stopped complaining
22:02:55 <merijn> carter: I need a single conversion function from my authentication GADT to my ADT, I guess I'll just stuff that into my Types.hs too >.>
22:03:05 <carter> merijn: write everything in one big module
22:03:07 <merijn> Because putting it anywhere else will probably break things horrifically
22:03:12 <merijn> carter: >.<
22:03:28 <carter> merijn: then split it later
22:03:53 <carter> let the SCC graph determine your module structure
22:03:56 <L8D> Is there a list somewhere of a bunch of all those simple data functions like zip, repeat, cycle, filter, map, reduce, take, drop, etc....?
22:04:11 <L8D> I'm implementing a functional programming library in JS
22:04:22 <pjdelport> L8D: Prelude?
22:04:38 <L8D> pjdelport: I should just look in there?
22:04:40 <pjdelport> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html
22:04:52 <pjdelport> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html
22:04:59 <pjdelport> Those two are probably a reasonable starting point.
22:05:12 <pjdelport> http://hackage.haskell.org/package/base-4.7.0.1 if you want to go spelunking :)
22:05:33 <nshepperd> I read once that the best feature of ocaml is disallowing recursive import, so that you can always start reading a program at the module that doesn't import anything else
22:06:06 <pjdelport> (L8D: Also, not to discourage you, but you know there are probably dozens of those for JS already, right? Is this more for learning?)
22:07:24 <merijn> nshepperd: The same thing applies to GHC haskell and it just sucks
22:07:46 <merijn> nshepperd: Because if you have two types the reference eachother you need to put them in the same module, rather than where they logically belong
22:08:39 <carter> unless you write a boot file
22:08:40 <carter> problem solved
22:08:41 <nshepperd> maybe that means you shouldn't have two types that reference each other!
22:09:00 <carter> or write a boot file
22:09:08 <merijn> carter: Unless you have a lot of those types, in which case writing a boot file is non-trivial too
22:09:10 <carter> :)
22:09:52 <dolio> You folks who want GHC to automatically figure it out are crazy.
22:09:59 <dolio> I've worked in systems that do, and it sucks.
22:10:02 <augur> is there a way to use a structured project in GHCi?
22:10:38 <augur> like, i have a project with hierarchical module structuring as usual, and i'd like to load it into GHCi
22:10:43 <merijn> dolio: The report demands it! :p
22:10:51 <dmj`> augur: what happens when you try?
22:10:58 <merijn> augur: Just load the modules?
22:11:14 <augur> merijn: it tends to complain that the modules in question arent present
22:11:20 <augur> lemme try again just in case, but
22:11:21 <lpaste> merijn pasted “recursive types” at http://lpaste.net/706536637181460480
22:11:39 <merijn> nshepperd: Feel free to suggest how to disentangle that :p
22:11:43 <augur> merijn: it doesnt seem to want to load a given module if its up and across
22:11:47 <dolio> If you're not dilligent circularities start creeping in until your entire project is one big ball of mud, and the entire thing has to be recompiled, slowly, when you change anything.
22:11:47 <merijn> augur: Is your search path correct?
22:11:53 <augur> merijn: dunno!
22:12:10 <merijn> dolio: Feel free to suggest how to eliminate circularities!
22:12:14 <dmj`> augur: does this project contain a folder named "src"
22:12:23 <dolio> Don't write them.
22:12:24 <augur> dmj`: it can
22:12:34 <merijn> dolio: No, I mean in my lpaste above
22:12:48 <merijn> I could just make everything ByteString, but then I might as well program C++...
22:12:55 <dmj`> auguar: you'll need to notify ghci of intermediate folders so it can set its search path properly
22:12:59 <dmj`> augur: :set -isrc
22:13:35 <dmj`> augur: or just shove that in your .ghci file
22:14:01 <carter> merijn: use the mu version
22:14:02 <tabemann> the whole circularities thing is why you put all your types in one file
22:15:13 <merijn> tabemann: Which sucks, because then all your instances are in one file too and before you know it all your code is
22:15:18 <augur> dmj`: im not sure i understand
22:15:43 <merijn> augur: ghci searches for modules relative to your current working dir
22:15:50 <merijn> augur: -i specifies it should search others too
22:16:09 <dmj`> what merijn said
22:16:45 <augur> merijn: ok
22:16:50 <nshepperd> I don't get it, where's the recursion here
22:17:44 <nshepperd> looks like SocketConfig -> AuthRequest -> everything else
22:19:13 <merijn> nshepperd: Except half the modules need SocketConfig
22:19:29 <merijn> nshepperd: Including the logical place to put AuthRequest
22:24:12 <dolio> One thing you can do is break up your modules more.
22:24:30 <lispy> s/can/usually should/
22:26:14 <merijn> dolio: I already have really small modules
22:26:28 <merijn> The largest is 124 lines
22:26:32 <lispy> But is it henning compatible yet?
22:26:44 <lispy> (sorry, I couldn't resist)
22:27:53 <merijn> Man, Henning's modules piss me off
22:28:03 <merijn> And that's all I shall say on that topic
22:28:36 <stalintrotsky> w-what are henning's modules
22:29:34 <merijn> I don't know the name of any off the top of my head
22:29:36 <lispy> stalintrotsky: he has a very distinct style. For example, put 1 typeclass in a module and call it C.
22:30:02 <merijn> stalintrotsky: He believes everything should ALWAYS be imported qualified and therefore all his types and classes have single letter names
22:30:27 <lispy> stalintrotsky: here is an example: http://hackage.haskell.org/package/gnuplot-0.5.1/docs/Graphics-Gnuplot-Frame.html
22:30:31 <merijn> stalintrotsky: "import qualified Data.Map as Map" and then the Map type would be called T (for type)
22:30:42 <merijn> So you'd write "Map.T" in type signatures
22:30:46 <lispy> stalintrotsky: it's very confusing to read in haddocks because haddock doesn't qualify imports
22:31:35 <lispy> stalintrotsky: in the type of cons, T has three different meanings
22:32:07 <carter> cons :: OptionSet.T graph -> Plot.T graph -> Frame.T graph
22:32:08 <carter> cons = Frame.Cons
22:32:12 <carter> in the source
22:32:21 <lispy> yeah, in the source it's not insane :)
22:32:22 <carter> with henning code the haddocks are less readable thant he code
22:36:36 <merijn> Does GHC warn for total matches in "pattern <- action"?
22:36:57 <lispy> I don't think so
22:37:06 <augur> anyone have a good tutorial on how to use cabal for a project properly?
22:37:37 <augur> Guest89783: greetings!
22:37:50 <lispy> augur: there have been some in the past, but the state of the art has changed. I don't know of any that are up to date.
22:37:56 <lispy> augur: use sandboxes.
22:38:03 <augur> lispy: yes
22:38:08 <augur> but, i dont know jack about cabal
22:38:18 <merijn> lispy: Man, that sucks...
22:38:25 <augur> mostly i want to know how to build this junk with hierarchical module structure
22:38:29 <lispy> augur: do you already have a .cabal file?
22:38:30 <augur> instead of a giant flat list of files
22:38:43 <augur> lispy: i made one, and i think its correct, but
22:39:47 <augur> this really should be something GHC handles. i shouldnt need to dick around with cabal just to make sure my stupid files know what they're referring to :|
22:40:02 <lispy> augur: did you use cabal init to make it?
22:40:07 <augur> lispy: yes
22:40:11 <lispy> cool
22:40:27 <augur> i dont know what im doing with this tho
22:40:34 <augur> ive never used cabal in this capacity so im clueless
22:41:28 <dmj`> augur: use cabal exec
22:41:42 <augur> i dont know what that means
22:41:43 <dmj`> augur: it will set your user pkg db to that of the sandbox
22:42:06 <augur> i know how to use a hammer, i've done it before. i was shown as a young child how to use a hammer.
22:42:17 <augur> i've never been shown how to use cabal exec. i dont know what it means to do so
22:42:19 <dmj`> augur: cabal exec bash, will drop you into a new terminal where ghci -v will show your user pkg db as that of the sandbox
22:42:54 <dmj`> augur: it's like virtualenv in python
22:43:03 <augur> i dont know what that means
22:43:18 <merijn> lispy: Ugh, you're right, it doesn't warn :(
22:43:31 <merijn> lispy: Now I have to manually track which are safe and which aren't...
22:49:13 <joelteon> "too complicated to desugar" haven't seen that one before
22:49:48 <dmj`> augur: whenever you cabal install anything it goes into a package database somewhere on your system. If you aren't using a sandbox it will go into the user package database (unless you use sudo, then I believe it will go global)
22:49:59 <ryantrinkle> merijn: you can use rebindable syntax to fool with that; ghc will only generate a use of 'fail' if it's a partial match
22:50:00 <augur> dmj`: im not cabal installing
22:50:12 <augur> dmj`: im _making_ a project
22:50:21 <ryantrinkle> merijn: i haven't tried it, but you might be able to construct a deprecated 'fail', which might trigger a warning
22:50:42 <dmj`> augur: ok, so you're building a library?
22:50:47 <augur> dmj`: yes
22:50:48 <ryantrinkle> merijn: you could also dump the desugared source and grep for 'fail's
22:50:53 <dmj`> augur: have you defined a cabal file?
22:50:56 <ryantrinkle> not good solutions, but might help if your situation warrants it
22:51:00 <merijn> Looks like there's already a 3 year old feature request for this warning, but it's been punted to 7.10 :\
22:51:13 <augur> well, more or less. ultimately its going to compile down to one file or a bunch of files i guess, whichever
22:51:16 <augur> but yes
22:51:22 <augur> dmj`: yes i have a cabal file using cabal init
22:52:09 <dmj`> augur: have you installed the dependencies you've defined your cabal file
22:52:23 <augur> dmj`: im not sure what you mean
22:52:25 <trap_exit> I love the haskell type system. So I'm writing this piece of code, and it's getting compliated, and I'm like -- this is weird for haskell code -- I'm feeling like I'm not understanding it.
22:52:31 <trap_exit> Then I realize: BAM, I have two types in one type
22:52:35 <trap_exit> and I should split them into types.
22:52:40 <trap_exit> I split them into two types.
22:52:42 <trap_exit> BAM, all is clear.
22:52:45 <trap_exit> Haskell FTW.
22:52:51 <augur> trap_exit: you should write a blog post about that refactoring
22:53:05 <augur> trap_exit: like, right now, before you go further, make a blog post describing this
22:53:25 <dmj`> augur: in your cabal file there is might be a "Build-depends" section, do you have any packages defined there?
22:53:37 <trap_exit> augur: so I don't spam #haskell? :-)
22:54:19 <augur> trap_exit: no, so you can a) extract/solidify understanding of the general princples at work, and b) share the wisdom with others who are new to haskell
22:54:31 <augur> dmj`: no, the project is self-contained
22:54:46 <dmj`> augur: ok, did you run cabal build?
22:54:57 <stalintrotsky> are your files in the right directories? like Data.Foo.Bar should be in Data/Foo/Bar.hs
22:55:14 <augur> dmj`: no, all i've done is cabal init. like i said, i dont know cabal, so i dont know what im doing
22:55:15 <stalintrotsky> for ghc to autofind it
22:55:41 <trap_exit> augur: I should setup a kickstarter and see if I can get funding for this
22:55:49 <augur> trap_exit: lol
22:55:54 <augur> kickstart my haskell blog post!
22:56:12 <stalintrotsky> make a patreon and get paid to continuously blog
22:56:33 <lispy> live coding on twitch
22:56:34 <trap_exit> level 1: $10.00: you get your name on my site; level 2: $50.00 : you get a t-shirt, level 3: $1000.00, I'll write a blog post about any aspect of ahskell you want!
22:56:40 <trap_exit> you know
22:56:47 <trap_exit> I would pay for a live stream of a hskell exprt
22:56:53 <dmj`> augur: look through cabal help, see if its intuitive, as stalintrotsky mentions having your modules named correctly (corresponding to folder names) is necessary
22:56:58 <MP2E> twitch.tv/fishcodehaskell (not a real link AFAIK, unfortunately :P)
22:57:04 <dmj`> augur: run the command "cabal help"
22:57:08 <lispy> MP2E: that's exactly what I was thinking of :)
22:57:09 <trap_exit> like if I could see a haskell expert code, I'd pay a montly subscritipn of somethig like $10.00 / month
22:57:31 <dmj`> trap_exit: that's it?
22:57:33 <joelteon> that's a lot of money
22:57:37 <stalintrotsky> there should be a CSPAN for watching haskellers haskell
22:57:40 <joelteon> ten bucks? that's like, a github membership
22:57:41 <dmj`> trap_exit: don't break the bank
22:57:41 <trap_exit> MP2E: how does the input work? do you overlay an keyboard, or does the fish input 8 bits
22:57:45 <joelteon> that's how much i spend on gas
22:57:46 <trap_exit> dmj`: if many people pay $10.00 / month, it's a lot
22:57:50 <lispy> trap_exit: actually, I'd love for us to develop a notion of mentors here in the community
22:57:57 <lispy> trap_exit: so that we can do stuff like that
22:58:13 <trap_exit> yeah, jle` was especialy helpful in helping me understand monads
22:58:19 <dolio> That sounds like one of the few things that could be more boring than CSPAN.
22:58:24 <trap_exit> I'd probably pay $10.00 / month to watch luite livestream ghcjs
22:58:37 <joelteon> i don't think luite would take $10/month to livestream ghcjs
22:58:39 <dmj`> trap_exit: there should be a haskell youtube where people who upload good videos receive royalties based on viewage and can receive donations as well / make their own channels
22:58:52 <trap_exit> joelteon: but many people may pay $10.00 / month
22:59:03 <MP2E> lambdatube
22:59:15 <trap_exit> then for $20.00 / month, you get to remotely shock the live-streamer if they get a compiler error
22:59:20 <MP2E> rofl
22:59:30 <trap_exit> so they wear this bracelet, and when they get a compile error, watchers vote: shock or not
22:59:34 <merijn> That doesn't sound appealing
22:59:36 <pjdelport> dmj`: Flattr?
22:59:40 <dmj`> this would proliferate haskell and force haskellers to learn marketing over monads
22:59:43 <merijn> I get compile errors all the time
22:59:45 <trap_exit> it'd be hilarious
23:00:00 <merijn> Like, 90% of my compiles have compile errors >.>
23:00:16 <dolio> That's the point, really.
23:00:23 <int-e> trap_exit: that would be hell for refactoring-by-chasing-type-errors
23:00:34 <dmj`> pjdelport: I'm not familiar with Flattr
23:00:34 <MP2E> indeed, it would probably enforce bad practice :P
23:00:40 <MP2E> -fdefer-type-errors
23:00:41 <trap_exit> merijn: I can't even write a single function w/o getting a compile error
23:00:54 <lispy> I think a good format would be to code like normal but record the session. Then add commentary on top / speed it up a bit.
23:01:11 <pjdelport> dmj`: It's a social microdonation thing that lets you "tip" works by people.
23:01:17 <augur> joelteon: $10 a month is like a good chunk of the Code School site and they have lots of junk
23:01:34 <lispy> "At this point I was wondering how to change the type to avoid non-sensical values. You can see that I ultimately went for a Maybe..."
23:01:52 <dmj`> pjdelport: that'd be cool, we should roll our own from scratch though. Since it is haskell :) and use acid-state loool
23:02:15 <stalintrotsky> I finally figured out how to use acid-state today, I had to read happstack docs
23:02:15 <augur> dmj`: cabal help isn't helpful.
23:02:16 <trap_exit> this does sound interesting
23:02:23 <dmj`> augur: the irony
23:02:26 <trap_exit> having 1 expert live coding, having 2 experts do live commenting
23:02:28 <lispy> augur: what are you stuck on?
23:02:32 <augur> dmj`: man pages are rarely helpful
23:02:33 <trap_exit> dude, I think this is going to be a real success idea
23:02:35 <pjdelport> dmj`: There's actually a project like that busy bootstrapping, as an alternative to GitTip: https://www.atunit.org/
23:02:36 <trap_exit> twitch.tv for haskellers
23:02:41 <augur> lispy: everything? i dont know what im doing. a pile of commands is not an understanding
23:02:45 <trap_exit> it'll get acquired by google for like 2 billion dollars
23:02:47 <trap_exit> who wants to help me build it
23:02:58 <lispy> augur: I know that feel. So, where are you at the moment?
23:03:01 <joelteon> no
23:03:03 <trap_exit> I'll start with the first line: "main :: IO ()"
23:03:06 <pjdelport> dmj`: The name is just a placeholder still, but so far it will be Haskell-based.
23:03:07 <glguy> trap_exit: I think you might be overestimating how exciting it would be to watch an "expert" haskell programmer in real time
23:03:11 <augur> lispy: i'm at the moment of saying "ok.. what am i supposed to do"
23:03:14 <dmj`> trap_exit: build what
23:03:27 <lispy> augur: So, you have a .cabal file, you have some .hs files?
23:03:33 <augur> lispy: yes, and thats it
23:03:33 <pjdelport> dmj`: There's #atunit and #atunit-tech if you want to get involved. :)
23:03:37 <int-e> glguy: I imagine it's like watching a high level chess game, except with a bit more activity ;-)
23:03:46 <lispy> augur: and if you type 'cabal configure' does it complain?
23:03:54 <augur> lispy: i dont know. why would i do that?
23:04:03 <joelteon> has cabal always had the --with-compiler flag, or was that a recent addition?
23:04:04 <dmj`> trap_exit: every IRC handle will get its own channel to post videos of their haskell tutorials, they could give out premium and freebie content
23:04:09 <lispy> augur: You might do that to test your .cabal file.
23:04:22 <augur> lispy: what will it test for?
23:04:36 <dmj`> pjdelport: what is #atunit?
23:04:40 <trap_exit> glguy: I think there's some interesting sweatspot between "here's a bunch of haskell code that someone wrote" and "here's them creating the code live" -- i.e. something to be learned by observing th eprocess of it being created
23:04:56 <trap_exit> glguy: though I do have to admit, I'm easily amused, and find watching car factory assembling cars fasicanting
23:04:58 <pjdelport> dmj`: IRC channel for https://www.atunit.org/
23:05:08 <lispy> augur: it will look at your build-depends mostly. It will also make sure the .cabal file parses and it will see if it can figure out how to build your library.
23:05:18 <augur> lispy: it says
23:05:20 <augur> > cabal: No 'main-is' field found for executable language-engine
23:05:21 <lambdabot>  Not in scope: ‘cabal’Not in scope: data constructor ‘No’Syntax error on 'main
23:05:22 <lambdabot>  Perhaps you intended to use TemplateHaskell
23:05:31 <augur> oh hush lambdabot
23:05:34 <int-e> trap_exit: you'd still be missing out on all the thinking
23:05:44 <dmj`> trap_exit: smells like php
23:05:50 <lispy> augur: ah, so 'main-is:' tells cabal what file has main :: IO (), and that is needed for executables
23:05:54 <pjdelport> trap_exit: Literate Programming -> Performative Programming?
23:05:59 <dmj`> pjdelport: that was for you sorry
23:06:10 <dolio> int-e: You'd get to see the websites they browse randomly while doing the thinking, though.
23:06:12 <augur> lispy: i want to build to a library i can FFI into from C
23:06:14 <lispy> augur: do you plan to make an executable or a library? both?
23:06:14 <dolio> That's almost as good.
23:06:18 <trap_exit> int-e: what do you recommend? should we force them to code inside a MRI machine, so we can see their brain activations too?
23:06:19 <pjdelport> dmj`: PHP?
23:06:28 <joelteon> no, wow, it's been there ever since cabal was first written
23:06:29 <joelteon> that's awesome
23:06:32 <joelteon> props, cabal
23:06:34 <lispy> augur: Do you have a link where I can look at your .cabal file?
23:06:40 <tnks> can someone help me better understand why Conal says, "IO is not a part of Haskell that's good for equational reasoning" in http://youtu.be/zzCrZEil9iI https://github.com/conal/talk-2014-bayhac-denotational-design
23:06:45 <int-e> trap_exit: nah, hope that once in a while they give a tutorial talk
23:06:52 <augur> lispy: i can put it up on lpaste
23:06:53 <dmj`> pjdelport: whatever that link is you posted
23:07:15 <pjdelport> dmj`: It's Haskell-based.
23:07:22 <tnks> IO seems to meet my simple definition of substitutability, so I'm confused why that's not sufficient for "equational reasoning"
23:07:33 <lispy> tnks: it's because you need to run `IO a` in the context of the real-world and the `a` can depend on the state of the real-world.
23:08:01 <stalintrotsky> you might get "give me a banana" from getLine once, but you can't replace getLine with "give me a banana" and get correct results
23:08:13 <augur> lispy: http://lpaste.net/109920
23:08:16 <L8D> @pl (.)
23:08:16 <lambdabot> (.)
23:08:18 * lispy looks
23:08:18 <dmj`> pjdelport: www.atunit.org is haskell?
23:08:27 <L8D> @pl ($)
23:08:27 <lambdabot> id
23:08:33 <L8D> There we go
23:08:35 <pjdelport> dmj`: The project is being implemented in Haskell, yes.
23:08:37 <trap_exit> fuck; got ear plug stuck in ear
23:08:37 <trap_exit> brb
23:09:04 <dmj`> tnks: IO can break referential transparency since pure code can cause IO to occur.
23:09:14 <lispy> augur: So the first thing that stands out to me is that this .cabal file is for building an executable only. So we should change it so that it's for building a library.
23:09:20 <int-e> dmj`: hush ;-)
23:09:23 <lispy> augur: Do you know how I could tell?
23:09:24 <augur> dmj`: noooo dont mention referential transparency! :(
23:09:31 <dmj`> int-e: the magic!! its gone :)
23:09:32 <augur> lispy: do tell!
23:09:39 <lispy> augur: line 19
23:09:47 <augur> lispy: seems reasonable!
23:09:55 <augur> lispy: i just did cabal init and followed the instructions
23:09:58 <lispy> augur: it says, "build me an executable named language-engine"
23:10:01 <augur> i dont think it asked if i was making a library or not
23:10:10 <pjdelport> tnks: What is probably meant is that with IO, normal equational reasoning only takes you as far as reasoning about IO actions themselves, not about their results semantics of execution.
23:10:21 <lispy> It does, but if it was your first time you might have gotten lost in the interrogation
23:10:30 <lispy> anyway, we can fix this pretty easily
23:10:38 <lispy> change that line to say, "library"
23:10:49 <augur> just library, or library language-engine?
23:10:52 <lispy> right
23:10:54 <tnks> pjdelport: lispy: okay, if this is really what Conal means, I wish he'd have said so more clearly.
23:10:57 <lispy> just library
23:11:37 <tnks> also. . . I think it's a subtle point that his "denotational design" may not really improve.
23:11:39 <augur> lispy: that seems to make cabal configure happy
23:11:44 <pjdelport> tnks: So in other words, equational reasoning is as perfectly good for IO as for any other pure Haskell code, but only up to the point of manipulating actions, not for describing their semantics (which probably needs higher-level tools).
23:11:58 <lispy> augur: There is also a 'cabal check' command that you should use periodically
23:11:59 <tnks> pjdelport: completely agree.
23:12:10 <augur> dmj`: "referential transparency" is an awful way of understanding whats going on, for a number of reasons :\
23:12:19 <pjdelport> tnks: I haven't watched that video, by the way, so I'm just speculating and not necessarily reflecting what Conal meant. :)
23:12:23 <lispy> augur: do you have some .hs files relative to this .cabal file? Perhaps src/Foo.hs?
23:12:32 <augur> lispy: yes
23:12:48 <tnks> pjdelport: it's a nice video thus far, but that one point feels sticky and debateable.
23:12:53 <L8D> @pl seq
23:12:53 <lambdabot> seq
23:12:56 <L8D> :t seq
23:12:58 <lambdabot> a -> b -> b
23:12:58 <lispy> so you'll want to edit line 24 to be something like `hs-source-dirs: src`
23:13:21 <lispy> augur: you'll also need to define exposed-modules and other-modules
23:13:21 <augur> lispy: ok
23:13:41 <augur> lispy: which will mean/do what?
23:14:05 <lispy> exposed-modules are the ones that people can import when they use your library
23:14:10 <lispy> other-modules is for everything else
23:14:28 <augur> lispy: ultimately im just going to expose a single module which will re-export a collection of functions
23:15:04 <lispy> okay, so you'll list that in the exposed-modules: Augur.Rexport.The.World
23:15:29 <lispy> and that needs to live at src/Augur/Rexport/The/World.hs
23:15:52 <augur> lispy: ok
23:16:01 * hackagebot https-everywhere-rules 0.0.1 - High-level access to HTTPS Everywhere rulesets.  http://hackage.haskell.org/package/https-everywhere-rules-0.0.1 (vi)
23:16:10 <tnks> pjdelport: lispy: actually, I think Conal's point is making more sense now. . . I think the trick is to bring elements of RealWorld into types and values, so we can speak to it's denotation more precisely.
23:16:39 <lispy> tnks: I haven't watched that video, but that strikes me as something Conal might say.
23:17:15 <augur> lispy: and once i have such a thing set up?
23:17:24 <lispy> augur: world domination?
23:17:36 <augur> then i just do cabal build to compile the exposed module? or what?
23:17:42 <lispy> yeah
23:18:04 <augur> ok
23:18:08 <lispy> and cabal install is something like cabal configure; cabal build; cabal copy
23:18:57 <dmj`> augur: for exectuables don't use cabal install, all you need is cabal build. cabal install puts them in your sandbox directory, cabal build puts them in the dist folder, cabal clean removes the dist folder
23:19:00 <lispy> I like to use sandboxes so I typically do; cabal sandbox; cabal install
23:19:09 <augur> lispy: and if i need to use some C stuff when building?
23:20:07 <lispy> augur: that will be more involved. You'll need to tell cabal where the C sources (or compiled library) can be found. You'll need to know how to use the FFI.
23:20:34 <avocado> i have a package that depends on Tensor-1.0.0.1 but cabal can't build it. am i ... missing something?
23:21:01 <lispy> augur: by the way, I often come back to this page as a reference: http://www.haskell.org/cabal/users-guide/developing-packages.html
23:21:02 * hackagebot https-everywhere-rules-raw 4.0 - Low-level (i.e. XML) access to HTTPS Everywhere rulesets.  http://hackage.haskell.org/package/https-everywhere-rules-raw-4.0 (vi)
23:21:57 <lispy> c-sources: filename list
23:21:58 <lispy> A list of C source files to be compiled and linked with the Haskell files.
23:22:56 <augur> lispy: cool, thank you
23:23:00 <lispy> yw!
23:23:04 <augur> lispy: its building :O
23:28:09 <augur> oh my, lispy
23:28:17 <augur> it built and spit out a bunch of stuff into dist
23:28:26 <augur> including a .dylib and a .a
23:29:43 <augur> now if only i know what those were :)
23:30:11 <augur> can you tell i dont do this junk much? i think ive never actually had to do anything serious with haskell. ive only ever used Xcode for actual compiled projects
23:31:09 <augur> thank you lispy, dmj`
23:31:31 <pjdelport> tnks: I assume http://conal.net/papers/type-class-morphisms/ is the associated paper?
23:31:36 <pjdelport> Looks neat!
23:31:57 <dfeuer> Well, that's lovely. I just lost my job :-(
23:32:11 <lispy> augur: nice! let me know if you have more questions
23:32:14 <augur> dfeuer: :(
23:32:14 <lispy> dfeuer: :(
23:32:17 <augur> dfeuer: what happened?
23:32:28 <augur> lispy: yes, what do i do with it now? lol
23:32:44 <dfeuer> augur, an accumulation of various things. The boss has hated my guts forever.
23:33:05 <dfeuer> He's also, apart from everything, a total asshol.
23:33:06 <augur> lispy: also how do i build it with some imported C code that im also going to be importing on the other side of the FFI barrier?
23:33:07 <dfeuer> asshole.
23:33:11 <augur> dfeuer: :(
23:33:16 <augur> dfeuer: what did you do?
23:33:28 <dfeuer> augur, ATM repair.
23:33:33 <augur> ah
23:33:57 <lispy> augur: well, FFI stuff is more advanced. It's usually best to learn it by example.
23:34:10 <dfeuer> As upset as I am at the moment, and as scared as I am about not knowing what my next source of income will be, I kind of feel like I just left an emotionally abusive relationship.
23:34:11 <augur> lispy: well, i know how to import the stuff
23:34:15 <tnks> pjdelport: I don't know if he's referencing a particular paper in this talk, but I know Conal talks a lot about denotation.
23:34:34 <augur> lispy: i just dont know quite how to compile the haskell
23:34:56 <lispy> dfeuer: If you want to talk about it #haskell is probably not the best place. #haskell-blah would be better.
23:34:56 <augur> lispy: i thiiink i just have to tell cabal to about the .h file, right?
23:35:05 <dfeuer> True dat.
23:35:15 <augur> dfeuer: i know that feeling
23:35:15 <lispy> augur: Is the C code already built or do you want ghc to build it?
23:36:08 <augur> lispy: im not sure i care, as long as i can use it in the C project as well
23:36:55 <lispy> augur: it matters for your .cabal file. If ghc is to build the .c file then you use c-sources but if you alread have the library then you use extra-libs
23:36:57 <augur> lispy: basically i need to translate between Haskell    Either String (String,Thing)   and a representation of that on the other side of the FFI
23:37:57 <augur> lispy: i see. well all i need is to be able to also use this C stuff as a library in C as well
23:38:37 <augur> its a bridging file, sort of
23:38:38 <lispy> augur: You probably want to use the extra-libs version
23:38:42 <augur> ok
23:38:59 <lispy> you need to make sure the C stuff is build as a library and installed to some location
23:39:35 <augur> ok, so ill have a separate C library for this thing. hm ok
23:39:39 <lispy> er, sorry extra-libraries
23:39:54 <lispy> and in that usage you'll work with the .h files as you thought
23:42:01 <lispy> augur: you'll want to work through this to get familiar with the FFI: http://en.wikibooks.org/wiki/Haskell/FFI
23:42:21 <augur> lispy: yeah
23:42:49 <augur> lispy: i get how to do it on either side of the boundary, but there's more than just writing code :)
23:46:08 <lispy> augur: I'm trying to find a simple ffi example to start from
23:46:13 <lispy> augur: something that has a .cabal file
23:47:46 <augur> lispy: actually, i might be able to get away with some other technique...
23:48:13 <augur> so my problem is, i need to return a pair of values, or an error message, right
23:48:23 <lispy> augur: have you seen this? http://dev.stephendiehl.com/hask/
23:48:28 <augur> and what i guess i could do is some sort of pointer jiggery pokery
23:49:32 <augur> like... on the C side,   char* strRes; Thing* thingRes; char* error;   foo(strRes,thingRes,error);
23:50:00 <augur> and on the haskell side itll return true or false, and set either the results or the error, accordingly
23:50:33 <augur> oh god Swift will be such a dream to work in...
23:53:11 <augur> actually i guess it would actually be &strRes etc since i want to set the pointer to point to the right value
23:53:16 <lispy> if the C side is `int foo( char* strRes, Thing* thingRes, char* error)` then the Haskell side will be something like `foreign import ccall safe c_foo :: Ptr CChar -> Ptr Thing -> Ptr CChar -> IO CInt`
23:53:46 <lispy> and you'll have to define Thing
23:54:00 <augur> lispy: yeah, what i want to do is is set out values
23:54:02 <lispy> CChar already exists in Foreign.C.Types
23:54:52 <augur> so probably i actually need   char**  so i can follow it and set the address of the value it should point to
23:55:09 <lispy> I advocate for making two layers when making an FFI binding. One layer is completely faithful to C. The other layer lifts that into Haskell idioms.
23:55:12 <trap_exit> is there any good book or set of articles
23:55:14 <trap_exit> on ahskell dsls ?
23:55:20 <augur> lispy: how do you mean?
23:55:24 <lispy> trap_exit: ICFP proceedings :)
23:55:35 <trap_exit> lispy: hmm, interesting idea
23:56:15 <lispy> augur: For the lowest layer I use Foreign.C.Types and model everything as closely to C as possible. Then I use that API but lift it up to a high level of abstraction that is more familiar to Haskell programmers.
23:56:27 <no-doz> :t withFile
23:56:28 <lambdabot>     Not in scope: ‘withFile’
23:56:29 <lambdabot>     Perhaps you meant one of these:
23:56:29 <lambdabot>       ‘writeFile’ (imported from Prelude),
23:56:43 <augur> lispy: oh, it doesnt need to be familiar to haskell programmers, its just for me to use
23:57:23 <lispy> augur: you might look at this package as an example: https://github.com/bsl/bindings-GLFW
23:57:54 <lispy> augur: that's the low level bindings stuff. The glfw-b package is the high level stuff: https://github.com/bsl/GLFW-b
23:58:13 <lispy> that's note mine, but bsl writes good code
23:58:37 <augur> 0_0
