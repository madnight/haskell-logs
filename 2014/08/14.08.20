00:05:41 <levi> Software Foundations is definitely in "advanced" territory.
00:15:52 * hackagebot ghc-mod 5.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.0.0 (KazuYamamoto)
00:16:15 <frerich> dfeuer : You around?
00:20:53 * hackagebot HaRe 0.7.2.7 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.7 (AlanZimmerman)
00:28:58 <dfeuer> frerich, I'm around.
00:38:44 <frerich> dfeuer: I'm glad that you started a wiki page giving some background information on 'fusion'. Since I have only a superficial idea of deforestation in general, I thought it migth be nice to have a short introduction to the topic first. I created a sketch at https://gist.github.com/frerich/3f73a46e3f679c2edc7c -- do you think something like this would make sense for your wiki page?
00:47:17 <Peaker> I want to embed the LevelDB C code into the Haskell bindings so they don't depend on the C lib being installed
00:47:32 <Peaker> So I added a git submodule, made Setup.hs build it prior to "cabal build" (preBuild hook)
00:48:03 <Peaker> but now the question is: How do I tell cabal (in the .cabal file) to install the built .so file (of the C lib) into the proper directory and link against that?
00:54:29 <alpounet> Peaker: i think you can just list the C files as c-sources, just like in https://github.com/thoughtpolice/hs-nacl/blob/master/nacl.cabal
00:55:04 <Peaker> alpounet: that's static linking, though.. I guess I could do that, but any reason to use the .so from the C lib?
00:55:16 <Peaker> btw, they're C++ sources
00:57:37 <Peaker> it's got its own build system, so just listing the .cc files seems like it might be a problem
00:57:58 <alpounet> Peaker: ah yeah right that'll be statically linked...
00:58:35 <alpounet> i don't have a clue, never ran into more complicated cases, you probably want to ask about that on SO or cafe or something
01:00:19 <Peaker> alpounet: gonna try just listing the .cc files now, see if that works
01:00:58 * hackagebot ghc-mod 5.0.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.0.1 (KazuYamamoto)
01:19:47 <alpounet> Peaker: did it work?
01:30:02 <latk> I have a package on my laptop, that builds when I use a load of --allow-newer flags. I used cabal freeze on this package after it had installed. When I attempt to install the same package on my server, using the same command, it fails to install because of transformers. Why might this be ?
01:33:04 <Peaker> alpounet: yeah, thanks :)
01:33:15 <Peaker> alpounet: made a pull request for leveldb-haskell bindings, that makes it a stand-alone build without a C dep
01:39:30 <BoR0> @pl map (\(x, ys) -> (x, map f ys))
01:39:31 <lambdabot> map (second (map f))
01:41:10 <frerich> Cool, I wasn't aware of "second", that's useful!
01:41:18 <BoR0> :)
01:41:19 <BoR0> @src second
01:41:19 <lambdabot> Source not found. You speak an infinite deal of nothing.
01:41:26 <BoR0> @hoogle second
01:41:29 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
01:41:29 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec secondaryColor :: SecondaryColor a => a -> IO ()
01:41:29 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec secondaryColorv :: SecondaryColor a => Ptr a -> IO ()
01:41:54 <alpounet> Peaker: yeah, saw that on github :)
01:41:57 <hyPiRion> > second (+1) (1, 2)
01:41:59 <lambdabot>  (1,3)
01:42:23 <BoR0> neat
01:42:34 <BoR0> > second (map succ) (1, [1,2,3])
01:42:37 <lambdabot>  (1,[2,3,4])
01:42:55 <BoR0> > map (second (map succ)) [(1, [1,2,3]), (2, [2,4,6])]
01:42:57 <lambdabot>  [(1,[2,3,4]),(2,[3,5,7])]
01:43:33 <frerich> Might have been nice to call ig 'onSecondOf' or so, such that you can write "(+1) `onSecondOf` (1,2)"
01:44:40 <dv-> i think usually you would pattern match on the tuple somewhere rather than use second
01:45:49 <hyPiRion> or lenses
01:46:07 <hyPiRion> > map (over _2 $ map succ) [(1, [1,2,3]), (2, [2,4,6])]
01:46:09 <lambdabot>  [(1,[2,3,4]),(2,[3,5,7])]
01:46:41 <hyPiRion> There's probably a better way to do that with lenses, though.
01:47:17 <shachaf> > over (mapped._2.mapped) succ [(1, [1,2,3]), (2, [2,4,6])]
01:47:19 <lambdabot>  [(1,[2,3,4]),(2,[3,5,7])]
01:47:39 <Peaker> alpounet: how did you see that? :) Following my user, the leveldb project, or what?
01:47:51 <Peaker> alpounet: (just wondering... :-) )
01:48:16 <Peaker> I want to replace my use of Sophia with LevelDB, because it seems Sophia never compacts the database it creates :(
01:49:49 <alpounet> Peaker: I've been following you for ages on github I think
01:55:12 <Peaker> alpounet: cool :)
01:55:27 <Peaker> is the "either" package dead now with the introduction of "ExceptT" in transformers?
01:55:45 <iron_houzi> I'm trying to read The Haskell Road to Logic, Maths and Programming and I have a hard time understanding the English sentence: "Let n > 1 be a natural number. Then we use LD(n) for the _least_ natural number greater than 1 that divides n." What does 'least' mean here? Lowest in value? (Page 4 btw)
01:55:49 <Peaker> The idea of a "transformers" lib that has all conceivable monad transformers seems to silly to me :(  It would be much nicer to have specific packages for specific transformers
01:56:08 <Peaker> iron_houzi: Yeah
01:56:50 <iron_houzi> Thanks
01:57:58 <Peaker> funny that as part of my dependencies, cabal built operational-TicTacToe
02:03:07 <Peaker> what are the blue packages in ghc-pkg list's listings?
02:03:28 <Peaker> oh, hidden
02:15:33 <Peaker> I have a bracketed computation, is there any nice way to get ghci to run within the bracket? (I don't have an "init" equivalent)
02:16:11 <Peaker> I could make a thread-based thingie that runs the bracket in a thread and sends back the content via an MVar and doesn't die until told to
02:20:52 <frerich> iron_houzi : Funny, I had the exact same issue with reading that book.
02:21:15 <gnegno> Hi all
02:21:24 <phog> hi gnegno
02:21:25 <frerich> iron_houzi : I always read 'least natural number" as "a number which is less natural than any other"
02:21:41 <gnegno> I'm writing from Italy
02:21:46 <gnegno> new on Mirc
02:22:18 <gnegno> Hi Phog
02:22:19 <iron_houzi> frerich: Thanks. I also found the English in that sentence a bit wonky. I hope the rest of the book will not be written in a similar way..
02:23:47 <frerich> iron_houzi: Quite frankly - I didn't finish it, so I wouldn't know. :-]
02:24:09 <iron_houzi> frerich: Was it due to poor language like the example above, or other factors?
02:24:26 <kuribas> Is it bad if a purely functional language has O(n) pattern matching on a datatype?
02:25:42 <MP2E> well, it certainly doesn't sound *good*
02:25:58 <frerich> iron_houzi : Both, in a way. It seemed to be a bit too academic for my test, reminded me of school text books. I missed the "Given this program, here's how reasoning like this and that can improve it." part somehow, i.e. the connection to the 'real world'.
02:26:55 <nclarke> frerich: I've only read some of it, but my impression is that that isn't the point of the book
02:26:55 <kuribas> I had this discussion on the purescript channel (which mattern matches (head:tail) on arrays in O(n)), and people didn't seem to mind.
02:27:17 <nclarke> It's about teaching mathematical/logical reasoning using Haskell
02:28:27 <kuribas> Purescript looks like a great way to generate clean Javascript, except for this.
02:28:34 <frerich> kuribas : Is it really the case that the time needed to match a single pattern such as 'head:tail' is O(n) in the length of the matched list? Or is it rather that matching any pattern in a whole series (think a 'case' statement with a lot of branches) is O(n) in the number of patterns to choose from?
02:29:11 <frerich> To me, the former seems undesireable, the latter plausible.
02:29:13 <kuribas> frerich: It's O(n) right now, since it uses Array.slice(1) from Javascript.
02:30:02 <kuribas> I think it is possible to optimize this in some cases but not in the general case.
02:30:19 <hyPiRion> So it's O(n) where n is the size of the input argument, not  the number of cases.
02:30:29 <kuribas> yes
02:30:35 <frerich> kuribas: That sounds odd. You'd think that when matching "a:b:c:rest", it would maybe access the first elements directly, using a subscript operator or the like.
02:31:31 <kuribas> frerich: yes, matching (a:_) could be done in O(1), but (_:rest) takes O(n).
02:31:50 <kuribas> A simple map becomes O(n^2).
02:32:20 <frerich> Are you sure it isn't Array.splice()?
02:32:54 <kuribas> ok, let's check
02:33:43 <kuribas> It's slice.
02:34:07 <systemfault> splice mutates.. you wouldn't want that.
02:35:39 <kuribas> Pattern matching on a Array seems interesting at first, but I don't see how it could be done efficiently.
02:36:09 <iron_houzi> OK. I'm not worried about this, as I'm reading it as support literature for a class I'm taking. Thanks for sharing your experience with the book.
02:38:38 <frerich> kuribas : When pattern matching e.g. (_:rest), you don't actually need to extract 'rest' just yet. You only need to see whether the array has at least one element. I suppose if the language could tell that you actually *access* 'rest', then it could create a splice?
02:39:22 <kuribas> frerich: it's a strict language.
02:40:40 <kuribas> My suggestion was to use an array and an index into the array, but that wasn't possible because it's incompatible with pure Javascript functions.
02:42:19 <wz1000> Only allow pattern matching on lists?
02:43:06 <kuribas> That's what I would do...
02:43:55 <wz1000> You can efficiently pattern match on Arrays in an impure function.
02:44:28 <kuribas> How?
02:47:20 <wz1000> C style arrays.
02:47:58 <wz1000> int* -> (int, int*)
02:48:22 <kuribas> wz1000: yes, but it compiles to javascript...
02:49:43 <frerich> Ah, I only now notice I had a wrong idea of what Array.splice() does in JavaScript.
02:50:30 <frerich> I thought it's like std::list::splice() in C++ which allows getting elements from a container in constant time.
02:51:36 <kuribas> You can get the head of an array in constant time, but the tail takes O(n).
02:51:54 <wz1000> Why?
02:52:16 <kuribas> Because you need to copy all the elements (minus the head).
02:52:42 <wz1000> Why would you need to copy all elements?
02:53:43 <kuribas> Because it's javascript.  Arrays in Javascript are like hashes, not like C arrays.
02:53:55 <wz1000> If you only use pure functions, why would you need to copy all elements?
02:54:19 <kuribas> Because when you remove the head, you have to re-index all the elements.
02:54:29 <kuribas> At least the engine does.
02:54:38 <kuribas> That's just how javascript works.
02:55:33 <wz1000> So javascript arrays are actually lists?
02:56:00 <stalintrotsky> If it was a list you could get the tail in constant time too, couldn't you?
02:57:05 <kuribas> wz1000: No, they are hashtables.
02:57:08 <stalintrotsky> and lists aren't indexed
02:57:19 <kuribas> wz1000: Associative arrays actually.
02:57:54 <Scorchin> Hi. I'm finding it really difficult to work with cabal. Are there any "for dummies" tutorials that show how to work through creating a new library with some tests? (HSpec or QuickCheck)
02:57:54 <kuribas> stalintrotsky: yes
02:58:28 <kuribas> Scorchin: https://hackage.haskell.org/package/hello
02:58:51 <kuribas> hm, it's a bit old...
02:58:53 <solirc> Scorchin: https://github.com/sol/hspec-example
02:59:34 <Scorchin> Why aren't tests enabled by default?
03:00:02 <solirc> Scorchin: With recent versions of cabal you can just say `cabal test`
03:00:29 <solirc> Scorchin: For development I would use `ghci`, though
03:00:50 <solirc> and then :reload followed by :main
03:01:02 <solirc> after modifying stuff
03:01:09 <dcoutts_> Scorchin: they take extra time to build, and pull in addition dependencies, so you don't always want them
03:01:42 <dcoutts_> Scorchin: you can enable tests by default using a local config file
03:01:43 <solirc> Scorchin: if you use sandboxes, start cabal with `cabal exec ghci test/Spec.hs`
03:01:50 <wz1000> kuribas: Javascript is so weird. So ar["prop"] is the same as ar.prop?
03:01:58 <dcoutts_> Scorchin: or globally in the ~/.cabal/config file
03:02:08 <kuribas> wz1000: yes
03:02:23 <Scorchin> Thanks both, that's really useful. Is there an equivalent example QuickCheck project?
03:04:14 <solirc> Scorchin: I don't know of any.  If you use QC, you have to look at the result yourself and exit your program with exitFailure manually to make cabal recognize test failures
03:04:54 <solirc> Scorchin: Hmm, I guess you could use http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-All.html
03:13:36 <dud> lambdabot: @help
03:13:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:13:50 <dud> lambdabot: @list
03:13:50 <lambdabot> What module?  Try @listmodules for some ideas.
03:13:54 <dud> lambdabot: @listmodules
03:13:55 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
03:16:07 <jaffachief> Is there a way to turn off the optimisation which converts large nullary data structures into enums?
03:25:26 <danilo2> Hello! I;ve got a lens related question. I've got a function mapped over a structure using "mapOf tinplate foo struct" and it maps foo over all matching elements recursively. I want to do it only on one "layer" of data, not digging intyo it recursively. I;ve got a short example explaining what I want to achive - coudl somebody tell me iff is it possible? http://lpaste.net/109690
03:41:22 * hackagebot language-glsl 0.1.1 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.1.1 (VoMinhThu)
03:43:01 <mikusp> Hi. I have a question about linking generated file while building Haskell package. I've created a package that depends on some native code that is compiled during build by nvcc. Right now I'm compiling it to shared library, but it shouldn't make a difference if it was an object file. If I add the library name to extra-libraries field in cabal file, it can't find it during build (it's in the same directory as .cabal file). Setting ext
03:52:05 <iron_houzi> Given this function: is it possible to insert printlines to keep track of which statements were executed? http://vpaste.net/P5tEq
03:52:53 <frerich> iron_houzi : You might find 'trace' useful.
03:52:58 <frerich> @hoogle trace
03:53:01 <lambdabot> Debug.Trace trace :: String -> a -> a
03:53:01 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
03:53:01 <lambdabot> package trace-call
03:53:32 <frerich> iron_houzi: you can use it like 'trace "Recursing" $ ldf (k+1) n'
04:02:49 <iron_houzi> frerich: I've done: import Debug.trace as the first line and installed trace-call with cabal, but I'm getting parse errors on this import line. How do I get this working exactly?
04:06:19 <iron_houzi> frerich: Sorry, capital T in Trace
04:07:20 <Alberta22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
04:08:04 <iron_houzi> frerich: Thank you for you help.
04:43:13 <iron_houzi> How do I execute the function foo(x) n number of times? I've tried: iterate foo [1..99]
04:43:40 <iron_houzi> sorry, n numner of times, with n as the input ..
04:44:09 <iron_houzi> so: foo(1), foo(2) .. foo(99)
04:44:17 <moop> map foo [1..n]?
04:44:17 <Hafydd> iron_houzi: map foo [1..99]
04:44:25 <iron_houzi> ahh
04:44:28 <iron_houzi> thanks
04:44:31 <iron_houzi> good '
04:44:34 <Hafydd> Alternatively: [foo n | n <- [1..99]]
04:44:34 <iron_houzi> ol map
04:48:25 <BoR0> @hoogle a -> b -> (a, b)
04:48:28 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)
04:48:28 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
04:48:28 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
04:48:37 <quchen> :t (,)
04:48:39 <lambdabot> a -> b -> (a, b)
04:48:41 <BoR0> oh, right
04:55:12 <FelipeRosa> Hey guys, are there any attempts to make a complete package manager for Haskell libs? I’m willing to participate in one of those
04:56:34 * hackagebot lifted-async 0.2.0.2 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.2.0.2 (MitsutoshiAoe)
04:58:59 <etandel> FelipeRosa: what do you mean by "complete"? Cabal is quite useful.
04:59:11 <quchen> Cabal is not a package manager.
04:59:17 <quchen> It's an installation system.
04:59:28 <quchen> Think of makefiles.
04:59:43 <FelipeRosa> etandel: I mean something a la ruby bundler, I don’t know
04:59:51 <BoR0> @hoogle instance Functor []
04:59:53 <lambdabot> Did you mean: :: instance Functor [instance]
04:59:53 <lambdabot> Control.Applicative unwrapArrow :: WrappedArrow a b c -> a b c
04:59:53 <lambdabot> Data.Graph.Inductive.Graph empty :: Graph gr => gr a b
05:00:07 <moop> you guys should port npm to haskell
05:00:13 <moop> replace cabal with npm
05:00:15 <moop> np
05:00:23 <etandel> It downloads them from a repository, is able to install them on sandboxes. I'm not so sure it handles dependency...
05:01:04 <etandel> But, again, what is a "complete" package manager?
05:01:34 <hyPiRion> A complete package manager sounds very similar to a sufficiently smart compiler.
05:01:37 <etandel> pip, for Python, does not handle dependencies very well, but it's a package manager.
05:01:57 <moop> it handles deps np
05:02:11 <moop> well, sufficiently good
05:03:37 <FelipeRosa> Well, I hate that I can’t, for example, install the lens package and some web framework together without cabal complaining lol
05:04:00 <FelipeRosa> you gotta create a sandbox everytime, and reinstall many libs
05:07:19 <quchen> Some users use Nix to do the package handling.
05:07:34 <quchen> I've seen some blog posts about it recently.
05:08:23 <etandel> Creating different sandboxes for different projects is quite common in a lot of languages, especially when dealing with more than one project with conflicting dependencies.
05:08:50 <etandel> I don't see what's wrong with that, and I actually think it's good practice.
05:10:05 <nexx> I think in the Haskell world the packages tend to be more restrictive in their dependencies
05:10:28 <FelipeRosa> nexx: what do you mean?
05:12:10 <nexx> I think in other ecosystems the problem ocours rarer, because the packages tend to allow more versions of the packages they depent on
05:16:37 * hackagebot wai-logger 2.2.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.2 (KazuYamamoto)
05:16:39 * hackagebot mighttpd2 3.2.0 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.0 (KazuYamamoto)
05:26:38 * hackagebot union-find-array 0.1.0.1 - union find data structure  http://hackage.haskell.org/package/union-find-array-0.1.0.1 (BertramFelgenhauer)
05:26:40 * hackagebot term-rewriting 0.1.1 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.1.1 (BertramFelgenhauer)
05:27:36 <SCHAAP137> anyone have some good resources on how to configure XMonad in a nice way?
05:27:52 <SCHAAP137> like, examples of how to deviate from the default
05:29:23 <iron_houzi> How do I get prime1 working so that it prints out the number instead of just True/False as it does in prime0? http://vpaste.net/u2DCN
05:30:55 <frerich> iron_houzi: What is the purpose of 'prime1'?
05:31:38 * hackagebot wai-logger 2.2.3 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.3 (KazuYamamoto)
05:31:40 * hackagebot references 0.2.1.0 - Generalization of lenses, folds and traversals to handle monads and addition.  http://hackage.haskell.org/package/references-0.2.1.0 (lazac)
05:32:12 <iron_houzi> frerich: map it to a list of integers and return either False or the prime number. I know this is quite bad haskell, but I'm just trying to wrap my head around haskell by playing and experimentation..
05:32:30 <etandel> make it return Maybe Int
05:32:30 <BoR0> iron_houzi, you can use Either. Left n or Right False
05:32:44 <etandel> return Nothing or Just Int
05:32:49 <mikusp> I have a question about linking generated file while building Haskell package. I've created a package that depends on some native code that is compiled during build by nvcc. Right now I'm compiling it to shared library, but it shouldn't make a difference if it was an object file. If I add the library name to extra-libraries field in cabal file, it can't find it during build (it's in the same directory as .cabal file). Setting extra-l
05:32:50 <etandel> or what BoR0 said
05:32:53 <BoR0> or what etandel suggested
05:32:56 <etandel> =D
05:32:59 <BoR0> :)
05:33:06 <frerich> iron_houzi: "return eihter False or the prime number" sounds like your function should return a value which is either a Bool or an Int.
05:33:11 <frerich> you could use what Bor0 said or what etandel said.
05:33:12 <frerich> ;-)
05:33:53 <BoR0> since you will only have Right False (and no case of Right True), it would be ideal to use the Maybe monad
05:34:40 <quchen> Maybe is a type (constructor). This problem has nothing to do with it also being a monad.
05:34:51 <dcoutts_> mikusp: the extra-libraries is mainly for libraries that are installed on the system
05:35:00 <quchen> You don't call Int "the Int Ord" as well.
05:35:25 <prophile> I call all types "the <type> Generic"
05:35:30 <prophile> that way you know they're not GADTs
05:35:48 <mikusp> ok, so how can I make cabal-install link to my custom library during build?
05:36:40 <iron_houzi> I'm sorry. I didn't understand how to write any of your suggestions. Would you mind spelling it out for me?
05:36:58 <BoR0> quchen, aha, right
05:37:06 <BoR0> s/monad/type/ :)
05:37:30 <quchen> Just call it "Maybe". You don't call Int "the Int type" :-þ
05:37:49 <BoR0> s/the Maybe monad/Maybe/ ? :D
05:37:56 <prophile> ...maybe
05:38:53 <BoR0> iron_houzi, you can solve your problem by making prime1 return "Just n" instead of "n", and "Nothing" instead of "False"
05:39:04 <iron_houzi> Thanks
05:39:39 <BoR0> you should read on types if you want to learn why the problem will be solved that way. I don't think I can explain it as good
05:42:36 <iron_houzi> [Nothing,Just 2,Just 3,*** Exception: prime.hs:(13,1)-(15,32): Non-exhaustive patterns in function prime1
05:42:40 <etandel> Though you'll probably have to rewrite the last guard as `otherwise = if ld n == n then Just n else Nothing`. And your function will have type "Just Int" instead of Int.
05:44:20 <iron_houzi> etandel: Thank you.
05:46:42 <etandel> or, more interestingly, `prime1 n = if prime0 n then Just n else Nothing`
05:47:10 <etandel> now any changes (e.g. optimizations) for prime0 will also take effect on prime1.
05:47:35 <etandel> yay code reuse =D
05:49:16 <moop> @hoogle Foreign.JNI
05:49:19 <lambdabot> No results found
05:49:21 <moop> :(
05:49:43 <moop> how do i lookup namespaces?
05:53:10 <meretrix> How would you recommend designing automated tests for an application that is very dependent on internal timers and polling events and the timing of exogenous input.  Is there a framework for "controlling" the flow of time?
05:56:41 * hackagebot masakazu-bot 0.4.0.0 - @minamiyama1994_bot on haskell  http://hackage.haskell.org/package/masakazu-bot-0.4.0.0 (minamiyama1994)
05:56:58 <prinsen> In cabal, do I need to list library dependencies twice, under library target and executable target?
05:57:26 <dcoutts_> prinsen: yes, they're independent, though you can have one depend on the other.
05:58:17 <prinsen> dcoutts_: But if the executable depends on the library, It still forces me to add all dependencies of the modules it imports from the library
05:59:09 <dcoutts_> prinsen: no, the rule is that it must list all direct dependencies.
05:59:33 <prinsen> dcoutts_: Yes but the dependencie is the library, not all dependencies of that library
06:00:05 <dcoutts_> prinsen: your exe would depend on the library, plus whatever other direct deps it has, probably base and perhaps some other things
06:00:24 <prinsen> dcoutts_: When you add an external library to your dependiencies, you dont add all its dependencies recursively
06:01:26 <dcoutts_> prinsen: yes indeed, as I said *direct* dependencies and that's why your exe may have fewer (direct) deps than the lib, if it's depending on the lib
06:01:39 <prinsen> dcoutts_: I think its because one of the modules in the executable imports modules from the library, and as they reside in the same directory it uses that file rather than using the libraries exposed module
06:02:16 <dcoutts_> prinsen: yes, you need to adjust the directories and import path to have the exe depend on the lib, rather than picking up the source modules directly.
06:02:45 <prinsen> dcoutts_: Yes thats the behaviour I would expect, but I need to add the library, any direct dependencies and the dependencies of the modules imported from the lib
06:03:19 <prinsen> dcoutts_: ok how?
06:03:41 <dcoutts_> prinsen: once you have the exe depending on the lib, and not picking up the source modules directly, then you only need to list the lib as a dep, plus the other direct deps
06:03:55 <dcoutts_> prinsen: the hs-source-dirs field
06:05:48 <HairyDude> Is there a tool for displaying your project's module dependency graph?
06:06:01 <HairyDude> (not package dependency)
06:08:15 <HairyDude> brb
06:08:50 <prinsen> dcoutts_: Thanks!
06:09:02 <dcoutts_> np
06:22:36 <gallais> is there a way to have haskell realize that from `Eq1 f` and `Eq a` in context, `Eq (f a)` is derivable?
06:24:43 <bennofs> gallais: what is the Eq1 class?
06:24:59 <bennofs> gallais: the one from Data.Functor.Classes?
06:25:17 <gallais> http://hackage.haskell.org/package/prelude-extras-0.3/docs/Prelude-Extras.html
06:27:51 <Saizan> gallais: that's what Lift1 is about
06:29:02 <SwashBuckla> this is horrible. http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass
06:29:45 <SwashBuckla> essentially "let's mimic the truthiness of Javascript's boolean logic!"
06:29:52 <SwashBuckla> ohgodno
06:30:09 <exio4> it is a nice abuse of typeclasses just to show them
06:30:14 <exio4> not how to use them!
06:30:23 <proxfox> if I have a code like this http://pastebin.com/BcEmWTfd | can I expect lazy computation so that `el` is not computed if any of the checks before `el /= 'X'` evaluate to false? I'm using IOUArray.
06:30:32 <SwashBuckla> exio4: :P I know
06:30:59 <gallais> Saizan: does that mean that I need to pollute my datatype definitions with Lift1?
06:33:33 <proxfox> hmm, seems that it isn't lazy
06:37:29 <Fuuzetsu> there are too many non-empty list libraries, which do I use?
06:37:56 <bennofs> Fuuzetsu: semigroups?
06:37:57 <Plastefuchs> o/
06:38:40 <bennofs> btw, I found data Foo = Bar a [a] often much nicer to work with than data Foo = Bar (NonEmpty a)
06:38:54 <Fuuzetsu> ah, I was looking for that
06:38:56 <Fuuzetsu> thanks
06:41:46 * hackagebot xss-sanitize 0.3.5.4 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.4 (MichaelSnoyman)
07:05:11 <SwashBuckla> :k Functor
07:05:12 <lambdabot> (* -> *) -> Constraint
07:05:17 <SwashBuckla> what is "Constraint"?
07:05:36 <sipa> mGic
07:05:39 <sipa> magic
07:06:16 <SwashBuckla> (* -> *) is a Type Constructor that takes one parameter
07:06:23 <SwashBuckla> Constraint is...?
07:10:26 <Fuuzetsu> Great, I had a bug so I threw more types at it and now it is all fixed
07:10:30 <Fuuzetsu> hooray types \o/
07:11:02 <clrnd> Fuuzetsu, yay
07:11:25 <eacameron1> my impression is that STM is unfair, especially to consumers, am I right?
07:16:38 <frerich> eacameron : I'm not sure about the "especially to consumers" part, but my understanding is that it's true that STM doesn't guarantee fairness: it may well be that some transaction keeps getting interrupted and needs to be replayed.
07:17:03 <dgpratt> well it finally happened: last night I was asked: what is a Monad?
07:17:33 <dgpratt> so of course I explained that Monad is just a Monoid in the Category of Endofunctors
07:18:09 <frerich> eacameron : This is explained very nicely in the (highly recommended!) book 'Parallel and Concurrent Programming in Haskell' book. See http://chimera.labs.oreilly.com/books/1230000000929/ch10.html#sec_stm-whynot
07:18:12 <SwashBuckla> :k Functor
07:18:13 <lambdabot> (* -> *) -> Constraint
07:18:21 <SwashBuckla> What is Constraint?
07:18:24 <frerich> eacameron : Third paragraph in that section.
07:18:34 <SwashBuckla> (* -> *) is a Type Constructor that takes one Type Parameter
07:18:38 <SwashBuckla> I know that much
07:19:09 <bennofs> SwashBuckla: A constraint is the kind of something that appears to the right of (=>)
07:19:29 <bennofs> SwashBuckla: (Functor a) => ..., here Functor a is a constraint on a
07:19:36 <eacameron> frerich: thank you
07:19:47 <bennofs> :k Show (IO ())
07:19:49 <lambdabot> Constraint
07:20:02 <kuribas> Which ghc version do you use?  The ghc page recommends using the one from my distribution (mint), but I cannot compile ghcjs with it.
07:20:05 <SwashBuckla> :k (IO ())
07:20:05 <Fuuzetsu> nicer waya to write ‘killringA %= (\kr -> kr {krKilled=True})’?
07:20:06 <lambdabot> *
07:20:11 <Fuuzetsu> assume I have krKilled lens
07:20:14 <SwashBuckla> :k Show
07:20:15 <lambdabot> * -> Constraint
07:21:02 <bennofs> Fuuzetsu: killringA.hrKilledLens .= True ?
07:21:33 <Fuuzetsu> ah, that's nice
07:21:38 <dgpratt> in truth, I recall that SPJ described Monads as "a programmable semi-colon" or something to that effect, so I tried to go with that angle
07:21:43 <luite> kuribas: for ghcjs you should use 7.8.3
07:22:01 <luite> kuribas: the latest haskell platform has it
07:22:27 <clrnd> dgpratt, I remember when I finally understood them I thought "oh damn, semi-colons for real"
07:22:34 <dgpratt> :)
07:23:36 <dgpratt> I think a lot of explanations of monads function less as direct enlightenment and more as a litmus test for comprehension
07:23:48 <kuribas> luite: ok, so it's best to build ghc from source?
07:24:17 <bennofs> @where hp
07:24:17 <lambdabot> http://hackage.haskell.org/platform/
07:24:47 <frerich> dgpratt: That should get included into the newxt HWN :-)
07:25:11 <dgpratt> but I'm not worried, I told them about #haskell, so I imagine they'll be along and you all can straighten them out :)
07:25:51 <dgpratt> I also told them about ychim
07:31:44 <kuribas> bennofs: ok thanks.
07:32:43 <Fuuzetsu> krEndCmd kr = (krAccumulate .~ kr ^. krKilled) . (krKilled .~ False) $ kr
07:32:52 <Fuuzetsu> ^ kind of ugly, an nice operators I could employ?
07:32:55 <Fuuzetsu> aany*
07:32:56 <Fuuzetsu> any**
07:33:34 <Fuuzetsu> hm, guess not considering I need to have access to previous krKilled
07:34:53 <bennofs> Fuuzetsu: Maybe krEndCmd = execState $ do { krAccumulate <~ use krKilled; krKilled .= False)
07:35:46 <Fuuzetsu> :t (<~)
07:35:48 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
07:36:27 <bennofs> Fuuzetsu: a <~ b is like a <- b, but instead of assigning the variable 'a' to the value of b, it assigns to the lens 'a'
07:43:42 <glguy_> krEndCmd &~ do krAcc <~ use krKilled; krKilled .= False
07:45:28 <[LINKEDINLOGSRZA> WHAT PLANET ARE YOU ON? #NOTEARTH #2TAN2C #WUWEDNESDAY#INTELLIGENTLIFE IS RARE IN THE
07:45:28 <[LINKEDINLOGSRZA> COSMOS....https://www.youtube.com/watch?v=F_2tpeIm02E&list=RDF_2tpeIm02E#t=0
07:45:40 <rom1504> [LINKEDINLOGSRZA: MARS
07:45:53 <quchen> Please don't respond to spam.
07:46:15 <rom1504> yeah ok
07:48:28 <kgadek> let's say I have a list with a rather funny type: [([Int],[Int],Int)] . I'd like a function that would return ([Int], [Int], [Int]) by concatting first, concatting second and consing third fields. How to write that in a short way?
07:48:44 <quchen> bennofs: Is "use" like "ask", but for State?
07:48:51 <bennofs> quchen: yes
07:49:04 <bennofs> quchen: well, it also takes a lens as argument
07:49:16 <quchen> <~ always confuses me a bit, still decyphering that line
07:49:19 <Fuuzetsu> is there an operator for ‘uses’, I can't find one
07:49:27 <quchen> There is, just below "use"
07:49:29 <quchen> http://hackage.haskell.org/package/lens-4.3.3/docs/Control-Lens-Getter.html#v:use
07:49:54 <Fuuzetsu> I'm asking for an operator
07:50:00 <Fuuzetsu> oh wait, there's a section
07:50:03 * Fuuzetsu scrolls down
07:50:06 <quchen> Oh, missed that
07:50:20 <Fuuzetsu> hm nope, don't see it
07:50:35 <Btwelve> hi everyone
07:50:51 <bennofs> Fuuzetsu: I think an operator for uses feels weird
07:51:42 <bennofs> Fuuzetsu: you can do: x <- use $ lens . to functionYouWouldGiveToUses
07:51:43 <quchen> bennofs: So `krAccumulate <~ use krKilled` looks up the "krKilled" field value. What then? It sets that value in the State pointed to by krAccumulate? In other words, it copies krKilled over to krAccumulate?
07:51:53 <bennofs> quchen: yes
07:52:05 <quchen> Neat, thanks.
07:53:28 <Btwelve> ?
07:53:29 <[LINKEDINLOGSRZA> WHAT PLANET ARE YOU ON? #NOTEARTH #2TAN2C #WUWEDNESDAY#INTELLIGENTLIFE IS RARE IN THE
07:53:29 <[LINKEDINLOGSRZA> COSMOS....https://www.youtube.com/watch?v=F_2tpeIm02E&list=RDF_2tpeIm02E#t=0
07:53:37 <glguy_> view : ask :: use : get
07:54:02 --- mode: ChanServ set +o glguy_
07:54:13 --- mode: glguy_ set +b [LINKEDINLOGSRZA!*@*
07:54:41 <glguy_> On phone so my ability to make good bans is limited
07:55:32 <quchen> glguy_: Typing ban masks must be a pain.
07:55:58 <glguy_> Did I kick the spammer? I have join part turned off....
07:56:09 <doismellburning> glguy_: they were k-lined
07:56:17 <Btwelve> how can i be a programmer?
07:56:19 <glguy_> Thanks
07:56:26 <Fuuzetsu> Btwelve: just like, sit down and code
07:56:34 --- mode: glguy_ set -o glguy_
07:56:55 * hackagebot yesod-auth 1.3.4.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.2 (MichaelSnoyman)
07:56:58 <Rifuli> Btwelve, go look up some books on C++
07:57:02 <Rifuli> lol ^-^
07:57:08 * Rifuli hides
07:57:21 <Ankhers> Btwelve: What kind of programming do you want to do?
07:57:31 <Fuuzetsu> pointing the next person that comes in here to ask about OOP in Haskell to Rifuli
07:57:36 <Btwelve> i have c programming language book
07:57:43 <shapr> both kinds of programming, COUNTRY AND WESTERN ... wait, I mean functional and imperative!
07:57:45 <Rifuli> Ouch ;(
07:57:47 <Btwelve> kernighan ritchie
07:57:50 <Rifuli> I don't even know haskell
07:58:06 <Btwelve> I want to be hacker
07:58:08 <Rifuli> I came here from #freenode after some guy asks a spammer to be klined
07:58:08 <Rifuli> xD
07:58:13 <Rifuli> asked*
07:58:16 <Btwelve> Pentester
07:58:33 <shapr> Btwelve: have you tried learning Haskell? You will be a better programer after learning Haskell!
07:59:03 <quchen> There are lots of hackers around here, but chances are they don't do what you think hackers do and mistake them for crackers.
07:59:10 <shapr> quchen: I agree!
07:59:22 <Rifuli> Btwelve, to be a 'hacker' you must learn and understand the core mechanics of multiple programming languages in order to find loop holes
07:59:32 <Rifuli> It depends what kind of platform your trying to break in to
07:59:37 <Fuuzetsu> ’loop holes’?
07:59:45 <Ankhers> Rifuli: False
07:59:46 <shapr> yeah, the real meaning of the word "hacker" is "person who understands systems well"
08:00:00 <Rifuli> How is that false Ankhers ?
08:00:04 <Fuuzetsu> I can see this turning pretty stupid pretty soon
08:00:21 <Ankhers> a hacker isn't someone that tries to break into different systems.
08:00:24 <doismellburning> Fuuzetsu: from here it did already
08:00:27 <Rifuli> If you want to hack a website that's code in php, go learn php and perhaps some database language
08:00:35 <quchen> Wanting to become a hacker is like wanting to become a master swordsmith. It's not something you can start learning, it's something you maybe achieve after you've learned lots of other things before. "Hacker" is more like a title than a skill.
08:00:47 <Rifuli> If you want to call yourself a 'hacker', go learn it all
08:01:17 <Btwelve> i dont hack a web site
08:01:18 <Rifuli> Ankhers, a hacker does break in to systems, what the hell else does he do?
08:01:27 <Fuuzetsu> quchen: has my master swordsmithing teacher been lying to me all these years?!
08:01:29 <quchen> Build them. Hackers build things.
08:01:38 <Rifuli>  Programmers build things
08:01:41 <Rifuli> Hackers break them,.
08:01:53 <Rifuli> Hackers are programmers, for the most part.
08:01:56 * hackagebot yesod-form 1.3.15.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.15.2 (MichaelSnoyman)
08:01:57 <quchen> That's how it's portrayed in CSI.
08:01:58 <bernalex> what's the most nicest way to do this: I have a bunch of maybes (8). I want to check if one is a Just and the rest are Nothings.
08:01:59 * hackagebot MonadRandom 0.2 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.2 (BrentYorgey)
08:02:00 * hackagebot BlogLiterately 0.7.1.7 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.7 (BrentYorgey)
08:02:01 <quchen> This is not CSI.
08:02:08 <shapr> Btwelve: if you want to start learning Haskell, I'd recommend starting with https://github.com/bitemyapp/learnhaskell
08:02:09 <doismellburning> this _is_ #haskell unless I'm mistaken
08:02:11 <shapr> quchen: ENHANCE
08:02:33 <Fuuzetsu> :t maybes
08:02:33 <shapr> I will enhance the resolution of my program far beyond the limits of the input source code! CSI-style!
08:02:34 <lambdabot>     Not in scope: ‘maybes’
08:02:34 <lambdabot>     Perhaps you meant ‘maybe’ (imported from Data.Maybe)
08:02:35 <bernalex> Rifuli: I have hacker in my job title. I don't break things.
08:02:43 <quchen> shapr: destroyEntropy :: [[Int]] -> [[Int]]
08:02:47 <Rifuli> I don't understand how this has anything to do with CSI
08:02:52 <shapr> My job title is Software Suleiman
08:02:58 <kuribas> I am trying to compiler haskell-platform, but I get this: Warning: The following packages are likely to be broken by the reinstalls: shake-0.13.2
08:02:59 <Fuuzetsu> :t f x = length [ () | Just _ <- x ]
08:03:00 <lambdabot> parse error on input ‘=’
08:03:04 <joeyh> is there any way to mark a Handle as close on exec?
08:03:05 <Fuuzetsu> :t let f x = length [ () | Just _ <- x ] in f
08:03:06 <lambdabot> [Maybe t] -> Int
08:03:29 <Btwelve> i'm from turkey and i dont have courses about hack
08:03:33 <quchen> bernalex: I would write it myself as a fold.
08:03:40 <Btwelve> sorry for bad english
08:03:41 <Rifuli> bernalex, then I am truly lost.
08:04:03 <quchen> bernalex: Or using explicit recursion. Anyway, a handwritten thing that aborts if a second Just is found.
08:04:07 <shapr> Btwelve: but you can teach yourself! did you see the link I sent you?
08:04:12 * shapr hugs dysinger for being awesome
08:04:14 <bernalex> quchen: oh no I forgot to specify
08:04:23 <bernalex> quchen: it's one *specific* of the maybes that should be Just
08:04:27 <joeyh> ah, found setFdOption CloseOnExec although I suppose it won't work on windows
08:04:37 <Btwelve> shapr, no i didn't. Please send again
08:04:41 <dfeuer> Rifuli, pop culture insists on conflating hackers with crackers, but that doesn't mean we will do so here.
08:04:44 <shapr> Btwelve: https://github.com/bitemyapp/learnhaskell
08:04:49 <dysinger> shapr: not awesome enough.  I know nothing.  I am just curious. ;)
08:04:49 <bernalex> so I have 8 maybes, and if a specific one of them is Just while the other are Nothing, then bleurgh
08:04:55 <quchen> bernalex: So you want a function that checks whether there is a "Just _" at the n-th position of a list, and everything is Nothing
08:04:59 <quchen> +else
08:05:00 <Btwelve> thank you
08:05:13 <shapr> dysinger: I always say that I'm awesome as long as I've done something awesome this week, but I haven't yet :-(
08:05:21 <bernalex> quchen: I guess I could construct the list to check if the 0th is Just, and if so, check that everything in the tail is Nothing
08:06:18 <quchen> bernalex: What about using split+find? Split on Just, find other Just in rest
08:06:18 <bshmatthews> shapr: you have a few days left!
08:06:31 <rrradical> So, there's a sortWith function that uses sortBy under the hood, but if the supplied comparison value function is expensive, then there are redundant expensive calculations. Is there a function that precalculates the comparison values before sorting? And if not, why not?
08:06:31 <bernalex> I could just do case (a, b, c, d...) of (Just something, Nothing, Nothing, Nothing,...) -> bleurggh; _ -> blorb
08:06:38 <shapr> dysinger: oh wait! matt might put some of my advice in one of his articles two days ago, so maybe I am awesome things week
08:06:41 <quchen> :t split isJust [Nothing, Nothing, Just 3, Nothing, Nothing]
08:06:42 <lambdabot>     Couldn't match expected type ‘Splitter (Maybe a)’
08:06:42 <lambdabot>                 with actual type ‘Maybe a0 -> Bool’
08:06:42 <lambdabot>     Probable cause: ‘isJust’ is applied to too few arguments
08:06:43 <shapr> s/things/this
08:06:49 <croyd> bernalex: you could put them in a list and use catMaybes
08:06:57 <bernalex> croyd: that was my initial thought
08:07:23 <bennofs> rrradical: i think there was a discussion about adding it
08:08:22 <rrradical> bennofs: I actually can't think of a reason why the existing behavior would be preferable
08:08:34 <shapr> well, maybe btwelve will return with Haskillz
08:08:39 <kgadek> …if anyone's interested: i found *some* solution to [([X],[Y],Z)] -> ([X], [Y], [Z]), ie: (psasts^..traverse._1 & concat, psasts^..traverse._2 & concat, psasts^..traverse._3)
08:08:44 <shapr> bshmatthews: have you done anything awesome this week?
08:08:53 <kgadek> not shortest, so any comment appreciated
08:09:25 <quchen> bernalex: Anyway, I don't think there's a standard function for this, and you won't have trouble writing an implementation by hand.
08:09:29 <hexagoxel> bernalex: \xs i -> and $ map _todo_ $ zip [0..] xs
08:10:44 <bennofs> rrradical: http://www.haskell.org/pipermail/libraries/2014-April/022489.html
08:11:09 <rrradical> bennofs: thanks!
08:11:14 <frerich> kgadek: Not sure whether that's an improvement over'\[(a, b, c)] -> (a, b, [c])' :-}
08:11:54 <bernalex> the stupid solution I did initially was like
08:11:56 <bernalex> > let xs = [Just 5, Nothing, Nothing] in (isJust . head) xs && not (all (isJust) $ tail xs)
08:11:58 <lambdabot>  True
08:12:13 <quchen> That is somewhat unreadable.
08:12:20 <kgadek> frerich: yeah but I need to concat multiple elems from list, not only asssert the list has length == 1
08:12:26 <bernalex> I don't think it's unreadable even if not true
08:12:28 <bernalex> eh
08:12:31 <bernalex> s/true/nice
08:13:28 <kgadek> frerich: another valid solution is `foldr (\(a,b,c) (x,y,z) -> (a:x, b:y, c:z)) ([],[],[]) psasts` but that's not prettiest too
08:14:00 <kgadek> frerich: oops, I meant: `foldr (\(a,b,c) (x,y,z) -> (a++x, b++y, c:z)) ([],[],[]) psasts`
08:15:49 <bshmatthews> shapr: Nope, still working on it. Trying to make a website with elm, that might be awesome!
08:15:57 <shapr> whoa, that would be awesome!
08:19:47 <quchen> bernalex: This is what I would call a readable implementation. http://lpaste.net/109698
08:19:49 <quchen> (Untested.)
08:22:00 * hackagebot one-liner 0.4 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.4 (SjoerdVisscher)
08:32:01 * hackagebot creatur 5.6.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.2 (AmyDeBuitleir)
08:32:24 <bennofs> I wonder, what are the advantages of running ghc-modi instead of plain ghci? ghci has the advantage that it can also be used as a REPL, and it can also do syntax checking and type info
08:32:38 <prophile> "data Salary = S Float"
08:32:52 <bennofs> :o
08:32:57 <prophile> I feel slightly ill
08:33:29 <quchen> You mean for using Float?
08:34:04 <prophile> for currency
08:34:14 <prophile> its not being a newtype is merely perplexing
08:35:09 <quchen> I don't think salaries leave the precision of Double, what's the problem?
08:35:36 <quchen> Are you trying to promise your users a raise of factor epsilon every second or something? :-þ
08:35:37 <frerich> quchen: Not sure I understood the task, but I added an annotation to http://lpaste.net/109698 with an alternative solution
08:35:53 <prophile> quchen: funnily enough percentage-based raises is exactly what that code snippet comes from ;)
08:36:00 <prophile> https://github.com/sjoerdvisscher/one-liner/blob/master/examples/paradise.hs
08:36:07 <quchen> Oh. Well I'll be quiet :-D
08:36:20 <prophile> hackagebot caught my eye
08:37:17 <quchen> frerich: That's a short solution, but I don't think it terminates if a Just is found before the desired position.
08:37:32 <kvelicka> is there a way to throw a GHC warning if one of the patterns of a guard gets evaluated?
08:37:54 <bennofs> kvelicka: you mean run-time ?
08:37:58 <kvelicka> yes
08:38:00 <quchen> Guards don't have patterns. Do you mean if a guard is evaluated?
08:38:04 <quchen> kvelicka: You can use Debug.Trace to do that.
08:38:16 <bennofs> quchen: PatternGuards! :D
08:38:28 <monochrom> use Debug.Trace.trace on the right side of =
08:38:29 <frerich> quchen : Oh you mean, the task was to have a function which doesn't force the spine up to 'n' if a Just was found before that? I see, a classical case of "Did not read the problem all the way to the end", I guess, oops :-)
08:38:29 <nshepperd> kgadek: \k -> (concatMap _1 k, concatMap _2 k, map _3 k) with appropriate definitions of _1, _2, _3?
08:38:53 <quchen> frerich: The task was "Check whether the n-th element of a list is the only 'Just' value.", at least that's how I understood it.
08:39:27 <kvelicka> quchen: yes, that's what I mean. Is there another way? This will go to a library soon and I would like to avoid keeping debug functions in there
08:39:38 <bernalex> quchen: considering I could construct my list however I wanted to, I would just put the one I wanted to be Just at the head
08:40:02 <bernalex> & what I did was "f (x:xs) = isJust x && (not . any (isJust) $ xs)", which you found ugly. personally, I don't think it's *that* bad.
08:40:02 <quchen> kvelicka: You should not throw errors/warnings from pure functions.
08:40:18 <quchen> kvelicka: If it's what you want to do you're going dirty, and Debug.Trace is for doing dirty things.
08:40:34 <kvelicka> quchen: fair enough :)
08:40:39 <quchen> not . any isJust == all isNothing
08:40:39 <monochrom> you want a warning to happen from a library?!
08:40:44 <bennofs> kvelicka: it's easy to just grep for trace before release
08:40:57 <bernalex> quchen: yeah I was just about to post that I just realised there was an isNothing too :-]
08:41:21 * quchen always writes his own Trace module that reexports tracing functions. Delete the module in the production branch, get errors if you left traces of Trace in there.
08:41:34 <hexagoxel> :t \i xs -> all (\(j,k) -> (i==j)==isJust k) $ zip [0..] xs
08:41:36 <lambdabot> (Num a, Eq a, Enum a) => a -> [Maybe a1] -> Bool
08:41:40 <bernalex> so it's just
08:41:42 <bernalex> f (x:xs) = isJust x && all isNothing xs
08:41:47 <prophile> clearly one should write all code in the IO monad
08:41:59 <prophile> that way you don't need hax for trace!
08:42:02 * hackagebot binary-list 0.3.0.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.0.0 (DanielDiaz)
08:42:02 <quchen> f (Just _:xs) = all isNothing xs; f _ = False
08:42:12 <int-e> > let f xs n = [n] == catMaybes (zipWith (fmap . const) [0..] xs) in f [Nothing, Just 42, Nothing] 0
08:42:13 <bernalex> ah true
08:42:14 <lambdabot>  False
08:42:18 <DanielDiaz> when I modify .cabal/config and set "optimization: true". Does this mean compiling with -O1 or -O2?
08:42:33 <bennofs> DanielDiaz: -O1 iirc
08:42:37 <kvelicka> monochrom: the library does parsing and there are some things that should not happen normally, but might. I'd like to warn the user about that
08:42:47 <monochrom> write all code in generalized MonadIO, too. that way you can't handle exceptions, either. :)
08:42:50 <quchen> DanielDiaz: -O2 is generally not recommended, Cabal even complains about it when you cabal check" I believe.
08:42:51 <kgadek> nshepperd: well yes, but as far as I can see I'd need to define _1, _2, _3
08:42:55 <bernalex> f = ap ((. all isNothing) . (&&) . isJust . head) tail -- :-P
08:43:09 <int-e> > let f n = ([n] ==) . catMaybes . zipWith (fmap . const) [0..] in f 1 [Nothing, Just 42, Nothing]
08:43:11 <lambdabot>  True
08:43:20 <barrucadu> monochrom: Nah, you can just do dirty things and liftIO them :p
08:43:22 <bennofs> kgadek: and not fail hard?
08:43:26 <DanielDiaz> quchen, bennofs: OK. Any chance to make it -O2 by default?
08:43:38 <DanielDiaz> I think to remember that was possible
08:43:42 <quchen> I don't think so. It would probably not be a good idea anyway.
08:43:42 <prophile> monochrom: I was only joking of course
08:43:44 <hexagoxel> bernalex: my solution also does stop at the first wrong Just/Nothing
08:43:52 <DanielDiaz> ok
08:43:55 <quchen> -O2 takes much longer to compile, and "rarely" leads to performance benefits.
08:43:58 <prophile> every one knows that maintainable code eschews do-notation and just passes RealWorld# around directly
08:44:11 <quchen> DanielDiaz: -O2 is only recommended when you actually know it's useful.
08:44:13 <bernalex> hexagoxel: O(n) is acceptable when n=8 TBH
08:44:32 <quchen> Because then it's O(1).
08:44:33 <DanielDiaz> quchen: ok then. will proceed with -O1
08:44:43 <DanielDiaz> thank you
08:45:13 <int-e> oh, (fmap . const) = (<$)
08:45:42 <monochrom> kvelicka: IMO your parser function should have codomain Either ParseError GoodResult, and have no right performing I/O behind the user's back.
08:47:21 <monochrom> especially since, in this context, "user" does not mean an end user, but rather another programmer who ought to have the final say on where warnings go
08:47:59 <kvelicka> monochrom: I see, fair enough
08:48:00 <quchen> Maybe I should add a "don't use error" section to the FBUT.
08:48:25 <kvelicka> FBUT?
08:48:42 <kgadek> nshepperd: ok, I can get away with `(concatMap (^. _1) k, concatMap (^. _2) k, k^..traverse._3)`
08:48:44 <quchen> That https://github.com/quchen/articles/blob/master/fbut.md
08:49:05 <spott> hey, how do I set it so all sandboxes put their haddock and hoogle documentation in the same place (.caba/share/docs/...)
08:50:41 <nshepperd> kgadek: looks pretty hard to golf it down further, since the accessors need to be fmapped
08:51:53 <kvelicka> @quchen looks like a valuable resource, cheers
08:51:54 <lambdabot> Unknown command, try @list
08:52:46 <kgadek> nshepperd: well, I hoped I could easily apply ((++),(++),(,)) to list but failed to do that
08:55:27 <kvelicka> quchen: so using error is a bad choice in almost all cases, correct?
08:56:14 <quchen> kvelicka: Yes.
08:56:28 <quchen> kvelicka: "error" should *never* be used to report errors.
08:56:36 <quchen> I mean user errors.
08:56:41 <c_wraith> I use error to indicate programmer error (ie, misuse of an api)
08:56:53 <c_wraith> But not for any expected error condition
08:57:01 <quchen> c_wraith: Right, such as calling foldl1 on an empty list.
08:58:06 <c_wraith> though it's nice to always consider if something can be done at the type level to prevent api misuse instead
08:58:31 <kvelicka> what about using it for say pattern matches that should never happen? is there a cleaner way to cover those cases?
08:58:55 <c_wraith> kvelicka: I do that, too.  I never feel good about it, but I do it sometimes.
08:59:29 <quchen> When they should never happen, you should a) make sure that they don't, b) warn users in a comment, c) possibly not even export the offending function.
08:59:53 <quchen> Using "error"-ing functions is fine as long as the error is never called.
09:00:27 <c_wraith> fortunately, recent GHC actually has the ability to provide stack traces from an error - if the program was compiled with profiling active.
09:00:30 <quchen> Canonical example:
09:00:31 <quchen> > (map head . group) [1,1,1,2,2,2,2,3,4,4,4,5,6,6]
09:00:33 <lambdabot>  [1,2,3,4,5,6]
09:01:14 <c_wraith> That makes running into one of those "this should never happen" situations less painful
09:01:54 <clrnd> kgadek, why not let whatever f1 f2 f3 = foldr (\(a,b,c) (x,y,z) -> (f1 a x, f2 b y, f3 c z)) ([], [], [])
09:02:44 <c_wraith> clrnd: that might be too strict
09:03:02 <kgadek> clrnd: you mean foldr (\(a,b,c) (x,y,z) -> (a++x, b++y, c:z)) ([],[],[])
09:03:03 <kvelicka> quchen: fair enough. I know for a fact that it will never be the case (the pattern I'm matching on doesn't ever return the offending value. I'll put in the comment and making a separate datatype for just this one instance doesn't seem to make sense.
09:03:03 <kgadek> ?
09:04:21 <clrnd> kgadek, no, then you can do > whatever (++) (++) (:) xs
09:05:16 <kgadek> oh ok. yet this is used only once and I thought how to do that cleanly :)
09:06:16 * dfeuer faces his NemesisD.
09:08:08 <djahandarie> Thankfully you can just kill -9 your nemesisd.
09:09:49 <TallerGhostWalt> I thik haddock's logo should use this http://www.shutterstock.com/pic-167615801/stock-vector-hand-drawn-illustrations-of-atlantic-cod.html?src=df7pJhfQ3EKvApk_md68RQ-1-0
09:10:50 <TallerGhostWalt> stylized with a lambda gill
09:12:06 * hackagebot force-layout 0.3.0.6 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.6 (bergey)
09:13:56 <NemesisD> djahandarie: sorry. what's happening?
09:14:41 <NemesisD> or rather dfeuer: did I do something?
09:15:06 <dfeuer_> djahandarie, that's not the preferred way to exorcise daemons under systemd.
09:15:18 <dfeuer_> No, NemesisD, but your name invites literal interpretation.
09:16:21 <dfeuer_> nemesis ~= enemy. Thing ending in "d" suggests Unix daemon.
09:16:43 <NemesisD> lol. i'm afraid this is a case of chose-an-irc-nick-when-i-was-13
09:16:47 <dfeuer_> Which djahandarie was clever enough to see had potential.
09:17:37 <zomg> I was banned from a channel because apparently "zomg" has something to do with satan
09:17:42 <dcoutts_> DanielDiaz: I think it is possible to set -O2 in the ~/.cabal/config file
09:18:07 <dcoutts_> DanielDiaz: certainly it's possible on the cabal configure/install command line, via -O0 -O1 -O2
09:18:29 <DanielDiaz> dcoutts_: I think I have done it in the past, that's why I asked here. But I don't remember how, or if it was just an illusion.
09:18:38 <dcoutts_> DanielDiaz: it's fine for the person building the package to use -O2, it's just that we discourage authors from doing this, since it's not a sensible default.
09:19:53 <hodapp> zomg: Um. What?
09:19:57 <DanielDiaz> dcoutts_: I understand. I just don't mind getting a little longer compilation time for a chance of a possible optimization in some package I am compiling.
09:20:07 <dfeuer_> dcoutts, do you think you have a bit of time to help me troubleshoot cons/build?
09:20:12 <dfeuer_> It's driving me bonkers.
09:21:16 <dfeuer_> fread2282, shouldn't that be fread(3)?
09:21:37 <zomg> hodapp: my thoughts exactly... It was a very strange moment :D
09:21:45 <fread2282> dfeuer_: no?
09:22:17 <dfeuer_> fread2282, I'm referring to the C function fread, which appears in book 3 of the Unix manual.
09:23:05 <fread2282> dfeuer_: yea, but my username isn't after fread
09:24:01 <dfeuer_> DanielDiaz, another thing that doesn't seem like a sensible default actually *is* GHC's default, which is why I'm going to try to make a case for making -fsimple-list-literals the default.
09:25:21 <dfeuer_> OK, peeps, who wants to play RULES? I'm trying to track down how a rule that's supposed to help create more list fusion opportunities actually increases allocation in some benchmarks.
09:26:06 <arianvp> cabal yells this at me when installing yesod:
09:26:07 <arianvp> cabal: The following packages are likely to be broken by the reinstalls:
09:26:08 <arianvp> ghcjs-0.1.0
09:26:08 <arianvp> warp-3.0.0.4
09:26:14 <arianvp> can I just safely force-reinstall?
09:26:42 <arianvp> or build yesod-bin in a sandbox?
09:27:06 <dcoutts_> arianvp: you can fore reinstall, and those two packages will become unusable (until you re-install them)
09:27:09 * hackagebot yesod-bin 1.2.12.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.4 (MichaelSnoyman)
09:27:10 <luite> arianvp: those packages will be unusable afterwards
09:27:22 <luite> arianvp: but for ghcjs you usually don't need the library
09:27:44 <dfeuer_> dcoutts_, did you see my heartfelt plea?
09:27:55 <dfeuer_> Or luite, for that matter?
09:28:39 <carter> proxfox: @google ghc profilling tools
09:28:44 <carter> @google ghc profiling tools
09:28:45 <lambdabot> https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/profiling.html
09:28:51 <carter> proxfox: theres some AMAZING tools there
09:29:11 <dcoutts_> dfeuer_: about rules and fusion? sorry, no time to help now
09:29:39 <luite> dfeuer_: i'm not too good with RULES myself either, i still need to add quite a few to avoid unnecessary conversion in ghcjs libs, i tried before but didn't quit get as far as i wanted
09:29:53 <dfeuer_> carter, I think you likely meant that for me. How do you compile NoFib for profiling?
09:30:05 <carter> dfeuer_: no, not you
09:30:06 <carter> proxfox:
09:30:36 <proxfox> carter: I'll check them out...
09:30:42 <carter> dfeuer: also you always @ me on ghc matters ! (i'm flattered, but aside from being responsive, i'm otherwise the least qualified person to help :) )
09:30:43 <sm> arianvp: probably you can add those packages to your yesod install command, or reinstall them later
09:30:47 <dcoutts_> dfeuer_: ping me in #ghc tomorrow
09:30:51 <dfeuer_> luite, the problem isn't (apparently) with he rules themselves, which fire, but rather with some unexpected and unidentified interaction they have with something else.
09:30:55 <carter> dfeuer: you should ping dcoutts_  on this stuff honestly
09:30:59 * dcoutts_ knows a thing or two about using rules
09:31:00 <carter> he's literally the world expert
09:31:04 <dfeuer_> Thanks, dcoutts_!
09:31:15 <dcoutts_> carter: 'a', not 'the'
09:31:54 <carter> dfeuer: secret to getting dcoutts_  help is to ask :)
09:32:03 <dfeuer_> carter, since you're a big benchmark fan, I discovered that the rules that are doing unexpected harm in some places actually do major good for the "wang" benchmark, cutting allocation in half.
09:32:20 <luite> dfeuer_: ah right
09:32:29 <dfeuer_> And doing much good for runtime, it seems, although I DO NOT trust my timings at all.
09:33:06 <dfeuer_> [but only with -fsimple-list-literals]
09:34:14 <dfeuer_> Can someone remind me which file has the default flags? I want to check nofib if I make -fsimple-list-literals the GHC default.
09:34:29 <carter> dfeuer: could you collect your questions into one big list
09:34:32 <carter> with bullet points
09:34:36 <carter> then email ghc-devs about them
09:34:40 <carter> rather than spreading it thin?
09:34:56 <dfeuer_> *sigh*
09:35:01 <luite> actually i need to look into RULES even more if i want some template stuff work fast without template haskell or supercompilation
09:36:47 <spott> hey, is there a way to export documentation from a sandbox to a central location?  AND to link it together (like haddock does if you don't use sandboxes)?
09:38:38 <quchen> spott: I don't think that's a good idea. What happens when you install multiple different versions of packages in different sandboxes?
09:38:50 <quchen> What if you delete a sandbox, something that many people do quite often.?
09:39:57 <proxfox> carter: well, I've profiled a bit before, and replaced the array with 2 bytestrings, now, my solution is about 15 times faster than c++ one... I guess c++ needs some work :D
09:41:16 <spott> quchen: It should be versioned (which I'm pretty sure it is), and if I delete the sandbox, the documentation should survive
09:44:31 <quchen> spott: I wonder what rebuilding the doc index does in that case. Is the deleted library silently forgotten?
09:45:04 <spott> sure... or removed...
09:46:24 <cow_2001> any hakyllers?
09:46:41 <spott> I use Dash (for os X) and haddockset, and I would love to have source view and hyperlinking between sources for sandboxed libraries
09:48:48 <njcomsec> how do i create objects ?
09:55:16 <c_wraith> njcomsec: what do you mean by "object"? If you mean values of your custom data type, you use a constructor you defined as part of the type.  Otherwise..  it depends on what you mean
09:57:35 <monochrom> I think it's pretty safe to equate object = value. heap object is implementation-speak for value.
09:58:13 <napping> monochrom: there are some funny heap objects
09:58:21 <dfeuer_> Objects typically have identity, whereas values do not.
09:59:32 <mroman> so...
09:59:38 <mroman> I can't have
09:59:58 <mroman> foobar a b binop = a `binop` b
10:00:05 <mroman> if a and b aren't always the same type?
10:00:16 <mroman> like
10:00:24 <tac> object and value are just words, man.
10:00:25 <c_wraith> mroman: sure you can.  You just need to put a type signature on foobar
10:00:33 <mroman> foobar (MyInt a) (MyInt b) binop = a `binop` b
10:00:43 <tac> It's their denotation that matters. (Or operatational semantics, if you're one of THOSE people)
10:00:45 <mroman> foobar (MyDouble a) (MyDouble b) binop = a `binop` b
10:00:51 <c_wraith> mroman: oh.  that changes things.
10:01:15 <c_wraith> mroman: pattern-matching a constructor does, in fact, restrict the type of that argument to only things that have that constructor
10:01:35 <mroman> ok
10:01:39 <mroman> That means I cant have
10:01:46 <c_wraith> mroman: oh!!  I see what you mean.  Hold on.
10:01:48 <mroman> fooAdd a b = foobar (+)
10:02:00 <mroman> fooMul a b = foobar a b (*)
10:02:00 <c_wraith> mroman: you can do that, but it requires a language extension
10:02:39 <carter> spott: https://hackage.haskell.org/package/mono-traversable-0.6.1/docs/Data-MonoTraversable.html is a thing
10:02:44 <carter> just not always worth ti
10:02:58 <c_wraith> mroman: for instance, foobar :: MyNum -> MyNum -> (forall a. Num a => a -> a -> a) -> MyNum
10:03:01 <carter> spott: if you look
10:03:07 <carter> you'll see its LESS generic than what you want
10:03:08 <carter> omap :: (Element mono -> Element mono) -> mono -> mono
10:03:17 <mroman> http://lpaste.net/109708
10:03:20 <mroman> ^- c_wraith
10:03:26 <mroman> that's my current code
10:03:32 <glguy> If you're already using lens, Each is your "monotraversable" replacement
10:03:44 <mroman> so instead of copy'n'paste that code and change (a + b) to (a * b), (a / b), (a - b) ...
10:03:52 <mroman> i'd want to "refactor" that a little
10:04:18 <c_wraith> mroman: right.  The key to what you're doing is that you want to pass a *polymorphic* function
10:04:40 <mroman> Isn't (+) already polymorphic enough?
10:04:43 <carter> spott: point being mono-traversable is the closest large thing like what you want, but its less generic than what you want
10:04:55 <mroman> @type (+)
10:04:56 <lambdabot> Num a => a -> a -> a
10:05:18 <c_wraith> mroman: it is polymorphic, yes.  But it doesn't stay polymorphic when it's used as an argument to another function.
10:06:12 <c_wraith> mroman: that's because in base haskell's type system, function arguments can't be polymorphic.
10:06:32 <c_wraith> mroman: they have to be fixed at *some* type, even if what exactly that type is isn't known yet.
10:06:55 <c_wraith> mroman: but you're actually asking for a function that can work on Double or Int, and it will decide which at runtime.
10:07:20 <spott> carter: it looks to be pretty much what I was looking for
10:07:24 <joelteon> according to reddit, /r/haskell is the #3 least sweariest programming subreddit. good job guys
10:07:26 <mroman> well
10:07:27 <carter> spott: nope
10:07:28 <mroman> c_wraith: no
10:07:29 <carter> its less generic
10:07:31 <carter> read the types
10:07:37 <mroman> It should be bound at compile time
10:07:40 <carter> the input and output types for the map need to be the same
10:07:45 <c_wraith> mroman: Fortunately, GHC has a language extension that allows you to say "I want this argument to be a polymorphic function"
10:07:47 <carter> a->a is a pretty boring type
10:07:47 <mroman> the only run time thing is which branch of case to take?
10:07:56 <c_wraith> mroman: it can't be.  Int and Double aren't the same type.
10:08:00 <spott> carter: ah...
10:08:01 <spott> yea
10:08:02 <mroman> yeah
10:08:02 <mroman> but
10:08:04 <spott> it is
10:08:14 <mroman> (OfInt b : OfInt a) -> ... a `binop` b
10:08:16 <carter> but you can't do anything stronger :)
10:08:28 <mroman> ^- this should give a compiler enough information to know at compile time that this is the binop that works on ints
10:08:51 <spott> why can't you do (Unboxed a, Unboxed b) => (a -> b) -> (f a -> f b)....
10:08:54 <c_wraith> mroman: it does.  but in another branch, you say that the binop works on Doubles
10:08:54 <mroman> looks like it works with -XRankNTypes
10:08:59 <spott> ?
10:09:01 <mroman> c_wraith: yeah. so?
10:09:14 <mroman> Other languages have "overloading" at compile time
10:09:14 <c_wraith> mroman: so, Int and Double aren't the same type.  That's a type error.
10:09:34 <mroman> oh
10:09:35 <mroman> wait
10:09:41 <mroman> right
10:09:49 <mroman> compiler doesn't know what function I pass
10:09:52 <mroman> :)
10:10:04 <spott> that is just completely as generic as possible/usefull
10:10:12 <c_wraith> mroman: like I said, there is a languag extension to support this.  And yes, it's RankNTypes
10:10:36 <c_wraith> mroman: RankNTypes allows you to specify that the argument being passed in must be polymorphic, and keep it polymorphic.
10:11:09 <glguy> spott: You can, the monotraversable class just doesn't expose that
10:11:29 <spott> glguy: what does?
10:12:12 <mroman> c_wraith: Yeah. It works with RankNTypes
10:12:16 <mroman> Thanks for your help.
10:12:23 <mroman> Now I don't have to copy the function 8 times ;)
10:12:25 <c_wraith> mroman: a very useful way to look at this is that in normal (rank 1) polymorphism, the function's caller gets to choose what all of the type variables are.
10:12:37 <glguy> spott: Either use functions in the Data.Vector modules, or using lens's Each class you can do it more generically: over each Data.Char.chr (fromList [1,2,3] :: Data.Vector.Unboxed.Vector Int) :: Data.Vector.Unboxed.Vector Char
10:12:52 <c_wraith> mroman: But with rank 2 polymorphism, which is what you're using, the function being *called* gets to choose what the type variables are
10:19:46 <timmy_tofu> Is there a better pattern than f x >>= return . sequence_ [g, h] for f x >>= \y -> do { g x; h x; } ? I don't think I've improved things using the former
10:20:17 <timmy_tofu> errr fx >>= \y -> do {g y; h y; }
10:20:28 <Kyshy> what is that ^^
10:20:51 <glguy> do { y <- fx; g y; h y}
10:21:03 <timmy_tofu> apply several a -> m () to the same a
10:21:05 <mroman> c_wraith: as long as the performance isn't terribly worse....
10:21:25 <mroman> not that I care
10:21:30 <timmy_tofu> glguy: Yeah, there's that. Not sure if I've saved anything
10:21:35 <mroman> otherwise I wouldn't use lookup but a real HashMap of some sort
10:21:42 <c_wraith> mroman: in general, performance won't change at all.
10:21:44 <glguy> You should just write it normally, it'll be easier to read
10:22:42 <glguy> you can also do { x <- fx; traverse_ ($ x) [g,h,i,j...] } or something, if you have a variable list of stuff to do with the argument
10:22:51 <glguy> but that's not inherently better
10:22:56 <mroman> c_wraith: hm
10:23:01 <mroman> let's push this one further
10:23:02 <mroman> can I
10:23:06 <mroman> pass a type as an argument?
10:23:30 <mroman> let's say I have a builtinUniOp
10:23:30 <c_wraith> mroman: Not in haskell.  That requires dependently-typed languages.
10:23:39 <mroman> that should work for unary operations
10:23:43 <mroman> that may have a concrete type
10:23:51 <mroman> like Bool -> Bool for NOT
10:24:06 <mroman> so I can use builtinUniOp (not) Bool
10:24:10 <timmy_tofu> I thought about traverse, but again didn't seem to be saving anything. Maybe there's no better way, save perhaps naming return . sequence_ into something semantically jaunty for the case at hand
10:24:11 <napping> c_wraith: System F is enough to be getting types as arguments
10:24:16 <mroman> instead of copy the function for every type
10:24:40 <athan> Hey guys, so if `callcc` takes a function and applies the current context to it, forgetting the context and returning with the environment returned by the function, that would be a normal continuation, no? Would a delimited continuation remember the context?
10:25:31 <mjrosenb> Is there samething like MArray, but where I don't need to give it a definite size when I initialize it?
10:25:57 <napping> athan: callcc grabs the whole context, delimited continuations grab the context up to some delimiter
10:25:57 <mroman> theoretically I don't need the "runtime" really
10:26:06 <mroman> I.e. if something behind the scenes just created the required code
10:26:12 <mroman> that would work as well :)
10:26:15 <athan> napping: Ahh, okay. Thanks :)
10:26:35 <mroman> i.e. builtinBinOp (+) would generate a function builtinAdd which copies code from a template
10:26:43 <mroman> and then builtinBinOp (+) is replaced with builtinAdd
10:26:45 <napping> athan: the remaining variation is mostly about what context the function call itself runs in
10:27:16 <mroman> However, I strongly assume that this code generation thing takes more effort than what I do now
10:27:29 <mroman> (*would take more effort)
10:28:15 <athan> napping: Hmm, that's a really different way of thinking for me. But still cool :)
10:28:32 <napping> like whether it's trimmed back to the prompt or left alone, and also whether the context you grabbed includes a prompt
10:28:43 <napping> includes the prompt, rather
10:35:13 <kuribas> Does lazyness have an effect on performance?
10:35:26 <kuribas> I would think a lazy language is a bit slower than a strict one...
10:35:47 <kuribas> But some things are easier to express with lazyness.
10:36:35 <bandbaz> Hi,
10:36:55 <mroman> Only thing I know is that lazyness can yield to a huge amount of memory requirement
10:37:00 <c_wraith> kuribas: laziness has some overhead, yes
10:37:11 <mroman> if you do it the obvious, human-readable way ;)
10:37:18 * hackagebot aws 0.10.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10.3 (AristidBreitkreuz)
10:38:05 <c_wraith> I mean, just something like (a + (b + c)) is slower as a lazy calculation than as a strict one.
10:38:22 <profil> @pl \x -> - ord 'A' + 1 + ord x
10:38:22 <lambdabot> (line 1, column 7):
10:38:22 <lambdabot> unexpected "-"
10:38:22 <lambdabot> expecting lambda abstraction or expression
10:38:46 <mjrosenb> will ghc optimize let (x,y) = (minimum l, maximum l) int oa single list traversal?
10:38:51 <funnybutton> what would make this program work? http://vpaste.net/u3I1A
10:39:04 <kuribas> c_wraith: ghc will optimise that using stricness analysis.
10:39:08 <c_wraith> mjrosenb: not usually.
10:39:24 <c_wraith> kuribas: yes.  And it does that *because* laziness has performance overhead.
10:40:44 <funnybutton> c_wraith: would you please check my program?
10:40:50 <profil> @pl \x -> -ord 'A' + 1 + ord x
10:40:50 <lambdabot> (line 1, column 7):
10:40:50 <lambdabot> unexpected "-"
10:40:51 <lambdabot> expecting lambda abstraction or expression
10:41:12 <profil> @pl \x -> 1 - ord 'A' + ord x
10:41:13 <lambdabot> ((1 - ord 'A') +) . ord
10:41:20 <Freundlich> 'sum' is a good example of laziness making things slow.
10:41:21 <mjrosenb> c_wraith: not unusually, as in it usually does this optimization?
10:42:37 <c_wraith> mjrosenb: GHC should always optimize that when it knows the type of the expression.
10:43:08 <mjrosenb> c_wraith: sweet.
10:43:19 <c_wraith> mjrosenb: err, sorry, got my wires crossed.  It'll only optimize that if something crazy is going on.
10:43:33 <c_wraith> mjrosenb: like you've imported a ton of RULES from somewhere.
10:43:59 <dfeuer_> Why's that, c_wraith?
10:45:32 <mjrosenb> c_wraith: blast.
10:45:41 <c_wraith> dfeuer_: iirc, GHC doesn't have the tools necessary to combine parallel folds into a single fold cleanly.
10:45:55 <mjrosenb> c_wraith: so either I should read up on rules, or I should write it as a single fold myself.
10:46:14 <mjrosenb> also, I've heard reads isn't exactly fast.
10:46:15 <c_wraith> mjrosenb: the latter is the only good mechanism at the moment
10:46:37 <mjrosenb> if I want to convert a hex string to a Word, should I roll my own?
10:46:49 <dfeuer_> c_wraith, I thought you were talking about something else. Scrolling up, I can't even see what you are referring to.
10:46:50 <michaelt_> mjrosenb: for simultaneous folds like that, http://hackage.haskell.org/package/foldl-1.0.5/docs/Control-Foldl.html is one way;   ((,) <$> L.minimum <*> L.maximum) is a typical example
10:47:35 <c_wraith> dfeuer_: whether GHC will optimize (minimum xs, maximum xs) to a single pass
10:47:48 <kuribas> Would it be a big difference?
10:47:52 <dfeuer_> Yes.
10:47:56 <dfeuer_> Usually.
10:48:10 <c_wraith> on the topic:  http://squing.blogspot.com/2008/11/beautiful-folding.html
10:48:13 <dfeuer_> If the lists are small enough, then probably not.
10:48:28 <dfeuer_> Small enough, however, is really quite small.
10:48:32 <kuribas> dfeuer_ that shouldn't depend on the list size.
10:48:45 <mjrosenb> michaelt_: that looks cool.
10:48:51 <kuribas> dfeuer_ I mean, it should be a constant factor.
10:48:52 <dfeuer_> kuribas, what you think should be and what is are not the same :P
10:49:00 * mjrosenb is dealing with a list that is several billion lines long :-(
10:49:09 <c_wraith> That post sketches out a system for fusing parallel folds, but it also points out that GHC's RULES aren't sufficient to make it work at the moment.
10:49:23 <mjrosenb>     Could not find module ‘Control.Foldl’
10:49:25 <mjrosenb> :-(
10:49:33 <michaelt_> mjrosenb: it packages  the same idea as is in the post c_wraith linked
10:49:37 <michaelt_> mjrosenb: cabal install foldl
10:49:48 <mjrosenb> michaelt_: itym emerge foldl :-p
10:49:53 <dfeuer_> kuribas, I have two words for you: "cache" and "cache". Oh wait, that's just one word. But it makes large lists much worse than small ones for that.
10:50:05 <kuribas> dfeuer_ hm, yes...
10:50:33 <michaelt_> mjrosenb: also, import qualified Control.Foldl as L or whatever, it totally overlaps with the Prelude
10:50:35 <dfeuer_> Oh, actually, the other word is "list fusion", because the parallel fold can fuse with a list producer, whereas two folds can't.
10:50:38 <dfeuer_> It's really bad.
10:50:42 <mjrosenb> gah, stupid min doesn't do what I want on Comparable c => Maybe c
10:51:07 <kuribas> Maybe inlining and CSE could turn it in one pass?
10:51:45 * mjrosenb is *also* relying heavily on list fusion here.
10:51:47 <dfeuer_> I asked about this yesterday in #ghc, and apparently it's not always easy to see when it's a good idea.
10:51:55 <Fuuzetsu> when are we going to get data type definitions inside let/where blocks?
10:52:40 <c_wraith> Fuuzetsu: When you pay someone enough for them to code up the extension and get it into GHC. :)
10:53:00 <Fuuzetsu> so never
10:53:01 <Fuuzetsu> thought so
10:53:04 <michaelt_> would it really be worth the trouble?
10:53:30 <Fuuzetsu> michaelt_: it would let you eliminate a lot of _ -> error "can't happen" without much pain
10:53:41 <mjrosenb> dfeuer_: I'd believe it.
10:53:55 <linman32> has anyone tried arangoDB?
10:55:09 <dfeuer_> What I want are safe fold-like coercions. But edwardk doesn't think anyone will be willing to go to the trouble to benefit just a few things a little bit.
10:55:51 <mjrosenb> so, I haven't been here in a while, I assume that getContents and readFile are still black magic?
10:56:12 <c_wraith> mjrosenb: they're convenient, but they have some downsides.
10:56:58 <michaelt_> They're awesome. Just don't use them.
10:57:23 <kuribas> dfeuer_ have you profiled your code?
10:57:24 <c_wraith> I have no issues with code that uses them - unless it's designed to be a long-running process.
10:57:26 <mjrosenb> and by black magic, I mean they look like they perform a single IO operation when they actually spread an IO operation out over an arbitrary amount of time.
10:57:27 <doismellburning> michaelt_: lol
10:57:55 <mjrosenb> c_wraith: as I said earlier, I'm processing a text file with probably about 3 billion lines of text on them.
10:57:59 <kuribas> dfeuer_ you can rewrite critical code as a direct loop.
10:57:59 <c_wraith> kuribas: dfeuer_ has actually been doing a lot of work on fusion-related issues recently.
10:57:59 <mjrosenb> *in it
10:58:10 <kuribas> c_wraith: Oh I see :)
10:58:23 <dfeuer_> kuribas, fold-like coercions turn O(n) operations into O(1) operations. Or are you talking about something else?
10:58:43 <michaelt_> mjrosenb: are you dividing it on lines?
10:58:50 <mjrosenb> michaelt_: yes.
10:59:14 <kuribas> dfeuer_: sorry, I meant to adress mjrosenb
10:59:20 <dfeuer_> Ah.
10:59:28 <kuribas> dfeuer_ I would like to see a supercompiler in haskell.
10:59:39 <mjrosenb> kuribas: there was one!
10:59:39 <kuribas> in ghc
10:59:44 <dfeuer_> kuribas, I don't even know what that is :P
10:59:48 <mjrosenb> kuribas: ok, not in ghc.
10:59:56 <RchrdB> It was in YHC, wasn't it?
11:00:01 <c_wraith> There is a fork of GHC that has a supercompiler
11:00:05 <RchrdB> YHC died as a project, though.
11:00:19 <RchrdB> I think that Neil Mitchell was working on it?
11:00:30 <kuribas> dfeuer http://community.haskell.org/~ndm/supero/
11:00:38 <mjrosenb> RchrdB: I don't think so.
11:00:47 <mjrosenb> yeah, supero.  that should really get revived.
11:01:02 <kuribas> dfeuer: it's a generalisation of list fusion and deforestation.
11:01:13 <Taneb> RchrdB, YHC is no more, and Neil Mitchell was a major force in it. Don't think it was a supercompiler, though
11:01:21 <c_wraith> the problem is that while supercompilation does amazing things to simple examples, it sort of chokes and dies on real programs.
11:01:24 <RchrdB> mjrosenb, yeah, ~ndm is Neil Mitchell's username, so I'm pretty certain that that's the project I was thinking of. :)
11:01:50 <RchrdB> Taneb, YHC wasn't a supercompiler, but IIRC he'd used YHC to implement Supero, I think.
11:01:53 <c_wraith> And that's the hard problem in making supercompilation a good idea.
11:02:09 <mjrosenb> RchrdB: yeah, I just don't think YHC ever saw any parts of supero, even if supero was based off of yhc.
11:02:17 <c_wraith> If someone solves it, fantastic!  Forget all those manual RULES! :)
11:02:34 <kuribas> http://community.haskell.org/~ndm/downloads/paper-rethinking_supercompilation-29_sep_2010.pdf
11:03:11 <kuribas> It claims their algorithm runs under 4 seconds for each program.
11:03:29 <kuribas> idk if they ever tested it on large programs.
11:03:59 <RchrdB> c_wraith, the person who writes regehr.org has been mooting the idea of using supercompilation techniques to generate sets of proven-valid rules automatically. =)
11:04:14 <mjrosenb> @hoogle a -> Maybe b -> (a,a) -> Maybe (b,b)
11:04:17 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
11:04:17 <lambdabot> Data.Graph.Inductive.NodeMap insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
11:04:25 <mjrosenb> noooot quite.
11:04:39 <mjrosenb> @hoogle a -> Maybe b -> [a] -> Maybe [b]
11:04:39 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
11:04:39 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
11:04:39 <lambdabot> Text.Regex.Base.RegexLike makeRegexOptsM :: (RegexMaker regex compOpt execOpt source, Monad m) => compOpt -> execOpt -> source -> m regex
11:05:13 <latro`a> mjrosenb, are you missing some parens? I have no idea what that second type would be
11:05:28 <mjrosenb> latro`a: oh, derp.  yes.
11:05:34 <kuribas> Maybe it could be interesting to mark code to be supercompiled, in order to reduce compile time.
11:05:36 <mjrosenb> @hoogle (a -> Maybe b) -> [a] -> Maybe [b]
11:05:36 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:05:37 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:05:37 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
11:05:59 * shapr hops cheerfully
11:06:00 <RchrdB> mjrosenb, \f l -> (catMaybes . map f) l -- ?
11:06:01 <mjrosenb> @hoogle (a -> Maybe b) -> (a,a) -> Maybe (b,b)
11:06:01 <lambdabot> No results found
11:06:02 <shapr> yay haskell!
11:06:32 <mjrosenb> RchrdB: pretty sure that doesn't do what I want.
11:07:02 <shachaf> mjrosenb: lens calls that "both"
11:07:46 * mjrosenb goes with mapM.  that is almost certainly what I want.
11:08:11 <glguy> mapM doesn't have the type you asked for
11:08:26 <shachaf> Oh, the first thing you asked for is mapM (or traverse).
11:08:27 <mjrosenb> shachaf: is that in a package?
11:08:27 <glguy> oh, at least not the last type
11:08:36 <shachaf> mjrosenb: It's in a package called lens.
11:08:54 <mjrosenb> glguy: I have something that is currently in an indeterminite state between a list that will always have two elements, and a tuple.
11:09:04 <mjrosenb> glguy: I can use either one, and since mapM exists...
11:09:11 <shachaf> mjrosenb: (traverse is another name for mapM, or for a generalization of it.)
11:09:32 <latro`a> usually one tries to make invalid data impossible
11:09:46 <latro`a> rather than simply declaring it invalid and having to check for it
11:10:01 <mjrosenb> shachaf: err, I meant lens/both.
11:10:02 <shachaf> I,I data Pair a = Pair a a deriving (Functor,Foldable,Traversable); traverse :: (a -> Maybe b) -> Pair a -> Maybe (Pair b)
11:10:21 <glguy> Linear.V2.V2
11:11:02 <monochrom> ^V^
11:12:05 <Markzz> is there a way of associating a label with data so you don't have to tuple it all up, say for example I wrote processing functions for [[Int]] -> [Int] , [Int] -> Bool, and then I need to associate [Int] with a and redo the processing, a method of not writing [(a, [Int])] -> (a,[Int]), (a,[Int]) -> Bool etc
11:12:22 * hackagebot FTGL 1.4 - Portable TrueType font rendering for OpenGL using the Freetype2 library  http://hackage.haskell.org/package/FTGL-1.4 (laquendi)
11:17:36 <eacameron> I just wrote a quick benchmark for Chan vs TMQueue. The results baffle me. TMQueue is 2x as fast as Chan WITHOUT -threaded, but the results are almost completely reversed WITH -threaded. Can someone help me understand this?
11:18:35 <kuribas> I am trying to install haskell-platform, but I get: Warning: The following packages are likely to be broken by the reinstalls: shake-0.13.2
11:18:59 <kuribas> It was however installed as a dependency of hptools
11:19:13 <mjrosenb> does anyone know if splitting the result of getContents on lines is a good/bad idea?
11:19:31 <mjrosenb> I'm curious as to why michaelt_ asked about that.
11:20:25 <eacameron> Here's my benchmark. It uses an input file with tons of lines of random data. https://gist.github.com/3noch/aaa2ddf8fae874aac91c
11:20:35 <dfeuer_> mjrosenb, getContents is not usually a good idea if you need high performance. Things like pipe and conduit will do that in ways that look pretty, but I don't know how to use them yet.
11:22:11 <mjrosenb> hrmm, this is running at ~3 MB/s
11:22:16 <nateb> Hello.  Is there a way to enumerate or list all data constructors for a type?  That is, for "data Bool = False | True" it would return something along the lines of [False, True]?  I ask because I want to be able to "show" them all (not use them, which I realize might require some kinda magic).
11:22:23 * hackagebot FTGL 2.0 - Portable TrueType font rendering for OpenGL using the Freetype2 library  http://hackage.haskell.org/package/FTGL-2.0 (laquendi)
11:22:36 <mjrosenb> nateb: if they implement Enumerate...
11:22:37 <Iceland_jack> nateb: [minBound..maxBound] :: [Bool]?
11:22:41 <geekosaur> nateb: derive Enum and Bounded
11:22:42 <Iceland_jack> > [minBound..maxBound] :: [Bool]
11:22:44 <lambdabot>  [False,True]
11:22:53 <nateb> Ah!  Perfect.
11:23:04 <nateb> Thank you all.
11:23:16 <mjrosenb> > [minBound..maxBound] :: [Ord]
11:23:17 <lambdabot>  Expecting one more argument to ‘GHC.Classes.Ord’
11:23:17 <lambdabot>  Expected kind ‘*’, but ‘GHC.Classes.Ord’ has kind ‘* -> Constraint’
11:23:27 <mjrosenb> :-(
11:23:29 <geekosaur> Ord isn't a type
11:23:34 <geekosaur> you may have neabt
11:23:38 <geekosaur> meant
11:23:39 <mjrosenb> > [minBound..maxBound] :: [Ordering]
11:23:40 <lambdabot>  [LT,EQ,GT]
11:23:49 <geekosaur> yes, that
11:23:54 * geekosaur slow
11:24:38 * mjrosenb is not a huge fan classes whose names are a prefix of a corresponding type.
11:24:53 <mjrosenb> then again, it is better than them having completely unrelated names
11:25:14 * shachaf wonders what a class for a partial ordering would be like.
11:25:30 <geekosaur> I thought there was already one (or more) on Hackage
11:25:39 <geekosaur> it comes up every so often
11:30:34 <mjrosenb> shachaf: wouldn't it just be like Ord, but with POrdering = LT | EQ | GT | NC ?
11:31:10 <shachaf> Maybe.
11:35:33 <johnw> mjrosenb: wouldn't it just be LT | NC?
11:36:23 <mjrosenb> johnw: you almost certainly want to have at least equality.
11:36:43 <johnw> oh, right, due to anti-symmetry
11:37:00 <johnw> guess I was thinking of pre-order
11:42:37 <mjrosenb> as expected, converting my custom rolled minmax function to use Control.Foldl's sample nuked my memory 'leak'
11:47:01 <mjrosenb> hrmm, is there a config file I can use to hardcode a max heap size?
11:47:08 <mp> how do I acccess other package's data files? inside package they do import Paths_foo and getDataFileName. is there a way to get Paths_foo in bar?
11:47:44 <mjrosenb> when I'm prototyping stuff, I can't imagine ever needing more than a 4G heap, and I can never remember to add the correct flags to ghc / ulimit before I run my program.
11:48:58 <MitchellSalad> is there any difference (in performance) between "a >> lift b >> lift c" and "a >> lift (b >> c)"?
11:49:03 <mjrosenb> if something is marked "Deprecated" on hackage, does that mean there is a replacement for it?
11:49:10 <monochrom> mjrosenb: the GHC user's guide has a section on that
11:49:44 <bennofs> MitchellSalad: if lifiting is expensive, lift (b >> c) could be faster
11:51:21 <djahandarie> If the bind in the unlifted monad is expensive, lift b >> lift c could be faster!
11:51:51 <MitchellSalad> that's a good point!
11:52:09 <bennofs> djahandarie: although the transformer will often need to use the unlifted bind too
11:52:57 <monochrom> if lift solves an NP-complete problem and bind solves a co-NP-complete problem, which one is faster?
11:53:46 <c_wraith> monochrom: the one on the left.
11:54:11 <mjrosenb> monochrom: A trip to the mental institution is probably fastest.
11:54:36 <monochrom> programming is hard. let's go to the mental institution!
11:55:11 <djahandarie> They may just let you in with that explanation.
11:55:47 <josephle> Cantor was a pioneer in this case.
12:00:18 <c_wraith> @quote mental.institution
12:00:19 <lambdabot> monochrom says: programming is hard. let's go to the mental institution!
12:02:44 <eacameron> For this benchmark https://gist.github.com/3noch/aaa2ddf8fae874aac91c     When built without -threaded, the TMQueue version is about 2x as fast as Chan, but with -threaded, the results are almost exactly the opposite! Why?
12:03:54 <mjrosenb> ok, so I'm using both reads, and getContents.  if one were a bottleneck, which one would it be?
12:04:00 <napping> eacameron: how is STM and MVar implemented without threaded?
12:04:25 <stalintrotsky> I would guess getContents since it involves disk I/O
12:04:37 <eacameron> napping: Is that a rhetorical question? ;)
12:05:05 <napping> no
12:05:25 <mjrosenb> and I guess I should say reads :: String -> [(Word32,String)]
12:06:19 <napping> oh, how many threads did you run with, with -threaded?
12:06:30 <napping> try with +RTS -N1, I think
12:07:28 * hackagebot persistent-mongoDB 1.4.4.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.4.3 (GregWeber)
12:09:22 <eacameron> napping: ah interesting. I'll try that; I thought GHC tried to figure that out itself?
12:09:35 <napping> eacameron: sure, and without -threaded you'll use only one
12:09:54 <napping> The difference is either how well they perform under contention or with less memory locality
12:10:06 <napping> or that -threaded provides different implementations of the primops
12:10:30 <napping> but I see both are based on primtives, so I doubt TVar could have a hugely cheaper single-core version
12:11:21 <fryguybob> eacameron: STM without threaded does not take locks to protect the RTS critical sections dealing with transactions.
12:11:53 <fryguybob> Well, I should say data structures for the fine-grained locking.
12:12:01 <eacameron> fryguybob: hmmm interesting
12:12:04 <napping> fryguybob: isn't the same true for MVar?
12:12:29 * hackagebot spice 0.2.0.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.2.0.0 (Crockeo)
12:13:29 <fryguybob> napping: I'm not sure about that for MVar.
12:14:12 <napping> eacameron: running with -threaded and +RTS -N1 should separate any effects from -threaded alone, vs. code possibly running in different cores/caches
12:14:20 <fryguybob> napping: Without threaded MVar's do not call lockClosure.
12:17:15 <eacameron> napping: so in my trivial case, single-threaded is actually faster hands down, and STM happns to handle that case better...
12:17:29 <shapr> Heard of the Ivory and Tower EDSLs Galois built?
12:17:56 <napping> eacameron: did you try compiling with -threaded and running with +RTS -N1?
12:18:11 <eacameron> napping: about to
12:19:02 <napping> In particular, if it gives different and faster results than -threaded alone, you might be able to use forkOn if you really care
12:19:03 <fryguybob> eacameron: It looks like there is only one "thread"'s worth of work in your test right?
12:19:32 <johnw> ozataman: ping
12:19:47 <eacameron> fryguybob: I have a producer and consumer, the consumer is in an a thread
12:21:31 <napping> Did you say if the overall time was better with or without -threaded
12:22:38 <fryguybob> eacameron: If the producer gets ahead of the consumer then blocks on some IO the consumer could catch up and still be productive.  But this is going to happen on the non-Threaded RTS and the threaded one.
12:22:47 <eacameron> napping: Same behavior with -N1; no overall time is the same, but the winner swaps
12:22:59 <napping> "no overall time is the same"?
12:23:00 <fryguybob> The threaded one has the extra overhead of sending the data to another core.
12:23:24 <napping> If -N1 and without -threaded have the same results, then it's an issue of cache locality
12:23:34 <eacameron> napping: eh?
12:24:04 <napping> -N1 forces it to run everything on one core
12:24:16 <napping> even though it's using the -threaded version of any RTS bits that have different implementations
12:24:25 <napping> If you said that has the same result as not using -threaded
12:24:43 <napping> then the difference is just that -threaded with default/higher -N puts the threads on different cores
12:25:31 <napping> or may put the threads on different cores, at least
12:25:55 <napping> eacameron: you didn't say which of the other results you were comparing -N1 to.
12:26:19 <eacameron> napping: I've only done without threaded or with threaded, default -N
12:26:34 <eacameron> I have >1 core
12:26:54 <napping> Was either faster in real time?
12:27:55 <Clarice> -N1 with multiple threads of execution should be slower than without multithreading
12:28:57 <napping> Clarice: yes, but the question is why relative performance changes around
12:29:17 <Clarice> +1 to cache locality, then
12:29:31 <Clarice> How predictable is that with the GHC runtime? I wouldn't know.
12:29:36 <napping> Yeah, that's why running with -N1 would be the interesting test
12:29:43 <napping> I don't know either
12:29:53 <Clarice> thunk crazy languages
12:30:07 <napping> well, it's thread scheduling I'm less sure about
12:31:11 <napping> how are threads distributed to execution contexts? Is that stable across runs? etc.
12:36:39 <archiduque> hey guys trying to install the latest package of haskell but i think i need libgmp.so.10 and when i do ghci in terminal  output this
12:36:41 <archiduque> GHCi, version 7.8.3: http://www.haskell.org/ghc/  :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... <command line>: can't load .so/.DLL for: libgmp.so (libgmp.so: cannot open shared object file: No such file or directory)
12:37:01 <archiduque> what i must do ?
12:37:29 <ion> Use your system package manager to install the package that provides libgmp.so
12:37:53 <zmbmartin> Anyone here use scotty? Is it possible to use optional params or pattern match based on params?
12:38:59 <archiduque> in my package manager when i put libgmp.so  it doesnt output nothing
12:39:01 <archiduque> wtf
12:39:01 <archiduque> xD
12:39:30 <archiduque> <ion>
12:39:49 <c_wraith> archiduque: just search for gmp
12:40:03 <dottedmag> archiduque: OS? (if Linux -- distribution?)
12:40:30 <archiduque> linux mint
12:40:42 <c_wraith> on debian, I have a libgmp10 package.
12:40:52 <c_wraith> mint probably has a similar package
12:41:14 <dottedmag> c_wraith: error is talking about libgmp.so, not versioned one. Wouldn't it need libgmp-dev then?
12:41:16 <archiduque> is already installed
12:41:24 <dottedmag> archiduque: try libgmp-dev then
12:41:40 <archiduque> ok thanks guys
12:41:57 <dottedmag> archiduque: did it work?
12:42:29 <archiduque> hell yeah!
12:42:30 <archiduque> thanks
12:42:31 <archiduque> :3
12:43:25 <abc56889> how do I make lenses for ioref?
12:46:25 <mjrosenb> so.... converting a String to a Word32... I've heard reads is bad, but I don't remember seeing a viable replacement.
12:46:41 <merijn> mjrosenb: reads is ok, although sucky performing
12:46:54 <merijn> mjrosenb: "read" <- no s is bad
12:47:13 <merijn> Although in general you probably wanna use some other function
12:47:14 <mjrosenb> merijn: right.  I want something that will be fast.
12:47:42 <mjrosenb> like I can write my own, but I suspect it won't perform spectacularly
12:47:55 <mjrosenb> and I should probably use ByteStrings rather than strings.
12:48:05 <mjrosenb> since this is guaranteed to be ascii
12:48:08 <merijn> Text
12:48:28 <merijn> Text will be almost as fast as ByteString, except not incorrect
12:48:39 <merijn> Probably attoparsec has some stuff for parsing numbers
12:49:50 <johnw> abc56889: https://github.com/jwiegley/notes/blob/master/misc/mutable-lens.hs
12:49:54 <napping> mjrosenb: are you parsing general input, or serializing stuff?
12:50:52 <mjrosenb> napping: I guess I'm deserializing a file that was serialized to ascii with printf("%p:    %p", foo bar)
12:51:03 <mjrosenb> err, \n at the end of that string.
12:53:09 <napping> Text is probably good for general input, but specifying ASCII is plausible if you are more after human-readable serialization
12:53:22 <napping> if it even makes any appreciable performance difference, of course
13:00:11 <mjrosenb> napping: how exactly would I "specify ASCII"?
13:01:06 <napping> mjrosenb: I mean if you just say the file has to be in ASCII
13:01:28 <napping> again presuming the UTF-8 decoding is actually expensive
13:02:38 * hackagebot clckwrks-cli 0.2.13 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.13 (JeremyShaw)
13:06:49 <napping> especially if you're generating the file yourself
13:08:24 <sm> hi all
13:09:04 <sm> to make my parsing less black art and more science, it would help a lot to have better visibility into the parsing process
13:10:42 <sm> I have a nice ptrace logging function I can drop in to parsec parsers, but I wonder if this could be automated, eg having it call the log function each time it enters a parser
13:11:55 <johnw> sm: if you use edwardk's parsers library, you could build logging into your monad
13:12:39 * hackagebot clckwrks-plugin-bugs 0.7.5 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.7.5 (JeremyShaw)
13:13:11 <sm> that sounds good. I think all parsing libs should come with such a trace mode for troubleshooting
13:14:30 <David> Is there a guide somewhere to setting up a lambdabot instance?
13:14:54 <David> I'm trying to figure out what to put in passwd.rc
13:17:39 * hackagebot clckwrks-plugin-ircbot 0.6.12 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.12 (JeremyShaw)
13:22:40 * hackagebot happstack-server 7.3.8 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.8 (JeremyShaw)
13:22:42 * hackagebot hoq 0.2 - A language based on homotopy type theory with an interval type  http://hackage.haskell.org/package/hoq-0.2 (valis)
13:30:43 <oisin888> I'm writing a really simple wrapper for OpenGLRaw's glBufferData - I will be using it to "buffer" both GLfloat values and GLuint values. However, I need to pass in a "type hint" - and I'm unsure how to do that. You can see the code - and the necessary hint locations (denoted by underscores) here: http://lpaste.net/5874653707668291584
13:33:57 <Haskellfant> how does ghci decide how to name the variables in :t? When I run :t (=<<) it uses a and b but when I use (join .) . fmap it uses a1 and a
13:34:17 <hpc> it prefers to use the letters you use in type signatures
13:34:23 <Haskellfant> ah ok
13:34:32 <hpc> or it goes a, a1, a2, ...
13:34:59 <hpc> it might go f, f1, f2, ... for stuff that's kind whatever -> *
13:35:26 <hpc> i can't remember
13:38:09 <djahandarie> The letter isn't fix, it starts adding digits to existing letters.
13:38:21 <djahandarie> :t liftM . liftM
13:38:22 <lambdabot> (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
13:38:22 <hpc> ah
13:38:28 <djahandarie> :t fmap . fmap
13:38:29 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:38:41 <hpc> :t (\x -> x)
13:38:42 <lambdabot> t -> t
13:38:50 <hpc> hey look, it guesses t
13:42:44 * hackagebot spice 0.3.0.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.0.0 (Crockeo)
13:43:33 <r444> I need to model a non-deterministic process with individual state for each computational branch and i'm quite lost with monad transformers.
13:43:48 <bergey> oisin888: Use ScopedTypeVariables
13:44:09 <r444> Seems like  'type GuessState a = StateT FieldState [] a' is a way to go, but i don't sure. :|
13:46:41 <vanila> r444, I think LogicT of State would be the right order
13:46:47 <vanila> rather than StateT
13:47:50 <vanila> r444, if you describe more precisle I could have a go
13:48:05 <vanila> more precisely*
13:48:06 <r444> vanila: i'll try
13:48:24 <r444> imagine some generic crossword
13:48:55 <r444> number of down/across words are variable
13:48:58 <linman32> what is a good http package to use for haskell?
13:49:17 <johnw> linman32: http-client
13:49:39 <r444> i've implemented clues in haskell(they can refer to other words)
13:49:43 <linman32> johnw: thnx
13:50:01 <r444> and i'm trying to bruteforce my way to the solution
13:50:13 <napping> what's a good extensible data type package?
13:50:26 <vanila> r444, ahh, so you fill in parts of the cross word - to try to solve it.. but also want these state changes to be undone when backtracking
13:50:36 <r444> yep
13:50:42 <vanila> ok let me think a little about that
13:51:05 <edwardk_> abc56889: you can't
13:52:19 <vanila> r444, one thing to think about is whether you need state at all? it could probably be done just as [Board] (list monad)
13:54:07 <r444> vanila: now i'm trying to remember my thoughts on that matter, i decided that i can't do it that way(maybe i was wrong)
13:55:40 <r444> vanila: can i PM you? i'd really like to extract this talk from main channel and gain some clarity of thought
13:55:44 <vanila> sure :0
13:55:46 <vanila> :)
13:56:09 <kludgy> I think I've just been defeated.. How does one generalize this type for all (Enum a, Bounded a)? http://lpaste.net/109722
13:57:23 <HeladoDeBrownie> kludgy, do you have scoped type variables on? I've never used it but I think it's what you're going for here
13:57:51 <kludgy> HeladoDeBrownie: No but I'll give it a go! :)
13:57:53 <HeladoDeBrownie> I might just be thinking about it wrong though
13:58:02 <c_wraith> kludgy: there is no 'a' in the type signature.  There's nothing for it to constrain.
13:58:37 <kludgy> c_wraith: Yea I understand why the error is there, just not how to re-express the problem correctly.
13:59:05 <c_wraith> kludgy: how does a user of printEnumPairs indicate what type they want it to operate on?
13:59:12 <c_wraith> kludgy: there's no place to put it in the type signature.
13:59:36 <c_wraith> kludgy: the standard approach is to use a proxy value.
13:59:43 <kludgy> c_wraith: Exactly my issue. :)
13:59:58 <kludgy> c_wraith: interesting..
14:00:29 <napping> just change the bit at the end from IO () to proxy a -> IO (), and add a _ before the = for an ignored argument
14:00:41 <c_wraith> kludgy: http://lpaste.net/109723
14:00:48 <c_wraith> ... which is exactly what napping said
14:00:48 <napping> then you'll get some more useful type errors :)
14:00:50 <JohnTalent> Where are some good beginner to intermediate user and reference haskell documentation?
14:00:52 <HeladoDeBrownie> YOu could also pick a vale of type F A without having an A, depending on the F.
14:00:55 <HeladoDeBrownie> value*
14:01:11 <HeladoDeBrownie> data F a = F
14:01:40 <HeladoDeBrownie> This is essentially useful for nothing more than a container for a type
14:01:41 <napping> HeladoDeBrownie: you can always get undefined :: A
14:01:44 <HeladoDeBrownie> Ah, true
14:01:55 <HeladoDeBrownie> I keep forgetting about undefined because it seems ugly to use it
14:02:00 <dmj`> JohnTalent: the typeclassopedia, http://www.haskell.org/haskellwiki/Typeclassopedia
14:02:03 <napping> yeah, there's a built in Proxy too
14:02:06 <zq> :t catMaybes
14:02:08 <lambdabot> [Maybe a] -> [a]
14:02:17 <zq> :t catMaybes . map (const Nothing)
14:02:18 <lambdabot> [a1] -> [a]
14:02:26 <johnw> HeladoDeBrownie: you could use error "Never evaluated" :: A
14:02:33 <napping> or at least recently
14:02:36 <napping> Proxy :: Proxy A
14:02:44 <zq> is there a case where "catMaybes . map (const Nothing)" returns something besides []? besides feeding it undefined
14:02:55 <napping> oh, that's not the one I had in mind
14:02:58 <napping> maybe next GHC?
14:03:06 <JohnTalent> dmj`: ok thanks.
14:03:07 <c_wraith> Data.Proxy is in GHC 7.8
14:03:11 <napping> there was some stuff about a proxy type that became zero-width at runtime
14:03:18 <JohnTalent> dmj`: do you think that's all I'll need?
14:03:24 <c_wraith> and yes, Data.Proxy is zero-width at runtime in GHC 7.8
14:03:28 <johnw> :t catMaybes . map (const Nothing)
14:03:30 <lambdabot> [a1] -> [a]
14:03:30 <napping> oh, it is?
14:03:31 <napping> huh
14:04:03 <johnw> zq: you can prove that it couldn't
14:04:11 <c_wraith> Note that my signature actually said "proxy" instead of "Proxy".  That difference is useful.
14:04:20 <napping> I'm running 7.8 myself, and it seems to have a completely ordinary definition data Proxy t = Proxy
14:04:21 <zq> johnw: sure i can, but how come ghc can't?
14:04:34 <c_wraith> napping: seems to, yes.  does underneath, no.
14:04:38 <johnw> zq: why would you expect GHC to do that?
14:05:09 <zq> johnw: why wouldn't i? it's a shortcut to doing less work
14:05:21 <napping> huh, that's awfully magic. I thought there would by a Proxy# type or pragma or something
14:05:51 <napping> GHC.Prim has a data Proxy# a with witness proxy# :: Proxy# a
14:05:54 <kludgy> It's an odd sort of hole in the language
14:06:17 <c_wraith> kludgy: No other language handles that case.  Most can't even have the problem.
14:06:20 <napping> Are you sure Data.Proxy gets that?
14:06:54 <c_wraith> kludgy: not completely sure, no.  Maybe it doesn't
14:06:54 <Peaker> With Control.Concurrent.Async -- if you have multiple asyncs you've created with: withAsync, and you want to wait on all of them, you are supposed to use a simple:  mapM await.  However, this is bad: if any of them throws an exception, you want the exception propagated as early as possible (killing all the other asyncs)
14:07:33 <Peaker> you don't want to wait on each serially, that only makes sense if they all return values
14:07:59 <David> hi guys, sorry to repeat the question, but can anyone point me to lambdabot documentation that details setup?
14:08:06 <David> I just installed lambdabot and got this:
14:08:09 <Peaker> What would be a good way to implement this idea?
14:08:20 <David> lambdabot> > 1 + 1
14:08:20 <David> ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-imports","-l","/home/david/.lambdabot/State/L.hs","--expression=1 + 1","+RTS","-N2","-RTS"]
14:08:20 <David>  Terminated
14:08:23 <Peaker> (i.e: concurrently wait for everyone, in case one throws)
14:08:52 <merijn> zq, johnw: "catMaybes . map (const Nothing)" can totally return something besides [] without undefined
14:09:03 <hpc> David: what's the output of "which mueval" in the console?
14:09:10 <merijn> zq, johnw: Trivial counter proof: [1..] <- now it returns bottom
14:09:19 <napping> Peaker: if you want all the results, what's wrong with mapM await?
14:09:28 <David> mueval doesn't exist
14:09:29 <Peaker> napping: that if any one of them throws, the whole thing throws
14:09:40 <napping> isn't that what you said you wanted?
14:09:43 <Peaker> napping: if the last one threw immediately, and the previous ones take forever
14:09:49 <Peaker> napping: It'll wait forever
14:09:52 <napping> ah, then mapM_ link first
14:09:56 <c_wraith> Peaker: link2 over each pair?
14:09:56 <David> I installed haskell-platform normally, and then used apt-get install lambdabot (tried to build it from source, but it was taking forever - it's a shitty VPS with 512mb ram)
14:10:03 <Peaker> oh, what's link? :) reading
14:10:04 <c_wraith> err, not each pair.  Just each consecutive pair
14:10:10 <hpc> lambdabot implements evaluating haskell via that executable
14:10:11 <hpc> hmm
14:10:23 <hpc> what if you do locate mueval?
14:10:25 <c_wraith> napping: I don't think link will do.  I think it needs link2
14:10:31 <hpc> (or updatedb && locate mueval)
14:10:32 <napping> why not?
14:10:34 <Peaker> napping: oh, awesome, that solves it :)
14:10:35 <zq> @let f x = case x of { [] -> []; x : xs -> f xs; }
14:10:38 <lambdabot>  .L.hs:158:19:
14:10:38 <lambdabot>      Ambiguous occurrence ‘f’
14:10:38 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:155:1
14:10:38 <lambdabot>                            or ‘Debug.SimpleReflect.f’,
14:10:38 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
14:10:48 <zq> @let sortofcatmaybe x = case x of { [] -> []; x : xs -> f xs; }
14:10:51 <lambdabot>  Defined.
14:10:51 <c_wraith> napping: link specifies that if the async throws an exception, it kills the current thread - but not the other way around.
14:11:03 <napping> you can use withAsync
14:11:11 <c_wraith> napping: using link2 means that if one of the asyncs throws an exception, they're all terminated promptly
14:11:12 <David> hpc: do I need to cabal install it?
14:11:13 <Peaker> yeah, I don't actually want the other way around
14:11:25 <Peaker> I want exceptions to propagate up, not down
14:11:36 <napping> or just use the concurrently/Concurrently stuff
14:11:53 <JohnTalent> anyone have trouble compiling hoogle?
14:11:58 <c_wraith> So..  You want asyncs to be keep running even if their results can't be used?
14:12:01 <johnw> merijn, zq: heh, simple proof: https://gist.github.com/a9ee9859f5f2fe4b3fbd
14:12:02 <merijn> I guess the best way to implement an IO action that can only be run once is to have "MVar (IO ())" and then do "tryTakeMVar x >>= \case Nothing -> return (); Just x -> x"?
14:12:04 <David> maybe I should install lambdabot with cabal...
14:12:04 <David> it's gonna take a long time
14:12:06 <zq> merijn: what about the function i just defined?
14:12:11 <Peaker> c_wraith: my asyncs are stored in a big map
14:12:16 <napping> mapConcurrently wait, if you don't mind the extra threads
14:12:19 <Peaker> c_wraith: it's for a build system
14:12:30 <Peaker> c_wraith: there may be shared dependencies, each represented by an async
14:12:39 <merijn> johnw: Proof is flawed
14:12:43 <johnw> how so?
14:12:49 <merijn> johnw: Coq is strict and thus can't have infinite lists like my example
14:12:54 <napping> hmm, link makes threads for rethrowing anyway
14:12:55 <johnw> haha
14:13:04 <johnw> you are mixing data and codata
14:13:10 <johnw> merjin is flawed
14:13:22 <hpc> David: if you have lambdabot running already you don't need to for that
14:13:37 <David> hpc: I installed lambdabot through apt
14:13:41 <johnw> I can't do the proof coinductively because there is no "nil"
14:13:41 <hpc> all you need is mueval on your path, which doesn't strictly need to be done the kosher way ;)
14:13:50 <zq> merijn: also, ghc has sufficient information to know that i've never fed an infinite list into that function
14:13:52 <johnw> which is effectively what you meant
14:13:54 <David> (not really familiar with ubuntu's package management system - normally I use cabal on my osx laptop)
14:14:09 <merijn> zq: Oh? How does it have that info?
14:14:10 <David> but I did notice that the cabal version tried to install a >lot< of dependencies
14:14:14 <David> which the apt did not
14:14:20 <hpc> David: see if mueval is in apt
14:14:26 <David> hpc: not for 12.04
14:14:26 <hpc> if not, here's my copy: https://dl.dropboxusercontent.com/u/37707/mueval
14:14:31 <merijn> David: Is the apt version of lambdabot up to date?
14:14:31 <johnw> zq: how can it know that no one, ever, will ever feed an infinite list to it?
14:14:34 <zq> merijn: the ast of my entire program
14:14:48 <johnw> zq: it sounds like you're getting into dependent typing land
14:14:49 <hpc> (i promise it won't hack the planet)
14:14:50 <David> merijn: it's this package: http://packages.ubuntu.com/precise/lambdabot
14:14:55 <zq> johnw: nooo!
14:14:55 <merijn> zq: You assume that GHC can prove a list is finite
14:14:57 <vanila> zq, it's not always possible to figure stuff like that out just looking at program source code
14:15:06 <zq> ugh
14:15:35 <David> what's rather suspicious is that ghc is not a dependency of that version of lambdabot...
14:15:37 <HairyDude> While cabal-installing something is it possible to forbid it from upgrading a particular package?
14:15:40 <johnw> I need a proof that merijn's name is actually pronouncable...
14:15:41 <zq> isn't laziness supposed to be able to handle this sort of thing?
14:15:44 <napping> Peaker: you might also like waitSTM
14:16:20 <merijn> HairyDude: Yes, add "constraint: Foo installed" to your .cabal/config or manually specify the extra constraint on the command line
14:16:32 <Clint> David: if there's something wrong with the package, file a bug
14:16:33 <HairyDude> merijn: ta
14:17:39 <napping> I think you can build an equivalent to mapConcurrently wait that doesn't use any threads that way
14:17:46 <David> Clint: I'm just confused... I don't really know enough about ubuntu's package management system to file a bug. It's the first time I've really used it.
14:17:51 <napping> or at least the version specialized to lists
14:18:03 <zalatovo> johnw: I'm guessing merijn is a Dutch name
14:18:09 <johnw> it is
14:18:19 <johnw> Peaker: you may be interested in http://hackage.haskell.org/package/taskpool
14:18:28 <johnw> it does dependency management over async, with propagating exceptions
14:21:21 <Clint> David: i believe it's all done through launchpad
14:26:36 <Peaker> johnw: thanks
14:26:50 <kludgy> c_wraith: Yea unfortunately no luck with http://lpaste.net/109723 :(  Playing around with a number of permutations to trick/guide the compiler but no luck type checking
14:27:27 <c_wraith> kludgy: oh, right.  need ScopedTypeVariables
14:27:41 <kludgy> c_wraith: Yea tried that too.
14:28:12 <c_wraith> http://lpaste.net/109724
14:28:25 <c_wraith> kludgy: ScopedTypeVariables needs you to put the forall in the type signature
14:28:39 <c_wraith> kludgy: which is a little non-obvious
14:29:02 <merijn> What's the best way to implement an action that can be run at most once? MVar (IO ()) combined with tryTakeMVar in the execution?
14:29:16 <latk> Is there some command to download a local copy of a package from hackage ?
14:29:23 <c_wraith> latk: cabal get
14:29:29 <johnw> merijn: use io-memoize?
14:29:32 <latk> c_wraith: Awesome, thanks.
14:29:36 <c_wraith> latk: (or on older versions of cabal, cabal unpack)
14:29:40 <David> thanks for the help guys
14:29:44 <kludgy> c_wraith: f :: forall a. (Show a, Enum a, Bounded a) => Data.Proxy a -> IO () ?
14:29:57 <c_wraith> kludgy: yes.
14:30:17 <Ouyang> I read an article that said not to use tabs in haskell and to use spaces instead.  Is this the common consensus among haskell devs?
14:30:23 <c_wraith> kludgy: err.  Well.  No.  Data.Proxy isn't the name of a data type
14:30:34 <c_wraith> kludgy: just make it "proxy a" for that argument
14:30:35 <latk> c_wraith: If I do this, and modify the file, will cabal preferentially get it from my machine ?
14:30:50 <merijn> johnw: THat doesn't seem to be the right usecase for me :)
14:30:53 <kludgy> c_wraith: ghc 7.8.3 btw, in case that makes a difference.
14:30:57 <hpc> Ouyang: it's about as close as you can get to everyone agreeing on a syntax-related thing in haskell
14:31:13 <hpc> Ouyang: the spec says that tabs should be treated as indentation to the next 8-stop
14:31:24 <merijn> johnw: Or rather, it seems a bit heavy weight
14:31:30 <hpc> so a tab can be anywhere from 1 to 8 spaces, and very few editors render it right by default
14:31:31 <johnw> merijn: then MVar (IO ()) should do it
14:31:48 <c_wraith> latk: depends on a bunch of factors.  If you're using a global cabal repository, it'll be preferred if it's installed.  If you're in a cabal sandbox, you can add-source your version
14:32:02 <merijn> johnw: Basically, I have an "dequeue" operation, which obviously makes no sense to run more than once (since you can only remove something from a queue once)
14:32:07 <Ouyang> so should I hit the enter button 8 times or possibly try to rebind tab to a hotkey?
14:32:26 <kludgy> c_wraith: I'm not sure the forall a. preceding the constraint declaration is correct.. getting error:  Illegal symbol '.' in type
14:32:26 <kludgy>     Perhaps you intended to use RankNTypes or a similar language
14:32:32 <hpc> Ouyang: just don't use tabs
14:32:40 <c_wraith> kludgy: did you enable ScopedTypeVariables?
14:32:51 <kludgy> c_wraith: Yes. I'll repaste so we're on the same page.
14:32:56 <dmj`> Ouyang: https://github.com/tibbe/haskell-style-guide
14:32:59 <hpc> replace tabs with however many spaces it takes to make things align
14:33:22 <kludgy> c_wraith: http://lpaste.net/109723
14:33:48 <c_wraith> kludgy: oh!  pragmas are surrounded with {-# #-} not {- -}.  Easy to miss.
14:33:57 <kludgy> c_wraith: Yes just noticed that ! hah thanks
14:34:37 <kludgy> c_wraith: Perfecto.. thanks for helping spot the typo.. should've clued in when the text editor wasn't syntax coloring
14:34:41 <c_wraith> kludgy: seriously, it is easy to miss.  It was mentioned recently as a source of bugs when NOINLINE pragmas get messed up. :)
14:34:52 <kludgy> c_wraith: good point
14:35:34 <merijn> Good syntax highlighting for haskell highlights pragma and comments different
14:35:48 <c_wraith> kludgy: http://gentoohaskell.wordpress.com/2014/06/16/unsafeperformio-and-missing-noinline/  was the article!
14:36:06 <kludgy> c_wraith: The forall a. has the interesting effect of deferring type errors until execution in ghci.
14:36:12 <latk> I am experiencing pretty intense cabal hell in these past days :s. Are there some guidelines on how it can be avoided ? Best practices and that sort of thing ?
14:36:43 <c_wraith> kludgy: Oh.  It means that the definition compiles, but if you use it improperly you get a compile error at the use site
14:37:01 <c_wraith> kludgy: if you were compiling standalone, it'll all be caught at compile time
14:37:15 <merijn> @where sicp
14:37:15 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
14:37:19 <merijn> latk: Last link there
14:37:44 <dmj`> latk: are you using a sandbox
14:37:52 * hackagebot one-liner 0.4.1 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.4.1 (SjoerdVisscher)
14:38:16 <latk> dmj`: I was, currently trying stackage which does not yet work with them. (it also did not solve my issues :s)
14:38:25 <kludgy> c_wraith: Makes sense, except I think my definition is still wrong :)  For instance: Couldn't match expected type ‘Proxy a0’ with actual type ‘Ordering’
14:38:26 <c_wraith> kludgy: with that definition, you need some sort of type constructor on the type of the value being passed in.  Like...   printEnumPairs (Nothing :: Maybe Int)
14:38:35 <kludgy> c_wraith: (lowercase proxy is not defined)
14:38:47 <c_wraith> kludgy: lowercase proxy unifies with any type constructor
14:39:15 <kludgy> c_wraith: src/Main.hs:9:60: Not in scope: type variable ‘proxy’
14:39:21 <c_wraith> kludgy: that's why I suggested lowercase.  You can use Data.Proxy.  Or you can use anything else you have lying around, like Maybe or []
14:39:54 <dmj`> latk: the more dependencies the higher probability of hell. If you remove all pkg-versions from your cabal file, do a cabal update && cabal install, and it works, just use cabal freeze, it will take everything in your sandbox and write it to a cabal.config file. Check that into version control.
14:40:08 <kludgy> c_wraith: Yea I have to deconstruct the Proxy where the value type is used.
14:40:12 <c_wraith> kludgy: oh!  right, that's a side effect of ScopedTypeVariables
14:40:54 <c_wraith> kludgy: http://lpaste.net/109726 will make it compile.  (add proxy to the forall list)
14:40:57 <kludgy> c_wraith: Murky uncharted corners of the lang :)
14:41:00 <c_wraith> kludgy: I forgot about that.
14:41:21 <kludgy> c_wraith: Oh that actually makes sense thanks.. the error is muisleading
14:42:11 <latk> dmj`: One of the problems I'm having is that packages I use can't work together, so I have to use loads of --allow-newer.
14:42:26 <napping> Does the vinyl library provide a good way to do a field delete?
14:42:45 <napping> I've got a type (fs :~: (k ': fs')) => proxy k -> Rec el f fs -> Rec el f fs', but I think that's a bit too free in the result type
14:43:33 <dmj`> latk: care to post your cabal file?
14:43:57 <kludgy> c_wraith: Still not working though. For instance: Couldn't match expected type 'proxy0 a0' with actual type 'Ordering'
14:44:25 <kludgy> c_wraith: (just using printEnumPairs LT as a test)
14:44:55 <c_wraith> kludgy: try printEnumPairs [LT]
14:44:55 <latk> dmj`: Well the other problem is that I have a library and an executable, that don't seem to work together :s. Basically snap-extras, snap-persistent and timeparsers aren't working together somehow.
14:45:18 <kludgy> c_wraith: Works. Thinking about this..
14:46:40 <kludgy> c_wraith: Algebraic substitution doesn't add up at all for that solution. Not sure how it works.
14:47:27 <c_wraith> kludgy: "proxy a" needs to unify with "[Ordering]".  Lists are kind of a special case, so the latter could also be rewritten as "[] Ordering"
14:47:29 <zerokarmaleft> trying to come up with a dead-simple riak example here and writes are failing due to some internal conversion, not sure why?: http://lpaste.net/109728
14:47:30 <dmj`> latk: sometimes pkgs don't update their upper bounds and you have to prod the author, or you can copy the specific functions from those pkgs into your code. That seems realistic for snap-extras at least. When using snap installing snap-server first seems to make things go smoothly
14:47:48 <c_wraith> kludgy: then "proxy" unifies with "[]", and "a" unifies with "Ordering"
14:48:08 <kludgy> c_wraith: Where can I read up on proxy unification?
14:48:29 <c_wraith> kludgy: that doesn't have anything to do with proxy.  There's nothing special about the name of the type variable.
14:49:07 <c_wraith> kludgy: it's just standard type variable unification involving a type constructor.
14:49:35 <kludgy> c_wraith: There's a big hole in my comprehension here, so I'm looking to fill the gaps.
14:49:42 <c_wraith> kludgy: I named the type variable "proxy" as a hint to the user that the value is never used.
14:49:56 <kludgy> c_wraith: Missing something about the type variable unification involving a type constructor then..
14:50:38 <kludgy> c_wraith: For instance, (minBound :: [] Ordering) doesn't work because there is no Bounded ([] Ordering)
14:50:44 <latk> dmj`: Probably a good idea. I seem to have it working now, with ~8 packages added to allow newer :s
14:51:10 <dalek57> can anyone help me out with haskore? I'm relatively new to haskell, so maybe this isn't the best choice, but I'd really like to learn haskell with music
14:51:38 <kludgy> c_wraith: So how does the substitution of (minBound :: a) where a ~ proxy [] Ordering work?
14:51:39 <dmj`> latk: nice
14:52:01 <c_wraith> kludgy: it's not true that a ~ proxy [] Ordering
14:52:11 <c_wraith> kludgy: it's actually proxy a ~ [] Ordering
14:52:19 <kludgy> c_wraith: interesting!
14:52:48 <c_wraith> kludgy: then it's basically a syntactic breakdown.  Strip things off the right side, assign them to be equal.
14:53:07 <kludgy> c_wraith: So: proxy a ~ [] Ordering implies a ~ Ordering ?
14:53:12 <c_wraith> kludgy: exactly
14:54:01 <kludgy> c_wraith: OK that really helps me understand why the [] type is a proxy whose definition doesn't matter!
14:54:17 <c_wraith> kludgy: and you can do that recursively.  It also implies proxy ~ [].  But since the proxy type is never used in any way, it doesn't matter what it is.
14:54:37 <stolaruk> How can I know whether to use System.IO.Handle or use GHC.IO.Handle ?
14:54:44 <napping> zerokarmaleft: that looks a bit fishy. How are put and get supposed to work?
14:55:37 <c_wraith> kludgy: all that matters is that *something* is present that unifies with proxy
14:56:22 <kludgy> c_wraith: Seems like such a detail deserves first-class treatment in the language syntax eventually.
14:56:42 <c_wraith> kludgy: And the reason to do that is so that you don't actually need a value of type a.  for instance, ([] :: [Ordering]) contains no values of type ordering, even though they are part of the type
14:56:43 <kludgy> c_wraith: I wonder if/how idris is tackling this one?
14:56:54 <yitz> stolaruk: they are one and the same
14:57:07 <stolaruk> yitz: oh ok
14:57:24 <c_wraith> kludgy: In Idris, you could actually pass the type as an argument, instead of a proxy for it.
14:57:32 <kludgy> c_wraith: right..
14:57:50 <c_wraith> kludgy: But in a language where types aren't values, proxies are about the best you can manage.
14:57:50 <kludgy> c_wraith: I think that's the missing link I was expecting in the lang syntax.
14:58:05 <zerokarmaleft> napping: yea, definitely fishy, the resolvable instances are spurious just so I can get it to typecheck...there are various modules where low-level store/retrieval functions differ based on how you want resolution and serialization to occur
14:58:11 <kludgy> c_wraith: It makes sense now. thanks for the help here! Also helps me when teaching others.
14:59:32 <napping> zerokarmaleft: maybe try the Network.Riak.Value.get?
14:59:38 <kludgy> c_wraith: Is there a safer alternative to undefined as a value to promote into proxy types?
15:01:25 <c_wraith> kludgy: yes.  that's exactly what a proxy type is.  You can pass a fully-defined type, and know that undefined isn't involved.
15:01:34 <yitz> @google haskell school of expression
15:01:38 <lambdabot> http://www.amazon.com/The-Haskell-School-Expression-Programming/dp/0521644089
15:01:38 <lambdabot> Title: The Haskell School of Expression: Learning Functional Programming through Mul...
15:02:02 <c_wraith> kludgy: the less-safe alternative is just saying a -> IO (), and passing in undefined
15:04:40 <kludgy> c_wraith: OK sorry to belabour.. so the undefined is still specified in at function application, but the proxy type serves as the convention by which we promise undefined will not be evaluated?
15:05:48 <c_wraith> kludgy: no.  You don't even need an undefined.  That's the whole point.  instead of printEnumPairs (undefined :: Ordering), you say printEnumPairs ([] :: [Ordering]).  (or whatever other type you want the proxy to be made concrete as in your case)
15:08:05 <kludgy> c_wraith: I think I see: The proxy type will always end up being introduced at the top, where there is always concrete evidence. I am choosing to use the Data.Proxy.Proxy convention.
15:08:30 <c_wraith> kludgy: fine.  printEnumPairs (Proxy :: Proxy Ordering), then.  :)
15:08:56 <c_wraith> kludgy: the important part is that you never need to create a value to unify with the type `a`
15:09:23 <kludgy> c_wraith: OK gotcha. Looking into Data.Tagged.Tagged now :P
15:09:45 <c_wraith> kludgy: Tagged a b is sort of the same thing as Proxy a -> b
15:09:57 <kludgy> c_wraith: This all strikes me as being very close to free theorems of sorts.
15:10:08 <c_wraith> kludgy: there are, in fact, conversion functions between the two in the tagged library
15:12:16 <napping> Does anyone here use vinyl much?
15:12:47 <napping> I'm having a bit of trouble trying to do some row-variable-polymorphism type stuff
15:13:02 <napping> I got a field delete working at type (fs :~: (k ': Delete k fs)) => proxy k -> Rec el f fs -> Rec el f (Delete k fs)
15:13:11 <napping> I'd like to tighten the constraint to IElem k fs, if possible
15:13:21 <schell> #haskell-game
15:13:40 <rumham> has anyone ever run into a problem where they can't update Cabel on an Amazon EC2 instance? I'm running out of memory
15:13:42 <schell> ha - sorry - missed /join
15:15:16 <dmj`> rumham: I have that problem when I run cabal on ubuntu in virtualbox, I'm assuming you're using a micro instance?
15:15:17 <koala_man> rumham: I had to add swap on my Google instance to work with haskell
15:15:41 <rumham> yeah, I could use a larger one but I don't wanna pay
15:15:52 <dmj`> rumham: digital ocean
15:16:07 <dmj`> $10/mo 1GB
15:16:25 <rumham> I'm still on the free tier of AWS
15:16:32 <rumham> Adding swap might work
15:16:35 <schell> anyone have a good introduction to free monads?
15:17:08 <schell> or is edwark’s http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Free.html pretty standard?
15:17:11 <merijn> rumham: Why bother compiling remotely anyway?
15:17:25 <merijn> schell: Tekmo had a good write up on his blog
15:17:41 <rumham> I have a Windows laptop and so much stuff just works better on Linux
15:17:48 <dmj`> merijn: assumed he was using it as a build server
15:18:07 <rumham> I don't wanna dual boot cause I need Windows for other things
15:18:10 <schell> merijn: what’s his blog addy?
15:18:12 <merijn> schell: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
15:18:18 <schell> merijn: thanks :)
15:18:21 <merijn> rumham: VirtualBox?
15:18:50 <merijn> rumham: If you have a recent machine (i.e. after 2007 or so) it should support hardware virtualisation
15:18:52 <rumham> it's pretty resource heavy, I used to use VMWare but I like the flexibility of being able to access the dev server from any computer on campus
15:19:10 <rumham> I'm a poor student
15:19:57 <dmj`> rumham: haskell on windows aint that bad
15:20:56 <c_wraith> kludgy: it actually has some relation to free theorems.  You know that the function can't do anything (except call seq) on the value of type proxy a, because it has no clue what type the value is.
15:20:58 <rumham> I know, I use Jekyll for my blog platform and the it doesn't support windows, so I need a dev machine regardless
15:21:13 <merijn> rumham: Sounds like a reason to switch to Hakyll ;)
15:21:14 <rumham> I just figured I'd use it for everything
15:21:34 <merijn> rumham: Also, for cheap students: http://lowendbox.com/
15:21:35 <rumham> is that Jekyll+Haskell? slash does Github support it?
15:21:59 <merijn> rumham: It's a haskell library/framework that's similar to Jekyll, afaik
15:22:08 <merijn> You can just dump static pages on github, yes
15:22:19 <schell> merijn, rumham: hakyll is great
15:22:27 <barrucadu> Hakyll is a bit more hands-on than Jekyll
15:22:57 <schell> it uses pandoc so i think it’s actually much more useful than jekyll
15:23:04 <rumham> interesting, I'll check it out
15:23:05 <merijn> rumham: Here's a Hakyll blog hosted on github: http://www.blaenkdenum.com/
15:23:15 <athan> Hakyll is more stable too, imo
15:23:15 <merijn> rumham: All source for it is in the github link at the bottom
15:23:22 <rumham> in the meantime, I got cabal working with swap space
15:23:55 <schell> for instance, you can maintain your resume as a markdown page and have hakyll output html, latex and pdf versions for your site
15:24:04 <athan> merijn: Whiggity whaaaat??
15:24:08 <rumham> damn, that's nice
15:25:21 <merijn> athan: What?
15:25:26 <schell> i use it for clients who need static websites because it inherits templating through pandoc, and then i get to write haskell for web clients
15:26:22 <schell> it’s kind of a great replacement for wordpress, IMO
15:26:30 <athan> merijn: I had no idea github could host hakyll
15:26:38 <RchrdB> I'm using Hakyll for my personal blog. It's lovely!
15:26:38 <merijn> athan: It's static html
15:26:47 <merijn> athan: github just hosts static html
15:26:58 <merijn> athan: You still need to generate the html on your own machine
15:27:08 <schell> athan: i don’t think it can compile a hakyll site, he’s saying it’ll host the html hakyll produces
15:27:40 <doismellburning> athan: what schell said
15:27:41 <merijn> Compiling hakyll would involve running arbitrary untrusted haskell on their machines, that'd be silly
15:27:49 <dmj`> you can use s3 to host hakyll too
15:27:54 <doismellburning> it has automagic handling for _jekyll_ because it'll run certain bits of Ruby
15:27:55 <dmj`> er, I mean html :)
15:28:11 <merijn> dmj`: Or the lowendbox link I linked earlier
15:28:24 <doismellburning> but basically the beauty of hakyll (and other static site generators) is that you can run them locally to produce html that you can just put nearly anywhere
15:28:29 <dmj`> merijn: yes
15:30:56 <athan> merijn, schell. doismellburning: ahhhhhhhh man. I can still dream, can't I?
15:31:22 <schell> :)
15:54:03 <Peaker> can I tell cabal that some library should only get a static linkage .a and not a .so?
15:54:27 <Peaker> the level-db bindings I've tinkered with build a broken .so file when getting a working .a file would be easier
15:55:10 <dcoutts_> Peaker: not very easily, system linker behaviour is to use the .so in preference when you use -l
15:55:26 <dcoutts_> you can use an absolute path to the .a
15:55:36 <dcoutts_> or you can ask the linker to link everything statically
15:56:01 <merijn> Static link all the things!
15:56:03 <dcoutts_> but we don't (and the system linker doesn't) have a very good mechanism for selective static linking
15:56:10 <orion> thoughtpolice: You around?
15:58:13 <Peaker> dcoutts_: ok, thanks.. just trying to make the leveldb package embed the C++ code within it
15:58:24 <Peaker> Having external C libs is annoying :-(
15:58:31 <merijn> Is there a way to make "cabal repl" also import a bunch of stuff?
15:59:12 <dcoutts_> merijn: meaning what?
15:59:46 <merijn> dcoutts_: Right now if I run "cabal repl" it doesn't actually import any of my libraries modules?
15:59:53 <acebulf> hey guys I'm doing the "write you a scheme" tutorial and I get a parseError on this line
16:00:13 <dcoutts_> merijn: erm, it loads all of them
16:00:16 <acebulf> readExpr :: String -> String
16:00:32 <acebulf> it doesn't like the -> arrow apparently
16:00:42 <dcoutts_> merijn: and you can change that using the usual ghci : commands
16:01:00 <merijn> dcoutts_: I'm getting "not in scope"
16:01:10 <merijn> until I manually "import Foo"
16:01:33 <dcoutts_> merijn: see :show modules
16:02:48 <dcoutts_> merijn: you might want to refer to the ghci docs on what :module etc does, and the difference between compiled and interpreted mode
16:03:36 <dcoutts_> merijn: cabal repl  literally just starts ghci with all the modules declared in the library in the .cabal file
16:03:47 <dcoutts_> it's not otherwise doing anything special
16:03:58 <dcoutts_> (well, apart from the package flags etc)
16:04:30 <merijn> lemme show you the ghci output
16:05:23 * dcoutts_ expects that merijn is using compiled code
16:05:28 <merijn> dcoutts_: http://lpaste.net/109732
16:06:04 <merijn> That doesn't seem right...
16:06:43 <sm> that's the difference between :load and :module/import
16:06:47 <dcoutts_> merijn: try it yourself, use :load
16:07:04 <merijn> What do I load?
16:07:55 <sm> cabal repl does a :load but you have to do the :module/import yourself (or in .ghci)
16:09:42 <merijn> I'm also confused why it compiles every module if I just ran "cabal build" 1s before
16:09:42 <pavonia> sm: So what does import that :load doesn't do?
16:10:10 <sm> pavonia: I honestly can't tell you, stare at the GHCI docs
16:10:35 <sm> it's a bit confusing in practice
16:10:55 <dcoutts_> pavonia: there's a difference between the modules that are in scope at the repl, vs the ones that are loaded
16:11:18 <dcoutts_> loaded just means they're compiled and the code is available to run
16:11:31 <dcoutts_> in this context, you can think of all pre-compiled packages as always loaded
16:11:43 <pavonia> Did that change since GHc 7?
16:12:00 <dcoutts_> possibly, check the user guide
16:12:17 <dcoutts_> (but not that I'm specifically aware of)
16:12:46 <merijn> dcoutts_: Any ideas why it's intepreting rather than loading the compiled objects?
16:12:56 <dcoutts_> merijn: not sure
16:13:51 <sm> ah, I've wondered that too. It seems to do that more than expected
16:14:05 <sm> different GHC options ?
16:17:53 <ezrakilty> Does anyone know if "ghc -e" has started invoking the C compiler to evaluate the expression, in recent versions?
16:18:07 <glguy> Speaking of GHCi, the * modifier on :m can be quite handy but not necessarily known
16:18:54 <merijn> ok, I have more bizarre issues
16:19:18 <sm> glguy: indeed
16:19:22 <merijn> cabal repl maxes out my physical memory (and an extra 4 GB of swapped out memory)...
16:20:10 <dcoutts_> that's rather surprising, ghci shouldn't take that much memory just to load a dozen modules
16:20:19 <dcoutts_> unless they're truly massive
16:20:47 <merijn> They're tiny
16:20:59 <merijn> I'll try just ghci without cabal
16:21:32 <dcoutts_> merijn: run cabal repl -v to see how cabal invokes ghci
16:21:42 <dcoutts_> and then you can play with that command line
16:22:18 <merijn> I don't have an sandboxing or whatever
16:27:20 <merijn> ok, this is really odd
16:27:40 <merijn> Lemme try and screenshot what happens to my system memory
16:28:06 * hackagebot erd 0.1.3.0 - An entity-relationship diagram generator from a plain text description.  http://hackage.haskell.org/package/erd-0.1.3.0 (burntsushi)
16:29:19 <enthropy> @ask int-e could \bot join #vinyl?
16:29:19 <lambdabot> Consider it noted.
16:31:34 <merijn> Is there a way to query how many threads are running?
16:32:10 <sm> you could run threadscope
16:33:08 <sm> but clearly you have too much code, remove bits until things improve
16:34:19 <merijn> Very helpful...
16:35:26 <merijn> System memory usage: http://files.inconsistent.nl/ghci.png
16:35:39 <merijn> The rise starts at the end of some simple example code
16:35:51 <merijn> The drop is when I exit ghci
16:36:11 <merijn> During the peak the virtual memory is at like 18GB
16:43:24 <sm> which code triggers it ?
16:44:40 <proxfox> does Data.ByteString work properly with different kinds of EOL characters? Seems that it just drops \n and leaves CR in front...
16:45:04 <merijn> The library I'm writing right now, but it's like 13 files so feels kinda useless to paste all of it
16:46:52 <merijn> It only happens *after* the code I'm running has actually finished
16:47:43 <hpc> can you add traces to narrow down the slowness to a particular evaluation?
16:47:43 <merijn> So now I'm playing the yak shaving game of installing gtk2 so I can install gtk2hs so I can install threadscope
16:49:01 <zq> so if the underlying representation of Data.Text.Text is an Array of Char, why would character access take O(n)?
16:49:12 <c_wraith> zq: it's not.
16:49:19 <zq> or rather, why is character access be forced to O(n)
16:49:19 <c_wraith> zq: it's an array of Word16
16:49:27 <luite> merijn: and then you find out that you shouldn't have installed the latest gtk2hs since threadscope doesn't compile with that
16:49:28 <zq> c_wraith: my question stands
16:49:30 <c_wraith> zq: holding UTF-16 data
16:49:48 <bitemyapp> Does anyone know who admins the Haskell Google+ page?
16:50:01 <c_wraith> zq: *UTF*-16
16:50:07 <merijn> luite: Oh, whee
16:50:31 <zq> c_wraith: so it's still variable length
16:50:39 <c_wraith> zq: yep
16:51:01 <merijn> luite: I'm open to better debugging suggestions?
16:51:04 <luite> merijn: at least that happened to me when i tried it two days ago, i wanted to try it to see if i missed anything in the ghcjs threadscope
16:51:14 <zq> c_wraith: what are the down sides of encoding to an array of utf-32, apart from twice as much memory used?
16:51:32 <hpc> zq: 4 times as much memory used for ascii ;)
16:51:35 <luite> merijn: well the best thing you can do is run into the same error and then fix it, and tell me how to install your fixed threadscope ;)
16:51:35 <zq> meh never mind
16:51:55 <zq> i really hate being forced into doublethink
16:52:11 <c_wraith> zq: also, there's no UTF-32.  It's not variable-length, so it's UCS-32
16:52:19 <merijn> luite: :(
16:52:43 <int-e> dcoutts, merijn: I think the cabal repl problem is somehow tied to -dynamic-too; as a simpler example, use a single module, M.hs. If I compile  ghc -c -dynamic M.hs, then  ghci M  will load the .o file; if I compile  ghc -dynamic-too M.hs, I get an M.dyn_o file but I don't know how to get ghci to load it.
16:52:44 <luite> merijn: it's probably relatively easy to fix, gtk changed some string handling stuff
16:52:49 <merijn> Plus, even with UCS-32 you don't have constant length
16:53:11 <merijn> int-e: Right now ghci is interpreting everything
16:53:22 <merijn> int-e: It seems to ignore the .o files I just had cabal build
16:53:28 <luite> merijn: so most likely threadscope needs some type sigs or some string conversion function somewhere
16:53:38 <int-e> merijn: it doesn't like those, it wants the .dyn_o files.
16:53:40 <merijn> oh, lemme guess it doesn't have the dist directory in search path?
16:54:09 <int-e> merijn: (well, check ghc --info for ("GHC Dynamic","YES"))
16:54:09 <merijn> If I build a binary (no ghci) I observe the same memory behaviour
16:54:28 <luite> merijn: eventually i'd like to make the ghcjs gui also load normal ghc threadscope files so you can profile stuffs without installing gtk2hs
16:54:36 <merijn> luite: <3
16:54:51 <sm> merijn: elimination is probably the quickest way to debug here, so I was being serious about removing code. Eg first find out if your code is triggering it, or which library is
16:54:56 <luite> yeah not terribly helpful now though :)
16:55:36 <merijn> sm: Except when eliminating code involves rewritng 75% of the library to make everything still function with that code missing
16:55:43 <merijn> All the code that is there has a reason for being there
16:55:54 <merijn> I only just got to the point of being able to actually run something...
16:56:12 <merijn> But since a single binary can reproduce the effect I guess I can profile the binary
16:56:22 <merijn> argh
16:56:25 <sm> you said simply running cabal repl blows up memory
16:56:41 <merijn> sm: No, I said running a bit of code in cabal repl blows up
16:56:57 <merijn> But that code should be using like a few kb of memory TOPS
16:57:00 <sm> ok, well just stub things out until it no longer happens
16:57:18 <merijn> If I stub anything out I can't run this code so nothing will happen
16:58:23 <sm> I think there's a way to do it so that you can make progress towards isolating this
16:58:55 <int-e> merijn: http://lpaste.net/109733 <-- the question is how to get the second 'ghci' command to load the .dyn_hi / .dyn_o file generated by ghc.
17:00:08 <int-e> merijn: the 'cabal repl' call runs into the same problem, I think.
17:00:10 <sm> stub out an api call -> stuff no longer works -> also memory doesn't blow up -> good information
17:00:22 <sm> now move into the lib, and repeat
17:00:23 <merijn> sm: There is only 1 API call
17:01:11 <merijn> "18,008,732,664 bytes allocated in the heap" <- that can't be right
17:01:29 <hpc> what's a few gigs among friends?
17:01:38 <dfeuer> Is int-e here?
17:01:44 <int-e> merijn: that's the total, including collected garbage?
17:03:22 <merijn> int-e: I dunno? That's the first entry it prints upon exit with +RTS -sstderr
17:04:12 <c_wraith> merijn: yes, that isn't concurrent.  That's total.
17:04:46 <merijn> Well, I'm running the heap profiling thingy now, let's see what it says
17:05:18 <int-e> merijn: the maximum residency is, hopefully, quite a bit smaller.
17:05:53 <merijn> int-e: Well, considering it's swapping my entire OS to disk and blowing up my virtual memory usages will into the double digit GB...
17:07:29 <bitemyapp> shapr: thank you :)
17:08:24 <int-e> dcoutts: https://ghc.haskell.org/trac/ghc/ticket/8736 seems relavant to the cabal repl behaviour. Which is unfortunate, because there's no real fix available.
17:09:03 <tm512> coming to haskell from imperative languages is really weird
17:10:19 <linman32> does anyone know what this means? Network.HTTP.Client (needs flag -package http-client-0.3.7.1)
17:13:40 <sm> tm512: enjoy the buzz! :)
17:14:19 <tm512> everything I've learned so far makes sense
17:16:53 <merijn> Where do I get hs2ps from? (To visualise memory profiling)
17:18:10 <int-e> merijn: isn't that tool called hp2ps?
17:18:28 <merijn> oh, maybe I fail at reading? :)
17:21:17 <kini> so System.Process is the standard way to spawn subprocesses, I gather, but what's the standard haskell way to do an exec system call?
17:22:28 <hpc> ... i hoogled exec and got a whole bunch of Monad run actions
17:22:31 <john_not_jenny> System.Posix.Process?
17:22:32 <hpc> i don't know what i expected
17:24:42 <merijn> hmmm
17:24:53 <merijn> Well, this doesn't look like a healthy memory usage graph
17:25:06 <merijn> http://files.inconsistent.nl/Main.pdf
17:25:24 <merijn> Any clues how I can trace what PINNED is?
17:27:59 <hpc> https://ghc.haskell.org/trac/ghc/ticket/7275
17:28:27 <hpc> looks like bytestrings count under PINNED
17:28:51 <hpc> and the profiler doesn't currently have the ability to give more detail
17:28:55 <merijn> :\
17:28:58 <merijn> Well that sucks
17:29:08 <merijn> How am I supposed to figure out wtf is going on?
17:29:27 <hpc> give it the ol' php try
17:29:32 <hpc> mess around with it until good stuff happens
17:30:14 <hpc> (that's only half joking; sometimes even deleting swaths of code and rewriting them works because you accidentally fix a subtle bug via retyping)
17:32:13 <merijn> hpc: I don't have swaths of code I can delete :(
17:32:21 <merijn> I have the bare minimum I need to actually run something
17:32:56 <tm512> in my code I usually just throw printfs everywhere
17:33:05 <tm512> I guess you can't do that though
17:33:22 <exio4> Debug.Trace
17:33:30 <int-e> tm512: there's Debug.Trace but it doesn't help with memory leaks
17:37:50 <tm512> I just started learning like a few hours ago, so forgive my ignorance, but aren't traces less useful in a functional language?
17:37:55 <cub-uanic> hi all, i'm newbie in haskell & xmonad, so sorry in advance for may be dumb questions. i want to define keybinding which will "sendMessage Shrink" or "sendMessage MirrorShrink" depending on current layout. how i can do that?
17:39:14 <merijn> tm512: They tend to be, yes. But Debug.Trace is still pretty handy for debugging (although I don't need it the much)
17:39:22 <hpc> tm512: they're weirder in haskell because it's lazy
17:39:25 <hpc> and pure
17:39:45 <hpc> so you either do your prints in IO instead of wherever you want
17:39:45 <merijn> Well, maybe not less useful, but more confusing
17:39:54 <hpc> or you use Debug.Trace which is tied to evaluation
17:40:12 <tm512> from the bit of ghci fiddling I've done so far there isn't a clear path of execution like there is in C
17:40:16 <hpc> so they aren't necessarily spat out in the order or timing you'd expect
17:40:16 <merijn> @quote cmccann adhd
17:40:16 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
17:41:36 <tm512> it feels more like "this is that" instead of "this does that"
17:41:46 <trap_exit> [soft question] : when working on large scale haskell projects, do people tend to (1) build end to end system first, even if not all types are complete ... then fill in the types later or (2) try to get each data type right, and hope that everything fits together?
17:42:48 <hpc> trap_exit: it depends
17:43:04 <merijn> trap_exit: I define lots of datatypes and function types with empty implementations, refactoring as I go
17:43:21 <merijn> And then start slowly filling in functions (by defining more datatypes/functions with empty implementations)
17:43:26 <trap_exit> merijn: yeah, I use lots of blah = error " ... " quite a bit
17:43:31 <merijn> i.e. figure the types out first, worry about implementation later
17:43:32 <trap_exit> but I'm nto sure about "not specifying in data types"
17:43:43 <merijn> trap_exit: Oh, I specify datatypes
17:43:58 <merijn> trap_exit: Also, GHC 7.8 has typed holes, use those instead of error!
17:44:04 <merijn> You can't forget to remove them
17:44:13 <trap_exit> so you don't do things like "data SvgNode = SvgNode" ... then later rewrite it as "data SvgNode = SvgRect ... | SvgLine ... | SvgText ... "
17:44:24 <tac> but merijn, holes don't let you supply an error message!
17:44:26 <Iceland_jack> merijn: I use them to check for types, if I put them into every undefined function the output gets too noisy
17:44:35 <merijn> tac: They have compile time warnings...
17:44:42 <trap_exit> tac: most of my error messages are of the form "implement me"
17:44:50 <tac> heh, merijn what trap_exit said :P
17:45:00 <merijn> Iceland_jack: Yeah, I'm campaigning for a "enable holes but don't print warnings" flag
17:45:06 <Iceland_jack> ah right
17:45:19 <tac> sometimes there are legitimate cases when you can say "if you get here, well nuts!".
17:45:23 <sm> tm512: I use trace (print) statements much *more* in haskell, since interactive debugging is less available
17:45:30 <tac> but yeah, I should learn Haskell's holes
17:45:41 <merijn> tac: They're like the simplest thing ever
17:45:42 <Iceland_jack> yes _ is quite nice to type, it would be cool to be able to write
17:45:42 <Iceland_jack>     foo :: a -> a
17:45:42 <Iceland_jack>     foo
17:45:42 <Iceland_jack> to specify a funnction stub
17:45:47 <merijn> tac: Prefix a variable with a _
17:45:49 <merijn> tac: Done
17:45:54 <tac> oh good
17:45:55 <trap_exit> let me see if I get holes correctonly
17:46:04 <trap_exit> the idea is "_" can occur outside of pattern matching <-- this is the entireity of holes right?
17:46:10 <Iceland_jack> :t ord _foo
17:46:11 <merijn> tac: Any _ prefixed identifier that is not in scope is treated as a hole
17:46:11 <lambdabot>     Found hole ‘_foo’ with type: Char
17:46:13 <lambdabot>     In the first argument of ‘ord’, namely ‘_foo’
17:46:15 <lambdabot>     In the expression: ord _foo
17:46:21 <tac> gotcha
17:46:23 <Iceland_jack> trap_exit: See above ↑
17:46:45 <trap_exit> ohhh
17:46:53 <Iceland_jack> lambdabot doesn't display more than one type hole
17:46:56 <Iceland_jack> but you can do
17:46:56 <Iceland_jack> :t ord _ch + _int
17:46:57 <lambdabot>     Found hole ‘_ch’ with type: Char
17:46:57 <lambdabot>     In the first argument of ‘ord’, namely ‘_ch’
17:46:57 <lambdabot>     In the first argument of ‘(+)’, namely ‘ord _ch’
17:47:05 <Iceland_jack> to distinguish between the two holes
17:47:17 <merijn> I'm baffled why my fairly trivial program is taking up over 1GB of RAM :(
17:47:35 <Iceland_jack> But you should get
17:47:35 <Iceland_jack>     Found hole ‘_ch’ with type: Char
17:47:35 <Iceland_jack>     …
17:47:35 <Iceland_jack>     Found thole ‘_int’ with type: Int
17:51:52 <tabemann> I need a good name for my IRC client
17:52:02 <merijn> Is there a way to see space allocation by function/callsite?
17:52:07 <trap_exit> tabemann: IO (Text)
17:52:16 <Iceland_jack> tabemann: SmIRC
17:52:26 <merijn> I mean, it's nice to see 2 GB worth of ARR_WORDS allocted, but that's not helpful if I dunno what is allocating them
17:52:40 <trap_exit> actually
17:52:40 <trap_exit> maybe IO [Text]
17:52:46 <tabemann> I'll go with HsIRC, considering one of its points is being scriptable in Haskell
17:52:49 <trap_exit> what is IRC but an IO op that returns a list of Text ?
17:53:42 <tabemann> dammit
17:53:47 <tabemann> someone already named something HsIRC
17:54:16 <tabemann> just an IRC client library for IRC rather than a full-fledged client with a UI and scripting capabilities and so on
17:54:18 <trap_exit> NOOOOOOO
17:54:21 <trap_exit> my 17" mbp has dead pixels
17:54:45 <tabemann> SmIRC is also taken too
17:54:50 <Markz> deserved for getting a mbp
17:54:57 <Markz> I'm just jealous
17:55:16 <Markz> sitting here with an external keyboard connected to my laptop coz I broke it
17:55:21 <tabemann> hIRC is not taken, luckily
17:55:26 <Markz> I want to be freeee
17:55:33 <linman32> hi i have hidden package errors. what is work around? http://lpaste.net/109734
17:55:50 <tac> tabemann: You mean something competing with, say, simpleirc?
17:55:50 <tm512> >not using second-hand thinkpads
17:55:58 * tac 's bot uses simpleirc and it's pretty usable.
17:56:08 <Iceland_jack> tabemann: 'biðlari'
17:56:16 <trap_exit> MarKZ: I'm getting ot the point where I think the perfect laptop
17:56:21 <trap_exit> is an ipad + a bluetooth keyboard case
17:56:32 <trap_exit> if only I could run emacs on the ipad and ssh into server to compile haskell
17:57:58 <tabemann> tac: someone actually named their IRC client SmIRC
17:58:33 <merijn> mmm
17:59:15 <linman32> i may have been invisible
17:59:16 <linman32> hi i have hidden package errors. what is work around? http://lpaste.net/109734
18:02:09 <tabemann> noooo there's an IRC client out there named hirc already
18:02:40 <tac> why not hiccup?
18:02:41 <tabemann> I'll do shIRC then, for Scriptable Haskell IRC
18:03:03 <tabemann> no that's taken too
18:03:09 <tac> oh man
18:03:13 <tabemann> for an IRC client literally written in shell
18:03:37 <tabemann> it seems like every possible name for an IRC client is already taken
18:03:38 <Iceland_jack> If I saw 'shIRC' I would think "shell IRC client"
18:03:51 <Iceland_jack> tabemann: YetAnotherHaskellIRCClient
18:04:01 <Markz> It's as if loads of people write IRC clients
18:04:03 <[swift]> ircH?
18:04:19 <tm512> you could just give it a name unrelated to IRC
18:04:20 <Markz> wait what am I doing... IRC pokerbot
18:04:44 <tabemann> okay, yahsIRC - Yet Another Haskell IRC
18:04:45 <tm512> I was going to write an IRC bot for an intro to haskell
18:04:49 <tabemann> yahsIRC isn't taken
18:05:23 <Iceland_jack> > iterate ("y"++) "yahsIRC"
18:05:25 <lambdabot>  ["yahsIRC","yyahsIRC","yyyahsIRC","yyyyahsIRC","yyyyyahsIRC","yyyyyyahsIRC",...
18:05:34 <Iceland_jack> ... ('y':)
18:08:04 <tabemann> I've written an IRC bot in OCaml before, but never something like a scriptable multiserver IRC client
18:08:20 <linman32> how do i make a hidden package in a sandbox, exposed?
18:08:44 <tac> linman32: probably cabal sandbox hc-pkg expose <packagename>
18:08:49 <merijn> oH!
18:09:07 <tac> tabemann: If you put your code on github or bitbucket, I'd be interested in following it :)
18:09:10 <merijn> I think I may know where the leak is, although I'm still not sure how it could possibly keep growing infinitely
18:09:16 <geekosaur> note that in most cases that really means you want to add the paqckage to your cabal file
18:09:20 <tac> I need to make sure I am on top of Haskell IRC technology :D
18:09:24 <Markz> can we see the code merijn?
18:09:33 <merijn> oh...
18:09:54 <merijn> Markz: It's 900 lines in 13 modules, so perhaps a bit much :)
18:09:58 <linman32> tac: it says unkown 'sandbox' subcommand
18:10:21 <tabemann> I should get myself a github account
18:10:26 <Markz> not really, github it
18:10:28 <tabemann> that first would require me learning how to use git
18:10:47 <tabemann> I'm used to using SVN myself
18:10:56 <merijn> tabemann: I have a good solution :)
18:11:11 <merijn> tabemann: Learn Mercurial, it's much easier to learn and then just use hg-git to interact with github :)
18:11:18 <tac> And you used 'cabal sandbox', right??
18:11:42 <merijn> Markz: I'm just checking one thing and then I may have the abridged bug report for you :p
18:11:43 <linman32> tac: cabal sandbox ghc-pkg expose bytestring
18:11:57 <tac> tabemann: distributed version control is pretty neat and is pretty much how everyone does open source now.
18:13:51 <solatis> tabemann: it cannot hurt to learn git, seriously -- in fact, i'm amazed at the amount of people that haven't learned about DVCS's by now
18:13:53 <tabemann> okay, I'll learn to use git
18:14:41 <tm512> not using a dcvs makes it more difficult to contribute to your project
18:15:00 <ChuckRoz> Git is a real pain at first. Once you get a handle on it though, it's incredibly useful
18:15:14 <ChuckRoz> Plus every single employer ever wants to see your github now
18:16:22 <linman32> tac: i added package to .cabal and it works. why wouldn't it automatically add it?
18:17:26 <tabemann> stupid design question - I want to put all of my types in a single module to avoid intermodule dependency problems, but I want to hide the interface to these types to my scripts loaded via System.Eval.Haskell
18:17:31 <tac> sry gotta run :X
18:17:37 <merijn> argh
18:17:38 <merijn> ffs
18:17:48 <halvorg> Which HTTP library should I use if I want a simple backend https rest server?
18:17:54 <tabemann> do I have to put *all* my accessors to those types in that single module then?
18:17:58 <Hafydd> gotta run :!
18:18:05 <merijn> Markz: Right, so I know the issue now. I was using hGetSome to read from a socket. hGetSome return an empty ByteString if the socket closes
18:18:16 <halvorg> I'm looking at happstack atm, but the docs are very focused on templating. Which is not something we'll do much of, if any.
18:18:29 <merijn> Markz: The pipes-binary library apparently changed and no longer terminates upon receiving an empty ByteString
18:18:46 <merijn> Markz: And a strictness leak somewhere else was keeping *ALL* input in memory
18:19:16 <merijn> Markz: End result: an infinite amount of empty ByteString appended to each other at a rate as fast as my thread can loop reading from the socket...
18:21:38 <Markz> cheers
18:23:53 <merijn> oh
18:24:08 <merijn> It's binary that changed to take "Maybe ByteString" as input in the incremental interface
18:38:03 <tac> halvorg: Have you looked at wreq for HTTP(S)?
18:39:49 <merijn> Compare these two memory usage graphs: http://files.inconsistent.nl/before.pdf
18:39:57 <merijn> http://files.inconsistent.nl/after.pdf
18:42:30 <tabemann> does anyone know anything about determining what classes System.Eval.Haskell.eval_ can see and what it cannot?
18:43:48 <tabemann> and actually, I realized I don't need accessors for my data types
18:44:37 <tabemann> well, maybe not
18:45:01 <tabemann> as I do want to restrict the range of state changes scripts can make, so they cannot modify arbitrary state
19:01:05 <Raynos> Hello type people. Is there a good document explaining how intersection types might work in a typed language (not specifically haskell)
19:03:10 <tac> Raynos: I want to say TaPL has a chapter on it
19:03:16 <tac> Types and Programming Languages by Benjamin Pierce.
19:03:32 <tac> it's very brief, it looks like
19:04:08 <tm512> http://hastebin.com/elapuqofiv.hs my first haskell function
19:05:12 <Raynos> specifically I'm interested in how you might intersect a concrete type and a generic type
19:07:13 <tac> what do you mean by 'generic' type?
19:07:34 <tabemann> I assume generic means parametric polymorphism
19:07:46 <tac> You probably wouldn't want to!
19:08:16 <minecrater1> hey all....i have a random question if anyone knows...I'm on a Mac...any idea how I can convert a pretty large PDF to  word.doc?
19:09:42 <mjrosenb> attoparsec question: I am parsing a file with a bunch of lines.  Is it faster/better to split it into lines, then parse each line individually, or to just let attoparsec handle the newlines?
19:10:16 <tabemann> I am not aware of there being a general way to convert PDFs to Word docs, especially since many PDFs are essentially collections of images in cases
19:10:36 <Markz> push it through google docs maybe
19:11:46 <mjrosenb> minecrater1: why exactly do you want to do that?
19:13:17 <minecrater1> mjrosenb: silly really...my wife who's a professional photographer needs to manipulate a rather large PDF to change pictures/text to tailor it to her business
19:13:25 <minecrater1> forgive my shitty IRC syntax im a beginner
19:14:06 <mjrosenb> minecrater1: that looked fine to me.
19:14:08 <Raynos> tac: generic I mean intersection of a record and a Map
19:14:50 <mjrosenb> minecrater1: I suspect you'd have better luck getting something that can just extract .jpg's from the pdf, then re-assemble them however you want in the gimp/photoshop/etc.
19:14:56 <Raynos> a Map is a generic type and a record is a concrete type. I'm trying to find a way to define a complex type for a complex blob of JSON.
19:15:04 <tabemann> apparently Adobe Acrobat can convert PDF to Word
19:15:23 <benzrf> tabemann: that is a disgusting setence
19:15:28 <benzrf> *sentence
19:15:36 <minecrater1> tabemann: yeah but that'd require paying for it in some manner apparently
19:15:42 <tabemann> yes
19:16:20 <Markz> heh, was trying out going thru google docs but it just converts to images, thought it did text
19:16:26 <Markz> but it crashed my firefox :(
19:16:43 <mjrosenb> Markz: it really shouldn't be doing that in browser.
19:16:47 <minecrater1> haha damn
19:16:58 <Markz> ?
19:17:01 <minecrater1> i was about to do it in google drive too, or at least attempt
19:17:13 * tabemann doesn't think converting to Word is a great idea unto itself himself
19:18:37 <minecrater1> ?
19:20:40 <mjrosenb> minecrater1: do you have photoshop? evidently, photoshop can extract images from pdfs.
19:20:53 <mjrosenb> also, Data.Text.lines says it is O(N)
19:20:54 <Markz> mjrosenb: what was your comment about the browser referring to
19:20:58 <mjrosenb> it is still lazy, right?
19:21:13 <mjrosenb> Markz: I mean it should be doing any conversions on the server, not on your local machine.
19:21:34 <Markz> probably
19:21:42 <minecrater1> mjrosenb: I do, not quite sure how I'd go about atht though
19:22:15 <minecrater1> even after I got the image
19:22:24 <mjrosenb> minecrater1: dunno, I'd try just opening the .pdf in photoshop.
19:32:00 <mjrosenb> @hoogle String -> Text
19:32:03 <lambdabot> Data.Text.Lazy pack :: String -> Text
19:32:04 <lambdabot> Data.Text pack :: String -> Text
19:32:04 <lambdabot> Prelude read :: Read a => String -> a
19:32:50 <dddfffd> how can I take 6 bits from a [GHC.Word.Word8] list, or Word8 in general?
19:34:42 <mjrosenb> dddfffd: .&. 0x3f ?
19:40:21 <mjrosenb> (One reason for this policy of replacement is that internally, a Text value is represented as packed UTF-16 data.
19:40:24 <mjrosenb> eww.
19:40:33 <mjrosenb> this does not sound suitable.
19:40:56 <nshepperd> UTF-16 whyyy
19:41:32 <shachaf> I think the main reason is ICU compatibility.
19:41:38 <Markz> ICU?
19:41:46 <shachaf> ICU.
19:42:11 <mjrosenb> internationalization library.
19:42:19 <mjrosenb> occasionally the bane of my existence.
19:42:25 <nshepperd> intensive care unit?
19:43:27 <nshepperd> I don't get it, UTF-16 is neither fixed size nor particularly efficient
19:43:27 <mjrosenb>      Homepage:            http://www.icu-project.org/
19:43:27 <mjrosenb>      Description:         International Components for Unicode
19:43:43 <Iceland_jack> Reason for UTF-16 is mostly speed
19:43:47 <Iceland_jack> it's detailed in the paper
19:44:24 <shachaf> UTF-16 is the scow of Unicode encodings in many ways.
19:45:06 <systemfault> utf-16 is a necessary evil.
19:45:12 <coppro> it's not necessary
19:46:09 <mjrosenb> gah, does ByteString not have a 'lines' function?
19:46:21 <systemfault> Windows and Java where created with UCS2 support... so once 32bit unicode appeard... 16bit were not enough to reprensent all the characters anymore, so that's where utf-16 came in.
19:46:41 <coppro> sure. but why bother with a 16-bit encoding anyway?
19:47:00 <Iceland_jack> UCS2 made sense at the time
19:47:06 <coppro> sure, but now it's pointless
19:47:12 <systemfault> coppro: utf-16 is the migration path from UCS2
19:47:19 <Iceland_jack> Yes, but UTF-16 doesn't use 16-bits
19:47:20 <vkbsh> Trying to write an IM client: why doesn’t this work?
19:47:21 <vkbsh> forkIO $ fix $ \loop_in -> do
19:47:21 <vkbsh>   msg_in <- hGetLine handle
19:47:22 <vkbsh>   putStrLn(msg_in)
19:47:24 <vkbsh>   loop_in
19:47:26 <vkbsh> forkIO $ fix $ \loop_out -> do
19:47:28 <vkbsh>   msg_out <- getLine
19:47:30 <systemfault> coppro:What do you suggest, rewrite the whole OS to use utf-8?
19:47:30 <vkbsh>   hPutStrLn handle (msg_out)
19:47:31 <mjrosenb> coppro: it is more likely to have uniform size than utf-8.
19:47:32 <vkbsh>   loop_out
19:47:34 <shachaf> vkbsh: Please don't paste more than a few lines in the channel at once.
19:47:41 <Iceland_jack> vkbsh: Please use lpaste
19:47:42 <shachaf> Use hpaste.org instead.
19:47:58 <vkbsh> My bad
19:48:03 <coppro> mjrosenb: if you need uniform size, use utf-32
19:48:14 <shachaf> To the question you asked: You tell us.
19:48:17 <Iceland_jack> coppro: UTF-16 is a good middleground
19:48:22 <coppro> systemfault: yes. Do it in a major version upgrade
19:48:26 <systemfault> utf-8 is the best...
19:48:29 <coppro> UTF-16 has none of the benefits of -8 or -32
19:48:30 <shachaf> coppro: I don't think you need to convince mjrosenb to dislike UTF-16.
19:48:31 <Markz> but utf-32 isn't uniform size in the future
19:48:43 <Iceland_jack> coppro: Read the paper on Text if you want the reasons
19:48:44 <Markz> may aswell just utf8
19:48:44 <shachaf> But I don't think this argument will get anywhere useful, so it's probably best not to have it here.
19:48:56 <systemfault> coppro: Not if you're Microsoft... That would kill the support for all the older applications.
19:48:57 <mjrosenb> coppro: except that it is nearly always half the size of utf-32.
19:49:08 <coppro> Iceland_jack: link?
19:49:22 <coppro> mjrosenb: and nearly always bigger than utf-8
19:49:26 <systemfault> utf-8 is the best imho..
19:49:47 <carter> all these claims need empirical statistics :)
19:49:52 <mjrosenb> coppro: yes, but there are plenty of strings that aren't uniform in utf-8 that are uniform in utf-16.
19:50:10 <systemfault> I see utf-16 as a pragmatic solution for platforms that originally used UCS2..
19:50:18 <Iceland_jack> (keep in mind that being good for user consumptions does not mean that an encoding is good for string internals)
19:50:36 <Iceland_jack> coppro: I think this was it https://www.cs.ox.ac.uk/files/3929/dissertation.pdf
19:50:51 <nshepperd> 'more likely to have uniform size' seems mostly useless
19:50:51 <Iceland_jack> If features the code and benchmarks for UTF8 and UTF16 implementations
19:51:41 <nshepperd> although I guess you can put a flag bit on each Text value saying whether it is in fact uniform size, that would let you "often" O(1) index
19:51:54 <mjrosenb> nshepperd: yup!
19:52:43 <Iceland_jack> Encoding UTF-8 values is quite a bit more expensive than UTF-16 values
19:53:30 <shachaf> You can also keep a sparse bit string using your favorite encoding that lets you index your UTF-8/UTF-16 string very quickly for the common case.
19:54:57 <mjrosenb> shachaf: I'm not entirely sure how that would work.
19:55:14 <Goplat> if you really need random access to the nth character of a text string, you're doing something horrible
19:55:22 <Markz> how many uses are there for indexing though
19:56:45 <mjrosenb> Goplat: iirc, xmpp does something like that.
19:57:03 <nshepperd> well, the main use of indexing is probably actually slicing
19:57:54 <mjrosenb> also, a number of years ago, the icfp /really/ wanted sub-linear string operations, slice included.
19:58:00 <mjrosenb> but the answer there was 'ropes'
19:58:16 <Goplat> text is for human-readable data. Humans are slow at counting characters, so if your format/protocol requires counting characters, it's badly designed
19:59:09 <Goplat> Slicing just needs an abstract notion of position within a string, which doesn't have to be characters, it can just as easily be bytes (or shorts in the case of UTF-16)
19:59:14 <mjrosenb> Goplat: Humans are also bad at making sure that parenthesis and various braces match.
19:59:30 <shachaf> Goplat: But Text doesn't even give you that.
19:59:38 <mjrosenb> Goplat: yes, but efb.
20:00:29 <tabemann> stupid System.Eval.Haskell question - for imports, what format does it load them in? source? .so? precompiled into the executable? (implied by example code I've seen that has loaded "Prelude" without a search path for any potential Prelude.so)
20:00:47 <nshepperd> you probably don't want to slice halfway through a surrogate pair
20:01:05 <shachaf> nshepperd: Yes, hence "abstract notion".
20:01:18 <Goplat> nshepperd: and you won't, if you use offsets that you previously got from iterating through the string properly
20:01:20 <shachaf> It would be a good API feature. But Text doesn't provide it.
20:01:26 <mjrosenb> nshepperd: but it'll be /so great/ when you paste strings together afterwards!
20:01:34 <mjrosenb> /home/mjrosenb/projects/dedup.hs:36:17: Not in scope: ‘hexadecimal’
20:01:36 <mjrosenb> really?
20:01:41 <mjrosenb> asses.
20:02:13 <shachaf> ?
20:03:31 <mjrosenb> shachaf: I am using Data.Attoparsec.ByteString.Lazy, and it looks like that isn't defined.
20:03:47 <mjrosenb> do I need to import Data.Attoparsec.ByteString as well?
20:04:19 <athan> Ugh. Why is Yesod converting all quotation marks in javascript to &quot;? .-.
20:04:29 <shachaf> I don't know.
20:04:46 <athan> toWidget is doing it... D:
20:04:59 * mjrosenb is not horribly clear on how interchangable Data.ByteString and Data.ByteString.Lazy are.
20:05:21 <mjrosenb> actually, this may not need lizisenn
20:05:27 <mjrosenb> ho god, fingers
20:05:29 <mjrosenb> *laziness
20:05:51 <athan> oh ho god, lend me thy.... nevermind.
20:06:16 <mjrosenb> @hoogle Char -> Word8
20:06:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:06:19 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
20:06:19 <lambdabot> Prelude error :: [Char] -> a
20:06:27 <shachaf> :-(
20:06:35 <Iceland_jack> mjrosenb: Why do you need that function..?
20:06:39 <mjrosenb> uhh... what?
20:06:46 <Iceland_jack> A function from 'Char -> Word8'
20:07:00 <mjrosenb> Iceland_jack: ByteString.split takes a Word8 as its parameter.
20:07:05 <mjrosenb> I want to split on '\n'
20:07:18 <Iceland_jack> @ty BSC.split
20:07:19 <lambdabot> Char -> BSC.ByteString -> [BSC.ByteString]
20:07:21 <Iceland_jack> takes a Char
20:07:25 <shachaf> Word8 is like uint8_t, a byte. Char is a Unicode code point.
20:07:30 <Iceland_jack> but be careeful
20:07:31 <athan> :t encodeUtf16BE . unpack
20:07:32 <lambdabot> Not in scope: ‘encodeUtf16BE’
20:07:32 <lambdabot>     Not in scope: ‘unpack’
20:07:32 <lambdabot>     Perhaps you meant one of these:
20:07:33 <shachaf> Maybe you want to split on the byte 10?
20:07:52 <Iceland_jack> *be careful
20:07:57 <nshepperd> :t fromIntegral . ord
20:07:58 <lambdabot> Num c => Char -> c
20:07:59 <mjrosenb> Iceland_jack: https://gist.github.com/84de48e161b2db4c4827 ?
20:08:53 <Iceland_jack> mjrosenb: If you're sure you want this, use Data.ByteString.Char8
20:08:56 <Markz> BSC = Data.ByteString.Char8
20:09:09 <mjrosenb> ahh.
20:10:03 <ericjones> Is there something about Data.Generics and using Generics to derive type classes that slows compilation?
20:10:19 <mjrosenb> cool, and Data.ByteString.Lazy.Char8 exists!
20:11:12 <mjrosenb> but attoparsec does not know about ByteString.Lazy.Char8 :-(
20:11:16 <Iceland_jack> Note that '\n' will become the byte as Ċ
20:11:52 <shachaf> I think you should take a step back and figure out what all these libraries and modules and types mean and what they do.
20:12:10 <mjrosenb> Iceland_jack: as ċ?
20:12:19 <Iceland_jack> mjrosenb:
20:12:19 <Iceland_jack> > BSC.pack "Ċ"
20:12:21 <lambdabot>  "\n"
20:12:21 <shachaf> For example, if you want Unicode compatiblity, you almost certainly shouldn't be using anything called .Char8. Those modules are Unicode-broken.
20:12:42 <mjrosenb> shachaf: I care 0% about unicode compatability.
20:12:43 <shachaf> And if you are using these modules, you should know that Data.ByteString.{Char8,}.ByteString are the same type.
20:12:54 <shachaf> And so on.
20:13:11 <ericjones> I have encountered a module that compiles very slowly and all it is doing really is deriving a bunch of typeclasses for a given type
20:13:39 <mjrosenb> shachaf: I am not that surprised about that.  I'm guessing the .Char8 is just giving it a more C-string-like interface?
20:14:12 <mjrosenb> wherease ByteString.Lazy is a very different beast.
20:14:27 <shachaf> I wouldn't say that.
20:15:08 <shachaf> Some of the distinctions are a bit involved and won't be resolved by the greedy algorithm of "use the first thing with a reasonable-looking name that type-checks".
20:15:41 <tabemann> http://lpaste.net/109739
20:16:19 <Iceland_jack> > text $ take 1000 $ map chr $ map (+ ord '\n') (iterate (+ 256) 0)
20:16:21 <lambdabot>  ĊȊ̊ЊԊ؊܊ࠊऊਊଊఊഊช༊ညᄊሊጊᐊᔊᘊᜊ᠊ᤊᨊᬊᰊᴊḊἊ ℊ∊⌊␊┊☊✊⠊⤊⨊⬊Ⰺⴊ⸊⼊《ㄊ㈊㌊㐊㔊㘊㜊㠊㤊㨊㬊㰊㴊㸊㼊䀊䄊䈊䌊䐊䔊䘊䜊䠊䤊䨊䬊䰊...
20:16:22 <Iceland_jack> > BSC.pack $ take 1000 $ map chr $ map (+ ord '\n') (iterate (+ 256) 0)
20:16:23 <lambdabot>  "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\...
20:18:28 <mjrosenb> shachaf: but if I am dealing with /strictly/ characters between 0x10 and 0x7a, they shuold be the same?
20:18:29 <Zenof> Name: Raymond D Albers (aka Ray D Albers) / Age: 46 / DOB: 1968/05/29 / SSN: 497-88-1819 | Credit report - http://rghost.net/57578827 / Phone Number: 636-936-8896 or (636) 441-1637 / Current Address: 958 S Brampton DR / City: Saint Charles / State: MO / Zip: 63304
20:18:39 <Iceland_jack> Should have written
20:18:39 <Iceland_jack>     map chr $ iterate (
20:18:48 <shachaf> mjrosenb: They aren't the same, the types are different.
20:18:49 <Iceland_jack>     map chr $ iterate (+ 256) (ord '\n') -- oh well
20:18:54 <shachaf> And the sorts of things you can do are different.
20:18:55 <charlie> lol
20:19:45 <mjrosenb> anyhow, I can't test it because Data.Attoparsec.ByteString.Lazy is missing the primary function that I'm using it for.
20:20:35 <tabemann> does anything know what's going on with my System.Eval.Haskell example?
20:20:49 <tabemann> *anyone
20:21:55 <mjrosenb> tabemann: that's a neat trick.
20:22:46 <tabemann> except it isn't working for some reason
20:23:22 <mjrosenb> tabemann: what package gives System.Eval?
20:23:58 <tabemann> plugins
20:26:28 <mjrosenb> so, has anyone used Attoparsec before?
20:26:48 <mjrosenb> (and can help me use it)
20:27:17 <nitrix> Some people asked me recommendations for a first language to learn programming. I really wanted to asnwer Haskell, but I felt like it was wrong.
20:27:39 <Welkin> nitrix, it is not wrong
20:27:45 <Welkin> haskell is a great first language
20:27:50 <nitrix> You have to experience the other main stream languages first, understand their pitfalls in my opinion before you can make sense of Haskell and truly see its beauty.
20:27:54 <Welkin> you don't need to use all of the advanced features andl ibraries
20:28:21 <tabemann> you'll learn bad habits programming in other languages, though, one could argue
20:28:34 <Welkin> I agree
20:28:50 <julianb> Welkin, I think that to truly appreciate haskell's beauty, you first need to experience imperative programming
20:28:53 <Welkin> in languages like python people learn terrible habits
20:28:56 <nitrix> Doesn't it "forge character", if you still follow my train of thoughts ?
20:29:16 <mjrosenb> nitrix: it depends what their background is.
20:29:26 <mjrosenb> if they have a strong math background, haskell is perfect.
20:29:59 <nitrix> I've heard of a lot of people trying Haskell, then moving to imperative programming and then, slowly picking functional programming and eventually Haskell again to stop at it.
20:30:11 <nitrix> But over the course of 10~15 years.
20:30:28 <Markz> someday I hope to appreciate the beauty
20:30:55 <Welkin> before I discovered functional programming and haskell, I was always dissatisfied with how messy my code became for simple things like games
20:30:57 <tabemann> I learned OCaml, tried Haskell for a bit, then stuck with OCaml for a while until I eventually switched to Haskell completely
20:31:31 <Welkin> this sounds like an infomercial, but it's what happened
20:31:39 <Welkin> same with web applications
20:31:47 <nitrix> Welkin: I'm still with you. Been doing games and as far as I can tell, this will be a game changer for me (no pun intended).
20:31:51 <kini> <john_not_jenny> System.Posix.Process?
20:31:51 <kini> looks right
20:32:03 <kini> sad that you don't get the nice types and stuff from System.Process though
20:32:09 <tabemann> I was originally turned off by Haskell because I couldn't figure out how to do the imperative things I was used to doing in it
20:32:37 <nitrix> Right. It's like learning programmation again, at least for me.
20:32:38 <Markz> since when was simulating the universe simple
20:32:39 <tac> tabemann: It's kind of hard with the community telling you from every direction "don't do imperative!"
20:32:39 <kini> just a path to the executable, arguments, environment variables, and whether not to scrub $PATH...
20:32:43 <nitrix> But it feels incredibly great.
20:33:21 <tabemann> tac: I didn't realize that I didn't need to do things the imperative way because I was so used to it
20:33:51 <tac> yeah. It's hard to find the division between what can and can't (should and shouldn't?) be done imperatively
20:33:51 <mjrosenb> ok, it looks like only Data.Attoparsec.ByteString.Char8 has hexadecimal :-(
20:34:58 <tabemann> tac: I didn't know about things like ST and IO mutable types either, so I wondered how I'd do things where I *needed* to do them imperatively
20:35:41 <tabemann> I also didn't know about things like Data.HashMap
20:36:01 <mjrosenb> tabemann: theoretically, you never /need/ them, but if you are new to haskell, you probably don't know that.
20:36:47 <Markz> wait what, how?
20:37:00 <tabemann> mjrosenb: and I was used to still doing certain kinds of things imperatively in OCaml
20:37:54 <mjrosenb> oh, wow, plugins is heavyweight.
20:38:04 <Welkin> data structures and algorithms courses are taught using an imperative approach
20:38:11 <Welkin> mine was taught in C, unfortunately
20:38:15 <tac> mjrosenb: yeah. Any kind of eval for Haskell is a mess, since it requires the whole compiler.
20:38:23 <mjrosenb> Welkin: mine was taught in java :-(
20:38:29 <glguy> Mjr the same parser combinators work when parsing lazy and strict byte strings
20:38:51 <mjrosenb> tac: yeah.  it also seems to be calling alex at runtime?
20:38:52 <glguy> The lazy parse function just runs the strict parser incrementally on the lazy chunks
20:39:26 <tac> haskell is kind of a miserable scripting language :(
20:40:37 <mjrosenb> glguy: cool. so if I import the strict Char8 library, I should be able to use those combinators with the lazy parse function?
20:42:25 <glguy> From the look of the documentation, yes. On phone so I can't
20:42:27 <glguy> Check
20:43:22 <Welkin> do you use text to speech?
20:43:43 <Welkin> er, speech to text
20:44:16 <glguy> Swipe keyboard
20:44:54 <Zekka> tac: When you say "scripting language" do you mean in the sense of "I have a larger app and I want users to write functionality for it" or "I want to automate system stuff"?
20:45:07 <mjrosenb> glguy: are you running an irc program locally?
20:45:33 <glguy> AndChat
20:45:33 <mjrosenb> Zekka: since we're talking about Plugin, I'd guess the former.
20:45:36 <tac> Zekka: I guess I'm being loosey goosey with language.
20:45:46 <tabemann> back
20:45:52 <path[l]> Welkin: out of curiosity (looking at the chat log), can you think of any algorithm where an efficient implementation is easier with immutable data structures? In my experience most of the smart algorithms seem to use data structures with in-place updates, and a persistent datastructure always seems strictly more complex
20:45:57 <Zekka> Eval's a requirement for the first but not the second imho
20:46:43 <Welkin> path[l], well, when it comes down to it, a computer is a state machine
20:47:57 <mjrosenb> path[l]: I've had a number of problems like that.
20:48:05 <path[l]> I guess what I’m getting at is, maybe it’s correct that courses on algorithms and datastructures assume imperative languages. The courses are hard enough without requiring people to understand how to do things efficiently with a persistent datastructure
20:48:36 <Welkin> a course on data structures and algorithms is to learn how they work, not how to optimize them
20:48:49 <Welkin> so it does not logically follow that you would use an imperative language
20:48:58 <Welkin> it is, after all, purely theoretical
20:49:30 <path[l]> huh … most of these courses I’ve seen are focused on showing you optimal algorithms, while they might fool around with sub-optimal ones, usually they’re trying to show you how you can implement an optimal version of something or the other
20:49:36 <Markz> my course was specifically, this is why we use this structure and algorithm because it's efficient
20:49:42 <mjrosenb> my school's data structures course was taught in sml for a year or so.
20:50:03 <Zekka> I'd have to say I've found Haskell to be a pretty language to express algorithms in, but it's often difficult to express efficient ones in it
20:50:09 <Welkin> path[l], I meant implementation details, not logical optimizations
20:50:19 <dolio> Persistent red black trees are easier for most operations than the pointer stuff people usually do.
20:50:23 <Welkin> logical optimizations are always the same no matter how they are implemeneted
20:50:34 <Zekka> ST technically allows you to accomplish it, but once you're using ST I don't see an advantage over an imperative-preferred language
20:51:08 <path[l]> dolio: I find that hard to believe, but I’m willing to be convinced.
20:51:09 <Zekka> I'm thinking specifically of algorithms like QuickSort
20:51:21 <Zekka> where the standard implementation relies on mutability
20:51:59 <mjrosenb> Zekka: lol, yeah.  when I learned functional programming, the professor gave use a quicksort implementation that was O(N^3) worst case behavior.
20:52:01 <carter> haskell is a lovely imperatie lang
20:52:11 <carter> *imperative
20:52:20 <mjrosenb> Zekka: that being said, functional merge sort is *beautiful*
20:52:26 <tabemann> I find myself writing a lot of imperative haskell these days
20:52:29 <Zekka> mjrosenb: You'll get no argument from me on that!
20:52:46 <Zekka> carter: Really? I've generally found State to be syntactically dense and by default it encourages some real antipatterns
20:53:17 <Zekka> it's hard to encapsulate state because by default State over a smaller structure doesn't compose well into chains of State over a larger structure
20:53:21 <tabemann> the syntax is kind of clunky for some common imperative operations (e.g. array accesses), but it's still a better imperative language than any other I've worked with
20:53:23 <athan> Is there a way to hoogle within a sandbox?
20:53:34 <carter> Zekka: State != imperativeative
20:53:35 <Zekka> (I'm aware that Lens does a very good job fixing this if you use Lens!)
20:53:36 <athan> or search for definitions within one?
20:53:43 <Zekka> carter: Well, what's "imperative" mean, then?
20:53:57 <carter> "update this location in memory damnit"
20:53:57 <Zekka> Because generally when I say "imperative" I'm referring to a series of operations that make incremental changes to a common state
20:54:06 <carter> State monad aint imperative
20:54:09 <Zekka> and State is pretty much the conventional formulation of that
20:54:13 <carter> its just threading some record around
20:54:18 <athan> I prefer "forgetful"
20:54:36 <Zekka> So for you it's not imperative unless it's imperative on the level of how you interact with memory?
20:54:38 <tabemann> imperative haskell is when you're doing everything in the IO monad, using IO mutable data structures, etc. etc. etc.
20:54:50 <Welkin> do blocks?
20:55:12 <tabemann> whereas the State monad is purely functional
20:55:14 <mjrosenb> oops, less just hit a brick wall :-(
20:55:17 <Zekka> Because you could get pretty much all imperative behavior using a heap in State if you were inclined, so I'd argue that unless there's a real semantic difference between what you're describing and what I'm describing then I'm not sure it is
20:55:23 <Zekka> tabemann: Well, what do you mean "purely functional"?
20:55:28 <nshepperd> you can write imperative haskell in IO with all IORefs :)
20:55:31 <carter> Zekka: bencmarks tell me your wrong :)
20:55:40 <carter> IO monad and ST monad are my best imperative friends
20:55:41 <nshepperd> it's basically type-safe C then
20:56:05 <Zekka> carter: I'm currently operating from the standpoint of "does the code mean the same thing?" not "does the code run in the same time?"
20:56:25 <carter> lol
20:56:37 <nshepperd> Plus a ReaderT for global mutable variables
20:56:41 <carter> Zekka: does the codes mean the same thing if it takes >1000x longer?
20:56:43 <Zekka> if you assume that code that doesn't run in the same time doesn't mean the same thing then you run into sticky problems like certain programs being expressible in C but not in Python
20:57:00 <Markz> when is type safety a problem in C
20:57:07 <Zekka> carter: I'm a member of the 'if it generates the same output with the same input' crowd
20:57:09 <tabemann> Zekka: producing side effects
20:57:21 <Welkin> Markz, c doesn't have type safety
20:57:30 <tabemann> is what I mean my imperative, and purely functional is the antonym of that
20:57:31 <Welkin> it barely has types
20:57:39 <tabemann> *by imperative
20:57:44 <Zekka> tabemann: Well, wouldn't you argue that the same's true with IO given that IO can only produce side effects in IO code, similarly to how State can only produce side effects in State code?
20:57:58 <carter> Zekka: i'm building tools where a program that takes 1000x slower than the optimal would be a bad bad bug
20:57:59 <Zekka> You might argue that 'but IO code can produce side effects in unrelated IO code'
20:58:10 <dibblego> tabemann: no, I can write imperative pure-functional code
20:58:30 <Zekka> But I'd argue that you can't observe the result of some IO code as 'unrelated' to other IO code without cheating with something like unsafePerformIO
20:58:32 <carter> dibblego: am i making sense?
20:58:33 <tabemann> Zekka: IO in any place affects IO anywhere, hence is imperative
20:58:40 <dibblego> carter: Yes.
20:58:55 <carter> dibblego: i passed the dibble test! :)
20:59:11 <Zekka> tabemann: See the above?
20:59:17 <Zekka> (let me know if it's not a satisfactory answer)
20:59:24 <dibblego> carter: I addressed this issue at a talk at a python conference recently
20:59:27 <carter> oh?
20:59:33 <Zekka> I'd argue it's a mute point because you can only really observe IO inside of one chain of IO operations in a given program
20:59:34 <dibblego> IO is imperative and pure-functional
20:59:36 <carter> @google tony morrison keynote
20:59:37 <Zekka> moot*
20:59:38 <lambdabot> http://www.youtube.com/watch?v=CFudCx868uw
20:59:38 <lambdabot> Title: BPS DCP Annual Conference 2012 - Tony Morrison - YouTube
20:59:38 <tabemann> Zekka: except you can't treat the IO monad as a state monad due to how concurrency and exception handling work
20:59:41 <carter> that one?
20:59:45 <dibblego> no
20:59:48 <carter> or am i bad at spelling?
20:59:50 <dibblego> yes
20:59:50 <Markz> so when/why is it a problem Welkin?
21:00:03 <Zekka> tabemann: Oh hey, that's actually right. Bad me for forgetting that.
21:00:04 <carter> yeah, i'm bad at spelling :)
21:00:14 <dibblego> github appears to be broken or I would get you a link, sorry
21:00:18 <tabemann> you can have IO in two different threads communicating with one another, which could never occur with a State monad
21:00:22 <Zekka> It has more power than State at least
21:00:24 <carter> https://www.youtube.com/watch?v=uqsZa36Io2M ?
21:00:33 <dibblego> https://www.youtube.com/watch?v=uqsZa36Io2M
21:00:34 <dibblego> yes
21:00:41 <carter> soo many dibbles!
21:00:46 <Zekka> But I don't think it's correct to say that it has more power than any non-IO monad assuming we don't count side effects that can be observed from other programs
21:01:08 <Zekka> There are a couple of non-IO concurrency monads out there, for instance
21:01:16 <tabemann> I'd say that IO has a special degree of power that other monads cannot have
21:01:22 <Zekka> here is a simple one: http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html
21:01:25 <carter> dibblego: lol, love the first sentence of the intro
21:01:35 <dibblego> carter: I haven't watched it yet
21:01:36 <Zekka> tabemann: Which is? And would you say that degre of power is the difference between imperative ad nonimeprative code?
21:01:48 <tabemann> except cooperative multithreading can be implemented via continuations, which can be implemented via monads
21:02:02 <tabemann> in a pure fashion
21:02:06 <Zekka> tabemann: Yes, that was my argument.
21:02:31 <Zekka> you're right that IO's powers aren't expressible in State, but I'd argue that they're expressible in *some* non-IO monad assuming the only program capable of observing is your Haskell program
21:02:32 <tabemann> whereas allows truly concurrent threads to communicate and affect one another's state
21:02:41 <tabemann> whereas IO*
21:03:01 <dibblego> you would probably be interested in looking at the free monad
21:03:11 * tabemann remembers implementing cooperative multithreading in Scheme using call/cc
21:03:11 <Zekka> tabemann: How is this different from true concurrency?
21:03:14 <dibblego> because you can write arbitrary imperative pure-functional programs using that
21:03:32 <Zekka> Couldn't you get concurrency in the sense that operations aren't atomic by implicitly throwing yields into every (>>)?
21:03:38 <tabemann> cooperative threads never actually execute simultaneously, and require threads to give up control voluntarily
21:03:45 <Zekka> tabemann: See above.
21:04:14 <Zekka> I think this is likely going to result in a similar conclusion to Carter's which is that "yes, but they don't mean the same thing unless from a "this is how the code is actually executed" standpoint" they do the same thing
21:04:22 <tabemann> cooperative threads can never execute on seprate cores
21:04:27 <tabemann> *separate
21:04:39 <Zekka> which I've kind of resisted hacking down because I think Carter's point is to some extent valid even though I have a feeling there's a philosophical objection  to be made from my standpoint
21:04:52 <mjrosenb> tabemann: out of curiosity, have you tried direct-plugins?
21:05:01 <carter> Zekka: nope, theres no valid objection to my opterational definition :)
21:05:03 <dibblego> here is pure-functional I/O in C# using free monad https://gist.github.com/tonymorris/7817335
21:05:16 <carter> a program that takes 1 hour rather than 1 second is a bug
21:05:16 <Zekka> tabemann: You're right that "actually on multiple cores" is not possible without IO in Haskell
21:05:26 <carter> when it could just take a second
21:05:29 <tabemann> mjrosenb: nope, just plugins
21:05:31 <carter> :)
21:05:43 <carter> you can use a dumb slow simple algorithm
21:05:44 <dibblego> https://gist.github.com/tonymorris/7817335#file-pureio-cs-L291-L303 is the imperative program
21:05:46 <carter> to prove correctness
21:05:49 <Hafydd> Ugh.
21:05:53 <carter> then prove your fast alg equals the slow alg
21:05:55 <carter> BUT
21:05:58 <mjrosenb> tabemann: plugins is /ancient/, it looks like.
21:06:00 <carter> you never really wanna use the dumb slwo alg
21:06:10 <mjrosenb> Copyright (C) 2004-5 Don Stewart - http://www.cse.unsw.edu.au/~dons
21:06:11 <dolio> You could execute cooperative threads on multiple cores if you wanted.
21:06:20 <Zekka> carter: So would you argue that i.e. C and Python are not capable of explaining the same class of programs?
21:06:26 <Zekka> because C epresses them immeasurably faster?
21:06:41 <Zekka> dolio: I don't know what the Report says but I'm pretty sure it doesn't say you're allowed/supposed to do htat
21:06:50 <carter> python can't express certain classes of programs except by dint of using C ffi
21:06:55 <dolio> What does a report have to do with it?
21:07:18 <shachaf> (f <$> x <*> y <*> z) makes a left-biased append tree, as in ((x <> y) <> z)
21:07:30 <shachaf> Is there a nice way to write that expression such that the tree is right-biased?
21:07:53 <tabemann> mjrosenb: direct-plugins is still kind of old
21:08:14 <Zekka> dolio: The Haskell report specifies what a Haskell implementation is actually supposed to do
21:08:25 <dolio> Who cares about Haskell?
21:08:27 <Zekka> so generally you don't break with it except when for instance introducing language extensions
21:08:32 <tabemann> the last update to plugins was in 2013
21:08:39 <carter> tabemann: theres a few altenratives
21:08:43 <carter> like plugins-ng i think?
21:09:02 <carter> oh, still wip
21:09:15 <Zekka> dolio: You're right that you can define a pure language that automatically parallelizes some code with cooperative threads, I suppose
21:09:18 <dolio> The Haskell report doesn't dictate what is possible to do in reality.
21:09:29 <mjrosenb> tabemann: it also looks like there is plugins-auto
21:09:42 <mjrosenb> tabemann: I'd see what xmonad uses, since it is presumably up to date.
21:10:10 <glguy_> shachaf: I'm not ready to say nice yet, but we ought to be able to work toward something like this: x <?> y = (,) <$> x <*> y
21:10:10 <glguy_> demo f x y z = (\(a,(b,c)) -> f a b c) <$> (x <?> (y <?> z))
21:10:18 <Zekka> dolio: From what I can tell your objection is a little more specifically "who said it made sense to call parallelism an IO-thing?"
21:10:25 <tabemann> xmonad just recompiles itself with the configuration being the main and xmonad being a library
21:10:51 <mjrosenb> tabemann: oh, boo.  I thought it used some dynamic plugin system.
21:10:58 <Zekka> and that that's more a Haskell quirk than something that has to be true of whatever purely functional language you're defining?
21:11:49 <shachaf> glguy_: I'd rather not use tuples.
21:12:01 <dolio> No. My objection was to cooperative threads 'not running at the same time' and whatnot.
21:12:16 <shachaf> glguy_: We could write right-biased liftAn for every n we care about, of course.
21:12:28 <tabemann> direct-plugins isn't suited to what I'm trying to do
21:12:29 <dolio> That is true if what you have is some sequential system and you are interpreting cooperative threads into that sequential system.
21:12:38 <dolio> But then that will be true of preemptive threads, too.
21:13:05 <Zekka> dolio: It sounds like your argument's a little similar to mine which is that "if you don't care about actual underlying behavior, it doesn't matter if cooperative threads *really* run at the same time"
21:13:40 <tabemann> cooperative threads will hold up on IO
21:13:45 * hackagebot hspec-laws 0.0.0 - Document and test laws for standard type classes  http://hackage.haskell.org/package/hspec-laws-0.0.0 (SimonHengel)
21:14:20 <glguy_> shachaf: If you're willing to turn your f around
21:14:20 <glguy_> demo2 f x y z = (x <**> (y <**> (z <**> pure f)))
21:14:41 <carter> Zekka: i feel like you're not listening to any other perpsective
21:14:45 <tabemann> IO is necessary to have threads that aren't halted by IO
21:14:49 <carter> even though theres validating in boht directions
21:15:01 <Zekka> carter: It's possible
21:15:01 <carter> tabemann: yeah... i've been writing a lot of very very concurrent stuff lately
21:15:29 <dolio> If you don't have IO, then there's no IO for your threads to be halted by.
21:15:39 <dolio> Whatever that means.
21:16:36 <Zekka> carter: You're generally arguing that speed/etc. differentiate code that looks imperative -- has the same structure, etc., but built out of purethings instad of IOthings -- from code that's really imperative (built out of IOthings), right?
21:16:47 <linman32> where is a good place to find working  demo code for http-client?
21:16:52 <shachaf> glguy_: I was just writing exactly that in another window.
21:17:02 <glguy_> *high five*
21:17:13 <shachaf> It isn't all that great, though.
21:17:32 <glguy_> pft, *your* exact version of that wasn't so great
21:17:34 <shachaf> f <$> x <*> y <*> z is pretty close to ideal, except for the left bias.
21:17:38 <benzrf> :t (<**>)
21:17:39 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
21:17:46 <benzrf> left bias
21:17:53 <benzrf> :t (<&>)
21:17:54 <lambdabot> Functor f => f a -> (a -> b) -> f b
21:17:56 <Zekka> carter: I'd argue that you need to do IO to observe these differences anyway
21:18:04 <dolio> shachaf: Can you run in the opposite applicative? Whatever it's called?
21:18:10 <Zekka> from the standpoint that the Haskell program can observe, the pure version seems to behave the same way as the IO version
21:18:21 <Zekka> if the IO program needs to time itself, for instance, the pure verison can lie the same way
21:18:27 <rrradical> Reading the haskell libraries mailing list, it seems a fair number of proposals for more polymorphism or more classes are voted down because they would make error messages worse. Would it be possible to provide general functions with specific error messages for certain types?
21:18:37 <Zekka> So you can write *equivalent* code in the same that it results in the same values when you inspect it
21:18:40 <shachaf> dolio: Hmm, interesting idea. It seems a little heavyweight.
21:18:44 <dolio> Where f <*> x = Op (unOp x <**> unOp f)
21:18:51 <Zekka> in the sense*
21:18:54 <shachaf> Right, same as the opposite Monoid.
21:18:58 <augur> oh if only we had idiom brackets!
21:19:01 <Zekka> carter: But I have a feeling this isn't a good sense for "equivalent"
21:19:16 <carter> :)
21:19:18 <dolio> shachaf: Maybe some ala type nonsense can make it better, depending on what exactly you're writing.
21:19:21 <augur> x (| y (| z (pure f) |) |)
21:19:29 <Zekka> Because it doesn't outright say that nonterminating code means something different from terminating code
21:19:34 <augur> or whatever
21:19:34 <shachaf> Let's say the answer is "a Traversable instance".
21:19:44 <Zekka> let x _ = 4; let y f = y f
21:19:59 <Zekka> There is no counterexample you can find for the idea that x and y are equivalent
21:20:13 <augur> zebr: sure there is
21:20:13 <carter> Zekka: i look and say so
21:20:19 <augur> er, Zekka^
21:20:33 <Zekka> carter: Observing the source code is an IO action!
21:20:43 <carter> no
21:20:47 <carter> tis pure
21:20:55 <carter> cause i say so
21:21:04 <Zekka> OK, sure, sure.
21:21:16 <Zekka> Your next step is finding a way to generally determine if code is terminating or nonterminating
21:21:23 <carter> proof
21:21:25 <carter> bam
21:21:30 <Zekka> augur: Responding to you now
21:21:36 <augur> proof
21:21:37 <augur> bam
21:21:40 <augur> x3
21:21:50 <Zekka> But you can't prove whether code is nonterminating or terminating in general, can you?
21:22:00 <augur> dont need to in general
21:22:04 <carter> proofs
21:22:05 <augur> you gave specifics!
21:22:05 <carter> bam
21:22:06 <dolio> Who can't?
21:22:09 <shachaf> :t let (<**>) = (Control.Applicative.<**>); infixr 1 <**> in \f (x,y,z) -> f x <**> f y <**> f z <&> (,,)
21:22:10 <lambdabot>     Precedence parsing error
21:22:10 <lambdabot>         cannot mix ‘<**>’ [infixr 1] and ‘<&>’ [infixl 1] in the same infix expression
21:22:11 <joelteon> I know I can't
21:22:17 <joelteon> I'm not smart enough to do that
21:22:21 <Zekka> augur: Well, yes, I gave a specific example, but it was meant to demonstrate something general
21:22:24 <shachaf> :t let (<**>) = (Control.Applicative.<**>); infixr 4 <**>; (<&>) = (Control.Lens.<&>); infixr 4 <&> in \f (x,y,z) -> f x <**> f y <**> f z <&> (,,)
21:22:25 <lambdabot> Applicative f => (t -> f a) -> (t, t, t) -> f (a, a, a)
21:22:27 <dolio> Proving it in general isn't necessary, either.
21:22:34 <carter> that too
21:22:34 <carter> :)
21:22:45 <dolio> You only need to prove the things about what you want to write.
21:22:52 <joelteon> are we arguing about why Haskell has no real world application?
21:22:55 <Zekka> which is that from the standpoint I'm talking about "equivalence" of functions it seems to me that you can't always demonstrate that a nonterminating funtion is nonequivalent to a terminating function
21:23:08 <carter> joelteon: i think its more just getting riled by z
21:23:22 <augur> z riles everything up
21:23:22 <joelteon> oh yeah, you can't define Eq for functions, that's madness
21:23:23 <Zekka> carter: Hope you're not too pissed off at me
21:23:26 <augur> cant we just stick to x and y?
21:23:27 <augur> sheesh
21:23:30 <joelteon> unless it's Eq a => Eq (() -> a) in which case it's REALLY easy
21:23:38 <Zekka> if I'm being thick I'm not trying to be
21:23:45 <carter> Zekka: i just think you'r not being explciti about what domains youre considering
21:23:47 * hackagebot yesod-platform 1.2.13.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.13.2 (MichaelSnoyman)
21:23:51 <augur> joelteon: in general you can probably do    (Enumerable a, Eq b) => Eq (a -> b)
21:23:53 <carter> a) fixed mechnical process
21:23:53 <dolio> joelteon: Or is it?
21:23:57 <carter> b) anything that does it
21:23:59 <joelteon> dolio: oh, it is
21:24:01 <joelteon> trust me
21:24:04 <dolio> Okay.
21:24:04 <carter> and you've not specified which process
21:24:06 <Zekka> carter: Let me start from a little bit earlier and then I think you'll understand me
21:24:12 <carter> mebe :)
21:24:14 <joelteon> You just do a == b = a () == b ()
21:24:20 <joelteon> and if there's an undefined, you crash!
21:24:34 <dolio> You haven't checked all the cases.
21:24:50 <Zekka> I started from the idea that you can generally write code without using IOthings that as far as your Haskell program can tell, is equivalent to code using IOthings
21:24:57 <joelteon> Well, you could also do a /= b = a () /= b ().
21:25:00 <dolio> You need to crash on all strict functions.
21:25:22 <joelteon> I'm sure Oleg could write a library that does that.
21:25:33 <glguy_> > let (<**>) = (Control.Applicative.<**>); infixr 4 <**>; (<&>) = (Control.Lens.<&>); infixr 4 <&>; t f (x,y,z) = f x <**> f y <**> f z <&> (,,) in over t id (1,2,3)
21:25:33 <augur> and it would work in the type system
21:25:35 <lambdabot>  (3,2,1)
21:25:41 <Zekka> When we talk about code that "does the same thing"/is equivalent we generally mean that for all the same input it generates all the same output
21:26:06 <carter> Zekka: thats ONE definiton
21:26:09 <Zekka> So let's imagine a program that feeds your two Haskell functions -- one in IO and one in homemade-IO-simulating monad
21:26:09 <joelteon> does undefined == undefined
21:26:09 <carter> its a useful one
21:26:12 <carter> but its not the ONLY one
21:26:17 <Markz> there are others?
21:26:20 <Zekka> carter: Yes: what I was trying to do was explain why I think it's dodgy
21:26:27 <Zekka> I'm arguing your side here, pay attention!
21:26:56 <carter> ah
21:27:00 <carter> well, i've been up for a while :)
21:27:12 <Zekka> It feeds your two functions all kinds of possible input -- the issue is that it can't necessarily distinguish cases where your function doesn't terminate at all from functions where it terminates with the right answer
21:27:30 <carter> why can't it?
21:27:33 <carter> i'm confused now
21:27:37 <Zekka> A sufficiently slow implementation may as well take almost forever but still terminate
21:28:03 <Zekka> Unless you don't believe in the halting problem, there are at least some cases where you can write a version that doesn't halt but introspecting over it can't prove that it doesn't halt
21:28:50 <shachaf> glguy_: Hmm, that's not great.
21:28:57 <carter> Zekka: thats only from a strictly "intensional" perspective
21:29:06 <shachaf> > let (<**>) = (Control.Applicative.<**>); infixr 4 <**>; (<&>) = (Control.Lens.<&>); infixr 4 <&>; t f (x,y,z) = f z <**> f y <**> f x <&> (,,) in over t id (1,2,3)
21:29:06 <Zekka> carter: What would an alternative be?
21:29:07 <lambdabot>  (1,2,3)
21:29:08 <carter> extensionally, you can prove they agree (or try to prove them)
21:29:13 <Zekka> thanks for playing ball with me by the way
21:29:14 <shachaf> > let (<**>) = (Control.Applicative.<**>); infixr 4 <**>; (<&>) = (Control.Lens.<&>); infixr 4 <&>; t f (x,y,z) = f z <**> f y <**> f x <&> (,,) in foldMapOf t N (1,2,3)
21:29:16 <lambdabot>  N 3 ◇ (N 2 ◇ N 1)
21:29:31 <shachaf> Also not great.
21:30:45 <Zekka> carter: Remember, we're starting from my bold claim that you can express any IOthing as a purething provided you don't also do an IO operation to prove that the side effects were really done
21:31:07 <shachaf> Perhaps this conversation should be in #haskell-overflow.
21:31:10 <Zekka> (such an operation would be replaced with a pure operation that says "sure it was done" for the purething)
21:31:16 <Zekka> shachaf: Yeah, you're probably right
21:33:45 <shachaf> glguy_: The Traversable and Foldable instances of Data.Map disagree on the tree shape.
21:33:50 <shachaf> > foldMap N (M.fromList [(x,x) | x <- [1..5]])
21:33:52 <lambdabot>  (N 1 ◇ (N 2 ◇ N 3)) ◇ (N 4 ◇ N 5)
21:33:54 <shachaf> > T.foldMapDefault N (M.fromList [(x,x) | x <- [1..5]])
21:33:56 <lambdabot>  (((N 1 ◇ N 2) ◇ N 3) ◇ N 4) ◇ N 5
21:34:20 <shachaf> Because Foldable writes (a <> (b <> c)) but Traversable writes (f <$> a <*> b <*> c)
21:35:19 <joelteon> dolio, i just understood why you have to discard strict functions while i was in the shower
21:35:29 <dolio> :)
21:35:35 <shachaf> (Milan changed it to be right-biased when I emailed him about it a while ago.)
21:35:36 <nitrix> Is <--> a reserved operator?
21:35:39 <joelteon> no
21:35:50 <shachaf> (Among other containers traversing topics.)
21:36:26 <nitrix> joelteon: Just making sure, this was directed at me?
21:36:32 <shachaf> I wondered how difficult it would be to make the Traversable instance agree with the Foldable instance.
21:36:35 <joelteon> nitrix: sorry, yes, i was speaking to you
21:36:48 <nitrix> joelteon: Awesome. Appreciated then.
21:37:31 <joelteon> nitrix: if it's not in the top of this page http://hackage.haskell.org/package/base-4.7.0.0/docs/doc-index-All.html, and not @, ->, =>, or ::, it isn't reserved
21:37:43 <joelteon> I might have missed one but those are your options
21:37:47 <glguy_> shachaf: For something that's going to be hidden away in Data.Map.Lazy, would it be so bad to have go l <**> (f k v <**> (go r <&> \ ... -> ..))  ?
21:38:17 <nitrix> joelteon: So essentially, a cheat sheet I got is misleading. Good thing I'm not using only one resource to learn.
21:38:21 <shachaf> It's an instance, so it's in Data.Map.Base. :-)
21:38:41 <shachaf> Anyway, it's not "so bad" as such, but if there's a nicer way to do it then that way would be nicer.
21:38:51 <glguy_> Should I be generating the traversals in makeLenses the same right-associated order?
21:39:00 <joelteon> nitrix: and anyway, you can shadow all of those; you just shouldn't write a package that exports them
21:39:23 <shachaf> I usually go for right-associativity when I can in Haskell because that's the typical shape of e.g. lists.
21:39:33 <nitrix> joelteon: Well the only one I know and used was from vty-ui
21:39:54 <glguy_> Sure, I understand the preference, I'm just wondering about the code generation
21:40:06 <glguy_> It wouldn't be much work to generate them this way
21:40:23 <shachaf> I don't know how important it is.
21:43:57 <dolio> :t \f a b c -> (f <$> a) <**> ((\b c f -> f b c) <$> b <*> c)
21:43:59 <lambdabot> Applicative f => (a -> a2 -> a1 -> b) -> f a -> f a2 -> f a1 -> f b
21:49:00 <shachaf> dolio: That's a lot of shadowing.
21:49:07 <shachaf> But I suppose it works.
21:55:53 <mjrosenb> ok, switching from parsing by hand to parsing with attoparsec, and switching from String to ByteString sped me up from ~4MiB/s to ~70MiB/s
21:57:01 <carter> congrats
21:57:05 <djahandarie> In theory, hand-rolled parsers should be able to beat attoparsec, if you're rolling them correctly anyways.
21:57:14 <carter> mjrosenb: you may wanna use Text rather than Bytestring
21:57:22 <mjrosenb> carter: it'll probably be slower.
21:57:34 <carter> mjrosenb: .... binary data or human text?
21:57:41 <Ralith> does your usecase demand maximal throughput?
21:57:49 <Zekka> djahandarie: What would it take to roll them correctly?
21:58:01 <mjrosenb> carter: "human text"
21:58:03 <carter> i recommend rewriting a snazzy parser dsl tha compiles using llvm-general :)
21:58:11 <carter> mjrosenb: Text is a better type than Bytestring
21:58:14 <carter> for human text
21:58:24 <Zekka> I have a f eeling if I were to write a parser it would probably start by writing a Parsec or attoparsec-style monad transformer stack to keep track of state
21:58:44 <Zekka> and I'm not sure that manually threading the state I need would be faster
21:58:54 <mjrosenb> yeah, but i'm parsing ~60 gb produced via fprintf(stdout, "%p:     %p\n", instr, *(uint32_t**)instr);
21:58:59 <Zekka> I don't know what hand-rolled optimizations I could use to improve over the standard design
21:59:07 <mjrosenb> so it is human readable, but it is guaranteed to be pure ascii
21:59:19 <djahandarie> Zekka, depends on the grammar. There are various specialized parsers you can write that attoparsec won't.
21:59:32 <carter> if you have that much regularity, pretty easy to muck with
21:59:39 <Zekka> djahandarie: Can you give an example of one? I can think of a few cases where you don't need to keep some of the same state
22:00:02 <Zekka> But I can't think of any other cases where you aren't doing manually the sorts of thing that Attoparsec abstracts around doing automatically
22:00:06 <Zekka> Sorry to put you on the spot
22:00:09 <mjrosenb> Ralith: it doesn't /demand/ it, but I dislike waiting around for a long time.
22:00:25 <carter> mjrosenb: lines :: ByteString -> [ByteString] would be handy
22:00:31 <carter> then you just process the lines alone
22:00:37 <djahandarie> Zekka, an operator precedence parser, for example.
22:00:38 <carter> Data.ByteString.Char8
22:01:02 <Zekka> carter: Does that play nicely with the GC/laziness for 60gb of data assuming you never operate on all of it at once or anything?
22:01:19 <carter> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy-Char8.html
22:01:24 <carter> use the lazy bytesring
22:01:27 <djahandarie> Even hand-coding recursive decent parsers can still be worth it sometimes.
22:01:32 <carter> or just incrementally load a chunk at a time
22:01:33 <carter> idk
22:01:33 <Zekka> djahandarie: Where the issue is that you can intermediately process the data in a few ways that are faster than playing with attoparsec's rules?
22:01:35 <carter> your call
22:01:41 <mjrosenb> carter: I am.
22:01:57 <carter> then per chunk, lines + whatever
22:02:01 <mjrosenb> well, technically, I'm using BS.split '\n' f
22:02:02 <Ralith> carter: seems like the cost of (un)marshalling might dominate a JIT approach
22:02:12 <mjrosenb> because I couldn't find lines at the time.
22:02:19 <Zekka> using algorithms like i.e. shunting-yard?
22:02:23 <carter> Ralith: not if you use the haskell abi and data model :)
22:02:27 <carter> mwahahhaah
22:02:45 <Ralith> carter: ghc, you mean?
22:02:53 <Ralith> and isn't that unstable?
22:02:53 <carter> yes
22:02:56 <carter> not really
22:03:02 <carter> its stable per major version
22:03:33 <Ralith> I think it'd still be very difficult to avoid having to (un)marshal text data
22:03:49 <carter> yes/no
22:04:08 <djahandarie> Zekka, something like that. All parser combinators are recursive decent, which is top-down. Sometimes it's the case that there are deterministic bottom-up parsers and no top-down parsers which don't use backtracking or guessing.
22:04:28 <carter> Ralith: i agree ti'd take a bit of work
22:04:33 <mjrosenb> Ralith: what do you mean by marshall/unmarshall?
22:04:41 <Zekka> djahandarie: OK, I think I understand
22:04:59 <carter> mjrosenb: naive llvm compilation uses a very C++ ish kinda rep to things
22:05:06 <Ralith> mjrosenb: convert Haskell's native representation to/from a representation convenient to work with in LLVM IR
22:05:12 <Ralith> ghc's, rather
22:05:26 <Ralith> carter: more C than C++
22:05:30 <carter> Ralith: i'm proposing making it easy to work in ghc's rep using llvm :P
22:05:34 <Zekka> When you say 'bottom-up' you mean recognizing the simplest entities as you go (i.e. numbers, operators) and turing them into bigger entities later? (i.e. asts?)
22:05:34 <carter> which would be DOABLE
22:05:36 <carter> just a bit of work
22:05:47 <carter> *lotta work
22:05:48 <Ralith> the only really C++y feature LLVM IR has is exceptions
22:05:55 <mjrosenb> Ralith: ahh.  presumably ByteString would be pretty compatible with LLVM?
22:06:03 <carter> pretty
22:06:15 <Zekka> carter: By the way I might actually end up writing a big actually-imperative program in Haskell before too long, so our discussion had a low-to-moderate degree of actual relevance
22:06:15 <carter> much
22:06:25 <carter> Zekka: hehe
22:06:31 <carter> what sort of program?
22:06:35 <carter> for fun / work / school?
22:06:40 <Zekka> I wrote a programming language with an interpreter in State a while back for fun
22:06:44 <Zekka> (and for school)
22:06:46 <Ralith> mjrosenb: I don't know what "compatible with" means. Everything has a defined memory layout, but ByteString is not a trivial datatype.
22:06:57 <djahandarie> Zekka, sure, that's a reasonable description.
22:06:59 <Zekka> I might end up rewriting a similar language in IO because I actually care about performace in this case
22:07:00 <carter> Ralith: foreign pointers
22:07:02 <carter> bam
22:07:07 <carter> thats trivial stuff
22:07:07 <carter> :)
22:07:09 <Zekka> while I'm not wanking about theoretical stuff I don't have much grounding in
22:07:17 <Zekka> carter: I'm looking forward to being able to piggyback on Haskell's GC
22:07:18 <Ralith> carter: I need more than a noun
22:07:25 <Zekka> That wasn't really an option in State because I needed to pass around the whole heap
22:07:26 <mjrosenb> Ralith: err, I misread "convienient" as "compatible" in your previous response.  My bad.
22:07:30 <carter> @google ghc foreign pointers
22:07:31 <lambdabot> https://hackage.haskell.org/package/base-4.2.0.1/docs/Foreign-ForeignPtr.html
22:07:36 <Zekka> And while I wrote a pretty decent GC it would probably be easier to use GHC's
22:07:45 <carter> Ralith: bytestrings are pinned byte arrays you can safely pass pointers to ffi calls
22:07:50 <Zekka> (and they probably wrote a better one)
22:08:00 <carter> so you can pass a pointer + length
22:08:02 <carter> to c
22:08:06 <carter> for a bytestring
22:08:12 <djahandarie> Zekka, for a slighty more concrete example, for grammars which have multiple rules that start identically, you can have a deterministic shift-reduce parser but any top-down parser would involve backtracking.
22:08:15 <Ralith> carter: I could've sworn they were segmented
22:08:19 <carter> Ralith: nope
22:08:23 <Ralith> what am I thinking of?
22:08:25 <carter> lazy bytesrings
22:08:28 <carter> strict bytesring aints
22:08:29 <Ralith> huh.
22:08:32 <Ralith> okay then
22:08:45 <Ralith> you often want lazy, though
22:08:47 <carter> you CAN work a chunk at a time on a lazy bytesring
22:08:50 <carter> and ffi on that
22:08:58 <carter> no shame in that
22:09:02 <Ralith> certainly
22:09:05 <Ralith> just takes some doing
22:09:09 <carter> so
22:09:10 <carter> doable
22:09:16 <carter> Ralith: lets stop quibbling :)
22:09:21 <Ralith> >_>
22:09:26 <carter> is doable
22:09:35 <carter> how much work is another qustion
22:09:37 <Zekka> djahandarie: So, for instance, if "1a" is a valid statement and "1.0" is a valid number in a language that allows that, with a top-down parser, because you have to identify the thing *first*, you need to backtrack, while if you identify it after you can determine how you continue based on how it continues?
22:09:40 <carter> but easyily doable
22:09:44 <Ralith> it would certainly be neat
22:09:53 * Ralith is a big fan of compiled DSLs
22:09:58 <carter> to call c code on lazy bytstring chunks?
22:10:02 <carter> oh
22:10:05 <carter> other thang
22:10:06 <Zekka> (pretend they were "goto" and "grotto", keyword and identifier, if you want a saner example)
22:10:10 <carter> well, sclv wrote part of one
22:10:10 <Ralith> to have such a parser library
22:10:58 <carter> huh is http://hub.darcs.net/ down?
22:11:06 <carter> http://hub.darcs.net/gershomb/adf-dfa
22:11:09 <carter> works
22:11:12 <stalintrotsky> works for me
22:11:18 <carter> Ralith: thats using the older llvm-binding
22:11:23 <carter> could build a parser lib on top
22:13:21 <djahandarie> Zekka, you don't always have to backtrack, you only have to backtrack when you get it wrong. :) But yes.
22:13:39 <Zekka> djahandarie: Right, you need to backtrack if your first rule is "keyword" and it wasn't one
22:13:50 <djahandarie> Yeah.
22:18:36 <David> Hi guys
22:18:43 <David> I'm still struggling to get lambdabot to work
22:18:53 <David> I installed it and verified that muinstall is also installed and in $PATh
22:18:59 <David> here's what happens now:
22:19:07 <David> lambdabot> > 1
22:19:08 <David> ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-imports","-l","/home/david/.lambdabot/State/L.hs","--expression=1","+RTS","-N2","-RTS"]
22:19:08 <David>   mueval: Using large values for -N is not allowed by default. Link with -rtsopts to allow full control.
22:19:47 <David> do i need to reinstall mueval with the option linked?
22:19:52 <David> I'm a little confused about what this means
22:24:47 <Fuuzetsu> does a person called Daniel Velkov come on IRC?
22:26:21 <stalintrotsky> Is there a typeclass for containers that can have occurences of a possible member counted and have members removed from? Foldable would work, but then counting would be O(n) when some structures could count in smaller time
22:26:51 <stalintrotsky> well I don't know if Foldable would work for removing elements
22:27:14 <stalintrotsky> I guess you could fold while creating a new structure that has all the elements except for the one you want to remove
22:27:18 <stalintrotsky> which would be O(n) again
22:45:51 <dfeuer> @tell nominolo I edited the Haskell Wiki page on the correctness of short cut fusion. I saw you did a lot of work on that; would you like to look over what I changed?
22:45:52 <lambdabot> Consider it noted.
22:52:05 <mjrosenb> gah... I re-wrote this sample program in C, and it /appears/ to be 5 times faster.
22:52:19 <coppro> hah
22:52:34 <coppro> did you do it in hand-optimized assembly yet?
22:52:40 <mjrosenb> coppro: no.
22:52:45 <mjrosenb> and I'm not planning on it.
22:52:56 <mjrosenb> oh good.
22:53:03 <mjrosenb> my C program isn't correct.
22:53:13 <coppro> hah
22:53:18 <coppro> that's what you get for using C ;)
22:54:00 <nicoo> stalintrotsky: Is a multiset what you want ?
22:54:09 <Markz> or any other language :)
22:55:43 <c_wraith> mjrosenb: if you're ok with incorrect results, I can find you an O(1) algorithm for most problems!
22:59:55 <dfeuer> c_wraith: why sell yourself short? Under those conditions, you can *always* do it.
23:00:21 <Fuuzetsu> can you have on O(1) solution for a problem of ‘heat up my room indifinitely’?
23:00:37 <mjrosenb> dfeuer: dunno, you may have to do a bit of work to make sure your program isn't accidentally correct.
23:00:39 <Fuuzetsu> indefinitely*
23:00:56 <mjrosenb> ok, bug fixed
23:01:03 <mjrosenb> and I re-compiled with -O2
23:01:09 <mjrosenb> now C is 10x faster :-(
23:01:22 <Fuuzetsu> make your Haskell faster
23:01:39 <dfeuer> Yes, Fuuzetsu, the solution is (12, "bro").
23:01:40 <tac-tics> Don't focus on speed
23:01:49 <tac-tics> The metric you want to really tunnel-vision onto is "webscale"
23:02:03 <coppro> haha
23:02:07 <mjrosenb> Fuuzetsu: that's what I want to do!
23:02:16 <mjrosenb> Fuuzetsu: I'm not 100% sure about how to do that atm.
23:03:01 <dfeuer> mjrosenb: show code.
23:04:15 <mjrosenb> https://gist.github.com/0089497c5b8450458bc0
23:04:46 <mjrosenb> dfeuer: ^
23:07:30 <dfeuer> mjrosenb: lazy IO has a pretty lousy reputation for performance. Have you tried the pipes-bytestring or pipes-text thing instead?
23:09:48 <WraithM> @djinn Maybe [a] -> Maybe a
23:09:48 <lambdabot> Error: Undefined type []
23:10:11 <dfeuer> ?
23:10:12 <Fuuzetsu> lousy IO
23:10:42 <mjrosenb> dfeuer: I have not,  I had been suggested conduit, but I didn't see a ByteString interface for it
23:10:56 <mjrosenb> (I had also been suggested pipes, but I forgot its name until now)
23:11:36 <solatis> ok, i want a very opinionated person to suggest to me what i should use for command line argument parsing -- frankly, i don't care, there are just too many options out there and i have no idea what to choose
23:11:58 <ChristianS> mjrosenb: actually, in my experience, lazy IO can perform pretty well compared to conduit and friends
23:12:02 <solatis> it seems like GetOpt is the way to go?
23:12:12 <c_wraith> solarus: optparse-applicative
23:12:30 <c_wraith> err. solatis.  ^^
23:12:32 <johnw> simple-conduit gives you a lot of the benefits of pipes/conduit, but with similar speed to lazy I/O
23:12:33 <solatis> c_wraith: good, what is your rationale/
23:12:34 <solatis> ?
23:12:47 <solatis> that everything ~-applicative is better? :)
23:12:50 <mjrosenb> ChristianS: well, I'm certainly open to suggestions!
23:12:58 <c_wraith> solatis: It's a little less bad of an interface than the rest. :)
23:13:23 <solatis> c_wraith: good, i will use that
23:13:46 <ChristianS> c_wraith: cmdargs seems to be popular as well, but you think that optparse-applicative is preferable?
23:14:22 <solatis> c_wraith: the syntax looks better than GetOpt
23:16:01 <solatis> ChristianS: looks like CmdArgs almost has its own DSL
23:16:03 <levi> mjrosenb: It might be faster to move more of your parsing into attoparsec.
23:16:15 <solatis> it looks nothing like 'regular' haskell code
23:16:28 * johnw is writing an attoparsec parser as we speak
23:16:39 <mjrosenb> levi: you mean also use it to pseudo-split on lines?
23:21:57 <levi> mjrosenb: Well, you're currently splitting into lines, parsing each line into a pair, discarding one element of each pair, then folding the list of remaining elements.  Seems to me you could parse directly into a list of the elements to fold over, which would simplify parsing *and* remove extraneous steps.
23:23:58 <mjrosenb> levi: I /really/ should be looking at both elements, but ATM, I just want to see what my speed is like compared to C
23:24:03 <mjrosenb> and the C code looks at both elements.
23:25:19 <mjrosenb> but I certainly agree that having attoparsec also find newlines would be a good idea.
23:26:16 <levi> Oh, I left out the layer of Maybe-unwrapping that you'd lose by putting newline handling into the parser.
23:28:24 <mjrosenb> levi: sounds good.  I'm trying to do this now, but I'm not sure how to do it without just generating a list of Either tuple ()
23:32:53 <mjrosenb> levi: you know if I'm generating a list, can I extract part of the list, then feed the parser more data?
23:34:19 <levi> If there's a parse rule that's active but runs out of input, you'll get a 'partial' result back that you can later continue from when more input is available.
23:35:34 <mjrosenb> levi: but can I extract any data out of the 'partial'?
23:36:33 <levi> So you expect that there are lines in the file that don't parse correctly with your line parser?
23:36:43 <levi> No, I don't think you can extract data from a 'partial' result.
23:37:42 <mjrosenb> levi: yes, I /know/ there are invalid lines
23:37:48 <mjrosenb> I'm kind of annoyed that they are there.
23:39:52 <levi> Well, just munch and discard the invalid lines; have the parser for a line munch zero or more invalid lines followed by a valid line, returning only the valid line.
23:39:55 <mjrosenb> ahh, I don't have to parse the whole input using a single call.
23:43:21 <michaelt> mjrosenb: here's a pipe-y version, maybe : http://lpaste.net/9098056487569195008
23:44:52 <solatis> c_wraith: thanks, optparse-applicative seems to be really decent
23:45:13 <michaelt> mjrosenb: wait, there's something wrong with the way it recovers from bad lines I think.... it isn't eating the rest of the bad line. ...
23:48:42 <dfeuer> mjrosenb: this is minor, but hand-fusing the minmax fold seems very likely to be slightly better: if something is less than or equal to the current min, it can't be greater than the current max, and the other way 'round.
23:49:19 <dfeuer> Very slightly, probably., but I figured I'd mention it.
23:49:51 <Fuuzetsu> reminder to not \t and code https://github.com/simonmar/alex/blob/master/src/ParseMonad.hs#L29
23:52:09 <dfeuer> Oh wait. Forget that... there could be bad effects to that... hmmmm.
23:52:15 <dfeuer> Would need to measure.
23:52:38 <mjrosenb> ok, my attempt to get attoparsec to also handle newlines seems to have improved it from 70 to 80.
23:53:00 * mjrosenb tries michaelt's version
23:54:01 <mjrosenb> ugh. I installed pipes, but I don't have Pipes.Attoparsec.
23:57:30 <johnw> pipes-attoparsec
