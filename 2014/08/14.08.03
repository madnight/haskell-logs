00:02:16 <dfeuer_> @src cycle
00:02:17 <lambdabot> cycle [] = undefined
00:02:17 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:02:49 <l0cust> Welkin2: ripozumo means "thingamajig that reposes"
00:02:57 <Guest36808> So I'm getting an error about expected type being ByteString, but actual type being bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString. So far I have found on stackoverflow someone solved this by unregistering a version of ByteString, but I get a warning that unregsitering would break another package (json lib depends on one, html lib depends on another). How am I supposed to get around this?
00:03:15 <Welkin2> thingamajig?
00:03:32 <l0cust> Welkin2: English slang for unnamed object
00:03:39 <HeladoDeBrownie> Guest36808, uses cabal sandboxes for separate projects
00:03:40 <Welkin2> I am familiar with it
00:03:49 <Welkin2> I have just never seen it used in a definition
00:04:11 <HeladoDeBrownie> Guest36808, what version does `cabal -V` say? (first line)
00:04:12 <l0cust> Welkin2: well, the presuffix -um- just refers to an undefined object
00:04:17 <l0cust> Welkin2: so...
00:04:21 <Axman6> Guest36808: I would guess you're using a Lazy ByteString when you should be using a Strict one
00:04:41 <HeladoDeBrownie> s/uses/use/
00:04:47 <Guest36808> using version 1.16.0 of the Cabal library
00:05:00 <HeladoDeBrownie> Guest36808, no, the *first* line
00:05:00 <Guest36808> cabal-install version 1.16.0.2
00:05:00 <Guest36808>  
00:05:03 <Welkin2> Guest36808: update your cabal-install
00:05:07 <HeladoDeBrownie> Okay, you have an old version
00:05:09 <Guest36808> (Failed to read :))
00:05:24 <HeladoDeBrownie> Run `cabal install cabal-install`, and make sure $HOME/.cabal/bin is in your $PATH. Do you know how to do that?
00:05:36 <l0cust> Guest36808: shit that's an old version of cabal
00:05:54 <Guest36808> linux-mint, I guess it's not that suprising
00:05:57 <HeladoDeBrownie> Guest36808, also I should probably ask whether you're running Linux as I'm assuming. (That bit me recently :P)
00:06:15 <l0cust> Welkin2: Hmm, what about "ripozejo"?
00:06:26 <l0cust> Welkin2: or "legejo"
00:06:47 <Welkin2> sounds too much like pendejo
00:07:35 <l0cust> Welkin2: that has a rather mortal meaning in Esperanto. It means "lynching ground"
00:07:48 <l0cust> Welkin2: Pendejo, that is
00:08:02 <HeladoDeBrownie> It's derogatory in Spanish
00:08:13 <l0cust> Welkin2: Legejo just means "library"
00:08:20 <l0cust> HeladoDeBrownie: I'm aware, I live in the southwest
00:08:30 <l0cust> HeladoDeBrownie: I get called "pendejo" on a daily basis
00:08:37 * hackagebot http-client 0.3.6.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.6.1 (MichaelSnoyman)
00:08:37 * hackagebot gloss-game 0.3.1.0 - Gloss wrapper that simplifies writing games  http://hackage.haskell.org/package/gloss-game-0.3.1.0 (ManuelChakravarty)
00:08:37 <HeladoDeBrownie> Fun
00:08:37 <Axman6> so no one agrees that Guest36808's problem is just a type error and not a package issue? :/
00:08:46 <l0cust> Axman6: no
00:08:55 <HeladoDeBrownie> Axman6, I've yet to arrive at any concrete conclusions, only guesses
00:09:31 <Axman6> because it really looks like a Lazy/Strict ByteString issie to me...
00:09:36 <Axman6> issue*
00:09:50 <HeladoDeBrownie> Axman6, I think you have good reason in believing so
00:10:12 <l0cust> Axman6: let's let HeladoDeBrownie finish his thing, because Guest36808's cabal version is really fucking old, and then we'll try your thing
00:11:23 <Axman6> might as well change the oil while fillinf the tyres I guess
00:11:30 <l0cust> Axman6: exactly
00:11:36 <glguy> Perhaps it would be worth just pasting the exact error messages
00:12:16 <l0cust> glguy: nonsense, this is Haskell. We lazily obtain the data we need, and make grandiose conclusions based on incomplete evidence. We also campaign against vaccines.
00:12:40 <HeladoDeBrownie> By nature all evidence is incomplete
00:12:58 <l0cust> HeladoDeBrownie: damn you and your logic
00:13:35 <Welkin2> l0cust: why not use a word from zulu
00:13:38 <Welkin2> they sound fun
00:13:40 <Welkin2> or swahili
00:13:50 <l0cust> Welkin2: My father speaks Herero, I might ask him
00:13:52 <Welkin2> https://translate.google.com/#en/zu/sleep
00:14:36 <l0cust> Welkin2: yaluza sounds fun
00:14:44 <HeladoDeBrownie> Guest36808, any luck?
00:14:57 <trap_exit> a haskeller and a lisper compete in building a rockett from scratch; the haskell guy startgs out by ordering rocket fuel, metal, and computers -- and labels them as such; ... someone finish the rest of the joke :-)
00:15:12 <l0cust> Welkin2: it also sounds like something an obese woman turning 44 would call her birthday party
00:15:19 <Welkin2> haha
00:15:28 <HeladoDeBrownie> trap_exit, that elicited a mental shrug from me :P
00:15:39 <HeladoDeBrownie> Not even a real shrug
00:15:40 <HeladoDeBrownie> The shame
00:15:41 <Welkin2> metal shrug*
00:15:42 <trap_exit> ouch
00:15:57 <trap_exit> i thought there was a joke there, but could not finish it myself
00:16:20 <Welkin2> l0cust: give it a name that will make people laugh
00:16:38 <l0cust> Welkin2: I have a fondness for recursive acronyms
00:16:46 <Welkin2> like GNU?
00:16:59 <l0cust> Welkin2: or PNG, or Wine
00:17:41 <l0cust> Welkin2: yes
00:18:01 <l0cust> Welkin2: I also have a fondness for british tanks, hence my nick
00:18:32 * hackagebot gloss-game 0.3.2.0 - Gloss wrapper that simplifies writing games  http://hackage.haskell.org/package/gloss-game-0.3.2.0 (ManuelChakravarty)
00:18:52 <Welkin2> l0cust: why the theme of "rest"?
00:19:04 <Welkin2> does it have a REST interface?
00:19:21 <l0cust> Welkin2: more RESTful than most CMS's, yes
00:19:51 <Welkin2> why not go for a synonym or something with a close definition
00:19:52 <l0cust> I don't know the proper way to pluralize acronyms. I always cringe when someone uses an apostrophe to pluralize something, but with acronyms, I don't see another way.
00:20:01 <Welkin2> sono in portuguese sounds nice
00:20:28 <Welkin2> or repousar
00:20:47 <Welkin2> could be bastardised to reposar
00:21:11 <HeladoDeBrownie> "riposa" is Italian for "it rests" and sounds somewhat similar to "mariposa" which flies in the clouds‚Ä¶ no, that's definitely a stretch :P
00:21:21 <Welkin2> mariposa, haha
00:21:44 <l0cust> Welkin2: there's a big hotel called "mariposa" near where I live
00:21:51 <Welkin2> doesn't that means butterfly?
00:21:54 <HeladoDeBrownie> It does
00:22:08 <Welkin2> I only read that in some cheesy romance novel
00:23:09 <l0cust> "quedo" is "restful" in Galician
00:23:32 * hackagebot gloss-game 0.3.3.0 - Gloss wrapper that simplifies writing games  http://hackage.haskell.org/package/gloss-game-0.3.3.0 (ManuelChakravarty)
00:24:45 <dfeuer_> What exactly is -main-is supposed to do?
00:25:11 <trap_exit> probably change to a different name from "main :: IO ()"
00:25:15 <trap_exit> though I'm just guessing
00:25:56 <HeladoDeBrownie> dfeuer_, you mean in the cabal config? Lets you specify which your Main module is
00:26:09 <HeladoDeBrownie> which should export main, an IO action to execute when the program runs
00:26:15 <dfeuer_> HeladoDeBrownie, I mean the GHC option.
00:26:17 <HeladoDeBrownie> cabal package config*
00:26:25 <HeladoDeBrownie> Hmm, probably similar I imagine?
00:26:40 <HeladoDeBrownie> "Set main module and function"
00:26:50 <l0cust> Welkin2: "umfundi" means "reader" in Zulu.
00:26:57 <l0cust> Welkin2: I could make some joke about monads
00:27:12 <dfeuer_> HeladoDeBrownie, I've just had very little luck making it work....
00:28:51 <l0cust> Welkin2: How about "olele", means "sleeper" in Zulu
00:30:56 <l0cust> Welkin2: I like "olele"
00:30:56 <Welkin2> l0cust: the name is really not that important and you will spend a lot of time on deciding
00:31:05 <l0cust> Welkin2: dammit I'm trying to not do work
00:31:20 <l0cust> Welkin2: now indulge me
00:31:38 <l0cust> Welkin2: I was going to use one of github's suggestions
00:32:04 <l0cust> Welkin2: apparently whoever comes up with the suggestions is an Archer fan. All of the suggestions are Archer references
00:32:07 <solatis> ok, i've done about 8 hours of reading and experimenting with cloud-haskell ... is my assumption correct that, in its current state, it is difficult to implement 'waterfall-stream' like processing? as in, master -> slave a -> slave b -> slave c -> collect results
00:32:10 <l0cust> Welkin2: or keywords from Archer
00:32:36 <solatis> as far as i can see, there is always a supervising master process collecting the results of a slave
00:32:44 <solatis> instead of a slave pushing work to another slave
00:33:56 <Welkin2> l0cust: https://upload.wikimedia.org/wikipedia/commons/1/1d/Tarsius_Syrichta-GG.jpg
00:34:02 <Welkin2> name it after those little guys
00:37:13 <Axman6> solatis: I don't see why that would be so, supervising and messaging are different topics
00:38:36 <Guest36808> Ok, sorry, had to leave. There was cake. So the consensus is still that I update cabal it seems. There's not going to be a problem using cabal to update cabal if I installed it originally through my package manager?
00:39:08 <l0cust> Guest36808: not if you have your $PATH set up correctly
00:39:58 <l0cust> Welkin2: I forgot how cute red pandas are
00:47:46 <Guest36808> Ok, so I've installed cabal 1.20.0.3
00:47:52 <l0cust> Guest36808: good good
00:50:02 <Guest36808> And set PATH=~/.cabal/bin:$PATH in my terminal window
00:50:22 <Guest36808> But then entering ghci and running ":load myfile.hs" gives me the same error
00:51:07 <Guest36808> Of course just going through ghci probably means I'm not using cabal in any way?
01:00:48 <friden> I have a question that has been bugging me for a while: How do i do a reinterpretation of a variable like a let can do but on the middle of a line? ill give an example:
01:00:53 <friden> i have this right now: (y,m,d) <- liftM (toGregorian . utctDay) getCurrentTime return (fromInteger y, m, d)
01:01:27 <friden> oh, copy didnt include line endings, sorry, one more try:
01:01:32 <friden> date :: IO (Int,Int,Int) -- :: (year,month,day)
01:01:38 <friden> date = do
01:01:44 <friden> (y,m,d) <- liftM (toGregorian . utctDay) getCurrentTime
01:01:49 <friden> return (fromInteger y, m, d)
01:01:52 <slomo> friden: put it on lpaste.net for anything that is more than one line
01:02:02 <friden> slomo: sorry, ok i will od that xd
01:03:06 <friden> http://pastebin.com/psRWpAKc
01:04:24 <Guest36808> So my project uses aeson (which depends on bytestring >=0.10.4.0) and blaze-html (which depends on bytestring >=0.9 && <0.11). So no problem there, but when I did "cabal install blaze-html" it chose to use 0.10.0.2 for bytestring, so now I'm getting this problem. What's the proper way to have a sandboxed environment for this project so I don't have to worry about what versions of things I have installed at the user level?
01:06:33 <slomo> friden: thanks, i don't know the answer unfortunately but that's at least easier to read than on irc ;) i would guess that a solution like you want would be rather confusing to read though
01:06:54 <friden> slomo: ok :/ anyways thanks for you answer^^
01:07:09 <HeladoDeBrownie> Guest36808, cd to a directory especially for your project, run `cabal sandbox init` (assuming your PATH points to a suitably recent cabal), then install any necessary packages
01:08:37 * hackagebot webkitgtk3 0.13.0.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.0.0 (HamishMackenzie)
01:08:38 * hackagebot webkit 0.13.0.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.0.0 (HamishMackenzie)
01:09:19 <Guest36808> Ok thanks, I have the dependencies being installed. So I know I'll be able to build it with cabal build. Will ghci know to use the sandboxed dependencies?
01:10:00 <HeladoDeBrownie> Guest36808, not automatically. You can either use `cabal repl`, if you have a package config in that directory, or use a flag to point GHC to the sandbox. The manual should tell you, I forget which.
01:10:13 <HeladoDeBrownie> Guest36808, I'd prefer the former whenever possible anyway
01:10:47 <HeladoDeBrownie> Guest36808, the flag in question is `-package-db [directory]` though
01:11:48 <HeladoDeBrownie> It's late, I should get to bed. Good night~
01:12:59 <Darwin226> Has anyone used ghc-modi?
01:13:49 <Guest36808> Thanks for the help. It builds with cabal build now!
01:18:38 * hackagebot gtksourceview3 0.13.0.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.0.0 (HamishMackenzie)
01:22:02 <Guest36808> Well thanks everyone, I can get it to execute. I'll probably ask more tomorrow.
01:23:55 * hackagebot gtksourceview2 0.13.0.0 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.13.0.0 (HamishMackenzie)
01:33:16 <trap_exit> this is stupid
01:33:19 <trap_exit> but I can't figure out how to do this
01:33:22 <trap_exit> in haskell, how do I write
01:33:30 <trap_exit> while (x <- readTBQueue q) { ... } ?
01:33:40 <trap_exit> this writing of an infinite while loop is new to me
01:37:17 <dfeuer_> trap_exit, there are lots of loops in Haskell. One is forever.
01:37:21 <slomo> trap_exit: http://lpaste.net/108691 something like this, also see http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html
01:37:54 <trap_exit> slomo: ah, and it's tail call optimization that eliminates stack overflow?
01:37:57 <ClaudiusMaximus> trap_exit: let loop = do { x <- readTBQueue q ; if x then .... ; loop ; else return () }  in loop
01:37:58 <dfeuer_> There is also for, if you're dealing with pipes, but I can't claim to understand it.
01:38:49 <trap_exit> hmm
01:38:54 <trap_exit> i wonder if frp is useful for this
01:44:30 * hackagebot aws 0.9.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.9.2 (AristidBreitkreuz)
01:59:31 * hackagebot webkitgtk3-javascriptcore 0.13.0.0 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.0.0 (HamishMackenzie)
01:59:33 * hackagebot webkit-javascriptcore 0.13.0.0 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.13.0.0 (HamishMackenzie)
02:24:34 * hackagebot vtegtk3 0.13.0.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vtegtk3-0.13.0.0 (HamishMackenzie)
02:24:36 * hackagebot vte 0.13.0.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.13.0.0 (HamishMackenzie)
02:29:34 * hackagebot svgcairo 0.13.0.0 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.13.0.0 (HamishMackenzie)
02:29:36 * hackagebot gconf 0.13.0.0 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.13.0.0 (HamishMackenzie)
02:34:34 * hackagebot gtk3-mac-integration 0.3.0.0 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.0.0 (HamishMackenzie)
02:54:36 * hackagebot yesod-bin 1.2.12.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.1 (MichaelSnoyman)
02:59:36 * hackagebot yesod-test 1.2.3.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.3.2 (MichaelSnoyman)
02:59:38 * hackagebot jsaddle 0.2.0.0 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.0 (HamishMackenzie)
03:03:28 <jle`> trap_exit: it's not really tco here
03:03:39 <jle`> hm
03:03:45 <trap_exit> tco here ?
03:03:49 <trap_exit> on tail call optimization
03:03:54 <trap_exit> well, to avoid the intinite stack trace
03:03:57 <trap_exit> I think it is tco
03:03:59 <trap_exit> jle` --
03:03:59 <jle`> actually yeah
03:04:12 <trap_exit> i just realized jle` -- is an no op
03:04:15 <trap_exit> since -- is comment
03:04:18 <jle`> heh
03:04:31 <trap_exit> jle`; you can redeem yourself in the following manner
03:04:37 <trap_exit> why does https://gist.github.com/anonymous/6108c7000e41c5b139ba throw an exception instead of dead lock?
03:04:42 <ion> @karma jle`
03:04:43 <lambdabot> jle` has a karma of 6
03:04:52 <trap_exit> or rather, should https://gist.github.com/anonymous/6108c7000e41c5b139ba deadlock or throw an exception ... because ghcjs is throwing na exception
03:04:56 <trap_exit> and I expect this code to just block that one thread
03:05:30 <jle`> i think tco usually refers to a compiler trick that detects tail calls and changes things to be constant stacky
03:06:08 <trap_exit> forget tco
03:06:13 <trap_exit> I need to know why this code throws an exception
03:06:14 <trap_exit> :-)
03:06:16 <trap_exit> https://gist.github.com/anonymous/6108c7000e41c5b139ba
03:06:29 <jle`> what's the exception?
03:06:38 <trap_exit> uncaught exception in Haskell thread: TypeError: Cannot read property 'blocked' of undefined
03:06:40 <trap_exit> ghcjs
03:07:03 <jle`> that sounds like it might be a ghcjs bug
03:07:16 <trap_exit> jle`; so atomically does not throw exceptions?
03:07:20 <trap_exit> i.e. the atomically $ STM ()
03:07:23 <trap_exit> should just block ... correct?
03:07:42 <jle`> well if something inside the STM block throws an exception, i think it would bubble out
03:08:02 <jle`> but it won't throw an exception on a block, it'll wait for the lock to be freed, so to speak
03:09:37 <jle`> it retries if anything changes in the process of the execution, you know the deal
03:09:53 <tramjoe> Back from taking my daughter to the park, I come with new questions (I a newbie who showed up on that list a few hour ago)....
03:10:48 <tramjoe> So, I am currently thinking about a few things, notably trying to compare what little functional language I am used too (erlang) and the haskell way
03:10:50 <jle`> hi tramjoe ! :D
03:10:58 <tramjoe> Notably, process composition
03:11:18 <tramjoe> It is hard to compose processes explicitely in erlang (no types and a mailbox paradigm)
03:12:23 <trap_exit> screw it; I'll sue skip chans https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent-MVar.html
03:12:24 <tramjoe> I gather than with Haskell, you use typed channels and can compose those
03:12:59 <tramjoe> Does the type system extends the whole way there?
03:14:32 <tramjoe> I guess what I mean is, is there a way to leverage the type system to accomplish something along the lines of protocol types or protocol contracts between processes communicating via channels ?
03:14:59 <tramjoe> Hi jle` :-)
03:15:28 <jle`> hi :)  i'm sorry, i don't know enough about erlang's process communication channel messages to be able to give a meaningful answer
03:15:36 <trap_exit> nope, I need a queue
03:15:49 <jle`> are you talking about this in the context of concurrency and distributed processes?
03:16:03 <tramjoe> (I am using process as in CSP paper, unsure if that is entirely isomorphic with the Haskell concurrency primitives)
03:16:40 <tramjoe> jle` I understand
03:20:13 <trap_exit> okay
03:20:16 <trap_exit> plain GHC just blocks
03:20:18 <jle`> hm i totally accidentally deleted my cabal binary from my windows haskell platform
03:20:23 <trap_exit> so this is definitely a ghcjs bug
03:20:43 <trap_exit> jle`: is this from your new internet / satellite only place, or do you still have a wired connection?
03:20:51 <jle`> i have a connection still
03:20:56 <jle`> but i don't really want to reinstall HP
03:21:41 <jle`> oh cool there are binaries available online
03:23:20 <jxm> Given the lack of biting to my previous question, do you guys know other discussion places I should go to? I know already of lambda the ultimate  and c2 wiki, any other interesting blogs/wikis around?
03:24:35 <jle`> jxm: what was your question?
03:25:05 * hackagebot huzzy 0.1.0.0 - Fuzzy logic library with support for Type-1, Interval type-2 and zSlices enabled type-2 fuzzy sets and systems.  http://hackage.haskell.org/package/huzzy-0.1.0.0 (jna_sh)
03:25:26 <jxm> The one you cannot answer due to " don't know enough about erlang's process communication channel" :-)
03:25:54 <jle`> oh, that was you :)
03:26:15 <jle`> the haskell subreddit is pretty active, and there's also the haskell cafe mailing list
03:26:30 <jle`> alternatively you can ask at a different hour
03:26:31 <jxm> Basically, are there idiomatic ways to somehow implement protocols / contracts for compositions of  channels + processes using the type system ?
03:27:41 <jxm> Mhh, funny, I hang on a few sybreddit s but never thought of adding /Haskell to my list. I suppose I have prejudice against reddit's general worthyness as a technical/reference place :-)
03:27:51 <jxm> I'll try it, thanks jle` !
03:33:52 <jle`> jxm: best of luck :)
03:35:31 <jxm> Thanks :-)
03:55:13 * hackagebot ghcjs-dom 0.1.0.0 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.0.0 (HamishMackenzie)
04:07:40 <boggle> isn't there a function to unwrap the element from a singleton list? basically I have a lazily generated list and i want the first element, but (take 1) leaves it wrapped in a list
04:08:38 <mmmm> head?
04:08:39 <Cale> boggle: there's head, but you'd better be certain that the list is nonempty
04:09:10 <Cale> Usually you'll want to pattern match using case, to be able to handle the case of an empty list
04:09:25 <mmmm> Or there's listToMaybe in Data.Maybe which is a safe head
04:10:22 <Cale> Even if you want the program to fail completely when the list is empty, sometimes you'll be better off using (\(x:xs) -> x) instead, since that will give you an accurate line number when the program fails
04:28:11 <boggle> Cale: yeah, i was looking for either a head that allowed empty lists, or just something to unwrap a singleton
04:28:20 <boggle> doesn't matter now though
04:28:43 <boggle> now i'm wondering how to easily make unfoldr parallel
04:46:03 <pjdelport> boggle: Parallel in what sense?
04:51:30 <kuribas> Does anyone uses haskell-indentation.el?
04:59:17 <int-e> dfeuer_: Hmm, regarding your unfoldr question on the mailing list, I'm not sure how to answer. in order to coax f :: b -> (a, Maybe b) into the shape c -> Maybe (a, c), since I saw no way to pull the 'Maybe' out of the pair, I just replaced c by Maybe b. And that's already the final type, Maybe b -> Maybe (a, Maybe b).
05:00:47 <dfeuer_> I'm going to have to meditate on that, int-e. But I should mention that my testing indicated GHC is good enough to erase both layers of Maybes in typical cases.
05:00:52 <benmachine> :t uncurry (fmap . (,))
05:00:53 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
05:01:54 <int-e> that's slightly surprising, but good :)
05:02:55 <dfeuer_> int-e, I'm not at all surprised by the one layer, but I am surprised that the one you added didn't hose it.
05:03:15 <dfeuer_> [or at least I don't think it did. I can't remember just what tests I tried]
05:07:12 <PotatoGim> Hi
05:10:16 <int-e> dfeuer_: Operationally, the extra Maybe allows for the check for the end of the list to be done one "unfoldr" iteration later. And that makes it surprising; it seems to me that in order to eliminate that Maybe again, ghc will have to split the 'go' function into two steps (the fmap, and the rest) and then rearrange it by choosing another loop breaker.
05:19:09 <t4nk687> hey i had a question
05:19:52 <t4nk687> what is the difference between . and $
05:20:05 <dibblego> quite a lot
05:20:14 <hpc> @src ($)
05:20:14 <lambdabot> f $ x = f x
05:20:17 <dibblego> (f $ x) is the same as (f x)
05:20:17 <hpc> @src (.)
05:20:18 <lambdabot> (f . g) x = f (g x)
05:20:30 <dibblego> (f . g) is the same as (\x -> f (g x))
05:20:44 <t4nk687> what is the use of $
05:21:09 <hpc> ($) has the lowest operator precedence
05:21:09 <dibblego> to do function application with low fixity
05:21:13 <exlevan> > "See ß 1"
05:21:15 <lambdabot>  "See \65533 1"
05:21:29 <t4nk687> fixity?
05:21:39 <kuribas> t4nk687: So you need less parens
05:21:47 <exlevan> how do I prevent escaping of 'ß'?
05:21:51 <hpc> fixity is precedence and associativity
05:22:13 <t4nk687> ahh you mean the precedence of operators to the left is lower?
05:22:17 <hpc> ($) has fixity of 9 and right, iirc?
05:22:44 <hpc> > w * x $ y $ z :: Expr
05:22:45 <lambdabot>  Couldn't match expected type ‚Äòs0 -> Debug.SimpleReflect.Expr.Expr‚Äô
05:22:46 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
05:22:46 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
05:22:52 <hpc> > w * f $ y $ z :: Expr
05:22:53 <lambdabot>  Couldn't match expected type ‚Äòs0 -> Debug.SimpleReflect.Expr.Expr‚Äô
05:22:54 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
05:22:54 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
05:22:56 <hpc> > w * f $ g $ z :: Expr
05:22:58 <lambdabot>  Couldn't match expected type ‚Äòs0 -> Debug.SimpleReflect.Expr.Expr‚Äô
05:22:58 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
05:22:59 <hpc> bah
05:23:33 <hpc> http://www.haskell.org/haskellwiki/Keywords#infixr
05:24:30 <hpc> > text "exlevan: See ¬ß 1"
05:24:32 <lambdabot>  exlevan: See ¬ß 1
05:25:07 <int-e> @tell dfeuer_ Ah, constructor specialisation (SpecConstr) looks like it can (at least in principle) turn 'unfoldr (fmap f) . Just' into the same code as 'unfoldr1 f'.
05:25:08 <lambdabot> Consider it noted.
05:25:10 <MiracleBlue> Anyone know if there are any good mirrors of the Haskell Platform installer for mac?  The speeds I'm getting from the main server are extremely slow.
05:25:50 <ColonelJ> I read somewhere that haskell used to use lazy lists or something to represent I/O, before eventually moving to use the IO monad.  Does anyone have any details of this, and much more crucially, what was so wrong with this original representation that made use of IO monad necessary?
05:26:47 <hpc> ColonelJ: someone told me what it was like and i forget most of it
05:27:00 <hpc> ColonelJ: but one issue was that getting data out of something like getLine was absolutely terrible
05:27:26 <exlevan> hpc: in what package is 'text' defined?
05:27:57 <hpc> http://hackage.haskell.org/package/pretty-1.1.1.1/docs/Text-PrettyPrint-HughesPJ.html
05:27:59 <ColonelJ> if possible I'd like some good references on it, be it research papers, or even forums or blogposts
05:28:23 <hpc> exlevan: it's ridiculously hard to find, so i have it memorized ;)
05:30:30 <merijn> ColonelJ: I don't remember the details, you should ask augustss when he's in here
05:31:11 <merijn> ColonelJ: He worked on the very first haskell implementations and is in here reasonably often, so he should be able to point you in the right direction
05:31:35 <merijn> Otherwise try asking the haskell-cafe mailing list
05:31:37 <ColonelJ> yea I'll definitely be sticking around today
05:31:42 <ColonelJ> hmm I found something
05:31:43 <ColonelJ> https://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
05:34:17 <darthdeus> hey guys, is there somewhere a guide on the parsec tokenizer? specifically Text.Parsec.Token
05:35:07 <darthdeus> like how to define custom language styles etc
05:38:46 <Th30n> haskell.org down only for me?
05:41:49 <alpounet> Th30n: nope
05:42:05 <ohgod> rip haskell.org
05:42:27 <Th30n> :(
05:42:39 <Th30n> Can I get documentation for function from lambdabot?
05:42:58 <ohgod> The answer to that question would be in the hackage documentation :P
05:43:04 <Th30n> oh lol, I have the base docs installed xD
05:43:10 <Th30n> i can check locally
05:43:12 <Th30n> silly me
05:43:13 <ohgod> That works too.
05:43:27 <t4nk080> :t f . g
05:43:29 <lambdabot>     Could not deduce (Show b0) arising from a use of ‚Äòf‚Äô
05:43:29 <lambdabot>     from the context (FromExpr c, Show a)
05:43:29 <lambdabot>       bound by the inferred type of it :: (FromExpr c, Show a) => a -> c
05:43:52 <ohgod> :t undefined
05:43:53 <lambdabot> a
05:44:05 <t4nk080> :t a *** g
05:44:06 <lambdabot>     Couldn't match expected type ‚Äòa b c‚Äô with actual type ‚ÄòExpr‚Äô
05:44:06 <lambdabot>     In the first argument of ‚Äò(***)‚Äô, namely ‚Äòa‚Äô
05:44:07 <lambdabot>     In the expression: a *** g
05:44:42 <ColonelJ> :t forever (putStrLn "alone")
05:44:44 <lambdabot> IO b
05:47:20 <ohgod> Phew. Glad I installed documentation with 7.8.3
05:47:46 <ColonelJ> "languages, such as Haskell, wear a hair shirt" Simon Peyton Jones, 2000
05:48:19 <ohgod> Itchy.
05:50:04 <ColonelJ> http://www.newadvent.org/cathen/07113b.htm interesting
05:51:55 <pjdelport> ColonelJ: That's a reference to how sticking to the principle of functional purity, even when it was very inconvenient (e.g. before monadic I/O) paid off in the form of the solutions Haskell now has.
05:52:23 <ColonelJ> yes indeed, very apt
05:53:00 <benzrf> i think hackage is down
05:53:12 <ColonelJ> all of haskell.org is down
05:54:37 <benzrf> D:
05:54:44 <burp> bleh, always when I need to access hackage‚Ä¶
05:56:02 <ColonelJ> "laziness and side effects are, from a practical point of view, incompatible" I'm not sure I agree with this statement even if it is true to an extent...
05:57:05 <systemfault> What do you guys think about the relation between OOP and FP, they feel mutually exclusive to me.. but a lot of people told me they aren‚Äôt
05:57:11 <hpc> "side effects" there means that when you evaluate a value, stuff happens
05:57:30 <ColonelJ> that's what side effects always means doesn't it?
05:57:35 <hpc> but laziness makes it difficult to predict when a value will be evaluated
05:57:37 <Cale> systemfault: The heart of the idea of OOP is easy to express in a functional language
05:57:42 <mmmm> The problem is that you can't predict what order things will happen
05:58:00 <hpc> see: the gazillions of problems people have with hGetContents
05:58:34 <earthy> hm. many people work with IEnumerable<T> in C# and have little problem
05:59:02 <hpc> IEnumerable is not lazy
05:59:02 <earthy> even though may implementations are lazy
05:59:07 <hpc> it's a stream
05:59:16 <hpc> (which is different because in C# you are "always in IO")
05:59:58 <earthy> yeah, every arrow in C# has an implicit 'IO'
06:00:15 <earthy> type-arrow, not the other arrows :P
06:00:19 <ColonelJ> is it not possible to have some hybrid that allows lazy evaluation but still enforces ordering and forced evaluation of expressions which are established to generate side effects (through analysis).  Is lazy evaluation supposed to be some mandate that something will never be evaluated?
06:00:38 <hpc> but the main thing is that with IEnumerable it's easy to control when things are requested
06:00:42 <hpc> (via for)
06:00:46 <earthy> ColonelJ: perfectly possible. as long as you have uniqueness.
06:00:46 <Cale> systemfault: The central idea of OOP is to have values that are determined by the manner in which they respond to messages or methods. This can be accomplished through records having fields of the appropriate types. The "encapsulation" aspect can then be had by defining functions that construct such records: the function parameters corresponding to "private" data.
06:01:37 <ColonelJ> earthy: uniqueness of?
06:01:43 <systemfault> Cale: Hmm, but by that definition, could you say that C is a OO language?
06:01:49 <hpc> ColonelJ: uniqueness types
06:01:54 <Cale> systemfault: C doesn't have first class functions, so this doesn't work
06:01:56 <hpc> https://en.wikipedia.org/wiki/Uniqueness_type
06:02:21 <earthy> ColonelJ: the problem is that without uniqueness you won't have the guarantee that some side effect will not be performed *twice*
06:02:34 <earthy> which makes it especially hard to reason about :)
06:02:40 <Cale> systemfault: This encoding relies on first class functions, and their ability to capture the values of variables in scope at their point of definition.
06:02:43 <ColonelJ> Right, I understand (indeed it is fairly obvious in a way)
06:02:55 <systemfault> Cale: Ahh, thanks for the clarification :)
06:03:17 <burp> great that the "Hackage down?" mirror is hosted at the same provider as haskell.org :P
06:03:26 <hpc> burp: lol
06:03:48 <Cale> systemfault: At least, once you have methods/messages which have parameters, which is pretty important :)
06:04:36 <benzrf> Cale: i like just 'behavior that has persistent state coupled with it as a unit'
06:04:49 <benzrf> so, basically mutable closures :-)
06:04:53 * benzrf googles for that one koan
06:04:55 <Cale> Yeah, I don't tend to think of the statefulness as central to the idea
06:05:06 <benzrf> oh?
06:05:06 <hpc> i think i know the koan you mean
06:05:12 <benzrf> well there are bajillions of definitoins
06:05:14 <benzrf> *definitions
06:05:22 <Cale> But you can do that too, e.g. by having methods that produce IO actions
06:05:39 <benzrf> i go for 'state w/ behavior' because it's a simple contrast with 'behavior divorced from state'
06:05:43 <Cale> Or a more pure encoding would have methods that produce new objects.
06:05:45 <benzrf> well
06:05:52 <benzrf> thats a justification, not a motivation
06:05:52 <Cale> (along with their result)
06:05:59 <benzrf> http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent
06:06:36 <hpc> i love using closures over mutable values
06:06:38 <hpc> in js and perl
06:06:52 <hpc> (and haskell with IORef)
06:07:13 <benzrf> hpc: oop tends to be about multiple methods sharing the same state
06:07:27 <benzrf> but if your closure's calling behavior differs by what args you pass
06:07:33 <benzrf> that's not really a huge distinction
06:07:34 <benzrf> :3
06:07:36 <hpc> multiple closures over the same reference
06:07:40 <benzrf> that too
06:07:54 <hpc> i normally don't go that far though
06:07:59 <Cale> I really don't like abusing the word "closure" to mean "function"
06:08:33 <benzrf> Cale: i have only ever heard closure mean 'function that is closed over its lexical scope' in cmmon usage
06:08:35 <Cale> Closures are only closures until you can't separate them into environment and code anymore.
06:08:36 <mhl> Hoogle doesn't work and I want to find a function that concatenates two Strings with some separator between them, eg. fun "a" "b" "-" would produce "a-b". Is  there such function, or do I have to roll it on my own?
06:08:44 <benzrf> i think i heard somebody crotchet about other definitions about once
06:09:06 <ektello> doesn't fpcomplete have a hackage mirror? or was that a fantasy I conjured up?
06:09:17 <hpc> > intercalate "-" ["a", "b", "snorb"]
06:09:19 <lambdabot>  "a-b-snorb"
06:09:24 <benzrf> mhl: concat a b c = a ++ b:c
06:09:24 <Cale> benzrf: A closure is a data structure which consists of some code with free variables in it, together with an environment which maps those free variables to values.
06:09:26 <benzrf> for 1-char
06:09:35 <Cale> benzrf: i.e. it's a specific type of pair
06:09:36 <ColonelJ> > :t join
06:09:38 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
06:09:45 <benzrf> Cale: sounds like an implementation detail :)
06:09:46 <ColonelJ> :t join
06:09:48 <lambdabot> Monad m => m (m a) -> m a
06:09:50 <hpc> > intercalate "-boop-" ["a", "b", "snorb"] -- also with longer separators
06:09:51 <lambdabot>  "a-boop-b-boop-snorb"
06:09:53 <Cale> benzrf: Closures *are* an implementation detail
06:10:02 <Cale> benzrf: Functions are the things they're used to implement
06:10:07 <Cale> (typically)
06:10:18 <mhl> Great, thanks a lot!
06:10:22 <benzrf> yeah well i use 'closure' to talk about functions when i am focusing on their ability to close over things
06:10:34 <benzrf> same as how i use 'monad' to talk about lists when im focusing on their join operation
06:10:48 * hpc usually takes it from the syntactic perspective, where a closure is the specific aspect of a value where it closes over something else in the same scope
06:10:50 <Cale> But closure isn't more general than function.
06:11:03 <Cale> It's a different thing entirely, and supports a different set of operations.
06:11:27 <hpc> so a javascript object could be a closure too, for instance
06:11:29 <benzrf> meh
06:11:45 <benzrf> Cale: l-language changes
06:11:59 <hpc> i realize that's probably even less correct than "closure = function" but whatever ;)
06:12:08 <benzrf> i have no time for academic pedantrwait no thats my favrite thing
06:12:09 <Cale> However, people abuse the term so much now that you're pretty much right, I just think it's not useful to do that.
06:12:29 <benzrf> Cale: closure has gone the way of literally :'(
06:12:59 <hpc> this function is literally a closure :D
06:15:48 <EvilMachine> Is there a generic function to lift a function into a newtype?
06:16:02 <Obiru> http://www.downforeveryoneorjustme.com/haskell.org
06:16:08 <burp> does anyone know another hackage mirror?
06:16:10 <EvilMachine> Obiru: yep :(
06:16:36 <burp> Obiru: http://www.hetzner-status.de/ (in german) data center is down, ETA is unknown
06:16:43 <benzrf> EvilMachine: i think theres a package and typeclass for that
06:16:53 <benzrf> i think lens has something <- universally true statement
06:17:23 <EvilMachine> burp: you could install hoogle on your own box. If you have the package installed and hoogle support enabled, the docs should already be prepared for it.
06:17:37 <benzrf> Obiru: protip: http://isup.me/haskell.org
06:17:56 <pjdelport> EvilMachine: There is newtype deriving, which may be related.
06:18:20 <EvilMachine> benzrf: If you include the other stuff from category-extras, the ‚Äúuniversally true statement‚Äù might definitely be universally true. :)
06:18:43 <EvilMachine> pjdelport: That only helps if the inner type has type classes.
06:18:55 <EvilMachine> pjdelport: In my case the inner type is a Map
06:22:30 <kamatsu> does anyone know what happened to haskell.org?
06:24:45 <ColonelJ> that's interesting, apprently the way GHC implements IO monad is vulnerable to the exact same issue just discussed (duplicating expressions with side effects) and the fact it works relies on a compiler hack
06:25:25 <ColonelJ> the uniqueness thing is basically by construction in the compiler
06:26:44 <benzrf> kamatsu: it was a partial website and somebody put in the wrong input
06:28:18 <mongo> hi what is this channel about
06:28:49 <hpc> unicorns
06:28:56 <benzrf> mongo: warm, fuzzy things
06:29:13 <yitz> mongo: the haskell programming language (seriously)
06:29:26 <hpc> see also, the channel topic
06:30:11 <burp> I doubt channel topic helps more than channel name right now ;)
06:32:19 <mongo> what is haskell
06:32:36 <mongo> #defocus told me this is the coolest channel
06:32:40 <ColonelJ> it's a programming language used by mathematically minded people who like to be lazy
06:32:50 <yitz> uh oh, the outage includes hackage. luite's mirror to the rescue. (see channel topic)
06:32:53 <mongo> okey just like html then
06:33:04 <yitz> heh
06:33:26 <ColonelJ> it's more lazy than HTML, you have to write less code
06:34:07 <ColonelJ> however you can easily spend several hours writing a single line if you're not careful
06:34:27 <burp> yitz: " luite's mirror to the rescue. " <- nope, it's hosted in the same data centre :(
06:35:53 <yitz> burp: you're kidding! that's an unfortunate new circumstance.
06:36:02 <yitz> > fix ("hi mongo! " ++)
06:36:03 <lambdabot>  "hi mongo! hi mongo! hi mongo! hi mongo! hi mongo! hi mongo! hi mongo! hi mo...
06:36:27 <mongo> hahaha
06:36:32 <mongo> where do you use this language
06:36:48 <silver> anywhere
06:37:49 <yitz> mongo: one good place to use it is tryhaskell.org
06:38:22 <mongo> yitz: what is the .end
06:38:44 <EvilMachine> mongo: A life support machine would be a good place to use haskell. :)
06:38:44 <yitz> mongo: it's infinite
06:39:09 <McManiaC> hoogle down?
06:39:30 <EvilMachine> McManiaC: Whole server, hoogle, hackage, haskell.org, :(
06:39:57 <McManiaC> EvilMachine: ouch :(
06:39:58 <burp> you get what you pay for, they are one of the cheapest providers
06:40:09 <EvilMachine> I guess we‚Äôll have to go back to living like cave men‚Ä¶
06:40:18 * EvilMachine joins #C
06:40:25 <silver> lol
06:40:48 * EvilMachine sharpens his pointer stick
06:41:14 <burp> yea, if hackage doesn't work I'll write my program in C with C libraries now and do haskell bindings afterwards :P
06:42:30 <gn0> Hi!
06:42:31 <EvilMachine> burp: On my system I could just add ‚Äúhoogle‚Äù to the USE flags, emerge hoogle, and would probably have my own hoogle and documentation, but I‚Äôm too lazy. ;)
06:42:35 <ColonelJ> seriously though, you could just invent a load of your own functions and use those, then write functions later to translate the ones you defined into the real ones
06:42:48 <yitz> EvilMachine: IDENTIFICATION DIVISION. PROGRAM-ID. ThisProgramIsInCobol...
06:42:57 <EvilMachine> ColonelJ: You mean like a‚Ä¶ compiler?
06:43:13 <mongo> im very angry at this game
06:43:17 <burp> EvilMachine: yes, but not the hackage packages itself now :/
06:43:40 <ColonelJ> EvilMachine: yea just invent your own language within haskell and then use that
06:43:57 * EvilMachine googles for ‚Äúevil assembler examples‚Äù
06:44:13 * geekosaur points to the hackage mirror in the /topic
06:44:56 <yitz> geekosaur: it's down too :(
06:44:58 <EvilMachine> geekosaur: You mean the one that‚Äôs hosted on at same broken data center? :)
06:45:10 <geekosaur> oh
06:45:13 <yitz> hi gn0
06:45:25 <yitz> mongo: what went wrong?
06:45:25 <geekosaur> (wat. that is not how mirrors should be done...)
06:45:28 <EvilMachine> If you know the URL, there‚Äôs always google cache
06:45:32 <EvilMachine> or archive.org
06:45:36 <gn0> hi ytiz
06:45:36 <mongo> yitz it dosent work
06:45:40 <ColonelJ> you don't need the URL to use google cache
06:45:54 <yitz> mongo: what doesn't work?
06:46:02 <EvilMachine> geekosaur: I think we have a new recruit for Captain Obvious. :)
06:46:09 <mongo> yitz i dont know where i can use it i cant use it with php nor java
06:46:20 <geekosaur> EvilMachine, if it's so obvious then why did it happen?
06:46:35 <hpc> here we go
06:46:45 <geekosaur> I was just thinking, relatedly, that with everyone moving to the oh so reliable cloud, we're about due for the tech equivalent of Madoff >.>
06:46:45 <EvilMachine> geekosaur: That‚Äôs a question for Philosoraptor right there. :)
06:47:54 <EvilMachine> geekosaur: :D I just installed my own VPN on my dynamic dns home server, and in effect have my own private ‚Äúcloud‚Äù. (Of course I‚Äôd never call it that.)
06:48:36 <phaazon> hm
06:48:47 * EvilMachine always has to think of ‚Äúklaut‚Äù, when reading ‚Äúcloud‚Äù. ‚Äúklaut‚Äù is German for ‚Äústeals‚Äù.
06:48:59 <phaazon> how do you flatten [IO (Either String a)] into IO (Either String [a])?
06:49:05 <hc> no, 'klaut' is german for cloud ;)
06:49:05 <phaazon> I use fmap sequence . sequence
06:49:10 <phaazon> not sure it‚Äôs the cleaner way :)
06:49:26 <EvilMachine> hc: yes and no. :)
06:50:14 <prophile> phaazon: unsafeCoerce
06:50:16 <prophile> :)
06:50:22 <phaazon> yeah.
06:50:24 <phaazon> I prefer mine.
06:50:24 <phaazon> :D
06:50:35 <quchen> phaazon: You've got a structure like f (g (h a)), where f = [], g = IO, h = Either String. You want to commute the "f" all the way to the inside which requires two neightbour permutations, so I think what you've got is the right way to go.
06:50:51 <phaazon> yeah
06:50:58 <phaazon> I want to collect inner actions
06:51:00 <phaazon> (sequence)
06:51:09 <phaazon> and map a collection again
06:51:17 <phaazon> so fmap sequence . sequence sounds okay after all :)
06:51:53 <quchen> Maybe there's a fancier way of writing the same, like
06:51:58 <quchen> :t traverse T.sequenceA
06:51:59 <lambdabot> (Traversable t1, Traversable t, Applicative f) => t (t1 (f a)) -> f (t (t1 a))
06:52:08 <quchen> That's not the right permutation for you, but should give you some ideas :-√æ
06:52:09 <phaazon> quchen: traverse id
06:52:20 <phaazon> traverse id = sequence :D
06:52:27 <quchen> That's also not what you want.
06:52:36 <phaazon> yeah
06:52:37 <phaazon> well
06:52:54 <phaazon> fmap sequence . sequence is quite okay to me
06:52:58 <phaazon> I understand that pretty well
06:53:09 <EvilMachine> unsafeJustRunThisCCode "int _,O,__??('}'??);main(){while(O?gets((rand()%O++?':':_)+__)||puts(&__??(_??))&_:srand(time((O+++_)))||O);}"
06:56:42 <jfeltz> I'm out of hackage mirrors to choose from, anyone have one besides hdiff?
06:57:26 <jfeltz> I remember fpco used to have one
07:03:22 <Th30n> I have [Maybe a]. What's the easiest way to turn that into [a]? Obviously Nothing should be discarded.
07:03:50 <quchen> ?hoogle [Maybe a] -> [a]
07:03:50 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:03:51 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:03:51 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:04:03 <Th30n> thanks
07:09:19 <EvilMachine> Update on haskell.org being down: Hetzner states that they apparently had a voltage drop that caused all they systems in the data center 19 to reboot.
07:09:22 <dottedmag> > sequence [Maybe 1, Maybe 2, Nothing]
07:09:23 <lambdabot>  Not in scope: data constructor ‚ÄòMaybe‚ÄôNot in scope: data constructor ‚ÄòMaybe‚Äô
07:09:36 <dottedmag> > sequence [Just 1, Just 2, Nothing]
07:09:38 <lambdabot>  Nothing
07:10:39 <mmmm> Th30n: or if you're doing catMaybes . map f then you can use mapMaybe
07:10:40 <pjdelport> :t foldr (liftA2 (liftA2 (:))) (pure (pure []))
07:10:41 <lambdabot> (Applicative f1, Applicative f) => [f (f1 a)] -> f (f1 [a])
07:11:18 <pjdelport> phaazon: If you're looking for something more principled than the double sequencing, maybe that?
07:11:41 <Th30n> mmmm: Thanks, but I'm actually doing map (a -> Maybe b) [a] then when I get [Maybe b] I cat that
07:12:22 <mmmm> @type mapMaybe
07:12:23 <lambdabot> (a -> Maybe b) -> [a] -> [b]
07:12:32 <mmmm> Th30n: ^
07:12:51 <Th30n> mmmm: xD
07:13:11 <Th30n> mmmm: Can't get used to reading composition right
07:15:16 <rufs> I guess it finally paid of to always have a bunch of "should read" tabs open in the browser
07:16:03 <mmmm> Can someone ping me when haskell.org gets back up please :)
07:16:36 <Th30n> mmmm: will do
07:17:24 <phaazon> pjdelport: I‚Äôm looking for the simpler way
07:17:29 <phaazon> fmap sequence . sequence wins :)
07:18:00 <EvilMachine> What the hell did they do there, that a simple reset can‚Äôt be solved by just letting the servers boot up again? (after playing back the file system transactions of course)
07:18:41 <beaky> hello
07:18:59 <pjdelport> phaazon: The above is conceptually simpler, perhaps, given sequence as foldr (liftA2 (:)) (pure [])
07:19:20 <burp> EvilMachine: I don't think the problem report is precise, I know more servers that are in that data center and are not accessible right now
07:19:36 <pjdelport> Instead of two traversals at two different levels, you just have the one traversal that combines both. :)
07:20:04 <McManiaC> man, why does the "Integral a =>" instance match even tho PB_SystemMsg is no integral :/ http://puu.sh/aD1NE/bcf1aba0ec.png
07:20:11 <McManiaC> that's stupid
07:20:13 <phaazon> pjdelport: there might exist rules for that :)
07:22:06 <Algebr> Was wondering about how ghc compiles code, is it just like one big computation?
07:25:21 <Cale> Algebr: There was a video of a talk given by SPJ at the Haskell Implementors' Workshop about the general structure of GHC and what it does. Let me see if I can dig it up for you.
07:25:26 <dottedmag> Algebr: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
07:25:29 <hpc> Algebr: https://ghc.haskell.org/trac/ghc/wiki/Commentary
07:25:38 <hpc> FMTYEWTKA ghc compilation
07:25:41 <Cale> Unfortunately, it's a bit tricky to locate with haskell.org being down...
07:25:46 <SrPx> Is there any standard operator that feeds a value to a function? "x |> f = f x" something like that
07:25:51 <Algebr> why is haskell.org down?
07:25:58 <hpc> Cale: ghc.haskell.org appears to be up
07:25:59 <u-ou> Cale: I would be interested in seeing that too
07:26:23 <hpc> Algebr: data center issues
07:26:24 <dottedmag> https://ghc.haskell.org/trac/ghc/wiki/AboutVideos
07:27:03 <Cale> oh, GHC hackathon
07:27:10 <Cale> yes
07:27:15 <Cale> those are the ones I'm thinking of
07:27:41 <dottedmag> SPJ book is a good introduction though.
07:27:50 <Algebr> dottedmag: nice! thank you !
07:28:26 <dottedmag> Algebr: book describes pre-ghc era, but it's easy to see how ghc evolved since.
07:29:44 <alpounet> SrPx: lens (and servant) define an operator for that: (&). I don't know if it's common to name it that way but anyway, here are two data points
07:30:16 <Cale> Oh, also, the Spineless Tagless G Machine paper is also likely quite helpful for getting a sense for how Haskell might be transformed to machine code. It's a little out of date with how GHC actually does things now, but there are papers describing the changes there as well.
07:30:48 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
07:32:18 <Cale> (In particular, GHC's machine is no longer spineless or tagless, ironically)
07:32:21 <nisstyre> Cale: for info on implementing static functional languages in general, Compiling with Continuations (the book) is invaluable
07:32:41 <nisstyre> actually it's useful for *any* functional language
07:32:42 <vanila> Compiling with Continuations is great, but that's for something like scheme or ocaml
07:32:48 <SrPx> Cale: what is up to date with how GHC does things?
07:32:48 <nisstyre> SML actually
07:32:59 <nisstyre> but it's useful for other language implementations too
07:33:01 <vanila> haskell being lazy, needs something totally different
07:33:09 <nisstyre> vanila: not quite
07:33:19 <nisstyre> thunks can be represented using the same algorithm for closures
07:33:26 <benzrf> ok so
07:33:31 <benzrf> i'm looking at peirce's law
07:33:36 <benzrf> it confuses me
07:33:51 <benzrf> @djinn ((p ‚Üí q) ‚Üí p) ‚Üí p
07:33:51 <vanila> benzrf, what's confusing about it
07:33:52 <lambdabot> Cannot parse command
07:33:59 <benzrf> @djinn ((p -> q) -> p) -> p
07:33:59 <lambdabot> -- f cannot be realized.
07:34:00 <vanila> it's only true in classical logic
07:34:03 <benzrf> vanila: oh
07:34:14 <vanila> so you can't give a lambda term that "proves" it, but you can prove it with excluded middle
07:34:25 <benzrf> you can prove its converse
07:34:27 <benzrf> *disprove
07:34:39 <vanila> also it's related to call with current continuation
07:34:45 <benzrf> I:
07:34:50 <SrPx> Any idea why I cn't install `hoogle`? http://lpaste.net/108696
07:35:34 <dottedmag> doesn't it download packages from haskell.org which is down?
07:35:53 <benzrf> dottedmag: ya
07:35:58 <Cale> SrPx: Well, this paper describes the pointer tagging in GHC http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm
07:36:03 <_2__brianna_99> Hey!
07:36:07 <benzrf> sup
07:36:17 <_2__brianna_99> How have you been?
07:38:19 <SrPx> Cale: thanks (:
07:38:24 <Cale> SrPx: http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=2B27688E4051F86A24DD6CD3246DF0F9?doi=10.1.1.19.411&rep=rep1&type=pdf
07:38:46 <_2__brianna_99> Hey Cale!
07:38:48 <Cale> Describes some additional changes which have been made in the face of concurrency
07:39:05 <Cale> There's actually a fair amount more than that to say, but people have linked useful resources
07:39:09 <Cale> _2__brianna_99: hello!
07:39:26 <dottedmag> Heh, so spineless tagless G-Machine is no longer spineless and has got tags? :)
07:39:30 <_2__brianna_99> How have you been?
07:40:00 <SrPx> something I ask often, why isn't there any attempt to implement a Haskell runtime on the GPU? considering haskell computations is based on reductions that are absolutely and inherently parallel, wouldn't that be at least somewhat interesting?
07:40:26 <_2__brianna_99> How do you work this app?
07:40:38 <benzrf> SrPx: there's reduceron, which is just barely related
07:40:55 <SrPx> benzrf: yes but it is not meant to run in a regular pc, though (right?)
07:41:11 <SrPx> except if there is some way to run fgpa programs on the gpu? hm
07:41:13 <benzrf> yah
07:41:49 <_2__brianna_99> I just want friendship!
07:42:18 <k00mi> SrPx: GPUs are no good for general-purpose parallelism
07:42:53 <k00mi> SrPx: they are good for running the same operation over a large set of data
07:43:42 <Algebr> So is the dragon book not all that useful for ghc? or is it just like a high level reference
07:43:57 <SrPx> k00mi: yes, the point I don't get is, why can't "some operation" be beta reduction? Haskell's runtime is basically the "same operation" being repeated over and over sequentially
07:47:27 <k00mi> SrPx: I see several problems: 1. there are still lots of data dependencies; 2. the operation might be too complex to be executed on a GPU core efficiently
07:48:15 <Guest20678> Hackage mirror mirrors? hdiff.luite.com appears to be down.
07:48:28 <k00mi> SrPx: there is no magic parallelism in your algorithm just because you write it in haskell
07:49:28 <SrPx> k00mi: I see those problems too, but beta reduction is not *that* complex if you think about it. Also, other than the necessary memory allocation, everything has locality. I'm not sure it would work, but I would love to see a paper investigating that.
07:50:18 <dutchie> hmm
07:50:23 <Philonous> Qfwfq, see http://www.reddit.com/r/haskell/comments/2ci15f/hackage_is_down_are_there_any_mirrors_available/
07:50:41 <dutchie> is it just me, or is the "hackage down" link in the topic also down
07:50:43 <quchen> I'm wondering, is there an estimate of the (order of magnitude of the) current number of Haskell users somewhere? GHC downloads, certain packages?
07:50:53 <dutchie> i mean http://hdiff.luite.com
07:51:01 <quchen> When a new compiler is released, how many people are affected?
07:51:03 <dottedmag> dutchie: it is
07:51:28 <SrPx> k00mi: hmm I actually disagree. For example, "sumNodes (Tree a b) = sumNodes a + sumNodes b; sumNodes (Leaf x) = x". `sumNodes a` and `sumNodes b` are (afaik) inherently parallel according to Haskell evaluation rules - the compiler is free to chose which one to reduce first, or to do it in parallel. The only reason it is done sequentially is because of how the runtime works with the CPU
07:51:34 <Qfwfq> Philonous: Hmm.. looking for documentation, rather than packages, but I suppose I can just unpack and haddock.
07:51:50 <dottedmag> dutchie: It's in the same datacenter. Oops :)
07:51:51 <Philonous> That, too
07:51:55 <vanila> oh
07:52:55 <vanila> is hackage down the reason I can't install idris
07:52:55 <Qfwfq> vanila: Yes.
07:53:18 <SrPx> quick question, I want to install Hoogle but it is warning me that proceeding can break several libs I need. How can I avoid that using sandboxes?
07:53:35 <k00mi> SrPx: you need at least dozens if not hundreds of parallel computations to get any speedup out of using a GPU
07:53:39 <mgsloan> vanila: You can use luite's mirror: http://www.reddit.com/r/haskell/comments/y1tgc/any_hackage_mirrors_how_do_you_deal_with_hackage/c5rk46g
07:53:44 <pjdelport> SrPx: The complexity isn't in beta reduction, but in the data dependencies. GPGPUs are good for stream processing, but not for random memory access (which beta reduction requires).
07:53:55 <mgsloan> (or at least I think you can, for me right now hdiff.luite.com isn't loading, so maybe not..)
07:54:09 <Qfwfq> mgsloan: Luite's mirror is down, as it's housed in the same data center, apparently.
07:54:21 <Qfwfq> mgsloan: FPComplete's mirror is fine.
07:54:24 <mgsloan> Qfwfq: Oh no!  Well, that explains that
07:55:11 <Qfwfq> Our critical infrastructure is so brittle.. :-(
07:55:51 <SrPx> pjdelport:  I see... hm
07:56:08 <k00mi> Qfwfq: hetzner being down doesn't happen very often
07:56:33 <SrPx> anyway, nobody ? Should I just create a dir "hoogle" and "cabal sandbox init; cabal install hoogle" ?
07:56:52 <Qfwfq> I didn't know we were using Hetzner machines. But uh official redundancy would be nice.
07:59:37 <Qfwfq> SrPx: If hoogle/.cabal-sandbox/bin is in your path, that should be fine.
08:00:45 <SrPx> Qfwfq: so every time I want to install a new library using cabal, I create a new dir for that sandbox and add it to my path? So I can create a dir such as ~/CabalSandboxes ? Did I get it?
08:00:54 <xinming> Just curious, In haskell, groupBy doesn't try to merge all items into same group, Only adjecent ones. Is this desired design? Is there a another "groupBy" method which does what I mean please?
08:01:12 <Qfwfq> SrPx: You could do that. I don't.
08:01:16 <darthdeus> anyone knows why haskell.org is down? :(
08:01:22 <SrPx> Qfwfq: how do you deal with it?
08:01:35 <alpounet> xinming: groupBy p . sort
08:01:40 <Qfwfq> SrPx: https://nixos.org/
08:01:48 <grayling_> Anyone came across a good tutorial on aeson and parsing arrays in json?
08:02:07 <k00mi> darthdeus: the datacenter hosting the server has problems
08:02:30 <burp> EvilMachine: in principle haskell.org should be reachable again
08:02:42 <darthdeus> oh poop
08:02:51 <burp> either it's broken now due to power outage, or just doesn't reboot properly :D
08:03:04 <xinming> alpounet: I don't mean the sort
08:03:13 <xinming> alpounet: I don't want to do sort before calling group by thing.
08:03:24 <Qfwfq> xinming: The sort makes elements adjacent, such that group behaves as desired.
08:03:30 <Qfwfq> xinming: Is your concern efficiency?
08:03:43 <xinming> Qfwfq: kinda like that.
08:04:02 <xinming> but what I conern is, why do we design the groupBy like that?
08:04:21 <Exio4> because it is cheap?
08:04:22 <xinming> which need to ask user to sort by hand
08:04:34 <Exio4> @src groupBy
08:04:35 <lambdabot> groupBy _  []     =  []
08:04:35 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
08:04:35 <lambdabot>     where (ys,zs) = span (eq x) xs
08:04:36 <xinming> Exio4: Don't kno
08:04:38 <xinming> dont' know
08:04:58 <alpounet> xinming: it's useful in many cases. think of RLE encoding for instance
08:05:13 <EvilMachine> Ok, apparently the whole data center location lost power, but at data center 19 where haskell.org is hosted, the UPS failed.
08:05:27 <Qfwfq> alpounet: That's a good example.
08:07:02 <EvilMachine> rock.haskell.org is available‚Ä¶ but that‚Äôs it
08:08:45 <EvilMachine> Btw: What is rock.haskell.org?
08:09:13 <Qfwfq> Stable, apparently.
08:09:22 <EvilMachine> doesn‚Äôt look terribly secure with that ‚Äúdefault web page‚Äù?
08:09:41 <cmccann> EvilMachine: like haskell.org, but with long hair and electric guitars
08:10:10 <EvilMachine> cmccann: Somebody should build an electric guitar out of the Haskell logo. :)
08:10:37 <EvilMachine> A fully programmable electric guitar / synth machine thing. :)
08:11:34 <cmccann> EvilMachine: sort of a flying V-shaped body on a double-necked guitar? could work.
08:11:52 <EvilMachine> yep.
08:12:49 <EvilMachine> cmccann: it would also be a really great shape for a building
08:15:35 <nomeata> is hackage AND hdiff.luite.com down?
08:16:56 <quchen> The beauty of local backups.
08:16:58 <tulcod> is haskell.org down?
08:18:57 <Qfwfq> quchen: I *should* get hackage-mirror running on a timer one of these days.
08:19:11 <mmmm> Say I am constructing an AST, is there a way to say that a certain function returns a certain constructor?
08:19:35 <tulcod> haskell.org being down rather frequently isn't really a good advertisement for the reliability of the haskell language
08:19:43 <k00mi> EvilMachine: reminds me of this demo: http://www.demoscene.tv/prod.php?id_prod=13772
08:19:52 <k00mi> written in haskell :-)
08:19:57 <tulcod> mmmm: template haskell?
08:20:07 <quchen> mmmm: You mean something like "a -> <guaranteed Just value>"? I don't think I've heard of that.
08:21:12 <pjdelport> mmmm: Perhaps something with GADTs, depending on what you want to do?
08:21:12 <k00mi> tulcod: this has nothing to do with haskell, the hoster has problems
08:21:57 <tulcod> k00mi: oh i know that. but what am i supposed to tell a friend who i potentially just convinced of the superior reliability of haskell?
08:22:59 <pjdelport> mmmm: GADTs let you constrain the type signatures of constructors to be more specific; making better-typed ASTs is a classic use case.
08:23:07 <dottedmag> tulcod: hoster's datacenter management software is not written in Haskell.
08:23:28 <mmmm> pjdelport: Like I have Tree = Branch (Tree a) (Tree a) | Leaf and I would like a function mkLeaf :: Tree but ensure that mkLeaf gives me something which isn't a branch
08:23:46 <tulcod> dottedmag: again, i get that. but the fact of the matter is that the community boasting reliability has a website with severe downtime.
08:23:51 <dottedmag> tulcod: and point to http://www.reddit.com/r/haskell/comments/y1tgc/any_hackage_mirrors_how_do_you_deal_with_hackage/c5rk46g
08:24:18 <dottedmag> tulcod: That was a joke.
08:24:26 <Pythonfant> I need to do several http requests to fill a simple data structure containing the title, the artist, the url and the license on an album. How would I go about filling such a data structure? Should I stay with tuples until I have all the values or should I initialize it with empty strings and then gradually fill it when I get the information
08:24:27 <k00mi> tulcod: I don't see how a hoster having problems says anything about haskell
08:24:35 <tulcod> by the way, hdiff.luite.com is down as well
08:24:45 <k00mi> because it's hosted in the same datacenter
08:25:45 <burp> UPS failed apparently
08:25:51 <int-e> hmm, is there a functioning hackage mirror?
08:26:07 <int-e> hdiff.luite.com also looks down from here
08:26:08 <mmmm> Pythonfant: You should write each request as a separate function and then use applicatives ie Structure <$> request1 <*> request 2 etc
08:26:13 <dutchie> fpcomplete mirror wfm
08:26:37 <dottedmag> dutchie: url?
08:26:55 <dutchie> remote-repo: hackage.fpcomplete.com:http://hackage.fpcomplete.com/
08:27:02 <tulcod> k00mi: i don't think you get how pr works
08:27:02 <dottedmag> dutchie: thank you
08:27:05 <burp> omg, thanks!
08:27:51 <Pythonfant> mmmm: can I access previous values with that? I basically have one request to fetch a list of titles, artists & urls and then I need to do another request for every url to get the license
08:28:35 <mmmm> ah so you need to use do notation instead
08:28:37 <int-e> dutchie: thanks!
08:28:44 <Pythonfant> here is the code if that helps unterstanding my problem http://lpaste.net/108698
08:28:46 <mmmm> I thought you wanted independent http requests
08:29:18 <k00mi> tulcod: if knowing PR means assuming people can't differentiate, yes
08:29:42 <Pythonfant> I guess my question is if I should return (Text, Text, Text) from getAlbumsByTag or already the album with an empty license
08:30:04 <pjdelport> mmmm: With GADTs, you can say something like: data Empty; data NonEmpty; data Tree a where { Leaf :: Tree Empty; Branch :: Tree a -> Tree a -> Tree NonEmpty }
08:30:33 <tulcod> k00mi: :)
08:30:58 <mmmm> Pythonfant: I think I would return the tuple, makes it clear that you're not done
08:31:05 <Pythonfant> ok
08:31:35 <pjdelport> mmmm: In other words, you give the Tree type a phantom type variable 'a' which is only used to keep track of whether a tree is empty or not, at the type level. And then GADTs constrain the constructors so that Leaf always returns an empty tree, and Branch always returns a non-empty tree.
08:32:28 <pjdelport> mmmm: And then you can declare a function as only accepting Tree NonEmpty, for example.
08:32:54 <mmmm> thanks
08:33:25 <latk> hackage is down ?
08:33:32 <latk> or is my internet being lame again
08:33:36 <tulcod> yep down
08:35:27 <sclv_> hdiff seems down
08:35:40 <sclv_> this remote hackage reputedly works http://www.reddit.com/r/haskell/comments/2ci15f/hackage_is_down_are_there_any_mirrors_available/
08:37:16 <sebastian> the documentation is available on hayoo.fh-wedel.de
08:37:22 <sebastian> although not in haddock style
08:39:28 <tejing> is there a easily accessible operator somewhere that equivalent to flip (.)?
08:39:43 <pjdelport> :t (&)
08:39:45 <lambdabot> a -> (a -> b) -> b
08:39:51 <pjdelport> @info (&)
08:39:52 <lambdabot> (&)
08:39:57 <ClaudiusMaximus> :t (>>>)
08:39:58 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
08:40:15 <pjdelport> tejing: & is from somewhere in lens
08:40:38 <ClaudiusMaximus> but (&) = flip ($)
08:41:31 <ClaudiusMaximus> :t (>>>) `asAppliedTo` (undefined :: a->b)
08:41:33 <lambdabot> (a -> b) -> (b -> c) -> a -> c
08:42:31 <nitrix> Hi guys, I'm a little confused reading LYAH. Why does [3,2,1] > [2,1,4] yields true?
08:42:37 <benzrf> nitrix: because it's greater
08:42:37 <tejing> k, not sure if I want to import Control.Category just for that, but maybe
08:42:41 <nitrix> They say the elements are compared in lexicographical order.
08:42:51 <tulcod> nitrix: right, and 3>2
08:43:01 <vanila> [3,2,1] > [2,1,4] = 3 > 2 || 3 == 2 && [2,1] > [1,4]
08:43:02 <benzrf> nitrix: it means that the lists are compared lexicographically
08:43:06 <benzrf> not that the individual vals are
08:43:07 <tulcod> nitrix: what comes first in alphabetical order "wine" or "beer"?
08:43:19 <nitrix> beer.
08:43:23 <tulcod> why?
08:43:30 <nitrix> Because it's smaller...
08:43:38 <tulcod> because 'w'>'b'
08:43:44 <nitrix> Oh, so _each_ elements are compared in lexicographical order?
08:43:46 <benzrf> > "wine" > "bear"
08:43:48 <lambdabot>  True
08:44:24 <dutchie> nitrix: the first element is compared, and only if they are equal is the next compared and so on
08:44:37 <nitrix> dutchie: You mean greater.
08:44:58 <dutchie> nope
08:45:19 <nitrix> What do you mean? > shouldn't be an equality operator.
08:45:21 <vanila> Like this:  [3,2,1] > [2,1,4] = 3 > 2 || 3 == 2 && [2,1] > [1,4]
08:45:26 <vanila> is what dutchie explained
08:45:29 <dutchie> yes
08:45:33 <latk> If I wanted to stream all values from a persistent database in a conduit, is there any better way of doing it than just incrementing the primary key?
08:45:41 <vanila> the actual rule would be   (x:xs) > (y:ys) = x > y || x == y && xs > ys
08:45:52 <dutchie> it compares 3 and 2, and if they are not equal that determines how the lists compare
08:46:19 <tulcod> nitrix: to compare "wine" and "beer", it suffices to look at the first letter. and b comes before w. so you're done
08:46:20 <dutchie> vanila's code is probably clearer than a textual explanation i'm putting together in my head as i go along
08:46:36 <tulcod> nitrix: [3,2,1] > [2,1,4] because 3>2, so you're done
08:46:54 <nitrix> vanila: Right, okay I get it now. But then, how come when [1,4]'s turn will come, there's no way that is true.
08:47:03 <dutchie> its turn doesn't come
08:47:03 <nitrix> They are all logical OR ?
08:47:13 <dutchie> because the comparison is determined by 3>2
08:47:17 <tulcod> nitrix: i think you need a coffee break
08:47:48 <nitrix> tulcod: I have ~20 minutes experience with Haskell.
08:47:50 <dutchie> it's just the same as dictionary ordering
08:47:51 <monochrom> True || c does not care about c
08:48:11 <tejing> bugger... I can't use >>> the way I wanted after all since it's the same precedence as >>= and right associative
08:48:15 <tulcod> nitrix: this is not about haskell. it's about how you order words in a dictionary. it's not complicated, and if you aren't seeing it you just need a 5min break
08:48:16 <dutchie> to be fair, pretty much every language that implements sequence comparison does it by lexicographic ordering
08:48:18 <vanila> tulcod, that was rude - please dont :)
08:48:34 <tulcod> rude? well i'm sorry if it sounded that way
08:48:43 <tulcod> it happens to me sometimes too
08:48:58 <dutchie> sometime the best way to solve a problem is to step outside and go for a walk :)
08:49:02 <tulcod> right
08:49:05 <vanila> but yeah it's just short circuiting
08:49:09 <nitrix> Then the text is misleading. I expected every elements to be compared as long as the condition remained True. e.g. [3,2,1] > [2,1,4] would be   3 > 2 && 2 > 1 && 1 > 4
08:49:16 <vanila> since 3 > 2 is true, it doesn't bother to check the other side of the ||
08:49:19 <tulcod> vanila: yes, and the only way to fix that is using a break
08:49:47 <monochrom> but the condition does not "remain True"
08:49:58 <tulcod> nitrix: that would also define an ordering on lists of comparable elements, but it's not the "default one" haskell gives you "for free"
08:49:58 <mkster> What am I doing wrong? http://lpaste.net/108699
08:50:03 <monochrom> err nevermind
08:50:16 <friden> nitrix: if that was true how would you have ordered them?
08:50:17 <tulcod> nitrix: i mean, yeah, that would be just as valid, but it turns out they chose to implement this one
08:50:35 <friden> as 3 is greater than 2 and 4 is greater than 1?
08:50:44 <prophile> mkster:  you want celsius2kelvin (Celsius 10)
08:50:55 <mkster> Oh ok
08:51:06 <nitrix> friden: Well, in my mind, there'd be no ordering, just comparing pairs made from a single element of both list.
08:51:40 <tulcod> friden: it doesn't need to be a total order :)
08:51:48 <nitrix> But I see how that's wrong. They'll probably got into greater details about it, so no harm done really.
08:51:48 <cmccann> fwiw, comparing those two lists in Python gives the same result as in Haskell
08:51:50 <tulcod> (or does it?)
08:52:16 <friden> if you google lexicographic ordering you'll probably get better explaiations
08:52:28 <nitrix> Sadly I'll have to.
08:52:51 <friden> but seriously, it isnt that hard, do like the othey guy said and take a 5 minute break
08:53:30 <vanila> or you could ask about it here if you like :)
08:53:53 <int-e> [3,2,1] > [2,1,4] ... indeed in a dictionary, "cba" (3rd, 2nd and 1st letter of the alphabet) would come after "bad" (2nd, 1st, 4th).
08:54:13 <vanila> that's  areally cool way to look at it int-e
08:54:26 <monochrom> lexicographical order is how English dictionaries order words. ['m', 'o', 'n', 'o'] is considered < ['m', 'o', 'o', 'n']. etc etc
08:54:38 <cmccann> idk, if the text was assuming everyone would know and expect lexicographic ordering it's understandable to be confused
08:54:40 <nitrix> vanila: int-e: oh sweet!
08:54:52 <nitrix> That one I instead much better actually.
08:55:07 <nitrix> er, understand
08:55:19 <pjdelport> nitrix: If you want all the elements to be compared, you need something like:
08:55:19 <pjdelport> > and $ zipWith (>) [3,2,1] [2,1,4]
08:55:21 <lambdabot>  False
08:55:30 <pjdelport> nitrix: If you want all the elements to be compared, you need something like:
08:55:30 <pjdelport> > and $ zipWith (>) [3,2,1] [2,1,0]
08:55:32 <lambdabot>  True
08:55:43 <pjdelport> Err, sorry about the double message.
08:56:33 <cmccann> in hindsight, the jump from "dictionary order" to applying that same concept to things other than words isn't actually obvious
08:57:02 <nitrix> I think int-e deserves a cookie for the explanation.
08:57:19 <nitrix> It's all I needed to grasp it :/
08:58:01 <tulcod> cmccann: agreed
08:59:07 <aarvar> Is hackage down?
08:59:16 <cmccann> yes
08:59:24 <aarvar> :(
08:59:57 <cmccann> data center issues and apparently the UPS was pining for the fjords or something
09:01:01 <thebnq> luite is down too? the topic is wrong then =(
09:01:29 <int-e> thebnq: http://www.reddit.com/r/haskell/comments/2ci15f/hackage_is_down_are_there_any_mirrors_available/ has a couple of suggestions.
09:03:47 <thebnq> int-e: thanks
09:04:57 <marchelzo_> How can I use a function from another haskell source file that also has a main function? I'm currently getting an error saying that 'main:Main' is defined in multiple files
09:05:08 --- mode: ChanServ set +o monochrom
09:05:19 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF | XCode 5 issues? http://is.gd/H4sEub' by monochrom
09:05:35 --- mode: monochrom set -o monochrom
09:05:37 <cmccann> marchelzo_: you can import OtherModule hiding (main)
09:05:58 <marchelzo_> cmccann: I have that but it still gives the error
09:06:13 <cmccann> assuming the other module isn't named Main in which case I think you're out of luck
09:06:15 <tulcod> can you even import a module which doesn't set its module name correctly?
09:06:16 <int-e> monochrom: thanks
09:06:42 <cmccann> marchelzo_: maybe specify when compiling which main is the right one?
09:06:51 <marchelzo_> cmccann: how?
09:06:52 <cmccann> there's a compiler flag for that but I forget what it is
09:07:07 <tulcod> marchelzo_: does the other source file have a "module" statement at the top of the file?
09:07:11 <dottedmag> -hs-main or something
09:07:15 <tulcod> ie is it actually a module, or just a source file?
09:07:18 <marchelzo_> neither of the modules are named Main
09:07:37 <marchelzo_> but they both have module names
09:08:13 <tulcod> marchelzo_: and are you sure that the "multiple files" refers to these two source files?
09:08:25 <tulcod> or could there be other places where "main" is defined
09:08:30 <marchelzo_> tulcod: Yes they are the only two source files that I am working with
09:08:30 <cmccann> I think the flag you want is -main-is
09:08:35 <tulcod> okay
09:09:05 <cmccann> marchelzo_: try "-main-is ActualMain.main"
09:09:18 <marchelzo_> oh my god
09:09:41 <marchelzo_> I forgot to write the changes to the file after chaning the module name. it used to be Main
09:09:46 <cmccann> hahaha
09:09:54 <marchelzo_> sorry for the confusion :|
09:09:55 <tulcod> marchelzo_: :)
09:10:05 <tulcod> apologize to your compiler
09:10:08 <marchelzo_> lol
09:11:56 <labelforth> I compile all of my code in my head
09:12:57 <labelforth> @slap lambdabot
09:12:57 * lambdabot is overcome by a sudden desire to hurt lambdabot
09:13:10 <tulcod> labelforth: to what?
09:13:22 <monochrom> to brain native code
09:13:43 <tulcod> is there a formal specification of that?
09:13:52 <labelforth> I wish!
09:14:41 <pantsman-> much like Haskell, the specification for my brain was a committee effort, in the 1980s
09:15:36 <tulcod> pantsman-: i've heard they want to get the committee back together and develop a new version which fixes some bugs
09:15:39 <labelforth> some manner of slow discrete neuron firing patterns
09:15:39 <cmccann> pantsman-: probably a smaller committee though
09:16:11 <pantsman-> cmccann, I hope so.
09:19:21 <Qfwfq> Server's back up, Hackage is misconfigured.
09:19:30 <johnw> we're working on it now
09:19:42 <Qfwfq> <3
09:20:00 <tulcod> good work guys
09:20:33 <Qfwfq> You are Important.
09:27:55 <Qfwfq> It's back up!
09:28:15 <johnw> exellent
09:28:35 <MP2E> yay!
09:32:39 <grayling_> Indeed it is. Thank you.
09:32:55 <johnw> appears a mount wasn't recorded in /etc/fstab so that when it rebooted /srv/hackage didn't come back up and the service then failed to restart; this has been remedied
09:33:02 <nitrix> monochrom: If you don't mind fixing it, in the topic, you're opening a quote before "http://www.haskell.org and you aren't closing it. My transformed half the topic into a link with weird coloration.
09:33:15 <nitrix> er, client
09:33:48 <nitrix> Actually... interesting.
09:33:51 <nitrix> It's a weechat bug.
09:34:12 <nitrix> Disregard.
09:35:19 * hackagebot StrappedTemplates 0.1.1.0 - General purpose templates in haskell  http://hackage.haskell.org/package/StrappedTemplates-0.1.1.0 (hansonkd)
09:37:31 <darthdeus> damn is there literally no guide on parsec, I can't find a thing about the tokenizer
09:38:10 <EvilMachine> darthdeus: This might be useful: ttp://book.realworldhaskell.org/read/using-parsec.html
09:38:34 <c_wraith> tokenizer?  Parsec has a tokenizer?
09:38:42 <darthdeus> EvilMachine: been there :(
09:38:48 <darthdeus> c_wraith: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Token.html
09:39:17 <vanila> darthdeus, there's an example:  lexer       = P.makeTokenParser haskellDef
09:39:18 <EvilMachine> darthdeus: Use the force‚Ä¶ Read the source? :)
09:39:35 <c_wraith> darthdeus: oh, that mess?  It's not used very much.
09:39:47 <darthdeus> vanila: yeah but the example tells me nothing about how to use it, except for the simple example :|
09:40:04 <vanila> yeah, I think you're right- there's a huge lack of docs on this
09:40:20 * hackagebot yesod-auth 1.3.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4 (MichaelSnoyman)
09:40:20 <darthdeus> and I'm not even trying to parse something difficult
09:40:30 <vanila> you may do just fine without using the tokenizer stuff
09:40:35 <darthdeus> all I want is to be able to distinguish  (\x.x) x   and  \x. (x x)
09:41:11 <vanila> hmm
09:41:12 <vanila> i can do that
09:41:16 <vanila> but I'm not sure how to help you do that
09:41:27 <vanila> I've parsed this language before
09:41:59 <darthdeus> here's what I have https://github.com/darthdeus/lamcal/blob/master/Parser.hs
09:42:14 <darthdeus> the problem is that if i change parseApp to use parseExpr recursively in both cases, it loops forever
09:42:20 <darthdeus> and it also doesn't handle parens at all
09:42:22 <vanila> ah let me have a look
09:42:23 <darthdeus> and i just have no idea how to do this
09:42:30 <darthdeus> let me just update it so that it loops infinitely
09:42:53 <darthdeus> ok pushed
09:43:17 <vanila> ah
09:43:23 <vanila> so one thing is that you should use chainl
09:43:27 <vanila> in parseApp
09:43:30 <vanila> instead of left recursion
09:43:48 <vanila> I think that will fix the loop
09:44:08 <darthdeus> hmm
09:44:13 <darthdeus> why can't i use recursion?
09:44:19 <darthdeus> i read that in the parsec docs, but without any explanation
09:44:38 <vanila> you can use recursion, it's just this particular type causes an infinite loop
09:44:49 <vanila> because it attempts to build an infinitely nested tree
09:44:55 <darthdeus> but chainl is for N occurences of something no?
09:44:59 <darthdeus> while i have two
09:44:59 <vanila> yes
09:45:06 <Guest35283> Hey. any Vim users here?
09:45:17 <vanila> ok but you do parse things like this:  f x y z
09:45:17 <latk> When I see ~ in a type signature, what does it mean ?
09:45:29 <hiptobecubic> arianvp_, of course
09:45:30 <arianvp_> Any vim users here? :)
09:45:31 <darthdeus> vanila: yeah true, but right now i don't even parse "f x" :D
09:45:35 <vanila> as App (App (App (App f x) y)) z
09:45:46 <vanila> so you would use chainl to do this in one go, rather than the recursion
09:45:46 <pjdelport> arianvp_: I use Vim.
09:45:47 <arianvp_> hiptobecubic: what's a good combination of plug ins for haskell that you really like?
09:45:56 <darthdeus> i guess I don't understand chainl properly
09:46:05 <pjdelport> arianvp_: Syntastic with hdevtools is good.
09:46:10 <arianvp_> I've been using sublime for now. but even the syntax highlighting is horrible
09:46:12 <limepod> syntastic + ghc-mod
09:46:30 <hiptobecubic> arianvp_, i'll I've ever really cared about was syntastic hdevtools(need recent fork)/ghc-mod
09:46:32 <darthdeus> ghc-mod is ultra slow in vim, hdevtools doesn't work with CPP :P
09:46:37 <hiptobecubic> neco-ghc for completion
09:46:41 <supki> latk: type equality
09:46:55 <latk> supki: Okay - I'm not completely sure what that means.
09:46:58 <arianvp_> CPP = C preprocessor?
09:47:02 <latk> That they are the same type ?
09:47:25 <darthdeus> vanila: how can I modify this to use chainl?
09:47:29 <supki> latk: a ~ b means a and b are the same type
09:47:47 <hiptobecubic> arianvp_, i actually use YouCompleteMe which works great with neco-ghc and is quite fast
09:48:02 <vanila> well: chainl1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> ParsecT s u m aSource
09:48:04 <latk> supki: Ah. Why do you need to include both in the type signature, then ?
09:48:13 <hiptobecubic> even shows type signatures of completions
09:48:13 <latk> Surely one should be enough ?
09:48:21 <darthdeus> yeah, that type signature makes no sense at all to me :|
09:48:36 <vanila> so you need to use parseApp = chainl1 parseTerminal (do char ' ' ; return App)
09:48:43 <arianvp_> hdevtools doesnt install for me :/
09:48:52 <arianvp_> at least on GHC7.8.2
09:48:57 <vanila> where parseTerminal parses either a single variable, or a bracketed lambda expression (you can do the second type later)
09:49:08 <arianvp_> http://lpaste.net/705670655810469888
09:49:13 <hiptobecubic> arianvp_, need a recent fork
09:49:21 <arianvp_> hiptobecubic: ah thanks
09:49:22 <darthdeus> hmm, interesting
09:49:40 <hiptobecubic> arianvp_, i went on github, looked at the 'network' graph of forks and then picked the newest one
09:49:47 <hiptobecubic> newest as in most recent
09:49:53 <arianvp_> hiptobecubic: which for is still maintained? I can only find bitc/hdevtools
09:49:58 <arianvp_> s/for/fork
09:50:02 <hiptobecubic> hold on let me check
09:50:20 * hackagebot yesod-platform 1.2.12.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.12.4 (MichaelSnoyman)
09:50:46 <darthdeus> vanila: holy shit it works
09:50:52 <vanila> :D
09:50:53 <vanila> good!
09:51:12 <hiptobecubic> maybe i'm thinking of the wrong thing... one of these plugins needed a fork
09:51:14 <vanila> do you have any questions about it?
09:51:21 <hiptobecubic> maybe it's in my irc log
09:51:32 <supki> latk: they are useful when you have type families or gadts, e.g. pattern match on gadt can introduce new type equalities
09:51:34 <darthdeus> yeah I'm like ultra confused
09:51:49 <darthdeus> does it always work on functions that are just a -> a -> a?
09:51:50 <vanila> oh sorry
09:51:55 <darthdeus> :D
09:51:57 <latk> supki: I'm not that familiar with type families or gadts - where could I read about them ?
09:52:02 <vanila> well ok so one thing that's really cool here is parser combinators
09:52:02 <darthdeus> I mean what if my App had three parameters?
09:52:13 <hiptobecubic> arianvp_, i am using schell's fork apparently
09:52:14 <vanila> yes you're right it only works with a -> a -> a, the type shows this in fact
09:52:25 <vanila> so what's happening here is you have a parser for a thing, like a varible x,y,z
09:52:38 <vanila> and then you have a parser for a combiner which in this case is " " for function application
09:52:49 <vanila> so chainl1 tries to parse a thing, then a combiner, thne a thing then a combiner and so on
09:52:57 <vanila> and it joins them into a left associative tree
09:53:05 <darthdeus> oh
09:53:07 <darthdeus> hmmm
09:53:10 <darthdeus> interesting
09:53:23 <vanila> so the parser for the combiner doesn't return a lambda term
09:53:24 <supki> latk: haskellwiki should have articles for both
09:53:35 <vanila> but instead it gives a functor that just joins two lambda terms with App
09:53:43 <hiptobecubic> arianvp_, https://github.com/schell/hdevtools
09:54:09 <arianvp_> hiptobecubic: that one works on 7.8.2?
09:54:20 <hiptobecubic> apparnetly
09:54:22 <hiptobecubic> apparently*
09:54:29 <hiptobecubic> I have 7.8.3
09:54:34 <darthdeus> vanila: thank you so much
09:54:36 <darthdeus> you saved my sanity
09:54:39 <vanila> yay :)
09:54:43 <darthdeus> i've been trying to figure this out for like 5 hours
09:54:46 <darthdeus> like literally
09:55:22 <darthdeus> ok one more question
09:55:35 <darthdeus> is this a good way to make it "either x x or (x x)"? https://github.com/darthdeus/lamcal/blob/master/Parser.hs#L31-L35
09:56:17 <darthdeus> because i'm not really sure how to do something like   (optional $ char '(') and then only apply the ')' if the left is there
09:56:50 <vanila> instead of parseParenLambda you could just add char '(' *> parseExpr <* char ')' to your parseTerminal rule
09:56:56 <vanila> that way it will automatically work
09:57:44 <darthdeus> even if the ( ) is not there?
09:58:08 <vanila> it's more like
09:58:42 <supki> latk: there's also another usecase; instance declarations  instance C Int where  and  instance a ~ Int => C a where  have different properties because of the way the instance lookup works
09:58:47 <vanila> an application could be f x y z or f (a b c) y z
09:59:07 <vanila> the parser will parse a single lambda term, whether it's a varible or a whole complicated expression in brackets
09:59:44 <darthdeus> hmm,   f (a b) x   doesn't work for me even now
10:00:00 <vanila> can I see?
10:00:17 <darthdeus> https://github.com/darthdeus/lamcal/blob/master/Parser.hs#L31-L35 i haven't changed it
10:00:23 <darthdeus> Œª> test "f (a b) x"
10:00:23 <darthdeus> Right (Var "f")
10:00:43 <latk> supki: This is all pretty new to me, I will have to do some reading :)
10:01:03 <latk> supki: I have no idea how instance lookup works, for instance.
10:01:23 <vanila> why don't you try removing parseParenLambda and par from parseApp - then just add a rule for bracket terms to terminal like (char '(' *> parseExpr <* char ')') to parseTerminal
10:02:18 <darthdeus> you mean like   char '(' *> (try parseVar <|> parseParenLambda) <* char ')' ?
10:03:23 <darthdeus> I think my structure is wrong
10:03:27 <vanila> well it's just the code you had a moment ago was working great
10:03:34 <vanila> bu I think you added bracketing to the wrong place
10:03:47 <vanila> so something like this might work better:
10:04:28 <supki> latk: the gist is that since any constraints are ignored, GHC can choose the latter instance and try to prove (a ~ Int) later, but it can't choose the former instance before it proves (a ~ Int). That can make a difference for the type inference
10:04:32 <darthdeus> no it is still working, but not in the case of "f (a b) x"
10:04:37 <supki> latk: i.e. the latter infers much better
10:04:39 <vanila> http://pastebin.com/EW4vjvk8
10:04:48 <vanila> I meanm this might not work as is, but it's an idea
10:05:21 * hackagebot wheb-strapped 0.0.1.0 - Strapped templates for Wheb  http://hackage.haskell.org/package/wheb-strapped-0.0.1.0 (hansonkd)
10:05:24 <latk> Okay.
10:05:32 <darthdeus> ok let me try
10:05:36 <latk> So if the equality were not there, it would choose the wrong type ?
10:05:40 <vanila> although maybe you don't want lambda in with the terminals..
10:05:42 <vanila> haskell doesn't do that
10:06:34 <Th30n> mmmm: haskell.org appears to be back online
10:06:49 <darthdeus> hmm, if i add parseExpr in any way to parseTerminal it just infinitely loops
10:06:54 <supki> latk: without type equality you can't write  instance C a where  and assume a is Int
10:07:09 <vanila> even in brackets?
10:07:29 <latk> supki: Ah, rightr right.
10:07:50 <darthdeus> yeah, \x.x
10:07:54 <darthdeus> or (\x.x)
10:09:46 <darthdeus> let me try to clean this up a bit and see if i have anything duplicated
10:09:52 <vanila> ok :)
10:10:01 <SrPx> What is a idiomatic way to write this? http://lpaste.net/108701
10:10:01 <arianvp_> I cant get hoogle to install :/
10:10:14 <arianvp_> http://lpaste.net/7393262780989571072
10:11:32 <darthdeus> vanila: probably a dumb question, but what is terminal representing?
10:12:40 <vanila> the idea of terminal is that it's a "unit" that always consumes something from the string - so that recursion with it will work
10:12:54 <vanila> when you have something that recurses before consuming anything from the string, there is a chance of infinite loop
10:13:33 <darthdeus> hmmm
10:14:19 <darthdeus> ok cleaned up https://github.com/darthdeus/lamcal/blob/master/Parser.hs ... now everything seems to work, except for   "f (x)" which parses as (Var "f")
10:14:35 <vanila> this is starting to look good
10:14:42 <darthdeus> even though "f x (y)" parses as
10:14:42 <darthdeus> Right (App (App (Var "f") (Var "x")) (Var "y"))
10:15:00 <vanila> just remove 'pars' from everything
10:15:14 <vanila> the only place to have it is like
10:15:22 * hackagebot wheb-mongo 0.0.2.0 - MongoDB plugin for Wheb  http://hackage.haskell.org/package/wheb-mongo-0.0.2.0 (hansonkd)
10:15:24 * hackagebot djinn-lib 0.0.1.1 - Generate Haskell code from a type. Library extracted from djinn package.  http://hackage.haskell.org/package/djinn-lib-0.0.1.1 (AlejandroSerrano)
10:15:26 * hackagebot djinn-ghc 0.0.2 - Generate Haskell code from a type. Bridge from Djinn to GHC API.  http://hackage.haskell.org/package/djinn-ghc-0.0.2 (AlejandroSerrano)
10:15:58 <darthdeus> why? I thought parens are valid everywhere
10:15:59 <vanila> terminal = try var <|> lambda <|> (char '(' *> expr <* char ')')
10:16:30 <darthdeus> huh
10:16:44 <darthdeus> how the hell does this work :D
10:16:45 <darthdeus> it works
10:16:46 <darthdeus> wtf
10:18:25 <xinming> anyone here tells me in list comprehensions, how does   'then sortWith by x' kind of thing is transformed?
10:18:48 <xinming> Or, what does they do actually, I see that :t output for sortWith and sortBy are totally different.
10:19:23 <vanila> darthdeus, if you like you can see my parser which dose the same thing
10:21:30 <SrPx> As nobody replied, I've posted the question on SO. If anyone is interested, here it is: http://stackoverflow.com/questions/25107101/how-to-represent-an-incremental-state-updating-function . Thanks.
10:21:59 <darthdeus> vanila: yeah sure :)
10:22:11 <darthdeus> vanila: i guess my biggest problem in understanding is why terminal works and expr doesn't in chainl1
10:22:33 <vanila> expr tries to parse an expr before building an application
10:22:42 <vanila> so to do that it has to parse an expr.. before building it into something
10:22:50 <vanila> and to do that..... it causes an infinitte loop
10:25:23 * hackagebot graph-wrapper 0.2.4.3 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.4.3 (MaxBolingbroke)
10:25:47 <darthdeus> what if i put app as the last thing in expr?
10:26:04 <yogurt_truck> SrPx: the question says that the second version is "barely readable" but I can't make sense of the first version, and I use "imperative" languages all the time
10:26:08 <darthdeus> hmm but i can't do that
10:26:12 <darthdeus> since that would parse var first
10:26:54 <paulschellin> yogurt_truck: Yeah, I've been trying to understand why someone would want to write that in either style
10:27:10 <SrPx> yogurt_truck: okay, I might update the question explaining the problem is not readability, as that varies across individuals, but the need of numerically tagging each variable
10:27:48 <zinfandel> SrPx: Why not to give them a meaningful name?
10:27:49 <yogurt_truck> SrPx: the nonstop rewriting of `x` based on conditionals all over the place makes me just not know what `x` is at all, but in any case it seems that you want to use either RWS or an arrow
10:28:14 <darthdeus> vanila: shouldn't i also make the var parser fail if there's anything after the letters?
10:28:18 <SrPx> yogurt_truck: I will read about both, thanks
10:28:31 <darthdeus> though if i change it to this it loops forever var = Var <$> (many1 letter <* eof)
10:30:19 <zinfandel> SrPx: Obviously when apply some function to x it changes to something different so why not to give it a good name, wouldn't it make the code more readable?
10:30:23 * hackagebot Wheb 0.2.0.0 - The frictionless WAI Framework  http://hackage.haskell.org/package/Wheb-0.2.0.0 (hansonkd)
10:32:12 <SrPx> zinfandel: this is just an example of the style, the code isn't doing anything meaningful
10:32:17 <mister_integer> question: where did foldl' go?
10:32:24 <mister_integer> It's not in the Prelude, was it ever there?
10:32:39 <SrPx> zinfandel: I've just extracted the pattern that matters (for this specific question) of the code I was writing.
10:33:29 <glguy_> mister_integer: It has always been in Data.List
10:33:35 <paulschellin> mister_integer: foldl' is in a lot of the Data libraries like Data.List
10:33:36 <mister_integer> ohhhh
10:34:21 <mister_integer> glguy_: thanks!
10:40:24 * hackagebot djinn-ghc 0.0.2.1 - Generate Haskell code from a type. Bridge from Djinn to GHC API.  http://hackage.haskell.org/package/djinn-ghc-0.0.2.1 (AlejandroSerrano)
10:40:36 <michaeltomer> I have a beginner Haskell question. Defining a record creates ‚Äúgetters‚Äù for the fields, and there‚Äôs a special syntax to do a copy-on-write ‚Äúmodification‚Äù to records. Is there a plain-old-function to handle the ‚Äúmodification‚Äù? Something like ‚ÄúnewPersonWithAge :: Person -> Int -> Person‚Äù that gets created?
10:42:17 <paulschellin> michaeltomer: I believe when you use the record name functions on the object and a desired update value, it creates an object which has only that field changed
10:43:15 <paulschellin> michaeltomer: Here's it on SO: http://stackoverflow.com/questions/14955627/shorthand-way-for-modifying-only-one-field-in-a-record-copy-a-record-changing
10:44:07 <michaeltomer> paulschellin: Yeah, I‚Äôve seen the shorthand. It looks like special syntax, not a regular function. Then again, I‚Äôm new to Haskell.
10:44:23 <michaeltomer> I‚Äôd like a function I can pass around.
10:44:40 <paulschellin> michaeltomer: I think that's what lenses are helpful for
10:44:55 <ClaudiusMaximus> michaeltomer: no, you have to make the modifiers manually, like \f x -> x{ field = f (field x) }  (this is kinda "records are not first class" complaint which the 'lens' package tries to help with)
10:45:09 <beaky> hello
10:45:11 <michaeltomer> You may be right. I didn‚Äôt really think of lenses since the data is flat, but that could work.
10:45:43 <michaeltomer> Okay, nice. Thanks everyone!
10:47:54 <xinming> anyone here can tell me how does internal about transform functions in list comprenhensions?
10:48:18 <xinming> just like    [ x | x <- list, then sortWith by x ]
10:49:22 <xinming> and I saw that the type of sortWith is (a -> b) -> [a] -> [a]    But I don't understand how is the sortWith function used internally in list comprehension
10:50:09 <Fuuzetsu> is there an easy way to automatically generate trivial attoparsec parsers for user defined data types? Say, I have data Foo = Bar | Baz, it'd be great if it could automatically derive Parser Foo with the "Bar" *> Bar <|> "Baz" *> Baz definition
10:50:25 * hackagebot Ketchup 0.3.1 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.3.1 (Hamcha)
10:53:31 <pointed_set> 2 ximming:  https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/list-comprehension-extensions#then-by-clauses
10:54:15 <Fuuzetsu> ‚Ä¶*> return Baz rather
10:55:26 <stelleg> pointed_set: whoa cool, did not know about all those extensions, thanks
11:02:10 <pointed_set> stelleg: I didn't know either (before I googled it)
11:03:14 <tertl3> hi
11:03:21 <mmaruseacph2> falled into cabal-hell again :(
11:03:23 <Feuerbach> Fuuzetsu: should be fairly easy to do using GHC.Generics
11:03:26 <tertl3> any elm fans here?
11:03:39 <Fuuzetsu> Feuerbach: Aye, mostly wondering if it has been done before
11:03:47 <Fuuzetsu> I might do it later
11:04:07 <mmaruseacph2> is there a well-tested guide on how to use it to prevent these cases? I use sandboxes a lot but I started using them late in the operating system's life so I still have platform and such
11:04:48 <Fuuzetsu> mmaruseacph2: what I did when I was using sandboxes was to purge any mention of Haskell from my system's knowledge
11:04:51 <Fuuzetsu> so nothing from package manager
11:04:53 <Fuuzetsu> and then sandbox everything
11:04:58 <nomeata> Feuerbach: ah, glad to see you. I‚Äôm currently packaging tasty-0.8 for Debian.
11:05:07 <Fuuzetsu> now I just use nix and don't worry about it at all
11:05:08 <mmaruseacph2> Fuuzetsu: so that means compiling ghc by hand?
11:05:09 <nomeata> Am I right that I can substitute the latest version of temporary for temporary-rc?
11:05:16 <tulcod> mmaruseacph2: some people say nixos solves some of these issues?
11:05:23 <mmaruseacph2> or GHC and Cabal from system and everything else from packages :)
11:05:31 <Fuuzetsu> mmaruseacph2: you can just fetch binaries and stick them in your PATH if that's what you prefer
11:05:41 <mmaruseacph2> tulcod: true, nixos does that but I haven't yet decided to do the switch
11:05:47 <tulcod> me neither
11:05:54 <mmaruseacph2> Fuuzetsu: ah, cool, thanks
11:05:56 <Fuuzetsu> tulcod: I use NixOS, you don't have to worry about cabal
11:06:33 <mmaruseacph2> there were some people here at Boston Hac installing Nix for cabal but I didn't meld into that group, I came a little late :)
11:06:46 <MP2E> Nix is kinda like a dreamland where cabal hell is a faint memory
11:07:11 <MP2E> cabal2nix works so well I haven't written a nix expression for a haskell project yet :P
11:07:13 <Fuuzetsu> yeah, I think there was some talk about Boston Hac (and another meet somewhere in Europe, forgot where) about nixers attending
11:07:19 <Feuerbach> nomeata: hi Joachim. Yes, I think you can (at least for now)
11:07:37 <Lowl3v3l> after googling... nixos sounds great. How actual are packaged there compared to ubuntu or fedora?
11:07:52 <Fuuzetsu> Lowl3v3l: Can you rephrase?
11:07:55 <ajyasgar> quite a few people at hac boston discussing nix, yeah
11:08:08 <tulcod> yeah, how's nixos for a distro *except* for its haskell support?
11:08:08 <Lowl3v3l> sry^^
11:08:15 <nomeata> Feuerbach: ok. I‚Äôll patch tasty-golden‚Äôs cabal file (but it would save us work if we wouldn‚Äôt have to do it on every upgrade ;-))
11:08:29 <MP2E> NixOS has a lot of things packaged, but honestly you're probably going to have to package stuff yourself
11:08:32 <MP2E> the community isn't big enough yet :P
11:08:35 <MP2E> it's a chicken and egg problem
11:08:35 <dfeuer_> nomeata, I had a vague pondering. Have you ever turned your attention to finding a way to perform the static argument transformation only when it's likely to be a good idea?
11:08:47 <MP2E> Thankfully, contributing is pretty easy
11:08:50 <Lowl3v3l> My question is : how fast are people with packaging new software to nixos? is it comparable to fedora or ubuntu? Or a nightmare like Debian stable :D
11:08:50 <Fuuzetsu> tulcod: It's quite fine. You'll probably end up packaging *something* yourself but it is not difficult to do.
11:08:57 <nomeata> dfeuer_: no, never touched that part
11:09:03 <MP2E> https://github.com/NixOS/nixpkgs <-- This is the repo
11:09:07 <Fuuzetsu> No Ruby environment set up as far as I can see so you might want to look out for that if you write Ruby
11:09:28 <MP2E> Lowl3v3l : writing 'nix expressions' which are packages, is very very simple actually. I'd say it's on par in terms of simplicity with makepkg
11:09:42 <dfeuer_> nomeata, something vaguely seems to suggest to me that it could be related to the work you did with arity, but I'm nowhere near knowledgeable enough to really know.
11:09:44 <Fuuzetsu> Lowl3v3l: It's very fast. If you want something then package it and send pull request. If it's a simple thing someone will merge it soon later (few minutes to few days, it depends)
11:10:10 <nomeata> dfeuer_: no, I was concernd with adding highly non-static arguments, not removing very static arguments :-)
11:10:22 <Lowl3v3l> kk, interesting, interesting.... how about non-free drivers?
11:10:27 <dfeuer_> nomeata, exactly. They look sort of dual.
11:10:37 <Fuuzetsu> Lowl3v3l: I'm using the nVidia binary blob right now
11:10:52 <mmaruseacph2> it works? that's awesome :D
11:10:54 <Fuuzetsu> you need to set allowUnfree and you're set; I don't know how many are actually packaged and what you need though but I haven't had any problems
11:10:55 <Lowl3v3l> okay, illl join the channel and look into it xD
11:10:59 <MP2E> they work, you need to put nixpkgs.config.allowUnfree = true; in your /etc/nixos/configuration.nix
11:11:00 <Fuuzetsu> cool
11:11:05 <MP2E> but they work great
11:11:16 <Lowl3v3l> Fuuzetsu, the problem is : in general, i need cuda-support^^
11:11:18 <mmaruseacph2> a few years ago when I first tried it (I went full way to NixOs) I was left with a non-working X
11:11:28 <mmaruseacph2> but I think things have definitely changed since then
11:11:30 <Fuuzetsu> CUDA is nVidia stuff, right? The nVidia drivers work fine.
11:11:52 <ajyasgar> yes CUDA is nvidia specific
11:11:56 <nomeata> dfeuer_: never thought about that angle
11:11:56 <Lowl3v3l> yes
11:12:20 <dfeuer_> nomeata, for all I know, it could be just me looking through ignorance-colored lenses.
11:13:08 <dfeuer_> What I'm currently trying to figure out is whether it's possible to make cycle a good producer for foldr/build.
11:13:18 <dfeuer_> Which is totally unrelated.
11:13:27 <dfeuer_> And should be a simpler question.
11:14:42 <mmaruseacph2> found it http://softwaresimply.blogspot.com/2014/07/haskell-best-practices-for-avoiding.html
11:14:48 <Feuerbach> nomeata: yeah, it'd save us all time if packages were maintained responsibly
11:14:55 <mmaruseacph2> I read it when it appearead but I forgot to save it
11:14:58 <nomeata> dfeuer_: and it isn't simple?
11:16:11 <ajyasgar> i saw something on twitter somewhat recently (~2-3 months ago iirc) where someone had written an image filter in haskell that somehow operated in-register. anybody have any idea what that project/paper/whatever might have been?
11:16:12 <nomeata> Feuerbach: true true. Trying to keep 750 packages consistent can be quite a chore, with some upgrading eaglery, some very lazily, some underspecifying build-depends, others overspecifying, and some forking... but its manageable
11:16:56 <dfeuer_> nomeata, maybe it is, but I haven't figured it out yet. Sometimes cycle xs = concat (repeat xs) does a much better job than the current definition, but then sometimes it does rather worse. I don't quite know how the current definition sometimes is good (perhaps something with the ++ rule?) but when an inlined function is mapped over the result of the current function, it does very well,
11:17:06 <dfeuer_> much better than that proposal.
11:18:36 <dfeuer_> There may be some other way, of coures.
11:18:37 <dfeuer_> course.
11:19:31 <Feuerbach> nomeata: in a way, you're forking every single package :) only this way you can ensure stability. I cannot afford that; so I fork only those that are especially prone to poor maintainership
11:21:57 <EvilMachine> How would you make a type class of ‚Äúzipper interfaces that can only process lists of Float or Char‚Äù (and then have one implementation be based on bytestrings)?
11:22:34 <EvilMachine> (Feel free to change the question if it‚Äôs stupid or wrong. :)
11:23:35 <EvilMachine> I‚Äôm lost in the depths of functional dependencies, multi-param type-classes, type families, and whatever other insanities there are. :/
11:24:19 <beaky> is there a standard name for something like 'Data Thing a = [a] a [a]' and the main operation is things like 'f (Thing x:xs y ys) = Thing xs x y:ys'
11:24:50 <EvilMachine> beaky: sounds pretty close to a zipper‚Ä¶
11:25:01 <paulschellin> So I've been looking into the Prisoner's Dilemma tournament (https://github.com/pdtournament/pdtournament) and I'm having trouble modifying the 'BotEnvironment' monad (among other things) to allow a writer monad to accumulate useful statistical information. Has anyone here looked into that project?
11:25:10 <mr-> beaky: Zipper :-)
11:25:24 <beaky> what are zippers good for
11:25:40 <hiptobecubic> zipping
11:26:00 <julianb> beaky, iterating over structures
11:26:02 <EvilMachine> beaky: Going through data structures and maintaining your current position most efficiently.
11:26:02 <tulcod> beaky: in general, IMO you should just start coding. you'll find when you need them.
11:26:43 <beaky> my biggest fear in haskell is using one data structure when another type would do even better
11:26:51 <beaky> e.g. using Data.Sequence over Data.Vector
11:27:08 <EvilMachine> beaky: Btw: You can find the zipper for every thinkable data structure, by finding the derivative of its type with type algebra. :)
11:27:29 <tulcod> beaky: you can *always* find a better data structure
11:27:29 <beaky> wow so theres a zipper for a tree?
11:27:32 <tulcod> beaky: you can keep making it more efficient and more concise and whatever
11:27:38 <EvilMachine> beaky: Yes.
11:27:40 <tulcod> until you end up with a page full of imports, and a program of 5 lines
11:27:46 <pointed_set> there is a zipper for anything Typeable
11:27:53 <tulcod> beaky: but really, that's not the most productive way to write haskell code
11:27:59 <EvilMachine> beaky: If that‚Äôs your biggest fear, you haven‚Äôt met many unknown GHC extensions yet. :)
11:28:02 <beaky> 'data Tree a = Tree a [a]' whats the zipper for this
11:28:21 <pointed_set> deriving (Data, Typeable)
11:28:31 <EvilMachine> beaky: one second‚Ä¶
11:28:38 <dfeuer_> Oh! I got it!
11:28:41 <pointed_set> toZipper (Tree whatever whutaver)
11:28:41 <dfeuer_> I think.
11:28:43 <EvilMachine> beaky: http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
11:29:16 <EvilMachine> beaky: search for ‚Äútree zippers‚Äù on that page.
11:29:17 <beaky> sometimes i find when i switch data types in haskell (and replace associated operations) i get much better mileage
11:29:19 <pointed_set> https://hackage.haskell.org/package/syz-0.2.0.0/docs/Data-Generics-Zipper.html
11:29:53 <dfeuer_> @tell nomeata I think this cycle might be good: http://lpaste.net/108711
11:29:54 <lambdabot> nomeata lets you know: To reach me, better use mail than lambdabot messages; I tend to read them too late.
11:29:54 <lambdabot> Consider it noted.
11:31:33 <pavonia> How do you set these "let you know" messages?
11:31:55 <tulcod> beaky: that's reasonable - types have a very central position in haskell
11:32:08 <tulcod> @tell pavonia like this
11:32:08 <lambdabot> Consider it noted.
11:32:13 <EvilMachine> dfeuer_: These lambdabot messages look like a case of inner-platform effect. ^^
11:32:16 <beaky> even using better types helps me think even better about my overall program function and design
11:32:37 <pavonia> And when I type something ...
11:32:43 <EvilMachine> dfeuer_: In other words: ‚Äôsup dawg, I herd yo like messageing services‚Ä¶ :)
11:32:56 <pavonia> tulcod: Well no, that's not what I mean
11:33:18 <pavonia> "nomeata lets you know: To reach me, ..." <-- I mean this one, public to the whole channel
11:33:30 <beaky> so lambdabot reinvented email? :D
11:33:36 <pointed_set> who wanted zippers for tree? https://gist.github.com/Heimdell/a519ce4dca1773687222
11:34:10 <beaky> so zippers basically help you take a thingy and remember state within that thingy?
11:34:38 <EvilMachine> beaky: lambdabot‚Äôs writer reinvented IRC/e-mail/instant-messaging/real-live-paper-mail/‚Ä¶ ;)
11:34:40 <beaky> (like what tree node to focus on?)
11:35:43 <EvilMachine> There‚Äôs nothing like a type class of functional dependencies to get one to hate Haskell in a matter of ‚Ä¶ well, it ain‚Äôt gonna be anything less than *hours*. ;)
11:35:56 <pointed_set> Generic zippers aren't available for direct usage, btw. See lines 22-27 - there the tracks for walk-between-leaves are.
11:36:11 <pavonia> Seems to be @auto-reply
11:36:19 <mmaruseacph2> EvilMachine: but you don't use fundeps so much
11:36:23 <beaky> btw whats a functional depenceny
11:36:24 <mmaruseacph2> so there's no reason to hate
11:36:36 <EvilMachine> mmaruseacph2: Maybe you know dgin
11:36:38 <beaky> is a fundep like the rdbms fundep?
11:36:42 <EvilMachine> mmaruseacph2: oops
11:36:56 <mmaruseacph2> beaky in "class C a b | a -> b" the "| a -> b" part
11:37:01 <pointed_set> class X x y | x -> y
11:37:02 <EvilMachine> mmaruseacph2: Maybe you know this: How would you make a type class of ‚Äúzipper interfaces that can only process lists of Float or Char‚Äù (and then have one implementation be based on bytestrings)?
11:37:04 <koala_man> is there a safe version of read?
11:37:13 <mmaruseacph2> which says that the type of a implies the type of b
11:37:20 <ab9rf> koala_man: by 'safe' you mean what?
11:37:26 <beaky> fundeps confuse me
11:37:38 <mmaruseacph2> that is instantiating a to Int for example means that b can be only a certain other type
11:37:38 <EvilMachine> mmaruseacph2: Ok, I don‚Äôt even want the type of a to imply the type of b
11:37:44 <koala_man> ab9rf: Read a => String -> Maybe a
11:37:54 <pointed_set> Make a typeclass FloatOrChar and use generic zippers working on objects of that typeclass, lol
11:37:59 <beaky> so a fundep is like a typeclass for a typeclass parameter?
11:38:30 <mmaruseacph2> koala_man: you mean something that will make ¬´read "ana" :: Int¬ª not result in "Parse error" but give you Nothing/Left "Cannot parse" ?
11:38:36 <koala_man> mmaruseacph2: yes
11:38:49 <pointed_set> No, its a multiparam typeclass, where some args are uniquely determined by other ones
11:38:51 <EvilMachine> beaky: The fundeps documentation is really bad. I couldn‚Äôt even find a proper and complete explanation of what is valid syntax and what isn‚Äôt. E.g. is ‚Äúclass C a b c d | a b -> c d‚Äù valid?
11:38:52 <mmaruseacph2> it's impossible with Read, you have to use a parser
11:39:16 <ab9rf> koala_man: there's an implenetation with that signature in Network.CGI but i'm not sure it will be wht you want
11:39:17 <pointed_set> there is a "reads" function, btw
11:39:30 <beaky> so fundeps are like higher kinded types?
11:39:33 <dv-> :t Text.Read.readMaybe
11:39:35 <lambdabot> Read a => String -> Maybe a
11:39:49 <mmaruseacph2> thanks dv, I didn't know about it
11:40:12 * mmaruseacph2 goes to replace all of his read functions to readMaybe :D
11:40:24 <ab9rf> mmaruseacph2: better to just use a parser
11:41:02 <koala_man> dv-: nice. why doesn't Hoogle find it?
11:41:18 <pointed_set> try in your ghci: (map reads ["1", "1lol", "lol"]) :: [[(Int, String)]]
11:41:37 <mmaruseacph2> ab9rf: clearly, but there are some cases where I don't need a parses to just transform the first 2 strings into int or fail the program anyway :)
11:42:00 <ab9rf> mmaruseacph2: still better to write a parser, especially given how easy it is to write parsers with attoparsec or parsec
11:42:52 <dv-> koala_man: i'm not sure
11:42:58 <mmaruseacph2> ab9rf: yep, but do you want to add another dependency to your project just to parse that argument?
11:43:20 <ab9rf> mmaruseacph2: shrug
11:43:34 <ab9rf> mmaruseacph2: attoparsec is small and ubiquitous
11:43:51 <hyPiRion> mmaruseacph2: I thought maximizing build time is the goal of all projects
11:43:58 <ab9rf> hyPiRion: hehe
11:44:08 <Fuuzetsu> the higher the build time, the better your project, everyone knows that!
11:44:17 <ab9rf> mmaruseacph2: you can hand-spin an int parser in about 5 minutes too
11:44:41 <cehteh> why doesnt ghc output C++ code then ? :)
11:44:44 <mmaruseacph2> it is also depending on mostly standard packages so yes, adding attoparsec to the dependencies is not so bad
11:44:49 <ab9rf> cehteh: haha
11:45:48 <jake0123124> Hello, I'm trying to set up ghc-mod and failing. When I run ghc-mod it says "all versions must be the same" and shows me ghc.el version 5.0.0 and ghc-mod version 4.1.6. I don't know if this is the problem but if it is I don't know how to resolve it. Anyone here use ghc-mod or is there a better way to use emacs with haskell?
11:47:08 <Fuuzetsu> I tried using ghc-mod before but it was unsuitable for environment with changing GHC versions‚Ä¶
11:47:11 <Fuuzetsu> maybe I should set it up again
11:47:17 <EvilMachine> mmaruseacph2: Actually something that allows me to write a type class GraphZipper graphzipper where: alterNodeData :: (nodeDataZipper -> nodeDataZipper) -> State graphzipper
11:48:16 <mmaruseacph2> EvilMachine: sorry, I have written only 2 zippers so far
11:48:17 <EvilMachine> mmaruseacph2: and nodeDataZipper should be a zipper for [Float] or [Char] (or probably more efficient things)
11:48:21 <mmaruseacph2> I'm still learning
11:48:28 <EvilMachine> mmaruseacph2: ok. :)
11:48:45 <mmaruseacph2> but you might also want to look at lens
11:48:47 * mmaruseacph2 ducks
11:48:56 <mkster> Hi have worked a bit with binary trees before but now I am really confused about this rose tree. How can I even traverse it recursively in some way? Can someone give me an example maybe? http://lpaste.net/108712
11:49:01 <EvilMachine> mmaruseacph2: With remaining eye? :)
11:49:30 <mmaruseacph2> EvilMachine: I don't get the joke, sorry :)
11:49:43 <EvilMachine> mkster: http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
11:50:03 <mmaruseacph2> mkster: you need a sum and a map there
11:50:05 <mmaruseacph2> @t sum
11:50:06 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:50:15 <mmaruseacph2> @type sum . map
11:50:16 <lambdabot>     Couldn't match type ‚Äò[a] -> [b]‚Äô with ‚Äò[c]‚Äô
11:50:16 <lambdabot>     Expected type: (a -> b) -> [c]
11:50:16 <lambdabot>       Actual type: (a -> b) -> [a] -> [b]
11:51:00 <mmaruseacph2> @type \children -> sum . map children
11:51:01 <lambdabot> Num c => (a -> c) -> [a] -> c
11:51:18 <ab9rf> @type (sum .) . map
11:51:20 <lambdabot> Num c => (a -> c) -> [a] -> c
11:51:32 <mmaruseacph2> @pl \children -> sum . map children
11:51:32 <lambdabot> (sum .) . map
11:51:45 <EvilMachine> mmaruseacph2: Futurama. Don‚Äôt look X with remaining eye.
11:52:08 <mmaruseacph2> paradoxaly, pointless has more (.) :)
11:52:28 <ab9rf> mmaruseacph2: pointfree forms are often laden with (.) :)
11:52:30 <mmaruseacph2> EvilMachine: I should find time to look at that too, soo many things to do
11:52:38 <mmaruseacph2> ab9rf: yep, I know :)
11:52:47 <mmaruseacph2> I was just making a (failed) joke
11:53:48 <mkster> But what if I don't want to use the given functions and do that myself somehow mmaruseacph2
11:53:54 <andreypopp> Does anybody use vim for writing haskell who can advice me on ghc-mod vs. hdevtools vs. ... ?
11:54:15 <jxm> I just commented on a cartoon + voice syntetisis lipsynced youtube video entitled "Should I Learn Erlang or Haskell? ". That guys has a whole series of them, and it's funny how wrong they are :-)
11:54:21 <mmaruseacph2> andreypopp: I use vim and ctags and that's all I need
11:54:32 <EvilMachine> mmaruseacph2: I‚Äôll give up for today. I love Haskell, but I *hate* how hard it is to do utterly simple things like partially limited polymorphy
11:54:45 <mmaruseacph2> mkster: you can write your own sum and map functions
11:54:45 <jxm> "Haskell has a one pass garbage collector to clean up code." Shiny, dust0free "garbage-collected" code :-) No code litter left.
11:54:49 <mmaruseacph2> using recursion
11:54:53 <jxm> https://www.youtube.com/watch?v=GJBUaySG8q8
11:54:57 <andreypopp> mmaruseacph2: I'm not experienced haskell programmer and sometimes I'd want to see some assistance like type of the expr under the cursor
11:55:02 <mmaruseacph2> so, if you have a Nil you just return 0
11:55:04 <jxm> "Haskell's type system means it is dynamically typed"
11:55:30 <mmaruseacph2> if you have Node a children you return 1 + a sum of the values of children
11:55:33 <jj0> anyone know how to setup SSL certificate based auth for webservices in wai?
11:55:53 <mkster> Thats what I tryed: http://lpaste.net/108712
11:55:57 <mmaruseacph2> so you need another function from the list of trees to the list of counts of nodes or to the sum of those counts
11:56:14 <Exio4> jxm, garbage-collected type system!
11:56:28 <mmaruseacph2> andreypopp: I mostly :t in ghci
11:56:46 <mkster> But I don't even know how to get the next Node so I can call the function again with it
11:56:46 <mmaruseacph2> or, if it is an inner value a I do a :: Void
11:56:50 <mmaruseacph2> and look at the error
11:56:58 <nomeata> @help social
11:56:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:57:04 <nomeata> @help away
11:57:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:57:18 <mmaruseacph2> mkster: have you written so far any function on a list?
11:57:23 <mmaruseacph2> *recursive function
11:57:29 <mkster> Yes
11:57:32 <mmaruseacph2> like computing the length or the sum
11:57:37 <mkster> Yes
11:57:38 <jxm> Exio4 Or tail-recursive concurrentcy management?
11:57:52 <mmaruseacph2> it's just the same pattern here too
11:57:56 <nomeata> @help auto-reply
11:57:57 <lambdabot> auto-reply. Lets lambda-bot auto-reply if someone sends you a message
11:57:57 <ab9rf> jxm: where are you finding these nuggets of wisdom?
11:58:06 <nomeata> pavonia ^
11:58:08 <jxm> Too many youtube videos I guess :-)
11:58:10 <Total_1mmersion> Shouldn't this compile? runST $ do { a <- newSTRef Nothing; b <- newSTRef Nothing; return (Compose a == Compose b) }
11:58:11 <mmaruseacph2> f [] = []; f (tree:trees) = something tree : f trees
11:58:38 <mmaruseacph2> and that something can be children
11:58:41 <jxm> I was actually looking for good HAskell videos on youtube
11:58:47 <Total_1mmersion> Compose comes from the transformers package under Data.Functor.Compose
11:58:51 <mmaruseacph2> but you need to make sure you get the types and the arguments righ
11:58:53 <mmaruseacph2> *right
11:58:57 <ab9rf> jxm: finding good anything videos on youtube takes effort
11:58:59 <mkster> Ok I'll try that
11:59:01 <angerman> Say I have a list of 10 elements, and I want to have 3 mostly equal length lists. [4],[4],[2] how would I do that properly?
11:59:02 <jxm> Founds a few gems, like Simon Peyton-Jones lectures
11:59:29 <mmaruseacph2> why not [3, 3, 4] or [4, 3, 3] ?
11:59:30 <jxm> Actually these made me think (hope?) that I could find more good stuff
11:59:34 <mmaruseacph2> (as list of lengths)
11:59:44 <pavonia> nomeata: Yeah, I already found out. But thanks anyway
11:59:45 <jxm> There are actually a few conferences talks that are worth it
11:59:49 <angerman> mmaruseacph2, I'd prefer ceil (10/3)
11:59:52 <Total_1mmersion> angerman, http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
11:59:56 <jxm> But I seem to have fallen in a tarpit now :-)
12:00:52 <angerman> Total_1mmersion, great. Why did I not find that with hoogle? :( I searched for Int -> [a] -> [[a]]
12:00:57 <jxm> A guy have a good selection of language-related videos, many about Haskell: https://www.youtube.com/user/jasonofthel33t/videos
12:01:05 <jxm> has
12:01:05 <Total_1mmersion> angerman, Hoogle doesn't index every package on Hackage
12:01:12 <ab9rf> angerman: hoogle doesn't seem to be catholic enough
12:01:27 <angerman> Total_1mmersion, any better tool?
12:01:49 <angerman> ab9rf: elaborate for an atheist please?
12:02:00 <ab9rf> angerman: look up what 'catholic' means
12:02:11 <Total_1mmersion> angerman, I only know of an alternative to Hoogle, but I don't remember the name or if it indexes more packages
12:02:19 <ab9rf> has nothing to do with religion
12:02:28 <adimit> Hayoo
12:02:35 <Total_1mmersion> angerman, he's referring to the description http://hackage.haskell.org/package/split-0.2.2
12:02:39 <angerman> Total_1mmersion, I know there's one of FP Complete, that the Yesod guys recomend.
12:02:46 <adimit> hayoo indexes more packages, its interface is different.
12:03:17 <angerman> adimit, thanks, I'll check that next time.
12:03:29 <adimit> http://hayoo.fh-wedel.de/
12:04:04 <adimit> though I must say that I personally use hoogle most of the time. Force of habit more than anything.
12:05:14 <Total_1mmersion> It looks like Hayoo knows about the split package because "chunksOf" shows up, but its type Int -> [a] -> [[a]] doesn't show chunksOf...
12:06:02 <Total_1mmersion> Hey, this worked perfectly! https://www.fpcomplete.com/hoogle
12:11:05 <geekosaur> yes, hoogle is generally better at type directed stuff and hayoo at name directed
12:11:20 <geekosaur> both try to do both, but each has differen strengths
12:14:11 <ezyang> Hello all, when you do "import Foo (bar, baz)", what is the list "(bar, baz)" called?
12:14:39 <zinfandel> ezyang: these are functions that you import from module Foo
12:14:45 <Total_1mmersion> Does anyone understand why newtype Apply is introduced in the Data.Functor.Compose module? http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Data-Functor-Compose.html
12:14:52 <ezyang> Yeah, but that's really wordy ^^
12:15:03 <zinfandel> ezyang: imported functions
12:15:15 <ezyang> So, like, the Backpack paper uses "thinning" to refer to a list of this kind
12:15:29 <ezyang> but I don't think that term is all that common in Haskell land
12:15:58 <ajyasgar> well, you are thinning the import space, no?
12:16:08 <ezyang> yes, that's why the term makes sense
12:16:12 <bergey> I like that name, but I've not heard it before.
12:17:11 <ajyasgar> www.mpi-sws.org/~dreyer/papers/backpack/paper.pdf link to the paper for those who don't know
12:17:21 <ClaudiusMaximus> explicit imports is a term i think i've heard
12:17:22 <k00mi> ezyang: how about "import list" as dual to "export list"
12:17:39 <ezyang> ok, the trouble is I'm writing the user manual page for the package-level equivalent, but we don't "import packages"
12:17:58 <ezyang> so "import list" doesn't work, unfortunately
12:18:04 <cmccann> "import list" is what I would say if I didn't stop to think about it
12:18:35 <cmccann> "thinning" is interesting but yeah I've never heard it before either
12:18:41 <ajyasgar> well "import Foo (bar, baz)" imports the functions bar and baz from the Foo module, correct?
12:19:00 <k00mi> yes
12:19:00 <ajyasgar> i'm not that far into my haskell education yet
12:19:02 <ajyasgar> alright
12:19:12 <ezyang> right, so we have this new command line functionality -package "base (Prelude, Data.List)" which only "imports" Prelude and Data.List from the base package
12:19:57 <ajyasgar> then maybe the (bar, baz, ... ) functions being imported from the Foo module could be the "import set" ?
12:20:13 <ajyasgar> gets around the difficulty of using "import list" since list is a core language object
12:20:27 <ajyasgar> not sure if set is actually
12:20:51 <NikolajK> is 'parseCSV input = parse csvFile "(unknown)" input' considered better code than 'parseCSV = parse csvFile "(unknown)" '?
12:21:32 <ezyang> NikolajK: Question of taste, but I'm often tempted to go for the latter since it's shorter
12:21:41 <ajyasgar> if your goal is to reduce the descriptive phrase, i don't know
12:22:01 <ezyang> ajyasgar: OK, I think I'll go with thinning for now
12:22:21 <ajyasgar> probably a good idea since it already has usage in existing literature i guess
12:22:24 <NikolajK> so nobody will raise an eye if reading one and not the other
12:22:53 <ezyang> eta expanding one variable is not too big of a deal
12:22:59 <ezyang> eta expanding ten could be though ;)
12:32:35 <Cale> http://www.reddit.com/r/haskell/comments/2cin7p/is_there_any_way_to_elegantly_represent_this/cjfvbpg
12:32:36 <Cale> lol
12:34:13 <bitemyapp> Cale: why
12:34:29 <Cale> Because that's actually how I understand shitty imperative programs
12:35:02 <Cale> by carrying out that process in a painstaking fashion, and usually ending up with something which is a bit messy, but possible to subject to meaningful analysis
12:35:15 <xintron> Looking for a template engine in Haskell. Found Karter (and like that it's inspired by jinja2) bit are there any other big ones?
12:35:18 <luite> why cond p f g x instead of cond p f g so it also works for constants?
12:35:49 <Cale> luite: I need to apply p to x
12:36:24 <luite> Cale: ah guess i need coffee :)
12:36:49 <Cale> luite: I asked myself the same thing before, and realised that I couldn't easily make it points free :)
12:36:52 <luite> trap_exit: that stm exception problm earlir, were you blocking in a synchronous thread?
12:37:09 <trap_exit> luite: oh hey, was just spamming you in #ghcjs
12:37:15 <trap_exit> I used forkIO
12:37:18 <trap_exit> are those synchronous threads?
12:37:45 <trap_exit> luite: this wasn't in any callback
12:37:46 <bitemyapp> xintron: where's Karter?
12:37:50 <trap_exit> it was just main = forkIO test
12:37:54 <bitemyapp> xintron: I wasn't aware of any Jinja2 inspired template libraries.
12:38:01 <Cale> xintron: Heist?
12:38:01 <trap_exit> and test = create a stm queue, try to read from it
12:38:14 <trap_exit> luite: do you have time to debug / discuss this? I can reload the failure case
12:38:19 <luite> ah k, yeah it looks like you ran into something. forkIO spawns an async thread, it could be called from a sync thread though, which might cause a problem
12:38:19 <Cale> I don't know what Karter and Jinja2 are
12:38:29 <xintron> bitemyapp: https://github.com/sourrust/karver/
12:38:46 <xintron> Cale: I'll look it up. Thanks
12:38:51 <trap_exit> luite: what can I do on my part to make this as easy for you to debug as possible>?
12:39:00 <Cale> http://hackage.haskell.org/package/heist
12:39:44 <luite> trap_exit: yeah i don't think it will be that hard to fix once i can reproduce it, it's just trying to check what makes some thread block, and it looks like it has a null tso, which would be typical for sync threads
12:39:58 <luite> trap_exit: but your earlier example worked ok for me, no error
12:40:31 <trap_exit> luite: I think it's an issue with the stm stuff; in a forkIO: (1) creat tbqueue, write to tbqueue, read from tbqueue = fine (2) create tbqueue, write; read; read = error, (3) create tbqueue; read = error
12:40:37 <trap_exit> damn
12:40:57 <trap_exit> luite: do you have a link of the example you're refeerring to? I just want to make sure we're referring to the same link
12:41:18 <luite> trap_exit: the runtime shouldn't throw exceptions like this, even if you're doing something wrong. a thread blocked indefinitely in an STM transaction should be the worst you get to see from haskell code
12:41:22 <trap_exit> luite: can you try with the following build flags: "ghcjs -Werror -Wall -XMultiParamTypeClasses -XBangPatterns -O2 " ?
12:41:34 <trap_exit> yeah, so ghc = blocked thread
12:41:37 <trap_exit> ghcjs = throwing that exception
12:42:03 <bitemyapp> xintron: thanks
12:42:28 <trap_exit> hmm, maybe this is time I learn cabal and create a proper minimal example
12:42:30 <luite> trap_exit: don't have the gist url anymore, but i had to fix it up a bit to make it self-contained. can you reupload a complete self-containd version so i can be sure i'm testing the right code?
12:42:43 <trap_exit> luite: sure, I will do that
12:43:10 <luite> trap_exit: if you only need base and the stm libraries, cabal shouldn't be necessary, both come with ghcjs-boot and i don't have other versions installed
12:43:35 <mkster_> Can someone help me with this I don't get how to work with this tree http://lpaste.net/108715
12:45:23 <glguy_> mkster_:  1+ (Node x (depth xs  ))   -- can you explain in words what you wanted this line to do?
12:45:58 <mkster_> I want to count the recursions needed to get to the bottom of the tree which is the depth
12:47:19 <glguy_> so you added 1 to what?
12:47:41 <mkster_> to every step and finally to 0
12:47:54 <trap_exit> luite: miniaml example, all from scratch: https://gist.github.com/anonymous/87402ce98fefd6b8bcc9
12:47:55 <glguy_> Node makes a new "ABaum"
12:48:02 <trap_exit> luite: let me know if I can do anything else to assist
12:48:15 <glguy_> so you're adding 1 to an ABaum applied to some arguments
12:48:38 <trap_exit> luite: x@server:~$ ghcjs --version The Glorious Glasgow Haskell Compilation System for JavaScript, version 0.1.0 (GHC 7.8.3)
12:48:54 <mkster_> So I am creating infinite amounts of ABaums?
12:49:13 <glguy_> That probably just isn't what you meant to do
12:49:51 <mkster_> But how can I do it then am trying to do this for hours now
12:50:07 <mkster_> I really don't get it
12:50:36 <trap_exit> luite: I'm off to buy lunch. https://gist.github.com/anonymous/87402ce98fefd6b8bcc9 is the minimal failure example. If you have anhthign (either "trap_exit, yhou're retraded, this works fine on my setup" or "trap_exit, this is a legit bug")_, please feel free to send me a PM; thanks! (be bacvk in 20 mins)
12:52:17 <glguy_> mkster_: There are two problems you have to thhink about. You're adding a number to an ABaum and you're trying to call depth on a list of ABaums, but it only works on single ABaums
12:52:40 <glguy_> depth :: ABaum a -> Int
12:53:01 <glguy_> but xs is   [ABaum a]
12:53:09 <glguy_> so "depth xs" isn't going to make sense
12:53:18 <pointed_set> maximum . map depth ?
12:53:43 <mkster_> no I don't want to use given functions
12:54:05 <glguy_> pointed_set: First mkster_ needs to understand why its wrong, it's not going to help to just write the answer out
12:54:48 <mkster_> Maybe it helps because the problem is that I dont know how to work with this type of data
12:55:27 <pointed_set> What does he wanted to do?
12:55:34 <tulcod> can haskell do any kind of C ("ffi") type checking? ie, i'm binding to some C functions, but it doesn't seem to make any attempt at matching up the type i'm giving it with the actual C type
12:56:02 <mkster_> I want to calculate the number of recursions needed till I reach the bottom of a tree http://lpaste.net/108715
12:56:13 <glguy_> mkster_: How would you determine the depth manually, without haskell?
12:56:30 <mkster_> Counting the longest chain of nodes
12:56:53 <glguy_> The computer needs more detail than that, though. How do you decide what the longest chain of nodes is
12:57:13 <tulcod> mkster_: what does 1+(Node x (depth xs  ))  mean? how can you add an integer to an ABaum a ?
12:57:39 <mkster_> I keep going into Nodes which are not Nil?
12:57:52 <tulcod> mkster_: what's the type of (+)?
12:58:29 <mkster_> I want to count the recursions tulcod
12:58:47 <tulcod> mkster_: why don't you want to answer my questions?
12:58:48 <pointed_set> The [ABaum a] is a List (ABaum a). So you should use "map" to do something (depth) over them and then combine result.
12:59:01 <mkster_> I thought it would evauluate to a chain of 1 + 1 +.. +0
12:59:22 <tulcod> mkster_: but that's not what it says
12:59:24 <Total_1mmersion> Does anyone understand why newtype Apply is introduced in the Data.Functor.Compose module? http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Data-Functor-Compose.html
13:00:20 <mkster_> I know and thats where I am stuck
13:00:24 <pointed_set> It will do so on data Nat = O | S Nat, but in your case it wont. Try figure out what are you trying to represent.
13:00:41 <ryantm> Is there a way to specify development-only dependencies with cabal? For example, HLint.
13:01:06 <c_wraith> ryantm: you can have that dependency depend on a flag you set
13:01:36 <benzrf> what's an ABaum
13:01:43 <mkster_> I did binary trees before that thats probably why I did it like this
13:02:03 <mkster_> Baum is German and means tree
13:02:21 <tulcod> mkster_: + is something that adds two integers
13:02:25 <pointed_set> mkster_: just try what I posted first and then try to think about it. 1 + <conbiner> (map <action> xs)
13:02:31 <tulcod> mkster_: so the thing on the left of + should be an integer, and the thing on the right should be an integer
13:03:04 <mkster_> but doesn't it evaluate to and Int?
13:03:05 <tulcod> mkster_: if the expression (Node x (depth xs  )) would make sense, then its type would definitely be (ABaum a)
13:03:27 <tulcod> mkster_: so the expression  1+ (Node x (depth xs  ))  doesn't make sense, since the hting on the right of + is not an integer
13:03:47 <tulcod> so that's wrong. but additionally, (Node x (depth xs  )) doesn't make sense
13:03:51 <gamegoblin> Does Haskell have any sort of macro system? I‚Äôd like to define ifM and caseM so I can stop doing `   a <- f x; if a ‚Ä¶  `   and do `   ifM f x ‚Ä¶  ` instead
13:04:28 <pointed_set> gamegoblin: You can actially define ifM
13:04:30 <tulcod> mkster_: since "depth" supposedly outputs an integer, rgiht?
13:04:39 <mkster_> Yes
13:04:42 <tulcod> mkster_: so "depth xs", if that expression would make sense, would be an integer
13:04:43 <Cale> gamegoblin: You don't need macros for that
13:04:47 <Philonous> gamegoblin, It has TH, bot that's not what you want. let ifM p t f = p >>= \b -> case b of True t; False f
13:04:49 <tulcod> but then what is a Node x (some integer)
13:05:01 <tulcod> the second argument to Node should be a list of things with the same type of x
13:05:02 <gamegoblin> I want to be able to still use the `then` and `else` keywords, though
13:05:06 <tulcod> instead of that list, you offer an int
13:05:18 <tulcod> mkster_: so that's broken. but - and i hate to tel lyou this - it's worse
13:05:34 <Cale> gamegoblin: Well, even macros aren't going to help with that :P
13:05:48 <tulcod> mkster_: depth xs doesn't make sense: supposedly "depth" takes an (ABaum a) input. but you're offering it xs, which is a [ABaum a]: a list of such (ABaum a)'s
13:05:56 <gamegoblin> Cale: Not necessarily macros I guess, I just mean syntax extension. Like defining my own syntactic sugar.
13:06:32 <gamegoblin> I could always make my own preprocessor I guess and alias ghc in my bashrc to run it through my preprocessor first
13:06:38 <gamegoblin> But that seems pretty hacky
13:06:41 <tulcod> mkster_: is it clear what's wrong?
13:07:06 <mkster_> i think so but I don't know how to write it correctly in haskell syntax
13:07:19 <tulcod> mkster_: that's understandable. haskell takes a while getting used to
13:07:20 <vanila> gamegoblin, you don't need to do that
13:07:24 <Cale> There's also f x >>= \case True -> ...; False -> ...
13:07:25 <pointed_set> mkster_: try to look onto "map" and "maxinum" functions in your ghci, maybe that gives you an insight
13:07:31 <tulcod> mkster_: (but it gets much, much better after letting it sink in)
13:07:43 <Cale> using the LambdaCase extension
13:07:46 <Philonous> gamegoblin, Actually, you can have this. You need -XNoImplicitPrelude and -XRebindableSyntax though
13:07:49 <tulcod> mkster_: (so much so that you'll want to write like you do in haskell even if you're writing in a different language)
13:08:01 <mkster_> I don't want to use given functions pointed_set
13:08:32 <Philonous> gamegoblin, I think it's a bad idea, though
13:08:33 <tulcod> mkster_: can i suggest you try some other haskell exercises first?
13:08:39 <pointed_set> +1
13:08:44 <gamegoblin> Philonous: yeah, starting to see that
13:08:52 <trap_exit> luite: can you replicate the bug?
13:09:27 <mkster_> I actually did quite a lot but I am having trouble understanding these data things
13:10:43 <mkster_> i did binary trees before where I could split up the tree in every step but I don't know how to do it with these trees
13:11:24 <vanila> mkster_, what is the problem?
13:11:32 <tulcod> mkster_: what is the type of "depth" going to be?
13:11:45 <tulcod> mkster_: (being explicit about your types in haskell typically helps you program)
13:12:28 <mkster_> The longest chain of nodes in a tree http://lpaste.net/108715
13:13:06 <vanila> what is a chain of nodes?
13:13:45 <tulcod> mkster_: what do you want the type of "depth" to be?
13:13:50 <mkster_> uh thats hard to explain
13:13:56 <mkster_> Int
13:14:01 <vanila> well, take your time
13:14:02 <tulcod> depth is a constant?
13:14:08 <ColonelJ> tulcod: if you make your types too explicit they may be deemed unfit for children
13:14:12 <vanila> but if you're going to write a program to compute things related to it you should be able to explain what it is
13:14:24 <forgottenone> hi i am trying configure vim to start learning haskell but when i try to install something with cabal i get this error:http://lpaste.net/108717 how can i fix it
13:14:31 <mkster_> English is not my native language
13:14:48 <tulcod> mkster_: if depth is an Int, why are you trying to feed it an argument? you can only feed arguments to function types
13:14:51 <glguy_> forgottenone: That says "warning"
13:15:28 <mkster_> No its a function then
13:15:35 <mkster_> one that returns an Int
13:15:35 * hackagebot amqp 0.10 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.10 (HolgerReinhardt)
13:15:37 <tulcod> what is its input and output?
13:15:40 <forgottenone> glguy: full log: http://lpaste.net/108718
13:15:53 <tulcod> right, depth takes something and outputs an Int. what does it take?
13:16:04 <mkster_> the input is a tree and the output an Int
13:16:21 <tulcod> right. so in haskell we'd say: depth :: ABaum a -> Int
13:16:31 <mkster_> Yes
13:16:36 <tulcod> good
13:16:46 <tulcod> mkster_: now, your first line indeed satisfies that
13:16:58 <tulcod> mkster_: Nil is an ABaum a, and 0 is an Int. so that's good.
13:17:28 <tulcod> mkster_: but your second line isn't quite right. yes, its input is an ABaum a. but then what?
13:17:49 <pointed_set> wake me when you'll get to the map & maximum
13:17:55 <tulcod> mkster_: you're matching the input against Node x xs.    so what is the type of x, and what is the type of xs?
13:18:07 <glguy_> forgottenone: and which version of GHC are you using?
13:18:29 <forgottenone> glguy 7.8.3
13:19:14 <mkster_> I am not sure about that x could be everythign because of a or maybe ABaum or Node
13:19:51 <pointed_set> mkster_: you could ignore x here completely
13:20:02 <mkster_> With _ ?
13:20:06 <tulcod> mkster_: okay, but if you know that x has type a, then what is the type of xs?
13:20:07 <pointed_set> yep
13:20:34 <mkster_> xs is [Abaum a] or maybe just ABaum?
13:20:48 <glguy_> forgottenone: It's possible that cgi just doesn't work with GHC 7.8.3 because it hasn't been updated for the new Typeable system
13:20:55 <pointed_set> you need somehow make an int from a list of trees (knowing that depth makes an int from 1 tree)
13:21:10 <tulcod> mkster_: why are you unsure?
13:21:20 <mkster_> No its supposed to take only one tree
13:21:40 <forgottenone> glguy how can i fix it?
13:21:47 <mkster_> becuase I am not used to splitting up arguments like that
13:22:08 <glguy_> forgottenone: cabal get cgi   to download the sources and then delete the manually written Typeable instance and use automatic deriving to derive it
13:22:33 <_ahg> I am having difficulty importing a library. I have run 'cabal-install line2pdf', and indeed I see the source code in my .cabal-sandbox
13:22:36 <glguy_> The DeriveDataTypeable language extension allows you to "derive (Typeable)"
13:22:46 <tulcod> mkster_: you defined the node thing as: Node a [ABaum a].... so if its first argument (the x) has type a, then its second argument (the xs) has type [ABaum a]
13:22:47 <mkster_> I can take only Nil or 3 arguments which is weird for me
13:23:03 <_ahg> however, when I attempt to compile a file that starts with 'import Text.LineToPDF', I get "Could not find moduel 'Text.LineToPDF'"
13:23:08 <tulcod> mkster_: so xs is a list
13:23:17 <tulcod> your various tree path choices
13:23:46 <_ahg> I do not know how to troubleshoot this--Text.LineToPDF is the module provided by the package, as far as I can tell
13:24:04 <pointed_set> Ok. It starts bother me. You could do "(map depth xs)" to get a [Int] - list of subtrees' depths. And then "maximum (map depth xs)" to get the maximum subtree depth. And then add 1.
13:24:13 <rudi_s> Hi. I want to escape a character in a string (i.e. "$" -> "\\$"). My current solution is concatMap f wheren f '$' = "\\$" ; f x = [x] - is there a better way?
13:24:37 <mgsloan> _ahg: Does ":m + Text.LineToPDF" work in ghci?
13:24:48 <mkster_> but I don't want to use these functions pointed_set
13:25:11 <pointed_set> mkster_: how do you want to make it, then?
13:25:14 <_ahg> mgsloan: No, I get the same error
13:25:43 <tulcod> mkster_: if not, then exercise: implement map
13:25:44 <mkster_> like I did it with binary trees before
13:25:58 <fizbin> @type let foo f lst = (let rv = reverse lst in reverse $ (f $ head rv):tail rv) in foo
13:26:01 <lambdabot> (a -> a) -> [a] -> [a]
13:26:03 <mgsloan> _ahg: Even with "cabal repl" ?
13:26:41 <_ahg> mgsloan: aah, with cabal repl, it successfully loaded the module
13:26:42 <mgsloan> _ahg: cabal sandboxes only affect cabal commands, so if you use ghc / runhaskell, they aren't going to see your sandbox
13:26:49 <pointed_set> mkster_: you tried to add an int to a tree. How we are supposed to believe, that you did it to the binary trees?
13:26:50 <fizbin> Does anyone have a better way of writing foo above? It's supposed to use a supplied function to modify the last element of the given list.
13:27:14 <_ahg> mgsloan, so rather than 'ghc file.hs', I will have to define a cabal package, and build it with cabal?
13:28:01 <mkster_> look at this: height (N ln rn) = 1 + max (height ln) (height rn)
13:28:08 <vanila> > let foo f lst = (let rv = reverse lst in reverse $ (f $ head rv):tail rv) in foo (\x -> 'y') "abc"
13:28:10 <lambdabot>  "aby"
13:28:12 <mgsloan> _ahg: Yes, or use hsenv
13:28:12 <mkster_> thats how I did it with bin trees
13:28:15 <hexagoxel> _ahg: "cabal exec -- ghc file.hs" should work. for anything larger, creating a package is probably a good idea though
13:28:23 <mgsloan> hexagoxel: Ahh, good to know!
13:28:35 <tulcod> mkster_: okay, here you need to take the maximum of a *list* of items rather than 2
13:28:38 <pointed_set> fizbin: the list is a bad container for that. You can also use some lenses
13:28:46 <vanila> fizbin, you could write it like this:   foo _ [] = [] ; foo f [x] = [f x] ; foo f (x:xs) = x : foo f xs
13:28:46 <mgsloan> I shouldn't be making blanket statements like that about cabal sandboxes, personally I still use hsenv
13:28:49 <tulcod> mkster_: but you also need to take the *height* of each of the items in the list
13:28:57 <_ahg> mgsloan and hexagoxel: thank you both.
13:29:12 <mgsloan> welcome!
13:29:25 <fizbin> pointed_set: Yeah, but it's a good container for surrounding uses, and this is just one spot in the code.
13:30:01 <mkster_> no the function is height it calls itself
13:30:10 <tulcod> mkster_: what is that a response to?
13:30:17 <c089> hi everyone. does one of you people have a copy of craft of functional programming 3rd edition and would be so nice to look something up for me?
13:30:32 <mkster_> you said I need to to take the height
13:30:33 <fizbin> vanila: Yeah, I thought of that too. Not sure what's better, though I guess that version is likely faster. (not that speed matters in the spot where I'm calling it)
13:30:41 <vanila> my way is better and faster
13:30:44 <tulcod> mkster_: what?
13:30:44 <c089> when he introduces quickcheck he has a rather unusual implementation of a very simple function (I think it was max3) which fails in a few edge cases
13:30:59 <tulcod> mkster_: what else do you want to do than take the height of each element in the list?
13:31:17 <forgottenone> glguy i am absolute beginner at haskell  so could you explain deriving
13:31:19 <mkster_> no nvm
13:31:49 <tulcod> mkster_: so turns out there's a neat little way to apply a function to every item in a list - map
13:32:05 <tulcod> and if you don't want to use that, that's fine, but then you should write something of your own
13:32:09 <mkster_> Yes I know map
13:32:25 <ColonelJ> fizbin, just curious, why are you asking?  your way looks pretty good and it works, and like you say, you don't care about its performance...
13:32:37 <tulcod> mkster_: and can you take the maximum of a list?
13:32:42 <fizbin> I mostly care about other people reading the code.
13:32:49 <mkster_> Sure
13:32:53 <fizbin> At least in this section of it.
13:33:12 <ColonelJ> fizbin, well you could name the function something like modifyLast instead of foo, and that's now readable
13:33:24 <fizbin> True.
13:33:26 <pointed_set> fizbin: let map_last f list = let (init, [last]) = splitAt (length list - 1) list in init ++ [f last]
13:33:42 <tulcod> mkster_: so what you wrote for binary trees does this
13:33:49 <tulcod> mkster_: it takes the height of both the left and right element
13:33:55 <tulcod> mkster_: and then takes the max of those two elements
13:34:04 <tulcod> mkster_: instead, you'll want to apply depth to all elements in the list
13:34:11 <tulcod> mkster_: and hten take the maximum of the resulting list
13:34:21 <tulcod> mkster_: makes sense?
13:34:30 <carter> johnw ping!
13:34:44 <mkster_> But I don't even know how to traverse the list correctly
13:34:58 <pointed_set> map does it >_>
13:35:22 <tulcod> mkster_: http://www.haskell.org/haskellwiki/99_questions/1_to_10
13:36:01 <glguy> Forgottenone: I can post a diff in a bit, but if you're new to Haskell abandoned packages might be the wrong place to start
13:37:18 <mkster_> I'll keep trying now and see if I get it done somehow
13:37:32 <hexagoxel> oh, "cabal exec -- ghc-pkg list" shows the packages in the sandbox.. i hadn't even tried that before :)
13:39:09 <mmmm> hexagoxel:  cabal sandbox hc-pkg list as well :P
13:39:10 <glguy> Forgottenone if you want to read https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/deriving.html  section 7.5.3. I'm on my phone, it's hard to write out code
13:39:19 <forgottenone> glguy: you're right but i want to install this packages to use vim with haskell
13:39:48 <glguy> This isn't for using vim
13:40:02 <glguy> Hpaste is an old paste bin web service
13:41:20 <pointed_set> Did anyone see any "how to do youself an FRP library" tutorial? The Event/Behaviour one, I mean.
13:42:52 <forgottenone> glguy i know but vim2hs extension requires hpaste
13:43:30 <forgottenone> glguy optionally at least
13:44:25 <nitrix> What is the standard practice for type definition of functions?
13:44:50 <nitrix> Do you do it explicitely, leave it implicitely, mixture of both depending on context?
13:45:08 <tulcod> nitrix: i'd say explicit if it's API, otherwise whatever you feel is appropraite
13:45:25 <pyon> nitrix: What language?
13:45:28 <annelies> I put explicit type signature on all top-level functions.
13:45:33 <nitrix> pyon: Haskell of course :)
13:45:35 <tulcod> pyon: ..
13:46:19 <pyon> nitrix: Normally, one uses explicit type signatures for module-level definitions, but leaves types to be inferred by the compiler for local definitions. ("let" and "where" clauses)
13:46:32 <nitrix> By giving explicit type signatures to the top-level API functions, that should be enough to guarantees other functions? Unless I'm mistaken.
13:46:41 <pyon> nitrix: But, personally, I prefer leaving them all to be inferred, because I am a lazy bastard.
13:46:49 <tulcod> nitrix: well... not quite... but it's probably good enough
13:46:53 <tulcod> nitrix: i mean yeah, i was gonna type that
13:47:06 <nitrix> pyon: Haskell is also lazy, we're even :D
13:47:09 <pyon> nitrix: lol
13:47:20 <vanila> you don't need any type annoations in haskell, it will infer everything unless you use advanced type system features like GADTs
13:47:37 <tulcod> nitrix: in the end, if it even compiles, it probably does what you want
13:47:47 <nitrix> pyon: Besides, I actually understand why it's lazy now, though. It's probably because of list comprehension, which is an amazing, AMAZING thing.
13:47:56 <ColonelJ> doesn't providing types allow errors to make more sense in the case where your program does NOT type check?
13:48:05 <tulcod> ColonelJ: correct
13:48:07 <vanila> ColonelJ, no
13:48:10 <nitrix> I'm learning the typeclasses right now.
13:48:14 <mkster_> tulcod one more question: how should I work with it like a list I obvioulsy can't match it the usual way with (x:xs)
13:48:15 <tulcod> ColonelJ: as in. it does help.
13:48:28 <tulcod> mkster_: well really you should be using map
13:48:29 <orion> How can I get haddock to generate documentation for internal/non-exported code?"
13:48:38 <tulcod> mkster_: if you don't want to use map, the easiest way would be to implement map.
13:48:53 <mkster_> use map on what? xs?
13:48:54 <tulcod> mkster_: the second easiest way would be to write something that closely resembles map
13:48:55 <l0cust> nitrix: not quite. In most cases, yes, but there are many cases with polymorphic types
13:48:58 <tulcod> mkster_: yes
13:49:06 <mkster_> Ok
13:49:07 <tulcod> mkster_: and if that doesn't make sense, you should do more list-related exercises
13:49:08 <l0cust> nitrix: such as Aeson
13:49:14 <nitrix> l0cust: I see. I'm not there yet, but good to know.
13:49:47 <l0cust> nitrix: Aeson, in case you don't know, is Haskell's JSON library (it's really nice).
13:49:50 <orion> I re-export an internal function called "scrypt" (which is documented), but haddock warns me with: Warning: Crypto.KDF.Scrypt: could not find link destinations for: Crypto.Internal.Scrypt.scrypt
13:49:52 <tulcod> orion: maybe export it to a library that you don't install?
13:49:58 <nitrix> l0cust: Oh, sweet!
13:49:58 <mkster_> I know lists well but I don't see the relation from tree to lits yet
13:50:16 <l0cust> nitrix: or if you do a lot with the OverloadedStrings extension
13:50:32 <tulcod> mkster_: well i don't know what you call "knowing" a list. implementing map should be a 5 minute exercise.
13:50:39 <tulcod> probably less
13:50:53 <nitrix> Yeah, I just learned today that strings are inneficient as they are list of characters. People tend to use proper modules for them.
13:51:03 <mkster_> Yes I think I even did it before
13:51:08 <t4nk629> what is ($)
13:51:09 <nitrix> But I perfectly understand the need for it and I actually like this better.
13:51:15 <l0cust> nitrix: there are two separate modules
13:51:18 <t4nk629> :t $
13:51:19 <lambdabot>     parse error on input ‚Äò$‚Äô
13:51:19 <lambdabot>     Perhaps you intended to use TemplateHaskell
13:51:24 <tulcod> :t ($)
13:51:26 <l0cust> @@ t4nk629 @src ($)
13:51:26 <lambdabot> (a -> b) -> a -> b
13:51:26 <lambdabot>  t4nk629 f $ x = f x
13:51:48 <l0cust> @@t4nk629: @src ($)
13:51:53 <tulcod> t4nk629: you just use it to change associativity
13:52:17 <l0cust> t4nk629: it basically means "wrap the rest of the line in parentheses"
13:52:43 <tulcod> take  "f a b". that means: apply a to f, then apply b to (f a). so "f a b" is (f a) b... but "f $ a b"  means  f (a b)
13:52:45 <pointed_set> mkster_: if you see no relations from your tree to list, I have bad news for ya
13:53:08 <nitrix> So, a $ b $ c is a(b(c)) ?
13:53:11 <tulcod> yes
13:53:19 <tulcod> nitrix: except that you need to add some spaces in there
13:53:20 <tulcod> but yes
13:53:29 <nitrix> Right, but I tried to keep it simple.
13:53:31 <mkster_> What do you mean pointed?
13:53:42 <nitrix> That's actually very convenient instead of using parentheses everywhere.
13:53:43 <pointed_set> a (b (c d) = a . b $ c d
13:53:52 <ColonelJ> lists are a special case of trees, so I don't see how knowing lists implies you know trees, there's no logical connection
13:54:04 <tulcod> pointed_set: that's horrible
13:54:04 <ColonelJ> (lists are trees where each node only has one branch)
13:54:11 <annelies> except for the last node!
13:54:32 <pointed_set> tulcod: totally agree
13:54:33 <rudi_s> tulcod: Horrible?
13:54:35 <ColonelJ> well the last node is a leaf not a node, but that's more a terminology thing
13:55:09 <kuribas> Does anyone get parse errors in haskell-indentation.el?
13:55:12 <rudi_s> I prefer a . b $ c d to all those braces personally.
13:55:21 <ColonelJ> anyway you can also have trees where the data is all stored in the leaves and not in the nodes
13:55:28 <tulcod> rudi_s: well i would say a $ b $ c d   is preferable
13:55:29 <pointed_set> +1 to rudi_s
13:55:48 <tulcod> or maybe even a $ b $ c $ d   if they're all on equal footing
13:56:03 <annelies> I tend to like parentheses except when nested.
13:56:08 <rudi_s> tulcod: Hm. I like a . b . c $ d (in this form actually) because I find the . to be less visually distracting than $
13:56:18 <tulcod> rudi_s: ah. hm, yeah i can live with that
13:56:31 <tulcod> my point was that mixing them like that where you can suffice with using just one is... weird?
13:56:40 <tulcod> ok i dunno. perhaps it's a style thing.
13:57:04 <rudi_s> Yeah. It's just a personal matter. Still I like the ability to use multiple equal ways.
13:57:17 <nitrix> addThree :: Int -> Int -> Int -> Int, apparently the input types would be Int -> Int -> Int and the output Int. Does that means functions always return one value?
13:57:31 <nitrix> And you'd need a tuple for multiple values bundled as one ?
13:57:36 <annelies> Functions always take one value and return one value.
13:57:42 <ColonelJ> nitrix, it's right associative
13:57:47 <tulcod> nitrix: yes
13:57:50 <pointed_set> tulcod: you could suffice by using a S & K combinators only
13:57:53 <tulcod> nitrix: aka currying
13:57:58 <annelies> you can see it as Int -> (Int -> (Int -> Int))
13:58:00 <ColonelJ> Int -> Int -> Int -> Int   ====   Int -> (Int -> Int -> Int)
13:58:42 <annelies> Like Func<int, Func<int, Func<int, int>>> in C#.
13:58:50 <pointed_set> nitrix: you could return a tuple Int -> (Int, String) if you want
13:58:56 <nitrix> Right.
13:59:18 <nitrix> It's the fact it has only one input, though there are clearly 3 ints there that confused me.
13:59:31 <nitrix> But that'd be currying as pointed out.
14:00:08 <ColonelJ> you can also have something like (Int, Int, Int) -> Int
14:00:15 <pointed_set> currying is a great thing
14:00:21 <ColonelJ> where it takes all 3 arguments in a tuple, as you would in most other languages
14:00:30 <ColonelJ> :t curry
14:00:31 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:00:38 <kuribas> in ML most functions are uncurried, right?
14:00:41 <nitrix> Yeah, honestly I expected that.
14:00:59 <mkster_> tulcod how would I even use map on it? Thats what I did: test (Node x xs) = map (+1) xs but I am not even sure if my tree is real list because thats what I think it would look like: Node 3 [Node 5 [Node 2 [Nil]]]
14:01:01 <pointed_set> In SML & OCaml they are curried
14:01:04 <nitrix> addThree x y z = x + y + z
14:01:32 <nitrix> I'm not sure I understand currying as ((a, b) -> c) though, given that example.
14:02:02 <tulcod> mkster_: okay, i'm sorry, i feel like i've explained this properly. you should re-read some early chapters on haskell.
14:02:09 <pointed_set> addThree = \x -> \y -> \z -> x + y + z
14:02:21 <nitrix> Though the book didn't cover tuples very much so far, maybe I'll connect the dots later.
14:02:38 <ion> instance Num a where { addThree :: a -> a -> a -> a; addThree x y z = x + y + z; (+) :: a -> a -> a; (+) = addThree 0; {-# MINIMAL addThree | (+) #-} ‚Ä¶ }
14:02:41 <annelies> Tuples are the simplest data structure.
14:02:51 <kuribas> nitrix: that's what currying is by definition.
14:02:52 <ColonelJ> nitrix: curry takes a function that is NOT curried ((a, b) -> c) and returns it as a function that is (a -> b -> c)
14:03:05 <ColonelJ> :t uncurry
14:03:06 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:03:09 <ColonelJ> that does the opposite
14:03:22 <t4nk475> whats the semantics of the duplicate method of the Comonad typeclass?
14:03:23 <nitrix> annelies: Yeah but then, my function would receive a tuple and an int ?
14:03:37 <tulcod> nitrix: if you want to output a tuple, output a tuple
14:04:01 <nitrix> Oh... my, god.
14:04:11 <pointed_set> :t \(x, y) -> x + y
14:04:13 <lambdabot> Num a => (a, a) -> a
14:04:25 <nitrix> So by adding parentheses to the function definition, I can actually curry it differently?
14:04:29 <ion> tnk: It should satisfy the laws specified in https://hackage.haskell.org/package/comonad-4.2.2/docs/Control-Comonad.html
14:04:42 <ColonelJ> nitrix yes you can have inputs that are functions
14:04:45 <annelies> the parentheses are a tuple pattern
14:05:01 <Luke> is there any equivalent of liftA2 but for functor?
14:05:03 <annelies> so \t(x, y) -> x + y takes a tuple of two numbers and returns a number
14:05:10 <annelies> s/t//
14:05:16 <jdgallag> Is anyone familiar with the Haskell-FFI?
14:05:33 <ion> luke: That is specifically the power Applicative provides that Functor does not.
14:05:34 <pointed_set> Luke: Functor doesn't have such a structure
14:05:43 <pointed_set> ion: +1
14:05:46 <kuribas> jdgallag: just ask
14:05:51 <nitrix> Holy crap.
14:06:00 <nitrix> I love haskell.
14:06:10 <pointed_set> :t uncurry (+)
14:06:12 <lambdabot> Num c => (c, c) -> c
14:06:26 <Iceland_jack> > uncurry (+) (10, 5)
14:06:28 <lambdabot>  15
14:06:58 <ion> > uncurry uncurry ((+), (10, 5))
14:07:00 <Luke> ion: yeah I thought so. I don't have a pure instance so not much I can do
14:07:00 <lambdabot>  15
14:07:04 <ColonelJ> > curry . uncurry (+) $ 10 5
14:07:05 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> ((a, b) -> c, (a, b) -> c)))
14:07:06 <lambdabot>    arising from the ambiguity check for ‚Äòe_1105‚Äô
14:07:06 <lambdabot>  from the context (GHC.Num.Num ((a, b) -> c),
14:07:06 <lambdabot>                    GHC.Num.Num (a1 -> ((a, b) -> c, (a, b) -> c)),
14:07:06 <lambdabot>                    GHC.Num.Num a1)
14:07:09 <tulcod> nitrix: also, such things are not just some theoretical construct. i use those every day.
14:07:10 <ColonelJ> haha fail
14:07:13 <Iceland_jack> > map (uncurry (+)) [(1, 10), (2, 20), (3, 30)]
14:07:15 <lambdabot>  [11,22,33]
14:07:24 <ColonelJ> > curry . uncurry (+) $ 10 $ 5
14:07:25 <tulcod> nitrix: there's whole libraries around constructs such as
14:07:26 <lambdabot>  Could not deduce (GHC.Num.Num (s0 -> ((a, b) -> c, (a, b) -> c)))
14:07:26 <lambdabot>    arising from the ambiguity check for ‚Äòe_1105‚Äô
14:07:26 <lambdabot>  from the context (GHC.Num.Num ((a, b) -> c),
14:07:26 <lambdabot>                    GHC.Num.Num (s -> ((a, b) -> c, (a, b) -> c)),
14:07:26 <lambdabot>                    GHC.Num.Num s)
14:07:30 <tulcod> :t (.).(.)
14:07:30 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:07:43 <Iceland_jack> ColonelJ: You can play around with lambdabot in PM
14:07:44 <ion> colonelj: I *wish* ($) had that fixity.
14:08:04 <nitrix> tulcod: It's a lot to grasp at one, but if I understand the implications correctly, this is just insane.
14:08:11 <nitrix> s/one/once/
14:08:12 <ColonelJ> Iceland_jack: it's only noisy because I'm doing it wrong
14:08:23 <t4nk475> ion: fair enough, but the laws retrict the behaviour so little that its tough to come up with examples
14:08:33 <jdgallag> I have some functionality, implemented in C, that works on Structs which represent trees.  I would like to wrap this functionality into a Haskell module.  I would like to be able to take a Haskell analog of such trees, lower them into a C struct, run the C functions, and obtain the result back into a Haskell data type.
14:08:34 <Iceland_jack> ColonelJ: I know :) you can then use the working code in #haskell and look like you got it right in the first try
14:08:35 <tulcod> nitrix: that's absolutely correct. from a programmers' point of view, the compiler is absolute magic.
14:09:28 <jdgallag> Would it be better to use a bit of networking to handle the interface or is the FFI capable of handling this sort of thing ... easily.
14:10:23 <pointed_set> :t fix
14:10:24 <lambdabot> (a -> a) -> a
14:10:39 <tulcod> jdgallag: you don't want to write bindings to C structs without using libraries
14:10:49 <tulcod> jdgallag: but once you do use them, it's extremely easy
14:10:51 <Iceland_jack> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 4
14:10:53 <lambdabot>  24
14:11:04 <tulcod> jdgallag: i personally like c2hs, but there are various helper libraries
14:11:39 <vanila> jdgallag, I would do this using networking or some kind of "wire" protocol where you instruct C to build the tree using some ffi functions
14:12:23 <c089> Swizec: well well well. if it isn't the man with body of a bro and the mind of a scholar o_O the internet is a small place my friend
14:12:27 <pointed_set> howdy I make lambdabot figuring out object outta their type?
14:12:39 <ion> ‚Äú@djinn‚Äù
14:12:41 <jdgallag> tulcod: Can you point me to any tutorialish material that shows how to interface with C structs that are "recursive"
14:12:45 <pointed_set> thx
14:12:49 <Swizec> c089 hello, small place indeed :D
14:13:00 <tulcod> jdgallag: no. but it's not any different from how you would construct them in haskell.
14:13:03 <pointed_set> @djinn (a -> a) -> a
14:13:04 <lambdabot> -- f cannot be realized.
14:13:05 <Swizec> c089 and yup, I follow the greek ideal. No need to neglect how you look just because you're an intellectual
14:13:26 <c089> didn't they excercise naked?
14:14:00 <SrPx> maybe this is silly but is it possible to download the whole haskellwiki as a PDF or better, .mobi? (:
14:14:11 <nitrix> Doing pushups on one hand and reading a book with the other.
14:14:18 <tulcod> jdgallag: the idea of struct handling in the FFI is that all of the data you have is purely in the haskell universe, and when you want to pass it to the C landscape, you write some bytes to memory which happen to line up to form the struct you want. then when you want to read such a C struct, you read some seemingly arbitrary bytes from memory to recover your haskell data
14:14:34 <tulcod> jdgallag: so it's not like one object is interpreted in two ways by different languages
14:14:36 <SrPx> I'm downloading a few Haskell books to read on Kindle but honestly on my experience I've been learning much more reading the haskellwiki
14:14:45 <tulcod> jdgallag: it's very clear when some object is in the haskell land or in the C land
14:15:14 <ColonelJ> nitrix yea the sleeping buddha pose is good for that
14:15:15 <mmmm> SrPx: You can feed urls into pandoc and it should do a decent job
14:15:25 <mmmm> not to mobi though unfortunately
14:15:29 <SrPx> mmmm: mmm...
14:15:38 <pointed_set> SrPx: you'd better learn by trial in ghci
14:15:40 <SrPx> let me think
14:15:52 <nitrix> ColonelJ: I wasn't even serious ;-;
14:15:54 <Fuuzetsu> nitrix: going to gym tomorrow?
14:15:56 <SrPx> pointed_set: sometimes I don't have a computer with me ):
14:16:13 <ColonelJ> nitrix: it is possible to exercise without moving!
14:16:18 <SrPx> pointed_set: as unbeliavle as it seems
14:16:22 <mmmm> Though you could first just write a mobi writer for pandoc
14:16:36 <Swizec> c089 I exercised naked once ... it feels weird
14:16:43 <SrPx> mmmm: o.o
14:16:44 <pointed_set> SrPx: I'm horrified from such a perspective
14:16:59 <ion> You can convert a number of formats to mobi with calibre.
14:17:19 <rudi_s> Can I change the result of System.Environment.getEnv? I'd like to test a function which uses getEnv and simulate different environment values.
14:17:35 <SrPx> pointed_set: we both ):
14:17:57 <ColonelJ> Swizec: I suspect girls have an easier time of it but who knows what they do
14:18:04 <c089> Swizec: the naked pushup... is just wrong
14:18:16 <mwhit> i joined this channel at a weird point
14:18:24 <ColonelJ> well you get covered in fluff off the floor... and it sticks
14:18:29 <Swizec> ColonelJ depends on boob size
14:18:31 <c089> mwhit: sorry about that ;)
14:18:34 <ColonelJ> Swizec: true
14:18:42 <Swizec> c089 I tried shadow boxing naked ... much floppiness ensued
14:18:54 <Fuuzetsu> #haskell-blah
14:18:55 <c089> Swizec: supposed to hit em with the HAND
14:19:10 <Swizec> c089 ooooooooooh
14:19:13 <pointed_set> rudi_s: build a wapper
14:19:17 <Swizec> I think I owe a few apologies ...
14:19:47 <rudi_s> pointed_set: How? I haven't written any tests in haskell before.
14:19:59 <c089> in case anyone offered to help me with that craft3e thing earlier: i am officially too dumb to scroll up in irssi without a PgUp key, please repeat
14:20:15 <rudi_s> c089: alt-p (and alt-n to scroll down)
14:20:18 <Fuuzetsu> I think you can scroll up with Alt + V?
14:20:31 <pointed_set> class ControlledEnviron env where getEnv :: env -> ...
14:20:36 <c089> rudi_s: alt-p gives me œÄ
14:20:40 <c089> which is a good thing to know I guess
14:21:03 <tulcod> in the FFI, is there a reason haskell doesn't type-check cross-languages? ie, that the C funciton I'm binding actually takes the arguments I'm telling it?
14:21:14 <rudi_s> c089: Weird terminal emulator ...
14:21:48 <c089> rudi_s: I'd guess OSX is the culprit before it even reaches the terminal
14:21:53 <rudi_s> pointed_set: And how would I use that? I'd like to just use my usual functions (f :: IO ()) and test the outcome, e.g. if they provide the right output.
14:22:04 <rudi_s> c089: Or that.
14:22:21 <c089> oh Fn-up/down works. (sorry about that, back to topic)
14:22:56 <BMeph_> tulcod: What should it do if one version of the C function does match, but the five other versions don't? ;√æ
14:23:01 <bhuemer> hi, I'm trying to get my head around conduits, in particular how I can fuse them (and as a result of that, how they're different from iteratees) .. for example, is it somehow possible to write a sink such that this will accept more values: CL.sourceList [1..4] $= CL.consume
14:23:11 <tulcod> BMeph_: ah. sure, i'll buy that argument :)
14:23:15 <tulcod> overloading
14:23:17 <tulcod> good enough
14:23:36 <tulcod> bah. darned C functions.
14:23:36 <bhuemer> to me it still seems that the source is in control of the sink's lifecycle
14:23:47 <BMeph_> tulcod: variadic functions and "void *" are hell on type checking.
14:24:18 <tulcod> BMeph_: sure, but in other cases it doesn't even attempt to say anything useful. but i guess you want to be consistent as well, so yeah
14:24:42 <pointed_set> in some "ControlledEnviron env => ReaderT env IO a" context you do call askEnv (askEnv = liftIO getEnv <$> ask) and you are on the horse
14:25:49 <bhuemer> as in, naively I would have hoped that "CL.sourceList [5..9] $$ CL.sourceList[1..4] $= CL.consume" produces [1..9], rather than [1..4]
14:26:36 <pointed_set> bhuemer: I seems to plug a source to a source
14:26:42 <pointed_set> * you seems
14:27:45 <rudi_s> pointed_set: Hm, I'm a little confused. This looks like I have to modify the original code to use askEnv which I then later can somehow "stub". Is there no direct way without modifying my working code?
14:27:56 <bhuemer> well, that might be part of the problem, maybe? but even if I use "=$", which I think produces a sink on the right hand side, it still has the same effect
14:28:25 <bhuemer> I might be mixing up these combinators now though
14:29:08 <pointed_set> rudi_s: You can hide it from import, and import another module with redefined version.
14:29:11 <bhuemer> I just want two sources to populate the sink, one after another
14:29:49 <bhuemer> and have the sink in control of its own resource (in this case there's none, but later I'd play around with sinkFile, etc.)
14:31:05 <pointed_set> rudi_s: Although, it looks horrible. I recommend not use the concrete environ, but an interface to get it.
14:31:13 <rudi_s> pointed_set: Hm. I'd like to just import my program/library and then run the tests with a modified getEnv. I don't know how I can hide anything at that time, as my lib/program already uses the default getEnv.
14:31:38 <rudi_s> Interface? I thought getEnv is there to get values from the environment.
14:33:29 <pointed_set> You want two envs: real and test stub. They have the same signature. You don't want to depend on them, so you make an interface.
14:33:56 <pointed_set> Also, what kind of code uses the output of getEnv?
14:34:06 <pointed_set> Pure or some IO-mess?
14:34:18 <rudi_s> pointed_set: IO-"mess"
14:34:40 <pointed_set> Could it be cleansed of IO to some extent?
14:35:02 <rudi_s> pointed_set: Hm, I guess I have to rethink the way of testing this code.
14:35:42 <rudi_s> Not really, it's kind of a high level test of the program itself. But I think I can just call the binary itself with a matching environment. Then I don't have to modify any code.
14:36:41 <pointed_set> I'd recommend to rework into pure code, its much more easy to test. Try to look onto quickcheck
14:37:28 <rudi_s> pointed_set: Yeah, normally I'd do that. But in this case it's not possible, as the program itself calls other programs which needs IO.
14:39:39 <pointed_set> Sometimes I dream about "controlled IO" which could be plugged into an "IO a" object to run it
14:43:19 <pointed_set> Did anybody tested if "timeout" function works under Windows in 7.8? I tried it in some work project in 7.6 and I had to redo everything because it get stuck on syscalls every time
14:45:01 <Abathurr> damnit
14:45:41 <dmj`> pointed_set: I don't think it works
14:46:28 <dmj`> pointed_set: well I don't think network I/O is interruptible even when the timeout expires
14:46:31 <dmj`> under windows
14:46:58 <nitrix> Is Integer bounded or truly infinite?
14:47:10 <dmj`> nitrix: memory bounded
14:47:21 <dmj`> Int is arch. dependent
14:47:30 <nitrix> And Int would be `word` bound, on the architechture.
14:47:38 <tulcod> dmj`: but at least a signed 32 bit int right?
14:47:44 <NemesisD`> is there any way to use typeable to get the type name of an argument without actually getting a value?
14:47:44 <nitrix> Interesting.
14:48:02 <dmj`> > maxBound :: Int
14:48:04 <lambdabot>  9223372036854775807
14:48:06 <dmj`> > maxBound :: Integer
14:48:08 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
14:48:08 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.maxBound‚Äô
14:48:12 <dmj`> ah :)
14:48:18 <bb010g> How do you import locally inside a package? If I'm working on a module Control.Foo at src/Control/Foo.hs and have import Data.Bar (src/Data/Bar.hs), shouldn't it grab if I do a :l src/Control/Foo.hs in GHCi? Do I need to manually load and import the required module in GHCi?
14:48:25 <nitrix> I've never seen a language offer bitsets as an opaque type.
14:48:26 <NemesisD`> i guess i could have a Typeable a, aname = tyConName . typeOf $ undefined
14:48:28 <nitrix> This is promising.
14:48:37 <NemesisD`> is this a bad idea?
14:55:34 <tulcod> NemesisD`: i think that's a common trick
14:55:52 <tulcod> i mean, i've seen it in other kinds of type related libraries, anyway
14:57:04 <tulcod> nitrix: in haskell, a bitfield is implemented by e.g. Data.Flags - https://hackage.haskell.org/package/data-flags-0.0.3.1/docs/Data-Flags.html
14:57:53 <nitrix> tulcod: Right, but Integer is essentially that as well.
14:58:02 <nitrix> tulcod: From what I understand.
14:58:13 <tulcod> nitrix: haskellers would say that Integers have nothing to do with bitfields :)
14:58:33 <nitrix> It's the only thing I know that resembles it :(
14:59:02 <nitrix> mpz_t maybe? of the GNU MP library?
14:59:02 <tulcod> nitrix: "what do numerical values have to do with a list of on and off switches"?
15:00:00 <nitrix> Anyway, I'll just assume that it's magical and incredibly useful.
15:00:30 <tulcod> nitrix: in practice, most code avoids Integer - Int suffices, and if it doesn't, you probably don't really want to execute it anyway
15:00:35 <nitrix> Does Int somehow overflow into Integer if they become too large?
15:00:39 <tulcod> no
15:01:01 <triliyn> Integer uses a machine word representation for things that fit it though
15:01:09 <nitrix> I see.
15:01:11 <triliyn> And overflows into its larger form
15:01:26 <nitrix> So Integer isn't that much overhead.
15:01:30 <triliyn> (But because this means integer has two constructors, it's still not quite as good as Int if you need it)
15:01:36 <triliyn> Well, it's another pointer in the way
15:01:43 <nitrix> I see.
15:01:44 <triliyn> And it can't be unboxed I think
15:01:57 <triliyn> But it's not as much overhead as always using a GMP-like structure
15:02:08 <nitrix> Good to know; I know I shouldn't bother too much, I was just curious.
15:02:34 <nitrix> I'm learning typeclasses now :)
15:03:06 <triliyn> (Actually I guess it's not really another pointer over Int unless you're writing your code such that the Ints are unboxed. But there is a bit of bounds checking I think?)
15:03:40 <nitrix> Typeclasses would be applying type constraints on parametric polymorphism?
15:04:12 <triliyn> A bit like that
15:04:43 <triliyn> They are also kind of like interfaces in OO (the main difference being that typeclasses can never be used as the type of a value)
15:05:13 <nitrix> So they are meant to be used with type variables then?
15:05:17 <nitrix> Like always?
15:05:44 <mwhit> not sure what "used with type variables" means exactly, but a class declaration will always have at least one type variable, yes
15:05:50 <ColonelJ> nitrix how long have you been doing haskell?
15:05:58 <nitrix> ColonelJ: 3~6 hours
15:06:12 <mwhit> as will a typeclass constraint
15:06:14 <ColonelJ> lol you're gonna be like a pro in a few days and then in a week you'll be better than everyone in here
15:06:35 <tulcod> nitrix: oh, if you do, could you go ahead and make Functor a superclass of Monad?
15:06:37 <nitrix> ColonelJ: I really want to get it right, I'm sorry x]
15:08:17 <nitrix> ColonelJ: I'll be wrong a hundred times too, since I lack a lot of the mathematical knowledge that would help me grasp the technical matters more quickly.
15:08:54 <tulcod> nitrix: nah, the maths is quite far removed from the actual programs
15:09:03 <tulcod> nitrix: seeing the link is an area of science in itself
15:09:16 <tulcod> in a way, that's what functional programming language development is all about
15:09:17 <nitrix> ColonelJ: Just earlier, list comprehensions for example.
15:09:28 <ColonelJ> nitrix: like the only maths you really need is type theory, and not very deep neither
15:09:39 <nitrix> That's reassuring.
15:09:42 <ColonelJ> and I guess algorithms for writing actual programs, but that's no different from any other language
15:10:10 <nitrix> I suppose an adaptation period, since I've used imperative/declarative languages all my life.
15:10:24 <jxm> ColonelJ, I was told the same but I am not so sure now
15:10:29 <nitrix> This feels like learning programmation again, it's so fun.
15:10:33 <tulcod> nitrix: it gets much better after you get over that
15:10:43 <nitrix> :)
15:10:45 <tulcod> like. a LOT
15:10:45 <jxm> I mean, yeah, to get the feel for monoids and monads, great
15:11:14 <jxm> Monoid once explained makes sense, monads on top of it, yeah sure
15:11:36 <jxm> But then you try to understand monadic composition with mixed types
15:11:51 <jxm> And _then_ I see no way out than category theory
15:12:14 <ColonelJ> ok I guess I'm not an expert, I wasn't sure how much category was really needed
15:12:22 <jxm> Neither am I
15:12:29 <jxm> Maybe I am wrong
15:12:43 <tulcod> you can do many great things without knowing what a category is.
15:12:43 <ColonelJ> I didn't really think haskell went beyond monads, which are just a corner
15:13:15 <jxm> Just that the simple  f :: a-> a  g :: a ->  and then f >>= g  makes sense
15:13:47 <bb010g> ColonelJ: What branch of math do you specialize in?
15:14:15 <jxm> But if f :: a -> Mb and g :: b -> Mc, with h :: a -> Mc = f >> g, this gets hard to reason about clearly
15:14:16 <bb010g> ColonelJ: Also, if you want to see category theory, hang around #haskell-lens. :)
15:14:23 <tulcod> #haskell. where everyone specializes in an area of math.
15:14:27 <ColonelJ> bb010g I guess I'd say type theory but I still I have a lot to learn
15:15:03 <Fuuzetsu> ##categorytheory
15:15:04 <ColonelJ> I'm not really doing maths any more as an occupation
15:15:14 <Fuuzetsu> remember that speaking in ##categorytheory is a severe violation
15:15:17 <beaky> hello
15:15:22 <ColonelJ> most of my work is just optimizing shit for weird DSP platforms
15:15:28 <tulcod> bb010g: i have the feeling lenses are to haskell as topoi are to logicians
15:15:31 <beaky> how do i learn how to write good haskell
15:15:40 <beaky> rather than bad haskell that will confuse me after 6 months
15:15:43 <tulcod> beaky: step 1. write a bunch of haskell
15:16:12 <ColonelJ> beaky: I would say the best thing is to break things down into tiny functions that do very simple things that you couldn't possibly not understand
15:16:31 <ColonelJ> and always keep hold of your old code so you can go back to it
15:16:32 <bb010g> tulcod: A quick look at topoi on Wikipedia makes me want to say yes, but I'm a bit unsure.
15:17:03 <Lowl3v3l> beaky well there are, like in any programming languages, 3 things to do. first : code much. second : read much code. third : learn maths and computer science. Seriously, i teach a little programming and a lot of code would be better if people knew basic computer science
15:17:04 <beaky> when i read others code they are usually big functions with nested do's and 20 where declarations
15:17:23 <bb010g> Fuuzetsu: "remember that speaking in ##categorytheory is a severe violation" What?
15:17:35 <_1_shahzad> hello
15:17:38 <ColonelJ> Lowl3v3l: I don't think anything you said actually answered his question.  Surely you'd be far better off writing code and letting others review it
15:17:39 <Iceland_jack> bb010g: Probably a joke
15:17:45 <Fuuzetsu> it is
15:18:05 <_1_shahzad> hello every oq
15:18:29 <Lowl3v3l> ColonelJ, well writing code was one of my suggestions
15:18:49 <ColonelJ> the act of just writing code doesn't make your code any better, it's an open loop
15:19:05 <_1_shahzad> hello
15:19:12 <Iceland_jack> hello _1_shahzad
15:19:14 <ColonelJ> even reviewing a little of your own code every few weeks from a few weeks ago would be better than writing loads of code
15:19:29 <_1_shahzad> ice land thanks
15:19:37 <bb010g> beaky: Try to go through the Typeclassopedia. You probably won't get all of it the first time, but look at it from time to time afterwards and see if you get more. Polymorphism is generally a "good thing" in Haskell code.
15:19:38 <_1_shahzad> whats up
15:19:56 <_1_shahzad> howa are u
15:20:29 <ColonelJ> arguably you're better off writing less code that does more and can be reused, so it forces you to reread it occasionally and improve it
15:21:05 <bb010g> If you find yourself writing monolithic sections of code, rethink what you're doing.
15:21:14 <tulcod> bb010g: topoi are, simply put, very well-behaved rich categories. it's a relatively simple definition for a very rich category, but the proofs are... a way of life
15:21:28 <ColonelJ> however being careful that you don't end up squashing code for the sake of it since that makes it a lot harder to understand
15:22:26 <ColonelJ> eh I'm gonna duck out before I end up saying any more useless crap
15:22:29 <pyon> Is it possible to efficiently implement the "Data.List.inits" function using only the concepts from the bananas, lenses, etc. paper? (catamorphisms, anamorphisms, hylomorphisms, etc.)
15:23:25 <pyon> It is "inits xs = [] : next xs where { next [] = [] ; next (x:xs) = map (x:) inits xs }", by the way.
15:23:36 <bb010g> pyon: You might want to ask that on #haskell-lens
15:24:01 <pyon> bb010g: I am not talking about those lenses.
15:24:01 <pjdelport> bb010g: Different kind of lens, i think. :)
15:25:34 <c_wraith> pyon: well, how strictly do you define "only"?
15:25:49 <mwhit> any function on a list can be implemented as a fold, i believe
15:26:51 <beaky> accountsLevels = takeWhile (not . null) . iterate (concatMap asubs) . (:[])
15:26:55 <beaky> how does that line work
15:27:31 <pyon> c_wraith: No recursive functions besides catamorphisms, anamorphisms, etc.
15:27:46 <pyon> (Or functions built from them.)
15:28:00 <c_wraith> pyon: it's certainly possible, then.
15:31:15 <c_wraith> pyon: you *could* express it as some combination of foldrs, and foldr is cata.  (there are probably better ways)
15:32:26 <pjdelport> beaky: (:[]) wraps a single value in a one-element list, and then iterate (concatMap asubs) keeps repeatedly "substituting" each element with the result of some function asubs :: a -> [a], returning a list of each substitution in turn.
15:32:57 <pjdelport> beaky: And then takeWhile (not . null) until the process exhausts itself and becomes empty.
15:33:13 <NemesisD`> i've got a simple [(a, b)] map and [a], isn't there a way to use the Maybe monad to map through the keys and stop at the first Just?
15:34:10 <tulcod> NemesisD`: something with  head . catMaybes  ?
15:34:32 <beaky> pjdelport: so all it does is group all the possible asubs generated from an element?
15:34:59 <pjdelport> beaky: I'm not sure about grouping; it depends what exactly asubs does.
15:35:19 <pjdelport> beaky: It performs some sort of search, presumably?
15:35:47 <beaky> https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Data/Types.hs#L220 heres asubs
15:36:08 <NemesisD`> i think i want msum . map (flip lookup myMap)
15:36:32 <pjdelport> beaky: Ah, that makes sense. That means it starts with a root account, than gives you a list of all sub-accounts at each level.
15:37:06 <beaky> oh
15:37:23 <beaky> isnt there a general function for doing that, like in data.tree or something
15:37:33 <pjdelport> beaky: So the the result list might look something like [[root],[sub1,sub2],[subsub1,subsub2,subsub3],[subsubsub1]]
15:41:22 <vanila> pyon,
15:41:23 <vanila> > foldr (\x ys ->  map (x:) ([] : ys)) [] "foobar"
15:41:25 <lambdabot>  ["f","fo","foo","foob","fooba","foobar"]
15:41:42 <pyon> vanila: Ah, nice, thanks!
15:41:48 <beaky> @hoogle [a] -> [[a]]
15:41:50 <lambdabot> Data.List inits :: [a] -> [[a]]
15:41:51 <lambdabot> Data.List permutations :: [a] -> [[a]]
15:41:51 <lambdabot> Data.List subsequences :: [a] -> [[a]]
15:42:13 <beaky> @hoogle Tree a -> [[a]]
15:42:14 <lambdabot> Data.Tree levels :: Tree a -> [[a]]
15:42:14 <lambdabot> Data.Tree flatten :: Tree a -> [a]
15:42:14 <lambdabot> Data.Graph.Inductive.Basic postorder :: Tree a -> [a]
15:42:22 <beaky> there we go
15:43:00 <beaky> i love trees
15:43:26 <beaky> @src Data.Tree.levels
15:43:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:43:33 <beaky> whats a rutabaga
15:43:50 <Iceland_jack> @google rutabaga
15:43:51 <lambdabot> http://en.wikipedia.org/wiki/Rutabaga
15:43:51 <lambdabot> Title: Rutabaga - Wikipedia, the free encyclopedia
15:44:29 <beaky> is it just me or are trees just glorified pairs of element and list
15:44:47 <vanila> it's not just (a,[a])
15:44:54 <vanila> but recursively,  T a = (a, [T a])
15:44:59 <beaky> oh
15:45:10 <beaky> right
15:46:17 <beaky> and the [T a] bit is called a forest?
15:47:30 <roboguy_> I think it's also the same as Free (Compose (,) [])  (if you have leaves, at least)
15:47:43 <roboguy_> oh wait, never mind that doesn't owrk
15:47:45 <roboguy_> *work
15:48:25 <beaky> how do i turn a list into a tree
15:48:46 <heatsink> It depends on what shape you want.
15:49:21 <vanila> Hi
15:49:29 <vanila> would anyone be able to help me with cabal install tf-random please
15:49:30 <heatsink> Actually, when you specify what shape you want, you can probably use that as your algorithm.
15:49:42 <heatsink> What happens when you try to install it?
15:49:46 <vanila> http://pastebin.com/raw.php?i=KHYpXZPb
15:49:52 <vanila> I don't understand this error
15:50:31 <vanila> should I installed tf-random manually?
15:50:42 <tulcod> vanila: did you force anything?
15:50:49 <vanila> I din't use forche
15:50:51 <vanila> force*
15:51:06 <vanila> just cabal install tf-random
15:51:09 <vanila> sorry
15:51:09 <tulcod> vanila: ever?
15:51:28 <vanila> not to my knowledge
15:51:35 <vanila> i don't know about the force command, so I doubt I used it
15:52:36 <tulcod> vanila: builds&install fine here. try removing ~/.ghc and try again
15:57:53 <vanila> I deleted ~/.ghc and I got the same error
15:57:57 <mgsloan> roboguy_: type Tree a = Free (Compose ((,) Int) []) Int
15:58:00 <vanila> setup-Simple-Cabal-1.18.1.3-x86_64-linux-ghc-7.8.3: The program alex version
15:58:00 <vanila> >=2.3 is required but it could not be found.
15:58:00 <mgsloan> yargh
15:58:08 <mgsloan> roboguy_: type Tree a = Free (Compose ((,) a) []) a  -- This does work
15:58:15 <roboguy_> mgsloan: ahh, that makes sense
15:58:37 <tulcod> vanila: that's a different error
15:58:42 <tulcod> vanila: cabal install alex
15:58:50 * mgsloan just spent some time playing with it, since he's never actually used Free or Compose
15:58:56 <vanila> installing alex gives me the errors about tf-random
15:58:58 <tulcod> vanila: cabal doesn't support build-time dependencies atm, so it just errors at build time
15:59:24 <benzrf> mgsloan: that seems slightly wrong for a tree...
15:59:28 <roboguy_> mgsloan: that would probably be slightly different because it has leaves, but it would be pretty similar
15:59:29 <benzrf> why use Free, why not just use Mu?
15:59:44 <roboguy_> benzrf: I was trying to make it with Free, but I didn't quite get it right
15:59:46 <tulcod> vanila: is /tmp in tmpfs? do you have enough memory?
15:59:54 <mgsloan> benzrf: Oh, yeah, I'm not saying this is a good idea
16:00:09 <roboguy_> yeah, I'm not totally sure if you can make it with Free
16:00:11 <benzrf> roboguy_: im pretty sure that Free is almost Mu but with a base case39
16:00:12 <tulcod> vanila: https://github.com/haskell/cabal/issues/1883
16:00:14 <benzrf> *case
16:00:16 <vanila> Iv'e downloaded tf-random
16:00:21 <benzrf> hence leaves
16:00:49 <roboguy_> benzrf: yeah
16:00:54 <mgsloan> One issue with this definition is that fmap is broken.  It'll only touch the leaves
16:01:28 <vanila> @google finiteBitSize
16:01:29 <lambdabot> https://hackage.haskell.org/package/largeword-1.2.3/docs/src/Data-LargeWord.html
16:01:32 <benzrf> @src Free
16:01:33 <lambdabot> Source not found. Do you think like you type?
16:01:39 <vanila> @hoogle bitSizeMaybe
16:01:40 <lambdabot> No results found
16:01:44 <benzrf> l8r
16:02:05 <vanila> Why is ghc teling me to use bitSizeMaybe
16:02:07 <vanila> but it doesn't exist?
16:02:09 <roboguy_> mgsloan: are you sure?
16:02:16 <roboguy_> it has to change all the as to bs
16:02:16 <mgsloan> If you don't need values on the branches, type Tree = Free []
16:02:42 <mgsloan> roboguy_: But that's a type synonym, it only changes the outer 'a', and a is used twice
16:03:11 <vanila>   | (case bitSizeMaybe n of m -> n > 64 ; _ -> False) = error "mkTFGen: case where size of Int > 64 not implemented"
16:03:13 <vanila> I patched tf-random this way
16:03:22 <vanila> so that it doesn't give me warnings about deprecated functions
16:03:43 <mgsloan> roboguy_: fmap (+1) (Compose (1, [2]) == Compose (1,[3])
16:03:45 <vanila> tf-random-0.5 failed during the final install step. The exception was:
16:03:46 <vanila> sequence)
16:03:49 <vanila> but it still gives this error
16:04:48 <vanila> any ideas? :(
16:05:27 <vanila> /tmp/pkgConf-tf-random-030503.5: hGetContents: invalid argument (invalid byte
16:05:50 <tulcod> vanila: see the bug. it's a bug (fixed a few days ago).
16:07:53 <roboguy_> :t Compose (1, [2])
16:07:54 <lambdabot> Not in scope: data constructor ‚ÄòCompose‚Äô
16:09:02 <vanila> So what do I do to fix this?
16:09:14 <vanila> I just did cabal install cabal, and the problem remains
16:10:08 <tulcod> vanila: "export LANG=en_US.UTF-8"
16:10:16 <vanila> I removed the silly l: ≈Ç
16:10:26 <vanila> now its intsalling
16:10:45 <vanila> but it breaks here: /tmp/pkgConf-QuickCheck-2.732121.6: hGetContents: invalid argument (invalid
16:11:05 <vanila> export LANG=en_US.UTF-8 didn't solve it either
16:12:30 <vanila> I'm deleting the √∂ in bj√∂rn
16:13:06 <tulcod> vanila: could you pastebin your env?
16:14:07 <solidus-river> i dont understand why this is a type error
16:14:09 <solidus-river> http://lpaste.net/108725
16:14:22 <solidus-river> it is pretty much a straight copy of https://github.com/ocharles/ocharles.org.uk--Getting-Started-with-Netwire-and-SDL/blob/master/Challenge2.hs
16:16:59 <solidus-river> did arrow compositionchange how it works?
16:17:01 <tulcod> vanila: could you type "env" and paste that into some pastebin?
16:17:10 <roboguy_> solidus-river: how so?
16:17:20 <solidus-river> roboguy_: er i mean within netwire
16:17:25 <vanila> no
16:17:36 <solidus-river> i wrote a function which is pretty much the exact same thing as ocharles example 3 for velocity of a cube
16:17:39 <solidus-river> and i'm getting a type error
16:17:47 <solidus-river> and it looks like the type error has to do wtih composition of wires
16:17:59 <solidus-river> composigin an when wire with a pure is resulting in the type of the when wire
16:18:36 <solidus-river> when (member G.Key'Left) is makin ga wire of s e m (Set G.Key) (Set G.Key)
16:18:43 <solidus-river> but i'm composing it iwth pure (-2)
16:18:54 <solidus-river> which should compose to a wire of s e m (Set G.Key) Double
16:18:58 <solidus-river> but that is not what the result is
16:19:29 <solidus-river> its resovig to type a0 -> Integer
16:19:33 <solidus-river> which has nothing to do with wires whatsoever
16:19:36 <solidus-river> :|
16:23:55 <solidus-river> ah it was my imports
16:24:08 <solidus-river> i needed netwires version of function composition
16:35:54 * hackagebot purescript 0.5.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.4 (PhilFreeman)
16:35:56 * hackagebot hactor 0.1.0.0 - Lightweight Erlang-style actors for Haskell.  http://hackage.haskell.org/package/hactor-0.1.0.0 (Forkk)
16:36:39 <solidus-river> is it always safe to use libraries versions of prelude functions, or is there something that does sanity checks on versions not from prelude?
16:36:53 <solidus-river> or is that mostly depending on the lib writer being carefull
16:37:30 <the193rd> Good evening my haskellfriends
16:38:57 <Iceland_jack> evening
16:40:58 <benzrf> good evenining
16:41:04 <fizbin> General "what is more readable/idiomatic" opinion question:
16:41:09 <benzrf> fizbin: oh boy!
16:41:47 <fizbin> First way of writing: if expression1 && expression2 then [long expression here] else []
16:42:09 <fizbin> Second way of writing: [long expression here | expression1 && expression2]
16:42:53 <fizbin> hlint is telling me to rewrite as the second way around, and that just seems wrong.
16:43:06 <benzrf> fizbin: in what kind of scenario would you want either an empty list or a 1-elem one?
16:43:06 <hpc> fizbin: use Maybe
16:43:16 <benzrf> hpc: u beat me :[
16:43:21 <roboguy_> fizbin: I like both personally, depending on what specifically the context is
16:43:41 <fizbin> I'm going to then be concatenating it to something that is a list of multiple things.
16:43:55 <benzrf> fizbin: i think you might prefer cons
16:44:19 <roboguy_> fizbin: the second one is kinda popular for that, especially if you would otherwise have a big chain of if-then-elses
16:44:29 <benzrf> fizbin: also, y not just use Maybe, then catMaybes
16:44:45 <benzrf> fizbin:
16:44:49 <benzrf> let v = long expr
16:44:55 <fizbin> benzrf: Not getting how I'd use catMaybes here.
16:45:04 <benzrf> in  if exp1 && exp2 then Just v else Nothing
16:45:20 <benzrf> fizbin: well, i assume you are producing a bunch of either [] or [item]
16:45:22 <benzrf> then concatting?
16:46:08 <fizbin> I'm producing two things of either [item] or [] and then I'm doing thingA ++ map someOtherFunc LongerList ++ thingB
16:46:24 <benzrf> fizbin: ah
16:46:55 <benzrf> fizbin: this whole setup seems slightly suspect....
16:47:24 <benzrf> fizbin: how experienced in haskell are you?
16:48:16 <fizbin> benzrf: I'm not sure how to answer that. I've submitted pull requests to lens, if that's a meaningful measure.
16:48:26 <benzrf> haha
16:48:33 <benzrf> alright nvm then, i trust your judgement
16:48:44 <benzrf> p-probably
16:48:54 <fizbin> Well, one.
16:49:00 <fizbin> About arrows.
16:49:11 <fizbin> (and Arrow-lens interaction)
16:49:14 * benzrf doesnt know arrows
16:49:28 <benzrf> nobody seems to like them so i never learned them
16:50:29 <athan> Hey yall, has anyone here had experience with Alex? I'm trying to make a css parser, and I think that whitespace is being parsed & tossed away at the lexing stage (I've got a $white+ pragma in my .x file). How much fun should I expect to have with making whitespace non-optional for certain tokens? (like .class selectors or #id, for instance)
16:50:54 <benzrf> fizbin: in my "Expert Opinion", hlint's version looks cleaner
16:50:56 <benzrf> if a bit more obtuse
16:51:20 <dibblego> the code (:[]) is repeated on both sides of the then/else branch
16:51:21 * benzrf always forgets that list comps exist
16:51:46 <benzrf> i, for one, would pull out the long expr into a let or something
16:51:49 <fizbin> Hrm; I do have a nasty if-else chain here, and I need to clean that up.
16:52:01 <benzrf> at least, if you're doing the thing with the if
16:52:09 <fizbin> dibblego: How so? (:[]) isn't repeated on the "else" side.
16:52:34 <dibblego> sorry, I don't mean that
16:52:35 <benzrf> dibblego: theres no cons on the rhs
16:52:44 <dibblego> if p then (x:[]) else id []
16:52:56 <dibblego> (if p then (x:) else id) []
16:53:41 <Iceland_jack> [ x | p ] ?
16:53:50 <Iceland_jack> > [ 5 | False ]
16:53:52 <lambdabot>  []
16:53:56 <dibblego> yes that is hlint's answer
16:56:39 <fizbin> Yeah, it does look cleaner after I pull everything out into a single let and not have that in the middle of the if-else chain.
16:57:07 <benzrf> dibblego: i was thinkin that
16:57:18 <benzrf> fizbin: whats the context of this anyway
16:57:24 <benzrf> why are you sticking things to either side of a list
17:00:56 * hackagebot hopenpgp-tools 0.8 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.8 (ClintAdams)
17:01:08 <fizbin> I'm turning a certain kind of graph (as in a Data.Graph.Inductive.Graph DynGraph with a certain kind of edge decoration) into an array of binary structures based on the graph's edges. Some of the edge kinds get summarized into a single binary structure instead of one structure per edge. The summarized edges need to go first.
17:01:56 <rudi_s> Hi. I want to escape a character in a string (i.e. "$" -> "\\$"). My current solution is concatMap f wheren f '$' = "\\$" ; f x = [x] - is there a better way?
17:02:45 <fizbin> I take the output of this function and Data.ByteString.Lazy.concatMap over it to get the total binary blob.
17:03:20 <joelteon> rudi_s, I think performance might be better if you manually write a recursive function
17:03:42 <joelteon> escape ('$' : xs) = '\\' : '$' : escape xs; escape xs = xs
17:04:23 <fizbin> rudi_s: So if performance is your goal, I think it'll be better if you have some way to avoid consing when there's nothing changed.
17:04:46 <fizbin> joelteon: That won't work. Consider what (escape "a$b") evaluates to.
17:05:04 <athan> Wow... I just saw some guy here at the computer lab stretch his eyelids... I've never seen anyone get that bad...
17:05:11 <joelteon> whoops
17:05:14 <joelteon> i did it wrong
17:05:24 <rudi_s> Thanks. Performance isn't really a major issue in my case. I was more looking for a nice and simple solution.
17:05:33 <glguy_> > foldr (\x -> if x == '$' then cons '\\' . cons '$' else cons x) [] "test$it"
17:05:35 <lambdabot>  "test\\$it"
17:06:01 <zomg> athan: I often get tired and can't sleep, it especially feels in the eyes :P
17:06:24 <fizbin> rudi_s: Then what you have is fine and plenty readable.
17:06:42 <athan> zomg: He looks decrepid, I want to get him a coffee or something
17:06:57 <rudi_s> fizbin: Thanks.
17:07:13 <zomg> athan: yeah probably not healthy if it's that bad...
17:07:20 <rudi_s> glguy_: What does cons do? Can't seem to find it in Prelude.
17:07:28 <joelteon> it's (:)
17:08:12 <rudi_s> Ah, thanks. Is there a reason to write cons instead of : or is that a lambdabot thing?
17:08:30 <athan> zomg: Who needs health, anyway? WE ARE PROGRAMMERS
17:08:41 <glguy_> I just like cons x better than (x:), it's from the lens library
17:09:04 <glguy_> You don't need to write it like that, I was just writing joelteon's function with foldr
17:09:39 <rudi_s> glguy_: Ah, that's good to know. Thanks. I've never used lens (nor do I know what exactly it is), still figuring out the haskell basics.
17:09:57 <RPR> Ok, I should have install ghc-mod along time ago.  Sweet.
17:11:03 <trap_exit> https://gist.github.com/anonymous/0021416aac282d394ec7 <-- how do I make this error go away? I don't like odd-lengthed lsits
17:11:09 <trap_exit> so the function is defined only for even-length strings
17:11:12 <trap_exit> and doesn't like odd-length strings
17:11:17 <trap_exit> but my compiler is complaining to me
17:12:11 <lfairy> trap_exit: look carefully at your declaration
17:12:17 <lfairy> very carefully
17:12:40 <trap_exit> 0-length list, 1-length list, >= 2-length list
17:12:54 <triliyn> trap_exit: it's gne_list in the second function head
17:13:17 <trap_exit> i'm retarded
17:13:17 <trap_exit> thanks
17:19:24 <solidus-river> did returnA get replaces by something, I'm using the language pragma Arrows but i'm getting a waringin about returnA not being in scope
17:19:43 <ab9rf> heh
17:19:46 <zerosNones> can anyone point out some enterpise size web apps built on Haskell/?
17:19:46 <glguy_> ?index returnA
17:19:46 <lambdabot> Control.Arrow
17:20:00 <pavonia> @help index
17:20:01 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
17:20:15 <pavonia> Is that a new plugin?
17:20:22 <fizbin> solidus-river: Did you import Control.Arrow ?
17:20:32 <glguy_> No, it's ancient
17:20:55 <solidus-river> fizbin: nope :)
17:22:11 <HeladoDeBrownie> zerosNones, Yesod's home page probably has examples of things built with it, if I recall
17:22:14 <HeladoDeBrownie> @google yesod
17:22:15 <lambdabot> http://www.yesodweb.com/
17:22:15 <lambdabot> Title: Yesod Web Framework for Haskell
17:22:28 <zerosNones> sweet thanks HeladoDeBrownie
17:23:57 <HeladoDeBrownie> zerosNones, hmm, it seems not, although I've only got a lousy web browser available right now. Perhaps "things built with Yesod" is a suitable jumping off point for your search though
17:24:19 <solidus-river> is monad fix hard to grasp?
17:24:24 <zerosNones> Going through it now HeladoDeBrownie thanks for the link
17:24:58 <solidus-river> or whats the best start doc for trying to get it
17:25:10 <MP2E> @src fix
17:25:11 <lambdabot> fix f = let x = f x in x
17:25:33 <fizbin> solidus-river: I didn't think it was too hard to grasp, but gathering lots of examples of its use helps.
17:25:46 <MP2E> Here's some better reading on fix and its uses : http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
17:26:06 <roboguy_> solidus-river: do you understand the regular fix already?
17:26:33 <solidus-river> roboguy_: a little but i'm no master of it
17:26:45 <solidus-river> hazily
17:26:58 <solidus-river> i read up on it then read up on bottom and definedness and thoguht i got it and stopped
17:27:04 <solidus-river> now i need to pick back up from there
17:27:26 <joelteon> instead of writing "my_fun a b c = ...", you write "fix (\ my_fun a b c -> ...)"
17:27:29 <joelteon> that's about it
17:28:16 <ab9rf> fix confuses me even when i'm sober
17:28:44 <fizbin> solidus-river: I found it helpful to write a bunch of standard "laziness is cool" haskell samples using "fix" as a way to get to understand "fix".
17:29:41 <solidus-river> this looks like a job for a beer, ghci, and those articles
17:29:54 <fizbin> > take 100 $ fix ((1:) . map (2*))
17:29:56 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
17:30:05 <kristof> Haskell is the only language I'm aware of whose users will shamelessly throw a "fix" in their code
17:30:05 <roboguy_> I thought I had a good example, but I'm not sure if you can rewrite it as MonadFix
17:30:12 <roboguy_> or mfix I should say
17:30:45 <benzrf> :t mfix
17:30:47 <lambdabot> MonadFix m => (a -> m a) -> m a
17:30:55 <benzrf> > fix(scanl(+)0.(1:))
17:30:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:31:01 <roboguy_> this is what I was thinking: http://lpaste.net/108726
17:31:28 <roboguy_> probably a bad name for it, though
17:32:49 <kristof> Ugh, gross
17:33:21 <roboguy_> kristof: not your style?
17:34:19 <roboguy_> that pattern match can never fail, by the way
17:34:45 <fizbin> roboguy_: I'd generalize the type. Can't you change the type signature to: generalFold :: (a -> Either b a) -> a -> b ?
17:35:04 <kristof> roboguy_: There are nicer ways of defining recursive functions.
17:35:33 <roboguy_> kristof: yeah, but I thought it was an interesting exercise
17:35:36 <kristof> And if the point of fix as a function is not to produce recursive functions, then someone please explain me what is
17:35:45 <athan> Like with bananas!
17:35:51 <benzrf> g2g quite soon
17:35:58 * hackagebot yesod-markdown 0.9.1 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.9.1 (PatrickBrisbin)
17:36:10 <kristof> roboguy_: What was? I wasn't here for whatever the discussion was. I just know that "fix" being a part of the core library of haskell shows precisely what its priorities are.
17:36:10 <benzrf> kristof: fix can also be used to pull values out of thin air
17:36:24 <benzrf> it has type `(a -> a) -> a', after al
17:36:25 <fizbin> kristof: The point of fix isn't recursive *functions*, it's (usually recursive) *values*.
17:36:25 <benzrf> *all
17:36:26 <roboguy_> kristof: oh, that lpaste thing I posted
17:36:31 <roboguy_> is what I was talking about
17:36:46 <roboguy_> fizbin: hmm, maybe
17:37:39 <roboguy_> fizbin: I wrote this a while ago, and I remember discussing whether or not you gain anything from a more general type signature. I can't remember what the agreement ended up being
17:37:53 <kristof> fizbin: But, see, I usually specify a value that needs to be constructed recursively by defining a function that calls itself. At least, that's what's natural to me.
17:38:35 <fizbin> kristof: Right, but recursive functions are then what you feed to "fix", not what you get out of it.
17:38:40 <fizbin> Well, sort of.
17:38:42 <roboguy_> kristof: there are some limited situations when fix can be relatively intuitive. But I can't think of any off the top of my head, haha
17:38:47 <benzrf> > (1:)
17:38:49 <lambdabot>  <[Integer] -> [Integer]>
17:38:50 <kristof> roboguy_: precisely :P
17:38:56 <benzrf> > fix (1:)
17:38:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:39:00 <benzrf> i never gave a list
17:39:04 <benzrf> and yet there's one!!!
17:39:11 <benzrf> will wonders never cease?
17:39:15 <roboguy_> kristof: a better (though, at first, even *less* intuitive) example might be loeb
17:39:25 <benzrf> :t loeb
17:39:26 <fizbin> @type let genFold fn init = case (fn init) of {Left a -> a; Right b -> genFold fn b} in genFold
17:39:26 <lambdabot> Not in scope: ‚Äòloeb‚Äô
17:39:27 <lambdabot> (t1 -> Either t t1) -> t1 -> t
17:39:39 <kristof> Bluhhh.
17:39:45 <kristof> Lovely.
17:39:49 <roboguy_> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
17:40:01 <roboguy_> it's basically like a spreadsheet DSL
17:40:14 <kristof> Fix is only useful in lazy languages, too.
17:40:17 <roboguy_> even though you wouldn't necessarily guess that the first time you see its type
17:40:30 <kristof> roboguy_: reading
17:40:35 <roboguy_> kristof: well... you can have laziness in strict languages
17:40:49 <kristof> roboguy_: Lazy data structures, then. Which I don't use all that often.
17:40:53 <fizbin> kristof: Or in languages with a lazy subset. It can be used in languages that require explicit laziness, like scala.
17:41:18 <roboguy_> this is a cool application of loeb: http://chrisdone.com/posts/twitter-problem-loeb
17:42:08 <roboguy_> not the most intuitive solution to the problem, but it's interesting to see that different way of looking at it
17:43:03 <kristof> roboguy_: Oh, that was cool
17:43:09 <kristof> But I still don't like fix. :P
17:43:28 <roboguy_> kristof: yeah, can't totally say I blame you haha
17:44:00 <kristof> roboguy_: Someone should make template haskell a standard part of GHC.
17:44:31 <kristof> Actually, no, never mind. I find template haskell terrifying, compared to rust's procedural macros.
17:44:32 <roboguy_> kristof: I've never actually written any template haskell code
17:44:40 <MP2E> me neither
17:44:41 <kristof> roboguy_: Have you written a lisp macro before?
17:44:46 <roboguy_> kristof: many times
17:44:51 <roboguy_> back in the day
17:44:51 <fizbin> I did, once. I went back and ripped it out.
17:44:55 <kristof> roboguy_: It's the same thing, but in a q monad. And stuff.
17:45:00 <fizbin> And swore never to do that stuff again.
17:45:00 <roboguy_> kristof: ahh, interesting
17:45:15 <roboguy_> I used to write *common lisp* macros too. that's right, the hard stuff
17:45:22 <roboguy_> no hygiene there
17:46:02 <ab9rf> common lisp is a painful language to work with
17:46:18 <kristof> lol
17:46:22 <fizbin> roboguy_: I actually always found CL-style macros much easier to get than that hygenic stuff scheme R5RS introduced.
17:46:36 <kristof> roboguy_: I wish syntax-case style macros were standard CL.
17:46:36 <ab9rf> it's probably been 20 years since i touched that pile of hazmat
17:46:49 <fizbin> I never managed to figure out WTF was going on with scheme's macro system.
17:47:03 <kristof> roboguy_: But, shamelessly, I wrote an anaphoric macro the other day that uses explicit variable capture and *I'm not ashamed*.
17:47:15 <kristof> ab9rf: What's painful about it?
17:47:20 <roboguy_> fizbin: it took me a while too, coming from CL, but I (sort of) figured it out eventually
17:47:25 <roboguy_> kristof: haha
17:47:41 <roboguy_> I don't think I've ever made an anaphoric macro
17:47:44 <kristof> Everytime I get dissatisfied with something I go back to CL and find myself comfortable.
17:47:54 <roboguy_> well, I did make a do-notation DSL in CL
17:48:15 <roboguy_> many years ago
17:48:18 <roboguy_> http://roboguy.net/monad.lisp
17:48:20 <kristof> ...One of these days, we'll have decent multithreaded concurrency libraries.
17:48:36 <ab9rf> kristof: i don't remember, i just know that thinking about CL makes me twitchy.  i admit i haven't odne a damn thing with CL since the late 80s.
17:49:13 <kristof> ab9rf: That was even before CL had OO components :o
17:49:23 <ab9rf> kristof: i'm not convinced that adding OO to CL would improve it
17:49:31 <kristof> It did
17:49:54 <vanila> ab9rf, it's not just OO, there actually have a very interesting well designed system
17:49:55 <roboguy_> ab9rf: CL already has OO
17:50:07 <ab9rf> roboguy_: it didn't when i learned it :)
17:50:22 <kristof> ab9rf: You've yet to describe what precisely you dislike about it but I'm not going to discredit your experience, which was probably as bad as you thought it was
17:50:51 <ab9rf> kristof: i don't remember the specifics anymore, it has been well over two decades and honestly i don't remember that well
17:51:10 <kristof> Okay :)
17:51:44 <ab9rf> kristof: it's entirely possible that i'd find it gloriously fun now
17:51:59 <kristof> Here's something I wish other languages had: generalized stream fusion. GHC just steamrolls everyone in that category.
17:52:05 <roboguy_> ab9rf: ahh, hah
17:52:11 <kristof> But that requires immutable-by-default.
17:53:31 <kristof> ab9rf: I'm usually just relieved every time I use it, not necessarily having fun. Oh, I need named and optional arguments? Sweet, CL has that. Oh, I need metaprogramming? Ok, CL has that. I want to "configure" certain functions without passing a reader monad manually everywhere? Okay, dynamic binding solves that.
17:54:04 <ab9rf> kristof: in some ways my recent work with haskell has been rediscovering how to program
17:54:05 <kristof> I need algebraic data types and really fast pattern matching? ...okay, gotta go back to Haskell. :P
17:54:18 <dfeuer> kristof: immutability is something I didn't appreciate properly until I learned a bit of Java, and recognized the pain of having to decide, and remember, whether any particular method should mutate things or not.
17:54:42 <kristof> ab9rf: Yeah? That sounds interesting, can you elaborate on that?
17:54:51 <ab9rf> kristof: having learned initially in the late 70s and trained in the late 80s
17:54:58 <kristof> Oh, that makes sense.
17:55:12 <glguy> ImplicitParams extension exists for people who think dynamic scope is a good idea
17:55:24 <ab9rf> kristof: i did open-source development (mainly in C) in the 90s and spent the 00s as a systems administrator doing very little development
17:55:45 <kristof> glguy: Yes, I'm aware. :) Most people don't think it is, though :'(
17:55:47 <fizbin> dfeuer: One of the things that makes the guava library for java so awesome is all the immutable data structures.
17:55:47 <dfeuer> kristof: if you want *really* fast pattern matching, you probably want ML. Apparently, it can do some seriously crazy pattern stuff that Haskell's laziness forbids.
17:56:08 <roboguy_> dfeuer: even with strictness annotations?
17:56:27 <kristof> dfeuer: Oh yeah? I didn't know that, I just assumed GHC was the fastest pattern matcher around, but I can see how laziness would defer some matching
17:56:31 <kristof> until a later time
17:56:57 <kristof> dfeuer: By ML do you mean OCaml or SML? I don't know what people use these days as a defacto ML.
17:57:11 <kristof> And if someone were to ask me what I wanted specifically from it, I would probably just say "whatever's better". :P
17:57:17 <dfeuer> roboguy_: I'm not sure. I read about that at some point. I think GHC may not even attempt some of the deep pattern analysis, but then what I read could be a bit old.
17:58:04 <roboguy_> dfeuer: ah
17:58:07 <kristof> ab9rf: So the concept of returning functions must have been really interesting, yeah?
17:58:18 <ab9rf> kristof: nah, i've worked with scheme
17:58:31 <kristof> ab9rf: Then it was the pattern matching and ADTs?
17:58:47 <ab9rf> kristof: and i used prolog in the 80s
17:59:17 <roboguy_> ab9rf: prolog is something that always looked a little tricky to me, with it's bidirectional unification
17:59:45 <ab9rf> roboguy_: i never really got good with prolog.
18:00:01 <k00mi> I remember reading a paper on implementing ADTs/pattern matching in C++ that included benchmarks of OCaml and Haskell
18:00:13 <mgaut72> hey all, I am trying to write out the ADT that corresponds to the following grammar: http://www.cs.arizona.edu/~debray/Teaching/CSc453/DOCS/cminusminusspec.html#lexical  what I have so far is here: http://pastebin.com/rxq1Lc22  I am struggling because I want to use the concrete type 'VariableDeclarations' in the data declaration for 'Function' and 'VoidFunction'
18:00:16 <kristof> Logic programming is too unpredictable for me. It's scary stuff :(
18:00:26 <k00mi> if I remember correctly OCaml was indeed faster
18:00:30 <roboguy_> kristof: yeah, that's the part that scares me too
18:00:30 <kristof> Graph reduction and loop fusion are the only kinds of magic I like :PPP
18:01:03 <kristof> Otherwise, I like to be able to peek into the generated assembly of a program and be able to intuitively see what's going on
18:01:26 <ab9rf> kristof: hah.
18:01:43 <ab9rf> with modern code that's a hopeless mess
18:01:48 <kristof> It's true! Sometimes you want to see that a loop is really just crunching and jumping
18:01:51 <dfeuer> kristof: not sure. I would guess probably both, but I don't know. In general, Haskell is more limited in how it can reorder patterns.  I don't remember what few details I did read.
18:02:01 <ab9rf> reminds me of looking at the C code generated by Chicken
18:02:10 <kristof> I've never had the pleasure :P
18:03:29 <kristof> C is fun! I like how closely it maps to assembly, no tricks.
18:03:36 <ab9rf> and with modern C compilers code gets strewn pretty far
18:03:48 <ab9rf> what with inlining optimizations
18:03:53 <kristof> Oh, yup
18:05:06 <ab9rf> one of the projects i work on sometimes involves reverse-engineering a game written in C++.  the mersenne twister randomizer (mt_random) is partially inlined all over the place in that code.
18:05:27 <kristof> :(
18:06:11 <ab9rf> you'll find a chunk of completely inexplicable integer arithmetic in the disassembly, which heralds a randomization.  recovering the actual original call is fairly tricky.
18:06:58 <dfeuer> ab9rf: Chicken's C-stack-as-nursery approach is pretty cool. I read on the Frege site that the Java it produces should not be viewed with unprotected eyes.
18:06:59 <ab9rf> especially if the mt_random result is subjected to further transformation; the compiler may optimize those transformations together and unthreading them is hard.
18:08:03 <dfeuer> ab9rf: why are you trying to reverse engineer this game?
18:09:34 <ab9rf> dfeuer: to make it better :)
18:10:06 <ab9rf> dfeuer: and, also, because we can.  why do you need a reason to reverse-engineer something?
18:10:54 <solidus-river> that wikidocs article on fix is great
18:11:20 <dfeuer> ab9rf: you need a reason because it looks like the sort of endeavor that is likely to have a low results-to-effort margin.
18:12:27 <ab9rf> dfeuer: i reject your premise
18:15:01 <dfeuer> ab9rf: because you're a really efficient reverse-engineer, or because you just really enjoy it?
18:15:14 <MP2E> ab9rf : I agree with you. I have a friend that reverse engineers for fun all the time, and I think he would say it is to his overall benefit
18:15:34 <ab9rf> dfeuer: well, i enjoy it although i'm not very efficient.  some of the other people who work on this are really quite good at reverse engineernig, though
18:15:54 <ab9rf> dfeuer: i think one of them does computer security for a living, reverse-engineering malware.
18:16:01 * hackagebot cabal-file-th 0.2.3 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2.3 (NickPartridge)
18:16:38 <ab9rf> MP2E: well, you certainly learn how specific compilers behave....
18:16:54 <ab9rf> gcc is irritating in its tendency to spew code randomly all over memory
18:17:31 <MP2E> you should see the PSX SDK compiler, it inlines everywhere except where it makes sense
18:17:40 <MP2E> inlining functions that are larger than the function being inlined to itself
18:17:49 <ab9rf> if gcc detects that two functions end with the same code, it'll reuse that code and make the other function jump into a common code block.
18:18:03 <MP2E> heh ouch
18:18:10 <ab9rf> it might make BOTH functions jump to a common block somewhere else nowhere nearby
18:19:08 <ab9rf> i've heard that it sometimes does the same thing with internal duplicated code blocks using floating code blocks with jsr & ret
18:19:43 <ab9rf> MP2E: both MSVC and gcc are fairly aggressive at inlining.
18:19:54 <ab9rf> MP2E: MSVC will inline between compilation units
18:20:09 <dfeuer> ab9rf: I've seen GHC do things that look kind of like that.
18:20:37 <MP2E> Well right dfeuer but in Haskell's evaluation model isn't it quite cheap to inline, therefore it happens more often?
18:20:55 <ab9rf> MP2E: it'll pull compiled code out of one .o file and inline parts of it into another .o file.  i'm not sure how it does this.
18:21:40 <MP2E> Not sure how that'd happen either. In GHC typically the original function is embedded in a module if it's INLINEABLE so that gets inlined
18:22:32 <ab9rf> i need t spend more time playing with LLVM
18:22:54 <ab9rf> it's one of those things that sits on my "list of things i should look at" but never gets picked up because i've got too many other things to do
18:23:11 <MP2E> LLVM is pretty great
18:23:54 <dfeuer> MP2E: it ... depends. Haskell tends to have a lot of small functions, each of which is cheap to inline, and when you put them together code sometimes get erased at the interface, but then sometimes it doesn't and you can get big chunks that are expensive to inline.
18:24:06 <MP2E> ah
18:25:56 <dfeuer> MP2E: one thing I've found in my assault on Data.List is that unfoldr is not inlined (currently), and it really should be, because a whole slew of Maybes end up getting allocated only to immediately become garbage.
18:32:00 <jle`> no way
18:32:02 <jle`> :|
18:32:17 <MP2E> :<
18:32:24 <MP2E> hopefully that gets fixed
18:32:38 <jle`> inlining is tricky though...i do remember adding an inline pragma to a small function causing my binary to go up by 100kB
18:32:48 <jle`> but i guess 100kB is not that big in haskell land
18:32:53 <jle`> it might be a big deal in javascript land though
18:34:26 <trap_exit> is http://leksah.org/ dead ?
18:37:24 <MP2E> trap_exit: I was about to say yes, but then I found the github and noticed there has been activity
18:37:27 <MP2E> https://github.com/leksah/leksah/commits/master
18:37:50 <trap_exit> damn, it's active
18:37:53 <trap_exit> good sluething :-)
18:45:53 <ab9rf> jle`: it's scary how willing we are to allocate megabytes of memory at a time.  of course, i cut my teeth on a platform that had 4 kilobytes of RAM....
18:46:54 <ab9rf> the first computer i managed professionally had a whopping 1.5 megabytes of RAM.
18:47:47 <jle`> must have had a hard time running crysis
18:48:31 <ab9rf> jle`: i'm fairly certain that crysis didn't exist in 1985.
18:48:44 <jle`> which would probably add to the difficulty :)
18:48:50 <ab9rf> jle`: and in any case it's never been built for the VAX-11 architecture
18:49:26 <cmccann> ab9rf: the "total allocation" numbers you see when profiling a haskell program are slightly terrifying at first
18:49:52 <ab9rf> it amuses me that i can download an emulator for my _cellphone_ that emulates that very computer on my cellphone and runs about 5x faster
18:58:43 <jollygood> in this article author seems to mock the idea that haskell (and IO in haskell) is purely functional. what is your take on this, does he have a point? http://conal.net/blog/posts/the-c-language-is-purely-functional
18:59:09 <benzrf> too bad conal is not online
18:59:53 <joelteon> i think it might be humor, since he refers to char * as the kleene star applied to 'char'
19:01:08 <benzrf> >String (or char *, for you type theorists, using a notation from Kleene)
19:01:12 <benzrf> he he he
19:01:52 <HeladoDeBrownie> jollygood, the author is often around here, maybe sometime you could ask him about it :)
19:01:55 <joelteon> that is clever though
19:01:56 <trap_exit> https://www.youtube.com/watch?v=xmjvOLlCdFU is amazing
19:02:10 <trap_exit> anyone who watches https://www.youtube.com/watch?v=xmjvOLlCdFU and does not get excited is not a Haskeller
19:02:57 <ab9rf> yeah, that's humor
19:03:24 <Iceland_jack> > text "‚ÄúC programmers‚Äù really program not in C, but in the purely functional language cpp (the ‚ÄúC Preprocessor‚Äù)."
19:03:24 <Iceland_jack> should be a nice hint :)
19:03:26 <lambdabot>  ‚ÄúC programmers‚Äù really program not in C, but in the purely functional langua...
19:03:43 <MP2E> oh, lamdbabot
19:03:45 <MP2E> @botsnack
19:03:45 <lambdabot> :)
19:04:04 <ab9rf> anybody who refers to CPP as a 'programming language' is clearly being humorous
19:05:29 <ab9rf> i would have awarded bonus points for connecting cpp metaprogramming to C++ metaprogramming using templates.
19:05:52 <Iceland_jack> and talking about cpp's run-time system
19:06:01 <jollygood> I know that he is joking that C is purely functional. but, through that joke, he also seems to be mocking the idea that haskell is purely functional. but yeah, would be interesting to hear it straight from him
19:06:58 <Iceland_jack> jollygood: Well Haskell is 'also' purely functional in the sense that it distinguishes evaluation from execution
19:07:12 <MP2E> Yeah evaluation vs execution is the real key here
19:07:40 <MP2E> I think he's joking that that is seen as a technicality, and that 'technically you could write pure C using CPP'
19:08:16 <dolio> You cannot, though. It's a pretty bad analogy.
19:08:57 <ab9rf> this fly won't leave my grasshopper alone
19:08:58 <Iceland_jack> You can also think of sh as being 'purely functional' by virtue of
19:08:58 <Iceland_jack>     $ a=l
19:08:58 <Iceland_jack>     $ b=s
19:08:58 <Iceland_jack>     $ $a$b
19:09:01 <Iceland_jack>     <output of /bin/ls>
19:09:15 <Iceland_jack> (kind of)
19:14:37 <ab9rf> satsuma laroux
19:21:44 <splintax> ok this is the second time now i've tried to cabal-install something (specifically pretty-show) and it's failed because "happy" is not installed. shouldn't that just be listed as a dependency?
19:21:59 <splintax> can't remember what the other package was but i can't tell if this is the maintainer's fault or something's wrong with my cabal
19:22:21 <Iceland_jack> is ~/.cabal/bin/ in your PATH assuming unix-like..?
19:27:25 <splintax> yeah, it is, although i have been following advice to "always sandbox", so the relevant path is actually ./.cabal-sandbox/bin
19:27:38 <splintax> everything seems to work if i just install happy manually
19:27:57 <splintax> although that didn't work for me with the other package last week, think it might have been hsx
19:28:21 <splintax> anyway, i guess my question is "is it common for stuff on hackage to fail to correctly specify its dependencies"
19:29:31 <dmwit> it happens
19:29:57 <dmwit> But executables cannot be dependencies as far as cabal is concerned.
19:30:30 <dmwit> You can require build tools, but cabal doesn't (yet) have a mapping from build tools to the canonical package which provides them.
19:37:41 <splintax> ah, okay. so that would explain why i've seen this problem twice with happy
19:38:14 <splintax> because it's an executable not a library
19:42:05 <Total_1mmersion> Is there some kind of STRef which "knows" about all the references which point to its value and allows a data type converesion (a -> b)?
19:43:29 <Total_1mmersion> Say I have ST s [STRef s Int] and I want to fmap show on all the Ints...
19:45:56 <Iceland_jack> Total_1mmersion: Do you want to get a list of [String] back or a list of [STRef s String]?
19:46:18 <Total_1mmersion> [String], I realize it's impossible to get the refs out of the ST monad
19:46:55 <Iceland_jack> you can get
19:46:55 <Iceland_jack>     ST s (STRef s [Int])
19:46:55 <Iceland_jack> back by doing 'fmap sequence'
19:47:02 <glguy_> Total_1mmersion: What you asked for doesn't exist, but what are you trying to do ?
19:47:34 <Cale> Total_1mmersion: Did you want to construct new STRefs of the second type?
19:48:12 <Total_1mmersion> Cale, no, I want the references to still point to the same thing
19:48:21 <Cale> Then no.
19:48:52 <Total_1mmersion> glguy_, I'm writing a compiler where I assign registers to statements while modifying the control flow graph.
19:49:08 <Iceland_jack> @modifySTRef
19:49:08 <lambdabot> Unknown command, try @list
19:49:10 <Iceland_jack> @ty modifySTRef
19:49:12 <lambdabot> STRef s a -> (a -> a) -> ST s ()
19:49:16 <Iceland_jack> You can't go from (a -> b)
19:49:38 <Cale> I suppose you could construct a new datatype which would allow for this
19:49:41 <Total_1mmersion> Right, I know that modifySTRef can't do it
19:50:19 <Total_1mmersion> Cale, exactly, but if I tack on Maybe Register onto every statement, I lose the guarantee that after assigning registers, every statement has one.
19:51:05 <Total_1mmersion> If I accidentally write the function which assigns registers, one statement might have Nothing as a register
19:51:06 <Cale> data STFRef s a = forall r. STFRef (STRef s r) (r -> a)
19:52:09 <Cale> Oh, you need a bit more than that of course, if you want them to be settable
19:52:19 <Total_1mmersion> whoa, how do I read this?
19:52:22 <augur> Cale: whoa, what is that, some kind of lensy STRef?!
19:53:04 <Cale> Maybe the GADT syntax for it would be clearer
19:53:32 <Cale> data STFRef s a where STFRef :: STRef s r -> (r -> a) -> STFRef s a
19:54:17 <Cale> readSTFRef (STFRef r f) = fmap f (readSTRef r)
19:54:22 <augur> that is surprisingly lens-like
19:54:23 <Cale> But you can't write
19:55:03 <Cale> for two reasons: 1) you don't know what type r is, and 2) you don't have a way to convert values of type a to values of type r
19:55:14 <Cale> So, you could do:
19:55:23 <Cale> data STFRef s a where STFRef :: STRef s r -> (r -> a) -> (a -> r) -> STFRef s a
19:55:49 <Cale> and yeah, it's somewhat lens-like
19:56:04 <zereraz> hello, I saw the quick sort from learnyouhaskell http://lpaste.net/108728 , so in the smallerSorted list in the list comprehension it should be a<x not <=.
19:56:11 * hackagebot PlayingCards 0.1.0.0 - Playing cards api  http://hackage.haskell.org/package/PlayingCards-0.1.0.0 (dillonhuff)
19:56:24 <augur> Cale: its lens with a state intermediary
19:56:33 * dfeuer wonders if he has enough room on a computer that isn't his to use it to compile GHC‚Äîsaid computer is probably much faster than his laptop.
19:56:35 <Cale> zereraz: No, you'll lose elements that way
19:56:49 <zereraz> Cale: but there is ++[x]++
19:56:56 <Cale> zereraz: so?
19:57:10 <augur> data Lens s a = Lens s (s -> a)     vs     data STFRef s a = forall r. STFRef (STRef s r) (r -> a)
19:57:12 <zereraz> Cale:  what will we lose
19:57:13 <Cale> zereraz: smallerSorted and biggerSorted are a partition of xs
19:57:20 <Cale> (as it stands)
19:57:25 <augur> you're just sort of .. pulling state over r instead
19:57:27 <augur> how weird
19:57:30 <Cale> You want every element of (x:xs) to end up in the resulting list
19:57:34 <glguy_> http://lpaste.net/108729
19:57:42 <glguy_> You can build "views" for yoru ref
19:57:44 <Cale> So x has to occur somewhere, and every element of xs has to occur somewhere
19:58:04 <augur> is STRef not a functor?
19:58:10 <Cale> If x occurs multiple times in the list, you don't just want it to occur once in the result
19:58:12 <Total_1mmersion> augur, it is not
19:58:19 <augur> why is that, again?
19:58:21 <Total_1mmersion> augur, you can't do (a -> b) on STRef
19:58:27 <Cale> augur: Because of the problem I just mentioned
19:58:29 <glguy_> It can't be one and satisfy the functor laws
19:58:35 * glguy_ needs to catch up on the backlog
19:58:45 <Cale> augur: Given only a function a -> b, you wouldn't know how to write to the resulting STRef
19:58:57 <augur> Cale: oh right, i see
19:59:15 <glguy_> It'd have to copy the STRef since the type could change, but it can't copy it because fmap id = id
19:59:20 <Total_1mmersion> Cale, how does your STFRef work? I have never learned GADTs
19:59:39 <glguy_> Total_1mmersion: The code I pasted does some of that refview business
19:59:41 <augur> if the ref occurs multiple times, what should fmap do -- should it produce multiple distinct new refs, or just one? tricky tricky
19:59:43 <augur> how interesting!
19:59:51 <Cale> Total_1mmersion: It defines a type STFRef whose only data constructor has the type that I gave
20:00:00 <Cale> (and which is also called STFRef)
20:00:12 <Cale> augur: Total_1mmersion wants it to alias
20:00:25 <Cale> But yeah, fmap could never do that
20:01:03 <glguy_> You could always make an "STRef s Dynamic"
20:01:23 <glguy_> and then have to guess what type is inside when it's reading time
20:01:36 <pavonia> zereraz: All elements equal to x but not x itself would get lost
20:01:47 <Iceland_jack> how about
20:01:47 <Iceland_jack>     fmap f stRef = runST $ do
20:01:47 <Iceland_jack>       val ‚Üê runSTRef ref
20:01:47 <Iceland_jack>       newSTRef (f a) -- ;)
20:02:03 <zereraz> pavonia: oh like if 5 is x and there are more than 1 5's
20:02:06 <glguy_> Iceland_jack: fails the fmap id = id law
20:02:26 <Iceland_jack> glguy_: Nope, because it fails to compile
20:02:46 <Iceland_jack> it has to compile before it can fail the law :)
20:03:03 <glguy_> OK, so you're twice wrong, you win :-p
20:03:20 <MP2E> haha
20:03:24 <Iceland_jack> I'm wrong only once and sooner than I would be if it would fail the law!
20:03:30 <MP2E> as long as you're wrong in a multiple of 2, you're fine
20:03:35 <Iceland_jack> Which means I'm as correctly wrong as anyone could be
20:03:52 <Iceland_jack> (unless it would fail the cpp)
20:07:03 <Total_1mmersion> glguy_, I have no idea what a Coyoneda is, but it looks like you just created a stringy view of the reference to the Int. Is that correct?
20:10:58 <Cale> Iceland_jack: Well, you probably meant readSTRef
20:11:19 <Iceland_jack> ah right, so many many layers of wrong
20:15:20 <Total_1mmersion> Cale, what if there is more "information" in the "a" than the "r"? data STFRef s a where STFRef :: STRef s r -> (r -> a) -> (a -> r) -> STFRef s a
20:15:37 <Total_1mmersion> For example, r :: Int, a :: (Int, Int)
20:15:59 <Iceland_jack> Total_1mmersion: Why is that a concern?
20:16:13 <Cale> Total_1mmersion: That can still "work", but reading the thing and then writing back the result you got won't be a no-op then
20:16:22 <Total_1mmersion> What functions would you pass in for (r -> a) and (a -> r)?
20:17:02 <Total_1mmersion> So this STFRef is sort of a view sitting on top of a standard STRef?
20:17:07 <Cale> yes
20:17:50 <Cale> If you wanted to be more principled about it, we could even use Lens.
20:18:12 <benzrf> Total_1mmersion: a `Coyoneda f b' is a pair of an `f a' and an `a -> b'
20:18:15 <Total_1mmersion> Hmm, I'm not sure if that's what I'm looking for. What if I want to convert the value referenced by the STRef into another data type, then do modifications on that?
20:18:27 <benzrf> Total_1mmersion: when you fmap, you just compose the fmapped function with the stored function
20:18:29 <SrPx> Is this correct? I've been trying to figure it out for a few minutes but it doesn't make sense http://o7.no/1opWcop
20:18:53 <benzrf> Total_1mmersion: so a `Coyoneda f a' is basically an f a, except it might not have applied some fmaps yet
20:18:59 <benzrf> Yoneda works similarly
20:19:26 <Total_1mmersion> benzrf, interesting, thanks for the description
20:19:27 <benzrf> you can also use Coyoneda with something where f isnt a functor, which lets you treat it like one and then figure out how to apply the fmapped stuff later
20:19:36 <benzrf> aka a free functor
20:19:58 <TheZakMan> does anybody here ever tried MLPostFactor?
20:20:11 <TheZakMan> I have an old macbook (mid 2007)
20:20:21 <TheZakMan> and i'm trying to install xcode
20:20:53 <geekosaur> SrPx: what doesn't make sense? (Aside from Arrows >.>)
20:21:12 * hackagebot PlayingCards 0.2.0.0 - Playing cards api  http://hackage.haskell.org/package/PlayingCards-0.2.0.0 (dillonhuff)
20:21:38 <SrPx> geekosaur: I don't understand that typing at all... first, `unsplit = arr (...)` would make me think unsplit'd type kind is *, not * ‚Üí * .
20:22:17 <SrPx> wait, that is horribly ambiguous
20:22:18 <geekosaur> :t arr
20:22:19 <lambdabot> Arrow a => (b -> c) -> a b c
20:22:37 <SrPx> :t split
20:22:38 <lambdabot> Splitter a -> [a] -> [[a]]
20:22:43 <geekosaur> :t uncurry
20:22:44 <lambdabot> (a -> b -> c) -> (a, b) -> c
20:23:13 <SrPx> ...? Look, `split :: (Arrow a) => a b (b,b); split = arr (\x -> (x,x))` then how is split not a function ?
20:23:29 <geekosaur> with no constraints on the `b` in the type of `arr`, it can unify with `(a, b)` from uncurry
20:24:08 <geekosaur> SrPx: Arrows *are* (an abstraction over) functions
20:24:57 <SrPx> No, I mean... `split = arr (...)` and its type is just an arrow. `unsplit = arr (...)` and its type is a function that returns an arrow...!?
20:25:40 <SrPx> both call the same function in a single value, so they should at least be of the same type
20:27:01 <SrPx> :src uncurry
20:27:12 <SrPx> oh
20:28:45 <geekosaur> uncurry's type can be read as `(a -> b -> c) -> ((a, b) -> c)`. as for `arr`, it takes a function and wraps it as an arrow
20:29:05 <geekosaur> compare `map`, which is
20:29:07 <geekosaur> :t map
20:29:09 <lambdabot> (a -> b) -> [a] -> [b]
20:29:24 <geekosaur> but can be read as: (a -> b) -> ([a] -> [b])
20:29:27 <SrPx> ah look, I see it is an error indeed... the `arr (\op (x,y) -> x `op` y)` should actually be `arr . (\op (x,y) -> x `op` y)`, no? I was looking at that definition, not the first `arr . uncurry`
20:29:51 <SrPx> you just made me notice (\op (x,y) -> x `op` y) is uncurry so it needs a dot there
20:30:44 <geekosaur> does seem like it
20:31:04 <geekosaur> :t arr (\op (x,y) -> x `op` y)
20:31:05 <lambdabot> Arrow a => a (t1 -> t2 -> t) ((t1, t2) -> t)
20:31:15 <geekosaur> yug
20:31:22 <geekosaur> :t arr . (\op (x,y) -> x `op` y)
20:31:25 <lambdabot> Arrow a => (t -> t1 -> c) -> a (t, t1) c
20:31:32 <SrPx> I understand it now, the lack of a dot make it look like ¬¥arr¬¥ was being applied to uncurry which is what didn't make sense... let me see if I can edit that
20:31:38 <geekosaur> right
20:32:17 <SrPx> OK I don't know how to edit the Haskell Wiki ):
20:32:38 <SrPx> anyway, thanks! geekosaur
20:33:11 <geekosaur> yeh, I think I implicitly ignored the comment because of that, it just looked wrong
20:33:48 <SrPx> well at least now I know exactly what uncurry is (:
20:36:14 * hackagebot plot 0.2.3.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.3.2 (VivianMcPhail)
20:37:18 <solidus-river> jle`: i've got a good question, whats the proper technique to initialize a wire with a base value
20:37:39 <solidus-river> jle`: so i have a wire now that describes how position changes with respect to velocity depending on input events for my spaceship
20:37:47 <solidus-river> jle`: but i need to provide it wtih an intial position
20:37:54 <solidus-river> jle`: and do so programatically based on a config files
20:37:56 <solidus-river> *file
20:38:15 <octopuscabbage> is there a function with the type signature (a->(b,c)) -> (b->c->d) -> (a->d) ie a function which takes a function that returns a 2 value tuple, and then a function that takes those two values and produces a third value but combines them so that the first parameter of the second function is the first slot of the tuple and the second paramater of the second function is the second slot in the tuble
20:38:18 <octopuscabbage> tuple*
20:38:33 <solidus-river> would this be a case for mkwire, i need to instantiate a integral wire with a starting value
20:38:48 <HeladoDeBrownie> @djinn (a->(b,c)) -> (b->c->d) -> (a->d)
20:38:48 <lambdabot> f a b c =
20:38:48 <lambdabot>     case a c of
20:38:49 <lambdabot>     (d, e) -> b d e
20:38:57 <solidus-river> octopuscabbage: check out uncurry and curry from Data.Tuple
20:38:59 <HeladoDeBrownie> octopuscabbage, not already written, probably, but easy enough to write
20:39:21 <solidus-river> :t curry
20:39:23 <lambdabot> ((a, b) -> c) -> a -> b -> c
20:39:27 <solidus-river> :t uncurry
20:39:28 <lambdabot> (a -> b -> c) -> (a, b) -> c
20:39:42 <HeladoDeBrownie> Ooh yeah, curry's a good idea
20:39:47 <octopuscabbage> ah cool that works
20:40:00 <octopuscabbage> i don't have a real need for it, it just seems like a function that would be useful at some point
20:40:45 <HeladoDeBrownie> It's just a specific way to compose things. I don't know how often this one comes up but it can be handy having compositions lying around :)
20:41:14 * hackagebot plot-gtk 0.2.0.2 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.2.0.2 (VivianMcPhail)
20:41:50 <jmcarthur> :t fmap . uncurry
20:41:51 <lambdabot> Functor f => (a -> b1 -> b) -> f (a, b1) -> f b
20:42:19 <jmcarthur> :t fmap . uncurry :: (b->c->d) -> (a->(b,c)) -> (a->d)
20:42:20 <lambdabot> (b -> c -> d) -> (a -> (b, c)) -> a -> d
20:42:29 <kvanb> @let funcurry = fmap. uncurry
20:42:32 <lambdabot>  Defined.
20:42:34 <kvanb> > funcurry 1 2
20:42:36 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b10 -> b))
20:42:36 <lambdabot>    arising from the ambiguity check for ‚Äòe_112‚Äô
20:42:36 <lambdabot>  from the context (GHC.Num.Num (a -> b1 -> b),
20:42:36 <lambdabot>                    GHC.Num.Num (f (a, b1)),
20:42:36 <lambdabot>                    GHC.Base.Functor f)
20:42:43 <kvanb> :t funcurry
20:42:44 <lambdabot> Functor f => (a -> b1 -> b) -> f (a, b1) -> f b
20:42:49 <HeladoDeBrownie> That was an odd choice of input
20:42:59 <kvanb> yeah I misread the typesif
20:43:00 <kvanb> *sig
20:43:26 <jmcarthur> that function was in response to a question from before you joined
20:43:38 <kvanb> > funcurry (+) (Just (1,2))
20:43:40 <lambdabot>  Just 3
20:44:03 <dmj`> @src funcurry
20:44:03 <lambdabot> Source not found. There are some things that I just don't know.
20:44:06 <HeladoDeBrownie> @type (.) . uncurry
20:44:08 <lambdabot> (a1 -> b -> c) -> (a -> (a1, b)) -> a -> c
20:44:20 <solidus-river> imo though i ran into this earlier in the week and i still think what i really wanted was a record instead of a tuple or a good use of zipWith
20:44:38 <solidus-river> being the lazy person i am i used uncurry / curry
20:45:01 <solidus-river> but i still have nightmares
20:46:47 <octopuscabbage> does anyone have experience with gtk2hs? in the python version of gtk you can pass a map of signals to handlers, does gtk2hs support this as well?
20:51:22 <geekosaur> python cares not that you have combined a bunch of things with wildly different types
20:53:21 <pavonia> octopuscabbage: What does that map store?
20:54:01 <octopuscabbage> pavonia: strings to functions
20:54:42 <octopuscabbage> geekosaur: yeah i suppose that's true, i guess it would involve a hacky workaround to get it to work
20:54:50 <HeladoDeBrownie> geekosaur, alternatively, you could say that Python *has* only one type
20:54:52 <pavonia> What do these strings denote?
20:55:09 <octopuscabbage> pavonia: the name of the signal (this refers to a builder object specifically)
20:55:13 <geekosaur> I think we don't even use the string reps of signal names, but instead a typed interface
20:55:34 <splintax> say i have data Tree a = Leaf a | Node a. is it possible to define "isALeaf :: Tree -> Bool" inline, eg. as an argument to filter?
20:56:01 <octopuscabbage> geekosaur: you would be correct, fine then it would store signals to functions
20:56:09 <splintax> or do i have to manually define a new named function, isALeaf (Leaf a) = true; isALeaf _ = false;
20:56:15 <HeladoDeBrownie> splintax, you could write a lambda, but it wouldn't have that name. You could use a local binding as well, but it wouldn't be defined at the place where the filter happens.
20:56:46 <HeladoDeBrownie> \x -> case x of { Leaf {} -> True ; Node {} -> False }
20:56:47 <geekosaur> splintax: with a lambda? (\x -> case x of Leaf _ -> True; _ -> False)
20:56:59 <splintax> yeah i don't care about the name. geekosaur's solution is what i'm looking for
20:57:02 <HeladoDeBrownie> What geekosaur and I said are equivalent
20:57:10 <geekosaur> slightly shoter with lambdacase but it's not worth the effort here
20:57:29 <HeladoDeBrownie> Yeah, I was originally going to write it as LambdaCase because why name a variable you don't need to? :P
20:57:51 <pavonia> octopuscabbage: So this means you install the same handler for a map of signals?
20:57:57 <HeladoDeBrownie> Actually our solutions aren't *quite* equivalent, but they are if you neglect bottom
20:58:32 <geekosaur> it's a pity that lambdas can't do multiple pattern matches directly, but there's no good syntactical way to add that
20:58:32 <octopuscabbage> pavonia: each signal should correspond to one function
20:58:51 <octopuscabbage> for example, on_window1_close or on_button1_activate
20:58:52 <geekosaur> and \case mostly scratches that itch
20:58:57 <octopuscabbage> those would be signal names
20:59:04 <HeladoDeBrownie> geekosaur, I'm more convinced than I used to be that using a case expression is preferable to multiple clauses
20:59:23 <geekosaur> enh, they're the same tbing after desugaring
20:59:32 <HeladoDeBrownie> Right, so it's the syntax that matters
21:00:19 <geekosaur> sometimes I find the explicit case clearer, usually it's noise that obscures what's important
21:00:59 <solidus-river> octopuscabbage: if gtk2hs used Cont for handlers it would allow this but i doubt it does
21:01:19 <pavonia> octopuscabbage: I'm not aware of such a function but maybe it can be built mapping "on" over a Map
21:01:40 <solidus-river> octopuscabbage: your looking for the Cont monad
21:02:00 <pavonia> What has Cont to do with that?
21:02:31 <solidus-river> it would allow for one function to be passed to gtk that acts as the python map does
21:02:34 <HeladoDeBrownie> geekosaur, that's fair, I just value lack of repetition of the binding's name over lack of case syntax.
21:02:38 <solidus-river> but with saner type enforcements
21:02:45 <qrada> hi i'm nub'n out hard right now.. say I have, Queue.MVar, Queue.Chan, Queue.State etc.. all which implement a queue interfaces as instances of some type classes.. so, all of my test.hs's are the exact same code except for the import of the specificm module, ie, import Queue.Chan in test.hs to test the chan queue implementation.. is there an elegant way to have the same test.hs file, test 'all' of the implementations? ie if i could somehow pass th
21:02:52 <solidus-river> http://www.haskellforall.com/2012/12/the-continuation-monad.html
21:03:11 <solidus-river> pavonia: ^
21:03:17 <sclv__> qrada: write your tests polymorphically
21:03:31 <sclv__> then invoke them multiple times, instantiated at each type
21:03:44 <geekosaur> qrada: the IRC protoocl has a length limit and you hit it
21:03:52 <qrada> hahahah did i?
21:03:58 <geekosaur> "ie if i could somehow pass th"
21:04:03 <qrada> sorry.. sclv_ thanks ya.. i think i'm 'underthinking this'
21:04:21 <qrada> ya so basically i should just import qualified everything.. then run my tests for each qualified import
21:04:47 <qrada> since everything stems from that initial queue instance
21:04:55 <pavonia> solidus-river: I know what the Cont monad does but I can't see how it's related here. Maybe I misunderstand the problem, though
21:04:57 <qrada> ya.. im not thinking right now
21:05:43 <solidus-river> pavonia: maybe i am, i thought octopuscabbage was looking for a way to form the problem of callbacks in a library in a way such that they could pass one function to the library to satisfy all callbacks
21:06:08 <trap_exit> anyone here managed to use the 10x increase in productivity of haskel to negotiate a 1M / year salary?
21:06:12 <solidus-river> pavonia: Cont allows for this if the library bindings are formed in a way to handle it
21:06:23 <pavonia> Aha, I see
21:06:58 <qrada> trap_exit: im trying but so far unsuccessful
21:07:00 <qrada> 8|
21:07:30 <trap_exit> i'm trying to very hard to find an area
21:07:34 <trap_exit> where I can kick some php/ruby ass
21:08:18 <carter> heh
21:08:37 <carter> build a business if you want the revenue to all go to you
21:08:42 <carter> be warned, won't be much revenue
21:08:43 <qrada> i've turned a few people on to haskell at work, but it's mostly a php shop with some go/node people.. of the people who liked haskell, i dont think any of them are still learning it
21:09:20 <solidus-river> but my answer was a circle jerk, i doub the gtk2hs bindings are made like that
21:09:38 <solidus-river> but if needed octopuscabbage could reform the callback bindings with Cont to get that functionality
21:09:41 <solidus-river> :P
21:10:35 <trap_exit> i feel like cloud haskell, build on aws / digital ocean
21:10:37 <solidus-river> so i was being not helpfull and now i feel bad and am going to go sit in the corner
21:10:45 <trap_exit> should be able to solve some hundred-million dollar problem
21:11:04 <splintax> trap_exit: well, once a problem-solver who likes to use haskell starts using the platform.
21:11:11 <qrada> erlang's also solving it
21:11:16 <qrada> (has been solving it)
21:11:45 <trap_exit> I actually think (I may be wrong on this) taht haskell is better at cloud for the following reason:
21:11:52 <trap_exit> in erlang, you explicity define your concurency/parallel strategies
21:11:57 <trap_exit> (within the code)
21:12:06 <trap_exit> in ahskell, you can swtich strategiers by just sswitching a monad
21:12:26 <solidus-river> trap_exit: the problem is that most people dont want to deal with types the way haskell makes you
21:12:48 <solidus-river> trap_exit: that has scared everyone i've talked about haskell in the cloud with off, and they've mostly settled on Go
21:13:03 <solidus-river> trap_exit: erlang is horrible at data processing, only really good for message passing
21:13:16 <solatis> and where does that leave haskell? :)
21:13:38 <solidus-river> it leaves it in the hands of people smart / explorative enough to see its value
21:13:47 <solidus-river> and sometime in the next X years that will be found
21:14:02 <solidus-river> or languages like Go / Rust will converge on more of a subset of haskell
21:14:07 <solidus-river> and it wont matter?
21:14:08 <solidus-river> :)
21:14:16 <qrada> im trying to fig out how to download don stewart/ekmett/simon peyton jones's brain into mine.. will pay big $$
21:14:18 <solatis> i think the latter is already happening
21:15:01 <kvanb> brew install glpk
21:15:12 <solidus-river> solatis: the true power will stay in the hask though
21:15:18 <splintax> rust certainly seems like it's haskell's type system + realtime/lowlevel features like optional GC
21:15:18 * solidus-river makes some pseudo religious gesture
21:15:25 <solidus-river> *speudo?
21:15:27 <AshyIsMe> qrada: hopefully the magic of nanobots allows us to do that sometime in the next couple decades
21:15:28 <ekjwf> Is the fact that quantum particles exist in a supersition of states until measured evidence that the universe is a simulation written in a lazily evaluated language? Does that make any lazily evaluated language like Haskell literally a programming language of the gods?
21:15:49 <Guest74017> lol
21:15:58 <qrada> haskell go rust c are my 'fav languages'.. throw in typescript just because i have to deal with js so typescript is decent (and coffee)
21:16:02 <solatis> ekjwf: i think youre confusing it with lisp
21:16:20 <qrada> AshyIsMe: would be nice :D
21:16:26 <kvanb> ekjwf: yes!!
21:16:28 <kvanb> Just yes.
21:16:46 <solatis> ekjwf: https://xkcd.com/224/
21:17:06 <qrada> i've been trying to learn me some 'coq', going to look into isabelle/hol because of the whole seL4 amazingness..
21:17:53 <bb010g> Alt text: "We lost the documentation on quantum mechanics. You'll have to decode the regexes yourself."
21:19:08 <MP2E> quantum physics is the runtime system
21:19:22 <MP2E> written in golfed out C, the internals forgotten long ago
21:19:31 <tac> Did you guys know we have #haskell-blah for off-topic conversations?
21:19:37 <solidus-river> solatis: i think what ultimatly haskell provides that languages like go / rust cant is a way of forming a problem completley abstracted from a model of execution
21:19:40 <MP2E> heh
21:20:06 <solidus-river> solatis: i'm really interested in experminting with more haskell as a way of forming a coding problem well and then only worrying about mappin gthat to specific os / device after its formed as part of compilation
21:20:20 <solidus-river> solatis: i also don't see them supporting laziness
21:21:53 <solatis> laziness is a typical thing that is either a language feature from the start, or will never be
21:22:02 <solatis> it just has too much an impact
21:22:47 <tac> To be sure, though, strict languages support lazy evaluation
21:22:51 <tac> You just have to be explicit about it
21:23:14 <tac> And it's just the reverse in Haskell, where you are explicit about strictness
21:23:18 <solatis> just look at the node.js community having severe problems trying to get their community to use 'work-pulling' streams instead of 'work-pushing' streams
21:23:22 <mwhit> @pl f g x y z = g z x y
21:23:22 <lambdabot> f = (flip .) . flip
21:23:47 <tac> (And it's considered by some to be a misfeature that lazy is the default, as strict evaluation is often the better default)
21:23:51 <Cale> If you have to be explicit, it tends to mean that most of the advantages of laziness in terms of compositionality are negated though, because people won't use it.
21:24:13 <Cale> Also, I strongly disagree about strict evaluation being more often the better default
21:24:32 <kvanb> laziness with a good strictness analyser is mostly strict anyway
21:24:51 <tac> Cale: which is why I purposefully used the weasle word "some"
21:24:51 <kvanb> if the argument is performance
21:24:55 <solidus-river> tac: i think its better to be explicitly lazy, there are less ways you can deviate when beign strict than there are that you can deviate when bieng lazy
21:25:03 <HeladoDeBrownie> Doesn't "non-strict" mean "not necessarily strict"?
21:25:38 <Cale> HeladoDeBrownie: "Non-strict semantics" means that the result and termination behaviour of programs has to be the same as if they were evaluated lazily.
21:25:43 <tac> HeladoDeBrownie: depends who you ask
21:26:01 <Cale> Haskell doesn't have a specified evaluation mechanism
21:26:04 <HeladoDeBrownie> Cale, okay, then what does "lazy" mean precisely?
21:26:17 <tac> HeladoDeBrownie: The famous thing to do is to harp on people who use the term "lazy" and get into an argument over exact semantics (whether terms can be shared or not)
21:26:24 <Cale> Lazy evaluation means outermost-first evaluation with sharing
21:26:38 <Cale> I'll use my usual example
21:26:54 <Cale> Consider the function double x = x + x, and suppose we want to evaluate double (double 5)
21:27:02 <HeladoDeBrownie> Ah, yes, I see it.
21:27:07 <Cale> Under strict evaluation, you evaluate innermost-first
21:27:24 <Cale> double (double 5) -> double (5 + 5) -> double 10 -> 10 + 10 -> 20
21:27:29 * tac prefers random redux evaluation
21:27:38 <Cale> We could also evaluate outermost-first:
21:27:41 <Cale> double (double 5)
21:27:46 <Cale> -> (double 5) + (double 5)
21:27:53 <Cale> -> (5 + 5) + (double 5)
21:27:57 <Cale> -> 10 + (double 5)
21:28:01 <Cale> -> 10 + (5 + 5)
21:28:04 <Cale> -> 10 + 10
21:28:04 <xinming> anyone here can tell me how does internal about transform functions in list comprenhensions?
21:28:05 <Cale> -> 20
21:28:07 <xinming> just like    [ x | x <- list, then sortWith by x ]
21:28:15 <xinming> and I saw that the type of sortWith is (a -> b) -> [a] -> [a]    But I don't understand how is the sortWith function used internally in list comprehension
21:28:36 <xinming> The question I asked yesterday night, But none replied, So, I repost my question again. :-)
21:28:38 <Cale> We duplicated work, evaluating double 5 twice here, because x occurred more than once in the body of double
21:29:27 <Cale> So, lazy evaluation fixes this problem with outermost-first evaluation, by saying that any evaluation done to a bound variable must be shared between the occurrences of that variable
21:29:37 <Cale> We can represent the sharing with a let expression, so:
21:29:41 <Cale> double (double 5)
21:29:56 <Cale> -> let x = double 5 in x + x  -- note we still reduce the outermost double first
21:30:02 <Cale> -> let x = 5 + 5 in x + x
21:30:06 <Cale> -> let x = 10 in x + x
21:30:10 <Cale> -> 10 + 10
21:30:11 <Cale> -> 20
21:30:56 <Cale> Under innermost-first (strict) evaluation, we evaluate every function parameter exactly once. Under outermost-first evaluation, we evaluate function parameters zero or more times.
21:31:10 <HeladoDeBrownie> But with lazy, zero or one.
21:31:14 <Cale> right
21:31:21 <Cale> So in that sense, it gets the best of both worlds.
21:31:52 <HeladoDeBrownie> Then strictness is mostly only useful for controlling space use?
21:32:17 <solidus-river> HeladoDeBrownie: and controlling the time of evaluations
21:32:22 <solidus-river> *evaluation
21:32:22 <Cale> Yeah, the problems with lazy evaluation come about when you end up with large expressions building up in memory.
21:32:36 <solidus-river> HeladoDeBrownie: and thats exactly where you'll see strictness usedin haskell libs as far as i've seen
21:32:46 <solidus-river> *used in
21:32:47 <geekosaur> xinming, have you read http://research.microsoft.com/~simonpj/papers/list-comp ?
21:32:53 <Cale> Any extra time costs for lazy evaluation come from the additional memory management
21:33:19 <solidus-river> Cale: also when you want to force a seperate thread to do some work
21:33:23 <Cale> Lazy evaluation typically takes fewer reduction steps in general.
21:33:34 <solidus-river> Cale: you don't want the thread just building up thunks for the main thread
21:33:41 <Cale> (sometimes infinitely many fewer reduction steps)
21:34:06 <tac> The trade-off is that those steps are typically more expensive
21:34:20 <tac> due to the cost of representing thunks
21:34:32 <Cale> Representing expressions, using thunks.
21:34:40 <tac> yeah
21:35:23 <nitrix> Personally, I think there are very few cases where performance would be an issue.
21:35:26 <tac> oh btw Cale
21:35:31 <tac> or anyone*
21:35:38 <Cale> Yes, in most cases, either evaluation order will be just fine.
21:35:48 <tac> Do you know if (and where) there are any papers on unboxed types in GHC?
21:35:51 <nitrix> Especially given functional languages generaly behaves lot more nicely in a distributed environment than any other language.
21:36:20 * hackagebot PlayingCards 0.3.0.0 - Playing cards api  http://hackage.haskell.org/package/PlayingCards-0.3.0.0 (dillonhuff)
21:36:27 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.50.231&rep=rep1&type=pdf
21:36:40 <tac> awesome. Thank you.
21:37:50 <Cale> Well, one way of thinking about it...
21:39:06 <Cale> We can classify each piece of data into "large" and "small" based on whether they have many or few separately evaluatable parts respectively
21:40:54 <Cale> and then classify computations based on which types of data they consume and produce
21:41:29 <Cale> If everything stays small, you'll typically be fine under either evaluation order
21:41:54 <Cale> If you're going from small to large, you'd rather be lazy than strict, because you may not end up needing the entire large structure.
21:42:55 <Cale> If you're going from large to large, there might be a way to produce each part of the result given only part of the input, and laziness fares better there.
21:43:42 <Cale> If you're going from large to small where you're searching for a specific piece of the large structure, you would hope it's not already evaluated, so lazy evaluation is good.
21:44:06 <Cale> If you're going from large to small by summarising the elements of the large structure, that's where you want strictness.
21:44:20 <HeladoDeBrownie> foldl'
21:44:23 <Cale> yes
21:44:33 <Cale> typically foldl' or something like it will be useful :)
21:46:32 <tac> Cale: would you say then that you want to be strict in proportion to the data you plan to *use* in a structure?
21:46:53 <Cale> The trouble with strict-by-default/lazy-as-an-option is that the main advantage of laziness is in the compositionality you gain from being able to stick together programs which lazily produce and consume data. If the thing you want is in the library, but accidentally too strict because someone didn't think about this use ahead of time, you lose that benefit.
21:48:03 <Cale> You want to be strict exactly at the point in your program where you're taking large datastructures or many individual bits of data, and summarising them somehow into a simple result.
21:48:12 <Cale> (in a way which depends on them all)
21:48:30 <tac> hmm
21:51:24 <Cale> e.g. adding up a list of numbers, counting the words in a string, basically anything you'd think of as accumulation of some sort
21:52:00 <Cale> You want a little strictness often when writing to an IORef repeatedly with a new value that depends on the old one
21:52:37 <HeladoDeBrownie> That's one of the few times laziness ever bit me, updating a TVar
21:53:06 <Cale> Another way to put it is you want to avoid building up large expressions composed of strict functions.
21:53:11 <HeladoDeBrownie> I managed to run out of‚Ä¶ stack?
21:53:25 <Cale> i.e. functions which have to pattern match their parameter to produce any part of their result
21:53:31 <Cale> and yeah
21:54:00 <Cale> You'll run out of stack space, because the stack is used to hold pattern matches who are waiting for their scrutinee to be sufficiently evaluated to match.
21:55:14 <Cale> i.e. you'll typically build up the large expression in memory just fine, and then when you go to evaluate it, because it was built from strict functions, each of them will demand to match on the result of this also-large-expression-composed-of-strict-functions, and you'll keep adding pattern matches to the stack until you run out of stack space.
21:55:51 <Cale> But even if you don't, you'll have wasted a lot of space on the expression.
21:56:06 <Cale> and a lot of time allocating space for it
21:56:13 <HeladoDeBrownie> I'm going to bed. Good night~
21:56:28 <HeladoDeBrownie> And thanks for the explanation
21:56:42 <Cale> Good night! and no problem :)
21:59:08 <xinming_> geekosaur: Not yet, But I'll read them now, thanks
22:01:41 <solidus-river> hmm, i think i just ran into a conflict of libraries
22:01:55 <solidus-river> lens provides its own (.) as does netwire
22:06:22 <dibblego> lens provides a (.) function? hope not
22:06:37 <zwer> lens uses Prelude's (.)
22:08:54 <tac> Why does regular Lens take 4 type parameters?
22:09:14 <c_wraith> tac: to allow lenses to change types
22:09:26 <tac> when would be a case where that would be useful?
22:09:53 <glguy> > over _1 show (1,2)
22:09:54 <lambdabot>  can't find file: L.hs
22:10:00 <glguy> ?undefine
22:10:00 <lambdabot> Undefined.
22:10:01 <tac> :(
22:10:02 <tac> heh
22:10:18 <glguy> > over _1 show (1,2)
22:10:18 <tac> > over _1 show (1, 2)
22:10:20 <lambdabot>  can't find file: L.hs
22:10:20 <lambdabot>  ("1",2)
22:10:36 <tac> gotcha
22:10:59 <tac> I'm guessing it's also useful for GADTs
22:11:18 <c_wraith> Not as much.
22:11:29 <c_wraith> It's most just about regular ADTs
22:11:36 <dibblego> @google lens polymorphic update problem
22:11:37 <lambdabot> http://r6.ca/blog/20120623T104901Z.html
22:11:48 <c_wraith> Parameterize over a type variable, still get to use lenses to update fields with the parameterized type
22:11:51 <zq> is it possible to automatically derive instance Monad for [Either a b]?
22:12:11 <c_wraith> zq: that type already has a Monad instance
22:12:34 <dibblego> well, no [] does
22:12:47 <zq> please reread
22:12:47 <dibblego> do you mean the type constructor x -> [Either a x] ?
22:13:11 <dibblego> [Either a b] is not well-kinded, so it's somewhat ambiguous
22:13:28 <dibblego> please disambiguate
22:13:31 <c_wraith> zq: I reread.  The question still is either asking for something that already exists, or incomprehensible
22:13:38 <dibblego> x -> [Either x b] ?
22:13:39 <benzrf> [Either a b] is not well-kinde
22:13:40 <benzrf> d?
22:13:42 <xinming_> geekosaur: ping
22:13:42 <Cale> zq: Perhaps you could write the instance that you wanted to derive automatically by hand?
22:13:55 <Cale> (so we'd know what you're talking about)
22:14:01 <dibblego> instance Monad [Either a b] -- kind error
22:14:04 <Cale> benzrf: Not to be a monad
22:14:06 <xinming_> geekosaur: I've read the page you sent, But I'm still curious on, how is list comprehension deal with it internally?
22:14:30 <zq> Cale: instance Monad [Either a] where ...
22:14:30 <xinming_> geekosaur: I mean, the sortWith function accepts 2 args, a function (a -> b)   and list.
22:15:16 <dibblego> zq: you need to write: newtype EitherList a b = EitherList [Either a b]; instance Monad (EitherList a) where ‚Ä¶
22:15:22 <benzrf> Cale: ah
22:15:30 <zq> dibblego: yeah, that's what i'm trying to avoid
22:15:53 <zq> i already have an instance written out
22:16:34 <Cale> zq: That's also ill-kinded, as the list brackets require a type argument of kind *
22:16:40 <Cale> while Either a has kind * -> *
22:17:54 <zq> ugh
22:18:15 <zq> i'll bite
22:18:46 <zq> how to get ghc to derive (>>=) :: [Either a b] -> (b -> Either a c) -> Either a c?
22:18:50 <Cale> (but what dibblego suggested will work)
22:18:52 <dmwit> ?unmtl EitherT e []
22:18:52 <lambdabot> EitherT e []
22:19:14 <Cale> zq: Yeah, it's not going to do that, you have to say what you mean, and I don't think there's a monad like that anyway
22:19:16 <zq> no kidding -- i did exactly what dibblego suggested already
22:20:09 <dmwit> ?unmtl ErrorT e [] a
22:20:09 <lambdabot> [] (Either e a)
22:20:11 <Cale> Have you checked that EitherList a satisfies the monad laws?
22:20:48 <dmwit> (>>=) :: [Either a b] -> (b -> [Either a c]) -> [Either a c], up to isomorphism
22:21:47 <dmwit> So my advice would be to just go ahead and use ErrorT.
22:22:06 <dmwit> Or edwardk's more law-abiding implementation, can't remember what it's called.
22:22:26 <zq> dmwit: i considered that too, but ErrorT has a bunch of error reporting things i don't need either
22:23:07 <c_wraith> zq: what's wrong with http://hackage.haskell.org/package/either-4.3.0.1/docs/Control-Monad-Trans-Either.html ?
22:23:44 <zq> c_wraith: massive amount of deps :\
22:23:51 <dmwit> BAH
22:23:56 <c_wraith> that's a problem?
22:24:04 <dmwit> Massive deps = massive amounts of code you do not, personally, have to write.
22:24:31 <solidus-river> jle`: i think i'm misunderstanding either wires or lenses, this results in a horrible type error but i don't think it should https://github.com/fuag15/functioninvaders/blob/feature/wire-init/src/NFInvaders/Simulation/BraveDefender.hs
22:24:39 <solidus-river> or anyone familiar with netwire / lenses ^
22:25:59 <zq> alrighty then, EitherT it is
22:26:07 <zq> c_wraith, dmwit, Cale: thanks
22:30:04 <qrada> my types finally lined up... yeaaah$!@)!)@$I!KE!)
22:35:12 <solidus-river> nvm i think i get it i need to apply a StateT to this wire if i want to use any += etc from Control.Lens
22:46:22 <platz> So now that we have lenses, is it true that manually constructed zippers are obsolete?
22:47:55 <platz> I'm thinking traversals and prisms would get you most of the way there
22:52:11 <c_wraith> platz: are you aware of http://hackage.haskell.org/package/zippers ?
22:52:27 <c_wraith> platz: it used to be part of the lens library, but was split out for not being general enough.
22:53:11 <platz> hrmm.. I have seen it a while ago but didn't know it used lens
22:53:49 <c_wraith> platz: don't confuse it with the zipper package.  They are different. :0
22:53:52 <c_wraith> err, :)
22:54:38 <platz> thanks. yeah zipper is the classic one
22:55:22 <c_wraith> Anyway, yeah.  Zippers uses lenses to navigate around structures.
22:55:33 <c_wraith> So it sounds pretty much like what I think you were envisioning.
22:58:00 <c_wraith> :t zipper
22:58:01 <lambdabot> Not in scope: ‚Äòzipper‚Äô
22:58:12 <c_wraith> lambdabot doesn't have it installed, though.  I suppose that's fine.
22:58:42 <mietek> @type let f x y z = (x, y, z) in let f1 = (f, f, f) in let f2 = (f1, f1, f1) in let f3 = (f2, f2, f2) in (f3, f3, f3)
22:58:43 <lambdabot> ((((t -> t1 -> t2 -> (t, t1, t2), t3 -> t4 -> t5 -> (t3, t4, t5), t6 -> t7 -> t8 -> (t6, t7, t8)), (t9 -> t10 -> t11 -> (t9, t10, t11), t12 -> t13 -> t14 -> (t12, t13, t14), t15 -> t16 -> t17 -> (t15, t16, t17)), (t18 -> t19 -> t20 -> (t18, t19, t20), t21 -> t22 -> t23 -> (t21, t22, t23), t24 -> t25 -> t26 -> (t24, t25, t26))), ((t27 -> t28 ->
22:58:43 <lambdabot> t29 -> (t27, t28, t29), t30 -> t31 -> t32 -> (t30, t31, t32), t33 -> t34 -> t35 -> (t33, t34, t35)), (t36 -> t37 -> t38 -> (t36, t37, t38), t39 -> t40 -> t41 -> (t39, t40, t41), t42 -> t43 -> t44 -> (t42, t43, t44)), (t45 -> t46 -> t47 -> (t45, t46, t47), t48 -> t49 -> t50 -> (t48, t49, t50), t51 -> t52 -> t53 -> (t51, t52, t53))), ((t54 -> t55 ->
22:58:43 <lambdabot>  t56 -> (t54, t55, t56), t57 -> t58 -> t59 -> (t57, t58, t59), t60 -> t61 -> t62 -> (t60, t61, t62)), (t63 -> t64 -> t65 -> (t63, t64, t65), t66 -> t67 -> t68 -> (t66, t67, t68), t69 -> t70 -> t71 -> (t69, t70, t71)), (t72 -> t73 -> t74 -> (t72, t73, t74), t75 -> t76 -> t77 -> (t75, t76, t77), t78 -> t79 -> t80 -> (t78, t79, t80)))), (((t81 ->
22:58:43 <lambdabot> t82 -> t83 -> (t81, t82, t83), t84 -> t85 -> t86 -> (t84, t85, t86), t87 -> t88 -> t89 -> (t87, t88, t89)), (t90 -> t91 -> t92 -> (t90, t91, t92), t93 -> t94 -> t95 -> (t93, t94, t95), t96 -> t97 -> t98 -> (t96, t97, t98)), (t99 -> t100 -> t101 -> (t99, t100, t101), t102 -> t103 -> t104 -> (t102, t103, t104), t105 -> t106 -> t107 -> (t105, t106,
22:58:44 <lambdabot> t107))), ((t108 -> t109 -> t110 -> (t108, t109, t110), t111 -> t112 -> t113 -> (t111, t112, t113), t114 -> t115 -> t116 -> (t114, t115, t116)), (t117 -> t118 -> t119 -> (t117, t118, t119), t120 -> t121 -> t122 -> (t120, t121, t122), t123 -> t124 -> t125 -> (t123, t124, t125)), (t126 -> t127 -> t128 -> (t126, t127, t128), t129 -> t130 -> t131 -> (
22:58:45 <lambdabot> [5 @more lines]
22:59:06 <benzrf> jesus
22:59:40 <c_wraith> yes, types can grow in size exponentially
22:59:43 <joelteon> should be using the monomorphism restriction there
22:59:48 <joelteon> but it's not
23:00:24 <mietek> Reading http://spacemanaki.com/blog/2014/08/04/Just-LOOK-at-the-humongous-type/
23:00:58 <mayski> nice title :DD
23:01:08 <c_wraith> :t ?f id id id id id id id id id id id
23:01:10 <lambdabot> (?f::(a -> a) -> (a1 -> a1) -> (a2 -> a2) -> (a3 -> a3) -> (a4 -> a4) -> (a5 -> a5) -> (a6 -> a6) -> (a7 -> a7) -> (a8 -> a8) -> (a9 -> a9) -> (a10 -> a10) -> t) => t
23:01:25 <trap_exit> wtf
23:01:28 * hackagebot authenticate 1.3.2.9 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.9 (MichaelSnoyman)
23:01:39 <trap_exit> are we trying to break haskell, break lamb dabot, or break #haskell ?
23:01:40 <c_wraith> That one's not exponential.  Darn.
23:02:28 <mietek> The simpler one is
23:03:27 <mietek> @type let f x = (x, x, x) in f (f (f 0))
23:03:29 <lambdabot> Num t => (((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t)), ((t, t, t), (t, t, t), (t, t, t)))
23:03:36 <mietek> Sadly,
23:03:42 <mietek> @type let f x = (x, x, x) in iterate f 0
23:03:43 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ (a, a, a)
23:03:44 <lambdabot>     Expected type: a -> a
23:03:44 <lambdabot>       Actual type: a -> (a, a, a)
23:03:58 <c_wraith> well, yes.  infinite types are *really* big. :P
23:05:34 <joelteon> so `let f x = (x, x, x)' could still be composed out of unique type variables right
23:06:52 <benzrf> night
23:12:40 <maybefbi> can yi show an overlay UI to show tips and select values from?
23:30:08 <solidus-river> oh yeah! my space invaders game moves finally
23:30:40 <solidus-river> and wires are the hardes thing i've ever had to grasp so far
23:36:37 <solatis> what are my options in haskell if i want a "simple" distributed job queue?
23:37:05 <trap_exit> how many years are we away from COq-like fully dependent types in haskell?
23:37:27 <trap_exit> solatis: probably haskell bindings to zeromq or rabbitmq
23:37:28 <bitemyapp> such questions
23:37:39 <solatis> trap_exit: that's exactly what i was thinkng
23:37:49 <bitemyapp> solatis: How big is the job queue?
23:37:53 <solatis> i was currently toying around with cloud haskell
23:37:55 <bitemyapp> solatis: RabbitMQ is not a job queue, it is a message queue.
23:38:02 <solatis> yeah i know
23:38:06 <solatis> same as with 0mq
23:38:19 <bitemyapp> I have a hard time thinking of 0mq as even a message queue, but sure.
23:38:20 <solatis> i just need pub/sub functionality
23:38:30 <bitemyapp> solatis: how many jobs in flight at a time?
23:38:44 <bitemyapp> solatis: how many must the system support having backed up and waiting for processing?
23:38:44 <trap_exit> 0mq, I've heard is tcp/ip sockets on crack, heorin, meth + whatever wonder drug Lucy is taking
23:38:58 <Iceland_jack> You've heard right
23:39:00 <bitemyapp> solatis: give me an order of magnitude.
23:39:07 <solatis> bitemyapp: small
23:39:16 <bitemyapp> solatis: just use RabbitMQ and read the documentation CAREFULLY
23:39:24 <solatis> message delivery is not required to be guaranteed, or even in order
23:39:34 <solatis> it's for a crawler framework
23:40:27 <solatis> twitter's Storm framework would actually be perfect for this, but that's way too focussed on JVM and doesn't have good non-java bindings
23:40:36 <bitemyapp> Storm is something other than a message or job queue.
23:40:42 <solatis> yeah i know
23:40:44 <bitemyapp> it's a real time data processing topology.
23:40:46 <solatis> it's stream processing
23:40:49 <solatis> yeah
23:40:50 <bitemyapp> Kafka would be an in-betweener.
23:41:00 <solidus-river> thats... intersting.. GLFW-b bindings dont seem to recognize a lot of the keys as the keys they are
23:41:03 <bitemyapp> solatis: you could fix up tcrayford's kafka bindings :P
23:41:12 <solatis> which is actually what my application is -- it's just actually one big stream with a lot of transformations
23:41:32 <solidus-river> it gets Key'Left and key'Right bu tkey'Up is not the up arrow and Key'Down is not the down arrow
23:41:32 <haasn> What's the difference between a message queue and a job queue? I'm unfamiliar with these terms
23:41:37 <trap_exit> solatis: I think the right thing to do
23:41:50 <trap_exit> solatis: is to do it in cloudhaskell, write whatever other libs, you need, and open source those other libs :-)
23:41:51 <solatis> haasn: message queue is a subset of a job queue
23:41:55 <trap_exit> in my completely unbiased opinion
23:42:11 <solatis> trap_exit: haha yes, that would be the pragmatic approach right ? :p
23:42:30 <trap_exit> solatis: that would be the optimize for trap_exit's future productivity approach
23:42:39 <trap_exit> whether it takes you 10x longer is irrelevant :-)
23:42:50 <trap_exit> make sure the libraies have good docs + neatly writrten examples / tutorials
23:42:50 <solatis> yes, that's what i was thinking
23:42:57 <solidus-river> nvm, i'm dumb
23:43:12 <solatis> maybe port twitter's Storm as a framework on top of cloud haskell
23:43:25 <solatis> and then profit
23:43:29 <trap_exit> what's so great about storm?
23:43:34 <trap_exit> isn't it just a graph + a push system ?
23:43:55 <solatis> you can describe topologies
23:44:05 <solatis> you submit those topologies to storm
23:44:08 <trap_exit> where by topolgies you mean graphs
23:44:11 <solatis> yes
23:44:27 <solidus-river> what is this cloud haskell people keep throwing around
23:44:34 <haasn> solidus-river: distributed-process
23:44:46 <trap_exit> it's the most amazing thing ever
23:44:46 <trap_exit> it means that you can write a single haskell app
23:44:53 <trap_exit> that repreesnts a datacetenter as 1 machine
23:44:53 <solatis> solidus-river: http://haskell-distributed.github.io/
23:45:31 <solidus-river> does it actually work out that way?
23:45:38 <solatis> no, of course not
23:45:42 <trap_exit> dunno, never used it yet
23:45:44 <trap_exit> only read about it
23:45:45 <solatis> :)
23:45:46 <trap_exit> but it sounds badass
23:46:08 <trap_exit> like all of haskell, it's a feature which sounds great on paper,
23:46:09 <solatis> it's kind of like erlangs message passing framework for haskell
23:46:10 <solidus-river> trap_exit: heh,
23:46:11 <trap_exit> will probably be performant in 5 years
23:46:17 <trap_exit> and 10 years later, every other langauge will copy it
23:46:36 <solidus-river> trap_exit: having not looked at it at all it sounds like a scary promise and my instinct tell me to seek out the 0mq bindings for haskell and work from there
23:46:45 <solatis> i find it extremely difficult to write code that goes from master -> slave a -> slave b -> slave c -> slave d -> collect
23:47:07 <solatis> it's easy to write code that goes master -> slave a -> collect -> master -> slave b -> collect -> etc
23:47:17 <trap_exit> solatis: 0mq has a great handbook/tutorial too
23:47:26 <solidus-river> trap_exit: it sounds amazing though o_o
23:47:28 <solatis> yeah i have had experience with 0mq in the past, a lot
23:47:30 <trap_exit> it's on my todo list even though I don't need 0mq yet
23:47:47 <solidus-river> solatis: read through 0mq's tutorial online before you plan your system, you'll be a happier coder in a month or two
23:47:52 <trap_exit> solatis: I've alias you as 0mq_wizard
23:47:59 <solidus-river> tutorial / doc
23:48:11 <solatis> solidus-river: i actually already have years of experience with 0mq in a large distributed c++ app
23:48:25 <solidus-river> then you'll be at home :) haskell bindings translate directly
23:48:30 <solatis> ok good
23:48:32 <solidus-river> directly-ish
23:48:41 <solatis> the docs of the bindings suck for a newbie tho
23:48:53 <solatis> and rabbitmq i never trust
23:49:04 <solatis> it makes claims that don't add up
23:49:39 <solatis> as soon as you start with federations, the guarantees it claims to give don't hold up anymore
23:50:03 <solidus-river> rabbitmq is not very awesome to work with, my last two jobs have used it and its been terrible
23:50:34 <solatis> yes that is my experience too
23:50:39 <solidus-river> along with redis, they can all go sit in the corner while people learn to think abou their job queues instead of throwing pre-built generic stuff at the problem
23:50:41 <solatis> nice idea, but unstable
23:51:24 <solatis> read this: http://aphyr.com/posts/315-call-me-maybe-rabbitmq
23:51:44 <fho> @lambdabot quote The cleanness is so ubiquitous it removed dirt from my keyboard.
23:51:45 <lambdabot> Unknown command, try @list
23:51:48 <solatis> that guy is very smart, and "destroying" all the claims rabbitmq claims to make
23:52:53 <solatis> lots of race conditions etc
23:53:10 <ReinH> I love his stuff
23:53:35 <solidus-river> ahh, culmination of almost 8 months of learning, a 2d spaciship moves at constant velocity around a screen
23:53:54 <solidus-river> lol
23:54:12 <solidus-river> solatis: yeah, that guy is smart but sometimes i think he confuses things
23:54:44 <solidus-river> solatis: he's made quite a few posts destroying distributed solutions but what it really boils down to is making a distributed system is hard, and coding one is hard and people involved need to take care
23:54:53 <solatis> yep
23:55:10 <solatis> but if rabbitmq is vulnerable to data loss (which he proved), it is important to know
23:55:24 <solidus-river> so's elasticsearch, but githubs still chuggin away on it :P
23:55:36 <solatis> yep
23:55:57 <solatis> and linkedin, etc
23:56:09 <solatis> but it is important to know the tradeoff
23:57:13 <solatis> especially for example etcd claiming to be a service for distributed locking -- you want that to be correct, and battle-proven
23:58:22 <solidus-river> aye, guess i'm still upset at him because he almost convinced the CTO at my work that we should build for Solr instead
23:58:30 <solidus-river> no one wants that alternative
23:58:39 <solidus-river> :)
23:59:16 <solatis> haha
23:59:37 <solatis> no, just get a support contract with the guys of elastic search
