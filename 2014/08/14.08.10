00:28:22 <benzrf> bye
00:31:38 <trap_exit> greatness
00:36:29 <dfeuer_> @tell carter I couldn't get the types to work out with the sized list, but I managed with a simple empty/nonempty version. The fusion on the consumption side looks very pretty.
00:36:29 <lambdabot> Consider it noted.
00:38:08 <dfeuer_> @tell carter the empty/nonempty GADT is really a cheat to make a type of nonempty lists that has the same representation as regular lists.
00:38:08 <lambdabot> Consider it noted.
00:51:52 <trap_exit> @tell trap_exit test
00:51:52 <lambdabot> You can tell yourself!
00:52:13 <trap_exit> @tell lambdabot good bot
00:52:13 <lambdabot> Nice try ;)
00:52:24 <c_wraith> @botsnack
00:52:24 <lambdabot> :)
00:54:03 <trap_exit_> @tell trap_exit test
00:54:03 <lambdabot> Consider it noted.
01:01:15 <trap_exit> @msgs
01:01:15 <lambdabot> Not enough privileges
01:01:39 <trap_exit> ah, @message, this is very cool
01:01:46 <genisage> is there a good way to catch an exception for a failed  pattern match in a let binding?
01:02:20 <genisage> Or do I just have to avoid ever letting a pattern match in a let fail?
01:02:41 <trap_exit> I don't understand your question. I just stick a _ -> error "failed"
01:02:45 <trap_exit> at the end of case statements
01:03:05 <genisage> I mean if I say let (x:xs) = f y in ...
01:03:14 <genisage> and f y happens to be []
01:03:25 <genisage> Is there some way to bail out and do something else.
01:04:38 <trap_exit> case (f y) of (x :xs) -> ... _ -> .... hmm
01:04:41 <trap_exit> but you don't want the case statement
01:05:00 <genisage> I have nothing against case statements.
01:05:50 <genisage> I didn't know they did pattern matching.
01:06:22 <trap_exit> learn from me!
01:06:26 <trap_exit> I'm a level 2 haskell newb now :-)
01:07:47 <genisage> thanks for the help.
01:10:16 <trap_exit> genisage: feel free to ask any other questions, I owe #haskell quite a bit for all the help I get :-)
01:11:25 <genisage> can you help me get rid of some of the calls to best in this http://lpaste.net/108471 ?
01:11:47 <genisage> pisa is just hanoi with four towers.
01:12:21 <trap_exit> hmm
01:12:27 <trap_exit> are you asking an algorithms question or a haskell question?
01:12:34 <trap_exit> I actually don't udnerstand what algorithm you're implementing
01:12:37 <genisage> algorithms
01:12:47 <genisage> Did you do the yorgey course?
01:13:04 <trap_exit> no
01:13:13 <genisage> Ah, nevermind then.
01:13:33 <tabemann> @where yorgey
01:13:33 <lambdabot> http://www.seas.upenn.edu/~cis194/lectures.html
01:14:08 <trap_exit> yeah, sorry about that
01:14:28 <genisage> no problem, it works, I'm just pretty sure it's doing more work than it has to.
01:23:43 <trap_exit> how do I create a type for somethign that is just like an Int
01:23:44 <trap_exit> but not compatible with an Int
01:23:54 <trap_exit> i.e. I want to create something called FooIndex
01:23:54 <trap_exit> which is just an Int
01:24:03 <trap_exit> but I can't do "type FooIndex = Int"
01:24:07 <trap_exit> becasue I don't want FooIndex / Int to be exchangeable
01:24:12 <tabemann> newtype Foo = Foo Int
01:24:56 <c_wraith> If you want arithmetic to work, too, use GeneralizedNewtypeDeriving and derive Num
01:25:07 <tabemann> note to do Int-ish things with it, you'll need to pattern match on it to extract the Int from it
01:25:09 <trap_exit> hmm
01:25:21 <tabemann> but isn't GND *bad*?
01:25:21 <trap_exit> tabemann, c_wraith: thanks
01:25:50 <c_wraith> tabemann: no.
01:26:19 <c_wraith> tabemann: in fact, I believe that as of GHC 7.8, all the weird cases have been forbidden by the role system
01:26:22 <tabemann> I heard that there were essentially bugs in GND that could cause crashes in corner cases and which allowed things like deriving unsafeCoerce
01:27:10 <c_wraith> but using GND to derive Num was never a problem
01:27:32 <trap_exit> tabemann vs c_wraith ... round 1 .... fight!
01:27:46 <c_wraith> I lose, because I'm going to bed! :)
01:27:51 <tabemann> so it's been all fixed in 7.8 with roles
01:38:03 <genisage> bye
01:44:01 <trap_exit> when writing anonymous functions, is there an easier way to write (\x -> case x of .... )
01:44:58 <pavonia> \case ...
01:45:55 <pavonia> (requires -XLambdaCase)
02:01:09 <zebr> hi all. `data None deriving (Eq, Show)` gives me an error "Can't make a derived instance of `Eq None': `None' must have at least one data constructor"
02:01:18 <zebr> why is that? surely deriving for the zero case is trivial?
02:03:05 <zebr> (i've had to define by hand `show _ = undefined` etc :p)
02:05:14 <trap_exit> hm
02:05:23 <trap_exit> is nond edefined as "data None = None"
02:05:23 <trap_exit> or "data None" ?
02:05:30 <zebr> the latter
02:06:27 * hackagebot safe 0.3.8 - Library of safe (exception free) functions  http://hackage.haskell.org/package/safe-0.3.8 (NeilMitchell)
02:07:54 <trap_exit> yeah
02:08:00 <trap_exit> then it's imposislbe ot define None -> None -> Bool
02:08:04 <trap_exit> or None -> String
02:08:06 <trap_exit> since you can't construct an object of type NOne
02:08:08 <zebr> trap_exit: it isn'
02:08:19 <trap_exit> for example, define a function None -> String
02:08:32 <zebr> trap_exit: it isn't; i have `show _ = undefined` and `_ == _ = undefined`, both of which are fully defined, as it were
02:08:59 <trap_exit> I'm asking for a function of type "None -> String"
02:09:25 <pavonia> Not very useful instances, though
02:09:27 <zebr> (\_ -> undefined) :: None -> String
02:09:50 <trap_exit> hmm
02:09:50 <trap_exit> I lose
02:09:51 <trap_exit> sorry baout that
02:11:16 <m> () -> String, it would be a constant
02:11:25 <m> \_ -> "result"
02:11:41 <m> unless you want the function that dos IO
02:12:00 <m> like getCurrentDirectory :: IO String
02:12:33 <trap_exit> m: how did you get a 1 char user name?
02:12:52 <zebr> pavonia: they are kind of useful: i can then derive Show and have (show :: Tree None), which is (say) the tree with no leaves.
02:12:55 <m> by chance, I didn't setp anything
02:13:58 <zebr> derive Show for (Tree a), that is.
02:14:06 <pavonia> zebr: But you can't show that tree either, can you?
02:14:19 <Pythonfant> zebr: wouldn't that be a tree with leaves off type None instead of a tree with no leaves (ofc because you can't construct None it's the same here)
02:14:36 <zebr> Pythonfant: well, yes, but since you can't construct it there aren't any
02:14:57 <zebr> Pythonfant: you can, yes
02:15:02 <zebr> * pavonia
02:15:23 <pavonia> How so?
02:17:12 <zebr> well, say we have `data Tree a = Branch (Tree a) (Tree a) | Leaf a | CatSaying String`. we can have (Branch (CatSaying "mew") (CatSaying "mrow") :: Tree None), and show it.
02:18:00 <zebr> if you remove the alternative terminal you just have an infinite showable tree :p
02:19:13 <pavonia> Oh well, that's a strange Tree definition
02:20:31 <zebr> pavonia: well, like i say, if we have `data Tree a = Branch (Tree a) (Tree a) | Leaf a deriving Show` then `take 100 . show :: Tree a -> String` is well-defined.
02:20:45 <zebr> or rather, Tree None -> String
02:21:23 <pavonia> But that's not useful either, IMO :p
02:22:28 <zebr> the actual case i have is where i have two terminals, like in the earlier example, and i want to show that one of those types of leaves can't exist
02:23:33 <zebr> but i still want to be able to print the tree, which is fine, because None can't actually occur. so being able to derive for a zero-constructor type makes perfect sense
02:26:24 <zebr> ah, i've found a ticket for this: https://ghc.haskell.org/trac/ghc/ticket/7401
03:02:18 <Darwin226> I've upgraded to the new haskell platform and hdevltools no longer work. When I want to install the package the missing dependency is process ==1.1.* but process-1.1.0.2 fails to install with "System\Process\Internals.hs:363:30: Not in scope: `unsafePerformIO' Failed to install process-1.1.0.2"
03:02:28 <Darwin226> Can anyone offer some assistance?
03:06:06 <pavonia> Darwin226: Isn't process part of the platform?
03:06:22 <Darwin226> I'm guessing hdevtools requires an older version or something
03:07:02 <pavonia> I'd download the source, edit the .cabal file and try if it compiles with the latest process version
03:07:14 <Darwin226> Ok, I'll try that
03:23:41 <copumpkin> is there a simple applicative xml parser anywhere?
03:26:19 <Darwin226> pavonia: It now says that Setup.hs: At least the following dependencies are missing: cmdargs -any, ghc-paths -any
03:26:35 <Darwin226> pavonia: But when I try "cabal install cmdargs" it says it's already installed
03:28:13 <pavonia> Darwin226: That's weird. How do you build?
03:28:36 <Darwin226> pavonia: I did runhaskell Setup.hs configure
03:29:08 <pavonia> Ah, run "cabal install" in the directory of the Setup file
03:29:26 <haasn> copumpkin: There's one based on Arrows which seems related
03:29:34 <haasn> You could probably wrap an applicative around it
03:30:29 <copumpkin> haasn: yeah, saw that
03:30:35 <copumpkin> just surprises me that there's nothing simpler
03:31:08 <copumpkin> generally code using arrows = nobody's done much with it in the past few years :P
03:31:29 <shachaf> copumpkin wants profunctor-based parsers
03:32:28 <zereraz> hello people, there is type error here http://lpaste.net/109157 , what do I do?
03:32:49 <zereraz> Couldn't match type `()' with `Char'
03:32:49 <zereraz> Couldn't match type `IO' with `[]'
03:33:00 <Darwin226> pavonia: Well, that worked but it doesn't compile. Errors like "src\Info.hs:130:59:     Not in scope: data constructor `GHC.MatchGroup'     Perhaps you meant `GHC.DocGroup' (imported from GHC)". Anyways, I guess I'll have to wait till the maintainer updates it or revert to 2013
03:33:11 <shachaf> zereraz: Start by figuring out what type you want it to have.
03:33:29 <shachaf> Then write that type down, and GHC will probably give you better errors.
03:33:32 <zereraz> :t mapM_
03:33:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
03:34:09 <Pythonfant> zereraz: so you want to print hello world n times?
03:34:15 <zereraz> Pythonfant: yes
03:34:31 <shachaf> Do you know what type you want it to have?
03:34:40 <zereraz> shachaf: I am little confused
03:34:51 <zereraz> shachaf: I am using an online question thingy
03:35:17 <zereraz> shachaf: so they are going to handle the main, but it seems they just call my function in main = do
03:35:41 <zereraz> so I think the type should be Int->IO()
03:36:04 <shachaf> That looks like a reasonable type.
03:36:23 <Pythonfant> zereraz: so which type has your base case?
03:36:44 <shachaf> So that means that (hello_worlds 0) and (hello_worlds n) must both have type IO ()
03:36:47 <shachaf> (Where n has type Int.)
03:37:01 <copumpkin> shachaf: or that
03:37:04 <zereraz> yes
03:37:08 <copumpkin> oh well, time for train
03:37:09 <copumpkin> bbl
03:37:31 <Darwin226> Looks like I'm not the only one https://github.com/bitc/hdevtools/issues/24
03:37:34 <zereraz> Pythonfant: my base is the problem ?
03:37:45 <zereraz> Pythonfant: as it returns a [char] ?
03:37:52 <Pythonfant> that's certainly one problem
03:38:10 <Pythonfant> your base case has type Num a => a -> [String]
03:38:16 <Pythonfant> (not [char])
03:38:22 <zereraz> Pythonfant: yeah
03:38:32 <zereraz> so what do i do?
03:38:59 <Pythonfant> it looks like you are trying to build up a list and printing it at the same time which won't work
03:39:13 <Pythonfant> you could try expanding something like hello_worlds 4 to see the problem
03:39:15 <zereraz> Pythonfant: I am building with recursion
03:39:20 <Pythonfant> I know
03:39:26 <zereraz> so I'll shift printing to another function
03:39:36 <Pythonfant> either that or you remove the lift building
03:39:54 <Pythonfant> s/lift/list/
03:40:00 <zereraz> Pythonfant: I want to practice this way, but what other ways do you suggest
03:43:46 <zereraz> http://lpaste.net/109157
03:43:50 <zereraz> still not working
03:44:01 <zereraz> why is there expected type Char?
03:44:15 <Pythonfant> zereraz: something like http://lpaste.net/109157
03:44:22 <Pythonfant> oh crap sorry I edited your paste
03:44:45 <zereraz> Pythonfant: no problem
03:45:05 <zereraz> http://lpaste.net/109160
03:46:09 <Pythonfant> :t :
03:46:10 <lambdabot> parse error on input ‘:’
03:46:13 <Pythonfant> :t (:)
03:46:14 <lambdabot> a -> [a] -> [a]
03:46:23 <zereraz> oh
03:46:39 <Pythonfant> you don't need to enclose "Hello World" in a list
03:46:43 <Pythonfant> if you are trying to prepend it
03:46:52 <zereraz> yeah got it
03:46:58 <zereraz> i could have done ++ too right
03:47:21 <Pythonfant> you could but if you can get away with (:) it's probably a good idea to use it
03:47:35 <zereraz> Couldn't match expected type `Int -> IO ()'
03:47:35 <zereraz> Couldn't match expected type `[a0]'
03:47:36 <Pythonfant> zereraz: you are also missing some paranthesis
03:47:47 <zereraz> Pythonfant: like?
03:48:02 <Pythonfant> listBuilder (n-1)
03:48:05 <zereraz> oh
03:48:08 <zereraz> yeah
03:48:13 <Pythonfant> and mapM_ print (listBuilder n)
03:48:23 <zereraz> yeah thanks
03:48:35 <Pythonfant> and you are probably going to print it one time too often
03:48:51 <zereraz> I am always confused when haskell assumes there is parenthesis and when we have to put them explicitly
03:49:29 <shachaf> Err on the side of writing too many. You can always take them out.
03:49:43 <shachaf> And remember that function application -- like "f x" -- is stickier than any operator.
03:49:53 <shachaf> So "f x+1" always means "(f x)+1"
03:49:56 <zereraz> shachaf: ok
03:50:01 <zereraz> oh
03:50:47 <Ainieco> hello, is it possible to install transformers 0.4.1.0 with ghc 7.8.3?
03:50:58 <zereraz> it worked, thanks Pythonfant shachaf
03:51:02 <Pythonfant> np
03:51:05 <kuribas> A question about "where" scope: is where sensitive to indentation, or does it always have the whole function as scope?
03:51:20 <Ainieco> conflict: ghc => transformers==0.3.0.0/installed-16a..., mylib => transformers==0.4.1.0
03:51:25 <Ainieco> what this all about?
03:51:59 <abc56889> if I have `data Foo a b = Bar a b | Baz a b`, is there any way to convert a Bar a b into a Baz a b?
03:52:17 <abc56889> (without unpacking it explicitly, just taking advantage of the equal number of arguments)
03:52:23 <shachaf> Not really.
03:52:38 <Ainieco> hello?
03:54:01 <Ainieco> http://vpaste.net/ZOJ1R
03:54:26 <Ainieco> does it reject's ghc becuase of transformers?
03:56:43 <tremon> kuribas: it has the whole definition as scope. Roughly, "where" is matched to the defining '='. That doesn't have to be a function definition, it can also be a let clause
03:57:45 <Ainieco> anyone?
03:57:51 <Ainieco> should i ask at #ghc?\
03:58:14 <zenzike> can anyone confirm that ghc's -M parameter does *nothing* for values after, say, 10m?
03:58:48 <kuribas> tremon: thanks, that's what I wanted to know.
03:59:21 <shachaf> zenzike: Makefiles?
03:59:25 <shachaf> Or do you mean the RTS option?
03:59:38 <zenzike> shachaf: I mean RTS option
04:00:03 <zenzike> ie, when I do ./main +RTS -M10m I expect my program to grow no bigger than 10 megabytes in size
04:00:16 <zenzike> but it's swamping over 2G
04:00:16 <augur> how can i set a foreign point in haskell?
04:00:20 <augur> whats the analog of something like
04:00:53 <augur> void set(Foo* x) { *x = someFoo; }
04:03:11 <augur> actually, what i really have is something more like
04:03:37 <augur> void copyPtr(Foo* x, Foo* y) { *x = *y; }
04:05:57 <augur> ahh actually nevermind
04:12:00 <RchrdB> augur, Foreign.Ptr and Foreign.Storable have what I think it is that you're after.
04:12:25 <Ainieco> hello?
04:12:43 <RchrdB> augur, e.g. set :: Ptr Int -> IO (); set x = poke x someFoo;
04:12:58 <augur> RchrdB: i was actually looking for a way to write one of those "mutate and return a flag" functions in haskell
04:13:09 <augur> RchrdB: but i wanted to phrase the issue more minimalist-y :P
04:13:25 <augur> anyway, i figure i can return a pointer and check if its null in C, so that works out better
04:13:40 <RchrdB> M'okay.
04:13:58 <RchrdB> Other thing you could use would be an IORef.
04:14:03 <RchrdB> Ainieco, hello. :)
04:14:45 <Ainieco> RchrdB: are you familiar with transformers and ghc783?
04:15:05 <Ainieco> http://vpaste.net/ZOJ1R does it says something to to anyone?
04:23:23 <Ainieco> looks like this question is really hard
04:25:05 <RchrdB> Ainieco, I think that your problem there is that you've declared in your .cabal file that you want your library to depend on version 0.4.1.0 of transformers, but you've already got 0.3.0.0 installed.
04:27:03 <Ainieco> RchrdB: yup, and i haven't installed 0300 explicity, it's part of ghc 783 apperantly
04:27:23 <Ainieco> so, do it means that ghc 783 doesn't support transformers 0410?
04:27:33 <RchrdB> Ainieco, AIUI you can't upgrade the libraries that come with GHC itself other than by installing another version of GHC. You should probably just see if your code works with 0.3.0.0 and relax the dependency you've declared on transformers to ">= 0.3.0.0"
04:28:50 <Ainieco> RchrdB: new criterion doesn't works with 0300 transformers, there are some shady stuff with transofrmers-compat in one of its deps and it require transformers >= 041
04:29:13 <Ainieco> i guess it just need to stick to 0300 until new version of ghc
04:31:25 <RchrdB> Ainieco, actually, I think I'm wrong about that and it's possible to upgrade more of those libraries than I think.
04:32:10 <pavonia> Why isn't haddock part of the platform anymore?
04:32:19 <mzero> it is
04:32:32 <RchrdB> Ainieco, ah, are you using a cabal sandbox, sorry?
04:32:49 <Ainieco> RchrdB: yep
04:33:03 <mzero> pavonia: did something lead you to think it wasn't?
04:33:17 <pavonia> It isn't listed here anymore https://www.haskell.org/platform/changelog.html
04:33:50 <mzero> ah - bother - that is because it moved from being "platform added" to "ghc supplied"
04:34:05 <mzero> and ... there is no "Tools, Provided with GHC" section yet...
04:34:06 <mzero> fie
04:34:16 <RchrdB> Ainieco, *oh* I see what the actual problem is. Sorry for being confusing earlier.
04:34:50 <Ainieco> RchrdB: np
04:35:05 <RchrdB> Ainieco, you could install a new transformers into your cabal sandbox, but what the error message is explaining is that, the doctest library that you want to use depends on the `ghc` package, and the `ghc` package has a dependency on the installed version of transformers.
04:35:11 <pavonia> mzero: Ah, okay
04:35:27 <RchrdB> Ainieco, so you can't have both of `new version of transformers` and also `use the current installed version of ghc`
04:35:38 <RchrdB> (at least, not linked into the same program)
04:36:09 <RchrdB> Ainieco, this probably didn't come up before because ghc version 7.6 doesn't depend on the transformers library but ghc version 7.8 does.
04:37:08 <RchrdB> Ainieco, and *ghc* itself can't be updated without installing a new... ghc. :)
04:37:12 <Ainieco> RchrdB: yeah, got similar answer on #ghc just 1-2 minutes ago :)
04:37:36 <Ainieco> so i'll wait for new ghc and stick with old criterion until then
04:37:48 <Ainieco> thank you!
05:09:51 <mzero> pavonia: change log page updated
05:15:14 <sohum> is there a clean way to generalise (==) :: a -> a -> Bool to some f a -> f a -> f Bool ?
05:15:34 <sohum> I'm not precisely sure what semantics it should have yet - I'm just curious if it looks familiar to anyone
05:16:06 <vanila> sohum, there's a completely generic way to go from a -> b -> c to f a -> f b -> f c
05:16:30 <vanila> I dont think there's any special/alternative way to build f a -> f a -> f Bool when starting from (==) though
05:17:30 <sohum> vanila: you mean fmap, right? the problem here is that fmap requires (b -> c) -> (f b -> f c) to also be a useful/definable thing...
05:17:48 <vanila> not fmap
05:18:06 <vanila> although well it's ju st a couple fmaps together
05:18:29 <vanila> :t liftA2 (==)
05:18:30 <lambdabot> (Applicative f, Eq b) => f b -> f b -> f Bool
05:18:57 <vanila> :t \x y -> fmap (fmap (==) x) y
05:18:58 <lambdabot> (Functor f, Eq a1) => (a -> a1) -> f a -> f (a1 -> Bool)
05:19:08 <vanila> ah that didn't work
05:19:14 <sohum> @src liftA2
05:19:14 <lambdabot> liftA2 f a b = f <$> a <*> b
05:19:37 <mmmm> What is a "type instance"?
05:19:39 <vanila> maybe it can'tb edone with fmap
05:19:41 <sohum> :t fmap . pure
05:19:42 <lambdabot> Functor f => a -> f a1 -> f a
05:19:55 <sohum> uh, not exactly
05:20:02 <sohum> but it's the fmap path, yea
05:22:50 <RchrdB> vanila, indeed, it can't be done with just `fmap` because you need something like `ap` to put the second argument in, which is what the Applicative typeclass gives you.
05:23:13 <RchrdB> (liftA2 (==)) is just what you want.
05:24:12 <sohum> RchrdB: the problem is that I can't define a useful functor instance on this thing, even a restricted functor
05:24:58 <vanila> what is the thing?
05:25:33 <sohum> trying to embed some portions of sql into the haskell type system
05:26:00 <sohum> so, for instance, I know that (==) should correspond to sql =, and that they have "corresponding" types for some definition of corresponding
05:26:11 <sohum> but I can't do that transformation generically
05:28:36 <RchrdB> sohum, in your shoes, I'd ditch the existing (==) operator, avoid trying to use *any* of the existing typeclasses in order to have nice syntax overloads, and write everything in a big GADT that you interpret.
05:28:56 <RchrdB> call the thing that corresponds to sql's "=" operator ":=" or something.
05:29:45 <sohum> RchrdB: that's the solution esquelto et. al have gone with, yea. I'm just trying to see if that is actually necessary or not
05:30:08 <RchrdB> oh I see
05:30:17 <RchrdB> I was about to point you to eqsueleto :)
05:30:25 <vanila> you could use (==) = (:=)
05:30:52 <sohum> RchrdB: for instance, Num works fine - (+) :: Num a => a -> a -> a generalised handily to a Q Numeric -> Q Numeric -> Q Numeric
05:31:20 <sohum> vanila: shadowing the existing (==) would seem to be Very Bad Practice :p
05:31:38 <RchrdB> (==) is a bit problematic, because it would have to have a type like (Q a -> Q a -> Bool) to fit the Eq class.
05:31:38 <sohum> RchrdB: haha, yeah, this is borne out of looking at esqueleto and being unsatisfied :p
05:31:48 <sohum> yes, exactly
05:31:54 <vanila> what's bad about it?
05:32:31 <sohum> about shadowing Prelude functions with a completely different function?
05:32:46 <sohum> or were you asking why I was unsatisfied with esqueleto?
05:34:31 <RchrdB> I'm interested in what it is about esqueleto that you want to improve on.
05:34:48 <sohum> for one thing, I'd much rather it didn't have a dependency on Persistent
05:35:04 <sohum> that's the major thing, really
05:36:22 <RchrdB> I assumed that the dependency on Persistent is mostly there so that users can smoothly upgrade to equeleto after starting a project with Persistent?
05:36:48 <sohum> well, you need to specify your database tables in the Persistent DSL
05:37:19 <sohum> which... is limiting
05:39:06 <sohum> I much prefer my database to be the source of truth about its types; there are some solutions that use a two-step compile to get the database types into haskell, and that seems like more the right solution, to me
05:47:44 <RchrdB> sohum, I think I've heard of "type providers" in F# being a way that people do that?
05:48:16 <RchrdB> sohum, this sounds like a thing that you might want to do with template haskell? :)
05:48:37 <sohum> yea, absolutely
05:49:01 <sohum> and I _think_ that bit exists, inasmuch as I was reading that haskelldb lib correctly :p
05:49:14 <RchrdB> (I don't know much about F# except from hearing about some of the things that the F# community make by reading lobste.rs or whatever)
05:49:39 <sohum> it's just - if I'm gonna do this, I'd like it to have a nicer syntax than esqueleto, too :p
05:49:48 <sohum> so I decided to poke at the pure bits first
05:50:40 <ifesdjeen> does anyone know a good tutorial on how to combine monads (newtype, class) to combine a monad that should have properties of State, IO and Resource?...
05:51:56 * hackagebot cabal-lenses 0.3 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.3 (DanielTrstenjak)
05:52:14 <Pythonfant> ifesdjeen: the thing you're looking for are probably monad transformers
05:52:49 <ifesdjeen> Pythonfant: not really, TBH. I'm already familiar with transformers, I need to build that "custom monadic stack", let me show an example
05:53:19 <Pythonfant> ifesdjeen: ah than you know probably know a lot more about haskell than me :)
05:53:25 <RchrdB> sohum, could you, um, make all the functions in a giant GADT that you interpret with names like `:==` and then provide a TH quasiquoter that parses an expression with tokens like `==` in it? :)
05:53:26 <ifesdjeen> https://github.com/jeremyjh/higher-leveldb/blob/master/src/Database/LevelDB/Higher.hs#L161-L201
05:53:49 <sohum> ohgodpossibly
05:53:59 <ifesdjeen> Pythonfant: hah, i'm pretty bad in Haskell TBH :) still a bunch to learn
05:54:35 <vanila> ifesdjeen, I think that is exactly what monad transformers are for
05:54:42 <vanila> unless you want to do it manually for learning
05:54:46 <sohum> that, um, seems scary and I would like to not do it :p
05:55:14 <sohum> RchrdB: basically, I'm just wondering if any useful notion of "generalised equality" already exists that I can piggyback off
05:56:01 <ifesdjeen> vanila: not exactly.. monad transformers are mostly for combining monad results, in a way. What i want is to be able to use properties of both monads within a single do block, kind of
05:56:32 <vanila> ifesdjeen, So you want the same thing as monad transformer stack, but without having to type lift?
05:57:39 <vanila> maybe just have a skim of http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf in case they really can do what you want
05:57:44 <ifesdjeen> vanila: pretty much. i want to make a class (MonadState m, MonadResource m, MonadIO m... ) => MyMegaMonad m ...
05:59:06 <ifesdjeen> i'm mostly bothered with the fact I always have to `runResourceT`, I wanted to hide it away
05:59:44 <vanila> you could write a single run function that has runResourceT and all the other stuff in it?
05:59:47 <vanila> that's what I always do
06:00:06 <ifesdjeen> will try to do it, maybe that'd be a solution.
06:00:09 <ifesdjeen> thank you vanila
06:01:57 * hackagebot rethinkdb-client-driver 0.0.0.2 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.0.2 (wereHamster)
06:04:38 <ab9rf> i find myself doing that sort of abstraction fairly frequently of late
06:05:19 <ab9rf> although i'm not bothered by having to use lift
06:13:08 <mjrosenb> wow, I'm just running into so many cabal packages that won't build :-(
06:14:14 <ab9rf> i forced a cabal install yesterday
06:14:33 <ab9rf> probably broke yesod but i'm not using yesod at the moment anyhow
06:15:16 <mjrosenb> SDL isn't building for me :-(
06:15:41 <ab9rf> i've never been able to get SDL to "work" for me even when it does build
06:16:44 <mjrosenb> also, grapefruit
06:17:53 <ab9rf> i just replaced a lot of complicated code with a much simpler invocation of liftM2
06:18:14 <Philonous> Must be one heck of a monad.
06:18:22 <ab9rf> not really
06:18:31 <ab9rf> just me being stupid when i wrote the original code
06:20:19 <mjrosenb> ab9rf: that happens a lot.
06:20:41 <mjrosenb> also, darcs doesn't build, iirc.
06:21:27 <ab9rf> the use of mplus was not intuitive to me, and i'm just starting to get the hang of it
06:21:56 <Philonous> mplus of what monad?
06:21:59 * hackagebot JuicyPixels 3.1.6 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.6 (VincentBerthoux)
06:22:03 <ab9rf> Philonous: in this case, Maybe
06:22:06 <mjrosenb> http://bpaste.net/show/588182/
06:22:16 <mjrosenb> mplus is awesome
06:22:29 <Philonous> ab9rf, Oh, right. mplus and mappend diasgree on Maybe, don't they?
06:22:32 <mjrosenb> ab9rf: Maybe was the monad that finally helped me grok monads in general.
06:22:33 <Philonous> Trips me up every time
06:22:44 <ab9rf> Philonous: possibly, i haven't used mappend much at all
06:23:11 <ab9rf> Philonous: certainly not in any "real code"
06:23:45 <MayK> Is there a codecademy-equivalent for Haskell?
06:23:47 <Philonous> (Just [3]) `mplus` (Just [5]) ==> Just [3]
06:23:50 <ab9rf> mjrosenb: maybe and [] are certainly better ones to try to understand than IO....
06:23:57 <Philonous> (Just [3]) `mappend` (Just [5]) ==> Just [3,5]
06:24:22 <mjrosenb> Philonous: you can also use lambdabot for that :-)
06:24:23 <MayK> (I mean something webbased, so that I can learn while I have some downtime at work.)
06:24:46 <ab9rf> MayK: fpcomplete.com has something along those lines, iirc
06:24:59 <MayK> Thanks, ab9rf.  I will check it out.
06:25:14 <ab9rf> MayK: no endorsement, just something i've stumbled across.
06:25:43 <Philonous> mjrosenb, AH, I had ghci handy, and I'd rather use that than wrangle lambdabot (and posisbly humiliate myself by getting it wrong a few times)
06:25:52 <mjrosenb> > let tryBoth x y = (x `mplus` y, x `mappend` y) in tryBoth (Just 3) (Just 5)
06:25:54 <lambdabot>  No instance for (GHC.Show.Show a0)
06:25:54 <lambdabot>    arising from a use of ‘M436212282488733040926435.show_M4362122824887330409...
06:25:54 <lambdabot>  The type variable ‘a0’ is ambiguous
06:25:54 <lambdabot>  Note: there are several potential instances:
06:25:54 <lambdabot>    instance [safe] GHC.Show.Show
06:26:02 <ab9rf> ha
06:26:05 <mjrosenb> Philonous: like that? :-p
06:26:11 <Philonous> mjrosenb, There you go :)
06:26:41 <MayK> lambdabot, help
06:27:18 <Philonous> mjrosenb, the Monoid instance of Maybe demands that the constituent type also be a Monoid. Integer isn't a Monoid, by default, so that's why you're getting the error
06:27:23 <Philonous> Or at least so I assume
06:27:48 <ab9rf> > let tryBoth x y = (x `mplus` y, x `mappend` y) in tryBoth (Just "cat") (Just "dog")
06:27:49 <lambdabot>  (Just "cat",Just "catdog")
06:28:10 <mjrosenb> catdog!
06:28:18 <ab9rf> moof
06:28:52 <Philonous> That's the sound of a cat bursting into flames
06:28:58 <mjrosenb> Philonous: oh, derp.  I forgot the square brackets :-p
06:29:56 <ab9rf> i showed the famous johnny carson "sound of an exploding sheep" carnac segment to my kids, and they spent the next half hour running around pretending to be "sheepers"
06:33:20 <mjrosenb> hrmm, is it possible to install an older ghc with cabal?
06:33:50 <mjrosenb> my system has 7.8.3, but I think my life would be easier if cabal just used 7.6.foo locally
06:35:17 <Philonous> mjrosenb, Not with cabal, no, but virthualenv supports that
06:35:30 <Philonous> http://hackage.haskell.org/package/virthualenv
06:35:57 <Philonous> cabal-dev too
06:37:58 <mjrosenb> oh hey, cabal list takes a string as an argument
06:38:20 <mjrosenb> maybe I should stop running cabal list | grep foo
06:38:26 <ab9rf> hehe
06:39:03 <Pythonfant> mjrosenb: that reminds of the times when I used to run cat * | grep foo :)
06:39:34 <mjrosenb> Pythonfant: to be fair, cat * | grep foo gives different output from grep foo *
06:40:37 <Pythonfant> yeah but grep foo * was what I was looking for :)
06:41:35 <Philonous> mjrosenb, That's not the point. Composition of small programs that do only one thing is un-UNIX-y. You' supposed to memorize the bazillion parameters everything now supports
06:52:02 * hackagebot cabal-bounds 0.8 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8 (DanielTrstenjak)
06:53:56 <sgronblo> http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package I think this page fails to answer the main question...
06:58:05 <mjrosenb> wait, the current haskell platform is using ghc-7.8.3?
06:58:26 <Philonous> mjrosenb, It should, why?
07:00:05 <mjrosenb> Philonous: I was looking into why sdl wasn't building, and there was an ML thread that said basically "7.8 is too new, don't expect it to work, stick to the haskell-platform"
07:00:11 <mjrosenb> or something similar to that
07:00:23 <Philonous> Ah, right. Well, the new platform came out a few days ago
07:01:23 <Clint> but when will non-conflicting darcs come out
07:01:55 <sgronblo> Something goes weird when I run hasktags .
07:02:12 <sgronblo> hasktags: tags: openFile: resource busy (file is locked)
07:03:59 <sgronblo> Ah the interwebs came to my rescue
07:05:44 <olivia1> http://pastebin.com/G6EK7M2c question inside :D
07:07:03 * hackagebot immortal 0.2 - Spawn threads that never die (unless told to do so)  http://hackage.haskell.org/package/immortal-0.2 (RomanCheplyaka)
07:07:54 <olivia1> it creates a lot of syntactic noise to have a 4 parameter typeclass so id like to avoid it if possible
07:11:25 <geekosaur> @quote edwardk There is nothing Natural about a Word.
07:11:25 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:11:29 <geekosaur> whoops
07:11:34 <geekosaur> @remember edwardk There is nothing Natural about a Word.
07:11:34 <lambdabot> Done.
07:11:47 <mjrosenb> anyone here use arch?
07:12:06 <NikolajK> is Hindley-Milnor the holy grail of type inference, or are there "similarly big" approaches out there?
07:14:08 <flux> it's probably not the holy grail, but very near the local minima :)
07:14:32 <flux> (I don't know of other radically different approaches, perhaps some exist)
07:15:04 <olivia1> i feel like there must be some way to do it with type families but they are very new to me
07:15:04 <hodapp> isn't Hindley-Milner a form of a more general one that I can't think of offhand?
07:15:35 <vanila> hodapp, I don't think so - anything further is usually undecidable
07:23:14 <Philonous> hodapp, Do you mean System F?
07:27:06 * hackagebot json-rpc 0.2.0.1 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.0.1 (XenoGenesis)
07:35:15 <NikolajK> this is used as an example on the Hindley milner Wikipedia page
07:35:15 <NikolajK> http://upload.wikimedia.org/math/9/0/4/90416a64b581112fd0f3203a5742c85d.png
07:35:46 <NikolajK> I have no idea what the purpose is of writing it like that, instead of
07:35:47 <NikolajK> \lambda x.\lamdba y. x
07:36:13 <NikolajK> what is the point? Here the reference: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Free_type_variables
07:38:06 <olivia1> here was the fix i went with re: my earlier question: http://pastebin.com/Mk9qSp0X
07:39:16 <mmmm> quit
08:04:12 <olivia1> nevermind that doesnt fix it
08:04:18 <olivia1> just pushes the problem elsewhere
08:08:21 <sithrak> test#
08:09:17 <RchrdB> sithrak, I like your choice of IRC nick. :)
08:10:47 <benzrf> hah
08:17:28 <olivia1> class Goal g o t c | g -> o, g -> t, g -> c, t -> c, o -> c
08:17:35 <olivia1> i somehow feel like this is not ideal, but it works
08:18:44 <benzrf> olivia1: why not just Goal g, then
08:19:01 <olivia1> i get a bunch of errors elsewhere which im not sure how to fix
08:19:02 <benzrf> it transitively decides everything doesnt it
08:19:13 <benzrf> er
08:19:18 <benzrf> not even transitively
08:19:30 <olivia1> http://pastebin.com/MLkMwKdu for instance itll say it cant figure out what "c" is
08:19:35 <olivia1> if i leave it off
08:19:47 <olivia1> (in the instance declaration)
08:20:02 <olivia1> i can probably solve this with type families or something but i cant figure out how
08:21:38 <olivia1> g decides o, t, and c. o decides t and c. t decides c
08:22:03 <olivia1> but g is only parameterized by c
08:22:18 <olivia1> actually
08:22:22 <olivia1> c decides all of them!
08:22:28 <bernalex> is there an elegant way to achieve this: f $ case a of (>5) -> "a"; (>10) -> "b"; _ -> "c" -- ?
08:22:43 <bernalex> i.e. what would be the most elegant way of doing it
08:22:59 <olivia1> class Goal g o t c | c -> g, c -> o, c -> t where
08:23:02 <olivia1> it should be like that
08:23:05 <olivia1> and that also works out
08:23:50 <benzrf> bernalex: how about something like
08:24:27 <olivia1> i might just give up and un-typeclass this
08:24:36 <olivia1> the types are fun but its becoming very hairy
08:24:46 <benzrf> fromMaybe "c" $ snd <$> find ((a>) . fst) [(5, "a"), (10, "b")]
08:24:51 <carter> @tell dfeuer theres lots of people on #ghc who are better to talk with about this fusion stuff than I. I just happen to respond to people when I see them talking :)
08:24:51 <lambdabot> Consider it noted.
08:24:53 <bernalex> benzrf: no
08:24:54 <benzrf> ^shit, but scales for rly long lists
08:24:59 <benzrf> bernalex: just 3 cases?
08:25:21 <dfeuer> Hello, carter.
08:25:45 <quchen> bernalex: You can use a Map with its lookupGT to do that efficiently for large numbers of cases
08:25:52 <carter> not responding right now
08:26:15 <dfeuer> Goodbye, carter.
08:26:18 <carter> :)
08:26:32 <carter> merry weekend
08:26:45 <bernalex> benzrf: it was meant in general when you have stuff like you have SomeMonad a, and want to do case SomeMonad a of SomethingWeird -> 1; Error a -> g a; -- and then you have where g a | a > 50 = ... | otherwise = ...
08:26:53 <Vulpyne> I've been looking around but didn't really find much. Is there a generally idiomatic way to do type safe state machines such that invalid state transitions are caught at compile time?
08:27:08 <carter> Vulpyne: GADT
08:27:11 * hackagebot tasty-hunit 0.9 - HUnit support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hunit-0.9 (RomanCheplyaka)
08:27:15 <bernalex> benzrf: so instead of doing g a, it would be nice if you could do Error (>50) -> ...; Error a -> ...; -- or something to that effect
08:27:18 <Vulpyne> carter: Could you be more specific?
08:27:27 <bernalex> benzrf: i.e. I should have specified I was being generic. :-]
08:27:32 <carter> Vulpyne: each valid transition becomes a constructor in the GADT
08:27:51 <benzrf> bernalex: guards, then
08:27:59 <benzrf> oicwym
08:28:11 <benzrf> all i can think is view patterns, man
08:28:15 <bernalex> benzrf: yeah exactly. :-P sort of guards in cases.
08:28:22 <carter> data SafeMachine from to where    blah :: SafeMachine Foo Baz
08:28:23 <carter> etc
08:28:33 <Philonous> carter, "Kleisli arrows of outrageous fortune" might be pertinent
08:28:45 <carter> i have no clue
08:28:45 <carter> :)
08:28:51 <benzrf> carter: oh thats pretty clever
08:28:56 <benzrf> Philonous: lel
08:28:59 <Vulpyne> carter: Okay, I'll look into that. I haven't really used GADTs much. Thanks for the reply.
08:29:04 <carter> gadts are nice
08:29:10 <benzrf> Vulpyne: gadts are pretty simple
08:29:22 <Philonous> benzrf, Do you disagree?
08:29:24 <carter> one of the more surpising things is you can totally define GADTs that use record syntax
08:29:29 <benzrf> Philonous: just find the title amusing
08:29:39 <Vulpyne> benzrf: Yeah, I understand the syntax and all. I'm just not used to thinking about solving problems with them.
08:29:43 <benzrf> Vulpyne: all it is, is you specify the types of the constructors yourself instead of letting them be inferred
08:29:46 <benzrf> ah ok
08:29:58 <Philonous> benzrf, The entire paper is written in that punning stile.
08:31:12 <Vulpyne> benzrf: Right, but using that feature to solve problems is a bit different from knowing how it works.
08:32:20 <Philonous> Vulpyne, This might be of interest: https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
08:32:38 <XrXr> Hi, I'm trying to install the gtk package on Windows with `cabal install gtk` and it's failing http://lpaste.net/342182819021193216
08:33:19 <Philonous> Vulpyne, It's not exactly what you are asking, but I believe the technique he uses might be helpful.
08:35:09 <Vulpyne> Philonous: Thanks, I'll read through that.
08:35:44 <Vulpyne> I found this code, but it seems like GHC 7.8.2 doesn't support the "type instance where" syntax: https://gist.github.com/NicolasT/4991376
08:37:09 <mmmm> Is there a good way to subtract 'F000' from a character? ie '\xF028' to '\x0028'?
08:37:37 <mmmm> I guess Char to Int to Char would work..
08:37:45 <geekosaur> toEnum and fromEnum, yeh
08:38:12 <carter> the Enum class annoys me
08:38:18 <carter> it really needs a teeny bit more generality
08:38:39 <carter> instead of having succ :: a -> a
08:38:43 <Vulpyne> mmmm: chr (ord '\xf000' - (toEnum 0xf000)) == '\NUL' :: Char
08:38:52 <carter> succ :: infoAbouta -> a -> a
08:38:59 <carter> roughtly
08:39:04 <carter> well
08:39:22 <Philonous> carter, What would that infoAbouta look like?
08:39:23 <carter> i guess i could do succ (infoabouta,a)->(infoabouta,a)
08:39:32 <carter> Philonous: like my sparseLayout type classs
08:39:54 <carter> i have a bajilion different ways of interpretting (int,int) as mapping to int
08:40:00 <carter> and reasoning wrt that induced ordering
08:40:13 <mmmm> I did f (ord -> c) = chr (c - ord '\xF000')
08:40:15 <carter> literally a bajillion
08:40:18 <mmmm> approximately
08:41:25 <Vulpyne> mmmm: Pretty much the same thing then. Seems reasonable, and I think there's a good chance the compiler will just optimize the conversion overhead out.
08:41:45 <monochrom> instance Num Char where ... :)
08:41:58 <carter> char is Int sized
08:41:59 <carter> :)
08:46:43 <Philonous> monochrom, horrifying!
08:49:59 <monochrom> run_length_encoding = concatMap (\s@(c:_) -> [c, genericLength s]) . group  :)
08:50:24 <benzrf> @let rle = concatMap (\s@(c:_) -> [c, genericLength s]) . group
08:50:26 <lambdabot>  Defined.
08:50:30 <carter> RLE === counting as compression
08:50:51 <benzrf> > rle "this is some text that i am typing right now, but i do not think that it has many double letters in it"
08:50:52 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
08:50:52 <lambdabot>    arising from a use of ‘L.rle’
08:50:55 <monochrom> but it needs Num Char, which lambdabot doesn't have
08:50:58 <benzrf> waah wahh waaah
08:51:30 <benzrf> :t to enum
08:51:31 <lambdabot> (Contravariant f, Conjoined p, Profunctor p1, Functor f1, Functor f, Enum a) => p (p1 Int (f1 Int)) (f (p1 Int (f1 Int))) -> p (p1 a (f1 a)) (f (p1 a (f1 a)))
08:51:32 <quchen> Don't use genericLength, https://github.com/quchen/articles/blob/master/fbut.md#genericlength
08:54:18 <benzrf> @src readMaybe
08:54:18 <lambdabot> Source not found. Are you typing with your feet?
08:54:37 <raichoo> @src readMay
08:54:37 <lambdabot> Source not found. Where did you learn to type?
08:55:01 <Philonous> quchen, That page should be in the topic of this channel
08:56:09 <quchen> I'm not sure about that, the topics covered are quite random after all.
08:56:22 <quchen> It's basically a copy+paste shortcut for me.
08:58:02 <Philonous> Well, is there a FAQ for this channel?
08:58:11 <quchen> ?faq
08:58:11 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:58:13 <benzrf> @where faw
08:58:14 <lambdabot> I know nothing about faw.
08:58:14 <benzrf> @where faq
08:58:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:58:29 <quchen> It's the Haskell FAQ, not this channel's, though.
08:59:18 <Philonous> Fair enough
08:59:45 <quchen> Note that ?faq doesn't say "Yes, Haskell can do that" anymore :-)
09:00:09 <benzrf> nooooooooo
09:00:13 <monochrom> @faq
09:00:13 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:00:17 <benzrf> we have @where faq
09:00:21 <benzrf> we need @faq back
09:00:59 <EvanR__> can haskell solve the halting problem
09:01:15 <benzrf> >There are also many companies which do not use Haskell, but prefer to hire people who know Haskell. It indicates that you learned something hard and obscure just for fun, which employers take as a sign of intelligence.
09:01:22 <benzrf> >hard and obscure
09:01:22 <benzrf> ;-;
09:02:26 <quchen> EvanR__: The Halting problem is solved. The result is "no".
09:02:46 <ChristianS> quchen: there are no programs that terminate?
09:03:16 <EvanR__> the yes haskell can do that seemed a bit strange to me
09:03:37 <feloneousmonk> benzrf: that's called "bait and switch" ;-)
09:04:20 <jle`> is faq gone?
09:04:38 <quchen> Yes.
09:04:46 <jle`> @faq is faq gone?
09:04:46 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:04:49 <jle`> aw
09:04:58 <quchen> Well, it's not gone, it's patched to doing something useful.
09:04:58 <jle`> and nothing of value was lost
09:05:06 <monochrom> no, benzrf, which employers take as exploitable.
09:08:50 <benzrf> jle`: HOW DARE YOUUUUUUUU
09:08:56 <benzrf> that was my favorite cmmand
09:08:58 <jle`> benzrf: :)
09:09:25 <jle`> i have some issues with the haskellwiki faq though now that i read through it
09:09:42 <jle`> in fact i have issues with a lot of things that lead me astray when i was learning haskell :/
09:09:49 <jle`> also i can't believe it's been over a year since i learned haskell
09:09:57 <jle`> ...i had hoped more would have changed in that time
09:14:24 <EvanR__> "dont use regex" is a really hard sell outside haskell
09:14:41 <EvanR__> even if there are alternatives
09:14:46 <bergmark> jle`: i find tons of things have changed in the last year!
09:14:58 <Philonous> jle`, Be the change you want to see!
09:15:24 <tabemann> that's because parsing APIs suck or are nonexistent outside Haskell
09:15:38 <jle`> Philonous: i am trying :D  i am partially disappointed in the change i was personally able to affect in the past year and a half
09:15:55 <jle`> but actually not so much and i think i balanced school and trying to contribute well ish
09:16:43 <jle`> bergmark: me too actualy, but i'd like to hear what you think :)
09:16:43 <mmmm> sometimes you need to use a regex library in a parser .. when the thing you're trying to parse has user defined regex macros
09:17:26 <Philonous> mmmm, In that case you still don't need a regexp library but an exorcist.
09:20:38 <mmmm> Well I actually skipped implementing it
09:20:59 <mmmm> Not looking forward to when someone comes on the issue tracker to ask why it isn't working
09:21:24 <Maior> @hoogle Bool -> a -> a -> a
09:21:25 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
09:21:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
09:21:25 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
09:23:59 <tabemann> I think there are bindings for PCRE available for Haskell, if you *really* need regexes
09:24:23 <quchen> Maior: if/then/else?
09:24:41 <quchen> Since 7.8 there's a "bool" function in Data.Bool too, but that has a different argument order
09:24:48 <Maior> quchen: heh cheers, assumed it'd be a function
09:24:49 <Maior> thanks
09:25:00 <tabemann> too bad Haskell isn't Agda, where if/then/else is a first-class function
09:25:18 <quchen> There is an extension to do that in Haskell too.
09:25:29 <quchen> if/then/else is then the "ifThenElse" function.
09:25:39 <quchen> But it's not really very useful.
09:25:55 <EvanR__> using pcre as a library would seem very baroque to most people, who are used to some subset of javascript, python, ruby
09:26:25 <EvanR__> even php
09:27:05 <EvanR__> its like perl's undying legacy
09:27:22 <ab9rf> there are two or three pcre bindings for haskell, actually
09:27:29 <ab9rf> one of them is in IO
09:27:38 <ab9rf> the other has a number of curious limitations
09:27:57 <ab9rf> in most cases you're better off writing a parser in (atto)parsec
09:28:41 <quchen> Such as the case where you have to be able to read the code
09:28:56 <ab9rf> the only time i'd consider using a regexp is to expose regexp functionality to a user, for some reason
09:29:12 <EvanR__> which for most users is a non feature
09:29:19 <ab9rf> regexps should not be used in code
09:29:44 <ab9rf> EvanR__: you'd be surprised how often people ask for "filtering by regular expression"
09:29:57 <tabemann> apparently there are a number of regex modules available for Haskell, if you *really* need regexes for some reason
09:29:59 <EvanR__> yeah i would
09:30:04 <EvanR__> then id be annoyed
09:30:10 <ab9rf> especially if you are targeting linux platforms
09:30:50 <EvanR__> parsing aside, i use regex in ruby to verify a string has some pattern, rather than attempt to parse the string
09:30:54 <ab9rf> tabemann: i tried to use one of them fairly early on in my haskell experience, before i learned how to use parsec
09:30:56 <tulcod> in c2hs, i have created a "newtype" for this opaque pointer that some C library gives me using {#pointer * someStruct as SomeStruct newtype#}. now i want to bind a C function that takes a pointer to such a struct, and returns an integer, so i wrote {#fun unsafe get_some_property as getSomeProperty {`SomeStruct'} -> `Int' #}. but c2hs apparently reads the C code and figurered the first argument should have type Ptr (), and doesn't know how to marshal
09:30:56 <tulcod> that. any ideas on how to tell it to just use the pointer type i just made?
09:31:00 <EvanR__> but i guess this is just another use case for parsing
09:31:17 <ab9rf> EvanR__: that's just an identifying parser, with the parse result discarded
09:31:25 <ab9rf> EvanR__: technically that's the original use for regexps
09:31:36 <monochrom> I use regex in a program
09:31:44 <ab9rf> regexps are supposed to answer the quesiton "is this string a member of this language"
09:31:50 <ab9rf> extracting matches is an extension
09:32:21 <tulcod> ab9rf: not all languages can be recognized by regexes...
09:32:27 <ab9rf> tulcod: indeed
09:32:37 <sipa> regexps are regular expressions
09:32:39 <EvanR__> i was confused when i first started using regex, the default seems to be "some substring matches this pattern" rather than "string is a member of language"
09:32:39 <tabemann> for instance, you cannot parse HTML with regexes
09:32:42 <sipa> they recognize regular languages
09:32:50 <ab9rf> tulcod: especially if you restrict yourself to classic regexps
09:33:03 <tulcod> classic means what mathematicians call regexp?
09:33:05 <ab9rf> PCREs recognize a much larger set of languages than traditional regexps
09:33:10 <EvanR__> the whole string matches a pattern is way more useful
09:33:18 <ab9rf> tulcod: yes, with just ., kleene closure, and alternation
09:33:29 <tabemann> even Jon Skeet cannot parse HTML using regular expressions
09:33:47 <EvanR__> chuck norris probably can
09:33:48 <Philonous> That doesn't stop people from trying, though.
09:34:11 <ab9rf> PCREs have a limited ability to be non-context-free, although doing so is EVIL
09:34:19 <quchen> You can't really parse anything with Regex, it's more like a tokenizer.
09:34:25 <monochrom> my secret of peace of mind is that I don't sell anything to unreasonable people.
09:35:02 <quchen> And concerning using Regex to work with HTML: For every unsolvable problem, there is a solvable subproblem.
09:35:19 <EvanR__> monochrom: how do you manage that?
09:35:56 <monochrom> by detecting whether the person I'm talking to is reasonable or not. does that answer your question?
09:36:29 <EvanR__> when the alert goes off, you cancel the deal?
09:36:32 <ab9rf> monochrom: reasonability detection is NP-complete.
09:36:53 <monochrom> yes. more than that. I stop talking. I walk away.
09:36:54 <tabemann> many people would love it if they could avoid selling things to unreasonable people, provided they could still sell things
09:37:12 <ab9rf> unfortunately most of the people i sell to are unreasonable
09:37:14 <EvanR__> unreasonable is a huge market share ;)
09:37:16 <ab9rf> and i'm not wealthy enough to be picky
09:37:41 <monochrom> I thought in this context "sell" simply means "suggest to use", and no money involved
09:38:03 <monochrom> it is not like you get any commission from "selling" Haskell
09:38:05 <EvanR__> i guess that is what i brought up
09:38:30 <monochrom> and really, for the health of the Haskell community, you don't want unreasonable people to join.
09:39:11 <EvanR__> is this an elitist attitude
09:39:30 <EvanR__> or just being reasonable
09:39:40 <mornfall> sounds like a mix of both
09:40:28 <mornfall> ab9rf: undecidable, actually
09:40:37 <Ankhers> Does anyone know if warp is supposed to work as well with GHC 7.8 as it did in 7.6?
09:41:14 <monochrom> I don't understand what is elitist about requiring to be reasonable. or collegial. or "be nice". all that.
09:41:28 <mornfall> monochrom: I suspect there are times when the first impression is way off though.
09:41:31 <mornfall> I had that happen before.
09:41:36 <quchen> NP-complete problems are decidable.
09:41:48 <mornfall> quchen: exactly my point :-)
09:42:00 <monochrom> I am aware of that. I don't jump to conclusion that easily.
09:42:01 <mornfall> Judging people to be complete assholes to find out they actually weren't, after all.
09:42:28 <quchen> I think you'll find it hard to encode reasonability into a logical system.
09:43:32 <pyon> On a 0-10 scale, how useful do you guys find kind polymorphism? 0 means "I do not need it at all", and 10 means "I cannot even imagine how I could program without it" (e.g., parametric polymorphism).
09:43:48 <mornfall> quchen: brain is a logical system, most likely... but yes, that probably wouldn't work
09:43:51 <ab9rf> i've yet to use it
09:43:53 <monochrom> somewhere in 7-10
09:43:59 <pyon> Ah!
09:44:05 <quchen> mornfall: That's an open question in philosophy
09:44:10 <monochrom> oh wait, kind polymorphism? then 0-2
09:44:44 <mornfall> pyon: even parametric polymorphism is not really a 10
09:44:54 <monochrom> 7-10 was for parametric polymorphism
09:45:11 <c_wraith> Kind polymorphism I would probably put in the 2-4 range.  I've found uses for it several times that make my code nicer.
09:45:29 <mornfall> I don't think I used it yet, but I really like the idea. :)
09:45:37 <mornfall> Backpack, on the other hand, I'm waiting.
09:45:37 <vanila> pyon, 0
09:45:57 <vanila> c_wraith, would be really interested to see examples if you have any handy
09:46:00 <c_wraith> Part of the problem is that on a scale of need, nearly all features are a 0.
09:46:00 <vanila> I couldnt'think of one at all
09:46:12 <c_wraith> turing completeness, and all
09:46:31 <mornfall> c_wraith: more like feature interchangeability
09:46:48 <mornfall> you have less need for parametric polymorphism if you have ad-hoc polymorphism
09:47:06 <theorbtwo> duck-typing!
09:47:08 <mornfall> or if you have dynamic types instead of static
09:47:08 <c_wraith> You don't need polymorphism at all, at a turing level.  :)
09:47:19 <quchen> c_wraith: Turing Completeness has nothing to do with needing things (or reality in general).
09:47:38 <c_wraith> So really, "need" is the wrong question.  A much better question is "does it make your life easier?"
09:47:40 <Iceland_jack> You don't need types either
09:47:42 <monochrom> mornfall: I don't equate asshole with unreasonable. there are unreasonable non-assholes.
09:47:46 <quchen> Reductionism isn't really fruitful at this level.
09:47:52 <benzrf> > group []
09:47:53 <lambdabot>  []
09:48:01 <theorbtwo> On a turing level, polymorphism is meaningless, or possibly universally true.  There are no types, only zuul.  Er, states and symbols.
09:48:10 <jle`> > group "hello world"
09:48:10 <pyon> mornfall: Well, at least for me, parametric polymorphism is a solid 10. Dynamic types are basically out of question for writing reliable programs. And static types without parametric polymorphism require either too much wheel reinventing (the same data structures and algorithms over and over) or evading the type system (e.g., void*).
09:48:11 <lambdabot>  ["h","e","ll","o"," ","w","o","r","l","d"]
09:48:14 <mornfall> c_wraith: well, if you regard the language as means of communication and as means of machine-assisted programming, then yes, you do need many things above turing completeness
09:48:16 <theorbtwo> There's a reason that nobody programs for turing machines, though.
09:48:17 <hodapp> You don't "need" computers at all. You can just do all this stuff by hand.
09:48:23 <vanila> what is kind polymorphism for?
09:48:25 <hodapp> All the computer does is make it quicker.
09:48:29 <hodapp> And that obviously doesn't matter.
09:48:44 <quchen> vanila: All Typeable things can be unified, for example.
09:48:57 <vanila> oh I guess if you have more kinds than * it could be relevant
09:48:58 <pyon> vanila: Sometimes the "most general kind" possible for a type constructor is a polymorphic kind.
09:49:01 <quchen> Previously, there was a "Typeable1" type for *->*-kinded things, for example.
09:49:10 <mornfall> pyon: that depends, C++ templates aren't parametric polymorphism in the sense that Haskell has parametric polymorphism, yet they give you static types and reasonable flexibility to avoid wheel-reinventing
09:49:12 <pyon> vanila: e.g., newtype Foo a b = Foo (a b)
09:49:15 <jle`> yeah Typeable is probably the most visible impact of kind polymorphism
09:49:27 <vanila> pyon, I see, thanks
09:49:28 <c_wraith> vanila: yeah, the new implementation of Typeable is the biggest single win from kind polymorphism
09:49:49 <jle`> edwardk has some nice demonstrations of kind polymorphism for useful Category instances
09:49:51 <monochrom> hrm, I forgot the new, better Typeable story. that bumps my answer to 7-10 again. :)
09:50:01 <jle`> instead of Category being * -> * -> *, it's t -> t -> *
09:50:02 <pyon> vanila: All that you know is that "a b" has kind *, which means that if "b" has kind K, then "a" has kind "K -> *". But K could be any kind.
09:50:05 <quchen> monochrom: Is Typeable *that* useful though?
09:50:10 <vanila> fascinating
09:50:23 <monochrom> it certain is at least 7
09:51:05 <mornfall> pyon: is kind promotion part of the bundle in your question?
09:51:21 <pyon> mornfall: No.
09:52:29 <jle`> the useful Category instane that has t -> t -> * where t is not * is Nat
09:52:40 <jle`> as in a natural transformation
09:52:50 <mornfall> (I do keep wondering though whether the declarative approach of advanced type systems is the best fit for our storytelling brains...)
09:53:10 <pyon> jle`: A functor category?
09:53:11 <jle`> not as in type nats
09:53:34 <jle`> it's in his talk about Hask
09:53:51 <pyon> Ah, checking it out. :-)
09:54:12 <pyon> jle`: Do you have a link to it? :-O
09:54:41 <jle`> pyon: www.youtube.com/watch?v=Klwkt9oJwg0 :)
09:54:52 <pyon> jle`: Thanks!
09:55:06 <monochrom> once upon a time, there was a great storyteller. he could explain any type system, no matter how bizzare or abstract, as a story that children would love. :)
09:55:16 <jle`> pyon: ofc!
09:55:23 <jle`> now off to bed, good night all
09:55:43 <mornfall> (there's also the infinite type tower problem -- all kinds are of the sort BOX... which is crude and might turn out to be limiting at some point, so what then?)
09:56:07 <mornfall> monochrom: show me that person :-)
09:56:23 <monochrom> I'm just telling a fictional story!
09:56:29 <vanila> I enjoyed your story :)
09:56:34 <mornfall> pah
09:56:45 <monochrom> but I may be able to do some of that person's ability
09:57:25 <mornfall> monochrom: but the issue isn't with stories about the type system, it's about encoding stories *in* the type system
09:57:35 <burp> I need advice on reducing a list of [DataX] where data DataX = Foo | Bar x. I want to have a function extractx :: [DataX] -> [x], how do you recommend to do this? One possibility could be to map over them with a case, return Just x or Nothing, then use catMaybes
09:57:40 <mornfall> after all, programs tend to encode stories
09:57:42 <monochrom> in fact, I told a fictional story in my http://www.vex.net/~trebla/haskell/IO.xhtml . once upon a time, a boy wanted to connect his radio receiver to his loudspeaker...
09:59:08 <burp> but somehow that feels clumsy, especially when Bar has many fields and I have to specify many "_" for the case
09:59:09 <monochrom> hmm! perhaps we can s/action/story/ !
09:59:28 <monochrom> "A value of type IO a is called a 'story'!"
09:59:29 <burp> Bar _ _ _ _ _ _ _ _ _ x _ _ _ _ -> Just x
09:59:37 <mornfall> monochrom :D
10:00:47 <EvanR__> ah xhtml
10:00:59 <mornfall> EvanR__: good old times huh?
10:01:11 <EvanR__> good vintage article
10:03:30 <mornfall> the analogy with a connector somehow reminded me of FRP
10:03:42 <mornfall> (or more generally dataflow programming)
10:03:56 <monochrom> if Bar has many fields, for example "Bar {f1 :: Int, f2 :: Bool, f3 :: Char}", then the case expression is "case gee of Bar{f2=x} -> Just x"
10:04:42 <mornfall> burp: you could also use fclabels or lens
10:05:00 <mornfall> (I guess)
10:05:04 <burp> monochrom: oh, thanks, I didn't know that I could write it like this
10:05:20 <burp> mornfall: looking at lens package is on my TODO list :)
10:05:28 <mornfall> (because writing all those extractx is boring)
10:07:32 <burp> so I guess with lenses I get the extract{x,y,z} "for free"
10:08:28 <mornfall> yeah, along with updatex and a bunch of operators to compose those things
10:08:35 <NikolajK> does somebody know an expression that gives two different results in two different scripts/programming languages?
10:08:43 <mornfall> (again, I think... I only used fclabels, which seems to be the less “vogue” of the options)
10:08:52 <NikolajK> i.e. I plug it into a prelude and two different programs understand it, but differently
10:09:20 <mornfall> NikolajK: what do you mean? is "parse error" a valid result?
10:09:36 <NikolajK> valid results
10:09:50 <EvanR__> polyglot
10:09:53 <monochrom> the C expression (x++)-(x++) may give two different results in the same programming language. you don't even need two languages. :)
10:10:00 <mornfall> NikolajK: is an infinite loop valid?
10:10:21 <Iceland_jack> haha
10:10:26 <c_wraith> monochrom: 0 and -1 are the only possible results for that?  Shouldn't there be more, somehow?
10:10:26 <NikolajK> I mean something like "[2]++[1]" is "[2,1]" in Haskell and in another language it might mean something else
10:10:47 <EvanR__> "2" + 2
10:10:49 <monochrom> more is better
10:10:49 <mornfall> NikolajK: it may mean something else in Haskell with redefined ++
10:11:01 <c_wraith> monochrom: I bet that 1 is also possible in some implementations
10:11:24 <NikolajK> mornfall: infinite loop is better than nothing
10:11:46 <FireFly> There's a ton of such examples
10:11:56 <NikolajK> the easist will be to find two different uses for common symbols such as "+" or "**"
10:12:00 <EvanR__> haha an infinite loop is worse than nothing
10:12:01 <Iceland_jack> You may want to look at quines
10:12:07 <mornfall> NikolajK: 10^10 :-)
10:12:12 <FireFly> And polyglots, as EvanR__ mentioned
10:12:16 <Iceland_jack> yes
10:12:17 <mornfall> NikolajK: (^ is xor in C)
10:12:20 <NikolajK> mornfall: that's what in which languages?
10:12:20 <monochrom> in "http://functionaljobs.com/jobs/8729-pragmatic-haskell-developer-at-anchor-systems", it says "A Bachelor's in science, engineering, or xenobiology will be well thought of." is the xenobiology part a joke? :)
10:12:26 * hackagebot texmath 0.8 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8 (JohnMacFarlane)
10:12:34 <Iceland_jack> But if you consider failure to compile is a 'result' then it's quite trivial :)
10:12:35 <NikolajK> okay, but does 10^10 make sense in C then?
10:12:37 <mornfall> NikolajK: and power in Haskell and many other languages
10:12:40 <NikolajK> it shouldn't just give an error
10:12:42 <mornfall> NikolajK: as an expression, yes
10:12:46 <Iceland_jack> NikolajK: yes
10:12:48 <mornfall> as a program, no
10:12:59 <FireFly> 0||2 evaluates to 2 in JavaScript and 1 in C (I think)
10:13:01 <Sornaensis> ^ is xor in C isn't it
10:13:02 <mornfall> (but you did ask for expressions)
10:13:17 <monochrom> 10^10 is legal in C.
10:13:24 <NikolajK> I asked for the resurn value in scripts, preludes etc.
10:13:26 <FireFly> 10^10 is 0 in C
10:13:45 <mornfall> NikolajK: what's a prelude?
10:14:03 <FireFly> "10^10" is as valid an example as "[1]++[2]"
10:14:11 <monochrom> what does "prelude" mean in the context of "two languages"?
10:14:32 <Sornaensis> builtins I guess
10:14:32 <NikolajK> I was thinking about shells
10:14:38 <NikolajK> I know one for Haskell and Python
10:14:43 <NikolajK> instant return of values
10:14:46 <FireFly> REPLs?
10:14:52 <Sornaensis> ghci is a repl
10:14:54 <mornfall> there's probably a C REPL somewhere
10:14:55 <FireFly> (read-eval-print loops)
10:15:00 <monochrom> I guess I don't understand the question. can anyone explain to me?
10:15:10 <Sornaensis> shells are different from repls
10:15:14 <NikolajK> whatever
10:15:22 <prophile> cling
10:15:29 <prophile> is a C interpreter for that sort of thing
10:15:33 <prophile> developed at CERN I believe
10:15:35 <FireFly> monochrom: finding an expression that is legal in two languages and yield different results in both, AIUI
10:15:52 <mornfall> prophile: yup, just found it :)
10:16:05 <Sornaensis> neato
10:16:10 <orion> Anyone know when haskell-platform will be released in FreeBSD Ports?
10:16:12 <mornfall> part of root, apparently
10:16:16 <Sornaensis> memory violations at the push of a button
10:16:27 <monochrom> yeah, so 10^10 and 0||2 and "2"+2 should be all good answers, and yet somehow they're all rejected.
10:16:36 <Iceland_jack> You can also do
10:16:36 <Iceland_jack>     let x + y = 5 in 2 + 2
10:16:38 <mornfall> hm, not yet maybe
10:16:41 * mornfall installs root
10:16:45 <Iceland_jack> where '2 + 2' is a valid example :)
10:16:49 <mornfall> (they have another C++ interpreter in there)
10:18:50 <mornfall> root [0] 10 ^ 10
10:18:50 <mornfall> (const int)0
10:18:56 <mornfall> NikolajK: ^^ like that?
10:19:04 <mornfall> root [0] is the prompt here
10:19:22 <monochrom> what is root? :)
10:19:28 <mornfall> monochrom: the cern software suite
10:19:43 <mornfall> (and my OS has a package, how cool is that?)
10:19:46 <jle`> something like 2.3 + 4 will give you varying results
10:20:02 <monochrom> interesting
10:20:06 <tulcod> jle`: in the case of python, even across versions
10:20:20 <tulcod> or was that 3/2 ?
10:20:32 <jle`> oh i think it was the fraction thing
10:20:36 <Sornaensis> muh mixed types
10:20:54 <tulcod> either way, the only way to really solve all these issues is to use a haskell-like type system :)
10:20:55 <dottedmag> Only in REPL printer, the value is the same.
10:20:56 <triliyn> In some languages they're the same type!
10:21:00 <triliyn> > 2.3 + 4
10:21:02 <lambdabot>  6.3
10:21:20 <tulcod> triliyn: Lua doesn't have an integer type - everything, even list indices, is floats
10:21:28 <mornfall> triliyn: having a “number” type is not all that unreasonable is it?
10:21:31 <dottedmag> REPL in python < 2.7 would print it as 6.2999999999999998
10:21:39 <FireFly> It's getting an integer type in the next version, though
10:21:48 <FireFly> JS doesn't have an integer type either
10:21:51 <triliyn> tulcod: ew D:
10:22:07 <triliyn> mornfall: well, I was thinking about how in haskell, integer-looking literals can be floats
10:22:13 <tulcod> triliyn: it's not too bad actually. you can store integers up to 2^24-1 exactly
10:22:35 <FireFly> tulcod: no, they're doubles, so 2^52-1 (IIRC)
10:22:36 <triliyn> tulcod: oh, I didn't know that. I guess that's fine then
10:22:37 <Sornaensis> 'zactly
10:22:40 <tulcod> FireFly: okay :)
10:22:44 <monochrom> but I want 2^54-1 or something
10:22:52 <mornfall> tulcod: interesting, it's really floats
10:23:01 <dottedmag> triliyn: Why? IEEE FP double up to 2^53 is precise.
10:23:01 <tulcod> mornfall: well doubles apparently
10:23:39 <mornfall> tulcod: floats as in floating point, it's DP yes
10:23:49 <tulcod> yeah
10:24:05 <mornfall> (it can also be single precision, depending on how the interpreter was built :)
10:24:24 <mornfall> my only lua encounter was via luatex/context
10:24:29 <dottedmag> mornfall: It can be int if you build the interpreter ;R
10:24:32 <dottedmag> :)
10:24:33 <FireFly> I think in some embedded contexts it's built with ints instead
10:24:34 <mornfall> beats tex any day as a language
10:24:35 <FireFly> Yeah :P
10:25:07 <tulcod> anyway gtg
10:25:33 <mornfall> (I actually did a haskell syntax highlighter in lua :D)
10:26:55 <mornfall> also, turns out lua strings aren't unicode (or at least their lpeg parse thingy doesn't work with them that way)
10:27:34 <mornfall> the equivalent of the "[∧∨]" regex tries to match the individual bytes... :|
10:27:36 <FireFly> they aren't, they're just byte arrays
10:27:56 <FireFly> pretty much C strings
10:28:16 <FireFly> Well, except you can have null characters in it because the length is stored separately
10:28:45 <EvanR__> they are BytesString.Char8 ;)
10:28:53 <Pythonfant> n
10:28:55 <mornfall> EvanR__: not really
10:28:57 <Pythonfant> sry
10:29:17 <mornfall> EvanR__: I don't think they expand each byte to a 4-byte value on indexing ;-)
10:29:57 <EvanR__> a Char is a 4-byte value? no way!
10:29:58 <benjumanji> exit
10:30:09 <EvanR__> you dont even need 24 bits
10:30:13 <FireFly> I almost forgot what channel I was in :P
10:31:00 <nitrix> It's so hard to destroy the state metodology.
10:31:27 <mornfall> EvanR__: yes, String uses 12+ bytes per character
10:31:28 <quchen> I don't think Char has a defined representation. All the Report says is "it's a Unicode codepoint, and should be convertible to and from Int".
10:31:31 <nitrix> Almost everything I wrote in the past had states or file-scope variables.
10:31:48 <mornfall> quchen: yeah, well, Char# in GHC says 31 bits
10:31:53 <vanila> nitrix: in what language?
10:31:57 <nitrix> vanila: C.
10:32:04 <vanila> that's just good C
10:32:12 <EvanR__> destroy the state methodology, starve the beast
10:32:23 <mornfall> viva la revolucion
10:32:29 <vanila> it doesn't have support for things like higher order functions, so you have to program that way
10:32:36 <nitrix> vanila: To the point it's really hard for me to figure out how to store or use things long-term with haskell.
10:32:45 <monochrom> I did not have a lot of file-scope variables when writing in C
10:32:59 <mornfall> me neither, I pack them up in structs
10:33:06 <nitrix> I understand its merely cascading arguments, but it feels so strange.
10:33:09 <mornfall> because threads
10:33:13 <monochrom> a lot of local mutable variables and pass by reference, yes
10:33:16 <vanila> well it takes a new approach, do you have any code you want to discuss?
10:33:58 <monochrom> there were no threads when I wrote in C. yet I had few file-scope variables because I had good judgment.
10:34:20 <mornfall> monochrom: how old *are* you?
10:34:30 <monochrom> 45
10:35:03 <EvanR__> pthreads sucks
10:35:12 <nitrix> vanila: Well, for example, I'm working on a toy game that should have quite interesting challenges to face while learning Haskell. Being a real-time strategy things with resource management, I suppose I'd need a list of entities, rooms, bunch of numbers on the resources (consumptions, production, etc)
10:35:30 <mornfall> monochrom: ohwell, I guess you could conceivably remember times when they weren't a concern... :P
10:35:37 <vanila> nitrix, well, state monad!
10:35:59 <nitrix> vanila: I see, so this is why I feel restricted.
10:36:06 <mornfall> (they certainly were a concern 20 years ago, though :P)
10:36:06 <vanila> make a record holding all these things, and then write code that needs to read or write to that in State
10:36:07 <nitrix> vanila: I'm about to read on monads, so.
10:36:08 <benzrf> mornfall: im pretty sure the median age in this channel is like 31
10:36:29 <benzrf> actually that'd make an intersting survey
10:36:33 <mornfall> benzrf: I'm not far from that, so I believe you.
10:36:37 <nitrix> vanila: Is the State monad considered a bad thing?
10:36:46 <Iceland_jack> nitrix: no
10:36:46 <vanila> no its the best thing
10:36:57 <mornfall> nitrix: yes, it is the source of oppression, you want a Commune monad instead
10:36:57 <nitrix> How does it deals with concurrency?
10:37:01 <vanila> nitrix, basically you could write all your functions to take an extra parameter, the state -- and then return their result value and the new state with a pair
10:37:03 <benzrf> the state monad is reasonably hella
10:37:05 <Iceland_jack> it doesn't deal with concurrency
10:37:14 <Iceland_jack> If you just need to pass configurations around you don't need monads
10:37:17 <benzrf> shit i overuse that word terribly
10:37:17 <nitrix> Right, so you pass the state around.
10:37:17 <vanila> nitrix, the state monad does exactly this
10:37:25 <vanila> so it just captures this programming technique
10:37:46 <Iceland_jack> and the configurations might contain mutable references
10:37:51 <nitrix> I think this will feel like home (:
10:38:01 <vanila> instead of writing  f oldState = (calculateNewState oldState, r)  you write   f = do calculateNewState ; return r
10:38:06 <EvanR__> not mutable references, references to mutable locations ;)
10:38:12 <vanila> as a rough idea of how to get started with this
10:38:13 <Iceland_jack> heh
10:38:37 <Iceland_jack> @hackage reflection
10:38:37 <lambdabot> http://hackage.haskell.org/package/reflection
10:38:53 <vanila> but even though you have "state" and can modify it, everything you're doing is still pure functions
10:38:57 <EvanR__> thats gotta be good
10:39:11 <nitrix> vanila: got it.
10:40:43 <nitrix> I know about the IO monad so far, so I suppose it works the same way, with <- and probably some get and put operations
10:40:49 <nitrix> Let met check.
10:40:59 <monochrom> mornfall: it really turns out that the good principles taught back then have stood the test of time and become more relevant, not less. if your procedure takes one more parameter (even by-reference is fine) instead of assuming one more global variable, it can be reused in more ways safely. it just happens that multi-threading is a special case of reuse.
10:41:25 <nitrix> http://www.haskell.org/haskellwiki/State_Monad, ah ah, first try. Literally <- get and put.
10:41:30 <nitrix> This is amazing (:
10:41:35 <ezrios> nitrix: you may also, in the course of reading up on monads, want to look up the desugaring of `do` notation
10:41:48 <ezrios> but that is for later
10:42:01 <nitrix> ezrios: That'd be nice. It's a bit too magical right now. Any link?
10:42:49 <mornfall> monochrom: I know, I avoid global state also in code that won't ever need to run multi-threaded (also, “won't ever” usually translates as “it will”)
10:43:07 <vanila> you don't need to worry about desugaring or >>= yet, I say learn to use it first - then it'll be easier to understand
10:43:10 <ezrios> nitrix: I liked these two articles
10:43:16 <ezrios> http://www.haskell.org/haskellwiki/Monads_as_containers
10:43:22 <ezrios> http://www.haskell.org/haskellwiki/Monads_as_computation
10:43:39 <nitrix> ezrios: Appreciated.
10:43:43 <ezrios> the second goes into 'do' syntax more
10:43:44 <mornfall> I also hate my colleagues for actually adding new global variables to a project that *is* supposed to work with threads one day (probably right the week after hell freezes over)
10:43:49 <ezrios> but they are both very accessible intros to monads
10:44:40 <monochrom> many programmers are lazy
10:44:47 <mornfall> vanila: desugaring may be important because of the “return” misnomer
10:45:00 <nitrix> Yeah I already read on return.
10:45:11 <nitrix> Which honestly, just feels like the opposite of <-
10:45:23 <nitrix> But I guess that'd be confusing if it was ->
10:45:24 <ezrios> in some sense
10:45:27 <mornfall> nitrix: might be because it is :-)
10:46:38 <mornfall> (in some sense, as ezrios points out... not quite in the -> sense I'd say)
10:47:19 <monochrom> I see how they're opposites. they cancel out, you can say. for example, story >>= return = story. the >>= and the return cancel out each other.
10:47:41 <ezrios> return is the "right identity" on bind.
10:47:59 <monochrom> but if you think like that, the logical conclusion is that 0 and + are opposites. x+0 = x, the + and the 0 cancel out each other.
10:49:03 <mornfall> monochrom: I think the “opposites” intuition comes from return pushing values into monads and <- pulling them out (not sure that's a good way to put things, but it's widely taught on the interwebs that way, isn't it?)
10:49:35 <mornfall> not from the algebraic identities
10:49:42 <ezrios> "wrapping" and "unwrapping"
10:49:44 <ezrios> values in monads
10:49:46 <ezrios> yeah
10:49:55 <nitrix> Quick question, how does one install a hackage package with cabal while automatically chasing dependencies?
10:50:03 <nitrix> Because that thing I want to use is a real hell.
10:50:04 <benzrf> nitrix: cabal install
10:50:04 <mornfall> nitrix: cabal install package
10:50:05 <ezrios> just `cabal install`
10:50:14 <benzrf> nitrix: but you should totally install nix ( ͡° ͜ʖ ͡°)
10:50:20 <orion> Does anyone have text-1.1.1.3 installed? Is there a .so for it in your .cabal directory? All I have is a .a
10:50:20 <ezrios> dafuq is nix
10:50:24 <mornfall> lol :D
10:50:36 <gamegoblin> @pl \x -> (x,x)
10:50:37 <lambdabot> join (,)
10:50:37 <mornfall> ezrios: it's the thing that allowed me to 'nix-env -i root' a while back ;-)
10:50:47 <ezrios> is this like
10:50:50 <ezrios> virtualenv for haskell
10:50:53 <ezrios> that would be awesome
10:50:57 <nitrix> "The program version c2hs >= 0.15 is required but it could not be found"
10:50:58 <geekosaur> that would be hsenv
10:51:03 <geekosaur> nix is a package manager
10:51:03 <ezrios> hm
10:51:08 <nitrix> Then if I install c2hs, it's another missing package and so on.
10:51:09 <ezrios> ooh
10:51:12 <Pythonfant> monochrom: well >>= and return are both functions, 0 is not a function, so you would need to find a function that cancels it out which would be (-) and then you actually have opposites
10:51:25 <geekosaur> orion: if you're running ghc 7.6, it will default to the .a on most platforms. 7.8 defaults to .so
10:51:40 <orion> geekosaur: I am running 7.8.3
10:51:40 <Pythonfant> monochrom: never mind that thought was stupid
10:52:00 <mornfall> ezrios, geekosaur, nix-shell is (if I understand what virtualenv is supposed to be) a general-purpose replacement for virtualenv (works fine with haskell, too)
10:52:25 <ezrios> hm
10:52:38 <mornfall> also, unlike cabal sandboxes, it manages your C dependencies just fine
10:52:54 <mornfall> (end of commercial break)
10:52:59 <geekosaur> then I would wonder about your cabal config; if it was created by a sufficiently old version of cabal, it may hardcode static libraries
10:53:15 <abc56889> is there a better pattern for stacking ReaderTs than ReaderT a (ReaderT b (ReaderT c m)) ?
10:53:17 <orion> geekosaur: I generated it fresh
10:53:20 <geekosaur> yes, I can see that. nix should be able to replace things like *env, modules, etc.
10:53:23 <orion> geekosaur: 1.20
10:53:27 <EvanR__> abc56889: use a record
10:53:31 <vanila> abc56889, what about ReaderT (a,b,c) m?
10:53:36 <geekosaur> huh. that sounds odd, then
10:54:41 <abc56889> vanila: it seems hard to define the appropriate MonadReader instances this way
10:54:49 <ezrios> huh
10:55:02 <tertl3> anyone use pcbsd for their main box?
10:55:02 <vanila> abc56889, The MonadReader instance should be automatic
10:55:09 <vanila> you dont have to write it
10:55:11 <tertl3> or freebsd
10:55:13 <nitrix> Still not working. The current dependency chain gives me:   ncurses -> c2hs -> language-c -> happy ....
10:55:22 <ezrios> cabal hell?
10:55:30 <nitrix> Well that's the question.
10:55:39 <nitrix> You guys said its supposed to find the dependencies.
10:55:42 <ezrios> I just sandbox everything
10:55:43 <abc56889> vanila: i have utility functions which expect to be able to `ask :: m c` for example
10:55:46 <vanila> why does happy even exist?
10:55:49 <vanila> happy/ale
10:55:50 <vanila> x
10:55:51 <mornfall> nitrix: ncurses? language-c? you aren't wasting time are you? :-)
10:55:57 <vanila> shouldn't these be replaced by now
10:56:02 <monochrom> no automatic dependency chasing for executable-only stuff
10:56:03 <Cale> vanila: hm?
10:56:11 <vanila> with parsec or something
10:56:31 <mornfall> aww parsec
10:56:32 <nitrix> mornfall: How come?
10:56:33 <mornfall> that's cute :-)
10:56:44 <geekosaur> the ncurses package may not be appropriate; there's I think 3 curses wrappers, one of which is ancient and unlikely to build properly against modern ncurses
10:56:44 <mornfall> nitrix: I thought you just started with Haskell
10:56:49 <nitrix> mornfall: Sure.
10:56:55 <Cale> I'm pretty sure that happy generates faster parsers than Parsec generally can.
10:57:09 <vanila> That kind of patronizing tone is really rude and not appreciated
10:57:28 <monochrom> I see no patronizing tone
10:57:30 <geekosaur> oh, ncurses is the up to date one, I must be thinking of hscurses
10:57:58 <geekosaur> but, whether happy/alex or parsec/attoparsec/uuparsinglib/etc. is appropriate depends on the parser
10:59:10 <Cale> Also, iirc, GHC's parser is written in Happy, which gives it a certain amount of resistance to death.
10:59:26 <geekosaur> yes
10:59:30 <nitrix> It's using happy _and_ alex, interesting.
10:59:36 <geekosaur> every so often they *do* review that and happy continues to win
10:59:47 <mornfall> nitrix: it's like yacc and flex, they come in pairs, usually
10:59:53 <mornfall> bison and flex, whatever
10:59:53 <nitrix> Ah, okay.
11:00:12 <nitrix> alex being the lexer I suppose (and my name).
11:00:13 <EvanR__> resistance to death amulet
11:00:24 <geekosaur> (also there are dependency cycle issues with dragging parsec or attoparsec into the core of ghc)
11:00:51 <geekosaur> whereas with happy you can generate the parser on another platform
11:01:11 <mornfall> geekosaur: well, parsec-ing haskell sounds like a proper nightmare to me
11:01:16 <Cale> Are there still monads in GHC which don't use the Monad class?
11:01:49 <Cale> (I recall there were for a long time)
11:01:56 <geekosaur> mornfall: most of the nasty stuff can't be handled by a parser *at all*, it has to be handled afterward by adjusting the AST
11:02:10 <geekosaur> the parser part is actually fairly staightforward
11:02:10 <vanila> I don't understand what your aim is in telling me that I'm not being patronized other than to dismiss it
11:02:46 <vanila> am I supposed to just say nothing if someone is being rude to me or what?
11:02:49 <mornfall> geekosaur: well, writing fast parsers with decent error reporting is not easy
11:03:07 <Cale> vanila: Who was rude to you?
11:03:10 <geekosaur> true, but parser generators don't necessarily help you much with that
11:03:15 <vanila> Cale, mornfall
11:03:19 <Cale> when?
11:03:26 <vanila> and monochrom refuses to acknowledge it
11:03:37 <duetosymmetry> hello #haskell
11:03:47 <Cale> duetosymmetry: Hello!
11:03:53 <duetosymmetry> I've got a question about Data.Hashable.hash
11:03:55 <EvanR__> the principal wants to see you two in his office
11:03:59 <vanila> When I said about replacing the use of happy with alex, and they said that was "cute" because it's not performant enough or something
11:04:36 <vanila> EvanR__, you are part of this problem now too
11:04:41 <quchen> duetosymmetry: … yes?
11:04:54 <duetosymmetry> I was writing something where locations on an integer lattice are used in generating hash values
11:05:10 <duetosymmetry> …but there are some hash collisions for small integer values
11:05:22 <duetosymmetry> hash (-1,-2) == hash (1,0)
11:05:54 <duetosymmetry> this seems like a pretty unfortunate hash collision
11:06:17 <duetosymmetry> i don't know what is the "right" way to deal with this?
11:06:22 <quchen> hash for Int is simply "id"
11:06:26 <c_wraith> duetosymmetry: I agree, that is unfortunate.
11:06:34 <Cale> Perhaps use hashWithSalt?
11:06:36 <duetosymmetry> quchen: yes. O
11:06:47 <duetosymmetry> quchen: yes. I'm aware
11:07:04 <duetosymmetry> I don't think that using hashWithSalt changes this
11:07:19 <wirrbel> what strategies do you have to cope with the haskel module system?
11:07:35 <Cale> oh, apparently not
11:07:37 <duetosymmetry> hashWithSalt 1699868174959416284 (-1,-2) == hashWithSalt 1699868174959416284 (1,0)
11:07:39 <duetosymmetry> True
11:07:41 <wirrbel> I am very much used to module systems with clear namespaces per package, like python
11:07:41 <mornfall> geekosaur: While I'm all for LL parsing, I suspect LR makes some of the desirable things in a programming language parser much easier
11:07:52 <quchen> duetosymmetry: You could write your own tuple instance that adds its own salt. But you're right, this is unfortunate.
11:07:58 <Iceland_jack> vanila: I agree, that comment was not appropriate
11:08:01 <wirrbel> while not perfect, I kind of can discover what a module containes directly
11:08:24 <wirrbel> in haskell I am often lost because symbols seem to be put somewhere into the global namespace tree
11:08:50 <duetosymmetry> is writing my own instance the "right" thing to do?
11:09:06 <Cale> wirrbel: One thing that can help is to generate all the documentation for the packages you install. You'll get a global index that way.
11:09:21 <vanila> Iceland_jack: Thanks, normally mentioning anything like this here just gets everyone attacking me further, like happened a bit
11:09:33 <vanila> I'm glad at least one people understands what I'm talking about
11:09:49 <Cale> duetosymmetry: Perhaps! I don't think the hash there is really meant to be all that resistant to collisions, it's just meant to be cheap.
11:09:53 <quchen> duetosymmetry: Hashable is supposed to be used to implement hash-based data structures. If it helps you to add your own salt to achieve this there's nothing wrong with it.
11:10:15 <corgifex> wirrbel: what global namespace tree?
11:10:32 <k00mi> wirrbel: do you know about qualified imports?
11:11:06 <Cale> I think wirrbel's problem is that he's trying to read code that someone else has written and which imports a bunch of modules unqualified.
11:11:08 <c_wraith> I think wirrbel actually means the package -> module namespacing isn't clear
11:11:25 <wirrbel> Cale, that is my problem
11:11:31 <duetosymmetry> quchen: thanks. more generally, should I think of the default implementation as a 'bad' hash?
11:11:38 <corgifex> c_wraith: that doesn't affect symbols, though
11:11:38 <wirrbel> I know that I can import qualified
11:11:52 <quchen> duetosymmetry: Not at all. "id" is a perfect Int->Int hash function after all.
11:11:56 <c_wraith> wirrbel: importing infix operators qualified sucks, though
11:12:02 <duetosymmetry> I would expect some integer pairs (common for games etc.) to have unique hashes
11:12:17 <duetosymmetry> within a radius of a few tens of the (0,0)
11:12:20 <quchen> duetosymmetry: The collision you're experiencing is really just a consequence of how the default tuple instance passes previous hashes on to new values.
11:12:24 <Iceland_jack> I would like #haskell to be more welcoming than this
11:12:40 <monochrom> I don't see any difference between python "import x from os" and haskell "import Os(x)"
11:12:53 <wirrbel> infix operators are something I feel that is also slowing me down when reading haskell code, its really hard to trace them back to their origin
11:13:02 <duetosymmetry> quchen: I saw that there is `combine` which involves (*) and xor
11:13:11 <Cale> wirrbel: Usually it's at least somewhat clear from context which *package* something comes from, in which case you can look up its documentation on hackage, and go to the index to locate the symbol that it comes from. If you've configured cabal to generate documentation (sad that this isn't the default), then you can also open up that documentation and find an index of all the symbols from all packages.
11:13:16 <Cale> (that you've installed)
11:13:25 <duetosymmetry> quchen: I would have expected this to be a common idiom
11:13:40 <merijn> Cale: Ah, thanks, you just reminded me to fix my cabal config file before doing anything today :)
11:13:47 <Cale> wirrbel: Another option is to open up the module you're working on in ghci and use :info symbolName
11:13:48 <k00mi> monochrom: if everyone would be using that or qualified imports everywhere, all would be fine
11:13:53 <EvanR__> when i first started i did not know where to look for <*>
11:14:10 <k00mi> monochrom: but sadly in haskell the default are open unqualified imports
11:14:15 <quchen> duetosymmetry: It costs some additional computational steps, and the default instance is the simplest one. Hashable doesn't guarantee anything, really, so there is no need to add those steps. (In general.)
11:14:19 <Cale> wirrbel: Which will tell you where it comes from and what its type is and a bunch of other stuff, depending
11:14:36 <wirrbel> Cale, :info symbolName seems handy
11:14:42 <merijn> k00mi: For me it depends what I'm importing
11:14:42 <quchen> duetosymmetry: Unfortunately, `combine` is not exported. :-(
11:15:01 <wirrbel> taking hmatrix for example
11:15:02 <wirrbel> http://hackage.haskell.org/package/hmatrix
11:15:07 <merijn> k00mi: i.e. I don't bother qualified imports for Control.Applicative, Control.Monad and similar modules you import *everywhere*
11:15:23 <k00mi> merijn: I agree, I think most of base is safe to import unqualified
11:15:53 <Cale> wirrbel: hmm, the docs for 0.16.x seem to have not generated
11:15:56 <wirrbel> lots of modules thematically aranged, when reading source code that might use hmatrix I really cannot tell that they use it from looking at the imports, oft course I know when I am fluent with hmatrix and know the imports
11:16:41 <Cale> wirrbel: Oh, well, you can also look in the project's .cabal file to see what packages it depends on
11:17:26 <Cale> wirrbel: and you can see a summary of hmatrix's own dependencies on that page (array, base, binary, deepseq, ...)
11:18:11 <wirrbel> hmm alright, so I see there is not much more I can do than what I do right now
11:20:55 <swgillespie> so is ap in Control.Monad the same as <*> for applicative functors?
11:21:09 <copumpkin> yes
11:21:28 <merijn> :O
11:21:31 <quchen> swgillespie: All Monads are also Applicative, and it's a law that <*> has to do the same as "ap".
11:21:32 <swgillespie> does that imply that all monads are applicative functors?
11:21:37 <c_wraith> yes
11:21:41 <swgillespie> ah, awesome, thanks
11:21:44 <c_wraith> GHC 7.10 will even enforce it
11:21:44 <merijn> My new cabal automatically set Documentationa and library-profiling to True?
11:22:01 <nitrix> Could someone explain this to me? http://ideone.com/sseJLe, line #8 is bogus, expected type is Curses (), the actual type returned is an IO (). I checked baudrate's documentation and it does indead return a Curses Integer.
11:22:06 <nitrix> So what's happening?
11:22:20 <c_wraith> swgillespie: in GHC 7.8, it's a warning for a type to have a Monad instance but not an Applicative instance.  In 7.10, it will be an error.
11:22:32 <swgillespie> c_wraith: gotcha, very cool. thanks!
11:22:34 <EvanR__> nitrix: you should check the type directly
11:22:47 <sbrg> nitrix: print is IO ()
11:22:49 <Cale> nitrix: I think it's complaining about the print
11:22:58 <monochrom> merijn: if it does that, I welcome it.
11:23:05 <gamegoblin> > sequence [Just 5, Just 3]
11:23:07 <lambdabot>  Just [5,3]
11:23:11 <gamegoblin> > sequence [Just 5, Nothing, Just 3]
11:23:12 <lambdabot>  Nothing
11:24:03 <tulcod> > sequence$sequence [Just$Just 1, Just$Just2]
11:24:04 <lambdabot>  Not in scope: data constructor ‘Just2’
11:24:04 <lambdabot>  Perhaps you meant ‘Just’ (imported from Data.Maybe)
11:24:08 <tulcod> > sequence$sequence [Just$Just 1, Just$Just 2]
11:24:09 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
11:24:09 <lambdabot>  Expected type: [Data.Maybe.Maybe a]
11:24:09 <lambdabot>    Actual type: Data.Maybe.Maybe (Data.Maybe.Maybe a)Couldn't match type ‘Dat...
11:24:09 <lambdabot>  Expected type: [Data.Maybe.Maybe a]
11:24:09 <lambdabot>    Actual type: Data.Maybe.Maybe (Data.Maybe.Maybe a)
11:24:21 <nitrix> sbrg: Is there any way to perform a conversion?
11:24:38 <sbrg> nitrix: liftIO may work
11:24:45 <sbrg> i don't know the curses library
11:24:47 <nitrix> Or maybe I'm misunderstanding the situation.
11:25:03 <sbrg> nitrix: You're running 'inside the Curses monad', so to speak
11:25:15 <nitrix> Correct.
11:25:32 <nitrix> So, monads are meant to be isolated?
11:25:32 <sbrg> :t print
11:25:33 <lambdabot> Show a => a -> IO ()
11:25:42 <sbrg> print does not have the same type
11:25:53 <nitrix> I get that.
11:26:08 <Cale> nitrix: Types are supposed to be isolated, it doesn't really have much to do with monads in particular
11:26:13 <EvanR__> to get debug messages from anywhere you can use Debug.Trace
11:26:32 <EvanR__> which cheats the type system using unsafePerformIO
11:26:52 <nitrix> Cale: It seems troublesome that a Curses Integer cannot act like an IO Integer, but what do I know.
11:26:54 <sbrg> nitrix: But looking at hackage, if you want to be outputting stuff using the curses library, you should be using drawString
11:26:59 <Cale> It seems like the Curses library ought to have *some* mechanism for putting things on the terminal :P
11:27:22 <nitrix> Yeah but I wanted to do it without the terminal :(
11:27:30 <nitrix> Consider writing to a file for example.
11:27:31 <EvanR__> a Curses Integer and an IO Integer aren't Integers
11:27:49 <nitrix> Ah?
11:27:54 <c_wraith> nitrix: writing to a file? That's..  not something usually done with curses.
11:27:57 <monochrom> please don't use curses to write to a file
11:28:10 <c_wraith> nitrix: curses isn't a pretty-printing library.
11:28:13 <joelteon> use vty
11:28:14 <nitrix> c_wraith: The hell are you saying. Logging is a perfectly good usecase.
11:28:17 <joelteon> no, no, I jest
11:28:40 <nitrix> c_wraith: curses doesn't write to a file, but the program may.
11:28:42 <monochrom> logging doesn't need curses
11:28:47 <nitrix> Of course not.
11:28:50 <monochrom> oh, I see
11:28:54 <c_wraith> nitrix: you should write byttes to a file.  Not screen-formatting instructions.
11:28:55 <nitrix> But curses is triggering logging actions.
11:29:12 <c_wraith> nitrix: is Curses an instance of MonadIO?
11:29:17 <monochrom> but don't use print for logging
11:29:19 <sbrg> @hoogle liftIO
11:29:20 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
11:29:21 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
11:29:21 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
11:29:26 <Cale> It is.
11:29:36 <sbrg> nitrix: import Control.Monad.IO.Class and use liftIO before any IO action
11:29:40 <Cale> liftIO will convert any IO action into a Curses action
11:29:41 <nitrix> c_wraith: It is.
11:29:48 <monochrom> liftIO (hPrint loghandle abc) is fine for logging
11:29:56 <Cale> However, you probably should consider moving any unrelated IO out of your Curses actions
11:29:57 <c_wraith> nitrix: then listen to everyone telling you to use liftIO
11:30:33 <monochrom> liftIO (print abc) is, like, you're stepping on curses's toes
11:30:55 <nitrix> It's not really a matter of doing it, because it's not something I _need_ to do. I'm curious how it'd be done if I had to call a function that expects a different type while I'm inside a monad.
11:31:02 <tac_> sbrg: is that the preferred place to import liftIO from?
11:31:02 <Cale> Though I don't really know how that library works, maybe you're meant to have your whole program inside of the single application of runCurses
11:31:05 <tac_> I was wondering that the other day
11:31:24 <sbrg> tac_: I've never really found out. Sometimes, using certain libraries, it seems they export it for you. Sometimes they don't
11:31:31 <EvanR__> nitrix: typically youd want to separate the IO actions from "non IO" monadic code
11:31:48 <tac_> oh, and Cale: Thanks for the one-liner recommendation for the time library. I had looked at it a long time ago, and mistakenly wrote it off as a viable datetime library for some dumb reason
11:31:52 <nitrix> EvanR__: What if the non-IO triggers IO ?
11:31:57 <sbrg> tac_: but I know what you mean -- it doesn't 'feel' like something you're supposed to be importing, heh.
11:32:07 <tac_> Cale: it's actually really welll-designed, if you take the time to read all the docs
11:32:13 <Cale> tac_: yes :)
11:32:15 <EvanR__> nitrix: it cant, but as you say, curses is an IO-like monad so you can do whatever you want with liftIO
11:32:25 <c_wraith> tac_: yeah, time is the least screwed-up time library I've seen.
11:32:29 <nitrix> I see.
11:32:29 <tac_> yeah
11:32:33 * hackagebot aws 0.9.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.9.3 (AristidBreitkreuz)
11:32:48 <nitrix> That certainly makes me feel better then. Knowing it's at least possible.
11:32:50 <tac_> The literal only thing I would like to see improved is a tutorial on the hackage page of how to use it.
11:33:23 <nitrix> Even if it's not someting you'd want to do; having the ability to do it is interesting.
11:33:32 <tac_> since the three or four critical functions for actually _generating_ the datetime/day/localtime objects are hard to pick out for newbies
11:33:33 <sbrg> nitrix: it isn't always. But in this case, Curses is an instance of MonadIO, so you can do that.
11:33:50 <c_wraith> nitrix: in general, look at instance lists in the documentation.  They hold a ton of *really* important information.
11:34:20 <c_wraith> nitrix: they're really easy to overlook, for whatever reasons, for how much important functionality they can have.
11:34:23 <nitrix> Right. Thanks.
11:34:37 <monochrom> they occupy little space
11:34:44 <Cale> nitrix: There are two processes taking place while any Haskell program runs: evaluation (converting expressions to values), and execution (carrying out the instructions described by IO actions). Evaluation (aside from some low-level hooks that aren't normally used), never causes execution to occur, but the process of executing IO actions will involve evaluating them to figure out what is to be done.
11:35:12 <EvanR__> nitrix: it makes sense in this case because curses is already has IO-like semantics, im guess it has callbacks. but if you were using Maybe or List or a Parser it might not make as much sense to "escape out" and do IO there
11:35:15 <c_wraith> ...  I kind of wish haddock generated specialized type signatures for every function that is part of an instance for a type and included them in the page.
11:35:32 <nitrix> EvanR__: I see. Makes sense indeed.
11:35:52 <c_wraith> So in the case of Curses and MonadIO, it'd include IO a -> Curses a on the page *somewhere*
11:36:04 <Cale> nitrix: In the end, your 'main' is an IO action, and it gets executed. In turn, it might use other IO actions as part of itself, and it might use expressions built up from things having nothing to do with IO.
11:37:26 <sbrg> IO is the universe, man. If you could just, like, break out or something, you'd just be, like, floating in the void, yo.
11:38:04 <EvanR> MonadTranscendental
11:38:08 <c_wraith> lazy evaluation is like quantum superposition and IO is waveform collapse.
11:38:27 <tac_> seq is like killing that poor cat :(
11:38:30 <c_wraith> Well, execution of IO is waveform collapse.
11:39:06 <c_wraith> tac_: even seq doesn't do anything unless its result is demanded by execution.
11:39:08 <Cale> :P
11:39:22 <Cale> I hate analogies with QM, they're always so wrong
11:39:31 <c_wraith> tac_: I'd say that seq is entanglement, to make the analogy worse. :)
11:39:37 <tac_> @type evaluate
11:39:38 <lambdabot> a -> IO a
11:39:40 <tac_> heh
11:39:48 <johnw> Cale: I both hate and love analogies with QM, but I can't decide until I see one
11:39:53 <monochrom> seq is like a button waiting for someone to push.
11:39:55 <sbrg> johnw: hah
11:39:59 <tac_> I prefer ez yang's ghosts & presents analogy personally
11:40:01 <jfischoff> johnw: hiyo!
11:40:05 <johnw> jfischoff: hello!
11:40:07 <monochrom> johnw wins!
11:40:15 <EvanR> if the program was total, lazy evaluation would be indistinguishable from eager, so the superposition analogy is describing something else ;)
11:40:17 <jfischoff> \o
11:40:26 <Philonous> monochrom, A big round button or a flashing square one?
11:40:47 <tac_> EvanR: When if we don't know it's total until someone finds a bug in the termination checker?
11:40:49 <monochrom> I don't know. which one do you like?
11:40:51 <benzrf> EvanR: it's not an analogy, it's how the universe works!
11:41:02 <sbrg> you don't know what kind of button is until you press it.
11:41:06 <benzrf> superposition is just an unevaluated thunk
11:41:09 <EvanR> undefined evaluation order isnt quantum superposition
11:41:16 <benzrf> observation forces the thunk
11:41:17 <EvanR> or unevaluated
11:41:34 <benzrf> entanglement occurs due to thunk-sharing
11:41:54 <monochrom> meanwhile, in ##physics: "QM is like haskell"...
11:41:57 <johnw> benzrf: it's funny that a hundred years ago, we'd be discussing mechanical machines and saying, "But that's how the universe works!"
11:41:58 <sbrg> Haskell. The programming language with semantics that almost have meaningful parallels in quantum physics
11:42:07 <c_wraith> But not really. :)
11:42:07 <Cale> Unless whatever you're talking about involves a complex projective Hilbert space of states, your analogy to QM is probably not appropriate :P
11:42:11 <Lowl3v3l> monochrom lol :D
11:42:24 <benzrf> implying i know anything about QM beyond the pop science level
11:42:36 <corgifex> I want Data.ByteString.Char7
11:42:41 <benzrf> corgifex: eew
11:42:49 <EvanR> programming language implementations are all like those 100 year old machines
11:42:58 <EvanR> in substance
11:43:02 <sbrg> Data.ByteString.QBit
11:43:21 <c_wraith> corgifex: that'd be a more correct name for .Char8.  :P
11:43:28 <EvanR> quantum parallel haskell notwithstanding
11:44:44 <mornfall> Iceland_jack: (I know vanila's gone by now, but anyway, out of curiosity... how is my comment “Y is cute” more offensive than their “why does X even exist”?)
11:45:49 <Iceland_jack> It sounds patronizing even if that wasn't the intent, the ':-)' smiley doesn't help
11:47:43 <monochrom> oh, I see, is it "parsec is cute" vs "it is cute of you to suggest parsec"?
11:47:49 <monochrom> is it simply that?
11:48:47 <hotguy77> in time he will seek you out
11:49:00 <sbrg> Who?!
11:49:46 <EvanR> haha
11:51:05 <burp> mornfall: so coming back to data DataX = Foo | Bar {x :: TypeX, … }, and  extractx :: [DataX] -> [TypeX]; with fclabels I'd use extractx = catMaybes . map (Data.Label.Partial.get x)?
11:52:13 <NikolajK> why are there actually two words, "data" and "type"? Why not make all "type"?
11:52:31 <Cale> NikolajK: Because they're completely different things?
11:52:57 <Cale> type declares type synonyms, i.e. new names for existing types, which won't be distinguished from the original types by the type checker
11:53:02 <NikolajK> I thought the things you set up with the data keywords are types too
11:53:06 <c_wraith> NikolajK: if you really want to rename something, rename "type" to "synonym"
11:53:08 <Cale> data declares new datatypes altogether
11:53:43 <Cale> The types defined by data declarations will be treated by the type checker as distinct from any other existing type
11:53:44 <c_wraith> NikolajK: type creates a new name that stays compatible with what it expands to
11:53:46 <EvanR> newtype also declares new (data?)types
11:54:10 <c_wraith> NikolajK: for instance, type String = [Char]
11:54:23 <Cale> Yeah, newtype is sort of in between, it creates new types which are equivalent in implementation to an existing type, but nonetheless treated as distinct for typechecking.
11:54:51 <NikolajK> okay, then I guess I just find the keyword "data" strange.
11:55:13 <EvanR> im also interested in the meaning, rationale, etymology of "datatype" vs "type"
11:55:15 <NikolajK> it's like calling shoeboxes "shoe"
11:55:22 <Cale> We could use "inductive" or something like that
11:56:10 <monochrom> NikolajK: don't read deeply into the reserved words "data" and "type". they are just reserved words.
11:56:36 <NikolajK> I find it sad that type judgements are written with double : :/
11:56:54 <merijn> NikolajK: Why?
11:56:59 <monochrom> oh, that one I have a word to say
11:57:29 <merijn> NikolajK: ocaml/sml used to have single : type signatures and :: list cons, after writing those languages I can say that that way around is even more annoying
11:57:39 <merijn> I write list cons a lot more than type annotations...
11:57:43 <monochrom> which one do you prefer, "(x :: y :: z :: []) : [Int]" or "(x : y : z : []) :: [Int]"?
11:57:44 <int-e> NikolajK: I think the distinction is between data types that represent values that you can take a part (by pattern matching) and function types, whose values you can just apply to something and hope for the best.
11:57:53 <merijn> (Incidentally, this is why haskell used the opposite of ML)
11:57:57 <Cale> NikolajK: The expectation is that you'll only ever have about one :: per line, while list conses usually come in bunches, so shorter notation is nicer there
11:58:15 <c_wraith> NikolajK: you could turn on -XUnicodeSyntax and use the unicode double-colon character if you like.
11:58:37 <monochrom> a simple Huffman-code argument implies that (x : y : z : []) :: [Int] is less redundant
11:58:40 <merijn> Haskell is like bureaucracy, everything gets answered in triplicate :>
11:58:53 <int-e> @quote fugue
11:58:53 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:58:54 <NikolajK> okay, I think you have a point
11:59:16 <NikolajK> I don't like a lot of notation
11:59:19 <EvanR> but in a language with way more type programming maybe : is better for type annocations
11:59:22 <EvanR> annotations
11:59:29 <NikolajK> is there a language which write xf for function application?
11:59:32 <monochrom> yeah, such as Java :)
11:59:41 <NikolajK> kek
12:00:02 <monochrom> yikes, incidentally, "java" answers both questions!
12:00:46 <monochrom> 1. since you have to write so many types in Java, : is better, although Java doesn't actually do this
12:01:01 <monochrom> 2. function application is written x.f()
12:01:08 <NikolajK> another thing - what does functional programming lack, what procedural programming has? if someone asks me, I can not really how functional programming is special, apart from functions being passable
12:01:09 <quchen> ?quote contrapuntal
12:01:09 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:01:13 <quchen> ^ merijn
12:01:27 <merijn> quchen: You're ten lines late :)
12:01:36 <quchen> Oh.
12:01:37 <quchen> :-(
12:01:40 <NikolajK> the notion that the code is ONE function is fuzzy: a procedural program is also one function, right
12:01:41 <monochrom> I think I have a quote for that, too
12:01:45 <monochrom> @quote @quote
12:01:46 <lambdabot> ion says: @@ @remember lambdabot @quote
12:01:51 <monochrom> @quote monochrom @quote
12:01:51 <lambdabot> monochrom says: * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
12:02:03 <monochrom> hmm, no, let me find first in PM
12:02:03 <sbrg> Now I have to look up what the hell contrapuntal fugues are.
12:02:07 <corgifex> NikolajK: side effects
12:02:41 <monochrom> oh, I see, mine said @remember, but anyway
12:02:55 <monochrom> @quote monochrom @remember
12:02:56 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
12:03:16 <mjrosenb> any arch users in here?
12:03:46 <NikolajK> corgifex: but there isn't a high level language where you can't avoid side effects, I'd assume
12:03:59 <corgifex> how about Haskell?
12:04:15 <NikolajK> ?
12:04:40 <NikolajK> you mean you vacuously can't avoid them?
12:04:51 <corgifex> what?
12:05:00 <NikolajK> I mean in Fortran, can't you just also code without side effects?
12:05:07 <corgifex> I don't know fortran
12:05:21 <NikolajK> just by choosing to write strange code
12:06:09 <EvanR> you can consider writing to local variables as not being a side effect in some sense
12:07:17 <NikolajK> I'd say/explain object oriented programming has objects. You can explain the object concept and point out how they look in Java. But if I write f.g in Haskell, thinking about how f and g should be coded, then that's not different than procedural coding to me.
12:08:00 <NikolajK> When someone asks, what is functional programming, or quote "why is it important", then I can say you can make things smooth if you're allowed to pass functions as first class arguments.
12:08:01 <EvanR> its possible to write pure code in non-haskell languages and often times this is a great idea
12:08:22 <Philonous> NikolajK, I think your question isn't well-posed. Functional programming isn't a well-defined thing and it certainly isn't opposed to imperative or procedural programming.
12:08:39 <NikolajK> I guess
12:10:42 <lpvb> code is never pure it will always heat up the room
12:11:04 <EvanR> even if it is chiseled into a rock just sitting there?
12:11:09 <NikolajK> hey, is there a module available which lets me parse first order logic written in LaTeX into its tree form
12:11:35 <NikolajK> A\land B to some read to use expression
12:11:43 <NikolajK> the quantifiers might be the tricky part
12:11:48 <lpvb> for you to see that code would require it to emit radiation
12:11:56 <EvanR> lol
12:12:04 <NikolajK> obviously, it doesn't matter much if it's latex or another formal representation of that logic
12:12:22 <EvanR> so it is the questioner who is heating up the room, unless the room is body temperature
12:12:51 <NikolajK> HoTT is heating up my first order logic
12:13:21 <NikolajK> I'd figure type inference people have worked enough with formal logic for there to be code available
12:13:34 <NikolajK> in particular, I want to map haskell code to 2D pictures
12:13:38 <EvanR> you can write the parser yourself with parsec, and there are some latex libraries, im not sure if theres something so specific for your case
12:13:48 <NikolajK> okay
12:13:57 <NikolajK> I've started reading up on parsec, actually
12:14:14 <NikolajK> in Real World Haskell
12:14:22 <Vulpyne> Hmm. Still banging my head against the type safe state machine problem. This is what I came up with (the magical type bits are totally stolen): https://gist.github.com/vulpyne/c2b9fd0c48a3c7290967
12:14:35 <EvanR> NikolajK: randomly found this http://hackage.haskell.org/package/HaTeX-3.3/docs/Text-LaTeX-Base-Parser.html
12:15:02 <Vulpyne> It works perfectly, but the issue now is I need to store the current state in a record, and I need to store the records in a map. Since each state has a separate type, I'm not sure how to accomplish that.
12:15:15 <NikolajK> okay, thx
12:15:26 <EvanR> did you try making a single state type
12:15:42 <Vulpyne> And it seems like using a class would basically require pattern matching on some constructor, and therefore would lose the compile time safety.
12:16:03 <NikolajK> why is there no alternative for "deriving Show". it looks like that's used almost always
12:16:17 <Maior> alternative?
12:16:19 <Vulpyne> Well, it is a single state type indexed by a list of the types it can transition to. IE, State '[OKTransition1,OKTransition2]
12:16:31 <gamegoblin> Is there an extension that will let me write some patterns of a function in point free form and some pointfully? as a contrived example:     f 0 = 5; f = id
12:16:52 <Vulpyne> gamegoblin: Don't think so.
12:17:03 <EvanR> Vulpyne: interesting, the transaction table could also be provided separately
12:17:22 <Vulpyne> EvanR: How do you mean?
12:17:30 <orion> Anyone have an example of the output of ghc-mod type ... ?
12:17:47 <EvanR> Map (S,I) S
12:18:13 <EvanR> for every combination of state and input
12:18:16 <Vulpyne> By transaction table, you mean a list of states and their valid transitions?
12:18:25 <EvanR> i meant transition table
12:18:34 <orion> Every time I call `ghc-mod type file.hs Main 7 7` (for example) I get no output.
12:19:01 <Vulpyne> I guess I still don't get what you're talking about.
12:19:18 <Vulpyne> Are you sure what you are proposing would catch any invalid state transition at compile time?
12:20:11 <Vulpyne> What I have currently in the GIST I linked to fulfills that requirement, the only issue is storing records with the current state embedded.
12:20:20 <EvanR> i dont think what im talking about would, since its representation is totally in that map, at runtime
12:20:46 <Vulpyne> Ah, yeah. Then that isn't what I want. I'm trying to get Haskell's static typing to detect any invalid transitions. Did you look at the GIST I posted?
12:21:08 <Vulpyne> Validating state transitions at run time is pretty easy, but I'd like to avoid the possibility of runtime errors completely.
12:22:02 <EvanR> so this defines valid transitions, but not necessarily exactly how the machine should behave?
12:22:39 * hackagebot sext 0.1.0.0 - Lists, Texts and ByteStrings with type-encoded length  http://hackage.haskell.org/package/sext-0.1.0.0 (DmitryDzhus)
12:22:39 <Vulpyne> The s0, s1, s2, s3 functions show actually transitioning through the states.
12:22:43 <EvanR> oh at the bottom
12:22:57 <Vulpyne> Yeah.
12:23:06 <EvanR> that set of functions is what i was thinking of
12:23:12 <EvanR> originally
12:23:14 <Vulpyne> And that part actually works, it just won't let you transition into an invalid state.
12:23:47 <Vulpyne> The issue is that each state has a different type, so storing it in a record or map of records becomes a lot more complex.
12:24:34 <Vulpyne> I'm not even sure what I want to do is possible.
12:24:46 <EvanR> when you read the file, is there some kind of validation at that point
12:25:18 <Vulpyne> This is just a toy example to get the machinery working. The actual application for it is a network server.
12:25:54 <Vulpyne> The network server has a state machine where client dialogs can transition through states in certain ways.
12:27:34 <EvanR> is it guarding against user input attempting to go into an invalid state, or guarding again the dialog having a bug that attempts to go into an invalid state
12:27:40 * hackagebot apiary 0.15.2 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.15.2 (HirotomoMoriwaki)
12:27:42 * hackagebot apiary-purescript 0.15.2 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.15.2 (HirotomoMoriwaki)
12:27:50 <mornfall> burp: sorry I was away
12:28:04 <Vulpyne> Guarding against me writing buggy code that does invalid transitions. :)
12:28:20 <codygman> I feel like there is a way to take the duplication out of this function: http://lpaste.net/109172#line40
12:28:21 <Vulpyne> The program will receive input, it'll do something based on the current state, and then it'll transition to a new state.
12:28:36 <EvanR> is the state machine transition rules a simple table? or a big complex set of functions
12:29:07 <mornfall> burp: why can't you use total lenses? (maybe I don't exactly remember your use case)
12:29:09 <Vulpyne> Pretty similar to what you see defined in the GIST.
12:29:16 <Vulpyne> There are a couple more states I will probably add.
12:29:39 <EvanR> in this case, how do you make sure your types are right ;)
12:29:48 <EvanR> to validate against
12:30:22 <Vulpyne> I don't think there's any way to protect me from my own stupidity in that case.
12:30:31 <Vulpyne> If I define the state machine transitions incorrectly, I'm screwed.
12:30:39 <mornfall> burp: in which case you don't need the catMaybes... extractx = map (get x)
12:30:59 <Vulpyne> But since they're all going to be in one place, I don't think that's too big an issue. I worry more about writing the code that transitions through the states.
12:31:08 <Vulpyne> I can of course manually check it, but that is pretty error prone.
12:31:09 <EvanR> i was thinking of this state machine definition thing, and i came up with a single type for the state, and functions of form S -> S or (S,I) -> S
12:31:45 <Vulpyne> Does that actually allow verifying the state transitions at compile time though?
12:31:46 <EvanR> and this seemed like equally as much to verify as a type
12:32:17 <EvanR> the transition function itself serves as the types you have
12:32:29 <EvanR> both semantically unchecked
12:32:33 <EvanR> but no runtime crash will occur
12:32:43 <mornfall> codygman: you could say where x l = lookup l p, but that doesn't help much does it
12:33:03 <Vulpyne> The types I have currently will detect an invalid transition at compile time.
12:33:17 <EvanR> f S1 _ = S2
12:33:25 <codygman> mornfall: I thought I could do something like: liftA3 (User . lookup) "first_name" "last_name" "email" but that doesn't actually make sense
12:33:26 <mornfall> codygman: tricks with fold will probably only make things worse
12:33:28 <EvanR> f S2 x | x > 0 = S3
12:33:30 <EvanR> etc
12:33:46 <Vulpyne> Yeah, but that will only detect errors at run time.
12:33:58 <Vulpyne> And those errors will need to be handled somehow.
12:34:07 <EvanR> unless there is an error state and the function is total, there would be no error possible by definition
12:34:10 <EvanR> unless i put the wrong state in
12:34:13 <codygman> mornfall: Yeah, I'm just exploring. It's already concise enough, but if there were another way I'd like to know ;)
12:34:14 <EvanR> but thats the same as your types
12:35:03 <Vulpyne> What if state == S1, and I call f state S3, but S1 -> S3 is an invalid transition?
12:35:15 <EvanR> the second arg in my example isnt a state
12:35:25 <Vulpyne> Sure, I can pattern match against that state combination and return an error in f, but that doesn't really help.
12:35:59 <Vulpyne> It's the Int part of the "State Int" from my example code?
12:36:26 <EvanR> im assuming the machine takes some input to help decide the transition
12:36:35 <EvanR> it doesnt have to
12:36:46 <supki_> codygman: buildUser = (liftA3.liftA3) User (lookup "first_name") (lookup "last_name") (lookup "email")
12:37:28 <EvanR> i dont really understand the source of an invalid transition
12:37:45 <codygman> supki_: Awesome! Now I can figure out how that works, I already have an idea ;)
12:38:48 <Vulpyne> Yes, the machine does take input. It looks at the input and the current state and calls a handler function to deal with the input. That function is going to want to transition to a new state after it completes.
12:38:51 <EvanR> without input, f S1 = S2, f S2 = S3, f S3 = S3 couldnt fail, and seems to be a pretty small spec
12:39:50 <Vulpyne> So suppose the state is S1 which can validly transition to only S2. However, I'm dumb and wrote my handler function to transition to S3 instead - I want that to be caught at compile time.
12:40:10 <EvanR> well youd use f on S1 and it would be S2
12:40:20 <EvanR> that case of the def is the spec
12:40:42 <EvanR> if i wrote a type also saying that, i guess youd have duplication-style error detecting code
12:41:03 <EvanR> so if they disagreed that would be an error
12:41:17 <Vulpyne> Maybe that example was too simple. It's more like: S1 -> S2,S3; S2 -> S1; S3 -> S2,S4; S4 -> S1
12:41:18 <burp> mornfall: I don't see how that works ( http://lpaste.net/109173 ) with Data.Label.Total
12:41:32 <EvanR> S2 or S3 depending on input?
12:41:42 <EvanR> or is it random
12:42:08 <mornfall> codygman: (I guess lenses/fclabels could help in your case as well, by providing functions to add things to a User and build it up that way instead of constructing it in one go :-)
12:42:38 <Vulpyne> It'll always start out in S1, then it'll call a function to handle input and that function will transition the state. Transitioning to S2 or S3 would be valid (which it is will be based on various non-deterministic factors), but what if I write it so the function transitions to S4?
12:43:20 <mornfall> burp: OK, I didn't realize you had multiple constructors
12:43:34 <Vulpyne> What's frustrating for me is the code I have satisfies that constraint perfectly.
12:43:35 <mornfall> burp: for a straight record that'd work though
12:43:47 <burp> mornfall: oh ok, yes
12:43:48 <Vulpyne> The only issue is storing and retrieving the state dynamically, since the type of the state changes.
12:43:50 <mornfall> burp: (or for one where x was there for all constructors)
12:43:58 <EvanR> yeah so its validating even less than what i would expect
12:44:11 <EvanR> but since its non deterministic thats all you can do
12:44:47 <Vulpyne> Well, the function that does the transition is going to have the current state: State '[S2,S3]
12:44:48 <EvanR> so you must be able to restore this thing somehow, even to its initial state
12:45:01 <mornfall> burp: but as lpaste suggests, mapMaybe makes it quite succinct as things go
12:45:20 <Vulpyne> The GIST code does type code magic to actually determine whether one type is in the list of types encoded in State.
12:45:35 <EvanR> i see that
12:45:44 <Vulpyne> So I'll have a State '[S2,S3] and I'll have a S4, which isn't found in the list and creates a compile time error.
12:46:09 <EvanR> it compiles, but does it run?
12:46:27 <Vulpyne> Or, alternatively, I could have an S2, which is found and I can call my handler with the current state and S2 and get back a State '[S1]
12:46:34 <Vulpyne> Yeah, it runs.
12:46:58 <EvanR> which function constructs the machine in its initial state?
12:47:13 <Vulpyne> initialState
12:48:17 <Vulpyne> Each state is parametized by a *list of types* that it can validly transition to.
12:48:28 <Vulpyne> Pretty magical.
12:48:38 <EvanR> you need a case which boots up this dialog with the machine in whatever state, which would be different types, so somehow you need to "forget" the type in that routine
12:49:29 <Vulpyne> Well, creating a record with the initial state is simple. data Blah = Blah (State '[S2,S3])
12:49:40 <Vulpyne> The problem is, once I transition the type is gonna change.
12:49:56 <EvanR> so you havent figured out how to run this dialog yet?
12:50:10 <Vulpyne> So the type in Blah has to be generic enough to allow all the different types, but it still has to be possible to recover the type information.
12:50:44 <Vulpyne> I'm not sure what you mean. I've figured out how to implement the state machine such that errors are detected at run time.
12:50:44 <EvanR> meh seems wrong to simply store different types in the same record location
12:50:49 <codygman> mornfall: That is interesting, I'll have to check into it.
12:51:32 <EvanR> but you can use an existential type combined with a type rep used for serializing
12:51:48 <EvanR> but you need to verify that too
12:51:55 <Vulpyne> Yes, existential types are one way to deal with it. The problem is, I think that'll cause me to lose the static checking.
12:52:19 <Vulpyne> To do that will require some data type with multiple constructors, as far as I know.
12:52:51 <Vulpyne> I dunno. I'm just not good enough at this advanced type stuff to make it work.
12:52:56 <EvanR> i really have no idea, but simply using a record seems too obvious ;)
12:54:17 <Vulpyne> Well, thanks for the response anyway.
12:55:03 <EvanR> one way to forget a type is to have multiple constructors like, A -> C, B -> C, where C is your normal type, and A and B can be your crazy state types
12:55:35 <Vulpyne> I need to get the type back though.
12:55:36 <EvanR> it can take the liberty of providing a uniform type rep for the serialization through C
12:55:55 <Vulpyne> So I need to store it in a way that it's encapsulated, then I need to retrieve it with all the information, so that I can apply it with a transition.
12:56:11 <EvanR> well C, opaque, would be handling that
12:56:21 <EvanR> the transition, handling
12:56:54 <jophish_> Yo yo yo
12:57:08 <EvanR> it could also do the serialization directly, without going through a uniform intermediate representation
12:57:15 <jophish_> What's the current in fashion SDL2 binding library?
12:57:26 <Vulpyne> I think I almost understand what you mean. Brain hurts.
12:58:04 <EvanR> like, each time you transition, you transition to a new set of handlers which are all at different types, and obviously different implementations
12:58:05 <Vulpyne> Something like using a closure and storing that in the data type.
12:58:19 <EvanR> right
12:58:32 <EvanR> and the external app would only see a uniform type, maybe IO ()
12:59:14 <EvanR> the transition would only accept some state types, so thats compile time checking
12:59:41 <EvanR> internally it has various typed routines to do serialization and further transitioning
13:00:38 <EvanR> i think phantom types is used this way
13:00:48 <jophish_> https://github.com/Lemmih/hsSDL2 This seems to be the nicest set of bindings, but it has a fairly large todo list
13:03:13 <EvanR> SDL2? glfw-b!
13:05:15 <nitrix> The heck, it took me forever to find that / isn't the same as `div`.
13:05:22 <nitrix> Such a bad assumption on my part.
13:05:27 <NikolajK> Is there any fundamental different between a data type defined via "data MyPair = Pair Int String" and "type MyPair = (Int, String)"?
13:06:16 <EvanR> :t (/)
13:06:17 <jophish_> EvanR: As much as I love glfw, sdl has audio support :/
13:06:17 <lambdabot> Fractional a => a -> a -> a
13:06:33 <jophish_> and aside from that they both seem very similar
13:06:53 <EvanR> sdl2 maybe, bindings for sdl1 didnt expose the audio
13:07:11 <EvanR> on the whole im kind of questioning whether audio callbacks in haskell make any sense
13:07:28 <jophish_> EvanR: Ideally they'd be wrapped up nice and neat
13:07:50 <EvanR> i mean, asynchronous please fill in this n-sample mutable array
13:08:14 <EvanR> very quickly please
13:08:38 <EvanR> thats a serious "can haskell do that" question i have
13:09:25 <jophish_> I don't see why Haskell can't do a memcpy as quickly as C
13:10:08 <nitrix> Maybe the OS prefers C :(
13:10:13 <EvanR> that wouldnt be the problem
13:10:34 <EvanR> it would be the response time of the handler
13:10:37 <nitrix> Giving you page where writes are extremely slow, ahah.
13:10:49 <jophish_> EvanR: ah I see
13:11:26 <EvanR> i know there are audio applications in haskell, but i cant seem to understand the low level bits
13:11:44 <EvanR> as far as audio for general glfw apps, im surmising id use port audio
13:11:59 <pavonia> NikolajK: They have the same algebraic representation (or what it is called), but they are different types in Haskell
13:12:01 <jophish_> EvanR: My feeling is that computers are fast enough to handle this. I'll let you know how I get on though
13:12:40 <EvanR> its like computers should be fast enough to write fast 1600x1200 framebuffer graphics but they arent
13:13:26 <EvanR> and while they can compute synthetic audio samples really fast, the crap between the program and the audio system, the OS, will cause drop outs if its not low latency enough
13:14:25 <EvanR> by increasing the size of the buffer its less of a problem but then your sound effects happen 100ms after the action
13:15:00 <NikolajK> pavonia: they have the same operation associated with it right, the projections and not more
13:15:48 <pavonia> And they have the same size
13:16:14 <pavonia> They are equivalent
13:18:24 <EvanR> > (,) 1 2
13:18:26 <lambdabot>  (1,2)
13:18:34 <EvanR> :k (,)
13:18:35 <lambdabot> * -> * -> *
13:18:49 <EvanR> > (,2) 1
13:18:50 <lambdabot>  (1,2)
13:19:53 <RyanGlScott> I have a bit of an unusual style question. I'm making an ADT with several constructors representing all-caps name (e.g., MPS SC UUID).
13:20:10 <RyanGlScott> What's the best way of representing them in Haskell? MPSSCUUID? MPS_SC_UUID? MpsScUuuid?
13:20:11 <EvanR> (,), A B C, and A {a::B, b::C}
13:20:27 <merijn> RyanGlScott: I'd say the first and last are most common
13:20:29 <hpc> the last would be the best way
13:20:29 <EvanR> (B,C), A B C, and A {b::B, c::C} work the same in a lot of ways
13:20:39 <hpc> i would rather do the second than the first
13:21:05 <RyanGlScott> Ooh, a variety of opinions. :)
13:21:13 <c_wraith> RyanGlScott: it sounds like this is interfacing with native code?  In that case, the usual stylistic opinions are weaker.
13:21:30 <c_wraith> RyanGlScott: At some level, everyone knows that you're using the standards from the native lib
13:21:33 <merijn> RyanGlScott: I don't think it really matters, tbh. I would go with what you (and your colleagues?) find easiest
13:21:35 <hpc> RyanGlScott: i would take all of this advice and completely ignore it, then do what you prefer
13:21:57 <RyanGlScott> c_wraith: Yep, that's exactly it. The closest example I can find is Family from Network.Socket: http://hackage.haskell.org/package/network-2.5.0.0/docs/Network-Socket.html#t:Family
13:21:58 <EvanR> please ignore all advice, including this advice
13:22:30 <RyanGlScott> That seems to take a hybrid CamelCase–underscored approach.
13:22:32 <hpc> this... advice... is... FALSE
13:22:38 <hpc> (don't think about it, don't think about it)
13:22:42 <c_wraith> RyanGlScott: yeah, there really aren't hard standards in that case.  Just go with what you like best.  (Unless what you like is naming all your types T and all your classes C)
13:23:07 <RyanGlScott> c_wraith. Hah. I could just start naming things AbstractADTConstructorFactoryBean.
13:23:42 <EvanR> type inferrence for java that incorporates that kind of naming convention
13:23:54 <EvanR> another great idea goes out the window
13:24:02 <NikolajK> >:k (forall a. (a->a))
13:24:17 <EvanR> *
13:24:31 <EvanR> :k (forall a. (a->a))
13:24:31 <lambdabot> *
13:24:46 <NikolajK> ghci doesn't accept it
13:24:57 <c_wraith> do you have RankNTypes enabled in ghci?
13:25:06 <NikolajK> probably not
13:25:12 <c_wraith> That would explain it!
13:26:31 <NikolajK> is this just legal Haskell code: http://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax
13:26:48 <hpc> yes
13:26:58 <hpc> requires GADTs and KindSignatures
13:27:01 <c_wraith> Technically, it's not "Haskell", but it is accepted by GHC with some extensions enabled
13:28:28 <c_wraith> Though most people consider "haskell" and "what ghc accepts with appropriate extensions enabled" to be synonymous most of the time.
13:28:36 <NikolajK> App  :: Lam (a -> b) -> Lam a -> Lam b
13:28:36 <NikolajK> this Lamda is a functor?
13:28:53 <vanila> you'd have to give the full definition
13:29:01 <vanila> I dont think so
13:29:03 <c_wraith> Actually, that's Applicative, as a single constructor
13:29:13 <c_wraith> err, well.  The <*> half of applicative
13:29:21 <vanila> oh wait its definitely not a functor, because the indices change
13:30:27 <NikolajK> the indices change?
13:31:15 <NikolajK> App is fmap with App e1 e2 = e1 e2
13:31:57 <c_wraith> NikolajK: no, App is closer to <*> than fmap.
13:32:30 <NikolajK> I don't understand, the type Lam (a -> b) -> Lam a -> Lam b is just that of a functor
13:32:35 <NikolajK> no, wait
13:32:38 <NikolajK> I'm confus
13:32:47 <c_wraith> :t fmap
13:32:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:32:52 <c_wraith> :t (<*>)
13:32:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:33:24 <NikolajK> I stand correctified
13:34:02 <c_wraith> NikolajK: That type cannot actually be made an instance of Functor, though.
13:34:39 <NikolajK> it also has Lift :: a -> Lam a
13:35:15 <NikolajK> so make fmap f ma = App (Lift f) ma
13:35:40 <quchen> NikolajK: But then  fmap id ≠ id
13:35:46 <c_wraith> NikolajK: That violates the Functor laws
13:35:55 <c_wraith> NikolajK: having the right type is not enough
13:36:20 <NikolajK> that's what she said :(
13:57:52 * hackagebot logic-TPTP 0.4.2.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.4.2.0 (DanielSchuessler)
14:02:53 * hackagebot Spock-worker 0.2.0.0 - Background workers for Spock  http://hackage.haskell.org/package/Spock-worker-0.2.0.0 (AlexanderThiemann)
14:07:53 * hackagebot yi 0.8.2 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.8.2 (MateuszKowalczyk)
14:07:55 * hackagebot yi-contrib 0.8.2 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.8.2 (MateuszKowalczyk)
14:12:40 <koala_man> I get this error trying to build a project in the POSIX locale: http://lpaste.net/109179
14:12:50 <koala_man> how do I make my build process locale agnostic?
14:12:56 <tulcod> i'm trying to prettify some API by writing wrappers. for a part of its methods, it is only advertised at runtime which are available: after connecting, you may get back events telling you the system is ready to do x or y (and this does indeed across connections). however, in practice, you'll just want to assume you can use those methods: otherwise there's not much you can do. what is a sane way to expose this functionality?
14:13:11 <tulcod> indeed vary* across connections
14:15:03 <aspidites> is there a way to pass commands that would have gone to 'cabal install' to 'cabal run'? i'm learning snap, and the site says to run 'cabal install -f development', but i ws under the impression that I am not supposed to run 'cabal install' inside a sandbox
14:15:48 <tulcod> aspidites: using cabal install  inside a sandbox will install to that sandbox
14:16:33 <aspidites> right. and doing so seems as though it wouldn't do what i want, since dist/ isnt in my path (hence the reason for 'cabal run' in the first place as I understand it)
14:16:38 <Maior> I have an IO Maybe IO String; can I reduce my suffering somewhat?
14:17:15 <hpc> you have a what now?
14:17:16 <tulcod> Maior: poe's law
14:17:27 <tulcod> or well
14:17:32 <tulcod> Maior: what's your /real/ problem, anyawy :)
14:17:52 <tulcod> Maior: cause it smells like you got that value in a strange way
14:18:41 <quchen> "IO Maybe IO String" is not a Haskell type.
14:18:42 <Maior> I have a function `FilePath -> IO String` that grabs data from a config file; I have `doesFileExist :: FilePath -> IO Bool`
14:18:51 <Maior> IO (Maybe (IO String)), sorry
14:19:17 <Maior> er, sorry, `FilePath -> IO (Maybe String)`
14:19:51 <quchen> Okay. Now what?
14:20:50 <thinkpad20> Hey guys, what module are the functions for traversing through Aeson `Value`s in? Looking through Data.Aeson I don't see them. Preferably *without* using lens, for now anyway.
14:21:23 <Maior> `pC = (doesFileExist packageConfigFile) >>= \c -> if' c (Just $ loadConfig packageConfigFile) Nothing`
14:21:53 <thinkpad20> For example something like `key :: Text -> Value -> Either SomeError Value`
14:22:03 <glguy_> thinkpad20: There might not be any, bos uses lens
14:22:09 <monochrom> Data.Aeson.Types has Value exposed. you can access directly.
14:22:14 <tulcod> Maior: pC = (doesFileExist packageConfigFile) >>= \c -> if' c (Just <$> loadConfig packageConfigFile) (return Nothing)
14:22:38 <thinkpad20> that's pretty lame
14:22:47 <glguy_> You can use the normal lookup functions on HashMaps
14:22:51 <Maior> tulcod: that's much nicer, thanks!
14:23:20 <monochrom> but I wouldn't even care about Value. isn't it enough to just write a FromJSON instance with .: and <$> <*> etc?
14:23:29 <thinkpad20> yeah, so I should write my own library of functions to walk JSON trees?
14:24:00 <thinkpad20> I can't believe a JSON library doesn't contain library functions to manipulate JSON data
14:24:09 <tulcod> Maior: but clearly this is not really nice to read, so usually you would just use do statements for this :)
14:24:52 <Maior> tulcod: hah true, I just...don't really feel happy/comfortable with do notation
14:25:09 <thinkpad20> I understand the concept of lenses, but every time I try to learn them I just get incomprehensible error messages
14:25:10 <tulcod> Maior: admittedly it will be a bit of a do tree in this case
14:25:21 <monochrom> I see, FromJSON still talks of Value, but the only case is the Object case, isn't it?
14:25:34 <tulcod> Maior: i think one way to "understand" do trees is to just be really strict about what types you should have where
14:25:42 <tulcod> do notation*
14:25:51 <Maior> tulcod: hm, ok
14:26:23 <tulcod> Maior: for example, in `exists <- doesFileExist packageConfigFile`, what's what?
14:26:44 <tulcod> Maior: doesFileExist :: FilePath -> IO Bool, so   doesFileExist packageConfigFile :: IO Bool
14:26:48 <thinkpad20> A few days ago I wrote up my own little JSON library (https://github.com/thinkpad20/easyjson), but I want to use Aeson because it'll be a lot faster
14:26:58 <tulcod> Maior: which is exactly the type <-, being part of a do for the IO monad, needs
14:27:10 <tulcod> Maior: so now exists :: Bool (the IO is "stripped off")
14:27:17 <tulcod> etc
14:27:33 <tulcod> Maior: also, when in doubt, assign ("unpack") your monadic variables
14:28:05 <Maior> tulcod: how do you mean?
14:28:23 <tulcod> Maior: well, you want to use the output of doesFileExist packageConfigFile. so assign its output to some variable.
14:28:31 <tulcod> then you can do computations that look pure
14:28:42 <Maior> oh, you mean, "lots of intermediate assignments"?
14:28:42 <tulcod> instead of having to fiddle around with >>= and return and <$> and whatever
14:28:45 <tulcod> yeah
14:28:59 <tulcod> Maior: and usually it's more clear anyway
14:29:00 <Maior> I did actually condense some things in my example for brevity, but sure
14:29:54 <roconnor> @free f :: forall r . r -> ((r, a) -> r) -> r
14:29:54 <lambdabot> h . k = p . $map_Pair h g => h (f x k) = f (h x) p
14:30:02 <Maior> tulcod: cheers :)
14:34:18 <Peaker> Heh, another reason "fail" is a failure: http://lpaste.net/109180
14:34:35 <t7> @hoogle Set a -> (a -> a -> Ordering) -> Maybe a
14:34:35 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:34:35 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:34:35 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
14:35:12 <monochrom> it's Control.Monad.State.Lazy for you
14:35:37 <monochrom> it has to be this way for http://lpaste.net/41790/ to work
14:35:44 <orion> hmm
14:36:06 <monochrom> if you replace fail by error, you get the same result. is error an error?
14:36:17 <orion> I'm getting a weird GHC error: Ambiguous occurrence ‘map’ It could refer to either ‘Prelude.map’, ... or ‘B.map’, imported from ‘Data.ByteString’
14:36:26 <monochrom> if you replace error by an infinite loop, you get the same result. is infinite loop an infinite mystery?
14:36:35 <orion> Shouldn't it default to Prelude's version of map?
14:36:38 <enthropy> orion: bytestring is supposed to be imported qualified
14:36:43 <Peaker> monochrom: yeah, but the semantics of "fail" in a monad are (expected? by me?) to be more well-defined than "error" in some subexpression
14:36:49 <orion> enthropy: import Data.ByteString         as B
14:36:55 <hpc> monochrom: http://thecodelesscode.com/case/1
14:36:59 <enthropy> orion: import qualified Data.ByteString as B
14:37:02 <mmmm> orion: You need the qualified
14:37:06 <orion> enthropy: Oh, bah!
14:37:33 <monochrom> whatever semantics you attach to fail are going to be rendered irrelevant if the semantics of >>= sidesteps it.
14:37:35 <glguy_> There'e no "semantics" of fail, it's just what gets called in the case of pattern match failure
14:37:54 <orion> thank you
14:38:02 <Peaker> glguy_: but there is an expectation of semantics :-)
14:38:14 <hpc> there's a general idea of what it should be
14:38:22 <hpc> plus general rules that it should behave similarly to mzero, etc
14:38:24 <Peaker> glguy_: thankfully we have proper type-classes for error throwing, so those have sensible semantics
14:38:33 <hpc> but nothing formal
14:39:05 <monochrom> you are, really, looking at const True (fail "message")
14:40:09 <koala_man> if anyone's wondering, my locale issue was due to QuickCheck <= 2.7.3. It was fixed in 2.7.4
14:42:56 * hackagebot Chart 1.2.4 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.2.4 (TimDocker)
14:42:58 * hackagebot Chart-cairo 1.2.4 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.2.4 (TimDocker)
14:43:00 * hackagebot Chart-gtk 1.2.4 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.2.4 (TimDocker)
14:43:02 * hackagebot Chart-diagrams 1.2.4 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.2.4 (TimDocker)
14:43:04 * hackagebot Chart-simple 1.2.4 - A wrapper for the chart library to assist with basic plots  http://hackage.haskell.org/package/Chart-simple-1.2.4 (TimDocker)
14:53:01 * hackagebot fay 0.20.1.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.1 (AdamBergmark)
14:54:07 <tulcod> bergmark: fay-lang.org is linked in the description, but the domain expired
14:56:03 <RyanGlScott> It would be nice to have syntax like [1..3, 5, 7..9] to represent [1,2,3,5,7,8,9]. Can one do this without using (++)?
14:56:11 <benmachine> no
14:56:16 <benmachine> well
14:56:28 <benmachine> not unless there's something exceptionally clever I haven't thought of
14:56:32 <tulcod> [1..3]++[5]++[7..9]
14:56:33 <benmachine> which... there often is
14:56:48 <RyanGlScott> I thought so, I just wanted to know if there was some Enum trick I hadn't heard of.
14:57:07 <quchen> RyanGlScott: (...) is free, so you can use that as whatever you want.
14:57:22 <quchen> Add an alternative "comma-like" and you can probably write something like that.
14:57:40 <benmachine> you'd have to also replace the [ and the ]
14:58:00 <tulcod> RyanGlScott: what do you want [1,3... , 2,4..] to mean?
14:58:01 * hackagebot json-schema 0.6.1.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.6.1.1 (AdamBergmark)
14:58:20 <RyanGlScott> tulcod: Good point, I hadn't thought that far. L)
14:58:51 <tulcod> though that sounds a *lot* like ordinal theory
14:58:53 <t7> @hoogle a -> b -> c -> (b -> a -> c)
14:58:54 <lambdabot> GHC.IO.Buffer Buffer :: RawBuffer e -> BufferState -> Int -> Int -> Int -> Buffer e
14:58:55 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification compressedTexImage3D :: ThreeDimensionalTextureTarget t => t -> Proxy -> Level -> TextureSize3D -> Border -> CompressedPixelData a -> IO ()
14:58:55 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification compressedTexImage2D :: TwoDimensionalTextureTarget t => t -> Proxy -> Level -> TextureSize2D -> Border -> CompressedPixelData a -> IO ()
14:59:05 <t7> @hoogle (a -> b -> c) -> b -> a -> c
14:59:06 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
14:59:06 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
14:59:06 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
14:59:42 <tulcod> RyanGlScott: admittedly, your cases are just finite interpolations, so you can probably restrict yourself to that
15:00:38 <RyanGlScott> Ultimately, I just need to check if a number is in a noncontinuous range, so I'll probably just do something like any (elem x) [[1..3], [5], [7..9]]
15:02:41 <corgifex> > any (`inRange` 2) [(1,3), (5,5), (7,9)]
15:02:43 <lambdabot>  True
15:03:32 <RyanGlScott> Good point, I should probably use Ix instead of Eq.
15:04:27 <roconnor> @free f :: forall r . r -> ((r, A) -> r) -> r
15:04:28 <lambdabot> g . h = k . $map_Pair g $id => g (f x h) = f (g x) k
15:05:14 <Rufflewind_> Is it possible to embed a ReadP parser inside a ParsecT parser? i.e. ReadP a -> ParsecT s u m a ?
15:05:16 <roconnor> @free f :: r -> ((r, A) -> r) -> r
15:05:17 <lambdabot> g . h = k . $map_Pair g $id => g (f x h) = f (g x) k
15:08:10 <mmmm> Rufflewind_: Can you say a bit more?
15:08:15 <enthropy> Rufflewind_: yes
15:08:27 <jcora> I have a question about approaching a problem from a functional perspective. I have a list of strings, and I have to classify each string and put it in another list for its class. Concretely, I have a list of command-line arguments, that can be either SOURCE, OBJECT, or OPTION, and I need three lists of this name from the initial list that contains them all. The problem is that options can span multiple strings, for example ("-x", "a") is
15:08:27 <jcora>  a single option "-x a". How would you do this in a functional way? Imperatively, this would be easy: I would iterate over the list, inspect the consequent element if necessary, and just maintain mutable data structures for results.\
15:09:29 <Rufflewind_> mmmm: given a blackbox parser p :: ReadP a, is there a generic way to convert it into a ParsecT parser?
15:09:37 <Rufflewind_> enthropy: how?
15:10:53 <Fuuzetsu> edwardk: is profunctor-extras abandoned?
15:11:29 <enthropy> Rufflewind_: it's a bit tricky to get the position to match up. https://github.com/jaor/xmobar/blob/master/src/Parsers.hs#L261-L263 does ReadS a -> parsec parser
15:18:11 <enthropy> Rufflewind_: oh actually that's not it. http://lpaste.net/6228341185002340352 is what I was thinking about
15:18:50 <enthropy> but ReadP will be much better to convert, since you can ask it "what string was consumed"
15:19:18 <Rufflewind_> enthropy: ah there's the missing piece I needed: setInput
15:19:24 <Rufflewind_> (and getInput)
15:19:37 <Rufflewind_> I was afraid I might have to use mkPT
15:20:28 <Fuuzetsu> edwardk: also http://hydra.cryp.to/build/164844/log/raw , ld fails for your folds library, any idea?
15:22:43 <Rufflewind> enthropy: wait so how do you actually ask it "what string was consumed"?
15:23:08 <edwardk> Fuuzetsu: did i forget to export a module from the package but include it somehow?
15:24:19 <Fuuzetsu> no, I don't think that's it considering your Travis-CI seemed to have built it past that… might be a nix problem but I don't know
15:24:24 <Fuuzetsu> I opened an issue on nixpkgs side
15:25:00 <Fuuzetsu> https://github.com/NixOS/nixpkgs/issues/3526
15:25:13 <Rufflewind> enthropy: never mind I didn't read the docs :P
15:25:14 <enthropy> Rufflewind: https://hackage.haskell.org/package/base-4.3.0.0/docs/Text-ParserCombinators-ReadP.html#v:gather
15:31:42 <benzrf> bbl
15:35:13 <Rufflewind> enthropy: thanks!
15:39:03 <orion> I can pattern match on Nothing, or I can pattern match on '_'. What is better?
15:39:19 <vanila> Nothing
15:39:21 <Rembane> Nothing. More explicit
15:39:24 <edwardk> orion: depends on how strict you want to be
15:39:45 <edwardk> orion: if you're already strict in that argument it doesn't matter much other than style
15:40:31 <quchen> If you have a custom ADT then you should usually match as explicitly as possible. When you match against "_", you won't get "unmatched pattern" warnings when you add another constructor and forget about it in some functions.
15:41:05 <edwardk> quchen++
15:41:12 <edwardk> that is pretty much entirely my reasoning as well
15:41:42 <enthropy> I think you can depend on Maybe staying the way it is
15:41:43 <edwardk> When we get around to adding that 'Kinda' constructor to Maybe, all bets are off ;)
15:42:11 <geekosaur> "FileNotFound"
15:42:27 <quchen> geekosaur: Inspired by PHP? data Maybe a = Nothing | Just a | FileNotFount
15:42:36 * quchen isn't sure whether the typo there is a feature
15:42:43 <edwardk> heh
15:42:49 <Cale> data Bool = False | True | Abort | Retry | Ignore
15:42:58 <geekosaur> wasn't the original dailywtf a C++ class?
15:43:05 <edwardk> http://hackage.haskell.org/package/acme-php-0.0.2/docs/Prelude-PHP.html
15:43:11 <quchen> geekosaur: There's an "original" of this?
15:43:15 <hpc> edwardk: beat me to it
15:43:19 <geekosaur> yes, it's an infamous dailywtf
15:43:46 <geekosaur> http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx
15:43:51 <hpc> http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx
15:43:58 <hpc> dammit, again!
15:44:03 * hpc goes back to tv
15:44:17 <benmachine> that one is also great for how True == 0
15:44:37 <quchen> The Haskell community would probably prefer  data Bool = True | False | Bottom.
15:44:58 <monochrom> I like bottom.
15:45:12 <geekosaur> and I misremembered, it's a C / C++ enum
15:45:15 <quchen> monochrom: That's why it should be explicit in Bool, and not lurking around implicitly!
15:45:28 <edwardk> sir monochrom-a-lot
15:45:28 <monochrom> I love haskell. it gets to the bottom of the matter. :)
15:45:51 <joelteon> i like the 0x3f in that URL
15:46:09 <monochrom> > chr '\x3f'
15:46:10 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
15:46:11 <lambdabot>              with actual type ‘GHC.Types.Char’
15:46:18 <monochrom> oops
15:46:21 <hpc> joelteon: the wtfs on that site don't stop at the articles
15:46:21 <monochrom> > '\x3f'
15:46:22 <lambdabot>  '?'
15:46:37 <monochrom> I see, heh
15:46:45 <hpc> the forum for the longest time was a microsoft community server instance
15:46:48 <geekosaur> meh. remember ? is meaningful in URIs
15:46:51 <hpc> last updated something like 2006
15:47:01 <hpc> now it runs discourse, which is even worse
15:47:12 <ozataman> Anyone aware of a utility for drawing module dependency graphs of a cabal package?
15:47:54 <quchen> ozataman: I think there's one on Hackage, and I wrote one myself as well
15:48:14 <quchen> This is mine, https://github.com/quchen/hackage-graph
15:48:19 <quchen> And let me see whether I can find the other one
15:48:22 <ozataman> I've been scanning hackage for a bit now, couldn't find one. I must have missed it
15:48:34 <quchen> Oh, it's in my own readme even. hackage-db it's called.
15:48:37 <geekosaur> http://hackage.haskell.org/package/cabal-graphdeps http://hackage.haskell.org/package/graphmod
15:48:45 * dfeuer continues to ponder. Is this right? scanr f q0 = scanrminus f q0++[q0]; scanrminus f q0 = foldr (\x r->f x r:r) q0
15:48:45 <geekosaur> and probably others, that's just so far
15:48:52 <ozataman> quchen: ah very nice. any way to constrain it to a single project?
15:48:58 <joelteon> discourse huh
15:49:00 <joelteon> is that bad
15:49:07 <joelteon> I like discourse
15:49:24 <quchen> ozataman: Should not be hard to implement, but I don't think I added that myself. hackage-db can do it I think.
15:50:00 <ozataman> geekosaur: thanks!
15:50:23 <geekosaur> actually those are it if you don't want to e.g. check deps of all installed packages
15:50:56 <dfeuer> If that *is* correct, it suggests that scanr is the wrong scanr for lists, and belongs in edwardk's NonEmpty instead.
15:51:29 <edwardk> dfeuer: this is why we have a Bind instance for lists ;)
15:51:44 <dfeuer> edwardk: what is Bind?
15:51:50 <edwardk> dfeuer: in semigroupoids
15:51:57 <quchen> Sounds like Monad without return
15:51:59 <mmmm> is anyone familar with the recursion-schemes package and able to explain the Base type family?
15:52:01 <edwardk> er actually the one i want is Extend actually
15:52:07 <edwardk> its the comonad without extract
15:52:16 <edwardk> :t extracted
15:52:17 <lambdabot> Not in scope: ‘extracted’
15:52:25 <edwardk> :t Data.Functor.Extend.extended
15:52:26 <lambdabot> Data.Functor.Extend.Extend w => (w a -> b) -> w a -> w b
15:52:33 <edwardk> @let import Data.Functor.Extend
15:52:34 <lambdabot>  <no location info>:
15:52:34 <lambdabot>      The package (comonad-4.0.1) is required to be trusted but it isn't!
15:52:35 <dfeuer> edwardk: I know what a semigroup is, but not a semigroupoid, and I don't know what a comonad is either, etc. What are you getting at?
15:52:59 <edwardk> extend gives you a tails sans the empty list
15:53:20 <dfeuer> How does that help?
15:53:27 <edwardk> its the structure that if you reduced it you'd get what you think you want in scanr i'd bet
15:53:53 <shachaf> Hmm, given (>>=) without return, you can't write fmap.
15:54:00 <edwardk> > scanr (+) 0 [1..3]
15:54:02 <lambdabot>  [6,5,3,0]
15:54:03 <edwardk> shachaf: yep
15:54:11 <shachaf> And I guess you can't write (>>=) with just fmap and join, either.
15:54:21 <dfeuer> edwardk: using tails to do that seems most inefficient.
15:54:34 <edwardk> dfeuer: i'm pointing to the shape, not to the implementation
15:55:33 <shachaf> So I guess you just provide both.
15:55:54 <dfeuer> foldr (\x r -> x+r : r) 0 [1..3]
15:56:04 <dfeuer> > foldr (\x r -> x+r : r) 0 [1..3]
15:56:05 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ [a]
15:56:05 <lambdabot>  Relevant bindings include
15:56:05 <lambdabot>    r :: [a] (bound at <interactive>:1:11)
15:56:05 <lambdabot>    x :: a (bound at <interactive>:1:9)
15:56:10 <dfeuer> Oops.
15:56:39 <dfeuer> Guess that's wrong.
15:56:45 <dfeuer> Not surprising.
15:57:00 <dfeuer> Yeah, I may give up there.
16:04:18 <bergmark> tulcod: oh right, thanks
16:05:32 <NikolajK> funfact http://i.imgur.com/xxUvViD.png good night
16:07:16 <sgronblo> Does cabal get rid of the source after compiling packages?
16:07:49 <bergmark> sgronblo: it unpacks to /tmp/
16:08:12 <sgronblo> I was trying to generate hasktags for my cabal packages
16:08:38 <Cale> That *is* a fun fact
16:08:39 <sgronblo> Trying to get started with Yesod but there are a lot of functions I don't know what they do.
16:11:01 <orion> Is there an efficient way to drop the last n elements of a bytestring?
16:12:02 <quchen> take (length - n)?
16:12:22 <quchen> For strict bytestrings, at least.
16:12:41 <quchen> And for lazy ones that should be a practical solution as well, unless you have a bazillion of chunks.
16:13:34 <dfeuer> orion: it depends on the context. You may want some sort of queue sometimes.
16:17:48 <sgronblo> Is it possible to run haddock for a dependency package? cabal haddock seems to assume I want to generate docs for my own package?
16:18:09 * hackagebot managed 1.0.0 - A monad for managed values  http://hackage.haskell.org/package/managed-1.0.0 (GabrielGonzalez)
16:18:19 <tulcod> sgronblo: you have to install it with documentation
16:19:01 <sgronblo> tulcod: can you explain in a bit more detail?
16:19:52 <joelteon> --enable-documentation
16:19:54 <joelteon> i think is the argument
16:20:35 <roconnor> @free roll :: (F r -> r) -> r
16:20:35 <lambdabot> f . g = h . $map_F f => f (roll g) = roll h
16:21:37 <tulcod> sgronblo: you have to install the dependency with documentation
16:21:44 <tulcod> like joelteon, that's a cabal option
16:22:24 <Fuuzetsu> interesting, GHC seems stuck on a module without doing much
16:22:46 <Fuuzetsu> it just sits at “[ 1 of 18] Compiling Text.TeXMath.Unicode.ToASCII ( src/Text/TeXMath/Unicode/ToASCII.hs, dist/build/Text/TeXMath/Unicode/ToASCII.o )”… (texmath-0.8)
16:25:20 <Fuuzetsu> https://github.com/jgm/texmath/blob/master/src/Text/TeXMath/Unicode/ToASCII.hs data dumps are the best
16:27:15 <Fuuzetsu> oh, ok, it managed it, it just took a bloody long time
16:29:49 <tulcod> Fuuzetsu: oh shit wow that page actually took some time to render here :P
16:30:38 <Fuuzetsu> reminds of that time I made it compile a file with 40000 functions
16:30:42 <Fuuzetsu> or 100k modules…
16:31:21 <Andrey__> Hi, I'm trying to grasp haskell's laziness and it would be great if someone confirmed my reasoning. I have a Hashmap of Hashmaps, and I would like to update or lookup or delete an element in inner most hashmap. Would it make more sense to use Hashmap.Lazy because I don't really need to put the whole element of outer Hashmap into memory? Or it doesn't matter and haskell does it anyways?
16:31:21 <hpc> reminds me of that primes module
16:31:28 <hpc> where it just listed the first thousand primes
16:32:42 <mmmm> Fuuzetsu: That was me haha
16:33:10 <mmmm> It was 40 000 more lines until I cut out the asian characters
16:33:42 <Fuuzetsu> mmmm: did it take forever and a bit to compile for you?
16:33:53 <mmmm> so friggin long
16:34:15 <mmmm> especially as I'm developing on my netbook
16:34:37 <mmmm> actually I ran out of memory most times I tried to compile from scratch before I cut it down a lot
16:34:53 <Fuuzetsu> did you try with 7.6.3?
16:35:15 <mmmm> no
16:35:22 <Fuuzetsu> I'll try
16:35:58 <Fuuzetsu> I think I can have a shower before this finishes…
16:36:20 <mmmm> lol sorry
16:36:22 <l0cust> Fuuzetsu: What are you trying to do?
16:36:36 <l0cust> Fuuzetsu: I'm guessing something with cabal --max-backjumps=-1 ?
16:36:40 <Fuuzetsu> just compiling texmath to make sure it works
16:37:12 <l0cust> Fuuzetsu: Ah. Someone should do the double-compile trick with LaTeX
16:37:22 <l0cust> Make sure our documents aren't poisoned
16:38:10 * hackagebot svm-light-utils 0.1.0.0 - Parsers and formatters for the SVMlight input file format  http://hackage.haskell.org/package/svm-light-utils-0.1.0.0 (BenGamari)
16:46:04 <mmmm> Are there any pure libraries which do svg -> pdf?
16:49:37 <zomg> mmmm: maybe pandoc can do that, it can at least output pdf but not sure about svg
16:50:58 <mmmm> zomg: ha.. pandoc can't and I was looking for a way to add it ;)
16:51:35 <hpc> i thought pandoc worked by turning each format into an internal representation
16:51:49 <mmmm> It does
16:52:10 <hpc> then it should be fairly basic to read from svg, and pdf is already working
16:52:20 <hpc> svg is "just" xml
16:52:28 <hpc> weird and peculiar, but the spec is easy to read
16:53:51 <mmmm> well.. we go to pdf via latex for a start
16:54:30 <mmmm> and the IR isn't that fine grained
16:55:02 <mmmm> the problem is when reading from EPUB or docx, there can be svgs embedded which cause errors when converting to pdf
16:58:24 <begriffs> Is there a way to configure "cabal test" to include default arguments? Possibly in the project's cabal file?
16:58:48 <begriffs> I'd like to always pass in --show-details=always --test-options="--color"
17:02:34 <Fuuzetsu> FTR texmath compiles just as long on 7.6.3
17:21:35 <gamegoblin> :t uncurry
17:21:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:23:47 <orion> Anyone know how to convert this code to use ByteStrings instead of Strings?: http://rosettacode.org/wiki/Entropy#Haskell
17:24:35 <coppro> orion: just use the corresponding functions from Data.ByteString
17:24:58 <trap_exit> besides "show", how can I convert Double -> String ?
17:24:59 <trap_exit> or Double -> Text
17:28:43 <EvanR__> trap_exit: one is printf
17:28:53 <pavonia> trap_exit: The Numeric module has several functions
17:29:00 <orion> coppro: No dice: http://ideone.com/ofpFBB
17:51:57 <tiffany_> hi
17:52:07 <tiffany_> anyone can help me ?
17:52:42 <glguy_> On IRC in general you should ask your question and then anyone who knows the answer and wants to help will be able to
17:52:46 <trap_exit> do you have a minimal failure exampl e?
17:53:18 <hpc> tiffany_: anyone in the whole world can help you :D
17:57:24 <trap_exit> okay
17:57:26 <trap_exit> what's the actual question?
17:57:28 <trap_exit> I'm dying to know
18:00:14 <mjrosenb> kristof: ping?
18:01:58 <mjrosenb> kristof: what exactly is being fixed?
18:02:35 <kristof> mjrosenb: what did you ping me for, I forget
18:02:41 <kristof> mjrosenb: Oh!
18:02:50 <mjrosenb> kristof: in #archlinux, you said things were being fixed
18:02:57 * mjrosenb is not too sure what things
18:03:16 <kristof> The people in this channel would know better, but cabal is smarter about installing dependencies and having multiple versions of the same package installed
18:03:40 <kristof> Someone please jump in and elaborate because I cannot. :P
18:04:50 <mjrosenb> kristof: well, the haskell-arch page explicitly says that cabal is probably a bad idea, because of cabal-hell
18:05:23 * mjrosenb just rm -rf'ed ~/.cabal, because I downgraded ghc, and all that was useless anyway.
18:05:25 <kristof> that's potentially outdated information.
18:06:06 <mjrosenb> kristof: I mean, cabal still doesn't have any way of removing a package, and last I heard, this is intentional.
18:06:32 <kristof> mjrosenb: that's not so bad
18:06:46 * mjrosenb *really* likes hackports from gentoo
18:06:56 <mjrosenb> I guess I could try to write something like that for arch.
18:07:07 <mjrosenb> (or see if it already exists c.c)
18:08:50 <maurer> https://ghc.haskell.org/trac/ghc/ticket/4862 suggests that I should be able to runtime tell ghc that it's using ld.gold, but I'm unclear how to do this
18:10:01 <mjrosenb> maurer: lololol... why are you changing it at runtime?
18:10:35 <maurer> mjrosenb: because when I installed it, ld.bfd was default, but I switched to gold so that chromium would actually link
18:10:42 <maurer> mjrosenb: now, ghc won't build things with gold
18:11:03 <maurer> It seems kind of ridiculous to have to rebuild my compiler to flip this switch
18:11:22 <mjrosenb> maurer: so, changing the linker doesn't mean that ghc re-detects the settings, you still need to change that config file
18:11:27 <mjrosenb> have you done that?
18:11:39 <maurer> mjrosenb: I am wondering where "that config file" is
18:12:23 <mjrosenb> maurer: /usr/lib/ghc-7.4.1/**/settings
18:12:43 <mjrosenb> err, 7.8.3
18:12:51 <mjrosenb> since that is likely what you are using.
18:14:10 <mjrosenb> oh, it is in the basedir
18:14:17 <mjrosenb> so /usr/ghc-*/settings
18:14:27 <maurer> OK, all good
18:14:29 <mjrosenb> err, /usr/lib/ghc-*/settings
18:14:30 <maurer> thanks
18:14:54 <mjrosenb> *super* annoying on debian
18:27:05 <orion> Is there a standard function which can do: [(a, b)] -> ([a], [b]) ?
18:28:00 <pavonia> @hoogle [(a, b)] -> ([a], [b])
18:28:01 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
18:28:02 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
18:28:40 <gamegoblin> So I installed the bcrypt library, and upon excuting the little example at the top of the page (https://hackage.haskell.org/package/bcrypt-0.0.4/docs/Crypto-BCrypt.html), it just returns Nothing all the time
18:28:43 <gamegoblin> ideas?
18:29:33 <MitchellVanDerHo> hey guys
18:29:50 <gamegoblin> When installing, it did say "no such instruction: `rdrand %rdx’" at one point
18:31:05 <merijn> gamegoblin: Sounds like it relies on the rdrand instruction and won't work without it?
18:31:25 <MitchellVanDerHo> jxnl: hey how's it going?
18:31:25 <gamegoblin> merijn: but it still installed and imports and seems to function, it just returns Nothing...
18:32:13 <merijn> gamegoblin: That doesn't seem right yeah, but I'm not familiar with the package, so I can't say anything about that
18:34:47 <merijn> Can it be that the new cabal that comes with GHC has fixed the stupid no-profiling/no-documentation default config? :O
18:37:33 <merijn> Also, do I want split-objs True nowadays? I forgot all the details about the new linking stuff GHC does...
18:39:06 <Mathnerd314> is there a library that turns classes into GADT's? e.g. mkGADT Eq -> data EqC k a where { (==) :: k a -> k a -> EqC k Bool } ?
18:40:28 <Mathnerd314> if not, is it possible to write such a library using template haskell?
18:41:01 <merijn> Mathnerd314: Why would it need to be a GADT and why the k parameter?
18:42:01 <Mathnerd314> the GADT is so it's typesafe. The k is so I can pull the various classes into a larger GADT Big a where { EqOp :: EqC Big a, ... }
18:44:04 <Mathnerd314> EqOp :: EqC Big a -> Big a, that is
18:44:14 <merijn> I don't see what'd be wrong or unsafe about "data EqADT a = mkEq { (==) :: a -> a -> Bool) }"?
18:44:16 <orion> hmm
18:45:03 <orion> If you have b :: Num => [(a, b)], is there a way to sort by b?
18:45:26 <Mathnerd314> merijn: I need a symbolic expression thing. So that doesn't work, because I can't store variables in a's.
18:45:29 <enthropy> @type sortBy
18:45:30 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
18:45:45 <enthropy> @type sortBy (comparing snd)
18:45:46 <lambdabot> Ord a => [(a1, a)] -> [(a1, a)]
18:45:52 <orion> ah
18:45:53 <orion> yay
19:08:30 * hackagebot sizes 2.3.2 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.3.2 (JohnWiegley)
19:11:15 <mjrosenb> when I register a package with ghc, where does that information exist?
19:11:19 <mjrosenb> is it all in .cabal?
19:11:29 <mzero> no
19:11:32 <mzero> in the package dbs
19:11:35 <mjrosenb> or is it placed somewhere else?
19:11:40 <mzero> which are a ghc thing
19:11:52 <mjrosenb> mzero: where is that? presumably, it is user-writable, and in my home directory?
19:11:52 <phaskell> No symbol 'that' found anywhere.
19:11:53 <mzero> ghc-pkg list will show you the locations
19:11:59 <mzero> "ghc-pkg list"
19:12:01 <mzero> run that
19:12:33 <mzero> mjrosenb: there is a global one, a "user" one, and if you are using sandboxes, a sandbox one
19:12:35 <mjrosenb> ahh, cool.  ~/.ghc
19:13:12 <mjrosenb> mzero: well, unless I installed something globally with cabal-install, the "global" one should only contain things that are tracked with my package manager
19:13:29 <mzero> likely
19:13:35 <mjrosenb> and I've never heard of sandboxes before today, so I don't think I used any of those.
19:13:48 <mzero> well then, I think you've found your location!
19:13:56 <mjrosenb> ok, so I'll blow away .cabal and .ghc, and be set.
19:14:25 <mzero> you might want to save your config files in those places, if you have any
19:14:47 <carter> @hackage compdata is what you're looking for Mathnerd314
19:14:47 <lambdabot> http://hackage.haskell.org/package/compdata is what you're looking for Mathnerd314
19:14:55 <mzero> ~/.ghc/ghci.conf  and ~/.cabal/config  in particular
19:15:07 <carter> Mathnerd314: be warned, https://hackage.haskell.org/package/compdata is awesome on one level, but heavy weight on the other
19:15:38 <merijn> Hmm, isn't the newest cabal cabal 1.20?
19:16:04 <merijn> Why is "cabal install cabal-install" trying to foist 1.18 on me, then? >.<
19:16:10 <mjrosenb> mzero: I didn't know it existed, so config files that I care about are unlikely.
19:16:42 <carter> mjrosenb: you never have to explode ~/.cabal EVER
19:16:45 <carter> just ~/.ghc
19:16:47 <carter> everrrrrr
19:17:02 <carter> ifyou know what you're doing, you can safely delete stuff in  ~/.cabal
19:17:03 <mjrosenb> carter: maybe, however...
19:17:08 <mjrosenb> carter: waaaay too late.
19:17:09 <carter> now you know for next time
19:17:12 <carter> point being
19:17:21 <carter> if you had a custom build of happy or pandoc or whatever
19:17:26 <carter> or idris
19:17:27 <carter> or agda
19:17:37 <carter> and it depended on certain static files
19:17:37 <carter> welll
19:17:48 <carter> a) the binaries are gone because you deleted ~/.cabal/bin
19:18:18 <carter> b)  the static files / templates / whatever they might have depped on were probably in  ~/.cabal/share (at least wrt the cabal 1.20 default config)
19:18:19 <mjrosenb> carter: yes, well, I haven't built anything, mostly becase cabal hasn't been able to build the packages that I actually care about.
19:18:27 <carter> mjrosenb: solution
19:18:37 <carter> a) dl the newest cabal-install binaries !:)
19:18:59 <mjrosenb> also, this machine is fairly new, so I know I don't have anything important on it :-p
19:19:05 <carter> k
19:19:12 <carter> i'm just telling you for future reference
19:19:12 <mzero> merijn: GHC 7.8.3 uses 1.18... you can install 1.20 (of Cabal and cabal-install), but that can be a bit tricky down the road if you ever use anything that links in ghc (as a lib)
19:19:20 <mjrosenb> carter: I *had* the newest ones, and it wan't cabal's fault (that I could tell)
19:19:32 <mjrosenb> most of the issues were ghc and/or package related.
19:19:33 <carter> mzero: i think its fine in practice
19:19:50 <carter> scary warnings might happen
19:19:56 <carter> but tend to not be an issue
19:19:59 <mzero> possibly - Johan was wary enough that we didn't ship 1.20 in HP
19:20:11 <carter> well yeah, valid conservatism
19:20:26 <carter> anywho, in 7.10, ezyangs work lands
19:20:35 <carter> which should make multiversion linkages saner
19:20:55 <mjrosenb> ok, I'm back to ghc-6.8.3, let's see if it works this time :-(
19:21:07 <carter> sadness
19:21:12 <carter> what the ehck are you trying to do
19:21:15 <mjrosenb> err, 7.8.3
19:21:19 <carter> ok
19:21:21 <carter> thats saner
19:21:28 <carter> cutting edge even
19:21:37 <mjrosenb> the keys are like... right next to each other.
19:22:04 <carter> and they're like half a decade apart, if not more!
19:22:30 <mjrosenb> carter: so I remember installing 6.8, but maaan, it was an unpleasant eperience.
19:22:30 <carter> Version 6.8.3 (released 17 June 2008)
19:22:44 <carter> mjrosenb: i remember REAL cabal hell
19:22:47 <mjrosenb> oh, I installed that a lot.
19:22:58 <carter> not the wimpy shit people compalin about toda
19:23:12 <splintax> is it possible to install ghc itself with cabal-install?
19:23:12 <carter> where you had to reinstall the transitive closure of everything all at once, at the same time
19:23:17 <splintax> assuming you already have an old ghc
19:23:17 <carter> splintax: nope
19:23:25 <mjrosenb> anyhow... I'm trying to install grapefruit, and sdl, or basically any frp library that comes with decent examples.
19:23:25 <carter> splintax: you can build new ghc with old ghc
19:23:36 <carter> splintax: but ghc is not cabalized
19:23:59 <splintax> right, is there a reason why it can't be cabalized? or just that nobody has undertaken the task yet
19:24:20 <carter> splintax: :))))))
19:24:24 <mjrosenb> also, just checking... cabal-install is /still/ not a package manager, right?
19:24:30 <carter> mjrosenb: yet
19:24:38 <geekosaur> there are some circular dependencies you'd need to think about
19:24:43 <mjrosenb> is it making motions in that direction?
19:24:45 <carter> geekosaur: thats not the issue
19:24:50 <carter> mjrosenb: well
19:25:01 <carter> most package managers you think of only support one version of everything
19:25:03 <carter> which is lame
19:25:17 <carter> ezyang's work, plus other pending things
19:25:19 <mjrosenb> carter: not my favorite package manager :-/
19:25:29 <carter> mjrosenb: oh? whats your fave?
19:25:41 <merijn> ezyang's stuff will be awesome
19:25:45 <carter> FACT
19:26:00 <mjrosenb> carter: portage.
19:26:07 <mjrosenb> also, <3 hackport
19:26:23 <mjrosenb> imo, it is the *right* way to do things.
19:26:39 <carter> splintax: sooo bascially the build cycle for ghc is a bit beyond the ken of standard cabal
19:26:49 <mjrosenb> I kind of like nix, but I've never actually used it, even though I have co-workers that rave about it.
19:26:59 <platz> npm does multiple versions
19:27:01 <splintax> imo the fact that newbies have to be explicitly told "cabal is not a package manager" entails that cabal should be a package manager ;)
19:27:10 <carter> lol
19:27:15 <carter> platz: it does it in a scary way
19:27:17 <platz> but it's dynamic goo
19:27:27 <mjrosenb> splintax: or it shouldn't exist :-p
19:27:32 <platz> yeah
19:27:44 <splintax> carter: mmm, i've had a look at the build instructions and they're pretty scary. i don't know cabal well enough to know which of the scary parts aren't supported though
19:27:52 <carter> splintax the build directions are easy
19:28:02 <platz> they're trying to force everyone to use semVer, and have this wierd ^ and ~ notation, but no-one follows it
19:28:33 <carter>  git clone --recursive git://git.haskell.org/ghc.git ; cd ghc ; perl boot ; ./configure ; make
19:28:51 <platz> ironically npm didn't use semVer itself when introducing 'breaking' changes
19:28:52 <carter> is all you need to do to kick off an optmized build of ghc head
19:29:09 <carter> platz: yeah, semver isn't properly semantic
19:29:10 <carter> :)
19:29:29 <carter> splintax: mind you, the resulting build takes a while the first time :)
19:29:55 <carter> https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart
19:29:57 <carter> point being
19:30:10 <carter> building ghc head (and all future ghc releases) is REALLLY EASY
19:30:13 <carter> i just showed you how
19:30:40 <carter> but, GHC is also a much much bigger and complex software artifact that most things on hackage
19:32:43 <platz> I might have to check out building HEAD... one tip: use checkinstall -D on linux, (or something like FPM which is cross-platform) to track the install
19:32:58 <platz> instead of make install
19:34:58 <merijn> Any good links for tackling the expression problem in haskell?
19:37:14 <platz> merijn: I'm not sure this is the canonical answer, but it works.  http://wadler.blogspot.com/2008/02/data-types-la-carte.html
19:37:41 <platz> I've heard some people say there is no 'real' solution to the expression problem, just different ways of re-defining the question
19:38:09 <solirc> RchrdB: I kind of expected that we sooner or later get issues with ghc exposing transformers...
19:38:24 <platz> merijn: whoops that was the wrong link
19:38:35 <platz> here http://www.staff.science.uu.nl/~swier004/Publications/DataTypesALaCarte.pdf
19:39:33 <merijn> platz: Thanks :)
19:41:38 <mjrosenb> what eaxactly is the "expression problem"?
19:42:01 <mjrosenb> iirc, i've heard of this before, and it wan't exactly what I thought it would be based on the name.
19:42:28 <platz> define a datatype by cases, where one can add new cases to the datatype *and new functions over the datatype*, without recompiling existing code, and while retaining static type safety (e.g., no casts).
19:42:57 <merijn> mjrosenb: The expression problem is "I want to able to both easily extend a program by adding new datatypes *OR* by adding new functions for existing datatypes, without needing to modify the original ones"
19:44:28 <mjrosenb> merijn: ahh, a coworker was telling me about def-advice in elisp that did the latter.  (the latter also sounds super-annoying)
19:44:40 <benzrf> merijn: you mean adding new elements to data types
19:44:40 <benzrf> ?
19:45:04 <kristof> benzrf: Adding new elements to data types is considered adding new datatypes.
19:45:05 <EvanR__> modifying datatypes without modifying them
19:45:26 <carter> i wonder what dibblego thinks of the expression problem
19:45:29 <merijn> mjrosenb: See this post, for example: http://journal.stuffwithstuff.com/2010/10/01/solving-the-expression-problem/
19:45:43 <carter> some of the ways people try to solve the expresson problem just aren't worth it
19:45:51 <carter> even though they look awesome on paper
19:46:15 <Cale> http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem
19:48:37 <tertl3> hi
19:48:46 <tertl3> why does my code look like this in github?
19:48:54 <tertl3> https://github.com/billyblackburn/Lisp-in-48/blob/master/listing3.3.hs
19:49:28 <kristof> tertl3: in the case
19:49:36 <kristof> tertl3: Does that code actually work?
19:49:43 <EvanR__> merijn: so statically checked monkey patching
19:49:49 <tertl3> yes its been tested
19:49:51 <merijn> EvanR__: Essentially
19:50:04 <merijn> tertl3: Because github's syntax highlighting for haskell is braindead and broken
19:50:08 <platz> hah, this sounds amusing "Co/Contravariance in Physics and Programming"
19:50:15 <kristof> tertl3: Even for slurping a quote character?
19:51:18 <EvanR__> merijn: hopefully statically checked comes with automatically list the full interface, which happens to be defined in several files in several packages
19:51:19 <kristof> tertl3: Anyway, github's syntax reader is reading that " in the case expression as the beginning of a string and highlighting accordingly.
19:52:55 <carter> tertl3: basicallly someone needs to patch githubs libs
19:53:04 <carter> tertl3: you SHOULD file a support ticket with them
19:53:24 <carter> saying "syntax hl stuff is busted, heres an example at this commit and file"
19:53:42 <merijn> Syntax highlighting of github for haskell actually appears to be getting progressively worse
19:53:52 <EvanR__> they use pigment and its broken for haskell and a few other non-ruby non-pythons
19:54:24 <carboniferous> #/join cpp
19:54:25 <EvanR__> i tried to fix it but its in a python DSL
19:54:44 <mjrosenb> EvanR__: pigment, or pygment?
19:54:47 <carter> EvanR__: i thought they used some ruby thing
19:54:50 <EvanR__> checking
19:54:53 <tertl3> ok now its not compiling anymore
19:54:57 <carter> bitbucket uses pygments
19:55:22 <EvanR__> probably pygments
19:56:00 <carter> but anyways
19:56:08 <carter> please file support tickets /issues to github
19:56:13 <carter> or they wont notice
19:56:27 <carter> plzeeeee :)
19:56:37 <carter> i'm looking at you EvanR__  and tertl3  :)
19:56:54 <otis> Hi, this is probably a stupid question, but why can't I seem to read a Char? I see that Char is an instance of Read, but the reader fails no matter what I try...
19:57:12 <merijn> otis: You're probably making the common mistake of not having quotes?
19:57:20 <merijn> > read "'c'" :: Char
19:57:21 <lambdabot>  'c'
19:57:24 <merijn> > read "" :: Char
19:57:25 <lambdabot>  *Exception: Prelude.read: no parse
19:57:27 <merijn> eh
19:57:30 <merijn> > read "c" :: Char
19:57:31 <lambdabot>  *Exception: Prelude.read: no parse
19:57:36 <kristof> Something about the expression problem...
19:57:40 <EvanR__> carter: there are already such tickets in pygments for various languages for various issues, at least for mine
19:57:42 <kristof> It says "without runtime type information"
19:57:53 <kristof> how the hell do you do ad-hoc polymorphism without tags
19:58:14 <carter> EvanR__: does github use pygments
19:58:18 <otis> merijn: nope, I've been trying that in ghci and get a "no parse" error with every attempt
19:58:24 <otis> ooo
19:58:39 <otis> you need the single char in the string itself?
19:58:53 <merijn> otis: read for char expects quotes too, yes
19:58:57 <merijn> Similarly
19:59:01 <otis> ah
19:59:06 <merijn> > read "whoops!" :: String
19:59:07 <lambdabot>  "*Exception: Prelude.read: no parse
19:59:09 <carter> because
19:59:12 <carter> :t 'c'
19:59:12 <lambdabot> Char
19:59:15 <merijn> > read "\"whoops!\"" :: String
19:59:16 <carter> :t "c"
19:59:16 <lambdabot>  "whoops!"
19:59:17 <lambdabot> [Char]
19:59:23 <EvanR__> carter: i found this, its my only evidence that i can remember http://stackoverflow.com/questions/6246245/using-syntax-highlight-from-github
19:59:28 <dmwit> > (read "'a'" :: Char, head "a" :: Char)
19:59:29 <lambdabot>  ('a','a')
19:59:37 <merijn> otis: read/show, in general, should produce and consume valid haskell syntax
20:00:02 <dmwit> > case "a" of [char] -> char; _ -> error "Oh, bugger, I assumed you were handing me a one-character string and I was wrong."
20:00:03 <otis> ah okay. I was thinking read "a" :: Char would be enough. Good to know, thanks
20:00:03 <lambdabot>  'a'
20:00:07 <merijn> otis: Although you really shouldn't be using read for anything serious anyway :)
20:00:21 <otis> no?
20:00:24 <otis> why not?
20:00:32 <merijn> Because it crashes on failure
20:00:36 <dmwit> read is partial and slow as molasses.
20:00:41 <otis> Well i've been using readMaybe
20:00:47 <otis> still a bad idea?
20:00:49 <dmwit> reads is slow as molasses, but at least it's total.
20:00:52 <merijn> Text.Read.readMaybe (in 7.6 and later) is better, but still terrible for "real" work :)
20:01:08 <tertl3> yah the github is broken
20:01:08 <merijn> dmwit: Now that everyone is using 7.6 we can finally tell them to use readMaybe instead of reads \o/
20:01:11 <otis> so what is suitable for "real work"
20:01:11 <otis> ?
20:01:21 * dmwit shrugs at merijn
20:01:21 <mjrosenb> cabal can be used as a library, right?
20:01:24 <dmwit> I prefer reads anyway.
20:01:48 <merijn> otis: How complex a thing are you trying to parse?
20:01:53 <dmwit> otis: Typically, you're advised to write a custom parser using one of the many parser combinator libraries available.
20:01:59 <carter> tertl3: file bug reprots with github!
20:02:16 <merijn> For any non-trivial parsing probably attoparsec/parsec, or for (de)serialisation binary/cereal
20:02:44 <k00mi> mjrosenb: Cabal is a library, yes
20:03:07 <k00mi> mjrosenb: cabal-install is the executable
20:03:09 <otis> well at the moment, im not really doing much of anything, but in the past I have used read in conjunction with parsec/attoparsec for numbers
20:03:27 <merijn> platz: Ah, yes, the Swierstra paper is the one I was looking for :) I wonder how performant his solution is...
20:03:30 <otis> for instance, i will capture a string of digits and pass that to read
20:03:39 <otis> which returns a Num
20:03:42 <otis> bad idea?
20:03:45 <tertl3> i cant find where to submit a bug
20:03:52 <tertl3> they assume the software is perfect
20:03:59 <mjrosenb> k00mi: so like, I can write a program that uses the cabal library to parse cabal files?
20:04:06 <platz> merijn: yeah it ueses a lot of typeclasses
20:04:12 <platz> might not be good for inner loops
20:04:29 <k00mi> mjrosenb: yes
20:04:29 <platz> plus there is an associativity issue with how you order the types in the signature
20:04:36 <merijn> platz: Well, typeclasses aren't necessarily costly if they're inlined
20:04:50 <platz> how do you inline them?
20:05:29 <merijn> platz: You don't, GHC does :p
20:05:35 <platz> heh
20:05:57 <merijn> platz: Basically, if GHC can fix that some useage of (+) is always Int, it can just preemptively inline Int's (+) and skip the lookup at runtime
20:06:30 <merijn> Non-polymorphic typeclass usage can almost always be trivially inlined like that
20:06:37 <thoughtpolice> well, you can SPECIALIZE too, of course.
20:06:48 <platz> i.e. RULES?
20:07:07 <merijn> Sadness, hdevtools is broken with 7.8.3? :(
20:07:09 <platz> ah i think they are different
20:07:24 <carter> platz: specialize autogenerates a rules
20:07:38 <carter> and unlike by hand rules, you know they aren't buggy!
20:07:51 <merijn> carter: Assuming GHC isn't buggy ;)
20:07:53 <carter> at least when the code compiles :)
20:07:57 <dmwit> otis: It's a very slow way to do it.
20:08:01 <tertl3> i emailed mr git
20:08:01 <carter> merijn: i've found bugs in specialize :)
20:08:06 <dmwit> otis: Since you're already parsing the thing, and then read is parsing it again.
20:08:07 <carter> tertl3: oh/
20:08:19 <carter> merijn: but happily spj fixed the bug a week later
20:08:30 <carter> sitll need to wait for 7.10 before i use specalize on some of my crazier stuff
20:08:31 <dmwit> otis: On the other hand, it costs very little in terms of developer time.
20:10:08 <mjrosenb> c.c fraction's last commit was more than a year ago.
20:10:40 <merijn> Oh, sadness, hdevtools on 7.8 has been broken for like half a year :(
20:10:48 <merijn> What will I use now :(
20:11:47 <otis> dmwit: well how else would I go about parsing a number to a Num? The way I see it, interpreting it twice is unavoidable. You have to first recognize that a sequence of characters represents a number, and then convert that sequence to a Num
20:12:06 <dmwit> otis: Yes. But Read does much more than convert the sequence to a Num.
20:12:11 <merijn> You can't parse to "Num"
20:12:22 <otis> well an instance of Num
20:12:30 <dmwit> otis: If you just pass it off to one of the functions from the Numeric module, it will already be an order of magnitude faster than passing it off to the Read parser.
20:12:34 <merijn> To succesfully lookup the relevant Read instance it needs to know the type before hand
20:12:41 <otis> yeah
20:12:42 <platz> i switched to ghc-mod after 7.8 because of hdevtools brokenness.  while slightly slower, ghc-mod does have some really cool features hdevtools lacks
20:12:44 <dmwit> otis: Read does an incredible number of things you probably don't want. e.g.
20:13:11 <dmwit> > read "( ( ((    -3.0e5)  ) ))" :: Double
20:13:12 <lambdabot>  -300000.0
20:13:45 <dmwit> And, unfortunately, you pay for all those things even after you know you just have a plain sequence of digits.
20:13:48 <otis> dmwit: ah okay, so the basic idea is correct, just using the read implementation is needlessly slow
20:16:52 <dmwit> (As an aside: it is definitely *not* true that interpreting it twice is unavoidable. One can interpret it and consume it in the same pass, if that becomes an important bottleneck.)
20:17:39 <otis> that would be accomplished with backtracking?
20:18:08 <dmwit> No? Just consume it as you see it, instead of waiting until you've seen the whole digit sequence before consuming.
20:19:14 <dmwit> I mean, the same way you can write a parser that recognizes a sequence of characters and produces a String by applying (:) in all the right places, you can write a parser that recognizes a sequence of characters and produces an Int by applying (\x y -> 10*x + y) in all the right places.
20:19:42 <otis> What if the user hands you "12abxs" which just so happens to be a valid Foo in my grammar...
20:19:47 <dmwit> or toDigit x + 10*y or whatever
20:20:07 <dmwit> otis: You deal with that the same way you would have before.
20:20:22 <otis> not backtracking?
20:20:31 <dmwit> Depends on the library used, I guess.
20:20:42 <dmwit> But it has nothing to do with the part where you handle the number.
20:20:45 <otis> I understand that to simply parse the number requires backtracking,
20:20:50 <dmwit> It's a completely orthogonal issue as far as I can tell.
20:20:56 <otis> yah
20:20:58 <otis> I understand that
20:20:59 <mjrosenb> how likely is it that semigroup changed in a way that its types are still compatible with fraction, but the behavior is different?
20:21:18 <orion> The following code tries to decrypt a bitcoin wallet using leet permutations of a known set of words ("Hello" "World"). Is there a way to refactor this code so that its memory usage doesn't go through the roof?
20:21:22 <orion> http://ideone.com/plK5Zu
20:21:58 <otis> dmwit: err I meant "I understand that to simply parse the number requires NO backtracking"
20:22:02 <dmwit> mjrosenb: Doesn't fraction provide the behavior, not semigroup?
20:23:20 <dmwit> orion: At a guess: "length perms" is forcing you to keep the entire "perms" list in memory.
20:23:27 <mjrosenb> dmwit: I mean, unless semigroup is literally just a bunch of typeclasses that have no defaults, it has some behavior that can change
20:23:38 <dmwit> orion: Compute the number of permutations using combinatorics instead, and I bet all your problems will disappear. Don't forget to use -O2, of course.
20:25:20 <orion> dmwit: You bring up a good point.
20:25:37 <orion> hmm
20:26:33 <dmwit> mjrosenb: You're right. I haven't looked much at the source of fraction, but a priori I give it a pretty low probability.
20:26:42 <orion> wow
20:26:49 <orion> It went from >9GB to ~200MB
20:27:46 <trap_exit> this is emas intersect haskell; but since ~ 50% #haskell uses eamcs, I'm asking here:
20:28:06 <trap_exit> I have my emacs cursor over "foo_bar", when I hit gg, I want emacs to execute >> grep "foo_bar :: "
20:28:08 <trap_exit> how do I do this?
20:28:18 <trap_exit> basically, when I have my mouse over a word, and I hit gg
20:28:23 <trap_exit> I want emacs to do a grep and find wher eit' sdefined
20:29:34 <joelteon> that's not haskell at all
20:29:36 <joelteon> ask #emacs
20:29:39 <trap_exit> okay, we need (interactive) (grep ... )
20:29:52 <trap_exit> no one here has such a function pre-written ?
20:29:58 <mjrosenb> trap_exit: is this in haskell-mode, or in a haskell-inferior buffer?
20:30:17 <trap_exit> I'm in Haskell-Mode
20:30:21 <mjrosenb> trap_exit: I just use M-x ack (or any one of 5 similar variants)
20:30:43 <mjrosenb> trap_exit: I suspect you want "gg" to insert "gg"
20:31:11 <trap_exit> oh, I'm using evil (vi simulation) under emacs
20:31:20 <trap_exit> but, sure, I probably want C-x 9 or osmething
20:31:31 <mjrosenb> trap_exit: oh god, nobody can save you.
20:31:58 <mjrosenb> joelteon: tby, I'm almost positive that haskell-mode is maintained by the haskell community, not the eamcs community.
20:32:08 <joelteon> oh
20:32:47 <carter> i think its under github.com/haskell
20:32:57 <joelteon> i mean i know haskell-mode is
20:33:01 <mjrosenb> *tbf
20:33:04 <joelteon> but i wasn't aware you couldn't make bindings like that global in emacs
20:34:15 <orion> @type concatMap
20:34:15 <lambdabot> (a -> [b]) -> [a] -> [b]
20:34:28 <platz> i just learned about M-x occur but that only searches open buffers
20:49:56 <trap_exit> in acse anyone else want the same:
20:49:56 <trap_exit> https://gist.github.com/anonymous/e2f8b79cb86dc1cc8246
20:53:50 * hackagebot bson 0.3.1 - BSON documents are JSON-like objects with a standard binary  encoding.  http://hackage.haskell.org/package/bson-0.3.1 (GregWeber)
21:04:49 <Welkin> haskell platform 2014 is out!
21:05:11 <Walther> Ooh! What are the main improvements?
21:05:14 <Welkin> but is it worth the upgrade if it means I will have to reinstall tons of libraries?
21:05:18 <Walther> or changes, for that matter
21:05:24 <Welkin> ghc 7.8.3
21:05:50 <nitrix> I already have 7.8.3 ...
21:05:52 <nitrix> Archlinux :D
21:06:02 <nitrix> Gotta stay bleeding edge man!
21:06:04 <Welkin> I don't know what the support for OpenGL and GLUT mean
21:07:18 <merijn> Welkin: OpenGL and GLUT are graphics libraries
21:07:23 <Welkin> I know
21:07:29 <Welkin> does that just mean they are included?
21:07:50 <merijn> Welkin: They were broken in the past, I think. They are fixed now (and included, yes)
21:09:42 <joelteon> it has old versions of some libraries too if i remember correctly
21:11:31 <merijn> Welkin: The question is basically: Do you feel comfortable manually managing packages/GHC installation? If yes, then platform probably doesn't gain you much
21:12:16 <Welkin> I'm still on ghc 7.6.x
21:12:23 <Welkin> is there much to gain from 7.8.3?
21:13:31 <merijn> TypedHoles \o/
21:13:46 <dmj`> Welkin: yea, MIO
21:13:49 <merijn> Closed typefamiles \o/ (or where those alreay in 7.6)
21:13:58 <dmj`> Welkin: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
21:14:00 <Welkin> what is MIO?
21:14:02 <joelteon> Compiler permorfance regression \o/
21:14:10 <joelteon> also, spelling permorfance regression
21:14:12 <joelteon> They fixed that anyway
21:14:15 <orion> How do you do something like myFunc (x:xs) if the argument is a ByteString?
21:14:17 <merijn> Welkin: Oh, yeah, MIO the new high performance IO manager
21:14:20 <joelteon> orion: you don't
21:14:45 <merijn> orion: There's functions to split one character of and there's unpack which converts ByteString into [Word8]
21:14:52 <Welkin> dmj`, thanks for the link
21:15:37 <dmj`> orion: let (hd, tl) = (B.head xs, B.tail xs)
21:15:57 <joelteon> case B.uncons xs of Just (hd, tl) -> ...; Nothing -> ...
21:16:49 <dfeuer> Orion, there are also some magical fake pattern things GHC can do these days. I have no idea how to use them though.
21:16:55 <joelteon> viewpatterns
21:17:06 <joelteon> myFunc (B.uncons -> (x:xs)) = ...
21:17:16 <joelteon> or rather Just
21:17:50 <dolio> Doing a bunch of uncons stuff on a bytestring is probably not very recommendable.
21:18:07 <joelteon> That too
21:18:07 <dmj`> @typ BS.head &&& BS.tail
21:18:08 <lambdabot> BSC.ByteString -> (Word8, BSC.ByteString)
21:18:47 <thoughtpolice> orion: hi, sorry i haven't been around this week.
21:19:00 <thoughtpolice> i believe you pinged me a while back?
21:21:11 <dfeuer> Also pattern synonyms, whatever those are. Thoughtpolice, do ByteStrings not have efficient slicing like Vectors?
21:21:50 <dfeuer> Or is unidentified garbage the issue?
21:22:10 <dfeuer> Sorry, I meant dolio.
21:22:18 <dolio> It depends on which bytestring you're using.
21:22:41 <c_wraith> they have efficient slicing (mostly), but it still requires allocation.  It's O(1), but it's still more work than you might want to do
21:23:25 <dfeuer> In any case, orion, you probably should use maps and folds and such to the extent you can, which will tend to work better with the stream fusion magic and various other magics.
21:23:42 <dolio> ByteString hasn't had any stream fusion for years.
21:24:31 <dolio> If it did have stream fusion, using something that does a tail-like operation would be really bad, though.
21:24:51 <dfeuer> When was the stream fusion removed, and why?
21:25:14 <dolio> It was removed a long time ago, and I don't know why.
21:25:53 <dfeuer> Is there a packed byte Vector of some sort to take up that bit of slack?
21:25:58 <c_wraith> yes
21:26:12 <c_wraith> StorableVector of Word8 is packed
21:26:28 <dolio> So are unboxed vectors.
21:26:29 <c_wraith> And in the appropriate format for FFI communication, just like bytestring
21:26:31 <dfeuer> That could be why. If Vector's doing it, Bytestring can stick to making non-streaming stuff fast. I guess.
21:27:02 <dolio> I don't think they have all the stuff for doing I/O like bytestring has, though.
21:27:23 <dolio> The removal of stream fusion from bytestring predates vector.
21:27:34 <dolio> I'm pretty sure.
21:27:34 <dfeuer> dolio: I now remember seeing that limitation back when I looked at it.
21:29:00 <c_wraith> I know I've asked this before, but I don't remember ever getting an answer - why doesn't GHC warn on MPTC declarations that include a member that's impossible to use because they don't use enough of the type variables to allow an instance to ever be chosen?
21:33:59 <dfeuer> c_wraith: sometimes there is no answer. File a feature request?
21:42:51 <enthropy> class C a b where a :: a; instance (b ~ ()) => C Int b where a = 1
21:43:12 <enthropy> c_wraith: with that one you can use   (a :: Int)
21:44:13 <c_wraith> really? GHC doesn't assume that instance might be overlapped?
21:44:15 <enthropy> That sketchy class is not a really a good reason to have no warning though
21:45:33 <enthropy> ghc picks that instance when it sees that the 'a' type variable is Int
21:45:54 <enthropy> then later on that ~ constraint forces b to be ()
21:46:15 <c_wraith> But if the instance might be overlapped, that isn't necessarily the best possible match.  If I understand how overlapping instances are selected.
21:47:04 <enthropy> right, I think you can get "instance C Int Char where a = 2" chosen with a type annotation
21:47:06 <c_wraith> I guess the current design assumes instances can't be overloaded unless they were declared in a module with -XOverlappingInstances or -XIncoherentInstances, though
21:47:17 <c_wraith> err, can't be overlapped
21:47:27 <solidus-river> is there a good example of using Events in netwire, i'm looking to make a wire that takes an Event a and does something with A whenever it happens
21:48:28 <c_wraith> enthropy: how would you annotate something so as to get that instance chosen, ever?
21:51:31 <dolio> Which?
21:52:37 <c_wraith> dolio: the "instance C Int Char" case
21:53:00 <enthropy> dolio: how to get one=1 out of http://lpaste.net/109186
21:53:16 * enthropy thought something like that would work, but it doesn't
21:53:37 <c_wraith> It really shouldn't
21:53:57 * hackagebot unagi-chan 0.1.1.0 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.1.1.0 (BrandonSimmons)
21:54:04 <dolio> c_wraith: There's no way you can annotate to choose that instance.
21:54:05 <mjrosenb> so, it looks like grapefruit is horribly out of date.  I asked for recommended replacements recentlyw and promptly forgot about it.
21:54:14 <mjrosenb> any opinions on the matter?
21:54:58 <Welkin> eat some strawberries
21:55:14 <Welkin> an orange is a good substitute for grapefruit if you want something similar
21:55:39 <c_wraith> dolio: I'm kind of horrified that you can even define zero that way, in that example. There are conflicting instances, no way to specify which one to use to resolve it, and GHC just... picks something.
21:56:02 <enthropy> well note the IncoherentInstances
21:56:04 <insejn> hi, I’m trying to implement my own Writer monad from scratch. I have http://lpaste.net/109187, can somebody confirm that I’m on the right track?
21:56:18 <c_wraith> enthropy: oh.  I did miss that one was present.  Ok, it's certainly incoherent.  :)
21:56:49 <c_wraith> enthropy: I'm ok with saying "IncoherentInstances is not a valid excuse for writing a class like that" :)
21:57:36 <enthropy> you don't need it when you just have "instance C Int b"
21:58:08 <solidus-river> is there a way to hoogle within a certain package
21:58:11 <solidus-river> ?
21:58:13 <dolio> c_wraith: Is GHC going to detect: class (b ~ T a) => C a b where type T a :: * ; ... ; foo :: a ; ...
21:58:23 <dolio> And other, more complicated things that are okay?
21:59:42 <c_wraith> dolio: I'm ok with getting a warning if I ever do something like that.  I deserve to be told to reconsider my approach.
21:59:43 <dolio> Seems like it could be tricky.
22:00:14 <dolio> You mean, the approach of encoding fundeps using type families?
22:00:23 <c_wraith> That isn't even a fundep
22:00:23 <dolio> So that they'll make more sense?
22:00:41 <enthropy> it behaves like   C a b | a -> b
22:00:48 <dolio> That is how you write fundeps in terms of type families.
22:01:41 <c_wraith> I don't see how you get any form of injectivity out of that.  Though I am getting hungry enough to fail to think clearly.
22:02:12 <c_wraith> ah, ok.  There it is
22:02:50 <dolio> Perhaps one day C a b | a -> b will be sugar for something like that.
22:03:49 <c_wraith> But nevertheless, when I'm using associated types, it tends to be the case that I don't even need an MPTC anymore.
22:03:53 <glguy_> It isn't quite ready for that, yet. The type inferrence doesn't work the same way as the fundep encoding today
22:04:00 <mjrosenb> Welkin: anything slightly less fruity?
22:04:49 <dolio> glguy_: That's good. Fundeps are weird.
22:05:00 <c_wraith> Fundeps have better inference at the moment, though
22:05:37 <glguy_> Right
22:05:42 <glguy_> c_wraith^
22:05:46 * dfeuer_ missed something. Someone who knows way more than he does just called fundeps "weird", which suggests maybe his own difficulty understanding them is not terribly unusual.
22:06:08 <glguy_> They might be "weird" but they aren't particularly complicated
22:06:17 <dolio> Yeah. They're not super hard to understand.
22:06:29 <dolio> But they don't work in certain ways that you might expect them to.
22:06:31 <solidus-river> are we talking about type families?
22:07:13 <dolio> Whereas type families do work that way.
22:07:27 <dolio> And it's not because fundeps couldn't work that way, too. They just don't.
22:07:53 <dolio> (Obviously, since the other way that fundeps could work can be done by using type families.)
22:08:53 * mjrosenb has had like one occasion to use one of those two, and I don't actually remember which one I used.
22:09:07 <solidus-river> i went with type families!
22:09:11 <glguy_> GHC doesn't make use of the fact that given a   class C a b | a -> b    and two constraints     C a b    C a c     that b~c
22:09:36 <dolio> Which used to be good. Because it might not be true.
22:09:49 <solidus-river> i'm very out of perspective on this conversation but it looks like your trying to prove the injectivity of your type family?
22:09:53 <dolio> That's at least been fixed.
22:10:03 <glguy_> Thanks Iavor
22:10:04 <solidus-river> which data families do but type families do not
22:10:19 <c_wraith> solidus-river: nah, you're way off-base in what's *actually* going on. :)
22:10:23 <solidus-river> damn
22:10:24 <solidus-river> lol
22:10:26 <solidus-river> figured
22:10:37 <solidus-river> netwires types are pretty frustrating
22:10:53 <solidus-river> it doesn't look like there is a way to get the a out of Event a unless your only interested in its frist occurance...
22:12:25 <c_wraith> solidus-river: my quick read of the types is that it's explicitly set up that way to prevent you from doing that
22:12:47 <c_wraith> solidus-river: but I've never used netwire, so I could be way off
22:13:00 <solidus-river> thats annoying though
22:13:05 <solidus-river> i mean i guess it forces you to abstract values from events
22:13:12 <solidus-river> but what if you want a value associated with an event
22:13:21 <solidus-river> like i want to make a bullet, but i need a value for its positio and direction
22:13:27 <solidus-river> with this abstraction i cant use events for that anymore
22:13:31 <solidus-river> even though its very clearly an event
22:13:59 * hackagebot yi-monokai 0.1.1.2 - Monokai colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-monokai-0.1.1.2 (MateuszKowalczyk)
22:14:11 <dolio> glguy_, c_wraith: Does GHC not take advantage of information that a determines b in type inference? Is that the deficiency?
22:14:40 <dolio> Because it's way too roundabout to see in the family version.
22:14:46 <solidus-river> dolio: only if the type says that a determines b
22:15:29 <glguy_> dolio: There's been a lot of indirection in this conversation, just to be clear we're talking about:   instance b ~ () => C Int b    without any fundep or tf, right?
22:15:42 <dolio> solidus-river: Well, "class (b ~ T a) => C a b where type T a :: * ; ..." does say that, in a way.
22:16:22 <dolio> glguy: I was thinking more about the fact that the class has a fundep could be used to improve inference in ways that wouldn't be figured out by the equivalent family version.
22:16:51 <c_wraith> dolio: yeah, that enocding pushes the type equality witness to the context, instead of making it available during inference
22:17:13 <glguy_> dolio: I was saying that the version you just pasted has less desirable inference properties compared to either the TF or FD version
22:17:19 <solidus-river> dolio: the difference is that with the family version you have to prove injectivity
22:17:52 <c_wraith> In theory, GHC could do more with ~ constraints than it does at the moment.
22:18:05 <solidus-river> dolio: https://github.com/fuag15/yaskl/blob/master/src/Yaskl/Data/Database.hs
22:18:11 <dolio> solidus-river: Prove injectivity of what?
22:18:21 * solidus-river keeps chiming in to this conversation even though he's as lost as walter
22:18:36 <solidus-river> dolio: injectivity of the class to its chosen type
22:18:44 <c_wraith> I thought Donny was the one who was lost.
22:18:59 <solidus-river> THATS HOW LOST I AM
22:19:04 <Walther> Huh?
22:19:07 <solidus-river> lol
22:19:22 <dolio> The fundep version doesn't have b injectively determined by a, either.
22:19:23 <solidus-river> Walther: don't worry, i'm out of my element, man
22:19:26 * Walther hands solidus-river a `map`
22:30:40 <jxv>  #haskell-game
22:31:47 <carter> c_wraith: dolio: you put the fundep (b ~ T a) in the methons
22:31:54 <carter> not in the class header
22:32:13 <carter> i actually do that a lot
22:32:22 <haasn> dolio: I don't understand the class definition you gave. Why would you have a type family if you're including the type in the instance head as well?
22:33:11 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Layout/Sparse.hs#L263-L283
22:37:52 <dolio> haasn: Because sometimes it's nicer to do that.
22:38:18 <dolio> Well, not in practice, probably. But sometimes fundep definitions are nicer than associated types.
22:38:46 <enthropy> you could do "class C a where type T a" "type C1 a b = (C a, b ~ T a)"
22:39:03 * hackagebot warp 3.0.0.7 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.7 (MichaelSnoyman)
22:41:33 <haasn> or class C a b | a -> b
22:41:40 <haasn> Unless there's some difference I fail to see
22:41:59 <dolio> If you don't want to use fundeps.
22:42:03 <dolio> Because they're weird.
22:42:09 <glguy_> The original discussion was just about ways you can encode things
22:42:13 <glguy_> not a particular recommendation
22:42:33 <dolio> Yes. Or detecting encodings of certain things.
22:43:31 <dolio> Fundeps make it okay to not mention part of your instance head in a method type. And there are ways of encoding fundeps into families that you might want to detect if you're going to try to warn about not mentioning variables.
22:44:10 <dolio> But it can probably be hard to detect when it's okay in general.
22:45:25 <dolio> Also if you start having multi-directional fundeps, there's probably no choice of primary instance variable you can make in general.
22:45:34 <solidus-river> whats the point of wraping and unwrapping arrows?
22:45:42 <solidus-river> or wrapping and unwrapping monads
22:45:43 <dolio> You just have to have the full encoding.
22:45:52 <dolio> Like WrappedMonad?
22:46:06 <solidus-river> dolio: yeah, whats the point of the wrapping?
22:46:27 <dolio> It lets you use the applicative combinators without incuring an Applicative constraint.
22:46:38 * merijn mumbles something about 7.10
22:46:45 <solidus-river> dolio: is there a good example?
22:46:49 <dolio> Yeah, it'll be pointless in 7.10.
22:47:02 <zq> hm
22:47:11 <merijn> solidus-river: Monad doesn't require a type to have an Applicative instance, but logically every Monad *has* to be an Applicative
22:47:18 <dolio> solidus-river: It's like having liftM.
22:47:22 <zq> is it possible to pattern match on utf-8 encoded bytestrings?
22:47:39 <merijn> solidus-river: The wrapper exists to let you use Applicative operators with any monad, even those with missing applicative instances
22:47:52 <merijn> zq: Maybe, depends on what you want?
22:48:37 <zq> merijn: Data.ByteString.UTF8 exports a fromString :: String -> ByteString
22:49:02 <zq> merijn: so how would do something like, case fromString "whatever" of { "whatever" -> ... }?
22:49:05 * hackagebot hspec 1.11.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.11.2 (SimonHengel)
22:49:07 * hackagebot hspec-meta 1.11.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.2 (SimonHengel)
22:49:28 <merijn> zq: If you want anything with any sort of reasonable performance you probably wanna use Text rather than String when converting to/from ByteString
22:49:55 <zq> well actually
22:50:01 <zq> i'm converting to and from text
22:50:15 <zq> as in, text <-> bytestr
22:50:20 <merijn> zq: Pattern matching Text in a sane way is pretty easy
22:50:38 <zq> of course; instance IsString Text works fine
22:50:58 <zq> the problem is that instance IsString ByteString doesn't encode to utf8, and i'd liek that to happen
22:51:20 <zq> do i define my own instance? how do i get it to override Data.ByteString.Internal's instance definition?
22:51:23 <mjrosenb> so... if I want to build a package with  base (==4.*), am I just boned?
22:51:24 <merijn> zq: The short answer to that is "too bad"
22:51:34 <merijn> zq: You can't override ByteString's instance
22:51:41 <dfeuer_> You can't override instances, but you can make newtypes with their own.
22:51:51 <dfeuer_> But
22:51:59 <merijn> dfeuer_: Which is probably more work than just encoding/decoding
22:52:10 <dfeuer_> ByteString as IsString does not really exactly make snse.
22:52:12 <zq> then i'd have to redefine my own ByteString ops too
22:52:25 <zq> dfeuer_: how not?
22:52:27 <merijn> zq: I think lens has a lens (or prism, I guess) between ByteString and Text, you might be able to do something nifty with that
22:52:35 <zq> oh man
22:52:39 <merijn> zq: Ask around in #haskell-lens for help with that
22:52:51 <zq> i really don't want to stoop to using lens :\
22:52:52 <edwardk> :t Data.ByteString.Strict.Lens.packedChars
22:52:53 <lambdabot> (Profunctor p, Functor f) => p BSC.ByteString (f BSC.ByteString) -> p String (f String)
22:53:04 <merijn> edwardk--
22:53:17 <merijn> edwardk: I'm disappointed that that exists :(
22:53:27 <edwardk> :t Data.ByteString.Strict.Lens.packedBytes
22:53:28 <lambdabot> (Profunctor p, Functor f) => p BSC.ByteString (f BSC.ByteString) -> p [Word8] (f [Word8])
22:53:32 <edwardk> =)
22:53:38 <shachaf> packedBytes is better
22:53:47 <shachaf> It's even the fancy tree version.
22:53:49 <zq> iirc, that doesn't encode to utf8
22:54:16 <edwardk> the former matches the semantics of Data.ByteString.Char
22:54:26 <dfeuer_> What is BSC?
22:54:48 <edwardk> BSC = Data.ByteString.Char
22:54:55 <edwardk> er Char8
22:55:00 <dfeuer_> Huh.
22:55:18 <shachaf> Char8 is a lie, unfortunately.
22:55:20 <dfeuer_> Is that for ASCII/Latin-1/whatever?
22:55:23 <edwardk> same bytestring as regular
22:55:37 <edwardk> but with the assumption all characters are in the latin-1 codepage basically
22:55:48 <edwardk> iso-8859-1 encoding
22:56:18 <dfeuer_> edwardk, do you have another moment to talk about coercions?
22:56:30 <athan> What's the current topic? (sorry)
22:56:33 <edwardk> passing out momentarily actually
22:56:40 <dfeuer_> The best time!
22:56:44 * dfeuer_ pours edwardk a drink.
22:57:01 <athan> Take a sensu bean
23:01:00 <Welkin> I thought I was in an anime channel for a moment
23:01:06 <Welkin> at the mention of senzu beans
23:01:09 <Welkin> and the roleplaying
23:01:16 <merijn> athan: The current topic is our disappointment in edwardk's inclusion of Char8 in lens :p
23:01:31 <Welkin> edwardk, you are such a disappointment
23:01:46 <shachaf> roconnor_: Did you see http://sneezy.cs.nott.ac.uk/fplunch/weblog/?m=200801 ?
23:01:59 <edwardk> Welkin: good to know =)
23:02:52 <shachaf> merijn: lens mostly tries to reflect the API of the libraries it's wrapping
23:03:22 <edwardk> lens borrows the infelicities of whatever it is modeling as needed
23:03:33 <merijn> shachaf: Sure, I'm mostly (only mostly!) joking about my disappointment :)
23:04:19 <athan> huh... yeah I got nothing. I was hoping for lexers or something. Also, Welkin, believe it.
23:04:48 <athan> *thumbs-up with swirly thing on thumbprint*
23:06:14 <benzrf> athan: swirly thing?
23:08:20 <athan> benzrf: http://www.narutoultimateninja.net/pictures/kakashi-06132009.jpg
23:08:33 <athan> benzrf: SUPER MEGA THUMBS UP +1!
23:09:14 <Welkin> you need to have sparkles around your eyes and colored swirls in the air around you
23:09:42 <Welkin> athan, are you the one in denver?
23:10:13 <benzrf> oh
23:10:18 <athan> Welkin: Hahahaha, yessir, yes I am the Denverite
23:10:19 * benzrf sighs
23:10:42 <benzrf> i thought i saw a believe it or two
23:11:00 <athan> benzrf: It's hard to restrain the urge to vomit whenever I hear it
23:11:08 <orion> hmm
23:11:46 <athan> benzrf: It's like... exaggerated enthusiasm. I just... cannot believe it (:o)
23:11:54 <benzrf> i had a naruto phase
23:12:02 <benzrf> i dont think they did the believe it thing in the manga
23:12:13 <orion> So, I am running this code right now: http://ideone.com/3HOj3Y
23:12:24 <orion> The size of the process grew to 4 GB after ~10 minutes.
23:12:47 <thelinuxkitten> set
23:12:51 <athan> benzrf: I heard the manga was sweet! I like anime in general, but that show was a pretty good let-down.
23:12:53 <orion> (The words function has been changed to an array with a lot more permutations)
23:13:00 <Welkin> athan, did you find a job?
23:13:02 <benzrf> i dunno
23:13:10 <benzrf> athan: it was basically the perfect storm of shonen
23:13:12 <benzrf> in retrospect
23:13:12 <athan> Welkin: Interview tuesday at a firm!! :)
23:13:13 <orion> Shouldn't GC kick in at some point?
23:13:21 <Welkin> athan, nice!
23:13:31 <Welkin> athan, at a denver startup?
23:13:53 <merijn> orion: Well, perhaps it can't GC anything because you have a memory leak?
23:14:03 <athan> Welkin: I'm working on a html/css parser for optimizing websites, hopefully I'll get into google with it here in Boulder, but yeah at a start up :)
23:14:16 <orion> merijn: Indeed. I don't know where I am leaking though,.
23:14:16 <joelteon> that's a big process!
23:14:35 <athan> joelteon: What is?
23:14:39 <merijn> orion: May want to profile the code and find out :)
23:14:41 <joelteon> 4 GB
23:14:57 <merijn> orion: Real World Haskell has a chapter on profiling memory usage (somewhere in the 20ish range)
23:15:10 <merijn> @where rwh
23:15:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:16:53 <athan> benzrf: It was, though! I love the battle they had, it took forever for it to build though
23:19:38 <benzrf> athan: i didnt mean that as a good thing
23:19:52 <benzrf> well, not rly a bad thing. an ambivalent thing
23:22:33 <hamid> :t ( fmap (+) (Just 1) )
23:22:34 <lambdabot> Num a => Maybe (a -> a)
23:23:03 <hamid> :t ( fmap (+) (Just 1) ) >>= (\x -> x 2 )
23:23:03 <lambdabot> Num (Maybe b) => Maybe b
23:23:20 <dmj`> I have some code that's leaking memory, process freezes after a few days. Hard to know where to look though.
23:25:26 <hamid> hmm     No instance for (Num (Maybe b0)) arising from a use of ‘it’
23:25:32 <Fuuzetsu> is ::: no longer a thing in vinyl?
23:25:38 <hamid> > ( fmap (+) (Just 1) ) >>= (\x -> x 2 )
23:25:40 <lambdabot>  No instance for (GHC.Show.Show b0)
23:25:40 <lambdabot>    arising from a use of ‘M15885425469119965379104.show_M15885425469119965379...
23:25:40 <lambdabot>  The type variable ‘b0’ is ambiguous
23:25:40 <lambdabot>  Note: there are several potential instances:
23:25:40 <lambdabot>    instance [safe] GHC.Show.Show
23:26:08 <trap_exit> on hoogle, I could not find anything of the form: ((a -> a) -> b -> b) -> (a -> m a) -> b -> m b
23:26:08 <hamid> could someone help me to fetch the _b_ out here? :)
23:26:23 <trap_exit> but it seems like a common strategy
23:26:28 <athan> hamid: That's a good one!
23:26:32 <trap_exit> i.e. suppose we have data foo = { .... some_selector :: .... }
23:26:42 <hamid> l :: Num (Maybe b) => Maybe b
23:26:44 <trap_exit> then we want (some_selector -> some_selector) -> foo -> foo ... which is eaasy to write
23:26:53 <trap_exit> but then we want (some_selector -> M some_selector) -> foo -> M foo
23:27:11 <hamid> athan, lol thanks :D
23:27:32 <shachaf> hamid: I'm confused about what you're trying to do but I don't think that code is accomplishing it.
23:27:58 <shachaf> Oh, maybe it almost is.
23:28:00 <shachaf> > ( fmap (+) (Just 1) ) >>= (\x -> return (x 2) )
23:28:02 <lambdabot>  Just 3
23:28:10 <shachaf> But there's no point to writing it like that.
23:28:20 <hamid> shachaf, that's it!
23:28:25 <hamid> shachaf, thanks :)
23:28:55 <shachaf> But why use (>>=)?
23:28:57 <hamid> shachaf, just trying to figure out how type system works :P
23:29:12 <shachaf> "a >>= (\x -> return (f x))" is just "fmap f a"
23:29:33 <Welkin> shachaf looks so much like snapchat
23:29:52 <Welkin> at first glance
23:30:20 <Fuuzetsu> jonsterling: what's up with vinyl 0.4.x, where did my ‘:::’ go?
23:30:22 <hamid> ow :/ right! so another fmap
23:30:39 <haasn> I don't know, I've never seen shachaf
23:31:01 <shachaf> haasn: As far as you know.
23:33:18 <haasn> It just occurred to me that you would recognize me just as little as I would recognize you, based on appearance
23:35:27 <athan> Potatoes!
23:35:50 <athan> Fuuzetsu: WAT::_wat?_
23:36:02 <Fuuzetsu> athan: ??
23:36:22 <athan> Fuuzetsu: How did they manage to remove it?? (*investigates*)
23:36:49 <Fuuzetsu> it's just not there
23:36:54 <Fuuzetsu> apparently things are different now
23:37:24 <Fuuzetsu> so the 60 or so ::: fields in this module now chuck errors
23:37:37 <mjrosenb> ok, sillt question (as usual).  what is the current version of base?
23:37:53 <glguy_> We had a talk by Jon Sterling 4 days ago about the new version of Vinyl http://vimeo.com/102785458
23:37:56 <athan> Fuuzetsu: :/
23:38:14 <glguy_> I believe he explains some of that
23:38:27 <Fuuzetsu> ah, I'll be sure to watch that, just gotta pop some food in the over
23:38:29 <Fuuzetsu> thanks glguy
23:38:45 <haasn> I don't know where (:::) went but I'm amazed the infixr 9 annotation for (:&) renders correctly on the haddock page
23:39:13 <Fuuzetsu> I wish the person who implemented it wasn't amazed that it worked.
23:39:42 <haasn> Oh, we have a test case for it. I just forgot
23:39:48 <Fuuzetsu> haasn: btw, we're moving out Haddock dev out of GHC tree (so no validates or building HEAD to hack) so I expect a lot more patches in the future ;^)
23:39:59 <haasn> Interesting news
23:40:06 <haasn> Is haddock no longer being bundled with GHC?
23:40:25 <Fuuzetsu> it is, they are going to track a separate branch and pile API patches on top
23:40:35 <Fuuzetsu> then at GHC release we just make sure we can work with new GHC API
23:40:41 <Fuuzetsu> rather than fighting with it between releases too
23:41:10 <haasn> Interesting
23:41:28 <haasn> Now if only I had the time and motivation to work on Haddock this would be really useful
23:41:41 <Fuuzetsu> yes, likewise
23:42:00 <trap_exit> is there a way to make these 2 lines into 1 line? besides the lame use of ; to separte the do block
23:42:04 <trap_exit> https://gist.github.com/anonymous/55b44004166ceb688179
23:42:23 <Fuuzetsu> trap_exit: lens
23:42:34 <trap_exit> too slow
23:42:47 <Fuuzetsu> @undo do {gui' <- f $ _gs__gui gs; return gs { _gs__gui = gui' }}
23:42:47 <lambdabot> f $ _gs__gui gs >>= \ gui' -> return gs{_gs__gui = gui'}
23:43:20 <trap_exit> argh
23:43:23 <trap_exit> no use of liftM or something to make this work ?
23:43:43 <haasn> fmap (\gui' -> gs { _gs__gui = gui'}) $ f _gs__gui gs
23:43:58 <Fuuzetsu> records just make things ugly as hell
23:44:50 <haasn> fmap (\gui' gs & gs__gui .~ gui') $ f (gs^.gs__gui)
23:44:51 <haasn> much better
23:45:32 <trap_exit> lol
23:45:33 <trap_exit> wtf
23:45:42 <haasn> That actually looks a lot like the definition of a lens
23:45:54 <trap_exit> it basically is
23:45:56 <trap_exit> but template hell screws up all my compile time
23:47:04 <c_wraith> then write lenses without TH?
23:47:58 <Fuuzetsu> edwardk worked hard to give you more time for swordfighting and this is what you do? tsk tsk tsk
23:49:14 <haasn> It's not really a lens, though. Can't read out of it because the constraint is too strict
23:49:41 <sgronblo> I've been looking at the Applicative functor a bit recently and trying to learn how to use it and why it's considered "weaker/having less structure/some other similar explanation" than a Monad.
23:50:03 <haasn> :t join
23:50:04 <lambdabot> Monad m => m (m a) -> m a
23:50:19 <haasn> You cannot write an equivalent function for :: Applicative f => f (f a) -> f a
23:50:25 <haasn> That's why it's “weaker”
23:50:31 <dmj`> trap_exit: how does it screw up your compile time?
23:50:33 <sgronblo> There was also an article making the rounds at HN/programming reddit by some guy at Thoughtbot who wrote about the difference, but I think he is mistaken.
23:50:34 <merijn> sgronblo: Monads are "Applicative + join", essentially :)
23:50:48 <sgronblo> http://pbrisbin.com/posts/applicative_functors/ this one
23:51:13 <merijn> sgronblo: Yeah, I saw that, but there's some errors/sloppiness in it
23:51:27 <c_wraith> oh.  Yeah, that looks pretty sloppy.
23:51:34 <haasn> I like to present applicative in a different form either way
23:51:45 <merijn> sgronblo: His type for >>= is wrong, for example
23:51:46 <haasn> I think if applicative as this: liftA2 (,) :: Applicative f => f a -> f b -> f (a,b)
23:51:46 <c_wraith> I just skimmed it.  Anything that talks about wrapping and unwrapping is usually missing the point.
23:52:47 <haasn> This is basically http://www.haskell.org/haskellwiki/Typeclassopedia#Alternative_formulation
23:52:58 <sgronblo> So my current intuitive understanding is that with a Monad you can refer to earlier values in a chain of bound functions (I'm guessing there will be lots of objections to this simple notion though?)
23:53:38 <haasn> sgronblo: Sort of; yes, the determining difference is that Monad gives you the power to make the next action depend on previous results
23:53:55 <merijn> sgronblo: Well, actually the types of (>>=) and <*> tell us something interesting already
23:54:01 <merijn> :t (<*>)
23:54:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:54:05 <merijn> :t (>>=)
23:54:05 <sgronblo> I would also like to think that both Monads and Applicative are partially about sequencing actions, but the discussion here made me doubt this idea slightly: https://news.ycombinator.com/item?id=8158759
23:54:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:54:14 <haasn> For example, I could write an IO action like:  getLine >>= \line -> if line == "quit" then exitProgram else doSomething
23:54:42 <sgronblo> haasn: yeah so that fits together with my "make the next action depend on previous results"
23:54:59 <haasn> When using only Applicative, that is not possible; I could perform both exitProgram and doSomething and combine their results afterwards
23:55:06 <haasn> But I can't possibly choose to execute or not execute one or the other
23:55:12 <merijn> sgronblo: With Applicative I have 2 f arguments as input, I don't get to inspect what the 'a' inside the 'f a' is, I can only apply the function 'a -> b' to it
23:55:37 <mjrosenb> wow, pqueue generates a lot of errors when it builds
23:55:55 <merijn> sgronblo: With >>= the second argument is "a -> m b", that is a user provided function that get's an 'a', does whatever it wants with that 'a' and then returns a (potentialy, completely unrelated) 'm b'
23:55:59 <mjrosenb> s/errors/warnings/
23:56:10 <haasn> sgronblo: An attempt to write this applicatively could start off as: (\line a b -> if line == "quit" then a else b) <$> getLine <*> exitProgram <*> doSomething; but as mentioned, this will cause getLine, exitProgram *and* doSomething to execute and will only combine their results in a pure way
23:56:21 <merijn> sgronblo: In other words, with Monad the 'm b' that is returned can depend on the value of 'a', with Applicative it cannot
23:56:28 <haasn> That's the fundamental “weakness” of Applicative - potential advantages notwithstanding
23:56:58 <merijn> sgronblo: I can write "x >>= \a -> case a of 1 -> foo; 2 -> bar" <- the executed action can depend on 'a'
23:57:26 <merijn> sgronblo: With applicative the executed actions can never depend on the value produced by earlier actions (which I think is what you meant earlier?)
23:57:43 <mjrosenb> merijn: I think the phrase "the 'mb'" is highly ambiguous
23:57:49 <haasn> sgronblo: “sequencing actions” is one thing they're both useful for, but there are others, too.
23:58:21 <merijn> mjrosenb: In what sense is it ambiguous?
23:58:54 <sgronblo> Is it correct to claim that they sequence actions though?
23:59:09 <sgronblo> There was some back and forth in that HN discussion
23:59:40 <merijn> sgronblo: Yes, no, maybe
23:59:45 <haasn> sgronblo: For IO, yes
23:59:49 <haasn> For some other monad/applicative; who knows?
23:59:52 <merijn> sgronblo: Depends on your definitions of sequence and action :)
