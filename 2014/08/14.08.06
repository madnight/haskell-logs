00:03:23 * hackagebot hsshellscript 3.3.2 - Haskell for Unix shell scripting tasks  http://hackage.haskell.org/package/hsshellscript-3.3.2 (VolkerWysk)
00:12:24 <haasn> I guess the “optimal” definition is getLongerList xs ys = go xs ys where go [] _ = ys; go _ [] = xs; go (_:xs') (_:ys') = go xs' ys'
00:16:15 <frerich> haasn: I think I like a solution based on something like 'compareLength :: [a] -> [a] -> Ordering' better simply because using that to define 'getLongerList' shows very clearly what it is doing. "if compareLength xs ys == GT then xs else ys" seems very expressive to me.
00:17:35 <frerich> Maybe even with 'isLongerThan = (== GT) . compareLength' such that you can write 'if xs `isLongerThan` ys then xs else ys' :-)
00:17:49 <frerich> Make that .:
00:18:24 * hackagebot auto-update 0.1.1.0 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.0 (MichaelSnoyman)
00:18:26 * hackagebot warp 3.0.0.6 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.6 (MichaelSnoyman)
00:19:20 <josiah14> is there a way to take something of type IO (IO String) and reduce it to just IO String?
00:19:26 <ion> join
00:19:43 <tdammers> :t join
00:19:44 <lambdabot> Monad m => m (m a) -> m a
00:19:47 <tdammers> TIL
00:20:14 <annelies> join ist wunderbar
00:20:19 <tdammers> x <- a >> x -- is what I would have used
00:20:29 <tdammers> conceptually speaking, that is
00:20:44 <tdammers> do { x <- a; x } -- technically
00:20:48 <annelies> join = (>>= id)
00:20:59 <frerich> tdammers: I agree, to me 'join' is a bit of a code smell.
00:21:00 * tdammers nods
00:21:10 <tdammers> frerich: why?
00:21:23 <tdammers> frerich: I had a perfectly legitimate use for it at one point
00:22:14 <tdammers> something about pagination with cairo
00:22:14 <frerich> tdammers: Note that I said 'code smell', not 'blatantly obvious errors which shouldn't have been permitted to the libraries in the first place'. ;-) I saw a whole bunch of cases wher e'join' was used even though you could have avoided nested monadic values in the first place (e.g. by 'x <- a; x')
00:22:33 <tdammers> yeah, but in that particular case, the nested values actually made sense
00:22:40 <frerich> So if I see 'join', I squint and try to see whether the code can be simplified.
00:22:59 <tdammers> and I didn't actually use join; I explicitly unwrapped the actions and then ran them
00:23:07 <tdammers> like the thing I just quoted
00:23:09 <shachaf> I like join.
00:23:10 <haasn> Disclaimer: If you have something of type IO (IO String), maybe “join” is not what you want
00:23:23 <haasn> Examples I can think of includes asynchronous callbacks
00:23:23 <annelies> I prefer to use do notation when combining monadic actions.
00:23:29 <haasn> Where ‘join’ would defeat the purpose
00:23:37 <haasn> Or other things that you want to get as an action to trigger later
00:23:40 <shachaf> I'd rather have join (f <$> x <*> y) than do { a <- x; b <- y; f x y }
00:24:05 <haasn> My poison of choise is liftM2 f
00:24:08 <haasn> choice*
00:24:12 <shachaf> (Or I'd rather have the latter turn into the former. I think that's coming up.)
00:24:25 <shachaf> haasn: OK, I'd rather have join (liftA2 f x y)
00:25:15 * haasn .oO(  iI f x y J Ii  )
00:25:20 <annelies> do { r <- f <$> x <*> y; r } :D
00:25:32 <haasn> s/J Ii/Ji/
00:40:38 <josiah14> join worked, thanks guys
00:40:45 <josiah14> although lift is nice, too
00:42:57 <djcoin> Is there an article where you can see each optimization step performed by haskell to go from source code to "binary" that take advantage of purity, inlining etc. ? (eg: for monad, I was wondering if in the end, all function were called or inlined) Thanks!
00:45:18 <haasn> The best way to do that is to study GHC's various intermediate representations
00:45:26 <haasn> -ddump-simpl for simplified core usually tells you a lot
00:45:30 <haasn> But see man ghc for the full list
00:50:59 <djcoin> Thanks haasn, I will see that, i'm still interested in an article which provide guided discovery of this though! :)
00:51:19 <haasn> Maybe http://alpmestan.com/2013/06/27/ghc-core-by-example-episode-1/ would help?
00:52:36 <djcoin> haasn: Yep, thanks!
01:28:36 * hackagebot wai-logger 2.2.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.2.1 (KazuYamamoto)
01:32:06 <solidus-river> is there a function for given the list
01:32:11 <solidus-river> [1, 2, 3, 4]
01:32:12 <solidus-river> i want to
01:32:16 <solidus-river> 1 + 2 + 3 + 4
01:32:21 <solidus-river> :t sequence
01:32:22 <lambdabot> Monad m => [m a] -> m [a]
01:32:22 <dv-> yes, sum
01:32:34 <solidus-river> well but i don't want to use +
01:32:43 <mr-> solidus-river: foldr ?
01:33:08 <djahandarie> :t mconcat
01:33:10 <lambdabot> Monoid a => [a] -> a
01:33:11 <csierra> solidus-river: why don't you want to use +?
01:33:15 <djahandarie> :t foldr
01:33:16 <lambdabot> (a -> b -> b) -> b -> [a] -> b
01:33:22 <djahandarie> Pick your poison.
01:33:26 <solidus-river> maybe, i'm trying to simplify this http://lpaste.net/108894
01:33:38 <solidus-river> it feels like it should fit into a fold or a a map
01:33:56 <solidus-river> but doesn't quite fit
01:34:03 <solidus-river> i'm thinking i can do someting snazy with Applicative
01:34:11 <solidus-river> and --> maybe
01:35:00 <solidus-river> > (+) <$> [1, 2, 3, 4]
01:35:02 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
01:35:14 <dv-> mapM_ step [left, down, right, up] ?
01:35:17 <djahandarie> It depends what structure --> and your values have.
01:35:48 <solidus-river> dv-: yeah but then that messes with --> which is the switch function for netwire
01:36:02 <solidus-river> so they have to run in sequence and have --> inbetween them
01:36:29 <solidus-river> or wait, maybe i'm thinking of wires wrong
01:37:00 <dv-> that code looks simple and clear anyway
01:37:06 <djahandarie> :t (-->)
01:37:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:37:16 <djahandarie> Where does one find --> in netwire?
01:37:18 <solidus-river> it has a lot of repition though
01:37:27 <solidus-river> https://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Switch.html#v:-45--45--62-
01:37:55 <solidus-river> takes two wires and returns a new wire that runs the first then the second
01:38:19 <mr-> Let me just remark that "How can I make 1 + 2 + 3 + 4 from [1,2,3,4]" was a rather unfortunate formulation of your actual question :-)
01:38:35 <djahandarie> Haha, quite.
01:39:13 <solidus-river> :p
01:39:44 <annelies> head . s/,/+/g
01:39:45 <annelies> :P
01:40:20 <lfairy> annelies: Tcl?
01:40:45 <solidus-river> mr-: well i was thinking i could generate the different steps via fmap step [left, down, right, up]
01:40:57 <solidus-river> then i'm left with a list of things i want to join with -->
01:41:12 <djahandarie> That approach is certainly possible using foldr.
01:41:22 <annelies> lfairy omg a Haskell-Tcl hybrid
01:41:41 <annelies> though s/// operator is from sed and Perl. Don't know if Tcl has it
01:41:57 <djahandarie> I suspect --> might not be commutative which is why it isn't a monoid (or semigroup). Don't know netwire well enough, anyway.
01:42:14 <enthropy> associative?
01:42:15 <djahandarie> I mean associative.
01:42:39 <solidus-river> yeah its not
01:42:44 <solidus-river> order matters
01:43:21 <lfairy> annelies: treating a list as a string reminded me of Tcl, that's all :P
01:43:26 <solidus-river> i don't think its possible with a fold because you need an initial value for the fold
01:43:29 <annelies> ohh :P
01:43:35 <solidus-river> but i guess i could give it identity as the intial value of fold
01:43:40 <lfairy> Tcl/Haskell sounds horrifying
01:43:44 <djahandarie> :t foldr1
01:43:45 <lambdabot> (a -> a -> a) -> [a] -> a
01:43:53 <levi> solidus-river: There are variants that don't require... what djahandarie said.
01:43:53 <annelies> Reminds me of the day I wished I had a C++-AWK hybrid.
01:44:02 <djahandarie> @src foldr1
01:44:02 <lambdabot> foldr1 _ [x]    = x
01:44:02 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
01:44:03 <lambdabot> foldr1 _ []     = undefined
01:44:10 <djahandarie> Oh, that wasn't what I was hoping for.
01:44:22 <solidus-river> :t foldl1
01:44:23 <lambdabot> (a -> a -> a) -> [a] -> a
01:44:28 <solidus-river> @src foldl1
01:44:29 <lambdabot> foldl1 f (x:xs) = foldl f x xs
01:44:29 <lambdabot> foldl1 _ []     = undefined
01:44:46 <lfairy> I think --> does have an identity, though
01:45:02 <solidus-river> hmm wonder whats clearer
01:45:06 <lfairy> Since it switches when the first argument inhibits, then the identity is the wire that inhibits immediately
01:45:24 * djahandarie -> bed
01:45:37 <lfairy> Or so I think. I don't use netwire, just guessing
01:46:06 <solidus-river> foldl1 --> [list], foldl --> (head list) (tail list), or foldl id --> list
01:46:09 <solidus-river> :t foldl
01:46:10 <lambdabot> (b -> a -> b) -> b -> [a] -> b
01:46:33 <arossouw> is it wrong to think that haskell is more efficient with cpu/memory utilization than interpreted languages?
01:46:50 <annelies> Yes.
01:47:11 <annelies> It's a property of the code in question and of the language implementation, not of the language.
01:47:22 <lfairy> LuaJIT and Julia are two brilliant counterexamples
01:47:39 <arossouw> so part of it has to do with the way the code is written?
01:47:52 <Maior> I have spent an embarrassingly long time trying to work this out: how do I get the current time as seconds-since-UNIX-epoch?
01:47:54 <lfairy> guess so
01:47:55 <arossouw> was just wondering, since reading this article http://eyallotem.blogspot.com/2013/05/comparing-python-and-haskell.html
01:48:00 <levi> arossouw: Both the way that your code is written and the way the implementation of the language is written.
01:48:08 <arossouw> ok
01:48:16 <Maior> I am struggling to find something from UTCTime / POSIXTime / something else -> Integer
01:48:44 <annelies> performance is implementation-defined!
01:49:11 <annelies> except for Java. Java is inherently slow :P
01:49:34 <companion_cube> this is so wrong :p
01:49:43 <arossouw> annelies: do you have some articles or books,that deal with this topic, so that i can educate myself?
01:49:48 <companion_cube> especially when talking about python just before
01:49:49 <lfairy> arossouw: It depends. You can't really make a statement about performance until you have a concrete problem to solve
01:50:02 <annelies> arossouw no idea, there isn't really much to it
01:50:07 <annelies> What do you want to learn about exactly?
01:50:17 <arossouw> efficiency of code
01:50:27 <supki> Maior: e.g. floor?
01:50:28 <lfairy> Go figure out what you're trying to do, then come back
01:50:29 <arossouw> i guess thats where algorithms are important
01:50:35 <Maior> supki: um?
01:50:45 <levi> arossouw: "Haskell" as defined in the Haskell Report could be executed via interpreter, compiler, or with paper and pencil.
01:50:48 <supki> floor :: POSIXTime -> Integer
01:50:57 <arossouw> i see
01:51:25 <Maior> supki: ...oh, thanks!
01:51:35 <arossouw> lfairy: and to make a fair comparison, you'd need to be proficient in all the languages your comparing?
01:51:39 <annelies> arossouw do you want to read about algorithmic complexity or about micro-optimization?
01:52:04 <annelies> or I/O?
01:52:08 <arossouw> i find algorithms exciting, unfimiliar with micro-optimization
01:52:09 <levi> It says what programs should *mean* by describing how they translate to a language that's a slightly-sugared version of lambda calculus.
01:54:00 <arossouw> yesod seems interesting, building webapps with haskell
01:54:38 <levi> Yesod is interesting, but perhaps not the best vehicle for a first Haskell project.
01:54:43 <adimit> Maior: UTCTime instantiates FormatTime. Look at the documentation of FormatTime here http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html#t:FormatTime
01:54:43 <adimit> You can format it using standard strftime expressions.
01:54:43 <adimit> among other things, you can convert it to posix epoch time, i.e. an Integer.
01:54:43 <adimit> (though FormatTime will first give you a String, which you can then Read. I don't know if there's a direct conversion to Int. Probably is for POSIXTime)
01:55:02 <adimit> ah. POSIXTime is just a NominalDiffTime wrt to unix epoch. Since NominalDiffTime instantiates both Real, and Num, you already have yourself a Fractional. Use supki's suggestion of just using floor. (This won't work on UTCTime, just PosixTime.)
01:55:04 <annelies> arossouw algorithmic complexity can betray you, though :P http://i.imgur.com/zX07TZR.png
01:55:10 <annelies> also see the "measure!" part
01:55:14 <Maior> yep cheers
01:55:47 <lfairy> arossouw: what do you mean by that?
01:55:57 <arossouw> unfortunally not a genius programmer, took me 8 hours to get understand the workings of a recursive merge sort
01:56:29 <annelies> make it a distributed merge sort for extra funzors
01:56:32 <arossouw> lfairy: text flowing like mad, what did i say again
01:56:34 <levi> That's not terrible if you're new to recursive algorithms.
01:57:17 <arossouw> yes, recursion through me off a bit, different way of thinking
01:57:26 <nexx> annelies map the function or the data structure?
01:57:31 <annelies> data structure
01:57:37 <annelies> red-black tree
01:57:55 <nexx> ah
01:57:59 <annelies> it's benchmark of insert at random index
01:58:17 <companion_cube> why use red-black trees?
01:58:20 <annelies> vector is array
01:58:49 <arossouw> annelies: have you attempted distributed merge sort?
01:59:01 <annelies> nope
01:59:13 <annelies> only sum on three computers :P
01:59:20 <arossouw> :-)
01:59:20 <annelies> which was pretty fun to write
01:59:31 <annelies> and not fault-tolerant at all
02:00:25 <annelies> companion_cube if you want to keep order you cannot use a hash table
02:00:39 <companion_cube> annelies: just use AVL
02:00:42 <companion_cube> it's so much simpler
02:00:50 <annelies> is it more efficient?
02:00:57 <companion_cube> roughly as efficient
02:01:10 <companion_cube> and there are whole-collection operations
02:01:17 <annelies> no idea
02:01:33 <annelies> ask the people who implemented libc++ and libstdc++
02:01:34 <companion_cube> I've been discussing with people who wonder why red-black trees are so popular, given the headache they induce
02:01:45 <arossouw> i'm totally lost when it comes to graphs and strassen . etc
02:01:47 <lfairy> I think AA trees win on the simplicity front
02:02:01 <annelies> http://stackoverflow.com/questions/5288320/why-is-stdmap-implemented-as-red-black-tree
02:02:14 <companion_cube> lfairy: even for removal?
02:02:45 <annelies> even then, when you implement the C++ standard library, you're probably used to headaches anyway :)
02:03:00 <companion_cube> yes, I don't think that's a good comparison point
02:03:19 <companion_cube> especially since red-black trees are a bit different in an impure language
02:04:16 <annelies> I've never touched much of this stuff.
02:04:36 <companion_cube> but I'm pretty sure AVL are simpler than red-black trees ;)
02:04:49 <companion_cube> even Okasaki avoided describing removal from a red-black tree
02:04:58 <annelies> I just use whatever is labelled "map" or "dictionary" :P
02:05:44 <annelies> about 100% of the code I write can probably get away with a linked list of (key, value) pairs anyway
02:06:45 <companion_cube> sure, that's the point of abstraction
02:08:17 <annelies> the language I use doesn't even document the complexity of operations on associative arrays :v
02:09:05 <annelies> but what would you expect of PHP anyway :D
02:09:15 <companion_cube> :D
02:09:19 <companion_cube> complexity: terrible
02:09:57 <annelies> complexity: what is that?
02:11:53 <annelies> I wonder if optimizing compilers change the complexity class for cases other than TCO.
02:12:51 <companion_cube> they may avoid useless re-computations, so I guess it can happen
02:15:50 <lfairy> I remember one of the motivating examples for the monomorphism restriction ran in exponential time
02:16:13 <lfairy> specializing that (as the restriction did) would have made it linear instead
02:21:00 <narendraj9> Is there a book specifically on designing embedded domain specific languages in Haskell?
02:21:33 <Iceland_jack> Unfortunately not, mostly just paper
02:21:35 <Iceland_jack> *papers
02:21:57 <annelies> bundle the papers and you've got yourself a book
02:23:23 <narendraj9> Can you give me some links to those papers?
02:24:01 <mmmm> There's a list on the haskell wiki
02:24:25 <mmmm> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages
02:24:47 <Iceland_jack> narendraj9: You can look for any paper on Feldspar, a lot of papers by Conal, searching for 'embedded DSL Haskell' should give you plenty of good hits
02:25:04 <Iceland_jack> It really depends on how complicated your DSL is
02:25:29 <narendraj9> thanks :-)
02:25:30 <Iceland_jack> If you want to embed an optimizing compiler or just a small configuration or description language
02:26:00 <annelies> > maximum []
02:26:02 <lambdabot>  *Exception: Prelude.maximum: empty list
02:42:23 <Aleksejs> Hi, is there a fold with optional acc, like in clojure?
02:45:29 <hyPiRion> Aleksejs: foldl1 is the equivalent without acc, foldl is the one with acc
02:45:38 <hyPiRion> > foldl1 (+) [1..5]
02:45:39 <lambdabot>  15
02:45:48 <hyPiRion> > foldl (+) 1 [2..5]
02:45:49 <lambdabot>  15
02:45:54 <tdammers> problem with foldl: it's not total
02:46:00 <tdammers> *foldl1
02:46:03 <tdammers> > foldl1 []
02:46:05 <lambdabot>  Couldn't match expected type ‘a -> a -> a’ with actual type ‘[t0]’
02:46:11 <tdammers> > foldl1 (+) []
02:46:12 <lambdabot>  *Exception: Prelude.foldl1: empty list
02:48:32 <solatis> tdammers: that is totally reasonable, since 1 + Nil has no meaningful result
02:50:17 <Aleksejs> > foldl1 (++) ["a", "b"]
02:50:18 <lambdabot>  "ab"
02:52:55 <poucet> Had an interesting realisation today. It seems that the AI world is reinventing the wheel.
02:53:50 <mmmm> should "cabal configure --enable-executable-profiling; cabal build" build my executable with profiling?
02:54:06 <hyPiRion> poucet: oh, how come?
02:55:51 <tdammers> solatis: it is reasonable but unfortunate
03:19:50 <poucet> Re.
03:20:21 <poucet> So it seems that AI first has FSMs and nowadays Behavior tree is the new hotness. The goal is typically : "I have a game engine, I want to have a brain I can ask fo rthe next action, how do I write this cleanly"
03:20:41 <poucet> But if you look at what behavior trees are, they're basically like writing code in a continuation monad.
03:20:49 <poucet> I don't have the precise type yet, so apologies for inaccuracies
03:21:24 <poucet> I mean the concept of 'failed' or 'success' is not foreign to monads
03:21:31 <poucet> And the concept of 'running' really seems to beg for continuations
03:22:27 <poucet> I haven't dug far yet, but so far I'm thinking something like: data Behavior m a = Behavior { tick :: m (Result m a) }; data Result m a = Success a | Failure | Running (Behavior m a)
03:22:55 <poucet> I am not quite sure what the 'a' would be, and maybe I acn simplify this by folding 'Success a' and 'Failure' into the 'a' itself. But having them directly there maps more closely to behavior trees
03:23:31 <poucet> Basically that's saying: A behavior will run inside of a monad and return either a result or the next behavior to run.
03:24:28 <poucet> If you then look at the typical 'sequence' method, that sounds like like sequenceM_, while the typically 'choice' method sounds more like the flip-side of that.
03:24:42 <poucet> If we make it more generic Result m a = Result a | Running (Behavior m a)
03:24:59 <poucet> then we can simply say that behavior tree = Behavior (YourGameEngineMonad) Boolean
03:25:08 <shachaf> poucet: This is sounding a bit like FreeT
03:25:11 <poucet> and sequence becomes andM while choice becomes orM
03:25:24 <poucet> shachaf: linky?
03:25:46 <shachaf> What is that?
03:25:52 <poucet> Behavior trees also seem to use 'reset'. But if you just want to repeat a behavior, then just cycle it infinitely
03:25:59 <poucet> shachaf: Got a link to FreeT?
03:26:03 <shachaf> Oh.
03:26:09 <shachaf> http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Trans-Free.html
03:27:34 <poucet> What does it do ?
03:27:55 <shachaf> Lots of things.
03:28:16 <shachaf> Look up "free monad" for the general idea. I'm not sure of a particular article to point to.
03:28:22 <poucet> Also, how does one typically go from e.g. 'monoid' to 'monad.
03:28:28 <poucet> I'm wondering what a magmad would be
03:29:00 <shachaf> I don't think the naming scheme is that systematic.
03:30:19 <poucet> Ignoring naming, I read an article on 'magma' lately on haskell reddit, just wondering what the -ad equivalnt would be. I still haven't grokked how to go from one to the other. And the 'just endofunctors' explanation is a bit too categorical for me
03:30:48 <shachaf> I don't know that "-ad" means anything on its on.
03:31:00 <poucet> I guess I don't know either
03:31:06 <shachaf> That question is almost entirely a naming question. :-)
03:31:17 <shachaf> Or maybe an anti-naming question.
03:31:56 <shachaf> But at any rate if you avoid categorical explanations you won't get too far in answering questions like this.
03:33:45 <BartAdv> poucet: yeah, exactly my thoughts too...maybe if they start investigating haskell instead of c++...I bet they have crazy structures for those behaviour trees with humongous editors etc
03:39:01 * hackagebot aws-sdk-xml-unordered 0.3.1 - The xml parser for aws-sdk package  http://hackage.haskell.org/package/aws-sdk-xml-unordered-0.3.1 (ShoheiYasutake)
03:53:25 <Twey> Does OverloadedRecordFields exist in GHC 7.8.3?
03:54:03 * hackagebot yesod-bin 1.2.12.2 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.2 (MichaelSnoyman)
03:56:35 <BartAdv> Twey: nope
03:57:37 <Pythonfant> Twey: you need to wait for 7.10 :)
03:57:40 <Twey> Aww.  Thanks.  I thought I heard something about it coming in 7.8.
03:57:47 <Twey> Alright.
03:59:35 <BartAdv> what about ghc-head though:)?
04:00:10 <Twey> I'd rather not rely on HEAD in production :þ
04:01:31 <BartAdv> silly me, somehow it does not occure to me people are using haskell in production :S
04:01:40 <Maior> lol
04:02:14 <BartAdv> well, if you're sitting in enterprise C# shop where they fear even F#, then you might get such impression
04:11:33 <hpc> it still amazes me that a C# shop would fear other .net languages
04:26:18 <poucet> BartAdv: I know unity does
04:42:30 <tristanStrange>  /msg NickServ identify moleH1ll
04:42:57 <tristanStrange> uh oh looks like i need to change my password!
04:43:07 <r444> yep, oops
04:44:08 * hackagebot MFlow 0.4.5.7 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.7 (AlbertoCorona)
04:44:22 <tdammers> it was a shitty password anyway
04:44:56 <vozz> Reading this about doing BFS in Haskell using Data.Tree http://pragprog.com/magazines/2012-10/thinking-functionally-with-haskell How would I do this while making sure I don't expand states that already exist elsewhere in the statespace? I'm guessing I need a function like filter that also maintains a set of expanded states... anyone got any idea how to do that?
04:45:08 <r444> tdammers: i think you must suggest a new one after this statement
04:45:23 <tdammers> how about 9843fsahoiandoqjwlianfoH@E#hrefhsdoiuQOS*jfergoihtoirh
04:46:13 <hyPiRion> I've always been happy with hunter2
04:46:23 <tdammers> you mean *******?
04:46:40 <r444> tdammers: i like a93hfd7$8sJh38hdn38hkskjggjscbvznndowenUHFUEjdiejDFje
04:47:15 <r444> this "fsahoiandoq" bit doesn't really have much character :\
04:47:25 <faern> tristanStrange: Pro tip. Don't send those msgs from inside a channel.
04:48:24 <vozz> Ah, I think I've figured it out
04:49:14 <vozz> It's funny, sometimes just typing out a question and thinking through what exactly you're asking sometimes just leads you straight to the answer
04:49:20 <tdammers> pro-pro-tip: configure your IRC client to automatically send those messages after logging onto the server
04:50:13 <Maior> vozz: quack
04:50:39 <vozz> What?
04:51:01 <csierra> vozz: rubber duck
04:51:03 <Maior> vozz: https://en.wikipedia.org/wiki/Rubber_duck_debugging
04:51:37 <vozz> Haha
04:55:26 <t7> rubber duck as a service
04:56:52 <hodapp> wut.
04:58:20 <Heather> hi!
05:02:08 <jonathan1> Hi. I'm writing a program that stores a shitload of small strings (3-5 chars). Right now I'm doing this with ByteStrings, but I get a lot of pinned memory. What is the most memory effective way to be storing such strings?
05:02:29 <annelies> Why would you store strings of chars as bytestrings? :S
05:03:01 <jonathan1> annelies: I meant that to be read as "strings of 3-5 characters"
05:03:17 <annelies> bytestrings store bytes, not characters :v
05:03:41 <jonathan1> annelies: I store my characters as their byte-representation
05:04:10 * hackagebot spe 0.6.3 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.6.3 (AndersClaesson)
05:05:48 <tdammers> jonathan1: I guess the question is, why do you store your strings in byte-encoded form?
05:05:50 <annelies> Did you try to use just String instead of ByteString?
05:06:04 <tibell> I'm trying to work with DeBruijn indices and GADTs as described in http://www.cse.unsw.edu.au/~chak/haskell/term-conv/DeBruijn.hs, but I cannot convince GHC that once two variables have been shown equal (by comparing their indices), the type of the value they bind must also be the same. Any ideas?
05:06:21 <annelies> http://stackoverflow.com/questions/9398572/memory-efficient-strings-in-haskell#comment11884783_9404694
05:06:28 <annelies> Maybe that goes for your situation as well.
05:06:40 <jonathan1> tdammers: I assumed that it would be more space-efficient at some point, but now I'm not so sure
05:07:14 <tibell> jonathan1, Text is somewhat smaller
05:07:21 <jonathan1> annelies: I have not. Searching the net, it seems bytestrings would be the recommended way
05:07:25 <tibell> jonathan1, if you're indeed dealing with Unicode text
05:07:50 <tibell> jonathan1, http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
05:07:58 <jonathan1> tibell: I am. I'll try that I guess :)
05:08:03 <annelies> Try String, ByteString and Text and profile all of them.
05:08:21 <annelies> With -O2
05:08:49 <tibell> jonathan1, there's also the not some commonly used http://hackage.haskell.org/package/smallstring
05:09:30 <tibell> jonathan1, we are adding a SmallByteString and a SmallText to the bytestring and text packages respectively, for e.g. when you have lots of small strings as keys in a map, but those changes haven't been released yet.
05:10:26 <tibell> jonathan1, I believe SmallString is 3 words + N bytes (where the bytes are UTF-8 encoded)
05:10:29 <jonathan1> Lots of suggestions :) It'll take me the whole day to try them all out
05:11:09 <tdammers> hmm, transparent utf-8 encoded strings would be nice
05:11:34 <tdammers> different space/time tradeoff than Text
05:11:42 <alpounet> tibell: ah, when are these small string types landing?
05:11:55 <tibell> alpounet, dcoutts is working on the bytestring one
05:12:02 <tibell> alpounet, I haven't had time to start on the Text one
05:13:00 <alpounet> ok, I have the time to see them coming :p
05:21:46 <annelies> how do those work?
05:21:47 <annelies> SSO?
05:24:13 * hackagebot network-metrics 0.4 - Send metrics to Ganglia, Graphite, and statsd.  http://hackage.haskell.org/package/network-metrics-0.4 (BrendanHay)
05:24:15 * hackagebot hopenpgp-tools 0.8.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.8.1 (ClintAdams)
05:27:45 <alpounet> annelies: the small strings?
05:27:58 <annelies> yeah
05:32:15 <alpounet> annelies: you can get an idea here https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Short.html although the version dcoutts is working on these days may be different, I'm not sure
05:50:40 <Pythonfant> I think I understood the very basics of rankntypes with the forall keyword but I don't quite understand why I need it for the type alias type Lens s a = Functor f => (a -> f a) -> s -> f s ?
05:54:12 <edwardk> where is the 'f' on the left of the = ?
05:54:30 <edwardk> that needs an explicit quantifier
05:55:14 <edwardk> without it, ghc maybe should let you apply that type alias only in strictly positive position and not require rank-n, but it doesn't track that stuff
05:56:11 <Pythonfant> sorry I couldn't quite follow you
05:57:05 <annelies> yeah
05:57:20 <Pythonfant> so lens has kind * -> * -> * is that the f you are referring to?
05:57:36 <edwardk> type Lens s a = Functor f => (a -> f a) -> s -> f s
05:57:43 <edwardk> that is really type Lens s a = forall f. Functor f => (a -> f a) -> s -> f s
05:58:11 <edwardk> Haskell traditionally doesn't bring in the forall keyword. that was an addition
05:58:31 <Pythonfant> ah because the functor needs to work with a and s?
05:58:48 <edwardk> because the type synonym lens doesn't mention f in its set of variables
05:59:08 <edwardk> if it was something like type LensLike f s a = (a -> f s) -> s -> f s -- then you might be good
05:59:21 <edwardk> that is first rank and everything is fine
05:59:35 <edwardk> but it avoids the encapsulation that makes lens go
05:59:51 <Algebr> General compilers question. It is known that a switch statement in C ends up being a branch table in the generated assembly, when the cases are "dense", but what happens when the cases are not "dense" or rather, how does the compiler decide that?
06:00:01 <Pythonfant> ah ok, thx edwardk, I think I got it now
06:00:07 <edwardk> now ghc classifies a lot of things that are really 'rank-1' as 'rank-2' when it can't be bothered to check
06:00:24 <edwardk> e.g. if you took that alias with the explicit forall and put it on the right hand side of :: alone the result is really rank-1.
06:00:35 <edwardk> if you returned one after several arguments, the result is really rank-1
06:01:02 <edwardk> but its easier for ghc to look at that type, flag it as rank-n, and require the flag regardless of use site.
06:01:09 <edwardk> ut that is a more nuanced issue
06:02:28 <idiotbox> How do I compose the two functions a -> b -> c -> d and d -> IO e to a -> b -> c -> IO e in point-free style?
06:04:00 <annelies> f . g where { f :: a -> b -> c -> d; g :: IO e }
06:04:20 <annelies> oh wait no multiple arguments
06:04:23 <annelies> I GIVE UP
06:04:32 <idiotbox> exactly :D
06:04:44 <Pythonfant> ((f .) .) . g
06:04:52 <annelies> tripple boob operator perhaps?
06:05:05 <vanila> :t \(f :: a -> b -> c -> d) (g :: d -> IO e) -> (\a b c -> g (f a b c)) :: a -> b -> c -> IO e)
06:05:07 <lambdabot> parse error on input ‘)’
06:05:18 <jle`> @pl \f g x y z -> g (f x y z)
06:05:19 <lambdabot> flip ((.) . (.) . (.))
06:05:19 <annelies> You need a language extension for that
06:05:29 <annelies> :D told ya
06:05:32 <vanila> :t \(f :: a -> b -> c -> d) (g :: d -> IO e) -> ((\a b c -> g (f a b c)) :: a -> b -> c -> IO e)
06:05:33 <lambdabot> (a -> b -> c -> d) -> (d -> IO e) -> a -> b -> c -> IO e
06:05:43 <frerich> annelies: Yes, you compose 'f :: a -> b -> c -> d' and 'g :: a -> IO b' using 'g .:. f'
06:05:46 <k_bx> Hi everybody! Do you know is there an analog of `safe` library for vectors instead of lists?
06:05:57 <jle`> why do you want the point free form? just curious
06:06:25 <idiotbox> somehow typing all the arguments seemed ugly, but after what I've seen now... :P
06:06:30 <k_bx> Oh, sorry, I think Data.Vector has all the needed things. Let me check.
06:06:34 <annelies> k_bx if only those all functions were generic :(
06:06:38 <annelies> all those*
06:09:18 * hackagebot yesod-form 1.3.15 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.15 (MichaelSnoyman)
06:10:10 <annelies> > pure (,,,,,,,,,,)
06:10:12 <lambdabot>  No instance for (GHC.Show.Show
06:10:13 <lambdabot>                     (f0 (a0
06:10:13 <lambdabot>                          -> b0
06:10:13 <lambdabot>                          -> c0
06:10:13 <lambdabot>                          -> d0
06:12:01 <k_bx> / sorry, actually vector doesn't even have safeHead or similar, weird
06:14:06 <annelies> https://gist.github.com/rightfold/20f27c1abafc3515b6d7 fixed!
06:22:16 <pointed_set> > let f x = (x, x) in f $ f $ f $ f $ f $ f $ f ()
06:22:18 <lambdabot>  ((((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),()...
06:23:08 <idiotbox> Couldn't match type 'bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString' with 'Data.ByteString.Lazy.ByteString' - what's this?
06:23:22 <pointed_set> k_bx: in agda it does.
06:23:47 <k_bx> pointed_set: it's simple to write, I was just surprised it's not there
06:24:56 <k_bx> Actually, don't know if it's simple to write with all the race-safety (seems doing "!? 0" is the only option).
06:26:47 <ion> _head and _tail are defined for Vector in lens.
06:33:34 <tsahyt> Why does strict-concurrency not compile anymore? Is it not maintained anymore?
06:35:16 <cies> Hi all!  Quick cabal question: I have a sandbox with a in-development package add-source'ed. I change both packages equally often, but when I change the add-source'ed package i have to bump its version number in both cabal files in order to trigger recompilation... It's a bit cumbersome; is there a quicker way (work around) to do this?
06:36:12 <cies> Sorry if my question is not clearly put.
06:48:46 <Ankhers> tsahyt: That library hasn't been updated in over four years.
06:49:23 * hackagebot gitson 0.2.0 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.2.0 (myfreeweb)
06:51:01 <tsahyt> Ankhers: Any alternatives that are maintained?
06:54:58 <Laquendi> cies: does 'cabal install foo --constraint=bar==1.0' help you? that probably isn't much easier tho
06:58:27 <cies> Laquendi: not _much_ easier, but a good start i guess.. thanks
06:58:52 <Ankhers> tsahyt: I can't say with any authority. I'm still relatively new to Haskell myself. Though, I think the standard is stm. I don't know about the strictness aspect though.
07:00:02 <tsahyt> i don't think STM is applicable for what I'm trying to do though. Sometimes laziness can be really annoying.
07:00:18 <cies> Laquendi: maybe removing somthing out of the .cabal-sanbox dir that triggers a recompile of the add-source'ed package is a way to go..
07:00:34 <tippenein> tsahyt: http://hackage.haskell.org/package/strict-concurrency-0.2.4.1/docs/Control-Concurrent-MVar-Strict.html
07:05:15 <fizbin> I'm trying to use Debug.Trace to figure out where my program is blowing up from exceeding stack space.
07:05:54 <fizbin> I suspect that I've got something held unevaluated until the last second.
07:06:10 <fizbin> Thing is, I can't figure out what.
07:06:15 <tsahyt> tippenein: That's the package I was asking about earlier. It doesn't compile here.
07:08:11 <tsahyt> It cannot find Control.OldException, which should have been in base, but has apparently been removed in the meanwhile
07:08:21 <Twey> fizbin: I don't think Debug.Trace will help you there.
07:09:08 <pqmodn_> fizbin: i would look into heap profiling, but i haven't used it before so i can't help much
07:09:14 <Twey> fizbin: There are some tools like vacuum for visualizing this sort of thing
07:09:23 <tsahyt> huh.. Apparently my problem actually lies with GTK. The command line version of my program works as expected.
07:09:39 <Twey> fizbin: GHCi's built-in debugging tools are alright, too
07:09:52 <fizbin> Well, if I get a Debug.Trace message before the program blows up, does that mean that the val in (trace msg val) was evaluated before blowing up, or that evaluating that is what caused the blow up?
07:10:02 <fizbin> Thing is, in ghci this runs fine.
07:10:34 <supki> ghci probably has higher stack limit
07:10:37 <Twey> fizbin: But you can use GHCi's :print command to see how much of a value is evaluated at a particular point, which may help clear up your confusion
07:10:42 <fizbin> And the stuff on debugging "out of heap" errors with +RTS -xc all show examples where you get an actual decent stack trace.
07:11:23 <fizbin> And when I try it, I get a stack trace of just MAIN.MAIN
07:11:29 <fizbin> Not helpful
07:12:44 <pqmodn_> fizbin, i think if you see a trace message, you only know it was evaluated. the program could have crashed sometime after printing the trace, but while doing something else
07:12:46 <Twey> fizbin: If ‘trace msg val’ prints msg then val gets forced to WHNF at that point, is all you know
07:13:08 <Twey> Notably, you *don't* know that it doesn't still contain a huge thunk under a constructor somewhere
07:13:25 <fizbin> Hrm.
07:13:29 <Twey> I really think :print would be more useful.
07:14:05 <Twey> Or some kind of static reasoning technique, like Heinrich's space invariants
07:14:18 <pqmodn_> does one of the profiling tools show "who" is allocating heap space? for instance could you see 500 thunks were allocated in a certain part of the program?
07:14:28 <Twey> http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html
07:14:43 <tsahyt> Okay, laziness isn't annoying. It's just threads that are annoying, but I knew that already. It works now :)
07:14:50 <fizbin> The issue is that it's blowing up inside this recursive function just as it winds down towards the answer.
07:14:59 <Twey> pqmodn_: Yes, the built-in GHC profiling stuff does, I think: https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/profiling.html
07:15:14 <pqmodn_> thanks, Twey
07:15:38 <fizbin> And forcing everything with liberal (excessive) use of `seq` doesn't change the observed behavior.
07:16:02 <fizbin> So I can't really think that there's anything left anywhere to be thunked.
07:16:09 <tibell> edwardk, around?
07:16:16 * tibell tries to channel edwardk's wisdom
07:16:17 <pqmodn_> fizbin, one thing to note is seq only evaluates until it hits a constructor (like Twey said). the data wrapped in the constructor could remain unevaluated
07:16:28 <tibbe> edwardk, ^^
07:16:28 <adimit> interesting. When I used ghci's :print function, it gave me "x = (_t4::…)" Then I wanted to evaluate _t4, and I got a ghc panic. It seems GHC doesn't want you to evaluate these terms?
07:16:31 <edwardk> tibbe what's up?
07:16:45 <tibbe> edwardk, I'm fighting with GADTs and Debruijn and need some spiritual advice
07:16:56 <tibbe> edwardk, in particular I'm trying to use http://www.cas.mcmaster.ca/~anand/DSL2011/DeBruijn_simple.hs
07:17:10 <Twey> adimit: Well, panics aren't supposed to happen.  ☺
07:17:15 <edwardk> er, why? =)
07:17:30 <tibbe> edwardk, it's a long story, consider it a step toward enlightenment
07:17:35 <edwardk> that sort of hell is why i have bound ;)
07:17:53 <edwardk> Bound, abstract, instantiate, done ;)
07:17:54 <tibbe> edwardk, but I want to pattern match on two expressions e1 and e2 if they're both the same Var
07:18:00 <danilo2> Hello! Is it ok, that when using -XIncoherentInstances GHC matches wrong instance (more general one) even if less general is available? I'm talking about a situation, where disabling -XIncoherentInstances and enabling -XOverlappingInstances allow the program to compile (so IncoherentInstances are breaking thuings here I think) - should it be considered a bug ?
07:18:14 <adimit> Twey: correct. So is the fact that one can type in these unevaluated terms (thunks?) into ghci prompts and cause a panic a bug?
07:18:25 <adimit> Or is it "to be expected?"
07:18:43 <tibbe> edwardk, I want to rewrite something like: let xs = ... in .... map f xs .... map g xs .... to let xs = ... in map2 ( \ x -> (f x, g x)) xs
07:18:53 <tibbe> edwardk, so some kind of tupling transform
07:18:59 <edwardk> tibbe: *nods*
07:19:00 <Twey> adimit: I'd think that's a bug
07:19:22 <tibbe> edwardk, but if I try to pattern match on (Map .. (Var v1)) (Map .. (Var v2)) | v1 `varEq` v2 = ...
07:19:26 * hackagebot gitson 0.2.1 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.2.1 (myfreeweb)
07:19:40 <tibbe> edwardk, I cannot convince the type system that these are the same Vars, even if the indices match
07:19:50 <tibbe> edwardk, I need to somehow convince GHC that the type envs are the same
07:19:55 <tibbe> edwardk, and that I don't know how to do
07:20:02 <adimit> Twey: it just seems like something that should've been caught already by someone much smarter than me…
07:20:17 <edwardk> what does your Map and Let look like?
07:20:55 <tibbe> edwardk, in progress code: http://lpaste.net/108913
07:21:03 <Twey> adimit: I think GHCi doesn't get as much priority as some other parts of GHC.  But maybe it's already been reported and/or fixed in a newer version?
07:21:05 <tibbe> edwardk, I'm actually using concatMap as it's a bit more general
07:21:26 <tibbe> edwardk, I need to add a Let and I expect that perhaps that's what will serve as proof that the type envs are the same
07:22:34 <tibbe> edwardk, I think I understand what I have now is wrong, my variables are free and not necessarily bound to the same thing
07:22:41 <edwardk> yeah
07:23:12 <edwardk> my usual approach is to not bake in the env, and instead use bound to manage the context then its much easier for me to line things up
07:23:12 <tibbe> edwardk, will it just work if I figure out Let?
07:23:29 <tibbe> edwardk, (pattern matching will also be difficult, as the two maps can be far from each other in the AST)
07:24:01 <tibbe> edwardk, bound might be were I'm headed eventually, but I want to understand how this works first. That will also help me use any library solution.
07:24:46 <adimit> Twey: I'll donwnload 7.8.3. (I'm on 7.8.0) and see if it persists.
07:24:53 <Twey> ‘Making de Bruijn suck less’ — nice
07:24:58 <pqmodn_> succ :)
07:25:05 <Twey> Er, yes.  Mental autocorrect
07:25:05 <ion> Given operations fooNew :: IO Foo, fooClone :: Foo -> IO Foo and fooCompute :: Foo -> Input -> IO Output which mutates something Foo points to, and given that you can provide a pure API using unsafePerformIO and cloning the value every time, and given that said pure API can avoid a clone using RULES when it’s clear the intermediate Foo value would be thrown away, is there a package that provides a class or
07:25:06 <edwardk> the trick you have is you need to know that your Ix is only in the common env
07:25:07 <ion> something that gives you a convenient way to implement that pure wrapper?
07:25:19 <Twey> adimit: Well, I'd search for your bug on the tracker first/as well
07:25:33 <Twey> Of course, upgrading's always good ☺
07:26:18 <edwardk> that said the bound solution by default won't give you a typed ast, so maybe this is better for your purposes
07:28:17 <adimit> Twey: I'm on it. It seems that what I'm trying to do actually should work. Sort of. Sometimes. So that definitely seems to be a bug.
07:30:00 <ibotty> hi, i was wondering why there is no function (a->b) -> [a] -> [(a,b)] in base somewhere
07:30:05 <ibotty> is it too trivial?
07:30:38 <supki> :t map . (ap (,))
07:30:39 <Twey> ibotty: map . (id &&&)
07:30:39 <lambdabot> (a -> a1) -> [a] -> [(a, a1)]
07:30:53 <adimit> ibotty: yes. you just need a function (a -> b) -> a -> (a,b) and use that as your mapping function :-)
07:30:55 <Twey> Or that ☺
07:31:04 <Rarrikins> ibotty: zip xs (map f xs)
07:31:13 <Twey> :t map . ap (,)
07:31:14 <lambdabot> (a -> a1) -> [a] -> [(a, a1)]
07:31:20 <Twey> (no bracketing required)
07:31:24 <tibbe> edwardk, by common env do you mean a top-level env or just the env shared (and extended by) the Let?
07:31:30 <ibotty> supki: that's nice.
07:31:32 <eacameron> I want to write some modules in Haskell to use in a massive C++ project, where should I start reading for building/linking HS into my C++ app+
07:31:32 <eacameron> ?
07:31:55 <ibotty> i knew about arrow and explicit zipping. but that's not that elegant.
07:32:18 <edwardk> i mean you have variables that index into the env, if one is under a lambda or something the env is bigger, so the ix into it in your var can be bigger. now if the other is under another lambda they can be referencing different local variable bindings
07:32:28 <Twey> eacameron: You'll need to go through the C ABI, http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:32:46 <edwardk> so you need to fuse under lambdas only where both are under the same lambdas is all
07:33:06 <adimit> Twey: It's #9046, and it only occurs if _tn have bounded polymorphic types. There was a patch 4 weeks ago, but I don't know the current status.
07:33:22 <adimit> anyway, thanks for holding my hand.
07:33:28 <Twey> adimit: Great!  No problem.  ☺
07:33:56 <eacameron> Twey, does this also work if my Haskell module uses IO?
07:34:03 <Twey> adimit: As a general rule, panics are things that shouldn't happen.  If you see a panic and you haven't been doing anything like overwriting GHC's internal memory, you've probably found a bug
07:34:32 <adimit> poor GHC. Why would anyone want to overwrite its internal memory?
07:34:40 <Twey> eacameron: I think IO just goes away when you export to C
07:34:54 <tibbe> edwardk, that's annoying, there might (legitimately) be intermediate lambdas
07:34:57 <adimit> … yeah, i was confused. But it seems the patch just created a test case. There is still no solution.
07:35:13 * tibbe is fighting hard to not throw out the GADT AST in favor of an untyped one.
07:36:42 <tibbe> edwardk, I suspect I need to give up on the GADT eventually anyway because I suspect that the tupling/sibling fusion I'm implementing can't be written as a fold but needs to be written as some kind of graph traversal and I don't think I can type the graph representation.
07:36:57 <edwardk> fair nuff
07:37:28 <tibbe> edwardk, I feel like I'm at the very edge of how far research have come in this area.
07:37:45 <tibbe> edwardk, so unless I think I can push the envelope I should do something less advanced.
07:37:46 <edwardk> well, its just a matter of picking a nice representation
07:38:15 <tibbe> I think I will go with an untyped ast and once I have algorithms down see if someone can figure out a way to type it.
07:39:34 <tibbe> edwardk, it's a bit frustrating that I know how to do this in an imperative setting but not in a functional one. :/
07:40:06 <tibbe> edwardk, in an imperative setting you can do this kind of sibling fusion by *starting* at the variables and rewrite their users
07:40:15 <tibbe> edwardk, instead of traversing the other way around, like you would in a fold
07:42:34 <eacameron> Twey: excellent, I need an escape from C++ badly ;)
07:43:06 <Twey> Heheh.
07:43:18 <edwardk> you can do what you want functionally, but you've made two choices that make it hard. GADTing the type and using debruijn. the rapier can work nicely, bound can work nicely, both work easier with an untyped EDSL, etc.
07:44:20 <Twey> edwardk: Rapier?
07:44:42 <edwardk> Twey: http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/
07:44:53 <Twey> Thanks!
07:45:58 <edwardk> ok, at home sick, meds kicking in, sleep time now.
07:59:31 * hackagebot pub 1.0.0 - Pipe stdin to a redis pub/sub channel  http://hackage.haskell.org/package/pub-1.0.0 (ParnellSpringmeyer)
08:00:52 <eacameron> now that edwardk left, there isn't much reason to keep talking I guess ;)
08:04:32 * hackagebot pub 1.0.1 - Pipe stdin to a redis pub/sub channel  http://hackage.haskell.org/package/pub-1.0.1 (ParnellSpringmeyer)
08:09:10 <vlatkoB> Is there a nicer way to write this? http://lpaste.net/108917
08:15:27 <dreams> Lazy functional programs are side-effect free, a statement that I've been reading a lot in papers. OK, but what about IO actions? It seems like they're abandoned or something.
08:15:58 <Ankhers> dreams: IO isn't pure. pure code is side-effect free.
08:16:37 <ChristianS> dreams: without any IO, your lazy functional program would be pretty useless
08:17:10 <ion> IO actions are first-class pure values that just represent IO actions you can choose to have executed by the runtime system.
08:18:29 <dreams> So the right statement should be: Pure lazy functional programs are side-effect free.
08:18:31 <supki> :t \f -> fmap (undefined :: Either a b -> Maybe b) ((liftA2.liftA2) (,) (f 1) (f 2))
08:18:33 <lambdabot> (Applicative f, Num a1) => (a1 -> f (Either a b)) -> f (Maybe (b, b))
08:18:41 <supki> vlatkoB: something like that? ^
08:18:52 <Cale> dreams: Evaluation in Haskell is effect-free.
08:18:57 <Cale> dreams: (mostly)
08:19:05 <Cale> dreams: But execution of IO actions isn't.
08:19:28 <Cale> Evaluation and execution are two separate but interleaved processes which take place while a Haskell program runs.
08:19:34 <ion> Haskell IO doesn’t have side-effects (modulo unmentionablePerformIO), it has effects.
08:19:50 <Cale> Evaluation means turning expressions into values, ultimately for the purposes of pattern matching.
08:20:05 <Cale> Execution means carrying out the instructions that IO action values specify.
08:21:19 <vlatkoB> supki: It doesn't compile, but that is in a way of what I was looking for. Thanks.
08:22:14 <Cale> For example, when you evaluate the expression (putStrLn "Hello") nothing visible will happen. Something internal will take place to work out which IO action this is, making your CPU slightly warmer, but since IO is an abstract type, you can't even directly pattern match on the result.
08:22:52 <vlatkoB> supki: It compiles when given signature.
08:22:52 <Cale> When the resulting action is executed though, the string "Hello" will be written to the terminal.
08:22:54 <guesting> I just finished profiling a big program with big data. I'm spending pretty much ALL of my time and ALL of my memory in "unstreamChunks/inner" from "Data.Text.Lazy.Fusion". What does this mean? What process is this so I can optimize it?
08:23:07 <dreams> Cale: putStrLn is not pure is it? its has side-effects.
08:23:28 <ion> > putStrLn "Hello"
08:23:30 <lambdabot>  <IO ()>
08:23:30 <Cale> dreams: The execution of the actions that it results in have effects.
08:23:37 <ion> No side effects occurred.
08:23:59 <ion> > putStrLn "Hello" `seq` 42
08:24:00 <Cale> dreams: But evaluating the function doesn't have effects, it just constructs an action for printing stuff on the screen without actually doing that.
08:24:01 <lambdabot>  42
08:24:34 <dreams> so what you're basically saying is that IO evaluation is pure, but its execution is not.
08:24:34 <Cale> Without actually printing anything, I should say, to be clear
08:24:53 <Cale> Yeah, evaluation of essentially all expressions is pure. Execution of IO actions isn't.
08:25:25 <Cale> There are low-level hacks with which you can make effects happen during evaluation, but they're not the sort of thing you want to mess around with on a daily basis.
08:25:39 <dreams> Cale: but when you evaluate an IO action, it will trigger that execution, which makes it not pure.
08:25:45 <Cale> NO!
08:25:49 <ion> It will not.
08:25:54 <Cale> Evaluation does not cause execution to occur.
08:26:08 <ion> See ‘putStrLn "Hello" `seq` 42’ above.
08:26:39 <dreams> Cale: what does then?
08:26:51 <Cale> dreams: Any more than opening an executable program in a hex editor would cause that program to run, for instance.
08:26:52 <dreams> ion: erm, not really familiar with how seq works.
08:26:56 <c_wraith> dreams: ultimately, the RTS when it executes main
08:27:22 <Cale> dreams: Yeah, in a compiled Haskell program, main gets executed, and it in turn may execute other IO actions that it has been built from.
08:27:58 <Cale> dreams: Alternately, you can execute an IO action by giving one to GHCi
08:28:31 <ion> dreams: It just made sure putStrLn "Hello" was also evaluated when evaluating the 42.
08:28:59 <hodapp> Cale: can one evaluate without executing?
08:29:08 <dreams> ion: I just noticed that, why it didn't print Hello?
08:29:15 <Cale> hodapp: In principle, yeah
08:29:31 <hodapp> Cale: but no implementation would permit this?
08:29:33 <ion> dreams: Because it just generated an abstract value representing the action of printing the string and did not execute it.
08:29:45 <c_wraith> hodapp: however, it's true that in a haskell application, evaluation is driven by the needs of execution
08:29:48 <Cale> hodapp: But you typically want to be able to see the result
08:30:05 <Cale> hodapp: Which will involve executing some action for printing that stuff on the screen
08:30:11 <dreams> ok, thanks all. I'll get my head over it one day hopefully.
08:30:15 <Rarrikins> dreams: Check out http://blog.jle.im/entry/first-class-statements
08:30:30 <Rarrikins> dreams: It goes over this topic as well.
08:30:38 <Cale> hodapp: Evaluation won't do much other than making your CPU hotter and shuffling some stuff around in memory that you can't otherwise see.
08:30:53 <ion> > "#!/bin/sh\necho Hello" `seq` 42  -- did not execute anything that prints Hello either.
08:30:55 <lambdabot>  42
08:31:17 <ion> I can choose to have an IO action executed by assigning it to main. I can choose to have an sh script executed by passing it to a sh process.
08:31:23 <Cale> dreams: getLine :: IO String doesn't contain a String any more than /bin/ls contains a list of files
08:31:24 <dreams> Rarrikins: ok thanks.
08:31:25 <ion> Evaluation does not imply execution.
08:32:20 <Cale> dreams: A value of type IO t is a description of some process which if it finishes will result in a value of type t, and which can cause your computer to do anything it could normally do when executed.
08:32:56 <dreams> I see.
08:33:07 <Cale> dreams: Evaluating an expression of that type will simply work out which value that is, i.e. which process, without actually causing any of its steps to be taken.
08:33:46 <dreams> So it just identify what to do, but does not do it.
08:33:47 <c_wraith> > undefined `seq` print 5
08:33:48 <lambdabot>  <IO ()>
08:34:01 <Cale> yes
08:34:22 <c_wraith> heh.  Right, Typeable instances don't inspect their argument - and apparently the Show instance for IO in lambdabot doesn't either.
08:34:22 <Cale> c_wraith: heh, that's interesting
08:34:28 <Cale> right
08:34:34 <dreams> alright, its more clear now. Thanks.
08:35:13 <Cale> > (undefined :: IO String) `seq` 0
08:35:15 <lambdabot>  *Exception: Prelude.undefined
08:35:24 <ion> dreams: This may or may not be helpful. https://gist.github.com/ion1/7154691
08:39:59 <tibbe> Any GADT/DSL experts around? http://stackoverflow.com/questions/25164544/equality-of-de-bruijn-indexed-variables-in-a-gadt
08:44:37 * hackagebot sloane 1.9.1 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-1.9.1 (AndersClaesson)
08:45:53 <danilo2> Hello! Is there any way to use "forall" in instance head? I want to do something like "instance AppMonadCtx2 (MonadCtx env set m a) (forall req. Req req (MonadCtx env set m) a) where [...]"
08:46:24 <danilo2> where class AppMonadCtx2 a b has fundep between a and b
08:47:31 <c_wraith> danilo2: isn't that the same as if there was no forall?
08:47:49 <c_wraith> danilo2: free variables in instance heads are already universally quantified
08:49:01 <danilo2> c_wraith: I want rankNTypes there - look, If I've got fundeps in the class (class AppMonadCtx2 a b | a -> b where[...]), I cannot write instance like I showed before, because of Liberage Coverage condition
08:49:08 <danilo2> *liberal
08:49:12 <enthropy> c_wraith: if you had "class AppMonadCtx2 x y where f :: x -> y", I'm guessing the forall in there would end up giving you rank 2 type
08:49:35 <danilo2> enthropy: I want to have rank2type there
08:50:12 <c_wraith> ah.  Why not put the rank 2 type in the class definition?  Or do you only want it on some instances?
08:50:24 <c_wraith> If the latter, then it's going to be problematic
08:51:46 <danilo2> c_wraith: I want it oonly on few ones
08:51:57 <enthropy> maybe you can split it up like:   class AppMonadCtx2 x y where f :: x -> (forall req. MkReq req y); type family MkReq req y; type instance MkReq req (MonadCtx env set m) = Req req (MonadCtx env set m)
08:52:24 <c_wraith> yeah, I can't see a way to do it without associated types
08:52:54 <danilo2> c_wraith: oh, what are associated types? Does haskell have them? I've never heard about them
08:53:07 <c_wraith> associated types are type families as part of a class
08:53:11 <enthropy> just another name for -XTypeFamilies
08:53:59 <c_wraith> specifically, what they're associated with is the class. :)
08:54:26 <enthropy> probably the second class involved can also be a MPTC
08:54:26 <danilo2> c_wraith, enthropy: ahh, good to know that name :) How can we do it using associated types? Maybe I'll show ou why I need it here. So I want the following instances to exist: http://lpaste.net/108919 . and the fundep is important there
08:56:00 <danilo2> c_wraith, enthropy: as you can see ,only the first and third instance needs rankNTypes and its important, that the "req" variable is used in the thirsd instance elsewhere
08:58:19 <danilo2> c_wraith, enthropy: anyway, how can we use type families here?
08:58:43 <enthropy> danilo2: all the instances seem to have Req req in the result type though
08:59:15 <enthropy> danilo2: anyways, I think the "type family MkReq" above is probably going to do?
08:59:19 <c_wraith> danilo2: sorry, gotta jump out of this conversation.  offline world calls to me.
08:59:37 <danilo2> enthropy: yes, they've got it, but the second and third one mentions "req" variable in other places, so we cannot throw it away. Maybe I'm missing a solution here?
09:00:18 <danilo2> enthropy: Ah I overlooked your message
09:00:26 <danilo2> c_wraith: ok, thank you very much
09:00:53 <danilo2> enthropy: I'll test it, brb
09:02:40 <enthropy> danilo2: I don't think you need appMonadCtx2 to have a rank2 type for the second instance
09:02:41 <jkarni> tibbe: I don't really see how you expect it to work
09:02:51 <danilo2> enthropy: ah I see it, but it deos not work. Look - you've thrown "forall req" inside of class declaration. So I cannot write any instance, which would mention the "req" type variable anywhere (we would get amboigous types) - like in the second instance I've posted before
09:03:02 <jkarni> tibbe: you're asking the compiler to do value-level reasoning for type-checking
09:03:08 <danilo2> enthropy: exactly - for the second I do not need it
09:04:18 <danilo2> enthropy: using your solution we cannot write the third instance also (look, there is: set~Insert req Empty) - and we do no thave access to "req" type variable while defining this instance
09:05:07 <enthropy> the second instance can use     type instance MkRec _unused (Req req (MonadCtx env set m) a) = (Req req (MonadCtx env set m) a)
09:05:23 <jkarni> tibbe: it may be that if you add another type parameter to Dist to keep track of what a was in the ConcatMap constructor you could write fuse
09:05:34 <jkarni> tibbe: but that makes it uglier...
09:06:50 <danilo2> enthropy: ahh I see it! Maybe its gonna to work, brb :) Thanks! :)
09:08:02 <enthropy> danilo2: then maybe something like     class AppMonadCtx2 x y where f :: x -> (forall req z. C req y z => z);  type family C req y z :: Constraint; type instance C req (MonadCtx set) z = (z ~ Req req (MonadCtx set), set ~ Insert req Empty)
09:08:06 <hexagoxel> what do you call a parameter where you are only interested in the type, not the value (example: the second parameter of asTypeOf)?
09:08:22 <enthropy> hexagoxel: proxy (there's a Data.Proxy)
09:10:24 <hexagoxel> enthropy: ah, thanks
09:10:44 <tibbe> jkarni, I realize that the code as stated is wrong, but on the other hand we must be able to convince that two De Bruijn indices are the same when they are, otherwise using them will be quite hard.
09:11:40 <tibbe> jkarni, we need to someone propagate the value level checking we did to the type checker
09:11:44 <enthropy> danilo2: but I think the version without ConstraintKinds will work out better (ghc can't conclude  (forall req1 z1. C req1 y1 z1 => z1) ~ (forall req2 z2. C req2 y2 z2 => z2)  given y1~y2)
09:12:24 <danilo2> enthropy: both versions ddoes not compile. Both give errors like "Could not deduce (C req0 y z)" - GHC does not unifies req with the second req
09:12:59 <jkarni> tibbe: like a type function?
09:13:06 <danilo2> enthropy: maybe I will make a minimal working example? If of course you will agree to look into it :)
09:13:16 <enthropy> danilo2: sure
09:13:29 <tibbe> jkarni, I don't know
09:13:30 <jkarni> tibbe: but you would then *also* need to keep that information somewhere in Dist
09:14:11 <tibbe> jkarni, so my thinking was that if we add a Let and pattern match on that, it can serve as a witness that the two Vars bound by that Let have the same type environment and are thus interchangable.
09:16:49 <tibbe> jkarni, I added the actual type error to the SO post, might make the question a bit more accessible.
09:17:18 <hexagoxel> i think Proxy is my new favourite Monad :D
09:20:55 <jkarni> tibbe: http://lpaste.net/108921
09:20:59 <jkarni> tibbe: that typechecks - don'
09:21:07 <jkarni> tibbe: t know if it's correct ...
09:21:22 <jkarni> tibbe: well, it isn't
09:21:32 <jkarni> tibbe: since it just covers (a ~ None), I guess
09:21:52 <danilo2> enthropy: ok, here it is: http://lpaste.net/108920 . The code works (but uses -XDysfunctionalDependencies to lift the liberal coverage condition) - this is an small extension to ghc written by me (and maybe it will be included). Anyway I want to know how to write it without it. When wee drop the fundeps, we cannot make function "tst" compile (which is obvious).
09:22:25 <jkarni> tibbe: I imagine *a* solution lies around this neighborhood, but i'm not sure it's the best one
09:22:40 <tibbe> jkarni, after stripping of all the Succs v point to the wrong variable
09:22:46 <tibbe> jkarni, yeah, I think you're close
09:24:29 <Qfwfq> Not sure how to instance Read for (forall a. Read a => a), pointers welcome. http://lpaste.net/500415431455014912
09:25:04 <jkarni> tibbe: got to go, but if I come up with an answer I'll post it on SO
09:26:14 <tibbe> jkarni, thanks
09:26:50 <Qfwfq> I'm thinking something like 'fmap (fmap (bimap Readable id)) . readsPrec' should work, but it doesn't work out the Read instance of the underlying type.
09:28:03 <glguy> danilo2: I was playing around with the example code from your dysfundeps ticket the other day and thought I'd share this: http://lpaste.net/108922
09:28:43 <danilo2> glguy: oh great :) Let me look at this :)
09:31:59 <glguy> danilo2: It's not a transparent as the way you were doing it, so maybe it's not useful, but it just seemed close enough to share
09:34:24 <danilo2> glguy: I'm sitting in front of it right now. Thank you for this solution - its very simple and clear and I think it can be easly generated in our use cases, but you are right - maybe it would bve usefull here. I cannot answer it right now - it has to many "dependencies" to think of. But right now (during the next 2 weeks) I'll be doing in my work all related stuff and I will test it. I will write back to you in a week or two (mayb
09:35:26 <danilo2> glguy: anyway, thank you very much for this lpaste - it indeed could do something interesting here (and its so simple and straightforward that I'm wondering now If I just overlooked it somehow or have we made tests using something like that before in the past and there were other issues with uit)
09:36:06 <zalatovo> Qfwfq: what is the point of Readable?
09:36:34 <zalatovo> maybe I'm not understanding correctly
09:37:26 <tac_> It appears that parallel and concurrent haskell's code repository has a busted cabal file
09:37:37 <tac_> It doesn't include -rtsopts or -O2 on most of the build targets :(
09:38:17 <Qfwfq> tac_: I think I remember there being separate cabal files in subdirectories.
09:41:46 <zalatovo> Qfwfq: is this a correct instance? http://lpaste.net/500415431455014912
09:43:06 <Qfwfq> zalatovo: No, the compiler can't work out the read instance of a outside the context of Readable.
09:43:20 <ydl> i have an instance declaration of a class with lots of contexts, i.e. "instance (C1 a b c, C2 a b c,...) => CC a b c where ...". This works fine, but when i am writing code that uses the methods defined in this class, ghc isn't happy with me putting (CC a b c) => ..., but it wants me to put some subset of the contexts. Why is it doing this? Aren't I providing more than enough information with (CC a b c) => ...?
09:43:39 <enthropy> danilo2: http://lpaste.net/108920 make req a concrete variable then coerce it to a polymorphic one
09:44:06 <Qfwfq> zalatovo: This is a simplification of my actual problem, and so I'm struggling to generate a use case. The broader idea is that you can pass around values without knowing their concrete type, but that they implement the interface parameter instances.
09:44:13 <Qfwfq> *interface the
09:44:44 * hackagebot np-linear 0.2.0.1 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.2.0.1 (AriePeterson)
09:44:48 <zalatovo> Qfwfq: Couldn't you just pass around Read a => a then?
09:44:55 <enthropy> danilo2: Data.Coerce.coerce does work here so there's no need to think too hard about unsafeCoerce being unsafe
09:45:22 <enthropy> on the other hand maybe your real "newtype Req req m a" has a different role for req
09:45:34 <Qfwfq> zalatovo: I don't think so, but I'll see if it works.
09:46:11 <danilo2> enthropy: oh! It looks very hackish! I'm reading and testing it right now. I see it does not make any work here (by the way - does it affect performance in any way?). And thank you very much for taking your time and helping with it. I really appreciate it :)
09:47:05 <Qfwfq> zalatovo: No, and I can't decipher the type error.
09:48:29 <danilo2> enthropy: by the way - if both of the solutions (mine with DysfunctionalDependecies) and yours work the same way (we do not know that, but assuming they do), would you recommend to go the way you showed (which is great, but hackish and not very clear) or to use the extension ?
09:48:30 <enthropy> oops I messed up the signature: appMonadCtxReal :: AppMonadCtx2 a => a -> (forall req m a1. (Req ReqV m a1) ~ MkB a => Req req m a1)
09:49:03 <enthropy> so that "let y = appMonadCtxReal  (undefined :: Ctx IO Int; :t y"  gives you y :: Req req IO Int
09:49:04 <danilo2> enthropy: I know, I already fixed it! :)
09:49:27 <zalatovo> Qfwfq: you're trying to get this kind of behavior, right? https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
09:50:28 <Qfwfq> zalatovo: Not really. The idea's that I'm getting a result from the Real World, and I don't know what type it is, besides from that it's an instance of two typeclasses. And I want to use it somewhere else, knowing and requiring only that.
09:50:57 <enthropy> danilo2: I'd go with this way (or the equivalent two-paramter class version that also uses ReqV)
09:51:44 <Qfwfq> zalatovo: One of those typeclasses is of the form 'class X a where { f :: Int -> a }', and I want to instance it for 'forall a. X a => a'.
09:52:31 <danilo2> enthropy: Oh, I hope I'm not wrong, but this does not work exactly as the one with Dysfundeps. Look, If the third instance would be a little more complicated (like the real one: AppMonadCtx2 (Value m2 a2) (Req req (MonadCtx env set m1) a1) <= (a1~Value Pure a2, env~m2, set~Insert req Empty, m1~t m2, MonadTrans t, Monad m2, Functor m2)) - how can iI code using your method, that "set~Insert req Empty" ? Which equals to "set~(req,())
09:53:27 <enthropy> make the superclass constraint say   set~Insert ReqV Empty
09:53:37 <danilo2> enthropy: ah, I'm sory - in my code, when I'm using the "<=" means the same as "=>" but on the right side of instance
09:53:56 <enthropy> yes I guessed that
09:54:19 <zalatovo> Qfwfq: http://lpaste.net/500415431455014912
09:54:32 <enthropy> I'm pretty sure you have nearly the same problem as http://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-Data.html
09:55:01 <zalatovo> Qfwfq: Notice the different types wrapped by Readable, the only thing they have in common is that they are an instance of Read
09:55:36 <enthropy> and that coercing the C to c (or your RecV to rec) doesn't break things
09:55:39 <danilo2> enthropy: hmmm, I'm afraid it will not work correctly, because GHC would not think that the "req" in "set~(req,())" is the same as the other "req", but I can be wrong. I'll test it. Thank you very much for showing this way! :)
09:55:44 <Qfwfq> zalatovo: This doesn't help when I want to read to that value, does it?
09:56:30 <Qfwfq> zalatovo: The function has a typeclass constraint on its result type, to instance that typeclass, I need to pull a function out of the underlying instance.
09:56:32 <zalatovo> Qfwfq: Yeah that example I gave doesn't make a lot of sense either I now see
09:56:35 <Qfwfq> Underlying type.
09:56:54 <danilo2> enthropy: It looks like the same problem to me
09:57:16 <enthropy> at least as long as you don't have "instance Insert ReqV x where something" and "instance Insert reqV x where somethingElse"
09:58:37 <enthropy> if you only have the latter instance it should be "safe"... but then you'd wouldn't have "req" in the instance head (ie. you'd write  "class Insert x where ins :: Rec req x")
10:00:07 <Qfwfq> zalatovo: Another problem is that in having two constraints on the interface, I need a way to guarantee a function with that interface in the codomain has all those properties. Which I think is impossible here.
10:00:34 <danilo2> enthropy: hmm, no. Insert just inserts element to nested tuple of tuples. It works the same way for all the elelemnts :)
10:00:38 <Qfwfq> zalatovo: Making this library unusable for me, which is a bit of a pain.
10:00:44 <Qfwfq> Anyway..
10:01:09 <eacameron> installing HS platform RC2 and running cabal update I get this disturbing error: cabal: mallocPlainForeignPtrBytes: size must be >= 0
10:01:27 <eacameron> anyone else see this?
10:01:57 <Qfwfq> Actually, I think I know how to solve this.
10:01:57 <danilo2> enthropy: the exact insert code is here : http://lpaste.net/108927 :)
10:02:24 <zalatovo> Qfwfq: you are much more knowledgeable than me about all this it seems :-P
10:03:04 <Qfwfq> zalatovo: I really appreciated your suggestions! Thanks.
10:04:04 <enthropy> danilo2: then it seems you can't take    (x ~ Insert ReqV set) and pretend it's the same as  (x ~ Insert req set)
10:04:11 <zalatovo> Qfwfq: but do I understand correctly that you want to be able to read things without knowing their concrete type, only that they can be read?
10:04:47 <danilo2> enthropy: I was just going to write that to you
10:06:04 <danilo2> enthropy: anyway I've got to test it. Maybe I would be able to generate the needed code (without using Insert). But still - this is interesting, because lfting the liberal coverage condition works and gives good results in all the test cases. Hmm
10:06:11 <Qfwfq> zalatovo: Read and shown, really, but yes.
10:07:31 <Qfwfq> zalatovo: I was trying to make guarantees 'forall a. Read a => Show a => a' about a function 'Read a => b -> a', which is impossible.
10:07:47 <Qfwfq> (Without knowing the concrete type.)
10:07:50 <tac_> is force . map f operationally equivalent to map f . force?
10:07:58 <tac_> err
10:07:59 <tac_> I guess not
10:08:00 <tac_> nvm
10:08:46 <Qfwfq> zalatovo: And I'm just going to hack around it with explicit case analysis on every type 'Read a => Show a =>' provided by the library (again, Read and Show are examples, the actual use case permits this.)
10:11:17 <apricity> what are top books to read as a beginner at both functional programming and haskell? (I'm not a begginer programmer in general)
10:11:41 <systemfault> Learn You a Haskell(LYAH) is not bad
10:11:46 <adimit> @where LYAH
10:11:47 <lambdabot> http://www.learnyouahaskell.com/
10:11:55 <adimit> apricity: go there.
10:12:12 <merijn> I've heard good thing about Bird's book
10:13:13 <merijn> apricity: There's not really much of a difference between haskell books for people who have never programmed and people who have, as most things from other languages don't translate all that well
10:13:15 <apricity> thanks, I grabbed LYAH. Is there a good book on thinking functionally?
10:14:10 <merijn> I think that's just lots of practice
10:14:16 <adimit> SICP. :-P
10:14:23 <adimit> but that's more lispy.
10:14:30 <merijn> There are the Functional Pearls papers, which are good, but you should probably finish LYAH before reading those anyway
10:14:37 <merijn> Also, Okasaki
10:14:38 <allsystemsarego> @google "thinking functionally Haskell"
10:14:41 <lambdabot> http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
10:14:41 <lambdabot> Title: Thinking Functionally Haskell | Programming languages and applied logic | Cam...
10:14:44 <merijn> @where okasaki
10:14:44 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:15:10 <adimit> apricity: also, if you want some type theory, you should go for Pierce's TAPL (Types and Programming Languages)
10:15:26 <apricity> that uses ocaml right?
10:15:50 <allsystemsarego> @google "thinking functionally Haskell developerworks"
10:15:51 <lambdabot> No Result Found.
10:16:27 <ydl_> i have an instance declaration of a class with lots of contexts, i.e. "instance (C1 a b c, C2 a b c,...) => CC a b c where ...". This works fine, but when i am writing code that uses the methods defined in this class, ghc isn't happy with me putting (CC a b c) => ..., but it wants me to put some subset of the contexts. Why is it doing this? Aren't I providing more than enough information with (CC a b c) => ...?
10:16:56 <allsystemsarego> apricity, http://pragprog.com/magazines/2012-08/thinking-functionally-with-haskell
10:17:23 <enthropy> ydl_: no that only happens if you had  class (C1 a b c, C2 a b c,...) => CC a b c; instance (C1 a b c, C2 a b c,...) => CC a b c
10:18:01 <enthropy> which has slightly less duplication if you write it as   type family CC a b c :: Constraint; type instance CC a b c = (C1 a b c, C2 a b c,...)
10:18:32 <mmachenry> If I am making a large project and trying to follow the "How to make a Haskell Program" wiki, and following the recommended directory structure for large programs, do people suggest using HSpecTest.hs in the parent dir as given on that wiki node?
10:18:50 <mmachenry> Do a lot of people use HSpecTest?
10:18:53 <yitz> apricity: it uses ML. ocaml is a slightly different dialect of ML.
10:19:37 <josephle> apricity: SML
10:19:45 <apricity> thanks for the recomendations, going to start reading
10:19:47 * hackagebot Vec 1.0.5 - Fixed-length lists and low-dimensional linear algebra.  http://hackage.haskell.org/package/Vec-1.0.5 (ScottDillard)
10:19:50 <ydl_> enthropy, i don't think i have that. to be precise i have a single context on the class in general (so "class (C1 a b c) => CC a b c where..."), but then have "instance (C1 a b c, C2 a b c, C3 a b c,...) => CC a b c where..." and haskell asks for some subset of C2,C3,...
10:19:51 <merijn> I'm pretty sure TaPL uses ocaml
10:19:53 <adimit> apricity: Just read LYAH. Then, when you're done, read RWH. And then maybe TAPL. Have fun.
10:20:08 <josephle> merijn: oh, I thought he was asking about okazaki
10:20:14 <merijn> But why are we recommending TaPL for "thinking functionally"?
10:20:39 <apricity> i actually used tapl in a class about 10 years ago. but i don't remember much of it
10:20:44 <merijn> I mean, I *like* TaPL, but I think it's for people who wanna learn type theory or learn how to implement a programming language, not for "learning to think functionally"
10:20:45 <ydl_> enthropy, sorry, just to re-iterate, haskell then asks for some subset of C2,C3 when I am writing functions using methods from CC
10:21:04 <c909> apricity: and write as much haskell as possible along the way. you can't really know you're understanding things until you challenge your self
10:21:43 <merijn> ydl_: Well, your "CC a b c" type constraint doesn't tell GHC that "C1 a b c" has an instance
10:21:55 <supki> mmachenry: usually you have a top-level spec file that is managed by hspec-discover
10:22:01 <enthropy> ydl_: that's unavoidable if you don't want to change the class CC
10:22:02 <supki> mmachenry: that wiki page is pretty weird
10:22:03 <merijn> ydl_: So you're not allowed to use that instance for your code, as GHC can't prove that instance is valid
10:22:10 <supki> mmachenry: http://hspec.github.io/hspec-discover.html
10:22:14 <adimit> merijn: I recommend it because it teaches you lambda calculus, and typed lambda calculus, both of which are essential for "thinking functionally"
10:22:24 <merijn> I don't think they are
10:22:24 <adimit> I especially like its exposition of boolean algebra.
10:22:44 <merijn> Church encoding things is not a good way to learn thinking functionally
10:22:51 <ydl_> enthropy, merijn, but if i tell ghc "(C1 a b c, CC a b c)" why would it still ask for "C3 a b c" if I don't use methods of C3 directly?
10:23:03 <josephle> maybe we should be making the distinction between "thinking functionally" and "learning type theory"
10:23:30 <merijn> ydl_: Because "instance Foo a => Bar a" says "a is an instance of Bar ONLY IF a is an instance of Foo"
10:23:36 <josephle> lambda calculus is cool, and the y combinator blows minds, but I agree it's not essential to writing good haskell code
10:24:08 <merijn> ydl_: Your CC instance says "CC a b c" is an instance of CC ONLY IF "C1 a b c", "C2 a b c" and "C3 a b c"
10:24:38 <ydl_> sure. then i tell haskell 'a b c' is an instance of "CC", so shouldn't it be able to infer C1-C3?
10:24:40 <merijn> ydl_: If you don't add those three constraints, then GHC goes like "well, guess this instance isn't valid...is there any other? No? Ok, then I give up!"
10:24:49 <merijn> ydl_: No
10:24:52 <merijn> ydl_: Reread what I said
10:25:15 <merijn> ydl_: being an instance of C1-C3 is A REQUIRED PRECONDITION for being an instance of CC
10:25:31 <merijn> ydl_: If GHC can't prove the required precondition, it can't use the instance of CC
10:25:52 <merijn> instance declaration constraints ARE NOT inheritance
10:26:33 <yitz> merijn: according to the preface, tapl uses ocaml only for code fragments that illustrate concrete implementations of type checkers, in only a few chapters (perhaps 2?).
10:27:01 <merijn> yitz: TaPL comes with a cd of ocaml implementations of every type checker discussed in the book
10:27:14 <ydl_> merijn, i don't think i understand. suppose CC has one function f, presumably depending on a,b, and c. I should be able to use f for ANY a, b, and c such that (CC a b c). Why is GHC asking me to write extra constraints when they are making my code less generic?
10:27:40 <josephle> yitz: I'm pretty sure TaPL has Hindley-Milner implemented in Ocaml in a chapter somewhere
10:28:01 <merijn> ydl_: Because "CC a b c" ONLY IF "C1 a b c", "C2 a b c" AND "C3 a b c"
10:28:16 <merijn> ydl_: Without those last three, there is no CC instance
10:29:25 <yitz> josephle: yes. i think there is one other chapter, or perhaps two, that implement type checkers. i think that those are the only ocaml. merijn says that complete implementations of those, in ocaml, are provided on a cd.
10:29:49 <ydl_> merijn, OK (please bear with me, i am sure i am being dense), i think i am starting to understand. Does this mean that if i have another set d e f such that "C1 d e f, C4 d e f", i can't write "instance (C1 d e f, C4 d e f) => CC d e f where..."
10:30:42 <enthropy> ghc only looks at the stuff to the right of => when picking instances
10:31:04 <ydl_> merijn, actually apologies for that, that was dense. of course that's the case w/o undecidableinstances. in my case the first type is concrete, so i have something like "CC Int b c", "CC Double e f"
10:31:21 <enthropy> "instance (C1 d e f, C4 d e f) => CC d e f" cannot coexist with "instance (C1 d e f, C4 d e f) => CC d e f"
10:32:02 <enthropy> "instance (C1 d e f, C4 d e f) => CC d e f" cannot coexist with "instance (C1 d e f, C3 d e f) => CC d e f" -- probably clearer
10:32:27 <ydl_> enthropy, yes of course, i made a mistake in explaining my problem. the first parameter is concrete
10:33:17 <enthropy> ydl_: "instance (C1 D2 e f, C4 D2 e f) => CC D2 e f" cannot coexist with "instance (C1 D1 e f, C3 D1 e f) => CC D1 e f" --  this?
10:33:18 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
10:33:18 <phaskell> D1: Add LICENSE and update README.md - https://phabricator.haskell.org/D1
10:33:36 <ydl_> enthropy, those two can't coexist?
10:33:45 <ydl_> if D1/D2 are concrete?
10:33:56 <enthropy> yes you can have both
10:34:03 <ydl_> ok i thought so
10:34:08 <ydl_> because that's what i have :)
10:35:16 <ydl_> anyway, my point is i have "instance (C1 D1 a b, C2 D1 a b) => CC D1 a b where..." and "instance (C1 D2 a b, C2' D2 a b) => CC D2 a b where..."
10:36:17 <ydl_> but to be fair some of the constraints don't apply to all the types, so i might have "instance (C1 D2 a b,...,C10' a) => CC D2 a b where...", could that cause functions to require me to state "(C10' a) =>"?
10:36:41 <ydl_> instead of just "CC D2 a b =>"?
10:36:46 <ydl_> oh i think i see, please forgive me
10:37:00 <ydl_> can i consider "CC D2 a b <=> (CC D2) a b"?
10:37:22 <enthropy> you're allowed to write a "f :: CC D2 a b => a -> b" in terms of the methods of CC
10:38:27 <pavonia> :t Left 1 :: (Either Int) String
10:38:29 <lambdabot> Either Int String
10:39:05 <enthropy> but eventually ghc will pick the "instance (C1 D2 a b,...,C10' a) => CC D2 a b where", and it will complain if it can't find a instance C10' a
10:40:52 <tac_> Trying to install threadscope, and I'm getting this. Any ideas what the issue really is?
10:40:55 <tac_> gtk-0.13.0.0 depends on pango-0.13.0.0 which failed to install.
10:41:09 <tac_> rather err: "setup: The pkg-config package pangocairo version >=1.10 is required but it
10:41:10 <tac_> "
10:44:01 <pavonia> tac_: Do you have the C dev package for pango installed?
10:44:45 <tac_> most likely not. Although I'm having trouble figuring out what the package would be called to apt-get it.
10:46:39 <pavonia> try libpango1.0-dev
10:47:38 <tac_> ah yes
10:47:40 <tac_> thank you pavonia
10:47:54 <pavonia> no problem
10:52:36 <timmy_tofu> I'm using postgres-simple and trying to get use array values, but I keep getting an Incompatible error
10:53:02 <timmy_tofu> ex query_ conn "SELECT ARRAY[false,false,true];"
10:53:08 <timmy_tofu> Incompatible {errSQLType = "_bool", errSQLTableOid = Nothing, errSQLField = "array", errHaskellType = "Bool", errMessage = ""}
10:53:18 <timmy_tofu> pg_type _bool is the array boolean type
10:53:37 <timmy_tofu> and I'm specifying V.Vector Bool
10:54:50 <timmy_tofu> hmmm, for some reason if I make it a multi-dimensional vector it works.... kinda, except that my data is now one more level deep than it should be
10:56:56 <timmy_tofu> I guess because it's expecting the row to be a list itself if I don't specify another type with a FromRow instance
10:57:34 <tac_> well that was a letdown
10:57:38 <supki> timmy_tofu: yeah, you probably need to wrap the result in Only
10:57:44 <tac_> I finally got all the depends installed, and I get a type error :X
10:57:46 <supki> i.e. a one-tuple
10:59:44 <timmy_tofu> supki: Duh... of course this is all obvious the second after you shout it into the room... c'est la vie
10:59:47 <timmy_tofu> thanks
10:59:51 * hackagebot persistent-mongoDB 1.4.4.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.4.2 (GregWeber)
11:02:49 <codehero> @let fibonacci2 = 0:1:zipWith (+) fibonacci2 (tail fibonacci2)
11:02:51 <lambdabot>  Defined.
11:03:08 <codehero> > take 20 $ fibonacci2
11:03:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
11:03:14 <codehero> :)
11:03:22 <codehero> gotta love this
11:04:51 <sedeki> does (+) mean infix notation?
11:04:58 <c_wraith> > fix $ (0:) . scanl (+) 1 -- codehero this one's extra-confusing
11:04:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:05:03 <dmj`> sedeki: prefix
11:05:05 <codehero> wow
11:05:09 <codehero> this is so short
11:05:15 <dmj`> > (+) 1 1
11:05:17 <lambdabot>  2
11:05:27 <etandel> > (+1) 1
11:05:29 <lambdabot>  2
11:05:30 <c_wraith> codehero: well, it requires importing fix, so it's not really that short. :)
11:05:34 <etandel> > (1+) 1
11:05:36 <lambdabot>  2
11:05:50 <c_wraith> sedeki: you can see it as taking a section of both sides of the infix operator.
11:06:09 <etandel> it is called sectioning, after all
11:06:28 <bramgg> Noob here, what's the prefered way to make an HTTP GET/POST request?
11:06:33 <merijn> sedeki: Any function that consists of only operator symbols and not starting with ':' (see haskell report for definition of operator symbol) is an operator and is used infix
11:07:04 <merijn> sedeki: Infix operator can be made prefix by surrounding with parentheses (and any prefix function be made infix by surrounding with backticks `)
11:07:06 <c_wraith> merijn: Things starting with : are infix operators, too.  That's not how they're special
11:07:24 <merijn> c_wraith: I started with "any function"
11:07:25 <sedeki> nice thanks
11:07:35 <merijn> c_wraith: Anything starting with : is not a function
11:07:42 <c_wraith> merijn: data constructors are functions.
11:07:53 <n-dolio> They aren't always. But they can be.
11:07:58 <c_wraith> oh, true
11:08:05 <c_wraith> Infix ones tend to be be functions, though!
11:08:21 <merijn> sedeki: Anyway, as c_wraith points out operators starting with : are constructors (':' is treated as an "uppercase" symbol operator, as it where)
11:08:34 <n-dolio> Yeah. I don't think you can define non-function infix constructors without extensions.
11:08:35 <dmj`> bramgg: there is the HTTP pkg, but it doesn't do things in constant space, so depending on the http request you might be ok, either http-conduit, http-streams, wreq, pipes-http
11:08:47 <merijn> @let data List a = Nil | a ::: List a
11:08:48 <lambdabot>  Defined.
11:08:58 <merijn> @undefine
11:08:59 <lambdabot> Undefined.
11:09:03 <merijn> @let data List a = Nil | a ::: List a deriving (Show)
11:09:05 <lambdabot>  Defined.
11:09:11 <merijn> > 1 ::: Nil
11:09:13 <lambdabot>  1 ::: Nil
11:09:24 <n-dolio> Or maybe you just wouldn't be able to use them. Not sure.
11:09:59 <bramgg> dmj`: why does constant space matter?
11:10:33 <merijn> bramgg: A colleague of mine just download a 100 GB data set over http, does that answer your question? :)
11:11:06 <c_wraith> Pfft, that totally fits in RAM.  Err.  Wait.  Not on this computer.
11:11:16 <bramgg> merijn: lol gochya
11:11:25 <dmj`> merijn: using the HTTP pkg?
11:11:26 <n-dolio> My home computer has 32. It's getting close.
11:11:35 <n-dolio> This one has 24, I think.
11:11:37 <merijn> dmj`: No, just using some browser
11:11:39 <bramgg> I doubt it would be an issue for what I'm doing though
11:11:53 <merijn> dmj`: My point was just "sometimes you wanna download stuff bigger than your RAM over http"
11:12:14 <dmj`> merijn: for sure
11:12:18 <periodic> I'm drawing a blank here and my googling isn't working.  There has to be a package that has a list-shuffle implemented, right?
11:12:28 <periodic> All I can find is people explaining how to implement it.
11:12:51 <n-dolio> I don't know of one.
11:12:53 <dmj`> bramgg: haskell accumulates thunks, if not evaluated they can cause a stack overflow, iteratees are a way to incrementally process input from a file descriptor, be it a file on disk, a network socket. It's what http-conduit and others use
11:13:09 <merijn> There's at least two on hackage, but I forget the names
11:13:56 <bramgg> dmj`: thanks, is http-conduit the most used library then? As a noob I want to begin getting familiar with the most common libraries.
11:14:02 <kini> How is mtl-2.2.1 a "dependency of fgl-5.5.0.1"? http://lpaste.net/108933
11:14:04 <merijn> periodic: Try searching for "permutations"
11:14:12 <kini> looking at the package info on hackage, it seems to just require "mtl" with no version ranges
11:14:30 <kini> seems like cabal could resolve dependencies if it picked mtl 2.1.x...
11:14:38 <merijn> kini: A dependency of fgl depends on 2.2?
11:14:50 <Fuuzetsu> kini: you can tell cabal to use mtl 2.1.x and see what it comes up with
11:14:53 * hackagebot persistent-template 1.3.2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.2.1 (GregWeber)
11:14:57 <geekosaur> aren't there cases where (some versions of) cabal try to use the latest known version instead of the installed one?
11:14:58 <kini> merijn: wouldn't cabal print out that whole chain, then?
11:15:13 <dmj`> bramgg: it's popular sure, but there are other packages as well, like http-streams. To minimize risk of cabal hell I'd recommend going with one that has similar deps
11:15:16 <eacameron> how do I install test dependencies with cabal?
11:15:23 <kini> Fuuzetsu: that's an idea...
11:15:35 <c_wraith> eacameron: something like cabal install --only-dependencies --enable-tests
11:15:36 <Fuuzetsu> eacameron: --enable-tests
11:15:41 <bramgg> dmj`: ty
11:16:03 <eacameron> c_wraith: Fuuzetsu: I promise I tried Google first... ;)
11:16:06 <eacameron> thank you!
11:17:24 <merijn> bramgg: http-conduit was fairly simple for me and it fits nicely with html-conduit if you wanna scrape HTML
11:18:33 <periodic> merijin: I think I used that in the past, but I don't want to something silly like "i <- random; return . drop i . permutations $ list"
11:18:58 <periodic> I'm specifically looking for a way to randomize a (small) list.
11:19:18 <oakwhiz> periodic: Fisher-Yates shuffle?
11:19:19 <Fuuzetsu> :t shuffle
11:19:21 <lambdabot> Not in scope: ‘shuffle’
11:19:26 <Fuuzetsu> that'd be too easy
11:19:30 <periodic> I get a lot of fun implementations like this: http://www.haskell.org/haskellwiki/Random_shuffle
11:19:52 <c_wraith> periodic: http://lpaste.net/99888
11:19:52 <periodic> oakwhiz: exactly, I didn't want to have to figure out what shuffle algo to use and how to implement it.  I figured this woudl be done somewhere.
11:20:15 <periodic> Right.  this has to be in a library somewhere, right?
11:20:59 <c_wraith> periodic: as far as I've seen, libraries don't have O(n) versions.
11:21:54 <joelteon> id is O(1)
11:22:12 <joelteon> the shuffle, however, is not a uniform distribution
11:22:16 <c_wraith> joelteon: id isn't a very good random shuffle.  It's slightly biased towards the input order
11:22:51 <merijn> periodic: No, I meant there's some packages that do shuffle and I thought they had permutations somewhere in their name
11:23:22 <myname_> @pl \x y -> 0 == mod y x
11:23:23 <lambdabot> ((0 ==) .) . flip mod
11:23:33 <Iceland_jack> > map snd $ sortBy (comparing fst) (zip (randoms (mkStdGen 42)) [1..20])
11:23:35 <lambdabot>  [3,5,16,8,11,12,1,18,2,9,15,17,7,10,13,19,14,6,20,4]
11:23:40 <oakwhiz> there are a few ways you could do this off the top of my head... you could do a "bag" shuffle where you select random items out of the bag to build a new list, and the bag gets smaller each time
11:24:08 <oakwhiz> you could also generate a lazy list of all possible permutations, then pick one at random
11:24:37 <periodic> yeah, I know a lot of ways to do it.
11:24:48 <periodic> It just seems like the sort of thing that would be already done somewhere.
11:24:50 <periodic> and done "right"
11:24:54 * hackagebot lazyio 0.1.0.1 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.1.0.1 (HenningThielemann)
11:24:55 <periodic> so it is actually uniform.
11:24:59 <c_wraith> merijn: all the ones i've seen that try to do that use a tree instead of ST, and end up adding a log n factor uselessly
11:25:19 <periodic> My list is small.  I'm happy to do a O(n lg n) solution.
11:25:40 <periodic> What I don't want is an exponential one like the "drop i . permutations" method
11:25:41 <periodic> :)
11:26:02 <periodic> I guess I'll just implement myself after all (via copy-and-paste of course)
11:26:03 <c_wraith> there's http://hackage.haskell.org/package/random-shuffle
11:26:27 <c_wraith> I really hate its interface, though
11:26:36 <c_wraith> For reasons no one can explain, it doesn't return the PRNG
11:26:46 <periodic> Yeah, that one is sort of weird.
11:27:00 <periodic> Okay, whatever, I give up.  Maybe if I run into this again I'll submit something.
11:28:17 <c_wraith> man, all my old implementations are terrible.  Let's see if I have a *sane* list shuffle using ST around.
11:29:08 <tac_> Is there a compiler flag for automatically resolving ambiguous typeclass instances?
11:29:25 <tac_> the threadscope package looks like it's broken with dozens of accounts of the same error
11:29:39 <tac_> it leads me to think maybe the .cabal is missing some flags or something somehow
11:29:42 <c_wraith> wow, threadscope still hasn't fixed that?
11:29:50 <c_wraith> No, it was caused by gtk changing
11:29:55 <tac_> ahh
11:30:02 <tac_> I kicked off an email to the maintainers list
11:30:04 <c_wraith> It's a trivial fix, but apparently it's never been patched in mainline
11:30:32 <tac_> Is this trivial fix also a quick fix?
11:30:49 <Fuuzetsu> I really really really wish that in addition to ByteString's fromStrict there was also toLazy synonym…
11:30:51 <c_wraith> yeah, it's just changing imports in something like 3 files.
11:31:24 <Fuuzetsu> the gtk changes are hardly changing imports…
11:31:25 <tac_> c_wraith: Do you happen to know a git repo with the fix? Or should I crack my knuckles and give it a go?
11:31:30 <Fuuzetsu> not sure if we're talking about the same breakage
11:31:44 <jfeltz> using the pipes library: how do you combine a Producer a m () with Consumer a m r ? In other words, the consumer doesn't use the producer's return type. It returns a different one.
11:31:50 <c_wraith> Fuuzetsu: oh.  well, there were at some point fixes like that.
11:31:57 <tac_> c_wraith: Fuuzetsu: http://lpaste.net/108934
11:32:00 <c_wraith> tac_: I don't know of anything offhand
11:32:04 <tac_> is the error I get while building
11:32:13 <c_wraith> Ok, that's new and different
11:32:16 <Fuuzetsu> tac_: check out the gtk2hs mainpage
11:32:25 <Fuuzetsu> they now allow String and Text to be used
11:32:40 <Fuuzetsu> but that does mean that everything ever now needs signatures &c
11:32:47 <tac_> ahh
11:33:04 <Fuuzetsu> I started doing changing this in Yi but I ran out of steam…
11:38:38 <Fuuzetsu> is there a nicer way to write ‘f <$> g <$> h’?
11:39:14 <c_wraith> I don't even know how that associates.
11:39:25 * tac_ was going to say the same thing
11:39:28 <c_wraith> is it f . g <$> h
11:39:34 <RchrdB> Fuuzetsu, f . g <$> h
11:39:34 <Fuuzetsu> f <$> (g <$> h)
11:39:46 <c_wraith> then yeah.  f . g <$> h
11:39:49 <Fuuzetsu> ah yes, I suppose
11:40:07 <c_wraith> That's one of the functor laws!
11:40:14 <Fuuzetsu> I knew that!
11:40:18 <RchrdB> Fuuzetsu, <$> is a synonym for fmap. One of the laws that fmap is required (!) to obey is that (fmap f . fmap g) must be the same function as (fmap (f . g))
11:40:51 <RchrdB> so if you rearrange a little, yeah, (f . g <$> h) is the same thing.
11:41:48 <RchrdB> Fuuzetsu, oh and it's plausible that GHC might change (f <$> g <$> h) to (f . g <$> h) because I think that there might be some simplification rules that take advantage of the Functor laws? Please don't quote me on that because I'm not certain.
11:42:13 <Fuuzetsu> no, GHC doesn't use laws to implement such things
11:42:30 <Fuuzetsu> I think desugaring ‘do’ based on the Monad laws is the only thing it does
11:42:46 <Fuuzetsu> there was even a thread on this on one of the mailing lists some time ago
11:42:58 <c_wraith> No, even that doesn't use the monad laws.
11:43:11 <Fuuzetsu> I thought it relied on associativity
11:43:30 <c_wraith> What does use the monad laws is that people assume do {a ; b ; c } is the same as a >> b >> c
11:43:36 <vanila> I thoutht GHC optimzed things like fmap f . fmap g
11:43:40 <Fuuzetsu> right
11:43:43 <vanila> at least for lists
11:43:54 <c_wraith> But that's people's assumption that relies on the laws, not how GHC compiles
11:43:56 <Fuuzetsu> vanila: you can have RULEs for concrete types we know about
11:44:23 <Fuuzetsu> so you can optimise for lists and whatever other well-behaved instances we know about, it just doesn't do it in general
11:44:35 <c_wraith> *peoples'
11:44:41 <vanila> alrihgt, cool
11:45:44 <kini> how does GHC actually compile do {a ; b ; c} then?
11:46:01 <kini> and I think people's is correct there fwiw
11:47:00 <c_wraith> do notation desugars to (a >> (b >> c)), but >> is left-associative
11:47:08 <kini> ahh
11:47:14 <merijn> @undo do { a; b; c }
11:47:14 <lambdabot> a >> b >> c
11:47:28 <c_wraith> yeah, @undo is a bit sloppy.
11:47:31 <kini> :i (>>)
11:47:40 <kini> @info (>>)
11:47:40 <lambdabot> (>>)
11:47:51 <kini> ... well that's very info-rmative
11:48:00 <merijn> Of course, if you monad instance obeys the laws the difference is non-existent
11:48:11 <merijn> kini: @info autocorrects to @undo, there is no @info command
11:48:16 <merijn> @info do {a;b;c}
11:48:16 <lambdabot> a >> b >> c
11:48:18 <kini> ah
11:48:27 <kini> lol, I didn't know lambdabot autocorrected
11:48:38 <c_wraith> :tyre ()
11:48:47 <c_wraith> @tyre ()
11:48:48 <lambdabot> ()
11:48:51 <c_wraith> I'm bad at lambdabot
11:49:38 <merijn> lambdabot autocorrects with a max Levensthein distance of 2
11:51:07 <vamega> Anyone know of a function with type [(a, [b])] -> [(a,b)]
11:51:21 <vanila> I wrote one just the other day
11:51:32 <vanila> it went through Map
11:51:39 <Fuuzetsu> hm, say I have a nasty Arbitrary instance for a record with many fields so it ends up looking like Foo <$> arbitrary <*> arbitrary <*> something <*> arbitrary <*> arbitrary … and so on, is there a nicer way to write this out so that it's less based on the field order? I could use do notation and then explicitly assign to fields but I'm not sure if this is the way to go here
11:51:46 <c_wraith> sometimes (a, f b) -> f (a, b) is called strength
11:52:00 <c_wraith> Which would make that join . strength
11:52:15 <c_wraith> err, join . map strength
11:52:15 <vanila> wow, nice one
11:52:55 <vamega> I'm looking to convert [(1. [2,3,4])] to [(1,2), (1,2), (1,3), (1,4)]
11:53:26 <c_wraith> duplicating the first element?
11:53:31 <merijn> :t \(a, b) -> (a,) <$> b
11:53:36 <lambdabot> Functor f => (t, f a) -> f (t, a)
11:53:54 <Iceland_jack> vamega: Do you know how you'd convert just (1, [2,3,4]) to [(1,2), (1,3), (1,4)]? (I'm guessing the duplication was unintentional)
11:53:59 <merijn> :t join . map (\(a, b) -> (a,) <$> b)
11:54:00 <lambdabot> [(t, [a])] -> [(t, a)]
11:54:31 <vamega> iceland_jack: yes
11:54:46 <vamega> I coudl zip repeat fst with snd
11:54:50 <merijn> > join . map (\(a, b) -> (a,) <$> b) $ [(1, [2,3,4])]
11:54:52 <lambdabot>  [(1,2),(1,3),(1,4)]
11:56:12 <vamega> c_wraith: yes duplicating the first element.
11:58:55 <vanila> > let f (a,(x:xs)) = (a,x) : map ((,) a) (x:xs) in [(1, [2,3,4]),(7,[9,8])] >>= f
11:58:56 <lambdabot>  [(1,2),(1,2),(1,3),(1,4),(7,9),(7,9),(7,8)]
12:00:37 <nick_named> > join . map (\(a, b) -> (a,) <$> b) $ [(1, [2,3,4]),(7,[9,8])]
12:00:39 <lambdabot>  [(1,2),(1,3),(1,4),(7,9),(7,8)]
12:04:53 <orion> Is there a way to ask haddock to tell me which functions aren't documented?
12:05:37 <c_wraith> Huh.  That's an excellent question.
12:05:54 <dmj`> greppadock
12:06:18 <supki> orion: --print-missing-docs
12:06:29 <Exio4> @let magic list = [ [ (x,y) | y <- xs ] | (x, xs) <- list]
12:06:30 <lambdabot>  Defined.
12:06:50 <Exio4> > magic [(1, [2,3,4]),(7,[9,8])]
12:06:51 <lambdabot>  [[(1,2),(1,3),(1,4)],[(7,9),(7,8)]]
12:07:10 <Exio4> so, join.
12:07:27 <codehero> magic O_O
12:07:29 <a2c> is there some documentation on lambdabot that I could read? or a small manual? I don’t want to spam the chat by playing with it
12:07:33 <orion> cabal: unrecognized 'haddock' option `--print-missing-docs'
12:07:39 <Iceland_jack> a2c: You can talk to it in PM
12:07:48 <a2c> Iceland_jack: thanks!
12:07:56 <nick_named> @let magic = join . map (\(a, b) -> (a, head b) : ((a,) <$> b))
12:07:57 <lambdabot>  .L.hs:152:1:
12:07:57 <lambdabot>      Multiple declarations of ‘magic’
12:07:57 <lambdabot>      Declared at: .L.hs:146:1
12:07:57 <lambdabot>                   .L.hs:152:1
12:08:03 <codehero> a2c: @help should display help
12:08:09 <nick_named> @let magic2 = join . map (\(a, b) -> (a, head b) : ((a,) <$> b))
12:08:11 <lambdabot>  Defined.
12:08:17 <c_wraith> lambdabot's @help isn't very helpful
12:08:22 <nick_named> > magic2 [(1, [2,3,4]),(7,[9,8])]
12:08:24 <lambdabot>  [(1,2),(1,2),(1,3),(1,4),(7,9),(7,9),(7,8)]
12:08:24 <supki> orion: yeah, that's a haddock option
12:09:03 <supki> orion: you'd need --haddock-options to pass options to haddock through cabal
12:13:53 <mmachenry> Does anyone know why I get this from "cabal test" when the module that I am testing works fine on this system (MacOS) http://lpaste.net/108935
12:16:15 <tulcod> mmachenry: did you forget to link the library in the test suite?
12:16:28 <supki> mmachenry: if that "dialer" thing is yours then you're probably missing some modules in the exposed-modules section in the .cabal file
12:16:40 <tulcod> mmachenry: hmm, tbh that shouldn't be necessary, disregard my suggestion
12:17:05 <mmachenry> supki: Oh that's it.
12:17:12 <mmachenry> Hard to understand message! Thanks
12:17:27 <mmachenry> tulcod: Also thanks for trying, and yes I had the lib in there.
12:18:19 <joneshf-laptop> looking at http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Extend.html, why does (->) need a Semigroup constraint?
12:18:39 <joneshf-laptop> if you define Extend with `extract` for this instance, there doesn't seem to be a reason for it
12:18:54 <joneshf-laptop> sorry, `extended`
12:18:57 <friden> I need some help, lately i've been working on a script to make suggestions for new moview to watch, so i've tried to parse web pages that lists movies by popularity. i found that torrent sites mostly mirrored my interests, but here is my problem:
12:19:10 <friden> i've been using: simpleHTTP (getRequest "http://google.com") >>= getResponseBody
12:19:10 <joneshf-laptop> if it's defined with `duplicated` then it makes sense
12:19:38 <friden> it works great for sites like google.com, or most sites that i've tried actually, but it does not work for thepiratebay.se
12:19:47 <friden> its really strange, it only prints a lot of ascii codes
12:20:02 <friden> i can't see why, someone knows whats up?
12:20:16 <orion> When I run haddock I get: "Warning: Crypto.KDF.Scrypt: could not find link destinations for: Crypto.Internal.Scrypt.scrypt" <-- That function is exported, but the *module* is /not/ exported. How can I get rid of this warning?
12:22:59 <nick_named> friden: I'm willing to bet it has something to do with encoding differences.  Do they use unicode?
12:24:17 <friden> i have no idea actually, i tried to use decodeUtf8 from Data.Text.Encoding instead and i got an error about something like incorrect utf8 encoding
12:24:49 <friden> but the strangest thing is that it worked three days ago, but today when i wanted to continue on my script it suddenly didnt work anymore
12:25:12 <monochrom> that is not ascii code. that is "Content-Encoding: gzip".
12:25:13 <friden> but its only thepiratebay.org that i've tried so far that doesnt work
12:25:21 <friden> oh, damn
12:25:33 <friden> maybe i can tell http to request plain text?
12:25:40 <monochrom> never ignore the header. never.
12:25:41 <sm> different locale setting ($LANG) in your current environment ?
12:26:12 <nick_named> There is a gzip package out there
12:26:14 <monochrom> http doesn't include code to decompress. you need zlib.
12:26:17 <joneshf-laptop> oh, maybe it's something to do with laws
12:27:00 <friden> heh, but then i'll have to check the header, and then encode it differently depending on encoding?
12:27:06 <monochrom> yes
12:27:33 <nick_named> Or you could find a library that does that for you
12:27:40 <friden> strange thou how it worked three days ago, i did just shut down my computer and started it up today, but i see the problem now
12:27:46 <friden> nick_named: yeah that would be awesome
12:28:00 <friden> something that detects encoding and gives me a string of the source
12:28:23 <friden> i thought the method i used did that actually
12:28:56 * sm would have a little look on hackage
12:29:29 <gdoteof> runghc is not finding my cabal folder it seems, is there some way to see where it is looking?
12:29:51 <Ankhers> gdoteof: Are you using a cabal sandbox?
12:29:58 <gdoteof> when i do runghc `...` it gives me errors that every depedency is missing
12:30:01 <nick_named> friden: Its not pretty, but http://stackoverflow.com/questions/3784765/how-to-make-haskells-network-browser-do-gzip-compression
12:30:03 <gdoteof> Ankhers: no i'm not
12:31:25 <samba1> how can I ahve postgres-simple-snaplet read from a different config file for different environments. By default snaplets use dvel.cfg, so postgres-simple looks for stuff there. I'd like to have a stage and production.cfg as well with different stuff. getSnapletUserConfig gives stuff automatically fetched from devel.cfg, is there an easy way to specify other files depending on an environment variable or something?
12:32:07 <friden> nick_named: whoa... i will try that and see if it works xd
12:32:32 <gdoteof> I use docker to sandbox my haskell environments
12:32:46 <mightybyte> samba1: ./myapp -e prod
12:34:16 <Ankhers> gdoteof: and you have installed the deps in your container, or are sharing the directory with the container?
12:34:24 <eacameron> noob question, I want to pattern match on an IO (Either a ()), can't I just do `Right () <- doAction`?
12:34:33 <samba1> mightybyte: Do you know how I can test that by passing the -e option through to the application when running with cabal run?
12:34:49 <gdoteof> Ankhers: the dependencies are 100% in the container.
12:35:16 <gdoteof> Ankhers: if i do 'cabal build' the whole thing goes fine.  i am trying to follow this example https://github.com/gimbo/cabal-macosx/blob/master/examples/wxHello/README
12:35:42 <gdoteof> so I added the l ittle toy Setup.hs file into the folder with my existing project (which compiles/runs fine) and do "runghc Setup configure"
12:35:59 <gdoteof> and it complains that none of my dependencies are there (including the project itself!)
12:36:45 <hexagoxel> samba1: cabal run -- -e prod (see cabal help run)
12:38:03 <gdoteof> Ankhers: http://lpaste.net/108937
12:38:34 <supki> gdoteof: runghc Setup configure only looks in global database by default
12:38:56 <gdoteof> supki: i'm not sure what you mean, but there is only one databse afaik(?)
12:39:39 <eacameron> for some reason `Right () <- doAction` fails to compile but `() <- doAction` doesnt....
12:40:01 <monochrom> there are at least two. global and user. read my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:40:05 <geekosaur> gdoteof, there's a global package database and a user package database. cabal sandbox coopts the latter
12:40:20 <gdoteof> i am *not* using cabal sandbox
12:40:27 <geekosaur> I'm sorry I mentioned it
12:40:27 <mmachenry> Gasp
12:40:28 <monochrom> "Setup.hs" defaults to ignoring user. this is not the doing of runghc. this is the doing of Setup.hs code
12:40:29 <geekosaur> it still exists
12:40:32 <geekosaur> pay attention
12:40:44 <geekosaur> I said coopts, not creates
12:40:47 <gdoteof> when i do cabal install .. it installs then to the user package db
12:40:52 <gdoteof> my apologies
12:40:55 <geekosaur> cabal install forces user
12:41:09 <geekosaur> (unless forced otherwise with --global)
12:41:14 <monochrom> yes, "cabal install" honours user. this says nothing about Setup.hs
12:41:19 <geekosaur> runhaskell Setup.hs uses 0--global unless forced with --user
12:41:32 <gdoteof> awesome
12:41:37 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml and also http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
12:42:36 <monochrom> the inconsistency is very wrong. but still, a good programmer knows to assume nothing.
12:43:36 <gdoteof> thanks.  i did suspect that there was a problem with where it was looking, but i was not not aware that there was a global one at all
12:44:58 <samba1> hexagoxel: mightybyte: thanks to both
12:51:02 <friden> nick_named: ok, almost done, if i just test the function you linked me at SO it prints alot of stuff but i managed to do: liftM snd $ browse $ gzipRequest $ fromJust $ parseURI "http://google.com"
12:51:07 <friden> and ended up with an IO (Response B.ByteString)
12:51:23 <monochrom> you can have as many database combinations as there are directed acyclic graphs with one root
12:51:34 <friden> its probably close and i know that im probably stupid, but i dont know how to make it a string xd
12:52:45 <orion> monochrom: I found a typo.
12:52:46 <Pythonfant> friden: you want to get from Bytestring -> String?
12:53:23 <Pythonfant> :t unpack
12:53:25 <lambdabot>     Not in scope: ‘unpack’
12:53:25 <lambdabot>     Perhaps you meant one of these:
12:53:25 <lambdabot>       ‘BS.unpack’ (imported from Data.ByteString),
12:53:29 <Pythonfant> :t BS.unpack
12:53:31 <lambdabot> BSC.ByteString -> [Word8]
12:53:33 <monochrom> you have to find or guess what those bytes mean, i.e., are they ascii, are they utf8, are they windows-1251
12:53:41 <friden> no that i could have hoogled xd
12:53:49 <friden> its more like i want to do Response B.ByteString -> String
12:53:51 <monochrom> and use the corresponding translation
12:54:09 <Pythonfant> friden: from which lib is the response type?
12:54:17 <monochrom> Response B.ByteString contains a ByteString field
12:54:23 <friden> Network.HTTP
12:54:28 <friden> if im interpreting it correctly
12:55:24 <friden> http://pastebin.com/4U3GGnGD
12:55:28 <friden> this is what i have so far
12:55:52 <merijn> Pythonfant: Use Text.Encoding to decode to Text and then unpack Text to String (or work directly with text)
12:56:11 <merijn> oh, wait, I guess that was for friden
12:56:12 <monochrom> you want to tell that to friden
12:56:27 <friden> merijn: oh thanks, i will try that^^
12:56:29 <Pythonfant> merijn: yep I was looking for the one from char8, but that's not his problem
12:56:41 <Twey> Is there an automated way in lens to produce a lens class (like with makeClassy) whose member lens maps to lenses on differently-named record fields on different types?
12:56:57 <merijn> Pythonfant: Char8 is a lie and should be forgotten >.<
12:57:08 <Pythonfant> merijn: yeah you're right :)
12:57:27 <supki> Twey: makeFields
12:57:45 <njcomsec> what kind of projects is haskell used in commercially?
12:58:00 <njcomsec> like science, analysis stuff?
12:58:10 <Twey> supki: Ah, brilliant — thanks!
12:58:21 <njcomsec> I heard it is best suited for data crunching/mass calculations
12:58:31 <MP2E> njcomsec: http://www.haskell.org/haskellwiki/Haskell_in_industry
12:58:33 <merijn> njcomsec: Lots of finance stuff
12:58:38 <njcomsec> ahh cool
12:59:10 <Twey> njcomsec: Finance and HPC seem like the big ones.  But that's more of a reflection on who can hire and attract Haskell programmers than on what Haskell is intrinsically suited for, I think.
12:59:16 <merijn> njcomsec: I know there at least a handful of banks/trading companies with >100k LOC haskell, many more companies with different stuff
12:59:43 <merijn> njcomsec: Haskell is now my "default" language for any project, unless I have a very good reason to use something else
13:00:03 <Twey> njcomsec: A lot of big tech companies you've probably heard of use Haskell internally, too.
13:00:07 <tibbe> edwardk: today is a parade of hard GADT problems
13:00:18 <tibbe> edwardk: I’m trying to type a n-ary map function
13:00:38 <merijn> njcomsec: You get all the nice lightweight threading/channel stuff like Go/Erlang has, you have cool STM stuff that doesn't really exist in many other languages, excellent server performance
13:00:41 <tibbe> edwardk: taking N functions to apply to each element, producing N output lists
13:01:04 <alorente> njcomsec: I work at a company with a Haskell web api. We like it :)
13:01:14 <edwardk> tibbe: can i back up and ask what the core probem you're looking to solve is?
13:01:15 <merijn> njcomsec: Hell, I even call haskell my favorite imperative language these days :)
13:01:15 <Twey> ‘All the nice lightweight threading/channel stuff’ but more lightweight ;)
13:01:29 <alorente> this is a case study about it https://www.fpcomplete.com/wp-content/uploads/janrain-case-study.pdf
13:01:36 <tibbe> edwardk: I’m trying to write a functional implementation of FlumeJava
13:01:49 <tibbe> edwardk: it’s a DSL for distributed MapReduce-style computations
13:02:12 <tibbe> edwardk: the FlumeJava paper defines a number of optimizations they define on their AST, among the sibling fusion (a tupling style optimization)
13:02:37 <njcomsec> well mainly I want to make games. not sure Haskell is really suited for it
13:02:43 <tibbe> edwardk: one core problem here is to rewrite two Maps on the same input into a single one with two outputs
13:02:51 <njcomsec> at least there is not a lot of experimentation or support yet
13:03:09 <tibbe> edwardk: and repeatedly applying that optimization so you convert N single maps into one N-output one
13:03:32 <edwardk> with the strongly typed API you want this is going to suck
13:03:39 <tibbe> edwardk: I managed to rewrite two single ones to a double one by having two constructors, Map and Map2, but that doesn’t scale of course
13:03:58 <tibbe> edwardk: I’m open to weakly types ASTs too. I can add the typing at the user-facing layer
13:04:00 <alorente> njcomsec: a thing I've heard about game development is if there's a realtime component you basically can't use a garbage-collected language (including Haskell) because the GC might run at any time, briefly locking your program and messing up time-critical things
13:04:05 <edwardk> sure you need to spit out some kind of hlisty thing
13:04:10 <merijn> njcomsec: I'd say it depends on what sort of games
13:04:17 <tibbe> edwardk: that’s what I’m trying, let me paste
13:04:36 <merijn> njcomsec: For something twitchy like FPS I don't think haskell is very suited yet, GC pauses make it hard to do soft-realtime
13:04:43 <njcomsec> I see
13:04:45 <Twey> njcomsec: For the kinds of games where you'd be tempted to use Java or managed C#, it's fine
13:04:52 <merijn> njcomsec: If you wanna do something more turn-based/slower paced then it's fine
13:04:54 <njcomsec> but it is strange you say that because there are many java games out there
13:05:07 <njcomsec> like minecraft performs quite well
13:05:13 <alorente> njcomsec: yeah. Android developers, for example, have learned to co-opt the garbage collector
13:05:17 <Pythonfant> also unity uses c#, right?
13:05:21 <njcomsec> yeh Im doing android apps now
13:05:26 <tibbe> edwardk: http://lpaste.net/108940
13:05:26 <Twey> njcomsec: For the high-octane wring-every-last-cycle-out-of-the-CPU 2016-style-graphics FPS games, you probably want to go with something that doesn't have a garbage collector
13:05:33 <edwardk> njcomsec: expect about that same level of issue. if you want to do AAA style titles you may have a problem, for anything mid-stream i'd say the issue of gc pauses is made out to be a bigger issue than it really is
13:05:38 <njcomsec> ahh I see what you mean
13:05:49 <njcomsec> yeh for hardcor 3d games c+= is the only option it seems
13:05:50 <tibbe> edwardk: what I pasted is a bit too limited, in that it requires all map outputs to have the same type, but it’s a start
13:06:00 <njcomsec> but I dont think I will ever make anything that performance critical
13:06:11 <Twey> njcomsec: Rust might be an alternative these days if you don't like C++.  Still pretty experimental, though.
13:06:26 <njcomsec> well I think I will learn c# for windows games
13:06:32 <njcomsec> I only plan on making 2d games for the moment
13:06:48 <Twey> njcomsec: You can go to Haskell for that
13:07:02 <tabemann> doesn't Haskell have a stop-the-world style GC rather than an incremental one, though?
13:07:03 <njcomsec> I will try haskell too
13:07:10 <Twey> tabemann: No, it's incremental
13:07:19 <Twey> Er *double-checks that*
13:07:22 <tibbe> edwardk: ‘accs’ in the code creates N intitially empty accumulator lists
13:07:33 <Enigmagic> Twey: it's generational but it is stop-the-world
13:07:40 <merijn> Haskell has generational GC, but stop-the-world
13:08:16 <edwardk> what keeps you from just going to something like
13:08:17 <edwardk>     Map :: (a -> Tuple b) -> Term [a] -> Term [Tuple b]
13:08:29 <edwardk> and fusing the 'Tuple' into the function when you concatenate another one in there
13:09:28 <Twey> Enigmagic, merijn: Ah, right, yes.  Thanks.
13:09:33 <edwardk> the type argument to Tuple should be the list of types or the nested pair mess you deal with now
13:10:04 <tabemann> I forget what the rationalization behind having stop-the-world GC than incremental GC was.... something about greater througput with incremental typically not having enough of an advantage to be worth it
13:10:39 <tibbe> edwardk: ah, in reality I’m dealing with ConcatMap, so Term [Tuple b] constains all the list to be of equal length
13:10:52 <tibbe> edwardk: hence I have Term (Tuple [b])
13:11:34 <edwardk> let me go back and try to break things up a bit. the fact that you are using concatmap means that you have a big mess on your hands, how does this fuse at all? if we're all giving back variable length lists you aren't getting one output stream of tuples in lockstep
13:12:21 <edwardk> do you want tuple to rather be something like: data Tuple (t :: [*]) where Empty :: Tuple '[]; Cons :: a -> Tuple as -> Tuple (a ': as)
13:12:34 <tibbe> edwardk: lockstep isn’t neccesary (there’s no streaming to be had here)
13:13:00 <tibbe> edwardk: what’s the difference between a list and a pair as the phantom type?
13:13:16 <edwardk> tighter specification. right now i think you are misreading your Tuple (a -> b)
13:13:27 <edwardk> its uninhabited
13:13:31 <edwardk> you have Tuple ()
13:13:35 <tibbe> edwardk: hmm, I see
13:13:41 <edwardk> and Tuple (a,()) and Tuple (a,(b,()))
13:13:45 <edwardk> etc.
13:13:48 <edwardk> but no Tuple (a -> b)
13:14:04 <edwardk> so switching to the data kind form forces you to get that right
13:14:07 <tibbe> edwardk: for a wider context, the travesal of the input list is very expensive (it’s terrabytes big, residing on several different machines)
13:15:04 <Trollinator> when I heard my compiler lecture, we were first taught Haskell and then Lisp… When a fellow student first heard of “car”, he asked “is that the equivalent of head or fst“?
13:15:09 <Trollinator> I thought that was pretty clever :D
13:15:28 <tibbe> edwardk: ok switched to your type
13:15:42 <tac_> what is the command to do the equivalent of ghc-pkg for cabal?
13:15:47 <Fuuzetsu> @pl f x = g <$> h x
13:15:48 <lambdabot> f = (g <$>) . h
13:15:58 <Fuuzetsu> fmap g . h I guess
13:16:03 <merijn> tac_: Wrong question
13:16:08 <merijn> tac_: cabal uses ghc-pkg
13:16:33 <monochrom> yes, car could be head or fst
13:16:34 <merijn> tac_: There is no cabal package database, which is also why cabal can't track executable or uninstall. It just uses the ghc-pkg library database
13:16:55 <Cale> Trollinator: Did the lecturer respond with "yes"?
13:17:29 <edwardk> now to apply some f underneath it, e.g. a map you're looking at something like needing a type family Map (f :: * -> *) (xs :: [*]) :: [*] where Map f '[] = '[]; Map f (a ': as) = f a ': Map f as ; and then to define the mapping function that takes you down the list. right now you need to get in there and put [] underneath all your elements in the type list
13:17:32 <tac_> I'm using a sandbox. My actual question is about why cabal install is rejecting the version of gtk I want
13:17:37 <Twey> Trollinator: ‘And also <list of other encoding-dependent equivalents>’
13:17:47 <edwardk> e.g. given Tuple '[a,b,c] you want Tuple '[[a],[b],[c]]
13:17:52 <Trollinator> Cale: I don't recall…
13:18:03 <monochrom> "cabal hc-pkg" calls ghc-pkg but also adds parameters about your sandbox
13:18:05 <edwardk> which is Tuple (Map [] '[a,b,c])
13:18:33 <edwardk> this is going to get complicated =)
13:19:44 <tibbe> edwardk: what would an untyped representation look like? I still need to have these higher-order functions in there.
13:20:11 <edwardk> tibbe: ah you're not converting all the functions to a syntactic form as well?
13:21:13 <tibbe> edwardk: no, I want to catch haskell functions as the functions bodies
13:21:21 <tibbe> edwardk: less work, better performance
13:21:29 <tibbe> edwardk: here I differ from e.g. Accelerate
13:22:01 <edwardk> that complicates any untyped story
13:22:23 <tibbe> edwardk: not using a GADT gives me some problem here, because I need to process e.g. (Map … (Map …)) but now the a->b’s don’t line up.
13:22:55 <edwardk> you really are biting off an annoyingly hard problem ;)
13:23:07 <tibbe> edwardk: those are the ones worth solving ;)
13:23:24 <tibbe> edwardk: I think this the first time I’d ever say “this is easier in Python”
13:23:30 <tibbe> edwardk: perhaps I’ll stick Typeable everywhere
13:23:31 <edwardk> sadly it would be =P
13:23:39 <tac_> And after all that work, I get the same error I got when I installed with apt-get T___T
13:23:41 <tac_> "threadscope: Cannot initialize GUI.
13:23:41 <tac_> "
13:23:57 <edwardk> it'd also be fine if i could abuse hask, but i don't think you want to give up all of the haskell libraries for it ;)
13:24:10 <tibbe> heh
13:24:17 <tibbe> my brain also needs to survive the trip
13:24:18 <edwardk> as you have a nice monad over (* -> *) here
13:25:07 * hackagebot DAV 0.7 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.7 (ClintAdams)
13:25:29 <tibbe> edwardk: could I do: forall a b. (Typeable a, Typeable b) => (a -> b) -> Term [a]
13:25:47 <tibbe> edwardk: then I will get lots of ugly dynamic type checking, but at least the code would get written
13:25:55 <Shamar> hi, anyone using SFML on windows? I had to hack the CSFML dlls for mingw that I downloaded from the official site to install the cabal package
13:25:56 <sclv> all those casts kill whatever efficiency you thought you won
13:26:06 <Shamar> here http://www.sfml-dev.org/download/csfml/CSFML-2.1-windows-32bits.zip you can find in the *bin* directory dlls with names like csfml-window-2.dll but the cabal file from hackage (you can see it here: https://github.com/SFML-haskell/SFML/blob/master/SFML.cabal) requires csfml-window.dll
13:26:08 * shapr puts a cast on his broken dynamic type
13:26:16 <Shamar> who's wrong? the csfml distribution or the haskell package?
13:26:17 <edwardk> yeah but you can also kill the need for the type arg you have then, but its going to be slow
13:26:40 <sclv> i can't read enough scrollback to see the actual tricky bit
13:26:56 <sclv> its basically some strongly typed AST and a particular set of transforms that are hard on it?
13:27:00 <tibbe> edwardk: the evaluator will create the ‘a’ and ‘b’s using Binary, since during excution they come from network/disk
13:27:09 <tibbe> sclv: yes
13:27:17 <sclv> do you still have a paste of it?
13:27:18 <edwardk> sclv: he's got a bunch of crazy fusion operators trying to fuse stuff into one pass and a strongly typed edsl with functions at the leaves
13:27:29 * neuroserpens looks around >.>
13:27:38 * neuroserpens looks to the other side <.<
13:27:49 <nick_named> sclv: http://tunes.org/~nef/logs/haskell/14.08.06
13:27:50 <neuroserpens> xD
13:27:50 <sclv> so the trick is to join up the ends of the functions
13:27:52 <edwardk> sclv 'd be a good guy to ask this stuff of, as he does this here for us =)
13:28:02 <sclv> ?
13:28:05 <shapr> neuroserpens: Hey, do you write Haskell code?
13:28:18 <neuroserpens> shapr: No! xD bwahahahhaaaa
13:28:22 <tibbe> sclv: I’m trying to fuse e.g. let xs = … in … (Map f xs) … (Map g xs) … into let xs = …; ys = Map2 f g xs in … Fst ys … Snd ys …
13:28:29 <edwardk> In PA / factor backtesting, all the streaming noise
13:28:33 <shapr> neuroserpens: do you WANT to write Haskell code?
13:28:39 <shapr> neuroserpens: Have you seen the nifty tutorial that bitemyapp wrote?
13:28:41 <neuroserpens> shapr: Mayb xD
13:28:52 <neuroserpens> shapr: Let me tell you my story...
13:29:01 <shapr> neuroserpens: Have you seen that tutorial?
13:29:09 * shapr digs around for the url
13:29:25 <shapr> aha!
13:29:27 <sclv> so Map2 is like a &&& type of thing?
13:29:30 <shapr> neuroserpens: check it out! https://github.com/bitemyapp/learnhaskell
13:29:35 <neuroserpens> shapr: I was bored the other day looking for the coolest irc channel ever... Then I saw stories of people who try to troll this channel and are treated to nicely they end up learning haskell rofl.
13:29:35 <tibbe> sclv: http://stackoverflow.com/questions/24712273/implementing-sibling-fusion-using-standard-ast
13:29:44 <neuroserpens> shapr: I'm a python coder though xD
13:29:50 <shapr> neuroserpens: Well, if you're bored and you only want to troll, I'll happily ban you.
13:29:59 <tibbe> sclv: hopefully that gives the general idea
13:30:02 <shapr> neuroserpens: but if you're bored and you want to LEARN, then this is the place!
13:30:05 <edwardk> neuroserpens: frankly that was a bit of a one off thing. if you want to troll, well, frankly we're tired of it
13:30:16 <tibbe> sclv: I’m trying to implement FlumeJava in Haskell (http://pages.cs.wisc.edu/~akella/CS838/F12/838-CloudPapers/FlumeJava.pdf)
13:30:19 <shapr> neuroserpens: Python got me into Haskell, so it's a good place to jump
13:30:22 <tibbe> sclv: in particular sibling fusion
13:30:31 <sclv> ok, there's a lot of catching up to do for me here
13:30:33 <shapr> neuroserpens: so which will it be? the learning choice or the banning choice?
13:30:49 * shapr starts the countdown
13:30:50 <sclv> i'm better when its a "i can't thread this type over _there_" sorta deal
13:30:54 <neuroserpens> shapr: Neither lol I'm not trolling hahaha
13:31:07 --- mode: ChanServ set +o edwardk
13:31:11 <shapr> neuroserpens: Ah, but if you're not learning then you're distracting
13:31:14 --- mode: edwardk set +b *!~neuroserp@187.21.59.228
13:31:15 --- kick: neuroserpens was kicked by edwardk (Your behavior is not conducive to the desired environment.)
13:31:20 <tibbe> sclv: I’ve been breaking it down into subproblems and have had various people try to help me with them
13:31:23 <shapr> edwardk: jolly good show!
13:31:25 --- mode: edwardk set -o edwardk
13:31:37 <sclv> gotta do a call -- back in a bit
13:31:38 <tibbe> sclv: I’m feeling like I’m banging my head against the limits of what we can type well (or at all) in Haskell
13:31:42 <tibbe> sclv: ok
13:31:45 <tibbe> brb
13:32:15 <byorgey> ivanm: are you around?
13:32:38 <byorgey> wondering how to use the graphviz package to round-trip a graph through some command other than dot, if anyone else knows the answer to that
13:35:54 <edwardk> tibbe: we can type a lot more than that, the problem is that you lose all your standard tools here
13:36:09 <edwardk> tibbe: so everything is going to be written bespoke just for this one case
13:36:28 <edwardk> my problem is i have yet to fully grok the type you are looking for
13:42:55 <tibbe> edwardk: fair enough
13:43:04 <edwardk> see pm
13:43:48 <tibbe> edwardk: I also suspect that a traditional AST won’t work for some of the optimizations I need (in particular the sibling fusion), as it might need a graph like representation
13:48:49 <sclv> tibbe: what about a pass where you just let-float concatmaps out?
13:49:16 <sclv> so that you bring them closer.
13:50:01 <Enigmagic> byorgey: http://hackage.haskell.org/package/graphviz-2999.17.0.1/docs/src/Data-GraphViz-Commands-IO.html#runCommand ?
13:50:57 <dzhus> why would comonad fail to install on my system? http://dpaste.com/0H8GDTB
13:51:32 <geekosaur> at a guess, you once did a cabal-dev install as root
13:51:58 <geekosaur> (the install path being a cabal-dev sandbox)
13:52:05 <dzhus> yep
13:52:11 <dzhus> how to fix this?
13:52:22 <sclv> tibbe: or is the problem now more narrowly how you write something that takes two ConcatMaps and turns them into a ConcatMap2 ?
13:52:45 <geekosaur> you are *probably* safe just doing sudo chown -R $USER /home/carma/carma/srv/cabal-dev
13:52:54 <geekosaur> since nothing in that sandbox has any business being owned by root
13:53:30 <sclv> the answer there is obvious -- you introduce a ConcatMap2 that just "secretly" has 2 concatmaps inside, and when you want to run it, you "operationally decode" that into the proper thing.
13:54:08 <dzhus> geekosaur: this helped, thanks!
13:56:27 <simukis_> how much can we generate with TH? I know we can generate at least function bodies with TH, but can we generate whole modules?
13:58:05 <Fuuzetsu> @pl parseFile f = readFile f >>= \c → return (f, decodeState c)
13:58:06 <lambdabot> (line 1, column 14):
13:58:06 <lambdabot> unexpected " "
13:58:06 <lambdabot> expecting operator
13:58:25 <Fuuzetsu> @pl parseFile f = readFile f >>= \c -> return (f, decodeState c)
13:58:25 <lambdabot> parseFile = liftM2 (>>=) readFile ((return .) . (. decodeState) . (,))
13:58:30 <frerich> Is there a way (e.g. via Hoogle) to search for functions which have a constraints on some type class? E.g. ‘Give me functions which deal with types which are instances of Monoid’?
13:58:52 <Fuuzetsu> new Hayoo just launched so maybe take that into consideration too
13:59:06 <dzhus> simukis_: you can't produce imports with TH
13:59:17 <pavonia> @hoogle Monoid a => b
13:59:20 <lambdabot> Did you mean: :: b
13:59:20 <lambdabot> Prelude undefined :: a
13:59:20 <lambdabot> Test.QuickCheck discard :: a
14:00:18 <benzrf> :t discard
14:00:20 <lambdabot> a
14:00:23 <benzrf> > discard
14:00:25 <lambdabot>  *Exception: DISCARD. You should not see this exception, it is internal to Qu...
14:00:30 <benzrf> intristing
14:03:24 <dv-> @more
14:08:18 <solidus-river> what would arrow notation look like to step every wire in a list
14:08:43 <solidus-river> most places i see it done they make a custom wire that manually stepwires but i wonder if theres a better way of doing that / cleaner where you feed it jus tthe input instead of using stepwire
14:10:18 <Andrey_> Hi, could anyone please explain how I could specify where to save binary with cabal build? Right now it save my file in dist/build/<projname>/<binary>. Instead, I want <binary> to be in parent directory of where "cabal build" was called
14:11:27 <Andrey_> or at least in the same directory where cabal build was called
14:13:46 <byorgey> Enigmagic: thanks, but that's much too low-level.  In particular I wanted to use something like 'graphToGraph' but use a command that I specify.  Some digging revealed that the command that gets used is hard-coded into the implementation of graphToGraph.
14:13:58 <byorgey> So I just copied the relevant source code and modified it for now.
14:15:11 * hackagebot DAV 0.8 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.8 (ClintAdams)
14:16:33 <apricity> I just finished reading chpt 1 of lyah and after programming the right triangles exercise I was wondering: does the order of predicates in a list compression matter?
14:16:44 <HeladoDeBrownie> apricity, yes.
14:16:52 <merijn> HeladoDeBrownie: Really? Why?
14:16:58 <edwardk> dzhus: /home/carma/carma/srv/cabal-dev/lib/x86_64-linux-ghc-7.6.3/comonad-4.2.2/Control: permission denied -- looks like something globally broken on your machine, comonad is just the canary in the coal mine
14:17:11 <apricity> just performance wise, or result wise also?
14:17:24 <HeladoDeBrownie> Well, the earlier ones get computed first. It's like the difference in ordering of a guard expression in a do expression.
14:17:31 <hexagoxel> Andrey_: you looked at "cabal help build" and "cabal help install"? (--builddir, --bindir)
14:17:44 <merijn> oh, right I guess it matters if you have a really expensive conditional
14:18:04 <HeladoDeBrownie> But more importantly other things can come between the guards, like variable bindings, and then it definitely matters.
14:18:51 <merijn> apricity: In the simple case like the LYAH examples it'd only matter performance wise
14:19:11 <apricity> ok, I'll take your word for it now. I don't understand exactly yet, but I think I'll get there
14:19:14 <Andrey_> hexagoxel: i did, when I try to specify parent directory like so --bindir=../ it gave an error
14:19:29 <merijn> apricity: tbh, list comprehensions are not used all that much in my experience
14:19:40 <merijn> apricity: I used to use them everywhere in python, but not really in haskell
14:19:55 <HeladoDeBrownie> They're good to learn, still, especially if you can figure out how they relate to do expressions
14:20:00 <merijn> Sure
14:20:10 <merijn> But I wouldn't worry about understanding really complex ones
14:20:14 <HeladoDeBrownie> Yeah
14:20:17 <HeladoDeBrownie> I'd agree
14:20:22 <merijn> Because almost no one writes anything other than trivial ones :)
14:20:30 <hexagoxel> Andrey_: ah yes, --bindir might need absolute path, i noticed that too
14:21:57 <Andrey_> hexagoxel: the reason I need this, i because I'm trying to deploy on heroku, so I need it in main parent because I need the program to access public/ folder
14:22:09 <hexagoxel> `pwd`/../ is rather ugly :D
14:22:21 <orion> When I run haddock I get: "Warning: Crypto.KDF.Scrypt: could not find link destinations for: Crypto.Internal.Scrypt.scrypt" <-- That function is exported, but the module is /not/ exposed in the cabal file. How can I get rid of this warning?
14:23:15 <apricity> hmmm chpt 2 is on types. I don't want to stop reading and it's way past my bedtime.
14:23:17 <geekosaur> orion: what version of haddock? I think there have been bugs related to that
14:24:06 <Fuuzetsu> geekosaur: that kind of message is not Haddock's problem
14:24:20 <geekosaur> link destinations?
14:24:31 <Fuuzetsu> usually something (cabal) needs to coordinate better to pass it everything
14:24:32 <geekosaur> that's not ld type linker, it's <a href> in generated haddocks
14:24:39 <orion> Haddock version 2.14.3
14:24:48 <c_wraith> orion: I'd just ignore it.
14:24:53 <orion> :<
14:24:57 <Fuuzetsu> I'd also ignore it if the doc comes up properly
14:25:05 * orion is pedantic
14:25:06 <geekosaur> but yes, might be best to just ignore it. handling that stuff properly is difficult
14:25:16 <Fuuzetsu> check for typo and whether the module can see the function
14:25:33 <osa1> is there a way to tell cabal to ignore all the upper bounds?
14:25:47 <geekosaur> specifically in cases like this where internal modules are referenced but not exported (e.g. hidden constructors)
14:25:54 <geekosaur> (not that htis is one)
14:25:57 <luite> osa1: --allow-newer
14:26:23 <c_wraith> orion: alternatively, export the module. I'm a huge proponent of exporting all modules with some of them clearly documented HERE BE DRAGONS
14:26:37 <osa1> thanks
14:26:40 <orion> c_wraith: Why?
14:26:43 <Fuuzetsu> oh, I came here to ask something; say I have ‘Map k (Either a b)’, how can I safely get to ‘Map k b’? At the moment my idea is to filter or Lefts in the values and then do unsafe extraction from remaining Rights knowing that Right is all that should be left but it doesn't feel clean
14:26:56 <c_wraith> orion: because it lets people do things with your packages that you didn't imagine.
14:27:00 <Fuuzetsu> (say if my filter fails and leaves a Left in there)
14:27:34 <bitemyapp> :t either
14:27:36 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:28:05 <Fuuzetsu> that doesn't do what I want, it's no different to Map.map
14:28:23 <bitemyapp> Fuuzetsu: what's the part that's bugging you, that it's unsafe?
14:28:48 <Fuuzetsu> bitemyapp: after filter I'd have Map.map (\case { Right x → x ; Left _ → error "can never happen ;^)" })
14:28:50 <bitemyapp> Fuuzetsu: it sounds a bit like catMaybes
14:28:54 <Fuuzetsu> I want to avoid the error all together
14:29:11 <bitemyapp> Data.Foldable crossed with a catEithers?
14:29:28 <Fuuzetsu> @hoogle catEithers
14:29:29 <lambdabot> No results found
14:29:35 <bitemyapp> Fuuzetsu: you'd have to write it, yes.
14:29:43 <bitemyapp> Fuuzetsu: is your goal to drop the Either wrapper during filtering?
14:29:52 <Fuuzetsu> well, if I could get that then that'd be great
14:30:06 <c_wraith> Fuuzetsu: don't you want something like Data.Map.mapMaybe?
14:30:13 <Fuuzetsu> perhaps, let me have a look
14:30:18 <c_wraith> or maybe mapMaybeWithKey
14:30:58 <Fuuzetsu> oh, it has mapEither
14:31:14 <Fuuzetsu> I could do that and ditch the fst element of the pair
14:31:29 <Fuuzetsu> :t mapEither id
14:31:30 <lambdabot>     Not in scope: ‘mapEither’
14:31:31 <lambdabot>     Perhaps you meant one of these:
14:31:31 <lambdabot>       ‘IM.mapEither’ (imported from Data.IntMap),
14:31:31 <c_wraith> :t M.mapMaybe $ either (const Nothing) Just
14:31:33 <lambdabot> M.Map k (Either a b) -> M.Map k b
14:31:35 <Fuuzetsu> :t M.mapEither id
14:31:37 <lambdabot> M.Map k (Either b c) -> (M.Map k b, M.Map k c)
14:32:23 <vojta> Is there any way to update ghc installed with the Haskell Platform?
14:32:37 <shachaf> Just install your own GHC.
14:32:38 <Fuuzetsu> I think I like the mapEither way better
14:32:49 <vojta> I have the latest Haskell Platform, but my ghc is still 7.6.3
14:32:55 <bitemyapp> vojta: instructions here: https://github.com/bitemyapp/learnhaskell
14:32:58 <vojta> (I need 7.8.x)
14:32:59 <bitemyapp> vojta: install your own GHC+Cabal
14:33:01 <vojta> thanks
14:33:04 <Fuuzetsu> vojta: there's new HP coming out very soon, you could wait
14:33:05 <Andrey_> vojta: you can install new haskell platform RC
14:33:06 <Fuuzetsu> that comes with 7.8.3
14:33:08 <shachaf> The "Haskell Platform" is just GHC+a bunch of packages.
14:33:12 <bitemyapp> vojta: they might as well get off it now.
14:33:15 <bitemyapp> errr
14:33:18 <osa1> hm --dependencies-only and --reinstall don't work together
14:33:19 <bitemyapp> Fuuzetsu: they might as well get off it now.
14:33:22 <shachaf> You can install GHC and then install the packages you need yourself.
14:33:55 <Fuuzetsu> bitemyapp: that's just your opinion on HP, they're not here to be convinced otherwise or they would have asked how to get off it
14:34:09 <bitemyapp> Fuuzetsu: I've talked to Mark about it at length.
14:34:30 <Fuuzetsu> and did he go ‘yep, tell everyone who comes by to not use HP’?
14:34:30 <bitemyapp> Fuuzetsu: we agree on the nature of the problems but he's committed to keeping it going for the people that use it or need it, especially Windows users.
14:34:42 <bitemyapp> Fuuzetsu: he does not disagree with me that it's less compelling for Mac or Linux users.
14:34:43 <josephle> bitemyapp: does your tutorial have instructions on how to get off HP?
14:34:53 <bitemyapp> josephle: it just never tells you to use it to begin with.
14:35:02 <bitemyapp> I don't think I even bring it up except as a possibility for windows users.
14:35:15 <bitemyapp> it tells you how to do various distro-supported and vanilla installs of GHC+Cabal
14:35:36 <bitemyapp> Fuuzetsu: I've gotten a lot of people going with Haskell. I used to tell them to use platform.
14:35:47 <bitemyapp> Fuuzetsu: it is based on a lot of painful experience that I no longer tell them to do so. There way *too many problems*
14:35:59 <bitemyapp> Fuuzetsu: when I stopped telling people to use Platform, the problems went away.
14:36:05 <sclv> others, such as me, use the platform happily.
14:36:16 <bitemyapp> sclv: which is fantastic, but I'm working with an n greater than 1
14:36:18 <sclv> this is an area where there are many decent approaches
14:36:22 <bitemyapp> and I have to do what works for the students.
14:36:25 <bitemyapp> and doesn't trip them up
14:36:27 <sclv> i'm not saying "stop"
14:36:34 <sclv> i'm saying others have other experiences too
14:36:37 <bitemyapp> sclv: I know full well there are people happy with Platform.
14:36:46 <sclv> right -- i'm not saying it for your benefit
14:36:56 <sclv> i'm saying it because this is a conversation in front of 1400 people in this channel
14:37:00 <bitemyapp> the way I put it is this
14:37:06 <bitemyapp> if you're using Platform and you're happy with it, stick with it.
14:37:10 <bitemyapp> if you have a choice, don't.
14:37:16 <bitemyapp> if you have Windows, it's a hard choice.
14:37:19 <bitemyapp> or harder, anyway.
14:37:30 <sclv> i also am happy with platform on os x
14:37:34 <sclv> i know others have other experiences
14:37:44 <sclv> and now we have this nifty one click installer
14:37:45 <bitemyapp> If you're using one of the distros that has good support for vanilla GHC/Cabal installs you should probably just do what the distro supports (such as Arch Linux)
14:37:52 <sclv> while before it was go through a more painful process if not platform
14:38:03 <Shamar> hi, I changed edited a cabal file to introduce a new Configuration Flags, but looks like cabal is ignoring it
14:38:10 <bitemyapp> sclv: ghcformacosx is also a one-click installer :)
14:38:11 <sclv> i agree on linux and distros being a different case
14:38:18 <sclv> bitemyapp: right. that's new and awesome
14:38:23 <sclv> and it may well change my mind
14:38:31 <solidus-river> jle`: is there a way to form a wire that expects a list of wires and steps them all with input based on a list without using a manual fmap of stepwire?
14:38:33 <bitemyapp> sclv: it doesn't need to change your mind. You're fine with Platform.
14:38:33 <sclv> but i've been trusting the platform without problem for years
14:38:46 <bitemyapp> sclv: the problem is new people face-planting into unnecessary conflicts that don't know how to cope yet.
14:38:48 <Shamar> here is the edited cabal with a new Flag section https://github.com/Shamar/SFML/blob/master/SFML.cabal
14:38:54 <bitemyapp> sclv: you're not new! You'll be fine :)
14:39:09 <solidus-river> jle`: where i see ocharles do it and where i see you do it in your examples (if i'm remembering right) you do a stepwire within a wire as a map, wondering if theres a way to form that using arrow notation thats a bit cleaner and doesnt need to keep track of the dt
14:39:22 <kosmikus> the platform (ideally) serves a purpose also for Linux distros, as a guideline for library versions to package. so platform vs. Linux distro isn't supposed to be mutually exclusive.
14:39:34 <bitemyapp> sclv: really we're all doing it wrong anyway. I'm told we should all join the NixOS valhalla :)
14:40:18 <solidus-river> aye, i use the ebuilds on gentoo and everything is great and happy
14:40:43 <bitemyapp> solidus-river: right.
14:40:45 <solidus-river> but i've tried to set up my friend with the platform on ubuntu and just gave up and downloaded / built
14:41:05 <bitemyapp> solidus-river: next time you help an Ubuntu user, see if you can use hvr's PPA linked in my guide
14:41:07 <tulcod> Shamar: we'll need some more information
14:41:11 <bitemyapp> solidus-river: it's pretty clean, works great, and is kept up to date.
14:41:37 <tulcod> Shamar: you're basically saying "this is how i have it right now, but it's not doing what i want"
14:41:46 <tulcod> Shamar: what is it not doing? what's wrong?
14:41:46 <tulcod> etc
14:42:01 <solidus-river> bitemyapp: :) awesome!, that will definitely make them happier
14:42:19 <bitemyapp> solidus-river: specifically: https://github.com/bitemyapp/learnhaskell#ubuntu
14:43:15 <solidus-river> what do happy / alex do again?
14:43:25 <MitchellSalad> lexer and parser generators
14:43:36 <tulcod> bitemyapp: so i'm one of these arch users, and i wouldn't even be able to tell you which one (HP or GHC+cabal) it is - presumably the latter. what do you htink about haskell packages depending on in-repo libraries?
14:43:39 <solidus-river> is it considered better than parsec?
14:44:08 <solidus-river> or am i confusing different things
14:44:17 <bitemyapp> tulcod: I don't have an informed opinion here.
14:44:22 <Andrey_> How would I run cabal from directory where there is no .cabal file, from parent for example?
14:44:24 <MitchellSalad> well, alex is a parser generator, while parsec is a parser combinator library
14:44:41 <bitemyapp> MitchellSalad: alex is a lexer, happy is a parser generator, parsec is a parser combinator library.
14:44:49 <MitchellSalad> right, other way around
14:44:55 <Shamar> tulcod, I added the flag; according to http://www.haskell.org/cabal/users-guide/developing-packages.html cabal should try with false and then with true
14:44:56 <vojta> Thank you!
14:45:03 <solidus-river> ok so happy will generate what i would manually write in parsec
14:45:08 <solidus-river> what's alex's role in the process?
14:45:18 <Shamar> but it doesn't...
14:45:20 <bitemyapp> solidus-river: lexing and parsing are often two different phases.
14:45:27 <solidus-river> or i guess maybe i'm still confused and hsould wikipedia those terms
14:45:29 <bitemyapp> solidus-river: cf. tokenization
14:45:35 <bitemyapp> solidus-river: probably, yes.
14:45:42 <Shamar> oh, nevermind: removing the Default line made it works as expected
14:45:43 <bitemyapp> solidus-river: best way to learn is to play around.
14:45:47 <MitchellSalad> solidus-river: have you used flex/bison?
14:45:52 <kosmikus> solidus-river: happy will not generate what you'd write in parsec. parser generators and parser combinators in general use very different algorithms.
14:46:05 <solidus-river> neg but my next project will need to parse unreal engine 3 animation models and i was planning on diving into parsec for that
14:46:07 <kosmikus> solidus-river: whether you prefer one or the other is mostly a matter of taste.
14:46:12 <solidus-river> if alex / happy will make that process happier i should look at them
14:46:45 <MitchellSalad> i would start with parsec if you're a beginner, alex/happy are much harder to use and the documentation is old and lacking. i've used them both
14:47:16 <merijn> Oh, bah, is the new platform out yet?
14:47:17 <trap_exit> ha! so I think I just wrote an in-memory datastore with transactions + listeners in < 200 liens of haskell
14:47:27 <trap_exit> "define the datatypes; everything else follows" is amazing
14:47:32 <MitchellSalad> let's see it!
14:47:55 <bitemyapp> solidus-river: supposedly parser generators like Happy are faster. I don't know how it compares with something like Attoparsec though.
14:47:57 <trap_exit> it's spread across 3 files, and only compiles right now
14:48:01 <trap_exit> let me make sure it actually works first :-)
14:48:10 <benmachine> merijn: I think no but all the release candidates are basically finalised
14:48:16 <bitemyapp> solidus-river: http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.html
14:48:20 <bitemyapp> quote: "Most ‘real’ parsers are built using bottom-up parser generators like happy. This is mostly for reasons of speed but also because most parser libraries are written for research and inadequate for practical applications. Parsec is designed as a ‘real world’ library from scratch:
14:48:22 <benmachine> just needs to be actually shipped
14:48:53 <solidus-river> i'm down to go with whichever is most readable / concise by someone coming into a project
14:49:00 <solidus-river> s/by/for/g
14:49:14 <bitemyapp> solidus-river: does performance matter?
14:49:24 <merijn> benmachine: I just found out I accidentally killed my existing install by upgrading OSX (even though I didn't update Xcode yet, it nuked the links in /usr/bin)
14:49:45 <bitemyapp> solidus-river: if not, use Trifecta or Parsec, depending on your error handling needs.
14:49:48 <benmachine> merijn: :(
14:49:56 <bitemyapp> solidus-river: if performance does matter, consider Happy or Attoparsec. And benchmark!
14:50:04 <benmachine> install everything in $HOME, what could go wrong
14:50:27 <josephle> bitemyapp: the tradeoff is that parser generators are slightly tricker to use for nonregular syntax, iirc
14:50:48 <bitemyapp> josephle: Interesting. I don't really know. Thanks for sharing that.
14:51:11 <sclv> @tell tibbe -- well you need a bunch of passes. float up, merge, then push back down. also, you can have multiple phases, starting dynamic, going static. http://www.cse.chalmers.se/~emax/documents/axelsson2014efficient.pdf
14:51:12 <lambdabot> Consider it noted.
14:51:41 <MitchellSalad> josephle: do you mean having to manually expand kleene-star rules, or something?
14:51:47 <solidus-river> thanks for the info :) i'll start playin around with them, not too worried about performance though, its a one time cost of loading stuff into records
14:52:12 <solidus-river> not parsing an input stream or anything
14:52:27 <bitemyapp> MitchellSalad: not necessarily. NFA are still regular.
14:52:30 <josephle> MitchellSalad: I think in the presence of syntax that requires "state" (e.g. C with typedefs), it requires a little bit of hacking to get around
14:53:23 <josephle> this is hearsay from my compilers class, where some people chose to use happy+alex. I opted for parsec
14:53:53 <Andrey_> How to specify with cabal which directory to compile?
14:53:58 <MitchellSalad> oh, well, happy has first-class support for state
14:54:29 <MitchellSalad> and also you can put state in the lexer monad
14:55:13 <MitchellSalad> it's sort of hard to piece together though, i built a python lexer and had to keep track of indentation level
14:55:48 <benzrf> lexing is bull
14:55:50 <benzrf> just parse
14:55:55 <benzrf> emirit
14:55:56 <benzrf> e
14:56:24 <josephle> MitchellSalad: I didn't know that! Maybe I'll use happy+alex the next time I need to parse some complicated grammar :)
14:56:31 <sclv> for complex grammers sometimes a lexing pass helps sort things out, mentally
14:56:40 <sclv> just seperates concerns, etc
15:10:18 * hackagebot pub 2.0.0 - Pipe stdin to a redis pub/sub channel  http://hackage.haskell.org/package/pub-2.0.0 (ParnellSpringmeyer)
15:10:20 * hackagebot pandoc-types 1.12.4.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.4.1 (JohnMacFarlane)
15:10:30 <bitemyapp> why is mapM also in Data.Traversable?
15:12:01 <int-e> @type Data.Traversable.mapM
15:12:02 <daneeklu> isn't that because it is much more general?
15:12:02 <bitemyapp> I guess it looks a lot like traverse.
15:12:02 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:12:07 <int-e> @type mapM
15:12:08 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:12:26 <daneeklu> it works on many things, not just lists
15:12:32 <glguy> bitemyapp: Because the Applicative as a superclass of Monad proposal isn't done yet
15:12:49 <glguy> so sometimes you'll only have a Monad instance to work with while traverse works on Applicatives
15:13:05 <bitemyapp> That makes sense. thanks.
15:13:56 <int-e> glguy: hmm? the instances for [] are the only ones that matter in this particular case, aren't they?
15:14:15 <Apocalisp> is there a data structure that is a free Abelian group?
15:14:19 <glguy> Data.Traversable.mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:14:37 <glguy> Control.Monad.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:14:51 <glguy> int-e: Data.Traversable generalizes the list in this case
15:15:07 <bitemyapp> Apocalisp: vector space?
15:15:09 <glguy> But neither of those two operations is using the Monad instance for lists
15:15:16 <int-e> glguy: yes. and [] is traversable.
15:15:19 * hackagebot pub 2.0.1 - Pipe stdin to a redis pub/sub channel  http://hackage.haskell.org/package/pub-2.0.1 (ParnellSpringmeyer)
15:15:57 <int-e> glguy: I don't know why you brought up applicatives above.
15:16:17 <glguy> int-e: traverse and mapM are the same except for the Monad / Applicative difference
15:16:32 <glguy> traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:16:48 <int-e> glguy: ah. thanks.
15:16:49 <glguy> int-e: bitemyapp 's question is in the context of Data.Traversable
15:17:15 <glguy> yw :)
15:17:20 <bitemyapp> Apocalisp: "More generally, every lattice forms a finitely-generated free abelian group.[2]"
15:18:17 <bitemyapp> Apocalisp: that seems a reasonable definition since we call [] the free monoid and it has the same limitation.
15:19:26 <Apocalisp> bitemyapp: link?
15:20:20 <mitchty> is there a way to make cabal not use $HOME for its .cabal dir?
15:20:22 <bitemyapp> Apocalisp: you're going to hate me: http://en.wikipedia.org/wiki/Free_abelian_group
15:20:53 --- mode: ChanServ set +o glguy
15:20:54 --- mode: glguy set -o+b glguy $a:beaky$#haskell-ops
15:21:14 <bitemyapp> Apocalisp: I wasn't sure based on the article if two-dimensional lattices of integers only formed the free abelian group because they contained numbers or not, but the quote I offered you seemed like what you wanted.
15:21:15 <geekosaur> mitchty: I think you always have to have a ~/.cabal/config but that can point everything else to somewhere else (the official Mac H--P installer does this)
15:21:52 <mitchty> geekosaur: hrm, thats annoying as this home dir is read only,
15:22:06 <geekosaur> I'm surprised that doesn't break other things
15:22:25 <bitemyapp> Apocalisp: the only lattice stuff I'm aware of are the abstract algebra libraries and LVish.
15:22:28 <geekosaur> you'd be well advised to `export HOME=/path/to/a/writable/directory`
15:22:37 <codehero> how can i set cc-options with cabal?
15:22:48 <benzrf> the heck is a lattice
15:23:15 <mitchty> geekosaur: tried that first tbh. >.<
15:23:29 <mitchty> guess its time to look at source
15:23:41 <monochrom> a lattice is a partial order plus guarantee that binary (or finitary) least-upper-bounds and greatest-lower-bounds are defined
15:24:03 <bitemyapp> Apocalisp: incidentally, groups can be nice for conveying the importance of laws, because the inversion operation's types aren't very expressive. It only means something with the presence of laws.
15:24:05 <geekosaur> mrr. is it using directory services to get the home directory? that would be unfortunate
15:24:11 <geekosaur> (and I'm not sure it's justifiable)
15:24:20 <bitemyapp> monochrom: does a lattice form an abelian group?
15:24:28 <bitemyapp> monochrom: parametrically?
15:24:43 <monochrom> no, it doesn't even include any notion of "inverse"
15:24:56 <bitemyapp> monochrom: I wonder what the wiki article is on about then. Any idea?
15:25:08 <akurilin> question: is there a modern alternative to hstats out there that will work with haskell2010?
15:25:20 <monochrom> binary lub and glb are associative, so you do get two monoids
15:25:56 <monochrom> but monoid can't possibly do lattices justice.
15:26:25 <monochrom> where is the wiki article?
15:26:54 <codehero> can somebody tell me how to pass cc-options to cabal?
15:27:02 <bitemyapp> monochrom: http://en.wikipedia.org/wiki/Free_abelian_group http://books.google.com/books?id=6I1setlljDYC&pg=PA182#v=onepage&q=abelian%20group&f=false
15:28:07 <tulcod> codehero: ... set the cc-options variable in your .cabal file?
15:28:11 <monochrom> ok, "integer lattice" just refers to the grid Z^n
15:28:18 <josephle> codehero: what do you mean cc-options?
15:28:24 <josephle> do you mean commandline options?
15:28:30 <monochrom> no partial order. it's just the grid sense of "lattice"
15:28:32 <codehero> https://github.com/jmillikin/haskell-ncurses/commit/d71c9d6c7cab0045803a0d589ec6ce475e533c86
15:28:35 <codehero> here in the last file
15:28:46 <codehero> + cc-options: -DHSNCURSES_NARROW_HEADER
15:28:52 <benmachine> you can form an abelian group out of boolean algebras, which are a kind of lattice
15:28:59 <codehero> and i want the building stuff to get this option
15:29:09 <benmachine> in the order-theory sense, I mean
15:29:12 <monochrom> it is regrettable that two mathematical communities contend for the same word
15:29:19 <tulcod> codehero: so... how does that code not suffice?
15:29:38 <codehero> well. it complains about the ncursesw.h not being there
15:29:49 <codehero> and that option should fix it
15:30:19 <benmachine> monochrom: go look at a word like "normal", and be thankful it is as few as two :P
15:30:21 <monochrom> but we programmers get the same thing for "functor"
15:31:10 <tulcod> codehero: so is your OS darwin?
15:31:15 <codehero> no
15:31:18 <codehero> it's archlinux
15:31:28 <josephle> codehero: gotta get rid of that "if" then :)
15:31:33 <tulcod> ..
15:31:46 <josephle> darwin is os x, not archlinux
15:31:55 <codehero> and how do i do that?
15:32:04 <josephle> do you have access to the .cabal file?
15:32:47 <codehero> well. i just did "cabal install ncurses"
15:33:21 <merijn> Eh, 1) why do you wanna use an OSX compatibility config on linux and 2) don't use ncurses, use vty and vty-ui
15:33:48 <tulcod> codehero: so do you have the ncurses C library installed?
15:33:53 <codehero> yes i do
15:34:05 <merijn> codehero: See my last remark
15:34:13 <trap_exit> where can I read a good tutorial on GHC.Generic vs other options for data generic programming?
15:34:42 <codehero> oh. vty?
15:34:45 <geekosaur> modern code should not be referring to ncursesw.h anyway, how long has it been since wide-character support was merged into ncurses proper?
15:35:15 <merijn> codehero: It's a pure haskell library for ncurses type things
15:35:21 <codehero> oh
15:35:22 <merijn> codehero: vty-ui adds widgets, etc. to it
15:35:31 <codehero> okay. well i'll take a look at that
15:35:49 <tulcod> codehero: do you have /usr/include/ncurses.h ?
15:35:57 <codehero> tulcod: yes i do
15:36:09 <tulcod> ok, just checking
15:36:17 <trap_exit> what are the tradeoffs that GHC.Generics and Data.Data chose to make?
15:36:55 <tulcod> codehero: i don't have any ncursesw headers either. may wanna contact the package maintainers
15:37:23 <codehero> well, that's actually okay like that. the ncursesw headers are compatible to the ncurses ones
15:37:30 <codehero> that switch was deliberate
15:38:30 <daneeklu> is it possible to use generics to implement a typeclass for "oracles" which can answer questions of arbitrary types, with different answer types (given a Question typeclass)?
15:39:20 <daneeklu> I realize the question may be confusingly formulated, but the types in question are straightforward: http://pastebin.com/f9fQhpZy
15:39:29 <codehero> okay i think i fixed it
15:39:42 <codehero> cp with --preserve=all seems to work :P
15:40:10 <codehero> it's definitely not pretty but meh
15:40:14 <merijn> daneeklu: What is the point of a question class if it has no functions/values in it?
15:40:35 <eacameron> is it possible to pass paths to cabal configure to use (paths to .so files, for example)?
15:40:51 <merijn> eacameron: "cabal help configure"
15:41:07 <daneeklu> merijn: different oracles may answer the same question in different ways
15:41:34 <merijn> daneeklu: Right, so parameterise "answer" over both oracle and question?
15:41:45 <daneeklu> for instance, if the "oracles" are elements in a heterogenous list, we may want to filter out all objects which answer in a certain way
15:42:21 <eacameron> merijn: ahh, I see --extra-lib-dirs=PATH; that will help. is there a more general way to just pass *variables* of some sort to the cabal setup?
15:42:40 <merijn> daneeklu: Why not: http://lpaste.net/108954 ?
15:42:44 <daneeklu> merijn: this may or may not solve the problem, I have been thinking about this problem so my brain is a bit hot
15:44:49 <Pythonfant> Is there a way to get a more precise error message from peristent than: SQLite3 returned ErrorConstraint while attempting to perform step.
15:47:07 <trap_exit> yo! what am I doing wrong here? https://gist.github.com/anonymous/ab8a1767fd6df671ffe3 ... I'm trying to say (if Diffable a, Diffable b) ==> then Diffable (a, b)
15:47:45 <merijn> trap_exit: You don't have an error anywhere?
15:47:50 <daneeklu> merijn: optimally, the type of answer would be decided by the question, not the oracle
15:48:11 <trap_exit> copmpiler error: https://gist.github.com/anonymous/a7b16703048893c9157c
15:48:23 <daneeklu> but that might still possibly work, with a minor modification
15:48:42 <merijn> daneeklu: Right, then delete the o parameter to Answer from my example
15:49:24 <trap_exit> https://gist.github.com/anonymous/27347c29089f6fb2ac49 <-- wtf am I doing wrong?
15:49:40 <merijn> trap_exit: Probably you want "instance (Diffable d1 o1, Diffable d2 o2) => Diffable (d1, d2) (o1, o2) where"?
15:50:19 <daneeklu> after some minor experimentation, it seems to work. Feel a bit silly now that I didn't get it to work earlier
15:50:24 <trap_exit> merijn: was not aware you could put type class requirements inside of a insatnce
15:50:25 <daneeklu> thanks a bunch
15:50:28 <trap_exit> merijn: that fixed it; thanks!
15:50:29 <merijn> trap_exit: Also, the standard doesn't allow type annotations in instance declarations
15:50:42 <merijn> trap_exit: Hence the error in your last paste
15:50:53 <merijn> There's a GHC extension that allows it, but I forget what it is
15:50:56 <trap_exit> merijn: err? https://gist.github.com/anonymous/6327d7195ee47a2fb1fd compiled?
15:51:01 <trap_exit> https://gist.github.com/anonymous/6327d7195ee47a2fb1fd compiled, no question mark
15:51:17 <daneeklu> merijn: no wait, there was one other thing earlier, which may complicate things
15:51:25 <merijn> trap_exit: That one doesn't have a type annotation in the instance :)
15:51:38 <daneeklu> optimally, an oracle would respond with Nothing for any question, even without having to be instantiated
15:51:54 <Shamar> can I cabal install a package in a specific directory?
15:52:00 <daneeklu> hence why I ventured into generics (like using SYB), and didn't want to parametrize the oracle over type
15:52:03 <merijn> trap_exit: Anyway you can think of "instance Foo a => Foo [a]" as "[a] is an instance of Foo IFF 'a' is an instance of Foo"
15:52:09 <Shamar> something like --prefix in autoconf
15:54:40 <merijn> daneeklu: I don't understand what you mean
15:55:05 <daneeklu> merijn: basically, assume you have lots of different question types
15:55:11 <qnikst> hello, I have a question about typelevel nats and quasi-quotes, should following code work: let a = 3 in [| Proxy :: Proxy $a |] (it doesn't typecheck for me), however [| Proxy :: Proxy 3 |] works
15:55:37 <daneeklu> and you only want to create an instance for those oracles who can give a valuable answer
15:55:55 <merijn> qnikst: In the former "a" is a term, you can't put arbitrary terms into types
15:56:15 <daneeklu> assume we have a single StupidOracle, which should be able to accept questions of any type, but always reply with Nothing
15:56:35 <qnikst> merijn: however I think I can put integers there
15:56:43 <daneeklu> so the best would be if this Oracle wouldn't have to be defined instance for every new type of question
15:56:45 <qnikst> and a is known to be integer
15:56:53 <merijn> qnikst: No, you can't put integers there
15:57:17 <merijn> qnikst: You can put TYPES of KIND Nat, there. These happen to look identical to integer literals, but they are not
15:57:24 <merijn> :k 3
15:57:25 <lambdabot>     Illegal literal in type (use DataKinds to enable): 3
15:57:32 <merijn> oh, no DataKinds? :(
15:57:36 <qnikst> merijn: I see
15:57:59 <daneeklu> (in SYB this is easy to do for different question types, as long as the answer type is the same across all question types)
15:58:22 <qnikst> is there a way to do smth like what I want?
15:59:15 <qnikst> marienz: i.e. I have an Integer that was calculated by a function and I want to create a type of kind Nat that has "the same value" (not sure how to say it properly)
15:59:28 <qnikst> at compilation time of cause
16:02:42 <osa1> any ideas why I'm not getting any outputs when I run my app with +RTS -hc -hbdrag,void ? I'm trying to test LDV profiling but I guess I'm missing something because generated log file is always empty(only a header is printed)
16:07:13 <danilo2> Hello! Is there a way in Haskell to extract the base type of a variable? I want just a function, which will work like this (extractBase (A 1 2 3)) -> (Proxy :: Proxy A), where A could have some type variables or not. for example - data A a = A a a a
16:07:53 <qnikst> merijn: thanks, I found a way to do what I want
16:08:41 <pavonia> danilo2: The value of Proxy must have kind *, no?
16:08:53 <benzrf> :k Proxy
16:08:54 <lambdabot> k -> *
16:08:58 <benzrf> > Proxy Maybe
16:09:00 <lambdabot>  Not in scope: data constructor ‘Maybe’
16:09:03 <benzrf> er
16:09:07 <benzrf> :k Proxy Maybe
16:09:08 <lambdabot> *
16:09:20 <pavonia> Hhm
16:09:30 <pavonia> :k Proxy Either
16:09:32 <lambdabot> *
16:09:37 <pavonia> Okay
16:09:56 <trap_exit> merijn: iFF is not true; [a] is a monoid without a being a monoid
16:10:42 <danilo2> pavonia, benzrf: It could work because of PolyKinds. Anyway - how we can do it ?
16:15:37 <merijn> trap_exit: Right, but the monoid instance for [a] is "instance Monoid [a]", not constraint
16:15:54 <danilo2> pavonia, benzrf: do you have any ideas? :)
16:16:23 <pavonia> Not really, maybe you can use the generics module
16:17:31 <pavonia> Apparently this is where Proxy is defined >.>
16:17:40 <StoneToad> is there somewhere I can keep up to date with the new platform release?
16:18:04 <danilo2> pavonia: Hmm, ok. I do not know generics well. But mayube this is a way to go. Proxy is defined in Data.Typeable just as data Proxy a = Proxy (with PolyKinds)
16:35:26 * hackagebot aig 0.1.0.0 - And-inverter graphs in Haskell.  http://hackage.haskell.org/package/aig-0.1.0.0 (RobertDockins)
16:40:26 * hackagebot abcBridge 0.10.0.0 - Bindings for ABC, A System for Sequential  Synthesis and Verification  http://hackage.haskell.org/package/abcBridge-0.10.0.0 (RobertDockins)
16:40:54 <solidus-river> hmm, is there syntax to map input over a list of arrows
16:42:21 <benzrf> solidus-river: map ($v) [f, g, ]
16:42:22 <benzrf> solidus-river: map ($v) [f, g, h]
16:42:31 <benzrf> solidus-river: ooooor,
16:42:33 <solidus-river> $v?
16:42:53 <benzrf> :t let f = undefined :: a -> b in sequence `asAppliedTo` [f]
16:42:54 <lambdabot> [a -> b] -> a -> [b]
16:43:19 <benzrf> solidus-river: ($v) is a section of ($)
16:43:36 <solidus-river> :t ($)
16:43:38 <lambdabot> (a -> b) -> a -> b
16:43:44 <solidus-river> :t ($v)
16:43:46 <lambdabot> (Expr -> b) -> b
16:43:50 <solidus-river> what package is that from?
16:43:58 <solidus-river> is that in Prelude?
16:45:20 <geekosaur> wwhich?
16:45:54 <solidus-river> so your saying this is true?
16:45:54 <geekosaur> `$v` there is just the ($) operator applied to a predefined simple-reflect binding in lambdabot
16:45:56 <solidus-river> http://lpaste.net/108960
16:46:47 <solidus-river> oh i recognize the $ now, lol, not used to seeing it as ($)
16:47:07 <solidus-river> i dont think that does what i'm lookin fro but i also don't understand what that does do
16:47:44 <geekosaur> ($x) for some value x is a function which takes a function and applies it to the value x
16:47:44 <solidus-river> i'm looking to emulate 6 -> 10 of that paste in a way that i can think of the number of applications of $v to the arrows as just mapping over a list of the arrows
16:48:07 <geekosaur> because ($) is just function application with an odd fixity
16:48:21 <solidus-river> oh so
16:48:49 <solidus-river> http://lpaste.net/108960
16:48:52 <solidus-river> is more accurate?
16:49:39 <geekosaur> I kinda don't "do" arrows; proc notation doesn't mean anything to me. Sorry
16:49:48 <solidus-river> darn
16:50:32 <geekosaur> > map ($v) [f,g,h]
16:50:34 <lambdabot>  No instance for (GHC.Show.Show b0)
16:50:35 <lambdabot>    arising from a use of ‘M174954907427399145212867.show_M1749549074273991452...
16:50:35 <lambdabot>  The type variable ‘b0’ is ambiguous
16:50:35 <lambdabot>  Note: there are several potential instances:
16:50:35 <lambdabot>    instance [safe] GHC.Show.Show
16:50:37 <geekosaur> bah
16:50:47 <geekosaur> what ti should have said was:
16:50:56 <geekosaur> [f v, g v, h v]
16:51:00 <solidus-river> > map ($1) [3+,4+,5+]
16:51:02 <lambdabot>  A section must be enclosed in parentheses thus: (3 +)A section must be enclo...
16:51:13 <solidus-river> > map ($1) [(3+),(4+),(5+)]
16:51:15 <lambdabot>  [4,5,6]
16:51:21 <solidus-river> lol
16:52:10 <solidus-river> > map (+1) [3, 4, 5]
16:52:12 <lambdabot>  [4,5,6]
16:52:18 <Fuuzetsu> sometimes I write some code and just go ‘man, Haskell is great’
16:52:41 <solidus-river> i'm really curious if $input will work over a list of wires, excited to try that when i get home
16:53:07 <solidus-river> i've never really thought about what it is to step a wire as a combination out side of proc notation
16:53:25 <solidus-river> if that works it would be cool but i'm thinking i might need to get in it with *** and &&&
16:54:00 <benzrf> Fuuzetsu: hella
16:54:12 <benzrf> > map ($v) [f,g,h] :: Expr
16:54:14 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
16:54:14 <lambdabot>              with actual type ‘[b0]’
16:54:15 <benzrf> > map ($v) [f,g,h] :: [Expr}
16:54:17 <benzrf> > map ($v) [f,g,h] :: [Expr]
16:54:17 <lambdabot>  <hint>:1:26: parse error on input ‘}’
16:54:18 <lambdabot>  [f v,g v,h v]
16:54:21 <benzrf> there
16:54:24 <Fuuzetsu> you should see my hspec/QC properties
16:54:38 <solidus-river> haha
16:54:50 <Fuuzetsu> prop "can start all torrents" $ withRtorrentFiles stopTorrent $ \d → allStarted <$> afterRunning d startTorrent `shouldReturn` True
16:54:54 <Fuuzetsu> it's beautiful ;_;
16:57:44 <solidus-river> interesting i need to play around with arrows in ghci this seems very do-able though
16:57:48 <solidus-river> arrow notation is wierd
17:05:40 <thinkpad20> hey guys, can anyone help me understand Aeson and lens? I'm trying to read tel's tutorial here (https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms) but it's not really sinking in. A big problem is that lens error messages are so incredibly inscrutable :(
17:05:58 <trap_exit> are there yet
17:06:00 <thinkpad20> For example: `*Main Data.Aeson.Lens Data.Aeson> "{\"a\": [1, 2, 3], \"b\": 200}" ^? _Object . key "a"`
17:06:00 <trap_exit> any ghc extensilns
17:06:03 <trap_exit> for dependent types?
17:06:11 <thinkpad20> gives me `No instance for (AsValue (HashMap Text Value))`
17:06:17 <thinkpad20> what does that mean?
17:06:59 <thinkpad20> also what if I wanted a lens into a Value, not a string?
17:07:25 <glguy> thinkpad20: You're using Data.Aeson.Lens?
17:07:31 <thinkpad20> yes
17:07:31 <Fuuzetsu> @pl f g h j k = g >>= \i -> h i j k
17:07:31 <lambdabot> f = (. ((flip .) . flip)) . (.) . (.) . (>>=)
17:07:55 <thinkpad20> for example, this works: `"{\"a\": [1, 2, 3], \"b\": 200}" ^? key "a" . _Array` but this doesn't `"{\"a\": [1, 2, 3], \"b\": 200}" ^? key "a" . _Array . nth 0`
17:08:27 <thinkpad20> I get an "No instance for (AsValue (Vector Value))" error
17:08:56 <glguy>  "{\"a\": [1, 2, 3], \"b\": 200}" ^? key "a" . nth 0
17:09:19 <glguy> When you use _Array you get the actual Vector at which point you'd need to use the generic indexing traversal "ix"
17:09:31 <glguy> "nth" is Data.Aeson.Lens magic for nth aeson value thing
17:09:50 <thinkpad20> why isn't a Vector of Values an instance of AsValue?
17:10:43 <glguy> AsValue instances are actual Aeson Values and things that can be parsed into them
17:11:37 <thinkpad20> but isn't it trivial to transform a vector of values into a Value? :|
17:12:08 <glguy> That's what _Array is for
17:12:15 <glguy> _Array :: Prism' t (Vector Value)
17:12:21 <thinkpad20> OK, well I guess I'll let that be :P
17:12:26 <glguy> There are examples of how to use the combinators in http://hackage.haskell.org/package/lens-4.3.3/docs/Data-Aeson-Lens.html
17:12:31 <thinkpad20> so why doesn't this work: `decode "{\"a\": [1, 2, 3], \"b\": 200}" ^? key "a"`
17:12:47 <Total_1mmersion> Why isn't there a pure or return for Functor?
17:12:47 <thinkpad20> yeah I'm going through that now, but it's exceedingly confusing to a lens beginner
17:13:04 <glguy> thinkpad20: decode returns a Maybe
17:13:22 <glguy> Maybe Value, that is
17:13:41 <thinkpad20> so wouldn't it just fail? I mean, if the `decode` fails, then the `^?` would also fail, right?
17:14:11 <glguy> ^? doesn't quite work like that
17:14:20 <thinkpad20> Yeah I guess I don't really know what it does
17:14:29 <glguy> ^? returns either Just the first result folded by the right argument
17:14:30 <thinkpad20> `(^?) :: s -> Getting (First a) s a -> Maybe a` makes no sense :P
17:14:39 <glguy> or a Nothing when the right argument doesn't fold anything
17:15:02 <glguy> That takes an 's' and a way to turn 's's into 'a's and gives you back Just the first one or Nothing
17:15:32 <thinkpad20> So isn't that just a `Prism' s a`?
17:15:48 <glguy> Getting is different than a prism on two levels
17:16:27 <glguy> Getting is one of the types that things are instatiated to, it picks the type constructor to run things in, in this case "Const (First a)"
17:16:28 <kvanb> trap_exit: no
17:16:36 <kvanb> but you can simulate it kinda using GADTs
17:16:40 <glguy> Prism is something you build and which can be instantiated at any type that satisfies its constraints
17:17:00 <glguy> type Prism s t a b =  (Choice p, Applicative f) => p a (f b) -> p s (f t)
17:17:07 <glguy> type Getting r s a = (a -> Const r a) -> s -> Const r s
17:17:19 <thinkpad20> ... T_T
17:17:34 <glguy> you can use a prism as a "getting"
17:17:50 <glguy> Right True ^? _Right
17:17:52 <glguy> > Right True ^? _Right
17:17:54 <lambdabot>  Just True
17:18:02 <thinkpad20> what's the r in getting
17:18:20 <glguy> It's the thing you get back when you're getting something
17:18:30 <thinkpad20> so result ok
17:18:33 <thinkpad20> and the s?
17:18:34 <glguy> newtype Const r a = Const r
17:18:43 <glguy> The 's' is the thing you're getting things out of
17:18:57 <thinkpad20> then what's the a?
17:19:40 <glguy> That's the thing you're actually visiting when you're getting that 'r'
17:19:52 <trap_exit> GADTs can not say this index is within range of this list
17:20:05 <thinkpad20> huh? so do you get back an a, or an r?
17:20:14 <thinkpad20> or is it an a wrapped in an r?
17:20:17 <glguy> You typically don't get to pick those two things independently
17:20:24 <glguy> (^?) :: s -> Getting (First a) s a -> Maybe a
17:20:35 <glguy> You're getting "First a"s when you visit "a"s
17:20:38 <glguy> with that combinator
17:21:11 <glguy> :t First . Just
17:21:12 <lambdabot> a -> First a
17:21:48 <glguy> :t \l s -> getFirst (l (First . Just) s)
17:21:49 <thinkpad20> why does First exist; isn't it just a Maybe?
17:21:49 <lambdabot> ((a1 -> First a1) -> t -> First a) -> t -> Maybe a
17:22:01 <glguy> it exists so you can pick the Monoid instance that makes sense for it
17:22:14 <glguy> Maybe has a different monoid isntancd
17:22:15 <hpc> like Sum/Product
17:22:30 <thinkpad20> blargh
17:22:46 <thinkpad20> so much to keep in my head
17:23:07 <glguy> You don't have to worry about the fact that it uses First
17:23:10 <glguy> That's an implementation detail
17:23:36 <thinkpad20> "implementation details" ==> error messages that make no sense
17:24:37 <glguy> > let s ^? l = getFirst (getConst (l (Const . First . Just) s)) in [1..10] ^? folded
17:24:39 <lambdabot>  Just 1
17:25:34 <shachaf> It's unfortunate that lens has to expose so much of its implementation details in user-visible types.
17:26:34 <thinkpad20> > :t getConst
17:26:36 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:26:56 <thinkpad20> f u lambdabot :|
17:27:09 <glguy> :t getConst
17:27:10 <lambdabot> Const a b -> a
17:27:19 <thinkpad20> lol thanks
17:27:25 <glguy> It's a bot, you can't hurt its feelings..
17:31:27 <Fuuzetsu> she's a fragile bot ;_;
17:32:00 <hpc> @botsnack
17:32:00 <lambdabot> :)
17:34:42 <bitemyapp> what's the state of affairs with datetime libraries? Is there a nice one that pulls together the functionality you'd want in a unified, clean way?
17:34:47 <bitemyapp> I'm only really familiar with stdlib.
17:35:19 <Fuuzetsu> hm, I thought I was writing out N files for this test but it turns out I was trying to write out n^n which is not great for n = 100000 ;)
17:35:26 <hpc> i use a combination of time and locale
17:35:35 <hpc> one of them is "old-$foo" and i forget which
17:35:40 <bitemyapp> hpc: is that satisfactory?
17:36:01 <hpc> it's got the time format string functions i need
17:36:03 <bitemyapp> hpc: http://hackage.haskell.org/package/old-locale ?
17:36:10 <hpc> and built-in rfc822 and such strings
17:48:28 <hpc> bitemyapp: yeah, that's it
17:49:09 <hpc> between those two packages there's a whole bunch of disorganization, but the main pieces of a good time library are there
17:49:54 <carter> they work nice as long as you import the top level module rather than the bits and pieces
17:51:04 <bitemyapp> not really what I want.
17:51:12 <carter> whats your goal?
17:51:18 <bitemyapp> carter: hpc: http://crsmithdev.com/arrow/
17:52:04 <carter> whats your use case
17:52:32 <bitemyapp> carter: the point is to have a nice unified story for timezone, locales, timestamp parsing
17:52:42 <bitemyapp> carter: what as my use-case for Bloodhound?
17:52:47 <bitemyapp> was*
17:52:58 <carter> idk, i don't use elastisearch
17:53:41 <carter> :)
17:53:59 <bitemyapp> carter: the point is, I didn't really have one.
17:54:07 <bitemyapp> carter: the absence of a good API irritated the ever-loving out of me.
17:55:17 <carter> ask ryan trinkle for some opinions
17:55:25 <carter> his haskell shop is a business built around time
17:55:35 * hackagebot jvm-parser 0.2.1 - A parser for JVM bytecode files  http://hackage.haskell.org/package/jvm-parser-0.2.1 (RobertDockins)
17:55:42 <carter> cool parser
17:56:07 <carter> bitemyapp: i'm starting to plan out a time series sub lib
17:56:23 <carter> currently
17:56:32 <carter> well, not doing it yet, but planning it out
17:57:41 <carter> huh http://hackage.haskell.org/package/time-lens-0.4.0.1/docs/Data-Time-Lens.html looks ok
17:57:52 <carter> meh, barebones
17:58:15 <bitemyapp> carter: point isn't lenses :\
17:58:20 <carter> i know
17:59:55 <carter> hrm, would the idea be to give time a better skin?
18:00:24 <bitemyapp> carter: a bit more than that. Pull together the bits you generally need with date/time stuff.
18:00:33 <bitemyapp> carter: unify the API.
18:00:54 <carter> what other bits are needed?  (and unify which bits)
18:01:14 <bitemyapp> carter: http://crsmithdev.com/arrow/
18:01:17 <bitemyapp> carter: that's the checklist.
18:01:42 <bitemyapp> carter: I want to make certain I'm not missing something, that such a library doesn't already exist.
18:01:50 <bitemyapp> carter: we have a very nice language, we should also have very nice libraries.
18:01:54 <carter> yes
18:02:02 <carter> hrm
18:02:11 <bitemyapp> the problem is the type system and hackage have let us limp along with substandard APIs.
18:02:16 <bitemyapp> there's no cause for that.
18:02:18 <carter> time is REALLY hard
18:02:26 <bitemyapp> carter: it doesn't have to be me, it doesn't have to be now.
18:02:31 <carter> no
18:02:32 <bitemyapp> carter: I just want to know the current state of things on this.
18:02:37 <carter> its fundamentally hard
18:02:45 <bitemyapp> carter: I know that, I've been programming as long as you have.
18:02:46 <carter> nb: i'm not trying to discourage
18:02:48 <carter> true
18:02:49 <carter> ok
18:03:00 <carter> lemme phrase differently
18:03:04 <carter> lets toss around ideas
18:03:12 <carter> i'm happy to help brain storm
18:03:20 <shachaf> That doesn't look like a legal lens.
18:03:44 <carter> that too :)
18:10:07 <Arahael_> Hey, I'm still very much a novice, I am trying to get the new GHC 7.8.6 working on Ubuntu Linux.  However, when I install gtk2hs-buildtools using cabal, it fails because it depends on hashtables, which failed to install.
18:10:26 <Arahael_> The error seems to be that /usr/bin/ld cannot find -lHShashable-1.2.2.0-gh7.8.3, and I don't know why.
18:10:28 <bitemyapp> Arahael_: 7.8.3?
18:10:53 <Arahael_> bitemyapp: Err... Yes.
18:11:27 <Arahael_> It seems I have a .o file in ./.cabal/lib/hashable-1.2.2.0/ghc-7.8.3/HShashable-1.2.2.0.o
18:11:46 <Arahael_> Not sure why I don't have .so files, nor why it's not linking.
18:11:48 <carter> Arahael_: cabal --version
18:11:59 <carter> how did  you install ghc
18:12:13 <carter> 'which ghc'
18:12:17 <carter> 'type ghc'
18:12:23 <carter> "type cabal"
18:12:38 <carter> Arahael_: i'm on a mac and a bit stale on linux, but lets collect some basic infos first
18:12:44 <Arahael_> carter: I used the latest ghc on the website, the 'unknown' one built on debian.  'which ghc' shows '/home/haskell/bin/ghc'
18:12:50 <carter> cabal --version
18:13:29 <Arahael_> Cabal is 1.20.0.3, "using version 1.20.0.2 of the Cabal library'.
18:13:42 <carter> ok
18:13:44 <Arahael_> hang on, let meuse cut and paste.
18:13:49 <carter> Arahael_: no
18:13:50 <carter> @lpaste
18:13:51 <lambdabot> Haskell pastebin: http://lpaste.net/
18:13:55 <carter> paste to lpaste
18:14:19 <Arahael_> http://lpaste.net/9161542400626130944
18:14:58 <Arahael_> I already ran 'hash -r' to ensure I'm using the right ghc.
18:15:02 <carter> ok
18:15:04 <carter> now
18:15:15 <carter> heres what I what you do to do
18:15:31 <carter> you have a ~/.ghc folder right?
18:15:48 <Arahael_> Yes, I do.
18:15:51 <carter> waittt
18:15:56 <carter> Q: you're not running as root right?
18:16:15 <Arahael_> No, I'm doing everything as 'ihaskell', and my prefix is my home directory.
18:16:20 <Arahael_> Hence those aliases.
18:16:30 <carter> ok
18:16:43 <carter> could you lpaste your ~/.cabal/config file?
18:16:52 <Arahael_> The system does have an older version of .ghc though.
18:16:59 <carter> eh?
18:17:04 <carter> that don't matter
18:17:11 <carter> its ~/.ghc/$GHCVERSION
18:17:17 <carter> different versions ignore eachother
18:17:56 <Arahael_> I've amended the paste: http://lpaste.net/9161542400626130944
18:18:06 <pavonia> Can cabal handle different GHC versions in parallel?
18:18:27 <carter> pavonia: caba -w
18:18:32 <carter> cabal -W
18:18:34 <carter> or something
18:19:30 <pavonia> I take that as a yes
18:19:51 <Arahael_> pavonia: I would interpret that as a "yes, but possibly not by default".
18:20:16 <Arahael_> carter: Can you see anything in that config file?
18:20:38 * hackagebot aws-kinesis 0.1.1 - Bindings for AWS Kinesis Version 2013-12-02  http://hackage.haskell.org/package/aws-kinesis-0.1.1 (larsk)
18:23:03 <Arahael_> carter: Do most people use this on the mac? (Ie, is the mac better supported?)
18:25:54 <carter> lol, gtk works way better on linux
18:26:29 <benzrf> carter: i'd just like to interject for a moment
18:26:42 <carter> benzrf: you know linux, take over :)
18:26:59 * carter bows
18:27:37 <Arahael_> benzrf: Thanks - have you seen anything or do you have additional suggestions?
18:28:10 <benzrf> carter: i was just referring to the dumb internet meme
18:28:22 <benzrf> http://www.reddit.com/r/gnu/comments/hv56g/source_of_the_famous_id_like_to_interject_for_a/
18:28:30 <benzrf> Arahael_: i dont know, i dont use osx
18:28:35 <carter> benzrf: he's on linux
18:28:52 <carter> benzrf: lets shift memery to blah :)
18:29:10 <carter> Arahael_: ok, so when you do "ls ~/.ghc"
18:29:12 <carter> what do you get?
18:29:23 <carter> Arahael_: it does look like you have a 1.16 style cabal config
18:29:28 <carter> we can fix that easily
18:29:59 <Arahael_> carter: I'm happy to wipe and try again, would take all of ~5 min.
18:30:00 <carter> Arahael_: ok so first "rm ~/.cabal/config ; cabal update" ### this will give you a 1.20 style cabal config
18:30:12 <Arahael_> Excellent, will give that a go, rm'ing cabal alone.
18:30:12 <carter> show me the contents of config after you do that
18:30:16 <carter> noo
18:30:19 <carter> literally what i'm saying
18:30:21 <carter> i'm being literal
18:30:26 <carter> no creative interpretations
18:30:43 <benzrf>    
18:30:46 <Arahael_> carter: I'm doing just that. :)
18:30:59 <carter> you never ever want to rm ~/.cabal/ unless you really have a good reason
18:31:19 <carter> (basiclaly some stuff winds up depending on static files that live there, and then binaries you had suddenly break because they cant find a file)
18:31:25 <Arahael_> carter: This is a throwaway VM, built yesterday.
18:31:28 <carter> oh ok
18:31:29 <carter> well
18:31:41 <carter> i' assuming theres lurkers learning tricks
18:31:45 <carter> amidst the infinite scrollback
18:31:47 <carter> :)
18:31:49 <carter> ok
18:31:54 <carter> next rm ~/.ghc
18:32:00 <carter> then ghc-pkg recache
18:32:04 <benzrf> carter: n-nix
18:32:08 <carter> benzrf: yaks
18:32:15 <carter> nix seems reallly cool
18:32:16 <carter> but
18:32:17 <carter> yaks
18:32:20 <benzrf> yaks
18:32:20 <benzrf> what
18:32:23 <Arahael_> "yaks"?
18:32:32 <carter> yak shaving
18:32:40 <carter> at some point i should try out using nix
18:32:57 <carter> but recursively making everything i build reproducible isn't something thats a high priority this month :)
18:33:00 <carter> next month, maybe
18:33:07 <Arahael_> I don't know what that refers to.  Anyway, you're already using nix, via mac os x.  It's actually really, seriously similar, right down to the complex-as-all-heck dynamic linker.
18:33:23 <benzrf> Arahael_: what?
18:33:30 <benzrf> Arahael_: which part of osx is like nix
18:33:39 <monochrom> the "x" part :)
18:33:39 <benzrf> it doesnt come with a package manager o.O
18:33:43 <Arahael_> Anyway. How do I know I have a 1.20.x cabal config?
18:33:43 <benzrf> monochrom: :3
18:33:53 <Arahael_> benzrf: Neither does "unix".
18:33:59 <benzrf> Arahael_: u realize im referring to http://nixos.org/ and not *nix
18:34:00 <carter> Arahael_: nix == package manager, not *nix
18:34:10 <carter> benzrf: he didn't realize
18:34:13 <carter> because he just heard about it
18:34:13 <benzrf> ahihi:
18:34:14 <carter> :p
18:34:14 <benzrf> *ah
18:34:15 <Arahael_> Clearly.
18:34:31 <carter> *nix is "posix unix like thingamombs"
18:34:48 <Arahael_> Heh, anyway - curious. Anyway how do I confirm that I Have a 1.20.x cabal config?
18:35:02 <carter> lpaste into a new lpaste the contends
18:35:04 <carter> and show me
18:35:10 <cmccann> "yak shaving" is a term for the fiddly little problems you solve because they're needed to solve some slightly larger problem which is needed to make something else which is.... and then there's your actual goal, ten layers removed
18:35:17 <Arahael_> carter: The new config is larger than a screen buffer.
18:35:24 <carter> Arahael_: @lpaste the bugger
18:35:24 <benzrf> carter: everybody loves yak shaving
18:35:25 <carter> :)
18:35:31 <benzrf> its what im generally doing at any particular moment
18:35:39 <benzrf> i've really taken FP to heart, yknow
18:35:58 <benzrf> instead of spending any time doing the important things, i just break them into simpler pieces and spend most of my processing there
18:36:09 <carter> :)
18:36:16 <carter> Arahael_: no need to paste
18:36:18 <cmccann> a lot of nifty haskell libraries are made from woven yak hair harvested by edwardk
18:36:18 <carter> i trust its fine
18:36:27 <carter> cmccann: its soooo nice having you back on irc
18:36:53 <Arahael_> carter: http://lpaste.net/9161542400626130944
18:37:00 <cmccann> what, were you really lacking for ambiguously informative snarky commentary
18:37:07 <Arahael_> I've deleted the ~/.ghc, and rehashed it.
18:37:09 <benzrf> that's my specialty!
18:37:14 <carter> Arahael_: woot
18:37:15 <carter> ok
18:37:16 <gfixler> shave . shave . shave $ yak
18:37:16 <carter> sooooo
18:37:18 <carter> ohhhh
18:37:20 <carter> yeah
18:37:20 <carter> ok
18:37:30 <carter> Arahael_: actually, things might just work now
18:37:33 <carter> letstry!
18:37:41 <benzrf> hmm
18:37:47 <benzrf> is there something like replicateM for monoids
18:38:06 <carter> some sort of exponentationa?
18:38:07 <gfixler> repeat $ shave yak
18:38:15 <benzrf> cuz i was gonna yell at gfixler the the obvious better solution is to runEndo (replicateMon 3 (Endo shave)) yak
18:38:19 <benzrf> so much DRYer!
18:38:22 <Arahael_> carter: Giving that a go by installing cairo, which was the original package I was trying to install.
18:38:29 <carter> Arahael_: nooo
18:38:37 <carter> you need to install gtk2hsbuildtools first
18:38:38 <gfixler> benzrf: we need to make a way better yak shaver
18:38:54 <benzrf> gfixler: i just figured out what my acme-package will be
18:38:56 <carter> unless cair auto installs that
18:38:57 <benzrf> acme-yak
18:39:00 <gfixler> :)
18:39:12 <benzrf> it will contain helpful utilities for shaving your yak
18:39:20 <codehero> lol
18:39:20 <gfixler> hmmm
18:39:20 <Arahael_> carter: It doesn't from memory - or rather, it doesn't upgrade it.
18:39:26 <carter> ??
18:39:28 <carter> ok
18:39:29 <carter> well
18:39:30 <gfixler> benzrf: I think we should rethink how packages are managed first
18:39:30 <carter> yeah
18:39:34 <carter> lets get that done firs
18:39:38 <benzrf> gfixler: (☞ﾟ∀ﾟ)☞
18:39:41 <Arahael_> Now installing gtk2hs-buildtools
18:39:58 <gfixler> benzrf: HOWEVER, I don't want to do that until I'm up to speed in nixOS
18:40:01 <gfixler> gotta do this right
18:40:37 * gfixler reading about yaks on wikipedia
18:40:55 <Arahael_> carter: It's now actually building gtk2hs-buildtools, so things look to be working. :)
18:41:05 <carter> i was just cargo culting
18:41:09 <cmccann> benzrf: acme-yak should be a utility that generates a new version of itself
18:41:15 <carter> but glad it helped
18:42:00 <cmccann> benzrf: preferably with some other package that depends on it, which acme-yak should automatically bump the dependencies of so that it always requires the next version of acme-yak
18:42:22 <benzrf> huue hue hue
18:42:36 <Arahael_> carter: There does seem to be a fair bit of assumed knowledge or practices - bit of a learning/setup curve.  But thanks. :)
18:43:22 <carter> cmccann: wooah
18:43:23 <carter> buggy
18:43:44 <benzrf> acme-yak will provide powerful abstractions for managing the context in which your yak is being shaved, so that you know which yak to shave next
18:43:56 <benzrf> powerful enough that it's worth a bit of yak shaving to install it, of course
18:43:57 <benzrf> :-3
18:44:21 <gfixler> Can anyone help me install yakage?
18:44:32 <gfixler> it's saying I'm missing dependencies
18:44:40 <gfixler> one of which is yakage...?
18:47:34 <benzrf> ;)
18:47:42 <benzrf> gfixler: you need to bootstrap it
18:47:51 <benzrf> gfixler: step 1, acquire some boots
18:47:56 <gfixler> benzrf: my bootstrapping package arrived in the mail today!
18:48:07 <gfixler> it was two bags of silicon powder, one p-type and one n-type
18:48:16 <benzrf> gfixler: was the crowbar inside the box
18:48:17 <gfixler> I'm not sure what I'm supposed to do with it
18:48:39 <gfixler> benzrf: yes, but it's straight - I'm apparently supposed to bend it myself
18:48:52 <codehero> lol
18:48:52 <gfixler> I'm looking up rod bending machines atm
18:49:09 <cmccann> gfixler: at least you didn't get a lump of iron ore to start with
18:49:18 <gfixler> I'll be honest - this is a bit more work than I was originally expecting.
18:49:34 <gfixler> cmccann: you guys seem to be doing cool things, so I'm sticking with it
18:52:13 <codehero> the first half of the chapters of LYAH was so easy
18:52:21 <codehero> i could read through them so quickly
18:52:38 <codehero> and i just don't know if i'm going to remember anything of the current chapter...
18:52:52 <codehero> s/and/and now
18:52:58 <gfixler> codehero: which one are you up to?
18:53:04 <codehero> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
18:53:08 <codehero> it's so confusing
18:53:10 <codehero> and so much
18:53:15 <gfixler> it is a lot
18:53:19 <gfixler> I just got through that one
18:53:21 <gfixler> I'm in IO now
18:53:30 <codehero> heh. io sounds like fun
18:53:37 <gfixler> I reread the last bit on kinds about 15 times
18:53:43 <codehero> ^^
18:53:45 <codehero> afk. eating
18:53:54 <gfixler> IMO it throws way too much at you all at once
18:54:13 <gfixler> I realized kinds are really simple, but everything else it was doing to explain them was not
18:55:16 <swgillespie> I learned the most about kinds by playing around with :k in ghci
18:55:30 <swgillespie> i had to read that passage a bunch of times too and the interpreter really helped
18:55:39 <benzrf> gfixler: yep
18:55:49 <benzrf> gfixler: note that typeclass constructors have kinds too:
18:55:51 <benzrf> :k Num
18:55:53 <lambdabot> * -> Constraint
18:55:54 <benzrf> :-o
18:55:57 <benzrf> :k Functor
18:55:59 <lambdabot> (* -> *) -> Constraint
18:56:18 <gfixler> that seems a bit constraining
18:56:28 <benzrf> :-3
18:56:43 <benzrf> gfixler: you could think of (=>) as having kind `Constraint -> k -> k'
18:56:49 <benzrf> but it's not actually a real operator
18:56:54 <benzrf> entirely syntactic
18:56:55 <gfixler> I was actually never confused by kinds - all of the parts about kinds in LYAH made sense immediately
18:57:34 <gfixler> they were just shrouded in a bunch of other things
18:57:37 <benzrf> gfixler: DataKinds is a ghc extn that lets you define new kinds and what types inhabit them
18:57:41 <benzrf> exactly like at the type/value level
18:57:42 <gfixler> yaks and such
18:57:56 <benzrf> gfixler: have you seen GADTs
18:58:10 <gfixler> benzrf: I'm guessing DataKinds is almost never needed by normal people
18:58:18 <benzrf> yeah :-3
18:58:19 <gfixler> benzrf: have not seen GADTs
18:58:35 <benzrf> gfixler: ok well
18:58:40 <gfixler> Gallium Aluminum...
18:58:55 <benzrf> you know how normally you specify the types of data constructor arguments based on the arguments to the type constructor?
18:59:00 <gfixler> Great Abstract Data Types
18:59:01 <benzrf> the G is for Generalized
18:59:08 <gfixler> ah
18:59:12 <benzrf> A is for algebraic as usual
18:59:27 <gfixler> oh, right - that was another thing LYAH saddled me with
18:59:42 <gfixler> it mentions Abstract Data Types once at the top of a long chapter on typeclasses
18:59:50 <gfixler> and then way at the bottom it casually mentions ADTs
19:00:00 <benzrf> it's Algebraic
19:00:02 <benzrf> :v
19:00:04 <gfixler> sorry, Algebraic
19:00:06 <gfixler> see?
19:00:14 <gfixler> I had just read a Python book on Abstract Data Types
19:00:22 <benzrf> yea i write abstract all the time
19:00:26 <benzrf> but
19:00:29 <benzrf> 09:57 < benzrf> you know how normally you specify the types of data constructor arguments based on the arguments to the  type constructor?
19:00:44 <gfixler> yes
19:01:02 <benzrf> GADTs let you write what the final type of a constructor is based on its arguments
19:01:03 <gfixler> though it is not 9:57 here
19:01:20 <benzrf> for example, you can do this:
19:01:42 <benzrf> data ThisIsUseless a where LyingConstructor :: a -> ThisIsUseless [a]
19:01:48 <benzrf> @let data ThisIsUseless a where LyingConstructor :: a -> ThisIsUseless [a]
19:01:50 <lambdabot>  Defined.
19:01:55 <benzrf> :t LyingConstructor "foo"
19:01:57 <lambdabot> ThisIsUseless [[Char]]
19:02:04 <benzrf> :t LyingConstructor (3 :: Int)
19:02:06 <lambdabot> ThisIsUseless [Int]
19:02:45 <gfixler> and this is normal ADT stuff, right?
19:02:53 <benzrf> gfixler: look again
19:03:00 <gfixler> there's a where
19:03:00 <benzrf> you cannot define that behavior using regular ADTs
19:03:12 <benzrf> gfixler: GADT declarations use where and not =
19:03:17 <benzrf> and ; instead of |
19:03:28 <benzrf> gfixler: like a typeclass instnace
19:04:21 <gfixler> ah, you wrapped the a in a list
19:04:25 <benzrf> gfixler: not really!
19:04:27 <benzrf> look:
19:04:40 <benzrf> > let LyingConstructor v = LyingConstructor 10 in v
19:04:42 <lambdabot>  My brain just exploded
19:04:42 <lambdabot>  I can't handle pattern bindings for existential or GADT data constructors.
19:04:43 <lambdabot>  Instead, use a case-expression, or do-notation, to unpack the constructor.
19:04:44 <gfixler> well
19:04:45 <benzrf> oops.
19:04:59 <benzrf> > case LyingConstructor 10 of {LyingConstructor v -> v}
19:05:01 <lambdabot>  Couldn't match type ‘t’ with ‘GHC.Integer.Type.Integer’
19:05:01 <lambdabot>    ‘t’ is untouchable
19:05:01 <lambdabot>      inside the constraints ([GHC.Integer.Type.Integer] ~ [a])
19:05:01 <lambdabot>      bound by a pattern with constructor
19:05:01 <lambdabot>                 L.LyingConstructor :: forall a. a -> L.ThisIsUseless [a],
19:05:05 <benzrf> o-oops
19:05:11 <benzrf> looks like i messed something up
19:05:22 <benzrf> th-the point is that you *should* be able to pull the 10 right back out if you do it right
19:05:25 <gfixler> you broke lambdabot's mind
19:05:28 <benzrf> there isnt actually a list anywhere
19:05:29 <benzrf> only in the type
19:05:36 <benzrf> data ThisIsUseless a where LyingConstructor :: a -> ThisIsUseless [a]
19:05:40 <gfixler> whoa
19:05:49 <benzrf> i'm declaring that LyingConstructor has type `a -> ThisIsUseless [a]'
19:05:57 <benzrf> i can specify what type the constructor has instead of letting it be inferred
19:06:32 <gfixler> right
19:06:44 <benzrf> and that allows you to do this kind of complete bullshit:
19:06:44 <benzrf> @undef
19:06:45 <lambdabot> Undefined.
19:07:02 <benzrf> @let data TNil; data TCons head tail;
19:07:04 <lambdabot>  Defined.
19:07:38 <benzrf> @let data HList ts where HNil :: HList TNil; HCons :: a -> HList ts -> HList (TCons a ts)
19:07:40 <lambdabot>  Defined.
19:07:58 <benzrf> :t 3 `HCons` "foo" `HCons` Nothing `HCons` HNil
19:07:59 <lambdabot>     Couldn't match expected type ‘HList ts1’ with actual type ‘[Char]’
19:08:00 <lambdabot>     In the second argument of ‘HCons’, namely ‘"foo"’
19:08:00 <lambdabot>     In the first argument of ‘HCons’, namely ‘3 `HCons` "foo"’
19:08:03 <benzrf> wait a sec
19:08:08 <benzrf> oh
19:08:13 <benzrf> :t 3 `HCons` ("foo" `HCons` (Nothing `HCons` HNil))
19:08:15 <lambdabot> Num a => HList (TCons a (TCons [Char] (TCons (Maybe a1) TNil)))
19:08:21 <benzrf> gfixler: i have a list at the type level!
19:08:34 <gfixler> o_O
19:08:56 <benzrf> i could do this before, but having GADTs lets me specify that my cons constructor's result type conses the type of the new item onto the list of types of items
19:09:16 <benzrf> @let hlist =  3 `HCons` ("foo" `HCons` (Nothing `HCons` HNil))
19:09:17 <lambdabot>  Defined.
19:09:33 <benzrf> :t case hlist of HCons h _ -> h
19:09:35 <lambdabot>     Couldn't match type ‘t’ with ‘Integer’
19:09:35 <lambdabot>       ‘t’ is untouchable
19:09:35 <lambdabot>         inside the constraints (TCons
19:09:51 <benzrf> ok well it looks like i have to do something more to be able to pull the values back out >.>
19:09:58 <benzrf> but the *point* is that the type information is preserved
19:10:18 <gfixler> is this a closure type?
19:10:18 <benzrf> if i did a little more trickery, i could pass that around and still know the types of the items
19:10:23 <benzrf> gfixler: i dont think thats a word
19:10:27 <benzrf> or if it is, i dont know it
19:10:31 <gfixler> I made it up
19:10:34 <benzrf> ha
19:10:39 <benzrf> depends on what you mean by that
19:10:43 <benzrf> look closely at the data decl
19:10:52 <benzrf> data HList ts where HNil :: HList TNil; HCons :: a -> HList ts -> HList (TCons a ts)
19:11:03 <benzrf> first of all, i'm specifying that HNil has type HList TNil
19:11:12 <benzrf> normally it would be inferred to have type `HList a'
19:11:28 <benzrf> second, and more importantly, i'm declaring that HCons takes an a and an HList ts
19:11:35 <benzrf> and gives an HList (TCons a ts)
19:11:47 <benzrf> data TNil; data TCons head tail; -- remember
19:13:00 <benzrf> gfixler: when i say `HCons item existingList', it looks at the types of item and existingList and says that the type of the new cons is those types consed together
19:13:14 <gfixler> now I see
19:13:15 <benzrf> gfixler: you absolutely cannot do this with normal ADTs
19:13:27 <benzrf> not that you should want to :P
19:13:30 <benzrf> this is not all that useful
19:13:32 <gfixler> oh, I don't
19:13:32 <benzrf> but it's COOL AS FUCK
19:13:42 <gfixler> but normal ADTs infer things
19:14:49 <swgillespie> this is cool but also terrifying
19:15:04 <modeller> Hi. A Quick (beginner) Question: if backtick makes a prefix function infix, and bracket makes infix function prefix, then why the below function usage fails?
19:15:17 <modeller> (`subtract`) 1 2
19:15:19 <benzrf> swgillespie: as fun haskell should be =D
19:15:24 <swgillespie> benzrf: ^^
19:15:30 <benzrf> modeller: interesting
19:15:33 <benzrf> > (`subtract`) 1 2
19:15:35 <lambdabot>  <hint>:1:12: parse error on input ‘)’
19:15:47 <benzrf> modeller: i feel like ive heard that that's a bug before
19:15:59 <benzrf> > (`subtract` ) 1 2
19:16:00 <modeller> oh so it is a bug
19:16:00 <Cale> It's not a bug, it's just the syntax doesn't allow it
19:16:00 <lambdabot>  <hint>:1:13: parse error on input ‘)’
19:16:10 <modeller> is there any rationale behind it?
19:16:12 <Cale> Because the prefix version is simply subtract
19:16:41 <Cale> It would be an additional special case in the syntax
19:16:42 <modeller> I see. I was just curious for this extra usage
19:16:49 <Clint> for negative gain
19:17:00 <Cale> You *can* do:
19:17:09 <Cale> (`subtract` 4)
19:17:16 <Cale> > (`subtract` 4) 5
19:17:18 <lambdabot>  -1
19:17:21 <modeller> that's currying right?
19:17:28 <Cale> It's an operator section
19:17:38 <Cale> > (* 4) 5
19:17:40 <lambdabot>  20
19:17:45 <Cale> > (4 *) 5
19:17:47 <lambdabot>  20
19:18:07 <modeller> ok. maybe for now I will just memorize that not to use extra symbols :)
19:18:13 <Cale> You can do that with any infix operator
19:18:30 <modeller> i c. thanks
19:18:34 <Cale> (`op` y) becomes (\x -> op x y)
19:18:45 <Cale> and (x `op`) becomes op x
19:18:58 <Cale> (which is the same thing as (\y -> op x y)
19:19:01 <gfixler> > (- 1) 0
19:19:03 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
19:19:03 <lambdabot>    arising from the ambiguity check for ‘e_110’
19:19:03 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
19:19:03 <lambdabot>    bound by the inferred type for ‘e_110’:
19:19:03 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
19:19:19 <pavonia> @src subtract
19:19:19 <Cale> ... right, I should say, any except for (-)
19:19:20 <lambdabot> subtract x y = y - x
19:19:26 <modeller> will try lambda later
19:19:26 <gfixler> d'oh
19:19:38 <gfixler> > ((-) 1) 0
19:19:39 <Cale> Because we want (- 5) to mean negative 5 of course
19:19:40 <lambdabot>  1
19:19:50 <gfixler> > (1 (-)) 0
19:19:50 <Cale> and not the function which subtracts 5
19:19:51 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0 -> a0) -> a1 -> t))
19:19:52 <lambdabot>    arising from the ambiguity check for ‘e_110’
19:19:52 <lambdabot>  from the context (GHC.Num.Num ((a -> a -> a) -> a2 -> t),
19:19:52 <lambdabot>                    GHC.Num.Num a2,
19:19:52 <lambdabot>                    GHC.Num.Num a)
19:19:58 <platz> is there no prior art for transducers?  something like transduceMap :: (b -> a) -> (acc -> a -> acc) -> (acc -> b -> acc); transduceMap f = \reduceFn -> \acc el -> reduceFn acc (f el)
19:20:04 <Cale> So that's a special case
19:20:11 <platz> hoogle has no results for "(acc -> a -> acc) -> (acc -> b -> acc)"
19:20:13 <gfixler> > (1 -) 0
19:20:15 <lambdabot>  1
19:20:27 <Cale> > (+(-1)) 0
19:20:29 <lambdabot>  -1
19:20:56 <gfixler> Cale: is that required syntax for subtraction via sectioning?
19:21:19 <gfixler> I'm not sure why (- 1) can't work (it works in clojure)
19:21:23 <Cale> gfixler: Well, the subtract function exists as a kind of apology for that special case
19:21:51 <Cale> (- 1) doesn't work because unary minus was considered more important than the operator section
19:22:16 <Cale> > (- 1)
19:22:18 <lambdabot>  -1
19:22:26 <gfixler> odd - there's a space to delimit things
19:22:40 <Cale> Yeah, the space doesn't matter here
19:22:50 <gfixler> are spaces discarded in sections?
19:23:10 <Cale> In general, the only whitespace sensitivity that Haskell has is at the start of lines
19:23:23 <gfixler> but f x doesn't become fx under the hood, does it?
19:23:32 <Cale> Well, I suppose you could argue that it's pretty important to separate tokens in some way
19:23:43 <Cale> But (f)(x) for instance is no different from f x
19:24:07 <Sornaensis> functions all the way down
19:24:19 <gfixler> what is - really?
19:24:24 <Cale> gfixler: Two things
19:24:34 <Cale> There's unary negation, and subtraction
19:24:37 <gfixler> in Clojure, e.g., it's actually an identifier that points to a subtraction function
19:24:38 <MitchellSalad> template haskell sections are whitespace sensitive ($)
19:24:48 <Cale> Unary negations are replaced by the function negate
19:24:51 <Cale> :t negate
19:24:52 <lambdabot> Num a => a -> a
19:25:02 <Cale> :t (-)
19:25:03 <lambdabot> Num a => a -> a -> a
19:25:15 <Cale> So, -x means negate x
19:25:29 <Cale> while x - y means (-) x y
19:25:42 <gfixler> so it's really just an issue with sections
19:25:45 <Cale> yeah
19:25:48 <gfixler> and how they're parsed
19:25:57 <Cale> You can't use (-) in a left section
19:26:14 <gfixler> could we in theory?
19:26:20 <mwhit> platz: transduceMap f g acc = g acc . f -- it's just rearranged composition
19:26:22 <gfixler> I mean, would getting that to parse break something else?
19:26:26 <Cale> Sure, but we'd need to do something different with unary negation
19:26:37 <Cale> > -     5
19:26:39 <lambdabot>  -5
19:26:46 <Cale> > (\x -> - x)
19:26:48 <lambdabot>  <Integer -> Integer>
19:26:50 <Cale> > (\x -> - x) 4
19:26:52 <lambdabot>  -4
19:27:00 <mwhit> @pl f g h x = h x . g
19:27:00 <lambdabot> f = flip (flip . ((.) .))
19:27:18 <mwhit> @pl f g h x y = h x . g $ y
19:27:19 <lambdabot> f = flip (flip . ((.) .))
19:27:27 <codehero> lol
19:28:03 <gfixler> Cale: I see
19:28:03 <Cale> > (\x -> -x^2 + x + 1) (-1)
19:28:05 <lambdabot>  -1
19:28:12 <gfixler> we'd have to recognize the lack of spaces
19:28:21 <gfixler> as negation
19:28:24 <platz> hrm I yes it's easy to derive, but odd that this idea seems distant in the minds of haskellers in forums
19:28:26 <Cale> gfixler: and that gets weird
19:28:59 <mwhit> platz: composition is all over haskell code, this just doesn't seem like a particularly special form to be "on their minds"
19:29:26 <Cale> gfixler: Especially when the thing after the - isn't an integer literal
19:29:52 <gfixler> Cale: but doesn't - require a Num?
19:29:57 <Cale> You might on some occasion like to write  - foo x y  a little more than -foo x y
19:30:19 <Cale> especially as it means - (foo x y)
19:30:26 <gfixler> I'm starting to see
19:30:48 <gfixler> this is one thing I appreciate about lisps
19:31:07 <gfixler> syntax singularity
19:31:15 <Cale> It's sort of a consequence of inheriting this somewhat standard mathematical practice
19:31:20 <gfixler> I spent awhile getting comfy in clojure, then started trying haskell
19:31:26 <Cale> Where we use the same symbol for negation and subtraction
19:31:30 <Cale> because of their relationship
19:31:38 <gfixler> and one of the biggest things I noticed was all of the care surrounding syntax
19:31:46 <gfixler> parentheses, fixity, whitespace, etc
19:31:47 <platz> mwhit: makes sense
19:32:46 <gfixler> Cale: I'd actually be quite happy with a different symbol for negation
19:32:53 <Cale> Haskell's concrete syntax has some funny details, but for the most part these things result in code being easy to read unless you intentionally abuse them.
19:33:33 <gfixler> Cale: I mostly agree
19:33:38 <gfixler> it's fun to have some variety in syntax
19:33:42 <Cale> Adding whitespace sensitivity of that sort and making people pay close attention in that way to whether there's a space after each - sign would be awkward
19:33:46 <gfixler> and there are some very concise bits of code as examples
19:34:13 <Cale> and we don't have a particularly good other symbol available for negation
19:34:14 <gfixler> Cale: it wasn't until you added - foo x y
19:34:17 <gfixler> then I saw it
19:34:31 <Cale> I've seen some languages use _ for negation, but only in integer literals
19:34:46 <gfixler> well, Haskell already threw me with /=
19:34:55 <Cale> I suppose another option would be to always write negate
19:35:06 <swgillespie> gfixler: you should check out the ML family's not equal operator :p
19:35:14 <gfixler> =/= ?
19:35:17 <swgillespie> <>
19:35:21 <Cale> I think /= actually looks more like the standard symbol for not-equal-to than != does
19:35:27 <gfixler> haha
19:35:36 <gfixler> well, it makes sense at least
19:35:36 <Cale> ≠
19:35:37 <swgillespie> i still don't understand how <> means not equal :p
19:35:42 <mwhit> we should just go full unicode
19:35:52 <Cale> swgillespie: It makes sense if there's an ordering
19:35:59 <Cale> swgillespie: Less than or greater than
19:36:03 <gfixler> I want a 6 kilokey keyboard
19:36:18 <gfixler> shaped like a C around me
19:36:28 <gfixler> like that blue guy in the Mos Eisley space port
19:36:44 <swgillespie> sure, ok
19:36:45 <Cale> http://media.moddb.com/images/groups/1/3/2933/a.baa-Chinese-Keyboard..jpg
19:36:51 <gfixler> hehe
19:38:04 <mwhit> gonna start using ℝ and ℤ just to annoy people
19:38:51 <swgillespie> haha
19:38:57 <Cale> Using ℝ for Double is especially egregious
19:39:07 <mwhit> hmatrix does it now
19:39:16 <mwhit> it was indeed super annoying
19:39:37 <gfixler> mwhit is keeping it ℝ
19:40:19 * mwhit slow clap
19:40:37 <mwhit> also dot product is <·>, i mean what
19:40:40 <mwhit> that isn't a *
19:40:53 <Cale> "Let's take this symbol used to denote a Dedekind-complete ordered field, and use it to denote something with almost no meaningful algebraic structure."
19:41:44 <trap_exit> after reading classics like LYSH and RWH, what is the nxt step in haskell advancement, is it (1) write lots of ahskell code, (2) read lots of haskell code, or (3) ask lots of dumbass questions in #haskell ?
19:42:01 <Cale> trap_exit: All three?
19:42:03 <mwhit> all of the above
19:42:12 <swgillespie> i for one ask many dumbass questions
19:42:16 <mwhit> if you want more reading and strucgtured assignments there's
19:42:19 <mwhit> @where yorgey
19:42:19 <lambdabot> http://www.seas.upenn.edu/~cis194/lectures.html
19:42:26 <mwhit> less structured practice there's
19:42:27 <gfixler> trap_exit: I don't see anything in there about yaks
19:42:28 <mwhit> @where nicta
19:42:29 <lambdabot> https://github.com/nicta/course
19:42:43 <Cale> http://chimera.labs.oreilly.com/books/1230000000929 -- this might also make a good next book
19:42:44 <trap_exit> what's yaks ?
19:43:07 <trap_exit> Cale: first part of that book iks intense; 2nd part is readable
19:43:14 <Cale> Even if you're not interested in parallelism and concurrency, there's a lot of general performance-related stuff in that book.
19:43:25 <trap_exit> gfixler: waht's yaks?
19:43:45 <gfixler> trap_exit: it's yaks all the way down (the kind you shave)
19:43:46 <trap_exit> Cale: yeah, the type system encodes parallel strategy part is mind blowing ... even though I still do not understand it
19:43:55 <trap_exit> gfixler: I don't get it
19:44:08 <geekosaur> @google yak shaving
19:44:10 <lambdabot> http://en.wiktionary.org/wiki/yak_shaving
19:44:10 <lambdabot> Title: yak shaving - Wiktionary
19:44:23 <geekosaur> hm, I was hoping for hacker's dictionary...
19:44:33 <geekosaur> @hacker yak shaving
19:44:34 <lambdabot> YAK: 0.00 @ N/A N/A
19:44:34 <lambdabot> SHAVING: 0.00 @ N/A N/A
19:44:35 <julianb> uhm hi. Is there any way do something like: instance (Monoid m) => Functor (G m) where ...? (that as of itself does not compile)
19:44:36 <geekosaur> heh
19:44:43 <bitemyapp> geekosaur: what does hacker do?
19:45:12 <geekosaur> I thought we had hacker's dictionary as one of the @dict entries. no idea what that edit "corrected" to
19:45:15 * gfixler points out that his comment about yak shaving has caused yak shaving to commence
19:45:18 <bb010g> http://www.definitions.net/definition/yak%20shaving
19:45:22 <mwhit> @hacker geekosaur
19:45:22 <lambdabot> GEEKOSAUR: 0.00 @ N/A N/A
19:45:24 <geekosaur> (like autoincorrect but in your lambdabot)
19:45:26 <mwhit> hm
19:45:28 <bitemyapp> @hacker Cale
19:45:28 <lambdabot> CALE: 0.00 @ N/A N/A
19:45:29 <bb010g> One of those is Hacker's
19:45:29 <trap_exit> I don't get it; wtf
19:45:42 <mwhit> @where commands
19:45:42 <lambdabot> http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
19:46:00 <trap_exit> are there any particularly good haskell code bases worth reading ?
19:46:01 <geekosaur> trap_exit, "yak shaving" is a hacker culture reference, it means some task that needs to be done so you can do what you really wanted to do
19:46:04 <bb010g> The New Hacker's Dictionary
19:46:04 <bb010g>     yak shaving
19:46:04 <bb010g>     [MIT AI Lab, after 2000: orig. probably from a Ren & Stimpy episode.] Any seemingly pointless activity which is actually necessary to solve a problem which solves a problem which, several levels of recursion later, solves the real problem you're working on.
19:46:33 <Cale> @hacker GOOG
19:46:34 <lambdabot> GOOG: 566.374 +1.304 (+0.23%) @ 8/6/2014 4:00pm
19:46:37 <julianb> trap_exit, HaXL's is nice, although its not easy
19:46:38 <mwhit> oh, so "development"
19:46:48 <bb010g> @stocks GOOG
19:46:48 <lambdabot> Unknown command, try @list
19:46:51 <geekosaur> oh, I had no idea we had a "ticker" in LB these days
19:46:57 <Cale> @ticker AAPL
19:46:58 <lambdabot> AAPL: 94.96 -0.16 (-0.17%) @ 8/6/2014 4:00pm
19:47:15 <Cale> such spell correction
19:47:29 <mwhit> i didn't even know it tried spell correction
19:47:31 <trap_exit> man
19:47:34 <trap_exit> fb uses haskell?
19:47:36 <geekosaur> @seen foo
19:47:37 <lambdabot> foO
19:47:42 <Cale> trap_exit: yes
19:47:45 <geekosaur> which is really @leet aka @elite
19:48:07 <geekosaur> also @info which people keep trying to do, but LB sees @undo
19:48:09 <bb010g> @seen hacker
19:48:09 <lambdabot> H4CKer
19:48:17 <Cale> trap_exit: http://hackage.haskell.org/package/haxl
19:48:30 <Cale> trap_exit: note the Author field :)
19:49:59 <Cale> trap_exit: Simon Marlow, who is responsible for a lot of GHC code, works for Facebook now :)
19:50:37 <gfixler> I feel like Facebook would be hellish for a Haskeller
19:50:45 <Cale> Oh, also, Bryan O'Sullivan, who has produced a lot of popular libraries and is one of the authors of RWH
19:50:46 <orion> I'm concerned about hackage's lack of TLS.
19:51:49 <vozz> if you define a function in a function definition using where, and use some of the same names for the arguments, does that matter?
19:52:13 <mwhit> not unless you wanted to use the original ones in the where
19:52:16 <julianb> vozz, I think you'd shadow any recursive calls
19:52:20 <mwhit> or unless warnings bother you
19:52:23 <MitchellSalad> orion: what about tls?
19:52:30 <vozz> okay, cool
19:52:39 <MitchellSalad> this one http://hackage.haskell.org/package/tls
19:52:39 <orion> MitchellSalad: hackage doesn't use it
19:52:47 <MitchellSalad> oh that's what you mean, haha
19:53:00 <MitchellSalad> nevermind
19:53:16 <geekosaur> I think someone is working on it?
19:53:25 <Cale> orion: Code signing would be more appropriate than TLS, I think
19:53:31 <geekosaur> but I haven't heard a lot, and the hackage team is usually rather quiet about what it's up to
19:55:24 <Cale> But there's a trust issue there which no amount of cryptography is going to solve
19:56:22 <orion> Cale: TLS is needed for uploader credentiald.
19:56:24 <orion> credentials
19:56:32 <Cale> orion: Yeah, I suppose that's true
19:57:23 <codehero> :t even
19:57:24 <lambdabot> Integral a => a -> Bool
19:57:37 <Cale> It would be nice to know that the account that shows up in the Uploader field really did upload the thing.
19:57:51 <Cale> But I'm not sure how often people even pay attention to that.
19:59:08 <tac_> Are there any haskell libraries as intuitive as Python's datetime module?
19:59:32 <tac_> I need to do some datetime parsing and date manipulation.
20:02:32 <orion> "For instance testing some proposition over a value which simply returns a Bool value representing whether the branch can perform the computation safely in the presence of a null is subject to accidental interchange." -- anyone know a way to reword that and not change its meaning?
20:02:34 <swgillespie> How do infix operators get imported in a qualified import?
20:03:00 <orion> It's a ridiculously long sentence.
20:05:09 <geekosaur> extra parentheses, iirc
20:05:20 <AlecTaylor> hi
20:05:49 <AlecTaylor> How do I generate C code from Haskell? - Tried: ghc -ddump-llvm -ddump-to-file hello_world.hs && opt -O2 hello_world.dump-llvm | llc -O2 -march c -o hello_world.c
20:06:06 <AlecTaylor> But got: "llc: error: invalid target 'c'."
20:06:11 <geekosaur> swgillespie, e.g.: import Control.Applicative ((<*>))
20:06:12 <trap_exit> Cale: what? one of the three Simons works for fb now?
20:06:16 <trap_exit> damn
20:06:34 <ezrios> which simon
20:06:36 <bb010g> orion: "For instance, testing some proposition over a Bool value representing whether the branch can perform the computation safely in the presence of a null is subject to accidental interchange."
20:06:45 <geekosaur> the first set of parens is part of import syntax, the second is the way you normally refer to an operator as a function
20:06:47 <bb010g> A bit shorter.
20:06:50 <Cale> tac_: Use http://hackage.haskell.org/package/time
20:06:51 <swgillespie> geekosaur: What if i did "import Control.Applicative as App", how do I reference <*> then? App.<*>?
20:06:57 <geekosaur> yes
20:07:00 <swgillespie> geekosaur: import qualified, sorry
20:07:02 <swgillespie> ok
20:07:05 <trap_exit> is there a way to use ghci instead of hacakge + hoogle for eading docs?
20:07:21 <trap_exit> I'm looking for a tutorial on ghci to use the sourced code of the apckages I have installed to show me docs
20:07:23 <geekosaur> beware that if you are using it in a section, it is (App.<*>) not App.(<*>)
20:07:25 <trap_exit> instead of hackage + hoogle
20:07:26 <Arahael_> How do I tell cabal to install an older version of a package and re-install any of the dependencies that were impacted by the change?
20:07:36 <trap_exit> nixos
20:07:59 <Arahael_> I'm trying to get ihaskell-notebook working, and for some reason, I have a package that insists on using base==4.6
20:08:24 <merijn> AlecTaylor: Why do you wanna generate C code from Haskell?
20:08:43 <Cale> tac_: It's one of the better-designed time libraries I've seen. If it seems unintuitive, it's just because the various systems humans have come up with for coping with time are horrible. It's a good library though, and probably can do what you need it to.
20:08:47 <swgillespie> geekosaur: ah, that's what was tripping me up. thanks
20:08:55 <orion> bb010g: thanks!
20:08:58 <geekosaur> yeh, it's a very common mistake
20:09:26 <merijn> Qualified operators are silly, though
20:09:52 <AlecTaylor> merijn: Integrating with other languages through their FFIs (which only support C)
20:10:06 <merijn> AlecTaylor: Haskell directly has a C FFI you can use
20:10:16 <geekosaur> App.(<*>) means look for a constructor named App and compose it with the prefix-function form of the <*> operator
20:10:16 <Arahael_> AlecTaylor: You could also compile to javascript, iirc.
20:10:25 <AlecTaylor> emscripten?
20:10:35 <Arahael_> AlecTaylor: No... ghcjs or ghc-js or something.
20:10:41 <merijn> AlecTaylor: You can just compile haskell to a shared/static library and link that into C applications
20:11:00 <AlecTaylor> What's the command to do that?
20:11:32 <merijn> There's no command you just need to use "foreing import"/"foreign export" to generate the right symbols. GHC just produces .so/.a files you can link
20:11:47 <merijn> AlecTaylor: May wanna read the FFI chapter in the GHC manual
20:11:47 * AlecTaylor wants an .so
20:11:51 <jle`> geekosaur: isn't it (App.<*>) ?
20:12:03 <trap_exit> OMG http://dev.stephendiehl.com/hask/ is awesome
20:12:09 <merijn> AlecTaylor: Alternatively, GHC can also link C object files into haskell binaries
20:12:17 <AlecTaylor> Yeah, noticed that
20:12:20 <geekosaur> [07 03:05] <geekosaur> beware that if you are using it in a section, it is (App.<*>) not App.(<*>)
20:12:31 <jle`> ah i see. sorry :)
20:12:34 <geekosaur> then I expanded on what the latter means, which is not what people expect
20:12:37 <jle`> ..when is App.(<*>) even valid?
20:12:41 <carter> Arahael_: are you installing the RIGHT ihaskell?
20:12:41 <geekosaur> when I said
20:12:48 <carter> Arahael_: theres 2
20:12:49 <geekosaur> [07 03:08] <geekosaur> App.(<*>) means look for a constructor named App and compose it with the prefix-function form of the <*> operator
20:12:50 <jle`> ah
20:12:55 <carter> Arahael_: also cabal sanbox
20:13:00 <jle`> everything makes sense now, thanks :)
20:13:01 <carter> but ihakslel SHOULD work with 7.8
20:13:04 <jle`> that's tricky stuff
20:13:20 <jle`> having (.) be syntax and also be a valid operator has caused a lot of trouble, i've noticed
20:13:27 <geekosaur> yes, yes it has
20:13:28 <jle`> in enumeration syntax too
20:13:41 <merijn> jle`: Hence why people are not very enthusiastic about using . for record syntax
20:14:11 <AlecTaylor> merijn: Are the techniques here still accurate, or has the API changed? - https://github.com/nh2/haskell-from-python
20:14:44 <jle`> i am much against . for record syntax...is there a proposition about it being added?
20:15:43 <Fuuzetsu> I think it was overthrown already
20:16:15 <jle`> we should just have (.) not be a valid operator, and use the mathematical unicode composition ssymbol for composition.  but i think that'd actually be counted as a non-operator identifier
20:16:41 <bb010g> I feel that if . was used for record syntax, there should be a better way to have two different record types with identical accessor names. Even if it isn't, there should still be a better way.
20:17:00 <trap_exit> is there a haskell package for reading stuff in ~/.cabal and extracting (1) source code and (2) types?
20:17:07 <Arahael_> carter: Never crossed my mind that there were two...
20:17:11 <trap_exit> I'd like to write my own version of hoogle, called haidu
20:17:19 <Arahael_> carter: Which one is the "right" ihaskell? I'm using the one in cabal.
20:17:25 <merijn> AlecTaylor: There's a few things you need, I'll strip the basics from my own C file here
20:17:29 <Fuuzetsu> trap_exit: (1) and (2) are GHC API
20:17:32 <Fuuzetsu> also haskell-src-exts
20:17:36 <carter> https://github.com/gibiansky/IHaskell is the one
20:17:41 <trap_exit> ah, so I use actual compiler to parse haskell code
20:17:42 <trap_exit> i like this
20:17:44 <carter> Arahael_: the author is super duper repsonsive
20:17:57 <carter> you can build it in a cabal sandbox
20:17:58 <Fuuzetsu> trap_exit: you'll stop liking this when you realise GHC API is a pain in the ass to follow…
20:18:01 <Arahael_> carter: Is that the one in cabal?
20:18:06 <carter> "in cabal"
20:18:09 <carter> you mean hackage?
20:18:17 <carter> thats the only one thats actively deved
20:18:28 <trap_exit> Fuuzetsu: you mean it's an intelligence test to only ensure smart people work on ghc ?
20:18:32 <carter> http://hackage.haskell.org/package/ihaskell
20:18:44 <Fuuzetsu> trap_exit: y-yeah, sure, that's exactly what it is
20:18:44 <carter> trap_exit: you will probably wanna use cabal sandbox to build it
20:18:47 <carter> Arahael_:
20:18:55 <Arahael_> carter: Good, I'm using the right one then.  What do I get from the sandbox?
20:19:12 <carter> @google cabal sandboxes
20:19:13 <lambdabot> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
20:19:13 <lambdabot> Title: An Introduction to Cabal sandboxes
20:19:31 <Arahael_> carter: I can actually get ihaskell notebook to work quite nicely.  The pain comes in when I want to use ihaskell-display, ihaskell-charts, and the like.
20:19:38 <carter> Arahael_: well
20:19:41 * dfeuer pokes RULES in the eye.
20:19:51 <carter> dfeuer: i warned yah
20:20:04 <carter> do you start to see why rules needs richer machinery for things you want?
20:20:08 <Arahael_> carter: If I have a completely dedicated install of ghc, cabal, etcetera, shouldn't I be able to pretend that sandbox doesn't exist?
20:20:16 <carter> Arahael_: yes
20:20:25 <merijn> AlecTaylor: Minimal C file: http://lpaste.net/108969
20:20:27 <Arahael_> carter: Good.
20:20:34 <dfeuer> carter, I think I even read that RULES are (typically) applied from the inside out, which is backwards from sanity.
20:20:41 <merijn> AlecTaylor: Replace *all* occurences with the name of your haskell module
20:20:50 <carter> dfeuer: backwards how?
20:21:35 <AlecTaylor> merijn: Hmm
20:21:38 <Arahael_> carter: My latest hurdle was that ihaskell-charts depends on base==4.6
20:21:50 <dfeuer> Sanity, I believe, is to act more like a Schemish macro system and work from the outside in—the outside has more context to work with.
20:21:55 <carter> Arahael_: pester the maintainer to fix it
20:21:57 <dfeuer> I could be wrong though.
20:21:59 <carter> Arahael_: or bump the bounds
20:22:04 <carter> Arahael_: --allow-newer
20:22:05 <merijn> AlecTaylor: Corresponding haskell file: http://lpaste.net/108969
20:22:19 <Arahael_> carter: Eh?  I'll try that...
20:22:19 <carter> Arahael_: cabal has a magic/evil --allow-newer flag
20:22:22 <carter> :)
20:22:26 <carter> dfeuer: no
20:22:31 <carter> its not a macro system
20:22:32 <merijn> AlecTaylor: This means that inside main you can now call start_server and start_client, which will run the relevant haskell code
20:22:35 <carter> its a rewrite engine
20:22:39 <dfeuer> So?
20:22:49 <carter> dfeuer: explain why you think those are the same
20:22:51 <carter> :)
20:22:56 <dfeuer> I don't think they are the same.
20:22:59 <carter> ah
20:23:00 <carter> :)
20:23:03 <dfeuer> I think there are important similarities.
20:23:21 <carter> idk
20:23:36 <carter> i can see why you'd think that
20:23:43 <AlecTaylor> merijn: I think I am understanding it, just pushing everything together (this repository has 3 files, all under 15 lines) - https://github.com/nh2/haskell-from-python
20:24:01 <carter> dfeuer: riddle me this --- with rewrites i can stop any time and i'll still have a valid program right?
20:24:09 <carter> thats not true for scheme macros
20:24:10 <carter> right?
20:24:42 <bb010g> Don't Scheme macros work more like TH than RULEs?
20:24:45 <merijn> AlecTaylor: And for completeness' sake the cabal file to build the thing: http://lpaste.net/108969
20:24:47 <dfeuer> Oh, there are differences for sure, carter. And with Scheme macros you can't just reach in willy-nilly and act like something is a macro when it isn't. But there are definite similarities.
20:24:48 <benzrf> (defmacro const (body) `(lambda (_) ,body)) Vs. const v _ = v
20:24:58 <benzrf> bb010g: yea
20:24:58 <dfeuer> benzrf, we do not talk about defmacro.
20:25:00 <carter> benzrf: yup
20:25:07 <benzrf> dfeuer: sorry but i dont know scheme
20:25:11 <benzrf> i read Land of Lisp
20:25:13 <benzrf> that's about it :p
20:25:18 <benzrf> the parens gave me eye ache
20:25:34 <benzrf> legitimately though, i had trouble following the code structure
20:25:39 <benzrf> it looked too homogenous
20:25:43 <benzrf> *homogeneous
20:25:50 <merijn> AlecTaylor: The code used in that repo loses some functionality though
20:26:01 <dfeuer> That's okay, benzrf. Scheme's syntax-rules system is simplistic but very pretty. The syntax-case system is spectacularly sophisticated.
20:26:02 <bb010g> benzrf: LOL is a pretty good introductory book. Check out the Racket docs for a good intermediate step.
20:26:13 <benzrf> bb010g: its ok
20:26:18 <merijn> AlecTaylor: Since it passes "NULL" "NULL' to hs_init, this means you can configure the runtime system using commandline flags, my code does keep that ability
20:26:18 <benzrf> lisp is not my goal
20:26:19 <carter> dfeuer: actualy syntax-rules turned otu to be turing complete
20:26:30 <benzrf> speaking of LoL
20:26:35 <benzrf> http://benzrf.com/misc/fp.pdf
20:26:41 <dfeuer> carter, was that Oleg's work?
20:26:45 <carter> prob
20:26:48 <bb010g> Lisp's parens actually make it look friendly to me. "It's going to be alright; your program is round!"
20:26:50 <AlecTaylor> merijn: Hate to ask, but can you show me how to push everything together? :)
20:26:55 <carter> @google oleg syntax-rules turing complete
20:26:56 <dfeuer> syntax-rules is very powerful as a language, but not as a macro system :P.
20:26:57 <lambdabot> http://okmij.org/ftp/Scheme/macros.html
20:26:57 <lambdabot> Title: Scheme Macro Programming
20:26:59 <AlecTaylor> (want to print something in Python from Haskell)
20:27:09 <carter> http://okmij.org/ftp/Scheme/macros.html#turing-completeness-hygiene
20:27:19 <dfeuer> So yes, that's Oleg.
20:27:23 <dfeuer> BBIAB.
20:27:57 <merijn> AlecTaylor: Anyway, I think my paste includes every detail you need, it has a C file, haskell file, plus cabal file that builds everything. If you wanna do something from python, you just move the code I put in the main function into another C function and have python call that C function
20:30:49 * hackagebot rtorrent-state 0.1.0.0 - Parsing and manipulation of rtorrent state file contents  http://hackage.haskell.org/package/rtorrent-state-0.1.0.0 (MateuszKowalczyk)
20:31:19 <AlecTaylor> merijn: Hmm, just learning the cabal system, looks like my version of cabal is too old
20:31:19 <AlecTaylor> http://packages.ubuntu.com/trusty/haskell-platform
20:34:34 <merijn> AlecTaylor: A new platform is due to be released any day now, but just running "cabal update; cabal install cabal-install" should work
20:34:46 <AlecTaylor> cheers
20:35:14 <Arahael_> merijn: Weirdly, I then got stuck with an obsolete cabal config file. I also had to delete that.
20:35:22 <Arahael_> merijn: (upgraded from 1.16 to 1.20)
20:35:44 <carter> you always have to migrate that
20:36:17 <Arahael_> It should be more obvious. Debian's migration is far, far better.
20:37:42 <orion> In haskell, what does "orphan" mean?
20:38:17 <carter> Arahael_: someone should write  patch for cabal-install so it does that
20:38:19 <jmcarthur> orion: it means there is an instance defined in a module that doesn't also contain either the type or the type class.
20:38:53 <swgillespie> i just had a moment of enlightenment with monad transformers. wow.
20:39:11 <jmcarthur> orion: orphans are "bad" because there could be more than one of them, and the compiler can't tell due to separate compilation
20:39:12 <benzrf> swgillespie: hella
20:39:24 <swgillespie> benzrf: my mind was just blown and my eyes opened
20:39:40 <orion> jmcarthur: How then would you extend a type class?
20:39:42 <benzrf> swgillespie: hella
20:40:16 <tabemann> orion: extend it in the same module as where the type is defined
20:40:18 <Arahael_> carter: There seems to be a bug in ihaskell for GHC 7.8.3, so I'm trying again with 7.8.2. I deleted .cabal entirely, and .ghc, however for some reason the linker can't find HStext-1.1.1.3-ghc7.8.2
20:40:24 <carter> Arahael_: no
20:40:30 <carter> 7.8.2 sucks
20:40:33 <carter> use 7.8.3
20:40:37 <carter> and pester the lib author
20:40:38 <bb010g> swgillespie: Wait until you get "monads are just monoids in the category of endofunctors"; it just suddenly makes so much sense and is awesome.
20:40:46 <orion> tabemann: What if it's something in another library?
20:40:47 <AlecTaylor> Hmm, that didn't really work
20:40:58 <swgillespie> bb010g: I hope someday I reach that level of enlightenment
20:41:25 <Arahael_> carter: I guess I should try the git version of ihaskell.
20:41:30 <carter> yeah
20:41:37 <benzrf> bb010g: edwardk showed me that particular light a few days ago
20:41:43 <Arahael_> carter: But why does 7.8.2 suck so badly? I mean, surely it has a working text lib?
20:41:48 <carter> Arahael_: its buggy
20:41:52 <jmcarthur> orion: what do you mean by "extend"? instances are not extensions anyway
20:41:53 <Arahael_> carter: How buggy?
20:41:55 <benzrf> it was a TRANSFORMATIVE EXPERIENCE
20:41:57 <AlecTaylor> merijn: It updated cabal in that session only, where are the binaries? - I need to put it earlier in my PATH I guess
20:41:57 <benzrf> :y
20:42:03 <Fuuzetsu> buggier than 7.8.3
20:42:07 <carter> Arahael_: now that 7.8.3 is out you shoudln't use 7.8.2
20:42:08 <swgillespie> I'm going through a paper implementing Algorithm W and it used a pretty complicated monad transformer but damn it's amazing
20:42:12 <orion> jmcarthur: Yes, poor word choice
20:42:27 <AlecTaylor> Found it ! - ~/.cobal/bin
20:42:27 <Arahael_> carter: The one product I wanted to try doesn't work with 7.8.3 today.
20:42:37 <carter> @lpaste the problem
20:42:37 <lambdabot> Haskell pastebin: http://lpaste.net/
20:42:43 <edwardk> bb010g: https://github.com/ekmett/hask/blob/master/src/Hask/Tensor/Compose.hs#L141 there it is
20:42:44 <carter> Arahael_: file a bug report with andrew
20:42:45 <jmcarthur> orion: the restriction is just that you can't define an instance separately from *both* the type class and the type definition.
20:42:47 <benzrf> Arahael_: is cobal like cabal for cobol
20:43:00 <benzrf> swgillespie: do you know any category theory
20:43:02 <carter> Arahael_: https://github.com/gibiansky/IHaskell/issues he's very responsive
20:43:08 <Fuuzetsu> you don't need cabal to be in COBOL hell though
20:43:12 <merijn> Arahael_: 7.8.2 got released only for people to find some critical bugs within a week, therefore 7.8.3 was released almost immediately after
20:43:28 <jmcarthur> orion: so you are always free to define a type and give it instances of existing classed or to define a type class and define instances for existing types
20:43:34 <swgillespie> benzrf: I'm familiar with abstract algebras, not categories specifically
20:43:36 <carter> merijn: you mean 7.8.1 to 7.8.2
20:43:39 <carter> took a teeny bit longer
20:43:40 <jmcarthur> *classes
20:43:45 <swgillespie> *algebra
20:43:49 <maybefbi> how can i use 'ghc-mod type' and hoogle inorder to implement auto-complete?
20:43:51 <orion> jmcarthur: tryuwe
20:43:52 <orion> true
20:43:54 <samba1> http://hackage.haskell.org/package/snap-0.6.0/docs/Snap-Snaplet.html#g:2 - it gives the example of putting non-snaplet data in the App config. How can I get this data out in a request though? Assuming it's not an IORef, just static data
20:43:58 <samba1> ?
20:44:14 <Arahael_> merijn: Well, what about 7.8.1, then?
20:44:19 <Fuuzetsu> just use 7.8.3
20:44:30 <benzrf> swgillespie: here, read this http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf
20:44:32 <jmcarthur> orion: and if you really need to define an instance for an existing type of an existing type class in a totally separate module, you should probably just make a newtype wrapper and define the instance for it instead
20:44:55 <jmcarthur> orion: because this eliminates the possibility that your instance will conflict with another
20:45:02 <swgillespie> benzrf: thanks!
20:45:07 <codehero> man
20:45:14 <codehero> i feel like i'm cheating
20:45:16 <codehero> http://rosalind.info/
20:45:19 <swgillespie> I love how in ruby or clojure, you read blogs to learn new things, but in haskell, you read textbooks and papers.
20:45:22 <codehero> haskell makes it way too easy :P
20:45:23 <orion> jmcarthur: Interesting, thanks
20:45:30 <benzrf> swgillespie: well, you read blogs too
20:45:41 <benzrf> swgillespie: and to be fair, that's a general intro to CT, not a haskell thing
20:45:50 <jle`> i read blogs more than anything for haskell
20:45:58 <swgillespie> sure, fair enough
20:46:03 * swgillespie reads
20:46:22 <carter> Arahael_: honestly ihaskell is a pain to build, so file bug reports
20:46:27 <carter> and andre will reply to help
20:46:31 <carter> *andrew
20:46:34 <glguy_> Samba1, you're looking at some pretty old version of the docs
20:47:04 <edwardk> benzrf, bb010g: there is something satisfying about taking the kind of thing folks say about monads and making it into a line of actual code
20:47:08 <glguy_> But also if you don't get your answer in the next couple minutes I can help when I get back to my desk
20:47:10 <bb010g> edwardk: What exactly is Hask for? Is it an alternative type & type class hierachy?
20:47:22 <edwardk> bb010g: its an exploration of what it is possible to say in haskell
20:47:31 <jmcarthur> orion: i admit that this is sometimes a bit of a pain, but it's worth it to avoid conflicting instances. those are much more painful.
20:47:35 <Fuuzetsu> abstract nonsense
20:47:36 <edwardk> bb010g: and of what it means to talk about lenses in a more general setting
20:47:51 <samba1> glguy_: ok, then http://hackage.haskell.org/package/snap-0.13.2.8/docs/Snap-Snaplet.html#g:2
20:48:05 <Arahael_> carter: It was actually _really_ easy to build on the current haskell platform.
20:48:18 <carter> Arahael_: the one in RC or the one from 2 years ago?
20:48:22 <carter> :)
20:48:25 <Arahael_> carter: The one from 2 years ago. :)
20:48:28 <edwardk> bb010g: e.g. in hask I've started building code to talk about nesting of monad transformers as forming a tensor in the category of monad transformer homomorphisms, in that setting then we can talk about strong profunctors and build lenses into monad transformer stacks!
20:48:30 <carter> Arahael_: point being, please file a bug report
20:48:41 <edwardk> bb010g: that isn't possible without the more general tools from the rest of the surrounding code
20:49:09 <Arahael_> carter: His docker app also works well, but doesn't include various packages that he didn't write. Am I justified in asking him to update so that I can use someone else's lib?
20:49:17 <edwardk> such lenses would let you shuffle around monad transformers past and through each other if they commute, pick out a reader structure from a larger state, etc.
20:49:18 <carter> yes
20:49:19 <benzrf> edwardk: what the hell is a strong profunctor anyway
20:49:26 <Arahael_> carter: Ok.
20:49:30 <carter> Arahael_: its his problem that is so hard tobuild things
20:49:35 <carter> Arahael_: also pester the author of the other lib
20:49:36 <carter> to update it
20:49:49 <carter> though if you can first work out a patch / bump to version bounds yourself
20:49:51 <carter> that helps things
20:50:09 <glguy_> :t right'
20:50:10 <lambdabot> Choice p => p a b -> p (Either c a) (Either c b)
20:50:16 <edwardk> benzrf: its a profunctor that somehow respects one of those monoidal category structures we talked about. if you know profunctor add he moral equivalent of 'first' and 'second' to it from Control.Arrow, but now you can generalize it to any tensor, not just (,)
20:50:25 <glguy_> :t first'
20:50:26 <lambdabot>     Not in scope: ‘first'’
20:50:26 <lambdabot>     Perhaps you meant one of these:
20:50:26 <lambdabot>       ‘first’ (imported from Control.Arrow),
20:50:28 <edwardk> benzrf: you can be strong with respect to a given tensor
20:50:33 <Arahael_> carter: Oh, that is already done.  It's just not in hackage.
20:50:43 <Arahael_> carter: It's the fixed and closed bug 283.
20:50:44 <carter> Arahael_: well holler at him
20:50:49 <carter> :)
20:50:49 <carter> idk
20:50:51 <edwardk> first' isn't exported by lens by default as stock lens doesn't use Strong for lenses, but rather the functor noise
20:50:54 <carter> i don't use notebooks
20:51:00 <benzrf> edwardk: hold on
20:51:20 <benzrf> oh
20:51:31 <AlecTaylor> merijn: cabal isn't working - http://lpaste.net/108974
20:51:54 <benzrf> class Strong p t where first :: p a b -> p (a, c) (b, c)?
20:51:56 <benzrf> er
20:52:00 <benzrf> class Strong p t where first :: p a b -> p (t a c) ( tb c)?
20:52:03 <benzrf> make that t b c
20:52:09 <edwardk> yeah, right now in lens we fix t = (,)
20:52:10 <benzrf> and 2nd also ofc
20:52:16 <edwardk> and we make a separtae 'Choice' class for t = Either
20:52:31 <edwardk> but both are 'monoidal' strengths
20:52:43 <benzrf> why use profunctor over (->)
20:52:47 <edwardk> so prisms are lenses into the Either structure
20:52:48 <benzrf> indexed, etc?
20:52:52 <edwardk> more than that
20:52:54 <edwardk> Iso
20:52:59 <edwardk> Prism
20:53:05 <edwardk> all those don't work with just (->)
20:53:09 <benzrf> why not
20:53:10 <benzrf> oh
20:53:11 <bb010g> Is there a way to list lambdabot ``@where``s?
20:53:15 <benzrf> no guarantee of reversibility
20:53:17 <edwardk> try to make them fit =P
20:53:18 <benzrf> right
20:53:47 <mwhit> not sure
20:53:49 <mwhit> @where commands
20:53:50 <lambdabot> http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
20:54:04 <bb010g> @list where
20:54:05 <lambdabot> where provides: where url what where+
20:54:06 <benzrf> type Choice p = Strong p Either
20:54:30 <benzrf> edwardk: so
20:54:32 <edwardk> that's pretty much where the class for it in Hask will go
20:54:51 <edwardk> now we can talk about Strong Compose   or Strong (,)  or String Either  -- works better flipped
20:54:55 <benzrf> hold on
20:55:44 <benzrf> type Lens s t a b = forall h. (s -> (h, a), (h, b) -> t)?
20:55:54 <benzrf> inb4 `no its CPSd'
20:55:54 <edwardk> no need for that
20:56:21 <edwardk> type Lens s t a b = forall p. Strong (,) p => p a b -> p s t -- basically
20:56:34 * Fuuzetsu just listened to a song/album titled ‘AMP’
20:56:35 <edwardk> type Prism s t a b = forall p. Strong Either p => p a b -> p s t -- basically
20:56:37 <Fuuzetsu> fitting
20:57:01 <edwardk> noisier in hask, but the idea is right
20:57:23 <benzrf> edwardk: ooooh that's pretty clever
20:57:43 * benzrf considers the formalization of strength in categorical terms
20:57:45 <edwardk> then an Iso just uses Profunctor p which is a superclass of Strong
20:57:58 <benzrf>              
20:58:04 <edwardk> benzrf: the fancy formalization is in terms of "Tambara modules"
20:58:09 <benzrf> mfw
20:59:59 <benzrf> i dont have time for this i have to figure out exponentials
21:00:02 <crocket> Hello
21:00:05 <crocket> I'm a layman.
21:00:10 <Fuuzetsu> Hello layman.
21:00:11 <benzrf> so that i can know about these fancy cartesian closed categories
21:00:12 <samba1> http://hackage.haskell.org/package/snap-0.13.2.8/docs/Snap-Snaplet.html#g:2 - Does anyone know how in a handler I could get the someNonSnapletData out of this?
21:00:15 <benzrf> hello layman
21:00:17 <crocket> How does haskell add an entry to an array if everything is immutable?
21:00:22 <benzrf> crocket: it doesnt
21:00:24 <benzrf> you get a new array
21:00:25 <crocket> Does it create a new array whenever I add a new entry?
21:00:28 <edwardk> anyways Strong Compose would let you dig into a stack of functors and extract a sub-chain of compositions from a larger chain
21:00:30 <benzrf> crocket: normally you'd use a list
21:00:41 <bb010g> crocket: Theoretically.
21:00:45 <benzrf> edwardk: wait
21:00:46 <benzrf> go back
21:00:46 <crocket> Can I add something to a list without cloning it?
21:00:51 <benzrf> crocket: only from IO
21:00:57 <crocket> ????
21:01:05 <benzrf> crocket: you have to fly out to Io before you can do that
21:01:12 <benzrf> crocket: hope you got rocket fuel dude
21:01:23 <benzrf> edwardk: ok, so
21:01:42 <crocket> That's weird
21:01:55 <benzrf> no, youre weird
21:01:56 <crocket> If everything is immutable, it would be difficult to gain performance.
21:02:06 <benzrf> crocket: only if you try to program imperatively
21:02:09 <edwardk> with a fancy newtype ComposeTrans s t m a = T { runT :: s (t m) a } -- that is used in a category of monad transformer homomorphisms newtype TransformerHom s t = TransformerHom (forall m a. Monad m => s m a -> t m a)
21:02:11 <mwhit> not really
21:02:16 <edwardk> then you can walk down into a stack of monad transformers
21:02:18 <benzrf> edwardk: h-hold on
21:02:30 <mwhit> you'll find the way lists are used is different enough from what you're used to that it's rarely an issue
21:02:31 <edwardk> benzrf: the nice thing about IRC is you have scrollback ;)
21:02:33 <benzrf> class Strong p t where first :: p a b -> p (t a c) (t b c); second :: p a b -> p (t c a) (t c b)
21:02:42 <benzrf> edwardk: bleh
21:02:51 <benzrf> specialized to t ~ Compose, u get
21:03:02 <bb010g> crocket: There's a whole lot of optimization going on.
21:03:08 <edwardk> so far so good
21:03:12 <benzrf> first :: p a b -> p (Compose a c) (Compose b c); second :: p a b -> p (Compose c a) (Compose c b)
21:03:13 <crocket> bb010g, I hope.
21:03:15 <glguy> samba1: You should be able to get the current "snaplet state" using getSnapletState :: Handler b v (Snaplet v)
21:03:38 <benzrf> crocket: what if i came to imperative land and i said 'what, you dont even have laziness, how do you operate on infinite data, that would lead to infinite loops'
21:03:48 <glguy> samba1: You can get the snaplet state out of a snaplet using this lens: snapletValue :: forall s. Lens' (Snaplet s) s
21:03:49 <benzrf> the answer is, you dont do that, because that doesnt work in strict languages
21:04:00 <edwardk> so if you had State s you could use that to 'view' or modify the (,) s   or the (->) s structure out of the state.
21:04:06 <benzrf> similarly, you dont program by updating the middle of a list in haskell
21:04:07 <crocket> benzrf, Is haskell fascism?
21:04:15 <edwardk> note that isn't as a monad, just as a functor sub-composition
21:04:22 <merijn> AlecTaylor: The cabal file I pasted has the following line: "Cabal-Version:       >= 1.17"
21:04:29 <benzrf> > let facism = haskell; haskell = facism; in haskell == facism
21:04:34 <lambdabot>  mueval-core: Time limit exceeded
21:04:38 <benzrf> crocket: i guess we'll never know
21:04:56 <merijn> AlecTaylor: The error you pasted is complaining that your cabal file uses a feature (default-language), but doesn't declare a cabal-version constraint that allows that feature
21:05:00 <glguy> samba1: I don't know if Snap has another version, but the way to use that is to import Control.Lens for the "view" function and write  "view snapletValue" to get a function   "Snaplet a -> a"
21:05:02 <benzrf> edwardk: this looks like a monad morphism
21:05:14 <edwardk> its similar
21:05:14 <benzrf> edwardk: but w/ profunctors
21:05:21 <edwardk> its more principled in many ways
21:05:22 <samba1> glguy: but it's not a snaplet itself....
21:05:35 <edwardk> a principled 'mmorph' is one special case of it
21:05:51 <glguy> samba1: Do you have some code that we can look at together?
21:05:58 <edwardk> but the idea that you can use it to do things like use lens-style isos to swap around your monad transformer stack is kinda nice
21:06:04 <glguy> samba1: It might be easier to show how to get the state in some code you wrote than to talk about it abstractly
21:06:17 <merijn> crocket: "is there a way to add something to a list other than cloning" <- well, keep in mind that if you add something to the front of the list, you don't actually need to copy the list, you can just use a pointer to the old list. Since the old list is immutable there's never a problem with data being changed
21:06:21 <edwardk> so e.g. ReaderT e (WriterT w)   can commute to WriterT w (ReaderT e) without loss of information in either direction
21:06:30 <jmcarthur> crocket: this idea of "creating a new array" is very operationally oriented. in practice, it just depends on what kind of array you're using. in theory, there is no operation at all, just a value that you've defined.
21:06:45 <samba1> glguy: Well, say I setup my app like in that link
21:06:58 <samba1> and then I'm in a handler
21:07:06 <merijn> crocket: i.e. if you come from something like Java where you have to make "deep copies" to avoid someone trampling over your data, haskell never has to make deep copies, it only makes shallow copies, since the data can never change anyway
21:07:08 <samba1> myHandler :: Handler App App ()
21:07:14 <samba1> myHandler = do
21:07:21 <glguy> put it on http://lpaste.net
21:07:25 <samba1> and then I want to get that (static) value, and return it in something
21:07:35 <samba1> there's just not much to lpaste
21:07:38 <benzrf> edwardk: sweet
21:07:38 <glguy> OK, if that's the extent of it I can make a paste
21:07:50 <jmcarthur> merijn: (although it's worth noting that for some data structures there is little difference between deep and shallow copying anyway)
21:07:58 <merijn> jmcarthur: Sure
21:08:03 <glguy> samba1: just give me a moment to install snap locally so my example code will type-check
21:08:06 <benzrf> edwardk: is there a notion in category theory of flipping the arguments of a tensor or something
21:08:12 <benzrf> could apply to shifting layers of a stack?
21:08:12 <glguy> I have to install "all the things"
21:08:28 <edwardk> well, sometimes you have a symmetric monoidal category, which permits you to do this all the time
21:09:12 <samba1> glguy: no rush, thank you. here's a simple example http://lpaste.net/6407689913952632832
21:09:25 <edwardk> for certain objects you can have something called a Yang-Baxter operator that lets you commute them
21:10:01 <ReinH> Oh. Yeah. That.
21:10:05 <ReinH> Of course.
21:10:22 <edwardk> for (,) and Either, they are symmetric monoidal tensors so its boring, for Compose you can't always commute, but there are some functors you can commute over other functors and or vice versa
21:10:24 <glguy> samba1: Why I'm compiling try adding this line to your example:     liftIO print . view snapletValue =<< getSnapletState
21:10:52 <glguy> samba1: You might have to "import Control.Lens (view)" and "import Control.Monad.IO.Class (liftIO)"
21:11:00 <benzrf> edwardk: oki
21:11:50 <samba1> glguy: i imported view when your last suggestion, and I have liftIO already for debugging
21:12:01 <samba1> glguy: i'm getting an error on your line, looking at it now
21:12:49 <edwardk> anyways, there are some monads you can always swap around, e.g. ReaderT/WriterT/StateT all swap over each other freely
21:12:54 <glguy> samba1: Did it saw that there was now "Show App" instance?
21:13:05 <samba1> glguy: once I added another (.), yes
21:13:24 <edwardk> and some stuff will always go in one direction very easily, e.g. EitherT, ReaderT because they have nice distributive laws
21:13:47 <edwardk> so you get a whole nest of structure you can play with if you embrace it
21:14:29 <glguy> samba1: example's almost done. I'm tracking down the imports I need for your example
21:16:41 <glguy> samba1: http://lpaste.net/6407689913952632832
21:18:40 <samba1> glguy: that is exactly right
21:19:09 <samba1> glguy: thank you
21:19:18 <glguy> yw
21:19:22 <samba1> glguy: i must go to work now, but i will look to understand it later
21:19:29 <tabemann> hmm I should really get back to work on my R7RS-small impl
21:19:31 <samba1> glguy: and maybe snap has a special way i will see
21:19:34 <edwardk> benzrf: there are other monoidal structures that may be worth exploring with lenses in a similar way. also this points to what a prism-like analogue for a traversal is
21:21:57 * benzrf yawns
21:22:08 * benzrf tries to think about traversals
21:22:41 <benzrf> ummm
21:22:52 <benzrf> something with lists
21:22:54 <benzrf> instead of either
21:22:59 <benzrf> no
21:23:53 <benzrf> hold on
21:24:00 <benzrf> couldnt the type just be the same as lens
21:24:02 <benzrf> *Lens
21:24:11 <benzrf> the function doesnt know how many items its gonna deal with
21:24:15 <benzrf> err
21:24:17 <benzrf> profunctor
21:24:17 <benzrf> w/e
21:24:20 <edwardk> you need to be able to glue some things together side-ways you can't right now
21:24:24 <benzrf> oh wait der
21:24:34 * benzrf ponders
21:24:40 * tabemann is kind of annoyed that he doesn't understand his datastructure comparison code anymore, just that he knows it works somehow
21:24:45 <edwardk> this ties to some fancy day convolution abuses
21:25:15 <benzrf> something about uh
21:25:19 <benzrf> mapping profunctors or
21:25:20 <benzrf> something
21:25:32 <benzrf> p a b -> p (f a) (f b)
21:25:35 <benzrf> err?
21:25:50 <tabemann> and I put a *lot* of work into that code, too!
21:26:38 <benzrf> if you had, like > class Profunctor p => Map p where fmap' :: p a b -> p (f a) -> p (f b)
21:26:44 <benzrf> you could do
21:26:48 <benzrf> wait
21:27:00 <tabemann> I should have written down how that thing even worked
21:27:13 <benzrf> split it into an h and [a] and then fmap' p  . rejoin [b] w/ h
21:27:22 <benzrf> edwardk: is that class unreasonable
21:27:51 <edwardk> benzrf: its one way to talk about the current concept of a setter
21:28:00 <benzrf> meehh
21:28:08 <edwardk> you need something more about 'f' though, e.g. Functor f => ...
21:28:12 <benzrf> edwardk: how do i getter w/ prof lenses
21:28:15 <benzrf> edwardk: oh right yeah
21:28:20 <benzrf> that's what i meant eesh
21:28:33 <benzrf> edwardk: if you just used Arrow we could lift fmap already
21:28:36 <benzrf> or something like that
21:28:49 <benzrf> edwardk: obviously Arrow is a much better choice than pf
21:29:02 <benzrf> edwardk: it has first and second BUILT IN no need for this tensor bs
21:29:10 <edwardk> you can make a profunctor that does something like newtype Get r a b = Get (r ~> a)
21:29:19 <edwardk> er
21:29:27 <edwardk> you can make a profunctor that does something like newtype Get r a b = Get (a ~> r)
21:29:34 <benzrf> (~>)
21:29:35 <edwardk> then figure out how to use it
21:29:35 <benzrf> wut
21:29:49 <edwardk> ~> is a placeholder for arrow in the correct category, its what i used in the hask talk
21:30:04 <edwardk> benzrf: https://www.youtube.com/watch?v=Klwkt9oJwg0&feature=youtu.be
21:30:22 <benzrf> sorry but its past midnight and my doctor recommended no strenuous mental activity
21:30:25 <jle`> imagine we could have infix type functions
21:30:27 <benzrf> past midnight
21:30:33 <benzrf> jle`: imagine?
21:30:35 <benzrf> the future
21:30:36 <benzrf> is now
21:30:38 <jle`> type (~>) = Category
21:30:43 <benzrf> oh
21:30:45 <benzrf> i thought you meant:
21:30:49 <jle`> so a ~> r is Category a r
21:30:56 <benzrf> > Left 4 :: Int `Either` String
21:30:58 <lambdabot>  Left 4
21:31:03 <benzrf> jle`: yeaah
21:31:11 <benzrf> that shouldnt be called Category it should be called
21:31:12 <benzrf> morphism
21:31:15 <benzrf> much better
21:31:19 <jle`> like of (**) = foo, then 7 ** 4 is foo 7 4
21:31:29 <benzrf> jle`: i got it
21:31:35 * benzrf yawns some more
21:31:38 <jle`> benzrf: it's a bit tricky.  (a -> b) is the morphism, but (->) is the Category
21:31:44 <jle`> like how m is the monad, not m a
21:31:48 <benzrf> myeah
21:31:57 <benzrf> i know
21:31:59 <benzrf> but wait
21:32:04 <benzrf> (->) is a category?
21:32:05 <benzrf> i dont think so
21:32:12 <benzrf> its a type constructor is what it is
21:32:18 <edwardk> jle`: not quite
21:32:18 <benzrf> for morphisms in some category
21:32:30 <jle`> it's the instance of Category
21:32:42 <edwardk> now we're closer =)
21:32:43 <benzrf> jle`: the Category class is the class for type constructors that build the types of morphisms in some category that shares objects w/ haske
21:32:46 <benzrf> *Hasl
21:32:47 <benzrf> ****Hask
21:32:56 <jle`> (->) represents the category of haskell types and morphisms dcharacterized by (->), i think?
21:32:58 <benzrf> jle`: hence class Morphism
21:33:07 <benzrf> jle`: what about `Kleisli m'
21:33:11 <edwardk> type family (~>) :: i -> i -> *; type instance (~>) = (->); -- etc
21:33:13 <jle`> so instance Category Foo would be the Category of haskell types, with morphisms Foo
21:33:25 <edwardk> jle`: the old hask approach ruled out Kleisli m as a category
21:33:29 <benzrf> jle`: yes, so
21:33:33 <benzrf> Foo is the morphism constructor
21:33:34 <edwardk> the new one admits it again
21:33:36 <benzrf> hence instance Morphism Foo
21:33:39 <benzrf> meh
21:33:44 <jle`> Kleisli m wouldhave haskell types, and morphisms Kelisi m a b
21:33:47 <crocket> merijn, ok
21:33:53 <jle`> benzrf: sorry, heh.  typeo. morphisms Foo a b
21:34:00 <benzrf> i know
21:34:04 <benzrf> but uh
21:34:07 <jle`> the morphisms are Foo a b, but Foo a b /= Foo
21:34:14 <benzrf> u know what i mean blehh
21:34:22 <benzrf> foo is more morphismy than categoryy
21:34:27 <benzrf> foo is more morphismy than category-y
21:34:32 <benzrf> Foo, even
21:34:33 <jle`> Foo is not a morphism; Foo a b is
21:34:54 <benzrf> Foo a b is the type of a morphism
21:34:55 <benzrf> ;)
21:34:58 <benzrf> WHOS THE PEDANT NOW
21:35:12 <jle`> :P
21:35:17 <jle`> Foo is the type level morphism i guess
21:35:21 <jle`> so things are weird
21:35:28 <jle`> also it's hard talking when there is a 5 second ssh lag v.v
21:36:02 <benzrf> jle`: `type level morphism'?
21:36:04 <benzrf> pls
21:36:11 <benzrf> i dont buy into this bulb shit
21:36:35 <benzrf> sorry at this time of night i start autopiloting and saying things like that automatically derived from my general mood in response to what people say
21:36:38 <benzrf> i should probably leave irc
21:37:16 <jle`> nah
21:37:35 <benzrf> buts its getting to the stage where my eyes feel bulgy
21:37:41 <benzrf> if i keep staying up i wont be able to get up early in the morning
21:38:48 <benzrf> i heard tha t in cccs we have curryings
21:39:21 <benzrf> but
21:39:22 <edwardk> we can have currying even in some monoidal categories as well, you don't need full cartesian structure for it
21:39:29 <benzrf> wha
21:39:32 <benzrf> how does
21:39:39 <benzrf> currying work for ctegoryies
21:39:47 <benzrf> you have objects representing morphisms
21:39:49 <benzrf> so
21:40:04 <benzrf> a -> b -> c is a morphism from a to (b -> c) as embeggeded in the category?
21:40:09 <benzrf> wrong consonant -.-
21:40:21 <edwardk> (p a b ~> c)  becomes (a ~> e b c)    for some bifunctor p and some (enriched) profunctor e
21:40:27 <jle`> edwardk: oh yeah i see :) kind polymorphism woo hoo
21:40:36 <benzrf> enriched
21:40:38 <benzrf> like
21:40:41 <benzrf> with protien powder
21:41:17 <benzrf> i found out about products because
21:41:26 <edwardk> hen someons says profunctor they mean a bifunctor  C^op * D -> Set    enriched lets that 'Set' be some other category E basically
21:41:34 <benzrf> i looked up groups in categories, but they required the diagonal natural transformation
21:41:56 <benzrf> C^op
21:41:58 <benzrf> i dont know
21:42:35 <edwardk> opposite category. spin all the arrows around so they face the other way
21:42:41 <benzrf> ohy
21:42:46 <benzrf> *oh
21:42:48 <benzrf> ~C
21:42:51 <benzrf> c^-1
21:42:53 <benzrf> 1 - c
21:42:54 <benzrf> c/1
21:43:00 <benzrf> 0 - c i mean
21:43:10 <benzrf> i dont knoww
21:43:26 <edwardk> newtype Op c a b = Op (c b a)
21:43:35 <benzrf> im leaving now before i fall asleep with my glasses on
21:43:37 <benzrf> i just almost did that
21:43:40 <benzrf> its bad for the frames
21:43:48 <edwardk> been there
21:43:49 <edwardk> night man
21:43:55 <benzrf> bye
21:56:53 <Fuuzetsu> lies, edwardk doesn't sleep
21:56:56 <AlecTaylor> hi
21:57:04 <edwardk> =P
21:57:51 <edwardk> i tend to sleep when i learn something new that makes me revisit a lot of previous positions, am sick, worked out or otherwise strained myself ;)
22:01:55 <machrider> anyone able to install the 'gtk' package? i'm getting an error from cairo-0.13.0.0 about how Module 'Distribution.Simple.Configure' doesn't export 'configCompilerEx'
22:04:55 <no_name> cabal is driving me nuts - I'm trying to add a library to link against and it won't let me give an absolute or relative path, tells me to use ${pkgroot} and that doesn't seem to work
22:08:11 <CmdrMoozy> i'm looking for some examples for how to use QuickCheck to check a curried function that takes more than one parameter - can anyone point me in the right direction?
22:09:31 <Iceland_jack> CmdrMoozy: QuickCheck can check functions of any arity uniformly
22:09:56 <Iceland_jack>     quickCheck (\(a :: Int) b -> a + b == b + a)
22:10:20 <Iceland_jack> so you don't have to do anything different
22:10:26 <CmdrMoozy> Iceland_jack, ah, that's super easy :) thanks!
22:15:49 <ivanm> byorgey: I am now
22:16:23 <ivanm> (I actually forgot I had IRC running on this machine, as I've been using it more as a server for the past month or so)
22:19:41 <comerijn> no_name: A C library you mean?
22:20:14 <machrider> cabal doesn't want to install anything for me tonight
22:20:38 <machrider> i feel like i'm getting punished for using the "stable" release from ubuntu
22:21:04 <comerijn> ubuntu stable is stupidly out of date with what's on hackage
22:21:30 <machrider> i don't know, i go to download the latest package and it's 2013.2.0.0
22:21:33 <machrider> and they recommend GHC 7.6.3
22:21:39 <machrider> so this is the latest stable, right?
22:21:54 <ivanm> @tell byorgey http://hackage.haskell.org/package/graphviz-2999.17.0.1/docs/Data-GraphViz.html#g:9 but use a custom replacement of dotAttributes
22:21:55 <lambdabot> Consider it noted.
22:22:08 <ivanm> machrider: the new Platform with 7.8.3 is coming out this weekend I believe
22:22:24 <machrider> ivanm: cool. am i crazy or is the ecosystem currently a little broken?
22:22:30 <ivanm> define "broken"
22:22:40 <machrider> well, i can't convince cabal to install anything
22:23:39 <machrider> cabal 1.16, so no 'cabal sandbox' command
22:23:52 <machrider> i have to compile from source if i want working tools, i guess
22:24:10 <comerijn> machrider: Why not just run "cabal install cabal-install" and get a new cabal with sandbox?
22:24:21 <machrider> hah, didn't know that was possible
22:24:39 <comerijn> Don't forget to update your path to the new cabal afterwards
22:24:40 <machrider> (i was looking for an 'upgrade' command)
22:24:54 <comerijn> (default it installs somewhere under ~/.cabal
22:25:17 <ivanm> well, "cabal update" will tell you to do that ;-)
22:28:27 <ivanm> and use $HOME/.cabal/bin for the PATH, not ~/.cabal/bin
22:32:11 <friden> merijn: Ok i forgot to say yesterday but the solution you linked from SO worked, thanks! thou its a bit irritating that some function in that solution prints a lot of stuff :/ look here: http://pastebin.com/T2rAYZDq
22:32:34 <friden> or if anyone else knows how to get rid if the outut before the last line
22:33:16 <friden> read the comments below the linked code
22:34:06 <glguy> friden: read http://hackage.haskell.org/package/HTTP-4000.2.17/docs/Network-Browser.html and look for "setOutHandler" and "setErrHandler"
22:35:00 <friden> glguy: awesome, thanks
22:35:32 <haasn> Oh wow, ghc-server fills the missing program to finish the shell tools I started working on 4-5 years ago!
22:35:34 <haasn> Finally
22:36:28 <coppro> haasn: ?
22:36:35 <haasn> https://github.com/chrisdone/ghc-server this is awesome
22:36:41 <haasn> Or this is going to be awesome
22:36:46 <haasn> I haven't quite figured out which
22:43:15 <mhyperbolic>  Is there a way to do this http://lpaste.net/108976 without using (!!)?
22:43:23 <AlecTaylor> I keep getting this error: "Failed to load interface for `Prelude'
22:43:23 <AlecTaylor>     Perhaps you haven't installed the "dyn" libraries for package `base'?"
22:43:37 * hackagebot yesod-bin 1.2.12.3 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.3 (MichaelSnoyman)
22:43:37 * hackagebot attoparsec 0.12.1.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.1 (BryanOSullivan)
22:44:31 <bb010g> mhyperbolic: where a:b:c:_ = ps
22:44:35 <machrider> making much more progress now that i've updated cabal.
22:44:50 <machrider> i guess packages are doing things that aren't compatible with 1.16
22:45:00 <haasn> mhyperbolic: Extending bb010g's suggestion, you can clean up the function even further
22:45:13 <haasn> threeWiseTurns (a:b:c:ps) = calcTurn a b c : threeWiseTurns ps
22:45:16 <haasn> threeWiseTurns _ = []
22:45:21 <haasn> simple, effective, efficient
22:45:39 <bb010g> mhyperbolic: You could just do both as pattern matches, with your first match being a:b:c:ps = calcTurn a b c : threeWiseTurns (drop 3 ps) & the 2nd being _ = []
22:45:46 <bb010g> haasn: Ninja'd. :)
22:46:25 <mhyperbolic> That is very clean yes!. Thank you :)
22:46:34 <haasn> mhyperbolic: You generally want to prefer using pattern matches to destruct data rather than boolean “tests” or projection functions
22:46:48 <haasn> mhyperbolic: The classic example is f xs = foo (head xs) (tail xs)  vs f (x:xs) = foo x xs
22:47:20 <machrider> anyone know how to coerce the sdl2 package to look in /opt for sdl 2.0.3 rather than the usual location?
22:47:29 <machrider> i have the /opt/sdl/bin on my PATH and /opt/sdl/lib in ld.so.conf
22:47:50 <haasn> In your case it's something similar, but you're using “length” to calculate information out of the list then explicitly comparing it with a value and deciding based on that Bool which path to choose. Consider what would have happened had you accidentally swapped the right hand sides of your “=” signs on lines 21-22
22:47:59 <haasn> The code would have computed just fine
22:48:02 <haasn> compiled[
22:48:21 * dfeuer compiles haasn.
22:48:31 <dfeuer> @compile haasn
22:48:31 <lambdabot> Not enough arguments to @.
22:48:44 <joelteon> I can contribute an argument
22:49:03 <haasn> With the pattern matching approach; it's explicit what the actual structure of the incoming list is and how to use the stuff you get out of it
22:50:28 <mhyperbolic> haasn, Yes I see. I didn't like using (!!) but couldn't see the pattern, but of course it is obvious now I've seen it :)
22:50:42 <AlecTaylor> Does cabal no longer have sandbox?
22:51:16 <dfeuer> OK, so why is it that @compile something tells me @ doesn't have enough arguments, whereas if I say @fishery something it just says it doesn't know how to do that?
22:51:33 <haasn> @help compile
22:51:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:51:41 <haasn> oh
22:51:43 <haasn> @help compose
22:51:43 <lambdabot> . <cmd1> <cmd2> [args].
22:51:44 <lambdabot> . [or compose] is the composition of two plugins
22:51:44 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
22:51:48 <haasn> It literally means @.
22:51:56 <haasn> the @compile got auto-corrected to @compose which is an alias for @. or @@
22:52:16 <dfeuer> Ahhh.
22:52:26 <dfeuer> Whatever @. and @@ mean.
22:52:44 <trap_exit> @ means at; @ means at&t
22:53:41 <bb010g> mhyperbolic: The worst part about (!!) is that for the nth item it has O(n) time, so if you pull out the 56th and 57th items of a list with (!!) you have to go match through 113 items of that list. It's not as bad with small numbers, but pattern matching helps tons. (There, you could probably just use drop 56 on the list and then pattern match on the first
22:53:41 <bb010g> and second item.)
22:53:51 <paraseba> Hello, I have a newbie question: what is the recomendation to name packages and modules? How do we avoid conflicts in hackage?
22:55:21 <mhyperbolic> bb010g, I didn't even think about, but of course the pattern matching is not only clearer but more effectient.. That is cool!
22:56:57 <solidus-river> heh, welcome to type hell
22:57:01 <solidus-river> http://lpaste.net/108977
22:57:30 <solidus-river> why is it converting my m in the return wire to that gibberish
22:57:38 <solidus-river> ((,) (Either e [(Either e b, Wire s e m () b)]))
22:57:43 <solidus-river> it thinks thats my wire monad?
22:58:49 <shachaf> Well, figure out what the type of each thing should be, and then see where what you think diverges from what GHC thinks.
22:59:02 <solidus-river> that type is insane
22:59:09 <solidus-river> like i don't even know where to begine
22:59:13 <solidus-river> innermost out? outtermost in?
22:59:15 <shachaf> By the way, "do { x <- a; return x }" is the same thing as "a"
22:59:42 <machrider> if anyone was curious, i just had to set PKG_CONFIG_PATH to find packages installed in /opt. (sorry for the non-haskell-specific derail)
23:00:24 <solidus-river> hmm, that explains the monad there
23:00:45 <glguy`> Solidus go look at the type of mkPure
23:01:07 <solidus-river> i have it open from hackage
23:01:22 <solidus-river> it takes a transition function from s -> a -> Wire s e m a b
23:01:25 <solidus-river> my a is ()
23:01:34 <solidus-river> er, my a is [Wire s e m () b]
23:01:52 <solidus-river> my b is [(Either e b, Wire s e m () b)]
23:01:55 <solidus-river> so i need
23:02:29 <solidus-river> s -> [Wire s e m () b] -> [(Either e b, Wire s e m () b)]
23:03:36 <solidus-river> but i believe that is the type of \dt wires -> mapM (\wire -> stepWire wire dt (Right ())) wires)
23:04:30 <solidus-river> well, i guess i need to get red of the monad in front of it, but i dont see a practical way to do that
23:08:47 <friden> i just read the source of nub and thought it was messy, so i made one myself. Probably there is a reason for not doing it like i do, but i dont know why, any ideas? http://pastebin.com/S1b1CHZJ
23:09:45 <dfeuer> friden, nub is such a bad idea in such a large majority of cases that a "better" one is not much of a priority.
23:09:46 <friden> i see that nubBy adds the first occurance and filters the remaining list of the added element, but when tested it seems like my version is about the same in both performance and memory consumption
23:10:08 <friden> toList $ fromList is better?
23:10:15 <shachaf> friden: Your nub doesn't keep the first element like the other nub does.
23:10:19 <dfeuer> Even that, but you can do better.
23:10:22 <glguy`> Try nub (1:repeat 0)
23:10:23 <trap_exit> how about (\x -> x)
23:10:41 <friden> glguy`: ah, good one
23:11:00 <friden> thanks xd
23:11:05 <dfeuer> You can keep the laziness of nub, and preserve order, without being so inefficient, as long as your type is in Ord.
23:11:25 <dfeuer> nub deals only in Eq, which makes it unusably slow for any lists that aren't extremely short.
23:11:42 <mhyperbolic> Is there a way to sort a list of tuples by the second elements other than creating a new ordering and using sortBy?
23:11:53 <shachaf> A new ordering?
23:11:55 <solidus-river> hmm
23:12:08 <dfeuer> Yes, mhyperbolic. Use `on`.
23:12:10 <shachaf> sortBy (compare `on` snd) is probably what I would write.
23:12:20 <haasn> I would probably write (comparing snd) instead of (compare `on` snd)
23:12:29 <solidus-river> i need to return an Either [(Either e b, Wire s e m () b)]
23:12:35 <glguy`> Is comparing out of favor?
23:12:42 <shachaf> I hope so.
23:12:45 <solidus-river> but i'm returning an m [(Either e b, Wire s e m () b)]
23:12:47 <shachaf> (compare `on`) is just as good.
23:13:07 <glguy`> When I bring up the keyboard I can't see the messages :)
23:13:48 * glguy` reorients
23:13:52 <dfeuer> glguy`, what does that mean?
23:14:03 <dfeuer> When you bring up the keyboard, you can't see the messages....
23:14:09 <haasn> I think he has an on-screen keyboard
23:14:20 <dfeuer> Ahhhhh...
23:14:20 <edwardk> dfeuer: he usually sits there clacking away on IRC on his phone at night
23:14:25 <glguy`> It means haasns response made mine redundant
23:14:30 <MP2E> lol
23:14:54 <haasn> Or at least it restricted its domain to “among people other than haasn”
23:15:04 <dfeuer> edwardk, I do that sometimes during the day, but my current phone (near the end of its life, I fear) has a keyboard.
23:15:40 <orion> hmm
23:16:16 <orion> Does anyone know how to complete this code?: http://lpaste.net/6074815165235200000
23:16:20 <mhyperbolic> dfeuer, , I can't use `on`. Is it from some library?
23:16:34 <haasn> You may have to import Data.Function or something
23:16:37 <glguy`> ?index on
23:16:37 <lambdabot> bzzt
23:16:38 <dfeuer> edwardk, Awodey does look a little fast. What was that other book you mentioned?
23:16:48 <edwardk> conceptual mathematics
23:17:02 <dfeuer> Thanks.
23:18:01 <glguy`> Orion you'll have to give us a hint
23:18:29 <dfeuer> You are driving me to bankruptcy, edwardk. Ordered.
23:19:00 <mhyperbolic> Yes that was it. Thanks
23:19:13 <orion> glguy`: I am using network-simple, and I am rewriting the serve function so that it takes a function `b addr' which will return True or False depending on whether or not to accept the incoming connection (based on SockAddr)
23:20:00 <solidus-river> closer http://lpaste.net/108977
23:21:37 <carter> edwardk: i'm mulling proposing a change to how min and max work on floats,  namely if either arg is a Nan, the result should be Nan, thoughts?
23:22:39 <edwardk> carter: bit too tired right now to think through the ramifications of that
23:22:44 <carter> ok
23:22:48 <carter> yeah, i'm crashing myself
23:24:12 <haasn> orion: λ in line 2 looks like a syntax error
23:24:48 <orion> haasn: Ah, that's a backslash. My editor replaces backslashes with lambdas.
23:25:06 <haasn> (why?)
23:25:29 <swgillespie> haasn: https://github.com/i-tu/Hasklig
23:25:37 <swgillespie> shrug
23:25:39 <orion> haasn: ^
23:25:54 <haasn> :t let λ=λ in \"\\λ"->λ
23:25:55 <lambdabot> [Char] -> t
23:26:29 <orion> haasn: It's only displayed on the screen. The actual source file gets a \
23:27:10 <orion> http://lpaste.net/6074815165235200000 <-- if you go there now, I've edited it.
23:27:16 <orion> I think I am doing something very noobish.
23:28:01 <orion> (It compiles)
23:34:02 <dfeuer> carter, is the issue how NaN interacts with \pm\infty?
23:46:38 <dyu> any server deployment tools written in haskell?
23:49:25 <AshyIsMe> glguy`: i use juicessh to connect to my irc vm on my phone and tablets, it's really nice as it supports mosh too
