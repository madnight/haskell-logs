00:01:24 <joelteon> I don't think it's built that way
00:25:12 <orangestickynote> Is anybody out there?
00:25:25 <MP2E> *echoes echoes echoes echoes*
00:25:57 <orangestickynote> Good. I thought I was alone. I'm new to IRC and was wondering if I was doing something wrong.
00:26:11 <MP2E> nah, #haskell just has it's ups and downs in terms of activity
00:27:07 <merijn> It's too early in the morning for the Europe crowd
00:27:17 <orangestickynote> Ah. Well good to know.
00:27:18 <merijn> And the US crowd is either in bed or drinking :)
00:27:27 <MP2E> haha indeed!
00:27:42 <orangestickynote> Hah yep. Just about to go to bed actually!
00:28:31 * hackagebot robot 1.3 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.3 (ChrisWong)
00:38:07 <trap_exit> moar haskell
00:47:06 <mroman_> HELP!
00:47:11 <mroman_> The lazyness is gone :(
00:48:42 <mroman_> Since I stuffed things into a StateMonad I'm suddenly not having lazy evaluation anymore
00:49:09 <mroman_> That's a huge deal breaker
00:49:58 <mroman_> I can't lazily map over lists anymore
00:50:05 <MP2E> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
00:50:19 <MP2E> there's a lazy state too
00:50:59 <mroman_> http://lpaste.net/110239
00:51:04 <mroman_> ^- that's my map
00:51:48 <jle`> mroman_: so what do you mean by laziness?
00:52:02 <jle`> mroman_: i think i might have an idea
00:52:08 <jle`> mroman_: do you know what the State type is?
00:52:12 <jle`> and what the Monad instance represents?
00:52:53 <mroman_> Well... my old map implementation didn't use state
00:53:01 <jle`> do you know what State is?
00:53:08 <mroman_> which is why my interpreter couldn't access global state within maps
00:53:15 <mroman_> so I've changed my map implementation to use the state
00:53:23 <mroman_> jle`: it's ([a],[a])
00:53:24 <jle`> (btw, there is mapM)
00:53:32 <jle`> mroman_: i mean, the State type
00:53:34 <jle`> State s a
00:53:52 <mroman_> State ([Exp],[Exp]) ()
00:53:58 <jle`> but do you know what the type represents?
00:54:05 <jle`> (for example, do you knwo what Maybe represents?)
00:54:09 <mroman_> No
00:54:16 <mroman_> I don't know what you mean with "representes"
00:54:22 <jle`> like, what it *is*
00:54:27 <jle`> data Maybe a = Nothing | JUst a
00:54:32 <mroman_> Ah
00:54:33 <mroman_> yeah
00:54:35 <jle`> Maybe is an ADT that can either be Nothing or Just a
00:54:39 <mroman_> it's Nothing or Just something
00:54:39 <jle`> what is State?
00:55:14 <mroman_> It carries around a tuple with (state,result)
00:55:18 <mroman_> by chaining functions together
00:55:19 <jle`> not quite
00:55:33 <jle`> the State type doesn't chain anything together
00:55:43 <mroman_> anyway I can't use mapM ;)
00:55:46 <jle`> and it doesn't really carry around a tuple
00:55:48 <mroman_> see line 3
00:56:04 <jle`> (ah, i see:) )
00:56:19 <jle`> State s a represents a function s -> (a, s)
00:56:31 <jle`> in fact, you could implement it as newtype State s a = State (s -> (a, s))
00:56:48 <jle`> State is a function on a starting state that results in a result, and a "modified"/new state
00:57:04 <jle`> note that there isn't anything involving chaining or anything as a part of what the type is
00:57:13 <jle`> it's just a function, s -> (a, s)
00:57:16 <mroman_> (changing to State.Lazy doesn't help either btw)
00:57:29 <jle`> mhm, and i'm goig to attempt to explain why :)
00:57:34 <mroman_> :)
00:57:40 <jle`> so, what is the type of your map'?
00:58:08 <mroman_> State ([Exp],[Exp]) [Exp]
00:58:23 <mroman_> what's at least the return type
00:58:47 <jle`> okay, so
00:58:52 <mroman_> it's [Exp] -> [Exp] -> State ([Exp],[Exp]) [Exp]
00:58:55 <jle`> State has a useful Monad instance
00:59:22 <jle`> that takes an (s -> (a, s)), a (a -> (s -> (b, s))
00:59:28 <jle`> and "merges it" into one giant (s -> (b, s))
00:59:57 <jle`> the resulting `b` is the result of feeding it through the first function and then taking the (a, s) and feeding it to the second function
01:00:10 <jle`> the resulting `s` is also the result of that, as well
01:00:34 <jle`> this is how (>>=) is implemented for State
01:00:51 <jle`> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
01:00:51 <lambdabot> f a b c =
01:00:51 <lambdabot>     case a c of
01:00:51 <lambdabot>     (d, e) -> b d e
01:01:06 <jle`> so, in your map'
01:01:18 <jle`> let's say your list is a hundred elements long
01:01:25 <jle`> how many (>>=)'s are there?
01:01:44 <mroman_> a hundred I'd say
01:01:50 <jle`> give or take
01:02:00 <jle`> so remember that, after all of this
01:02:18 <mroman_> but I need to use it on infinite lists :(
01:02:23 <jle`> you get a final function, s -> (b, s)
01:02:29 <jle`> that's the final result of your map'
01:02:38 <jle`> it takes an input state, and returns the result, and then the output state
01:02:53 <jle`> now, when you think about laziness, you think about the laziness of the result, the b
01:03:13 <jle`> if you don't use all the elements of the resulting b...then not all of the elements of the original list are evaluated, right?
01:03:19 <nshepperd> surely you can use concat . mapM (runStack f . return) here
01:03:31 <jle`> if you only use ten elements of the resulting b, you'd expect only the first ten elements of the input list to be evaluated?
01:03:41 <mroman_> jle`: of course
01:03:44 <jle`> however
01:03:49 <jle`> what about the resulting `s`?
01:04:09 <mroman_> the "state"?
01:04:11 <jle`> in order to *know* the resulting state, you have to resolve every single (>>=)
01:04:15 <mroman_> I don't care about that
01:04:18 <mroman_> I just wan't the result :)
01:04:29 <jle`> yeah, the resulting ([Exp], [Exp]) at the of the list
01:04:49 <jle`> well...if you throw it away and runState that, then you should be ok, i think
01:05:01 <jle`> however, if you ever (>>=) the result of map' to another State s a...
01:05:13 <mroman_> oh wait
01:05:18 <mroman_> No, I need the state
01:05:20 <jle`> in order to get the "resulting state", it has to evaluate every single call to (>>=)
01:05:22 <mroman_> but just parts of it
01:05:28 <jle`> what parts?
01:05:48 <mroman_> if my state is (a,b)
01:06:14 <mroman_> then runStack saves a, computes the function, retreives the new a
01:06:16 <mroman_> ah
01:06:20 <mroman_> I'll just paste the source of it
01:06:37 <mroman_> http://lpaste.net/110242
01:06:57 <mroman_> BlsqProg is just a type synonym for [Exp]
01:07:04 <mroman_> and BlsqStack as well ;)
01:07:52 <mroman_> runStack temporarily replaces the first element of the state tuple
01:08:08 <mroman_> so
01:08:09 <jle`> so what parts of the final state do you ever use?
01:09:23 <mroman_> runStack evaluates p with a predefined stack (xs)
01:09:46 <mroman_> which means eval p doesn't have an effect on the stack since it's restored in line 7
01:09:54 <mroman_> however, it carries orund the second element of the tuple
01:10:12 <mroman_> because the changes eval p makes to the second element of the tuple are important and need to be kept
01:10:24 <mroman_> hm
01:10:34 <mroman_> can't I run eval in an runState/exectState?
01:10:40 <mroman_> would that preserve lazyness?
01:10:51 <jle`> lazyness is still here
01:11:07 <mroman_> Not the way I need it :(
01:11:10 <jle`> but what you are asking cannot possibly be done lazily, as it is
01:11:40 <jle`> do you `take n` the result of map' some time?  why not take n the result of the input to map'?
01:12:45 <mroman_> hm?
01:13:17 <mroman_> jle`: Backwards compatibility
01:13:29 <mroman_> Existing programs rely on my interpreter doing lazy evaluation
01:13:36 <mroman_> but now it ain't doing it no more.
01:13:45 <mroman_> which breaks a lot
01:13:56 <nshepperd> I don't get it, the head of the list (runStack f [x] : _) should be computed immediately, so that you can straight away do `take n` on the map as long as it's using State.Lazy
01:14:20 <jle`> the problem is that, to know the resulting state, you need to go through the entire list
01:14:30 <jle`> and you need to know the resulting state because you later, presumably, use (>>=)
01:14:41 <jle`> with the result of map'
01:14:48 <jle`> and (>>=) uses the resulting state of map'
01:15:47 <nshepperd> oh, I assumed they are using evalState on the output of this function to get the value
01:16:14 <mroman_> nshepperd: not immediately
01:16:24 <mroman_> at the end of the interpreter there's an execState
01:18:36 <nshepperd> oh
01:19:46 <jle`> the way it is written, even though it seems that you can "short circuit" the evaluation of the result, you can't "short circuit" the infinite chain of (>>=)'s necessary to resolve the final state
01:19:53 <mroman_> but wait
01:20:06 <mroman_> if I use execState on map' it would work?
01:20:38 <mroman_> (probably not I guess)
01:20:45 <jle`> no, because the final state is the result of an infinite amount of (>>=)'s
01:20:59 <mroman_> man :(
01:21:16 <mroman_> ok
01:21:18 <mroman_> so this means
01:21:19 <jle`> remember that these are all just noramla function calls
01:21:21 <jle`> and function composition
01:21:25 <mroman_> since I can't break backwards compatibility
01:21:41 <jle`> i actually welcome you to hand-evaluate and hand-unroll these binds :)
01:21:41 <mroman_> I have to provide the old map function that can't access global variables
01:21:50 <mroman_> and a map function that isn't lazy but can do exactly that
01:21:57 <jle`> and you'll see why this can't happen
01:22:10 <jle`> because this is just normal functio composition that you can evaluate by hand...no magic
01:22:13 <jle`> hm
01:22:15 <nshepperd> maybe you could use a ReaderT with `local` instead of saving and restoring the stack
01:22:31 <jle`> yeah, i was going to say.  does your map' thing ever need to *change* the state?
01:22:59 <jle`> if it doesn't, then you can just either make it have an extra input with the state
01:23:02 <mroman_> jle`: only the second element of the tuple
01:23:08 <jle`> oh, it changes it?
01:23:12 <mroman_> yes
01:23:40 <trap_exit_> what is the simplest library in haskell to play a sine wave? I'm looking for something really basic that supports PCM
01:23:42 <mroman_> it's like this
01:23:47 <trap_exit_> I'm on OSX
01:24:00 <jle`> what did you expect to happen?  that if you take 10 the result, only the first ten state changes are registered?
01:24:05 <mroman_> your stack is [1,2] and you evaluate an addition using runStack
01:24:20 <mroman_> it will set the stack to [1,2] evalute the addition
01:24:25 <mroman_> which results in the stack being [3]
01:24:38 <mroman_> then it remembers that, restores the stack to [1,2] again and returns [3]
01:24:52 <mroman_> that's what happens to the first element of the tupel
01:25:13 <mroman_> however, changes made to the second element aren't saved and restored
01:25:23 <nshepperd> what is the second element?
01:25:28 <mroman_> because runStack is allowed to modify the second element, but not the first
01:25:33 <mroman_> nshepperd: it's technicall another stack
01:25:39 <mroman_> there's a "local" and a "global" stack
01:25:58 <mroman_> well
01:26:06 <mroman_> at least there are two stacks ;)
01:26:21 <mroman_> I refer to the first element as the "global stack" and the second as the "global state stack"
01:26:35 <mroman_> and runStack runs on a "temporarily local stack"
01:26:49 <mroman_> (i.e. runStack has no effect on the global stack but an effect on the global state stack)
01:27:38 <jle`> does it need to know the global stack?
01:28:56 <nshepperd> well okay, writing to global variables does not play well with laziness
01:29:11 <nshepperd> unless you know beforehand which variables will be written to
01:29:50 <jle`> i don't think that's quite the problem here...the issue is that (>>=) has to be run on every element of the list, regardless of whether or not the final result is used
01:30:12 <jle`> because of the way State's monad instance inherently works
01:30:30 <nshepperd> so that you know when you need to evaluate the action because a written value is called for
01:32:18 <nshepperd> that's true, but you can get around that
01:36:48 <nshepperd> using execState inside of runState, for example, would remove a whole bunch of (>>=) from the chain, which would only be computed when the value is called for
01:37:02 <nshepperd> er, inside runStack
01:39:21 <nshepperd> actually, shouldn't you be able to shortcircuit `execState (foo >> put bar)` generally?
01:40:21 <jle`> nshepperd: the problem isn't evaluating the state as much as evaluating the function to create the state, i think
01:40:40 <nshepperd> although, you still have to evaluate the (>>) to get to the point of realising there's a 'put' at the end, I guess
01:40:57 <jle`> if you have an infinite list of (>>)'s, you can't really prove that every (>>) "ignore sthe last state" until you evaluate all of the (>>) functions
01:43:26 <jle`> > let andThen f g s1 = let (_, s2) = f s1 in g s2
01:43:27 <lambdabot>  not an expression: ‘let andThen f g s1 = let (_, s2) = f s1 in g s2’
01:43:28 <jle`> oops
01:43:34 <jle`> @let andThen f g s1 = let (_, s2) = f s1 in g s2
01:43:36 <lambdabot>  Defined.
01:43:42 <jle`> @let ret = (,)
01:43:43 <lambdabot>  Defined.
01:43:47 <nshepperd> hmm, does that mean that using execState to try and "hide" some operations would actually help?
01:44:18 <jle`> @let map' _ [] = ([],); map' f (x:xs) = f x `andThen` map' f xs
01:44:19 <lambdabot>  Defined.
01:44:49 <jle`> @let testSF = map' (ret . (*2)) [1..] `andThen` ret 0
01:44:51 <lambdabot>  Defined.
01:45:10 <nshepperd> because you're basically zippering the State object to make the 'ends' more accessible
01:45:15 <jle`> > print (testSF 0)
01:45:17 <lambdabot>  <IO ()>
01:45:23 <jle`> > show (testSF 0)
01:45:27 <lambdabot>  mueval-core: Time limit exceeded
01:45:57 <jle`> well if you ran on it on ghc, you'd see that it prints out "(0," ... and then hangs
01:46:00 <jle`> ghci
01:46:16 <nshepperd> `a >> big-thing >> put` instead of `a >> b >> c >> d >> e >> f >> put`
01:46:19 <jle`> because of laziness, it doesn't need to evaluate the entire infinite list to give the result
01:46:36 <jle`> but to give the end state, it needs to evaluate the entire infinite list
01:46:57 <jle`> (even though in the actual function, the end state is unmodified.  but it has to evaluate each one to know that the end state is unmodified)
01:48:28 <brbblnch> hi
01:48:55 <jle`> > (map' (ret . (*2)) [1..100] `andThen` ret 0) 0
01:48:56 <lambdabot>  (0,0)
01:49:00 <jle`> hi brbblnch :)
01:49:30 <nshepperd> > (map' (ret . (*2)) [1..] `andThen` const (1,1)) 0
01:49:32 <lambdabot>  (1,1)
01:50:15 <jle`> hm
01:50:57 <jle`> @let put' s = const ((), s)
01:50:59 <lambdabot>  Defined.
01:51:23 <jle`> > (map' (ret . (*2)) [1..100] `andThen` put' 0) 1
01:51:25 <lambdabot>  ((),0)
01:52:22 <jle`> oops
01:52:27 <jle`> > (map' (ret . (*2)) [1..] `andThen` put' 0) 1
01:52:28 <lambdabot>  ((),0)
01:53:14 <jle`> in this case laziness works :)
01:53:41 <brbblnch> I'm trying to use/understand parsec (http://book.realworldhaskell.org/read/using-parsec.html) and I want to parse a stream of tokens that aren't chars. The tutorial linked seems to construct parsers on a predefined 'char' basis parser. How to create my basis parser for my custom type ?
01:55:16 <arianvp> I met some haskell guys on the train yesterday.  Community is pretty small.  So perhaps are you two here on the IRC?
01:55:28 * arianvp fingers crossed
01:56:33 <nshepperd> @let into f g s1 = let (x, s2) = f s1 in g x s2
01:56:34 <lambdabot>  Defined.
01:56:49 <jle`> so for some reason, put seems to make a difference. i didn't expect that
01:57:14 <jle`> but thinking it over, it makes sense :)
01:57:30 <nshepperd> @let get' x = (x,x)
01:57:31 <lambdabot>  Defined.
01:58:35 <nshepperd> > (get' `into` \(x,y) -> map' (ret . (*2)) [1..] `andThen` put' (x,y)) (1,2)
01:58:36 <lambdabot>  ((),(1,2))
01:58:41 <mroman_> jle`: I seemed to have managed to make it lazy again
01:58:42 * hackagebot robot 1.3.0.1 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.3.0.1 (ChrisWong)
01:59:08 <nshepperd> > (get' `into` \(x,y) -> map' (ret . (*2)) [1..] `andThen` get' `into` \(a,b) -> put' (x,b)) (1,2)
01:59:12 <lambdabot>  mueval-core: Time limit exceeded
01:59:34 <mroman_> jle`: http://lpaste.net/110243
01:59:38 <nshepperd> oh right, mueval won't want to show the (1,
02:00:26 <jle`> brbblnch: someone actually just asked that the other day, and i think the conclusion was that parsec makes it a little tricky.  you need to use tokenPrim
02:00:29 <jle`> unfortunately
02:01:20 <brbblnch> jle`: thanks!
02:01:29 <jle`> mroman_: congrats :)
02:01:54 <jle`> breaking out of (>>=) and the monad instance is one way to bypass the problem
02:02:04 <jle`> State's monad instance is useful, but it is not the only way to interface with teh State type
02:02:08 <mroman_> yeah
02:02:18 <mroman_> but it's only lazy under certain circumstances
02:02:35 <mroman_> it's only lazy if a programmer doesn't ask for something on the global state stack after the map
02:02:52 <mroman_> i.e. if he modifies the global state stack and asks for that later on
02:02:53 <jle`> if your two states are separate
02:02:58 <brbblnch> So the model:     Rawtext -[lexer]-> Tokens -[parser]-> AST    is not really supported/liked by parsec ?
02:02:59 <mroman_> it will fail
02:03:14 <jle`> then you might be able to enforce it statically
02:03:28 <jle`> by doing runState as a pure function, inside the outer global state
02:04:22 <jle`> i think nshepperd has a nice potential solution too
02:04:46 <mroman_> at least I'm backwards compatible again :)
02:04:50 <jle`> mroman_: :)
02:05:09 <jle`> brbblnch: i don't think it's really encouraged
02:05:15 <jle`> but i am not a parsec expert, so i can't really say
02:05:36 <jle`> usually parsec is used as both the lexer and the parser, i believe
02:05:45 <sagittarian_> does anyone know how to enter a multiline definition with a where clause in ghci after setting :set +m?
02:05:55 <mroman_> now I have to make the same modificiation to filter' too
02:06:00 <mroman_> and then I should be fine
02:06:11 <brbblnch> ok, thanks
02:06:28 <jle`> it has some tokenizing utilities built in
02:06:43 <mroman_> I'll just add a slight hint that asking for the global state stack *might* break lazyness for now
02:07:11 <mroman_> which makes sense
02:07:23 <mroman_> since you are asking for take 5 for the first element
02:07:35 <mroman_> but not for the second element I guess
02:08:07 <mroman_> i.e. "pop from global state stack" requires that you know the "top" of the global state stack
02:08:23 <mroman_> and if you do mapM (\x -> pushToGlobalStateStack x) [1..]
02:08:30 <mroman_> you'll never know the top of it :)
02:09:18 <mroman_> cool stuff :)
02:10:08 <brbblnch> mmh, I found that: http://www.vex.net/~trebla/haskell/parsec-generally.xhtml . It also mentions tokenPrim
02:12:08 <jle`> mroman_: :)
02:13:00 <jle`> brbblnch: here is a usage of tokenPrim to implement satisfy :: (Char -> Bool) -> Parser Bool
02:13:02 <jle`> http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Char.html#satisfy
02:13:17 <jle`> it's kind of silly that it isn't made polymorphic on Char
02:13:27 <jle`> because there's no reason it can't be
02:13:36 <jle`> sorry, (Char -> Bool) -> Parser Char
02:13:43 <jle`> it could have been made (a -> Bool) -> Parser a
02:14:16 <jle`> i think it has to do with how the internal Parser type is implemented, which is streamlined towards streams of characters/text
02:15:00 <mroman_> crap
02:15:05 <mroman_> It's not working for filter'
02:16:18 <mroman_> ah. *typo*
02:16:20 <mroman_> yay
02:16:21 <mroman_> :D
02:17:09 <mroman_> Good thing I noticed this "break lazyness" before deploying
02:17:56 <masak> not 100% on-topic, but I couldn't think of where else to ask, and maybe someone here has a good answer: why is it called "lambda calculus" and not "lambda algebra". as far as I understand, calculus is concerned with things like rate of change and integration; algebra is the study of symbols and rules.
02:20:44 <Iceland_jack> masak: “More generally, calculus (plural calculi) refers to any method or system of calculation guided by the symbolic manipulation of expressions.” from https://en.wikipedia.org/wiki/Calculus
02:20:56 <mroman_> > take 5 $ filter (\x -> x < 10) [1..]
02:20:57 <lambdabot>  [1,2,3,4,5]
02:21:06 <mroman_> > take 5 $ filter (\x -> x < 1) [1..]
02:21:10 <lambdabot>  mueval-core: Time limit exceeded
02:21:15 <Iceland_jack> Calculus is by no means limited to differential/integral calculus
02:21:18 <mroman_> ^- there's no way to make that work, right?
02:21:31 <Iceland_jack> mroman_: No, you want ‘takeWhile’
02:21:33 <Iceland_jack> @ty takeWhile
02:21:35 <lambdabot> (a -> Bool) -> [a] -> [a]
02:21:57 <Iceland_jack> > takeWhile (< 10) [1..]
02:21:58 <mroman_> No, I want take ;)
02:21:59 <lambdabot>  [1,2,3,4,5,6,7,8,9]
02:22:03 <Iceland_jack> > take 5 $ takeWhile (< 10) [1..]
02:22:04 <lambdabot>  [1,2,3,4,5]
02:22:09 <Iceland_jack> > take 5 $ takeWhile (< 3) [1..]
02:22:11 <lambdabot>  [1,2]
02:22:25 <mroman_> > take 5 $ takeWhile (<1) [1..]
02:22:27 <lambdabot>  []
02:22:48 <mroman_> but takeWhile ain't filter
02:23:11 <Iceland_jack> Yes but the effect you were asking for is not what filter does
02:23:30 <mroman_> Yeah. It's not possible the way I head in my head
02:34:13 <masak> Iceland_jack: can you think of some other method or system of calculation guided by symbolic manipulation of expressions, besides infinitesimal/integral calculus and lambda calculus?
02:34:56 <Iceland_jack> pi calculus
02:36:22 <Iceland_jack> masak: Just search for 'calculus' there https://en.wikipedia.org/wiki/Category:Logical_calculi https://en.wikipedia.org/wiki/Category:Lambda_calculus
02:36:35 <masak> yeah; finding more examples as we speak.
02:36:41 <masak> thank you; that cleared it up.
02:36:52 <brbblnch> Thanks again, jle`
02:37:35 <Iceland_jack> masak: You may be interested in this too: http://math.stackexchange.com/questions/54763/what-do-algebra-and-calculus-mean
02:38:10 <masak> would it have made sense for it to have been called "lambda algebra"? is it still mostly a historical accident that it wasn't?
02:38:58 <Cale> masak: Sure. It's also a calculus though.
02:39:41 <masak> *nod*
02:40:28 <Iceland_jack> This one also has good answers http://mathoverflow.net/questions/36758/difference-between-a-calculus-and-an-algebra
02:40:36 <aegray> If I wanted to implement a function that, given an Int, returned Int->Int, and given a String, returns String - is that possible?
02:41:01 <jle`> aegray: you could use sum types
02:41:07 <Iceland_jack> aegray: sure, what is the use case?
02:41:07 <shachaf> In a roundabout way, yes, but it's not recommended.
02:41:15 <jle`> but you wouldn't be able to enforce that it maps to the same type
02:41:17 <jle`> statically
02:41:53 <jle`> usually though you don't actually want this :)
02:42:53 <aegray> Iceland_jack: I'm playing around with some ideas for an frp compiler we have and I'm seeing if its possible to make my compile function return a function of the time varying input sources used throughout the code
02:42:59 <Iceland_jack> You can also use associated types or fundeps aegray
02:43:02 <aegray> really just playing
02:43:18 <aegray> ok time for me to get reading on those
02:43:20 <aegray> thx
02:43:53 * hackagebot between 0.9.0.2 - Function combinator "between" and derived combinators  http://hackage.haskell.org/package/between-0.9.0.2 (PeterTrsko)
02:44:26 <Iceland_jack>     class    Foo f      where { type Ba f; foo :: f -> Ba f }
02:44:26 <Iceland_jack>     instance Foo Int    where { type Ba Int = Int -> Int; foo = (*) }
02:44:26 <Iceland_jack>     instance Foo String where { type Ba String = String; foo = id }
02:45:07 <Iceland_jack> Then
02:45:07 <Iceland_jack>     foo :: Int -> Int -> Int
02:45:07 <Iceland_jack> and
02:45:07 <Iceland_jack>     foo :: String -> String
02:53:09 <edlinde> hi guys, I have used haskell a while back.. wondering where I can learn more details about monads?
02:53:20 <edlinde> is LYAH still a good resource?
02:53:28 <Iceland_jack> sure
02:55:39 <MP2E> for good reading on Monads : http://dev.stephendiehl.com/hask/#monads
02:58:59 <edlinde> I actually never got around to reading monads
02:59:01 <edlinde> :)
02:59:12 <edlinde> wondering what it is really? like in layman terms?
02:59:35 <edlinde> I am about to work on a project that makes heavy use of monads to get data from the underlying filesystem
02:59:51 <Freundlich> You need to use them and you will understand.
03:00:56 <edlinde> I should really get back into a bit of Haskell programming :)
03:01:25 <Freundlich> The term "abstraction" comes from abstracting things. They usually don't come out of nothing.
03:02:49 <MP2E> edlinde : Are you familiar with a Functor?
03:03:11 <edlinde> MP2E: its been a while .. lemme just check it out
03:03:21 <edlinde> unless you can just spell it out
03:03:25 <edlinde> is it a higher order fn?
03:04:04 <edlinde> ah got it
03:04:08 <edlinde> its just a container yeah
03:04:20 <edlinde> on which a function like map can be applied
03:04:25 <edlinde> http://www.haskell.org/haskellwiki/Typeclassopedia#Functor
03:04:55 <Iceland_jack> @src Functor
03:04:56 <lambdabot> class  Functor f  where
03:04:56 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:05:06 <MP2E> For some things it can be thought of as a container, but it's more than that. It's a computational context. Scary jargon aside, take a look at something like 'IO Int', say if you want to read an Int from a user
03:05:24 <MP2E> Well if you want to apply (+2) to that int, you're stuck without a functor
03:05:34 <MP2E> but I wouldn't say that the functor is moving +2 inside a container here :)
03:08:48 <edlinde> ok
03:08:53 <pjdelport> edlinde: To understand the essence of them, forget about Monad until you feel you understand Functor
03:09:02 <pjdelport> And probably Applicative too
03:09:05 <edlinde> ok
03:09:11 <edlinde> so how do I refresh all this stuff?
03:09:26 <pjdelport> In terms of dependency: Functor -> Applicative -> Monad
03:09:29 <phaazon> hey
03:09:30 <pjdelport> Each one builds on the previous
03:09:43 <edlinde> I have done all this stuff in the past .. maybe up to applicative
03:09:54 <edlinde> I remember finding the LYAH tutorial quite useful
03:09:58 * gfixler just got to applicative in LYAH tonight
03:10:02 <edlinde> is there a better resource that you guys use?
03:10:16 <edlinde> ofcourse I need to practise too :)
03:10:18 <pjdelport> edlinde: IMHO, the best way to think of Functor is as an abstract structure with typed slots that you can operate on.
03:10:38 <edlinde> whats a “typed slot"?
03:10:47 <MP2E> I learned from LYAH, but I've also read a few other books and many many papers/blogposts/wiki entries. I think LYAH is a great place to start
03:10:54 <pjdelport> edlinde: "structure" doesn't mean a data structure; just some kind of computational structure or context for the "slots" that you operate on.
03:11:04 <MP2E> :k []
03:11:06 <lambdabot> * -> *
03:11:16 <edlinde> what books?
03:11:22 <gfixler> pjdelport: a list of Ints has a bunch of Ints in it - are these indexed locations in the list 'slots?'
03:11:32 <pjdelport> edlinde: For example, the IO foo is an IO action resulting in foo: In that case, the "structure" is the IO effect, and the "slot" is the result, foo
03:11:40 <MP2E> Real World Haskell, Parallel and Concurrent Programming in Haskell
03:11:56 <pjdelport> gfixler: Yup. So in list's case, the "structure" is the shape of the list, and the "slots" are the list elements.
03:11:59 <edlinde> MP2E: thanks
03:12:13 <edlinde> pjdelport: not getting it at the moment sorry.. maybe I need to read up a little
03:12:16 <gfixler> pjdelport: and a tree's nodes are its slots, and a functions slot is its eventual output
03:12:18 <MP2E> the functional pearls are great papers to read, dohaskell.com has a ton of links to great blog posts from around the community
03:12:20 <pjdelport> :t fmap
03:12:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:13:07 <pjdelport> edlinde: In the above signature for fmap, you can thinkof the "f" as representing the structure you're operating in terms of, and a and b are the "slot" types.
03:13:51 <edlinde> I just roughly got the idea when you were talking about the list context
03:13:52 <pjdelport> So fmap takes a structure with slots of type a (f a) and transforms it into a structure with slots of type b (f b) using the provided function (a -> b)
03:14:06 <edlinde> so in the list the structure is the shape of the list and the slots are the list elements
03:14:18 <pjdelport> And the important bit is that that fmap is *structure-preserving*: that's what the Functor laws mean.
03:14:29 <edlinde> so these “slots”.. are these where you can plugin a function to operate on the elements/slots?
03:15:11 <pjdelport> So fmap guarantees that the *structure* stays unchanged, even though the content of the slot(s) are replaced.
03:15:25 <edlinde> I really need to brush up my haskell :(
03:15:39 <edlinde> think I will get cracking again with LYAH
03:15:46 <pjdelport> So again, in list's case, "structure-preserving" means that the size and order of the list stays the same, even though the elements get replaced.
03:15:56 <edlinde> hmm ok
03:16:32 <edlinde> same can be thought of even in a tree structure I guess
03:16:34 <pjdelport> In IO's case, "structure-preserving" means that the IO action's *effect* stays the same, even though the result gets "replaced" or transformed
03:16:38 <pjdelport> Yup.
03:16:39 <gfixler> pjdelport: helpful to make a concrete version for list? Functor [] => (a -> b) -> [] a -> [] b
03:16:40 <edlinde> but then I was thinking about the “traversal” style
03:16:50 <edlinde> can that be a functor in some sort?
03:17:18 <edlinde> like say you wanted to access all nodes in a tree in DFS fashion and apply some function like say print to the nodes?
03:17:30 <edlinde> is this written as a functor?
03:17:50 <pjdelport> Traversal is a slightly different thing, but yeah, it's related.
03:17:59 <edlinde> ok
03:18:11 <pjdelport> If you mean the Traversable class, for example, it's basically a combination of Functor and Foldable
03:18:15 <MP2E> edlinde : Yep, you definitely could use a functor for that purpose.
03:18:23 <edlinde> i see
03:18:24 <MP2E> using print on all nodes in a tree
03:18:39 <edlinde> I have done stuff like that in C++
03:18:53 <edlinde> but ofcourse I think haskell looks so much cleaner
03:19:05 <pjdelport> A Functor would only let you transform the individual tree nodes into print actions, though; it doesn't give you a way of combining all the individual print actions.
03:19:25 <pjdelport> That's where Foldable comes in: it does allow that.
03:19:27 <edlinde> and thats where you need a foldr or foldl?
03:19:32 <edlinde> ok gotcha
03:19:58 <edlinde> so that is functors… whats an applicative then? how is that different?
03:20:01 <pjdelport> And Haskell's Traversable combines both, giving you traverse
03:20:08 <edlinde> is it another level of abstraction on top of functors
03:20:27 <edlinde> is Traversible, Foldable etc covered in LYAH?
03:20:31 <MP2E> edlinde: Well, functors are great for lifting a function with one argument, but what happens if you feed it a function that takes two? Let's find out :) Say we want to add 2 lists
03:20:33 <pjdelport> edlinde: Well, all Applicatives are Functors too, by definition. Applicative takes Functor and adds two more capabilities.
03:20:46 <pjdelport> edlinde: The first is pure (also called return by Monad)
03:21:56 <pjdelport> edlinde: Essentially, pure is a distinguished "default" structure for your Functor that you can lift any plain, pure Haskell value into.
03:22:48 <pjdelport> For example, for list, pure x is [x]: the singleton list. For IO, pure x is a no-op (effect-free) IO action that just returns x.
03:22:59 <pjdelport> For Maybe, pure x is Just x. And so forth.
03:23:11 <edlinde> pjdelport: I got to run soon sorry.. but if I went through LYAH and then real-world Haskell can I get the hang of this stuff?
03:23:28 <edlinde> I know LYAH has added many more newer topics since I looked at it last
03:23:44 <pjdelport> edlinde: Maybe :) I'm not sure offhand how well they cover this particular intuition.
03:24:01 <gfixler> edlinde: I've been reading LYAH, and going through CIS 194, which recommends chapters in RWH
03:24:04 <pjdelport> But before you go, then, the second important thing that Applicative adds is <*>: function application lifted into the functor.
03:24:09 <gfixler> so it's like a triple-attach
03:24:11 <gfixler> attack*
03:24:16 <no-doz> people should read lyah, then rwh?
03:24:31 <edlinde> ok but then I can always ask you guys when I am stuck :)
03:24:31 <edlinde> at the moment all my concepts are quite rusty
03:24:31 <edlinde> ok
03:24:51 <gfixler> no-doz: they both progress from basic to advanced - I think reading in parallel is probably better, to let intuitions bolster each other
03:25:10 <gfixler> no-doz: if you read one, then switch, suddenly you're learning about basic typeclasses and things again
03:25:16 <pjdelport> So where Functor only lets you apply a *pure* function to a functorial value, Applicative lifts function application in general into the context of the functor. Which means you can say for example:
03:25:16 <pjdelport> > [(1+), (2+)] <*> [20, 30]
03:25:18 <lambdabot>  [21,31,22,32]
03:25:36 <no-doz> gfixler: ahhh
03:25:37 <pjdelport> > Just (+) <*> Just 2 <*> Just 3
03:25:39 <lambdabot>  Just 5
03:25:46 <pjdelport> > Just (+) <*> Just 2 <*> Nothing
03:25:48 <lambdabot>  Nothing
03:25:59 <pjdelport> > Nothing <*> Just 2 <*> Just 3
03:26:00 <lambdabot>  Nothing
03:26:57 <pjdelport> :t (<$>)
03:26:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:27:01 <pjdelport> :t (<*>)
03:27:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:27:09 <pjdelport> (<$> is just fmap, of course)
03:27:26 * gfixler might actually be understanding this finally
03:27:29 <pjdelport> So you can think of <*> as being like <$> / fmap, except that *both* sides are functorial values, not just the right side.
03:29:06 <gfixler> pjdelport: in Just (+) <*> Just 2 <*> Nothing are the <*> acting a bit like $, but at a higher level?
03:29:12 <pjdelport> So remembering that you can use pure to lift any value into a "default" functorial value, you can write fmap f [1,2,3] as:
03:29:12 <pjdelport> > pure f <*> [1,2,3]
03:29:13 <lambdabot>  No instance for (GHC.Show.Show b0)
03:29:13 <lambdabot>    arising from a use of ‘M64161477275505168268822.show_M64161477275505168268...
03:29:13 <lambdabot>  The type variable ‘b0’ is ambiguous
03:29:13 <lambdabot>  Note: there are several potential instances:
03:29:13 <lambdabot>    instance [safe] GHC.Show.Show
03:29:47 <pjdelport> (ignore that error)
03:30:12 <pjdelport> But because it's symmetric, you could also write: [f, g, h] <*> pure 5
03:30:25 <gfixler> whoa
03:30:35 <pjdelport> The first applies a function to many values; the second applies many functions to a single value.
03:31:08 <pjdelport> And of course you can apply many functions to many values: [f, g, h] <*> [1,2,3]
03:31:09 <no-doz> :)
03:32:05 <gfixler> what's the default structure that pure lifts a function into?
03:32:22 <gfixler> list?
03:32:27 <mindfreak> minimal context
03:32:45 <gfixler> (yeah, that's what I'm operating under ;)
03:33:09 <pjdelport> gfixler: It depends on the functor: but it has has to be a "faithful" default structure, for whatever meaning the functor's structure has.
03:33:29 <gfixler> just tried this:
03:33:32 <pjdelport> It must obey: f <$> pure x == pure (f x)
03:33:34 <gfixler> > pure (+1)
03:33:35 <lambdabot>  No instance for (GHC.Show.Show (f0 (a0 -> a0)))
03:33:35 <lambdabot>    arising from a use of ‘M91747662026113290218876.show_M91747662026113290218...
03:33:35 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
03:33:35 <lambdabot>  Note: there are several potential instances:
03:33:35 <lambdabot>    instance [safe] GHC.Show.Show a =>
03:33:43 <gfixler> > :t pure (+1)
03:33:44 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:33:46 <pjdelport> So pure isn't allowed to just throw away the value, or whatever.
03:33:48 <gfixler> :t pure (+1)
03:33:49 <lambdabot> (Applicative f, Num a) => f (a -> a)
03:33:52 <gfixler> there we go
03:34:04 <pjdelport> For list, pure x == [x]
03:34:26 <gfixler> pjdelport: you say 'for list' - where does list come in?
03:34:32 <gfixler> x is just a value, no?
03:34:46 <pjdelport> So that means you you can also write "pure f <*> [1,2,3]" as "[f] <*> [1,2,3]"
03:35:05 <pjdelport> gfixler: For list as the Functor, i mean :)
03:35:15 <gfixler> hmmm
03:35:25 <gfixler> which part of this is the Functor? :)
03:35:30 <gfixler> the [1,2,3]?
03:35:38 <pjdelport> The list type, yeah.
03:35:41 <gfixler> I see
03:35:42 <pjdelport> pure will have a different meaning for every individual functorial type
03:35:47 <doismellburning> anyone have a favourite twitter library?
03:35:54 <pjdelport> For Maybe as the functor, pure is Just
03:36:04 <gfixler> so pure f <*> someTree will lift f into a tree context?
03:36:04 <doismellburning> hs-twitter doesn't build for me, most of the rest of https://hackage.haskell.org/packages/search?terms=twitter seem undocumented...
03:36:12 <Peaker> if I have: "mask_ $ uninterruptibleMask $ interruptibleOp" and an async exception is thrown at interruptibleOp. Will it discharge when reaching mask_ ?
03:36:12 <Peaker> (or only when leaving mask_?)
03:36:26 <pjdelport> gfixler: Well, that will apply f to each of the tree's slots, yeah.
03:36:36 <pjdelport> In general, pure f <*> x == f <$> x
03:37:21 <pjdelport> And just to ground this in a non-data-structure example too: pure (++) <*> getLine <*> getLine
03:37:29 <gfixler> I'll be reading through applicatives in LYAH tonight or tomorrow, which should help
03:37:49 <gfixler> right, concat the strings returned by getLines
03:37:57 <gfixler> but wrapped in an IO?
03:38:32 <pjdelport> There, the Applicative is IO, and pure gives you a "dummy" IO action that returns (++), which gets applied to the results of each of the following actions.
03:39:05 <gfixler> the getLines would both need to be IO actions, right?
03:39:29 <pjdelport> Yup (and they are :)
03:39:34 <pjdelport> :t getLine
03:39:34 <lambdabot> IO String
03:39:35 <gfixler> pjdelport: waaait a minute
03:39:47 <gfixler> when you say 'returns (++)' - you mean the monadic return?
03:39:59 <gfixler> or whatever 'return' inside an io action is?
03:40:00 <fds4345> monkey = (:[])
03:40:02 <pjdelport> gfixler: No, just "results in"
03:40:06 <gfixler> pjdelport: okay
03:40:11 <pjdelport> pure == return
03:40:26 <gfixler> and they're different simply because they work differently/at different levels/
03:40:27 <gfixler> ?
03:40:33 <pjdelport> So Monad's return should actually be part of Applicative, not Monad; it only exists for historical reasons.
03:40:46 <pjdelport> No, they're basically synonyms :)
03:40:52 <gfixler> hmmm
03:40:53 <pjdelport> No semantic difference.
03:40:57 <gfixler> that's extra confusing
03:41:19 <pjdelport> It's juts because Monad predates splitting out Applicative into its own class, in Haskell.
03:41:36 <pjdelport> So wherever you see "return" you can mentally translate that into "pure"
03:41:39 <gfixler> pjdelport: I feel like I heard Edward Kmett talk about this on the first Haskell Cast
03:41:46 <gfixler> or maybe the hosts
03:41:48 <funrep_> http://www.reddit.com/r/haskell/comments/2ez5pj/has_anyone_had_success_using_phonegap_and_haste/
03:41:51 <funrep_> interesting idea
03:42:02 <haasn> Good thing the AMP is coming in 7.10 and making everything awesome
03:42:04 <pjdelport> So anyhow, the important idea to remember is that <*> means "structure-preserving function application".
03:42:17 <gfixler> pjdelport: so is the plan to lose return in monads and have monads use the pure from applicative?
03:42:28 <gfixler> pjdelport: that may answer my earlier question
03:42:42 <gfixler> Just (+) <*> Just 5 <*> Just 3
03:42:56 <gfixler> pjdelport: ^^ I was wondering if <*> were like $, but at a higher level
03:43:11 <pjdelport> gfixler: Exactly :)
03:43:16 <gfixler> cool
03:43:26 <haasn> (<*>) = liftA2 ($)
03:43:27 <pjdelport> In fact, (<*>) == liftA2 ($)
03:43:30 <haasn> :)
03:43:41 <pjdelport> So <*> is *literally* "lifted function application"
03:43:43 <gfixler> :)
03:43:47 <gfixler> pjdelport: nice!
03:44:01 <haasn> I like thinking about applicative in terms of liftA2
03:44:01 <gfixler> I'm not used to saying correct things in here
03:44:08 <haasn> :t liftA2
03:44:09 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:44:20 <haasn> :t liftA -- compare it to this, which is essentially just Functor
03:44:21 <lambdabot> Applicative f => (a -> b) -> f a -> f b
03:44:26 <gfixler> these signatures are looking less scary by the week
03:44:35 <haasn> :t let liftA0 = pure in liftA0 -- and this, which could totally be named this
03:44:36 <lambdabot> Applicative f => a -> f a
03:44:47 <haasn> Do you see the resemblence?
03:45:06 <gfixler> yes
03:45:19 <gfixler> liftA <-- A for Applicative?
03:45:34 <gfixler> and the liftMs I've been seeing are M for Monad?
03:45:45 <haasn> The key difference between liftA0, liftA1 and liftA2 is how many “applicative values” go into it. With liftA0 you have none (and so one is “created”), with liftA1 you have exactly one (which stays “unchanged”), with liftA2 you're combining two
03:45:47 <pjdelport> Oh, and another important intuition: pure f <*> pure a <*> pure b <*> ...  ==  pure (f a b ...)
03:45:59 <gfixler> haasn: I deduced as much :)
03:46:16 <gfixler> pjdelport: that looks like lifted function composition
03:46:18 <pjdelport> That's an important corollary of what "structure-preserving" means.
03:46:44 <gfixler> pjdelport: okay, now it stopped looking like that
03:47:11 <gfixler> pjdelport: curious what determines the structure pure lifts these into
03:47:22 <gfixler> pjdelport: I'm guessing a, b, etc must share a type?
03:47:24 <pjdelport> It basically means that performing a pure application (f a b ...), and then lifting the result with "pure" means exactly the same thing as lifting each of the individual parts into the functor with "pure", and then performing functorial function application.
03:47:37 <haasn> Lifted function composition:
03:47:39 <haasn> :t (>=>)
03:47:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:47:40 <gfixler> pjdelport: which mirrors several other things so far
03:47:45 <haasn> Is precisely what Monad lets us do (over Applicative)
03:47:54 <pjdelport> So pure must be information-preserving, in that sense.
03:47:57 <haasn> Or maybe I misunderstood what you meant by “lifted function composition”
03:47:58 <gfixler> haasn: I'm shutting off my brain to that for now :)
03:48:04 <haasn> lifted (function composition) or (lifted function) composition?
03:48:26 <gfixler> haasn: yeah, forget it - I was thinking of it more like pure f <*> pure g <*> pure h ...
03:48:29 <gfixler> i.e. several functions
03:48:53 <haasn> Lifted function composition would be like pure (.) <*> pure f <*> pure g
03:49:05 <haasn> = pure (f . g)
03:49:30 <gfixler> right
03:49:41 <gfixler> I figured it can still be functions on the right, as they're also values
03:49:49 <haasn> Here's another neat way of thinking about Applicative that I'm fond of
03:49:56 <haasn> :t liftA2 (,)
03:49:57 <lambdabot> Applicative f => f a -> f b -> f (a, b)
03:50:04 <haasn> :t pure ()
03:50:05 <lambdabot> Applicative f => f ()
03:50:17 <haasn> These two functions are equivalent to <*> and just ‘pure’
03:51:01 <haasn> The Applicative laws are just like the monoid laws
03:51:38 <gfixler> liftA2 (,) is like lifted zipping
03:51:51 <haasn> In that “pure ()” is the identity of liftA2 (,)
03:52:05 <haasn> (up to isomorphism between ((), a) ≅ a ≅ (a, ())
03:52:21 <haasn> And “liftA2 (,)” is associative, gain up to isomorphism between ((a,b),c) ≅ (a,(b,c))
03:52:31 <gfixler> what are those 5th Element water symbols?
03:52:34 <haasn> In essence, it doesn't matter in which grouping you combine actions - you always get the same “action”
03:52:48 <haasn> 5th Element water symbols? You mean ≅?
03:52:57 <trap_exit> anyone here written a theorem prover in ahskell?
03:53:02 <haasn> That's a symbol for “isomorphic to”
03:53:10 <trap_exit> I want to read about designing DSLs for expressing tactic languages,
03:53:11 <trap_exit> i.e. like the ltac in Coq
03:53:13 <haasn> Or “equal up to isomorphism”
03:53:20 <MP2E> trap_exit: I have not, but Agda is an example of that
03:53:39 <trap_exit> MP2E: is Agda written in Haskell?
03:53:42 <trap_exit> oh right, I remember, it is
03:53:42 <MP2E> Yep
03:53:54 <trap_exit> Maybe I should read Agda sources.
03:54:03 <gfixler> haasn: I'm not sure I grok how ((), a) is isomorphic to a
03:54:25 <haasn> gfixler: Can you try writing the functions?  f :: ((), a) -> a
03:54:28 <haasn> and g :: a -> ((), a)
03:54:46 <gfixler> oh, I see
03:55:04 <gfixler> I'm fairly new to isomorphisms, but that seems to make sense
03:55:24 <haasn> If you can write those and prove that f . g = id and g . f = id, then you've proven an isomorphism
03:55:36 <trap_exit> MP2E: #agda: we do not have a tactic language
03:55:45 <gfixler> haasn: nice
03:55:45 <MichaelBurge> What's the storty behind the name 'return' in the monad typeclass? Why not 'wrap' or 'lift'?
03:55:46 <trap_exit> MP2E: you lie! :-)
03:56:00 <MP2E> oh, didn't read tactics language, whoops.
03:56:14 <haasn> MichaelBurge: I believe it was just chosen because it looks sort of neat to write something like do foo <- m1; bar <- m2; return (f foo bar)
03:56:16 <trap_exit> MP2E: if you can port 7.8.3 to nixos, I'll forgive you :-)
03:56:18 <haasn> It “reads like C”
03:56:21 <haasn> (for better or for worse)
03:56:22 <MP2E> it is ported :P
03:56:27 <MP2E> haskellPackages_ghc783.ghc
03:56:29 <trap_exit> MP2E: you are hereby forgiven
03:56:50 * gfixler wishes he was there early on to say "No! Bad name! Do it again."
03:57:16 * gfixler means that for lots of things, though, not just Haskell
03:57:35 <haasn> One of the immediate corollaries, of course, is the fact that: do foo <- m1; return foo; bar <- m2; return (f foo bar) -- works nothing like C
03:57:56 <pjdelport> gfixler: Obligatory http://martinfowler.com/bliki/TwoHardThings.html
03:58:03 <haasn> s/corollaries/caveats/
03:58:07 <gfixler> pjdelport: already know what that link's about :)
03:58:25 <MichaelBurge> Yeah, I've had several people get tripped up thinking it does an early return somehow
03:59:00 <haasn> One of the caveats to the caveat is that this is not something that will show up either way because “do return x; ...” is just the same as “do ...”
03:59:21 <haasn> So we can “get away with it”. It's still a good example of explaining how “return” is nothing at all like “return” though
03:59:25 <haasn> “pure” is a good name
03:59:52 <haasn> I think “wrap” has more potential to be misleading, and “lift” is already taken
03:59:57 <haasn> (And over-used either way)
04:01:03 <gfixler> 3 hard things in computer science: 1. naming 3. race conditions! things 2. cache invalidation
04:01:34 <haasn> 2 hard things in computer science: 1. naming, 2.
04:01:39 <nexx> just invalidate it all
04:02:00 <haasn> (I wonder if that one is understandable)
04:02:08 <gfixler> haasn: working on it
04:02:16 <nexx> haasn yes :)
04:02:21 <MichaelBurge> gfixler: The cache invalidation one reminds me of this: http://thecodelesscode.com/case/158
04:02:45 <gfixler> MichaelBurge: :)
04:04:00 <gfixler> pjdelport: thanks again for a great lesson
04:04:03 * hackagebot semver 0.3.0 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.3.0 (BrendanHay)
04:20:26 <Vai> is there any hop to bypassin an ipad lost and erased one?
04:22:35 <dv-> what does that have to do with haskell
04:54:23 <wz1000> I was going through "Write yourself a scheme in 48 hours" and have a question. Why do they use different representations for a List and a DottedList? Why not have 'Nil' added to LispVal, and define lists as Cons LispVal LispVal?
04:56:16 <wz1000> Here is the link if any one wants: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Return_Values
05:00:20 <pjdelport> wz1000: Probably not any fundamental reason. The advantage of that approach would be making it easy to keep working with the inner lists as conventional Haskell lists, without translating from such a Cons.
05:01:07 <pjdelport> wz1000: It also makes it easy to have a different implementation for each constructor for functions like showVal, introduced in the next page.
05:01:24 <zalatovo> wz1000: Does something like (Cons Nil (Number 2)) even make sense?
05:01:46 <wz1000> Ah
05:02:01 <pjdelport> It does when you start using cons cells to define trees and such :)
05:02:06 <zalatovo> wz1000: wait I think that would be ('() . 2)
05:02:18 <zalatovo> wz1000: so it does seem to make sense, never mind :-)
05:02:46 <pjdelport> wz1000: It's a good question to ask, though! It's probably worth exploring both representations, and the tradeoffs each involves.
05:04:01 <gfixler> wz1000: I *did* want that link - thanks!
05:06:31 <wz1000> So, the main reason is to be able to treat scheme lists like haskell lists? Isn't my way how lists are actually treated in most lisps?
05:24:15 * hackagebot vcswrapper 0.1.0 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.1.0 (HamishMackenzie)
05:24:17 * hackagebot vcsgui 0.1.0.0 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.1.0.0 (HamishMackenzie)
05:24:19 * hackagebot ltk 0.14.0.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.14.0.0 (HamishMackenzie)
05:24:21 * hackagebot leksah-server 0.14.0.0 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.14.0.0 (HamishMackenzie)
05:29:16 * hackagebot leksah 0.14.0.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.0.0 (HamishMackenzie)
05:44:18 * hackagebot qc-oi-testgenerator 1.2.0.1 - Compile time generation of operation invariance tests for QuickCheck  http://hackage.haskell.org/package/qc-oi-testgenerator-1.2.0.1 (goedderz)
05:49:10 <HairyDude> http://lpaste.net/110246
05:49:24 <HairyDude> related: https://github.com/gtk2hs/gtk2hs/issues/36
05:50:20 <HairyDude> trying to install grapefruit but glib fails to install with this message
05:51:35 <wz1000> HairyDude: Look for an older version on hackage that does export the function you need, and then compile it with that.
05:52:25 <HairyDude> wz1000: think it's more likely my cabal is old, just updating it now
05:54:10 <HairyDude> hm, nope
05:54:30 <hamishmack> HairyDude: cabal install Cabal
05:54:36 <hamishmack> HairyDude: then try again
05:55:48 <HairyDude> forgot that the cabal command is actually in cabal-install, not cabal
05:57:02 <HairyDude> that's better
05:59:48 <HairyDude> setup: The pkg-config package 'glib-2.0' is required but it could not be found.
05:59:53 <HairyDude> pkg-config --version glib-2.0 says 0.26
06:05:25 <hamishmack> HairyDude: that is the version of pkg-config
06:05:41 <HairyDude> just realised that o\
06:05:49 <hamishmack> HairyDude: What does pkg-config --modversion glib-2.0
06:05:50 <hamishmack> give
06:06:07 <HairyDude> not found... think I didn't install the glib dev package
06:07:05 <t7> @hoogle (a -> (a, Maybe b)) -> [a] -> [b]
06:07:08 <lambdabot> No results found
06:07:35 <HairyDude> ah, that's better
06:07:59 <haasn> That type signature doesn't make sense to me
06:09:02 <carter> @tell infandum the codes online
06:09:02 <lambdabot> Consider it noted.
06:09:49 <carter> @tell dfeuer next time just link em to the github
06:09:50 <lambdabot> Consider it noted.
06:09:56 <carter> @tell dfeuer_ next time just link em to the github
06:09:56 <lambdabot> Consider it noted.
06:14:24 * hackagebot cabal-lenses 0.4 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4 (DanielTrstenjak)
06:14:26 * hackagebot cabal-bounds 0.8.6 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.6 (DanielTrstenjak)
06:44:27 * hackagebot hindent 1.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-1.0 (ChrisDone)
06:47:39 <nateb> I have a large group of ADTs who are chained together, like `A = Aa B | ...; B = Bb C | ...; C = Cc D | ...; ...; Y = Yy Z`.  Right now, in order to make one, I am doing `A $ B $ C $ ... $ Z blah`.  It feels like there must be a simpler way.  Is there some method of doing this like `magicallyMakeAfromZ $ Z blah`?
06:48:25 <vanila> nateb, a typeclass could do the magic
06:54:29 * hackagebot rakhana 0.1.0.0 - Stream based PDF library  http://hackage.haskell.org/package/rakhana-0.1.0.0 (YorickLaupa)
06:57:19 <nateb> vanila: okay, what kind of typeclass?  That's the piece I can't quite put together.
06:57:46 <nateb> My problem is sometimes I need to make an A from a Q, and sometimes I need to make an S from a Z, etc.
06:57:50 <vanila> i'll paste an example, give me a sec
06:57:54 <nateb> Thanks!
06:58:34 <nateb> vanila: I'm actually going to be leaving, I didn't expect so quick a response, but thank you for lending a hand.
07:14:32 * hackagebot cabal-cargs 0.7.2 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.2 (DanielTrstenjak)
07:16:51 <doismellburning> is there any way to make a non-blocking get from a BoundedChan?
07:18:36 <Mattais> can you guys tell me of good books or parts of the web to start learning Haskell?
07:18:45 <hpc_> @where lyah
07:18:45 <lambdabot> http://www.learnyouahaskell.com/
07:18:53 <doismellburning> Mattais: LYAH ; RWH
07:20:48 <Mattais> doismellburning: what is LYAH?
07:20:50 <angerman> can anyone recommend a great tutorial/book on functional graph processing? Or in general functional algorithms on graphs? if it would be haskell, that would be even better :D
07:21:24 <doismellburning> Mattais: lambdabot provided a linl
07:21:26 <doismellburning> *link
07:22:35 <Mattais> ok
07:24:33 * hackagebot hsimport 0.5.2 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.5.2 (DanielTrstenjak)
07:27:03 <carter> angerman: whats the actual goal
07:27:10 <carter> like, what problems on graphs are you wanting ot solve
07:27:14 <carter> or just for funsies/
07:27:33 <carter> do you want a graph algorithms book or a functional data structures book?
07:27:45 <angerman> carter: primarily funsies :D. Specifically visiting nodes, ensuring no duplicate visits,...
07:27:57 <carter> angerman: functional doesn't change it much
07:28:09 <carter> just means that the naive translations of some algs have an extra log n factor
07:28:27 <carter> (at most)
07:28:32 <carter> @google graph algorithms book
07:28:33 <lambdabot> http://en.wikipedia.org/wiki/Book:Graph_Algorithms
07:28:33 <lambdabot> Title: Book:Graph Algorithms - Wikipedia, the free encyclopedia
07:28:55 <angerman> carter: so what's the 'non-naive' appraoch then, that one would use with fp?
07:29:02 <carter> angerman: ST monad :)
07:29:07 <carter> idk
07:29:16 <carter> angerman: graph theory/ graph algs is A HUGE area
07:29:45 <carter> angerman: it sounds like you should jsut read a good graph theory / graph algs test
07:29:53 <carter> and try to write dumb /naive versions of the algs
07:29:56 <carter> and see what happens
07:30:16 <angerman> cater, yep, I'll probably go that way and look up ST monad + visitor pattern or something like that.
07:30:37 <carter> i dont know what you mean by visitor pattern
07:30:41 <carter> :t traverse
07:30:42 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:39:35 * hackagebot confsolve 0.5.3 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.5.3 (DanielTrstenjak)
07:44:55 <phaazon> how often does the cronie haddock run on hackagedb?
07:45:01 <phaazon> once a dayy?
07:45:02 <phaazon> -y
07:45:03 <Phillemann> Is there a way to have sort of a background compilaton and error display for a single source in emacs which uses cabal and its sandbox? I've installed emacs prelude and loaded a haskell file. I got the error reporting, but it doesn't find the modules I've installed in the sandbox, only the ones which come with ghc (or which are global, for that matter).
07:56:05 <dario> Phillemann: shouldn't flymake be able to do that?
07:56:17 <dario> (not sure though, i'm mostly a vim user)
07:56:49 <carter> angerman: for folding through structures, the traverse op is magic
07:57:07 <carter> or applicable specialized version for not quite fully polymorphic structures
07:58:11 <angerman> carter, thanks. will look into traverse :D
07:58:48 <Phillemann> dario: Ah, you lead me into the right direction, I think. There is flycheck-haskell.
07:58:58 <dario> ah, nice :)
08:05:05 <hellertime> if I'm defining some map function, which is taking a type, removing the type constructor to call map on the underlying value, and then reapplying the type constructor… is that the same as fmap?
08:05:27 <doismellburning> lenses :(
08:05:27 <vanila> that might very well be fmap
08:05:38 <vanila> you should still check the functor laws
08:06:19 <hellertime> thats the thing. say… data V = V (Vector Double), right.  V (Vector Double) has kind * , not * -> *
08:06:33 <hellertime> so its not a functor I think
08:07:07 <vanila> if its not a functor then this can't be fmap, but you can make a similar sort of function called something else
08:07:14 <hellertime> oh wait. perhaps I am needlessly specializing here aren't i?
08:07:24 <vanila> possible!
08:07:44 <hellertime> heh. ok back to playing around with types…
08:19:41 * hackagebot codex 0.1.0.4 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.4 (aloiscochard)
08:20:08 <aloiscochard> ^ this version work on MacOS if anyone interested...
08:23:30 <parc> i've got a bizarre issue i've come across. i've got a module X, whose Main file imports a function from another module Z, which causes the Read Day instance (from the time library) to become undefined in a submodule X.Y. at first i thought it was an orphan instance issue, but i don't understand how `not` importing a function could cause an instance to be defined
08:24:17 <parc> and the module X.Y can import from Z, but the problem only occurs if the Main file does
08:29:43 * hackagebot Gamgine 0.3 - Some kind of game library or set of utilities.  http://hackage.haskell.org/package/Gamgine-0.3 (DanielTrstenjak)
08:29:45 * hackagebot gitson 0.4.0 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.4.0 (myfreeweb)
08:47:37 <McManiaC> in pipes, what happens if you 'await' but there is no more input to process?
08:48:04 <McManiaC> does it wait forever?
08:50:47 <copumpkin> I would hope not, since they shouldn't work that way
08:51:00 <copumpkin> you run the pipe and when the input is over, you either get a result or something awaiting more input
08:51:33 <copumpkin> in your case, you'd just end up with something expecting more input
08:51:48 <copumpkin> which you can feed if you want, or throw away, or whatever
08:59:35 <McManiaC> hm maybe im using them wrong
08:59:36 <McManiaC> :>
09:04:47 * hackagebot microformats2-types 0.1.0 - Microformats 2 types for Haskell.  http://hackage.haskell.org/package/microformats2-types-0.1.0 (myfreeweb)
09:07:07 <McManiaC> copumpkin: http://npaste.de/p/d8/ is this not how you use pipes? i receive a bytestring stream from… whereever, try to parse it and if i get a partial result i await some more (line 22), otherwise loop over the main function (line 15)
09:07:49 <McManiaC> what if line 22 "fails" since there is no more input? in attoparsec I would apply "" but how do i figure this out in pipes?
09:09:48 * hackagebot leksah 0.14.0.1 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.0.1 (HamishMackenzie)
09:22:39 <statusfailed> Does anyone use Machines? Do you know if there's a function equivalent to Data.List.groupBy ?
09:33:55 <vanila> where can I find type rules for staged lambda calculus?
09:39:53 * hackagebot http-test 0.2.2.0 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.2.0 (glutamate)
09:55:36 <RedNifre> Hey there.
09:56:43 <RedNifre> If I have JSON that is like "number":"123.456" and I want to parse it to data { number :: Number } instead of data { number :: String }, what is the easiest way to do that?
10:00:26 <RedNifre> hmmm... I guess I can somehow do that on the left side of a .: in parseJson...
10:01:20 <nshepperd> you can fmap it
10:02:36 <nshepperd> I have some code here that does like parseJSON (Object o) = Foo <$> o .: "bar" <*> fmap (stuff) (o .: "baz")
10:05:47 <sagittarian> can anyone explain to me what's up with the types here: http://lpaste.net/110252
10:06:59 <Tuplanolla> Looks like you were struck by the monomorphism restriction, sagittarian.
10:07:12 <sagittarian> ???
10:07:21 <Tuplanolla> See this: http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:07:29 <RedNifre> nshepperd, can you explain what happens in that line of code?
10:07:30 <sagittarian> thanks Tuplanolla
10:07:45 <monochrom> a combination of monomorphism restriction and ghci special defaults "for your convenience"
10:08:14 <sagittarian> so an explicit type signature (in a source file) would fix that?
10:08:23 <triliyn> yes
10:08:23 <Tuplanolla> That also works in the interpreter.
10:08:46 <Tuplanolla> let {f :: String; f = "This is how."}
10:09:04 <doismellburning> so um, how do I "catch" an arbitrary "error"?
10:10:16 <monochrom> I am curious why you want to catch an arbitrary error, what you need it for. it may help.
10:11:01 <nshepperd> RedNifre: wait, you're using aeson, right? and defining a FromJSON instance for your datatype?
10:11:56 <doismellburning> I have a thread, it's doing Some Stuff with an arduino; right now the arduino isn't plugged in, so my whole program dies with some "error" text: https://gist.github.com/doismellburning/77eb167d7c31f03abb09
10:12:13 <doismellburning> monochrom: sorry, should have written it up pre-hoc
10:13:06 <doismellburning> presumably though there is some (suboptimal) way of "catching *"
10:13:09 <RedNifre> > 2%3
10:13:11 <lambdabot>  2 % 3
10:13:24 <RedNifre> nshepperd yes
10:13:36 <RedNifre> I am just curious how exactly that works under the hood.
10:13:37 <dreams> Is it just me, or is it difficult to read Haskell code? all those recursive functions, the whole program boils down to one expression. I find it way easier to read imperative code. Or do you get used to it after a while?
10:13:54 <doismellburning> dreams: I'd go with neither
10:13:58 <MR4Y> I believe you get used to it
10:13:59 <monochrom> doismellburning: then it's my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
10:14:21 <monochrom> dreams, I used to find COBOL code hard to read.
10:14:25 <RedNifre> I mean, my intuition was that all these o .: "field" statements sort of constructed a look up map for the parser. So when the parser encounters "field" it parses it and plucks it into the data.
10:14:28 <doismellburning> dreams: it's neither "just you" but nor is it objectively difficult, but lots of people may find it nontrivial at first
10:14:38 <doismellburning> monochrom: thanks!
10:15:00 <RedNifre> But if one of those statements between two <*> is fmap bla (o .: "field") then I don't understand how it actually works.
10:15:02 <doismellburning> monochrom: try! thanks
10:15:20 <Tuplanolla> You can't skim as much when reading Haskell, dreams.
10:15:36 <nshepperd> RedNifre: yeah the fromJSON :: Value -> Parser a
10:15:37 <monochrom> in fact, "COBOL is just like English", is precisely why it's so hard to read
10:15:37 <dreams> Tuplanolla: what do you mean?
10:15:49 <dreams> doismellburning: so its just at the start?
10:16:09 <monochrom> "multiply x by y" is more obfuscating then "x*y", yes. to me anyway.
10:16:09 <Tuplanolla> Read slower and focus less on what things are called.
10:16:33 <RedNifre> hmm... or does it work backwards as in, it iterates over the entries in the data, picks the corresponding entry in the parseJSON and applies that to the JSON?
10:16:35 <doismellburning> dreams: I would say most things get easier with practice
10:16:37 <nshepperd> RedNifre: but o .: "field" also constructs a (Parser b) for any FromJSON b
10:17:02 <monochrom> similarly, the imperative "tmp1 = a+b; tmp2 = c*tmp1; answer = tmp2 + 4" is more obfuscating than the functional "c*(a+b) + 4"
10:17:11 <dreams> monochrom: sometimes being just like English make it easier to read although I don't like it much, like in Haskell its easy to tell what this does: take 10 spaces, but when the you have a larger expressions.. brain explosion.
10:17:18 <nshepperd> RedNifre: so what o .: "field" really means is (get "field", parse it and return the value)
10:17:57 <RedNifre> Yeah, that makes sense. Thanks.
10:18:13 <dreams> doismellburning: I don't know I'm spending hours trying to understand a 130 LOC program.
10:18:19 <monochrom> you can analyze subexrepssions one part at a time. you can always do that.
10:18:46 <doismellburning> dreams: and how does that compare to other programs you've tried to understand?
10:19:59 <MR4Y> Also, how one goes about practicing functions and things like that? I was recommended the 'Learn You a Haskell' book by a friend, but I feel like the knowledge of the language escapes my mitts as I continue reading it. I understand the concepts and understand what the code does, however, I can't do the same things on my own. They don't work or only work partially. I can't seem to bridge the gap between theory and practice.
10:20:07 <dreams> doismellburning: other programs in Haskell you mean?
10:20:18 <doismellburning> dreams: yes
10:20:41 <monochrom> I do not mean to say that you have difficulty with the size of "c*(a+b) + 4". however, some people do, seriously. so they just have a lower threshold than you, but you and them are talking about the same problem, just with different sizes.
10:20:45 <dreams> monochrom: yeah, the problem is when you have many of those, takes time. and then you have to make sense what they do together.
10:20:59 <doismellburning> dreams: (I assume you have tried to understand other comparable Haskell programs, to arrive at it not being a difficulty local to that program)
10:21:01 <dreams> doismellburning: to be honest, not much different.
10:21:14 <monochrom> and those people, they seriously say "tmp1 = a+b; tmp2 = c*tmp1; answer = tmp2 + 4" is clearer. seriously.
10:21:20 <dreams> doismellburning: no, this is the largest I've tried to read.
10:21:46 <dreams> monochrom: perhaps its because we're used to it. which makes sense.
10:21:54 <monochrom> so I think what I want to conclude is: I agree to disagree. your opinion and mine are opposites.
10:22:48 <monochrom> anyway, those people have gone to OOP.
10:23:14 <dreams> monochrom: ugh, I hate OOP.
10:23:46 <nshepperd> objection oriented programming
10:25:12 <dreams> Well I didn't conclude anything
10:25:45 <dreams> nshepperd: I find it easy to write spaghetti-code in OOP. Again maybe its just me.
10:26:38 <nshepperd> no, I think it's a frequent effect
10:26:47 <nshepperd> inheritance spaghetti is the worst
10:27:05 <dreams> monochrom: I am working solely with Haskell this year, the beginning is hard. I was checking if I'm a retard or thats what beginners normally face.
10:27:24 <michaelt> McManiaC: if you are still around: the Pipe will stop when the Producer (or Consumer) stops, you don't inspect the incoming material for End of File, unless you arrange that in the incoming material
10:27:49 <Kinnison> dreams: If you're mostly used to non-functional languages, then it's often very hard at the start, while your brain wraps around how FP works
10:28:12 <monochrom> this is why in my http://www.vex.net/~trebla/haskell/prerequisite.xhtml starts by saying that the prerequisite is school math skills.
10:28:15 <edlinde> is there a good tutorial I can follow to write and practise haskell?
10:28:27 <dreams> Kinnison: Haskell is my first functional language.
10:28:28 <edlinde> I am going to read LYAH soon
10:28:41 <dreams> monochrom: let me check that.
10:28:43 <edlinde> just wondering if there is something I can use on the side to keep practising code
10:28:47 <yukko> I liked LYAH but I read it like five years ago
10:29:00 <monochrom> after the nightmare of polynomials and limits and nasty integrals, no Haskell expression is too big. none of them.
10:29:10 <McManiaC> michaelt: i think i solved this by making a "Pipe (Maybe ByteString) ..." and do a "forever $ yield Nothing" in the producer at the eof
10:29:23 <McManiaC> not quite sure if i really like this but hmhm
10:29:31 <RedNifre> :t .:
10:29:32 <lambdabot> parse error on input ‘.:’
10:29:35 <edlinde> yukko: yeah me too
10:29:38 <monochrom> unfortunately, programmers choose to be programmers (not mathematicians) precisely because they flunked math.
10:29:42 <c_wraith> Eh.  When I learned haskell, I had no real issues with functional programming.  It's mostly the same as good practices in any language.  On the other hand, laziness and higher-kinded types *really* took effort to wrap my brain around.
10:29:44 <RedNifre> :t (.:)
10:29:45 <lambdabot>     Not in scope: ‘.:’
10:29:46 <lambdabot>     Perhaps you meant one of these:
10:29:46 <lambdabot>       ‘.’ (imported from Data.Function),
10:29:46 <edlinde> my haskell is real rusty
10:29:51 <edlinde> so I got to remind myself
10:29:52 <michaelt> McManiaC: yes, that's how you make an explicit end, if you want one.
10:29:54 <Tuplanolla> :t (.) . (.)
10:29:55 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:30:34 <edlinde> so how do I get back on the haskell horse? :)
10:30:46 <Tuplanolla> Just use it, edlinde.
10:30:49 <RedNifre> ghci gives a really complicated type for .: do I really have to type all that if I create a function stringToNum v s = fmap read (v .: s)
10:31:17 <michaelt> McManiaC: are you sure you need to know this?  There is the alternative of writing a fold over the producer, or a so-called parser etc.
10:31:23 <c_wraith> RedNifre: which (.:)?  aeson?
10:31:24 <dreams> Kinnison: but to be honest, its the laziness that makes things harder.
10:31:27 <RedNifre> yes
10:31:46 <RedNifre> I want to parse some json that has a lot of fields that have strings that contain numbers
10:32:04 <doismellburning> "strings that contain numbers"?
10:32:05 <c_wraith> RedNifre: is it acceptable to fire whoever wrote the code producing that json?
10:32:16 <RedNifre> unfortunately not
10:32:17 <doismellburning> as in "6"?
10:32:17 <c_wraith> RedNifre: because clearly they had no idea what they were doing
10:32:21 <RedNifre> yes
10:32:52 <RedNifre> what I want to do is write parseJson like <*> stringToNum v "numberfield" <*> stringToNum v "anotherField" etc.
10:32:53 <nshepperd> RedNifre: I think it's just because ghci likes to fully qualify the names. if you have the right modules imported, it's just "Object -> Text -> Parser a"
10:33:02 <edlinde> just use it ain’t good enough :)
10:33:26 <McManiaC> michaelt: well, this parser expects a "\n" at the end of every line, and if it's missing it gets a partial result… if i dont get any more input it will silently discard the message otherwise
10:33:45 <McManiaC> michaelt: i guess i could just add a linebreak to the last char, no matter what, but ugh
10:35:21 <michaelt> McManiaC: the producer you are going to attach this too is the raw input from some socket or whatever
10:35:25 <michaelt> ?
10:35:34 <McManiaC> michaelt: yup
10:36:03 <Kinnison> dreams: Laziness can confuse me sometimes :-)
10:36:04 <c_wraith> RedNifre: I think the type for stringToNum is just going to be (Read a) => Object -> Text -> Parser a, given nshepperd's input.  That's really not bad.
10:36:08 <RedNifre> So "do" is for >>=, right? How do I configure it to work for other things?
10:36:15 <MR4Y> How I bridge the gap between theory and practice? I've been reading the LYAH book for about a month now, but  I can't get past functions. The functions I try to make as practice never work as intended.
10:37:02 <RedNifre> e.g. when writing parseJson, every line seems to have to end with <*>, is there something like do as <*> that I can put at the beginning?
10:38:09 <michaelt> McManiaC: It may be that you should be repeatedly parsing the Producer itself, writing first a Producer ByteString (IrcT m) () -> Producer (UTCTime, IRCMsg) (IrcT m) (Producer ByteString (IrcTm) ())
10:39:09 <Tuplanolla> More concrete examples would be easier to answer, MR4Y.
10:39:11 <l0cust> RedNifre: what?
10:39:35 <l0cust> RedNifre: (<*>) is just convoluted fmap-sugar
10:39:49 <l0cust> @@ RedNifre :t (<*>)
10:39:50 <lambdabot>  RedNifre :t (<*>)
10:40:03 <l0cust> :t (<*>)
10:40:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:40:06 <l0cust> there we go
10:40:06 <nshepperd> <*> is really Applicative sugar
10:40:06 <Guuf> MR4Y: I think a good way would be to try to discuss an example and your solution with someone more experienced.
10:40:12 <c_wraith> l0cust: err.  no, <*> is not derivable from fmap
10:40:20 <l0cust> c_wraith: you're right, sorry
10:40:23 <MR4Y> Being more specific, I understand what the code does and all the theory of it, but I can't do them on my own.
10:40:26 <c_wraith> l0cust: fmap is derivable from <*> and pure
10:40:33 <l0cust> :t pure
10:40:34 <lambdabot> Applicative f => a -> f a
10:40:34 <RedNifre> I mean you can replace a >>= b >>= c with do a b c, right? I would like to replace a <*> b <*> c with do<*> a b c or something like that.
10:40:42 <michaelt> McManiaC: see for example `parsed` here:  https://hackage.haskell.org/package/pipes-attoparsec-0.5.1/docs/Pipes-Attoparsec.html it will parse while it can, then when it breaks you figure out what to do
10:40:43 <l0cust> RedNifre: no, you can't
10:40:44 <McManiaC> michaelt: then calling 'next' on the BS producer?
10:40:56 <nshepperd> "f <$> action1 <*> action2 <*> action3" lifts f to acting on the results of each action
10:40:59 <l0cust> RedNifre: you can replace a >> b >> c with do; a; b; c;
10:41:04 <michaelt> McManiaC: thats the straightforward way, right
10:41:05 <Tuplanolla> That's still not specific enough, MR4Y. Give us one problem at a time.
10:41:05 <l0cust> RedNifre: but not (>>=)
10:41:22 <RedNifre> maybe I meant that one, I'm still not totally clear on IO and do etc.
10:41:28 <McManiaC> michaelt: hm, maybe i can just use that attoparsec library
10:41:28 <McManiaC> :D
10:41:37 <l0cust> RedNifre: what you can do is something like
10:41:49 <l0cust> RedNifre: well, let me write it emacs, I'll pastebin it
10:42:27 <RedNifre> so "do" isn't a function, it's built right into the language and only works for >>?
10:42:42 <burp> syntactic sugar
10:42:54 <nshepperd> RedNifre: as it happens Parser does have a Monad instance, which means you can actually write "do field1 <- o .: "field1"; field2 <- o .: "field2"; return (Constructor field1 field2)"
10:43:02 <MR4Y> I'm not able to create my own functions with the function knowledge I have. Essentially, what I want to do works in my head with what I read from functions, but not in practice.
10:43:36 <monochrom> RedNifre: yes it's syntax. it gets translated to >>= and >>. but I lump >> with >>=. see my http://www.vex.net/~trebla/haskell/IO.xhtml#do
10:43:54 <nshepperd> RedNifre: although I wouldn't recomment it honestly, since (Constructor <$> o .: "field1" <*> o .: "field2") has so much less noise
10:43:55 <Guuf> MR4Y: Paste one of your functions on the paste site in the topic and talk us through it, and we can point out where you don’t quite hit the mark.
10:44:13 <RedNifre> Mh, that's not sugary enough. I wish do was configurable so that do; a; b; is syntactic sugar for do>>;a;b; because then I could write a<*>b<*>c as do<*>;a;b;c;
10:44:19 <michaelt> McManiaC: the "parse" function makes a "parser" in the Pipes sense out of an attoparsec parser, this means, a StateT (Producer ByteString m x) m parsed-value, so runStateT (parse attoparser) p is a bit like doing `next`, but has either succeed or failed with the parser
10:44:30 <hcaulfield57> Is printf doing some magic behind the scenes, I can't figure out why this function won't actually work. http://lpaste.net/110253
10:44:35 <hcaulfield57> It's very short by the way, one line
10:44:47 <michaelt> McManiaC: by contrast, "parsed" keeps parsing and emitting as long as it can
10:45:24 <MR4Y> Also, how I answer back to people? It's been 2-3 years since I last used IRC.
10:45:32 <monochrom> there is no upper bound for sweetness, I agree.
10:45:47 <Guuf> MR4Y: Just type their name, a colon, a space, then your answer.
10:45:48 <Tuplanolla> Just use their name, MR4Y.
10:45:51 <burp> given an expression tree like data Expr = Plus [Expr] | Times [Expr] | Log Expr | Symbol String | Rational Int Int, I want to write an evaluation function evalExpr :: [(Symbol,Double)] -> Double. How do you recommend to do this? My naive approach would be to store the (Symbol,Double) pairs in a Map, and perform the evaluation in a Reader monad where I lookup the symbols in the map and insert their values; this seems to be inefficient though.
10:45:54 <edlinde> is there an online course for haskell?
10:45:57 <edlinde> like coursera?
10:46:07 <RedNifre> So, how long do you have to program in Haskell before a program compiles on the first try? ;)
10:46:26 <hcaulfield57> RedNifre: A long time, people make mistakes
10:46:41 <monochrom> very short time for me
10:47:01 <l0cust> RedNifre: http://lpaste.net/110254
10:47:07 <hcaulfield57> Usually it's just simple mistakes for me that are easily fixable, due to me not paying enough attenion to the tpes
10:47:09 <monochrom> but I took baby steps. I did not "dive in and do a huge project early"
10:47:25 <hcaulfield57> s/tpes/types
10:47:30 <MR4Y> Guuf, what I'm trying to do at the moment is make a recursive version of the fibonacci numbers.
10:47:59 <Guuf> MR4Y: Okay.
10:48:13 <sagittarian> i'm trying to make an infinite list of successive factorials (the specialty of haskell, naturally)
10:48:18 <sagittarian> what am i misunderstanding here:
10:48:26 <sagittarian> > let facs = scanl (*) 1 [1..] in take 10 facs
10:48:28 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880]
10:48:29 <nshepperd> my favourite program, "main = return ()" usually compiles on the first try for me :)
10:48:34 <edlinde> monochrom: did u do some sort of online course?
10:48:40 <monochrom> no.
10:48:46 <nshepperd> I work my way up from there
10:48:49 <barrucadu> nshepperd: And it's totally free of side effects! It's the ultimate program!
10:49:08 <monochrom> sagittarian: the answer looks perfectly correct.
10:49:18 <RedNifre> l0cust yeah, I'll stick to <*>
10:49:42 <l0cust> barrucadu: "The ideal program is a black box in which you press \"go\", and the box heats up, but there's no input or output, and you have no idea what's going on." - Simon Peyton Jones
10:49:43 <sagittarian> shouldn't the second number be 2?
10:49:47 <monochrom> perhaps you are merely forgetting that 0! = 1 therefore there is no error
10:49:52 <hcaulfield57> Looks like there is some magic going on with printf
10:50:14 <barrucadu> l0cust: Woah, woah, "heats up"? Sounds like an observable output to me!
10:50:32 <l0cust> hahaha
10:50:37 <Guuf> Hah :D
10:50:38 <c_wraith> hcaulfield57: the magic more or less corresponds to allowing extra runtime errors. :)
10:50:45 <Tuplanolla> No, sagittarian.
10:50:48 <l0cust> I wish lambdabot had quote-grabs
10:50:48 <monochrom> ok, look, scanl (*) a [x,y,z] = [a, a*x, a*x*y, a*x*y*z]. the 0th item doesn't even use (*)
10:51:11 <sagittarian> so what am i misunderstanding?
10:51:17 <monochrom> but it's exactly right to have the 0th item being 0!. please don't "fix" it. it ain't broken.
10:51:25 <hcaulfield57> c_wraith: I think I'm just going to avoid it and use functions that have a set amount of arguments
10:51:39 <MR4Y> Guff: I've been messing with it so much that I don't have the orginal source anymore.
10:51:39 <hcaulfield57> Varabiable length functions are not very Haskell-like anyways
10:51:53 <sagittarian> http://lpaste.net/110255
10:51:58 <Tuplanolla> Show us what you do have, MR4Y.
10:52:12 * l0cust cringes at the python
10:52:18 <sagittarian> oh the 1 is the first item
10:52:19 <sagittarian> okay
10:52:24 <Tuplanolla> How about (-1)! then, sagittarian?
10:52:46 <c_wraith> hcaulfield57: the way it works is using a typeclass for its return value, and returning something that could be another function - or not.  It makes heavy use of return-type inference.
10:53:04 <sagittarian> > let facs = scanl1 (*) 1 [1..] in take 10 facs
10:53:05 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[a0]’
10:53:05 <lambdabot>  Relevant bindings include facs :: t (bound at <interactive>:1:5)
10:53:06 * l0cust should probably do his school-work instead of fucking around on irc
10:53:15 <sagittarian> > let facs = scanl1 (*) [1..] in take 10 facs
10:53:17 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
10:53:27 <c_wraith> hcaulfield57: But if you ask it to return a function when it thinks it has all the information the pattern needs - it gets unhappy.  at runtime, not compile-time.
10:53:35 <sagittarian> Tuplanolla, God made the positive whole numbers, all the rest are the work of man
10:53:38 <Guuf> MR4Y: As, Tulpanolla said, show us the source you do have. Or retry from scratch.
10:53:50 <burp> maybe I should not make an evalExpr but rather write a code generator and compile it afterwards, for efficiency, or I just do evalExpr and see how well it performs :)
10:53:53 <MR4Y> Tupanolla: Guff: http://pastebin.com/wu7BV5fD
10:54:00 <MR4Y> This is what I ended up with so far.
10:54:02 <hcaulfield57> c_wraith: Ah, I see. I've always found it a pain to use in composing other functions, but perhaps it's just because I'm a mediocre Haskell programmer.
10:54:20 <c_wraith> hcaulfield57: no, that's because it *is* a pain when composing with other functions. :)
10:54:22 <nshepperd> Tuplanolla: don't be silly, that's a pole
10:54:28 <Tuplanolla> Shh...
10:55:50 <Tuplanolla> Start from the type signature and tell us what a is, MR4Y.
10:56:42 <Guuf> MR4Y: Okay, good!
10:56:43 <michaelt> McManiaC: I'm not totally following, but you might then add the timing info with a Pipe  IrcMsg (UTCTime, IRCMsg) (IrcT m) r  adding, say the time when the await succeeds
10:56:51 <c_wraith> I still think that if GHC had type-level strings (as lists of characters), it should be possible to do type-safe printf by putting the format string into the type..
10:57:07 <Guuf> MR4Y: Let’s start with the return type of your function. What do you want it to be?
10:57:49 <Tuplanolla> I'll let Guuf carry you.
10:58:50 <Guuf> Oh, sorry Tuplanolla, I didn’t see you had started.
10:59:08 <dfeuer_> c_wraith, I still think printf is an odd thing to strive for.
10:59:18 <dfeuer_> Yes, it's convenient, but is it really worth the trouble?
10:59:59 <nshepperd> I think I saw some slides at some point from a talk involving making a type-safe printf but with an ADT sort of format "string"
11:00:16 <dfeuer_> The types tend to get complicated very quickly, leading to inscrutable error messages and long inference times.
11:00:18 <hcaulfield57> I decided not to use printf. It's too much trouble
11:00:25 <c_wraith> nshepperd: oh, yeah.  There are a bunch of those.  they work well, but they're really verbose
11:00:33 <MR4Y> Guff: Well, I want it to be of type Int, accept and return an Int. The function should catch wether 'n' is 0 or 1. If it's 0 or 1, it should return those as result. Otherwise, It should return the nth number, which is the result of the sum of both number preceding it. Essentially.
11:00:49 <nshepperd> printf (Lit "3 = " :^: IntField) 3
11:01:27 <c_wraith> http://hackage.haskell.org/package/formatting is an example
11:01:38 <nshepperd> and the :^: builds up some kind of godawful data structure with a phantom type set to (Int -> String)
11:01:45 <Guuf> MR4Y: Yes, your reasoning is correct.
11:02:00 <Guuf> MR4Y: Do you want me to just point out what is wrong?
11:02:50 <MR4Y> Guff: Sure. I'm clueless at this point about why it doesn't work.
11:03:20 <Guuf> MR4Y: Okay, I’ll do that.
11:03:41 <monochrom> sagittarian: I want you to consider the choices of "fac !! n = n's factorial" vs "fac !! n = (n+1)'s factorial"
11:04:21 <RedNifre> Hm, could it be that there is a problem with strictness when parsing JSON with an fmap in a separate function? What is this: Just (Ticker {high = *** Exception: Prelude.read: no parse
11:04:44 <sagittarian> monochrom, how do you want me to consider it?
11:04:46 <c_wraith> RedNifre: The read is deferred until the value is actually demanded, yes
11:04:48 <Guuf> MR4Y: The type signature should be fibonacci :: Int -> Int.
11:04:53 <RedNifre> I mean, this looks like the parsing worked and I got a Ticker data, but when looking at the Rational fields it is broken?
11:05:03 <monochrom> do you really prefer "fac !! n = (n+1)'s factorial"?
11:05:11 <nshepperd> RedNifre: oh right, I remember this sillyness
11:05:31 <nshepperd> RedNifre: for some reason the default Read instance for Rational can't understand decimal notation
11:05:33 <c_wraith> RedNifre: that means that whatever string it got there wasn't actually parsable as a rational with Read
11:05:49 <nshepperd> RedNifre: ie. "3.6" makes it choke
11:05:52 <MR4Y> Guff: And just that?
11:05:55 <RedNifre> ...what?
11:06:08 <RedNifre> you mean you can only read rationals that result in n%1?
11:06:16 <Guuf> MR4Y: Your first case, were you check if n < 0 is correctly written, but the rest of the cases aren’t. You don’t write a vertical bar “|” before new cases.
11:06:36 <c_wraith> RedNifre: you should never mistake read for a real parser
11:06:43 <c_wraith> RedNifre: if you want a real parser, use a real parser
11:06:45 <monochrom> > 3.6 :: Rational
11:06:47 <lambdabot>  18 % 5
11:06:47 <Guuf> MR4Y: You just write the function again, at the same intendation level as your first function.
11:06:51 <monochrom> oh, Read
11:07:00 <sagittarian> monochrom, what do you mean by (n+1)'s factorial?
11:07:01 <nshepperd> RedNifre: Numeric.readFloat will do it for you
11:07:03 <monochrom> > read "3.6" :: Rational
11:07:04 <lambdabot>  *Exception: Prelude.read: no parse
11:07:09 <sagittarian> i prefer that fac n == n!
11:07:24 <ski> sagittarian : should `fac !! 0' be the factorial of `0', or the factorial of `1' ?
11:07:27 <RedNifre> But I don't want float, I want something that can do decimal fractions.
11:07:27 <hcaulfield57> It's bizarre that in records you don't have to initialize some of the fields.
11:07:34 <sagittarian> ah i see
11:07:38 <hcaulfield57> What is the value even?
11:07:45 <Guuf> MR4Y: Lastly, your last case does not make sense, you can’t return the empty list when your return numbers in the other cases. But I think you realize that. :)
11:07:47 <ski> (and similarly with `fac !! 1')
11:07:47 <monochrom> [1, 2, 6, 24] !! 1 = 2.
11:07:55 <monochrom> > [1, 2, 6, 24] !! 1
11:07:56 <lambdabot>  2
11:08:10 <nshepperd> RedNifre: readFloat is also a misnomer, it works for any RealFrac, including Rational
11:08:24 <RedNifre> ...
11:08:51 <monochrom> God created us because He wants us to create Haskell. and Haskell starts from 0.
11:08:59 <ski> > (readFloat :: ReadS Rational) "3.6"
11:09:01 <lambdabot>  [(18 % 5,"")]
11:09:03 <MR4Y> Guff: I know, but I started flailing my arms uncontrolably at that point and trying everything else insted. List comprehensions and everything I know at this point.
11:09:21 <Guuf> MR4Y: I know the feeling. :)
11:09:30 <ski> nshepperd : i would have thought it had that name since it read a number expressed in floating-point notation
11:09:51 <ski> (as opposed to `18 % 5', say)
11:10:10 <nshepperd> ski: oh, I guess that sorta makes sense
11:10:17 <MR4Y> Guff: That would be the same feeling with the prior...8 languages I tried?
11:10:24 <hcaulfield57> I don't think I really needed printf, I just wanted it because of habit.
11:10:24 <dfeuer_> Avoiding indexing operations is a good way to avoid fencepost errors. That is why man created foldr, foldl, unfoldr, map, and all that crazy traversal stuff.
11:10:33 <Tuplanolla> Was one of those Scheme, MR4Y?
11:10:48 <Guuf> MR4Y: It’s a feeling one often has when learning something new, in my experience.
11:11:01 <sagittarian> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); fib n = fibs !! n in fib 6
11:11:03 <lambdabot>  8
11:11:07 <dfeuer_> > readFloat "18 % 5" :: Rational
11:11:09 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’
11:11:09 <lambdabot>                with ‘GHC.Real.Ratio GHC.Integer.Type.Integer’
11:11:09 <lambdabot>  Expected type: GHC.Real.Rational
11:11:09 <lambdabot>    Actual type: [(a0, GHC.Base.String)]
11:11:12 <MR4Y> Tupanolla: Technically yes. It was Racket.
11:11:12 <nshepperd> anyway it's confusing that Read Rational doesn't do the same thing the repl and compiler does
11:11:29 <hcaulfield57> To be honest I think Haskell has the highest learning curve of any language I've learned, anything else is easy in comparison. Mostly just learning syntax and library functions/methods
11:11:30 <dfeuer_> @type readFloat
11:11:32 <lambdabot> RealFrac a => ReadS a
11:11:32 <Guuf> MR4Y: So, did you get it working?
11:12:10 <hcaulfield57> And it's somewhat difficult to say I'm done learning Haskell, there's always somewhere you can go.
11:12:10 <FreeFull> hcaulfield57: What about Prolog?
11:12:10 <MR4Y> Guff: I'm rewriting the code now.
11:12:12 <Tuplanolla> Coq might be worse, hcaulfield57.
11:12:16 <nshepperd> > (fst . head . readFloat) "18%5" :: Rational
11:12:17 <lambdabot>  18 % 1
11:12:18 <Guuf> MR4Y: Ok. :)
11:12:41 <hcaulfield57> Never learned Prolog or Coq, haha. If it's something I'm learning in my free time, it better be pretty interesting.
11:12:45 <monochrom> well, I'm never done learning python either. there is always one more secret.
11:12:48 <nshepperd> > (readFloat :: ReadS Rational) "18%5"
11:12:49 <lambdabot>  [(18 % 1,"%5")]
11:12:52 <dfeuer_> Why would it be RealFrac instead of Fractional?
11:13:02 <Tuplanolla> Both fall in that category, so get learning!
11:13:08 <tabemann_> dependently typed languages are not easier than Haskell
11:13:14 <MR4Y> Tupanolla: The 'full stack' would be: C#, C, Python ( 2 and 3), Ruby, Clojure, Racket, Rust and ClojureScript,
11:13:19 <monochrom> and I'm never done learning javascript. there is always one more corner case in the semantics of == and ===
11:13:20 <dfeuer_> > readFloat "18.5" :: Rational
11:13:21 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’
11:13:21 <lambdabot>                with ‘GHC.Real.Ratio GHC.Integer.Type.Integer’
11:13:21 <lambdabot>  Expected type: GHC.Real.Rational
11:13:21 <lambdabot>    Actual type: [(a0, GHC.Base.String)]
11:13:22 <hcaulfield57> Actually, Python was/is a bit troublesome for me since I'm using static languages.
11:13:23 <nshepperd> well, there's a lesson in why you shouldn't blindly apply fst.head to return values
11:13:42 <dfeuer_> > readFloat "18.5" :: (Rational, String)
11:13:43 <lambdabot>  Couldn't match expected type ‘(GHC.Real.Rational, GHC.Base.String)’
11:13:43 <lambdabot>              with actual type ‘[(a0, GHC.Base.String)]’
11:13:46 <McManiaC> michaelt: solved it using the 'parsed' function :) http://puu.sh/beiKs/bafcf4a35d.png
11:13:47 <hcaulfield57> used to using
11:13:47 <dfeuer_> Gahhhh.
11:14:00 <McManiaC> michaelt: i had to adjust my parser, which took me a while, but otherwise it works fine
11:14:01 <ski> hcaulfield57 : Prolog (and logic programming in general) is interesting
11:14:04 <McManiaC> michaelt: thx!
11:14:12 <tabemann_> dynamic typing considered harmful
11:14:24 <michaelt> McManiaC: Oh, I see, good. Welcome.
11:14:37 <monochrom> in contrast, the sense of "never done learning haskell" is only in learning more skills, not getting lied to one more time
11:14:45 <hcaulfield57> ski: Maybe I'll look up Prolog. Unfortunately it's hard to justity learning something I don't use at work vs getting better at work languages haha.
11:15:04 <MR4Y> Tupanolla: Forgot Java and JavaScript as well.
11:15:38 <hcaulfield57> Dynamic typing has it's purposes, but it's harder to rational about things in my opinino.
11:15:53 <hcaulfield57> rationalize about things. Sigh, new keyboard, I can barely type.
11:16:29 <monochrom> if you believe in what companies make you write on your CV about "career goal: personal growth", then Haskell's sense of "never done learning" should sound like gospel.
11:16:39 <MR4Y> Guff: And different error.
11:16:56 <hcaulfield57> Most people I've talked to have never even heard of Haskell
11:17:14 <Guuf> MR4Y: Alright, paste your new code and we’ll look at it.
11:17:15 <hcaulfield57> When I learned it, I thought it was more mainstream
11:17:40 <hcaulfield57> Prolog looks bizarre
11:17:51 <Tuplanolla> It's a gateway drug to more esoteric languages.
11:17:53 <monochrom> (I don't believe in it, by the way. why can't it be "career goal: get money to raise kids" which is both more honest and more noble?)
11:18:01 <Guuf> I learned Haskell just because a colleague knew OCaml and I wanted to be more hardcore. ;)
11:18:04 <tabemann_> it is the most mainstream pure language
11:18:17 <RedNifre> :t readFloat
11:18:18 <ski> hcaulfield57 : Mercury is a more modern logic programming language. but if you decide to attempt to learn some LP, i still suggest starting with Prolog, if not for any other reason, then because most of the literature is expressed in terms of Prolog (or variants thereof)
11:18:18 <lambdabot> RealFrac a => ReadS a
11:18:20 <MR4Y> Guff: http://pastebin.com/WmDEvbck
11:18:26 <tabemann_> it's mainstream compared to agda, coq, idris, etc.
11:18:39 <RedNifre> > readFloat "1.1"
11:18:41 <lambdabot>  [(1.1,"")]
11:18:45 <Guuf> MR4Y: And what does the error message say?
11:18:45 <hcaulfield57> I thought Haskell was the gateway to more esoteric languages.
11:18:49 <nshepperd> career goal: get enough money to go back to playing with haskell every day
11:19:07 <monochrom> heh
11:19:11 <Tuplanolla> That was what I tried to say.
11:19:42 <MR4Y> Guff: Well, it shows three errors when I try to load it into GHCi
11:20:00 <Guuf> MR4Y: Right.
11:20:09 <Guuf> MR4Y: You still have the vertical bars.
11:20:33 <MR4Y> Guff: So, the code doesn't work because of the guards?
11:20:53 <ski> hcaulfield57 : Mercury has support for functional programming in addition to logic programming, it also has a module system, a static type system, and also a static mode/instantiation and determinism system. to appreciate what the latter two are good for, it's also good to first learn Prolog
11:20:56 <Guuf> MR4Y: I wouldn’t put it that way. Only one of the things after the bars is a guard.
11:21:25 <Guuf> MR4Y: n < 0 is a guard, but the others aren’t, so they shouldn’t have vertical bars before them.
11:21:31 <MR4Y> Guff: I see.
11:21:47 <hcaulfield57> I've also been looking at Smalltalk lately. It's pretty interesting in it's own right.
11:21:55 <ski> hcaulfield57 : logic programming is based on expressing *relations* (aka predicates), not functions. one consequence of this is that one can realtively often run relation both "forwards" and "backwards", so it does the same job as two (or more) functions
11:22:10 <MR4Y> Guff: Now I just need to get the formula right.
11:22:11 <RedNifre> does readFloat really have multiple parses?
11:22:21 <RedNifre> I mean, what to do with that list and that empty string?
11:22:24 <RedNifre> > readFloat "1.1"
11:22:26 <lambdabot>  [(1.1,"")]
11:22:30 <Guuf> MR4Y: Right. I guess that means it checks now?
11:22:38 <ski> @type readFloat
11:22:39 <lambdabot> RealFrac a => ReadS a
11:22:43 <monochrom> > read "3%4" :: Rational
11:22:45 <lambdabot>  3 % 4
11:22:54 <MR4Y> The function loads into GHCi, but doesn't work the way I want it to.
11:22:55 <ski>   type ReadS a = String -> [(a,String)]
11:23:00 <monochrom> Rational's Read instance doesn't use readFloat at all
11:23:09 <MR4Y> Guff: The function loads into GHCi, but doesn't work the way I want it to.
11:23:24 <monochrom> well, I guess it's too bad, you would prefer it to accept both formats, wouldn't you :)
11:23:32 <Guuf> MR4Y: Well, but then you have won against the syntax at least. Great!
11:23:44 <triliyn> RedNifre: I don't know of any Read instance with multiple parses, but the string will not always be empty
11:23:50 <MR4Y> Guff: But I lost against recursion ;-;
11:23:53 <triliyn> > readFloat "1.1 this isn't consumed"
11:23:54 <lambdabot>  [(1.1," this isn't consumed")]
11:24:05 <RedNifre> > (readFloat :: ReadS Rational)  "1.1"
11:24:07 <lambdabot>  [(11 % 10,"")]
11:24:39 <Guuf> MR4Y: The mathematical formula is, as you probably know, f(n) = f(n-1) + f(n-2).
11:24:41 <RedNifre> > (readFloat :: ReadS Rational)  "1.1 and 3.3"
11:24:42 <lambdabot>  [(11 % 10," and 3.3")]
11:25:02 <triliyn> > let [(n, rest)] = readFloat "1.1 1" in (n, read rest :: Integer)
11:25:04 <lambdabot>  (1.1,1)
11:25:25 <hcaulfield57> ski: In my list of random languages to learn I had Smalltalk and Scheme, but maybe Prolog might be worth adding, when I actually get enough time to learn something.
11:25:33 <hcaulfield57> I guess it is a long weekend :)
11:25:42 <benzrf> smalltalk isnt quite the same as most other languages
11:25:52 <hcaulfield57> Smalltalk is completely bizarre
11:25:58 <benzrf> i dunno about bizarre...
11:26:02 <hcaulfield57> I've played around a little, but not tried to learn seriously.
11:26:06 <Tuplanolla> It's also on my list of things to look into, hcaulfield57.
11:26:09 <benzrf> its actually pretty simple in essence
11:26:21 <hcaulfield57> benzrf: And that's what makes it so bizaree
11:26:25 <benzrf> u have your objects & your messages
11:26:26 <hcaulfield57> Tuplanolla: What is?
11:26:30 <Tuplanolla> Smalltalk.
11:26:40 <hcaulfield57> Ah yea, it seems very interesting.
11:26:46 <Tuplanolla> Add these to your list too: Pure, Coq, J.
11:26:48 <benzrf> it's basically the epitome of dynamically typed OO
11:27:03 <vanila> Tuplanolla++ J rules!
11:27:07 <hcaulfield57> The biggest hurdle I think for Smalltalk is that it doesn't play nicely with the surrounding environment.
11:27:14 <nshepperd> > readFloat "1.1 "
11:27:15 <lambdabot>  [(1.1," ")]
11:27:25 <Tuplanolla> Under lifting the cup, drink coffee.
11:27:33 <monochrom> on your CV, you can claim: "I know J/Java/Javascript" :)
11:27:33 <ski> > [(x,y) | let s0 = "1.1 and 3.3",(x,s1) <- (readFloat :: ReadS Rational) s0,("and",s2) <- lex s1,(y,s3) <- (readFloat :: ReadS Double) s2,("","") <- lex s3]
11:27:34 <hcaulfield57> Haskell works really nicely for UNIX programming (never used it for Windows), Smalltalk seems to want to do it's own thing.
11:27:35 <lambdabot>  [(11 % 10,3.3)]
11:27:58 <prophile> :t lex
11:27:59 <lambdabot> ReadS String
11:28:02 <nshepperd> this looks like a pretty crappy float parser
11:28:18 <ski> Tuplanolla : "Pure" being ?
11:28:18 <MR4Y> Guff: The explicit formula doesn't work and...kinda freezes with big numbers.
11:28:50 <Guuf> MR4Y: That it freezes for big numbers is expected. In what way doesn’t it work?
11:29:11 <Tuplanolla> It's a language based on term rewriting, ski.
11:29:24 <nshepperd> RedNifre: but anyway I don't think it should have multiple parses if it's a well-formed number. so I guess make sure the list has one element, and make sure the empty string is indeed the empty string (or whitespace), and throw an error otherwise
11:29:29 <ski> Tuplanolla : related to Maude ?
11:29:35 <Tuplanolla> I don't know.
11:29:36 <dnivra> hello everyone! I'm trying to solve the problem 8 of the 99 problems and I run into an error which I can't make much sense of. Could someone help out? Code: http://lpaste.net/110257 and error: http://lpaste.net/110258.H
11:29:44 <benzrf> 99 problems, huh
11:29:54 <nshepperd> still this is pretty gross just for wanting to decode a Rational
11:30:10 <MR4Y> Guff: I changed the final thing to fibonacci n = fibonacci(n-1) + fibonacci(n-2). Entering fibonacci 70 made the interpreter churn and do nothing.
11:30:12 <benzrf> :t Prelude.lex
11:30:12 <lambdabot> ReadS String
11:30:14 <benzrf> huh
11:30:18 <benzrf> its aprleude
11:30:32 <ski> nshepperd : you can use `("","") <- lex ...' as in my example above to make sure there's nothing interesting at the end
11:30:41 <RedNifre> Finally, this works: sToN v s = fmap (fst.head.(readFloat :: ReadS Rational)) (v .: s)
11:30:44 <Guuf> MR4Y: Your formula is correct and you would get that result on any computer. :)
11:30:58 <Tuplanolla> The time complexity is O(F(n)) if I'm not mistaken, MR4Y.
11:31:11 <Guuf> MR4Y: There are of course more clever ways to compute fibonacci numbers.
11:31:33 <ski> > [x | (x,s) <- readFloat "1.1 ",("","") <- lex s]
11:31:35 <lambdabot>  [1.1]
11:31:51 <monochrom> dnivra: is it simply a typo? prob8EliminateDuplicates vs prob8EliminateDuplicates'
11:32:01 <MR4Y> Guff: Certainly. Thought, the knowledge of the other things didn't seeped in yet.
11:32:23 <MR4Y> Tupanolla: With a lambda?
11:32:37 <monochrom> I mean lines 5 and 6. I understand that prob8EliminateDuplicates' is a helper function and I support doing it
11:32:41 <Tuplanolla> With a cache.
11:34:25 * ski pondered the other day how to prove that multiplication on integers respects the representation of an integer as a difference between two natural numbers
11:34:33 <dnivra> monochrom: yeah that was a typo; my bad. I should probably choose different helper function names
11:35:19 <hcaulfield57> Sometimes the usage of ' is kind of distracting at times.
11:36:03 <RedNifre> dammit, Rationals don't turn into JSON numbers when converting them to JSON.
11:36:37 <monochrom> (a0-a1)*(b0-b1) = a0*b0 + a1*b1 - (a1*b0 + a0*b1)
11:36:58 <monochrom> if there is any respect, it's by brute force
11:37:04 <MR4Y> Might not seem like a clever question, but how long does it take to compile yesod?
11:37:46 <Guuf> A couple of hours, I would say.
11:38:05 <michaelt> MR4Y: that will depend quite a bit on what you or your sandbox already have installed...
11:38:05 <monochrom> wait, really? not half an hour?
11:38:23 <ski> i assume `a0 - a1 = c0 - c1' and `b0 - b1 = d0 - d1', iow `a0 + c1 = c0 + a1' and `b0 + d1 = d0 + b1'
11:38:24 <dnivra> Correcting that throws up new errors though. New code: http://lpaste.net/110261 and error: http://lpaste.net/110259
11:38:53 <Guuf> monochrom, not for me, but my computer is a bit old.
11:38:57 <MR4Y> michaelt: It's just the standard 2013.2.0.0 haskell-platform
11:38:57 <monochrom> oh! insensitive to that, I see.
11:39:57 <ski> and i want to prove `(a0 - a1) * (b0 - b1) = (c0 - c1) * (d0 - d1)', iow `(a0 * b0 + a1 * b1) - (a1 * b0 + a0 * b1) = (c0 * d0 + c1 * d1) - (c1 * d0 + c0 * d1)', iow `(a0 * b0 + a1 * b1) + (c1 * d0 + c0 * d1) = (c0 * d0 + c1 * d1) + (a1 * b0 + a0 * b1)'
11:40:20 <ski> it's a bit of a mess to keep track of eight different quantities
11:40:55 <MR4Y> michaelt: Since Archlinux (not currently using it) is the great deceiver of Haskell it seems. Currently on Lubuntu, which doesn't have 2014 as well. Buckets of fun.
11:41:37 <monochrom> I would be less ambitious at first. if a0-a1 = c0-c1, then (a0-a1)*k = (c0-c1)*k, for natural k first.
11:41:59 <ski> after drawing some rectangles, i think i got an idea which might work (relying on cancellation) .. but i'm wondering if i'm missing some easier way
11:42:16 <ski> monochrom : aye, i was pondering to try that first
11:42:49 <michaelt> MR4Y: well, you don't need to install the Platform, does it have the most recent ghc?
11:43:27 <monochrom> then for (a0-a1)*(0-k) = (c0-c1)*(0-k)
11:43:30 <vanila> ski, A different approach would be to construct integer multiplcation by recursion with addition and other operations that respect the equivalence relation - so you don't have to prove it at all.. but then one would maybe need to show that that definition of * is equivalent to the recursive one
11:43:44 <RedNifre> How do I convert a Rational to a JSON number without intermediate floating point problems?
11:44:04 <MR4Y> michaelt: Hopefully. Didn't checked.
11:44:08 <monochrom> then, similarly, k*(a0-a1)=k*(c0-c1) and (0-k)*(a0-a1)=(0-k)*(c0-c1)
11:44:11 <Trollinator> you don't.
11:44:38 <ski> vanila : by recursion how ? recursion on one (or both) of the naturals in the representation of an integer ?
11:44:49 <monochrom> then there are clever ways of instantiating all of those simple cases and combining them to get the general case.
11:44:58 <RedNifre> E.g. if I have 9%10 then I want "value":0.9 instead of something like "value":0.8999999999993453134
11:45:16 <MR4Y> michaelt: Archlinux doesn't even have haskell-platform ;-;
11:45:26 <michaelt> MR4Y: Its pretty easy to install locally the binary distribution from the ghc page.  then you can use the cabal-install you already have to go from there
11:45:31 <ski> monochrom : hm, ok
11:45:35 <monochrom> in particular, e.g., the normalization (3-4) -> (0-1) is very useful.
11:45:40 <vanila> ski, well for example you can define subtraction on these integers by just x - y = x + neg y, and it's respectful just because + and neg are, I mean a similar thing like that
11:46:08 <ski> monochrom : i think it would be nice if i wouldn't have to rely on normalization here (though a version which does could also be interesting)
11:46:50 <ReinH> monochrom: you can use this equivalence relationship to define the integers from the naturals
11:47:25 <michaelt> MR4Y: haskell platform is on closer inspection for Windows and OS X and maybe for a general community standard. Or that's one view anyway.  notice this http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
11:47:26 <monochrom> yes, we are doing that. we're looking for nice proofs.
11:47:34 <ReinH> monochrom: oh ok sorry
11:47:39 <ski> vanila : yes .. but as i'm defining ⌜ℤ⌝ as the usual quotient on pairs on ⌜ℕ⌝, i'm not sure how to do something like that for multiplication
11:47:47 <MR4Y> michaelt: Should be. Let's say that Archlinux documentation is like Pypy documentarion. It assumes the end user knows a lot of things about how Arch works. The secondary way to which you could use to build 2013 haskell-platform doesn't have PKG build in it. You have to do it manually.
11:48:03 <MR4Y> michaelt: I have 2014 on my windows partition.
11:49:20 <vanila> ski, x * y = if x == 0 then 0 else if x > 0 then y + (x-1)*y else if x < 0 then (x+1)*y - y
11:49:45 <Phillemann> Is there a package which parses ISO dates?
11:49:48 <hcaulfield57> I've discovered that if you don't eat lunch, you quickly loose the ability to program.
11:49:53 <vanila> probably this comes out much longer than just doing algebra but it's another approach
11:50:05 <Phillemann> Ah, found it, sorry.
11:50:35 <monochrom> I love normalizations. they're so normal. :)
11:50:36 <ski> ReinH : yes, i'm starting from ⌜_-_ : ℕ × ℕ → ℤ⌝, with ⌜∀p₀,n₀,p₁,n₁ : ℕ. p₀ - n₀ = p₁ - n₁ ⇔ p₀ + n₁ = p₁ + n₀⌝
11:51:28 <ski> vanila : oh, trichotomy
11:52:05 <ski> vanila : hmm, i wonder how easy it would be to see termination of that
11:52:35 <monochrom> the variant is |x|
11:52:44 <monochrom> or, a variant
11:52:52 <ski> (variant ?)
11:53:12 <ski> vanila : ty for the alternative approach idea
11:53:50 <monochrom> it's imperative parlance for the expression whose type is natural, whose value strictly decreases per iteration, therefore proves termination.
11:54:26 <monochrom> wherease invariant is imperative parlance for a sentence true before/after every iteration.
11:54:27 <ski> oh
11:54:48 <ski> is that "variant" terminology from Hoare logic ?
11:55:01 <monochrom> and lastly, by imperative parlance, I mean imperative formal methods parlance. so, the Dijkstra calibre, not the GvR calibre! (snob)
11:55:35 <f-a> quick q: is there a way to specialise a function according to its typeclass?
11:55:47 <monochrom> well, Hoare didn't worry about termination at first. I don't know who gave that name.
11:55:56 <ski> ok
11:56:21 * ski was experimenting around with syntax for equality proofs, when stumbling into the above
11:56:55 <simpson> f-a: In GHC, at least, there's a pragma for that, SPECIALIZE: https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
11:57:02 <monochrom> it is definitely affiliated to Hoare logic, because you add that expression and its requirement to decrease to the while-loop rule so as to extend Hoare's logic to cover termination
11:57:24 <vanila> ski another proof a-la Zeilberger http://lpaste.net/110262
11:57:36 <ski> monochrom : and presumably also for recursion
11:57:41 <monochrom> yeah
11:59:12 <f-a> thanks simpson
11:59:42 <ski> vanila : i'm figuring that if i'm decomposing to naturals, i'd prefer to keep the proof strictly to naturals, after restating in terms of those
12:00:30 <vanila> oh very good point, I overlooked at
12:00:50 <monochrom> I have a cunning plan!
12:01:00 <monochrom> the variant is a certificate of termination
12:01:20 <monochrom> therefore, it can also be gruesomely called: death warrant
12:01:40 <ski> my current idea is to prove `L = R' by proving `2 * L + (J + K) = 2 * R + (J + K)', for suitable expressions `J' and `K' of the same complexity as the previous `L' and `R'
12:02:51 <ski> vanila : e.g., i'd like to be very careful with stuff like `(x0-x1)*(a0-a1) - (y0-y1)*(b0-b1)', since i'm really not done yet defining multiplication on integers
12:03:25 <monochrom> indeed, I really treated (x0-x1) as (x0,x1) at crucial times
12:04:34 <ski> (yes, i treat ⌜_-_⌝ here as a (non-injective) constructor for ⌜ℤ⌝)
12:06:29 <monochrom> oh, is ICFP about to start?
12:06:44 <luite> tomorrow is the first day, monday the first day of the main event
12:06:56 <luite> haskell symposium is after the main event this year
12:07:22 <vanila> ski, I think this is a good idea http://lpaste.net/110263
12:07:26 <monochrom> "The plan is to meet at The Bishop's Arms" "NOTE: there are three Bishop's Arms" XD
12:07:43 <ski> (fyi, i'm currently defining naturals as the free monoid on a singleton set. this makes the definitions of operations on them interesting (to me))
12:08:07 <vanila> although there may be two base cases
12:09:16 <ski> vanila : hm, interesting
12:09:34 <ski> (this is a variation of the normalization idea, i think)
12:09:44 <vanila> I meant to prove a0*b0 + a1*b1 - (a1*b0 + a0*b1) = (a0+1)*b0 + (a1+1)*b1 - ((a1+1)*b0 + (a0+1)*b1)
12:09:51 <vanila> but wrote something else by mistake
12:11:38 <ski> vanila : annotate the correction ?
12:12:22 <vanila> http://lpaste.net/110263
12:13:13 <vanila> now if x-y = z-w you can reach one from the other by application of the two rules so this should be enough to conclude
12:17:42 <ski> mhm
12:18:39 <ski> i was a little bit surprised that proving this seemed quite a bit more involved than proving the corresponding property for addition
12:28:25 <ski>   add : ℤ → ℤ → ℤ
12:28:34 <ski>   add (Subtract p₀ n₀) (Subtract p₁ n₁) = Subtract (Add p₀ p₁) (Add n₀ n₁)
12:28:47 <ski>   ⌜add ⌞SubEq pl₀ nl₀ pr₀ nr₀ eq₀⌟ ⌞SubEq pl₁ nl₁ pr₁ nr₁ eq₁⌟⌝ = SubEq (Add pl₀ pl₁) (Add nl₀ nl₁) (Add pr₀ pr₁) (Add nr₀ nr₁) (AddMix pl₀ pl₁ nr₀ nr₁ ∘ ⌜Add ⌞eq₀⌟ ⌞eq₁⌟⌝ ∘ AddMix pr₀ nl₀ pr₁ nl₁)
12:28:58 <ski>   AddMix : (m : ℕ) → (n : ℕ) → (o : ℕ) → (p : ℕ) → Add (Add m n) (Add o p) = Add (Add m o) (Add n p)
12:29:03 <spopejoy> having trouble building a darcs repo. any idea why a package wouldn't show up, even though I'm using --user, and ghc-pkg finds it?
12:29:20 <ski> where ⌜AddMix⌝ should be easy to prove with associativity
12:30:16 <spopejoy> with 'runhaskell Setup.lhs configure --user', I get 'Setup.lhs: At least the following dependencies are missing: haskell-src ==1.0.*', but 'ghc-pkg list haskell-src' finds it
12:30:29 <spopejoy> haskell-src-1.0.1.5
12:31:51 * ski would also like, for each proof of ⌜l = r⌝ (where ⌜l,r : A⌝), a canonical element of ⌜A⌝
12:32:07 <spopejoy> HOWEVER: this package was installed with haskell-platform, and it's constrained in cabal. Would using '--user' mean that it wouldn't be found? I thought global stuff shows up when using --uyser
12:35:13 * hackagebot lit 0.1.0.5 - A simple tool for literate programming  http://hackage.haskell.org/package/lit-0.1.0.5 (cdosborn)
12:37:36 <Algebr> Why is Latex so huge?
12:39:13 <michaelt> Algebr: it's all those macros expanding each other.
12:40:45 <spopejoy> OK found the root of the problem. ghc-pkg list --global finds haskell-src, but ghc-pkg dump (used by configure) doesn't. Why would list show a package, but dump NOT show it?????
12:44:33 <alphonse23_> has anyone ever type in ['('..] into ghci
12:44:35 <michaelt> it seems to have taken 50 minutes to install yesod on my laptop but that was with profiling and haddocking and including text vector attoparsec etc.  With the haskell platform presupposed, and no profiling, it can't take more than 25 minutes
12:44:39 <alphonse23_> *typed in ['('..]
12:44:48 <alphonse23_> it's pretty cool
12:44:51 <c_wraith> > succ '('
12:44:52 <lambdabot>  ')'
12:45:11 <c_wraith> alphonse23_: if you want all printable characters, start at ' '
12:45:15 <alphonse23_> and pred '(' produces '\'
12:45:28 <alphonse23_> but you can't specify it into the range
12:45:42 <alphonse23_> so ['\'..'Z'] doesn't work
12:45:54 <solarus> > take 10 ['\\'..]
12:45:55 <lambdabot>  "\\]^_`abcde"
12:46:07 <c_wraith> > ['\\'..'Z']
12:46:09 <lambdabot>  ""
12:46:10 <alphonse23_> that didn't work for me c_wraith
12:46:19 <alphonse23_> [''..] produced an error
12:46:19 <c_wraith> works like I'd expect
12:46:19 <solarus> > take 10 ['\''..]
12:46:21 <lambdabot>  "'()*+,-./0"
12:46:28 <c_wraith> alphonse23_: I said ' ', not ''
12:46:47 <alphonse23_> okay that worked
12:46:51 <spopejoy> no cabal/ghc-pkg expertise around?
12:47:13 <alphonse23_> what's the significance of '\128'
12:47:24 <alphonse23_> why does \128 start after \del?
12:47:49 <c_wraith> it's using the Show instance for Strings
12:47:54 <c_wraith> it escapes a lot of stuff
12:48:04 <alphonse23_> " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL"
12:49:23 <c_wraith> ghci is using the show instance to display the string, that is
12:50:48 <michaelt> alphonse23_: for me putChar fails at \55257
12:51:28 <alphonse23_> it runs out of memory or something?
12:51:32 <alphonse23_> it doesn't run forever
12:51:41 <alphonse23_> I'm afraid of trying it.
12:51:53 <c_wraith> There aren't that many codepoints.
12:51:54 <michaelt> no, there is a maxBound
12:51:57 <michaelt> > maxBound :: Char
12:51:59 <lambdabot>  '\1114111'
12:52:13 <c_wraith> More to the point, there are a bunch of codepoints that don't even make sense to try to print by themselves.
12:52:24 <alphonse23_> oh. so why doesn't it stop at \1114111?
12:52:34 <c_wraith> Because unicode does not map single codepoints to single glyphs
12:52:58 <michaelt> strangely, putChar maxBound doesn't make an error, it just gets replaced.
12:58:33 <sala> hey
12:58:53 <RedNifre_afk> Have you checked for what is at 55257 in unicode?
12:59:27 <copumpkin> http://www.fileformat.info/info/unicode/char/d7d9/index.htm
12:59:44 <superfunc> I have a question, if someone doesn't mind answering. Since functors are supposed to exhibit two laws (mapping id over a functor leaves it unchanged and composition), why aren't these behaviors just explicitly written in the functor typeclass?
13:00:27 <RedNifre> > read 32 :: Char
13:00:29 <lambdabot>  No instance for (GHC.Num.Num GHC.Base.String)
13:00:29 <lambdabot>    arising from the literal ‘32’
13:01:22 <RedNifre> > chr 32
13:01:24 <lambdabot>  ' '
13:01:37 <RedNifre> > chr 0xFEFF
13:01:38 <lambdabot>  '\65279'
13:01:43 <RedNifre> > chr 0xFFFE
13:01:45 <lambdabot>  '\65534'
13:01:48 <RedNifre> oh no.
13:02:38 <RedNifre> > chr (65536 * 17 -1)
13:02:39 <lambdabot>  '\1114111'
13:02:43 <RedNifre> > chr (65536 * 17)
13:02:44 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
13:03:28 <RedNifre> That's bad, why does it accept invalid code points like 0xFFFE?
13:04:21 <RedNifre> > take 256 $ map chr [0..]
13:04:23 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
13:04:37 <RedNifre> > take 128 $ map chr [32..]
13:04:39 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
13:05:06 <hpc> for a minute there i thought FFFE was the replacement character
13:05:08 <hpc> but that's FFFD
13:05:30 <RedNifre> FEFF is the byte order mark and that works precisely because FFFE is forbidden
13:06:44 <RedNifre> so Char isn't really a Unicode code point, it's just a number <- [0..1114111] :(
13:07:37 <RedNifre> Meh, guess it's worth the performance. I mean, you can't really do Unicode with just Chars and Strings anyway.
13:08:13 <benmachine> Chars are meant to represent unicode code points, iirc
13:08:18 <benmachine> if they don't do that it's probably a bug
13:08:36 <RedNifre> That's not a unicode code point: chr 0xFFFE
13:08:46 <geekosaur> yes and no. when it comes down to it, it's a somewhat restricted Int
13:09:41 <geekosaur> and it doesn't exclude FFFE because it's just an Int and not a smart subtype
13:09:42 <RedNifre> So Chars are things for which there exist a bidirectional mapping to integers from 0 to 1114111, which makes them useful for approximating Unicode, I guess.
13:10:05 <michaelt> The text library disbelieves in anything above \55295 if I understand it
13:10:16 * hackagebot language-lua 0.4.5 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.5 (OmerAgacan)
13:10:27 <sagittarian> what does the pipe mean in: class (Monad m) => MonadError e m | m -> e where ... ?
13:10:37 <Clint> fundeps, i believe
13:10:38 <hpc> sagittarian: it's a functional dependency
13:10:39 <shachaf> It's called a functional dependency.
13:10:39 <michaelt> m determines e
13:10:46 <sagittarian> thanks guys
13:10:51 <benmachine> geekosaur: I claim that's a bug according to the standard
13:10:54 <RedNifre> I bet D7FF is invalid
13:10:57 <hpc> basically, for every m there's exactly one e that can match
13:11:04 <RedNifre> IS that a surrogate?
13:11:12 <hpc> you can have instance MonadError () Maybe
13:11:23 <hpc> but you can't then go and have instance MonadError Int Maybe as well
13:11:25 <geekosaur> benmachine, then so is Haskell not supporting subtyping.
13:11:38 <shachaf> michaelt: 0xD800 - 0xDFFF are invalid code points.
13:11:38 <benmachine> geekosaur: ...how?
13:11:40 <sagittarian> and the functional dependency is contingent on the actual code
13:11:50 <sagittarian> ?
13:11:51 <geekosaur> because subtyping is essential to support Unicode the way you claim it should be
13:11:53 <hpc> and what you get to do from that restriction is that when type inference sees 'm = Maybe', it can then infer 'e = ()'
13:12:03 <sagittarian> meaning you can define one or the other, whichever you want, but not both?
13:12:15 <benmachine> geekosaur: I can't see how that's true
13:12:16 <sagittarian> okay thanks
13:12:34 <benmachine> geekosaur: Char should just be an enumeration of all unicode codepoints, not more nor less
13:12:59 <geekosaur> benmachine, it could possibly be implemented that way. at the cost of becoming practically useless
13:13:02 <shachaf> sagittarian: No. You should look up documentation on functional dependencies because it's a slightly complicated extension.
13:13:29 <sagittarian> i am, thanks shachaf
13:13:40 <shachaf> sagittarian: Oh. Yes to "one or the other but not both" if you mean instances for () Maybe and Int Maybe.
13:14:08 <benmachine> geekosaur: how would that be less useful than what currently exists? why do you ever need to create Chars that are not codepoints?
13:14:26 <geekosaur> the real fact of the matter is that unicode isn't quite as well defined as you'd like to believe; *nobody* implements it properly and people who have tried have found that it can't be
13:15:09 <RedNifre> I guess it's best for performance that Chars are just numbers from 0 to 1114111 and Strings are just lists of chars. It's fine IMHO that you only get real unicode checking when using Text
13:15:24 <spopejoy> arrgh figured it out. macport install of darcs fubar'd my PATH
13:15:27 <benmachine> RedNifre: you do not use String if you care about performance :P
13:15:28 <geekosaur> benmachine, roundtripping issues. there's an old discussion about this from around the first implementation of ghc's I/O manager supporting utf8 instead of just iso8859-1
13:15:56 <benmachine> performance is not an excuse for incorrectness in this case
13:16:26 <RedNifre> How does UTF-8 play into this? Aren't Strings UTF-32?
13:16:57 <hpc> String is just [Char] and Char is whatever encoding it wants to be
13:16:58 * geekosaur wonders if (a) he can find the discussion (b) benmachine will figure they Know Better and outrank the entire discussion
13:17:07 <benmachine> geekosaur: due to a quirk in the hotel wifi, I cannot do any web browsing at all
13:17:09 <geekosaur> RedNifre, I was referring to a discussion of roundtripping
13:17:19 <hpc> in ghc iirc it is UTF-8, but don't quote me on that
13:17:29 <geekosaur> which came up in the context of GHC's I/O manager handling encodings
13:17:55 <geekosaur> utf8 is not directly applicable to *this* discussion but was to *that* discussion and led into issues similar to those being discussed here
13:18:02 <RedNifre> That doesn't really matter. Especially for round tripping it is important that 0xD800 is NOT a valid character, since you can't encode that in UTF-16
13:18:33 <benmachine> so I guess if I need to read a discussion to understand this further, I am not going to understand it further :P
13:18:56 <geekosaur> I'm shorthanding, ghuess I should conclude that since I did not memorize the exact discussion, clearly it never existed
13:20:23 <benmachine> geekosaur: also I didn't understand your remark about outranking, if you think I'm being overly prescriptive then I apologise
13:20:58 <benmachine> I know I don't understand Unicode but I thought I understood enough of it to know at least roughly what Char looks like
13:21:10 <geekosaur> ghc cuts corners because it has to. as I said earlier: unicode *can't* be implemented as you want it. people who have tried have found that it manages to contradict itself
13:21:25 <hpc> what particular bits contradict?
13:21:26 <geekosaur> and for all its detail it leaves important things unspecified
13:21:36 <RedNifre> If I were to implement it I'd model Chars as 32 bit integers (UTF-32). I think that's how Go models them.
13:21:49 <RedNifre> Java has them as 16 bit for historical reasons, which causes all kinds of problems
13:22:26 <RedNifre> Ruby has this insane concept of "every String can has it's own encoding", but I think strings are always bytes, so if you want unicode it is UTF-8...
13:22:50 <michaelt> Oh I see, Text maps the 'invalid' points to '\xfffd'
13:22:59 <geekosaur> (lemme rephrase that. unicode /per se/ is not contradictory but several of the encodings do not actually map to unicode the standard and apparently can't for some reason)
13:23:14 <RedNifre> ...what?
13:23:22 <michaelt> T.putStr broke on a 'valid' codepoint
13:23:29 <khumba> Is there a standard idiom for inverting a map, Map k v -> Map v [k]?  Something nicer than for example this:
13:23:33 <khumba> :t Map.fromList . map (\xs@((k,_):_) -> (k, concatMap snd xs)) . List.groupBy ((==) `on` fst) . List.sort . map (second (:[]) . Tuple.swap) . Map.assocs
13:23:34 <lambdabot>     Not in scope: ‘Map.fromList’
13:23:34 <lambdabot>     Perhaps you meant one of these:
13:23:34 <lambdabot>       ‘M.fromList’ (imported from Data.Map),
13:23:44 <RedNifre> michaelt which one?
13:24:17 <Peaker> RedNifre: note the most expensive thing is cache lines, so you may want to store stuff UTF-8 to waste less cache lines
13:24:29 <Peaker> (performance-wise)
13:24:58 <RedNifre> Oh, I thought cache lines match the general number of bits of the CPU, e.g. 32bit or 64 bit.
13:25:17 * hackagebot http-test 0.2.2.1 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.2.1 (glutamate)
13:25:18 <michaelt> wait, my claim about printing might be wrong
13:25:19 * hackagebot http-test 0.2.3 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.3 (glutamate)
13:25:24 <RedNifre> ...how can you cache chars if they are 1 to 4 bytes? How do you fetch that from the cache?
13:26:01 <RedNifre> and how would you align utf-8 chars to cache lines?
13:26:19 <Peaker> RedNifre: cache lines cache general RAM bytes. If your data structures take more RAM, they waste more cache lines
13:26:24 <dreams> Peaker: is sharing implementation similar to caches?
13:26:33 <Peaker> dreams: what do you mean?
13:26:35 <benmachine> khumba: I don't know about standard idiom, but how about M.fromListWith (++) . map (\(x,y) -> (y,[x])) . M.assocs
13:27:01 <RedNifre> sure, but how do you read or write chars to the cache if chars are 1,2,3 or 4 bytes large? How would you safe any space?
13:27:18 <RedNifre> I mean, you can serialize a whole String to RAM, but then you can't access chars by index.
13:27:22 <dreams> Peaker: like arguments are only computed once and are stored for later need.
13:27:31 <Peaker> I fixed all my horrible deadlock bugs/etc by writing my own Control.Exception primitives to replace: bracket, bracket_, finally, onException, handle,   no more horrors! Yay! :)
13:27:46 <Peaker> uninterruptible-mask makes much more sense for the cleanup actions
13:27:59 <luite> Peaker: did you need anything special to handle cleanup?
13:28:00 <michaelt> No, right, Text prints everything, by making replacements; but Char/String includes the invalid things
13:28:01 <Peaker> being "responsive" at the expense of cleanups/correctness is a horrible horrible trade-off
13:28:19 <Peaker> luite: I wanted to guarantee cleanups actually happen
13:28:37 <Peaker> luite: by default, Control.Exception does not - because async exceptions kill interruptible cleanups (which is pretty much any blocking cleanup)
13:28:43 <luite> Peaker: ah just uninterruptible masks for blocking things in the cleanup?
13:28:57 <Peaker> luite: yeah! And a bit of code review to guarantee my cleanups dont block forever
13:29:01 <ezyang_> Is there a way to programatically extract the set of flags Cabal decides to compile code with?
13:29:16 <Peaker> ezyang_: hackily you could use "cabal build -v"
13:29:20 <RedNifre> Earlier today I got this weird error where I tried to printed a Just SomeData thing that I parsed from JSON and I only got the exception when I printed it, because a field could not be parsed. Given Lazy evaluation and higher order function parsing and exceptions, basically any piece of code can throw any exception at any time, right?
13:29:25 <Peaker> (probably a better way)
13:29:45 <Peaker> luite: At one point, I had to write asyncThrowTo = forkIO around throwTo to avoid a deadlock between two threads that want to kill each other in their cleanups
13:29:47 <joelteon> does the maintainer of optparse-applicative come in here?
13:29:52 <khumba> benmachine, that's great, I missed fromListWith, thanks!
13:30:00 <RedNifre> I mean, in this case it was a safe looking parser that returned a Maybe, but even though I got a Just out of it it still exploded because I passed a buggy function into it that threw an error.
13:30:07 <Peaker> but otherwise, using my primitives improved the situation greatly
13:30:10 <luite> Peaker: ah right you mentioned a nonblocking throwTo at some point
13:30:30 <ezyang_> Peaker: blah, I asked for programmatic!
13:30:55 <Peaker> ezyang_: pipe the stdout :-)
13:31:28 <Peaker> luite: I think Control.Exception ought to be changed to do this
13:31:28 <Peaker> it will radically improve the concurrency situation in Haskell, IMO
13:31:30 <ezyang_> ok, I'm going to do this for now and file a Cabal bug
13:31:48 <RedNifre> ...which makes me wonder about this whole purity thing. I mean, I thought that pure functions are safe and only IO is bad and you can only lift up, but not down... however, you can pass non-total functions into "total" functions, thereby tainting them and destroying the "totalness" purity you thought you had.
13:32:47 <luite> Peaker: right i think they're quite powerful but might need a bit of tweaking or other control structures to make them a bit easier to manage. normally exceptions run in a MaskInterruptible state, right?
13:32:57 <luite> err, i mean exception handlers
13:33:09 <Peaker> luite: yeah
13:33:10 <Peaker> luite: which is a very very very dangerous default
13:33:12 <barrucadu> RedNifre: Yes, if you use partial functions, bad things can happen. That's why partial functions are bad.
13:33:24 <Peaker> super-duper error-prone
13:33:53 <barrucadu> Except in cases where it can be verified that, for all possible inputs, the partial function succeeds (eg, an internal helper function in a module, where all the input is thus controlled)
13:34:27 <luite> Peaker: async exceptions are pretty interesting to implement too btw, similar to call/cc for scheme, at least some implementations :)
13:35:18 * hackagebot yi 0.8.2 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.8.2 (MateuszKowalczyk)
13:36:25 <RedNifre> Okay, so the rule is "only use partial function on your own data" then...
13:36:52 <Peaker> RedNifre: Ideally, redesign your data types and even use advanced type system features to avoid partial functions
13:37:09 <Peaker> RedNifre: Stuff like GADTs exist for this purpose
13:37:40 <RedNifre> Will do, later, when I have a better understanding of Haskell (Still only at chapter 3 of "Beginning Haskell")
13:38:33 <RedNifre> Actually, I sort of stopped reading and went straight to implementing something instead. I don't really know what I'm doing but I'm making progress and it's fun :)
13:39:27 <RedNifre> Speaking of progress, I think I reached the point where I want to use a library. I just discovered hackage and I'm looking for a decimal float/fix point library. There are a few, but how do I figure out which one is good?
13:39:41 <RedNifre> I wish there were user reviews ;)
13:40:02 <Fuuzetsu> look at the API, see number of downloads, ask around
13:40:14 <Fuuzetsu> latest upload date is usually relevant
13:40:20 <RedNifre> good point
13:40:32 <silver> also you can make such reviews :D
13:41:38 <RedNifre> "That library uses Monads. I don't know what that is, one star!"
13:43:13 <RedNifre> Before I go down that rabit hole of using a special library to represent a number, does anyone know if that will complicate my JSON shenanigans? See, the whole point of decimals is that a) I have decimals b) I can write that decimal to JSON without an intermediate binary float conversion.
13:44:28 <Haskellfant> RedNifre: what exactly do you want the library to do? haskell supports floating point numbers without the need for additional libraries
13:44:39 <RedNifre> I have no intuition how flexible haskell is here. Can Aeson turn data { foo : CustomDecimalRepresenting0.9 } into "foo":0.9 without intermediate float, thus preventing disasters like "foo":0.89999999934523
13:44:42 <RedNifre> ?
13:45:15 <Haskellfant> RedNifre: haskell supports exact rationals
13:45:21 <Fuuzetsu> depends on what your ToJSON instance does
13:45:21 <Haskellfant> that might be what you're looking for
13:45:55 <RedNifre> I tried those already, but JSON mangles them, they turn into "foo":{denominator:34,forgotwhatitscallinator:10}
13:46:10 <RedNifre> ...which is accurate, but I want 3.4 instead.
13:46:33 <brycelane_> does anybody use EclipseFP?
13:46:35 <Haskellfant> you could probably wrap them in a newtype and provide a custom ToJSON instance
13:47:48 <RedNifre> Is ToJSON extendable? It looks like it can only output some predefined things.
13:48:02 <Haskellfant> ToJSON is just a type class
13:48:22 <Haskellfant> you can provide ToJSON instances for all types
13:48:43 <Cale> RedNifre: You might also try Data.Fixed
13:49:03 <RedNifre> Can you create invalid JSON, e.g  {"foo":quotesAreMissing}?
13:49:29 <barrucadu> No
13:49:54 <Cale> You construct data structures which represent the JSON, and that is rendered to a String in a way which prevents invalid syntax.
13:50:20 * hackagebot haste-compiler 0.4.1 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.1 (AntonEkblad)
13:51:27 <RedNifre> That's the problem. If I have a custom thing representing 0.1, how can I output JSON of the format "foo":0.1, without having an intermediate binary float that might actually be 0.099999999999234?
13:51:55 <Cale> There is a warning about using Fixed though, in the case that your application is user-facing in any way. Because Fixed supports arbitrarily large numbers, the user could provide a number with a very large exponent to fill up memory.
13:52:00 <RedNifre> I mean, there is no point in having decimal fractionals, if I can't write them to JSON without converting them to binary floats and back to decimal.
13:52:22 <Cale> But Fixed is a solution to this
13:52:35 <RedNifre> I'm currently reading about it.
13:52:41 <Cale> (apart from that caveat, which is shared by Integer and Rational)
13:52:51 <RedNifre> I guess Fixed is decimal and it's supported by Aeson directly?
13:53:08 <modeller> A question for polynomial time complexity: Does non-integer exponent count as polynomial time? e.g. O(n^3.3) My concern is the wiki entry of "polynomial" says a polynomial can only have +ve integer exponent.
13:53:24 <Cale> RedNifre: Yeah
13:53:52 <RedNifre> Sounds perfect, I'll see how far I'll get with that. Thanks :)
13:53:57 <Cale> RedNifre: If you're interested in representing amounts of money, type Centi = Fixed E2 is probably what you want.
13:55:20 * hackagebot pandoc-citeproc 0.5 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.5 (JohnMacFarlane)
13:56:51 <jle`> modeller: i'm sure i have seen such things be called polynomial complexity in the past
13:58:23 <modeller> jle`: do you mean that "polynomial complexity"  allows rational number exponents, while "polynomial" don't.
13:59:05 <RedNifre> Centi looks fine, but how do I get a Centi from either a string or a Rational?
13:59:49 <barrucadu> RedNifre: Why do you want to get it from a string or a rational?
14:00:48 <barrucadu> There are already ToJSON and FromJSON instances for Fixed
14:00:51 <RedNifre> I have JSON that looks like "foo":"12.34" and so far I managed to parse that to Rationals
14:01:12 <RedNifre> Excellent, then I can throw away all that Rational parsing stuff :)
14:01:58 <barrucadu> …but I assume they don't wrap up the values inside a string
14:02:14 <RedNifre> Ah, well, they do.
14:02:20 <RedNifre> Currently, I do this: fmap (fst.head.(readFloat :: ReadS Rational)) (v .: s)
14:02:53 <RedNifre> I guess this works just as well with Centi instead of Rational?
14:04:39 <RedNifre> Excellent, it works perfectly :)
14:06:29 <nitrix> I'm curious, how would one have two i/o functions, e.g. putChar and getChar with a type that looks like :: (World* -> char) -> World* and :: World* -> (World* -> char) given that World* is a linear type? How would you make this convenient without having to user pass the world around if Haskell didn't use monads?
14:07:34 <bennofs> nitrix: I think you can still use monads even with linear types
14:08:15 <nitrix> You can, although the question is how would you make the user comfortable with linear types if there was no mands?
14:08:16 <bennofs> nitrix: the safety that linear types give you just allows you to expose the constructor of the IO monad without risk (= use a simple state monad for IO)
14:08:17 <nitrix> monads*
14:09:23 <vanila> I think the precursor to haskell used to use something like linear types (uniqueness types?)
14:09:29 <bennofs> ah hmm, so you're looking for alternatives to monads for that problem. idk why you want that though :)
14:09:50 <nitrix> bennofs: Research mostly.
14:10:19 <nitrix> But my knowledge on the topic feels short so I'm asking around.
14:10:21 * hackagebot layers-game 0.4 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.4 (DanielTrstenjak)
14:10:24 * hackagebot arxiv 0.0.1 - A client for the Arxiv API  http://hackage.haskell.org/package/arxiv-0.0.1 (TobiasSchoofs)
14:12:32 <prophile> so a couple of monads (IO, STM, State etc) have some kind of "variables" which look a lot like (m a, a -> m ())
14:12:46 <prophile> seems vaguely... lensy
14:12:57 <prophile> I wonder, is there a prettier formulation of them?
14:13:10 <bennofs> nitrix: I think you could use a continuation passing style. So you have getChar :: (Char -> World* -> (World*,a)) -> World* -> (World*,a) and putChar :: Char -> (World* -> (World*,a)) -> World* -> (World*,a)). I think that would allow you to write getChar $ \c1 -> getChar $ \c2 -> putChar c2 $ putChar c1
14:14:20 <irdan> can anyone tell me why i get a lexical error on "\x", but the string "\\x" is shown with both slashes?
14:14:44 <shachaf> irdan: It's shown with both backslashes for the same reason that you type it with both backslashes.
14:14:48 <nitrix> bennofs: Yeah but that works only in that case, no ?
14:14:57 <jle`> modeller: oh, yeah.  the mathemaical definition of polynomial usually doesn't include non-integer exponents.  but i think in the context of complexity, you can see non-integer exponents
14:15:04 <bennofs> nitrix: in what case wouldn't it work?
14:15:09 <nitrix> bennofs: Oh, I see where you're getting. You'd always have the World* the first argument and also the first output?
14:15:10 <irdan> shachaf: yes, but in the first string "\x" appears to be escaping x
14:15:22 * hackagebot layers-game 0.4.1 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.4.1 (DanielTrstenjak)
14:15:33 <shachaf> irdan: Try length ("\\x")
14:15:37 <bennofs> nitrix: World* is always last argument and first element of output tuple
14:15:47 <nitrix> Right.
14:16:07 <irdan> shachaf: haha, i see.  thanks
14:16:08 <nitrix> And then, that World* can just move around throughout i/o functions.
14:16:34 <int-e> prophile: to get rid of the world token, you could formulate these monads as free monads, together with black-box interpreters.
14:17:33 <prophile> int-e: indeed, although that's not quite what I'm asking—I probably phrased the question badly
14:18:00 <nitrix> bennofs: what if a function needs two random numbers? You can't do: randNum w + randNum w, you'd need ehm... randNum randNum w ... but then how do you get the values..
14:18:09 <nitrix> bennofs: I'm a bit lost.
14:18:28 <prophile> van laarhoven lenses reformulate (a -> b, a -> b -> a) as forall f. Functor f => (b -> f b) -> (a -> f a) - I'm wondering if there's something analogous for (m a, a -> m ()) for any monad m
14:19:09 <jle`> modeller: the wiki page for big-o notation and time complexity defines polynomial-order complexity as x^c with any c > 1.  it doesn't seem to limit c to integers
14:19:36 <bennofs> nitrix: randNum $ \rand1 -> randNum $ \rand2 -> (, rand1 + rand2)    (you can also call (, x) = return x :))
14:20:59 <jle`> explicit world passing doesn't really seem to fit into nice models for concurrency, for me :/  or runtime exceptions
14:21:44 <nitrix> jle`: I know, I'm looking for a way to use linear types to pass a world around without monads, and its for research purposes.
14:22:19 <jle`> ah i see
14:22:28 <int-e> jle`: and you're right. it becomes better once you realize that it's an implementation trick to enforce evaluation order by way of artificial data dependencies; you don't need to pass around the whole world at all.
14:23:01 <int-e> jle`: but that completely breaks the standard interpretation of the type.
14:23:38 <jle`> what breaks what interpretation?
14:24:08 <int-e> reducing the world token to nothing at all breaks the interpretation that an IO action somehow produces a new, modified world.
14:24:21 <RedNifre> I'm confused. I changed my parsing function to pS Centi v "bla" since I changed my function to pS a v s = fmap (fst.head.(readFloat :: ReadS a)) (v .: s)  , but I'm doing it wrong. What is the correct syntax to write what I mean?
14:24:53 <RedNifre> in that function, a used to be Centi, but I wanted to generalize it for other types as well...
14:25:52 <jle`> int-e: indeed
14:27:03 <Cale> RedNifre: Centi is a type (a type synonym for Fixed E2, specifically), you don't want it showing up in patterns or values. You can use Centi values just like other numbers, as there are instances of Num, Fractional, etc. for it.
14:28:24 <Cale> RedNifre: Pretty much the only thing which ought to distinguish the fact that you're using Centi as opposed to another type of numbers will be in the type signatures of your functions.
14:30:24 * hackagebot JuicyPixels 3.1.7 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.7 (VincentBerthoux)
14:31:28 <RedNifre> So if I have JSON like {"foo":"1.22","bar":"1.666666"}, and data {foo :: Centi, bar :: Micro}, what is the most elegant way to parse the JSON to the data?
14:33:31 <RedNifre> When I only dealed with Centi I used <*> pS v "foo" <*>... in the parser, which used this: pS v s = fmap (fst.head.(readFloat :: ReadS Centi)) (v .: s)
14:34:01 <RedNifre> I could copy paste that function to get one for Micro, but that's not really good.
14:35:58 <RedNifre> So how can I generalize that function to work with Centi or Micro or any other thing I pass to it?
14:49:13 <trap_exit> what are clojure's tranducers?
14:49:15 <trap_exit> what would their type signatures be in haskell?
14:50:15 <edlinde> do most people here when writing functions write an explicit type declaration for each function?
14:50:22 <edlinde> is this good practise?
14:50:41 <vanila> I don't often do that
14:50:45 <Cale> trap_exit: http://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/ discussion here
14:50:50 <vanila> only if I an using types to direct my programming
14:50:50 <cbarrett> edlinde: for top level declarations, yes, most of the time.
14:51:03 <Cale> edlinde: It really depends
14:51:10 <trap_exit> I write the explicit type declaration efore writing the function definition itself
14:51:28 <edlinde> hmm so when is it a good idea to do it?
14:51:29 <trap_exit> I also compile with -Wall -Werror, so my compiler won't compile unless I provide the type declaration
14:51:33 <Cale> edlinde: If I don't know exactly how to write the function, but I know what type it ought to have, writing the type signature first tends to be a very useful first step.
14:51:39 <edlinde> i see
14:51:48 <edlinde> ok
14:51:59 <Cale> edlinde: At the end, in the form of documentation, it's also a very good idea to include type signatures for everything.
14:52:03 <Cale> (at the top level)
14:52:38 <edlinde> what do you mean by “top level” ? :)
14:52:48 <Cale> I mean not inside of a 'where' or 'let'
14:52:56 <edlinde> ok
14:53:02 <Cale> Things at the outermost scope of a module
14:53:02 <edlinde> yeah that would look ugly
14:53:09 <edlinde> ok get you
14:53:24 <Cale> Sometimes you will also want to add type signatures inside let or where, but yeah, exercise taste :)
14:53:40 <cbarrett> IIRC the motivation for doing this (other than style) is that there are also situations in which the type checker will have trouble infering the type of functions to be as general as you might like.
14:53:43 <Cale> Sometimes you can go through and flesh out a whole library's type signatures before writing any of the code, filling in the definitions with undefined, and then looking at how the library might be used in a type-checkable way.
14:53:53 <cbarrett> But I can't recall the specific situations.
14:55:22 <Cale> Other times, it's easier to leave the type signatures out until later. Occasionally they end up being longer and more cumbersome than the code you wanted to write. So it's good that there are options. :)
14:56:07 <trap_exit> Cale: that looks so simple it shouldn't have its own name
14:56:16 <edlinde> Haskell is so cool :)
14:56:19 <edlinde> I did it a while back
14:56:35 <edlinde> and now I have bit of a gap … but coming back to it.. I just remember how much fun it was when I was doing it
14:56:36 <trap_exit> Cale: it's like "if you can fold on 'a'; we can transform it into a fold on 'b'"
14:56:52 <edlinde> its a pleasure to code in Haskell… too bad I never got the chance to continue using it
14:56:56 <Cale> trap_exit: It seems like something that might be worth naming to me
14:57:10 <Cale> trap_exit: We give fancy names to much simpler things after all ;)
14:57:38 <edlinde> do you guys manage to use haskell for pretty much anything these days?
14:57:50 <tabemann_> you can always code on your own in Haskell, even if you cannot do it for work or school
14:57:52 <trap_exit> Cale: Transducer is a cool sounding, tuturistic name
14:57:56 <trap_exit> I'd expect it to do something crazy
14:57:57 <edlinde> like connecting to dbs, writing web servers?
14:58:02 <zcd> i use haskell to order my burgers
14:58:12 <edlinde> zcd: I am sure you do :)
14:58:14 <zcd> so yes pretty much everything
14:58:20 <Cale> edlinde: Yeah, my last couple jobs have been in Haskell, and the one I'm about to start is as well.
14:58:42 <edlinde> I was using Erlang recently for some distributed code I had to write.. so still in touch with the FP stuff
14:58:51 <trap_exit> zcd: is this via grubhub, spoonroket, or which API ?
14:58:56 <edlinde> Cale: yeah but you are like a haskell guru :)
14:59:14 <Cale> Most of the stuff I've been working on personally has consisted of messing around with Coq and Agda
14:59:17 <trap_exit> edlinde: you must hereby burn your Erlang passport or forever be banned from #haskell
14:59:21 <zcd> spoonrocket has an api?
14:59:39 <zcd> also ever since the price change to $8 it has never been the same :(
14:59:46 <trap_exit> zcd: I dunno, I'm asking how your're ordering hambugers via API
14:59:50 <trap_exit> zcd: what was it used ot be priced at?
15:00:49 <edlinde> is there a difference between [Char] and String?
15:01:11 <edlinde> or they just synonymous to one another?
15:01:18 <dmj`> edlinde: synonyms
15:01:21 <geekosaur> String is a type alias
15:01:24 <zcd> trap_exit: was $6 when it first started
15:01:26 <geekosaur> it's identical to [Char]
15:01:26 <edlinde> ah ok
15:01:30 * tabemann_ wants to play around with dependently-typed languages, but finds himself unable to wrap his brain around things as simple as the type signature of (.)
15:02:03 <dmj`> edlinde: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-String.html
15:02:53 <zcd> tabemann_: takes two functions and returns a third?
15:03:01 <edlinde> is this good to read along with LYAH? —> http://dev.stephendiehl.com/hask/#basics
15:03:21 <edlinde> and http://www.haskell.org/haskellwiki/Typeclassopedia
15:03:39 <edlinde> I am just trying to quickly refresh all the haskell stuff
15:03:55 <tabemann_> zcd: in, say, agda many functions such as (.) take extra implicit arguments
15:04:28 <cbarrett> trap_exit: re: transducers, it would probably like this: (a -> b -> a) -> (c -> b -> c), but I'm not super clear on the concept
15:04:43 <bennofs> edlinde: those are both very good, alrhough the first contains some pretty advanced stuff IMO
15:04:57 <trap_exit> cbarrett: no, the reddit post said (x -> a -> x) -> (x -> b -> x)
15:05:07 <dmj`> edlinde: the typeclassopedia cannot be recommended highly enough, it is a *great* resource. Make sure to read the "applicative programming with effects" paper
15:05:12 <dreams> Is there any implementation of the "Spineless Tagless G-machine" that I could look at?
15:05:13 <zcd> tabemann_: as a filthy casual, i don't even know what agda is
15:05:20 <prophile> tabemann_: if you imagine the explicit quantifiers on (.) it's forall a. forall b. forall c. (b -> c) -> (a -> b) -> (a -> c)
15:05:22 <cbarrett> trap_exit: OK
15:05:34 <merijn> dreams: Not really, the GHC implementation has evolved quite a bit since then
15:05:46 <edlinde> bennofs: I think I will manage to get up to applicatives real fast… since I done this stuff in the past… but I never really read Monads
15:05:53 <merijn> dreams: Although I think the STG paper includes a lot of C-like explanation on how to implement an STG
15:05:53 <prophile> and in dependent types, forall a. b turns into \a -> b
15:05:58 <edlinde> so need to get the hang of that
15:06:09 <edlinde> someone here pointed that link out for Monads
15:06:22 <prophile> so (.) takes a type a, a type b, a type c, a function from b to c, and a function from a to b
15:06:28 <prophile> (and gives you a function from a to c)
15:06:41 <edlinde> is LYAH still a good resource to refresh all the basics?
15:06:54 <edlinde> Cale: what do you say?
15:06:55 <merijn> edlinde: Depends on how basic and how much refreshing? :)
15:07:00 <dreams> merijn: yeah but its hard to implement it by just reading high level description.
15:07:12 <edlinde> merijn: true
15:07:14 <Cale> edlinde: Yeah, I don't know of anything better for the time being
15:07:21 <merijn> dreams: Which STG paper did you read? There's multiple I think, the journal is really long (like 72 pages)
15:07:25 <edlinde> cool then its still relevant
15:07:44 <edlinde> I remember reading LYAH earlier and I was able to code all the assignments and stuff
15:07:53 <edlinde> so it was quite useful
15:07:58 <dreams> merijn: "Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine"
15:08:03 <tabemann_> okay, I'm gonna head out now
15:08:16 <merijn> dreams: The now, I don't think there's a much more in-depth one :)
15:08:23 <merijn> err
15:08:28 <merijn> s/The now/Then no
15:08:51 <dreams> merijn: by the way, I found this: https://github.com/tcsavage/lazy-compiler
15:09:15 <dreams> merijn: but i think its based on an older paper.
15:09:32 <merijn> dreams: I mean, there's probably more detailed stuff, but you've reached the point where you will have to dive into the GHC wiki and papers describing variations, etc. on the STG
15:10:09 <merijn> The people on the GHC dev list may be able to provide you more pointers
15:10:37 <dreams> merijn: I tried, GHC is a complicated box. Hard to get into.
15:10:42 <merijn> I know :)
15:11:28 <dreams> merijn: by the way when you said "GHC implementation has evolved", did you mean its not using the same implementation in that paper?
15:12:00 <merijn> dreams: I'm (unfortunately!) not aware of any communities for language implementers where you can hang out and get help (well, there's a few, but they're all rather naive "oh, look at me implement a variation of coffee script" kind and not anything more challenging)
15:12:08 <edlinde> *Main> :t min   min :: Ord a => a -> a -> a
15:12:13 <edlinde> whats Ord ?
15:12:20 <dreams> merijn: heh.
15:12:32 <edlinde> I understand that its a function taking two args and returning one arg of the same type
15:12:33 <merijn> dreams: If I knew of one, I'd be hanging out there ;)
15:12:37 <geekosaur> edlinde, indicates types which support ordering
15:12:39 <edlinde> but didn’t get the Ord a
15:12:55 <geekosaur> (not all do; complex numbers, for example, cannot be mathematically ordered)
15:13:18 <edlinde> so does this mean that the min function is ordering internally?
15:13:19 <merijn> dreams: Your best best is probably hanging around and trying to ask the people working on "proper" languages for details (i.e. ghc devs, people working on idris, there's other people developing serious languags here too)
15:13:23 <edlinde> as in it must sort or something?
15:13:40 <edlinde> just trying to understand the concept
15:13:53 <geekosaur> edlinde, sorting is not required. some concept of ordering is required
15:13:55 <merijn> dreams: GHC started out with the STG description, but things have been optimised, tweaked, etc. since then
15:14:20 <edlinde> geekosaur: is the sorting associated with the type variable “a” or with the function “min"?
15:14:30 <geekosaur> so you can say 3 < 4, but you can't say whether 3+4i is less than or greater than 4+3i, although you can certainly say they are not equal
15:14:32 <merijn> dreams: I got recommended (but haven't read yet) "Making a Fast Curry: Push/Enter vs Eval/Apply for Higher Order Languages" as a follow up to STG
15:15:12 <dreams> merijn: yeah, I guess I'll try that. Well, there is an accessible tutorial on the G-machine implementation, maybe I should start with that one first.
15:15:23 <edlinde> geekosaur: so its associated to the type variable?
15:15:29 <dreams> merijn: thanks, I'll read it.
15:15:30 <geekosaur> edlinde, with `min`. it must do a comparison; to do a comparison, it must know how to compare values, and that ability comes from `Ord`
15:15:36 <merijn> dreams: oh, I just remembered
15:15:46 <geekosaur> min :: Ord a => a -> a -> a
15:16:03 <edlinde> right so what I meant to ask was that if the type is not one that supports Ord .. then min won’t work yeah?
15:16:04 <geekosaur> given some type a which has an Ord instance so that comparisons can be done, return the smaller of the two parameters
15:16:10 <geekosaur> yes
15:16:18 <edlinde> ok get you
15:16:38 <geekosaur> nd you will get an error at compile time saying it can't find an Ord instance
15:16:47 <merijn> dreams: If you're interested in the type aspect too, at OPLSS we did an implementation of dependently typed LC, I think the source for that is online, although that's not nearly as low-level machine compilation-y as STG
15:17:57 <dreams> merijn: sure.
15:18:07 <merijn> dreams: https://github.com/sweirich/pi-forall
15:18:18 <merijn> Anyhoo, I gotta run
15:18:41 <dreams> thanks.
15:24:16 <numberten> merijn: i just realized you were italy from our oplss diplomacy game
15:24:32 <numberten> i knew your nick was familiar from something
15:25:29 * hackagebot MFlow 0.4.5.8 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.8 (AlbertoCorona)
15:32:09 <mindflay3r> Hi. I'm searching for a way to dynamically compile and use pure haskell code from untrusted sources. As far as I've seen, there's 1) the 'hint' package, 2) the older 'plugins' and 3) the GHC API itself. What are advantages/disadvabtages of those options?
15:33:06 <hpc> hint is almost certainly going to be using the ghc api
15:33:15 <hpc> so going 3 would likely end up reimplementing hint
15:33:20 <mindflay3r> Security is most important for me, but efficiency is also. I'd like to be able to use the 'Safe Haskell' restrictions on the code.
15:34:11 <vanila> mindflay3r, wouldn't you be better writing an interpreter that specifically enforces your security requirements on code execution?
15:34:32 <vanila> mindflay4r, wouldn't you be better writing an interpreter that specifically enforces your security requirements on code execution?
15:35:54 <mindflay3r> vanila: You mean, a custom DSL instead of 'normal' haskell code, which is then customly interpreted?
15:36:34 <mindflay3r> I'd rather use the full haskell syntax for the plugin code.
15:37:42 <schell> are type operators polymorphic?
15:37:58 <hpc> type operators?
15:38:34 <ezyang_> you can define type operators which are kind-polymorphic, yes
15:38:35 <schell> i don’t know if i asked that correctly
15:38:45 <mindflay3r> hpc: And what about 'plugins'? It's older, but I couldn't find anything on why the hint developers didn't like it.
15:39:26 <schell> ezyang_: i’ve got a type, SField Projection, where type Projection = “projection” ::: M44 GLfloat
15:39:32 <geekosaur> back when hint was developed, plugins read interface files directly (and therefore broke with every ghc upgrade)
15:39:35 <hpc> mindflay3r: not sure; might have to do with things you can't enforce via types, like resource exhaustion, timing out evaluation, tight loops with no allocation, etc
15:39:39 <hpc> oh, or that
15:40:00 <schell> then i have a function that is expecting an SField (n:::t)
15:40:21 <geekosaur> and ghc didn't have much support for loading and unloading stuff. ghc's interface is richer now and plugins is less necessary
15:40:58 <monochrom> in fact, during the first few versions of plugins, GHC API did not exist.
15:40:59 <schell> i would think that (broken down) SField Projection == SField (“projection” ::: M44 GLfloat) == SField (n:::t) where n = “projection” and t = M44 GLfloat, but i’m getting a kind error
15:41:34 <schell> “Couldn't match kind ‘GHC.TypeLits.Symbol’ with ‘*’ Expected type: SField (n0 ::: M44 GLfloat) Actual type: SField Projection”
15:41:58 <ezyang_> sounds like the kind error is elsewhere
15:42:59 <schell> i’m using a function setUniform :: SField (n:::t) -> t -> SetUniformCommand ()
15:43:06 <hakujin1> does GHC support hot code loading during program execution?
15:43:24 <mindflay3r> monochrom: Interesting ;)
15:43:37 <schell> ezyang_: full source -> http://lpaste.net/110271
15:43:51 <schell> and the error is on line 32
15:44:53 <mindflay3r> Thanks for your answers, thanks to the logs I could read them despite my bad connectivity.
15:45:05 <schell> i probably don’t understand (:::)
15:46:27 <ezyang_> that must be a type operator
15:46:48 <trap_exit> the answer to this is amost certaily no,
15:46:48 <schell> ezyang_: yes, but it seems it’s not kind-polymorphic?
15:46:50 <trap_exit> but I want to see if there's a way to do this
15:47:00 <trap_exit> I want to _pattern_ match on haskell data structures
15:47:25 <ezyang_> Not familiar with the library, so I couldn't say
15:47:26 <trap_exit> so for nested haskell datatypes, can we do something like "regex or CFG" ... but over the data types?
15:47:33 <ezyang_> If you can, load it up in GHCi and ask for info about it
15:47:58 <schell> ezyang_: unfortunately the docs aren’t too much help (http://hackage.haskell.org/package/vinyl-0.4.3/docs/Data-Vinyl-Universe-Field.html#t::::)
15:49:54 <ezyang_> oh, well, that's very simple
15:50:05 <ezyang_> if it's data, then its kind is something -> something -> *
15:50:51 <ezyang_> it appears to be (:::) :: k -> * -> *
15:51:41 <schell> so the k isn’t…polymorphic?
15:52:02 <jonsterling> I do not remember why the k is there instead of just Symbol
15:52:18 <schell> hey jonsterling
15:52:20 <jonsterling> (There may or may not be a good reason)
15:52:23 <jonsterling> Hey schell!
15:52:53 <ezyang_> sure, but it may be constrained to something else at that point
15:53:06 <jonsterling> It gets constrainted to Symbol, it would appear, in the SField type
15:53:13 <schell> jonsterling: i’ve gotten closer with that thing i sent the other night, but now i’m having this problem
15:53:48 <jonsterling> To be honest, the whole Field universe is kind of only there to appease the people who needed the old-style behavior. I don't use it myself, and it is possible that it is a little wacky... I'd help in more detail, but I need to go to the airport very soon!
15:54:32 <schell> well nice to hear from you, i’ll try a couple other ideas
15:55:32 * hackagebot hopenpgp-tools 0.8.2 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.8.2 (ClintAdams)
15:55:34 * hackagebot process-listlike 0.8 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.8 (DavidFox)
16:14:17 <RedNifre> Hm, IO is a bit confusing. I'm using scotty, which can send json like this: main do; get "/bla" $ json $ SomeData;     but how can I send IO(Maybe SomeData) ?
16:14:57 <roboguy_> RedNifre: if you're using do notation, you need to use <- to get at the Maybe SomeData
16:15:05 <joneshf-laptop> can you curry a case expression?
16:15:19 <joneshf-laptop> or does everything have to be fully applied
16:15:47 <RedNifre> So <- is like unwrapping? I guess this only works inside an IO monad? I mean, I guess I can't unwrap in pure code, right?
16:16:06 <roboguy_> RedNifre: it works with any monad. most monads are pure
16:16:22 <roboguy_> IO is one of the few exceptions
16:18:41 <Cale> RedNifre: A value of type IO t is nothing like a value of type t
16:18:48 <RedNifre> Hm, seems to be a different IO: Couldn't match type `IO' with `Web.Scotty.Internal.Types.ActionT T.Text IO'
16:18:53 <roboguy_> RedNifre: also, it's more like running than unwrapping
16:19:02 <Cale> RedNifre: Instead, it's a description of some action which could be taken to produce a value of type t at the end.
16:19:28 <Cale> RedNifre: when you write v <- x where x :: IO t, inside of a do-block, it means "execute the action x, and call its result v".
16:19:35 <Cale> v :: t then
16:20:13 <Cale> RedNifre: Does that make sense?
16:20:41 <Cale> For example, getLine :: IO String isn't really anything like a String, it's a representation for the action of getting a line of text from the user at the terminal.
16:21:11 <RedNifre> So inside IO I can "run" other IO, which results in something that looks unwrapped, which is fine, since it's still contained in the outer IO?
16:21:15 <Cale> and when you write v <- getLine, it means "execute the action getLine (i.e. get a line of text from the user), and call the resulting String v"
16:21:32 <Cale> You shouldn't think of it as wrapping
16:21:39 <Cale> /bin/ls isn't a wrapper for a list of files
16:21:50 <Cale> it's a program which when you run it constructs a list of files
16:22:11 <Cale> Apart from that, yeah
16:22:24 <RedNifre> Okay, but what does Couldn't match type `IO' with `Web.Scotty.Internal.Types.ActionT T.Text IO' mean then?
16:23:06 <Cale> It probably means that you tried to use an IO action as an action of this other monad
16:23:59 <Cale> Without knowing much about scotty, I'd be willing to bet that ActionT Text IO is an instance of MonadIO though, so you should be able to apply liftIO to some value of type IO t to get an action of type ActionT Text IO t
16:24:35 <RedNifre> The scotty code looks like this and fails at the <- part :  get "/price" $ do; mTicker <- getTicker ; json $ mTicker
16:24:54 <roboguy_> RedNifre: I think you need to use the scotty function
16:25:04 <Cale> What are the types of get and getTicker?
16:25:12 <RedNifre> Okay, so I need to figure out how to lift IO into that special scotty get function monad thing
16:25:21 <RedNifre> getTicker results in IO(Maybe Ticker)
16:25:23 <roboguy_> like in this tutorial http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
16:25:28 <Cale> okay
16:25:31 <Cale> RedNifre: and get?
16:26:05 <RedNifre> I'm not sure about the type of get, that's the thing from the scotty example. How do I find out? Is there a better way than reading the github code?
16:26:31 <Cale> http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty.html#v:get
16:26:44 <Cale> okay, so apparently it wants an ActionM () as its argument
16:27:03 <Cale> Try this:
16:27:05 <roboguy_> RedNifre: I suspect if you stick a "scotty portNumberHere $ ..." right before your do to convert it to IO, it will work
16:27:11 <Cale> get "/price" $ do; mTicker <- liftIO getTicker ; json $ mTicker
16:27:27 <Cale> er, also get rid of that superfluous semicolon...
16:27:33 <Cale> get "/price" $ do mTicker <- liftIO getTicker ; json $ mTicker
16:28:17 <Cale> roboguy_: We know that getTicker is inappropriate there, because it's an IO action, and get takes an ActionM () as its second argument, according to the docs.
16:28:28 <RedNifre> roboguy_ nah, scotty portnumber is the outer thing and runs the whole server on that port.
16:28:32 <roboguy_> Cale: oh, right
16:29:07 <Cale> RedNifre: So, you should be able to use  liftIO  to turn an IO action into an ActionM action.
16:29:18 <RedNifre> Cale, can you explain what exactly your code does? I mean, I guess it deals with the IO, but I don't see anything about ActionM.
16:29:27 <RedNifre> ah
16:30:06 <RedNifre> Is it worth explaining ActionM, or should I read some more chapters of Beginning Haskell before asking a thousand questions? :)
16:30:12 <Cale> liftIO in general will turn IO actions into various other types of actions for monads built on top of IO
16:31:02 <Cale> RedNifre: Well, I don't know *exactly* what ActionM is myself, it's something defined by scotty. Looking at the documentation here: http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Internal-Types.html#t:ActionT
16:31:30 <Cale> It appears to be a monad designed for handling various errors and state related to Scotty.
16:32:59 <RedNifre> Ah, I thought that it might be a Haskell thing. Okay then.
16:33:19 <assia_t> n
16:33:20 <schell> Cale,RedNifre: yeah as far as I know it’s the “response” monad
16:33:33 <RedNifre> That fixed the problem, everything works now. Phew.
16:33:51 <schell> after your app has dealt with routing the request, the ActionM builds the response
16:34:40 <Cale> I'm not entirely sure why it's necessary, it's probably not entirely necessary. Transforming IO rarely is.
16:35:07 <Cale> You could probably have a type of functions producing IO actions in place of it.
16:36:18 <RedNifre> So... I can't do IO in pure code, but I can pass pure code to various IO monads and there are different IO monads, but I can sort of ... convert between them to make them compatible? I'm confused.
16:36:43 <Cale> RedNifre: There are two separate but interleaved processes which take place as a Haskell program runs
16:37:19 <Cale> There's evaluation, which means reducing expressions to values for the purposes of pattern matching. This is "pure", it's referentially transparent: evaluating the same expression will always result in the same value.
16:37:59 <Cale> Then there's execution, which means carrying out the steps described by IO actions. This is not pure, executing the same IO action many times can result in different outcomes each time.
16:38:09 <vanila> @src mapM
16:38:09 <lambdabot> mapM f as = sequence (map f as)
16:39:39 <Cale> RedNifre: IO actions can involve subexpressions that have nothing to do with IO, for example,  do v <- getLine; print (reverse v)
16:40:27 <Cale> reverse :: [a] -> [a] here needn't know or care that the string it gets came from doing I/O, or that its result is about to be printed to the screen
16:41:57 <zwer> or even that the list it is reversing are a bunch of IO actions
16:42:06 <Cale> RedNifre: Functions can be used to manipulate IO actions in various ways -- evaluating a function never (apart from some low-level hooks that don't occur in ordinary Haskell code) results in IO actions being executed.
16:42:20 <Cale> zwer: The list it's reversing is not a bunch of IO actions in this case
16:42:26 <Cale> It's a bunch of characters.
16:42:40 <Cale> But sure, we could form a list of IO actions and then reverse it
16:43:13 <Cale> e.g.  reverse [print n | n <- [1..10]]  will give us a list of IO actions
16:43:48 <Cale> we could then apply sequence to that list to glue them together into a single action which (when executed) would execute each in turn
16:44:40 <Cale> RedNifre: Following?
16:45:22 <RedNifre> What confuses me is this: Suppose I have an IO(String), so it's not really a String yet. Now, if I want to reverse the not yet String I can run reverse inside by lifting it, right?
16:45:48 <Cale> RedNifre: Well, you can write  do v <- myIOString; return (reverse v)
16:46:11 <Cale> Or you can use fmap/liftM which are effectively the same thing
16:46:13 <RedNifre> Yeah, but you have to do return to put it back into the IO, sort of.
16:46:21 <Cale> liftM f x = do v <- x; return (f v)
16:46:32 <merijn> RedNifre: Right, so if "IO String" is "an IO action that will produce a String" then "andThen :: IO a -> (a -> IO b) -> IO b" is a functio that takes "an IO action that will produce an 'a' and a function that uses an 'a' to produce an action that will produce a 'b' and returns an action that will return a 'b'"
16:46:34 <geekosaur> RedNifre, you can think of it as: you have a program which when run would produce a String. you are attaching an addiitonal chunk of program to that
16:46:41 <Cale> return v is an IO action which does nothing, but which has v as its result
16:46:59 <Cale> and the result of a do-block is the result of the last action in it
16:47:06 <RedNifre> Yes, that I understand. What I don't understand is what happened in the scotty case. It looks like you somehow pulled the Data out of the IO.
16:47:06 <merijn> RedNifre: If your familiar with callbacks/promises you could consider this kinda/maybe sorta similar
16:47:37 <merijn> Which scotty case? I missed the start :)
16:47:43 <Cale> RedNifre: We used liftIO to turn the IO action into an ActionM action, and then we executed the ActionM action, capturing its result.
16:48:08 <Cale> do mTicker <- liftIO getTicker ; ...
16:48:31 <Cale> Here, getTicker :: IO (Maybe Ticker)
16:48:43 <Cale> and liftIO getTicker :: ActionM (Maybe Ticker)
16:48:51 <Cale> and so mTicker :: Maybe Ticker
16:48:59 <jle`> remember that we dont actually "extract" the result.  what happens is that every IO action sequenced has a "result".  by using <-, we get to name the result for *reference* in future sequenced actions
16:49:05 <HeladoDeBrownie> I'm playing with this as a learning exercise: For a list with length encoded in type, is it possible to write a function that (if it type checks) obtains the element at a given index of that list without fail? I've tried and failed to figure out what type such a function would have.
16:49:16 <Cale> because mTicker is the result of executing the action liftIO getTicker
16:49:25 <merijn> HeladoDeBrownie: Yes, although doing this in haskell is kinda ugly
16:49:31 <dreams> merijn: http://www.haskell.org/haskellwiki/Ministg
16:50:02 <RedNifre> Is it because you only need one return to make sure it's still IO and given that you used liftIO inside that scotty ActionM which might sort of have an implied return at the end somewhere... hm... hmhmhm.
16:50:05 <HeladoDeBrownie> merijn, what type would it have?
16:50:05 <Cale> which in turn will be the result of executing getTicker on its own, because that's what liftIO is meant to do, produce actions of a more structured monad which have the same result as executing some IO action
16:50:16 <merijn> HeladoDeBrownie: It does require using {-# LANGUAGE KitchenSink #-} :)
16:50:31 <HeladoDeBrownie> merijn, I have various extensions enabled already, I don't mind using them.
16:50:31 <merijn> HeladoDeBrownie: Lemme see, I think I had an example gist on github
16:50:37 <Cale> RedNifre: I'm not sure what you mean there by "make sure it's still IO"
16:50:42 <merijn> dreams: Thanks, I'll have a look
16:50:57 <Cale> RedNifre: This is sort of a complicated example for a beginner though
16:51:18 <Cale> RedNifre: (though I guess it's pretty simple as far as uses of liftIO go)
16:51:19 <merijn> Yeah, I figure a good first step would be to understand a simple transformer like StateT
16:52:16 <roboguy_> HeladoDeBrownie: maybe something like: at :: proxy (n :: Nat) -> proxy (m >= n) -> Vec m a -> a
16:52:25 <jle`> StateT is a great transformer to begin with.  maybe even start with StateIO ( a s -> IO (a, s) )...a "fixed" transformer transforming IO ... and then generalizing to s -> m (a, s)
16:52:31 <RedNifre> Yeah, I think the problem was my impatience. "Beginning Haskell" got a bit dry so I decided to implement something without understanding all the basics of Haskell. That was fun, but I guess it makes more sense to learn a bit more before I proceed.
16:52:36 <Cale> RedNifre: So, in general, there can be many different libraries which define some type of "computations with results of type t", say "M t"
16:52:41 <jle`> MaybeT is simple too but it might be too simple to gain much from
16:52:49 <jle`> Beginning Haskell has had some detractors, i think...
16:53:02 <HeladoDeBrownie> roboguy_, I was looking for something like that (>=), does it exist somewhere in ghc or base?
16:53:11 <Cale> RedNifre: and often such a library will have some way to take a value of type t, and produce a computation which "does nothing" but produces the given value as its result
16:53:30 <merijn> HeladoDeBrownie: I'll hack together a simple example
16:53:38 <HeladoDeBrownie> merijn, I'd appreciate it.
16:53:38 <Cale> RedNifre: e.g. in a parsing library, you might have a parser which eats none of the input, but succeeds in parsing with the given result
16:53:44 <roboguy_> HeladoDeBrownie: not that I'm aware of. Nat does though
16:53:56 <roboguy_> HeladoDeBrownie: it wouldn't be too hard to make a type family to do it
16:53:57 <Cale> RedNifre: that's what 'return' is, in general
16:54:03 <HeladoDeBrownie> roboguy_, yep, I'm already using that and I figured I'd need a Proxy (n :: Nat), but couldn't get much past that.
16:54:15 <roboguy_> HeladoDeBrownie: hmm, well what do you have so far?
16:54:33 <Cale> RedNifre: in addition to that, you often have some way to take a computation whose result has type a, and a function from possible results of type a, to further computations whose results have type b
16:54:49 <roboguy_> a Proxy type only has one value, so you don't have to worry about it too much at the value levle
16:54:52 <roboguy_> *level
16:54:54 <HeladoDeBrownie> roboguy_, the Vec implementation itself as well as this most likely incorrect type for the indexing function: Proxy (i :: Nat) -> Vec n a -> a
16:55:12 <roboguy_> HeladoDeBrownie: hmm, maybe you should paste it on the paste site
16:55:17 <Cale> RedNifre: and glue those together in the obvious way, giving a computation which will run the first action to get a result of type a, then apply the function to determine what to do next, and carry that out as well, producing its result as the overall result of the computation
16:55:36 <Cale> That's what (>>=) :: (Monad m) => m a -> (a -> m b) -> m b  means, in general
16:55:51 <Cale> RedNifre: Monad is just an interface to libraries which define operations like these
16:55:59 <roboguy_> HeladoDeBrownie: you will probably need an additional proxy argument witnessing i <= n
16:56:02 <rod_> Hi everybody , beginner question ; Is it possible to mix A computation in the List Monad with the Eval monad to spped up things .... ??
16:56:41 <HeladoDeBrownie> roboguy_, http://lpaste.net/110273
16:57:16 <Cale> RedNifre: Now, a fair amount of the time (perhaps more often than should really be the case), the monad defined by some library will be built up somehow in terms of IO, and there will be a canonical way to take IO actions and turn them into computations of this more specific type.
16:57:31 <Cale> RedNifre: that's what liftIO is for
16:57:38 <Cale> :t liftIO
16:57:40 <lambdabot> MonadIO m => IO a -> m a
16:57:41 <roboguy_> HeladoDeBrownie: yeah, I think you'll need to implement >= yourself as a type family
16:58:07 <HeladoDeBrownie> roboguy_, I've never defined a type family before, what should I read on that?
16:58:11 <roboguy_> luckily, the syntax for type families is very similar to the syntax for value level functions
16:58:15 <Cale> rod_: I'm not sure what you mean. A computation in the list monad is just a list.
16:58:18 <jle`> just thinking out loud, i'm not sure if "built on top of" is a meaningful or helpful concept when talking about liftIO
16:58:25 <roboguy_> HeladoDeBrownie: well, it's essentially just a function at the type level. let's see...
16:58:31 <RedNifre> :src liftIO
16:58:41 <Cale> rod_: It is possible to parallelise the evaluation of the elements of a list.
16:58:47 <RedNifre> @src liftIO
16:58:47 <lambdabot> Source not found. I feel much better now.
16:58:52 <roboguy_> HeladoDeBrownie: there's a couple examples here http://www.haskell.org/haskellwiki/GHC/Type_families#Closed_family_simplification
16:58:54 <Cale> RedNifre: liftIO will be defined separately for each library
16:59:03 <roboguy_> (closed type families are best when possible, I think)
16:59:16 <Cale> RedNifre: Its implementation depends on exactly how the new monad was defined in terms of IO
16:59:17 <HeladoDeBrownie> roboguy_, thanks.
16:59:32 <Tuplanolla> Eval from Control.Parallel.Strategies, Cale?
16:59:49 <merijn> HeladoDeBrownie: https://gist.github.com/merijn/39dc86e345e87276c523
16:59:53 <RedNifre> Makes sense.
17:00:18 <merijn> Although I haven't tested it beyond lack of warnings :p
17:00:38 <HeladoDeBrownie> merijn, it looks like my thinking wasn't too far off; is LessThanEq or equivalent not defined anywhere standard? That's the main thing I was missing, the definition of that.
17:00:46 <Cale> jle`: Well, it's a meaningful concept when talking about most definitions?
17:01:01 <jle`> a MonadIO is a monad that can represent, among other things, (arbitrary) IO computations.  And if you have any IO a, you can transform it into MyMonadIO a, which is an object that represents the exact same computation that the IO a represented
17:01:17 <CapitalSigma> hey all
17:01:22 <jle`> MyMonadIO doesn't have to be "built on top of" IO
17:01:32 <jle`> it just needs to be able to represent and sequence arbitrary IO actions
17:01:33 <Cale> jle`: We say that one thing Y is built on top of another X, or in terms of another X, if the definition of X makes use of Y.
17:01:34 <merijn> HeladoDeBrownie: There is a comparison for Nat (the lifted natural type), but the solver Nat is kinda sucky
17:01:44 <rod_> Cale : its an optimizer code which generates almost all possible solutions using guards tu prune the tree, wonder if i could parallelize the search to split the searchspace to more cpeu cores ....
17:01:57 <HeladoDeBrownie> merijn, I've heard there'll be improvements for type-level nats in the next GHC, is that something that's getting serviced?
17:01:58 <merijn> HeladoDeBrownie: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html
17:01:59 <RedNifre> Ah, I guess one of the monad laws is that you can't pull out the content directly?
17:02:00 <Cale> er, derp
17:02:04 <CapitalSigma> if i have some experience writing functional code (Standard ML), what should i read to start learning haskell?
17:02:11 <merijn> HeladoDeBrownie: Yeah, improving the solver is one of the goals, yes
17:02:25 <Cale> jle`: We say that one thing Y is built on top of another X, or in terms of another X, if the definition of Y makes use of X, or the definition of Y makes use of something built on top of X. :)
17:02:47 <merijn> CapitalSigma: The Gentle Intro might be up your alley, not sure how up to date it is
17:02:51 <Cale> rod_: You could.
17:03:16 <HeladoDeBrownie> merijn, roboguy_, thanks for your help, I believe what you've shown me will help me get the rest of it.
17:03:20 <roboguy_> RedNifre: it's not a law, it's just not possible with the monad methods
17:03:22 <CapitalSigma> merijn: thanks
17:03:26 <merijn> HeladoDeBrownie: Hmm, I seem to have made at least one error, since I get non-exhaustive pattern, I think there's an off by one
17:03:28 <roboguy_> RedNifre: because of the types
17:03:43 <roboguy_> HeladoDeBrownie: no problem
17:04:06 <jle`> Cale: ah, so you don't mean built on top of in the sense of implementation or monad transformers
17:04:10 <merijn> CapitalSigma: It's usually not recommended as it's not actually very gentle, but I think it was a decent crash course in syntax and peculiarities? Maybe someone else knows something better, though
17:04:12 <roboguy_> RedNifre: in fact, with some instances of Monad, you *can* pull stuff out directly. not with the Monad interface though
17:04:20 <Cale> jle`: Just mean in terms of definition dependency
17:04:25 <roboguy_> the simplest Monad, Identity, is an example
17:04:33 <CapitalSigma> merijn: that's good to know, i was a little put off by the name
17:04:33 <merijn> Or Maybe, or List or Either :)
17:04:40 <merijn> @quote gentle.intro
17:04:41 <lambdabot> haskruby says: A Gentle introduction to Haskell is as gentle as Mike Tyson
17:04:50 <merijn> @quote piranha.pits
17:04:50 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
17:04:58 <merijn> CapitalSigma: If that's any indication ;)
17:05:35 <geekosaur> it's gentle enough if you've some experience behind you :p
17:05:57 <CapitalSigma> merijn: the intro explicitly recommends you've got experience in an 'almost functional language like ML', so i feel like i'm in good company
17:06:00 <rod_> Cale, i was not sure if it would work , cause the solutions seem to not be independent using also State to pick elements from for each list step which reduces the remaining objects
17:07:02 <RedNifre> So, if I read a String out of a file I get an IO String and I might use various liftIO to turn that IO String into Whatever String, but I won't be able to transform it into a regular String, since nobody is allowed/can implement a function that does this?
17:07:31 <geekosaur> RedNifre, there is no String there
17:07:40 <avaritia> hey i've started reading okasaki and i've got a retarded question not exactly connoted with haskell , can i ask it?
17:07:50 <Tuplanolla> You can turn it into IO Whatever, RedNifre.
17:08:05 <Cale> avaritia: Yeah, shouldn't be a problem :)
17:08:35 <Cale> RedNifre: The *action* of reading a string out of a file will have type IO String, but when you actually carry out that action, you'll get a String
17:08:38 <geekosaur> there is a "program". you cannot cause that program to run, except by making it (part of) the value of `main`.
17:08:38 <rod_> RedNifre: You can use the resulting IO String in another IO Computation from where you can pass it to a pure function as String
17:08:58 <Cale> :t readFile
17:09:01 <lambdabot> FilePath -> IO String
17:09:01 <jle`> RedNifre: yes, there is no string that exists.  but if you sequence it, you can name the result and reference it in a later sequence IO action
17:09:03 <avaritia> Cale: i'm in the Amortization and Persistence via Lazy Evaluation chapyer and i'm reading about amortizing the queue with bankers method, am i correct with saying that i can grow the amortized O(1) towards infinity ?
17:09:09 <geekosaur> you can add additional program fragments to that program, and as long as they make their way back to `main`, that program will eventually be run
17:09:23 <Cale> If we write  do secrets <- readFile "/etc/passwd"; ...
17:09:29 <Cale> then secrets :: String
17:10:23 <merijn> HeladoDeBrownie: Right I changed the gist to use LessThan instead of LessThanEq and then it's correct (i.e. wrong index gives type error)
17:11:23 <linman32> hi. i have a type mismatch error. `(IO t0, b0)' is not 'IO (EventBox, Image)`
17:11:27 <linman32> how can i fix that?
17:11:27 <linman32> http://lpaste.net/110275
17:11:48 <avaritia> Cale: i guess my question was too stupid eh
17:12:06 <roboguy_> linman32: fst expects a pair but you are giving it an IO value
17:12:08 <jle`> linman32: you gotta have strength :)
17:12:10 <Cale> avaritia: I don't know the answer off the top of my head
17:12:11 <jle`> ;)
17:12:15 <jle`> sorry, it was a bad pun
17:12:20 <Cale> avaritia: It's been years since I read Okasaki's book
17:13:06 <linman32> roboguy, jle`: i am giving an IO pair, right?
17:13:07 <Cale> avaritia: However, it's probably true that the amortised costs can grow without bound
17:13:10 <jle`> :t \(iot0, b0) -> do { t0 <- iot0; return (t0, b0) }
17:13:11 <lambdabot> Monad m => (m t, t1) -> m (t, t1)
17:13:12 <roboguy_> linman32: basically, you have a function (a, b) -> b and you want a function IO (a, b) -> IO b. there's a certain lifting function that can transform the function in that way
17:13:15 <avaritia> Cale: k thx
17:13:19 <roboguy_> :t fmap
17:13:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:13:24 <roboguy_> in this case, f is IO
17:13:42 <jle`> is strength given in any commonly used libraries?
17:13:43 <avaritia> Cale: anyways why people find amortized costs usefull when they perform in such unstable way?
17:13:51 <jle`> s/given/defined
17:13:54 <roboguy_> jle`: it's in lens
17:14:02 <roboguy_> (naturally, haha)
17:14:04 <Cale> avaritia: If your only concern is the total running time of the program, then it's a reasonable way to work.
17:14:05 <jle`> heh
17:14:23 <edwardk> > _2 id (1,[2,3])
17:14:24 <lambdabot>  [(1,2),(1,3)]
17:14:29 <linman32> jle`: what do you mean i gotta have strength?
17:14:35 <jle`> ( linman32: the joke was that this function is commonly called `strength` )
17:14:48 <linman32> roboguy_: your saying b/c it is an IO monad?
17:14:48 <roboguy_> jle`: well, that isn't quite what's needed here actually
17:14:51 <Cale> avaritia: It's only once you care about running times for little pieces of the program, e.g. latency in a streaming application, that you need a more precise way of accounting for the costs.
17:15:07 <roboguy_> linman32: actually, because it's an IO value and IO is a Functor so we can use fmap
17:15:15 <avaritia> Cale: true, but what if its 10 * 2^100 :< , thank you for the answer
17:15:31 <jle`> ah, i should have looked in the paste :)
17:15:34 <jle`> my bad
17:15:37 <roboguy_> the monad part doesn't come into play for that part of the code
17:15:49 <Cale> avaritia: Well, asymptotic complexity also doesn't care about constants
17:16:15 <Cale> avaritia: That's just how it is, you only care about the rate of growth of complexity, and only for large-enough input sizes.
17:16:43 <roboguy_> jle`: I think strength is sequenceAOf in lens, btw
17:17:07 <Cale> avaritia: This can sometimes be extremely impractical, to the extent that the most practical algorithms for solving a problem are exponential, while the polynomial time ones are almost never used.
17:17:19 <Cale> (sometimes, not all the time)
17:17:25 <roboguy_> well, maybe
17:17:59 <linman32> roboguy_: haha. ok. i'm new to haskell.. so use fmap?
17:18:25 <Cale> avaritia: To really be practical, you'll want to measure the real amount of time and space that your program is spending by profiling and using tools like criterion.
17:18:26 <linman32> roboguy_: i don't know what a functor is
17:18:36 <roboguy_> linman32: yeah. if we take f to be IO (which it is in this particular case, but not necessarily in general), fmap's type is fmap :: (a -> b) -> IO a -> IO b
17:18:54 <roboguy_> linman32: oh, you should learn about functors before monads. but you might need to worry about either too much right now
17:19:17 <roboguy_> we just need to use fmap as though it has the type "fmap :: (a -> b) -> IO a -> IO b" for now
17:19:58 <Cale> avaritia: But despite the fact that if you really look at the definition of big-O notation, the asymptotic complexities are practically meaningless if you don't know the constants, it's still often a useful theoretical tool for comparison of algorithms.
17:20:39 <linman32> roboguy_: thanks. that seems weird, but i'll take your word for it now. haha
17:21:27 <roboguy_> linman32: it makes more sense when you the more you use it. It will also make more sense when you run into more instances of Functor
17:21:30 <linman32> roboguy_: (c programming background)
17:21:33 <avaritia> Cale: true , thanks for the detailed answer :)
17:22:02 <roboguy_> linman32: actually me too, originally (well, C++). Haskell is definitely different
17:30:35 <edwardk> jle`: sequenceAOf l = l id, hence _2 id above
17:30:43 * hackagebot Gamgine 0.4 - Some kind of game library or set of utilities.  http://hackage.haskell.org/package/Gamgine-0.4 (DanielTrstenjak)
17:31:10 <jle`> edwardk: yeah, it just became clear to me :)
17:34:10 <rod_> Cale, would you look at my code ?
17:34:33 <rod_> http://lpaste.net/4808553841668653056
17:35:44 * hackagebot debian 3.83.4 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.4 (DavidFox)
17:45:44 <vanila> how do I fix this?  unix-compat-0.4.1.3 failed during the final install step. The exception was:
17:45:45 * hackagebot layers-game 0.4.2 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.4.2 (DanielTrstenjak)
17:45:50 <vanila> /tmp/pkgConf-unix-compat-0.4.110261.3: hGetContents: invalid argument
17:48:02 <ski> rod_ : that `split' is sometimes called `select' (except that you didn't preserve the ordering. possibly that doesn't matter in your case)
17:51:40 <ski>   fahrerkenntbezirk (fah,dat) bez = or [b == bez | (b,q) <- dat]
17:53:18 <ski>   fahrerkenntbezirk (fah,dat) bez = elem bez (map fst dat)
17:54:29 <ski>   bezfahquo (fah,dat) bez = (bez,fah,case lookup bez dat of Just q -> q; Nothing -> 0.0)
17:54:46 <augur> yo ski!
17:55:02 <ski>   bezfahquo (fah,dat) bez = (bez,fah,fromMaybe 1.1 (lookup bez dat))
17:55:05 <ski> augur : lo
17:55:15 <ski> er, s/1.1/0.0/
17:55:58 <ski>   do ...
17:56:02 <ski>      guard $ fahrerkenntbezirk r x
17:56:14 <ski>      let s = bezfahquo r x
17:56:20 <ski>      ...
17:56:28 <ski> can be replaced by
17:56:31 <ski>   do ...
17:58:01 <ski>      q <- lift (maybeToList (lookup x (snd r)))
17:58:24 <ski>      let s = (x,fst r,q)
17:58:26 <ski>      ...
17:58:56 <ski> oh, if we repace the initial `r <- pick' by `(fah,dat) <- pick' we can say instead
17:59:04 <ski>   do (fah,dat) <- pick
17:59:15 <ski>      q <- lift (maybeToList (lookup x dat))
17:59:26 <ski>      let s = (x,fah,q)
17:59:33 <ski>      return (s:acc)
17:59:42 <ski> you may want to rename `x' to bez'
17:59:46 <ski> rod_ ^
18:00:17 <rod_> ski : thanks for all your proposals ...
18:01:02 <ski> rod_ : instead of accumulating in `compileBez', and finally reversing, i'd try the direct approach, and compare the performance
18:01:37 <rod_> my main concern however was to find out if i could use the Eval Monad in this routine to speed up things , my second core is having pizza ....
18:01:47 <ski> rod_ : how i wanted to define `split'/`select' can exemplify what i mean :
18:02:01 <ski>   select :: [a] -> [] (a,[a])
18:02:14 <ski>   select [     ] = []
18:02:49 <ski>   select (a0:as0) = (a0,as0) : [(a1,a0:as1) | (a1,as1) <- select as0]
18:04:06 <ski> (for (a recursive) `compileBez' (that would take a list of `x's, instead of just one), you'd use `do'-notation instead of list comprehension, otherwise it's the same idea about avoiding accumulators)
18:04:39 <qrada_> i'm reading source from the 'courier' package.. and i think my mind has just been blown
18:05:15 <ski> rod_ : i have no idea how `Fahrer',`Bezirk',`Quote',`konfigurationHeute' are defined
18:05:36 <ski> (or `DbFahrer' for that matter)
18:06:09 <qrada_> they declare this Transport data type.. data Transport = Transport { ... handle :: Name -> IO Bool } ... then they have various transports, TCP/UDP/MEmory which do say.. return Transport { handle = tcpHandles transport } .. which is defined as tcpHandles :: SocketTransport -> Name -. IO Bool
18:06:24 <ski> rod_ : i don't see any direct opportunity for `Eval' here .. there might still be some
18:06:37 <qrada_> so now they are able to just pass around a 'Transport' type.. instead of something constrained to another type
18:06:40 <qrada_> pskfaspofkas
18:07:04 <qrada_> ie instead of Transport a.. it's just Transport
18:07:09 <c_wraith> qrada_: isn't that just the standard way of handling "object oriented" haskell?
18:07:11 <ski> rod_ : however, avoiding the accumulation and tail-recursion may perhaps make the code more incremental, which might perhaps improve efficiency
18:07:25 <c_wraith> qrada_: records of functions are powerful.
18:07:43 <qrada_> c_wraith: don't know.. i've been trying to find a nice elegant way to express these 'abstract interfaces' im creating for counters/queues/etc
18:07:53 <qrada_> and all of my stuff is.. Blah a .. with this, i could have Bla
18:08:30 <qrada_> ie, I have a Counter a type, which becomes say, Counter MVar, Counter IORef, Counter Redis... but now after finally having this realization I can probably achieve what I initially wanted.. simply.. Counter
18:08:48 <qrada_> (preface: im a nub)
18:11:53 <qrada_> ok going to go test this out with my project.. so happy ;f ;] 8|
18:12:36 <rod_> ski: i need the accumulation , the accumulation is my result list , the q which is set to 0 was first calculated inside the list monad, i factored it out and do the computation in parallel afterwards
18:14:08 <ski> @let select :: MonadPlus m => [a] -> m (a,[a]); select [    ] = mzero; select (a:as) = return (a,as) `mplus` liftM (fmap (a :)) (select as)
18:14:11 <lambdabot>  Defined.
18:14:19 <ski> > select "abcd"
18:14:20 <lambdabot>  No instance for (GHC.Show.Show
18:14:20 <lambdabot>                     (m0 (GHC.Types.Char, [GHC.Types.Char])))
18:14:20 <lambdabot>    arising from a use of ‘M442919640868773510024570.show_M4429196408687735100...
18:14:20 <lambdabot>  The type variable ‘m0’ is ambiguous
18:14:20 <lambdabot>  Note: there are several potential instances:
18:14:30 <ski> > select "abcd"  :: [(Char,String)]
18:14:32 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
18:15:18 <ski> rod_ : note how this `select' doesn't use an accumulator, but still computes basically the same as your `split' (but keeping the ordering, instead of reversing the first half)
18:15:49 <ski> rod_ : so .. are you really sure you need the accumulator, or do you only need to compute the resulting list (in whatever order you prefer) ?
18:15:55 <jle`> > select "abcd" :: Maybe (Char, String)
18:15:56 <lambdabot>  Just ('a',"bcd")
18:16:45 <kvanb> containers in any programming language are just plain awkward
18:17:02 <ski> kvanb : hehe, what makes you say that ?
18:17:08 <kvanb> everything about them is wrong and sadly I think haskells are too
18:17:19 <kvanb> well, say you need to do two things which should be relatively cheap combined
18:17:23 <rod_> ski : i am not sure at all , your overwhelming me , right now :) have to check this
18:17:31 <kvanb> each with asymptotics of Ologn or something like that
18:17:39 <ski> qrada_ : anyway, that `Transport' thing is basically just OO (minus implementation inheritance parts)
18:17:57 <kvanb> There is no programming language I know of which has a standard container library capable of expressing something like
18:18:07 <kvanb> 'Lookup this, and while you're there, update this'
18:18:29 <qrada_> ski, is that an 'acceptable method' for achieving that type of abstraction
18:18:49 <ski> qrada_ : i'm not sure what "that type of abstraction" is, so it's hard to tell
18:19:02 <qrada_> o ok thnx
18:19:19 <kvanb> nobody must agree :\
18:19:35 <qrada_> the stuff i'm working on is similar... I'm going to try it out right now and see if everything fits
18:21:45 <ski> qrada_ : may i suggest looking at "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>, re OO (and also ADTs) ?
18:22:27 <ski> qrada_ : you may also want to check out the earlier "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
18:23:15 <ski> kvanb : hm, the problem sound vaguely zipper-like, or "combining folds"-like ..
18:23:36 <qrada_> thanks alot ski, checking now
18:23:40 <magicman> @type M.updateLookupWithKey
18:23:41 <lambdabot> Ord k => (k -> a -> Maybe a) -> k -> M.Map k a -> (Maybe a, M.Map k a)
18:23:46 <kvanb> I had a thought just then that maybe it's a thing that could be fixed with lens
18:25:53 <rod_> ski: ok , select should work , so i can eliminate the reversing of the result you mean , right ?
18:25:58 <ski> qrada_ : some parts of these papers may or may not be harder to grasp (depending on your current knowledge). you may still have some use of other parts
18:26:23 <ski> qrada_ : for some further information, you could check out TaPL, which mentions OO vs. ADTs in some chapters
18:26:28 <ski> @where TaPL
18:26:29 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
18:26:40 <ski> rod_ : yes
18:27:56 <schell> is it possible to constuct a function that given some parameters, returns a function of varying parameters?
18:28:24 <Makoryu> schell: What would the type of such a function be?
18:28:33 <schell> as in, f :: a -> (a -> a), f :: a -> b -> (a -> b -> c)
18:28:37 <qrada_> ski: ya, i'll give them a read and absorb something.. anything helps. I have this 'abstract library' idea i'm working on.. which isn't very abstract.. but it's more of a project for me to keep improving my haskell.. Implementing this technique I just learned should clean up quite a bit of code.. about to start implementing it
18:28:47 <schell> Makoryu: exactly, i’m not sure
18:29:33 <ski> schell : it's possible to do some tricks with type classes (see `printf')
18:29:43 <ski> in most cases i'd say it's not worth it
18:29:59 <schell> ski: thanks - maybe i’m being too general about it
18:30:06 <fresheyeball> hey folks
18:30:21 <fresheyeball> I have a super noob question
18:30:24 <schell> i’ve got an AST that i’d like to compile down to a function
18:30:30 <ski> schell : in general, such a thing would require dependent types (as in Agda,Coq,Idris,ATS,&c.)
18:30:55 <schell> and that function would take a number of parameters depending on how many times a certain operation was performed
18:30:59 <ski> schell : hm, perhaps your usecase fits GADTs ..
18:31:34 <fresheyeball> I am using scotty for the first time
18:31:43 <fresheyeball> and just want to recieve some post data
18:31:50 <fresheyeball> but can find zero documentation
18:32:30 <schell> ski: and possibly DataKinds, PolyKinds?
18:32:41 <ski> schell : as an example, i think it's possible to compile a representation of a pattern to something involving a function that takes as many arguments as there are "variables" in the pattern
18:32:52 <ski> (i don't remember details atm)
18:32:55 <schell> right!
18:33:01 <schell> that’s what i would like
18:33:26 <ski> schell : well, maybe `DataKinds' and `PolyKinds'. or maybe instead type/data families & associated types
18:33:33 <schell> it would have to be some kind of recursive structure i’m guessing
18:33:57 <augur> how do i use GHC to compile a static library that has some C code included (to export the functions for initing and exiting the RTS)?
18:35:00 <augur> er, not a static library, a dynamic library. or whatever it is i need to compile in order to make a black-box file
18:42:12 <rod_> ski: works only result is reversed , ~ 4 min for about 40000 solutions , i need 2 , i reverse in "instance Show Result" , not 40000 reversals , only 2 ;) thx
18:44:44 <fresheyeball> I am thrashing
18:44:46 <fresheyeball> please help
18:44:47 <fresheyeball> http://stackoverflow.com/questions/25588258/handling-post-with-scotty
19:02:42 <ryantrinkle> is there any way to "SPECIALIZE instance" an instance created with "deriving"?
19:13:40 <rod_> ryantrinkle,  if data FOO = blblbl deriving (Eq,Show) then deriving (Eq) instance Show FOO where show (f::FOO) = blalall ++ FOO blllll
19:15:15 <ryantrinkle> rod_: right; i'm just wondering if there's any way to use the SPECIALIZE pragma on that
19:15:31 <ryantrinkle> (without writing the implementation out by hand)
19:16:11 <rod_> ryantrinkle, cant help then , sorry
19:17:14 <eacameron> threadscope keeps getting "Killed" because of too much memory on my eventlog; can I prevent that somehow and just let the computer suffer?
19:17:47 <ryantrinkle> eacameron: you could set up a huge swapfile
19:17:52 <rod_> eacameron, same here ... eventlog 84 Mb and suffering
19:18:17 <ryantrinkle> oh, does it die before an OS-level out-of-memory?
19:18:51 <eacameron> ryantrinkle: I think the OS is doing it; unless GHC has an upper bound I don't know about
19:19:05 <ryantrinkle> eacameron: what OS are you running?
19:19:12 <eacameron> Linux mint
19:19:35 <ryantrinkle> https://wiki.archlinux.org/index.php/swap#Swap_file_creation
19:19:56 <ryantrinkle> you can use the instructions there to create additional swap without repartitioning
19:20:05 <ryantrinkle> (though it'll be even slower than a normal swap partition, lol)
19:21:12 <DanZimm> if I get a segfault in ghci is that possibly a bug?
19:21:18 <DanZimm> or is that expected at certain places?
19:21:26 <Makoryu> Uhh
19:21:29 <jle`> it's most likely a bug
19:21:32 <eacameron> haha...is that possible? ;) at least I'm on an SSD
19:21:34 <Makoryu> Yeah that's normally not supposed to happen
19:21:38 <coppro> probably a bug, unless you're using very weird extensions
19:21:39 <jle`> unless you are doing FFI stuff
19:21:45 <eacameron> DanZimm: Unless you're using a library that does crazy stuff
19:21:49 <Makoryu> Usually, though, the actual bug is in FFI land
19:22:04 <jle`> i've run into ghc bugs not involving ffi tho
19:22:07 <eacameron> DanZimm: Yeah, FFI
19:22:18 <coppro> you might be able to do it with undecideable instances
19:22:28 <jle`> ...or well, i couldn't pin it down to ffi
19:23:01 <DanZimm> I'm using Data.List
19:23:04 <eacameron> jle`: GHC has bugs? I thought Haskell typesystem prevented those...
19:23:05 <jle`> what version of GHC do you have?
19:23:09 <DanZimm> guessing that's not too crazy
19:23:25 <DanZimm> ghci is version 7.6.3
19:23:30 <eacameron> DanZimm: yeah...that should be safe
19:23:45 <DanZimm> unsure if I can repeat it, trying the same code
19:23:59 <DanZimm> also: I'm on OSX Yosemite
19:24:47 <DanZimm> ya doesn't look like its gunna seg fault again
19:25:00 <eacameron> rod_: did you just make a bigger swap as ryantrinkle suggested?
19:25:11 <DanZimm> > let (/\) :: Eq a => [a] -> [a] -> [a] ; (/\) a b = (a `union` b) \\ (a `intersect` b) ; take 10 $ [1..] /\ [1,3..]
19:25:13 <lambdabot>  <hint>:1:115:
19:25:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:25:54 <DanZimm> uh can anyone help me out here lol
19:26:01 <DanZimm> in ghci it works O.o
19:26:32 <eacameron> DanZimm: can you not use /\?
19:26:43 <DanZimm> apparently here I can't
19:26:46 <DanZimm> in ghci you can
19:27:29 <ryantrinkle> i don't think semicolons are allowed in lambdabot
19:27:37 <DanZimm> ah ok
19:27:46 <ryantrinkle> (not at top-level, anyway)
19:28:01 <eacameron> I thought you said it segfaults?
19:28:11 <Cale> Well, lambdabot expects a complete expression
19:28:33 <DanZimm> > let (/\) a b = (a `union` b) \\ (a `intersect` b) in take 10 $ [1..] /\ [1,3..]
19:28:34 <Cale> You can use @let to make semi-persistent bindings, and I think that will allow semicolons
19:28:38 <lambdabot>  mueval: ExitFailure 1
19:28:57 <DanZimm> never seen that one from him
19:29:39 <MorpheusBeing> He is an awesome bit of software!
19:30:18 <DanZimm> indeed, what does mueval mean?
19:30:33 <DanZimm> yea so looks like the segfault was a once in a lifetime thing lol
19:30:38 <DanZimm> just the right circumstances
19:31:31 <tabemann_> > let (/\) a b = (a `union` b) \\ (a `intersect` b) in take 10 $ [1..] /\ [1,3..]
19:31:33 <MorpheusBeing> ?all-dicts mueval
19:31:34 <lambdabot> No match for "mueval".
19:31:36 <lambdabot>  mueval: ExitFailure 1
19:32:47 <MorpheusBeing> https://hackage.haskell.org/package/mueval
19:33:20 <DanZimm> yea I see that
19:33:26 <DanZimm> secure haskell interpreter
19:34:47 <DanZimm> unfortunately I don't know haskell well enough to read the source to see where it's crashing
19:35:41 <tabemann_> the thing is that that little bit of code *shouldn't* crash like that
19:35:59 <DanZimm> probably
19:36:20 <DanZimm> I figured an operator like that woulda been in the stl even
19:36:24 <DanZimm> I guess not though
19:37:08 <tabemann_> STL? what does that mean aside from standard template library?
19:37:45 <DanZimm> oop wrong term I guess
19:37:55 <DanZimm> for some reason I thought it meant standard library
19:38:20 <tabemann_> yeah, STL is a C++ thing
19:39:17 <DanZimm> well good to know :D
19:39:38 <tabemann_> the only abbreviation I've seen for "standard library" is stdlib
19:39:51 <HeladoDeBrownie> DanZimm, one short term you can use for the Haskell standard libary is base.
19:39:58 <HeladoDeBrownie> "Is X in base?"
19:40:10 <DanZimm> ah ok cool, thanks!
19:40:33 <HeladoDeBrownie> Although I'm not sure if that refers to the Haskell standard library in general or more properly to GHC's.
19:40:41 <tabemann_> mind you there are a lot of things that are in the haskell platform that are not in base
19:40:44 <HeladoDeBrownie> GHC and Haskell tend to be taken as synonymous in more ways than they should. :P
19:41:19 * DanZimm thought GHC was just a tool whereas haskell was a language
19:41:30 <HeladoDeBrownie> DanZimm, that's correct, GHC is a compiler for the Haskell language.
19:41:43 <shachaf> The Glaswegian Shachaf Compiler certainly can't tell the Glaswegian Difference Compiler between them.
19:41:47 <HeladoDeBrownie> However, in practice, almost everybody uses GHC when programming in Haskell.
19:41:48 <DanZimm> yea, and then I was guessing part of the lang spec was to have certain functions etc
19:41:54 <DanZimm> e.g. Prelude
19:41:59 <Cale> DanZimm: But the language which GHC compiles, and the language Haskell-as-in-The-Report are two different things
19:42:05 <brycelane> I'm having trouble with QuickCheck and $quickCheckAll. I have a property, `prop_Foo i = False`, and it doesn't seem to be getting picked up
19:42:13 <ski> rod_ : yes, i know you only reverse at the end. the point was to make it more incremental
19:42:17 <ski> ryantrinkle,rod_ : btw, if you make an explicit `Show' (`Read') instance, please define `showsPrec' (`readsPrec') instead of `show' (`read'), for any non-trivial cases
19:42:20 <DanZimm> cale: oh really? interesting
19:42:26 <shachaf> brycelane: Perhaps it's the type?
19:42:33 <DanZimm> are the differences listed somewhere
19:42:40 <ryantrinkle> ski: i'm actually hoping to specialize instances for Monad
19:42:40 <tabemann_> some consider "Haskell" to mean the language in the report
19:42:41 <brycelane> shachaf, what is the appropriate type?
19:42:44 <Cale> DanZimm: Well, GHC has a lot of extensions
19:42:52 <Cale> DanZimm: which are documented in the GHC user's guide
19:42:58 <shachaf> brycelane: I don't know, what type did you write?
19:43:10 <brycelane> Int -> Bool
19:43:10 <Cale> DanZimm: Most projects choose to turn on one or more of these
19:43:19 <ryantrinkle> i've got an implementation of a MonadState that uses an IORef under the hood, but it's polymorphic in the reference type and underlying monad
19:43:21 <shachaf> Then that's probably fine.
19:43:34 <shachaf> Please post full actual code.
19:43:39 <ryantrinkle> unfortunately, this also seems to make it slower than just using IO directly
19:43:47 <ski> ryantrinkle : i don't know if a freestanding `SPECIALIZE' on every member of interest would DTRT ..
19:44:01 <DanZimm> cale: ah ok cool
19:44:14 <brycelane> shachaf, http://lpaste.net/110280
19:44:33 * DanZimm is finishing up the LYAH guide, took a week but I feel fairly well aquianted with the basics of haskell
19:44:50 <shachaf> brycelane: It fails when I run it.
19:45:00 <brycelane> shachaf, hum...
19:45:30 <shachaf> augustss is quite well-acquainted with the BASICs of Haskell.
19:45:59 <Cale> shachaf: tee hee
19:46:09 <ski> preflex: xseen augustss
19:46:09 <brycelane> shachaf, I'm attempting to run from cabal. My test-suite type is exitcode-stdio-1.0, is that right?
19:46:18 <shachaf> brycelane: I don't know much about cabal.
19:46:44 <brycelane> shachaf, what is the typical method of running tests?
19:46:55 <shachaf> ski: He was here a couple of days ago.
19:47:12 <Cale> DanZimm: Cool! It took me about a month before I felt like I could do useful stuff with Haskell, and about a year to really be comfortable, but that was over a decade ago.
19:47:13 <shachaf> brycelane: I don't know.
19:47:21 <shachaf> brycelane: Probably cabal?
19:47:38 <brycelane> shachaf, alright thanks.
19:48:11 <DanZimm> Cale: so you were around when Haskell was just being born?
19:48:22 <Cale> DanZimm: Not quite, but a few years after.
19:48:26 <DanZimm> ah fair
19:48:29 <Cale> I started around 2001-2002
19:48:42 <shachaf> That's at least a decade after, isn't it?
19:48:48 <DanZimm> oh jeeze
19:48:55 <Markz> where would I find the source for constructing record field accesors?
19:49:01 * DanZimm didn't realize 10 years ago is 2001-2002
19:49:05 <Cale> Yeah, Haskell 1.0 was 1990
19:50:12 <Cale> Still, I seem to recall being in this channel when there were fewer than 100 people here.
19:50:36 <Cale> So, from a social standpoint, the language was pretty embryonic :)
19:51:27 <shachaf> whoa, back when you had a lowercase c
19:55:08 <brycelane> cabal is running my quickcheck tests, but saying they all passed when they did not.
19:55:39 <shachaf> brycelane: Try using -v or strace or one of those tools to figure out what it's doing.
19:56:27 <brycelane> its something with the way they are run. It 'appears' to be returning exit code 0 to the command line which gets interpreted as success
20:04:24 <dfeuer> Is Cale here?
20:04:32 <Cale> hi
20:04:48 <dfeuer> Hi Cale. I feel like I'm stumbling around in the dark with higher order folds.
20:05:01 <dfeuer> I never know if I'm doing them righct.
20:05:05 <dfeuer> Do you have any tips?
20:05:20 <Cale> Well, what do you mean by 'higher-order' as opposed to just ordinary folds?
20:05:46 <dfeuer> For instance, I'm guessing that foldM f a xs = foldr (\x r a' -> f a x >>= r) return xs a      but I'm not sure.
20:05:59 <dfeuer> By higher-order folds, I mean folds that accumulate functions.
20:06:09 <Cale> ah, okay
20:07:34 <Cale> The main pointer I would give is that if you can't immediately see how to write something as a fold, to just write it recursively
20:07:41 <dfeuer> :D
20:07:57 <dfeuer> I do want to learn, you know....
20:08:14 <Cale> (and then to be very careful to see whether it's still readable once you rewrite it as one)
20:09:43 <dfeuer> Sometimes there are reasons to write things in ways that are less readable than one might like. But I do think readability is too often neglected.
20:09:49 <redtricy1le> hs
20:10:11 <Cale> One thing which I find troubling about your proposed foldr is that the a' variable goes unused
20:10:35 <trap_exit> so I have data Foo = ... 20 different constructors ... / then I have a file blah.hs, which is "instance SomeClass Foo where .... " and this file is > 200 lines, all part of this one gigantic "instance SomeClass" -- and emacs is slow to indent. Is this a known problem? i.e. when you have an "instance Class where ... " being over 200 lines, haskell / eamcs identation becomes slow
20:11:29 <shachaf> dfeuer: It gives me a warning (the same one Cale gave you).
20:11:42 <dfeuer> Huhhhhh
20:12:42 <dfeuer> Oh. So I guess that a is supposed to be a'. Oops.
20:12:57 <Cale> yes
20:13:03 <Cale> If you do that, then it's good
20:13:08 <shachaf> Yes.
20:13:44 <dfeuer> Cale, one pattern I'm seeing is that some folds seem to pass things right to left and left to right, in this sort of fashion. And it makes me wonder whether there is a way to make that more explicit/readable.
20:13:50 <shachaf> Well, it's correct, at any rate.
20:14:12 <dfeuer> To capture the pattern in a function without obfuscating it.
20:14:38 <dfeuer> shachaf, I will find out if it's good after a bunch of compiling.....
20:16:14 <dreams> lambda abstraction is a closure right?
20:16:35 <Cale> dreams: Lambda abstractions *may be implemented by* closures
20:17:01 <dfeuer> So the answer, roughly, is "sometimes".
20:17:24 <Cale> dreams: Closures are an implementation mechanism which consists of a pair of some code along with an "environment" which is a mapping from free variables of that code to values
20:18:03 <Cale> Once you lose the ability to separate that pair into its component parts, it's misleading to call the structure a "closure"
20:18:08 <der|> How can I make cabal install to display the build long instead of redirecting it to a file ?
20:18:17 <Cale> Closures are rarely if ever a language feature as such
20:18:20 <der|> ** log
20:18:24 <dfeuer> Lambda lifting is another way to do it, as I recall. And sometimes the optimizer will end up actually applying the thing at compile time.
20:18:28 <Cale> But they're very useful for implementing a variety of language features.
20:18:47 <Cale> (including functions)
20:19:04 <dfeuer> There are languages that let you dig into closures, as I recall, but that's generally a Bad Idea.
20:19:08 <dreams> Cale: I'm just trying to figure out why closure is used interchangeably with thunks in papers.
20:19:23 <Cale> Yeah, you can have graph reduction evaluators for functional languages that avoid using closures or thunks
20:19:31 <dfeuer> Thunks are like closures except they take no arguments.
20:19:43 <shachaf> It probably isn't used interchangeably.
20:19:43 <Cale> kinda
20:19:57 <shachaf> You can have one without the other.
20:20:05 <dreams> ah ok
20:20:09 <Cale> "Thunk" is a generic term for "whatever data structure is being used to implement unevaluated expressions at runtime"
20:20:21 <dfeuer> Yes, that.
20:20:22 <Cale> and in many cases, that will be a closure of some sort
20:20:33 <dreams> so each are implementation specific by they represent unevaluated expressions.
20:20:56 <dfeuer> Closures are semi-specific sorts of structures.
20:21:01 <Cale> Closure is more specific in terms of its structure than a thunk
20:21:10 <shachaf> I,I transitive closure
20:21:22 <Cale> in that it specifically implies the presence of this environment alongside the code
20:21:54 <dreams> a closure is just a function with a nested function isn't it?
20:21:59 <Cale> > foldr (\x xs a -> a : xs (a+x)) (\x -> [x]) [1,2,3,4,5] 0
20:22:01 <lambdabot>  [0,1,3,6,10,15]
20:22:02 <dreams> inner.
20:22:08 <Cale> dfeuer: ^^ something to meditate on :)
20:22:33 <Cale> dreams: Closures are not functions
20:22:53 <dfeuer> Closures can *represent* functions.
20:22:57 <Cale> dreams: A closure is a pair, whose first part is some representation for some code with "free variables" in it
20:23:16 <Cale> and whose second part is a mapping (of some sort) from those free variables to values
20:23:32 <Cale> I suppose you could consider that second part to be a function on a finite domain
20:23:52 <Cale> But it's more likely to be something like an array in practice
20:23:58 <dfeuer> Cale, from a functional programming perspective, the entire thing represents a function.
20:24:11 <Cale> dfeuer: The entire thing *might* be used to represent a function
20:24:22 <bitemyapp> is there a "humanize" or humanize bytes Haskell library?
20:24:29 <Cale> but once you get up to that level, it'd be wrong to call the thing a closure anymore
20:24:35 <Cale> because that's the wrong level of abstraction
20:24:40 <dfeuer> Yes.
20:25:07 <Cale> Just like it's probably wrong to refer to machine instructions as "circuits".
20:25:17 <dfeuer> But I think people who call the structures "closures" tend to be ones who interpret them as functions,
20:25:36 <dfeuer> whereas others might call them ... I dunno ... objects or something.
20:25:38 <Cale> There are a lot of people who abuse the term "closure" when they mean "function"
20:25:46 <Cale> But this is an abuse which I'd like to see less of
20:25:53 <dfeuer> Yes.
20:25:57 <dfeuer> That would be nice.
20:26:45 <dfeuer> The trouble is probably from people who know C or C++ or some similarly broken language that uses the name "function" to refer to a very limited sort of procedure.
20:26:57 <dreams> foo x y = (\z -> z + r) where r = x / y   <-- isn't that a closure?
20:27:03 <tabemann_> there are languages, e.g. groovy, where "closure" is used this way as part of their standard terminology...
20:27:03 <dfeuer> No.
20:27:48 <Sonderblade> i have a list of 2tuples like this: [(3, [-3,4,9,-2]), (77,[-9,0,4])] how would i return a new list with all negatives from the second element of each 2tuple filtered out?
20:27:54 <Cale> dreams: foo is a function which takes two arguments and produces another function.
20:28:06 <dfeuer> dreams, that is a definition in Haskell. The right hand side is a lambda abstraction with a where binding.
20:28:06 <shachaf> dreams: "closure" is an implementation detail. What you wrote is a Haskell definition.
20:28:14 <Cale> (or which takes three arguments and produces a fractional numeric value)
20:28:38 <Cale> dreams: Closures are not part of the specification of Haskell.
20:28:52 <HeladoDeBrownie> Sonderblade, map (fmap (filter (> 0)))
20:28:56 <dreams> hmm, that's strange, I guess Wikipedia definition of closure is wrong then.
20:29:10 <Cale> dreams: But functions are. How an implementation chooses to implement functions, whether by closures or some other representation, is up to the implementation.
20:29:26 <HeladoDeBrownie> Sonderblade, woops, >= not >
20:29:31 <HeladoDeBrownie> Err
20:29:38 <HeladoDeBrownie> No I've confused myself now :P
20:29:44 <HeladoDeBrownie> I should go to bed
20:29:44 <dreams> Ok thanks.
20:29:44 <shachaf> THe Wikipedia definition doesn't look that bad.
20:29:58 <Markz> where would I find the source for constructing record field accessors?
20:30:12 <shachaf> The source for what?
20:30:25 <Cale> The wikipedia definition isn't terrible, but its examples look questionable.
20:30:37 <HeladoDeBrownie> Sonderblade, want me to go into more detail on what that function actually does?
20:30:48 <Markz> http://pastebin.com/fcXTRgX9
20:31:10 <Markz> thats missing { } ofc, paste error
20:31:16 <shachaf> There is no Haskell source for them.
20:31:21 <Cale> dreams: What's probably confusing is that the article immediately jumps to an example of behaviour which closures can help to implement, but which by no means are *required* in order to implement.
20:31:27 <Markz> ?
20:31:28 <shachaf> first would look like first (Pair x _) = x
20:31:39 <Sonderblade> HeladoDeBrownie: fmap cheats :) it doesn't work if the list is the first element in the tuple
20:32:12 <HeladoDeBrownie> Sonderblade, well it wasn't :P But if you want that, well, another thing you could do is pattern match on the pair
20:32:18 <Cale> dreams: and it uses misleading names, like closure_1 = startAt(1) -- here the variable closure_1 isn't itself a closure, but some value which might be implemented internally by a closure.
20:32:31 <Markz> yeah, so where do I find example source for including this
20:32:36 <shachaf> over (mapped . _1) filter (>= 0)
20:32:46 <shachaf> The Haskell Report.
20:32:49 <HeladoDeBrownie> Or you could learn the lens package.
20:32:51 <HeladoDeBrownie> :P
20:32:54 <dreams> Cale: ah ok. This is why I got confused I guess.
20:33:04 <Markz> I've looked at lens, it doesn't help
20:33:07 <Cale> dreams: Probably the article's author was slightly confused too
20:33:14 <dreams> Cale: heh.
20:33:35 <Cale> dreams: As I mentioned, there are lots of people who abuse the terminology, which results in a lot of confusion about what it's really supposed to mean.
20:33:40 <Markz> wait, if that was
20:33:44 <HeladoDeBrownie> Markz, was talking to Sonderblade, to whom shachaf responded with a lens snippet.
20:33:47 <Markz> directed at me*
20:34:04 <MR5Y> I can't use the name I was using a few hours ago ;-;
20:34:38 <HeladoDeBrownie> MR5Y, register it next time, if possible
20:34:40 <dreams> Will keep that in mind.
20:35:30 <MR5Y> HeladoDeBrownie: Well, I quickly skimmed the user list and no one seems to be using it, so I'm clueless.
20:35:42 <HeladoDeBrownie> MR5Y, /whois that_nick
20:36:33 <Sonderblade> HeladoDeBrownie: im trying to learn "the general pattern" for unpacking/changing/repacking a list of tuples
20:36:49 <HeladoDeBrownie> Sonderblade, do you know about patterns?
20:36:50 <Sonderblade> HeladoDeBrownie: so fmap works in the specific case, but is not generalizable afaiui
20:36:50 <Markz> shachaf, at some point the compiler or w/e defines first for { ... first :: _ ... } I would like to look at the source for this
20:37:09 <shachaf> Markz: It doesn't generate Haskell code for it.
20:37:21 <Sonderblade> HeladoDeBrownie: pattern matching?
20:37:27 <MR5Y> HeladoDeBrownie: I am logged in as myself with that nickname somewhere else. What the..
20:37:30 <HeladoDeBrownie> Sonderblade, that's a thing you can do with patterns, yes.
20:37:31 <Markz> could you expand on that
20:37:43 <shachaf> What is there to expand?
20:38:25 <Markz> on how it does work?
20:38:44 <Sonderblade> HeladoDeBrownie: yes
20:39:07 <dreams> Were could one get help with operational semantics? is there a channel you'd recommend? (sorry if out of topic)
20:39:57 <HeladoDeBrownie> Sonderblade, okay, so unpack the tuple using pattern matching and use a function on one of the elements:
20:41:56 <MR5Y> Also, do you guys think is recommended I learn a second language alongside Haskell?
20:41:57 <Sonderblade> oh i get it: [((filter (>=0) a),b) | (a,b) <- [([-3,4,9,-2], 3), ([-9,0,4],99)]]
20:42:00 <HeladoDeBrownie> Woop sorry had to go afk for a moment
20:42:04 <HeladoDeBrownie> Anyway map (\(a, b) -> (filter (> 0) a, b)) would work
20:42:34 <HeladoDeBrownie> >= I mean, sorry, copied my previous line
20:44:08 <Markz> shachaf?
20:44:11 <HeladoDeBrownie> Sonderblade, a list comprehension could work, though they don't tend to be highly favored for one reason or another
20:44:30 <HeladoDeBrownie> My guess and the reason I don't use them as much is because they don't compose as well
20:45:50 <dfeuer> Cale, I'm kind of pondering your koan, but haven't gotten very far yet.
20:46:25 <dfeuer> MR5Y, you should learn multiple languages!
20:46:37 <dfeuer> A variety of different languages.
20:46:50 <Cale> dfeuer: Well, maybe an easier koan first:
20:46:58 <Cale> > foldr (:) [] [1,2,3,4,5]
20:47:00 <lambdabot>  [1,2,3,4,5]
20:47:04 <dfeuer> You should focus, at first, on *good* languages, but a few bad ones for brief periods can give perspective.
20:47:17 <MR5Y> defeuer: I'm currently reading LYAH. I'm thinking of taking another language to complement that.
20:47:25 <dfeuer> Cale, foldr (:) [] = id
20:47:30 <Cale> dfeuer: right
20:47:57 <MR5Y> dfeuer: I "tested" a number of languages before Haskell so...
20:48:02 <Cale> > foldr (\x xs -> x : xs) [] [1,2,3,4,5]
20:48:03 <lambdabot>  [1,2,3,4,5]
20:48:08 <dfeuer> MR5Y, you could give Scheme a whirl, if you want to see what a language with a really powerful macro language looks like.
20:48:20 <Cale> > foldr (\x xs a -> x : xs a) (const []) [1,2,3,4,5] 0
20:48:22 <lambdabot>  [1,2,3,4,5]
20:48:24 <dfeuer> You could try Standard ML if you want a fancy module system.
20:48:33 <Cale> > foldr (\x xs a -> (x,a) : xs a) (const []) [1,2,3,4,5] 0
20:48:34 <lambdabot>  [(1,0),(2,0),(3,0),(4,0),(5,0)]
20:48:38 <MR5Y> dfeuer: Does Racket count as "I tested Scheme?"
20:48:44 <Cale> > foldr (\x xs a -> (x,a) : xs (a+1)) (const []) [1,2,3,4,5] 0
20:48:45 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4)]
20:48:53 <Cale> > foldr (\x xs a -> (x,a) : xs (a+x)) (const []) [1,2,3,4,5] 0
20:48:55 <lambdabot>  [(1,0),(2,1),(3,3),(4,6),(5,10)]
20:48:59 <dfeuer> Depends what you were doing with it.  Cale, do you really think I can think that fast?
20:49:18 <Cale> dfeuer: I'm presenting the whole sequence for you to think about at your own pace :)
20:49:24 <Cale> > foldr (\x xs a -> (x,a) : xs (a+x)) (\x -> [x]) [1,2,3,4,5] 0
20:49:26 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ (t, t)
20:49:26 <lambdabot>  Relevant bindings include x :: t (bound at <interactive>:1:39)
20:49:28 <Cale> oops!
20:50:03 <Cale> right, we'd need a pair there :)
20:50:13 <Cale> > foldr (\x xs a -> (x,a) : xs (a+x)) (\x -> [(x,x)]) [1,2,3,4,5] 0
20:50:14 <lambdabot>  [(1,0),(2,1),(3,3),(4,6),(5,10),(15,15)]
20:50:26 <Cale> not very pretty if we want to stick with pairs
20:50:28 <haasn> :t scanl (+)
20:50:29 <lambdabot> Num a => a -> [a] -> [a]
20:50:35 <dfeuer> Cale, can you PM me or email me or something? This is all getting lost in noise.
20:50:38 <Cale> okay
20:50:41 <MR5Y> dfeuer: So far, I "tested" C#, C, Python 2.x, Python 3.x, Clojure, ClojureScript, Ruby, Rust, Racket, Java and JavaScript.
20:51:02 <Cale> Well, I guess I can do all this in ghci and then paste to PM
20:51:15 <trap_exit> MR5Y: you forgot erlang
20:51:24 <dfeuer> Cale, or I can even do it myself, as long as you haven't made mistakes.
20:51:32 <dfeuer> Or you can do it in a query with lambdabot.
20:51:41 <trap_exit> MR5Y: also, Ocaml
20:51:43 <dfeuer> [if you don't want to switch to ghci]
20:51:55 <MR5Y> trap_exit: If I started reading 7 languages in 7 weeks I would get there.
20:52:04 <dfeuer> MR5Y, when you "tested" Racket, did you study syntax-case?
20:52:23 <trap_exit> MR5Y: I found it impossible to appreciate the beauty of Haskell until I tried all other languages
20:52:42 <trap_exit> MR5Y: also, don't forget; Coq, Agda, Idris
20:52:49 <benzrf> trap_exit: u mean, like
20:52:58 <benzrf> u learned haskell, it seemed ok, then u went back, u realized what was imssing?
20:53:03 <bjz_> trap_exit: as a heavy user of Rust, <3 <3 Haskell's syntax :)
20:53:06 <dfeuer> trap_exit, I've been meaning to try some of those.
20:53:08 <MR5Y> defeur: I read their getting started thing and started reading a bit of the book they recommended(which was in Scheme).
20:53:10 <Gurkenglas> Aww, but I wanna read it too!
20:53:30 <MR5Y> trap_exit: I was recommended Haskell after I got stuff with Python and their infinite loops with lists.
20:53:31 <trap_exit> benzrf: no, 7 years ago, I tired learning Haskell, thought it was retarded ... tried all the other langauges, then realized Haskell is fucking beautiful and I was an idiot 7 years ago
20:53:44 <benzrf> trap_exit: can u not slur
20:54:01 <dfeuer> MR5Y, Lisp in general and Scheme most especially cannot be appreciated properly without studying their macro systems.
20:54:21 <trap_exit> benzrf; what do you mean by 'slur' ? I thought it refers to spoken langauge
20:54:29 <benzrf> 'retarded'
20:54:35 <trap_exit> i.e. slur = drunk spoken language
20:54:54 <Sonderblade> HeladoDeBrownie: that's a nice solution. i'm a little dismayed about the "syntactic overhead" though. if the tuple has 5-6 elements it gets bad
20:54:58 <MR5Y> dfeuer: I had a few tries on that with CLojureScript Koans. Then I got stuck and...the stock market...You know how that goes.
20:55:02 <dfeuer> The word "slur" can also be a noun meaning insult.
20:55:19 <benzrf> dfeuer: yeah but i used it as a verb
20:55:23 <benzrf> so the confusion is understandable
20:55:27 <HeladoDeBrownie> Sonderblade, using lens makes it look a little cleaner, albeit at the cost of an additional dependency; did you see shachaf's suggestion?
20:55:33 <kadoban> It's also a verb, that means a similar thing.
20:56:03 <trap_exit> I don't understand the problem with the word http://www.thesaurus.com/browse/retarded
20:56:16 <joelteon> Don't use it anyway.
20:56:24 <joelteon> If you want to continue using it, please leave.
20:57:11 <DanZimm> so is there a design reason why when someone puts a typeclass constraint on a type constructor it isn't assumed for all functions that use that type constructor?
20:58:01 <HeladoDeBrownie> DanZimm, could you show an example? What it sounds to me like you're describing wouldn't type check.
20:58:17 <DanZimm> like if you do `data (Ord a) => MyType a = ...` and then I have some function `doStuff :: (Ord a) => MyType a -> ...` why must we have the `(Ord a)` in the function declaration?
20:58:18 <HeladoDeBrownie> Or, I probably misunderstood really.
20:58:43 <joelteon> DanZimm: Putting constraints on datatypes is discouraged for exactly that reason.
20:58:45 <HeladoDeBrownie> Well, because if you didn't have it then the function would appear to be able to be given any a.
20:58:45 <DanZimm> like from a design perspective why didn't the haskell gurus make it so the context was assumed there?
20:58:52 <joelteon> It shouldn't be.
20:59:01 <Sonderblade> HeladoDeBrownie: i didn't but id rather go without extra dependencies
20:59:05 <DanZimm> yes I understand that, I'm asking why, from a design perspective, this is the case
20:59:11 <DanZimm> i.e. why shouldn't it be?
20:59:12 <joelteon> Someone who knows more about the type system can probably correct me, but I think the fact that data constructors can be given a context in the first place is a hack.
20:59:33 <HeladoDeBrownie> Sonderblade, okay, by all means look into lens then. And I'd consider it a good idea to at least check out anyway.
20:59:50 <joelteon> DanZimm, I think data Ord a => MyType a means that the constructors have an Ord constraint.
21:00:01 <joelteon> There's no reason functions that operate on that datatype should also have that constraint.
21:00:11 <DanZimm> for example if you have a type constructor which will /only/ take an Ord type as an arg (in every function that uses this), this might allow for some cleaner code
21:00:26 <joelteon> Unless of course they use the constructor, which they usually do. In that case, the function needs an Ord constraint anyway.
21:00:56 <joelteon> Ok, I'm getting out of my depth. Maybe someone else can explain better.
21:01:05 <DanZimm> joelteon: right, when they use the constructor they need the constraint, my question is, from a design perspective, why?
21:01:31 <DanZimm> it might be cleaner if /every/ function that uses that type constructor uses the constraint of (Ord a)
21:01:32 <HeladoDeBrownie> DanZimm, say you had a function :: MyType a -> String. This is implicitly: forall a. MyType a -> String. Nowhere indicated in that type is the necessity of an Ord a constraint.
21:02:08 <joelteon> Well, we've covered that. DanZimm's question is why not.
21:02:12 <DanZimm> heladodebrownie: yes, I understand that, but if you declare data (Ord a) => MyType a..., from a design perspective, why is that not assumed?
21:02:19 <HeladoDeBrownie> We want to be able to tell what a function accepts and returns *just* from its type (also expanding type synonyms), so we'd end up with a problem.
21:02:55 <trap_exit> joelteon, benzrf: so English is not my first langauge, I'm reading http://www.parents.com/blogs/to-the-max/2013/03/06/autism/5-things-people-dont-get-about-the-word-retard/ ... and I don't get it; is retard not == stupid, and if so, why is it offensive ?
21:02:58 <HeladoDeBrownie> (The problem is more general than functions, of course.)
21:03:29 <MR5Y> Someone here has experience with Haskell (or compiling it) under Arch Linux?
21:03:33 <Gurkenglas> trap_exit, I think this sort of thing should be discussed in #haskell-blah
21:03:39 <joelteon> MR5Y: what's the problem?
21:03:39 <DanZimm> heladodebrownie: sure, but couldn't the type be implied by the constraint on the constructor?
21:04:05 <DanZimm> for example if you tried to fetch the type of the function it could implicitly add the constraint on it
21:04:19 <HeladoDeBrownie> DanZimm, then you'd be hiding information in a way that makes it impossible to rely solely on the type of the function.
21:04:20 <DanZimm> but when actually declaring the function is really what I'm talking about
21:04:34 <MR5Y> joelton: To put it simply. How I put haskell-platform or the latest haskell-platform on it. The documentation is half written and the AUR package is missing the PKGBUILD thing.
21:04:43 <joelteon> just tab complete my name
21:05:10 <MR5Y> joelteon, To put it simply. How I put haskell-platform or the latest haskell-platform on it. The documentation is half written and the AUR package is missing the PKGBUILD thing.
21:05:11 <MR5Y> There.
21:05:16 <Gurkenglas> (Except the people of this channel would be more likely to ignore you if you comply...)
21:05:22 <DanZimm> heladodebrownie: I'm not saying change the actual type of the function, I'm talking about the declaration of the function, it might be cleaner, in some sense, if when declaring we're able to leave out the implied constraints on the type constructors
21:05:27 <joelteon> Sorry I'm not really familiar with how HP is included in AUR
21:05:30 <HeladoDeBrownie> DanZimm, there are ways you might be given a MyType a without also being given the Ord a constraint. If the constraint is implicit for that parameter, you've got no way to pass it in.
21:06:02 <HeladoDeBrownie> DanZimm, you're saying you want a *syntactic* shortcut where you omit the constraint in the function's type signature but its actual type includes it?
21:06:08 <MR5Y> joelteon, Apparently no one I could find is, since I've seen complaints about how Arch linux is not friendly to haskell-developers.
21:06:09 <DanZimm> yes
21:06:12 <joelteon> MR5Y, what are you hoping to accomplish in Haskell? are you planning to write packages, or just to learn it? It might be a better idea to install GHC yourself.
21:06:34 <HeladoDeBrownie> DanZimm, I would consider that highly likely to produce hard-to-read code.
21:06:53 <DanZimm> the actual type of the function would remain the same, (i.e. with the constraint Ord a) but when defining it would be less typing
21:06:54 <HeladoDeBrownie> DanZimm, you're asserting the type looks one way but you can't get the full picture without asking the compiler. That way lies madness.
21:06:56 <MR5Y> joelteon, Well, I'm currently learning it with LYAH. I just want to have Arch and the latest haskell on both my Windows and Linux installs.
21:07:46 <DanZimm> heladodebrownie: sure, in some sense I can see that, but if you have a type constructor that will only have functions defined on it with the constraint (Ord a) I feel as though that could be cleaner
21:07:52 <DanZimm> at least IMO that would be cleaner
21:08:01 <HeladoDeBrownie> DanZimm, essentially, as they are now, type signatures written by a programmer are *authoritate* unless they contradict what the compiler knows.
21:08:13 <DanZimm> gotcha ok
21:08:26 <HeladoDeBrownie> DanZimm, well, you actually very often have cases where you might want many functions to have the constraint, but not all. Look at the Data.Map module for examples.
21:08:45 <DanZimm> heladodebrownie: do you see my point though? Like I'm intersted in defining type constructors that REQUIRE certain constraints on the parameters, no matter what
21:08:53 <HeladoDeBrownie> DanZimm, I would call the cases where you want *every* function to have that constraint rare enough that it's not worth special-casing either the syntax or the type system for it.
21:08:55 <LazyHaskeller> Hi everyone.
21:09:02 <MR5Y> Hello
21:09:20 <DanZimm> heladodebrownie: fair, mainly a newb here still, just poking around at the lang still ;D
21:09:21 <LazyHaskeller> How long will it take to create a Microsoft Word equivalent in Haskell?
21:09:32 <HeladoDeBrownie> DanZimm, an alternative to your suggestion would be to use so-called "smart constructors", ways to obtain values of that type that aren't real constructors and may impose other limitations or checks.
21:10:09 <DanZimm> yea that's basically what I'm talking about
21:10:14 <HeladoDeBrownie> DanZimm, you can easily use a smart constructor to impose an Ord constraint without making every operation over your type require it.
21:10:25 <HeladoDeBrownie> If that's what you'd need, that's what I'd suggest doing.
21:10:55 <trap_exit> list monad = absolutely brlliant
21:11:05 <trap_exit> list monad = easy to do 'non-deterministic programming'
21:11:11 <trap_exit> where "make arbitrary choice of a, b, c" => [a, b, c]
21:11:38 <DanZimm> hrmmm that doesn't sound like what I'm talking about now (I have no clue what a smart constructor is) - I would want *every* operation using the type constructor to require the parameter to have Ord on ir implicitly
21:11:55 <DanZimm> (and ofc this is all theoretical, I have no real life situation atm, as I said, poking the language)
21:12:38 <HeladoDeBrownie> If you can come up with a case for that, by all means share it.
21:12:51 <DanZimm> I understand haskell and c++ aren't very comparable, but the type of dealio I'm thinking of is when you have templates with `int` parameters
21:13:15 <DanZimm> heladodebrownie: IMO it's still worth discussing even though there isn't a real life example at hand
21:13:16 <trap_exit> DanZimm: can you github gist the corresponding C++ code?
21:13:21 <DanZimm> sure
21:15:02 <HeladoDeBrownie> DanZimm, real code is a good way to anchor discussions like this one, especially as we can point out specific examples of what we're talking about.
21:15:23 <DanZimm> trap_exit: https://gist.github.com/danzimm/35f20959db52b76abba4
21:15:41 <HeladoDeBrownie> I agree that there are things that the very idea of can be interesting, but in this case I feel the case is too nebulous.
21:15:44 <DanZimm> heladodebrownie: sure, nonetheless dismissing the possibility seems unfair, let me come up with a concrete example
21:15:55 <DanZimm> (unfair to the code, not to a person)
21:16:06 <DanZimm> (yes I treat my code like a person)
21:16:17 <trap_exit> DanZimm: foo :: Int -> (Int -> Int) \n foo x = \y -> x +y
21:16:20 <trap_exit> DanZimm: next question
21:16:31 <HeladoDeBrownie> Don't get me wrong, I'm certainly willing to hear arguments for this sort of thing. However, I've heard many of them before and the counterarguments have struck me as more convincing.
21:16:41 <DanZimm> trap_exit: this is an example, not the summer up of all possible situation
21:16:41 <DanZimm> s
21:17:06 <DanZimm> I'm not talking about practically how one could do what I'm talking about, I'm talking about theoretically why isn't it the way I'm describing
21:17:25 <trap_exit> I don't understand your question.
21:17:31 <HeladoDeBrownie> You may be interested in reading up on Haskell's type system, I think.
21:17:33 <DanZimm> the best reasoning I've heard, which I respect, is about the fact that types are no longer opaque from the programmer
21:17:41 <HeladoDeBrownie> I can't point out specific examples, but that's essentially where your answer will lie.
21:17:45 <HeladoDeBrownie> s/examples/sources/
21:17:47 <MR5Y> What's the offtopic channel again?
21:17:51 <HeladoDeBrownie> #haskell-blah
21:17:56 <trap_exit> #ocaml
21:18:00 <DanZimm> ^lmao
21:18:02 <HeladoDeBrownie> ##cooking
21:18:13 <MR5Y> HeladoDeBrownie, thanks.
21:18:19 <HeladoDeBrownie> Well you do have to admit, Haskell is not on topic in #ocaml
21:18:34 <DanZimm> trap_exit: my question is why are constraints in type constructors not implicitly carried over to every function that use those type constructors
21:18:51 <MR5Y> trap_exit, I would have gone for #perl, but eh...
21:19:22 <DanZimm> I understand you /dont/ do it because it doesn't give you anything (you would need to add the constraint to every function that uses it anyhow) but I feel like that could be useful if you didn't have to add the constraint to every function
21:19:49 <DanZimm> moreover there is already situations where if you want the exact type you need to consult the compiler, i.e. if you decalre a function w/o a tyoe
21:20:09 <DanZimm> sure you can figure it out using documentation and the such, but if you want to know what the compiler is going to give you need to consult the compiler
21:20:30 <DanZimm> (my response to the above response to my question)
21:21:52 * DanZimm feels like he's annoyed everyone here
21:21:56 <DanZimm> sorry guys
21:21:58 <DanZimm> didn't mean to
21:22:07 <HeladoDeBrownie> DanZimm, you didn't strike me that way.
21:22:09 <MR5Y> The lag bar increased a little.
21:23:02 <HeladoDeBrownie> DanZimm, often explicit type signatures are used for the programmer's benefit, however there are actually cases where a type cannot be inferred, mostly when using GHC extensions, but it's not uncommon.
21:23:28 <DanZimm> nonetheless there are plenty of situations where they can be inferred
21:23:42 <HeladoDeBrownie> If I were to include type signatures, I would prefer that they accurately reflect the type as-is; I usually don't have to ask the compiler because the documentation tells me and the compiler confirms by telling me my code type checks.
21:24:34 <DanZimm> heladodebrownie: ok fair, seems to be coming down to a personal perspective type of dealio
21:24:40 <DanZimm> heladodebrownie: do you see my perspective at least?
21:25:04 <DanZimm> Also, ice cream of brownies?
21:25:11 <DanZimm> or from brownies?
21:25:13 <DanZimm> :P
21:25:30 <HeladoDeBrownie> DanZimm, I understand why you might not want to write out constraints all the time; there are ways around it, but I think you might be overly fixated on one particular solution.
21:25:36 <HeladoDeBrownie> DanZimm, it means "brownie ice cream".
21:25:55 * DanZimm has some pretty elementary spanish reading abilities :P
21:25:58 <Markz> shachaf, so if haskell doesn't generate the function what does it do?
21:26:10 <shachaf> What function?
21:26:21 <shachaf> Haskell is a language. It doesn't generate anything.
21:26:22 <DanZimm> heladodebrownie: I honestly have 0 situations in mind, just was going through the LYAH guide and was curious about it
21:26:29 <Markz> http://pastebin.com/fcXTRgX9, first
21:26:55 <shachaf> GHC generates the function, but that doesn't mean it generates Haskell code for it.
21:27:07 <Markz> so how does it work then?
21:27:30 <DanZimm> hrmmm heladodebrownie do you think everyone will have the same view point as you on this? (curious if I'm alone in this)
21:27:38 <HeladoDeBrownie> DanZimm, that's often the problem with something that sounds like a good idea; it's difficult to come up with uses for it. I'm not saying there are none, however as I said before, I don't think they justify the special casing that would be required.
21:27:43 <shachaf> I don't follow.
21:27:44 <HeladoDeBrownie> DanZimm, no, of course not. :)
21:28:05 <Markz> if it doesn't generate a function, what does it do shachaf
21:28:16 <shachaf> I just said it generates the function.
21:28:31 <Markz> in haskell(
21:28:33 <Markz> *
21:29:00 <geekosaur> if it generates it at all it's probably in Core, but in fact it's probably much lower level than that
21:29:32 <DanZimm> heladodebrownie: ok, again fair point. It's interesting because, in theory, you could implement it in a way that wouldn't disturb the already in place paradigms that people use
21:29:34 <geekosaur> since constructors are fairly "primitive" in terms of the compiler
21:29:42 <DanZimm> i.e. lack of constraint wouldn't change
21:29:50 <HeladoDeBrownie> DanZimm, I'm not saying Haskell doesn't make compromises for the sake of making things "nice"; however, it makes especially few compromises, especially when it comes to things that *sound* nice but limit the ability to reason about code, such as what you're suggesting, or, a more prominent example, the separation of side effects from evaluation.
21:30:18 <HeladoDeBrownie> DanZimm, I'm curious how you'd do so.
21:31:04 <HeladoDeBrownie> What I just said might have read wrong; I'm saying that the inclusion of side effects in evaluation may sound nice but it limits the ability to reason about evaluation.
21:31:39 <HeladoDeBrownie> (And of course "nice" is subjective; someone who's been with Haskell for a while knows well the benefits.)
21:31:51 <DanZimm> heladodebrownie: well, if theres a constraint on the type constructor implicitly add it to all functions that use that type constructor (if they aren't already there) otherwise if there aren't any constraints on the type constructor (which is the way of doing things now) keep everything the same as now
21:32:42 <HeladoDeBrownie> DanZimm, I hope this doesn't come across as condescending, but we might try revisiting this discussion after you've gained a firmer footing in Haskell, including the type system in particular.
21:32:43 <DanZimm> (again this is in theory, no idea how the backend actually works)
21:33:27 <DanZimm> heladodebrownie: nope not at all, many times in my life have a questioned things deeply that are everntually answered by a more advanced understanding of the subject ;D
21:33:37 <DanZimm> e.g. math
21:38:45 <augur> if i have a haskell library, and some C code that provides type signatures for the haskell library, as well as some minor auxiliary functions, what do i do with ghc to get the C stuff to compile into a self-contained library?
21:41:13 <augur> or cabal, since the library is a hierarchical thing and cabal seems to be the thing to use for those
21:41:54 <dfeuer> augur, C code provides type signatures for the Haskell library?
21:42:16 <augur> no
21:42:22 <augur> but yes
21:42:55 <augur> its a wrapper around the haskell code, and provides type signatures to other C code that's more refined than what the Haskell side provides
21:43:32 <dfeuer> More refined types on the C side than the Haskell side... that's a first.
21:44:06 <shachaf> C has all sorts of great type system features.
21:44:08 <shachaf> Like const.
21:44:49 <Hodapp> o_O
21:46:02 <joelteon> And *
21:46:42 <augur> dfeuer: the haskell side tends to render things opaque at the FFI
21:46:53 <augur> eg, things become Ptr () / void*
21:47:18 <dfeuer> Ah.
21:47:28 <augur> so i want to recover some of the distinctions, even tho for C they're not deeply enforceable
21:48:04 <augur> but, i also need to provide some C code that wraps hs_init and hs_exit
21:48:21 <augur> and i need to compile that, and make the whole thing into a single thing somehow
21:48:40 <augur> that i can import into a C project without having to do any fancy sort of GHC-based compilation
21:49:02 <augur> if i can compile the library with GHC, it should be usable by other compilers without them knowing anything about haskell
21:51:21 * hackagebot netwire-input 0.0.1 - Input handling abstractions for netwire  http://hackage.haskell.org/package/netwire-input-0.0.1 (Mokosha)
22:01:22 * hackagebot netwire-input-glfw 0.0.1 - GLFW instance of netwire-input  http://hackage.haskell.org/package/netwire-input-glfw-0.0.1 (Mokosha)
22:10:27 <ski> dfeuer : compare with "leaned so far right he came back left again!" at <http://www.willamette.edu/~fruehr/haskell/evolution.html>
22:10:59 <dfeuer> ski, that's ... a joke, but not so helpful, I don't think. Yes, I've seen it.
22:11:06 <dfeuer> I got a bit more out of the Haskell Wiki.
22:17:28 <ski> dfeuer : if you want to, you could think of functions as being defines by `data a -> b = forall env. Closure# (# env , (# env , a #) #-> b #)', where the type `X #-> Y' is a type of "top-level function" (like a C function, not depending on non-local arguments), corresponding to Lewis' strict implication/conditional `X ⥽ Y' <https://en.wikipedia.org/wiki/Strict_implication> ..
22:18:01 <ski> dfeuer : .. which also can be expresses conversely in terms of ordinary implication as `◻ (X → Y)', where the `◻' "nessecary" modality <https://en.wikipedia.org/wiki/Modal_logic> expresses that the value doesn't depend on "cotingent" assumptions/values (i.e. doesn't depend on local variables)
22:18:46 <dfeuer> ski, you're going a bit over my head...
22:18:48 <ski> (the `(# .. , .. #)'s are just unboxed pair types, you can read them as boxed pair types `(.. , ..)' instead, if you prefer)
22:19:47 <dfeuer> ski, you're going up into modal logic, which I've never studied.
22:20:05 <shachaf> ski: Hmm, you go back and forth between #-> and ->#
22:20:11 <dfeuer> Also, it's 1:18 AM here.
22:20:26 <ski> the idea being that if we're to represent a function of type `a -> b' as a closure, then that is a pair of a value of type type `env', representing the non-local (but not global) environment, together with a "top-level function" that takes this `env' as input in addition to `a', producing a `b'
22:20:37 <ski> shachaf : where ?
22:20:54 <shachaf> In past iterations of this syntax.
22:21:06 <ski> shachaf : oh. that may well be
22:21:40 <dfeuer> ski, that is a concept I've been familiar with for years. The modal logic is another story.
22:22:03 <augur> dfeuer: where is here?
22:22:04 <phaskell> No symbol 'here' found anywhere.
22:22:21 <augur> ..
22:22:21 <augur> what
22:22:24 <augur> where is here
22:22:25 <Markz> hah
22:22:28 <augur> where is here?
22:22:28 <phaskell> No symbol 'here' found anywhere.
22:22:31 <augur> o_O
22:22:39 <dfeuer> Perfect.
22:22:47 <DanZimm> so I think I answered my question
22:22:48 <DanZimm> kinda
22:22:52 <DanZimm> ;D
22:22:53 <shachaf> thoughtpolice: ☝
22:23:00 <dfeuer> augur, I'm in Maryland, near Washington D.C., in the U.S.A.
22:23:21 <augur> dfeuer: !!
22:23:22 <augur> me too!
22:23:39 <augur> also lets do this in -blah
22:25:26 <thoughtpolice> shachaf: sorry, I can fix that
22:30:35 <ski> dfeuer : basically, if you can prove `A' without any assumptions, you can then prove `[] A' (meaning "necessary `A'")
22:31:00 <ski> dfeuer : more generally, if you can prove `A', with *only* assumptions of the shape `[] B', then you can prove `[] A'
22:31:46 <ski> (this looks a bit like a comonadic extension operation `([] A -> B) -> ([] A -> [] B)')
22:32:32 <ski> dfeuer : think of values of type `[] A' as those values of type `A' which you can define on the top-level of the program, which can therefore only use other top-level definitions (of type `[] B', for various `B')
22:33:39 <ski> then, if you can prove `[] (A -> B)', then this means proving `A -> B' without any non-global assumptions, so it corresponds to defining a function from `A' to `B' on the top-level of the program, iow the `A #-> B' of above
22:34:49 <dfeuer> Er ... okay?
22:35:21 <shachaf> ski: That's a nice interpretation.
22:37:27 <augur> ski: thats the interpretation that i think pfenning uses? roughly?
22:37:41 <ski> augur : hm, maybe ?
22:37:57 * ski can't recall reading about what interpretation Pfenning uses
22:38:40 <augur> or at least i think he talks about it as something related to code quoting maybe? or something like that
22:38:59 <augur> i forget the terminology he uses for this. staging? i dont know
22:39:35 <ski> augur : hm. i think Nanevski has some paper about connecting modal logic to quotation and staging, at least
22:39:41 <augur> yes
22:39:43 <ski> s/paper/papers/
22:39:43 <augur> with pfenning :)
22:39:47 <ski> could be :)
22:40:10 <augur> they also have some papers on a version that captures context as well
22:40:16 <augur> instead of just []A you have [G]A
22:40:29 <ski> yes
22:40:32 <augur> with the rule    G !- A  ===>  D !- [G]A
22:40:49 <augur> jonsterling and i refered this in that paper, actually, ski
22:40:55 <augur> it turns out this is good for metavariables
22:41:06 <augur> [G]A is the type of a metavar!
22:41:07 <ski> the nice thing about this is that it can handle manipulating open code expressions, with free variables
22:41:17 <augur> also
22:41:19 <augur> http://www.cs.cmu.edu/~fp/publications.html
22:41:20 <augur> cmd-f modal
22:41:35 <ski> (as opposed to the typical `[] A' thing for staged computation / quoting, which can only handle closed code expressions)
22:42:07 <augur> yeah
22:42:17 <augur> http://www.cs.cmu.edu/~fp/papers/popl96.pdf
22:42:22 <augur> a modal analysis of staged computation
22:42:57 <augur> for [], not [G]
22:43:26 <augur> yeah, they talk about staged computation. thats it.
22:43:27 <ski> ok
22:49:48 <augur> is there a GHC channel?
22:51:00 <ski> yes, #ghc
22:51:36 <augur> aha, i tried #haskell-ghc but nothing
22:51:38 <augur> #ghc
22:51:40 <augur> whoops
22:52:23 <ski> yes, #ghc
22:52:28 <ski> er
22:53:18 <augur> i meant to type /join #ghc but left out the /join :)
22:54:10 <jle`> it happens
22:54:23 <filius> Hi everyone, I have a dynamic programming program finding longest common subsequence  implemented using Arrays here: http://lpaste.net/110287, but I always got KILLED when I ran it over a sequence of ~8000 integers. Is there a way to solve this?
23:06:07 <nshepperd> filius: my first thought is it might be bad that you're traversing the whole list of A.range bounds in order to construct your ds array
23:06:49 <nshepperd> but maybe it's smart enough to fuse that
23:15:32 <Markz> how would one play around with case analysis on the command line?
23:15:37 <filius> nshepperd: thanks! after some digging, I think this might be due to the memory-inefficientness of Arrays, I'll try some other data structures and see how it goes. As to your point, do u think there is a more efficient way to construct the ds array?
23:18:11 <nshepperd> I don't know
23:18:42 <Hafydd> Markz: do you mean as in the "case" expression?
23:18:56 <nshepperd> from testing in ghci, it seems to be possible to make a 8000x8000 array from a list without it dying, fairly quickly too, so maybe it's not that
23:20:27 <filius> nshepperd: yep, I've tried that too and it goes on well here.
23:20:29 <sqrt2> when i define a new algebraic datatype, how the "magic" derivations of Eq, Ord, Enum, etc. work?
23:20:42 <Markz> say I was playing with a function that produces Either, and I wanted to play with Left, how would I select the value from Left in the command line
23:21:09 <sqrt2> does the standard just say it should work this way, explicitly mentioning those typeclasses?
23:21:16 <sqrt2> or is there more to it?
23:21:20 <DanZimm> what does a `!` mean in a value constructor?
23:21:28 <DanZimm> e.g. in Data.Map
23:21:32 * hackagebot pandoc 1.13.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.13.1 (JohnMacFarlane)
23:21:35 <DanZimm> `data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
23:22:29 <Hafydd> Markz: if you want a partial function that extracts the the Left value or fails with an error, you could use "either id undefined e", or "let Left x = e in x".
23:25:12 <nshepperd> filius: maybe you could calculate the distance seperately from the path?
23:25:34 <jle`> DanZimm: the keyword you're looking for is that it's a strict field
23:25:37 <Hugglesworth> okay, I'm super tired and probably being stupid because this feels like one of those things that I've done a million times; but I have a function from a library that takes (a -> FileName) and I need to pass it (a -> IO FileName); but I can't seem to pull the io out and I'm getting cranky
23:26:17 <jle`> Hugglesworth: what is the type of the function from the library?
23:26:43 <Hugglesworth> customRoute :: (Identifier -> FilePath) -> Routes
23:26:58 <Markz> thanks Hafydd
23:27:05 <shachaf> You can't.
23:27:48 <Hugglesworth> route (customRoute hashRoute) -- is typical if hashRoute isn't IO; I keep thinking liftm is my way out, but it doesn't help
23:27:58 <jle`> the best you can do is get an IO Routes
23:28:10 <jle`> hm
23:28:22 <jle`> wait
23:28:29 <Hugglesworth> I can deal with propigating the IO all the way left, I don't mind that, but I just can't seem to get it to work
23:28:36 <jle`> actually, yeah.
23:28:52 <jle`> you can't
23:29:01 <filius> nshepperd: good point. I'll try that.
23:29:07 <Hugglesworth> fuck
23:29:21 <DanZimm> jle`: thanks
23:34:42 <nshepperd> filius: currently you're storing (distance for i j, path for i j) in the lazy ds array, so that your paths (list of Action) are kept around even when you later don't need them. Instead I think the trick would be to have ds just contain the distance, then write a seperate go' that recurses building up the path, using the previously calculated subdistances to decide which way to go
23:36:46 <nshepperd> at least, it would eliminate a tuple cell, cons cell and Action for each array position
23:55:00 <lbstr> Hello guys, I have a simple problem that is hard to google out, namely, i wan't to use happy for my gramma, when i use simple gramma example and try to run happy I just get 'Parse error' on end of every file
23:55:25 <lbstr> *at the end of
23:55:44 <lbstr> i just can't generate that parser
23:58:08 <Cale> lbstr: I'm not an expert on Happy, but I'll have a look if you post the code on lpaste.net or something.
