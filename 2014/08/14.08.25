00:00:13 <t4nk714> this is my program:
00:00:13 <t4nk714> import qualified Data.Vector.Mutable as MV import qualified Data.Vector as V import Control.Monad import Control.Monad.ST   evenMV v i = do 	--x <- MV.read v i 	fmap even $ MV.read v i  main = do 	let v1 = V.fromList ([1,3,4,6,4,4,3,21,3,4,2,2,4,5,6] :: [Int]) 	let w =  [1,4,6,8,9] :: [Int] 	let r = runST $ do 		a <- V.thaw v1 		b <- filterM (evenMV a) w 		return b 	print r
00:02:29 <lpvb> t4nk714: maybe you should paste that to http://lpaste.net/ instead and give the channel a link to that
00:08:01 * hackagebot language-c 0.4.6 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.6 (BenediktHuber)
00:08:01 * hackagebot word-trie 0.2.0.4 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.4 (MateuszKowalczyk)
00:17:59 * hackagebot directory 1.2.1.0 - library for directory handling  http://hackage.haskell.org/package/directory-1.2.1.0 (HerbertValerioRiedel)
00:23:00 * hackagebot yi-language 0.1.0.2 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.2 (MateuszKowalczyk)
00:28:00 * hackagebot references 0.2.1.1 - Generalization of lenses, folds and traversals to handle monads and addition.  http://hackage.haskell.org/package/references-0.2.1.1 (lazac)
00:43:04 * hackagebot yesod-core 1.2.19.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.19.1 (MichaelSnoyman)
00:58:05 * hackagebot process 1.2.0.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.0.0 (HerbertValerioRiedel)
00:59:31 <arianvp> ugh cabal
00:59:32 <arianvp> :(
00:59:54 <arianvp> "20 packages will be broken due to reinstalls)
00:59:59 <arianvp> this is why I cant have nice things
01:00:06 <arianvp> wtf
01:18:08 * hackagebot stylish-haskell 0.5.10.2 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.10.2 (JasperVanDerJeugt)
01:21:04 <arianvp> So I installed ghc-mod for EMACS. but when I issue "C-c C-h"  it says "command not found hoogle"  while hoogle is in my path
01:21:09 <arianvp> anyone hadd a similar issue?
01:24:14 <bergmark> arianvp: is it in emacs' path?
01:25:19 <arianvp> (setenv "PATH" (concat "~/.cabal/bin:" (getenv "PATH")))
01:25:22 <arianvp> yep
01:26:28 <arianvp> and set-exec-path has been set as well
01:26:43 <arianvp> weird thing is.  hlint _does_ work and stylish-haskell too
01:27:09 <trap_exit> honest, non-flamy question:
01:27:20 <trap_exit> what is the advantage of dynamic typing (say erlang) in distributed systems ?
01:27:29 <trap_exit> I've found some problem with writng distributed code in haskell
01:27:44 <trap_exit> but I'm not sure if it's because I'm just not used to typing messages, or if this is a fundamental limitation of type systems
01:38:12 * hackagebot http-client 0.3.7.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.7.2 (MichaelSnoyman)
01:44:02 <arianvp> damn emacs is so complex
01:44:06 <arianvp> im a bit nausious i think
01:44:15 <ChongLi> nauseated?
01:45:14 <arianvp> yeh
01:45:22 <ChongLi> it's actually not so complex
01:45:47 <ChongLi> it's just different enough to make it seem that way
01:47:36 <johnw> It's the apparent complexity that arises from having a few key parts that can combine in many interesting ways.  I think of this as the "binary phenomenon", or the fact that using only 1s and 0s, I can ultimately watch Ender's Game in hi-def.
01:48:54 <stalintrotsky> sometimes I confuse the mod keys I use in emacs and xmonad
01:48:57 <slack1256> emacs haskell mode seems really nice though. What I really want is a yi editor build from ground up with vim bindings but the rest being like emacs "just a lisp interpreter".
01:49:14 <stalintrotsky> and sometimes I confuse the commands themselves, like C-x C-o as opposed to mod + j
01:56:25 <arianvp> i might give evil mode a shot
01:56:33 <arianvp> because this is just an RSI monster
01:56:57 <johnw> is Martin Escardo here by any chance?
02:01:51 <stalintrotsky> they don't call it emacs pinky for nothing
02:10:10 <Twey> arianvp: Consider swapping Ctrl and Alt — emacs uses Ctrl a lot, and it's better to have the more frequently-used key on the stronger thumb
02:10:26 <arianvp> hmm I see
02:10:40 <arianvp> god structured-haskell-mode is nice
02:10:59 <Twey> arianvp: You could also try ergoemacs, which is a set of bindings that already do this
02:11:13 <arianvp> or... evil-mode :)
02:11:15 <Twey> Or, if you have money to burn, get one of these beauties: https://www.kinesis-ergo.com/shop/advantage-for-pc-mac/
02:11:49 <arianvp> ugh I just bought a mechanical keyboard
02:11:49 <Twey> evil-mode is kind of limited, doesn't work well with other modes, and requires you to waste a load of keypresses mode-switching
02:11:50 <makalu> can I get a coloured profile like visual-prof but with something that's compatible with cabal projects? Visual-prof uses its own build command and doesn't find modules :(
02:12:00 <arianvp> how about god-mode
02:12:01 <Twey> I don't think I know anyone who uses it for real
02:12:10 <Twey> god-mode is used, yeah
02:12:24 <arianvp> dude that keyboard is sexy.
02:12:29 <arianvp> Cherry mx browns :)
02:12:48 <Twey> It's a delight
02:12:55 <arianvp> you got one?
02:13:00 <Twey> They'll swap them for other Cherry switches if you ask, too
02:13:03 <Twey> Yeah
02:13:09 <arianvp> oh sweet. I'm personally a fan of reds
02:13:14 <arianvp> they're not that loud :)
02:13:20 <Twey> Aye
02:13:30 <arianvp> and my collegues are fan of the reds as well ;)
02:13:33 <ion> If you *really* have money to burn: http://youtu.be/_rzFqEqzhmA
02:13:35 <Twey> The customer service are great
02:14:06 <Twey> ion: Unfortunately these aren't made any more ☹
02:14:08 <arianvp> well I dont have money to burn. but last year I was unable to open doors or do the most simple tasks with my hands for almost 6 months
02:14:10 <arianvp> after a hackathon
02:14:18 <ion> twey: aww
02:14:29 <arianvp> Oh god. that thing is awesome
02:14:45 <ion> +1 for the “traditional keyboard” layout in the video being the Amiga layout.
02:14:47 <arianvp> but yeah. CPS is real and i've had it and it's horrible :(
02:15:13 <johnw> this is more appropriate to #haskell-blah
02:42:43 <BoR0> @hoogle Text -> ByteString
02:42:45 <lambdabot> Data.Text.Encoding encodeUtf16BE :: Text -> ByteString
02:42:45 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16BE :: Text -> ByteString
02:42:45 <lambdabot> Data.Text.Encoding encodeUtf16LE :: Text -> ByteString
02:56:20 <sdx32> > [1,3..10] :: [] Float
02:56:22 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
02:56:37 <sdx32> why is this (11.0)?
02:59:35 <opqdonut> sdx32: the list goes on until it reaches >= the endpoint
02:59:52 <opqdonut> for Floats, it seems
02:59:58 <opqdonut> > [1,1.4..4] :: [Float]
02:59:59 <lambdabot>  [1.0,1.4,1.8,2.1999998,2.5999997,2.9999995,3.3999994,3.7999992,4.199999]
03:00:06 <opqdonut> which is a bit weid I have to admit
03:00:23 <Iceland_jack> Floating point numbers are weird :)
03:00:36 <makalu> why is Vector's snoc O(n)? It has to copy the vector?
03:01:07 <makalu> I wonder how I should build a vector incrementally
03:01:31 <Iceland_jack> makalu: You use some of the other functions, there is a section on "Construction" https://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector.html#g:7
03:01:45 <opqdonut> sdx32: ah, the haskell report says "For Float and Double, the semantics of the enumFrom family is given by the rules for Int above, except that the list terminates when the elements become greater than e3+i/2 for positive increment i, or when they become less than e3+i/2 for negative i."
03:02:29 <opqdonut> ([a,c..b] converts to a call to enumFromThenTo)
03:03:58 <BoR0> @hoogle Text -> String
03:03:59 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
03:03:59 <lambdabot> Data.Text.Internal showText :: Text -> String
03:03:59 <lambdabot> Data.Text.Lazy unpack :: Text -> String
03:04:14 <Iceland_jack> @ty Data.Text.unpack
03:04:15 <lambdabot> Data.Text.Internal.Text -> String
03:04:53 <BoR0> thx
03:08:44 <sdx32> opqdonut: ah, nice. Thanks!
03:09:02 <moop> @hoogle fromIntegral
03:09:02 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
03:09:38 <Iceland_jack> @src fromIntegral
03:09:38 <lambdabot> fromIntegral = fromInteger . toInteger
03:11:55 <moop> @src toInteger
03:11:55 <lambdabot> Source not found. My pet ferret can type better than you!
03:12:03 <moop> @hoogle toInteger
03:12:03 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
03:12:16 <Iceland_jack> ‘toInteger’ doesn't have a single definition since it's a type class method
03:14:01 <Iceland_jack> The definition for Integer is simply:
03:14:02 <Iceland_jack>     toInteger i = i
03:14:02 <Iceland_jack> and for Int:
03:14:02 <Iceland_jack>     toInteger (I# i) = smallInteger i
03:14:57 <moop> hm
03:16:41 <Iceland_jack> Maybe adding the types will make it clearer
03:16:48 <Iceland_jack>     toInteger :: Integer -> Integer
03:16:48 <Iceland_jack>     toInteger i = i
03:16:49 <moop> no i understand
03:16:53 <Iceland_jack> okay
03:17:08 <moop> what i don't understand is why PortNumber is an integral and not integer
03:17:18 <moop> :t PortNumber
03:17:20 <lambdabot> Not in scope: data constructor ‘PortNumber’
03:17:35 <moop> oh wait
03:17:44 <Haskellfant> :i Integral
03:17:54 <Iceland_jack> If you're taling about PortNumber from Network it's seems to be a Word16
03:17:57 <Iceland_jack> *talking
03:17:59 <Haskellfant> moop: an Integral is just a type class
03:18:08 <Haskellfant> so it can be an Int, an Integer, …
03:18:15 <Iceland_jack> and Word16 is an instance of Integral
03:18:28 <Iceland_jack> but like Haskellfant says it's not a type
03:22:40 <moop> ok, and sorry if it's a dumb question, but why is word16 an instance of Integral?
03:22:56 <Iceland_jack> moop: not a dumb question
03:23:34 <Iceland_jack> Integral basically means that you're an integral number that you can divide
03:24:05 <Iceland_jack> So if you think of Integral as a set, it looks something like
03:24:05 <Iceland_jack>     Integral = {Int, Integer, Int8, Int16, ..., Word8, Word16, ...}
03:26:22 <Iceland_jack> And that means that you can divide two Ints (or Integers, or Word16s), you can get their remainder and turn them into an Integer
03:31:42 <moop> oh wait word is not related to strings
03:31:43 <moop> i'm dumb
03:31:45 <moop> sorry
03:31:47 <moop> :D
03:31:55 <Iceland_jack> hah
03:32:09 <Iceland_jack> Now I get your confusion :)
03:35:57 <bmcorser> hello
03:40:48 <bmcorser> i'm running through http://learnyouahaskell.com/ and rewrote one of their functions to turn a list of tuples into a map of lists, but i'm sure it could be done in less code. would anyone like to have a look?
03:41:00 <bmcorser> gist is here: https://gist.github.com/bmcorser/8f3b8e0ef1933b8b5b32
03:43:14 <Haskellfant> bmcorser: I guess listInsert = fromList doesn't count? :P
03:43:29 * hackagebot http-conduit 2.1.4.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.1 (MichaelSnoyman)
03:43:53 <Iceland_jack> bmcorser: Is the 'listInsert' function even necessary?
03:44:01 <hexagoxel> Haskellfant: it doesn't work
03:44:25 <Iceland_jack> bmcorser: You probably want to take a look at https://hackage.haskell.org/package/containers-0.3.0.0/docs/Data-Map.html#g:5
03:44:30 <Haskellfant> hexagoxel: ah fromListToMapList = fromList
03:44:32 <bmcorser> Iceland_jack: not strictly
03:44:39 <Haskellfant> no nvm I'm stupid
03:44:44 <bmcorser> :)
03:44:55 <hexagoxel> types don't even match :)
03:45:17 <Haskellfant> hexagoxel: yeah I shouldn't get into #haskell right after I woke up :)
03:45:18 <Iceland_jack> bmcorser: Basically if the key exists, you want to cons the the value to the existing value (list)
03:45:21 <bmcorser> Iceland_jack: but i didn't want to write Data.Map.lookup k acc twice and didn't know how to do a where in a lambda
03:45:28 <bmcorser> Iceland_jack: yes
03:45:49 <Iceland_jack> bmcorser: Look at the documentation for 'insertWith'
03:46:28 <BoR0> @hoogle Long
03:46:29 <lambdabot> Data.HashTable longestChain :: HashTable key val -> IO [(key, val)]
03:46:29 <lambdabot> Foreign.C.Types data CLLong
03:46:29 <lambdabot> Foreign.C.Types data CLong
03:46:48 <bmcorser> Iceland_jack: i did, but since the "with" function needs to take either a string or a list i couldn't get it to work
03:47:36 <bmcorser> ah wait ..
03:48:00 <bmcorser> hmm no
03:49:09 <Iceland_jack> ghci> M.insertWith (++) 4 [1] (M.fromList [(4, [999])])
03:49:09 <Iceland_jack> fromList [(4,[1,999])]
03:52:56 <Iceland_jack> That should be a start, as for your code if you went in that direction instead it might look nicer with a case expression
03:52:59 <bmcorser> Iceland_jack: the difficult is i dont start with [(1, [1], (2,[2])] i start with [(1,1),(2,2)]
03:53:16 <Iceland_jack> bmcorser: Right :) you'll need to bridge the gap between the two
03:53:22 <bmcorser> yes
03:53:31 <bmcorser> and yes
03:53:39 <Iceland_jack> can you define 'listInsert' with the same type in terms of insertWith?
03:53:39 <bmcorser> i'll post again later :)
03:53:48 <Iceland_jack> please do
04:58:38 * hackagebot json-assertions 1.0.5 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.5 (OliverCharles)
05:08:30 <DanZimm> so I joined this channel because of https://gist.github.com/quchen/5280339
05:08:41 <DanZimm> so I joined this channel because of https://gist.github.com/quchen/5280339
05:09:11 <DanZimm> oop sorry apparently I don't know how to type
05:09:41 <Algebr> How do you know when the data structure you made is actually a functor/applicative/monad? Do you just try implementing their respective functions and then check if the laws work out?
05:10:13 <bergmark> Algebr: you can do that, after a while you get a feel for it
05:10:26 <vanila> DanZimm, lol i was just thinking about you yesterday
05:10:53 <DanZimm> vanila: hrm? about me specifically?
05:10:55 <vanila> that's spooky that you just showd up again
05:11:06 <DanZimm> O.o
05:11:16 * DanZimm didn't know people knew him around here
05:13:33 <latk> How can I relativley reference a config file from an executable created by a cabal sandbox? Where does my filepath start ?
05:13:52 <latk> Is there some way to make it work both if it is run using cabal run, as well as compiled ?
05:23:58 <dibblego> Algebr: because it will follow one of a number of known patterns
05:29:02 <Algebr> dibblego: So are there unknown patterns out there waiting to be codified?
05:29:21 <Algebr> or rather, interesting & non-trivial
05:29:27 <pjdelport> Algebr: The intuition can be made more precise: for example, you can see a functor as an abstract structure (e.g. context, effect, or container) with a typed slot that you can operate on in some structure-preserving way.
05:29:32 <vanila> definitely Algebr
05:29:37 <vanila> there's so much to discover
05:29:57 <Algebr> my mind was just blown.
05:30:41 <dibblego> Algebr: sure, but you usually have to traverse the same ground as others first
05:30:43 <pjdelport> Algebr: Then Applicative extends that by adding structure-preserving lifted function application, and a distinguished "default" structure (pure/return)
05:31:41 <Algebr> this language can never be finished..?
05:31:42 <pjdelport> Algebr: And then monad extends that by adding a way to merge nested structures in a way that preserves both levels of structure (join)
05:32:55 <dottedmag> Algebr: those constructs are not parts of language, they are parts of libraries (albeit some of them end up in standard library).
05:34:22 <Algebr> you don't count the standard library as being part of the language?
05:35:22 <dottedmag> Not really. Look at hackage for replacements for Prelude to see why.
05:36:40 <dottedmag> And anyway, Applicative or Monad may end up in standard library, but specific implementations are introduced in the corresponding libraries, so standard library is open for extension, but closed for modification (until the next standard goes out).
05:38:23 <pjdelport> Algebr: Then you get Coapplicative / Comonad, which can respectively be thought of as functors with a distinguished "default" slot (extract), and a way to change the focus of that "default" slot to each of a structure's individual slots (duplicate)
05:39:28 <Algebr> All of these neat strucutres help you write less code...will there be a future where a non-trivial haskell program is like 4 lines of code??
05:40:51 <vanila> Algebr, yes - it's like that already... but that's not counting the libraries that let you do all this stuff so compatctly
05:40:58 <vanila> if you count the library code it's not as wild
05:42:34 <dottedmag> Algebr: Does main = xmonad defaultConfig count as a non-trivial Haskell program? :)
05:42:39 <Algebr> that kind of sucks for non-experts. Like to understand anything you'd have to already know all those abstractions, or at least what they mean.
05:43:12 <vanila> you have to learn a lot to understand haskell code, it's one of the hardest languages
05:43:14 <dottedmag> Algebr: to understand anything in C you'd have to already know the libraries, right?
05:44:59 <NikolajK> What are classes extending Monad? In the sense of
05:44:59 <NikolajK> "class Monad m => MoreSpecificButUsefullThingy m where"
05:44:59 <NikolajK> MonadPlus is an example, right? Else?
05:45:19 <Algebr> dottedmag: no but its so low-level and I can just step through the code. here I have to learn all kinds of new abstractions just to get anything serious going...
05:46:14 <untseac> Hi
05:46:18 <bergmark> NikolajK: all monad transformers
05:46:23 <Algebr> dottedmag: for example, trying to use snap, but it uses template haskell, lens, like everything under the sun. I'm not dissing snap, great haskellers should use whatever they want, but it makes it hard to understand what the heck is going on, which is of course my own fault.
05:46:38 <untseac> What's the best way to learn haskell for a total beginner?
05:46:54 <NikolajK> untseac: depends on what you did before
05:47:48 <Haskellfant> untseac: reading “learn you a haskell” is probably a good idea
05:47:53 <NikolajK> "Learn yourself a Haskell" and "Real World Haskell" are two recommended books which are available online. Both approach the subject with people in mind who did some minor imprtative programming before
05:48:52 <earthy> or major ;)
05:49:28 <NikolajK> what I really wanted to say is "Real World Haskell often draws explicit comparisons to Java etc."
05:50:04 <NikolajK> it helps if you know this, but it's not necessary. PS: I actually think the Wikibook could also be used to learn the basics.
05:50:48 <untseac> I do know some functional languages through ocaml and scala but I rather relearn it. thanks for the input.
05:51:11 <NikolajK> bergmark: Okay, I haven't tried to understand them yet, but will in the future. Other classes, maybe with a compact mathematical interpretation?
05:51:23 <DanZimm> Ok haskellers, I'm doing this lyah guide thingy and was curious about the following line I came up with: [2*x | x <- [1,2..], x >= 12, x <= 20]
05:51:27 <sivteck> untseac, there's also: https://github.com/bitemyapp/learnhaskell
05:51:31 <dottedmag> Algebr: Right-o. The learning curve is steep, but amount of stuff to learn is not so huge.
05:51:46 <DanZimm> is there anyway to make this terminate with some nice syntax?
05:51:47 <NikolajK> > [2*x | x <- [1,2..], x >= 12, x <= 20]
05:51:51 <lambdabot>  mueval-core: Time limit exceeded
05:52:07 <vanila> [2*x | x <- [12..20]]
05:52:18 <DanZimm> ah fair
05:52:31 <DanZimm> but nonethless can you work with infinite sets in comprehensions ever?
05:52:39 <vanila> you can do, and what you wrote almost works
05:52:48 <DanZimm> like is there some predicate I can add to tell it to stop?
05:52:48 <vanila> it's just that it gets past 20 and it still has hope for more elements
05:52:59 <NikolajK> the comprehension is just do, which is just >>=. Maybe reason there
05:53:00 <bergmark> NikolajK: you can go the other direction too, if you have Monad you also have Functor, Applicative, Arrow, ArrowApply
05:53:11 <vanila> > take 5 $ [2*x | x <- [1,2..], x >= 12, x <= 20]
05:53:12 <lambdabot>  [24,26,28,30,32]
05:53:16 <vanila> > take 8 $ [2*x | x <- [1,2..], x >= 12, x <= 20]
05:53:18 <lambdabot>  [24,26,28,30,32,34,36,38]
05:53:19 <DanZimm> aha!
05:53:21 <vanila> > take 10 $ [2*x | x <- [1,2..], x >= 12, x <= 20]
05:53:23 <vanila> now it crashes
05:53:25 <lambdabot>  mueval-core: Time limit exceeded
05:53:28 <fortune500> > fix error
05:53:30 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:53:40 <DanZimm> fortune500: wat
05:53:48 <DanZimm> ok ty vanila
05:54:22 <NikolajK> a truly 22th century language should be able to proof that all x after 20 in the list [1,2,…] are bigger than 20 and know to stop :(
05:54:43 <untseac> What made me want to learn haskell is that is great to create correct programs. True story right?
05:54:44 * DanZimm is very facinated by these infinite lists
05:55:12 <DanZimm> nikolajk: good thing we're not in that century yet
05:55:17 <NikolajK> the problem is that passing the list forward in the >>= chain with the x <= 20 as predicate doesn't solve what you want it to
05:55:34 <NikolajK> DanZimm: why?
05:55:51 <DanZimm> because haskell doesn't do that yet! (was a joke ;P)
05:57:19 <NikolajK> it could be done in principle. take the pattern [1,2,..], compute the recursive structure and proof that it's monoton. And the program would of course also have to have the idea to check if it's monotone. Then this together with x<=20 would make the code realize to terminate at 20
05:57:24 <pjdelport> > [ x | x <- [0..], x == 5] :: [Word16]
05:57:26 <lambdabot>  [5]
05:57:27 <NikolajK> prove*
05:57:29 <pjdelport> tada :)
05:57:44 <pjdelport> You just have to wait a bit longer for :: [Int]
05:57:56 <zereraz> @src splitAt
05:57:56 <lambdabot> splitAt n xs = (take n xs, drop n xs)
05:58:14 <nh2> is there a `String -> ByteString` function that does *not* discard any parts of characters? ByteString.Char8 does; I would like to turn the full String into a ByteString
05:58:16 <DanZimm> > [ x | x <- [0..], x >= 12, x <= 20 ] :: [Word16]
05:58:18 <lambdabot>  [12,13,14,15,16,17,18,19,20]
05:58:29 <DanZimm> pjdelport: you are awesome
05:58:32 <zereraz> how to put @src in ghci? I need to use it offline
05:58:44 <NikolajK> what is [Word16]?
05:59:06 <adas> NikolajK: 16 bit int
05:59:10 <DanZimm> Microsoft word from the future
05:59:10 <Haskellfant> Word16 is a 16bit unsigned integer type
05:59:13 <vanila> NikolajK, that would be so cool i wonder if any language can do that
05:59:40 <Haskellfant> so enumerating all the values is way faster than with a 32 or even 64bit Int
06:00:08 <dagle> Hmm. Checking for packages on hackage and all packages I find are made by dons O_o
06:00:14 <NikolajK> PS: I dream of a language which is an expert in all things Kolmogorov complexity, one that thinks for you in unheard ways
06:00:24 <NikolajK> I mean Data is such a machine
06:00:29 <zereraz> ?
06:00:33 <NikolajK> Mr. Data
06:00:50 <Haskellfant> dagle: there are also quite a few by ewardk :)
06:00:52 <NikolajK> he sure can recognice the intent behind the x<=20 pattern
06:01:48 <zwer> untseac it is true. this is a great, related talk on the matter. http://vimeo.com/72870631
06:02:03 <dagle> Haskellfant: I bet it's just dons with another nick, because he overflowed the database.
06:02:14 <Haskellfant> dagle: :P
06:02:35 <Haskellfant> don't tell that to edwardk, he might be offended
06:03:07 <untseac> zwer, thanks, video first is always a good idea :)
06:04:22 <NikolajK> from reading some papers and tellings, it appears the suggestion by Moggi to write down State and computation via monads was a pure accident that could have well been overlooked. I wonder if there are some other natural undiscovered concepts to make code more concise
06:05:08 <DanZimm> proof of special case of fermats last theorem (joke ofc): [(a,b,c) | a <- [1..], b <- [1..], c <- [1..], a^4 + b^4 == c^4]
06:05:17 <jamess> > filter odd [1..10]
06:05:19 <lambdabot>  [1,3,5,7,9]
06:05:34 <NikolajK> pjdelport: so the case ":: [Word16]" just lets ghci know that you wont go on too long and hence it stops? Or how does that work?
06:05:39 <jamess> how would we filter only even numbers, if even didn't exist? basically, how to negate the predicate
06:06:15 <vanila> DanZimm, if only :)
06:06:15 <Haskellfant> > filter even [1..10]
06:06:17 <lambdabot>  [2,4,6,8,10]
06:06:17 <NikolajK> map (+1) into it?
06:06:27 <Haskellfant> > filter (not odd) [1..10]
06:06:29 <lambdabot>  Couldn't match expected type ‘a -> GHC.Types.Bool’
06:06:30 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘G...
06:06:30 <lambdabot>              with actual type ‘a0 -> GHC.Types.Bool’
06:06:38 <Haskellfant> > filter (not . odd) [1..10]
06:06:40 <lambdabot>  [2,4,6,8,10]
06:06:43 <vanila> I wonder what kind of advanced supercompiler could to output [] for [(a,b,c) | a <- [1..], b <- [1..], c <- [1..], a^4 + b^4 == c^4]
06:06:44 <NikolajK> > filter odd $ map (+1) [1..10]
06:06:45 <lambdabot>  [3,5,7,9,11]
06:06:52 <jamess> ah not
06:06:57 <NikolajK> I'm stupid
06:07:00 <jamess> why the dot though?
06:07:17 <Haskellfant> jamess: you want to negate the result of applying odd to the number not the function not itself
06:07:19 <NikolajK> > map (+1) $ filter odd [1..10]
06:07:20 <lambdabot>  [2,4,6,8,10]
06:08:14 <pjdelport> NikolajK: The ":: [Word16]" is an explicit type declaration: it constrains the type to Word16 (which is bounded enough that all the values can be enumerated quickly)
06:08:45 <pjdelport> NikolajK: By default, Haskell tries to infer the most generic type:
06:08:46 <pjdelport> :t [ x | x <- [0..], x == 5]
06:08:47 <lambdabot> (Num t, Eq t, Enum t) => [t]
06:08:53 <NikolajK> pjdelport: k, yeah that's what I ment. How does the program know it doesn't forget anything this way, though
06:09:14 <NikolajK> what if 17 pops up at place 100000 of [1,2]
06:09:18 <NikolajK> [1,2..]
06:09:48 <pjdelport> NikolajK: It will simply go through all of them by brute force, until it reaches the end.
06:09:58 <NikolajK> which end
06:10:03 <pjdelport> > length ([0..] :: [Word16])
06:10:04 <lambdabot>  65536
06:10:08 <pjdelport> The end of that list.
06:10:10 <NikolajK> ah k
06:10:12 <Haskellfant> NikolajK: you can only represent a certain amount of numbers using word16
06:10:18 <Haskellfant> because you only have 16 bits
06:10:29 <NikolajK> so that's a hack for DanZimm, not an honest solution :)
06:10:58 <pjdelport> NikolajK: The [0..] syntax is just short for the enumFrom method of Enum type class. That's why the generic signature has Enum in the context.)
06:11:01 <NikolajK> not monotone-proving-Data 22th century style code
06:11:52 <pjdelport> It will just enumerate all the types values in order; and for a bounded type like Word16, that's a finite list.
06:12:01 <NikolajK> > [ x | x <- [0..], x >= 12, x <= 20 ] :: [Word16]
06:12:02 <lambdabot>  [12,13,14,15,16,17,18,19,20]
06:12:04 <NikolajK> should be the same as
06:12:33 <NikolajK> > [ x | x <- [0..], x >= 12, x <= 20, member x (length ([0..] :: [Word16])) ]
06:12:35 <lambdabot>  Not in scope: ‘member’
06:12:35 <lambdabot>  Perhaps you meant one of these:
06:12:35 <lambdabot>    ‘IM.member’ (imported from Data.IntMap),
06:12:35 <lambdabot>    ‘M.member’ (imported from Data.Map),
06:12:35 <lambdabot>    ‘S.member’ (imported from Data.Set)
06:12:52 <NikolajK> what was the member quiery again?
06:13:05 <NikolajK> no wait
06:13:18 <NikolajK> > [ x | x <- [0..(length ([0..] :: [Word16]))], x >= 12, x <= 20]
06:13:20 <lambdabot>  [12,13,14,15,16,17,18,19,20]
06:13:23 <NikolajK> right
06:13:43 <NikolajK> that's kinda more honest
06:13:48 * hackagebot ghc-syb-utils 0.2.2 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.2 (ThomasSchilling)
06:14:28 <pjdelport> NikolajK: maxBound is a better way to state that. :)
06:14:34 <pjdelport> > maxBound :: Word16
06:14:36 <lambdabot>  65535
06:14:47 <NikolajK> :) hey I just copied YOUR code
06:15:18 <pjdelport> Well, the intent of the length was just to demonstrate that the list is finite.
06:15:45 <NikolajK> yeah that's what she said.
06:16:17 <joe9> With C programming using signal handlers, the recommended approach is to do as less as possible in the handler and do the bulk of the programming in the main loop.
06:16:31 <joe9> Is that practice relevant for haskell signal handlers too?
06:18:38 <NikolajK> Is there any toturial which introduces the writer monad from the Hom-functor perspective?
06:19:17 <NikolajK> also, what functors in haskell aren't representable?
06:19:31 <sideeffect> hello, I'm on Debian testing, I tried installing Haskell Platform from https://www.haskell.org/platform/linux.html (haskell-platform-2014.2.0.0-unknown-linux-x86_64.tar.gz), but when I try to run ghc(i), I get these errors:
06:19:42 <pjdelport> joe9: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals suggests that the Haskell-level signal handler might be executed outside the scope of the C-level handling, so maybe not.
06:19:50 <Dtgr> joe9: I don't think there's difference in good signal handling conventions between languages
06:20:11 <sideeffect> thanks for help :)
06:20:47 <joe9> pjdelport: Dtgr: ok, thanks. let me read up on the article.
06:20:49 <sideeffect> the errors are:
06:21:01 <sideeffect>  /usr/local/haskell/ghc-7.8.3-x86_64/bin/ghc-7.8.3: line 9: /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/ghc: cannot execute binary file: Exec format error
06:21:06 <sideeffect>  /usr/local/haskell/ghc-7.8.3-x86_64/bin/ghc-7.8.3: line 9: /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/ghc: Success
06:21:31 <pjdelport> joe9: Might want to ask on #ghc too!
06:22:09 <sideeffect> I've seen this these errors also here http://ircbrowse.net/browse/haskell?id=18793462&timestamp=1407779534#t1407779534 but without any explanation/ways to fix it
06:23:19 <NikolajK> Can I view terms of type "IO Soemthing" (what's often called "action") to be, literally, <programs to be read in an executed by main>
06:23:35 <NikolajK> <program code to be read in an executed by main>
06:24:05 <trap_exit> haskell is a language where learning it decreases your employability on the job market
06:24:27 <vanila> trap_exit, what should i learn to increase employability
06:24:34 <trap_exit> java
06:24:34 <trap_exit> php
06:24:34 <exio4>  java
06:24:41 <Haskellfant> trap_exit: I'll probably stay unemployed then :/
06:24:52 <NikolajK> nursing
06:25:05 <trap_exit> one day, we're goign to see people on the streets holding up pan handling signs
06:25:06 <pjdelport> NikolajK: "IO action that yields Something" is probably the most accurate / helpful.
06:25:09 <trap_exit> "will write haskell for food"
06:25:26 <pjdelport> NikolajK: IO values represent first-class actions, or effects.
06:26:09 <pjdelport> (Their effect is their "structure", in terms of the previous intuitive analogies i gave for functors / monads)
06:26:39 <pjdelport> (In other words, "structure-preserving" means "effect-preserving", for IO.)
06:26:52 <NikolajK> I don't think words like "yields" are precise enough to further my understanding
06:26:58 <tomfiodorov> >>decreases your employability on the job market
06:27:02 <tomfiodorov> could you elaborate?
06:27:20 <pjdelport> NikolajK: It's not meant to be that precise; you could say yields, returns, results in, produces, delivers... :)
06:27:43 <pjdelport> The intuition is just that the IO action's effect happens, and then you have a value.
06:28:35 <NikolajK> my question is motivated by the first answer here
06:28:35 <NikolajK> http://stackoverflow.com/questions/4063778/in-what-sense-is-the-io-monad-pure
06:28:40 <joe9> pjdelport: ok, thanks. good idea.
06:28:44 <pjdelport> Or more accurately, that the IO action is a value that represents a future value that will be obtained by the executing the effect that the action represents.
06:29:08 <NikolajK> and the "execution only via main" is right, right?
06:29:29 <Javran> :t zipWith id
06:29:31 <lambdabot> [b -> c] -> [b] -> [c]
06:29:38 <Javran> :t zipWith ($)
06:29:40 <lambdabot> [b -> c] -> [b] -> [c]
06:30:24 <Javran> :t ?f `id` ?x
06:30:25 <lambdabot> (?x::t1, ?f::t1 -> t) => t
06:30:48 <rom1504> > 1
06:30:53 <lambdabot>  1
06:30:53 <rom1504> :t 1
06:30:55 <lambdabot> Num a => a
06:30:57 <pjdelport> NikolajK: More or less; you can execute in other ways as well, like at the ghci prompt (and of course unsafePerformIO, but unsafePerformIO performs the action's effect as a side effect, so it breaks referential transparency, hence the name)
06:31:05 <kgadek> hi. no particular case, only wondering: is it ok to implement encryption in garbage collected + immutable language/platform like Haskell? sounds bad at first, e.g. can't clear memory, but is there anything more to the story?
06:31:21 <makalu> I remember people had issues with time. Is there a better library for parsing and calculating with dates?
06:31:59 <makalu> kgadek: there's a C + Haskell SSL implementation on hackage
06:31:59 <pjdelport> NikolajK: In a sense, you can think of a Haskell executable as compiling into a single top-level invocation of "unsafePerformIO main"
06:32:58 <NikolajK> I interpret this as my understanding being correct so far
06:33:09 <kgadek> makalu: yeah, but there's C inside. I'm wondering if it's ok to do that only in haskell
06:33:46 <vanila> kgadek, what about the timing side channel?
06:34:07 <trap_exit> is ther a shor thand for: "foo :: type_class A => type_class B => a -> b -> c" ?
06:34:19 <trap_exit> i.e. if I have more than one type class constraint, do I need more than one "=>" ?
06:34:19 <vanila> kgadek, so I think haskell like languages are better for writing the specifications of crypto algorithms than the actual implementations
06:34:23 <trap_exit> or is there a way to 'group' the type class constraints?
06:34:32 <Tuplanolla> Put them in a tuple, trap_exit.
06:34:48 <trap_exit> Tuplanolla: example ?
06:35:26 <TheKing444> is then anything like replicateM that uses Integer (or Word) instead of Int?
06:35:58 <wombawomba> I'm trying to optimize the following: https://gist.github.com/aeriksson/aa3d80f3def966cbbafb Any ideas?
06:36:07 <kgadek> vanila: yeah, that's another thing to the story. There is *whole* lot of practical attacks + strategies to avoid them in imperative, low-level languages. // I believe you're right, C/C++ are better but… I'm trying to think if that would be possible to implement that in Haskell with all known attacks in mind
06:36:14 <pjdelport> NikolajK: Yeah. Inside the composed main IO action, all manipulation of IO actions stays pure (assuming you don't use unsafePerformIO unsafely inside. :).
06:36:15 <Tuplanolla> f :: (A a, B b) => a -> b, trap_exit.
06:36:48 <trap_exit> Tuplanolla: nice, thanks!
06:37:25 <NikolajK> pjdelport: okay, thanks for the infos
06:37:26 <TheKing444> Hey why does length use Integer instead of Word?
06:38:18 <kgadek> vanila: my thoughs started from the "[Haskell-cafe] Tor project" topic on haskell-cafe. Galois is doing Tor implementation and Adam Wick says that it would be interesting to see the security of high-level implementation of TLS
06:40:15 <TheKing444> http://stackoverflow.com/q/25487119/1172541
06:40:31 <exio4> @type length
06:40:33 <lambdabot> [a] -> Int
06:40:51 <vanila> kgadek, insane
06:41:42 <vanila> Why does Galois want a tor implementation?
06:43:44 <kgadek> vanila: no idea! but since my expertise on encryption implementations is close to none and I see something that's "insane", it's usually someone who is either genius / more knowledgeable from me or the idea is just stupid
06:43:46 <vanila> Any Galois folk around?
06:43:54 <vanila> why Tor :)
06:44:29 <vanila> kgadek, If it was anyone other than Galois doing this i say it was stupid - but those guys are smart...
06:44:40 <kgadek> my thougts exactly
06:44:58 <vanila> I'd really like to know more about why they're doing this
06:45:09 <kgadek> I even suspect that safe encryption is possible in HS
06:45:24 <kgadek> or they do some magic like proof-driven C development
06:45:29 <kgadek> as in SeL4 kernel
06:45:46 <kgadek> (the OS kernel that's proven with Haskell to work)
06:45:51 <vanila> kgadek, well they developed Cryptol
06:46:03 <vanila> which is a haskell-like language for specifying and deal with crypto algorithms
06:46:06 <vanila> dealing*
06:46:18 <c_wraith> vanila: Galois does very little unless it's being funded by someone else.
06:46:34 <vanila> by the way SeL4 is done with Isabelle
06:46:38 <vanila> I dont think there's any haskell involved
06:46:51 <c_wraith> vanila: it's likely someone is paying them for an implementation that has some verified properties
06:47:30 <kgadek> vanila: ok, I might have misread about SeL4. My bad
06:51:59 <vanila> I can't even see the point in doing tor in haskell
06:52:15 <Algebr> vanila: why is haskell bad for doing tor?
06:52:54 <vanila> Algebr, most effective attack against tor was against the web browser (a firefox derivative)
06:53:31 <vanila> until you take that out of the loop your treading water imo
06:53:46 <Algebr> are there haskell web browsers??
06:54:42 <wombawomba> Are there any go-to references for writing performant Haskell?
06:54:54 <opqdonut> real world haskell, if you haven't read it yet
06:55:14 <opqdonut> http://book.realworldhaskell.org/read/
06:55:18 <silver> wombawomba, it doesn't work like that
06:55:59 <wombawomba> alright, cool. I've only read the first half so far
06:56:07 <wombawomba> silver: how does it work?
06:56:33 <dreams> wombawomba: most pitfalls I found in papers.
06:58:54 * hackagebot yesod-platform 1.2.13.3 - Meta package for Yesod (deprecated)  http://hackage.haskell.org/package/yesod-platform-1.2.13.3 (MichaelSnoyman)
06:59:50 <silver> wombawomba, often order of execution isn't even known for programmer, so no point in go-to
07:00:08 <NikolajK> when they say a C language "has introduced monads", what does that mean? I mean they can't even have fmap, can they?
07:00:10 <dreams> writing efficient Haskell programs is a complicated business.
07:00:57 <jmcarthur> silver: wombawomba wasn't asking about goto, but about what resources to "go to" to learn about performance
07:01:08 <silver> oh I see
07:01:10 <silver> sorrry
07:01:19 <wombawomba> heh yeah, I'm looking for articles or similar
07:01:53 <wombawomba> I figured it would be interesting to learn to write performant Haskell
07:02:03 <dreams> wombawomba: what are you after, space or speed performance?
07:02:20 <wombawomba> well, mainly speed right now I guess
07:02:30 <jmcarthur> (a good question, although the two tend to coincide)
07:02:45 <wombawomba> although both are interesting to me
07:03:06 <wombawomba> I'm trying to solve SPOJ-style problems for practice
07:03:41 <wombawomba> but my Haskell code keeps ending up much slower than the corresponding C code
07:03:48 <tero-> is there a function that runs a bunch of tasks IO (Maybe a) each in a separate thread, waits until everyone is ready (or failed/timeout), and then wraps up results?
07:03:55 <lecoeus> wombawomba: have you read pearls of functional algorithm design?
07:04:29 <wombawomba> lecoeus: I have it, but I haven't read it
07:04:49 <dreams> wombawomba: with speed its probably your algorithm. Because GHC can take care of speed with optimization flags. But in terms of space, its more difficult.
07:05:02 <wombawomba> right now though, it's not an algorithm issue
07:05:15 <perfstref> hello, i have some STRef integer mutation code and it works much slower compared to a similar solution in OCaml? does anyone know any GHC optiizations on this?
07:05:19 <dreams> wombawomba: http://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/
07:05:45 <exio4> i think a little top (too), is try to use the right type for the job
07:06:06 <wombawomba> for instance, this code: https://gist.github.com/aeriksson/ec604418a0a21016e74b is roughly 20x faster than this code: https://gist.github.com/aeriksson/aa3d80f3def966cbbafb
07:06:14 <wombawomba> even though I'm using mutable vectors
07:06:37 <jmcarthur> tero-: using the async package, maybe something like   mapM wait <=< mapM async
07:06:39 <makalu> people say Simon Marlow's "Parallel and Concurrent Programming in Haskell" is useful as well even for regular sequential code
07:06:57 <tero-> jmcarthur: thanks. I'll have a look
07:07:13 <wombawomba> dreams: that looks great, thanks
07:07:32 <jmcarthur> tero-: you would have to add something for timing out, but failure should be handled automatically by async
07:07:40 <makalu> and it's free to read online
07:07:54 <jmcarthur> tero-: for timing out, async supports the notion of racing, so you could race an async job with a clock
07:08:03 <wombawomba> makalu: I've seen that, but I figured it probably didn't apply to me. Will give it a look!
07:09:11 <jmcarthur> wombawomba: do you have a problem description for that code?
07:09:17 <jmcarthur> wombawomba: i will take a stab at making faster
07:09:36 <tero-> jmcarthur: I'm making multiple ajax requests using ghcjs and then processing the results after all have returned. maybe the browser will take care of timeouts
07:09:56 <jmcarthur> tero-: i wouldn't trust the browser :)
07:10:21 <jmcarthur> i really should give ghcjs a shot. it could make me not hate web dev so much.
07:11:20 <wombawomba> jmcarthur: https://www.hackerrank.com/challenges/missing-numbers
07:11:27 <tero-> jmcarthur: I started using it seriously last weekend. I can recommend it if can accept larger JS output (megs)
07:12:23 <dreams> lecoeus: does it focus on efficiency?
07:12:38 <jmcarthur> tero-: cool. i'd probably be using it to make app-like functionality anyway, so it would all be loaded once up front.
07:12:48 <lecoeus> dreams: if you mean algorithmic efficiency, yes
07:12:54 <jmcarthur> ajaxy type stuff, i mean
07:13:05 <tero-> jmcarthur: and with FRP it's really neat. http://weblog.luite.com/wordpress/?p=127
07:13:17 <dreams> lecoeus: yes.
07:14:29 <luite> tero-: you can use timeout x (ajax y) to make an IO (Maybe (AjaxResult x)) from an IO (AjaxResult x), to handle timeout from Haskell
07:15:09 <tero-> luite: thanks
07:15:24 <luite> tero-: (it does require the ajax binding to call .abort() on the xhr if you want to clean up properly, that's easy to add with an onException in the binding
07:15:51 <luite> since System.Timeout sends an async exception to the waiting thread to wake it up
07:16:11 <tero-> luite: aha
07:16:42 <perfstref> can anyone help why these different versions of simple count all work 7x slower compared to a similar OCaml solution? http://lpaste.net/109978
07:16:47 <luite> jmcarthur: i'm also working on a new codegen that brings size down and where some functionality can be dropped for older browsers or more limited environments
07:19:53 <luite> jmcarthur: but some other things had priority recently :)
07:20:57 <wombawomba> jmcarthur: I have to go, but I'll ping you later to see if you managed to get it to run faster :)
07:21:10 <jmcarthur> alright sure
07:21:24 <jmcarthur> luite: sweet.
07:23:09 <c_wraith> perfstref: I'm not sure any of those examples are good enough for the strictness analyzer to avoid creating thunks.
07:23:47 <c_wraith> perfstref: and in a simple busy-wait like those, creating thunks is a *ton* of overhead
07:23:57 * hackagebot testPkg 0.0 - Small test package  http://hackage.haskell.org/package/testPkg-0.0 (Stephen_E_A_Britton)
07:24:02 <perfstref> c_wraith: the memory usage is 0% during execution
07:24:36 <perfstref> c_wraith: do you mean it's creating and destructing them right away even though it is not accumulating them?
07:24:51 <c_wraith> perfstref: they could be.  You'd need to check the core
07:25:25 <c_wraith> perfstref: count3 almost certainly is creating thunks.  There's no way the strictness analysis can see through STRefs
07:26:52 <perfstref> c_wraith: my purpose for inlining count2 and putting a bangpattern was to give a hint that the value is strict. that's also slow
07:27:57 <perfstref> c_wraith: i'm guessing OCaml may be allowing unboxed mutable integers. i don't know if that is allowed in haskell.
07:29:01 <c_wraith> perfstref: It is, though it isn't straightforward. But you don't need mutable for that.
07:29:36 <Algebr> How do you delete from a file? Like I have a handle on it.
07:29:41 <perfstref> c_wraith: this looks very simple to do in OCaml, here: http://lpaste.net/109979
07:29:44 <tero-> jmcarthur: mapConcurrently seems to do the same
07:30:01 <c_wraith> perfstref: it's enough to write the loop so that strictness analysis sees that the counter should be unboxed.
07:30:05 <perfstref> c_wraith: i thought there should be an easy solution that for some reason i couldn't see
07:30:33 <c_wraith> perfstref: you should install the ghc-core utility
07:30:48 <perfstref> c_wraith: so count1 and count2 are not enough either then
07:31:19 <julianb> perfstref, it probably has something to do with thunks, doing foldl' (\x -> (+) 1) 0 [1..1000000000] does the same thing in 130s in my pc (through ghci)
07:31:57 <julianb> (your code is taking way more than that, though it hasn't finished running yet)
07:32:19 <c_wraith> perfstref: you *really* should be looking at core if you want to figure this out
07:32:36 <exio4>  /query alis
07:32:39 <exio4> oops
07:33:26 <dreams> ...
07:33:34 <dreams> c_wraith: reading core is a bit tricky for me, what resources would you recommend?
07:34:39 <perfstref> julianb: that's 6x slower than STRef
07:35:31 <luite> perfstref: you can't do unboxed mutable integers with GHC by the way, the closest things there is is a mutable array of unboxed integers or working with a pointer. but you probably don't want that here, like c_wraith said
07:36:26 <julianb> perfstref, not in my case, count3 is taking about 3 mins by now
07:36:34 <perfstref> luite: then that may be limiting fast integer mutation.
07:37:10 <perfstref> julianb: i used -O3 in both. count3 is 5s for me
07:37:24 <perfstref> julianb: foldl' took 30s
07:37:40 <Javran> @pl \f x -> join (fmap (flip fmap x) f)
07:37:41 <lambdabot> (join .) . flip (fmap . flip fmap)
07:37:55 <julianb> well, that's weird...
07:38:23 <Javran> :t join (fmap (flip fmap ?x) ?f)
07:38:25 <lambdabot> (?x::m a1, ?f::m (a1 -> a), Functor m, Monad m) => m a
07:38:45 <Javran> :t \f x -> join (fmap (flip fmap x) f)
07:38:47 <lambdabot> (Functor m, Monad m) => m (a1 -> a) -> m a1 -> m a
07:38:49 <perfstref> luite: do you know what is the best way for high-performance FSM implementations in Haskell?
07:38:56 <Javran> :t ap
07:38:58 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:39:35 <TheKing444> > iterate succ 0 !! maxBound
07:39:41 <lambdabot>  mueval: ExitFailure 1
07:39:51 <TheKing444> > "Hello"
07:39:53 <lambdabot>  "Hello"
07:40:48 <luite> perfstref: in most cases you don't need a single mutable int, arrays are supported, but the Int#/Word# primitives are immutable
07:40:55 <julianb> perfstref, that doesn't make sense... my pc is running the STRef version in 5s, the foldl' version in 0s
07:41:04 <julianb> using 03
07:41:18 <luite> perfstref: and if you really need a single unboxed mutable int, you can still use a single element array
07:42:50 <perfstref> luite: ok, that makes sense. i'll try that
07:43:08 <perfstref> julianb: just tried it again, for some reason it's 30s on mine
07:43:40 <julianb> perfstref, are you sure the amount of 0s in the foldl version is the same as the other one?, and that you're compiling with the same flags?
07:44:00 <perfstref> julianb: using -O3 for both
07:44:09 <perfstref> and i just copied your
07:44:14 <perfstref> yours
07:44:32 <perfstref> julianb: checked it, it's same
07:45:01 <TheKing444> Question: is -O3 dangerous?
07:45:11 <exio4> as far as i know, -On (n>=3) is the same as -O2
07:46:04 <c_wraith> perfstref: well, http://lpaste.net/109981 generates good core for the loop.  Uglier than I anticipated, though.  There's probably a simpler way.
07:46:21 <c_wraith> perfstref: I also didn't check actual runtime
07:48:16 <perfstref> c_wraith: yes, that matches it
07:49:47 <c_wraith> perfstref: heh.  http://lpaste.net/109982 actually does give me the same core.
07:49:49 <perfstref> c_wraith: i'll also check the unboxed mutable vector instead of stref for curiosity
07:49:59 <Tuplanolla> @pl \ x -> flap x $ \ f x y -> f y x
07:50:00 <lambdabot> ($ const . join) . flap
07:50:19 <c_wraith> perfstref: no way that'll be faster.  The loop in my two lpastes should never let the counter out of a register
07:50:49 <perfstref> c_wraith: i tried to use the bangpatterns to force strictness but i guess $! is better
07:51:08 <c_wraith> perfstref: it's not better, it just doesn't need an extension. They do the exact same thing.
07:51:20 <Tuplanolla> @pl \ x -> flap x $ \ f y z -> f z y
07:51:21 <lambdabot> flip flap flip
07:51:25 <Tuplanolla> There we go.
07:51:46 <perfstref> c_wraith: but the count2 in my example tries to do the same with bangpatterns, doesn't it?
07:51:57 <c_wraith> if I could actually read the full ghc-core output, I could track down what assembly corresponds to the loop
07:54:40 <c_wraith> huh.  Yeah, I'm bad at x86 asm.  does movl %eax, (%ebp) copy it to memory?
07:56:05 <c_wraith> That's the only thing in the loop that looks like overhead.  Hmm.  I wonder if compiling via -fllvm would fix that.
07:56:29 <zmbmartin> Does anyone use the mongoDB package? connect has a type signature of: connect :: Host -> IO Pipe. If I call that a number of times am I opening new connections each time or getting the same one?
07:56:35 <joshc_> () in general is pointer indirection, IIRC, so: possibly.  I always get the argument order mixed up (it doesn't help that different x86 assemblers use different argument order :\)
07:56:58 <luite> -ddump-cmm is probably easier to read that the assembly then
07:57:05 <luite> than
07:57:18 <Tuplanolla> That reads "move from the extended A register to the place referred by the extended base pointer".
07:57:35 <perfstref> c_wraith: which version is that? count3 or count2?
07:57:36 <Tuplanolla> You might want to use Intel syntax for reading assembly, c_wraith.
07:57:50 <c_wraith> perfstref: it's my version.  Which I suppose is count2
07:58:31 <perfstref> c_wraith: oh, your version is not either of these, and is much faster than them
07:58:52 <perfstref> c_wraith: i had asked if count2 with bangpatterns here was the same with your second version: http://lpaste.net/109978
07:58:56 <c_wraith> perfstref: even if you make the loop counter correct?  Please note that I made the loop counter smaller. :)
07:59:13 <perfstref> c_wraith: yes, i made it the same
07:59:18 <c_wraith> ok
07:59:36 <perfstref> c_wraith: yours runs in 0.7s, same as OCaml
07:59:54 <c_wraith> perfstref: with the bang pattern, I would usually expect GHC to be optimize the same way
08:00:09 <c_wraith> perfstref: but maybe the strictness analyzer missed that one.
08:00:12 <Tuplanolla> Hey, zmbmartin.
08:00:28 <c_wraith> perfstref: my expectation is that the strictness analyzer will miss a lot, and you should help it maximally.
08:00:57 <Tuplanolla> This is what I meant by using mconcat yesterday: https://www.refheap.com/bc865e0b720990e5e1035cd66
08:01:09 <perfstref> c_wraith: do you know if forcing it on application ($!) vs forcing it on the datatype makes any difference? or should i just check it anyway
08:01:28 <c_wraith> perfstref: there are a bunch of different factors.
08:02:27 <freeaaa> best soccer tips http://tinyurl.com/p5bpscx
08:03:00 <c_wraith> perfstref: unfortunately, optimizing haskell for GHC is another black art - that shares little with the black art that is optimizing C, until you get down to super low-level stuff.
08:03:17 <zmbmartin> Tuplanolla: ok Thanks! I solved my problem with catMaybes
08:03:31 <Tuplanolla> @t catMaybes
08:03:31 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
08:03:40 <Tuplanolla> :t catMaybes
08:03:42 <lambdabot> [Maybe a] -> [a]
08:04:10 <perfstref> c_wraith: ok, i installed the ghc-core and i'll check tight loops. thanks!
08:04:47 <Tuplanolla> That works too, but you might want to look at my use of Monoid too.
08:04:48 <c_wraith> perfstref: by the way, http://www.haskellforall.com/2012/10/hello-core.html is a handy intro to ghc-core
08:05:13 <zmbmartin> Tuplanolla: I will so I can understand it :)
08:05:25 <perfstref> c_wraith: thanks!
08:07:18 <Shirila22>  You can find funny videos here. http://bit.ly/1mFMmyS
08:09:03 * hackagebot github 0.11.0 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.11.0 (cesar_nataren)
08:11:02 <sheisty27> sup coloreds?
08:11:56 <sheisty27> functional programming is bullshit
08:12:01 <sheisty27> for loops are better
08:13:21 <hamid> sheisty27, It's not about for loops! you are thinking about mutablity.
08:13:34 <vanila> functional programming is good
08:13:36 <sheisty27> i don't know what that is
08:13:44 <exio4> sheisty27: and what about while loops?
08:13:55 <sheisty27> don't use while loops
08:13:55 <danneu> loop/recur
08:15:48 <c_wraith> So, yeah.  http://lpaste.net/109990  I don't really understand the generated assembly. %ebp has something going on I just don't understand, clearly.
08:16:03 <sheisty27> your code is wrong
08:16:31 <sheisty27> stick to visual basic
08:16:42 <Tuplanolla> Now, c_wraith, Intel syntax.
08:17:00 <c_wraith> Tuplanolla: I use what my tools give me.
08:17:11 <Tuplanolla> objdump?
08:17:20 <sheisty27> you're not a real coder
08:17:30 <sheisty27> that's why your code isn't working
08:17:37 <mmmm_> What does "provides constraints" mean in this sentence? "Pattern P (used in a pattern) requires constraints CR, and provides constraints CP"
08:18:04 <c_wraith> mmmm_: that's interesting wording.  Where is that from?
08:18:24 <mmmm_> https://ghc.haskell.org/trac/ghc/ticket/8581
08:19:18 <vanila> c_wraith, there's no other place to put that though is there?
08:19:22 <eikke___> edwardk: whenever I see proposal messages to libraries@, I feel the urge to ask 'Could you list some of the drawbacks you can think of (if any)?'. Should be a rule in proposal messages :-)
08:19:40 <vanila> c_wraith, I'm sorry - no you're right that would be faster if it were in _c3QI
08:19:48 <vanila> since it would only happen right at the end, rather than once per loop
08:19:57 <edwardk> eikke___: i don't have any drawbacks for this proposal
08:20:10 <edwardk> eikke___: it simplifies the design and makes it less magic. the cost is it needs to make it use GADTs, woop-ti-do
08:20:15 <eikke___> edwardk: thought so
08:20:18 <edwardk> its using Any for chrissakes
08:20:25 <edwardk> so by comparison that is an easy win
08:26:17 <Algebr> if you get your_file_name.hs: <<loop>> upon execution of your program, what exactly does that mean?
08:27:19 <edwardk> Algebr: it means you have an infinite loop in your code, where something depends on itself to proceed.
08:27:21 <c_wraith> mmmm_: I'm going to guess that he means that CR is the set of constraints that need to be in the function's type signature if you pattern match on P, and CP is the set of constraints that the type-checker knows are satisfied if P matches
08:27:23 <edwardk> > let x = x in x
08:27:27 <lambdabot>  mueval-core: Time limit exceeded
08:27:31 <edwardk> ^- that sort of thing
08:27:48 <edwardk> they can be more subtle
08:28:04 <c_wraith> mmmm_: actually, I'm pretty confident in that guess.
08:28:14 <tero-> I get "thread blocked indefinitely in an MVar operation" with Control.Concurrent.Async.runConcurrently on ghcjs even though all threads complete their tasks ok.
08:28:32 <tero-> any hints where to start digging?
08:29:04 <Algebr> hmm, yes it was something like that example.
08:29:39 <TheKing444> How do you index Data.Sequence.Seq when it is bigger than how big Int goes?
08:30:01 <c_wraith> TheKing444: that data structure won't fit in your system's memory if it has that many elements
08:30:02 <tero-> krhm, one of the threads them dies. nevermind
08:30:14 <c_wraith> TheKing444: heck, it won't fit in the address space available
08:30:34 <TheKing444> oh
08:30:46 <TheKing444> well, thats unfortunate
08:31:02 <c_wraith> It is a downside.
08:31:33 <TheKing444> time to refactor
08:31:46 <TheKing444> or I guess it is called optimizing
08:33:09 <c_wraith> mmmm_: if you haven't used GADTs, you're probably not familiar with pattern matches satisfying constraints - but it can happen even without pattern synonyms.
08:34:31 <f-a> tried haskell-beginners with no luck, so I am trying here: given an error like this http://ariis.it/link/t/has-err.txt , why isn't a default (Int) declaration at the top of the module fixing it?
08:35:15 <c_wraith> f-a: the defaulting rules are pretty strict.  It can only default in very specific cases, and your code isn't one of those cases
08:35:20 <mmmm_> c_wraith: ok, so when he says that CP must be provable from CE, does that mean there has to be a way to turn something which satisfies CE to something which satisfies CP?
08:35:53 <f-a> (and just as I typed this, hexagoxel suggested -XExtendedDefaultRules on #haskell-beginners)
08:36:12 <c_wraith> mmmm_: well, I read it as CE must be a superset of CP, in some way or another
08:36:55 <mmmm_> and what is the relationship between CR and CP?
08:36:58 <c_wraith> f-a: in general, the default directives aren't too useful.  I recommend more or less not ever using them.
08:36:59 <mmmm_> disjoint?
08:37:19 <c_wraith> mmmm_: no relationship.
08:38:26 <c_wraith> mmmm_: they may be disjoint, they may have a nonempty intersection, they may have some relationship that GHC can never identify.
08:38:38 <mmmm_> right
08:39:01 <mmmm_> Is there a way to specify types for a pattern synonym? I remember reading some discussion somewhere about it
08:39:26 <c_wraith> Not in 7.8.  I don't know about future plans
08:39:35 <hexagoxel> f-a: yeah you need to wait a least a full hour for replies :D
08:39:55 <f-a> if you check the timestamps it's scary, hexagoxel ;)
08:39:57 <mmmm_> c_wraith: thanks for your help
08:40:48 <simpson> Is there a version of bracket that operates on Either/EitherT? I need to deallocate resources in the inner Monad of an EitherT regardless of whether there's currently a failing condition.
08:41:43 <c_wraith> simpson: check the instance lists
08:42:05 <simpson> :t bracket
08:42:07 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:42:33 <simpson> I haven't yet found a generalized bracket on MonadError. Maybe I just have to roll up my sleeves.
08:42:41 <c_wraith> simpson: no, I mean in the haddocks for EitherT, check the instance lists.  I'm seeing about 10 instances that deal with that.
08:44:21 <c_wraith> simpson: as a hint, the MonadBase and MonadBaseControl instances are for the monad-control package, which lifts all kinds of combinators (including bracket)
08:44:32 <simpson> Hm, I see only MonadError; MonadCatch and MonadThrow on EitherT delegate it to the inner Monad.
08:45:34 <c_wraith> simpson: must be looking at a different EitherT.  I think there are multiples, sadly
08:45:35 <simpson> Haven't worked with those before, but they seem promising, thanks.
08:45:50 <simpson> c_wraith: I'm looking at ekmett's either, which is supposedly the correct EitherT to use.
08:45:57 <c_wraith> Ah, same one I was looking at.
08:47:20 <simpson> Okay, so MonadBaseControl comes close but still uses IO's bracketing. I want to bracket the Either state; the "exceptions" that I want to "catch" are just Lefts.
08:47:35 <simpson> I suppose I'll have to write what I want.
08:51:25 <c_wraith> simpson: I think http://hackage.haskell.org/package/lifted-base-0.2.3.0/docs/Control-Exception-Lifted.html should do what you want, with the MonadBase and MonadBaseControl instances
08:51:47 <c_wraith> simpson: I'm pretty sure that will actually run bracket's finalizer on exceptions
08:51:57 <c_wraith> simpson: err, on Lefts
08:52:28 <simpson> Sadly, it's not quite right: "Also, any monadic side effects in m of the "release" computation will be discarded; it is run only for its side effects in IO."
08:53:16 <c_wraith> Does your finalizer ever return Lefts?
08:53:22 <simpson> I have EitherT CustomErrorType (StateT CustomStateType IO) and I'm modeling a language with it. The language's scoping and computation rules allow catching exceptions.
08:53:48 <simpson> Yeah, the finalizer can return Left if it decides to not catch the current error.
08:54:11 <c_wraith> ah.  That is a different use case.  I guess you will have to write it yourself
08:54:57 <simpson> Yeah. I basically need to use MonadError's catchError, which *does* save my State by way of only operating on the EitherT.
08:55:23 <simpson> :t catchError -- but catchError is a tad too simple. :c
08:55:24 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
08:57:02 <c_wraith> simpson: maybe lifted-base's catch?
08:57:31 <c_wraith> simpson: or maybe try, instead of catch
09:12:11 <zmbmartin> Tuplanolla: I pinged you in a private channel if that is alright. If you don't have time no worries.
09:16:42 <haz-a-question> Hey, I have a non-beginner monad question
09:17:16 <davidfetter> you don't need permission to ask :)
09:17:18 <haz-a-question> If I have a nested monad, such as IO (Either String [Int])
09:17:53 <steffen> What is a nice way to do this : (+!+) :: Maybe [a] -> Maybe [a] -> Maybe [a]. I tried liftM2 (++) but it will give me Nothing if one of the ars is nothing :(
09:17:53 <steffen>  
09:17:59 <haz-a-question> And I have a function [Int] -> IO (Either OtherType)
09:18:11 <jfischoff> @unMTL ErrorT IO String [Int]
09:18:11 <lambdabot> Unknown command, try @list
09:18:27 <jfischoff> @unmtl ErrorT IO String [Int]
09:18:28 <lambdabot> String (Either IO [Int])
09:18:32 <haz-a-question> Is there a way I can  "bind" the monads in a nested way?
09:18:42 <jfischoff> oh whoops
09:18:42 <c_wraith> jfischoff: wrong arg order. :P
09:19:03 <jfischoff> @unmtl Error String IO [Int]
09:19:04 <lambdabot> Error String IO [Int]
09:19:04 <c_wraith> haz-a-question: that's what monad transformers are for
09:19:17 <davidfetter> .oO(more than meets the eye)
09:19:28 <davidfetter> sorry. 80s moment.
09:19:37 <pablo|> steffen: isn't Maybe [a] redundant? how is Nothing different then Just []?
09:19:45 <pjdelport> steffen: What do you want to happen, exactly?
09:20:02 <haz-a-question> Monad transformers, where can I find some information on those? Is there a decent tutorial somewhere?
09:20:17 <steffen> pjdelport: hahaha, your right! Let me try without the maybe in the first place xD
09:20:46 <haz-a-question> I wanted to do something like   m >>= f
09:20:48 <davidfetter> http://en.wikibooks.org/wiki/Haskell/Monad_transformers
09:21:13 <haz-a-question> but the bind would require Either String [Int] -> IO (either String OPtherType)
09:21:22 <davidfetter> that's just googling. no earthly clue as to its helpfulness to you
09:21:32 <steffen> pjdelport: ohh no, I want to append to lists but it can happen, that for one of them, there is none
09:21:33 * davidfetter more in the n00b monad questions state
09:21:34 <haz-a-question> rather then just the [Int] -> IO (Etiher String OtherType)
09:21:49 <steffen> pjdelport: so with just using emptylists, this would not work
09:22:29 <jfischoff> haz-a-question: You want EitherT
09:22:34 <jfischoff> @hoogle either
09:22:35 <clrnd> :t fmap . fmap
09:22:36 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:22:36 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
09:22:37 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
09:22:37 <lambdabot> package either
09:22:43 <jfischoff> @hackage either
09:22:43 <lambdabot> http://hackage.haskell.org/package/either
09:22:53 <jfischoff> haz-a-question: ^
09:24:49 <pjdelport> steffen: Can you describe what exactly you want to happen for the relevant inputs? :)
09:25:27 <pjdelport> You said liftM (++) isn't the desired behavior, but what is, then?
09:26:23 <steffen> pjdelport: I figured that you were right in the first place :) Sorry for the confusion :)
09:37:11 <haz-a-question> Thank you c_wraith for pointing me to Monad Transformers genereally, and to jfischoff for pointing me EitherT concretely. This is definately what I need (both abstractly & concretely). You guys are great!
09:37:29 <c_wraith> haz-a-question: glad to help.  Come back any time.
09:37:42 <haz-a-question> I most certainly will!
09:47:03 <jollygood> wasn't there a function like this? I can't find it on hoogle. (a -> b) -> (a, a) -> (b, b)
09:47:27 <ReinH> :t (&&&)
09:47:28 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
09:47:36 <ReinH> Nope.
09:47:50 <ReinH> One of the Arrow ones iirc
09:48:28 <bennofs> :t bimap :: (a -> b) -> (a,a) -> (b,b)
09:48:29 <lambdabot>     Couldn't match type ‘c0 -> d0’ with ‘(a1, a1)’
09:48:30 <lambdabot>     Expected type: (a1 -> b1) -> (a1, a1) -> (b1, b1)
09:48:30 <lambdabot>       Actual type: (a1 -> b1) -> (c0 -> d0) -> p0 a1 c0 -> p0 b1 d0
09:48:39 <bennofs> :t join bimap :: (a -> b) -> (a,a) -> (b,b)
09:48:41 <lambdabot> (a -> b) -> (a, a) -> (b, b)
09:48:45 <oisin878> Hello! I'm haing an issue with cabal. I've installed a package (Data.Octree) from Hackage - but I ran into some problems, so I pulled the source from github and made some modifications. Now I want to cabal install my local package and use that one instead. How do I overwrite the hackage package with my local source code?
09:48:52 <stew> :t (***)
09:48:52 <jollygood> :t bimap
09:48:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:48:54 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:49:00 <jollygood> :-O
09:49:07 <bennofs> @hoogle bimap
09:49:09 <lambdabot> package bimap
09:49:27 <bennofs> @hackage bifunctors
09:49:28 <lambdabot> http://hackage.haskell.org/package/bifunctors
09:49:29 <glguy_> > over both (*2) (3,4)
09:49:31 <lambdabot>  (6,8)
09:49:46 <ReinH> There's always lens
09:49:46 <jollygood> I never learned arrows, I guess it's time
09:49:54 <vanila> It's so weird that the ST monad lets you do basically a well typed hetrogeneous store in a pure way
09:50:00 <vanila> but you can't implement this in normal haskell
09:50:22 <merijn> vanila: What do you mean "can't implement this in normal haskell"?
09:51:00 <vanila> there's no pure implementation of ST that doesn't use something like unsafeCoerce or an extra typeclass consrtaint (for something like typeable) or a closed universe (the GADT method)
09:51:29 <merijn> AFAIK ST doesn't use unsafeCoerce?
09:51:43 <bennofs> it uses unsafePerformIO-like
09:51:46 <merijn> Or a typeclass constraint, for that matter
09:51:56 <merijn> bennofs: Where?
09:52:00 <c_wraith> merijn: I'm will to bet readSTRef uses something a lot like unsafeCoerce
09:52:05 <vanila> I think you misunderstood me
09:52:05 <c_wraith> *willing
09:52:27 <bennofs> merijn: I think it needs to unwrap IO at least (importing some magic GHC module)
09:52:29 <vanila> you can implement state, list, maybe monad etc.
09:52:34 <vanila> but you can't implement ST as a user
09:52:36 <merijn> bennofs: ST doesn't use IO
09:52:44 <merijn> bennofs: In fact, IO is a specialised case of ST
09:52:56 <vanila> even ignoring the algorithmic speedup from the mutable implementation it provides
09:53:03 <bennofs> ah right, but ST still uses GHC magic
09:53:16 <merijn> bennofs: Define magic?
09:53:47 <vanila> merijn, does that make sense?
09:53:49 <merijn> It uses some primitive types, but in the end, so does everything
09:54:12 <jollygood> > over several (+2) (1,2,3)
09:54:12 <bennofs> merijn: MagicHash -> magic
09:54:14 <lambdabot>  Not in scope: ‘several’
09:54:26 <merijn> vanila: I'm not 100% sure that's true (that you can't implement ST as user), but I'm not sure how
09:54:36 <merijn> bennofs: MagicHash isn't magic in any normal sense of the word
09:55:02 <bennofs> you can probably implement ST using the FFI or similar
09:55:08 <vanila> merijn, I don't have a mathematical proof but im sure there's no way to do it - I asked here yesterday and was told it was impossible
09:55:21 <merijn> bennofs: It's just that the standard syntax for unboxed types uses a character that is not allowed by the report
09:55:43 <merijn> vanila: Did you read the paper on ST? It's pretty enlightening
09:56:14 <vanila> yes
09:57:14 <bennofs> merijn: but to implement ST, you need to use GHC primitive functions (like newMutVar#)
09:57:38 <c_wraith> vanila, merijn: you can't implement ST using safe primitives.  The whole point of ST is that it uses the type system to prove its use of unsafe primitives is safe.
09:59:47 <vanila> c_wraith, yeah it's just that you can implement it with data.dynamic
10:00:07 <zmbmartin> I want to do an instance of Monoid for a Field which is a mongoDB type that consists of a Label(Text) and a Value ie [Label: Value]. You create a Field with =: as a constructor. I am not concerned with the Label only the Value.
10:00:13 <vanila> which uses unsafeCoerce
10:01:22 <c_wraith> vanila: Data.Dynamic uses a weaker mechanism to prove that its use of unsafeCoerce is valid.  Weaker in that before GHC 7.8, it was possible to create lying instances of Typeable.  And even in 7.8, it's possible to find hash collisions, if you try really hard.
10:01:33 <vanila> scary!
10:01:58 <vanila> I wonder kind of extra "power" ST gives you wrt. curry-howard
10:02:08 <vanila> ignoring the mutation aspects
10:02:21 <vanila> probably nothing, but the fact you can't implement purely is curious
10:03:16 <oisin878> What might be the cause of using "deriving Read" but getting a "Prelude.read: no parse" error?
10:03:38 <merijn> oisin878: You're reading the wrong String? :)
10:03:45 <c_wraith> oisin878: providing input in a form that doesn't get accepted by the Read instance
10:03:47 <merijn> > read "c" :: Char -- whoops
10:03:49 <lambdabot>  *Exception: Prelude.read: no parse
10:03:54 <merijn> > read "'c'" :: Char -- whoops
10:03:56 <lambdabot>  'c'
10:03:59 <oisin878> merijn: But it's the string that comes from the "show" call... which is also derived.
10:04:21 <oisin878> Simply: read $ show $ ..
10:04:24 <merijn> oisin878: lpaste the datatype and read/show calls + results?
10:04:30 <oisin878> merijn: Alright
10:05:43 <oisin878> http://lpaste.net/109992
10:06:11 <oisin878> Ah, sorry, the result is: *** Exception: Prelude.read: no parse
10:06:12 <athan> Does throwing in flags to `cabal install` force it to escape from a sandbox? For instance, I'm installing Yi with `cabal install -fvty`, and it's trying to do it globally
10:06:16 <NotUnknown> Could someone please help me ?
10:06:24 <vanila> sure
10:06:27 <merijn> oisin878: What's the result of "show"?
10:06:34 <bmuk> what is the best way to get the products of all three digit numbers? [x*y | x <- [100..999], y <- [100..999]]?
10:06:48 <oisin878> merijn: "Vector3 {v3x = 1.0, v3y = 2.0, v3z = 3.0}"
10:07:09 <vanila> bmuk, that works fine, do you want the list of have unique entries?
10:07:23 <NotUnknown> May i get some help here ?
10:07:27 <vanila> NotUnknown, yes
10:07:31 <merijn> hmmm, odd
10:07:36 <merijn> oisin878: No idea
10:07:44 <NotUnknown> Thanks i need help with Windows @vanila
10:07:45 <oisin878> merijn: Thanks for taking a look :)
10:07:46 <zwer> > product [100..999]
10:07:47 <NotUnknown> How to open GRE Powerprep 2 in windows IE9, When i click continue in Internet Explorer 9 it's not working ?
10:07:48 <lambdabot>  4311620889832239429429499517670828272457518674135910201519054540829794643510...
10:07:49 <vanila> bmuk: since x*y = y*x you can cut out some computation like this: [x*y | x <- [100..999], y <- [x..999]]
10:08:06 <bmuk> vanila: yes I would like only the unique entries. Is this the most idiomatic way? The most efficient?
10:08:26 <vanila> bmuk, you'd have to filter out duplicates afterwards
10:08:27 <bmuk> vanila++ I see that
10:09:02 <jfischoff> vanila++
10:09:05 <vanila> alternatively you could take the numbers [100*100...999*999] and filter out the primes? probably not faster but it saves a second pass
10:09:13 <NotUnknown> Am i in a wrong place @vanila ?
10:09:22 <vanila> NotUnknown, yeah, sorry - this is for haskell
10:09:50 <bmuk> vanila: Is a list comprehension the only way to do this? Or the best way?
10:10:09 <NotUnknown> @vanila thank you but could you please give me some links for my problem ? i
10:10:09 <lambdabot> Unknown command, try @list
10:10:20 <Tuplanolla> At least it's easy to read, bmuk.
10:10:40 <glguy_> NotUnknown: If you have a question about Haskell on Windows, ask it. If anyone is able and willing to help they will. Also, @username is specific to Twitter, on #haskell we use that for bot commands.
10:10:53 <Tuplanolla> Try #windows for the rest, NotUnknown.
10:11:17 <NotUnknown> They are not even giving reply Tuplanolla
10:11:28 <Tuplanolla> Perhaps they expect you to figure it out on your own.
10:11:40 <NotUnknown> Anyway thank you all for your support , sorry for the trobule.
10:12:09 <bmuk> Tuplanolla: I will leave it; I am just curious as to other ways to solve the problem.
10:12:28 <Tuplanolla> Do you know what the list comprehension means, bmuk?
10:12:43 <jollygood> is it possible to implement immutable hash table efficiently? how?
10:12:59 <Tuplanolla> Hint: it's also known as a monad comprehension.
10:13:23 <bennofs> Are there any tricks to read the core of a large function? Through inlining, it often happens that when I look at core, I get presented with a 200loc function (which is very hard to understand because of unreadable variable names)
10:13:58 <bmuk> Tupanolla: yeah, I wrote the first one. Well, I know what that particular one means. Just like in pure math where you describe sets like this { x | x <= 0 }
10:14:13 <bmuk> every x such that x fulfills these properties
10:15:33 <Tuplanolla> I used an inappropriate term there. I meant in terms of language constructs.
10:16:18 <bmuk> I don't know any more about them than how to use them. What are they?
10:17:10 <Tuplanolla> > [x * y | x <- [1 .. 4], y <- [x .. 4]]
10:17:12 <lambdabot>  [1,2,3,4,4,6,8,9,12,16]
10:17:23 <Tuplanolla> > do x <- [1 .. 4]; y <- [x .. 4]; return $ x * y
10:17:25 <lambdabot>  [1,2,3,4,4,6,8,9,12,16]
10:17:54 <bmuk> ah okay. So they are syntactic sugar for that do notation
10:18:15 <Tuplanolla> > [1 .. 4] >>= \ x -> [x .. 4] >>= \ y -> return $ x * y
10:18:17 <lambdabot>  [1,2,3,4,4,6,8,9,12,16]
10:18:33 <mikeplus64> bennofs: the ghc-core program is handy
10:18:38 <Tuplanolla> The magic has been dispelled.
10:19:06 <bennofs> mikeplus64: thanks, I already use that
10:19:06 <bmuk> > [ x * y | x <- [1..4], y <- [1..4], even x]
10:19:06 <vanila> Tuplanolla, I don't thnik list comps actually do desugar to monads though
10:19:09 <lambdabot>  [2,4,6,8,4,8,12,16]
10:19:15 <vanila> due to:
10:19:33 <vanila> > [ (x,y) | x <- [1,2,3] | y <- ["foo","bar","baz"]]
10:19:36 <lambdabot>  [(1,"foo"),(2,"bar"),(3,"baz")]
10:19:59 <bmuk> how would you translate the predicate to monads? filter?
10:20:23 <vanila> bmuk, that you can translate
10:20:23 <merijn> :t guard
10:20:25 <lambdabot> MonadPlus m => Bool -> m ()
10:20:25 <mikeplus64> bennofs: i think ghc-core does this by default but maybe try compile with -dsuppress-all
10:20:32 <vanila> if even x then [()] else []
10:20:36 <vanila> empty list means "fail"
10:20:45 <vanila> so it backtracks and tries other x's and y's
10:20:56 <bennofs> mikeplus64: I'll try that flag. I think GHC core only suppresses some things
10:20:58 <merijn> vanila: You're right that list comprehensions don't desugar to monads by default
10:21:11 <bmuk> merijn: how are they implemented?
10:22:01 <merijn> bmuk: Explicit list functions, I think, I don't know off the top of my head
10:23:22 <bmuk> Are list comprehensions always the best choice for problems like this (the list of all numbers that satisfy some arbitrary conditions?)
10:23:31 <vanila> not always
10:23:37 <mikeplus64> merijn: you could probably use fail, but nobody likes fail
10:23:49 <c_wraith> I don't use list comprehensions a whole lot - but sometimes they're really concise.
10:23:51 <vanila> bmuk, you might want something more advanced that does constrtaint solving before the brute force search
10:24:02 <Tuplanolla> Looks like it requires {-# LANGUAGE MonadComprehensions #-}.
10:24:04 <vanila> which would require a different monad than []
10:24:10 <Tuplanolla> I thought that was the default for some reason.
10:24:47 <bmuk> vanila: is there explicit language support for something like that or would I write it myself?
10:26:44 <Tuplanolla> It should be the default.
10:30:50 <halvorg> Hi, I'm gonna build a rest/http api in haskell, any recommended libraries?
10:31:06 <jmcarthur> @tell wombawomba this is within half the speed of C on my machine. http://lpaste.net/109993
10:31:06 <lambdabot> Consider it noted.
10:31:08 <halvorg> I see snap/yesod/happstack are possibilities, but comparisons are hard tocome back.
10:31:20 <halvorg> hard to come by*
10:31:30 <jmcarthur> @tell wombawomba the bottleneck (by far) is the parsing
10:31:31 <lambdabot> Consider it noted.
10:34:30 * hackagebot monad-logger 0.3.7.2 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.7.2 (MichaelSnoyman)
10:38:28 <bmuk> Is there a way to generate the list comprehension in such a way that it doesn't contain duplicates? a set comprehension maybe? nub is taking longer than I would like it to
10:38:43 <joelteon> how would you detect duplicates
10:39:34 <halvorg> bmuk: make your own nub if you can order the items.
10:39:39 <mightybyte> halvorg: http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
10:39:53 <halvorg> nub doesn't have an Ord constraint, so it is very slow.
10:40:23 <mightybyte> halvorg: Also http://softwaresimply.blogspot.com/2012/12/haskell-web-framework-matrix_20.html for a different take.
10:40:34 <halvorg> mightybyte: 2012, still up to date?
10:40:48 <c_wraith> halvorg: not really.  Everything's faster now, and not uniformly
10:41:06 <halvorg> c_wraith: what do you mean?
10:41:14 <mightybyte> halvorg: Yeah, those posts are pretty big picture, so I would say that they're still fairly accurate.
10:41:15 <halvorg> c_wraith: oh nvm, thought you meant about my nub comment.
10:41:20 <halvorg> :D
10:41:23 <glguy_> Faster is one dimension, but they different systems have different approaches to being used, as well
10:41:23 <c_wraith> oh, hah.
10:42:15 <mr-> Is there a version of parsec's parseTest that also outputs the remaining input-stream?
10:42:45 <bmuk> I suppose this is a better nub, it uses a set. http://buffered.io/posts/a-better-nub/
10:42:57 <glguy_> mr-: Just write a parser that returns the rest of the string as well
10:44:14 <mr-> right, thanks
10:44:21 <jfischoff> bmuk: its not clear which would be better for small sized lists.
10:44:55 <bmuk> jfischoff: my list is 405450 before trimming the duplicates
10:45:04 <jfischoff> alright then
10:45:32 <jfischoff> There is also HashSet
10:45:34 <bmuk> why does the default implementation of nub not require an Ord constraint?
10:46:10 <bmuk> we could at least have a nubOrd or something
10:47:19 <jfischoff> bmuk: what is the type of your elements?
10:47:28 <bmuk> Int
10:47:35 <lpaste> edwardk pasted “For Juan Carlos” at http://lpaste.net/6684112424280260608
10:48:22 <vanila> edwardk, which channel is this may i ask?
10:48:29 <vanila> [that the paste is for]
10:48:35 <edwardk> vanila: technically it was for facebook =)
10:48:52 <edwardk> for the "Programming Haskell" group there
10:49:00 <vanila> ooh
10:49:03 <vanila> interesting
10:49:10 <vanila> GADTs on facebook huh :)
10:49:37 <edwardk> someone posted a thing going on about how GADTs were awesome and I pointed out his example didn't need G, so he asked me for an example.
10:49:50 <edwardk> hence that
10:50:00 <vanila> ah
10:50:08 <vanila> well technically that doesn't need GADTs either :p
10:50:19 <vanila> (I just finally got pushed into reading Oleg's tagless paper properly)
10:51:02 <jfischoff> I suppose without de bruijin indices you do need a GADT
10:51:15 <hodapp> what paper?
10:51:29 <edwardk> vanila: sure, though technically oleg's finally tagless paper isn't a 'final' encoding, so 'technically''s abound all around =)
10:51:41 <glguy_> edwardk: He asked for an example that *did* need GADTs?
10:51:50 <edwardk> glguy_: yeah
10:52:00 <edwardk> i guess just to figure out what G in GADT was all about
10:52:33 <simpson> edwardk: Are patches to `either` accepted? I have a patch but have to round-trip it through internal code review, so I don't want to put in effort if it's unmaintained.
10:52:46 <edwardk> i still take patches for it
10:52:50 <edwardk> what are you looking to do?
10:53:40 <simpson> I needed bracketEitherT, which brackets for Left values in EitherT without disturbing the inner Monad.
10:54:00 <simpson> (Context: Exception handling in an implementation of a stateful language.)
10:56:00 <bennofs> Is there a combinator library for lexing? (not just parsing)
10:56:37 <monochrom> I haven't seen one
10:57:01 <vanila> why not just use a parser combinator library to lex?
10:57:51 <bennofs> vanila: because (I think) that's slower, because the parser combinator library has to deal with possibly context-sensitive languages, whereas lexing is typical only regular
10:58:51 <Crockeo> Anyone mind helping me with some OpenGL stuff? I'm trying to load textures.
10:58:51 <Crockeo> http://lpaste.net/109996
10:59:15 <Crockeo> Like the paste says, every time I try to run it, it throws an error
10:59:34 <Crockeo> (the error is just for testing purposes right now)
11:00:05 <edwardk> simpson: i could see it. surprised tekmo didn't include it in errors actually.
11:05:09 <bmuk> How do I pattern match on a singleton list? Will f [x] work?
11:05:14 <vanila> yes
11:05:27 <bergey> Crockeo: according to https://www.khronos.org/opengles/sdk/docs/man/xhtml/glIsTexture.xml if you haven't bound a texture to the name, it's not a texture (and isObjectName calls glIsTexture)
11:06:04 <Crockeo> bergey: So if I want to check if that's working, then I should do it after my call to 'textureBinding', yeah?
11:07:35 <bergey> Crockeo: Sounds reasonable.  I don't know the texture part of OpenGL well.
11:08:01 <bergey> Usually in Haskell I assume that if the type indicates it can't fail, that's true. :)
11:08:38 <kgadek> hi. is there any intro to type dependent type systems with I/O in mind? I'm wondering how to
11:08:38 <kgadek> a) read n::Int and then n*integers from input,
11:08:39 <kgadek> b) pass it to (classic) safe-head method.
11:08:40 <kgadek> Any newbie-dependent materials would be nice ;)
11:09:20 <Crockeo> bergey: So do I, but I'm a little more cautious around bindings that seem (or at least feel) so low-level as these.
11:09:37 * hackagebot snap 0.13.2.8 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.8 (DougBeardsley)
11:09:54 <Crockeo> bergey: Side note, if it comes up that the texture is rendering fine, would you have any idea why a texture might be rendering as a white square?
11:10:33 <bergey> bergey: Yes.  I like using GLUtil and vinyl-gl instead.
11:11:01 <bergey> Crockeo: no idea; that seems to be the usual failure mode of OpenGL.
11:11:19 <jmcarthur> kgadek: a) you would have to return a tuple   (n :: Int, Vec n Int)
11:11:32 <Crockeo> bergey: Yeah, so I've come to discover. I was just hoping that you might have some magical GL-pro insight into it.
11:11:44 <jmcarthur> kgadek: b) you would have to pattern match on the returned Int, and if it's not zero then you would be able to use the safe head function on the vector
11:12:27 <jmcarthur> kgadek: but unfortunately i don't know what to recommend for you to read
11:12:39 <Crockeo> bergey: GLUtil and vinyl-gl seem cool, if still a little foreign to me. Shame that I would have to completely re-write the backend of my library for it.
11:12:55 <Crockeo> Well not /completely/
11:13:34 <kgadek> jmcarthur: but this is effectively checking bounds at runtime, which I'd love to skip. I suspect that Irdis/other dep-typed have a way to solve this with some kind of proofs but I have little knowledge on that so… well, back to original question :)
11:13:44 <supki> kgadek: I found http://www.reddit.com/r/haskell/comments/29kv2y/why_dependently_typed_programming_will_one_day/cimhyt0 helpful when I had a similar question
11:14:01 <jmcarthur> kgadek: you have to check that the input satisfies the expectations you are imposing on it. there is no way not to do it at runtime
11:14:25 <jmcarthur> kgadek: dependent types don't relive you of this responsibility. rather the opposite, they require you to prove that you have done it.
11:14:56 <kgadek> jmcarthur: I thought about something along: check property -> coerce types
11:14:57 <jmcarthur> kgadek: the benefit for this sort of case is that you could do the check just once and then reuse the proof multiple times
11:15:20 <jmcarthur> kgadek: that's right. in this case, you check that the size is nonzero, is from then on the type checker will know
11:15:26 <jmcarthur> *and from then on
11:15:37 <kgadek> jmcarthur: exactly. But I'm stuck at "how to preserve all of that in runtime" etc
11:15:57 <jmcarthur> kgadek: i don't think i understand
11:16:12 <kgadek> supki: thanks, I'll dive into whole thread
11:16:26 <jmcarthur> kgadek: you said you wanted the IO to return an n-vector of integers. the only way the n can appear in the type is if the n is known.
11:16:45 <jmcarthur> kgadek: alternatively, you could say it returns Maybe (NonEmpty a)... no dependent types are even needed, then
11:16:55 <jmcarthur> sorry...  Maybe (NonEmpty Int)
11:18:19 <jmcarthur> kgadek: but no matter what, you still have to say what to do with it's actually empty. that's just how it works, because you can't typecheck the user of your program.
11:18:24 <kgadek> jmcarthur: easier one: is it possible to write "foo :: n -> [a] -> Vector n a" where [a] is of length n?
11:18:49 <jmcarthur> kgadek: you would have to also take an argument that proves that the length of the list is n
11:18:50 <kgadek> jmcarthur: but probably I could typecheck the path in my program
11:19:15 <kgadek> hm.
11:19:52 <kgadek> so in such case I always need a runtime value that would be a "proof" to my property?
11:20:02 <kgadek> isn't it possible to do it other way around?
11:20:02 <jmcarthur> kgadek: it doesn't necessarily have to appear at runtime
11:20:05 <vanila> kgadek, you could try this out in idris if you want
11:20:14 <jmcarthur> kgadek: but it does have to be a value that appears at least at compile time
11:20:23 <vanila> it has IO
11:20:27 <jmcarthur> kgadek: the compiler could make it disappear
11:20:48 <pleberto> is it possible to define a function foo :: T -> Int -> a that returns the xth property of a type T ?
11:20:54 <pleberto> using lens or something?
11:20:59 <jmcarthur> pleberto: define "property"
11:21:12 <pleberto> jmcarthur: like if I have a constructor T a b c
11:21:18 <pleberto> a b c are the properties
11:21:24 <jmcarthur> fields?
11:21:26 <pleberto> yeah
11:21:26 <kgadek> jmcarthur: ok, I think that I need to do more research anyway… thank you!
11:21:40 <jmcarthur> pleberto: you could define the appropriate instances for T so that you can use _1, _2, etc.
11:21:42 <jmcarthur> :t _1
11:21:43 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
11:22:17 <jmcarthur> :t view _1
11:22:18 <lambdabot> (Field1 s s a a, MonadReader s m) => m a
11:22:21 <jmcarthur> blah
11:22:22 <pleberto> jmcarthur: is it possible to do it generically?
11:22:28 <dolio> There is no requirement that a value of type 'T a b c' have as, bs, and cs in them.
11:22:34 <pleberto> maybe using template haskell?
11:22:34 <jmcarthur> this is about as generic as i can think of
11:22:41 <jmcarthur> dolio: i think he meant a value constructor
11:23:08 <jmcarthur> pleberto: you could do something. i don't know what purpose this would serve, though. it still amounts to writing some type class instance or something.
11:23:31 <pleberto> what im generally looking for is type -> tuple of fields
11:23:58 <pleberto> well an instance of a type/contructor
11:24:34 <pleberto> For some reason im thinking of constructors as types, is this wrong?
11:25:02 <pleberto> a constructor is like a type that has a more generic type right?
11:25:11 <hodapp> er, constructors are functions
11:25:21 <pleberto> you can pattern match on constructors though
11:26:48 <pleberto> does lens use templatehaskell?
11:27:13 <edwardk> pleberto: it can
11:27:29 <pleberto> what do you mean edwardk ?
11:27:38 <pleberto> i mean does it use template haskell in its own code?
11:27:48 <edwardk> i mean that lens has Control.Lens.TH to provide template haskell to users
11:28:09 <edwardk> it has i think 2-3 modules that use template-haskell internally to define stuff that would be more bug-ridden to define without it
11:28:15 <pleberto> edwardk: are those special parts of lens for use in template haskell?
11:28:40 <edwardk> well, 'makeLenses' is a combinator provided by lens for template-haskell use
11:29:37 <edwardk> but it also makes use of template-haskell to define some things internally, e.g. System.IO.Error.Lens because there are a bunch of fiddly prisms to make there and the set of them has changed continuously over the course of GHC's development
11:29:54 <edwardk> so it'd otherwise have to use a bunch of CPP to get the set of them right
11:30:08 <edwardk> http://hackage.haskell.org/package/lens-4.4.0.1/docs/System-IO-Error-Lens.html
11:30:56 <edwardk> i'm committed to removing the latter eventually, if there is demand, but the former will stick around, its too useful and too widely used, even if we get the new overloaded record field proposal, the existing lens machinery for template haskell is better in many ways
11:30:59 <edwardk> afk a bit, meeting
11:35:30 <halvorg> Which aeson version should I use? newest?
11:36:00 <halvorg> There is no dedicated stable/development versioning on hackage, confuses me.
11:36:32 <monochrom> I think, by convention, every version posted on hackage is deemed stable
11:37:08 <halvorg> Ok, that's good to know.
11:37:11 <clrnd> hey, suppose I have a ByteString like "201 25 4032" and I want something like a Vector Int from it, Vecotr only because it's a very large list, how could I do it?
11:37:17 <monochrom> there are some exceptions but the authors will note them on the front page
11:37:48 <clrnd> I thing going to-then-from List would mess up performance
11:43:20 <clrnd> well already found how, https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy-Char8.html#g:25
11:44:17 <RoxRacoon> What is this about?
11:44:39 <monochrom> parsing a string to a Vector of Int
11:44:50 <monochrom> err, s/string/bytestring/
11:45:35 <RoxRacoon> No haskell.. What is this channel about?
11:45:54 <monochrom> the programming language called Haskell
11:45:59 <simpson> RoxRacoon: This channel is for the Haskell programming language.
11:46:06 <RoxRacoon> Yes but what is special about it
11:46:13 <c_wraith> It's good.
11:46:13 <monochrom> there are a lot of URLs on the topic line. I'm sure one of them helps you.
11:46:34 <c_wraith> correction.  it's less bad than everything else I've tried.  :)
11:46:48 <RoxRacoon> Should i learn it? Past knowlage is php, c# and sql
11:47:25 <c_wraith> RoxRacoon: it's very different from all of those.  It's not likely to be an easy thing to pick up, or something you can use often.  But it may change the way you think about programming.
11:47:30 <hodapp> RoxRacoon: It will likely completely change how you view programs if you do.
11:47:42 <c_wraith> (technically, you can use it for many things.  Politically is another issue)
11:48:18 <monochrom> I only know what is not special about Haskell. it can't wash your dishes. it can't guess what you want. it can't do your laundary.
11:48:33 <glguy_> monochrom: You should probably upgrade, it does dishes now
11:48:44 <monochrom> haha
11:49:00 <c_wraith> worst of all, Haskell doesn't free you from needing to communicate clearly what it is what you want your program to do.
11:49:10 <c_wraith> *that you want.
11:49:56 <monochrom> I think that PHP actually encourages you to believe that the computer can guess what you mean. So Haskell will be very refreshing in the lack of that apparent ability.
11:50:22 <glguy_> The computer *does* guess
11:50:30 <glguy_> php that is
11:50:37 <pjdelport> {- LANGUAGE DoTheDishesToo -}
11:50:46 <c_wraith> pjdelport: you forgot the #s!
11:50:51 <charlie> auto everything :P
11:51:18 <pjdelport> c_wraith: It's not entirely implemented yet. :)
11:52:10 <RoxRacoon> Is it web centered or?
11:52:39 <monochrom> what makes a language web-centered or not-web-centered?
11:52:59 <monochrom> what is the precise, objectively checkable criterion?
11:53:00 <geekosaur> "... is what I point to when I say ..."
11:53:05 <geekosaur> :p
11:53:28 <c_wraith> @quote Jafet research.language
11:53:29 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
11:53:29 <RoxRacoon> Is it ment for web use?
11:53:34 <josephle> if your browser comes packaged with an interpreter for a language, I would think it is safe to say that language is web-centered :P
11:53:51 <josephle> but that's a very narrow definition
11:53:57 <Hafydd> #!/usr/bin/env sudo runghc
11:53:58 <Hafydd> {-# LANGUAGE MakeMeASandwich #-}
11:53:59 <c_wraith> RoxRacoon: haskell is meant to be a general-purpose language
11:54:10 <clrnd> monochrom, yeah, I'm trying to parse a lot of Ints, but I have a problem
11:54:17 <monochrom> I don't think "meant to" is objectively checkable.
11:54:20 <geekosaur> apparently web is so very magical special for some people that languages either are intended specifically for it or are obsolete/useless/???
11:54:21 <c_wraith> RoxRacoon: there are web frameworks, but that's just because people like using the language, not because it was a design goal
11:54:22 <pjdelport> RoxRacoon: http://www.haskell.org/haskellwiki/Introduction
11:54:49 <dv->  haskell sucks for web programming
11:55:07 <vanila> dv- it's not quite as mature as PHP but give it time :)
11:55:31 <monochrom> I also don't think that "meant to" is relevant in practice.
11:55:45 <RoxRacoon> Well thanks for all the help, will consider learning it due to what seems a helpful community :)
11:55:51 <monochrom> Lisp is meant to take over the world. It ended up not taking over the world.
11:56:47 <lpvb> clojure is a lisp
11:56:50 <lpvb> it's pretty popular
11:56:59 <hodapp> Clojure is quite nice.
11:56:59 <monochrom> ML is meant for writing theorem provers. It ended up getting many more applications than theorem provers.
11:57:13 <hodapp> PHP was meant for writing dinky little homepages.
12:01:34 <monochrom> SQL was meant for everything except storing web forum messages. Hell there was no web back then. It ends up storing nothing except web forum messages.
12:15:10 <yukko> is there a way to trace what function/file triggered an undefined exception
12:15:33 <yukko> some library I'm using is doing it and I don't know which one
12:16:35 <geekosaur> compile with profiling and -rtsopts, run with +RTS -xc ?
12:18:05 <clrnd> well finally got arround to learning bytestrings and damn, AsFastAsCee in your face
12:19:44 <chrisdone> unsafePerformPerfectMelbourneShuffle
12:21:59 <dreams> yukko: stack trace
12:28:41 <haz-a-question> c_wraith & jfischoff: Thanks again for pointing me to Monad Transformers & EitherT earlier. After some research/learning I got it to work exactly as I expected. That guidance was exactly what I needed!
12:29:57 <tobiasgw> I've been looking into the UnitTyped library (https://hackage.haskell.org/package/unittyped-0.1/docs/UnitTyped.html) and I'm quite fascinated by the way it let's you express values with associated units
12:30:35 <tobiasgw> for instance, you can write "1 meter" or "30 seconds"
12:31:27 <tobiasgw> but I don't understand how this is implemented? Why does the compiler allow a number to come before a function?
12:31:35 <c_wraith> tobiasgw: it's a little fragile, though.  It depends on creating a function instance for Num
12:31:45 <c_wraith> tobiasgw: it will conflict with any other library that does the same thing
12:31:45 <merijn> tobiasgw: I think it abuses Num instances :)
12:31:48 <tobiasgw> I would understand "meter 1" where meter is a function
12:31:56 <c_wraith> :t 1
12:31:57 <lambdabot> Num a => a
12:32:03 <tobiasgw> I see
12:32:12 <merijn> tobiasgw: Keep in mind that numeric literals are overloaded to be "fromIntegral 1", etc.
12:32:51 <tobiasgw> so you could make Num instances for your own types?
12:32:56 <merijn> If you have a Num instance for "Num a => Num ((a -> Foo) -> Foo)" and "meter :: a -> Foo" then it type checks
12:33:01 <merijn> tobiasgw: You can, yes
12:33:08 <merijn> tobiasgw: In fact, lots of people do
12:33:21 <merijn> Think of num instances for vectors in vector libraries, etc.
12:33:24 <tobiasgw> does it have any down sides?
12:33:38 <tobiasgw> since you refer to it as abuse ;)
12:33:39 <merijn> tobiasgw: Well, having one for functions is very brittle
12:34:00 <merijn> tobiasgw: For "real" types, there's not really any downsides (unless the instances are wrong)
12:34:24 <tobiasgw> ok
12:34:29 <tobiasgw> good to know
12:34:30 <tobiasgw> :)
12:34:31 <merijn> tobiasgw: The abuse is in the fact that it implements an instance for functions, which will overlap with ever other instance for functions, which is brittle
12:35:01 <c_wraith> tobiasgw: that library will do something like:  instance Num a => Num (Unit -> a) where...
12:35:09 <tobiasgw> oh, so that implementation will be the instance for all functions, no matter the signature of the function?
12:35:17 <merijn> tobiasgw: But adding instances for things like complex number, i.e. "data Complex a = Complex a a" with "instance Num a => Num (Complex a)" is safe
12:35:46 <merijn> tobiasgw: Because that can only conflict with other instances for Complex, which shouldn't exist anyway
12:35:47 <c_wraith> well, instance resolution is a little complicated.  But in general, it will conflict with other instances with (->) as the top-level type constructor
12:36:57 <merijn> tobiasgw: In fact, being able to define your own instances for typeclasses is the main feature they were designed for. It means you can make your own Monoids, Ord, Functors, etc. too
12:37:23 <tobiasgw> I guess it reads nicely with "1 meter" rather than "meter 1"
12:37:53 <tobiasgw> although "meter 1" would be simpler to implement
12:38:02 <merijn> tobiasgw: Anyway, I think it's a neat library, but I probably wouldn't use it for "serious" work
12:38:12 <Tuplanolla> Has a floating point monad or such ever been suggested? Having one seems reasonable since floating point numbers are incompatible across architectures and operations on them exhibit arbitrary error propagation.
12:38:23 <dolio> People probably shouldn't be writing instances for functions anyway. So there shouldn't be anything to conflict with.
12:38:38 <dolio> But that of course means that neither should the units library do it.
12:38:46 <merijn> Tuplanolla: Floating points incompatible across architectures? Which architectures are incompatible?
12:38:47 <tobiasgw> dolio: hehe, right
12:39:36 <Tuplanolla> Anything that doesn't follow IEEE 754 or uses extra precision, merijn.
12:40:07 <tobiasgw> merijn: I really like the idea of having units checked by the compiler, is there another lib you would rather use for "serious" work?
12:40:39 <merijn> Tuplanolla: Right, but I don't think there's a haskell compiler for platforms without IEEE754 support?
12:40:48 <merijn> Tuplanolla: So it doesn't seem very useful?
12:40:58 <simpson> Tuplanolla: I thought about it for a minute and couldn't come up with a good example. Are there popular platforms that have non-IEEE 754 floats?
12:40:59 <Tuplanolla> The use would be to discourage people from using floating point numbers.
12:41:00 <merijn> tobiasgw: I would just do the dumb thing and use lots of newtype
12:41:27 <merijn> tobiasgw: That requires explicit conversions, but usually you don't have that many different units anyway
12:41:38 <merijn> tobiasgw: i.e. "newtype Meters = Meter Int" or something
12:41:55 <pleberto> How should I go about learning about formal verification? I currently have basic understanding of types.
12:41:58 <Kackao_> ist this http://s14.directupload.net/images/140825/z93pz7qp.jpg al pacino?
12:42:22 <tobiasgw> merijn: seems sensible :)
12:42:23 <Tuplanolla> Pick up a book like CPDT or SF, pleberto.
12:42:43 <pleberto> What are those?
12:42:44 <latk> I've got a string like "Mr James Brown BSc Mrs Jane Smith Md", and want to parse each entity and their pre/post titles. Could anyone offer some guidance using attoparsec to do this? I am finding it difficult to stop the "name" parser just eating everything..
12:42:52 <Tuplanolla> http://adam.chlipala.net/cpdt/
12:43:03 <dolio> Which platforms don't support IEEE754?
12:43:07 <Tuplanolla> http://www.cis.upenn.edu/~bcpierce/sf/
12:43:16 <pleberto> google 'Council of Certified Dog Trainers' lol
12:43:22 <merijn> latk: Well, without delimiters how do you know when a name ends?
12:43:30 <haz-a-question> \quit
12:43:45 <pleberto> Tuplanolla: which one should I start with?
12:43:48 <latk> merijn: You don't. It won't be perfect, but I would like some kind of semi working thing :s
12:43:50 <merijn> pleberto: Software Foundations is a good book (and free!)
12:43:53 <Tuplanolla> Whichever approach you prefer, pleberto.
12:43:58 <latk> (otherwise I will have to do it by hand!)
12:44:09 <pleberto> I have no idea what either approach is lol
12:44:19 <merijn> pleberto: Assuming you have like basic-intermediate experience with haskell types
12:44:30 <Tuplanolla> One could say CPDT is more practical.
12:45:18 <pleberto> merijn: yeah?
12:45:19 <merijn> pleberto: Software Foundations is a book about formally proving properties of programs using Coq, it has lots of exercises and examples. If you use Proof General (emacs) or Coquille (vim) you can dynamically step through proofs and see how they work and interactively do the exercises too
12:45:42 <Tuplanolla> Both books are like that.
12:45:52 <merijn> I have no experience with CPDT, so I can't offer any comment :)
12:46:09 <pleberto> I've been hearing a lot of whispers floating around the web that coq is outdated
12:46:13 <pleberto> is this true?
12:46:17 <Tuplanolla> No.
12:46:22 <pleberto> ok cool
12:46:24 <monochrom> latk: first define a grammar. it represents the assumptions you make. you can be wrong for assuming them, but you already know that. you need to make explicit your assumptions. that is the purpose of the grammar.
12:46:35 <pleberto> thanks Tuplanolla merijn
12:47:04 <merijn> pleberto: No, Coq is still pretty much the state of the art for theorem proving
12:47:18 <pleberto> Tuplanolla: which book would you say is better for a begginer?
12:47:19 <merijn> pleberto: Nowadays there's Agda too, but it has a very different approach and I wouldn't use them for the same things
12:47:54 <pleberto> merijn: ive been hearing people talk about twelf and hott, and saying they are better than coq :S
12:48:38 <int-e> then there's Isabelle, HOL4, a couple more
12:48:39 <latk> monochrom: I believe I've started to do this - in that I have types to represent pretitle name and posttitle. Unfortunatley, because name (the middle bit) can in theory be any string, it kinda takes over. Is there some easy way of creating a parser for all strings appart from those that represent another parser? Or something to that effect ?
12:48:50 <merijn> pleberto: HoTT is the new hot thing, yes, but it's not going to replace Coq any time soon
12:48:57 <pleberto> ah ok
12:48:58 <monochrom> pleberto: you will eventually learn everything. but you can only learn one thing at a time. (unless you say, you can use your left eye to learn one thing, and your right eye to learn another thing, simultaneously.) you must linearize. randomly pick one and start learning.
12:49:17 <mathk> Hello everyone! I was working on implementing foldl with foldr and was wondering if my implementation is correct, maybe someone more experienced could take a quick look at it: http://lpaste.net/110000
12:49:37 <merijn> pleberto: Things like Twelf, hott, etc. are different ways of doing things, they are not necessarily better (at least we're not sure) and Coq has several decades of tools, books and stuff behind it :)
12:49:47 <pleberto> monochrom: ive started learning things like that before only to realize that i skipped a bunch of prerequisites and dont understand anything
12:49:50 <merijn> pleberto: So it'll be significantly easier to learn and use than the others :)
12:49:59 <monochrom> the middle bit cannot be any string. No one is called "Mr Mr Mrs BSc". the middle bit cannot contain Mr or Mrs.
12:50:03 <pleberto> ok ill do coq then
12:50:06 <pleberto> thanks
12:50:08 <merijn> mathk: Sounds like a time to learn QuickCheck ;)
12:50:18 <monochrom> you have enough prerequisite to learn Coq.
12:50:37 <pleberto> do you guys think formally verified operating systems are the future?
12:50:54 <mathk> merijin: I'll have to google that, thanks!
12:51:00 <merijn> pleberto: Intermediate haskell is more than sufficient for Coq, SF actually begins with just "basic functional programming" chapter which should feel like "easy intro exercises" to anyone who knows haskell ;)
12:51:13 <pleberto> ah ok
12:51:43 <latk> monochrom: True. Is there some way to define a parser in attoparsec that is all strings except [strings] ?
12:52:19 <monochrom> I don't understand the question
12:53:11 <int-e> mathk: step x g a = g (f a x) is \x g -> g . (`f` x), so there's a crucial difference.
12:53:36 <int-e> > foldr (-) 0 [1..10]
12:53:37 <lambdabot>  -5
12:54:09 <latk> So in general a name could be anything. I could define that by many anychar. This is actually not what I want. Is there any way to get what I actually want (e.g. not parsing Mr or BSc as a name)?
12:54:16 <latk> Other than defining things twice, that is
12:54:41 <pleberto> whats a better editor for haskell? vim or emacs?
12:54:56 <merijn> mathk: QuickCheck is a library for randomized testing, so you'd write "\f z l -> foldl f z l == myFoldl f z l" and it'd throw a bunch of random lists at your code and check that your foldl and actual foldl produce the same results
12:55:02 <monochrom> where can I read your grammar?
12:55:05 <merijn> mathk: And if it fails it will print what it failed on
12:55:35 <merijn> pleberto: I would use whichever you're comfortable with, there appears to be a rough 50-50 vim/emacs split around here
12:55:56 <pleberto> ok ill stick with vim then
12:56:27 <merijn> pleberto: syntastic + hdevtools are kinda nice in vim for haskell (the hdevtools on hackage is broken, but I have a working branch on my github)
12:56:28 <monochrom> you should learn both emacs and vim. it will be vain gloriously rewarding.
12:56:34 <Tuplanolla> I use Vim just because it requires me to type less keys.
12:56:50 <merijn> monochrom: I tried emacs, it just makes me sad :(
12:57:22 <sivteck> ugh, stay with whatever editor you know, when you are learning something new >.>
12:57:23 <pleberto> merijn: i actually had a nice setup for vim based on a collection of tools other people used, im going to try and set that up
12:57:35 <monochrom> I did so and never looked back. it is so much satisfying to watch people argue over emacs vs vim, and find that I'm agnostic and therefore above both sides :)
12:57:56 <Tuplanolla> I've often hoped for a more powerful and abstract editor.
12:58:04 <pleberto> the only thing is, emacs seems to have much better windows support
12:58:05 <Preyer> merijn: I'm also a beginner in emacs, the built-in tutorial was pretty good and this was a wonderful read: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
12:58:12 <Tuplanolla> Vim feels so primitive even with all the modes.
12:58:15 <pleberto> vim on windows is hell
12:58:15 <merijn> monochrom: "Well, the important thing is that you've found a way to feel smugly superior to both sides" ;)
12:58:38 <merijn> pleberto: Really? I used gvim for years on windows and it worked well enough?
12:59:12 <pleberto> oh really, last time i tried it, it was unusable, ill try again
12:59:12 <merijn> Preyer: I don't have any motivation or time to learn emacs
12:59:32 <merijn> pleberto: anyway, if you plan to do Software Foundations (or Coq in general), get https://github.com/the-lambda-church/coquille
12:59:38 <pleberto> ok
13:00:16 <merijn> pleberto: (Plus some useful keybindings here: https://github.com/merijn/dotfiles/blob/master/vim/ftplugin/coq.vim)
13:00:34 <pleberto> ah ok cool
13:00:48 <pleberto> that coqide looked kinda sketchy
13:00:50 <merijn> pleberto: Especially the . one is nice, it means that if you type . in insert mode (which ends a Coq command) it will automatically run it in the interactive prover
13:01:06 <merijn> pleberto: It sucks, it doesn't even have "jump to beginning of line", it's an utter pain
13:01:16 <pleberto> ah :P
13:01:35 <merijn> pleberto: Coquille basically makes vim look the same, one "file" window and two interactive windows where it shows the current proof state
13:01:55 <pleberto> ok cool thanks!
13:02:06 <merijn> oh, you need to follow the README and install vimbufsync or it won't work
13:02:19 <pleberto> okay
13:03:05 <TallerGhostWalt> So, I am just discovering HStringTemplate
13:03:10 <TallerGhostWalt> seems really cool
13:06:40 <mathk> int-e: Thanks! But ((`f` x2) . (`f` x1) . id) and (id . (`f` x1) . (`f` x2)) evaluate in the same way, don't they?
13:07:12 <int-e> mathk: no. try f a b = b - a
13:08:28 <Tuplanolla> Only if they commute, mathk.
13:09:02 <int-e> mathk: id is an identity for (.), so you have (`f` x2) . (`f` x1) and (`f` x1) . (`f` x2) ... evaluating the same two functions but in different order.
13:10:01 <mathk> Hm, I get the same results with [foldl / myFoldl] (\a b -> b - a) 0 [1..5]
13:10:20 <mathk> Sorry if I'm missing something here and thanks for your input!
13:11:53 <athan> hey guys, why do cabal flags make installs escape sandboxes?
13:12:00 <athan> er - using cabal flags
13:12:09 <athan> custom ones defined in your .cabal file, I mean
13:12:55 <dcoutts_> athan: can you explain what you mean?
13:13:51 <athan> dcoutts_: Do you know what cabal flags are?
13:14:04 * dcoutts_ is one of the authors/maintainers of Cabal
13:14:26 <dcoutts_> athan: yes
13:15:07 <dcoutts_> athan: assume I know all about Cabal, but that I don't know exactly what you mean
13:15:16 <athan> dcoutts_: Okay, so when I refer to a "cabal flag", I specifically mean one defined on a per-package basis though the `flag` directive in the package's .cabal file
13:15:26 <athan> You got it
13:16:08 * dcoutts_ doesn't know what "installs escape sandboxes" refers to
13:16:11 <athan> dcoutts_: I would like to compile my package in a sandbox, but use one of the flags. How would I do so?
13:16:37 <dcoutts_> in the normal way, same as outside a sandbox
13:16:40 <athan> The `cabal install` command becomes a global one, instead of using the sandbox
13:17:05 <athan> dcoutts_: via `cabal install -f{flag}`, right?
13:17:11 <dcoutts_> yep
13:17:11 <int-e> mathk: ah flip (-) is tricky. myFoldl (flip (-)) 0 [1,2] != myFoldl' (flip (-)) 0 [1,2], but it works for lists of odd length.
13:17:23 <athan> dcoutts_: When I do that, the install performs outside the sandbox
13:17:36 <dcoutts_> athan: can you show an example of this, e.g. a log
13:17:36 <int-e> mathk: I should've suggested something based on (++).
13:18:02 <int-e> mathk: like foldl (++) "" ["a","b"]
13:18:03 <athan> dcoutts_: Would stdout do?
13:18:17 <dcoutts_> athan: yep, e.g. with -v so we can see the details of what it's doing
13:18:42 <athan> Sure thing
13:20:03 <mathk> int-e: Yeah, that does the trick... I think i worked it out now, thank you!
13:21:13 * glguy_ believes that athan is asking either "How can I do a sandboxed build of an executable but then install it in user or global" or that it's doing that and he doesn't want it to
13:22:34 <athan> glguy_: Almost
13:23:41 <athan> glguy_: The flag is making the build itself global, but I want it sandboxed
13:26:23 <glguy_> alright, well, if my guess was wrong you should continue making that output paste for dcoutts_ :)
13:26:26 <int-e> athan: do you have a concrete example that people could reproduce? (cabal sandbox init; cabal install foo)?
13:26:56 <int-e> and yeah, dcoutts_ is the expert
13:26:59 <doismellburning> a/win 61
13:27:05 <doismellburning> sorry
13:27:17 <athan> int-e: Yes! It's from the Yi project - If you get the latest source from git, do a cabal sandbox init, and a `cabal install -fvty`.
13:31:43 <int-e> athan: hmm. vty from git, too?
13:32:13 * dcoutts_ hits the same problem as int-e 
13:32:59 <athan> You guys are great
13:34:30 <dcoutts_> and vty doesn't declare it's source repo
13:34:44 <int-e> but a homepage which is a git repo
13:34:49 <athan> http://lpaste.net/110004
13:34:49 <dcoutts_> athan: this would be easier if you could show us your log demonstrating the problem
13:34:54 <dcoutts_> ah...
13:34:58 <athan> dcoutts_: ^
13:35:05 <athan> it doesn't attempt to use the sandbox
13:35:53 <dcoutts_> athan: what makes you say that?
13:36:38 <athan> From the first line of the log - the typical statement "Notice: installing into a sandbox located at
13:36:38 <athan> /home/athan/dev/yi/yi/.cabal-sandbox" Isn't there
13:36:49 <athan> first few lines of the log*
13:37:58 <int-e> maybe add the output of  ghc-pkg list ?  this looks like you have globally installed packages.
13:38:18 <int-e> athan: note that the "Notice: using sandbox..." usually comes after resolving dependencies.
13:38:44 <athan> int-e: a sandbox uses global packages?
13:38:46 <int-e> and it's failing that first step
13:38:49 <dcoutts_> athan: it only says that when it's about to install
13:38:50 <int-e> athan: yes.
13:38:58 <athan> Oh!!
13:39:01 <dcoutts_> athan: but in your example it never gets that far
13:39:03 <int-e> athan: of course, that's where it gets the base library, for example.
13:39:04 <dcoutts_> because the dep planning fails
13:39:27 <athan> cabal hell is rooted deeply
13:39:43 <dcoutts_> it's not cabal hell, it's a genuine dependency conflict
13:39:58 * hackagebot darcs 2.8.5 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.5 (GaneshSittampalam)
13:40:07 <int-e> athan: it might work if you try  cabal install -fvty path-to-git-version-of-vty/ path-to-git-version-of-yi/
13:40:12 <johnw> didn't know darcs was still being worked on
13:40:53 <int-e> dcoutts_: does the sandbox consistency requirement extend to global packages?
13:41:11 <athan> int-e: Hmm
13:41:11 <merijn> dcoutts_: This follows my earlier observation that noone using the term "cabal hell" nowadays seems to have any clue what it means, I think that less than 1 in 50 or 100 uses are actually cabal related
13:41:25 <merijn> It seems that it's just fashionable to call any dependency problem "cabal hell"
13:41:37 <dcoutts_> merijn: yeah, I know :-( I'm resigned to it
13:41:41 <alcabrera> I heard there was some work going on for GSoC this summer with darcs, johnw. update 2.8.5 might reflect some of that.
13:41:41 <athan> merijn: We need a dictionary :/
13:41:59 <dcoutts_> int-e: hmm, good question
13:42:16 <merijn> athan: Cabal hell stems from the time where cabal was...less careful and would silently upgrade/reinstall packages, breaking half your installed packages without you noticing
13:42:19 <int-e> merijn: that's because people have forgotten about the days where cabal-install would reinstall packages without much care, breaking them a lot :)
13:42:19 <dcoutts_> int-e: not sure if it extends to the whole global db or just to the subset that's used by the sandbox
13:42:27 <athan> dcoutts_ | int-e: Here's my ghc-pkg list, if that clears anything up :/ http://lpaste.net/110005
13:42:56 <dcoutts_> athan: can you re-run and show us the log, with the flag --max-backjumps=-1
13:42:59 <athan> merijn: That sounds more like cabal deception  to me :o
13:43:34 <merijn> athan: Most (like 95%) of the problems people have are "my dependencies conflict and cabal gives up"
13:43:36 <athan> dcoutts_: You got it
13:43:54 <merijn> athan: Which is really the fault of your dependencies and not cabal :)
13:44:00 <int-e> athan: oh, you already had a sandbox. have you tried starting from scratch, issuing 'cabal sandbox delete'?
13:44:22 <athan> merijn: I bet :/. I think it would be cool if we had a dictionary in lambdabot, though. For terms like homomorphism, natural transformation, and the like :)
13:44:32 <athan> like quoting lambdabot itself or something
13:44:41 <int-e> athan: the package list is fine, cabal-install should not pick up vty from there. an existing sandbox, however ...
13:44:45 <athan> int-e: Too many times :/
13:45:01 <ion> @quote @quote
13:45:02 <lambdabot> mauke says: @quote vim
13:45:03 <athan> merijn: D:
13:45:31 <dcoutts_> athan: looks like the problem is simply that yi needs lens >= 4.4, but the latest available vty needs < 4.2
13:45:43 <dcoutts_> athan: and the solution is probably to find the development version of vty
13:45:44 <int-e> athan: well, I've successfully built  yi  with -fvty, using the git version of vty
13:46:30 <int-e> athan: all in a sandbox.
13:46:31 <athan> int-e: Ahhhh, wow. That's a relief. Thanks, dcoutts_, I've learned my lesson!
13:46:43 <athan> int-e: Did you use add-source?
13:47:22 <int-e> athan: no, I used   cabal install vty/; cabal install -fvty yi/yi/. but there's no reason that add-source should fail, I think.
13:47:53 <athan> int-e: I'm having a very strange inconsistency with add-source in a yesod application
13:49:27 <athan> int-e: But thank you, that helps a million times over.
13:49:37 <dez_> is this an appropriate place to ask very beginner questions?
13:49:54 <int-e> dez_: yes
13:50:47 <dez_> I have two functions to make a list of integers from an integer one works and the other doesn't and I have no idea why
13:50:59 <dez_>  toDigitsFail :: Integer -> [Integer] toDigitsFail n          | n < 1 = []          | otherwise =  (toDigitsFail (n `div` 10)) : (n `mod` 10)    toDigitsWorks :: Integer -> [Integer] toDigitsWorks n          | n < 1 = []          | otherwise =  (n `mod` 10) : toDigitsWorks (n `div` 10)
13:51:20 <glguy_> dez_: This is a fine place for the quesiton, but please put the code on http://lpaste.net
13:51:21 <dez_> humm... formatting could be a problem
13:51:23 <glguy_> and not in the channel
13:51:31 <dez_> ok
13:52:20 <int-e> (toDigitsFail (n `div` 10)) : (n `mod` 10) <-- this is in the wrong order.
13:52:55 <monochrom> it won't typecheck
13:53:05 <dez_> does recursion have to go last?
13:53:10 <stelleg> yeah I'm guessing thats what he means by fail
13:53:16 <int-e> (:) is a cons, it takes a list element (the head) and the remainder of the list (the tail). You cannot simply swap the two.
13:53:20 <glguy_> :t (:)
13:53:21 <lambdabot> a -> [a] -> [a]
13:53:27 <monochrom> you could try (toDigitsFail (n `div` 10)) ++ [n `mod` 10] but it will be slow
13:53:42 <monochrom> recursion can appear anywhere as long as type-correct
13:53:43 <dez_> ahhh
13:53:46 <int-e> x : xs = [x] ++ xs
13:53:59 <dez_> I understand, thank you
13:54:43 <dez_> : is not like magic glue the first element has to be an element. duh ok, thanks again
13:56:04 <pjdelport> dez_: Feel free to ignore this suggestion if you don't want to get into using recursion patterns yet, but if you do, the above is a good example of something that's suited to unfoldr
13:57:16 <dez_> pjdelport: thanks I will look at that too.
13:57:42 <pjdelport> dez_: No rush, if you're just learning. :)
13:58:20 <dez_> shoud I remove my code from lpaste?
13:58:27 <monochrom> there is no need
13:58:37 <dez_> ok, thanks again
14:10:02 * hackagebot xkbcommon 0.0.1 - Haskell bindings for libxkbcommon  http://hackage.haskell.org/package/xkbcommon-0.0.1 (AukeBooij)
14:13:15 <lpaste> burp pasted “FunPtr on CString” at http://lpaste.net/110008
14:13:44 <monochrom> eh! the lpaste bot is back?
14:13:54 <burp> anyone familiar with System.Posix.DynamicLinker and Foreign.Ptr can have a look at my three lines? :D
14:14:03 <burp> I expect it to output "bla blub foobar"
14:14:08 <burp> instead I get garbage
14:14:25 <monochrom> which package has System.Posix.DynamicLinker?
14:14:33 <burp> unix
14:17:37 <burp> the same thing with a double dtest = 12345; works
14:18:43 <burp> "castFunPtrToPtr :: FunPtr a -> Ptr b "
14:18:48 <burp> "Note: this is valid only on architectures where data and function pointers range over the same set of addresses, and should only be used for bindings to external libraries whose interface already relies on this assumption."
14:18:56 <burp> is this a valid assumption on x86_64?
14:19:13 <monochrom> yes I think so. also, the double eample works
14:27:06 <carter> Yup, same memory space ish
14:27:18 <carter> not true on IOS
14:27:58 <monochrom> I know. double deference. you need to treat it as Ptr (Ptr CChar) i.e. Ptr CString
14:28:10 <monochrom> s/deference/dereference/
14:28:21 <burp> isn't that already the case when I use peekCString?
14:28:26 <monochrom> no!
14:28:53 <monochrom> peekCString is just CString i.e. Ptr CChar. not enough Ptr
14:28:59 <burp> arg CChar
14:29:08 <athan> int-e | dcoutts_ : It's installing :'D thanks for all your help, you deserve more recognition for what you do
14:29:10 <burp> dang, thanks
14:29:26 <monochrom> double -> double* -> Ptr CDouble. char * -> (char *)* -> Ptr (Ptr CChar)
14:29:34 <dcoutts_> athan: cheers
14:30:20 <burp> so what I want to have after dlsym/castFunPtrToPtr is a Ptr (Ptr CString)
14:30:54 <burp> so I guess it's just another peek
14:31:06 <monochrom> yeah
14:39:11 <phaazon> The Glorious Glasgow Haskell Compilation System, version 7.8.3
14:39:15 <phaazon> YES <3
14:39:27 <monochrom> congrats
14:39:33 <phaazon> I removed my debian and installed archlinux
14:39:39 <phaazon> pacman -S ghc gives me that <3
14:39:41 <hpc> we need to hurry up with the updates, firefox is on version 31
14:40:09 <monochrom> HTTP is on version 4000. no one will exceed that for a while. :)
14:40:17 <phaazon> talking about versions, something that always makes me curious: what is the purpose of the super-major version number?
14:40:21 <monochrom> also, Haskell Platform is on 2014 :)
14:51:39 <benmachine> phaazon: it has no strictly-defined purpose, but it still has value for communicating "how excited should you feel about this"
14:57:26 <phaazon> benmachine: yeah well
14:58:12 <benmachine> plus, like, upgrade a major version if anything breaks, upgrade a super-major version if everything breaks
15:00:24 <phaazon> the only purpose I’d find would be for a game engine or that kind of stuff
15:00:24 <phaazon> 0.x.y.z would be the initial engine
15:00:24 <phaazon> 1.x.y.z would be the first public version, and so on
15:00:24 <phaazon> but I don’t like that
15:01:26 <dmj`> in aeson, is there a way to override the default implementation for [a]
15:01:41 <dmj`> instance FromJSON a => FromJSON [a] where ...
15:02:24 <phaazon> what the…
15:02:25 <phaazon> Loading package transformers-0.4.1.0 ... <command line>: can't load .so/.DLL for: libHStransformers-0.4.1.0.so (libHStransformers-0.4.1.0.so: cannot open shared object file: No such file or directory)
15:02:41 <monochrom> perhaps define "newtype My a = My [a]", "instance FromJSON a => FromJSON (My a) where ...". then to choose your instance, make sure you use the type My a rarther than [a].
15:05:08 <dmj`> monochrom: yea, that's what I'm currently doing now, it kind of muddies the api, since users have to take on the cognitive overhead of understanding that "My a" just represents a list
15:05:55 <monochrom> it is really important to ditch the provided [a] instance?
15:06:27 <monochrom> phaazon: perhaps the missing files are in a separate pac thing
15:06:41 <monochrom> whatever archlinux calls a package
15:06:42 <Haskellfant> is there something like liftM for applicatives in the standard library? I don't think monads are necessary there
15:06:50 <dmj`> @typ liftA
15:06:52 <lambdabot> Applicative f => (a -> b) -> f a -> f b
15:07:14 <Haskellfant> ah I wanted to ask for filterM
15:07:16 <Haskellfant> sorry
15:07:18 <Haskellfant> I'm getting tired
15:07:39 <monochrom> this is why I denounce getting GHC from linux distros. they bikeshed one single GHC into a hundred packages. you never know what you're missing.
15:08:19 <Haskellfant> in the nicta course you even implemnt something like a filterA https://github.com/tonymorris/course/blob/master/src/Course/Applicative.hs#L151
15:09:47 <phaazon> monochrom: pac thing ?
15:11:22 <monochrom> yes. what does archlinux call a package?
15:11:41 <Haskellfant> monochrom: a package :)
15:11:53 <codile> monochrom: you mean pacman the package manager?
15:11:59 <monochrom> yes
15:12:16 <Haskellfant> well the package manager is called pacman, a package is called a package
15:12:22 <MP2E> .pkg.tar.xz is the package extension
15:12:52 <monochrom> the *.so files may be in a separate archlinux package
15:12:59 <Haskellfant> :t filterA
15:13:01 <lambdabot>     Not in scope: ‘filterA’
15:13:01 <lambdabot>     Perhaps you meant one of these:
15:13:01 <lambdabot>       ‘filter’ (imported from Data.List),
15:13:06 <codile> they are not
15:13:10 <Haskellfant> hm this really doesn't seem to exist
15:13:11 * monochrom hates linux distro ideologies
15:13:15 <codile> at least not that i know
15:13:18 <codile> monochrom: why?
15:13:24 <geekosaur> arch doesn't generally do the dev vs. runtime split
15:13:25 <MP2E> arch's is quite sane
15:13:28 <MP2E> yeah
15:13:30 <simpson> To be fair, this is Arch-specific.
15:13:48 <monochrom> because I hate all ideologies
15:13:56 <int-e> monochrom: nah, arch doesn't do that. https://www.archlinux.org/packages/extra/x86_64/ghc/files/
15:14:05 <MP2E> even your ideology of hating ideologies?
15:14:12 <monochrom> alright, then I don't know why the *.so files can't be found
15:14:12 <codile> ^ :HD
15:14:22 <codile> s/:HD/:D
15:14:23 <monochrom> well, mine is not an ideology
15:14:27 <codile> it is
15:14:57 <MP2E> I just wanted to make a fun recursive loop out of it
15:14:59 <MP2E> :P
15:15:19 <codile> hmm. it has to be a group
15:15:37 <codile> but well, i've already heard other people saying that they hate ideologies
15:16:32 <geekosaur> also I must note that it's not so much an ideology as their way of avoiding what we miscall "cabal hell" in C
15:17:15 <codile> package management is actually pretty solid in most linux distros
15:17:21 <geekosaur> because they end up with multiple versions of half the ecosystem runtime libraries to maintain compatibility, but you can only have one development version installed or you get hell
15:18:37 <phaazon> 00:12 < monochrom> the *.so files may be in a separate archlinux package
15:18:40 <phaazon> huhu?!
15:18:46 <geekosaur> already been corrected
15:18:48 <phaazon> I don’t use pacman to install my packages
15:19:02 <phaazon> I use cabal-install
15:19:07 <phaazon> I just install ghc
15:19:20 <phaazon> so the transformers should be got through cabal
15:19:22 <monochrom> which cabal-install version?
15:19:42 <phaazon> cabal-install version 1.20.0.3
15:19:54 <phaazon> I guess it’s because of my cabal config
15:20:04 <phaazon> I enabled dynamic executable and sharing
15:20:09 <phaazon> I disabled it, and recreated the sandbox
15:20:14 <phaazon> it seems better
15:20:27 <geekosaur> isnt there a bug report about that?
15:20:53 <phaazon> ah?
15:20:58 <phaazon> that would explain my issue then
15:21:26 <monochrom> you should enable shared. or use the default. (the default varies with GHC version.) GHC 7.8.3 needs shared: True
15:21:28 <wombawomba> Is it possible to traverse a Data.Map as a tree?
15:21:57 <monochrom> because ghci wants the *.so files
15:22:11 <wombawomba> (I'm asking since it's implemented as a balanced binary tree, and it would be very convenient for me to use this structure)
15:22:35 <monochrom> as for dynamic executable, it's really up to you
15:22:37 <cwraith> wombawomba: in some sense, yes.  Possibly not in a useful sense.  foldMap takes advantage of the tree structure
15:25:57 <c_wraith> wombawomba: alternatively, you can do it very manually, with repeated applications of splitRoot
15:28:03 <wombawomba> alright, I'll look into it
15:28:19 <wombawomba> thanks
15:57:06 <Tuplanolla> I just saw >>= in a C program and had to stop for a moment to think how monads got there.
15:58:25 <codile> lol
15:58:28 <codile> wut?
15:59:19 <hyPiRion> I always do `while (i --> 0) { .. }` to confuse people whenever I can
16:01:00 <codile> what does --> do?
16:01:20 <codile> :t (-->)
16:01:21 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:01:23 <codile> hmm
16:01:33 <cite-reader> It's C. Read it like this: i-- > 0
16:01:47 <hyPiRion> codile: nothing in Haskell. But people get stange looks when reading that C code.
16:01:56 <codile> oh...
16:02:00 <codile> that's evil
16:02:04 <cite-reader> Isn't it?
16:02:07 <codile> yupp
16:02:59 <codile> C/C++ allow some weird stuff
16:03:01 <k00mi> codile: >>= is a right shift assign
16:03:49 <codile> what's also funny
16:03:56 <codile> #define true false
16:04:00 <codile> #define false true
16:04:06 <cite-reader> No. Stop.
16:04:16 <codile> :D
16:04:37 <Tuplanolla> Take a look at Windows' headers if you want nightmare fuel, codile.
16:04:37 <cite-reader> Or, what the hell, I'll join in.
16:04:42 <cite-reader> #define struct union
16:04:46 <codile> Tuplanolla: heh :D
16:04:53 <codile> #define double int
16:04:57 <codile> that one would also be funny
16:05:10 <codile> "what the hell is going on with my numbers? oO"
16:05:47 <Tuplanolla> My favorite part is a language extension that allows making comments through token pasting.
16:06:16 <Tuplanolla> #define _VARIANT_BOOL /##/
16:07:24 <goglosh> hey this might sound stupid but
16:07:50 <goglosh> is there a library managet for haskell like there is pip for python?
16:08:07 <codile> goglosh: cabal
16:09:22 <goglosh> great, thanks
16:11:14 <codile> hmm. actually
16:11:15 <codile> it should be
16:11:19 <codile> #define float int
16:11:20 <moghedrin> Tuplanolla: Oh gods.
16:11:21 <codile> duh
16:12:11 <codile> the best thing about replacing all floats with ints is that the code still works :P
16:12:15 <codile> i mean
16:12:17 <codile> it compiles
16:17:23 <Tuplanolla> They use it to build structures and unions, moghedrin. It's not even the worst thing in there.
16:33:54 <merijn> codile: C doesn't have true and false
16:34:10 <codile> well. yeah. but c++ does
16:34:54 <Tuplanolla> Newer revisions provide stdbool.h, merijn.
16:36:36 <chrisdotcode> is it possible to install lambdabot from source, without problems?
16:37:16 <hpc> define problem
16:37:38 <hpc> it's pretty easy to get it mostly working
16:37:55 <chrisdotcode> ghc version 7.8;; git clone, cabal sandbox, install in sandbox, compile
16:40:09 <int-e> chrisdotcode: I think it should work; remember to use 'cabal exec' to run the thing, or @run won't work.
16:40:23 <chrisdotcode> sweet.
16:40:56 <chrisdotcode> int-e: to the best of my knowledge, it seems I'm going to need to install each package individually, and then cabal add-source each installed dep in the core package
16:41:31 <int-e> chrisdotcode: I'd do a cabal sandbox init  followed by  cabal install lambdabot*/
16:41:38 <int-e> (note the /)
16:42:32 <int-e> chrisdotcode: that is, unless you plan to hack on the code, in which case  add-source  is of course helpful.
16:42:51 <chrisdotcode> int-e: yeah, I *don't* want to install binary packages.
16:42:54 <chrisdotcode> i want to hack the code.
16:43:16 <chrisdotcode> there doesn't seem to be a script to sandbox and add-source and install the deps in order, so I might have to write one, and submit a PR
16:43:45 <cite-reader> Isn't that cabal install --only-dependencies or similar?
16:44:03 <chrisdotcode> yes, but the dependencies are on *hackage*, not from the repo
16:44:41 <int-e> chrisdotcode: you can let cabal-install figure out the dependencies. just  cabal add-source lambdabot*  (possibly as separate commands?) followed by  cabal install lambdabot lambdabot-trusted
16:45:01 <chrisdotcode> int-e: sweet, and that'll install from the local repo copy?
16:45:22 <chrisdotcode> (because, as said prior, I plan to hack the source)
16:45:42 <int-e> chrisdotcode: yes.
16:45:50 <chrisdotcode> alright, I'll give that a try.
16:45:52 <chrisdotcode> thanks, int-e
16:49:22 <Ouyang> I get an error saying "The IO action 'main' is not defined in module 'Main'" with this https://gist.github.com/Beaudidly/8d9948a5986259345951 . Is this an error with my installation or the program itself?
16:49:50 <dmj`> Ouyand: do you have cabal file?
16:49:56 <dmj`> Ouyang: ^
16:50:12 <fatface> were i found good source codes, repos about python exploits, i want code to read and learning, python codes for more than penetrate, some start stuff to learn about intercept and look for hole, maybe here or at onion can any one give me a hand?
16:50:29 <Ouyang> uhhhh cabal file, I'm going to guess, no, but I use cabal
16:51:31 <dmj`> Ouyang: just put main = print one
16:51:47 <dmj`> project euler :)
16:52:10 <Ouyang> thank you, I'm terrible at this.
16:53:40 <Tuplanolla> Luckily that doesn't last long, Ouyang.
16:55:13 <T_S__> anybody tried to use the free monad foeund in “Reflection Without Remorse”
16:55:16 <T_S__> ?
16:56:20 <rrradical> how do I map over a newtype of a concrete type? like, newtype Foo = Foo [Char]. I want to be able to fmap f foo. I can't make Foo a functor because its kind is *
16:56:33 <fatface> any one know good resources in python here?
16:56:51 <kadoban> fatface: #python ? :D
16:57:17 <kadoban> You mean combining python and haskell somehow, or just python in general?
16:57:29 <fatface> python in general
16:57:42 <fatface> resource, repos for study code
16:59:51 <goglosh> so, guys... haskell is a lisp?
16:59:57 <kadoban> fatface: Only thing I can think of offhand is the like, python standand library...the parts that are actually in python anyway. I believe it's quite good quality, but that might be just my opinion
17:00:05 <hpc> haskell is in the ML family
17:00:10 <goglosh> ML?
17:00:19 <hpc> it's the language family you've never heard of
17:00:24 <hpc> C, lisp, ML
17:00:32 <kadoban> goglosh: Quite different from lisp really.
17:00:34 <goglosh> yeah never heard og it
17:00:38 <hpc> and then the oddballs like array and stack languages, prolog
17:00:47 <goglosh> well syntactically it is hell different
17:01:08 <goglosh> oh yeah prolog... is that even a thing? :P
17:01:15 <goglosh> Ima loop up that ML thing though
17:01:18 <kadoban> Quite different in most ways I can think of. Really just...they're both functional languages
17:01:20 <hpc> https://en.wikipedia.org/wiki/ML_%28programming_language%29 -- that's ML syntax
17:01:48 <hpc> https://en.wikipedia.org/wiki/Haskell_%28programming_language%29 -- haskell syntax
17:01:59 <hpc> @where lyah
17:02:00 <lambdabot> http://www.learnyouahaskell.com/
17:02:05 <josephle> I can never figure out whether or not ML as a language ever existed, since all we have now is SML and OCaml
17:02:13 <goglosh> oh meta language
17:02:13 <fatface> yep, but i'm not familiar building some stuffs like vulnerabilities, i build other kind of codes, so i want to read some codes to understand more about that kind of architecture u know
17:02:19 <hpc> ML is quite old
17:02:42 <goglosh> so... is it well suited for cryptography?
17:03:01 <spion> so... why is it called a metalanguage?
17:03:02 <kadoban> Pretty sure ML is/was a real language, but I don't think it was a well used one. Has lots of influence though
17:03:24 <josephle> spion: it was used as a meta language for a theorem prover
17:03:28 <kadoban> goglosh: What are we talking about now, haskell or ML?
17:03:42 <hpc> yes
17:03:54 <goglosh> uh haskell
17:04:25 <josephle> well, both ML's decendants and Haskell are general purpose programming languages
17:04:38 <goglosh> I'm starting out, figured I'd learn haskell as I delve in mathematical stuff, rather than procedural spaghetti
17:04:41 <kadoban> goglosh: Haskell has some pretty nice crypto primitives, if that's what you mean. I'm not sure how well suited it is for it, but seems nice every time I've used those. cryptohash package on hackage I believe
17:05:22 <goglosh> awesome
17:05:24 <hpc> it's suited to crypto in the same way a car is suited to getting from LA to san francisco
17:05:36 <hpc> (it will get you many other places as well)
17:05:53 <goglosh> kewl, I was afraid I was taking a boar or a submarine
17:06:00 <goglosh> boat*
17:06:25 * hpc imagines a boar wearing a saddle
17:06:36 <josephle> that's basically minecraft
17:06:50 <cite-reader> Only if the boar is made of cubes.
17:06:54 <cite-reader> Also everything else.
17:08:03 <goglosh> lel
17:09:20 <josephle> goglosh: crypto is a big field. Are you doing protocols or algorithms?
17:10:39 <goglosh> I'm just hopping in. I'm learning the very basics
17:11:00 <goglosh> like... xor encryptions and such
17:11:17 <meoblast001> i'm sort of a haskell noob. is there a function that takes a list and a number and skips that many items?
17:11:30 <josephle> :t drop
17:11:31 <hpc> > drop 5 [1..30]
17:11:31 <Hafydd> drop
17:11:32 <lambdabot> Int -> [a] -> [a]
17:11:33 <lambdabot>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
17:11:50 <meoblast001> ah, thanks. is there also a function that takes them from the right side? if not i can just use reverse
17:12:02 <hpc> not on its own, but
17:12:07 <hpc> > take 5 [1..30]
17:12:09 <lambdabot>  [1,2,3,4,5]
17:12:21 <meoblast001> but i guess i need to use length for that
17:12:22 <hpc> the structure of [] makes that a much more inconvenient operation
17:12:41 <hpc> for instance, it can't work on infinite lists
17:13:10 <Hafydd> > inits [1..10] !! 3
17:13:12 <lambdabot>  [1,2,3]
17:13:17 <DanZimm> hpc: what doesn't work on infinite lists?
17:13:20 <Hafydd> Er, I mean...
17:13:36 <Hafydd> Well, I suppose that's no better than just reversing it.
17:13:39 <josephle> DanZimm: dropping the n rightmost elements of a list
17:13:47 <DanZimm> ah yes ok
17:15:22 * hackagebot growler 0.1.0.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.1.0.0 (IanDuncan)
17:20:23 * hackagebot sasl 0.0.0.2 - SASL implementation using simple-pipe  http://hackage.haskell.org/package/sasl-0.0.0.2 (YoshikuniJujo)
17:20:25 * hackagebot igrf 0.2.0.0 - International Geomagnetic Reference Field  http://hackage.haskell.org/package/igrf-0.2.0.0 (dmcclean)
17:30:35 <danielsmw> can Binary instances be derived generically? if so, does anyone have a good learning reference?
17:34:27 <dcoutts_> danielsmw: yes, using the new GHC.Generics mechanism
17:34:39 <dcoutts_> see docs on GHC.Generics
17:35:46 <danielsmw> dcoutts_: do you know what GHC version I need? I feel like I'm doing things approximately correctly but i'm getting compiler errors and runtime errors for the lack of default get/put definitions
17:36:03 <danielsmw> dcoutts_: ah, 7.2 according to the docs. thanis
17:36:08 <danielsmw> dcoutts_: *thanks
17:37:23 <sccrstud92> if my implementation of <*> is not equivalent to ap, does that mean i most likely violated a law somewhere?
17:38:12 <merijn> sccrstud92: Yes
17:38:23 <merijn> sccrstud92: Well, at least if it produces different results from ap
17:38:25 <sccrstud92> shieeeeeeeeet
17:38:48 <sccrstud92> merijn: my Applicative instance has a Semigroup constraint but my Monad instance doesnt
17:39:04 <oisin786> When I add the debugging line: " -prof -auto-all" to my cabal file, I get the error " library not found for -lHSrandom-1.0.1.1". Why is this and how do I fix it?
17:39:13 <oisin786> on OSX*
17:44:24 <Laquendi_> oisin786: try running 'cabal install --only-dependencies --enable-library-profiling' in a fresh sandbox
17:45:38 <oisin786> Laquendi_: What should I install?
17:52:05 <danielsmw> so according to the docs, I can import GHC.Generic, derive Generic for a data type, and the "instance Binary MyData" should work... but it doesn't. am I missing something?
17:58:09 <josephle> danielsmw: can you be more specific?
17:58:23 <josephle> what part of the process doesn't work?
17:58:56 <kgadek> hi. got a problem with hspec testing code that returns `Monad m => m a`. If I try to instantiate `m` to be `Either String` then I can not test for Left :< http://pastebin.com/3gY6aTQw
17:59:34 <danielsmw> josephle: Sure. I literally just duplicated the example on the Data.Binary page under Generic support and when I try to encodeFile the new datatype I get "No instance nor default method for class operation Data.Binary.put"
18:00:13 <danielsmw> josephle: previously I'd been running my own code, but now that the example isn't working... I'm wondering if maybe I've broken a package somewhere in cabal, unless I'm just really stupid.
18:01:08 <josephle> hmm, it seems to work on my computer
18:01:31 <danielsmw> hmm, okay. thanks for the verification. I might need to reinstall ghc. *sigh*...
18:03:09 <Enigmagic> danielsmw: what version of binary do you have installed?
18:03:21 <danielsmw> Enigmagic: what's the fastest way to determine that?
18:03:37 <shachaf> ghc-pkg list binary
18:03:48 <danielsmw> 0.5.1.1
18:03:48 <Enigmagic> danielsmw: ^^^ that
18:04:12 <danielsmw> ah
18:04:14 <danielsmw> which I now see
18:04:19 <danielsmw> does not have generics support
18:04:39 <danielsmw> i should never have installed haskell platform
18:04:48 <danielsmw> Enigmagic: thanks!
18:04:58 <Enigmagic> np
18:05:30 <danielsmw> Enigmagic++
18:05:38 <heatsink> kgadek: return res `shouldBe` Left "nope"
18:05:53 <heatsink> kgadek: return res `shouldReturn` Left "nope"
18:07:52 <SuperSlut> does lpaste.net have an http api?
18:08:25 <kgadek> heatsink: thanks but "exception: ErrorCall (nope)"
18:08:46 <oisin786> Laquendi_: Thanks! That did it
18:09:47 <SuperSlut> nvm got it
18:10:39 <kgadek> heatsink: both do that actually
18:14:08 <heatsink> kgadek: shouldBe is just (@?=), and (@?=) doesn't work that way
18:14:37 <heatsink> For example, print =<< (Left "nope" `shouldBe` Left "nope") should print ()
18:15:47 <heatsink> Oh, you're using fail, not Left
18:16:55 <benzrf> what is shouldBe
18:17:02 <johnw> it's from hspec
18:17:24 <heatsink> What is, shouldBe.
18:17:36 <kgadek> hmr yeah. fail is what I have now…
18:17:41 <kgadek> but
18:18:25 <heatsink> Maybe it's not forcing evaluation.
18:18:28 <kgadek> I believe that not much harm would be done since I gave explicit typing ?
18:18:35 <heatsink> What if you make the returns strict?
18:18:40 <kgadek> heatsink: anyway - http://pastebin.com/8fu2WpLq
18:18:42 <kgadek> hmr
18:19:08 <beid7712> http://vividsx.com/digitalplayground-bangbros-realitykings-brazzers-naughtyamerica-mofos-pornpros-babes-21sextury-nubilefilms-private-passionhdpornfidelity-teenfidelity-evilangel-elegantange/
18:19:13 --- mode: ChanServ set +o johnw
18:19:17 --- mode: ChanServ set +o johnw
18:20:14 --- mode: johnw set -o johnw
18:20:30 <MarkusBarthlen> Hi! Beginner question - I want to iterate over the columns of a sql table and coerce null to 0 or "NULL" if appropriate. Can I actually do that and what language construct would I use?
18:21:06 <johnw> MarkusBarthlen: Are you asking how to do that in Haskell?
18:21:19 <MarkusBarthlen> Yes
18:21:27 <johnw> it would be easier just in plain SQL, wouldn't it?
18:21:53 <heatsink> Does it change if you add strictness to the shouldThrow test, kgadek?
18:22:06 <kgadek> heatsink: give a sec, trying second option
18:22:13 <kgadek> (evaluate does not work)
18:22:54 <MarkusBarthlen> Hmm. I did not actually consider that but it should work.
18:24:02 <heatsink> I don't know what it's doing.  Maybe you can find something that satisfies (`shouldThrow` anyErrorCall) and work backward from there.
18:26:48 <MarkusBarthlen> Thanks
18:28:23 <johnw> MarkusBarthlen: any time!
18:29:33 <kgadek> heatsink: got it
18:29:48 <kgadek> http://pastebin.com/LiZaTaJx
18:30:01 <kgadek> that was indeed lazy eval
18:31:12 <heatsink> evaluate res didn't work, but evaluate (res `seq` ()) did work?
18:31:47 <kgadek> this one works: `evaluate res `shouldThrow` errorCall "nope"`
18:32:36 <kgadek> …where do I have the code with evaluate that did not work?
18:32:57 <heatsink> In the paste, I see evaluate (res `seq` ())
18:33:24 <heatsink> so I inferred that you tried evaluate res, and it didn't work
18:34:07 <kgadek> oh, that was obviously an error…
18:34:50 <kgadek> it's quite early here (3am in Poland)
18:34:57 <heatsink> ok
18:35:09 <kgadek> thank you!
18:35:17 <heatsink> you're welcome
18:35:53 <heatsink> It is weird that (fail "" :: Maybe a) = Nothing, but (fail "" :: Either String a) = error ""
18:36:12 <shachaf> It is parametricity.
18:36:45 <shachaf> It's mildly unfortunate, but special-casing String would be much more unfortunate.
18:38:08 <heatsink> I didn't know that Either a had a monad instance.
18:38:15 <heatsink> I thought it was just Either String.
18:39:49 <shachaf> It's much more useful this way for most cases.
18:40:07 <Guest88890> I am a raw apprentice, need help to understand following error message:
18:40:25 <Guest88890> Hello.hs:1:8:
18:40:25 <Guest88890>     Ambiguous module name `Graphics.UI.Gtk':
18:40:25 <Guest88890>       it was found in multiple packages: gtk3-0.12.5.6 gtk-0.12.5.6
18:40:47 <Guest88890> what do I do to resolve this issue please.
18:41:02 <Guest88890> or specify with package to use.
18:41:16 <heatsink> You can set a global default by using ghc-pkg
18:41:28 <heatsink> Or you can specify the package on the command line with -package
18:41:52 <heatsink> If you're using Cabal, you would put the package name and version range in the cabal file.
18:42:06 <Guest88890> so where I have ghc --make Hello.hs -o Hello -package gtk-0.12.5.6?
18:42:11 <heatsink> yes
18:42:21 <Guest88890> thank you very much.
18:43:34 <Guest88890> getting the same error
18:44:57 <Guest88890> have not setup the simple project running under cabal management
18:45:02 <heatsink> Hmm.  I don't select packages on the command line very often.
18:45:12 <heatsink> Maybe you need -hide-package gtk3-0.12.5.6
18:45:50 <Guest88890> v simple program to start learning about gui interface to haskell to get hircules irc client to compile as part of another project
18:48:42 <Guest88890> http://projects.haskell.org/gtk2hs/documentation/ - this is what I am trying to compile and then run. The indetantation is wrong
18:49:55 <heatsink> Did you try -hide-package?
18:50:08 <Guest88890> the -hide-package cli switch has worked, but now error in code with strange character
18:50:27 <Guest88890> \8220
18:52:34 <heatsink> If you copied it from the webpage, there might have been a problem with text encoding
18:53:41 <heatsink> It says the file is in the demo/ directory.  Did you get the file from there?
18:53:41 <Guest88890> Fixed the problem with the encoding different " used
18:53:52 <Guest88890> no, just copied from the page
18:54:13 <Guest88890> unable to install gtk2hs using cabal install - says no such package
18:54:53 <dfeuer_> BLARGH.
18:54:59 <dfeuer_> Sorry.
18:55:11 <dfeuer_> List fusion is too complicated, or I'm too stupid.
18:55:16 <Guest88890> now starting to compile,but getting message "not in scope" for window, button
18:55:42 <Guest88890> Not stupid - need better documentation and examples for mere mortals to understand!
18:56:36 <dfeuer_> Guest88890, it's ... very hard to understand why some things work right and others don't. One might say that GHC is complex enough to develop emergent properties.
18:57:22 <Welkin> is there a clean way to mapM_ over a list of multiple arguments?
18:57:42 <heatsink> How many arguments?
18:57:51 <Welkin> for example: mapM_ g [2 3 4, 5 6 7, 7 8 8]
18:58:13 <Guest88890> @fortune
18:58:14 <lambdabot> You say you are lying.  But if everything you say is a lie, then you are
18:58:14 <lambdabot> telling the truth.  You cannot tell the truth because everything you say
18:58:14 <lambdabot> is a lie.  You lie, you tell the truth ... but you cannot, for you lie.
18:58:15 <lambdabot>               -- Norman the android, "I, Mudd", stardate 4513.3
18:58:22 <vanila> if g takes 3 arguments:   mapM_ (\(x,y,z) -> g x y z) [(2, 3, 4), (5, 6, 7), (7, 8, 8)]
18:58:32 <Welkin> right
18:58:42 <Welkin> but can I do it without wrapping the arguments inside of tuples?
18:58:49 <vanila> kind of
18:58:51 <vanila> you could do this
18:58:53 <merijn> Did 7.8 have bool/cond in base yet?
18:59:06 <johnw> s/Did/Does
18:59:50 <vanila> mapM_ (\k -> k g) [k 2 3 4, k 5 6 7, k 7 8 8]   where  k x y z = \g -> g x y z
19:00:32 * heatsink can't tell if vanila is joking
19:01:09 <merijn> johnw: Pretty sure both are correct in English
19:01:13 <dfeuer_> merijn, what is bool/cond?
19:01:23 <johnw> the Did phrasing is wrong to my ears
19:01:37 <merijn> johnw: That's just a problem with your dialect of English :p
19:01:40 <johnw> haha
19:01:41 <shachaf> The answer is yes.
19:01:46 <shachaf> To bool.
19:01:47 <vanila> > let g x y z = (z, x + y) ; k x y z = \g -> g x y z in map (\k -> k g) [k 2 3 4, k 5 6 7, k 7 8 8]
19:01:48 <lambdabot>  [(4,5),(7,11),(8,15)]
19:01:49 <merijn> dfeuer_: "bool :: a -> a -> Bool -> a"
19:01:59 <merijn> shachaf: Where is it? Hoogle doesn't seem to find it?
19:01:59 <phaskell> No symbol 'it' found anywhere.
19:02:00 <vanila> it works fine
19:02:04 <shachaf> Data.Bool
19:02:17 <heatsink> dfeuer_: You can think of optimizations as partial evaluation.  The optimizer evaluates the stuff that it can compute at compile time.  It has a few rules for what it won't evaluate.
19:02:19 <trap_exit> https://news.ycombinator.com/item?id=8224469 <-- how true is this of the Haskell community as well?
19:02:20 <trap_exit> [original article = Dylan]
19:02:22 <merijn> shachaf: Thanks
19:02:30 <Welkin> vanila: that looks more confusing
19:02:37 <heatsink> dfeuer_: Stream fusion takes advantage of those optimizations.
19:02:43 <vanila> the tuple way is better then
19:02:46 <shachaf> heatsink: There are a few specific optimizations that you can think of that way, anyway.
19:02:59 <dfeuer_> heatsink, it makes for a certain amount of complexity and fragility.
19:03:04 <vanila> 'k' in that example was a higher order function
19:03:18 <merijn> trap_exit: How true is what?
19:03:21 <dfeuer_> Which can be frustrating.
19:03:23 <dfeuer_> ARGH.
19:03:31 <heatsink> Sure.
19:03:43 <Welkin> how does (\k -> k g) work? where is g coming from?
19:04:02 <vanila> g is the function you originally named <Welkin> for example: mapM_ g [2 3 4, 5 6 7, 7 8 8]
19:04:04 <trap_exit> merijn: good question
19:04:12 <Welkin> oh
19:04:20 <dfeuer_> merijn, I saw that. I seem to remember it's backwards.
19:04:22 <vanila> (\k -> k g) is just a function that gives g to k
19:04:31 <johnw> aka ($ g)
19:06:24 <heatsink> I simplified it a bit: mapM_ id [g 2 3 4, g 5 6 7, g 7 8 8]
19:06:36 <shachaf> @src mapM_
19:06:36 <lambdabot> mapM_ f as = sequence_ (map f as)
19:06:43 <vanila> heatsink, that misses the point
19:07:14 <heatsink> How so?
19:07:41 <vanila> you might have missed/misunderstood the earlier question
19:12:32 <tabemann> trap_exit: the thing is that people *do* use Haskell - just not commercially
19:13:09 <dolio> They don't use it commercially?
19:14:24 <tabemann> okay, some stock-trading types use it
19:15:19 <merijn> tabemann: "some stock trading types"
19:15:56 <Welkin> I recently started programming imperatively in haskell
19:15:57 <merijn> tabemann: You realise Lennart's bank has like 1 million LOC of haskell and 1.5 million of their in house haskell dialect? And that there's a whole bunch of other banks that do too?
19:16:00 <Welkin> everything is in a do block
19:16:01 <Welkin> haha
19:16:08 <Welkin> at least for opengl
19:16:15 <tabemann> Welkin: I do that all the time
19:16:27 <merijn> Not to mention the guy who's working for a company with a 150k LOC actionscript3 compiler written in haskell
19:16:36 <merijn> Or facebook's stuff...
19:16:45 <merijn> @quote Jafet research.language
19:16:45 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
19:17:09 <merijn> Tons of people are using haskell commercially, they're just not blogging about it, because they're working...
19:17:35 <vanila> How does one get a job doing haskell?
19:17:45 <Welkin> I'm going to blog about it to help others like me who have no idea what they are doing
19:18:12 <AshyIsMe> vanila: if you find out let me know! :P
19:18:22 <zomg> vanila: probably best to be in a city with haskell corps, though I've seen a handful of remote ones as well
19:18:33 <heatsink> The Haskell Corps
19:18:41 <tabemann> the closest thing to an FP job I've gotten is the scala job I nearly got and the job I did get which is likely going to become a scala job
19:18:43 <Welkin> lots of companies using languages internaly that they don't advertise for
19:18:52 <johnw> vanila: one answers a job opportunity posting
19:19:09 <zomg> Welkin: yeah, sorta hard to just find them if nobody tells you they're using it =)
19:19:17 <johnw> vanila: I'm on my second Haskell job now, and that's how I find them
19:19:19 <vanila> johnw, where do you find those? mailing lists?
19:19:28 <johnw> haskell-cafe posts them from time to time
19:19:42 <zomg> I've noticed blogging about haskell helps
19:19:46 <Welkin> or just join a company and decide to use haskell
19:19:50 <merijn> In Amsterdam there's a "commercial FP" meetup, there's quite a few companies migrating from php/ruby/python to scala/erlang/F#/clojure (haskell less so, because it doesn't interoperate with existing code as easily)
19:19:50 <Welkin> that's always possible
19:19:54 <merijn> vanila: haskellers.com
19:19:54 <zomg> I think I wrote a couple of random not-even-very-useful things about haskell to my blog
19:20:01 <zomg> and two people have asked me about it :P
19:20:11 <SuperSlut> bro
19:20:14 <RevBayes> Planet Haskell has some postings as well, if I remember correctly
19:20:22 <SuperSlut> if u want to  write haskell make a startup
19:20:26 <Welkin> use whatever languages you feel is best for implementing the solution
19:20:29 <tabemann> I'm stuck in Milwaukee, which is planet C# with the occasional Java job
19:20:36 <johnw> also, attend Haskell hackathons nearby you and ask around
19:20:42 <zomg> SuperSlut: will you fund it?
19:20:44 <SuperSlut> writing haskell for someone is not much better than writing shitscript for someone
19:20:50 <SuperSlut> you dont need funding
19:20:55 <tabemann> there's an FP meetup here, but it seems to be rather Erlang-centric in practice
19:20:56 <SuperSlut> all u need is ur moms basement
19:21:10 <zomg> Ok I'll just go over here where I can't hear you...
19:21:12 <SuperSlut> and 10 bucks a month for hosting
19:21:12 <vanila> how do you make money from a startup, don't they all go bankrupt?
19:21:28 <SuperSlut> of course some go bankrupt
19:21:29 <johnw> vanila: is that really an appropriate question?
19:21:36 <SuperSlut> but
19:21:51 <vanila> I don't know johnw, is it not ok?
19:21:57 <SuperSlut> if you have a good idea it doesnt matter
19:22:14 <zomg> Startups work if they can find an audience
19:22:19 <SuperSlut> if you are yourself a developer then you dont need much else to start
19:22:20 <zomg> but like 90% of them don't really work out so good
19:22:34 <johnw> this channel is for discussing Haskell, not how to make startups succeed
19:22:41 <vanila> ok
19:22:44 <johnw> thanks
19:22:48 <SuperSlut> most of the failing startups are those arts majors that think they can just hire people to do everything for them
19:22:56 <copumpkin> SuperSlut: please stop.
19:23:02 <SuperSlut> wat
19:23:14 <zomg> I think I might've seen a haskell posting on SO Careers actually
19:23:28 <zomg> so yeah just looking in places for the jobs will probably help =)
19:23:31 <SuperSlut> the good haskell jobs are difficult to get
19:23:40 <SuperSlut> and most of them require heavy math knowledge
19:23:48 <SuperSlut> like quants and shit
19:23:52 <tabemann> the thing is that you need something to pay the bills, regardless of what one actually wants to do, hence one ends up programming things one doesn't really want to, like Java
19:24:37 <SuperSlut> also theres like 100 applicants for every decent haskell position and a lot of them are smart mofos
19:24:48 <tabemann> I'm lucky that I'll even get to program in Scala at my current job; the existing codebase is in Groovy and Java, but the current team lead doesn't really like those and wants to do a rewrite
19:25:03 <zomg> I wrote a thing at work in Haskell
19:25:11 <zomg> I just told them I'm writing it in Haskell and nobody gave a shit
19:25:12 <zomg> lol
19:25:21 <SuperSlut> lol
19:25:40 <tabemann> at my workplace everything has to be in a JVM language, because we have outside libraries that are in Java that we have to interface with
19:25:47 <SuperSlut> write a 10 line haskell program to launch your app and put 'senior haskell dev' on your cv
19:25:49 <lpvb> zomg: but the code was solely your responsibility right? no one else had to maintain or interact with it?
19:26:19 <zomg> lpvb: yeah, it was a quick temporary service we needed for something so it really didn't matter :D
19:26:38 <SuperSlut> java is dying imo
19:27:03 <tabemann> Java is only dying in the sense that it'll probably inevitably be replaced by Scala in the long run
19:27:08 <tabemann> the JVM isn't dying
19:27:10 <SuperSlut> nah
19:27:13 <johnw> I would ask that you please keep to the topic; we are here to discuss Haskell
19:27:13 <stelleg> is there a way to run ghc with the program specified in the command line?
19:27:17 <SuperSlut> jvm gona die with java
19:27:37 <tabemann> SuperSlut: why do you say the JVM is dying?
19:27:50 <tabemann> do you expect .NET to win?
19:27:51 <heatsink> stelleg: runhaskell
19:27:52 <johnw> tabemann, SuperSlut: please
19:28:08 <SuperSlut> ok johnw
19:28:11 <johnw> thanks
19:28:41 <solatis> if i only want to do high level, black-box testing, does anyone have an opinion about a good test framework i should use? having 20 different Test-Suite definitions in my .cabal file is not so great..
19:28:49 <stelleg> heatsink: sorry, i mean something like: runhaskell -c 'main = putStrLn "Hello world"'
19:29:08 <stelleg> runhaskell as far as I know only takes a program file
19:29:14 <solatis> there seem to be quite a few test frameworks that all do things just a little differently, and frankly, i don't think i care enough
19:29:43 <stelleg> and doesn't work trying to use /dev/stdin
19:30:39 * hackagebot flowdock 0.2.0.0 - Flowdock client library for Haskell  http://hackage.haskell.org/package/flowdock-0.2.0.0 (IanDuncan)
19:30:43 <stelleg> also doesn't work with bash temp files, e.g. runhaskell <( 'main = putStrLn "Hello world"' )
19:30:56 <stelleg> oops
19:31:16 <stelleg> *with an echo in there*
19:31:30 <stelleg> complains about it not being a regular file
19:32:35 <bgamari> Can someone explain attoparsec's inconsistency here? https://gist.github.com/bgamari/366b3e25aabbec53381c
19:33:37 <bgamari> I guess this probably has something to do with empty strings being used to indicate end of stream
19:33:46 <bgamari> but the behavior is surprising at best
19:36:33 <marchelzo_> stelleg: you could just make bash script to do it
19:37:15 <stelleg> marchelzo_: true, just checking if anyone has a better solution
19:38:01 <marchelzo_> stelleg: for me, runhaskell <<< 'main = putStrLn "Hello World"' works
19:38:28 <stelleg> marchelzo_: oh cool, thanks!
19:38:32 <marchelzo_> np
19:38:37 <stelleg> marchelzo_: not familiar with <<<
19:40:56 <stelleg> oh it sends it to stdin
19:41:01 <stelleg> nice
19:41:09 <stelleg> didn't even think tto try that
19:41:41 <marchelzo_> echo 'main = putStrLn "Hello World"' | runhaskell also works
19:41:55 <stelleg> yeah thats what I just checked after your idea :)
19:41:59 <marchelzo_> lol
19:46:51 <zygs-zegs> :t readsPrec
19:46:52 <lambdabot> Read a => Int -> ReadS a
19:49:03 <Zemus> how can I use filter on a list of custom data types? I want to filter out rows (data types) that have a field greater then a certain value... anyone have any ideas?
19:49:27 <stelleg> marchelzo_: ah but looks like it does break stdin for the haskell program
19:50:17 <stelleg> i guess that's unsurprising though, as it has no way to know when the source stdin ends
19:50:34 <zygs-zegs> Zemus: filter ((<=value).recordSyntaxIdentifer)
19:51:45 <zygs-zegs> Zemus: recordSyntaxIdentifier is the field name given in the Record-Constructor definition of the type. Goolge Haskell Record syntax for more info
19:55:42 * hackagebot here 1.2.5 - Here docs & interpolated strings via quasiquotation  http://hackage.haskell.org/package/here-1.2.5 (TaylorHedberg)
19:56:11 <Zemus> zygs-zegs: where do I pass in my current list? lets say I have old_list (current), do I do something like:: let new_list = filter ((<=value).Age) old_list ?
19:56:43 <zygs-zegs> Zemus: you are 100% correct
19:57:24 <marchelzo_> stelleg: :( I guess a bash script is the solution after all
19:58:07 <Zemus> uit IRC (Ping timeout: 240 seconds)
19:58:07 <Zemus> *** pgokeeffe ha
19:58:08 <zygs-zegs> Zemus: However, let f = filter ((<=value).Age) in f old_list works as well. filter ((<=value).Age) is in Point-Free-Form (another term you might want to Google)
19:58:41 <Zemus> filter is Data.List.Filter or Data.Map.Filter?
19:59:00 <zygs-zegs> Zemus: Lastly note that Age is not a valid function generated from record syntax, Age is capitalized and therefore a type, not a function
19:59:37 <zygs-zegs> Zemus which filter to use depends on the type of old_list
20:00:03 <Zemus> true ... my record has it as slcCustAge (the field of my data SlcRecord)
20:00:31 <zygs-zegs> Zemus: if old_list is a Map, then use Data.Map.Filter, if it is a List use Data.List.Filter or Prelude.Filter
20:01:06 <Zemus> zygs-zegs: or ... it gives no errors, wanted to test it so I did: print f and get f not in scope?
20:02:12 <zygs-zegs> Zemus: you could load your code into GHCI, and use ":t" to determine the type of old_list
20:03:31 <Zemus> zygs-zegs: my mistake (stupid typo), works perfectly!
20:04:57 <zygs-zegs> Zemus: I'm not sure about the scoping of f without looking at yourcode. make sure that f is defined in the same function scope as print AND make sure that f is an instance of type-class Show
20:05:13 <zygs-zegs> Zemus: Oh, good it works!
20:05:38 <zygs-zegs> Zemus: Glad I could help!
20:07:27 <pvbnios> whats up here? http://lpaste.net/110027
20:08:33 <Cale> pvbnios: It means you used a string literal where a list of Text values was expected
20:08:51 <pvbnios> Cale: actually putting the string into [] like ["asdf"] fixed it :S
20:08:59 <trap_exit> oh man -Wall is awesome, catches so many silly bugs
20:09:00 <Cale> yep, it would
20:09:03 <pvbnios> is this some special syntax or somkething?
20:09:07 <pvbnios> i thought [] was list
20:09:11 <Cale> pvbnios: yes
20:09:12 <johnw> dcoutts: ping
20:09:26 <haasn> If "asdf" is a Text value, then ["asdf"] is a list of Text values
20:09:34 <zygs-zegs> does anyone know a good reference for implementing readsPrec from the type-class Read?
20:09:47 <Cale> pvbnios: Well, OverloadedStrings is being used to treat "asdf" as a Text value.
20:09:57 <pvbnios> yes Cale
20:10:09 <zygs-zegs> I have never implemented Read by hand before, and am a little confused how the parser is suposed to work
20:10:09 <pvbnios> but why does it need a list?
20:10:21 <Cale> pvbnios: I can't tell that from your paste.
20:10:35 <Cale> pvbnios: The remainder of your code demands a list for some reason
20:10:41 <pvbnios> oh
20:10:48 <pvbnios> its supposed to be a list in the first place..
20:10:50 <pvbnios> wierd
20:10:55 <pvbnios> weird
20:11:02 <pvbnios> weird is weird to spell
20:11:11 <johnw> does anyone know why, even though I configure with --enable-library-profiling --enable-executable-profiling, cabal isn't building executables that accept +RTS -p?
20:11:15 <Cale> werid
20:11:33 <merijn> johnw: Your forgot -rtsopts :)
20:11:34 <Cale> johnw: hmm
20:11:35 <merijn> *You
20:11:36 <AfC> monochrom: you around?
20:11:45 <zygs-zegs> Are all dependancies also compiled with those flags, INCLUDING base?
20:11:45 <Cale> ah, yeah, that's possibly it
20:12:15 <Cale> It's sort of frustrating that turning on profiling doesn't imply -rtsopts
20:12:41 <johnw> merijn: when building with profiling, you don't need -rtsopts
20:12:58 <johnw> when I use +RTS, it dumps me a menu of all the options I *could* have used
20:13:02 <Cale> Or for that matter, that -rtsopts isn't the default. It's fine if we want to have -no-rtsopts, but I sometimes miss having that on by default.
20:13:08 <johnw> Cale: I agree
20:13:39 <Cale> Oh, profiling does imply it? Hmm.
20:16:19 <merijn> File layout question: Small helpers are the start or at the end of a file?
20:16:49 <zygs-zegs> merjin: I prefer the end, important stuff up front
20:17:00 <zygs-zegs> merjin: it's a matter of taste though...
20:18:04 <zygs-zegs> merijn: If it's really small & used once, I'll put it in a where clause
20:19:12 <bms1> ooph, the 'either' package has way too many dependencies for what it is
20:20:03 <zygs-zegs> I haven't looked at the dependacy list, what looks like an unreasonable dependacy?
20:20:36 <bms1> cabal wants me to install 17 dependencies... All of them are pretty much ekmett's algebraic things
20:20:57 <roboguy_> bms1: probably to avoid orphan instances
20:20:57 <bms1> I'm sure they're all just for typeclass instances of classes in those other packages
20:21:06 <bms1> yep
20:21:27 <merijn> zygs-zegs: Sure, but then I wouldn't need to ask either ;)
20:21:30 <zygs-zegs> Now that I look, MonadRandom seems out of place
20:22:01 <bms1> zygs-zegs: There is a MonadRandom instance for the Either transformer
20:22:47 <roboguy_> hmm, maybe it would make sense to reverse some of those dependencies
20:22:50 <johnw> merijn: when I manually insert -prof, I get that error from TH about dynamic loading and needing to build things twice, which isn't working yet
20:24:13 <chrisdotcode> is there no module available to resolve a filepath?
20:24:13 <merijn> johnw: Oh, yeah, I had the same issue where it wouldn't build profiled+dynamic libraries, stupid thing
20:24:34 <johnw> yeah, I've cured this before, but this time my tricks aren't working
20:24:44 <zygs-zegs> I find Haskell's typeclasses make it difficult to determine who's package is responsible for defining the instances. Is there a rule of thumb for this?
20:25:26 <merijn> zygs-zegs: Rule of thumb is: No orphans
20:25:47 <merijn> zygs-zegs: And orphan is an instance that is not defined in either 1) the module defining the class or 2) the module defining the type
20:26:34 <johnw> merijn: ah, found the trick
20:26:40 <zygs-zegs> I know what orphaned instances are, I'm just not sure who's package should define the instance(s).
20:26:52 <merijn> zygs-zegs: Depends on who imports whom :)
20:26:52 <johnw> cabal configure, cabal build, then hack in ghc-options of -prof -osuf p_o, and cabal build again without re-configuring
20:27:20 <merijn> zygs-zegs: i.e. if the package defining the class depends on the package defining the type, then it has to be the class package (otherwise you'd have a circular dependency!)
20:27:26 <merijn> zygs-zegs: Or the other way around
20:27:39 <chrisdotcode> johnw: how's gitlib? :)
20:27:44 <zygs-zegs> Should the person's package who devised the typeclass be burdened with finding all the other types which satisfy his new typeclass and instanitate all the possible instances?
20:27:47 <johnw> chrisdotcode: I haven't touch it
20:27:55 <merijn> johnw: I unsucked another module, I might actually get this library polished enough to release the pre-pre-pre-alpha this week :D
20:28:10 <zygs-zegs> merijn: Interesting, let me think about that...
20:28:27 <chrisdotcode> johnw: I'm looking at your libgit bindings, and making a high-level interface over that seems plausible
20:28:37 <chrisdotcode> *libgit2
20:28:38 <johnw> chrisdotcode: isn't that what gitlib is?
20:28:42 <zygs-zegs> merijn: Yeah, that makes sense!
20:28:48 <merijn> zygs-zegs: For a sufficiently general class it seems most logical to have a package just for the class and have datatypes depend on that :)
20:29:00 <chrisdotcode> johnw: yeah, but *only* for libgit, since gitlib isn't ready for prime-time yet
20:29:07 <merijn> If your class is not very general not a lot of people will instantiate it anyway
20:29:14 <johnw> chrisdotcode: what do you mean?  It was in production use by FP Complete for 2 years
20:29:20 <johnw> chrisdotcode: that's pretty prime-time
20:29:29 <chrisdotcode> johnw: er, documentation-wise, I meant.
20:29:34 <johnw> ah, well, yes
20:29:54 <johnw> so you want to wrap libgit2 only with some other interface?
20:30:15 <bms1> Why are orphan instances so bad? Is it just because you can't hide them when you import/export them?
20:30:34 <shachaf> bms1: More than one person might define them.
20:30:38 <roboguy_> bms1: they could conflict with someone else's orphan instance
20:30:51 <bms1> oh
20:31:11 <chrisdotcode> or just write a higher-level version of it *over* libgit2. Instead of having to see type-sigs with C pointers, etc.
20:31:25 <roboguy_> bms1: also, you can never hide instances
20:31:37 <chrisdotcode> *over your bindings, I meant.
20:32:02 <glguy> And GHC doesn't check that a program compiled using only a single instance for a given type today, so they can lead to incoherent instance selection
20:32:56 <johnw> chrisdotcode: seems like a real duplication of effort though; why not just document gitlib?
20:34:46 <chrisdotcode> johnw: that's also an idea
20:35:06 <chrisdotcode> (johnw: but I do remember you saying something about removing the "repofactory" abstraction or something)
20:35:17 <merijn> glguy: That's not true
20:35:19 <levi> johnw: Is FP Complete not using gitlib anymore?
20:35:20 <johnw> yes, that's a very easy change to make
20:35:29 <johnw> since you don't have to use it all already as things stand now
20:35:32 <johnw> levi: no, they are not
20:35:36 <merijn> glguy: If someone else defines another orphan it will just not compile
20:35:43 <glguy> Merijn: yes it is and it's documented as a known issue
20:35:48 * hackagebot Folly 0.1.2.0 - A first order logic library in Haskell  http://hackage.haskell.org/package/Folly-0.1.2.0 (dillonhuff)
20:35:49 <johnw> levi: they changed the way that their backend servers are utilized, enabling the use of command-line directly
20:35:56 <merijn> glguy: Is this with dynamic linking?
20:35:59 <glguy> No
20:36:10 <merijn> glguy: Link to where this is documented then?
20:36:13 <johnw> gitlib's real use at FP Complete was in treating an S3 store as a direct repository for Git object
20:36:21 <merijn> glguy: AFAIK you can never have incoherent instance selection without an extension
20:36:31 <glguy> Yeah, I'll send you the ticket when I'm back at my desk
20:36:41 <levi> johnw: Using the command line directly ends up being less work/more reliable? I guess that makes sense.
20:36:51 <johnw> yeah
20:36:56 <johnw> they don't need the higher speed from gitlib
20:37:07 <glguy> But no, you don't need an extension, the check is known to be disabled at module import
20:37:13 <johnw> also, working through a C FFI ended up being a source of a lot of really arcane bugs
20:37:13 <glguy> And isn't done at linking
20:37:29 <johnw> there is a gitlib-hit backend now, which is what I'd invest in if I had to do it over again
20:37:46 <johnw> libgit2 has some advantages, but in my opinion none of them are worth it
20:38:10 <levi> hit is a haskell implementation of git?
20:38:19 <johnw> once I spent a couple of days tracking down a bug that ended up being an uninitialized local variable in the C code; I like that in Haskell that kind of thing can't even be expressed
20:38:20 <johnw> yes
20:38:24 <glguy> Merijn: currently multiple instance possibilities are only checked when resolving an instance and not at module import
20:38:47 <glguy> So as long as only one of the instance was in scope at each use site
20:39:11 <levi> As I do most of my coding at work in C, I have spent many days in similar debugging pursuits.
20:39:13 <glguy> It doesn't matter that there is an instance conflict when those modules are then both imported
20:40:07 <levi> Fortunately, a lot less often than I used to, but those things do crop up sometimes.
20:40:38 <johnw> and when it's buried under 4 layers, behind a highly asynchronous back-end, and running inside an ephemeral container.  Well, then, it gets even trickier
20:40:52 <johnw> better to use something slower but trustworthy, if speed isn't a blocking issue
20:41:00 <levi> Indeed.
20:42:43 <glguy> Merijn: here you go https://ghc.haskell.org/trac/ghc/ticket/8338
20:44:32 <merijn> glguy: thanks
20:47:07 <ParahSailin> johnw: ah hey
20:48:08 <johnw> Hi ParahSailin
20:48:34 <ParahSailin> im not sure if im up to co-maintainership
20:48:44 <johnw> of what again?
20:48:53 <ParahSailin> gitlib
20:48:58 <johnw> ok
20:49:16 <ParahSailin> so thats the story, fpcomplete stopped using it, so no reason to maintain?
20:49:29 <johnw> well, I have other things to do you know
20:49:40 <ParahSailin> i suppose i should step up
20:49:56 <johnw> I'll certainly keep it working for my use cases, or if a need arises again
20:50:18 <ParahSailin> i need to work out my use cases first
20:51:21 <ParahSailin> what was the thinking behind making a general class, was there originally intent to make a pure haskell implementation?
20:51:31 <johnw> there is one now, gitlib-hit
20:51:43 <johnw> it just needs a bit more work
20:51:54 <johnw> hit itself is maintained by someone else
20:51:57 <johnw> @hackage hit
20:51:57 <lambdabot> http://hackage.haskell.org/package/hit
20:55:57 <merijn> What's the state of cabal's test-suite integration? I have a bunch of commandline program tests I want to run, where should I look?
20:56:09 <johnw> just run them as exitcode style tests
20:56:22 <johnw> "success" will just mean ExitSuccess
20:56:29 <johnw> (i.e., exit code of 0)
20:57:31 <merijn> johnw: "just them as exitcode style test" <- I don't know what that means? :)
20:57:36 <johnw> one sec
20:57:50 <johnw> https://gist.github.com/c38e514d346a0093bd97
20:57:58 <johnw> that builds a test and runs it
20:58:36 <johnw> main.hs can do anything it wants, it just need to exit with a status code of 0 (i.e., no exceptions in the Haskell case)
20:59:15 <merijn> johnw: Hmm, that doesn't look like it'll quite work for me :\
21:00:08 <merijn> johnw: I need to test communicating processes, so I need to run at least two binaries
21:00:49 <johnw> so write a main.hs which spawns them
21:00:56 <johnw> it can do literally anything at all
21:08:55 <merijn> johnw: Then I still need a convenient way to test things as I have like 10 binaries to run in various combinations and having a single test that spawns them all and treats them as a single success/failure would be rather inconvenient :)
21:09:12 <johnw> so add several such test runners in your .cabal
21:09:17 <johnw> you can have as many as you like
21:09:25 <johnw> that is, if you want to do it through Cabal at all
21:10:02 <merijn> johnw: I just meant that writing a single binary for the cartesian product of combinations seems tedious and will quickly fill up my cabal file :)
21:10:09 <johnw> true
21:10:42 <merijn> I was hoping there was some form of library for simply spawning a bunch of process and checking access codes/output
21:10:52 * hackagebot hi 0.0.8.2 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.8.2 (DaisukeFujimura)
21:26:53 <spopejoy> lens getter help ... [(1,2),(3,4)] -> [2,4]?
21:27:37 <johnw> ^.. _2
21:28:16 <shachaf> toListOf (traverse .. _2)
21:28:23 <spopejoy> > [(1,2),(3,4)]^.._2
21:28:24 <shachaf> Er.
21:28:25 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field2
21:28:25 <lambdabot>                      [(t0, t1)] [(t0, t1)] a a)
21:28:25 <lambdabot>    arising from the ambiguity check for ‘e_112342’
21:28:25 <lambdabot>  from the context (Control.Lens.Tuple.Field2
21:28:25 <lambdabot>                      [(t, t2)] [(t, t2)] a a,
21:28:26 <shachaf> Sigh
21:28:30 <shachaf> toListOf (traverse . _2)
21:28:41 <shachaf> Or (^.. traverse . _2), if you prefer infix operators.
21:28:46 <johnw> ah, that was it, traverse
21:29:11 <spopejoy> I thought it would be something using 'mapped'
21:29:32 <spopejoy> [(1,2),(3,4)]^..traverse._2
21:29:43 <spopejoy> > [(1,2),(3,4)]^..traverse._2
21:29:45 <lambdabot>  [2,4]
21:33:30 <johnw> does anyone know why GHC.Generics.gfoldl might be consuming a great deal of memory?
21:33:38 <dfeuer_> Kill.
21:33:46 <zcd> :t lift
21:33:48 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
21:33:56 <dfeuer_> :t GHC.Generics.gfoldl
21:33:57 <lambdabot> Not in scope: ‘GHC.Generics.gfoldl’
21:34:03 <zcd> :t foldl
21:34:05 <lambdabot> (b -> a -> b) -> b -> [a] -> b
21:34:06 <johnw> :t Data.Data.gfoldl
21:34:07 <lambdabot> Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
21:34:23 <zcd> :t id
21:34:24 <lambdabot> a -> a
21:34:28 <zcd> :t pure
21:34:29 <lambdabot> Applicative f => a -> f a
21:34:55 <zcd> :t (***)
21:34:56 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
21:35:30 <dfeuer_> johnw, strictness analysis problem?
21:35:36 <johnw> i wonder
21:51:04 <glguy_> spopejoy: Don't forget the good old fashioned:
21:51:06 <glguy_> > map snd [(1,2),(3,4)]
21:51:08 <lambdabot>  [2,4]
21:52:10 <shachaf> glguy: Are you trying to make this easy or something?
21:52:18 <glguy_> I love functions
21:52:36 <shachaf> Especially functions with domain equal to codomain?
21:52:49 <shachaf> (Equipped with composition and identity, perhaps?)
21:52:56 <haasn> > let xs = [(1,2),(3,4)] in [b | (_,b) <- xs]
21:52:58 <lambdabot>  [2,4]
21:53:00 <glguy_> No, not those kinds of functions
21:53:15 <haasn> I don't know what this is about but I think list comprehensions with pattern matches are kind of a cool way of getting things out of lists
22:16:36 <johnw> dfeuer_: so, it was syb.  I just changed a use of everywhereM to propagate the change manually (it was a shallow structure), and all my problems went away
22:16:49 <johnw> premature generalization
22:23:15 <dfeuer_> johnw, unfortunately I have no idea what you're talking about.
22:23:27 <dfeuer_> What is syb?
22:23:53 <shachaf> @whatis syb
22:23:53 <lambdabot> <http://www.haskell.org/haskellwiki/Scrap_your_boilerplate>,<http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/>,<http://homepages.cwi.nl/~ralf/syb2/>,<http://homepages.cwi.nl/~ralf/syb3/>
22:24:33 <johnw> say you have a gigantic type with some Ints in it, and you want to increment every Int by one.  You can do it with lens, or you can do it with syb.
22:24:47 <johnw> (and probably other things besides)
22:25:31 <adas> syb?
22:25:42 <johnw> see shachaf's links
22:26:32 <dfeuer_> Huh.
22:27:09 <dfeuer_> I'm trying to figure out why this foldr/build I see in core2core isn't fusing.
22:27:16 <dfeuer_> GRR
22:27:18 <dfeuer_> Must go.
22:27:19 <dfeuer_> Bye.
22:28:15 <adas> just got here
22:28:25 <johnw> ah
22:28:28 <johnw> @whatis syb
22:28:29 <lambdabot> <http://www.haskell.org/haskellwiki/Scrap_your_boilerplate>,<http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/>,<http://homepages.cwi.nl/~ralf/syb2/>,<http://homepages.cwi.nl/~ralf/syb3/>
22:28:41 <shachaf> Try lambdabot (/msg lambdabot @where syb) or Google.
22:28:43 <shachaf> Or that.
22:28:49 <adas> thanks
22:29:34 <johnw> it was being used in my case so data structures could be changes and the algorithms would continue to work, no matter what shape the structures ended up being
22:29:58 <nitrix> How practical would it be to have a haskell compiler implementation that doesn't rely on a garbage collector?
22:30:04 <shachaf> I would be worried about exactly the opposite effect.
22:30:33 <shachaf> Maybe I switch my type to use an Int instead of a String as some sort of optimization. Suddenly my SYB code starts changing that Int and my program breaks.
22:31:11 <johnw> shachaf: in my case the "targeted type" is very specific, so I can see why it was chosen; but the performance penality of the generalization is behaving torribly
22:31:36 <johnw> i wonder if it's syb's problem, or something in the way we're setting up the types
22:32:03 <simpson> nitrix: Sounds very tricky. What's the goal?
22:32:29 <shachaf> You can probably do better than SYB.
22:32:41 <nitrix> simpson: Informational, nothing else.
22:33:13 <johnw> considering that there were only two "points" being modified within a structure that was a non-recursive record, the non-syb version was just 1 line of code longer.  much better than syb
22:39:12 <prinsen> dcoutts_: Thanks!
22:58:48 <lispy> Haskell embedded DSL for writing low-level systems code: http://ivorylang.org/
22:59:05 <johnw> lispy: interesting!
23:00:00 <johnw> lispy: perfect timing, mentioning that just now
23:00:15 <MP2E> wow nice
23:01:07 <lispy> johnw: sweet! Really I don't deserve any credit. Never worked on it.
23:05:34 <dfeuer_> OK people. Give me a clue. Why doesn't foldr/build fire here? http://lpaste.net/110032
23:06:10 * hackagebot alfred 0.2 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.2 (PatrickBahr)
23:06:44 <johnw> dfeuer_: um, context?
23:07:19 <dfeuer_> johnw, what context do you want? I'm asking because there could potentially be a lot of context.
23:07:29 <johnw> well, what you pasted is meaningless to me
23:07:46 <johnw> and since I just read a paper on foldr/build fusion, I might have something to say
23:07:58 <dfeuer_> johnw, I'm not trying to be difficult. At all.
23:08:10 <johnw> can you show me the code that produced this output?
23:08:15 <dfeuer_> Yes!
23:08:20 <dfeuer_> Let me add that to the paste.
23:09:19 <shachaf> At some point in one's life in this channel, one should learn how to ask questions in such a way that the people answering them have maximal information and the easiest time figuring out what's going on.
23:09:28 <shachaf> Hopefully that point is "right away".
23:10:50 <dolio> It doesn't fuse because you don't have foldr k z (build g)
23:11:16 <dfeuer_> johnw, I just edited it.
23:11:57 <dfeuer_> dolio, I don't?
23:12:08 <dolio> Certainly not in the core you showed at the time.
23:12:14 <johnw> from the output, it looks like the outer foldr/build is fusing, but the inner foldr remains
23:12:24 <johnw> oh, n/m
23:12:41 <dfeuer_> johnw, yes, one foldr/build pair fuses and the other does not.
23:12:55 <johnw> doesn't that make sense though?
23:13:01 <johnw> you haver foldr/build/foldr
23:13:43 <dfeuer_> dolio, is the problem that it's pulled out lvl_s24Q, and that somehow separates the foldr from the build and it can't see that they're next to each other?
23:14:16 <dolio> If it's a separate definition, then they're not next to each other.
23:14:31 <dfeuer_> dolio, is there a trick to keep it from doing that?
23:14:46 <dolio> I don't know.
23:15:07 <shachaf> I think if you inline by hand carefully you'll see what it's doing.
23:15:13 <shachaf> If I'm right about what it's doing.
23:15:18 <spopejoy> given a function f :: State S V, and an initial invocation 'evalState f (S value)' etc: is there any way to initiate the V value within that initial invocation? Examples all seem to want the V value to "get going" in f.
23:15:57 <shachaf> spopejoy: No. State S V is a fancy way to write S -> (V,S)
23:15:59 <merijn> spopejoy: You could do "put" within f and do "evalState f undefined", but you probably shouldn't
23:16:15 <shachaf> And not too fancy, at that.
23:16:34 <spopejoy> ok. my fun is recursive so it sounds like I need a starter fun and a separate monadic loop fun.
23:17:21 <shachaf> You might not want to use State in the first place.
23:17:26 <spopejoy> :)
23:17:33 <spopejoy> believe me i tried :)
23:18:04 <spopejoy> but I was passing/reassigning a var through many invocations and it's begging for monadic magic
23:18:14 <johnw> you could use ST
23:18:26 <carter> ST monad is awesome
23:18:28 * shachaf sighs
23:18:30 <carter> i need to use it more
23:18:36 <johnw> but then you're still passing around a var, so n/m
23:18:40 <carter> well, i'm using PrimMonad a lot, so i guess that counts
23:19:00 <spopejoy> ST is a little .. involved. I don't need the encapsulation, for one
23:19:10 <carter> its not involved at all
23:19:14 <carter> its pretty simple
23:19:32 <johnw> lispy: ivory doesn't build with 7.8.3; fix!
23:19:41 <carter> johnw: whats the error
23:19:55 <lispy> johnw: https://github.com/GaloisInc/ivory :)
23:20:00 <johnw> base == 4.6.0.0
23:20:13 <carter> --allow-newer=base ?
23:20:14 <lispy> " It is not compatible with GHC 7.8.x at this time. Expect 7.8 support to include changes that will break 7.6 compatibility."
23:20:16 <johnw> if I ignore deps, it breaks due to changes in TypeLits
23:20:27 <carter> oh
23:20:29 <carter> lol
23:20:43 <carter> yeah, if they're type lit heavy that takes some work
23:21:02 <lispy> It uses a lot of ghc extensions
23:21:08 <johnw> lispy: I'm adding support to Nix now, at least for building with 7.6
23:21:15 <lispy> cool
23:21:23 <lispy> You should let them know, maybe make an issue?
23:21:33 <dolio> dfeuer_: What if you run with -fno-full-laziness?
23:21:38 <johnw> i'm shaving other yaks
23:21:42 <lispy> They may not use it, but it would be exciting
23:21:56 <johnw> the YakStack
23:21:56 <dfeuer_> dolio, if I fix c and n to specific functions, that seems to help.
23:22:12 <dfeuer_> At least with simple enough ones. (s/functions/values)
23:23:51 <dfeuer_> dolio, -fno-full-laziness makes it work.
23:24:22 <dolio> What if you mark builder inline?
23:24:57 <lispy> builder? I was thinking maybe inlining foo would help
23:25:10 * lispy doesn't know what he's talking about when it comes to fusion (or fission)
23:25:30 <shachaf> dfeuer_: When I build that code as-is fold/build fires.
23:25:32 <dolio> It's the takeWhile/enumFromTo that isn't fusing, I think.
23:25:40 <dfeuer_> lispy, inlining foo isn't something the library can do.
23:25:48 <shachaf> ("as-is" + hiding takeWhile)
23:26:15 <dfeuer_> shachaf, when I do that, it fires once, but I want it to fire twice.
23:27:52 <dfeuer_> dolio, inlining builder doesn't seem to help any.
23:28:20 <dfeuer_> Unless you mean inline by hand, which I haven't tried.
23:28:21 <dfeuer_> Let me do that.
23:28:31 <dfeuer_> Yes, of course you meant that.
23:28:32 <dolio> No. I meant putting a pragma.
23:28:32 <dfeuer_> Duh.
23:28:40 <carter> {-# INLINE foo #-}
23:28:50 <dfeuer_> Yeah, well, that did nothing.
23:29:14 <spopejoy> actually, seems like a straightforward approach for a recursive State fun is use an argument, ie fun :: V -> State S V. The V in the state is only meaningful in the final 'return'.
23:29:24 <carter> shachaf: ahh
23:29:28 <carter> spopejoy: ah
23:29:52 <carter> spopejoy: so Data Fun s = s -> Fun s ?
23:29:53 <dfeuer_> And I guess I can't exactly inline that....
23:30:05 <edwardk> carter: looks like no good deed goes unpunished, https://github.com/haskell/random/issues/14 =)
23:30:30 <carter> edwardk: lessor of the evils
23:30:37 <spopejoy> carter: no, just a function. For instance, assembling a list: myfun :: [a] -> State (Foo,Bar) [a]
23:30:54 <carter> edwardk: so should it be a minor or major bump?
23:31:18 <carter> i feel like theres a distinction between a RNG being determnistic within a given version vs between versions
23:31:19 <edwardk> carter: do you want to bundle up the major version bump for that, and the latest pull for issue 12 into a single patch and go from there?
23:31:30 <carter> i'd be down for doing that
23:31:36 <edwardk> and kill the existing version pushed to hackage?
23:31:43 <carter> should i kill it now?
23:31:44 <edwardk> we'll seek less noisy solutions in the future
23:31:54 <edwardk> get a replacement first
23:31:55 <carter> shoudl i  add myself to uploaders?
23:32:06 <carter> bump to 1.1 or 1.0.2 ?
23:32:11 <edwardk> 1.1
23:32:11 <carter> 1.1 i guess?
23:32:15 <edwardk> color it a major bump
23:32:20 <carter> k
23:32:42 <carter> i'll prep that after I sleep, then ping you for a thumbs up and then i'll upload?
23:33:00 <edwardk> i was hoping to bundle more of the current ghc trac backlog for random with 1.1, but this'll do
23:33:20 <carter> you mean the "port tf-random features to random" stuff?
23:33:26 <edwardk> no
23:33:45 <edwardk> bits about stating the random range starting at 1, and another tweak that was proposed to it
23:33:57 <carter> which tix are those?
23:34:18 <edwardk> 4218 8899
23:34:37 <edwardk> 7936 is merged into 4218
23:35:05 <edwardk> https://ghc.haskell.org/trac/ghc/ticket/427 is more about something closer to the merge tf-random item
23:35:12 <edwardk> but i want to punt on that for now
23:35:19 <carter> ok
23:36:20 <carter> ok, i've made some notes so i can look up our chat tomororw
23:36:43 <carter> edwardk: when do you get to gotenburg
23:36:44 <dfeuer_> dolio, the full laziness thing is wonked. Well, not full laziness per se, but the fact that it interferes with RULES the way it does.
23:36:54 <edwardk> carter: saturday
23:36:55 <carter> I need to figure out whhat i'm doing for my cellphone while im ther
23:36:58 <carter> ah
23:36:59 <carter> me too
23:37:05 <carter> i'm going ot be wrecked
23:37:10 <carter> need to finish prepping my talk / demo :)
23:37:17 <bmcorser> Iceland_jack: one line after all :) https://gist.github.com/bmcorser/1a6b8bd68ff090c7de82
23:37:20 <edwardk> likewise
23:37:46 <bmcorser> i don't think i could improve on that
23:38:10 <AfC> oh, bloody. Now what? "/usr/bin/ld: cannot find -lHSrandom-1.0.1.3-ghc7.8.3"
23:39:12 <carter> edwardk: i suppose i should add myself to uploaders
23:39:14 <AfC> edwardk: oh, were you just talking about a bug in tf-random a moment ago?
23:39:20 <carter> AfC: no
23:39:20 <carter> random
23:39:32 <c_wraith> bmcorser: I think your (\a b -> concat [b, a]) is just (flip (++))
23:39:41 <carter> the 1.0.1.3 release should have been a 1.0.2 or 1.1
23:39:46 <carter> or waited till the new maintiner took over
23:39:59 <carter> or something
23:40:01 <carter> now its triage
23:40:16 * dfeuer_ looks at the GHC FAQ to try to understand how to defeat full laziness....
23:40:18 <carter> edwardk: by the power of core libraries, should i add myself to random uploaders?
23:40:34 <dfeuer_> carter, you are the MOST random uploader.
23:40:37 <AfC> carter: hm. Ok. I'm trying to create a CI+CD environment, and with pristine pure cleanroom build all they way up I'm getting errors like that one above. At first I thought it was a .cabal/config setting problem. Now I don't know what it could be
23:40:49 <carter> AfC: what oS?
23:41:03 <AfC> carter: base is Debian
23:41:05 <carter> AfC: also, when was the last time you did cabal uppdate?
23:41:14 <AfC> 30 minutes ago?
23:41:14 * hackagebot wreq 0.2.0.0 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.2.0.0 (BryanOSullivan)
23:41:20 <bmcorser> c_wraith: oh yeah, cool
23:41:22 <carter> AfC: ok, when did you install random?
23:41:31 <AfC> 30 minutes ago
23:41:32 <carter> this is a weird bug
23:41:34 <carter> ok
23:41:36 <AfC> *clean*
23:42:08 <carter> hrmm
23:42:29 <carter> AfC: soo... 1.0.1.3 will be marked deprecated sometime tomororw even this linker error aside
23:42:54 <carter> AfC: could you try using 1.0.1.2 for today?
23:43:34 <carter> edwardk: leme know once you get back / pm or othewise, on the uploader part, but i'll pester you before i merge /push to sanity check
23:43:44 <carter> on the github front
23:43:50 <edwardk> carter: sure, ping me when you wake up
23:43:55 <carter> yeah
23:43:57 <carter> ok
23:44:02 <AfC> carter: that's a good question. --constrain to `cabal` or something like that, right?
23:44:19 <carter> orjust cabal install random-1.0.1.2
23:44:33 <carter> i should crash
23:44:42 <carter> i got A LOT i wanna get done the next few days
23:45:00 <comerijn> Ah, bollocks!
23:45:06 <comerijn> ghc depends on binary?
23:45:37 <comerijn> Crap :\
23:45:40 <carter> comerijn: which ghc vesion?
23:45:51 <comerijn> 7.8.3
23:45:56 <carter> and hows it affectin you?
23:46:08 <carter> comerijn: multi versionlinking will work in 7.10 :)
23:46:12 <comerijn> Data.Binary.Get.isolate only appears in binary-7.2.0
23:46:25 <comerijn> And ghc-7.8.3 depends on binary-7.1.0
23:46:29 <dfeuer_> dolio, the FAQ talks about GHC not floating a let between two lambdas. Any idea what that means?
23:47:06 <carter> comerijn: coudln't you copy the source?
23:47:09 <carter> https://hackage.haskell.org/package/binary-0.7.2.1/docs/src/Data-Binary-Get-Internal.html#isolate
23:47:27 <comerijn> carter: I'm gonna try
23:47:34 <carter> copy and paste
23:47:38 <carter> maybe i'tll still work
23:47:40 <carter> ok
23:47:41 <carter> night
23:48:18 <comerijn> carter: Well, I'll have to import Get.Internal too and cross my fingers
23:49:15 <dolio> dfeuer_: I'm not exactly sure what you're reading, but I think it means it won't turn '\x y -> let z = x + 1 in z + y' into '\x -> let z = x + 1 in \y -> z + y'
23:49:48 <dfeuer_> dolio, http://www.haskell.org/haskellwiki/GHC/FAQ#When_can_I_rely_on_full_laziness.3F
23:50:02 <dfeuer_> I don't think I understand it well enough to understand how to defeat it properly.
23:50:19 <dolio> You're not going to defeat it.
23:50:27 <dfeuer_> Hmmm.
23:50:41 <dolio> It's lifting a constant expression out to the top level.
23:51:13 <dfeuer_> But I don't want it there, because I'm not done with it!
23:51:22 <dolio> I don't know what you can do besides make the fusion run earlier than it does that. But I don't know if that's possible.
23:53:04 <dfeuer_> dolio, is there a way to make the constant expression not look like a constant expression?
23:53:23 <dfeuer_> There is no earlier available to me.
23:53:58 <dfeuer_> The badness seems to happen very early.
23:54:37 <comerijn> So, if Data.Binary.Get.Internal doesn't export a constructor that I need, am I just boned?
23:55:35 <merijn> I'm guessing that attempting to upgrade binary is going to be a major suckfest and break all my stuff?
23:56:01 <dfeuer_> dolio, I think maybe it *would* happen in the gentle simplifier phase, except that that phase does no inlining, and in particular does not inline $.
23:56:55 <dfeuer_> Nah, that doesn't work either.
23:57:18 <dfeuer_> Ah.
23:57:19 <dfeuer_> Right.
23:57:23 <dfeuer_> NO inlining.
23:58:16 <marchelzo_> How do you make a haskell program that you can pipe stuff into in bash?
23:58:45 <dfeuer_> marchelzo_, you make a Haskell program that reads from standard input.
23:59:09 <marchelzo_> dfeuer_: but how do you read until EOF?
23:59:32 <merijn> No one?
