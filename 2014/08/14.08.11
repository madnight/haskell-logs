00:00:16 <sgronblo> merijn: hehe i guess we are in philosophy class now
00:00:34 <haasn> sgronblo: Would you consider [Int] an action producing an Int?
00:00:38 <merijn> sgronblo: If, for conceptual simplicity's sake we ignore >>= as it's a bit unwieldy and instead look at >=>, then we know the following from the monad laws
00:00:42 <merijn> :t (>=>)
00:00:43 <haasn> Because [] is both an Applicative and a Monad
00:00:43 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
00:00:55 <sgronblo> I'm still struggling to come to terms with what exactly people mean when they talk about an action
00:01:17 <Fuuzetsu> ‘instruction’?
00:01:18 <merijn> sgronblo: If a monad obeys the law than ">=>" is associative, that is "(f >=> g) >=> h" = "f >=> (g >=> h)"
00:01:19 <haasn> sgronblo: It's a generic term we use for lack of anything better. An action is something of type :: m a; where m is implied to be an instance of Monad
00:01:29 <merijn> sgronblo: And "return" is the identity for ">=>"
00:01:29 <mjrosenb> > [\x -> case x of 1 -> "foo"; 2 -> "bar"] <*> [1]
00:01:30 <haasn> Like for example “getLine :: IO String” is an IO action
00:01:31 <lambdabot>  ["foo"]
00:01:41 <haasn> And “putStrLn :: String -> IO ()” is a function producing an IO action
00:02:01 <merijn> sgronblo: The sequencing behaviour of IO follows from monad laws like that and the definition of what IO as a type does
00:02:49 <haasn> > [1] >>= \x -> case x of 1 -> ["foo", "foo", "foo"]; 2 -> ["bar"]
00:02:51 <lambdabot>  ["foo","foo","foo"]
00:03:29 <merijn> sgronblo: If you consider "m a -> (a -> m b) -> m b" and know that "'IO a' is a computation that produces an 'a'", then it is clear that >>= has to execute the first argument first
00:03:51 <sgronblo> Tell me if this is mistaken: It seems that Applicative's actions can depend on earlier actions, it's just that their dependency is hardcoded in the instance of Control.Applicative?
00:03:59 <merijn> sgronblo: Else how could you give an 'a' to the function to produce 'm b'? There is no 'a' until you execute the IO action
00:04:40 <merijn> sgronblo: In a limited way, yes, such hardcoding still needs to obey the Applicative laws, but yes the Applicative can do some fancy things
00:05:03 <sgronblo> As in Just (+3) <*> Just 5 -> Just 8, but Nothing <*> Just 5 -> Nothing, if these Maybes correspond to actions then the result of the Just 5 "action" is dependent on the first.
00:05:58 <merijn> sgronblo: Right, if the Applicative holds some form of context, then the Applicative instance can use this. Which incidentally, lets you do some interesting things
00:06:35 <merijn> sgronblo: Consider the "Async a" type that produces an 'a', >>= would have to wait for the initial "Async a" to return before it could use the 'a' to create a new Async
00:06:53 <haasn> > ("foo", (+)) <*> ("bar", 1) <*> ("bat", 2)
00:06:55 <lambdabot>  ("foobarbat",3)
00:07:21 <merijn> sgronblo: Applicative can run the "function producing Async" and the "function argument Async" in parallel, because they're independent and running them in parallel still follows the Applicative laws
00:07:45 <mjrosenb> merijn: is the thing you're trying to point out that monad's function argument is its second argument, or that (>>=)'s second argument returns an (m b) rather than a (b), which it then wraps?
00:09:01 * hackagebot hspec 1.11.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.11.2 (SimonHengel)
00:09:01 * hackagebot hspec-meta 1.11.2 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.2 (SimonHengel)
00:09:19 <merijn> mjrosenb: I mean that result of the function argument of >>= can depend on the result of >>='s first argument in arbitrary ways
00:09:40 <haasn> sgronblo: The Applicative that really helped me internalize the notation and functions is Parsec
00:09:48 <haasn> (Although Parsec is incidentally also a Monad)
00:10:05 <joelteon> the DSL that blaze uses is also an Applicative
00:10:26 <insejn> can somebody explain to me why I’m getting “No instance” error when compilig this code: http://lpaste.net/109189
00:11:28 <sgronblo> haasn: Yeah I've read a bunch of stuff about Parsec, but I should re-read now that I brushed up on the Applicative a bit.
00:11:41 <mjrosenb> merijn: I am still not seeing how this is different from giving an arbitrary a->b wrapped in an f as the first argument to <*>
00:13:16 <benzrf> mjrosenb: ok, think about this
00:13:25 <haasn> An interesting difference between Monad and Applicative is that Monad enforces a sort of “order” - for example :: IO a -> (a -> IO b) -> IO b  has to execute the IO a action before the (a -> IO b) action because otherwise how would it get an ‘a’ to plug into the function
00:13:27 <benzrf> mjrosenb: take the concrete example of `getLine >>= putStrLn'
00:13:40 <benzrf> mjrosenb: you cannot write that with Applicative
00:13:42 <benzrf> you need Monad
00:14:14 <benzrf> mjrosenb: Applicative allows "external" joins
00:14:14 <haasn> Meanwhile, Applicative's :: IO (a -> b) -> IO a -> IO b could just as well execute the IO a before the IO (a -> b)
00:14:14 <haasn> eg. f <*> x = do a <- x; fun <- f; return (fun x)
00:14:19 <benzrf> Monad allows "internal" joins
00:14:36 <merijn> mjrosenb: The side effects of <*> can't depend on 'a'
00:14:43 <haasn> And in fact, you can “reverse” the order of any Applicative
00:14:53 <haasn> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Applicative-Backwards.html#v:Backwards
00:14:57 <mjrosenb> benzrf: ok, so we are saying the same thing, just he's using terminology that is more confusing to me.
00:15:08 <benzrf> ok
00:15:24 <corgifex> insejn: the problem is your definition of runWriter
00:15:34 <merijn> mjrosenb: Imagine the the trivial "x :: IO Bool" and "x >>= \b -> case b of True -> print "Yay!"; False -> print "Boo!"" <- what gets printed depends directly on the value produced by 'x'
00:15:34 <benzrf> mjrosenb: when you have applicative (ignoring pure), the most powerful thing you can do on top of Functor is `f a -> f b -> f (a, b)'
00:15:38 <haasn> Which is not that surprising when you consider the alternative definition of Applicative involving (**) :: Applicative f => f a -> f b -> f (a,b)
00:15:41 <corgifex> insejn: its type doesn't mention m anywhere
00:15:55 <haasn> Because you can just use fmap swap :: Functor f => f (a,b) -> f (b,a) -- to flip the order of results
00:16:08 <benzrf> mjrosenb: you cannot determine the particular f around the f b in terms of the a "in" the f a
00:16:23 <benzrf> mjrosenb: because the f a and f b already exist as regular values
00:16:30 <benzrf> mjrosenb: so the f must be predetermined
00:16:33 <benzrf> ON THE OTHER HAND
00:16:45 <benzrf> Monad gives you join :: m (m a) -> m a
00:17:09 <benzrf> since the m a is inside the outer m, it may depend on the previous "contents" of the m
00:17:18 <benzrf> it can depend on them
00:17:39 <insejn> corgifex: how did you come to this conclusion by looking at the error message?
00:17:42 <benzrf> if you have `m b' and `b -> m a', you can fmap the latter over the former and get m (m a)
00:17:56 <benzrf> and now the inner value is dependent upon the result of the original
00:18:02 <benzrf> if you apply join, you have an m a
00:18:03 <insejn> corgifex: I feel that I’m having problems with correctly decrypting them
00:18:06 <benzrf> you just bound
00:18:11 <corgifex> insejn: well, it said the error is in the subexpression 'runWriter mul'
00:18:36 <corgifex> corgifex: at first I was like "what do you mean, ambiguous variable?! mul is clearly a Writer [String] Int"
00:18:44 <corgifex> haha, wtf
00:18:47 <corgifex> insejn:
00:18:56 <benzrf> with Applicative, you must have an f a and an f b outside of anything else. with Monad, you may have nesting, which allows dependency
00:19:04 <benzrf> on the part of the m, anyway
00:19:16 <corgifex> insejn: but then I noticed that you'd defined your own Writer and had a closer look at runWriter
00:20:10 <corgifex> insejn: right away I noticed some non-standard bits (like superfluous Monoid w constraints)
00:20:27 <mjrosenb> benzrf: right, I said the main difference is that with Applicative, the 'function' argument returns a pure value, which <*> wraps in an f, whereas the function argument to >>= returns an m b, so it has free reign over the whole return value
00:20:36 <corgifex> insejn: I also know that runWriter is normally not a method
00:20:41 <mjrosenb> ok, reactive banana is built
00:20:46 <mjrosenb> I am going to bed.
00:21:06 <hamid> > (+) <$> Just 1 <*> Just 2
00:21:07 <lambdabot>  Just 3
00:21:30 <corgifex> insejn: and then I noticed that the MonadWriter class uses the Writer type, which makes no sense. MonadWriter is supposed to be generic, with Writer just an instance of it
00:21:47 <hamid> shachaf, so this ( fmap (+) (Just 1) ) >>= (\x -> return (x 2) ) == (+) <$> Just 1 <*> Just 2
00:21:51 <hamid> shachaf, right?
00:21:59 <insejn> corgifex: ah, gotcha
00:22:07 <insejn> corgifex: corgifex: So here’s another question: how do you know when to implement something as a method vs plain function?
00:22:13 <corgifex> insejn: well, and then I saw that nothing in runWriter actually nails down m (not mentioned explicitly, no functional dependencies)
00:22:14 <hamid> shachaf, you meant >>= (\x -> return (x 2) ) is another fmap. like that?
00:22:19 <shachaf> hamid: Those two values happen to be equal.
00:22:47 <shachaf> They're both (Just 3).
00:22:55 <solidus-river> > (+) <$> 1 <*> 1
00:22:57 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
00:22:57 <lambdabot>    arising from a use of ‘M451171418085496471010103.show_M4511714180854964710...
00:22:57 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
00:22:57 <lambdabot>  Note: there are several potential instances:
00:22:57 <lambdabot>    instance [safe] GHC.Show.Show a =>
00:23:00 <solidus-river> i think i'm misunderstanding applicative
00:23:12 <benzrf> solidus-river: yep
00:23:14 <hamid> hmm
00:23:21 <solidus-river> > (+) <$> [1] <*> [1]
00:23:22 <lambdabot>  [2]
00:23:33 <solidus-river> i think i got it now
00:23:40 <solidus-river> :P
00:24:08 <corgifex> insejn: depends :-)
00:24:40 <haasn> hamid: That's “also fmap” but via a different law
00:24:41 <corgifex> insejn: like, I know the type of runWriter should be Writer w a -> (a, w), so it's not a method
00:24:59 <haasn> hamid: In effect what you have is your fmap (+) (Just 1) <*> Just 2
00:25:13 <haasn> And since pure = Just for the Maybe applicative, this is fmap (+) (Just 1) <*> pure 2
00:25:23 <solidus-river> i really dont like how with arrows you cant use where syntax to build up functions
00:25:26 <corgifex> insejn: you could try to generalize it to (MonadWriter w m) => m a -> (a, w), but that precludes some useful instances of MonadWriter
00:25:30 <haasn> Which via an applicative law is essentially fmap (\f -> f 2) $ fmap (+) (Just 1)
00:25:34 <haasn> hamid: Does that make sense?
00:25:43 <solidus-river> anything using where claims its not in the scope of the lambda
00:25:52 <solidus-river> or i guess, is it possible to use where blocks in lambdas?
00:26:33 <hamid> haasn, yeah it makes sense.
00:27:27 <haasn> Which is also the same form you get if you reduce fmap (+) (Just 1) >>= \x -> return (x 2)  to fmap (\x -> x 2) $ fmap (+) (Just 1)
00:28:18 <sgronblo> haasn: On the HN thread some guy said "For the most part, only "special" monads like IO enforce sequential computation.", "No, IO doesn't either, because of laziness."
00:28:42 <haasn> Note that since fmap f . fmap g = fmap (f . g) this is also equal to fmap ((\f -> f 2) . (+)) (Just 1)  which can be reduced to fmap (\x -> x + 2) (Just 1)   = fmap (+2) (Just 1); which via an Applicative law (fmap f (pure x) = pure (f x)) is the same as Just (1+2) = Just 3
00:28:49 <orion> In a .prof file, what does the "entries" column stand for?
00:28:52 <haasn> So we can essentially prove what shachaf said via transformations due to laws
00:29:57 <haasn> sgronblo: That's... tricky to answer. In general, IO does indeed force sequential computation - but there exists a concept of “lazy IO” that can make /some/ side effects occur at a later time. This term is somewhat distinct from the concept of “laziness” in general, which is an artifact of *pure* computations, not side effects.
00:30:16 <solidus-river> ApplicativeDo seems odd
00:30:23 <hamid> haasn, +1
00:30:28 <hamid> haasn, thanks :)
00:30:36 <insejn> corgifex: but tell should be a method, correct?
00:30:56 <hamid> I love #haskell :)
00:31:05 <haasn> All significantly non-trivial monads imply some sort of “strictness sequence” though; for example what happens if we evaluate:  error "foo" >>= error "bar"
00:31:06 <solidus-river> however i immediatly love it because it removes more lambda notation
00:31:09 <haasn> Which error will we see?
00:31:14 <insejn> corgifex: also what useful instances of MonadWriter do you have in mind?
00:31:15 <corgifex> insejn: well, you could write everything without classes, just plain Writer
00:31:35 <haasn> For monads, most likely "foo"; for Applicatives (via error "foo" <*> error "bar") we can't really tell in general
00:31:44 <haasn> Does that make sense?
00:31:45 <insejn> corgifex: exactly, so that’s my previous question — when do you actually turn something into a method...
00:31:46 <corgifex> insejn: particularly the stuff formed by monad transformers
00:31:53 <sgronblo> haasn: yeah exactly lazy IO was mentioned in the next comment
00:32:14 <corgifex> insejn: like WriterT w (Reader r) or something
00:32:20 <dolio> > (error "foo" >>= error "bar") 5
00:32:21 <lambdabot>  *Exception: bar
00:32:44 <merijn> sgronblo: Lazy IO requires abusing unsafe functions to create it, though
00:32:50 <haasn> dolio: Oh, nice counter-example
00:33:14 <corgifex> insejn: you turn it into a method when you want to write code that works with two or more different types, I guess
00:33:20 <merijn> solidus-river: ApplicativeDo is sensible, because applicative functions can do some things that >>= can't
00:33:30 <haasn> > runIdentity (error "foo" >>= error "bar")
00:33:32 <lambdabot>  *Exception: bar
00:33:35 <haasn> This one also works
00:33:48 <dolio> What is lazy I/O "abusing"?
00:33:49 <haasn> They're among the few monads I can think of where (>>=) isn't strict in its left argument
00:33:55 <merijn> dolio: unsafeInterleaveIO
00:34:05 <dolio> Lazy I/O is the intended use of that function.
00:34:12 <merijn> dolio: Sure
00:34:30 <merijn> dolio: My point is that "lazy IO" is not just "oh, lol, your IO is randomly lazy"
00:34:48 <haasn> Arguing about the pros and cons of lazy IO is tricky
00:34:51 <merijn> It requires manual intervention using unsafe functions to get it
00:35:00 <haasn> It seems to me that they are largely practical in nature, and not semantic
00:35:16 <Peaker> haasn: lazy IO is anything but practical. It is useful as long as the program is a toy
00:35:23 <merijn> The fact that that's the intended usecase of, for example, unsafeInterleaveIO, doesn't make it any less abuse than unsafePerformIO
00:35:30 <haasn> Peaker: I'm including the disadvantages
00:35:32 <Peaker> Once it grows, lazy I/O blows up in various interesting ways
00:35:47 <merijn> Peaker: Hence why we now have pipes & co :)
00:36:01 <Peaker> merijn: unsafePerformIO has valid use cases though, where it could be named "safePerformIO" :-)
00:36:07 <Peaker> unsafeInterleaveIO is invalid by design (IMO)
00:36:57 <haasn> unsafeInterleaveIO's worst crime is that it breaks the sort of expectation that changing the order of evaluation preserves the result
00:37:11 <haasn> (excepting cases where this leads to a loop)
00:37:54 <merijn> Oh well, there's worse things than those two around :p
00:38:10 <shachaf> haasn: What I said was that they are the same value.
00:38:14 <haasn> do a <- unsafeInterleaveIO (print 1); b <- unsafeInterleaveIO (print 2); a `seq` b `seq` return () -- vs b `seq` a `seq` return ()
00:38:43 <shachaf> Whether those expressions are "doing the same thing" is a different question (and a tricky one to make sense of, so I didn't say anything about it. I'd say that the answer is no, though).
00:38:59 <dolio> haasn: There is no guarantee that those won't print the same thing.
00:39:15 <corgifex> pseq
00:39:16 <haasn> shachaf: That was aimed at “They're both (Just 3)”; I was showing how one could achieve this result using only general Applicative/Monad/Functor laws and the fact that pure = Just
00:40:02 <haasn> dolio: Right; but there's also no guarantee that they *will* print the same thing; which is sort of what I'm getting at
00:40:35 <dolio> There is also no guarantee that a `seq` b `seq` return () will print the same thing every time.
00:41:03 <glguy_> which is why corgifex wrote : pseq earlier
00:41:07 <dolio> Right.
00:41:20 <Darwin226> Is it at all possible to write a function with a pure interface that does an inplace quicksort on an array?
00:41:32 <trap_exit> what is the overhead of instaianting the identity monad
00:41:34 <corgifex> Darwin226: yes, ST
00:41:35 <trap_exit> does the compiler optimize it away ?
00:41:38 <Fuuzetsu> oh, cool, so you can recover ‘the old way’ in vinyl through some nice trickery
00:41:47 <Fuuzetsu> but it sounds like the new way might be what I want more
00:41:53 <Darwin226> corgifex: But doesn't that mean that you still do a copy of the array at the start?
00:42:05 <haasn> Not if it's already a mutable array
00:42:06 <corgifex> Darwin226: what array?
00:42:08 <dolio> There is also no guarantee that: 'a <- forkIO (print 1) ; b <- forkIO (print 2) ; a `seq` b `seq` return ()' will print the same thing every time.
00:43:11 <merijn> Darwin226: Yes, you can directly make the initial array mutable, but it's horrifically unsafe and likely to break
00:43:12 <Darwin226> corgifex: Well, I don't know. Does it matter? I don't know have a particular usecase.
00:44:02 <Darwin226> merijn: Is that somehow still pure or is it in the same category as unsafePerformIO?
00:44:03 <haasn> If your parameter is an immutable array, it's immutable and touching it should be impossible
00:44:33 <haasn> If your parameter is a mutable array, it's already mutable
00:44:37 <haasn> It depends on what you want
00:44:49 <haasn> This is not really an implementation issue as much as a semantics issue
00:45:06 <merijn> Darwin226: The same category as unsafePerformIO, you have to copy the initial array to do it safely, yeah
00:45:11 <insejn> corgifex: I still feel like I do not completely understand the previous error: a0 is ambiguous. Where’s the ambiguity coming from? It feels to me that I actually want it to be polymorphic and therefore ambiguous, no?
00:45:41 <corgifex> insejn: the error was about m0, not a0
00:45:43 <merijn> Darwin226: To do in-place updates like that in a purely functional way you'd need something like linear types, which haskell doesn't have
00:46:19 <merijn> Darwin226: Unless you initialise the array mutably, of course, then you're fine without either the unsafe operation or copying
00:47:02 <Darwin226> merijn: Does haskell ever decide that an update is safe to do inplace? Outside of ST I mean?
00:47:30 <shachaf> That sort of depends on what you mean by "an update".
00:47:53 <shachaf> That's not a notion that's built into the language.
00:47:57 <Darwin226> merijn: For example, if an immutable array is just a temporary value in a function that never gets used after you call magicalInplacePureSort arr
00:48:04 <solidus-river> can you not use where bindings in a lambda?
00:48:07 <shachaf> If a function calls itself recursively with a different argument, is that an update?
00:48:13 <shachaf> solidus-river: You cannot.
00:48:41 <insejn> corgifex: Right, I know how to fix this by making it a plain func, but just for kicks I did this: http://lpaste.net/109191
00:48:41 * solidus-river is sad at the unreadability of his lambdas
00:49:09 <dolio> let is the expression version of where.
00:50:00 <corgifex> insejn: yeah, now the problem is that the compiler doesn't know what w is in this expression
00:51:06 <merijn> Darwin226: That's the sorta thing linear types would help with, I don't think GHC can effectively do that sort of thing
00:52:47 <corgifex> insejn: the class definition says MonadWriter depends on two parameters, w and m, and they're independent
00:52:48 <corgifex> you can fix this by adding a functional dependency, so it can deduce w from m
00:52:48 <Darwin226> merijn: I see.
00:53:37 <frerich2> solidus-river: Can you paste them at lpaste.net ?
00:55:21 <solidus-river> frerich2: sure, they are particularly gruesome though http://lpaste.net/109192
00:56:10 <solidus-river> the ones that filter out inhibited wires are even worse to read because they have a list comprehension thrown in there at the end
00:56:34 <insejn> corgifex: Right, so this can be fixed by functional dependencies, I assume
00:57:11 <corgifex> yeah. class MonadWriter w m | m -> w where ...
00:57:21 <lfairy> or you can use type families
00:57:49 <lfairy> class MonadWriter m where type Inner m :: *
00:58:07 <corgifex> right now it assumes you could have both, say, instance MonadWriter [String] (Writer [String]) and instance MonadWriter Int (Writer [String])
00:58:54 <corgifex> it knows m = Writer [String] and it knows it has instance MonadWriter [String] (Writer [String]), but it isn't sure you really want w = [String] here
01:00:24 <hamid> I know this is wrong: [1,2,3] >>= (\x -> Just x)
01:00:46 <hamid> but I think chaining on different mondas can be quiet useful
01:00:59 <hamid> how can we acheive that in haskell?
01:01:10 <hamid> quite*
01:01:26 <corgifex> hamid: what would that do?
01:01:35 <Gaelan> @pl generate string options =   generatePattern string options ( generateBackground string options )
01:01:35 <lambdabot> generate = liftM2 ap generatePattern generateBackground
01:01:50 <solidus-river> frerich2: i'm playing around with ways to make a wire of wires that can grow / shrink in netwire
01:02:07 <lfairy> hamid: for that, you'd need to specify an explicit mapping between Maybe and []
01:02:14 <solidus-river> based off of what ocharles did
01:02:38 <hamid> corgifex, no idea :P just brainstorming
01:02:54 <hamid> lfairy, that makes sense. but what about transformations?
01:03:00 <Welkin> what did ocharles do?
01:03:10 * ocharles wonders what he did
01:03:12 <Welkin> also, how has netwire been going?
01:03:14 <lfairy> hamid: what do you mean, transformations?
01:03:25 <hamid> lfairy, is that what they are for?
01:03:31 * Welkin slaps handcuffs on ocharles for what he did
01:04:05 <lfairy> hamid: natural transformations? that's one thing you can do with them
01:04:31 <lfairy> in your case though, I'd just use mapMaybe
01:04:35 <lfairy> :t mapMaybe
01:04:36 <lambdabot> (a -> Maybe b) -> [a] -> [b]
01:05:20 <shachaf> lfairy: If hamid has no idea what that would do, how come you know?
01:05:45 <shachaf> Maybe that's not the best way of putting it.
01:05:50 <lfairy> shachaf: just guessing :\
01:05:51 <Welkin> Maybe
01:05:58 <lfairy> the other interpretation would be traverse, I guess
01:06:00 <Welkin> I see the pun
01:06:05 <frerich2> solidus-river: It looks like there's some duplication - I suspect it might be useful to have a slightly different order of arguments for 'stepWire' such that you don't need so many lambdas. Something like the annotation in http://lpaste.net/109192
01:06:17 <insejn> corgifex: thanks a lot bro!
01:06:38 <shachaf> I think figuring out what it would mean is the first priority, over specific implementation details of a specific thing it might mean.
01:07:13 <corgifex> 👍
01:07:51 <hamid> lfairy, thanks :)
01:08:02 <lfairy> np :)
01:08:03 <frerich> solidus-river: This is based on the observation that in your lambdas, there's always a "dt" passed to stepWire (but not via the lambda arguments) and never an action passed. To it makes sense to reorder the arguments such that the 'dt' thing comes first and the 'action' comes last.
01:08:37 <lfairy> there's another interpretation as well, using the traverse function
01:09:17 <solidus-river> frerich: but stepWire is a function provided by Netwire-5 is it considered bad to alias a different argument order to built in functions like that?
01:09:25 <lfairy> > traverse (\x -> if even x then Just (x `div` 2) else Nothing) [2,8,10]
01:09:26 <lambdabot>  Just [1,4,5]
01:09:27 <shachaf> I can think of lots of interpretations.
01:09:37 <lfairy> > traverse (\x -> if even x then Just (x `div` 2) else Nothing) [2,8,9]
01:09:38 <lambdabot>  Nothing
01:09:45 <shachaf> But neither mapMaybe nor traverse sound like they match the description of "chaining on different monads".
01:09:48 <solidus-river> not sure if that would be more confusing or less confusing than the lambda aproach for someone who is familiar with netwire
01:09:50 <lfairy> that's more of an "and" or an "or"
01:10:59 <solidus-river> thats much cleaner
01:11:39 <lfairy> shachaf: well, mapMaybe f xs = xs >>= listToMaybe . f
01:11:47 <shachaf> (To me it sounds like either a misunderstanding about the nature of monads -- which is most likely, and the answer to which is probably "you can't do that and it doesn't really make sense to want to" -- or some question the answer to which is monad transformers. Or maybe something else. But if people keep guessing we'll never find out what the question really is.)
01:11:49 <lfairy> *maybeToList
01:11:59 <shachaf> I know.
01:14:04 <frerich> solidus-river: 'stepWire2' is a somewhat lame name, that's true. You could avoid the extra function by using 'flip' instead, e.g. '\arrow input -> stepWire arrow dt input' is the same as '(flip stepWire) dt', but I'm not sure that's any nicer. It' just inconvenient for your particular use cases that the 'dt' argment is not the first :-)
01:14:06 * hackagebot transformers-base 0.4.3 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4.3 (MikhailVorozhtsov)
01:17:45 <frerich> solidus-river: This would be just a first step though, by making the code less noisy it's hopefully easier to spot bigger repetitions which can be factored out. All those '*Collection' functions seem to follow a similiar pattern, starting with mkGen, then doing some massaging, then a 'return (Right something, <recurse here>)'.
01:19:37 <lfairy> shachaf: I see your point -- I don't know why I assumed so much then
01:21:37 <solidus-river> working on it, first it seems i need to understand what flip does to functions with more than two arguments
01:22:02 <Pythonfant> @src flip
01:22:02 <lambdabot> flip f x y = f y x
01:22:39 <solidus-river> > let f a b c = (a, b, c) in flip f 1 2 3
01:22:40 <lambdabot>  (2,1,3)
01:22:49 <solidus-river> > let f a b c = (a, b, c) in flip flip f 1 2 3
01:22:51 <lambdabot>  Could not deduce (GHC.Num.Num
01:22:51 <lambdabot>                      (a0 -> (t0 -> t1 -> t2 -> (t0, t1, t2)) -> a1 -> t5))
01:22:51 <lambdabot>    arising from the ambiguity check for ‘e_1123’
01:22:51 <lambdabot>  from the context (GHC.Num.Num
01:22:51 <lambdabot>                      (a -> (t -> t3 -> t4 -> (t, t3, t4)) -> a2 -> t5),
01:23:01 <solidus-river> > let f a b c = (a, b, c) in flip (flip f) 1 2 3
01:23:03 <lambdabot>  (1,2,3)
01:23:16 <Pythonfant> solidus-river: f :: a -> b -> c -> d is the same as f :: a -> b -> (c -> d)
01:23:21 <solidus-river> > let f a b c = (a, b, c) in flip (flip f 1) 2 3
01:23:22 <lambdabot>  (3,1,2)
01:23:23 <adas> while writing brainfuck interpreter ... what is the best way to deal with brainfuck's jump instructions .. which are '[' and ']'?
01:24:08 <solidus-river> wish there was an easier way to think about that
01:24:16 <adas> reason i ask is because, to know where to jump to you need to know where the corresponding closing and opening squre bracket is..
01:24:26 <benzrf> adas: i cheated by using parsec
01:24:34 <benzrf> but it is not so hard to accomplish yourself
01:24:58 <solidus-river> but if you wanted to take a and make it c
01:25:40 <Pythonfant> solidus-river: I'm not sure but I think you can't accomplish that with flip
01:25:50 <adas> benzrf: yes, but could briefly tell me how you implemented the '[' and ']' instructions?
01:26:14 <Pythonfant> nobody stops you from writing flip3 f x y z = f z y x, ofc
01:26:29 <adas> benzrf: so you would use parsec to parse everything between a [ and ]?
01:30:35 <solidus-river> heh, i'm searching for the elusive 1 2 3 to 2 3 1 mapping via flip
01:32:58 <solidus-river> your right i htink its not possible, in order to get 2 before 1 you need to apply 1 already in which case you cant flip the 3
01:34:40 <benzrf> adas: parsec handles consumption of input & testing
01:35:04 <benzrf> so i just used that to simplify writing a recursive parse-inside-the-brkts parser
01:35:09 <benzrf> adas: to be precise you can do something like
01:35:32 <trap_exit> so I have a design qeustion
01:35:34 <trap_exit> I have this function, call it map__del1
01:35:36 <benzrf> uh
01:35:37 <benzrf> 1 sec
01:35:52 <trap_exit> which has type map__del1 :: Int -> IntMap v -> (Maybe v, IntMap v)
01:36:05 <trap_exit> where (1) it deletes the element from the map, and (2) returns it
01:36:14 <benzrf> adas: actually my particular solution would end up pretty much requiring you to reimplement the basics of parsec if u did it from scratch
01:36:17 <benzrf> ¯\(°_o)/¯
01:36:23 <trap_exit> so I'm trying to figure it out ... should it have type signature Int -> IntMap v -> (Maybe v, IntMap v)
01:36:33 <trap_exit> or should I throw it in amonad
01:36:34 <corgifex> @pl \f a b c -> f b c a
01:36:35 <lambdabot> flip . (flip .)
01:36:37 <adas> benzrf: so im better off using parsec or attoparsec
01:36:47 <trap_exit> so it's be like Int -> State (Map v) (Maybe v)
01:36:49 <thelinuxkitten> @type subparser
01:36:51 <lambdabot> Not in scope: ‘subparser’
01:36:57 <corgifex> @pl \a b c -> f b c a
01:36:57 <lambdabot> flip (flip . f)
01:37:14 <thelinuxkitten> @hoogle subparser
01:37:16 <lambdabot> No results found
01:37:45 <benzrf> adas: i dont
01:37:46 <benzrf> know
01:38:01 <benzrf> adas: it should be fairly easy to do it from scratch anyway?
01:38:08 <benzrf> i was wrong
01:38:12 <dropster> soneome here have time for a noob question regarding ADT ?
01:38:36 <adas> dropster: just ask
01:39:10 <dropster> Going through Begging Haskell and he have an exampole with an ADT that have another ADT inside but for me this doesnt work
01:39:41 <dropster> like Data client = individual Person Bool deriving show and the there is data person = person string string
01:40:12 <dropster> problem is that it complains that there is only two arguments
01:40:34 <corgifex> ok, first off: 1) what's your actual code?  2) what's the error message?
01:40:34 <benzrf> adas: i would recommend doing something like
01:40:45 <benzrf> wwait
01:40:45 <dropster> sorry for the missing caps
01:40:51 <corgifex> 3) the book isn't called "Begging Haskell"
01:40:52 <benzrf> well it depends i guess? maybe
01:41:03 <benzrf> adas: i wrote mine so it semi-compiles
01:41:15 <dropster> beginning Haskell
01:41:17 <dropster> :D
01:41:25 <benzrf> instead of keeping the code in-memory i build a StateT over IO
01:41:32 <corgifex> yes, and that's why I don't trust your retyped code
01:41:49 <benzrf> so im interpreting but not at quite as raw a level
01:41:56 <adas> benzrf: ah okay
01:41:59 <benzrf> i translate the code into an internal structure like a real interpreter would od
01:42:02 <benzrf> *do
01:42:25 <adas> benzrf: i prefer that too
01:45:33 <dropster> Any ideas ?
01:45:57 <corgifex> yes
01:46:16 <corgifex> could you answer my questions?
01:46:57 <dropster> yes sorry it slipped
01:47:48 <dropster> http://lpaste.net/109194
01:48:45 <corgifex> ok, that's #1
01:49:20 <dropster> this isn 1 & 2 combined http://lpaste.net/109195
01:50:10 <corgifex> ok, so that's not #1
01:50:11 <Gaelan> @pf hue HSL h _ _ = h
01:50:12 <lambdabot> Maybe you meant: pl bf
01:50:24 <Gaelan> @pl hue HSL h _ _ = h
01:50:25 <lambdabot> hue = const (const . const)
01:50:27 <corgifex> because the error is in the code 'Individual "Jack" "Smith" True' and that's not in your paste
01:50:35 <dropster> the last paste show sthe code and the error
01:50:52 <solidus-river> theres no isRight or isLeft for Either?
01:51:04 <corgifex> dropster: ok, the error message makes perfect sense to me
01:51:07 <corgifex> what's unclear?
01:51:23 <Maior> solidus-river: since 4.7.0.0
01:51:35 <solidus-river> Maior: why?
01:51:53 <dropster> in the book at says that would work too but it doesnt compared to having Individual String String bool in the definition of the ADT
01:52:02 <Maior> solidus-river: because that's when they were added and no-one added them before then?
01:52:25 <Maior> solidus-river: oh, did you parse my response as "there's no isRight since 4.7"?
01:52:28 <solidus-river> Maior: oh you mean there are? its not comin up via hoogle
01:52:38 <Maior> sorry, my response was ambiguous
01:52:40 <solidus-river> @hoogle Either a b -> Bool
01:52:40 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
01:52:40 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
01:52:40 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
01:52:55 <solidus-river> @hoogle (Either a b) -> Bool
01:52:55 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
01:52:55 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
01:52:55 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
01:52:56 <Maior> :t isRight
01:52:57 <lambdabot> Either a b -> Bool
01:53:33 <solidus-river> i'm on 4.8 i think but i don't have isright is it part of Prelude?
01:53:36 <corgifex> dropster: then the book is wrong
01:53:48 <solidus-river> its not in data.either
01:53:59 <corgifex> dropster: you'd have to do something like Individual (Person "Jack" "Smith") True
01:54:25 <Maior> solidus-river: you think; I'd check that
01:55:22 <Pythonfant> solidus-river: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Either.html#v:isRight
01:56:47 <solidus-river> oh know, i'm so wrong i'm in base 4.6
01:57:09 <dropster> Yes that work but isnt mentioned at all
01:58:06 <dropster> thanks
01:58:46 <Maior> solidus-river: hf ;)
01:59:11 <solidus-river> lol, is 4.7 stable? i wonder why i dont have it
01:59:35 <solidus-river> i've been running with the latest gentoo ebuild (2013.2) figured that was relatively up to date
02:00:31 <Maior> assuming "2013.2" means "February 2013", that does not seem relatively up to date
02:00:34 <Maior> but I don't speak Gentoo
02:00:56 <solidus-river> aye, this is wierd
02:01:17 <solidus-river> how do i check the version of base from a ghci prompt?
02:02:12 <supki_> :!ghc-pkg list base
02:03:36 <solidus-river> interesting, GLFW-b requires base 4.6.0.1
02:03:51 <solidus-river> i thoguht the GLFW-b bindings were relatively new
02:05:35 <Pythonfant> solidus-river: the version on hackage seems to only have an upper bound <5 for base
02:06:32 <solidus-river> hmm, in my cabal file i only ever say i need base and i don't specify a version, i'm assuming that defaults to the maximum possible stable version of base, is that right?
02:06:44 <solidus-river> or is there a way for me to tell what is causing an old version of base to be pulled in
02:07:24 <supki_> cabal always uses the installed version of base
02:07:26 <Fuuzetsu> how do I write down [String] when lifted to type level? Trying to make a field of type [String] in vinyl…
02:07:42 <supki_> and there's no way to upgrade it except upgrading ghc
02:07:47 <Fuuzetsu> Previously I had "something" ::: [String] but now you need some fancy new stuff with :~>
02:11:57 <finishingmove> I get an error installing GHC 7.8.3 on Ubuntu 14.04, something related to ghc-prim. Has anyone experienced this?
02:13:46 <corgifex> yeah, once I tried to install something on windows xp and also got an error related to something else
02:14:17 * hackagebot spoty 0.1.0.1 - Spotify web API wrapper  http://hackage.haskell.org/package/spoty-0.1.0.1 (DavidNilsson)
02:15:30 <solidus-river> is ghc 7.8 considered stable / safe?
02:16:41 <solidus-river> well, haskell.org says its released, i s'pose that also means stable
02:17:36 <Kinnison> I guess it depends what you mean by 'safe' though
02:17:42 <Kinnison> Debian/stable doesn't carry it yet
02:17:47 <Kinnison> and won't until Jessie is released
02:18:03 <Kinnison> So if you want wide adoption of your code, don't use 7.8 specific (or updated base, etc) code
03:53:58 <solidus-river> > fmap (+1) []
03:54:00 <lambdabot>  []
03:54:21 <solidus-river> > zipWith (+) [] []
03:54:22 <lambdabot>  []
03:57:08 <adas> > let fib = 0:1:(zipWith (+) fib (tail fib)) in take 10 fib
03:57:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
03:57:55 <adas> but thats an old trick
03:58:39 <solidus-river> neat :)
03:59:25 <adas> solidus-river: learning?
03:59:44 <solidus-river> always, but right now i'm destroying :\
03:59:53 <solidus-river> told gentoo to upgrade my haskell install from 7.6 to 7.8
03:59:57 <solidus-river> not goin terribly smooth
03:59:58 <solidus-river> lol
04:00:07 <adas> solidus-river: are you new to gentoo?
04:00:25 <solidus-river> no, i'm an old gentooer, been about 12 years now
04:01:01 <adas> solidus-river: cool. then okay.
04:01:07 <solidus-river> jesus.. its been 12 years
04:01:22 <solidus-river> on that reflection i'm going to sleep
04:01:44 <tv> > let fib = 0:scanl (+) 1 fib in take 10 fib -- also old, but nice :)
04:01:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
04:14:29 * hackagebot parsec-numbers 0.0.5 - Utilities for parsing numbers from strings  http://hackage.haskell.org/package/parsec-numbers-0.0.5 (ChristianMaeder)
04:14:31 * hackagebot parsec3-numbers 0.0.5 - Utilities for parsing numbers from Char sequences  http://hackage.haskell.org/package/parsec3-numbers-0.0.5 (ChristianMaeder)
04:33:11 <adas> a while back i read an article about a system that runs haskell directly on the metal without an OS. does anyone remeber the name?
04:33:22 <dibblego> house?
04:33:42 <Axman6> the one Galois did perhaps
04:33:58 <edofic> HaLVM
04:33:58 <Axman6> HaLVM
04:34:04 <Axman6> https://galois.com/project/halvm/
04:34:11 <adas> ah thanks
04:34:12 <Axman6> @quote stereo
04:34:12 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
04:34:31 <Axman6> hmm, less relevant that I had hoped that time
04:47:56 <rlp10> I'm new to attoparsec, how do I consume upto and including a specific string (e.g. "Selected Option:")? The stuff before might be several lines long.
04:52:26 <simukis_> rlp10: <* from Control.Applicative will be useful for that.
04:53:44 <simukis_> manyTill anyChar (string "Selected Option:") <* string "Selected Option:" should do what you want
05:01:45 <pjdelport> rlp10, simukis_: I think you only need one string "Selected Option:" there, otherwise it will expect two of them.
05:04:18 <pjdelport> > B.pack <$> anyWord8 `manyTill` string "bar" `parseOnly` "foobar"
05:04:19 <pjdelport> Right "foo"
05:04:20 <lambdabot>  Not in scope: ‘B.pack’
05:04:20 <lambdabot>  Perhaps you meant one of these:
05:04:20 <lambdabot>    ‘BS.pack’ (imported from Data.ByteString),
05:04:20 <lambdabot>    ‘BSL.pack’ (imported from Data.ByteString.Lazy),
05:04:20 <lambdabot>    ‘BSC.pack’ (imported from Data.ByteString.Char8)Not in scope: ‘anyWord8’No...
05:29:39 * hackagebot regex-applicative 0.3.0.3 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.3.0.3 (RomanCheplyaka)
05:36:17 <tippenein> Is it a known issue that ghci doesn't see cabal sandboxed packages?
05:37:05 <danilo2> Hello! Is it a bug in GHC? (I want to ask you prior reporting it). The first instance compiles fine, while the second does not: http://lpaste.net/109197
05:37:22 <Maior> tippenein: why would you expect it to?
05:37:31 <Maior> tippenein: (you may be looking for `cabal repl`)
05:40:32 <Maior> does anyone have opinions on using DeriveGeneric as per http://hackage.haskell.org/package/yaml-0.8.0.1/docs/Data-Yaml.html#t:FromJSON example?
05:40:35 <Maior> +the
05:41:14 <tippenein> cabal repl returns after printing Preprocessing library ..
05:41:15 <Maior> I've no feel for any potential issues and their impact, etc.
05:45:30 <supki_> tippenein: cabal exec ghci  runs ghci in the correct environment
05:46:06 <Maior> oh that'd do it
05:46:17 <supki_> (assuming new enough cabal-install)
05:47:15 <Maior> I could have sworn `cabal repl` would just dtrt
05:47:22 <Maior> but I know little about it
05:47:48 <tippenein> Maior: I read that too, but for some reason it doesn't do anything
05:47:52 <tippenein> thanks supki_
06:07:17 <Darwin226> I'm attempting to install hdevtools for windows again after upgrading to the new haskell platform. This is the result: http://lpaste.net/109198 I'm guess it has something to do with the new ghc version packaged with HP2014. Is there any way to run the old one just for hdevtools?
06:07:27 <Darwin226> What can I do about this in general?
06:07:41 <supki_> danilo2: http://stackoverflow.com/questions/19758828/eta-reduce-is-not-always-held-in-haskell and linked questions may be useful
06:09:10 <danilo2> supki_: Oh, thats very interesting!
06:11:21 <danilo2> supki_: That has to be the case. Thank you for the clarification. For a moment I felt like crazy and not understanding completely whats going on. Anyway that is a strange bahaviour even if has some reasons behind.
06:13:32 <supki_> Darwin226: I think there's a pull request against hdevtools github repo that fixes issues with 7.8.3 support
06:13:59 <supki_> Darwin226: https://github.com/bitc/hdevtools/pull/33
06:14:02 <Darwin226> supki_: There is, but it's for the main branch. The windows support one is already a few commit behind
06:14:31 <Darwin226> supki_: and one of the issues with the new HP is the process package that isn't even a dependency of the main branch, just the windows one
06:19:19 <supki_> Darwin226: what's the windows support branch?
06:19:39 <supki_> I only see master and a bunch of wip* in the hdevtools repository
06:20:03 <supki_> I also don't understand why cabal picks process 1.1
06:20:32 <Darwin226> supki_ It's a fork
06:20:55 <Darwin226> supki_: https://github.com/mvoidex/hdevtools
06:26:49 <latk> I'm using flycheck-haskell in emacs, but I get the following : http://lpaste.net/109199 - any idea why this might be /
06:26:50 <latk> ?
06:27:37 <bergmark> latk: usually when a package name is in an error message it means there are multiple versions of the package
06:28:45 <supki_> Darwin226: aha. Well, you can try to relax version bounds on process and filepath in the cabal file and merge https://github.com/schell/hdevtools/commit/dd4c641405cf951da68eff740e10670d8c95d0d2 and https://github.com/schell/hdevtools/commit/4ff36c55ed64a774067697d9830a490bb9028263
06:29:18 <supki_> not sure if there's an easier way
06:29:51 <angerman> If I have something like this: "WnC+pcxFVwO2g3YgkzEAt2dSyvzqmoa+k0vboNUjl37mqs1Ke2EcfbTiZSvuVJrgR+2f/4skZfcxQftKm0UVTy1El34T6mNxZLIQoVJXxI44khwvp2BjKHsGv9wi3LIdlrd24AJbvxOb74LhD3HzZKjlLp6uoy84/xTlXwf2Pdk=" and want to turn it into an integer for a PublicKey, how do I go about that?
06:29:51 <latk> bergmark: Oh! I'll see if removing the sandbox helps.
06:31:32 <Darwin226> supki_: I've managed to get it compiling with process 1.2 but it doesn't work. No output. And I'm not really prepared to dig through the code
06:32:14 <bergmark> latk: if you can you should pass -no-user-package-db to it
06:34:15 <pjdelport> angerman: base-64 decode?
06:34:47 <angerman> pjdelport, yes i tried that, but that leaves me with a bytestring, and using Binary.decode on it doesn't work :(
06:39:42 <angerman> pjdelport: I seem to be missing something, somewhere.  I just fail to figure out where.
06:41:03 <quchen> You need to know how the data was encoded.
06:41:10 <quchen> There is no way to recover the data correctly otherwise.
06:41:36 <quchen> That string you posted could represent the digits of an integer, interspersed with random noise letters, after all.
06:42:18 <pjdelport> angerman: Ah, once you have a ByteString, and assuming it's a raw big-endian number you could say for example:
06:42:18 <pjdelport> integerFromString :: BS.ByteString -> Integer
06:42:18 <pjdelport> integerFromString = BS.foldl' (\a b -> 0x100*a + fromIntegral b) 0
06:42:19 <angerman> quchen, I'm trying to read in RSA XML :(
06:43:53 <d3m1g0d-> > Just 3 <*> Nothing
06:43:54 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
06:43:54 <lambdabot>    arising from the ambiguity check for ‘e_13’
06:43:54 <lambdabot>  from the context (GHC.Num.Num (a -> b))
06:43:54 <lambdabot>    bound by the inferred type for ‘e_13’:
06:43:54 <lambdabot>               GHC.Num.Num (a -> b) => Data.Maybe.Maybe b
06:44:14 <d3m1g0d-> > Just (+3) <*> Nothing
06:44:15 <lambdabot>  Nothing
06:44:22 <d3m1g0d-> > Nothing <*> Just 3
06:44:24 <lambdabot>  Nothing
06:44:36 <d3m1g0d-> why do they both equal to Nothing if the definition is
06:44:43 <d3m1g0d-> Nothing <*> _ = Nothing
06:44:57 <d3m1g0d-> why does this: "> Just (+3) <*> Nothing" equal to nothing ?
06:45:08 <pjdelport> d3m1g0d-: There's also a definition that _ <*> Nothing = Nothing
06:45:13 <Maior> d3m1g0d-: because that's not all of the definition
06:45:46 <d3m1g0d-> thats not what it says in LYAH: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
06:46:27 <pjdelport> d3m1g0d-: Or to put it a different way, the definition would be: Just f <*> Just x = Just (f x); _ <*> _ = Nothing
06:47:39 <skrivbord> How do you send and receive a message from an UDP server in haskell?
06:47:50 <pjdelport> d3m1g0d-: LYAH defers "(Just f) <*> something" to the Functor instance, with "fmap f something":
06:47:50 <pjdelport> Just f <*> Nothing  →  fmap f Nothing  →  Nothing
06:47:52 <Maior> d3m1g0d-: yes it does
06:47:59 <hyPiRion> d3m1g0d-: if you see, LYAH defines (Just f) <*> something = fmap f something
06:48:04 <Maior> d3m1g0d-: see the line below what you pasted: `(Just f) <*> something = fmap f something  `
06:48:30 <hyPiRion> > fmap (+3) Nothing
06:48:32 <d3m1g0d-> ok I understood. Thank you guys !
06:48:32 <lambdabot>  Nothing
06:49:53 <pjdelport> d3m1g0d-: LYAH's definition is probably not the best. Sometimes it makes sense to defer to Functor like that, but for Applicative Maybe, you don't want to hide the simple symmetry that Just f <*> Just x = Just (f x), and anything else is Nothing.
06:50:32 <mitchty> anyone ever static link binaries with ghc and musl libc perchance?
06:51:50 <rlp10> pjdelport, simukis: many thanks for your assistance
06:51:56 <latk> I feel like I must be doing something wrong, when I have to add 8 packages to "allow-newer" for cabal install to work :s
06:53:19 <quchen> latk: Does the testsuite pass (if included)?
06:53:38 <quchen> Even if not, some packages have lots of unnecessary or wrong upper version bounds.
06:56:26 <latk> quchen: I didn't realise you could run testsuites for installed packages - how do you do it ?
06:56:42 <quchen> latk: cabal configure --enable-tests && cabal test
06:56:55 <quchen> (Maybe throw a "cabal install --only-dependencies" in there)
06:57:05 <quchen> It only works when the package comes with a testsuite, of course.
07:01:55 <angerman> pjdelport: thanks. well rolling once own can be the easiest from time to time. I just never looked at doing that, and instead tried the libraries to make it work for me :-/
07:04:51 * hackagebot vk-aws-route53 0.1.2 - Amazon Route53 DNS service plugin for the aws package.  http://hackage.haskell.org/package/vk-aws-route53-0.1.2 (VladimirKirillov)
07:05:23 <pjdelport> angerman: This particular problem is probably right on the gray area where it's questionable whether it's worth putting in a library (because there are so many little variations)
07:32:12 <fortune500> ,
07:54:12 <sm> joeyh: the git-annex progress sounds great, congrats
07:58:27 <pchiusano> i am trying to find the original post where iteratees were introduced
07:58:47 <pchiusano> was it just a post by Oleg on haskell cafe somewhere?
07:58:53 <modeller> Trivial (Beginner) Question: Since haskell is expression oriented, is it ok to assume that there is no deterministic evaluation order? E.g. expressions like "let y = x + 42 in x = 42 + y " is allowed, correct?
08:00:08 <bergmark> pchiusano: that's not a valid expression
08:00:48 <modeller> Correction:  "x = y + 42 \n y = x + 42"
08:00:52 <tulcod> modeller: in general you have no control over the order in which pure expressions are computed
08:01:03 <danilo2> I've got short question regarding ScopedTypeVariables. Could anybody just quick look at these two small codes and tell me why the first one compiles, while the second seems not to use scopedtypevariables and complains about ambigouity? http://lpaste.net/109204
08:01:17 <tulcod> modeller: however, if you sequence some monadic computations, then that is fixed: if you first get some input string from the terminal, and then print it, then that's what it does
08:01:31 <shachaf> modeller: You can write that (one-line version: let { x = y + 42; y = x + 42 } in ...), but those probably won't evaluate to anything.
08:02:34 <modeller> tulcod: so that expression is syntactically legetimate (although it is non-sensical and evaluates to nothing)
08:02:36 <bergmark> danilo2: i'm guessing because in the second example the variables in the different signatures aren't connected so they are too polymorphic
08:02:45 <yano> nyuszika7h: oh baby
08:02:49 <nyuszika7h> yano: ಠ_ಠ
08:02:52 <tulcod> modeller: it can't be both non-sensical and syntactically legitimate
08:03:07 <modeller> shachaf: I see. thanks for the tip
08:03:09 <danilo2> bergmark: but hmm, I am using scoped type variables, so these variables are not ment to be the same as in the signature?
08:03:16 <shachaf> modeller: That's not an expression in the first place.
08:03:30 <modeller> tulcod: It passed compilation, so it is legitimate, no?
08:03:38 <shachaf> "let ... in ..." is an expression.
08:03:43 <tulcod> modeller: define "legitimate"
08:03:50 <tulcod> if it compiled, it compiled
08:03:51 <shachaf> Anyway, when someone's asking a simple question, why make it complicated by talking about "monadic computations"?
08:04:15 <bergmark> danilo2: you need an explicit forall
08:04:26 <tulcod> shachaf: because i felt that the difference should be made explicit
08:04:40 <modeller> tulcod: I meant passed compilation by "syntactically legitimate"
08:04:46 <danilo2> bergmark: ohh, really? I did not know that! thank you! Was it always like this? do you know any reasons behind this?
08:04:53 <shachaf> What difference?
08:04:56 <shachaf> Never mind.
08:05:07 <tulcod> shachaf: the fact that you don't have control on what the compiler does with your pure computations doesn't mean that the entire program runs out of order and does unexpected stuff
08:05:35 <shachaf> Not worth the argument.
08:05:55 <bergmark> danilo2: it is a bit weird, but it has always been like this afaik, don't know why exactly
08:06:00 <danilo2> bergmark: Look, in the example on the bottom (http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap) there is no explicit forall and ScopedTypeVariables are working like I wanrted to
08:06:39 <danilo2> bergmark: hmm, Thats strange. I bet I was using this sometimes without explicit forall. Maybe I will ask about it in #GHC?
08:08:03 <enthropy> you don't need an explicit forall for instances
08:08:07 <frerich> tulcod: If you are eager to make some "difference" explicit, you may appreciate http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_about_ordering.2Fsequencing
08:08:24 <danilo2> enthropy: ah! But why do we need for function signatures?
08:08:59 <enthropy> yes. In some sense that behavior is consistent, because class C a where f :: a -- the 'a' was always scoped
08:09:34 <danilo2> enthropy: in that sense yes, but why explicit forall makes the variables in scope too? For me this is a bit wired
08:09:49 <tulcod> modeller: maybe frerich's link is interesting for what you wanted to know
08:11:08 <enthropy> danilo2: you mean people write     instance forall x y. C x y?
08:11:10 <modeller> tulcod: thanks for all the discussion.
08:11:30 <enthropy> that's as bad as putting extra parentheses
08:11:42 <danilo2> enthropy: no, of course not. I mean, it should just work for functions like we write explicit forall in their signatures
08:12:15 <enthropy> it would be nice if it worked that way
08:12:50 <bergmark> danilo2: might be worth asking on haskell-café
08:13:12 <danilo2> enthropy, bergmark: I'll ask in few minutes! thanks :)
08:13:19 <enthropy> f :: t; f = let { t :: t; t = undefined } in t
08:13:21 <bergmark> it might be because it's less surprising
08:13:45 <bergmark> if you have a module without ScopedTypeVariables and then add it your program may not compile anymore
08:14:05 <enthropy> bergmark: it can already break/fix things with instances though
08:19:56 <bartavelle> I would like to efficiently model computations that might depend elements coming from a stream, and posted details here : http://stackoverflow.com/questions/25246665/how-to-model-computations-that-depend-on-specific-elements-from-a-stream
08:20:05 <bartavelle> depend on"
08:20:34 <bartavelle> if someone has already done something like that, I would be very interested
08:35:05 * hackagebot DAV 1.0.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.1 (ClintAdams)
08:48:06 <olivia1> in dijkstras algo with priority queue, why do the implementations im looking at add *all* nodes to the pq. dont you just have to add neighbors as you go along?
08:48:22 <olivia1> add all nodes to the pq at the beginning*
08:49:17 <olivia1> oh is that for finding all paths? i just want the shortest path from A to B and Nothing otherwise
08:50:06 * hackagebot IntervalMap 0.3.0.3 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.3.0.3 (ChristophBreitkopf)
08:50:22 <olivia1> i think i answered my own question, nevermind :)
08:50:25 <c_wraith> olivia1: there are no algorithms to find the shortest path between A and be without finding al shortest paths from A
08:50:57 <c_wraith> olivia1: the only optimization we know of is stopping when you reach B, instead of exploring the whole graph. :)
08:50:57 <JohnTalent> is there a simplier version of haskell? whenever i get up to monads i fail to grok the higher maths.
08:51:18 <c_wraith> err, between A and B
08:51:19 <olivia1> but if i just want A to B then theres no need to add EVERY node to the pq, as some/many may be unreachable from A
08:51:26 <Maior> JohnTalent: have you read http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html perchance?
08:52:11 <olivia1> im moving my game world from 2d to 3d and adding every node at the start will become prohibitively expensive
08:52:24 <c_wraith> olivia1: That's just how Dijkstra's algorithm works.  You go to whatever node is cheapest to reach from the nodes you've explored.  How do you know which unexplored node is cheapest to reach?  keep them all in a PQ
08:52:24 <glguy> JohnTalent: Can you give an example of some of the higher math you had trouble with to add some context about what was hard?
08:52:25 <olivia1> since im doing a simple grid based worlg
08:52:35 <c_wraith> olivia1: in that case, use A*
08:52:47 <olivia1> c_wraith: right, but cant i just add them as i go along?
08:52:53 <olivia1> rather than all at the beginning
08:53:07 <JohnTalent> glguy: monads and whatever else gets learned next.
08:53:26 <c_wraith> olivia1: it sounds like you have a ton of structure that you know about and djikstra's algorithm doesn't.  That means you should be using A*
08:53:41 <c_wraith> JohnTalent: believe it or not, "monads" is not a topic to learn when learning haskell.
08:53:42 <JohnTalent> Maior: no but i will looks. thanks.
08:53:59 <c_wraith> JohnTalent: learn about higher-kinded types instead.
08:54:16 <olivia1> c_wraith: right, but dijkstra is simpler for a prototype ;)
08:54:18 <glguy> olivia1: To answer your specific question, you add all the verticies ahead of time so that you only ever add at the beginning and then slowly remove nodes as you go
08:54:33 <glguy> olivia1: If you added them for every neighbor and then removed them as they were the minimum you might not terminate
08:54:51 <olivia1> glguy: even if all the edge weights are 1?
08:54:54 <glguy> or you'd have to use another mechanism to remember your visited set
08:55:04 <ajcoppa> JohnTalent: where are you in your haskell learning journey?
08:55:08 <olivia1> i do have a map where i remember the visited nodes
08:55:21 <ajcoppa> what resources have you used and how far have you gotten through them? asking to help get you on a path that will let you succeed
08:55:51 <JohnTalent> c_wraith: ok
08:55:54 <glguy> olivia1: If you're tracking the visited set separately that you won't need to add all the elements to the PQ at the start, but dijksta's algorithm isn't defined like that afaict
08:56:21 <olivia1> glguy: i think ill just go ahead and switch to A* sounds like
08:57:03 <glguy> I think that's an orthogonal questiong, but a good idea in your case
08:57:09 <olivia1> yeah
08:57:12 <c_wraith> JohnTalent: basically, "Monad" is an abstraction.  You're fine using the concrete stuff instead of worrying about the details of the abstraction, because it's honestly *not very important*.  Learn Haskell's type system instead.  It's really deeper and more complex than you think.
08:57:19 <JohnTalent> ajcoppa: not far. page 110 of a book now long gone. My concern with haskell is reading other people's code will be nonsuperfluous.
08:57:33 <olivia1> thanks for the help :)
08:58:19 <ajcoppa> JohnTalent: we have a pretty good set of standard resources we recommend for beginners. i suggest joining #haskell-beginners and reading through this guide: https://github.com/bitemyapp/learnhaskell
08:58:42 <ajcoppa> you may have some review at the beginning, but the first standard resource has you go through exercises that will make sure you really understood what you read before
08:59:28 <jollygood> what function(s) should I use to get all the files with *.txt extension in a directory tree?
08:59:57 <c_wraith> jollygood: I recommend the directory-tree package for anything involving that sort of problem
09:00:11 <jollygood> thanks I'll take a look
09:00:12 <JohnTalent> ajcoppa: ok thanks.
09:00:46 <JohnTalent> ajcoppa: how is corporate acceptance of haskell going. it's been years since I've looked at the hasell 'scene'.
09:11:09 <JohnTalent> have any of you used haskell->llvm->javascript?
09:11:23 <Maior> JohnTalent: no, but it's on the todo list
09:14:22 <Twey> Can I get the picoseconds from a NominalDiffTime?
09:14:56 <glguy> You can realToFrac it to another type, say a Double
09:15:27 <glguy> Or do you mean you want the actual Data.Fixed.Pico?
09:15:46 <Twey> No, realToFrac will do, thanks.  I guess I was being daft
09:16:06 <StephenS> New website looks fresh
09:16:50 <napping> readlToFrac has RULES for DiffTime <-> Pico too
09:17:29 <napping> which new website?
09:18:55 <StephenS> napping: http://new-www.haskell.org/ ?
09:19:24 <napping> ah, that one. I thought maybe it had gone live at www.haskell.org
09:25:17 <tulcod> StephenS: wait, that's actually gonna be haskell.org?
09:25:24 <tulcod> i tohught it was just gonna be haskell-lang.org
09:26:01 <StephenS> no
09:26:12 <adas> in attoparsec does parseTest only return a `Partial`?
09:26:20 <adas> if so, it doesn't say so in the doc
09:42:07 <gihan> Hello!  Newbie question here: how does one produce documentation from an .lhs file?  Specifically, I tried to run haddock on the first lecture available at http://www.seas.upenn.edu/~cis194/lectures.html and received an error message "The function 'main' is not defined in module 'Main'".  What am I doing wrong?  Thanks!
09:42:56 <bergmark> gihan: if you don't name your module ghc assumes it's "Main" and that you need a main declaration
09:44:20 <gihan> bergmark: Thanks --- so haddock is the right command, but I need to alter the .lhs file?
09:48:40 <bergmark> gihan: yes
09:49:37 <gihan> Thanks! bergmark++
09:52:27 <gihan> @activity
09:52:28 <lambdabot> 0*total
09:52:52 <gihan> @help
09:52:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:54:11 <gihan> @karma
09:54:11 <lambdabot> You have a karma of 0
09:57:08 <johnw> if I have a Hoopl graph, how does that get mapped to procedure offsets?
09:58:26 <StephenS> @help
09:58:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:58:28 <StephenS> @list
09:58:29 <lambdabot> What module?  Try @listmodules for some ideas.
09:58:32 <StephenS> @listmodules
09:58:32 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
09:58:39 <StephenS> @system
09:58:39 <lambdabot> Unknown command, try @list
09:58:44 <StephenS> @karma
09:58:44 <lambdabot> You have a karma of 0
09:58:51 <johnw> StephenS: you can /query lambdabot and have a private conversation
09:58:52 <StephenS> @search me
09:58:52 <lambdabot> Unknown command, try @list
09:58:58 <StephenS> I know
09:59:03 <StephenS> I like it this way more.
09:59:15 <johnw> but perhaps others do not
09:59:21 <StephenS> Who made that bot?
09:59:23 <StephenS> @source
09:59:23 <lambdabot> Unknown command, try @list
09:59:28 <johnw> @hackage lambdabot
09:59:28 <lambdabot> http://hackage.haskell.org/package/lambdabot
09:59:29 <napping> What are you trying to find?
10:00:48 <napping> johnw: what are you doing with hoopl?
10:01:09 <pjdelport> (StephenS: Unless you're trying to show something, it's better to /query lambdabot , to avoid polluting the channel.)
10:01:49 <johnw> napping: Using it to represent a procedure that I'm building a register allocator for
10:02:43 <napping> Are you asking how offsets are computed, or how to get them at all?
10:02:54 <johnw> how to get them at all
10:03:02 <johnw> I want to build a liveness map
10:03:13 <napping> I don't see anything that does it for you
10:03:19 <johnw> yeah, that's what I thought
10:03:22 <johnw> ok, thanks
10:03:23 <napping> hoopl sounds like an interesting approach
10:03:32 <napping> it would depend on the sizes of instructions, wouldn't it?
10:04:02 <johnw> I have the instruction table (i.e., the nodes in my graph), and yes, they all vary in size and the number of variables they can refer to
10:04:39 <napping> Hmm, could jumps even vary in side based on the distance they are jumping?
10:04:54 <johnw> in my case no
10:05:10 <johnw> I jump to a label, but the jump instruction and its offset is fixed in size
10:05:44 <napping> Could you work with offsets from labels and label each block?
10:06:08 <napping> Also, are you using hoopl to do the register allocation?
10:06:11 <johnw> I don't know enough yet to know; I'm modifying an existing assembler
10:06:28 <johnw> no, the register allocator is the thing I'm replacing; it's not Hoopl
10:07:13 <josephle> does hoopl not give a way to do generalized dataflow analysis?
10:10:27 <ajcoppa> JohnTalent: i'm not as qualified to answer the "corporate adoption of haskell" question, but maybe others are
10:10:34 <johnw> I'm not sure
10:11:10 <johnw> maybe postorder_dfs?
10:11:46 <Faucelme> quit
10:11:46 <napping> looks like your best bet, if you're done with hoopl passes and don't have another preference on block order
10:12:32 <napping> and I suppose you shouldn't compute the register map until you are done with any passes that might change instructions
10:15:19 * hackagebot cabal-bounds 0.8 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8 (DanielTrstenjak)
10:15:19 <johnw> yes, at this point I am done
10:15:40 <joeyh> hmm, I just managed to run into the transformers-compat -fthree mess, installing lens on Windows with the new platform
10:15:50 <joeyh> thought that was settled by now
10:16:15 <edwardk> you should be able to use the latest 0.3.3.x versions of transformers-compat with no flags
10:16:17 <edwardk> and just have it work
10:16:19 <edwardk> just depend on transformers-compat >= 0.3.3.1 IIRC
10:16:23 <edwardk> and it'll pick the right version
10:16:41 <joeyh> cabal seemed to want to upgrade network to a newer version than HP has. I have never found a way to compile network on windows
10:16:51 <joeyh> the -fthree hack seemed to work
10:17:11 <edwardk> joeyh: preventing it from upgrading network is something i have no idea how to do or why it wants to do so
10:17:36 <edwardk> guess you needed more constraints on the environment to keep it from trying to upgrade stuff
10:17:37 <johnw> you could add a --constraint on the command-line
10:19:41 <seeg> hello
10:24:00 <seeg> I use Data.Aeson.Lens and I have a problem with it: https://gist.github.com/CGenie/7884f53b2386d74c164b
10:25:22 <kini> Reading the docs for System.Exit, I see this statement: "Note: in GHC, exitWith should be called from the main program thread in order to exit the process. When called from another thread, exitWith will throw an ExitException as normal, but the exception will not cause the process itself to exit."
10:25:28 <kini> is there some way to kill my program from a thread other than the main thread?
10:26:00 <edwardk> seeg: interesting. i'd have expected a Text instance.
10:26:05 <edwardk> seeg: it appears to be missing http://hackage.haskell.org/package/lens-4.3.3/docs/Data-Aeson-Lens.html#t:AsValue
10:26:07 <glguy> kini: System.Exit module?
10:26:23 <edwardk> i think i'd be okay with adding it. glguy? can you see any issues with that?
10:27:45 <glguy> edwardk: You'd define it via   Text.encodeUtf8?
10:28:04 <edwardk> i guess so
10:28:07 <tv>  
10:28:12 <edwardk> sounds grossly inefficient
10:28:16 <shachaf> kini: I can think of hacky ways but probably you'd want to send a message to the main thread via some mechanism or another.
10:28:18 <edwardk> but it should be correct
10:28:29 <glguy> I guess. Aeson treats raw JSON as a binary format and doesn't offer any such direct route
10:28:45 <glguy> It might be surprising to people that it's slower
10:28:46 <napping> shachaf: I can't think of hacky ways, besides an FFI call to abort or such
10:28:55 <Maior> I fear I'm missing something very obvious - how do I trace an IO a ?
10:29:00 <shachaf> napping: That's the sort of hacky ways I was thinking of.
10:29:01 <edwardk> well, right now its surprising that they can't manipulate text as json
10:29:06 <c_wraith> glguy, edwardk: it won't be slower than the String instance
10:29:11 <kini> glguy: yes, that's what I was looking at, but it doesn't seem to do what I want
10:29:20 <kini> shachaf: hmm, I see... such as?
10:29:21 <napping> kini: That's the only library function I know for exiting
10:30:03 <pjdelport> Maior: traceIO ?
10:30:06 <shachaf> kini: Have the main thread block on an MVar or something?
10:32:03 <shachaf> edwardk: It's the same as the Aeson API, though, isn't it?
10:32:06 <kini> shachaf: well, I don't want the main thread to block, I just want it to be killed - basically I'm spawning another program, and I want to die if that program dies
10:32:06 <kini> so my first thought was "forkIO $ exitWith =<< waitForProcess handle", but since it's not in the main thread that doesn't actually kill me
10:32:42 <Maior> pjdelport: I am failing at using that + show + my IO a
10:32:44 <shachaf> I don't follow.
10:33:40 <TheKing444> hello, anyone need help haskell'in?
10:34:04 <TheKing444> > repeat repeat <*> pure 4
10:34:06 <lambdabot>  [[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
10:34:18 <TheKing444> >1 `par` 2
10:34:20 <pjdelport> Maior: How does your code look? If you have foo = ... :: IO a, you should be able to say something like foo = ... *> trace IO "foo"
10:34:30 <Maior> :t (*>)
10:34:31 <lambdabot> Applicative f => f a -> f b -> f b
10:34:43 <napping> might as well just say >> in IO
10:34:44 <pjdelport> err, foo = ... <* trace IO "foo" rather, of course
10:34:46 <Maior> @src (*>)
10:34:47 <lambdabot> (*>) = liftA2 (const id)
10:34:59 <kini> shachaf: my program is an interpreter, basically. I'm spawning an external program which acts as a UI for the interpreter. If the user exits the UI, I want to kill my interpreter at that point
10:35:01 <pjdelport> napping: Nah, you want to keep the original result (presumably)
10:35:02 <napping> oh, if you want to trace only after the code is finished then <* is useful
10:35:23 <TheKing444> kini, use finally
10:35:25 <edwardk> shachaf: we often round off some of the rough edges of an API we back with lens though
10:35:25 <napping> I'm used to putting debug output first, in case things get stuck inside
10:35:33 <kini> if the interpreter spawns the UI, and then just blocks until the UI exits, rather than responding to the user, there's not much point :P
10:35:38 <TheKing444> kini, a `finally` (killThread interpreter)
10:35:42 <TheKing444> or something like that
10:36:00 <napping> kini: If you just have the main thread and the externall process, then maybe linking with async is the easiest way to go
10:36:41 <TheKing444> race is what you usually use for running two threads until one of them exit
10:37:39 <shachaf> edwardk: I'm a bit suspicious about an implementation for Text that just encodes as UTF-8. But eh, only a bit.
10:38:22 <edwardk> seeg: i'd be okay with adding the instances for Text. now mind you the next major release of lens (which that would entail) is likely to split aeson support off into a separate package again.
10:38:28 <edwardk> seeg: so this may take some time
10:39:08 <edwardk> in the meantime you can encode the block of text you are overloading to utf8 by hand and then use the lenses into it. the issue is that aeson doesn't suport using JSON as Text.
10:39:20 <edwardk> and lens copies that limitation
10:40:44 <rrradical> I'd like to use the mapAccumLM function, but it's in MonadUtils, which is in the 'hidden' package ghc-7.8.3. Why is it hidden? It seems like a useful utility function to me. Should I just reimplement it?
10:41:08 <napping> How are you compiling?
10:41:13 <shachaf> rrradical: It's hidden because it's only meant to be used by GHC itself or things using the GHC API.
10:41:19 <merijn> rrradical: Hidden means that your cabal file isn't depending on the right package
10:41:24 <napping> Oh, from ghc
10:41:25 <merijn> Doesn't it?
10:41:29 <shachaf> You probably shouldn't be linking against the GHC API for non-GHC code.
10:41:34 <merijn> True
10:41:58 <rrradical> I guess my question is, why isn't it available in Base or something?
10:42:05 <rrradical> because it seems generally useful
10:42:14 <shachaf> Maybe it exists in some other library.
10:42:27 <rrradical> not that I could find on hoogle/google
10:42:59 <shachaf> Getting things into base requires careful consideration.
10:43:06 <napping> In general GHC has a lot of utitility stuff built up over the years. I think some of it's code even predates do-notation
10:43:07 <shachaf> http://hayoo.fh-wedel.de/?query=mapAccumLM finds a few other places that have it.
10:43:25 <shachaf> But it's probably simplest to reïmplement it yourself, really.
10:43:31 <rrradical> I suppose there's a better abstraction that people usually use instead?
10:43:58 <napping> or link against ghc for that matter, if you don't need to care about small/clean dependencies
10:44:40 <pjdelport> rrradical: What are you using it for?
10:44:51 <napping> you could get the same effect with a mapM in a state monad (maybe just adding StateT)
10:45:38 <napping> if you fold things under the newtypes, that signature is basically (x -> StateT acc m y) -> [x] -> StateT acc m [y]
10:46:51 <rrradical> oh hm, I just need foldLM afterall. there was a previous situation where I needed the individual results as well as the acc, but not this time
10:47:40 <rrradical> well...thanks =$
10:48:16 <napping> kini: Does a shutdown always start from the external process?
10:48:51 <seeg> edward, thanks :)
10:49:07 <napping> If it does, something like async (<startProcess> >>= <wait/exitWith) >>= link should work well enough
10:49:49 <napping> It's not too nice to throw the exit as an asynchronous exception in the main thread, but it ought to work
10:53:33 <kini> napping: not always from the external process, no...
10:54:00 <napping> ah, that makes it more confusing
10:54:00 <TheKing444> I tried installing the new haskell platform, but ghci does not work!
10:54:01 <TheKing444> $ ghci
10:54:02 <TheKing444> /usr/local/haskell/ghc-7.8.3-x86_64/bin/ghc-7.8.3: line 9: /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/ghc: cannot execute binary file: Exec format error
10:54:02 <TheKing444> /usr/local/haskell/ghc-7.8.3-x86_64/bin/ghc-7.8.3: line 9: /usr/local/haskell/ghc-7.8.3-x86_64/lib/ghc-7.8.3/bin/ghc: Success
10:54:39 <TheKing444> That sha256sum was correct as well.
10:54:44 <napping> well, exitWith just raises a particular exception, and if that makes it to the top of the main thread uncaught, things shut down
10:54:51 <TheKing444> :t exitWith
10:54:52 <lambdabot> Not in scope: ‘exitWith’
10:54:53 <kini> the main process, being an interpreter, does have a sort of "main loop", that is to say, there's a point where it will "surface" between successive evaluations, and ask for input from the user
10:54:53 <kini> I could have it check an ioref at that time, which could be set by another thread when the external process died
10:55:16 <kini> in that case, the interpreter wouldn't exit until it was next idle, which might be some time later, but I guess that's not too terrible
10:55:29 <sclv> @tell byorgy ping me when yr around?
10:55:29 <lambdabot> Consider it noted.
10:55:33 <glguy> seeg: there you go https://github.com/ekmett/lens/commit/2bb06c634f73110ff84ce0113be9ad4ac66bcb6d#diff-d41d8cd98f00b204e9800998ecf8427e
10:55:46 <napping> it's not too complicated, just that the simple linking thing will make the main thread die as soon as the process dies
10:56:02 <napping> which might be a bit strange if the process is only dying because the interpreter is trying to shutdown
10:56:43 <kini> oh, if the interpreter shuts down, the external process won't find out for a while - they only communicate over zeromq sockets, nothing else (this is an ipython kernel and frontend, btw)
10:57:09 <kini> and even if the external process does find out that the interpreter has died, it will not itself die without user input
10:57:17 <napping> oh, okay
10:57:26 <TheKing444> kini, you just need to proper use of `finally` and `killThread`
10:57:56 <ezrios> TheKing444: `uname -a`
10:57:58 <napping> I'm not sure how finally gets along with asynchronous exceptions
10:58:34 <TheKing444> erizos, I am on Ubuntu 14.04.
10:59:02 <ezrios> TheKing444: `uname -a`
10:59:17 <TheKing444> Linux ChrisLaptopUbuntu1304 3.13.0-32-generic #57-Ubuntu SMP Tue Jul 15 03:51:12 UTC 2014 i686 i686 i686 GNU/Linux
10:59:18 <kini> oh, I guess I could just do "mainThread <- myThreadId; forkIO $ waitForProcess handle >> killThread mainThread"
10:59:21 <napping> ah, finaly does mask exceptions for the duration of the handler
10:59:25 <kini> what do I need finally for?
10:59:44 <ezrios> TheKing444: i686 and you are downloading haskell platform for x86_64
10:59:46 <ezrios> ?
10:59:51 <ezrios> why
11:00:00 <napping> well, if you were running the process in another thread with link as I suggested, the exit message would be sent as an asynchronous exception to the main thread
11:00:03 <TheKing444> kini: finally make sure that if there is an error, that it still kills the main thread
11:00:24 <napping> so you'd need "finally" or something if you had any shutdown actions like maybe writing/flushihng a history file that you wanted to be sure happened
11:00:29 <TheKing444> ezrios, I just downloaded from the linux page
11:00:39 <TheKing444> where should I be downloading from?
11:00:59 <kini> napping: I'm just running the process using "createProcess" from System.Process
11:01:00 <napping> actually, it's a similar story if you organize things that way, and the mainThread wants to do any cleanup while it's being killed
11:01:07 <ezrios> TheKing444: probably through your distro's package manager
11:01:11 <kini> afaik that shouldn't create any haskell threads, no?
11:01:15 <napping> nope
11:01:17 <ezrios> I have no experience with Haskell on Ubuntu
11:01:22 <ezrios> in my experience it's a complete nightmare
11:01:23 <TheKing444> ezrios, but they have updated yet
11:01:25 <TheKing444> to 2014
11:01:29 <ezrios> s/no experience/little experience
11:01:32 <TheKing444> *haven't
11:01:44 <napping> but I think you mentioned at one point you were creating the process in another thread and having that wait for the process to exit, while the main thread went on to become the interpreter
11:01:44 <ezrios> TheKing444: then update your local mirror of the package tree
11:01:46 <TheKing444> where is a i686 version or whatever?
11:01:50 <ezrios> or wait for a package to become available
11:01:50 <kini> this is useful for haskell on ubuntu: https://launchpad.net/~hvr/+archive/ubuntu/ghc
11:01:53 <ezrios> alternatively, build from source
11:02:04 <TheKing444> ugh, I will try that maybe
11:02:23 <kini> napping: ah, no - I create the process in the main thread. The other thread was just a thread created to sit there and block, waiting for the process (given its ProcessHandle from the main thread)
11:02:40 <kini> TheKing444: or use nix :)
11:02:40 <ezrios> hm
11:02:43 <ezrios> I also need to update ghc ._.
11:02:43 <napping> well, it doesn't matter where you create the process, just where you block checking if it exits
11:02:50 <kini> right
11:02:55 <TheKing444> Yeah, or that
11:03:01 <napping> if you don't mind polling, you could just set/check an MVar or something
11:03:17 <Cale> For a long time now, I haven't relied at all on my linux distro's Haskell-related packages. I just install the GHC generic linux binary, and then grab the tarball for cabal-install from hackage and run the bootstrap.sh script from that.
11:03:19 <TheKing444> kini: forkFinally is also a good idea
11:03:32 <napping> I recommended async because it handles a lot of details about when exceptions can be received or thrown
11:03:54 <napping> simon explains it all in his really nice book: http://chimera.labs.oreilly.com/books/1230000000929
11:04:02 <napping> but you wouldn't want to build your own
11:04:11 <kini> I will read about async, thanks for the pointer :)
11:04:48 <napping> the book covers a lot of other good stuff too :)
11:05:47 <kini> I've heard good things. We have a copy here at the office if I'm not mistaken...
11:06:04 <napping> It's also free to read online, because Simon is nice
11:06:11 <kini> great!
11:06:20 <napping> Not that that stopped me from ordering a copy
11:08:06 <linman32> hi. cannot install glib-0.13.0.0 in sandbox
11:08:06 <linman32> http://pastebin.com/z2vhHkNt
11:08:18 <linman32> anyone know what is wrong?
11:08:53 <napping> huh, why "sudo"?
11:09:08 <linman32> i wasn't using it before, but thought it might help
11:09:10 <linman32> it didn't
11:09:17 <Cale> linman32: Which version of the Cabal library are you using?
11:09:22 <napping> It shouldn't help with a sandbox
11:09:28 <kini> check your Cabal version
11:09:32 <Cale> linman32: Perhaps the version which installed into the sandbox is too old?
11:09:33 <linman32> 1.20.0.1
11:09:33 <napping> If anything it might hurt by making some things owned by root
11:09:56 <Cale> well hmm, that's not very old, let me have a look
11:10:00 <linman32> napping: ok, note taken
11:10:22 <Cale> uh, hmm
11:10:25 <kini> cabal 1.20.0.1 definitely has configCompilerEx
11:10:33 <napping> nor is glib-
11:10:38 <napping> 0.13.0.0
11:10:38 <Cale> yeah, it does
11:10:48 <linman32> cabal-install version 1.20.0.3
11:10:55 <linman32> 1.20.0.1 of the Cabal library
11:11:06 <Cale> Yeah, that ought to be fine
11:11:09 <Cale> weird
11:11:22 <napping> what about your cabal-install? try `cabal --version`
11:11:38 <napping> I don't know where the version of cabal used for the setup script is taken from
11:11:45 <Cale> Maybe try the command with -v
11:11:48 <linman32> cabal-install is 1.20.0.3
11:12:02 <napping> and what version of the library does it say?
11:12:26 <linman32> library is 1.20.0.1
11:12:29 <napping> huh
11:12:32 <napping> maybe ghc-pkg?
11:13:01 <linman32> GHC package manager version 7.6.3
11:13:36 <Cale> It must be either using a broken or old version of the library instead of that one, because that version's Distribution.Simple.Configure *does* export configCompilerEx
11:13:45 <napping> Sorry, I meant running something like ghc-pkg list outside the sandbox and checking what versions of cabal package it knows about
11:13:57 <Cale> So, maybe run the command with -v2 and see which version it's actually trying to use
11:13:58 <napping> sorry, "Cabal"
11:14:17 <seeg> glguy, thanks :)
11:14:19 <eacameron> why doesn't `foo = "Str" :: String` satisfy the top-level type sigs warning?
11:14:28 <Cale> and yeah, make sure that ghc-pkg list only reports one version of the Cabal package, and that it's the one you expect
11:14:33 <napping> If you installed ghc into your home directory, running under sudo might have given it trouble finding the global package database
11:14:42 <napping> Cale: hmm, I've got two, one from the global database and one from the user database
11:14:53 <Cale> eacameron: Because that's not a top-level type signature
11:14:55 <triliyn> eacameron: that is still an expression-level type signature
11:15:05 <napping> Cale: and things seem to work for me
11:15:16 <Cale> napping: Well, I suppose that's okay
11:15:40 <eacameron> Cale: triliyn: so "foo" itself is still polymorphic somehow?
11:15:44 <linman32> ran outside the sandbox and cabal versions look the same
11:15:51 <Cale> eacameron: No, its inferred type will be String
11:15:54 <kini> napping: thanks, the "link" solution seems to work very well :)
11:16:04 <Cale> eacameron: It's just that this is not structurally a top level type signature
11:16:04 <triliyn> eacameron: that should be monomorphic, it's just that the type signature is not at the top level
11:16:05 <napping> cool
11:16:19 <kini> now I just need to figure out why the heck ghc-mod thinks that Control.Concurrent.Async doesn't exist, despite my program compiling just fine...
11:16:19 <triliyn> I'm not sure if this has any relevant consequences, but that's why it's triggering the warning
11:16:23 <Cale> eacameron: which would look like  foo :: String; foo = "Str"
11:16:24 <napping> kini: that's just throwing an exception in the main thread whenever the other thread notices the process died, so I wasn't sure it would be entirely reliable
11:16:25 <triliyn> Sounds like a style warning to me
11:16:42 <Cale> eacameron: You don't have to worry about that warning too much.
11:16:45 <kini> napping: what failure cases do you envision?
11:17:10 <napping> just that you might not run all the cleanup code on the way out that you might expect, unless you protect it with finally or something
11:17:15 <enthropy> triliyn: the monomorphism restriction still kicks in for   myId = id :: a -> a
11:17:19 <Cale> eacameron: -Wall turns on lots of warnings which are of various levels of importance, and some of which I think should usually be ignored.
11:17:37 <linman32> napping: ghc-pkg and cabal are running the same versions in and outside of sandbox
11:17:41 <napping> also that control flow might get a bit confusing if your haskell program starts the shutdown, then takes long enough finishing up that the external process dies, and the link throws an exception from that
11:18:06 <napping> linman32: that's pretty odd. Can you try a fresh sandbox? Do you have enough packages that's annoying?
11:18:06 <Cale> (especially "you didn't use the result of this action in a do-block"
11:18:07 <eacameron> Cale: it's annoy with constants and things
11:18:08 <Cale> )
11:18:45 <linman32> napping: i can try fresh sandbox
11:18:46 <kini> napping: well, concurrency is always fraught with these weird corner cases... it's no worse a solution than what I was trying to do before ("exitWith =<< wait" in a separate thread) :)
11:18:52 <pjdelport> eacameron: Also note that even explicit top-level signatures are entirely free to be polymorphic: giving signatures is not about making them monomorphic.
11:19:08 <pjdelport> It's just a style / clarity thing.
11:19:09 <Cale> eacameron: Yeah, it's safe to just not worry about it. This is why we have type inference, so you don't have to write the type signatures for things where it's obvious.
11:19:19 <eacameron> pjdelport: good point; I guess I meant it was not what I expected
11:19:26 <napping> kini: Right, I forgot you were happy just closing the whole process anyway
11:19:31 <kini> :)
11:19:40 <pjdelport> (There's the dreaded monomorphism restriction too, but that's another separate kettle of fish.)
11:19:59 <johnw> and always one specific kind of fish, unless you define the kettle at global scope
11:20:10 <kini> the monomorphism restriction made me gunshy of type inference, lol
11:27:47 <linman32> napping: on line 34 it says failed to install cairo. also failed to install glib
11:27:51 <linman32> napping: pastebin.com/TErA8rmL
11:28:56 <linman32> napping: this is after trying to create a new sandbox
11:29:18 <napping> that sounds a lot better
11:29:37 <napping> well, the withCStringLen thing is funny
11:29:42 <napping> did you install gtk2hs-buildtools
11:29:42 <linman32> napping: b/c no sudo? : )
11:29:52 <napping> Nah, because that sounds like errors I've seen myself
11:30:12 <napping> not the precise message you get, but cairo etc. failing, often because I didn't have the C libraries installed
11:30:17 <Maior> am I doing anything obviously-terrible in https://github.com/doismellburning/parcel/blob/sadpanda/src/Main.hs perchance?
11:30:30 <napping> just cabal install gtk2hs-buildtools anywhere or in a sandbox or something
11:30:55 <napping> It installs some tool programs necessary for a gtk2hs build to go through, if you didn't install it already
11:31:47 <linman32> yes, the gtk2hs-buildtools were installed in the sandbox succesfully
11:32:35 <linman32> but same error when trying to do gtk install
11:33:55 <napping> I have to go now
11:34:09 <linman32> napping: wait, what would your recomend next?
11:34:26 <napping> I don't know, that looks like a function that should be provided from text
11:34:40 <linman32> napping: thanks
11:34:45 <napping> maybe similar checks with -v and such that you are getting a reasonable version of text?
11:35:28 <linman32> how is this done?
11:40:16 <lukaswilkeer> Hi
11:44:49 <bmuk> Hey everyone, what are some open source projects that need contributors? I would like to find something that isn't feature complete yet
11:45:52 <lukaswilkeer> :/window next
11:46:07 <pjdelport> bmuk: Any subject or area in particular you're interested in?
11:46:42 <solidus-river> huzzah: yesterday i wrote 19 utility functions for handling different types of wire collections in netwire! how do you submit / suggest changes to a project on darcs
11:46:50 * solidus-river has only lived in git land
11:46:59 <bmuk> pjdelport: I am interested in most areas of computer science, but AI, security, and filesystems are probably my favorites
11:47:04 <pjdelport> bmuk: or particular skills that you have?
11:47:15 <linman32> napping: i think it is working. after updating text package in sandbox.
11:47:25 <linman32> napping: g2g. thanks
11:47:41 <pjdelport> Ah, okay. Well, you could start by browsing through http://hackage.haskell.org/packages/ and seeing if there's something that catches your eye.
11:48:55 <solidus-river> bmuk: filesystems interest you? the world needs more of you! Go forth and make filesystems betterer!!!
11:49:07 <solidus-river> :P
11:49:19 <bmuk> solidus-river: haha I will try. I do have a few ideas
11:49:29 <orion> bmuk: Check out ZFS.
11:49:31 <bmuk> Definitely implementing one in haskell is on my list
11:49:40 <lukaswilkeer> When I use `cabal install yesod` i get `cabal: Codec.Compression.Zlib: premature end of compressed stream`. What's up?
11:49:41 <popl> er?
11:49:51 <bmuk> orion: I have used ZFS and btrfs, haven't looked at much of the code though
11:52:53 <glguy> lukaswilkeer: The metadata that cabal update downloads might be truncated, You could try "cabal update" again
11:53:53 <Fuuzetsu> did Hackage just die again
11:54:01 <Fuuzetsu> oh nvm I got on
11:55:06 <lukaswilkeer> glguy: Thanks! I'm trying now.
11:58:52 <lukaswilkeer> It's normal cabal install and cabal update take a long time?
11:59:35 <koala_man> how long is long?
11:59:36 --- mode: ChanServ set +o glguy
11:59:38 <napping> It's not unusualy for cabal install to spend a lot of time compiling stuff
11:59:50 --- mode: glguy set -o+b glguy *!*@64.56.124.97$#haskell-ops
11:59:51 <napping> cabal update is mostly just downloading things, it shouldn't take long on a reasonably fast connection
12:00:11 <ezrios> huh
12:00:32 * hackagebot monad-journal 0.2.3.0 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.3.0 (DimitriSabadie)
12:00:34 * hackagebot zip-archive 0.2.3.3 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.3 (JohnMacFarlane)
12:00:51 --- mode: ChanServ set +o glguy
12:01:37 <Ankhers> I was having an issue earlier with cabal update taking a long time (it was actually just hanging and not doing anything. I had to `rm ~/Library/Haskell/repo-cache/hackage.haskell.org/00-index.tar.gz.etag` to fix it. Once I removed that file, it did its thing normally.
12:02:00 --- mode: glguy set -o glguy
12:02:01 <Ankhers> I don't know what caused it to do that though.
12:02:11 <bergmark> it feels like cabal update has gotten slower again
12:02:22 <bergmark> it got a lot faster with hackage2
12:02:30 <lukaswilkeer> Ankhers: I will try this..
12:02:44 <kini> dumb question: if "Maybe (forall a. P a)" is an impredicative type, why is "(forall a. P a) -> B" merely a rank-n, and not an impredicative, type?
12:03:00 <Ankhers> lukaswilkeer: You can also do `cabal update -v3` to see what it is doing to take so long.
12:03:12 <lukaswilkeer> `cabal install snap` took about 30 minutes.
12:03:21 <carter> kini: impredicative means you can substitute in a polymorphic type
12:03:34 <napping> kini: and I guess arrows are special
12:03:35 <pertl> I am trying to get the whole picture how IO is handled in haskell. I *think* I understood enough of monads so far to be able to understand it. what I wonder: how is the actual IO interaction (= side effect) in haskell working? e.g. the function "putStrLn" ... is there a "native" implementation of "putStrLn" that behaves like a monad and calls the operating system functionality to output characters on stdout during processing of ">>=" ? or 
12:03:36 <pertl> it completely different?
12:03:42 <kini> carter: right, so can't you substitute in a polymorphic type in (forall a. P a) -> B ?
12:03:52 <carter> idk
12:03:57 <Ankhers> lukaswilkeer: It does need to download / install all of its dependencies, which can take time depending on your connection speed and processing power to actually compile.
12:04:05 <carter> kini: if a is free in B
12:04:23 <carter> aint it true that you just have a polymrophic value
12:04:29 <napping> kini: more to the point, functions don't have constructors so maybe it's easier to do special things for them
12:04:35 <n-dolio> kini: It is impredicative. It's just that GHC doesn't care about certain types of impredicativity.
12:04:36 <carter> so you can't change it to being P (\forall b . P b)
12:04:44 <carter> or whatever
12:04:53 <carter> i'll let the experts take over
12:04:58 <kini> hmm
12:05:06 <bergmark> lukaswilkeer: snap has a lot of dependencies, lens notably!
12:05:21 <kini> n-dolio: I see, that seems like a reasonable explanation :)
12:06:03 <Ankhers> the latest version of cabal seems to allow concurrent building though, which speeds up the process quite a bit.
12:06:10 <n-dolio> Some impredicative things make inference more difficult, or at least GHC's algorithm wasn't designed to handle them.
12:06:27 <n-dolio> So GHC only tries to handle them if the extra extension is on.
12:06:28 <napping> ocharles: your generics-sop examples don't quite work as written
12:07:03 <kini> I guess I just assumed that since the extension was called ImpredicativeTypes, types you could have without the extension were not impredicative
12:07:36 <n-dolio> Yeah, it's not the best name.
12:08:03 <modeller> I often heard Monad a lot but I am still way until reading that chapter. Is it OK to think that: the major usage of Monad is to define evaluation order for expressions, though this is not the sole usage of Monad?
12:08:04 <modeller> Just checking my understanding so that I can (safely) defer all expression-evaluation-order related doubts to Monad readings.
12:08:07 <carter> LANGUAGE ReallyExtremelyImpredicativeTypes
12:08:26 <n-dolio> Strictly speaking, you could have types like (forall a. P a) -> B without it being impredicative, but the type system GHC uses just looks impredicative.
12:08:44 <carter> modeller: i like to think of monads as algebraic cooties for threading information around
12:08:53 <carter> so thats a good intuition
12:08:55 <carter> eg
12:08:58 <napping> modeller: sounds reasonable enough for now - evaluation order isn't the only major reason, but monads are pretty much the main way you enforce order
12:09:04 <modeller> what is cooties, let me look it up
12:09:11 <carter> @google cooties
12:09:12 <lambdabot> http://en.wikipedia.org/wiki/Cooties
12:09:12 <lambdabot> Title: Cooties - Wikipedia, the free encyclopedia
12:09:43 <carter> :t (>>=)
12:09:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:09:52 <modeller> i see
12:10:06 <carter> given a monadic value, i can only look inside it if i promise to put the result of looking inside back in the monad
12:10:25 <carter> "eval something, then using the resulting value to compute a new evalable thing"
12:10:58 <carter> which kinda relates to your data ordering idea
12:11:06 <napping> carter: I think the question was whether it's reasonable to defer reading about monads for a bit
12:11:12 <carter> yeah
12:11:13 <modeller> cater: thanks for the explanation, though it looks cryptic for me for now :)
12:11:17 <carter> don't worry about what monads are
12:11:18 <carter> just use them
12:11:23 <carter> and you'll get a better sense
12:11:34 <modeller> Let me note that down and understand it along the way
12:11:47 <lukaswilkeer> begmark: Cabal took a long time when compile lens on snap install.
12:11:49 <carter> the stephen diehl tutorial does it well
12:12:10 <modeller> napping: yes I meant that
12:13:33 <napping> ocharles: in particular, gtoRow uses a "p" it doesn't define, and misses a SingI constraint, this compiles for me: http://lpaste.net/109207
12:15:28 <modeller> @quit
12:15:28 <lambdabot> Not enough privileges
12:15:33 * hackagebot zip-archive 0.2.3.4 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.4 (JohnMacFarlane)
12:16:12 <ocharles> napping: yea, I was really sloppy with that. I'll fix it up later tonight, thanks for the prod!
12:20:33 * hackagebot JuicyPixels 3.1.6.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.6.1 (VincentBerthoux)
12:22:56 <pjdelport> bmuk: Are you interested in type theory and programming language developments too?
12:23:38 <latk> I'm getting a message about "cabal: The following packages are likely to be broken by the reinstalls: ghc-7.8.3". What does this mean? This is from installing --dependencies-only in a fresh sandbox.
12:24:08 <pjdelport> bmuk: One project that's actively looking for volunteers to help with "easy" tasks is Idris, which is a Haskell-like language with dependent typing.
12:24:30 <pjdelport> bmuk: Its type system may be of particular interest to with regards to things like security.
12:24:40 <pjdelport> "to you", even
12:25:09 <bmuk> pjdelport: Yes I am, Idris sounds cool
12:25:19 <bergmark> latk: hmm, sandboxes sometimes reuse installed dependencies, so it might be because of that somehow
12:25:36 <pjdelport> bmuk: There's #idris, and a small community around it.
12:25:58 <pjdelport> bmuk: I'm sure if you ask, someone can help orient you and give you some starter tasks to tackle. :)
12:26:02 <bergmark> latk: you can probably fix it by adding the packages it wants to reinstall explicitly, so `cabal install mypkg something somethingelse'
12:26:27 <dfeuer> > length $ inits [1..100000]
12:26:30 <lambdabot>  mueval-core: Time limit exceeded
12:26:32 <bmuk> I'll definitely ask around
12:26:35 <dfeuer> Still broken.
12:26:50 <pjdelport> bmuk: Oh, and it's implemented in Haskell.
12:26:57 * dfeuer offers fish pie to all present.
12:27:15 <latk> bergmark: Huh. Okay.
12:28:29 <tulcod> pjdelport: is idris gonna be somehow merged back into haskell? is haskell gonna get dependent types?
12:29:26 <bjorkintosh> tulcod, independent projects.
12:32:16 <hiptobecubic> tulcod, hopefully not
12:36:58 <carter> tulcod: BUT ghc IS gonna get dependent types
12:37:05 <carter> theres folks working onthat for their phds
12:37:13 <tulcod> nice
12:37:21 <carter> {-# LANGUAGE DependentTypes #-} will be a thing
12:37:36 <tulcod> carter: wait, doesn't that mean idris is basically pointless from that point?
12:37:39 <carter> nop
12:37:41 <carter> different
12:37:47 <tulcod> cause from what i know about idris, it's like haskell, but with dependent types
12:37:50 <carter> theres many different approaches to using dpeendent types
12:37:55 <carter> tulcod: you need to elarn mroe
12:37:55 <tulcod> okay
12:37:56 <carter> :)
12:38:02 <tulcod> okay
12:38:16 <carter> like, in haskell we don't need the type theory to be sound
12:38:26 <carter> because we can already write undefined :: a
12:38:28 <carter> for any a
12:38:31 <carter> to fake proofs
12:38:33 <tulcod> haha, right
12:38:33 <shlevy> Will haskell be total with dependent types enabled?
12:38:34 <shlevy> Ah
12:38:35 <shlevy> OK :D
12:38:48 <carter> shlevy: if you help add a totality checker and associated pragma, sure
12:39:04 <shlevy> mm
12:39:14 <carter> would be cool to have a {-# Total  fooo #-}
12:39:17 <carter> pragma
12:39:29 <carter> probably by default you'd only get a warning
12:39:41 <carter> would be the right balance
12:40:20 <carter> shlevy: but yeah, a first step would be improving the coverage checker for GADTs and stuff
12:40:27 <carter> no one wants to fix that for some reason
12:40:39 <carter> and anyone who wants totallity checking an doesn't do that, is lame
12:40:41 <carter> :)
12:49:27 <sinelaw> any easy way to convert yacc .y files to happy bnf format?
12:50:50 <pjdelport> tulcod: Only saw that message now, but yeah, "dependent types" is a very big design space: there's no sense talking about a language getting it as if it's a single checkbox to tick.
12:51:04 <tulcod> right
12:51:14 <carter> yeah
12:51:21 <carter> its like "which style of proof / formalization"
12:51:22 <pjdelport> Haskell / GHC is getting (and already has) several dependent typing features, but nothing comparable to the extent of Idris.
12:51:24 <carter> how its supported
12:51:44 <carter> pjdelport: ehhh, its getting the full hog once Richard does his phd defense
12:51:55 <carter> allegedly thats when his branch will go into head :)
12:52:46 <shlevy> carter: Any pointers to the design of Richard's work? Who si Richard? :D
12:55:21 <alcabrera> shlevy: I know only a little of Richard (Eisenberg), but you can check out some of the research here: http://www.cis.upenn.edu/~eir/ :)
12:55:22 <tulcod> i don't know who you are, richard, but you better hurry with your phd.
12:56:08 <corgifex> don't let it get to your head
12:58:00 <carter> let him do science at his own pace
12:58:15 <carter> but ifyou care about nice things, someone pleese improve pattern coverage checking for GADTs
12:58:22 <carter> if you don't care about that, you don't care about fancy types
12:58:28 <carter> :)
12:59:11 <n-dolio> I wouldn't expect this all to happen very soon.
12:59:49 <carter> that too
13:04:45 <orion> Are list comprehensions strict?
13:05:46 <corgifex> no
13:09:44 <nick_named> carter: I am kind of starting to work on that.
13:12:03 <Gaelan> @pl (value - vMin) * (dMax - dMin) / (vMax - vMin) + dMin
13:12:03 <lambdabot> (value - vMin) * (dMax - dMin) / (vMax - vMin) + dMin
13:12:15 <Gaelan> @pl scale value vMin vMax dMin dMax =   (value - vMin) * (dMax - dMin) / (vMax - vMin) + dMin
13:12:16 <lambdabot> scale = flip flip id . ((flip . (liftM2 (flip . ((+) .)) .)) .) . (`ap` subtract) . (((.) . flip . ((flip . ((/) .)) .)) .) . flip flip subtract . (((.) . (.) . (*)) .) . (-)
13:12:25 <Gaelan> No.
13:12:25 <clrnd> noice
13:12:31 <Gaelan> Just no.
13:13:09 <eacameron> anyone have experience using mysql or mysql-simple in multithreaded contexts?
13:35:41 * hackagebot one-liner 0.3 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.3 (SjoerdVisscher)
13:39:54 <jonsterling> Fuuzetsu: Do you still need help with that [String] thing?
13:45:42 * hackagebot purescript 0.5.4.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.4.1 (PhilFreeman)
14:01:22 <slyrus> haskell newbie here with a stupid music-suite question... is this the right place to ask?
14:03:30 <benzrf> slyrus: probably
14:04:51 <slyrus> I'm trying to get lilypond to output tablature and can do so if use music2ly and hand-edit Staff -> TabStaff in the .ly file. Is there way to specify this as an option to music2pdf?
14:04:52 <Fuuzetsu> jonsterling: let me see if I got a reply on café but I suspect I didn't
14:06:06 <Fuuzetsu> jonsterling: oh, I did, I might be good then
14:13:13 <eacameron> I need to run forEach for each row of a mysql query and pipe that row through a conduit. forEach takes a (r -> IO ()) action for each row, but conduit's yield is not an IO action! Is there any way to convert a conduit yield to an IO action?
14:21:07 <c_wraith> eacameron: Not directly.  You could hack it with an MVar or something..
14:21:39 <latk> If I use cabal freeze in a package that I've also used --allow-newer in, what will the frozen packages be ?
14:21:54 <c_wraith> latk: it will freeze with whatever is installed
14:22:15 <latk> c_wraith: Ah, okay.
14:22:41 <c_wraith> eacameron: you could write a conduit that reads values from an MVar, and yeilds them.  And then you could hand forEach an action that writes to that MVar
14:22:52 <c_wraith> *yields.  I'm bad at spleling
14:24:11 <c_wraith> eacameron: you'd need to have the forEach running in a separate thread, I suppose.
14:25:36 <eacameron> c_wraith: ok, yeah I thought of that. we're using TMQueues right now and were hoping to use conduit to clean it up
14:26:23 <c_wraith> eacameron: alternatively, you could rewrite the database binding to be conduit-oriented
14:26:41 <eacameron> c_wraith: hahaha. Yeah I thought of that too...for about 2 seconds
14:26:57 <c_wraith> It's usually not that much work.
14:27:03 <eacameron> c_wraith: really?
14:27:08 <eacameron> huh...
14:27:19 <eacameron> I might give a stab in some free time then...
14:27:41 <eacameron> basically all I need is for forEach to have a polymorphic monad type right?
14:27:45 <eacameron> r -> m ()
14:27:46 <eacameron> ?
14:28:44 <eacameron> I'm using mysql-simple
14:28:58 <dspies> In accelerate, do I need to worry about contended accesses?  Is there a limit to how many threads can read the same element at the same time?
14:30:45 * hackagebot HGamer3D-Audio 0.4.0 - Audio Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Audio-0.4.0 (PeterAlthainz)
14:30:47 * hackagebot HGamer3D-CEGUI-Binding 0.4.0 - A Game Engine for the Haskell Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.4.0 (PeterAlthainz)
14:30:49 * hackagebot HGamer3D-Enet-Binding 0.4.0 - Enet Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.4.0 (PeterAlthainz)
14:30:51 * hackagebot HGamer3D-Ogre-Binding 0.4.0 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.4.0 (PeterAlthainz)
14:30:53 * hackagebot HGamer3D-SDL2-Binding 0.4.0 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.4.0 (PeterAlthainz)
14:31:43 <c_wraith> eacameron: What I'd do, honestly, is copy the implementation of forEach, but move it into an appropriate Conduite type, and replacing calling a function parameter with calling yield.
14:31:49 <c_wraith> *Conduit
14:32:10 <c_wraith> eacameron: I'm willing to bet that's just a matter of using some calls to liftIO
14:33:08 <eacameron> c_wraith: excellent idea. I'll give that a whirl! man, we need different versions of hackage, one from the perspective of each streaming lib
14:33:08 <eacameron> ;)
14:33:23 <quchen> ?tell monochrom Now that Cabal supports it, maybe you should mention the "haddock → hyperlink-source: True" setting in your http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
14:33:23 <lambdabot> Consider it noted.
14:35:48 <merijn> quchen: I don't see that option in my cabal config file?
14:35:55 * hackagebot HGamer3D-SFML-Binding 0.4.0 - SFML Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.4.0 (PeterAlthainz)
14:35:57 * hackagebot HGamer3D-Data 0.4.0 - Game Engine for the Haskell Programmer - Data Definitions and Utilities  http://hackage.haskell.org/package/HGamer3D-Data-0.4.0 (PeterAlthainz)
14:35:59 * hackagebot HGamer3D-Graphics3D 0.4.0 - 3D Graphics Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Graphics3D-0.4.0 (PeterAlthainz)
14:36:01 * hackagebot HGamer3D-GUI 0.4.0 - GUI Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-GUI-0.4.0 (PeterAlthainz)
14:36:03 * hackagebot HGamer3D-InputSystem 0.4.0 - Joystick, Mouse and Keyboard Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-InputSystem-0.4.0 (PeterAlthainz)
14:36:18 <quchen> merijn: You don't? Odd. It was auto-generated for me.
14:36:24 <quchen> 1.20
14:37:00 <quchen> Here's my .cabal, http://lpaste.net/109210
14:37:26 <quchen> Maybe you just updated Cabal without deleting your .cabal file?
14:37:43 <quchen> When you do and then run `cabal update` you should get it with the new setting
14:38:10 <merijn> quchen: oh, maybe
14:38:28 <merijn> That's annoying, that means my first few packages are installed without that :(
14:38:45 <quchen> Yup.
14:39:00 <quchen> I think it's not enable by default because it requires hscolour installed.
14:39:10 <dspies> Is anyone here familiar with accelerate?
14:41:00 <Maerten> Hi, I have a (beginner) question about Database.Persist and Thyme: Is it possible to let the entities use UTCTime from Data.Thyme without having to convert Data.Time's UTCTime to Data.Thyme's UTCTime? Right now i have an "instance PersistField UTCTime" that is converting between the types and i am looking for a more efficient way to do this... any help would be appreciated, thanks in advance!
14:41:05 * hackagebot HGamer3D 0.4.0 - A Game Engine for the Haskell Programmer  http://hackage.haskell.org/package/HGamer3D-0.4.0 (PeterAlthainz)
14:41:07 * hackagebot HGamer3D-Network 0.4.0 - Networking Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Network-0.4.0 (PeterAlthainz)
14:41:09 * hackagebot HGamer3D-WinEvent 0.4.0 - Windowing and Event Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-WinEvent-0.4.0 (PeterAlthainz)
14:45:46 * hackagebot mwc-random 0.13.2.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.2.0 (AlexeyKhudyakov)
14:45:48 * hackagebot one-liner 0.3.1 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.3.1 (SjoerdVisscher)
14:46:36 <linman32> hi. trying to install darcs and have dependency issues after upgrading iconv
14:46:37 <linman32> http://pastebin.com/FyJyR7Wi
14:46:59 <linman32> anyone help w/ dependencies?
14:47:47 <merijn> quchen: Hmm, I guess I'll just ghc-pkg unregister all of them and rebuild after I enable hyperlink-source?
14:48:05 <quchen> merijn: My approach to fixing anything with .cabal is nuking everything.
14:48:12 <quchen> It works. And saves time. Every time.
14:48:20 <merijn> quchen: Sure
14:48:45 <merijn> But so does ghc-pkg unregister, especially since I only have 15 or so packages installed since the new platform
14:49:00 <quchen> And whenever you're trying to surgically do anything (read: ghc-pkg unregister instead of nuking) *something* goes wrong. But those are just my two cents.
14:49:03 <merijn> The platform libraries come with source hyperlinked, right?
14:49:08 <sveit_> is it fair to say that for a multivariabletypeclass to be usable each member function must reference each type?
14:49:15 <merijn> sveit_: Yes
14:50:52 <sveit_> merijn, thanks. so follow-up, does this mean there is no way to have a multiparametertypeclass as a context to another class (i.e. "class (C1 a b) => C2 ...") where the subclass doesn't use part of the type variables?
14:51:04 <sveit_> i know the direct way doesn't work, but are there workarounds people use?
14:51:16 <merijn> sveit_: You can have that work in a sensible way, no
14:51:22 <merijn> sveit_: Depends on what you want
14:51:30 <merijn> sveit_: Probably you want a type family anyway
14:51:50 <sveit_> merijn, not in my case :)
14:52:00 <sveit_> i explicity want something to be polymorphic
14:52:04 <carter> nick_named: you're working on the coverage checkerf or GADTs? YAY
14:52:35 <merijn> sveit_: Well, then I think you're boned :)
14:52:39 <merijn> sveit_: Maybe fundeps?
14:52:53 <sveit_> merijn, aren't fundeps ~ type families?
14:53:14 <sveit_> merijn, just not named
14:53:17 <merijn> Pretty sure they're not
14:55:04 <murphy_> hi - I'm new to haskell, and I'm interested specifically to see what it can do with midi events ... I've gone through the basics of lyah and installed the midi library from cabal, but I'm stuck looking for tutorials
14:55:09 <murphy_> or examples
14:55:16 <tertl3> hi I am trying to change my libs to use the newer Text.Parsec
14:55:20 <sveit_> merijn, don't fundeps just say that some set {a,b,c} determines some other set {d,e,f}, so with type families i could do "type FunDep_d a b c :: *; type FunDep_e a b c :: *; ..." to have the same effect?
14:55:27 <murphy_> barring google searches, does anyone know how I should start looking ?
14:56:55 <quchen> merijn: I haven't used the Platform in some time, so I'm not sure about the source anymore
15:00:47 * hackagebot barecheck 0.2.0.0 - QuickCheck implementations for common types  http://hackage.haskell.org/package/barecheck-0.2.0.0 (OmariNorman)
15:01:25 <heagle> Hi, I am trying to figure out how to remove the needless allocations in this code sample. https://gist.github.com/anonymous/4788f476428ca75863ad The problem is fully within 'p', as I cannot figure out how to pass to `array` without allocating up a assoc list of pairs. That is I cannot get gcc to replace with a simple loop.
15:03:58 <tertl3> hello
15:04:10 <tertl3> how can upgrade my code from Text.ParserCombinators.Parsec to Text.Parsec?
15:04:25 <joelteon> sed s/ParserCombinators\.//
15:04:44 <tertl3> do I need to change something?
15:04:59 <tertl3> becuase it doesny compile when I change it
15:05:04 <joelteon> i dunno
15:05:06 <etandel> what does it say?
15:05:09 <joelteon> the first place i'd look is the compiler error messages
15:05:13 <joelteon> usually they have some clues
15:05:18 <etandel> when you try to compile, what does ghc say?
15:05:29 <tertl3> one sec ill try again
15:05:48 * hackagebot mwc-random-monad 0.7.1.0 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.7.1.0 (AlexeyKhudyakov)
15:12:15 <tertl3> etandel,
15:12:35 <tertl3> listing3.3.hs:140:13:
15:12:35 <tertl3>     Not in scope: type constructor or class
15:12:35 <tertl3>     Perhaps you meant one of these:
15:12:35 <tertl3>       `Parsec' (imported from Text.Parsec),
15:12:35 <tertl3>       `ParsecT' (imported from Text.Parsec)
15:14:12 <benzrf> what a pity
15:14:46 <tertl3> i get a lot of those errors
15:15:11 <etandel> huh, i have no idea why it says there's a Parsec on Text.Parsec but doesn't understand that you actually imported Text.Parsec.
15:16:05 <heagle> tertl3:  what is on that line? (line 140)
15:17:00 <tertl3> parseExpr ::Parser LispVal
15:17:00 <tertl3> parseExpr = parseAtom
15:17:00 <tertl3>         
15:17:00 <tertl3>   <|> parseString
15:17:00 <tertl3>   <|> parseRatio
15:17:01 <tertl3>   <|> parseComplex
15:17:03 <tertl3>   <|> parseFloat
15:17:05 <tertl3>   <|> try parseNumber --we need try because they can all start with hash char
15:17:07 <tertl3>   <|> try parseBool
15:17:09 <tertl3>   <|> try parseCharacter
15:17:17 <heagle> http://gist.github.com paste there please
15:17:37 <heagle> the whole source while you are at it :)
15:18:47 <quchen> ?paste
15:18:47 <lambdabot> Haskell pastebin: http://lpaste.net/
15:18:53 <quchen> ^ that's our recommended pastebin.
15:19:00 <heagle> Today I learn :P
15:19:03 <quchen> It features automatic HLint suggestions :-)
15:19:05 <tertl3> https://github.com/billyblackburn/Lisp-in-48/blob/master/listing3.3.hs
15:19:09 <tertl3> its already here
15:19:13 <quchen> heagle: Gists are fine too of course.
15:19:32 <quchen> But Github has some Haskell syntax highlighting problems (for DataKinds syntax).
15:19:53 <heagle> yea I kinda see that :D
15:20:01 <corgifex> so apparently it's called "Parsec" now
15:20:59 <glguy> type Parser = Parsec String ()
15:21:26 <glguy> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-String.html#t:Parser
15:25:21 <heagle> tertl3: I *think* your problem is your parser type is not matching what parsec now expects.
15:25:37 <tertl3> ok im trying to change it now
15:25:50 * hackagebot debian 3.83 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83 (DavidFox)
15:26:26 <glguy> tertl3: You need to add this import:
15:26:28 <heagle> yea the symbol `Parser` is not even imported from Parsec.
15:26:31 <glguy> import Text.Parsec.String
15:26:40 <sveit_> merijn, i htought about it a bit, and can i "cheat" the requirement to reference each type by saying something like "class C a b c where type D b :: *; f :: a -> D b -> c"?
15:26:41 <glguy> as mentioned above (indirectly)
15:26:56 <sveit_> as in will haskell allow me to call such code?
15:27:53 <glguy> sveit_: The code you wrote just there doesn't quite work. If you want to add a "proxy" type argument, you don't need to use a type family
15:28:07 <glguy> but it might be better to figure out what it is you're doing and then understand the best way to encode it
15:28:33 <glguy> But with a proxy argument you'd have:    f :: a -> proxy b -> c
15:28:43 <nh2> is there a name for a programming idiom where for all my data types, I leave a free `a` functor (or similar)? E.g. data User = { age :: Int, name :: String } becoming data User a = { age :: a Int, name :: a String } ?
15:29:50 <k00mi> nh2: what's the point of that?
15:31:16 <glguy> k00mi: I don't know what nh2 is doing with it, but it can be handy for adding annotations, tracking partially filled data, funny recursion
15:31:24 <tertl3> ok thanks guys its working now :)
15:31:43 <tertl3> had to add import Text.Parsec.String
15:32:19 <glguy> yw
15:33:00 <nh2> k00mi, glguy: yes my idea is to later plug in `a` with "referency things" like IORef or Maybe
15:34:04 <nh2> it seems so general to leave each member with a free context hole that there might be a name for it and I want to see if there are some paradigms using that for some benefit
15:37:12 <tertl3> what about this error from fpcomplete with same code
15:37:13 <tertl3> ErrorCall: Prelude.(!!): index too large
15:37:30 <glguy> > [0..5] !! 10
15:37:31 <lambdabot>  *Exception: Prelude.(!!): index too large
15:37:38 <joelteon> and that's why we don't like !!
15:38:41 <estulticia> what is !!?
15:38:49 <glguy> tertl3: It's probably this bit:  do args <- getArgs ;  putStrLn (readExpr (args !! 0))
15:38:50 <joelteon> > [0..10] !! 1
15:38:51 <lambdabot>  1
15:39:02 <joelteon> wow, that wasn't a great example
15:39:09 <joelteon> > ["list", "of", "words"] !! 2
15:39:10 <lambdabot>  "words"
15:39:14 <glguy> tertl3: Do you have a way to give arguments to main when you run it on fpcomplete?
15:39:14 <silasm> "hello" !! 3
15:39:19 <joelteon> estulticia: it's what [] is in other languages
15:39:32 <silasm> wow I'm bad at lambdabot...
15:39:33 <glguy> estulticia: It's a zero-based list index function
15:39:35 <quchen> estulticia: zero-based list indexing.
15:39:47 <quchen> ?src (!!)
15:39:47 <lambdabot> xs     !! n | n < 0 = undefined
15:39:47 <lambdabot> []     !! _         = undefined
15:39:47 <lambdabot> (x:_)  !! 0         = x
15:39:47 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:39:51 <tertl3> glguy, no just the console
15:40:19 <glguy> tertl3: then you probably need to edit your main function so that it doesn't work based on getArgs
15:40:21 <orion> My application is experencing a memory leak. I profiled it and got this result: http://i.imgur.com/9vCsdZF.png does anyone know what could be going on? (http://ideone.com/BEbeSi)
15:40:33 <tertl3> glguy ah ok
15:40:49 <estulticia> glguy, quchen, joelteon: thanks
15:40:51 * hackagebot Allure 0.4.9.0 - Near-future Sci-Fi roguelike and tactical squad game  http://hackage.haskell.org/package/Allure-0.4.9.0 (MikolajKonarski)
15:40:52 <eacameron> can someone help me gain intuition of what `fix` does? I've read the docs and the source, and I've even seen it used. But I still lack the underlying intuition
15:40:53 * hackagebot LambdaHack 0.4.9.0 - A game engine library for roguelike dungeon crawlers  http://hackage.haskell.org/package/LambdaHack-0.4.9.0 (MikolajKonarski)
15:41:15 <glguy> tertl3: If you want to assert that you require at least one argument in a toy project you can write:    do arg:_ <- getArgs
15:41:28 <corgifex> eacameron: time travel / recursion
15:41:29 <glguy> tertl3: That way when you forget to give arguments you'll at least get a line number in the error
15:41:35 <quchen> eacameron: Maybe this helps: https://github.com/quchen/articles/blob/master/fix.md
15:41:43 <merijn> eacameron: Fix implements pointfree recursion
15:41:48 <merijn> eacameron: You know this example:
15:41:55 <merijn> > let ones = 1: ones in ones
15:41:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:42:14 <tertl3> glguy,  I am new to this do you have any ideas for how to implement that?>
15:42:29 <glguy> tertl3: which "that"?
15:42:32 <merijn> eacameron: That self-recursive definition relies on giving a name to it, fix is the function that implements that without a name, i.e. it passes the result of a function to itself
15:42:35 <merijn> :t fix
15:42:35 <lambdabot> (a -> a) -> a
15:42:38 <linman32> does anyone have expirience w/ dependency problems in cabal sandbox?
15:42:38 <merijn> > fix (1:)
15:42:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:42:44 <tertl3> glguy, main :: IO ()
15:42:44 <tertl3> main = do args <- getArgs
15:42:45 <tertl3>           putStrLn (readExpr (args !! 0))
15:42:59 <joelteon> so when you use fix, the argument list to fix looks like a normal function definition
15:43:11 <joelteon> the function you're calling is the first argument
15:43:14 <glguy> tertl3: You could replace getArgs with "getLine" and get a line of input from the console. Maybe that' would help?
15:45:00 <joelteon> for example, the fibonacci function could be fix (\ fib (a, b) -> a : fib (b, a + b))
15:45:27 <eacameron> quchen: invaluable resource!
15:45:28 <tertl3> ah ok glguy u are genius confirmed
15:45:45 <tertl3> working like a rolex now :\
15:46:38 <glguy> linman32: You should just ask your question if you want a shot at an answer
15:47:06 <glguy> Unless all you actually wanted to know is if such a person exists :)
15:48:30 <linman32> need help with these dependencies: http://pastebin.com/35V3Nzq8
15:53:12 <dfeuer> Buh. reverse . reverse ≠ id, for real. Annoying.
15:53:40 <prophile> dfeuer: really?
15:53:50 <fortune500> :t fix
15:53:50 <lambdabot> (a -> a) -> a
15:54:08 <tertl3> can you access this https://www.fpcomplete.com/user/tertl2/scheme-in-48-hours
15:54:25 <tertl3> ?
15:54:29 <dfeuer> Yes, prophile. Rrrrreally.
15:54:39 <glguy> linman32: darcs is abandonware now, it hasn't been updated since Feb 2013 on hackage. It might be easier to install it through your package manager than to go via hackage. If you want to go via hackage you might have to try either loosening up your constraints or unregistering the conflicting package (in this case "text").
15:54:51 <shiona> tertl3: Some page opened
15:55:08 <tertl3> shiona, but not the code?
15:55:23 <glguy> I don't know if #darcs is still active, but you might check if the users there have a favorite way to build now. The answer might be a development version
15:55:30 <shiona> I can see a textbox with haskell code
15:55:38 <linman32> glguy: wait. but gtk uses it. is that abandoned? is gtk a good haskell gui to use? i'm new to this stuff
15:55:46 <dfeuer> I think I now sort of understand a little about how call arity analysis helps foldl fuse. Such weirdness.
15:55:52 * hackagebot muon 0.1.0.8 - Static blog generator  http://hackage.haskell.org/package/muon-0.1.0.8 (kaashif)
15:55:59 <zwer> dfeuer are you talking about infinite lists, or?
15:56:23 <dfeuer> zwer: either infinite or bottom-terminated.
15:56:56 <shachaf> @where sneaky2 doesn't help with this, but is slightly closer to being able to do it
15:56:56 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
15:57:01 <glguy> linman32: I can't make any gui library recommendations. I don't have much experience there
15:57:19 <shachaf> (It's impossible, of course. Use something symmetrical like FMList instead.)
15:57:37 <glguy> linman32: If your OS has a package manager you can probably install a working darcs binary
15:59:05 <dfeuer> Well hello, edwardk. I saw a comment you wrote a few months ago about changing Data.List.reverse to the Prelude version or similar now that call arity is here. I think you are right. I don't have ghc right now, but I think reversing unfoldr gets a perfect unfoldl.
15:59:32 <edwardk> sweet
15:59:48 <edwardk> i vaguely recall mentioning that right after having read through nomeata's paper in depth
15:59:54 <merijn> hmmm, isn't cabal supposed to put docs under ~/Library/Haskell/doc? Then why am I seeing my 7.6.3 docs instead of 7.8? :\
15:59:56 <dfeuer> (Just doing things by hand, and assuming the analysis works out.)
16:00:35 <dfeuer> I'll need to grovel over Core later to be sure.
16:05:53 * hackagebot yesod-test 1.2.4 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.4 (GregWeber)
16:05:58 <hexagoxel> linman32: you don't need darcs for gtk, afaik, unless for special stuff maybe. i have basic gtk haskell program running without any darcs installed
16:06:36 <linman32> glguy: thanks for advice. installed via software manager
16:06:53 <linman32> hexagonexl: your probably right, seeing that it is for rev-control
16:07:28 <linman32> hexagoxel: how is is gtk compared to other haskell gui packages?
16:07:32 <hexagoxel> (and the gtk projects all seem to be on github)
16:07:58 <hexagoxel> haven't used other
16:08:06 <Maya22>  Here some videos. I hope you like them! http://j.mp/1oEKLKx
16:08:27 --- mode: ChanServ set +o johnw
16:08:44 <jonathan1> Hi. I'm trying to optimize a program for memory. What I don't understand is why functions that manipulate lists seem to swallow memory? My most memory consuming function is a filter; I go through a large list of elements, and for each element I check whether it is in a certain set, or not. Imo, this shouldn't really need any memory at all, why does it?
16:09:15 <shachaf> jonathan1: It's slightly tricky to reason about this thing locally.
16:09:23 <geekosaur> you'd have to show us actual code
16:09:25 <shachaf> Maybe it's a lazily-generated list which doesn't really exist until you're looking at it.
16:09:36 <shachaf> But it's hard to say something specific without seeing what you're doing.
16:12:26 <hexagoxel> linman32: glade (the wysiwyg gui editor) is unstable and crashes a lot. the library interface is at a gtk2 level (even with the gtk3 package), which is kinda annoying as gtk3 is nicer in places. apart from that i found gtk easy to use (at least after successful installation)
16:12:42 <hexagoxel> but i did not do anything too complex
16:12:50 <jonathan1> Ok, so about the memory thing: http://pastebin.com/XrSs0qAj
16:13:21 <jonathan1> The relevant parts of the code atleast, with more reader-friendly names
16:13:56 <linman32> hexagoxel: thanks for sharing expirience. g2g
16:14:14 <jonathan1> actually, I messed that up. http://pastebin.com/jWQ9Ux1n
16:23:48 <trap_exit> what is the fastest code for [Double] -> [String] ?
16:23:57 <trap_exit> where I need to convert a huge list of doubles to a huge list of strings
16:24:14 <zinfandel> trap_exit: map show ?
16:24:14 <trap_exit> [Double] -> [LazyText] is fine too
16:24:18 <trap_exit> no no no
16:24:19 <trap_exit> show is slow
16:24:34 <BMeph> trap_exit: 'const [""]' ;þ
16:24:47 <ReinH> So are lists
16:24:49 <trap_exit> BMeph: I bet you're a smartass
16:24:57 <trap_exit> BMeph: clever :-)
16:25:35 <trap_exit> fine, Vector of Doubles -> Vector of Strings
16:25:36 <BMeph> trap_exit: Funny story, I am right this instant, wearing a shirt with an ass on it, underneath which, it reads: "I'm a smart one!"
16:26:20 * BMeph puts his hand to his chest and taps that ass...
16:30:26 <josephle> trap_exit: parMap rpar show? If show is slow, just do more shows at once!
16:30:56 <trap_exit> ARGH
16:30:58 * hackagebot yesod-test 1.2.5 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.5 (GregWeber)
16:31:06 <trap_exit> I was hoping for faster Double -> Text or Double -> String conversion
16:31:11 <trap_exit> are you guys kidding ? :-)
16:31:28 * trap_exit locks BMeph and josephle in a cage and throws the key away
16:31:48 <josephle> trap_exit: http://hackage.haskell.org/package/double-conversion-0.2.0.6/docs/Data-Double-Conversion-Text.html#v:toShortest
16:32:01 <josephle> it claims to be 30 times faster
16:32:06 <josephle> I guess you can find out for yourself
16:32:35 <trap_exit> josephle: cool, thanks!
16:44:20 <Lorianne22>  Hi! I give you some videos. I hope you like! http://bitly.com/1nJPjKj
16:44:43 --- mode: ChanServ set +o glguy
16:44:51 --- mode: glguy set -o glguy
16:46:19 <trap_exit> glguy: as ah op, do you get to do anything else besides kick spammers ?
16:47:15 <trap_exit> what's the fastest way to do Double -> Int conversion ?
16:47:31 <glguy> probably "floor"
16:48:24 <glguy> trap_exit: I get to change the /topic and ask people to stay on topic and send /msg to people who might be disruptive. It's pretty awesome
16:48:59 <NemesisD> hey guys i was hoping you may help me avoid going down a terrible path of law violation
16:49:11 <trap_exit> monad laws or legal laws?
16:49:13 <trap_exit> becuase we can't help with legal laws
16:49:21 <kristof> For free, that is.
16:49:22 <NemesisD> lol typeclass
16:49:42 <josephle> oh, then continue
16:50:06 <NemesisD> i've got a type Parser a that immplements functor, applicative, monad, monadplus, monoid, alternative
16:50:39 <NemesisD> i want to wrap it like data Parser' e a = Parser' { parseError :: String -> e, parser :: Parser a}
16:51:27 <NemesisD> i'd like to derive those laws from the inner parser but i probably can't do that. should i (or even can i) go down the path of defining those instances or should i choose a different strategy
16:53:42 <benzrf> NemesisD: what does parseError do
16:54:04 <shachaf> Speaking of law violations: What would be a good name for "data N a = N a | Nempty | Nappend (N a) (N a)" with the obvious illegal Monoid instance, used to inspect monoid trees?
16:54:10 <NemesisD> benzrf: digs attoparsec's errors that were generated with Control.Monad.fail out of string and into a proper type :(
16:54:21 <benzrf> so Parser a is an attoparsec
16:54:22 <benzrf> ?
16:54:28 <NemesisD> yep
16:54:43 <shachaf> "free pointed magma" doesn't really have a ring to it.
16:55:00 <benzrf> shachaf: yeah, only one operation
16:55:15 <NemesisD> shachaf: that's gotta be an enemy in a capcom game
16:55:42 <pjdelport> NemesisD: If you represent that as newtype Parser' e a = Parser' (String -> e, Parser a) i think you *maybe* be able to get all of those with newtype deriving.
16:56:43 <pjdelport> Though it will require a Monoid instance for e.
16:58:23 <dfeuer> shachaf: what's illegal about a monoid instance for that? As long as you're not deriving Eq, shouldn't that work fine?
16:58:28 <NemesisD> pjdelport: nah. it blunders trying to eta reduce things
16:59:28 <NemesisD> maybe i'll have to use a ReaderT (e -> String) with Parser at the bottom
16:59:39 <shachaf> dfeuer: ?
16:59:49 <pjdelport> NemesisD: Oh well. :) You probably just want to go and define those instances, then.
17:00:06 <shachaf> I'm talking about the instance where mappend = Nappend; mempty = Nempty
17:00:39 <pjdelport> shachaf: Useless opinion, but i think "free pointed magma" has an *awesome* ring to it.
17:01:19 <shachaf> It's too long.
17:01:32 <shachaf> I called it Nonoid but that's a pretty bad name also.
17:01:33 <dfeuer> shachaf: what's illegal about that? As long as your Eq instance works right, you should get a monoid (albeit an inefficient one).
17:01:47 <shachaf> dfeuer: Sure, instance Eq T where _ == _ = True and you're done
17:01:48 <dfeuer> (Well, inefficient for some operations.)
17:02:00 <cmccann> shachaf: upgrade that to "fauxnoid"
17:02:02 <NemesisD> pjdelport: right now e is a phantom type in Parser' e a, maybe i could carefully define type changers (which is what i'm after), whatever :: Parser' Foo a -> Parser' Bar a; whatever = id
17:02:09 <shachaf> cmccann: whoa
17:02:17 <NemesisD> dirty tricks
17:02:40 <shachaf> Maybe there ought to be a general naming scheme for "free" structures sans laws.
17:03:08 <glguy> ReifiedMonoid?
17:03:20 <shachaf> Hm, maybe...
17:03:37 <shachaf> dfeuer: It sounds like you're proposing the sort of scheme where you don't export your type and use module boundaries to ensure it's being used safely.
17:04:04 <shachaf> I'm talking about laws that just apply to the type even when it's fully exposed.
17:04:07 <dfeuer> shachaf: approximately so.
17:04:08 <shachaf> (Otherwise what's the point?)
17:04:25 <dfeuer> Well, lots of things do that, but okay.
17:04:33 <cmccann> shachaf: your point is Nempty I think
17:05:33 <ij> Does ghci generate a sort of a soruce file that it compiles and just runs behind our backs?
17:05:40 <shachaf> I made a big improvement to containers using this type.
17:05:50 <merijn> ij: You mean when you type inside it?
17:05:57 <shachaf> Well, to the Foldable etc. instances for containers.
17:06:00 <ij> merijn, Yes.
17:06:08 <shachaf> What other classes would be useful to reify in this way?
17:06:40 <merijn> ij: Yes, no, maybe, it depends? :) Why do you ask?
17:07:29 <ij> I was just thinking I could save it after I've typed a lot of stuff, but I guess I probably can just copy ghci_history too.
17:08:08 <merijn> ij: There's no practical way to do that no, but then again I wouldn't recommend typing a lot of stuff into ghci in the first place :)
17:08:33 <Welkin> does anyone use the python interpreter to write whole functions?
17:08:39 <Welkin> that has always been painful
17:08:43 <merijn> Welkin: Yes, I'm sure some people do
17:08:51 <Welkin> it seems like ghci is not useful for multiline code either
17:09:05 <merijn> You can do it, but you shouldn't :p
17:11:25 <ian_mi> If GHC knows that a type t has kind (k1, k2) is it possible to convince it that there exist types (a :: k1) and (b ::k2) such that t ~ '(a, b)?
17:13:32 <ian_mi> Is this considered pattern matching on types?
17:13:38 <mhitza> is there a way that I could share data constructors between two data types?
17:14:02 <Welkin> mhitza, if you put them in different modules and qualify the imports
17:15:08 <mhitza> Welkin, maybe I'm explaining it wrong, But consider data A1 = One | Two | Three and data A2 = One | Two . Are you saying this is possible by putting them in different modules?
17:15:18 <glguy> mhitza: You can approximate that in a way with GADTs. Maybe you can paste an example of what you're trying to do though?
17:15:32 <mhitza> ok, let me clean it up a bit
17:16:05 <ian_mi> mhitza: what would the type of One be?
17:17:08 <glguy> An example of the technique I'm talking about can be seen here: http://hackage.haskell.org/package/hoopl-3.10.0.1/docs/Compiler-Hoopl.html#t:Pointed
17:17:26 <glguy> but if that doesn't make sense you're probably better off not trying to do it, it won't necessarily lead to better code
17:17:27 <mhitza> ian_mi, glguy the example http://lpaste.net/109215 wheren AttackType and Canceable share the same values
17:18:24 <Hafydd> What does the word "canceable" mean?
17:18:47 <mhitza> Hafydd, a property for an attack in fighting games
17:18:54 <spott> is it possible to have a function in a typeclass with multiple versions of that typeclass:  instance MyClass m where myFunc :: (MyClass m2, MyClass m3) => m -> m2 -> m3
17:18:58 <josephle> I think he meant Cancelable
17:18:59 <Hafydd> That doesn't tell me what it means.
17:19:08 <spott> essentially something that allows you to transform between versions of a typeclass
17:19:12 <Hafydd> Oh. Is it a typo, then?
17:19:16 <mhitza> Hafydd, anyway I see it typoed
17:19:24 <Hafydd> I see.
17:20:49 <merijn> spott: That doesn't really make an y sense
17:21:02 <spott> why not?
17:21:43 <spott> it depends on how similar your typeclasses are:  for example, a typeclass "Number", that allows you to divide ints to get rationals
17:21:57 <spott> or divide ints by rationals to get rationals
17:22:12 <spott> *your typeclass instances are
17:22:35 <merijn> spott: No, I meant your question doesn't make any sense in the contexts of how typeclasses work
17:22:45 <merijn> spott: What would myFunc do?
17:25:08 <spott> The example I am struggling with is sparse and dense matrices:  a sparse matrix only has values in certain places (everything else is zero), but a dense matrix has values everywhere
17:25:26 <merijn> spott: Right, I know the guy you wanna talk too :)
17:25:34 <merijn> spott: Join #numerical-haskell and talk to carter :)
17:25:54 <spott> yea, I know him... but the question is more general than that
17:26:48 <merijn> spott: The thing is, if the types of m2 and m3 aren't fixed, how does GHC select an implementation?
17:28:21 <spott> merijn: MyFunc a b :: (MyClass a1, MyClass a2, MyClass a3) => a1 -> a2 -> a3
17:29:19 <orion> My application is experencing a memory leak. I profiled it and got this result: http://i.imgur.com/9vCsdZF.png does anyone know what could be going on? (http://ideone.com/BEbeSi)
17:29:33 <trap_exit> what is the builtin that does
17:29:37 <spott> when MyFunc is given implementations for a and b, it finds the function that is defined on those two, and spits out a3 according to the function
17:29:46 <trap_exit> 1 -> [0], 2 -> [0, 1], 3 -> [0, 1, 2], n -> [0, 1, ..., n-1] ?
17:30:03 <trap_exit> 1 -> [0], 2 -> [0, 1], 3 -> [0, 1, 2], n -> [0, 1, ..., n-1] ? (waht's a builtin that provides this function)
17:30:17 <merijn> spott: Right, but that means your instance for Foo relies on instance existinf for a2 and a3, which GHC doesn't know. And I don't see an immediate way of massaging the class so that it can
17:31:38 <spott> merijn: well, technically an instance for Foo only needs to have an instance for every other a2... a3 would be defined by the return type of those but I get what you are saying
17:31:48 <Axman6> trap_exit: enumFrom 0
17:32:00 <Axman6> > enumFrom 0 $ 1
17:32:01 <lambdabot>  Couldn't match expected type ‘s0 -> t’ with actual type ‘[a0]’
17:32:10 <Axman6> > enumFromTo 0 $ 1
17:32:11 <lambdabot>  [0,1]
17:32:18 <Axman6> > init . enumFromTo 0 $ 1
17:32:20 <lambdabot>  [0]
17:32:22 <Axman6> >_>
17:32:31 <merijn> spott: Making it a MPTC just makes the mess bigger :\
17:32:40 <spott> MPTC?
17:32:42 <Axman6> > enumFromTo 0 . (subtract 1) $ 1
17:32:44 <lambdabot>  [0]
17:32:48 <merijn> spott: multiparametertypeclass
17:33:13 <Axman6> > enumFromTo 0 . (subtract 1) $ 5
17:33:15 <lambdabot>  [0,1,2,3,4]
17:33:19 <spott> merijn: they are MPTCs... :)
17:33:24 <spott> just not in this toy example
17:35:11 <trap_exit> oh
17:35:11 <trap_exit> I'm retraded
17:35:13 <trap_exit> [ 1 ..]
17:35:15 <trap_exit> > [1 .. ]
17:35:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:35:26 <trap_exit> > take 5 [0 .. ]
17:35:27 <lambdabot>  [0,1,2,3,4]
17:35:42 <trap_exit> > take 5 [ (0 :: Int} .. ]
17:35:43 <lambdabot>  <hint>:1:19: parse error on input ‘}’
17:35:52 <trap_exit> > take 5 [ (0 :: Int) .. ]
17:35:53 <lambdabot>  [0,1,2,3,4]
17:36:12 <trap_exit> I'm going to go sit in timeout for a while now
17:36:12 <merijn> trap_exit: See also "enumFromTo"
17:36:17 <merijn> :t enumFromTo
17:36:18 <lambdabot> Enum a => a -> a -> [a]
17:36:21 <trap_exit> merijn: noted, thanks
17:36:25 <merijn> > enuFromTo 0 5
17:36:26 <lambdabot>  Not in scope: ‘enuFromTo’
17:36:26 <lambdabot>  Perhaps you meant ‘enumFromTo’ (imported from Prelude)
17:36:32 <merijn> > enumFromTo 0 5
17:36:34 <lambdabot>  [0,1,2,3,4,5]
17:36:56 <merijn> > let f = enumFromTo . pred in f 9
17:36:57 <lambdabot>  <Integer -> [Integer]>
17:37:04 <merijn> eh
17:37:10 <merijn> > let foo = enumFromTo . pred in foo 9
17:37:11 <lambdabot>  <Integer -> [Integer]>
17:37:30 <merijn> > let f = enumFromTo 0 . pred in f 9 -- stupid show instance for functions...
17:37:32 <lambdabot>  [0,1,2,3,4,5,6,7,8]
17:38:10 <Hafydd> It's better than a 3-line error message, surely.
17:38:59 <solidus-river> anyone here ever fought with upgrading haskell using the gentoo package overlay before?
17:39:00 <merijn> Hafydd: Not if I don't understand something's going wrong >.>
17:39:27 <Hafydd> merijn: surely the presence of "<Integer -> [Integer]>" when you didn't want a function would tell you that.
17:39:28 <solidus-river> i upgraded ghc and haskell-updater fails to build everything it claims it needs to build. usually doesnt get past the config checks
17:39:46 <solidus-river> this is problematic because the only wm on my maching (or one thats configured sanely) is XMonad
17:39:50 <solidus-river> which i expect will not work if i restart
17:40:27 <merijn> Hafydd: I thought it was simple-expr
17:40:56 <Hafydd> Oh. Well, the problem would seem to be with simple-expr, then.
17:42:19 <josephle> solidus-river: fortunately for you, xmonad does not recompile every power cycle
17:42:41 <josephle> now if you want to update your configs...
17:42:50 <solidus-river> josephle: but wouldn't it fail to link if the haskell bindings for x11 are now broken?
17:43:12 <solidus-river> or does it only use those packages at compile time
17:43:19 <solidus-river> not sure how linking works with haskell
17:44:56 <solidus-river> i guess it would link to the system library though in the end
17:45:40 <merijn> solidus-river: All the haskell libraries are by default statically linked (this is why many newcomers complain about the sizes of haskell binaries)
17:46:07 <merijn> solidus-river: The good news is, if you didn't change that default it doesn't matter at all that you broke any haskell libraries, as long as your dynamic C libraries are intact
17:46:20 <merijn> solidus-river: (This is also a good argument in favour of static linking IMO)
17:46:24 <shachaf> merijn: Whereas the non-newcomers have learned not to complain about it anymore?
17:46:35 <merijn> shachaf: I think static linking is great
17:46:43 <solidus-river> hmm, bad news is i wouldn't be suprised if gentoo's emerge changes that from static to dynamic
17:46:50 <solidus-river> but this gives me hope
17:47:00 <merijn> shachaf: Dynamic linking has given me a billion times more nightmares than static ever has
17:47:25 <josephle> solidus-river: but at least your xmonad binary will work thanks to static linking
17:47:38 <merijn> josephle: Not if gentoo broke the default config ;)
17:47:48 <josephle> oof, that is true...
17:48:16 <merijn> solidus-river: run ldd on your xmonad binary to find out?
17:48:58 <merijn> If it doesn't show anything other than some /usr/lib C libraries, you should be fine
17:49:08 <roconnor__> shachaf: thanks for the link
17:50:48 <roconnor__> shachaf: the U(Mu T) being iso to forall x. (T x -> x) -> U x is particularly interesting for the special case of T = U.
17:51:36 <solidus-river> merijn: thats an awe3some idea!
17:52:38 <shachaf> roconnor__: You mean that (forall r. (T r -> r) -> T r) is also a fixed point of T?
17:52:47 <solidus-river> i'm heading home to try that out, no doub't i'll be back on in a bit
17:53:51 <shachaf> roconnor__: That seems a little odd at first but it makes sense.
17:54:26 <shachaf> I guess you have the same thing for Nu? (exists x. (T x, x -> T x)) is a greatest fixed point?
17:54:33 <shachaf> There it's even more obvious.
17:59:34 <roconnor__> shachaf:  I don't really see why this makes sense.
18:00:07 <roconnor__> well the Nu one makes a bit more sense.
18:00:26 <shachaf> roconnor__: (exists x. (x, x -> T x)) is a fixed point because you start with an initial x value, which you can't do anything with except apply the function to it and then inspect the non-parametric parts of the result.
18:00:43 <roconnor__> I guess the Mu one says you can evaluate everything but the outermost T.
18:00:46 <shachaf> Then you can apply the function again on the parametric parts of the result.
18:00:55 <shachaf> So the function is just pre-applied one or more times.
18:01:24 <roconnor__> okay
18:01:35 <shachaf> Oh, that's not the one you were talking about.
18:02:17 <shachaf> Take the Mu case with Maybe: (forall r. (Maybe r -> r) -> r) vs. (forall r. (Maybe r -> r) -> Maybe r)
18:02:31 <shachaf> It's doing the same thing except it doesn't do the final reduction.
18:02:38 <roconnor__> yep
18:03:00 <shachaf> I guess reduction isn't the right word, but you see what I mean.
18:03:48 <roconnor__> unroll :: (forall r. (T r -> r) -> r) -> (forall r. (T r -> r) -> T r)  is a nicer type than unroll :: (forall r. (T r -> r) -> r) -> T (forall r. (T r -> r) -> r)
18:05:05 <athan> Is there a haskell-like shell? Not looking to do scripting in particular, like with shelly, but just a general purpose shell that, maybe, supports typed variables and functional programming in your .*shrc files...?
18:05:08 <shachaf> Sure, but you need the latter to show that it's a fixed point.
18:05:23 <shachaf> I don't remember why I sent you that article anymore.
18:05:41 <roconnor__> unroll i r = i (fmap r)
18:06:45 <roconnor__> shachaf: you were teaching me that Mu F and forall r. (F r -> r) -> r are ismorphic for (postive) functors F.
18:06:52 <ReinH> roconnor__: hi!
18:06:56 <roconnor__> hi
18:07:27 <shachaf> roconnor__: I like to take that as the definition of Mu. And the existential thing as the definition of Nu.
18:07:40 <shachaf> I prefer to call newtype Fix f = Fix (f (Fix f)) "Fix".
18:08:21 <roconnor__> hmm
18:08:55 <ReinH> oh that sounds interesting!
18:09:31 <ReinH> I think I was told that Mu and Nu are the same in Haskell?
18:09:37 <shachaf> They are the same in Haskell.
18:09:44 <dolio> All those types.
18:09:49 <shachaf> Yes.
18:10:02 <shachaf> It's a good exercise to figure out why.
18:10:02 <dolio> In other languages, they may not be the same.
18:10:27 <dolio> Although which the newtype would be would depend on something in the language.
18:10:37 <shachaf> Yes.
18:10:44 <shachaf> But it has a clear analogy to value-level fix.
18:11:32 <shachaf> Anyway, you could say fold :: Fix f -> Mu f; unfold :: Nu f -> Fix f
18:12:15 <shachaf> Is there a name for this pattern? fmap :: Functor f => f a -> Yoneda f a; fmap :: Functor f => CoYoneda f a -> f a
18:12:41 <shachaf> It comes up in a lot of places.
18:12:48 <dolio> Currying?
18:13:08 <shachaf> I mean, where either "the arguments of" or "the return value of" a particular function are interesting values in themselves.
18:13:20 <shachaf> (With an existential or a universal respectively.)
18:15:08 <dolio> Those are limit and colimit adjunctions.
18:15:23 <dolio> The thing that gets called Yoneda is an end.
18:15:31 <dolio> CoYoneda is a coend.
18:15:51 <dolio> And both ends and coends are internalizations of natural transformations, which is what fmap is.
18:16:05 <dolio> Coends end up on the left, and ends end up on the right.
18:16:09 * hackagebot dns 1.4.3 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.3 (KazuYamamoto)
18:20:30 <shachaf> dolio: What about the fold/unfold thing?
18:21:06 <dolio> Well, for one, in a language where Mu and Nu were distinct, you wouldn't be able to write both of your functions.
18:21:22 <dolio> At least, not with the expected behavior.
18:21:23 <shachaf> And e.g. Codensity/Density, I guess.
18:21:30 <shachaf> True.
18:21:34 <shachaf> Hm.
18:22:52 <dolio> What's the (co)density one?
18:23:10 <shachaf> (>>=) :: Monad m => m a -> Codensity m a
18:23:41 <dolio> Oh. That's same as (Co)Yoneda.
18:23:44 <dolio> Just a different category.
18:23:46 <shachaf> Right.
18:24:25 <dolio> You have a natural transformation, and turn it into a (co)end.
18:24:47 <dolio> A lot of that probably depends on things being complete enough.
18:25:09 <dolio> But when you're Set-like, you are.
18:27:21 <dolio> Anyhow, Fix f -> Mu f assumes that Fix f is initial. Then there's a natural transformation for the universal property, and you take an end.
18:27:31 <c909_> I'm a noob. Could someone give me a pointer on how to use a monad in a list comprehension?
18:28:04 <dolio> Universal properties being natural transformations, more or less. And (co)limits being internalizations of them.
18:28:25 <c909_> Basically, I have function that returns a Reader a Bool, and I need to use it as a constraint in a comprehension
18:31:13 * hackagebot rainbow 0.16.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.16.0.0 (OmariNorman)
18:35:33 <dfeuer> Is there anything worth doing about the nasty case of reverse.reverse? Is reverse.reverse.reverse=reverse about the best you can do?
18:35:51 <shachaf> Why do you care?
18:36:04 <dfeuer> shachaf: just pondering.
18:37:22 <geekosaur> I have a vague recollection of past attempts that ended up causing more problems than they solved, but it's been a long time...
18:37:43 <dfeuer> shachaf: I was exploring on paper what happens if reverse is defined using (approximately) the Prelude definition, as opposed to the Data.List definition, using the new foldl and call arity stuff.
18:37:54 <geekosaur> (and it is possible that modern ghc is better at the cases that exploded before)
18:38:58 <dfeuer> The result of reverse(reverse xs) using that is not *horribly* horrible, but it's still pretty horrible. In particular, it copies the spine of the list.
18:39:19 <shachaf> dfeuer: fun fact: ghc doesn't optimize «reverse []» to «[]»
18:39:24 <hodapp> spine of the list?
18:39:29 <dfeuer> (and maybe allocates some more useless stuff too)
18:39:48 <dfeuer> hodapp: the spine meaning the actual conses, as opposed to whatever they contain.
18:40:24 <jmcarthur> i don't think it's "horrible," although i agree that it would be nice to optimize it further
18:40:34 <dfeuer> shachaf: does it not inline it?
18:40:37 <edwardk> clearly you should use the super-lazy reverse instead =P
18:40:51 <dolio> Do people write reverse (reverse xs)?
18:41:04 <jmcarthur> dfeuer: recursive definition, isn't it?
18:41:06 <athan> Does anyone know where material is on van Laarhoven lenses? His blog seems buggy :/
18:41:15 <dfeuer> dolio: of course not. I'm thinking about potential inlining.
18:41:24 * jmcarthur goes to dig up his super lazy foldl
18:41:32 <shachaf> @where sneaky2
18:41:32 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
18:41:35 <dolio> Do people write things that inline to reverse (reverse xs)?
18:43:07 <jmcarthur> http://lpaste.net/91109   -- super lazy foldl
18:43:08 <dfeuer> dolio: that's one side of what I don't know. Suppose not. How do you write a good forceSpine?
18:43:35 <dolio> Using strategies?
18:44:51 <dolio> I don't really know, though, because I've never wanted a function that would have the name forceSpine.
18:45:23 <nadaa> newbie trying to "cabal install wx" on new debian 7.6.0 amd64 sys cabal crash on " wxc-0.90.1.1 failed during the configure step"
18:46:38 <dfeuer> dolio: that's what reverse.reverse *is*.
18:46:39 <geekosaur> nadaa: do you have the system wx devel libraries installed? and, we'd probably need to see output with -v3
18:46:49 <shachaf> dfeuer: ?
18:46:53 <dolio> Yeah. I've never used reverse.reverse.
18:46:55 <dfeuer> jmcarthur: I'm not sure how to read that.
18:47:19 <shachaf> Why should reverse.reverse be called forceSpine?
18:48:03 <dfeuer> shachaf: because that's what it does, while also allocating a bunch of stuff.
18:48:18 <shachaf> OK, I would write length.
18:48:18 <tgeeky> shachaf: I could see, in a handwavy fashion, some bidirectional tree-like thing being forced into a spine by two reverses :o
18:48:35 <athan> dfeuer: lazy pattern matching?
18:48:44 <bts-> how do I get haskell-mode's C-c C-l in emacs to load cabal deps? I have already run `cabal install`
18:49:06 <dfeuer> athan: what is the question?
18:49:20 <dolio> Anyhow, I think before you start on stuff like this, it might be good to figure out of people actually write it.
18:49:32 <dolio> Because otherwise it's just delaying my compiles.
18:49:33 <athan> dfeuer: I just saw you said you didn't know how to read the code. Is it from the lazy pattern matching?
18:50:00 <shachaf> I think that's good advice for a lot of dfeuer's recent activity.
18:50:20 <dfeuer> athan: what's the <*> mean?
18:50:38 <nadaa> yes some libwx stuff    i new at this ? should i be using cabal github wxHaskell and or building other source at the same time ??
18:50:47 <dfeuer> shachaf: the reverse.reverse is probably silly. Some of the rest seem not to be.
18:51:03 <athan> dfeuer: I'm guessing applicative-like application where [] is the instance, but that's what got me too
18:51:11 <modeller> Anyone know what this symbol "⊥" mean as in "programs that formally evaluate to ⊥" in the Haskell report (Intro).
18:51:15 * hackagebot rainbow-tests 0.16.0.0 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.16.0.0 (OmariNorman)
18:51:38 <bts-> modeller: the "bottom" type
18:51:40 <athan> modeller: I'm guessing undefined
18:51:43 <shachaf> bts-: It's not a type.
18:51:55 <solidus-river> athan: its bottom / undefined
18:51:57 <dolio> It is a value common to all types.
18:52:03 <bts-> ah sorry
18:52:08 <athan> modeller: in this context. It could be a nonterminating function though
18:52:16 <c909_> So, I'm trying to do something that may be dumb. I'm still learning. http://lpaste.net/727321315366666240 Can someone tell me how to use a function in the reader monad as a constraint in a list comprehension?
18:52:21 <modeller> non-terminating. got it
18:52:23 <modeller> thanks
18:52:48 <dolio> c909: If you want to apply a Reader, you have to use runReader.
18:53:01 <c909_> ok.
18:53:21 <c909_> this is part of a chain that eventually calls runReader. Will this work?
18:53:48 <dolio> I'm not sure that's what you want for this example, though.
18:54:17 <c909_> yeah. I posted a really simplified example. Perhaps it isn't enough.
18:54:36 <geekosaur> nadaa: the haskell bindings depend on c++ developer bindings
18:54:50 <c909_> I'm keeping my configuration state in the Reader monad and the list construction depends on the configuration data
18:55:15 <geekosaur> it's not like someone reimplemented Wx in Haskell; it just binds to the C++ developer libraries
18:55:31 <c909_> and my predicate is composed of a few other functions that depend on that data, so it would be inconvienient to just pass the data directly
18:55:58 <griotspeak> Hello
18:56:02 <dolio> c909: Perhaps filterM would be useful to you.
18:56:24 <dolio> You cannot use it in the middle of a list comprehension, though.
18:56:50 <c909_> I will check that out. It seems that using runReader with the data from ask worked for me.
18:56:56 <c909_> thanks a lot for the help!
18:57:13 <geekosaur> the runtime libraries are not enough, there are various constants and things needed to bind to the developer libraries in the headers, which are in the -dev packages
18:57:44 <c909_> hm, filterM looks like a better solution too. thanks
18:57:55 <dolio> No problem.
19:00:54 <Sgeo> How soon until Backpack becomes the Haskell way to do things?
19:03:44 <griotspeak> Hello… I have an admittedly confused question. When we define instances of a class, is it reasonable to think of that similar to adding methods to a class in OO ?
19:04:59 <AshyIsMe> it's more like adding new concrete types of an abstract class
19:05:09 <griotspeak> ah, yea
19:06:02 <griotspeak> and defining the type class is similar to declaring the abstract class.
19:06:13 <AshyIsMe> yeah
19:07:02 <griotspeak> I thank you
19:07:16 <dolio> The connection doesn't hold up in all cases, though. So be careful.
19:07:23 <griotspeak> yeah
19:07:27 <Cale> Though if your plan is to encode some idea from OO, type classes are probably a red herring
19:07:57 <hodapp> if you disregard OO completely, that's a closer approximation than paying it any mind.
19:08:08 <Cale> You can probably do it just with data types consisting of records of functions (and perhaps some other stuff) and functions which construct those records
19:08:38 <Cale> You can do the important part of OO that way, anyway.
19:09:00 <dolio> As long as you agree with Cale what the important parts are. :)
19:09:02 <pjdelport> griotspeak: You can *vaguely* think of instances as providing a concrete implementation class of an abstract base class. Type classes are a little bit more like interfaces, in OO terms.
19:09:15 <griotspeak> full disclosure, I am both learning Haskell and trying to apply learning to swift
19:09:18 <Cale> You don't get all the stuff about subtyping and inheritance and whatnot, but that's stuff that OO programmers have already started to avoid in their designs anyway.
19:09:46 <pjdelport> (griotspeak: But analogies with OO has its limits, as people point out.)
19:10:01 <griotspeak> my question was motivated because I wasn't sure whether using instance methods was muddying the waters
19:10:49 <griotspeak> I actually think that I understand type classes as a general concept pretty well now in terms of Haskell
19:11:01 <griotspeak> though I need to write more Haskell
19:11:06 <tgeeky> griotspeak: famous last words!
19:11:08 <jmcarthur> dfeuer, athan: the (<*>) is from Control.Applicative and corresponds, in this case, to the ((->) a) instance
19:11:23 <pjdelport> griotspeak: Type classes are pretty simple at the root. A class like Num simply defines an interface and a common set of methods that a number-like type must have.
19:11:31 <griotspeak> yea
19:11:46 <jmcarthur> dfeuer: it's not the important part of the function, just a trick to not have to bind one of the arguments
19:11:50 <griotspeak> I freely admit that I don't get Applicative and friends
19:12:21 <dfeuer> jmcarthur: what's the purpose of an extra-lazy foldl (assuming I can figure out what it does)?
19:12:25 <pjdelport> griotspeak: The built-in concrete number types like Int, Double, Rational, etc. all provide Num instances: but they idea is that you can go and declare it for any other data type that it makes sense for, including types you define yourself.
19:12:45 <solidus-river> it looks like there are a lot of packages that are incompatable with ghc 7.8 still?
19:12:52 <solidus-river> http://pastie.org/9463558
19:13:01 <griotspeak> many thanks, goodnight
19:13:02 <dfeuer> Oh, is this a foldl that can terminate early?
19:13:04 <pjdelport> So you could make a fancy "data Polynomial = ..." type, and declare a Num instance for it, and then proceed to use (+) and all the rest on it.
19:13:47 <dolio> solarus: A 2 year old version of vector?
19:13:48 <dfeuer> H,,,... no....
19:13:58 <dolio> Whoops, sorry. solidus-river.
19:14:12 <dfeuer> What was old is new again!
19:14:58 <solidus-river> dolio: heh, well balls why do i have such an old version of vector on my machine, darn it gentoo, are your ebuilds just going to completely screw me over
19:15:12 <solidus-river> and to think just last week i was tlaking about how smooth haskell was using emerge
19:16:14 <dfeuer> dolio: I realized the other day that a machine I have an account on is still running ghc 6.x....
19:16:39 <dolio> Well, that's kind of useful.
19:16:55 <dolio> I can't even test against 7.6 anymore, because it doesn't build with 7.8.
19:17:01 <dolio> And I don't have 7.6 anymore.
19:17:18 <solidus-river> there is no back! only forward!
19:17:29 <dolio> (Well, actually I do. But I haven't been bothered to go back and compile an auxiliary 7.6.)
19:17:43 <solidus-river> man this could be a bick pain in the bum though
19:17:55 <solidus-river> if gentoo thinks i need 2 year old packages i need to find out why and upgrade them as oneshot
19:17:58 <solidus-river> joy
19:18:10 <dfeuer> dolio: is that the great primops shift?
19:18:13 <dolio> Anyhow, 7.8 changed some low level stuff that will break certain packages until you get updated versions.
19:18:31 <dolio> dfeuer: Probably, I guess.
19:18:48 <dolio> But in general building previous versions of GHC with new compilers isn't supported.
19:19:15 <dolio> No one wants to go fix old code to build on new stuff.
19:19:37 <jmcarthur> dfeuer: to be extra lazy! for example, consider a version of reverse defined in terms of the lazier foldl. you can use the null function on the result without evaluating the whole spine of the original list.
19:20:48 <dfeuer> jmcarthur: I still don't *understand* the lazier foldl, so I don't understand in what fashion it's lazier.
19:21:14 <dfeuer> Replacing reverse.reverse with id is easy; I was looking for something preserving the semantics.
19:21:18 <jmcarthur> dfeuer: try it out yourself. define another version of reverse in terms of it and compare with the standard definition when composed with null
19:21:54 <jmcarthur> dfeuer: try something like   null $ reverse (1:2:3:4:5:6:7:8:undefined)
19:22:38 <jmcarthur> @src sneaky2
19:22:38 <lambdabot> Source not found. Maybe you made a typo?
19:22:58 <jmcarthur> bah
19:23:42 <jmcarthur> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in null $ lazyReverse (1:2:3:4:5:6:7:8:undefined)   -- basically what you would get from the lazier foldl, specialized for reverse
19:23:43 <lambdabot>  False
19:23:53 <jmcarthur> > null $ reverse (1:2:3:4:5:6:7:8:undefined)   -- standard reverse
19:23:54 <lambdabot>  *Exception: Prelude.undefined
19:24:18 <solidus-river> kinda cool that ghc is willing to make breaking changes
19:24:25 <neutronest> > head [1..5]
19:24:26 <lambdabot>  1
19:24:40 <modeller> A short question: In haskell, when we talk about "class", does it always mean "type class" (not class as a type like in C)?
19:24:43 <edwardk> dfeuer: a properly lazier reverse can get you the length of the spine right even in the infinite case. you get an infinite list of bottoms rather than one big fat bottom
19:25:46 <modeller> I ask this to clarify the "class" in haskell report context: An identifier must not be used as the name of a type constructor and a class in the same scope.
19:25:53 <dolio> modeller: Yes. Always type class.
19:26:04 <edwardk> dfeuer: so if you have a predicate like lengthGT 10000 that computes the result by checking to see if it really is greater than 10000, and stops digging after that the predicate will return the right answer on the 'lazier reversed' infinite list, etc.
19:26:12 <modeller> dolio: thx
19:26:44 <jmcarthur> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in length $ take 10 $ lazyReverse [1..]
19:26:45 <lambdabot>  10
19:26:59 <jmcarthur> > length $ take 10 $ reverse [1..]
19:27:03 <lambdabot>  mueval-core: Time limit exceeded
19:27:12 <dfeuer> edwardk: Weird. I will need to dig into what this <*> means and try to puzzle this out later tonight.
19:27:23 <jmcarthur> dfeuer: i already gave you the definition of (<*>) earlier
19:27:30 <jmcarthur> dfeuer: and explained that it is not the important part
19:27:39 <dolio> It's just the S combinator here.
19:27:48 <solidus-river> well that was suprisingly pleasant unmasked the unstable builds and everything seems to be fixing itself
19:28:27 <solidus-river> merijn: ldd proved my xmonad binaries are staticly linked except for some C libs
19:28:36 <solidus-river> merijn: thanks for the tip
19:28:42 <jmcarthur> dfeuer: f <*> a = \b -> f b <*> a b
19:28:47 <jmcarthur> gah
19:28:49 <jmcarthur> fail
19:28:54 <jmcarthur> dfeuer: f <*> a = \b -> f b (a b)
19:28:56 <jmcarthur> sorry
19:29:26 <dfeuer> Hm.
19:29:41 <jmcarthur> so it's basically   go xs (reverse xs)
19:29:46 <dolio> Yes.
19:30:16 <dolio> If I'm not mistaken, that function is using foldl f z xs = foldr (flip f) z (reverse xs)
19:30:51 <dolio> Plus is uses the original xs to know when to stop, so it doesn't have to look at reverse xs for that.
19:31:10 <jmcarthur> right, it uses the spine of the original list with the elements of the reversed list
19:32:42 <jmcarthur> the spine of the reversed list is only forced when you force an element from it
19:34:40 <dfeuer> jmcarthur: I have to run, but that's interesting.
19:40:11 <shachaf> @where sneaky2 + foldr
19:40:11 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
19:53:49 <Lambdanaut> Hiya. I've got a StateT monad with an inner IO. Is it possible to unwrap just the State monad, leaving the IO behind, and call another function with just the State monad? I only want to use the IO portion in my program's main loop, but want to keep the rest of the function pure.
19:54:10 <Lambdanaut> functions*
19:55:16 <shachaf> I'm not sure what all those words mean but maybe you want to write something with a type like MonadState s m => ...
19:55:18 <Luke> Lambdanaut: yeah just make a function that takes StateT m
19:55:23 <shachaf> Which'll work with both State s and StateT s IO
19:55:33 <athan> How can a constraint be universally quantified? In the SYB paper, gmapT :: (forall b. Term b => b -> b) -> a -> a.... :S
19:55:41 <shachaf> ...Or you can do that, since State s = StateT s Identity these days.
19:56:07 <Luke> Lambdanaut: Monad m => StateT s m a    -- will pass the IO monad through without allowing you to use it
19:57:06 <Luke> Lambdanaut: does that make sense?
19:58:05 <Lambdanaut> Somewhat. An example would be very appreciated
19:58:12 <Luke> sure
19:58:13 <Luke> one se
19:58:16 <Lambdanaut> :)
19:58:59 <Luke> sec*
20:06:15 <Luke> Lambdanaut: http://lpaste.net/109218
20:07:53 <Luke> Lambdanaut: your inner functions basically allow a monad to be threaded through but they don't have to know it's IO (or whatever other outer monad you have)
20:08:09 <Luke> er, inner monad I should say
20:08:27 <Lambdanaut> Oh right, I guess I'm doing this already
20:08:48 <Lambdanaut> doesn't this compromise myFn's purity?
20:09:10 <Luke> Lambdanaut: no myFn is still pure
20:09:42 <Luke> you could be just passing the Identity monad as m or something like IO
20:10:22 <Lambdanaut> I see okay that makes sense. Thanks! 8)
20:11:28 <Luke> Lambdanaut: if you don't want your function to be monadic at all, get the state out of your state monad and just pass it in as an explicit argument
20:18:29 <Lambdanaut> So I'm just applying that qualifier of Monad m => StateT a m ()
20:18:44 <Lambdanaut> and it's making my type signatures pretty verbose
20:18:55 <Lambdanaut> is that avoidable or not? I can live with it.
20:19:42 <Lambdanaut> Maybe a type synonym that forces the "m" to be a monad
20:19:51 <Lambdanaut> is that possible?
20:20:29 <edwardk> Lambdanaut: it doesn't work like you want. when you ever need to take such a synonym in negative position (as an argument) it means very very much the wrong thing
20:20:39 <edwardk> Lambdanaut: my advice to you is to abandon that goal
20:20:43 <edwardk> it doesn't end well
20:21:25 * hackagebot hspec-expectations 0.6.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.6.1 (SimonHengel)
20:21:29 <Lambdanaut> okay. That's fine. Thanks
20:23:31 <trap_exit> hmm
20:23:36 <trap_exit> how do I add a Double and an Int and get a Double
20:23:39 <trap_exit> i.e. I want Double -> Int -> Double
20:23:41 <trap_exit> but I can't use +
20:24:19 <Darien> + and fromIntegral
20:25:01 <Lambdanaut> It works for me without using fromIntegral
20:25:24 <Lambdanaut> oh wait not, scratch that. It's needed.
20:25:44 <Darien> @pl (\x y -> x + fromIntegral y)
20:25:44 <lambdabot> (. fromIntegral) . (+)
20:30:50 <solidus-river> interesting, it looks like after my ghc 7.8 upgrade my mod-ghc is no longer running within a cabal sandbox
20:31:26 * hackagebot hspec 1.11.3 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.11.3 (SimonHengel)
20:31:28 * hackagebot hspec-meta 1.11.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.3 (SimonHengel)
20:32:18 <solidus-river> re-initing the sandbox fixed it
20:36:27 * hackagebot hspec2 0.4.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.4.1 (SimonHengel)
20:39:45 <dfeuer> Is there a name for what you get if you abstract the multiplication out of exponentiation by squaring?
20:42:51 <Darien> If not I'll dub it Fred?
20:43:42 <shachaf> Abstracted multiplication is called "multiplication".
20:47:44 <dfeuer> shachaf: I'm talking about a function like  expby _ _ 0 = 1; expby _ x 1 = x; expby (*) x (n::Int) = expby (*) (x*x) (n `quot` 2) * if n `rem` 2 == 0 then 1 else x
20:48:09 <shachaf> Yes.
20:48:10 <glguy_> If there is an answer it's likely to be http://en.m.wikipedia.org/wiki/Exponentiation_by_squaring
20:48:33 <shachaf> :t Data.Semigroup.times1p
20:48:34 <lambdabot> (Data.Semigroup.Semigroup a, Numeric.Natural.Internal.Whole n) => n -> a -> a
20:49:02 <dfeuer> shachaf: aha!
20:49:14 <dfeuer> I think that's probably the right idea.
20:49:24 <shachaf> newtype Foo a = Foo { unFoo :: a }; instance Monoid a => Num (Foo a) where Foo x * Foo yf = Foo (x <> y); fromInteger 1 = Foo mempty; timesN n = unFoo . (^ n) . Foo
20:51:44 <dfeuer> But yes, you're right, monoid and not semigroup.
20:52:31 <trap_exit> there's three stages of monads: (1) not understanding monad tutorials, (2) reading the types of monads to actually understand them, and (3) realizing that everything is a monad
20:52:41 <dfeuer> Er... I think. I may need that generality, but it's unfortunate.
20:52:57 <glguy_> There got to be a step 4 involving irc
20:56:31 <joelteon> step 4 is where you post in IRC explaining about how you finally understand monads
20:56:36 <joelteon> see step 1
20:57:00 <joelteon> people need to stop making such a big deal out of monads. I never see "Applicative tutorials"
20:59:11 <BMeph> step 5 ???
20:59:31 <ion> Way less than “everything” are monads.
20:59:48 <trap_exit> glguy: well, the problem now is that ever time I see a -> (a, s)
20:59:50 <trap_exit> it's like hmm, that is a state monad
20:59:54 <joelteon> if haskell hadn't introduced special syntax specifically for monads, none of this would ever have happened
20:59:56 <trap_exit> err, s -> (a, s)
21:00:19 <trap_exit> it's all haskell's fault
21:00:23 <ion> joelteon: I’m glad to have the do notation. I’ll be even more happy when it only results in a Functor/Applicative constraint when possible.
21:00:33 <joelteon> 7.10, right?
21:00:44 <ion> Nope AFAIK
21:00:48 <isaacd> Is there currently a lib to conveniently apply SipHash to haskell types? hashable used to be that lib but then it ditched siphash for a faster hash
21:02:16 <dfeuer> shachaf: unfortunately, Cartesian product doesn't have a "true" identity element, although the Cartesian product by a singleton is isomorphic to the original.
21:02:19 <dfeuer> Feh.
21:02:35 <shachaf> ?
21:03:25 <isaacd> siphash only has a way to apply to ByteStrings. So alternately is there a class somewhere for converting haskell types to bytestrings efficiently? Storable maybe?
21:05:23 <joelteon> what do you want to hash that isn't a bytestring?
21:05:37 <isaacd> Int
21:05:41 <isaacd> or similar type
21:05:59 <joelteon> a number?
21:06:05 <isaacd> And types that contain ints, etc
21:06:16 <isaacd> I'm using siphash to create unique identifiers for things
21:07:10 <isaacd> I suppose I need a serialization lib- is "binary" the lib I want for that?
21:09:16 <isaacd> cereal perhaps- " Similar to binary in performance, but uses a strict ByteString instead of a lazy ByteString, thus restricting it to operating on finite inputs."
21:11:36 <glguy_> Cereal doesn't do anything fancier than binary or bytestring builder
21:12:14 <glguy_> And existed before binary was improved with incremental parsing . it's unnecessary note
21:12:23 <glguy_> Now*
21:13:13 <merijn> glguy_: Not really
21:13:24 <merijn> glguy_: Binary still only does lazy bytestring serialisation
21:13:48 <merijn> glguy_: There were plans to merge cereal's strict bytestring serialisation into binary, but afaik that hasn't happened yet
21:14:51 <solidus-river> http://lpaste.net/109220
21:15:01 <glguy_> No, binary has a strict incremental interface now
21:15:01 <solidus-river> trying to condence code into utility functions and failing
21:15:13 <solidus-river> if i dont use appendedStep and do all that manually its fine
21:15:24 <glguy_> Trevor said his plan is to deprecate cereal
21:16:34 <dolio> Good, that means bytes can be deprecated.
21:16:37 <dolio> Or is it bits?
21:17:07 <glguy_> We built it for a particular project a couple years ago parsing network packets. It served its purpose
21:17:32 <shachaf> Bits & Bytes™ Cereal
21:28:16 <Lambdanaut> If anyone knows of any article that explains how the " <- " operator works, could you link? Google doesn't allow searching on special chars like that.
21:28:46 <tabemann> what about it?
21:28:59 <Lambdanaut> I know how to use it, but am curious of how it seems to know what values to pull out of a monad
21:29:05 <geekosaur> (1) try symbolhound (2) the official story is in the Haskell Online Report; you can also play with @undo in lambdabot
21:29:06 <glguy__> The search term is "do notation"
21:29:14 <Hafydd> Lambdanaut: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 and http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
21:29:23 <geekosaur> and (3) what glguy__ said
21:29:26 <tabemann> x <- y ... is simply y >>= (\x -> ...)
21:29:49 <Lambdanaut> okay thanks tabemann, haha yeah that's what I was asking
21:31:00 <isaacd> glguy__: well, if you can show me how to use binary to create a strict ByteString (the sort that the siphash package requires) without creating an intermediate lazy one, I'll use it
21:31:42 <isaacd> cereal's 'encode' does that very directly
21:31:51 <glguy__> cereal doesn't do anything to help make a strict byte string other than to call 'toStrict" at the end
21:31:58 <isaacd> oh okay
21:32:14 <isaacd> so I could use binary with toStrict
21:32:18 <isaacd> for future-proofing
21:32:47 <tabemann> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful < the second thing that comes up when searching on Google for "do notation"
21:33:01 <tac-tics_> tabemann, heh...
21:38:25 * tabemann wonders how common it is to do imperative programming in Haskell when functional programming would be possible
21:40:50 <isaacd> glguy__: where is the strict incremental interface for binary, out of curiosity?
21:41:46 <glguy__> It's all in the same module : http://hackage.haskell.org/package/binary-0.7.2.1/docs/Data-Binary-Get.html#v:runGetIncremental
21:51:15 * tabemann had to buy a book on Groovy because he's starting a new job that uses it next week
21:51:54 * sclv extends condolences
21:52:21 <benzrf> ;-;
21:52:32 <benzrf> from what i recall of groovy its much like roovy
21:52:34 <benzrf> i mean ruby
21:52:49 <gcganley> is it better to read the paper a subject is based on or a tutorial written by a user
21:53:04 <benzrf> gcganley: on what
21:53:09 <gcganley> such as applicative functors
21:53:30 <benzrf> latter almost def
21:53:43 <shachaf> Better to read the paper, if those are your two options and you don't know anything about the latter.
21:54:17 <gcganley> because i have a slew of papers on my ipad i read them every so often
21:54:36 <shachaf> A lot of "tutorials" are quite terrible, written by people who don't understand the topic or how to explain it.
21:54:46 <gcganley> and sometimes i get it and its great but kost of the time its very confusing
21:54:50 <shachaf> With the paper you have at most one of those issues.
21:55:25 <gcganley> shachaf: like how everyone has a monad tutorial?
21:55:44 <shachaf> Yes. Like that.
21:56:02 <salohcin> if anyone has a second to look at this error I will be very grateful. I have been googling this the past few days and can't figure it out for the life of me.  I want to use Juicy Pixels to create a png image for a raytracer: http://pastie.org/9463770
21:56:10 <glguy__> gcganley: Have you seen this yet? http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
21:57:58 <gcganley> glguy__: no... whats the paper about (besides beyond the title of iterators of course)
21:58:23 <gcganley> wow i just said besides beyond sorry about that
21:59:43 <glguy__> gcganley: Check out the abstract. If you have questions about what the abstract means I can either help or suggest you read the rest :)
22:02:12 <gcganley> glguy__: interesting stuff... so its a paper on language design?
22:02:42 <gcganley> glguy__: well more language practices
22:03:09 <trap_exit> there's this fundamental link between moands and laziness
22:03:12 <trap_exit> both are about building up computations
22:03:14 <trap_exit> to be excuted later
22:03:28 <glguy__> I'd describe it as showing how Applicatives and Traversables capture a lot of patterns that would traditionally be called iteration
22:03:29 <trap_exit> so when I build up a monad, i'm not executing code, I'm building up a computation
22:03:33 <trap_exit> and at some later point, we're like "run this computation"
22:03:59 <Hafydd> Sometimes it builds up so much that it bursts at a seam known as "unsafePerformIO".
22:05:06 <glguy__> trap_exit: I think that's mostly just laziness happening there. You could also write "When I build up an Int I'm not executing code ... and at some point later ..."
22:05:26 <trap_exit> glguy__ : hmm
22:05:51 <trap_exit> glguy__ : but can you "run" the Int twice?
22:05:58 <trap_exit> I feel like there's something different going on with Monads
22:06:08 <trap_exit> since after I build a MOnad, it's not just I executed it once
22:06:13 <Hafydd> > let int=1 in (int, int)
22:06:14 <lambdabot>  (1,1)
22:06:15 <glguy__> > [1,2] >>= \x -> [x,x*2]
22:06:17 <lambdabot>  [1,2,2,4]
22:06:17 <trap_exit> but I can excute it 0 times, 1 time, 2 times, or 1 time + some other shit + re-execute the monad
22:06:59 <trap_exit> Hafydd : hmm, good things I did not write a new monad tutorial titled "monad is like laziness"
22:07:21 <Hafydd> trap_exit: yes, good thing you took a lazy approach to writing such a tutorial.
22:07:26 <glguy__> trap_exit: Can you relate the distinction that you're seeing to the code I wrote above?
22:08:05 <trap_exit> hmm
22:08:07 <glguy__> or
22:08:20 <trap_exit> glguy__ I guess what I'm actually thinking is "monads are like thunks"
22:08:30 <trap_exit> rather than "monads are like laziness"
22:08:54 <sclv> in my mind applicatives are like "data with extra structure"
22:09:12 <sclv> for a sufficiently developed notion of structure
22:09:49 <sclv> and the key neatness of them is they have two forms of well behaved composition
22:10:19 <sclv> Compose f g a = Compose (f (g a)) and Pair f g a = Pair (f a, g a)
22:11:00 <sclv> so the "structure" is well behaved and "noninterfering"
22:14:33 <linman32> i have an ambiguous occurence error
22:14:34 <linman32> http://pastebin.com/JgsQfFxz
22:14:48 <linman32> anyone know how to solve this?
22:15:33 <tac-tics> In cabal, if the .cabal file defines a flag, how do you pass a value in for that flag?
22:17:05 <glguy__> tac-tics: run "cabal install --help | less" and look for the string "flags"
22:17:14 <glguy__> they describe the format
22:22:42 <tac-tics> ah, apparently you can't pass flags with -f to build....
22:26:43 <glguy__> If you're using the configure/build/copy/register sequence the flags go to configure, If you're using install on its own, the flags go on install
22:31:17 <honza> Could someone help me understand what the args are in this function?  http://lpaste.net/109222
22:31:26 <tac-tics> hm
22:31:34 <honza> i see 2 args (2 fns) and one return value
22:31:35 <tac-tics> oh well, I'll just tweak the settings manually for now I guess
22:31:38 <tac-tics> bed time
22:31:44 <glguy__> honza: -> is "right-associative"
22:31:55 <glguy__> so     a->b->c    is     a->(b->c)
22:32:31 <glguy__> honza: In Haskell a function always takes one argument
22:34:19 <kadoban> honza: If it helps, look at the last line in that automatic suggestion in your paste. It shows an equivalent reading of the function type
22:35:41 <honza> ah, it doesn't need the brackets because it's right assoc
22:35:53 <honza> so confusing
22:36:02 <honza> i think i get it, thanks!
22:36:08 <glguy__> The brackets are just there to emphasize the "transducer" part of the type
22:37:39 <glguy__> > let sum xs = foldr (\x rec acc -> rec $! acc+x) id xs 0 in sum [1..10]
22:37:40 <lambdabot>  55
22:41:43 * hackagebot protobuf 0.2.0.3 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.0.3 (NathanHowell)
22:42:02 <joelteon> oh nice
22:45:02 <honza> glguy__: love that you recognized that immediately; i guess it's been all over lately
22:46:13 <adas> glguy__: how does that work?
22:47:19 <glguy__> adas: which part?
22:47:38 <adas> whats the 0 at the end?
22:48:05 <adas> at the end of the definition of sum
22:48:47 <glguy__> > let sum xs = foldr (\x rec acc -> rec $! acc+x) id xs z in sum [a,b,c,d]
22:48:48 <lambdabot>  z + a + b + c + d
22:48:57 <glguy__> It's the zero element, the starting value of acc
22:49:47 <glguy__> :t (\x rec acc -> rec $! acc+x)
22:49:48 <lambdabot> Num a => a -> (a -> b) -> a -> b
22:49:51 <glguy__> :t foldr (\x rec acc -> rec $! acc+x)
22:49:52 <lambdabot> Num a => (a -> b) -> [a] -> a -> b
22:50:47 <glguy__> adas: It's worth spending some time in GHCi looking at the types of the components of that expression if you haven't seen that shape before
22:51:02 <adas> glguy__: yup. doing that
22:52:41 <blaenk> is there a way to only build the docs from a ghc source distribution? in particular, the html ones?
22:52:56 <blaenk> I'm aware they're available online. this is to see if I can modify/patch and contribute to them
22:58:35 <glguy__> blaenk: Have you read https://ghc.haskell.org/trac/ghc/wiki/Building yet?
22:59:08 <blaenk> been looking at some pages from it, but I guess I'm missing the relevant parts
22:59:27 <glguy__> Look or "Building the documentation"
23:00:01 <blaenk> psh, thanks, I was looking at another page that shows the dependencies for building documentation ;)
23:01:46 * hackagebot lzma-conduit 1.1.0 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-1.1.0 (NathanHowell)
23:06:16 <benzrf> bye
23:14:05 <blaenk> glguy: you have any idea what these errors are about? https://gist.github.com/blaenk/0c48edccd7694fbf1304
23:14:21 <blaenk> I ran the command stated in the page you mentioned: make stage=0 FAST=YES
23:14:26 <blaenk> I have the build deps
23:15:51 <blaenk> er, make stage=0 FAST=YES
23:15:57 <blaenk> egh, make html stage=0 FAST=YES
23:16:47 <glguy> The easiest way will probably be to actually build GHC first to get the depend for generated
23:17:03 <blaenk> heh, what a pain. I just want to build the docs ;_;
23:17:07 <blaenk> but I'll give that a try glguy, thanks
23:17:13 <glguy> Or to do some research to figure out what target makes them
23:17:19 <blaenk> alright
23:26:26 <CmdrMoozy> i'm learning to use the composition and application operators (. and $); say i have a list x, is there some cleaner way to express x !! (length x - 2) by using these operators?
23:26:43 <CmdrMoozy> it's not clear to me how the syntax works in the case of functions that take arguments on either side of them, like == or + or etc
23:28:12 <ReinH> CmdrMoozy: not really
23:28:17 <Iceland_jack> 'x !! (length x - 2)' is good
23:28:38 <ReinH> (.) would be needlessly complicated:
23:28:43 <ReinH> @pl \x -> x !! (length x - 2)
23:28:43 <lambdabot> ap (!!) (subtract 2 . length)
23:28:51 <ReinH> actually not that bad
23:28:58 <ReinH> but not very idiomatic or easy to real
23:29:08 <ReinH> *read
23:29:31 <CmdrMoozy> fair enough - thanks :)
23:29:55 <ReinH> CmdrMoozy: you already use function application all over the place: it's the space character ;)
23:30:08 <ReinH> f $ a = f a
23:30:22 <ReinH> ($) just has a much lower precedence
23:32:27 <CmdrMoozy> so `f . g $ x` is equivalent to `f . g x`? the former just being a bit more clear about what's being done?
23:32:33 <Iceland_jack> no
23:32:42 <Iceland_jack> (f . g $ x) is (f (g x))
23:33:10 <CmdrMoozy> and f . g x is f(g)(x)?
23:33:32 <Iceland_jack> 'f . g x' is a function
23:33:40 <Iceland_jack> It would be equal to
23:33:40 <Iceland_jack>     \y -> f (g x y)
23:34:06 <Iceland_jack> @unpl f . g x
23:34:06 <lambdabot> (\ c -> f (g x c))
23:34:50 <Iceland_jack> CmdrMoozy: consider
23:34:50 <Iceland_jack> @ty length . take 3
23:34:51 <lambdabot> [a] -> Int
23:35:25 <Iceland_jack>       (length . take 3) "hello"
23:35:25 <Iceland_jack>     = length (take 3 "hello")
23:35:25 <Iceland_jack>     = length "hel"
23:35:25 <Iceland_jack>     = 3
23:36:04 <CmdrMoozy> i see
23:36:13 <Iceland_jack> @src (.)
23:36:13 <lambdabot> (f . g) x = f (g x)
23:36:35 <Iceland_jack> It could also be defined as
23:36:35 <Iceland_jack>     f . g = \x -> f (g x)
23:36:35 <Iceland_jack> right
23:36:58 <Iceland_jack> so when 'f = length' and 'g = take 3' you get the situation above
23:37:35 <Iceland_jack> It may be confusing since 'take 3' is a function application
23:39:55 <CmdrMoozy> ah i was forgetting that in lambda syntax e.g. `\x` is naming the first parameter `x`, not the function itself `x` - this is all much less confusing now heh
23:42:19 <linman32> setup: The pkg-config package 'libglade-2.0' version >=2.0.0 is required but it could not be found.
23:42:26 <linman32> anyone able to help w/ that error?
23:43:15 <pavonia> Do you have that package installed?
23:43:18 <CmdrMoozy> Iceland_jack, ah, i see the difference; I need more practice before it seems trivial though :)
23:43:26 <CmdrMoozy> Iceland_jack, thanks so much for the in-depth explanation!
23:45:15 <linman32> pavonia: no, libglade-2.0 does not seem to be installed
23:45:29 <Iceland_jack> No problem CmdrMoozy, the trick is just to add parentheses around function applications
23:45:29 <Iceland_jack>     length . take 3 ==> length . (take 3)
23:45:29 <Iceland_jack> and then apply the definitions which I hope you'll agree are quite simple
23:45:33 <Iceland_jack> @src ($)
23:45:33 <lambdabot> f $ x = f x
23:45:34 <Iceland_jack> @src (.)
23:45:35 <lambdabot> (f . g) x = f (g x)
23:45:43 <Iceland_jack> And that's all :)
23:45:47 <pavonia> linman32: Well, then ... :p
23:45:52 <glguy> It is a C library you have to install outside of Haskell
23:46:09 <linman32> pavonia: it says there is no package named 'libglade'
23:46:17 <linman32> pavonia: and i ran cabal update
23:46:30 <pavonia> See what glguy said
23:46:30 <CmdrMoozy> linman32, glade is not a haskell package
23:47:00 <CmdrMoozy> linman32, i think you need "apt-get install glade" or "yum install glade" or whatever package manager you use
23:47:22 <glguy> You've picked one of the most challenging build projects you could have :)
23:48:46 <linman32> CmdrMoozy: thanks
23:48:51 <linman32> glguy: what do you mean?
23:49:19 <glguy> Gtk and all of its dependencies
23:49:24 <pavonia> Building gtk on Windows is really tough
23:49:59 <linman32> glguy: is Gtk a good gui route for haskell?
23:50:06 <xintron> I'm using cabal sandbox for my projects but is there some way to specify the output binary when running `cabal build` (instead of having it under dist/build/foo/foo)?
23:53:08 <glguy> I don't know if there is a good route, I don't have experience with non web browser guis in Haskell
23:53:49 <glguy> Maybe someone else can weigh in
23:56:52 * hackagebot LambdaHack 0.4.99.0 - A game engine library for roguelike dungeon crawlers  http://hackage.haskell.org/package/LambdaHack-0.4.99.0 (MikolajKonarski)
23:56:54 * hackagebot Allure 0.4.99.0 - Near-future Sci-Fi roguelike and tactical squad game  http://hackage.haskell.org/package/Allure-0.4.99.0 (MikolajKonarski)
23:57:20 <CmdrMoozy> I can say that I personally dislike using GTK+ in C, but i'm not sure what that says about its Haskell interface
23:57:53 <CmdrMoozy> if it was me, I would probably pick one of the high-level maintained libaries listed here: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level and see how I liked it
23:58:19 <kadoban> The options for GUIs in haskell seem really limited whenever I've looked. GTK seemed like one of the few decent options
23:59:26 <CmdrMoozy> i am a huge haskell noob, but it seems like it would be hard to have a very pure GUI library; i might also consider just calling haskell code from C or C++ and writing a GUI in that language
