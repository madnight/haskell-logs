00:07:35 <frerich> dfeuer : Hi, do you happen to have a blog or something where you keep a log of your efforts to improve the 'fusability' of various standard Prelude functions? I've followed your -libraries posts over the last couple of weeks and it seems like a really interesting exercise to consider functions for whether they fuse well, but it's still not clear to me how you can tell whether something like e.g. 'foldr' is better for fusing than 'foldr1'.
00:07:46 * hackagebot ekg 0.4.0.2 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.2 (JohanTibell)
00:07:46 * hackagebot debian-build 0.2.1.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.2.1.1 (KeiHibino)
00:09:18 <dfeuer> No, frerich, I don't. As for foldr1, I suggest you try coming up with a fusion rule for foldr1/build. Or a way to write foldr1 in terms of foldr. If I'm remembering correctly, it *can* be done, but it's REALLY not pretty, and leads to other intermediate structures.
00:09:48 <dfeuer> One thing that's really valuable is trying something, and then reading through the Core that GHC produces to see how it was compiled.
00:15:02 <frerich> dfeuer: Seeing SPJ's last mail, it seems I'm not the only one who'd be interested to learn what 'fusing' functions means exactly, how to tell whether a function fuses well and how to make a function fuse well.
00:17:42 * hackagebot influxdb 0.6.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.6.0 (MitsutoshiAoe)
00:48:21 <wz1000> Is there any difference(performance, memory usage or otherwise) between 'main = do {t <- bar; putStrLn $ f t; main}' and 'main = f `liftM` bar >>= putStrLn >> main'
01:07:42 <frerich> wz1000 : I'd hope there's no significant difference. Instead of using 'liftM' you could just use 'main = bar >>= putStrLn . f >> main' by the way.
01:08:39 <frerich> For some reason it seems that when I see a "lift" of some sort, there's usually a nicer way to write things.
01:08:42 <adas> did we just have a netsplit
01:09:04 <furrykef> I don't see one.
01:11:38 <wz1000> frerich: Won't there be memory leaks with the 'do' version? The reference to 't' is kept during the recursive call.
01:17:28 <mjrosenb> wz1000: I don't think it will hold on to the reference.
01:20:27 * dfeuer wonders if oleo is actually oily.
01:21:20 <oleo> in a sense.....
01:21:28 <oleo> lol
01:21:49 <dfeuer> Well, I suppose everyone is to some extent.
01:26:47 <dfeuer> Compiling GHC brings my CPU up to around 90C. Should I be concerned?
01:27:04 <dfeuer> Er... 92 now.
01:27:21 <zomg> Sounds like maybe it's time for some dust cleaning :P
01:27:35 <mjrosenb> dfeuer: I think my hw caps are aroud 98C
01:27:43 <dfeuer> zomg, I did one not too long ago. It's a laptop though, and not top of the line...
01:28:10 <mjrosenb> dfeuer: modern processors are pretty good about shutting down before they get damaged
01:28:25 <mjrosenb> dfeuer: your file system may not appreciate it, but you have journaling enabled, right?
01:28:40 <dfeuer> Yes, ext4.
01:28:59 <dfeuer> Darn well better have journaling... I'm on an encrypted /home.
01:29:21 * dfeuer does not want to think about what will happen if that gets scrambled.
01:29:30 <zomg> dfeuer: ah, yeah laptops aren't always too good with heat I've noticed, even the temperature in the room you are can affect their ability to dissipate heat properly :P
01:30:02 <dfeuer> zomg, that is a property of *all* things that dissipate heat.
01:30:25 <mjrosenb> dfeuer: if you are using multiple cores, you can almost certainly lower the temperature by running with fewer cores.
01:30:32 <zomg> dfeuer: Well I mean laptops can be particularly finicky about it, more so than desktops
01:30:41 <dfeuer> mjrosenb, yeah, I thought about that.
01:30:52 <dfeuer> But -j4 is slow enough!
01:32:18 * dfeuer hopes GHC will give me a new fan when this one dies.
01:32:57 <wz1000> dfeuer: Check your thermal paste
01:33:28 <dfeuer> wz1000, you can't check that without destroying it!
01:34:04 <wz1000> dfeuer: So replace it. It isn't too expensive, and your computer will thank you.
01:34:20 <dfeuer> And I hate taking apart laptops. So many screws; so much to keep track of.
01:36:00 <ion> dfeuer: Follow the official repair manual.
01:36:15 <dfeuer> This is getting very off topic.Sorry.
01:36:16 <wz1000> dfeuer: I knew someone who used to use a magnet for that. He dropped it on his motherboard. RIP
01:36:26 <ion> And put each set of screws into a zip-lock bag with a title.
01:36:40 <dfeuer> Screws need a map. A sticky map.
01:36:43 <dfeuer> Or something.
01:37:22 <dfeuer> Are there Haskell libraries with screws and nuts and bolts?
01:37:53 * hackagebot rawstring-qm 0.1.5 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.1.5 (tolysz)
01:37:56 <wz1000> dfeuer: I think that would be covered under the IO monad.
01:38:07 <prophile> no, though if you're interested in lenses, bananas, envelopes and barbed wire you're covered
01:39:43 <pqmodn> @pl (\a b -> max (fst a) b)
01:39:44 <lambdabot> max . fst
01:39:58 <wz1000> Is there any term for types that can be fully represented using haskell syntax?
01:40:21 <prophile> what do you mean by that?
01:40:41 <dfeuer> > fireRailGunAt myBoss
01:40:44 <lambdabot>  "dfeuer's boss is killed by a ridiculously energetic projectile."
01:40:52 <latk> I have just discovered that ('9' + 4) * 3 not only works in javascript, but gives 282. What am I doing writing this shit :(
01:41:27 <prophile> latk: I assume you've seen the []+[]/{}+[] examples?
01:41:55 <shiona> in case not: https://www.destroyallsoftware.com/talks/wat
01:41:58 <latk> prophile: I have seen almost no javascript
01:42:05 <prophile> in javascript, []+[] is the empty string, []+{} is the string '[object Object]', {}+[] is 0 and {}+{} is NaN
01:42:09 <latk> and am thankful for my previous ignorance
01:42:09 <dfeuer> wz1000, I think they're called "Haskell types" but I could be wrong.
01:42:45 <shiona> also javascript (==) is .. interesting
01:42:59 <prophile> shiona: it is symmetric!
01:43:09 <dfeuer> This one's a classic: http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
01:43:10 <shiona> and if(x) is not the same as if(x == true)
01:43:11 <prophile> it may not be transitive or even reflexive but one out of three ain't bad
01:43:12 <mjrosenb> shiona: /javascript/ is interesting.
01:43:13 <wz1000> prophile: I mean that any type such that its of their haskell instances are valid members of itself. Eg: you can represent list type, but not list type that can only have a even length
01:43:36 <latk> shiona: Haven't seen that before, watching now. I need to escape this horror.
01:43:40 <mjrosenb> prophile: == not being reflexive is common.
01:43:41 <prophile> data EvenList a = Cons a a (EvenList a) | Nil
01:43:54 <prophile> mjrosenb: unfortunately so, that doesn't make it any less ridiculous
01:44:26 <mjrosenb> > (0.0 / 0.0) == (0.0 / 0.0)
01:44:28 <lambdabot>  False
01:44:35 <prophile> indeed
01:44:46 <prophile> the fine work of the IEEE :/
01:45:03 <wz1000> prophile: OK, what about a type in which all strings that fit the regular expression syntax for emails are a member.
01:45:19 <mjrosenb> also,
01:45:24 <mjrosenb> > 0.0 == - 0.0
01:45:26 <lambdabot>  True
01:45:51 <prophile> mjrosenb: that still makes sense in an equivalence relation
01:45:53 <shiona> mjrosenb: huh, didn't know they spec'd that to be true
01:46:06 <mjrosenb> shiona: yes.
01:46:10 <prophile> wz1000: it's tenuous to use a regex for emails but I take your point
01:46:12 <mjrosenb> -- so much angst there.
01:46:27 <prophile> dfeuer was probably right with "haskell types"
01:46:56 <prophile> floating point makes me a sad programmer :(
01:47:09 <mjrosenb> > -0.0 < 0.0
01:47:10 <lambdabot>  False
01:47:48 <dfeuer> > -0.0 == 0.0
01:47:50 <lambdabot>  True
01:47:53 <prophile> I think you probably could translate a regex into the type system actually
01:48:10 <shiona> prophile: I'm not sure about a sad programmer, maybe sad mathematicist (is that a word?)
01:48:26 <mjrosenb> shiona: mathematician?
01:48:34 <shiona> ah, of course
01:48:47 <prophile> <.> => Char, <letter> => (), <a | b> => Either <a> <b>, <a b> => (<a>, <b>), <a*> => [<a>]
01:48:55 <prophile> so you could enforce a regex at the type level
01:48:56 <wz1000> prophile: How? Also, what about a set type. That is impossible to write using only the type system
01:49:12 <prophile> indeed
01:49:31 <prophile> well
01:49:35 <prophile> actually, no
01:49:41 <prophile> a set of a is isomorphic to a -> Bool
01:50:13 <prophile> though that does rule out most useful operations on sets
01:50:54 <mjrosenb> prophile: what does it rule out?
01:51:10 <mjrosenb> it certainly doesn't rule out intersection and union.
01:51:19 <prophile> indeed, but it does rule out iteration in sensible amounts of time
01:51:51 <prophile> (on that note though, if you make it a -> Any its monoid instance gives you union and a -> All has intersection)
01:51:52 <wz1000> prophile: Not if a is enumerable
01:52:02 <prophile> "in sensible amounts of time"
01:52:24 <mjrosenb> wz1000: if you're dealing with 64-bit integers, and have a set with INT_MIN and INT_MAX....
01:52:27 <prophile> iterating through, say, all Word64s in a Word64 -> Bool set
01:52:37 <prophile> yeah
01:53:26 <wz1000> prophile: What about a graph?
01:54:41 <prophile> probably a good example
01:55:07 <wz1000> I don't think that you can represent an undirected graph with no broken links using the type system.
01:56:17 <prophile> I wouldn't be surprised if there's some fiendish kmettian type hack which could do it
01:56:25 <prophile> but I can't think what it would be
01:56:47 <pavonia> Shouldn't you be able to represent everything you can represent at value level at the type level too?
01:57:23 <mjrosenb> a broken link being a a pair of vertices, a and b, such that (a,b) is in the graph, but (b,a) isn't?
01:58:15 <wz1000> a link (a,b) where any one or both of a and b are not nodes in the graph
01:59:24 <wz1000> I sometimes wish there was a way to do a subtraction of types in haskell
02:00:10 <prophile> I wish for dependent types quite often
02:01:01 <wz1000> Do any of agda, idris and the rest have haskell interop?
02:01:05 <trap_exit> dude
02:01:05 <trap_exit> so do I
02:01:08 <trap_exit> I want dependent types
02:01:12 <trap_exit> I want dependent types
02:01:15 <mjrosenb> wz1000: agda almost certainly does.
02:01:49 <trap_exit> what does "agda has haskell interop" mean ?
02:02:06 <mjrosenb> wz1000: presumably, you don't want to say "all possible values are 'in' the graph"?
02:02:12 <solatis> trap_exit: i would interpret that as 'you can use haskell libraries'
02:02:21 <trap_exit> damn
02:02:34 * trap_exit goes off to isntall agda
02:03:26 <solatis> funny, agda is even on hackage
02:03:32 <trap_exit> yeah
02:03:35 <trap_exit> the way to install agda, apparen ty is
02:03:37 <trap_exit> cabal install agda
02:03:41 <solatis> that's what they mean probably
02:03:49 <trap_exit> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.MacOSX
02:03:54 <solatis> just FFI for agda in a hackage package
02:04:03 <solatis> lame :)
02:04:05 <trap_exit> wtf is aquamacs
02:04:52 <solatis> trap_exit: emacs for submarines?
02:05:06 <oleo> emacs for mac/iOS ?
02:05:07 <notdan> emacs for osx
02:05:11 <oleo> ah
02:05:18 <oleo> so emacs for macs
02:05:19 <trap_exit> emacs for dolphins
02:05:29 <trap_exit> dolphins code in emacs
02:05:34 <solatis> in the case of emacs, whales are more likely
02:05:36 <solatis> *ducks*
02:05:50 <wz1000> Why do you need an OS when you have emacs?
02:05:52 <solatis> sorry too many puns in that sentence
02:06:06 <trap_exit> I've always used http://emacsformacosx.com/ ... but I guess agda likes aquamacs, so aquamacs it is
02:06:18 <trap_exit> wz1000 : becuase emacs doesn't ahve drivers yet
02:06:45 <notdan> you can use emacsforosx with agda as well, I am sure
02:07:06 <trap_exit> gentlemen, if agda is as easy to use as ahskell, and agda has dependent types
02:07:15 <trap_exit> then I may have to stop spamming this channel with my haskell questions
02:07:29 <notdan> OK
02:08:33 <solatis> damn, it looks like we have to make a port for emacs in agda
02:08:49 <solatis> i never heard about language that relied so heavily on a single editor
02:09:35 <wz1000> solatis: Try java without eclipse or intelliJ
02:09:42 <wz1000> :P
02:09:49 <solatis> i did. it's called scala.
02:10:08 <solatis> no but really, i did a lot of java dev in emacs
02:10:15 <solatis> i never had any problems with it
02:11:04 <dfeuer> solatis, a nicer alternative might be Frege, but it's still a little new.
02:18:54 <wz1000> Here is emacs as an OS: http://www.informatimago.com/linux/emacs-on-user-mode-linux.html
02:22:41 <wz1000> 1
02:22:43 <wz1000> j
02:23:06 <Testeree> build failure when "cabal install cabal-install" http://pastebin.com/gkDzkgZC
02:23:47 <Testeree> uname -a "local 13.3.0 Darwin Kernel Version 13.3.0: Tue Jun  3 21:27:35 PDT 2014; root:xnu-2422.110.17~1/RELEASE_X86_64 x86_64"
02:28:16 <Testeree> anybody there?
02:28:55 <pavonia> Does "ghc-pkg check" report any problems?
02:30:01 <Testeree> nope
02:31:38 <Testeree> problem solved after ghc-pkg recache :)
02:31:45 <Testeree> thanks btw.
02:32:02 <pavonia> Ah
03:00:21 <blakehaswell> Hey Henry_Jia_T60
03:03:02 * hackagebot interpolation 0.0 - piecewise linear and cubic Hermite interpolation  http://hackage.haskell.org/package/interpolation-0.0 (HenningThielemann)
03:03:03 <wz1000> Java and C++ people call proper functions functors. Wow
03:08:27 <shiona> wz1000: last time I heard of functors in C++ they were objects with operator(), not actual functions (as I understand it)
03:08:28 <spaceloop> Haskell people call Hask endofunctors functors ;)
03:09:28 <prophile> ML has some meaning for it
03:12:20 <wz1000> shiona: A proper function is a function that can be passed around. I consider the function as an object or "functor" to be a proper function in C++
03:13:44 <shiona> wz1000: ah. In practice you could just use function pointers.
03:14:42 <shiona> Unlike functions, c++ functors can have an internal state which to me makes it less of a 'real function'
03:18:18 <mjrosenb> shiona: constexpr function pointer!
03:18:23 <wz1000> shiona: So do regular c++ functions
03:19:02 <shiona> wz1000: hmm, true. Forgot about function static variables
03:19:38 <shiona> mjrosenb: Is that a thing? I've not even come to terms with c++11 let alone '14
03:20:03 <mjrosenb> shiona: it is from c++11.
03:20:35 <shiona> hmm
04:06:15 <_d0t> hi. Are there any centos6 repos with ghc 7.8.3?
04:08:11 * hackagebot conduit-extra 1.1.3.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.3.2 (MichaelSnoyman)
04:11:58 <jle`> I think even vanilla C has static function variables, doesn't it?
04:13:12 * hackagebot possible 0.1.0.0 - Three valued Data.Maybe  http://hackage.haskell.org/package/possible-0.1.0.0 (tolysz)
04:14:06 <mjrosenb> jle`: yes.
04:14:26 <mjrosenb> also, global state, in general, although that may not be verboten?
04:24:50 <bluebelle> Why does caseSensitive is defined False on Text.Parsec.Language javaStyle
04:28:13 * hackagebot monte-carlo 0.6.1 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.6.1 (PatrickPerry)
04:29:00 <hyPiRion> javaStyle should really be called algolStyle, I guess
04:33:05 <SwashBuckla> http://lpaste.net/109616 -- Could I use `interact` here instead of getLine; print.. etc?
04:33:34 <_d0t> SwashBuckla: yes
04:33:39 <SwashBuckla> how?
04:33:43 <SwashBuckla> what would I need to change?
04:33:58 <SwashBuckla> I've tried fiddling around with it -- it seems the type of interact
04:34:01 <SwashBuckla> :t interact
04:34:02 <lambdabot> (String -> String) -> IO ()
04:34:13 <SwashBuckla> expects a (String -> String) function
04:34:14 <_d0t> SwashBuckla: show.interact
04:34:17 <_d0t> like that
04:34:21 <_d0t> :t show . interact
04:34:22 <lambdabot> (String -> String) -> String
04:34:39 <_d0t> meh
04:34:44 <_d0t> show . solveRPN
04:34:48 <_d0t> sorry
04:34:51 <SwashBuckla> :P
04:35:08 <bluebelle> @hyPiRion so it should be sensitive right?
04:35:08 <lambdabot> Unknown command, try @list
04:36:01 <SwashBuckla> _d0t: so we want  interact (show . solveRPN)
04:36:11 <_d0t> yup
04:36:44 <_d0t> main = forever $ interact $ show . solveRPN
04:36:46 <_d0t> like that
04:40:15 <SwashBuckla> _d0t: so this does compile, but it does not behave the same as my paste
04:40:35 <SwashBuckla> it doesn't echo any results back to stdout
04:40:55 <_d0t> SwashBuckla: well, thats another issue %)
04:41:11 <simon> @pl \s n -> concat (replicate n s)
04:41:12 <lambdabot> (join .) . flip replicate
04:41:20 <simon> @pl \n s -> concat (replicate n s)
04:41:20 <lambdabot> (join .) . replicate
04:41:54 <nyuszika7h> what does "(join .)" mean?
04:41:55 <hyPiRion> bluebelle: for java, yes
04:41:58 <SwashBuckla> _d0t: yes, your version doesn't work
04:42:07 <SwashBuckla> my version does work
04:42:10 <nyuszika7h> I know about function composition but that lone '.' there, I don't get it
04:42:30 <_d0t> nyuszika7h: '.' is a function too
04:43:04 <spaceloop> nyuszika7h: join is a generalisation of concat, for any monad
04:43:07 <spaceloop> :t join
04:43:08 <lambdabot> Monad m => m (m a) -> m a
04:43:08 <{AS}> nyuszika7h: it is a section like (a +) representing (\c => a + c)
04:43:23 <{AS}> then (a .) represents (\c => a . c)
04:43:32 <{AS}> it is just a shortcut
04:43:38 <{AS}> err replace => with ->
04:43:44 <nyuszika7h> ah
04:44:28 <SwashBuckla> _d0t: they simply aren't doing the same thing
04:45:50 <_d0t> SwashBuckla: indeed. Probably interact is not what you're looking for then.
04:46:24 <SwashBuckla> based on the documentation, it is
04:46:28 <SwashBuckla> so why isn't it working?
04:46:33 <SwashBuckla> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:interact
04:47:01 <_d0t> SwashBuckla: The entire input from the standard input device is passed to this function as its argument
04:47:20 <_d0t> looks like its not divided into separate strings
04:47:24 <SwashBuckla> as opposed to getLine which gets 1 line at a time
04:47:28 <SwashBuckla> yea
04:47:30 <SwashBuckla> hmm
04:47:35 <_d0t> you should add lines
04:48:53 <_d0t> SwashBuckla: unlines . map (show . solveRPN) . lines
04:48:59 <_d0t> thats what goes into interact
04:49:39 <_d0t> SwashBuckla: main = forever . interact $ unlines . map (show . solveRPN) . lines
04:49:58 <sibr> Does using Codensity have any advantage over using ContT?
04:50:32 <_d0t> SwashBuckla: although forever is redundant there
04:51:14 <_d0t> SwashBuckla: http://bpaste.net/show/mkShpW3cvQrGQ52KlB2A/
04:52:26 <SwashBuckla> I need some EOFyes
04:52:30 <SwashBuckla> oops
04:52:42 <SwashBuckla> was just about to ass that forever is redundant, yeah :)
04:52:46 <SwashBuckla> ass?!
04:52:52 * SwashBuckla gives up typing
04:54:43 <sibr> I'm wondering whether the ability to use call/cc is useful in a parser monad
05:30:48 <spaceloop> is there a way to disable certain ghc language pragma's in a specific module?
05:34:33 <bergmark> spaceloop: i recommend only specifying pragmas within the files, otherwise you can't load the modules in ghci
05:35:01 <luite> cabal repl should still work
05:36:00 <spaceloop> bergmark: well, the point is, I would like some pragma's to be turned on by default in cabal repl, and like to specify this in .ghci file, but one specific module does not work well with this extension, so I want to turn it off there
05:37:02 <bergmark> i'm still using cabal-dev ;-(
05:37:05 <luite> spaceloop: you can do {-# LANGUAGE NoTypeFamilies #-} for example
05:37:46 <luite> but i probably woudn't do that myself in things i intend to upload to hackage
05:39:19 <angerman> Does cabal provide a way for me to build a shippable distribution archive that does not depend on external shared libraries?
05:39:52 <angerman> e.g. I want to create a binary to give a coworker, who will not be able to build the binary from source and all it's dependencies.
05:40:28 <luite> angerman: you can build a statically linkd executable with --disable-executable-dynamic, some non-haskell dynamic libs will remain, libgmp i think
05:40:59 <tv1> is there a name for (a -> m (a -> b) -> m b) ?
05:41:06 <angerman> luite, hmm...
05:41:45 <doismellburning> luite: <3
05:42:16 <luite> uh hello
05:42:20 <prophile> @pl \x -> liftM ($ x)
05:42:21 <lambdabot> fmap . flip id
05:42:26 <prophile> tv1: ^
05:42:43 <tv1> prophile: thanks!
05:42:45 <shiona> @hoogle a -> m (a -> b) -> m b
05:42:45 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:42:45 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:42:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:43:02 <spaceloop> luite: thanks!
06:08:27 * hackagebot aws-ec2 0.1 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.1 (VladimirKirillov)
06:32:55 <angerman> luite, i finally went with copying the required dylibs over, and creteing a wrapper .sh script that sets LD_LIBRARY_PATH
06:33:31 <angerman> luite, can I teach cabal about the construction, so it can create a distributable archive somehow?
06:34:18 <dcoutts_> angerman: are you talking about Haskell shared libs or C libs?
06:34:19 <angerman> luite: e.g.: copy these libs into a newly create subfolder libs, and create a shell file with the following content, then build a tar archive from it and zip it.
06:34:32 <angerman> dcoutts_: c libs
06:34:37 <dcoutts_> ah
06:34:42 <dcoutts_> that gets very tricky
06:35:39 <dcoutts_> angerman: it may work for simple cases, but you cannot in general relocate C libs
06:38:05 <dcoutts_> angerman: in general it's a hard problem, and very platform specific
06:38:16 <dcoutts_> not something we can trivially include into cabal
06:38:28 <dcoutts_> not if we want it to work in most cases
06:38:52 <dcoutts_> certainly it'd be useful, but it'll need more work and thought
06:41:09 <{AS}> Hi, does anyone know if there is a paper involving the UNPACK mechanism in Haskell?
06:41:23 <{AS}> I would like to know more about the background
06:41:33 <angerman> dcoutts_: oh it's same platform for me, so that's kinda easy. I was just wondering if there was a post build script I could specify.
06:43:31 * hackagebot hxt 9.3.1.5 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.5 (UweSchmidt)
06:43:46 <dcoutts_> {AS}: it's probably documented along with the stuff on unboxed types
06:44:20 <{AS}> dcoutts_: where is that?
06:44:20 <phaskell> No symbol 'that' found anywhere.
06:45:14 <dcoutts_> {AS}: I'm suggesting what to look for in papers, as you'll not find it by looking for UNPACK I think. I don't have a specific paper suggestion.
06:45:37 <dcoutts_> {AS}: but check the ghc dev wiki for links to papers, and it has quite a bit of documentation in the wiki itself
06:45:41 <{AS}> dcoutts_: Ah, thanks :)
06:45:50 <{AS}> dcoutts_: Yeah I think I found something interesting
06:46:14 <{AS}> * apparently I had done so before
06:46:18 <spaceloop> using mtl, what would be a nice way of logging (my Monad is a MonadWriter) thrown errors (my Monad is a MonadError), but not those that are caught? I would like to do this with WriterT, but I don't see how.
06:47:12 <dcoutts_> {AS}: it also helps to understand the normal data memory layout, to see how UNPACK changes things
06:49:25 <{AS}> dcoutts_: could you please elaborate?
06:50:02 <dcoutts_> {AS}: first make sure you understand the layout in memory of ordinary Haskell data objects
06:50:13 <{AS}> Ah
06:50:48 <dcoutts_> once you understand that, the UNPACK transformation is straightforward
06:51:48 <{AS}> dcoutts_: Yeah, I think I have an intuition :), I was just wondering if there was a paper so I could refer to it (and get things completely correct)
06:51:56 <{AS}> dcoutts_: In any case, thanks
06:52:36 <dcoutts_> {AS}: it may well be in one of the ghc papers, but I couldn't swear
06:52:49 <dcoutts_> certainly the unboxed type stuff is explained in some citable paper
06:53:34 <{AS}> dcoutts_: I found "Unboxed values as first class citizens in a non-strict functional language" by Peyton-Jones and Launchberry
06:53:54 <{AS}> Launchbury*
06:54:16 <dcoutts_> {AS}: sounds like one of the original ones
06:58:33 * hackagebot spice 0.1.0.1 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.1.0.1 (Crockeo)
07:08:34 * hackagebot spice 0.1.0.2 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.1.0.2 (Crockeo)
07:18:38 * hackagebot ehs 0.1.0.1 - embedded Haskell by using quasiquotes.  http://hackage.haskell.org/package/ehs-0.1.0.1 (minpou)
07:22:59 <preyalone> I'm trying to get type information in inf-haskell-mode, but when I do C-c C-t RET, inf-haskell-mode reports "Not in scope: String". I'm using Prelude defaults and everything.
07:23:39 * hackagebot diagrams-rasterific 0.1 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1 (bergey)
07:26:20 <preyalone> ah, ya have to manually C-c C-l to load the file first. lame.
07:27:54 <falsealarm> this may be a stupid question but whats the difference between a graph database like neo4j and happstack's acid-state?
07:28:39 * hackagebot spice 0.1.1.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.1.1.0 (Crockeo)
07:35:28 <preyalone> how can i get inferior-haskell-type to stop prompting me for confirmation each time? it's quite annoying.
07:58:44 * hackagebot Spock 0.6.3.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.3.0 (AlexanderThiemann)
08:07:20 <Rachael22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
08:07:42 * frerich sings the Monty Python "spam" song.
08:08:53 <oleo> grindell you!
08:12:17 <alpounet> thoughtpolice: hey! any reason hs-nacl isn't on hackage?
08:19:15 <thoughtpolice> alpounet: it needs a few tweaks, I keep getting pestered about it :)
08:19:36 <Fuuzetsu> carter: do you know the procedure for getting a package deleted on Hackage? There's a package up using a name I want to use and it is abandoned: uploaded in 2009, single version, only 76 uploads in 5 years, project since renamed and developed under completely different name
08:19:42 <thoughtpolice> orion has been doing great work on it, and I've wanted to get it done with. perhaps I can finish the remaining things this week since orion cleaned up after me
08:19:46 <Fuuzetsu> do I just try to get the author to agree?
08:21:24 <alpounet> thoughtpolice: hah :) well, I'm asking because of the interest in a haskell impl of Tox's core (that you've heard about, I've been told)
08:21:31 <alpounet> so the use case is the same i guess
08:21:54 <ezyang> Hey, is it still possible to download a tarball of all packages on HackagE?
08:22:32 <napping> ezyang: how about downloading all the tarballs individually?
08:22:44 <ezyang> bleh
08:23:15 <napping> I don't know of any easy way, but I imagine you could script up multiple downloads from 00-index.tgz without too much trouble
08:23:21 <luite> i think the tarball only contained the latest version of each?
08:24:00 <napping> also, isn't all of hackage getting to the point that a single compressed tar is a bit less random access than you'd like?
08:24:23 <luite> i only have a script that downloads all tar files, not just the latest versions
08:25:40 <ezyang> I only wantthe latest versions
08:26:55 <Fuuzetsu> I think it's like one POST to get the links
08:27:11 <Fuuzetsu> luite: got any patches for me?
08:28:15 <luite> Fuuzetsu: i've been testing the patch today with haddock-ghcjs, but i haven't tested it in the ghc tree yet
08:29:14 <Fuuzetsu> you don't really need to, we're out of the tree now
08:29:27 <Fuuzetsu> we just have to make sure it all works at 7.10 release time
08:29:41 <Fuuzetsu> or 7.8.4 or whatever
08:29:59 <bmuk> Hey everyone, is there an easy way to get an up to date haskell environment in ubuntu 14.04?
08:30:48 <clrnd> bmuk, this works for me http://new-www.haskell.org/downloads/linux
08:30:50 <danilo2> Hello! I've got an AST (abstract syntax tree) consisting of many datatypes. Each datatype has some constructors and fields of some types. I want to write a function which recursively applies a function to each field of given type. For example given simpel example: http://lpaste.net/109625 I want a function which will just apply a transformation (X->X) on each field of type X. Is there a way to make it general way? Using lenses or ot
08:31:15 <luite> Fuuzetsu: ok, I just need to review a few things then and add some comments to a module
08:31:19 <napping> bmuk: plus this: http://www.haskell.org/cabal/download.html
08:32:08 <bmuk> Okay thank you very much. I would use the platform but I would like the sandboxing feature in cabal
08:32:47 <barrucadu> danilo2: Pandoc does exactly that using Data.Generics - see pandoc-types
08:33:44 <enthropy> @type \f x -> everywhere (mkT f) x
08:33:45 <lambdabot> Not in scope: ‘everywhere’
08:33:45 <lambdabot> Not in scope: ‘mkT’
08:33:47 <danilo2> barrucadu: Oh, nice to know that! Anyway - generics is the only way to go? Cannot we just use lenses and some traversqals to do this? (I do not know lenses so well)
08:34:27 <barrucadu> danilo2: I don't really know lenses at all; there is quite possibly a way to do it
08:34:34 <enthropy> lens has a version of uniplate included which will use the same classes
08:34:43 <napping> bmuk: Doesn't installing haskell platform yourself give a reasonably recent cabal?
08:35:02 <napping> bmuk: I've just found it sufficiently easy to go without the platform on linux
08:35:46 <danilo2> enthropy, barrucadu: so maybe it would be possible with lenses. enthropy - have you got any further "hint" - any keyword, which would alow me to dig faster for the lens functionality I'm looking for?
08:35:49 <napping> I think the major benefit of the platform is on windows, to give you pre-built versions of binary dependencies that are otherwise a huge pain to build yourself
08:35:51 <bmuk> the one in the ubuntu repositories has cabal 1.6
08:36:14 <napping> bmuk: older than this one? https://www.haskell.org/platform/
08:36:19 <bmuk> napping: my use case is inside of vagrant boxes
08:36:25 <enthropy> danilo2: I would just use use the " \f x -> everywhere (mkT f) ", which is Data.Generics (syb)
08:36:52 <Fuuzetsu> lost an ‘x’ there
08:37:02 <napping> hmm, newest platform has cabal-install 1.18
08:37:09 <bmuk> I believe so - I have ghc 7.6.3
08:37:19 <enthropy> @let import Data.Generics
08:37:20 <lambdabot>  .L.hs:80:1:
08:37:20 <lambdabot>      Data.Generics: Can't be safely imported!
08:37:20 <lambdabot>      The module itself isn't safe.
08:37:28 <napping> I don't know if that does sandboxes
08:38:02 <danilo2> enthropy: Ahh, now I understand your first answer. Thnak you. I would use it - anyway if anybody knows anything simmilar in lens I would prefer it, because I'm using lenses in other places to, so I would like not to use syb if I do not have to :)
08:38:02 <bmuk> 1.18 does have sandboxes
08:38:02 <Fuuzetsu> sandboxes were added with 1.18
08:38:26 <enthropy> danilo2: "tinplate" or similar functions
08:38:34 <napping> bmuk: okay, then downloading the latest platform should work too
08:38:39 <danilo2> enthropy: thank you very much! :)
08:38:48 <napping> I don't know what vagrant requires, sounds interesting
08:39:32 <bmuk> I just need an automated way to install it (I could obviously write the script myself) so it will play nice with the vagrant workflow (usually just a bootstrap.sh run on a fresh vm image every time you want to work)
08:40:22 <bmuk> I think it will help prevent cabal hell, probably not as well as nix-os, but I couldn't seem to boot nix-os off of a usb
08:40:40 <Fuuzetsu> you should be able to boot NixOS off a USB
08:40:50 <napping> bmuk: cabal sandboxes alone seem pretty reliable at avoiding dependency trouble
08:41:04 <Fuuzetsu> problem with cabal sandboxes is that sharing is a pain in the ass
08:41:14 <napping> "sharing"?
08:41:22 <bmuk> Fuuzetsu: unetbootin gave me a blinking cursor :/
08:41:26 <monochrom> bmuk: have you read https://www.haskell.org/platform/linux.html#binary ?
08:41:39 <Fuuzetsu> yes, say two different sandboxes use lens, you'll usually build lens twice in this scenario
08:41:50 <napping> ah, you mean not sharing
08:41:51 <Fuuzetsu> you can create a lens sandbox and add source but doing this for every dep is tedious
08:41:55 <napping> yeah, it's a bit annoying
08:42:10 <Fuuzetsu> also if you then want to change lens version in one sandbox and not the other, good luck
08:42:27 <Fuuzetsu> but with nix this is done automatically so it's great
08:42:29 <napping> but if you're willing to spin up virtual machines to avoid tangled dependencies, some recompilation is presumably tolerable
08:42:43 <Fuuzetsu> bmuk: I had success with unetbootin
08:42:56 <napping> bmuk: only for dependencies, or are you using machine images for other stuff too?
08:43:03 <Fuuzetsu> just have to format the stick right before using it or it gets upset
08:43:46 <bmuk> Fuuzetsu: it may have been the system I installed it on - my arch install got borked somehow so I tried to switch to nixos, gave up after the unetbootin and dd didn't work, went to ubuntu
08:44:07 <napping> The next GHC should be able to share built packages nicely
08:44:15 <Fuuzetsu> well, if you ever want to try it out again then we can help you in #nixos
08:44:28 <Fuuzetsu> by the way, you can install nix on top of your existing distro if you so choose
08:44:39 <bmuk> napping: what do you mean? right now I'm trying to see if vagrant will work for my needs.
08:45:05 <napping> bmuk: I mean just making a separate cabal sandbox for unrelated projects seems to entirely prevent incompatible dependency issues
08:45:27 <bmuk> Fuuzetsu: I may do that this weekend. It would really only come down to whether proprietary drivers would work (or if it has 3.15 I don't really need them) and whether steam worked.
08:45:44 <bmuk> I am extremely fascinated by the pure package management
08:45:47 <Fuuzetsu> Linux lenalee 3.16.1 #1-NixOS SMP Thu Jan 1 00:00:01 UTC 1970 x86_64 GNU/Linux
08:45:48 <napping> If you want a machine image also for deploying to servers or something, or to have a completely reproducible development environment, then vagrant sounds interesting
08:46:01 <Fuuzetsu> steam is packaged IIRC
08:46:14 <bmuk> napping: ah, I see. That was one of my ideas with it
08:46:24 <napping> the only downside I see to sandboxes is that installing the same version of the same package into two different sandboxes will compile it twice
08:46:54 <napping> and GHC 7.10 is supposed to be smart enough about multiple builds of a library to make it possible to just cache the results
08:47:42 <napping> I don't believe Nix - or at least the default expressions - is really set up for using multiple versions of Haskell libraries anyway
08:47:48 <bmuk> I was planning on having different vms for different projects so I may not even need cabal sandbox. I would just like all of the cabal stuff to be in the /vagrant/ directory so that I can easily push it all to github, instead of having it in the home directory
08:47:56 <theli0nheart> Using GHCi, how can one inspect the type of a function that starts with a period? E.g., :t Aeson..: throws an error.
08:48:08 <Fuuzetsu> napping: in nixpkgs we usually only keep latest version but there's nothing stopping you using multiple versions
08:48:20 <Fuuzetsu> you can trivially generate a nix expression for anything on Hackage
08:48:20 <bmuk> theli0nheart: did you try putting it in parentheses?
08:48:28 <monochrom> :type (Aeson..:)
08:49:15 <theli0nheart> monochrom bmuk: aha! that did it. thanks!
08:50:10 <bmuk> Fuuzetsu: what would the difference be between nix on ubuntu and actually running nixos
08:50:30 <Fuuzetsu> NixOS uses nix for system configuration, all my configs are generated by nix
08:50:38 <Fuuzetsu> I don't write any conf files myself ;)
08:51:01 <bmuk> so I would never really need a dotfiles repo, just the nix config file
08:51:12 <luite> Fuuzetsu: the haddock-library dependencies have no bounds, that's probably risky, add < 1.2 ?
08:51:20 <Fuuzetsu> whereasa just nix + some distro, your distro handles all the services and all the system stuff, you'd only use nix for packages
08:51:32 <luite> Fuuzetsu: or 1.1.*
08:51:54 <Fuuzetsu> luite: which deps exactly?
08:52:01 <Fuuzetsu> bytestring? deepseq? those aren't changing any time soon
08:52:25 <Fuuzetsu> or do you mean the dep in Haddock package?
08:52:29 <luite> Fuuzetsu: no i mean haddock (now haddock-api) -> haddock-library
08:53:09 <Fuuzetsu> uh, sure, we could put a bound at next release
08:53:30 <Fuuzetsu> 1.1.* should do
08:54:44 <luite> Fuuzetsu: the other packages come with ghc, the ghc package depends on them, so those shouldn't cause trouble since cabal can only choose those versions
08:55:37 <Fuuzetsu> yep
08:58:59 * hackagebot hxt 9.3.1.6 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.6 (UweSchmidt)
08:59:00 <athan> What would be a good place to learn about continuations? I don't know what `yeild` does... SICP?
08:59:31 <Fuuzetsu> yield* just looking for stuff online should be good
08:59:51 <levi> athan: I don't recall SICP saying much about continuations, but it's been a while.
09:00:31 <athan> levi: Crud. Fuuzetsu: Hmm, alright I'll do some digging. Thanks!
09:00:50 <levi> There's always http://okmij.org/ftp/continuations/
09:01:27 <athan> levi: Wow! Thank you!!
09:01:59 <levi> athan: Also, http://library.readscheme.org/page6.html
09:02:02 <Fuuzetsu> but is there a topic oleg doesn't have something on?
09:02:20 <levi> Fuuzetsu: Lots, but they're probably not very interesting. ;)
09:02:20 <Fuuzetsu> in fact does Oleg have a topic about things Oleg hasn't spoken on?
09:02:29 <monochrom> oleg doesn't have a monad tutorial :)
09:02:37 <Fuuzetsu> Yet!
09:02:45 <athan> levi: Very nice :)
09:02:46 <silver> "typed string theory coming soon"
09:02:50 <Fuuzetsu> I'm sure if you embed some of his stuff into something else and squint, it's a monad tutorial
09:03:08 <monochrom> oleg doesn't have an applicative tutorial :)
09:03:18 <silver> what about arrows?
09:03:37 <monochrom> oleg doesn't have a discontinuation tutorial :)  (I'm making up "discontinuation" :) )
09:04:00 * hackagebot hxt-http 9.1.5 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.5 (UweSchmidt)
09:04:01 <levi> athan: And http://www.haskell.org/haskellwiki/Continuation
09:04:02 * hackagebot hxt-relaxng 9.1.5.1 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.5.1 (UweSchmidt)
09:04:04 * hackagebot gravatar 0.6 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.6 (PatrickBrisbin)
09:04:20 <monochrom> you don't need continuation for yield
09:04:33 <monochrom> I mean, when learning yield.
09:14:32 <preyalone> Where should I report errors in inf-haskell.el?
09:15:01 <preyalone> GHC Trac?
09:15:47 <bennofs> @where haskell-mode
09:15:48 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
09:15:50 <bennofs> :/
09:16:04 <bennofs> I think it's http://github.com/haskell/haskell-mode
09:16:12 <glguy> You can probably email the author of that module. I suspect that it isn't maintained by the GHC devs
09:16:41 <carter> @tell Fuuzetsu  you can get it marked deprecated
09:16:42 <lambdabot> Consider it noted.
09:16:57 <slack1256> There is even #haskell-emacs
09:17:07 <Fuuzetsu> carter: but I want to use the name
09:17:10 <slack1256> to check if somebody encountered the same bug
09:17:23 <Fuuzetsu> i.e. I'd like to take over a name of unused package
09:18:19 <carter> Fuuzetsu: problem is current hackage model doesn't let you delete history :)
09:18:34 <carter> Fuuzetsu: i do think you raise a valid point about name space exhaustion
09:19:05 <carter> and you should talk with both libraries folks (eg edwardk and luite) AND hackage folks, to figure out a proposal to evolve how we namespace
09:19:07 <carter> so you can get that name
09:19:13 <carter> and not have all the od versions
09:19:49 <preyalone> thanks all, will do
09:20:37 <Fuuzetsu> carter: right, but in some cases the package is just unused so if it's deleted then nothing breaks
09:20:45 <Fuuzetsu> although of course for more active packages it becomes a problem
09:21:12 <Fuuzetsu> I'll probably send an e-mail to libraries@ when I want to take over the name, just feeling my ground here
09:21:35 <edwardk> Fuuzetsu: libraries@ would be the appropriate venue for global namespace disputes
09:22:07 <carter> Fuuzetsu: the problem is you still have all the old versions of the old code
09:22:47 <Fuuzetsu> well, the idea would be that a Hackage admin just wipes the package out of existence and a person swoops in and uploads their own
09:23:02 <Fuuzetsu> is there a technical problem with that?
09:23:10 <Fuuzetsu> (for unused packages)
09:23:32 <carter> Fuuzetsu: permahistory
09:23:40 <carter> unused is such a fickle term
09:23:52 <bergey> There's a problem proving that a package is unused.
09:24:29 <Fuuzetsu> bergey: 76 downloads in 5 years, the project name was changed and developed under a different name all together, only a single version was ever released
09:25:08 <edwardk> Fuuzetsu: a more likely solution would be that you'd be granted maintainer status on the project and could release a new version if you were given control of the package
09:25:27 <edwardk> i've 'new version' being something completely different
09:25:28 <Fuuzetsu> edwardk: right, but I'd like to start from 0.1.0.0 and not 2009.… whatever
09:25:31 <edwardk> just on a higher version number.
09:25:36 <edwardk> yeah, there you're screwed. =P
09:26:02 <Fuuzetsu> ;_;
09:26:09 <monochrom> oh, 2009, now I know which package you're referring to :)
09:26:14 <Fuuzetsu> which
09:26:17 <monochrom> HTTP
09:26:19 <Fuuzetsu> no
09:26:22 <monochrom> oops
09:26:23 <bennofs> acme-year?
09:26:24 <Fuuzetsu> isn't that used?
09:26:25 <Fuuzetsu> nope
09:26:39 <edwardk> sessions?
09:26:41 <edwardk> =)
09:26:42 <Fuuzetsu> all you have to do is list the third of Hackage that has been abandoned
09:26:43 <Fuuzetsu> nope
09:26:51 <glguy> pfft, HTTP is *way* beyond 2009
09:27:01 <joelteon> what package is it????????
09:27:04 * monochrom knows very few packages!
09:27:04 <josephle> combinatorrent?
09:27:07 <joelteon> don't keep us guessing
09:27:08 <Fuuzetsu> nope
09:27:11 <joelteon> base?
09:27:21 <monochrom> what have I done? :)
09:27:23 * slack1256 wanted to use combinatorrent
09:27:25 <Fuuzetsu> haha, I'd like to see someone try to claim base
09:27:38 <Fuuzetsu> slack1256: come and put your effort into ‘bittorrent’ library!
09:27:38 <edwardk> anyways, the year.month.day convention never really took =P
09:27:51 <edwardk> Fuuzetsu: *whistles innocently*
09:28:07 <slack1256> Are you sure it isn't lens? that is unmaintained...
09:28:14 <monochrom> hahahaha
09:28:22 <glguy> ouch
09:28:31 <ReinH> Fuuzetsu: are you writing a bittorrent library?
09:28:34 <slack1256> *flies away*
09:28:55 <Fuuzetsu> ReinH: Very hopefully not but at this rate it's looking more likely by the day
09:28:56 <edwardk> clearly what you should then do is get maintainership, write new versions, just with lower version numbers and make the higher versions uninstallable. that won't confuse anybody at all.
09:29:01 <ReinH> ha
09:29:14 <frerich> glguy: Hi there, weren't you the guy who mentioned that writing a 'catamorphism generator' would be a nice TH exercise?
09:29:22 <glguy> Yeah, did you finish it?
09:29:35 <Fuuzetsu> the ‘bittorrent’ library is in a rather broken state and the maintainer is not too responsive ;/
09:29:49 <ReinH> Fuuzetsu: I noticed that :(
09:29:51 <frerich> glguy: https://github.com/frerich/makemorphism <-- indeed I did! Just one known issue left though (cannot derive catamorphism for '(->)')
09:29:57 <Fuuzetsu> at this rate it may be better to go to my old plan and try to salvage what I can from combinatorrent
09:30:39 <ReinH> Fuuzetsu: the bittorrent library uses a bunch of stupid, poorly designed, unnecessarily non-portable libraries that the author also wrote :/
09:31:03 <frerich> glguy: Alas, I couldn't find a lot things which would be suitable for the quotation-style of defining expressions, too much of the code is "dynamic" as in: generated by loops. So I ended up juggling with plain values to construct some expressions.
09:31:09 <ReinH> carter remembers when I was trying to deal with this
09:31:10 <monochrom> write a new library for bittorrent. call it bitrotten.
09:31:14 <frerich> glguy: I suppose somebody more familiar with TH could condense the code considerably.
09:31:23 <glguy> frerich: Yeah, the quotations only help in very limited circumstances
09:31:27 <Fuuzetsu> ReinH: I spoke to the author, he plans to split what's now ‘bittorrent’ into more packages still
09:31:58 <frerich> glguy: Anyway, thanks for mentioning that idea. It's the first time I did anything with TH and it was a fun experience at that. :-)
09:32:04 <Fuuzetsu> but I see there's interest, if someone is interested in collaborating on a bittorrent library and then client then I'm all ears
09:32:10 <Fuuzetsu> less work to do for me
09:32:34 <Fuuzetsu> well, client can wait, library for now
09:32:38 <ReinH> Fuuzetsu: I actually went to the trouble of removing that stupid library and replacing it so that I could get the bittorrent library to build
09:32:44 <ReinH> and it *still* didn't work
09:32:53 <Fuuzetsu> ReinH: I fixed ‘krpc’
09:33:19 <pseudolio> > map length ["bittorrent", "bitrotten"]
09:33:21 <lambdabot>  [10,9]
09:33:24 <ReinH> Fuuzetsu: this stupid thing right here http://hackage.haskell.org/package/base32-bytestring
09:33:32 <pseudolio> Unacceptable.
09:33:38 <Fuuzetsu> what's wrong with that one ReinH
09:33:43 <Fuuzetsu> IIRC that one worked out of the box
09:33:46 <ReinH> Fuuzetsu: it depends on this stupid thing right here http://hackage.haskell.org/package/bits-extras
09:33:54 <pseudolio> > length "bitnetrotor"
09:33:57 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
09:33:58 <Fuuzetsu> I opened an issue about removing that from dependencies
09:33:59 <ReinH> Fuuzetsu: then you happen to be on the one platform it will build on
09:34:10 <Fuuzetsu> ReinH: you need to pass a configure flag to cabal for that one
09:34:19 <Fuuzetsu> let me check, I just packaged it the other day
09:34:19 <ReinH> "This is currently only expected to work on Linux systems, and even there can lead to issues with GHCi's custom linker."
09:34:33 <ReinH> It's *designed* to be non-portable
09:34:37 <Fuuzetsu>   configureFlags = "--ghc-option=-lgcc_s";
09:34:47 <Fuuzetsu> right
09:34:53 <bennofs> > sort "bittorrent"
09:34:55 <lambdabot>  "beinorrttt"
09:35:00 <Fuuzetsu> well, an issue to remove it is there but yeah, I agree it's not optimal
09:35:11 <Fuuzetsu> I think learning from combinatorrent and bittorrent packages is probably for the best
09:35:18 <ReinH> Fuuzetsu: The irony? The whole library is only used for one operation
09:35:22 <Fuuzetsu> and then try to write thisonewontfail
09:35:26 <ReinH> and that operation is only used in one place
09:35:37 <Fuuzetsu> bennofs: how about ‘harrent’
09:35:40 <ReinH> and replacing it with a portable version does not significantly change the performance of the libarry
09:35:53 <Fuuzetsu> (it's what your landlord yells at the 1st of each month)
09:35:53 <glguy> frerich: There are some short-cuts you can take with the lowercased versions of some of the TH constructors, but other than that it doesn't look like there'd be much room for improvement
09:36:40 <frerich> glguy: Well even though I would've loved to hear that it can all be condensed to 8 lines, I'm also happy to hear that it's not totally crazy. :-)
09:37:26 <ReinH> Fuuzetsu: Even after I fixed that by rewriting the parts that were non-portable, it still won't actually compile on 7.8 because it depends on some GHC functionality that was removed. I forget which exactly.
09:37:34 <ReinH> Anyway I now hate that library with the fury of a thousand suns
09:37:38 <Fuuzetsu> ReinH: I fixed that
09:37:45 <Fuuzetsu> it was because the FDs got fixed
09:37:52 <Fuuzetsu> and the instances were no longer accepted
09:37:53 <ReinH> Ah yes! Indeed
09:38:09 <ReinH> You fixed it you say? Excellent.
09:38:23 <Fuuzetsu> well, don't get to excited, even if it builds it does not do much
09:38:37 <Fuuzetsu> there's a lot of commented out stuff and replaced with ‘undefined’ without clear comment on where to go
09:38:40 <ReinH> If I hadn't cobbled together a solution for the thing I was building the library for from some off-the-shelf parts, I might care. ;)
09:39:08 <ReinH> hahaha
09:39:09 <Fuuzetsu> well, I'll probably try to gather some hands to help out on a new torrent library on café in the following days so if you're interested then keep your eye out
09:39:19 <ReinH> Ah, yes, you "fixed" it. ;)
09:39:26 <ReinH> Fuuzetsu: cool
09:39:45 <Fuuzetsu> ‘I got it to compile’
09:40:42 <Fuuzetsu> https://github.com/Fuuzetsu/bittorrent/commit/a6c5d06783a293980e06494d593653a0b770f934.patch changes 38 undefineds to error…
09:41:36 <bennofs> maybe the package could be renamed instead of removed? that way, users who still need it can use the renamed version
09:41:43 <carter> bennofs: nope
09:41:45 <carter> :)
09:41:48 <carter> doesn't work
09:41:53 <Fuuzetsu> there are no users
09:41:58 <carter> that too
09:41:58 <bennofs> carter: why?
09:42:12 <carter> bennofs: because hackage folks will say "nope"
09:42:24 <carter> you can talk about adding ways to enrich the name space
09:42:37 <carter> roughly: hackage is meant to be append only
09:42:40 <Fuuzetsu> I think I'll try to get maintainer rights and then petition to get the old version removed
09:42:54 <carter> no, you can't get stufff removed is my point
09:43:02 <carter> even if you're maintaner
09:43:06 <carter> you can mark stuff deprecated
09:43:24 <Fuuzetsu> what exactly does making it deprecated do?
09:43:34 <Fuuzetsu> IIRC it makes cabal skip over it
09:43:36 <carter> yeah
09:43:39 <carter> well
09:43:48 <carter> theres a difference btwn deprecating a version and a package
09:43:58 <carter> you could deprecate the 2009 version
09:44:05 <carter> and start with 0.1 :)
09:44:11 <Fuuzetsu> yes
09:44:12 <bennofs> carter: not even renaming? :( i thought they were only against removing
09:44:18 <carter> bennofs: renaming is a mutation
09:44:27 <carter> append only
09:44:55 <carter> i'm not saying thats my beliefs, but merely the design that hackage has
09:45:46 * Fuuzetsu mentall notes to make noise on libraries@ later
09:45:54 <Fuuzetsu> maybe we can have it changed by 2030
09:46:34 <josephle> that's the spirit
09:46:43 <Fuuzetsu> call it Hackage 2.5
09:49:07 * hackagebot djinn-lib 0.0.1.2 - Generate Haskell code from a type. Library extracted from djinn package.  http://hackage.haskell.org/package/djinn-lib-0.0.1.2 (AlejandroSerrano)
09:49:22 <Fuuzetsu> did djinn dev restart
09:58:33 <sruz25> Is it possible to read from mutable array in condition (guards)? Or do I have to read it before and give it as argument?
09:59:58 <sruz25> Also is STArray any better than IOArray for this?
10:01:19 <sruz25> I theoretically could give it as argument, but I already have a lot a arguments as it is
10:01:56 <c_wraith> sruz25: no, there is no case in which you can read from a mutable array in a guard.
10:03:56 <sruz25> damn
10:04:57 <nitrix> I have to admit I'm really happy by the choice of the name 'Haskell'.
10:05:02 <nitrix> At least it's google-able.
10:05:07 <kristof> Suppose A <: B <: C, where A-C are types. What are the subtypes of [B]?
10:05:23 <nitrix> Not some common name or single letter.
10:05:24 <TheBizzle> I'm fairly new to Haskell and don't quite understand how to deal with a problem I'm encountering.  I want to read from a state monad, use the state to generate a list of items, and then update the state for each of those items.  Unsurprisingly, I'm doing something wrong and getting a compiler error, but I don't know how to make sense of it.  A link to the
10:05:25 <TheBizzle> code and error: http://lpaste.net/109630
10:05:50 <kristof> Is the collection of subtypes [A], or is it [C]?
10:06:11 <luite> Fuuzetsu: https://github.com/luite/haddock/commit/4db5ab21b243724783e439de554d79cdf2076ca8
10:06:52 <c_wraith> TheBizzle: the problem comes from your use of lift
10:07:53 <luite> Fuuzetsu: oops, haddock-executable probably shouldn't depend on haddock-library
10:07:56 <c_wraith> TheBizzle: What are you actually trying to do here?  Do you want a nondeterministic search, with each indepedent branch using its own state (inherited from its parent)?
10:08:12 <c_wraith> @unmtl StateT Int [] a
10:08:12 <lambdabot> Int -> [] (a, Int)
10:08:27 <vanila> kristof, there is no subtyping in haskell though
10:08:45 <kristof> vanila: but if there were
10:09:02 <vanila> I think it would just be [A] <: [B] <: [C] then
10:09:27 <vanila> [B] might be a list with B's and A's in it
10:09:50 <TheBizzle> c_wraith: This is a simplified version of the code.  The actual code is deterministic search, actually.  Each branch should build on state returned from the last branch, like a fold
10:10:54 <c_wraith> TheBizzle: ok.  Now that I know what you're doing...  StateT Int [] isn't the right model for that search anyway.
10:10:59 <Fuuzetsu> luite: I make-sdist.sh is not actually used by anyone ;P
10:11:04 <vanila> A -> B <: X -> Y  would be when  B <: Y and X <: A though
10:11:51 <kristof> vanila: this shit doesn't work in mutable languages
10:12:01 <vanila> really?
10:12:10 <c_wraith> kristof: scala does it.  (which isn't to say that it works)
10:12:28 <kristof> c_wraith: it doesn't work :P
10:12:38 <TheBizzle> c_wraith: Alright.  What's the better way to approach it, then?
10:13:04 <nyuszika7h> what's wrong with this code? http://lpaste.net/2014882541395247104
10:13:10 <kristof> I'm just working on a small statically typed lisp with my own type inference algorithm and subtyping came up and I'm stumped :P
10:13:16 <Fuuzetsu> I think*
10:13:32 <merijn> kristof: Do you own a copy of TaPL yet? :)
10:13:34 <vanila> kristof, I think there's a subtyping section in TAPL, might be useful
10:13:36 <bernalex> so I had to make this commit yesterday -- https://github.com/plaimi/tempuhs-server/commit/6151138f9dde98ed431c811c4b5faf932885d821 -- anyone have an idea on how to do it the initTimespan tests in a terse & clever manner that's still readable and nice?
10:13:46 <kristof> TheBizzle: without subtypes. Throw in type classes with the ability to derive instances and off you go.
10:14:00 <c_wraith> kristof: wrong conversation.  :)
10:14:13 <c_wraith> TheBizzle: As a beginner, it's probably easiest to just work in State Int and handle the recursive search yourself.  Fortunately, there are handy combinators for that, like mapM
10:14:14 <Fuuzetsu> luite: looks fine to me with just eyeing it, I can try it and merge it in if there are no problems tomorrow unless you're in extreme rush and need it now
10:14:22 <kristof> merijn: pssh, it's the first thing I checked
10:14:27 <kristof> Been open since the start
10:14:37 <merijn> kristof: Just checking ;)
10:14:39 <vanila> kristof, what bit are you stuck on?
10:14:53 <vanila> inference in the presence of subtypes?
10:14:58 <kristof> That.
10:15:07 <vanila> hmm I've never implemented this
10:15:15 <kristof> I just sort of need a general way to decide when something is covariant or contravariant.
10:15:34 <vanila> kristof, well that should work just as I said with ->
10:15:54 <c_wraith> vanila: it's not that simple in the presence of mutable data.
10:15:56 <vanila> so during inference, you need a way to take the lowest-upper-bound and greatest-lower-bound of types
10:16:00 <kristof> I was thinking that "container" types are probably automatically contravariant, becausw functions and generics seem to work that way, but hrm.
10:16:10 <luite> Fuuzetsu: not at all, i'll squash the fix commit (haddock-executable deps) and fix other things if i find them, you're ok with just merging my master branch or should i send a pull req?
10:16:30 <Fuuzetsu> it's better if you send a PR so me and Simon can comment if needed
10:16:35 <Fuuzetsu> send it to haskell/haddock
10:16:43 <kristof> vanila: that's simple constraints propagation, solved problem
10:16:55 <vanila> great!
10:17:11 <luite> Fuuzetsu: ok
10:17:20 <c_wraith> TheBizzle: actually, as I look at that a bit more..  I think you'll need to restructure it significantly.
10:18:28 <c_wraith> TheBizzle: the problem with just putting each element in the list into the state is that the last one will override the rest. If you want to do some processing with each of those current states, you'll need to interleave the logic for doing so
10:19:23 <kristof> vanila: well I still need a way to decide that, given a datatype construction that someone hands me, will it behave covariantly or contravariantly with respect to the next level of types
10:20:04 <pseudolio> So track the variance.
10:20:05 <kristof> Typing's weird. I'm going back to Python.
10:20:26 <kristof> pseudolio: is variance generally decidable for all types without "thinking about it"?
10:21:11 <pseudolio> What does that mean?
10:21:26 <c_wraith> TheBizzle: http://lpaste.net/109630 is kind of close, though it has a subtle problem.
10:21:27 <kristof> Who knows.
10:21:40 <napping> kristof: you can usually decide it from the definition
10:22:12 <kristof> Decide according to what rules?
10:22:18 <vanila> I think that you can recursively apply these rules:   (-) -> (+),  (+) and (+),  (+) or (+)
10:22:34 <kristof> Hrmmmmm.
10:22:43 <sruz25> is runST essentially UnsafePerformIO of ST monads only not so dangerous?
10:22:47 <c_wraith> TheBizzle: http://lpaste.net/109632 is even better, but it requires a sufficiently new version of mtl that you have access to modify'
10:22:52 <pseudolio> Some things you'll have to know primitively their variance.
10:22:55 <c_wraith> sruz25: it's the same, yes
10:22:59 <napping> yeah, just knowing the variance of type constructors used in the definition, and tracking whether they are used in positive or negative places should let you figure it out
10:23:02 <napping> dunno about recursive types
10:23:06 <c_wraith> sruz25: the difference is using the type system to prove it's safe
10:23:16 <pseudolio> I'm not sure if you can decide what variance to give a definition, but you can check a declared one.
10:23:17 <napping> Of course you get answers like mutable lists being invariant
10:23:17 <TheBizzle> c_wraith: That's fine.  I can use whatever version of mtl.  I'll check it out.  Thanks
10:23:39 <pseudolio> The choice is not necessarily unique, though.
10:23:58 <napping> pseudolio: isn't there a most general choice?
10:24:02 <pseudolio> If a type former could be covariant, it could also be invariant.
10:24:08 <kristof> vanila: ah, and then there's the problem of heterogenous linked lists. I've actually taken the route of calling that an opaque data type, is that insane?
10:24:12 <pseudolio> So you'd need to have subtyping of variance, too.
10:24:23 <pseudolio> To have a most general choice.
10:24:25 <sruz25> c_wraith: oh, great
10:24:29 <sruz25> ty
10:24:32 <c_wraith> remember that in a mutable setting, variance of subtyping depends on more than just whether that type variable appears in a positive or negative location. It also depends on whether you're reading from or writing to mutable cells of that type
10:24:34 <vanila> heterogenous anything is scary, I would try to avoid it if possible?
10:24:51 <napping> oh, I guess it gets undecidable if you require variance on type arguments also
10:24:53 <kristof> Then it would not be lisp!
10:25:12 <vanila> fair point :)
10:25:17 <kristof> I throw around heterogenous lists all the time
10:25:44 <c_wraith> Pfft.  They're all [LispVal] to me!
10:25:54 <Fuuzetsu> they are just LispVal to me
10:26:00 <kristof> c_wraith: sneaky me has a solution for that in the way I define setting "places".
10:26:39 <pseudolio> Also if you want to avoid duplication, you'd need variance polymorphism.
10:26:54 <kristof> I don't even know what that means. :o
10:27:04 <pseudolio> Or, dependent variance, I guess. Whatever you want to call it.
10:27:17 <pseudolio> So that the variance of a definition can depend on the variance of parameters to it.
10:27:37 <kristof> Ah, right.
10:27:44 <pseudolio> And I expect that isn't going to be easily decidable automatically.
10:27:55 <kristof> That is what I expected, too.
10:28:06 <linman32> hamishmack: hey are you in chat?
10:28:21 <kristof> But I figure that if humans can intuit what "will work" in a given context, there must be some decidable rules
10:28:50 <c_wraith> kristof: that only implies that there are heuristics that are normally right.
10:29:01 <c_wraith> kristof: it does not imply those heuristics are consistent or complete
10:29:07 <c_wraith> (or even correct)
10:29:19 <kristof> c_wraith: normally right is fine by me
10:30:28 <kristof> c_wraith: the type checker will be a program that operates on a list of type signatures itself with the entire language available for type construction, so this is a beast entwined in godelian knots already
10:31:03 <kristof> But the benefit of this is drop in type systems are a mere library away
10:31:24 <vanila> if you use state monad you derive the rules about positive/negative on read/wrote acess
10:31:43 <kristof> How?
10:32:52 <vanila> so we have: get :: State a a,  put :: a -> State a ()
10:33:49 <vanila> and State s a is s -> (a, s)
10:34:26 <orion> thoughtpolice: Is there anything more I can do?
10:37:16 <vanila> s -> (a, s) <: s -> (a', s)  when a <: a'   so   State a a <: State a' a
10:38:10 <kristof> I was thinking of something along those lines!
10:39:01 <vanila> a' -> (_ -> (a, ())) <: a -> (_ -> (a, ()))  when a <: a'  so   a' -> State a () <: a -> State a ()
10:39:21 <vanila> i would have to check this more formally but I think that gives you right rules
10:40:12 <linman32> hi, hamishmack talks about making a sandbox in a particular way here: http://ircbrowse.net/browse/haskell?events_page=537435
10:40:25 <linman32> does anyone know how to perform what he is talking about?
10:40:46 <linman32> (better link) http://ircbrowse.net/browse/haskell?id=18810219&timestamp=1407975196#t1407975196
10:41:21 <Fuuzetsu> linman32: do what he says there, what exactly is unclear?
10:41:52 <linman32> Fuuzetsu: how do you add to gtk3.cabal file? or what am i supposed to add?
10:42:35 <Fuuzetsu> linman32: actually I just looked in the cabal file and all the demos seem added already, you can probably just configure with -fbuild-demos and that will do it
10:43:45 <linman32> Fuuzetsu: which directory should i be in? and what is the command?  this? cabal install ./gtk2hs/gtk -fbuild-demos
10:44:02 <Fuuzetsu> gtk2hs/gtk
10:44:04 <Fuuzetsu> cabal sandbox init
10:44:09 <Fuuzetsu> cabal configure -fbuild-demos
10:44:11 <Fuuzetsu> cabal build
10:44:20 <Fuuzetsu> then the demos should be somewhere under dist/
10:44:42 <Fuuzetsu> afaik cabal has some commands to run the results directly too, cabal exec or cabal run or something
10:46:29 * Fuuzetsu → bed
10:46:54 <nitrix> I'm really confused. How does haskell deals with concurrency with ForkIO ?
10:46:57 <linman32> Fuuzetsu: got errors http://lpaste.net/109636
10:47:04 <nitrix> Let me post my code:
10:47:20 <linman32> what is best way to get needed dependencies
10:47:22 <Fuuzetsu> linman32: run cabal install --only-dependencies before cabal configure
10:47:23 <linman32> ?
10:47:47 <Fuuzetsu> nitrix: read Parallel and Concurrent Programming in Haskell
10:48:40 <nitrix> http://ideone.com/vnrE6u line #46
10:49:09 <Fuuzetsu> nitrix: what's the problem?
10:49:16 <Fuuzetsu> also you can use threadDelay maxBound
10:49:25 <nitrix> Is this even safe? Wouldn't the rendering thread or whatever decide the render an incomplete string?
10:49:45 <linman32> Fuuzetsu: more errors w/ --only-dependencies http://lpaste.net/109637
10:50:16 <nitrix> Besides, how does it even knows to re-render it now that timeText has changed... is it abstracted by that magical runUi ?
10:50:17 <Fuuzetsu> nitrix: setText may block or something, you could also use MVar or STM or whatever you want to ensure everything is properly done
10:50:50 <nitrix> Fuuzetsu: Right, so I just assume the Vty library knows what its doing?
10:51:24 <nitrix> The synchronization is done by the library?
10:51:30 <nitrix> module, sorry.
10:51:34 <Fuuzetsu> linman32: I think running cabal install gtk2hs-buildtools outside of the sandbox then trying again will work
10:51:54 <Fuuzetsu> nitrix: I can't say ‘yes’ because I don't know but probably.
10:52:40 <nitrix> Fuuzetsu: I understand. Got it. Their examples show it that way, but it left me puzzled. I'm used for the user to be exposed to the concurrency mechanisms.
10:52:50 <nitrix> But in this case it'd be abstracted.
10:52:59 <nitrix> I suppose this is using a form of State monad
10:53:00 <nitrix> ?
10:53:18 <Fuuzetsu> right, I'm using gtk2hs at the moment for a program and I'm using MVars there to do updates
10:53:35 <Fuuzetsu> nitrix: I don't know, State doesn't seem like the right candidate though
10:54:08 <nitrix> setText :: Widget FormattedText -> Text -> IO ()
10:54:12 <nitrix> I stand corrected.
10:54:48 <linman32> Fuuzetsu: hey, same problem. tried doing cabal install gtk2hs-buildtools outside of sandbox
10:56:01 <samba1> How do I use withSession in Snap.Snaplet.Session?
10:56:06 <samba1> I see it wraps a handler, and looking at the code it's very simple just calling the handler, commitSession, and then returning the handler.
10:56:10 <samba1> So I can do `withSession mySession myHandler`. But, where would I add session logic? Like reading something from the session, taking depedent action. getFromSession and setInSession all return Handler b SessionManager (), how can I wrap that up?
10:56:10 <Fuuzetsu> linman32: you'll have to figure out how to update your gtk2hsC2hs first then, it might be a PATH problem or something for you
10:56:28 <Fuuzetsu> anyway I'm off to bed, I'm sure someone else can step in if you don't figure it out
10:56:45 <linman32> Fuuzetsu: thanks for helping :)
10:58:33 <linman32> how do i update gtk2hsC2hs, as Fuuzetsu said?
10:58:58 <luite> linman32: cabal install gtk2hs-buildtools
11:00:30 <linman32> Fuuzetsu said it might then be a path problem. updating gtk2hs-buildtools does not fix problem
11:02:13 <btcNeverSleeps> if I have something like: "tx1 :: Int -> Maybe Int" I can then, say: "fmap tx1 (Just 3)" and that works fine.
11:02:58 <btcNeverSleeps> What if I want the same for, say: "tx2 :: Int -> Int -> Maybe Int" where I want to get Nothing in case either the first or the second Int is Nothing?
11:03:24 <pranz> Is there a difference in performance by using STrefs instead of having all fields you want mutable part of the stateful record?
11:03:45 <solidus-river> jle`: heh, you and mm_freak are busy guys, i'm still pulling my hair out over this, mm_freak suggested i try to form it using just behavior and event types he supplied but it didn't seem to help much
11:04:00 <jle`> solidus-river: sorry, i'm on vacation atm :)
11:04:09 <linman32> what is alex and happy? how do i install them?
11:04:28 <glguy> btcNeverSleeps: do { x <- firstArg; y <- secondArg; tx2 x y }
11:04:29 <pranz> linman32: cabal install is one way to get them
11:04:40 <linman32> pranz: should i install in sandbox?
11:04:47 <samba1> btcNeverSleeps: The first or second Ints can't possibly be Nothing, they're Ints not Maybe Ints
11:04:58 <btcNeverSleeps> glguy: ah, I have not learned the do notation yet :-/
11:05:16 <pranz> linman32: no I don't think that's neccesary
11:05:32 <glguy> ?undo do { x <- firstArg; y <- secondArg; tx2 x y }
11:05:33 <lambdabot> firstArg >>= \ x -> secondArg >>= \ y -> tx2 x y
11:05:44 <solidus-river> jle`: i ran into the exact same problem i ran into trying to do it with netwire http://lpaste.net/109578
11:05:59 <solidus-river> jle`: oh, nevermind then! enjoy your vacation :)
11:06:07 <btcNeverSleeps> samba1: I know, I know... Compared to the first example: "fmap tx1 (Just 3)", I'm after something like this "??? tx2 (Just 3) (Just 42)"  which would return Nothing in case either the first or the second Maybe is Nothing.
11:06:24 <linman32> pranz: thanks
11:06:25 <solidus-river> jle`: why are you on irc during vacation!, go be in cool places and or waste lots of time!
11:06:32 <btcNeverSleeps> glguy: cool ?undo there!
11:06:55 <moghedrin> I feel like 'join . liftM2 tx2' would work here too. Am I wrong?
11:07:34 <glguy> moghedrin: close. check the type
11:07:38 <hask54> Basic unix question: This is how I compile my app: ghc --make app.hs -o ../app (I want the app in the parent directory). How do I run ../app *as if I was running it from ../ without actually doing "cd .." first?
11:07:41 <jle`> solidus-river: haha i'm trying to configure squid so i can get past these chinese firewalls
11:07:47 <samba1> btcNeverSleeps: I see. Yeah, see glguys. You could also do it in applicative style with tx2 <$> (Just 3) <*> (Just 6)
11:08:06 <hask54> If I do ../app it acts as if its running from the current directory, not from ../
11:08:23 <jle`> don't tell anyone though
11:08:49 <glguy> yeah, there are all sorts of indirect ways to get there :)
11:09:54 <merijn> hask54: Programs always run with their current working directory set to whatever they were launched from
11:10:10 <merijn> hask54: If you want something different you need to programmatically change the working dir in the code of app
11:10:50 <hask54> merijn: okay. it's just that it's a bit painful to do "cd .." every time just to launch the app. the only easy alternative is two have two terminal windows open, but that clutters things
11:11:39 <mp> hi, I get "error: unterminated /* comment" from TH, any ideas?
11:12:04 <jle`> mp: are you terminating your /* comments?
11:12:16 <athan> v.v
11:12:28 <bennofs> Those this type exist somewhere? newtype FixT m f = FixT { outFT :: f (m (Fix f)) }
11:12:40 <bennofs> s/Fix f/FixT m f
11:13:01 <btcNeverSleeps> that helps, thanks.  Another question, but it's more of a "design" question: when I have a function, say: "tx1 :: ... -> Maybe X" and then another one which shall use that result, am I better to have that second function be "tx2 :: X -> ..." or "tx2 :: Maybe X -> ..."?
11:13:08 <koala_man> hask54:  app() ( cd ..; ./app "$@" ); then you can just run 'app foo bar' and it'll autocd
11:13:12 <bennofs> Ah, that is just Fix (Compose f m) I think
11:13:25 <jle`> btcNeverSleeps: you can turn any (a -> b) into a (Maybe a -> Maybe b) with fmap
11:13:31 <jle`> btcNeverSleeps: you can't go the other way
11:13:40 <jle`> in general, at least
11:13:47 <jle`> so usually we like to give the (a -> b) version if possible
11:14:19 <hask54> koala_man: what is that? bash command I type in every single time before 'app foo bar' ?
11:14:37 <samba1> hask54: koala_man: you can even add a `cd -` to the end of that so when the process dies you're back in the subdir
11:14:55 <koala_man> hask54: you type it in once per session, or alternatively stick it in your .bashrc, and then
11:15:07 <koala_man> samba1: no need, it runs in a subshell
11:15:19 <koala_man> hask54: then you can run 'app foo bar' as many times as you want
11:15:32 <hask54> hehe
11:16:28 <btcNeverSleeps> that is very interesting... And (somehow related to my previous question), should I better have a function "tx :: X -> Y -> Maybe Z" or "tx :: Maybe X -> Maybe Y -> Maybe Z"?  I kinda "feel" that "tx :: X -> Y -> Maybe Z" is cleaner but then it requires a bit more "work" when you call tx.
11:16:54 <vanila> btcNeverSleeps, Do you know about the maybe monad?
11:16:57 <vanila> it might be useful here
11:17:17 <vanila> for example you might have tx :: X -> Y -> Maybe Z, and then  if you have mx :: Maybe x, my :: Maybe y  you can write
11:17:25 <vanila> do x <- mx ; y <- my ; tx x y
11:17:45 <jle`> Monad might be a bit overkill here, but
11:18:06 <jle`> oh wait
11:18:09 <jle`> no, you  need Monad here, heh
11:18:12 <merijn> jle`: Has to be monad, applicative is not enough
11:18:25 <jle`> i didn't look close enough ;_;
11:19:42 <athan> Are commutative monads easier to prove / construct in dependently typed settings?
11:20:44 <btcNeverSleeps> I'll go read on the do notation and then try what glguy and vanila suggested. Thanks a lot to everyone.
11:20:59 <carter> things are easy to construct in any setting
11:21:08 <carter> proving ... that varies with the proof quality
11:21:13 <jle`> there should be some (a -> b -> m c) -> (m a -> m b -> m c) in standard library perhaps
11:21:15 <carter> do you want a pen and paper proof
11:21:23 <jle`> i guess you could use liftA2 and join
11:21:42 <jle`> liftA2 turns (a -> b -> Maybe c) -> (Maybe a -> Maybe b -> Maybe (Maybe c))
11:21:57 <jle`> and then join turns (Maybe (Maybe c)) -> Maybe c
11:22:22 <jle`> it just feels a little silly that you have o jump into do notation to be able to do it in a readable way
11:22:26 <athan> carter: I was hoping for something more automatic haha. My use case is parallel array updates, where indicies might clash - that's where dependent typing might help (at least my intuition)
11:22:38 <glguy> You can just write it with do notation, no need to throw combinators, this is why we have do notation
11:22:41 <carter> why would indicies clash?
11:23:03 <athan> carter: Idk, maybe... they, uh...
11:23:11 <athan> carter: Let me get back to you on that one
11:23:12 <carter> athan: either you start needing atomics
11:23:23 <carter> or you schedule your work to not have overlapping writes
11:23:29 * carter is writing an array libs
11:23:35 <athan> carter: :)
11:23:45 <carter> athan: locking / atomics have a cost
11:23:47 <carter> can be prettycheap
11:23:53 <carter> but can be pricey too
11:24:49 <athan> carter: Couldn't predicates restricting certain locks be encoded in a dependently typed fashion, though, making for compile-time atomics??
11:25:03 <carter> athan: at what cost to humans?
11:25:25 <carter> the lib author should bear the pain needed to let all users be happy magicians
11:26:25 <athan> carter: But but.... TYPE SAFETY
11:26:39 <carter> athan: fix your design so theres no danger :)
11:28:04 <pseudolio> A monad with array updates isn't commutative.
11:28:11 <athan> carter: My design is going to be a non-overlapping schedule that's derived from dependent types, but used by the programmer as if they were atomic
11:28:38 <athan> pseudolio: Couldn't it be, if the index clashes were restricted at compile time?
11:28:44 <athan> carter :P
11:28:59 <carter> athan: not unless you control the reads
11:29:09 <carter> reads and writes to the same area dont commute!
11:29:35 <athan> we shall see >:D
11:29:45 <athan> *moniacle laugh*
11:30:11 <jle`> solidus-river: have you looked at ocharles's asteroids example? it uses a gun with cooldown on keypress, right?
11:30:37 <solidus-river> jle`: it does but it uses netwire 4 and the wires he uses have changed the way they work
11:30:41 <carter> athan: solution
11:30:43 <carter> don't use a monad
11:30:43 <solidus-river> jle`: the way he does it is no longer possible
11:30:47 <carter> only provide an applicative
11:31:02 <carter> athan: then you can introspect actions before running em
11:31:35 <athan> carter: Too much overhead!
11:31:42 <carter> athan: whats the use case
11:31:53 <carter> because i don't sense a "i'm trying to write fast stuff"
11:31:58 <carter> in your jargoning
11:32:08 <athan> carter: oh, well, I am kinda...
11:32:13 <carter> because if you don't benchmark
11:32:14 <carter> :)
11:32:31 <athan> *prepares to eat $#%&*
11:33:30 <carter> @hackage criterion is your best friend and lover, go everywhere with it
11:33:30 <lambdabot> http://hackage.haskell.org/package/criterion is your best friend and lover, go everywhere with it
11:33:36 <carter> if you say you care about perf
11:33:40 <carter> measure measure measure
11:33:40 <carter> :)
11:34:00 <josephle> I impressed my TA with criterion output, it was great
11:34:16 * josephle is a happy criterion user
11:34:21 <athan> carter: Thank you hahaha, I'll make sure to treat her properly
11:34:50 <carter> athan: no, be like a codependent addict who cant live without benchmarks
11:36:29 <athan> carter: I'll prepare the plates for prompt breaking :)
11:36:38 <carter> no
11:36:42 <carter> point being
11:36:50 <carter> for constant factor level perf matters, measure
11:36:52 <carter> don't speculate
11:37:20 <athan> carter: I understand, I've got a few machines I can work with, too. I can't wait :D
11:37:37 <benzrf> can somebody give me an example of a function in haskell that is *not* an epimorphism?
11:38:05 <athan> benzrf: undefined?
11:38:11 <benzrf> :y
11:38:28 * benzrf goes to ask ##math 
11:40:23 <frerich_> glguy: Oooh, exciting...
11:41:04 <RchrdB> benzrf, sure. (const 0) is not an epimorphism. ((even) . (const 0)) == ((<1) . (const 0)), but (even) != (<1).
11:41:18 <benzrf> aha
11:41:30 <bmuk> I'm getting a strange type error, can you guys look at my code? http://bpaste.net/show/635584
11:41:43 <bmuk> it's in the sumMultiplesBelow function
11:42:13 <benzrf> so... a non-surjective function is not necessarily an epimorphism because the differences in the functions you compose with it might be covered by elements that the non-epimorphism doesnt output
11:42:25 <thebnq> bmuk: multiplesBelow requires another argument
11:43:11 <bmuk> thebnq: I'm passing both the list and the limit?
11:43:35 <thebnq> bmuk: oh i see, you can't just use the . there
11:43:48 <thebnq> :t (.)
11:43:49 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:44:15 <thebnq> the function on the right side gets one argument, and then that whole thing is given to the other
11:44:34 <bmuk> ah. How else can I compose them? Just ($)?
11:44:40 <RchrdB> benzrf, yes, that's correct.
11:44:46 <benzrf> ($) is not composition!
11:44:52 <bmuk> it's application
11:45:38 <bmuk> but (f . g) x == (f (g x)) == f $ g x, no?
11:46:03 <RchrdB> bmuk, write the version with points in first, and use lambdabot's @pl to convert it into point-free form if you really want to.
11:46:08 <thebnq> yea but you have f $ g x y
11:46:23 <RchrdB> so, sumMultiplesBelow xs limit = sum (multiplesBelow xs limit) -- right?
11:46:33 <bmuk> yes
11:46:38 <RchrdB> @pl \xs limit -> sum (multiplesBelow xs limit)
11:46:39 <lambdabot> (sum .) . multiplesBelow
11:46:42 <athan> bmuk: (f $ g) x =/= (f . g) x
11:47:07 <Iceland_jack> Don't follow @pl blindly
11:47:42 <glguy> Use @pl as a curiosity, not as a recommendation
11:47:46 <RchrdB> bmuk, and lambdabot ↑ gives the point-less version, which is (sum .) . multiplesBelow. And I wouldn't write that, because it's awful.
11:48:06 <bmuk> I love this channel - I always learn something new. RchrdB++ thebnq++
11:48:12 <bmuk> I wouldn't write that either
11:48:17 <Iceland_jack> You can define (.:) = (.).(.) and write it
11:48:17 <Iceland_jack>     sum .: multiplesBelow
11:48:24 <Iceland_jack> but just write it pointfully
11:48:40 <bmuk> I always thought (.) composed any two functions together
11:48:55 <Iceland_jack> It does
11:49:00 <Iceland_jack> as long as the types match
11:49:08 <thebnq> functions of one argument
11:49:21 <glguy> functions have one argument
11:49:45 <Iceland_jack> > ((+) . succ) 5 2
11:49:47 <lambdabot>  8
11:49:55 <thebnq> oops yeah
11:49:58 <Iceland_jack> If you're going to call
11:49:58 <Iceland_jack>     a -> b -> c
11:49:58 <Iceland_jack> binary functions, then (.) can accept those
11:50:25 <bmuk> so I could technically do sumMultiplesBelow xs = sum . (multiplesBelow xs)?
11:50:30 <Iceland_jack> yes
11:50:39 <thebnq> yea, you don't need the ()s either
11:50:40 <Iceland_jack> and skip the parentheses
11:50:51 <Iceland_jack> @pl \xs -> sum . multiplesBelow xs
11:50:52 <lambdabot> (sum .) . multiplesBelow
11:51:03 <Iceland_jack> @unpl \xs -> sum . multiplesBelow xs
11:51:03 <lambdabot> \ xs c -> sum (multiplesBelow xs c)
11:51:06 <Iceland_jack> same thing
11:51:09 <bmuk> do you think that looks better than the fully pointed version?
11:51:21 <Iceland_jack> Both are equally good
11:51:37 <RchrdB> I slightly prefer the fully-pointed version.
11:52:04 <bmuk> I know it's just an exercise and therefore rather short, is there anything I could do to improve this code? From a functionality or stylistic standpoint?
11:52:15 <jle`> i like keeping one point
11:52:23 <jle`> instead of using (.:)
11:52:30 <jle`> but a lot of people like (.:)
11:52:51 <Iceland_jack> I would use (.:) if were included in the Prelude
11:52:56 <Iceland_jack> but I never use it as is
11:53:41 <ezrios> @hoogle (.:)
11:53:43 <lambdabot> No results found
11:54:06 <ezrios> wat
11:54:12 <ezrios> oh the boobs operator
11:55:12 <athan> exrios: Does it compose two fixpoints or something?
11:55:41 <jle`> Iceland_jack: same here
11:56:21 <eitan_chatav> ((.).(.))
11:57:01 <ezrios> then there is always monkeyface (:[])
11:57:19 <bmuk> Okay it is fixed, thank you all - http://bpaste.net/show/635654
12:04:24 * hackagebot hslinks 0.6 - Resolves links to Haskell identifiers.  http://hackage.haskell.org/package/hslinks-0.6 (HansHoglund)
12:06:23 <samba1> How do I use withSession in Snap.Snaplet.Session?
12:06:27 <samba1> I see it wraps a handler, and looking at the code it's very simple just calling the handler, commitSession, and then returning the handler.
12:06:30 <samba1> So I can do `withSession mySession myHandler`. But, where would I add session logic? Like reading something from the session, taking depedent action. getFromSession and setInSession all return Handler b SessionManager (), how can I wrap that up?
12:09:25 * hackagebot hslinks 0.6.1 - Resolves links to Haskell identifiers.  http://hackage.haskell.org/package/hslinks-0.6.1 (HansHoglund)
12:09:27 * hackagebot transf 0.13 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.13 (HansHoglund)
12:11:58 <solidus-river> jle`: ha! i at least now can form exactly the problem i'm having the wire once used to emit an event at a single instant and then inhibit and there is no equivalent to that in netwire 5
12:12:11 <solidus-river> jle`: netwire 5 changes that to emiting an event once and then emiting NoEvent but it never inhibits
12:12:33 <solidus-river> jle`: so you can no longer switch behaviors based on events the way that ocharles was
12:12:52 <solidus-river> and i'm having a hell of a time reforming that into netwire 5
12:13:10 <solidus-river> i could always make my own wire but that seems dumb
12:14:01 <linman32> hi how do i install the latest version of gtk2hsC2hs? i have 0.13.7, but can't install 0.13.11
12:16:40 <pavonia> linman32: Why can't you install the latest version?
12:17:36 <linman32> pavonia: that is a good question. i "sudo apt-get install libgtk-3-dev", but it does not upgrade it
12:17:47 <linman32> pavonia: so not sure
12:18:35 <pavonia> Oh wait, where do you get that version number from? The latest version of gtk2hs-buildttols on Hackage is 0.13.0.1
12:20:06 <pavonia> Also, why do you need that later version? Are you getting build errors for another gtk package?
12:20:08 <linman32> pavonia: http://lpaste.net/109643
12:20:15 <linman32> pavonia: yes
12:22:06 <linman32> pavonia: line 20/21 talks about gtk2hsC2hs version error
12:22:45 <pavonia> Yeah. So did you install the latest buildtools package via cabal?
12:22:56 <linman32> in sandbox or outside?
12:23:37 <pavonia> Doesn't matter I guess
12:24:00 <linman32> what are build tools?
12:24:26 <pavonia> @hackage gtk2hs-buildtools
12:24:26 <lambdabot> http://hackage.haskell.org/package/gtk2hs-buildtools
12:24:26 * hackagebot transf 0.13.1 - Text transformer and interpreter.  http://hackage.haskell.org/package/transf-0.13.1 (HansHoglund)
12:25:21 <pavonia> I'm just confused about the version number of that tool being different from the package's version number
12:26:46 <linman32> pavonia: got a step further. but now http://lpaste.net/109645
12:27:22 <linman32> after installing gtk2hs-buildtools in sandbox, ran this "cabal install --only-dependencies"
12:29:16 <pavonia> linman32: What version of text are you using?
12:31:16 <linman32> pavonia: text 0.11.3.1
12:35:11 <merijn> Is anyone aware of any Coq libraries (or whatever other tool) for proving concurrent haskell code correct?
12:36:29 <pavonia> linman32: You seem to need at least text-1.0
12:37:12 <bmuk> Is there a better function in the prelude that does what sum does?
12:37:34 <bmuk> It's very slow on large lists
12:37:34 <merijn> bmuk: Define "better"?
12:37:48 <merijn> bmuk: Are you compiling with -O2?
12:37:51 <bmuk> yes
12:37:56 <merijn> :t sum
12:37:57 <lambdabot> Num a => [a] -> a
12:38:04 <merijn> bmuk: Which numeric type?
12:38:13 <merijn> bmuk: Int or Integer?
12:38:26 <bmuk> Int
12:38:34 <bmuk> should I be using Integer
12:38:38 <merijn> hmm, that sounds odd
12:38:43 <merijn> bmuk: Integer is slower than Int
12:38:51 <merijn> Whether you should be using Integer depends
12:39:05 <merijn> Integer uses bignums, Int is machine dependent in size
12:39:11 <bmuk> I don't need anything above the wrap around point, so I guess not
12:39:39 <merijn> How large is "large lists"?
12:40:09 <bmuk> Less than 2,000,000 elements
12:40:37 <bmuk> I'm not sure how to accurately estimate how many fibonacci numers there are under 4,000,000
12:40:51 <merijn> oh
12:41:02 <merijn> That sounds like your fibonacci implementation is slow?
12:41:10 <bmuk> but the fib function isn't my problem - I'm testing sum on a trivial list comprehension right now
12:41:11 <merijn> > sum [1..2000000]
12:41:17 <lambdabot>  mueval-core: Time limit exceeded
12:41:24 <merijn> hmm, that takes longer than on my machine
12:41:35 <merijn> On my 2009 macbook that returns in like 1 sec
12:41:41 <merijn> Without optimisations
12:41:42 <shachaf> > foldl' (+) 0 [1..2000000] -- lambdabot doesn't use -O2
12:41:43 <lambdabot>  2000001000000
12:41:52 <merijn> shachaf: ghci doesn't use -O2 either :)
12:41:52 <bmuk> Let me show you my code;
12:42:19 <shachaf> > sum [1..2000000] -- fair enough
12:42:22 <lambdabot>  2000001000000
12:42:59 <merijn> bmuk: Can you try something simple for me?
12:43:05 <bmuk> sure
12:43:14 <athan> `mod` is constant time, right?
12:43:27 <merijn> bmuk: Compile this with "ghc -O2" and tell me what "time ./main" returns: main :: IO ()
12:43:29 <athan> (within the bounds of the CPU's word size)
12:43:30 <merijn> main = print $ sum [1..2000000]
12:43:51 <merijn> bmuk: On my machine that runs in: real    0m0.074s
12:44:28 <merijn> 200,000,000 runs in about 7s
12:44:46 <DanielDiaz> is it safe to cast an 'Int' to a 'Word32'?
12:44:53 <merijn> DanielDiaz: No
12:45:02 <merijn> DanielDiaz: Also, haskell doesn't have casts
12:45:12 <merijn> DanielDiaz: On 64bit Int is 64bits in GHC
12:45:26 <DanielDiaz> meirjn: well, 'fromIntegral'...
12:45:29 <bmuk> 0.06s
12:45:36 <bmuk> hmm.
12:45:46 <DanielDiaz> > maxBound :: Int64
12:45:48 <lambdabot>  9223372036854775807
12:45:50 <merijn> bmuk: Right, that sounds normal, so that makes it seem the problem is not sum, but something else :)
12:45:54 <DanielDiaz> > maxBound :: Word32
12:45:56 <lambdabot>  4294967295
12:45:59 <DanielDiaz> ok, answered
12:46:00 <bmuk> maybe it's a problem with laziness
12:46:02 <DanielDiaz> sorry about that
12:46:03 <dolio> DanielDiaz: What do you mean by safe?
12:46:28 <merijn> DanielDiaz: There is Data.Word which is the same size as Int, but unsigned
12:46:42 <merijn> > 5 :: Data.Word.Word
12:46:44 <lambdabot>  5
12:47:06 <merijn> > (maxBound, maxBound) :: (Int, Data.Word.Word)
12:47:09 <lambdabot>  (9223372036854775807,18446744073709551615)
12:47:34 <bmuk> sum [x | x <- [1..], x <= 4000000] takes forever too
12:47:38 <DanielDiaz> meirjn: yes, I know. Thank you. For one moment I thought 'Int' might fit inside of 'Word32', but the example above crearly proves it wrong. Which was of  course clear. I was too hasty asking haha
12:47:47 <merijn> bmuk: oh, lol
12:47:52 <Iceland_jack> bmuk: You want
12:47:56 <Iceland_jack> @ty takeWhile
12:47:57 <merijn> bmuk: You fell for a classic newbie mistake :D
12:47:57 <lambdabot> (a -> Bool) -> [a] -> [a]
12:48:06 <merijn> bmuk: The list comprehension is infinite
12:48:13 <merijn> bmuk: So sum takes an infinite amount of time :)
12:48:16 <Iceland_jack> > takeWhile (<= 14) [1..]
12:48:16 <bmuk> haha
12:48:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
12:48:29 <bmuk> I thought that the predicate would make it end?
12:48:41 <merijn> bmuk: No, predicates are filters
12:48:59 <bmuk> haha okay. merijn++
12:49:00 <merijn> > [x | x <- [1,2,3,4,5,4,3,2,1], x < 4 ]
12:49:02 <lambdabot>  [1,2,3,3,2,1]
12:49:14 <merijn> But yeah, takeWhile is what you want
12:49:26 <merijn> > takeWhile (<4) [1,2,3,4,5,4,3,2,1]
12:49:27 <lambdabot>  [1,2,3]
12:50:00 <bmuk> what is a concise way to limit the output of a function I am mapping over a list?
12:50:22 <Iceland_jack> What do you mean 'limit'?
12:50:27 <merijn> take/takeWhile and friends
12:50:40 <merijn> > take 20 [1..]
12:50:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
12:50:53 <merijn> > takeWhile (<15) [1..]
12:50:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
12:51:27 <merijn> > take 20 $ map (*5) [1..]
12:51:29 <lambdabot>  [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
12:51:31 <bmuk> Iceland_jack: sorry, I want to do what takeWhile did to an infinite list, but I want to apply a function to the list before I analyze the number
12:51:39 <merijn> bmuk: That's fine
12:51:44 <merijn> bmuk: Laziness :)
12:52:13 <merijn> You can easily map over an infinite list if you only inspect the first 20 elements (with, for example takeWhile/take)
12:53:03 <merijn> > let f = takeWhile (<200) . map (5*) in f [1..]
12:53:05 <lambdabot>  [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,120...
12:53:18 <bmuk> http://pastebin.com/svz7rFSC
12:53:18 <exio4> > takeWhile (<100) $ map (*5) $ filter even [1..]
12:53:21 <lambdabot>  [10,20,30,40,50,60,70,80,90]
12:53:58 <linman32> pavonia: thanks. did cabal install text (and 1 other package). now works
12:54:23 <bmuk> exio4++
12:54:26 <bmuk> that should work
12:54:34 <pavonia> linman32: Great!
12:55:42 <solarus> or just `[2,4..]' instead of `filter even ..'
12:56:45 <merijn> exio4: Needs more . and less $ :)
12:57:39 <exio4> yep, that was version 0.1! :P
13:01:01 <monochrom> "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
13:01:22 <merijn> For the popcorn gallery: You can extract an arbitrarily long section of a (.) pipeline, put it in a let/where and drop the name in the pipeline and get correctly typed code. whereas the same does not apply to pipelines of $
13:01:24 <athan> monochrom: Ha! I always wondered
13:01:44 <merijn> athan: That was a joke :)
13:01:53 <shachaf> @remember monochrom "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
13:01:53 <lambdabot> It is stored.
13:02:10 <merijn> athan: points in this case refer to "names", so pointless/point free code is code without explicit names :)
13:02:22 <nitrix> Is Data.Text the closest that would be from C strings?
13:02:33 <merijn> nitrix: Look in Foreign.C.Types
13:02:41 <merijn> nitrix: It depends on why you ask
13:02:56 <shachaf> CString would be the closest to C strings.
13:03:00 <nitrix> I'm just concerned about memory usage. I do not have to port anything.
13:03:01 <merijn> nitrix: Do you mean "I want high performance string manipulation" or do you mean "I need to interact with C"?
13:03:03 <athan> merijn: Ohhhhh, well either way, I like that better haha
13:03:09 <nitrix> merijn: High performance.
13:03:15 <spaceloop> monochrom: I think point refers to an argument (in mathematics, x in "f(x)" is called a point)
13:03:21 <merijn> nitrix: Right, then use Text, it's as fast a proper unicode will ever be
13:03:31 <nitrix> merijn: Appreciated, thanks.
13:04:40 <merijn> nitrix: Anything else will not deal with unicode properly
13:04:57 <merijn> spaceloop: Hence why what he said was a joke :)
13:06:59 <spaceloop> merijn: ah, I see ;)
13:08:52 <bmuk> How can I profile my code to see how much time is spent in each function?
13:09:56 <Peaker> bmuk: compile it with -auto-all -caf-all -rtsopts -prof
13:10:02 <Peaker> bmuk: then run it with +RTS -p
13:10:10 <bmuk> Peaker++
13:10:11 <athan> bmuk: `:set +s` in ghci is a quick hack
13:11:15 <bmuk> Peaker: couldn't find module Prelude?
13:11:35 <Peaker> bmuk: you need to have ghc's profiling support installed
13:11:42 <Peaker> bmuk: and the profiling support of every library dependency too
13:11:51 <Peaker> bmuk: how have you installed ghc?  apt-get?
13:11:57 <mutable> Hello. I asked this question yesterday, but got no one answsers. I saw ghc 7.8.3 compiled stuff much slower than 7.6 (like cabal install cabal-install). Is it expected?
13:12:07 <bmuk> Peaker yeah, haskell platform through apt-get
13:12:16 <Peaker> bmuk: try: apt-get install ghc-prof
13:12:27 <Peaker> bmuk: and the "-prof" version of any library package you have too
13:12:45 <Peaker> mutable: if you do apples to apples comparison and it is slower, maybe you can open a bug report?
13:13:07 <solidus-river> bmuk: if your going to be super serial about haskell it'd be worht investing the time to build ghc / haskell platform from source, the debian / ubuntu versions be a bit whack
13:13:16 <mutable> so it is not expected? I see. Let me take further look.
13:13:31 <solidus-river> bmuk: just like the debian / ubuntu versions of npm are odd
13:15:03 <Peaker> mutable: I'm not sure if it's expected, you can ask #ghc maybe
13:15:19 <bmuk> solidus-river: I'm actually using vagrant. Not sure how well it would compile in a vm, I already have trouble with cabal sometimes running out of memory
13:15:37 <solidus-river> bmuk: ouch
13:16:01 <bmuk> but, I'm using vagrant specifically to avoid cabal hell
13:16:31 <bmuk> I'm already pretty invested in Haskell and have compiled from source before, it just takes forever on real hardware, I can't imagine in a vm
13:16:55 <solidus-river> bmuk: what about cabal-sandbox's to avoid cabal hell
13:17:30 <mutable> Peaker: I guess you do not feel it is significant slower from your usage? I just want to confirm that not everybody is seeing before digging further.
13:21:25 <bmuk> I have thought of that; vagrant just seemed like a cool idea - i.e. I can share it with everyone working on a project and we will all have the same environment, same env as server, etc.
13:24:33 * hackagebot binary-list 0.2.0.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.2.0.0 (DanielDiaz)
13:29:57 <Peaker> mutable: I don't know, I haven't measured
13:30:13 <Peaker> but GHC slowness is a real pain point. I wish someone made a type-check-whole-project-and-only-then-compile switch for ghc
13:30:29 <Peaker> (now GHC has type-check only flag but it doesn't generate .hi files, so you can only do it for your dependency "leafs")
13:32:52 <felixn_> https://gist.github.com/munro/8dc88c454e25dbd32bf9 <-- crap... can someone help me with this case statement?  I feel rusty
13:34:25 <felixn> eh eh?  it should be obvious but right now I can't see what I'm doing wrong ... it's yelling at my second case
13:34:46 <joshc> felixn: the second case needs to be at the same column as the first
13:34:59 <felixn> eh eh?  it should be obvious but right now I can't see what I'm doing wrong ... it's yelling at my second case
13:35:03 <felixn> woops!
13:35:23 <felixn> joshc: ah thanks, I meant to press up enter on my terminal to rerun :)
13:35:50 <felixn> I wish that error was more obvious!
13:37:50 <frerich_> Anybody here familiar with Template Haskell? There’s an “Info” type ( http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Info ) which you get from reify’ing e.g. a type. I wonder why ‘PrimTyConI’ doesn’t  have any type variable bindings (TyVarBndr) associated with it.
13:38:00 <earnThis> Best way to learn haskell coming from a python heavy background, in your opinion
13:38:10 <frerich_> E.g. $(stringE . show =<< reify ''(->)) shows "PrimTyConI GHC.Prim.(->) 2 False"
13:38:30 <bmuk> earnThis: Learn You a Haskell. I came from the same background and it was really accessible
13:38:33 <merijn> earnThis: Same as coming from any background, Learn You a Haskell, followed by Real World Haskell and lots of confusion :)
13:38:35 <bmuk> accessable?
13:39:07 <felixn> earnThis: yes!  I agree with Learn You a Haskell ... also don't make your first project an embedded DSL ... and persitance, it will eventually click
13:39:41 <frerich_> earnThis: A lot of people seem to like this Haskell course (which involves exercises): http://www.cis.upenn.edu/~cis194/
13:39:55 <bmuk> I compiled with ghc -O2 -auto-all -caf-all -rtsopts -prof 2.lhs and then ran ./2 +RTS -p, but it didn't give me any profiling info, just the normal output
13:40:06 <earnThis> Any good open source projects that intertwine the two, python and haskell?
13:40:09 <proxfox> if I were to loop over the same action, again and again, and each time I have to load a distance matrix into an array, what array should I use, is there optimization on the compiler side which will keep the immutable array allocated or?
13:40:14 <earnThis> thanks for the suggestions as well
13:40:16 <felixn> earnThis: play with the GADT and pattern matching ... it's amazing and you won't be able to live without it (new languages like Swift, Rust, and Haxe have added this amazing feature)
13:40:50 <latk> trying to install cabal-install on a fresh ubuntu install. I get the error "Error during cabal-install bootstrap:
13:40:51 <latk> Building the Cabal package failed."
13:40:51 <dolio> bmuk: Did it complain about not having profiling for libraries?
13:40:55 <merijn> proxfox: Why not make the action a function that takes a distance matrix, load the matrix once and pass it as argument on every invocation?
13:40:59 <latk> any ideas what I've done wrong ?
13:41:04 <bmuk> dolio: no I installed them
13:41:15 <proxfox> merijn: matrix is different each iteration
13:41:20 <dolio> bmuk: Also I wouldn't recommend using -O2 during profiling. It will make the results very confusing.
13:41:20 <merijn> latk: Try again with "-v3"
13:41:42 <merijn> proxfox: Then I don't really see what keeping the array gains you?
13:41:44 <dolio> Or, can, at least.
13:42:05 <dolio> bmuk: It didn't produce any extra files?
13:42:07 <bmuk> I tried without and it didn't compile it again
13:42:11 <latk> merijn: as an argument to ./bootstrap.sh ?
13:42:27 <merijn> latk: huh? oh you don't have cabal installed yet?
13:42:28 <bmuk> dolio: no just the usual hi and object files
13:42:37 <proxfox> merijn: well, keeping the allocated array and then filling it with new values will reduce a cost of quadratic time needed to allocate a new array.. i guess?
13:42:40 <latk> merijn: Yeah
13:42:51 <dolio> Compiling with different -O flags won't recompile unless you -fforce-recomp.
13:42:53 <merijn> proxfox: Why does allocating array take quadratic time?
13:42:57 <dolio> Or different flags in general.
13:43:06 <latk> Actually, is the cabal-install in apt-get usable ?
13:43:06 <merijn> proxfox: I would expect allocation of a fixed size array to be constant time
13:43:20 <proxfox> merijn: if not allocation then garbage collection, right?
13:43:25 <dolio> bmuk: Running a binary with profiling is supposed to generate a profilng file, if I recall correctly.
13:43:41 <bmuk> dolio: I see it now (after fforce-recomp)
13:43:44 <dolio> Did it not rebuild when you use the profiling flags, maybe?
13:43:48 <merijn> proxfox: I highly doubt that too
13:43:54 <dolio> That'd be my guess.
13:44:05 <merijn> proxfox: I'd recommend a healthy dose of "profile before optimising" :)
13:44:07 <latk> apt-get cabal-install seems to be for ghc7.6.3 :s
13:44:35 <bmuk> It didn't rebuild. fforce-recomp worked just fine, I just assumed the profiling info would spit out as I run it
13:44:59 <dolio> No, it's dumped to a file, I believe.
13:45:09 <dolio> It's been a while since I profiled anything, though.
13:45:11 <bmuk> yeah, I see it now.
13:45:46 <bmuk> now only to interpret it lol
13:46:59 <nitrix> Out of curiosity, how does the `atomically` function work? What aspect of the language makes it possible and how is it implemented?
13:47:11 <proxfox> merijn: ok, i'll check it...
13:47:29 <nitrix> Usually you have mutexes or locks in one form or another, but that one seems like it's stopping the world or something.
13:47:48 <nitrix> Like a garbage collector would, just to perform the transaction :/
13:47:48 <dolio> It does not stop the world.
13:47:55 <nitrix> So how does it work? :S
13:48:01 <merijn> nitrix: I recommend reading the STM paper :)
13:48:04 <bmuk> total time 0.00 secs?
13:48:12 <merijn> nitrix: It's linked at the top of the STM docs
13:48:16 <dolio> Databases don't typically stop the world for transactions, either.
13:48:19 <nitrix> merijn: Oh okay.
13:48:25 <merijn> nitrix: It discusses the implementation and behaviour
13:48:27 <dolio> Good ones, at least.
13:48:51 <nitrix> No, but it lets you atomically work on something that might not be used atomically somewhere else.
13:49:00 <merijn> nitrix: Ah, that's not true
13:49:29 <nitrix> Well... would you actually mind looking at a function for me ?
13:49:30 <merijn> nitrix: The only mutable updates STM can make is other STM values, and STM transactions can only be run using atomically :)
13:50:24 <nitrix> merijn: So it begins with setText : https://github.com/jtdaugherty/vty-ui/blob/master/src/Graphics/Vty/Widgets/Text.hs
13:51:43 <merijn> oh, this seems to use IORef
13:52:07 <nitrix> merijn: I tried to dig it down, but I couldn't see anything for concurrency, then realised the examples all used `schedule`, which is defined here: https://github.com/jtdaugherty/vty-ui/blob/master/src/Graphics/Vty/Widgets/EventLoop.hs#L64
13:52:37 <nitrix> merijn: So, I get that these actions are performed atomically, but the rest of the code doesn't... so how is it safe :/
13:53:07 <nitrix> I also found things about channels IO chan ref or something, but I don't know enough about them, so if you wouldn't mind breifing me :X
13:53:28 <merijn> nitrix: It's writing all events into a transactional channels
13:53:51 <merijn> If all updates happen in a single thread that reads from multiple channels then it's trivially threadsafe (only one thread does updates)
13:54:54 <stalintrotsky> Is there a generalization for structures that you can count the occurences of a member in?
13:55:41 <nitrix> merijn: Mhhh, I see. They have a very interesting model.
13:55:53 <nitrix> merijn: I've never seen something like that, except maybe Go.
13:57:24 <latk> so my error doing cabal install cabal-install is : http://lpaste.net/109656
13:58:02 <latk> ubuntu 14.04
13:59:02 <int-e> latk: how much memory do you have?
13:59:17 <latk> ah good point. 512mb on this server
13:59:18 <latk> is it sufficient ?
13:59:20 <merijn> nitrix: It's a very Go/Erlang style model, yes. But haskell threads are very good at that model :)
14:00:06 <int-e> latk: that may be insufficient; at the very least, don't use -j (i.e. try -j1)
14:00:43 <latk> i wasn't :p
14:01:05 <int-e> latk: cabal-install tends to do that by default nowadays
14:01:53 <int-e> latk: You can have a look at ~/.cabal/config and see whether it has a 'jobs:' line.
14:05:29 <linman32> is glade good in gtk projects?
14:09:00 <eacameron> I just want to verify that my conclusions are correct: It seems that MVars must be used for synchronizing IO-dependent code (like synchronizing writes to a file, for example) and STM can (and often is) used for synchronizing purely in-memory structures. Is this correct?
14:13:49 <merijn> eacameron: Not really, you could use STM for the former too
14:13:51 <arianvp> I want to write a lightweight web API in haskell.  would WAI be a good choice?
14:14:09 <arianvp> the API seems pretty clean
14:14:11 <merijn> eacameron: The difference is STM lets you compose multiple TVar operations to behave as a single atomic operation
14:14:20 <eacameron> arianvp: Have you seen scotty?
14:14:25 <merijn> eacameron: Whereas MVar behaviour is independent and not composable like that
14:14:53 <dolio> The original STM didn't have anything that would qualify as a lock like MVar, I think; if that's what's necessary for synchronizing some other resource.
14:14:56 <arianvp> eacameron: sweet!
14:15:00 <dolio> But now there's TMVar.
14:15:16 <merijn> dolio: You could trivially build a lock using TVar Int where 0 == free
14:15:17 <arianvp> nice that it is WAI compactible. does this mean I can just plug in other WAI middleware like perhaps session and auth?
14:15:25 <john_not_jenny> Do you guys use GetOpt? Or does anyone have a preference among these options http://www.haskell.org/haskellwiki/Command_line_option_parsers ?
14:15:41 <dolio> Oh, I guess that's true.
14:16:18 <merijn> "atomically $ do x <- readTVar lock; writeTVar lock 1; when (x /= 0) retry" :)
14:16:26 <eacameron> merijn: How can you synchronize writes to a file with STM? I can't do IO in STM...
14:16:45 <dolio> eacameron: You use STM to build a lock.
14:16:52 <merijn> eacameron: You'd have to use atomically to actually run the STM transaction
14:17:22 <arianvp> apparently yes: https://github.com/scotty-web/scotty/blob/master/examples/gzip.hs
14:17:23 <arianvp> nice
14:17:27 <eacameron> dolio: merijn: oh, so just reproduce MVar with STM
14:17:32 <merijn> eacameron: Right
14:17:34 <arianvp> eacameron: this was exactly what I was looking for :)
14:17:36 <arianvp> thanks
14:17:48 <eacameron> arianvp: I've never used it; but I wish I did ;)
14:17:56 <merijn> eacameron: I recommend Simon Marlow's Parallel and Concurrent Haskell book :)
14:18:03 <dolio> I guess that's nice, because you can acquire multiple locks without having to worry if you wrote them in the exact same order everywhere in your code.
14:18:03 <arianvp> We're gonna use Yesod soon at work
14:18:05 <arianvp> kinda hyped
14:18:05 <merijn> eacameron: It describes various use cases in-depth :)
14:18:22 <eacameron> arianvp: nice!
14:18:24 <arianvp> haskell at work ftw
14:18:31 <arianvp> or at least. internship
14:18:35 <arianvp> but whatever :) awesome stuff
14:19:53 <luite> arianvp: the latest WAI (and thus scotty, yesod and other stuf built on it) traded some ease of use for performance, it's a bit harder to implement a middleware now
14:19:54 <eacameron> merijn: I've heard good things about it.
14:20:18 <eacameron> merijn: so then is it preferrable to make your transactions as short as possible to minimize retries?
14:20:38 <arianvp> luite: the type signatures for middleware seem to make a lot of sense to me though
14:21:34 <arianvp> but yeh. I see some stuff changed from   Yesod 1.2 to 1.4 . like WAI stopped using conduits etc
14:21:52 <luite> arianvp: the sig for middleware hasn't changed, the one for Application has
14:22:09 <arianvp> but that makes stuff easier right? at least more "framework agnostic"
14:22:09 <eacameron> merijn: `atomically $ replicateM 100 (readTMQueue queue)` might be better as `replicateM 100 (atomically $ readTMQueue queue)`
14:22:14 <arianvp> not easier, per se.
14:22:15 <merijn> eacameron: Yes
14:22:35 <merijn> eacameron: STM suffers from interference, the smaller/more local your transactions, the less overhead
14:22:49 <luite> arianvp: less conduit complexity, but the middleware has to handle chunks by itself now
14:23:42 <luite> arianvp: if your middleware is purely byte chunk oriented, then that's probably ok, but for example if you want to decode text now, your chunk might end in the middle of some utf8 encoded character
14:24:59 <luite> arianvp: so it's a bit of a tradeoff, you can still add your own state machine streaming thing on top of it of course
14:25:24 <kvelicka> hi guys. when (if ever?) is appropriate to add yourself to the authors' list for a package?
14:26:28 <arianvp> so what was the reason for this change?   not locking people into conduit?
14:26:47 <hpc> kvelicka: when you make significant improvements to the code beyond pure mainenance, imo
14:26:55 <alorente> I'm having trouble understanding what cabal claims is a version conflict. https://paste.andrewlorente.com/dojabotufo.txt It claims it can't install semigroups or conduit because they require bytestring==0.9.2.1 while this app requires bytestring>=0.10.
14:26:55 <alorente> But when I look at those packages on hackage, semigroups doesn't even depend on bytestring while conduit only declares >= 0.9 http://hackage.haskell.org/package/conduit-1.0.17.1 http://hackage.haskell.org/package/semigroups-0.15.2
14:27:01 <hpc> since the two fields that seem to be used most are author and maintainer
14:27:07 <luite> arianvp: i think the main reason was performance
14:27:16 <linman32> anyone with gtk/haskell expirience. is glade beneficial?
14:28:04 <kvelicka> hpc: hmm, so rewriting the parser that a lib uses in a rather significant way would count ritght?
14:28:06 <luite> arianvp: the ResourceT transformer was probably a limiting factor, and Kazu likes to squeeze out as much as possible :)
14:28:19 <hpc> i think so
14:28:37 <hpc> if the original author(s) are around, definitely ask them about adding yourself
14:28:48 <hpc> there might also be a relevant hackage policy somewhere
14:31:15 <dcoutts_> alorente: not totally clear, can you paste the log with cabal install --only-dependencies  -v --max-backjumps=-1
14:31:56 <arianvp> I liked the old Application signature more though :)
14:32:01 <arianvp> Request -> IO Response
14:32:05 <arianvp> that' s kinda neat.
14:32:31 <dcoutts_> alorente: it's saying that void requires the installed semigroups, which requires the older bytestring, but it's unclear yet why it cannot use a different instance of the void package
14:33:11 <napping> edwardk: asking about your "parsers" library, are you supposed to use TokenParsing by defining an instance (maybe for a newtype)?
14:33:23 <edwardk> napping: currently, yes
14:33:45 <napping> ah, maybe I should start depending on that
14:33:57 <edwardk> i'm looking to offer a stock newtype that just takes a whitespace parser as a parameter
14:34:09 <TallerGhostWalt> is there a way to mix hspec and yspec tests?
14:34:11 <alorente> dcoutts_: it's thinking...
14:34:24 <napping> I wanted a token parser with a custom choice of whitespace, ended up copying the module from parsec with changes to open up the record fixpoint
14:34:41 <bernalex> can someone tell me WTF this results in a parse error: http://lpaste.net/5573369770557833216 ? if I further indent the do-block in the let to make it indentet beyond the variable (i.e. ranges), it compiles and works. what rule am I not getting here?
14:35:11 <bernalex> I annotated it with a working version
14:35:17 <napping> bernalex: layout scopes have to be at least nondecreasing, maybe strict increasing
14:35:49 <napping> I suggest reading the algorithm in the language spec about a dozen times or so
14:36:19 <alorente> and the `let` introduces an indentation level because you could have multiple let-declarations with a single `let` keyword. `let foo=...\n    bar=...`
14:36:44 <geekosaur> it makes sense to me, let itself introduces layout and so your "do" ends o n the next line with a thing outdented from the start of the preceding let-binding
14:37:00 <geekosaur> people tend to forget that let uses layout
14:37:25 <bernalex> hey btw I answered my own question on my own while I was waiting for you guys :-P
14:37:31 <bernalex> foo = do let a = do
14:37:33 <bernalex>               putStrLn "test"
14:37:35 <bernalex>          a
14:37:38 <bernalex> writing that made me realise my folly
14:37:45 <alorente> dcoutts_: with --max-backjumps=-1 it's happy...
14:38:15 <dcoutts_> alorente: ok, so apparently it was hard to find a solution, and previously it was hitting a backtracking limit
14:38:31 <napping> bernalex: putting a { before "foo" and after the end of the do would also allow that
14:38:34 <alorente> dcoutts_: I can probably do away with the need for --max-backjumps with more version annotations in my .cabal file, right?
14:38:42 <bernalex> napping: yeah I know :-]
14:39:09 <dcoutts_> alorente: you can experiment interactively on the command line by using --constraint= flags
14:39:41 * hackagebot yesod-auth-oauth2 0.0.5.1 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.5.1 (PatrickBrisbin)
14:39:43 * hackagebot binary-list 0.2.0.1 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.2.0.1 (DanielDiaz)
14:41:19 <napping> bernalex: I wasn't sure if you knew you could use layout again within a {}
14:41:25 <alorente> thanks dcoutts_ !
14:46:49 <tlo_> hi all, newbie here. I struggle with a list of tuples: I have [(String, String)] and I want [(BC.ByteString, BC.ByteString)]. Should be easy with BC.pack :: String -> BC.ByteString. BC is: import qualified Data.ByteString.Char8 as BC. Any hints?
14:47:54 <alorente> dcoutts_: ohhh ok so after running into problems later, I think the reason it was confused was I had rmed -rf ~/.cabal, but forgot to whack ~/.ghc. So the ghc-pkg situation was all messed up
14:48:21 <hpc> tlo_: so first, you have a list that you want to do a thing to every element of
14:48:23 <hpc> :t map
14:48:24 <MitchellSalad> tlo_: you should write a function with type (String, String) -> (ByteString, ByteString) first
14:48:25 <lambdabot> (a -> b) -> [a] -> [b]
14:48:38 <hpc> and then you'll want... that
14:49:10 <hpc> there's a neat operator in Control.Arrow that you may like
14:49:22 <hpc> > (* 5) &&& (* 2) $ (2, 2)
14:49:23 <lambdabot>  No instance for (GHC.Show.Show t1)
14:49:24 <lambdabot>    arising from a use of ‘M602593781842657595818605.show_M6025937818426575958...
14:49:24 <lambdabot>  The type variable ‘t1’ is ambiguous
14:49:24 <lambdabot>  Note: there are several potential instances:
14:49:24 <lambdabot>    instance [safe] GHC.Show.Show
14:49:35 <hpc> > (* 5) *** (* 2) $ (2, 2) -- er, that one
14:49:37 <lambdabot>  (10,4)
14:49:58 <hpc> (f *** g) = "do f to the left and g to the right"
14:50:15 <tlo_> hpc: thanks, will try it!
14:50:35 <hpc> the rest is an exercise for the reader ;)
14:50:55 <ksira> Anyone know how feasible it is to stream data from a SQL database query into the pipes ecosystem, i.e. lazily?
14:51:02 <tlo_> MitchellSalad: thanks!
14:51:13 <ksira> I'm using esqueleto and persist-mysql to query at the moment.
14:51:41 <MitchellSalad> or how about lens, over both pack
15:04:38 <arianvp> anybody here worked with http://simple.cx/ ? it seems very similar to scotty
15:04:44 <tlo_> hpc: the *** operator works like a charm :) MitchellSalad: what do you mean with lens?
15:05:06 <luite> i wonder how many microframeworks we need...
15:05:15 <MitchellSalad> tlo_: i mean something like, over both pack :: (String, String) -> (ByteString, ByteString)
15:05:34 <MitchellSalad> over both pack === pack *** pack
15:05:51 <carter> luite: 7
15:06:03 <carter> no more no less
15:06:33 <luite> five is right out
15:07:17 <arianvp> 7 is about right
15:10:47 <Markzz> How would you go about creating a bytestring output from a combination of word8 and string sources?
15:11:48 <burp> you mean serialize it?
15:11:54 <dmj`> Markzz: a bytestring is just [Word8], So given a string just call Data.ByteString.pack, then you can combine them since they're monoids with (<>)
15:11:58 <dmj`> @typ BS.pack
15:12:00 <lambdabot> [Word8] -> BSC.ByteString
15:12:15 <burp> use one of the many serialization libraries
15:12:50 <dmj`> @typ Data.ByteString.Char8.pack
15:12:52 <lambdabot> String -> BSC.ByteString
15:14:14 <Markzz> I'll get back to you on that, thanks
15:14:24 <dmj`> don't listen to me, a ByteString is a pointer with an offset and length
15:14:30 <shachaf> You have to encode the String.
15:14:41 <Iceland_jack> 'pack' may truncate the values
15:14:44 <shachaf> For example which bytes do you want for the string "λ"?
15:15:15 <Markzz> I suppose I should add some context
15:15:23 <Markzz> http://pastebin.com/uSLVkYTR
15:15:31 <dmj`> what encoding are you expecting your input to be?
15:15:44 <Iceland_jack> > BSC.pack "a" == BSC.pack "š"
15:15:46 <lambdabot>  True
15:16:06 <dmj`> > Data.Text.pack "a" == Data.Text.pack "š"
15:16:08 <lambdabot>  Not in scope: ‘Data.Text.pack’Not in scope: ‘Data.Text.pack’
15:18:12 <Markzz> I just want to be able to format it to be 0x30x?,0x? text here 0x3
15:18:40 <iron_houzi> Does anybody know "The Haskell Road to Logic, Maths and Programming (Doets, van Eijck)? I have the 2004 edition and was wondering if it's worth reading it for the Haskell parts, or if it's too outdated.
15:18:45 <Markzz> obviously not the text version though
15:20:34 <hiptobecubic> iron_houzi, I have it and took a course with van Eijck at CWI. I liked it, but it's very mathy and not particularly practical if you are trying to learn how to use haskell in places you'd usually use something like python.
15:21:12 <hiptobecubic> If you like talking about closures and abstract relations then sure, it's great :D
15:21:25 <burp>  
15:21:50 <dmj`> iron_houzi: it's more of a math book
15:22:19 <hiptobecubic> iron_houzi, the title is pretty accurate i think. It's about learning logic and math through haskell, not the other way around.
15:22:42 <hiptobecubic> I did like it though, so I'd still say take a look :)
15:24:04 <athan> Talking about "Haskell road to maths..."? I really liked it
15:24:31 <athan> I actually need to re-read it :S
15:28:51 <iron_houzi> hiptobecubic: dmj`: that sounds good. I'm taking a course on formal logic which I am already aquainted with. I thought I'd try to add this book since it was recommended by my teacher, but I was a bit startled when I saw how old it was, knowing that haskell has come a long way in ten years. I just wanted to know if I can just use the haskell examples in the book without any consideration about the difference
15:28:53 <iron_houzi> between the haskell standards then and now..
15:28:56 <hiptobecubic> The course at Universiteit van Amsterdam that used it was called "software testing." The other students were mostly from the Software Engineering master and were not amused.
15:30:43 <hiptobecubic> iron_houzi, it doesn't use any crazy new haskell stuff. It's pretty straightforward, which I really liked about it.
15:31:09 <iron_houzi> thanks!
15:31:20 <hiptobecubic> iron_houzi, no need to learn lenses  :)
15:31:33 <athan> lol
15:31:37 <hiptobecubic> I think it doesn't even need ghc. hugs probably works.
15:31:44 <iron_houzi> I already did a course based on SICP, so this seems like a perfect progression
15:32:10 <iron_houzi> Yeah .. I had never heard of hugs, which just added to my worries..
15:32:27 <hiptobecubic> it works fine, it's just no longer developed.
15:32:38 <iron_houzi> is it a repl?
15:32:41 <hiptobecubic> supports Haskell98 I think? I don't know the specifics.
15:32:48 <josephle> it's an entirely different compiler, iirc
15:32:52 <hiptobecubic> Yes it's an interpreter only
15:32:53 <geekosaur> hugs was an interpreter written in ANSI C
15:32:58 <josephle> ah, an interpreter
15:33:08 <iron_houzi> Is GHC not written in C?
15:33:11 <geekosaur> so nicely portable but somewhat limited and no actual compilation to native code, it reinterprets each time
15:33:19 <geekosaur> ghc is mostly self-hosted
15:33:21 <hiptobecubic> GHC is mostly written in haskell
15:33:29 <geekosaur> some primitives are in C or Cmm
15:33:42 <hiptobecubic> geekosaur, is Cmm a thing outside of ghc?
15:33:47 <iron_houzi> wow! Perfectly functional then.
15:33:47 <hpc> the runtime is a wee bit of C, and for a while there was a terrifying piece of perl too
15:33:49 <geekosaur> yes and no
15:33:58 <merijn> hiptobecubic: Yes
15:34:22 <geekosaur> it's derived from C--, and while it started out as a more general thing I am not sure GHC speaks a standard dialect any more?
15:34:22 <merijn> hiptobecubic: C-- is defined unrelated to GHC, ghc then uses a C-- inspired dialect called Cmm
15:34:46 * hackagebot happstack-server 7.3.8 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.8 (JeremyShaw)
15:34:57 <geekosaur> (that is, I think even Cmm is not by design ghc-specific, but it is likely that ghc's own Cmm is)
15:35:06 <merijn> hiptobecubic: I'd say GHC is entirely written in haskell, the runtime system is not entirely in haskell, though :)
15:35:17 <hiptobecubic> Interesdong. I'm not familiar with C--
15:35:37 <geekosaur> it's a modern take on a systems programming language / compiler implementation language
15:35:46 <hiptobecubic> it's difficult to search for
15:35:56 <geekosaur> it's closer to the metal than e.g. C but less close than assembler
15:35:59 <merijn> I disagree, I think C-- is a modern take on an IR/assembler
15:36:14 <hiptobecubic> there we go http://www.cminusminus.org/
15:36:20 <geekosaur> http://www.cminusminus.org/
15:36:23 <merijn> Unless you have an entirely different notion of what "systems programming" means, I don't think it's suitable for that at all :)
15:36:28 <geekosaur> and, well, no. it's more like BLISS
15:37:01 <merijn> I'd be more inclined to call rust a modern take on a systems programming language
15:37:02 <hiptobecubic> This seems like llvm in a way
15:37:07 <merijn> hiptobecubic: It is
15:37:16 <merijn> hiptobecubic: In more than just a way :)
15:37:19 <geekosaur> merijn: practically, you ported an old system by porting something on the level of C-- or BLISS, used it to build the compiler and runtime and key parts of the kernel, and then wrote the rest in the real compiler
15:37:29 <stalintrotsky> when configuring dependencies in a .cabal, how safe is it to just make one just  >= version?
15:37:43 <merijn> stalintrotsky: Opinions differ :)
15:38:59 <hamishmack> linman32: I have not used glade much myself.  But I can say that libglade (and therefor the glade haskell package) have been replaced by GtkBuilder (which is included in the gtk and gtk3 haskell packages)
15:39:20 <hamishmack> linman32: You can use the glade app to make the GtkBuilder files
15:39:26 <ksira> So, does anyone have experience streaming from a DB using pipes? Or should I ask on SO.
15:39:41 <geekosaur> probably better asked on SO or -cafe
15:39:46 * hackagebot happstack-server-tls 7.1.3 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.3 (JeremyShaw)
15:39:48 * hackagebot spice 0.1.2.1 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.1.2.1 (Crockeo)
15:39:50 * hackagebot binary-list 0.2.0.2 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.2.0.2 (DanielDiaz)
15:40:26 <hamishmack> linman32: http://hackage.haskell.org/package/gtk3-0.13.0.0/docs/Graphics-UI-Gtk-Builder.html
15:40:47 <ksira> yeah, I have big data problems. :P
15:41:46 <hamishmack> linman32: Examples are https://github.com/gtk2hs/gtk2hs/tree/master/gtk/demo/gtkbuilder and https://github.com/gtk2hs/gtk2hs/tree/master/gtk/demo/filechooser
15:42:15 <linman32> hamishmack: is using a UI designer such as glade a good idea for GUI projects?
15:43:45 <linman32> hamishmack: the filechooser app never built after "cabal configure -fbuild-demos"
15:44:01 <linman32> hamishmack: and then "cabal build"
15:44:43 <ksira> linman32: It worked fine last time I tried it, this was with gtk3.
15:45:03 <ksira> linman32: using glade I mean.
15:45:58 <hamishmack> I think it depends a lot on the application.  I think sometimes you wind up needing to write code to spin up the UI and it can be nicer to have it all in one place.
15:46:45 <hamishmack> But even then playing with glade is a good way to learn what UI components are available and how to lay them out.
15:47:04 <john_not_jenny> Is there somewhere that lists the differences between the different version of the base library?
15:47:05 <hamishmack> filechooser may not be in the .cabal file
15:47:43 <hamishmack> Javran only fixed it up recently
15:47:56 <dmj`> john_not_jenny: https://github.com/blitzcode/hackage-diff
15:48:16 <john_not_jenny> Great thanks dmj`
15:48:18 <dfrey> Hi, I have a newbish question.  The example is contrived to avoid a lengthy backstory.  Say you have a function gt5 n = n > 5 and another lt8 n = n < 8.  Now say I want to create a gt5AndLt8 function.  I know that I can do gt5AndLt8 n = (&&) (gt5 n) (lt8 n), but I feel like there should be a more abstract concept so that I can just do something like gt5AndLt8 = combine (&&) gt5 lt8   What is the concept that
15:48:20 <dfrey> I'm missing?
15:48:38 <hamishmack> linman32: Makefile in the filechooser dir should work
15:48:40 <Iceland_jack> dfrey: you can use 'liftA2'
15:49:22 <linman32> ksira, hamishmack: there are executables under demo/dist for demos, but not filechooser
15:49:34 <Iceland_jack> but in reality you wouldn't create special functions for gt5, lt8, ...
15:49:35 <linman32> hamishmack: gtk3.cabal has filechooser in it
15:49:51 <dfrey> Iceland_jack: like I said, it's contrived
15:49:54 <linman32> hamishmack: how do i use makefile in filechooser?
15:49:55 <Iceland_jack> @pl \n -> gt5 n && lt8 n
15:49:55 <lambdabot> liftM2 (&&) gt5 lt8
15:50:08 <sipa> @define gt5 = (> 5)
15:50:11 <lambdabot>  Defined.
15:50:13 <Iceland_jack> dfrey: use liftM2 or liftA2 or
15:50:13 <Iceland_jack>     (&&) <$> gt5 <*> lt8
15:50:18 <FreeFull> liftM2 and liftA2 are identical there
15:50:20 <sipa> @define lt8 = (< 8)
15:50:22 <lambdabot>  Defined.
15:50:28 <dmj`> > (&&) <$> (>5) <*> (<8) $ 6
15:50:30 <lambdabot>  True
15:50:38 <sipa> > liftA2 (&&) lt8 gt5 3
15:50:41 <lambdabot>  False
15:50:44 <sipa> > liftA2 (&&) lt8 gt5 7
15:50:46 <lambdabot>  True
15:50:47 <sipa> > liftA2 (&&) lt8 gt5 9
15:50:48 <FreeFull> <*> is ap
15:50:49 <lambdabot>  False
15:51:09 <FreeFull> > (ap (fmap gt5) (lt8)) 6
15:51:10 <hamishmack> linman32: You could add an “Executable” here https://github.com/gtk2hs/gtk2hs/blob/master/gtk/gtk3.cabal#L392
15:51:10 <lambdabot>  No instance for (GHC.Classes.Ord a0) arising from a use of ‘L.gt5’
15:51:10 <lambdabot>  The type variable ‘a0’ is ambiguous
15:51:10 <lambdabot>  Note: there are several potential instances:
15:51:10 <lambdabot>    instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a)
15:51:10 <lambdabot>      -- Defined in ‘base:GHC.Real’
15:51:11 <dmj`> > (&&) `fmap` (>5) `ap` (<8) $ 6
15:51:12 <dfrey> sipa, Iceland_jack: Thanks.  I will do some reading on this
15:51:13 <lambdabot>  True
15:51:19 <hamishmack> linman32: Like the other ones
15:51:33 <FreeFull> > (ap (fmap gt5) (lt8)) (6 :: Integer)
15:51:35 <lambdabot>  Couldn't match type ‘GHC.Types.Bool -> a0’
15:51:35 <lambdabot>                with ‘GHC.Integer.Type.Integer’
15:51:35 <lambdabot>  Expected type: GHC.Integer.Type.Integer
15:51:35 <lambdabot>                 -> GHC.Types.Bool -> GHC.Types.Bool
15:51:35 <lambdabot>    Actual type: (GHC.Types.Bool -> a0)
15:51:40 <FreeFull> Ugh, I'm doing something wrong
15:51:51 <Iceland_jack> FreeFull: where is (&&)?
15:51:51 <phaskell> No symbol '(&&)' found anywhere.
15:52:01 <FreeFull> Oh, you're right
15:52:12 <hamishmack> linman32: But running make in the filechooser dir should also work
15:52:15 <Iceland_jack> > ap ((&&) . (> 5)) (< 8) 6
15:52:16 <lambdabot>  True
15:52:18 <FreeFull> > (ap (fmap (&&) gt5) (lt8)) (6 :: Integer)
15:52:20 <lambdabot>  True
15:52:30 <FreeFull> Unnecessary brackets too
15:52:36 <dmj`> :t Data.Bool.(&&)
15:52:38 <FreeFull> > (ap (fmap (&&) gt5) lt8) 6
15:52:38 <lambdabot> Not in scope: data constructor ‘Data.Bool’
15:52:39 <lambdabot>  True
15:52:43 <FreeFull> > (ap (fmap (&&) gt5) lt8) 4
15:52:45 <lambdabot>  False
15:54:25 <linman32> hamishmack: how do you run make?
15:55:34 <hamishmack> linman32: cd demo/filechooser && make
15:56:39 <hamishmack> linman32: Then ./filechooser to run it
15:57:32 <linman32> hamishmack: it worked thanks!
16:05:52 <linman32> hey are there any good graph databases for haskell?
16:06:50 <athan> linman32: The only graph database I've heard of is titan :/
16:06:58 <athan> and it's not in haskell ://
16:08:17 <merijn> IMO, there are no good graph databases :p
16:08:52 <dmj`> linman32: you can serialize a graph and save it to disk if its pure.
16:08:59 <merijn> errr, I mean, the only good one is the one I'm paid to help implement, of course ;)
16:09:31 <merijn> dmj`: That hardly qualifies as "good"
16:09:49 * hackagebot clckwrks 0.22.4 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.22.4 (JeremyShaw)
16:09:52 <dmj`> merijn: well, that leads me to my next point. Data.Graph + acid-state == graph database
16:09:54 <dmj`> :)
16:09:56 <merijn> The query time would suck :)
16:10:15 <merijn> dmj`: Maybe, if you only want trivial graphs :)
16:10:33 <dmj`> merijn: if you didn't implement bfs right then yes :P
16:12:12 <linman32> so in general there aren't many good graph databases? or just to plug into haskell?
16:13:03 <merijn> linman32: I'm talking in general
16:13:17 <merijn> linman32: It depends, how big a graph are we talking? :)
16:13:49 <merijn> hundreds of vertices? thousands? millions?
16:14:01 <merijn> How many edges? hundreds? thousands? millions?
16:14:03 <hpc> hundreds, thousands, nay dozens of nodes!
16:14:17 <merijn> hpc: That's how I feel
16:14:33 <merijn> hpc: distributed graph processing! graphs bigger than main memory!
16:14:44 <pavonia> Hundreds of thousands of millions!
16:14:57 <merijn> hpc: Meanwhile, our biggest test graph is a paltry 10 GB and our cluster nodes have like 256 GB RAM :)
16:15:06 <carter> merijn: matrices!
16:15:12 <hpc> wow, that's almost webscale
16:15:16 <carter> lameeeeee
16:15:25 <carter> :)
16:15:44 <carter> merijn: you need to get some ecommerce id X product rating sparse graph
16:15:50 <merijn> carter: Arguably our graph processing engine is a sparse matrix computation :)
16:15:56 <carter> probs
16:16:25 <carter> but only transitive path queries + transtive closure and neighborhods right?
16:16:37 <merijn> Except we're cooler than you, 'cause ours is distributed!
16:16:58 <rom1504> DBpedia needs 50Go of diskspace (with virtuoso)
16:17:17 <rom1504> and freebase is much bigger
16:17:20 <linman32> merijn: i'm not sure. i've heard good things about graph database, so trying to avoid sql
16:17:30 <carter> merijn: but your graphs fit in ram :P
16:17:35 <hpc> i like sql
16:18:19 <merijn> carter: No, we support writes/reads from/to arbitrary nodes
16:18:29 <carter> no what?
16:18:32 <carter> ahhh
16:18:39 <carter> oh
16:18:47 <carter> so kinda OLTP rather than OLAP?
16:18:51 <linman32> merijn: i don't know haha. maybe there is some basic graph database software i can use in meantime?
16:18:55 <merijn> "not just transitive path, closures and neighborhood" :)
16:18:55 <carter> or  is there a write log
16:19:07 <carter> linman32: whats your problem domain?
16:19:14 <merijn> carter: Let me lookup what those acronyms mean :)
16:20:23 <merijn> carter: Well, we just treat remote writes as mappend for some monoid :)
16:20:36 <carter> merijn: so you have a WALL that turns into a bulk insert
16:20:41 <carter> *WAL
16:21:03 <merijn> carter: Actually, I have no clue how much implementation details I'm allowed to discuss xD
16:21:06 <linman32> carter: not sure... doing a startup and looking for problem stage
16:21:15 <carter> linman32: :)
16:21:18 <carter> merijn: :P
16:21:19 <merijn> carter: There's a paper coming up in ASPLOS
16:21:49 <merijn> carter: I'm not allowed to circulate preprint, though
16:22:15 <carter> merijn: well, once things aren't secret lemme know
16:22:21 <carter> till then i'll assume its boring :)
16:22:56 <merijn> carter: It's essentially BSP, with arbitrary reads/writes and no consistency guarantees between barriers
16:23:16 <merijn> So kinda lika OpenMP, but distributed
16:23:28 <carter> so it like distributed sqlite
16:24:35 <merijn> We don't have transactions and locking, though. sqlite does, I think?
16:25:39 <linman32> carter, merijn: are there any good online tutorials for graph database?
16:25:51 <carter> linman32: how big are your graphs
16:27:03 <linman32> carter, merijn: no secrets. do something along the lines of medical data storage. like patient record keeping, EHR, etc
16:27:31 <linman32> carter, merijn: short term, the graphs are probably going to be pretty small, i imagine
16:27:52 <carter> linman32: then just use an in memory graph lib
16:30:29 <linman32> carter, merijn: is there a library for that?
16:30:40 <carter> linman32: for generic graphs
16:30:44 <carter> ?
16:30:54 <linman32> carter: yes
16:31:03 <carter> theres a few on hackage
16:31:07 <carter> fgl is kinda neat
16:41:38 <dmj`> > round 2.5
16:41:39 <lambdabot>  2
16:41:42 <dmj`> :(
16:47:56 <merijn> dmj`: round follows IEEE 754 rounding
16:47:59 <merijn> i.e. bankers rounding
16:48:07 <merijn> > round 3.5
16:48:09 <lambdabot>  4
16:50:24 <pavonia> @check (\x -> round x == truncate (x + 0.5))
16:50:26 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 10 shrinks):
16:50:26 <lambdabot>  -0.5000009017777127
16:51:31 <pavonia> > let x = -0.5000009017777127 in (round x, truncate $ x + 0.5)
16:51:33 <lambdabot>  (-1,0)
16:52:49 <pavonia> @check (\x -> (x > 0) ==> round x == truncate (x + 0.5))
16:52:50 <lambdabot>  +++ OK, passed 100 tests.
16:53:10 <merijn> > round 2.5 == truncate (2.5 + 0.5)
16:53:13 <lambdabot>  False
16:53:20 <merijn> Boom, another counter example :)
16:53:30 <pavonia> :(
16:53:44 <hpc> fun fact: IEEE float is optimized for `compare`
16:53:57 <merijn> Banker's rounding rounds x.5 to nearest even
16:54:07 <hpc> it's the only operation that isn't atrocious to implement
16:54:16 <merijn> So 50% of x.5 gets rounded up and 50% gets rounded down
16:54:25 <merijn> Thus it is "fairer" than other rounding schemes
16:54:45 <pavonia> > round 2.5
16:54:47 <lambdabot>  2
16:54:56 * hackagebot binary-list 0.2.0.3 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.2.0.3 (DanielDiaz)
16:55:01 <pavonia> Wow, I didn't know that
16:55:11 * geekosaur would suspect that the idea is defeated by binary vs. decimal
16:55:27 <vanila> its nothing to do with base
16:55:38 <geekosaur> that is, 2.5 is actually 2.499999999999999999 when you represent it in binary floating point
16:55:50 <hpc> 0.5 is 0.1 in binary, so it's fairly convenient
16:55:53 <merijn> geekosaur: That only applies to float
16:56:13 <merijn> > round (5 % 2)
16:56:15 <lambdabot>  2
16:56:36 <pavonia> > round 3.5
16:56:37 <lambdabot>  4
16:57:09 <chrisdotcode> is there a flipped version of fmap/<$> available?
16:57:18 <chrisdotcode> something like <$$>?
16:57:23 <hpc> :t (<$$>)
16:57:25 <lambdabot>     Not in scope: ‘<$$>’
16:57:25 <lambdabot>     Perhaps you meant ‘<$>’ (imported from Control.Applicative)
16:57:26 <chrisdotcode> (cause there's <**>)
16:57:30 <chrisdotcode> Yeah,, I thought so too
16:57:32 <hpc> @hoogle (<$$>)
16:57:34 <chrisdotcode> Doesn't exist, seemingly.
16:57:35 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
16:57:35 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
16:57:41 <hpc> hmm
16:57:41 <chrisdotcode> Yet <**> exists.
16:57:45 <chrisdotcode> Weird, right?
16:57:51 <pavonia> So is this rounding scheme intentionally or is it implied by the way the number is represented internally?
16:57:59 <MitchellSalad> but wouldn't <$$> just be `fmap`?
16:58:12 <MitchellSalad> oh flipped fmap
16:58:17 <chrisdotcode> MitchellSalad: it's (flip fmap)
16:58:19 <hpc> i miss cale-flip
16:58:20 <dibblego> @type (&)
16:58:21 <lambdabot> a -> (a -> b) -> b
16:58:25 <dibblego> @type (<&>)
16:58:26 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:58:33 <dibblego> @type flip fmap
16:58:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:58:38 <hpc> :t (>>>)
16:58:39 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
16:58:43 <djahandarie> I still cale-flip whenever I'm angry and he's in proximity.
16:58:47 <hpc> fsvo cat ;)
16:59:19 <chrisdotcode> Is <&> in lens?
16:59:26 <dibblego> yes
16:59:44 <chrisdotcode> *sighs*.
16:59:53 <chrisdotcode> Thanks everyone, though.
17:00:05 <Algebr> is there something like case foo@(sqrt x) of
17:00:11 <dibblego> you're writing haskell without lens? sorry to hear that
17:00:37 <merijn> Algebr: What would that do?
17:00:50 <Algebr> >give me a handle on whatever the result of sqrt x was
17:00:58 <dibblego> Algebr: let foo = sqrt x
17:00:58 <merijn> pavonia: The rounding scheme is intentional
17:01:00 <hpc> i bet you also write javascript without jquery, ruby without rails, your bike with no handlebars
17:01:15 <chrisdotcode> Nothing that needs lens yet.
17:01:41 <glguy> just empty files?
17:01:47 <merijn> pavonia: Like I said, it's the "fairest" rounding for x.5, others will be biased in the way they round x.5 (i.e. always rounding up biases how many values get rounded up)
17:01:50 <chrisdotcode> hahah
17:02:05 <dibblego> just import statements prolly
17:02:07 <chrisdotcode> come to think of it, lens might simplify my code a lot, currently.
17:02:14 <merijn> pavonia: Note, that this behaviour is *only* for x.5, x.51 or x.49 get rounded as expected
17:02:15 <chrisdotcode> But I'm scared of learning lens because of the type signatures
17:02:21 <merijn> > round 2.5
17:02:23 <lambdabot>  2
17:02:26 <merijn> > round 2.5000000000000000001
17:02:28 <lambdabot>  2
17:02:37 <merijn> hmm, float problems? xD
17:02:42 <ReinH> :p
17:02:45 <merijn> > 2.5 == 2.5000000000000000001
17:02:47 <lambdabot>  True
17:02:50 <merijn> argh
17:02:53 <ReinH> lmao
17:02:55 <hpc> i thought i could learn lens better if i went deep into perl and forgot about type signatures
17:02:55 <merijn> > round 2.5000000000001
17:02:57 <lambdabot>  3
17:03:00 <hpc> but perl is still too typed
17:03:00 <merijn> There we go
17:03:05 <ReinH> Floating point numbers, everyone.
17:03:15 <pavonia> merijn: Yeah, I'm reading about it right now. What do you call the other rounding method, i.e 0.5 ==> 1.0?
17:03:26 <chrisdotcode> hpc: hahaha
17:03:45 <merijn> pavonia: Depends, are you talking "0.5 ==> 1.0 && -0.5 ==> 0" or... ?
17:03:58 <theshadow> I'm new to haskell and I'm reading Learn you a haskell. Type classes. Let me see if I get this. They're not like java interfaces as the bug says they are. They are constraints applied to a type variable. E.g. Eq a means that all instances of a must be the same type. Is this correct?
17:04:23 <merijn> theshadow: Well, it says there is ONE 'a' and it is an instance of Eq
17:04:24 <MitchellSalad> Eq a means a must be declared an instance of Eq
17:04:24 <pavonia> merijn: I'm not sure about negative numbers. I mean the version you usually learn in school
17:04:43 <merijn> pavonia: I forget it's name :)
17:04:49 <merijn> Wikipedia probably knows
17:05:06 <pavonia> merijn: In German it's called "Kaufmännisches Runden" (merchant's rounding)
17:05:40 <merijn> theshadow: I prefer to read type signatures like "(==) :: Eq a => a -> a -> Bool" as "IF 'a' is an instance of Eq, THEN (==) has type 'a -> a -> Bool'"
17:05:41 <pavonia> which is confusing becaue banker's rounding seems to be the opposite :)
17:05:42 <theshadow> (Eq a) => a -> Bool is then saying that a must an instance of Eq and this function will return a Bool?
17:06:17 <merijn> theshadow: The implicit "else" branch is that "IF 'a' is NOT an instance of Eq, then it's a type error"
17:06:31 <theshadow> right no matching function with that type
17:06:35 <merijn> theshadow: Yes, that's exactly what it means
17:08:58 <merijn> theshadow: In some ways typeclasses are a *bit* like interfaces, but they let you encode some things that interfaces can't. For example, the notion of a multi-type interface makes little sense
17:09:51 <merijn> theshadow: Whereas the following (this requires a haskell extension, but it's meaning should be obvious) does make sense with typeclasses: "convert :: Convertible a b => a -> b"
17:10:06 <theshadow> merijn: Though abstractly that makes sense I think I need to read a little more. Right now my brain is performing mental gymnastics trying to find an analogous idea for what I'm reading now.
17:10:25 <theshadow> That does make sense
17:10:41 <theshadow> It's kind of like saying if you can "cast" this thing to that thing then you can convert it
17:11:02 <merijn> theshadow: Right and you'd then write instances like "instance Convertible Char Int where ..."
17:11:30 <merijn> theshadow: Another interesting difference is the existence of polymorphic values, like
17:11:33 <merijn> :t maxBound
17:11:35 <lambdabot> Bounded a => a
17:11:43 <merijn> > maxBound :: Char
17:11:44 <lambdabot>  '\1114111'
17:11:47 <merijn> > maxBound :: Bool
17:11:49 <lambdabot>  True
17:11:56 <merijn> > maxBound :: Int
17:11:58 <lambdabot>  9223372036854775807
17:12:37 <theshadow> I'm assuming maxBound returns the maximum value of a thing
17:12:40 <merijn> theshadow: Or functions polymorphic in their return value, such as "read :: Read a => String -> a", interfaces can't really be polymorphic in their returns
17:12:46 <merijn> theshadow: Yes
17:13:01 <merijn> Although read is a bit evil, readMaybe is better
17:13:04 <merijn> :t readMaybe
17:13:05 <lambdabot> Not in scope: ‘readMaybe’
17:13:13 <exio4> reads?
17:13:17 <merijn> :t Text.Read.readMaybe
17:13:18 <lambdabot> Read a => String -> Maybe a
17:13:24 <merijn> exio4: reads sucks :)
17:13:35 <merijn> exio4: Since 7.6 there's a readMaybe in base, it's much easier :)
17:13:40 <theshadow> OK, head is spinning. Let me finish this chapter where things still make some sense.
17:13:42 <exio4> oh, 7.6
17:13:53 <merijn> > Text.Read.readMaybe "1" :: Maybe Int
17:13:55 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
17:14:08 <merijn> awww
17:15:25 * tabemann_ is wondering which is better to use, a Reader monad or implicit parameters
17:15:47 <Algebr> can ghci do what ocaml's top level can do via #trace?
17:15:57 <hpc> never implicit parameters
17:16:08 <merijn> Algebr: ghci has a complete tracing debugger, so probably?
17:16:19 <merijn> Algebr: It's a bit hard to follow, so no one uses it much, but...
17:16:29 <merijn> (due to lazy evaluation)
17:16:32 <Algebr> k
17:16:42 <merijn> Consult GHC manual for details ;)
17:17:06 <WraithM> tabemann_: Reader is certainly more standard. I've never seen implicit parameters. I'd very readily believe hpc in saying never implicit parameters.
17:17:42 <theshadow> So plain ol' read is kind of like itoa, itoa, etc.. basically (but not really) an eval and typer inferred value
17:17:52 <tabemann_> hpc: I've heard that implicit parameters are evil, but the main bad thing about them I can see is them infesting type signatures
17:18:25 <hpc> they're not composable
17:18:40 <theshadow> nvm I get this part now.
17:19:08 <merijn> Hmm, I remember seeing atomic CAS for IORefs somewhere? Anyone know which library I want?
17:19:23 <hpc> at best, it's a really backwards form of Reader, as you intend to use it
17:19:26 <merijn> theshadow: The implementation you want gets inferred by type, yeah :)
17:19:34 <hpc> at worst, it's dynamic scoping
17:19:35 <merijn> > read "1" :: Int
17:19:38 <lambdabot>  mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
17:19:43 <merijn> heh
17:19:45 <theshadow> yea that part cleared it up read "1" doesn't tell read what to do with "1"
17:19:46 <merijn> > read "1" :: Int
17:19:48 <lambdabot>  1
17:19:59 <merijn> > read "1" :: Bool -- whoops
17:20:01 <lambdabot>  *Exception: Prelude.read: no parse
17:20:26 <merijn> theshadow: That last one is why you want Text.Read.readMaybe :: Read a => String -> Maybe a :)
17:20:42 <merijn> Which would return "Just 1" and "Nothing" respectively
17:21:04 <nicoo> merijn: I never got why there is a read at all. readMaybe is so much nicer :o
17:21:15 <theshadow> Because they had to start somewhere :P
17:21:34 <theshadow> Then you realize you could do better but need to maintain backwards compatibility
17:21:44 <theshadow> Welcome to the evolution of programming languages
17:21:50 <tabemann_> because there are a good few misguided partial functions in the prelude
17:22:38 <tabemann_> at one time back in prehistory they must have not realized that partial functions are a bad thing
17:22:46 <merijn> nicoo: Hysterical raisins :)
17:23:15 <nicoo> ><'
17:23:37 <merijn> But yes, I also think tail and head should be "[a] -> Maybe [a]" and "[a] -> Maybe a"
17:24:12 <theshadow> What is Maybe? I haven't seen that yet.
17:24:27 <merijn> theshadow: "data Maybe a = Just a | Nothing"
17:24:42 <theshadow> Ah, It's this or it's Nothing
17:25:09 <XniX23> how should i think about this: l = ["a", "b"]; combinations = l <<= (\c -> return (l ++ "1")) ? why do i get all the combinations?
17:25:17 <merijn> theshadow: Right, it's instead of using, say, null pointers to indicate absence
17:25:38 <XniX23> >>= *
17:25:55 <merijn> XniX23: Maybe this is a hint
17:25:58 <merijn> :t (>>=)
17:26:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:26:03 <merijn> :t flip concatMap
17:26:04 <lambdabot> [a] -> (a -> [b]) -> [b]
17:26:05 <tabemann_> why even have tail and head and instead force the user to use pattern matching?
17:26:19 <merijn> XniX23: Compare those two types :)
17:26:20 <dibblego> @type _head
17:26:21 <lambdabot> (Cons s s a a, Applicative f) => (a -> f a) -> s -> f s
17:27:25 <exio4> tabemann_: map head [[1,2,3], [4,5,6]]?
17:28:04 <tabemann_> tis true
17:28:20 <haasn> > [x | x:_ <- [[1,2,3],[4,5,6]] ]
17:28:22 <lambdabot>  [1,4]
17:29:03 <tabemann_> okay, I am gonna head out
17:30:13 <bmuk> I believe I need a mutable map. I'm not sure; maybe the state monad would be what I need? I'm trying to write a function that tests whether something is prime. The best way to do this that I know of is to check whether it is divisible by any prime p such that p <= sqrt n. Obviously I would need to maintain some sort of cache which would store prime numbers. I would also like to memoize the function so that if I ask it for a number I've
17:30:13 <bmuk> already asked for, it won't have to do the computation again. What is the best way to go about this?
17:33:08 <nicoo> bmuk: You can also do something like « primes a:b = a : primes (filter (\x -> x `mod` a <> 0) b) »
17:33:53 <bmuk> :t (<>)
17:33:54 <lambdabot> Monoid m => m -> m -> m
17:34:03 <nicoo> i.e. remove multiples as you go (except that it gets stored as a thunk, since it is lazily evaluated)
17:34:15 <nicoo> bmuk: It is “not equal”
17:34:30 <jophish> nicoo, are you sure about that?
17:34:34 <bmuk> nicoo: I thought /= was not equal
17:34:40 <jophish> because I think <> is mappend
17:34:58 <josephle> nicoo: that is true in SML...
17:35:19 <nicoo> josephle, bmuk : Then I'm tired enough to get confused with ML notation
17:35:32 <nicoo> josephle: It's true in OCaml too
17:35:40 <bmuk> haha it's all good :)
17:35:42 <nicoo> bmuk: Anyways, I meant /=
17:35:43 <josephle> ah, I wasn't sure if it was
17:37:01 <bmuk> so that will build an infinite list of primes; so I would only need to check if a number was in that list. Will it cache results, or does it have to evaluate the list every time it is needed?
17:37:40 <kini> is there some convenient library function that is basically "foo f x = do y <- get ; f y x" ?
17:38:06 <nicoo> bmuk: If you apply primes only once (i.e. bind its result somewhere), the list will be kept and lazilly evaluated
17:38:17 <hpc> @pl \f x -> do {do y <- get ; f y x}
17:38:18 <lambdabot> (line 1, column 12):
17:38:18 <lambdabot> unexpected '{'
17:38:18 <lambdabot> expecting variable, "(", operator or end of input
17:38:24 <hpc> @pl \f x -> do {y <- get ; f y x}
17:38:24 <lambdabot> (line 1, column 12):
17:38:24 <lambdabot> unexpected '{'
17:38:24 <lambdabot> expecting variable, "(", operator or end of input
17:38:26 <hpc> :(
17:38:51 <nicoo> @pl \f x -> get >>= \y -> f y x
17:38:51 <lambdabot> ((get >>=) .) . flip
17:39:03 <nicoo> :t ((get >>=) .) . flip
17:39:04 <lambdabot> MonadState a1 m => (a1 -> a -> m b) -> a -> m b
17:39:57 <kini> :t \f x -> do y <- get ; f y x
17:39:59 <lambdabot> MonadState t m => (t -> t1 -> m b) -> t1 -> m b
17:40:04 <kini> doesn't like {} for some reason
17:40:17 <kini> :t \f x -> do y <- get ; liftIO (f y x)
17:40:21 <lambdabot> (MonadState t m, MonadIO m) => (t -> t1 -> IO b) -> t1 -> m b
17:40:48 <kini> oh well, I might as well define such a function myself I suppose
17:40:51 <josephle> @pl \f x -> do y <- get; f y x
17:40:51 <lambdabot> (line 1, column 20):
17:40:51 <lambdabot> unexpected ';'
17:40:51 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
17:40:56 <josephle> :(
17:41:06 <kini> you need a space before the ; for some reason
17:41:14 <kini> oh, that's @pl
17:41:22 <kini> @pl \f x -> do y <- get ; f y x
17:41:22 <lambdabot> (line 1, column 21):
17:41:22 <lambdabot> unexpected ';'
17:41:22 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
17:41:30 <kini> strange, what was it that needed spaces before semicolons, then...
17:41:34 <josephle> ?undo \f x -> do y <- get ; f y x
17:41:34 <lambdabot> \ f x -> get >>= \ y -> f y x
17:41:52 <josephle> can we do ?undo >>= @pl? :)
17:42:19 <bmuk> nicoo: let's say a have a isPrime function which is just isPrime x = x `elem` primes. I would be making thousands of calls to isPrime, probably iterating over the same numbers plenty of times. GHC is smart enough that it will cache the results of these calls?
17:42:25 <pavonia> @@ @pl @undo \f x -> do y <- get ; f y x
17:42:25 <lambdabot>  ((get >>=) .) . flip
17:42:37 <josephle> pavonia: oh, neat!
17:43:08 <hpc> bmuk: you have to write your function such that it can keep track
17:43:13 <hpc> @hoogle memoize
17:43:19 <lambdabot> package memoize
17:43:21 <lambdabot> package array-memoize
17:43:23 <lambdabot> package io-memoize
17:43:35 <hpc> check out that package for stuff that will do it for you
17:43:44 <hpc> or there's a page on the wiki that covers the general pattern
17:44:39 <bmuk> I see that it's (for fib) something like memo_fib = (map fib [0..] !!)
17:46:48 <bmuk> so I could do isPrimeMemoized = (map isPrime [2..] (flip elem))?
17:47:24 <joelteon> bmuk, couldn't you get better performance than `elem' out of a HashSet?
17:48:37 <bmuk> I asked about using a map earlier; would I have to use State? I've never used Maps in haskell
17:49:04 <joelteon> nah, a HashSet would look a lot like a list
17:49:14 <joelteon> except that you'd create one using H.empty, add elements using H.insert
17:49:42 <joelteon> instead of [] and (:)
17:50:02 <joelteon> but the member check would be a lot faster for lots of primes
17:50:44 <bmuk> Constant time, right? Do you insert a tuple for relation?
17:50:56 <joelteon> no, you'd do that in a Map, but a Set is just the elements
17:51:02 <joelteon> Set a is like Map a ()
17:52:01 <bmuk> Is this set immutable?
17:52:09 <joelteon> yeah
17:52:15 <joelteon> insert returns a new set
17:52:56 <bmuk> But obviously ghc stores immutable objects really efficiently?
17:53:16 <joelteon> yeah
17:54:15 <bmuk> I've been getting into algorithms and complexity lately; before I would just write the simplest answer and call it a day. Forgive all my questions about performance. lol
17:55:47 <joelteon> rule of thumb for haskell: [a] is very, very rarely the *best* answer
17:56:00 <carter> van em boas tressss
17:56:06 <carter> *treees
17:56:43 <bmuk> joelteon: that's because [a] is a linked list?
17:56:48 <joelteon> yeah
17:56:59 <joelteon> super easy to pattern match on though, for sure
17:57:22 <carter> it winds up being that [a] is better as a pure streaming constrol structure
17:57:25 <carter> than as  data structure
17:57:34 <carter> excep when its good :)
17:57:53 <bmuk> I've heard (on the haskell cast) that strictness comes into play a lot with optimizations as well, but also that laziness can be used as an advantage.
17:58:00 <carter> both are great
17:58:04 <carter> use them together and wisely
17:58:22 <carter> like, laziness is great for DSLs that have a specificational flavor
17:58:32 <carter> Eg: recursive grammars via parser combinators
17:59:22 <bmuk> Every time I think I pretty much understand programming something else comes along and there's this whole world of knowledge I hadn't even considered before.
17:59:47 <carter> fun :)
18:02:20 <etandel> so, I have to fix a bug on a query dealing with 9 tables and the guy who wrote it no longer works at the company. Any suggestions?
18:02:32 <etandel> btw, the db is not normalized
18:02:44 <geekosaur> sql might be better asked about elsewhere
18:03:19 <carter> etandel: hire the guy
18:03:20 <carter> again
18:03:31 <carter> and pay him to document stuff :)
18:03:38 <etandel> =D
18:04:08 <carter> or make sure you get paid when you document your stuff :)
18:04:36 <etandel> I'd think documentation is expected, not a bonus.
18:04:45 <carter> depends on the org!
18:05:05 <carter> the business folks don't care abou that, just whether tings work :)
18:05:55 <etandel> well, in this org, it barely exists. =/
18:06:30 <carter> clearly you need to educate the business folks about the costs in product evolution velocity if you dont docuemnt :)
18:07:57 <etandel> been there. But things are a lot better now; when I joined there wasn't a single automated test for the project.
18:08:37 <carter> woah
18:08:49 <carter> i'm not paid to write tests, i'm just paid to ship ship ship :)
18:08:56 <carter> cool :)
18:09:30 <proxfox> I'm iteratively reading data, storing it into immutable array and only reading, what can I do to speed up the computation since I've noticed that the array isn't reused but created on each iteration which slows computation...
18:09:46 <carter> proxfox: build it once :)
18:09:52 <carter> or use a mutable array
18:09:53 <carter> well
18:10:00 <carter> can you use an unboxed/storable array?
18:10:03 <proxfox> carter: how to build it once?
18:10:10 <carter> idk
18:10:15 <carter> depends on what your'e doing
18:10:19 <proxfox> carter: I'm using Data.Array.Unboxed
18:10:22 <carter> ok
18:10:27 <carter> you could use a mutable array
18:10:31 <carter> and overwrie
18:10:36 <carter> why do you nee it in an arary?
18:11:55 <proxfox> carter: I'm doing a bfs over the landscape, on each iteration landscape changes, I'm checking if neighbors are valid, to do it in constant time I use the array
18:12:23 <proxfox> carter: but seems the overhead of the array creation is completely slowing the algorithm
18:12:42 <carter> reuse the array then?
18:12:59 <carter> ie
18:13:06 <carter> is the size of the array always the same?
18:13:08 <carter> make it mutable
18:13:15 <proxfox> carter: well, how can I do it, if I use mutable array or any kind of monadic array I'll have to change the whole code...
18:13:21 <carter> well
18:13:27 <carter> :)
18:14:47 <carter> you want yourcode to be faster but not change ANYTHING? :)
18:15:41 <geekosaur> doesn't everyone?
18:16:32 <etandel> the dream
18:16:42 <proxfox> carter: xD, well, I do understand I have to change something but this would require a complete rewrite, I use the array on only one spot but if I change to mutable arrays I'll have to rewrite everything in a monad, every single bit...
18:17:01 <etandel> but sometimes it's possible. You can change the compiler, the compiling options, the processor etc.
18:17:01 <carter> well, i can't give you better suggestions without knowing more
18:17:09 <carter> proxfox: have you profiled?
18:17:12 <carter> or benchmarked?
18:17:21 <carter> sounds like your doing game ngineering, #haskell-game does that a lot
18:17:51 <proxfox> carter: yep, using variable sized immutable array is faster than using constant size array... so i guess the space isn't reused...
18:18:00 <carter> no
18:18:04 <carter> why would the space ever be reused?
18:18:06 <carter> profile
18:18:15 <carter> how big are the arrays?
18:18:15 <proxfox> carter: I don't know, smart optimizations, who knows! :D
18:18:18 <carter> no magic
18:18:22 <carter> theres no magic at all
18:18:24 <carter> don't assume magic
18:18:25 <carter> :)
18:18:37 <carter> anywho, unless you show the code
18:18:38 <proxfox> arrays range from 1-10000 elements
18:18:43 <carter> and have some prifling info
18:18:47 <carter> cna't help :)
18:18:50 <carter> are you writing a game?
18:18:53 <carter> or something different?
18:19:06 <proxfox> http://pastebin.com/c6uSDRkZ
18:19:08 <proxfox> nope
18:19:13 <proxfox> just an algorithmic puzzle
18:20:16 <proxfox> carter: http://pastebin.com/hdizeP8j example of input
18:20:47 <proxfox> so, it reads the input, fills the array with the '---X--XXX' lines
18:21:04 <carter> no clue
18:21:06 <carter> :)
18:21:10 <carter> busy with work right now
18:21:18 <proxfox> i understand
18:21:27 <luite> big arrays may be pinned, cause heap fragmentation, or are just more expensive to copy
18:21:27 <proxfox> but as you can se the array is used only in line 25
18:22:04 <proxfox> and if I do `readArray index arr` and similar, I'll have to rewrite every function
18:22:13 <proxfox> I believe so, am I right?
18:23:39 <carter> its not much code though!
18:23:42 <luite> proxfox: line 6, replicateM
18:24:19 <proxfox> luite: thanks, ghc-mod didn't catch that!
18:25:55 <koala_man> which lib would I use to load images? is there anything in the haskell platform I'm overlooking?
18:26:23 <koala_man> like a png to a pixel grid
18:26:31 <luite> koala_man: for something simple and easy to install you can use juicypixels
18:26:40 <luite> no non-haskell deps
18:27:04 <luite> oh perhaps zlib for png, dunno about that, but that's in the platform
18:27:17 <koala_man> nice and recently updated, thanks!
18:28:02 <carter> koala_man: juicy-pixesl
18:28:12 <ij> :t group
18:28:13 <lambdabot> Eq a => [a] -> [[a]]
18:28:38 <proxfox> carter: yep, I know its not that much code, that's what makes it special :D, but yep, I'll rewrite it then, thanks!
18:28:40 <ij> > group [1,1,2,1]
18:28:43 <lambdabot>  [[1,1],[2],[1]]
18:28:45 <carter> proxfox: no
18:28:49 <carter> proifle and benchmark first ;)
18:28:51 <carter> then rewrite
18:29:04 <ij> Does a group that would return [[1,1,1],[2]] exist?
18:29:17 <ij> And by that I mean is available.
18:29:38 <carter> ij: sort it then group it :)
18:29:41 <proxfox> carter: why?
18:29:51 <carter> proxfox:because you should actually measure whats being slow
18:29:54 <carter> not speculate
18:29:58 <carter> you could very well be right
18:29:58 <ij> carter, I don't want to have a Ord restriction.
18:29:59 <carter> BUT
18:30:10 <carter> ij: then you have to scan the whole thi thing
18:30:15 <carter> or osomething
18:30:19 <carter> n^2
18:30:20 <carter> or whatever
18:30:25 <proxfox> oh, well, ok, i'll plot some stats and see...
18:30:45 <carter> proxfox: use criterion OR use ghc's profilign tools
18:30:52 <PotatoGim> Hi
18:31:00 <ij> Oh, well I'll have to stick with group.sort then.
18:31:21 <proxfox> yep, done that, although threadscope crashed sometimes being unable to load large files
18:31:32 <carter> proxfox: ghc-events-analyze
18:31:39 <carter> though that needs some perf engineering
18:31:50 <carter> for events  logs > 5mb i need to run them on a monster server
18:32:01 <carter> currently has a nasty space blowup
18:32:21 <proxfox> aha
18:32:40 <carter> but its very nice
18:32:46 <carter> because it gives you a picture at the end ;)
18:38:20 <alphonse23_> does anyone know how to turn conceal on in vim?
18:38:53 <alphonse23_> as in, does anyone use github.com/enomsg/vim-haskellConcealPlus
18:39:02 <alphonse23_> and know how to get it to work?
18:40:10 * hackagebot binary-list 0.2.0.4 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.2.0.4 (DanielDiaz)
18:55:41 <koala_man> how do I turn a (IO Either b a) into an (ExceptT b IO a)?
18:55:59 <johnw> you mean IO (Either b a)?
18:56:21 <koala_man> yes
18:56:39 <johnw> just call "ExceptT action"
18:56:43 <Markzz> If I'm using just a ReaderT I can't actually modify the state?
18:56:43 <johnw> where action is your IO (Either b a) value
18:56:50 <johnw> Markzz: correct
18:56:54 <koala_man> duh
18:56:56 <koala_man> johnw: thanks!
18:57:01 <johnw> Markzz: unless you make the ReaderT contain an IORef or something mutable
18:57:42 <merijn> johnw: Then you still can't, you can only modify what the state points too :p
18:58:15 <johnw> yeah, true :)
19:00:20 <timmy_tofu> doctest is complaining it can't find the Paths_ module - how can I make that visible to it?
19:01:52 <solirc> timmy_tofu: -idist/build/autogen
19:02:12 <solirc> ^ I mean pass this to doctest
19:02:38 <timmy_tofu> I swear I did that before... dunno where it disappeared to
19:03:20 <solirc> TallerGhostWalt: I imagine it should be possible..
19:05:08 <solirc> timmy_tofu: We will add it to doctest by default in the future..
19:05:51 <solirc> timmy_tofu: https://github.com/sol/doctest/issues/89
19:06:05 <timmy_tofu> Much obliged either way... in the meantime I've gotta find the git gremlin eating my code.
19:09:20 <johnw> I generally call that gremlin "teammates"
19:10:19 <TallerGhostWalt> johnw: I think my teammates call it me
19:11:58 <timmy_tofu> Unfortunately I have no one to blame at the moment other than myself or the computer. Computer it must be, then.
19:12:12 <TallerGhostWalt> is anyone using vim-conceal?
19:12:27 <TallerGhostWalt> Is there something like it for emacs yet/already
19:13:25 <tabemann> question
19:14:21 <tabemann> I'm looking at System.Eval.Haskell, and am wondering about how to get it to return an arbitrary monad, considering that it has a Typeable restriction on its return type
19:15:26 <tabemann> well, IO has a Typeable1 instance...
19:17:09 <tabemann> question
19:17:18 <tabemann> can any monomorphic type have a Typeable instance?
19:18:53 <merijn> tabemann: Yes
19:19:03 <merijn> afaik
19:20:00 <tabemann> including functions?
19:22:12 <dmj`> css sucks
19:23:39 <c_wraith> tabemann: of course.
19:23:55 <c_wraith> > typeOf words
19:23:57 <lambdabot>  [Char] -> [[Char]]
19:26:30 <bmuk> What is the difference between mod and rem?
19:26:57 <tabemann> this means that code can escape System.Eval.Haskell, if the return type is given as IO (Maybe (Foo -> Bar))
19:27:41 <RchrdB> bmuk, how they behave on negative numbers.
19:28:18 <c_wraith> tabemann: well, yes.  What's wrong with that?
19:28:26 <c_wraith> tabemann: the point is that you know what the return type is.
19:28:37 <tabemann> c_wraith: oh, I want to be able to do that
19:28:42 <c_wraith> tabemann: in fact, I take advantage of that
19:28:54 <RchrdB> > (-5) `divMod` 8
19:28:55 <lambdabot>  (-1,3)
19:28:59 <RchrdB> > (-5) `quotRem` 8
19:29:01 <lambdabot>  (0,-5)
19:29:15 <bmuk> RchrdB: ah, okay thank you. I think rem is what I want (testing divisibility)
19:29:37 <tabemann> because I am working on a scriptable application, and I want the script code to be able to install callbacks that can be later evaluated
19:29:59 <RchrdB> bmuk, mod always gives a positive output and div always rounds down. rem gives a negative output for negative left inputs and quot rounds towards zero.
19:30:21 <c_wraith> tabemann: also, you can smuggle out polymorphic functions if you use a RankNTypes newtype wrapper to hide the type variable.
19:32:03 <tabemann> cool
19:32:58 <RchrdB> @check \x y -> y>0 ==> ((x `div` y) * y) + (x `mod` y) == x
19:32:58 <lambdabot>  : -1: -1:Ambiguous infix expression
19:33:49 <RchrdB> @check \x y -> (y>0) ==> ((((x `div` y) * y) + (x `mod` y)) == x)
19:33:53 <lambdabot>  +++ OK, passed 100 tests.
19:33:58 <tabemann> the only thing about System.Eval.Haskell - is the code you feed in taking the form of a Haskell source file, or the form of a Haskell expression
19:34:04 <RchrdB> @check \x y -> (y>0) ==> ((((x `quot` y) * y) + (x `rem` y)) == x)
19:34:06 <lambdabot>  +++ OK, passed 100 tests.
19:34:17 <tabemann> I get the impression it is in the form of a Haskell expression
19:34:19 <c_wraith> tabemann: an expression, but you can load arbitrary files as source beforehand
19:34:28 <c_wraith> tabemann: equivalent to using :load in ghci
19:35:32 <tabemann> so I might want to load the actual source files I plan on executing ahead of time, and then have the expression just refer to an entry point in those source files
19:35:53 <c_wraith> yes
19:36:30 <tabemann> to allow the user to provide actual Haskell source files, containing a name such as scriptMain that the expression refers to
19:37:39 <bmuk> This may be a little off topic (more math than haskell), but I know the riemann hypothesis is supposed to predict primes (though it hasn't been proven). Would it be possible to use that function to generate primes (faster than a sieve?)
19:38:12 <trap_exit> whoa, ... liftM* just makes so much more sense now
19:38:20 <trap_exit> I have an idea for  anew monad tutorial
19:38:28 <trap_exit> instead of explaining stuff to people, it should apttern match
19:38:35 <trap_exit> i.e. wait until peopel see lots of repetition in their code
19:38:44 <trap_exit> then the tutorial is like "look, you're writing all this .... instead, you can use this"
19:38:49 <trap_exit> and BAM, people get monads
19:39:13 <athan> trap_exit: that's how I got homomorphisms
19:39:14 <TallerGhostWalt> I really want to get into static code analysis but it is just so daunting
19:39:20 <TallerGhostWalt> anyone have good tips?
19:39:28 <TallerGhostWalt> or starting points?
19:39:32 <TallerGhostWalt> I see sbv
19:39:40 <mayski> trap_exit: do it!
19:39:55 <athan> TallerGhostWalt: Have you looked into dependently typed langauges?
19:40:08 <trap_exit> mayski: http://xkcd.com/927/
19:40:22 <trap_exit> Software Foundations / Coq is amazing.
19:40:41 <TallerGhostWalt> Coq would be the best first dep lang?
19:40:52 <tabemann> Agda
19:41:01 <athan> trap_exit: I am jealous :( I really need to dive in
19:41:14 <TallerGhostWalt> My goal is to statically analyze haskell progs I have written eventually
19:41:24 <TallerGhostWalt> so would that be the best route back to that?
19:41:41 <splintax> bmuk: i can't think of how it could be done, and i didn't see anything from a quick google. what do you mean by the riemann hypthesis is supposed to predict primes? https://en.wikipedia.org/wiki/Riemann_zeta_function#Euler_product_formula ?
19:41:48 <athan> TallerGhostWalt: datakinds + GADTs & type families :)
19:42:29 <mayski> trap_exit: well, yes, and you probably come up with that method just writing code and some day coming across hoogle/etc that shows you how you should've done it
19:42:44 <trap_exit> yeah
19:42:45 <trap_exit> hmm
19:42:51 <trap_exit> maybe someone should add this to hlint
19:43:01 <tabemann> what package name should I put an IRC client under?
19:43:09 <trap_exit> at some point, you run hlint, and hlint is like "dude, .... you can rewrite this as a monad where >>= = ... and return = ... "
19:43:36 <TallerGhostWalt> athan: k I guess I don't think of those as analyzers in the right way
19:43:43 <dmj`> tabemann: Network?
19:43:53 <dmj`> tabemann: you mean category?
19:44:08 <athan> TallerGhostWalt: It gives the same capacity (roughly) as dependent types ;)
19:44:16 <athan> check out Adga / Idris
19:44:39 <tabemann> dmj`: I actually meant to say module name
19:45:18 <TallerGhostWalt> athan: k thanks I will
19:45:23 <tabemann> like Network.IRC.Client.Foo
19:45:29 <bmuk> splintax: nevermind - I misremembered the implications of the Riemann hypothesis
19:45:50 <athan> TallerGhostWalt: Feel free to ask me questions!
19:46:18 <TallerGhostWalt> athan: will do!  Splitting time between learning awesome high level stuff and awesome low level stuff is hard
19:46:22 <dmj`> tabemann: oh, looks like there is an IRC Client package category
19:46:22 <dmj`> https://hackage.haskell.org/packages/#cat:IRC Client
19:46:39 <athan> TallerGhostWalt: You can do it! (in Rob Schneider's voice)
19:49:19 <tabemann> dammit - three names I looked at for an IRC client *all* have chat clients of some sort with those names
19:49:58 <trap_exit> hmm
19:50:07 <trap_exit> tabemann: how about IO(Text) ?
19:50:12 <t4nk495> hi guys
19:50:54 <t4nk495> other than becoming a better programmer/hobby/fun. Should i learn haskell
19:51:02 <t4nk495> Job prospects
19:51:14 <mayski> next to none as far as I know
19:51:16 <athan> t4nk495: It teaches you the ways of the force
19:51:23 <tabemann> okay, I found a name
19:51:25 <t4nk495> lol yeh
19:51:32 <mayski> but haskell is good for those reasons you listed
19:51:51 <mayski> it made me better in python!
19:51:54 <t4nk495> yeh I might learn it for the sake of saying i know haskell
19:51:54 <tabemann> Haskell makes you a better programmer, but ruins all other programming languages for you
19:52:03 <tabemann> Haskell is something to learn for its own sake
19:52:08 <dmj`> t4nk495: yes, haskell is the future
19:52:14 <trap_exit> Haskell is like an intelligence test
19:52:21 <trap_exit> If someone does not use Haskell; I can't imagine working with them now.
19:52:28 <bmuk> t4nk495: call me crazy but functional language employment is only going up
19:52:28 <mayski> haha
19:52:38 <joelteon> a lot of things are only going up
19:52:38 <c_wraith> That's more like a judgment test, not an intelligence test.
19:52:46 <RchrdB> TallerGhostWalt, if you specifically want to learn Coq, there are some nice books online - "Software Foundations" over at http://www.cis.upenn.edu/~bcpierce/sf/current/index.html and "Certified Programming with Dependent Types" at http://adam.chlipala.net/cpdt/
19:52:50 <t4nk495> well javascript development is moving more and more towards functional js
19:53:04 <trap_exit> tabemann: what are you calling it?
19:53:09 <johnw> TallerGhostWalt: definitely read CPDT after you've already started using Coq practically
19:53:13 <johnw> but not before
19:53:20 <trap_exit> the world is goign more concurrent
19:53:22 <tabemann> Yatter
19:53:31 <Iceland_jack> t4nk495: There are better languages if you're concerned with getting jobs, that being said check out the language by reading Learn You a Haskell and decide for yourself
19:53:31 <Iceland_jack> @where LYAH
19:53:31 <lambdabot> http://www.learnyouahaskell.com/
19:53:32 <trap_exit> concurrent imperative lock based orogramming  requires 6-digit IQ to get right
19:53:32 <bmuk> joelteon: true. I think the functional paradigm addresses a lot of the problems we will face in the coming years much better than OO
19:53:36 <johnw> trap_exit: not only that, but it's doing so while you do other things
19:53:45 <trap_exit> therefore, the only remaining langauges will be Haskell, Erlang, and C (for the brilliant kernel hackers)
19:53:56 <johnw> Iceland_jack: did you ever do anything with your lattice security Monad?
19:54:05 <tabemann> everyone else is copying Erlang's concurrency
19:54:15 <tabemann> except for Clojure, which's gone the STM route
19:54:16 <RchrdB> TallerGhostWalt, SF is meant to be an introductory text, CPDT is more advanced and aims to take you through writing a certified compiler as one of the examples, IIRC.
19:54:20 <bmuk> trap_exit: I hope we aren't writing kernels in C in 20 years
19:54:22 <trap_exit> also, types are good
19:54:44 <t4nk495> I know some C. But it seems that Haskell is gaining momentum
19:54:47 <trap_exit> erlang's idea is "write your code, where if any process crashes, the sytem still works"
19:54:48 <TallerGhostWalt> I've def heard good things about software foundations
19:54:48 <johnw> RchrdB: it guides you through writing certified interpreters for some tiny expression languages
19:54:55 <trap_exit> but having some static guarntees is good
19:55:23 <tabemann> Haskell will always be the programming language of the future as long as most people are programming in the likes of Java and C#, and even Scala and F#
19:55:31 <Iceland_jack> johnw: I've been formulating some different ways of formulating it using some new features in GHC but nothing public
19:55:33 <trap_exit> bmuk: I can't imagine writing kernls without (1) manual memory management, (2) pointer arithmetric -- at taht point, it's basically C :-)
19:55:49 <Iceland_jack> haha, one of those 'formulating' should be replaced :)
19:55:52 <RchrdB> johnw, ta.
19:55:54 <johnw> Iceland_jack: I'd be very interested
19:56:14 <tabemann> of course Scala sounds like the future to the people coming from Java, and same with F# to the people coming from C#
19:56:21 <trap_exit> liftM: you make my code so much clearner; why did we not meet earlier?
19:56:30 <splintax> trap_exit: haskell, erlang and C isn't enough, we also need a numerical computing language :)
19:56:32 <johnw> trap_exit: maybe because you knew him as fmap before?
19:56:32 <TallerGhostWalt> I am looking at Coq and Agda and idris I guess I will just see which one seems more fun.
19:56:39 <bmuk> trap_exit: https://en.wikipedia.org/wiki/Singularity_%28operating_system%29
19:56:46 <Iceland_jack> johnw: I'll make a note to message you if I get somewhere with it
19:56:51 <johnw> thanks!
19:57:03 <t4nk495> so java->scala, C#->F#,  ?->haskell
19:57:11 <trap_exit> splintax: I think a haskell DSL for GPGPU wil suffice for numerical computing
19:57:14 <TallerGhostWalt> Thanks for everyones help
19:57:15 <johnw> Iceland_jack: I'm looking at "security in Haskell" in general for work right now, so I'm interested in anything related to that overall concept
19:57:41 <tabemann> ? is the people who realize that Scala is just a better Java and F# is just a watered-down OCaml
19:58:14 <trap_exit> bmuk: "working state: abondoned" ouch
19:58:16 <splintax> trap_exit: i saw hackage.haskell.org/package/accelerate the other day and it looks really cool, but not all problems are trivially parallelizable
19:58:28 <t4nk495> From what i've read about Haskell. It's the only pure functional programming lang
19:58:47 <tabemann> t4nk495, there's also Clean and the dependently-typed languages
19:58:47 <johnw> t4nk495: Agda is pretty pure
19:58:49 <bmuk> I think the appeal of Scala and F# isn't that they are more feature complete than Ocaml or haskell or what have you. It's that you get some of the features and get to keep your legacy code and libraries
19:58:56 <t4nk495> ah
19:58:57 <tabemann> like Agda and Idris
19:58:57 <trap_exit> splintax: hmm, I can't thikn of a *single* HPC numerical computting problem ... where CPUS dominate GPUs
19:58:59 <t4nk495> yeh
19:59:14 <bmuk> trap_exit: I know, but managed oses are IMO a good idea.
19:59:26 <Iceland_jack> johnw: SafeHaskell and making simple restricted monads goes a very long way in terms of effort v benefit
19:59:28 <splintax> trap_exit: check out numerical weather prediction
19:59:28 <trap_exit> bmuk: what does 'managed' mean in this situation?
19:59:39 <trap_exit> bmuk: does it mean no pointers ?
19:59:42 <trap_exit> splintax: what algorithms do they use?
20:00:17 <trap_exit> my argument for GPU is this: all numerical problems pretty much reduce do large either dense or sparse matrix ops
20:00:24 <trap_exit> GPUs dominate GPUs on both dense and sparse matrices
20:00:25 <bmuk> trap_exit: managed by a runtime, I believe. So in Singularity's case it was the CLR
20:00:27 <trap_exit> game over CPUs
20:00:44 <tabemann> bmuk: at my workplace we're planning on switching from Groovy to Scala, but I suspend that there will be retention of older Java code which will be eliminated in an incremental fashion
20:00:49 <bmuk> I believe it would have a garbage collector, etc.
20:00:53 <trap_exit> bmuk: actually, I will agree with one thing
20:01:00 <trap_exit> bmuk: there's Adam Chlipala's work with Coq + Bedrock
20:01:03 <tabemann> *suspect
20:01:23 <trap_exit> bmuk: so I'll retract Haskell + Erlang + C, and say: Haskell + Eralng + {either C or some depdndently-typed system which can prove correctness of your OS }
20:02:29 <tabemann> Scala was chosen because it seemed like the best language we could find that would still run under the JVM because of outside code we have to run that is in Java; Clojure was out because it's dynamically typed, and my team lead doesn't really like dynamic typing (hence why we want to get rid of Groovy)
20:02:36 <bmuk> trap_exit: haha, there's also House https://en.wikipedia.org/wiki/House_%28operating_system%29 (don't know if they used anything but haskell. don't know much really other than it sounds awesome)
20:02:39 <splintax> trap_exit: well, NWP is inherently serial in that you're solving differential equations for a finite step in time, and then iterating
20:03:11 <splintax> the DE-solving part might ultimately reduce to "matrix operations" and has been successfully parallelised, a little
20:03:14 <trap_exit> splintax: rigid body physics simulatiuons are also finite step in time => iterate =-=> and GPUs still win; however, I know nothikng baout numerical weather prediction
20:04:21 <splintax> i'm no NWP expert, but i think it's too early to assess whether it will ultimately be dominated by GPUs (or any other massively parallel architecture)
20:04:54 <merijn> Numerical weather prediction is really hard for GPUs
20:04:56 <bmuk> tabemann: from what I understand Scala is really cool. I have used it a little, but I know that ekmett uses it a lot and some of his libraries (Machines) are available. I have heard their type system is even more expressive than haskell's, but more verbose (I could be wrong). I have also heard they (scala devs) don't think the lambda cube is the end all be all of type theory so it would be interesting to see where they go with their
20:04:56 <bmuk> type system
20:05:21 <merijn> One of my colleagues is working on a project for doing distributed weather processing using FPGAs, though, which seems interesting
20:05:23 <splintax> the main problem right now is that not a lot of GPGPU work has been done for NWP, especially relative to the decades of effort invested in sophisticated atmospheric models
20:05:46 <splintax> and those atmospheric models can't be simplified just by doing better software engineering and HPC
20:06:17 <edwardk> bmuk: i wouldn't say the type system in scala is more expressive than haskell. its different, its got a bunch of subtyping crammed into it, but in exchange it gives up all the kind machinery, etc.
20:06:27 <merijn> bmuk: Scala's type system is more flexible, I wouldn't say it's more expressive
20:06:34 <splintax> so maybe that field will eventually be dominated by highly parallel computers running algorithms built with functional languages, but it will take many years to get to that point
20:06:35 <edwardk> bmuk: to get a cursory improvement in some areas is trades of _everything_ else.
20:06:54 <merijn> And I mean flexible in the "python is flexible" way, where you can do things, but it costs you the ability to do static analysis :)
20:07:27 <merijn> splintax: Oh, said colleague is using a purely functional languagefor this weather prediction thingamajig too :)
20:07:31 <splintax> merijn: sounds like a cool project, where is this research happening if you don't mind me asking?
20:07:55 <merijn> splintax: Collaboration between some UK universities, dunno if the project has properly started yet, though
20:08:02 <merijn> splintax: Heriot-Watt is one of the partners
20:08:39 <athan> bmuk: I want a commutativity calculi
20:09:36 <bmuk> edwardk, merijn: Okay, that goes along with what I had heard - I know scala can't infer as much.
20:09:41 <splintax> merijn: cool. are you also using haskell in research? i've been wanting to do some postgrad study in CS for a while, but have put it off due to a lack of ideas about theses i could get passionate about. been really interested in NWP + FP the last few months though and it seems like a wide open research area
20:10:50 <edwardk> bmuk: the main cost is that you can't express as much as well. =/
20:10:53 <merijn> splintax: Right now I'm doing C++, when I get back from my internship I have plans to work on GPU bindings for haskell, but I haven't been able to dedicate the time so far
20:11:29 <bmuk> edwardk: I know on the haskellcast you complained about how verbose comonads are in scala haha
20:11:31 <merijn> splintax: Well, the main problem I've encountered in CS in finding places with funding :)
20:12:37 <athan> merijn: I don't know if someone already said this, but I think carter is working on a sparse matrix library
20:12:46 <carter> :)
20:12:48 <merijn> athan: I know :)
20:13:10 <merijn> athan: But that's not nearly low level enough for me :)
20:13:15 <carter> lol
20:13:23 <carter> merijn: you wanna segfuult your gpu more
20:13:25 <splintax> merijn: PhD places in the UK? i'm in australia, wonder if it's similar
20:13:55 <merijn> splintax: Well, I'm doing my phd in NL, I just used to work at Heriot-Watt
20:14:18 <merijn> carter: You jest, but I have a really annoying segfault issue on the GPU >.>
20:14:34 <splintax> merijn: cool. did you move to NL for personal or academic reasons?
20:14:47 <merijn> splintax: I'm originally from there :)
20:14:50 <carter> merijn: no, i'm serious
20:15:01 <tac> (What does NL stand for?)
20:15:03 <carter> the only reason to write lower level than wha ti'm doing is because you want to get more interesting crashes
20:15:08 <carter> or write SIMD
20:15:16 <splintax> merijn: ah. here i was thinking your nick was an alias ;-)
20:15:17 <merijn> carter: I have a segfault right now from a relative pointer dereference which ONLY happens if the value is in a variable
20:15:20 * hackagebot simple-pipe 0.0.0.16 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.16 (YoshikuniJujo)
20:15:22 <merijn> tac: Netherlands
20:15:26 <carter> see
20:15:28 <tac> ahh
20:15:41 <tac> I hear the netherlands are a nice place to live.
20:16:06 <bmuk> those in academia who are researching haskell (merijn, etc.), does one normally pursue their master's before moving on to PhD? Also will it hinder me if my concentration in undergrad is different than what I wish to pursue in graduate school?
20:16:06 <merijn> carter: i.e. I have a pointer: foo and a variable i, the value of 'i' is 53 and 'foo[i]' segfaults, but 'foo[53]' does not
20:16:27 <carter> merijn: ooo, in C++?
20:16:32 <carter> whats foo?
20:16:36 <carter> or gpucoes?
20:16:38 <carter> codes
20:16:42 <carter> native or gpu?
20:16:54 <merijn> bmuk: In Europe (except for the UK, but that's not really Europe ;), it's extremely rare to start a phd before finishing your masters
20:17:02 <merijn> bmuk: You'd have to be exceptional to be considered
20:17:09 <merijn> carter: gpu code, foo is an int pointer
20:17:32 <spott> merijn: does i[foo] work?
20:17:38 <spott> :)
20:17:46 <merijn> carter: I've run it in nVidia's cuda-gdb and literally "print i" in gdb shows "i = 53" and running "print foo[i]" segfaults in gdb, but "print foo[53]" does not
20:18:14 <merijn> Weirdest bug I've encountered so far, and I've had a bug where I accidentally hard power down-ed a CPU by writing to the APIC :)
20:18:37 <bmuk> merijn: I figured as much. I am just worried that my concentration now will lock me in to that field of study (I'm currently working towards a B.S. in computer science with a concentration in security, but I am more interesting in AI and PL)
20:18:42 <bmuk> interested*
20:18:42 <merijn> spott: oh, interesting, didn't think to try, although it really shouldn't matter
20:18:52 <spott> nope... it shouldn't
20:18:59 <spott> but it might give you more information
20:19:01 <merijn> bmuk: Sweden is good if you like type theory, PL and haskell/agda :)
20:19:16 <merijn> Chalmers has lots of haskell peeps
20:19:18 <spott> merijn: also, why are you writing your own GPU bindings for haskell: there is accelerate
20:19:19 <carter> merijn: theory: saturating all the registrs
20:19:20 <bmuk> sweden sounds nice! merijn++
20:19:21 <merijn> And Scotland is filled with FP stuff
20:19:30 <carter> merijn: try doing  j := i, then using j
20:19:40 <carter> Or using 1 fewere variables in that section
20:19:51 <carter> spott: no
20:19:54 <carter> its not tha simple
20:19:55 <spott> merijn: also: https://github.com/tmcdonell/cuda
20:20:03 <carter> accelerate only lets you write flat array computations
20:20:12 <merijn> spott: I've tried a few haskell CUDA bindings already, but invariably they kinda suck
20:20:16 <spott> yea, but they have cuda bindings...
20:20:22 <edwardk> bmuk: comonads work fine, its monad transformers and the like that get you ;)
20:20:28 <merijn> i.e. they're minimal C wrappers, in which case I'm better of writing C++ :)
20:20:36 <merijn> But, I gotta run!
20:20:42 <merijn> Be social and all that!
20:21:31 <spott> merijn: later
20:21:57 <trap_exit> so I need to setup my own webdav server; the online docs says: install apache / nginx; my question: is there a easy way to roll my own using happstack + some webdav module?
20:22:07 <trap_exit> if it's like 50-100 lines of ahskell to integrate some library into hapstack, that'd be a fun project
20:23:02 <splintax> bmuk: i can't see how "concentrating" on security in undergrad would exclude you from compsci research later on. although, my undergrad is in maths, and i am hoping to do CS research, so maybe i'm just believing what i want to believe :-)
20:23:53 <djahandarie> bmuk, there's plenty of security-related PL stuff too, FWIW. :)
20:24:26 <spott> hey, how do you deal with writing an instance for a typeclass if you need to further constrain the types of the instance:  for example, fmap is (a->b)-> (f a -> f b), but for this type, I need a and b to be constrained
20:24:34 <Iceland_jack> bmuk: The university I go to has a course on Language-Based Security and a department that focuses quite a bit on that
20:24:43 <carter> spott: you write your own map :)
20:24:51 <carter> you can do stuff with constraint kinds
20:24:58 <carter> but ... unclear how much win you get
20:25:01 <bmuk> djahandarie, splintax: I hope you are both right. I chose security because I kind of had to. (I got a free ride to a school that only has security and game programming as concentrations)
20:25:38 <bmuk> Iceland_jack: like type safety and code verification sort of thing?
20:25:50 <spott> so basically, I'm SOL?
20:26:08 <djahandarie> There is that, but there is also the game of defining type systems to obtain security properties.
20:26:19 <nshepperd> if a and b are constrained it's not really fmap, is it?
20:26:43 <Iceland_jack> bmuk: Yes, along with information flow and many other things
20:26:49 <Iceland_jack> it runs the gamut really
20:26:55 <spott> nshepperd: it is fmap in a smaller space: from unboxed values of one type to unboxed values of another type
20:27:06 <bmuk> Iceland_jack, may I ask where? It sounds really interesting.
20:27:17 <Iceland_jack> bmuk: At Chalmers, it was mentioned before
20:27:30 <Iceland_jack> Gothenburg, Sweden
20:28:07 <djahandarie> Many of the type theory masters apply their skills to security stuff. Frank Pfenning, Bart Jacobs, etc.
20:28:11 <bmuk> I'll definitely look into it for grad school. I'm starting at Florida Polytechnic next monday.
20:28:32 <carter> spott: they have to have the same unboxedness predicate
20:28:51 <carter> spott: theres ays
20:28:52 <carter> ways
20:28:55 <carter> but the ROI is fuzzy
20:29:59 <spott> carter: why?
20:30:12 <carter> 'cause :)
20:30:20 <carter> try using constraint kinds
20:30:27 <carter> and doing thusly  a custom class
20:30:33 <carter> that normal functor instance
20:30:36 <carter> plus constrained functors
20:31:09 <splintax> i'm confused as to what spott is trying to achieve. seems like you're asking the compiler to lie to you, if you want it to say that something is a Functor when it can't always be fmapped over
20:31:20 <carter> yeah
20:31:21 <carter> the set problem
20:32:26 <spott> splintax: it can be fmapped over by a subset of all functions... isofunctions in the category of "unboxed values"?
20:32:57 <spott> I'm missing why it has to be useful for EVERY function in order to be useful
20:33:13 <carter> spott: why not just use Data.Vector.Unboxed.map ?
20:33:43 <spott> carter: I am...
20:34:27 <carter> there is https://hackage.haskell.org/package/ConstraintKinds-1.3.0/docs/Control-ConstraintKinds-Functor.html
20:34:41 <carter> but honestly mikeizbiki will say "not really worth ti"
20:34:47 <carter> despite having written it
20:36:14 <splintax> spott: because if fmap didn't work for every function, then you could get type errors at runtime, defeating a goal of the type system? seems like ConstraintKinds would allow that to occur as well?
20:36:42 <carter> you kinda want a constrained functor
20:36:46 <spott> splintax: I'm not sure how we get from "doesn't work for every function" to "type errors at runtime"...
20:36:50 <carter> BUT you want it to also work with everything else
20:37:16 <carter> so you need to have a Functor f => ConstrainedFunctor f  instance too
20:37:24 <carter> but the problem is
20:37:30 <carter> you can't write that!
20:37:40 <carter> because of how class constraints work in ghc
20:38:18 <spott> yea, I'm getting that it isn't worth it...
20:38:22 <carter> well
20:38:29 <carter> more like we don't ahve the tech for it right now :)
20:38:43 <spott> it just seems... annoying
20:38:54 <splintax> spott: if your type is a Functor instance, then the compiler will allow you to fmap any function over it?
20:38:55 <carter> well
20:39:03 <carter> splintax: yeah
20:39:05 <nshepperd> would it be useful if ConstrainedFunctor had been in the prelude all along?
20:39:09 <carter> nshepperd: no
20:39:12 <carter> the issue isnt that
20:39:26 <carter> its that when you have instance Functor f => ConstrainedFunctor f
20:39:31 <nshepperd> I mean if Functor never existed
20:39:32 <carter> that NO other instance could match it
20:39:35 <splintax> the issue seems to be that static type systems are annoying when you could just write the code you want and it would work, for now
20:39:37 <spott> splintax: I guess I was thinking about the constrained functor thing
20:39:51 <carter> nshepperd: yeah, if Functor Was constrainted functor (which would be problematic in some ways)
20:39:57 <carter> it'd be ok
20:40:11 <carter> the problem is theres lots of things you could try to write with constrained functor that you can't enforce
20:40:12 <carter> like
20:40:18 <carter> if you had an Ord constrain
20:40:22 * hackagebot simple-pipe 0.0.0.17 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.17 (YoshikuniJujo)
20:40:28 <carter> you'd have to say "f prefseres ordering"
20:41:08 <carter> *preserves
20:41:14 <carter> (doesn't preserve spelling obs)
20:42:10 <spott> carter: why?
20:42:20 <nshepperd> it's not very conceptually nice, I think
20:42:36 <carter> how do you prove that  a->b will be a monotonic function?
20:42:42 <spott> or more accurately: why would you write a Constrained fmap that preserves ordering
20:43:05 <carter> because otehrwise you shouldn't be allowed to write an fmap on values with an Ord constraint
20:43:09 <carter> so one tricky thing
20:43:17 <carter> is you want a more general solution that you actually need
20:43:31 <carter> you have functorial things that have constraints on what types of values they can serialize
20:43:42 <carter> "how do i read/write this"
20:43:47 <carter> not other things like ord constraints
20:45:14 <carter> or Hashable
20:45:17 <carter> or whatever
20:49:40 <spott> so, fmap is still usefull if we have constraints...
20:51:09 <spott> it is a function on the individual elements applied to every element, which is usefull even if we have constraints on what those individual elements can be
20:52:04 <carter> yes
20:52:06 <carter> BUT
20:52:25 <carter> only if those constraints are a matter of whats "representable"
20:52:33 <carter> not about the semantics of the elements between eachother
20:52:39 <carter> or at least
20:52:48 <carter> you could imagine a agda/idris / coq functor model
20:52:54 <carter> where you not only have constraints on the values
20:53:06 <carter> BUT a proof obligation about what the function must satisfy
20:53:26 <carter> "this function must be order preserving"
20:53:34 <carter> "this must be hash value preserving"
20:53:44 <carter> spott: am i mkaing sense?
20:56:27 <spott> you are... but I feel like there is a middle ground.  If I have an (Ord -> Ord) constraint, I haven't said that it IS ordered on both sides of the functor... just that it is some type that CAN be ordered
20:57:26 <spott> most of the time, I don't even NEED that constraint, I can move from Ord -> b
20:58:25 <c_wraith> spott: err.  Ord -> Ord is a kind error.
20:58:46 <spott> c_wraith: sorry... bad notation
20:59:15 <spott> that was supposed to be shorthand for (Ord a, Ord b) => (a -> b)
21:02:26 <carter> a set type using Ord would die
21:02:34 <carter> if you dont' rebuild it
21:02:45 <carter> if you were to fmap the values and not rebuild
21:03:21 <spott> carter: why would you use the ord then?
21:03:35 <carter> spott: my point being
21:03:45 <carter> is that you need to prove your function you're fmaping
21:04:00 <carter> is a proper morphism in the subcategory induced by tyour constraints
21:04:02 <spott> my point is that you don't...
21:04:23 <spott> or, most of the time you don't
21:04:36 <carter> unsafeMapKeys
21:04:37 <carter> :)
21:04:40 <carter> yes,
21:04:46 <carter> but thats not giving you the same guarantee
21:04:58 <carter> fmap shouldn't crash your data structures
21:06:59 <spott> so, I can have a constraint "forall a"  which allows me to create an fmap that is the same as it is now....
21:07:33 <spott> and then I can also create an fmap from unboxed -> unboxed values (to abuse notation again)
21:07:49 <spott> which is usefull for certain types.
21:08:29 <spott> if we want to have a fmap for keys, we have to leave that proof to the writer... but we don't enforce laws of typeclasses in haskell ANYWAYS... I'm not sure how this is different
21:09:55 <splintax> some laws are enforced, namely the ones encoded in the type signatures of the functions required by the typeclass
21:10:46 <splintax> why do you want your type to be a Functor instance?
21:11:41 <spott> splintax: sure, but most aren't... we don't enforce the composability and Id laws of functor...
21:12:36 <spott> functor is a useful idiom...
21:13:01 <spott> and it seemed easy enough...
21:13:01 <spott> :)
21:16:12 <splintax> can't you convey that idiom just by calling your map function fmap' or something? the main reason for making the type a functor (afaik) is to preserve the safety of other functions that assume that fmap will work for any function.
21:18:39 <carter> splintax++
21:18:40 <carter> :)
21:20:26 <splintax> having a look at typeclassopedia now though, i'm not really sure whether fmap's signature implies that it must always be possible to construct f a for any type a
21:20:27 * hackagebot ghc-parser 0.1.3.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.3.0 (gibiansky)
21:21:32 <incog> J A M E S  F O L E Y
21:21:33 <incog>   L #_O_/,#|,#|\ G
21:21:33 <incog>   M /,\__..|~O|, O
21:21:33 <incog>   A #,/#,#,|#,|# A
21:21:33 <incog>   O -----,#,#,|# L
21:21:33 <incog> ROLLS PAST THE GOALIE
21:21:33 <dolio> It is not possible, depending on what you mean by 'construct'.
21:22:10 <splintax> can you create a functor that can only "contain" Ord instances, so you know that :: f a always means :: Ord a => f a ?
21:22:47 <enthropy> fmap f . fmap g == fmap (f . g) -- tends to get in the way
21:24:00 <copumpkin> splintax: that works on the way in
21:24:24 <copumpkin> not on the way out
21:24:46 <copumpkin> so you end up with a fmap :: (a -> b) -> OrdSet a -> OrdSet b
21:24:53 <copumpkin> OrdSet a carries evidence that a is Ord
21:25:00 <copumpkin> but you still have to be fully polymorphic in b
21:25:15 <copumpkin> so it wants you to concoct an Ord instance out of nowhere for any b
21:25:23 <splintax> ah i see
21:30:30 <HaskEnthu> I am getting this error when "cabal install gtk3" http://pastebin.com/KESNKqFZ
21:30:46 <HaskEnthu> gtk2hsC2hs: Errors during expansion of binding hooks:
21:31:53 <HaskEnthu> ./Graphics/UI/Gtk/Types.chs:2529: (column 12) [ERROR]   >>> Unknown identifier!
21:33:29 <HaskEnthu> any help on what i am missing here?
21:35:29 * hackagebot simple-pipe 0.0.0.18 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.18 (YoshikuniJujo)
21:46:16 <linman32> hi. cabal is trying to install an outdated package for some reason (.7 instead of .8.1)
21:46:17 <linman32> http://lpaste.net/109681
21:46:29 <linman32> is there a fix?
21:47:01 <solatis> linman32: please paste your .cabal file
21:47:08 <solatis> oh wait
21:47:14 <solatis> you are installing without .cabal
21:47:35 <Guest31374> Is XMonad still actively developed?
21:48:00 <solatis> can't you just do `cabal install cypher-0.8.1` ?
21:48:01 <linman32> http://lpaste.net/109682
21:48:14 <Guest31374> Anyone?
21:48:18 <linman32> i'm using sandbox
21:48:31 <Guest31374> hey linman32 tell me!
21:48:36 <Maxdamantus> xmonad seems like something that shouldn't be actively developed.
21:48:42 <Guest31374> why?
21:48:49 * Maxdamantus imagines xmonad-contrib is actively developed.
21:48:52 <MP2E> Guest31374: xmonad receives updates as they need them
21:48:59 <linman32> Guest31374: dude. i'm new to haskell. your asking wrong guy haha
21:49:10 <Maxdamantus> Guest31374: because it's meant to be a small codebase.
21:49:31 <shachaf> Guest31374: #xmonad is the channel for xmonad
21:49:33 <Guest31374> i just recently came across some articles which said its like the "BEST THING ON LINUX"
21:49:41 <Guest31374> i was like... wha...?? I never heard of it
21:49:42 <Maxdamantus> and have a fairly minimal set of core features.
21:49:42 <MP2E> it's pretty great
21:49:43 <solatis> linman32: you should install cypher >= 0.8
21:49:53 <solatis> instead of cypher -any
21:49:57 <Guest31374> explored their site, it seemed, exactly, very "minimal"
21:50:04 <shachaf> Guest31374: Please don't badger individual people for answers to your questions. This is a big channel.
21:50:23 <Guest31374> I'm sorry for that badgering. just felt a little naughty at that time
21:50:29 <Guest31374> sorry linman32
21:50:40 <HaskEnthu> Cannot find a definition for `GtkPlug' in the header file.
21:50:54 <linman32> solatis: tried installing latest cyper http://lpaste.net/109683
21:51:45 <linman32> Guest31374: haha its ok
21:52:01 <solatis> linman32: ah great, you've just entered dependency hell
21:52:51 <linman32> solatis: hmmm
21:52:55 <HaskEnthu> ya http://lpaste.net/109684
21:53:14 <ryantm> Guest31374, If you are wondering if xmonad works, it does. I'm using it right now.
21:53:43 <MP2E> same here
21:54:32 <linman32> solatis: how do i get dependency hell if i'm in sandbox?
21:54:37 <HaskEnthu> verbose log http://lpaste.net/109685
21:54:40 <MP2E> I wonder if there's going to be a wayland port of xmonad... maybe waymonad? :P
21:55:06 <tac> linman32: dependency hell is unavoidable. Sandboxes just keep the hell isolated to one project at a time.
21:55:14 * Maxdamantus is also using it.
21:56:17 <ryantm> linman32, it's only lesss likely in a sandbox because you have less dependencies
21:58:08 <linman32> cypher is for neo4j. is neo4j a good db to use?
21:58:20 <cwraith> well, and things you install in a sandbox can't break things outside the sandbox.  that's really important.
21:58:55 <HaskEnthu> ok i got it gtk3 should be built with -fhave-quartz-gtk on osx?
21:59:22 <linman32> tac: how do i fix dependency hell?
21:59:43 <tac> linman32: I'm not sure. I still struggle with it myself.
21:59:55 <tac> If it's a particular package, you can always ask about it by name in #hackage
22:00:00 <c_wraith> is there a simple way to wipe everything installed in a sandbox without wiping the sandbox config (ie, not cabal sandbox delete)
22:00:24 <tac> You might want to check your cabal file and look at the version number. Sometimes cabal init puts version numbers in for you that you might not want.
22:01:33 <glguy`> You fix dependency hell by figuring out which package isn't compatible with the versions of things you want to use and you update it and submit the patch to the maintainer
22:01:39 <tac> Can someone tl;dr explain what a "polykind" is?
22:01:58 <shachaf> "poly" stands for "polymorphic"
22:02:00 <c_wraith> tac: it means you can have type variables that can have different kinds
22:02:04 <shachaf> It's like a polymorphic type, except a kind.
22:02:13 <c_wraith> tac: usually, type variables must have a concrete kind
22:02:17 <tac> ah
22:02:42 <tac> So it's a little like (S : Type_1) -> ... in dependent types?
22:02:50 <c_wraith> No
22:03:08 <Maxdamantus> `Type` would be a specific kind.
22:03:20 <Maxdamantus> called `*` in Haskell.
22:03:23 <tac> Right
22:03:26 <tac> Type would be a Type_1
22:03:40 <linman32> glguy: update haskell code in offending package?
22:04:14 <Maxdamantus> Type_1 would be a Type, rather.
22:04:15 <c_wraith> tac: consider  newtype Compose f g a = Compose (f (g a))
22:04:40 <c_wraith> tac: What are the kinds of f, g, and a?
22:05:02 <tac> I would think a :: *, and f, g :: * -> *, but I know that's not going to be right because that's the obvious thing.
22:05:15 <c_wraith> tac: it's the simplest correct answer, but it's not complete
22:05:30 <tac> So you have something more like...
22:05:53 <c_wraith> tac: in base haskell, that is exactly the kinds of those type variables.
22:05:56 <glguy`> linman32: Right, that's the only way to actually avoid dependency hell is to update the packages
22:06:16 <tac> Compose :: (x, y, z :: Type_1) -> (f :: y -> z) -> (g :: x -> y) -> (a :: x) -> z, right?
22:06:42 <tac> Where x, y, and z are all kinds
22:06:43 <c_wraith> tac: when you add extensions, you start making other things possible.  With the KindSignatures extension, you could have a :: * -> *, g :: (* -> *) -> *, and f :: * -> *
22:06:54 <c_wraith> tac: or many other variants
22:07:25 <c_wraith> tac: there are many ways to fit those three type variables together.  What if you wanted to unify all those ways in one type?
22:07:30 <tac> Is there an error in my faux-Haskell type signature above? I just want to make sure my understanding is right.
22:07:41 <Guest31374> ok guys... c ya
22:07:46 <c_wraith> tac: I have no idea, I don't speak dependent types. :)
22:07:55 <tac> heh
22:08:24 <tac> I can't bring myself to learn the newest haskell type gadgetry, since it all seems to be subsumed by depdenent typing
22:08:39 <tac> but I end up afraid and perplexed by the vocabulary
22:08:55 <linman32> glguy: in this case (http://lpaste.net/109683) should i update cypher to require vector .10, instead of vector .9?
22:09:03 <c_wraith> tac: well, PolyKinds allows you to unify putting them all together.  newtype Compose (f :: k1 -> *) (g :: k2 -> k1) (a :: k2) = Compose (f (g a))
22:09:30 <c_wraith> tac: k1 and k2 are kind variables - they can stand for any concrete kind.
22:09:37 <tac> right
22:09:41 <tac> so I think I understand it correctly
22:10:58 <c_wraith> tac: it's just a handy way to make types more general, by allowing the kinds of type variables to vary as well.
22:11:09 <tac> right
22:11:12 <c_wraith> tac: among other things, the new Typeable library is defined in terms of it
22:11:21 <tac> plus, I think it helps with the funny stuff constraints can do in Haskell, right?
22:11:29 <glguy`> linman32: yup
22:11:29 <tac> Since constraints are kinds... or something like that
22:11:44 <Fuuzetsu> how is maintainership passing done on Hackage?
22:11:47 <c_wraith> tac: indeed.  constraints have kinds like...  Ord :: * -> Constraint
22:12:05 <c_wraith> tac: or Monad :: (* -> *) -> Constraint
22:12:09 <enthropy> that Compose doesn't need those kind signatures, right?
22:12:44 <c_wraith> enthropy: I don't know if it needs them or not, when PolyKinds is enabled. I have no idea if PolyKinds makes it generalize nested types like that.
22:13:11 <c_wraith> tac: well, PolyKinds interfaces cleanly with ConstraintKinds.  They both mix together exactly how you'd hope.
22:13:43 <c_wraith> tac: like...  Typeable, again.  Typeable :: k -> Constraint
22:14:44 <tac> typeable in haskell seems like black magic to me
22:15:07 <tac> but I'm intersted in generic programming and self-describing Martin-Lof universes
22:15:24 <HaskEnthu> whatever happened to polyparse? its hackage page suggests it to be a replacement for Read Class https://hackage.haskell.org/package/polyparse
22:15:29 <c_wraith> Typeable's implementation is black magic - but the type-level machineray is actually pretty clean now.
22:15:35 <c_wraith> *machinery
22:17:15 <tac> and it will last until someone wants superkind polymorphism
22:17:47 <c_wraith> Yes.  By the way, Stephanie Wierich wants to blow the roof off the hierarchy.
22:18:05 <c_wraith> And she's largely responsible for the DataKinds extension, so I expect her to succeed, one of these days.
22:18:55 <Iceland_jack> She's doing phenomenal work
22:20:21 <linman32> glguy`: how do i dl' package source (cypher 0.8.1) modify, then cabal install it in sandbox?
22:20:38 <c_wraith> I believe it's been theorized that if the stack is infinite, it gives you the same degree of power as dependent types.  I'm pretty sure that hasn't been proven.
22:20:40 <glguy`> You can download it with "cabal get cypher"
22:20:48 <glguy`> You can add-source with cabal sandbox
22:22:48 <linman32> glguy`: add source to .cabal file? did you mean to say there is a command for that?
22:23:21 <glguy`> linman32: http://www.haskell.org/cabal/users-guide/installing-packages.html  See "Sandboxes: Basic usage"
22:30:38 * hackagebot Monaris 0.1.8 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.8 (FumiakiKinoshita)
22:50:14 <dolio> Just making a bunch of levels doesn't give you dependent types.
22:52:03 <dolio> Heck, Agda has infinitely many levels _and_ dependent types.
22:52:17 <dolio> And they're not aiming to get rid of either.
22:57:18 <c_wraith> dolio: I think the hypothesis was the infinitely many levels lets you encode everything dependent types do..  I assume the hypothesis had something to do with extending singletons
22:57:55 <dolio> Adding levels isn't going to help what's wrong with what you can do in GHC now.
22:58:53 <dolio> You'd need for everything in the language to live in a singleton type.
22:58:55 <dolio> Like functions.
22:59:17 <dolio> Because many things you can't define yourself.
23:00:10 <johnw> c_wraith: how would having infinitely many levels give me Pi-types, for example?
23:00:40 <johnw> there is a fundamental dissociation between the value and type levels that is not present in a dependently typed language
23:00:49 <c_wraith> I have no idea. All I read was that there was a hypothesis that it could be made to work.
23:01:17 <dolio> Sometimes there is a distinction between types and values in dependently typed languages.
23:01:26 <johnw> dolio: when is that?
23:01:48 <dolio> Martin-löf type theory has it, as traditionally presented, for instance.
23:02:13 <johnw> ah, ok
23:02:26 <dolio> There are type judgments 'T type' and term judgments 't : T'.
23:02:37 <dolio> And terms can appear in types, but they are not the same as types.
23:03:12 <johnw> and lambda abstractions and Pi-types are different, despite the similarities
23:03:19 <dolio> They are still different syntactic classes, basically.
23:03:49 <dolio> Yes. That's almost always the case.
23:03:59 <Ouyang> I have a question for any haskell programmer here.  What did you learn haskell for?
23:04:12 <c_wraith> I learned haskell for work.
23:04:20 * djahandarie doesn't think he's seen anywhere where Pi-types and lambda abstractions have been united
23:05:07 <dolio> I've seen it, I think. But it's an odd thing to do when you have several other quantifiers.
23:05:12 <johnw> djahandarie: http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=331521&fileId=S095679680500554X
23:05:23 <johnw> "This paper studies the main properties of type systems with unified $\lambda$ and $\Pi$."
23:05:37 <dolio> Like, what do they do with sigma and W?
23:05:38 <johnw> sadly, paywalled
23:05:57 <djahandarie> http://www.cic.unb.br/~ayala/EVENTS/fairouzJFPpaper2006.pdf
23:06:23 <johnw> ah, thank you
23:06:53 <Ouyang> Just trying to figure out if I should learn haskell.  I know ruby, and I'm learning Java, but not digging it.  Not really sure what people do with haskell so thats why I asked to get a general representation.
23:06:55 <dolio> You can use lambda as your only means of variable binding. But then you'd still have pi, sigma, and W which take functions.
23:07:17 <johnw> Ouyang: we do anything you might want to do with a programming languages, except maybe writing kernel drivers
23:07:17 <dolio> Original Agda did that.
23:07:37 <c_wraith> johnw: didn't someone write kernel drivers and compile them with ajhc?
23:07:43 <johnw> I think Galois did
23:08:08 <Ouyang> johnw, something like a GUI windows app for various things?
23:08:29 <johnw> Ouyang: you can do that, although I'm not familiar with that aspect of Haskell at all
23:10:37 <Ouyang> johnw, yeah I'm just trying to figure out what else I would do with a language.  I love programming, just not sure what end product I want.
23:11:48 <Iceland_jack> Ouyang: Check out Learn You a Haskell, it's available for free online
23:11:50 <Iceland_jack> @where lyah
23:11:50 <lambdabot> http://www.learnyouahaskell.com/
23:12:11 <Ouyang> Iceland_jack, yup thanks, that is what I'm currently using.
23:12:35 <dolio> djahandarie, johnw: I don't agree with their conclusion.
23:12:49 <dolio> 'We can do this, so it's desirable.'
23:15:21 <johnw> hha
23:17:09 <Iceland_jack> Ouyang: I went into Haskell because I was tired of Haskellers acting like Haskell was amazing and I wanted to prove them wrong, I'm still here
23:17:57 <Ouyang> that is hell of a lot of effort to prove someone wrong lol
23:18:10 <Iceland_jack> I'm dedicated
23:18:23 <Iceland_jack> But Haskell made programming fun again
23:18:38 <Ouyang> I bet you can't file my taxes properly
23:18:56 <lpvb> Iceland_jack: did you prove them/us wrong?
23:18:58 <Ouyang> I hope it won't make me lazy
23:19:13 <Iceland_jack> Ouyang: This is #haskell, laziness is good
23:20:07 <Iceland_jack> lpvb: No, it's excellent
23:20:29 <Ouyang> inb4 people think donetsk just got nuked
23:20:55 <lpvb> Ouyang: I was frustrated with my spaghetti code in impure languages like C++ and java where the code was barely modular with code depending on hidden state everywhere. So I chanced upon 'Why Haskell Matters' and everything it said resonated with me.
23:22:18 <Ouyang> I'm interested by haskell a lot
23:22:50 <Ouyang> Anyone reccomend anything from this list of books https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#haskell ?
23:23:15 <Ouyang> outside of the learn you a haskell that I'm reading at the moment
23:23:50 <johnw> how intensely do you want to get into things, Ouyang?
23:24:25 <Ouyang> I have 4 years of college ahead of me, so I guess pretty itnensely as I got a lot of time on my hands
23:24:48 <johnw> then I can't recommend this enough: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
23:25:00 <johnw> it's not Haskell exactly, but it will shed light on some of the principles behind Haskell
23:25:19 <johnw> not to mention it is fun enough to be addictive
23:25:34 <johnw> I "lost" another 5 hours to it last night :)
23:28:54 <lpvb> johnw: how would reading this help me with haskell?
23:29:23 <johnw> that's why I asked how much he wanted to get into things
23:29:32 <johnw> it won't necessarily help you *use* Haskell at all
23:29:49 <johnw> but it's help me a great deal to *understand* Haskell and why certain decisions were made in its design
23:29:49 <Ouyang> hahaha I have to figure out how to even use the thing I downloaded
23:30:06 <Ouyang> to learn functional programming, or to get a better mindset?
23:30:10 <johnw> both
23:30:40 <johnw> also, learning the concept of dependent types in Software Foundations will make many of Haskell more advanced typing features much less intimidating
23:30:47 * hackagebot language-glsl 0.1.0 - GLSL abstract syntax tree, parser, and pretty-printer  http://hackage.haskell.org/package/language-glsl-0.1.0 (VoMinhThu)
23:31:48 <Ouyang> I'm trying to set up a comfy environment for me to start haskell, so I'm trying to set up debian here.  Windows feels eh writing haskell
23:32:22 <johnw> Ouyang: well, in that case I'd suggest NixOS, but maybe you want to limit the number of new yaks you have to shave to get to your goal :)
23:34:28 <notdan> Ouyang: eh, The Haskell Road to Logic, Math and Programming is an interesting read, I guess
23:34:52 <notdan> I haven't read Haskell School of Music, but I've seen the music demos produced in Haskell and it's nifty
23:34:53 <Ouyang> notdan, all kinda mediocre on that list?
23:35:32 <notdan> Hm, no, I think it's all pretty good
23:35:45 <notdan> but LYAH is probably the besst beginner book
23:36:12 <Ouyang> ok thank you, much appreciated
23:36:38 <johnw> I agree that LYAH is a great place to start
23:37:07 <notdan> I wouldn't say that Software Foundations is the best way to start learning functional programming, because it presupposes some knowledge of fp
