00:00:01 <Fuuzetsu> Hayoo defaults to much more, you might want to use that
00:00:26 <merijn> You can install local hoogle with a custom index
00:00:38 <merijn> Although my machine keeps running out of memory merging the indices >.>
00:01:05 <Fuuzetsu> I once tried to merge hoogle files for every package on Hackage
00:01:13 <merijn> Fuuzetsu: Same here :D
00:01:41 <sgronblo> Ah shows up in Hayoo
00:01:41 <Fuuzetsu> https://github.com/ndmitchell/hoogle/issues/44 ;)
00:01:44 <sgronblo> Thanks
00:04:33 <merijn> Fuuzetsu: Mine just made my machine unusably slow for about 4 hours before running out of memory
00:09:09 * hackagebot happstack-hsp 7.3.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.2 (JeremyShaw)
00:09:09 * hackagebot happstack-server-tls 7.1.2.1 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.2.1 (JeremyShaw)
00:25:15 <solidus-1iver> i'm super confused, how do i get from an event to a value using netwire
00:25:36 <solidus-1iver> <& produces another event
00:25:40 <solidus-1iver> so i cant use that to make something out of events
00:28:42 <solidus-1iver> i want to produce a value at a given event
00:28:48 <solidus-1iver> i have a wire that produces an event when i want to make the value
00:28:52 <solidus-1iver> but how do i go from that to a value
00:44:51 <apricity> vim
00:45:18 <apricity> woops mistype sorry
00:46:05 <Fuuzetsu> yes, the keys are right next to ‘emacs’
00:57:32 <Argue> > pl \y -> something a y b y c
00:57:33 <lambdabot>  <hint>:1:4: parse error on input ‘\’
00:58:14 <Argue> @pl \y -> something a y b y c
00:58:14 <lambdabot> flip (join (flip (something a) b)) c
01:05:20 <Argue> @pl \a b -> something (foo a) (foo b)
01:05:21 <lambdabot> (. foo) . something . foo
01:06:36 <frerich> Argue: Another way to write that is "something `on` foo"
01:07:54 <Argue> is that `on` as in this one? http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Function.html
01:08:04 <frerich> Argue: Yep!
01:08:14 <Argue> awesome, thanks!
01:09:09 * hackagebot distributed-process 0.5.1 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.5.1 (TimWatson)
01:17:21 <Fuuzetsu> ‘on’ is great
01:17:56 <NikolajK> can one write "let" without an "in" following? Is in optional?
01:18:24 <corgifex> only in a do block
01:18:35 <NikolajK> why is that?
01:18:45 <corgifex> do { let X = Y; ... } is sugar for let X = Y in do { ... }
01:18:59 <NikolajK> ah, okay
01:20:51 <ibid> NikolajK: what would a let without an in even mean outside of a do?
01:26:21 <NikolajK> I just saw an example with let, missing do, was surprised and asked. but yeah indeed it was in a do block,
01:59:15 * hackagebot tellbot 0.3.3.2 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.3.3.2 (DimitriSabadie)
01:59:17 * hackagebot list-t 0.2.2 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.2 (NikitaVolkov)
02:09:17 * hackagebot list-t 0.2.3 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.3 (NikitaVolkov)
02:14:17 * hackagebot tellbot 0.3.4.0 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.3.4.0 (DimitriSabadie)
02:14:18 <Twey> > do let { x = 5 }; x + 3
02:14:20 <lambdabot>  8
02:17:45 <pavonia> What monad is that?
02:18:08 <shachaf> No monad.
02:18:39 <pavonia> But there clearly is some monad involved
02:19:33 <pavonia> @undo do let { x = 5 }; x + 3
02:19:33 <lambdabot> let { x = 5} in x + 3
02:19:48 <pavonia> Huh
02:21:19 <pavonia> > do { let { x = 5 }; x + 3 }
02:21:21 <hexagoxel> does an updated haskell report exist that reflects the changes in ghc 7.10 (esp. Functor->Applicative->Monad stuff)?
02:21:21 <lambdabot>  8
02:22:09 <pavonia> Can anyone explain why/how that works?
02:23:55 <adas>            is there a way to ask ghc to use the sandbox env?
02:24:07 <Maior> adas: use cabal to do things?
02:24:29 <adas> Maior: you mean cabal exec, cabal repl?
02:24:33 <ChristianS> hexagoxel: i don't know what exactly you mean, but ghc doesn't define standard haskell
02:24:34 <Maior> adas: yes
02:24:39 <lfairy_> pavonia: "do" itself doesn't imply Monad; the desugaring does
02:25:06 <kazagistar> pavonia: undo shows the unsugared version, that is what the syntax turns into internally
02:25:10 <lfairy_> pavonia: notice when you used @undo, the result didn't mention >> or >>=
02:25:17 <adas> Maior: but i want to pass parameters to cabal exec and cabal repl ..
02:25:27 <adas> cabal exec --threaded doesn't work
02:25:40 <pavonia> > do 1
02:25:42 <lambdabot>  1
02:25:49 <adas> ill try again
02:26:03 <Maior> adas: ghc-options:
02:26:09 <Maior> adas: (in your .cabal file)
02:26:14 <supki> adas: cabal has some weird issues with the command line parsing but e.g.  cabal exec ghc -- --threaded ...  should work
02:26:17 <Maior> adas: there may be a CLI way
02:27:17 <pavonia> > do 1; 2
02:27:18 <lambdabot>  Could not deduce (GHC.Num.Num (m a0))
02:27:19 <lambdabot>    arising from the ambiguity check for ‘e_112’
02:27:19 <lambdabot>  from the context (GHC.Num.Num (m b),
02:27:19 <lambdabot>                    GHC.Num.Num (m a),
02:27:19 <lambdabot>                    GHC.Base.Monad m)
02:27:43 <pavonia> So the last expression is returned "as is"?
02:28:51 <kazagistar> no, the error is in the first expression... what do you think "let" gets desugared to?
02:29:10 <oakwhiz> pavonia: The last statement in a do block must be an expression.
02:29:13 <kazagistar> @undo do 1; 2
02:29:14 <lambdabot> 1 >> 2
02:29:51 <kazagistar> :t (>>)
02:29:52 <lambdabot> Monad m => m a -> m b -> m b
02:30:11 <kazagistar> :t 1
02:30:12 <lambdabot> Num a => a
02:30:25 <hexagoxel> ChristianS: yeah, but what is the relation between ghc and standard haskell? my current first assumption was that ghc implements standard haskell, plus a ton of non-standard extensions
02:30:35 <pavonia> kazagistar: Well, my confusion wasn't about the let but about the last expression, I thought it has to be a monadic value
02:31:21 <hexagoxel> but at least with ghc 7.10, that does not seem the case any more (?)
02:31:38 <kazagistar> pavonia: it only needs it if the desugared version needs it
02:32:06 <pavonia> Yeah
02:32:38 <adas> yea looking into it
02:32:38 <kazagistar> pavonia: I think that is reasonable behavior, do you disagree?
02:33:21 <ChristianS> hexagoxel: that would be make assumption as well, where/how do you think ghc 7.10 breaks it?
02:33:33 <pavonia> kazagistar: I don't, I just wasn't aware of this
02:34:28 <supki> hexagoxel: https://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#haskell-standards-divergence
02:34:43 <kazagistar> pavonia: neither was I, but I suspect it would never have come up, since I generally avoid do notation for the trivial cases where it would have come up, and a type signature would have caught any related bugs anyways :P
02:34:58 <kazagistar> it is an interesting observation
02:37:51 <hexagoxel> supki: ah, thanks
02:39:39 <hexagoxel> ChristianS: was thinking of Monad superclasses. if i read them correctly, reports 98 and 2010 say "Monad has no superclass"
02:40:41 <ChristianS> hexagoxel: the report just defines Monad, it doen't concern itself with whether or not it has superclasses
02:43:15 <shachaf> ChristianS: ?
02:43:34 <shachaf> The Report defines the standard Prelude, which includes a complete class definition of Monad.
02:44:20 * hackagebot tellbot 0.4.0.0 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.4.0.0 (DimitriSabadie)
02:44:21 <ChristianS> shachaf: hmm, iirc the report only gives a sample implementation
02:44:57 <shachaf> Yes, a sample implementation.
02:47:00 <dfeuer_> ChristianS, a class represents an interface, not an implementation.
02:49:21 * hackagebot debian-build 0.1.0.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.1.0.1 (KeiHibino)
02:49:25 <ChristianS> dfeuer_: true it changes the interface but for those who don't rely on the new superclass being there it shouldn't really matter i'd think
02:49:45 <ChristianS> dfeuer_: i mean, all valid haskell 2010 programs should still be accepted by the new ghc?
02:50:20 <hexagoxel> well if you define a new Monad instance without Function/Applicative, it won't compile
02:51:26 <ChristianS> hexagoxel: hmm, that sucks indeed
03:10:08 <Raydiation> do i want a functor for every type?
03:10:26 <shachaf> What does that mean?
03:11:54 <oakwhiz> Raydiation: you want a functor when you have a type that can be mapped over
03:13:31 <zwer> ;[ppppppppppp
03:18:50 <trap_exit> I think too many _'s make my code hard to read: https://gist.github.com/anonymous/49b7b230dcc3cf394269
03:18:51 <btcNeverSleeps> quick question: I'm deriving Ord for something like Ace, King, Queen, Jack, Ten, etc.   How can I get 1 for Ace and 13 for Deuce?
03:19:16 <shachaf> The derived instance puts them in the order that you write them in.
03:19:44 <shachaf> Oh, maybe you're saying you want to get an Int out of your type.
03:19:57 <btcNeverSleeps> shachaf: yup, I need an Int
03:20:05 <shachaf> Look up Enum.
03:20:20 <btcNeverSleeps> shachaf: oh ok
03:30:34 <Raydiation> oakwhiz: thanks
03:33:50 <pache> Hiya, quick question, is there a way I can import all the modules that are imported in a module? If that makes sense?
03:35:35 <pache> So I have a huge list of imports in a file, I've made that file a module, any way I can, when importing the module I made in another file, also import the modules imported in that module?
03:36:09 <pache> Sort of like a tree, I guess what I'm asking is if there's C-style #includes, or if I have to paste that huge module list in each time?
03:36:18 <ion> module Blah (module Exports) where { import qualified Foo as Exports; import qualified Bar as Exports; … } works on the Haskell side, but does not work as you’d like on the Haddock side.
03:37:11 <trap_exit> 1) does haskell support multi-line strings? 2) I need to write a decent parser for a algo-like langauge; what package should I use?
03:37:25 <pache> ion: Cheers I'll give it a try.
03:37:28 <ion> "foo\
03:37:30 <ion> \bar"
03:37:38 <Maior> trap_exit: http://www.haskell.org/haskellwiki/Poor_man's_here_document
03:37:40 <trap_exit> nice
03:37:41 <ion> or use an appropriate quasiquoter
03:38:16 <Freundlich> Why would print use my Show instance while traceShow does not? I'm printing a tuple where I defined a Show instance for one of its element types.
03:38:36 <ion> The unlines [ … ] way in the linked document can also work nicely.
03:39:03 <trap_exit> Maior: wtf wtf wtf
03:39:05 <ion> Parsec is rather popular for parsing. I haven’t looked at Trifecta for quite a while but it at least has potential.
03:39:10 <trap_exit> Maior: is 'here' a haskell native, or a haskell library
03:39:20 <trap_exit> oh, it needs to be pure haskell
03:39:20 <trap_exit> no native dependencies
03:39:21 <trap_exit> does parsec satisfy that?
03:39:27 * hackagebot debian-build 0.2.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.2.0.0 (KeiHibino)
03:39:35 <Maior> trap_exit: I am inclear as to what you're wtfing over
03:39:47 <trap_exit> Maior: how does this magic work?
03:39:52 <trap_exit> Maior: is 'here' a haskell library, or is it a builtin
03:39:58 <Maior> trap_exit: ah, see https://en.wikipedia.org/wiki/Here_document
03:40:00 <Maior> trap_exit: neither
03:40:11 <trap_exit> Maior: this seems magical that I can just write {- DATA START ... DATA END -} and have it be put into a "DATA" var
03:40:32 <trap_exit> Maior: right ... so it this handled by the hhaskell parser?
03:40:47 <trap_exit> oh
03:40:48 <trap_exit> no
03:40:48 <trap_exit> wtf
03:40:48 <trap_exit> it's reading itself
03:40:54 <trap_exit> this is disguisting
03:41:05 <Maior> trap_exit: yes, item 2 ftw
03:41:39 <trap_exit> you know what?
03:41:39 <trap_exit> quasiquotes will do fine for me
03:47:01 <jle`> haskell has multi line strings i think but they're pretty awkward
03:49:26 <Maior> jle`: all the \\\\\\
03:50:36 <jle`> it's also kind of awkward because it breaks if {-# LANGUAGE CPP -#} is enabled
03:50:59 <jle`> oops that's an improper pragma
03:51:12 <jle`> don't judge me, ssh lag is like 30 seconds >____>
03:51:18 <trap_exit> what is the point if attoparsec?
03:51:27 <jle`> the point of what?
03:53:08 <trap_exit> why does it exist
03:53:12 <trap_exit> is the problem "parsec is too slow"
03:53:14 <trap_exit> thus people wrote attoparsec?
03:58:44 <adas> trap_exit: perhaps its because parsec consumes failed input while atto does not
04:38:44 <trap_exit> yo
04:38:46 <trap_exit> poll
04:38:52 <trap_exit> what's your favorite monad?
04:38:53 <trap_exit> mine is StrictRWS
04:38:55 <trap_exit> so fucking useful
04:38:58 <doismellburning> []
04:39:03 <trap_exit> not so much the read part, but Wrist + State
04:39:06 <trap_exit> err, Write
04:39:18 <dottedmag> X
04:39:21 <trap_exit> doismellburning: what are you doing, writing non-detreministic simulators ?
04:39:22 <barrucadu> The wrist monad, a useful component in writing haskell
04:39:31 <doismellburning> trap_exit: ?
04:40:00 <trap_exit> doismellburning: I believe [] monad is useful for logic programming, since you can easily enumerate all posstible states
04:40:15 <doismellburning> ok
04:44:38 * hackagebot CPL 0.0.7 - An interpreter of Hagino's Categorical Programming Language (CPL).  http://hackage.haskell.org/package/CPL-0.0.7 (MasahiroSakai)
04:46:47 <hexagoxel> trap_exit: Proxy :D
04:47:06 <trap_exit> hexagoxel : waht does it do?
04:47:07 <Exio4> all monads are cool!
04:47:16 <Exio4> (but IO)
04:49:06 <adas> poll
04:49:11 <adas> favorite oneline?
04:49:15 <adas> favorite oneliner?
04:49:34 <adas> perhaps thats been done too many times already
04:49:42 <hodapp> what is this, buzzfeed?
04:49:53 <adas> sory
04:50:13 <hodapp> "10 Haskell One-Liners That Will Change Your Perspective Forever. #7 had me in tears."
04:50:40 <adas> hodapp: link?
04:50:46 <Twey> Haha
04:50:48 <hexagoxel> trap_exit: really, nothing. Proxy is even simpler than Identity Monad.
04:50:58 <Twey> ‘Shut up and take my clicks!’
04:51:03 <adas> no wories. got it
04:51:09 <adas> kidding
04:51:12 <zomg> Favorite oneliners?
04:51:12 <trap_exit> hodapp: link pls
04:51:18 <zomg> Hard to pick, Arnie had so many good ones
04:51:22 <trap_exit> return ()
04:51:29 <trap_exit> where are Arnie's one liners
04:51:40 <trap_exit> I also like any lines that ahve "::" in them
04:51:56 <zomg> trap_exit: https://www.youtube.com/watch?v=1kxKqf2tMoU
04:54:18 <frerich> Does anybody know how to implement the 'chainWhile' function as given in http://lpaste.net/109289 without using explicit recursion?
04:54:43 <ocharles> Is tehre really no Show a => Show (Const a e) instance?
04:54:45 <ocharles> That seems... odd?
04:54:50 <trap_exit> foldl
04:56:11 <alpounet> ocharles: sounds like you've got a small patch for libraries@
04:56:17 <ocharles> Indeed
04:56:55 <shachaf> Nor is there a Show instance for Identity.
04:57:06 <ocharles> That got fixed in the latest transformers, I thought?
04:57:53 <shachaf> Maybe.
04:58:08 <alpounet> ocharles: actually, it's been discussed http://haskell.1045720.n5.nabble.com/Proposal-Add-common-instances-for-Control-Applicative-Const-td5738481.html
04:58:18 <ocharles> alpounet: thanks, I thought it must have
05:07:42 <t7> > [1, 'a'] :: List (Forall a. (Show a) => a)
05:07:43 <lambdabot>  <hint>:1:27:
05:07:43 <lambdabot>      Illegal symbol '.' in type
05:07:43 <lambdabot>      Perhaps you intended to use RankNTypes or a similar language
05:07:43 <lambdabot>      extension to enable explicit-forall syntax: forall <tvs>. <type>
05:07:55 <t7> > [1, 'a'] :: List (forall a. (Show a) => a)
05:07:56 <lambdabot>  Not in scope: type constructor or class ‘List’
05:07:56 <lambdabot>  Perhaps you meant ‘Last’ (imported from Data.Monoid)
05:08:06 <t7> > [1, 'a'] :: [(forall a. (Show a) => a)]
05:08:07 <lambdabot>  Illegal polymorphic or qualified type:
05:08:08 <lambdabot>    forall a. GHC.Show.Show a => a
05:08:08 <lambdabot>  Perhaps you intended to use ImpredicativeTypes
05:08:38 <t7> how do i into existential list ?
05:15:27 <prophile> t7: in that case, you'd be better off just making a list of strings :)
05:16:08 <t7> but in other cases?
05:16:15 <t7> im sure i have seen someone do this before
05:16:30 <t7> i should just hold list of functions, i know....
05:16:47 <doismellburning> heh I remember trying to build something like this before
05:20:03 <freeman42> what is this I don't even... http://i.imgur.com/9x2XS8k.png why does everything have to be so hard? xD
05:20:37 <freeman42> that was after installing the latest haskell platform on Ubuntu 14.04
05:21:18 <skuggi> t7: I think you have to make a type like this: data ShowBox = forall a. Show a => ShowBox a
05:21:25 <skuggi> and make a list of those
05:22:10 <skuggi> and you need -XExistentialQuantification
05:35:25 <r444> freeman42: i think you should run uninstall-hs and remove old ghc versions
05:36:25 <freeman42> r444, sorry, it was me being silly, I installed it from Ubuntu repo and it was actually 2013.2.0.0 instead
05:36:53 <r444> freeman42: ok, glad it's resolved
05:45:31 <freeman42> r444, got it solved thank you, downloaded the binaries
06:24:53 * hackagebot flowdock 0.1.0.0 - Flowdock client library for Haskell  http://hackage.haskell.org/package/flowdock-0.1.0.0 (IanDuncan)
06:28:12 <sgronblo> Could someone clarify a few things about Applicatives and Monads and sequencing? Specifically if they do imply sequence or if sequence is only guaranteed by the virtue that you can refer to the result of an earlier action with a monad? Or is the sequencing inherent to how expressions get compiled? Is IO a special Datatype that automatically gives order to Applicative and Monad evaluation?
06:30:19 <Exio4> @src nubBy
06:30:20 <lambdabot> nubBy eq []     = []
06:30:20 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:33:23 <Twey> sgronblo: The key operation of (the Haskell formulation of) monads is (>>=), which gives you some notion of ‘and then’ in that the second argument is a function, so it's up to the implementation of the (>>=) operator, supplied with the first argument, to produce a value to feed it
06:34:47 <Twey> sgronblo: But that ‘sequencing’ may not be *temporal* sequencing; that's just the IO definition.
06:35:58 <pjdelport> sgronblo: Sequencing is not really inherent to Applicative / Monad: it's just a property of particular instances. IO, for example, is defined to sequence effects from left to right, but it could equally have been defined to sequence effects from right to left.
06:36:38 <Twey> sgronblo: There's a thing called a ‘reverse state monad’ that basically exists to screw up people's expectations of monads-as-embedded-imperative-languages: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
06:37:51 <pjdelport> sgronblo: For demonstration, you can reverse any existing Applicative's sequencing order (if any) like this: http://lpaste.net/107551
06:39:14 <Twey> The effects of Applicative have no kind of implied sequencing — in a <*> b the effects of a are independent of the result of b, and vice versa.  That's why they're useful to represent computations that can be done in parallel (e.g. Simon Marlow's Haxl language).
06:41:28 <MagneticDuck> any particular reason why the only export of a "readMaybe" function (Read a) => String a -> Maybe a seems to come from Network.CGI.Protocol, according to hoogle?
06:41:36 <MagneticDuck> isn't there a more... relevant place to imoort it from?
06:41:50 <MagneticDuck> I mean, just to make my imports more ... coherent?
06:42:53 <supki> Text.Read
06:43:01 <Clint> :t fmap fst . listToMaybe . reads
06:43:02 <lambdabot> Read b => String -> Maybe b
06:43:30 <MagneticDuck> ah, reads
06:43:34 <MagneticDuck> yeah that works too
06:43:37 <MagneticDuck> alright thanks
06:53:29 <dottedmag> Is there something of type b -> (a -> Maybe b) -> a -> b?
06:53:49 <vamega> dottedmag
06:53:52 <vamega> What would that do?
06:53:57 <dottedmag> like Data.Maybe.maybe, but with return value optional, not argument.
06:54:21 <dottedmag> "totalize non-total function with a default value"
06:55:11 <vanila> :t maybe
06:55:12 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:55:50 <dottedmag> It's trivial to implement using fromMaybe, just wondered maybe it's already there somewhere.
06:59:02 <Ankhers> Using cabal, is there a simple way to install my test dependencies?
06:59:52 <supki> cabal install --enable-tests --only-dependencies
07:00:17 <Ankhers> supki: awesome, thanks.
07:01:32 <nshepperd> :t (.) . fromMaybe
07:01:33 <lambdabot> c -> (a -> Maybe c) -> a -> c
07:17:43 <MagneticDuck> :t flip id -- this is still the most effective way to quickly confuse newbies
07:17:44 <lambdabot> b -> (b -> c) -> c
07:17:54 <doismellburning> :t flip
07:17:55 <lambdabot> (a -> b -> c) -> b -> a -> c
07:18:09 <MagneticDuck> :t id
07:18:10 <lambdabot> a -> a
07:18:18 <MagneticDuck> :D:D:D newbies haven't got a chance
07:18:42 <Rembane> :t flip flip
07:18:43 <lambdabot> b -> (a -> b -> c) -> a -> c
07:18:45 <MagneticDuck> the idea is that "flip id" isn't soo above their heads that they can't even begin to comprehend it
07:18:56 <MagneticDuck> but it's still very puzzling
07:19:18 <hamid> MagneticDuck, it was and it still is for me :D
07:19:28 <MagneticDuck> "flip flip" is much easier to understand
07:19:40 <eacameron> it is incredibly annoying that everything in base uses monomorphic IO
07:19:49 <MagneticDuck> you just need to see that you can write it as (a ->b -> c) -> b -> (a -> c) and then boom, pretty obvious
07:19:59 <MagneticDuck> but newbies aren't used to the notion of *expanding* type signatures
07:20:09 <MagneticDuck> a -> a --> (a -> a) -> a -> a
07:20:35 * MagneticDuck writes a book on 101 ways to fool newbies, but is not yet quite comfortable with lenses
07:20:54 <Kinnison> lenses are still a little magical for me :-(
07:22:47 <MagneticDuck> ups typo, meant to write (a -> b) -> a -> b
07:22:57 * MagneticDuck ciao
07:25:22 <eacameron> is lifted-base common? It seems that it should not be
07:25:27 <eacameron> commonly used
07:26:14 <bergmark> we use it a lot
07:26:57 <Clint> i'm slowly switching to exceptions
07:30:02 * hackagebot libssh2 0.2.0.3 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2.0.3 (IlyaPortnov)
07:30:42 <sshine> Clint, ErrorT?
07:31:19 <Clint> sshine: EitherT usually
07:32:46 <eacameron> bergmark: so you must use your own monads and write MonadBaseControl instances for them?
07:33:50 <bergmark> eacameron: yes, lots of newtypes
07:34:04 <joneshf-laptop> i find myself often needing a function :: String -> Maybe a -> Either String a
07:34:19 <joneshf-laptop> is there alreadying something tht does this
07:34:34 <joneshf-laptop> or some way to encapsulate it easily?
07:34:38 <Iceland_jack> yeah, from ‘errors’
07:34:42 <Iceland_jack> http://hackage.haskell.org/package/errors-1.2.1/docs/Control-Error-Util.html
07:34:45 <joneshf-laptop> or am i just building things wrong?
07:34:54 <Iceland_jack> 'note :: a -> Maybe b -> Either a b'
07:35:00 <sgronblo> Soo... A monad is a burrito but a combined monad is a sandwich? :)
07:35:03 <Razik> Who knows this game Marble blast ultra ?
07:35:14 <joneshf-laptop> Iceland_jack, thanks
07:35:16 <vanila> :t \s -> maybe (Left s) Right
07:35:17 <lambdabot> a -> Maybe b -> Either a b
07:35:25 <Iceland_jack> Latest version of package here http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html
07:35:35 <eacameron> bergmark: that seems so painful! I'm new to rolling my own monads; but the fact that base uses monomorphic IO everywhere makes the experience pretty rough
07:36:04 <flebron>  What does cabal mean when it writes "hastache-0.6.0 (reinstall) changes: bytestring-0.10.0.2 -> 0.10.4.0,"?
07:36:08 <bergmark> eacameron: it's a bit of boilerplate...
07:36:36 <bergmark> flebron: it wants to reinstall hastache using another version of bytestring
07:36:51 <bergmark> probably because some other dependency you have requires a newer version
07:37:06 <flebron> bergmark: Another than what? I have bytestring-0.10.4.0.
07:37:25 <flebron> A different one from the one it was installed with?
07:38:16 <eacameron> bergmark: I'm guessing you use CPP or something, no?
07:38:27 <bergmark> flebron: that says that hastache was installed against 0.10.0.2
07:38:45 <bergmark> eacameron: use CPP for what?
07:38:53 <eacameron> bergmark: the boilerplate
07:40:40 <bergmark> eacameron: nope, it's just 4 lines of code
07:40:57 <eacameron> bergmark: yeah, but it's a rough 4 lines! ;)
07:49:19 <Darwin226> What would you recommend for writing haskell in vim in therms of auto complete plugins and stuff?
07:49:56 <doismellburning> Darwin226: I use nothing more than vim2hs, but there's probably cooler stuff
07:51:20 <Darwin226> What I would like is error checking, GHCi, type info and maybe jump to definition and autocomplete (if that's a thing in haskell)
07:51:54 <doismellburning> me too
07:53:03 <pjdelport> Darwin226: For error checking, Syntastic + hdevtools is quite nice
07:53:38 <Darwin226> pjdelport: hdevtools can also provide type info, any plugins that use that?
07:54:00 <pjdelport> Darwin226: I think so, but i haven't actually poked at that yet.
07:57:26 <sgronblo> yeah i have syntastic + hdevtools or ghcmod, dont remember which one i installed for it to start working
07:58:22 <sgronblo> i think there was a recommendation for vim plugins in that getting things done with haskell pdf that was linked around on the interwebs recently
08:02:35 <sgronblo> Is this correct, {true, false} with false as zero and logical or as binary op is a monoid?
08:03:08 <monochrom> yes
08:03:35 <c_wraith> there's even a newtype wrapper for that in Data.Monoid, named Any
08:03:50 <sgronblo> Where's my field's medal?
08:04:02 <c_wraith> There's also a wrapper for the True/And monoid, named All
08:04:02 <pjdelport> Any and All
08:04:04 <monochrom> gone. come again next year :)
08:04:22 <Hafydd> Don't you mean your monoid's medal?
08:04:27 <monochrom> hahaha
08:04:38 <sgronblo> c_wraith: aww you spoiled it, i was gonna get the medal next time by defining the monoid with and
08:05:39 <sgronblo> anyway, I guess Haskell must be some secret plot to get people to start thinking about abstract math
08:06:14 <c_wraith> Hmm.   does the AMP make Alternative and MonadPlus the same thing?  I really should look into that.
08:06:15 <sgronblo> also it seems monadplus is just a monoid definition for a monad or?
08:06:46 <c_wraith> sgronblo: it is a monoid, but it's a specially restricted version of a monoid
08:07:24 <pjdelport> c_wraith: That's the proposal, yes.
08:07:27 <c_wraith> sgronblo: for instance, you would create a Monoid instance for [a], but a MonadPlus instance for []
08:07:57 <c_wraith> sgronblo: that implies that the Monoid instance could depend on the type of the value contained in the list
08:08:03 <c_wraith> sgronblo: but a MonadPlus instance can't
08:08:37 <sgronblo> http://en.wikibooks.org/wiki/Haskell/MonadPlus ah this page even states it as "The most common approach says that mzero and mplus form a monoid."
08:10:47 <pjdelport> sgronblo: If i'm not mistaken, you can roughly say that MonadPlus m => is equivalent to (Monad m, Monoid (m a)) =>
08:11:30 <c_wraith> I really should go ahead and propose an Alternative -> Monoid wrapper for Data.Monoid.  It's a handy thing to have.
08:12:36 <eacameron> I keep getting this in my attempt to write an instance for MonadBaseControl The first argument of ‘StM’ should have kind ‘* -> *’, but ‘ByteString -> IO (Pool Connection)’ has kind ‘*’
08:12:48 <eacameron> any ideas
08:13:24 <sgronblo> c_wraith: I dont really get the explanation about Monoid for [a] but MonadPlus for []. [] does not mean empty list I guess?
08:13:58 <c_wraith> sgronblo: [], at the type level, is a type constructor, like Maybe
08:14:16 <c_wraith> @kind []
08:14:17 <lambdabot> * -> *
08:14:25 <Iceland_jack> > [] :: [] Int
08:14:26 <lambdabot>  []
08:14:50 <pjdelport> sgronblo: As a type constructor, [a] == [] a, which you can think of as "List a"
08:14:54 <jle`> [a] is syntactical suggar for [] a
08:14:55 <chrisdotcode> how can I print a Parser (from Data.Aeson?) It doesn't have a show instance, sadly.
08:15:34 <sgronblo> Ah I think I get it
08:15:50 <pjdelport> sgronblo: In fact, you can say "type List = []", and then "map :: (a -> b) -> List a -> List b"
08:15:51 <c_wraith> sgronblo: if you don't have experience with abstracting over higher-kinded types..  Well, it turns out to be really useful!  It's an important part of many haskell classes.
08:17:31 <c_wraith> :t mappend
08:17:33 <lambdabot> Monoid a => a -> a -> a
08:17:37 <c_wraith> :t mplus
08:17:37 <lambdabot> MonadPlus m => m a -> m a -> m a
08:18:04 <c_wraith> The difference between those two signatures is important!
08:18:29 <c_wraith> For mappend, the whole type of the arguments/results (a) is constrained by the class
08:18:45 <c_wraith> For mplus, only the type constructor (m) is constrained by the class
08:22:04 <pjdelport> So MonadPlus is essentially what happens when you take Monoid a => a -> a -> a and specialize "a" to Monad m => m a
08:22:30 <sgronblo> c_wraith: I think I get it
08:22:56 <sgronblo> But I can't really think of a rephrasing of what you said that would verify whether my understanding is correct
08:23:25 <c_wraith> sgronblo: Well, then, don't worry about it just yet.  It's ok to take some time on it.
08:24:04 <c_wraith> sgronblo: it was one of the new ideas in haskell that took me the longest to learn. (the other was how to think about laziness)
08:25:08 <sgronblo> Here goes: Monoid is for concrete types where the "addition" is related to those concrete types, example set of string with concatenation as plus and empty string. MonadPlus on the other hand is concerned with adding "contexts" regardless of what the "context" "contains"?
08:25:33 <c_wraith> that's a fair description
08:26:00 <c_wraith> It's a bit inexact, but that's ok.  Just remember that the types themselves are the ultimate authority. :)
08:26:22 <sgronblo> I feel like I havent been understanding this many concepts in such a short time with Haskell before
08:29:12 <nshepperd> 'Alternative becomes a superclass of MonadPlus (in addition to Monad, of course)' hmm
08:29:26 <jle`> c_wraith: they still have to be different i guess
08:29:44 <jle`> or else you would have to do (Alternative m, Monad m) => for everything
08:29:51 <vertas> Join #Open-Chat | A channel with all sensible topics!
08:29:53 <jle`> MonadPlus becomes an empty typeclass with no methods
08:30:32 <c_wraith> jle`: yes, but making Alternative a superclass of MonadPlus means that I can just do an Alternative -> Monoid wrapper, and leave out any mention of MonadPlus entirely.  Which is nice.
08:30:36 <jle`> it's kind of weird though because the laws are kind of in an awkward position
08:30:52 <c_wraith> Yeah, the laws are..  not really settled
08:31:11 <jle`> c_wraith: you still need MonadPlus  if you want to do Alternative stuff and also (>>=)
08:31:20 <jle`> or at least Monad
08:31:39 <c_wraith> jle`: but that's fine, because of the superclass addition
08:32:21 <c_wraith> jle`: people working with MonadPlus can use the Alternative wrapper, and don't need a special MonadPlus wrapper
08:32:29 <jle`> the laws are a bit more awkward because Alternative is defined under laws that don't mention (>>=)...and MonadPlus has laws that do involve (>>=) but do not add any additional methods...so i guess you can only "instance" lawful MonadPlus's, whose Altnerative methods satisfy the laws under (>>=)
08:32:55 <jle`> c_wraith: i'm not sure i understand; Alternative implies Applicative, but that doesn't imply Monad, right?
08:33:02 <pjdelport> The same kind of relationship holds for Alternative: Alternative f == (Applicative f, Monoid (f a))
08:33:33 <jle`> people who want Monad + Alternative would still have to specify both?
08:34:02 <c_wraith> jle`: I think you missed my entire goal.  I want to propose an Alternative -> Monoid wrapper for Data.Monoid.  With AMP in effect, you could use that wrapper if your context includes Alternative *or* MonadPlus constraints
08:34:18 <jle`> ah i see
08:34:22 <jle`> i didn't scroll back enough ^_^
08:34:27 <jle`> sorry :)
08:35:05 <c_wraith> I agree, though, that there's some awkwardness with making the two classes directly related.
08:36:31 <danilo2> Hello! Is there any option to ghc to show additional repositories with installed things (the repos listed with ghc-pkg list)?
08:37:08 <c_wraith> you mean, can you tell ghc about additional package databases?  Yes, though I don't recall the option offhand
08:37:59 <jle`> if anything we can do type MonadPlus m = (Alternative m, Monad m)
08:38:16 <jle`> but laws are still awkward
08:38:23 <enthropy> danilo2: --package-db= ?
08:38:40 <Twey> I can't wait until we add enough extensions that we can specify the laws as part of typeclasses and eliminate all confusion.
08:38:51 <sgronblo> Is this related to what you are talking about? It seems that Maybe's mplus is equal to <|> ?
08:39:19 <jle`> mplus should be equal to (<|>) in the way MonadPlus/Alternative are intended to behave
08:40:02 <jle`> that is, ifa type has an mplus, then it should be equal to the (<|>
08:40:07 <danilo2> enthropy, jle`: I was missing the term "package database". Of course! thank you :)
08:40:25 <jle`> they are supposed to represent the same thing kinda
08:40:35 <sgronblo> Yeah I just noticed that "acb" <|> "def" => "acbdef" too
08:41:31 <jle`> Alternative gives monoidy structure, and MonadPlus adds a right seminearringy structure on top of the existing monoidy structure
08:41:38 <sgronblo> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html#g:2 I dont think the Alternative class is very well described here. How can you know what the result of <|> is supposed to be.
08:42:01 <sgronblo> "An associative binary operation"
08:42:27 <jle`> sgronblo: heh. it depends on the semantics of the instance
08:42:42 <jle`> it also has to have an identity with empty
08:43:34 <jle`> so you really can pick a lot of things with (<|>) and empty for a type, as long as they are monoidy (empty is the identity under (<|>), and (<|>) is associative)
08:43:35 <geekosaur> this is the problem with abstraction; sometimes it's hard to describe said abstraction in ways that make sense. (Monad, anyone?)
08:43:48 <jle`> there are several possible possible instances for Maybe, for instance
08:44:09 <jle`> however, there is only one possible instance, I believe, that will behave as a MondPlus under (>>=)
08:44:14 <jle`> which is why it's so awkward!
08:45:08 <jle`> the problem with Alternative is that it isn't allowed to "say anything" about the behavior under (>>=)
08:45:11 <sgronblo> jle`: hmm something like choosing the right just in case there are two justs or?
08:46:12 <sgronblo> Anyway, I'm supposed to be studying Yesod, not this abstract "crap" :)
08:46:20 <jle`> sgronblo: yeah :)
08:46:34 <jle`> hm actually i wonder how many of the lawful Aternative instances for Maybe are also lawful MonadPlus instances
08:46:42 <Ankhers> Would anyone be able to make some suggestions on how to make this better? http://lpaste.net/109300
08:46:53 <jle`> sgronblo: :P
08:48:53 <jle`> Ankhers: you  can rewrite wordCount in compositional style if you want :)
08:48:56 <sgronblo> I cant even remember how I got sidetracked into this territory
08:50:19 <Ankhers> jle`: Could you elaborate a little more? I don't understand how to do that.
08:52:52 <jle`> Ankhers: instead of foo x = f . g $ h x, which is focuseon x and what functions to apply to it, you can do foo = (f . g) . h
08:53:01 <jle`> which says that foo is just the composition of (f . g) and h
08:53:28 <jle`> and because (.) is associative, you can leave off the parentheses
08:54:09 <jle`> sometimes, writing functions as compositions of other functions helps things seem clearer
08:54:31 <jle`> but not in every case of course; a lot of times, application-style is nicer
08:55:07 <jle`> in haskell we like thinking of function compositions though, because we have the guaruntees that make function composition a useful abstraction, so :)
09:01:58 <Ankhers> jle`: I swear I tried that earlier and it didn't compile. Thanks for the help.
09:02:31 <jle`> Ankhers: no problem!
09:02:48 <Ankhers> jle`: Is that the only thing you would suggest changing?
09:03:19 <doismellburning> does this function already exist? https://gist.github.com/doismellburning/c6f2c844a62e3ef90406
09:03:47 <john_not_jenny> Is there an option to execute code in ghc/i on the command line (ie, python -c "print 4")?
09:04:32 <jkarni> Ankhers: you could also do something like:
09:04:37 <jkarni> Ankhers: wordCount s = let wb = wordsBy (not . isAlphaNum) . map toLower in map (head &&& length) $ group . sort $ wb s
09:04:45 <enthropy> john_not_jenny: ghc -e "print 4"
09:04:53 <john_not_jenny> ah... thanks
09:05:18 <jkarni> Ankhers: gets you a [(String, Int)] from which you can construct the map if you want
09:05:33 <jle`> Ankhers: hm.  well there's not much room to go wrong :)  i might leave a small note that it is a common idiom to import qualified Data.Map.Strict as M
09:05:36 <jkarni> Ankhers: not significantly better though
09:05:38 <jle`> and then import Data.Map.Strict (Map)
09:05:54 <josephle> :t mappend
09:05:55 <lambdabot> Monoid a => a -> a -> a
09:06:01 <josephle> doismellburning ^
09:06:22 <jle`> a lot of the functions defined in Data.Map are used in other libraries (including base!) so it's often  nice to be able to know immediately when reading the code where exactly they come from
09:06:22 <josephle> or actually, that might not be general enough
09:07:59 <josephle> doismellburning: you can abstract your foo function with applicative functors
09:08:09 <josephle> > pure (+) <*> Just 1 <*> Just 2
09:08:10 <lambdabot>  Just 3
09:08:14 <josephle> ^ doismellburning
09:08:40 <Ankhers> jle`, jkarni: Thanks.
09:09:01 <jle`> josephle: that's just liftA2, which isn't what we hants, though :/
09:09:47 <jle`> doismellburning: i think you might like foo f x y = fmap f (x <|> y)
09:09:59 <jle`> oh wait that's not it either
09:10:19 <josephle> jle`: oh, you're right. I need to read more closely...
09:10:24 <jle`> x <|> y <|> liftA2 f x y
09:10:33 <jle`> yeah, i am not sure if it exists in a cleaner form
09:10:42 <jle`> oh that should be flipped
09:10:48 <jle`> liftA2 f x y <|> x <|> y
09:11:12 <jle`> .... liftA2 f x y <|> y <|> x
09:12:40 <nshepperd> that looks like the Monoid instance for Maybe would be if f was <>
09:12:40 <josephle> jle`: it definitely seems like some cross between monoid and applicative
09:29:33 <vektor> where can I find a list of the bare essentials of haskell, like what kind of primitive data types/constructors exist (think 'a' for char or 5 for int) and which functions/operands/operators there are?
09:32:54 <vektor> I can wrap my head around the constructors I need (I think of them as parameterless functions here, I guess that's fine.) due to the problem...
09:34:07 <vektor> But operands... ghci's autocomplete doesn't list (:) for example.
09:34:15 <vektor> I'm afraid I'm missing more than that
09:36:06 <enthropy> vektor: read https://www.haskell.org/onlinereport/haskell2010/ and skip some "redundancy"?
09:36:40 <vektor> redundancy from checking the auto-complete, due to namespaces etc?
09:36:44 <enthropy> I mean you don't need list compreshensions, if/then/else, sections
09:38:14 <enthropy> if you can use "let/in", you don't need to know "where"
09:39:34 <enthropy> the problem with defining some essential subset of the language is that you'll probably see other people's code that goes beyond it
09:39:50 <t4nk445> Hi, i need some help on foldr in haskell. Am trying to reverse a list using foldr.
09:40:04 <t4nk445> This is what I got:
09:40:06 <t4nk445> reverse' :: [a] -> [a] reverse' ls = foldr (\acc x -> (acc:x)) ls []
09:40:53 <yesthisisuser> Is there a nice way to implement "finite sets", similar to Fin in Idris.. In the end, I suspect that what I am asking for here is dependent types..
09:40:55 <yesthisisuser> http://lpaste.net/109302
09:41:03 <enthropy> @src foldr
09:41:03 <lambdabot> foldr f z []     = z
09:41:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:41:07 <vanila> t4nk445, The key to doing this is to understand about function composition
09:41:14 <vanila> here is an example
09:41:16 <enthropy> t4nk445: your definition matches the first equation
09:41:21 <vanila> > (3:) . (2:) . (1:) $ []
09:41:22 <lambdabot>  [3,2,1]
09:41:28 <vanila> > (1:) . (2:) . (3:) $ []
09:41:30 <lambdabot>  [1,2,3]
09:41:38 <enthropy> so your reverse' is just id right now
09:41:58 <vanila> notice that I can reverse it and it stays the same
09:42:00 <t4nk445> interesting, that's what I get when I try different values to it -- id
09:42:02 <vanila> stayes well typed*
09:42:50 <vanila> > foldr (\y zs -> zs . (y:)) id [1,2,3] $ []
09:42:51 <lambdabot>  [3,2,1]
09:43:45 <doismellburning> josephle + jle` - thanks! (had a power cut, sorry for delayed response)
09:43:56 <enthropy> > foldr (\ x xs -> xs ++ [x] ) [] [1,2,3]
09:43:57 <lambdabot>  [3,2,1]
09:44:03 <vektor> enthropy: Sorry, been afk for a bit... well, I'll stick to that essential subset and not need any code from the outside, for the most part. But you're right about if/then/else and where and let and so on
09:45:09 <vanila> ++ is also defined using recursion so this method has O(n^2) complexity
09:45:33 <enthropy> yep. But that's what the intention seems to have been with "(\acc x -> (acc:x))"
09:45:40 <vanila> what's cool about using function composition to build a list is that it still has O(n) efficiency
09:47:42 <zwer> is that guaranteed? in ghc, at least
09:47:58 <josephle> vanila: I've had to use that trick before on list-like structures, it's a pretty cool trick :)
09:48:38 <vanila> zwer, I'm just counting the recursion steps
09:48:39 <jle`> what's the difference?
09:48:43 <jle`> (hehe, bad pun)
09:48:45 <vanila> this isn't related to any specific compiler
10:05:53 <modeller> If I 'd like to use a global variable name after "case ... of ", how to do it?
10:06:50 <modeller> data Fruit = Apple | Orange
10:06:50 <modeller>  
10:06:50 <modeller> apple = "apple"
10:06:50 <modeller>  
10:06:53 <modeller> orange = "orange"
10:06:57 <modeller>  
10:06:57 <doismellburning> @hoogle a -> b -> b
10:06:59 <modeller> whichFruit :: String -> Fruit
10:07:00 <lambdabot> Prelude seq :: a -> b -> b
10:07:00 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
10:07:00 <lambdabot> GHC.Conc par :: a -> b -> b
10:07:03 <modeller>  
10:07:06 <modeller> whichFruit f = case f of
10:07:07 <modeller>                  apple  -> Apple
10:07:09 <doismellburning> :t flip snd
10:07:10 <lambdabot> b -> (a, b -> c) -> c
10:07:10 <modeller>                  orange -> Orange
10:07:17 <keko_> use a pastebin for large amounts of code
10:07:18 <doismellburning> :t flip . snd
10:07:18 <lambdabot> (a1, a -> b -> c) -> b -> a -> c
10:07:26 <modeller> @pastebin
10:07:26 <lambdabot> Unknown command, try @list
10:07:29 <modeller> @list
10:07:29 <lambdabot> What module?  Try @listmodules for some ideas.
10:07:36 <modeller> @list pastebin
10:07:36 <lambdabot> No module "pastebin" loaded
10:07:40 <keko_> http://lpaste.net/new/haskell
10:07:44 <keko_> look at the topic
10:07:44 <doismellburning> oops not snd
10:08:07 <doismellburning> (flip const, woo)
10:08:16 <godel> type theory question: (system f) suppose that I wanna prove that an expression has no type. I assume that it has type \rho and go to a contradiction. But I should asume that \rho is a type, right? I mean, put \rho : Type in \Gamma.
10:08:52 <modeller> http://lpaste.net/109304
10:09:48 <modeller> ok got it. So here is the question again: If I 'd like to use a global variable name after "case ... of ",
10:09:48 <modeller> 	   how to do it? http://lpaste.net/109304
10:13:24 <TempestAdept> Hello. In some days I'll be in a place with very limited Internet access and I'll need to set up a haskell environment for myself on windows. And I'll need some libraries outside Haskell Platform (namely, cryptocipher). Is there a convenient way to  get the dependency tree so I could bring all needed libs with me?
10:15:26 * hackagebot partial 0.1.0.0 - A nullary type class for partial functions  http://hackage.haskell.org/package/partial-0.1.0.0 (PhilFreeman)
10:15:28 <merijn> TempestAdept: How limited is your internet before then? If the answer is "not at all", I guess the lazy mans approach would be to just mirror all of hackage locally?
10:16:26 <merijn> TempestAdept: Otherwise, try "cabal install --dry-run"?
10:23:37 <TempestAdept> merijn: Thanks. I've just noticed that the platform with GHC 7.8.3 has been released, so I'll soon have a system without already installed packages and will get the deptree
10:25:22 <TempestAdept> modeller: the patterns don't work this way. Variable name in a pattern will shadow the global binding. Use guards
10:32:11 <pjdelport> modeller: You'll need something like: whichFruit s | (s == apple) = Apple | (s == orange) = Orange | otherwise = error "unknown fruit"
10:32:28 <pjdelport> oh, foo
10:35:11 <NikolajK> Can I say * is Ob_{Hask}?
10:35:37 <vanila> kinda
10:35:45 <NikolajK> where is the compromise?
10:35:59 <NikolajK> wait, that was a pun
10:36:05 <vanila> lol, totally accidentally
10:36:10 <vanila> well the problem is its' not really a category is it? maybe if you just refer to total functions
10:36:15 <vanila> and total values
10:36:29 <pyon> vanila: It is still a category even with bottom, just not a nice one.
10:36:46 <NikolajK> I know it's not CCC because of that, but is it really not even any category?
10:36:49 <pyon> vanila: But it is also less of a nice category with certain extensions.
10:37:12 <vanila> oh my mistake. I thought you had to get rid of undefined for it to be a category at all
10:37:33 <josephle> vanila: if sets and partial functions make a category, why wouldn't types and partial functions? :P
10:37:48 <pyon> NikolajK: Without bottom and without extensions, I think it is not just CCC, it is bi-CCC.
10:37:59 <vanila> you would want its limits to coincide with haskell data types though: not sure if that works when you throw away undefined data?
10:39:59 <barrucadu> I have in my code if condition then Just $ f ... else Nothing, and it feels like there should be a function to abstract that pattern - is there anything?
10:40:04 <barrucadu> A quick hoogle didn't find anything
10:40:34 <vanila> barrucadu, you could use the maybe monad,  guard condition ; return f
10:41:14 <barrucadu> vanila: Not any shorter than the if, I was hoping for an already existing function something like Bool -> a -> Maybe a
10:41:30 <barrucadu> Well, I guess it saves one line
10:41:36 <alorente> barrucadu: there are a few things like that on Hackage. Try Hayoo instead of hoogle -- http://hayoo.fh-wedel.de/?query=Bool+-%3E+a+-%3E+Maybe+a
10:41:41 <vanila> it isn't intended to make the code shorter
10:42:07 <NikolajK> does anybody know an intro or discussion of Haskell with all of the math as prerequisite? I'm battling a bit with me to read lots of "boring" stuff in RWH or LYAH before I get an overall picture
10:42:33 <vanila> NikolajK, I don't think there is any math prereq to using/learning haskell
10:42:49 <vanila> not more than any other programming at least
10:43:10 <NikolajK> I mean I'd like a tutorial that uses it
10:43:51 <NikolajK> real word haskell literally contrasts it's code with Java. On chapter 4 it says "Our early learning of Haskell has two distinct aspects. The first is coming to terms with the shift in mindset from imperative programming to functional: we have to replace our programming habits from other languages. We do this not because imperative techniques are bad, but because in a functional language other techniques work better."
10:44:24 <NikolajK> I don't want that. I want a topdown concise intro, saying what the main building blocks are, assuming I already know what a monad is etc.
10:45:00 <sivteck> NikolajK, have you seen: http://www.haskell.org/haskellwiki/Typeclassopedia
10:46:31 <NikolajK> I know that exists, but I didn't view it as an introduction
10:46:41 <NikolajK> I'll give it another go, if it's suitable
10:46:49 <vanila> what is it you want to learn exactly?
10:47:23 <NikolajK> what programs are permissable in the language, I guess
10:47:39 <vanila> it's turing equivalent so you can write what you can in any other language
10:49:54 <NikolajK> Turing completeness means every computable function can be computed with some program, but what about http://upload.wikimedia.org/math/4/8/a/48a1e70e50cfac8d1a29e9efd6e20716.png
10:50:28 <vanila> oh you want to understand how the type system works
10:50:30 * hackagebot monad-lrs 0.0.2.1 - a monad to calculate linear recursive sequence  http://hackage.haskell.org/package/monad-lrs-0.0.2.1 (BinJin)
10:51:03 <vanila> I think that a good intro textbook for that is TAPL - it covers a few things that aren't relatd to haskell which you can skip but it is very comprehensive
10:51:38 <pjdelport> NikolajK: Maybe the most effective way will just be to ask specific questions, depending on what you want to know.
10:52:01 <pjdelport> NikolajK: There are a lot of mathematically-minded folk around here that can probably give precise answers.
10:52:03 <NikolajK> I also want to write a program with parsec
10:52:07 <pjdelport> and/or pointers
10:52:15 <NikolajK> TAPL is what
10:53:12 <NikolajK> they play Let It Go here at Starbucks
10:53:43 <NikolajK> Pierce, got it
10:56:48 <NikolajK> is the book downloadable, free?
11:04:45 <flebron> Hi. I have a [IO Int]. Each IO Int takes some time to evaluate (it's benchmarking some stuff), so I'd like to collect via console the Ints as soon as they're available. If I use sequence, this will wait until they're all available to show me the firs tone (since it does \(x':xs') -> {x <- x'; xs <- xs'; return (x:xs)}). How can I get these results in a streaming way?
11:05:08 <vanila> flebron, mapM_ print ints
11:05:09 <merijn> flebron: See async
11:05:16 <merijn> @hackage async
11:05:16 <lambdabot> http://hackage.haskell.org/package/async
11:05:26 <merijn> vanila: No, that's explicitly not what he wants
11:06:35 <merijn> flebron: First "map (>>=print)" to get [IO ()], then wrap each IO () in async and use the sequence of async to evaluate in parallel
11:06:47 <flebron> Cool, thanks :)
11:07:06 <flebron> What if they can't be evaluated in parallel though? (Right now they can't, but I can make it so they can.)
11:07:15 <napping> What was the question?
11:07:22 <napping> That will interleave print output, won't it?
11:07:35 <napping> maybe print is just a bad example?
11:07:49 <flebron> Given [IO Int], print each Int as it arrives, without waiting for the entire list to finish computing (as with sequence).
11:07:57 <vanila> oops yeah
11:07:58 <vanila> :t mapM_ (print =<<)
11:07:59 <lambdabot> Show a => [IO a] -> IO ()
11:08:01 <vanila> that should do it
11:08:09 <napping> Ah, then you may want a queue or something
11:08:19 <vanila> I forgot to bind it
11:08:34 <flebron> Ah, OK, I suppose I can map (>>=print) and see them as they go, that makes sense :)
11:08:40 <napping> incidentally, async has a mapConcurrently
11:09:11 <koala_man> flebron: you specifically don't want it in parallel, right?
11:09:11 <napping> bbbbbbacbdaefcgbhdijakelfmocnpgqbrshtduivjwaxykzelfmocnpgqbrshtduivjwaxykzelfmocnpgqrshtduivjwaxykzelfmocnpgqrshtduivjwaxykzelfmocnpgqrshtduivjwaxykzelfmocnpgqrshtduivjwaxykzelfmocnpgqrshtduivjwaxykzelfmocnpgqrshtduivjwxykzelfmonpgqrshtuivjwxykzlmonpqrstuvwxyz
11:09:19 <napping> is what I got from mapConcurrently (\c -> putStr (replicate 10 c)) ['a'..'z']
11:09:28 <napping> I assume you don't what characters from different numbers mixed together?
11:10:32 <merijn> napping: Can't happen
11:10:38 <napping> can't?
11:10:43 <merijn> print (and other Handle operations) are threadsafe
11:10:57 <merijn> They atomically print to a Handle
11:11:13 <merijn> Handle's are guarded by an MVar in the runtime
11:11:21 <napping> that doesn't mean they print all the characters at once
11:11:31 <enthropy> what library is like ansi-wl-pprint, but supports tables?
11:11:37 <napping> how do you think I got the line 1101110110100000030000400 as part of output from mapConcurrently print [1000..1010] then?
11:11:42 <merijn> napping: It means two prints can't be interleaved
11:12:16 <merijn> napping: I don't know which voodoo mapConcurrently uses
11:12:30 <merijn> My async proposal should not do that
11:12:42 <napping> that's async
11:12:51 <napping> and mapM_ (forkIO . print) has the same behavior
11:13:14 <merijn> Really? That's not right
11:13:15 <napping> the Handle is guarded by an MVar yes, but it oly sends a single character in each atomic operation
11:13:21 <napping> try it yourself
11:14:29 <napping> well, it varies by the buffering mode
11:15:55 <merijn> ah
11:16:14 <merijn> That explains the difference between ghci and real code
11:16:24 <merijn> Line buffered is the default
11:17:44 <napping> yeah, it seems to bottom out around hPutStr
11:17:56 <luite> depends, if the output is a tty the default is line buffering, otherwise it's block buffering
11:17:57 <napping> which specifically prints a character a time to unbuffered streams
11:18:44 <napping> but hPutStrLn makes a separate hPutChar call to put the newline
11:20:33 * hackagebot bindings-hamlib 0.1.0.0 - Hamlib bindings for Haskell  http://hackage.haskell.org/package/bindings-hamlib-0.1.0.0 (RickyElrod)
11:21:16 <napping> huh, but I don't see those getting split in tests
11:21:41 <napping> anyway, be careful about mixing about between threads
11:30:00 <vanila> sequence (replicate 3 (do threadDelay 1000000 ; print 1))
11:30:06 <vanila> I just tested this and it does what you want
11:30:22 <vanila> it sleeps 1 second then prints, three times
11:30:30 <vanila> it doesn't sleep 3 seconds then print them all
11:30:43 <vanila> it's the same as mapM_ (print =<<)
11:38:31 <enthropy> is there some way to use "VG.backpermute :: (VG.Vector v Int, VG.Vector v a) => v a -> v Int -> v a", when I don't know which 'v' is going to be used?
11:39:06 <enthropy> as in I am passing this function defined in terms of backpermute to another function   f :: (forall v a. VG.Vector v a => v a -> v a)
11:39:33 <enthropy> so it seems I cannot provide an instance "VG.Vector v Int"
11:39:39 <JohnTalent> +
11:42:32 <enthropy> oh well I will just use  mybackpermute x ix = VG.convert (VG.convert x `V.backpermute` ix) `asTypeOf` x
11:42:40 <bitemyapp> johnw: yo. that email.
11:42:49 <johnw> what e-mail?
11:43:08 <bitemyapp> johnw: State Monad and fold isomorphism
11:43:11 <bitemyapp> johnw: http://i.imgur.com/ndDy6lP.gif
11:43:13 <johnw> oh, yeah?
11:43:17 <bitemyapp> that's going straight into the dialogues.
11:43:19 <johnw> haha
11:43:26 <johnw> cool :)
11:43:27 <bitemyapp> Too freakin' cool.
11:43:34 <johnw> isomorphisms are where it's at, man
11:43:38 <glguy_> Our side of the split is the best side
11:43:42 <johnw> one could play with them all day and have braingasms left and right
11:43:42 <bitemyapp> johnw: I had a suspicion they were isomorphic in the past because of the way I'd used reduce in Clojure
11:43:49 <bitemyapp> johnw: but I didn't have a proof of such
11:43:53 <bitemyapp> informal or otherwise.
11:45:36 * hackagebot double-conversion 2.0.1.0 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-2.0.1.0 (BryanOSullivan)
11:46:31 <vektor> a question about the usage of "let... in...": Is it safe to assume that any function can be expressed by allowing "let" only at the beginning of the function or directly after "in"? Do you even need "let" after "in"?
11:47:52 <bitemyapp> johnw: https://github.com/bitemyapp/learnhaskell/blob/master/dialogues.md#state-monad-vs-fold
11:48:03 <bitemyapp> johnw: whenever you write cool stuff like that, please notify or PR me.
11:50:27 <glguy_> :t au (iso runState state) traverse
11:50:28 <lambdabot>     Occurs check: cannot construct the infinite type: s ~ (a, s)
11:50:28 <lambdabot>     Expected type: (State s a -> s -> (a, s))
11:50:28 <lambdabot>                    -> (a1, State s a) -> s -> (a1, s)
11:50:37 <glguy_> :t au (iso state runState) traverse
11:50:38 <lambdabot> Traversable t => t (s -> (a, s)) -> s -> (t a, s)
11:51:28 <glguy_> (argument order switched on that one since lambdabot was last updated)
11:53:03 <olivia1> trying to think of a better data structure/algorithm to use here. i need to keep track of how the list has been updated so far while i fold over it http://pastebin.com/jH4q3MCM
11:53:31 <olivia1> (the order of the elements in the list dont matter)
11:55:05 <pjdelport> olivia1: Can you illustrate that with an example?
11:56:06 <spott> what does {-# UNPACK #-} do?
11:56:23 <olivia1> maybe this will add some intuition. i am updating entities and in order to update each entity, the entity must look at the list of all entities in a way that is up to date
11:56:30 <olivia1> b is just some other state that is being passed around
11:57:09 <olivia1> for instance if two entities want to move to a certain position, whoever is first in the list will win
11:57:50 <dv-> i would use the state monad
11:58:20 <olivia1> for the b?
11:58:31 <olivia1> or would that help with the list processing as well
11:58:44 <dv-> for the entities that you're updating
11:59:12 <olivia1> mind sketching a quick example?
11:59:21 <quchen> spott: Do you know what an unboxed value is?
11:59:25 <spott> yup
11:59:56 <quchen> Have you read the GHC manual entry on UNPACK? http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
12:00:35 <quchen> spott: Also note that since GHC 7.8, the compiler automatically UNPACKs strict fields with sizes up to a machine integer
12:01:01 <spott> I'm reading it... is there a way to connect to this structures in c? (or to memory space)?
12:01:05 <quchen> s/integer/word/
12:01:48 <quchen> C as in the programming language? I don't know. What's memory space?
12:03:03 <spott> if you were to lay out the heap: and I have a two valued constructor:  data T = T {-# UNPACK #-} !Float {-# UNPACK #-} !Float
12:03:06 <spott> how does that sit in memory
12:03:56 <quchen> That should be a "T" that has two pointers, each going directly to a float.
12:04:07 <spott> is it [float,float]? is it T = *pointer to location of both floats, T = *pointer to location of one float, *pointer to location of second float?
12:04:19 <spott> quchen: thanks
12:04:20 <quchen> If you hadn't unpacked the fields, the T pointers would point to "Float" fields, which in turn consist of a pointer to a float.
12:04:34 <spott> quchen: I figured that was true
12:04:58 <Cale> Of course, not really pointers to floats
12:05:03 <spott> is there a way to create an unboxed structure?  for example T contains a pointer to two floats in contiguous memory?
12:05:16 <spott> Cale: what do you mean?
12:05:42 <dv-> olivia1: http://pastebin.com/A1UnxeSv
12:05:46 <athan> spott: seq
12:05:48 <Cale> They're pointers to code
12:06:21 <spott> Cale: not if they are unboxed and strict...
12:06:21 <quchen> I simplified a bit there, yes.
12:06:26 <spott> Cale: right?
12:06:29 <Cale> right
12:06:45 <Cale> I was really correcting quchen's description of what you get without the unboxing
12:06:54 <spott> Cale: ok, thanks
12:07:11 <spott> athan: seq doesn't put things in memory... it only evaluates them, so it wouldn't create two floats in contiguous memory, would it?
12:07:53 <Cale> spott: Right.
12:08:03 <Cale> Why are you worried about the exact locations of things in memory?
12:08:06 <quchen> You don't have access to the memory layout in Haskell, unless you use external things (FFI) or go deep inside your compiler's special operations.
12:08:16 <quchen> (Or use a lib to do that for you.)
12:08:17 <Cale> The garbage collector can and will move things around at will
12:08:57 <athan> spott: contiguous as in "next to each other"?
12:09:04 <spott> athan: yup
12:09:11 <athan> it should be sufficient
12:09:14 <athan> well, hmm
12:09:20 <athan> are you making an ffi, spott?
12:10:04 <athan> spott: vector may be a good option for you if you're just looking for a performant, strict container
12:10:07 <spott> Cale: two reasons, number one, It helps with me figuring out how things are going to be evaluated and to sort out a performance model for haskell, and number two: when creating a vector, and dealing with it, you want it in contiguous memory to improve cache coherence:  pointer indirection can kill you
12:10:17 <spott> athan: I'm not making an ffi... I'm just curious
12:10:28 <Cale> spott: If you care about that, then use unboxed vectors or arrays
12:10:49 <athan> spott: haskell is supposed to be imaginary, and everything taken care of (on a machine-by-machine basis) by the compiler/GC
12:10:51 <Cale> But yeah, unboxing strict fields also works here
12:11:00 <athan> ^^
12:11:29 <Cale> You give up all the machinery for polymorphism and lazy evaluation when you unbox things of course though
12:11:53 <athan> spott: There is some overhead for thunks and other wrapper-machinary for dynamic typing (if supported in your app)
12:11:56 <spott> Cale: yea, I know you can't have polymorphism over unboxed values
12:12:31 <athan> Cale: Would it be restricted to a typeclass, then? o.O
12:13:02 <spott> athan: you basically can't have a pointer to "some type" you have to have a pointer to "a specific type"
12:13:31 <olivia1> dv-: i still dont quite see how this helps
12:13:40 <Cale> athan: Well, boxed values are pointers to code
12:14:04 <Cale> athan: When you unbox, say, an Int value, you get that Int sitting there instead of a code pointer
12:14:47 <Cale> So, the code which operates on such things can't be oblivious to the representation.
12:14:56 <athan> Cale: Oh wait, derp. vectors and arrays are homogeneous
12:15:01 <athan> nevermind haha
12:15:27 <Cale> e.g. there's only one compiled version of map :: (a -> b) -> [a] -> [b]
12:15:54 <Cale> (the compiler doesn't build special ones for different types 'a' and 'b' because it doesn't need to, the code required is actually identical)
12:15:55 <athan> Cale: Woah, really?? I thought that the use cases were analysed at compile time and specific cases were compiled!
12:16:07 <athan> wow, that's pretty cool
12:16:28 <javex> hey, complete haskell beginner here. Trying to implement linked lists as an exercise. I want to define the "elem" function, however my module's elem has a collision with GHC.Lists' elem. Is there way to fix that while keeping my elem name?
12:16:48 <Cale> javex: import Prelude hiding (elem)
12:16:49 <dv-> olivia1: if you want to loop over a list in such a way the updated list is available then State is a way to do it (by 'get'ing the list in the beginning of the loop)
12:16:54 <javex> Cale: thanks
12:18:42 <olivia1> dv-: so you dont mean like this? http://pastebin.com/4fbaLHmN
12:19:01 <athan> How could you define factorial with `fix`?
12:19:19 <athan> or is that not right...?
12:19:29 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
12:19:38 <athan> Cale:!!!
12:19:40 <athan> Thank you!
12:19:42 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
12:19:43 <lambdabot>  3628800
12:19:44 <athan> I was looking at it wrong
12:20:22 <athan> this is a catamorphism, yes?
12:20:45 <Cale> Well, factorial is a hylomorphism
12:20:54 <Cale> But we're not really expressing it like that
12:20:59 <spott> athan: that is an interesting use of fix... I wouldn't usually think about looking at factorials as a fixed point calculation
12:21:01 <athan> Hmm, okay
12:21:13 <athan> spott: It's a whole new worrrrrld
12:21:29 <josephle> general recursion is just a fixed point calculation :)
12:21:41 <athan> Cale: I still need to dissect the bannanas and barbed wire paper :/
12:21:47 <johnw> athan: a catamorphism reduces a structure (aka, a fold); factorial "builds" a structure (the set of numbers), and then "reduces" it, even though there is no actual intermediate structure in memory, but just conceptually
12:21:47 <athan> :D!!!
12:21:51 <quchen> The DMR does not apply inside "let" blocks, as far as I know. What about "where"?
12:22:00 <athan> hmm, like a foldl johnw?
12:22:02 <johnw> so hylo = cata+ana
12:22:12 <athan> or like a LR parser...?
12:22:15 <johnw> no, more like an unfold feeding a fold
12:22:19 <athan> hmm
12:22:26 <johnw> but with a termination condition so that it doesn't run forever
12:22:27 <athan> I haven't seen unfold in production code yet
12:22:41 <athan> johnw: Thank you :)
12:22:54 <Cale> > foldr (*) 1 (unfoldr (\x -> if (x > 10) then Nothing else Just (x,x+1)) 1)
12:22:55 <lambdabot>  3628800
12:23:03 <johnw> yeah, exactly that
12:23:04 <johnw> Cale++
12:23:29 <corgifex> heh, "an interesting use of fix". other people think defining recursive functions is the only use of fix
12:23:42 <tulcod> is there any package for dealing with millisecond-precision timestamps?
12:23:50 <athan> hahaha
12:24:07 <Cale> corgifex: In some sense it is
12:24:17 <Cale> Though not just functions
12:24:18 <athan> > :t unfoldr
12:24:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:24:23 <Cale> :t unfoldr
12:24:24 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:24:28 <athan> gratsi
12:24:30 <josephle> corgifex: if that makes brouwer spin in his grave, what is the fixed point of the spin function? :P
12:24:34 <athan> @src unfoldr
12:24:34 <lambdabot> unfoldr f b = case f b of
12:24:34 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:24:34 <lambdabot>    Nothing        -> []
12:24:46 <athan> wow, now that's...
12:24:47 <dottedmag> What's the recommended way to have a separate haskell environment for a project? cabal sandboxes?
12:24:52 <athan> *drools*
12:24:56 <corgifex> josephle: a sphere
12:24:57 <Cale> josephle: There are many fixed points consisting of the axis of rotation
12:25:10 <spott> corgifex: I think recursion is the biggest use of fix, i just didn't think of factorial as a fixed point recursion calculation
12:25:22 <corgifex> eh? it's a recursive function
12:25:28 <corgifex> or a loop, but loops are just recursion
12:25:32 <athan> spott: That was my guess too :)
12:25:32 <tulcod> josephle: A joke from Allen Hazen: is the transitive closure of is the transitive closure of is the transitive closure of.
12:25:55 <corgifex> are you trying to quine me, mister
12:26:20 <athan> dottedmag: Yep! Also check out `cabal sandbox add-source`
12:26:28 <dottedmag> athan: thank you
12:26:32 <solidus-river> jle`: I've got some difficulties with netwire again. I need a way to get a wire to inhibit once an event occurs, or get a wire to produce a value when an event occurs and I've looked through Control.Wire.Core Control.Wire.Interval Control.Wire.Event and i cant see anyway with the given functions to do this. All the examples that live in event land stay in event land untill asSoonAs but I can't build the value you want to from my event untill i kn
12:26:45 <solidus-river> jle`: and happy wednessday :)
12:27:36 <spott> corgifex: sure, but it doesn't HAVE to be done in a fixed point way, and I don't generally think of it that way
12:27:44 <corgifex> huh?
12:27:51 <corgifex> what do you mean by "a fixed point way"?
12:28:25 <Cale> corgifex: You don't normally think about the fact that the factorial function is the fixed point of some mapping on a space of functions
12:28:35 <maurer> @pl \x -> (sum x) / (length x)
12:28:35 <lambdabot> liftM2 (/) sum length
12:28:52 <athan> spott: It gives you way more freedom
12:29:29 <athan> ...could you do this kind of stuff with `seq` to give arbitrary strictness in recursive data structures? o.O
12:29:32 <corgifex> Cale: I never think about that!
12:29:44 <corgifex> I just know recursive bindings can be desugared to fix
12:30:01 <athan> Cale: Holy crap, that's genius
12:30:17 <Cale> athan: What is?
12:30:17 <corgifex> maurer: you can't / length
12:30:38 <modeller> Question: i posted some code on lpaste.net, is there a way to link it from here?
12:30:39 <maurer> corgifex: Yeah, you need to fromIntegral it first
12:30:40 <athan> Cale: The description of factorial you just uttered, I never think like that. I should...
12:30:56 <maurer> corgifex: I just wanted to see how one would lift such a structure
12:30:58 <corgifex> modeller: uh, just mention the url?
12:31:00 <maurer> I suppose I could have done
12:31:00 <Cale> Well, that's what fix does
12:31:01 <johnw> maurer: for larger lists, you should use Tekmo's foldl package to do that
12:31:10 <maurer> @pl \x -> h (f x) (g x)
12:31:10 <lambdabot> liftM2 h f g
12:31:11 <modeller> corgifex: ok i c
12:31:14 <johnw> otherwise GHC will force the whole list into memory
12:31:14 <Cale> It finds the least-defined fixed point of a function
12:31:14 <maurer> to make what I was curious about more clear
12:31:18 <Cale> fix f = x where x = f x
12:31:43 <athan> ahh, thanks for reminding me Cale
12:32:00 <athan> would your definition be more performant than `fix' f = f (fix' f)`?
12:32:01 <corgifex> I've written a few different versions of fix in strict languages, for very practical reasons :-)
12:32:16 <Cale> Yes, though I hate using the word "performant" for that
12:32:22 <athan> erm
12:32:23 <corgifex> it shares more
12:32:31 <modeller> Question: (See code on http://lpaste.net/109308.) Why it fails to refer to global variable in the case expression?
12:32:35 <athan> Cale: More strict...?
12:32:49 <athan> because let bindings are inlined, right?
12:32:54 <corgifex> modeller: because you can't refer to variables in patterns
12:32:56 <athan> or something along those lines
12:33:08 <modeller> (corrected link)Question: (See code on http://lpaste.net/109308 .) Why it fails to refer to global variable in the case expression?
12:33:30 <quchen> That's the same link, modeller.
12:33:31 <modeller> corgifex: So we can only use LOCAL var inside pattern?
12:33:32 <corgifex> modeller: you can only match against constructors and bind new variables
12:33:42 <corgifex> what?
12:33:42 <pjdelport>  modeller: You'll need something like: whichFruit s | (s == apple) = Apple | (s == orange) = Orange | otherwise = error "unknown fruit"
12:33:56 <corgifex> you don't need those ( _
12:33:58 <corgifex> ( )
12:34:02 <Cale> athan: I just hate the word 'performant' in general, because it's needlessly vague and is a new usage for an unrelated noun.
12:34:06 <pjdelport> corgifex: They're just for clarity :)
12:34:09 <modeller> quchen: the second linke is now openable.
12:34:23 <corgifex> modeller: so is the first
12:34:34 <Cale> athan: fix f = f (fix f) will lose sharing.
12:34:46 <athan> Cale: I'll be more strict with myself :)
12:35:00 <modeller> corgifex: nice. I couldn't on mine. Anyway let me try the guard version.
12:35:01 <athan> hmm, ...sharing? You don't have to go into it if you don't want to
12:35:20 <corgifex> sharing results is the opposite of recomputing them
12:35:26 <Cale> athan: Yeah, so the thing about lazy evaluation which sets it apart from plain outermost-first evaluation is that any bound variable is evaluated at most once
12:36:02 <corgifex> > (\x -> x + x) (sqrt 2)
12:36:03 <lambdabot>  2.8284271247461903
12:36:07 <Cale> athan: When you have something like fix f = f (fix f), when f pattern matches on its argument, then fix f will be evaluated anew.
12:36:20 <athan> Cale: Ahh yeah, I remember Pierce talking about how Haskell has a abstract syntax graph because of it
12:36:22 <Cale> athan: and the definition unfolded again and again
12:36:29 <corgifex> s/pattern matches on/applies/
12:36:36 <corgifex> ?
12:36:41 <modeller> pjdelport: I see. So Guard allows global var, while pattern-matching doesn't.
12:37:16 <Cale> Whereas when you have  fix f = let x = f x in x, or equivalently, fix f = x where x = f x, the variable x gets evaluated at most once, and any work done computing it is shared amongst uses
12:37:29 <athan> ahh nice!!!
12:37:31 <athan> that's awesome
12:37:51 <athan> there's no explicit way to "share" an instance of a bound variable to a nested scope?
12:37:59 <athan> yow
12:38:02 <athan> nevermind actually
12:38:07 <pjdelport> modeller: Right. A pattern match *introduces* new variables, while a guard is a normal expression.
12:38:20 <athan> ahhhhh
12:38:52 <Cale> athan: In ghci, import Debug.Trace
12:38:59 <Cale> let fix' f = f (fix' f)
12:39:06 <Cale> fix' (\x -> trace "#" (1 : x))
12:39:13 <modeller> pjdelport: I see. Let me try to further understand that on the Haskell report. Appreciate it if there could be a reference.
12:39:34 <Cale> and then  let fix f = x where x = f x
12:39:39 <Cale> and try the same thing with fix
12:39:52 <Cale> and you'll notice that only one # gets printed
12:39:53 <athan> that's wonderful
12:39:55 <corgifex> fix' (1 :) creates an infinite structure. fix (1 :) creates a single node that points back to itself.
12:41:16 <quchen> Funny how you're discussing a problem that sounds similar to one that I'm having (sharing). My current subproblem is that I cannot find a minimal non-working example ;-)
12:41:49 <quchen> But corgifex' and Cale's fix examples made something click. Doesn't help me, but it's a nice thing to have a drive-by-learn here once in a while.
12:41:59 <Cale> It would be so nice to have a HOPS-like graphical display for the Haskell heap with nicely labelled functions and everything.
12:42:30 <Cale> You could find problems with sharing so much more easily when they appear as existence or absence of arcs in a graph
12:42:31 <quchen> Cale: I'm not sure what HOPS is, but have you seen Luite's memory thing in GHCJS?
12:42:36 <quchen> It showed all the pointers and so on
12:42:41 <Cale> Yeah, there are some cool things like that
12:42:41 <quchen> (In a nice tree)
12:43:23 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
12:43:27 <Cale> ^^ HOPS looks like this
12:43:44 <quchen> Oh, that's very similar to what I mentioned
12:43:51 <corgifex> fix and f sitting in a tree, s-h-a-r-i-n-g
12:44:05 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/screendumps.html
12:44:41 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/Screenshots/BoolList.filter.png :)
12:45:30 <Cale> It's a bit hard to read, but being able to see something like this in action is really useful to understanding the performance model for functional programs
12:46:06 <Cale> The ones based on GHC's internals will probably never be quite as readable, but you can give some sort of sense of the graph structure
12:51:24 <athan> How did you get good at making fixpoint-derived functions? Just tons of trial & error? Any papers that gave you insight?
12:51:40 <merijn> athan: I think it's just tons of doing :)
12:52:03 <merijn> athan: Also, grab a paper/whiteboard and do textual substitutions by hand
12:52:24 <Cale> athan: If you can write the recursive function, it's a simple syntactic transformation
12:52:25 <athan> merijn: Doing that right now xD
12:52:30 <Cale> Like:
12:52:36 <athan> Cale: O_O
12:52:42 <Cale> fac n = if n == 0 then 1 else n * fac (n-1)
12:52:43 <Cale> becomes
12:53:01 <Cale> \fac n -> if n == 0 then 1 else n * fac (n-1)
12:53:10 <Cale> and then apply fix to that
12:53:40 <athan> Okay I'm gonna need some earplugs or something to keep my brain from leaking out my ears, this is too awesome
12:54:24 <Cale> The translation for mutual recursion is a little fancier
12:54:30 <Cale> Like, if you wanted...
12:54:48 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
12:54:49 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:55:04 <Cale> Then you might have to do something like:
12:55:39 <Cale> > let (e, o) = fix (\ ~(evens,odds) -> (0 : map (+1) odds, map (+1) evens)) in e
12:55:40 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
12:56:01 <athan> hmm okay
12:56:03 <athan> that makes sense
12:56:09 <tulcod> Cale: is that really surprising? you're just taking the fixed point of the pair
12:56:12 <athan> I'm definitely going to need to work this out on paper
12:56:18 <Cale> tulcod: It's not terribly surprising
12:56:31 <olivia1> yea i just cant see how state helps me at all here
12:56:31 <merijn> tulcod: It is surprising, if you didn't realise this yet
12:56:43 <merijn> tulcod: Afterwards it's "obvious" ;)
12:56:46 <tulcod> :)
12:56:52 <Cale> tulcod: But it's not quite the simple syntactic transformation that non-mutual recursion can be managed by
12:57:41 <tulcod> reminds me of this guy who tried to tried to tell me something about string theory, and he was surprised by himself that he found the idea that string theory should have 10 or 11 dimensions "obvious" now
12:57:48 <athan> the surprising thing for me was factorial, it's a 2ary lambda
12:58:00 <kristof> "you're just taking the fixed point of the pair"
12:58:18 <kristof> Kudos to you all but I will never be able to think about programming that way. :(
12:58:22 <nolan_d> Is it possible to enable pragmas in the GHCI instance spawned by cabal repl? The repl subcommand doesn't seem to accept -X.
12:58:33 <Cale> athan: Well, I just wrote it like that, but fix only works with the first parameter
12:58:41 <tulcod> kristof: it took me an advanced course in logic & computability :)
12:58:54 <tulcod> ie don't worry
12:58:57 <Cale> athan: It's the same as  \fac -> (\n -> if n == 0 then 1 else n * fac (n-1))
12:59:13 <nolan_d> I added them to my package.cabal's default-extensions but I'm not sure that's wise.
12:59:26 <supki> nolan_d: :set -X$extension
12:59:27 <athan> Cale: :O!!!!!
12:59:28 <athan> okay
12:59:34 <athan> I need to reconfigure my brain
12:59:45 <athan> this is.... *beep boop*
13:00:06 <nolan_d> supki: Excellent, thanks.
13:00:17 <merijn> kristof: I think it's the sort of thing you shouldn't worry about until you need it
13:00:50 <Cale> athan: You can think about what might happen if you apply this function to an undefined-everywhere function:
13:01:01 <kristof> merijn: Someone in here threw around an advanced use for fix but I forget what it was.
13:01:07 <Cale> (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined
13:01:23 <Cale> -> (\n -> if n == 0 then 1 else n * undefined (n-1))
13:01:23 <josephle> kristof: the key to working with (n+1)-dimensions is to start with n-dimensions and add one more
13:01:32 <josephle> works for HoTT, works for string theory :P
13:01:39 <Cale> oh, he disconnected
13:03:53 <solidus-river> q/ws 8
13:06:01 <tulcod> any recommendations for dealing with microsecond-precision timestamps?
13:06:24 <johnw> render them to strings if passing them through Javascript
13:06:39 <tulcod> luckily javascript is not involved. C, however, is.
13:07:09 <johnw> then i'd use a pair of integers, one for the seconds, one for the microseconds
13:07:18 <johnw> or just use Boost DataTime
13:07:24 <johnw> oops, thats' C++, never mind
13:08:06 <tulcod> what would be ideal is some kind of datatype in Base to represent it
13:09:54 <carter> tulcod: look at how criterion does timing
13:10:02 <corgifex> @hoogle UTCTime
13:10:04 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
13:10:04 <lambdabot> Data.Time.Clock data UTCTime
13:10:04 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
13:10:09 <taruti> Is there a infix function like "flip fmap"? That is (<xxx>) :: Functor f => f a -> (a -> b) -> f b ?
13:10:23 <carter> `(flip fmap)`
13:10:37 <tulcod> carter: just a Double. thanks for the tip.
13:10:51 <carter> huh
13:10:54 <joelteon> if you install lens you get <&>
13:10:56 <carter> tulcod: i meant the ffi bits
13:11:03 <carter> @hackage criterion
13:11:04 <lambdabot> http://hackage.haskell.org/package/criterion
13:11:54 <carter> https://github.com/bos/criterion/blob/master/Criterion/Measurement.hs#L188-L201
13:12:16 <tulcod> https://github.com/bos/criterion/blob/master/cbits/time-posix.c :)
13:12:37 <carter> yup
13:12:40 <carter> that too
13:12:43 <carter> theres a bit of asm there
13:14:17 <taruti> joelteon: thanks :)
13:15:43 <joelteon> taruti: i wouldn't install lens just for <&> if i were you
13:15:49 <joelteon> sorry, i was being facetious
13:15:57 <joelteon> if you already depend on it it's fine but just define your own
13:19:12 <taruti> joelteon: just having a name for it is fine, thus I avoid inventing my own name for it, redefining it locally is trivial :)
13:19:19 <joelteon> right
13:19:25 <joelteon> well yes, <&> is my recommendation
13:32:27 <napping> Is there a good alternative to FGL for manipulating a DAG or relation?
13:33:18 <dropdrive> carter: Are you cartazio on reddit?  If yes, can you expand on http://www.reddit.com/r/haskell/comments/2dd2um/what_are_some_haskell_alternatives_to_pandasnumpy/cjogg3z?context=1 ?
13:33:23 <carter> yes
13:33:43 <carter> i also run #numerical-haskell
13:39:11 <athan> #numerical-haskell
13:39:14 <athan> her derp
13:39:15 <athan> sorry
13:40:30 <Tordek> hi! I'm trying to implement some of the exercises from typeclassopedia (Implement Functor (Either e), for example), but I can't because it comes from GHC.Base
13:40:40 <Tordek> is it possible to avoid importing/asking for it exlicitly?
13:41:25 <corgifex> why not just define your own Either
13:42:58 <jkaye> data Either' a b = Left a | Right b should do the trick?
13:43:15 <eacameron> sometimes I really wish I could have where clauses in my lambdas
13:43:40 <eacameron> that seems like it would be a simple lang extension...
13:44:47 <Tordek> corgifex: laziness
13:45:11 <Tordek> jkaye: Left/Right would name clash, wouldn't they?
13:45:19 <napping> Tordek: probably not - you get instances if you import anything from a module at all, so as long as you use the standard Functor and Either you probably get the instance too
13:45:28 <corgifex> import Prelude hiding (Either); data Either a b = Left a | Right b deriving (Read, Show, Eq, Ord);
13:46:17 <napping> Extensions like OverlappingInstances might let you *write* your instance, but being sure you are testing yours and not the standard one is hard
13:47:05 <Tordek> ok, I see... thanks!
13:48:16 <Tordek> can something similar be done about (->) ?
13:49:07 <napping> Huh, that's tricky
13:49:24 <aarvar> you could define a newtype
13:49:37 <napping> For data types, making your own version and using the standard class is nice, so you can test with ordinary functions
13:49:51 <napping> I mean, test with all kinds of standard functions that use that class
13:50:04 <merijn> Tordek: A simpler solution is the following
13:50:18 <merijn> Tordek: "data MyEither a b = MyLeft a | MyRight b"
13:51:01 <nyuszika7h> or data Either' a b = Left' a | Right' b
13:51:37 <Tordek> hiding (Either(..)) already lets me do that the prettier looking way; but now my problem's on (->)
13:52:31 <aarvar> newtype MyFn a b = MyFn { getMyFn :: a -> b }
13:53:15 <pjdelport> Tordek: If you're doing this for learning, another approach is to define your own version of the Functor type class.
13:53:30 <pjdelport> Tordek: And then just define instances for that for the Prelude types.
13:53:37 <Tordek> sure, but now I can't type `fmap = (.)`, aarvar
13:53:41 <pjdelport> Tordek: That has the bonus that you can experiment with modifications to it. :)
13:53:50 <aarvar> well, true
13:53:52 <Tordek> pjdelport: that's a good idea, thanks!
13:55:09 <pjdelport> Tordek: That's especially nice when you get to defining Applicative and Monad instances, and so on; you can experiment with a Monad class that has join instead of just return and >>=, for example.
14:01:18 <parsnip> How does one capture escape sequences from user input? It isn't necessary to use something like ncurses is it?
14:07:31 <pjdelport> parsnip: What do you want to do, exactly? By default, if you just use e.g. getLine or getChar, you get the raw standard input.
14:07:34 <tulcod> parsnip: is System.Console.ANSI what you're looking for?
14:07:43 <pjdelport> (including escape sequences)
14:08:23 <pjdelport> ghci> getLine
14:08:23 <pjdelport> ^[[A^[[B^[[C^[[D
14:08:23 <pjdelport> "\ESC[A\ESC[B\ESC[C\ESC[D"
14:08:25 <parsnip> System.Console.ANSI doesn't provide a means to determine whether a user pressed backspace or something does it?
14:08:40 <pjdelport> ghci> getLine
14:08:40 <pjdelport> ^?^?^?
14:08:40 <pjdelport> "\DEL\DEL\DEL"
14:08:44 <pjdelport> ^- That's backspace
14:08:51 <parsnip> What about arrow keys?
14:09:02 <pjdelport> parsnip: Those were the previous example :)
14:09:07 <parsnip> hmm
14:09:19 <parsnip> Trying it in ghci, y <- getChar
14:09:33 <pjdelport> If you want to make *sense* of the escape sequences, you probably want ncurses or similar, though, yes.
14:09:43 <parsnip> followed by any arrowkey leaves y as '\ESC'
14:09:45 <pjdelport> (otherwise you'll basically be implementing what it does from scratch)
14:09:50 <parsnip> for any arrow key
14:10:04 <pjdelport> parsnip: \ESC is just the start of the escape sequence (hence the name "escape sequence" :)
14:11:40 <pjdelport> So the escape sequence for the up arrow, for example, is three characters: ['\ESC', '[', 'A']
14:12:08 <parsnip> I must be missing something :O whatever I try seems to omit the identifying parts...
14:12:18 <parsnip> ah, so i must capture the entire line?
14:12:23 <parsnip> hmm
14:13:44 <parsnip> What I'd like to do is allow the user to delete and move the cursor while giving input for a CLI application
14:13:46 <pjdelport> parsnip: "the identifying parts"?
14:14:05 <pjdelport> Oh, then you'll want something like readline
14:14:16 <pjdelport> http://hackage.haskell.org/package/readline
14:15:04 <pjdelport> Or without the GNU readline dependency: http://hackage.haskell.org/package/haskeline
14:15:04 <pjdelport> http://hackage.haskell.org/package/editline is another alternative (BSD, not GNU)
14:15:05 <parsnip> well, when trying y <- getChar followed by any arrowkey left me with '\ESC'. Omitting the parts of the sequence that would actually allow me to determine which arrow key they had preed
14:15:15 <parsnip> thanks ill check those out
14:18:22 <tulcod> is there a way to check if some abstract composition of higher-level functions (from the type classes) is equal to a lower-level implementation?
14:18:45 <tulcod> ie. i have two ways to construct some number type, one using fromRational blablabal (the higher level one), and one just using MkFixed
14:19:06 <josephle> tulcod: you can use quickcheck to do it empirically
14:19:09 <napping> parsnip: were there further characters you could get with getChar?
14:20:38 <parsnip> napping: sorry, I don't know what you mean : )
14:21:14 <josephle> tulcod: that is, if you're returning the same type in both cases
14:21:26 <tulcod> josephle: yeah, the types are exactly the same
14:21:32 <tulcod> was wondering if there was a "perfect" way though
14:21:39 <tulcod> maybe compiling to the IR
14:22:05 <merijn> tulcod: If you want to know the "proper" way of proving this, I've got THE right book for you ;)
14:22:10 <napping> parsnip: you called getChar and got '\ESC'. Did you get anything if you called it again without pressing another key?
14:22:14 <josephle> you can inspect the system FC/Core output, but I suspect they won't be the same
14:22:22 <tulcod> merijn: a book on type theory?
14:22:31 <tulcod> merijn: you have my attention either way
14:22:41 <merijn> tulcod: Not on type theory, although I have recommendations for that too :p
14:22:43 <merijn> tulcod: www.cis.upenn.edu/~bcpierce/sf/current/index.html
14:23:23 <merijn> tulcod: Software Foundations, it's covers how to formally prove in Coq things like "are two functions behaviourally equal" (and much more)
14:23:40 <merijn> You can extract/generate haskell and ocaml from Coq too
14:23:59 <tulcod> merijn: do i read the entire thing?
14:24:02 <tulcod> or is there a specific chapter
14:24:20 <merijn> tulcod: The book has tons of exercises, I would just start reading at the intro and do the exercises
14:24:43 <merijn> I recommend using either Proof General (emacs) or Coquille (vim) so you can do interactive proofs and step through the proofs in the book
14:25:19 <tulcod> merijn: (spoiler alert: probably not gonna use these methods in this instance)
14:25:23 <merijn> tulcod: The first chapter or so is "basic" functional programming, should be trivial if you're doing haskell, I'd do them anyway to get used to Coq and then follow the book
14:25:24 <josephle> tulcod will still have to accept the function extensionality axiom into his heart to get the answer he wants
14:25:55 <tulcod> josephle: meh, the premise of extensionality suffices in this case :P
14:28:34 <tulcod> {-# LANGUAGE TemplateHaskell, GeneralizedNewtypeDeriving #-}
14:28:47 <tulcod> nice
14:28:55 <danilo2> Hello! :) Is it possible in TemplateHaskell Convert constructor name to type name? I mean for data V = V I want to convert 'V into ''V?
14:29:40 <tulcod> danilo2: the type of 'V is just a Name, isn't it?
14:30:17 <tulcod> danilo2: there is no difference between names: names are names
14:30:25 <tulcod> danilo2: how you use them is up to you
14:30:29 <danilo2> tulcod: Yes, but it does not work like this in TH. If you are using 'V it is completely different from ''V. I think I just found the answer. After reifying we get the parent name
14:30:48 <danilo2> tulcod: let me show you an example :)
14:31:04 <danilo2> tulcod: lets see ssuch TH funciton: registerCls dataName = return [FunD (mkName "_prop_V_x") [Clause [ConP dataName [VarP (mkName "x"),WildP,WildP]] (NormalB (VarE (mkName "x"))) []]]
14:31:44 <danilo2> tulcod: If I use it like "$(registerCls 'V)" it works, when using $(registerCls ''V) it gives: error: Type constructor ‘V’ used as a constructor-like thing
14:32:13 <tulcod> > ConE ''Int
14:32:15 <lambdabot>  Not in scope: data constructor ‘ConE’
14:32:15 <lambdabot>  Perhaps you meant ‘Cons’ (imported from Lambdabot.Plugin.Haskell.Eval.Truste...
14:32:15 <lambdabot>  Perhaps you intended to use TemplateHaskell
14:32:19 <bernalex> http://www.haskell.org/haskellwiki/Obfuscation what does that program do?
14:32:29 <tulcod> well. "ConE ''Int" is a valid expression in my ghci
14:35:11 <tulcod> danilo2: uh, it works fine here
14:35:33 <tulcod> ghci > registerCls ''Int
14:35:34 <tulcod> [FunD _prop_V_x [Clause [ConP GHC.Types.Int [VarP x,WildP,WildP]] (NormalB (VarE x)) []]]
14:36:27 <danilo2> tulcod: I'm sorry - the other way around!
14:36:27 <tulcod> and ":t ''Int" gives Name
14:36:34 <danilo2> try: registerCls 'Int
14:36:43 <glguy_> It's ''TypeConstructorName   or 'DataConstructorName
14:36:45 <tulcod> danilo2: Int is not a data constructor
14:36:57 <danilo2> tulcod: Oh right, sorry - make a datatype
14:37:26 <tulcod> danilo2: still works
14:37:34 <tulcod> data Bla = Bla Int
14:37:44 <tulcod> registerCls 'Bla
14:37:45 <tulcod> [FunD _prop_V_x [Clause [ConP Ghci5.Bla [VarP x,WildP,WildP]] (NormalB (VarE x)) []]]
14:37:52 <danilo2> tulcod: seriously? In ghci right?
14:37:54 <tulcod> yes
14:38:04 <danilo2> tulcod: give me a second
14:38:24 <tulcod> danilo2: you are probably mixing up type and data constructors somewhere
14:38:30 <tulcod> danilo2: indeed, 'Int is an invalid expression
14:38:52 <danilo2> tulcod: Of course 'Int is not. I'm using data constructors here. wait a second
14:39:36 <danilo2> tulcod: Could you try registerCls ''Bla ?
14:39:45 <tulcod> danilo2: works
14:42:09 <danilo2> tulcod: ok, here you have 2 files, that does not compile: http://lpaste.net/109311
14:45:11 <tulcod> danilo2: and does this work with 'V ?
14:45:22 <danilo2> yes!
14:45:34 <tulcod> okay, that's surprising
14:46:12 <danilo2> tulcod: I dont think so. In other case there will be no sense in making 2 syntax, for 'V and ''V. The only suprosing thing is that it is the same type.
14:47:56 <tulcod> danilo2: the fact that they both have the same type *makes* it surprising :)
14:48:42 <danilo2> tulcod: You are right. I'm sorry - few sentences I've written here today make no sense (like opposite things above - I'm sorry - I'm a little tired :) )
14:49:14 <danilo2> tulcod: anyway - if you reify ('v) you can get ''V  :)
14:49:21 <danilo2> 'V
14:50:14 <tulcod> danilo2: hmm.... i guess a Name corresponds to an actual haskell symbol, rather than just representing a string
14:51:03 <tulcod> danilo2: yeah, it also complains when trying to splice in ''Int
14:51:15 <tulcod> danilo2: so the lesson learned is that a Name can actually have several different subtypes
14:51:58 <tulcod> danilo2: (it only complains at *splice* time, mind you: the expression itself is valid)
14:54:05 <danilo2> tulcod: Oh! How do you know that?
14:54:19 <tulcod> danilo2: which part?
14:54:57 <danilo2> tulcod: that it only complains in splice time? I mean that 'V and ''V are really the same thing, but are treated separately only at splice time
14:55:16 <tulcod> danilo2: because the expression registerCls ''V evaluated - see above
14:56:59 <danilo2> tulcod: I do not see anything above exept oyur sentences "so the lesson ..." , "(it only complains ..." and "because the expression ..."
14:57:22 <tulcod> <tulcod> [FunD _prop_V_x [Clause [ConP GHC.Types.Int [VarP x,WildP,WildP]] (NormalB (VarE x)) []]]
14:58:46 <athan> Kindof a dumb question, but how do I have multiple conditions for an if statement? Preferably in a way that's easy to do in ghci?
14:59:03 <athan> ...and not some kind of higher-order function application tomfoolary?
14:59:25 <vanila> athan, if x then y else if z then w else ...
14:59:42 <danilo2> tulcod: Ok. anyway I'm going to sleep. Thank you for the conversation! :)
15:00:01 <tulcod> athan: case
15:00:05 <corgifex> case () of _ | x -> y | z -> w | ...
15:00:33 <athan> vanila: Ahhh, nice, thank you. Sorry about that
15:00:51 <athan> oh, I thought case needed whitespace, thank you!!!
15:01:24 <corgifex> nothing needs whitespace
15:03:04 <tulcod> athan: additionally, what do you have against whitespace?
15:03:17 <athan> tulcod: It's the devil
15:03:25 <tulcod> athan: if you can choose between readability and density, choose readability
15:03:38 <athan> tulcod: I'm just joking haha, I'm in ghci
15:04:13 <etandel> tulcod: but but but point-free! =(
15:04:14 <tulcod> athan: ghci also has syntax for multi line expressions
15:04:27 <tulcod> etandel: point-free can be more readable
15:04:47 <etandel> tulcod: but is commonly abused
15:04:53 <tulcod> perhaps
15:05:52 <etandel> f = a . b . c $ d .f >>= etc
15:06:43 <etandel> i mean, nothing against something like putStrLn . show . sqrt . fromInteger
15:07:09 <etandel> but when people start using flip, fix and unfold hacks just to be point-free, it can get pretty ugly very fast
15:07:32 <athan> tulcod: How?!??!
15:09:41 <tulcod> athan: http://stackoverflow.com/questions/8443035/multi-line-commands-in-ghci
15:10:19 <benmachine> Cale: I'm making arguments on the libraries list you may or may not agree with http://www.haskell.org/pipermail/libraries/2014-August/023549.html
15:10:28 <tulcod> etandel: luckily the type system sort of tells you that if it made sense to someone, somewhere, sometime, and it still compiles, it probably does what you want :)
15:10:35 <benmachine> Cale: certainly I can't think of anyone else who'd agree with me :P
15:10:50 <benmachine> Cale: short version: no to Data.Word in prelude because it's weird and overflowy
15:12:01 <tulcod> benmachine: is there a Word without negatives and subtraction?
15:12:24 <tulcod> benmachine: cause i'm about to introduce a bunch of them
15:12:29 <joelteon> word is the non-negative version of int
15:12:33 <benmachine> tulcod: what do you mean by that? some other type that has a runtime error when you use those things?
15:12:41 <benmachine> or just no Num instance at all?
15:12:43 <tulcod> compile time would be better
15:12:57 <tulcod> benmachine: is there a better variant, anyway?
15:13:02 <tulcod> like, you're arguing against Word. what's better?
15:13:08 <athan> tulcod: ! Thank you!
15:13:23 <benmachine> tulcod: well, mostly I think that a non-negative type isn't actually that useful
15:13:33 <joelteon> what about for port numbers
15:13:41 <benmachine> well, port numbers aren't really numbers
15:13:46 <tulcod> so what are they?
15:13:47 <benmachine> you can't add or subtract or compare them
15:13:48 <athan> Can you make tail-recursive functions with fix?
15:13:58 <benmachine> athan: fix can encode all recursion ever
15:14:00 <joelteon> what about as an argument to take
15:14:08 <etandel> tulcod: hahaha, indeed.
15:14:23 <tulcod> benmachine: give me a type to represent "port numbers"
15:14:28 <tulcod> cause i need one
15:14:32 <joelteon> well, network has PortID
15:14:34 <tulcod> (that's not actually a joke)
15:14:46 <athan> benmachine: But are they tail-recursive?
15:14:49 <benmachine> right, you want an opaque type that you can construct from an Int or Integer
15:15:27 <bernalex> data [] a = [] | a : [a] -- can someone desugar this step by step so I get it?
15:15:32 <benmachine> athan: my intuition would be that any recursive definition can be manually transformed into a version using fix that has essentially the same behaviour
15:15:33 <bernalex> damn type/data constructor namespace
15:15:38 <joelteon> bernalex, there's no sugar there
15:15:46 <bernalex> joelteon: so what's [a] then?
15:15:47 <benmachine> athan: but I've never tested whether or not the performance is actually the same
15:15:50 <corgifex> bernalex: data List a = Nil | Cons a (List a)
15:15:54 <joelteon> oh, whoops
15:15:58 <Tordek> sanity check: for a datatype "Flip a b" (i.e., b -> a), you can't define a Functor instance for (Flip b)... correct?
15:16:00 <athan> benmachine: Ahh yeah, I understand that. That's how I feel too, let's hope haha
15:16:07 <joelteon> my mistake
15:16:07 <benmachine> Tordek: correct
15:16:14 <josephle> > fix (\fac acc x -> if x <= 0 then acc else fac (acc*x) (x-1)) 1 10
15:16:15 <lambdabot>  3628800
15:16:18 <josephle> athan ^
15:16:22 <Tordek> benmachine: thanks
15:16:24 <josephle> tail recursive factorial
15:16:53 <bernalex> corgifex: isn't [a] here just a : []?
15:16:57 <joelteon> no
15:17:00 <joelteon> in types, [a] is [] a
15:17:01 <bernalex> corgifex: oh right
15:17:05 <joelteon> in values, [a] is a : []
15:17:07 <bernalex> it's not the data constructor
15:17:10 <bernalex> it's the type constructor
15:17:21 <athan> josephle: Too cool :) Thank you!
15:17:23 <benmachine> in all cases, having magic list syntax when it could be a perfectly ordinary data type is kind of silly
15:17:29 <benmachine> well, having [a,b,c] list syntax is sort of ok
15:17:33 <corgifex> bernalex: data [] a = [] | (:) a ([] a)
15:17:35 <joelteon> except when you want to construct a list
15:17:40 <benmachine> but having the type be [a] instead of List a was probably a mistake
15:17:48 <tulcod> @src []
15:17:48 <lambdabot> data [] a = [] | a : [a]
15:18:05 <benmachine> lambdabot's @src is basically made of lies
15:18:39 <bernalex> thanks
15:18:51 <etandel> does it actually read how it's defined on ghc or it's just something people wrote that is equivalent or equal to what actually happens?
15:18:53 <bernalex> I kind of knew all of this but I'm so tired my eyes are about to shut themselves with force :-P
15:19:19 <benmachine> joelteon: anyway, take shouldn't take a Word because taking (-1) from a list is kind of silly but there's a sort of sensible way to do it, whereas take (-1 :: Word) might just be a really bad idea
15:19:32 <corgifex> etandel: it's just some text file
15:19:35 <bernalex> of course of course now my brain is on again
15:19:35 <joelteon> yeah i was just thinking of reasons to use non-negative numbers
15:19:43 <bernalex> the a in [a] is of course a type
15:19:49 <olivia1> how do i make a pattern synonym work for multiple cases into the same pattern?
15:19:53 <etandel> corgifex: oh. thx
15:19:55 <benmachine> and/or type inference will be infectious and make other terms Words when you thought they were Ints
15:19:58 <benmachine> => bad things
15:20:18 <olivia1> pattern Thing i <- ThingA i | ThingB i _
15:21:20 <tulcod> corgifex: wait, someone /wrote/ this? like, by hand?
15:21:31 <corgifex> yeah
15:21:36 <tulcod> wow. too much time.
15:21:56 <corgifex> where did you think the code in the actual libraries came from?
15:22:07 <olivia1> (doesnt work)
15:22:21 <doismellburning> wrote what?
15:22:23 <tulcod> corgifex: i'm just amazed by how much time is put into what is primarily an IRC bot
15:22:55 <bernalex> is it possible to use a regular function as a data constructor somehow?
15:23:02 <bernalex> like data Summed a = sum a?
15:24:51 <tulcod> bernalex: it doesn't work like that
15:25:05 <bernalex> tulcod: no but can you make it work like that?
15:25:05 <tulcod> bernalex: defining a constructor defines a function
15:25:09 <tulcod> you can't re-define it
15:25:15 <tulcod> what's the real issue you want to solve?
15:25:18 <bernalex> is ah of course
15:25:18 <etandel> a constructor is a function
15:26:19 <bernalex> tulcod: I'm not dealing with a real issue. just thinking aloud. :-]
15:26:45 <benmachine> bernalex: I think I kind of see what you're going for, but I wonder how you define the sum function then
15:27:10 <benmachine> in particular, what type does it have
15:27:31 <olivia1> is there a good writeup of what exactly AllowAmbiguousTypes is for/does?
15:32:58 <linman32> hey are there any gtk2hs gurus out there? having trouble w/ packages
15:34:38 <tulcod> linman32: in IRC, you usually don't "ask to ask" - just go ahead and state your problem :)
15:37:53 <linman32> tulcod: installing gtk and its dependencies is really messy in cabal version 1.20. using cabal-library-version might help
15:38:19 <linman32> tulcod: going to try to use cabal-library-version  (no questions right now)
15:38:36 <linman32> tulcod: to install gtk..
15:41:05 <hamishmack> linman32: Which OS?  What error are you getting? Which package gtk or gtk3?
15:42:11 <spott> how do I build the documentation for vector?
15:42:41 <spott> it doesn't want to build by using cabal install vector --haddock-all, or runhaskell Setup.hs haddock
15:43:21 <linman32> hamishmack: ubuntu 14. getting lots of errors, depending on which approach. gtk3 i think not sure
15:43:32 <linman32> hamishmack: this is the closest i got: http://stackoverflow.com/questions/19570575/gtk2hs-fails-to-install-with-recent-cabal-versions
15:43:49 <linman32> hamishmack: the error on stackoverflow
15:43:54 <hamishmack> linman32: Have you looked at the steps travis uses ? https://travis-ci.org/gtk2hs/gtk2hs
15:45:36 <linman32> hamishmack: no. thanks for the info. where are instructions though?
15:46:51 <orion> Does anyone know how to adapt this code to ByteStrings?: http://ideone.com/Hx08mb
15:48:07 <hamishmack> Theres normally not much to it.  If you have the C libs then cabal install Cabal && cabal install gtk2hs-buildtools && cabal install gtk3
15:48:55 <linman32> hamishmack: in the sandbox?
15:49:05 <trap_exit> what is the best way to learn attoparsec
15:49:06 <hexagoxel> afaik you need alex for gtk2hs-buildtools
15:49:06 <hamishmack> If you are having trouble with Cabal check that the latest library is installed with “ghc-pkg list”
15:49:14 <trap_exit> is there a good attoparsec tutorial, or should I just read the RWH parsec tutorial?
15:49:45 <hamishmack> ah yes you will need alex
15:50:39 <Clint> trap_exit: i found that learning parsec actually got in the way
15:50:44 <rduck> http://pastebin.com/m5jtnqAS can anyone give a noob some tips?
15:51:03 <josephle> orion: overloaded strings will make your life easier
15:51:11 <trap_exit> Clint: what do you suggest I read? the raw type defs of attoparsec? :-)
15:51:38 <orion> josephle: I have OverloadedStrings enabled, but I am having trouble figuring out how to make the transition.
15:51:48 <josephle> ok
15:52:09 <tolt> trap_exit: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec is pretty good
15:52:10 <josephle> there are some ByteString functions that are analogous to list functions
15:52:32 <linman32> hamishmack: Failed to install gtk3-0.13.0.0
15:52:36 <ian_mi> Shouldn't I closed type family with only one instance always simplify when possible?
15:52:37 <linman32> hamishmack: that is the error
15:53:26 <ian_mi> I have the closed type family type family (⊙) f g a where (⊙) f g a = f (g a) yet I still get errors such as 'Could not deduce (Object c3 ((:.:) f g a) ~ Object c3 (f (g a)))'
15:53:48 <ian_mi> where Object is a Constraint family I have defined
15:53:57 <trap_exit> tolt: nice, thanks!
15:54:01 <josephle> orion: so for one thing, your permute function can use B.null and B.cons (if you import qualified ByteString as B)
15:54:36 <hamishmack> linman32: Can you lpaste.net the log?
15:54:45 <trap_exit> ### for parsing in haskell ### is there some tool where (1) I specify a prioritized CFG and (2) it generates a parser for me?   It seems that with parsec/attoparsec, I'm writing th eparsec myself -- whereas, I'd prefer to just write a CFG (and tell it what priorites what binary ops have) ... and it generates the parser for me
15:54:46 <orion> josephle: I see. How about the (c:cs) pattern matching?
15:55:18 <tolt> trap_exit: http://www.haskell.org/happy/
15:55:44 <josephle> orion: unfortunately you lose that when you use ByteStrings. You'll have to make do with head and tail
15:55:44 <tolt> trap_exit: It takes a BNF and produces a parser
15:55:58 <benmachine> trap_exit: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html
15:55:59 <bennofs> trap_exit: parsec can build an expression parser from priorities. See Text.Parsec.Expr
15:56:10 <linman32> hamishmack: http://lpaste.net/109313
15:56:13 <trap_exit> tolt: nice, thanks!
15:56:20 <trap_exit> benmachine, bennofs: will look into this
15:57:02 <trap_exit> benmachine: ha! that looks awesome, thanks!
15:57:31 <JohnTalent> wow, not a whole lot of games in hackage is there? :p
15:57:35 <hamishmack> linman32: So this looks like the problem… “gtk2hsC2hs: System/Glib/GObject.chi not found in”
15:58:01 <tolt> Wow, that expression parsing thing is awesome.
15:58:46 <josephle> orion: is there any reason why you'd want to use bytestring? It seems more convenient to use Text for your purposes
15:59:26 <orion> josephle: I am feeding the data to a hashing algorithm.
16:00:31 <hamishmack> linman32: I wonder gtk2hs-C2hs has problems in sandboxes.  Can you try PATH=/home/nickgeoca/workspace/med/demo/.cabal-sandbox/bin:$PATH cabal install gtk3
16:00:39 <sm> JohnTalent: at http://hackage.haskell.org/packages/#cat:Game ?
16:01:16 <linman32> hamishmack: lol, my name is there. whoops.
16:01:28 <linman32> hamishmack: you are saying add the sandbox to the system path?
16:02:05 <hamishmack> Yeah, but I am not sure that is the problem
16:02:15 <hamishmack> I am going to try out a sandbox build here
16:03:09 <JohnTalent> sm no at: http://hackage.haskell.org/packages/#cat:Games
16:03:10 <linman32> hamishmack: errors again. http://lpaste.net/109314
16:07:12 <Cale> JohnTalent: heh, that one miscategorised entry
16:07:35 <JohnTalent> Cale: :p
16:07:43 <josephle> orion: you can do your string manipulations using Text then encode them to ByteString via: http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Encoding.html
16:08:29 <joelteon> if you're manipulating text data, use Text
16:08:40 <sm> JohnTalent: maybe that can be fixed now
16:08:47 <joelteon> hashes are operations on bytes, so you then convert your Text to a ByteString
16:09:19 <orion> josephle: I still can't use pattern matching on Text, right?
16:09:29 <sm> you could ask edwin to recategorise it
16:10:14 <sm> so that no one ever fails to find our game trove
16:11:02 <sm> now, what's all this about: Loading package aeson-0.7.0.6 ... <command line>: can't load .so/.DLL for: /home/simon/.cabal/lib/i386-linux-ghc-7.8.2/aeson-0.7.0.6/libHSaeson-0.7.0.6-ghc7.8.2.so (/home/simon/.cabal/lib/i386-linux-ghc-7.8.2/aeson-0.7.0.6/libHSaeson-0.7.0.6-ghc7.8.2.so: undefined symbol: aesonzm0zi7zi0zi6_DataziAesonziEncodeziByteString_encodeToByteStringBuilder_info)
16:11:38 <josephle> orion: unfortunately not, but perhaps your permute can be redone using higher order functions?
16:12:12 <orion> josephle: It probably can be. I am having trouble figuring out how to approach such a problem.
16:14:14 <hexagoxel> hamishmack: that's the same error. my guess would be that you lack some system (i.e. non-haskell) libraries (some glib (glib2 (?))) stuff
16:15:14 <trap_exit> https://gist.github.com/anonymous/558d227d4c30403d6846 <-- error I get from copying Parsec example (URL in gist) what am I doing wrong? I'm copying literally from the Hackage docs
16:16:28 <josephle> orion: is the end goal of permute to concatenate all the strings in the list returned by permute?
16:16:38 <hamishmack> linman32: I think hexagoxel might be right.  Can you sudo apt-get install libgtk-3-dev (if you have not already)?
16:17:37 <hamishmack> linman32: My sandbox build worked ok, but I had a slightly old cabal-install so I am trying again with the latest version.
16:18:08 <linman32> hamishmack: libgtk-3-dev is already the newest version.
16:18:47 <alorente> trap_exit: where's parens coming from? I can't find it in either your paste or the docs
16:19:04 <trap_exit> alorente: Text.Parsec.Token
16:19:16 <trap_exit> alorente: hmm, that may be the problem ... I used hoogle, then took one that had "parsec" in teh package name
16:20:10 <Tordek> > Implement pure and (<*>) in terms of unit and (**), and vice versa.
16:20:11 <lambdabot>  <hint>:1:26: parse error on input ‘in’
16:20:41 <linman32> hexagoxel: it says libgtk-3-dev is already installed
16:20:45 <Tordek> this was very interesting to do... and surprisingly simple once I realized how all the types fit together
16:21:08 <sm> that problem game "lifter" JohnTalent pointed out, is actually a working boulderdash clone - neat!
16:21:34 <sm> one of my all-time favourite c64 games
16:23:53 <hamishmack> linman32: While this runs you could try cabal install glib cairo pango gio gtk3
16:24:39 <hamishmack> That should force it to reinstall glib (since it seems to be missing one of the chi files from it)
16:24:53 <linman32> hamishmack: Failed to install gtk3-0.13.0.0
16:25:01 <trap_exit> postfix name fun = Postfix (do{ reservedOp name; return fun }) <-- how do I get this one line to compile?
16:25:09 <trap_exit> I'm trying to read http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html
16:25:18 <hamishmack> did it install glib again?
16:26:07 <JohnTalent> ghcjs Hello Word=Success
16:26:10 <linman32> hamishmack: http://lpaste.net/109315
16:26:20 <linman32> didn't seme too
16:27:24 <linman32> hamishmack: oh wait... it is trying to install in med/demo2 instead of med/demo?
16:27:31 <linman32> let me try getting a new sandbox
16:31:34 <dfeuer> carter: there's a comment indicating that trying to share the result of the square when calculating x^4 or x^5 is counterproductive, and therefore these are rewritten to x*x*x*x and x*x*x*x*x. Any idea why this is? Isn't it a matter of three/four multiplies vs. two/three multiplies and a move? What makes the former faster?
16:31:57 <carter> dfeuer: why are you asking me? what code?
16:32:04 <carter> i don't know, benchmark it
16:32:18 <carter> :)
16:32:23 <dfeuer> carter: because you're a numeric performance guru.
16:32:26 <carter> no
16:32:39 <carter> my stance on performance is "write all the different low level versions and measure"
16:32:44 <carter> :)
16:32:46 <vanila> (x^2)^2 takes less multiplications
16:32:50 <carter> yah
16:32:54 <vanila> but maybe x*x*x*x caches better?
16:32:54 <kite_dis> hola
16:33:05 <vanila> (I have no idea how computers work)
16:33:18 <carter> vanila: could have to do with how it unrolls
16:33:27 <carter> vs  having a funcall or whatever
16:33:28 <dfeuer> I doubt it's a caching thing.
16:33:34 <carter> dfeuer: write them and measure :)
16:33:37 <vanila> I see
16:33:53 <haasn> Try let x'=x*x in x'*x'
16:33:55 <carter> dfeuer: http://www.amazon.com/Guide-Experimental-Algorithmics-Catherine-McGeoch/dp/0521173019 read this book
16:34:05 <linman32> hexagoxel, hamishmack: i renamed a directory where a sandbox was and forgot about it. deleted it and am starting over. so far so good
16:34:50 <carter> it gives a systematic exposition on how to benchmark and do perf experimentation
16:35:01 <hamishmack> linman32: Mine just got past the point where yours had the error (so it is looking good too)
16:35:17 <dfeuer> carter: I'm trying to get going on Edward Kmett's reading list right now, and also reading Oliver Twist (which has a disturbing degree of antisemitism). But I'll try to get to that one at some point.
16:35:54 <hamishmack> I wonder if the glib failed to work completely the first time
16:37:00 <mfo> @pl member s t =  isJust (lkup s t)
16:37:00 <lambdabot> member = (isJust .) . lkup
16:37:49 <quchen> I've got an interesting phenomenon that has to do with inlining. I basically have this CAF in one module, and use it in another one; it's a function that pre-calculates some values, think of it as `f = \x -> x * p where p = <100th prime>`. Now when I INLINE it, `p` is only calculated once from the call site; when I NOINLINE it, it seems like it's recalculated on every invocation.
16:38:14 <quchen> Can someone explain why this happens, or is the issue not really transparent with only that explanation?
16:38:19 <merijn> quchen: With or without MMR?
16:38:25 <quchen> merijn: MMR?
16:38:28 <quchen> DMR?
16:38:39 <merijn> MonoMorphism Restriction, yeah
16:38:56 <quchen> I briefly considered the DMR, but not enough it seems. Everything's standard here.
16:39:09 <quchen> In other words, the DMR is on.
16:39:12 <linman32> hamishmack: trying to install glade. requires v2.0.0 or greater, but not found
16:39:14 <linman32> hamishmack: http://lpaste.net/109316
16:39:26 <merijn> Can you paste the CAF?
16:39:41 <merijn> quchen: Does it have a type sig? Does it have a typeclass in it?
16:39:54 <kite_dis> dfeuer: jews are the world's most racist people
16:40:33 <quchen> merijn: Line 207, http://lpaste.net/109317
16:40:54 <quchen> It's not very minimal though :-\
16:40:56 <quchen> @ops
16:40:56 <lambdabot> Maybe you meant: pl oeis docs
16:40:59 <quchen> @where ops
16:40:59 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:41:18 --- mode: ChanServ set +o geekosaur
16:41:20 <hamishmack> linman32: Just for the record here is what I did http://lpaste.net/109318
16:41:23 --- mode: geekosaur set +b *!*a@94.242.205.*
16:41:23 --- kick: kite_dis was kicked by geekosaur (kite_dis)
16:41:30 --- mode: geekosaur set -o geekosaur
16:42:01 <merijn> quchen: I'm willing to bet that with INLINE it's able to specialise the typeclass functions
16:42:21 <dfeuer> Thanks, geekosaur.
16:42:47 <quchen> merijn: So I would have expected that when I export the polymorphic function like that, but make a monomorphic synonym at the call site, everything's specialized and the typeclasses are gone
16:42:54 <modeller> Could anyone help provide an example on using guard inside case...of?
16:43:08 <hamishmack> linman32: I can’t help much with glade as I do not use it (or gtkbuilder).  Javran recently updated some of the examples though.
16:43:17 <hamishmack> linman32: https://github.com/gtk2hs/gtk2hs/commits/master
16:43:21 <dfeuer> modeller: it's exactly like using a guard in a function definition.
16:44:15 <hamishmack> linman32: Actually this is a better link https://github.com/gtk2hs/gtk2hs/pull/47
16:44:25 <quchen> merijn: Problem is I reached my goal now (proper sharing of the value in the 'where'), but I don't quite want to release it without knowing why it works
16:45:07 <merijn> quchen: Consult the glasgow-haskell-users mailing list?
16:45:11 <dfeuer> quchen: a mildly painful approach that may work is -dverbose-core2core
16:45:33 <modeller> dfeuer: http://lpaste.net/109319
16:45:55 <quchen> dfeuer: That sounds very verbose :-s
16:46:06 <hamishmack> linman32: My understanding is that if you have a .glade you can run gtk-builder-convert to make it into a file that will work without the need for the glade library
16:46:20 <yukko> how do I get cabal to install a package to .cabal instead of using the sandbox?
16:46:23 <modeller> dfeuer: I am confused by "case () of _"
16:46:25 <dfeuer> quchen: it is. You'll want to strip your module down to absolute bare bones before you try it.
16:46:38 <quchen> dfeuer: The calling or the defining module?
16:46:56 <quchen> Please say calling
16:48:05 <dfeuer> modeller: that's an "abuse" of case/of to implement what GHC now supports as a multi-way if (I don't remember what it's called). Basically, it's saying "if () matches _, then if this then that else if foo then bar else baz". Since ()
16:48:26 <quchen> MultiWayIf
16:48:27 <dfeuer>  Always matches _, it reduces to if this then that else if foo then bar else baz.
16:48:39 <linman32> hamishmack: maybe example code is old, but it cant find "import Graphics.UI.Gtk.Glade"
16:48:42 <linman32> hamishmack: http://lpaste.net/109320
16:49:26 <dfeuer> modeller: if you've mucked around with LISP or Scheme, they call that construct "cond".
16:50:16 <modeller> dfeuer: So the () means nothing inside the parenthesis literally?
16:50:56 <ReinH> modeller: () is literally an empty tuple
16:51:03 <dfeuer> modeller: the () is actually the only defined value of the () type. Basically, data () = ().
16:51:19 <modeller> dfeuer: I see thanks for the detailed explanation.
16:51:21 <dfeuer> Yes, what ReinH said is right.
16:51:29 <modeller> ReinH: I see. thx
16:51:40 <ReinH> np
16:52:16 <hamishmack> linman32: As far as I know libglade is not supported with Gtk 3
16:52:47 <modeller> xb
16:53:28 <hamishmack> linman32: Try out the examples Javran ported to Gtk Builder.  git clone https://github.com/gtk2hs/gtk2hs.git
16:54:30 <linman32> hamishmack: thanks
16:54:43 <hamishmack> linman32: Then look in the directories he mentions in the pull request https://github.com/gtk2hs/gtk2hs/pull/47
16:56:45 <hamishmack> linman32: Looks like gtk/demo/filechooser was the one that used glade
16:57:04 <spion> @src fmap
16:57:05 <lambdabot> Source not found. There are some things that I just don't know.
16:57:08 <spion> @src map
16:57:09 <lambdabot> map _ []     = []
16:57:09 <lambdabot> map f (x:xs) = f x : map f xs
16:58:54 <merijn> spion: fmap source depends on the functor
16:59:02 <merijn> Also, @src is filled with lies
16:59:02 <spion> yeah, I just realized that :|
16:59:12 <spion> well, I only needed map anyway :)
16:59:29 <spion> only an instance has @src :P
17:02:55 <quchen> Filled with lies?
17:03:17 <quchen>  ?src is filled with lies the same way the Report is.
17:03:17 <merijn> quchen: i.e. not the actual implementations used
17:04:03 <spion> i'm toying around with trying to write a proof
17:04:08 <spion> so that definition will do nicely
17:05:33 <merijn> spion: Oh! Another candidate for Software Foundations :D
17:05:43 <merijn> Is that in @where yet?
17:05:45 <merijn> @where sf
17:05:45 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
17:05:45 <lambdabot> assistant."
17:05:51 <merijn> It is :)
17:06:13 <spion> oh, way too early for that
17:06:21 * hackagebot hayland 0.1.0.0 - Haskell bindings for the C Wayland library.  http://hackage.haskell.org/package/hayland-0.1.0.0 (AukeBooij)
17:06:24 <spion> :D
17:06:31 <spion> no wait
17:06:52 <merijn> spion: It's pretty easy if you're moderately comfortable with haskell, I think
17:06:52 <spion> seems like its not too early
17:06:53 <spion> thanks
17:07:06 <merijn> spion: Lots of exercises and examples too
17:07:33 <merijn> spion: I recommend using Proof General (emacs) or Coquille (vim) with it so you can interactively step through proofs and interactively do proofs
17:07:35 <spion> i got interested reading http://www.haskellforall.com/2013/12/equational-reasoning.html
17:08:01 <merijn> The book itself is just literate Coq files that you can execute/run using those editor plugins
17:11:05 <linman32> hamishmack: do you know how to build a gtk project in the demo examples?
17:15:11 <hamishmack> linman32: Oh to make it in the sandbox the easiest thing might be to add it to the gtk3.cabal file then cabal install ./gtk2hs/gtk -fbuild-demos from the sandbox dir
17:26:39 <gcganley> :t (ap)
17:26:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:27:01 <gcganley> :t <*>
17:27:02 <lambdabot> parse error on input ‘<*>’
17:27:11 <gcganley> :t (<*>)
17:27:12 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:27:18 <linman32> hamishmack: thanks for helping out. going to try your suggestion. i tried creating a local sandbox in filechooser, but that didn't work
17:27:27 <spott> i've got a list with repeated values like: [0,0,0,1,1,2,4,5,5], how do I get a list of the lengths of the repeated sequence?
17:27:29 <linman32> hamishmack: but for now g2g
17:27:41 <vanila> spott, map length . group
17:28:05 <spott> group eh? is there a Data.Vector equivalent of that?
17:31:27 <gcganley> :t (<$>)
17:31:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:31:41 <gcganley> :t (<*>)
17:31:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:32:03 <gcganley> wait so you could use <$> in funtor code and in applicative code?
17:32:48 <cmears> <$> is just fmap
17:32:56 <cmears> And all applicatives are functors
17:39:36 <solatis> does anyone here actually use the UnicodeSyntax language extension? it seems weird to me to put this into a language, as it seems to be a representation problem rather than a language problem
17:39:36 <spott> why is (:+:) not a valid operator signature?
17:40:14 <spott> solatis: it has some annoyances, but \ being λ is kind of nice
17:40:17 <napping> spott: ":" as a leading character is reserved for infix constructors
17:40:19 <schell> spott: maybe it has something to do with cons?
17:40:34 <schell> x : xs
17:40:39 <spott> napping: so it has to be a constructor?
17:40:43 <spott> weird
17:40:54 <napping> yeah, like with uppercase or lowercase at the start of a name
17:40:55 <schell> kinda cool
17:41:02 <solatis> spott: yes but you can also make your editor display it like that, not?
17:41:14 <spott> solatis: which is what I do...
17:41:15 <schell> wait, is that like back-tick?
17:41:35 <schell> like you could do 0 :(,) 1
17:41:56 <napping> what?
17:42:02 <napping> that's 0 :: ((,) 1)
17:42:14 <schell> or would you have to explicitly write your constructor with : in the name?
17:42:17 <napping> with one cons, I mean
17:42:19 <solatis> spott: exactly, so it shouldn't be in the language itself :)
17:42:22 <enthropy> (,) can't be in an operator name
17:42:47 <napping> yeah, Foo can't be a function, bar can't be a constructor, :+ can't be an infix operator, <> can't be an infix constructor
17:42:47 <schell> enthropy: i was trying to use (,) as an infix constructor
17:42:48 <enthropy> > data T a b = a :*+ b deriving Show
17:42:49 <lambdabot>  <hint>:1:1: parse error on input ‘data’
17:42:54 <enthropy> @let data T a b = a :*+ b deriving Show
17:42:57 <lambdabot>  Defined.
17:43:07 <enthropy> > 1 :*+ ()
17:43:08 <lambdabot>  1 :*+ ()
17:43:22 <napping> solatis: it's part of the lexical syntax of the language
17:44:04 <schell> i see
17:44:12 <schell> so it does have to be part of the definition
17:46:26 <cmccann> spott: last I checked, using lambda for lambdas is the one thing UnicodeSyntax doesn't and probably can't do
17:46:40 <spott> cmccann: oops
17:46:59 <solatis> napping: but will it not be more of a problem than a solution when you're working in projects with multiple people?
17:47:02 <cmccann> due to the unfortunate fact that lambda is a letter :P
17:47:13 <spott> you are right
17:47:20 <pjdelport> The fact that - has a syntactic exception but lambda doesn't is kind of disappointing. :)
17:47:35 <solatis> napping: also, it will only work for one specific project -- i rather have *all* haskell code i look at use the unicode substitutions :)
17:48:31 <napping> I think the major part is letting you use unicode in identifiers
17:49:02 <cmccann> pjdelport: I wonder how hard it would be to disambiguate lambdas if it was allowed. the -> seems like it should make only "start of a lambda abstraction" or "lowercase identifier" valid, never both...
17:49:28 <solatis> napping: ah, i thought it was all about replacing patterns with unicode symbols
17:49:45 <cmccann> unicode identifiers is part of the language definitions, that's not an extension
17:49:57 <napping> Oh, am I confused about what's what?
17:50:02 <cmccann> UnicodeSyntax lets you use unicode versions of certain bits of syntax
17:50:09 <cmccann> like → for ->
17:50:15 <pjdelport> cmccann: Having a separate "LambdaIsSyntax" extension seems like it should be reasonable.
17:50:16 <cmccann> and ∷ for ::
17:50:35 <napping> huh, I guess it does seem fairly minor
17:50:38 <pjdelport> That is, it just reclassifies lambda as a symbol, not a letter.
17:50:40 <cmccann> pjdelport: not reasonable enough for anyone to have implemented it yet, apparently
17:50:54 <Hafydd> Shame on anyone who forces someone to use awkward key combinations to edit their source file consistently.
17:52:04 <cmccann> pjdelport: might as well allow using unicode whitespace as identifiers too. then I can finally use the "juxtaposition representing multiplication" unicode whitespace character as an alias for (*)
17:52:18 <johnw> cmccann: you just tempted me
17:52:28 <olivia1> i dont undestand why this doesnt work http://pastebin.com/ZH6BtnzX
17:52:52 <cmccann> johnw: oh noooooo
17:52:56 <cmccann> it would be amusing though
17:53:12 <johnw> olivia1: you never pass anything to 'what' that would indicate what the type of 'k' is supposed to be
17:53:12 <solatis> Hafydd: amen to that :
17:53:20 <cmccann> there are some other categories of unicode code points that are neither reserved syntax nor legal in identifiers, too
17:53:28 <Hafydd> amen to that ∷
17:53:38 <johnw> the code expects you mean B, but lacks the evidence to prove it
17:54:21 <olivia1> johnw: the first foo doesnt do that?
17:54:40 <johnw> no, because k is just at type variable
17:54:45 <silasm> johnw: GNU makefiles let you use whitespace in variable names. I was horrified when I discovered that '$ ' is a valid variable reference.
17:55:25 <silasm> (as well as '$)' and '$(()', among many other horrifying things)
17:55:37 <olivia1> but if i have a function a->a theres no problem
17:55:52 <johnw> but if you're a 'b' to construct a 'k'
17:55:59 <johnw> you were given a function b -> k to know what that means
17:56:04 <johnw> weren't*
17:56:13 <johnw> a -> a is not transforming anything
17:56:32 <johnw> sorry, that was totally unclear
17:56:41 <johnw> you have a given that given a 'b'.  The only thing you know is that it's a Blah
17:56:48 <johnw> you're trying to use that 'b' to construct something that expects a 'k'
17:56:53 <olivia1> basically this is a toy example of a problem im running into with phantom types
17:56:55 <johnw> but there is no connection anywhere between b and k
17:57:25 <johnw> I don't see any phantom types here
17:57:36 <johnw> oh, I guess Thing has one
17:58:09 <olivia1> i guess im sort of hacking about subtyping here
17:58:17 <olivia1> in my case its Worker Employed and Worker Unemployed
17:58:28 <johnw> you may want data kinds then
17:58:31 <napping> olivia1: you're not using the argument "f" at all, I don't see how it's type Foo k is connected to anything at all
17:58:32 <johnw> where you can make that clear and explicit
17:58:40 <napping> you could even give it undefined :: Foo Int or something
17:58:48 <olivia1> i want to be able to hold both of them and process them uniformly, but when i statically know its one or the other i want to be able to use them specifically
17:59:02 <napping> and the body uses blah and stuff to specifically construct a Foo B
17:59:04 <olivia1> without a bunch of error prone pattern matching
17:59:18 <olivia1> i should use data kinds for that?
17:59:49 <napping> It's a bit awkward to wrap up into a list that mixes them, but that's a reasonable plan
17:59:57 <olivia1> okay, thanks!
18:00:01 <napping> this example doesn't really get at a problem with that plan
18:00:08 <johnw> data Status = Employed | Unemployed ; data Worker :: Status -> * where foo :: Worker 'Employed
18:01:07 <napping> The annoying bit is having to do something like data AnyWorker = EmployedWorker (Worker Employed) | UnemployedWorker (Worker Unemployed) to mix them together in a single list
18:01:26 <olivia1> i feel like that defeats the purpose
18:01:28 <napping> and not being able to handle *that* unifomrly with a Worker
18:01:33 <johnw> you mean, if you weren't using data kinds
18:01:39 <johnw> with data kinds you'd just have [Worker a]
18:01:42 <olivia1> ah okay
18:02:43 <napping> johnw: how does that work out?
18:03:02 <johnw> [Worker a] is a list of either a Worker 'Employed or a Worker 'Unemployed
18:03:11 <napping> sure, but not a list that might have some of each
18:03:24 <johnw> a list that can have either one or the other
18:03:29 <johnw> i mean ,a mix of both
18:03:54 <olivia1> what does that ' signify?
18:04:01 <johnw> it names the constructor as the type level
18:04:18 <johnw> s/as/at
18:04:28 <napping> that's a side point, making sure you can only have the phantom type be Employed or Unemployed
18:04:58 <napping> in your paste, you only have constructors to make Thing A or Thing B, but undefined and such can be given a type like Thing String
18:05:26 <napping> DataKinds gives you a lifted version of (simple enough) data types
18:06:03 <napping> so that data Status = Employed | Unemployed also gives you a *kind* Status, and new *types* 'Employed and 'Unemployed
18:06:31 <napping> perfect for that kind of type argument that's only supposed to take on some values
18:06:35 <olivia1> ahh my brain
18:07:15 <johnw> ah, you're right, I still can't have hereogenious lists this way
18:07:48 <olivia1> i still get the Could not deduce (k ~ 'Employed)
18:07:52 <carter> johnw: ohhh, that reminds me
18:08:00 <carter> i need to prototype my "fancier overloaded lsits"
18:08:32 <napping> olivia1: sure, you're always returning a Worker 'Employed, and not doing anything to constrain the argument type
18:08:45 <olivia1> how do i say it can be either?
18:08:59 <olivia1> k ~ Status ?
18:09:26 <Enigmagic> impredicactive types! *ducks*
18:09:35 <Enigmagic> impredicative rather.
18:09:50 <napping> the problem is the other way around - you're already saying k can be anything, but in the body you are returning something that's always Employed even though it's in a place that needs to match 'k
18:09:53 <Enigmagic> or use an existential wrapper
18:10:04 <trap_exit> parsec error: https://gist.github.com/anonymous/cd7f62a054d52fe9bb70 <-- please help me debug :-)
18:10:09 <napping> well, assuming you just changed the type parameters in the paste
18:11:14 <napping> olivia1: if you pass "what" a Foo A, the type promises it will return a Foo A, but the body builds a Foo B
18:12:31 <olivia1> is there any way to express it can be either while still getting the benefit of them being separate sometimes? (without separate deconstructors)
18:13:40 <olivia1> haha, this sounds a bit like suptyping
18:13:43 <olivia1> sub*
18:13:44 <olivia1> uh oh!
18:14:52 <trap_exit> jle`: ping
18:15:38 <napping> one thing to consider is always using some kind of wrapper
18:16:06 <olivia1> is there an advantage to that over just having Status be in the original datatype?
18:17:28 <napping> it's probably a bit too complicated, but you could set things up so you can write functions Worker a -> Worker a, and also have a Worker Employed, Worker Unemployed, or Worker Mixed
18:17:58 <olivia1> thatd be ideal
18:18:03 <olivia1> i could do that with a wrapper?
18:18:07 <napping> still requiring some kind of pattern matching / conversion to get a specific type from Mixed, or to inject a specific type into Mixed
18:18:44 <napping> well, the trick is setting things up so the Worker Employed always has just the right info for an Employed thing, the Worker Unemployed always has the right info the other way, and the Worker Mixed has something you can pattern match on to get one or the other
18:20:04 <solatis> ok
18:20:07 <solatis> that's it
18:20:25 <solatis> i'm going back to keeping things simple, instead of trying to do things the most correct way
18:22:41 <modeller> @ops
18:22:41 <lambdabot> Maybe you meant: pl oeis docs
18:23:10 <modeller> pl oeis docs
18:23:14 <modeller> @pl oeis docs
18:23:14 <lambdabot> oeis docs
18:24:50 <napping> olivia1: something like data Worker a where EmployedWorker :: ??_1 -> Worker 'Employed; UnemployedWorker :: ??_2 -> Worker 'Unemployed; MixedEmployed :: ??_1 -> Worker Mixed; MixedUnemployed :: ??_2 -> Worker Mixed
18:26:18 <napping> or, don't bother with all the hassle and do something like (SharedWorkerInfo, EmployedInfo) vs (SharedWorkerInfo, Either EmployedInfo UnemployedInfo)
18:26:38 <olivia1> i came up with this http://pastebin.com/27tTp8Y8
18:28:12 <olivia1> so 'Something' is the mixed state
18:28:31 <olivia1> its really just a specialized Either though, yeah
18:28:41 <olivia1> thanks for the help :)\
18:29:43 <solatis> is 'A do-notation statement discarded a result of type' a warning i should worry about?
18:30:05 <napping> almost certainly not, unless you didn't mean to discard the result
18:30:11 <solatis> it's about using >> instead of >>=, right?
18:30:16 <haasn> solatis: pretty much
18:30:32 <haasn> You can squelch the warning by using do { _ <- foo; bar } instead of do { foo; bar }
18:30:36 <solatis> no i know, but it's not like haskell will be lazy and not evaluate the monad transormation right?
18:30:38 <haasn> when foo is not of type :: m ()
18:31:06 <solatis> i know, but i'm compiling -Wall -Werror, and i wonder how to handle this
18:31:09 <napping> and pretty much the whole point of do notation is letting you nicely write things that might have effects besides the bound result, it's not terribly unusual to do that
18:31:18 <napping> -fno-warn-unused-do-binds, I think
18:31:24 <solatis> ack
18:31:30 <haasn> That or “void” are the two idiomatic ways to make it compile
18:31:32 <solatis> i will add that to my compile flags then
18:31:39 <haasn> But you can specifically disable the warning if you feel you don't need it
18:32:00 <solatis> well, from my C++ experience, i always learned to compile everything -Wall -Werror
18:32:09 <solatis> i wonder whether that's a good idea in haskell too?
18:32:10 <haasn> Some warnings can be a bit annoying in Haskell
18:32:28 <napping> A few particular cases like using mapM where you could use mapM_ deserve a warning
18:32:29 <haasn> Like type defaulting (usually benign) and ignoring the results of do blocks
18:32:43 <solatis> yeah
18:32:51 <haasn> iirc with -Wall -Werror something as simple as main = print 1 will fail to compile
18:32:56 <haasn> Because 1 is being implicitly defaulted to Integer
18:32:58 <haasn> Which is a warning
18:33:50 <solatis> yeah
18:34:15 <solatis> they should make a -Wsome instead of -Wall :)
18:34:27 <napping> can you get that warning in ghci?
18:35:12 <napping> ah, here's the really bogus one: do fail "Hi"; return ()
18:35:18 <napping> A do-notation statement discarded a result of type ‘GHC.Prim.Any’
18:35:47 <napping> well, maybe you are just supposed to stop at that point
18:36:37 <napping> I suppose that does save you from unreachable code
18:36:54 <napping> I'm not sure how often things you don't mind ignoring actually return some result
18:37:00 <napping> forkIO giving you a ThreadId, for example
18:37:22 <vanila> what is monad reflection?
18:37:43 <napping> vanila: the one from Filinski?
18:37:52 <vanila> I don't think so
18:38:51 <haasn> napping: That one isn't too bogus; although the error message is misleading
18:39:06 <napping> yeah, I guess that makes sense as a kind of unreachable code warning
18:39:07 <haasn> iirc GHC.Prim.Any is an artifact of the internal encoding of unbound polymorphic variables
18:39:17 <trap_exit> does cabal install pull the sources as well?
18:39:26 <trap_exit> I'm looking at ~/.cabal ... and I can't find the *.hs files
18:40:44 <napping> trap_exit: check /tmp. It doesn't install the unpacked sources anywhere
18:40:56 <trap_exit> is there a way to install *.hs files?
18:41:02 <trap_exit> I want to grep throuhg *.hs files
18:41:22 <napping> maybe? the archives are cached under .cabal/packages
18:41:49 <napping> I think there's a nice command, maybe cabal get
18:42:49 <napping> or you could zgrep the tgz
18:43:13 <trap_exit> napping: .cabal/packages worked; thanks!
18:45:04 <jle`> trap_exit: sup?
18:45:15 <trap_exit> jle`: was going ot ask you for hlep with parsec
18:45:19 <trap_exit> jle`: but issues are mostly resolved now
18:45:23 <jle`> solidus-river: for the record, you can always ask in #haskell-game :)
18:45:26 <trap_exit> jle`: how's vacation ?
18:45:27 <jle`> trap_exit: hooray!
18:45:56 <jle`> solidus-river: but i think you can use until from Control.Wire.Interval?
18:46:20 <jle`> solidus-river: and also when, as well
18:46:34 <jle`> trap_exit: it's nice :) thanks for asking! been having a blast
18:48:53 <jle`> solidus-river: all that being said, implicit inhibition is admittedly a bit of a headache, so in the next iterations of netwire/wires it's probably going to be gone
18:57:05 <napping> are there any alternatives to fgl?
18:58:13 <napping> some stuff like using swapped association list in Context is a bit annoying
19:04:51 <solatis> damn, is it correct that building parsec needs a LOT of ram?
19:05:21 <solatis> currently eating +- 3GB ram here
19:11:14 <benzrf> holy crap how has #haskell gone without a single line of chat in 6 minutes
19:11:16 <benzrf> its uncanny
19:11:26 <cwraith> solatis: that sounds unexpected.  I'm not used to things using more than about 1GB, like...  linking hxt, for instance
19:12:02 <solatis> c_wraith: well it's taking about 10 minutes already building, and i had to close my browser because of massive swapping on my 4GB laptop
19:12:21 <solatis> but it appears legit
19:16:55 <drbean> Is there any function, a -> [(a,b)] -> [b], like partition, which does lookup but returns a list of all values with a key, not just the first one?
19:17:31 <Rarrikins> Have you tried filter
19:17:53 <benzrf> drbean: you could manually recurse
19:17:57 <benzrf> or manually fold
19:18:06 <Rarrikins> filter and map
19:18:11 <vanila> :t \a -> map snd . filter ((a==) . fst)
19:18:12 <lambdabot> Eq b1 => b1 -> [(b1, b)] -> [b]
19:18:17 <jle`> filterMap
19:18:18 <benzrf> @hoogle a -> [(a,b)] -> [b]
19:18:20 <dibblego> is it possible to use doctest with GHC 7.8.3, and if so, does there exist a project that does?
19:18:21 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
19:18:21 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
19:18:21 <lambdabot> Language.Haskell.TH.Syntax RecP :: Name -> [FieldPat] -> Pat
19:18:23 <benzrf> :t filterMap
19:18:24 <lambdabot>     Not in scope: ‘filterMap’
19:18:24 <lambdabot>     Perhaps you meant ‘filterM’ (imported from Control.Monad.Writer)
19:18:28 <Rarrikins> map snd . filter ((==a).fst)
19:18:39 <jle`> mmaybe a list comprehension would work well
19:18:45 <benzrf> yes certainly
19:19:06 <benzrf> [b | (a, b) <- l, a == p]
19:19:15 <jle`> ya
19:19:21 <solatis> and now ghc is running for 6 minutes already building the `network` package
19:19:24 <jle`> except don't use a and b as variables :)
19:19:27 <solatis> something feels wrong
19:19:32 <jle`> data variables
19:20:20 <solatis> ohhhh
19:20:25 <solatis> i think i know what might be going on
19:21:06 <solatis> my (user-global-)cabal config has -Wall enabled, and apparently the compiler output is buffered
19:25:21 <sgronblo> Is uninstall-hs only for haskell installs installed by haskell platform?
19:26:48 * hackagebot hspec-wai 0.3.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.3.0 (SimonHengel)
19:27:49 <sgronblo> oops, looks like i had an older version of haskell platform, and both haskell-platform and ghc installed through brew as well
19:40:26 <bmuk`> Hey does anyone know if haskell packages are broken atm on arch? xmonad --recompile is saying it can't find any of my imports. ghc-pkg check says it's looking in ~/.cabal, but I installed via the repos?
19:41:59 <pavonia> What is the full output of ghc-pkg check?
20:02:16 <bmuk`> pavonia: I can't seem to get ghc-pkg to cooperate with wgetpaste :/
20:02:57 <bmuk`> http://pastebin.com/aDzgkN2f
20:03:41 <modeller> Could someone help take a look at the code below? (detailed version in http://lpaste.net/109339 )
20:03:42 <modeller> -- Question : why couldn't match?
20:03:43 <modeller> myIntersperse :: a -> [[a]] -> [a]
20:03:43 <modeller> myIntersperse _ [(x:[])] = [(x:[])]
20:03:46 <modeller>                            
20:05:01 <bb010g> Take a look at the RHS first. What's the type of (x:[])?
20:05:44 <modeller> bb010g: it should be [a]
20:05:54 <modeller> :t (x:[])
20:05:55 <lambdabot> [Expr]
20:05:55 <pavonia> bmuk`: Oh wow. What happens when you try to reinstall these packages, say mtl?
20:06:27 <pavonia> (I'm not even sure if you can install mtl separately)
20:06:37 <bb010g> modeller: Then you wrap that in [] to get [(x:[]]. That has type [[a]]. So, fix your type signature first.
20:07:35 <solatis> ok people, i need someone to guide me in the right direction again
20:07:35 <pavonia> bmuk`: Also, is there an mtl directory in /home/bmuk/.cabal/lib/x86_64-linux-ghc-7.8.3/?
20:07:39 <solatis> look at this code: http://lpaste.net/109340#line57
20:07:43 <bmuk`> pavonia: http://pastebin.com/48UniHbp
20:07:44 <ludamad> #lua
20:07:46 <ludamad> Woops
20:07:53 <kristof> Gross.
20:08:05 <bmuk`> I don't have a .cabal directory
20:08:32 <solatis> i'm trying to build an automated test, but i'm tangled in all kinds of monads -- how would *you* validate those properties?
20:08:50 <modeller> bb010g: Oh you mean the 2nd occurence. yes I saw it now
20:09:24 <bb010g> modeller: RHS = right hand side
20:10:22 <modeller> bb010g: got it
20:10:53 <pavonia> bmuk`: I think something is seriously broken but I dont know how to fix it. How did you install Haskell on your system in the first place?
20:13:22 <modeller> bb010g: yes now it pass on that error. thx
20:15:41 <bmuk`> pavonia: the normal way - yaourt -S ghc happy alex cabal-install haddock
20:16:13 <bmuk`> pavonia: It's okay, though. I think I'm going to reload my box tonight anyway
20:16:20 <bb010g> bmuk`: With or without [haskell-core]?
20:16:33 <bmuk`> the repo? without
20:16:40 <bb010g> Also, look into NixOS before reinstalling
20:17:02 <bmuk`> bb010g: do you run Nix?
20:17:24 <bb010g> bmuk`: Yes, and it's pretty near magical how easy it is.
20:18:42 <bmuk`> bb010g: is the install process tedious? (I consider arch mildly tedious, gentoo/funtoo much more so)
20:19:24 <MP2E> as much of a NixOS fan as I am, I think the beginning is pretty tedious
20:19:34 <MP2E> once everything is running it's incredibly smooth
20:19:46 <MP2E> bit of a paradigm shift though
20:20:17 <bb010g> bmuk`: Not too bad. It's a whole lot better after the first install. I'll throw up my configuration.nix here so you can take a look.
20:20:33 <MP2E> ^ truer words could not be said, my second install of nixos was like 10 minutes
20:20:37 <bmuk`> Okay thank you
20:20:54 <MP2E> but I just copied a configuration.nix from one of my other machines and fiddled with it
20:20:56 <bmuk`> I'm glad you caught me; I was about to dd Qubes onto my usb
20:21:12 <bb010g> https://www.irccloud.com/pastebin/SY80vOOE
20:21:16 <bb010g> bmuk`: ^
20:21:54 <bb010g> I could pretty much copy and paste that to another fresh box and have a near-identical setup.
20:22:26 <bmuk`> That is pretty awesome. Does it handle cabal hell as well as I've heard it does
20:23:21 <bb010g> bmuk`: Yeah, you can just use nix-shell --pure and default.nix in your project folder. Let's take this over to #nixos
20:23:38 <bmuk`> okay
20:31:37 <vanila> A huge haskell program is telling me "Prelude.undefined"
20:31:54 <vanila> how would I go about finding out what's causing that?
20:32:08 <vanila> it's ntot my code and its many many line
20:32:09 <vanila> s
20:32:30 <swgillespie> grep for "undefined" ?
20:32:31 <bb010g> vanila: Can you trace the file and line:char?
20:32:44 <vanila> How do I trace it?
20:33:03 <vanila> and it's not a single file but an entire program (a few directories full of .hs files)
20:33:20 <bb010g> I thought it gave location context, I may be remembering wrong
20:33:46 <dibblego> vanila: compile with -prof -auto-all -caf-all and run with +RTS -xc http://www.haskell.org/haskellwiki/Debugging
20:33:54 <vanila> awesome dibblego ill try it thanks
20:38:02 <vanila> it's weird, i've done a clean and rebuilt the whole thing with cabal after adding those flags to the .cabal.. but the +RTS -xc flags are giving me a huge message about having to enable -prof (but I did?)
20:38:24 <vanila> oops, i only added it to one executable in the package
20:40:34 <vanila>     Could not find module ���System.Console.ANSI���
20:40:35 <vanila>     Perhaps you haven't installed the profiling libraries for package ���ansi-terminal-0.6.1.1���?
20:40:43 <carter> vanila: :)
20:40:48 <vanila> this is little odd
20:41:05 <vanila> I'm worried I need to get EVERY dependency, and rebuild it with profiling?
20:41:12 <carter> vanila: you might have to explode  ~/.ghc and set library-profiling : True in ~/.cabal/config
20:41:13 <carter> wellll
20:41:15 <carter> idk
20:41:39 <vanila> this thing is using a cabal sandbox, will that make things any easier?
20:41:39 * carter looks a dibblego  :)
20:41:44 <carter> yeah
20:41:48 <carter> explode the local cache
20:41:57 <carter> and add the right profiling flag to the sandbox config
20:41:58 <dibblego> carter: ?
20:42:19 <pavonia> vanila: Yeah, -prof needs all depedencies to have it enabled
20:42:23 <carter> i'm bad at profiling tooling, so i probably should shutup :)
22:02:30 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF | XCode 5 issues? http://is.gd/H4sEub'
22:02:30 --- topic: set by monochrom!trebla@216.138.220.146 on [Sun Aug 03 09:04:00 2014]
22:02:30 --- names: list (clog dvennink dimday josephcs Derbycat rekahsoft kcantu jcullen mgaare dgpratt cap3lla pweaver_ tmct shintah danvet Guest45558 CmdrMoozy MercurialAlchemi drbean dfeuer startling anttih egul solidus-river samcal why_away trap_exit DanielDiaz fold djfoote blazb dolio zaphar_ps xinming_ samrat MrWoohoo Welkin rejuvyesh Swizec glguy artymis sabirc arpunk joeyh Maxdamantus Nimatek_ amosr c74d ixian8 ziman_ klugez_ acharles nuttycom Lambdanaut Phillemann dmac)
22:02:30 --- names: list (Belgarion0 charlie cmn _ashbreeze_ jonathanj skilpat NinjaPenguin wjlroe _jrp_ teeteewhy melter doshitan metaf5 Internet13 plutoniix lpsmith _5kg Total_1mmersion_ asjo linduxed ion shmookey fqsxr canta StoneToad _ikke_ pranz1 dyreshark reggie1 myme polyidus sbrg chrisdone koz rrradical bjornars Plasmastar __main__ ij- Pythonfant mawuli__ lpaste_ Jello_Raptor alang indiv0 MindfulMonk mickk suOya__ Tordek_ jrslepak_ felixn_ Freundli1h pp^ cdk_ spaceshi1s)
22:02:30 --- names: list (jj2baile helgar_ m4farrel_ radix___ eyem_ scopedTV rudi_s_ elij Bwild_ Jonno_FT1 redtricy1le Shozan otto_s_ integral_ ljhms_ Dodek_ tstc` thirsteh_ fionnan_ gws tridacty1a bd__ aprescot1 andrewsw_ danking_ jix_ poucet_ ehamberg qwandor|quassel RevJohnnyHealey aartamonau bgyss stvc_ NobbZ|ZZzz Wamanuz2 shennyg jmcc zling__ eamelinky asabil lacrosse__ rschulman_ PatrickRobotham zph biscarch dlackty_ serjeem_ mbrcknl jonsterling mankyKitty oldmanstanley_)
22:02:30 --- names: list (posco Natch petercommand quaestor1 tarmil``` ilmig ernst_ stevely_ M-ou-se_ shintahW gauthier eevar Rufflewind Nervkind jordanl saltylicorice linman32 dibblego path[l] ForNeVeR Argue_ kerrick iXeno AfC zcd etehtsea dysinger systemfault corgifex jlyndon joshsz korpse________ shanse kroogs bgamari silasm amiri vsayer iteratee PotatoGim gentleben stalintrotsky erikd phaskell phay weems|mac croyd jao` S_T_A_N ch4rl35 ian_mi ruukasu kristof jfischoff)
22:02:30 --- names: list (StoneCypher kaol hc Jesin apaku buckmaster meandi__ jxnl tranma digixtc yeltzooo choosegoose desophos ilk afarmer dogmaT jang1 steamboat WraithM dsantiago roconnor carlosgaldino limepod cobakobodob theorbtwo jml nisstyre gamegoblin predator117 Nahra` execut3 ivan\ Philonous spopejoy pavonia Longlius kazagistar ddere zarul rmk_ orion ThatOtherPerson jedws yukko bb010g gienah j2j michaelneale tromp Sgeo pobody Eagle_Erwin gfixler codesoup thoughtpolice)
22:02:30 --- names: list (gereedy yfeldblum talios vikraman ckw JZTech101 r444 innertracks asante SmileyKeith ellipsis_ tabemann Betal sea-gull stepcut oberstein zz_LoRdToLsToI Nickeeh codile fall_ LordDeath ThePhoeron Reiser si14 lfp Diskord ggherdov GGMethos fergusnoble Svedrin ttuegel trez asfp sw1nn zanchoPansa kongo2002 Castor0 jrw Boreeas strmpnk orzo Jaxan raid idnar Yawgmoth_ gspr jennmoneydollars Xorlev yeshuah k4r1m_ puzza007 sdx32 billyiii aloiscochard kirjs__)
22:02:30 --- names: list (MiracleBlue NemesisD` LeNsTR cdidd haskoiner bjorkintosh aaron8910 ninedotnine agatam pxqr jtcwang dagle reizuki_ tb01110100 noam bcoppens omefire2 so tgeeky joneshf-laptop Enigmagic pyon franckverrot nshepperd Cale Talryn kqr tpsinnem shergill kshannon ValicekB subleq Licenser Vq Laquendi xrz oubiwann plhk_ ahf jlewis__ solarus_ curlywur2y twopoint718 mjrosenb ZsoL_ gsilvis squimmy flojistik lpvb_ gandr_ xahry_ Zariel japesina- funfunctor1 javawizard)
22:02:30 --- names: list (mikecaruso1 ozataman_ yakutori_ peterhil` Kron lgt neptunepink kylcarte ksf dkua eazar001 latro`a alpha123 kludgy OlegYch8 gilligan- prinsen asdofindia dreixel_ schell yacks pjdelport \q shelf JagaJaga OscarZ leifw ekroon_ kmapped triliyn vital glguy_ FreeFull monochrom thunderrd john_not_jenny centrinia guampa caumeslasal dabradley lokydor descender comma8 Jaak Aeriff mkrtem bergey Wuzzy L8D cjheath erickedji jake_l funrep bygone kfish Athas statusbot)
22:02:30 --- names: list (divyanshu tg Nik05 adamse saep purefn1 arch_ horlicks_ MitchW jle` MrGwen liszt tv Floyd_ Guest22892 frontendloader o0oo0o mendez alvdav ousado jwheare2 javex terlar SoupE armyriad etabot hinidu eyck savanni ThatCantBe acikers agjacome hackagebot vmeson fling arj Khisanth jaimef alxgnon naudiz nolan_d dougia estulticia kardboardb nifty AntiSpamMeta igorii mattp_ dlundy slasktask estewei_off IanKelling tumdedum d-snp kmicu Paprikachu haasn Excureo djcoin)
22:02:30 --- names: list (nakal_ Dtgr sm jpierre03 Mokosha stepkut shouya plucas fikusz `^_^v Lefeni jophish troydm eeezkil falafel joelteon notori0us augur lamilami rom1504 user___ waterlaz preyalone xpinguin wjm carter bmuk dgvncsz0f afleck himikof bounb dsirenko Kneiva boegel|work skuggi raphie__ CARAM nick1234abcd SethTisue_______ blindscreen andreypopp jodaro ikke cstrahan Raynos chas zpconn_________ aristid Imdsm c9sould jroesch_ yrashk wjt steshaw avdi_ tobyp termos etrepum)
22:02:30 --- names: list (bchar teehemkay sclv m_george emmanueloga AlainODea sindresorhus mno2 mindos_cloud___ superjudge__ _tca tarcwynne Karethoth_ akahn metadave alphonse23_ ocharles mrb_bk jzelinskie jabbslad__ MMuse_ cloudhead dstockwell ReinH MediumDivision wizonesolutions pygospa sunfun kalz hvr mceier coppro liyang helge_ murphy_ maoe1 KitD Shogun jlamothe mornfall mountaingoat relrod AleXoundOS bens tomboy65 Rakkin Gilfoyle yano ninegrid gseitz semberal antoniy tov deni)
22:02:30 --- names: list (Draconx nemesit|znc TDJACR Zekka hbar cjwelborn imalsogreg dan64 c-rog ortmage Rylee tsani bsmt adlan solirc Biohazard yusukesuzuki Rarrikins zeroskillor Drezil case39 whaletechno saml Brando753 lifenoodles ephemeron shiona CindyLinz mr- phadej hamishmack Bazzie copumpkin jonh lusory thetallguy1 bydo SparkySparkyBoom thetallguy bbloom benzrf robbert Lindrian seagreen ajcoppa brycelane grynn omefire3 Cr8 mads- jcurbo infinity0 unsymbol perrier noteventime)
22:02:30 --- names: list (ibid otulp Desoxy eyenx ps-auxw mgomezch effy_ amatsu rlp10 isomorphic fall` DrCode ninzine Kobata mike4 shachaf dsturnbull wagle clstopher42 coaupiff simcity2000 purefn Soft lambdabot ChristianS AncientPC Burton ffledgling|afk sveit codeburg BeLeKy obcode edran repnop stew BlastHardcheese frerich n-dolio mwestrik SenorSenpai zz_mopemope ido StolenToast wto mavam wtw LeaChim Pad^ gridaphobe Starfire DarkFox _d3f stoned Klumben Guest75732 luzie cerchio Paks)
22:02:30 --- names: list (mutable haroldwu tippenein inr papna farn yac kav_ arun paz harski tomprince Tehnix jdiez jtobin eL_Bart0 mayski_ David kittenso1p Razz_ supki Ornedan kennyp emma nesqi srcerer hyPiRion frms indigo werdna tnks manfoo7`` oblivian FragByte s4msung hmax skarn cschneid tamiko umib0zu tych0 Kazurik kloeri ciaranm Baughn albel727 sohum henrikhodne bartavelle Shin-LaC vozz jnoah no_name mikeplus64 ezrios jrib bbee hpd frsilent benbangert TheMoonMaster ipuustin)
22:02:30 --- names: list (iross Someguy123 SegFaultAX s_e_ nyuszika7h andyland drdo bra Edoxile pcapriotti johnw diginet_ Taneb abh greymalkin CosmicRa` mimi_vx pnielsen_ BeardedCoder thebnq theDon bitemyapp taruti martingale abc56889 Gothmog_ arrdem aninhumer devn zebr mxf j0ni_ heath benmachine tessier shlevy pii MasseR lispy Entroacceptor chit honkfest1val ktosiek cyanoacry Blkt_ Iceland_jack slobo_ ssedov DustyDin1o kaiza mmaruseacph2 stelleg waxjar drlemon nik_89 vamega ormaaj)
22:02:30 --- names: list (periodic dropdrive mortberg jakutis Luke- hodapp obiwahn mami gbarboza cmccann kalloc emlow mrpantoufle djahandarie Corey friden mononofu sofancy raek geal qz joefiorini aford aoh zerokarmaleft Deewiant peltchu lyxia Profpatsch dqd bergmark rabisg thorkilnaur_ annulus zomg Intensity Arnar_ `micro honza hpc krakrjak yam enko cpa brixen amf not_a_bear Martty mirsal Watcher7 deavid heaumer nikola cepheus mrmonday nwf otterdam hanDerPeder Rembane jungnam)
22:02:30 --- names: list (sixthgear ens Artpicre Cryovat saiam Plazma janne kgadek alorente bwe xplat eddd doismellburning kragniz Hafydd faern FireFly pikhq blast_hardcheese rblackwe byorgey ryanakca coconnor schlumpi jorj irssi_ heyj bvad bjobjo dv- Erstarrung xpika fryguybob gargawel_ jayne ClarusCogitatio dustinswan jaspervdj b_jonas fractalcat JPohlmann Saizan mixi dp_wiz Kruppe jglukasik machineslearn flebron Guest74109 ft isomorphismes alinab lulf mrshoe EvanR karls)
22:02:30 --- names: list (koninkje_away ircbrowse cods ab9rf heudebeu joneshf zenzike osfameron spacebug Nshag mechairoi HugoDaniel tristero jcsims everett catsup zz_anildigital vincom2 pieter seliopou brisbin macron Sornaensis levi jchee MK_FG julmac int-e Eliel_ stbuehler earldoug1as qrada__ FliPPeh popl Krakarn magicman Okasu dilinger pingu g0dmoney- ndeine mikeizbicki anders^^ tismith majoh Twey tekacs jlouis mietek statusfailed edk andreasrx Tesseraction Or1 xintron Rutger`)
22:02:30 --- names: list (hng Derander Ulrar splintax Raynes pm5 nitrix mathu sokoll betawaffle thomassgn defanor chirpsalot Fubar^ burp cow-orker noctux kuyatzu amiller Nivim CaveJohnson idoru noplamodo_ claudiyoh davean bstrie rs0 tomku pi8028 SaBer itb dowski staffehn meretrix Boney kakos vpm akurilin phaazon RayNbow`TU asm89 owlglass sunnavy Cheery mrkishi ephess cryon McManiaC filinep_off zalami adnap lieven_ Kabaka sviterok pfn xaimus jmct lithiumdeuteride pharaun peder)
22:02:30 --- names: list (anachron liori Draggor mrowe_away cwc bernalex sodaplayer evax_ td123 bbastian oconnore froztbyte qrada_ finnrobi empyreal bxc OrangeDu1k nulpunkt tlevine numberten XMunkki vhz_ flori R2ZER0 mjo mangaba_leitosa moop sleepynate epta alloyed yan_ brackets vladan parallel21 ivoscc DigitalKiwi wormphlegm wting go|dfish qr42 waynr _flow_ kjanosz noddy lahwran felixsch ivan` therealklanni wei2912 djapo kipras`away z0d joe_k JustAPerson sellout dju amontez_)
22:02:30 --- names: list (Iloiny jackhill Nanar monsieurp eagleflo barrucadu srhb mak` dh zymurgy sordina2 jin_jin Fuuzetsu liuw Wayneoween rieper jrp6 bitraten ParahSailin joachifm wollw kini BrianHV flux zachmassia hiredman dottedmag KitC_ iota_ AshyIsMe ChewieBe1rdy dxld_ [mth] gidogeek Jyppe neektza Lacriatch averell Dashkal sarlalian T_X jacobw xnyhps dixie petterw pdxleif zoink mephx dmead notdan stiell Hardolaf marienz jameseb sajith nicoo knyon pfoetchen ggreg comboy)
22:02:30 --- names: list (Bootvis noidi drone| adrienneleigh opqdonut Tiktalik Guest63619 jasu0 `bps ahihi dmilith kloplop321 cyphase hegge dcoutts helgikrs1 rtl Sagi Harbinger agolsme_ pqmodn sshine pyrtsa cynick Ke peddie heikkih humppa mnemon opto Ezku Gracenotes_ srbaker qtplatypus keko_ Jei mokus Adeon cross nexion Liskni_si Chousuke Bane^ cursork Tene mlen itsmonktastic joshc maurer chasecaleb dario electrogeek michaelpj kandinski Kinnison Na6hu7Ud_ mrd felipe_ somenick-)
22:02:30 --- names: list (jlewis cjay banyan tsou mgomes_ cyrusdavid knyppeldynan tomejaguar_away fabjan_ davorak_ companion_cube ChongLi Transfusion spion machrider seanparsons l3kn k00mi alcabrera|afk Clint mandu sipa ByronJohnson adimit Walther charliekilo agrif Bigcheese cin nkpart Vbitz acfoltzer george2 caasih_ elgot jnott d3lxa koala_man [swift] zq saurik feltnerm_ callumacrae Spockz clementd Th0mas marsbot danneu katis blenny PHO_ kosmikus iron_houzi `0660 TakSuyu fyolnish)
22:02:30 --- names: list (KaneTW zeiris SLi fnordbert milli petantik Preyer _1126 GaveUp uncleBlazer aupo gdsx_ demolithion natte hsc tromp__ elfangor geekosaur Cathy osnr phaer sgronblo gx^ thorstadt iulian tomaw @ChanServ cmsd2 DasIch shapr mero Laney)
22:02:38 <bb010g> :k (->) Int
22:02:39 <lambdabot> * -> *
22:02:53 <pjdelport> spopejoy: It can help to define: type Reader e a = e -> a
22:02:53 <pjdelport> or equivalently: type Reader e a = (->) e a
22:03:09 <bb010g> pjdelport: Don't bring Reader in yet
22:03:32 <spopejoy> yes please don’t. Reader exercises in the typeclassopedia melted my brain :)
22:03:33 <pjdelport> bb010g: It's a helpful tool to see the partial application :)
22:03:54 <bb010g> ((->) a) is a bit more transparent
22:04:05 <Welkin> spopejoy, those exercises were incredibly helpful -- and satisfying
22:04:17 <Welkin> especially the monad ones
22:04:24 <spopejoy> agree. i just found the (-> e) ones really hard.
22:04:28 <Welkin> oh
22:04:53 <bb010g> spopejoy: Right now we have: (f :: (a -> b -> c)) <*> (g :: (a -> b)) = undefined :: (a -> c)
22:04:53 <Welkin> I undertstood that better after reading jle` 's blog post on Autos/Category/Arrows
22:05:07 <bb010g> spopejoy: Start filling in that undefined
22:05:39 <spopejoy> h? :)
22:05:58 <bb010g> spopejoy: If you've got a function being returned, a lambda's a good place to start
22:06:22 <spopejoy> <$>?
22:06:36 <spopejoy> sorry just guessing. gimme a second.
22:07:04 <bb010g> Just try definitions. Follow the type. Don't try to go point free yet
22:09:32 <jcb_> going through rwh book and I saw a comment about operator precedence.  Is there a way to get an operation's precedence?
22:09:32 <spopejoy> hmm. a lambda that takes f,g?
22:10:08 <bb010g> spopejoy: No
22:10:48 <bb010g> spopejoy: We already have the two arguments on the LHS: (f :: (a -> b -> c)) <*> (g :: (a -> b)) = undefined :: (a -> c)
22:10:58 <bb010g> We're returning a function.
22:11:13 <bb010g> (<*>) :: (a -> b -> c) -> (a -> b) -> (a -> c)
22:12:23 <Welkin> :t (<*>)
22:12:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:12:42 <bb010g> (Dealing with the ((->) a) instance here)
22:13:00 <ezrios> jesus
22:13:16 <spopejoy> yeah is freenode bombing today?
22:13:20 <bb010g> Netsplit?
22:13:32 <ezrios> seen quite a few netsplits this week
22:13:48 <Welkin> just replace f with (->) a
22:14:09 <aarvar> he did that
22:14:17 <bb010g> Welkin: We did that, working on the implementation
22:14:32 <ezrios> ugh reader monad
22:14:35 <Welkin> haha
22:14:45 <Welkin> the reader monad is confusing, yes
22:14:48 <ezrios> I remember thinking about that for hours on the train
22:14:58 <bb010g> It's easier than you think if you follow the type
22:16:05 <spopejoy> is ‘a’ really a different type?
22:16:13 <ezrios> 'a' is a type variable
22:16:22 <bb010g> spopejoy: There's an implicit forall a. at the front; it's anything
22:16:50 <ezrios> similar to how we use 'x' to stand in for any number (1,2,3,etc.)
22:16:50 <bb010g> spopejoy: And it is a different a than the a in :t (<*>)
22:17:05 <ezrios> we use 'a' to stand in for any particular type (Int,[Char],etc.)
22:17:17 <spopejoy> but in this stylized <*>, we’re saying (a -> b -> c) <*> (a -> b) -> (a -> c)
22:17:39 <spopejoy> my confusion with this stylization is, is a of type b or c.
22:17:39 <ezrios> what
22:18:20 <ezrios> schell: not sure what you mean by stylization
22:18:31 <spopejoy> bb010g has taken me through a text substitution on the type of <*>, as an exercise
22:18:32 <bb010g> It's like how you alpha convert in lambda calc; You make ``(\x -> x)`` ``(\y -> y)`` in ``(\x -> x x) (\x -> x) = (\x -> (\y -> y) (\y -> y)) = (\x -> (\y -> y))``
22:18:39 <ezrios> if you are taking about the type of (<*>) with respect to ((->) a)
22:18:42 <ezrios> :t (<*>)
22:18:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:19:00 <ezrios> it's c -> (a -> b) -> c -> a -> c -> b
22:19:04 <bb010g> spopejoy: It's neither. Forall a. ((->) a)
22:19:06 <ezrios> really by substitution
22:19:17 <bb010g> ezrios: Or just use c. :D
22:20:10 <spopejoy> * working it out on paper here
22:20:13 <bb010g> (<*>) :: forall a. forall b c. (a -> b -> c) -> (a -> b) -> (a -> c)
22:20:31 <spopejoy> how do i get those nifty bullets in irc?
22:20:39 <bb010g> You can merge the forall a. forall b c. to forall a b c.
22:20:53 <bb010g> spopejoy: Bullets?
22:20:59 <ezrios> bb010g: uh
22:21:10 <ezrios> we are talking about the ((->) a) instance here right
22:21:10 <spopejoy> as in, “walks away slowly” or similar snarky statuses
22:21:20 <bb010g>  /me does stuff
22:21:24 * bb010g does stuff
22:21:35 * spopejoy working it out on paper atm
22:22:10 <pharaun> how long does the "update" take for cabal cos it seems to be hanging, i'm wondering if there's something funny going on
22:23:53 <Welkin> pharaun, not very long
22:24:16 <Welkin> not as long as compiling gcc from source, at least
22:24:35 <pharaun> cos it has been like 5 minute now and its not done downloading the package list
22:24:52 <Welkin> if it's just slow, then that's fine
22:25:16 <pharaun> well yeah i'm just not used to it being this slow so was wondering if there was an known issue :)
22:25:41 <Welkin> I'm trying it now on my spotty wifi
22:25:54 <Welkin> and it seems to be taking a while
22:25:58 <pharaun> yeah
22:26:52 <Welkin> perhaps it needs a progress meter
22:27:00 <Welkin> like in homebrew
22:27:15 <Welkin> oh, it finished
22:27:30 <bb010g> spopejoy: What have you got so far?
22:27:40 <pharaun> there! it finished
22:27:46 <pharaun> that was unusual slow
22:27:50 <spopejoy> bb010g: sigh. struggling.
22:28:00 <pharaun> Welkin: either you kicked something to work or i was just being impatient :)
22:28:05 <bb010g> spopejoy: What have you got for the RHS?
22:28:06 <EvanR__> what happens when your acid state runs out of memory, OOM killer?
22:28:22 <EvanR__> is there no better way to handle that
22:28:28 <spopejoy> i even cheated and looked at the source, didn’t help
22:28:37 <trap_exit> cabal install Happstack
22:28:37 <trap_exit> cabal: Codec.Compression.Zlib: premature end of compressed stream
22:28:37 <trap_exit> wtf
22:28:58 <Welkin> is there a -verbose flag?
22:29:11 <bb010g> spopejoy: Take it from the top. (f :: (a -> b -> c)) <*> (g :: (a -> b)) = undefined :: (a -> c)
22:29:41 <bb010g> Put in the lambda on the RHS to satisfy the ((->) a) part of (a -> c)
22:29:43 <Welkin> trap_exit, try again with -v
22:29:55 <glguy> trap_exit: Your  ~/.cabal/packages/hackage.haskell.org/00-index.tar.gz is likely truncated
22:30:08 <trap_exit> okay, killing the 00-index files
22:30:09 <trap_exit> running cabal update
22:30:11 <trap_exit> then I'll cabal install -v happstack
22:30:40 <Hafydd> You missed some parentheses: ((f) :: (a -> (b -> (c)))) <*> ((g) :: (a -> (b))) = ((undefined) :: (a -> (c)))
22:30:41 <trap_exit> https://gist.github.com/anonymous/8e8810257f1017514f3c
22:30:42 <trap_exit> same error
22:30:45 <trap_exit> what else should I try?
22:31:14 <bb010g> spopejoy: Now you have (f :: (a -> b -> c)) <*> (g :: (a -> b)) = \(x :: a) -> (undefined :: c)
22:31:19 <bb010g> Hafydd: :)
22:31:37 <bb010g> spopejoy: What can you use to get a c?
22:31:46 <spopejoy> f g
22:32:00 <bb010g> But as the third argument
22:32:09 <spopejoy> it looks like f . g a, but that would mean . == <*>
22:32:13 <bb010g> And you need to apply g
22:32:19 <bb010g> Let's go pointfull
22:32:38 <spopejoy> that is pointful :)
22:32:42 <spopejoy> f and g are args, no?
22:32:56 <trap_exit> https://gist.github.com/anonymous/74619f4ce59e432ad739
22:32:57 <trap_exit> what else can I provide
22:33:03 <trap_exit> to help debug "cabal install happstack" ? :-)
22:33:11 <spopejoy> i’m failing this seminar :)
22:33:17 <bb010g> spopejoy: You're taking an a in the lambda.
22:33:26 <numberten> is there a way to define a newtype where the newtype automatically derives the typeclasses of its value?
22:33:35 <bb010g> spopejoy: f requires an a first. Fill in the first part of the undefined.
22:33:39 <Welkin> trap_exit, --verbose[=3]
22:33:50 <spopejoy> the type of f a is ( b -> c )
22:33:55 <bb010g> spopejoy: (Use another undefined for the b for now)
22:34:14 <trap_exit> Welkin is -v3 not the same ?
22:34:22 <Welkin> try it and see
22:34:22 <spopejoy> the type of g a is c
22:34:23 <bb010g> spopejoy: (f :: (a -> b -> c)) <*> (g :: (a -> b)) = \(x :: a) -> (f a (undefined :: b) :: c)
22:34:40 <bb010g> ORLY? :) g :: a -> b
22:34:43 <spopejoy> f a (g a)
22:34:54 <bb010g> spopejoy: (f :: (a -> b -> c)) <*> (g :: (a -> b)) = \(x :: a) -> (f a (g a) :: c)
22:34:55 <trap_exit> Welkin: looks the same: https://gist.github.com/anonymous/d2eb9b681a063db45992
22:35:11 <spopejoy> for some reason i came to that a while ago but confused it with (.)
22:35:35 <bb010g> spopejoy: It "duplicates" the a across the arguments using another function to change type
22:36:00 <aarvar> @djinn (a -> b -> c) -> (a -> b) -> a -> c
22:36:00 <lambdabot> f a b c = a c (b c)
22:36:02 <bb010g> spopejoy: The cool part is when you pair it with (.)
22:36:31 <spopejoy> it’s pretty cool as it is :)
22:36:45 <EvanR__> numberten: newtype deriving
22:37:42 <spopejoy> so is that a morphism?
22:37:42 <bb010g> :t \f g h -> f <$> g <*> h
22:37:43 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
22:37:50 <trap_exit> VICTORY
22:37:50 <trap_exit> not quite yet
22:38:06 <bb010g> spopejoy: Yeah...all functions are morphisms in Hask (IIRC, new to category theory).
22:38:50 <spopejoy> so it’s not specifically then. i was focusing on the “type-changing” utility of <*>, but morphism is more general
22:38:56 <bb010g> Oh.
22:39:17 <bb010g> I'm not sure there, it's just a useful thing to wrap your mind around it.
22:39:17 <spopejoy> don’t worry. me no speak groups
22:39:52 <bb010g> I've been trying to hang around #haskell-lens & ##categorytheory, but they still blow my mind daily.
22:40:42 <bb010g> Although I did get through a fair bit of the Hask source without going insane, so that's progress.
22:41:07 <trap_exit> ha, I figured it out; all on my own;
22:41:08 * trap_exit doe svictory dance
22:41:10 <spopejoy> yeah edwardk was seriously schooling us all the other here on #haskell about the “shape” of lenses
22:41:17 * bb010g gives trap_exit a high five
22:41:29 <bb010g> edwardk is amazing. :)
22:41:47 <trap_exit> I should get a sticker or somethign: "I can debug my own cabal problems now."
22:42:08 <trap_exit> bb010g: why is edwardk amazing?
22:42:34 <Welkin> because he is a bastard!
22:43:05 <spopejoy> getting late here in nyc. thanks bb010g
22:43:12 <spopejoy> bb010g++
22:43:21 <Welkin> oh, he usually shows up when you mention his name
22:43:22 <bb010g> trap_exit: He knows what he's doing around all that poly-kinded category theory stuff.
22:43:32 <bb010g> spopejoy: Glad to help.
22:45:34 <spopejoy> did that ++ work??
22:46:42 <Welkin> @karma bb010g
22:46:42 <lambdabot> bb010g has a karma of 1
22:46:48 <Welkin> bb010g--
22:46:50 <Welkin> @karma bb010g
22:46:50 <lambdabot> bb010g has a karma of 0
22:46:53 <bb010g> spopejoy: lambdabot doesn't do karma here AFAIK, but it's still a nice gesture
22:46:56 <Welkin> yes
22:46:57 <bb010g> Oh
22:47:05 <spopejoy> bb010g++
22:47:10 <spopejoy> @karma bb010g
22:47:10 <lambdabot> bb010g has a karma of 1
22:47:10 <bb010g> Welkin: Hey! :D
22:47:15 <dfeuer> @help karma
22:47:15 <lambdabot> karma <polynick>. Return a person's karma value
22:47:24 <bb010g> @list karma
22:47:24 <lambdabot> karma provides: karma karma+ karma- karma-all
22:47:25 <Welkin> polynick? haha
22:47:45 <Welkin> c++
22:47:48 <dfeuer> @karma edwardk
22:47:48 <lambdabot> edwardk has a karma of 41
22:47:49 <Welkin> @karma c
22:47:49 <lambdabot> c has a karma of 2
22:48:04 <dfeuer> Welkin, that's off-topic.
22:48:06 <dfeuer> c--
22:48:22 <dfeuer> c--++
22:48:25 <dfeuer> @karma c--
22:48:25 <lambdabot> c-- has a karma of 2
22:48:38 <Welkin> c++++
22:48:39 <spopejoy> bb010g++ #since Welkin won’t
22:48:43 <Welkin> @karma c++
22:48:43 <lambdabot> c++ has a karma of 11
22:48:49 <dfeuer> Ew...
22:49:00 <spopejoy> @karma bb010g
22:49:00 <lambdabot> bb010g has a karma of 2
22:49:09 <spopejoy> my work is done here
22:49:18 <Welkin> @karma lambdabot
22:49:18 <lambdabot> lambdabot has a karma of 28
22:49:27 <Welkin> spopejoy, did you just use a python comment?
22:49:29 <Welkin> this is haskell!
22:49:38 <dfeuer> I fixed it.
22:49:40 <dfeuer> @karma c++
22:49:41 <lambdabot> c++ has a karma of -8
22:50:16 <blz37> @karma c
22:50:16 <lambdabot> c has a karma of 2
22:50:19 <spopejoy> Welkin++ --but I don’t think Haskell comments work here
22:50:26 <spopejoy> @karma Welkin
22:50:26 <lambdabot> Welkin has a karma of 3
22:50:36 <blz37> @karma clojure
22:50:36 <lambdabot> clojure has a karma of 0
22:50:37 <Welkin> haskell comments work on lambdabot
22:50:42 <blz37> @karma scala
22:50:42 <lambdabot> scala has a karma of -3
22:50:51 <Welkin> > sum [1..10] -- like this
22:50:52 <shachaf> Please experiment with lambdabot in /msg or #haskell-overflow or something.
22:50:52 <lambdabot>  55
22:51:19 <spopejoy> i think you have to use # to comment on karma commands
22:51:34 <Welkin> or #haskell-blah
22:51:52 <Welkin> it's usually overrun by benzrf though
22:52:26 <dfeuer> I think #haskell-blah may be more appropriate for heavy collaborative lambdabot experimentation, but I could be wrong.
22:52:47 <Welkin> run, lambdabot!
22:52:52 * Welkin set lambdabot free
22:53:10 <Welkin> don't let the government capture you for experimentation!
22:53:24 <Welkin> phone home, little alien!
22:59:45 <Welkin> I interpreted those hashtags in the quite message of artymis as irc channels
22:59:49 <Welkin> quit*
23:08:54 <CmdrMoozy> if i'm defining an instance Arbitrary for QuickCheck, do I have to say `arbitrary = do ...`? i'm not exactly sure why the first version of this is fine, and the second version is incorrect: http://lpaste.net/109353
23:10:30 <Welkin> desugar the do notation into bind notation
23:11:10 <pharaun> i love clarity coming back to a problem, months after you struggled with it for a long time
23:11:31 <CmdrMoozy> Welkin, ah, that's right, let me google and play with it... :)
23:12:24 <Welkin> choose yields a Gen Int
23:12:33 <Welkin> but SmallTestInt takes an Int
23:15:45 <CmdrMoozy> Welkin, ah yeah, it seems fmap is the clearest way to do it
23:15:57 <CmdrMoozy> @src fmap
23:15:57 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:16:16 <CmdrMoozy> ^ what's the trick to that?
23:16:32 <Welkin> :i fmap
23:16:38 <ezrios> @info fmap
23:16:38 <lambdabot> fmap
23:16:39 <Welkin> @info fmap
23:16:39 <lambdabot> fmap
23:16:43 <ezrios> great
23:16:45 <Welkin> haha
23:16:50 <ezrios> thanks lambdabot
23:17:04 <Welkin> :t fmap
23:17:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:17:10 <Welkin> :t (>>=)
23:17:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:17:24 <CmdrMoozy> there's some way to get lambdabot to give the definition of a built-in function -- not just the type signature
23:17:42 <Welkin> it's easier to just look at the source online
23:18:01 <CmdrMoozy> ah yeah there is indeed a nice little source button
23:18:02 <genisage> CmdrMoozy: fmap has a bunch of different definitions, which one do you want?
23:18:08 <ezrios> :t (=<<)
23:18:09 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:19:03 <CmdrMoozy> genisage, well, i'm trying to grok what `fmap SmallTestInt (choose (-5, 5))` is really doing - given `newtype SmallTestInt = SmallTestint Int`
23:19:35 <Welkin> choose (-5, 5) yields Gen Int
23:21:18 <CmdrMoozy> Welkin, i'm not totally sure what a Gen Int "is", since the QuickCheck docs just define it as "newtype Gen a"
23:21:40 <Welkin> well, if you look at the type of choose you can see it
23:21:41 <Welkin> :t choose
23:21:42 <lambdabot> Random a => (a, a) -> Gen a
23:21:50 <Yep_> Hi, I need to provide an ftp like prompt like interface on the console. Pretty basic stuff but was wondering if there was a module somebody knows that already wrapped a few of the generic "prompt" interface (e.g. utility functions to change the prompt, splitting args into array, providing help descriptions, etc)?
23:21:52 <Welkin> a is Int, in this case
23:22:16 <Iceland_jack> :t sample' (choose (-5, 5))
23:22:17 <lambdabot> (Random a, Num a) => IO [a]
23:23:06 <sgronblo> Pedantry time: Is it more correct to say that something is a Monad or that something can be defined as a Monad?
23:23:29 <dfeuer> Yep_, you might want to start with https://hackage.haskell.org/package/readline
23:23:46 <johnw> sgronblo: is, as long as you're talking about the right thing :)
23:24:08 <CmdrMoozy> is it correct to say that choose returns e.g. /a function which returns Ints/ rather than an Int itself?
23:24:35 <Welkin> well, yes, it returns a computation
23:24:39 <Iceland_jack> CmdrMoozy: ‘choose (-5, 5)’ gives you a generator for numbers between -5 and 5
23:24:42 * dfeuer hands johnw a bowl of popcorn with butter and a little salt.
23:24:42 <Welkin> like a Just 4
23:24:48 <Welkin> but instead a Gen 4
23:25:27 <Iceland_jack> Interally that generator is a wrapper around a function, but it needn't be
23:25:35 <Iceland_jack> *Internally
23:25:39 * dfeuer hopes maybe johnw will go back to explaining a bit more about effectful streams or whatever they're called.
23:27:18 <CmdrMoozy> that makes sense
23:27:50 <Yep_> dfeuer: Readline looks great, I was hoping not to add an extra dependency though
23:28:05 <Yep_> windows support etc
23:28:06 <Iceland_jack>     Gen a
23:28:06 <Iceland_jack> is (representationally) equal to
23:28:06 <Iceland_jack>     StdGen -> Int -> a
23:28:21 <CmdrMoozy> Welkin, Iceland_jack, thanks :)
23:28:35 <Welkin> actually it looks like MkGen
23:28:44 <Welkin> not Gen (that is the type constructor)
23:29:14 <Welkin> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Gen.html#Gen
23:29:50 <Yep_> dfeuer: oh great, just found http://hackage.haskell.org/package/haskeline
23:30:44 <Yep_> dfeuer: thanks for the lead
23:31:07 <Welkin> dfeuer, effectful streams?
23:31:14 <Welkin> you mean like arrows?
23:31:21 <Welkin> or Auto?
23:31:37 <johnw> dfeuer: hi
23:31:41 <johnw> effectful streams is a great name
23:31:59 <johnw> like conduit
23:32:04 <johnw> pipes, io-streams, simple-conduit, enumerator, iteratees, etc., etc.
23:33:02 <dfeuer> Hi, johnw.
23:33:26 <dfeuer> Yes, that's the name johnw used the last time we started to speak about the matter.
23:53:41 <solatis> hello
23:53:46 <solatis> i need someone to hold my hand
23:53:47 <solatis> http://lpaste.net/109354
23:54:10 <makalu> is there a straightforward way to detect overflow when converting from Double to Float (I've been using GHC.Float.double2Float)? I could use minBound, maxBound with integral types but not with floats.
23:54:16 <solatis> "of course" this generates the error "Couldn't match expected type ?ZMQ z b0? with actual type ?Bool?"
23:54:41 <solatis> the offending line is the last one
23:55:09 <solatis> i think you guys can understand what i'm trying to do, but can anyone point me in the right direction on what to google for ?
23:55:48 <frerich> solatis: What is the type of 'unpack  receive receiver'?
23:56:00 <solatis> it's a strng
23:56:10 <solatis> as in, `message` is a string
23:56:14 <adas> solatis: you should include the error you're getting as well
23:56:28 <solatis> ok hold on, i will post a better pastie
23:57:10 <corgifex> what is this supposed to do?
23:58:12 <frerich> solatis: The thing is that the second argument to forM_ is supposed to be of type 'a -> m b', i.e. it should return a monadic value.
23:58:23 <Pythonfant> maybe you want return $ validator message
23:58:28 <frerich> solatis: However, your code ends with 'validator emssage', which returns a plain Bool
23:58:30 <corgifex> Pythonfant: no
23:58:34 <solatis> yeah
23:58:49 <solatis> frerich: and i don't do anything with the bool
23:59:05 <Pythonfant> corgifex: why not?
23:59:08 <solatis> so the logical conclusion ghc makes is to return the bool, since it's the last statement of a do block
23:59:15 <frerich> solatis: Given that you use forM_, i.e. you discard the return values, you could try 'return (validatormessage)' or 'return ()' at the end.
23:59:21 <corgifex> Pythonfant: because 'return anything' doesn't make sense in forM_
23:59:28 <corgifex> because forM_ ignores the return value
23:59:33 <Pythonfant> corgifex: ah right, sorry
23:59:38 <solatis> this was the explanation i was looking for
23:59:43 <solatis> thanks
23:59:57 <Welkin> Pythonfant, sycophant?
