00:00:05 <dfeuer> What's the best Haskell IDE?
00:00:24 <dfeuer> I'm tired of chasing down where things are defined by hand.
00:01:01 <dfeuer> [It's rather tough when modules get imported wholesale]
00:01:22 <cow_2001> dfeuer: vim / emacs, maybe
00:02:15 <cow_2001> dfeuer: i agree with the wholesale bit. it's two times annoying when it's done in documentation :D
00:04:17 <cow_2001> dfeuer: i don't know where you stand with regard to the various editors, but those two editors have vibrant ecosystem of users and plugin developers
00:04:44 <cow_2001> http://www.haskell.org/haskellwiki/Vim and http://www.haskell.org/haskellwiki/Emacs
00:05:20 <dfeuer> Thanks, cow_2001.
00:05:21 <cow_2001> dfeuer: did you read this page? http://www.haskell.org/haskellwiki/IDE
00:05:34 <dfeuer> I'm not sufficiently comfortable with either of them, really. I use vim, but badly.
00:07:00 <cow_2001> the vim channel has some nice folks who are happy to help
00:10:39 <gessha> hello, can anyone help with this code http://lpaste.net/109543
00:10:53 <gessha> this is from learn you haskell
00:11:26 <gessha> How can I catch any wrong command imput?
00:12:05 <c_wraith> gessha: you can't do it from inside that table.  You'll need to move it outside the table.
00:12:38 <Cale> another problem is that PutStrLn should be putStrLn
00:12:45 <c_wraith> gessha: like, when you want to use the table, you'll do something like "lookup command dispatch" to get the action out of the table.
00:12:59 <c_wraith> gessha: but lookup returns a Maybe value
00:13:16 <c_wraith> gessha: and you would use the catchall in the case where it returns Nothing
00:13:18 <funfunctor> hi
00:13:29 <Cale> The pattern [x:xs] will only match a list with a single element which is a nonempty list.
00:14:22 <funfunctor> anyone know what the deal is with linking to llvm-general ? I get messages like this: libHSCrabLab-0.1.0.0.a(Mrepl.o):(.text+0x1b1): undefined reference to `CrabLabzm0zi1zi0zi0_CrabLabziCodegenziEmit_codegen1_info'
00:14:33 <ion> > case [1:2:3] of [x:xs] -> (x, xs)
00:14:36 <lambdabot>  No instance for (GHC.Show.Show t0)
00:14:36 <lambdabot>    arising from a use of ‘M734801817551657406420342.show_M7348018175516574064...
00:14:36 <lambdabot>  The type variable ‘t0’ is ambiguous
00:14:36 <lambdabot>  Note: there are several potential instances:
00:14:36 <lambdabot>    instance [safe] GHC.Show.Show
00:14:44 <ion> > case [1:2:[3]] of [x:xs] -> (x, xs)  -- doh
00:14:46 <lambdabot>  (1,[2,3])
00:15:08 <funfunctor> I think I need to tweak something in my cabal config because I know the llvm bindings has issue with ghci in a similar way??
00:15:13 <gessha> c_wraith: Thanks. So can I say
00:15:23 <ion> I’m not sure it’s beneficial for lambdabot to dump five lines of errors here.
00:15:43 <gessha> let (Nothing) = putStrLn "Error message"
00:15:51 <shachaf> It is anti-beneficial.
00:16:45 <dfeuer> Hello, Cale.No, you can't say that, gessha.
00:16:54 <c_wraith> gessha: that syntax isn't quite right. I'm going to sleep right now, but Cale was also making suggestions for you.  I'm pretty sure he'll help you out.
00:17:32 <Cale> gessha: That's a type error, because Nothing :: Maybe t, while putStrLn "Error message" :: IO ()
00:17:57 <Cale> So, there's no way that putStrLn "Error message" could ever be equal to Nothing
00:18:18 <Cale> and you're not even allowed to write that pattern binding
00:18:29 <gessha> aha
00:18:38 <Cale> (Also, pattern matching against patterns which don't bind variables is usually pointless)
00:18:51 <Cale> Well, in that way
00:18:58 <dfeuer> Yes, in that way.
00:19:03 <Cale> It's useful in function bindings and case expressions of course :)
00:20:09 <gessha> Then how can I catch if the user has input wrong arguments
00:20:37 <Cale> Well, I haven't seen the rest of your code
00:20:41 <Fuuzetsu> @pl f x = x `on` foo $ bar
00:20:41 <lambdabot> f = flip (`on` foo) bar
00:20:49 <gessha> sorry just a sec
00:20:56 <Cale> But presumably, you read the input using getLine or something, and then do something with the result of that
00:22:13 <gessha> import System.Environment import System.Directory import System.IO import Data.List import Data.Char  dispatch :: [(String, [String] -> IO())] dispatch =  [ ("add", add) 			, ("view", view) 			, ("remove", remove) 			, ("bump", bump) 			, ( String , error') 			]  main = do 	( command:args ) <- getArgs 	let (Just action) = lookup command dispatch 		(Nothing) = putStrLn "Error" 	action args 	 add :: [String] -> IO () add [fileName, todo
00:22:18 <gessha> damn
00:22:24 <gessha> http://lpaste.net/109544
00:25:10 <kvelicka> why would haskell expect a different type than it actually is in a let binding?
00:27:18 <lieven_> kvelicka: because you're using it later in an incompatible way? can you show us the code?
00:27:20 <merijn> kvelicka: You made a type error? :)
00:28:16 <dfeuer> Cale, do you think you could help me with this quick question? http://lpaste.net/109542
00:28:44 <kvelicka> well that's what I'm leaning towards, but
00:28:45 <kvelicka> http://lpaste.net/2725616478316396544
00:28:52 <kvelicka> how come?
00:28:53 <Cale> dfeuer: Sure, just let me answer gessha here
00:29:00 <dfeuer> Hurray!
00:29:08 <Cale> gessha: So, instead of  let (Just action) = lookup ...
00:29:46 <Cale> gessha: you want   case lookup ... of Just action -> action args; Nothing -> putStrLn "Error!"
00:30:18 <Cale> dfeuer: okay, what's your question?
00:30:27 <Cale> oh, I see
00:30:30 <Cale> comments :)
00:30:38 <dfeuer> :D
00:31:06 <funfunctor> actually how do you debug the linkage step in a cabal build process?
00:31:08 <gessha> Cale: Thanks Cale
00:31:52 <Cale> dfeuer: My first impression is "if you have to ask, then probably just use the one you know works"
00:32:08 <dfeuer> Cale, the one above isn't my code.
00:32:26 <dfeuer> I'm trying to understand it, and also to get a better sense of scans.
00:32:32 <dfeuer> At the same time.
00:32:45 <kvelicka> lieven_: merjin: http://lpaste.net/2725616478316396544 what am I missing?
00:35:51 <ion> You’re defining events as a non-function but using it as a function.
00:35:53 <Cale> dfeuer: It's pretty similar at least... If cseBind pattern matches its second parameter though... you might have a bad time with passing undefined
00:36:08 <dfeuer> cale, cow_2001 pointed out an error.
00:36:18 <ion> The “works” code probably gives a warning about shadowing.
00:36:19 <dfeuer> Which is easily corrected, I think.
00:36:29 <cow_2001> i'm not sure
00:36:38 <dfeuer> I'm sure you're right, cow_2001.
00:36:53 <cow_2001> tell me how you've fixed it
00:37:29 <Cale> @src mapAccumL
00:37:29 <lambdabot> mapAccumL _ s []     = (s, [])
00:37:29 <lambdabot> mapAccumL f s (x:xs) = (s'',y:ys)
00:37:29 <lambdabot>    where (s', y ) = f s x
00:37:29 <lambdabot>          (s'',ys) = mapAccumL f s' xs
00:38:23 <dfeuer> But I think I just fixed it, cow_2001: http://lpaste.net/109542
00:38:23 <kvelicka> ion: could you point where that might be happening? I pasted in one changed and one not-yet-changed instance http://lpaste.net/7094859693192904704 thanks!
00:39:26 <cow_2001> O_O
00:39:46 <Cale> kvelicka: btw, you don't need to repeat 'let' over and over, you can put multiple bindings into one let
00:40:00 <ion> “events = sortEvents . events $ dat eventLog” defines events as a non-function but uses it as a function in the definition.
00:40:25 <kvelicka> Cale: good point, thanks!
00:40:29 <Cale> Yeah, that's a recursive definition of events
00:40:41 <ion> “let eventlist = events datapart; let events = sortEvents eventlist” seems to shadow another definition of events, you should get a warning about that. (Remember to use -Wall)
00:40:47 <kvelicka> ion: wow. someone's got the case of the mondays.. thanks!
00:40:51 <dfeuer> Cale, I don't think undefined gives a problem here, because it's never inspected, but the uninspected stuff does kind of make me wonder if there's a cleaner approach.
00:40:57 <merijn> hmmm
00:41:09 <merijn> socket operations don't throw an exception after a socket disconnects?
00:41:10 <Cale> ah, yeah, merging these lets is going to create a problem for you, because you're reusing names
00:41:15 <merijn> That's annoying...
00:41:48 <Cale> You probably don't want to use 'events' as a name here, because your definition will shadow the function which is in scope
00:42:00 <kvelicka> I'll sort it out, I just somehow managed to miss the fact that I accidentally changed names in a way that makes them shadow each other
00:42:20 <ion> -Wall is your friend
00:42:29 <kvelicka> the field used to be called capEvents and I just changed it witout enaging the brain
00:42:36 <kvelicka> ion: point taken :)
00:44:07 <merijn> I guess there's no way to import multiple modules on one line in ghci?
00:44:14 <shachaf> merijn: :m + A B C
00:44:16 <ion> import Foo; import Bar  ;-)
00:44:19 <shachaf> But no way to import qualified etc.
00:44:22 <ion> Sorry, missed the “i” in “ghci”
00:44:23 <shachaf> ion: Doesn't work.
00:48:41 <merijn> ah, yeah :m is good enough
00:49:14 <merijn> I'll debug the rest tomorrow :)
00:50:30 <Cale> dfeuer: try mapAccumL
00:54:42 <dfeuer> Cale, I think you're absolutely right.
00:57:14 <dfeuer> Cale, and that'll have to be added to my list of functions that should fuse but don't :P
01:02:03 <kvelicka> Is there a standard abbreviation for the word deprecation (as in for commit messages and whatnot)?
01:04:05 <ilk> does anyone know where i can hotlink a file without signing up for an account?
01:05:28 <zorg24> ilk hmm I just use dropbox for that
01:05:48 <ilk> k ill try that thanks
01:08:09 <zorg24> ilk: if you don't alreadt use dropbox its kind of silly to install for that, but if you do just right click a file and choose "Share Dropbox Link"
01:08:40 <zorg24> and lastly if its code use lpaste
01:37:13 * hackagebot warp 3.0.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.1 (MichaelSnoyman)
01:41:45 <xificurC> anyone using Yi to do their daily dose of haskell coding?
01:42:13 * hackagebot idempotent 0.1.2 - Idempotent monoids  http://hackage.haskell.org/package/idempotent-0.1.2 (alynn)
01:47:35 <zorg24> xificurC: I personally use sublime when writing Haskell
01:49:27 <xificurC> I use emacs with vim bindings. I just thought if it is recommended by the community I'd give it a spin
02:06:43 <benzrf> vim ftw
02:07:01 <benzrf> sublime is for people who are afraid of learning new keybinds
02:13:08 <shanse> that's a rather stupid statement to make
02:15:30 <dottedmag> benzrf: I miss the time when it was possible to do most of text manipulation was possible in a single application.
02:15:50 <dottedmag> Browsers and shells are not cooperative, but at least they have Emacs-like keybindings most of the time.
02:16:43 <dottedmag> Also, "afraid of learning new keybinds"? Really? With Cmd-P meaning "Goto" instead of "Print" as everywhere else?
02:17:17 * hackagebot debian-build 0.2.1.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.2.1.0 (KeiHibino)
02:17:38 <eikke__> is there any typeclass for scalar multiplication?
02:20:45 <benzrf> bye
02:21:13 <prophile> eikke__: there's the Additive typeclass from linear
02:21:39 <prophile> which gives you (^*) and (*^) for scalar products
02:23:55 <solidus-river> netwire is driving me utterly insane tonight
02:24:07 <eikke__> prophile: hmh, thanks. might be what I'm looking for, but is a bit too much of a dep for my purposes :)
02:24:08 <solidus-river> there seems to be absolutely no way to get a very simple core behavior for gaming out of it
02:24:20 <solidus-river> and i've been wrestling against this for almost 2 weeks straight now
02:25:01 <solidus-river> i want to produce a value one time when an event happens and then inhibit
02:25:10 <solidus-river> so i want to produce a single value when an event occurs and then inhibit
02:25:17 <solidus-river> and then i want to delay
02:29:29 <solidus-river> i dont think i understand untill
02:31:30 <sopvop> #haskell, which smtp package would you recommend?
02:31:39 <sopvop> client
02:31:52 <prophile> Thunderbird
02:32:16 <sopvop> prophile: I doubt cabal install Thuderbird will work :)
02:32:37 <prophile> true, but then in my experience cabal install <anything> usually doesn't work
02:34:05 <sopvop> prophile: in my experience probability of cabal install not working correlates with packages being part of yesod ecosystem...
02:36:49 <angerman> how do i parse a quoted string with escaped quotes using attoparsec? e.g. "foo\"bar"?
02:37:18 * hackagebot simple-pipe 0.0.0.13 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.13 (YoshikuniJujo)
02:38:00 <sopvop> angerman: you may wish to use parsers library, it has instances for attoparsec http://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Token.html
02:38:55 <sopvop> angerman: or check source for implementation ideas
02:41:36 <sopvop> angerman: something like ` (char '\\' *>  (char '"' <|> pure '\\')) '
02:42:04 <angerman> sopvop, thanks! That's wonderful!
02:49:06 <paraze> Hi :)
02:49:17 <paraze> http://paste.awesom.eu/NYXa -> why `replicate' 0 5` doesn't print [5,5,5] ?
02:50:02 <shachaf> What does it do?
02:50:43 <solidus-river> jle`: you wouldn't happen to be around would you? who is it in #haskell-game who made netwire, i believe i have a bone to pick with them :)
02:50:45 <paraze> []
02:51:03 <solidus-river> jle`: or i seriously misunderstand their library in a core way, which is more likely
02:51:34 <shachaf> paraze: That don't seem right.
02:51:46 <sopvop> > let replicate' n x | n == 0 = [x, x, x] | otherwise = x : replicate' (n-1) x
02:51:47 <lambdabot>  not an expression: ‘let replicate' n x | n == 0 = [x, x, x] | otherwise = x ...
02:51:55 <frerich> solidus-river : The IRC nick of the netwire author is 'mm_freak'.
02:51:58 <shachaf> paraze: Can you show the full ghci session you're using here?
02:52:08 <sopvop> > let replicate' n x | n == 0 = [x, x, x] | otherwise = x : replicate' (n-1) x in replicate 0 5
02:52:10 <lambdabot>  []
02:52:28 <Saizan> > let replicate' n x | n == 0 = [x, x, x] | otherwise = x : replicate' (n-1) x in replicate' 0 5
02:52:34 <lambdabot>  [5,5,5]
02:52:42 <sopvop> oh, that's wrong replicate :)
02:52:50 <solidus-river> frerich: thanks :) hmm, he's not around, i'm having trouble giving up on this and sleeping
02:53:04 <sopvop> paraze: you forgot ' in replicate'
02:54:05 <paraze> Oh, thanks ^^'
03:03:34 <filillo> ciao
03:03:36 <filillo> !list
03:03:36 <monochrom> filillo: http://okmij.org/ftp
03:16:30 <trap_exit> anyone here in berkeley?
03:16:34 <trap_exit> I want to find a berkeley haskell user group
03:20:32 <bernalex> what's a nicer way to achieve this: http://lpaste.net/2805054002989891584 ?
03:21:55 <bernalex> here it is without formatting if you hate links ;-)   (foo, bar) = case (maybeFoo, maybeBar) of (Nothing, Nothing) -> ((), ()); (Just a, Just b) -> (a, b); (Just a, Nothing) -> (a, a); (Nothing, Just b) -> (b, b)
03:22:11 <Hafydd> bernalex: based on the types you have there, (beginMin, beginMax) = ((), ()).
03:22:32 <bernalex> Hafydd: wat
03:23:01 <bennofs> bernalex: how many values of type () are there?
03:23:17 <bernalex> oh those were placeholders
03:23:59 <Hafydd> bernalex: in your last branch, a is undefined.
03:24:06 <Hafydd> I suggest maybe writing an example that compiles properly!
03:24:09 <bennofs> Hafydd: it's supposed to be a b
03:24:13 <bernalex> oops it should be "b, b')
03:24:40 <bernalex> updated the paste
03:25:03 <bernalex> (Nothing, Just b) -> (b, b)
03:25:21 <bennofs> (fromMaybe (fromMaybe () maybeBeginMax) maybeBeginMin, fromMaybe (fromMaybe () maybeBeginMin) maybeBeginMin)
03:25:35 <bernalex> right, so if there's only an 'a', set both of them to that. if there's a 'b', set both to b. if there's neither, do some error thing, if both are there, fromJust them.
03:25:39 <bennofs> not that nice through
03:25:45 <bernalex> bennofs: yeah the case is nicer than that
03:26:02 <bernalex> I just assumed this was sort of common
03:27:51 <bennofs> just another idea (maybe there is a way to simplify it to make it nice): fromMaybe ((), ()) $ (,) <$> (maybeBeginMin <|> maybeBeginMax) <*> (maybeBeginMax <|> maybeBeginMin)
03:28:51 <bernalex> I might just end up using the case because it's so easy to read. it will be refactored away into some function anyway.
03:31:09 <Hafydd> beginMin : beginMax : _ = catMaybes [maybeBeginMin, maybeBeginMin, maybeBeginMax, maybeBeginMax, Just someThing]
03:31:24 <Hafydd> Oh, wait...
03:32:08 <Hafydd> beginMin : beginMax : _ = catMaybes [maybeBeginMin, maybeBeginMax, maybeBeginMin, maybeBeginMax, Just someThing]
03:34:42 <Hafydd> or: beginMin : beginMax : _ = catMaybes $ replicate 2 [maybeBeginMin, maybeBeginMax] ++ [Just someThing]
03:34:50 <Hafydd> Or just:
03:34:51 <Hafydd> beginMin = maybeBeginMin <|> maybeBeginMax <|> Just someThing
03:34:56 <Hafydd> beginMax = maybeBehinMax <|> maybeBeginMin <|> Just someThing
03:35:22 <bennofs> Hafydd: instead of <|> Just someThing, you need to use fromMaybe something
03:35:32 <bennofs> Hafydd: otherwise, beginMin :: Maybe _
03:35:32 <bernalex> Hafydd: the latter was my original idea
03:35:41 <Hafydd> I think my version is more readable!
03:36:05 <Hafydd> ...oh, I see what you mean.
03:36:25 <bernalex> but it doesn't work very well
03:44:48 <yesthisisuser> A more polite way to say (\x -> return . f x) ?
03:45:09 <hpc> fmap f
03:45:18 <hpc> er
03:45:30 <yesthisisuser> Is it? .. no
03:45:39 <hpc> :t (\x -> return . f x)
03:45:41 <lambdabot> (FromExpr b, Show t, Show a, Monad m) => t -> a -> m b
03:45:50 <hpc> :t (\f x -> return . f x)
03:45:51 <lambdabot> Monad m => (t -> a -> b) -> t -> a -> m b
03:46:30 <hpc> that's annoying
03:47:56 <yesthisisuser> (.) return . f
03:48:10 <hpc> :t return .: f
03:48:11 <lambdabot>     Not in scope: ‘.:’
03:48:11 <lambdabot>     Perhaps you meant one of these:
03:48:11 <lambdabot>       ‘.’ (imported from Data.Function),
03:48:20 <hpc> bah
03:48:33 <hpc> i think if you do (.:) = fmap fmap fmap, that will work
03:48:44 <furrykef> http://lpaste.net/109548 -- what am I doing wrong here? It gives me a compile error, namely "Could not deduce (a ~ Int) from the context (Integral a)"
03:49:49 <barrucadu> furrykef: (!!) takes the index as an Int
03:49:52 <barrucadu> @type (!!)
03:49:53 <lambdabot> [a] -> Int -> a
03:50:16 <yesthisisuser> hpc: indeed it does. I had forgot about good old (.:)
03:52:22 <furrykef> yeah, I thought that might be it
03:52:30 <furrykef> | otherwise = seq ++ [seq !! fromIntegral (n - 1) + seq !! fromIntegral (n - 2)]
03:52:35 <furrykef> This works, but is there a better way?
03:53:39 <barrucadu> A better way would be to not use (!!) at all, the haskell wiki has some example implementations: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
03:53:47 <danilo2> Hello! Is it possible to get the current parsing position (line/column) using the edwardk_ 's parsers library (with trifecta backend) ?
03:57:13 <haasn> danilo2: http://hackage.haskell.org/package/trifecta-1.5.1/docs/Text-Trifecta-Combinators.html
03:57:22 <haasn> position :: Parser Delta
04:00:23 <Cale> furrykef: It's a good thing there is: that program will spend an amount of time quadratic in n just evaluating (++)'s alone
04:00:42 <Cale> furrykef: xs ++ ys takes O(length xs) steps to reduce
04:00:57 <Cale> furrykef: so adding to the end of a list recursively like that is terrible
04:01:14 <prinsen> Is it possible to have a data type be parameterized by a value?
04:01:15 <Cale> moreover, xs !! n takes O(n) steps
04:01:24 <Cale> prinsen: In languages that are not Haskell, yes
04:01:49 <prinsen> Cale: ..., and in Haskell?
04:02:05 <furrykef> Cale -- I didn't expect it to be a good implementation
04:02:08 <Cale> prinsen: You might like the promoted data types stuff in GHC though. You can lift types to the kind level, and their values to the type level. But it's not totally automatic.
04:02:11 <furrykef> This is a "getting my feet wet" implementation
04:02:20 <Cale> furrykef: Yeah
04:02:29 <furrykef> I started learning Haskell just last night
04:02:47 <Cale> furrykef: Yep, it's fine, I'm just letting you know why to avoid these things :)
04:03:41 <Cale> furrykef: So, one thing you might do is instead of trying to construct a finite list, define the whole list of fibonacci numbers at once.
04:03:46 <furrykef> So I looked at that page and I saw this: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:03:53 <furrykef> I think it's gonna be a long time before things like that come naturally to me
04:04:04 <Cale> Well, we can get there in a couple of steps
04:04:10 <Cale> Let's start with...
04:05:15 <Cale> fibs = 0 : 1 : [fibs !! n + fibs !! (n+1) | n <- [0..]]
04:06:01 <Cale> does it make sense why that works?
04:06:57 <furrykef> uhh, gimme a min to mentally process it. I'm a little sleepy.
04:07:17 <danilo2> haasn: I was asking about parsers api - I know I can use trifecta API but then it is not movable over other backends
04:07:17 <furrykef> yeah, I get it.
04:07:26 <Cale> furrykef: Okay, great :)
04:07:33 * hackagebot hayoo-cli 0.1.0.3 - Hayoo CLI  http://hackage.haskell.org/package/hayoo-cli-0.1.0.3 (Gonzih)
04:07:45 <Cale> furrykef: So the next thing we can do is to split that list comprehension up:
04:08:10 <Cale> fibs = 0 : 1 : zipWith (+) [fibs !! n | n <- [0..]] [fibs !! (n+1) | n <- [0..]]
04:08:24 <Cale> which at first makes things more complicated
04:08:34 <Cale> but [fibs !! n | n <- [0..]] is the same thing as fibs
04:08:45 <Cale> and [fibs !! (n+1) | n <- [0..]] is the same thing as tail fibs
04:10:37 <Cale> Do you see what I did there? If we have a list comprehension like  [a + b | stuff], this is the same as zipWith (+) [a | stuff] [b | stuff]
04:13:00 <furrykef> OK, well, before we proceed any further I still want an answer to my original question -- flawed as my implementation may be, how can I make seq !! (n-1) work without having to use fromIntegral?
04:13:00 <Cale> furrykef: let me know if that's clear or if you have questions about it :)
04:13:08 <Cale> ah
04:13:22 <furrykef> 'Cause of course the issue there is bound to come up again in some other context
04:13:26 <Cale> !! is sort of flawed in requiring an Int
04:13:54 <Cale> :t genericIndex
04:13:56 <lambdabot> Integral i => [a] -> i -> a
04:13:59 <Cale> There's that
04:14:26 <Cale> which will at least be correct for large values when the i type is Integer
04:14:34 <Cale> (but it will take a long time)
04:15:33 <furrykef> er, so what I would do is...?
04:15:44 <Cale> genericIndex seq (n-1)
04:16:01 <Cale> Or you can just  seq !! fromIntegral (n-1)
04:16:13 <Cale> Or just take n to be an Int
04:16:38 <Cale> fibonacci' :: (Integral a) => Int -> [a]
04:17:43 <wz1000> This is weird. I have a program that runs perfectly when I directly invoke it from bash, but fails to output anything when I pipe it to something else. Can this be a haskell problem?
04:18:19 <hpc> unlikely
04:18:23 <hpc> what's the program?
04:18:46 <furrykef> Cale -- thanks
04:18:52 <Cale> It might be a problem with the Haskell program, but it's unlikely to be a Haskell problem :)
04:19:23 <hpc> @faq can haskell break unix pipes?
04:19:23 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:19:27 <hpc> aw
04:20:23 <wz1000> http://lpaste.net/1088883950245380096
04:20:39 <wz1000> I pipe it to bar for eye candy
04:21:05 <hpc> the output has colors?
04:21:11 <wz1000> But now, even if I pipe it to cat, it doesn't work
04:21:15 <wz1000> No
04:22:12 <hpc> "doesn't work" meaning no output, it hangs, or?
04:22:34 <wz1000> Adding the call to net.sh broke it I think
04:22:42 <wz1000> There is no output
04:23:27 <Cale> Does it terminate?
04:23:53 <hexagoxel> well you would not be able to say "no output" if it did not terminate yet :D
04:24:28 <funfunctor> simple question: how can I take, f :: String -> Something (Maybe Other)  to just f :: String -> Something ()
04:24:47 <hpc> it depends on what Something is
04:24:55 <sipa> that depends on how to turn a Something (Maybe Other) into a Something ()
04:24:55 <funfunctor> its probably a misinformed question but entertain me for a sec
04:25:07 <Cale> funfunctor: is 'Something' an instance of Functor?
04:25:12 <wz1000> Cale: no
04:25:38 <Cale> wz1000: Maybe add some putStrLn's before and after the runInteractiveProcess
04:25:39 <funfunctor> ok well I have replEvalExpr :: String -> REPL (Maybe AST.Module)
04:26:04 <hpc> wz1000: there's an awful lot of IO in that paste that has the potential to break things; i think you should systematically replace parts of the code with placeholders and see what you have to remove to make it work
04:26:05 <funfunctor> Cale: yes, hope so, let me check
04:26:28 <Cale> funfunctor: fmap (const ()) . replEvalExpr :: String -> REPL ()  if so.
04:26:41 <wz1000> Replacing net.sh with a script that prints "a" endlessly makes it work.
04:26:51 <wz1000> I think it is a timing issue
04:27:08 <wz1000> net.sh takes some time to run
04:27:10 <Cale> wz1000: It could be an issue with the input handle to that process getting closed
04:28:06 <wz1000> Cale: Why would it only appear when piping to another program?
04:28:07 <funfunctor> Cale: aah thanks
04:29:44 <Cale> wz1000: I'm not sure
04:30:41 <wz1000> I added a putStrLn before creating the handle to net.sh, which failed to print
04:31:08 <funfunctor> Cale: works perfect thank you!
04:34:35 <funfunctor> is the IO () monad a instance of functor?
04:34:50 <prophile> IO () has the wrong kind to be a functor instance
04:34:56 <prophile> but IO has a functor instance
04:35:00 <hexagoxel> :t (()<$)
04:35:02 <lambdabot> Functor f => f b -> f ()
04:35:24 <wz1000> Any ideas?
04:35:39 <funfunctor> prophile: can you explain a little more please?
04:35:58 <funfunctor> prophile: is that some way of saying "we lie about the maths"
04:36:09 <prophile> functors have a kind * -> *, they're things that take a type and give you a type
04:36:16 <prophile> like Maybe
04:36:17 <haasn> There is no such thing as an IO () monad
04:36:23 <prophile> or IO
04:36:37 <prophile> IO takes a type and gives you a type, like if you give it () you'll get the type IO ()
04:36:47 <prophile> () has kind *, IO () has kind *, and IO has kind * -> *
04:36:54 <prophile> functors all have kind * -> *, like IO
04:36:58 <bernalex> prophile: () is a type, like String or Int
04:37:07 <prophile> but IO () is "concrete" so to speak, it has kind *
04:37:09 <prophile> so it can't be a functor
04:37:15 <prophile> barrucadu: indeed
04:37:16 <bernalex> prophile: IO String, IO Int, IO (). so IO () can't be a Functor any more than IO String can.
04:37:23 <bernalex> oh that was for funfunctor
04:37:24 <prophile> bernalex: exactly
04:37:33 <prophile> barrucadu: sorry, tab-completion
04:38:04 <funfunctor> I get lost a little in the syntax sugar but I think I get you
04:38:43 <bernalex> funfunctor: so -- String, Int, () -- these things have kind *. they can't be functors. you need things that are kind *->*. i.e. things that take a type. like Maybe, IO and []. these can all be functors.
04:39:16 <hask54> What is the recommended way of installing Haskell on an Ubuntu Linux server machine? (for running Haskell web apps)
04:39:17 <hask54> Using "apt-get install", or downloading/installing Haskell from haskell.org ?
04:39:26 <bernalex> Maybe is not a type by itself. you can't have a function f :: Maybe -> IO -> []. you need to give them a type so they can become concrete. f :: Maybe Int -> [String] for instance.
04:43:30 <Heather> hi
04:43:34 <funfunctor> bernalex: I was trying to do:
04:43:35 <funfunctor> process :: AST.Module -> String -> IO ()
04:43:35 <funfunctor> process = fmap (const ()) . process'
04:43:35 <funfunctor> process' :: AST.Module -> String -> IO (Maybe AST.Module)
04:43:41 <bernalex> Heather: hallo
04:44:33 <funfunctor> I don't really want AST.Module winding up actually in the REPL so I am trying to push to back down
04:44:55 <Heather> bernalex: I've got strange error: Couldn't match type `b0' with `r'
04:45:09 <funfunctor> problem is complexity is starting to bite my ass xD
04:45:34 <bernalex> Heather: think we need more to go on than that. post the offending line & full error, please. preferably with context to https://lpaste.net
04:46:23 <funfunctor> :t liftIO
04:46:25 <lambdabot> MonadIO m => IO a -> m a
04:47:37 * hackagebot TypingTester 0.1.0.2 - Command Line Typing speed tester  http://hackage.haskell.org/package/TypingTester-0.1.0.2 (AlanHawkins)
04:47:40 <Heather> bernalex: here: https://gist.github.com/Heather/499e8ace722b24f54b80
04:48:30 <wz1000> Cale:  http://i.imgur.com/psPa9dX.jpg Here is what I'm doing. See anything obviously wrong?
04:48:39 <Heather> bernalex: as far as I understand r is from (forall r. Request state r -> IO r) 	-- requests          but what is b0?
04:49:54 <xpika> Does anyone know the policy for cabal versions. a.b.c.d ?
04:50:00 <bernalex> Heather: there are no imports so I don't know what any of these things actually are
04:50:33 <xpika> the last one is only for bug fixes?
04:50:48 <bernalex> Heather: I'm not sure b0 is significant beyond "this is not type `r`, which is what I expect"
04:51:00 <Heather> bernalex: it's io-reactive package on hackage
04:51:12 <xpika> d == minor bug fixes, c == major bug fixes, b = improvement, a = major version?
04:51:14 <bernalex> Heather: but the error message is for a different line than your paste, so I have no way of actually checking anything here.
04:51:18 <Heather> bernalex: https://github.com/andygill/io-reactive/blob/master/Control/Concurrent/Reactive.hs
04:51:18 <bernalex> xpika: that's up to you
04:51:40 <bernalex> xpika: what we use at plaimi is x.y.z where x means major release, y means new functionality and z means bugfixes
04:52:04 <xpika> bernalex: ok thanks
04:52:07 <Heather> bernalex: error line is here: https://github.com/andygill/io-reactive/blob/master/Control/Concurrent/Reactive.hs#L89
04:52:13 <xpika> bernalex: looks pretty standard
04:52:24 <Heather> bernalex: but it's more related whole function I think
04:52:36 <bernalex> xpika: so z bumps are always backwards compatible is a rule
04:52:44 <bernalex> xpika: (internally at my company)
04:52:52 <bennofs> ?pvp
04:52:52 <lambdabot> Maybe you meant: v pl
04:52:58 <bennofs> @where pvp
04:52:59 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
04:53:02 <funfunctor> You know every day I use Haskell it feels like I am constantly learning to program for the first time
04:53:04 <haasn> Heather: Are you sure the type signature for reactiveObjectIO is right?
04:53:20 <bennofs> xpika: the link has a few guidelines
04:53:27 <funfunctor> does anyone else feel like this or am I just a bit stupid?
04:53:29 <Heather> haasn: why not
04:53:35 <haasn> Heather: The (forall r. Request state r -> IO r) bit is the problem; your version doesn't look like it's sufficiently polymorphic
04:53:58 <haasn> Either make your implementation of this more polymorphic, or relax the requirement
04:54:12 <sdx23> hi. Is it possible to do an eta-reduction in an expression like let readDouble x = read x :: Double -- ?
04:54:21 <prophile> funfunctor: I'm pretty sure everyone whose name isn't simon felt like that when they learned haskell
04:54:23 <haasn> sdx23: readDouble = read :: String -> Double
04:54:42 <sdx23> haasn: ahh, ok, I was really confused, thanks
04:55:01 <Heather> haasn: what's b0 anyways?
04:55:10 <haasn> Heather: b0 is the type of your chan, from line 12
04:55:16 <haasn> It's something - your code doesn't care what, but it's something
04:55:38 <bernalex> Heather: I leave you in the loving hands of haasn -- work stuff came up
04:56:49 <haasn> Oh, wait
04:56:51 <haasn> That's not quite true
04:57:03 <funfunctor> prophile: wipes the sweat and tears away, ok.. good ! :)
04:57:08 <haasn> I just saw your Req is existentially quantified
04:57:18 <Heather> haasn: my?
04:57:37 <haasn> Well, whoever wrote that's. On line 44
04:57:45 <funfunctor> prophile: I managed to write a compiler in a day or so, there are many many things still to do though
04:58:19 <bernalex> funfunctor: I use haskell professionally. I feel like a newb every day.
04:58:33 <Heather> haasn: forall a . Req (Request s a) (MVar a) ?
05:00:37 <bernalex> funfunctor: good part is: I simultaneously feel like a wizard.
05:01:37 <funfunctor> bernalex: i'm reworking my llvm codegen and trying to work out how to fit it into the Cryptol 2 compiler
05:02:06 <bernalex> funfunctor: cool. for work, or just for fun?
05:02:15 <funfunctor> bernalex: but I am working on a side project to get me to where I want to be.
05:02:21 <funfunctor> bernalex: both
05:02:31 <funfunctor> bernalex: i work for myself at the moment
05:02:33 <bernalex> funfunctor: hence the "just". work is always fun for me at least. ;-)
05:02:37 * hackagebot TypingTester 0.2.0.0 - Command Line Typing speed tester  http://hackage.haskell.org/package/TypingTester-0.2.0.0 (AlanHawkins)
05:02:58 <bernalex> well except for applying for funding. that's not fun. :-P
05:03:16 <funfunctor> bernalex: the Maybe fun Just work
05:04:23 <haasn> Heather: Hmm, it looks like it's just an inference error. If I add the type signature manually, it type checks
05:04:27 <funfunctor> bernalex: check it out ! https://gist.github.com/victoredwardocallaghan/cb3845b55a82b0ab9dfd
05:04:29 <haasn> I wonder why it doesn't infer correctly
05:05:01 <bernalex> heh. crablab.
05:05:09 <haasn> Doesn't seem related to the monomorphism restriction either
05:05:30 <funfunctor> haasn: maybe it does but the call site does not fall into the constraint of the type restriction (without looking at your problem)
05:05:40 <bernalex> haasn: you managed to nail it down into a line? link?
05:06:06 <haasn> bernalex: adding a type signature for “requestit” makes it type check - but that's not quite trivial because it mentions ‘state’ so you need ScopedTypeVariables (ugh)
05:06:13 <funfunctor> bernalex: its a attempt to write a matlab equiv in haskell
05:06:14 <haasn> But it might be a GHC bug or regression. I can't figure out why it doesn't infer correctly
05:06:17 <haasn> It should be rank-1 polymorphic
05:06:43 <funfunctor> type inference scares me personally
05:06:59 <funfunctor> I try to put type signatures on basically everything
05:07:13 <bernalex> haasn: is there other stuff there that requires rank-n-types?
05:07:29 <haasn> bernalex: Yes, the rank-n signature of ‘mkObject’
05:07:36 <bernalex> haasn: so does it work if you remove that?
05:07:50 <bernalex> haasn: can you factor out that & try the file w/o the RankNTypes pragma & see if that affects inference?
05:08:28 <Heather> haasn: what means add the type signature manually?
05:08:29 <wz1000> Anyone who knows why pipes break my program?
05:08:33 <bernalex> Heather:
05:08:35 <bernalex> > 1
05:08:37 <lambdabot>  1
05:08:37 <bernalex> >1
05:08:41 <bernalex> >1 :: Double
05:08:44 <bernalex> > 1 :: Double
05:08:46 <lambdabot>  1.0
05:08:49 <bernalex> god damn I keep forgetting heh
05:08:57 <bernalex> Heather: but yeah basically adding a type signature where one should not be needed
05:09:03 <Heather> bernalex: but there is added signature, to what object?
05:09:03 <bernalex> Heather: usually to restrict your code
05:09:09 <bernalex> Heather: requestit
05:09:46 <Heather> bernalex: r -> IO r?
05:09:49 <haasn> bernalex: Yes, I removed RankNTypes and I get the same error
05:09:57 <bernalex> haasn: ok so not a problem with that at least
05:09:58 <haasn> bernalex: Might be related to existential types
05:10:02 <haasn> Let me try to isolate it
05:12:38 <haasn> bernalex: I think I managed to isolate it
05:12:42 <furrykef> Cale -- well, I understand "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)" now but I don't grok it.
05:13:13 <bernalex> furrykef: what do you mean you understand but don't grok it? what's not grokking for you? :-]
05:13:22 <bernalex> it's really a very simple function
05:13:42 <funfunctor> bernalex: with fmap (const ()) . replEvalExpr :: String -> REPL () how can I stop "()" from also being printed out
05:13:56 <Saizan> so simple it's a list, not a function
05:14:04 <furrykef> It's just that I've been programming in Python for (I think) 11 years, so radically changing how I think is not exactly coming easy for me
05:14:23 <furrykef> (and C and C++ for longer than that)
05:14:33 <Heather> haasn: how you type requestin there?
05:14:53 <bernalex> Saizan: true hah.
05:15:14 <Heather> haasn: I can't type it with r - You cannot bind scoped type variable `r'
05:15:36 <haasn> Heather: It requires an extension, ScopedTypeVariables; but that requires changing other bits as well
05:15:48 <bernalex> furrykef: have you seen some of the perhaps easier fibonacci sequence implementations?
05:15:48 <furrykef> To be frank -- and I'm not saying it's a bad thing -- if a Martian came to me and said "this is how I program" and showed me Haskell, I'd think, "Wow, you really are Martian."
05:15:50 <haasn> requestin :: forall r. Request state r -> IO r
05:16:00 <haasn> and then the type of reactiveObjectIO needs to be changed to :: forall state object. state -> ...
05:16:09 <furrykef> bernalex -- yes. In fact, I programmed one (without peeking). That's what led me here, in fact, because I didn't do it quite right.
05:17:42 <furrykef> It's just that a recursively defined sequence isn't something I've seen before -- at least not without a conspicuous "n - 1" or something somewhere.
05:17:55 <bernalex> furrykef: I was a C/C++/Python guy mostly before haskell. done a little bit of common lisp, but not enough to be a true functional programmer. it's hard. but it gets easier surprisingly fast. then suddenly you'll find yourself cursing at C++ and Python for not being Haskell. :-]
05:18:05 <furrykef> I realize for instance if I do this:  seq = 1 : 2 : 3 : seq   then I'm going to get the sequence [1,2,3,1,2,3,1,2,3...]
05:20:07 <furrykef> Passing the seq to a function to define itself, though, like  seq = 1 : 2 : 3 : tail seq  (which of course results in [1,2,3,2,3,2,3...]) just feels weird somehow.
05:20:40 <bernalex> furrykef: once you start writing actual programs, recursion comes a lot more naturally than you might expect. it will be awkward at first, but then you'll "get it", and wonder what's wrong with people who still use imperative languages. ;-)
05:21:02 <bernalex> furrykef: I recommend game programming. that's a great way to learn. and it's fun for most people too.
05:22:09 <furrykef> heh, well, that's a familiar subject at least
05:22:19 <furrykef> (I have two Nintendo DS games under my belt)
05:22:50 <furrykef> I'd probably try to make something too big for my own good, though.
05:23:01 <alpounet> start small then
05:23:07 <prophile> furrykef: https://gist.github.com/prophile/a586f03befe2200994b6
05:23:07 <wz1000> Anyone has any idea why unix pipes break my program? Help would be appreciated.
05:23:14 <prophile> that's a translation of the fibs example into Python
05:23:37 <furrykef> prophile -- I'm not sure that's the right link. I just got redirected to gist.github.com.
05:23:42 <prophile> which may give you some kind of intuition
05:23:43 <furrykef> oop
05:23:46 <furrykef> it worked the second time
05:23:47 <furrykef> weird.
05:25:01 <furrykef> prophile -- thing is I never really used generators in Python either :P
05:25:08 <furrykef> (generator expressions, yes, but plain generators, maybe once)
05:25:24 <bernalex> learning functional programming is a good way to make the rest of your python team hate you ;-)
05:26:10 <prophile> "what do you mean true != lambda x, y: y?"
05:27:39 * hackagebot uri-encode 1.5.0.3 - Unicode aware uri-encoding.  http://hackage.haskell.org/package/uri-encode-1.5.0.3 (AdamBergmark)
05:30:36 <Heather> haasn: this way it compiles, thank you
05:32:13 <haasn> Heather: This is a regression from GHC 7.6.1 to 7.8.2 by the looks of it
05:32:29 <edwardk_> @tell danilo2 with trifecta you can use mark and release
05:32:29 <lambdabot> Consider it noted.
05:32:34 <haasn> Wait, scratch that
05:33:08 <haasn> It's not a regression, the issue is even weirder - it only occurs if you enable GADTs
05:33:27 <Heather> haasn: oh, I see...
05:38:28 <danilo2> edwardk_: Ok, but is "parsers" not ment to be a general interface for parser backend? Should it not define some methods to optain the parsing position?
05:47:58 <mokkake> hi, i got some trouble installing hscurses in a sandbox: http://pastebin.archlinux.fr/548679, can't understand the issue
05:50:03 <haasn> Heather: bernalex: https://ghc.haskell.org/trac/ghc/ticket/9456#ticket
05:50:24 <haasn> Would appreciate if somebody could just quickly make sure it fails under 7.8.3 as well
05:50:37 <haasn> So “try 7.8.3” isn't a valid response :p
05:52:44 <Heather> haasn: thanks
05:56:17 <mokkake> is this channel relevant for getting cabal help ?
05:56:24 <bernalex> mokkake: sure
05:56:53 <bernalex> haasn: I'll give it a go
05:57:37 <mokkake> okay, so if anyone got an idea on how to solve this: http://pastebin.archlinux.fr/548679, would be sweet
06:06:14 <hexagoxel> mokkake: hscurses is the problem, which is (on hackage) not updated to a version that works with ghc 7.8 (but it is fixed in github, and will probably be forwarded to hackage relatively soon..)
06:06:47 <mokkake> hexagoxel: okay, thanks for your answer. So installing the git version will work ?
06:07:45 <hexagoxel> pretty sure, but haven't tested myself (it's on my to-do list :D)
06:08:01 <mokkake> hexagoxel: okay thanks :)
06:08:28 <mokkake> does work indeed !
06:19:43 <lebek> what's wrong with my FromJSON Element instance http://lpaste.net/109550 ?
06:20:08 <lebek> compiler is telling me "No instance for (FromJSON Parser (Map ByteString Position))"
06:20:59 <lebek> I thought my code would require an instance of FromJSON (Map ByteString Position)
06:21:31 <lebek> so I don't understand where Parser comes from in that error
06:23:01 <danilo2> edwardk_: Could I ask you one more question regarding trifecta? What is te best way to read the last parsed character? Should I put it in a state or is there any otyher, better way?
06:29:00 <FelipeRosa> Hi guys, I’ve got a question… why is there such a big problem with package dependencies in Haskell that is not seen (or almost) in a language like Ruby for example?
06:29:30 <lieven_> more information encoded in the types
06:29:30 <bernalex> FelipeRosa: I haven't seen them with haskell apart from with yesod
06:29:41 <repnop> FelipeRosa: and ruby can get pretty ugly at times
06:29:45 <bernalex> (then again I use Portage a lot more than cabal)
06:30:49 <repnop> if you just write a site once and then let it be sure, but if you have to upgrade gems you get stuck figuring out what gem updated another gem to cause some section of the app to fail
06:31:01 <bernalex> basically using cabal (and pip and whatever other languages use) for sandboxes is great, but expecting them to work on a system is not going to be happy days.
06:31:09 <FelipeRosa> Hum… that’s it probably then hehe, I’m having most problems with Yesod, guess it was a biased question heh
06:31:34 <bernalex> FelipeRosa: 99.99% or so of the people who ask about cabal hell in the last couple of years are talking about yesod.
06:33:07 <FelipeRosa> I see… are there any solutions to this? or at least something a can do to minimize the problems?
06:33:23 <prophile> don't use yesod
06:33:25 <eevar> cabal install snap ;)
06:33:30 <FelipeRosa> I’ve been searching for a day or two but found nothing satisfying
06:33:38 <FelipeRosa> Oh, hahah
06:33:49 <bernalex> cabal install scotty
06:34:02 <prophile> pip install bottle
06:34:15 <bernalex> rm -rf / --no-preserve-root
06:34:50 <johannesvogel> hey guys, i have a question regarding do_curl / do_curl_ . Currently, I use it like this: " r <- do_curl curl statusURL [] " which works fine, but it says, that do_curl is deprecated. When I change it to use do_curl_ it says: "No instance for (CurlHeader headerTy0) arising from a use of `do_curl_' The type variable `headerTy0' is ambiguous". Any idea how I can fix this?
06:35:16 <geekosaur> actually the reason you don't see it in Ruby is everyone uses their own repos instead of a global one, in my experience. and for yesod, the same thing happens; you're supposed to install a pristine non-Platform ghc and then use Stackage
06:35:39 <FelipeRosa> Oh, makes sense
06:35:46 <bernalex> geekosaur: I've seen dependency hell in both ruby & python
06:35:47 <geekosaur> I got major headaches from "this version fo Rails uses exactly these versions of (half the ecosystem) and thou shalt not mix with anything else"
06:36:13 <bernalex> using an actual package manager instead of these lang-build tools makes all of the problems go away.
06:36:25 <bernalex> using cabal globally on a system is like using cmake or autotools globally. painful.
06:36:34 <prophile> nix
06:36:34 <kvelicka> is there a way to throw a warning if one of guard patterns gets executed? I could do it with trace, but I'm looking for a proper, ghc warning
06:38:29 <FelipeRosa> I’ll give snap a shot, thanks for the answers :d
06:39:05 <bernalex> FelipeRosa: there's also happstack
06:39:21 <bernalex> I ended up with scotty though
06:40:26 <FelipeRosa> bernalex: Why did you end up with scotty?
06:40:47 <sopvop> scotty is tiny
06:40:51 <bernalex> FelipeRosa: it's small & fast.
06:41:01 <bernalex> it uses wai & warp.
06:41:03 <sopvop> snap is not that big either
06:41:33 <bernalex> happstack isn't gigantic either, since it's so modular. you can start out small-ish.
06:42:45 <FelipeRosa> Oh, right… I’ll take a look at each of them :d
06:42:48 * hackagebot yesod-mangopay 1.9.1 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.9.1 (FelipeLessa)
06:43:58 <sopvop> Choosing web server /= locking yourself into one framework. Haskell's web is modular.
06:50:56 <johannesvogel> hey guys, i have a question regarding do_curl / do_curl_ . Currently, I use it like this: " r <- do_curl curl statusURL [] " which works fine, but it says, that do_curl is deprecated. When I change it to use do_curl_ it says: "No instance for (CurlHeader headerTy0) arising from a use of `do_curl_' The type variable `headerTy0' is ambiguous". Any idea how I can fix this?
06:54:10 <eevar> FelipeRosa: fwiw, I just installed yesod without issue. latest cabal-install, ghc 7.8.3, in a sandbox
06:55:21 <eevar> haven't made a project and tried building that, though
06:56:10 <FelipeRosa> eevar: Yeah, I managed to do that too
06:59:36 <hask54> I want to put GHC final app into the parent folder. This doesn't work:
06:59:37 <hask54>  ghc --make app.hs -o ../
06:59:49 <hask54> It gives me error, "can't open output file for writing"
06:59:51 <hask54> why?
07:00:14 <hask54> oh
07:00:16 <hask54> ../app worked
07:00:17 <repnop> that is a dir
07:00:21 <repnop> maybe?
07:10:51 <etandel> hask54: -o expects a filename, ../ is a directory.
07:10:57 <hask54> yeah
07:11:06 <hask54> ../app worked
07:15:47 <hask54> Why does this compile just fine: https://pastee.org/69w9w
07:15:47 <hask54> But this gives me an error? https://pastee.org/qxcyx
07:15:48 <hask54> I only added the readFile line. What's the problem there?
07:16:52 <tulcod> hask54: well what's the error?
07:17:31 <hask54> tulcod: this is the error: https://pastee.org/fr5k4
07:18:01 <tulcod> hask54: not every "do" statement concerns the IO monad
07:18:15 <tulcod> hask54: so look up the type of scottyH'
07:19:26 <tulcod> hask54: and if that doesn't make any sense, then look up what "do" statements are syntactic sugar for
07:20:23 <hask54> tulcod: that's the type: https://pastee.org/cdhjw
07:20:27 <hask54> so isn't that just an IO?
07:20:32 <hask54> like main always is
07:20:45 <tulcod> hask54: no, its output type is IO
07:21:12 <tulcod> hask54: its input types have Port and ScottyH' (),  hwereas you're trying to feed it an IO () action
07:21:24 <tulcod> hask54: the "do" statement is an *argument* to scottyH'
07:21:57 <hask54> ah, interesting
07:22:08 <tulcod> is it clear where the error lies?
07:22:25 <hask54> I'm just wondering how I can read a file in my web app
07:22:32 <tulcod> right :)
07:22:32 <hask54> if this doesn't work, i'm out of ideas
07:22:49 <tulcod> hask54: well what does it mean to "read a file in an app"?
07:22:51 * hackagebot haskoin 0.1.0.1 - Implementation of the Bitcoin protocol.  http://hackage.haskell.org/package/haskoin-0.1.0.1 (PhilippeLaprade)
07:22:56 <tulcod> i mean, you already have that funciton that implements your app
07:23:12 <tulcod> save from modifying its implementation, you can't do anything else "in" it
07:23:31 <tulcod> hask54: so either you read before you start execution of the "web app" part, or you read afterwards (which sounds rather silly)
07:23:51 <hask54> tulcod: ah of course!!
07:24:25 <hask54> tulcod: i haven't yet even reached chapter "applicative functors" in LYAH, so this still confuses me
07:24:31 <hask54> don't really know what a monad is yet
07:24:36 <hask54> but i get this now
07:24:39 <funfunctor> bracket is cool !
07:24:40 <tulcod> applicatives != monad
07:24:44 <funfunctor> :t bracket
07:24:45 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:24:45 <hask54> i'll put the read before scottyH'
07:24:47 <hask54> that should work
07:25:09 <tulcod> hask54: but yeah, i found it really helpful to be very precise about the types in your do statements
07:25:17 <tulcod> tells you the difference between "let" and "<-"
07:33:07 <hask54> how can I make readFile go into a subdirectory (with respect to the running app)? readFile "dir/foo.txt" doesn't work.
07:34:38 <mhyperbolic> Hello, I am going through Real World Haskell and thus creating copies of standard library functions. It's difficult to test these extensivly, so I was wondering if there is some way to use quickcheck to check if my functions gives the same results as the library function?
07:34:46 <Ankhers> readFile "./dir/foo.txt"?
07:35:00 <hask54> Ankhers: just tried, didn't work either
07:35:06 <hask54> still get this: openFile: does not exist (No such file or directory)
07:35:36 <Ankhers> hask54: It worked for me.
07:35:50 <Ankhers> as does "dir/.foo.txt"
07:36:22 <Ankhers> Are you running the binary from the directory above "dir"?
07:37:21 <hask54> Ankhers: yeah I compile the binary like this: ghc --make app.hs -o ../app
07:37:21 <hask54> And this is my top-level directory structure:  app (the compiled app), source (in which app.hs is), dir (which contains foo.txt)
07:38:07 <repnop> and you're running it from ../app and not ./ where you compiled it?
07:38:22 <repnop> er ../
07:38:32 <repnop> otherwise it'd have to be ../dir/foo.txt based on the src cwd
07:38:38 <hask54> repnop: oh shit, of course lol
07:40:10 <mads-> I am a C++ programmer with no knowledge of functional programming. What would be the best resource for me to learn haskell?
07:40:24 <repnop> learn you a haskell is good imo
07:41:30 <mads-> thanks :)
07:41:38 <hask54> mads-: hell yeah http://learnyouahaskell.com i'm reading it now it's awesome
07:41:49 <mhyperbolic> Real World Haskell is also nice for more hands on things.
07:41:51 <repnop> just might wnat to take it slow before you try to do any complex projects
07:44:09 <repnop> otherwise you might spend 30+ minutes just playing around with your toy concept only to have learned far more about the language studying a book in that time
07:44:20 <repnop> (and by playing i mean trying to fix the types)
07:46:58 <jkaye> repnop: I found playing with types to be one of the more helpful ways of learning. Ie. implement Applicative for the Free monad
07:47:08 <repnop> jkaye: at the very start?
07:47:33 <jkaye> repnop: Nope. Just in general. Don't want to scare someone away from trying things out
07:47:34 <repnop> honestly getting to the point where you read about monads would be more useful then try to hack IO and say StateT to play nice together
07:47:45 <jkaye> repnop: Agreed
07:50:10 <fizbin1> Is there any haskell language extension that allows for something like what scala allows for with type aliases internal to a type's definition?
07:50:11 <repnop> anyways i find haskell just fun to play around with in the end even if i'd be far more productive in other languages
07:50:41 <repnop> if i keep up playing around someday maybe i'll be productive in it also :)
07:52:18 <fizbin> That is, I have a type (TokenSystem specType tokType nfaEdge charType) and I'd like to easily, for a given TokenSystem, refer to "the NFA graph type appropriate to tokSys", which is (Pt.Gr () (Maybe nfaEdge))
07:53:28 <fizbin> Maybe I'm wanting something like type functions? Something that would take a full TokenSystem type (with all the variables filled in) and give me a new type?
07:54:13 <bernalex> I did this before but can't for the life of me remember how.
07:54:40 <bernalex> how do I "if someBool then append the text else don't append the text"?
07:55:01 <bernalex> I guess if bool then append "text" else append ""
07:55:04 <bernalex> would work
07:55:16 <hc> bernalex: try Control.Monad when?
07:55:23 <RyanGlScott> Is there a reason that showParen requires a Bool argument?
07:55:58 <RyanGlScott> It seems a bit redundant, given the function's purpose.
07:56:15 <fizbin> > let someBool = True in (if someBool then (++ ", World!") else id) "Hello"
07:56:17 <lambdabot>  "Hello, World!"
07:56:26 <fizbin> > let someBool = False in (if someBool then (++ ", World!") else id) "Hello"
07:56:27 <repnop> f t a b | b t ++ a | otherwise t ?
07:56:28 <lambdabot>  "Hello"
07:56:35 <Iceland_jack> RyanGlScott: It matters depending on the current precedence
07:56:55 <bernalex> hc: not sure how to make that unugly for a simple "test" ++ "test"
07:57:29 <RyanGlScott> Iceland_jack: So is it for convenience then?
07:57:33 <hc> bernalex: 'when' only works when inside a (writer) monad
07:57:35 <repnop> need the = signs of course hehe
07:57:38 <bernalex> hc: exactly
07:58:03 <bernalex> I want to do "foo" (if someBool ++ "bar")
07:58:38 <hc> bernalex: perhaps with catMaybe and concat?
07:58:48 <hc> sry, catMaybes
07:58:57 <bernalex> I think there's a way to get clever here using applicatives, but IDR how
07:59:52 <bernalex> I guess concat . catMaybes isn't too bad
08:00:15 <fizbin> > let someBool = False in concat $ ["Hello"] ++ [", World!" | someBool]
08:00:18 <lambdabot>  "Hello"
08:00:31 <fizbin> > let someBool = True in concat $ ["Hello"] ++ [", World!" | someBool]
08:00:32 <lambdabot>  "Hello, World!"
08:01:04 <bernalex> fizbin: nice, thanks
08:05:22 <RyanGlScott> Suppose you have a really long chain of showStrings, e.g. showString a . showString " " . showString b . showString " " . showString c
08:05:35 <RyanGlScott> What's an elegant way of avoiding the repetition of showString?
08:08:21 <albertid_> RyanGlScott, intersperse
08:08:39 <Exio4> isn't that a fold?
08:08:40 <Cale> Or even unwords
08:08:45 <vanila> map showString [a," ", b," ", c]
08:09:24 <albertid_> map showString $ intersperse " " [a, b, c]
08:09:29 <Cale> > unwords ["hello", "there", "world"]
08:09:30 <lambdabot>  "hello there world"
08:09:49 <albertid_> oh yea, Cale :)
08:10:11 <bennofs> appEndo $ foldMap (Endo . showString) $ intersperse " " [a, b, c]
08:10:14 <RyanGlScott> Would unwords be as efficient as using ShowS?
08:10:44 <bennofs> :t intersperse
08:10:45 <Cale> RyanGlScott: Pretty much. You can apply (++) to the result to get a ShowS if you like.
08:10:46 <lambdabot> a -> [a] -> [a]
08:10:49 <mhyperbolic> http://lpaste.net/109560 . How can I boils this down to one declaration of step? I've been staring at it and can't see it.
08:12:55 * hackagebot hayoo-cli 0.1.0.4 - Hayoo CLI  http://hackage.haskell.org/package/hayoo-cli-0.1.0.4 (Gonzih)
08:13:48 <hask54> When I run my Haskell web app locally, it works fine, I can visit it via http://localhost:3000  However, when I compile (successfully) and run the same web app on my Linux machine, the system cannot access http://localhost:3000  Why not?
08:14:24 <Cale> hask54: What?
08:14:38 <Cale> hask54: You just said one thing, and then the opposite of that same thing.
08:14:44 <repnop> that is a question with many possible issues...
08:14:57 <hask54> Cale: I'm running a scotty web app https://github.com/scotty-web/scotty
08:15:04 <hask54> repnop: yeah..
08:15:08 <repnop> if you're trying to access it from your local system to the linux one, cannot use localhost.
08:15:09 <Cale> Can you visit it or not?
08:15:46 <Cale> Are you trying to say that your app works on windows and not linux?
08:16:02 <repnop> your distro might not allow inbound 0.0.0.0
08:16:11 <repnop> if you're using the real host ip
08:16:25 <hask54> Cale, repnop: I can visit it locally (on my OS X Safari web browser) when I compile and run it locally.  However, I can *not* access it on a web browser on my Ubuntu linux server (the Links text browser) if I compile and run it on my Ubuntu linux server machine.
08:16:44 <repnop> ah
08:16:58 <repnop> check dmesg to see if there was a deny on port 3000
08:19:04 <repnop> could netstat -nl to verify it is bound to 3000
08:20:08 <hask54> repnop: i tried "tail -f /var/log/{messages,kernel,dmesg,syslog}" (as suggested in http://superuser.com/questions/289239/is-it-possible-to-tail-f-the-output-of-dmesg) while accessing the site, but nothing got logged
08:20:33 <repnop> netstat -nlp | grep 3000
08:22:04 <hask54> repnop: yeah it's active:
08:22:04 <hask54> tcp        0      0 0.0.0.0:4007            0.0.0.0:*               LISTEN      9028/app
08:22:05 <hask54> (i'm using port 4007 btw)
08:22:13 <hask54> (just thought i'd write 3000 earlier for simplicity :) )
08:22:14 <repnop> yep looks bound to all interfaces
08:22:30 <hask54> so what could the issue be..
08:22:50 <repnop> sadly i don't do networking in haskell so someone else will have to step in :)
08:23:30 <_yo_> i cannot install darcs (not even in a sandbox), because it depends on a too old version of base. is this for a reason or has it just not been updated in a while?
08:24:21 <eevar> hask54: try curl -i host:port
08:24:49 <hask54> eevar: $ curl -i localhost:4007
08:24:50 <hask54> curl: (52) Empty reply from server
08:26:58 <mads-> learnyouahaskell says "null checks if a list is empty. If it is, it returns True, otherwise it returns False. Use this function instead of xs == []". Does this mean that using xs == [] is better to use then null?
08:27:21 <enthropy> @type null
08:27:22 <lambdabot> [a] -> Bool
08:27:27 <enthropy> @type (== [])
08:27:28 <lambdabot> Eq t => [t] -> Bool
08:27:31 <repnop> you have that backwards eh
08:27:38 <repnop> based on the english anyways
08:27:49 <nclarke> @_yo_ Looks like it was last updated in Feb 2013
08:27:50 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT MY
08:27:50 <lambdabot> WAY" I've ever heard!!
08:27:55 <`Jake`> Yeah, learnyouahaskell says that you should prefer null over xs == []
08:28:12 <mads-> oh yeah, I misread that...
08:29:40 <hask54> eevar, repnop, My Node.js local express apps run just fine however. Localhost is recognized for them
08:29:42 <`Jake`> And as the types show, null is more general than using xs == [], so that's nice
08:29:47 <hask54> so I'm not sure what went wrong with my scotty apps
08:29:51 <hask54> ONLY on my ubuntu
08:30:08 <hask54> (again, works fine on my local os x computer)
08:30:10 <_yo_> nclarke: ich thought darcs has to be a very popular package, yet it doesn't build on recent versions of ghc. is there something that needs to be fixed first? or can we just bump the packages' dependencies
08:31:01 <hask54> _yo_: lol ich
08:31:33 <enthropy> _yo_: I'm pretty sure the source you can get from "darcs get http://darcs.net" will build with the current ghc
08:32:32 <_yo_> enthropy: ah, ok, thank you. i thought they kept hackage up-to-date to contain the latest stable version
08:32:38 <eevar> fetching said source could get tricky if you're unable to build darcs, tho ;)
08:32:53 <enthropy> probably they should upload something to hackage
08:33:11 <_yo_> eevar: i can fetch it from another machine that has an older version of darcs installed, but in general, you are right
08:33:41 <_yo_> eevar: in addition, my distro does not provide darcs by default
08:33:50 <enthropy> it's pretty straightforward to get darcs to call cabal sdist whenever you push
08:34:02 <eevar> pragmatically, there are probably some git mirrors of the darcs repo
08:34:24 <enthropy> so they could set it up that you could "cabal install http://darcs.net/snapshot.tar.gz"
08:35:52 <_yo_> enthropy: sounds like a good idea. you could also create daily snapshots this way (in case the latest version is broken)
08:42:04 <tritlo> how bout using darcs from stackage?
08:44:28 <repnop> hask54: i think you shoudl check the version of your haskell environment and libraries on windows compared to linux
08:44:32 <evancz> i am attempting to build 4 cabal projects that have dependencies on each other
08:44:40 <evancz> using the strategy outlined here: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
08:44:44 <repnop> if they aren't the same, you have more variables to account for to solve the issue eh?
08:44:55 <evancz> in the "advanced usage" section
08:45:09 <repnop> and in the future if you are planning to deplay to linux anyways, better off getting used to tmux
08:45:33 <evancz> it seems that the sandbox prefers to go to hackage than to use the sub-sandbox version that I just built
08:45:54 <evancz> is my problem clear?
08:46:13 <evancz> B and C both depend on A
08:46:17 <evancz> I build A from source
08:46:23 <evancz> I then build B and C
08:46:28 <hask54> repnop: what's the simplest way to check which versions of scotty, warp, wip I have? (i guess those are the crucial ones)
08:46:40 <evancz> but instead of using the A I just built, it goes to hackage and builds whatever is there
08:47:01 <Saizan> evancz: if you build A from custom source you should change its version number, otherwise cabal assumes it's the same as on hackage
08:47:12 <repnop> hask54: i don't know how haskell works in windows
08:47:22 <repnop> but you might have a %USERDIR%/.cabal directory?
08:47:30 <hask54> repnop: by the way, telnet gives me this, does this info help in any way? at least it seems to be showing that there is a warp server there... https://pastee.org/bj64a
08:47:32 <luite> evancz: you have used add-source for A?
08:47:45 <repnop> or whatever that variable is in windows
08:47:47 <Saizan> hask54: ghc-pkg list
08:47:54 <evancz> i do the "cabal sandbox init --sandbox=root/dir"
08:48:16 <evancz> luite: I don't think add-source does what I want?
08:48:35 <evancz> luite: or at least I seem to have had more success with the --sandbox flag
08:49:37 <repnop> is it a safe bet to assume with assume on forking COW of the os should benefit data that was parsed before the fork?
08:50:03 <evancz> Saizan: the idea is to build based on a bunch of git tags, not on cabal stuff
08:50:22 <luite> evancz: hm, ah i see. do they show up in list-sources after that?
08:50:28 <evancz> Saizan: I can lower my goals though
08:50:41 <evancz> luite: let me check
08:51:25 <repnop> i guess i should phrase that better. I'm wondering (as i think it does) ghc should benefit from linux COW when forking for most situations
08:52:59 * hackagebot djinn-ghc 0.0.2.2 - Generate Haskell code from a type. Bridge from Djinn to GHC API.  http://hackage.haskell.org/package/djinn-ghc-0.0.2.2 (AlejandroSerrano)
08:53:56 <evancz> luite: it says weird stuff
08:54:21 <evancz> it says it can't find anything in the root and the subdirectories that are actually downloaded from github and linked to the root with --sandbox
08:54:48 <evancz> but if i go into the packages.conf.d directory (or whatever it is) all the stuff is listed there
08:54:58 <evancz> one version of package A
08:55:29 <evancz> i'll try some other stuff, thanks :)
08:56:12 <repnop> ah reading the yesod about page sounds like you can....though they should update that page as ruby 2.1 also easily takes advantage of cow fork
09:03:51 <pbogdan>  /quit
09:06:40 <preyalone> is there an Emacs package to show type information on hover?
09:12:08 <Ankhers> preyalone: Does haskell-mode not do that?
09:13:01 * hackagebot haskoin 0.1.0.2 - Implementation of the Bitcoin protocol.  http://hackage.haskell.org/package/haskoin-0.1.0.2 (PhilippeLaprade)
09:18:02 <alcabrera> preyalone: ghc-mod doesn't do this on hover, but for files that type check, I can press "Alt-?" to show the type of an expression in the buffer.
09:20:58 <debs> hey
09:24:51 * dfeuer points out that compiling GHC takes a long time.
09:28:02 * hackagebot amqp 0.10.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.10.1 (HolgerReinhardt)
09:28:44 <carter> dfeuer: when your own code bese gets to be 100kloc of haskell you should be so luck :)
09:28:46 <carter> *lucky
09:30:08 <dfeuer> carter, do you have a tip on how to avoid a full GHC recompile just to see the effect of a change to a library on nofib?
09:30:26 <carter> no clue
09:30:31 <carter> ask on ghc-dev mailing list
09:30:33 * dfeuer puts food on carter's family.
09:30:39 <carter> thats not nice
09:30:54 <Luke-> https://github.com/snapframework/snap-server/blob/master/test/Snap/Internal/Http/Server/Socket/Tests.hs how can this test do IO, it doesn't look like Test is a monad transformer?
09:31:05 <dfeuer> carter, you may not recognize where that came from if you're not from the U.S.
09:31:12 <carter> i'm from NYC
09:31:22 <carter> manhattan
09:31:57 <dfeuer> My brother lives in Manhattan.
09:32:02 <carter> cool
09:32:09 <carter> tis a yummy island of food
09:33:00 <dfeuer> What am I dooooing wrong?
09:33:03 * hackagebot fay 0.20.1.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.2 (AdamBergmark)
09:33:58 <dfeuer> How do I get nofib built with the right compiler?
09:34:31 <bergmark> Luke-: The Test constructor has a TestLike constraint, which has an IO method
09:34:43 <carter> well, you can actually document what you're trying to do, state the goal and whats going wrong, and email ghc-devs with a link to you writeup of what you're trying to do and whats not working
09:34:48 <carter> instead of asking rhetorical questions
09:34:52 <carter> whats the dev wiki say?
09:35:17 <bergmark> Luke-: IO is also not a monad transformer but can still do IO ;-)
09:35:39 <napping> Is there any nice library for partial orders/preorders/relations?
09:35:40 <Luke-> can I use it with any monad then?
09:35:55 <dfeuer> Dunno, carter, I haven't found it there yet. I was just reading the internal documentation.
09:35:57 <carter> napping: 1-2
09:36:01 <carter> what itnernal docs?
09:36:03 <napping> I'm using fgl, but I've had to implement some thinngs myself
09:36:13 <carter> dfeuer: look on the wiki better
09:36:36 <Luke-> bergmark: where do you see the IO constraint?
09:36:38 <dfeuer> carter, nofib/README.md
09:36:45 <napping> I'm pretty much only interested in raw relations for modifying them a bit before taking a transitive closure
09:36:46 <carter> dfeuer: look on the dev wiki more
09:37:12 <bergmark> Luke-: I'm not sure what you are trying to do, but usually I have a transfomer stack that collects tests, and then you can just run them from main
09:37:30 <bergmark> Luke-: runTest: http://hackage.haskell.org/package/test-framework-0.8.0.3/docs/Test-Framework.html#t:Testlike
09:37:40 <Luke-> bergmark: yeah I use a writerT in my monad trans stack now to collect tests
09:37:43 <napping> carter: suggestions? No hits on hackage for preorder or "\"partial order\"", and "partial order" gives mixed results
09:37:48 <Luke-> bergmark: is that not a good way to do it?
09:38:02 <nshepperd> Luke-: the actual definition there is testCase "socket/closedOnListenException" $ do { ... }
09:38:03 <bergmark> Luke-: I do that too sometimes
09:38:05 <carter> dfeuer: https://ghc.haskell.org/trac/ghc/wiki/Building/RunningNoFib
09:38:14 <carter> napping: whats it you wanna actually do
09:38:16 <carter> whats the end goal
09:38:18 <dfeuer> carter, I just found that.
09:38:25 <carter> :p
09:38:34 <nshepperd> Luke-: afaict testCase :: String -> IO () -> Test
09:38:53 <napping> Well, I've got a set of strict subset contraints that I eventually want to turn into a set of constructors
09:38:55 <bergmark> Luke-: hmm actually I don't, i use a writer to collect assertions inside test cases
09:39:10 <nshepperd> Luke-: so the contents of that do-block is normal plain IO
09:39:19 <Luke-> nshepperd: so in this case 't' is the IO monad?
09:39:27 <napping> so things like taking the transitive reduction of a dag, shortest path, just plain querying whether things are subsorted
09:39:33 <carter> oh
09:39:39 <carter> so you want a "deep embedding model"
09:39:43 <carter> of a partial order
09:39:44 <carter> thats explicit
09:39:57 <bergmark> Luke-: i recommend using tasty instead of test-framework by the way, moving to tasty is very simple
09:39:59 <carter> napping: i don't have my matrix lib done yet, or i'd say it'd be good for directed graph iterations
09:40:00 <napping> sounds about right - it's in a compiler sort of program
09:40:08 <carter> bergmark: but the compile times go up
09:40:08 <Luke-> bergmark: I'm using tasty
09:40:46 <Luke-> bergmark: but I'm testing state monad code and i want to interleave asserts so I had to do it with the writerT with a StateT inside
09:40:59 <Luke-> bergmark: where the asserts are collected in the WriterT
09:41:27 <bergmark> carter: from using tasty over test-framework?
09:41:32 <Luke-> bergmark: so I was looking at test-framework to see if the monadic testing was any better and it looked like this example was threading the IO monad through
09:41:41 <carter> bergmark: yeah, 'cause tasty has all those regex lib deps etc
09:41:51 <carter> so travis takes like 5+ minutes ot build all the deps
09:41:57 <bergmark> ok, well I don't really care about test dependencies :-)
09:42:45 <carter> well
09:42:49 <carter> depends on the tool suite
09:43:07 <Luke-> carter: you're saying test-framework builds faster because it has less deps than tasty?
09:43:24 <napping> I guess the most graph-like thing I want is an immediate-dominator computation, which I use to help figure out which subsortings have to be implemented as functions
09:43:38 <carter> 'cause of regex-tdfa-rc
09:43:48 <Luke-> ah
09:43:55 <Luke-> at least tasty gets updated
09:44:02 <carter> test-framework does too
09:44:07 <Luke-> bergmark: anyway am I being clear about what I'm asking here?
09:44:11 <carter> its now managed by github.com/haskell
09:44:12 <carter>  :)
09:44:18 <carter> https://github.com/haskell/test-framework
09:44:19 <napping> a glb would be nice
09:44:24 <phaazon> > ["test","foo"] >>= (return . length)
09:44:25 <lambdabot>  [4,3]
09:44:26 <carter> which means i have push powers ;)
09:44:35 <Luke-> carter: Upload date	Wed Oct 9 00:25:39 UTC 2013
09:44:42 <carter> Luke-: so?
09:44:50 <repnop> so liftIO is just a transformation to allow another io access right?
09:44:51 <Luke-> so the packages hasn't been updated since then
09:44:52 <carter> if you want you can PR changes on it
09:44:56 <carter> so?
09:45:00 <carter> if it still works why patch it?
09:45:00 <repnop> a functor?
09:45:12 <repnop> another monad that is*
09:45:18 <carter> Luke-: does a stable test suite lib need patching that much?
09:45:28 <Luke-> code working /= code making progress
09:45:53 <carter> well, i fyou wanna improve stuff i can make sure any good PR gets merged in
09:46:00 <carter> otherwise i don't understand our discussion
09:46:04 <bergmark> Luke-: i don't really understand what the problem is
09:46:38 <Luke-> bergmark: I want to be able to test monadic code with Tasty and I think I need to use a Writer monad to collect asserts - is that true or did I just not do it right?
09:47:39 <Luke-> carter: maybe update the package to at least point at the lastest github url?
09:47:46 <carter> Luke-: it does
09:47:49 <carter> look on hackage man
09:48:10 <carter> don't Source repository	head: git clone https://github.com/haskell/test-framework
09:48:12 <carter> see
09:48:29 <Luke-> carter: Home page	https://batterseapower.github.io/test-framework/
09:48:45 <Luke-> carter: the docs for tasty are better and more accessible
09:48:50 <carter> whatever
09:48:51 <Luke-> carter: does tasty have HTML output?
09:48:52 <carter> i don't care
09:49:01 <carter> i'm just saying
09:49:01 <Luke-> i care though
09:49:03 <Luke-> that's why I use tasty
09:49:06 <carter> well then write PRS
09:49:09 <carter> i use tasty too
09:49:11 <carter> you're missing my point
09:49:15 <carter> and i'm done talking about this
09:49:36 <Luke-> my point is simple: moving the repo doesn't mean the code is being worked on
09:49:43 <Luke-> and it's not like the code doesn't need work
09:49:55 <Luke-> whether that's in the form of docs, or more reporting etc
09:50:12 <carter> thes are valid points
09:50:32 <carter> otoh, i don't spend that much fo my engineering doing testing, so  as long as tests run i dont care that much :)
09:50:57 <Luke-> carter: not everyone is in the same situation
09:51:01 <carter> i know
09:51:07 <carter> notice how i wasn't telling you how to work
09:51:12 <carter> just how theres a space of choicse
09:51:16 <carter> and they're valid for different people? :)
09:51:25 <carter> i'm not telling you what your definition of validity
09:51:28 <carter> just that theres more than one
09:51:44 <carter> please don't tell my personal definition of whats valid is invalid
09:52:01 <carter> because then it turns into a metaphysical something something
09:52:02 <Luke-> i think your original point was that test-framework is maintained and my point is that it's not maintained in the areas that I care about so it's not an option for me, and many other people in my situation
09:52:17 <carter> sure
09:52:18 <bergmark> Luke-: I ended up with a writer for assertions because I needed my test cases to be `IO MyTestReader -> TestTree'
09:52:21 <bernalex> carter: Luke-: this is getting antagonistic. mind moving it to #haskell-blah?
09:52:29 <carter> bernalex: i'm done talking about it anyays
09:53:09 <Luke-> bergmark: i see
09:53:38 <john_not_jenny> I'm trying to use Data.Attoparsec.ByteString.Char8, and I've installed Attoparsec with Cabal.  GHCI is unable to find the module.  Is there something else I need to install?
09:53:54 <carter> john_not_jenny: hrmmmm
09:53:57 <carter> howd you install it?
09:54:06 <john_not_jenny> cabal install attoparsec
09:54:07 <Luke-> bergmark: I guess my point is I can't tell if I can put a Test in my StateT m
09:54:26 <john_not_jenny> I had it working before, but they deprecated Data.AttoParsec.Char8
09:54:37 <carter> ohhh
09:54:38 <carter> ohhh
09:54:39 <carter> hangon
09:54:49 <napping> john_not_jenny: there shouldn't be. What version did you get?
09:54:55 <carter> https://hackage.haskell.org/package/attoparsec-0.12.1.1/docs/Data-Attoparsec-ByteString-Char8.html or https://hackage.haskell.org/package/attoparsec-0.12.1.1/docs/Data-Attoparsec-Text.html
09:54:56 <bergmark> Luke-: sure, you can put it in there, then you get it out to run the tests
09:55:07 <carter> john_not_jenny: the way to find the version is to do ghc-pkg list
09:55:11 <Luke-> bergmark: yeah but it's not a monad
09:55:18 <bergmark> Luke-: what's not a monad?
09:55:44 <Luke-> bergmark: Tasty
09:56:11 <john_not_jenny> Hm...
09:56:18 <Luke-> bergmark: more specifically: TestTree
09:56:21 <napping> carter: the point of the dominator stuff is to add edges so there is a unique shortest path between any pair of related items. Can you do that just with matrices?
09:56:55 <carter> well, if you can model the latice / whatever as a directed graph, why not
09:56:59 <carter> you're doing that with FGL as is?
09:57:09 <napping> Yeah, calling it's immediate dominator routine
09:57:36 <john_not_jenny> Well, it works now.  I reran ghc-pkg recache (I couldn't find attoparsec in the list... even though it said it was installed) and it installed fine.  Weird. Thanks anyway
09:57:56 <napping> john_not_jenny: were you perhaps in a cabal sandbox the first time?
09:58:01 <john_not_jenny> napping, ohhhh
09:58:07 <john_not_jenny> napping, yes I was ha
09:58:13 <john_not_jenny> I just started using them, I'm not used to it yet
09:58:30 <napping> Maybe cabal repl in the sandbox would work?
09:58:48 <napping> I've been using haskell-mode rather than running ghci directly
09:58:58 <napping> but I think that's how you get a ghci with access to packages installed in the sandbox
09:59:04 <john_not_jenny> ah.
09:59:24 <eevar> john_not_jenny: you may want to add "require-sandbox: True" to ./cabal/config
09:59:42 <napping> eevar: what's that for?
10:00:41 <eevar> it aborts cabal commands with an error if you're not in a sandbox
10:01:02 <carter> eevar: i'd personally not do that
10:01:03 <john_not_jenny> So I should be using the sandbox at all times?
10:01:14 <carter> john_not_jenny: not necessarily
10:01:23 <carter> but its a valid workflow
10:01:31 <carter> i 'm old school and don'tuse sandboxes
10:01:42 <carter> otoh, i tend to have pretty version range permissive code bases
10:01:47 <eevar> john_not_jenny: the only package in *my* ~/.cabal is cabal-install itself
10:01:48 <carter> so i dont need to break out sandboxes that often
10:01:51 <napping> and I use them, but not all the time
10:02:07 <napping> actually, I just use haskell-mode
10:02:08 <carter> i like my faster build times this way :)
10:02:15 <eevar> keeps stuff from breaking, but i spend a lot of time compiling ;)
10:02:27 <bergmark> Luke-: but the contents of a TestTree can run in IO so you can do everything in there, why does TestTree itself need to be a monad?
10:02:35 <napping> and it gives you a repl which is in a sandbox or not automatically
10:03:06 * hackagebot simple-config 1.2.2.1 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.2.2.1 (YusukeNomura)
10:04:43 <preyalone> Does Alt+? work for third-party types loaded from Cabal file dependencies?
10:04:59 <john_not_jenny> I'm not sure how they would work with programs I want to install.  For example, I use cabal to install xmonad. Would I create a sandbox for Xmonad and install it that way?
10:05:14 <john_not_jenny> (if I had require-sandbox)
10:06:22 <carter> john_not_jenny: i'm personally against sandboxes for building binaries
10:06:31 <carter> john_not_jenny: my trick is to build the binary normally
10:06:32 <Luke-> bergmark: I don't want to run IO. I want to either put my monad into TestTree or have a TestTree in my StateT m
10:06:39 <silver_> I think you should use the package manager for your distro
10:06:43 <carter> then trash ~/.ghc when versions get graumpy
10:06:55 <john_not_jenny> heh
10:07:04 <carter> its always safe to explode ~/.ghc
10:07:07 <carter> never ~/.cabal
10:07:08 <carter> well
10:07:11 <carter> sometimes ~/.cabal
10:07:17 <carter> but that should be for a good reasons
10:07:22 <carter> but always safe to trash ~/.ghc
10:07:48 <napping> carter: I have one big sandbox I use for building binaries
10:07:59 <carter> and thats a valid approach
10:08:17 <napping> similar to what you do, but it keeps things just needed for binaries from getting mixed up with global stuff
10:08:55 <carter> reminds me
10:09:01 <carter> new pandoc has docx support and other crazies
10:09:42 <napping> well, I think work is underway on caching builds
10:09:54 <carter> yeah
10:09:57 <carter> no
10:09:59 <carter> even better
10:10:00 <carter> wayy better
10:10:36 <napping> better than caching each individual package build?
10:10:54 <carter> wel, multi version support
10:10:54 <prophile> I have .ghc and .cabal as symlinks to dirs in /tmp
10:11:00 <prophile> plus a script to build my usual packages
10:11:12 <carter> so you can talk coherently about using more than one version of a lib in the same package
10:11:20 <carter> vai the transitive deps
10:11:22 <napping> oh, is it actually going that far?
10:11:31 <prophile> it takes almost exactly the right amount of time to make a cup of coffee
10:11:33 <napping> I thought it was just to give ghc-pkg multiple version support
10:11:55 <napping> but you'd still need cabal or something to help sort out the versions well enough to build any particular thing
10:11:57 <carter> edward z yang is working on a bunch of stuff intersecting how ghc handles deps and module and packages and its intersection with cabal
10:12:00 <carter> yeah,
10:12:04 <carter> hes doing some really exciting stuff
10:12:34 <napping> multiple packages in the same project has a lot of risks to rule out
10:12:40 <ajcoppa> carter: that sounds amazing
10:12:50 <carter> napping: yes
10:12:52 <carter> he's doing it right
10:13:05 <napping> Even just letting ghc-pkg retain multiple packages is enough to set up sandboxes with no redundant recompilationm
10:13:16 <carter> well
10:13:17 <carter> the point is
10:13:30 <carter> things will be getting very snazzy come 7.10 wrt tooling for more "caching"
10:13:38 <carter> but thats just the tip of the iceberg
10:13:43 <napping> yeah, however it goes
10:15:08 <bergmark> Luke-: since TestTree isn't a monad transformer you can't stack anything under it, but why is the other way a problem? Im not sure what "putting a TestTree in my StateT" means, isn't it just `return' or `put'?
10:16:16 <Luke-> bergmark: i want to run like 10 asserts interleaved in my monadic code
10:16:31 <Luke-> bergmark: like "do monadic action, test, do monadic action, test" etc
10:18:19 <napping> /leave/leave
10:19:41 <bergmark> Luke-: aha, that's why i use a Writer
10:20:05 <Luke-> ha ok me too
10:21:04 <Luke-> bergmark: I'm imagining making TestTree a monad which basically wraps writer so you can stack it in a transformer
10:23:44 <dmj> transformers, monads in disguise
10:26:01 <repnop> dmj: is there somewhere that goes indepth on that (learn you a haskell does it?) as i'm already using liftIO when working in another monad but i'd like to learn more about it
10:26:32 * repnop waits for the category theory response
10:26:50 <dmj> repnop: yes, Grabmuller has an excellent article on it, RWH mentions it briefly (you write your own MaybeT)
10:26:59 <repnop> thanks :)
10:27:20 <dmj> repnop: to understand the nesting of transformers knowing kinds really helps
10:27:24 <repnop> though i still have to figure out why Random isn't working inside my StateT do
10:27:36 <repnop> but i put off working on it until i learn more
10:27:52 <dmj> repnop: do kinds make sense to you?
10:27:57 <merijn> repnop: I think the best way to understand transformers is to implement one (or more) yourself!
10:28:21 <repnop> dmj: i'm slowly learning porting this ruby app that was mostly functional but obviously not pure
10:28:21 <dmj> repnop: sorry if that came across condescening, that is not my intention
10:28:26 <repnop> dmj: hardly
10:28:29 <merijn> Let's see if I still have my homework exercise for people lying around :)
10:28:46 <merijn> repnop: Did you ever implement the State monad yourself?
10:29:07 <repnop> i just want to learn why if i have a randomRs inside of StateT do it always has the same seed hehe
10:29:28 <merijn> :t randomRs
10:29:30 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
10:29:44 <repnop> however if it isn't in a StateT do it works correctly
10:29:45 <dmj> repnop: a new seed requires IO
10:30:07 <repnop> dmj: so the RandomGen isn't being given again?
10:30:12 <repnop> i just mean the initial seed
10:30:32 <repnop> in an IO monad getStdGen inits with a new seed everytime
10:30:36 <repnop> (per process)
10:30:53 <repnop> but when i use it inside of a runState it always has the same seed
10:31:09 <repnop> i still have so much to learn, just wish i could study why :)
10:31:29 <repnop> in ruby i just load 8GB then fork per run lol
10:31:38 <Luke-> bergmark: anyway thanks for letting me bounce ideas off you
10:32:09 <merijn> repnop: Can you lpaste this code you're using with State?
10:32:13 <dmj> repnop: you can call next on the RandomGen to get a new value yes
10:32:33 <repnop> merijn: sure though i'm still reading the basic haskell books i was just interested in that behavior
10:32:43 <repnop> let me make a simple example
10:33:08 * hackagebot between 0.9.0.1 - Function combinator "between" and derived combinators  http://hackage.haskell.org/package/between-0.9.0.1 (PeterTrsko)
10:35:58 <merijn> repnop: I think the best way to understand transformers is to implement both State and the State transformer: http://lpaste.net/109563
10:36:18 <dmj> repnop: I highly recommend the typeclassopedia as well, which covers State and StateT as merijn mentions
10:37:26 <repnop> cool
10:37:35 <repnop> i was still converting this engine
10:38:33 <repnop> i was just wondering why in a runStateT g <- liftIO $ getStdGen; let rnd = randomRs (1, 100) g :: [Int] always had the same seed...maybe due to using mapM on a list that was taking from it
10:39:01 <repnop> i didn't really want to bring it up yet since i'm wasting your time
10:39:20 <ghull> hello all.  Just looking for someone to reassure me that it is actually possible to learn this language.
10:39:59 <prophile> ghull: it is
10:40:20 <repnop> and using mkStdGen would add IO to the type ruining the sim
10:40:26 <repnop> i ended up just using real tick data instead lol
10:40:43 <ghull> prophile: thanks.   I'll get back to it.
10:40:52 <repnop> once i figure out why they didn't play nice i could build some rng sims
10:40:52 <prophile> I'm helping!
10:42:15 <repnop> but i should write my own state monad
10:43:09 * hackagebot apache-md5 0.6.1.0 - Apache specific MD5 digest algorighm.  http://hackage.haskell.org/package/apache-md5-0.6.1.0 (PeterTrsko)
10:43:38 <repnop> just seems weird that the getStdGen seeds itself differently when you're in main compard to runStateT
10:43:53 <merijn> :t getStdGen
10:43:55 <lambdabot> IO StdGen
10:44:03 <merijn> oh
10:44:14 <merijn> repnop: I think I know the missing clue for you :)
10:44:21 <repnop> merijn: nice :)
10:44:24 <merijn> getStdGen only gets the *current* seed
10:44:39 <repnop> so have to pass it to my StateT
10:44:44 <merijn> repnop: All the IO versions of functions in the random module update it afterwards
10:44:44 <repnop> before in it
10:45:12 <merijn> :t randomR
10:45:13 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:45:21 <repnop> :t randomRs
10:45:22 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
10:45:23 <merijn> repnop: There's a reason that returns a new RandomGen
10:45:27 <nshepperd> if you're going to discard the RandomGen after using it I think you need to use some kind of split* function
10:45:37 <repnop> i was using randomRs
10:45:50 <merijn> repnop: randomIO will use randomR and then write the next seed to the IO
10:45:57 <repnop> ah
10:46:04 <repnop> so if not in IO monad it won't update?
10:46:05 <merijn> repnop: randomRs generates an infinite list starting from a certain seed
10:46:22 <merijn> repnop: But randomRs doesn't update the IO seed, so getStdGen will keep returning the same value :)
10:46:40 <repnop> merijn: well i'm talking about multiple process runs
10:46:40 <merijn> repnop: So repeated invocations of randomRs with the result of getStdGen will be identical :)
10:47:05 <repnop> if i run via the StateT monad i only get two results...based on the split
10:47:10 <glguy> If you want a split of the current stdgen you can use newStdGen
10:47:22 <repnop> but in IO every run is random
10:48:11 <nshepperd> ah, you use newStdGen to split from the system randomgen
10:48:21 <repnop> well getStdGen has the same result
10:48:43 <repnop> in IO it is random, in runStateT it isn't
10:49:34 <prophile> getStdGen involves unsafePerformIO nonsense
10:49:40 <prophile> so I'm gonna say that's to blame
10:49:43 <prophile> without any evidence
10:49:44 <repnop> ah :/
10:49:47 <prophile> the prosecution rests, your honour
10:49:48 <repnop> i just wonder why
10:50:03 <repnop> because my solution is to just open /dev/urandom instead and not worry for now
10:50:44 <repnop> but i'd actually like to learn why this happens
10:51:31 <glguy> repnop: What's the actual issue? I don't think I saw the top of this
10:51:58 <repnop> glguy: if i use getStdGen for randomRs in main = do the seed is random
10:52:09 <repnop> if i use it in main = runStateT func ...
10:52:16 <repnop> where func uses getStdGen the seed is fixed
10:52:30 <nshepperd> I don't see why getStdGen would need to use unsafePerformIO if it's :: IO StdGen already
10:52:32 <prophile> a test-case would not go amiss I suspect
10:53:08 <prophile> nshepperd: http://hackage.haskell.org/package/random-1.0.1.1/docs/src/System-Random.html#getStdGen
10:53:09 <repnop> so when my main is a StateT monad there are only two results
10:53:09 * hackagebot atomic-primops-foreign 0.6.2 - An atomic counter implemented using the FFI.  http://hackage.haskell.org/package/atomic-primops-foreign-0.6.2 (RyanNewton)
10:53:13 <glguy> repnop: getStdGen just reads the current state of a global variable. That global variable can be updated by anything running in IO that needs random numbers
10:53:45 <repnop> glguy: i'm just wondering why is all
10:53:51 <glguy> repnop: without seeing the code we can only guess at what's accessing the global variable
10:54:14 <nshepperd> ohh, the global random generator reference is magically made
10:54:19 <glguy> You generally shouldn't be using getStdGen
10:54:25 <repnop> i use newStdGen also...
10:54:41 <repnop> mkStdGen just ruins the sim due to the IO added on the function hehe
10:54:45 <repnop> nshepperd: ah yeah?
10:55:12 <repnop> it seemed runghc didn't have the same issue
10:55:35 <repnop> i figured it was a seed issue due to that
10:56:57 <mhyperbolic> I get this complatation error that I don't understand at all.. It's very simple code. Error and source -> http://lpaste.net/109564
10:57:57 <merijn> mhyperbolic: I think it's trying to link the SimpleJSON.o object file after compiling it too
10:58:14 <merijn> mhyperbolic: What happens if you just run "ghc -o simple Main.hs"?
10:58:29 <glguy> mhyperbolic: Are you using those arguments to ghc instead of going via "--make" for a special purpose or because you don't know about "--make"?
10:58:55 <nshepperd> repnop: does the problem go away if you use newStdGen instead of getStdGen?
10:58:56 <merijn> glguy: --make is redundant
10:59:05 <merijn> --make is on by default
10:59:11 <merijn> And has been for years
10:59:15 <mhyperbolic> glguy, The last one. I'm reading Real World Haskell and just doing what it tells me
10:59:35 <merijn> mhyperbolic: DId you try what I wrote?
10:59:47 <mhyperbolic> merijn, That works. I don't need to supply the other object code ?
11:00:04 <glguy> merijn: Well no one told me :)
11:00:06 <merijn> mhyperbolic: GHC automatically sees that Main.hs imports SimpleJSON and compiles it for you
11:00:21 <RumHam> Hey, can anyone explain what is happening here? I'm really new to Haskell. http://codepad.org/YgHrE9Dh
11:00:32 <mhyperbolic> merijn, Ok. Would there be any reason for the book to tell me to do it the other way other than it maybe being outdated ?
11:00:39 <RumHam> why does n stay in scope? Just because of the "where" keyword? What's happening under the hood
11:00:40 <merijn> mhyperbolic: By specifying SimpleJSON.o it was trying to link the compiled version of SimpleJSON twice, hence the "multiple definitions"
11:00:57 <merijn> mhyperbolic: --make wasn't on by default a few years ago, and RWH is already several years old :)
11:01:17 <mhyperbolic> merijn, Ah ok. That makes sense. Thank you very much! :)
11:01:37 <merijn> RumHam: You mean "why can subFunc use argument to testClosure"?
11:02:03 <RumHam> yeah
11:02:08 <enthropy> RumHam: it might be easier to read it as "testClosure n = let subFunc 1 = n in subFunc n"
11:02:15 <merijn> RumHam: Do you know any other languages yet? (like python or JS or Go, because those are the only ones I can give an example in :)
11:02:23 <RumHam> like, I get that it *can* and it's called a closure
11:02:28 <RumHam> I know JavaScript also supports them
11:02:32 <RumHam> but I don't get why it happens
11:02:39 <RumHam> like, under the hood is there a reason?
11:02:43 <RumHam> or is it just built that way?
11:03:00 <RumHam> I assume it's related to currying?
11:03:05 <merijn> RumHam: Define "is there a reason", it's built that way because people think that's useful
11:03:06 <thebnq> mostly convenience
11:03:16 <merijn> RumHam: Not really, it's just a local function declaration
11:03:28 * enthropy thinks it would be unnatural to not have 'n' in scope
11:03:32 <dncr> I'm doing math on many polygons defined as lists of strict tuples of Ratio Integer. They are usually 3-gons or 4-gons but sometimes higher. Are things likely to get faster if I use vector instead of lists?
11:04:15 <RumHam> so is the type of subFunc :: a -> a still?
11:04:19 <RumHam> or is it actually like
11:04:28 <RumHam> :: a -> a -> a
11:04:44 <merijn> RumHam: This is equivalent to the following python: http://lpaste.net/109565
11:05:03 <enthropy> subFunc :: Int -> whateverType'n'has
11:05:22 <enthropy> (is a bit of a lie)
11:05:38 <repnop> nshepperd: it doesn't sadly
11:05:40 <frerich_> merijn: I think you wouldn’t write “then” in Python though.
11:05:55 <merijn> frerich_: oh, right
11:06:01 <merijn> frerich_: I forgot how to python :)
11:06:05 <enthropy> subFunc :: Num a => a -> whateverTypeNHas
11:06:13 <RumHam> is see, so n stays in scope but the type of the sub function isn't changed? I figured it was creating another function under the hood that took two arguments, one of the actual argument and one of the leftover
11:06:15 <merijn> I only do haskell nowadays (and bash, hence the "then") :)
11:06:30 <RumHam> okay, thanks for your help :)
11:06:52 <merijn> RumHam: It just defines two functions "testClosure" and "subFunc" and it just happens to be that "testClosure" calls "subFunc" and returns it's result
11:07:34 <merijn> RumHam: Like I said, if that python code makes sense to you, then your set, because that's exactly what it means in haskell
11:08:00 <desophos> is my intuition correct that "manager" structures are signs of poor design?
11:08:40 <merijn> desophos: yes, no, maybe? :)
11:08:46 <merijn> desophos: What is a "manager" structure?
11:09:21 <sinelaw> Does anyone know of a  database-independent way to read schema info?
11:10:28 <dncr> Is it possible to make a Storable instance for Integer
11:10:29 <desophos> i mean structures that keep track of other structures, handle their interactions, manage their data; like a network object that handles interactions between nodes
11:11:10 <moghedrin> desophos: I would say "It depends".
11:11:11 <glguy> dncr: Storable instances need to have a fixed size, so no
11:11:42 <desophos> my intuition is that structures should handle their own data and interactions should be local/myopic
11:12:11 <repnop> ok so this always returns two results for me. http://lpaste.net/109568 i'm sure there is something obvious i did wrong but i'm fairly new :/
11:12:42 <repnop> i realize mapM isn't efficient there
11:12:53 <desophos> instead of having a (relatively) global structure that can arbitrarily "see" what other structures are doing
11:13:00 <repnop> i just wondering why this program only has two results
11:13:44 <desophos> i use the term "structure" because these could be functions, classes/objects, modules, whatever
11:14:12 <merijn> repnop: You do realise "rng rnd" will always return only 1 value, right?
11:14:20 <kwakashak> why is there a convention to start constructor names with a capital letter? Isn't that inconsistent since types should start with capital, but constructor is a function?
11:14:29 <repnop> merijn: if you have multiple runs of the process?
11:14:37 <Shersh> hello everybody. Could someone tell me why this code :  show "\d"  gives me error with text " lexical error in string/character literal at character 'd' "
11:14:38 <repnop> so the global rng is a fixed seed in haskell?
11:14:44 <merijn> repnop: Oh, hmm
11:14:47 <repnop> i'm talking about running the same app 100 times
11:14:52 <repnop> there are two results
11:15:03 <merijn> lemme check
11:15:11 <repnop> x is based on the split on StdGen
11:16:08 <repnop> arch linux ghc 7.8.3
11:17:15 <merijn> repnop: Is it supposed to never use the values in the [1..100] list when you mapM the tick?
11:17:25 <nshepperd> repnop: you're taking one random value and dividing it into >=50 and <50
11:17:25 <glguy> repnop: It's because you only use a single random number
11:17:33 <glguy> repnop: so you either add 0.0001 100 times
11:17:36 <repnop> merijn: yep...
11:17:39 <glguy> or you subtract it
11:17:43 <dncr> glguy: right. i was thinking about something like unboxed vectors (storing values in a row instead of pointers) of variable sized types but i guess you lose the whole easy-arithmetic addressing thing.
11:17:55 <repnop> ah ok so it only pulled a value once
11:18:13 <kwakashak> why are constructor names start with capital letter??
11:18:15 <repnop> merijn: i just used that as a lazy way to run 100 times
11:18:24 <merijn> repnop: replicateM_ :)
11:18:27 <repnop> ahhh
11:18:28 <merijn> :t replicateM_
11:18:30 <lambdabot> Monad m => Int -> m a -> m ()
11:18:45 <repnop> ok so i needed a bit more reading to fix that issue lol
11:19:00 <merijn> kwakashak: Because the language definition states they must always start with a capital letter
11:19:13 <repnop> so map won't eval again but replicate will
11:19:16 <glguy> repnop: If you want to do it the way you have there you can "zipWith" the random number list with your [1..100]
11:19:23 <kwakashak> merijn: why if its not a type?
11:19:25 <glguy> repnop: rather than only using the head of the list
11:19:39 <repnop> glguy: well the real system uses results from a file
11:19:39 <Shersh> does somebody know why show "\d" fails with error ?
11:19:40 <merijn> glguy: oh, good catch :D
11:19:50 <repnop> but i also test via random results
11:20:14 <nshepperd> repnop: what you probably actually want to do is 'mapM_ runTick (take 100 rnd)'
11:20:15 <merijn> repnop: Actually, isn't the entire thing simply solved by
11:20:30 <merijn> "mapM_ runTick (take 100 rnd)"?
11:20:34 <repnop> merijn: i hope you give me a simple one because in ruby this a joke lol
11:20:40 <repnop> ah yeah same as nshepperd
11:21:04 <desophos> http://programmers.stackexchange.com/questions/129537/can-manager-classes-be-a-sign-of-bad-architecture
11:21:23 <merijn> repnop: Then you actually use a different value of the random list every tick :)
11:21:36 <repnop> so basically my problem was with mapM it only pulls once from (rng rnd) right?
11:21:53 <nshepperd> (rng rnd) doesn't 'pull' anything
11:22:00 <repnop> ok yes
11:22:01 <nshepperd> it's one value, the head of the list
11:22:06 <repnop> rng rnd = result single value
11:22:08 <repnop> yeah
11:22:20 <desophos> i like the 4th answer
11:22:22 <repnop> i thought the current state of the monad was being passed as the monad had to be given to it
11:22:28 <repnop> but live and learn :)
11:22:47 <merijn> repnop: Well, this brings me back to my earlier "implement the State monad" link ;)
11:23:02 <repnop> merijn: yeah i know, i said i didn't want to waste the time but you guys kept asking :)
11:23:12 <repnop> i figured it was something trivial
11:23:18 <repnop> i'm just used to 32GB of state
11:23:54 <statusfailed> I'm trying to translate this post on the operational monad: http://apfelmus.nfshost.com/articles/operational-monad.html to use the Free monad
11:24:11 <statusfailed> I am stuck trying to get a Functor instance for "StackInstruction" (in that link)
11:24:42 <nshepperd> btw for random numbers my go-to hammer is MonadRandom
11:24:43 <statusfailed> definition: data StackInstruction a where; Pop  :: StackInstruction Int; Push :: Int -> StackInstruction ()
11:25:03 <Ralith> nshepperd: I'm a fan of random-fu, myself
11:25:07 <Ralith> it's lots of fun
11:25:12 <statusfailed> random-fu is awesome
11:25:14 <repnop> i guess my next question would be is there was way to actually constantly take one off a Rng source?
11:25:18 <nshepperd> it's nice to be able to getRandom >>= tick instead of messing with randomGens
11:25:29 <Ralith> @hackage random-fu
11:25:29 <lambdabot> http://hackage.haskell.org/package/random-fu
11:25:55 <repnop> as most of my sims run for 100M+ ticks, i don't think i want to take 100M off of a prng
11:26:26 <Ralith> why not?
11:26:58 <statusfailed> repnop: rng source like ... hardware rng?
11:27:08 <statusfailed> or you mean something like /dev/random ?
11:27:21 <repnop> i guess since it is lazy you could just constly take off it right
11:28:01 <statusfailed> repnop: if you go with random-fu it will abstract away handling where the random numbers come from. I suspect MonadRandom does similar?
11:28:15 <statusfailed> repnop: you are thinking of having a huge list of random numbers and then taking some whenever you need them?
11:28:21 <merijn> repnop: You're forgetting something important :)
11:28:37 <Ralith> oh, repnop is still thinking about mapping his tick function over a list of random values
11:28:45 <merijn> repnop: The infinite list that you're taking 100 elements off is lazy
11:28:52 <repnop> yeah i mentioned that laready
11:28:54 <merijn> repnop: They get generated "on-demand" :)
11:28:59 <repnop> i realized it is lazy
11:29:22 <repnop> and that is why i'm working on being better at haskell :)
11:29:26 <nshepperd> huh, looks like random-fu has its own MonadRandom class
11:29:31 <merijn> I think the mapM_ should just run in constant space :)
11:29:39 <bmuk> Are any of you using vagrant/docker in your projects?
11:29:42 <repnop> it should since it discards results
11:30:02 <repnop> though can a function run out of space? i assume so
11:30:25 <merijn> repnop: Yeah, I just had to double check sequence_ (the way mapM_ is implemented) worked the way I expected :)
11:30:28 <repnop> so as long as the function of it halts ...
11:30:40 <nshepperd> you can just map stuff over a lazy list, but won't it be pinned, since it's still in scope?
11:30:48 <merijn> Hell, just try replacing "take 100" with something huge and see what happens
11:31:21 <merijn> nshepperd: GC isn't determined by live references, not scope
11:31:29 <merijn> s/isn't/is
11:31:34 <repnop> yeah my mistake was assuming the state of the prng was getting passed in the StateT Float IO ()
11:31:49 <repnop> right?
11:32:20 <repnop> now if i had mk prng function in my state code this wouldn't happen but then have IO Int to deal with
11:33:38 <repnop> still makes me feel stupid for such an obvious mistake lol
11:35:10 <repnop> but i appriciate the help guys, sorry to waste your time :(
11:37:01 <eevar> repnop: could you explain that last issue you mention in other words?
11:38:14 <merijn> repnop: btw, check out this simplified version :)
11:38:23 <merijn> http://lpaste.net/109572
11:38:51 <merijn> Removed the IO from the State, flipped arguments to newPrice and most code magically disappears :)
11:40:42 <repnop> will take a look in a sec wife is ...
11:40:52 <repnop> but i appricate all the help
11:42:42 <heagle> I would like to change the default behavior for Gen [Int] in quickcheck. I would like it to only make lists of length 6 or less and have all elements modulo 100. Where do I start?
11:43:12 <repnop> merijn: that is quite clean damn
11:44:01 <repnop> now i assume there isn't a better way to keep the state of a binominal model per-leaf right ;)
11:44:21 <repnop> but maybe someone will ask for a donation with that question haha
11:44:22 <sm> neeh: I do, what's up ?
11:44:37 <neeh> oh, hey
11:44:50 <neeh> well, I'm not sure I can say here
11:46:19 <sm> I tend to ignore random PMs unless they mention one of my projects, but I saw you're on #haskell
11:47:58 <neeh> oh, nevermind
11:48:00 <neeh> sorry
11:50:14 <repnop> merijn++
11:50:32 <repnop> thanks again you really helped me think differently about that situation
11:51:12 <repnop> and nshepperd, statusfailed, glguy
11:54:55 <stalintrotsky> is it bad form to mix applicative and monadic operators in the same definition?
11:55:53 <Ixcar3000> does anyone know why show "\d" gives me an error?
11:56:15 <shachaf> Whatever is giving you the error probably knows.
11:56:22 <heagle> you need to escape the \?
11:56:38 <Ixcar3000> show "\a" works perfectly
11:56:41 <cschneid> Ixcar3000: because \ indicates that you are starting an escape character (ie, a tab is \t), but d is not a valid escape char
11:56:49 <geekosaur> what is \d supposed to be?
11:57:03 <Ixcar3000> i want to parse string char by char
11:57:03 <geekosaur> I know it as a perl / pcre thing, not as a character escape
11:57:19 <Ixcar3000> and in fails when there is \d
11:57:32 <Ixcar3000> but \a, \b and other works fine
11:57:37 <heagle> whoa
11:57:46 <geekosaur> as for why \a does one thing and \d another, there's no Haskell escape starting with a
11:57:52 <geekosaur> but there are several starting with d
11:58:03 <Ixcar3000> how can i fix this?
11:58:06 <geekosaur> hm, no, maybe that's reversed
11:58:14 <geekosaur> so you want to change haskell's character syntax?
11:58:23 <geekosaur> (the problem is not in show, it is in parsing your literal string)
11:58:24 <cschneid> http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html -- see the table on that page.
11:58:54 <cschneid> those are the only valid characters that can occur right after a backslash in a literal string.  Note that if you want a literal backslash, you type it twice ("\\d" is probably what you're looking for)
11:59:10 <cschneid> Ixcar3000: for instance, here's a snippet of ghci - https://gist.github.com/cschneid/8d5d4b321e3ba1ea3075
11:59:16 <Ixcar3000> i cant type double backslash
11:59:21 <Ixcar3000> it is in input
11:59:28 <Ixcar3000> so i can modify the string
11:59:29 <geekosaur> er
11:59:41 <geekosaur> if it's in input then it should not be being modified at all
11:59:48 <geekosaur> please show your actual code and actual input
12:00:06 <cschneid> Ixcar3000: can you paste us a snippet of code to give us an idea of what's up? That's odd that its trying to escape stuff on user input
12:00:07 <geekosaur> also the actual error
12:00:15 <Ixcar3000> well, how to get ['\\', 'd'] from "\d" ?
12:00:45 <Ixcar3000> error: lexical error in string/character literal at character 'd'
12:01:31 <heagle`> doing it this way works fine: '\\':'d':[]
12:01:34 <geekosaur> please show actual code and actual input and actual error.
12:01:42 <geekosaur> pyanfar:10006 Z$ echo '\d' | ghc -e 'getLine >>= mapM_ print'
12:01:42 <geekosaur> '\\'
12:01:42 <geekosaur> 'd'
12:02:06 <cschneid> > head "\\d"
12:02:07 <geekosaur> seems to be doing the right thing. please note the difference between character or string literals and input from a file
12:02:07 <lambdabot>  '\\'
12:02:25 <geekosaur> (and that this difference is not Haskell specific)
12:02:26 <Ixcar3000> head "\d"
12:02:40 <cschneid> > head "\d"
12:02:42 <lambdabot>  <hint>:1:8:
12:02:42 <lambdabot>      lexical error in string/character literal at character 'd'
12:03:11 <cschneid> Ixcar3000: so backslash is an escape character in haskell strings.  So it looks to the next character to figure out what to do.  'd' is not a valid escape rule, so it's an error.
12:03:45 <cschneid> Ixcar3000: so to get around it, "\\" is a single literal backslash character. "The next char is an escape rule", "The rule is to have a literal backslash"
12:04:30 <Ixcar3000> thanks everybody!)
12:04:36 <cschneid> Ixcar3000: this only applies to strings in your source code, not the user's input.  Check out what geekosaur pasted where "\d" was passed in from outside the program.
12:04:39 <heagle> (which is what I suggested way back at the start of this). It *is* strange how "\a" (escape for alert) works but "\d" does not.
12:04:56 <cschneid> heagle: why? \a is a valid escape, \d is not.
12:06:37 <heagle> cschneid: right, makes sense now that I did head "\t" and got '\t' :)
12:07:06 <heagle> same for "\a". Thus not that strange at all.
12:11:18 <dreams> Are thunks allocated in the heap?
12:13:32 <johnw> dreams: why do you ask?
12:14:01 <dreams> johnw: curiosity
12:14:07 <johnw> i would think they'd have to be
12:14:20 <dreams> johnw: you're right. Just read it in a paper.
12:14:40 <`Jake`> When I use cabal update, it tells me that there is a new version of cabal-install available, but if I run cabal install cabal-install and then try cabal update again, it still tells me that there is a new version available. cabal --version returns 1.18.0.5. Should I worry about that?
12:15:00 <johnw> `Jake`: if you just installed cabal-install, you should be using 1.20.something
12:15:31 <`Jake`> I thought so. The --version request was after I installed it, though
12:15:43 <johnw> so where did the new binary go I wonder?
12:16:11 <dcoutts_> `Jake`: it'll simply be that the one on your $PATH is the older one
12:16:23 <`Jake`> one second
12:16:25 <dcoutts_> the new one will have been installed to ~/.cabal/bin
12:16:35 <dcoutts_> which is either not in your $PATH, or later in your $PATH
12:16:56 <`Jake`> Ah, yeah, home directory .cabal/bin instead of /usr/local
12:17:01 <`Jake`> in my $PATH
12:17:05 <`Jake`> thanks
12:17:51 <dcoutts_> `Jake`: these paths (and the option to symlink) are controllable from ~/.cabal/config
12:18:02 <`Jake`> Ah, thanks
12:23:27 <phaazon> @hoogle f a -> a
12:23:30 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
12:23:30 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
12:23:30 <lambdabot> Data.Monoid getDual :: Dual a -> a
12:24:31 <JohnTalent> how does one get source code from within the interpreter?
12:24:34 <`Jake`> Wait, if only my home directory was in my path, shouldn't `which cabal' return the version from my home directory? I'm asking because it returned the version from /usr/local/bin/cabal
12:24:53 <`Jake`> Oh, nevermind
12:25:08 <`Jake`> it's the version from /usr/local/bin, not /usr/local/bin/cabal
12:25:42 <JohnTalent> well?
12:27:03 <`Jake`> JohnTalent: Do you mean something like this for ghci?
12:27:06 <`Jake`> @src product
12:27:06 <lambdabot> product = foldl (*) 1
12:27:49 <c_wraith> JohnTalent: There's no guarantee the source is anywhere on your system for code ghci can use.
12:28:18 <c_wraith> JohnTalent: as such, finding source is not a tool it has built in.
12:29:21 <cschneid> > getProduct . mconcat $ map Product [1..9]
12:29:22 <lambdabot>  362880
12:29:47 <c_wraith> JohnTalent: to be as clear as possible: ghci is fully capable of loading compiled object code, and in fact prefers to do so when it has the option to go either way.
12:31:00 <JohnTalent> c_wraith: okay. so you answered my question.
12:31:08 <JohnTalent> i wanted to peek at system function.
12:31:10 <JohnTalent> s
12:31:18 <`Jake`> Which function?
12:31:34 <`Jake`> Well
12:31:41 <`Jake`> You can always look at the source code in hackage
12:32:10 <JohnTalent> `Jake`: yes
12:32:23 <JohnTalent> foldl
12:32:42 <`Jake`> If you do :i foldl in ghci, it will tell you where the function was defined
12:32:54 <JohnTalent> i'm also having a terrible time entering a new foldl'
12:33:03 <JohnTalent> `Jake`: ok,thanks.
12:33:35 <c_wraith> JohnTalent: it's often easiest to add new definitions in a standalone file, and load that into ghci.  This is because multiline stuff is awkward in ghci. (possible, but awkward)
12:34:06 <JohnTalent> c_wraith: yeah, it appears that way.
12:34:30 <`Jake`> (Once you know where a function was defined, you can search for the module in google, and just click on a link to hackage. Then you'll either already be in the source file or there'll be a source button in the top right corner)
12:36:48 <JohnTalent> makes more sense to have it in the ghci.
12:37:25 <NemesisD> has anyone in here had success using haskell-mode with cabal sandbox'd projects?
12:38:53 <c_wraith> JohnTalent: it's a super-hard problem, because it's 99% social. ghci is just sticking with the technical issues of running a haskell REPL
12:40:05 <JohnTalent> add an S to that and you have a deal! (REPLS)
12:41:34 <mmasters_> hello :)
12:42:08 <falafist> What are the downsides of using lenses? Do they lead to non-idiomatic code?
12:42:11 <mmasters_> a friend of mine was telling about Haskell and how this exists: https://hackage.haskell.org/package/lens
12:42:34 <c_wraith> falafist: they make some very straight-forward things a little less direct - but they make many complex things much simpler.
12:42:57 <falafist> c_wraith: could it be that those complex things are so complex because of poor design choices?
12:43:29 <mmasters_> he was telling me about how this functionality doesn't exist in erlang, I figured it could have the same feature because they are both purely functional. Am I not thinking about it correctly?
12:43:58 <bennofs> NemesisD: You can tell haskell-mode to use cabal repl -> sandbox support for free!
12:44:00 <falafist> mmasters_: its a utility library it provides no new functionality
12:44:31 <c_wraith> falafist: Not often.  Say you have a tree of JSON values from the aeson library, and want to modify some things buried deep inside.  This is a hard problem with functional updates and strong types.  But lenses make it pretty easy.
12:44:39 <mmasters_> falafist : what does it do? I'm not very familiar with haskell
12:44:40 <geekosaur> on the one hand, what falafist said. on the other hand, expressibility is a thing as well
12:44:56 <c_wraith> mmasters_: the mechanisms used in that library depend on type-directed polymorphism that erlang has no match for.
12:44:56 <falafist> ah thats a good point c_wraith
12:44:57 <NemesisD> bennofs: do tell how! i'm having a problem right now where any time i bring up interactive mode it says it can't find the executable GHC
12:45:08 <`Jake`> searching for erlang lens in haskell returns a few results
12:45:13 <`Jake`> in google, sorry
12:45:18 <geekosaur> haskell and erlang are both turing equivalent, so you can do the same things in either. or in other turning equivalent languages such as C++, for that matter.
12:45:21 <`Jake`> not in haskell -.-
12:45:26 <geekosaur> how *easily* you can do them is always a question
12:45:29 <c_wraith> mmasters_: but there are other mechanisms for encoding the basic ideas.
12:45:31 <bennofs> NemesisD: oh, do you mean the REPL or ghc-mod?
12:45:55 <NemesisD> bennofs: when i run haskell-interactive-bring (C-`)
12:46:12 <falafist> has anybody used influxdb with haskell?
12:46:15 <bennofs> NemesisD: M-x customize-variable haskell-process-type
12:46:26 <bennofs> NemesisD: set to cabal repl
12:46:46 <NemesisD> bennofs: currently its 'cabal-repl
12:46:59 <bennofs> NemesisD: :(
12:47:06 <tomejaguar> Does `reversed :: Ordering -> Ordering` exist, so I can do `sortBy (reversed (comparing snd)) ...`?
12:47:15 <bennofs> NemesisD: idk then
12:47:37 <S11001001> @hoogle Ordering -> Ordering
12:47:40 <lambdabot> Language.Haskell.TH.Syntax thenCmp :: Ordering -> Ordering -> Ordering
12:47:40 <lambdabot> Prelude id :: a -> a
12:47:40 <lambdabot> Data.Function id :: a -> a
12:47:54 <tomejaguar> Yeah hoogle seems to say no.
12:48:00 <tomejaguar> Which is odd, because it seems like an obvious thing to want.
12:48:04 <NemesisD> bennofs: the issue is: cabal: The program 'ghc' version >= 6.4 is required but it could not be found. Couldn't reinstall some add-source dependencies. Some add-source dependencies have been reinstalled. etc
12:48:15 <geekosaur> that seems the wrong way to do it? just swap the order of the parameters to be compared
12:48:20 <geekosaur> which is
12:48:22 * hackagebot pretty 1.1.1.2 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.1.2 (DavidTerei)
12:48:23 <geekosaur> :t flip
12:48:24 <lambdabot> (a -> b -> c) -> b -> a -> c
12:48:35 <NemesisD> i don't know why. cabal is definitely in both my emacs (findable with executable-find) and and regular $PATH
12:48:40 <S11001001> tomejaguar: you could coerce to [Down x] where your list is [x]
12:48:45 <bennofs> NemesisD: but is ghc in your emacs?
12:49:09 <NemesisD> bennofs: i believe so but how do i find out again?
12:49:19 <`Jake`> > sortBy (flip comparing snd) $ map ('a',) [1..10]
12:49:20 <bennofs> NemesisD: well you said executable-find?
12:49:21 <lambdabot>  Couldn't match type ‘(a, b) -> b’ with ‘(a, b)’
12:49:21 <lambdabot>  Expected type: (((a, b) -> b) -> b)
12:49:21 <lambdabot>                 -> ((a, b) -> b) -> (((a, b) -> b) -> b) -> GHC.Types.Ordering
12:49:21 <lambdabot>    Actual type: (((a, b) -> b) -> b)
12:49:21 <lambdabot>                 -> ((a, b) -> b) -> ((a, b) -> b) -> GHC.Types.OrderingCouldn...
12:49:21 <tomejaguar> geekosaur: Yeah but then I have to do it directly to compare, which is a lower level operation.
12:49:23 <S11001001> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Ord.html#t:Down
12:50:34 <geekosaur> :t flip (comparing snd)
12:50:35 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
12:50:50 <geekosaur> :t comparing snd
12:50:52 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
12:51:04 <tomejaguar> geekosaur: Oh sorry, I'm clearly being stupid.
12:51:47 <tomejaguar> Yes, that's what I wanted, thanks!
12:51:49 <c_wraith> falafist: I would say that the best description of the lens package is that it uses a lot of high-powered theoretical machinery (and developed some of it in the first place) to make things that should be easy actually be as easy as they should be - while also relying on rigorous mathematical foundations instead of being an ad-hoc formulation.
12:52:14 <NemesisD> bennofs: it returns "/opt/ghc/7.8.2/bin/ghc"
12:52:18 <falafist> ah ok c_wraith
12:52:45 <c_wraith> falafist: And that's something that's shown up over and over again in haskell libraries - things based on rigorous math really tend to hold up well over the long term.
12:55:55 <bernalex> is there a function that does length . filter but uh fast?
12:56:28 <JohnTalent> does ghc.list.foldl run out of stack space much? looking at the source, it doens't use seq.
12:56:36 <NemesisD> bernalex: you may need a different data structure
12:56:37 <geekosaur> bernalex, perhaps you want a fold?
12:56:56 <wto> JohnTalent: have a look at foldl'
12:57:08 <bernalex> like f g (x : xs) | g x == True = 1 + f g xs; g x == False = f g xs
12:57:37 <bergmark> JohnTalent: http://www.well-typed.com/blog/90/
12:58:22 * hackagebot ihaskell 0.4.2.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.4.2.0 (gibiansky)
12:58:49 <JohnTalent> bergmark: ha! thanks for that.
12:58:51 <bergmark> bernalex: is it slow? doesn't it fuse?
12:58:58 <bernalex> bergmark: does it?
12:59:06 <JohnTalent> haskell documentation is much better than it was 12 years ago.
12:59:51 <tomejaguar> bernalex: Are you sure that's fast?  It leaks space.
12:59:58 <bergmark> bernalex: i don't know, but if you're worried check the generated core
13:00:03 <bernalex> tomejaguar: I'm not.
13:00:30 <godel> hello, can someone help me with this error http://lpaste.net/2348721454436057088 ? It is very strange
13:00:57 <bergmark> godel: the were is outside the do block
13:01:05 <bergmark> where*
13:01:09 <godel> and why is that?
13:01:17 <godel> I supposed that was the problem
13:01:27 <godel> but checked indentation and it was ok
13:01:35 <geekosaur> it's more difficult than that
13:01:42 <geekosaur> where scopes to a set of top level declarations
13:01:51 <bergmark> godel: because of
13:01:52 <geekosaur> the do does not
13:01:53 <bergmark> > do { x <- return 1; x <- return 2; print x }
13:01:56 <lambdabot>  <IO ()>
13:02:13 <godel> and how can I do this?
13:02:21 <geekosaur> use let inside the do
13:02:27 <godel> ahh ok
13:02:28 <godel> thanks
13:03:03 <bergmark> geekosaur: where doesn't just scope to top level declarations
13:03:30 <geekosaur> no, but in this case I think that's the relevant one because there's nothing else to scope to
13:04:33 <geekosaur> still, where is ... tricky. it'd be nice if lambdabot had something to desugar binding groups, where, etc. --- maybe input on lpaste and output as an annotation thereto. (or built into lpaste, maybe)
13:04:49 <frerich_> Is there a way to adjust the template generarted by ‘cabal init’? I’d like to have ‘ghc-options: -Wall’ included by default.
13:04:54 <geekosaur> it's easier to see whats going on when you see what it looks like to the compiler
13:05:02 <bergmark> godel: you can also keep the where and add arguments to the declarations
13:05:12 <mutable> hello. I just installed ghc 7.8.3. And reinstall all cabal packages of my projects. I noticed the compile time is much longer than ghc 7.6. Is it expected?
13:05:14 <godel> how? bergmark
13:05:43 <hask54> Why does      contents <- readFile "file.txt"    work fine if the file only contains plain ASCII characters     but FAILS (Error: "hGetContents: invalid argument (invalid byte sequence)")      if the file contains some unicode characters?
13:05:48 <bergmark> godel: do { x <- foo; y x } where y x = x
13:06:00 <hask54> It's on my Ubuntu 12.04 machine. On the other hand things work great on my local OS X machine
13:06:03 <geekosaur> hask54: your locale is set incorrectly?
13:06:13 <godel> oh, I see
13:06:30 <hask54> geekosaur: not sure, maybe..
13:06:40 <geekosaur> if you have a Unicode locale it should accept Unicode. otherwise it tries to apply a conversion from the specified locale, falling back to iso8859-1
13:07:39 <hask54> geekosaur: that's what I see when I type "locale" https://pastee.org/4rf8c
13:07:42 <hask54> utf8 almost everywhere
13:08:30 <geekosaur> except for those warnings, which are the locale library not understanding those settings
13:08:36 <geekosaur> and ghc won't understand them either
13:09:15 <geekosaur> "en_US.UTF-8" is a fine locale. "UTF-8" is not. LC_ALL is unset, so ghc would use iso8859-1
13:11:39 <cow_2001> this is so weird. https://mail.python.org/pipermail/python-ideas/2014-August/028618.html
13:12:51 <subleq> cow_2001: i'm a python programmer. at least people have started to realize that runtime type assertions is not static typing
13:14:06 <hask54> geekosaur: thanks i googled how to fix this. thanks
13:15:44 <vanila> what do peolpe like about python?
13:15:47 <cow_2001> subleq: Guido Van Russom: "Proposal: Use Haskell" :p
13:16:13 <gfixler> vanila: it's really fast to learn and do things with
13:16:28 <vanila> gfixler, that's cool
13:16:37 <vanila> I can get behind that
13:16:48 <gfixler> almost no syntax
13:17:03 <dncr> In ghc 7.6.3, I'm compiling with "ghc -isrc -outputdir build -o Main -prof -auto-all -caf-all -O3 -fforce-recomp --make Main" and then after "./Main +RTS -prof" Main.prof has been created but is an empty 0-byte file. What's going on?
13:17:16 <gfixler> it has a lot of nice sugars, like list and dict comprehensions
13:17:52 <geekosaur> dncr: how are you exiting the program?
13:17:58 <cow_2001> i love python, but i also hate it, kinda
13:18:06 <geekosaur> control-C or an exception will leave you with no profiling output
13:18:15 <dncr> geekosaur: Alt+F4. It's a gloss program.
13:18:42 <frerich_> Does anybody know whether it’s possible to build criterion in a cabal sandbox? I did something like that for other tools (e.g. ‘cabal sandbox init && cabal install hlint’) and even though doing so didn’t yield any errors with criterion, I just can’t find a binary anywhere :-}
13:18:59 <geekosaur> hm. I don't know how gloss works on windows, if it's throwing an exception to deal with the close event then you won't get profiling output
13:19:00 <vanila> <gfixler> almost no syntax
13:19:15 <dncr> geekosaur: I'm on Ubuntu.
13:19:16 <vanila> I feel like t has a lot of weird syntax, but i come from scheme
13:19:20 <geekosaur> odd, then
13:19:22 <pseudolio> "Use Haskell" is a good suggestion. That way you can discuss it here.
13:19:26 <gfixler> vanila: scheme has even less syntax :)
13:19:51 <gfixler> vanila: in other languages you might do for (i=0; i<10; i++) { etc; }
13:19:55 <geekosaur> I would not expect an exception. but, again I don't really know gloss. might need to look up the maintainer on hackage and ask
13:20:02 <dncr> mm
13:20:03 <dcoutts_> frerich_: criterion is a library, not an exe
13:20:05 <gfixler> idiomatic python would be for i in range(10):
13:20:06 <hask54> I have a basic question. Please look at this: https://pastee.org/j46ts  This is a simple web app in Haskell. I launch the app only once. After that it can accept web requests. I know that readFile will only be read laziliy when it launches, so it won't actually be read at all.
13:20:07 <hask54> My question is: Will the file be read every time over again for each web request, or will it be read only once on the first request and then stored forever in memory for quick access for later web requests?
13:20:32 <vanila> gfixler, I see!
13:20:37 <arianvp> what's the difference between `mtl` and `transformers` ?
13:20:42 <arianvp> one seems to depend on the other
13:20:48 <frerich_> dcoutts_: argghh, sorry, of course - I remember reading that but for some obscure reason then went to install it thinking that “Soon, I can do ‘criterion mytest’” :-{
13:21:12 <geekosaur> arianvp: mtl provides a backward compatible interface, mostly.
13:22:05 <geekosaur> originally there was mtl1, based on functional dependencies. then there was some experimentation with type families, leading to monads-fd and monads-tf with transformers sitting on top.
13:22:35 <ChristianS> geekosaur: so for new code, transformers is recommended over mtl?
13:22:42 <pseudolio> mtl provides a significant amount of functionality that transformers does not.
13:22:54 <geekosaur> no, mtl is recommended
13:23:02 <geekosaur> transformers was a minimal implementation
13:23:13 <ChristianS> ah
13:23:23 <geekosaur> mtl2 was redone on top of transformers
13:24:31 <geekosaur> (mtl1 did a lot of things kinda poorly because it was old and ancient ghc had limitations. transformers helped not only to test fundeps vs. type families but also newer implementations of things. the result became mtl2)
13:25:04 <geekosaur> it might be more accurate to say that mtl2 is the modern monads-fd, which sits on top of transformers
13:25:11 <geekosaur> as did monads-tf which turned out to be a dead end
13:25:20 <hask54> Noone?
13:26:14 <Philippa> hask54: indexContents will get read through once
13:26:23 <bergmark> hask54: it will be read once, you are using indexContents on every request and that has type String
13:27:02 <bergmark> if it was IO String it would be read on every request
13:27:45 <hask54> Philippa, bergmark: but how does haskell know it will need that variable?
13:27:47 <hask54> in the future
13:30:06 <bergmark> hask54: read up on lexical closures in SICP for instance
13:30:37 <pseudolio> How does any language with garbage collection know what not to garbage collect?
13:30:44 <hask54> ok hehe
13:31:08 <hask54> Ok so my final question today
13:31:15 <hask54> I have a web app that I can run
13:31:18 <shachaf> whoa, it's Philippa
13:31:22 <pantsman_> readFile uses lazy IO, it won't actually load the contents until needed
13:31:28 <hask54> How do I keep it alive, so if it crashes it will auto-launch again?
13:31:34 <hask54> and launch in the background too
13:31:46 <arianvp> heh haskell programs dont crash
13:31:50 <arianvp> no. just kidding
13:33:40 <hexagoxel> frerich_: fyi: i have a little bash script with the purpose of installing executables using sandboxes, at https://github.com/lspitzner/cabal-exec-install
13:34:06 <pantsman_> hask54, what OS are you running?
13:34:16 <hask54> pantsman_: it's for my ubuntu 12.04 server
13:34:21 <pantsman_> try Upstart, then
13:34:48 <hask54> ok
13:35:34 <quchen> geekosaur: Why is monads-tf a dead end? What did it promise?
13:35:58 <quchen> geekosaur: I thought it avoided the fundep, which allowed more flexibility
13:36:31 <geekosaur> my understanding is that it was originally believed that type families could do everything fundeps could
13:36:52 <geekosaur> experience demonstrated otherwise, there are things that either cannot be done or are much less efficient
13:37:16 <geekosaur> but type families have their own advantages for some other uses (see for example closed type families)
13:37:37 <pseudolio> I don't think there's anything in mtl that wouldn't be better with type families, except that the types are more annoying to write with families.
13:37:37 <quchen> But monads-tf doesn't use closed families, does it?
13:37:44 <geekosaur> no
13:37:57 <pseudolio> And tons of stuff already uses mtl, and not monads-tf.
13:38:02 <geekosaur> that was a later direction, after the idea of replacing fundeps with type families was discarded
13:38:38 <quchen> pseudolio: Unfortunately, some popular packages seem to depend on monads-tf, yielding ambiguity errors every time you import .Trans
13:39:03 <geekosaur> I vaguely recall an Oleg post demonstrating a case that worked with fundeps but not with ghc's type families implementation *and* showed that making type families work there had some serious problems,
13:39:23 <pseudolio> I don't think Oleg stuff is a good argument.
13:39:33 <geekosaur> (like it turned out to be a backdoor for incoherent instances)
13:41:01 <pseudolio> And it has little to do with the stuff in mtl.
13:42:04 <geekosaur> it may not have been Oleg. point was that there was a case that couldn't be done with type families retaining type safety
13:42:05 <btcNeverSleeps> hey all... I've got a "missing -B<dir> option" when I try to run ghc from the command line (from Emacs things seems ok). Apparently it's because my PATH is incorrect and I try to run ghc directly from /usr/local/opt/ghc-7.8.3....min/lib/ghc-7.8.3/bin (I actually do).
13:42:43 <btcNeverSleeps> it's explained here: https://groups.google.com/forum/#!msg/haskell-cafe/YEZfdXFyEJY/yzM_a1pyaj4J
13:43:00 <geekosaur> btcNeverSleeps, yes, don't run that directly. there should be a wrapper script somewhere in a normal $PATH location which calls it with the right -B options; this is done so that the binary ghc distribution can be relocatable
13:43:20 <btcNeverSleeps> great... Now I can move forward: what are those "wrappers" and how do I install them?
13:43:26 * hackagebot pcre-light 0.4.0.3 - A small, efficient and portable regex library for Perl 5 compatible regular expressions  http://hackage.haskell.org/package/pcre-light-0.4.0.3 (DanielDiaz)
13:43:58 <geekosaur> they should have been installed automatically. the default if you did not install with a --prefix would be /usr/local/bin
13:45:48 <spanglish> I've discovered a possible but in template haskell. I'm curious if anyone else has encountered this.
13:45:51 <pseudolio> What you can do with fundeps but not families is write overlapping instances that are open.
13:46:08 <spanglish> I have a function: methodSig :: Name -> Q Exp
13:46:09 <btcNeverSleeps> geekosaur: oooh, gotcha... I have one in /usr/bin/ghc and *another* one in /usr/local/bin.  The one in /usr/bin/ghc is an older version (installed by a Debian package I think)
13:46:22 <geekosaur> yes, that would make sense
13:46:29 <spanglish> this implementation should work in theory:  methodSig name = [| allToJsApi (Proxy :: Proxy $(name)) |]
13:46:37 <geekosaur> so remove the debian package if you want to use the newer one
13:47:04 <pseudolio> Which means in some places you'll have an instance C X Y where X determines Y, and in others you'll have C X Z where X determines Z.
13:47:22 <spanglish> However, this implementation compiles:  methodSig name =  let t = appT (conT ''Proxy) (conT name) in [| allToJsApi (Proxy :: $(t)) |]
13:47:51 <pseudolio> And fundeps work in an odd way that, despite this being a functional dependency, you can never observe that Y is supposed to be the same as Z.
13:48:04 <spanglish> GHC is complaining with:
13:48:05 <spanglish>     Couldn't match kind `*' against `* -> * -> *'
13:48:05 <spanglish>     Kind incompatibility when matching types:
13:48:05 <spanglish>       t0 :: *
13:48:05 <spanglish>       a0 :: * -> * -> *
13:48:05 <spanglish>     In the first argument of `allToJsApi', namely `(Proxy :: Proxy $t)'
13:48:07 <spanglish>     In the Template Haskell quotation
13:48:09 <spanglish>       [| allToJsApi (Proxy :: Proxy $t) |]
13:48:36 <pseudolio> And you can exploit that implementation detail to do some stuff.
13:49:36 <pseudolio> But it's a difficult argument to make that this would be good practice.
13:49:52 <pseudolio> And, of course, mtl doesn't do anything like that.
13:53:26 <sinelaw> anybody know of a database-independent schema reader? (e.g. get all tables, columns, etc.)
13:54:19 <sinelaw> hmmm hsql may work...
14:03:17 <DanielDiaz> ok
14:05:30 <johnw> question for anyone familiar with the singletons library: Is there a better way to write this type signature?  head :: ((n :> 0) ~ 'True) => Vector n (x ': xs) -> x
14:05:36 <johnw> (ignoring the fact that in this case, the predicate on nats is not needed)
14:05:40 <johnw> imagine I had said n :> 10, so that I only want to take the head of lists larger than 10 elements
14:27:19 <Janiczek> hi, I'm having trouble with cabal install arithmoi: error: invalid preprocessing directive #-} ... ghc 7.4.1, cabal-install 0.14.0, cabal library 1.14.0
14:27:25 <Janiczek> what to do?
14:29:10 <bennofs> Janiczek: what OS?
14:29:18 <Janiczek> OSX 10.10
14:29:29 <quchen> Janiczek: Your compiler is over two years old, I suggest an upgrade.
14:29:40 <Janiczek> which means clang, or gcc?
14:29:50 <quchen> GHC.
14:29:57 <Janiczek> oh!
14:30:15 <Janiczek> I sort of assumed I had homebrew version. Guess not.
14:30:38 <bennofs> I think the haskell platform for Mac includes patches to make it work nicely with clang
14:30:45 <bennofs> @where hp
14:30:45 <lambdabot> http://hackage.haskell.org/platform/
14:33:32 * hackagebot simple-pipe 0.0.0.14 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.14 (YoshikuniJujo)
14:33:44 <merijn> Janiczek: You can't use 7.4 on OSX 10.10
14:33:55 <merijn> You need to have 7.8
14:34:02 <merijn> Better yet, just install haskell platform
14:34:21 <merijn> Janiczek: Homebrew for GHC is unmaintained
14:34:32 <Janiczek> Installing the platform
14:34:51 <merijn> I recommend installing platform and/or manually installing GHC (depending on how bleeding edge you want to be :))
14:35:00 <bergmark> why doesn't it work on 10.10? it works on 10.9 O_o
14:35:26 <merijn> bergmark: What? 7.4 doesn't work on 10.9 either
14:35:45 <bergmark> but but i've been testing with it :-)
14:35:47 <merijn> Unless you manually patched a whole bunch of stuff
14:35:56 <bergmark> i patched on line :-)
14:36:03 <bergmark> one*
14:43:33 * hackagebot xml-pipe 0.0.0.9 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.9 (YoshikuniJujo)
14:48:08 <byorgey> anyone else having trouble with a corrupt 00-index.tar.gz from Hackage?
14:49:03 <byorgey> when I 'cabal update' it crashes with "premature end of compressed stream", and when I try running gunzip on the 00-index.tar.gz it downloaded, I get "unexpected end of file"
14:50:51 <glguy> byorgey: how big is the 00-index.tar.gz you've downloaded and what kind of file does file(1) report it as?
14:51:14 <glguy> I just checked and was able to cabal update here and not get a corrupted index
14:51:47 <dcoutts_> byorgey: sounds like two error messages for the same thing, ie a truncated download
14:51:50 <byorgey> ah, hmm, file(1) reports gzip compressed data, but it's only 4096 bytes
14:52:03 <glguy> Should be closer to 5922869 bytes
14:52:18 <byorgey> indeed, 4096 bytes seems on the small side
14:52:22 <quchen> I just ran `cabal update` and it worked
14:52:27 <byorgey> any ideas what could cause this?
14:52:42 <glguy> Your local network admin doing something clever with your HTTP traffic?
14:52:51 <byorgey> I have cabal-install-1.20.0.3, built with Cabal-1.20.0.2
14:53:00 <glguy> same
14:53:03 <glguy> which os?
14:53:03 <byorgey> glguy: possible.
14:53:10 <byorgey> Ubuntu
14:54:39 <byorgey> I get different lengths every time I try, all far too short: 8192 bytes, 12296, ...
14:55:25 <byorgey> sigh.  Is there a way to do a "manual" update?
14:56:18 <quchen> Uhmm I could upload my file for you
14:56:26 <quchen> Or send it via IRC if that works
14:56:34 <quchen> I assume it's portable?
14:59:27 <byorgey> never mine, I can get the .tar.gz myself using wget, and I just stuck it in .cabal/packages/hackage.etc  (and unzipped it) and that seems to work
14:59:30 <byorgey> *mind
14:59:53 <byorgey> I wasn't sure if that was all that was required
15:02:09 <dcoutts_> byorgey: is/was it still failing with cabal update?
15:02:38 <dcoutts_> cabal update -v3 might give some hints
15:03:23 <byorgey> dcoutts_: yes, cabal update still fails even after I manually downloaded 00-index.tar.gz
15:03:59 <dcoutts_> well it'd overwrite the file you downloaded manually
15:04:04 <byorgey> right
15:04:21 <dcoutts_> would be good to work out why it's failing for you
15:06:30 <byorgey> dcoutts_: here's the output from cabal update -v3: http://lpaste.net/109589
15:06:46 <byorgey> I've got to run, but will read the scrollback later
15:08:19 <finishingmove> I'm trying to install GHC 7.8.3 on Ubuntu 14.04 and `sudo make install` is failing for me because of some missing files in /usr/local/haskell. Does anyone know what should usually be there?
15:08:21 <dcoutts_> byorgey: mm, nothing revealing. I guess that's not so surprising, since it's a truncation problem, so the headers don't tell us all that much.
15:21:01 <burp> missing files in /usr/local/haskell? o_O
15:21:18 <burp> on make install? that doesn't make sense to me :)
15:21:30 <burp> oh, someone impatient
15:26:05 <meoblast001> codile: digga :D
15:38:57 <athan> What situations call for StandaloneDeriving? Is it necessary when you use DataKinds or GADTs?
15:39:58 <nitrix> I'm not even good with Haskell and I already seen flaws in every languages I worked with before since I've been those tutorials.
15:40:14 <nitrix> ^ Er, that english there.
15:40:32 <vanila> nitrix, what flaws?
15:40:34 <vanila> oh
15:40:39 <vanila> you mean flaws in those languages not in haskell?
15:40:48 <vanila> yeah that's the worst thing about learning nice programming languages
15:40:52 <vanila> everything else becomes terrible
15:41:04 <nitrix> vanila: Mhm. I used to swear by C for many things and now, even on my own projects, I'm a little scared.
15:41:15 <nitrix> I'm concerned about putting correctness in the hands of the programmer.
15:43:18 <vanila> I think that you could improve C a lot with ideas from haskell without reducing its (already small) scope much further
15:44:39 <vanila> but there's a lot of things (main example: array bounds) that require seriously difficult work beyond what haskell can do
15:48:38 * hackagebot spice 0.1.0.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.1.0.0 (Crockeo)
15:48:43 <comerijn> vanila: That's called Rust ;)
15:48:52 <vanila> yeah gotta study rust
15:49:07 <vanila> I had hoped Go would be this, studied it for a bit and was very disappointed
15:50:27 <comerijn> athan: StandaloneDeriving is nice for when you need a Typeable instance but the library you're using doesn't derive it
15:50:38 <comerijn> athan: Since it's no longer to write manual Typeable instances
15:51:00 <merijn> athan: In general it's a nice way to get instances when the author forgot to derive/implement them
15:51:46 <merijn> athan: Go is good in the sense that is is considerably less awful than C and if I ever need to do money-oriented programming I'd rather write Go than C :p
15:51:49 <merijn> errr
15:51:50 <athan> merijn: Hmm, okay. But can't we use simply `deriving(Typeable, Data...)` already, with the (specific) language extension?
15:51:52 <merijn> s/athan/vanila
15:52:33 <merijn> athan: Yes, but suppose I use reall-awesome-library from hackage, but it's author didn't derive Typeable for a datatype, but my code needs it?
15:52:36 <athan> merijn: Good to know anyway haha.
15:53:10 <merijn> athan: StandaloneDeriving lets you use the workaround of deriving Typeable in your code without patching really-awesome-library
15:54:21 <levi> athan: StandaloneDeriving is necessary for deriving with GADTs, too.
15:54:29 <athan> merijn: Hmm, okay. Why can't it work with just `deriving(...)`? Is it easy to make something derivable?
15:54:35 <athan> levi: Ahh, okay
15:55:13 <merijn> athan: I don't understand what you mean with "Why can't it work with just `deriving(...)`?"?
15:55:52 <athan> merijn: Nevermind, I think I got it. Thanks :)
16:00:19 <levi> I gather from the GHC manual that you have to use standalone deriving with GADTs (and other "exotic data types") because they don't conform to the requirements for "Specification of Derived Instances" in the Haskell Report.
16:00:24 <athan> So, to me, a data family instance looks a lot like a GADT. Am I correct?
16:00:48 <merijn> athan: Not entirely, afaik
16:01:19 <merijn> athan: GADTs come with the effect that different constructors result in different types, data families don't really
16:02:14 <athan> merijn: What about with singleton's Sing? The instances look very GADT-y
16:02:49 <merijn> athan: I guess if you squint a bit they look kinda similar
16:02:58 <merijn> athan: However, GADTs are closed, data families are open
16:03:07 <Iceland_jack> mathu: constructors of data families can result in different types
16:03:21 <Iceland_jack>     data instance Foo Int = I Int
16:03:21 <Iceland_jack> where
16:03:21 <Iceland_jack>     I :: Int -> Foo Int
16:03:40 <merijn> Which package is the commandline hoogle? Just hoogle?
16:03:52 <Iceland_jack> that was for merijn, sorry
16:04:04 <athan> merijn: Closed? Thanks for the help :)
16:04:17 <athan> Also Iceland_jack: Thank you!!!
16:04:24 <merijn> athan: You can't add new entries to a GADT (without modifying the GADT declaration, that is)
16:04:24 <Iceland_jack> Yes closed and don't carry proof are the biggest differences
16:04:35 <Iceland_jack> *open and don't carry proof
16:04:36 <athan> merijn: Ahh okay, awesome
16:13:05 <joelteon> At what point did it start being possible to build GHC with clang?
16:13:08 <joelteon> Was that 7.8?
16:13:22 <merijn> joelteon: Yeah
16:13:25 <joelteon> damn
16:13:49 <merijn> Why "damn"?
16:13:59 <joelteon> nix woes
16:14:03 <joelteon> I'm going to have to build GHC 7.8 with GHC 7.8
16:18:36 <levi> athan: Not all things constructed with GADT-syntax are actually GADTs either (I'm not sure if it's directly relevant to your question, but I thought it was interesting when reading about GHC extensions). You can enable GADT syntax without enabling GADTs, which allows you to create only standard data types with GADT-style syntax.
16:24:18 <athan> levi: That's actually very interesting! Is it a language extension like "ADTWhere" or something? Very cool.
16:25:48 <levi> It's called GADTSyntax
16:26:45 <mmasters_> falafist : you still there?
16:26:50 <levi> Extension GADTs implies GADTSyntax and RelaxedPolyRec
16:27:27 <athan> levi: Very cool, thank you :)
16:28:41 * hackagebot llvm-pretty 0.1.0.0 - A pretty printing library inspired by the llvm binding.  http://hackage.haskell.org/package/llvm-pretty-0.1.0.0 (TrevorElliott)
16:28:43 * hackagebot llvm-pretty-bc-parser 0.1.2.0 - LLVM bitcode parsing library  http://hackage.haskell.org/package/llvm-pretty-bc-parser-0.1.2.0 (TrevorElliott)
16:33:41 * hackagebot llvm-pretty-bc-parser 0.1.2.1 - LLVM bitcode parsing library  http://hackage.haskell.org/package/llvm-pretty-bc-parser-0.1.2.1 (TrevorElliott)
16:36:28 <dfeuer> Hi, y'all. Anyone know what a CoreAlt is?
16:37:09 <levi> athan: You're welcome!
16:37:20 <merijn> Are there any benchmarks that show the performance difference between TChan and TQueue?
16:37:22 <levi> dfeuer: I haven't heard of that before. What's the context?
16:37:58 <dfeuer> levi: I'm trying to understand how CSE works in GHC. That type shows up a lot in CSE.lhs.
16:38:47 <johnw> merijn: TChan has more overhead
16:39:03 <merijn> johnw: Yes, but *how* much more
16:39:14 <johnw> benchmark it with criterion
16:39:45 <merijn> johnw: Basically, I have some very specific needs, which will likely result in me implementing my own TChan/TQueue style thing and I was curious whether someone already did the performance work for me
16:40:26 <levi> dfeuer: I'm guessing they represent case alternatives in the Core abstract syntax representation, but I'm not entirely sure.
16:40:37 <merijn> (basically, I need a Chan where I can remove items "in the middle")
16:42:13 <jmcarthur> merijn: an MVar containing a fingertree maybe? not sure what operations you need to be fast
16:42:35 <merijn> jmcarthur: I'm working with STM, so it has to be T something regardless
16:42:44 <jmcarthur> so a TVar then :)
16:43:10 <levi> dfeuer: It's a type alias from the CoreSyn module
16:43:11 <merijn> jmcarthur: I just need a FIFO queue, but with an efficient removal in the middle operation
16:43:41 <dfeuer> Thanks, levi.
16:44:34 <jmcarthur> merijn: sounds like a fingertree should work nicely if it's okay for it to only be modified by one thread at a time (essentially what STM would force you to do)
16:44:35 <merijn> jmcarthur: I considered just using "TQueue (TVar Bool, a)" and then modifying the bool to indicate "removed", but that means I can have a long list of items that won't be removed until they reach the front of the queue
16:44:51 <jmcarthur> merijn: a fingertree supports split and concat in O(log n)
16:44:52 <merijn> jmcarthur: I have multiple reader and multiple writers
16:45:21 <merijn> Actually
16:45:32 <jmcarthur> merijn: well, multiple readers and writers doesn't mean you can't do this. it depends on the access patterns you need.
16:45:50 <merijn> That makes me wonder whether I really want STM for this, rather than using IO and wrapping STM around that...
16:46:02 <merijn> I guess STM is pretty horrific for this usecase
16:46:14 <jmcarthur> that is your call :)
16:46:57 <merijn> jmcarthur: It's just that I realised that "multiple reader/multiple writer" is sort of a worst case "thundering herd" causing scenario :)
16:46:59 <jmcarthur> how much parallelism are we talking about here? how much contention for this queue will there be?
16:47:13 <johnw> merijn: yep
16:47:25 <merijn> jmcarthur: >100s of competing threads per queue?
16:47:27 <ReinH> jmcarthur: removal in the middle or from the bottom?
16:47:31 <merijn> ReinH: Middle
16:47:32 <ReinH> er merijn ^
16:47:36 <ReinH> Interesting.
16:47:44 <ReinH> A lot more effort has been put into deques than that, I think :/
16:48:02 <merijn> I'm thinking whether it might not be better to have my outer queue be in MVar (which should be more efficient) and then only the inner bit in STM
16:48:08 <jmcarthur> merijn: and how often are they trying to manipulate the queue?
16:48:24 <merijn> jmcarthur: Constantly :)
16:48:38 <merijn> jmcarthur: As fast as network clients are stuffing packets in :p
16:49:45 <jmcarthur> and it
16:49:47 <jmcarthur> oops
16:50:11 <jmcarthur> and it's not possible to simply remove this synchronization point?
16:50:35 <merijn> jmcarthur: In what sense?
16:50:44 <jmcarthur> in the sense of just not having these queues at all
16:50:52 <merijn> jmcarthur: No
16:50:57 <jmcarthur> by changing the topology of these threads a bit
16:51:22 <jmcarthur> e.g. avoid having any centralized threads handling multiple clients
16:53:44 <merijn> jmcarthur: No, because that fundamentally conflicts with the protocol I'm implementing
16:54:28 <merijn> jmcarthur: The problem is I have N independent incoming connections which write messages at their own speed and I need to guarantee fairness
16:54:55 <merijn> So the solution is to have a queue of every non-empty connection, read one from the first, then if not-empty append to the queue again
16:55:07 <merijn> Which guarantees fairness
16:55:34 <merijn> But it means that there's contention when popping connections from the queue
16:57:36 <fread2282> :t curry
16:57:38 <lambdabot> ((a, b) -> c) -> a -> b -> c
16:58:54 <merijn> Well, I guess I could have only a single thread read from the queue of connection and serialise this to a bounded buffer which is then read from...
16:59:28 <merijn> That would eliminate contention and still guarantee fairness
16:59:46 <merijn> Or rather, any contention will now be in hands of the user
17:04:52 <tabemann_> sigh. now I have a project I actually want to implement in Haskell, but now I will have so lesw time to work on it now that I have a job
17:04:58 <tabemann_> less*
17:06:33 <benzrf> tabemann_: I:
17:08:38 <tabemann_> especially since this is a job where they basically expect you to work as long as necessary to meet deadlines (but give you much flexibility in slow times)
17:12:14 <stew> so just schedule lots of slow times :)
17:13:09 <tabemann_> heh
17:29:04 <tac> I've apparently broken my haskell setup on my laptop. When I `import Data.Text` in GHCi, I get "Could not find module 'Data.Text'`
17:29:19 <tac> How does GHCi decide which packages to use, by default?
17:29:23 <hpc> ghc-pkg | grep text?
17:29:25 <glguy> check   ghc-pkg list text
17:29:30 <hpc> er
17:30:01 <tac> is text a package on its own? I thought Data.Text came with base
17:30:07 <glguy> nope, you have to install it
17:30:07 <tac> hmm
17:30:16 <erikd> tac: text is a package on its own.
17:30:21 <erikd> you need to cabal install it
17:30:39 <tac> ah, that would also explain why Text.Parsec didn't work. It looks like it's not under that heading in base
17:30:56 <erikd> Text.Parsec is in the parsec package :-)
17:31:00 <tac> right right
17:31:18 <tac> Originally, I tried Text.Parsec, and when that failed, I decided to test something more likely to be included in the base package (Data.Text)
17:31:19 <tac> doops!
17:32:55 <tac> very excellent. thank you guys
17:33:01 <levi> Text.Parsec doesn't have anything to do with Data.Text, AFAIK. The 'Text' means different things in their names I think?
17:34:49 <tac> Oh I know
17:34:54 <tac> I was just trying to sanity check my setup
17:35:19 <tac> I figure the best way to learn how GHC and Cabal work with package management is by repeatedly breaking my setup and crying to IRC to help me fix it >__>
17:36:02 <hpc> the best way to learn is to break your internet as well
17:36:10 <hpc> then spend a week figuring out simple stuff that just won't do what it should
17:36:11 <hpc> ;)
17:37:08 <merijn> I wonder why TChan uses TVar + TList rather than just TMVar like Chan uses MVar
17:37:27 <tac> hpc: I am working on many fronts simultaneously to break things that I shouldn't ever need to mess with in the first place.
17:37:40 <hpc> :D
17:37:41 <tac> anyway, I got my stupid lambda calc evaluator working, so thanks
17:38:11 <tac> except that apparently it's slightly broken on linux. But why would things work cross-platform without pain? :)
17:38:17 <vanila> tac can I see?
17:38:22 <tac> sure
17:38:37 <vanila> thanks :)
17:39:08 <tac> vanila: https://bitbucket.org/_tactics/lambda/src
17:39:26 <tac> Lambda.hs is the one and only source file. The .lc file is the "standard library" for the language.
17:39:40 <tac> It's untyped at the moment, and the parser is very very particular
17:40:31 <josephle> untyped lambda calculus is fun to play with
17:40:33 <tac> Let me know if anything doesn't make sense. I went back and added commentary, hoping that it might help someone who's curious about how these things work.
17:40:39 <tac> josephle: yep yep :)
17:41:10 <vanila> tac, I cant view this it wants me to log in
17:41:20 <tac> oops
17:41:27 <tac> one second
17:41:40 <tac> vanila: try the same link again
17:41:48 <tac> It was marked private
17:41:52 <josephle> I remember when my mind was blown when my professor gave me hw that involved encodings of lists in lambda calc
17:41:56 <vanila> great! works now , thanks :)
17:42:50 <tac> josephle: did you know you can do those encodings in System F, too?
17:43:07 <josephle> yes, my mind was blown a second time when that happened
17:43:23 <vanila> tac, wow very nice code!!
17:43:44 <vanila> eval' (Lam x b) ctx = VFun (\v -> eval' b ((x, v) : ctx)) <-- this technique is awesosme
17:45:14 <tac> vanila: yeah. It's almost cheating, since you can use Haskell's closures to implement closures
17:45:22 <tac> It's harder to do in something like C. But still possible.
17:45:43 <tac> Writing a Lisp in C is also annoying because you can't simply use the host language's garbage collector
17:45:53 <vanila> *nod*
17:45:56 <josephle> lexical closures in C is an interesting compiler exercise
17:46:08 <vanila> it was a surprise to me that all you need to compile lisp into C is closure conversion though
17:46:09 <Clarice> tac: You would need to decide on a representation of environments. There's a good blog post on it that I can't remember.
17:46:12 <vanila> CPS is just a bonus to get TCO
17:46:29 <Clarice> But the gist is that you "can", in the same way that you can do anything in C if you put your mind to it. :P
17:46:37 <josephle> that makes sense -- that it's just closure conversion
17:46:40 <dfeuer> Writing Lisp in C is annoying because C doesn't optimize tail calls.
17:47:08 <Clarice> dfeuer: Tail calls aren't even a necessary part of Lisp! The only Lisp I know of that supports TCO, guaranteed, is Scheme.
17:47:55 <Clarice> dfeuer: Clojure can't do it because of the JVM. It's not required by conforming CL implementations. Picolisp has the gall to call it an academic party trick (which I agree with, to an extent). I don't think newlisp does it, partly because TCO in interpreters is... harder than in compilers.
17:48:24 <vanila> I cannot understand why these new fangled languages refuse to do TCO
17:48:25 <dfeuer> Clarice: a fair point, I suppose. Do *actual* CL implementations do it?
17:48:28 <flux> TCO is harder in interpreters?-o
17:48:30 <vanila> like python and go and stuff
17:48:37 <Clarice> flux: Is that true or did I just bullshit something?
17:48:47 * hackagebot simple-pipe 0.0.0.15 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.15 (YoshikuniJujo)
17:48:50 <flux> I cannot see why it would be so.
17:48:51 <vanila> TCO is really easy to implement and without it you get unbounded stack growth on normal lisp style code
17:49:23 <tac> you just have to take that into account when deciding on your control flow constructs
17:49:31 <tac> you have to do things in a more imperative way
17:49:41 <vanila> it's totally bizarre that people refuse to implement this simple optimization, they defend it with things like "it gives unpredictable memory behavior" or that it breaks stack traces.. but it strictly improves memory use so I am left scratching my head
17:49:54 <geekosaur> interpreters can do tail call optimization. JVM just doesn't
17:49:55 <Clarice> dfeuer: http://0branch.com/notes/tco-cl.html#sec-2-1 the short answer is that most self respecting compilers do.
17:50:01 <vanila> I think it's more like that language designers don't understand tail calls and are content with control contructs like goto instead
17:50:37 <Clarice> dfeuer: GNU Common Lisp isn't used by... anyone, as far as I can tell, and CLisp doesn't have the most active development branch. :P So in effect, yess.
17:50:47 <dfeuer> vanila: it can have a negative impact on performance under certain fairly common circumstances.
17:50:55 <josephle> vanila: I mean, it *does* break stack traces...
17:50:58 <Clarice> vanila: It DOES break stack traces
17:51:02 <Clarice> That's fucking important
17:51:31 <Clarice> Anyway, you should be able to turn TCO on or off for "people who know what they're doing", with some arbitrary default (I would say the arbitrary default is on)
17:51:35 <vanila> dfeuer: can you tell me where/when, I've never encountered that
17:51:38 <Clarice> ...SBCL does this. You can turn TCO off.
17:52:20 <vanila> Clarice, wouldn't you just use TRACE instead of worrying about stack frames in common lisp?
17:52:23 <Clarice> vanila: The Rust mailing list has a very good thread on why they didn't implement TCO in their language that has to do with the "negative performance impact" in that common case
17:52:34 <josephle> Clarice: so you mean making optimization level flags actually mean something :P
17:53:16 <dfeuer> vanila: basically, there's more stuff to shuffle around when you do a function call. I would still come down on doing it unless you can prove it's not necessary.
17:53:16 <Clarice> josephle: That's disingenuous. Optimization level flags are always well documented, otherwise no one would go to the trouble of implementing them. You'd just have one flag that says "SUPER-SPEEDY"
17:54:09 <Clarice> This entire discussion should probably go into #haskell-blah because I derailed it from vanila's perfectly on-topic discussion.
17:54:30 <josephle> what was vanila's topic?
17:54:36 <Clarice> Implementing his Lisp in Haskell
17:54:59 <Clarice> Which I consider silly :P I don't believe in ever implementing a language in a high level language
17:55:00 <vozz> How can you define a list type that has a fixed length? For example an encryption key that might be some fixed number of bytes
17:55:12 <Clarice> vozz: With an array
17:55:16 <Clarice> errr vector
17:55:51 <josephle> vozz: are you also expecting the typechecker to enforce this length?
17:55:56 <__cody__> Clarice: how about a low level language in a high level one?
17:56:05 <dfeuer> Clarice: why ever not? High level languages are excellent at implementing other languages.
17:56:16 <vozz> josephle: It would be nice if it did
17:56:31 <vanila> vozz, data Vec n a where Nil :: Vec Void a ; Cons :: a -> Vec n a -> Vec (Maybe n) a
17:56:42 <Clarice> __cody__: Only if you're using the high level language to specifically emit assembly or vm bytecode
17:56:47 <josephle> vozz: https://hackage.haskell.org/package/Vec
17:57:22 <Clarice> How does one write a garbage collector in Haskell, for instance?
17:57:23 <vanila> this lets you have   Cons 'a' (Cons 'b' Nil) :: Vec (Maybe (Maybe Void)) Char -- the elements: Nothing, Just Nothing index into the vector
17:57:46 <Clarice> dfeuer: see above
17:57:50 <josephle> Clarice: I think most people consider the runtime system to be separate from the compiler
17:57:51 <vanila> Clarice, I guess you'd have to just use haskell to specify an abstract model of GC
17:57:52 <vozz> Nice, thanks a lot
17:58:27 <vanila> Clarice, like in the SPJ lester book on implementing haskell compilers, they implement an abstract heap - and then implement combinator reduction in terms of that
17:58:28 <__cody__> Or an interpreter which puts the onus of GC on the meta-language
17:58:29 <Clarice> josephle: I merely said "implementing a language", not "writing a compiler".
17:58:39 <dfeuer> Clarice: obviously there's little sense in interpreting assembly in Haskell, but I'm still missing your point.
17:59:36 <Clarice> dfeuer: I say that I wouldn't write a language implementation in Haskell because I would want the flexibility to experiment with runtime libraries, which are nontrivial to write in a langauge with, say, a runtime
17:59:55 <vanila> "Tail calls require a calling convention that is a performance hit relative to the C convention."
18:00:00 <vanila> is this what you were talking about?
18:01:39 <geekosaur> All languages have runtimes. You just happen to need the C runtime to do pretty much anything on modern OSes, so you get it "for free"
18:02:10 <carter> vanila: that quote is false :)
18:02:20 <Clarice> geekosaur: There's very little to the C runtime besides allocation/memory management runtimes, which by the way are also written in c
18:03:28 <geekosaur> but consider that original Mac OS bundled a Pascal runtime the same way. C is not somehow unique
18:04:54 <geekosaur> and Algol60 only needed a bigger runtime than C gets away with because they stupidly made I/O part of the language specification instead of a separate libraries spec
18:05:13 <dfeuer> carter: please explain.
18:05:28 <carter> tail calls are just jumps
18:05:30 <Clarice> geekosaur: I didn't say C was unique, just that there's a level of resource control you have in C that you don't have in other languages, which I believe to be necessary for runtime implementation. Erlang has separate heaps for actors, while other languages have a shared heap with particular garbage collection styles. How do you specify any of that with a high level language like Haskell?
18:05:30 <vanila> carter, it sounds false but i'd have to profile
18:05:52 <vanila> i have not got around to implementing TCO is my scheme compiler yet
18:05:53 <carter> its only on VMs that lack general GOTOs that tail calls are pricy
18:06:06 <geekosaur> you don't, you're talking about higher level languages vs. lower level
18:06:15 <geekosaur> there's always been a hierarchy
18:06:28 <_tca> Clarice: you can do it with mmap
18:06:39 <Clarice> geekosaur: Well, the context of this was "why wouldn't you write a language in Haskell?" because I said that I would not, that's all.
18:07:07 <geekosaur> in the old days there were special system programming languages that required even less runtime... and you wrote the language runtimes and often the compilers in it
18:07:15 <__cody__> but "writing a language" and writing a runtime are dferent ings
18:07:26 <Clarice> In your opinion, __cody__ .
18:07:56 <dfeuer> carter: the jumping is easy. The (tiny) potential performance hit, as I recall, has to do with the need for a function to clean itself off the stack before actually making the call.
18:07:56 <__cody__> well it's like 2% of GHC
18:08:12 <carter> dfeuer: .... no....
18:08:19 <carter> its slower than a loop sure
18:08:25 <carter> well, just as pricy as loop
18:08:28 <vanila> you know it's really crazy that TCO is controversial - the general hacker public still haven't digested the lambda papers!
18:08:28 <carter> clear what from stack
18:08:29 <geekosaur> (admittedly the compilers part was probably overkill, on the other hand if you had to use the systems programming language to bootstrap then you might as well write your compiler in it, then use the resulting compiler and runtime to do everything else)
18:11:11 <geekosaur> if it's not obvious, the general hacker public treats TCO much the same way as the leaky abstraction thing we were discussing the other day. they grok hard rules they don't really understand but can follow blindly
18:11:12 <dfeuer> carter: the stack pointer has to move before the jump, to remove the local variables, etc. As I recall, there is a little bit of juggling required to make this happen. I'm confident it's fairly trivial on a modern computer, and certainly not worth the pain and suffering C inflicts.
18:11:43 <geekosaur> as distinct from considerations that require understanding to use appropriately
18:12:08 <__cody__> ooh
18:12:14 <carter> dfeuer: .... why do you think that?
18:12:22 <__cody__> my bad the RTS is actually quite a large part of GHC
18:12:43 <dfeuer> carter: are you arguing just to argue?
18:13:00 <carter> dfeuer: ... given talks on this stuff
18:13:20 <dfeuer> carter: I ask that because you seem to be arguing both sides.
18:13:30 <carter> i've only said one side
18:13:39 <carter> that a tail call friendly abi is cheaper than normal funcall abi
18:13:51 <carter> *normal == C / etc not tail calling abi
18:14:22 <vanila> wild
18:14:28 <dfeuer> carter: so you weren't objecting to my claim that any slow-down from TCO in some cases is trivial?
18:14:35 <carter> what slow down?
18:14:45 <carter> i never said theres a slow down
18:14:46 <vanila> dfeuer, I asked about that earlier
18:14:47 <tac> LLVM can do tail call easily, can't it?
18:14:50 <carter> yeah
18:14:53 <carter> tailcalls are cheap
18:14:53 <dfeuer> People have written papers about this, carter.
18:15:01 <carter> and?
18:15:03 <dfeuer> BRB.
18:15:15 <carter> the fast ccall convention on llvm is tail calls
18:15:21 <vanila> in x86 a tail call can be implemented by just jumping past a function prelude, whereas a function call requiers setting up and destroying a stack frame
18:15:28 <carter> yes
18:15:35 <athan> *rings bell* Okay, break before round 2
18:15:50 <vanila> I get the point about not having TCO so that you operate better with C tools
18:15:56 <vanila> but that's not a performance thing
18:17:36 <carter> yeah
18:17:48 <carter> thats just getting precise stack traces and supporting var arg functions
18:18:11 <heatsink> What are you really comparing when you compare tail call support with no tail call support?  Usually tail call support comes with other design decisions, like not having control flow based loops.
18:18:33 <vanila> heatsink, you can still have loops and stuff, TCO doesn't interact badly with that at all
18:18:47 <vanila> in fact TCO gives you the power to implement loops and such efficently in the language itself
18:19:11 <vanila> there's no need for a trade-off, but I see the rust folk using this as a barganing chip to say "we don't need TCO we already have loops"
18:19:11 <heatsink> That's the point though
18:19:24 <heatsink> If you have the power to implement efficient loops with tail calls, why would you also support efficient loops with control flow?
18:19:26 <dolio> Heh.
18:19:45 <carter> heatsink: maybe to keep more registers live at once :)
18:20:02 <heatsink> carter: tailcall-based compilers tend to have interprocedural register allocation for that reason
18:20:03 <carter> rather than reloading/spilling to stack
18:20:05 <dfeuer> carter: what I vaguely recall from my limited reading was that non-tail calls are slightly faster using C calling conventions. I could be misremembering though.
18:20:07 <vanila> I'm just saying they're orthogonal, there is no need to sacrifice one to have the other - you can have the best of both worlds
18:20:34 <dolio> heatsink: Sounds like a lot of work. :)
18:20:44 <dfeuer> It's been several years.
18:20:53 <carter> the fast ccall convention gives you both fast tail calls and fast fun calls
18:21:08 <carter> what you lose vs the c abi calls is you dont get var args and precise stack traces
18:21:44 <dfeuer> Varargs is rather disgusting anyway, but stack traces are nice.
18:22:43 <heatsink> Okay, so that sounds reasonable if you have a system where control flow is the preferred way to implement loops
18:23:32 <Clarice> dfeuer: :'(
18:23:47 <Clarice> dfeuer: They amount to the same thing as passing an explicit list.
18:24:09 <levi> When talking about C, it's important to separate the language as defined in the spec and the way it's implemented for a particular platform (i.e. the platform ABI).
18:24:26 <carter> var args support has pretty deep implications to the ABI
18:24:27 <carter> though
18:24:38 <dfeuer> Yes, Clarice, except they're horrible.
18:25:03 <Clarice> dfeuer: But picture this: you've got a million different uses of a function and suddenly you've come up with an expanded use for the function. Using your new function is just an &rest away in common lisp, and now you don't have to modify those million call sites.
18:25:37 <Clarice> dfeuer: They're not any more horrible than the passing of the explicit list. One is just as performant as the other.
18:26:01 <vanila> well one thing that's interesting is multiple value returns
18:26:06 <Clarice> I concur
18:26:14 <vanila> that's quite a different thing than just returning a list/tuple
18:26:24 <vanila> but C doesn't support this at all
18:26:37 <vanila> whereas it's trivial to support with continuations, since you just make your continuations take extra parameters
18:26:40 <dfeuer> Scheme does, and GHC does.
18:27:04 <vanila> I wouldn't say GHC does
18:27:08 <carter> no it does
18:27:08 <Clarice> vanila: Why don't you just throw a value in a register with some inline assembly? No, really.
18:27:14 <carter> ghc has unboxed tuples
18:27:23 <Clarice> carter: That's slightly different.
18:27:26 <vanila> in something like STG it doesn't have to allocate the constructor
18:27:27 <Clarice> But not entirely.
18:27:35 <vanila> it just allocates code that applies it when destruted
18:27:38 <carter> Clarice: no, unboxed tuples ARE multipel return fvalues
18:27:40 <dolio> Unboxed tuples are exactly multi-returns.
18:27:55 <dfeuer> Which is why the rules for using them look weird.
18:27:59 <Clarice> carter: The importance of multiple value returns is the flexibility of callsites.
18:28:07 <dolio> dfeuer: They aren't weird anymore, actually.
18:28:19 <shachaf> i,i What are unboxed sums?
18:28:20 <vanila> it's as efficient but its a different category of language
18:28:29 <dfeuer> dolio: I thought you couldn't store them in data structures and such.
18:28:37 <Clarice> vanila: +1
18:28:41 <dolio> Well, okay, they're weird like that.
18:28:52 <dolio> dfeuer: You used to not be able to use them as arguments to a function, though.
18:28:55 <dolio> But now you can.
18:29:19 <dfeuer> Huh. Not sure I noticed that change.
18:29:27 <shachaf> It was a while ago.
18:29:39 <Clarice> carter: Any function calling another function that returns an unboxed touple will still have to make the assumption that the value it's getting is an unboxed tuple.
18:29:40 <dolio> It changed in 7.6?
18:29:45 <angerman> is there a Data.Map like structure that does sub maps? { k -> v, k2 -> { k3 -> v3, k4 -> v4, ... }, k5 -> v5, ... }?
18:29:45 <dolio> Or was it 7.8?
18:29:47 <shachaf> 7.6? Really?
18:29:55 <carter> Clarice: not true strictly :)
18:29:55 <shachaf> I thought it was earlier.
18:30:01 <Clarice> carter: Example? I'm curious
18:30:03 <dolio> I'd be surprised if it were any earlier than 7.6.
18:30:34 <carter> unboxed tuples are the same as "fully applied args"
18:30:35 <dfeuer> Clarice: that's the case in Scheme as well. You can't just call a function returning multiple values as though it returned one.
18:30:54 <dfeuer> Although I think *some* Scheme implementations support that.
18:30:55 <Clarice> dfeuer: The Scheme has the same limitation.
18:30:57 <shachaf> Oh, I guess it was 7.6.
18:30:57 <Clarice> *Then
18:31:05 <Clarice> carter: I'm not sure what "fully applied args" means.
18:31:34 <carter> i mean
18:31:46 <heatsink> angerman: Just use a map containing maps?
18:31:48 <dfeuer> Clarice: basically,  f a b = foo is pretty much the same as f (#a,b#) = foo, except the latter can't be partially applied.
18:31:52 <levi> Is the change you're referring to the one where GHC changed from a push/enter to eval/apply model for non-saturated function applications?
18:31:53 <carter> passing (# Int#, Int# #) to a function
18:32:06 <angerman> heatsink: what do I do with the "non-map" values?
18:32:10 <dolio> levi: No, that was ages ago.
18:32:17 <carter> is the same as  what a function that takes Int#->Int#-> does
18:32:18 <levi> Ah, ok.
18:32:29 <dolio> levi: The change was that (->) used to have a kind like ?? -> ? -> *.
18:32:45 <dolio> Where ?? was * or #, and ? was ?? or (#).
18:33:07 <heatsink> angerman: If some elements are non-map values, then use Either (or a type that has the same shape) to allow the map to contain either type.
18:33:16 <dolio> So you could return unboxed tuples, but not use them as arguments (because it's unnecessary to do so).
18:33:24 <Clarice> carter: But I'd like to pass (# Int#, Int# #) to a function that has type f :: Int# -> a
18:33:31 <dolio> But now unboxed tuples just have kind # or something, and can be arguments to functions.
18:33:40 <angerman> heatsink: either... now i feel stupid :(
18:33:47 <heatsink> > Map.fromList [(1, Left 'a'), (2, Right $ Map.fromList [(9, 'c')])]
18:33:48 <carter> Clarice: then a better be equal to (Int# -> b)
18:33:50 <lambdabot>  Not in scope: ‘Map.fromList’
18:33:50 <lambdabot>  Perhaps you meant one of these:
18:33:50 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
18:33:50 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
18:33:50 <lambdabot>    ‘S.fromList’ (imported from Data.Set)Not in scope: ‘Map.fromList’
18:33:51 <angerman> heatsink, not your fault, though :D
18:33:58 <carter> :)
18:33:59 <Clarice> carter: Nope! :)
18:34:07 <carter> Clarice: SEG FAULT :)
18:34:11 <Clarice> hahahaha
18:34:15 <Clarice> Lisp versus Haskell priorities
18:34:24 <heatsink> angerman: You'll get used to thinking with types soon enough
18:34:29 <levi> angerman: Well, maps are parameterized on two types, right? A key type and a value type.
18:34:31 <Clarice> I'm not saying either one is better or right, just that they're different in terms of problems being solved
18:34:49 <levi> angerman: All the values have to have the *same* type; there's no way around that.
18:35:13 <angerman> levi: yes, but I was looking for a data type X = Map | Value, instead of adding an Either in there.
18:35:16 <slack1256> unless you pack existential types thought
18:35:17 <carter> Clarice: you can do fun stuff by writing CMM :)
18:35:25 <slack1256> *though
18:35:36 <dolio> And now (->) has a kind like TYPE(i) -> TYPE(o) -> *
18:35:36 <Clarice> carter: I was actually going to learn LLVM for some... side project of mine
18:35:43 <dolio> Although I think GHC just reports * -> * -> *.
18:36:01 <carter> Clarice: llvm-general  is a good starting point
18:36:08 <Clarice> carter: Mailing list or channel?
18:36:14 <levi> angerman: Well, 'Either a b' is just 'data Either a b = Left a | Right b'; it's just expressing a 'sum' of two possibilities.
18:36:14 <carter> the library
18:36:15 <heatsink> It says something like ? -> ?? -> *
18:36:16 <furrykef> http://lpaste.net/109599 -- how's this for a naive implementation of primes?
18:36:17 <carter> i run the channel
18:36:25 <carter> the mailing list does have folks on it
18:36:25 <Clarice> Oh! Right on
18:36:29 <carter> but low volume
18:36:45 <carter> the main dev of llvm-general doesn't come on IRC that often
18:36:51 <angerman> levi: yes, I just never thought of eitehr. it's alwasy been in the "error" reporting direction for me.
18:37:11 <Clarice> carter: But hopefully you understand what I mean when I say I understand why the type signature I proposed would be silly for nonfunctional value of a, but it still irks me coming from my favorite language
18:37:12 <carter> on the haskell lvm channel some of the mroe substantial LLVm haskell user all lurk
18:37:21 <carter> Clarice: :)
18:37:41 <vanila> furrykef, looks fine! You could do more efficient algorithms but it's a good start
18:37:58 <levi> angerman: You can create your own sum type that looks like 'data ValueOrMap k v = Value v | Map k v'
18:38:03 <heatsink> furrykef: True `notElem` xs looks weird.  It's the same as not (any xs).
18:38:07 <vanila> furrykef, A fun trick is that you could make use of the 'primes' list in your isPrime function
18:38:14 <heatsink> not (or xs)
18:38:34 <vanila> because of lazyness, you can look at the start of the list as you compute the next elements
18:38:53 <Clarice> vanila: *laziness
18:41:19 <levi> angerman: Er, the type I said wasn't quite right.
18:42:05 <levi> You'd want 'Value v | Nested (Map k v)' or something like that.
18:42:14 <carter> vanila: yeah, which is nice for one pass streaming things
18:43:26 <angerman> levi, but then I have to adjust lookup et al :)
18:44:00 <angerman> levi so Map k (Either v (Map k v)) seems to be a better fit.
18:45:26 <furrykef> <heatsink> furrykef: True `notElem` xs looks weird.  It's the same as not (any xs).
18:45:28 <furrykef> Thanks. Didn't know that
18:45:29 <Clarice> angerman: Does the nested map have the same types as the parent map?
18:45:43 <angerman> Clarice: yes.
18:45:51 <Clarice> angerman: Gotcha. What's this for, anyway?
18:46:06 <Clarice> I've never seen a hash-table have values that are actually more hash-tables
18:46:18 <jle`> it looks like an indexed rose tree
18:46:26 <angerman> Clarice: parsing lua tables
18:46:35 <Clarice> I dunno anything about Lua :P
18:46:41 <johnw> "My god, it's full of hash tables"
18:47:37 <carter> i feel like we should have more dat structures that can exploit both hasable and ord structure when we have both
18:47:55 <angerman> Clarice: any generic dictionary structure which can have dictionarys as values.
18:48:28 <Clarice> angerman: Use cases for that? :o
18:48:38 <jle`> a DOM?
18:48:50 <jle`> JSON?
18:49:00 <Clarice> ...right
18:49:11 <jle`> or any situation where a rose tree is useful perhaps
18:49:12 <angerman> I guess there are multiple, as jle`, just named, in my case I'm having the bindings from the current scope of a function.
18:49:22 <jle`> like graph algorithms
18:49:33 <jle`> pathfinding
18:49:38 <Clarice> jle`: If it's indexed, it would be an IntMap, then
18:49:48 <jle`> indexed by a key, not by an int
18:49:59 <jle`> i suppose indexed is the wrong word :|
18:49:59 <Clarice> Hrm. Yes, alright.
18:50:15 <heatsink> furrykef: Actually, not (or xs)
18:50:24 <furrykef> heatsink -- yeah, I caught that now
18:50:27 <furrykef> thanks though
18:50:32 <heatsink> sure
18:51:05 <angerman> jle`, Clarice: a file system... whoa!
18:51:16 <jle`> :D
18:51:32 <angerman> had to look at hackage and search for rose tree to find file system...
18:51:49 <Clarice> angerman: I still think "IntMap" because, you know, inodes? :P
18:51:51 <jle`> any not xs
18:52:10 <jle`> er
18:52:13 <jle`> all not xs
18:53:10 <jle`> @check (==) <$> all not <*> not . or
18:53:10 <lambdabot>  : -1: -1:Ambiguous infix expression
18:53:16 <jle`> @check (==) <$> all not <*> (not . or)
18:53:19 <lambdabot>  +++ OK, passed 100 tests.
18:53:23 <lalulos> strtok in haskell?
18:54:39 <lalulos> how do i split a string/bytestring into tokens?
18:54:49 <lalulos> is there a simple way without a parser?
18:55:11 <slack1256> you could do it with regex, but parser are much nicer to deal with.
18:55:21 <rudi_s> lalulos: There's split.
18:55:40 <lalulos> thanks rudi_s
18:55:48 <rudi_s> lalulos: http://hackage.haskell.org/package/split
18:56:33 <slack1256> OMG that introduction of the package
18:56:35 <lalulos> you know whats strange - how theres single quotes for char and double quotes for string
18:56:49 <lalulos> couldnt that be infered?
18:56:51 <dmj> @typ BS.breakByte
18:56:52 <lambdabot> Word8 -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
18:57:05 <furrykef> No, because 'a' and "a" are entirely different things
18:57:19 <lalulos> what i mean is
18:57:27 <lalulos> the compiler can determine which one you want
18:57:31 <lalulos> based on the type expected
18:57:47 <furrykef> That would make it annoying for the cases where it can't
18:57:54 <lalulos> like what cases?
18:58:00 <lalulos> i cant think of any
18:58:04 <Clarice> lalulos: No, the compiler can infer types for unspecified types. You're talking about type correction, where you say something and actually mean something else.
18:58:07 <silver_> that would ruin point of type safety
18:58:13 <Clarice> ^
18:58:19 <flux> it could work like it works for integers
18:58:28 <Clarice> "Oh, you said a list of chars here but I think you actually meant a single char, so let me just TOTALLY CHANGE THAT FOR YOU"
18:58:31 <lalulos> yeah
18:58:38 <flux> 'a' and "a" could both be of some type class "CharacterOrString"
18:58:39 <lalulos> no Clarice
18:58:44 <lalulos> cause whenever you use a char or string
18:58:48 <lalulos> you are passing it to a function
18:58:53 <lalulos> that takes only one type
18:58:53 <Clarice> Wow!
18:58:54 <flux> but, I'm quite sure the benefit would not really be there.
18:58:54 <lalulos> right
18:59:19 <Clarice> lalulos: The more we let people forget, the stupider they become.
18:59:26 <lalulos> ?
18:59:36 <furrykef> I'm gonna invoke my Python roots and say "explicit is better than implicit"
18:59:37 <lalulos> thats not a good argument
18:59:46 <Clarice> furrykef: Thank you.
18:59:53 <lalulos> the whole point of a programming language is to make it easierr for the programmer
19:00:09 <slack1256> lets say that I got a function called toChar
19:00:15 <monochrom> explicit is better than implicit. so why is python full of implicit conversions between different number types?
19:00:20 <flux> although it sounds like it could be simply a better compiler error message. "You have a single-character string here, but you need a Char, consider replacing " with '  "
19:00:29 <Clarice> lalulos: Easier for you to express things you should express. If you don't understand that a char is a fundamentally different datatype than a list, then we've got... a problem.
19:00:35 <[swift]> monochrom: preach it
19:00:37 <glguy_> monochrom: No no, just the parts where it's better to be explicit
19:00:37 <monochrom> and implicit conversions from various types to booleans?
19:00:44 <angerman> Great, another wonderful haskell eror message: cannot construct the infinite type
19:00:45 <lalulos> there is already a feature like this for text and string iirc
19:00:50 <lalulos> through a pragma
19:00:52 <Clarice> lalulos: Name it.
19:00:55 <slack1256> toChar :: SingleStringOrChar a => a -> Char
19:01:03 <pjdelport> monochrom: Python never claimed to be the best exemplar of that principle. :)
19:01:09 <slack1256> toChar "ab" what is the output?
19:01:25 <Clarice> Type error.
19:01:34 <flux> slack1256, it would be a type error, because compiler would infer its type to be String
19:01:40 <slack1256> to verify you are passed a single char you need a refinement of String.
19:01:40 <monochrom> mark my words. programmers are hypocrites.
19:01:41 <flux> well, not really 'infer'
19:01:47 <pjdelport> angerman: What's the code?
19:01:48 <merijn> monochrom: Because python hackers have never spend 2 weeks hunting down an implicit numeric conversion before ;)
19:01:54 <glguy_> ?remember monochrom mark my words. programmers are hypocrites.
19:01:54 <lambdabot> Nice!
19:02:00 <slack1256> But you don't want a new type, you want coerced String to chard only when there is a single char.
19:02:02 <lalulos> well obviously it can be a char if there is only one character
19:02:03 <Clarice> Er, how do you even define SingleStringOrChar? This isn't Idris, we don't have dependent types.
19:02:05 <glguy_> done
19:02:16 <slack1256> LiquidHaskell?
19:02:26 <Clarice> Whatever, this discussion is stupid.
19:02:36 <Clarice> monochrom: I concur with this. :P
19:02:40 <augur> can i define types in lambdabot?
19:02:47 <heatsink> angerman: You probably are treating a map as an element of a map.
19:02:49 <merijn> ok, name brainstorming session!
19:02:51 <angerman> pjdelport: data X a b = X { ..., bindings :: Map a b, ... }, b being Either String (Map a b)
19:02:56 <slack1256> I just wanted to show that if you haave that you have inconsistent functions.
19:03:18 <Clarice> slack1256: ah, alright. Well I agree.
19:03:23 <merijn> What is a good name for a channel/queue type which supports efficient removal of elements from the middle of the queue and relative insertion into the queue?
19:03:32 <Clarice> merijn: MagicChan
19:03:39 <lalulos> slack1256: how is that inconsistent?
19:03:43 <monochrom> random access queue
19:04:01 <monochrom> preemptible queue
19:04:05 <slack1256> The class SingleStringOrChar has to implement instances for String and Char
19:04:17 <Clarice> merijn: Question, what does "relative insertion" mean?
19:04:17 <lalulos> i never proposed that
19:04:21 <merijn> monochrom: Ah, that's pretty good
19:04:22 <slack1256> That includes working with "abc" strings of more than one character
19:04:23 <dolio> meque
19:04:25 <lalulos> i said you still have either string or char
19:04:27 <lalulos> two types
19:04:31 <merijn> Clarice: Insert before/after a specific element
19:04:34 <Clarice> slack1256: He didn't even want a typeclass, he wanted a datatype.
19:04:45 <angerman> jle` any rose tree implementation i should be aware of instead of trying to put a map into my map?
19:04:46 <lalulos> but you have only one way of writing static strings in code
19:04:51 <lalulos> using single quotes for example
19:04:52 <dfeuer> merijn: much depends on whether you want particularly efficient access to things near one or both ends, and what kind of access.
19:04:58 <slack1256> he wanted automatic coercion of single strings to chars.
19:05:01 <Clarice> merijn: Okay, then JengaQueue
19:05:06 <merijn> Clarice: I don't really have a usecase for that (I really just want efficient removal), but I figure I might as well add it if I can
19:05:23 <Clarice> merijn: That name is perfect, please use it. Please.
19:05:28 <merijn> dfeuer: It's just a FIFO queue, but with the ability to remove elements from the middle efficiently
19:05:41 <merijn> I actually like monochrom's preemptible queue, it's pretty accurate
19:05:42 <dfeuer> Making your data structures too general makes them slow and complicated.
19:05:58 <merijn> dfeuer: That's not really general at all...
19:06:12 <lalulos> for example a: char -> int         a 'b'                would use a char and         b: string -> int      b 'b' would use string
19:06:13 <monochrom> there is also bullyable queue :)
19:06:20 <dfeuer> No, I meant the "might as well try to ...."
19:06:27 <Clarice> merijn: FIFO? More like FI?O
19:06:44 <merijn> dfeuer: Oh, that's more because my current design seemed to efficiently allow relative insertion
19:06:58 <merijn> dfeuer: Not something I designed for, just a "hey, I guess that's possible too" observation
19:07:05 <slack1256> so b: is a partial function right?
19:07:05 <merijn> If it doesn't work out, I'm ditching that
19:07:08 <lalulos> Clarice: this is the option i was talking about: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html#overloaded-strings
19:08:04 <Clarice> lalulos: That is so very different
19:08:11 <Clarice> lalulos: That's overloading a syntax.
19:08:12 <lalulos> slack1256: a regular function
19:08:16 <lalulos> yeah
19:08:20 <Clarice> lalulos: For things which can be, you know, string-like
19:08:25 <dfeuer> Ah, that makes sense, merijn.
19:08:29 <lalulos> thats what im talking about too
19:08:30 <slack1256> b "abc" = error "abc" right?
19:08:36 <Clarice> lalulos: 'a' is not string like.
19:08:42 <lalulos> yes it is...
19:08:45 <Clarice> lalulos: There is no stringiness to it
19:08:47 <lalulos> before it is compiled
19:08:53 <Clarice> Getouttahere!
19:08:56 <lalulos> it can be interpreted as a string of length 1
19:09:18 <Clarice> I sure hope not.
19:09:19 <lalulos> if wherever it is used expects a type of String
19:09:36 <lalulos> Why, what would that break?
19:09:43 <Clarice> It's silly. Too many implicits.
19:09:50 <slack1256> lalulos: I guess what you want if subtyping right?
19:09:54 <slack1256> *is
19:09:57 <lalulos> how is it silly, plenty of languages already do it
19:10:02 <silver_> and 3 can be interpreted as [Int] of lenght 1
19:10:02 <slack1256> that Char is a subtype of String
19:10:02 <Clarice> lalulos: Like what?
19:10:14 <merijn> lalulos: Plenty of languages are terribly designed, so that's not really an argument
19:10:26 <lalulos> so what is actually wrong with this?
19:10:39 <lalulos> so far all ive heard is 'its just bad'
19:10:41 <pjdelport> angerman: type Foo a b = X a (Either String (Map a b)) checks fine here
19:10:44 <slack1256> that chars aren't really Strings
19:10:53 <lalulos> im not saying a char is a string
19:11:01 <pjdelport> angerman: What's the full code in context? Having a Map inside a Map should be no problem.
19:11:02 <dolio> What is wrong is that it would cost time to implement, and won't aid anyone enough to recoup that cost.
19:11:03 <lalulos> im saying it can be determined which one is needed
19:11:05 <lalulos> at compile time
19:11:05 <slack1256> that single strings are not really chars
19:11:23 <Clarice> lalulos: You're saying auto-type-conversion. That's bad. Bad bad bad.
19:11:24 <lalulos> it can be determined from the surrounding context
19:11:30 <Clarice> lalulos: It encourages laziness.
19:11:34 <dolio> And would occasionally be annoyingly ambiguous.
19:11:35 <lalulos> so
19:11:39 <dfeuer> Making it easier to make mistakes and harder to debug them?
19:11:40 <lalulos> what is actually bad about it?
19:11:43 <pjdelport> angerman: Having an infinite number of Maps at the type level is an error, though; maybe that happened?
19:11:45 <furrykef> lalulos -- what about ['a'] vs. ["a"]
19:11:46 <merijn> I don't think this discussion is very constructive at the moment
19:11:49 <furrykef> two very different things
19:11:51 <Clarice> dolio: I would say that it wouldn't aid in anything.
19:11:52 <pjdelport> infinite number of nested Maps, that is.
19:11:55 <slack1256> lalulos: what if you call a function on the same argument but on different context where one is interpreted with char and another with single string?
19:11:58 <lalulos> furrykef: that can also be infered the exact same way...
19:12:11 <Clarice> slack1256: To be honest, that's a weird function.
19:12:22 <lalulos> slack1256: im only talking about statically defined strings
19:12:31 <dolio> I didn't say it wouldn't aid in anything. I said it wouldn't aid sufficiently to recoup the cost of anyone implementing it instead of something else.
19:12:32 <slack1256> oh OK
19:12:34 <angerman> pjdelport: well it could conceptually be infinite maps in maps.
19:12:36 <furrykef> lalulos -- maybe the compiler can, but the programmer can't unless he reads what's done with it
19:12:44 <furrykef> and he may have to read pretty carefully
19:13:03 <lalulos> the char type can be removed completely and string can be used
19:13:11 <lalulos> with an optimization for single length strings
19:13:32 <slack1256> that's more complicated than having a Char and String separated
19:13:38 <slack1256> you're dependent on implementation
19:13:40 <angerman> pjdelport: As jle` was saying, i'm probably looking for a rose tree, instead of sticking Either a (Map a b), as b into a Map a b.
19:14:20 <dolio> Are you only thinking about string literals?
19:14:21 <lalulos> slack1256: what do you mean?
19:14:27 <lalulos> yes dolio
19:14:38 <dolio> Because having a Char tells me that an arbitrary value of that type is length one.
19:14:41 <jle`> i would probably just make my own tree type
19:14:41 <dolio> Having a String does not.
19:15:08 <jle`> that's the way that aeson does it
19:15:13 <dolio> So you cannot simply get rid of the Char type and then 'optimize'.
19:15:30 <splintax> String is just [Char] so to make Char a special case of String makes no sense :/
19:15:33 <lalulos> well you can and you can check the length
19:15:50 <dolio> You can't check the length of an unknown string at compile time.
19:15:58 <lalulos> i know
19:16:02 <lalulos> but you can at runtime
19:16:05 <lalulos> or dependent types
19:16:17 <lalulos> im just brainstorming
19:16:25 <dolio> Why would I throw away the compile time information that I have and do it at runtime?
19:16:25 <splintax> "you can just check it at runtime" is unlikely to go down well in #haskell
19:16:27 <vanila> brainstorming for what?
19:16:40 <merijn> dolio: Because you like python? :D
19:16:46 <dolio> I don't.
19:16:49 <lalulos> removing the char type is a different thing
19:16:56 <Clarice> splintax: I wouldn't say that. Haskell does a lot of runtime behavior. Pattern matching is a case switch on a tag bit, for instance.
19:17:02 <lalulos> what i was talking about initially is only having one type of quote for both char and string
19:17:15 <silver_> it's useless
19:17:21 <slack1256> Clarice: Even then the compiler whines when you don't check all the cases.
19:17:24 <silver_> and error prone
19:17:28 <Clarice> slack1256: Mehhhh
19:17:45 <slack1256> Clarice: I say the same but tell that to ghc-mod
19:18:11 <lalulos> is there really a huge need for the Char type in a high level programming language such as haskell?
19:18:12 <merijn> Clarice: Pattern matching isn't actually a case switch on a tag bit
19:18:22 <dolio> Yes.
19:18:24 <slack1256> Yes
19:18:26 <lalulos> why
19:18:33 <merijn> Clarice: In fact, datatypes may not even have a runtime representation at all
19:18:36 <dolio> Because I want to know that I have a Char and not a String.
19:18:42 <slack1256> because is conceptually easy.
19:18:42 <lalulos> why?
19:18:54 <dolio> Because I don't want to have to test its length every single time I want to know I have a Char.
19:18:55 * hackagebot linear-opengl 0.2.0.1 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.1 (BenGamari)
19:18:57 <Clarice> merijn: To the former I say "well, sometimes it is", and to the latter, yes, I'm aware of type erasure :)
19:18:58 <merijn> For the same reason I prefer having Maybe to null pointers
19:19:13 <merijn> Clarice: I'm not talking about type erasure
19:19:22 <lalulos> dolio: that can be done using dependent types with a condition on the length of the string
19:19:28 <lalulos> and its way more general that way
19:19:30 <merijn> Clarice: Type erasure says *types* don't exist at runtime, I'm saying data may not exist at runtime
19:19:30 <Clarice> merijn: Oh, you know, when I said pattern matching I just meant pattern matching where your cases are merely datatypes, not necessarily patterns
19:19:36 <dolio> I don't want to use code :: String -> Int which is unsafe, but I test beforehand that it's length 1.
19:19:46 <slack1256> What is a String? Oh just a string of chars is sounders that "oh just a string of strings of size 1 that have the same representation of Char"
19:19:51 <merijn> Clarice: Yes, and I'm saying datatypes don't need to have a runtime existence :)
19:19:55 <slack1256> you gained nothing afar of indirection.
19:19:56 <dolio> lalulos: I don't need dependent types. I just need Char.
19:20:06 <Clarice> merijn: You would know more about that than I do! Question, when you pattern match on a Maybe, what happens?
19:20:14 <lalulos> dolio: so how do you check if a string is some other length other than 1?
19:20:38 <merijn> Clarice: The answer is "it depends", there are multiple compilation strategies for datatypes and GHC can pick whichever it thinks optimises best
19:20:53 <copumpkin> a Char corresponds exactly to a unicode character. It's not a string of length 1
19:20:57 <dolio> There are manifold functions that make sense on Char but are unsafe on String.
19:21:09 <shachaf> copumpkin: To a code point. Well, almost exactly.
19:21:12 <lalulos> copumpkin: that all depends on the representation in memory
19:21:13 <dolio> There are not that many useful functions that require strings of exactly length 15.
19:21:15 <lalulos> it can be the same
19:21:19 <Clarice> copumpkin: Do not join this discussion, he is a bad troll
19:21:22 <Clarice> copumpkin: Also, love your name.
19:21:25 <copumpkin> :)
19:21:27 <merijn> Clarice: If you're interest in low level details of how to compile to machine code, I have a good paper for you that covers all the details. Should be readable with minimal haskell and basic C/asm skills
19:21:40 <lalulos> Clarice: you are an ignorant uptight idiot
19:21:44 <Clarice> Thank you!
19:21:46 <merijn> No name calling, please
19:21:47 <copumpkin> watch it.
19:21:54 <dolio> Please refrain from calling people trolls and whatnot.
19:21:59 <Clarice> Noted.
19:22:01 <lalulos> merijn: wheres the warning for him?
19:22:09 <merijn> lalulos: That applies to both of you
19:22:09 <copumpkin> from dolio?
19:22:38 <merijn> I consider calling people trolls name calling too
19:22:40 <Clarice> merijn: If it's not too much trouble, I'd love to see those papers.
19:22:48 <lalulos> its always the less knowledgeble people in here that act like know it alls
19:22:51 <furrykef> No no no no no, this is how you do it
19:22:51 <tac> hmm
19:23:05 <furrykef> Your simian countenance suggests a heritage rich in species diversity.
19:23:05 <copumpkin> lalulos: let's stop talking about it
19:23:06 <tac> Why would backspace not work properly for Prelude.getLine
19:23:06 <tac> ?
19:23:07 <Clarice> merijn: I've also some papers on efficient pattern matching strategies that I've been meaning to look at.
19:23:21 <tac> I'm getting ^? and it's not removing the previous character from the buffer for some reason
19:23:53 <geekosaur> children, can we please behave?
19:23:55 <merijn> Clarice: https://research.microsoft.com/apps/pubs/default.aspx?id=67083 it's not entirely up-to-date with current GHC, but a good starting point
19:23:58 <copumpkin> lalulos: and for the record, dolio pretty much knows more about dependent types than 99% of the people here and still says he doesn't want dependent types for this :)
19:24:13 <copumpkin> (the remaining 1% is me, cause I'm super cool)
19:24:16 <copumpkin> (just kidding)
19:24:19 <geekosaur> tac: getLine is not automagically wrapped by a readline-like
19:24:24 <slack1256> lol
19:24:30 <Clarice> merijn: Oh, THAT paper. Someone threw that at me just a few days ago, I haven't gotten around to reading it yet.
19:24:31 <lalulos> copumpkin: so?
19:24:36 <geekosaur> which will do things like hiding the difference between DEL and backspace
19:24:36 <merijn> Clarice: :)
19:24:39 <tac> geekosaur: even so, most languages automatically handle backspace :X
19:24:59 <merijn> tac: This has to do with terminal behaviour, not language
19:24:59 <tac> I'm trying to figure out how to get getLine to do that now, I guess
19:25:02 <lalulos> copumpkin: he was talking about that specific case, doesnt mean he doesnt want dependent types at all
19:25:04 <carter> copumpkin: i still find it funny that you messing around with Pi Repa led to someone els getting a workhsop paper :)
19:25:08 <pjdelport> angerman: Something like this? newtype RMap a b = RMap (Either String (RMap a b))
19:25:16 <tac> merijn: It might be because I'm running from GHCi. Might that be the case?
19:25:17 <copumpkin> carter: hey, they cited me
19:25:19 <carter> :)
19:25:22 <geekosaur> tac: when people are used to shells and python etc. using some readline/editline/etc., they don't notice their stty settings are wrong
19:25:26 <carter> copumpkin: you're the expert :)
19:25:37 <geekosaur> I'm guesisng if you "stty -a" at the shell, it'll show your erase is set to ^H
19:25:47 <geekosaur> but you're using ^? (ASCII DEL)
19:25:50 <pjdelport> angerman: D'oh, not quite like that, sorry. :)
19:26:12 <geekosaur> so you're not getting the tty line editing you expect
19:26:22 <geekosaur> (this is sadly quite common these days)
19:26:37 <merijn> tac: No, python behaves the same, for example
19:26:39 <pjdelport> angerman: newtype RMap a b = RMap (Either String (Map a (RMap a b))) ?
19:26:58 <geekosaur> python can be built with readline support
19:27:03 <geekosaur> sometimes it is, sometimes it isn't
19:27:24 <tac> yeah, it looks like that behavior is happening because I'm running inside GHCi
19:27:25 <merijn> tac: Try running this trivial script: 'echo "print input(\"hmm?\n\")" >> test.py && python test.py'
19:27:25 <tac> using :main
19:27:36 <angerman> pjdelport isn't that also going to be infinite on the type level?
19:27:38 <merijn> tac: Then try typing and backspacing
19:27:46 <merijn> tac: Exact same behaviour for me
19:27:47 <tac> right
19:27:55 <tac> I compiled and it works just fine now :)
19:28:10 <merijn> I'd consider it a bug if it works, actually
19:28:25 <pjdelport> angerman: Nah, it's recursive, but not infinite (at the type level). The *values* may be infinitely nested, though.
19:29:31 <pjdelport> angerman: Similar to how say list is a finite type, but list values can be infinite.
19:30:36 <angerman> pjdelport, hmm, type massaging :D
19:34:26 <zugz> is there a shorthand for "mapStateT (return.runIdentity)", or a neat generalisation to other transformers?
19:34:47 <zugz> :: Monad n => StateT s Identity b -> StateT s n b
19:35:20 <merijn> zugz: mmorph?
19:35:23 <merijn> @hackage mmorph
19:35:24 <lambdabot> http://hackage.haskell.org/package/mmorph
19:36:53 <zugz> right, 'hoist' looks like a generalisation of mapStateT. Neat.
19:38:35 * tabemann is wading through the Yi source
19:39:13 <athan> * lends tabemann water wings
19:39:56 <tabemann> I'm trying to figure out how it does scripting in Haskell
19:40:11 <tabemann> because I'm planning on writing an application that itself is to be scripted in Haskell
19:40:44 <athan> tabemann: Good luck :/ Please share with me your findings!
19:40:56 <sipa> do it the xmonad way
19:41:16 <sipa> the configuration is the top level source code that gets compiled
19:41:32 <tabemann> I'm not going to do it the xmonad way because I want to be able to run scripts inside the application without shutting down the application and starting it up again
19:41:44 <tabemann> as it's an IRC client, and I don't want to lose or interrupt its state
19:41:48 <shachaf> What would you call a function :: Traversable t => [b] -> t a -> t b that puts the values from the list into the traversed structure?
19:41:53 <MP2E> isn't the yi way the xmonad way too?
19:41:55 <MP2E> I could be wrong
19:42:17 <MP2E> seems to recompile the configuration here when I modify it
19:42:38 <tabemann> the way I'm leaning towards now is pluggable, but with plugins being compiled at runtime and then dynamically loaded
19:42:53 <Clarice> From what I remember, the configuration is literally recompiled into xmonad
19:43:22 <tabemann> I thought that xmonad had the configuration as the top level of the application and "xmonad" being a library it calls
19:43:42 <godel> how would you handle parse errors here : http://lpaste.net/1121608912391372800 ?
19:44:53 <Clarice> tabemann: *shrug*
19:45:26 <tabemann> maybe I should just look at how dynamic loading works with GHC rather than wading through the codebase of Yi
19:46:30 <sipa> Clarice, tabemann: you're both right
19:47:12 <Clarice> :o
19:47:42 <Clarice> sipa: Right, it's a library, so the final application is essentially recompiled everytime.
19:47:54 <shachaf> OK, for my free pointed magma type (and similar types), what's a better name: "nonfree monoid" or "cheap monoid"?
19:50:38 <athan> shachaf: Lobster monoid
19:51:14 <athan> diamond crusted
19:55:16 <dolio> Don't both of those imply it's a monoid, which it isn't?
19:55:35 <shachaf> Yes, but it has a Monoid instance.
19:55:47 <dolio> Awesome.
19:55:59 <lalulos> how do I concatenate two bytestrings?
19:56:08 <shachaf> The main use is to inspect the Foldable/Traversable/etc. append trees of various structures.
19:56:48 <shachaf> For example I used this a while ago to figure out that Data.Map generates way too many memptys.
19:57:23 <shachaf> (So I sent Milan an email with a fix and it's better now.)
19:58:09 <tabemann> okay, Yi uses Language.Haskell.Interpreter
19:58:29 <lalulos> ah append
20:04:59 <Exio4> @src pure
20:05:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:05:41 <pjdelport> shachaf: That's an interesting application.
20:06:10 <shachaf> Someone suggested ReifiedMonoid once.
20:06:30 <pjdelport> shachaf: Wouldn't one of the Haskell evaluation visualization tools also help with that, or is the above targeted to be more useful in practice?
20:06:38 <clsped> Whats a good haskell http client library for making REST API calls?
20:06:55 <shachaf> pjdelport: I don't know.
20:07:04 <shachaf> I don't know of any such tools that work.
20:07:07 <dolio> Which ones?
20:08:15 <danclien> clsped: wreq (https://hackage.haskell.org/package/wreq) is a wrapper around http-client (https://hackage.haskell.org/package/http-client)
20:08:30 <clsped> danclien: thanks looks good
20:08:49 <pjdelport> shachaf: I haven't really used it, but i was vaguely looking at ghc-vis a while back, for one example.
20:09:13 <pjdelport> shachaf: Is that something that falls under "doesn't really work"? :)
20:09:57 <shachaf> I don't know.
20:10:14 <shachaf> But I don't think it does what I want.
20:10:29 <shachaf> I want to "visualize" not the data structure but its Foldable instance.
20:10:32 <pjdelport> Vacuum's another one, i think.
20:10:57 <pjdelport> Well, you would use it to visualize say an application of fold.
20:11:26 <pjdelport> I imagine it might be a bit noisy compared to what you're doing, though, unless the display could be narrowed down.
20:20:11 <NemesisD> chrisdone: are you around, perchance?
20:26:56 <tabemann> dammit that isn't gonna work
20:27:24 <tabemann> well maybe it will
20:27:44 <tabemann> (after all IO and STM have Typeable1 instances...)
20:28:31 <sclv> I vote reified. or observable
20:30:29 <tabemann> question
20:30:47 <tabemann> is Typeable special somehow, or can you just create your own Typeable instances?
20:31:59 <NemesisD> scumbag laptop. ask question on irc. it drops my wifi for 10 mins
20:33:28 <merijn> tabemann: You could, but not anymore
20:34:03 * hackagebot hmatrix-svdlibc 0.3.0 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.3.0 (BenGamari)
20:34:05 * hackagebot pandoc-lens 0.2.1 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.2.1 (BenGamari)
20:34:55 * tabemann is trying to figure out how a script in Hint is to communicate with his application outside of it
20:36:16 <carter> bgamari: huh
20:36:37 <carter> bgamari: typo ?  git clone git://github.com/bgamari/gmatrix-svdlibc.git
20:37:03 <tabemann> what happens if you generate IO foo inside of Hint, return it from Hint, and then bind it outside Hint? does that even work?
20:37:14 <bgamari> carter, Doh! Thanks for pointing that out
20:37:15 <bgamari> fixed
20:37:16 <benzrf> Hint?
20:37:24 <carter> bgamari: using editing powers?
20:37:27 <carter> aint it grand
20:37:31 <tabemann> as IO does have a Typeable instance, so you should be able to do it
20:37:39 <tabemann> benzrf: Language.Haskell.Interpreter
20:37:58 <benzrf> O:
20:38:20 <tabemann> s/Typeable/Typeable1
20:38:40 <bgamari> carter, ahhh, nope
20:38:43 <bgamari> carter, forgot about this
20:38:45 <carter> :P
20:38:45 <carter> :)
20:39:03 * hackagebot hmatrix-svdlibc 0.3.1 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.3.1 (BenGamari)
20:40:33 <clsped> is there a library for working with dates/times? Like parsing strings and getting a date and time in milliseconds
20:46:22 <clsped> ah time package
20:47:27 <carter> clsped: times pretty feature ful
20:47:33 <carter> the organization is a bit confusing
20:47:38 <carter> but it has everything if you look around
20:47:45 <carter> you'll probably wanna import the top level module
20:47:52 <carter> so you don't play "where was this actually defined"
20:47:53 <carter> gamed
20:47:59 <clsped> yeah okay
20:48:28 <carter> otoh, time as a human sociological construct is REALLY complicated anyways
20:49:01 <carter> soo i don't personally buy arguments that a simple time lib thats also correct can exist :)
20:49:06 * carter ducks
20:49:21 <carter> at least wrt time as people think about it
20:52:10 <clsped> aww it uses 1 - 12 for months but my months are 0 - 11 :S
20:52:21 <levi> angerman: It struck me a while back that there's a Functor instance for (Map k), so you could get something like your nested map with 'Free (Map k) v' from Control.Monad.Free; this gives you 'Pure v | Free ((Map k) Free (Map k) v)'
20:53:20 <clsped> what do?
20:53:31 <carter> clsped: make it pretty
20:53:35 <carter> clsped: point being, easy
20:53:47 <carter> just write a wee transformation of the infos
20:53:54 <clsped> carter: its 10 TB of data :S
20:54:13 <tabemann> dammit, Yi just goes and compiles its configuration file when it starts up
20:54:14 <johnw> levi: effectively an N-ary tree
20:54:33 <carter> clsped: for parsing or pretty priting?
20:54:41 <clsped> for parsing
20:54:43 <carter> oh
20:54:55 <carter> write a wee parser that interprets your stuff into a tuple
20:55:00 <carter> then tanslates the tuple to the time rep
20:55:08 <clsped> trying to use this: https://hackage.haskell.org/package/time-1.4.0.1/docs/Data-Time-Format.html
20:55:09 <carter> attoparsec should make that easy peasy
20:55:11 <levi> johnw: Yeah, angerman was looking for a map that could store either values or further maps.
20:55:21 <carter> clsped: theats for pretty printing
20:55:24 <carter> not parssing/reading
20:55:29 <clsped> its for parsing also
20:55:39 <carter> ohhh
20:55:41 <clsped> :t parseTime
20:55:42 <carter> ohhh
20:55:42 <lambdabot> Not in scope: ‘parseTime’
20:55:48 <clsped> or w/e
20:56:08 <carter> buildTimeSource
20:56:09 <carter> :: TimeLocale	
20:56:09 <carter> The time locale.
20:56:10 <carter> -> [(Char, String)]	
20:56:11 <carter> Pairs of format characters and the corresponding part of the input.
20:56:12 <carter> -> t
20:56:14 <carter> use buildTime
20:56:24 <carter> and split on the sepertors
20:56:28 <carter> then do a cleanup on that chunk
20:56:47 <carter> clsped: you know what size each piece   letter is
20:56:48 <carter> right?
20:56:53 <carter> in # of characters
20:56:55 <clsped> yes
20:56:59 <levi> tabemann: How do you want your plugin system to work?
20:57:03 <carter> so youc an split things out like so
20:57:31 <tabemann> levi: I want to dynamically execute code specified by the user at runtime
20:57:56 <clsped> carter: hmm not sure how to use this function
20:58:09 <carter> clsped: zip the cleaned up chunkz with the char codes
20:58:16 <carter> after you fix up each chunkles
20:58:18 <carter> *chunklet
20:58:20 <clsped> ah ok
20:58:24 <clsped> i see
20:58:34 <tabemann> so that the application does not need to be restarted each time the user tries to do something
20:59:21 <carter> clsped: that still requires you to do the right seperators bits
20:59:28 <clsped> yeah
20:59:30 <carter> BUT it localizes what you need to cleanup
21:00:02 <carter> clsped: whats the data sset for?
21:00:13 * carter is slightly starting to think abouthow to write decent time series data structures
21:00:14 <clsped> its forex data (time, bid, ask)
21:00:17 <carter> ohh
21:00:18 <carter> cool
21:00:23 <carter> btw, #numerical-haskell is a channel :)
21:00:25 <carter> mwhahahahah
21:00:29 <clsped> ah
21:00:36 <carter> (i run it :) )
21:00:41 <clsped> im trying to parse a bunch of data and store it in influxdb
21:00:48 <carter> the time series db thingy
21:00:51 <carter> @google influxdb
21:00:52 <clsped> yeah
21:00:52 <lambdabot> http://influxdb.com/
21:00:52 <lambdabot> Title: InfluxDB - Open Source Time Series, Metrics, and Analytics Database
21:01:05 <platz> I was thinking of implementing an interactive brokers client in haskell, but not sure I understand all the order structures
21:01:15 <clsped> not sure about influxdb though
21:01:17 <platz> still at least there are a few reference implementions in different languages
21:01:35 <clsped> because when i tried mongo it was using 4 times as much disk space as the data in csv!
21:01:37 <platz> (it's a gateway for trading)
21:01:58 <carter> clsped: mongo stores the key names in every record
21:02:10 <clsped> carter: even when i just stored an array
21:02:11 <carter> so its likeyou have header * # of rows overhead
21:02:40 <clsped> the usage reduces by like 5% when i switched to an array
21:02:41 <carter> clsped: what sorta queries
21:03:06 <clsped> carter: what do you mean?
21:03:17 <carter> what are the queries you wanna run on the data
21:03:33 <clsped> map reduce and selection of a subset for now
21:03:36 <carter> ok
21:03:47 <carter> you could just stream through the file each time
21:03:54 <carter> as some haskell queries
21:03:58 <carter> that load a chunk at a time
21:04:09 <clsped> i could do that for a start
21:04:16 <clsped> but i cant store all the data on one machine
21:04:22 <carter> well, you could
21:04:32 <carter> just need to have the disk space
21:04:32 <carter> but yeah
21:04:43 <clsped> yeah
21:04:51 <clsped> it might grow to a huge size
21:05:04 <clsped> thomson reuters has 1 petabyte of forex ticks for example
21:05:11 <carter> clsped: is this for work or funsies?
21:05:17 <clsped> funsies :D
21:05:31 <carter> k
21:05:55 <carter> clsped: using local or ephemeral comput?
21:06:25 <clsped> i have several small cloud nodes
21:06:33 <clsped> for now its just local though
21:06:35 <carter> ok
21:06:44 <carter> ok
21:06:45 <carter> so
21:06:59 <carter> what sorta local compute do you have?
21:07:42 <clsped> i have 4 $5 digital ocean nodes
21:07:45 <carter> ok
21:07:58 <carter> and you're trying to do DO for compute and storage for now?
21:08:16 <clsped> for now just local
21:08:32 <carter> ah
21:08:32 <carter> ok
21:08:32 <clsped> ill need more nodes
21:08:36 <carter> well
21:08:49 <carter> clsped: as a warm up
21:08:57 <carter> well
21:08:58 <carter> hrmmm
21:09:17 <carter> for a given volume of compute, enginering for one big box is much esier than many little boxes
21:09:29 <carter> granted for map reducey things latter can be faster if your'e careful
21:09:31 <clsped> i can actually store the tick data on one machine right now
21:09:34 <carter> ok
21:09:35 <clsped> it compresses 10x
21:09:38 <carter> cool
21:10:06 <carter> so maybe split iinto 100mb - 5gb chunks
21:10:25 <carter> work on one chunk while decompressing the next
21:10:26 <carter> or something
21:10:45 <carter> probably a chunk size that decompreses to still fit in ram
21:11:32 <clsped> yeah, im just trying to decide on what technologies to use right now
21:11:48 <carter> ok
21:11:51 <clsped> i want to eventually have it as a cloud service with a web frontend
21:11:56 <carter> cool
21:12:09 <carter> i'd say keep it simple where you understand the internals for now
21:12:13 <carter> either that will work fine
21:12:25 <carter> or blow up and you'll be like "outsouce the engineering to a db"
21:12:48 <clsped> yeah
21:12:55 <clsped> ok thanks for the help, g2g sleep
21:12:57 <clsped> gnight
21:18:02 <xpika> does anyone know how to get hoogle to list all functions in Data.Map ?
21:18:25 <carter> maybe hayoo can do that
21:21:23 <enthropy> ghci has :browse Data.Map
21:26:47 <xpika> enthropy: thats a possibility, but ive already set something up with hoogle
21:27:12 <xpika>  :: a gives you most results
21:29:08 <solatis> you know, after 3 weeks of doing haskell full-time, i'm actually amazed at the speed i'm picking things up
21:29:18 <solatis> i already feel pretty productive
21:30:02 <solatis> guess it helps if you're familiar with FP and things like type categories
21:30:19 <solatis> then the only thing left to learn is monads, and you know 75% of the language already
21:30:40 <carter> categories and monads are the boring bits ;)
21:30:46 <solatis> but people always have been claiming haskell being a weird,hard-to-learn language
21:31:11 <carter> they just name patterns / abstraction you'll do anyways by hand  af ew times
21:31:17 <solatis> yes
21:31:56 <solatis> it actually took a 'monad implemnetation in javascript' blog post for me to finally get monads, how obvious they actually are
21:32:15 <xpika> a related question. can i get ghc-mod to retrieve type definitions?
21:32:16 <carter> saldy bind in js is kinda unsafe
21:32:21 <carter> prob
21:32:26 <johnw> xpika: yes
21:32:37 <johnw> xpika: for me it "just works", so I'm not sure what you have to do
21:33:13 <solatis> and why the fsck is ubuntu still using cabal 1.16
21:33:43 <xpika> johnw: in conjunction with browse ?
21:33:53 <johnw> not sure about that, xpika
21:33:55 <johnw> I just type C-c C-t
21:40:55 <solatis> ok, i'm having a bit of a cabal pickle.. ubuntu uses 1.16 by default, and i want to upgrade to 1.20
21:41:10 <solatis> cabal install cabal cabal-install updates the *local* installation in ~/.cabal/
21:41:26 <solatis> what is the recommended way of doing this globally? updating my PATH seems so... ugly
21:41:38 <carter> solatis: fix your path
21:41:41 <carter> get over it :)
21:41:47 <solatis> gmrlb
21:42:04 <carter> i've had cabal/bin in my path for > 5 years ;)
21:42:22 <solatis> so there's no way to tell cabal to install itself in, say, /usr/local/bin ?
21:42:42 <carter> you can copy it
21:42:46 <carter> i dont recommednt that
21:42:58 <carter> if only because you dont wanna clobber binaries that have the same name has haskell ones
21:42:59 <carter> probably
21:43:01 <solatis> no that's not what i want
21:43:37 <solatis> i was looking into ubuntu's `update-alternatives`, but that creates more problems than solutions
21:43:47 <danclien> solatis: +1 to carter's suggestion to add it to your PATH. :)
21:43:59 <carter> solatis: i've been using haskell in various forms since 2004
21:44:09 <carter> and i've been doing commercial hakell work for a few years
21:44:17 <carter> i'm very conservative in my suggestions
21:44:24 <carter> sooo when DO make suggestions, they're fact based
21:44:25 <carter> :)
21:44:46 * solatis is expecting a formal proof now
21:44:57 <carter> :P
21:45:07 <carter> i'm telling you the simplest solution :)
21:45:14 <solatis> yeah it's the most pragmatic
21:45:22 <carter> not pragmatic
21:45:22 <carter> simple
21:45:28 <carter> :)
21:45:40 <carter> it might be the sanest too
21:45:46 <solatis> one could argue that the most simple solution is always the most pragmatic too
21:45:50 <carter> sure
21:45:57 <solatis> anyway
21:46:00 <carter> but some people use pragmatic in an unclear way :)
21:46:00 <solatis> you are correct
21:46:09 <solatis> every other sysadmin will immediately understand what's going on
21:46:25 <carter> i'd accept pragmatic if simple + sane implies pragmatic
21:46:25 <carter> :)
21:46:42 <solatis> as soon as you start symlinking global install directories, its starting to become a maze really soon
21:46:48 <carter> yeah
21:47:01 <carter> this avoids clober issues
21:47:06 <carter> and touching global things
21:47:27 <solatis> yeah
21:47:37 <solatis> and i'm using isolated containers anyway
21:47:56 <solatis> so right after my 'cabal update && cabal install cabal cabal-install' i just update the PATH
21:48:04 <carter> yeah
21:48:11 <carter> solatis: THEN
21:48:18 <carter> rm ~/.cabal/config and do cabal update
21:48:25 <solatis> oh
21:48:25 <carter> so you can get a 1.20 syle cabal config
21:48:27 <carter> full of nice things
21:48:32 <solatis> very good advice
21:48:33 <solatis> thank you
21:48:35 <carter> like parallle package builds
21:48:39 <solatis> wouldn't have thought of it
21:49:15 <carter> also i don't use sandboxes that much
21:49:23 <carter> i just occasional explode my ~/.ghc :)
21:49:29 <carter> (i never explode my ~/.cabal)
21:49:30 <carter> though
21:49:36 <carter> sandboxes are nice though
21:49:43 <solatis> hmm
21:49:46 <carter> just for my projects i tend to not need them as much
21:49:53 <solatis> in my case i just have 1 big project that emits +- 20 executables
21:49:58 <carter> cool
21:50:16 <solatis> that seemed like the simplest way
21:50:22 <carter> you mean ~ 20±small number
21:50:23 <glguy_> -20 executables sounds interesting
21:50:26 <danclien> carter: What's stored in .ghc vs .cabal?
21:50:27 <carter> yeah
21:50:36 <carter> danclien: .ghc just has the user pkg db
21:50:52 <carter> if ghc-pkg / cabal / ghc don't see something listed in there, they assume they need to reinstall it
21:50:54 <solatis> glguy_: it's a (pretty large) pipeline of distributed processes communicating via zeromq
21:51:03 <dfeuer> Hello, ladles and gentlefish!
21:51:12 <carter> ~/.cabal/share tends to have static file assets
21:51:29 <carter> ~/.cabal/bin tends to have those handy binaries which may or may not depend on those static files
21:51:34 <carter> solatis: neat
21:51:41 <napping> solatis: carter is not recommending against using sandboxes
21:51:48 <solatis> i know
21:51:59 <solatis> sandboxes actually sound like a feature that should be enabled by default
21:52:10 <carter> solatis: something like that will be possible in 7.10
21:52:21 <solatis> nearly all projects similar to cabal (npm for example) have their own version of dependency hell
21:52:28 <napping> earlier things were not at smooth as the current cabal sandboxes
21:52:34 <carter> heck
21:52:47 <carter> even current cabal sans sandboxes is light years better than in like 2008
21:52:59 <carter> what people currently call cabal hell
21:53:04 <carter> is cute and baby sized
21:53:07 <danclien> carter: I have no idea how anyone did any work with Haskell before Cabal.
21:53:10 <carter> compared with cabal hell yor
21:53:12 <carter> danclien: no
21:53:13 <napping> I install stuff outside sandboxes and nuke ghc all the time, it's just way easier for getting projects to build independently
21:53:22 <carter> cabal was a thing in 2008
21:53:23 <carter> BUT
21:53:39 <carter> if you built something, it'd rehash all itspackage deps
21:53:44 <carter> so any other lib tha tshared that dep
21:53:46 <carter> would get busted
21:53:54 <solatis> i miss `npm link` in cabal, tho
21:53:56 <danclien> Ouch.
21:54:08 <carter> danclien: so i'd have to build all the libs i want to be able touse at once
21:54:32 <carter> and their transitive closure of deps
21:54:35 <carter> ALL OF THEM
21:54:49 <johnw> Nix is really the answer to these problems
21:55:03 <johnw> I literally keep forgetting how much of a pain cabal can be
21:55:06 <carter> nah
21:55:16 <carter> i happily dont have codes that trip cabal problems
21:55:21 <solatis> johnw: have you ever heard of a simiar system that isn't considered a pain?
21:55:25 <napping> sounds like 7.10 is getting that sort of management for haskell packages
21:55:29 <danclien> Anyone using Nix on OS X?
21:55:29 <carter> yeah
21:55:35 <carter> john does
21:55:39 <carter> napping: exactly
21:55:50 <solatis> *every* language that has something similar is considered a PITA by the people using it
21:56:10 <johnw> solatis: cabal is roughly straddling three jobs: package management, dependency resolution, and building projects
21:56:13 <carter> we'll be getting a coherent way to talk about multiversion support and even how to sanely have > 1 version linked into a project
21:56:19 <johnw> danclien: me
21:56:21 <danclien> solatis: Cabal is extra painful for me due to long compile times.
21:56:23 <johnw> danclien: and joelteon
21:56:28 <johnw> and copumpkin
21:56:34 <danclien> johnw: Any major issues with it? Was thinking about giving it a shot.
21:56:41 <carter> ehh, the more i talk to people who manage distros package managers, the more i think cabal really inssn't a package manager
21:56:56 <johnw> danclien: we had some hiccups last week in the Mac support, but things are looking better now
21:57:05 <carter> what sorta hickup?
21:57:13 <danclien> johnw: Ah, cool. I'll give it a shot this week.
21:57:25 <johnw> the gccApple derivation was made obsolete, when several packages still needed it to build
21:57:37 <johnw> it was a major improvement for Mac overall, but not for certain packages specifically
21:57:39 <solatis> danclien: don't complain about long compile times. i have worked 15 years as a c++ dev. we have no such luxuries as automatic dependency resolution or quick compile times.
21:57:41 <johnw> ask me in #nixos :)
21:57:46 <carter> napping: one thing thats really cool, is ghc head is getting a notion of module type signatures
21:57:58 <johnw> ooh, that sounds nice
21:58:07 <carter> theres some subtleis wrt that
21:58:15 <carter> in the context of type classes
21:58:19 <carter> but its happening
21:58:31 <napping> even just the multiversion stuff is enough to avoid any unnecessary recompilation
21:58:42 <carter> even dieeper than that
21:58:49 <merijn> johnw: Since you're further in SF than me, found any good bits on proving concurrent algorithms correct? :)
21:58:52 <carter> different versions/builds will have different linker symbols!
21:59:09 <johnw> merijn: I have
21:59:28 <merijn> Do tell :)
21:59:29 <napping> I suppose that's fancy and all
21:59:37 <johnw> searching...
21:59:41 <napping> Are the module signatures used for dependency stuff?
21:59:48 <carter> napping: it means you can safely link two versions of a package into the same final lib
21:59:50 <Heather> hi, how to pass two IO monads to function with =<< or alike
21:59:58 <carter> napping: they might inthe future
22:00:01 <solatis> merijn: proving concurrent algorithms correct... i think we're still far, far aways from that
22:00:13 <carter> idea is you could swap out implimentations
22:00:32 <carter> lol
22:00:32 <napping> You wouldn't want to write them manually, but gathering a list of what things you used at what types, and letting that be your constraint on a dependency might work out pretty nicely
22:00:41 <merijn> solatis: Eh, no? There's plenty of proofs for concurrent algorithms, they're just rather involved
22:00:42 <carter> napping: yeah
22:00:49 <carter> merijn: tis too fucking heard
22:00:55 <johnw> merijn: http://www.sciencedirect.com/science/article/pii/S1571066108000765
22:00:58 <napping> then pvp-style version numbers of individual symbols
22:00:59 <carter> proving mutable things correct with machine cheked proofs
22:01:16 <merijn> carter: I totally proved distributed reference counting correct for a paper, which the grumpy bastards at PLDI rejected >.<
22:01:18 <carter> napping: it winds up being subtyping on the mdoule innterfactes
22:01:23 <carter> merijn: :)
22:01:28 <glguy_> Heather: We can help more if you give us more information, but something like this might be relevant to you:    m1 >>= \x1 -> m2 >>= \x2 -> f x1 x2
22:01:33 <danclien> Heather: Do you have a code sample we could look at?
22:01:35 <merijn> carter: Depends on how much mutability you have and your concurrency primitives
22:01:43 <carter> and how much work you wanna do
22:01:49 <merijn> carter: Proving haskell algorithms correct is a lot more tractable than C :)
22:01:52 <carter> yes
22:01:53 <solatis> merijn: sorry, you might be correct. it's probably just simple cases that can be covered?
22:02:04 <carter> merijn: SPAA or the like would be better for something liek tht
22:02:08 <carter> vs pldi
22:02:12 <solatis> i can't imagine what a formal proof of, say, a distributed consensus algorithm might look like
22:02:21 <Heather> danclien: do a <- b; foo a =<< c
22:02:26 <merijn> solatis: Oh, those have been done decades ago
22:02:30 <Heather> danclien: how can I simplify it
22:02:48 <napping> Heather: that looks simple enough
22:02:50 <merijn> carter: Some reviewers suggested POPL, I'm going to try POPL 2016 if I get started in time on finishing it :p
22:02:56 <glguy_> do a <- b; d <- c; foo a d
22:02:59 <glguy_> Heather ^
22:03:11 <napping> yeah, that's probably simpler
22:03:13 <johnw> merijn: http://coq.inria.fr/V8.2pl1/contribs/ParamPi.html http://sole.dimi.uniud.it/~ivan.scagnetto/pi-calculus.html http://coq.inria.fr/distrib/8.2/contribs/PiCalc.html
22:03:19 <Heather> napping: glguy: I want more syntax sugar! :)
22:03:27 <merijn> johnw: Oh, there's pi calculus for Coq?
22:03:29 <merijn> Neat
22:04:00 <johnw> see also the list of references in that first article
22:04:06 <johnw> some of which I just linked in that second set
22:04:44 <merijn> Basically, all I need to model are MVar's and threads
22:04:50 <merijn> So pi-calc might be overkill
22:04:57 <johnw> it's funny you should say that, since I want something similar
22:05:00 <napping> Heather: there's not a lot more to do there. You could go for something like join (liftM2 f a b)
22:05:02 <johnw> except that I want to model TVars
22:05:16 <johnw> I wanted to prove some properties of my new "taskpool" library
22:05:22 <merijn> johnw: heh
22:05:51 <merijn> johnw: We should work on that together, Coq + haskell verification sounds like it should get into any semi-decent FP conference ;)
22:06:03 <johnw> I would very much enjoy that
22:06:12 <johnw> I've been pair-programming some Coq + haskell with edwardk and it's been quite fun
22:06:15 <napping> are you planning on using any particular logic?
22:06:33 <Heather> :t liftM2
22:06:36 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:06:38 <merijn> napping: I'm planning on using the simplest thing that will require the least effort on my side :p
22:06:58 <merijn> Actually, I think that mu-calculus might be simpler for this
22:07:31 <trap_exit> merijn: what is your paper about?
22:07:40 <trap_exit> johnw: what have you two been working on in Coq + Haskell ?
22:07:44 <merijn> johnw: You might wanna consider that, I dunno how complex logic you wanna model? muCRL is pretty simple, the only problem is state space explosion, which may not be an issue if your task pool is not to complex
22:07:58 <merijn> trap_exit: Nothing, we just now realised we both wanna proof fairly similar things
22:08:11 <carter> johnw: did you look at haxl's design yet?
22:08:12 <trap_exit> merijn: what do you want to prove ?
22:08:14 <merijn> Although I also just realised my mu-calculus book is on the other side of the atlantic :(
22:08:18 <carter> and wheter or not its related?
22:08:19 <johnw> trap_exit: formalizing some of the concepts in ed's hask library
22:08:33 <Heather> napping: not sure if liftM2 helps here
22:08:34 <johnw> trap_exit: github.com/jwiegley/category-theory, and now github.com/ekmett/homotopy
22:08:36 <merijn> trap_exit: I wanna prove my concurrent queue design correct :p
22:08:57 <johnw> merijn: my needs should be pretty simple, so I'll go with what you need
22:09:04 <trap_exit> merijn: taht is an important problem
22:09:12 <trap_exit> with concurernt, "it passes unit tests" just isn't good enough
22:09:13 <johnw> merijn: http://people.inf.ethz.ch/csprenge/Publications_files/tacas98.ps
22:09:25 <merijn> hmmm
22:09:41 <Heather> napping: maybe just liftM ?
22:09:51 <trap_exit> :t liftM
22:09:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:09:59 <trap_exit> :t liftM2
22:10:01 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:10:15 <trap_exit> :t liftM4
22:10:16 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
22:10:29 <johnw> carter: only what I've seen in Simon's presentations
22:10:38 <johnw> carter: I hope to discuss it with him at ICFP soon
22:11:21 <Heather> napping: after all I don't need monad as result
22:11:33 <furrykef> http://lpaste.net/109608 -- I tweaked my code so that isPrime uses the primes sequence now. How'd I do?
22:11:53 <merijn> johnw: Oh, sweet :)
22:12:05 <merijn> johnw: My old professor put a free copy of the book I mentioned online :D
22:12:07 <trap_exit> :t liftM8
22:12:08 <lambdabot>     Not in scope: ‘liftM8’
22:12:08 <lambdabot>     Perhaps you meant one of these:
22:12:09 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
22:12:12 <merijn> johnw: http://www.cs.vu.nl/~wanf/BOOKS/moddissys.pdf
22:12:12 <johnw> merijn: link!
22:12:12 <trap_exit> :t liftM6
22:12:14 <lambdabot>     Not in scope: ‘liftM6’
22:12:14 <lambdabot>     Perhaps you meant one of these:
22:12:14 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
22:12:16 <johnw> :)
22:12:28 <rrradical> why does cabal's data-files parameter affect the entire project and not just the target? >:( my example executable needs data files but not my library
22:13:49 <colluphid> i think i remember reading about a function that would surround a value with quotes but i cant remember the name. any one know off the top of their head?
22:14:21 <johnw> do you mean in Haskell?
22:15:52 <danclien> Heather: What's the type of `foo`?
22:16:30 <johnw> merijn: are you able to meet on Google Hangouts?
22:17:32 <merijn> johnw: Yeah
22:17:48 <Heather> danclien: Progress -> Async () -> IO ()
22:18:49 <Heather> danclien: strange thing is : Expected type: Progress -> Async () -> ()
22:21:57 <danclien> Heather: I think I'm in over my head on this one. :(
22:24:56 * hackagebot hmatrix-svdlibc 0.3.1 - SVDLIBC bindings for HMatrix  http://hackage.haskell.org/package/hmatrix-svdlibc-0.3.1 (BenGamari)
22:24:56 * hackagebot warp 3.0.1.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.1.1 (MichaelSnoyman)
22:26:54 <jungnam> what is the easiest way to install the Lambdabot?
22:27:22 <jungnam> ubuntu packages does not work with mueval..
22:27:38 <Heather> danclien: look https://gist.github.com/Heather/b37e1498e3a664c84fcb
22:29:38 <[mth]> Does anyone know what OS signals ghc uses internally for GC and threading?
22:33:14 <Heather> danclien: I see, I need join
22:34:01 <danclien> <-- Haskell newbie. :)
22:34:39 <dfeuer> <-- Haskell newbie trying to hack on GHC's libraries :P
22:41:24 <pjdelport> [mth]: Are you looking for a general introduction? If so, maybe try https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts
22:42:09 <pjdelport> (Specifically https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler )
22:42:18 <danclien> Heather: Would it be possible to do `doProcess <$> mkProgress stdout <$> async foo`?
22:42:40 <danclien> Er... doProcess <$> mkProgress stdout <*> async foo
22:46:05 <danclien> Oops. Never mind. That wouldn't work unless doProcess was `a -> b -> ()`.
22:47:53 <danclien> Probably could join though? `join $ doProcess <$> mkProgress stdout <*> async foo`
22:54:52 * hackagebot eternal 0.0.6 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.6 (Heather)
22:54:54 * hackagebot eternal 0.0.7 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.7 (Heather)
22:56:35 <furrykef> I'll ask again
22:56:36 <furrykef> http://lpaste.net/109608 -- I tweaked my code so that isPrime uses the primes sequence now. How'd I do?
23:07:04 <pjdelport> :t let bindM2 f a b = join (f <$> a <*> b) in bindM2
23:07:05 <lambdabot> (Applicative m, Monad m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
23:07:23 <danclien> pjdelport: Oh, nice.
23:07:45 <pjdelport> danclien: I've wanted something like that once or twice before.
23:08:33 <pjdelport> where "bindM" would be =<<
23:08:50 <danclien> Is there a reason to use liftM2 over Applicative's syntax?
23:09:28 <dfeuer> Can anyone guess why GHC.List.and and GHC.List.or are written out with recursive forms and have their own separate fusion rules, rather than just using the Prelude definition based on foldr?
23:09:46 <pjdelport> Well, until the Applicative superclass is commonplace, it avoids the extra constraint:
23:09:47 <pjdelport> :t let bindM2 f a b = join (liftM2 f a b) in bindM2
23:09:49 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
23:09:49 <mjrosenb> furrykef: you probably don't have to go all the way up to x / 2, but it doesn't seem wrong.
23:10:45 <danclien> pjdelport: Ah, that makes sense.
23:11:09 <merijn> danclien: Monads are not (yet) required to implement Applicative, and therefore you might end up having a double constaint "(Applicative m, Monad m) => ...", other than that, not really
23:11:10 * danclien waits for GHC 7.10.
23:11:48 <dfeuer> Could someone explain what INLINABLE does, aside from allowing specialization outside the defining module?
23:12:06 <bitemyapp> is there a way to reference files with code in pandoc and have it inline those files?
23:12:07 <furrykef> mjrosenb -- you do for x == 4  ;)
23:12:34 <furrykef> I originally had < instead of <= but that caused it to think 4 is prime
23:13:23 <mjrosenb> furrykef: not what I was talking about :-p
23:13:46 <furrykef> what were you talking about, then?
23:18:40 <mjrosenb> furrykef: look at 197.  let's say we want to test to see if it is divisible by 65.  without doing any division/modulus at all, based on your algorithm, there is a very easy way to see that it it can't go into 197.
23:19:31 <mjrosenb> furrykef: what would the other number be (/assuming/ that 197 is divisible by 65, just round it to make that true)
23:23:29 <athan> Could someone help me understand System F... and potentially the common syntax when denoting types and... stuff?
23:24:28 <johnw> athan: if you work through software foundations, by the end System F will just be a set of definitions to you
23:24:34 <furrykef> mjrosenb -- I don't think I follow.
23:25:07 <athan> johnw: Oh! Alright, yeah I've been trying to go though some of Mark P. Jones work (to a slight avail)
23:25:11 <athan> Thanks :)
23:26:37 <mjrosenb> furrykef: ok, x * 65 == 197, what is x?
23:27:19 <johnw> e×
23:27:23 <johnw> x = 197/65
23:28:47 <furrykef> ~3.03
23:28:55 <mjrosenb> furrykef: right!
23:29:26 <mjrosenb> furrykef: so it is /about/ 3, but there is /no way/ that 197 can be divisible by 3.
23:29:45 <mjrosenb> furrykef: since you checked its factors in order, that would have been the second number that you checked.
23:31:07 <furrykef> ah.
23:31:24 <furrykef> yeah, I get'cha.
23:32:50 <mjrosenb> furrykef: cool, so what should that bound be?
23:34:35 <furrykef> Honestly I'm probably not thinking clearly enough to figure that out right now ^^;
23:37:30 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
23:37:32 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:38:00 <mjrosenb> Cale: ruining his fun :-p
23:38:07 <johnw> ozataman: ping
23:39:56 * hackagebot taskpool 0.1.0 - Manage pools of possibly interdependent tasks using STM and async  http://hackage.haskell.org/package/taskpool-0.1.0 (JohnWiegley)
23:40:03 <athan> johnw: Should I read software foundations, or types and programming languages first?
23:40:16 <johnw> athan: do them at the same time
23:40:39 <mjrosenb> "software foundations"?
23:40:55 <athan> johnw: :D
23:40:57 <[mth]> pjdelport: Looking for implementaton specifics, in terms of what signal handlers it actually registers and what it actually files. But thanks, that had some useful pointers to implementation detail.
23:40:57 <johnw> they share the same author too :)
23:41:12 <johnw> mjrosenb: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
23:41:24 <pjdelport> [mth]: Cool. :)
23:41:39 <mjrosenb> johnw: danke.  that title way /way/ too generic for me to hope to find it
23:41:42 <athan> johnw: I owe him a beer
23:41:59 <mjrosenb> oh, cool, I know one of the co-authors!
23:42:15 <johnw> it's the first hit on google....
23:42:34 <furrykef> That doesn't mean you know you've got the right one
23:42:43 <johnw> touché :)
23:42:54 <mjrosenb> johnw: and the next 30 are not.
23:42:56 <levi> bitemyapp: I don't think you can do that in pandoc, but you can do it with asciidoc/asciidoctor.
23:44:57 * hackagebot ekg 0.4.0.2 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.2 (JohanTibell)
23:49:57 * hackagebot debian-build 0.2.1.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.2.1.1 (KeiHibino)
23:50:42 <noone_> Does anyone know how to get cabal repl working inside of emacs when using hspec-discover?
23:50:59 <noone_> From the command line I can run cabal repl Spec and it works fine, but I can’t get that working inside of emacs
23:51:13 <mjrosenb> cabal has a repl? c.c
23:51:54 <noone_> Later versions of cabal have a repl command that enables you to start ghci with dependencies from the cabal file
23:52:07 <noone_> so it loads all the dependent modules for you
23:52:24 <dfeuer> noone_, "Does anyone know how to ... cabal ...?" No.
23:52:28 <noone_> and adds any extensions you specified into the session
23:53:05 <noone_> lol dfeuer
23:54:54 <dfeuer> Hello, edwardk! I just discovered that the and/cons, and/single, or/cons, or/single, and/augment, and or/augment rules are missing.
23:55:09 <dfeuer> [well, actually and/cons/cons and or/cons/cons]
