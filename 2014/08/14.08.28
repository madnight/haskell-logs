00:03:32 <nilg> how Haskellers parse program options these days? I'm having a choice overload http://www.haskell.org/haskellwiki/Command_line_option_parsers
00:06:38 <haasn> I know optparse-applicative is well known and I also remember liking options
00:06:46 <haasn> I would use one of those
00:08:48 * hackagebot alfred 0.3.1 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.3.1 (PatrickBahr)
00:10:57 <haasn> I think all the cool options parsers these days use applicative functors
00:11:10 <haasn> So they should feel pretty similar
00:12:16 <remdezx> hello! I keep getting this error ( http://lpaste.net/110127 ) when running code in GhcMonad, but in GHCI it works fine. Am I missing some flags? Did I forget to enable comething in ghc-api?
00:14:34 <Peaker> remdezx: when things work fine in GHCI it's usually due to type defaulting
00:14:34 <Peaker> remdezx: "The type variable ëm20í is ambiguous" is the key
00:14:36 <Peaker> remdezx: you need to choose m20=IO or m20=Pure
00:16:40 <remdezx> Peaker: Ok, but if ghci can guess it, why can't I make it in ghc api? I tried to enable Opt_ExtendedDefaultRules but it didn't work too
00:17:43 <remdezx> Peaker: I'm pretty sure that there are some other flags enabled in ghci which I'm missing
00:18:23 <Peaker> remdezx: you can just annotate the type to choose m20 which fits you
00:18:28 <trap_exit> Can we see the actual code?
00:18:48 <trap_exit> This is like going into a car shop, and saying "my car makes these noises" but not allowing the mechanic to look under the hood.
00:20:45 <remdezx> Peaker: I know, but ghci does it automatically - in this case I'd prefer doing it that way
00:22:32 <trap_exit> i've never regretted putting more :: 's in my *.hs files
00:23:30 <om-foxy> phadej: FYI that worked.  Cheers!
00:30:22 <jaseemabid> What is a good project to learn haskell in a month? What kind of projects should I write so that I can make good use of haskell (types, fp etc)?  Background: Learning a subject per month. Networking was last month. Decided to try Haskell for September. I have been coding for ~4 years, know python, JS, some scheme, emacs-lisp etc. Not completely new to FP. How hard is it to take something like a haskell interpreter in haskell? Or a toy
00:30:22 <jaseemabid> VCS? How did you all learn?
00:31:30 <trap_exit> jaseemabid: haskell in haskell is slightly more involved than scheme in scheme
00:31:48 <trap_exit> one good project I have in mind (someone else told me of this)
00:31:52 <trap_exit> is to write a better search for #haskell logs
00:32:14 <trap_exit> I forgot who gave me this idea, but if there was a better way to search #hashekll, I would know
00:33:19 <jaseemabid> trap_exit: You mean a text parsing, indexing, smart search sort of project? Yeah, might make me implement a few good text search algorithms in haskell.
00:34:00 <trap_exit> it'd be nice if there was a tool to turn #haskell into a wiki
00:34:12 <trap_exit> i.e. an interactive cool, where you can tag conversations in #haskell, and turn them into wiki-like entries
00:34:24 <trap_exit> a while back, jle` explained to me, in channel, of how monads work from the ground up
00:34:31 <trap_exit> I'd love to ahve a tool that let me take the old chat log and turn it into a wiki entry
00:36:22 <jaseemabid> One annoying thing about IRC logs is intermixed conversations. Maybe with that removed.
00:37:13 <trap_exit> yeah
00:37:23 <trap_exit> everyone else should just stfu when I talk
00:37:32 <trap_exit> actually, I think that's part of the challenge / fun
00:37:33 <trap_exit> to infer who's talking to who
00:38:11 <jaseemabid> A wiki page per day. Direct links to log lines, range of lines like github. A semantic URL scheme for that. People can link to  interesting sections from main pages.
00:38:58 <trap_exit> yes
00:39:01 <trap_exit> when you pull this off, let me know
00:39:06 <trap_exit> then we can try to raise funding vs genius
00:39:16 <trap_exit> this is goign to be tagging the world ... starting with IRC rather than rap lyrics
00:40:28 <trap_exit> jaseemabid: to help you along, I'l even contribute a line
00:40:30 <trap_exit> main :: IO ()
00:41:03 <jaseemabid> In general what kind of problems make you use a functional language and all its features well, so that I can learn haskell in ~3 days. You are suggesting me that this is.
00:41:15 <jaseemabid> ~30 :)
00:41:54 <jaseemabid> Atleast this will make me read a lot of #haskell. That will help! :P
00:48:38 <jle`> jaseemabid: what sort of programming projects have you done in the past?
00:51:02 <jle`> you can write a scheme interpreter, but you'd probably finish that in less than a month
00:51:18 <jle`> there's a popular scheme interpreter tutorial as a haskell introduction series floating around
00:51:45 <jle`> if you have ever done anything involving anything numerical/mathsy, you might have fun with a haskell port
00:52:10 <jle`> if you are already familiar with web, a blog or something might be a nice second or third haskell project
00:52:15 <jaseemabid> jle` I'm happy to hear that Q. A lot of web both frontend and backend (I'm bored and wanna do something else). Some compilers - a lex+yacc compiler for a a simple lang. Network stuff in C, but not much. Tons of JS. Few other random open projects on GH https://github.com/jaseemabid
00:53:25 <jle`> haskell is "famously good at compilers"
00:53:57 <jle`> in fact it's one of the things that haskell is said to be "very good for, if it is good for anything"
00:53:59 <jaseemabid> jle`:  Ideally no more web. I have played around with xmonad but not sure how newbie friendly that is. Inclined towards compilers, etc
00:54:01 <jle`> nobody actually said these exact quotes
00:54:11 <jle`> but i like to put them in quotation marks
00:54:13 <jle`> for fun
00:54:52 <simpson> MLs are good at compilers and other meta-language stuff. "ML" stands for "meta-language". Haskell is not technically ML, but it's closely related.
00:54:55 <jaseemabid> jle` Sadly I'm on a mac and and not linux anymore - so hacking xmonad is slightly more painful :(
00:55:27 <jaseemabid> simpson: Oh. I remember doing oca*ML* at school for some lab.
00:55:56 <jle`> like i said, there's a very accessible scheme-in-haskell tutorial floating around as an introduction to haskell
00:56:09 <jle`> there's also a neat tutorial aboout writing an LLVM code generator/compiler in haskell for a toy language
00:56:24 <jle`> it might be a bit less of a "day 1" project though
00:56:29 <nilg> Assume l is a list of 3 arguments, it seems the following code is not valid, why? [e1,e2,e3] = l
00:56:30 <jle`> if compilers are what interests you
00:56:51 <simpson> nilg: How is it not valid? What kind of error message do you get?
00:56:55 <jaseemabid> I recently worked on a foss python tool called colander - A serialization/deserialization/validation library for strings, mappings and lists, and realized how much python suck at that job because it doesn't have static types. Inclined towards learning type system of haskell well.
00:57:09 <nilg> simpson: parse error on input `='
00:57:12 <jle`> > let [e1,e2,e3] = [1,2,3] in (e1, e2, e3)
00:57:14 <lambdabot>  (1,2,3)
00:57:15 <simpson> > let [e1, e2, e3] = [1, 2, 3] in e1 -- it should work...
00:57:16 <lambdabot>  1
00:58:02 <jle`> i don't think you are allowed to pattern match like that at the top level, if that is what you are trying to do
00:58:11 <simpson> nilg: Ah. Could you pastebin some of your code at lpaste.net?
00:58:18 <simpson> Sounds like just a syntax problem.
00:58:33 <jaseemabid> jle` Thank you. If haskell is good for some compiler related stuff, I'd like to go in that direction. trap_exit I'd look into a log search solution too ;)
00:58:58 <xificurC> I'd like to write some documentation for a process. I'd love to write it as plaintext and have the ability to convert it to a pdf or html, with the ability to make changes to the style of the exports
00:59:11 <xificurC> the question - is markdown and pandoc a good option for this?
00:59:34 <jle`> jaseemabid: i don't know anything that i enjoy writing compilers in more than haskell, if that means anything
00:59:44 <nilg> simpson: I just had forgotten the let :')
00:59:47 <jle`> xificurC: i have historically used md and pandoc for things like that
00:59:49 <jaseemabid> xificurC: If you are an emacs user, org-export is really really good at that.
01:00:12 <xificurC> yeah I have org and md in my mind
01:00:29 <xificurC> I don't know what is an easier choice
01:00:34 <jle`> jaseemabid: a command line game might be a fun first or second project.  or, if you want to dig into gritty real world stuff, a chat server
01:00:34 <simpson> nilg: Ah, no worries.
01:00:38 <jaseemabid> xificurC: Why md? Just write .org
01:00:42 <jle`> since you have been doing networking
01:01:29 <jle`> but i think building a compiler or parser is one of those projects that gets your feet wet into several aspects of haskell programming
01:01:42 <jaseemabid> jle` A chat server with raw sockets? is haskell used for low level stuff much?
01:01:50 <jle`> yes it is
01:01:52 <xificurC> jaseemabid: well md seems to be `in` so I thought it might have more options and future in general
01:01:58 <xificurC> if thats not the case I can stick to org
01:02:00 <jle`> i can't imagine using anything other than haskell for low level stuff
01:02:09 <jle`> (a slightly exaggerated and facetious statement, to prove a point ;) )
01:02:15 <jle`> s/prove/make
01:02:15 <xificurC> i used org-mode a bit, didn't use md at all yet
01:02:56 <jle`> the reason is because haskell provides you with the power of low-level programming, with a lot of safety and expressiveness
01:03:01 <jle`> safety that you can't get in other languages
01:03:38 <jaseemabid> I find the haskell grammar to be more complex.  I'll try to implement "the micromanual for lisp" in haskell to start with.
01:03:48 <barrucadu> xificurC: IME, org-mode has more features than Markdown; however for documentation I use Markdown because (1) it has enough features, and (2) it's more widely-known than org-mode
01:04:02 <jle`> i wouldn't write a haskell compiler, though, if that's what you are saying :)
01:04:31 <jle`> here is the scheme tutorial, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
01:04:32 <jaseemabid> jle` I'll write a micro lisp, lisp -> haskell probably.
01:04:39 <trap_exit> jaseemabid: other things you can look into include:
01:04:47 <jle`> haskell implementation is notoriously difficult
01:04:52 <trap_exit> 1) an app which allows people using cellphones to message each other
01:05:05 <trap_exit> 2) a web site which allows peopel to post pictures of themself, intereests, and friends
01:05:09 <xificurC> ok, thanks for your input jle`, jaseemabid and barrucadu :)
01:05:11 <jle`> for many reasons
01:05:16 <jle`> just a warning :)
01:05:28 <trap_exit> 3) a phone app where people can send each other self-deleting images
01:05:41 <jle`> np! and happy haskelling :)
01:05:51 <jle`> we're always here to help.  #haskell-beginners is nice too
01:09:56 <trap_exit> #php is great too
01:10:02 <trap_exit> provides motivation to learn more haskell when the going gets though
01:10:50 <jaseemabid> trap_exit been there, done that, got the tshirt too
01:50:13 <tetra_> hi
01:55:54 <trap_exit> hi
01:59:06 * hackagebot engine-io 1.1.1 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.1.1 (OliverCharles)
01:59:08 * hackagebot socket-io 1.1.0 -   http://hackage.haskell.org/package/socket-io-1.1.0 (OliverCharles)
01:59:44 <professorlamp_> hellooo
02:10:57 <Arn-Hack3ur> hi
02:11:58 <dv-> i'm learning c and i have to say that after years of haskell it's really refreshing
02:13:07 <quanticani> inb4 refreshing desert
02:14:10 * hackagebot engine-io 1.1.2 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.1.2 (OliverCharles)
02:24:11 * hackagebot limp 0.1.0.0 - representation of Integer Linear Programs  http://hackage.haskell.org/package/limp-0.1.0.0 (amosrobinson)
02:24:13 * hackagebot limp-cbc 0.2.8.6 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.2.8.6 (amosrobinson)
02:34:42 <jaseemabid>  
02:34:42 <jaseemabid> [Thu Aug 28 2014]
02:34:42 <jaseemabid> *** Topic for #haskell: http://www.haskell.org/ | Paste code/errors:
02:34:42 <jaseemabid>     http://lpaste.net/new/haskell | Logs:
02:34:47 <jaseemabid>     http://tunes.org/~nef/logs/haskell/?C=M;O=D
02:34:50 <jaseemabid>     http://ircbrowse.net/day/haskell/today?mode=recent | Administrative
02:34:53 <jaseemabid>     issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF            [11:42]
02:34:54 <jaseemabid> *** #haskell: topic set by glguy, 2014-08-16 01:59:35
02:34:57 <jaseemabid> *** Users on #haskell: jaseemabid Wertax_ ulfdoz jrm2k6_ lfairy takuan jiggler
02:35:02 <jaseemabid>     fumieval jasonjckn eddd TititaTitutu Dre3ml0r_ juhp aib tech2 Rakkin
02:35:05 <jaseemabid>     Sixmsj superlinux-hp aaron891_ oish amosr_ koi startling saikrishna cbou
02:35:06 <jaseemabid>     slomo cespinoza trout-senpai jophish__ hellangel7 hamid Guest54235
02:35:09 <jaseemabid>     phyrex1an jordanl hiroakip Cale dpwright josephcs AfC rtpg kyb3r_ artymis
02:35:12 <jaseemabid>     pgokeeffe everett vmeson lpvb codeburg M-ou-se_ danvet ninedotnine fabe
02:35:53 <juhp> :)
02:40:23 <adas> i can do 0x100 and 0o232 for hexa and octa numbers. how do i specify binary?
02:41:17 <schubam> adas: start with a 0
02:41:57 <adas> oh.. thanks
02:42:04 <adas> > 01001
02:42:05 <lambdabot>  1001
02:42:15 <trap_exit> http://erlang.org/pipermail/erlang-questions/2014-August/080717.html .. oh shit, in languages like erlang/haskell, _legacy_ code are _more stable_ due to purity
02:42:16 <trap_exit> damn
02:43:01 <adas> schubam: don't think it works
02:43:33 <schubam> adas: sorry, I just checked again, too. Remembered it wrongly. sorry.
02:44:39 <supki> adas: there's no built-in support for binary integer literals
02:44:49 <supki> (until 7.10 at least)
02:45:06 <supki> there are quasiquoters, I think
02:49:15 * hackagebot argparser 0.3.3 - Command line parsing framework for console applications  http://hackage.haskell.org/package/argparser-0.3.3 (sbergot)
03:04:19 * hackagebot uhc-util 0.1.3.8 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.8 (AtzeDijkstra)
03:19:31 <SPLOOCH> >0b100
03:20:05 <SPLOOCH> > 0b100
03:20:06 <lambdabot>  Not in scope: ‚Äòb100‚Äô
03:23:23 <halvorg> Hi, I'm using scotty and scotty-tls. It seems to work just fine, but I get these printlines on every request received:
03:23:30 <halvorg> data: end of file
03:23:32 <halvorg> ultraInterp: send: resource vanished (Broken pipe)
03:23:57 <halvorg> anyone have an idea what it means? ultraInterp is the project name
03:27:21 <osa1> I'm getting "hGetContents: invalid argument (invalid byte sequence)" and I believe this is because of file encoding(latin1). is there a way to somehow detect file encoding and read it accordingly?
03:27:59 <trap_exit> oh whoa
03:28:02 <trap_exit> I just realized how pretty typeclasses are
03:28:07 <trap_exit> not just for overloading ops
03:28:10 <trap_exit> but for all tyeps of cool tricks
03:29:47 <SPLOOCH> osa1: not really. if you don't expect a certain encoding you should treat it as just bytes.
03:29:50 <osa1> okay apparently I can't detect it
03:30:04 <osa1> right
03:30:28 <osa1> as a second question I'd like to convert "Prelude.read: can't read" error to something more meaningful, any ideas how to catch it?
03:32:00 <pjdelport> :t readMaybe
03:32:02 <lambdabot> Not in scope: ‚ÄòreadMaybe‚Äô
03:32:58 <pjdelport> :t readList
03:33:01 <lambdabot> Read a => ReadS [a]
03:33:17 <osa1> is this in safe package?
03:33:27 <pjdelport> :t let readMaybe = listToMaybe . readList in readMaybe
03:33:29 <lambdabot> Read a => String -> Maybe ([a], String)
03:34:32 <osa1> whatever. I'll just use readMay from safe package
03:35:21 <pjdelport> That should be good, yeah :)
03:40:07 <Cale> :t reads
03:40:09 <lambdabot> Read a => ReadS a
03:40:52 <Cale> type ReadS a = String -> [(a, String)]
03:41:29 <Cale> The list will be empty if there are no parses, and nonempty (usually with just a single element) otherwise.
03:42:15 <Cale> > reads "56" :: [(Integer, String)]
03:42:16 <lambdabot>  [(56,"")]
03:42:21 <Cale> > reads "56apple" :: [(Integer, String)]
03:42:22 <lambdabot>  [(56,"apple")]
03:42:28 <Cale> > reads "x56" :: [(Integer, String)]
03:42:30 <lambdabot>  []
03:49:26 * hackagebot foldl 1.0.6 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.6 (GabrielGonzalez)
03:49:40 <RedNifre> > help
03:49:42 <lambdabot>  Not in scope: ‚Äòhelp‚Äô
03:50:05 <RedNifre> > json $ [1,2,3]
03:50:06 <Haskellfant> @help
03:50:06 <lambdabot>  Not in scope: ‚Äòjson‚Äô
03:50:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:50:25 <RedNifre> @help help
03:50:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:50:34 <RedNifre> @help list
03:50:35 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:50:53 <RedNifre> @help list json
03:50:53 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:51:02 <RedNifre> @list json
03:51:03 <lambdabot> No module "json" loaded
03:51:08 <RedNifre> @list aeson
03:51:08 <lambdabot> No module "aeson" loaded
03:51:25 <RedNifre> @help hey lambdabot, is it possible to load a module into you?
03:51:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:51:35 <Haskellfant> > toJSON [1,2,3]
03:51:37 <lambdabot>  Not in scope: ‚ÄòtoJSON‚Äô
03:51:38 <RedNifre> I am disappointed
03:53:09 <RedNifre> On a more serious note, is there an easy way to convert a data to JSON? I write a lot of data bla, "bla" .= bla. For example, in Java + GSON, you only specify the data and it just works (tm).
03:53:25 <Haskellfant> http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html#t:ToJSON
03:54:26 <RedNifre> Thanks.
03:55:12 <Haskellfant> RedNifre: you can also let ghc derive ToJSON for you
03:55:49 <RedNifre> That sounds even better, how to do that?
03:56:15 <Iceland_jack> RedNifre: It's described on that page
03:56:17 <RedNifre> ...or is that the Data.Aeson.TH thing?
03:56:23 <Iceland_jack> no, you use Generics
03:56:37 <Iceland_jack> and
03:56:37 <Iceland_jack>     instanec ToJSON <your datatype>
03:56:40 <Iceland_jack> *instance
03:56:45 <Iceland_jack> and that's it
03:57:11 <RedNifre> okay, I thought Haskellfant meant another option that wasn't mentioned on that page. I'll figure it out...
03:57:12 <doismellburning> that feels a bit magic
03:58:12 <Iceland_jack> Generic programming is a bit magic
03:59:18 <RedNifre> To me that's convention over configuration and "Don't repeat yourself". I think it's much better than writing ToJSONs that are just "bla" .= bla , "bleh" .= bleh, "meh" .= meh
04:05:59 <doismellburning> RedNifre: understandable
04:27:18 <nilg> I'd like to create a random generator that output [Bool] but biased (where I can specify the probability of getting True or False at the random generator creation)
04:28:36 <doismellburning> nilg: so f :: Bias -> Count -> Random [Bool] (where Bias is some probability, Count is a non-negative integer)?
04:28:42 <mikusp> Hi. I'm trying to compile GHC from sources. I've cloned repo from Github, checkouted tag ghc-7.8.3.-release, run the usual sync-all, boot, configure and make. While compiling stage2 compiler, I get this error http://lpaste.net/110133 . What can be the reason for this? I'm using GHC 7.8.3 installed in my system to bootstrap.
04:31:08 <nilg> doismellburning: yes, exactly, I'm reading the System.Random manual ATM moment, but as I'm very new to Haskell, it's gonna take a while me to figure out how to do that (though I'm sure it's very simple)
04:40:03 <mskow>  /msg NickServ REGISTER Kiitos010 mskowr@gmail.com
04:40:32 <jkarni> nilg: generate a random Double/Int, if it's less than the probability, return True, otherwise, return False?
04:42:07 <nilg> jkarni: that was my thought, but I was wondering if there is a more elegant way
04:44:51 <jkarni> nilg: that doesn't seem particularly inelegant to me - maybe we have different aesthetic sensibilities!
04:46:22 <nilg> or perhaps we have the same, but you see Haskell with a better resolution, while I just see a big fog ;-)
04:46:26 <nullremains> mskow: you might want to change your password
04:48:14 <pjdelport> nilg: How do you represent the probability?
04:48:54 <jkarni> nilg: there are more advanced techniques for describing probability distributions, but I doubt they're worth getting into in the case of i.i.d. Bools
04:49:35 * hackagebot twitter-conduit 0.0.5.8 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.8 (TakahiroHimura)
04:55:13 <chrisdone> does this function exist anywhere? sandbox :: MonadState s m => m a -> m (a,s)
04:58:24 <quanticani> :t liftM2 (,) get
04:58:26 <lambdabot> MonadState a1 m => m a2 -> m (a1, a2)
05:00:17 <lpaste> chrisdone pasted ‚Äúsandbox‚Äù at http://lpaste.net/110134
05:04:21 <chrisdone> sort of similar to Reader's `local' in that it delimits a changed local scope that doesn't affect the outer
05:19:32 <kamatsu> who's familiar with pipes? I have a quick question
05:19:59 <pjdelport> kamatsu: Best just to ask the question.
05:20:06 <pjdelport> :)
05:20:35 <kamatsu> i want to yield everything in a producer from inside a pipe
05:20:50 <brill> What's to be done if two packages in cabal can't be installed at the same time. authenticate-oauth and lens seems to be conflicting.
05:21:03 <kamatsu> but if I try and just go for myProducer yield it gives me a weird type error that's difficult to understand
05:21:19 <edwardk> brill: which one wants the older dependency?
05:21:26 <bergmark> brill: send a pull request to update the outdated one
05:21:28 <kamatsu> I think it's because `for` is trying to create a producer but I'm writing a pipe.
05:22:16 <edwardk> if lens is putting restrictive upper bounds on things, we'd consider that a bug
05:22:30 <edwardk> so if it is us, let us know
05:22:33 <dcoutts_> brill: if you only need them installed at the same time, and don't need to use them together in one app, then you can just use a sandbox for one or the other or both
05:27:13 <kamatsu> I think i could make it work if there was a way to convert a Producer to a (polymorphic) Producer'
05:30:36 <brill> edwardk: when just installing the newest version of authenticate-aouth (and nothing else) and then lens, the lens install breaks authenticate-oauth-1.5
05:31:19 <brill> The only option is a force-install. But that is not an option. And yes I need it in the same app.
05:33:05 <nilg> is there a forM that takes 2 lists of inputs instead of one?
05:33:19 <brill> edwardk: lens install also breaks http-client-0.3.7.2 - the version that comes with authenticate-aouth.
05:33:26 <brill> edwardk: How do I report it?
05:34:33 <nilg> Wow, hoogle has answered my question!!!! :)
05:35:39 <trap_exit> nilg: isn't hoogle awesome ?
05:35:47 <trap_exit> nilg: the first time I used it, I was like "for the first time in my life, google sucks"
05:36:34 <Tuplanolla> Google is pretty terrible for anything programming related.
05:36:36 <pjdelport> @remember trap_exit isn't hoogle awesome? the first time I used it, I was like "for the first time in my life, google sucks"
05:36:36 <lambdabot> Good to know.
05:37:44 <Tuplanolla> Even simple things like looking for C instead of C++ is difficult since -C++ discards every result that even hints of C++.
05:46:54 <edwardk> brill: if you go to install both at the same time, cabal install lens autheneticate-oauth   -- what complains?
05:47:09 <edwardk> brill: things installed in series lead to all sorts of thrashing
05:48:19 <brill> edwardk: I haven't installed it in series. But should I do so?
05:49:02 <edwardk> brill: um, by installing one after another is what i mean by installing it in series
05:49:09 <edwardk> try installing them simultaneously like i mentioned above
05:49:20 <edwardk> that should tell you what is causing the breakage
05:49:27 <brill> edwardk: Ok. I'll try that.
05:49:32 <edwardk> rather than whoever goes second getting blamed for everything
05:55:33 <zmbmartin> I have some packages installed in ~/.cabal but ghc-pkg does not recognize those so ghc-pkg list and ghc-pkg unregister do not work. Do I need to configure ghc-pkg?
05:55:52 <MagneticDuck> uhm. anybody know if there's a synonym for "none id", so I don't have to write "(not . and)"? :D
05:56:28 <dcoutts_> zmbmartin: if ghc-pkg doesn't know about them then they're effectively not installed, you can use cabal to install them again (it will also consider them as not installed).
05:56:29 <MagneticDuck> ^ another silly pedantic search for a trivial function
05:56:54 <gaze__> hey guys, what's this '[xyz] syntax?
05:56:55 <kamatsu> i solved my problem by running the producer as a transformer on top of my pipe, and having a consumer that yielded to the base pipe monad.
05:56:59 <gaze__> it seems like a list kind?
05:57:05 <kamatsu> so my question is no longer open :)
05:57:42 <zmbmartin> dcoutts: cabal says they are installed. When I cabal info a package it shows the version installed.
05:58:07 <Tuplanolla> Do you have extensions in use, gaze__?
05:58:25 <MagneticDuck> gaze__: context? (just got here, maybe I'm just missing it)
05:59:02 <gaze__> Prelude> :k '[Int] -- '[Int] :: [*]
05:59:10 <gaze__> what is this and where is it documented?
05:59:26 <MagneticDuck> [*]?
05:59:31 <MagneticDuck> not familiar with that O.o
06:00:28 <MagneticDuck> gaze__: wait, hold up, are you just learning haskell or are you facing something complicated that I know nothing about?
06:01:06 <MagneticDuck> oh, never mind, you're facing something complicated I know nothing about
06:01:46 <gaze__> MagneticDuck: it's likely not that complicated but also something a total beginner wouldn't face
06:01:58 <Axman6> @hoogle Read a => String -> Maybe a
06:02:00 <MagneticDuck> well all I know is it involves the datakinds extension
06:02:03 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
06:02:04 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
06:02:04 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
06:02:12 <MagneticDuck> and I shy away from all those cool language extensions :(
06:04:28 <jkarni> gaze__: I believe the tick is to distinguish data constructors from type constructors when DataKinds is enables
06:04:39 <jkarni> gaze__: s/enables/enabled
06:04:42 <Tuplanolla> I'd also like to know where extensions are documented.
06:05:31 <jkarni> gaze__: https://www.haskell.org/ghc/docs/7.4.2/html/users_guide/kind-polymorphism-and-promotion.html
06:05:43 <jkarni> gaze__: section 7.8.2.1
06:06:45 <mikusp> I'm trying to compile GHC from sources. I've cloned repo from Github, checkouted tag ghc-7.8.3.-release, run the usual sync-all, boot, configure and make. While compiling stage2 compiler, I get this error http://lpaste.net/110133 . What can be the reason for this? I'm using GHC 7.8.3 installed in my system to bootstrap.
06:06:55 <jkarni> gaze__: and the [] is just the promoted constructor itself
06:07:50 <brill> edwardk: Ok. An install in a series worked fine. So no problem, I guess. Thank you!
06:08:16 <edwardk> brill: terminologically i'd call that installing them at the same time. you seem to have inverted the sense of what i was trying to call it =)
06:09:10 <exio4> @kind 'Just '[Maybe [Int]]
06:09:11 <lambdabot>     Illegal type: ‚Äò'[Maybe [Int]]‚Äô
06:09:11 <lambdabot>       Perhaps you intended to use DataKinds
06:09:24 <exio4> :(
06:10:53 <brill> edwardk: You're right. I guess cabal can make some qualified guesses as to manipulate versions when it has the full picture.
06:11:43 <brill> edwardk: All I know is that a cabal install authenticate-aouth ; cabal install lens doesn't work.
06:11:54 <MagneticDuck> is there any particular reason that it is common practice to typecast everything except 'main'?
06:12:33 <brill> edwardk: But thanks for your time. Where else but #haskell can you talk to the maintainer himself just like that? :-)
06:12:36 <edwardk> brill: for that i'd need to see what was being complained about by cabal. not sure what versions got picked by things
06:13:32 <edwardk> MagneticDuck: typecast?
06:13:33 <brill> edwardk: I could send you that to your email.
06:13:54 <edwardk> brill: or throw it up as an issue on github.com/ekmett/lens/issues so others can see it and comment
06:14:09 <MagneticDuck> edwardk: uh, type.. apply
06:14:16 <MagneticDuck> ugh, I'm always incorrect with that terminology
06:14:22 <MagneticDuck> specify the type of
06:14:30 <edwardk> i can't promise it won't get closed out as a non-issue, but it'd get looked at at least
06:14:36 <MagneticDuck> yeah, typecast is something completely different
06:15:14 <barrucadu> MagneticDuck: It's also fairly common to specify the type of main
06:15:31 <edwardk> MagneticDuck: top level function signatures are considered good form for 2 reasons, we have language features that actually need type signatures to typecheck occasionally, and they are good documentation. its much easier to check that you got it right when you wrote the function than later 8 functions in when you go to use it
06:15:40 <barrucadu> Specifying the type of all top-level definitions gives the compiler more context to work with, and also acts as documentation
06:15:45 <barrucadu> heh, edwardk beat me to it
06:15:57 <brill> edwardk: Ok. I'll do that.
06:15:59 <edwardk> so your code typechecks faster and is more likely to be correct
06:16:00 <MagneticDuck> edwardk: I got that
06:16:03 <MagneticDuck> yeah
06:16:10 <edwardk> and you get documentation
06:16:15 <edwardk> so there isn't much downside
06:16:21 <MagneticDuck> I have no issue with that
06:16:58 <MagneticDuck> but I've heard from some sources that it's kinda not a good thing to do for some reasont to specify the type of main
06:17:11 <MagneticDuck> ... just curious what would make some people say that?
06:18:53 <edwardk> MagneticDuck: that makes no sense to me =)
06:19:12 <MagneticDuck> nor to me >_>
06:20:56 <gaze__> Hey, what's 'blah' should have kind 'OpenKind' mean?
06:25:59 <brill> edwardk: I've added an issue to lens in github.
06:26:04 <edwardk> thx
06:30:17 <trap_exit> is there a way, in haskell, to say "anytime you want an object of type FOO", and I have an object of type "Bar", try to call "to__Foo" (which is a function of "class To_Foo")
06:30:31 <trap_exit> i.e. if I have a Bar, but it's expecting a Foo, check if there is an instance of "instance To_Foo Bar"
06:30:33 <trap_exit> and if so, auto convert it
06:31:50 <bergmark> trap_exit: you can change your function to take a `ToFoo f => f' arg instead of `Foo' and add an identity instance for Foo
06:32:30 <trap_exit> this still requires that I call to__Foo, no ?
06:32:33 <trap_exit> I want to not even ahve to call to_Foo
06:32:59 <trap_exit> https://gist.github.com/anonymous/a15c6c91b222ef1da928 <-- core
06:33:06 <trap_exit> so my goal is to avoid calling to__Foo
06:33:13 <trap_exit> but I feel like under oyur suggestion, I still ahve to call to__Foo
06:33:18 <trap_exit> gergmark: ^
06:33:20 <Twey> trap_exit: Well, what you can do is define your Foo functions to be on ToFoo instead.  Then you don't need to call toFoo explicitly.  lens does this, for example, with makeClassy.
06:34:21 <bergmark> trap_exit: do you think implicit type conversions is a good idea?
06:35:41 <trap_exit> https://gist.github.com/anonymous/12ce843b261411650f05 <-- this is my full question <-- Twey , bergmark
06:35:59 <trap_exit> bergmark: I don't know, but I feel like I can only know after trying it and seeing whether it amkes code more concise or harder to read
06:36:14 <trap_exit> Twey: can you tell me what you mean tby define function on ToFoo ? I don't see how toa void the to__Foo call
06:36:19 <bergmark> trap_exit: yes it makes it more concise, yes it makes it harder to read ;-)
06:36:32 <trap_exit> bergmark: the important question is: is it possible? :-)
06:37:01 <MichaelBurge> What would you guys think about allowing trailing commas in lists, tuples, module exports, and imports?
06:37:32 <trap_exit> I thikn module exports already have trailing commas
06:37:37 <trap_exit> otherwise I don't know how some of my code is compiling
06:37:40 <Twey> trap_exit: Instead of writing functions Foo ‚Üí Baz, you write functions ToFoo f ‚áí f ‚Üí Baz, as bergmark said.
06:37:43 <dmwit> MichaelBurge: I'm general in favor of allowing extra commas in funny places, but keep in mind there's TupleSections to be careful of.
06:38:16 <trap_exit> Twey : ah, the unicode char makde everything clearer
06:38:30 <trap_exit> this is soooo cool
06:38:42 <bergmark> trap_exit: i don't think you can do it implicitly, at some point you have to choose HOW you want to convert between the types
06:38:43 <Twey> trap_exit: Then whenever you want to call a ‚ÄòFoo‚Äô function, you just call one of the methods from ToFoo instead.
06:38:56 <trap_exit> Twey : yesh, I see how this works now, rewriting my code this way
06:38:58 <Twey> trap_exit: This is, of course, a terrible idea.  :√æ
06:39:01 <Twey> Please don't
06:39:05 <trap_exit> what?
06:39:09 <trap_exit> this is an awesome idea
06:39:21 <trap_exit> I have a bunch of data structures, all of which can be auto-converted into svg dom trees
06:39:21 <Twey> trap_exit: You can write PHP in Haskell, but everyone would rather you didn't.
06:39:39 <trap_exit> Twey: you forget the haskell motto "avoid success at all costs"
06:39:55 * trap_exit learns to not touch stoves by getting burned
06:40:00 <Twey> No, we lost that one a long time ago.  The buck's passed to Agda, or Idris, or something.
06:40:09 <bergmark> MichaelBurge: -1, format your code so it's obvious to see if you've forgotten an item (e.g. utrecht style)
06:40:46 <Hodapp> utrecht style?
06:40:49 <MichaelBurge> trap_exit: thanks for the tip
06:41:06 <trap_exit> MichaelBurge: ?? I don't think I helped you
06:41:24 <trap_exit> oh, trailing commas
06:41:25 <trap_exit> you're welcome
06:41:38 <kruchy> @pl angler (tmpx,tmpy) (wx,wy) = (180/pi) *  atan2 (tmpx - wx) (tmpy - wy)
06:41:38 <lambdabot> angler = uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . ((((180 / pi) *) .) .)) .) . (. (-)) . flip . (((.) . atan2) .) . (-))
06:41:43 <bergmark> Hodapp: http://lpaste.net/110139
06:42:34 <trap_exit> Twey: you know, what I hate about this new style
06:42:43 <trap_exit> is that I used to be able to read top level type declarations an dundestand hwat's going on
06:42:49 <trap_exit> now, it's a but more opaque
06:42:57 <trap_exit> s/but/bit/
06:43:02 <Hodapp> bergmark: I'm just finding very little reference to that name, that's all.
06:43:59 <Hodapp> https://github.com/jaspervdj/stylish-haskell/issues/22 is the only reference I'm finding so far, which you posted in.
06:44:05 <bergmark> ;-)
06:44:17 <bergmark> we'll i'm pretty sure i didn't make it up at least!
06:44:39 <bergmark> maybe my colleagues from utrecht did
07:04:51 <augustss> Howdy
07:05:07 <dp_wiz> Is there a nice LRU cache with automatic expiration?
07:07:08 <edwardk> heya
07:07:27 <edwardk> dp_wiz: not prepackaged that i know of
07:07:47 <augustss> edwardk, will you come to ICFP?
07:08:00 <edwardk> i'll be there. i fly out tomorrow afternoon
07:08:18 <augustss> great
07:08:24 <edwardk> I got stuck running CUFP this year, so i have to come. =)
07:08:32 <augustss> Ah, yes.
07:09:13 <edwardk> I suppose given that it is basically in your backyard that we'll see you there. ;)
07:09:50 <augustss> I'll be there.  Staying a few days at the hotel, commuting the rest.
07:12:56 <gaze__> http://lpaste.net/110144 Any idea what's going on here?
07:13:06 <dp_wiz> Hm... Looks like i should build my own cache with psqueues and expiration thread strapped to its side.
07:13:09 <gaze__> I don't understand the use of sig0
07:13:40 <luite> gaze__: add forall sig.
07:14:17 <gaze__> ohhoho you saucy minx
07:14:18 <gaze__> thanks!
07:14:47 <edwardk> dp_wiz: its fairly easy to build one on a priority search queue
07:14:55 * hackagebot semver 0.1.0 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.1.0 (BrendanHay)
07:14:57 <gaze__> are implicit type variables not automatically bound?
07:15:10 <edwardk> dp_wiz: if you want approximate expiration there are faster ways, but if you just need something quick that'll get you bootstrapped
07:15:22 <gaze__> do you have to forall them to get them to bind over their inner scope?
07:15:54 <augustss> If you means inside the function body, then yes.  You need a forall.
07:16:39 <edwardk> gaze__: ScopedTypeVariables are something you have to turn on, and then you need to use an explicit forall to explicitly request them to be bound in nested scopes, otherwise there are all sorts of non-trivial ways that they'd change the meaning of well formed programs
07:17:47 <augustss> The way it works be default was a design mistake in Haskell, but we are stuck with it now.
07:25:16 <nshepperd> hmm, queuelike doesn't seem to build with recent base
07:25:29 <nshepperd> conflicts with toList in GHC.Exts
07:27:33 <nshepperd> grump
07:27:44 <philandstuff> hello. I'd like to convert an ip address in string form to a HostAddress. I've found the inet_addr fn but its type is String -> IO HostAddress. does anyone know why it uses IO and why it can't just be pure String -> HostAddress?
07:29:04 <pjdelport> philandstuff: inet_addr does a lookup, i think
07:29:31 <edwardk> philandstuff: if you are offline when the first lookup fails how do you retry in the model you want?
07:29:43 <SwashBuckla> why are there types Product and Sum in Data.Monoid? I only ask as they seem a little... useless
07:30:16 <Saizan> because of the Monoid instances they have
07:30:18 <barrucadu> SwashBuckla: Because there are two (obvious) different monoids for integers
07:30:21 <pjdelport> philandstuff: http://hackage.haskell.org/package/iproute seems to have a reasonable IPv4 address type
07:30:38 <augustss> I don't think inet_addr does a lookup.
07:30:47 <SwashBuckla> barrucadu: but we have * and +
07:30:58 <edwardk> SwashBuckla: they are quite useful when it comes to implementing passes over data in parallel.
07:31:04 <barrucadu> SwashBuckla: Yes, but if you try to define a Monoid instance for Int, you have to pick one of those
07:31:20 <edwardk> SwashBuckla: there are a lot of tools that work with Monoid specifically
07:31:31 <edwardk> SwashBuckla: they are used to sort of match up against that API
07:31:32 <SwashBuckla> barrucadu: ah ok
07:31:37 <Hafydd> > (mconcat $ map Product [1..6], mconcat $ map Sum [1..6])
07:31:39 <lambdabot>  (Product {getProduct = 720},Sum {getSum = 21})
07:31:48 <philandstuff> edwardk: why would being offline stop me converting 1.2.3.4 to a Word32?
07:31:56 <philandstuff> pjdelport: ooh thanks I'll have a look
07:32:11 <barrucadu> philandstuff: It calls the C function inet_addr, and the FFI makes it live in IO
07:32:19 <pjdelport> philandstuff: http://hackage.haskell.org/package/iproute-1.3.1/docs/Data-IP.html specifically
07:32:22 <augustss> philandstuff I don't think it should be in IO.  It should return Maybe HostAddress
07:32:31 <philandstuff> barrucadu: that makes a lot of sense
07:32:45 <edwardk> philandstuff: hrmm inet_addr should probably just work actually.
07:32:51 <SwashBuckla> > foldr (*) 1 [1..6]
07:32:53 <lambdabot>  720
07:33:03 <Hafydd> If it can cause a DNS lookup, that seems like IO.
07:33:11 <edwardk> Hafydd: it doesn't
07:33:15 <philandstuff> wow, that was a fantastic first impression of #haskell. thanks everyone, all very useful
07:33:17 <SwashBuckla> > (foldr (*) 1 [1..6], sum [1..6])
07:33:18 <augustss> But it shouldn't do a lookup.
07:33:19 <lambdabot>  (720,21)
07:33:36 <Hafydd> Yes, my example was quite contrived.
07:33:57 <barrucadu> I guess it was easier to use inet_addr from socket.h in the initial implementation, and it's never been changed
07:33:59 <Hafydd> Doesn't it? I see
07:34:33 <barrucadu> It also throws an IOError if the address is malformed
07:34:36 <edwardk> philandstuff: if you wanted to pursue this feel free to put something forward to the libraries@ mailing list, at least asking for why that needs to live in IO. while it may be too late to change that call (or it might not) a pure variant should surely be possible
07:34:43 <augustss> The FFI call to inet_addr needs a well placed unsafePerformIO.  This is a legitimate use.
07:34:52 <kqr> SwashBuckla, the monoid instances are very useful for writing code like getSum (foldMap (Sum . length) ["hello", "world"])
07:35:11 <kqr> SwashBuckla, without those, you'd have to do two passes (which might or might not get fused, and either way is less clear in intention)
07:35:41 <philandstuff> edwardk, augustss: thanks. I'm quite new to haskell so I don't really feel I understand it well enough to submit anything
07:36:34 <augustss> philandstuff But your initial impression was right.  It doesn't have to be in IO.
07:37:44 <edwardk> it looks to me that it was put in IO because it was the easiest way to call it
07:37:55 <edwardk> as it wraps with withCString, etc.
07:42:34 <edwardk> philandstuff: i posted a request for discussion to the libraries mailing list
07:42:47 <OMN0M> Hi if anyone has a moment, I am trying to install Haskell correctly on Ubuntu and I can get 1.8 installed but No matter what version I get: cabal sandbox unrecognied command
07:43:10 <edwardk> OMN0M: what does cabal -V say?
07:43:45 <OMN0M> using version 1.8.0.2 of the Cabal library
07:44:00 <edwardk> OMN0M: after you run 'cabal install cabal-install' what does cabal -V say?
07:44:04 <Javran> how can I raise a parsing error from Parser in parsec?
07:44:33 <edwardk> Javran: do you just want to 'fail' ?
07:44:37 <Javran> I tried `throwError $ Message "foo"` but it didn't work
07:44:43 <OMN0M> cabal install cabal-instal
07:44:52 <OMN0M> returns: cannot configure cabal-install-1.20.0.3. It requires base >=4.3 && <5
07:44:52 <OMN0M> For the dependency on base >=4.3 && <5 there are these packages: base-4.3.0.0,
07:45:00 * hackagebot http-client 0.3.8 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.8 (MichaelSnoyman)
07:45:16 <edwardk> OMN0M: what does ghc -V say?
07:45:36 <Javran> edwardk: I want to produce something like `Left "error message"` in parse result.
07:45:47 <OMN0M> The Glorious Glasgow Haskell Compilation System, version 6.12.1
07:45:57 <edwardk> OMN0M: the problem is your compiler is from the stone age
07:46:01 <augustss> Javran You can only raise a parsing error when you are totally done parsing.
07:46:31 <Javran> augustss: you meant <?> ?
07:47:11 <edwardk> <?> is used to hint what a failure that doesn't consume anything should consider the current 'expected' thing to be
07:47:41 <edwardk> mzero <?> "cupcakes" will say that you have an error, because it expected cupcakes
07:47:51 <OMN0M> How do I update the compiler?
07:47:53 <Javran> I see
07:47:59 <ion> The cupcake is a lie.
07:48:01 <augustss> Javran: You get the error message back when you use runP (or whetever you use at the top level).
07:48:26 <edwardk> but its not the only way to get an error out of parsec, if you fail, the error message from fail should percolate up as I recall
07:48:41 <barrucadu> OMN0M: Through the package manager. Trusty has GHC 7.6
07:50:09 <ion> omn0m: Here‚Äôs what i do to install GHC. It may or may not be helpful for you. https://gist.github.com/ion1/2815423
07:50:14 <augustss> Javran: If you are just starting with parsec, don't bother adding nice error messages.  Just use the default ones.
07:50:21 <OMN0M> Thank you
07:50:32 <Javran> just out of curious, what does MonadError do?
07:50:46 <barrucadu> OMN0M: Which version of Ubuntu are you on?
07:51:16 <Javran> some exceptions that can be thrown and caught I guess?
07:51:18 <edwardk> Javran: MonadError is used to make it so you can use the same code to throw or handle errors across a wide array of different monad transformers
07:51:28 <OMN0M> I am trying from both Debian and Ubuntu
07:51:41 <OMN0M> Debian is 6 Ubuntu is 14.04
07:52:06 <barrucadu> Even Debian Stable ahs GHC 7.4
07:52:12 <barrucadu> How did you install such an old GHC?
07:52:14 <barrucadu> *has
07:52:26 <edwardk> Javran: however, the 'parse error' in parsec isn't the same as the one handled by MonadError.
07:52:28 <barrucadu> Ah, Squeeze has 6.12
07:52:33 <dfeuer_> Who knows how to get fibon to compile?
07:52:34 <edwardk> Javran: you can get a hint of that by looking at the instance
07:52:42 <OMN0M> So don't use Squeece?
07:52:43 <dfeuer_> I'm getting some kind of failure to load an interface for compression codecs.
07:52:46 <edwardk> MonadError e m => MonadError e (ParsecT s u m)
07:52:50 <barrucadu> Well, Ubuntu should be fine
07:52:58 <dfeuer_> odec/Compression/BZip.hs:58:1:  Failed to load interface for ‚ÄòCodec.Compression.BZip.Internal‚Äô
07:52:58 <OMN0M> Okay let me try
07:52:59 <barrucadu> Unless you're also using a very old version of that
07:53:11 <edwardk> that strongly indicates that throwError or catchError will just delegate to the underlying monad m that your parser works over
07:53:28 <edwardk> Javran: while the backtracking behavior, etc. of parsec is unrelated to m.
07:53:32 * dfeuer_ hands edwardk some kind of utterly paradoxical category.
07:53:49 <Javran> edwardk: I see, thanks!
07:54:29 <RedNifre> Why can't I declare data like this: data Something { bla :: String, blah :: String } ?
07:54:37 <edwardk> Javran: so basically all the MonadError machinery is lifted, because it would be really really hard to write catchError by hand if it wasn't, but isn't for this usecase.
07:55:01 * hackagebot semver 0.1.1 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.1.1 (BrendanHay)
07:55:27 <edwardk> RedNifre: because we like to make you repeat yourself. the two Somethings in data Something = Something { bla :: String, blah :: String }  are very different.
07:55:39 <edwardk> The former is a type, the latter is a data constructor, a value.
07:56:12 <edwardk> the fact that we _can_ pun them at all is only because they live in different worlds
07:56:29 <edwardk> but when you need another parameter where does it go in your notation?
07:56:42 <RedNifre> Right, but why isn't the meaning of "data Something {" defined to be a short notation for "data Something = Something {"?
07:57:47 <edwardk> dfeuer_: Codec.Compression.BZip.Internal has been an exposed module for pretty much all time in the bzlib package
07:57:53 <RedNifre> Another parameter? What do you mean exactly?
07:58:01 <zerokarmaleft> RedNifre: subjective value of syntactic sugar?
07:58:23 <edwardk> RedNifre: because it is a special case that leads to bad intuitions that users quickly outgrow?
07:58:25 <RedNifre> I'm a total beginner and caught myself writing a lot of data Something = Something. Am I doing it wrong?
07:58:31 <Javran> edwardk: I just saw the source code of Control.Monad.Error and I see lift functions everywhere
07:59:02 <edwardk> Javran: I maintain that module so that users don't have to write code that way =P
07:59:32 <edwardk> RedNifre: no you are doing things right, the key is that later on you'll grow to dealing with more abstract data types, where the notation you want doesn't scale at all
07:59:42 <Javran> edwardk: good work, thank you :)
07:59:49 <edwardk> data Something a = Something { bla : a, blah :: a }
07:59:55 <edwardk> where do you do that in your notation?
08:00:50 <RedNifre> Wouldn't that just be data Something a { bla...?
08:01:14 <edwardk> RedNifre: but now you're further conflating the value and the type level
08:02:04 <RedNifre> You mean that the "a" puts too much distance between "Something" and "{"? I think I agree.
08:02:12 <edwardk> and when you need a second constructor? existential quantification? want to write something that isn't a record with this syntax...
08:02:41 <edwardk> RedNifre: consider the fact that users often write things that aren't records, arguably it is the more common case not to have record sugar involved
08:03:13 <edwardk> data Foo a      -- already has a meaning, its a data type that takes one parameter and has no constructors.
08:03:41 <RedNifre> I see. Guess I'll have to learn more Haskell then.
08:03:44 <SrPx> What is the meaning of "type Rep a" here? I've never seem that pattern http://lpaste.net/110146
08:03:46 <SrPx> seen
08:03:48 <edwardk> data Foo a = Foo a a -- has no way to collapse in your notation, the records have become magic in weird ways
08:04:10 <edwardk> SrPx: that is a class associated type
08:04:11 <augustss> RedNifre: What you suggest would be possible, but it wouldn't really save much.
08:04:31 <edwardk> SrPx: it is a special syntax for using type families
08:04:43 <SrPx> edwardk: hmm is it? I'm used to: "type Foo = Synonymous". But there is no "=" there...
08:05:10 <edwardk> SrPx: type Foo = ... is a type synonym, type families are a bigger deal
08:05:25 <SrPx> edwardk: so it is completely unrelated?
08:05:29 <edwardk> more or less
08:05:37 <SrPx> where can I read about it?
08:05:49 <edwardk> if you pull it out of the class the syntax is 'type family Rep a :: * -> *'
08:06:01 <edwardk> thttp://www.haskell.org/haskellwiki/GHC/Type_families
08:07:32 <edwardk> SrPx: they were added back around ghc 6.10, and are needed to do a lot of the fancy stuff behind vector, DPH, etc.
08:07:36 <RedNifre> The whole concept of types, type classes and values is still not clear to me. For example, if I model bank accounts that have a balance and an associated currency, how would I model that you can only add the balances of accounts that have the same currency?
08:08:26 <RedNifre> Being a beginner, my first thought was to have a currencyCode::String in the Account data, but now I wonder if I could somehow have accounts that are typed with a currency.
08:08:29 <edwardk> RedNifre: it depends on how much safety you want to get. you could make the currency part of the type of the account, you could make a money type that carries the currency in its type, etc. there are lots of design options here.
08:08:50 <SrPx> edwardk: I see, thanks. I'm reading about it on the wiki. I wonder where **you** learned it?
08:09:00 <edwardk> if you have currencyCode :: String in the data type you don't get to know that users won't screw up and try to add two account balances together
08:09:37 <edwardk> SrPx: heard about the language feature back in 6.10-6.12 or so, went to use it, failed because of bugs in the implementation, kept trying until it was fixed up enough to use ;)
08:10:06 <RedNifre> edwardk how would you prevent that with the other options?
08:11:41 <edwardk> RedNifre: well, you could do one of several things. you could have a Money data type that carries a phantom type for the currency. You could use a currency typeclass to say something acts like a currency that has Num, etc. as a superclass, but that'd get repetitive in terms of instances and require you to know about how the instances all behaved operationally, etc.
08:11:43 <SrPx> ah... that's convenient.
08:11:48 <RedNifre> Currently, I also have data Currency = Currency { id::String, name:String}. I could put those currencies into accounts, but that wouldn't help. I also could change it to Currency = USD(...) | EUR(...) etc, but I still don't see how that prevents people from adding account balances of incompatible accounts.
08:12:41 <MichaelBurge> A parser takes text to some target type a. What's the word for an unparser?
08:12:58 <cschneid> MichaelBurge: printer / prettyprinter / Show?
08:13:04 <RedNifre> Hm. Guess I'll go back to learning for now.
08:13:13 <edwardk> lets consider --   newtype Money currency = Money !Double deriving (Eq, Ord, Num, Fractional, Floating, Real, RealFloat)   -- now you could make up data USD, data Euro -- now Money USD and Money Euro are different data types you can't add together
08:13:16 <edwardk> er
08:13:23 <edwardk> newtype Money currency = Money Double
08:14:01 <edwardk> (12 + 34) :: Money Euro -- works fine, but (12 :: Money Euro) + (34 :: Money USD) -- will fail
08:14:08 <RedNifre> ah
08:15:02 <MichaelBurge> cshneid: yeah, 'printer' works - thanks
08:15:15 <edwardk> we made up our own type of numbers and tagged it with what we wanted to use to ensure its safety, the tag here is phantom so you don't have a _lot_ of security, but it is often enough to just have to think about the conversions where you need them
08:15:18 <cschneid> MichaelBurge: "serializer" maybe too, depending on the format of the output
08:15:28 <cschneid> MichaelBurge: "printer" feels human readable, while "serliaizer" may not be
08:16:05 <RedNifre> So I wouldn't need accounts at all, since a number of type Money Euro is basically the same thing as an account, right?
08:16:30 <cschneid> RedNifre: I imagine accounts have names / address / account numbers / etc... :)
08:16:38 <cschneid> RedNifre: it may be the balance of an account though, yeah.
08:17:06 <RedNifre> nah, there's just one user and accounts are uniquely identified by the bank they belong to and their currencies.
08:17:15 <MichaelBurge> As a followup, Data.Binary is one library I know of that encourages you to write the getter and putter together. Is there a text parser library that does that?
08:17:59 <cschneid> MichaelBurge: aeson and cassava both have getter/putter "near" each other, although they are different typeclasses
08:18:18 <edwardk> RedNifre: then you can probably just get by with something like the Money type above, now the cost of putting it in the type is this will occasionally get in your way. you need container types that know about them, etc. this quickly becomes non-trivial, so think hard before you move an invariant to the type level. it can be rewarding. you learn a lot, you can prove a lot of things, but it does come at a cost
08:18:59 <RedNifre> Since I'm doing this to learn Haskell I guess I'll go for it.
08:19:10 <cschneid> edwardk: that'd prevent a list like [Money] that can be both Euro and USD right?
08:19:28 <augustss> cschneid: yes
08:19:32 <edwardk> cschneid: that is pretty much where it starts to blow up on you
08:19:33 <cschneid> is there a general solution to that kind of use case?
08:20:01 <RedNifre> oh
08:20:12 <augustss> cschneid: you can wrap it in an existential, but then you have trouble taking it out.
08:20:24 <edwardk> cschneid: sure you can look at the commonalities between them and make a data type for that existential case, e.g. they are all Doubles maybe with some description, you can use a horrible existential wrapper, etc.
08:20:25 <cschneid> augustss: ok, I'll read up on that (if only to see how it works).
08:20:26 <RedNifre> That's not that good, since I wanted a bank to have a list of accounts, which I thought could be a list of Money.
08:21:03 <edwardk> RedNifre: honestly? what i'd probably do is just use a Map from currency to balance and not enforce the invariant
08:21:05 <augustss> RedNifre: you'd have to have one list for each currency
08:21:36 <edwardk> and then if i had to go back and revisit it, the difference is probably 10x as much code to enforce the invariant as to just carefully reason it through
08:22:07 <edwardk> it really depends on the usecase how much time i spend on modeling my invariants
08:22:25 <RedNifre> yeah, the map is better anyways. I mean, I don't actually want to have separate accounts with the same currency in the same bank/user
08:23:38 <RedNifre> one more thing, what should I use for money? I mean, double won't work. What's the right number type for financial things?
08:25:05 <cschneid> RedNifre: rational probably
08:25:42 <Hodapp> fixed-point integer, if possible.
08:26:37 <Hodapp> at least, it's oftne handled that way in other languages.
08:26:53 <cschneid> Hodapp: yeah, rational is "fixed point" I think?
08:26:54 <edwardk> RedNifre: depends on the application, usually some kind of fixed precision numeric type unless you really need to calculate fractions of fractions of pennies for technical reasons in your domain
08:26:56 <zmbmartin> shachaf: Regarding the bcrypt how could I not use Data.ByteString.Char8 with it?
08:27:13 <edwardk> rational doesn't work so well for interest =P
08:27:20 <Hodapp> cschneid: I'm not so sure rational counts as fixed point.
08:27:25 <cschneid> yeah, not really
08:27:29 <cschneid> it is arbitrary preceision at least :)
08:27:39 <cschneid> is there a BigNum style builtin?
08:27:51 <nshepperd> handling money exactly is tricky
08:27:52 <augustss> RedNifre: Sadly, a lot of money computations in banks are actually done using Double.
08:27:54 <Hodapp> you don't *want* arbitrary precision with financial, generally.
08:28:18 <cschneid> Hodapp: yeah, although using an underlying arbitrary precision, then explicitly rounding at the right points sounds right?
08:28:31 <SrPx> How can I see a list of every Haskell Wiki article?
08:28:33 <Hodapp> cschneid: that'd be acceptable, provided you get the rounding details right.
08:28:35 <augustss> For instance, Excel uses (horribly hacked) double for ots numbers.
08:29:05 <cschneid> Hodapp: right. if youre core work is finance, then having control over the rounding seems important. But what do I know, I deal with electricity.
08:29:10 <nshepperd> I think normally you decide on a base unit (eg, thousandths of a cent), represent everything with Integers, and then round things to the nearest unit
08:29:46 <RedNifre> This sounds like there isn't something built into Haskell, so if I want to get serious I should probably look for a library.
08:29:47 <nshepperd> when you divide amounts of currency, you use `quot`, and put the remainder into an overflow account
08:30:02 <Hodapp> cschneid: My degree is electrical engineering as well.
08:30:11 <RedNifre> Guess I'll use approxRational to round to %100 for now.
08:30:38 <cschneid> Hodapp: nope, not that. The tricky part is I have no clue on how electricty works. I do programming around smartgrid :)  Which means I have to guess at things I have no training in.
08:31:00 <Hodapp> cschneid: the main thing with finance is that everything has to balance out.
08:31:01 <cschneid> (Demand Response - controlling Air Conditioners / Hot Water Heaters / Etc)
08:31:21 <Hodapp> which rules floating point out, pretty much right away.
08:31:26 <augustss> RedNifre: You can make you library polymorphic in the number type and choose later.
08:33:11 <edwardk> RedNifre: augustss's proposal is pretty much what i do with everything.
08:34:15 <edwardk> once you've parameterized on it, you can use compensated arithmetic, CReal, Double, a fixed precision data type, etc. all with impunity without changing the code. you can test if doubles become a problem with code you have greater assurances for, and decide later
08:35:39 <luite> is there a good/affordable hostel in gothenburg that more ICFPers go to? i haven't booked anything yet
08:36:22 <luite> and i probably don't want to sleep in the car for a week :)
08:37:15 * edwardk heads out
08:38:40 <RedNifre> So what is the minimum data Euro I need so I can write Money Euro?
08:42:01 <nshepperd> if it's a phantom type, "data Euro" :)
08:42:01 <dfeuer_> edwardk, so I just need to install that package (once GHC compiles again)? I want fibon because it uses unfoldr, unlike nofib.
08:45:42 <waterboy_> set dcc_auto_chat 0
08:48:13 <RedNifre> > newtype Money currency :: Money Double
08:48:15 <lambdabot>  <hint>:1:1: parse error on input ‚Äònewtype‚Äô
08:48:46 <RedNifre> > newtype Money currency = Money Double
08:48:47 <lambdabot>  <hint>:1:1: parse error on input ‚Äònewtype‚Äô
08:49:00 <barrucadu> RedNifre: Double is a bad idea for currency, because of floating point imprecision
08:49:17 <RedNifre> I know
08:49:20 <quanticani> @let newtype Money currency = Money Double
08:49:23 <lambdabot>  Defined.
08:49:32 <quanticani> :t Money 0
08:49:33 <lambdabot> Money currency
08:49:35 <RedNifre> When does lambdabot need > and when @?
08:49:39 <vanila> what should you use? rationals?
08:49:45 <quanticani> it uses @ for commands
08:49:51 <barrucadu> Rationals or integers, yeah
08:49:51 <quanticani> "> " is a shortcut for @run
08:50:03 <quanticani> or fixed-point numbers
08:50:06 <RedNifre> @let data Euro
08:50:07 <lambdabot>  Defined.
08:50:19 <RedNifre> > 4.0 :: Money Euro
08:50:20 <lambdabot>  No instance for (GHC.Real.Fractional (L.Money L.Euro))
08:50:20 <lambdabot>    arising from the literal ‚Äò4.0‚Äô
08:50:26 <quanticani> let does definitions, run does expressions
08:51:06 <quanticani> @let deriving instance Num (Money a)
08:51:07 <lambdabot>  .L.hs:170:1:
08:51:07 <lambdabot>      Can't make a derived instance of ‚ÄòNum (Money a)‚Äô:
08:51:07 <lambdabot>        ‚ÄòNum‚Äô is not a derivable class
08:51:07 <lambdabot>        Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension
08:51:07 <lambdabot>      In the stand-alone deriving instance for ‚ÄòNum (Money a)‚Äô
08:51:16 <quanticani> aw
08:51:30 <quanticani> @undefine
08:51:30 <lambdabot> Undefined.
08:52:02 <quanticani> @let newtype Money currency = Money Double deriving (Num, Fractional, Real, Read, Show, Eq, Ord)
08:52:02 <nshepperd> > Money 4.0 :: Money Euro
08:52:03 <lambdabot>  .L.hs:152:34:
08:52:03 <lambdabot>      Can't make a derived instance of ‚ÄòNum (Money currency)‚Äô:
08:52:03 <lambdabot>        ‚ÄòNum‚Äô is not a derivable class
08:52:03 <lambdabot>        Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension
08:52:03 <lambdabot>      In the newtype declaration for ‚ÄòMoney‚Äô
08:52:05 <lambdabot>  Not in scope: type constructor or class ‚ÄòMoney‚ÄôNot in scope: type constructo...
08:52:16 * quanticani shakes fist, gives up
08:52:53 <RedNifre> help edwardk, we are doomed!
08:54:16 <RedNifre> @help
08:54:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:54:28 <RedNifre> @list
08:54:28 <lambdabot> What module?  Try @listmodules for some ideas.
08:54:35 <dmwit> ?let newtype Money currency = Money Double deriving (Read, Show, Eq, Ord)
08:54:37 <lambdabot>  Defined.
08:54:43 <dmwit> ?let data Euro
08:54:44 <lambdabot>  Defined.
08:54:47 <RedNifre> what is that questionmark?
08:54:48 <dmwit> > Money 4.0 :: Money Euro
08:54:50 <lambdabot>  Money 4.0
08:54:52 <dmwit> RedNifre: Same as @
08:55:27 <dmwit> ...but with smaller finger movements on my keyboard. ;-)
08:55:43 <RedNifre> ?let data Dollar
08:55:44 <lambdabot>  Defined.
08:56:03 <RedNifre> > Money 4.0 :: Money Dollar + Money 3.0 :: Money Euro
08:56:04 <lambdabot>  <hint>:1:35: parse error on input ‚Äò3.0‚Äô
08:56:16 <RedNifre> > Money 4.0 :: Money Dollar + (Money 3.0 :: Money Euro)
08:56:18 <lambdabot>  <hint>:1:36: parse error on input ‚Äò3.0‚Äô
08:56:30 <RedNifre> > Money 4.0 :: Money Dollar + (Money 3.0 :: Money Dollar)
08:56:32 <lambdabot>  <hint>:1:36: parse error on input ‚Äò3.0‚Äô
08:56:36 <RedNifre> huh?
08:56:48 <geekosaur> need parens for the first type signature as well
08:57:01 <RedNifre> > (Money 4.0 :: Money Dollar) + (Money 3.0 :: Money Dollar)
08:57:02 <lambdabot>  No instance for (GHC.Num.Num (L.Money L.Dollar))
08:57:02 <lambdabot>    arising from a use of ‚ÄòGHC.Num.+‚Äô
08:57:04 <geekosaur> everything after the first :: is parsed as type
08:57:08 <dmwit> > let (+++) :: Money a -> Money a -> Money a; Money a +++ Money b = Money (a + b) in (Money 4.0 :: Money Dollar) +++ (Money 3.0 :: Money Euro)
08:57:09 <lambdabot>  Couldn't match type ‚ÄòL.Euro‚Äô with ‚ÄòL.Dollar‚Äô
08:57:09 <lambdabot>  Expected type: L.Money L.Dollar
08:57:09 <lambdabot>    Actual type: L.Money L.Euro
08:57:21 <dmwit> ?src Num
08:57:21 <lambdabot> class  (Eq a, Show a) => Num a  where
08:57:21 <lambdabot>     (+), (-), (*)       :: a -> a -> a
08:57:21 <lambdabot>     negate, abs, signum :: a -> a
08:57:21 <lambdabot>     fromInteger         :: Integer -> a
08:58:19 <dmwit> instance Num (Money a) where Money a + Money b = Money (a + b); Money a - Money b = Money (a - b); Money a * Money b = error "um, no"; negate (Money a) = Money (negate a); abs (Money a) = Money (abs a); signum (Money a) = Money (signum a); fromInteger n = Money (fromInteger n)
08:58:23 <dmwit> ?let instance Num (Money a) where Money a + Money b = Money (a + b); Money a - Money b = Money (a - b); Money a * Money b = error "um, no"; negate (Money a) = Money (negate a); abs (Money a) = Money (abs a); signum (Money a) = Money (signum a); fromInteger n = Money (fromInteger n)
08:58:24 <RedNifre> wait, now I need separate operators to do money calculations? This doesn't look like it's worth the effort.
08:58:25 <lambdabot>  Defined.
08:58:40 <dmwit> > (Money 3 :: Money Dollar) + (Money 4 :: Money Euro)
08:58:41 <lambdabot>  Couldn't match type ‚ÄòL.Euro‚Äô with ‚ÄòL.Dollar‚Äô
08:58:41 <lambdabot>  Expected type: L.Money L.Dollar
08:58:41 <lambdabot>    Actual type: L.Money L.Euro
08:58:48 <dmwit> > (Money 3 :: Money Dollar) + (Money 4 :: Money Dollar)
08:58:50 <lambdabot>  Money 7.0
08:59:22 <RedNifre> dmwit, where is all that code comming from? :)
08:59:24 <dmwit> > (3 :: Money Dollar) + (4 :: Money Euro)
08:59:25 <lambdabot>  Couldn't match type ‚ÄòL.Euro‚Äô with ‚ÄòL.Dollar‚Äô
08:59:25 <lambdabot>  Expected type: L.Money L.Dollar
08:59:25 <lambdabot>    Actual type: L.Money L.Euro
08:59:33 <dmwit> > (3 :: Money Dollar) + (4 :: Money Dollar)
08:59:35 <lambdabot>  Money 7.0
08:59:38 <dmwit> RedNifre: fingertips =)
09:00:03 <exio4> while you're it, code a brainfuck interpreter
09:00:20 <RedNifre> so you just remember that you have to define things like signum and negate, whenever you want a specially typed number?
09:00:33 <dmwit> exio4: I think I have one or two of those lying around in my programming directory...
09:00:47 <dmwit> RedNifre: No, that was why I asked for the source of Num before writing the code.
09:00:56 <dmwit> RedNifre: (the "?src Num" query to \bot)
09:01:16 <Tekmo> RedNifre: You provide a `Num` instance for any new types you define
09:01:40 <Tekmo> RedNifre: `Num` is just another type class
09:01:55 <RedNifre> > (4 :: Money Dollar) * 3
09:01:57 <lambdabot>  Money *Exception: um, no
09:02:00 <Tekmo> RedNifre: There is no special built-in language support for those mathematical operations
09:02:24 <Tekmo> RedNifre: All `ghc` does is say "Oh, you're using the (+) operator.  I noticed that this operator belongs to the `Num` type class, let me see if you defined how that operator behaves for your type"
09:02:47 <dmwit> Well, that's not 100% accurate. There's built-in language support which supplies instances for some base types like Int, Double, Integer, etc.
09:03:06 <Tekmo> dmwit: Yeah, that's true.  There are default high-efficiency instances provided by the language
09:03:17 <Tekmo> dmwit: But the `Num` class itself is not a language "built-in"
09:03:52 <nshepperd> in real haskell you would just activate GeneralizedNewtypeDeriving and write "newtype Money c = Money Double deriving (Num)"
09:03:57 <nshepperd> or at least, I would
09:04:01 <dmwit> yes, me too
09:04:06 <Tekmo> +1 for GeneralizedNewtypeDeriving
09:04:54 <chrisdotcode> I've got to learn how to use parsec...
09:05:09 <Tekmo> chrisdotcode: Are you new to parser combinator libraries?
09:05:14 <dmwit> But since it's not available in-channel, I figured what the heck, let's make some progress here instead of complaining about not having GND. ;-)
09:05:25 <Tekmo> chrisdotcode: I can point you to a good general-purpose tutorial for these sorts of libraries.  It's not `parsec`-specific, but it will give you the idea
09:05:31 <RedNifre> ?let instance Num (Money a) where Money a + Money b = Money (a + b); Money a - Money b = Money (a - b); Money a * Money b = error "um, no"; negate (Money a) = Money (negate a); abs (Money a) = Money (abs a); signum (Money a) = Money (signum a); fromInteger n = Money (fromInteger n); Money a * b = Money(a + b)
09:05:32 <lambdabot>  .L.hs:170:17:
09:05:32 <lambdabot>      Conflicting definitions for ‚Äò*‚Äô
09:05:32 <lambdabot>      Bound at: .L.hs:170:17
09:05:32 <lambdabot>                .L.hs:175:17
09:05:36 <chrisdotcode> Tekmo: Indeed.And parsers in general. I've always wanted to write a language,but never got past parsing.
09:05:48 <chrisdotcode> s/language/compiler in general
09:06:06 <vanila> chrisdotcode, interpreter might be easier
09:06:16 <dmwit> Allowing (*) :: Money a -> Money a -> Money a seems like a Really Bad Idea.
09:06:20 <Tekmo> chrisdotcode: http://www.cs.tufts.edu/~nr/cs257/archive/graham-hutton/monadic-parsing-jfp.pdf
09:06:32 <RedNifre> That's not what I want.
09:06:44 <RedNifre> I want Money a -> Num that is not Money a -> Money a
09:06:45 <chrisdotcode> Tekmo: Awesome! Is that intermediate level?
09:06:55 <RedNifre> But I think the problem is that money isn't really a number.
09:06:59 <Tekmo> chrisdotcode: I think halfway between beginner and intermediate
09:07:07 <RedNifre> > (3 :: Money Dollar ) * 4
09:07:09 <lambdabot>  Money *Exception: um, no
09:07:16 <RedNifre> that one should result in 12 dollar, right?
09:07:36 <dmwit> I don't know what "should" means.
09:07:37 <chrisdotcode> Tekmo: Thanks a lot! After that, I can hop straight into the parsec tutorial and doc?
09:07:45 <dmwit> Please give a more technical description of what you mean by "should".
09:07:45 <RedNifre> ?let instance Num (Money a) where Money a + Money b = Money (a + b); Money a - Money b = Money (a - b); Money a * Money b = error "um, no"; negate (Money a) = Money (negate a); abs (Money a) = Money (abs a); signum (Money a) = Money (signum a); fromInteger n = Money (fromInteger n); Money a * Integer b = Money(a + b)
09:07:46 <lambdabot>  .L.hs:170:17:
09:07:47 <lambdabot>      Conflicting definitions for ‚Äò*‚Äô
09:07:47 <lambdabot>      Bound at: .L.hs:170:17
09:07:47 <lambdabot>                .L.hs:175:17
09:07:47 <lambdabot>  
09:08:02 <Tekmo> chrisdotcode: Yeah.  I think after reading that you should be able to understand the parsec tutorial and documentation
09:08:09 <chrisdotcode> Awesome. Thank again.
09:08:10 <SrPx> How can I see a list of all articles on the Haskell Wiki?
09:08:13 <Tekmo> chrisdotcode: You're welcome!
09:08:17 <RedNifre> I mean that in the real world, you can multiply an amount of money with a number (but you can't multiply money with money)
09:08:34 <exio4> money^2!
09:08:42 <Tekmo> RedNifre: I would just define another function named `scale` for this purpose
09:08:59 <Tekmo> RedNifre: scale :: Double -> Money a -> Money a
09:08:59 <dmwit> ?let (.*) :: Money a -> Double -> Money a; Money a .* b = Money (a * b)
09:09:02 <lambdabot>  Defined.
09:09:09 <dmwit> > (3 :: Money Dollar) .* 4
09:09:11 <lambdabot>  Money 12.0
09:09:20 <RedNifre> where did the dollars go?
09:09:43 <augur> hello everyone!
09:09:45 <exio4> @type (3 :: Money Dollar) .* 3
09:09:45 <Tekmo> augur: Hi!
09:09:46 <lambdabot> Money Dollar
09:09:46 <pjdelport> :t (3 :: Money Dollar) .* 4
09:09:47 <lambdabot> Money Dollar
09:09:53 <augur> Tekmo: heyo hey
09:10:19 <Tekmo> RedNifre: The `Dollar` only shows up in the type, not the value
09:10:48 <Tekmo> RedNifre: In Haskell you distinguish between something's value and type
09:11:09 <Tekmo> RedNifre: A lot of languages sort of conflate the two a little bit, meaning that the type is just a reflection of the shape of the data
09:11:16 <Ch0c0late> ReadNifre: Money is a type constructor which takes a parameter value.
09:11:31 <Tekmo> RedNifre: But in Haskell you have a lot more control over what kind of information you can store in the type
09:11:31 <Ch0c0late> RedNifre: Money is a type constructor which takes a parameter value.
09:11:48 <Tekmo> RedNifre: That information may have no relation to the actual value encoded by the type
09:12:23 <RedNifre> so 4 dollars is of one of the Money types, and the particular money type it is of happens to be the Money Dollar type?
09:12:42 <Tekmo> RedNifre: Yes
09:13:03 <Tekmo> RedNifre: Have you ever programmed in a language with generics, like Java or C# or C++?
09:13:13 <RedNifre> yes
09:13:30 <Ch0c0late> So what does template <class T> means RedNifre
09:13:33 <Ch0c0late> ?
09:13:48 <Tekmo> RedNifre: So in languages with generics types can take arguments (like List<T> in Java, or whatever the syntax is)
09:14:01 <RedNifre> that I pick the specifics when instantiating a new thing.
09:14:08 <dmwit> A Haskell koan. Q: Where did the dollars go? A: The dollars didn't exist in the first place.
09:14:16 <Tekmo> RedNifre: Money is a type that takes a type argument, just like generics take a type argument
09:14:37 <Tekmo> RedNifre: The difference is that generics in other languages usually use the type argument to represent the types of values stored inside the object
09:14:44 <RedNifre> I mean, in Java you have type erasure. I'd actually prefer if a List<String> would be of type List<String> and not of type List.
09:14:48 <Tekmo> RedNifre: In Haskell, we often use the type argument to just store arbitrary information
09:15:15 * hackagebot debian 3.83.3 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.3 (DavidFox)
09:15:15 <dmwit> In Haskell, you have type erasure too, but it's more complete. A List<String> is just a bunch of bits, like values of every other type.
09:15:24 <Tekmo> RedNifre: So you can think of `Money Dollar` as being like `Money<Dollar>`, it's just that there is no `Dollar` stored inside of it
09:15:35 <Tekmo> RedNifre: What's actually stored inside of it is a `Double`, not a `Dollar`
09:15:46 <vanila> you don't store information in the type in haskell
09:15:49 <dmwit> Ooops. I mean in GHC, not necessarily in Haskell.
09:16:17 <Tekmo> RedNifre: The `Dollar` is just a "tag" that we use to communicate extra information to the compiler
09:16:19 <vanila> types just make sure you don't do things that don't make sense like Apple + ['x','y']
09:16:30 <Tekmo> RedNifre: We call type parameters like `Dollar` "phantom types"
09:16:51 <Tekmo> RedNifre: We use these "phantom types" to make sure that the compiler doesn't mix together types that don't make sense
09:17:20 <Tekmo> RedNifre: In this example, we use the phantom type to make sure that the compiler doesn't accidentally add `Money Dollar` to `Money Cent`
09:17:29 <Tekmo> RedNifre: If we want to add them, we must explicitly convert one to the other
09:17:36 <augur> is it possible to compile a haskell library that exports some C FFI stuff, together with a corresponding C header, in such a way that it produces a single black-box library that contains all the components required to use it in C?
09:17:45 <augur> including, ideally, things like hs_exit and so forth?
09:18:51 <augur> the problem im running into trying to just compile the haskell is that once i get onto the C side of things, Xcode cant find the bazillion symbols that Haskell generates, because I guess it doesnt know where to look for everything
09:19:06 <vanila> If you want two new types that hold Doubles you could use  newtype Dollar = Dollar Double, and newtype Cent = Cent Double,  there is no need for weird type system tricks
09:19:15 <augur> and i was hoping that if I could compile a small amount of the C side using GHC, it would make this easier
09:20:16 * hackagebot process-listlike 0.7 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.7 (DavidFox)
09:20:18 <RedNifre> So the "value" refers to the representation, i.e. "4 dollar" has the value "Money 4", which just means "Double 4", because Money is basically a synonym for Double. And the type of "4 dollar" is "Money Dollar", because that is all the additional information associated with that particular Double instance?
09:20:55 <augur> RedNifre: no no
09:20:55 <Tekmo> RedNifre: Yes
09:21:03 <augur> that cant be right
09:21:03 <RedNifre> :)
09:21:07 <Tekmo> Haha
09:21:20 <augur> Double is a type, it cant be applied to 4
09:21:32 <Tekmo> The "value" stored inside the `Money` constructor is a `4` of type `Double`
09:21:33 <augur> presumably neither can money unless money is also a constructor
09:21:43 <Tekmo> `Double 4` is a type error
09:21:44 <RedNifre> I meant 4.0 :: Money Dollar
09:21:45 <vanila> I think this phanton type stuff is confusing to beginners and unnecessary
09:22:00 <Tekmo> When you wrap the `4` inside the `Money` constructor you give it a new type instead of `Double`
09:22:09 <Tekmo> Thus the name: "newtype"
09:22:10 <augur> probably so is conflation of type and data constructors, guys
09:23:05 <Tekmo> augur: You mean naming both `Money`?
09:23:06 <dmwit> augur: I think the standard practice is to compile everything with GHC, even when the top-level main function is in C.
09:23:24 <dmwit> augur: So I'm not sure you'll find something pre-made for doing what you ask.
09:23:34 <dmwit> (sorry)
09:23:55 <Tekmo> RedNifre: Let me help translate terminology for you
09:24:03 <Tekmo> RedNifre: Let me just redefine the data type definition a little bit
09:24:06 <Tekmo> RedNifre: We'll use this instead
09:24:09 <augur> dmwit: well if thats the standard practice im ok with it, as long as i can produce a blackbox that i can use in other C projects without tracing through dependencies :)
09:24:28 <dmwit> nope, don't think so
09:24:37 <Tekmo> RedNifre: newtype Money a = MakeMoney Double
09:24:43 <augur> dmwit: if the output of GHC is something like   MyLib.whatever   and i can just pull that into C, then im happy
09:24:49 <dmwit> no no
09:24:52 <dmwit> you're not getting it
09:25:02 <dmwit> If there's Haskell code involved, you're compiling with GHC. Not with gcc.
09:25:10 <dmwit> That's the standard practice as far as I know.
09:25:16 * hackagebot confsolve 0.5.2 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.5.2 (DanielTrstenjak)
09:25:17 <Tekmo> RedNifre: In that definition `Money` is called a "type constructor", meaning that it takes type arguments (like `a`, which could be `Dollar`)
09:25:32 <augur> dmwit: yes, but is there no way to compile to a self-contained library?
09:25:37 <dmwit> right
09:25:41 <Tekmo> RedNifre: `MakeMoney` is the "data constructor"
09:25:49 <augur> dmwit: i mean, how do people write libraries in haskell? that cant be right
09:25:53 <dmwit> More precisely: I don't know. But I haven't heard of such efforts.
09:25:57 <Tekmo> RedNifre: You can think of `Money` as a function from some type `a` to a new type `Money a`
09:26:03 <Tekmo> RedNifre: That's not totally precise, but it's close enough
09:26:10 <augur> you cant write a haskell library and then expect every other developer who uses it in _C_ to download GHC and compile their program with that
09:26:16 <augur> that definitely cant be how this works
09:26:17 <Tekmo> RedNifre: You can think of `MakeMoney` as an ordinary function from `Double` to `Money a`
09:26:18 <nshepperd> I think people normally write haskell libraries in haskell
09:26:23 <augur> GHC cant possibly be so insular
09:26:23 <Tekmo> RedNifre: MakeMoney :: Double -> Money a
09:26:33 <dmwit> augur: [citation needed]
09:27:20 <augur> dmwit: well given that people have written fairly complex things with haskell, that have to interface to all sorts of things, it would be ridiculous if this couldnt be done
09:27:39 <nshepperd> it's the reason they call C the lowest common denominator - it's so simple you can use it from anything, but it's hard to go the other way
09:27:45 <augur> i mean, you're not compiling _python_ with GHC, and yet there's a way to call Haskell from Python
09:27:48 <Tekmo> RedNifre: So `MakeMoney` is a data constructor that you use to wrap weakly typed `Double`s and give them more precise types like `Money Dollar`
09:27:51 <augustss> augur: You can ship DLLs.
09:28:00 <Tekmo> RedNifre: By giving them a more precise type you communicate more information to the compiler that it can use to detect mistakes
09:28:05 <augur> augustss: is that the only option?
09:28:39 <augur> augustss: my goal is to make an ObjC framework that wraps around some haskell, but that means i cant expect the framework user to have Haskell installed
09:28:45 <augustss> augur: If you don't want the users to download ghc you need to ship binaries.  Shared libraries is the only option for that.
09:28:49 <ClaudiusMaximus> augur: i once wrote a .so plugin for a C program using GHC and the haskell package plugins, it's almost certainly bitrotted to pieces but there might be something useful in it still https://gitorious.org/pdhaskell/hsext
09:28:49 <nshepperd> that said, maybe you can compile your library down to a static library with a C-like entry point
09:29:04 <Tekmo> augur: Wouldn't a shared library be ideal for you?
09:29:06 <augur> augustss: and by dll do you mean a dylib, or something else?
09:29:06 <augustss> DLLs on Windows, .so on *nix.
09:29:15 <nshepperd> dylib on mac...
09:29:23 <RedNifre> Given the complexity with :: Money Dollar, the additional datas and extra operators like .*, I'm no longer sure that all this is really worth it.
09:29:28 <augustss> augur: whatever is the appropriate shared libs for your platform.
09:30:07 <Tekmo> augur: Dynamic linking is the most common way for C libraries to import each other's code
09:30:17 * hackagebot protocol-buffers-fork 2.0.16 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-fork-2.0.16 (StefanWehr)
09:30:19 * hackagebot protocol-buffers-descriptor-fork 2.0.16 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-fork-2.0.16 (StefanWehr)
09:30:20 <augur> augustss: ok. ive tried doing this before but it never seems to work because of missing symbols. can i ask you more questions next time an issue arises?
09:30:43 <augustss> augur: if I'm around, you're welcome to ask.
09:30:53 <augur> augustss: cool, thanks :)
09:30:58 <augustss> augur: I've done it on Windows and Linux.
09:31:03 <Tekmo> augur: It's worth learning how to do this regardless, even outside of Haskell
09:31:38 <augustss> augur: You might have to ship the ghc RTS as well, unless you link that statically into your lib.
09:32:19 <augur> augustss: thats probably the issue thats coming up, but none of the tutorials ive seen have any explanation of that. they all just say, compile this way, copy this file into your project dir, and you're good to go!
09:32:21 <augur> except it never is :\
09:33:20 <augustss> augur: It can be quite fiddly.  And some aspects can change netween ghc versions.
09:33:27 <RedNifre> How can I specify a type "Num, except Money"?
09:33:57 <Tekmo> RedNifre: Just specify `Money`
09:34:03 <Tekmo> RedNifre: The compiler already knows that `Money` is a `Num`
09:34:15 <Roger__> Anyone know how to make a function that is (=) if the arguments are instances of Eq, and False otherwise?
09:34:27 <Tekmo> RedNifre: Oh, sorry, I think I misunderstood you
09:34:41 <RedNifre> So how to write (*) that takes Money and a Num, but not two Moneys?
09:34:42 <Tekmo> RedNifre: Are you asking about "a `Num` that is *not* `Money`"?
09:34:43 <monochrom> no, the syntax "=" is reserved
09:34:48 <RedNifre> yes
09:34:58 <Tekmo> RedNifre: You can't.  You have to define a separate function for that purpose
09:35:12 <Tekmo> RedNifre: The `Num` type class enforces that the arguments of `*` must have the exact same type
09:35:18 * hackagebot debian 3.83.3.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.3.1 (DavidFox)
09:35:26 <Tekmo> RedNifre: So you would have to define something like:
09:35:34 <Tekmo> RedNifre: scale :: Double -> Money -> Money
09:35:37 <RedNifre> So how to write a function that can multiply a Money with a Double, but not with another Money?
09:35:46 <monochrom> (*) is already taken by the Prelude. you can still make your own (*), but you're looking at a name clash, the same way you make your own takeWhile
09:35:56 <Tekmo> RedNifre: scale x (Money y) = Money (x * y)
09:35:58 <Roger__> monochrom: I don't mean I want the name of the function to be (=). I mean I want the function to return what (=) would if applied to instances of Eq, and false otherwise
09:36:18 <monochrom> Eq's is (==), not (=)
09:36:19 <RedNifre> But there's only a nameclash with * because Money IS Double?
09:36:20 <vanila> Roger__, you can't do that, you'll have to write Eq instances that return false for everything else
09:36:31 <augustss> Money is a very dubious Num, since * should be banned.
09:36:39 <augustss> It's a torsor.
09:37:00 <augustss> Kinda
09:37:10 <augustss> Or a vectorspace, maybe.
09:37:15 <monochrom> how to write Eq instance for Money depends on the semantics of Money
09:37:24 <nshepperd> a vector space over scalars, really
09:37:35 <Roger__> vanilla: Doesn't work: I'm trying to make a monad, so I can't impose any typeclass constraints
09:37:39 <Tekmo> RedNifre: It clashes because `Num` has an `(*)` method
09:37:50 <RedNifre> For example, if I had data Money = Money {amount::Double, currency::Currency} I could then define (Money a b) * c = Money (a*c) b, right?
09:37:52 <Tekmo> RedNifre: Even if you don't implement `Num` for `Money`, it will still clash
09:37:58 <vanila> Roger__, maybe you can add constraints
09:38:14 <Tekmo> RedNifre: Once you define a type class with a method, that method clashes with other functions of the same name unless you namespace them
09:38:21 <vanila> Roger__, although if it requires Eq i doubt it's a monad
09:38:29 <augustss> RedNifre: The * from Num takes two arguments of the same type.
09:39:09 <augustss> So Num isn't a good choice for Money.
09:39:42 <Tekmo> RedNifre: Note that if you don't need multiplication, the `Monoid` type class makes a good alternative to `Num`
09:39:50 <monochrom> perhaps you don't mind a name clash. Control.Exception used to clash with Prelude. :)
09:39:52 <Tekmo> RedNifre: You can treat `(<>)` as analogous to `(+)`
09:39:58 <Tekmo> :t (<>)
09:40:01 <lambdabot> Monoid m => m -> m -> m
09:40:30 <augustss> Tekmo: Monoid doesn't have subtraction.
09:40:30 <sivteck> :t mappend
09:40:31 <lambdabot> Monoid a => a -> a -> a
09:40:40 <Tekmo> augustss: Oh yeah, good point
09:41:01 <Tekmo> augustss: In that case, he may just have to settle for `Num` with some unimplemented methods, or use an alternative Prelude
09:41:20 <augustss> Money / Money makes sense.  It's an exchange rate.
09:41:22 <Tekmo> augustss: Or just ask his users to import Prelude hiding `Num(..)`
09:41:26 <wz1000> Is it possible to choose random elements from an infinite set in an unbiased manner?
09:41:35 <vanila> wz1000, no
09:41:58 <greymalkin> augustss: Not really, exchange rates typically track three decimal places, rather than two
09:42:00 <Roger__> vanilla: AFAICT you're simply not allowed to declare that (m a) is a monad while imposing any constraints on a
09:42:06 <wz1000> Ah.
09:42:20 <vanila> Roger__, oh yes you're right sorry
09:42:36 <augustss> greymalkin: I consider the number of decimals a presentation issue.
09:43:00 <augustss> greymalkin: Exchange rates are tracked with more than 3 decimals, btw.
09:43:17 <Tekmo> It also bothers me that we're using `Double` internally for money
09:43:26 <Tekmo> I'd prefer an `Integer` to represent the number of cents
09:43:31 <Roger__> vanilla: I think I can seperate out the monad functions from the equality requiring functions, actually, so I guess that's probably the best workaround
09:44:00 <Roger__> vanilla: thanks
09:44:05 <vanila> np!
09:44:12 <augustss> greymalkin: But if you know a bank that only uses 3 decimals I'm happy to arb them. :)
09:44:53 <RedNifre> So is it really impossible to create a function called "*" that can somehow multiply money with not money? I don't understand why there is a conflict if I declare * to take a data Money = Money{amount::Number} as input.
09:45:06 <RedNifre> (That is, if Money wraps a number instead of being one)
09:45:15 <augustss> Tekmo: I think the Money type should be polymorphic in the underlying scalar so you can pick what you want.
09:45:17 <vanila> RedNifre, yes you can define your own new function (*) that does whatever you want
09:45:20 * hackagebot hprotoc-fork 2.0.16 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-fork-2.0.16 (StefanWehr)
09:45:31 <vanila> RedNifre, you just need to hide or not import the original (*) that comes from the standard library
09:46:12 <Tekmo> augustss: That makes sense
09:46:17 <RedNifre> But I thought the original (*) only takes numbers, why then can't I declare an additional (*) that takes something other than a number as a parameter? Why should there be a conflict?
09:46:33 <Tekmo> RedNifre: You can, if you hide the (*) from the current namespace
09:46:44 <vanila> RedNifre, because those are different functions
09:46:51 <pjdelport> RedNifre: The conflict is only in the name: when you say (*), Haskell has to know which one you're referring to.
09:46:53 <Tekmo> RedNifre: You have to hide the `(*)` method of the Num type class, otherwise it will clash with any new function named `(*)` that you define
09:47:07 <exio4> @type (*)
09:47:08 <lambdabot> Num a => a -> a -> a
09:47:11 <pjdelport> RedNifre: You can disambiguate it either by fully qualifying it, or by hiding the one you don't want.
09:47:12 <RedNifre> but doesn't haskell know which one I'm refering to based on the type of the parameters?
09:47:13 <Tekmo> RedNifre: If you want to hide it, you can use `import Prelude hiding Num((*)`
09:47:16 <augustss> RedNifre: Haskell doesn't have overloading the way C++, Java, or C# has.
09:47:18 <Tekmo> RedNifre: No
09:47:31 <Tekmo> RedNifre: Let me qualify that, sort of, but not in this case
09:47:35 <RedNifre> Thanks augustss, that explains it.
09:47:41 <geekosaur> RedNifre, type directed name resolution is a thing that comes up periodically and gets discarded because it interacts badly with the rest of Haskell
09:47:56 <Tekmo> RedNifre: Haskell can infer `Num` instances if they match the signature of the `(*)` method of the `Num` type class
09:48:14 <augustss> RedNifre: Every overloaded Haskell function has to conform to the type in it's class declaration.
09:48:15 <Tekmo> RedNifre: In this case, the type signature of `(*)` as defined by `Num` requires that both arguments have the same type
09:48:18 <geekosaur> if you look for that specific phrase you can find a lot of discussion about it
09:48:34 <Tekmo> RedNifre: If you want to implement a `(*)` function which does not take arguments of the same type, you will have to completely hide the existing `(*)` from `Num`
09:48:37 <SrPx> How can I see a list of all articles on the Haskell Wiki?
09:48:46 <Tekmo> RedNifre: And then you would just implement your own `(*)` function from scratch
09:50:01 <pjdelport> SrPx: http://www.haskell.org/haskellwiki/Special:AllPages
09:50:27 <augustss> RedNifre: It's totally possible to have a (*) which has type a->b->c, but it will interact very poorly with type inference.
09:50:41 <pjdelport> SrPx: http://www.haskell.org/haskellwiki/Special:SpecialPages has a few more kinds of index, which might be of interest too.
09:55:32 <NikolajK> So I figured out that <*>, as coming from a monad, is 75% Yoneda lemma and actually, for every functor f there is a map <F>, and such that if F is a monad, then it's '<*> g x' is 'join $ <F> g x'. Anyone interested?
09:55:57 <RedNifre> .* it is then
09:56:07 <RedNifre> @let Currency = USD | EUR
09:56:07 <lambdabot>  Parse failed: Parse error: |
09:56:18 <RedNifre> @let data Currency = USD | EUR
09:56:20 <lambdabot>  Defined.
09:56:36 <RedNifre> @let data Money = Money {Integer, Currency}
09:56:37 <lambdabot>  Parse failed: Parse error: Integer
09:56:54 <RedNifre> @let data Money = Money {amount  :: Integer, currency :: Currency}
09:56:55 <lambdabot>  .L.hs:172:1:
09:56:55 <lambdabot>      Multiple declarations of ‚ÄòMoney‚Äô
09:56:55 <lambdabot>      Declared at: .L.hs:151:1
09:56:55 <lambdabot>                   .L.hs:172:1
09:56:55 <lambdabot>  
09:57:17 <chrisdotcode> @undefine Money
09:57:17 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
09:57:24 <marchelzo_> How can I do regex substitutions on bytestrings? currently I am unpacking and repacking and it's slow
09:57:33 <RedNifre> okay then
09:57:35 <RedNifre> @undefine
09:57:36 <lambdabot> Undefined.
09:57:43 <RedNifre> @let data Currency = USD | EUR
09:57:45 <lambdabot>  Defined.
09:57:50 <RedNifre> @let data Money = Money {amount  :: Integer, currency :: Currency}
09:57:51 <lambdabot>  Defined.
09:58:01 <chrisdotcode> RedNifre: you can also private message her.
09:58:07 <chrisdotcode>  /msg lambdabot <code>
09:58:19 <RedNifre> @let (Money a b) .* c = Money (a * c) b
09:58:20 <lambdabot>  Defined.
09:58:28 <RedNifre> > Money 4 USD * 3
09:58:30 <lambdabot>  No instance for (GHC.Num.Num L.Money)
09:58:30 <lambdabot>    arising from a use of ‚ÄòGHC.Num.*‚Äô
09:58:40 <RedNifre> > Money 4 USD .* 3
09:58:41 <lambdabot>  No instance for (GHC.Show.Show L.Money)
09:58:42 <lambdabot>    arising from a use of ‚ÄòM3712381224498043936155.show_M3712381224498043936155‚Äô
09:59:13 <RedNifre> ah, sorry.
10:01:05 <RedNifre> > currency (Money 4 USD .* 3)
10:01:07 <lambdabot>  No instance for (GHC.Show.Show L.Currency)
10:01:07 <lambdabot>    arising from a use of ‚ÄòM36177106167571753956189.show_M36177106167571753956...
10:01:22 <RedNifre> > amount (Money 4 USD .* 3)
10:01:23 <lambdabot>  can't find file: L.hs
10:01:40 <RedNifre> ...
10:01:52 <monochrom> try again. race condition.
10:02:00 <RedNifre> > amount (Money 4 USD .* 3)
10:02:02 <SrPx> pjdelport: hm thanks
10:02:02 <lambdabot>  12
10:02:12 <SrPx> not what I expected though :(
10:02:13 <RedNifre> what happened with lambdabot there?
10:02:27 <monochrom> a mysterious bug
10:04:56 <SrPx> What is a good library to create a 2d game in?
10:05:29 <monochrom> free-game
10:05:48 <Fuuzetsu> new free-game version soon
10:06:53 <Twey> How does Criterion decide how many samples to take?
10:08:11 <Fuuzetsu> isn't it a set number unless you tell it otherwise?
10:09:08 <RedNifre> Well, this has been a lot of fun and I learned a lot. Thanks everybody, bye :)
10:09:13 <Twey> Fuuzetsu: Nope.  It ran ten of my big benchmark and‚Ä¶ many thousands of my little benchmark
10:09:25 <SrPx> and what is a lightweight library for rendering in general? Ie, all I need is a fast way to blit sprites into a screen, and clear it.
10:10:25 * hackagebot hprotoc-fork 2.0.16.1 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-fork-2.0.16.1 (StefanWehr)
10:10:32 <Twey> SrPx: ‚ÄòFast‚Äô in terms of execution time or coding time?
10:10:43 <SrPx> Execution time.
10:10:54 <Twey> Well, you can draw on the screen directly with OpenGL
10:11:22 <SrPx> Yea I'd be happy with just OpenGL, but I thought Haskell had some clever tricks to allow me to get performance with just the high level calls (:
10:11:38 <Twey> Sure, but I thought you didn't care about the coding time.  :√æ
10:11:43 <SrPx> (I'd prefer to just code the client in WebGL if that is the case, for portability)
10:12:07 <SrPx> Nah I do, just that execution is more important. But of course, if there is something that takes 10% of the time for 90% of the perf, that is great.
10:12:15 <jfischoff> Are there any haskell syntax highlighters that use haskell-src-exts or GHC‚Äôs parsing api?
10:12:21 <Twey> gloss is pretty nice, and I think not that slow
10:13:29 <monochrom> does SDL count?
10:14:06 <Twey> There's SDL somewhere in the middle there, yeah‚Ä¶ and Cairo a bit higher up
10:14:38 <Twey> OpenGL is also not that unpleasant to use in Haskell, with some support libraries (vinyl-gl is lovely)
10:14:39 <monochrom> I think free-game already calls OpenGL for you
10:15:11 <augustss> SrPx: In case you're SrPeixinho in reddit, I've answered you.
10:15:26 * hackagebot semver 0.1.2 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.1.2 (BrendanHay)
10:17:15 <SrPx> augustss: ah thank you, replied back
10:21:45 <athan> Hey guys I've got a weird cabal error... It's telling me that the package I'm installing is a dependency of itself, and it required version 0.0.0... I have no idea why
10:21:54 <MichaelBurge> Is there a syntax sugar for comonads?
10:22:35 <dcoutts_> athan: can you post the .cabal file and the log showing the command you ran and the error it produced.
10:22:52 <athan> dcoutts_: Sure thing, one sec
10:22:53 <jfischoff> MichaelBurge: there is a quasiquoter
10:23:01 <jfischoff> @hackage codo
10:23:01 <lambdabot> http://hackage.haskell.org/package/codo
10:23:09 <jfischoff> MichaelBurge: ^
10:23:25 <Twey> That's a broken link
10:23:33 <Twey> @hackage notarealpackage
10:23:34 <lambdabot> http://hackage.haskell.org/package/notarealpackage
10:23:37 <jfischoff> oh
10:23:41 <Twey> It's http://hackage.haskell.org/package/codo-notation
10:23:45 <jfischoff> http://hackage.haskell.org/package/codo-notation
10:24:04 <MichaelBurge> jfischoff: Thanks, I'll give it a try
10:24:24 <jfischoff> MichaelBurge: yes, I wonder if it works ‚Ä¶
10:25:22 <athan> dcoutts_: So here's the cabal file: http://lpaste.net/110148 and here's the log: http://lpaste.net/110150 It's a brand new sandbox, and I've tried to delete and re-init a few times
10:25:28 * hackagebot hbro 1.2.0.0 - Minimal KISS-compliant browser  http://hackage.haskell.org/package/hbro-1.2.0.0 (koral)
10:26:24 <aisqwe> can you show me a problem where solving it might clarify the importance of functors or monoids or monads ??!!
10:26:49 <Twey> Hrm, I wonder what the free comonad is‚Ä¶
10:27:25 <Tekmo> aisqwe: This functional pearl does an excellent job of showing off one cool use of monads: http://www.cs.tufts.edu/~nr/cs257/archive/graham-hutton/monadic-parsing-jfp.pdf
10:27:38 <augustss> aisqwe: It's a little difficult to show one problem that shows their importance, since their importance it that they abstract things that are common to many problems.
10:27:53 <athan> aisqwe: it's a technique, not necessarily a solution
10:27:59 <barrucadu> aisqwe: Consider trees, lists, maps, etc. These are all functors, so we can use the same function (fmap) to do things with their contents. If they weren't functors, you'd need a separate mapping funciton for every type
10:28:05 <Tekmo> aisqwe: This functional pearl does a great job of showing off monoids: http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
10:28:14 <barrucadu> *function
10:28:19 <dcoutts_> athan: it's not saying it's a dependency of itself, it's just saying it's trying to install foo-0.0.0, which is the one you're trying to install
10:28:30 <MP2E> Twey: newtype Cofree f a = Cofree { runCofree :: (a, f (Cofree f a)) }
10:28:42 <Twey> aisqwe: Mapping a function over a list is a simple use of functors.  Concatenating two strings (or adding two ints) is a simple use of monoids.  Dereferencing a sequence of possibly-missing values is a simple use of monads.
10:28:48 <athan> dcoutts_: Hmm. would I have to `cabal install foo-0.1.0`?
10:28:53 <dcoutts_> athan: and then it says it cannot install gsap-shakespeare, which is because there is no such package (at least cabal doesn't know about it)
10:28:55 <athan> that's so strange
10:29:02 <athan> oh!
10:29:24 <athan> dcoutts_: Sorry. This is such a pain sometimes
10:29:29 <dcoutts_> athan: no that bit is quite straightforward, your .cabal file is foo-0.0.0, so that's the goal the solver is trying to pick
10:29:43 <dcoutts_> goal foo, with constraint foo == 0.0.0
10:30:24 <athan> dcoutts_: This project is related to a really strange error anyway
10:30:32 <athan> cabal-related
10:30:35 <dcoutts_> athan: one confusing thing is that it so happens there is a package on hackage called foo-1.0, so the solver notes that it's rejecting that one
10:30:44 <athan> dcoutts_: OH
10:30:48 <athan> dcoutts_: that makes a lot more sense
10:30:49 <Twey> Tekmo: I ran across this thread yesterday: http://www.reddit.com/r/haskell/comments/1cc6fe/haskell_for_all_pipesconcurrency100_reactive/c9f5sq9 and was wondering whether you've had a chance to read ‚ÄòPush/Pull FRP‚Äô yet and whether your opinion on the relationship between pipes and FRP has changed
10:31:27 <athan> dcoutts_: Does type inference get tricky across sandboxes?
10:31:44 <aisqwe> thanks guys, i will follow your responses, just wanted to know, if i want to program in haskell should i know abstract algebra to be good at it and otherwise i would be better off using other languages to solve my problems
10:31:45 <dcoutts_> athan: you can't really share packages across sandboxes
10:31:46 <Tekmo> Twey: My `mvc` library is basically the pseudo-FRP library for `pipes`
10:32:00 <Tekmo> Twey: Especially `mvc-updates`
10:32:15 <Twey> Mm, yes, I was just reading that
10:32:32 <barrucadu> aisqwe: It's not really necessary. You pick things up as you use the abstractions.
10:32:36 <Twey> But why do you call it ‚Äòpseudo-FRP‚Äô?  Do you believe it's fundamentally different to conal's ‚ÄòFRP‚Äô?
10:32:51 <athan> dcoutts_: Sorry, I didn't mean in that way. Two separate packages, but with some fairly tricky types. Basically, I'm getting javascript in one package presumed to be html by the master package that uses it
10:32:59 <Tekmo> Twey: So people usually include some notion of continuous time in FRP
10:33:08 <Tekmo> Twey: `pipes` doesn't support anything like continuous time
10:33:14 <Twey> Ah, I see
10:33:22 <conal> Tekmo: and a simple & precise denotation.
10:33:23 <Tekmo> Twey: However, I think `mvc-updates` is good enough for most purpose
10:33:32 <athan> Tekmo: Did you see conal's talk on that?
10:33:36 <Tekmo> conal: Yes, I agree with that
10:33:36 <athan> ^^
10:34:11 <Twey> Tekmo: I guess that answers my question.  Thanks a lot!
10:34:12 <dcoutts_> athan: so sandboxes don't really have anything to do with this
10:34:20 <Tekmo> Twey: So I think `mvc-updates` meets the simple denotation criteria, and also has nice algebraic properties (with nice functors to the denotation), but it lacks continuous time
10:34:27 <athan> dcoutts_: /:
10:34:29 <Tekmo> Twey: You're welcome!
10:34:47 <Tekmo> Twey: Also, if you ever need to casually ping me when I'm not on IRC, just contact me by Twitter or by email
10:35:06 <chrisdotcode> how can you print out the current version of your own cabal package? `main = getVersion >>= print`, where the getVersion function is the one I'm looking for
10:35:07 <shachaf> zmbmartin: Encode from your String/Text password to ByteString, e.g. using UTF-8.
10:35:25 <Tekmo> athan: Unfortunately, my commencement conflicted with part of Bay'Hac so I couldn't see it
10:35:29 * hackagebot hbro-contrib 1.2.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.2.0.0 (koral)
10:35:34 <Tekmo> athan: However, I have seen some of his earlier talks on the same subject
10:35:37 <dcoutts_> chrisdotcode: Cabal generates a module for you that includes your project version
10:35:52 <dcoutts_> see the cabal user guide
10:35:54 <chrisdotcode> dcoutts_: how do you gain access to it?
10:36:02 <chrisdotcode> i'm guessing it's some import
10:36:05 <dcoutts_> chrisdotcode: just import it
10:36:07 <dcoutts_> see the cabal user guide
10:36:20 <chrisdotcode> will do
10:36:54 <SrPx> How do you communicate with a javascript application using sockets? https://github.com/banacorn/socket.io-haskell 's example doesn't work
10:37:36 <Tekmo> I'm pretty sure there is a websockets library on Hackage
10:37:55 <Tekmo> SrPx: http://hackage.haskell.org/package/websockets
10:38:26 <SrPx> thanks
10:44:20 <SrPx> is there any way I can port an OpenGL application in Haskell to js?
10:44:56 <Twey> MP2E: With cojoin (Cofree (x, c)) = Cofree (Cofree (x, c), fmap (fmap (\y -> Cofree (y, c))) c) ?
10:47:04 <dmwit> A pure-JS software implementation of OpenGL would be a truly hideous thing to see. You should definitely do it.
10:47:07 <Denommus> SrPx: maybe emscripten?
10:47:58 <dmwit> More to the point: you should probably ask JS folks what to do about 3D graphics. No real reason to expect people in here to care (though some may know).
10:50:36 <Tekmo> SrPx: You mean port a Haskell application written against OpenGL to work against WebGL?
10:52:44 <SrPx> Maybe just a WebGL lib for haskell itself, which ran on top of a browser. Why? Same reason as using Haskell over C+OpenGL. Because you wouldn't need to actually write WebGL and JavaScript when you need to.
10:52:49 <merijn> Tekmo: After our last discussion I got the entire handshaking pipe to both AND actually look nice and readable :) I still need to do any performance benchmarking to see how well the entire thing performs, but I should get the library feature complete first :)
10:53:40 <Tekmo> merijn: That's awesome!
10:54:00 <Tekmo> merijn: I just want to mention that there's only one `pipes` feature that impacts performance and that's the use of the `Pipes.Lift` module
10:54:09 <Tekmo> merijn: If you use any functions in that module I can show you how to optimize that
10:55:01 <merijn> Tekmo: Right, so currently I'm using "hoist (lift.lift)" to get stuff from pipes-binary and pipes-parse to work with my custom state stack
10:55:10 <Tekmo> SrPx: Would you be compiling the Haskell application to Javascript or would the Haskell application generate an executable which produces the required Javascript?
10:55:21 <Tekmo> merijn: Oh, `hoist` is fine
10:55:31 <Tekmo> merijn: It's things like `distribute` or `runReaderP` which are slow
10:55:39 <Tekmo> merijn: Although, side note, you can still optimize `hoist` if you ever need to
10:55:41 <SrPx> Talryn: what works
10:55:50 <Tekmo> merijn: There is an `unsafeHoist` function in `Pipes.Internal` which is even faster
10:55:55 <Peaker> So, I thought more about how async exceptions are supposed to be used:  throwTo being synchronous -> forcing "mask" to be interruptible by default -> meaning that cleanups aren't guaranteed to happen, means the whole model is very very error prone
10:56:00 <Tekmo> merijn: unsafeHoist (lift . lift) is a safe usage of it
10:56:16 <DanielDiaz> if I have a type `t` which is instance of the Traversable class, and I define an NFData instance by `rnf t = foldl1 seq t `seq` ()`. Is this a good idea?
10:56:17 <merijn> Tekmo: Right now I have one use of runReaderP, I think
10:56:27 <Peaker> Whenever you write a bracket with a blocking cleanup -- a single async exception (after a single sync exception) can destroy all your invariants
10:56:41 <merijn> Peaker: Yes, it's an utter pain
10:56:45 <Tekmo> merijn: If it ever becomes a bottleneck, just send me an e-mail and I can help you optimize it
10:56:50 <Tekmo> merijn: It's very easy to optimize
10:56:53 <merijn> Tekmo: Will do :)
10:57:09 <Peaker> merijn: I think maybe an asynchronous throwTo (at least as an option) would have been a better choice!
10:57:19 <Peaker> because at least then maskUninterruptible could safely be the default
10:57:24 <merijn> Peaker: Yeah, I used significant amounts of uninterruptibleMask and painful debugging to fix it
10:57:28 <Peaker> and then invariants don't get easily broken
10:58:02 <jfischoff> Peaker, merijn: can you give a concrete example? I would like to understand these edge cases better
10:58:18 <Peaker> jfischoff: imagine you have some code using "withMVar"
10:58:33 * jfischoff nods
10:58:34 <Peaker> jfischoff: withMVar is supposed to guarantee the MVar is returned to the same state (of being full)
10:58:42 <jfischoff> right
10:58:58 <Peaker> now while the body is executed by withMVar, the mvar is filled by another thread
10:59:02 <Peaker> so withMVar's cleanup blocks
10:59:26 <Peaker> and now you get an async exception of any sort
10:59:34 <Peaker> And your MVar is broken!
11:00:06 <merijn> jfischoff: Basically, blocking operations can be interrupted even inside a mask, therefore any resource allocation/freeing which involves (potentially) blocking behaviour (like MVars) is broken in the presence of async exceptions
11:00:27 <jfischoff> merijn: ah
11:00:30 <Peaker> Or perhaps you have a:  withAsync that's supposed to prevent your child threads from leaking. But it blocks when killing child, but then it is killed - poof, invariants destroyed
11:00:31 <jfischoff> Peaker: question
11:00:53 <Peaker> merijn: tons of cleanup operations (throwTo, file close, ...) are blocking
11:00:58 <Peaker> and all of the invariants based on them are completely moot :(
11:00:59 <merijn> Peaker: I know
11:01:08 <merijn> Peaker: Oh, but throwTo is fine
11:01:18 <Peaker> merijn: it blocks but the effect is guaranteed to have happened?
11:01:21 <merijn> Peaker: You can't be interrupted while sending an interrupt, I think?
11:01:27 <Peaker> merijn: throwTo blocks
11:01:37 <Peaker> merijn: until thread can receive the interrupt
11:01:44 <jfischoff> Peaker: So I am blocked in withMVar waiting to be able to putMVar and I get an exception, it kills the putMVar, MVar is no in an invalid state, is that an correct rephrasing?
11:01:48 <Peaker> And I don't think it's maskUninterruptible?
11:01:57 <Peaker> jfischoff: yeah
11:02:07 <merijn> Peaker: oh, it is :(
11:02:37 <merijn> None of the masks in base are uninterruptible by default :\
11:03:08 <Peaker> perhaps throwTo guarantees synchronously that the exception is sent, and only waits for ack?
11:03:16 <Peaker> (but if killed, still causes the exception to be sent?)
11:03:30 <Peaker> probably not! because that would require an unbounded queue, which is probably why throwTo is synchronous
11:03:41 <merijn> Peaker: No, the docs explicitly says throwTo is interruptible :\
11:04:07 <Peaker> I have some awful deadlocks in a big complex composition of threads, and it's all because of cleanup destructions like this
11:04:42 <merijn> Peaker: I think johnw was working on a taskpool library that modelled things as a DAG of tasks with cleanups on failure, etc.
11:04:50 <Peaker> I thought it was safe to use Async transparently, but it isn't. Haskell concurrency is very unsafe and very error-prone because of all this!
11:05:10 <merijn> Peaker: Isn't STM an option for you?
11:05:15 <Peaker> merijn: how does it help?
11:05:19 <Peaker> merijn: I still have my brackets
11:05:30 <Peaker> merijn: I still have to kill threads
11:06:46 <merijn> Peaker: You can get STM transactions to simply retry on async exception, so if you replace your MVar usage with TMVar/TVar you at least eliminate that
11:07:09 <merijn> Peaker: If you can eliminate the blocking in your allocation/cleanup by using STM you will know your cleanup/alloc is atomic
11:07:35 <Peaker> say I have:  withProcess  which creates a process and then interrupts that process onException, and closes handles/waits on it in the finalization
11:07:37 <merijn> So it doesn't help with bracket/thread killing
11:07:39 <Denommus> yay, helm does not have a memory leak any longer!
11:08:00 <merijn> Peaker: But it might help by writing "unblocking" cleanup/allocation?
11:08:01 <Peaker> merijn: how can withProcess be used safely? (I don't think it can :-( )
11:08:12 <Peaker> what's that?
11:09:37 <Peaker> TaskPool is mostly about parallelism, it seems, and it's incompatible with my own parallelism management :(
11:09:47 <merijn> Peaker: Well, that you can have STM retry on exceptions which means you know the entire thing happened or nothing (and you can automatically retry in case of the latter!)
11:09:49 <Peaker> though I could read it for inspiration
11:09:59 <Peaker> merijn: but STM is just about local state mutation
11:10:03 <merijn> Peaker: Depends on what kind of blocking allocation/freeing thing you need
11:10:05 <Peaker> merijn: or global state mutation for that matter
11:10:17 <Peaker> merijn: it doesn't let me do things like close the file handles
11:10:49 <Peaker> I wonder if I write my own threading/concurrency framework -- with an async throwTo and nonInterruptibleMask being the default -- if things will work out better
11:11:17 <merijn> Peaker: I've considered the same, yeah :)
11:11:35 <Peaker> merijn: maybe an experiment should be thrown at hackage!
11:11:56 <merijn> We don't really have any good safe threading libraries yet, afaik
11:13:11 <Tekmo> `pipes-concurrency` was supposed to be that safe threading library, but ghc-7.8 broke its most useful feature: deadlock avoidance
11:15:33 <merijn> Tekmo: Well, pipes-concurrency doesn't have a fairly-queued mailbox yet, does it?
11:15:44 <Peaker> merijn: the amazing (And quite disappointing thing) here is really that I have discovered this from use, though all the documentation makes it seem like these concurrency primitives are all thought out/work well.
11:15:44 <Peaker> There's a huge warning on nonInterruptibleMask, iirc, but the rest is honky dory
11:17:04 <merijn> Peaker: I think at the time not many people considered this sort of use? If you look at Simon's PCH book it has loads of warnings about this
11:18:18 <Peaker> Tekmo: Does pipes-concurrency help make "withMVar" safe?
11:18:36 <Tekmo> merijn: No, it doesn't
11:18:51 <merijn> Peaker: pipes-concurrency doesn't expose MVars, it has it's own primitives
11:19:06 <Peaker> how do I use pipes-concurrency to avoid the pitfalls with bracket?
11:19:06 <Tekmo> Peaker: `pipes-concurrency` exposes a safer alternative to `MVar` that never deadlocks
11:19:22 <Peaker> Tekmo: does it forego async exceptions in favor of some other mechanism?
11:19:27 <Tekmo> Peaker: Yes
11:19:32 <Peaker> Tekmo: and bracket too?
11:19:49 <Peaker> Tekmo: Have to go offline, will read about it soon, thanks :)
11:19:52 <merijn> Tekmo: I figured, because that's what I find myself needing most here, I've been trying to implement an efficient IO and STM fair queue, but I keep getting stuck :p I have a possible design now, I think which I'll try after work
11:19:54 <Tekmo> Peaker: It doesn't use exceptions at all to communicate between threads
11:20:15 <Tekmo> Peaker: Just remember that it only works pre ghc-7.8
11:20:38 <Tekmo> merijn: The issue is STM itself
11:20:49 <Tekmo> merijn: STM doesn't have a fair `orElse` primitive
11:21:09 <merijn> Tekmo: Sure, but I need one in both IO and STM anyway
11:21:14 <Tekmo> merijn: Oh, ok
11:21:33 <merijn> Tekmo: I think the only sane approach is to just have a ring buffer you iterate over
11:21:45 <Tekmo> I'm still new to ring buffers, but I've heard of them
11:22:16 <merijn> Tekmo: Basically, imagine a queue of "ready" (i.e. non-empty) chans/queues/whatever and after you read one message append the queue at the end
11:22:29 <merijn> Tekmo: Newly ready ones go at the end as well
11:22:59 <Tekmo> merijn: Oh, I see
11:23:09 <Tekmo> So it's a little bit like round robin?
11:23:12 <merijn> That's the simplest way to guarantee fairness, I think
11:23:37 <merijn> Tekmo: It's round-robin, where idle queues don't block faster ones
11:23:59 <merijn> i.e. no point in blocking on idle queues, as long as you guarantee fast ones don't starve slow ones
11:24:13 <Tekmo> Oh, so if you have an idle queue at the front you just move it to the back?
11:24:30 <merijn> Tekmo: Oh, I would just not keep idle queues in the main queue at all
11:24:37 <merijn> Tekmo: Just queue them at the end when they become ready
11:24:48 <Tekmo> merijn: That makes sense
11:25:10 <Tekmo> I'm trying to think of what the Haskell type would be for that
11:25:17 <merijn> Tekmo: I mean, that's fairly simple to implement using Chan/TQueue
11:25:19 <Tekmo> If we replace queue with "STM transaction"
11:25:48 <merijn> Tekmo: But to make my life hard I want a preemptible one, i.e. if a connection dies it should remove itself from the main queue
11:26:17 <johnw> merijn: taskpool is entireyl based on STM
11:26:22 <johnw> (and async)
11:26:50 <merijn> Right now I have a "Chan (MVar TBQueue)" and do "readChan -> tryTakeMVar -> if Nothing then drop else operate on TBQueue and write back to Chan"
11:26:56 <merijn> But this is really cumbersome
11:26:59 <johnw> oh wow
11:27:03 <johnw> that's like layers upon layers
11:27:21 <merijn> On disconnect the connection just does takeMVar, leaving it empty on the queue
11:27:34 <merijn> But that litters the queue with dead connections and is really cumbersome to use
11:27:36 <Tekmo> merijn: I feel like the elegant interface to this would be a fair `orElse`/`msum`
11:27:53 <Tekmo> merijn: However, under the hood it might be really messy
11:28:22 <Tekmo> merijn: Maybe if GHC should have something like this as an STM built-in
11:28:22 <fryguybob> What are the semantics of a "fair" orElse?
11:28:42 <lpvb> can I use reactive banana on top of gtk2hs
11:28:45 <Tekmo> fryguybob: I just realized that it made no sense
11:28:46 <merijn> fryguybob: round-robin amongst all unblocked sources
11:28:54 <Tekmo> fryguybob: Or wait
11:28:54 <merijn> fryguybob: But yeah, it makes no sense in STM
11:29:25 <Tekmo> fryguybob: Maybe you can't make a fair orElse, but I think you can make a derived abstraction fair
11:29:29 <merijn> johnw: Well, if you have a simpler suggestion, I'm all ears :)
11:29:51 <Tekmo> fryguybob: Never mind.  Round robin doesn't have nice algebraic properties
11:30:16 <merijn> johnw: 1) implementing a preemptible queue is really hard to do safely and 2) any implementation I've come up with runs into the problem "even if I get a "dequeue" operation on insert, how do I update it after the first read/requeue"
11:30:19 <Tekmo> fryguybob: A fair merge of two lists is not associative and doesn't have an identity
11:30:29 <lpvb> Nevermind my previous question, but is reactive-banana a good library to start toying with FRP?
11:30:49 <johnw> merijn: I don't have a better answer atm
11:30:59 <merijn> johnw: Currently I'm thinking of implementing an actual circular buffer so I can keep a static dequeue operation and a moving "read" index
11:31:04 <Tekmo> Alright, I have to head out.  Nice talking with you all
11:31:08 <merijn> johnw: But that'll have to wait until after work :)
11:31:09 <zmbmartin> shachaf: So use Data.ByteString.UTF8?
11:31:15 <johnw> Tekmo: I'm thinking of rolling simple-conduit again, this time with a pipes compatible interface
11:31:30 <shachaf> zmbmartin: That's one option.
11:31:30 <Tekmo> johnw: There is a way we can interface with neither of us depending on each other's library
11:31:35 <shachaf> Seems like a reasonable one.
11:31:39 <johnw> Tekmo: how so?
11:31:53 <Tekmo> johnw: The trick is what we both provide a transformation from our respective types to church-encode versions
11:31:56 <Tekmo> johnw: i.e.
11:32:01 <zmbmartin> shachaf: Awesome thanks!
11:32:09 <Tekmo> johnw: fromPipe :: Proxy ... -> {church encoded Proxy}
11:32:22 <Tekmo> jordanl: toSimpleConduit :: {church encoded} -> SimpleCOnduit
11:32:27 <johnw> that should be easy, since mine is already a church encoding
11:32:28 <Tekmo> Oops
11:32:30 <shachaf> Church-encoded Proxy?
11:32:37 <johnw> (well, BB encoding)
11:32:40 <shachaf> Oh, not the usual Proxy type.
11:32:45 <Tekmo> shachaf: Yeah
11:32:48 <Tekmo> shachaf: The one in `pipes`
11:32:54 <Tekmo> johnw: Right
11:33:02 <johnw> Tekmo: sounds like an excellent idea
11:33:11 <Tekmo> johnw: So if you want I can add a function that consumes your church encoded simple conduit in `pipes`
11:33:19 <Tekmo> johnw: Because consuming a church encoded representation is dependency-free
11:33:26 <solidus-river> wasn't there a cool trick using fix to generate a list of the fibbonaci numbers?
11:33:32 <johnw> Tekmo: I've been played around with looking at conversions to/from many libraries: foldl, conduit, machines, etc.
11:33:41 <Tekmo> johnw: This is the same trick I use to add `foldl` support to my libraries without actually depending on `foldl`
11:33:42 <johnw> Tekmo: yes, let's do that
11:34:08 <johnw> Tekmo: I think the winds are blowing in the direction of pipes, so I'd like simple-conduit's interface to use yours, and provide a "no frills pipes" for those who need nothing extra
11:34:28 <Tekmo> johnw: I think all the streaming libraries should provide church-encoded translations so that we can interoperate
11:34:29 <johnw> but for me, the UI layer is *extremely* thin
11:34:35 <johnw> agreed
11:34:55 <johnw> at its core, simple-conduit can be used with just (.) and ($)
11:34:55 <Tekmo> *BB-encoded
11:35:03 <johnw> whatever operators I support on top of that is just syntax
11:35:20 <Tekmo> Anyway, I have to head out, though
11:35:23 <johnw> but I want to pick a syntax more people will find familiar
11:35:31 <johnw> Tekmo: ok, let's talk again soon
11:35:32 <jle`> fare thee well
11:35:32 <Tekmo> Open an issue on the `pipes` repo to remind me
11:35:35 <johnw> Tekmo: are you coming to ICFP?
11:35:43 <solidus-river> > fix ((0:) . scanl (+) 1)
11:35:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:35:55 <Tekmo> johnw: No, I totally forgot about it
11:35:59 <johnw> :(
11:36:05 <Tekmo> johnw: However, next year for sure
11:36:13 <johnw> ok, i'll ping you after, opening issue now; farewell!
11:36:22 <lpvb> strange, if I search 'reactive-banana' on hackage it won't show reactive-banana-sdl but will show reactive-banana-wx. If I search 'reactive banana' it will show them all though. Maybe packages with hyphens in their names should have their keywords split up?
11:36:24 <Tekmo> Awesome!  Talk to you later
11:36:44 <hexagoxel> would it make sense, in order to achieve module-local, package-local and public visibility, to have two modules (one exposed, one not) for each logical module in a package?
11:38:56 <victor__> hey guys, I am a beginner programmer, the only language I have really dived into is python, would haskell be a good second language?
11:39:17 <simpson> victor__: Sure.
11:39:36 <Denommus> victor__: yes :)
11:39:43 <Denommus> victor__: it will teach you a lot
11:39:57 <SrPx> Ok you suggested websockets, but there is the problem that websockets is not supported by all clients. socket.io is nice that it can fallback to http when needed. does anyone know how to make socket.io work on haskell? the example here is clearly wrong: https://github.com/banacorn/socket.io-haskell
11:40:05 <victor__> in what way would it complement python? as in what can haskell do for me that python can't?
11:40:09 <jle`> victor__: you might have had better luck in that case with haskell as a first language, perhaps, but i think having it as a second language here is pretty great nonetheless :)
11:40:51 <jle`> safety and (if done right) performance
11:40:54 <btubbs> victor__: type strictness (and power).  lazy evaluation.  functional style programming.
11:40:57 <jle`> mostly safety
11:41:01 <simpson> victor__: Mu. They are different languages but they are both general-purpose programming languages that are capable of the same stuff.
11:41:44 <jle`> the stylistic differences are a nice touch, but it is hard to quantify it as an advantage
11:42:06 <tomqq> it'll make you a better python programmer ;)
11:42:25 <MP2E> victor__: In Haskell, the compiler is a co-author. If your program is logically inconsistent(verified through types) the program won't compile. The refactorability factor is amazing! Even large codebases can be refactored with a level of assurance that once the code compiles, it will 'just work'
11:43:18 <Denommus> victor__: Haskell will teach you about types like few other languages can
11:43:24 <victor__> what haskell tutorials do you recommend?
11:43:34 <tomqq> learnyouahaskell.com/chapters
11:43:36 <Denommus> victor__: learn you a haskell for great good
11:43:36 <bennofs> @where lyha
11:43:36 <lambdabot> I know nothing about lyha.
11:43:39 <btubbs> http://learnyouahaskell.com/
11:43:40 <bennofs> @where lyah
11:43:40 <lambdabot> http://www.learnyouahaskell.com/
11:43:44 * bennofs is slow
11:43:56 <jle`> haskell gives you static (comepile-time) guaruntees about your code.  in python you often debug and test at "run-time" --- run the program, and see where you mess up.  in haskell, you are more often debugging and testing at "compile-time".  if your program is wrong, you'll know before it even has to run
11:44:02 <victor__> wow that was pretty unanimous
11:44:05 <jle`> ~.~*~ magic ~.~*~
11:44:15 <jle`> there's a nice guide on the topic of #haskell-beginners too
11:45:07 <btubbs> after LYAH, http://www.haskell.org/haskellwiki/Typeclassopedia has been the most helpful thing for me to make sense of how the different parts of the language fit together
11:45:14 <btubbs> (still a novice though)
11:45:32 <jle`> you can probably see that run-time debugging is potentially much more difficult than compile-time debugging.  sometimes errors don't even manifest at runtime except for in specific situations in cases you are unlikely to test until it shows up in the real world
11:46:00 <dmwit> victor__: the Gentle Introduction
11:46:05 <jle`> haskell provides guaruntees that other languages (and even other statically typed languages) can only dream of
11:46:05 <dmwit> There, now it's not unanimous. =)
11:46:21 <monochrom> victor__: Haskell takes the opposite stance of Python's on many issues
11:46:27 <dmwit> ?where tutorials
11:46:27 <lambdabot> http://haskell.org/haskellwiki/Tutorials
11:46:35 <monochrom> when it comes to language design
11:47:14 <Denommus> jle`: well, OCaml is mostly equivalent in abstraction power. Only it uses the module system instead of type classes
11:47:30 <Denommus> and it isn't as pure
11:47:40 <sivteck> > "moar" ++ "power"
11:47:41 <lambdabot>  "moarpower"
11:47:59 <jle`> Denommus: thanks for calling me out :)
11:48:04 <monochrom> I like OCaml's type system too.
11:48:04 <jle`> s/other languages/many other languages
11:48:23 <monochrom> but at the end of the day, I prefer the type "Int -> Int" to have no effects
11:48:37 <SrPx> nobody?
11:48:41 <marchelzo_> Is there a way to regex substitutions on bytestrings without unpacking them and then re-packing them?
11:48:43 <jle`> ah yeah.  more guaruntees from the types
11:49:11 <Denommus> oh, I much prefer its module systems over type classes. But I dream about a language that uses linear types to control side effects instead of both Haskell's and OCaml's approach
11:50:23 <Denommus> like `getChar :: ~World -> (Char, ~World)`, where ~ marks the type as linear
11:51:17 <dmwit> Have you looked at that one language... Clean, I think... that uses uniqueness types?
11:51:17 <Denommus> and then applicative functors in the module level would be perfectly possible (OCaml's modules are generative instead, unfortunately)
11:52:10 <Denommus> dmwit: yeah, but it doesn't have SML/OCaml's module system. I guess if I want such a language I'll need to create it some day
11:52:43 <dmwit> Ah, designing a language. Always a fun and regrettable act. =)
11:53:02 <johnw> first I want to design a better language designer
11:54:35 <Denommus> I need to first finish my FRP library in Rust before diving into that. XD
11:55:21 <Fuuzetsu> I imagine you can't ever finish before stable considering you have to rewrite it to work every 3 days
11:56:56 <monochrom> @quote monochrom design.*language
11:56:56 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
11:59:22 <Denommus> Fuuzetsu: yup, returning closures from functions, for instance, is completely broken :-/
11:59:38 <Denommus> Fuuzetsu: but the language is getting near stability
12:00:16 <Fuuzetsu> as I always say when this comes up, I'm not interested until my programs still work 3 days later
12:00:48 <Denommus> I'm not here to preach it, don't worry
12:01:11 <Fuuzetsu> yup, just saying
12:02:23 <bennofs> Is there anything particular about haskell that causes long compile times? Or is it just that it needs much optimizations?
12:02:54 <Denommus> bennofs: the type checking is a lot of work
12:06:24 <solidus-river> what are sparks?
12:06:32 <SparkySparkyBoom> yes?
12:06:40 <solidus-river> lol
12:06:52 <solidus-river> on haskell.org/platform it boasts haskell supports sparks
12:06:57 <solidus-river> what does that mean in that context
12:07:01 <solidus-river> er
12:07:03 <solidus-river> thread sparks
12:08:30 <bennofs> solidus-river: I think sparks is an even more-lightweight form of threads
12:08:35 <sm> rivers of fire spewing from your pc's vents due to all the parallel
12:08:58 <bennofs> solidus-river: You can have very many sparks, which get scheduled to many threads, which are then scheduled to run on multiple CPUs
12:09:11 <solidus-river> bennofs: since asking here i tried googleing and it seems like sparks are lazy paralellism?
12:09:21 <solidus-river> bennofs: ie, this could be a new thread if that makes sense?
12:09:37 <solidus-river> does a spark always get evaluated in a timely manner
12:09:41 <bennofs> solidus-river: yeah, something like that. (I haven't used sparks myself)
12:09:45 <solidus-river> or can you know by spark blocked
12:09:52 <solidus-river> *now
12:09:53 <solidus-river> :P
12:10:54 <dolio> Denommus: If you design a language, it shouldn't use uniqueness types for I/O. World passing makes no sense as a model for it.
12:10:54 <bennofs> solidus-river: a spark is a hint to the runtime: if you can evaluate this expression now if possible
12:11:34 <solidus-river> cool
12:11:56 <bennofs> solidus-river: so if you have let p = veryExpensiveComputation, q = alsoVeryExpensive; then you can do: p `par` q `par` (p,q), so the runtime will spark p and q (hint to evaluate p and q in parallel)
12:12:36 <bennofs> solidus-river: http://stackoverflow.com/questions/958449/what-is-a-spark-in-haskell has a nice graphic
12:13:32 <solidus-river> > fix ((0:) . scanl (+) 1)
12:13:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:13:50 <solidus-river> benofs, thats really cool as a side i need to get why that works with fix
12:13:55 <solidus-river> does fix feed itself into itself?
12:14:08 <bennofs> solidus-river: fix is defined as fix f = f (fix f)
12:14:53 <bennofs> solidus-river: so fix f expands into an infinite expression f (f (f (f (f (f ... )   (imagine that last ) to be infintely many )
12:15:11 <solidus-river> aye, i'm confused by the ocmposition though, why isn't it
12:15:14 <bennofs> solidus-river: because f might ignore it's argument, that "chain" will end sometime
12:15:26 <solidus-river> > fix (0: scanl (+) 1)
12:15:28 <lambdabot>  Couldn't match expected type ‚Äòa -> a‚Äô with actual type ‚Äò[a0]‚ÄôCouldn't match ...
12:15:45 * hackagebot serialport 0.4.7 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.7 (JorisPutcuyps)
12:15:47 <solidus-river> composing a scan with a list is wierd, i'm having trouble following what that does
12:15:56 <bennofs> so fix
12:16:08 <bennofs> solidus-river: (0:) :: [Integer] -> [Integer]
12:16:13 <bennofs> solidus-river: it prepends 0
12:16:29 <solidus-river> :t (0:) . scanl (+) 1
12:16:30 <lambdabot> Num a => [a] -> [a]
12:17:06 <solidus-river> it prepends 0 then scanes its list to the right starting at 1
12:17:10 <bennofs> fix ((0:) . scanl (+1) 1) = (0:) . scanl (+1) 1 $ fix ((0:) . scanl (+1) 1)
12:17:45 <bennofs> now, if we assume that fix ((0:) . scanl (+1) 1) = fibs, then we get fibs = (0:) . scanl (+1) 1 $ fibs
12:18:13 <bennofs> this leads us to the usual definition of fibs in haskell:
12:18:31 <bennofs> > let fibs = (0:) . scanl (+1) 1 $ fibs
12:18:32 <lambdabot>  not an expression: ‚Äòlet fibs = (0:) . scanl (+1) 1 $ fibs‚Äô
12:18:36 <bennofs> > let fibs = (0:) . scanl (+1) 1 $ fibs in fibs
12:18:37 <lambdabot>  Occurs check: cannot construct the infinite type: a1 ~ a1 -> a1
12:18:37 <lambdabot>  Expected type: a1 -> a1 -> a1
12:18:37 <lambdabot>    Actual type: a1 -> a1
12:18:37 <lambdabot>  Relevant bindings include fibs :: [a1] (bound at <interactive>:1:5)
12:18:46 <bennofs> oh hmm, somewhere I made an error
12:18:57 <solidus-river> > let fibs = (0:) . scanl (+) 1 $ fibs
12:18:59 <lambdabot>  not an expression: ‚Äòlet fibs = (0:) . scanl (+) 1 $ fibs‚Äô
12:19:02 <solidus-river> oh
12:19:02 <solidus-river> lol
12:19:39 <bennofs> > let fibs = (0:) . scanl (+) 1 $ fibs in fibs
12:19:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:19:53 <bennofs> ah, I introduced a (+1) instead of (+) somewhere
12:20:10 <solidus-river> is that an ifficient representation, i suppose so, its only ever adding 2 eleemnts
12:20:39 <bennofs> solidus-river: that definition is memoized, yes.
12:20:47 <bennofs> > let fibs = (0:) . scanl (+) 1 $ fibs in fibs !! 900
12:20:49 <lambdabot>  5487710883948000005141367394838371444380051930912359272449495342703981120106...
12:20:58 <bennofs> > let fibs = (0:) . scanl (+) 1 $ fibs in fibs !! 9000
12:21:01 <lambdabot>  3461602912866847463132892729406531958210049388405746491977923548826267614512...
12:22:52 <solidus-river> bennofs: thanks for helpin me get that and sparks :)
12:23:17 <alpounet> bennofs: hey, while you're around, I saw you were adding benchmarks to hnix, any numbers yet? (note: I haven't checked the repo in a few days, maybe there's smth there now)
12:24:00 <bennofs> alpounet: parse time for all-packages.nix is ~2.5s on my laptop (the laptop is not very fast)
12:24:51 <alpounet> bennofs: oh alright, that should be fine after a couple of optimizations
12:24:52 <bennofs> alpounet: The benchmarks are just some random files, so that we get at least *some* indication whether a change resulted in better perf or not
12:25:33 <johnw> actually, let me look at that now
12:27:30 <alpounet> bennofs: right. 2.5s isn't so bad actually, for a first shot a the parser. and i'm sure johnw and you will speed that up in no time :)
12:28:18 <fread2282> (how) can I do class A (c :: * -> Constraint) a?
12:28:41 <bennofs> fread2282: just do class A (c :: * -> Constraint) a ?
12:28:55 <fread2282> Not in scope: type constructor or class ‚ÄòConstraint‚Äô
12:29:01 <bennofs> fread2282: you'll need -XMultiParamTypeClasses, -XConstraintKinds, -XKindSignatures and import GHC.Exts
12:29:11 <fread2282> I have ConstraintKinds enabled
12:29:19 <bennofs> fread2282: import GHC.Exts
12:29:40 <fread2282> thanks
12:33:43 <bam365_> if I write a function fib n = fib (n - 1) + fib (n - 2) (w/ fib 0 = 0 and fib 1 = 1), why is it so much slower than the canonical fibs implementation?
12:33:59 <bennofs> bam365_: because it does not memoize results
12:34:38 <bennofs> bam365_: consider fib 4. This will need to calculate fib 3 and fib 2. But note that fib 3 will also need to calculate fib 2! This means that a lot of work is duplicated
12:35:12 <bennofs> bam365_: with the canonical version, the result of fib 2 will be memoized, meaning the result will be saved and not calculated again in future "calls"
12:35:20 <bam365_> so fibs is self-memoizing because it's a list a not a recursive function
12:35:25 <bennofs> bam365_: yes
12:35:48 <bennofs> bam365_: each element of the list will only be calculated once and then kept in memory
12:38:46 <johnw> bennofs: the main culprit is the nixPath parser
12:38:51 <johnw> it's very inefficient
12:39:16 <johnw> lots of string-building that is thrown away, combining with too much backtracking
12:39:40 <bennofs> johnw: yeah, paths in nix are quite ambiguous :/
12:39:47 <johnw> can you give me the precise rule?
12:40:01 <johnw> it might be easier to check for protocol://
12:40:05 <johnw> rather than /<not />
12:40:19 <bennofs> johnw: do you mean uri or paths?
12:40:37 <helpta> johnw: are you a nix/nixos contributor?
12:40:40 <johnw> so, try to parse a Uri first
12:40:50 <johnw> helpta: I help maintain darwin support for nixpkgs
12:41:00 <helpta> ah
12:41:00 <bennofs> johnw: a path is something that contains at least one slash. but it also may not contain a double slash, because a double slash must be parsed as an update operator
12:41:12 <johnw> what if we try to parse a Uri first
12:41:16 <johnw> and if that fails, assume it is a path?
12:41:26 <johnw> (if it has a slash)
12:41:41 <johnw> let me give that a try
12:42:02 <bennofs> johnw: the problem is that there a 3 types of non-quoted-text-like things: 1) uris 2) paths and 3) identifiers
12:42:08 <johnw> right
12:42:23 <johnw> so, I think that instead of back-tracking, we may need to unify these three parsers
12:42:25 <bennofs> johnw: I think I have test cases for most of the edge-cases, so you should see failures if you mess up :)
12:42:38 <johnw> i.e., parse the most general thing that any one of them could be, and then examine the actual value we get to decide which it is
12:42:50 <helpta> has anybody played with hdf5 and haskell?
12:43:39 <bennofs> johnw: another thing to take care of: <abc> is a SPATH, while a<b is a a LT b
12:43:46 <johnw> sure
12:43:52 <johnw> but this is where the speed is going
12:43:52 <bennofs> johnw: also, a<bc> is a function application
12:44:04 <johnw> all the backtracking that happens in nixUri, nixSPath and nixPath, before parsing a real string
12:44:17 <johnw> ok, I'll leave the fix to you then
12:44:21 <johnw> since you understand the subtleties
12:44:57 <bennofs> johnw: and another problem: lambda vs nixUri. a:a is an uri, while a: a is a lambda :/
12:45:17 <johnw> can we postpone all atempts at path/uri parsing?
12:45:23 <Denommus> dolio: why do you think so?
12:45:27 <johnw> i.e., are there other more certain things it could be?
12:45:39 <johnw> if we can do that, then again we can glom them all together and then decide after we parse
12:45:49 <Denommus> dolio: I actually think it makes MORE sense than Haskell's approach, because it will maintain referential transparency even on IO
12:45:57 <johnw> having decision logic based on parser lookahead is always expensive
12:46:05 <Denommus> dolio: and if you want to make it implicit, you can use the State Monad
12:46:10 <bennofs> johnw: well, if we don't parse a/b as a path, it will be parsed as a div b
12:46:18 <Peaker> merijn: Reading Marlow's book CPH now, and I see he's using the modifyMVar example as an example of how mask is a *safe* operation, weird!
12:46:31 <johnw> bennofs: does div require spaces around the operator?
12:47:09 <solidus-river> where does fix come from?
12:47:20 <solidus-river> is the default monad fix?
12:47:47 <merijn> Peaker: It's safe if you can guarantee your MVar operation won't block
12:47:59 <bennofs> johnw: hmm, I could try that.
12:48:12 <Peaker> merijn: hmm. for most such uses of MVar it's indeed probably the case
12:48:15 <merijn> Peaker: You can only be interrupted when actually blocking
12:49:33 <merijn> Which requires you to carefully audit exactly how the code can be used, etc.
12:49:38 <solidus-river> > [x | x <- fix ((0:) . scanl (+) 1, x < 10]
12:49:39 <lambdabot>  <hint>:1:42: parse error on input ‚Äò]‚Äô
12:50:00 <solidus-river> > [x | x <- fix ((0:) . scanl (+) 1), x < 10]
12:50:04 <lambdabot>  mueval-core: Time limit exceeded
12:50:09 <Peaker> I have ~20 or more tabs open on various thread abstractions in hackage that I need to read through to see if anyone addressed this problem
12:50:12 <solidus-river> is there a way to get that toterminate?
12:50:18 <solidus-river> * to terminate
12:50:24 <solidus-river> :t takeWhile
12:50:25 <lambdabot> (a -> Bool) -> [a] -> [a]
12:51:44 <ij> I lifted a bunch of stuff into IO and my program stopped working. might that happen because of lifting stuff in IO or I did something else that is stupid?
12:53:51 <Peaker> merijn: to make throwTo asynchronous, I guess one could forkIO a thread just in order to throwTo, though that's a bit ridiculous :)
12:54:43 <zwarn> if someone is willing to guide me through some type/monad confusion in the parser i am trying to make please pm me
12:54:55 <Peaker> zwarn: Why not ask here?
12:56:49 <zwarn> i have a parser that works with a monad stack for state, reader, writer
12:57:02 <zwarn> and i have a print-eval-loop
12:57:35 <merijn> zwarn: If you use all three of those, you may just wanna use RWST which combines them into a single one :)
12:58:00 <merijn> ij: "Yes"
12:58:35 <zwarn> very interessting
12:58:44 <zwarn> i will look at that
12:58:48 <Peaker> zwarn: what's the problem?
12:59:45 <zwarn> i cant find a way to pass the state information through my eval loop
12:59:56 <zwarn> in a monadic way
13:00:04 <merijn> What's a good intro to linear and uniqueness types?
13:00:10 <Peaker> hmm: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception.html#g:13 says: "if the takeMVar was not interruptible, then this particular combination could lead to deadlock, because the thread itself would be blocked in a state where it can't receive any asynchronous exceptions. With takeMVar interruptible, however, we can be safe in the knowledge that the thread can receive exceptions right up until the point when the takeMVar succeeds" <-- i
13:00:10 <Peaker> sn't this more simply true if you use "restore (takeMVar m)" ?
13:00:18 <johnw> merijn: I liked Rosetta Stone, actulaly
13:00:29 <merijn> zwarn: runState should return the state at the end, so just pass that into the next iteration?
13:00:44 <johnw> http://math.ucr.edu/home/baez/rosetta/rose3.pdf, read pages 35-40
13:00:52 * hackagebot hindent 0.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-0.0 (ChrisDone)
13:01:00 <johnw> but there are probably better intros
13:01:01 <Peaker> zwarn: your monad stack can have IO at the bottom, so you can do the REPL?
13:01:05 <marchelzo_> How can I import a module from the parent directory?
13:01:56 <merijn> johnw: I was hoping for a TaPL-style "I'm considering implementing this" type of intro ;)
13:02:02 <Clint> are there success monads alternate to EitherR?
13:02:04 <johnw> ah
13:02:23 <johnw> merijn: http://cs.ioc.ee/~tarmo/tsem11/jeltsch1602-slides.pdf?
13:03:03 <dolio> Denommus: The semantics of functions and tuples are wrong to make sense of world passing as an I/O program.
13:03:13 <johnw> merijn: also http://okmij.org/ftp/Computation/resource-aware-prog/region-io.pdf
13:03:22 <dolio> It is merely having functions with side effects and using the tokens to keep them in the right order.
13:03:32 <dolio> Not making sense of the side effects.
13:03:59 <alpounet> johnw: what's the parser used in hnix now? trifecta?
13:04:09 <johnw> alpounet: parsers, so either trifecta or parsec you choose
13:04:10 <alpounet> i remember it depends on "parsers" to easily switch
13:04:21 <alpounet> yeah, but the one that parses all-packages.nix in 2.5
13:04:25 <fread2282> is there any way I can do simple value -> type functions?
13:04:25 <alpounet> i guess it's trifecta :)
13:04:32 <alpounet> 2.5s *
13:04:32 <merijn> johnw: I've decided that trying to do sensible exception/bottom handling in my language idea is untractably hard. Next idea: Use linear/uniqueness types and track totality and only allow difficult behaviours on total values :p
13:04:34 <johnw> either way it will be slow for the same reason
13:06:06 <edwardk> merijn: just build everything on top of display logic then you can throw all the modalities in a blender and pick what you want
13:06:47 <merijn> edwardk: I have no clue what that meant :)
13:07:15 <lpaste> zwarn pasted ‚ÄúHow to get give the state to the next Iteration in the eval-loop‚Äù at http://lpaste.net/110153
13:07:21 <edwardk> merijn: http://www.pitt.edu/~belnap/87displaylogic.pdf
13:07:40 <angerman> How do I sort a list of Maybe UTCTime descending?
13:07:57 <ij> main' works, main'' doensn't. Why? http://sprunge.us/TJZY
13:08:21 <angerman> where Nothing < Just anything.
13:08:24 <bennofs> johnw: btw, I have tried attoparsec, without specially using attoparsec's parsers I got ~1.5s for all-packages.nix
13:08:49 <johnw> using attoparsec well requires changes some use patterns
13:08:57 <edwardk> merijn: anywyas, display logic is a sort of logical hack that makes it easy to throw in connectives, modalities, etc. from all corners of logic and preserve the admissability of cut. -- the ability to form a lemma / write a function
13:09:03 <johnw> like using satisfy (a predicate over Word8's) instead of oneOf
13:09:12 <edwardk> merijn: so by curry howard you get a type system with those sorts of properties
13:09:27 <edwardk> i'm just not smart enough to program in my previous attempt at doing so ;)
13:09:46 <merijn> edwardk: Then what hope do I have? :)
13:09:53 <bennofs> yeah, I tried some of that in branch (was interested to see how fast I can get it), but somehow I introduced a space leak (parsing all-packages.nix never finished) and didn't want to track it down
13:10:01 <edwardk> merijn: i went a bit overboard. you might show more restraint ;)
13:10:20 <johnw> bennofs: once you fix path parsing, we can look at what rises to the top of the profile next
13:10:25 <edwardk> i'd also blended it with a bunch of other unrelated things all at the same time
13:12:39 <merijn> edwardk: I was inspired by the composable effects stuff they're doing at MSR (there was a presentation at OPLSS) and my earlier idea of having orthogonal+extensible typing passes
13:13:36 <merijn> edwardk: One critical issue with my idea was that adding extra typing info in a way that makes sense for datatypes that were defined before they existed is non-obvious
13:15:05 <merijn> Like, if there's a datatype with 4 fields, which doesn't export them and the datatype doesn't export them, then retroactively annotating the datatype with new type information isn't really doable
13:17:10 <Peaker> the unbounded-delays package: Frees you from the restriction to threadDelay only under 300000 years, you can use any Integer :)
13:17:51 <merijn> Peaker: Except you can't
13:18:03 <Peaker> why not?
13:18:38 <merijn> Peaker: Long timeouts are buggy and I patched it, which broke it in a different way, so I patched the patch and broke it back the original way (3 reviewers not noticing this) and I haven't got around to fixing the fix of my fix :p
13:19:02 <Peaker> merijn: well, it could just loop around a short timeout?
13:19:19 <merijn> Peaker: Yes, but the max timeout is currently broken on several platforms :)
13:19:28 <merijn> It will crash on OSX, for example :)
13:19:58 <zygs-zegs> Hey guys, what is a better way to write: (fmap . fmap . fmap . fmap) mappingFunction MySuperNestedFunctors ?
13:20:01 <Peaker> well, just found it funny that someone was bothered by the Int restriction (~300K years!)
13:20:02 <merijn> But I don't have the time to build and test a fix :)
13:20:50 <merijn> > maxBound :: Int32 `div` 1000000
13:20:52 <lambdabot>  <hint>:1:25:
13:20:52 <lambdabot>      Illegal literal in type (use DataKinds to enable): 1000000
13:21:01 <merijn> > (maxBound :: Int32) `div` 1000000
13:21:03 <lambdabot>  2147
13:21:05 <Peaker> zygs-zegs: point-fully? (Assuming the fmaps are for the function instance)
13:21:05 <Peaker> merijn: Int64 here
13:21:09 <merijn> Peaker: No
13:21:16 <merijn> Peaker: You're limited to CInt :)
13:21:18 <tommd> Peaker: Perhaps they are astrophysicists?
13:21:22 <merijn> Peaker: Due to aforementioned bug
13:21:39 <zygs-zegs> point fully or not, I feel like the (fmap . fmap . fmap . fmap) looks ugly and might be reducible
13:21:47 <merijn> Peaker: And 64bit on GHC uses 32bit for int
13:21:50 <merijn> eh
13:21:54 <merijn> s/GHC/OSX
13:22:10 <Peaker> merijn: oh, using Int32 for microseconds is crazy
13:22:10 <pixman> what are the fields, where Haskell more efficient?
13:22:13 <merijn> Peaker: So it's a max of 2147 seconds on my machine
13:22:26 <pixman> *is
13:22:30 <tommd> pixman: Define efficient.  For the human, the computer, or perhaps something else?
13:22:34 <merijn> Peaker: Oh, it might actually do more
13:22:46 <Peaker> zygs-zegs: well, it's tricky because each "fmap", while it looks the same, has a different type
13:22:53 <pixman> for programmers productivity
13:23:03 <merijn> Peaker: I just realised it probably divides by 1000000 before converting to Int32
13:23:11 <Peaker> zygs-zegs: so it's hard to generalize it to something like (x 4 fmap)
13:23:44 <Peaker> btw, having "Int" and no fancier type to represent time with "microseconds by convention" is also very silly
13:23:56 <Peaker> you have a type system, use it!
13:24:02 <zygs-zegs> Peaker: hmm, well that kinda sucks...
13:24:05 <tommd> pixman: I'd say writing languages and compilers (DSLs or otherwise) has some evidence to suggest an efficiency gain vs some other languages.  In general these questions are hard to answer objectively.
13:24:43 <Peaker> zygs-zegs: it's still quite concise and nice, compare with unwrapping it all (as that is usually done in most PLs)
13:25:03 <Twey> Anybody read http://tomasp.net/blog/2014/why-coeffects-matter/ ?  I think these use cases are sufficiently handled by monads (and sometimes constructor hiding) already, which makes me feel like I'm missing something.
13:25:06 <Peaker> zygs-zegs: you could define ad-hoc: fmap1, fmap2, fmap3, fmap4, etc
13:25:15 <pixman> ok, thx anyway :)
13:26:12 <zygs-zegs> I  was thikning of defining "deepFmap" in a where clause, but the function is so short a where clause seems inapropriate
13:26:54 <Twey> { sensitive } looks a lot like a monad with a hidden constructor (and perhaps certain ‚Äòtrusted‚Äô extraction functions).  { database }, { gps }, { metro }, &c. are all just Reader.
13:29:01 <glguy_> zygs-zegs: If you're fmapping down 4 levels it's quite likely that it means you have some types to name
13:29:14 <glguy_> rather than building up such a complex type
13:30:47 <zygs-zegs> Peaker: This looked promising: fmapN = (foldr1 (.) .) . replicate
13:30:59 <zygs-zegs> Peaker: but the types are off for fmap
13:31:44 <helpta> Twey: I thought coeffects are like monads in F#
13:32:30 <zygs-zegs> Peaker: after a little hacking around, I understand what you mean about the types of each fmap baeing different
13:33:12 <zygs-zegs> I think it's a lost cause, I'm okay with the verbose (fmap . fmap . fmap . fmap)
13:36:01 <Mokosha> does anyone have any good strategies for debugging intermittent segfaults in haskell programs?
13:36:12 <Mokosha> my program is crashing and I have no idea why
13:36:36 <Mokosha> I thought type safe programs shouldn't do that ;)
13:36:43 <dolio> Either it's a bug you should report to GHC, or you're doing something where you should know the source of the segfault.
13:37:07 <dolio> Or your computer has issues, maybe.
13:37:57 <helpta> Mokosha: strace
13:38:06 <Mokosha> what is strace?
13:38:29 <Trollinator> a tool to trace a program's syscalls.
13:38:29 <helpta> It traces system calls
13:38:35 <monochrom> my general list of suspects, from more likely to less likely (according to me anyway): the program uses backdoors (e.g. unsafePerformIO), the hardware has faults, compiler bug
13:40:34 <zwer> Mokosha are you using FFI? or any of the unsafe* functions
13:41:13 <Mokosha> I'm using OpenGL
13:41:24 <Mokosha> actually there's a place where I convert lists to ptrs
13:41:31 <Mokosha> I'll check that, thanks guys
13:41:34 <merijn> That sounds like a likely suspect
13:41:46 <merijn> Mokosha: You may be interested in the Debug.Trace module :)
13:42:03 <Mokosha> yea, I trace a lot
13:42:09 <Mokosha> laziness makes my brain hurt sometimes though
13:43:12 <monochrom> sometimes, Debug.Trace tells you what laziness does.
13:43:30 <monochrom> however, segfault is unlikely to be related to laziness
13:44:14 <monochrom> nonetheless, Debug.Trace helps you find out the order of events, including order caused by laziness.
13:45:18 <Mokosha> that usually requires a lot of wrapping in trace
13:46:40 <helpta> Mokosha: strace will help you narrow down the cause significantly in most cases
13:47:12 <coppro> which binds tighter? higher or lower precedence number on the fixity declaration?
13:47:29 <monochrom> higher is tighter
13:47:51 <monochrom> I always use ":info * +" at ghci to remind me of that :)
13:48:32 <arpnk> Mokosha: You can also check trace things out with DTrace (In FreeBSD, Solaris derivates, Linux and OSX)
13:48:44 <arpnk> s/check//
13:49:53 <Trollinator> I love how you can express in Haskell the type of lists of functions that can be composed.
13:51:18 <Iceland_jack> coppro: https://ghc.haskell.org/trac/ghc/ticket/8751 for future reference
13:59:27 <trap_exit> in haskell, instead of saying [a], is it possible to say: this is a heterogeneous list of objects, all of which has (ToFoo) defined on it?
13:59:42 <trap_exit> it's not "ToFoo a => [a]" since this means that I must pick some class which suports ToFoo, and have an entire list of that one class
13:59:59 <trap_exit> I want ahtegereous list, where the only thing we know is that w esupport "ToFoo" on each element of the list
14:00:15 <Shockk> trap_exit: using existential quantification or GADTs, you're able to do that
14:00:31 <trap_exit> Shockk : great, can you point me at reading material?
14:00:32 <glguy_> There are 3 ways: ImpredicativeTypes (basically the wrong way), existential quantification (better), finding a way to not need that (best)
14:01:03 <trap_exit> for the sake of learning; how do I learn about the wrong + better ways?
14:01:28 <Shockk> this page is where I learned about them (very recently actually): http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
14:01:36 <glguy_> Oh, actually, impredicative types won't help with the existential version
14:01:58 <trap_exit> glguy_: too late, alrready started reading http://www.haskell.org/haskellwiki/Impredicative_types
14:02:03 <trap_exit> Shockk: added as 2nd element on reading list
14:02:08 <glguy_> You can still learn about what it is
14:02:24 <coppro> Iceland_jack: heh
14:02:49 <coppro> trap_exit: the general rule is that all the ways suck, it's easier to add the ToFoo a requirement on the functions which use your type
14:02:50 <bennofs> trifecta question: the parser runUnspaced (Unspaced $ token $ char 'a') should not accept "a ", correct?
14:03:27 <trap_exit> http://www.haskell.org/haskellwiki/Impredicative_types
14:03:28 <trap_exit> wtf
14:03:31 <trap_exit> I still don't get what it does
14:03:40 <trap_exit> the example makes no sense and looks stupid
14:04:13 <coppro> trap_exit: yes
14:04:15 <coppro> :P
14:04:21 <Shockk> from what I've seen, GADTs are similar except they're defined in a way similar to that of instances, but you'd have to look them up for specifics; I read that in GHC, existentially quantified types and GADTs are equivalent
14:04:31 <coppro> what's the idiomatic way to iterate over all unordered pairs of elements from a list?
14:04:37 <bennofs> or rather, it was a "parsers" question
14:04:44 <glguy_> GADTs provide a syntax for using existential quantification
14:04:44 <trap_exit> [ | x <- lst] .... ?
14:04:47 <trap_exit> coppro : ^^
14:04:49 <glguy_> it's still existential quantification
14:04:57 <coppro> trap_exit: *pair*
14:04:59 <Shockk> ahh
14:05:32 <trap_exit> coppro: if you have a list of n elemements, do you have n/2, n, n-1, or n(n-1)/2 pairs ?
14:05:33 <glguy_> let pairs xs = [ (y,z) | y:ys <- tails xs, z <- ys ] in pairs [1..4]
14:05:37 <glguy_> > let pairs xs = [ (y,z) | y:ys <- tails xs, z <- ys ] in pairs [1..4]
14:05:39 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
14:06:21 <trap_exit> I never knew that "data Obj = forall a. (Show a) => Obj a" was a valid Haskell type.
14:06:21 <trap_exit> wtf
14:06:40 <glguy_> yay learning
14:06:52 <glguy_> It's valid given an extension that makes it valid
14:07:32 <trap_exit> Can Existential Types be anonymous, or do I also have to name it, like data AnyRenderable = forall a. Renderable a => AnyRenderable a ?
14:07:45 <glguy_> name
14:08:05 <monochrom> GHC makes you name them
14:08:07 <trap_exit> alright
14:08:09 <trap_exit> haskell extensions are sorta cool
14:08:14 <Kirsty22>  Here some videos. I hope you like them! http://bit.ly/1mFMmyS
14:08:16 <trap_exit> is there an online booklet I can print
14:08:20 <trap_exit> which lists all the common/cool extnesions?
14:08:26 <trap_exit> I feel like I might as well as learn them all
14:08:30 <monochrom> the GHC user's guide
14:08:43 <monochrom> it even has a PDF version
14:08:50 <Shockk> on the subject of extensions, I enjoy using LambdaCase
14:08:57 <trap_exit> http://www.haskell.org/ghc/docs/latest/users_guide.pdf
14:08:58 <trap_exit> trees are about to die
14:09:39 <monochrom> in the short term, trees are already dead, whether you print or not
14:10:08 <monochrom> there is already a pile of paper in the printer. whether you use it, the paper is not going back to the forest.
14:10:25 <Algebr> Does this ever happen? You use a library written by someone else and their implementation of bind or fmap is incorrect, ie violates laws.
14:10:42 <Denommus> dolio: I don't understand what you mean, be clearer
14:10:53 <trap_exit> Algebr: when it does, I track them down with a pitchfork
14:11:03 <simpson> Algebr: Which library?
14:11:06 * hackagebot haste-compiler 0.4 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4 (AntonEkblad)
14:11:13 <Denommus> dolio: wait, I understand what you're trying to say, but I disagree
14:11:29 <Algebr> none that I know of, was just wondering if that's a real issue
14:11:39 <Denommus> dolio: it's not just about the right order, but also about referential transparency
14:12:12 <monochrom> all you can claim is: by not using that paper, you cause a backward trickle in the economy, so that some lumberjack is laid off in the future, and therefore a tree will not be cut down in the future
14:12:31 <dolio> Denommus: World -> (a, World) makes no sense of infinitely running computations.
14:12:57 <monochrom> (and yes, I am naughtily wording it so that it sounds like you're destroying someone's job! bwhahahaha...)
14:13:22 <trap_exit> monochrom: I said "trees are about to die"
14:13:36 <trap_exit> monochrom: I did not claim the death of trees were related to my printting :-)
14:13:45 <trap_exit> monochrom: I think trees are about to die somewhere in the world regardless of whether I print the manual or not
14:14:07 <monochrom> damn you with your tautologies! I'm supposed to be the master of tautologies!
14:14:09 <trap_exit> monochrom: however, trees are about to die
14:14:14 <dolio> A computation that infinitely outputs "Look Around You" has the same denotation as one that just loops without printing anything.
14:14:24 <Denommus> dolio: and IO Char is not referentially transparent. Haskell only disguises impure functions under a special syntax
14:14:43 <SrPx> Okay this is unrelated to when I asked about opengl, now I just want something easy to now circles and practise some styles. Is there any lib similar to Ocaml's Graphics, JS's canvas etc?
14:15:29 <dolio> I don't think that's true.
14:15:50 <dolio> I doubt you can prove it, either, since IO is an abstract type.
14:15:55 <monochrom> Denommus: have you read my http://www.vex.net/~trebla/haskell/IO.xhtml ?
14:16:08 * hackagebot pwstore-fast 2.4.3 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.4.3 (PeterScott)
14:16:10 * hackagebot pwstore-purehaskell 2.1.3 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.1.3 (PeterScott)
14:17:07 <Denommus> monochrom: I have no problems understanding I/O in Haskell, I'm discussing a ownership type approach for I/O
14:17:08 <dolio> Certainly, I doubt you can prove it's better than World -> (a, World), since that is the exact implementation hack that GHC uses behind the scenes.
14:17:40 <dolio> Er, prove it's worse.
14:17:46 <monochrom> I disagree. "IO Char is not referentially transparent. Haskell only disguises impure functions under a special syntax" implies not understanding I/O in Haskell.
14:19:08 <monochrom> I suggest reading it because I have addressed the issue there.
14:19:56 <Denommus> monochrom: where?
14:20:08 <monochrom> in the section "The Types of I/O Actions"
14:20:59 <helpta> monochrom: are you saying that haskell IO is referentially transparent?
14:21:30 <monochrom> no
14:21:39 <Twey> helpta: But Tomas goes on to talk about coeffects as an extension to the core type theory, which seems completely unnecessary in that case
14:22:02 <Twey> helpta: And also links them to some of Dominic Orchard's work on comonads
14:22:18 <Twey> Or at least s/links them/links/
14:22:34 <Denommus> monochrom: I don't understand where it contradicts what I have said
14:22:44 <helpta> Twey: i have no idea what hes talking about tbh, I just remember reading that coeffects are like haskell monads in F#
14:22:52 <dolio> Twey: If all his examples are reader, you can do that with both monads and comonads.
14:23:05 <Denommus> monochrom: every time you execute getChar, it indeed performs the same action, but it results in different evaluations
14:23:11 <Twey> dolio: Ah, yes, they could also be comonads, to be sure
14:23:24 <deni> reflection, in the context of applicatives? is that a thing or am I misunderstaing something? can anyone provide a usefull link (either to a tutorial or code sample)?
14:23:24 <Twey> dolio: But that doesn't require type system extensions, either.
14:23:30 <Twey> (even to F#, I think?)
14:23:32 <dolio> It might for F#.
14:23:36 <Denommus> monochrom: except if you're specifically disagreeing with the "special syntax" part, which I admit that was a gross oversimplification
14:24:31 <dolio> Although if you only care about a particular (co)monad at any time, it wouldn't.
14:25:01 <monochrom> getChar is not an impure function. An impure function is required to have type "() -> Char" and "f ()" is a different char at a different time. getChar fails that requirement. getChar is "IO Char". it is the same IO Char every time.
14:25:21 <monochrom> unsafePerformIO would be an impure function.
14:25:34 <dubosec> Hi. I have a silly new person question, but I was playing around in haskell, and I noticed the min and max functions still work on strings. for instance, "max "cat" "dog" returns dog, max "ten" "eleven" returns ten, and max "kirk" "picard" returns picard. At first I thought maybe it was just returning the longer string or the string which alphabetically comes first, but that does not appear to be the case I think. So what does 
14:25:34 <dubosec> max look for when you use strings as the parameters?
14:25:44 <helpta> dolio: are monads an 'extension' of category theory into computer science? because im reading a book on category theory and it has no mention of monads anywhere
14:25:48 <Denommus> dolio: the problem I'm trying to address with ownership type-based I/O is very specific: I want to be able to have trustful Applicative Functors in the module level, and for that side-effects that aren't referentially transparent are inadmissible
14:25:59 <Twey> dubosec: Ord on strings is lexicographical
14:26:12 <hakujin> helpta: keep reading
14:26:18 <Denommus> monochrom: it is not the same IO Char every time
14:26:22 <S11001001> > 'a' > 'A'
14:26:24 <lambdabot>  True
14:26:29 <dolio> helpta: It's difficult to believe that you have a category theory book without any mention of monads.
14:26:31 <S11001001> > 'a' > 'B'
14:26:32 <lambdabot>  True
14:26:39 <S11001001> > 'b' > 'A'
14:26:40 <helpta> dolio: its an intro book but i do
14:26:41 <lambdabot>  True
14:26:44 <helpta> its not in the index at least
14:26:47 <dolio> helpta: They are used to do algebra.
14:27:05 <helpta> hmm, okay maybe i missed it
14:27:12 <glguy_> Denommus: You understand that there is no "Char" inside an "IO Char" , right?
14:27:18 <Twey> Denommus: No, it's the same IO Char every time.
14:27:20 <monochrom> how is it not the same IO Char every time?
14:27:24 <dolio> Denommus: Which side effects are referentially transparent?
14:27:57 <S11001001> @quote /bin/ls
14:27:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:28:19 <helpta> is there a simple application of category theory I can work with while learning it?
14:28:35 <dolio> helpta: Which book do you have, out of curiosity?
14:28:50 <Denommus> if it's the same IO Char every time, how is the parameter passed to >>='s function different every time?
14:28:59 <helpta> dolio: this book http://www.amazon.ca/Category-Theory-Steve-Awodey/dp/0199237182/ref=sr_1_1?ie=UTF8&qid=1409261267&sr=8-1&keywords=category+theory
14:29:15 <dolio> helpta: That one definitely talks about monads. Toward the end, I think.
14:29:23 <helpta> ah okay
14:29:37 <dolio> And it will be in the context of algebra.
14:30:01 <monochrom> there is no requirement of "same char passed to >>='s function every time". or rather, where did you deduce such a requirement?
14:30:04 <helpta> dolio: I also have this book: http://www.amazon.ca/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_1?ie=UTF8&qid=undefined&sr=8-1&keywords=category+theory+conceptual+mathematics
14:30:10 <helpta> not sure which one is more useful
14:30:23 <dolio> That one is more basic.
14:30:52 <dubosec> So lexicographical order is basically alphabetical order, where max returns strings which begin with letters later in the alphabet and min returns strings which begin with the earlier letters?
14:30:53 <dolio> I'm unsure if it talks about monads. It might be easier to read depending on your background, though.
14:30:57 <Twey> > let f x = x + 3 in (f 1, f 2, f 3) -- this is the same f every time, Denommus
14:30:59 <lambdabot>  (4,5,6)
14:31:21 <helpta> dolio: is there an application of category theory I can think of when reading these? Because it seems too abstract for me
14:31:44 <dolio> helpta: I don't know. That also depends on your background.
14:33:04 <helpta> I dont really have much background besides basic group/set/model theory
14:33:34 <helpta> im learning this as a hobby along with coq
14:33:58 <dolio> Well, most stuff in category theory is designed to specialize down to the definition in set theory.
14:33:58 <monochrom> not to say that IO has anything to do with [], but by your criterion, ['a', 'b', 'c'] is not the same [Char] every time, on the ground that in ['a','b',c'] >>= \x -> ..., x is a different Char at different time.
14:34:13 <monochrom> I don't understand how to reason that way.
14:34:49 <dolio> That will perhaps not explain why category theory is useful, but it can give you concrete things to thing about. The category of sets.
14:35:50 <helpta> dolio: what i try to do is somehow connect category theory with programming and I am unable too
14:36:23 <dolio> Well, it specializes to programming in a similar way to specializing to sets.
14:36:38 <helpta> I can think about sets but I dont see why, because you can do all of the same operations in set theory (at least the ones I learned so far)
14:36:45 <Iceland_jack> helpta: 1. Read papers on programming language theory, 2. See category theory used in those papers, 3. Use those examples to motivate learning
14:36:47 <dolio> For a sufficiently principled type of programming (which not even Haskell really is, but it's close).
14:37:06 <Iceland_jack> I don't recommend learning category theory without knowing the applications
14:37:46 <helpta> yeah Iceland_jack thats something I realised now
14:38:06 <helpta> I'm going to try to find some applications and try to work from the top down
14:38:12 <Denommus> sorry, my connection dropped
14:38:45 <Denommus> so, is IO a actually a function that receives some implicit parameter, similarly to the State Monad?
14:38:49 <Algebr> What is the purpose of the module that cabal makes, one one that starts Paths_
14:39:14 <dolio> IO is an abstract type.
14:39:27 <monochrom> helpta: the ideas of "functor" and "natural transformation" are useful. you may always specialize them to set theory. this specializing may or may not be important, however.
14:39:34 <dolio> You can imagine that it is like State, except that doesn't actually make sense.
14:39:35 <glguy_> Algebr: The purpose is to contain all the paths it contains so your program can use those and know what they are
14:39:36 <Cale> Denommus: It's almost possible to think of it like that, but it's hard to imagine what the type of that implicit parameter would be, or to come up with a representation of that sort which would work in the face of concurrency
14:39:40 <Denommus> dolio: I'm sorry, does this type describe a function?
14:40:20 <dolio> It is not just concurrency that makes it fail.
14:40:20 <Denommus> yes, concurrency is my main issue with describing I/O in terms of linear types right now
14:40:22 <dolio> It is non-termination.
14:40:41 <Denommus> dolio: in my specific case, I don't care all that much about non-termination
14:41:15 <Denommus> s/linear/ownership/
14:41:17 <monochrom> dolio means for example printing out "hello" to no end
14:41:23 <dolio> monochrom: Yes.
14:41:44 <dolio> It cannot model your favorite programs from when you were 10 years old.
14:41:50 <monochrom> or marginally more interestingly, echoing input to output to no end.
14:42:21 <monochrom> but I prefer my marginally more interesting case because then I have an excuse to call it a "reactive system".
14:42:35 <dolio> Or a web server.
14:43:17 <Algebr> glguy_: and what is the purpose of that .h?
14:43:33 <Algebr> some kind of runtime system interaction?
14:43:55 <Denommus> monochrom: I know what he means, and I'm saying that it is not all that important in my context
14:44:19 <Denommus> but okay, you convinced me
14:44:25 <glguy_> Algebr: Its if you need to know where to put the apps configuration files or data files or whatever, what version of the app is running, etc.
14:44:43 <Denommus> I'll think of something else to address how to have applicative functors in my toy language
14:45:09 <Algebr> glguy_: but why is it a c header and not haskell code?
14:46:39 <glguy_> Algebr: I don't usually see a paths.h, but perhaps you've got some C code that cabal is compiling. In that case it will likely need to know the same information. the cabal_macros.h helps when using CPP to enhance portability/compatibility
14:49:30 <meoblast001> hi. i just recently installed a new version of cabal, created a sandbox, and installed my library, and tried to open the repl
14:49:44 <Algebr> glguy: nice, thanks so much
14:49:45 <meoblast001> i did $cabal repl, and it says "Processing <my-library>..." then it returns to the command prompt
14:49:53 <meoblast001> is this what's supposed to happen?
14:54:32 <sm> meoblast001: no, maybe it ran out of memory
14:54:40 <meoblast001> sm: it didn't crash
14:54:42 <meoblast001> it just stopped
14:54:53 <sm> see if cabal build works
14:55:10 <meoblast001> building, preprocessing, in-place registering
14:55:12 <meoblast001> then it exists normally
14:56:00 <benzrf> > 3 ~ 4
14:56:02 <lambdabot>  Pattern syntax in expression context: ~4
14:56:05 <benzrf> ah
14:56:24 <sm> maybe try cabal repl -v{,2,3}
15:00:04 <SriPra> hi..
15:01:09 <simpson> Hi!
15:01:10 <SriPra> i would like to know the difference between F# type providers and the type generation capability built into frameworks that use template haskell
15:01:45 <SriPra> i think Yesod has some type generation capability using TH
15:13:14 <DanZimm> I just want to say I spent a while writing a fractal generator in c/++ and it's about 350 lines, in haskell I wrote it, thus far 38 lines and all that's left is making actual pngs
15:13:23 <DanZimm> i.e. haskell is awesome!
15:13:35 <monochrom> is the Haskell version fast enough?
15:15:12 <Twey> Denommus: pyon and I had a discussion about this in ##programming not so long ago ‚Äî did you see that conversation?
15:15:35 <steffen> Excuse if this is a silly question, but whn I compile C, I also can get the .o object file. When I compile a whoe haskell project with 'cabal build' what du I have to switch, to also get a .o file?
15:15:56 <pyon> Twey: Regarding what?
15:16:08 <sipa> steffen: cabal does much more than compiling; it's more like a package manager
15:16:18 <dukedave> Any ideas why I'm getting, "cabal: There is no package named 'shapefile'.", I just did an 'update', and: https://hackage.haskell.org/package/shapefile
15:16:21 <sipa> steffen: if you call ghc directly you can build the .o file from a .hs file
15:16:36 <Twey> pyon: Encoding concurrency structure with linear types.
15:16:48 <monochrom> steffen: there are *.o files as well, they are somewhere under the directory "dist". dig deeper.
15:16:48 <steffen> sipa: ah okay, cool then I have to look for the flag in ghc, not in cabal :) thanks
15:17:06 <steffen> monochrom: okay
15:17:12 <pyon> Twey: Oh, regarding the impossibility of using lambda calculi alone to model concurrent computation?
15:17:20 <Twey> pyon: Aye
15:17:24 <pyon> Ah!
15:18:06 <steffen> sipa: is it true, that when I have the .o file, I can ghci into it?
15:18:21 <Twey> Or rather, concurrent computation with hidden state √† la IO
15:18:39 <monochrom> no, *.o is not enough, you need *.hi, but they are there too
15:19:35 <monochrom> actually, the story is way more complicated than that.
15:19:36 <Twey> steffen: .hi similar to your .h files in C, except that the compiler makes them for you ‚Äî you need them in order to know the types of things
15:19:58 <Twey> (they do some other stuff too, though)
15:19:58 <glguy_> steffen: It will probably help if you say what it is you're trying to do
15:20:03 <monochrom> the first option is that you don't need anything. ghci can act as an interpreter
15:20:13 <goglosh> that all reminds me
15:21:16 <goglosh> do you guys have any article or book on how a haskell program looks when compiled?
15:21:35 <d-snp> if I have a function that's like myFunction :: SomeClass a => Bool -> a, can I have it sometimes return a String, and other times an Int, if both String and Int implement the typeclass?
15:21:53 <Twey> d-snp: Yes
15:21:55 <Twey> Er
15:22:14 <monochrom> goglosh: https://ghc.haskell.org/trac/ghc/wiki/Commentary has it for GHC
15:22:19 <Twey> d-snp: For a definition of ‚Äòsometimes‚Äô.  That type signature means it can return any instance of SomeClass, and the caller chooses which
15:22:53 <steffen> Twey: wow cool, so I what do I have to run? I tried 'ghci Main' 'ghci Main.o', 'ghci Main.hi', #ghci Main.hi Main.o' and all of them with the -fobject-code flag
15:22:53 <Twey> d-snp: So whether it returns an Int or a String, for example, depends on whether it's used in a context that expects an Int or a String.
15:23:07 <d-snp> ahh
15:23:10 <geekosaur> note "caller". *you*, the author of the function, do not have a say; nor can you find out what the claler chose
15:23:19 <monochrom> d-snp: it is important to know that caller chooses, and therefore the author cannot choose. the author has zero control.
15:23:46 <monochrom> the "cannot find out" part, though, is specific to parametricity
15:23:57 <steffen> Twey: I am in the directory where they are ofc, I found it under dist/build/...
15:24:19 <Twey> steffen: ghci Main.o  should work
15:24:20 <d-snp> alright, I think it means I should be bubbling up my Maybe
15:24:36 <d-snp> goglosh: perhaps this is nice? http://www.reddit.com/r/haskell/comments/iqz0l/reverse_engineering_of_compiled_haskell/
15:24:43 <Denommus> Twey: I have not
15:25:09 <Denommus> Twey: what would you suggest me to do to encode side effects, then?
15:25:48 <monochrom> "ghci Main.o" does not do what you think
15:26:27 <monochrom> perhaps I should continue spewing out the 2nd option afterall
15:27:24 <monochrom> the 2nd option requires *.hs, *.hi, *.o to be all present. if they are in different directories, you need to add command line options to say those directories.
15:29:06 <benzrf> :t modify
15:29:07 <lambdabot> MonadState s m => (s -> s) -> m ()
15:29:58 <monochrom> the 3rd option requires registering a library package
15:30:55 <monochrom> at the end of the day, geekosaur's question is the best answer.
15:31:20 <monochrom> oh oops, it's glguy_'s question!
15:31:49 * glguy_ scrolls up
15:32:41 <monochrom> I have a dream. I dream that one day, on stackoverflow and reddit etc, most of the time answers of the form "what are you trying to do?" get landslide upvote victory.
15:32:51 <Rembane> :D
15:33:08 <shachaf> It's more satisfying to feel like you read someone's mind and solved a puzzle with incomplete information, so people will keep doing it.
15:33:17 <shachaf> It's also more impressive, so people will keep upvoting it.
15:33:30 <hpc> i have a much more ambitious dream, where "answers in plain javascript only" doesn't get nothing but jquery suggestions
15:34:15 <gfixler> hpc: the problem is popularity - probably most people are good about it, but a tiny percent of everyone writing javascript is still a big number
15:34:16 <vanila> that reminds me
15:34:22 <vanila> i heard people say jquery is a monad
15:34:24 <vanila> is that true?
15:34:29 <shachaf> No.
15:35:13 <gfixler> ergo jquery is not a burrito
15:35:28 <MP2E> jburrito, best fork
15:35:34 <monochrom> well yes, clearly, people who receive no money payment for their labour in forums have to be paid in some other form, and bragging right is probably it.
15:35:58 <hpc> jquery is an enormous wrapper around getElementsBySelector
15:36:16 <hpc> with OO extensibility
15:55:54 <DanZimm> monochrom: sorry got caught up in some python (eek :P) but no idea on speed, havent tried comparing yet
15:55:58 <exio4> @pl \x n -> vef n (movDiff x n)
15:55:58 <lambdabot> ap vef . movDiff
15:56:09 <exio4> @hoogle ap
15:56:11 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:56:12 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
15:56:12 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
15:56:13 <DanZimm> probably going to be a bit slower, but for the ease of modularity that haskell is giving me I'd say this is worth it
15:56:19 <exio4> oh
15:56:52 <DanZimm> right now using haskell I think I can provide an arg to a program that represents the function to create the fractal around
15:57:16 <DanZimm> in the c/++ version I need to actually compile a new file to create a fractal with a new function
15:57:44 <vanila> what is meant by c/++?
15:59:52 <dibblego> how do I pass flags to cabal build?
16:00:07 <dcoutts> dibblego: depends what you mean
16:00:12 <shachaf> Which flags?
16:00:16 <dcoutts> cabal build --help
16:00:27 <c74d> vanila: C and C++, I‚Äôd think
16:00:40 <dcoutts> dibblego: the answer might be to pass a flag to cabal configure
16:00:43 <vanila> both?
16:01:02 <dibblego> those flags , for example, that appear in the .cabal file
16:01:07 <dibblego> dcoutts: oh ok
16:01:14 <dcoutts> dibblego: you specify them during configure
16:01:27 <dibblego> ok thanks
16:01:31 <dcoutts> because they can affect which deps are picked
16:03:08 <c74d> vanila: generally, I‚Äôd think it‚Äôd be ‚ÄúC or C++‚Äù, but in context I think ‚Äúand‚Äù makes more sense ‚Äî ‚Äúor‚Äù would imply that DanZimm doesn‚Äôt know which it is‚Ä¶
16:26:04 <Dre3ml0rd> I'm having a slight issue. Im just learning haskell so bare with me
16:26:14 <Dre3ml0rd> I try load the hs file and get this
16:26:16 <Dre3ml0rd> heightPercent.hs:8:34: parse error on input ‚Äò=‚Äô
16:26:30 <Dre3ml0rd> the issue come on this line
16:26:30 <Dre3ml0rd> then [percentile = age / (height / 100)]
16:26:44 <shachaf> You should post your whole code on hpaste.org
16:26:54 <shachaf> But that line doesn't make much sense even on its own.
16:27:00 <Dre3ml0rd> there really isn't much to my code
16:27:31 <Dre3ml0rd> Is there a special way to write If-then-else statements?
16:27:48 <shachaf> Maybe not, but it's a good habit to get into. If problems were always where you thought they were, you'd be able to solve them much more easily.
16:27:55 <shachaf> What are you trying to accomplish with that line?
16:29:06 <Dre3ml0rd> that line simple calculates a percentile value IF age is between 1 and 24
16:29:53 <shachaf> You can't assign to variables in Haskell. I don't know if that's what you're trying to do since you haven't posted your code.
16:30:49 <Dre3ml0rd> http://lpaste.net/110158
16:31:50 <shachaf> I think you're making up a bunch of syntax here. :-) Where are the [] coming from, for instance?
16:32:02 <shachaf> Anyway, the way you'd write that would probably be something like "where percentile = ..."
16:32:30 <shachaf> E.g. "where percentile = if ... then ... else ..."
16:33:04 <shachaf> There are a bunch of other things that don't make sense about that paste, though, like "age <= [1..24]"
16:33:15 <Dre3ml0rd> that was me trying out things cause it wasnt working
16:33:24 <Dre3ml0rd> Im kinda taking a whole run and gun approach to learning
16:34:05 <shachaf> I think Haskell is different enough from what you're used to that you'll be better served by reading an introduction first.
16:34:27 <Dre3ml0rd> so can I write: where percentile = age / height if age = [1..24]
16:34:40 <shachaf> Making up syntax and hoping that it'll do what you want only works when the language is so close to your mental model that there isn't anything interesting to learn anyway. :-)
16:35:01 <shachaf> No. "if ... then ... else ..." is a specific sort of expression and it can only be used in a specific way.
16:35:08 <Dre3ml0rd> yeh makes sense
16:35:30 <exio4> "age = [1..24]", what is that supposed to do?
16:35:48 <Dre3ml0rd> so that is if age is between 1 and 24, then it does something
16:36:04 <exio4> and if not? undefined? null pointer?
16:36:14 <Dre3ml0rd> and if not, it does something else
16:36:27 <Dre3ml0rd> if not, it simply takes the age as being 24
16:38:18 <eriksensei> it might be helpful to take note of the difference between a statement (which might 'do' something) and an expression
16:38:39 <merijn> haskell doesn't have statements
16:38:51 <eriksensei> my point exactly
16:39:22 <Dre3ml0rd> eriksensei: could you briefly explain that?
16:39:45 <Dre3ml0rd> sorry Im just starting out and have limited knowledge
16:39:53 <hpc> Dre3ml0rd: so, in a language like C you have expressions (things like "x + 3")
16:40:02 <hpc> Dre3ml0rd: and you have statements, things like "x = x + 3"
16:40:26 <eriksensei> ...or: print "hello"
16:40:27 <Dre3ml0rd> got it
16:40:48 <hpc> essentially, the difference between a value and "thing to do"
16:41:31 <Dre3ml0rd> so an expression gives a value while a statement is simply a "calculation" for instance
16:41:50 <monochrom> in Haskell, "v = expr" means definition. not change state. there is nothing to change.
16:42:05 <merijn> hpc: Although, technically speaking x = x + 3 is an expression in C ;)
16:42:09 <eriksensei> shachaf just said: ""if ... then ... else ..." is a specific sort of expression and it can only be used in a specific way." note the use of 'expression' there
16:42:26 <Dre3ml0rd> ok I kinda understand
16:42:29 <hpc> merijn: because C is horrid ;)
16:42:54 <merijn> hpc: I just spend the entire day debugging C++, you don't have to tell me...
16:43:01 <Dre3ml0rd> lol
16:43:01 <monochrom> and yeah, that's an expression. in C it would be the ? : operator
16:43:05 <eriksensei> a statement can be anything; an imperative instruction to print "hello" to the screen right at that very moment, for example
16:43:12 <Dre3ml0rd> ok
16:43:16 <hpc> if you really want to stretch the definition of statement, do-notation can somewhat count because "x <- m" isn't an expression on its own
16:43:38 <Dre3ml0rd> ok
16:44:39 <hpc> or "x = 5" in haskell which only occurs in specific "definitions here only" places
16:44:43 <hpc> like top-level, or let bindings
16:45:22 <Dre3ml0rd> I understand thanks a lot
16:45:26 <eriksensei> i regret having mentioned the word statement already ;)
16:45:36 <Dre3ml0rd> but what could be a solution to it
16:45:48 <hpc> eriksensei: you should think twice before you make such bold statements in the future ;)
16:45:52 <hpc> eriksensei: there's no value in it
16:45:53 <Dre3ml0rd> All I want to do is that if the age is between 1 and 24, then it calculates using the given age
16:45:57 * hpc ducks
16:46:00 <Dre3ml0rd> Else it calculates using 24
16:46:22 <eriksensei> hpc: i had a beer jusrt now; all my hopes of self-control are out the window
16:46:34 <hpc> (that was a bad pun)
16:46:37 <monochrom> if x>=1 && x<=24 then x else 24
16:47:24 <eriksensei> hpc: ah, you just saved it from whooshing right over my head, thanks ;)
16:47:48 <Dre3ml0rd> monochrom thanks I will try
16:48:20 <Enigmagic> > let x = 25 in min x 24
16:48:22 <lambdabot>  24
16:48:34 <exio4> couldn't you use a guard there?
16:48:39 <monochrom> yes
16:49:03 <monochrom> oh there are a million other ways. should I write them all out?
16:49:04 <goglosh> Enigmagic: that just calculates 24
16:49:22 <shachaf> A guard is a shortcut. It's worthwhile understanding the concepts that are being discussed, regardless of how you write it in the end.
16:49:28 <exio4> i didn't know if you could and i don't have ghc right now monochrom :P
16:49:33 <Dre3ml0rd> currently it says there is a parse error in the line for THEN
16:49:35 <Dre3ml0rd> then percentile = age / (height / 100)
16:49:41 <Dre3ml0rd> comes back with parse error for the =
16:50:02 <monochrom> no = inside the then branch or the else branch
16:50:04 <Enigmagic> goglosh: yes, it's an alternative if he didn't want age 0 to be set to 24 ;-)
16:50:51 <Dre3ml0rd> monochrom what should it be then
16:51:03 <exio4> variable = if ... then ... else ...
16:51:24 <Dre3ml0rd> ok go its going to have to be the other way around
16:51:25 <goglosh> b.. but but wouldn't that statement just be the same as saying plain '24' ?
16:51:57 <monochrom> where percentile = (if age>=1 && age<=24 then age else 24) / (height / 100)
16:52:12 <monochrom> I would write that in C, too, except with the notation ?:
16:52:32 <monochrom> (age>=1 && age<=24 ? age : 24) / (height / 100)
16:52:40 <Dre3ml0rd> ok wow thats great
16:53:47 <goglosh> so what do you guys use haskell for?
16:53:52 <eriksensei> programming, mostly
16:54:00 <goglosh> lel
16:54:00 <zwer> you can take it even futher, and have if-then-else return a function.
16:54:07 <zwer> > let multiply = True in (if multiply then (*) else (+)) 10 20
16:54:08 <lambdabot>  200
16:54:15 <eriksensei> and for lonely saturday nights, you know...
16:54:36 <monochrom> it is unfortunate that math teachers does not honour if-then-else as an algebraic operator, and programming teachers does not give you algebraic laws of it.
16:54:39 <goglosh> oh eah? you have your waifu coded in has?
16:54:40 <shachaf> That seems to me to be taking it exactly as far.
16:55:00 <eriksensei> goglosh: something like that ;)
16:55:08 <TomJohnson> Parsing to and using algebraic datatypes to represent special data
16:55:09 <monochrom> (if b then e else f)*k = if b then e*k else f*k is a useful algebraic law, for example
16:55:46 <vanila> goglosh, please less 4chan
16:56:08 <zwer> further than C will take you, unless I forgetting C.
16:56:11 <zwer> +am
16:56:46 <goglosh> sure I'll try that
16:57:44 <shachaf> (multiply ? times : plus)(10,20) seems like perfectly reasonable C to me.
16:57:50 <monochrom> even when you have the imperative if-then-else statement in mind, "((if b then R else S); P) = if b then (R;P) else (S;P)" is an important algebraic law
16:57:58 <Dre3ml0rd> monochrom this is what ive got atm http://lpaste.net/110158
16:58:37 <Dre3ml0rd> It tells me I need to add a Fractional a into the context of the first line
16:58:49 <monochrom> do you want to convert to Double in order to divide?
16:59:14 <Dre3ml0rd> how so?
16:59:23 <Dre3ml0rd> a doublefloat?
16:59:28 <Dre3ml0rd> what would that achieve?
16:59:44 <monochrom> percentile = fromIntegral (if age >= 1 && age <= 24 then age else 24) / (fromIntegral height / 100)
17:01:14 <benzrf> monochrom: what about
17:01:15 <Dre3ml0rd> Sorry to sound like a retard but what does fromIntegral do?
17:01:21 <benzrf> Dre3ml0rd: please dont use slurs
17:01:28 <monochrom> it converts between number types
17:01:32 <benzrf> min 24 (abs age)
17:01:36 <benzrf> oh wait
17:01:36 <Dre3ml0rd> benzrf sorry
17:01:41 <benzrf> nah that doesnt work
17:02:15 <Dre3ml0rd> OK it works now
17:02:18 <Dre3ml0rd> Thanks everybody so much
17:02:27 <Dre3ml0rd> Absolutely amazing community
17:03:17 <monochrom> they are promoting the old movie Ghostbusters soon because of the 30th anniversary. therefore, you may recognize this sooner or later:
17:03:26 <monochrom> @quote monochrom fromIntegral
17:03:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:03:46 <hpc> when there's something strange / in the neighborhood
17:03:51 <hpc> guess who it is? / ghostbusters!
17:04:48 <andkore> Is it possible to compile a binary that will run on Linux from Windows? I'm trying to get a web application going on OpenShift. I tried doing compilation on the server, but it was taking too long and timing out, even though I only had one extra dependency (scotty).
17:05:16 <geekosaur> it's rather easier to go the other way using wine on linux
17:05:37 <hpc> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling -- this is probably relevant
17:06:03 <andkore> I looked at that page but couldn't really figure out what was going on.
17:08:48 <lennOracle> hey :) I'm new to haskell, I'm trying to convert a boolean logic expression given as a string into a form that I can actually plug values into it. For example I'm given "(nand (nand (a b)) a)" which I'd like to convert into some function such as func a b = nand (nand a b) a. I can't quite think how to go about this, can anyone hint me in the right direction? Thanks for your time!
17:09:31 <monochrom> it may be easiest to create a virtual machine, run linux inside, and compile code inside
17:09:41 <andkore> monochrom: That's what I was thinking
17:10:01 <shachaf> monochrom: Oh, that answer makes a lot more sense after you realize it wasn't to lennOracle's question.
17:10:14 <monochrom> hehehe
17:10:46 <shachaf> lennOracle: I think the first step is to describe what you're trying to do in more detail.
17:10:53 <monochrom> it may be easiest to create a virtual machine, run linux inside, run verilog... :)
17:11:00 <geekosaur> :p
17:11:04 <shachaf> For example, can you write out a type for the thing you're doing?
17:11:12 <shachaf> Presumably it's thing :: String -> ...
17:12:21 <monochrom> I am uncomfortable with conflating expressions with functions
17:12:42 <shachaf> Yep.
17:12:47 <koala_man> sounds like it would be covered almost exactly by the first few chapters of "write yourself a scheme in 48 hours"
17:13:00 <monochrom> so if you see 1 variable in the expression, the function is 1-ary? if you see 13 variables, then the function is 13-ary?
17:13:03 <shachaf> Maybe there's an implied "\a b ->" on the outside. Writing out the type is a good way to clear that sort of thing up.
17:13:26 <monochrom> moreover how do I know which variable is considered the 1st parameter? which one is the 5th parameter?
17:13:46 <shachaf> > compare a b
17:13:48 <lambdabot>  LT
17:13:55 <shachaf> > compare (-a) (-b)
17:13:56 <lambdabot>  LT
17:14:02 <hpc> it's easy, all of them are the first parameter
17:14:19 * monochrom makes a conflated face
17:14:21 <shachaf> > (compare a (-1), compare z (-1))
17:14:22 <lambdabot>  (LT,GT)
17:14:33 <MP2E> haha
17:21:45 <lennOracle> shachaf: I have a function (say transformExpression) that takes in a String such as "(nand (nand (a b)) a)" and I'd like to output a function (say evaluateExpression) (I'm not sure what type that'd turn out to be yet :P) that takes in a truth table like so, evaluateExpression((a,#f), (b,#t)) which would output a boolean value, in this case gives True
17:22:14 <fread2282> does anyone have a source for haskell's thread overhead vs erlang?
17:22:16 <yeboot> Hi, I'm literally brand spanking new to haskell (just downloaded and installed haskell-platform).  I compiled a hello world program for haskell (main = putStrLn "Hello world") and can't help but notice the binary is 8.9 mb
17:22:41 <yeboot> extrapolating uneccesarily this tells me haskell generates huge binaries for simple things, is this true?
17:22:56 <guesting> How can I find out where a segmentation fault is happening?
17:23:13 <shachaf> yeboot: Extrapolating from one point is pretty risky.
17:23:24 <monochrom> the runtime system is huge. this is a constant overhead. does not grow like that for larger programs
17:23:30 <yeboot> always is, haha
17:23:31 <shachaf> yeboot: GHC statically links almost everything by default, so you get the RTS and what not linked into your binary.
17:23:36 <Iceland_jack> yeboot: Another extrapolation is that all Haskell binaries are 8.9 mb, which is pretty sweet
17:23:49 <yeboot> Iceland_jack I should've gone with that one, hahah
17:23:51 <shachaf> lennOracle: OK. I'd follow monochrom's advice about being careful to distinguish between "function" and "expression".
17:23:54 <monochrom> also, the library is huge, too, and statically linked by default
17:24:18 <yeboot> any way to have it dynamically linked, instead?
17:24:37 <monochrom> ghc -shared -dynamic xxx.hs
17:25:12 <monochrom> unfortunately, you need both -shared and -dynamic, because they stand for two different sides, and you need both sides
17:25:49 <monochrom> they get away with this clumsy interface because there is cabal-install who does it for you
17:26:53 <monochrom> except if you are on windows, you can't enjoy dynamic linking
17:27:36 <monochrom> the story on windows is actually complicated.
17:28:07 <Hodapp> if you're on Windows, can you enjoy anything?
17:28:21 <ReinH> monochrom: o/
17:28:26 <ReinH> Hodapp: Yes. You can enjoy games.
17:28:38 <monochrom> one aspect of making and using DLL works. another aspect doesn't. the aspect that doesn't affects only ghci and template haskell. meaning, probably doesn't affect you all that much.
17:28:40 <yeboot> well trying to dynamically link it gave me a few errors about missing libraries, but I'm sure I can sort that out and install everything the system needs (I'm on linux).  I just figured if I were to be messing around and making a lot of programs to test my knowledge working through something like LYAH a ton of 9mb binaries would be annoying after a while
17:28:48 <beckyconning> what does 'res' mean conventionally?
17:28:57 <shachaf> Probably "result".
17:29:02 <beckyconning> ah thanks
17:29:56 <monochrom> however, because of that aspect, the GHC people decided: let's make it simpler, let's ship a no-DLL binary of GHC for now. (there is a good reason for this simplification.) similarly, the Haskell Platform people too.
17:30:32 <beckyconning> pretty much the only think i don't like about the haskell community is abbreviated symbols / names : P i probably am too stupid to get why having short names is more important though.
17:31:09 <monochrom> so, if you downloaded an installer, you get no DLL. if you build GHC yourself from source, you may change the default and get DLL, except there may be problems with ghci and template haskell
17:31:11 <shachaf> beckyconning: I can't think of any time I've seen "res" in Haskell. But I see it in C code all the time.
17:31:15 <eriksensei> beckyconning: types are generally considered to be more important than names
17:31:41 <monochrom> https://ghc.haskell.org/trac/ghc/wiki/DynamicGhcPrograms has the full story
17:31:55 <shachaf> I think Haskell people use short (one-letter) names for roughly the same reasons that mathematicians do.
17:32:07 <beckyconning> i admit that there is a lot of c and javascript with abbreviated names too : ) i've just never really worked inside projects with them before
17:32:14 <ReinH> edwardk has a nice explanation for this, let me see if I can find it
17:32:16 <yeboot> because programs are written on chalkboards? shachaf
17:32:43 <shachaf> I've read more maths in PDFs and books than on chalk boards.
17:32:56 <monochrom> I use short names when longer names aren't really all that more meaningful
17:33:14 <shachaf> Yes.
17:33:24 <beckyconning> shachaf: i think thats why i don't get it lol! i am learning maths backwards through haskell : P. objective-c -> ruby (with lots of lamdas and procs) -> javascript (with lots of monad-type and partially applied things) -> haskell -> maths : P
17:33:29 <ReinH> Sometimes parametricity means that there really aren't any more meaningful long names
17:33:30 <monochrom> also, "foo" and "bar" are no better than "x" and "y".
17:33:38 <ReinH> I wouldn't want to replace (a -> b) with (thing -> otherThing) for instance
17:33:47 <beckyconning> the most confusing thing i've ever seen is http://conal.net/talks/bayhac-2014.pdf
17:33:59 <shachaf> map :: (source -> target) -> [source] -> [target] -- much harder to read, or keep in your head, than (a -> b) -> [a] -> [b]
17:34:05 <monochrom> "bar" and "baz" are in fact worse than "y" and "z"
17:34:06 <ReinH> shachaf: exactly
17:34:51 <beckyconning> shachaf: i totally aggree, but i've never used foo / bar / baz ever : P
17:35:04 <shachaf> I dind't say anything about foo/bar/baz.
17:35:08 <beckyconning> shachaf: not that x, y, z aren't important where the thing is very generic
17:35:20 <beckyconning> monochrom: : not that x, y, z aren't important where the thing is very generic
17:35:26 <ReinH> edwardk's thing is proving impossible to google for. Maybe he knows where it is. :/
17:35:26 <shachaf> beckyconning: Imagine that that PDF was written with long names instead of short names and symbols.
17:35:27 <monochrom> I find that every programmer who brags about meaningful long names use "foo", "bar", "baz" all the time.
17:35:37 <monochrom> @quote monochrom hypoc
17:35:37 <lambdabot> monochrom says: mark my words. programmers are hypocrites.
17:35:53 <beckyconning> monochrom: not me : P
17:35:54 <ReinH> heh
17:36:04 <eriksensei> schachaf: what you just wrote about source and target helped me realise that that's what all the s and t's are for in lens, whee!
17:36:11 <shachaf> beckyconning: You're saving a bunch of time with all those short names. Allow yourself that extra time to understand the paper.
17:36:23 <ReinH> beckyconning: part of the issue with those slides is that they aren't accompanied by him explaining things as he goes
17:36:32 <shachaf> eriksensei: Hah. s/t in lens is my fault, but that's not the original motivation for those names.
17:36:42 <eriksensei> it isn't?
17:36:51 <edwardk> eriksensei: s is for state, t is the letter after s ;)
17:37:05 <shachaf> No, but it's a good motivation-after-the-fact.
17:37:07 <monochrom> in fact it's worse. not only do they use "foo" etc all the time, they use "foo" for two different things within the same minute.
17:37:13 <edwardk> the rest was post-hoc
17:37:20 <ReinH> beckyconning: He gave a similar talk at LambdaJam and used more conventional notation http://conal.net/talks/lambdajam-2014.pdf
17:37:28 <edwardk> a and b were chosen to match up with traverse
17:37:38 <edwardk> originally s t a b   was a b c d
17:37:45 <ReinH> beckyconning: also here's the video from bayhac https://www.youtube.com/watch?v=zzCrZEil9iI
17:37:55 <edwardk> but that required folks to do capture avoiding substitution in their head to unify with the types for traverse
17:37:57 <beckyconning> i totally get that its because i'm stupid but ¬µ √Æd ‚â£ id was so hard for me to get. someone else had to explain that it was the same as \x -> x : P
17:38:03 <beckyconning> so i'm learning it backwards basically
17:38:04 <eriksensei> shachaf, edwardk: i feel so silly and so elucidated at the smae time, thanks! :)
17:38:04 <lpvb> what's the point of *> and <* ?
17:38:08 <shachaf> That talk isn't the same thing. The part where it is about the same thing it uses the same symbols.
17:38:30 <lpvb> when would I need to use those?
17:38:30 <shachaf> beckyconning: Please don't call people stupid in this channel. :-)
17:38:36 <ReinH> beckyconning: you aren't stupid, you just don't know a thing yet
17:38:43 <edwardk> so shachaf put forth a half dozen ideas for alternatives and i let him talk me into letting him put in a 6k line patch into lens to swap the letters around
17:39:12 <edwardk> lpvb: before *> something <* after
17:39:27 <ReinH> beckyconning: watch the video, it helps :)
17:39:29 <beckyconning> ok well: i'm extremely inexperienced with even basic maths but very good at 'functional style' javascript lol! : P
17:39:31 <zwer> I thought s and t were used because they are the first two letters of the word stab
17:39:35 <lpvb> yeah but when would I need to throw away the values except in IO?
17:39:35 <beckyconning> ReinH: i will : )
17:39:46 <lpvb> or is it meant for IO
17:40:02 <edwardk> lpvb: char '(' *> term <* char ')'
17:40:05 <shachaf> That was a coincidence, or so I tell edwardk.
17:40:16 <monochrom> in every Applicative you have reasons to throw away data
17:40:16 <edwardk> it is often useful to have a character parser return the character parsed
17:40:20 <shachaf> I think he only started worrying when it started spelling "i m a s t a b u"
17:40:24 <edwardk> but you don't always need it
17:40:58 <ReinH> shachaf: lol
17:40:59 <lpvb> edwardk: thanks
17:41:02 <monochrom> in fact computation is strictly-entropy-increasing because it throws away old data all the time
17:41:10 <eriksensei> edwardk i can see how shachaf makes some very persuasive arguments ;)
17:43:38 <monochrom> in Do-Re-Mi, the stanza "la, a note to follow so" was because the author could not think up something more witty.
17:43:50 <trap_exit> can someone ELI5 http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ (ignoring the "where are your parents / what are you doing on IRC part") ?
17:44:01 <trap_exit> is this guy basically saying: you dont' need existential types; you can do it with just pure data types ?
17:44:26 <shachaf> t, a type to follow s
17:44:41 <shachaf> Even ghc picks "t" when it has no clues on what to name a type variable.
17:46:20 <eriksensei> i like t
17:48:09 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
17:52:16 <eriksensei> monochrom: surely 'la' should have been something to do with lambda?
18:04:18 <lebek> I'm using the aeson library to parse a json file, and this code http://lpaste.net/110161 is telling me there's no instance for FromJSON (Parser (Map String Position))
18:04:40 <platz> trap_exit: I think he was saying the libs weren't using the extra features typeclasses provide over records.  I'm not sure though that he successfully eliminated the space where typeclasses can be beneficial with his example at the bottom though
18:04:46 <shachaf> lebek: Do you expect to be able to represent a parser as JSON?
18:04:52 <platz> also i asked this before with some answers here http://ircbrowse.net/browse/haskell?events_page=173021&events_per_page=100
18:06:05 <platz> so "toWidget :: Window -> Widget" in his example is one thing; apparrently erisco thinks a Widget -> Window function is harder
18:06:27 <platz> I haven't entirely thought it though yet
18:06:28 <lebek> shachaf: not sure I understand what you mean
18:07:05 <shachaf> lebek: If you have an instance FromJSON T, that sounds like you should be able to turn some JSON into a value of type T.
18:07:19 <shachaf> That error is about instance FromJSON (Parser ...)
18:07:33 <shachaf> Do you expect to be able to turn some JSON into a parser?
18:08:43 <lebek> shachaf: oh I see what you're saying - no, I'm confused by the error, I was expecting type inference to see that particular type as FromJSON (Map String Position)
18:09:09 <shachaf> lebek: OK.
18:09:13 <ReinH> shachaf: that's an interesting idea though
18:09:17 <shachaf> If you post the full error then I won't have to read all that code.
18:09:41 <shachaf> (The full error includes a line number.)
18:10:10 <shachaf> lebek: By the way, are you sure you intend parseJSON j = do { o <- parseJSON j; ... }?
18:10:18 <fread2282> lebek: without the full error, I'm betting it's line 42 which should probably be o <- return $ parseJSON j
18:10:20 <shachaf> That doesn't look like very fruitful recursion.
18:10:22 <lebek> shachaf: http://lpaste.net/110162
18:10:46 <shachaf> fread2282: That almost certainly doesn't do what lebek wants.
18:11:18 <lebek> fread2282, shachaf: it worked, so what's the difference?
18:11:25 <shachaf> Maybe it does.
18:11:40 <shachaf> "x <- return y" is a lot like a complicated way of writing "let x = y"
18:12:36 <fread2282> lebek: lookineg at the aeson docs that should cause an infinite loop. what did you intend in that line?
18:13:28 <fread2282> lebek: actually nevermind
18:13:46 * fread2282 brain fart
18:14:40 <trap_exit> so I'm playing with existential types ... and I'm not seeing how it makes my code more concise
18:14:55 <trap_exit> basically, not, instead of doing things like "to__TexExpr foo" I'm doing "Any_TexExpr foo"
18:15:06 <trap_exit> and instead of "to__SvgDoc bar", I'm doing "Any_SvgDoc bar"
18:15:18 <trap_exit> so it seems like I have over-complicated my type system and gained no conciseness in my code
18:15:33 <trap_exit> this leads me to wonder -- when are existential types actually truly useful? because I certainly have not found them
18:15:34 <fread2282> trap_exit: also lens doesn't work nicely with them
18:15:44 <trap_exit> well
18:15:44 <trap_exit> I don't like lens
18:15:44 <fread2282> so for that reason IMO no
18:15:52 <monochrom> Control.Exception is a good use of existential types
18:15:53 <trap_exit> since it slows down my compile time
18:16:01 <lebek> fread2282, shachaf: is 'return' just injecting the value back into the Parser monad?
18:16:05 <trap_exit> hmm
18:16:07 <fread2282> lebek: yep
18:16:17 <fread2282> trap_exit: the TH?
18:16:21 <shachaf> I don't quite like that phrasing, but the answer is yes.
18:16:36 <trap_exit> monochrom: Control.Exception seems less magical now that you mention it
18:17:04 <lebek> fread2282: but parseJSON already returns a Parser.. so why does the result need wrapping?
18:18:51 <dmwit> Can't see the code. But "parseJSON j = do { o <- parseJSON j; ... }" can be fruitful if the type of parseJSON differs on the two sides of the equation.
18:19:49 <shachaf> Yes.
18:20:29 <monochrom> what is the type of o?
18:20:29 <dmwit> lebek: I wonder why you expect M.mapKeys to return a Parser.
18:20:32 <fread2282> trap_exit: lens is a rather big dependency but IMO worth it and easy to make a tiny version in your own code
18:20:45 <lebek> dmwit: it
18:21:07 <lebek> dmwit: it's my understanding that <$> will apply M.mapKeys inside the Parser
18:21:24 <dmwit> lebek: Why do you expect o to be a Parser?
18:21:43 <lebek> dmwit: because that's what parseJSON returns
18:21:48 <merijn> argh
18:21:56 <merijn> Why is thinking about MVar's so hard :(
18:21:57 <dmwit> lebek: Irrelevant. =)
18:22:22 <dmwit> lebek: You have used do-notation's bind.
18:22:24 <fread2282> o should be Parser (Map String Position) or so AFAICT
18:22:32 <merijn> Somehow pointers feel easier, even though there's no logical reason for my brain not to think of them the exact same way...
18:22:33 <dmwit> lebek: So types are not what you might expect.
18:22:54 <dmwit> lebek: If you are using parseJSON j at type Parser X, you should expect o to have type X.
18:23:23 <dmwit> lebek: (shachaf actually said this some time ago, I think. But it's subtle.)
18:23:39 <dmwit> :t (>>=)
18:23:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:23:46 <lebek> dmwit: ok, sounds like I should read about do vs let.. thanks :)
18:24:09 <fread2282> lebek: do notation puts an implicit >>= everywhere, so the a in a <- (m :: M ty) pretends to have type ty when it actually has type M ty
18:24:14 <shachaf> You should probably understand what do does before you use it.
18:24:20 <dmwit> (>>=) :: Parser (Map X Y) -> (Map X Y -> Parser b) -> Parser B
18:24:36 <dmwit> ?undo do { o <- parseJSON j; foo o }
18:24:36 <lambdabot> parseJSON j >>= \ o -> foo o
18:24:47 <lebek> ah...
18:24:58 <lebek> this is starting to make sense
18:25:52 <fread2282> lebek: so you can either remove the <$> or add a return
18:25:56 <fread2282> s/so//
18:26:20 <monochrom> oh, let args = M.mapKeys ...
18:26:31 <fread2282> ?undo do   {  o <- parseJSON j    ; args <- M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) <$> o ;    return $ Element args }
18:26:31 <lambdabot> parseJSON j >>= \ o -> M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) <$> o >>= \ args -> return $ Element args
18:26:40 <fread2282> ?undo do   {  o <- parseJSON j    ; args <- M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) o ;    return $ Element args }
18:26:40 <lambdabot> parseJSON j >>= \ o -> M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) o >>= \ args -> return $ Element args
18:27:01 <fread2282> ?undo do   {  o <- return $ parseJSON j    ; args <- M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) <$> o ;    return $ Element args }
18:27:01 <lambdabot> return $ parseJSON j >>= \ o -> M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) <$> o >>= \ args -> return $ Element args
18:27:09 <monochrom> so it seems I am also right to teach >>= before teaching do
18:27:14 <dmwit> fread2282 is not giving carefully tested advice.
18:27:19 <fread2282> do is confusing
18:28:43 <dmwit> Element . M.mapKeys (...) <$> parseJSON j
18:28:51 <dmwit> would be my preferred spelling
18:29:02 <fread2282> my advice is just to avoid do
18:29:29 <lebek> dmwit: that looks cleaner
18:29:44 <lebek> I'm guessing fromRight is bad practice
18:29:45 <monochrom> the ... part is very long, but ok :)
18:29:51 <fread2282> use big where blocks instead until you get good at writing pointfree code like dmwit
18:29:54 <tertl3> hello
18:30:01 <dmwit> fromRight is not good practice, no.
18:30:08 <trap_exit> is there a wya to have "a ::: TexExpr" to expand into "to__TexExpr a" ? i.e. to say "cast with to__TexExpr" ?
18:30:14 <dmwit> Unless you have written down a careful proof that it really is right.
18:30:23 <monochrom> pun!
18:30:26 <dmwit> pun! =D
18:32:14 <fread2282> lebek: you can use where blocks almost like you use do and IMO it's behaviour is more sensible
18:32:27 <SrPx> Hello, I've cloned the https://github.com/ocharles/engine.io repo, initialised a cabal sandbox on the examples folder and ran cabal install. Then I tried compiling MainSnap.hs and got this: MainSnap.hs:15:8:     Could not find module ‚ÄòPaths_chat‚Äô
18:32:36 * dmwit squints at fread2282
18:33:05 <SrPx> I guess I will never ever be able to compile an example from Hackage :(
18:33:10 <lebek> is there anything wrong with do apart from the fact that people like me use it without knowing how it works?
18:33:19 <shachaf> No, do is great.
18:33:22 <fread2282> parseJSON j = Element <$> args where {o = parseJSON j; args = M.mapKeys (fromRight . AP.parseOnly parseRatio . B.pack) <$> o}
18:33:52 <shachaf> I don't think "don't use do" is good advice for writing clear Haskell programs.
18:34:01 <dmwit> fread2282: You still aren't giving careful advice. That (<$>) is incorrect.
18:34:02 <shachaf> I do think you should know what do notation translates to.
18:34:21 <dmwit> And using "where" instead of "do" works in this case because he is not really using "do". "where" is not a general-purpose replacement for "do".
18:34:32 <shachaf> ==dmwit
18:35:30 <fread2282> dmwit: yes it is
18:35:42 <fread2282> dmwit: your pointfree code isn't though
18:35:47 <shachaf> where is not even comparable to do
18:39:11 <tertl3> haskell is like a pillow
18:39:25 <fread2282> do is useul, but it's presented as *way* more useful than it actually is
18:39:49 <tertl3> main = do
18:39:58 <tertl3> main =
18:40:17 <tertl3> do putStrLn "hello"
18:40:19 <tertl3> >
18:40:36 <tertl3> amI doing it right?
18:41:16 <zwer> you don't need a do there
18:41:21 <tertl3> \join #haskell-ghc-only
18:41:42 <lebek> thanks all, the response I get in here always makes me wish I could work with haskellers all day
18:42:02 <tertl3> \join #verysecretchannell
18:42:28 <tertl3> \join #CandyLand(no spaces)
18:43:03 <tertl3> > main = putStrLn "this is your commander reporting"
18:43:04 <lambdabot>  <hint>:1:6: parse error on input ‚Äò=‚Äô
18:43:20 <tertl3> > putStrLn "this is your commander reporting"
18:43:21 <shachaf> tertl3: What are you doing?
18:43:21 <lambdabot>  <IO ()>
18:44:34 <tertl3> > let
18:44:35 <lambdabot>  not an expression: ‚Äòlet‚Äô
18:44:38 <fread2282> dmwit: oh, your code is correct, whops, sorry
18:45:02 <tertl3> > 5 + 5
18:45:03 <lambdabot>  10
18:45:20 <tertl3> > 10
18:45:21 <lambdabot>  10
18:46:00 <tertl3> > fst[2,3,4,5]
18:46:02 <lambdabot>  Couldn't match expected type ‚Äò(a, b0)‚Äô with actual type ‚Äò[t0]‚Äô
18:46:27 <tertl3> > ghc
18:46:28 <lambdabot>  Not in scope: ‚Äòghc‚Äô
18:47:03 <fread2282> > head[2,3,4,5]
18:47:04 <lambdabot>  2
18:47:18 <Iceland_jack> fread2282: You can PM lambdabot by the way
18:47:23 <fread2282> tertl3: you might want to use /msg or #haskell-beginners
18:47:36 <eriksensei> or ghci...
18:47:59 <shachaf> tertl3: Please use /msg to communicate with lambdabot. You're making a lot of noise in the channel.
18:51:41 <gennady> Could someone help me understand why I am getting the error in the comment below the code? http://lpaste.net/8442623407090040832 I am use eclipse with the eclipsefp plugin.
18:51:45 <yeboot> >\s -> s s
18:51:55 <yeboot> > \s -> s s
18:51:56 <lambdabot>  Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
18:51:56 <lambdabot>  Relevant bindings include s :: t1 -> t (bound at <interactive>:1:2)
18:52:09 <gennady> Even though its printing it out
18:52:18 <yeboot> how to lambda s. s s
18:52:29 <shachaf> yeboot: What type would it have?
18:52:59 <merijn> gennady: It's not an error, it's a warning
18:53:02 <dolio> gennady: It's warning you that it had to pick a type for what you wrote arbitrarily in order to print it out.
18:53:09 <dolio> And it picked Double.
18:53:19 <fread2282> @type fix
18:53:20 <merijn> gennady: "Defaulting" means "You didn't tell me eonough to figure out what you wanted, so I picked "Double""
18:53:21 <lambdabot> (a -> a) -> a
18:53:32 <yeboot> oh right I'm trying to use untyped lambda calculus in a statically typed language
18:53:38 <yeboot> herp
18:53:43 <gennady> Oh hmm
18:53:47 <dmj`> yeboot: \x -> x x, is an infinite type
18:53:59 <dmj`> @typ \x -> x x
18:54:00 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
18:54:00 <lambdabot>     Relevant bindings include x :: t1 -> t (bound at <interactive>:1:2)
18:54:00 <lambdabot>     In the first argument of ‚Äòx‚Äô, namely ‚Äòx‚Äô
18:54:04 <merijn> gennady: If you would have typed "findStdev xs :: Double" it should be quiet
18:54:19 <merijn> gennady: Or "let xs = [1..20] :: [Double]", for that matter
18:55:20 <gennady> Ah yup, thanks!
19:01:24 <jonafan> let's suppose i've got a bunch of functions that deal with lists that will always have at least one item
19:02:12 <jonafan> do you guys think it's better to not deal with the [] case
19:02:32 <jonafan> or make functions like a -> [a] -> b
19:02:43 <shachaf> You could use a type like NonEmpty.
19:02:56 <jonafan> lemme hit the google
19:03:02 <shachaf> http://hackage.haskell.org/package/semigroups-0.15.2/docs/Data-List-NonEmpty.html defines data NonEmpty a = a :| [a]
19:03:22 <shachaf> Which is a lot like your a -> [a] -> b solution, uncurried.
19:04:53 <jonafan> okay... now let's say it's guaranteed to have two items
19:05:29 <trap_exit> https://gist.github.com/anonymous/aa7b166db037aacfa6d9 <-- is there a way to reduce the number of types to__TexExpr appears on the RHS?
19:05:30 <jonafan> (my dumb haskell project involves games of blackjack)
19:05:53 <trap_exit> I'm almost tempted to do something like alias Z = to__TexExpr, and atleast write Z instead of to__TexExpr so many times in the RHS
19:12:03 * hackagebot spice 0.4.0.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.4.0.0 (Crockeo)
19:13:17 <jonafan> i've rewritten this thing 5 times i think
19:13:23 <merijn> argh, any geniuses around? I'm not smart enough for my own problems >.>
19:14:05 <jonafan> it's my first haskell, so it was terrible at first but i'm gradually refining it
19:15:30 <Wizkhalifaaaa> hello?
19:15:36 <merijn> I just can't find an efficient way to have a fair queue where connection can die...the best I've managed so far is "Chan (MVar (TBQueue a))", which is pretty horrific
19:15:57 <Wizkhalifaaaa> i have had the same problem :/
19:16:33 <bmuk> Does ghc use copy on write data structures to make immutability more efficient? I.e. I have a 10000 element list and I change one element. Doesn't ghc optimize this in some way? I was thinking about it and I think COW data structures in memory would be one solution
19:16:45 <merijn> If anyone has any better ideas, please let me know
19:16:45 <sick_potatoes_> hi guys
19:16:49 <merijn> bmuk: In general, no
19:17:02 <BlinkyBill_> bmuk most of the time yes
19:17:06 <merijn> bmuk: However, GHC will reuse the tail of your list after the change
19:17:11 <Wizkhalifaaaa> anyone had any experince in Phishing? could you please pm me?
19:17:20 --- mode: ChanServ set +o shachaf
19:17:25 --- kick: Wizkhalifaaaa was kicked by shachaf (Wizkhalifaaaa)
19:17:32 <sick_potatoes_> anyone know some funny batch file codes? i ran out of ideas ;p
19:17:40 <merijn> bmuk: i.e. if you insert an item in front of the list, it will just use the same list as tail
19:18:09 <merijn> bmuk: if you insert in the middle, you'll have to construct a new "front" of the list, but the tail (after the insertion) is shared
19:18:10 <BlinkyBill_> we are legion
19:18:20 <sick_potatoes_> oh god
19:18:23 <BlinkyBill_> we do not forget we do not forget
19:18:31 <BlinkyBill_> expect us
19:18:50 --- mode: shachaf set +b *!*@gateway/web/freenode/203.14.52.140
19:18:53 --- kick: BlinkyBill_ was kicked by shachaf (BlinkyBill_)
19:19:02 <bmuk> merijn: what about other data structures such as maps.
19:19:04 --- kick: sick_potatoes_ was kicked by shachaf (sick_potatoes_)
19:19:42 <simpson> Disappointing. What about those of us who are legion and can behave ourselves in public? :T
19:19:43 <merijn> bmuk: Same thing, everything between the root and insertion has to be copied, everything below can be reused
19:19:54 --- mode: shachaf set -b+b *!*@gateway/web/freenode/203.14.52.140 *!*@gateway/web/freenode/ip.203.14.52.140
19:20:18 <merijn> bmuk: Insertion in Map requires O(log n) copies in an immutable language
19:20:26 <merijn> Same for Set
19:20:36 --- mode: shachaf set -o shachaf
19:20:49 <bmuk> Is there some reason why the front part of the structure can't be reused?
19:22:56 <merijn> bmuk: Yes, because it is immutable
19:23:14 <ReinH> @src (++)
19:23:14 <lambdabot> []     ++ ys = ys
19:23:14 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:23:15 <lambdabot> -- OR
19:23:15 <lambdabot> xs ++ ys = foldr (:) ys xs
19:23:34 <merijn> bmuk: Suppose I have "1:2:3:5:6:7:[]" if I want to "insert" 4 between 3 and 5 I'd have to mutate the list
19:23:39 <ReinH> makes the reuse pretty clear
19:24:00 <bmuk> what about using a rope under the hood? https://en.wikipedia.org/wiki/Rope_%28data_structure%29
19:24:15 <merijn> bmuk: You'd still be changing the list
19:24:36 <merijn> 3 *has* to point to 5, you can't change that without removing immutability from the language
19:25:39 <bmuk> I understand that it has to be immutable from the programmer's standpoint, but from the compiler's standpoint wouldn't it be the same?
19:26:02 <merijn> bmuk: What you're implicitly assuming is that there's only one reference to the list
19:26:09 <merijn> bmuk: What if there's 5 references to the list?
19:26:15 <bmuk> ah I see
19:26:51 <merijn> bmuk: The upside is that (if you're familiar with the java/c/whatever terminology) you can use shallow copies everywhere
19:26:57 <bmuk> they would need to point to the old list
19:27:04 <merijn> bmuk: If nothing can change you never need deep copies
19:27:13 <merijn> bmuk: Which is why you *can* reuse the tail of the list
19:27:40 <shachaf> A Tail of Two Lists
19:28:13 <ReinH> I see what you did there
19:28:26 <merijn> > let h = 5:6:7:[] in (1:2:3:4:h, 1:2:3:h) -- copying the start and reusing the tail would look "like this" after the "insert"
19:28:28 <lambdabot>  ([1,2,3,4,5,6,7],[1,2,3,5,6,7])
19:28:39 <bmuk> So in let x = [1,2,3], b = x b is just a pointer to the list in x?
19:28:47 <dmwit> yeboot: You might like data D = D (D -> D)
19:28:55 <merijn> bmuk: Effectively, yes
19:28:57 <shachaf> bmuk: b and x are pointers to the same list
19:29:20 <merijn> Wasn't there a really nice webpage showing haskell evaluation using lots of arrows and explaining sharing?
19:29:25 <dmwit> yeboot: So that you can write D (\x -> case x of D x' -> x' x) or something like that.
19:29:39 <shachaf> @where lazy
19:29:39 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
19:29:40 <ReinH> merijn: there's one about thunk with cartoony pictures that ezyang did
19:29:43 <ReinH> *thunks
19:29:47 <ReinH> ^ is great though
19:29:54 <dmwit> yeboot: Of course, the downside of this representation is that you can never observe anything. =P
19:29:56 <shachaf> I saw a talk recently that had nice graphs.
19:30:00 <shachaf> http://jelv.is/blog/Lazy-Dynamic-Programming/
19:30:34 <merijn> bmuk: That vex link is a pretty good intro that shows how stuff can be shared in haskell :)
19:31:04 <bmuk> thank you all :) merijn++ shachaf++ ReinH++
19:31:34 <merijn> The lazy dynamic programming one is also really nice :)
19:32:12 <merijn> ok, so I need to run a terrible idea for a fair queue by you guys
19:33:19 <ReinH> merijn: ok
19:33:26 <merijn> How about just having a single MVar and rather than writing to it directly do "forkIO $ putMVar sharedVar x", the MVar has a FIFO wake up queue, so this guarantees fairness and lets me cancel by just async interrupting the thread...
19:36:11 <merijn> hmm, according to the docs they're FIFO, but that's not guaranteed, so maybe not such a great idea...
19:38:01 <lennOracle> hi :) please forgive me for asking such a silly question, but is there a quick way to convert a string such as "(nand (nand (a) (b)) (a))" into a tuple like ("nand",("nand","a","b"),"a")? if not, how might I go about doing this? Thanks :)
19:38:22 <shachaf> No way, quick or otherwise.
19:38:34 <shachaf> Tuples have types that determine their shape at compile time.
19:38:51 <shachaf> Start by defining an algebraic data type for the sort of expressions you want to parse.
19:39:21 <shachaf> To do this you should start by figuring out what sorts of expressions you want to parse.
19:44:34 <lennOracle> shachaf: okay, i'll give that a try, thanks :)
19:45:45 <ReinH> lennOracle: might be a good time to read about parsing
19:46:41 <shachaf> Parsing is how you get from point A to point B.
19:46:50 <shachaf> It's useful to figure out what those points are first.
19:47:24 <ReinH> Yep.
19:47:35 <merijn> Hah "reallyUnsafePtrEquality# :: a -> a -> Int#"
19:47:46 <ReinH> merijn: my favorite ghc function :D
19:47:57 <shachaf> merijn: It's really unsafe because it can give you both false negatives and false positives.
19:48:07 <merijn> shachaf: I know :)
19:48:40 <lennOracle> ReinH: haha, this is admittedly a homework problem and I've never done any haskell at all, so I've been trying to read as much as I can whilst simultaneously trying to do the problems, still not familiar with so much stuff :X
19:48:53 <ReinH> lennOracle: a homework problem where?
19:48:55 <lennOracle> for only a day or so now that is, not easy!
19:49:10 <merijn> There's no CAS2 primitives in GHC, I guess?
19:51:31 <lennOracle> ReinH: I haven't posted the problem itself, I was just asking how I might solve that part of it
19:51:44 <ReinH> It's a rather odd Haskell problem.
19:51:51 <ReinH> So I was curious where you found it.
19:52:03 <ReinH> And what the context is.
19:52:55 <lennOracle> ultimately i'll be turning that string into a boolean expression and then I'll be passed the actual values of the variables and will have to evaluate that expression
19:53:31 <lennOracle> i'm probably going about it in the completely wrong way but I'm learning a lot of haskell in the meantime trying to figure out how I might do such a thing :P
19:55:43 * ReinH shrugs
19:56:18 <ReinH> If that is supposed to be a beginner Haskell exercise, that's rather troublesome.
19:56:32 <tabemann> it's not a beginner Haskell exercise, for starters
19:56:48 <shachaf> It sounds like a good Haskell exercise to work toward.
19:56:50 <tabemann> secondly, if they are actually specifically asking for tuples, what they're asking for is impossible
19:57:05 <haasn> I think using tuples was lennOracle's idea
19:57:18 <haasn> AB problem
19:57:19 <shachaf> Not all exercises have to be bite-sized.
19:58:11 <trap_exit> lnk to said exercise please?
19:58:27 <trap_exit> *link*
19:59:41 <trap_exit> okay
19:59:45 <trap_exit> I demand a link to said exercise
20:01:03 <ReinH> shachaf: I would hope it would come with enough context to rule out a "simple" solution though, and to explain why there isn't one.
20:01:04 <lpvb> what's a good resource to learn FRP
20:01:32 <ReinH> lpvb: I suppose it depends on what you mean by FRP. Maybe Elm these days?
20:01:38 <bmuk> shachaf, where do you find articles like this?
20:01:39 <ReinH> Although it isn't The One True FRP
20:01:47 <shachaf> bmuk: Like what?
20:02:30 <lpvb> idk elm focuses on usage I want to know the underlying mechanics of FRP and stuff
20:02:39 * tabemann liked that piece on dynamic programming
20:02:41 <lpvb> so I know what I'm doing
20:03:07 <bmuk> shachaf: http://www.vex.net/~trebla/haskell/lazy.xhtml
20:03:48 <shachaf> bmuk: By being in here.
20:03:57 <shachaf> monochrom wrote that article and links to it occasionally.
20:04:10 <shachaf> If monochrom wrote an article it's probably good.
20:04:15 <MP2E> ^
20:04:17 <ReinH> lpvb: maybe this will help? http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming
20:04:47 <haasn> I like http://www.vex.net/~trebla/humour/
20:06:04 <bmuk> shachaf: so there isn't a one true source of all haskell articles? haha
20:06:12 <bmuk> Other than this channel I mean
20:06:27 <haasn> #haskell is the one true source of all haskell articles, though
20:06:31 <ReinH> Many of them factor through this channel at some point
20:06:54 <bmuk> I figure it will just be new ones though. I have a lot of catching up to do
20:08:20 <Dre3ml0rd> why use haskell over c++ for instance?
20:08:53 <haasn> It's more fun to program in
20:09:15 <shachaf> bmuk: There are a lot of bad Haskell articles. The hard part of making a useful source of Haskell articles is cutting them out, not collecting everything.
20:10:32 <Dre3ml0rd> haasn so its just more enjoyable to use?
20:10:55 <ReinH> Dre3ml0rd: I don't think that was an exhaustive list. ;)
20:11:12 <Dre3ml0rd> ReinH haha
20:12:38 <merijn> Because haskell is much simpler than C++
20:12:56 <ReinH> Dre3ml0rd: You can reason more effectively about program behavior in Haskell, the type system is more powerful so it both catches more errors and provides more assistance in writing correct programs
20:13:18 <Dre3ml0rd> ok thats great to know
20:13:29 <ReinH> There are plenty of times when the type system has helped me write something I probably couldn't have written myself
20:13:30 <Dre3ml0rd> XCode allows for haskell now as well which is ideal
20:13:59 <ReinH> You get to use all the best (imo) parts of math to help you write better programs
20:14:05 <haasn> Haskell makes it much harder to accidentally shoot yourself in the foot
20:14:34 <bmuk> Dre3ml0rd: The only real reasons to use C++ over haskell are maintaining legacy code and writing software that interacts with memory directly or makes use of assembly code. Hopefully the later will be easier in high level languages sooner rather than later
20:14:44 <merijn> haasn: Except when you're using async exceptions :p
20:15:18 <Dre3ml0rd> bmuk ok makes sense
20:15:40 <bmuk> That's just my opinion though
20:20:31 <bmuk> has anyone used Ivory yet?
20:21:44 <jle`> safety and enhanced reasoning capabilities have become the best benefits of haskell to me
20:21:44 <jle`> you have to think a lot less
20:22:37 <jle`> and you can say more meaningful about parts of your program, too
20:24:19 <haasn> I also like conciseness - it's usually much shorter, in terms of characters and lines of code, to say the same things in Haskell
20:30:16 <AlephNull> I've been looking at the Ghc package, specifically compiling targets at runtime. How trivial would it be to have the bulk of the program be able to be dynamically recompiled while still keeping some sort of state between recompiles.
20:30:49 <merijn> AlephNull: If you can serialise your state to a socket/file, pretty easy, if not, pretty hard :)
20:31:22 <AlephNull> Mkay. I wonder, can sockets actually be serialised?
20:31:32 <AlephNull> The main state is tcp connection data.
20:32:21 <shachaf> You can pass file descriptors to other processes.
20:32:48 <AlephNull> Oh, sockets are literally just handles. I imagine those are easily copied?
20:32:57 <merijn> AlephNull: Socket are inherited via fork and not closed by exec
20:33:22 <merijn> AlephNull: You'll have to convert to/from file descriptors from the Handle, but other than that it's actually pretty easy
20:33:55 <AlephNull> Out of interest, if the file I'm running imports something which is later added as a target, will it get recompiled?
20:35:14 <tabemann> the other thing is you could break your program into two parts, a pluggable part and a plugin part, and only recompile and reload the plugin part, and pass the Handle to the plugin part after it is loaded
20:35:14 <tabemann> that way you don't even need to fork/exec a new process
20:35:32 <trap_exit> in C, if my code infinite loops with functions calling each other; I can compile with -g, fire up gdb, then look at the stack frames. In haskell, when my code infinite loops, ghc tells me "<<loop>>" -- how can I get ghc to dump the fucking call frame / stack frames ?
20:36:00 <dolio> There aren't stack frames.
20:36:21 <trap_exit> okay
20:36:23 <trap_exit> how do I debug infinite loops?
20:36:58 * AlephNull could theoretically have the loading/unloading handled completely by the 'plugin' half of the program, the host part just responding to some sort of signal of when to reload.
20:37:06 <AlephNull> Define a loop.
20:37:12 <dolio> Test individual functions. Use the debugger. Trace.
20:37:17 <yeboot> how does one use the let keyword in hugs
20:37:26 <tabemann> you're using hugs?
20:37:32 <yeboot> for now, yes
20:37:37 <trap_exit> test individual functions is icky due to laziness
20:37:45 <trap_exit> so an infinite loop may not be a problem until I need the value
20:37:46 <trap_exit> how do I trace?
20:37:47 <meoblast001> when installing gtk, what can i do to resolve this error? "Module `Data.Text.Foreign' does not export `withCStringLen'"
20:38:24 <dolio> Why would laziness be a problem with testing individual functions?
20:39:25 <tabemann> you can always deepseq what functions return, to force the evaluation of any loops
20:39:28 <merijn> yeboot: It is STRONGLY recommend you use ghci over hugs
20:39:37 <merijn> yeboot: Hugs is very out of date and poorly maintained
20:39:43 <tabemann> merijn: I was going to saythat
20:40:04 <tabemann> isn't it completely unmaintained now?
20:40:09 <merijn> It might be
20:40:21 <AlephNull> Out of curiosity is using the Ghc package that much of a limiting factor, or is ghc enough of the defacto standard that it doesn't matter?
20:40:47 <merijn> AlephNull: There's a few other compilers, but for production code I wouldn't worry about GHC being limiting
20:40:53 <tabemann> ghc is the only Haskell compiler anyone actually uses, so that shouldn't be an issue
20:40:56 <merijn> AlephNull: Half of hackage is ghc only :P
20:41:06 <geekosaur> only half?
20:41:07 <monochrom> if you use hugs, there is no equivalent of "let x=1" like in ghci
20:41:51 <AlephNull> Hmm
20:42:05 <merijn> ok, I'm giving up on this concurrent fair queue business for tonight
20:42:10 <merijn> I'm not smart enough for this...
20:42:38 <AlephNull> If I declare 'foo 1 = bar' in one module and 'foo 2 = baz' in another, will I be able to call both foo 1 and foo 2?
20:43:05 <merijn> AlephNull: Yes, but it will require disambiguation
20:43:20 <merijn> AlephNull: For example, importing both modules qualified and using Foo.foo and Bar.foo
20:43:58 <AlephNull> So can't do it unqualified?
20:44:10 <geekosaur> I think they were hoping for consolidation in the same way it works in a single module. which, no, does not work
20:44:16 <dolio> They will be two different functions.
20:44:22 <dolio> They are not two cases of the same function.
20:44:29 <geekosaur> the single module one desugars into a single function with a top level case
20:44:37 * AlephNull idly considers concatenating sources.
20:45:07 <geekosaur> ghc (indeed, the haskell report) won't even take it in the same module if they're separated by another binding
20:47:11 <AlephNull> I have 'command :: Controller -> String -> String -> IO () -- enacting controller, command name, command arguments' and was hoping of being able to add more commands across multiple files. Though I somewhat imagine that I might be better having Command.hs with all definitions of command pointing to functions in other modules.
20:47:40 <simpson> AlephNull: What are you building?
20:47:52 <benzrf> geekosaur: wait, seriously?
20:47:55 * benzrf tries
20:48:28 <geekosaur> depending on what exactly you're up to, you may be able to do that with a typeclass. *but* that's not necessarily the right way to go. we'd have to know exactly what you're trying to achieve with this
20:48:28 <AlephNull> A tcp/talker server thing.
20:48:43 <geekosaur> benzrf: last I checked at least
20:48:46 <monochrom> pattern matching does not work that way
20:48:52 <merijn> Sounds like the expression problem to me :p
20:48:56 <geekosaur> yep
20:49:09 <benzrf> dang
20:49:11 <merijn> To which I still have to find a satisfactory solution in haskell
20:49:27 <AlephNull> Would I be better off using cases instead of pattern matching?
20:49:36 <benzrf> AlephNull: case IS pattern matching
20:49:36 <monochrom> case = pattern matching
20:49:37 <merijn> I've seen Ralf L√§mmel's solution and Swierstra, but neither strike me as very well-performing
20:49:52 <AlephNull> Or more manually desugaring.
20:49:55 <jle`> do typeclasses not help
20:50:00 <jle`> the expression problem
20:50:15 <geekosaur> they help in some ways and hurt in others
20:50:28 <merijn> jle`: Both Ralf and Swierstra's solution use typeclasses, they help in making it possible, but don't help performance wise
20:51:07 <simpson> Well, as a wise man once said, it's not called The Expression Inconvenience.
20:51:10 <monochrom> I speak semantically. does not matter what syntax sugar you're thinking.
20:51:20 <AlephNull> Would this be bad? https://gist.github.com/jrobertsgb/b8f17289e959c4e4d6c4
20:51:24 <jle`> typeclasses have a performance impact?
20:51:44 <merijn> jle`: It depends on the usecase
20:51:54 <merijn> jle`: If they can be inlined then they will have almost zero overhead
20:52:03 <jle`> i can think of a space overhead perhaps
20:52:09 <merijn> jle`: But the way they're used in the expression problem prevents inlining
20:52:21 * hackagebot validation 0.4.0 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.4.0 (TonyMorris)
20:52:25 <jle`> hm
20:53:09 <monochrom> nothing wrong with https://gist.github.com/jrobertsgb/b8f17289e959c4e4d6c4
20:53:39 <monochrom> in fact, I do something that way in my IRC processing code
20:53:52 <monochrom> that is, string literals in patterns
20:54:12 <jle`> i do this often
20:54:40 <jle`> i also do case words inp of { "hello":"world":_ -> ... }
20:54:44 * AlephNull is thinking of having a caseSensitiveCommand pattern, the general case of which giving the arguments to the command function in lowercase.
20:55:05 <AlephNull> For times when I want/need the arguments in the orignal case.
20:56:01 <monochrom> I don't understand the sentence about caseSensitiveCommand pattern.
20:56:37 <monochrom> pattern matching against string literal is case-sensitive, along with codepoint-sensitive
20:56:51 * AlephNull looks it over. Basically, caseSensitiveCommand gets its argumeents as typed by the user, command has it given in lowercase.
20:57:06 <AlephNull> The latter probably has some use in pattern matching on arguments.
20:58:40 <AlephNull> There's not that many use cases I can think of where you'd need the text in the original case
20:58:45 <monochrom> I admit ignorance of this topic and I will stop talking.
21:00:24 <merijn> There's a case-insensitive packages which allows both case insensitive comparison while tracking the original case of the text...
21:00:49 <AlephNull> Oh?
21:01:11 <AlephNull> Surprisingly, it's called case-insensitive
21:03:02 <jle`> one of the more classic examples of fun with newtypes
21:03:32 <benzrf> i think one of the most annoyingly tricky classes of problems that are solved incredibly well by higher order functions are the sort that involve acting on transformed versions of data and persisting the changes to the original
21:03:53 <benzrf> i.e. like the kind of thing that the schwarzian transform does in perl
21:04:09 <benzrf> or diffing based on some subset of the values d:
21:04:39 <benzrf> hmm, 'acting on transformed versions of data and persisting the changes  to the original
21:04:44 <benzrf> may be poor phrasing
21:04:48 <swgillespie> that sounds like a patent
21:04:54 <monochrom> haha
21:05:07 <jle`> lol
21:05:48 <benzrf> but really any kind of function that has a By suffix falls into this class, i think
21:06:41 <benzrf> without the ability to toss predicates around, that kind of thing would only be solvable by mapping, doing the regular version, then somehow matching the mapped versions back to the originals
21:06:54 <Axman6> swgillespie: i read patents all day, that was far clearer that most of what comes across my desk
21:07:24 <dolio> Are you validating the patent on immutibility?
21:07:42 <Axman6> eh?
21:07:59 <dolio> Immutability, i guess.
21:08:14 <swgillespie> that patent is 100% gonna die
21:08:21 <Axman6> oh, are you talking about the MS one?
21:08:33 <swgillespie> Axman6: that must be a tough job :/
21:08:36 <dolio> Yes. But I don't want to start a lengthy discussion.
21:08:40 <Axman6> i havent looked at it closely, but id guess its life is short
21:08:58 <swgillespie> MS is just trying to make sure that nobody else can patent it by trying it first and then failing
21:09:00 <swgillespie> shrug
21:09:02 <swgillespie> software patents :(
21:09:08 <Axman6> swgillespie: yes, which is why I've quit and will be leaving in a few weeks =)
21:09:21 <swgillespie> Axman6: haha, congrats! :D
21:10:13 <Axman6> there's nothing inherently wrong with software patents, it just happens to be the current area of huge groth and innovation. its happened before in many i dustries
21:11:41 <dolio> That's probably about enough.
21:11:52 * Axman6 apologises for poor typing, ipads and ssh dont make for a great editing environment
21:25:38 <qrada__> hey everyone.. wondering if anyone could provide some quick insight.. soo.. I have this record which I use to create some 'abstract counters'. I have various implementations for this counter -> mvar, ioref, redis, etc.... now, I would LIKE to somehow run my runCounterTests function on all of those different 'types' of Counters.. ie, using mapM runCounterTests [mkCounter'MVar, mkCounter'IORef, mkCounter'Redis] etc
21:26:27 <qrada__> I can run them one by one obviously.. but, i'd like to somehow map over them etc for my benchmarking
21:26:58 <qrada__> not sure what to do.. extremely tired also not helping
21:32:37 <Cale> qrada__: I think I'd need more information about the types of things to be able to give a sensible answer
21:33:34 <qrada__> ah
21:34:08 <qrada__> ok well I have some wrecked stuff on github.. would you like a link? I think I need to re-read script your typeclasses etc.. something i'm doing is holding everything back
21:35:36 <Axman6> you could each of tgem provide a function of type Action -> IO Result
21:35:43 <mzero> I need help from the math wiz's here: I defining a type class that is a Partial Order, plus one more law:    if   a ‚â§ c  && b ‚â§ c   then  either a ‚â§ b or b ‚â§ a ...
21:36:00 <mzero> I'm wondering what that property is called, and if there is a name for such a class?
21:36:11 <trap_exit> wtf
21:36:14 <trap_exit> so for any a, b <=c
21:36:20 <trap_exit> oh wait
21:36:23 <trap_exit> n/m, I misread, sorry
21:36:34 <trap_exit> so for any element, all elements less than it form a full order
21:36:52 <mzero> yes
21:37:01 <qrada__> Axman6: true.. good idea thanks
21:37:05 <trap_exit> I have no idea what it's called, sorry
21:37:22 <mzero> Think of it as the typeclass of values that can be ordered by Trees
21:37:22 <qrada__> i need to pick people's brains in here one day so that i can get set on the right track... i have no problem refactoring all of this code
21:38:27 <trap_exit> i dunno
21:38:30 <trap_exit> trees seem to imply disjoint
21:38:33 <Axman6> it seems on the surfacr a problrm calling for typeclasses but its probablu not
21:38:36 <trap_exit> but you can have stuff like a <= b, a <= c
21:38:46 <trap_exit> then the elems <= b form a full order, the elems <= c form a full order
21:38:52 <trap_exit> and a is shared among both
21:38:56 <mzero> Yeah, so I'm defining a typeclass   Prefix    for values that can be built into prefix-trees
21:39:09 <Axman6> hmm, i should perhaps give up on this ipad irc idea...
21:39:17 <qrada__> Cale, here are two links.. I have tons of separation in my modules/repos so it's a bit 'nutty'.. here's my testing library: https://github.com/adarqui/Abstract-Testing/blob/master/src/Abstract/Testing/Counter.hs  ... Here's my Counter 'interface': https://github.com/adarqui/Abstract-Interfaces/blob/master/src/Abstract/Interfaces/Counter.hs
21:39:57 <trap_exit> i fail to see how this is useful
21:40:01 <mzero> so, for example, IP address blocks are an instance -- but have two roots (IPv4 & IPv6)
21:40:07 <trap_exit> since it seems like all prefixes are <= "Zzzzzzzzzzzzzz"
21:40:34 <mzero> 0.0.0.0/0 is a prefix of all IPv4 address, but not any IPv6 addresses
21:40:41 <mzero> so there can be multiple roots
21:40:51 <mzero> but even if there is a single root, it still isn't a total order
21:40:51 <trap_exit> why not just have 2 classes ?
21:40:52 <trap_exit> ipv4 and ipv6 :-D
21:40:55 <qrada__> if any of you want to take a quick peek.. so basically.. my Counter data type is pretty polymorphic.. I have several implementations of this counter (ioref/mvar/redis) etc.. Now that i'm doing this testing library, im running into the problem of how to test/benchmark all of them etc... but I like the Action -> IO Int idea
21:41:03 <mzero> 10.0.0.0/8 is incomparable with 192.0.0.0/8
21:41:38 <mzero> I need them in one data structure... but that is another story... even with a single root, it still isn't a total order
21:41:56 <trap_exit> https://gist.github.com/anonymous/d2d51f4d1ec4a247892d <-- is "cabal udpate" supposed to freeze on osx? this is ghc 7.8.3
21:42:10 <trap_exit> I don't understand why it is bad
21:42:14 <trap_exit> to have 10.0.0.0 < 192.0.0.0
21:42:29 <mzero> no, trap_exit cabal on os x shouldn't freeze....
21:42:32 <mzero> and doesn't for me...
21:42:39 <mzero> what version of cabal?   (cabal --version)
21:42:49 <Cale> qrada__: You use way way way too many modules
21:42:54 <mzero> it is bad for my use case to have 10.0.0.0/8 < 192.0.0.0/8
21:43:13 <mzero> you can think of these two prefixes as sub-trees of a routing that can't be compared
21:43:16 <qrada__> cale, ya
21:43:21 <Cale> and not enough top level type signatures
21:43:23 <trap_exit> mzero: https://gist.github.com/anonymous/49e63e4bae7f4991fcbd <-- is this the cabal version you have?
21:43:52 <trap_exit> mzero: I think we have the X Y problem. What are you actually trying to solve?
21:44:23 <qrada__> i dont really know how to clean it up so that it's really solid/useable yet.. when i do i will refactor everything
21:44:24 <mzero> trap_exit: that is the correct, Haskell Platform included version of cabal
21:44:45 <qrada__> my biggest thing now is trying to figure out how to test/benchmark all of my different implementations.. efficiently
21:45:03 <qrada__> i'd like to have ioref/mvar/redis compete .. and pass my tests
21:45:09 <qrada__> in some uber clean way
21:45:19 <mzero> trap_exit - I'm building an Internet Router... and I need a framework for testing and evaluating routing table optimizers....
21:45:46 <trap_exit> mzero: whdy do you have to be able to compare some, and not be able to compare others?
21:46:18 <mzero> but that is somewhat besides the point - I have a type class and this is the law that I needs to embody --- I'm just looking for the proper name for the mathematical property (like reflixivity, transitive, and ???) as I'd like to use the right concepts... and potentially learn from it
21:46:28 <mzero> cabal update just updated for me
21:46:31 <mzero> btw
21:46:47 <trap_exit> mzero: I found the problem
21:46:52 <trap_exit> re-downloading haskell platform is going to take me 3 hours
21:47:03 <trap_exit> I think the problem is that my internet is currently slow
21:47:54 <mzero> trap_exit: because if you are receiving a large collection of BGP annoucements, you need to relate prefixes to existing parts of the routing tree: They could be "covering", "covered", "same", or "disjoint" -- the disjoint case is pretty important because then you know that theses two parts of the routing problem are separable
21:48:39 <trap_exit> mzero: do you actualy need "a <= b" or "a is_covered_by b" ?
21:49:24 <jle`> <= is so confusing to me now these days
21:49:32 <jle`> because of => in haskell being syntax
21:49:40 <jle`> >= too
21:49:40 <jle`> because of >>=
21:49:43 <jle`> v.v
21:49:45 <jle`> what happened to me
21:49:55 <mzero> trap_exit: I don't use ‚â§ or < ... I use ‚âº , which is an alias for a type class member, covers
21:50:20 <mzero> so yes, this type class doesn't have Ord as a constraint
21:50:31 <mzero> and < doesn't work on such values
21:50:44 <mzero> but covers is a partial order over the values
21:51:07 <trap_exit_> one more dumb question
21:51:11 <trap_exit_> so your 'elements' are sets of ip addresses
21:51:14 <mzero> but partial order isn't enough ... it needs this "prefix" or "tree-like" property... but I'm not sure what it is
21:51:17 <trap_exit_> and set A coers set B iff B is a subset of A ?
21:51:45 <theme2> hi
21:52:01 <mzero> the values of the type class are IP Subnets - so an leading-prefix bit match on IP addresses
21:52:50 <theme2> I'm new here
21:52:58 <mzero> So, for example,   Set a   is not  Prefix --- precisely because if a is a subset of c, and b is a subset of c....   a and be might not be subsets of one or the other
21:53:16 <mzero> welcome theme2 - just jump right in and ask if you need help with Haskell!
21:53:29 <theme2> hehehe :D
21:53:38 <Axman6> hi theme2, do you have a question about haskell?
21:53:58 <theme2> Axman6: erm... maybe yes?
21:54:17 <theme2> I didn't expect 2 people to suddenly ask this
21:54:18 <theme2> wait a sec
21:54:19 <qrada__> theme2: Either No Yes
21:54:44 <mayski> prepare your monads
21:54:56 <Axman6> or Bool
21:54:57 <qrada__> lol
21:55:36 <mzero> trap_exit_: should have said that this way:   a ‚äÉ c  ‚àß   b ‚äÉ c  does not imply  a ‚äÉ b ‚à® b ‚äÉ a
21:55:38 <trap_exit_> shit
21:55:39 <trap_exit_> cabal update succeeded
21:55:46 <Axman6> oh no
21:55:57 <dmj`> ready your lambda cannons
21:55:58 <theme2> OK.... I guess my question is a bit classic "What exactly is a monad?"
21:56:15 <mzero> @quote jello
21:56:15 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
21:56:23 <mzero> :-)
21:56:24 <mayski> ahahah
21:56:32 <trap_exit_> (a <= c) and (b <= c) does not imply (a <= b) or (b <= a)
21:56:43 <theme2> I have one explanation for the Either and the list monads
21:56:47 <trap_exit_> mzero: okay, so two elements smaller than c are not necessairly comparable to each other
21:56:59 <theme2> I have another for the Writer and the State monads
21:57:06 <trap_exit_> mzero: this can be like 10.0.0.0/8 = c, a = 10.1.0.0/16, b = 10.2.0.0 / 16
21:57:11 <trap_exit_> then a <= c, b <= c, but you can't compare a & b ... right? mzero
21:57:12 <theme2> I have yet another for the Reader monad
21:57:26 <theme2> And I'm still getting my head around the IO monad
21:57:37 <MorpheusBeing> Question - is there an example somewhere of how I can use lambdabot in a QT program and interact with it? ELI 5 as I am an apprentice
21:57:45 <trap_exit_> theme2: my suggestion is (1) ignore monads, (2) write haskell
21:57:55 <trap_exit_> (3) at the point when you're like "why the fuck amI passing all these arguments around"
21:57:58 <trap_exit_> read the type signatures on the reader / state monad
21:58:02 <trap_exit_> and be like "damn, this is exactly wht I need"
21:58:07 <theme2> Is there any explanation that can make me understand all of them?
21:58:19 <mzero> trap_exit_: other way 'round     if a is a prefix of 10.1.2.0/24   and b is a prefix of 10.1.2.0/24   (both are fewer bits than that)... then we need the property that either a or b is the prefix of the other (or a == b)
21:58:22 <MorpheusBeing> @fortune
21:58:22 <lambdabot> Q:      What do you say to a Puerto Rican in a three-piece suit?
21:58:22 <lambdabot> A:     Will the defendant please rise?
21:58:23 <trap_exit_> theme2: ask jle` -- he's amazing; he explained it to me
21:58:37 <Dre3ml0rd> can someone briefly explain to me the importance of a line like this:
21:58:37 <Dre3ml0rd> heightPercent :: (Integral a) => a -> a -> String
21:58:43 <dmj`> jle` is amazing
21:58:47 <dmj`> jle`++
21:58:48 <jle`> >_______>
21:58:51 <mzero> theme2: is your background other programming languages like Java?
21:58:52 <jle`> im not
21:59:11 <theme2> mzero: sort of, but not java
21:59:11 <MorpheusBeing> ?karma+ jle`
21:59:11 <lambdabot> jle`'s karma raised to 9.
21:59:13 * trap_exit_ volunteers jle` to explain monads by type signatures to theme2
21:59:29 * dmj` dmj` seconds
21:59:34 <jle`> theme2: one helpful thing might be to, for now, strop looking for common themes between different monad instances and instead use them practically as they come up in your own programming adventures
21:59:54 <trap_exit_> mzero: this seems different from " (a <= c) && (b <= c)" does not imply "(a <= b) or (b <= a)"
22:00:02 <jle`> i don't think going through "all the monad instances" and understanding them one-by-one in a vacuum is a very constructive thing
22:00:08 <mzero> well - one way is to just look at Monad this way: It is just an interface with a two members.... return and >>=  (>> is just sugar, and fail is best not talked about for now)
22:00:28 <trap_exit_> mzero: forget it, this is the property you want: "(a is prefix of c) AND (b is prefix of c)" ==> "(a is prefix of b) or (b is prefix of a)" <--- right?
22:01:06 <theme2> jle`: well... that works well for me until I try to understand monad transformers and the ST monad
22:01:07 <mzero> well, look at it this way, trap_exit_    if I have two things that are prefixes of a third, I need that to imply that one is the prefix of the other.     subset as a partial order relation doesn't staisfy this
22:01:16 <mzero> address prefixes used for routing need to
22:01:17 <trap_exit_> mzero: forget it, this is the property you want: "(a is prefix of c) AND (b is prefix of c)" ==> "(a is prefix of b) or (b is prefix of a)" <--- right?
22:01:23 <trap_exit_> mzero: isnt't that the same as wht I stated?
22:01:27 <mzero> yes
22:01:30 <trap_exit_> mzero: are we LOUDLY AGREEING with each other? :-)
22:01:30 <mzero> that is what I want
22:01:30 <jle`> yeah.  and each instance/interface is useful in its own way, independent of the usefulness of the other instances.  the main thing that uniting them under a Monad typeclass offers is the ability to write generic functions
22:01:36 <mzero> what is that called in math, any idea?
22:02:04 <jle`> theme2: why would the ST monad be an exception? :)
22:02:26 <jle`> understand the ST type and what it offers, practically
22:02:31 <theme2> jle`: I dunno
22:02:32 * hackagebot blacktip 0.1.0.0 - Decentralized, k-ordered unique ID generator.  http://hackage.haskell.org/package/blacktip-0.1.0.0 (bitemyapp)
22:02:34 <jle`> then look at what a monadic interface offers
22:02:36 <jle`> to that type
22:02:59 <jle`> most monad instances are useful outside of their monad instances/interfaces
22:03:04 <jle`> i mean, look at list
22:03:05 <trap_exit_> mzero: I think this is called a string
22:03:08 <trap_exit_> mzero: I think all strings satisfy this property
22:03:24 <jle`> do you go to a new haskeller and say, "hey, let me introduce you to the List Monad :D", and then talk about [1,2,3] ?
22:03:37 <jle`> i mean...yeah, List is a monad instance
22:03:46 <jle`> but its monad instance isn't the whole story of how useful it is
22:03:47 <theme2> jle`: I think of it more like a dfs
22:03:58 <theme2> when it is used as a monad
22:04:04 <jle`> i meant, saying "list monad" when you really mean "list type"
22:04:31 <jle`> in this case, if you're trying to teach someone about haskell lists...and how to create them, pattern match on them, etc....it is irrelevant that it's a monad.  it's useful in and of itself
22:04:37 <theme2> jle`: erm... nope
22:04:43 <theme2> ok...
22:04:44 <nshepperd> a monad is like a helmet that gives you superpowers
22:04:49 <theme2> ???
22:04:51 <monochrom> clearly, the reason you use the list monad at a certain place is that you need its specific listness.
22:05:01 <mzero> theme2: you can think "a monad instance is a type that let's me put a normal value into the monad (return); and lets me apply an operation to the value within the monad, so long as the operation is pure (and so I use liftM), or it returns a new value within the monad (>>=)
22:05:21 <trap_exit_> mzero: in all seriousness -- isn't the property we described strings/lists? i.e. all strings/lists satisfy this property
22:05:34 <monochrom> similarly, I use parsec because it is parsec, not because any arbitrary monad suffices
22:05:39 <mzero> Now, almost any monad will have additional features - like how to get the value back out of the monad into pure computation land again... or other fancy operations....
22:05:45 <theme2> mzero: liftM is another thing I got confused
22:05:48 <mzero> but the essence is just the interface I gave
22:06:10 <mzero> trap_exit_: yes, [a] is a valid instance of Perfix for all Eq a ... and so are Strings....
22:06:31 <shachaf> "how to get the value back out" is misleading intuition, I think (because it suggests that "there's a value", which is almost never the case).
22:06:36 <mzero> but there are other values ... such as IP addresses....
22:06:50 <mzero> well - depends on the monad, eh?
22:07:06 <nshepperd> isn't an ip address just a string of bits
22:07:06 <mzero> but yes, "back out" is fuzzy
22:07:14 <shachaf> I can only think of a few where the concept of "the value" makes sense.
22:07:27 <shachaf> Pretty much only Writer w for various values of w, actually.
22:07:37 <mzero> bounded, and with two distinct incomparable forms, nshepperd , yes
22:07:56 <theme2> mzero , shachaf: well... one reason I don't understand the ST monad is probably because I don't quite understand the IO monad
22:07:58 <mzero> but again, I'm looking for the mathematical property, not a concrete instance
22:08:02 <jle`> Identity might be counted among them.  but that's reducible to Writer (), kinda
22:08:19 <jle`> theme2: do you understand the IO type?
22:08:31 <shachaf> Anyway, I just joined, I'm probably missing some context anyway.
22:08:38 <theme2> jle`: I'm not sure
22:08:48 <jle`> start there :)
22:08:52 <monochrom> theme2: have you read my http://www.vex.net/~trebla/haskell/IO.xhtml ?
22:09:03 <mzero> theme2: I'd expand on what I said above --- notice that the monad instance (Either, ST, IO, []) gets to decide how return and >>= are implemented - which means all the computation is under it's control in a sense
22:09:09 * theme2 clicks the link
22:09:28 <shachaf> theme2: ST and IO are both pretty magical, unusual examples of a monad.
22:09:45 <shachaf> If your goal is "understand monads", you're probably better off with almost any other example.
22:10:00 <coppro> ^
22:10:05 <shachaf> If your goal is "understand how I/O is done in Haskell", you should look at IO, of course.
22:10:16 <coppro> Maybe is the canonical first example
22:10:18 <theme2> btw I initially thought IO was a special syntax until I realized it was a type constructor
22:10:23 <jle`> IO and ST are indeed unlike most other monads in haskell.  trying to "learn all the monads" is very difficult if you jsut go through different instances and see how they relate
22:10:27 <shachaf> You can accomplish either of these goals reasonably well without the other one.
22:12:02 <jle`> i'll silently add in my own IO type overview, http://blog.jle.im/entry/first-class-statements ... but it doesn't really go over the monad instance
22:12:30 <jle`> so it might help you separate out thinking about the IO type, and its monad instance...and you might see that former can be understood without mention of the latter
22:12:37 <mzero> trap_exit_: http://matt.might.net/articles/partial-orders/ is a good survey or various partial orders and lattices... but oddly the thing I'm after is missing there
22:12:52 <dmj`> theme2: have you checked out the monad tutorial fallacy paper? the typeclassopedia or the "what I wish I knew when learning haskell" posts?
22:12:58 <dmj`> *blog post
22:12:59 <jle`> i don't recommend looking at a type and trying to understand its monad instance without understanding the type itself
22:13:08 <trap_exit_> in addition to @ for ops, we should have a title for "Prof", like "Prof Jle1"
22:13:08 <trap_exit_> or "Jle`, chaired Prof of Monads"
22:13:09 <jle`> that's only going to get you into trouble :)
22:13:18 <jle`> trap_exit_: not helpful >_>
22:13:30 <jle`> i get things embarassingly wrong here as much as i get them right
22:13:42 * theme2 is attempting to process complex data
22:13:48 <mzero> where's mr. Kmett when I need him?
22:14:15 <shachaf> What's the thing you're after?
22:14:38 <monochrom> a partial order in which every downset is totally ordered
22:14:56 <mzero> that!
22:14:58 <mzero> the name of that
22:15:04 <shachaf> Oh, that's from way above, I missed it.
22:15:14 <mzero> and the name of the property that defines it
22:15:18 <monochrom> for example, for all string c, every two prefixes of c are comparable
22:15:24 <trap_exit_> mzero: people on ##math didn't know either
22:15:24 <trap_exit_> mzero: either (1) this structure does not have matheamtical signifinance or (2) you're about ot win next year's fields medal
22:15:26 <mzero> (is "downset" a formal thing?)
22:15:35 <mzero> ROCKING
22:15:42 <mzero> (did you really ask over on #math?)
22:16:03 <shachaf> https://en.wikipedia.org/wiki/Upper_set
22:16:06 <monochrom> downset is a formal thing. I learned it from Davey & Priestley
22:16:25 <monochrom> I don't need ##math to teach me math, really.
22:16:31 <trap_exit_> mzero: yeah, I asked over in ##math
22:16:46 <mzero> hawt
22:17:36 <theme2> I've just realized why exactly I don't understand monad transformers
22:18:06 <theme2> It's because I treat IO as a special case, and monad transformer examples tend to use IO
22:18:38 <monochrom> StateT Int (Cont r a) is more fun, yes
22:18:48 <theme2> ???
22:18:59 <monochrom> a monad transformer example that doesn't use IO
22:19:10 <theme2> ok...
22:19:15 * theme2 looks up Cont
22:19:23 <jle`> heh
22:19:29 <monochrom> Cont wrecks your mind more than IO does
22:19:39 <jle`> :k StateT
22:19:41 <lambdabot> * -> (* -> *) -> * -> *
22:19:42 <shachaf> Codensity!
22:19:43 <jle`> :t Cont
22:19:44 <lambdabot>     Not in scope: data constructor ‚ÄòCont‚Äô
22:19:44 <lambdabot>     Perhaps you meant one of these:
22:19:44 <lambdabot>       ‚ÄòConst‚Äô (imported from Control.Lens),
22:20:11 <theme2> whoops
22:20:16 <jle`> do you mean StateT Int (Cont r) ?
22:20:23 <monochrom> oh!
22:20:32 <monochrom> StateT Int (Cont r) a
22:21:07 <jle`> theme2: i liked that 'monad transformers step by step' article...that's the one that eventually helped me understand transformers
22:21:10 <monochrom> thank you for your kind check. (pun!)
22:21:34 <theme2> lol
22:21:37 <jle`> and it has useful examples of monad transformers that don't involve IO
22:21:55 <theme2> jle`: thanks
22:22:24 <jle`> @google monad transformers step by step
22:22:26 <lambdabot> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
22:22:26 <lambdabot> Title: Monad Transformers Step by Step
22:22:31 <jle`> i think that's the one
22:22:53 <theme2> I/O is usually the easiest thing in most languages, but not haskell
22:23:07 <shachaf> mzero: http://mathforum.org/kb/message.jspa?messageID=3982983
22:23:08 <jle`> there are some slight API changes to the current monad transformer libraries, but you should be able to catch them
22:23:24 <monochrom> I had an analogy between monad transformer and T-bone steak
22:23:24 <shachaf> https://en.wikipedia.org/wiki/Tree_(set_theory)
22:23:34 <jle`> theme2: i actually have found IO a lot more easy/fun to work with in haskell than in other languages
22:23:53 <jle`> i think it just requires a slight readjustment of thought
22:23:57 <theme2> jle`: for me, something easy is not fun
22:24:00 <mzero> hmmm.. yes, though mine are actually FORESTS, not TREEs as there could be disjoint roots
22:24:09 <jle`> can something be both easy and fun? :)
22:24:22 <jle`> (the post that i linked to earlier makes a case for this)
22:24:30 <theme2> I better stop chatting now
22:24:38 <theme2> So I can read that paper
22:24:44 <mzero> wow - shachaf - that is exactly the question I'm asking - you are an amazing search engine!
22:24:49 <monochrom> yikes, I did not think of trees. and to think that I just taught a data structure course full of trees.
22:25:07 <shachaf> mzero: Thank monochrom.
22:25:13 <jle`> theme2: good plan :)
22:25:18 <shachaf> https://encrypted.google.com/search?q=%22downset+is+totally+ordered%22
22:25:41 <mzero> Indeed - what I'm trying to do is write optimizers that abstract over the class of values that can be arranged in trees
22:25:50 <monochrom> but yes, I take credit for coming up with good search keywords :)
22:26:12 <shachaf> I still don't know what mzero's original question was.
22:26:31 <shachaf> But if it's answered then maybe there's no reason to read up that far.
22:27:40 <mzero> my question was what is the mathematical name for a partial order with this additional property (and also the name of the property)
22:29:13 <theme2> erm excuse me, what is Map?
22:29:43 <glguy> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map-Lazy.html
22:29:55 <jle`> theme2: Map from the containers package is a key-value store
22:30:24 <theme2> Is Map related to map?
22:30:35 <jle`> it's implemented with a binary search tree, so its keys must be comparable/Ord
22:30:38 <shachaf> No.
22:30:41 <jle`> theme2: nope
22:30:52 <theme2> -_-
22:30:55 <theme2> bad name
22:31:27 <theme2> One thing I hate about haskell is misleading names
22:31:59 <mzero> ah yes... one of the seven stages of Haskell acceptance.... the "can't rename this mess" stage!  :-)
22:32:07 <splintax> there really needs to be a concise, unambiguous name for a Map
22:32:21 <copumpkin> theme2: it's a pretty common name for that structure
22:32:27 <shachaf> And for that operation.
22:32:30 <copumpkin> theme2: what would you call it?
22:32:34 <splintax> associative array is too long, hash is ambiguous and implies implementation details...
22:32:35 <theme2> The Functor class got me confused for quite a while back then.
22:32:41 <theme2> copumpkin: Dictionary
22:32:52 <glguy> damn, we forgot to consult when theme2 to see which names he knew when picking them
22:32:59 <glguy> someone make a ticket
22:33:01 <splintax> i feel like dictionary implies Map String a
22:33:07 <theme2> -_-
22:33:07 <jle`> Dict isn't too bad, i don't think
22:33:10 <splintax> it's better than any of the alternatives i just gave though
22:33:24 <jle`> it's used in other situations w/out string keys
22:33:39 <shachaf> I,I Function
22:33:50 <jle`> type Map = (->)
22:34:01 <shachaf> ReifiedPartialFunction
22:34:07 <jle`> type Array = (->) Int
22:34:17 <splintax> what are all the definitions of map?
22:34:24 <glguy> shachaf: reified like the beans?
22:34:32 <splintax> function application over a functor, associative array, topological chart?
22:34:33 <splintax> navigation chart
22:34:40 * shachaf reflects on reified beans.
22:34:43 <tac> jle`: some very useful functions indeed
22:34:54 <tac> s/functions/types
22:34:55 <splintax> also just a function
22:34:57 <jle`> splintax: surely there is some sort of book or compilation out there that collects words and lists all of their associated meanings
22:35:04 <splintax> ahaha
22:35:21 <monochrom> the precise name for Map is Ordered Dictionary
22:35:22 <tac> jle`: don't forget multisets! type Multiset a = (->) a Int
22:35:58 <splintax> monochrom: for me "map" (in the data structure context) strongly implies that the keys are _not_ ordered :/
22:36:19 <monochrom> however, Data.Map.Map is
22:36:40 <jle`> OKVS, ordered key-value store
22:37:12 <shachaf> conal prefers Maps without ordering. Or partiality. Or traversing.
22:37:18 <monochrom> to a large extent, you must make an assumption about the keys to get a computable dictionary
22:38:00 <monochrom> if the keys are not hashable, you cannot use the hashing approach
22:38:23 <monochrom> if the keys are not totally ordered, you cannot use any search tree approaches
22:38:48 <monochrom> in the limit, if the keys do not have computable equality test, you cannot even have a computable dictionary
22:38:51 <jle`> i can't imagine a workable dictionary without at least Eq
22:39:21 <tac> Does Haskell have a standard Hash typeclass?
22:39:22 <jle`> i am thinking about it though
22:39:37 <jle`> tac: well there's the one from HashMap, but i'm not sure if that fits your description
22:39:58 <monochrom> kind of standard: unordered-containers has one
22:40:00 <glguy> This is the one I typically see in use : http://hackage.haskell.org/package/hashable-1.2.2.0/docs/Data-Hashable.html#t:Hashable
22:40:08 <tac> Thanks
22:40:09 <glguy> unordered-containers uses the one from hashable
22:40:31 <monochrom> yeah
22:40:39 <shachaf> There ought to be a package called hashtable that uses the hash from hashable.
22:40:55 <tac> wtf. you can seriously set fixity for `varname` style operators >___>
22:41:21 <monochrom> yes, it is important for `mod` and `elem`
22:41:29 <glguy> > (2 * 3 `div` 4 , 2 + 3 `div` 4)
22:41:31 <lambdabot>  (1,2)
22:41:38 <monochrom> hell, even `sepBy` in parser libs
22:44:36 <shachaf> `elem`, `notElem`, `quot`, `rem`, `div`, `mod`, `par`, `pseq`, `on`, `shift`, `rotate`, `shiftL`, `shiftR`, `rotateL`, `rotateR`, `xor`
22:44:38 <glguy> > 1 `elem` [2] ++ [3]
22:44:40 <lambdabot>  False
22:45:16 <mzero> not to mention `fmap`
22:45:25 <mzero> (though I now prefer  <$>  )
22:45:25 <glguy> what about `fmap`?
22:45:37 <jle`> is `fmap` defined to be the same as (<$>) ?
22:45:38 <shachaf> `fmap` doesn't have infixity defined in base, as far as I can tell.
22:45:48 <mzero> other way 'round
22:45:53 <mzero> @src (<$>)
22:45:53 <lambdabot> f <$> a = fmap f a
22:45:59 <jle`> i meant, the fixity
22:46:21 <jle`> hm, apparently not
22:46:28 <davean> tac: I'd warn you off Data.Hashable, the instances it has are pretty bad as far as hashes go
22:46:30 <jle`> thank you ghci
22:46:32 <glguy> mzero: The topic is `infix` operators having fixities
22:46:37 <shachaf> That should probably be eta-reduced.
22:46:41 <mzero> aha
22:46:46 <shachaf> What if I write (f <$>) and it doesn't inline?!
22:47:04 <davean> tac:
22:47:06 <davean> instance Hashable Int where
22:47:09 <davean>     hash = id
22:47:09 <glguy> I give up, what?
22:47:18 <tac> davean: very great
22:47:45 <davean> tac: isn't it though?
22:48:00 <mzero> ? what's the problem with that? pretty sure most languages do that
22:48:04 <jle`> is "slightly different input produces very different output" a part of the requirements for the so-called "perfect hash"?
22:48:24 <davean> mzero: it fails almost all the requirements for a good hash
22:48:34 <jle`> or is it only determinism and no collisions
22:48:40 <davean> and simply won't work for many applications of a hash
22:49:12 <davean> jle`: a perfect hash is something entirely different
22:49:33 <mzero> well.... it is perhaps arguable that the there are pretty wide range of hash uses, with different needs, and the tradeoffs for cryptographic good hashes, vs. those good enough to implement a hash table are great enough to warrant having different ones
22:49:37 <tac> davean: in Python, I think hash(i) = i for small i
22:49:40 <monochrom> ok, what would you have Hashable Int do, and why is it better?
22:49:41 <mzero> hash = id for Int is good enough for a hash table
22:50:03 <davean> mzero: Only some uses of a hash table really
22:50:11 <davean> And only some hash tables
22:50:16 <jle`> how about instance Hashable Int where hash = (*) <*> (bool (-1) 1 . even)
22:50:22 <davean> mzero: I think, for example, a growable hash table fails with that hash
22:50:54 <mzero> a growable hash table should be doing one final 'round of mixing one the hash of the values
22:50:58 <glguy> jle`: Obfuscating the hash implementation doesn't make it a better hash
22:51:08 <jle`> it was a joke hash, heh
22:51:27 <jle`> @let inthash = (*) <*> (bool (-1) 1 . even)
22:51:29 <lambdabot>  Defined.
22:51:32 <jle`> > map inthash [1..10]
22:51:34 <lambdabot>  [-1,2,-3,4,-5,6,-7,8,-9,10]
22:51:35 <mzero> in fact - it is almost always better to implement fast cheap hash on all data types - and then re-hash that with a hash functions that meets the properties of the application --- than to replicate that work out in all the types
22:51:40 <monochrom> are you confusing the independent-of-table-size part of the hash function with the tailored-for-table-size part called compression map?
22:52:38 <shachaf> mzero: Hashing with a good hash may be too late if you've already hashed with a bad one. :-)
22:52:50 <shachaf> (Unless it's injective like id, or something, I guess.)
22:53:22 <mzero> night all
22:54:29 <davean> shachaf: Well yah :) it seems pretty hard to recover independence ;)
22:58:14 * hackagebot blacktip 0.1.0.0 - Decentralized, k-ordered unique ID generator.  http://hackage.haskell.org/package/blacktip-0.1.0.0 (bitemyapp)
22:58:14 * hackagebot hspec-meta 1.11.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.4 (SimonHengel)
23:03:09 * hackagebot hspec 1.11.4 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.11.4 (SimonHengel)
23:13:10 * hackagebot hspec2 0.4.2 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.4.2 (SimonHengel)
23:22:54 <theme2> what in the world is that quit message?
23:23:02 <theme2> "(Quit: computer exploded) "
23:23:06 <MP2E> haha
23:23:20 <MP2E> no doubt a humorous custom quit message
23:23:31 <MP2E> if you type '/quit blah' blah will be your quit message, for instance
23:30:00 <marchelzo_> How can I derive from a typeclass but then make one special case for a function? Like I want to derive from Eq but modify the (==) function in one case only
23:31:02 <adas> marchelzo_: make the type an instance of Eq and redefine (==)
23:31:27 <marchelzo_> adas: oh I did't know it was that simple. ok!
23:31:32 <marchelzo_> thanks
23:33:10 <theme2> Excuse me, what does this class header mean?
23:33:17 <theme2> class Monad m => MonadState s m | m -> s where
23:34:57 <theme2> hello???
23:37:01 <Enigmagic> theme2: it's a functional dependency
23:37:19 <MP2E> theme2: It means for every given m there is precisely one s that is possible
23:37:32 <theme2> ???
23:38:28 * theme2 is confused
23:38:38 <drbean> I didn't indent my definition of (==) in my instance of Eq declaration, and lookup on my type wouldn't terminate.
23:39:49 <theme2> erm...
23:40:00 <theme2> So what exactly does "class Monad m => MonadState s m | m -> s where" mean?
23:40:26 <theme2> Why is "so" highlighted?
23:40:31 <theme2> test so
23:40:46 <MP2E> It defines a typeclass, called MonadState that takes 2 arguments, s and m. m must be an instance of the Monad typeclass. Also, if you are given m, you can figure out what s is by the type of m
23:40:58 <tac> In parsec, if char ' ' fails, does it consume the space?
23:42:47 <theme2> MP2E: so "MonadState A M" and "MonadState B M" would generate an error, right?
23:44:06 <MP2E> Actually no, because in that case the inputs still only have one output each, though their output happens to be shared. 'instance MonadState A Int where ...' then 'instance MonadState A String where...' would cause a type error, though
23:44:11 <geekosaur> tac: no. but anything else it had consumed up to that point remains consumed, hence "try" to "unwind" the token stream back to a retry point
23:44:20 <tac> thanks
23:44:39 <geekosaur> tac: for example char ' ' >> char 's' will leave ' ' consumed if the char 's' fails
23:44:44 <MP2E> because then we're asking it to produce 2 different s for one given m
23:44:46 <theme2> MP2E: Is something reversed there?
23:44:56 <tac> geekosaur: thanks. Yeah. I am rusty on this stuff :)
23:44:59 <MP2E> oh whoops
23:45:04 <MP2E> theme2: you're right, I reversed the arguments
23:45:05 <MP2E> :P
23:45:10 <MP2E> so yes
23:45:12 <MP2E> you were right
23:45:41 <theme2> Ok... haskell always use "type magic"
23:45:59 <trap_exit> does haskell support something like "#include" ? so I have "header" and "impl" ; impl needs to include header; but I want header to pull in dems from impl too
23:46:07 <trap_exit> but I don't want circular imports
23:46:09 <shachaf> No. That completely doesn't follow from what anyone said.
23:46:17 <trap_exit> so I'd prefer "header" to be able to just "#include <impl...>"
23:46:29 <trap_exit> does haskell allow this? for me to just "include in place" rather than import
23:46:32 <marchelzo_> geekosaur: So if I want to parse 0 or 1 semicolons and then something else, it is char ';' >> parseSomethingElse?
23:50:25 <Arunabha> Hi, the expression func = foldr step [] . lines seems to work in ghci, but doesn't function application have the highest precedence ? if so why is the '.' (dot) not considered a parameter to foldr ?
23:51:22 <theme2> Arunabha: it will if you make it "func = foldr step [] (.)"
23:51:24 <theme2> probably
23:52:10 <theme2> :t foldr step []
23:52:12 <lambdabot>     Not in scope: ‚Äòstep‚Äô
23:52:12 <lambdabot>     Perhaps you meant ‚Äòsep‚Äô (imported from Text.PrettyPrint.HughesPJ)
23:52:19 <theme2> whoops
23:52:43 <Arunabha> theme2: No, step is a function defined elsewhere
23:52:45 <theme2> "folr step []
23:53:04 <theme2> "foldr step []" is not a function, so it cannot be applied to a parameter
23:53:12 <theme2> assuming that you aren't doing something strange
23:53:28 <benzrf> theme2: foldr step [] is absolutely a functoin
23:53:38 <benzrf> u may be thinking of foldr1
23:53:48 <theme2> ah right
23:53:50 <Arunabha> foldr takes 3 args and here we're only passing 2, so wouldn't the '.' be considered the third param ?
23:53:58 <benzrf> Arunabha: no
23:54:04 <benzrf> `foldr step []' is the argument to .
23:54:10 <theme2> If that func doesn't work, then plain old " f . g " wouldn't work
23:54:24 <Arunabha> so . has a higher precedence than function application ?
23:54:28 <benzrf> Arunabha: no...
23:54:30 <benzrf> it has lower precedence
23:54:42 * theme2 starts to confuse himself
23:54:48 <benzrf> therefore,
23:54:58 <benzrf> foldr step [] . lines
23:54:59 <benzrf> is really
23:55:05 <benzrf> (foldr step []) . (lines)
23:55:09 <benzrf> that's how precedence *works*
23:55:31 <benzrf> * has higher prec than +, so `3 * 4 + 2' is `(3 * 4) + 2'
23:56:01 <Arunabha> benzrf: I think that only holds if *all* the parameters to the operator are supplied
23:56:12 <benzrf> Arunabha: i dont think you know about currying
23:56:20 <benzrf> Arunabha: anyway
23:56:29 <benzrf> that would imply that parsing depends on knowing the arity of functions
23:56:33 <benzrf> which is some perl-level shit
23:56:45 <benzrf> i think we prefer our parsing decidable!
23:57:11 * theme2 detects profanity
23:57:48 <theme2> Arunabha: "foldr step" returns a function
23:57:48 <benzrf> Arunabha: anyway, there's no such thing as "all the parameters"
23:57:58 <benzrf> Arunabha: all functions in haskell take exactly 1 argument
23:57:58 <theme2> say, "f=foldr step"
23:58:08 <benzrf> i know i sound like a pedantic dick, but it's important to learn to think that way
23:58:13 <theme2> "f []" is again a function
23:58:14 <Arunabha> benzrf: so... foldr step [] filter id [1,2] shoukd work ?
23:58:16 * hackagebot egison 3.3.11 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.11 (SatoshiEgi)
23:58:21 <theme2> say, "g = f []"
23:58:23 <benzrf> Arunabha: you'd get a type error
23:58:44 <theme2> "g x" is finally a value
23:59:02 <Arunabha> hmm I'm missing something then, so why is the filter considered a param whereas . is not
23:59:11 <theme2> so "foldr step [] x" is really "((foldr step) [] ) x"
23:59:16 <benzrf> Arunabha: because (.) is an operator
23:59:21 <benzrf> and it has lower prec
