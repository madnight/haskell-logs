00:00:09 <shachaf> Wait, for what?
00:00:18 <haasn> GeneralizedNewtypeDeriving?
00:00:32 <haasn> I think that would just end up full of unsafeCoerce / safeCoerce
00:00:42 <glguy> There are types that GND excludes and multi param tc cases for starters that it can't generate
00:01:28 <haasn> latk: If you search on stackoverflow a bit there's some post about which extensions are considered “safe” or “harmless” - those are probably a good place to start
00:01:40 <haasn> There's also at least a post or two about extensions considered “controversial” or “dangerous”
00:01:51 <shachaf> Oh, so you can.
00:01:55 <glguy> GND was unsound because it didn't attempt to write the instances beyond casting afaik
00:01:58 <latk> haasn: Ok, thanks!
00:02:03 <haasn> But for a full list, the GHC user's manual is comprehensive
00:02:20 <shachaf> instance Num T where (+) = coerce ((+) :: Int -> Int -> Int) :: T -> T -> T
00:02:20 <bb010g> haasn: -ddump-deriv
00:02:22 <shachaf> good instance
00:02:38 <shachaf> glguy: I don't think GND is actually unsound in plain Haskell, only combined with other GHC extensions.
00:03:08 <glguy> That matches my understanding
00:03:13 <haasn> I'm not sure if this is correct; but I know that some of these “GHC extensions” include popular ones
00:03:24 <shachaf> Yes, like GADTs.
00:03:25 <haasn> I think you can do it with just GADTs
00:03:33 <shachaf> Or TypeFamilies.
00:03:40 <shachaf> GADT-style type equality is enough.
00:03:48 <shachaf> (But RankNTypes-style Leibniz equality isn't!)
00:04:12 <haasn> http://joyoftypes.blogspot.de/2012/08/generalizednewtypederiving-is.html is definitely of interest
00:04:33 <shachaf> The author thinks that it's possible with RankNTypes, but I think it isn't.
00:04:40 <trap_exit> without using Show + pack, how do I convert "Int -> Text" ? Hoogle is nearly useless http://www.haskell.org/hoogle/?hoogle=Int+-%3E+Text
00:04:57 <trap_exit> one would think there's a trivial Int -> LazyText conversion
00:05:00 <trap_exit> ... but, no!
00:05:59 <haasn> At least now it's solely of academic interest since I believed type roles eliminate this particular issue completely
00:06:34 <haasn> Is “show.pack” not trivial enough?
00:06:38 <haasn> Err, pack.show
00:07:24 <glguy> The text package has a module for converting numbers into and out of text
00:07:29 <Iceland_jack> trap_exit: One way is to use ‘formatting’ which is slightly overkill
00:07:39 <trap_exit> format "{}
00:07:47 <trap_exit> foramt "{}" $ Format.Only int
00:07:49 <shachaf> I'd be interested if someone could write a total function :: (forall p. p A -> p B) -> Void for concrete types A and B, though.
00:07:50 <trap_exit> is what i'm currently using
00:08:07 <Iceland_jack> trap_exit: that's a different package
00:08:17 <trap_exit> Iceland_jack: oh what do you have in mind?
00:08:26 <Iceland_jack> The package ‘formatting’
00:08:26 <Iceland_jack> ghci> import Formatting
00:08:27 <Iceland_jack> ghci> format int 5
00:08:27 <Iceland_jack> "5"
00:08:31 <Iceland_jack> ghci> :t format int 5
00:08:34 <Iceland_jack> format int 5 :: Data.Text.Internal.Lazy.Text
00:08:40 <Iceland_jack> @hackage formatting
00:08:41 <lambdabot> http://hackage.haskell.org/package/formatting
00:08:43 * hackagebot casadi-bindings-core 2.0.0 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-2.0.0 (GregHorn)
00:08:43 * hackagebot casadi-bindings 2.0.0 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.0.0 (GregHorn)
00:09:22 <glguy> Number printing and parsing stuff is in the text package itself
00:10:39 <haasn> shachaf: Am I allowed to pick A = (), B = Void?
00:11:00 <shachaf> That sounds OK.
00:11:24 <haasn> f g = runIdentity (g (Identity ()))
00:11:25 <shachaf> By the way, by "total" I mean in a way that GHC is aware of.
00:11:29 <haasn> Oh
00:11:31 <haasn> You mean total
00:11:42 <haasn> Wait, how can that function be total?
00:12:22 <shachaf> OK, A and B can't be Void.
00:12:43 <shachaf> That makes it too easy.
00:13:00 <shachaf> They have to have at least one inhabitant.
00:13:08 <haasn> Okay. IO () and ()
00:13:21 <shachaf> OK, how do you do it?
00:15:51 <haasn> Hmm, I'm not sure if it's possible with just (). But that still pretty much gives you unsafePerformIO, right? So you could pretty much destroy the universe; and do nasty things making a (forall a b. a -> b) using polymorphic IORefs
00:16:03 <shachaf> Why?
00:17:39 <trap_exit> hmm, haskell precedence table is opposite of C precedenca table right?
00:17:46 <haasn> Oh, wait, the caller is allowed to abuse the fact that B has inhabitants
00:17:48 <trap_exit> http://www.haskell.org/onlinereport/decls.html apears to show that precedence = higher = bindgs more tighetr in haskell
00:17:54 <haasn> Hmm
00:18:51 <shachaf> The idea is, if A and B are different (concrete) types then it shouldn't be possible to write a function :: forall p. p A -> p B
00:19:04 <shachaf> So demonstrate that to the type checker.
00:25:15 <haasn> Are A and B allowed to have kinds other than *?
00:26:40 <shachaf> What if I say yes?
00:27:06 <shachaf> But you can't use TypeFamilies or GADTs.
00:27:26 <shachaf> (For roughly the same reason that you can't use them with GeneralizedNewtypeDeriving. They make this too easy.)
00:27:35 <haasn> A = Const; B = Tagged;  f g = runTagged (g (Foo (Const ()))) where data Foo f = Foo (f () Void)
00:28:21 <haasn> oh, runFoo too
00:28:35 <shachaf> Clever.
00:28:55 <shachaf> But since I said A and B have to be inhabited, I think it rules out kinds other than *. :-)
00:33:24 <haasn> Hmm, you can also do it if A is allowed to be Void (even if B isn't), but that's not allowed
00:34:18 <shachaf> Sure, it's easy to write (forall p. p a -> p b) -> (forall p. p b -> p a)
00:36:09 <haasn> There might be a way to prove that writing this function is not possible; by considering all possible data types ‘p’ you could insert (as some combination of sums, pairs and arrows)
00:36:21 <haasn> I'm out of ideas at any rate
00:37:08 <shachaf> Well, it's easy with GADTs.
00:37:23 <haasn> Yes, or TFs and the others
00:37:46 <shachaf> I believe that it isn't possible without but I don't know exactly how to phrase what it is that isn't possible (what's the extra power gadts give you over leibniz equality?).
00:38:04 <haasn> I'm not familiar with the term leibniz equality
00:38:21 <shachaf> In this context it means newtype Is a b = Is (forall p. p a -> p b)
00:38:46 <shachaf> The only inhabitant is id, so it gives you a way of talking about type equality.
00:38:58 <haasn> Ah, like Refl :: Is a a
00:39:23 <shachaf> Right.
00:39:34 <shachaf> This is also how Equality from lens works.
00:41:43 <haasn> Oh, this thing is producing unsafeCoerce using only GND, isn't it? https://ghc.haskell.org/trac/ghc/ticket/1496
00:41:46 <haasn> Oh
00:41:57 <haasn> Never mind, I completely missed the line that said data family Z
00:42:34 <shachaf> Anyway, what GeneralizedNewtypeDeriving gives you is more or less type equality between something and its newtype.
00:42:40 <shachaf> (Implemented with unsafeCoerce.)
00:49:07 <haasn> You're trying to prove that (forall p. p A -> p B) can't exist if A and B are different, right?
00:49:41 <shachaf> In Haskell2010+RankNTypes, yes. Something like that.
00:50:01 <shachaf> (Note that this is incompatible with univalence. Or so I understand.)
00:50:17 <haasn> Oh, right; so one counter-example is indeed enough to show it false. I just confused myself for a bit
00:51:17 <sshine> if I want (\id -> (id 'a', id 3)) (\x -> x) to type-check, can I use rank-2 types? (trying to compare the expressivity of lambda calculus with let-expressions to other things...)
00:51:27 <haasn> sshine: yes
00:51:38 <haasn> But you have to give an explicit type annotation
00:51:42 <haasn> GHC can't infer rank-2 types
00:52:00 <sshine> because rank-n type inference is undecidable, right?
00:52:11 <sshine> I wonder about rank-2.
00:52:34 <haasn> Rank-N is not decidable in general. Rank-2 is decidable, but GHC will probably never have an algorithm with it - it's complex and clashes with other Haskell type features
00:52:52 <opqdonut> http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
00:53:00 <sshine> opqdonut, I *just* found it! but thanks :D
00:53:20 <sshine> haasn, okay.
01:08:38 <slack1256> http://www.haskellforall.com/2012/09/the-functor-design-pattern.html
01:08:53 <slack1256> Is there an analogous Monad design pattern on some blog post?
01:09:51 <splintax> i've created a newtype Branch, which is a Tree that has only leaves (ie. depth 1). i'm using newtype so that i can make sure functions that take Branches are never called on Trees in general. but if i have a Branch and i want to use a function that takes a Tree, how do i convert back?
01:10:51 <shachaf> I don't follow.
01:11:15 <lfairy> slack1256: take a look at mmorph
01:11:44 <slack1256> mmorph is the functor design patter described on that post. It is described at the end of the article :-)
01:12:21 <slack1256> shachaf: Do you mean me or splintax?
01:12:37 <shachaf> I mean splintax.
01:17:21 <slack1256> splintax: your newtype Branch is just interested on leaves right?. So is either a (Leaf a) or (Nil). Is that like (Maybe)?
01:19:04 <slack1256> Or you are insterested in traversing the Tree and be located on the context of the leaves? If is that you Can use a Zipper to position yourself on the leaves of the tree.
01:23:24 <splintax> hmm, yeah, my Branch should actually be a [Leaf] (although it can also be seen as a Tree). thanks slack1256
01:25:00 <slack1256> If you are gonna be manipulating the Leafs and you want to go back to using a Tree I would argue for the Zipper. It will save you frustrations.
01:25:03 <slack1256> :-)
01:28:48 * hackagebot persistent 1.3.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.2 (MichaelSnoyman)
01:32:40 <zereraz> hello, I wanted to know is there something like index in lists, like we have in arrays
01:32:48 <zereraz> like list[1]
01:32:48 <sshine> :t (!!)
01:32:49 <lambdabot> [a] -> Int -> a
01:32:51 <zereraz> oh
01:32:56 <zereraz> i forgot, thanks
01:33:19 <sshine> zereraz, unlike array lookups, (!!) is O(n).
01:33:38 <zereraz> sshine: what is O of array lookups
01:33:48 * hackagebot persistent 1.3.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.3 (MichaelSnoyman)
01:33:58 <sshine> zereraz, O(1) for arrays that fit in memory.
01:34:48 <sshine> zereraz, lists in Haskell are linked lists, so to get to the nth element, you have to traverse n-1 chained elements. it's often not a problem.
01:35:15 <sshine> zereraz, in fact, when used right, these immutable linked lists have other benefits.
01:35:53 <mmmm> What does makeRelative do in System.FilePath?
01:37:00 <sshine> mmmm, did you look at the documentation? :) http://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath-Windows.html#v:makeRelative
01:37:23 <solatis> interesting. are there any good implementations of things like a skiplist in haskell?
01:37:32 <zereraz> sshine: how are these immutable?
01:38:03 <zereraz> sshine: and its O(1) because we go directly to the memory location right?
01:38:35 <mmmm> Yes..
01:38:35 <mmmm> It doesn't even say what the arguments are meant to be
01:38:48 * hackagebot http2 0.5.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.5.0 (KazuYamamoto)
01:41:39 <zereraz> If I am new to haskell and I want to use http://hackage.haskell.org/package/OpenGLRaw opengl and practice haskell(as I am going to learn opengl in college) is this a good idea, or should I wait and learn more.
01:43:21 <sshine> zereraz, yup
01:43:38 <Th30n> zereraz: I suggest OpenGL package instead of RAW, along with that I recommend one of the books on opengl, like OpenGL Superbible latest edition
01:44:12 <zereraz> Th30n: I am learning open gl with c++ so won't it be raw, and won't I be able to relate with it better
01:44:36 <zereraz> going to learn*
01:44:55 <Th30n> zereraz: OpenGL isn't that much different from RAW calls, it's just type safer and you won't have stupid bugs.
01:45:06 <sshine> mmmm, as I understand it, it takes two absolute paths, treats one as a prefix and tries to remove this prefix from the other in a safe way.
01:45:58 <zereraz> Th30n: oh ok great
01:46:06 <Th30n> zereraz: The "problem" with using Raw bindings is that you than have to learn a lot more Haskell's FFI
01:46:17 <zereraz> Th30n: FFI?
01:46:46 <Th30n> zereraz: foreign function interface, you will have to work with haskell's pointers and translations to C
01:47:12 <zereraz> Th30n: also which opengl package?
01:47:20 <zereraz> which one here http://www.haskell.org/haskellwiki/OpenGL
01:47:22 <Th30n> zereraz: I mean it's not hard, but if you are learning both Haskell and OpenGL at the same time, then it is a bit unecessary to stretch yourself
01:47:36 <Th30n> zereraz: http://hackage.haskell.org/package/OpenGL
01:47:36 <zereraz> Th30n: yeah I agree
01:47:51 <zereraz> I download it with cabal?
01:48:09 <Th30n> zereraz: yes, but I would recommend to read up about cabal and cabal sandbox
01:48:18 <zereraz> Th30n:  and any decent tutorials?
01:48:30 <Th30n> zereraz: just a sec
01:48:35 <zereraz> Th30n: ok I will look them up
01:48:38 <zereraz> sure
01:49:07 <Th30n> zereraz: this has section on cabal, and overall good sections on almost anything: http://dev.stephendiehl.com/hask/
01:49:27 <zereraz> Th30n: thanks allot!
01:49:38 <zereraz> sshine: thanks
01:52:25 <Th30n> zereraz: this touches on various parts of managing a project: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:53:23 <zereraz> Th30n: that looks like a great link
01:53:40 <Th30n> zereraz: and I'm trying to find that tutorial of setting up a build with cabal
01:57:14 <Th30n> zereraz: ah, here it is: www.haskell.org/cabal/users-guide/developing-packages.html (quickstart should be enough for starting)
01:58:25 <zereraz> Th30n: ok thanks, http://www.haskell.org/haskellwiki/OpenGLTutorial1 in this they used import Graphics.UI.GLUT , is that opengl
01:58:48 <Th30n> zereraz: no, ok first things first, OpenGL is just a 3D graphics API
01:59:15 <Th30n> zereraz: you will need also an API that interfaces with window system of your OS, GLUT (or better, freeGLUT) is one such API
01:59:40 <Th30n> Th30n: personally i'm using SDL2, but SDL2 also has API for various image handling, audio, inputs etc.
02:00:16 <Th30n> zereraz: freeGLUT is used in many tutorials, but I don't know how are the bindings in Haskell (I used it only with C++)
02:00:43 <zereraz> Th30n: ok, thanks. I'll start learning all this soon.
02:01:13 <Th30n> zereraz: I think GTK has much better developed bindings for Haskell, so you might want to check that
02:01:16 <arossouw> is it a good idea to build desktop gui apps with haskell?
02:01:24 <Th30n> arossouw: I don't see why not
02:01:32 <arossouw> for a businness app :-)
02:01:45 <Th30n> arossouw: Apparently FRP is really well suited for GUI apps
02:02:03 <arossouw> ok, i was wondering about gtk2hs
02:03:05 <Th30n> arossouw: I haven't worked with Gtk, but it's the goto API on linux in any language
02:03:06 <arossouw> won't build gui apps yet though, still have to learn the haskell language well, before attempting that
02:03:46 <arossouw> never thought i'd be so addicted to haskell, hehe
02:04:10 <Th30n> arossouw: Oh, then maybe FRP confused you, it stand for functional reactive programming, it's just a style, not an API
02:04:29 <arossouw> i see
02:04:55 <Th30n> arossouw: same here, I'm also learning, took a class last semester and got addicted instantly, unfortunately Haskell isn't that much encouraged at my college, Java rules everything :(
02:05:13 <arossouw> :-(, java is uggly in my opinion
02:05:42 <Th30n> arossouw: Well, I'm working mostly with C++ (coz I'm focusing on 3d computer graphics) and C++ is way uglier
02:05:59 <Th30n> arossouw: but unlike Java it offers me much more freedom in the way I structure my code
02:06:03 <arossouw> lol, yes it might take me 5 more years to know c++ well
02:07:06 <Th30n> arossouw: I hope Rust will prove popular in the C++ area beacause it looks like they mixed C and Haskell which I really like :)
02:07:07 <arossouw> dont want to go too much off topic, but i find qt and c++ easier to grasp than visual c++
02:08:16 <arossouw> hmm, taking a look at rust now
02:08:16 <Th30n> arossouw: I wouldn't know, I do all my coding on Linux, so no visual c++
02:08:25 <arossouw> hehe
02:08:45 <hyPiRion> Th30n: I think Rust is more similar to OCaml than Haskell really
02:09:00 <Th30n> hyPiRion: well my only functional language experience is Haskell
02:09:02 <arossouw> it would be cool if someone would make a developer linux distro with haskell and other languages, don't like windows (use it only for games)
02:09:24 <Th30n> hyPiRion: and maybe it wouldn't even be that if there wasn't that one professor at college who supports haskell enthusiastically
02:09:43 <Lowl3v3l> arossouw, which language do you miss in linux?
02:09:56 <arossouw> python
02:09:58 <hyPiRion> Th30n: aha – but yeah, I really like the way Rust is going. I hope they can get the package managing working correctly, and I will use it for performance critical code for about anything
02:10:17 <trap_exit__> i wonder
02:10:25 <Lowl3v3l> arossouw, i have NOT found any linux distribution that doesnt include python :o
02:10:26 <trap_exit__> can we make the world a beter place, by placing odesk / elance requests for people to write haskell modules?
02:10:35 <trap_exit__> the point is not to use the modules, but to increase the number of haskell programmers
02:10:40 <Th30n> arossouw: really, python? I always had a hard time setting up python on Windows and on Linux it comes installed :D
02:10:44 <Lowl3v3l> trap_exit__, +1
02:10:49 <arossouw> ok i misunderstood, i meant miss as in i'm so busy with haskell other languages look boring
02:10:53 <trap_exit__> plus, it's very cheap[
02:10:57 <trap_exit__> since probability of paying out is very small
02:11:56 <Th30n> Anyways, people I'm going off... to Windows :/ I promised a friend to do something with C#... Time to set up vim over there :(
02:12:12 <arossouw> i wonder if the language d has gained some ground
02:12:30 <Lowl3v3l> Th30n, poor guy
02:12:49 <Lowl3v3l> arossouw, well at my university there are D courses so i think at least a little
02:12:58 <arossouw> i see
02:13:41 <vozz> What editors and plugins do you guys use for Haskell?
02:14:02 <Twey> I think I'm confused by Netwire's event system.  Why is it that a wire can both inhibit, *and* pass through a NoEvent?
02:14:10 <arossouw> i think leksah is most popular, i prefer console
02:14:11 <Twey> Isn't it redundant?
02:14:11 <Lowl3v3l> vozz, i use the Eclipse Plugin on the one hand and Leksah on the other
02:14:56 <vozz> Oh wow, I hadn't heard of leksah before
02:16:16 <annelies> I use IntelliJ or Emacs depending on my mood.
02:17:33 <vozz> What king of things do these full blown IDEs do for you that text editors dont?
02:17:54 <annelies> show me the type of the expression I have selected :P
02:18:00 <annelies> No idea on how to set this up in Emacs.
02:18:21 <UnrealQuester> should be trivial to implement in vim/emacs
02:18:33 <Cale> I use mostly vim, but I don't really use many of vim's features, so it really doesn't make much difference vs. something like gedit
02:18:51 <annelies> I'm just used to these editors.
02:19:21 <Cale> If your editor can convert tabs to spaces and can maintain an indentation level on newline, and the syntax colouring works for you, then it'll probably be fine for Haskell.
02:20:09 <vozz> Yeah, I'm already using vim
02:20:18 <vozz> I was wondering if there's anything cool I'm missing out on
02:20:41 <Cale> You're probably not going to spend most of your time on actually inputting the code anyway, so trying to optimise that part of the process is a little bit futile, at least that's how I look at it.
02:21:00 <UnrealQuester> vozz: tried the plugins at http://www.haskell.org/haskellwiki/Vim ?
02:21:11 <companion_cube> some features are not about inputting the code
02:21:16 <companion_cube> but finding which values have the right type
02:21:30 <companion_cube> type-sensitive completion is a huge win imho
02:21:56 <vozz> yeah I've already got a couple plugins
02:22:00 <mr-> companion_cube: is there an editor that does that?
02:22:02 <Cale> It's also hard to do right?
02:22:03 <annelies> I find stuff like "rename" and "extract variable" very useful
02:22:10 <annelies> but I have yet to find a Haskell editor that supports these
02:22:25 <companion_cube> mr-: don't know, but this would be most useful
02:22:36 <companion_cube> also, something to tell you the type of an expression
02:22:52 <vozz> something which checks the type of something... I don't find it that useful because often when I want to know is when I'm halfway through typing something else, and it won't typecheck when the program doesnt compile
02:23:00 <Cale> Type sensitive completion is tricky, because it's hard to know what things will typecheck without having a well-defined hole.
02:23:16 <vozz> and just something with highlighting and indenting and syntax checking
02:23:28 <mr-> companion_cube: ghcmod can do that, sort of, iirc ;-)
02:23:33 <vozz> oh and completion based on name
02:23:38 <mr-> companion_cube: telling the type, I mean
02:24:16 <companion_cube> vozz: it should be able to type something even in many cases where the whole file doesn't compile
02:24:18 <lfairy> vozz: yeah, Haskell type inference goes in out and sideways, so it's hard to figure out the type from a fragment
02:24:25 <companion_cube> I have something like this for OCaml, and it's awesome
02:24:48 <vozz> I'm not very good at interactive development... I think that's something I would like to sort out
02:25:15 <vozz> I generally just have my program and do cabal run, or runhaskell on it if its just a small script
02:25:17 <Cale> One thing which I *would* like to have is that any edit which caused the first non-whitespace character after a layout keyword (do, of, where, let) to move should cause the rest of the block to move analogously.
02:25:19 <arossouw> is it possible that haskell will have something similar to erlang OTP in the future?
02:25:39 <Cale> arossouw: Yes.
02:25:51 <arossouw> great, looking forward to that
02:25:55 <Cale> http://hackage.haskell.org/package/distributed-process-platform
02:25:56 <vozz> how do you go about loading bits into ghci and testing stuff out? What I don't like is typing a load of stuff into ghci and then having to remembmer what I did and retype it into a file
02:26:22 <vozz> I heard emacs was good for that kind of thing, and has better haskell plugins, and was thinking of switching to emacs with evilmode
02:26:28 <Cale> Not sure why the docs didn't build for that
02:27:28 <arossouw> is concurrent programming overkill?
02:28:04 <Cale> arossouw: But yeah, a lot of the design of distributed-process is based on Erlang (or how Erlang people think Erlang ought to behave), and that covers a lot of the lower-level mechanisms supporting distributed programming
02:28:21 <Cale> and this package is an attempt at something OTP-like built on top of it
02:28:28 <arossouw> cool
02:28:37 <Cale> I haven't tried it yet, but it looks cool
02:28:57 <annelies> Does it provide hot code loading?
02:29:05 <annelies> That would be interesting in Haskell.
02:30:02 <annelies> As in, exactly like in Erlang. Running old code still uses the old function implementations.
02:30:25 <Cale> I don't think it attempts anything like that.
02:32:52 <Feuerbach> Simon Marlow did hot code reload for Facebook. I don't know if those changes are now merged back to ghc, or if there's any tooling around that.
02:34:22 <arossouw> is there a method of measurement to determine when you're software could benefit from parallel/concurrent code?
02:35:10 <lfairy> Amdahl's law perhaps?
02:35:23 <lfairy> That's not a method though, more an argument
02:35:39 <lfairy> The criterion library is great for benchmarking
02:35:40 <arossouw> ok, thanks i'll do some reading
02:35:42 <Cale> In general, that's hard. I suppose you can try it and see. Some of Haskell's features for parallelism are pretty easy to just throw in, but typically you might need to adjust your algorithms a bit to expose the parallelism in the first place.
02:35:45 <annelies> The logical negation of whether impahtant business people told you it could
02:36:08 <Cale> http://chimera.labs.oreilly.com/books/1230000000929
02:36:15 <Cale> ^^ might be a book to check out :)
02:36:30 <arossouw> oh, yes busy reading that
02:37:19 <arossouw> i find the STM interesting , seen an example where they simulate bank transactions in haskell
02:37:20 <Cale> ah, it eventually gets up to the Erlang-like distributed stuff, but also covers the more traditional SMP parallelism and concurrency
02:37:43 <Cale> Yeah, STM reduces the level of headaches a great deal
02:38:12 <annelies> Stuff like Datomic is also interesting. Wish it were FOSS.
02:38:17 <Cale> It doesn't completely solve the problems you might have with concurrent programs, but it eliminates a lot of room for bugs.
02:38:32 <arossouw> :-)
02:39:30 <arossouw> sucks to work in an open office, distractions everywhere
02:40:12 <vozz> What exactly _is_ hot code reloading? I've seen this which solves (what i think is) the same problem without actually hot reloading the code https://hackage.haskell.org/package/keter
02:40:49 <augur> is there a good tutorial on creating C libraries anywhere? i need to make some kind of library out of my haskell code that i can call into from C
02:41:20 <augur> and i know how to call through to haskell, but i want it to be pre-compiled and something i can just drop into any C project, even if im not compiling through GHC
02:43:36 <Qfwfq> Is there any consensus on the ideal fixity progression of (<$$>), (<$$$>), &c?
02:44:07 <Cale> Qfwfq: What are those?
02:44:28 <Qfwfq> Cale: Well, as I use them: (<$$>) = fmap . fmap; (<$$$>) = fmap . fmap . fmap.
02:44:46 <Cale> Should probably all be the same as (<$>)
02:44:56 <Cale> Which is infixl 4
02:45:03 <Qfwfq> Thanks! (https://github.com/fmap/functor-infix/blob/master/src/Data/Functor/Infix/TH.hs)
02:48:37 <arossouw> how can i do an or condition on isPrefix of , ie . isPrefixOf "pattern1" or "pattern2" list
02:50:35 <Iceland_jack> :t any
02:50:36 <lambdabot> (a -> Bool) -> [a] -> Bool
02:50:39 <Trollinator> but there is already <**>, which is flip (<*>)
02:50:39 <shachaf> any (`isPrefixOf` list) ["pattern1", "pattern2"]
02:50:58 <arossouw> neat, damn i have so much to learn
02:51:10 <Trollinator> having <$$> be anything other than flip (<$>) would be inconsistent
02:51:41 <arossouw> [x | x <- Char8.lines(s), any (`isPrefixOf` list) ["pattern1", "pattern2"]] ?
02:51:58 <shachaf> Don't use Data.ByteString.Char8. :-( It's evil.
02:52:04 <arossouw> oh why ?
02:52:22 <Trollinator> by the way, I think that if there's a short alias for pure f <*> x, there should also be an alias for f <*> pure x
02:52:22 <shachaf> By evil I mean it breaks on Unicode codepoints outside of ASCII.
02:52:39 <arossouw> oh, which is preferred then?
02:52:48 <shachaf> That depends on what you're doing.
02:52:55 <arossouw> i'm only using text log files
02:53:13 <Trollinator> well, if your Haskell program doesn't break your umlauts, somebody else will.
02:53:37 <shachaf> Yes, but text can be a lot of things.
02:53:46 <arossouw> true
02:53:48 <shachaf> Trollinator: Especially if people go taking advice like that.
02:54:26 <Trollinator> hey, don't blame me for being cynical. Blame the world!
02:54:38 <Lowl3v3l> Trollinator, +1 :D
02:55:09 <arossouw> shachaf: the application i'm writing is basicly a person for email log files
02:55:22 <arossouw> s/person/parser
02:55:41 <shachaf> Emails (even e.g. names in emails) can certainly contain all sorts of Unicode characters.
02:55:44 <Pythonfant> I always go with Text
02:56:15 <arossouw> ok, i'd have to build from scratch then, isn't bytestring faster than Text?
02:56:25 <shachaf> Anyway, Data.Text or a ByteString containing UTF-8-encoded text or or whatever is fine.
02:56:33 <shachaf> You have to figure out what you want to do.
02:56:40 <arossouw> ok
02:56:48 <shachaf> It's not much use if it's faster at doing the wrong thing.
02:57:02 <arossouw> lol, true
02:58:07 <Twey> Trollinator: It's not obvious from the type, but (<**>) is actually not flip (<*>).
02:58:34 <Twey> Trollinator: Try in your local GHCi: flip (<*>) (putStrLn "hi") (const <$> putStrLn "ho"); (<**>) (putStrLn "hi") (const <$> putStrLn "ho")
02:58:47 <arossouw> tutorials at fpcomplete, use Data.attoparsec.char8
02:58:52 <arossouw> for parsers
02:59:18 <ChristianS> arossouw: that'll only for for latin8, not for utf8
02:59:25 <Trollinator> it says “A variant of <*> with the arguments reversed. ” in the docs
02:59:41 <arossouw> ok, i'll read up on differences between utf8 and latin8
03:00:00 <Twey> Trollinator: File a doc bug — that's pretty unclear, at best.
03:00:05 <ChristianS> arossouw: you can check out the utf8-string for dealing with utf8-encoded bytestrings. the api is much more limited than Text, though.
03:00:29 <arossouw> thanks
03:01:21 <arossouw> ChristianS: is Data-ByteString-Lazy-UTF8 ok?
03:02:49 <ChristianS> arossouw: yes if the limited api is sufficient for your purposes. there is no isPrefixOf function, for example.
03:02:59 <arossouw> ok
03:05:26 <osa1> where's cpphs's issue tracker?
03:09:01 * hackagebot scotty-binding-play 1.0 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.0 (YusukeNomura)
03:09:30 <latk> So I've noticed the slowest point in my development is finding the right docs to look at. How do people generally do it?
03:09:44 <coppro> experience
03:09:53 <Pythonfant> hoogle/hayoo
03:10:02 <arossouw> ok, so i'll go for Data.Text
03:10:13 <Twey> latk: haskell-doc-mode
03:10:22 <latk> Twey: Oh? Whats that ?
03:10:35 <Twey> latk: emacs mode for jumping to relevant documentation for Haskell function under point
03:11:19 <latk> Twey: That sounds incredible.
03:12:27 <Twey> Actually, that might just be part of haskell-mode
03:13:22 <arossouw> whats the collective names for these , <*> <$> .etc?
03:13:40 <mmmm> functions?
03:13:46 <Cale> Applicative operations?
03:13:53 <Cale> I dunno :)
03:13:53 <arossouw> ok
03:13:59 <Twey> Operators?
03:14:09 <arossouw> just want documentation for brief explanation
03:14:23 <Twey> arossouw: Look up ‘applicative’
03:14:27 <arossouw> ok, thanks
03:20:23 <tibell> Anyone heard about a "tupling transform" optimization and have a paper/article reference?
03:24:09 <Twey> tibell: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.652 http://link.springer.com/chapter/10.1007%2F3-540-16470-7_11 http://dl.acm.org/citation.cfm?id=1227249
03:24:10 <Twey> http://books.google.co.uk/books?id=lqiO25_qIRMC&pg=PA472&lpg=PA472&dq=tupling+transformation&source=bl&ots=aMV9lMjwPs&sig=T1HsiPsm453QgVhL2e6qBMsgFsU&hl=en&sa=X&ei=5q_gU-bvH7Cp7AbjnIHADQ&ved=0CDwQ6AEwAw#v=onepage&q=tupling%20transformation&f=false
03:26:26 <trap_exit> is there any good haskell libraries for sound synthesis? something to output *.wav files that I can play back in the browser. I'm looking for really simple things, like biiiiing, boooooong, piiiiiiing, poooooooong, just very basic sound effects
03:26:41 <trap_exit> things that most video games do when you (1) press a button or (2) unlock some achievement
03:27:33 <slack1256> tidal were cool back then for making music programatically. I should export to some format
03:28:23 <slack1256> trap_exit: check out https://www.youtube.com/watch?v=vgS2NmlVtjk
03:29:24 <trap_exit> slack1256: that suffices for my needs
03:29:41 <trap_exit> wtf is that user interface though?
03:30:08 <trap_exit> also, is this twins programming
03:30:12 <trap_exit> or do we have two views of the same guy
03:30:39 <annelies> if twins are equal, does it matter? :)
03:33:21 <trap_exit> looking at sound pacakges without sample sound output ... is like looking at 3d rendering packegs without looking at rendered images
03:33:25 <trap_exit> i like twins
03:33:34 <trap_exit> not the twins shown in the video, but twins in general
03:34:04 * hackagebot dockercook 0.1.2.1 - A build tool for multiple docker image layers  http://hackage.haskell.org/package/dockercook-0.1.2.1 (AlexanderThiemann)
03:34:06 * hackagebot Spock 0.6.1.3 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.1.3 (AlexanderThiemann)
03:34:31 <slack1256> annelies: the twins are two different expressions, they have the same denotation though
03:36:58 <trap_exit> okay ... https://www.youtube.com/watch?v=d2JvOwS26Zg suppercollider wins
03:45:30 <zereraz_> hello my aim is to filter a list and show only things at odd index, so I was thinking of using filter and a function to check the element is odd or not. So I saw elemIndex but it returns a Just index. What should I do to do this?
03:45:52 <zereraz_> *check the element is at odd position or not
03:46:12 <coppro> zereraz_: filter is not something you should use for this
03:46:20 <zereraz_> coppro: ok
03:46:28 <coppro> filter only works on the element itself
03:46:29 <zereraz_> then?
03:46:35 <coppro> you could use elemIndex, but it wouldn't work right anyway
03:46:45 <coppro> > elemIndex 1 [1, 2, 1]
03:46:47 <lambdabot>  Just 0
03:46:52 <zereraz_> yeah
03:46:56 <coppro> it wouldn't work for later occurrences of the same item
03:47:06 <zereraz_> I was thinking that
03:47:09 <coppro> probably the best way is to fold
03:48:17 <zereraz_> is there any way of using !!n
03:48:20 <coppro> > foldr (\x (xs,b) -> if b then (x:xs,False) else (xs,True)) True [1..5]
03:48:21 <lambdabot>  Couldn't match expected type ‘([a], GHC.Types.Bool)’
03:48:21 <lambdabot>              with actual type ‘GHC.Types.Bool’
03:48:30 <coppro> > foldr (\x (xs,b) -> if b then (x:xs,False) else (xs,True)) ([],True) [1..5]
03:48:32 <lambdabot>  ([1,3,5],False)
03:48:58 <coppro> yes, you could use that to do a slice
03:49:25 <tsahyt> Is there a way I can force evaluation of an expression inside the IO monad? I've got a computation with multiple steps and I want to let the user know which step is currently happening.
03:49:56 <zereraz_> coppro: can you explain the first part of foldr
03:49:58 <hpc> :t evaluate
03:49:59 <lambdabot> a -> IO a
03:50:18 <hpc> will evaluate something to WHNF
03:50:25 <slack1256> tsahyt: use the State monad (not the writer one) to output the state you are currently processing. Then print that state out.
03:50:28 <ClaudiusMaximus> tsahyt: there's evaluate but that only does WHNF (ie, the outermost constructor) - maybe combine it with deepseq if you need more
03:50:31 <coppro> > let xs = [1, 2, 3, 4, 5] in [xs !! n | n <- [1, 3 ..]]
03:50:33 <lambdabot>  [2,4,*Exception: Prelude.(!!): index too large
03:51:08 <coppro> zereraz_: I'd strongly suggest finding a good book/tutorial that covers basics like foldr and lambdas (and Maybe, for that matter)
03:51:13 <slack1256> *The State monad over IO!
03:51:13 <tsahyt> I'll have a look at deepseq, thanks.
03:51:18 <zereraz_> coppro: ok thanks
03:51:35 <coppro> zereraz_: if you don't understand how to use a Maybe (like Just 1), you'll run into trouble pretty quick :)
03:51:45 <zereraz_> coppro: I don't
03:51:48 <slack1256> tsahyt: deepseq won't help you, you want to the user know in which state you are processing right?
03:51:55 <coppro> learnyouahaskell.com is good; just skim the bits you know
03:51:56 <zereraz_> coppro: I'll read more
03:52:05 <zereraz_> coppro: ok thanks
03:52:21 <tsahyt> I want to make sure that evaluation of one part has been finished before starting with the next part, so I can tell the user that we're moving on to the next part now
03:54:16 <slack1256> then why not just the IO monad?
03:54:20 <mmmm> zereraz_: You usually don't want to use !! as it can cause runtime errors
03:54:43 <zereraz_> mmmm: runtime error because of length of list?
03:54:54 <tsahyt> My computations consist of several large but pure steps that I'm chaining together in the IO monad
03:54:57 <mmmm> yes, same with functions like head and tail
03:55:02 <slack1256> return (foo a) >> putStrLn "part foo done" >> return (bar c) >> putStrLn "part bar done"
03:55:20 <coppro> zereraz_: also because !! is slow
03:55:24 <zereraz_> mmmm: I could use length(myList) and use !! till 1 less than that
03:55:32 <tsahyt> Does that already do the trick? I thought it'd involve more work than that
03:55:43 <zereraz_> mmmm: ok
03:55:50 <slack1256> yep.
03:56:01 <mmmm> how about you try writing a function: odds :: [a] -> [a]; odds [] = _; odds [x] = _; odds (x:y:xs) = _;
03:56:08 <tsahyt> Great. I'll do it that way.
03:56:13 <mmmm> zereraz_: That's not a very functional style :)
03:56:33 <zereraz_> mmmm: can you explain?
03:56:37 <pointed_set> So, why not write safe (!!.) :: [a] -> Int -> Maybe a?
03:56:38 <slack1256> also lets say that your pure functions has parts like f(g(x)) and you want to do first g(x) and tell the user and then f(g(x)), you can do
03:57:32 <mmmm> I've given you half the function definition, you fill in the underscores, ie what should happen with the empty list, what should happen with a list with 1 item and what should happen with a list with 2 or more items
03:57:45 <slack1256> do { a <- return (g x); putStrLn "g x done"; b <- return (f a); putStrLn "done f ( g x) )" }
03:58:20 <pointed_set> Oh, gods! use "let x = y" instead of "x <- return y"
03:58:40 <zereraz_> mmmm: oh thats for me, ok I'll do it
03:59:03 <slack1256> pointed_set: I need the ordering semantics that >>= gives me, let doesn't work there because is lazy pattern biding.
03:59:41 <slack1256> at least for the ordering purposes and the "already evaluated that" semantics tsahyt needs.
03:59:45 <pointed_set> slack1256: return (f x) WILL NOT enforce f x to be refuced. You need seq or deepseq
03:59:53 <pointed_set> * reduced
04:00:51 <slack1256> right I needed (return $! f x)
04:01:11 <zereraz_> mmmm: my aim in that is to return list of odd numbers?
04:01:19 <pointed_set> slack1256: something like so.
04:01:23 <zereraz_> mmmm: or return list with digits at odd index
04:01:39 <pointed_set> If you really need to enforce it.
04:01:45 <slack1256> But I still needed that the reduction happened when IO returned its WHNF. otherwise let could happen only when needed
04:02:11 <slack1256> and thus long after we tell the user that we already did it.
04:02:18 <slack1256> *told
04:02:44 <pointed_set> use seq or deepseq then
04:03:24 <slack1256> deepseq doesn't evaluated
04:03:33 <slack1256> evaluate evaluates :-)
04:03:43 <slack1256> @type evaluate
04:03:44 <lambdabot> a -> IO a
04:03:53 <pointed_set> Hmm. Did you made instances right?
04:04:08 <slack1256> right. but Deepseq only gives this
04:04:11 <slack1256> @type deepseq
04:04:13 <lambdabot> Not in scope: ‘deepseq’
04:04:17 <slack1256> @type seq
04:04:18 <lambdabot> a -> b -> b
04:04:33 <pointed_set> aaand?
04:04:35 <slack1256> that when b is WHNF(NF) a is also in WHNF(NF).
04:04:48 <slack1256> so if we never need b, we never evaluate a.
04:04:59 <pointed_set> materialize x = x `seq` x
04:05:15 <tsahyt> So basically, what I want to do is use evaluate $ force (f x), where force is from the deepseq package?
04:05:25 <slack1256> const 5 (materialize x) == 5
04:06:20 <arossouw> http://honza.ca/2012/10/haskell-strings , is this guy doing it wrong?
04:06:32 <slack1256> tsahyt: if you are returning a simple datatype like Int seq will do. If you are returning a Map and want each of the leaves evaluated then deepseq.
04:06:50 <honza> arossouw: most likely :)
04:07:12 <arossouw> :-)
04:07:22 <shachaf> deepseq is rarely the right function to use, and never by default.
04:08:37 <shachaf> It's a blunt instrument. It usually does too much in irrelevant places.
04:08:52 <shachaf> The better solution is to apply strictness in the right place.
04:09:03 <pointed_set> +1
04:09:28 <arossouw> honza: are those findings still valid?
04:09:40 <shachaf> pointed_set: You're the one who brought up deepseq in the first place. :-(
04:09:51 <slack1256> but usually if you don't know where that place is you end up doing "debugging by strictness perturbation"
04:10:12 <honza> arossouw: i think the main point of the post is to highlight the fact that the obvious implementation is very inefficient and that finding a fast one is hard if you're just starting out
04:10:23 <arossouw> i see
04:10:25 <slack1256> and when that doesn't work, you place safe and end up being XMonad's XState
04:10:35 <slack1256> *s/place/play
04:10:56 <honza> arossouw: it's more a rant about my frustrations with haskell as opposed to a complaint about strings
04:11:10 <arossouw> ok
04:12:08 <arossouw> honza: have you found better way of dealing with it?
04:12:31 <slack1256> I should send a patch to Base libraries in where I define a head function to specifically for Strings
04:12:57 <honza> arossouw: not really --- i have this on and off relationship with haskell; but as far as strings go, the post is fairly exhaustive in terms of the number of different implementations
04:13:17 <slack1256> head :: String -> Char; head (x:_) = x; head [] = error "If you're reading this, you should really import Data.Text"
04:13:27 <k00mi> honza:
04:13:35 <arossouw> ok, makes sense
04:13:43 <k00mi> honza: you might want to use a streaming abstraction like conduits
04:13:54 <honza> arossouw: anything in particular you were wondering?
04:14:07 <Dtgr_> honza: was haskell implementation thrown into /dev/null like the others?
04:14:17 <Pythonfant> well 3.5s vs 1s c is not that bad
04:14:48 <k00mi> if python is faster, it's not fast enough :P
04:14:48 <arossouw> no just curious, the impression i get is that you need lots of experience in haskell to write an efficient parser
04:14:53 <coppro> honza: I have a bit of an on-and-off relationship with haskell
04:15:28 <Pythonfant> k00mi: well if python is just calling a c function it's understandable that it's pretty damn fast
04:15:38 <coppro> honza: but my gut reaction to your first Data.Text implementation was "well obviously that's slower, you're converting so much that you're going to slow things down with all the conversions"
04:15:52 <k00mi> Pythonfant: true
04:16:39 <arossouw> any opinions on bazaar?
04:17:03 <mmmm> zereraz_: Digits at odd index
04:17:19 <mmmm> zereraz_: if you wanted odd digits then you would use a filter
04:17:34 <k00mi> arossouw: the version control system?
04:17:44 <arossouw> yes, that one
04:17:56 <zereraz_> mmmm: yes I did with filter, now gonna try the odd index, but I am slightly confused how to
04:18:06 <zereraz_> mmmm: I think I must use recursion
04:18:09 <k00mi> ah, it's mostly dead
04:18:11 <mmmm> yep!
04:18:57 <arossouw> i'm used to git, but some developer prefers bzr
04:19:47 <k00mi> I don't think there is a good reason to switch
04:19:56 <zereraz_> odds :: [a] -> [a]
04:19:57 <zereraz_> odds [] = []
04:19:57 <zereraz_> odds [x] = [x]
04:19:58 <zereraz_> odds (x:y:xs) = [y]++odds xs
04:20:01 <zereraz_> mmmm:
04:20:01 <arossouw> agree
04:20:14 <zereraz_> mmmm: I got it in the first try!!! yay!
04:20:37 <zereraz_> mmmm: was surprised
04:21:22 <mmmm> zereraz_: You can also do odds (x:y:xs) = y : odds xs
04:21:33 <zereraz_> mmmm: oh yeah!
04:21:43 <mmmm> As coppro was saying earlier, that kind of pattern is called a fold
04:21:52 <mmmm> you see it a lot when using haskell
04:22:02 <zereraz_> mmmm: I have once used such pattern
04:22:02 <mmmm> @src foldl
04:22:03 <lambdabot> foldl f z []     = z
04:22:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:22:09 <mmmm> @src foldr
04:22:09 <lambdabot> foldr f z []     = z
04:22:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:22:11 <zereraz_> mmmm: interesting, thanks allot
04:22:40 <slack1256> > let odds (x:y:xs) = y : odds xs; odds [] = []
04:22:42 <lambdabot>  not an expression: ‘let odds (x:y:xs) = y : odds xs; odds [] = []’
04:22:51 <slack1256> > let odds (x:y:xs) = y : odds xs
04:22:52 <lambdabot>  not an expression: ‘let odds (x:y:xs) = y : odds xs’
04:22:56 <coppro> slack1256: use {}
04:23:35 <slack1256> > help
04:23:37 <lambdabot>  Not in scope: ‘help’
04:23:47 <slack1256> there is no help! everybody run
04:23:52 <zereraz_> lol
04:23:56 <slack1256> @help
04:23:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:24:05 <slack1256> @list
04:24:05 <lambdabot> What module?  Try @listmodules for some ideas.
04:24:26 <zereraz_> help foldr
04:24:43 <zereraz_> did not work -_-
04:24:59 <zereraz_> @help foldr
04:24:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:29:59 <predator117> @def odds (x:y:xs) = y : odds xs; odds [] = []; odds [x] = x
04:30:00 <lambdabot>  .L.hs:162:12:
04:30:01 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
04:30:01 <lambdabot>      Relevant bindings include
04:30:01 <lambdabot>        x :: a (bound at .L.hs:162:7)
04:30:01 <lambdabot>        odds :: [a] -> [a] (bound at .L.hs:158:1)
04:30:08 <predator117> @def odds (x:y:xs) = y : odds xs; odds [] = []; odds [x] = [x]
04:30:09 <lambdabot>  .L.hs:158:1: Warning:
04:30:10 <lambdabot>      Pattern match(es) are overlapped
04:30:10 <lambdabot>      In an equation for ‘odds’:
04:30:10 <lambdabot>          odds (x : (y : xs)) = ...
04:30:11 <lambdabot>          odds [] = ...
04:30:26 <predator117> > odds [1,2,3[
04:30:27 <lambdabot>  <hint>:1:13:
04:30:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:30:28 <predator117> > odds [1,2,3]
04:30:30 <lambdabot>  [2*Exception: L.hs:(158,1)-(159,12): Non-exhaustive patterns in function odds
04:30:40 <predator117> well you get the idea
04:30:52 <slack1256> @def id2 x = x
04:30:53 <lambdabot>  Defined.
04:30:58 <slack1256> aha!
04:31:06 <beaky> hello
04:31:07 <slack1256> > id2 4
04:31:09 <lambdabot>  4
04:31:19 <slack1256> @undef id2
04:31:20 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
04:33:03 <zereraz_> also odds[x] = [] , not [x]
04:36:06 <annelies> odds xs = map snd $ zip xs (drop 2 xs)
04:36:17 <annelies> nah, nvm :P
04:49:43 <mmmm> how did I only realise now that there is traceM in the debug.trace package
04:50:01 <mmmm> for so long I've been doing trace "" (return ())
04:59:23 <trap_exit> when is a new haskell platform coming out?
04:59:32 <kvelicka> .
05:07:01 <annelies> trap_exit next year's gay pride
05:07:27 <trap_exit> when is that?
05:07:54 <trap_exit> wait ...
05:07:56 <trap_exit> does nixos boot
05:07:58 <trap_exit> if so, time to switch
05:08:29 <ehamberg> trap_exit: they're up to release candidate 4, so I would guess “very soon”.
05:09:29 <ehamberg> http://projects.haskell.org/pipermail/haskell-platform/
05:10:01 <trap_exit> http://projects.haskell.org/pipermail/haskell-platform/2014-July/002934.html
05:19:23 <latk> everything is so much harder when programming in python :s
05:19:43 <latk> I don't even remember how I used to work out what things did without type signatures
05:20:00 <bahamas> latk: everything everything?
05:20:12 <latk> bahamas: Many things :p
05:20:24 <annelies> documentation and tests
05:20:28 <zwer> you prayed that your unit tests were comprehensive enough?
05:20:41 <latk> annelies: Yeah, my supervisor doesn't believe in either of those things
05:20:56 <benzrf> neither do i
05:20:58 <annelies> Tell him he sucks and be a rebel.
05:21:01 <latk> he does believe in 600 line functions with variable names like a, n, etc.
05:21:03 <benzrf> thank god i use a language that needs them less
05:21:11 <annelies> bad code is bad regardless of type system
05:21:19 <benzrf> latk: tell him that an internet stranger thinks he's a jerk
05:21:21 <latk> true, but I can't even treat it like a black box :s
05:21:32 <annelies> threaten him!
05:21:36 <annelies> or her
05:21:39 <latk> I probably won't do that :p
05:22:09 <bahamas> latk: be thankful you're not programming in something worse than python at least
05:22:22 <latk> bahamas: True
05:22:29 <annelies> I'd say PHP is worse, but you can specify parameter types. :P
05:22:30 <danilo2> Hello! I would lvoe to ask you why the following code does not compile: "fst (5, return 5)" ? I understand that type inferencer does not know what monad is the second argument, but is there a way to ze lazyness here? We just do not need the second argument
05:22:53 <annelies> > fst (5, return 5)
05:22:55 <lambdabot>  Could not deduce (GHC.Base.Monad m0)
05:22:55 <lambdabot>    arising from a use of ‘GHC.Base.return’
05:22:55 <lambdabot>  from the context (GHC.Num.Num a)
05:22:55 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
05:22:55 <lambdabot>  The type variable ‘m0’ is ambiguous
05:23:11 <bahamas> annelies: you can? how are they enforced?
05:23:24 <annelies> at runtime when the function is called
05:23:46 <annelies> so function f(DateTime $x) { } if (false) f(42); is not an error
05:24:27 <annelies> danilo because it cannot know which implementation of return to use. this should work:
05:24:34 <annelies> > fst (5, return 5 :: IO Int)
05:24:36 <lambdabot>  5
05:24:51 <danilo2> annelies: it does bnot need to know that
05:25:42 <annelies> well, you cannot introduce type errors, regardless of whether the code in question will ever run or not
05:26:10 <annelies> maybe existential types work here, but my knowledge doesn't stretch that far
05:26:56 <bahamas> annelies: well, it's better than no checking I guess
05:27:16 <annelies> bahamas sure, but it wouldn't be PHP if it didn't suck terribly ;)
05:27:24 <annelies> since this is a syntax error: function f(int $x) { }
05:27:28 <nitrix> Ah ah ah! This has to be the greatest 10 minutes of my life on Haskell : https://www.youtube.com/watch?v=RqvCNb7fKsg
05:27:31 <latk> I've never actually used php
05:27:33 <nitrix> The guy is such a troll xD
05:27:33 <annelies> it works only with class types, "callable" and "array" :P
05:27:45 <vanila> PHP is so coool XD
05:27:50 <annelies> not with int, bool, float and string :P
05:28:00 <danilo2_> annelies: You just throw this element away so you do not use it in any cases. you do not need to know the implementation. I would love to know how to make it using existentials / rankntypes etc
05:28:49 <annelies> I'm working on a langauge that does something similar to what PHP does, except it works with all types and has generics. CBA to implement static typing.
05:29:12 <vanila> hly crap, FrungyKing was on here
05:29:17 <vanila> or at least his 'very' combinator was
05:31:25 <companion_cube> annelies: you mean like Hack?
05:32:49 <annelies> AFAIK Hack has static typing.
05:33:27 <companion_cube> it has both, I think
05:33:59 <annelies> more like this: https://gist.github.com/rightfold/a2d37c51923d202037a2
05:34:15 <annelies> where requires specify a precondition like in Eiffel and Spec#
05:34:18 * hackagebot huzzy 0.1.5.5 - Fuzzy logic library with support for T1, IT2, GT2.  http://hackage.haskell.org/package/huzzy-0.1.5.5 (jna_sh)
05:34:19 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
05:34:36 <kvelicka> hello. when using cabal, is there a way to invoke `cabal repl` that automatically includes all the modules that a package exports? currently it only imports the first one
05:40:53 <mmmm> kvelicka: You can add the modules you need by :m +My.Module.Here
05:40:59 <mmmm> If that's what you want
05:42:34 <kvelicka> mmmm: but is there a way to load them all at once by just writing cabal repl?
05:44:36 <annelies> You can write a script that does this somewhere:
05:44:42 <annelies> ls src/**/*.hs | sed 's#\.hs$##g' | sed 's#/#.#g' | sed 's#^#:m +#g'
05:44:53 <annelies> and passes that to stdin before accepting keyboard input :P
05:45:13 <annelies> oh need to strip "src/" as well
05:50:11 <tippenein> does $$ have a general meaning? I see it used some places but what is the idiomatic meaning? Apply?
05:50:50 <tippenein> ex. sourceHandle h $$ foldC
05:51:40 <Clint> tippenein: that's a conduit operator
05:51:43 <mmmm> is that in conduit tippenein?
06:02:57 <trap_exit> is there an easy way to get haskell 7.8.3 via nix os ?
06:04:17 <Ronel> hello
06:04:17 <Ronel> can someone give me an example function that sums a range of numbers without using 'sum' and lists
06:04:17 <Ronel> ?
06:04:30 <Ronel> i am in the progress of trying to learn haskell
06:04:49 <hyPiRion> without lists?
06:05:14 <hyPiRion> > foldl (+) 0 [1..10]
06:05:15 <lambdabot>  55
06:08:00 <pavonia> > foldl (+) 0 $ enumFromTo 1 10
06:08:02 <lambdabot>  55
06:08:17 <mr-> > let {mysum 0 = 0; mysum n = n + mysum (n-1)} in mysum 10
06:08:19 <lambdabot>  55
06:08:30 <annelies> > let sumRange (x, y) = if x == y then x else x + sumRange (x + 1, y) in sumRange (1, 10)
06:08:33 <lambdabot>  55
06:08:48 <tb01110100> > 42
06:08:49 <lambdabot>  42
06:10:26 <pavonia> > (fix $ \f x -> if x == 0 then 0 else f (x-1) + x) 10
06:10:28 <lambdabot>  55
06:13:37 <Ronel> i don't want to do sum [0...5]
06:14:33 <vanila> Ronel, consider
06:14:36 <vanila> 1 + 2 + 3 + 4 + 5
06:14:40 <vanila> 5 + 4 + 3 + 2 + 1
06:14:42 <vanila> =
06:14:45 <vanila> 6 + 6 + 6 + 6 + 6
06:15:02 <vanila> so sum [1..n] = ((n+1)*n)`div` 2
06:15:59 <Ronel> i want a function summate that takes an int
06:15:59 <Ronel> and summates everything between 0 and that int
06:16:18 <dutchie> > sumTo n = n * (n+1)/ 2
06:16:20 <lambdabot>  <hint>:1:9: parse error on input ‘=’
06:16:22 <dutchie> er
06:16:26 <dutchie> whatever
06:16:32 <etandel> @src fixa
06:16:32 <lambdabot> Source not found. That's something I cannot allow to happen.
06:16:33 <dutchie> but also THANKS FREENODE
06:16:34 <etandel> @src fix
06:16:34 <lambdabot> fix f = let x = f x in x
06:17:53 <etandel> huh, didn't know haskell had a builtin y combinator.
06:17:58 <etandel> cool
06:18:49 <mr-> I think it's from Data.Function
06:20:23 <annelies> > let sumRange (x, y) = runST $ do { r <- newSTRef 0; i <- newSTRef x; fix (\f -> do { b <- readSTRef i; if b == y + 1 then readSTRef r else do { modifySTRef r (+ b); modifySTRef i (+ 1); f } }) } in sumRange (1, 10)
06:20:26 <lambdabot>  55
06:21:07 <aarvar> Show him that and he'll never try haskell again
06:21:16 <etandel> lol
06:21:17 <dutchie> haha
06:21:31 <annelies> But they said Haskell was the best imperative language!
06:21:45 <etandel> a guy enters #haskell looking for help on a simple sum function, ends up having a class on monads and combinators.
06:22:50 <Tinned_Tuna> oh lawdy
06:24:33 <annelies> and ST, the most-used Haskell feature
06:24:47 <aarvar> after adding random fixes of course
06:25:41 <annelies> If lambdabot imported System.Process I'd use shell :P
06:25:42 <annelies> > shell
06:25:44 <lambdabot>  Not in scope: ‘shell’
06:27:08 <annelies> we bought electric fly swatters and now the office smells like grilled fly
06:29:46 <Ronel> been away
06:29:54 <Ronel> did someone say something to me
06:30:03 <aarvar> yeah
06:30:11 <Ronel> my scrollback is a couple hundred lines of text
06:30:30 <Ronel> and i missed it
06:30:35 <aarvar> sumTo n = n * (n+1)/ 2
06:30:35 <vanila> I showed you how to write the function
06:30:44 <Ronel> ah k thanks
06:31:21 <Ronel> can a haskell process spawn interact with the outside world and based on some conditions spawn a different number of threads
06:31:28 <Ronel> ?
06:31:52 <etandel> Ronel: sure...
06:32:10 <etandel> the IO monad is one way of interacting with the outside world.
06:32:21 <jle`> Ronel: oh i mentioned that we tend to discourage using explicit recursion if there is a higher order function that can do the same job
06:32:27 <aarvar> IO embeds imperative programming inside of haskell
06:32:27 <jle`> i like saying the IO type :)
06:32:43 <etandel> and there are libaries and extensions to deal with multitasking (threads, GPGPU, multiprocessing etc.)
06:32:51 <aarvar> Saying monad scares people
06:32:51 <Ronel> aha
06:33:01 <Ronel> well i found something about monads
06:33:03 <etandel> ahaha sorry
06:33:21 <Ronel> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
06:33:47 <jle`> i'm not sure if it scares people, but it's mostly irrelevant in this situation
06:33:54 <etandel> http://www.quickmeme.com/img/44/44b0bd758f8ee5c81362923f0d5c8e017c9ddf623925e60c29a4c015b89fbb45.jpg
06:35:04 <annelies> this is by far the best monad tutorial:
06:35:05 <annelies> class Applicative m => Monad m where
06:35:05 <annelies>     return :: a -> m a
06:35:05 <annelies>     (>>=) :: m a -> (a -> m b) -> m b
06:35:09 <jle`> you don't introduce someone to lists for the first time and say "okay, we're going to learn about the list monad: how to make lists alike [1,2,3]
06:35:44 <Ronel> in the small time i've been reading about haskell i didn't get what a monad is
06:35:49 <jle`> i mean yeah...list is a monad...but it's a pretty irrelevant and misleading thing to bring up whena ll you are telling someone to do is how to make a new list in haskell
06:36:03 <vanila> or how to add numbers up to 5
06:36:11 <aarvar> Or how to do IO
06:36:19 <jle`> Ronel: my suggestion: don't worry about it, they're not worth learning about, trust me :)
06:36:38 <Ronel> my decision to learn haskell is based on the fact that i am tired of for/while/objects when implementing code that is mega mathsy
06:37:31 <Trollinator> if Monad extends Applicative, why does it need return? pure is the same thing, no?
06:37:31 <jle`> Ronel: what do you mean by 'mathsy'? :)
06:37:41 <annelies> mine was based on the fact I had to pick a language for a high school project and didn't want to use PHP or Java
06:37:57 <annelies> wanted to try something new :D
06:37:59 <Ronel> jle`, most of the code i write is just math stuff
06:38:06 <jle`> in haskell we tend to have a more generalized definiton of math that...is pretty much encompassing everything conceivable
06:38:07 <aarvar> Because Monad doesn't extend Applicative because there was no Applicative when Monad was added
06:38:27 <Trollinator> but it will soon.
06:38:31 <annelies> aarvar that's fixed but I don't know in which version
06:38:45 <aarvar> isn't it being fixed in 7.10 or something
06:38:55 <Ronel> jle`, i read a lot of spec that just describe mathematical functions and i have to implement those specs in c++
06:39:05 <annelies> C++ is fun.
06:39:34 <aarvar> Well that explains your implementation of sum
06:39:49 <jle`> Ronel: mathematical as in...relating to numbers?
06:39:50 <annelies> Sum in C++: std::accumulate(xs.begin(), xs.end())
06:39:57 <Trollinator> Yeah, it's fun in the in the same way that tearing out your toenails individually is fun.
06:41:10 <annelies> Metaprogramming in C++ is fun. :)
06:41:58 <annelies> Everything is more fun than low-level crap like C and Java. :v
06:42:17 <Ronel> c++ is a clusterfuck of for/ifs/whiles, a way to kill yourself if you don't manage your memory, a cluster fuck of classes
06:42:18 <k00mi> Ronel: what are your performance requirements?
06:42:19 <tdammers> annelies: no.
06:42:25 <tdammers> annelies: C is fun. PHP isn't.
06:42:30 <aarvar> Java isn't really low-level, it's just crap
06:42:40 <k00mi> annelies: Java is low-level but C++ isn't?
06:42:49 <Ronel> k00mi, heh, real fast
06:43:02 <annelies> I'd say C++ is less low-level than Java. :P
06:43:31 <Ronel> i want to implement the mac layer and the physical layer of an eNodeB
06:44:05 <Ronel> i saw i have bindings for FFTW
06:44:11 <k00mi> Ronel: you *can* get really well-performing code out of GHC, but it's not trivial and often results in less idiomatic code
06:44:26 <Ronel> idiomatic?
06:44:56 <k00mi> e.g. writing your own loop instead of using lists as loops, like we often do
06:46:09 <pjdelport> Ronel: Re. monads earlier, Functor is more fundamental and important to understand.
06:46:23 <Ronel> pjdelport,
06:46:36 <Ronel> ok
06:46:37 <pjdelport> Ronel: The order you want to learn them in should be Functor, then Applicative, then Monad. Each just adds on to the previous.
06:46:37 <aarvar> He linked to http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
06:46:51 <aarvar> note it says functors, applicatives, and monads
06:47:27 <Ronel> so c++ compilers beat the crap out of ghc when it comes to performance ?
06:47:54 <aarvar> Short answer: No
06:48:07 <k00mi> eh, yes
06:48:43 <Ronel> haskell is interpreted or compiled?
06:48:58 <aarvar> both
06:49:05 <k00mi> long answer would be 'No, if you trigger the right optimizations'
06:49:06 <FreeFull> Usually compiled in the end
06:49:14 <FreeFull> ghci is an interpreter
06:49:35 <FreeFull> GHC a compiler
06:52:13 <Ronel> "The Glorious Glasgow Haskell Compilation System,"
06:52:31 <Ronel> from wikipedia
06:52:37 <Ronel> is that for real ?
06:52:43 <vanila> yes
06:52:44 <RchrdB> Ronel, yes.
06:52:49 <vanila> lol;
06:52:50 <Pythonfant> Ronel: try ghc --version :)
06:53:19 <Ronel> heh
06:53:40 <Ronel> how much coke do the people that write it snort ?
06:53:56 <splintax> Ronel: what kind of mathematics are you doing? numerical computing?
06:54:43 <curlywur1y> Ronel: functional programmars generally are mental
06:55:03 <curlywur1y> programmers*
06:55:32 <Ronel> i want to implement a turbo coder/decoder
06:55:46 <tdammers> the "Glorious" part is pretty much in the same stupid line of humor as `import this` in Python
06:55:51 <pjdelport> Ronel: Oh, neat!
06:55:51 <SrPx> I've just ran `cabal sandbox init`, then `cabal install accelerate` and it said: "The following packages are likely to be broken by the reinstalls: (...)". How can that be possible if I am running this command in an empty sandbox?
06:55:54 <tdammers> except it's a bit more subtle
06:56:01 <tdammers> and a bit more British, in a way
06:56:26 <Ronel> pjdelport, i also need to write tail biting convolutional encoder and decoder
06:56:38 <Ankhers> SrPx: Is it possible you had a sandbox in that location previously?
06:56:46 <Ronel> pjdelport, for the fft part i will use fftw
06:56:52 <SrPx> nope, just created the directory /accelerate ... it was empty before
06:56:58 <SrPx> well, I'll try to create another one
06:57:01 <vanila> Ronel, those sound pretty advanced compared to what you were asking a bit ago
06:57:28 <Ronel> vanila, so ?
06:57:34 <supki> SrPx: the packages will be broken inside the sandbox
06:57:57 <SrPx> supki: but how, if there is no package ? it is the first thing I install
06:58:24 <supki> sandbox reuses packages from the global db
06:58:28 <supki> e.g. base
06:59:28 <splintax> Ronel: i'm interested, what are you implementing that stuff for? is it a real-time system?
06:59:35 <SrPx> http://lpaste.net/108828 any idea guys? :(
07:00:11 <Ronel> splintax, an software defined eNodeB
07:00:27 <Ankhers> SrPx: supki already said that the sandbox will reuse packages in the global db.
07:00:55 <SrPx> Ankhers: yes, notice the package didn't install even when I used --force-reinstalls. How can I install it?
07:00:59 <Ankhers> SrPx: Chances are, you installed things outside of a sandbox, and are going to reuse those inside the new sandbox.
07:01:34 <splintax> Ronel: cool. i haven't done anything like that before, but i'm not sure that haskell is a good choice? since haskell is a garbage-collected language, afaik it is difficult to make guarantees about how long operations will take and so forth
07:05:36 <supki> SrPx: doesn't look like the version on hackage supports ghc 7.8
07:05:45 <supki> you may want to try to install it from github
07:05:51 <SrPx> ah alright! thanks
07:06:07 <SrPx> quick question then, what is the difference between accelerate and repa?
07:07:30 <SrPx> is there any good book/resource on the matter of parallel computing in hs?
07:07:43 <Cale> SrPx: Accelerate is meant to work with CUDA and OpenCL and other GPU-based backends
07:07:49 <Iceland_jack> @google parallel and concurrent programming in haskell
07:07:50 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
07:07:51 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
07:08:19 <vanila> @src Monad State
07:08:19 <lambdabot> Source not found. There are some things that I just don't know.
07:08:21 <vanila> how do I do this?
07:10:43 <Pythonfant> @src MonadState s m
07:10:43 <pjdelport> @src Maybe fmap
07:10:43 <lambdabot> Source not found. :(
07:10:44 <lambdabot> fmap _ Nothing  = Nothing
07:10:44 <lambdabot> fmap f (Just a) = Just (f a)
07:10:49 <Pythonfant> @src MonadState
07:10:50 <lambdabot> Source not found. Sorry.
07:10:50 <pjdelport> @src Maybe (>>=)
07:10:51 <lambdabot> (Just x) >>= k = k x
07:10:51 <lambdabot> Nothing  >>= _ = Nothing
07:11:00 <pjdelport> I don't think it has entries for State, though.
07:11:04 <pjdelport> (@src is a manual database.)
07:12:18 <Pythonfant> vanila: you probably need to hoogle for it and then click the source link
07:14:40 <Ronel> hellooo
07:15:11 <SrPx> Iceland_jack: ah thanks, but seems like that book doesn't address gpus
07:16:33 <vanila> @src State (>>=)
07:16:33 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
07:17:25 <vamega> Hi
07:17:31 <vamega> Is there a safe version of Maybe?
07:17:39 <vamega> I tried a search on hoogle
07:17:43 <sclv> maybe is safe
07:17:44 <sclv> ?
07:17:48 <vamega> for [a] -> Maybe a
07:17:57 <vamega> sclv - I guess I meant total.
07:18:04 <vamega> Rather than safe.
07:18:08 <vanila> :t listToMaybe
07:18:09 <lambdabot> [a] -> Maybe a
07:20:01 <Pythonfant> vamgea: are you looking for a safe/total version of head? that does [a] -> Maybe a or what do you want this function to do
07:20:55 <vanila> > listToMaybe []
07:20:56 <vanila> > listToMaybe [1]
07:20:56 <lambdabot>  Nothing
07:20:57 <vanila> > listToMaybe [1,2]
07:20:58 <lambdabot>  Just 1
07:20:59 <lambdabot>  Just 1
07:21:10 <Pythonfant> yeah listToMaybe would be the one your looking for if that's what you want
07:21:22 <pjdelport> @hackage safe
07:21:22 <lambdabot> http://hackage.haskell.org/package/safe
07:21:26 <pjdelport> There's also that.
07:23:11 <SrPx> supki: just letting you know that the github version is compatible with ghc 7.8 and installed without issues on a sandbox. thanks!
07:26:16 <vanila> @src runState
07:26:17 <lambdabot> Source not found. Just try something else.
07:29:20 <Ankhers> Would someone please explain how I would be able to write a FromJSON instance for this? http://lpaste.net/108831
07:31:51 <pmade> Ankhers: parseJSON will give you the JSON value which should be an "Object", which I believe is just a Map, so you can "reach inside" for the size information.
07:33:15 <SrPx> Why does core have "let .. in" as a primitive if "let x = 7 in x" is essentially a sugar for `((\x -> x) 7)` ?
07:34:19 <Ankhers> pmade: Thanks. I will look into that.
07:35:12 <k00mi> Ankhers: you can use aeson's (.:) to look up a field of an Object
07:36:01 <Ankhers> k00mi: I have tried that. I just don't understand how to use it to deal with the JSON arrays.
07:36:04 <sproctor-work> Can someone help me understand why the indentation is wrong in the first function in http://lpaste.net/108832 ? The second version appears to be fine.
07:36:18 <TheJhonny> does ghci handle recursive functions that are defined while using the console well?
07:36:33 <k00mi> Ankhers: I will annotate your lpatse
07:37:53 <TheJhonny> I tried to make a length function in the ghci and it fail, while I have the same code in a .hs file and it seems to work just fine.
07:38:09 <TheJhonny> I'm trying to fine the nuances of the ghci :)
07:38:30 <Ankhers> TheJhonny: if you create a function in ghci, you need to use let.
07:38:43 <Ankhers> let f x = x + 1
07:38:49 <Ankhers> will work in ghci
07:38:51 <TheJhonny> I did do that.  That was my first mistake I found lol
07:39:34 <TheJhonny> http://lpaste.net/108833
07:39:42 <arossouw> how do i convert Data.Text.IO (from output of readFile) to Data.Text ?
07:39:49 <Mon_Ouie> You may have only define one case (e.g. length (x:xs) = or length [] = )
07:40:09 <TheJhonny> Oh!
07:40:10 <TheJhonny> Thanks
07:40:20 <Mon_Ouie> > let length [] = 0; length (_:xs) = 1 + length xs in length [1, 2, 3]
07:40:22 <lambdabot>  3
07:42:27 <TheJhonny> So I gotta use the semi if I want to do pattern matching?
07:43:50 <Ankhers> TheJhonny: You seem to be missing the `+` in your function definition. It should be `1 + length' xs`
07:44:59 <TheJhonny> oh.
07:45:17 <k00mi> Ankhers: ok, reload your paste
07:46:28 <arossouw> ok, figured it out
07:46:55 <k00mi> Ankhers: 'object .: field' returns some value of type 'FromJSON a => a'
07:48:03 <TheJhonny> Thanks for the help!
07:48:04 <k00mi> Ankhers: so in the "sizes" case, I have chosen a to be a list (of Strings, or Text, or something else depending on parseSize)
07:48:28 <k00mi> Ankhers: and JSON arrays can indeed be parsed into lists
07:51:26 * hackagebot huzzy 0.1.5.5 - Fuzzy logic library with support for T1, IT2, GT2.  http://hackage.haskell.org/package/huzzy-0.1.5.5 (jna_sh)
07:51:26 * hackagebot np-linear 0.2.0.0 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.2.0.0 (AriePeterson)
07:51:27 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
07:58:32 <Ankhers> k00mi: I'm getting a type error with that. expcted: Parser (t4, t5); actual: (Integer, (t4, t5)); in the return type of a call of parseSize. for simplicity, I just have parse size defined as `parseSize s = (9, 0)`
07:59:08 <OdiseoESP> hello there
07:59:23 <k00mi> Ankhers: try 'parseSize s = return (9, 0)'
07:59:37 <k00mi> Ankhers: and you probably have to give it a type signature
07:59:57 <k00mi> welcome OdiseoESP
08:02:33 <The_other_cat> Hello. For error logging i want to add a timestamp to my messages. For printing the messages (Strings) i want to concate them with the timestamp (given as IO String). So i will end up with a return type IO String. So what is the correct way to convert the IO String -> String? I searched with hoogle and could find just functions IO a -> a, but now i'm a bit lost what exactly to use since i'm new to IO buisiness
08:02:54 <geekosaur> that seems evident :)
08:03:06 <geekosaur> you do not convert an IO anything to a not-IO
08:03:21 <The_other_cat> Hmm.. ok maybe i'll explain the setup better
08:03:33 <geekosaur> I am not explaining myself very well
08:03:42 <Cale> The_other_cat: Values of type IO t are descriptions of things which could be done to obtain a value of type t. You can execute an IO action inside of another IO action to get the result
08:03:44 <geekosaur> the point is that IO is a walled garden
08:03:59 <geekosaur> you not only cannopt take anythoing out of it, but there is not actually anything to take out of it
08:04:16 <Tinned_Tuna> "One does not simply escape from the IO Monad"
08:04:19 <geekosaur> an IO String is not a String in a box that you can somehow take out of the box
08:04:26 <geekosaur> it is a *recipe* for acquiring a String
08:04:33 <Cale> Inside a do-block, v <- x means "execute the action x (whose type is something like IO t), and call its result v (whose type will be t)
08:04:40 <mmmm> ~"an IO String is not a String inside a burriro that you can somehow get out of the burrito"
08:04:42 <The_other_cat> So the correct way is to let the printing function handle IO String input and not String?
08:04:43 <Ankhers> k00mi: I hate to ask, but what should the type signature be? I don't know what type size is. I'm guessing it should be something like `Parser a -> Parser (Int, Int)`?
08:04:44 <geekosaur> just like /bin/ls (or the DIR command on Windows) does not itself contain a list of files
08:04:52 <geekosaur> yes
08:05:21 <k00mi> Ankhers: String -> Parser (Int, Int)
08:05:22 <Cale> The_other_cat: The thing you probably want to do is just to execute the IO action
08:05:36 <The_other_cat> ok cool. thanks, i'm still not digging those monads
08:06:08 <geekosaur> (monads are not the problem here. people think it's the monad part of the IO monad that is strange; it is not, it's the IO part that is strange(
08:06:19 <Cale> The_other_cat: There's no function of type IO t -> t because each time you execute an IO action to get its result of type t, the result might be different, and functions aren't allowed to produce different results for the same argument.
08:06:42 <Cale> The_other_cat: However, inside an IO action, you're allowed to execute any IO action you like to obtain its result.
08:07:25 <Cale> (which you can then pass around to things which don't necessarily involve IO)
08:07:54 <Cale> So, for instance, you might have something like:
08:08:07 <Cale> main = do s <- getLine; putStrLn s
08:08:23 <Cale> For the program which gets a line of text from the user, and then prints it back out
08:08:30 <Cale> Here, getLine :: IO String
08:08:32 <Cale> s :: String
08:08:39 <Cale> putStrLn :: String -> IO ()
08:08:42 <Cale> main :: IO ()
08:09:08 <Cale> and of course, being equal to main,  (do s <- getLine; putStrLn s) :: IO ()
08:09:26 <Cale> The_other_cat: Make sense?
08:09:58 <Cale> So, you should think of "s <- getLine" as meaning "execute getLine, and call its result, in this case the line of text that the user typed, s"
08:12:09 <The_other_cat> Makes sense, thanks
08:12:54 <Cale> do-notation will glue together smaller IO actions into more complicated ones (it actually generalises to other monads as well, but that's not so important)
08:13:26 <The_other_cat> One more question. why does putStrLn has type String -> IO () and not String -> IO String ?
08:13:49 <splintax> after putting a line on the terminal, we don't get anything useful back
08:13:50 <bb010g> What would you want to return from putting a string on the screen?
08:13:53 <Cale> Well, because it doesn't really have a meaningful result to produce
08:13:56 <annelies> The_other_cat command-query separation principle
08:14:40 <Cale> The action which it gives you when you apply it to a String is the action which prints the given string to the terminal, and just results in an empty tuple, because there's no other sensible thing for it to return.
08:14:42 <The_other_cat> ah, i was thinking of response instead of response type!
08:16:11 <splintax> trap_exit: btw i'm only just reading that arrow lpaste now, good link.
08:16:17 <mmmm> has operational been replace by Free or are the packages slightly better suited for different purposes?
08:19:35 <pjdelport> The_other_cat: A good example of a function of type String -> IO String would be: prompt s = putStr s *> getLine
08:19:58 <bb010g> :t *>
08:19:59 <lambdabot> parse error on input ‘*>’
08:20:04 <bb010g> :t (*>)
08:20:05 <lambdabot> Applicative f => f a -> f b -> f b
08:20:06 <bb010g> :t (>>)
08:20:08 <lambdabot> Monad m => m a -> m b -> m b
08:20:25 <bb010g> Also written as prompt s = putStr s >> getLine
08:20:31 <Cale> pjdelport: The_other_cat doesn't know that notation
08:20:40 <bb010g> (At least until AMP)
08:20:54 <Cale> The_other_cat: These are the same as  prompt s = do putStr s; getLine
08:20:56 <The_other_cat> true that, i don't know *>
08:21:23 <osa1> is there a directory version of System.Directory.copyFile (from `directory` package) ?
08:22:42 <Ankhers> k00mi: It doesn't seem to work. Thanks anyways.
08:22:47 <Philonous> The usual TH pattern of taking the data type name and reifying it to receive the constructors (and then doing something with them) seems to break for associated data types, since I can't just say mkLenses ''(FooAssicatedType BarType). Am I missing something, or is it not possible to e.g. have lenses auto-generate in this case?
08:23:15 <albeit> @pl (\a b -> (a+b) / 2)
08:23:16 <lambdabot> flip flip 2 . ((/) .) . (+)
08:23:23 <bb010g> :t ($>)
08:23:24 <lambdabot>     Not in scope: ‘$>’
08:23:24 <lambdabot>     Perhaps you meant one of these:
08:23:24 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
08:23:35 <albeit> :t ((/2) . (+))
08:23:37 <lambdabot> (Num a, Fractional (a -> a)) => a -> a -> a
08:26:17 <k00mi> Ankhers: what's the error?
08:28:40 <pjdelport> The_other_cat: *> is one way to do sequencing; it's essentially the same as >> or the implicit sequencing of do-syntax.
08:29:02 <fread2282> how can I QuickCheck all types which satisfy the typeclass constraint on my test?
08:30:21 <Ankhers> k00mi: No instance for (FromJSON t0) arising from a use of `.:' That is the line with `tags <- o .: "tags"`
08:31:49 <Ankhers> k00mi: I 'fixed' it by changing it to `tags <- o .: "tags" :: Parser Object`, but then I started getting more errors and wasn't sure if that is what I needed to do.
08:32:45 <Ankhers> k00mi: I semi lied there. When I add the parser, it compiles. Though, decode will always return nothing.
08:33:21 <k00mi> Ankhers: I just saw that "tags" is an array
08:33:38 <Ankhers> k00mi: Oh. Yes it is.
08:33:55 <k00mi> Ankhers: so that line should be :: Parser [Object]
08:34:09 <k00mi> and then you have to take the first element
08:36:30 <monochrom> everyone should cite my IO tutorial: http://www.vex.net/~trebla/haskell/IO.xhtml
08:36:43 <k00mi> Ankhers: I have to go now, but maybe someone else can help you if you still have problems
08:36:56 <Ankhers> k00mi: Thanks for all the help.
08:37:35 <The_other_cat> I'm sorry i have to ask again. This IO String timestamp, i still don't quite get how to handle it - e.g. how to print it. Via ghci it's fine, but how about in a do block?
08:37:57 <monochrom> The_other_cat: read my http://www.vex.net/~trebla/haskell/IO.xhtml
08:38:09 <monochrom> it's similar to the getLine example
08:38:33 <monochrom> but read the whole thing. you need the whole picture.
08:40:08 <The_other_cat> ah, now i see (<-) magic ;)
08:42:34 <BeardedCoder> monochrom: Nice article.
08:43:45 <pjdelport> The_other_cat: If you evaluate an IO action in ghci, ghci will execute it for you, and show the result.
08:56:11 <ocharles> dcoutts (or anyone else): what's the ETA on the new cbor-based binary library?
09:00:49 <latk> are aeson parsers compatible with attoparsec ?
09:04:35 <josephle> latk: if you go on the aeson parser page and click on the Parser type, it links you to attoparsec
09:04:57 <josephle> latk: so I assume yes :)
09:13:18 <RyanGlScott> Is there a simple way of viewing a list comprehension unsugared?
09:14:44 <n-dolio> -ddump-ds?
09:14:53 <RyanGlScott> That sounds promising, let me try it
09:15:56 <RyanGlScott> Hm, it might be a bit too unsugared for my tastes, but that definitely does what it advertises.
09:16:28 <enthropy> any clues for implementing http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/syntax-extns.html#record-wildcards with a quasiquoter?
09:30:50 <latk> josephle: Awesome :p
09:36:24 <AleksejsHome> Hi, is there any function that goes through the array of pairs like (cond, func), and if cond x is true then executes func x?
09:37:24 <Fuuzetsu> map (\(p, f) -> if p then f p else ???)
09:38:03 <Fuuzetsu> map (\(p, f) -> if p then f x else ???) is what you wanted rather
09:41:33 <josephle> (map snd . filter fst) <*> pure x?
09:41:50 <josephle> I guess Fuuzetsu's solution is actually readable though
09:42:00 <latk> So I'm writing a FromJSON instance for Data.Time.Day. I have this so far: http://lpaste.net/108847 , but this gives me the warning: http://lpaste.net/108848 - why?
09:42:07 <latk> Isn't _ covering all of the other patterns ?
09:42:32 <glguy__> this line : parseJSON (Object v) =
09:42:36 <glguy__> not your case
09:42:44 <latk> Oh. Okay, how should it look ?
09:42:50 <latk> Ahh I see
09:42:51 <latk> okay
09:42:57 <vamega> If I want to apply a function to only the second element in a list of tuples.
09:43:01 <vamega> How would I go about doing that.
09:43:14 <glguy__> [ (x,f y) | (x,y) <- mylistoftuples ]
09:43:53 <Ankhers> latk: did you get it?
09:43:53 <vamega> glguy__ thanks. Forgot about comprehensions. Was attempting to do this using maps.
09:44:45 <glguy_> vamega: It's probably worth making sure you know how to do it with map, too
09:44:45 <josephle> map (\(x,y) -> (x,f y)) -- map solution
09:44:49 <glguy_> nevermind
09:44:53 <josephle> oops
09:47:04 <vamega> glguy__ : I can't think of a way that doesn't involve a lambda.
09:47:12 <glguy_> That's fine
09:47:20 <vamega> Or mapping over the second element, and zipping that up with the first element.
09:47:20 <glguy_> the goal isn't to do it without one
09:47:35 <vamega> But the list comprehension method is so much simpler.
09:47:38 <vamega> And more readable.
09:48:47 <triliyn> :t second
09:48:49 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
09:49:32 <triliyn> > second (+1) ("three", 2)
09:49:34 <lambdabot>  ("three",3)
09:49:43 <triliyn> If you wanted to do it without a lambda
09:50:04 <vamega> triliyn: Thanks
09:50:25 <josephle> :t _2
09:50:25 <AleksejsHome> Fuuzetsu: I made like this: foo x fs = head $ [f x | (c, f) <- fs, c x]
09:50:26 <lambdabot> (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
09:50:48 <vamega> I've only breifly looked at Arrows. When trying to work with HSL.
09:51:01 <vamega> HXL, not HSL.
09:51:14 <triliyn> Well, in this case the "a" is just specialized to (->)
09:51:26 <triliyn> And this tends to happen in most cases where people use arrows
09:51:31 <Fuuzetsu> AleksejsHome: that has the obvious problem in that it will break if none (c x) == True
09:51:44 <triliyn> So you can think of second as (b -> c) -> (d, b) -> (d, c)
09:52:05 <vamega> Yeah, I the instance of (->) for Arrow is quite apparent.
09:52:49 <vamega> Thank you, I'll keep that in mind in the future.
09:55:59 <josephle> map (& _2 %~ f) -- why stop with arrows?
09:56:46 <glguy_> O.o
09:56:52 <glguy_> over (mapped . _2) f
09:56:57 <vamega> josephle: Is that using lenses?
09:57:28 <josephle> glguy_: my lens-foo is not up to par quite yet
09:57:38 <josephle> vamega: yes!
09:57:56 <vamega> Well, I'm going to avoid that right now then.
09:58:10 <vamega> Given that I'm writing what could quite easily be a small shell script.
09:58:29 <vamega> I don't think pulling in lens would be appropriate.
09:58:38 <Ankhers> foldr for String / Text concatenation is generally what you want to use, correct?
09:58:46 <vamega> I'm attemping to stick to the Prelude as much as possible.
09:59:13 <josephle> a reasonable choice
10:06:39 <supki> Ankhers: Builder is usually faster than concatenating a bunch of Texts with foldr
10:11:17 <hiptobecubic> This exact question came up awhile ago. someone benchmarked it but i don't recall who
10:11:25 <tac_> "pinned" data has something to do with immune to usual garbage collection, right?
10:12:34 <k00mi> tac_: afaiu, it means the GC can't move the objects
10:18:42 <babu> I am using Network.Wreq. How can I extract Int 11011 from Just (Number 11011.0)?
10:20:43 <Guest17569> babu: (\(Just (Number x)) -> floor x) ?
10:21:54 <Guest17569> if Number 11011.0 has a RealFrac instance then fmap floor
10:36:13 <Maior> I've created a ByteString via http://hackage.haskell.org/package/cryptohash-0.7.0/docs/Crypto-Hash-SHA224.html - how do I turn that into a... "hex sting"?
10:36:16 <Maior> sting? String
10:36:39 <enthropy> for once ghc-7.6's typechecking of TH brackets has caught a bug
10:36:49 <babu> Guest17569: which package do I import to get the Number type? In ghci I call a method that returns Number but Number is not in scope
10:37:07 <josephle> babu: Number is a constructor of the Aeson Value type
10:37:08 <merijn> Maior: ByteString.unpack :: ByteString -> [Word8]
10:37:41 <merijn> Maior: Then just have a Word8 -> [Char] (or Text, whatever) and concat the result
10:37:51 <Maior> merijn: ...that'd do it, thanks
10:38:12 <merijn> I wonder if there's a concatMap for ByteString...
10:38:26 <merijn> Maior: Oh, there is
10:38:29 <merijn> There you go
10:38:38 <merijn> :t BS.concatMap
10:38:39 <lambdabot> (Word8 -> BSC.ByteString) -> BSC.ByteString -> BSC.ByteString
10:40:04 <Maior> merijn: I'm slightly confused as to how concatMap would be useful?
10:40:27 <Maior> (surely I just want a Word8 -> Char?)
10:40:43 <bergmark> isn't a word8 two hex chars?
10:40:51 <merijn> bergmark++
10:41:00 <bergmark> yay
10:41:00 <Maior> ...ah
10:41:02 <Maior> thanks
10:41:07 <merijn> 255 = FF :)
10:41:09 <merijn> or 0xFF
10:42:35 <Clint> Maior: map toUpper . concatMap ((\x -> if length x == 1 then '0':x else x) . flip showHex "")
10:43:08 <kuribas> Is big O notation in Data.Map worst case or average case?  (http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Strict.html)
10:44:20 <merijn> kuribas: I think average?
10:45:39 <kuribas> I suspect so...
10:45:56 <babu> Guest17569: that works, thanks.
10:46:07 <Th30n> kuribas: But shouldn't big O notation always be the worst case?
10:46:32 <Laquendi> don't trust me since i don't know anything, but i would imagine strict version has worst-case bounds and lazy version has average bounds
10:46:39 <Th30n> meaning if something has big O complexity there is no way it will perform worse than that
10:46:45 <k00mi> Th30n: no
10:47:35 <josephle> Th30n: what about amortized analysis? It uses big O notation as well, but we know amortized O(f(x)) doesn't imply worst-case O(f(x))
10:48:05 <orion> thoughtpolice: You around?
10:49:59 <codehero> haskell is so awesome
10:50:22 <Philonous> Really? Does it inspire awe?
10:50:48 <Cale> Philonous: At least some of the time :)
10:51:01 <codehero> heh. it's just so cool
10:51:55 <moghedrin> codehero: Hello preacher, meet the choir! ;D
10:52:01 <codehero> :D
10:52:15 <codehero> well, i'm just learning
10:52:42 <codehero> and compared to what i'm used to haskell has some really cool stuff
10:52:50 <Cale> yes
10:52:51 <kuribas> transformer stacks are not so awesome...
10:53:01 <vanila> to be honest haskell is one of the best programming langauges
10:53:07 <Cale> kuribas: Thankfully, you don't have to use them :)
10:53:26 <kuribas> I think haskell is the least anoying language :)
10:53:41 <moghedrin> codehero: Just out of curiousity, what made you decide to start learning it?
10:53:53 <moghedrin> ^^
10:54:05 <codehero> Pythonfant did :P
10:54:33 <codehero> and i heard a lot of good stuff about haskell
10:54:42 <codehero> and well, i wanted to try functional programming
10:55:16 <kuribas> Cale: you don't use transformer stacks?
10:55:41 <Philonous> kuribas, Not to split hairs, but that's not what he said.
10:55:43 <Cale> kuribas: Not often. There are cases where they're appropriate, but they're seriously overused.
10:55:56 <Cale> I would never use StateT over IO, for instance.
10:56:02 <Philonous> Why not?
10:56:04 <vanila> it's frustrating how like Parsec source code is all extremely extremely generic
10:56:12 <vanila> and it's all monad transformers too
10:56:12 <Cale> Because IO already has a lot of facilities for state.
10:56:18 <vanila> so it's very hard to actually read or understand that code
10:56:25 <Th30n> josephle: indeed... this is just horrible, O can be both avg and worst case :/
10:56:25 <codehero> i think that with haskell i might actually be able to do some of the project euler challenges
10:56:29 <levi> Regarding the big O discussion; big O is *usually* worst-case, but can also apply to best case, average case, and amortized analysis. It's usually specified which kind of analysis is being done when it's not worst-case.
10:56:32 <kuribas> IORefs :)
10:56:38 <Cale> yes
10:56:43 <nick_named> codehero: I love me some project euler.
10:56:46 <codehero> trying it with c++ wasn't very easy
10:57:00 <codehero> i couldn't even get the first one working :P
10:57:01 <levi> Also, average case and amortized analysis are a bit different.
10:57:05 <merijn> codehero: tbh, I'm not a big fan of project euler for learning programming
10:57:20 <Th30n> levi: so, when relating to algorithms with no context of analysis it pertains to worst case, right?
10:57:21 <merijn> Project Euler is fun if you wanna learn number theory, but they're lousy for programming
10:57:29 <vanila> Are there sites like project euler, but more relevant to programming?
10:57:35 <Cale> I will typically use IORefs either directly or by applying readIORef and writeIORef to one and passing those read/write ends to various parts of my program which need them.
10:57:36 <vanila> (and hopefully don't require a captcha)
10:57:46 <Philonous> Cale, Ah, well, yes. But often when I write "stacked" programs I try to separate concerns. There might be some part that needs state but doesn't care about IO altogether.
10:57:54 <nick_named> merijn: Agreed, but its a ton of fun.  However, you can increase the learning potential if you optimize all of your code
10:57:55 <codehero> well. for math programming stuff project euler is quite nice
10:57:56 <orion> monochrom: Found a typo.
10:58:16 <codehero> there are several sites with programming challenges
10:58:20 <Cale> Philonous: Another rule I have about monad transformers is that apart from one-liners, I'll never use them without a newtype.
10:58:27 <levi> Th30n: That's what I'd consider to be how it's usually used, yes.
10:58:36 <nick_named> merijn: Learn a lot about dynamic programming + optimizing algorithms
10:58:45 <codehero> https://www.hackerrank.com/ http://coderbyte.com/ http://codecondo.com/coding-challenges/
10:58:56 <codehero> but i don't think many of them support haskell
11:00:06 <merijn> nick_named: Right, but they focus on a part of haskell that is notoriously newbie unfriendly (the sucky Num hierarchy) and ignore all the things haskell is good at (high level abstraction, concurrency, etc.)
11:01:16 <vanila> is therer any better way to do Num?
11:01:25 <vanila> I agree that this sucks, but I'm not sure it can be improved
11:01:32 <nick_named> merijn: I agree, but you can definetly find use for high level abstraction, but its not as obvious as other places.  For example, I use arrows in a few solutions, and a *lot* of applicatives
11:01:41 <n-dolio> It doesn't seem significantly suckier that the majority of other languages.
11:01:54 <n-dolio> Not that that's a high bar.
11:02:11 <n-dolio> But that would make almost every language newbie unfriendly.
11:02:23 <ReinH> n-dolio: o/
11:02:56 <levi> vanila: There have been alternative 'numeric preludes' that have been created, but the current numeric hierarchy has been in the Report for a long time.
11:03:35 <n-dolio> Lots of people like to talk about making it closer to various algebraic abstractions, but that's not going to make it a lot more newbie friendly, either.
11:03:47 <n-dolio> Unless the newbie is a math student.
11:03:51 <vanila> it's not about "newbie friendy"
11:03:57 <nick_named> n-dolio: Yeah, but it would be a lot more user friendly
11:04:06 <codehero> hmm
11:04:47 <codehero> yaaay \o/
11:04:52 <codehero> got the first one correct :P
11:05:09 <codehero> list comprehensions are great :D
11:05:30 <Cale> n-dolio: I think it's actually pretty close to being where it needs to be, just a few little things deserve splitting up. abs and signum don't really belong in Num.
11:05:35 <merijn> n-dolio: Right, I'm not saying is more sucky then other languages. I spend a few weeks hunting silent coercion bugs in C, but to newbies the constant fromIntegral'ing seems rather terrible
11:05:45 <n-dolio> Why is Group, AbelianGroup, Rig, Ring, Field, Module, ... more user friendly?
11:05:49 <Cale> I actually think fromIntegral is fine
11:05:55 <Cale> It *should* be awkward
11:05:59 <merijn> Cale: I'm not saying it's not?
11:06:07 <Cale> fromIntegral is typically a really expensive operation
11:06:34 <merijn> Cale: I'm saying that for a newcomer to the language who has never had to hunt for silent coercion bugs it APPEARS worse than other language where things "Just Work", even if "Just Work" is broken
11:06:39 <edwardk> Cale: ultimately the issue is that to do abs and signum right you really need to embrace MPTCs + fundeps or type families in the numeric tower. you'd want the absolute value of a complex number to be a real, etc.
11:07:04 <merijn> And thereofre I don't think that problems that force newbies to do exercises where haskell APPEARS much worse than other languages is very good marketing
11:07:16 <Cale> edwardk: Well, I'm okay with the present versions, just think they need their own type class.
11:07:24 <merijn> Making newbies write threaded servers is much better, because there haskell shines with how easy things are
11:07:47 <Cale> edwardk: If you want a type class for magnitude-like operations, that'd be fine too, but yeah, that's a different thing
11:08:23 <edwardk> merijn: the way i see it, haskell is the only thing taking this side of the bet, where we do the coercions at the boundaries and never once subtype anything in the numeric tower
11:08:42 <edwardk> which is a grand glorious experiment i never want to lose, because it works _so_ well scaling it up.
11:09:08 <Pythonfant> @hoogle a->[a->Bool]->Bool
11:09:10 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
11:09:10 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
11:09:10 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
11:09:18 <edwardk> its different, so there is an impedence mismatch when people trained in every other language come in and have to deal with something new, but the important part is they don't have to deal with all the magic rules they had to deal with before
11:09:18 <Pythonfant> hm does something like that exist?
11:09:35 <merijn> edwardk: Like I said, *I* have spent weeks hunting down silent coercion bugs in C. fromIntegral seems brilliant to *me*
11:09:35 <Pythonfant> any,and don't seemt to do what i want
11:10:02 <merijn> I'm just saying that newbie ruby/python programmers won't see it that way, so don't focus their attention on it
11:10:03 <nick_named> Pythonfant: What are you looking for?
11:10:06 <n-dolio> @type any . flip id
11:10:07 <lambdabot> a -> [a -> Bool] -> Bool
11:10:10 <edwardk> merijn: its just a place where we could use more communication. i wish the thing you had to use all over the place had a shorter name ;)
11:10:52 <merijn> edwardk: Anyway, I started this as an argument against using Project Euler as basic haskell exercises, since I think it forces people to work with the least nice bits of haskell
11:10:54 <Pythonfant> nick_named: I want to apply multiple predicates to a value and return true if any/all of them match
11:11:08 <edwardk> merijn: point taken and for the most part i agree
11:11:14 <Cale> edwardk: Well, that was also part of my point -- fromIntegral is typically quite expensive (sometimes obscenely so), and I've often thought it's actually good that its name is so awkward
11:11:32 <edwardk> it makes the folks who go in via that path think haskell is for maths
11:11:40 <merijn> Cale: I would agree *if* the Prelude wasn't so damn monomorphic on Int
11:11:41 <Cale> Or realToFrac
11:11:49 <Cale> realToFrac can be *absurd*
11:11:58 <prophile> @pl \x -> all ($ x)
11:11:58 <lambdabot> all . flip id
11:12:05 <prophile> :t all . flip id
11:12:06 <lambdabot> a -> [a -> Bool] -> Bool
11:12:11 <prophile> something like that?
11:12:25 <prophile> (@Pythonfant)
11:13:20 <n-dolio> ReinH: Was that a hello?
11:13:25 <ReinH> n-dolio: yep
11:13:30 <n-dolio> Okay. Hello. :)
11:15:33 <Pythonfant> prophile: yep, thx
11:24:26 <rufs> started learning about monad transformers yesterday, is there a prefered way of modifying the state? should I be more explicit using 'modify' or implicit by using functions that are in the state monad?
11:24:36 <rufs> if that question makes sense
11:25:49 <hseg> Found out what it's called when f.g.f = f (without necessarily having f.g = id) - f is the weak inverse of g (in the semigroup theory sense).
11:26:07 <merijn> rufs: I would say that if you can use modify then it's probably easiest
11:26:29 <merijn> rufs: The main reason to use functions that return StateT is to use them in do-notation
11:26:36 <rufs> I feel like its more clear as to what is modified also
11:26:42 <rufs> and where
11:27:24 <merijn> rufs: for example "modify f" can only manipulate the actual state value "f :: Foo -> StateT s IO x" can do any arbitrary IO, for example
11:30:49 <rufs> merijn: yes true
11:31:36 <merijn> However, if you *want* to do that arbitrary IO, then clearly you want the StateT value
11:36:08 <rufs> hm and a related problem
11:36:24 <rufs> updating records gets a bit awkward
11:36:36 <merijn> rufs: Lenses \o/
11:36:43 <rpglover64> Has anyone tried to use the Text.Printf alternate form conversion specifier?
11:36:57 <rufs> yeah, what lens library should I look at?
11:37:04 <rufs> saw that there was a few
11:37:25 <rpglover64> Because I think I found a mismatch in the behavior and the documentation (i.e. I found a bug in base), but I could be misunderstanding.
11:37:42 <merijn> rufs: The "most batteries included and most popular, but most intimidating" is lens (see #haskell-lens)
11:38:13 <latk> I have a type Foo, whose ToJSON instance looks like toJSON x = object ["foo" .= (show x)]. Say this results in { 'foo' : 'Foo' }. I then have a type Bar, which looks like data Bar = Bar { name :: String, foo :: Foo}. I want to write a ToJSON instance so that the result is { 'name' : 'somestring', 'foo' : 'Foo' }. At the moment I can only get { 'name' : 'somestring', 'foo' : { 'foo' : 'Foo' }}.
11:38:18 <latk> Hopefully that makes sense..
11:38:34 <rufs> merijn: ok thx, will check that out
11:38:38 <nitrix> I'm a bit puzzled by all the different ways to do the same thing. let, where, |, pattern matching...
11:39:02 <nitrix> Hopefully I can work it out.
11:39:27 <rpglover64> In particular, I'm getting an exception when trying to call `printf "%#x\n" 11`
11:39:40 <rpglover64> but the documentation seems to imply that that is okay.
11:39:44 <latk> I think what I need is some function like Value -> Value -> Value, but no such function seems to exist..
11:39:55 <merijn> nitrix: let/where do essentially the same thing, but with slightly different syntax
11:40:31 <tippenein> latk: how did you get the foo: { foo: Foo } ?
11:41:13 <HeladoDeBrownie> nitrix, | and pattern matching are pretty distinct from all those other things
11:41:24 <Ch0c0late> nitrix: Also you use let in do block to bind stuff that are not impure such as map.
11:41:46 <HeladoDeBrownie> nitrix, feel free to ask questions if you don't understand them
11:41:52 <latk> toJSON (Bar a b) = object [ "name .= toJSON a, "foo" .= toJSON b ]
11:41:53 * hackagebot gitson 0.1.0 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.1.0 (myfreeweb)
11:41:55 <latk> tippenein: ^
11:42:50 <latk> tippenein: I wanted to just put toJSON b, but it results in a Value, not a Pair
11:43:34 <tremon> rpglover64: what is your base version? The alternate form didn't exist until 4.7
11:44:13 <rpglover64> Thanks
11:44:25 <rpglover64> I thought I was 4.7.0.0, but apparently I'm 4.6.0.0
11:47:25 <Ankhers> Does anyone have any information on the state of the next platform, aside from the mailing list RC3 announcement?
11:51:54 * hackagebot GLFW 0.5.2.1 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.2.1 (PaulLiu)
11:56:28 <Shamar> hi, anybody have been able to install sdl on windows?
11:56:54 <Shamar> I've tried all tutorials online without success
11:59:34 <Shamar> I've tried this: http://roy-t.nl/index.php/2014/01/16/building-sdl-on-windows-for-use-with-haskell-cabal/
11:59:53 <Shamar> those linked in haskellwiki
12:00:14 <RyanGlScott> Shamar: What problems are you experiencing?
12:00:45 <Shamar> cabal successfully compile sdl
12:01:21 <RyanGlScott> So what is the problem? :)
12:01:40 <Shamar> but when I try to launch https://github.com/snkkid/LazyFooHaskell/tree/master/lesson01
12:02:04 <Shamar> i get an error about missing mingw32.dll
12:02:16 <carter> Q: why doesn't UTCTime have a Show instance?
12:02:17 <carter> the haddocks say it does
12:02:18 <carter> but it seems not to have one dspite that
12:02:47 <RyanGlScott> Shamar: Are you running the program from MSYS?
12:03:05 <Shamar> I run ghci from msys
12:03:40 <Shamar> I tried to install sdl in msys and in cmd
12:03:47 <MP2E> well that's your issue
12:03:53 <MP2E> use msys
12:04:04 <Shamar> yes
12:04:16 <Shamar> but even with msys it doesn't run
12:04:53 <Ankhers> Shamar: Are you trying to run the application in ghci, or are you compiling it and running the generated binary?
12:04:56 <Shamar> I always get the error: can't load mingw32.dll
12:05:08 <Shamar> I load the hs in ghci
12:05:34 <Ankhers> Shamar: Have you tried compiling it?
12:05:47 <Shamar> mmm... no
12:06:22 <Shamar> I'll try asap
12:09:14 <supki> carter: you'd need to import Data.Time.LocalTime to get it
12:09:21 <carter> ohhh
12:09:51 <carter> supki: THANK YOU
12:09:55 <carter> i was going mad
12:10:44 <carter> i may still use format time for my use case
12:10:45 <carter> but thanksssss
12:11:04 <RyanGlScott> I wonder if there's a reason that the Show instance is defined in an entirely separate module? That seems odd.
12:11:22 <carter> i have suspect its to make you use formatTime instead
12:11:25 <carter> which is pretty nice
12:13:48 <RyanGlScott> Speaking of Haddock oddities... is there a reason certain pages give you the message "Sorry, it's just not here?"
12:13:53 <RyanGlScott> For example, http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-GHCi.html from base.
12:14:46 <ocharles> Is anyone here going to ICFP 2014?
12:14:49 <carter> ocharles: me
12:14:53 <carter> are you?
12:14:55 <ocharles> carter: did you get early registration prices?
12:14:59 <carter> nope
12:15:00 <ocharles> i'm curious how different they are to now
12:15:07 <carter> the price list is on the paper form
12:15:07 <ocharles> $1500 is quite the cost :(
12:15:19 <carter> for which bit?
12:15:30 <ocharles> icfp and the two haskell days
12:15:40 <carter> wat
12:15:44 <ocharles> oh, and hope
12:15:47 <carter> ah
12:16:01 <carter> assuming i don't have to drop the trip, i'm giving a talk at hope
12:16:05 <pikaren> exit
12:16:06 <carter> need to finish prepping the slides
12:16:13 <ocharles> cool :)
12:16:34 <carter> i may have  to drop the trip if certain business things go bonkers
12:16:55 <carter> happily the only thing i've had to prepay is the airfair
12:17:26 <ocharles> well, if you find the cost of early registration - i'd be interested to know it
12:17:29 <ocharles> I haven't been able to find it yet
12:17:59 <carter> http://regmaster4.com/2014conf/ICFP14/register.pdf
12:18:19 <ocharles> thanks!
12:18:35 <ocharles> ah good, not hugely different
12:18:38 <carter> yeah
12:18:39 <ocharles> i don't have to hate myself too much then
12:18:41 <ocharles> :D
12:18:53 <carter> yeah, i'm trying to pay for things at the last minute as much as i can
12:19:01 <carter> ocharles: i think i have a 2br room at the hotel reserved
12:19:12 <carter> well 2 bed
12:19:25 <carter> * do have
12:19:40 <carter> need to adjust the reservation, but in theory i could halve my hotel costs
12:19:55 * ocharles nods
12:20:01 <pikaren> exit
12:20:34 <carter> g2g work things
12:25:58 <aristid> so many extensions should be activated by default in GHC IMHO. who wants to write serious code without e.g MPTCs these days? :P
12:28:03 <shachaf> Type classes are overrated.
12:33:00 <Ch0c0late> Let's say I have a list l1 = [1,2,3]. Now I want to calculate GCD in a way that GCD(l2[i], l2[i+1]) = l1[i] for each 1 <= i <= length l1. Any hint? Prime factorization, Euclidean algorithm, Binary algorithm, etc. may work but all of them is based on having the numbers on which we want to take gcd of them but this is reversed. As an example what should be two parameter of GCD func that equals to 1(based on l1) i.e. GCD(?, ?) = 1. Having that another
12:33:00 <Ch0c0late>  important thing is to get concerned about next number in l1 too. As an instance GCD(?,?) = 2 => GCD(2,6) = 2 because of GCD(6,3) = 3. Any hint?
12:33:12 <nick_named> :t (>>=) . flip id
12:33:13 <lambdabot> a -> (c -> (a -> c) -> b) -> (a -> c) -> b
12:34:04 <Shamar> Ankhers, RyanGlScott compiling it worked just fine even in windows' cmd
12:34:19 <Algebr`> Say you want to compile a language to C, you already have the AST. At this point, you could do bytecode or three address code. What would be easier, or rather pros/cons of either? And how does one generally go about compiling to C? Any kind of reference or pointers? (bad pun).
12:34:44 <Ankhers> Shamar: Don't quote me on this. But I believe I read something that you can't use ghci to run GUI applications.
12:34:44 <Shamar> but, why ghci don't works?
12:34:45 <companion_cube> I'm not sure why you'd need bytecode?
12:35:44 <Ch0c0late> You need byte code if you want to translate it to your targeted machines Algebr`. So no need
12:36:25 <enthropy> aristid: just enable them in your .ghci file (and in whatever cabal file you have)
12:36:46 <Shamar> ah... well gloss app can be started in ghci, even if when you close the window the program start allocating memory until "out of memory" exception
12:36:52 <josephle> Algebr`: what kind of language are you compiling to C?
12:36:59 <Algebr`> my own toy language
12:37:16 <Shamar> mmm.. but this would mean that we can't debug haskell gui
12:37:18 <josephle> functional? imperative?
12:37:44 <aristid> enthropy: that i should do, true. but still.
12:37:49 <Algebr`> so for my toy language, I can turn the AST into three address code instead?
12:38:13 <Ankhers> Shamar: I could be wrong. I'm still a Haskell newb myself.
12:38:37 <companion_cube> Algebr`: compiling to C is an AST-to-AST transformation
12:38:47 <Algebr`> Ankhers: I'm pretty sure I remember using ghci for gtk2hs
12:39:18 <Algebr`> companion_cube: so I could directly generate the C code from the toy language's AST?
12:39:35 <companion_cube> well, depends on what the language looks like, but probably yes?
12:39:41 <companion_cube> the first C++ compiler did that
12:40:35 <Algebr`> companion_cube: are there any links or docs that show examples or references?..
12:40:43 <Ch0c0late> Algebr`: Another idea is Portable Object Compiler. The first ObjC compiler did the same thing. It translated ObjC source code using a set of predefined macro to C source code.
12:41:34 <Shamar> btw, someone should link this sdl installation guide for windows in haskell wiki:  http://roy-t.nl/index.php/2014/01/16/building-sdl-on-windows-for-use-with-haskell-cabal/
12:41:37 <benmachine> Ch0c0late: your problem with the gcds is impossible, I think
12:42:08 <Ch0c0late> benemachine: What's the problem with it?
12:42:11 <merijn> Algebr`: Compiling to C is generally just 'generate some C code in a way that makes sense"
12:42:34 <Shamar> it's quite recent and (except for ghci support) it works
12:42:36 <Ch0c0late> benmachine What's the problem with it?
12:42:40 <companion_cube> maybe also add a set of C functions that help translating your AST
12:43:03 <merijn> Algebr`: Two research compilers I worked on in uni compiled to C and it was really just 1) implement a runtime system in C and compile it to a .so, 2) define some convenience macros, 3) compile everything and link the runtime into it
12:43:53 <merijn> Algebr`: Also, you could try generating LLVM assembly and use llvm to generate binaries for you. Depends how comfortable you are with C
12:44:04 <companion_cube> see also nimrod, which I believe compiles to C
12:45:23 <benmachine> Ch0c0late: my minimal counterexample is l1 = [2, 1, 2]
12:46:03 <benmachine> Ch0c0late: then you have to have l2[1] and l2[2] coprime, but you've also got to have them both even
12:47:01 * hackagebot cookie 0.4.1.3 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1.3 (MichaelSnoyman)
12:54:18 <jonsterling> Hey, I hope this isn't inappropriate to post here--but if anyone is hiring Haskell developers, I was just downsized and am presently available. Thanks!
12:57:16 <merijn> jonsterling: Try haskell-cafe and haskellers.com :)
12:57:27 <merijn> jonsterling: dons also regularly tweets haskell job openings
12:59:00 <jonsterling> merijn: thanks!
13:00:37 <merijn> jonsterling: Also, I think Standard Chartered and Jane Street are always hiring (if you're willing to relocate), although Jane Street does ocaml instead of haskell
13:01:56 <jcora> Hi all. I'm reading the book Practical Foundations for Programming languages, and in the first section the author is using the word 'sort' when describing abstract syntax trees - but he hasn't defined it. What does it mean in this context? (I know the question isn't directly about Haskell, but it's about PL theory which the Haskell community is close with I suppose)
13:02:03 * hackagebot yesod-platform 1.2.13 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.13 (MichaelSnoyman)
13:03:46 <josephle> jcora: I think Harper's usage of "sort" in this case is to mean syntactic class
13:04:15 <amf> is there a way to declare an enum data type with specifying the fromEnum, toEnum instances all at once? I want to avoid duplicating the enum names
13:04:49 <jcora> josephle: Do you have an example of syntactic classes? Do "expression" and "declaration" qualify (informally speaking)"
13:04:52 <jcora> ?*
13:04:52 <lambdabot> Maybe you meant: v @ ? .
13:05:03 <carter> jonsterling: oh shit
13:05:13 <jonsterling> carter: :(
13:05:16 <josephle> jcora: if the language had declarations, then perhaps you would separate them from expressions
13:05:19 <carter> this is the startup you've been at for 3+ years?
13:05:32 <jonsterling> Yeah... We ran out of money (no surprise there!)
13:05:33 <josephle> jcora: and then they would be separate classes.
13:05:51 <josephle> jcora: although more realistically the classes would be "expressions" and "statements"
13:05:55 <carter> jonsterling: forgive me for asking... but you didn't know that money was running low?
13:06:14 <jcora> josephle: OK thank you,  think I understand.
13:06:21 <jonsterling> carter: I did know, but it was represented as being likely to last for several more months :(
13:06:24 <geekosaur> amf: is there some reason you can't use derived instances?
13:06:29 <carter> blah
13:06:42 <schell> jonsterling: are you looking for work?
13:06:48 <jonsterling> schell: I am! :)
13:06:49 <carter> jonsterling: one  thing i've learned is its very very important to speculatively pipeline new work opportunities ahead fo time
13:06:58 <josephle> jcora: no problem, PFPL is a good book :)
13:07:01 <carter> i'm trying to get some new work pipelined myself!
13:07:02 <schell> jonsterling: care to work at a digital agency?
13:07:05 <jonsterling> carter: You are definitely right! I'm not so good at thinking about that kind of stuff...
13:07:14 <Philonous> Is it possible to depend on 2 versions of a library, that is, to pull in library A which depends on library B, version 1, but also add library B (version 2) directly?
13:07:32 <carter> jonsterling: think "fuck it, i want nice things, speculatively try to creat new opportunities even when things are going well"
13:07:48 <schell> jonsterling: what’s your email? i’ll send you some details, maybe you will be interesting
13:07:54 <jcora> josephle: Too bad I only have the copy with a giant "Preview" timestamp slapped on all the pages, which I haven't been able to remove... Considering shelling out the cash and getting it from Amazon...
13:07:58 <schell> maybe you will find* it interesting, haha
13:07:58 <jonsterling> schell: Thanks! My email is jon[at]jonmsterling[dot]com
13:08:05 <amf> geekosaur: i have a lot of char's or ints that i want to map to symbolic enum names. the ints may not be successive in value
13:08:53 <schell> jonsterling: cool, thanks :)
13:09:25 <geekosaur> hm. my experience with types like that is that Haskell's Enum typeclass is not useful with them
13:10:55 <Shamar> anybody know the status of sdl2? I'm tring to choose between SDL, SDL2 and SFML
13:12:14 <UnrealQuester>  /quit
13:12:18 <UnrealQuester> damn
13:13:57 <carter> Shamar: ask on #haskell-game
13:15:45 <Shamar> thanks carter
13:21:58 <jcora> josephle: I have a followup question on sorts: would lvalues and rvalues be different sorts in the abstract syntax of C++? (Essentially rvalues are constructs that store values, ie. variables, and lvalues just evaluate to something, ie. literals)
13:23:12 <carter> so  ()-> IO a and a -> IO ()  ?
13:23:27 <carter> roughtly/
13:23:36 <carter> ?
13:23:41 <josephle> jcora: they can be considered sorts, although C++ makes for a very complicated AST
13:23:45 <gdoteof> I'm so confused and frustrated.  How do i turn a Lazy bytestring into a [Char]
13:23:53 <carter> unpack
13:24:03 <gdoteof> unpack turns it into a [Word8]
13:24:07 <carter> Data.ByteString.Lazy.Char8.unpack
13:24:10 <carter> :)
13:24:19 <carter> i use the .Char8 ones
13:24:19 <jcora> josephle: OK, and I suppose it does.
13:24:52 <gdoteof> ::breathes sigh of relief:: thanks
13:24:55 <jcora> Unrelated Haskell question: what does the operator <:> do? Or something similar, I saw it once, and remember that it had something to do with applying functions to lists/elements of lists.
13:25:06 <josephle> jcora: some advice about reading PFPL. Harper really goes into detail with each subject. It benefits to just get a high level view on your first pass.
13:25:32 <jcora> josephle: Great, I will keep that in ind.
13:25:34 <jcora> mind*
13:26:03 <jcora> I was also told to read Types and Programming Languages in parallel, have you read that book and what do you think of it?
13:26:22 <jcora> (I want to create a programming language, that's the primary reason why I'm reading these books.)
13:26:37 <jcora> josephle: If you have other recommendations for that goal, please tell me
13:27:32 <josephle> TaPL is definitely friendlier to the beginner, imo
13:27:39 <Lowl3v3l> jcora, learn the tools that are out there!!! bison,flex,yacc...
13:28:32 <jcora> josephle: Yes, but do they cover similar topics? I thought TAPL was more concerned with type theory, which seemed to be quite more formal and specific.
13:28:44 <josephle> PFPL is all about type theory too
13:29:11 <Trollinator> josephle: why sorts? r/lvalueness is a property of expressions, not types.
13:29:12 <jcora> Lowl3v3l: I know about them, but I'd like to implement that stuff myself. I'll see how that goes, maybe I change my mind.
13:29:42 <josephle> Trollinator: jcora was asking about the definition Bob Harper uses in his book Practical Foundations of Programming Languages
13:29:49 <Lowl3v3l> jcora, okay, i knew of past times when i should have done that^^
13:30:04 <josephle> Trollinator: where he uses sorts as a synonym to syntactic classes
13:30:09 <Trollinator> Oh, OK.
13:30:41 <jcora> Anyway, any info on that <:> operator?
13:31:28 <carter> jcora: its easy to make up new operators
13:31:46 <josephle> jcora: TaPL and PFPL have overlap at first, but their focus changes once you get to "advanced features"
13:31:49 <carter> @let (<:>) a b =  a + b
13:31:52 <lambdabot>  Defined.
13:31:59 <carter> 7 <:> 8
13:32:01 <carter> bam
13:32:03 <trap_exit> anyone hsere using nixos? is there an easy way to install ghc-7.8.3 ?
13:32:03 <josephle> carter: I think he actually meant (:) from the Prelude
13:32:04 <carter> > 7 <:> 8
13:32:06 <lambdabot>  15
13:32:09 <carter> oh
13:32:11 <carter> ahhhh
13:32:11 <jcora> josephle: What is the main difference?
13:32:12 <carter> cons
13:32:23 <carter> :t (:)
13:32:24 <lambdabot> a -> [a] -> [a]
13:32:42 <josephle> jcora: TaPL focuses on getting more complex type systems and uses OOP as a motivating example
13:32:56 <zwer> jcora (:) exists and <:> doesn't :)
13:32:58 <josephle> jcora: PFPL focuses on modelling different styles of programming using type theory
13:33:24 <jcora> Maybe I misremember the operator. But I think it was something from the prelude, and it definitely involved the symbols < and >, with something in between, and had to do with functions and lists... If not, it was probably not from the Prelude, in that case just forget it.
13:33:41 <merijn> jcora: <$> or <*> ?
13:33:59 <jcora> <*> this one!
13:34:46 <jcora> Doesn't seem to be in prelude because :t <*> reports a parse error
13:34:55 <nick_named> :t (<*>)
13:34:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:35:02 <josephle> jcora: more succinctly, TaPL delves into more complicated type systems and PFPL goes into more complicated operational semantics
13:35:04 <merijn> jcora: It's in Control.Applicative
13:35:05 <Ch0c0late> jcora: It's in Control.Applicative
13:36:34 <jcora> Great, does it do something simple or? I'm a Haskell beginner, going over the LYAH at the moment
13:36:43 <josephle> it's kind of amusing that Pierce models OOP using subtyping while Harper models OOP with essentially a vtable
13:36:55 <jcora> "Simple" meaning something a beginner could understand
13:37:04 <Ch0c0late> jcora: It's related to Functors. Do you know them?
13:37:49 <Ch0c0late> jcora: (+) <$> [1,2,3] <*> [1,2,3]
13:38:10 <jcora> Ch0c0late: Nope, I don't know much about CT yet. I plan to learn it much later, after I read TAPL and PFPL, and something on abstract algebra which is apparently a requirement.
13:39:18 <merijn> jcora: He means haskell functors, not CT functors
13:39:32 <merijn> jcora: i.e. "fmap :: Functor f => (a -> b) -> f a -> f b
13:40:02 <jcora> I don't know about them either, sadly
13:40:03 <jcora> Wait
13:40:04 <joshc> window 3
13:40:56 <jcora> merijn I can read what that means, but that's sort of it.
13:41:13 <benzrf> jcora: Functor is defined as follows:
13:41:20 <benzrf> 1. take a type f
13:41:23 <benzrf> f is a functor if
13:41:40 <benzrf> 2. there is a function of type `(a -> b) -> (f a -> f b)'
13:41:43 <benzrf> we'll call it fmap
13:41:44 <benzrf> and
13:41:49 <benzrf> 3. fmap id does the same thing as id
13:42:11 <jcora> I don't get 3.
13:42:23 <benzrf> jcora: for example, [] is a Functor, because `map' has type `(a -> b) -> ([a] -> [b])', and `map id' is just 'id'
13:42:23 <jcora> It's something to do with identity or?
13:42:26 <benzrf> jcora: yes
13:42:29 <benzrf> id a = a
13:42:42 <Ch0c0late> Altogether, * -> *
13:43:44 <benzrf> jcora: any function f of type `(a -> b) -> (f a -> f b)' for which `f id' is the same as `id' is a Functor implementation for the type f
13:43:49 <benzrf> jcora: do you know about typeclasses?
13:44:01 <jcora> benzrf: yep
13:44:26 <jcora> I get what Functor f => ... is supposed to mean, it means that f implements an interface defined in Functor
13:44:28 <benzrf> jcora: Functor is a typeclass that has fmap as a method
13:45:21 <Ch0c0late> So, Functors are those stuff that can get mapped over. jcora
13:46:24 <benzrf> for some value of 'mapped over'
13:46:24 <jcora> Can you just explain this syntax a bit: (a -> b) -> (f a -> f b). That is the type of a function which takes a function form some type a to some type b as an argument, and returns another function. I don't really understand the (f a -> f b) part.
13:46:45 <benzrf> jcora: fmap takes a function from a to b and lifts it into a function from f a to f b
13:47:02 <jcora> Yes, but what exactly is f a?
13:47:03 <benzrf> where f is the type that's an instance of Functor
13:47:06 <Ch0c0late> f here denotes those stuff that are functors.
13:47:08 <jcora> "a" is supposed to be a type.
13:47:10 <jcora> Not a value
13:47:16 <benzrf> jcora: f is a type constructor
13:47:16 <jcora> And here it's used like an argument it seems...
13:47:17 <benzrf> like Maybe
13:47:37 <benzrf> jcora: f a could be Maybe Int, where f is Maybe and a is Int
13:47:37 <Ch0c0late> a iss type variable jcora
13:47:57 <jcora> OK I get it now, thanks!
13:47:59 <Ch0c0late> You can also partially apply some types. jcora
13:48:17 <moghedrin> jcora: Think of f as the container, and a as what it holds. It's not entirely correct, but for the simple functors (like Maybe or List) it holds.
13:48:23 <jcora> Ch0c0late that would mean like TakesTwoParameters Int x?
13:48:37 <jcora> (partial apllication)
13:48:47 <josephle> jcora, the gritty details of this are in ch 22 of PFPL, but the explainations here should suffice for now
13:49:11 <Ch0c0late> jcora: Yes
13:49:54 <Ch0c0late> jcora: Have you ever took a look at Concepts of Programming Languages by Sebasta?
13:50:00 <benzrf> jcora: keep in mind that Functors are not necessarily containers
13:50:10 <benzrf> jcora: for example, you can define fmap when f is (r ->)
13:50:26 <jcora> Ch0c0ate I've noted it down, thank you
13:50:41 <Ch0c0late> mapping function over function
13:52:08 * hackagebot hOpenPGP 1.4 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.4 (ClintAdams)
13:53:50 <Ch0c0late> jcora: In order to complete discussion Applicative Functors are just functors but more powerful.
13:53:58 <Ch0c0late> > :t fmap
13:54:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:54:07 <josephle> :t fmap
13:54:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:54:14 <jcora> > :t map
13:54:16 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:54:20 <jcora> :t map
13:54:21 <lambdabot> (a -> b) -> [a] -> [b]
13:54:23 <jcora> wow nice
13:54:26 <jcora> haha
13:54:40 <jcora> Wonder if you could hack the server...
13:54:51 <jcora> 1+2
13:54:58 <Thooms> > 1+2
13:55:00 <lambdabot>  3
13:55:07 <jcora> > head reverse [1..]
13:55:09 <lambdabot>  Couldn't match expected type ‘[[t0] -> t]’
13:55:09 <lambdabot>              with actual type ‘[a0] -> [a0]’
13:55:17 <jcora> > head (reverse [1..])
13:55:22 <josephle> lambdabot has gotten an informal security audit...right?
13:55:22 <lambdabot>  mueval: ExitFailure 1
13:55:55 <Ch0c0late> jcora: While <*> means that a functor that has a function in itself.
13:56:26 <Ch0c0late> :t (<*>)
13:56:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:58:43 <jcora> Hm, I got lost a bit, why does map have the type it has?
13:58:58 <jcora> I mean shouldn't it be ([a] -> [b])?
13:59:16 <jcora> (Assuming it's a map you find in other languages, that applies a function to the elements of a list)
13:59:41 <josephle> jcora: it needs to take a function (a -> b) in order to change [a] to [b]
13:59:52 <Ch0c0late> jcora: like what? In Ruby you write [1,2,3].map! {|item| item + 1}
14:00:09 <Ch0c0late> jcora: So here you want to map a function over a list of values.
14:00:27 <jcora> List(1, 2, 3) map { _+1} in Scala for example. Results in List(2, 3, 4)
14:00:35 <Ch0c0late> jcora: In the example above part inside {} is a block that is passed to map function.
14:01:06 <Ch0c0late> jcora: So you're mapping a function. It can be called anonymous function.
14:01:45 <Ch0c0late> jcora: Now in Haskell definition map take a function and a list and apply that function over each elements of the list.
14:02:14 <jcora> I wasn't thinking straight when I said the type of map should be [a] -> [b], what I meant was that it should be [a] -> (a -> b) -> [b]
14:02:34 <zwer> that is map with flipped arguments
14:02:37 <zwer> :t flip map
14:02:39 <lambdabot> [a] -> (a -> b) -> [b]
14:02:48 <jcora> :t flip
14:02:49 <lambdabot> (a -> b -> c) -> b -> a -> c
14:02:54 <josephle> in scala the type of map is (self[A] -> (a -> b) -> self[B]) because of OOP conventions
14:03:02 <nick_named> :t fmap . flip id
14:03:04 <lambdabot> Functor f => a -> f (a -> b) -> f b
14:03:07 <jcora> :t map
14:03:08 <lambdabot> (a -> b) -> [a] -> [b]
14:03:17 <Ch0c0late> jcora: Note that Haskell is a pure functional language.
14:03:21 <jcora> God damn it.
14:03:34 <jcora> I don't know what's with me, I see it now...
14:04:21 <jcora> I just thought about it with the first two args reversed, probably because of OOP
14:04:53 <etandel> btw, Python's map() takes the function as the first arg as well
14:04:56 <MagnusVortex> Okay, time for Haskell 101 with MagnusVortex!
14:05:02 <MagnusVortex> what does -> mean?
14:05:21 <nick_named> Lost a predicate? Don't worry! flip id is to the rescue!
14:05:24 <jcora> I don't understand the part about functors not having to be containers. Is there an example of that?
14:05:24 <nick_named> :t find . flip id
14:05:25 <hexagoxel> :k (->)
14:05:25 <merijn> MagnusVortex: It depends on context :p
14:05:25 <lambdabot> a -> [a -> Bool] -> Maybe (a -> Bool)
14:05:26 <lambdabot> * -> * -> *
14:05:45 <ezrios> MagnusVortex: it's the Reader monad
14:05:46 <merijn> MagnusVortex: Could be a lambda, could be a function type, could be higher kind :>
14:06:16 <MagnusVortex> so if I have "stuff -> otherstuff", there's no real way to read that?
14:06:26 <ezrios> MagnusVortex: depends on what the stuff is
14:06:30 <hexagoxel> in a type signature?
14:06:54 <merijn> MagnusVortex: There is, but I need to see the surrounding syntax
14:06:58 <etandel> jcora: functions are functors as well
14:07:08 <zwer> also IO
14:07:12 <etandel> > fmap (+1) (*2) $ 2
14:07:13 <MagnusVortex> ezrios:  does it depend on what otherstuff is as well?
14:07:14 <lambdabot>  5
14:07:26 <merijn> MagnusVortex: "\x -> x + 1" <- this is a lambda
14:07:36 <merijn> MagnusVortex: "foo :: Int -> Bool" <- this is a function type
14:07:45 <zwer> > fmap (++"!") getLine
14:07:47 <lambdabot>  <IO [Char]>
14:08:15 <jcora> etandel: I don't know how to read that code. What's (+1) for starters? A partially applied function +?
14:08:16 <Ch0c0late> :info Functor
14:08:36 <etandel> funcors, applicatives, monads, arrows etc. don't have to be containers. They are just "contexts", which might be a list or an IO operation.
14:08:43 <nick_named> :t (+1)
14:08:44 <lambdabot> Num a => a -> a
14:08:59 <etandel> jcora: (+1) is the function that takes any num and adds 1 to it
14:09:01 <jcora> (+1) 24
14:09:03 <etandel> yes, a partial application
14:09:11 <jcora> > (+1) 24
14:09:12 <etandel> > (+1) 24
14:09:13 <lambdabot>  25
14:09:13 <lambdabot>  can't find file: L.hs
14:09:19 <jcora> Lol we broke it?
14:09:22 <zwer> jcora all functions in haskell take a single argument
14:09:29 <MagnusVortex> >(+1)24
14:09:40 <MagnusVortex> > (+1)24
14:09:41 <lambdabot>  25
14:09:58 <nick_named> etandel: lambdabot doesn't like you
14:10:00 <jcora> zwer: Right, currying, I just didn't know it had a use outside of type signatures.
14:10:06 <etandel> nick_named: hahaha. so it seems
14:10:15 <hexagoxel> > (/3) 9
14:10:17 <lambdabot>  3.0
14:10:33 <etandel> jcora: it's handy in cases like `map (*2) list`
14:10:37 <nick_named> > (div 3) 9
14:10:37 <hexagoxel> observe it is partial application in second argument
14:10:38 <lambdabot>  0
14:10:41 <nick_named> > (`div` 3) 9
14:10:43 <lambdabot>  3
14:10:43 <hexagoxel> > (3/) 9
14:10:45 <lambdabot>  0.3333333333333333
14:10:46 <Aline22>  You can find funny videos here. http://bit.ly/1y2SGSo
14:10:53 <etandel> instead of map (\x -> x+1) list
14:10:54 <HeladoDeBrownie> etandel, (+ 1) is section syntax. http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-300003.5
14:10:58 <ion> > map (-2) [10..20]
14:11:00 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
14:11:00 <lambdabot>    arising from the ambiguity check for ‘e_121020’
14:11:01 <lambdabot>  from the context (GHC.Num.Num (a -> b),
14:11:01 <lambdabot>                    GHC.Num.Num a,
14:11:01 <lambdabot>                    GHC.Enum.Enum a)
14:11:02 <MagnusVortex> > (/3) 9
14:11:03 <nick_named> > ((/)3) 9
14:11:03 <lambdabot>  3.0
14:11:05 <lambdabot>  0.3333333333333333
14:11:27 <HeladoDeBrownie> Woop, wrong person
14:11:31 <ezrios> ion: I don't think sections work on subtraction
14:11:34 <ion> Aww, lambdabot doesn’t have NumInstances?
14:11:35 <ezrios> because of unary negation
14:11:36 <HeladoDeBrownie> jcora, (+ 1) is section syntax. http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-300003.5
14:11:39 <yogurt_truck> etandel: Thinking of functors as containers / contexts got in the way of my learning process, though
14:11:52 <nick_named> > (/3) 9 - ((/)3) 9
14:11:54 <lambdabot>  2.6666666666666665
14:12:32 <etandel> jcora: in any case, fmap for functions is the same as composition.
14:12:49 <jcora> OK, so sections are partial applications for binary operators?
14:13:05 <jcora> Can other functions be partially applied with currying?
14:13:16 <HeladoDeBrownie> jcora, I don't know what you mean by "partial application".
14:13:32 <zwer> jcora sure
14:13:40 <zwer> :t map reverse
14:13:41 <lambdabot> [[a]] -> [[a]]
14:14:14 <nick_named> You can partially apply any function
14:14:16 <ezrios> :t (`elem` [1..10])
14:14:18 <lambdabot> (Num a, Eq a, Enum a) => a -> Bool
14:14:23 <shachaf> jcora: "partial application" isn't really a thing.
14:14:24 <MagnusVortex> is :t something like "tell me about" or "type"?
14:14:26 <ezrios> (`elem` [1..10]) 5
14:14:29 <ezrios> > (`elem` [1..10]) 5
14:14:31 <lambdabot>  True
14:14:34 <ezrios> > (`elem` [1..10]) 42
14:14:35 <lambdabot>  False
14:14:35 <HeladoDeBrownie> MagnusVortex, it asks for its type.
14:14:38 <shachaf> You can come up with a technical definition but for the most part it's just application.
14:14:49 <ezrios> you can even have sections for functions
14:14:50 <etandel> yogurt_truck: Well, that helped my learning process. I guess no one learns the same way. =)
14:15:20 <jcora> OK, it's not partial application because in Haskell each function only takes a single argument. It's an expression that uses currying to generate another function. Am I on the right track here?
14:15:25 <MagnusVortex> Okay, thanks HeladoDeBrownie.
14:15:46 <MagnusVortex> and I think that's enough haskell for a bit.
14:15:48 <HeladoDeBrownie> jcora, I don't think it could be said to "use currying" in any meaningful way.
14:15:50 <MagnusVortex> thanks all!
14:16:03 <MagnusVortex> mmm... curry...
14:16:04 <HeladoDeBrownie> jcora, it's simply application.
14:16:20 <ezrios> jcora: don't think of a -> b -> c as a function of two arguments
14:16:29 <hexagoxel> why is there http://www.haskell.org/haskellwiki/Partial_application then..
14:16:34 <ezrios> think of it as a function that takes an argument of type a and returns a function of type (b -> c)
14:16:39 <ezrios> that is, think of it as a -> (b -> c)
14:16:58 <HeladoDeBrownie> hexagoxel, it's a metaphor at best, and of dubious usefulness in my opinion.
14:17:03 <etandel> I don't remember who said, but "curried foods and curried functions are both acquired tastes"
14:17:17 <ezrios> curried functions are awesome
14:17:26 <ezrios> I feel crippled in languages without them
14:17:32 <jcora> Yes, that's hat I meant HeladoDeBrownie
14:17:43 <jcora> But that's a totally different mode of thinking.
14:17:48 <jcora> And I like it.
14:18:05 <jcora> Seems useful for constructing functions without using additional syntax...
14:18:17 <jcora> I have to research whether Scala is capable of doing it in this way.
14:18:18 <HeladoDeBrownie> jcora, basically, if you read that section on sections that I linked, you'll learn all you need to know about them.
14:18:48 <etandel> ezrios: i know what you mean. I hate when I want to curry something in Python and have to "curried = functools.partial(foo, 'arg1')"
14:19:16 <HeladoDeBrownie> jcora, the Report also uses the words "partial application". That doesn't make it a technical term, though – The Report is colloquial in many places.
14:19:28 <ezrios> etandel: Python and JavaScript are not that bad in this respect
14:19:38 <ezrios> but things like C++ or Perl... ._.
14:19:51 <etandel> ezrios: indeed
14:19:59 <nick_named> ezrios: C++ has std::function and std::bind now
14:20:09 <ezrios> nick_named: the syntax looks horrifying
14:20:24 <etandel> C++ is horrifying.
14:20:28 <ezrios> and C++11 only
14:20:31 <ezrios> I think
14:20:32 <nick_named> ezrios:  Its actually not that bad...  Horrible compared to Haskell though
14:20:47 <merijn> C++11 is not that bad, tbh
14:21:02 <merijn> The syntax is crud, but at least you can get it to do what you want, mostly
14:21:03 <nick_named> merijn: Agreed, so much better than C++03
14:21:04 <ezrios> ah, I just don't always have the option to work in C++11
14:21:24 <fread2282> etandel: there's a python package that does currying
14:21:27 <Ch0c0late> merijn: Yes.
14:21:30 <nick_named> I love move.
14:21:46 <zwer> fread2282 do you know the name off hand?
14:21:51 <prophile> functools has partial application for python
14:22:49 <_ikke_> Why is this giving errors (line 7). It works without the : last sorted, but with it, it says "Could not deduce (a ~ [a])"
14:23:25 <fread2282> zwer: https://pypi.python.org/pypi/PyMonad/ was the one I was thinking of, bet there's a few others on pypi
14:23:25 <HeladoDeBrownie> _ikke_, I don't see a link
14:23:45 <_ikke_> http://lpaste.net/108872
14:24:08 <zwer> fread2282 cool thanks
14:24:21 <josephle> _ikke_: what is the type of (last sorted)?
14:24:27 <fread2282> s/bet/but/
14:24:59 <HeladoDeBrownie> @type (:)
14:25:00 <lambdabot> a -> [a] -> [a]
14:25:00 <HeladoDeBrownie> @type last
14:25:01 <lambdabot> [a] -> a
14:25:02 <nick_named> :t last
14:25:04 <lambdabot> [a] -> a
14:25:04 <etandel> fread2282: i'll check it out
14:25:13 <nick_named> You need [last sorted]
14:25:25 <_ikke_> Oh, right, I get it
14:25:29 <_ikke_> and use ++ instead of ::
14:25:31 <_ikke_> :
14:25:32 <nick_named> And (++) instead of (:)
14:25:35 <_ikke_> yeah
14:25:40 <etandel> oooh a "curry" decorator. aweomse
14:25:43 <etandel> awsome
14:25:45 <etandel> awesome
14:25:45 <etandel> dammit
14:25:47 <cschneid> Does HaRe not install against ghc 7.8? https://gist.github.com/cschneid/0bee76e2f90cea70ecba
14:25:57 <Ch0c0late> http://queue.acm.org/detail.cfm?id=2611829
14:26:19 <Ch0c0late> It's annoying that some imperative programming languages tends to be most functional.
14:27:03 <Ch0c0late> s/most/mostly/g
14:27:12 <josephle> Ch0c0late: please elaborate. Is haskell not the best imperative programming language in the world? :P
14:27:50 <nick_named> _ikke_: For the last line, you might as well do `bubblesort xs = xs`.  Its probably a personal thing, but not including the xs on the rhs weirds me out, makes me look for an error.
14:28:07 <Ch0c0late> josephle: of course it is. At least I love it.
14:28:24 <_ikke_> nick_named: right
14:29:42 <_ikke_> nick_named: any other tips?
14:29:47 <josephle> nick_named: just trust the exhaustiveness checking :)
14:30:41 * Ch0c0late heh. Funny. Swift implementation of Haskell fmap. 
14:30:45 <kirelagin> Hi, I'm looking for a function :: Monad m => [a -> m a] -> (a -> m a)
14:30:49 <kirelagin> Does anyone have one?
14:31:24 <Ch0c0late> It costs too much. :) kirelagin
14:31:43 <kirelagin> =(
14:32:39 <kirelagin> oh wait, will a fold with (>=>) and return work…
14:32:59 <merijn> kirelagin: Yes, and return as zero element
14:33:13 <josephle> I almost thought the joke was that "I'm looking for a function" had type [a -> m a] -> (a -> m a)
14:33:14 <merijn> :t foldl (>=>) return
14:33:16 <lambdabot> Monad m => [b -> m b] -> b -> m b
14:33:36 <Ch0c0late> josephle: ^5
14:34:00 <fread2282> :t (foldr (<=<) return)
14:34:01 <lambdabot> Monad m => [b -> m b] -> b -> m b
14:34:04 <josephle> Ch0c0late, I'm glad you thought so too
14:35:56 <kirelagin> yep, thanks
14:40:12 <benzrf> hmmmmmmm
14:40:37 <benzrf> @let CEndo c a = c a a
14:40:38 <lambdabot>  .L.hs:146:1:
14:40:38 <lambdabot>      Not in scope: data constructor ‘CEndo’
14:40:38 <lambdabot>      Perhaps you meant ‘Endo’ (imported from Data.Monoid)
14:40:38 <lambdabot>  
14:40:38 <lambdabot>  .L.hs:146:13:
14:40:50 <benzrf> @let newtype CEndo c a = CEndo (c a a)
14:40:52 <lambdabot>  Defined.
14:41:19 <benzrf> @let instance Category c => Monoid (CEndo c a a) where mempty = id; mappend = (C..)
14:41:20 <lambdabot>  .L.hs:149:34:
14:41:20 <lambdabot>      ‘CEndo’ is applied to too many type arguments
14:41:21 <lambdabot>      In the instance declaration for ‘Monoid (CEndo c a a)’
14:41:27 <benzrf> @let instance Category c => Monoid (CEndo c a) where mempty = id; mappend = (C..)
14:41:29 <lambdabot>  .L.hs:150:18:
14:41:29 <lambdabot>      Couldn't match expected type ‘CEndo c a’
14:41:29 <lambdabot>                  with actual type ‘a0 -> a0’
14:41:29 <lambdabot>      Relevant bindings include
14:41:29 <lambdabot>        mempty :: CEndo c a (bound at .L.hs:150:9)
14:41:32 <benzrf> dang
14:41:51 <benzrf> @let instance Category c => Monoid (CEndo c a) where mempty = id; mappend (CEndo f) (CEndo g) = CEndo (f C.. g)
14:41:52 <lambdabot>  .L.hs:150:18:
14:41:52 <lambdabot>      Couldn't match expected type ‘CEndo c a’
14:41:52 <lambdabot>                  with actual type ‘a0 -> a0’
14:41:52 <lambdabot>      Relevant bindings include
14:41:52 <lambdabot>        mempty :: CEndo c a (bound at .L.hs:150:9)
14:42:01 <benzrf> huh.
14:42:05 <benzrf> :t (C..)
14:42:07 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
14:42:24 <benzrf> oh
14:42:29 <benzrf> @let instance Category c => Monoid (CEndo c a) where mempty = C.id; mappend (CEndo f) (CEndo g) = CEndo (f C.. g)
14:42:31 <lambdabot>  .L.hs:150:18:
14:42:31 <lambdabot>      Could not deduce (c ~ a)
14:42:31 <lambdabot>      from the context (Category c)
14:42:31 <lambdabot>        bound by the instance declaration at .L.hs:149:10-43
14:42:31 <lambdabot>        ‘c’ is a rigid type variable bound by
14:42:33 <benzrf> :\
14:42:35 <merijn> You were thinking of
14:42:42 <merijn> :t (C.>>>) -- ?
14:42:44 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
14:42:51 <benzrf> @let instance Category c => Monoid (CEndo c a) where mempty = C.id; mappend (CEndo f) (CEndo g) = CEndo (f C.>>> g)
14:42:52 <lambdabot>  .L.hs:150:18:
14:42:53 <lambdabot>      Could not deduce (c ~ a)
14:42:53 <lambdabot>      from the context (Category c)
14:42:53 <lambdabot>        bound by the instance declaration at .L.hs:149:10-43
14:42:53 <lambdabot>        ‘c’ is a rigid type variable bound by
14:43:01 <benzrf> regardless
14:43:08 <benzrf> why does it want c ~ a?
14:43:46 <benzrf> @let instance Category c => Monoid (CEndo c a) where mempty = CEndo C.id; mappend (CEndo f) (CEndo g) = CEndo (f C.. g)
14:43:47 <lambdabot>  Defined.
14:43:49 <benzrf> there we go
14:43:51 <benzrf> and now we have
14:44:09 <benzrf> :t mconcat `asAppliedTo` [CEndo (Kleisli putStrLn)]
14:44:10 <lambdabot>     Couldn't match type ‘()’ with ‘[Char]’
14:44:10 <lambdabot>     Expected type: String -> IO String
14:44:11 <lambdabot>       Actual type: String -> IO ()
14:44:14 <benzrf> dang
14:44:38 <benzrf> :t mconcat `asAppliedTo` [CEndo (Kleisli (\s -> putStrLn s >> getLine))]
14:44:40 <lambdabot> [CEndo (Kleisli IO) String] -> CEndo (Kleisli IO) String
14:44:42 <benzrf> sweet
14:45:00 <benzrf> josephle: ^simplest solution ( ͡° ͜ʖ ͡°)
14:45:10 <bitemyapp> benzrf: lol
14:45:12 <jcora> Hey all, another question about functions. In Scala, functions take multiple arguments. For example, lets say f is of type (Int, String, Int): Boolean. You can partially apply this function like this f(_, "bla", _) - which evaluates to a new function of type (Int, Int): Boolean, where the two ints are the first and last arguments of f.
14:45:16 <jcora> This is similar to currying.
14:45:27 <benzrf> jcora: not exactly
14:45:31 <jcora> Except you don't have to do it "linearly"
14:45:40 <benzrf> easy partial application is a handy side effect of currying
14:45:51 <benzrf> [insert pun on side fx]
14:46:11 <jcora> OK, but is it possible to partially apply functions Scala-style in Haskell?
14:46:18 <jcora> Because it actually seems more useful.
14:46:24 <benzrf> jcora: write a lambda
14:46:31 <benzrf> jcora: or rethink why you want that
14:46:43 <josephle> benzrf: lol
14:46:51 <benzrf> josephle: think about it
14:46:53 <jcora> Huh OK
14:46:57 <hiptobecubic> jcora, lambdas.
14:46:58 <benzrf> what you realllllllly want is mconcat on a more general form of Endo
14:47:14 <jcora> I know some of those words
14:47:18 <benzrf> that is to say, Endo for `Kleisli m' instead of for (->)
14:47:31 <benzrf> the most general solution was to define an Endo for any Category
14:47:32 <benzrf> ;y
14:47:39 <ezrios> whoa, shit got real in this channel
14:47:45 * ezrios scrolls up
14:47:58 * benzrf finally gets to be the one being annoyingly general and ignoring the specific use-case
14:48:04 <benzrf> ah, i could get used to this
14:48:15 <ezrios> my category-fu is not up to snuff
14:48:51 <tolt> Odd question about Free. Is an integer a free magma? I don't know how to talk about free things.
14:48:57 * josephle bows to benzrf
14:49:07 <ezrios> lol
14:49:09 <bitemyapp> tolt: integer isn't parametric, so no.
14:49:18 <ezrios> looks like you have levelled up
14:49:18 <benmachine> tolt: no, for two reasons: one, a magma is a collection of things with an operation, not a single thing
14:49:19 <benzrf> tolt: i dont know much about the formal definition of free objects
14:49:40 <benzrf> tolt: but in general a free X is something that gives you an X from anything that's X minus an important part
14:49:44 <benmachine> tolt: second reason, integers aren't a free magma because they have too many rules
14:49:45 <tolt> I said that wrong. I meant to ask about tree instead of Integer
14:49:51 <benmachine> ah
14:49:58 <benmachine> then... yes, I think
14:49:58 <benzrf> tolt: yes, btrees are the free magma
14:49:59 <benzrf> i think
14:50:04 <bitemyapp> benzrf: not "the"
14:50:05 <ezrios> Are there any useful tidbits of information applicable to Haskell that I could glean from ncatlab?
14:50:07 <bitemyapp> benzrf: more like "a"
14:50:08 <benzrf> bitemyapp: fine :p
14:50:13 <bitemyapp> benzrf: they're the default example, yes.
14:50:28 <ezrios> site looks interesting and I am thinking of poking around in category theory
14:50:54 <tolt> Alright. Thanks bitemyapp, where can I learn more about free?
14:51:58 <bitemyapp> tolt: hum. I haven
14:52:05 <bitemyapp> haven't formalized the tutorial I usually give.
14:52:28 <bitemyapp> tolt: I'll give you some keywords instead
14:52:39 <bitemyapp> tolt: and you dig up material based on those keywords.
14:52:41 <bitemyapp> tolt: does that work for you?
14:52:49 <tolt> Yeah.
14:53:02 <bitemyapp> tolt: free (magma semigroup monoid functor applicative monad), yoneda, coyoneda
14:53:16 <bitemyapp> tolt: and: https://github.com/bitemyapp/learnhaskell/blob/master/dialogues.md#epic-functor-algebra-coyoneda-discussion
14:53:23 <bitemyapp> tolt: and operational
14:53:28 <tolt> Ahh. I'll look into yoneda/coyoneda
14:53:30 <tolt> Thanks
14:53:35 <bitemyapp> tolt: play with IORef, the functor instance vs. the coyoneda free functor for it.
14:53:41 <bitemyapp> tolt: try to see what's different about them.
14:53:50 <tolt> Alright.
14:58:00 <cmccann> bitemyapp: ...there's a functor instance for IORef?
14:58:49 <alanz> cschneid: HaRe does not currently install with GHC 7.8.3, I am working on it
14:59:41 <merijn> cmccann: No
14:59:55 <bitemyapp> cmccann: oh, I wonder what I was thinking of then…
15:00:13 <cmccann> merijn: it was a rhetorical question :P
15:00:14 <bitemyapp> I talked about it with edwardk and ReinH
15:00:37 <bitemyapp> cmccann: what's the data type where the coyoneda is read-only?
15:01:08 <bitemyapp> and the defined functor instance is not
15:01:18 <cmccann> dunno
15:01:26 <bitemyapp> cmccann: https://gist.github.com/thoughtpolice/5843762
15:02:47 <bitemyapp> cmccann: http://www.reddit.com/r/haskell/comments/17a33g/free_functors_the_reason_free_and_operational_are/
15:02:55 <bitemyapp> looks like I misremembered/misunderstood.
15:03:08 <cmccann> bitemyapp: I'm not sure how you'd get a non-read-only anything to be a functor. unless the thing being written is not the functor's type parameter, like the "s" in "State s a"
15:04:55 <bitemyapp> cmccann: Right.
15:05:09 <bitemyapp> cmccann: I have to be careful when pulling things from vague memory.
15:05:15 <bitemyapp> my memory is not very good at all :\
15:05:25 <bitemyapp> that's why I save everything I can.
15:06:58 <cmccann> bitemyapp: well, as a general rule reading is covariant, writing is contravariant
15:07:36 <cmccann> and I say general rather than absolute only because extremely contrived counterexamples may exist
15:07:53 <shachaf> cmccann: What is a counterexample?
15:07:55 <shachaf> Oh, "may" exist.
15:08:26 <bitemyapp> cmccann: that's an interesting idea/way to put it
15:08:27 <cmccann> though I suspect any such contrived counterexamples would rest on creatively interpreting the definitions of "read" and "write"
15:08:49 * bitemyapp nods
15:10:14 <Guest27021> CIAO
15:10:22 <Guest27021> COME FUNZIONA
15:12:17 * hackagebot RFC1751 0.3.0.0 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/RFC1751-0.3.0.0 (XenoGenesis)
15:34:45 <rabisg> 23
15:39:44 <amosr> rabisg: love under will
15:41:10 <rabisg> amosr: dont know what that means :P typed it by mistake
15:41:36 <amosr> rabisg: oh, sorry. 23 is a magic number
15:43:31 <benzrf> 23 FNORD
15:43:43 <amosr> argh!
15:46:50 <vanila> someone linked a bunch of "programming challenge" sitse the other day, but none let me do it in haskell
15:47:00 <vanila> are there any ones that let you use haskell? or at least don't stop you..
15:49:53 <systemfault> I don’t know if it still exists.. but back in the days, a lot of people would do the problems on projecteuler.net
15:50:11 <josephle> project euler got hacked recently, but it should be back
15:50:14 <vanila> im not a fan of projecteuler.net
15:50:19 <alorente> yeah, anything that doesn't try to check your work for you should be gravy, right?
15:50:41 <alorente> some friends and I were using ACM challenge questions but they were a little involved for language-learning
15:50:49 <josephle> google codejam is coming up, if you want some competition
15:52:23 * hackagebot GLFW 0.5.2.2 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.2.2 (PaulLiu)
15:54:49 <merijn> @where exercises
15:54:49 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
15:55:15 <trap_exit_> data IndentedStrictText = IndentedStrictText Int StrictText
15:55:19 <trap_exit_> that is not a very good name is it?
15:55:36 <paolobento> IST is better
15:55:48 <paolobento> (sorry)
15:56:02 <Shamar> guys, did you know this blog post? http://flyingfrogblog.blogspot.it/2010/05/why-is-haskell-used-so-little-in.html
15:56:04 <trap_exit_> I think we should simplify it to IS
15:56:14 <levi> Past ICFP programming contests could be a source of fun exercises.
15:56:18 <Shamar> looks interesting: is it true?
15:56:47 <vanila> flyingfrogblog? hmmmm
15:56:53 <levi> Shamar: It's a rather old blog post, and the author is somewhat biased against Haskell.
15:57:04 <vanila> I recognize that blog
15:57:23 <merijn> Shamar: That's a really trolly post
15:57:45 <merijn> I know of at least 8 or so companies with >100k haskell code bases, and tons more with smaller
15:58:20 <vanila> wow, so much coe
15:58:21 <vanila> code*
15:58:28 <vanila> How do you even end up with 100k lines?
15:58:32 <merijn> It's just that a lot of these companies aren't really all that interested in wasting their time convincing people to use haskell
15:58:34 <vanila> what does it do?
15:58:57 <trap_exit_> haskell is great
15:59:00 <merijn> vanila: Standard Chartered have I believe at least >100k lines of haskell and even more using their own custom strict haskell language
15:59:02 <josephle> levi: some of those ICFP contests are really troll, but I guess that was the point
15:59:02 <zeiris> What's the point in having a competitive edge you advertise to people?
15:59:49 <vanila> i wish I could write haskell as my job
15:59:58 <levi> Jon Harrop is worth listening to when talking about OCaml and F# for the purpose of fast numeric/scientific code. But he's a consultant and very focused on driving people to the tools he's chosen to specialize on, and I think that colors his opinions on things he didn't choose.
16:00:31 <levi> josephle: What do you mean that they're "really troll"?
16:01:11 <josephle> levi: as in the hosts really know how to frustrate the solvers
16:02:53 <josephle> especially with the bonus requirements that come halfway in the contest
16:03:00 <levi> Well, an *easy* contest problem wouldn't be much fun. :)
16:03:29 <alorente> vanila: uh one thing to do would be to implement various sorting algorithms
16:03:44 <josephle> that is true!
16:03:57 <Shamar> I'd really like to join an haskell open source project related to an application not a library or framework
16:04:04 <Shamar> any suggestion?
16:04:13 <merijn> pandoc?
16:04:18 <merijn> xmonad?
16:04:46 <alorente> vanila: that seems particularly haskell-appropriate because then you can learn about how naïve implementations are memory-inefficient
16:05:11 <vanila> okay :)
16:05:29 <Shamar> mmm... nothing "not for dev"?
16:05:38 <josephle> merijn: when you say xmonad, do you mean contributing modules? It seems the core is pretty stable these days.
16:05:58 <Shamar> I mean, both pandoc and xmonad are wondeful projects
16:06:29 <alorente> sorting algorithms came to mind because I was reading about this silly bad algorithm http://en.wikipedia.org/wiki/Stooge_sort
16:06:36 <Shamar> but that's not something that my wife would understand :-D
16:07:25 * Shamar laughs of himself...
16:08:25 <benzrf> hmmmm
16:08:26 <benzrf> @undef
16:08:27 <lambdabot> Undefined.
16:09:00 <benzrf> @let instance Monoid (a -> a) where mempty = id; mappend = (.)
16:09:02 <lambdabot>  Defined.
16:09:07 <benzrf> huh, that works
16:09:12 <benzrf> in that case, what's the point of Endo?
16:09:27 <trap_exit_> does nayone else have hte following problem:
16:09:32 <trap_exit_> emacs randomly hits 100% while indenting haskell code
16:09:46 <trap_exit_> for some reason, it apepars I write really shitty haskell code taht causes the indent procedure to infinite looop in emacs
16:10:43 <ReinH> trap_exit_: have you considered not doing that? :p
16:10:53 <ReinH> trap_exit_: also fyi there's  #haskell-emacs channel
16:10:59 <trap_exit_> oh
16:11:15 <trap_exit_> why so few people
16:11:17 <trap_exit_> what do others here use?
16:11:26 <ReinH> trap_exit_: did you know about the channel before I told you about it?
16:11:36 <ReinH> that's why so few people :p
16:11:51 <Discoloda> trap_exit_: famous words to start a war
16:12:08 <trap_exit_> Discoloda: I don't care which side wins
16:12:10 <ReinH> well, at least it isn't a face
16:12:11 <trap_exit_> I use evil mode on emacs
16:12:22 <trap_exit_> i'm viewed as traitor by both sides
16:12:25 <bms1> benzrf: That requires FlexibleInstances
16:13:08 <l0cust> jle`: hi
16:13:26 <RchrdB> trap_exit, I haven't any help of advice for you, but I do use haskell-mode in Emacs and haven't seen it go into infinite loops trying to indent source. You don't perhaps have any defadvice wrapping the indentation, maybe?
16:13:44 <bms1> benzrf: (actually, I'm not sure...)
16:14:07 <trap_exit> RchrdB: what's defadvice ?
16:14:30 <Andrey_> Hi, i'm trying to use acid-state to store data received from websockets, and I'm wondering where it would be most appropriate to call openLocalStateFrom function? Would it be too slow if  I was calling it on every new client connection?
16:15:29 <benzrf> vim!!1111!!111
16:15:39 <l0cust> benzrf: fuck your shitty editor
16:15:49 <ezrios> D;
16:15:59 <l0cust> benzrf: We all know the only reason anyone uses vim is because they can't figure out how to exit out of it.
16:16:17 <benzrf> l0cust: are u seriously still making that joke
16:16:28 <benzrf> you realize that ^C displays a message explaining how to quit, right
16:16:38 <RchrdB> trap_exit, "advice" in elisp is one mechanism for transparently wrapping before/after functions around other functions. If you don't recognise the word then you're almost certainly not using it.
16:16:40 <l0cust> benzrf: No, I didn't, and that's exactly my point
16:17:10 <benzrf> l0cust: so you're saying that you didnt think to try pressing the #1 exit key sequence in unix
16:17:13 <RchrdB> trap_exit, the only connection it has to indentation is that I've seen at least one person's .emacs file where they used defadvice to override how js2-mode indents javascript files (as an example).
16:17:27 <ezrios> l0cust: is that your only criticism
16:17:29 <trap_exit> i'm almost certain
16:17:34 <trap_exit> the problem is the interaction of evil-mode and haskell-indent
16:17:38 <benzrf> l0cust: what do you want, for the editor to say THIS IS HOW U QUIT the instant you open it in massive letters?
16:17:47 <benzrf> actually, it does that, minus the massive
16:17:51 <l0cust> benzrf: the most well known exit sequence is M-q C-x C-f C-butterfly C-M-w C-m
16:17:54 <RchrdB> trap_exit, plausible! I have no idea how to debug that. :|
16:18:06 <ezrios> hurr i can quote xkcd comics
16:18:06 <benzrf> l0cust: http://benzrf.benzrf.com/imgs/d07935.png
16:18:07 <trap_exit> what?
16:18:09 <genisage> why can't we all just use pico?
16:18:11 <benzrf> this is the vim startup screen
16:18:13 <trap_exit> the universal editor quit command is save + kill -9
16:18:27 <trap_exit> why not just use notepad
16:18:45 <RchrdB> Please can we not have a flamewar about text editors? Thanks.
16:18:52 <l0cust> benzrf: You are aware that I'm kidding, right? Besides, you vim users don't posess the mental facilities to operate Emacs
16:18:59 <RchrdB> l0cust, please stop.
16:19:04 <l0cust> benzrf: nor do you posess the carpal tunnel
16:19:08 <trap_exit> lol
16:19:12 <haasn> @where ops
16:19:13 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:19:16 <trap_exit> even haskell is not immune to vim/emacs flame wars
16:19:25 <josephle> is there a place that is immune?
16:19:27 * benzrf smugly shakes his wrist w/o wincing
16:19:27 <l0cust> alright, fine
16:19:33 <l0cust> josephle: #emacs, or #vim, probably
16:19:48 <benmachine> vim/emacs flame wars are probably older than me
16:20:00 <josephle> I guess massacres do not count as wars
16:20:08 <l0cust> benmachine: vi/emacs users probably are
16:20:14 <l0cust> benmachine: vim, really depends on your age
16:20:19 * tabemann just can't figure out how to make vi or vim stop beeping at him
16:20:30 <benmachine> I sort of assumed we were all past actually genuinely giving a shit and were being super ironic or something
16:20:32 <alpha123> tabemann: Well there's always `sudo rmmod pcspkr`
16:20:43 <genisage> tabemann: use screen and turn on visual bell
16:20:58 <benmachine> I just learn to embrace the beeps
16:21:15 <benmachine> when you finally work out how to get rid of them you'll realise how deeply bereft you are without them
16:21:20 <alpha123> My laptop has a ridiculously loud and startling beep, so that's not really an option :|
16:21:21 <benmachine> and then you won't be able to get them back
16:21:25 <geekosaur> xset b 0
16:21:30 <benzrf> benmachine: i know i am
16:21:31 <ezrios> "what's that noise??'
16:21:37 <ezrios> "oh, that's benmachine's editor. he likes the beeps."
16:21:39 <ezrios> "wat"
16:21:42 <alpha123> lol
16:21:48 <slack1256> It is folklore that lazy evaluation compose better, usually showing how it supports separated generators/consumers as in "Why functional programming matters", but does this notion of composition goes further?
16:22:11 <benmachine> I once downloaded a C program that played the zelda theme using ioctl()
16:22:11 <Cale> slack1256: In what sense?
16:22:20 <ezrios> benmachine: have you seen viznut's work
16:22:30 <ezrios> algorithmic one-liner C programs you pipe to PCM
16:22:34 <ezrios> and music comes out
16:22:47 <slack1256> as in, if some function is not based on generator/consumer based can still benefit from laziness?.
16:22:57 <slack1256> (this is a problem of me having lack of imagination)
16:23:03 <ezrios> https://www.youtube.com/watch?v=GtQdIYUtAHg
16:23:07 <ezrios> and also on topic, algorave
16:23:20 <ezrios> (in haskell) https://www.youtube.com/watch?v=FenTeBMkAsQ
16:23:21 <codehero> benmachine: the zelda theme? o_o
16:23:35 <Cale> slack1256: Most functions are consuming or generating something. Those which produce or consume larger structures with many parts that could be evaluated separately tend to benefit from laziness.
16:23:55 <yogurt_truck> ezrios: have you tried euterpea? it's lovely
16:24:18 <tabemann> from what I gather, though, lazy lists aren't as useful as that paper purported
16:24:27 <benmachine> ezrios: sounds cool but it's late and I don't want to upset my flatmates
16:24:28 <Cale> We use them all the time
16:24:29 <benmachine> or
16:24:30 <benmachine> be awake
16:24:31 <haasn> Laziness can play well into parallelism
16:24:31 <benmachine> anymore
16:24:38 <haasn> Or, rather, nonstrictness
16:24:53 <haasn> Only evaluate the strict parts immediately, evaluate parts that don't have to be forced yet in parallel
16:24:56 <tabemann> what I mean is that there are better lazy sequence data structures than the list
16:25:02 <Cale> Oh?
16:25:20 <Cale> Lists are absolutely perfect for what they are
16:25:29 <tabemann> okay, I need to get going though
16:25:40 <slack1256> Mmm you're right, most functions are consuming or generating something, specially in a pure language.
16:25:55 <Cale> If you plan on iterating through a list of things in order, then lists present you with about as concise a representation as possible.
16:26:18 <Cale> slack1256: Lists are essentially our loops
16:26:34 <Cale> and it helps sometimes that they can be infinite, or combinatorially large
16:27:23 <Cale> for the same reason that you might want to have an infinite loop, or one which potentially iterates more times than you'll practically ever want to actually have the loop body occur.
16:27:34 <slack1256> In "more points for lazy evaluation" augustss shows that laziness enable efficient higher-order functions, and bob concedes that point that in strict languages that really hurts because you have to use manual recursion.
16:27:43 <Cale> yep
16:28:24 <slack1256> Maybe I should really learn SML to appreciate more the benefits of laziness
16:29:07 <Andrey_> how would I pass opened acid state to a function? what would a signature be?
16:29:14 <josephle> then you'll lament the lack of backpack in Haskell ;)
16:29:46 <Cale> It really needs to be the default for that reason: if the default is to be strict, when you find the functions that you want to compose in your library, the chances are good that whoever wrote it won't have thought about your use case, and you'll need to rewrite it to be explicitly lazy, which defeats a lot of the point of having things be compositional.
16:30:21 <codehero> sml seems *fun*
16:30:37 <codehero> judging by the example code on wikipedia
16:32:49 <Cale> Whereas strictness is just slightly more rarely required, and tends to be the kind of thing that you can't ignore when you really need it, because your program's performance will suffer dramatically. So it just becomes a matter of learning to spot the places where it'll be important. The rule of thumb I use is this: if you're collapsing many individual bits of data down into a single thing which depends on all of them
16:32:49 <Cale> and can't be partially evaluated, that's where you want some sort of strict higher-order function like foldl' or some explicit strictness annotations.
16:34:23 <Cale> Basically, things you'd think of as accumulations of some sort. You want to avoid building up large expressions in memory composed of strict functions (functions that must pattern match on their input to produce any part of their result).
16:35:43 <Cale> So for instance, when you're repeatedly updating the contents of an IORef, or recursively updating an accumulating parameter without matching on it, you want to be careful there.
16:38:44 <bitemyapp> Cale: thanks for fielding that question. Good answer :)
16:39:12 <slack1256> That is a good rule of a thumb, it is also the first pattern people of other languages will try to use (number cruching) and that explains the initial frustation.
16:41:40 <hiptobecubic> why sml over ocaml?
16:41:45 <ydl> anyone using haskell on windows, have you run into conflicts using your own version of mingw vs the one bundled with haskell?
16:44:29 <josephle> pragmatically I would prefer to learn ocaml over sml, but I guess there are some pretty big differences to those who care
16:45:15 <jophish> ydl, I've not had any problems at all with Haskell on windows
16:45:45 <hiptobecubic> josephle, sure. But I'm asking what they are.
16:45:46 <ydl> jophish, i'm asking specifically about the C compiler to use with haskell packages though
16:45:50 <hiptobecubic> I don't know either.
16:45:54 <hiptobecubic> (language)
16:47:09 <slack1256> hiptobecubic: I only said that because bob harper (which is critical of some part of haskell but with reason) likes SML, so to understand his points I choose it.
16:47:38 <slack1256> They arent that different, generative vs applicative functors, object systems, non-overloaded numeric functions.
16:48:00 <kvanb> ydl: yes, you should use the gcc shipped with ghc for making object files
16:48:33 <ydl> kvanb, so i /will/ run into problems if I use my own?
16:48:41 <Saizan> Cale: i feel like it should be type driven
16:48:46 <merijn> ydl: Well, you need a C compiler with the same ABI
16:48:47 <kvanb> you might. None of this is predictable.
16:48:48 <josephle> slack1256: I would say an object system is a pretty big difference if any Ocamler actually used it
16:48:59 <kvanb> the format of gcc object files change sometimes
16:49:03 <kvanb> and so does the sections they include
16:49:04 <merijn> ydl: GHC can link arbitrary object files, as long as the ABI matches
16:49:36 <merijn> ydl: Same way you can mix clang and gcc object files if you're sure the two used the same ABI
16:49:41 <josephle> hiptobecubic: but ocaml has more industry support. SML's claim to fame is being formally verified to be typesafe.
16:50:30 <hiptobecubic> i see
16:50:51 <alpha123> I can't stand OCaml's syntax :/
16:51:04 <kvanb> merijn: does that actually predictably work?
16:51:08 <hiptobecubic> it's pretty ugly if you're used to haskell yeah
16:51:21 <hiptobecubic> or even C :)
16:51:53 <josephle> that double semi-colon...
16:52:13 <alpha123> Haskell's syntax is actually the reason I keep coming back to it :P
16:52:21 <hiptobecubic> let x = 1.0 .+ 2.0;;
16:52:27 <hiptobecubic> or is it +. ?
16:52:34 <alpha123> +. I *think*
16:52:41 <alpha123> I don't really 'get' Haskell yet, but it's beautiful
16:53:22 <haasn> The ugliest thing about Haskell syntax is that :: and = don't have the same width in monospace fonts
16:53:32 <alpha123> I'm a web designer and use JavaScript and Ruby pretty much exclusively, but I'd like to add Haskell to that toolbox
16:53:33 <codehero> lol
16:53:35 <jophish> haasn, vim folding :)
16:53:37 <hiptobecubic> haasn, haha :D
16:53:45 <Discoloda> I would like it if Haskell switched :: and :
16:53:48 <kvanb> which is less of an issue if the function has arguments
16:53:56 <alpha123> haasn: I think I have a vim plugin that replaces :: with a single character, it's neat
16:54:16 <kvanb> if you use an editor with ligatures you can use that font
16:54:19 <haasn> There's always UnicodeSyntax
16:54:24 <haasn> But I really don't like that approach
16:54:26 <Discoloda> alpha123: vim conceal
16:54:28 <haasn> I like seeing things the way it's in the source file
16:54:37 <hiptobecubic> agreed
16:54:39 <alpha123> That's it, thanks Discoloda
16:54:43 <haasn> So I can see, optically, what other people see - and control layout
16:55:01 <Discoloda> haasn: me too, i always disable vim's conceal
16:55:18 <codehero> @let listOfFuns = map (*) [0..]
16:55:19 <lambdabot>  Defined.
16:55:35 <codehero> > (listOfFuns !! 13) 8
16:55:37 <lambdabot>  104
16:55:39 <codehero> oh man
16:55:40 <merijn> kvanb: Why wouldn't it? linking is linking
16:55:42 <codehero> haskell
16:55:53 <codehero> this is crazy, but i love it
16:56:08 <Discoloda> crazy awesome
16:56:54 <codehero> yeah
16:57:13 <merijn> > (*) <$> ZipList [1..10] <*> ZipList [1,3..] -- whoo!
16:57:14 <kvanb> merijn: well, the example I would have immediately come up with, is object files post-lto support and object files pre-lto support
16:57:15 <lambdabot>  ZipList {getZipList = [1,6,15,28,45,66,91,120,153,190]}
16:57:25 <Fuuzetsu> haasn: Agda uses : for types, just switch to that
16:57:33 <haasn> ;^)
16:57:34 <kvanb> afaik clang got lto a lot earlier than gcc?
16:57:42 <Discoloda> also Idris
16:57:49 <kvanb> also gold vs no-gold and llvm linker specific versus ld
16:57:53 <hiptobecubic> Fuuzetsu, yes. That's much easier.
16:57:58 <merijn> kvanb: If lto object files are different, then by definition they're not the same ABI
16:58:04 <haasn> I feel like writing a practical program in one of those two languages to learn them better, but I can't decide whether I should be using Agda or Idris
16:58:15 <alpha123> Idris sounds more practical
16:58:16 <Fuuzetsu> Discoloda: Idris goes all the other way with such ugly stuff like _|_
16:58:18 <kvanb> haasn: Coq :D
16:58:21 <merijn> haasn: Learn Coq, it's a cool video game :)
16:58:26 <vanila> haasn, what kind of practical program?
16:58:26 <kvanb> haha
16:58:28 <alpha123> Though I barely understand Haskell, let alone Idris or Agda :P
16:58:28 <merijn> Sucks for programming, but still
16:58:29 <haasn> But I guess since I'm a vim user that means “Idris”
16:58:42 <vanila> btw Idris is nice but it doesn't seem ready for practical use yet
16:58:54 <merijn> I found a good Coq mode for vim, so I'm happy :)
16:59:05 <merijn> Agda still kinda sucks in vim
16:59:09 <vanila> Coq is what gets used for real world stuff
16:59:12 <haasn> vanila: I'd like to try porting my Haskell units library, for example; it currently uses TFs + Singletons and stuff and I want to see how much easier that is with dependent types
16:59:17 <Discoloda> Fuuzetsu: _|_ is not used as much as : or ::
16:59:20 <vanila> like soeone wrote a C compiler in it with all the correctnes proofs
16:59:29 <alpha123> Well then someone's a little crazy
16:59:33 <vanila> haasn, that's an interesting project - good luck!
16:59:52 <Fuuzetsu> haasn: that's fairly trivial in Agda
17:00:10 <Fuuzetsu> not exactly the kind of thing I was thinking of when you said practical program
17:00:25 <haasn> What, did you think I was gonna implement nethack or something? :)
17:00:27 <Fuuzetsu> thought you meant nasty IO stuff or something
17:00:41 <vanila> net hack with a proof  that it's really damn hard to win :)
17:03:01 <Discoloda> i wonder how far you can go, programming with just the types. the "compiler" figures out the contents of the function
17:03:27 <alpha123> I was really addicted to nethack for a few months and only won three times, and I was reading the wiki and IRC and everything. Can confirm hard to win. @_@
17:03:43 <haasn> Discoloda: probably depends on how strictly typed your data types are
17:03:52 <Fuuzetsu> what language
17:03:52 <merijn> Discoloda: There's some stuff already, if you're somewhat familiar with type theory already check out McBride's thesis
17:03:53 <haasn> Like you can infer way more with dependent vectors than with lists
17:04:00 <Fuuzetsu> you can just run IO in your compiler and compute that way ;^)
17:04:34 <merijn> Discoloda: Although you'd probably want to at least be familiar with the basics of dependent types for that one
17:04:57 <Fuuzetsu> what's McBride's thesis on?
17:05:08 <merijn> Discoloda: His entire argument is that you write a type, the compiler refines and implements as much as it can until it gets stuck. At which point you add more type annotations so the compiler can continue
17:05:12 <merijn> Fuuzetsu: ^^
17:05:26 <merijn> Epigram, essentially
17:05:40 <Fuuzetsu> never used epigram 2
17:05:49 <haasn> Epigram 2 is vaporware
17:05:50 <Fuuzetsu> uh, just epigram
17:06:00 <Fuuzetsu> yes, I just hear great woes regularly about Epigram 2 not happening
17:06:08 <vanila> Fuuzetsu, where?
17:06:15 <Fuuzetsu> my house until recently…
17:06:40 <merijn> It's sad that Epigram 2 isn't happening, I thought the thesis was really cool
17:06:46 <vanila> Why do you say it isnt happening?
17:07:28 <merijn> Well, I haven't seen much output and McBride moved to a different uni
17:07:38 <vanila> hmm
17:07:40 <Andrey_> Hello, is it possible to make acid-state not store anything into file and just hold everything in memory?
17:08:02 <vanila> what is he researching there?
17:08:34 <merijn> Andrey_: errr
17:08:41 <merijn> Andrey_: What the hell would the point of that be?
17:08:48 <haasn> 2014-05-23 15:23:59 christiansen i asked conor about that at mgs, and he cites his change of religion as a reason why epigram 2 will never get finished
17:09:03 <vanila> what religion?
17:09:10 <merijn> Now I'm curious what that change of religion was :)
17:09:16 <vanila> probably from OTT to HOTT
17:09:24 <vanila> I mean, this is my guess
17:09:27 <haasn> I'd imagine something like this, too
17:09:31 <vanila> but this is really sad and terrible
17:09:38 <merijn> Dammit
17:09:45 <merijn> Now I need to read HoTT even more :\
17:09:51 <Saizan> he sounded fairly skeptical of HoTT at mgs, actually
17:10:25 <Andrey_> merijn: I just do need it persistent
17:10:30 <Saizan> he quite likes that transporting is free at runtime when you have K
17:10:47 <benzrf> OTT/
17:10:51 <benzrf> * OTT?
17:10:55 <merijn> Andrey_: How can you persist anything without storing in a file?
17:10:59 <josephle> Observational Type Theory
17:11:18 <josephle> unfortunately the nLab definition is biased towards HoTT :P
17:11:20 <Andrey_> merijn: I DON'T need it persistent :D
17:11:30 <jonsterling> I don't want to speak for him, but what I've heard him say is that he basically wants HoTT so long as he can have a subuniverse where all coercions are for-free and irrelevant.
17:11:38 <Andrey_> merijn: sorry for typo
17:11:48 <Andrey_> merijn: that was kinda important
17:12:12 <Saizan> jonsterling: yeah, that'd seem the pragmatic thing to do
17:12:16 <merijn> Andrey_: Then just use haskell data structures?
17:13:05 <vanila> I have all the epigram2 source code
17:13:11 <merijn> Andrey_: The point of acid-state is to make haskell data structures ACID. Immutable data structures are ACI by definition, so if you're gonna remove the D from acid, why bother?
17:13:21 <sclv> jonsterling: so that's what voevodsky wants too, and he calls HTS
17:13:54 <Saizan> sclv: that also has equality reflection though
17:14:06 <sclv> oh and conor doesn't want that?
17:14:11 <Andrey_> merijn: I didn't know that they are ACI by definition :)
17:14:32 <Andrey_> merijn: that was kinda the point of using acid-state for ACI
17:14:34 <sclv> i guess that that component really can't compute :-)
17:15:02 <merijn> Andrey_: Well, if you can't mutate anything then updates are automatically atomic (they can't change anything), they automatically consistent (nothing changes) and isolated (they don't interfere, so you can't mutate)
17:15:16 <merijn> If you want mutable things, use STM
17:16:10 <Saizan> sclv: you wouldn't invent OTT if you were fine with eq. reflection, i'd think
17:16:12 <jonsterling> sclv: Equality reflection computes fine, but not decidably. That's the part that Conor doesn't want: for him, the judgments of Type Theory need to be analytic so that terms may be viewed as proofs.
17:16:49 <Andrey_> merijn: that makes sense, thanks. However, since I already implemented acid-state would I have any other benefits except persistency ?
17:17:13 <Andrey_> merijn: over regualar data structures
17:17:20 <merijn> Andrey_: Not really, and actually STM would make you far more flexible, because it can (unlike acid-state) store functions
17:17:21 <sclv> so that's just a 1-truncated subuniverse of HoTT then?
17:17:46 <Saizan> hSet-truncated
17:17:47 <jonsterling> sclv: And he has other obligations to aspects of actual ETT implementations which are not intrinsic to ETT itself.
17:18:22 <Andrey_> merijn: ok, I guess it's not too hard to convert from acid state map to regular map - just remove the acid
17:18:23 <vanila> im sad that epigram isn't going to be a real language
17:18:27 <vanila> it sounded like the best thing ever
17:21:29 <benzrf> vanila: how so
17:22:00 <vanila> it had a new theory and lots of generic programming stuff that other languages still haven't done
17:22:24 <merijn> vanila: Implement your own! :)
17:22:54 <vanila> well you know it's possible for fans to pick up epigram2 and work on that, I think it'ss even somewhat usable in its current state
17:23:02 <vanila> but I don't think I can do that
17:23:25 <sclv> jonsterling: i'm not sure i follow that latter statement
17:23:56 <sclv> Saizan: yeah, whoops, i always forget where to start counting :-(
17:24:08 <sclv> if i just call them set and prop i guess that makes my life easier
17:24:23 <trap_exit> tell :: (StrictWriter w) => w -> StrictWriter w () tell = Control.Monad.Writer.Strict.tell
17:24:25 <trap_exit> what am I doing wrong here?
17:24:25 <dolio> You start counting at -2.
17:24:34 <sclv> dolio: yes. i know. but i always forget.
17:24:41 <dolio> :)
17:25:57 * sclv still can't parse "obligations to aspects of ETT implementations"
17:26:14 * jonsterling is writing a wall of text to sclv
17:26:45 <jonsterling> sclv: Existing sclv implementations do not actually spit out checkable proof artifacts (typing derivations). Basically, a gigantic ML program tells you whether or not your argument suffices; theoretically, a huge typing derivation is generated using tactics, but in practice you don't actually get to see this. As opposed to Coq, where the full proof term is
17:26:45 <jonsterling> built for you. But this isn't intrinsic to ETT—it's just a practical matter that the proof terms would be so massive that it would be intractable. Conor says this is not a problem in practice for ITT, but I have heard Jason Gross say that he has dealt with proof terms in Coq which are way bigger than is practical.
17:26:59 <jonsterling> Whoops, not "sclv implementations" but "ETT implementations"
17:27:56 <vanila> I think Conors point is that if you hvae huge proof terms, you might want to  prove things differently - like using reflection?
17:27:58 <sclv> ok, so conor wants to keep that "irrelevance" feature?
17:28:06 <merijn> trap_exit: Well, what is StrictWriter? It appears to be used as both constraint and type?
17:28:51 <sclv> that's one of the issues right, can we frame that in terms of truncation in a nice way?
17:29:13 <sclv> like take advantage of that structure to be better at mere results
17:29:20 <jonsterling> sclv: I think it's just a matter of building in a privileged setoid universe that behaves like OTT operationally.
17:30:01 <sclv> ok, i'll make do with that for now.
17:30:42 <Saizan> jonsterling: btw, what would you think equality should be for your "realize M in N" construct?
17:31:21 <sclv> i haven't studied OTT deeply enough to parse your explanation fully, but it certainly helps
17:31:26 <jonsterling> Saizan: I am not sure yet. What I really want is for equality to be defined over extracted terms a la ICC(*), but it remains to be seen if I can get everything I want and still keep subject reduction.
17:31:43 <jonsterling> Clearly a meaning explanation for "realize M in N" is still forthcoming, if one can exist :)
17:32:47 <vanila> What is realize M in N?
17:33:01 <jonsterling> vanila: It's from a bizarre little idea I wrote up here: http://www.jonmsterling.com/posts/2014-06-30-a-type-theory-with-scoped-realizability.html
17:34:13 <codehero> "The most common use case with flip is calling it with just the function parameter and then passing the resulting function on to a map or a filter." could somebody give me an example for that?
17:34:16 <Saizan> btw, how does basing your theory on realizers relate to wanting more than one model?
17:34:38 <jonsterling> Saizan: What about wanting more than one model?
17:34:45 <Saizan> > zipWith (flip (-)) [0..] [1..]
17:34:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:34:56 <Saizan> > zipWith ((-)) [0..] [1..]
17:34:58 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
17:35:11 <codehero> oh. okay
17:35:14 <codehero> cool. thank you :)
17:35:44 <Saizan> jonsterling: well, like for MLTT we have the interpretation in Set, in Set^C, omega-groupoids, etc..
17:36:16 <Saizan> i.e. the inference rules are valid for all of those
17:36:51 <sclv> that's an interesting post
17:36:56 <Saizan> but it seems like Nuprl is more about fixing a model and then adding inference rules as you need them
17:37:18 <jonsterling> Saizan: ETT is got when you take the standard meaning explanations as definitive; whilst there are probably multiple semantics for ETT, ETT is indeed more about making the syntax do *everything* the semantics can.
17:38:56 <jonsterling> If you consider ETT as a syntax tailor-made for realizability semantics, you must note that there is one thing which ETT does not have which realizability does have, which is Church's Thesis. So it's more expedient to consider the open-ended nature of the meaning explanations, and say that realizability is a semantical formulation which is slightly more
17:38:56 <jonsterling> restrictive.
17:39:51 <Saizan> jonsterling: otoh, we also know that ETT ~ LCCC
17:40:03 <hiptobecubic> what the hell are you guys talking about
17:40:20 <jonsterling> Oh no! The #Haskell police are onto me!
17:40:35 <merijn> hiptobecubic: Type theory :)
17:41:45 <trap_exit> can somoene enlightened in template haskell give me a hand and help me do the follwoing conversion? https://gist.github.com/anonymous/22d52a0a757e488553e0 (it's a simple sequence_ ==> for_)
17:41:45 <trap_exit> thanks!
17:42:06 <jonsterling> This is a good post: http://existentialtype.wordpress.com/2013/01/28/more-is-not-always-better/
17:42:24 <Saizan> i guess the two approaches are kind of in contrast, to say ETT ~ LCCC you have to stop the BHK guys before they add more inference rules :)
17:42:29 <jonsterling> And this is a good thread: http://uf-ias-2012.wikispaces.com/file/view/IAS%20-%20MEANING%20EXPLANATION%20DISCUSSION/390300226/IAS%20-%20MEANING%20EXPLANATION%20DISCUSSION
17:42:39 <jonsterling> Saizan:  I think so :)
17:44:03 * Saizan cannot stop being a formalist
17:44:41 * jonsterling is caught between worlds
17:44:42 <TallerGhostWalt> anyone using irc clients in emacs?
17:44:49 <TallerGhostWalt> favorites?
17:44:56 <genericpersona> erc?
17:45:01 <genericpersona> i used to use that
17:45:04 <genericpersona> it was pretty good
17:45:13 <TallerGhostWalt> i use rcirc right now
17:45:16 <TallerGhostWalt> but I need notifications
17:45:29 <genericpersona> get out of emacs and use a real client :)
17:45:43 <enthropy> trap_exit: that doesn't look easy to do with TH, but you could write something   [for| x in xs |] $ do -- multi line body --
17:45:54 <TallerGhostWalt> well... sure
17:46:03 <enthropy> which can expand out to what you have
17:46:06 <TallerGhostWalt> but that first part
17:46:16 <haasn> enthropy: But why not write for xs $ \x -> do
17:46:17 <Saizan> enthropy: x would be out of scope in the do block
17:46:27 <enthropy> oh true
17:50:20 <RchrdB> TallerGhostWalt, I used to use Erc. It worked fine, except that its support for SSL was not good at the time I used it (tended to deadlock at odd moments, leaving the editor unresponsive)
17:51:10 <RchrdB> TallerGhostWalt, the reason I *stopped* using Erc is that it was too effective at telling me when new messages came in, so I switched to a *less* useful IRC client on purpose to reduce that issue. :)
17:51:53 <TallerGhostWalt> Rchrd8: That is great
17:52:11 <TallerGhostWalt> I'll have to try it out
17:52:24 <RchrdB> yw
17:52:51 <shachaf> MyCatDeadlocks
17:57:34 * hackagebot yesod-mangopay 1.7.1 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.7.1 (FelipeLessa)
18:02:35 * hackagebot mangopay 1.8.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.8.1 (FelipeLessa)
18:07:41 <llovelock> Hi, I'm running into troubles trying to build haskell platform for ubuntu 12.04
18:09:26 <llovelock> error is http://lpaste.net/108878
18:10:28 <dibblego> llovelock: I suggest installing ghc only on linux
18:10:57 <llovelock> dibblego: what do you mean by that?
18:12:32 <llovelock> do you mean the platform probably won't compile?
18:12:49 <benzrf> @let newtype APF p a b = APF {unAPF :: p a b}
18:12:52 <lambdabot>  Defined.
18:14:00 <benzrf> @let instance Arrow p => Profunctor (APF p) where dimap f g (APF a) = APF (arr f C.. a C.. arr g)
18:14:02 <lambdabot>  .L.hs:155:38:
18:14:02 <lambdabot>      Could not deduce (b ~ d)
18:14:02 <lambdabot>      from the context (Arrow p)
18:14:02 <lambdabot>        bound by the instance declaration at .L.hs:154:10-40
18:14:02 <lambdabot>        ‘b’ is a rigid type variable bound by
18:14:10 <benzrf> @let instance Arrow p => Profunctor (APF p) where dimap f g (APF a) = APF (arr h C.. a C.. arr f)
18:14:11 <lambdabot>  .L.hs:155:38:
18:14:11 <lambdabot>      Could not deduce (FromExpr d) arising from a use of ‘h’
18:14:11 <lambdabot>      from the context (Arrow p)
18:14:11 <lambdabot>        bound by the instance declaration at .L.hs:154:10-40
18:14:12 <lambdabot>      Possible fix:
18:14:14 <benzrf> @let instance Arrow p => Profunctor (APF p) where dimap f g (APF a) = APF (arr g C.. a C.. arr f)
18:14:15 <lambdabot>  Defined.
18:14:17 <benzrf> there
18:14:17 <glguy_> Do that in /msg please
18:14:29 <benzrf> is that law-abiding?
18:17:20 <bb010g> Does lambdabot have separate @lets per channel/privmsg?
18:17:23 <benzrf> no
18:17:50 <shachaf> No.
18:18:53 <kvanb> so theoretically, could poison lambdabot using private messages
18:18:57 <kvanb> \o/
18:19:07 <ydl> this is an ill-formed question, but i am trying to compile fortran code for future interop with haskell. i have this working on linux with gfortran, but am trying to get it on windows. the issue is that ghc bundles gfortran but not the f951 executable in the installation. I am wondering what to do, since it seems it is not advised to get my own version of mingw and friends
18:19:36 <ydl> should i not worry so much, or does this mean i have to compile ghc on my own?
18:19:49 <kvanb> ydl: I think merijn said it would work
18:20:17 <merijn> ydl: Get a version of f951 that has the same ABI as the gcc that GHC bundles, that should work
18:20:22 <ydl> kvanb, sorry, i got disconnected at some point (bad internet here). could you summarize what he said?
18:20:26 <kvanb> ^
18:20:29 <ydl> ah
18:20:43 <ydl> any ideas on how to do that? :)
18:21:34 <ydl> ghc bundles gcc 4.6.3, which is a ways behind the current version.
18:25:07 <hiptobecubic> ghc bundles gcc?
18:25:26 <merijn> hiptobecubic: For linking and CPP
18:25:32 <merijn> hiptobecubic: (on windows)
18:26:20 <ydl> merijn, sorry to keep bothering you, but do you know anywhere i can grab the appropriate f951 executable? or do i have to find gcc-4.6.3 and build it myself?
18:26:48 <merijn> I'm afraid that it's likely the latter, but I'm not sure, I don't really do much windows development
18:28:08 <sixthgear> my first haskell program https://gist.github.com/sixthgear/370e18bb5c4444f84294 im quite pleased it actually works
18:28:22 <benzrf> sixthgear: hella
18:28:41 <codehero> sixthgear: nice ^^
18:29:14 <hiptobecubic> sixthgear, :)
18:29:14 <sixthgear> guess ill try the opposite direction now which should be interesting
18:29:19 <codehero> and this is mine     main = print $ sum [ x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
18:29:21 <codehero> :P
18:29:43 <benzrf> :t intereac
18:29:44 <lambdabot>     Not in scope: ‘intereac’
18:29:45 <lambdabot>     Perhaps you meant one of these:
18:29:45 <lambdabot>       ‘interact’ (imported from Prelude),
18:29:45 <benzrf> :t interact
18:29:46 <lambdabot> (String -> String) -> IO ()
18:30:02 <ydl> merijn, is there a way to find out what version of mingw ghc is bundled with?
18:30:07 <ydl> (different from gcc version)
18:30:17 <benzrf> codehero: main = interact (decToRoman . read)
18:30:35 <merijn> ydl: No clue, maybe someone in #ghc or the mailing lists knows
18:30:45 <benzrf> fyi there are more programmtic ways to translate roman numerals
18:30:49 <bb010g> sixthgear: Try Integer instead of Int.
18:31:00 <ydl> i hate windows
18:31:05 <sixthgear> this time i jumped right to the Input/Output section of lyah which allowed me to gain that sliver of understanding of how the fuck its actually possible to build programs in this thing ;)
18:32:04 <benzrf> sixthgear: do u grok how IO wokrs
18:32:10 <benzrf> can u do io w/o do notation
18:32:53 <sixthgear> i grok very little benzrf but i do have a basic grasp on IO type and the <- operator
18:33:28 <benzrf> sixthgear: it is fairly simple
18:33:35 <benzrf> (>>=) on IO has the type:
18:33:43 <monochrom> good to hear. but I still like my explanation better: http://www.vex.net/~trebla/haskell/IO.xhtml
18:33:45 <benzrf> :t (>>=) `asAppliedTo` getLine
18:33:46 <lambdabot> IO String -> (String -> IO b) -> IO b
18:33:53 <benzrf> s/String/a/g
18:34:22 <benzrf> sixthgear: the key point is that do-notation does not actually "do" something
18:34:31 <benzrf> sixthgear: it's just sugar for composing theoretical actions
18:35:02 <sixthgear> ok, i can accept that
18:35:15 <benzrf> sixthgear: there is no way to do side effects in haskell (without cheating)
18:35:29 <benzrf> what you CAN do is build up a value describing the side effects you want, and leave it in a specific place
18:35:42 <benzrf> then the compiler knows that 'running the program' means executing the value stored in the `main' nam
18:35:45 <benzrf> *name
18:35:51 <benzrf> but YOU cannot run an IO action
18:35:56 <benzrf> you can just indicate which one the compiler should run
18:36:26 <sixthgear> this feels like there is no spoon
18:36:27 <merijn> The compiler can't run them either
18:36:30 <merijn> The runtime runs them
18:36:31 <sixthgear> ;)
18:36:33 <benzrf> the reason why that's an important distinction is that you cannot dynamically generate new IO values and run them *from within a function*
18:36:44 <benzrf> the only way to get an action to run is to stick it to the single main action
18:36:46 <merijn> sixthgear: There's a really in depth of explanation of why IO is pure in haskell here: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
18:37:31 <sixthgear> benzrf: if i recomposed main with using do , would that help me understand your point better?
18:38:14 <shachaf> I'm not sure that that explanation is that great.
18:38:16 <benzrf> sixthgear: well, look at it this way
18:38:21 <shachaf> But then again I'm just a h8r these days.
18:38:24 * shachaf sighs.
18:38:31 <benzrf> sixthgear: let's say i have some function of type `Int -> Int', ok?
18:38:36 <sixthgear> err i meant without
18:38:37 <monochrom> then promote my explanation :)
18:38:39 <sixthgear> sure ok
18:38:49 <benzrf> sixthgear: i *know* that that function must be pure
18:38:56 <benzrf> let's say i tried to do this:
18:39:05 <benzrf> f x = x + 1
18:39:09 <sixthgear> monochrom merijn shachaf: ill read both
18:39:12 <benzrf>   where fx = putStrLn "oh no"
18:39:29 <benzrf> sixthgear: even without laziness, that is not an effectful thing
18:39:37 <shachaf> Oh, if monochrom says something it's probably good.
18:39:54 <merijn> shachaf: I'm not sure it's great, but I think it covers some stuff that monochrom's explanation does put as much attention too, so I'd say read both :p
18:39:55 <benzrf> because putStrLn does not put a string, it *gives you an action which would print the string, if you ran it*
18:40:13 <benzrf> sixthgear: so if you somehow ran the value stored in `fx', it would print "oh no"
18:40:48 <shachaf> I wrote a mini-explanation once at http://stackoverflow.com/a/13538351
18:40:52 <benzrf> sixthgear: but the only way to get an action to be run is to stick it into whatever is stored in `main'. and calling the function cannot go back and add something to main
18:41:04 <benzrf> sixthgear: therefore, the function cannot actually do anything with the action
18:41:36 <merijn> sixthgear: The basic idea of pure functions is that it returns the same output for the same input, so "if x == y then f x == f y"
18:41:56 <benzrf> merijn: dont forget effect-free
18:42:21 <sixthgear> hmm yeah i understand the basics to that degree merijn
18:42:54 <benzrf> sixthgear: what languages do you already know
18:43:23 <sixthgear> my mainstays are python, c, go and js
18:43:49 <benzrf> sixthgear: cool
18:44:01 <benzrf> 1 sec
18:45:14 <benzrf> sixthgear: here, look at this http://bpaste.net/show/564450
18:45:40 <sixthgear> looking
18:45:53 <benzrf> sixthgear: haskell IO works more or less like this, except that there's no way to call run()
18:47:03 <benzrf> sixthgear: you get to use bind() and then()
18:49:10 <sixthgear> ok, i get it benzrf, i've used similar concepts (i think) in python
18:49:38 <benzrf> sixthgear: (>>=) is bind, (>>) is then
18:49:59 <benzrf> hprint <-> putStrLn, hinput <-> getLine
18:50:24 <benzrf> getLine >>= putStrLn <-> bind(hinput, hprint)
18:50:44 <benzrf> sixthgear: do-notation is just sugar for (>>=) and (>>)
18:53:04 <sixthgear> benzrf: sorry, you used <-> is that related?
18:53:24 <bts-> yes
18:53:29 <benzrf> nah that's just 'is the same as'
18:53:32 <benzrf> not formal notation :p
18:53:37 <sixthgear> rgr
18:54:46 <sixthgear> benzrf: so using that i just made an echo loop with: main = getLine >>= putStrLn >> main
18:54:53 <mmachenry1> Does anyone know why I get this error when I follow the "how to build a haskell program" tutorial? http://lpaste.net/108882
18:55:09 <mmachenry1> It's just saying "ExitFailure 1"
18:55:55 <shachaf> It's saying a whole bunch of things before that.
18:56:00 <mmachenry1> Assuming it's not blocking on LICENSE which cabal allowed me to have none
18:56:15 <shachaf> It'd say even more things if you added -v to the options.
18:56:32 <shachaf> Without that I'd have to guess that it's LICENSE. Did you try making one?
18:56:59 <mmachenry1> I just did. It worked :( Sorry should have earlier
18:57:07 <mmachenry1> That's silly.
18:57:57 <splintax> you can alos just delete the 'license-file' field from your *.cabal file
18:58:01 <benzrf> sixthgear: correct!
18:58:15 <ydl> kvanb, merijen seems to have gone, but i fixed my problem by downloading the original tarball from ghc-tarballs and copying f951 into the relevant directory. is there somewhere i can suggest that GHC bundle this by default?
18:58:20 <benzrf> oops i thought you were asking if that was what it does
18:58:37 <kvanb> they probably won't.
18:58:41 <kvanb> not many people use fortran
18:58:59 <benzrf> sixthgear: anyway, back in the day, people used to write code like
18:59:01 <kvanb> but you can suggets it on the trac probably or send an email to hte list
18:59:11 <benzrf> getLine >>= \text ->
18:59:17 <benzrf> putStrLn "processing..." >>
18:59:24 <benzrf> sleep 1000 >>
18:59:30 <benzrf> putStrLn (reverse text)
18:59:35 <platz> do I need type families to return a specific type from a typeclass instance?  http://lpaste.net/108883#line33
18:59:45 <benzrf> sixthgear: then somebody had the bright idea of inventing sugar to make that into:
18:59:52 <benzrf> text <- getLine
18:59:56 <benzrf> putStrLn "processing..."
18:59:59 <benzrf> sleep 1000
19:00:01 <benzrf> putStrLn (reverse text)
19:00:06 <geekosaur> platz: you can't choose the type
19:00:38 <ydl> kvanb, sure, but it's one executable. they included gfortran anyway, it doesn't add much size. i'll email them. thanks
19:00:49 <platz> hrm, so I can't say addition should be al RValue
19:02:04 <codehero> lol. i'm an idiot
19:02:16 <codehero> i just forgot that lambdas don't have a name...
19:02:23 <platz> I thought about splitting it into separate instances for LValue and RValue with FlexibleInstances, but then i can't add an LValue and an RValue
19:02:29 <codehero> so i thought the first parameter was the name of the lambda ...
19:02:32 <codehero> grr
19:03:36 <benzrf> codehero: hah
19:03:42 <codehero> yeah
19:03:51 <codehero> caused some trouble while looking at foldr
19:04:05 <codehero> i was thinking "wait. how can this work?"
19:07:45 <platz> (Actually a multi parameter type classes should be able to convert between the two)
19:08:01 <neuroserpens> lmfao... I don't know a thing about haskell, but people say this is one of the coolest irc channels out there and that you guys can  even turn trolls into haskell students by being super nice roflmfao!!!
19:08:27 <vanila> neuroserpens, its' true :) ive seen it
19:08:35 <neuroserpens> vanila: lmaoo
19:08:36 <kristof> I have seen it, too.
19:08:36 <codehero> man
19:08:51 <codehero> i will wait for the day i can see it
19:08:58 <neuroserpens> I laughed SOOOO HARD AT THIS https://news.ycombinator.com/item?id=7161236
19:09:13 <neuroserpens> In fact I'm still laughing ROFL
19:09:42 <benzrf> neuroserpens: by entering the channel u have legally bound yourself to learn haskel
19:09:45 <benzrf> l
19:10:09 <glguy> Yeah... Part of our EULA
19:10:28 <neuroserpens> lmao
19:10:32 <codehero> you might be pleased to learn that you can compile
19:10:34 <codehero> | haskell to javascript now
19:10:36 <codehero> :O
19:10:45 <neuroserpens> HAHAHAHA ^
19:10:45 <Guest57227> trolls weakness is getting treated as if he wasnt trolling
19:10:47 <codehero> need.to.google
19:11:22 <pharaun> yup
19:11:23 <neuroserpens> it's funny because even though the language I can do virtually anything with is python, I've worked with many others but no haskell up to now
19:11:29 <benzrf> neuroserpens: you're first task: write a function in haskell that takes n and gives the nth fib number
19:11:35 <neuroserpens> So I think I'm truly bound to learn it now haha
19:11:53 <neuroserpens> benzrf: don't underestimate my intelligence lol that's too easy
19:11:55 <shachaf> neuroserpens: Trolling is not appreciated here. The general policy is to make this a pleasant environment, not to convince people to learn Haskell or to pander to trolls.
19:12:25 <benzrf> neuroserpens: ah, but it will require learning the syntax
19:12:50 <EvanR> syntax is a minor part of learning to program
19:12:59 <neuroserpens> I think I'll translate my hackerrank solutions from python to haskell for fun
19:13:41 <benzrf> EvanR: its a necessary 1st step
19:13:52 <vanila> it's frustrating that hackerrank doesn't let you do haskell
19:13:54 <codehero> python isn't too bad. it actually has something like list comprehensions oO
19:14:00 <neuroserpens> vanila: haha
19:14:09 <vanila> i wanted to find a site like that for haskell
19:14:10 <neuroserpens> codehero:  python rules man
19:14:19 <codehero> i still like haskell more :P
19:14:26 <codehero> i'm just two days in and i love it
19:14:33 <neuroserpens> vanila:  you should try hacker.org... several problemas are language agnostic
19:14:39 <vanila> okay, thanks
19:14:49 <neuroserpens> problems*
19:15:18 <glguy> Rosalind.info is nice, too
19:15:24 <codehero> hmm. flash?
19:16:16 <sixthgear> benzrf: https://gist.github.com/sixthgear/370e18bb5c4444f84294 so i reworked that with new understanding, i see what the sugar was doing
19:17:07 <sixthgear> but i'll have to come back to it later, gotta run for now, thx all for help
19:19:18 <neuroserpens> good thing afj quit php dev... php gives me the creeps lol
19:19:31 <codehero> php is really bad
19:19:54 <benzrf> sixthgear: np
19:19:58 <neuroserpens> can you believe I.T. people in the fucking brazilian ministries work with windows machines and php?
19:20:05 <benzrf> https://en.wikipedia.org/wiki/Monad_%28Gnosticism%29 <- its a conspriacy
19:20:07 <benzrf> neuroserpens: yes, i can
19:20:10 <neuroserpens> this is the fucking stone age
19:20:12 <codehero> it was the first language i was playing around with. by that i mean copy/pasting some login together
19:21:14 <neuroserpens> there is a very good article about php
19:21:22 <neuroserpens> i think  it's called "a fractal of bad design"
19:21:27 <Hodapp> neuroserpens: yes.
19:21:29 <pharaun> oh
19:21:34 <pharaun> i know the guy who wrote that article
19:21:38 <neuroserpens> lmfao
19:21:39 <pharaun> anyway let's not bash php in here
19:21:46 <neuroserpens> yes let's
19:21:46 <shachaf> ==pharaun
19:21:47 <codehero> neuroserpens: i've seen that one
19:21:48 <neuroserpens> xD
19:21:54 <shachaf> neuroserpens: This channel is about Haskell. Please no language bashing.
19:21:59 <pharaun> or other languages, we should focus on haskell or productive discussing, no bashing
19:22:14 <codehero> right. no language bashing
19:22:15 <neuroserpens> bashing php is productive discussing rofl
19:22:19 <pharaun> no it is not
19:22:21 <hiptobecubic> French is the worst!
19:22:23 <neuroserpens> xD
19:22:25 <codehero> :D
19:22:37 <neuroserpens> codehero i want to add you on facebook
19:22:40 <hiptobecubic> Or should I say het Nederlands in here :)
19:22:42 <codehero> i guess it's safe to say that haskell is the best language. we can just leave it at that
19:22:48 <codehero> neuroserpens: i don't have facebook
19:22:59 <neuroserpens> codehero: lame
19:23:05 <codehero> why?
19:23:08 <codehero> i deleted my account
19:23:09 <shachaf> neuroserpens: You're behaving like a troll. Stop it.
19:23:17 <neuroserpens> shachaf: :(
19:23:24 <hiptobecubic> typical troll frown
19:23:59 * neuroserpens is sad now
19:24:07 <vanila> neuroserpens, don't worry about it most people in here are nice
19:24:31 <neuroserpens> shachaf killed my will to learn haskell :(
19:24:55 <codehero> repeat 'willpower'
19:25:02 <codehero> here's enough willpower for everyone
19:25:13 <hiptobecubic> codehero, you forgot >
19:25:19 <codehero> lol
19:25:22 <Saizan> learning needs a bit more calm than what you were showing :)
19:25:25 <codehero> i don't want to spam :D
19:25:49 <codehero> > take 10 (repeat 'willpower')
19:25:51 <lambdabot>  Syntax error on 'willpower'
19:25:51 <lambdabot>  Perhaps you intended to use TemplateHaskell
19:25:53 <codehero> hmm
19:25:56 <codehero> duh
19:26:04 <codehero> > take (repeat 'willpower') 10
19:26:06 <lambdabot>  Syntax error on 'willpower'
19:26:06 <lambdabot>  Perhaps you intended to use TemplateHaskell
19:26:07 <slack1256> http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
19:26:12 <codehero> i'm doing it wrong
19:26:14 <slack1256> it brings tears to my eyes.
19:26:15 <Saizan> double quotes
19:26:22 <codehero> oh yeah :P
19:26:31 <codehero> > take 10 (repeat "willpower")
19:26:33 <lambdabot>  ["willpower","willpower","willpower","willpower","willpower","willpower","wi...
19:26:36 <codehero> i'm stupid
19:26:56 <neuroserpens> for x in range(10): print('willpower')
19:27:13 <hiptobecubic> neuroserpens, wrong paradigm
19:27:25 <l0cust> ["willpower" | _ <- [1..10]]
19:27:36 <codehero> :)
19:27:36 <l0cust> ["willpower" | x <- [1..10]]
19:27:40 <l0cust> > ["willpower" | _ <- [1..10]]
19:27:42 <lambdabot>  ["willpower","willpower","willpower","willpower","willpower","willpower","wi...
19:27:46 <l0cust> there we go, forgot the >
19:27:51 <hiptobecubic> > forM_ [1..10] (print "willpower")
19:27:53 <lambdabot>  Couldn't match expected type ‘a0 -> m b0’
19:27:53 <lambdabot>              with actual type ‘GHC.Types.IO ()’
19:28:02 <neuroserpens> ok this is spam
19:28:06 <neuroserpens> you are all behaving like trolls
19:28:08 <neuroserpens> stop it
19:28:21 <hiptobecubic> :t forM_
19:28:22 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
19:28:27 <hiptobecubic> oh whoops
19:28:38 <glguy> > "Codegolf"<$ [0..9]
19:28:40 <lambdabot>  ["Codegolf","Codegolf","Codegolf","Codegolf","Codegolf","Codegolf","Codegolf...
19:28:40 <codehero> > ["trololo" | _ <- [1..10]]
19:28:42 <lambdabot>  ["trololo","trololo","trololo","trololo","trololo","trololo","trololo","trol...
19:28:48 <neuroserpens> HAHAHA ROFL
19:28:53 <ezrios> > putStrLn "do you even liftM"
19:28:55 <lambdabot>  <IO ()>
19:28:55 <l0cust> > mapM_ (\_ -> print "willpower") [1..10]
19:28:56 <lambdabot>  <IO ()>
19:29:15 <slack1256> Guys, remember you can /msg lambdabot
19:29:25 <neuroserpens> lmao this really is one of the coolest irc channels ever
19:29:26 <l0cust> slack1256: that's too easy
19:29:46 <shachaf> neuroserpens: Your behavior is indistinguishable from a troll. If you keep going you'll be banned.
19:29:54 <neuroserpens> wtf
19:30:03 <hiptobecubic> shachaf, what are you talking about?
19:30:29 <hiptobecubic> :t (<$)
19:30:31 <lambdabot> Functor f => a -> f b -> f a
19:30:42 <ezrios> what the hell is that
19:30:50 <hiptobecubic> ezrios, ask glguy
19:30:54 <l0cust> ezrios: it's a functor operator
19:30:57 <ezrios> > 4 <$ [1,3,5]
19:30:59 <lambdabot>  [4,4,4]
19:31:06 <ezrios> so it's like const
19:31:06 <codehero> umm
19:31:09 <ezrios> in a functorial context?
19:31:12 <codehero> what's the use of that?
19:31:21 <ezrios> I guess it's a lifted const
19:31:39 <codehero> > *3 <$ [1,3,5]
19:31:41 <lambdabot>  <hint>:1:1: parse error on input ‘*’
19:31:48 <l0cust> :t pure
19:31:50 <lambdabot> Applicative f => a -> f a
19:31:51 <codehero> > (*3) <$ [1,3,5]
19:31:53 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
19:31:57 <ezrios> > "wat" <$ repeat 42
19:31:59 <lambdabot>  ["wat","wat","wat","wat","wat","wat","wat","wat","wat","wat","wat","wat","wa...
19:32:02 <ezrios> yeah
19:32:06 <codehero> ah
19:32:08 <ezrios> it's like a lifted const
19:32:12 <l0cust> :t const
19:32:14 <lambdabot> a -> b -> a
19:32:26 <glguy> Handy when defining parsers:  True <$ string "true"
19:32:28 <hiptobecubic> lambdabot can show functions?!
19:32:29 <neuroserpens> > "ban my ass then shachaf" <$ repeat 666
19:32:32 <lambdabot>  ["ban my ass then shachaf","ban my ass then shachaf","ban my ass then shacha...
19:32:40 <hiptobecubic> neuroserpens, ok now you're a troll.
19:32:46 <ezrios> lmao
19:32:46 <neuroserpens> :(
19:33:00 <neuroserpens> hiptobecubic: I thought you were on my side :(
19:33:17 <hiptobecubic> neuroserpens, that was before you acted like a dick head
19:33:26 <neuroserpens> :(
19:33:47 <nitrix> ezrios: Thrift Shop ?
19:33:50 <neuroserpens> at least i learned some haskell from ezrios >:|
19:33:56 <ezrios> nitrix: what
19:34:11 <geekosaur> ":(" doesn't cut it. there are standards for behavior in this channel.
19:34:35 <neuroserpens> they started it  :(((
19:34:43 <geekosaur> wat
19:34:47 <slack1256> neuroserpens: are you reading a haskell book if so which?
19:34:57 <ezrios> slack1256: highly recommend LYAH and RWH
19:35:03 <codehero> RWH?
19:35:05 <neuroserpens> slack1256: ezrios is teaching me
19:35:07 <ezrios> Real World haskell
19:35:08 <l0cust> ezrios: rwh is horrifyingly out of date
19:35:09 <neuroserpens> slack1256: he is my mentor
19:35:15 <slack1256> oh, I want to know about more of his/her context
19:35:18 <Clint> l0cust: yes
19:35:18 <l0cust> @where rwh
19:35:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:35:19 <ezrios> l0cust: so is LYAH for that matter
19:35:26 <ezrios> before the great monad transformer API change
19:35:27 <hiptobecubic> yeah rwh was pretty frustrating
19:35:39 <l0cust> ezrios: not nearly as badly as rwh
19:35:40 <ezrios> I still found RWH pretty instructive
19:36:01 <ezrios> the rest of the information I've gleaned from trolling this channel, hackernews, google, reddit, and academic papers
19:36:05 <ezrios> but I don't know jack shit
19:36:13 <vozz> I just started readingParallel and Concurrent Programming in Haskell, it's really good
19:36:17 <ezrios> probably the largest Haskell program I've written is my xmonad config
19:36:32 <hiptobecubic> which is no small feat
19:36:33 <vozz> anyone got any other recomendations?
19:36:47 <ezrios> vozz: ah, that one's on my reading list
19:36:51 <ezrios> skimmed it over, looks very good
19:36:57 <splintax> i've been reading Types and Programming Languages (Pierce). not about haskell but very applicable
19:37:17 <vozz> It's really good at explaining things clearly
19:37:30 <ezrios> I've never done parallel or concurrent programming though
19:37:52 <hiptobecubic> well don't learn it in haskell, you'll be spoiled forever
19:37:53 <vozz> Neither, that's why I'm reading it :)
19:38:06 <pharaun> rwh was pretty outdated but i still found it very instructive
19:38:08 <l0cust> :t seq
19:38:10 <lambdabot> a -> b -> b
19:38:24 <pharaun> and it is still imo a good starting place, after that i liked the paralle and concurrent programming book it was nice
19:39:04 <nitrix> Still learning here. The whole `let in`, `where`, `pattern matching`, `guards`, it's all very cool but why not one unified way of doing thing.
19:39:16 <nitrix> Seriously, I don't even know which one to know and when.
19:39:29 <ezrios> I think they are different constructs entirely
19:39:38 <vozz> I'm thinking about reading  Algorithms: A functional programming approach, it looks pretty good. There's another book also about functional algorithms, with examples in ML and Haskell (although the haskell ones are in an appendix or something), but I forgot the name of it, does anyone know it?
19:39:40 <hiptobecubic> let in and where are similar
19:39:40 <nitrix> The entire language so far seems _great_, it's just, what the heck that part...
19:39:43 <slack1256> I really think haskell-wiki should have a course-track of learning haskell as a series of blogposts from gabriel, ocharles, simons and a series of papers, rws LYAH told what I needed to learn, the blogpost and papers helped cement the knowledge
19:39:44 <hiptobecubic> but let in is an expression
19:39:47 <ezrios> I believe you can substitute `let in` in place of any expression
19:40:01 <ezrios> but `where` has some weird rules as to what it can "attach" to
19:40:03 <hiptobecubic> nitrix, it's mostly style and readability
19:40:05 <l0cust> nitrix: that's a bit like asking "why do there exist while loops when for loops also exist"
19:40:19 <pharaun> ordering
19:40:19 <nitrix> l0cust: so why?
19:40:35 <l0cust> nitrix: lexical convenience
19:40:37 <ezrios> pattern matching is deconstructing a value
19:40:38 <pharaun> sometime you care about the let more than the rest, othertime you care about the other code than what is in the where
19:40:47 <yogurt_truck> slack1256: kepp this nearby http://dev.stephendiehl.com/hask/
19:40:50 <ezrios> and boolean guards provide conditional branching on true/false values
19:40:54 <yogurt_truck> keep*
19:41:07 <pharaun> while matching just deconstructs the constructor and extracts values/etc...
19:41:20 <pharaun> guards can have more complicated branching
19:41:49 <vozz> Ah, I found the other book http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
19:42:00 <nitrix> So, there should be almost no case where someone writes a boring if?
19:42:23 <Exio4> an if? what is that?
19:42:31 <Exio4> :P
19:42:41 <slack1256> yogurt_truck: that list really helped me. I understood about recursive-schemes from it.
19:42:43 <vozz> ah, so its data structures
19:42:43 <l0cust> nitrix: i use them in monadic code occassionally
19:43:15 <nitrix> l0cust: I'll get to monads at some point.
19:43:38 <pharaun> nitrix: an if has its place and time, i do write them from time to time
19:43:44 <pharaun> when i don't want to break out into another function
19:43:45 <nitrix> So pattern matching is deconstructing a type to extract the values.
19:43:52 <nitrix> I love that definition.
19:43:55 <nitrix> Great.
19:44:14 <nitrix> Guards does branching based on the arguments?
19:44:17 <nitrix> Only on arguments?
19:44:26 <l0cust> nitrix: boolean values
19:44:27 <vozz> guards is just booleans isnt it?
19:44:41 <nitrix> Oh, okay.
19:44:47 <Exio4> you could see it as a bunch of "if G1 then E1 elseif G2 then E2 ..."
19:45:01 <nitrix> alright.
19:45:53 <nitrix> which leaves `let in`, which I hear can replace any expression since the `in` part is the expression, but its using variables declared by `let`.
19:46:05 <nitrix> So, what is `where`'s purpose then?
19:46:15 <l0cust> nitrix: let, but it's easier to read
19:46:23 <l0cust> nitrix: let can also be used in monadic code
19:46:33 <slack1256> let is local to the branch of the guards, where cover the whole guards
19:46:49 <l0cust> nitrix: where only attaches to top level functions
19:47:12 <slack1256> @where try haskell
19:47:13 <lambdabot> I know nothing about try.
19:47:21 <l0cust> @where tryhaskell
19:47:22 <lambdabot> http://tryhaskell.org/
19:47:28 <slack1256> thanks
19:47:53 <benzrf> nitrix: `let' is an expression
19:48:03 <benzrf> nitrix: `where' introduces bindings at a syntactic level
19:48:24 <benzrf> nitrix: the main difference in actual usefulness is that if you have guards you can attach a where to the function as a whole
19:48:41 <slack1256> ^ this is what I tried but failed to say.
19:49:13 <nitrix> Right.
19:49:37 <nitrix> Because appart from these 4 things, I can reason everything else so far, no problem.
19:50:03 <nitrix> I don't know why these precisely doesn't stick.
19:51:12 <CmdrMoozy> hi all, i have an awful newbie question; i've read the first four chapters of "learn you a ...", and i'm implementing the first (of 99) haskell problem, but i'm running into a type error I don't grok yet because i'm awful - here's my program and the GHC output: http://pastebin.com/yzugzjn9
19:51:40 <nitrix> I'm comming from declarative languages and referential transparency was new to me. List comprehensions too, lazy evaluation, currying, partial application, parametric polymorphism, classtypes, all good so far.
19:51:44 <l0cust> CmdrMoozy: pastebin.com is awful, use lpaste in the future
19:51:55 <codehero> also here are some paste services that can compile and execute haskell code: http://codepad.org/ http://ideone.com/
19:52:03 <geekosaur> CmdrMoozy, so, you are using the == operator on a type `a`
19:52:20 <l0cust> CmdrMoozy: "error" can only be used in the context of a monad
19:52:42 <geekosaur> you have not asserted that `a` supports (==), which is done by adding the context `Eq a` to the type of `testMyLast`
19:52:43 <slack1256> nitrix: somethings are better learned in practice, I recall a paired tryhaskell, if we find I could show you the differences between let in and where
19:52:57 <nitrix> But I hate how every tutorials goes like "Well you can do it this way with patterns", "oh but wait, you can also do it this way with guards", "Now watch, let in", "actually, use a where"...
19:53:08 <ryantrinkle> is there a good library for combined parsing/prettyprinting these days?
19:53:25 <nitrix> Like, seriously, why 4 ways to do the same thing. :(
19:53:39 <slack1256> Do somebody remember the tryhaskell but with two people sharing a session?
19:53:40 <nitrix> We'll see.
19:53:47 <l0cust> codehero: Do you come from a TDD world? That's not how we do things in Haskell
19:53:54 <CmdrMoozy> geekosaur, that makes sense; i shall read more about it online :) thanks :)
19:53:56 <codehero> l0cust: no?
19:54:00 <l0cust> CmdrMoozy: Do you come from a TDD world? That's not how we do things in Haskell
19:54:09 <codehero> btw. what's a TDD world?
19:54:10 <l0cust> sorry codehero, weechat's completion betrayed me
19:54:20 <codehero> heh
19:54:24 <slack1256> Test Driven Development == TDD
19:54:28 <codehero> ah
19:54:34 <l0cust> codehero: it's a thing that people in scripting languages do
19:54:42 <pavonia> l0cust: "error" can be used anywhere
19:54:49 <l0cust> :t error
19:54:51 <lambdabot> [Char] -> a
19:54:52 <CmdrMoozy> l0cust, somewhat; basically for each function in the 99 problems, i'd like some way to assert that they are implemented correctly
19:54:53 <l0cust> huh
19:55:01 <l0cust> I thought it was a monad thing
19:55:03 <l0cust> anyway
19:55:13 <geekosaur> you're thinking of fail
19:55:13 <l0cust> CmdrMoozy: see quickcheck
19:55:18 <l0cust> geekosaur: ahh yes
19:55:37 <CmdrMoozy> l0cust, thanks, I'll read the wiki article :)
19:55:56 <l0cust> @check (\xs -> length (take 5 xs) <= 5)
19:55:58 <lambdabot>  +++ OK, passed 100 tests.
19:56:02 <l0cust> CmdrMoozy: that's what we do
19:56:09 <l0cust> CmdrMoozy: it randomly generates test cases
19:57:02 <codehero> l0cust: whoa. that's awesome
19:57:24 <codehero> what does it mainly check for?
19:57:36 <hiptobecubic> codehero, it checks that your function returns true
19:57:44 <codehero> oh, okay
19:58:02 <hiptobecubic> @check (const False)
19:58:04 <lambdabot>  *** Failed! Falsifiable (after 1 test):
19:58:04 <lambdabot>  ()
19:58:16 <CmdrMoozy> that's actually really cool
19:59:04 <benzrf>       
20:00:10 <l0cust> benzrf:
20:00:21 <codehero> l0cust: benzrf:
20:00:44 <vozz> CmdrMoozy: for testMyLast you need to add "Eq a =>" to the beginning of the type signature, which basically says the type a needs to be a type that has equality so you can use == on it
20:00:46 <l0cust> codehero: l0cust: benzrf:
20:01:28 <codehero> i think we just implemented a stack! \o/
20:01:38 <CmdrMoozy> vozz, indeed, that does it :) I actually was just reading about that syntax online; thanks! :)
20:03:07 <vozz> and then in your main function, map isn't IO, you'd want to do let x = map .... or something
20:03:18 <vozz> but that's a weird way to go about it
20:03:54 <vozz> and yeah just use quickcheck like the others did before :)
20:04:06 <CmdrMoozy> vozz, yeah; i'm reading up on quickcheck so that'll all be different anyway :)
20:07:31 <codehero> funny how you can just omit the parameter if it's at the end
20:07:38 <codehero> currying is so cool
20:08:42 <codehero> @let fn = ceiling . negate . tan . cos . max 50
20:08:44 <lambdabot>  Defined.
20:08:51 <codehero> > fn 8
20:08:53 <lambdabot>  -1
20:09:01 <codehero> > fn 8
20:09:03 <lambdabot>  -1
20:09:03 <codehero> argh
20:09:07 <codehero> > fn -8
20:09:08 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
20:09:09 <lambdabot>    arising from a use of ‘M246531422862486814728406.show_M2465314228624868147...
20:09:09 <lambdabot>  The type variable ‘c0’ is ambiguous
20:09:09 <lambdabot>  Note: there are several potential instances:
20:09:09 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:09:12 <codehero> woot
20:09:20 <codehero> > fn 9001
20:09:21 <lambdabot>  2
20:09:28 <codehero> okay..
20:09:37 <pavonia> > fn (-8)
20:09:39 <lambdabot>  -1
20:09:41 <codehero> i have no idea what this does, but it's cool
20:10:19 <l0cust> :t fn
20:10:20 <lambdabot> (RealFrac b, Integral c, Floating b) => b -> c
20:11:22 <l0cust> :i fn
20:11:29 <l0cust> @info fn
20:11:29 <lambdabot> fn
20:11:35 <l0cust> that's unhelpful
20:11:41 <codehero> :D
20:11:55 <codehero> well. it's a defined function
20:11:59 <codehero> @info map
20:12:00 <lambdabot> map
20:12:02 <codehero> huh
20:12:06 <codehero> lol
20:12:19 <l0cust> @src fn
20:12:20 <lambdabot> Source not found. Are you on drugs?
20:12:28 <l0cust> yes, but that's irrelevant
20:12:32 <codehero> XD
20:12:49 <hiptobecubic> wasn't there something that would reverse engineer function definitions from test cases?
20:13:38 <merijn> l0cust, codehero: @info autocorrects to @undo
20:13:41 <merijn> @undo fn
20:13:41 <lambdabot> fn
20:13:45 <l0cust> fn
20:13:50 <l0cust> :t fn
20:13:51 <lambdabot> (RealFrac b, Integral c, Floating b) => b -> c
20:14:02 <l0cust> merijn: ah
20:14:03 <enthropy> hiptobecubic: "magic haskeller" among many other tools
20:14:04 <merijn> heh
20:15:30 <l0cust> > fn 1
20:15:32 <lambdabot>  -1
20:15:35 <l0cust> > fn 1
20:15:37 <lambdabot>  can't find file: L.hs
20:15:40 <l0cust> > fn 1
20:15:42 <lambdabot>  -1
20:15:57 <l0cust> >fn 2
20:16:07 <l0cust> > fn 2
20:16:09 <lambdabot>  -1
20:16:12 <l0cust> > fn 2
20:16:14 <lambdabot>  -1
20:16:17 <l0cust> damn
20:16:21 <l0cust> anyway
20:16:28 <merijn> l0cust: Please do this sort of testing in private message
20:16:35 <l0cust> merijn: that just occurred to me
20:17:54 <vozz> l0cust: fn of anything less than 50 is going to be the same as 50
20:18:01 <vozz> it's maxing the arg with 50
20:25:33 <codehero> oh. yeah
20:25:34 <codehero> 23:07:14         codehero | @let fn = ceiling . negate . tan . cos . max 50
20:25:48 <codehero> @l0cust
20:25:48 <lambdabot> Unknown command, try @list
20:27:00 <EvanR> > find L.hs
20:27:02 <lambdabot>  Not in scope: ‘L.hs’
20:27:18 <EvanR> > fix L.hs
20:27:20 <lambdabot>  Not in scope: ‘L.hs’
20:31:57 <prsteele> wow, when was the notation (,,) added? I don't ever remember seeing it, but it's nice
20:32:14 <shachaf> You mean (,,) for the constructor of a 3-tuple?
20:32:26 <prsteele> shachaf: yes
20:32:33 <shachaf> It's been around for a long time.
20:32:46 <prsteele> must have just missed it then, thanks
20:33:41 <shachaf> With TupleSections you can write e.g. (1,,3) for (\x -> (1,x,3))
20:34:02 <shachaf> Or (,2,,4) or anything.
20:34:25 <shachaf> But the (,,) syntax has been around since before Haskell 98.
20:34:56 <CmdrMoozy> is there some Bool statement which says "someFunction x results in an error"?
20:35:07 <joelteon> ??
20:35:19 <slack1256> @type try
20:35:20 <lambdabot> Exception e => IO a -> IO (Either e a)
20:35:58 <slack1256> I guess if you do (try $ return (foo a)) you can check in the Either if returns an error/exception
20:37:52 * hackagebot statistics 0.13.2.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.13.2.1 (BryanOSullivan)
20:39:54 <ryantm> How do I make a QuickCheck prop for positive integers?
20:40:47 <ryantm> (not sure that is even the right way to say that)
20:41:12 <joelteon> ryantm: the (==>) operator may be helpful
20:41:20 <Iceland_jack> ryantm: there is a newtype for that
20:41:29 <joelteon> oh yeah, that too
20:41:32 <joelteon> but for the general case, ==>
20:41:47 <Iceland_jack> well if there weren't a newtype you'd just use abs
20:41:58 <Iceland_jack>     prop_testPos (abs -> n) = ... n ...
20:41:58 <joelteon> yeah, that too
20:42:02 <joelteon> but for the general case......
20:42:08 <Iceland_jack> but (==>) works if you need to discard!
20:42:11 <Iceland_jack> yes :)
20:42:18 <joelteon> thank you Iceland_jack
20:42:36 <Iceland_jack> I've just had bad feels with (==>) discarding all my tests heh
20:43:05 <ryantm> Sorry, I saw that newtype but I don't know how to use it.
20:43:25 <ryantm> maybe I should provide an example to modify.
20:43:32 <Iceland_jack> ryantm: there is a newtype called Positive that you can use as
20:43:32 <Iceland_jack>     prop_testPos (Positive n) = ... n ...
20:43:49 <Iceland_jack> Then 'n' will only ever be a positive number
20:45:14 <CmdrMoozy> slack1256, so if i do e.g. "let x = last []", ghci still returns "x :: a" for :t x since "last :: [a] -> a" - how do I test if x is an exception?
20:45:39 <CmdrMoozy> i guess the problem is that x is lazily evaluated
20:46:13 <slack1256> try (return $! (last []))
20:46:15 <slack1256> probably
20:48:06 <pingu> CmdrMoozy: you have to evaluate it, it's a runtime exception.
20:48:30 <ryantm> Iceland_jack, joelteon thanks! I figured it out. I was looking at http://hspec.github.io/quickcheck.html and I needed to replace the x argument of the lambda with (Positive x)
20:48:50 <joelteon> yep, there you go
20:49:22 <joelteon> ryantm, are you new to haskell?
20:49:24 <ryantm> Iceland_jack's pattern match as a function definition got me there finally.
20:49:27 <ryantm> yes!
20:50:21 <augur> anyone know how to compile some C code (that calls haskell) into a library so that i can use it in Xcode?
20:50:53 <joelteon> can you not just import the code into the project and add it to your target?
20:51:20 <augur> joelteon: the haskell+c stuff apparently needs to be compiled with GHC, according to the website
20:51:47 <Iceland_jack> ryantm: if you wanted to discard non-positive inputs you could then do as joelteon suggested
20:51:48 <Iceland_jack>     describe "..." $ do
20:51:48 <Iceland_jack>       it "..." $ property $ \x ->
20:51:48 <Iceland_jack>         x > 0 ==> ...
20:52:12 <merijn> augur: You need to let GHC do the linking I think, yeah. But you can compile the C code however you like
20:52:47 <merijn> augur: But the end result will just be a shared library that you can in turn just link with whatever C code the way you link any shared library
20:52:48 <augur> merijn: what i want tho is to have the GHC stuff compile the C part, and then i want to make a static lib so i can just drop it into Xcode and not worry
20:53:07 <ryantm> Iceland_jack, cool.
20:53:08 <augur> and then compile using Xcode
20:53:08 <merijn> augur: I'm not sure you can compile haskell to a static lib?
20:53:30 <augur> merijn: well, i think i have to use `ar` in terminal to make a lib from .o's
20:53:34 <merijn> augur: I might be wrong, though. But what is wrong with just having Xcode link haskell dynamically
20:53:48 <augur> merijn: can it do that?
20:54:32 <merijn> augur: GHC libraries are just standard shared libraries and anything that's foreign export'ed (or C functions that call haskell) are visible to the linker
20:54:44 <ydl> suppose i have a .a file in my directory tree. how do i tell cabal to link to that file as a library during compilation?
20:54:59 <ydl> i.e. i have "libtest.a" in my package's directory tree
20:55:01 <augur> merijn: right but i dont want to have to futz around with GHC to get my Xcode app to link
20:55:29 <merijn> augur: Just run cabal, get a .so file, have Xcode link the .so file?
20:55:33 <ydl> i've tried to do "extra-libraries: test" but it doesn't work
20:55:50 <augur> merijn: ill investigate that
20:56:07 <merijn> ydl: Just specify -ltest as extra flag to ghc?
20:56:39 <ydl> merijn, will try, but isn't there a "cabaly" version of that?
20:57:08 <merijn> augur: oh, looks like GHC even builds static libraries for some of my stuff
20:57:23 <augur> merijn: oh, fun. :D
20:58:42 <ydl> merijn, so it works if i do '-ltest' to ghc, but not if i pass it as extra-libraries. do you know why that might be?
21:03:18 <enthropy> ydl: have you seen what http://hackage.haskell.org/package/hlbfgsb does?
21:04:01 <enthropy> I'm pretty sure it doesn't build with the most recent ghc/Cabal, but it's another idea
21:05:20 <ydl> so does extra-libraries somehow exclude ".a" files?
21:07:47 <CmdrMoozy> so in reading some things online, i'm thinking that I want to almost always prefer using Maybe instead of exceptions, since exceptions can only be dealt with in do blocks - is this silly?
21:08:49 <benzrf> CmdrMoozy: do blocks are not magickal
21:09:11 <benzrf> and haskell's "exceptions" really shouldnt be used at all except in IO
21:09:38 <geekosaur> CmdrMoozy, it's a bit inaccurate, but it also does touch on a common pattern: when possible we use Maybe or Either / Error so as to handle such things more purely
21:10:02 <merijn> CmdrMoozy: do-blocks are just syntactic sugar for the >>= and >> functions
21:10:32 <geekosaur> (You may find the Error type and/or its monad handy because you can not only indicate failure, but the nature of the failure. "Nothing" doesn't give you much to go by)
21:12:19 <CmdrMoozy> so if I was defining a function to e.g. divide two integers, it would be clean to return Nothing on division by zero?
21:12:39 <CmdrMoozy> doing something like myDiv x 0 = error "Division by zero." seems harder to deal with
21:13:50 <codehero> > 5/0
21:13:52 <lambdabot>  Infinity
21:13:56 <codehero> :O
21:14:00 <codehero> that's cool :D
21:14:16 <splintax> hmm
21:14:19 <splintax> :t Infinity
21:14:21 <lambdabot> Not in scope: data constructor ‘Infinity’
21:14:23 <codehero> but it's also -1/12 i think
21:17:28 <benzrf> :t (1/0)
21:17:29 <lambdabot> Fractional a => a
21:17:34 <benzrf> > 1/0
21:17:36 <lambdabot>  Infinity
21:17:43 <splintax> > 1/0 + 1
21:17:45 <lambdabot>  Infinity
21:17:51 <benzrf> :t id 1/0
21:17:52 <lambdabot> Fractional a => a
21:17:54 <benzrf> hmm
21:18:07 <benzrf> @let infinity = 1 / 0
21:18:09 <lambdabot>  Defined.
21:18:09 <benzrf> :t infinity0
21:18:10 <splintax> i guess that makes sense
21:18:10 <benzrf> :t infinity
21:18:11 <lambdabot>     Not in scope: ‘infinity0’
21:18:11 <lambdabot>     Perhaps you meant one of these:
21:18:11 <lambdabot>       ‘infinity’ (line 157),
21:18:12 <lambdabot>     Ambiguous occurrence ‘infinity’
21:18:12 <lambdabot>     It could refer to either ‘L.infinity’,
21:18:13 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:157:1
21:18:20 <benzrf> dang it lambdabot
21:18:24 <benzrf> :t L.infinity
21:18:25 <lambdabot> Fractional a => a
21:18:27 <mmachenry1> > 1/0 - 1/0
21:18:28 <lambdabot>  NaN
21:18:30 <benzrf> lol i dunno
21:18:40 <codehero> :D
21:18:42 <mmachenry1> > 1/0 + 1/0
21:18:44 <lambdabot>  Infinity
21:18:52 <codehero> lambdabot: wrong! it's two times infinity
21:19:04 <codehero> duh
21:19:08 <mmachenry1> > 2/0
21:19:10 <lambdabot>  Infinity
21:19:20 <codehero> mm
21:19:30 <codehero> > (pi-pi)/0
21:19:32 <lambdabot>  NaN
21:19:35 <codehero> heh
21:19:40 <codehero> > pi-pi
21:19:42 <lambdabot>  0.0
21:19:54 <codehero> hmmm
21:19:58 <codehero> > g64
21:20:00 <lambdabot>  Not in scope: ‘g64’
21:20:10 * codehero want grahams number! :<
21:21:36 <splintax> so what type(s) is Infinity then?
21:22:26 <sclv> can we tone down playing with lambdabot in public all?
21:22:34 <sclv> you can always privmsg it to poke around
21:23:13 <codehero> > f a b|b==0=1|odd b=mod(a*f a(b-1))m|0<1=f(mod(a^2)m)$div b 2
21:23:15 <lambdabot>  <hint>:1:6: parse error on input ‘|’
21:23:21 <codehero> hmm. why doesn't this work
21:24:25 <HeladoDeBrownie> codehero, that evaluates expressions, not declarations
21:24:35 <benzrf> > infinity :: Rational
21:24:37 <lambdabot>  Ambiguous occurrence ‘infinity’
21:24:37 <lambdabot>  It could refer to either ‘L.infinity’, defined at L.hs:157:1
21:24:37 <lambdabot>                        or ‘Data.Number.Natural.infinity’,
21:24:37 <lambdabot>                           imported from ‘Data.Number.Natural’ at L.hs:94:1-26
21:24:38 <codehero> hmm
21:24:40 <benzrf> > L.infinity :: Rational
21:24:42 <lambdabot>  *Exception: Ratio has zero denominator
21:25:05 <codehero> there has to be a oneliner for grahams number, right?
21:25:33 <joelteon> lambdabot should throttle its REPL functionality
21:26:44 <codehero> @let graham a b|b==0=1|odd b=mod(a*f a(b-1))m|0<1=f(mod(a^2)m)$div b 2
21:26:46 <lambdabot>  Defined.
21:27:03 <codehero> @let m=10^500
21:27:05 <lambdabot>  .L.hs:164:35:
21:27:05 <lambdabot>      Ambiguous occurrence ‘m’
21:27:05 <lambdabot>      It could refer to either ‘L.m’, defined at .L.hs:158:1
21:27:05 <lambdabot>                            or ‘Debug.SimpleReflect.m’,
21:27:05 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
21:27:14 <joelteon> codehero: use private message
21:27:16 <codehero> okay
21:27:38 <codehero> not my problem if you don't get to see grahams number!
21:28:09 <joelteon> calculate TREE{3} instead
21:33:07 <pikaren> /e/s
21:42:33 <ReinH> codehero: you can pm lambdabot fyi
21:43:46 <codehero> ReinH: i know. i just thought that calculating the last digits of grahams number was easier :P
21:44:03 <codehero> but i couldn't find a real one liner
21:47:04 <raisdead> I am trying to understand the state monad. I have been trying to use it as a method to keep track of a maximum so far. I can implement it by explicitly passing the state to the function every time (purely), but I cannot figure out the state monad. Can someone point me to an example implementation of something similar?
21:47:27 <gamegoblin> I remember reading some article a year or two ago that was a bit satire, but it was basically describing some young software engineer going into industry and learning more and more about OO but eventually getting lead in circles with design patterns and I think, winding up at functional. Does anyone know which article I’m talking about? I can’t find it.
21:49:00 <Saizan> raisdead: the state monad would be doing exactly that but packaged up in combinators
21:49:02 <trap_exit> alright, what class do I have to instance so that I can use format "{}" on my object?
21:49:04 <trap_exit> this is for package text-format
21:50:20 <Saizan> raisdead: maxM [] = return (); maxM (x:xs) = do m <- get; if m < x then put x else return (); maxM xs
21:50:51 <trap_exit> ohh, I got it
21:50:52 <trap_exit> this is awesome
21:50:54 <Saizan> raisdead: then you use runState with a starting value for the maximum to get your result
21:54:48 <codehero> Awesome! compare `on` length ... man, that reads almost like real English!
21:54:49 <codehero> lol
21:57:12 <gamegoblin> > let a = id; this = id; is = id; swedish = intersperse “f” in this is a swedish “hello”
21:57:14 <lambdabot>  <hint>:1:55: lexical error at character '\8220'
21:57:27 <gamegoblin> ah frack my non unicode quotes
21:58:20 <gamegoblin> > let a = id; this = id; is = id; swedish = intersperse 'f' in this is a swedish "hello"
21:58:22 <lambdabot>  "hfeflflfo"
21:58:29 <gamegoblin> :D
21:59:17 <glguy> You might need to visit this website http://www.speakswedish.co.uk/phrases/basic_phrases
22:03:06 <gamegoblin> > let (this,is,a)=(id,id,id); very f x = f(f(f x)); swedish = intersperse 'f' in this is a very swedish "hello"
22:03:09 <lambdabot>  <hint>:1:110: lexical error at character '\SI'
22:03:18 <gamegoblin> > let (this,is,a)=(id,id,id); very f x = f(f(f x)); swedish = intersperse 'f' in this is a very swedish "hello"
22:03:20 <lambdabot>  "hfffffffeffffffflffffffflfffffffo"
22:03:25 <codehero> lol
22:03:44 <codehero> :D
22:03:50 <gamegoblin> Haskell is basically english with enough coersion
22:04:02 <codehero> heh. i see that
22:05:49 <swgillespie> > let 2+2=5 in 2+2
22:05:49 <gamegoblin> let (this,is,a)=(id,id,id); very f x = f(f(f x)); swedish = intersperse 'f' in this is a very very swedish "hello"
22:05:51 <lambdabot>  5
22:05:59 <swgillespie> haskell can do anything >:D
22:06:08 <gamegoblin> > let (this,is,a)=(id,id,id); very f x = f(f(f x)); swedish = intersperse 'f' in this is a very very swedish "hello"
22:06:10 <lambdabot>  "hffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
22:06:14 <dmj`> > do "anything"
22:06:14 <gamegoblin> Guess it was too swedish
22:06:16 <lambdabot>  "anything"
22:06:16 <solidus-river> what is causing some packages to not have documentation on hackage recently?
22:06:34 <solidus-river> i cant remember the specific package but i know its been more than one where the most recent version of the package doesnt get generated docs
22:06:50 <gamegoblin> solidus-river: I had one of my packages not get docs generated. Reuploaded a week later and it worked fine. No idea.
22:06:55 <gamegoblin> solidus-river: hackage be whack
22:07:01 <dmj`> whackage
22:07:05 <gamegoblin> bahahahaha
22:07:41 <codehero> swgillespie: thank you for breaking math
22:07:49 <codehero> -_-
22:08:03 <swgillespie> there was a horrible/awesome thread on stack overflow that was "make 2+2=5 in your favorite language"
22:08:12 <swgillespie> the most evil one was java but haskell's was pretty funny
22:08:15 <codehero> lol
22:08:49 <codehero> > let 5/0=24 in 5/0
22:08:51 <lambdabot>  24
22:08:56 <swgillespie> haskell totally rolls with it
22:09:02 <codehero> > let 5/0=42 in 5/0
22:09:03 <lambdabot>  42
22:09:04 <codehero> i meant 42
22:09:06 <codehero> obviously
22:09:13 <solidus-river> > let 2+2 = 5 in 2+2
22:09:15 <benzrf> class Fixnum;def+(_)5;end;end
22:09:15 <lambdabot>  5
22:09:18 <benzrf> 4 ruby
22:10:20 <codehero> so that's how big brother does it
22:10:24 <codehero> he uses haskell O_O
22:10:28 <benzrf> lol
22:10:49 <paraseba> why (Monoid m) => IO m  is not a Monoid? Can it be? Why not?
22:10:53 <trap_exit> is there a way to have a module EXPORT something it IMPORTS ? i.e. I want to have a module which exports Data.Text.Buildable class as Buildable
22:11:17 <benzrf> paraseba: sure it could be
22:11:20 <gamegoblin> \f a b = f a ++ f b
22:11:31 <raisdead> Saizan: Thank you. I was able to figure out my particular case and it helped my understanding.
22:11:31 <codehero> > let (+) 2 2 = 5
22:11:33 <lambdabot>  not an expression: ‘let (+) 2 2 = 5’
22:11:34 <benzrf> paraseba:
22:11:36 <codehero> duh
22:11:42 <codehero> @let (+) 2 2 = 5
22:11:42 <gamegoblin> trap_exit: just export it as you’d export anything else
22:11:44 <lambdabot>  Defined.
22:11:49 <benzrf> @let newtype ApplMon f a = ApplMon (f a)
22:11:50 <gamegoblin> @pl \f a b = f a ++ f b
22:11:50 <codehero> > 2 + 2
22:11:51 <lambdabot>  Defined.
22:11:51 <lambdabot> (line 1, column 8):
22:11:51 <lambdabot> unexpected "="
22:11:51 <lambdabot> expecting pattern or "->"
22:11:52 <lambdabot>  Ambiguous occurrence ‘+’
22:11:53 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:156:3
22:11:55 <lambdabot>                        or ‘GHC.Num.+’,
22:11:57 <lambdabot>                           imported from ‘Prelude’ at L.hs:34:8
22:11:59 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
22:12:03 <gamegoblin> @pl \f a b -> f a ++ f b
22:12:03 <lambdabot> flip =<< (((.) . (++)) .)
22:12:06 <codehero> lol
22:12:11 <codehero> i broke it
22:12:26 <paraseba> benzrf: isn't it a trivial and useful case? Why is it not part of Data.Monoid
22:12:58 <benzrf> @instance (Applicative f, Monoid a) => Monoid (ApplMon f a) where mempty = ApplMon . pure . mempty; mappend (ApplMon a) (ApplMon b) = ApplMon (mappend <$> a <*> b)
22:12:58 <lambdabot> Maybe you meant: instances instances-importing
22:13:02 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (ApplMon f a) where mempty = ApplMon . pure . mempty; mappend (ApplMon a) (ApplMon b) = ApplMon (mappend <$> a <*> b)
22:13:03 <codehero> well. i'm going to sleep now. see you all tomorrow
22:13:03 <lambdabot>  .L.hs:146:10:
22:13:04 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
22:13:04 <lambdabot>      from the context (Num a)
22:13:04 <lambdabot>        bound by the inferred type of duh :: Num a => a at .L.hs:146:1-14
22:13:04 <lambdabot>      The type variable ‘b0’ is ambiguous
22:13:07 <benzrf> :|
22:13:22 <benzrf> i-i didnt even use ^
22:13:27 <benzrf> @undef
22:13:27 <lambdabot> Undefined.
22:13:29 <benzrf> @let newtype ApplMon f a = ApplMon (f a)
22:13:31 <lambdabot>  Defined.
22:13:31 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (ApplMon f a) where mempty = ApplMon . pure . mempty; mappend (ApplMon a) (ApplMon b) = ApplMon (mappend <$> a <*> b)
22:13:33 <lambdabot>  .L.hs:150:18:
22:13:33 <lambdabot>      Couldn't match expected type ‘ApplMon f a’
22:13:33 <lambdabot>                  with actual type ‘a0 -> ApplMon f0 a1’
22:13:33 <lambdabot>      Relevant bindings include
22:13:33 <lambdabot>        mempty :: ApplMon f a (bound at .L.hs:150:9)
22:13:38 <Saizan> raisdead: cheers
22:13:45 <benzrf> @let instance (Applicative f, Monoid a) => Monoid (ApplMon f a) where mempty = ApplMon (pure mempty); mappend (ApplMon a) (ApplMon b) = ApplMon (mappend <$> a <*> b)
22:13:47 <lambdabot>  Defined.
22:13:54 <benzrf> paraseba: there, just use that ;)
22:14:05 <paraseba> let me try to parse that ...........
22:14:06 <gamegoblin> codehero: re@big brother
22:14:08 <gamegoblin> > let new f a b = f a ++ f b; speak = take 3 in new speak "inglish" "society"
22:14:10 <lambdabot>  "ingsoc"
22:14:20 <benzrf> gamegoblin: lmao
22:14:29 <benzrf> u mean socialism
22:15:05 <gamegoblin> Oh, it’s been 10 years since I’ve read it, forgot I guess
22:15:57 <paraseba> benzrf: can you please explain what ApplMon is?
22:16:09 <benzrf> paraseba: newtype wrapper for making any applicative into a monoid
22:17:04 <solidus-river> in netwire what are you supposed to do to convert a Double for the set of Interval wires to something that will respect the HasTime dependency
22:17:10 <paraseba> benzrf: why do you need it? To avoid defining this instance for every Applicative out there? Sorry for the dumb question
22:17:14 <benzrf> paraseba: ya
22:17:22 <benzrf> instance (Applicative f, Monoid a) => Monoid (ApplMon f a)
22:17:25 <benzrf> you could theoretically do
22:17:28 <benzrf> instance (Applicative f, Monoid a) => Monoid (f a)
22:17:32 <benzrf> but that causes problems
22:17:43 <benzrf> so you only instantiate it for explicitly wrapped types
22:18:33 <paraseba> I see. The kind of problems that it causes is braking other instance definitions for code that imports this instance? Or more serious problems? I'm very curious about why something like this is not defined in Data.Monoid
22:18:55 <benzrf> it might be
22:18:57 <benzrf> i dont know
22:19:09 <benzrf> paraseba: you CAN just do liftA2 mappend
22:19:22 <paraseba> yes, that's what I was thinking ...
22:21:44 <paraseba> benzrf: my current problem is, I'm trying to write a function that takes a function to "output" stuff, either to the console via IO, or to a list, or to a State, etc. My current approach is taking something of type (Monad m => a -> m ()) but I was thinking about changing it to a Monoid
22:22:08 <paraseba> I'm not sure if that's reasonable, users wanting to use IO, would have to wrap IO into a Monoid
22:23:37 <HeladoDeBrownie> paraseba, IO () is a Monoid.
22:24:33 <paraseba> HeladoDeBrownie: why not (Monoid m => IO m)
22:24:38 <benzrf> paraseba: so youre basically doing a Writer?
22:25:05 <HeladoDeBrownie> paraseba, you don't even need that, (Monoid m) => IO m is also a Monoid.
22:25:06 <paraseba> benzrf: maybe I am, that's a good clue, I'll have to check that
22:25:36 <paraseba> (I'm writing my first haskell program by the way, a BrainFuck evaluator)
22:26:12 <benzrf> oh pretty nice
22:26:15 <paraseba> HeladoDeBrownie: where is the instance defined, I can't find it in Data.Monoid
22:26:37 <benzrf> my preferred implementation method is a parser that results in an IO action
22:26:41 <HeladoDeBrownie> Hmm, I thought it was there, but you could define it. I'd look around but I can't make new internet connections right now for some reason.
22:26:45 * benzrf heads to sleep
22:26:59 <benzrf> bye
22:27:02 <HeladoDeBrownie> \o
22:27:04 <paraseba> good night, thanks
22:27:10 <benzrf> np
22:27:15 <benzrf> o/
22:29:04 <solidus-river> i don't understand why ghc doesnt like this http://lpaste.net/108885
22:29:25 <ydl> i have been trying to link to a static c library (".a" file) in the root directory of my project. I can do it with just the "libtest.dll" file and running ghci with "-ltest", but can't seem to use the static ".a" library at all
22:30:11 <solidus-river> > import Linear.V2 (V2 1.0 1.0) * 3.0
22:30:13 <lambdabot>  <hint>:1:1: parse error on input ‘import’
22:30:39 <solidus-river> you should be able to multiplay a V2 Double by a Double
22:30:46 <solidus-river> thats a valid thing in Linear.V2
22:33:50 <ydl> note this is for building a library
22:36:28 <solidus-river> heres a cleaner example of the problem
22:36:33 <solidus-river> http://lpaste.net/108886
22:36:46 <glguy>  /msg haasn The topic says not to idle because in previous cases where someone was offended they complained that they were uncomfortable explaining themselves with so many people around so we had to cut back the audience
22:36:58 <glguy> <_< well, there's that
22:37:18 <solidus-river> :P
22:37:41 <solidus-river> https://www.youtube.com/watch?v=4TYv2PhG89A
22:38:13 * hackagebot apiary 0.14.0.1 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.14.0.1 (HirotomoMoriwaki)
22:38:59 <solidus-river> > :t *
22:39:01 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:39:04 <solidus-river> > :t (*)
22:39:06 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:39:43 <solidus-river> interesting, i dont get why * ever works with V2 Double * Double
22:39:48 <solidus-river> but ghci is strangely cool with it
22:40:26 <solidus-river> but ghc complains about it
22:41:06 <glguy> solidus-river: There's an instance Num a => Num (V2 a)
22:41:09 <haasn> solidus-river: In your line 17, 2.0 isn't a Double
22:41:28 <haasn> solidus-river: Numeric literals are polymorphic in Haskell - 2.0 could be a Double, it could be a Rational, it could be a V2 Double (which it is in this case)
22:41:37 <haasn> It could even be a String (but it probably shouldn't be)
22:41:50 <haasn> :t 2.0
22:41:51 <lambdabot> Fractional a => a
22:41:59 <solidus-river> :t Double
22:42:00 <lambdabot> Not in scope: data constructor ‘Double’
22:42:01 <solidus-river> er
22:42:18 <solidus-river> well.. so what type would make ghc happy there
22:42:25 <solidus-river> :i Double
22:42:38 <haasn> V2 Double. But then you're just assining simpleVectorMult = (*)
22:42:42 <haasn> assigning*
22:43:06 <haasn> If you actually want to write :: V2 Double -> Double -> V2 Double; though, you need to change the code instead
22:43:29 <solidus-river> well the problem is i want to multiply a V2 by a double elsewhere in my code within a function
22:43:38 <solidus-river> and it was complaining about types so i broke the snippet out to talk about it
22:43:59 <solidus-river> and it seems not nice to everywhere i want to multiply a vector by a scalar in my function to write
22:44:08 <solidus-river> vector * (V2 scalar scalar)
22:44:12 <solidus-river> but i guess i can
22:44:38 <solidus-river> i'm still i guess not understanding why ghci is cool with it. Double is an instance of Num
22:44:40 <haasn> There might be some function already there for you to lift a Double into a V2 Double, rather than having to apply V2 manually
22:44:54 <glguy> You could use fromRational or return or pure
22:45:14 <haasn> fromRational would imply it being a Rational, though; which might not be there. You'd have to use toRational first, which on Double is just.. ugh
22:45:24 <glguy> ok, then realToFrac
22:45:25 <haasn> I'd much rather avoid the round-trip
22:45:28 <solidus-river> is there an easy way to convert Double to something that will satisfy HasTime t
22:46:05 <solidus-river> :t realToFrac
22:46:06 <lambdabot> (Real a, Fractional b) => a -> b
22:46:18 <glguy> (return 5.2 :: V2 Double, realToFrac (5.2::Double) :: V2 Double)
22:46:35 <haasn> solidus-river: in GHCi, the “2.0” you wrote is equivalent to “fromRational (2.0 :: Rational)” - and the fromRational instance for V2 Double says how to lift that, probably with code that looks like “V2 scalar scalar”
22:46:45 <haasn> So the work is just hidden inside an instance and polymorphic literal
22:46:48 <haasn> It's still doing nothing different
22:47:05 <haasn> There is no way to “cheat” the fact that (*) requires operands to be of the same type
22:47:11 <glguy> (^*) :: (Functor f, Num a) => f a -> a -> f a
22:47:16 <haasn> However, there may already be a scalar multiplication operation somewhere in Linear. Have you checked?
22:47:18 <glguy> In Linear.Vector
22:47:23 <haasn> ^ there you go
22:48:42 <trap_exit> what is the idiomatic way to write either (\x -> x + 2) or (\x -> 2 + x)
22:48:44 <solidus-river> interesting is using Linear.Vector (^*) in any wy more efficient or betterer than realToFrac?
22:48:52 <haasn> trap_exit: (+2) or (2+)
22:49:09 <trap_exit> because () = slice notation ?
22:49:16 <haasn> solidus-river: Yes, I imagine it's both
22:49:40 <haasn> Although I'd need to look at the core to really find out
22:49:58 <haasn> Does GHC optimize (fromRational . toRational) :: Double -> Double to id?
22:50:00 <haasn> “optimize”
22:50:15 <haasn> It probably changes semantics, but it's not like anybody cares about Double's semantics either way
22:50:37 <solidus-river> @hoogle Double -> NominalDiffTime
22:50:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:50:40 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
22:50:40 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
22:50:52 <solidus-river> bleh, none of those seem good
22:50:54 <enthropy> > fromRational (toRational (0/0))
22:50:56 <lambdabot>  -Infinity
22:52:29 <solidus-river> huh, i dont get how someones supposed to interact with the for wire from Netwire
22:52:36 <solidus-river> it only takes a Hastime t value for the duration
22:52:47 <solidus-river> and the only values that seem usable for that is NominalDiffTime
22:52:56 <solidus-river> and it seems like theres no good way to create that from a double or integer
22:52:57 <haasn> enthropy: Good idea; I checked it by compiling with -O2 as well - it also prints -Infinity instead of NaN proving that the round trip isn't magically optimized away
22:53:24 <glguy> solidus-river: Go to GHCi and type, :m Data.Time       :i NominalDiffTime
22:53:30 <glguy> and you'll see all the instances it supports
22:53:36 <Enigmagic> trap_exit: http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
22:53:56 <trap_exit> Enigmagic: ah, thanks!
22:54:07 <glguy> Prelude Data.Time> 10.5 :: NominalDiffTime
22:54:07 <glguy> 10.5s
22:54:25 <glguy> These are also using the "fromRational" and "fromInteger" methods from Num and Fractional
22:54:45 <haasn> I wonder why netwire uses NominalDiffTime instead of DiffTime. It seems like NominalDiffTimes only purpose is to introduce off-by-one timing errors due to leap seconds
22:54:54 <haasn> I wonder if netwire is reliable around leap seconds
22:55:59 <solidus-river> glguy: i guess i still have some type foo to learn
22:56:14 <solidus-river> i see NominalDiffTime is an instance of num and I can do 2.0 :: NominalDiffTime and it gives me 2s
22:56:22 <solidus-river> but i dont kno0w how to form this function
22:56:24 <solidus-river> http://lpaste.net/108890
22:56:52 <glguy> Use realToFrac to convert your Double to a NominalDiffTime
22:57:17 <glguy> Or instead don't ask for a Double parameter
22:57:17 <haasn> Why not pass in NominalDiffTime instead of Double in the first place?
22:57:21 <glguy> but ask for a NominalDiffTime
22:57:27 <solidus-river> is that most of the time the way to go with trying ot get different types out of Num's?
22:57:35 <solidus-river> haassn because i want to be able to pass it a double
22:57:49 <solidus-river> if i ask for a NominalDiffTime wont it require other functions to convert?
22:57:59 <solidus-river> just spreading the conversion around in the logic of the program
22:58:06 <glguy> Yeah, but it will also be more obvious to them that they are passing in a time
22:58:13 <glguy> rather than masking the time behind a "Double"
22:58:40 <glguy> With a nominaldifftime you know what units you're dealing with
22:58:52 * solidus-river grumbles but realizes thats better
22:58:58 <glguy> with Int or Double it could be seconds or microseconds or days or something more exotic
23:12:39 <haasn> solidus-river: But if you use NominalDiffTime *everywhere*, you won't need to convert anything
23:12:45 <haasn> Until you get to the literals, which are already polymorphic. Win/win
23:24:15 <solidus-river> i wish tehre was a way to make this clearer http://lpaste.net/108893
23:25:16 <Iceland_jack> solidus-river: You can make a pattern synonym for (V2 (-1) 0), (V2 0 (-1)), ...
23:25:31 <Iceland_jack>     pattern Left = V2 (-1) 0
23:25:32 <Iceland_jack>     pattern Down = V2 0    (-1)
23:26:25 <Iceland_jack> where
23:26:25 <Iceland_jack>     Left = V2 (-1) 0
23:26:25 <Iceland_jack> and you can pattern match on Left as well
23:26:31 <haasn> There must me some way to “rotate”​ a V2
23:26:51 <haasn> Making this operation much simpler: Move forwards for duration/4, turn 90° to the left
23:26:54 <haasn> Repeat forever
23:27:31 <haasn> If I were to write this function I would probably 1. find a way to generate an infinite list of the directions I want to move
23:27:43 <haasn> something like “iterate turnLeft startDir”
23:28:00 <haasn> And then I would 2. find a way to make a wire step through an infinite list, holding each value for one step of time
23:28:07 <haasn> one unit*
23:28:19 <haasn> I imagine netwire must have something like this. If it does not, I would write it
23:28:38 <haasn> The code could be as simple as invaderVelocity = stepThrough duration $ iterate turnLeft startDir
23:35:02 <zematis> hello! noob question: in a function taking two list types, [a] and [b]. Can is it possible for me to return a list of either type (return [a] or return [b])?
23:36:55 <UnrealQuester> you could do that with Either
23:37:32 <zematis>  Cool. Thanks!
23:38:27 <Pythonfant> afaik either is usually used to get error messages in the Left
23:38:39 <UnrealQuester> yes
23:38:41 <haasn> That's one possible use, but not the only
23:38:52 <Pythonfant> haasn: hm k, haven't seen any other use of it
23:39:54 <haasn> Off the topic of my head I know that monoid-extra's monoid coproduct is basically [Either m n]
23:40:25 <haasn> Where “Left” and “Right” are not really much different - just two separate options
23:41:06 <haasn> machines uses “Either” in its Y-shaped stream mergers, for example
23:41:14 <haasn> Left for things coming from the left stream, Right for things coming from the right stream
23:41:29 <haasn> There are lots of sane uses where neither is an “error” condition
23:41:45 <Pythonfant> ok :)
23:41:51 <haasn> The bias towards Left is based purely on the order of type parameters determining which Monad instance is more convenient
23:41:57 <haasn> towards Left being error*
23:42:53 <Pythonfant> yep that's why I thought it could confuse people if you use Left for something not indicating an error
23:43:18 <haasn> Fair enough
23:43:33 <haasn> I guess usually if you have some semantic attached to it besides “left” and “right” you can give it a custom ADT
23:44:07 <zematis> hmm. Doesn't appear to be working. Does this typing sound legal to you guys: getLongerList :: [a] -> [b] -> Either [a] [b]
23:44:24 <haasn> Yes that seems perfectly possible
23:44:40 <zematis> hmmm
23:45:06 <Pythonfant> zematis: you need to use Left [a] and Right [b] as return values
23:45:10 <Pythonfant> not just [a] and [b]
23:45:35 <haasn> There are lots of things that could be wrong. If you want more help you need to show the code (and the error message for good measure)
23:46:27 <zematis> Let me do some research on Left and Right for a minute or so. If I don't figure it out, I'd love to have you guys look at it.
23:46:48 <zematis> (or if you guys are randomly curious just let me know, but it's nothing that interesting)
23:48:26 <solidus-river> haasn: aye it does have it but its built more around events although wires are instances of applicative
23:49:42 <zematis> got it working. Thanks Pythonfant!
23:50:08 <Pythonfant> great
23:50:13 <zematis> :)
23:50:31 <haasn> I wonder if it's better to write that function by comparing “length” or by writing something like getLongerList xs [] = Left xs; getLongerList [] ys = Right ys; getLongerList (x:xs) (y:ys) = bimap (x:) (y:) $ getLongerList xs ys
23:51:08 <Pythonfant> :t bimap
23:51:09 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
23:51:13 <haasn> I think the former might be better
23:51:43 <haasn> By the time you've forced Left or Right, you already have forced the original spine (just like length) except now you've built up your own big thunks for the new list, rather than keeping the old structure around
23:55:18 <supki> the latter works when one list is infinite
23:55:34 <haasn> Oh, nice observation
23:55:53 <haasn> But you can write your own compareLength function that has the same properties
23:58:03 <trap_exit> is ther ea builtin that ignores it's argument and always returns a particular value?
23:58:05 <trap_exit> i.e. \x -> c
23:58:30 <Pythonfant> const c?
23:58:56 <Pythonfant> > const 5 3
23:58:58 <lambdabot>  5
23:59:05 <trap_exit> nice, thanks
