00:01:06 * hackagebot snaplet-sqlite-simple 0.4.8.1 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.8.1 (JanneHellsten)
00:01:06 <lispy> augur: I'm probably going to bed soon. Good luck and don't hesitate to ask more questions if you get stuck again.
00:01:16 <augur> lispy: thanks :)
00:02:12 <lispy> trap_exit: here is a book: http://www.cs.ox.ac.uk/publications/books/fop/
00:03:11 <trap_exit> lispy: that looks badass
00:03:11 <trap_exit> lispy: thanks
00:03:16 <trap_exit> lispy: your ()'s are hereby forgiven
00:03:21 <lispy> heh
00:04:05 <lispy> one more link before I disappear
00:04:07 <lispy> trap_exit: https://www.fpcomplete.com/user/edwardk/bound
00:13:15 <sgronblo> cabal... I'm running with --reinstall and it still says "already installed, run with --reinstall if you want to install anywa"...
00:40:20 <lpvb> > let howard x y="howard "++x()++y();likes=const"likes ";tomatoes=const"tomatoes" in howard likes tomatoes
00:40:21 <lambdabot>  "howard likes tomatoes"
00:40:43 <lpvb> any shorter ways to compose functions to make sentences
00:41:06 <lpvb> this is just a toy for fun
01:09:14 <trap_exit> should constructors have names like " | DocInsertLeafAfter ... | DocInsertLeafBefore ... | DocInsertInnerAfter | ... DocInsertInnerBefore " ... or DocILA DocILB DocIIA DocIIB ?
01:09:46 <solarus> > const "howard " <> const "likes " <> const "tomatoes" $ ()
01:09:48 <lambdabot>  "howard likes tomatoes"
01:34:00 <lpvb> solarus: I think the point flew over your head
01:36:03 <MP2E> those were functions composed to create a sentence
01:36:08 <MP2E> i guess i missed the point too :P
01:38:33 <lpvb> > let howard x y= const "howard"<>x<>y;likes=const" likes ";tomatoes=const"tomatoes" in howard likes tomatoes
01:38:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
01:38:35 <lambdabot>    arising from a use of ‘M76121959321217867915285.show_M76121959321217867915...
01:38:35 <lambdabot>  The type variable ‘b0’ is ambiguous
01:38:35 <lambdabot>  Note: there are several potential instances:
01:38:35 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
01:38:52 <lpvb> > let howard x y= const "howard"<>x<>y;likes=const" likes ";tomatoes=const"tomatoes" in howard likes tomatoes $ ()
01:38:54 <lambdabot>  "howard likes tomatoes"
01:42:40 <JohnTalent> what's used for logic programming in haskell?
01:45:36 <JohnTalent> nevermind
01:46:52 <mroman> since Web.Encodings is deprecated
01:46:52 <mroman> what's the alternative?
01:50:12 <ChristianS> mroman: http-encodings package maybe?
02:06:41 <mroman> ChristianS: Doesn't look like it
02:06:53 <mroman> I need to encode stuff for output in HTML
02:07:49 <mroman> I.e. < => &lt; etc
02:08:22 <mroman> but I can just write that myself
02:08:24 <mroman> no big deal :D
02:11:25 <Cale> mroman: Well, if you're using a library to generate HTML, it hopefully does that already.
02:11:39 <ChristianS> mroman: ah, there are html and blaze-html -- maybe one of those
02:12:02 <Cale> yeah, I know html will do it
02:15:45 <Cale> It looks like blaze-html does as well
02:51:33 * hackagebot simple-pipe 0.0.0.22 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.22 (YoshikuniJujo)
02:55:35 <mroman> Cale: I'm not using a library to generate HTML
02:55:50 <mroman> well
02:55:54 <mroman> technically I use Text.XHtml
02:56:10 <mroman> but the interpreter HTML Output is a String
02:56:16 <mroman> with HTML in it
02:56:22 <mroman> so I have to embed it with primHtml
02:56:32 <mroman> hm. wait
02:56:33 * hackagebot cabal2nix 1.69 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.69 (PeterSimons)
02:56:57 <mroman> yeah I could rewrite toHTML for the syntax highlighting to use a HTML library
02:57:00 <mroman> but *effort*
02:57:02 <mroman> :D
03:11:35 * hackagebot yaml 0.8.9 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9 (MichaelSnoyman)
03:14:40 <benmachine> mroman: blaze-html lets you embed stuff that's already been escaped without escaping it again
03:16:33 <benmachine> so if you already have some stuff generating String, you can turn that into Html without double-escaping it
03:40:14 <Twey> I remember there used to be a package on Hackage that had a big list of IRC message codes in it; anyone remember what it was called?
03:43:21 <AshyIsMe> Twey: this one? https://hackage.haskell.org/package/irc-0.6.0.1/docs/src/Network-IRC-Base.html#encode
03:43:28 <AshyIsMe> replyTable down the bottom?
03:44:23 <Twey> Ahh, yes, thanks!
03:44:26 <AshyIsMe> that was the top google hit for "hackage irc" and then 3 clicks deep
03:44:26 <AshyIsMe> haha
03:44:41 <Twey> I was even looking at this package earlier… must've skipped right over it
04:00:29 <trap_exit> any haskellers feel that earthquake?
04:00:42 <trap_exit> for a moment I thought I was being punished for my compile errors
04:12:46 <Axman6> trap_exit: san francisco?
04:13:13 <trap_exit> how did you know? did only one earthquake occur in the world over the past hour?
04:13:52 <Axman6> I just searched twitter for earthquake
04:14:22 <trap_exit> ohh
04:14:23 <trap_exit> I need to see what's on twitter
04:14:23 <hpc> trap_exit: also...
04:14:24 <hpc> 07:12 [freenode] -!- trap_exit [ac382747@gateway/web/freenode/ip.172.56.39.71]
04:14:28 <hpc> 172.56.39.71 - T-Mobile USA In San Pablo United States | IP ...
04:14:46 <Axman6> a 6.1 quake apparently
04:14:47 <trap_exit> fuck
04:14:48 <trap_exit> does it give my GPS coordinates too?
04:15:01 <no-doz> how big of a quake would it take to damage an operating HDD?
04:15:10 <hpc> trap_exit: thank god, it doesn't
04:15:22 <trap_exit> no-doz: SSD or those spingly things?
04:15:26 <Axman6> https://twitter.com/earthquakesSF/status/503487883672444928
04:15:31 <no-doz> the latter
04:15:35 <dottedmag> no-doz: not a strong one if it falls down from a table.
04:15:45 <no-doz> heh
04:15:51 <no-doz> and if it doesn't?
04:15:55 <hpc> the good drives will lock the drive head when they detect an impact
04:16:02 <trap_exit> yeah, this particular earthquake was gentle, as if my apartment was in a boat swinging back and forth
04:16:06 <no-doz> ahh
04:16:17 <trap_exit> I suspect it's only the fall + hitting the floor + sudden deceleartion taht breaks hds
04:16:19 <Axman6> I felt ones like that when I worked in Tokyo
04:16:23 <Axman6> best wakeup alarm I had
04:16:25 <trap_exit> unlikely the actual shake to damage it
04:16:28 <no-doz> haha
04:16:30 <Axman6> a gently rocking awake
04:16:32 <no-doz> I've been woken by one
04:17:24 <trap_exit> https://twitter.com/earthquakesSF
04:17:24 <trap_exit> hmm
04:17:26 <trap_exit> aftershocks
04:18:29 <trap_exit> take irc away ... I am more productive
04:18:51 <trap_exit> this just gave me a new idea
04:18:52 <trap_exit> ghc should add a new flag
04:18:58 <hpc> what you need is a custom IRC server where each channel is like a code file
04:19:06 <hpc> and you have a line editor interface in each
04:19:19 <trap_exit> -Xhelp // when you get a compile error, (1) auto send errors + source file to gist, (2) gives you a URL to paste in #haskell
04:19:45 <stalintrotsky> if something needs an input file, how do I pass it stdin instead?
04:19:48 <stalintrotsky> with bash
04:20:01 <trap_exit> >
04:20:04 <trap_exit> oh
04:20:04 <trap_exit> -
04:20:05 <hpc> stalintrotsky: oh jeez, i remember this
04:20:05 <Axman6> often you use the filename '-'
04:20:17 <trap_exit> isn't '-' handled by the prog
04:20:18 <trap_exit> or is it handled by the shell ?
04:20:19 <Axman6> but that's more convention than standard
04:20:19 <stalintrotsky> is that implemented by the application or a part of bash?
04:20:22 <hpc> if it doesn't support filename '-' there's another trick
04:20:33 <trap_exit> hpc: let's hear it, is it /dev/this-shell ?
04:20:35 <Axman6> names pipes!
04:20:38 <Axman6> named*
04:20:50 <hpc> /dev/fd/0 maybe?
04:20:52 <trap_exit> that is clever
04:21:20 <trap_exit> you know; there is one good thing about earthquakes
04:21:21 <trap_exit> it brings people together
04:21:25 <trap_exit> people come out an dmeet and chat
04:21:25 <hpc> there's a weird way that works too, it's like <(foo)
04:21:40 <dottedmag> trap_exit: (2) Initiates an earthquake
04:21:46 <dottedmag> *(3)
04:21:57 <hpc> http://serverfault.com/questions/398514/pass-a-pipe-to-a-command-that-expects-a-filename -- POOF!
04:22:19 <hpc> so the totally overkill method would be foo <(cat)
04:22:50 <Axman6> that question mentions pv (pipeviewer), which is one utility I highly recommend
04:23:14 <hpc> as a point of interest in how it's implemented btw:
04:23:15 <hpc> $ echo <(cat)
04:23:16 <hpc> /dev/fd/63
04:23:26 <Axman6> it's awesome when compressing things, you can get a running total of the amount of data compressed and its compressed size quite easily
04:24:08 <Axman6> pv input.tar | <compress -o stdout> | pv > outfile.tar.z
04:30:34 <Guest51008> hi
04:30:41 <Guest51008> this channel is about?
04:30:47 <hpc> /topic
04:59:31 <Twey> Guest51008: This channel is about the programming language Haskell.
05:00:42 <trap_exit> haskell ftw
05:00:46 <trap_exit> someone needs ot do a billion dollar haskell startup
05:01:17 <Guest51008> Twey: thx
05:02:10 <trap_exit> ask not what haskell can do
05:02:14 <trap_exit> ask what you can do for haskell
05:02:25 <trap_exit> so what silly webapp can I build to make ahskell better?
05:02:30 <trap_exit> (I need something to test out my ghcjs project on)
05:02:45 <trap_exit> in particular, something to make #haskell, not haskell, better
05:03:47 <hpc> trap_exit: how about something that watches the channel logs and indexes conversations by topic
05:03:59 <hpc> then someone can search for "zipper" and find an explanation someone already gave
05:04:01 <trap_exit> holy shit
05:04:01 <trap_exit> that is brilliant
05:04:11 <trap_exit> there's some NLP involved too
05:04:18 <trap_exit> it's like a mix of time series, NLP, and GUI
05:04:20 <hpc> it can pick up automatically who is the explainer and highlight their lines
05:04:48 <trap_exit> hpc: you are brilliant
05:04:59 <hpc> then add a manual system for fixing the system's mistakes and a rating system for peer review
05:05:35 <trap_exit> http://tunes.org/~nef/logs/old/ <-- convenient old data
05:06:22 <trap_exit> input: irc log
05:06:24 <trap_exit> output: wiki entries
05:07:00 <trap_exit> searching old irc logs is such a bitch; better tools are definitely needed
05:07:48 <hpc> the trick i would expect is figuring out how to structure the project so you get something usable asap
05:07:59 <hpc> since you can probably spend years screwing around with the ai
05:08:00 <trap_exit> oh
05:08:07 <trap_exit> probably putting that haskell.zip up online
05:08:31 <trap_exit> hpc: what are you, a project manager in real life?
05:08:58 <hpc> no, lowly code monkey with a few big projects under my belt
05:09:13 <hpc> enough to have ideas, not enough to want to actually do them
05:10:06 <trap_exit> yeah
05:10:10 <trap_exit> so what is a good list of features to tackle
05:10:17 <trap_exit> 1) put txt files behind a happstack server
05:10:20 <trap_exit> 2) hope to not get sued
05:10:29 <trap_exit> 3) basic string matching search
05:10:54 <hpc> i don't think you can get sued for irc logging
05:11:41 <hpc> i think what i'd do is put the log viewer up, add manual controls for snipping out bits, then search and manual classification
05:11:43 <trap_exit> hpc: this is the US; anyone can get sued for anyting; whether the lawsuit wins is another thing
05:11:48 <hpc> then progressively tweak the automation
05:12:05 <hpc> maybe do something fancy like hook an existing classifier
05:12:41 <hpc> perhaps spamassassin, for the selfish interest of that i code for that too
05:13:18 <trap_exit> hpc: you wrote spamassassin ?
05:13:25 <hpc> no, just on the project
05:14:37 <hpc> my boss is on the PMC and knows the creator though
05:14:39 <hpc> http://svn.apache.org/repos/asf/spamassassin/trunk/CREDITS
05:14:40 <trap_exit> sleep beckons me
05:14:57 <trap_exit> will think this over
05:14:58 <hpc> and i am one of the committers
05:15:00 <trap_exit> thanks for the idea :-)
05:15:02 <hpc> ta
05:15:11 <trap_exit> one last thing, any chance you're int the SF area?
05:15:17 <hpc> DC area
05:15:20 <trap_exit> might be fun to chat this over coffee
05:15:20 <trap_exit> oh
05:15:21 <trap_exit> n/m
05:32:29 <cleberson> great group
05:39:22 <arianvp> Why exactly is  ParsecT  `Stateful` ?
05:41:06 <Axman6> perhaps to make parsing context sensitive grammar parsing easier (say a mapping of all definitions)
05:43:29 <freetip> Free tips if u like and share our page
05:43:29 <freetip> www.best-soccer-tips.com
05:43:29 <freetip> Free tips if draw/lose
05:43:29 <freetip> 80%+ Winning Hit Rates!
05:45:31 <sbrg> lol.
05:46:15 <burp> only if it's written in Haskell
05:47:14 <Rembane> Lazy tips.
05:50:19 <darveter> > 1
05:50:21 <lambdabot>  1
06:02:00 * hackagebot chatty 0.6 - Some monad transformers and typeclasses for abstraction of global dependencies.  http://hackage.haskell.org/package/chatty-0.6 (implementation)
06:02:02 * hackagebot chatty-text 0.6 - Provides some classes and types for dealing with text, using the fundaments of Chatty.  http://hackage.haskell.org/package/chatty-text-0.6 (implementation)
06:09:50 <amar^> I am assuming that many guards in code aren't good, is my assumption correct?
06:09:59 <hpc> depends on the code
06:10:19 <hpc> even goto has its place
06:11:08 <amar^> http://lpaste.net/109927
06:11:40 <amar^> probably my first steps in Haskell, not sure going in the right direction?
06:12:43 <user2046> maybe use pattern matching instead
06:13:52 <user2046> http://lpaste.net/109927
06:14:23 <user2046> if R and L are constructors
06:14:43 <amar^> looks neat, they are value constructor
06:15:10 <Laquendi> amar^: guards are nice and all but try to program without them for a month or two and you'll do better
06:16:19 <amar^> does that applicable for pattern matchinh  also?
06:16:42 <Laquendi> no, only guards. use pattern matching as much as possible :)
06:16:52 <user2046> it'd be pretty hard if you didn't use them :P
06:17:27 <user2046> (pattern matches i mean)
06:18:04 <amar^> :) :) that's good
06:19:13 <vramana> I just installed the latest Haskell Platform on Ubuntu 14.04 When I type ghci,  i get this error Loading package integer-gmp ... <command line>: can't load .so/.DLL for: libgmp.so How do I resolve this?
06:20:48 <benmachine> I don't think it's true that guards are bad
06:20:52 <arianvp> hmmph
06:20:54 <benmachine> just that pattern-matching is better, when it is appropriate
06:21:07 <arianvp> ddoes anybody know if the parsec documentation has been backed up somewhere?
06:21:30 <arianvp> the  Utrecht university ysadmins seem to have thrown away all personal pages...
06:21:31 <arianvp> http://www.cs.uu.nl/~daan/parsec.html
06:22:02 * hackagebot HTTP 4000.2.18 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.18 (GaneshSittampalam)
06:22:21 <hpc> ooh
06:24:44 <Twey> Can I make a type Generic if it has no type parameter?
06:26:32 <Twey> I'm trying to automatically derive Binary for a monomorphic type
06:27:10 <benmachine> there is an instance Generic Bool, looks like
06:28:02 <Twey> … wait, I'm confused: where is the Generic class even defined?
06:28:10 <Twey> I thought it was in syb, but that seems to be a type.
06:28:43 <benmachine> ok, so, what Generic are you talking about?
06:28:53 <benmachine> there's possibly more than one approach to generics in existence
06:29:11 <deathknight_> I heard so many good things about this channel. I hope everyone now feels performance anxiety!
06:29:32 <Twey> I'm trying to do https://hackage.haskell.org/package/binary-0.7.2.1/docs/Data-Binary.html#g:3
06:29:50 <Twey> Oh, *GHC.Generic*.  Sorry, I'm an idiot.
06:29:56 <benmachine> aha
06:30:00 <benmachine> yeah, that's not syb
06:30:13 <benmachine> also, GHC.Generics, plural :)
06:30:16 <Twey> Right.
06:30:23 * Twey shakes his head.
06:30:55 <Tuplanolla> We don't need to do that if you feel cheated instead, deathknight_.
06:30:57 <benmachine> deathknight_: I feel slightly ill, but I think I did that beforehand
06:31:27 <arianvp> I never understood why Writer's type isnt just:
06:31:53 <arianvp> newtype (Monoid w) => Writer w a = Writer { runWriter :: (a,w) }
06:32:05 <arianvp> why do we move the Monoid constraint to the Monad instance?
06:32:13 <arianvp> why not just directly embed it in the datatype?
06:32:16 <benmachine> it would have to be in the Monad instance anyway
06:32:27 <benmachine> datatype contexts do not work how you would like them to work
06:32:32 <arianvp> ow
06:32:33 <Twey> arianvp: Because it isn't necessary for w to be a Monoid in order to *construct* one, only to use it
06:32:52 <arianvp> yes but why would you want to construct a Writer that you cant usse
06:33:04 <benmachine> datatype contexts are actually almost useless, hence them being removed in Haskell2010 (or 2011, I forget)
06:33:12 <Twey> *shrug* Who knows :þ  But generally we like to not arbitrarily limit the user
06:33:34 <Twey> Also yes, datatype contexts are weird — you don't actually get the context propagated to the use site, so you'd have to duplicate it
06:33:43 <arianvp> oh lame
06:33:55 <arianvp> I'm wondering if a Semigroup-based writer would be of any use
06:34:00 <arianvp> non-empty logs? hehe
06:34:43 <benmachine> arianvp: the most obvious problem with Semigroup-based writer is writing "return"
06:35:02 <arianvp> oh yeah true
06:35:33 <benmachine> fun fact: if you can make (w,a) into a Monad, that tells you that w is a Monoid
06:36:21 <arianvp> that kind of make sense
06:36:27 <benmachine> so not only is it sufficient, it's actually also necessary
06:36:33 <benmachine> it's precisely the right condition
06:41:50 <arianvp> benmachine: If that constraint is so strong. why the newtype wrapper?
06:42:04 <arianvp> if it's the _only_  implementation why not just have a monadd instance for (w,a)
06:42:10 <benmachine> arianvp: good question
06:42:16 <benmachine> some would say we should have that instance!
06:42:25 * benmachine shrug
06:42:40 <arianvp> Same for (->) r
06:42:46 <benmachine> well, we *do* have that one
06:42:57 <arianvp> yep
06:46:26 <arianvp> Another piece of magic I dont understand is : https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Error-Class.html
06:46:39 <arianvp> Why is there  strMsg  if there is no way to throw ann error with a message!
06:46:46 <arianvp> :@
06:47:08 <Twey> arianvp, benmachine: I feel like Writer is wrong, anyway.  Update seems to fit more nicely into the general scheme of R/W/S.
06:47:10 <Heffalump> arianvp: isn't that what fail does?
06:47:22 <benmachine> Twey: huh?
06:47:43 <arianvp> Heffalump: Oh yeah I see. I always secretly try to forget that wart
06:47:59 <Heffalump> :-)
06:48:09 <Twey> benmachine: http://homepages.inf.ed.ac.uk/s1225336/talks/types13.pdf
06:48:48 <Twey> benmachine: State as it exists in Haskell isn't actually a combination of Reader and Writer.  Update is the monad such that combining Reader and Update gives you State
06:49:21 <arianvp> but what is wrong with writer then
06:51:09 * Twey may be misremembering this a bit, actually
06:51:27 <arianvp> I always feel a bit dumb when I look at these kind of slides
06:51:30 <arianvp> hehehe
06:52:09 <Twey> Right, sorry, Update is a generalization of State generated by a composition of Reader and Writer
06:52:09 <benmachine> Twey: looks to me like Update is more powerful than reader or writer
06:52:18 <benmachine> oh right
06:52:28 <Twey> Ignore the previous :þ
06:52:49 <arianvp> so you could get State by combining R and W? nice
06:53:18 <Twey> Not State, but Update
06:53:31 <arianvp> but Update is a generalisation of State you said
06:53:48 <arianvp> meaning that you can construct a State from an Update?
06:53:49 <Twey> Which is basically State generalized over a monoid — so you no longer have to *replace* your old state with a new one, but instead combine them using some monoid operation
06:53:56 <Twey> (which can be replace, to get you back to State)
06:53:56 <arianvp> ah
06:55:08 <Twey> Right, which is precisely a combination of Reader and Writer — you read the original environment and write a type of ‘updates’ to the environment; applying the updates to the environment gives you the current state
06:55:42 <arianvp> so if you'd use `flip const` as your definition of mappend you'd get back State?
06:55:56 <benmachine> you can't quite use that, because it doesn't have an identity
06:55:58 <benmachine> but something similar
06:57:18 <Twey> Right, you need a no-op.  So you can use something like data StateUpdate s = Id | New s, where apply Id s = s; apply (New s') s = s'
06:58:36 <Twey> Which is Monoid: instance Monoid (StateUpdate s) where mempty = Id; mappend Id y = y; mappend x Id = x; mappend x y = y
06:58:55 <Twey> (this is Maybe, by the way)
06:59:17 <Twey> @src Maybe mappend
06:59:17 <lambdabot> Source not found. Abort, Retry, Panic?
06:59:21 <Twey> Aw.
06:59:49 <arianvp> oh yeah I see
06:59:57 <Twey> Oh, right, yes, Last, not Maybe — Maybe has the Monoid constraint for combining
07:01:47 <arianvp> yeh but algebraically they're the same datatype
07:01:57 <arianvp> right?
07:02:18 <Twey> Then to get your ‘current state’ you apply all the updates you've written so far (with ‘listen’ from Writer) and ‘apply’ them to your original enviroment (‘get’ from Reader)
07:02:27 <Twey> s/you apply/you take/
07:02:42 <Twey> arianvp: They're isomorphic, but have different instances, right
07:02:49 <Twey> (actually, I think Last is a newtype over Maybe)
07:03:27 <arianvp> I might experiment a bit with this Update
07:03:38 <discipline> Hello lads, Data.Map.empty gives me an empty Map Int String, how can I create an empty Map Int Float ?
07:03:57 <arianvp> Data.Map.empty gives you an empty Map key value
07:04:00 <arianvp> for any key value pair
07:04:05 <Twey> s/get/ask/ sorry
07:04:17 <Twey> :t Map.empty
07:04:18 <lambdabot>     Not in scope: ‘Map.empty’
07:04:19 <lambdabot>     Perhaps you meant ‘M.empty’ (imported from Data.Map)
07:04:22 <Twey> :t M.empty
07:04:23 <lambdabot> M.Map k a
07:04:56 <arianvp> discipline: you're probably trying to both insert strings and floats into the same Map
07:04:59 <arianvp> which is not possible in haskell
07:05:08 <Twey> discipline: The type returned by M.empty is decided by how you use it.  If you're not using it anywhere you can ascribe it an explicit type annotation instead: (M.empty :: M.Map Int Float)
07:05:39 <discipline> arianvp: oh, I try to pass it to a function expecting Map Int Float and it says it has expected type Map Int [Char], hum, let me paste the code
07:05:40 <Twey> s/annotation/with an annotation/
07:05:49 <arianvp> yes sure.
07:05:58 <geekosaur> that implies your types are wrong somewhere
07:06:29 <lpaste> discipline pasted “The map issue” at http://lpaste.net/109929
07:07:29 <arianvp> addedValue = show (value + current)
07:07:34 <arianvp> is off type [Char] not Float
07:07:36 <arianvp> remove the show
07:07:54 <lpaste> discipline revised “The map issue”: “Map issue, full code” at http://lpaste.net/109929
07:08:09 <discipline> oh god
07:08:11 <arianvp> :)
07:08:14 <discipline> thank you so much
07:08:20 <discipline> duh
07:08:23 <discipline> :-)
07:08:32 <discipline> arianvp: you are the man
07:08:39 <arianvp> I try I try
07:08:41 <arianvp> :P
07:09:05 <Twey> discipline: You misspelt ‘delimiter’ too :þ
07:09:43 <discipline> hahah thanks for pointing it out
07:09:57 <discipline> it is really not a measuring unit ;-)
07:10:23 <arianvp> how much? meh around one delimeter I guess
07:10:38 <arianvp> could be a good unit for measuring tastyness
07:10:55 <arianvp> "This hamburger. my delimeter is off the charts"
07:11:50 <Twey> Heheh.
07:13:11 <arianvp> hmm I need a nice way to keep track of the source position of my expressions in my interpreter
07:13:12 <arianvp> :/
07:13:20 <arianvp> hmm (SourcePos, Expr) will do I guess
07:15:08 <sgronblo> What's a capability?
07:21:07 <Twey> sgronblo: http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
07:27:10 * hackagebot chatty-utils 0.6 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.6 (implementation)
07:29:55 <sgronblo> Twey: new concepts are never ending :)
07:45:14 <Twey> sgronblo: Quite possibly literally!
07:48:54 <joe9> In C programming, wait() returns if there is an interrupt. But, that is not happening with getAnyProcessStatus of haskell. Is there any way to enable that?
07:52:01 <zmbmartin> I am still not 100% with type signatures. I am using Database.MongoDB and there is a function lookup in Data.Bson -> lookup :: (https://hackage.haskell.org/package/bson-0.3/docs/Data-Bson.html#t:Val v, https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad m) => https://hackage.haskell.org/package/bson-0.3/docs/Data-Bson.html#t:Label -> https://hackage.haskell.org/package/bson-0.3/docs/Data-Bson.html#t:Document -> m v
07:52:18 <zmbmartin> I am not sure how to use it.
07:52:41 <zmbmartin> I tried -> lookup Label Document
07:53:16 <zmbmartin> But that errors.
07:56:43 <Twey> zmbmartin: You mean: lookup ∷ (Val v, Monad m) ⇒ Label → Document → m v ?
07:57:21 <Twey> zmbmartin: It means it's a function that takes a Label and a Document and provides a result of type m v, where m is some Monad and v is some Val
07:57:36 <Twey> zmbmartin: Label and Document are types; what you want are *values* of those types
07:58:12 <Twey> zmbmartin: For example, 3 can be an Int, but Int is not an Int.  So if you have a function that expects an Int, writing ‘Int’ is invalid.
07:58:30 <Twey> 1 + Int, for example, doesn't make sense.
07:59:02 <Twey> zmbmartin: If you want more specific advice, you'll have to give more information about the code and the error.
08:01:16 <yesthisisuser> So, the way acid-state works. There is really no difference using a "proper" hashtable as opposed to, say, Data.Map or a persistent data-structure if I understand correctly.
08:01:26 <zmbmartin> Twey: So do I need to pass it more then a Label and Document.
08:01:37 <zmbmartin> Twey: Let me paste an example.
08:02:08 <tabemann> zmbmartin: you need to pass it a label and a document
08:02:15 * hackagebot auto-update 0.1.1.2 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.2 (MichaelSnoyman)
08:04:55 <zmbmartin> tabemann Twey: OK I think I see what I am doing wrong. Thanks!
08:08:57 <McManiaC> i have a list of objects which contain a lot of (optional) nested objects, which again contain optional nested objects (optional meaning Maybe) and I want to get a list of all "Just .." values of some of the nested objects
08:09:06 <McManiaC> because of the nested things this sounds like a perfect job for lenses
08:09:31 <McManiaC> but i cant wrap my head aroudn on how to use lenses as a "filter" on my list
08:09:32 <Ragnar_> @pl \f -> fold . fmap f
08:09:32 <Guuf> Yes.
08:09:32 <lambdabot> (fold .) . fmap
08:09:57 <McManiaC> any hints?
08:10:33 <Guuf> I am a lens newbie myself, but I can see if can find something...
08:11:25 <McManiaC> something like, pseudo coded
08:12:01 <McManiaC> listOfObjects ??? on _Just fieldLensA . on _Just fieldLensB
08:12:02 <McManiaC> etc
08:17:18 * hackagebot igrf 0.2.0.0 - International Geomagnetic Reference Field  http://hackage.haskell.org/package/igrf-0.2.0.0 (dmcclean)
08:25:20 <yitz> yesthisisuser: am i missing a previous part of the conversation? there is a difference between storing data on disk and storing it in memory.
08:27:34 <yesthisisuser> yitz: no i am mostly talking to myself.. hehe. no but I am still struggling to understand how acid-state stores data on disk
08:28:18 <yesthisisuser> but ok, yes I see what you are saying. I need to consider both disk access and memory access
08:28:49 <yitz> yesthisisuser: the point of libraries like acid-state and persistent is to automate the generation of code for marshalling data between haskell data types and a persistent store.
08:30:10 <yitz> yesthisisuser: in the case of acid-state, you describe your data as haskell types, and it automatically generates haskell code and SQL code for the getters and setters you need.
08:30:42 <yesthisisuser> sql code?
08:31:03 <yitz> yesthisisuser: in the case of persistent, you describe your data in a simple DSL that is closer to the SQL.
08:31:47 <yitz> yesthisisuser: well, assuming your backend is a SQL database, yes.
08:31:54 <Fuuzetsu> is GHC able to optimise something like someList ++ [1] ++ [2] ++ [3] to compile time?
08:32:18 <Fuuzetsu> I should probably learn how to spit out and rid core
08:32:22 <Fuuzetsu> read Core*
08:33:02 <geekosaur> yesthisisuser, the whole point of acid-state is generating code for storing Haskell in some kind of database, rather than rolling your own persistent data store by hand
08:33:14 <bergey> > [(0, Just (0, Nothing)), (1, Just (1, Just 1)), (2, Nothing) :: (Int, Maybe (Int, Maybe Int))] ^.. traverse . _2 . _Just . _2 . _Just
08:33:16 <lambdabot>  [1]
08:33:23 <bergey> ^ McManiaC
08:33:37 <yesthisisuser> ok now i am confused. i thought acid-state was implemented in terms of some sort of transactional log written to disk
08:33:47 <yitz> Fuuzetsu: yeah look at the core.
08:34:11 <Fuuzetsu> is that ‘yeah it optimises it, look at the core’ or ‘yeah, you should look at the core’
08:34:14 <geekosaur> yesthisisuser, the transactional log is outsourced :p why roll your own when most database managers provide it already?
08:34:47 <arianvp> Hey guys
08:34:48 <geekosaur> you'd normally use it in an application that is already using a database
08:34:56 <arianvp> I don't understand why  I get this error: http://lpaste.net/109935
08:35:15 <arianvp> interpret' (Var var) = do { env <- ask; throwError NotImplemented}  works fine
08:35:21 <yitz> Fuuzetsu: yeah you should look at the core. don't know if it optimizes that.
08:35:26 <Fuuzetsu> OK
08:35:56 <arianvp> anyone got an idea?
08:36:05 <McManiaC> bergey: sweet, thanks
08:36:17 <arianvp> :t maybe
08:36:18 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:36:22 <geekosaur> arianvp, note the package information in the error message
08:36:23 <McManiaC> bergey: how would i for example return a list of lets say, the first int and the last int?
08:36:36 <geekosaur> you very probably have multiple versions of the transformers package
08:36:37 <McManiaC> bergey: so in your example [(1,1)]
08:36:49 <arianvp> geekosaur: but it's running in a sandbox
08:37:20 * hackagebot ghc-mod 5.0.1.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.0.1.1 (DanielG)
08:37:22 <geekosaur> sandboxes are not magic, in particular g;lobal packages are still visible. and transformers is normally supposed to come fromt he global package
08:37:58 <arianvp> ow
08:38:01 <arianvp> that's ... lame
08:38:28 <yitz> arianvp: it's because you say M.lookup var env but env is not a Map, it's an Env.
08:38:38 <arianvp> yitz oh yeah woops
08:39:10 <arianvp> that fixed it :)
08:39:14 <geekosaur> why is it referencing transformers-0.4.1.0:Data.Functor.Identity.Identity
08:39:14 <yitz> yay!
08:39:21 <geekosaur> that's usually a very bad sign
08:39:35 <yitz> glad it wasn't what geekosaur said, which would be a more serious problem :)
08:39:46 <geekosaur> yeh.
08:39:54 <geekosaur> would be nice to know why it's including that though
08:40:01 <geekosaur> because it is such a bad sign...
08:40:03 <Fuuzetsu> geekosaur: it could be that he just doesn't directly depend on transformers in his package
08:40:30 <arianvp> Fuuzetsu: but I do
08:40:35 <yitz> geekosaur: it would be nice if it were easier to distinguish more easily between those two very different kinds of errors from the error message
08:40:46 <arianvp> oh no I dont
08:40:48 <arianvp> I depend on mtl
08:40:59 <Fuuzetsu> OK then I don't know, I'm (nearly) free from package woes ;)
08:41:13 <arianvp> I depend on mtl,, not transformers. why is it pulling in transformers?
08:41:14 <arianvp> :S
08:41:29 <Fuuzetsu> mtl depends on transformers
08:41:38 <arianvp> oh ok
08:41:46 <arianvp> so I should be fine?
08:41:58 <yitz> arianvp: nowadays mtl is just a re-export of transformers, with slightly different API. it used to be a totally separate library.
08:42:02 <Fuuzetsu> so it is probably as I said, you just don't directly depend on transformers so it shows you exactly where it's coming from
08:42:23 <arianvp> mtl is what most people use though right?
08:42:24 <Fuuzetsu> is mtl the most common dependency
08:42:35 <Fuuzetsu> 27k downloads this month
08:42:43 <yitz> arianvp: either one is fine.
08:42:47 <Fuuzetsu> that's 1000 a day if you think about it
08:43:30 <yitz> Fuuzetsu: that's actually unreasonably high. i wonder if it's artificially inflated by some bot and hence meaningless.
08:43:30 <arianvp> wow :P
08:43:52 <Fuuzetsu> yitz: even if half of it is buildbots and whatnot, that's still a lot
08:43:56 <arianvp> Writing interpreters is so much fun
08:44:05 <Fuuzetsu> considering with sandboxes you'll pretty much rebuild it for every project, I can see it hitting that number
08:45:42 <luite> Fuuzetsu: it will be cached after the first download
08:46:02 <Fuuzetsu> hm, I suppose it is downloads and not installs
08:46:18 <yitz> arianvp: packdeps show mtl has 1873 reverse deps, of which 322 are "obsolete" (whatever that means), and transformers has 1143 of which 347 are "obsolete". So about even.
08:46:29 <arianvp> why can't you have cyclic type synonyms?
08:46:30 <Fuuzetsu> buildbots like Travis refetch everything though (which is stupid) so it probabaly comes from that
08:46:34 <yitz> arianvp: http://packdeps.haskellers.com/reverse
08:47:03 <yitz> arianvp: you mean recursive? i don't think you want cyclic...
08:47:11 <arianvp> I want
08:47:22 * hackagebot sized 0.1.0.0 - Sized sequence data-types  http://hackage.haskell.org/package/sized-0.1.0.0 (HiromiIshii)
08:47:22 <arianvp> type Env = Env (Map T.Text Closure)
08:47:26 <arianvp> type Closure = (Expr, Env)
08:47:36 <arianvp> but it doesnt allow me. so I newtype'd it
08:47:45 <arianvp> but now I need to unpack Env everywhere, which is annoying
08:48:13 <yitz> arianvp: type is just a synonym, not much more than a textual substitution.
08:48:59 <yitz> arianvp: you can use record syntax with a newtype. that will give an unwrapper function. slightly less inconvenient sometimes.
08:49:14 <Fuuzetsu> ah, it warms my heart when a single module uses 21 extensions
08:49:23 <Fuuzetsu> (from that sized package just now)
08:50:24 <Markz> data Ex = Ex { mple :: Int } we have mple :: Ex -> Int generated. Why is something like mple_update :: Ex -> Int -> Ex not generated?
08:52:58 <dreams> > (\ x -> case x of | x == 1 -> 1 | otherwise -> 2) 4
08:53:00 <lambdabot>  <hint>:1:19: parse error on input ‘|’
08:53:03 <yitz> Fuuzetsu: 21 is pretty good. the default yesod scaffolded site has only 13 extensions in its cabal file.
08:53:09 <dreams> > (\ x -> case x of _ | x == 1 -> 1 | otherwise -> 2) 4
08:53:11 <lambdabot>  2
08:53:21 <dreams> what's the difference
08:53:22 <Mysterious_Light> as i remember, one can write let ex = ... :: Ex in ex { mple = newValue} to update only this field of tuple, but i have not use this notation
08:53:35 <dreams> what is _ ?
08:53:41 <Mysterious_Light> as i remember, one can write let ex = ... :: Ex in ex { mple = newValue} to update only this field of tuple, but i have not used this notation
08:53:45 <Markz> wildcard?
08:53:46 <yitz> dreams: a pattern match
08:53:49 <Fuuzetsu> well as long as it builds with 7.8.3
08:53:50 * Fuuzetsu packages
08:53:52 <geekosaur> dreams: case is for pattern matching. _ is a pattern
08:54:02 <geekosaur> (the trivial pattern that matches anything)
08:56:12 <yitz> Markz: a very good question that people have been asking for years. basically, it's very unclear what the syntax and semantics of such a thing should be. it's a discussion that has been going on for years.
08:56:26 <dreams> ah wait. nervermind. I was just confused because normally there is no '|' in case of.
08:57:50 <geekosaur> right, we're using guards to get something like switch in other languages. you might be interested in http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#multi-way-if
08:58:07 <yitz> Markz: you can get that effect with the syntax ex { mple = 42 } but that's not composable.
08:58:30 <dreams> geekosaur: is that directed to me?
08:58:34 <geekosaur> which is an extension for a slightly less weird way to do it than by abusing guards on a dummy pattern match
08:58:36 <geekosaur> yes
08:58:38 <Markz> okay, thanks
08:59:25 <dreams> geekosaur: I know what guards are, I just never used them in lambdas, which is obviously different.
08:59:46 <geekosaur> the lambda doesn't have much to do with it, it's part of case
09:00:03 <geekosaur> (there is also lambdacase but that's yet a different thing)
09:00:53 <benmachine> Markz: also, if you've not heard of lenses, maybe you should hear of lenses
09:00:55 <dreams> geekosaur: f x = case x of 1 -> 1 otherwise = 2, you can't do it like that in lambdas.
09:01:02 <goedlel> can someone tell me what this Pico type is and how to use it? http://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-LocalTime.html#t:TimeOfDay
09:01:10 <benmachine> Markz: it's possible to autogenerate lenses for a data type using Template Haskell
09:01:20 <dreams> s/=/->
09:01:21 <benmachine> goedlel: see Data.Fixed
09:01:24 <yitz> dreams: personally i think it's neater to just define a function in the where clause and use regular guards.
09:01:46 <geekosaur> dreams, you can do that in lambdas. what you can't do is the version with top levels that desugars into that case: f 1 = 1; f _ = 2
09:01:47 <dreams> yitz: yes I agree, I'm just messing around with lambdas.
09:01:49 <goedlel> benmachine: i looked at that, still dont understand
09:01:54 <benmachine> goedlel: basically it's a fixed-precision decimal type
09:02:10 <benmachine> goedlel: what do you want to do with it?
09:02:25 <dreams> geekosaur: with the same syntax?
09:02:26 <goedlel> i have a nuber like 12.345 and i need to create a Pico from it
09:02:28 <zmbmartin> Twey: tabemann: Thanks again it actually was a stupid mistake on my part. I had Database.MongoDB hiding (lookup) instead of importing it qualified as …
09:02:31 <goedlel> its in text initially
09:02:57 <benmachine> > read "12.345" :: Pico
09:03:01 <lambdabot>  mueval-core: Time limit exceeded
09:03:05 <benmachine> wat :/
09:03:06 <yitz> goedlel: you can create a Rational and then use realToFrac
09:03:24 <benmachine> wow, that actually does seem to loop
09:03:28 <dreams> geekosaur: (\ x -> case x of 1 -> 1 otherwise -> 2) 2   <-- doesn't work.
09:03:36 <yitz> > realToFrac (read "12.345" :: Rational) :: Pico
09:03:38 <lambdabot>  *Exception: Prelude.read: no parse
09:03:39 <goedlel> oh I can use read ?
09:03:47 <yitz> wat
09:03:56 <geekosaur> dreams: you're missing a |
09:04:01 <goedlel> can I do read "12.345" :: Pico ?
09:04:12 <benmachine> goedlel: you ought to be able to, but looks like there's a bug
09:04:18 <goedlel> I can't tell based on the docs
09:04:18 <geekosaur> or a ; and something else
09:04:19 <kurt21> Why does this not work: type Num2Num = Num a => a -> a
09:04:22 <arianvp> Why does HM have a Let rule if we've got Lam and Abs?
09:04:25 <geekosaur> you are confusing patterns and guards
09:04:36 <benmachine> goedlel: for now, read it as a Double and then convert it with realToFrac
09:04:36 <dreams> geekosaur: well in a pure function you don't have to type |, that's my point.
09:04:47 <goedlel> ok ill do that
09:05:00 <geekosaur> dreams: sometimes you do, if it's sufficiently pattern-like.
09:05:19 <geekosaur> dreams: in particular, `otherwise` in the thing you are thinking of is not doing what you think it is
09:05:34 <dreams> geekosaur: what then?
09:06:01 <geekosaur> it's a new binding which matches anything, like _ but named and shadowing the Prelude's definition
09:06:05 <yitz> wow. the Read instance of Rational appears to be broken. tried that in GHCi too.
09:06:48 <yitz> > realToFrac (12.345 :: Rational) :: Pico
09:06:50 <lambdabot>  12.345000000000
09:06:50 <geekosaur> dreams: this is fairly confusing at first, but you need to distinguish between patterns and guards
09:07:05 <dreams> geekosaur: you mean its equivalent to case x of 1 -> 1 _ -> 2 ?
09:07:09 <geekosaur> yes
09:07:21 <geekosaur> (also you need a semicolon there, or use layout)
09:07:37 <geekosaur> (maybe that also is confusing you)
09:07:42 <goedlel> realToFrac (read "12.234" :: Rational) :: Pico
09:08:04 <dreams> geekosaur: that was just an example. I normally type them in new lines.
09:08:11 <geekosaur> > case 2 of 1 -> 1; otherwise -> otherwise
09:08:12 <goedlel> realToFrac ((read "12.234") :: Rational) :: Pico
09:08:14 <lambdabot>  2
09:08:16 <kurt21> yitz: This works: read "3 % 5" :: Ratio Int
09:08:27 <dreams> geekosaur: case of is just pattern matching isn't it?
09:08:29 <goedlel> > realToFrac (read "12.234" :: Rational) :: Pico
09:08:30 <lambdabot>  *Exception: Prelude.read: no parse
09:08:43 <geekosaur> do you see what happened there?
09:08:47 <goedlel> > realToFrac ((read "12.234") :: Rational) :: Pico
09:08:49 <lambdabot>  *Exception: Prelude.read: no parse
09:08:52 <kurt21> Why does this type alias with a class constraint not work: type Num2Num = Num a => a -> a
09:08:54 <goedlel> wut
09:08:56 <benmachine> goedlel: that's not how the Rational read format works
09:09:05 <benmachine> > read "2 % 5" :: Rational
09:09:08 <lambdabot>  2 % 5
09:09:15 <dreams> geekosaur: oh wow,
09:09:33 <goedlel> > realToFrac (read "12.234" :: Double) :: Pico
09:09:35 <lambdabot>  12.233999999999
09:09:39 <goedlel> ah
09:09:43 <dreams> geekosaur: thats enlightening.
09:09:44 <geekosaur> patterns create bindings. we use _ when we don't want a binding.
09:10:21 <goedlel> > realToFrac (read "12.234") :: Pico
09:10:23 <lambdabot>  *Exception: Prelude.read: no parse
09:10:30 <geekosaur> and the other half of what's going on between patterns and guards is
09:10:33 <geekosaur> > otherwise
09:10:35 <lambdabot>  True
09:11:27 <dreams> > case _ of 1 -> 1; otherwise -> otherwise
09:11:29 <lambdabot>  Found hole ‘_’ with type: a
09:11:29 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:11:29 <lambdabot>             the inferred type of it :: a at Top level
09:11:29 <geekosaur> it's just an alias of sorts for readability; you are creating a guard whose value is always True, so that it is used if nothing else did
09:11:36 <geekosaur> heh
09:11:53 <dreams> > case 2 of 1 -> 1; _ -> _
09:11:54 <geekosaur> that part is not a pattern, it's a value. so you just triggered the TypeHoles extension
09:11:55 <lambdabot>  Found hole ‘_’ with type: a
09:11:55 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:11:55 <lambdabot>             the inferred type of it :: a at Top level
09:12:43 <geekosaur> hrm. is it me or should that have inferred a type of Num a => a
09:12:59 <geekosaur> or at least Integral a => a
09:13:06 <dreams> geekosaur: ok, what I got so far is that otherwise is bound to the expression in case expr of.
09:13:15 <geekosaur> when used as a pattern, yes
09:13:22 <yitz> huh. fractional numeric literals are supposedly interpreted using fromRational. yet those literals are not valid Rational literals!
09:13:23 <geekosaur> but with | it is part of a guard, and is just an expression
09:14:08 <yitz> well, they are valid literals, but the Read instance doesn't work for them.
09:14:10 <geekosaur> yitz: yes, the compiler converts 12.234 to 12234 % 100000 and then applies fromRational to that
09:14:16 <geekosaur> er
09:14:33 <geekosaur> 122340 % 10000
09:14:41 <yitz> geekosaur: that conversion is a hidden special case; it's not exposed in the Read instance. weird.
09:14:43 * geekosaur might be trying to do too many things at once
09:14:54 <goedlel> for some reason when i search 'parseOnly' on hoogle it doesn't show up
09:14:56 <geekosaur> yes, it's not part of read, it's a compiler intrinsic
09:15:06 <goedlel> its in Data.Attoparsec
09:15:09 * yitz thinks geekosaur is also juggling 5 balls
09:15:18 <geekosaur> goedlel: the standard hoogle only indexes stuff that comes with ghc. try the one on fpcomplete
09:15:27 <goedlel> ah
09:16:12 <geekosaur> you can make the standard one find other things if you name the package specifically, otherwise it sticks to bootlibs
09:16:25 <geekosaur> whereas fpcomplete should search all of hackage automatically
09:17:02 <goedlel> ok
09:19:49 <yitz> goedlel: you can use Data.Text.rational to read a Pico.
09:20:24 <goedlel> yitz: already did it with read :: Double and realToFrac
09:20:44 <yitz> oops Data.Text.Read.rational
09:21:06 <yitz> goedlel: going via an IEEE floating point is very messy
09:21:20 <goedlel> oh
09:21:24 <goedlel> ok then
09:22:50 <goedlel> yitz: not sure how to use Reader type
09:23:43 <goedlel> > rational "12.234"
09:23:45 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
09:23:45 <lambdabot>                with ‘GHC.Real.Ratio GHC.Integer.Type.Integer’
09:23:46 <lambdabot>  Expected type: GHC.Real.Rational
09:23:46 <lambdabot>    Actual type: [GHC.Types.Char]
09:23:47 <yitz> goedlel: in this case it's a synonym for Fractional a => Text -> Either String (a, a)
09:24:00 <statusfailed> How do I get a producer of Text or Bytestring lines using Pipes which is doing input buffering 'under the hood'?
09:24:13 <yitz> @type rational
09:24:15 <lambdabot> Rational -> Doc
09:24:31 <yitz> oh no wrong rational. we want Data.Text.Read.rational.
09:24:39 <goedlel> > Data.Text.Read.rational "12.234"
09:24:41 <lambdabot>  Not in scope: ‘Data.Text.Read.rational’
09:26:59 <yitz> goedlel: got it slightly wrong. it's a synonym for Fractional a => Text -> Either String (a, Text)
09:27:26 * hackagebot arbtt 0.8.1.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8.1.1 (JoachimBreitner)
09:27:36 <goedlel> is a Pico a Fractional?
09:28:41 <yitz> goedlel: if the return value is Left, the conversion failed, if it's (n, x), n is the Pico, and x is the remaining text. so rational "12.345boom" == Right (12.3450000000, "boom")
09:28:58 <yitz> goedlel: yes.
09:29:16 <goedlel> yitz: would it be slow to convert from ByteString to Text?
09:29:31 <goedlel> because I currently have the data as ByteString
09:29:32 <k00mi> goedlel: you can look that up in ghci with «:info Pico»
09:29:58 <dreams> geekosaur: this is confusing
09:30:18 <dreams> > case 2 of otherwise -> otherwise
09:30:20 <lambdabot>  2
09:30:24 <dreams>  > case 2 of 2 -> otherwise
09:30:33 <dreams> > case 2 of 2 -> otherwise
09:30:35 <lambdabot>  True
09:30:36 <dreams> why does the second one return True?
09:30:45 <geekosaur> `otherwise` there is a pattern that matches anything, it creates a new local binding
09:30:48 <yitz> goedlel: convert it to Text using Data.Text.Encoding.decodeUtf8
09:30:57 <geekosaur> the Prelude *also* defines a binding `otherwise` whose value is True
09:31:24 <geekosaur> if you turn on shadowing warnings, ghc will tell you that the first one is shadowing an existing binding when it creates the new one
09:31:37 <yitz> > case 2 of 3 -> otherwise
09:31:39 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
09:33:00 <geekosaur> in terms of other languages (somewhat inaccurate, but close enough in this case) `otherwise` is a global variable, but you have defined a local variable with the same name
09:33:10 <dreams> geekosaur: I though otherwise is bound to the expression in case expr of. Now its also bound to a boolean?
09:33:12 <yitz> > case 2 of otherwise -> otherwise + 40
09:33:13 <lambdabot>  42
09:33:19 <geekosaur> > otherwise
09:33:21 <lambdabot>  True
09:33:26 <geekosaur> ^ defined in Prelude
09:33:30 <hpc> my favorite "syntax"
09:33:35 <yitz> > case 2 of 2 -> otherwise + 40
09:33:37 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
09:33:37 <lambdabot>    arising from a use of ‘GHC.Num.+’
09:33:42 <geekosaur> if you use it *as a pattern*, then you are creating a new local variable that hides the globally defined one
09:33:47 <shiona> > otherwise && False
09:33:49 <lambdabot>  False
09:33:57 <dreams> geekosaur: ah, so when you pattern match it, it binds it to a different value?
09:34:03 <dreams> ah ok
09:34:07 <geekosaur> > case Just 3 of Just x -> x; Nothing -> 0
09:34:09 <lambdabot>  3
09:34:20 <geekosaur> here I used a pattern that locally creates an "x"
09:34:22 <geekosaur> > x
09:34:24 <lambdabot>  x
09:34:32 <geekosaur> whoops, right...
09:34:47 <geekosaur> lambdabot has all the single character ones predefined >.>
09:35:00 <dreams> cool.
09:35:03 <dreams> geekosaur: thanks.
09:35:07 <geekosaur> anyway it's a local "variable" that only exists within that branch of the case expression
09:36:03 <goedlel> how do i extract the result from an either
09:36:19 <geekosaur> > case 2 of 2 -> Prelude.otherwise; otherwise -> False
09:36:22 <lambdabot>  True
09:36:30 <geekosaur> there's some confusion for you :p
09:36:37 <yitz> btw ghc optimizes away a guard consisting of otherwise and skips the trivial test. not sure if that happens if you use True instead.
09:36:39 <geekosaur> oh, I did that wrongh
09:36:56 <geekosaur> ... that sounds wrong
09:37:09 <geekosaur> since otherwise is literally `otherwise = True`
09:37:27 <dreams> geekosaur: so? it returned True.
09:37:28 <yitz> geekosaur: i asked simon mar about that once.
09:37:37 <geekosaur> if ghc is actually checking for the name there, that just seems to ask for trouble
09:37:59 <dreams> > case 2 of 1 -> Prelude.otherwise; otherwise -> False
09:38:01 <lambdabot>  False
09:38:08 <geekosaur> dreams: I started writing one thing and ended with something else
09:38:20 <McManiaC> is there any way to do something like this with lenses?
09:38:21 <McManiaC> [(1,Just 2),(3,Just 4)] ^.. folded . ((,) <$> _1 <*> _2 . _Just)
09:38:22 <geekosaur> > case 2 of 1 -> False; otherwise -> Prelude.otherwise
09:38:24 <lambdabot>  True
09:38:51 <yitz> geekosaur: on the other had, evaluating an expression and determining at compile time that it is always True is a lot more than just checking for the name "otherwise".
09:38:58 <yitz> geekosaur: why asking for trouble?
09:39:06 <barrucadu> goedlel: `either` (Data.Either)
09:39:09 <barrucadu> :t either
09:39:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
09:39:12 <geekosaur> I dislike the idea of hardwiring special names in general
09:39:22 <barrucadu> Or use a case
09:39:49 <geekosaur> and yes, I know it happens on other places, but those are at least documented...
09:39:54 <Algebr> in: instance Functor (Either a) where, why isn't it (Either a b)? Does the a in (Either a) capture both a b?
09:40:08 <geekosaur> Algebr: b needs to be "free" there
09:40:10 <yitz> geekosaur: agreed. but here it seems pretty safe to treat " | otherwise " as a very common synonym for "else".
09:40:12 <barrucadu> Algebr: Functor has kind * -> *
09:40:28 <geekosaur> and a cannot be free, because Functor must be of kind *
09:40:31 <yitz> geekosaur: unless NoImplicitPrelude is in effect.
09:41:03 <Algebr> geekosaur: I don't understand..
09:41:32 <edwardk> > [(1,Just 2),(3,Just 4)] ^.. folded . getFold ((,) <$> Fold _1 <*> Fold (_2 . _Just))
09:41:34 <lambdabot>  Not in scope: ‘getFold’
09:41:38 <geekosaur> Functor requires something that takes a type as a parameter. Either takes two types; you must specify one of them in the instance, so one is left for Functor to use
09:41:40 <edwardk> > [(1,Just 2),(3,Just 4)] ^.. folded . runFold ((,) <$> Fold _1 <*> Fold (_2 . _Just))
09:41:42 <lambdabot>  [(1,2),(3,4)]
09:41:51 <edwardk> McManiaC: ^-
09:42:11 <Algebr> ah,
09:42:12 <geekosaur> :k Either
09:42:13 <lambdabot> * -> * -> *
09:42:18 <goedlel> > either id fst (Data.Text.Read.rational (Data.Text.pack "12.3"))
09:42:20 <lambdabot>  Not in scope: ‘Data.Text.Read.rational’Not in scope: ‘Data.Text.pack’
09:42:25 <geekosaur> :k Maybe
09:42:27 <lambdabot> * -> *
09:42:40 <geekosaur> Maybe can be used as instance Functor Maybe
09:42:55 <Algebr> So if functor used up 2, then I would be able to (Either a b)
09:43:12 <geekosaur> :k Either Int
09:43:13 <lambdabot> * -> *
09:43:19 <geekosaur> now it has the right kind to be a Functor
09:43:42 <geekosaur> you can use a type variable instead of a type, but you need to "capture" it somehow so Functor sees something of kind * -> *
09:43:44 <goedlel> Whats going on here: http://lpaste.net/109940 ?
09:44:49 <yitz> goedlel: the Left case is an error message, not a Pico, so you can't use id. you can use error if you don't mind crashing in that case.
09:45:01 <goedlel> ah ok
09:45:12 <goedlel> yup that works
09:45:31 <yitz> goedlel: otherwise, you actually have to tell it what to do if the parse fails.
09:45:37 <McManiaC> edwardk: awesome, thanks!!
09:47:32 <yitz> goedlel: or you could use either Nothing (Just . fst) to postpone that for later.
09:47:45 <goedlel> ah ok
09:48:22 <yitz> um either (const Nothing) (Just . fst)
09:52:07 <yitz> @type either (const Nothing) (Just . fst)
09:52:08 <lambdabot> Either a (a1, b) -> Maybe a1
09:54:54 <gvr> :pl f x = x+1
09:55:17 <yitz> gvr: use @pl
09:55:30 <gvr> sorry!
09:55:49 <gvr> @pl f x = x+1
09:55:50 <lambdabot> f = (1 +)
09:55:55 <yitz> gvr: don't apologize to me, apologize to lambdabot :)
09:56:11 <Algebr> I get issues with this small instance based code, http://lpaste.net/109941
09:56:31 <barrucadu> yitz: Clearly lambdabot needs an emotions plugin, and to refuse to answer people who mistype too many commands
09:56:39 <gvr> @pl tail (inits (take (length haystack) needle))
09:56:40 <lambdabot> tail (inits (take (length haystack) needle))
09:57:00 <gvr> @unpl tail (inits (take (length haystack) needle))
09:57:00 <lambdabot> tail (inits (take (length haystack) needle))
09:57:21 <barrucadu> gvr: There are no points in that, maybe you mean \haystack needle -> tail (inits (take (length haystack) needle))
09:58:04 <yitz> barrucadu: there used to be something like that, but they disabled it because the "persona" was deemed offensive.
09:58:22 <yitz> Algebr: two problems
09:58:39 <yitz> Algebr: one is that you are not using f, so you're never getting to the type b as required.
09:58:54 <yitz> Algebr: the other is that you're missing the Right case.
09:59:04 <Algebr> ya, wanted to get left case first
09:59:21 <Algebr> but why should f be used?
10:00:10 <marrrk> Hey, is there something like Scala’s getOrElse on a Haskell Maybe?
10:00:16 <gvr> yup, that's right. Guess, all lambda-bot requests are put in logs and visible for everybody, that's weird. Anyway, you're very kind to newbies here
10:01:36 <yitz> Algebr: ah i see in your reversed Either Left is the "error" case so you don't apply f. that actually looks right. what is the problem?
10:01:42 <supki> marrrk: Data.Maybe.fromMaybe
10:01:50 <marrrk> Thank you, I will try that
10:01:59 <yitz> marrrk: or maybe from the Prelude
10:02:07 <yitz> @type maybe
10:02:08 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:02:17 <Algebr> yitz: I get this error: Couldn't match type `a' with `b' …
10:02:18 <Algebr>       `a' is a rigid type variable bound by
10:02:18 <Algebr>           the type signature for
10:02:18 <Algebr>             furry :: (a -> b) -> EitherLeft t a -> EitherLeft t b
10:02:20 <Algebr>           at /home/edgar/HTutorials/twenty_probs.hs:31:3
10:02:24 <Algebr>       `b' is a rigid type variable bound by
10:02:27 <Algebr>           the type signature for
10:02:31 <Algebr>             furry :: (a -> b) -> EitherLeft t a -> EitherLeft t b
10:02:37 <Algebr> oops, sorry about the code post, thought itd be one line
10:05:36 <joe9> I am trying to figure out the haskell version of sigwait(). The bindings are here: http://hackage.haskell.org/package/bindings-posix-1.2.6/docs/Bindings-Posix-Signal.html
10:05:41 <yitz> ah no, so then maybe that *is* the case where you need to apply f.
10:05:49 <joe9> Just wanted to check if anyone is aware of any.
10:07:10 <joe9> Is there any reason http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Signals.html does not have sigwait()? Is there something about haskell's implementation that breaks it?
10:07:32 <Algebr> yitz: ha, yea, it was indeed reversed. Guess that's part of the exercise.
10:08:07 <Algebr> What is ((->) t) mean?
10:08:09 <Algebr> does*
10:09:19 <barrucadu> Partially-applied function arrow type. "(->) a b" is the same as "a -> b"
10:09:34 <ij> So t takes the place of a, right?
10:09:48 <barrucadu> Yes; sorry, should have used a 't'
10:10:02 <ij> I was always wondering about this.
10:10:11 <monochrom> so draw this analogy: Maybe a : Maybe :: (->) t a : (->) t
10:11:07 <yitz> joe9: it has awaitSignal. is that what you need?
10:11:20 <monochrom> for example "instance Functor ((->) t) where ..." is legal
10:12:04 <Algebr> monochrom: so ((->) t) is really just t -> ?
10:12:32 <monochrom> yes, except t -> is a syntax error
10:12:41 <mads-> If I have a string, how do I best ask "How many A's, B's and C's are in it?"?
10:13:03 <Algebr> what does the fmap implentation of that look like?
10:13:22 <yitz> mads-: hint: use the filter function
10:13:26 <yitz> @type filter
10:13:27 <lambdabot> (a -> Bool) -> [a] -> [a]
10:13:33 <Algebr> mads-: Maybe do a group on the string? then count the lenghts?
10:13:58 <joe9> yitz: no awaitsignal uses sigsuspend. From what I read, that is different from sigwait.
10:14:26 <mads-> yitz: then do a filter for each char?
10:14:28 <monochrom> fmap f xs = f . xs
10:15:39 <pjdelport> Algebr: It can sometimes help to consider type Reader = (->)
10:16:06 <pjdelport> Algebr: Then e -> a is Reader e a, and ((->) e) is Reader e
10:16:18 <pavonia> :t group
10:16:19 <lambdabot> Eq a => [a] -> [[a]]
10:16:39 <yitz> joe9: i see. hmm. i'm not familiar with bindings-posix, and it hasn't been updated for a while. but you could either use that, or just use FFI yourself to access sigwait.
10:18:03 <joe9> yitz: looks like ffi is my only option. I raised an issue in github System.Posix. Hopefully, it will be added in.
10:18:03 <yitz> mads-: there are a few different approaches. that's one of them, and it works. it requires a separate pass throught the string for each letter, though.
10:18:44 <joe9> !seen ezyang
10:19:01 <joe9> Has anyone seen ezyang?
10:19:30 <yitz> joe9: ok. sounds good. FFI for one very standard C function really isn't so bad. you may need some CPP for the import if you need to support a lot of platforms though.
10:19:48 <hpc> no preflex :(
10:21:09 <dfeuer_> Ping nomeata
10:21:42 <nomeata> dfeuer: pon
10:21:43 <nomeata> *pong
10:24:44 <dfeuer> nomeata, I was just hoping to discuss that foldr2 thing for a moment. I *think* option 3 is semantically okay, but I wish I felt more confident about it. I also don't like the fact that option 3 (as well as the current implementation) rules out apparently-legitimate uses for the asymmetry in the Report version.
10:25:51 <dfeuer> The most important question in my mind is whether option 3 will give the same semantics in each case; that seems to be a reasonable baseline requirement.
10:26:21 <nomeata> dfeuer: what do you mean by “in each case”? Do you mean no fusion vs. fusion on the left vs. fusion on the right?
10:26:55 <dfeuer> Yes, nomeata. Like I said, I think it's okay, but I'd like a second opinion.
10:27:32 <nomeata> Did you try to find a fusion rule for right that would preserve the current semantics?
10:27:33 * hackagebot https-everywhere-rules 0.0.2 - High-level access to HTTPS Everywhere rulesets.  http://hackage.haskell.org/package/https-everywhere-rules-0.0.2 (vi)
10:27:56 <dfeuer> The sort of thing it (and the current impl) rules out is safely doing something like zipping a counting list against a list that bottoms out right past what you're counting to.
10:28:23 <dfeuer> nomeata, that would be nice, wouldn't it .... I'll race you to an attempt.
10:29:28 <nomeata> You say (and the current impl), but you really should say: (and the curren impl, if it fuses on the right), right?
10:29:41 <dfeuer> Yes.
10:30:27 <dfeuer> I think adding noinlinableIdentity should be a performance measure, not a semantic change.
10:30:46 <dfeuer> I'm not sure it's possible to do what you want. I'd like it to be.
10:32:33 * hackagebot https-everywhere-rules 0.1.0 - High-level access to HTTPS Everywhere rulesets.  http://hackage.haskell.org/package/https-everywhere-rules-0.1.0 (vi)
10:33:18 <nomeata> dfeuer: looking at the code I wonder: the problem isn't quite "zip [] ⊥" but "zip [] (build ⊥)", right?
10:34:02 <nomeata> I wonder how realistical _that_ is
10:35:06 <nomeata> So I wonder: Is there code that does _not_ contain build yet (i.e. “normal” list functions) that triggers the semantic change.
10:35:46 <nomeata> Because using build directly in the presence of bottom is not guarnateed to be semantically sound anyways, isn’t it?
10:38:54 <dfeuer> nomeata, let me look at that.
10:39:17 <dfeuer> Using build *is* semantically sound in the presence of bottom.
10:39:50 <dfeuer> It's not semantically sound if the argument to build forces any type that build requires to be polymorphic.
10:40:53 <davorb> hey guys. i'm trying to use the →-operator in ghc, but when I try to compile my program, I get an error saying "Illegal operator `→' in type `String → String'". is there a way around this?
10:41:06 <davorb> that is, make use of utf8.
10:41:15 <dfeuer> davorb, you need a LANGUAGE pragma at the top of your file.
10:41:21 <dfeuer> I don't remember which.
10:41:55 <nomeata> dfeuer: ah, confused seq and undefined. sorry.
10:42:06 <nomeata> dfeuer: but still, it would make the issue less severe
10:42:19 <dfeuer> nomeata, I'm still trying to figure out the answer to your question about the exact way it breaks down.
10:42:56 <eivuokko> Is the choice between 32bit and 64bit for haskell platform (Windows) also a choice of which kind of external libraries I can (only) use?
10:46:12 <Algebr> is it possible to have something like, class Foo f g where
10:46:21 <dfeuer> nomeata, the problem is worse than the example given suggests, I tihnk.
10:47:07 <seangrove> Hey all, just getting started, and I'm trying to install present + stylish-haskell + ghc-mod, and cabal tells me that present will break the other two
10:47:35 <seangrove> Is this an obvious problem, or likely just an issue with my setup?
10:48:03 <dfeuer> nomeata,  foldr2 k z [] (build (\c n -> undefined))   rewrites under that rule to (\c n -> undefined) (foldr2_right k z) (\_ -> z) []   which reduces to undefined.)
10:49:22 <nomeata> dfeuer: right, this is (almost) the example from the source code. But how do I trigger that without build?... Well, I guess "filter undefined [0..10]" does the job. So I guess that settles it...
10:49:27 <goedlel> Why am I getting this error? http://lpaste.net/109942
10:49:36 <goedlel> error bottom, code on top
10:50:27 <goedlel> oh sorry
10:50:30 <dfeuer> nomeata, sorry, I was just noting that the build function doesn't have to be undefined; it just needs to produce undefined values.
10:50:37 <goedlel> forgot to propery qualify Done type
10:50:39 <goedlel> got it now
10:50:54 <dfeuer> My effort to write unfoldr using build will make more opportunities for this sort of problem.
10:51:37 <dolio> dropWhile (const True) [1..]
10:51:52 <eivuokko> Algebr, Perhaps you mean multi-parameter typeclasses.  It is possible in GHC, not in haskell 98 iirc.
10:54:21 <goedlel> is it wrong to have an erection from doing haskell?
10:54:36 <ij> Weird for sure, but not wrong.
10:54:50 <goedlel> oh
10:55:24 <dfeuer> nomeata, I don't think there is a way to fuse on the right list with the Report semantics, because I don't see any way to see foldr2 as a fold over the right list. To begin with, foldr2 k z undefined []  should be undefined.
10:55:48 <nomeata> dfeuer: I agree
10:56:00 <dfeuer> Well, that may not be a solid reason. But I don't see a way; you're better at seeing weird ways if they exist.
10:56:22 <nomeata> Not necessarily.
10:56:42 <sbrg> goedlel: don't doubt your love
10:57:12 <goedlel> i shan't
10:57:36 * hackagebot arbtt 0.8.1.2 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8.1.2 (JoachimBreitner)
10:57:38 <nomeata> But you can argue like this: a right fold will always pattern match on the list it is folded over, but "foldr2 k z xs ys" should first do something else before pattern matching ys; this doing-something-else-first is not supported by foldr
10:57:43 <nomeata> (this should be noted somewhere, e.g. in the ticket)
10:58:06 <dfeuer> nomeata, the non-confluence means that (as far as I understand matters) a perfectly safe fusion on the left is not guaranteed to be chosen over an unsafe one on the right.
10:58:33 <nomeata> dfeuer: well, we can make it safe by by changing foldr2
10:58:56 <nomeata> dfeuer: the non-confluence is a separate issue from the soundness of unfoldr/right
10:58:59 <nomeata> *foldr2/right
10:59:13 <dolio> goedlel: That was not appropriate.
10:59:52 <dfeuer> nomeata, it compounds the soundness problem, because the semantics change not only based on optimization flags, but also based on the order the rules get applied.
11:00:00 <sbrg> sounds like the appropriate reaction to me. sharing it, maybe a bit less.
11:00:16 <dfeuer> But yes, I *think* we're agreed that the soundness problem is a problem.
11:00:55 <nomeata> dfeuer: not a huge one (nobody complained so far), but yes, would be nice to have this fixed.
11:02:23 <dfeuer> OK. I think the fact that no one has complained so far probably counts as evidence that option 3 is good enough in practice.
11:02:46 <dfeuer> Even though it disturbs me slightly.
11:03:30 <dfeuer> nomeata, should I officially propose option 3 on the libraries list, or just attempt to come up with a patch?
11:03:54 <nomeata> dfeuer: it could also mean that people do rely on the lazyness, but in these cases fusion never happend, and hence noone complained
11:04:01 <nomeata> so unfortunately it is not a clear guidance on what to do
11:04:09 <dfeuer> True.
11:04:26 <nomeata> But a proposal to the library list would be a good idea nevertheless
11:05:06 <dfeuer> nomeata, should I raise it as a 1 vs. 3 thing, or just propose 3?
11:05:49 <dfeuer> Oh, I see. GRRRR
11:06:43 <dfeuer> nomeata, I am such a trouble maker. The current functions defined using build are mostly too wimpy to create a lot of these problems. My very strong desire to bring unfoldr into the mix will change that.
11:06:48 <goedlel> dolio: u jelly?
11:07:00 <nomeata> dfeuer: just propose 3 (and mention that the alternative would be to drop fusion on the right, so if people think that’s better they can still jump on that)
11:07:09 <dfeuer> OK.
11:07:13 <nomeata> you’re not a trouble maker, you are a cleaning up a mess!
11:07:16 <nomeata> It’s very appreciated
11:07:25 <dfeuer> Thanks.
11:07:26 <dolio> goedlel: Are you going to behave appropriately?
11:07:46 <goedlel> dolio: that remains to be seen
11:07:46 <nomeata> I’m not always keeping up with what you do, but nevertheless I think it is very useful
11:08:16 --- mode: ChanServ set +o dolio
11:08:23 <dolio> Is that a no?
11:08:32 <goedlel> thats an undefined
11:09:44 <goedlel> sorry if i rustled your jimmies
11:11:13 <dolio> Don't let it happen again.
11:11:37 --- mode: ChanServ set -o dolio
11:12:13 <Tuplanolla> Do you have a list of common pitfalls beginners face with Haskell? Things like indenting ifs incorrectly or treating : like a lowercase letter.
11:12:57 <goedlel> dolio: pls do not banarate me, oh powerful one
11:14:21 <pjdelport> Tuplanolla: It probably varies a lot from person to person, depending heavily on prior background.
11:18:52 <Tuplanolla> I'll be instructing a Haskell course this fall, so I'd like to know what to expect.
11:23:47 <pjdelport> Tuplanolla: Oh, might be worth asking that of a few of the regulars in #haskell-beginners then
11:24:19 <Tuplanolla> So many Haskell channels!
11:25:16 <sbrg> So, uh.. what is the best way for me to upgrade my haskell platform? Have the one with 7.6.3 currently. running linux
11:33:12 <sbrg> is it sufficient to simply replace the ghc binary? I just updated cabal, but I have a few things in .cabal/bin such as xmonad that I'd rather not be wiping completely etc..
11:43:10 <bergmark> sbrg: you can keep those
11:43:28 <sbrg> alright
11:43:32 <sbrg> i just did that anyway
11:43:45 <goedlel> How can I convert LocalTime to number of milliseconds?
11:45:09 <Fuuzetsu> haha http://hackage.haskell.org/package/exception-mailer
11:45:15 <sccrstud92> are there any classes that instantiate Arrow and Monad?
11:45:21 <Fuuzetsu> I guess that's one thing to do when you get an exception
11:46:14 <opqdonut> sccrstud92: an arrow takes two type arguments, a monad takes one
11:46:54 <sccrstud92> opqddonut: its allowed to be partially applied for the Monad instance
11:47:13 <sbrg> Fuuzetsu: I'd like it to send snail mail. Can it do that?
11:47:21 <sccrstud92> ssomething like
11:47:32 <sccrstud92> instance Arrow Type
11:47:38 <sccrstud92> instante Monad (Type a)
11:47:48 <opqdonut> sccrstud92: well (->) is an Arrow, (r->) is a Monad
11:47:50 <opqdonut> for instance
11:48:35 <sccrstud92> opqdonut: thank you
11:48:40 <opqdonut> sccrstud92: also, Arrows and Monads are related via the Kleisli arrow, as you probably know
11:48:53 <sccrstud92> opqdonut: yes
11:48:59 <opqdonut> citing the arrow docs, "any monad gives rise to a Kleisli arrow, and any instance of ArrowApply defines a monad"
11:49:49 <sccrstud92> opqdonut: i have a type that can instantiate Arrow with two arguments, and instantiate Monad on a third
11:50:03 <bergmark> and Arrow gives Applicative too
11:50:07 <sccrstud92> and im afriad that newtypes are too messy
11:50:19 <opqdonut> definitely sounds like they would be :)
11:53:28 <sccrstud92> opqdonut: pipes could implement Arrow if the type parameters were in the right place, right?
11:53:51 <sccrstud92> it could probably have a couple different instances
11:54:03 <opqdonut> I guess so yeah
11:58:08 <enferex> I need some help with some basic ByteString parsing
11:58:09 <enferex> http://lpaste.net/109946
11:59:00 <enferex> I am building a list of Foo, and have to create foos from a list of ByteStrings
11:59:03 <JohnTalent> Are there logic interface (aka prolog) type libraries for haskell?
11:59:28 <pjdelport> @hackage prolog
11:59:28 <lambdabot> http://hackage.haskell.org/package/prolog
12:00:00 <pjdelport> Well, if you search hackage for "prolog" or "logic", you'll find quite a few more.
12:00:29 <Fuuzetsu> sbrg: no idea
12:00:41 <lpvb> does ocaml have a deterministic garbage collector?
12:01:05 <lpvb> is that why it's used more in finance than haskell (my perception)
12:01:35 <Fuuzetsu> hold on here, you asked a question and then assumed you were right and drew a conclusion based on the assumption?
12:01:38 <carter> lpvb: lol, only one org in finance uses ocaml
12:01:41 <carter> and they're tiny as fuck
12:01:45 <carter> we hear about the a lot
12:01:49 <carter> but they be baby sized
12:01:56 <lpvb> Fuuzetsu: well if I get a no for the first then I know the second is wrong
12:02:05 <NikolajK> here   http://en.wikibooks.org/wiki/Haskell/do_Notation#Translating_the_bind_operator   the page says   "x1 and x2 are the results of action1 and action2. If, for instance, action1 is an IO Integer then x1 will be bound to an Integer). The stored values are passed as arguments to action3, which returns a third action.". But that's pretty wrong, isn't it!? The things happen with >>= never involve any passing of arguments of the initial typ
12:02:09 <carter> also the GC is determinsitics in most languages
12:02:15 <lpvb> carter: oh well, jane street makes a lot of fuss then
12:02:18 <carter> yes
12:02:21 <carter> they be loud to FP folks
12:02:29 <benmachine> I work for them
12:02:29 <carter> but they be tiny in finance land
12:02:36 <carter> benmachine: cool, have we met?
12:02:45 <benmachine> carter: I don't know?
12:02:49 <carter> are you in NYC?
12:02:51 <benmachine> no
12:02:54 <carter> ah
12:02:55 <carter> that'd do it
12:02:57 <carter> :)
12:03:03 <carter> london or asia office?
12:03:04 <benmachine> I was there for three weeks last year, but not since
12:03:08 <benmachine> london
12:03:10 <JohnTalent> yes quite alot of estoteric haskell packages without documentation.
12:03:11 <carter> cool
12:03:11 <lpvb> carter: so haskell's garbage collector aint a problem for them high speed tradings?
12:03:26 <pjdelport> NikolajK: "The *bound* values are passed as arguments ..." might be a better description.
12:03:28 <carter> lpvb: haskells GC is just fine
12:03:39 <carter> lpvb: the trick to latency based things is just don't allocate much
12:03:40 <hpc> NikolajK: your question got cut off at "of the initial typ"
12:03:52 <carter> or use a "hard real time incremental collector"
12:03:58 <NikolajK> e Int, it only involves things being done with terms of m Int etc.
12:04:04 <carter> lpvb: BUT, real time GC costs you througput
12:04:06 <benmachine> anyway I get the impression that JS is louder about ocaml because the ocaml community is actually *smaller* so we have to make more of an effort to get hires
12:04:19 <carter> benmachine: yeah, something like that :)
12:04:28 <NikolajK> which are the bound value
12:04:39 <NikolajK> in "action1 >>= \ x1 -> action2 >>= \ x2 -> action3 x1 x2", say
12:04:40 <Fuuzetsu> I'll learn OCaml for money
12:06:22 <NikolajK> no actual term gets ever subsituted for x1 or x2, the expression "\x->bar x" after a >>= is only ever used to apply the functor to it an make a map between lifted types out of it
12:06:34 <sccrstud92> is there a way to find haskell companies in an area?
12:07:09 <goedlel> How do I convert from NominalDiffTime to Double or Int ?
12:07:41 <lpvb> my city hasnt had a meeting for 4 years
12:07:49 <lpvb> user group meeting
12:08:11 <lpvb> any active haskell user groups in the south east US?
12:08:19 <benmachine> sccrstud92: there's this http://www.haskellers.com/jobs
12:08:56 <benmachine> actually that might not be too up-to-date, not sure
12:08:59 <pjdelport> NikolajK: x1 and x2 will eventually be bound to relevant values.
12:09:52 <sccrstud92> benmachine: last listing was on July 31
12:09:57 <sccrstud92> looks fairly up to date
12:10:02 <sccrstud92> just not a lot of jobs
12:10:05 <sccrstud92> listed
12:12:00 <NikolajK> pjdelport: I'm confused, because I don't think so. If we have mx >>= \x->(foo x), then what happens is that the function  \x->(foo x) gets modified via the monads fmap, then join is applied to the result and this is evaluated at mx. After fmap has been applied, there is no more x to be substitured with a term of the initial type, Int, say.
12:12:32 <goedlel> is using Rational slow compared to Double?
12:12:39 <NikolajK> so x is never bind to anything
12:12:45 <NikolajK> bound
12:12:56 <sccrstud92> goedlel: defininately uses more memory
12:13:03 <sccrstud92> definitely*
12:13:04 <ion> goedlel: They are not comparable in that fashion, they exist for different purposes and have very different semantics.
12:13:10 <NikolajK> goedlel: nice name
12:13:18 <goedlel> ha
12:13:32 <Twey> goedlel: Yeah, unfortunately CPUs have hardware support for IEEE floats (which Double is), but generally not for rationals
12:13:47 <goedlel> Im using NominalDiffTime which is an instance of a bunch of typeclasses
12:13:54 <goedlel> im wondering if it will be slow
12:14:29 <goedlel> Fractional, Real, RealFrac
12:14:36 <goedlel> :S
12:14:44 <Twey> goedlel: That's totally different
12:15:11 <goedlel> Twey: will it only use one of the types if I convert it?
12:15:31 <Twey> goedlel: A type being an instance of a typeclass doesn't slow anything down (unless you use the typeclass, in which case there's a small runtime indirection penalty over using a monomorphic function, unless the typeclass has been specialized for that type)
12:15:37 <Twey> goedlel: Typeclasses aren't types
12:15:49 <goedlel> okay
12:16:07 <Twey> goedlel: Having a type be an instance of a typeclass doesn't slow anything down, any more than writing a function on a type makes that type slower to use anywhere else
12:16:21 <goedlel> ah
12:16:58 <goedlel> Twey: but doesn't it hint that it could be slow?
12:17:26 <goedlel> if it's an instance of Fractional for example, could it not be storing its data like a Fractional and not like a Double?
12:17:47 <sccrstud92> when is it okay to put a type constraint in a data type declaration?
12:18:00 <Twey> goedlel: Well… Double is a Fractional
12:18:07 <sccrstud92> ive heard that is generally best practice
12:18:11 <sccrstud92> to avoid
12:18:17 <benmachine> sccrstud92: it's basically not useful
12:18:45 <sccrstud92> benmachine: so if I include it I will still have to include the constraint in all the functions that use it?
12:18:48 <Twey> goedlel: NominalDiffTime is a Rational inside, which *is* probably going to be a bit slower than a Double in some cases.  But that has absolutely nothing to do with how many typeclass instances it has.
12:18:51 <benmachine> sccrstud92: yes
12:19:00 <sccrstud92> benmachine: blegh
12:19:03 <goedlel> ah ok Twey
12:19:07 <sccrstud92> any way to avoid having to do that?
12:19:24 <Twey> goedlel: Rational is a *type*, i.e. it affects the runtime representation of the value.  Fractional is a *typeclass*, which just means there are certain functions defined on the type.
12:19:50 <sccrstud92> benmachine: typing Monad m => for every function is tedious
12:20:01 <sccrstud92> and it seems like there should be a way to not have to that
12:20:03 <benmachine> sccrstud92: mostly my answer is "get over it, it's not that bad" :P
12:20:05 <goedlel> Twey: wouldnt Rational be much slower because it seems to compute a pair of integerts that represent the rational?
12:20:13 <benmachine> there might be a way to do something about it
12:20:13 <sccrstud92> benmachine: i can accept that lol
12:20:17 <Twey> goedlel: Saying that being Fractional makes NominalDiffTime slower is like saying that having powf() defined makes C's float slower
12:20:26 <benmachine> you can make datatypes that package type class instances inside them
12:20:32 <goedlel> Twey: yeah i get it now
12:20:37 <sccrstud92> how do i do that?
12:20:41 <Twey> goedlel: It's *somewhat* slower.  Not necessarily *much* slower, depending on what you're doing.
12:20:57 <benmachine> sccrstud92: using GADTs, I think, although I can't remember exactly how/if it works, give me a sc
12:21:08 <sccrstud92> ill read a link if you got it
12:21:11 <goedlel> Twey: I'm parsing a bunch of date/times from strings and converting them to milliseconds
12:21:12 <Twey> goedlel: In fact, it might not be slower at all: if an Integer is small then it'll be stored as an Int, and you have hardware support for Int.
12:22:09 <Twey> So if you're just manipulating one of the Integers, it might be the same speed as normal manipulation of an Int, plus a pointer lookup.  If you're manipulating two (and your operation doesn't get optimized away!) then it's going to require at least twice as many instructions, obviously.
12:22:35 <goedlel> Twey: wouldnt creating the Rational in the first place be slow?
12:22:38 <Twey> goedlel: But really, you shouldn't be thinking about these things.  If it turns out to be a bottleneck later on, revisit it.  But I very much doubt this is going to be the bottleneck in your application.
12:23:00 <Twey> goedlel: Why?  It's just a pair of ints.
12:23:08 <Twey> You mean for the GCD?
12:23:15 <goedlel> yeah
12:23:17 <pjdelport> NikolajK: x definitely gets bound to something (to when and what depends on the functor/monad in question)
12:24:00 <NikolajK> pjdelport: that contradicts what I said, though
12:24:04 <Twey> goedlel: Well, it gives you… what is it, log n or something?
12:24:05 <NikolajK> so where is the error
12:24:10 <Twey> For a small n.
12:24:14 <pjdelport> NikolajK: I'm not really sure what you're trying to say. :)
12:24:26 <lpaste> benmachine pasted “GADT” at http://lpaste.net/109947
12:24:30 <Twey> pjdelport: Well, it might not.
12:24:35 <benmachine> sccrstud92: take a look
12:24:39 <Twey> :i Const
12:24:44 <NikolajK> I explained how I think "mx >>=(\x->(foo x))" works
12:24:47 <Twey> :t Const
12:24:49 <lambdabot> a -> Const a b
12:24:54 <goedlel> Twey: this piece of code is just parsing millions of times converting them to milliseconds and sending them further, so this might be a bottleneck
12:25:06 <NikolajK> and from my understanding, x gets lost once the fmap hidden in >>= gets applied to \x->(foo x)
12:25:09 <benmachine> sccrstud92: I tend to think of GADTs as being excessively heavyweight for a problem like this, but if you're really keen, maybe you can try it out
12:25:10 <Twey> > fmap (+ 2) (Const 3)
12:25:12 <lambdabot>  No instance for (GHC.Show.Show (Control.Applicative.Const a0 b0))
12:25:12 <lambdabot>    arising from a use of ‘M536478620351274011015138.show_M5364786203512740110...
12:25:12 <lambdabot>  The type variable ‘a0’ is ambiguous
12:25:12 <lambdabot>  Note: there are several potential instances:
12:25:12 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
12:25:18 <NikolajK> \x->(foo x) becomes something of the form \mx->(foo2 mx)
12:25:34 <Twey> > getConst $ fmap (+ 2) (Const 3)
12:25:36 <lambdabot>  3
12:25:40 <zereraz> ok I have a question, why is haskell called purely functional when it has IO and such stuff that are not pure? is it partially pure or are IO and file systems pure somehow? I am quite new to these terms.
12:25:40 <Twey> There it's never bound
12:26:03 <sccrstud92> benmachine: i dont mind at least learning how it would work. particurlay since I might switch to using GADTs regardless
12:26:43 <Twey> NikolajK: That might be the case, but if so ‘foo2’ includes the original ‘foo’.
12:26:44 <opqdonut> zereraz: haskell uses an abstraction called "monads" to talk about IO purely
12:27:03 <zereraz> opqdonut: but inside monad they are not pure right
12:27:26 <opqdonut> sure, side effects do happen
12:27:28 <benmachine> haskell doesn't really need to use monads to talk about IO
12:27:28 <Twey> zereraz: Haskell itself is a pure language.  We have EDSLs for writing impure code, but that doesn't change the purity of the language used to write them.
12:27:39 <opqdonut> benmachine: it doesn't, no
12:27:42 <NikolajK> Twey: foo2 is (join.fmap) foo or something similar. This has not to do with x::Int being bound or not though
12:27:53 <zereraz> benmachine: how?
12:28:14 <pjdelport> NikolajK: I'm not sure what you mean by "lost"
12:28:16 <benmachine> zereraz: well, the important part is that you have a type IO a, and you can attach callbacks (a -> IO b) to get an IO b
12:28:17 <zereraz> so how do you call it pure when it uses something that uses something that is not pure?
12:28:29 <Twey> zereraz: You can imagine a Haskell program as a pure function that returns a string, which string is then compiled as a C program, for example.  The resulting program might do impure things, but the language used to generate it is pure.
12:28:53 <goedlel> How do I convert a rational to an int (assuming the rational is a whole number)
12:28:57 <zereraz> Twey: interesting
12:28:59 <Twey> (of course, the mechanism is rather nicer than writing strings, but the principle is the same)
12:29:04 <benmachine> zereraz: it turns out that gives you a monad, and you can treat monads uniformly and that's all really cool, but it sort of works even if you don't have a Monad typeclass
12:29:10 <NikolajK> pjdelport: Unless m is the identity monad, not any term of the type of x gets bound to, in evaluating mx>>=\x->foo x
12:29:14 <pjdelport> NikolajK: fmap doesn't really change anything: if you say join (fmap (\x -> putStrLn x) getLine) then x will *still* be bound to the result of getLine.
12:29:28 <Twey> goedlel: floor
12:29:30 <pjdelport> NikolajK: For example, if you say "getLine >>= \x -> putStrLn x", then x will be bound to the result of the getLine action, after it finishes executing.
12:29:30 <pjdelport> NikolajK: In the case of IO, that happens inside the run-time system somewhere.
12:29:44 <zereraz> so until I understand monads I should accept that is pure, like its really pure
12:29:57 <goedlel> thanks Twey
12:30:00 <pjdelport> ugh, IRCCloud; those last two messages of mine got delivered out of order
12:30:02 <zereraz> I thought we call it pure because its almost pure
12:30:09 <NikolajK> pjdelport: "then x will *still* be bound to the result of getLine." I don't think so
12:30:18 <zereraz> but the language is pure
12:30:21 <zereraz> right?
12:30:21 <pjdelport> NikolajK: Well, that's what happens. :)
12:30:30 <NikolajK> if you apply fmap to it, then the new function has an input type different from that of x
12:30:39 <benmachine> I think what people mean when they say "Haskell is pure" is that "evaluation of Haskell expressions does not have side effects"
12:30:55 <Twey> NikolajK: Right, foo2 is  (join . fmap) foo  or something similar, which is join (fmap foo).  And (fmap foo) is a function that knows how to ‘unwrap’ the value passed in, apply the ‘foo’ function (thereby binding your x), and wrap it back up.
12:31:00 <benmachine> however, not all of programming in Haskell is evaluating expressions
12:31:22 <goedlel> I think it means that the unpure code is made explicit, so you can cleanly separate the pure and unpure, I don't think haskell is actually pure overall.
12:31:37 <benmachine> using Haskell requires understanding both the pure evaluation of expressions and the impure execution of IO
12:31:38 <zereraz> ok that makes sense
12:31:43 <NikolajK> Twey: ‘unwraping’ is the handwavy wrong explanation
12:31:50 <pjdelport> NikolajK: It doesn't: fmap just applies the function "inside of" the functor's context. In the case of IO, that means arranging for it to be applied to the result of the IO action in question (getLine, in the above example)
12:31:53 <benmachine> but it's really useful that you can separate pure code from impure code
12:31:54 <NikolajK> 'Nothing' never gets unwraped, for example
12:31:55 <zereraz> you can explicitly see the unpure part
12:32:03 <benmachine> yeah
12:32:05 <athan> benmachine: I tend to think "the results of expressions are unambiguous and compositional"
12:32:10 <zereraz> and is it a big deal
12:32:12 <zereraz> being pure?
12:32:20 <Twey> NikolajK: The interesting point is just in the definition of unwrap/apply/wrap, which depends on the particular monad/functor; there *are* indeed a few cases that will never call the function and thus never bind the variable, such as Const
12:32:23 <benmachine> athan: do you think of side-effects as ambiguous, or what?
12:32:32 <pjdelport> NikolajK: When the IO action gets executed by the RTS, then its result is bound to x, and evaluation continues.
12:32:39 <zereraz> what if there are softwares that highlight global variables and possible side effects
12:32:47 <Twey> NikolajK: But in almost all cases, the function will eventually get called with some value of the appropriate type
12:32:51 <barrucadu> zereraz: It makes reasoning about code easier, as you can substitute things by equality
12:32:53 <goedlel> zereraz: I think if something was 100% pure it wouldnt be able to communicate with the outside world
12:33:00 <pjdelport> NikolajK: Nothing changes type anywhere.
12:33:04 <barrucadu> If haskell were not pure, then you couldn't do that (no referential transparency)
12:33:14 <athan> benmachine: If they're done in the normal imperative sense, then yeah I can see functions that inject side effects as being ambiguous to their purpose
12:33:17 <zereraz> goedlel: yeah but what about mathematics, its functions are pure
12:33:39 <goedlel> yeah, but they cant actually 'do' anything
12:33:43 <benmachine> athan: hmm, not sure I agree
12:33:48 <NikolajK> I don't know. I think I've spelled out an accurate description what happens and there no value of the type of x is ever involved… well whatever
12:33:48 <goedlel> its the mathematician thats actually doing something
12:33:58 <Twey> NikolajK: The unwrap/wrap part is handwavy and rubbish, but the application part is for real.  ;)
12:34:05 <zereraz> goedlel: that is very interesting
12:34:18 <benmachine> athan: the way I see it, side-effecting functions are like "return this value, and also do this other thing", and those other things stack up in a clearly-defined manner
12:34:33 <zereraz> goedlel: so mathematicians by applying it make use of unpure parts
12:34:37 <Tuplanolla> Consider a function with the type Universe -> Effects -> Universe, goedlel.
12:35:00 <benmachine> I think one of the major reasons that Haskell is pure is because you can't really be lazy unless you are pure
12:35:08 <benmachine> impure + lazy = pain
12:35:23 <zereraz> benmachine: can you explain
12:35:26 <athan> benmachine: I agree! That's a good perspective to have for composable side effects
12:35:27 <goedlel> Tuplanolla: yeah thats theoretically plausible, but not doable because you cant depend on the state of the Universe
12:35:45 <Twey> NikolajK: There's no magic function-rewriting going on here.  The *only* thing you can do with a function a → b is apply it to a function a.  The functor can choose to ignore the function, as with Const, but if it does anything with the function at all, it calls it with a value of type a (possibly more than once).
12:35:59 <benmachine> zereraz: purity allows you to not care what order things are evaluated in, which lets you choose not to evaluate some of them at all
12:36:03 <Twey> apply it to a value of type a**
12:36:28 <goedlel> Tuplanolla: because the universe typically exists outside of the program
12:36:36 <zereraz> benmachine: I kind of understand, but I think I can now move on from this topic and come back after reading about monads
12:36:41 <zereraz> thanks allot everyone
12:36:43 <benmachine> zereraz: side-effects can be different depending on what order they occur in, but in a pure function all that matters is the return value, and that will always be the same
12:37:02 <Tuplanolla> Concurrency ruins it, but that's what the IO monad tries to represent.
12:37:32 <NikolajK> Twey: no, if you have a function f::a->b, you can do something else than apply a term of x::a to it. Namely pass f to fmap, resulting in (fmap f):m a->m b and pass that to an mx::m a. No x::a gets every used
12:37:40 <zereraz> benmachine: ok
12:38:15 <NikolajK> and that's what happens in mx>>=\x->return (f x)
12:38:30 <barrucadu> NikolajK: fmap isn't magic, it knows how to "unwrap" (imprecise and hand-wavy as that term may be) the m x into an x
12:38:59 <NikolajK> barrucadu: … mhm
12:39:17 <NikolajK> 'Nothing' of type Maybe Int can't get unwraped to an Int
12:39:31 <benmachine> NikolajK: think of fmap for lists. it takes a function f and produces a function which applies f to every element of the list
12:39:32 <NikolajK> not all functors are "containers"
12:39:33 <zwer> @src fmap Maybe
12:39:34 <lambdabot> Source not found. That's something I cannot allow to happen.
12:39:49 <benmachine> i.e. you apply f to elements of type a
12:39:54 <benmachine> that's how fmap works
12:40:01 <Twey> NikolajK: But what you get back when you pass it to fmap is a ‘wrapped’ function (in a more real sense this time, i.e. a function that either calls your function there and then or stores it away somehow to be called later, doing things to the input and output on either side)
12:40:13 <benmachine> with Maybe, you apply f to the element of type a, if there is one, and return Nothing otherwise
12:40:25 <Twey> NikolajK: You might find this easier to grasp if you look at the actual source of some functors
12:40:35 <Twey> @src (->) fmap
12:40:36 <lambdabot> fmap = (.)
12:40:41 <benmachine> what fmap f does is it applies f to all the elements of type a in your structure to turn them into b's
12:40:50 <Twey> @src (.)
12:40:50 <lambdabot> (f . g) x = f (g x)
12:40:57 <benmachine> for some suitably loose definition of "elements in your structure"
12:41:06 <Twey> fmap f g = f . g = \x -> f (g x)
12:41:10 <NikolajK> benmachine: for Just values, this is what happens. But only for them
12:42:01 <Twey> Here ‘unwrap’ means ‘apply to x’, and ‘wrap’ means ‘embed in a lambda’
12:42:16 <benmachine> I think we're talking at cross-purposes here a bit
12:42:26 <Twey> But as usual the function is always applied to *some* value, in this case (g x)
12:42:28 <benmachine> like, the two of you seem to be disagreeing, but mostly neither of you say anything actually wrong
12:43:00 <Twey> benmachine: No, NikolajK is just taking fmap as a primitive operation on functions
12:43:08 <benmachine> NikolajK: fmap f Nothing applies f to all the values of type a in Nothing :)
12:43:23 <NikolajK> I understand that in many cases, Haskell does a matching and uses ways to work with the "x" when given a "MyMonad x". But that doesn't proof that "x in \x->.." gets bound evantually".
12:43:39 <benmachine> what do we mean by bound, anyway
12:44:32 <NikolajK> at the very least, that any term of the type of x is used in computations
12:44:35 <Twey> NikolajK: There's no such proof, because it doesn't always get bound (e.g. fmap f Nothing, or Const)
12:44:47 <benmachine> oh, sure it is
12:45:00 <NikolajK> in some cases, like with Just 3
12:45:35 <Twey> NikolajK: But in the cases where it's not used, it's just never called.  If it is used, then it is called, because that's the only thing you can do with functions (fmap is not a special case here: it's just another function implemented in terms of applying the function you give it to some input)
12:45:45 <benmachine> the thing that's puzzling me is that I think of "bound in" as a syntactic condition, like, some variable is bound within some piece of code
12:46:24 <benmachine> whereas you people seem to be thinking of "bound in" as "set to some value during an actual run of the program"
12:47:09 <benmachine> this much is true: if you write getLine >>= \x -> putStrLn x, then (\x -> putStrLn x) will be called with a String argument
12:47:45 <Twey> benmachine: I'm pretty sure ‘x gets bound to y’ is common usage
12:47:48 * hackagebot HTTP 4000.2.16.1 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.16.1 (GaneshSittampalam)
12:49:13 <benmachine> Twey: yeah, maybe, but if we're having long and confused discussions about it I tend to get more pedantic :P
12:49:22 <benmachine> Twey: usually I can work out what you mean, but sometimes I need precision
12:49:26 <NikolajK> benmachine: I usually also used x is bound in the sense of "\int f(x)dx" or "\forall x. P(x)", but here we used it more in a "pointer for a variable" kind of way
12:49:29 * Twey scratches his head.
12:49:48 <goedlel> whats a good HTTP REST client library?
12:49:57 <Twey> benmachine: I mean, it's precisely-defined terminology :þ  ‘Is bound in’ and ‘gets bound to’ are different concepts, is all.
12:50:22 <goedlel> or just a good HTTP client library
12:50:47 <Twey> goedlel: ‘rest’ is pretty nice
12:50:48 <benmachine> Twey: ok, fair enough
12:50:54 <goedlel> ok ill try  that
12:50:55 <NikolajK> I think you guys are right for all the examples we did, in particular the wiki claim which started my question, so I concede
12:50:55 <benmachine> Twey: pedantry revoked :P
12:51:24 <NikolajK> to put a total order on two rights
12:51:29 <Twey> Oh, client, sorry
12:51:47 <goedlel> Twey: I found wreq, it seems nice
12:52:03 <Twey> goedlel: Ah, here: http://hackage.haskell.org/package/rest-gen
12:52:10 <Twey> Yes, I've heard good things about wreq
12:52:12 <NikolajK> @src const
12:52:13 <lambdabot> const x _ = x
12:52:48 <goedlel> ok ill go with wreq
12:52:51 <NikolajK> @pl const x _ = x
12:52:51 <lambdabot> const = const
12:52:55 <NikolajK> lol
12:53:18 <Twey> Ha
12:53:36 <NikolajK> \x->x _ = x
12:54:17 <NikolajK> i want to know if const y is \_->y, literally
12:54:36 <Haskellfant> @src const
12:54:37 <lambdabot> const x _ = x
12:54:39 <barrucadu> It is
12:54:41 <Twey> NikolajK: Pretty sure it is
12:55:11 <benmachine> well, what else would it be?
12:55:12 <Twey> For whatever definition of ‘literally’ you choose :þ
12:56:09 <NikolajK> Twey: yeah I was thinking that too
12:56:26 <NikolajK> homotopy equivalent, as in HoTT
12:56:56 <benmachine> I believe HoTT has extensionality, so you're fine
12:56:56 <NikolajK> (which means extensionally equal, I think)
12:57:22 <benmachine> I think only types can be homotopy equivalent, not values
12:57:28 <Twey> Yeah, that doesn't make much sense
12:57:39 <benmachine> but that's just drawing from my knowledge of topology, not HoTT directly
12:57:44 <Twey> They're extensionally equal and probably also intensionally, depending on what respective optimizations the compiler decides to apply
12:58:23 <NikolajK> functions are functors in HoTT, so I think homotopy equivalent (=naturally isomorphic) is right
12:58:45 <benmachine> functions are functors? in what sense?
12:58:54 <benmachine> I thought they were... functions
12:59:31 <ciaranm> they're pointy functors!
12:59:38 * Heffalump wonders if anyone can explain the point of HoTT. It seems neat, but I haven't quite understood what it's useful for yet.
12:59:59 <NikolajK> in the sense that HoTT is about extending the identity types of Martin Löfs theory. And these x=y, then a function is applied to them, becomes f(x)=f(y) - this mirrors Hom(x,y) to Hom(fx,fy).
13:00:11 <ciaranm> one nice thing you can do is say whether or not two proofs are "the same"
13:00:13 <Fuuzetsu> is there really no general library for tries up on hackage?
13:00:30 <benmachine> Heffalump: aiui one of the things that's appealing about HoTT is it allows you to use isomorphisms like equalities, which is basically what all mathematicians do anyway
13:00:38 <vramana> I having some trouble with cabal on ubuntu can somebody help me?
13:01:04 <benmachine> Heffalump: so it's a logical foundations that is tractable and usable and reflects common practice, which are three things that set-theoretic foundations basically aren't
13:01:11 <NikolajK> parts in the identity types move equalities "f(x)=f(y)" around and so the natrual transformations are homotopy transformations. I think that's where the name comes from
13:01:28 <dcoutts_> vramana: the trick is not to ask if you can ask a question, but to ask your question. You'll not get volunteers for an unknown question.
13:01:54 <Twey> Heffalump: As a mathematical foundation or as a programming language?
13:02:12 <Heffalump> Twey: either.
13:02:25 <NikolajK> Heffalump: funding?
13:02:34 <Heffalump> NikolajK: :-)
13:03:12 <NikolajK> it's extremely hyped - the argument "make proofs published by mathematicans checkable by computer" seems like a project with a goal far too far away
13:03:25 <vanila> isn't HOTT vaporware though
13:03:43 <benmachine> geez, you guys, this is mathematics, it's ok for your revolutions to take a couple of generations
13:03:53 <NikolajK> it is connected to higher cateogry theory, which was popular with people already some years ago, and so it was "easy to hype". I guess
13:04:18 <vanila> how is it different from extentional type theory?
13:04:24 <c_wraith> vanila: no, actually.  the HOTT book was released.
13:04:30 <Heffalump> ok, perhaps I could ask the same question about (a) category theory and (b) Martin-Lof type theory, by way of comparison (as I can roughly see how those are considered useful to the world)
13:04:38 <Twey> Heffalump: Well, as a mathematical foundation it gives you a simple foundation that a) gives you a precise notion of ‘equivalence’ for proofs, b) is based on types and relations rather than intensional structure, and c) extends neatly to structures that sets don't have a pretty set-theoretic representation, like homotopy spaces
13:04:47 * Twey probably missed some
13:04:51 <NikolajK> vanila: that question is ill guided, as it is an extentional type theory
13:05:08 <NikolajK> what's new is a richer theory of proofs for identity
13:05:31 <vanila> what's wrong with the K axiom?
13:05:32 <NikolajK> not just Löfs inductive definition, but also this univalence thingy.
13:05:49 <companion_cube> is Hott really necessary for formalizing most mathematics, though?
13:06:05 <Twey> Heffalump: As a programming language it gives you a way of talking about different ways types can be ‘the same’.  For example, it's nice to be able to have structures like multisets in types and be able to compare two terms of ‘the same’ type, even if the multisets in their types are not structurally the same (unbalanced, for example)
13:06:05 <companion_cube> coq should already be enough for most uses (ignoring usability issues)
13:06:22 <vanila> Coq isn't really useful though, because it lacks proper dependent pattern matching
13:06:49 <NikolajK> companion_cube: not for proof-irrelevant ZFC math, that's for sure
13:07:07 <companion_cube> vanila: how so?
13:07:16 <Twey> companion_cube: It's not *necessary* at all.  But it will probably make it rather nicer.
13:07:20 <companion_cube> coq does have dependent pattern matching afaik
13:07:28 <companion_cube> Twey: how? more isomorphisms?
13:07:36 <vanila> companion_cube, you can't prove that equality proofs are equal for example
13:07:48 <companion_cube> ah
13:08:08 <companion_cube> but I think reflection (ssreflect especially) makes it quite easy to use boolean equality proofs instead
13:08:20 <Twey> companion_cube: HoTT gives you more ways of saying that proofs are equivalent.  So you can generalize proofs/programs over more types
13:08:23 <{AS}_> vanila: Is that because they dependend on Axiom K?
13:08:23 <companion_cube> pretty big theorems have been proved in coq
13:08:30 <vanila> yeah {AS}
13:09:17 <Twey> (s/that sets don't have/that don't have/ previously)
13:09:44 <companion_cube> for a proof assistant based on Hott to be mature enough, I fear years will be needed
13:09:56 <NikolajK> I've wondered several times if only the internet makes me thing that HoTT got really big, really fast - might be that it's just those poeple who are online who speak about it, but it's not so in the academic math/CS world, of which I'm removed
13:10:07 <Twey> Heffalump: But of course the foundation arguments also apply to it as a programming language, once you get to the point where you're proving non-trivial theorems about your code
13:10:13 <vanila> I don't understand why people are so hyped about HoTT (I have a good guess) but why is it any better than coq with proper dependent type pattern matching?
13:10:31 <ciaranm> why is "proper dependent type pattern matching" important?
13:10:57 <vanila> ciaranm, it's useful for writing programs and proofs about dependently typed data structures
13:11:16 <ciaranm> vanila: but why is that your one killer feature? what's so special about that, as opposed to anything else?
13:11:22 <NikolajK> vanila: For me, somebody would have to show me non-higher category theory that gets cleared up with it - and not n-Sphere bla only homotopy people care about
13:11:23 <{AS}_> vanila: The Univalence Axiom is definitely useful
13:11:26 <vanila> ciaranm, beacuse it's the only thing missing
13:11:27 <Twey> NikolajK: It got big within the formal methods community pretty fast, because a lot of big names got behind it and it turned out to be useful to connect a whole bunch of different areas that are already popular for study (proofs, types, categories, homotopy spaces)
13:11:31 <Zemus> anyone here use the EclipseFP plugin to code Haskell in Eclipse IDE? Trying to figure out how to force it to build the EXE for distribution.
13:12:32 <vanila> NikolajK, sorry I don't understand what you mean
13:12:38 <{AS}_> Some ITT things can become a bit elaborate sometimes (*requiring* explicit pattern matching)
13:12:52 <companion_cube> I don't think dependent programs are that useful for formalizing mathematics
13:13:08 <companion_cube> they won't use Curry Howard everywhere
13:13:14 <ciaranm> formalising isn't the important bit. verifying is.
13:13:18 <companion_cube> look at the Odd Order theorem's formalization
13:13:49 <vramana> I installed latest haskell platform. I ran cabal install cabal-install It installs cabal-install 1.20.0.3  But shows this warning Warning: The directory /home/vramana/.cabal/bin is not in the system search path.
13:13:50 <Twey> ciaranm: ‘As opposed to anything else’ — HoTT is really only two additions to the standard dependent MLTT: higher inductive types (spaces/types with axiomatically associated paths/equivalences) and the univalence axiom (which lets you treat those equivalences as identities, up to the same equivalence, giving them computational content)
13:14:05 <NikolajK> vanila: I like HoTT for the geometric interpretation and because I read about it while learning type theory. But the thing which HoTT has which is different from Martin Löf ITT, and that I find interesting, ends with the geometric interpretation.
13:14:54 <vramana> I added export PATH:~/.cabal/bin:$PATH to my .bashrc But it doesn't solve the problem.
13:15:01 <vanila> fair enough, HoTTs geometric interpretation is certainly fun and neat but I don't see how it going to help me write programs better
13:15:02 <ciaranm> when HoTT really takes off the geometric interpretation will be forgotten and will be seen as some quaint old thing with confusing terminology
13:15:19 <Twey> vramana: Can you run cabal-installed programs?
13:15:31 <{AS}_> HoTT is often seen as possible replacement of OTT
13:15:37 <goedlel> If im using readFile to lazily read a file, how can I consume X number of lines from the file at a time until the whole file is read?
13:15:39 <vanila> Can no one tell me about any real benefits of HoTT?
13:15:50 <Heffalump> vramana: do you mean 'PATH=...' rather than 'PATH:...' ?
13:15:58 <{AS}_> vanila: It makes it possible to use equivalences as equalities
13:15:59 <Twey> vanila: See above
13:16:01 <vanila> {AS}_, why does OTT need replaced? the only problem I know is that they never finished implementing it
13:16:11 <vramana> Twey: Nope.
13:16:20 <{AS}_> vanila: Sorry, I meant alternative
13:16:21 <vramana> Heffalump: PATH=
13:16:34 <{AS}_> OTT is useful in it self :)
13:16:38 <Heffalump> vramana: does echo $PATH show the directory now?
13:16:39 <Twey> vanila: I think OTT turned out to be a truncated version of HoTT
13:16:43 <vanila> I feel like there is too much misguided hype around HoTT
13:17:00 <jonsterling> Twey: Yep!
13:17:06 <goedlel> what does OTT stand for?
13:17:13 <vanila> goedlel, Observational type theory
13:17:14 <{AS}_> vanila: Did you read Licatas paper on Homotopy Patch Theory
13:17:14 <jonsterling> OTT is what happens when you want to make an intensional theory of hsets
13:17:17 <goedlel> ah ok
13:17:26 <vramana> Heffalump: Yeah
13:17:45 <{AS}_> It has a nice practical application of HoTT
13:18:01 <{AS}_> vanila: http://dlicata.web.wesleyan.edu/pubs/amlh14patch/amlh14patch.pdf
13:18:09 <vanila> thanks {AS}_ this might answer some of my questions
13:18:33 <Twey> vanila: http://www.cs.nott.ac.uk/~txa/talks/lyon14.pdf is a nice application, too.
13:18:34 <Heffalump> I read the paper but didn't really understand what was being added by the use of HoTT
13:18:46 <vanila> thanks Twey
13:18:57 <NikolajK> what is OTT
13:19:00 <vramana> Heffalump: http://pastebin.com/GbGtRwDb This is the log
13:19:04 <ciaranm> NikolajK: Over The Top
13:19:08 <NikolajK> ah
13:19:11 <Heffalump> what does it tell us about patches that we wouldn't know otherwise (or would only know with more complications)
13:19:20 <benmachine> or alternatively, observational type theory
13:19:21 <Twey> NikolajK: ‘Observational Type Theory’, a means of adding extensionality to intensional type theory
13:19:22 <Heffalump> s/complications/work/
13:19:23 <{AS}_> NikolajK: Observational Type THeory
13:19:35 <vanila> NikolajK, they showed a way to add quotient types to intentional type theory as well as handling equality proofs better
13:19:41 <{AS}_> It is ITT with coercisions of equality
13:19:42 <Heffalump> vramana: oh, you're install it with sudo
13:19:47 <Heffalump> so it doesn't see the same PATH as you do
13:19:55 <goedlel> how can i 'take' from a list until I have took all elements?
13:19:56 <jonsterling> Well, ITT has coercions for equality; OTT just has a more extensional equality
13:20:10 <Heffalump> what does 'which cabal' say?
13:20:17 <benmachine> hey, since there are people asking about haskell problems in here, it might be wise to take the type theory stuff to #haskell-blah or something
13:20:22 <vanila> yeah OTT is "more" extentional but type-checking is still decidable
13:20:28 <Twey> Or ##hott — that's a thing
13:20:37 <vramana> Heffalump: /home/vramana/.cabal/bin/cabal
13:20:48 <NikolajK> is intensional type theory in any way about complexity? That's the foremost integional property of function code I can think of
13:20:50 <benmachine> Twey: does it ever get people who do not realise that it's an acronym
13:20:53 <jonsterling> vanila: Yeah! The kind of extensionality in play here doesn't affect decidability typechecking
13:20:54 <{AS}_> I always wanted to try full ETT with NuPRL, unfortunately they don't have a public release
13:21:11 <Twey> benmachine: Not yet :þ
13:21:20 <jonsterling> {AS}_: Yes! I'm in the process of getting access to their cloud system, but they're dragging their feet...
13:21:26 <Twey> NikolajK: No
13:21:33 <jonsterling> {AS}_: I do have an installation of MetaPRL though which gives a pretty good idea of how it goes
13:21:40 <Heffalump> vramana: then just ignore that error. But using sudo to 'cabal install' things is probably a mistake in general.
13:21:52 <goedlel> Can I somehow fold over a list X elements at a time?
13:21:52 <{AS}_> jonsterling: Isn't MetaPRL a bit outdated though? Maybe I should try anyway
13:21:54 <Heffalump> you may want to use cabal install --user instead
13:22:10 <Twey> :t chunksOf
13:22:12 <lambdabot> Int -> [e] -> [[e]]
13:22:24 <Twey> goedlel: Data.List.Split.chunksOf ?
13:22:32 <Twey> (or chunks, I can never remember which one is deprecated)
13:22:42 <jonsterling> {AS}_: It's a little out of date, but it does include most of the type theoretical innovations present in modern Nuprl... (PER types, etc.)
13:22:42 <Heffalump> isn't type theory on topic?
13:22:55 <Zemus> so no? no one uses EclipseFP plugin?
13:23:05 <Heffalump> I don't mind moving to haskell-blah but I wouldn't have thought it necessary
13:23:06 <goedlel> ah thanks Twey that looks like what I need
13:23:10 <vramana> Heffalump: I always get Permission denied errors So I used sudo when installing.
13:23:29 <Heffalump> vramana: right, hence --user to put packages in the user database in your home directory rather than overwriting the system one
13:23:33 <benmachine> vramana: a better way to do things is to set root-cmd: sudo in your cabal config
13:23:37 <Heffalump> it's better to leave dpkg to manage the system one
13:23:44 <benmachine> or, yeah, just use the user package db
13:23:49 <benmachine> (that's what I do)
13:23:49 <{AS}_> jonsterling: Ah, cool
13:24:07 <Twey> jonsterling: Wait, NuPRL is not publicly available?
13:25:38 <jonsterling> Twey: If you know where to look, you can find an archive of it, but it's not really installable as is
13:25:44 <Twey> Huh.
13:26:38 <yukko> I just discovered Data.Typeable - is being able to reify abstract types into concrete ones really safe? can bad things happen when you do it?
13:27:43 <Twey> Actually, on that topic, I'm curious about GHC's ‘Fingerprint’.  What is that?  Can they collide?
13:27:53 <bennofs> yukko: it's safe as long as you don't write Typeable instances manually I think
13:27:57 <vramana> benmachine: doesn't help http://pastebin.com/NtWwNCCy
13:28:00 <Heffalump> anyway, thanks all for the discussion about HoTT. I am slightly the wiser now :-)
13:28:07 <glguy> And you can't write them manually any more
13:28:20 <yukko> oh I see!
13:28:37 <Twey> Heffalump: My pleasure, at least ☺
13:28:40 <benmachine> vramana: you have to also fix things, but it at least ensures they won't become any more broken in the future
13:28:58 <benmachine> vramana: sudo chown -R vramana ~/.cabal
13:29:12 <arianvp> Hey guys, why  do we have the `Let` rule in the Hindley-Milner type system?
13:29:13 <arianvp> can
13:29:25 <arianvp> Isnt  App and Abs sufficiently powerful?
13:29:26 <benmachine> vramana: (be very careful copying commands that begin with sudo from internet chat channels, but I promise this one is okay :P)
13:30:04 <Iceland_jack> arianvp: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Let-polymorphism
13:30:18 <arianvp> of course there's something on wikipedia about it ...
13:30:23 <Iceland_jack> :)
13:30:28 <qwebirc10733> i am using MonadLogger as part of a monad stack and have to pass in a callback (in the io monad) is there any way to pass that monad-logger to the callback?
13:30:44 <benmachine> yukko: Typeable in itself is totally safe. It's made dangerous by the existence of cast :: a -> Maybe b that uses run-time type information, but that again is made safe by preventing user-defined instances
13:30:51 <Iceland_jack> Let generalization is a big part of HM, but it doesn't play nicely with more advanced Haskell features
13:31:15 <Heffalump> I still worry slightly that adding Typeable to all concrete types will allow people to violate abstraction boundaries
13:31:16 <arianvp> well haskell isn't a pure HM type system either right?
13:31:18 <qwebirc10733> is there some way to reify that monad function?
13:31:21 <Iceland_jack> no it's not
13:31:38 <c_wraith> Heffalump: I don't see how it'd allow that, offhand
13:31:44 <Iceland_jack> But to use the example from the article:
13:31:44 <Iceland_jack> > let f x = x in (f True, f 0)
13:31:46 <lambdabot>  (True,0)
13:31:52 <Iceland_jack> > (\f -> (f True, f 0)) (\x -> x)
13:31:54 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
13:31:54 <lambdabot>    arising from the literal ‘0’
13:32:23 <qwebirc10733> ok thanks
13:32:54 <arianvp> qwebirc10733: would be useful if you got some code at hand to demonstrate what you mean.
13:32:56 <Heffalump> do newtypes get different Typeable representations?
13:33:22 <brycelane_> Is there a way to do conditional importing based on OS? I need to concat a FilePath, and the 'filepath' library has two modules, one for POSIX and one for Windows.
13:33:41 <vanila> does typeable interact with ST?
13:33:50 <Iceland_jack> Heffalump: yes
13:33:54 <Heffalump> brycelane_: can't you just use System.FilePath ?
13:34:02 <Heffalump> brycelane_: but if not, use CPP
13:34:11 <stalintrotsky> If you import System.FilePath it will choose the right one to import
13:34:17 <Iceland_jack> They're representationally equal, but not propositionally equal types
13:34:32 <arianvp> CPP always makes me feel dirty
13:34:43 <goedlel> how do I write a ToJSON instance for a type that should be encoded as an array (not an object)?
13:34:45 <stalintrotsky> the module on haddock doesn't show all the exported members but you can use the same ones listed in the Windows and POSIX modules
13:34:53 <vramana> benmachine: Why?? Still getting some errors http://pastebin.com/Mr3BdRJM
13:34:54 <qwebirc10733> here some sample code http://lpaste.net/109949
13:35:11 <brycelane_> maybe, I'm using this as a learning tool so I'm a bit naive
13:35:14 <benmachine> vramana: ah, do the same thing with ~/.ghc
13:35:24 <arianvp> that's quite the code :D
13:35:35 <dolio> brycelane_: You can write two different implementations and have cabal choose which one to use. I'm not sure that's significantly better than CPP, though.
13:35:36 <benmachine> vramana: basically, when you sudo cabal install some stuff, it creates some directories in your home directory, and it does that as the root user
13:35:37 <brycelane_> thanks Heffalump
13:35:47 <goedlel> trying to use aeson to parse object into array
13:35:56 <benmachine> vramana: you want to do it as your ordinary user, and tell cabal how to use sudo so that it only does so when necessary
13:36:11 <qwebirc10733> addConnectionClosedHandler  and consumeMsgs support IO callbacks only so I cannot reuse the monadlogger  and have to start runStderrLoggingT each time
13:36:26 <c_wraith> Heffalump: yep.  Typeable does not get affected by GND.
13:36:40 <vramana> benmachine: Okay I understand it i guess.
13:37:05 <benmachine> brycelane_: I believe that System.FilePath basically picks one of the two modules to expose depending on what your system is
13:37:55 * hackagebot word-trie 0.1.0.0 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.1.0.0 (MateuszKowalczyk)
13:37:55 <qwebirc10733> I would appreciate any tips on writing the code better
13:38:40 <arianvp> Couldn't you make so that the callbacks are MonadIO instead of IO?
13:38:55 <arianvp> because then you can just make your transformer stack an instance of MonadIO (if it isnt already)
13:39:09 <qwebirc10733> unfortunately they are part of the amqp package
13:39:48 <arianvp> liftIO them?
13:42:09 <qwebirc10733> i tried that but it doesnt seem to work
13:42:20 <qwebirc10733> Could not deduce (MonadLogger IO)
13:43:06 <Feuerbach> qwebirc10733: take a look at monad-control
13:43:34 <qwebirc10733> i thought the callback would need to support monadbasecontrol for it to work?
13:44:00 <Feuerbach> and for amqp there's a .Lifted module IIRC
13:44:19 <Feuerbach> your monad has to be an instance of MonadBaseControl IO, yes
13:44:50 <goedlel> How can I encode a type into an array using aeson?
13:46:38 <qwebirc10733> thanks feuerbach: you are right there is a consumeMsgs that will work in Lifted
13:47:02 <johnw> qwebirc10733: you always have the option of making a MonadLogger instance for IO
13:47:07 <johnw> qwebirc10733: that's what my 'logging' package does
13:47:21 <goedlel> it seems difficult since haskell lists are of one type but json arrays can contain elements of different types
13:47:41 <arianvp> goedlel. that's the point  . they _can_ but they don't have to
13:47:56 * hackagebot MonadRandom 0.2.0.1 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.2.0.1 (BrentYorgey)
13:48:10 <goedlel> arianvp: so is it possible to make a heterogeneous array using aeson?
13:48:15 <goedlel> toJSON only?
13:48:46 <qwebirc10733> does the logging package support line numbers somehow?
13:49:02 <arianvp> I haven't played much with aeson to be honest, but I don't see why it wouldn't be possible.
13:49:04 <johnw> qwebirc10733: you could add that in your logging function of course
13:49:11 <luite> goedlel: an array is a Vector Value, where Value can be any JSON thing
13:49:47 <qwebirc10733> thanks johnw, that does sound like a good option especially as there are other callback functions where I have the same problem
13:49:52 <luite> goedlel: so anything you can convert to a Value (through ToJSON for example) can be stored there, they all ahve the same type
13:50:18 <goedlel> luite: so i should just put it into a vector?
13:50:22 <johnw> qwebirc10733: note that with the new version of fast-logger (which I haven't upgraded to you), you won't need to distinguish between finalizing and non-finalizing logging functions
13:52:41 <luite> goedlel: yes you want to construct a Value that represents a JSON array, see Data.Aeson.Value , the Array constructor
13:52:54 <goedlel> okay thanks
13:53:22 <qwebirc10733> thanks for all your help and am looking forward to the new version of logging
13:53:34 <johnw> qwebirc10733: let me see how hard it is to do right now
13:54:02 <qwebirc10733> awesome!
13:54:57 <johnw> qwebirc10733: well, it works just fine with what's on Hackage right now
13:56:19 <dreams> guys, what is a blackhole?
13:56:32 <hexagoxel> is there a tool for simplifying haskell expressions? e.g. "let a = e in f a" -> "f e" (assuming a not free in e)
13:57:49 <Tuplanolla> @pl let a = e in f a
13:57:49 <lambdabot> f e
13:58:05 <arianvp> hexagoxel: HLint ?
13:58:31 <trap_exit> is it bad form to use RWS monad everywhere? (instead of writer, reader, state) -- I realize it's more general, but it's so convenienet just using one monad that does everything
13:58:49 <trap_exit> so often I'm looking at a tistuationw here all I need is state + writer
13:58:50 <trap_exit> and I'm like, RWS () writer state
13:58:57 <hexagoxel> Tuplanolla: hmm sorry for being imprecise, pointfree is too rigid for my needs. i want a sensible level of point-free-ness
13:58:58 <trap_exit> rather than writerT (state .... )
13:59:25 <arianvp> hexagoxel: but that's a very personal opinion. that's hard to embody in a program I guess
13:59:26 <trap_exit> hexagoxel: we should call everything by it's true name, pointfree is pointless
13:59:28 <qwebirc10733> thanks johnw I will check it out
14:00:36 <arianvp> @pl \h f g x -> f x `h` g x
14:00:37 <lambdabot> liftM2
14:00:40 <arianvp> nice
14:00:49 <hexagoxel> trap_exit: the hackage executable is called pointfree, right?
14:01:06 <trap_exit> no idea
14:01:07 <arianvp> hexagoxel: correct
14:01:28 <hexagoxel> trap_exit: then i do not get what you mean
14:01:43 <arianvp> there is also http://hackage.haskell.org/package/pointful
14:01:44 <arianvp> :)
14:01:44 <trap_exit> it's a joke
14:01:45 <trap_exit> "pointless" as in useless
14:01:59 <trap_exit> pointfree code makes code so obfuscated looking that it's pointless
14:02:08 <arianvp> trap_exit I disagree :)
14:02:10 <trap_exit> "pointless" = useless in one english definition
14:02:28 <trap_exit> arianvp: I like my intermediate variable names :-)
14:02:44 <arianvp> interpret  = flip (runReader . runExceptT . interpret')  emptyEnv
14:02:45 <arianvp> :D
14:03:02 <trap_exit> well, there's just one flip in there
14:03:08 <arianvp> yeh not too deadly
14:03:25 <trap_exit> I'm against multiple use of functions that shuffle around the order of arguments
14:03:25 <trap_exit> here, I'm not against conciseness
14:03:31 <arianvp> I have times when I evan  utilize    fmap fmap fmap
14:03:35 <johnw> qwebirc10733: http://www.yesodweb.com/blog/2014/01/new-fast-logger is what I want to incorporate
14:03:36 <arianvp> or (.).(.) (equivalent)
14:03:42 <Tuplanolla> @pf (((/) .) . (+) .)
14:03:43 <lambdabot> Maybe you meant: pl bf
14:03:43 <arianvp> that's bad probably :)
14:04:03 <arianvp> @unpl (((/) .) . (+) .)
14:04:03 <lambdabot> (\ b h k -> (/) ((b h) + k))
14:04:05 <trap_exit> yeah
14:04:07 <Sotek> I've got a problem with a personal haskell project; I'm getting segfaults in a pure function that calls Data.Aeson.encode. What I've managed to figure out via trace is that the segfault trips when 'preparing to' evaluate the RHS of a .= in an object literal - it never evaluates the trace on that RHS, but it evaluates everything else (if I trace the show of the .= expression, it outputs ("screen", a few characters of garbage, then Null, then segfaults.
14:04:24 <trap_exit> the problem I have with pointfree ... is that "idiomatic" pointfree involves doing whatever black magic required to order of arguments
14:04:25 <Sotek> Google suggests this might be a bug in Data.Text.EncodeUTF8 or something?
14:04:29 <trap_exit> and I'm not willing to sacrifice that
14:04:35 <Sotek> does anyone have suggestions for what to do about this?
14:04:53 <trap_exit> Sotek: post error in gist; post code in gist; post minimal file that crashes on gist
14:05:12 <arianvp> and then bug report it :)
14:05:18 <arianvp> or let us look at it. hehe
14:05:34 <trap_exit> right, step (4) is point gist links here in #haskell
14:05:36 <Sotek> the entire error is "Segmentation fault". The code is definitely non-minimal, but I might be able to get a minimal instance in a few.
14:05:57 <arianvp> also. package versions, ghc version etc etc
14:06:07 <arianvp> see if we can reproduce it
14:06:30 <trap_exit> also, OS you're running, how much RAM you have, the serial number of the CPU; the temperature + humidity of your office, etc ...
14:06:32 <qwebirc10733> i guess i dont understand as logging-1.4.1 already uses fast-logger (>=2.1.5)?
14:06:45 <Sotek> I've tried a bunch of different versions of the packages to no effect. :\
14:06:50 <qwebirc10733> or is it under a different name?
14:06:55 <Sotek> or well, I think I have.
14:07:07 <Sotek> but I only started experimenting with sandbox yesterday.
14:07:28 <arianvp> variableNotFound = throwError . VariableNotFound
14:07:30 <Sotek> (and don't know how to see the version of GHC my sandbox install uses? cabal installs weirdly and I'm confused. :<)
14:07:34 <arianvp> these kind of things a better to be pointfree imo
14:07:46 <arianvp> GHC isnt sandboxed
14:07:57 <arianvp> so it's the same as outside of the sandbox I think
14:07:58 <dcoutts_> Sotek: when you do cabal configure, use -v and it'll report all sorts of details
14:09:12 <augur> lispy: ping
14:09:48 <Sotek> https://gist.github.com/MichaelRalston/049d56ca4b9cad9b8c31 the output of cabal configure -v
14:12:25 <hexagoxel> arianvp: oh, hlint does have a library interface with haskell-src, that is nice. unfortunately, it does not seem to do the replacement i suggested. still useful, thanks.
14:12:38 <hexagoxel> or is there a way to enable more hints than by default?
14:12:48 <Sotek> ... hm. well a minimal example doesn't crash, so now to figure out what's relevant.
14:13:20 <arianvp> hexagoxel: you can add your own hints if I recall correctly
14:17:36 <goedlel> im having trouble writing a toJSON for a type 'data TheType = TheType Integer Double Double'  that would do (TheType a b c) -> [a, b, c] for aeson
14:17:42 <goedlel> can someone show me how?
14:17:58 * hackagebot word-trie 0.2.0.0 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.0 (MateuszKowalczyk)
14:18:52 <Algebr> I think I understand that functors are something that provide a context for a value, and that I can understand for like "containers" and Maybe/Either. I'm having trouble understanding how functions can be context representors...., the ((->) e) is still throwing me off. Does it mean that if you call this context function, then you'll get something that will be used in your computations?
14:19:23 <Sotek> okay, I have somehow completely failed to replicate this problem.
14:19:35 <arianvp> those are the best problems
14:19:56 <Sotek> I mean it is reliable from my original code, but trying to rebuild it ... nope.
14:20:23 <Heffalump> Algebr: imagine that 'e' is 'Bool', then 'f a' = 'Bool -> a'
14:20:34 <arianvp> say I have
14:20:38 <Heffalump> which is basically just a pair of 'a' values, one for False and one for True
14:21:05 <Algebr> Heffalump: why is this interesting?
14:21:45 <arianvp> the context is an already filled in parameter
14:21:52 <arianvp> it's like dependency injection
14:21:57 <arianvp> dunno if that helps
14:22:16 <Algebr> so one of the things that your data structure depends on is provided already?
14:22:23 <arianvp> yes
14:22:42 <arianvp> sorta.
14:22:58 <arianvp> I just wrote some code that uses  (->) r
14:23:06 <arianvp> Hoping it might shed some light on its use
14:23:16 <Sotek> also: I guess I did already learn that there are not known major bugs with Data.Aeson.encode, which suggests at the very least I tripped over something weirdo.
14:23:22 <goedlel> luite: can you show me an example of using a heterogeneous vector?
14:24:15 <arianvp> hmm that code is more why it's useful as a Monad ((->) r ) is a monad too
14:24:33 <Algebr> arianvp: is there a link?
14:24:43 <athan> goedlel: HList might get something similar. Do you want the speed of vectors, or the semantic functionality?
14:25:00 <goedlel> semantic functionality
14:25:03 <goedlel> and speed wouldnt hurt
14:25:35 <arianvp> Algebr: http://stackoverflow.com/questions/14178889/reader-monad-purpose
14:25:46 <arianvp> I really liked that answer
14:25:49 <athan> goedlel: heterogeneous lists are a pain in the butt, but I think we're getting close. Do you want a monomorphic type signature? Because that would be actually pretty easy.
14:26:04 <athan> goedlel: Or do you need type level sets?
14:26:22 <goedlel> athan i have a type data T = T Integer Double Double
14:26:31 <goedlel> and I want to get json list as [a, b, c]
14:26:54 <athan> goedlel: I'm confused.
14:27:16 <goedlel> im trying to encode a type as a json array
14:27:18 <Sotek> can't you just do object [toJSON a, toJSON b, toJSON c]?
14:27:21 <Heffalump> Algebr: it makes a connection to a "container" Functo
14:27:24 <Sotek> er, not object, derp
14:27:33 <Heffalump> because a pair of 'a' values is just a particular kind of container
14:27:45 <Heffalump> if you make the 'e' type be Int, then you've got an infinite array
14:27:54 <goedlel> Sotek: yeah, there doesnt seem to be anything similar for array
14:28:10 <Sotek> goedlel: why not just "toJSON [toJSON a, toJSON b, toJSONc]" then?
14:28:19 <Sotek> er, with the right spacing.
14:28:23 <athan> Sotek++
14:28:32 <athan> goedlel: You can create an instance!
14:28:35 <goedlel> Sotek: let me try that
14:28:46 <athan> or at the very least, leverage `toList`
14:28:48 <goedlel> athan: its the instance creation thats the problem
14:28:51 <athan> er whichever it is
14:29:20 <athan> goedlel: Do you have any code I can look at?
14:29:25 <Sotek> also, re my problem: I just remembered that my traces were changing the behavior (but not the problem) - without them, I get "Data.Vector.Mutable: uninitialized element" in what I think is in the same place. (hard to be sure, of course...)
14:29:52 <Sotek> I assume that doesn't immediately tell anyone what's wrong.
14:30:12 <goedlel> ah
14:30:20 <goedlel> what Sotek suggested works perfectly
14:32:21 <Sotek> cool.
14:33:00 <athan> Sotek: We should have `toJson` generics :P
14:33:06 <athan> or a deriving clause
14:34:01 <Sotek> athan: I'm sure there's a better way than what I said, yes. My haskell experience isn't terribly deep.
14:34:44 <athan> Sotek: Generics are awesome :) check out the scrap your boilerplate paper for a good intro!
14:34:50 <tekul> Anyone run into problems with ghcmod-vim recently?
14:34:57 <tekul> I'm having this problem https://github.com/NixOS/nixpkgs/issues/3146#
14:35:14 <Sotek> that said, I don't think generics would have solved his problem? since he DIDN'T want the "obvious" translation.
14:35:15 <tekul> And someone says it's an issue with vimproc.
14:38:08 <athan> tekul: I'm using notepad++ right now
14:39:34 <athan> tekul: Sorry, I'm joking... In a weird state of mind right now. Let me see if I can help, I think I'm using it right now - I may be using the hamlet extension, I've never had problems with it though. It uses vundle, lemme dig
14:39:40 <tekul> athan: Would that require changing OS as well as editor? :)
14:40:30 <tekul> I'm using pathogen, and it was working OK until I upgraded to ghc-mod 5
14:40:31 <Fuuzetsu> tekul: are you on NixOS?
14:40:51 <tekul> This is on OSX, but I had the same issue on NixOS after I installed vim yesterday
14:40:59 <glguy_> athan: Aeson already has generic deriving for To/FromJSON
14:41:10 <Fuuzetsu> tekul: I hear of some hack for vim
14:41:14 <Fuuzetsu> such as https://github.com/bflyblue/nixpkgs/commit/e3e4f26b1d46959b8a1592ffc72c0205908250af
14:41:19 <athan> glguy_: I knew it!!
14:42:38 <Fuuzetsu> tekul: you should probably try GHC mod 5.x, 5.0.1.1 was just released earlier
14:42:58 <tekul> I just installed that on OSX and it's broken here now :)
14:43:01 * hackagebot word-trie 0.2.0.1 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.1 (MateuszKowalczyk)
14:43:11 <tekul> Actually it was 5.0.1... I'll try 5.0.1.1
14:43:25 <Fuuzetsu> that won't fix it looking at the changelog
14:43:32 <pertl> somehow I am too stupid to get 'scanr' ... I don't understand why "scanr (-) 0 [1,2,3]" delivers "[2,-1,3,0]". can somebody explain please?
14:43:34 <tekul> But this seems specific to the vim plugin...
14:44:13 <Fuuzetsu> tekul: yes, sorry I can't help with that but I know some people in #nixos got it working so you might want to ask around there
14:44:31 <athan> I need to start using Yi...
14:44:44 <tekul> Fuuzetsu: Thanks. Was it the same error? The version check failing?
14:44:58 <athan> @src scanr
14:44:59 <lambdabot> scanr _ q0 []     =  [q0]
14:44:59 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
14:44:59 <lambdabot>     where qs@(q:_) = scanr f q0 xs
14:45:19 <athan> pertl: Don't give up!! :)
14:45:26 <pertl> yikes
14:45:26 <Fuuzetsu> tekul: yes, it was something about versions
14:45:34 <Fuuzetsu> I hear there's a hack to workaround that
14:45:38 <athan> pertl: What's scaring you? the @?
14:45:39 <tekul> I'll check the log
14:45:42 <tekul> Thanks
14:45:54 <Fuuzetsu> athan: we can use some helping hands
14:46:12 <athan> Fuuzetsu: In Yi? I'm unpacking right now :)
14:46:18 <dfeuer> nomeata: do you happen to know why GHC's concatMap isn't a good producer?
14:46:18 <Fuuzetsu> athan: yes
14:46:30 <athan> Fuuzetsu: :3
14:46:31 <benmachine> pertl: I think that scanr f z xs roughly returns [foldr f z xs, foldr f z (drop 1 xs), foldr f z (drop 2) xs, ...]
14:46:42 <Fuuzetsu> I found time recently to start hacking on it again, currently trying to clean up the modules a bit because it's scary
14:46:51 <Fuuzetsu> our issue tracker is fairly up to date
14:46:52 <athan> Fuuzetsu: Fair warning - I've never really used emacs :D
14:46:53 <benmachine> i.e. all the intermediate results on the way to computing foldr
14:47:01 <Fuuzetsu> athan: yi --as=vim
14:47:02 <nomeata> dfeuer: sorry, no.
14:47:08 <benmachine> er, should be (drop 2 xs) there
14:47:08 <dfeuer> Hmmmm
14:47:08 <athan> Fuuzetsu: That's godly
14:47:22 <d-snp> hi, why is this line illegal? it says illegal polymorphic or qualified type:
14:47:23 <d-snp> type ActionResult = MonadIO m => IO (Producer String m ())
14:47:24 * athan prepares blood oath
14:47:32 <glguy_> > scanr (-) z [a,b,c,d]
14:47:34 <lambdabot>  [a - (b - (c - (d - z))),b - (c - (d - z)),c - (d - z),d - z,z]
14:47:39 <glguy_> pertl: ^
14:47:50 <athan> glguy_: So is this a hylomorphism?
14:47:59 <Fuuzetsu> the editor needs much more polish, there are some big issues but I hope we can recruit you to help out if you don't dislike it
14:48:14 <pertl> I will try to comprehend that, thanks :-)
14:48:46 <athan> Fuuzetsu: You got it, I hope I can help :)
14:49:31 <glguy_> athan: I don't believe so
14:50:12 <athan> glguy_: Hmm, it feels like a... super catamorphism or something. Sorry
14:50:49 <athan> or like a factorial
14:50:58 <athan> idk, either way it's cool
14:52:39 <Fuuzetsu> athan: PS: probably want to install from git
14:52:45 <Fuuzetsu> PPS: that may or may not be broken right now at least on 7.6.3
14:54:25 <Sotek> hmm, if I replace encode with seq encode and a fixed string, it still bombs. if I then replace that encode with encodeToByteStringBuilder I don't crash immediately, but if then call toLazyByteString on the builder it crashes again.
14:55:48 <lpaste> d-snp pasted “Making a type alias with the producers in it” at http://lpaste.net/109954
14:56:03 <d-snp> I pasted my full hs file, it crashes on my type definition
14:56:14 <d-snp> I'm trying to extract the return type of my two 'action' functions
14:56:27 <glguy> d-snp: For reference, compiler errors aren't "crashes"
14:56:34 <d-snp> eh oops :P
14:56:40 <d-snp> it errors :P
14:57:23 <glguy> d-snp: You forgot to mention "m" in your type ActionResult
14:57:34 <athan> Fuuzetsu: Build's failing o:
14:57:52 <Fuuzetsu> are you on 7.6.3
14:57:55 <glguy> d-snp: Try: type ActionResult m =
14:57:56 <Fuuzetsu> if yes then give me 5 mins
14:58:47 <d-snp> glguy: same error message unfortunately
14:59:02 <Fuuzetsu> should be good on 7.6.3 now
14:59:04 <glguy> d-snp: and now removed "MonadIO m =>"
14:59:07 <glguy> remove*
14:59:13 <zereraz> hello, how to write recursive definitions in haskell where the base case is [] and then the definition, It looks like it gets overridden by the next part.
14:59:15 <glguy> That goes where you use the type synonym, not inside
14:59:20 <zereraz> in ghci
14:59:26 <athan> Fuuzetsu: Oh I was just talking about your continuous integration system
14:59:30 <athan> I'm on 7.8.3
14:59:35 <zereraz> ghci seems to override them
14:59:57 <Fuuzetsu> athan: right, right, that's just crying about 7.6.3, I just moved out a module to different package and I'm still in the middle of getting the dependencies right there
15:00:03 <d-snp> glguy: ah yes that did it..
15:00:10 <Fuuzetsu> which is why you see word-trie from hackage bot every 5 minutes…
15:00:33 <dreams> zereraz: use :{ then write the definitions, then :}.
15:00:33 <d-snp> so I'm not allowed to have type class constraints in type aliases like that, that's just the rule?
15:00:35 <athan> Fuuzetsu: Sorry :P
15:00:55 <arianvp> d-snp  type constraints in  datatypes isnt that useful anyway
15:01:03 <zereraz> dreams: is that a block ?
15:01:04 <arianvp> (I discovered this today)
15:01:08 <glguy> d-snp: Without special extensions your type constraints go on the very top-level of a type
15:01:10 <athan> zereraz: try `let foo [] = ... ; foo (x:xs) = ...`
15:01:11 <Sotek> hmm, I guess my problem is in the bytestring package right now.
15:01:15 <athan> on one line
15:01:16 <benmachine> arianvp: I think you're talking about a different issue, we're talking about type synonyms, not datatypes
15:01:20 <arianvp> oh
15:01:21 <dreams> zereraz: yeah it lets you write definitions in multiple lines.
15:01:22 <arianvp> i see
15:01:28 <arianvp> that's indeed a different issue
15:01:32 <zereraz> ok thanks, I'll try
15:01:55 <Sotek> and I haven't actually tried with older versions of bytestring.
15:02:05 <dreams> zereraz: so :{, then let f [] = [] then type enter, then f (x:xs) = blah, then enter then :}
15:02:51 <dfeuer> nomeata: you asked the question three years ago, and no one answered. Maybe no one was paying attention? Your preliminary results looked positive.
15:02:58 <dreams> zereraz: sorry you also need to type enter after the first :{
15:03:03 * hackagebot word-trie 0.2.0.2 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.2 (MateuszKowalczyk)
15:03:28 <nomeata> dfeuer: I did? :-)
15:03:29 <nomeata> where?
15:03:47 <Fuuzetsu> the travis guys REALLY need to cache build results
15:03:47 <Fuuzetsu> I hate waiting 10-20 minutes before the build of my own stuff even starts
15:04:00 <zereraz> dreams: and at the end I type }: ?
15:04:05 <dfeuer> nomeata: http://www.haskell.org/pipermail/haskell-cafe/2011-December/097230.html
15:04:09 <d-snp> glguy: alright :) Thanks for the help :)
15:04:13 <zereraz> dreams: and there should be only 1 let?
15:04:31 <dreams> zereraz: when you finish the definition type enter then type :}. and yes 1 let.
15:04:40 <bennofs> Fuuzetsu: you can cache build results
15:05:07 <bennofs> Fuuzetsu: oh, only available on private travis :/
15:05:26 <enthropy> zereraz: :set +m  lets you leave off the :{ :}
15:05:27 <sinelaw> howdy. traceShowId prints strings such as "bla\n". how can I get it to print the actual characters (e.g. newline)?
15:05:29 <zereraz> Prelude> :{
15:05:29 <zereraz> Prelude| let prod [] = 1
15:05:29 <zereraz> Prelude| prod (x:xs) = x* (prod xs)
15:05:31 <zereraz> Prelude| :}
15:05:38 <zereraz> why is that wrong?
15:05:41 <sinelaw> or is there an alternative?
15:05:57 <enthropy> but with :set +m you need an extra newline to say you're done with layout
15:06:08 <zereraz> I am getting parse error on input 'prod'
15:06:38 <nomeata> dfeuer: forgot about that. but you see, it is normal to get no replies to list-fusion related questions :-)
15:06:51 <Fuuzetsu> bennofs: I'm talking about build deps here, say lens or whatever, I don't care for my own build results
15:06:52 <Fuuzetsu> it just seems like a waste of resources on their end and waste of time of the users
15:07:00 <dfeuer> So I am seeing!
15:07:11 <zalatovo> zereraz: I think it's because you don't have a "let" on the second line, but I'm not sure if you can have multiple patterns in GHCI function definition
15:07:17 <dreams> zereraz: paste your code in http://lpaste.net/new/haskell
15:07:42 <dreams> zalatovo: no, the second line doesn't need let.
15:08:02 <zereraz> http://lpaste.net/109955
15:08:04 * hackagebot Folly 0.1.0.0 - A first order logic library in Haskell  http://hackage.haskell.org/package/Folly-0.1.0.0 (dillonhuff)
15:09:12 <zereraz> 1 let with ; works though
15:09:13 <dreams> zereraz: the second prod needs to aligned with the first.
15:09:28 <dreams> zereraz: after the let.
15:09:33 <zereraz> dreams: so ghci actually makes them into a block
15:09:38 <zereraz> ok got it thanks
15:10:04 <zalatovo> zereraz: And you don't have to write the parentheses around prod xs
15:10:25 <nomeata> dfeuer: I guess the reason is that adding yet another function to fuse properly is academically not exploitable anymore
15:10:33 <nomeata> and it is relatively tedious to do and test
15:10:43 <Tuplanolla> A quick question. When was prompt2 introduced to ghci?
15:10:45 <zereraz> zalatovo: I always get this part wrong, I either put less paranthesis or put more, I don't understand that part as of now
15:11:03 <nomeata> even more reasons to value your work
15:12:23 <Sotek> this is a terrible question to ask, and I'm sure the answer is no, but: is there a way other than encode to convert an Aeson Value into a string? alternatively, is there a way other than toLazyByteString to turn a builder into a bytestring? (that isn't just another way to call down into toLazyByteStringWith)
15:12:47 <dfeuer> nomeata: so I figured. I've decided to back off the whole cons/build thing for now, even though it can sometimes do good; I want to try to focus on things with a better chance of making it into GHC *soon*.
15:13:04 * hackagebot Folly 0.1.1.0 - A first order logic library in Haskell  http://hackage.haskell.org/package/Folly-0.1.1.0 (dillonhuff)
15:13:06 <Axman6> Sotek: why do you ask?
15:13:45 <nomeata> ACK
15:13:50 <Sotek> Axman6: Because toLazyByteStringWith is crashing for me, and I can't find a version that's compatible with my other depedencies that doesn't crash.
15:14:08 <Axman6> crashing how?
15:14:20 <nomeata> dfeuer: BTW, are you attending ICFP?
15:14:27 <Sotek> Data.Vector.Mutable: uninitialized element
15:14:28 <dfeuer> Sotek: you probably *can*, by importing weird modules that break abstractions, but that would be *wrong*.
15:14:54 <naudiz> is there a way to match functions against argument types?
15:15:02 <dfeuer> nomeata: I think it's unlikely. I lost my job yesterday. Where/when is ICFP?
15:15:14 <Sotek> dfeuer: well what's right?
15:15:19 <Axman6> naudiz: hoogle?
15:15:25 <glguy> Sotek: You probably aren't going to be able to trick Aeson into not blowing up by using a different entry point into the encoder. It's more likely that you're doing something funny with pointers
15:15:33 <Sotek> glguy: I'm /not/, though :(
15:15:34 <Axman6> @hoogle [a] -> Int
15:15:35 <lambdabot> Prelude length :: [a] -> Int
15:15:35 <lambdabot> Data.List length :: [a] -> Int
15:15:35 <lambdabot> Prelude head :: [a] -> a
15:15:43 <dfeuer> Sotek: if aeson really is the problem, fix aeson.
15:15:54 <dfeuer> Otherwise, fix your code.
15:16:04 <naudiz> Axman6: I'm talking about having a function foo :: a -> b -> c that acts in different ways depending on the types of a and b
15:16:04 <kgadek> hi. little hope for anyone to help, but I'll give it a shot: let's say I want to use http://hackage.haskell.org/package/mersenne-random-pure64 in my code. I need to have an equiv. of randomR, so that I pass a range and get a result. Is that possible with such interface that does not provide uniform-random?
15:16:12 <Sotek> dfeuer: I don't know what the problem is. What I know is that I can turn everything into a builder, and not crash. Then if I try to encode the builder, I crash.
15:16:13 <tekul> Regarding my ghcmod-vim problem (version check failure, index out of bounds) - it goes away if I revert to ghc-mod 4.1.5 which I had before. NixOS had 4.1.6 and it went awry on OSX when I upgraded to 5.x
15:16:13 <nomeata> dfeuer: oh, sorry to hear that
15:16:27 <nomeata> dfeuer: in one week, in Göteborg in Schweden
15:16:48 <dfeuer> Thanks, nomeata. No, I will not be flying across the ocean next week.
15:16:48 <naudiz> Axman6: so I'd like to do something like pattern matching against types
15:17:32 <Axman6> naudiz: well, (multi parameter) type classes let you do that
15:18:03 <Axman6> naudiz: but generally you'd use a sum type to do that
15:18:05 * hackagebot opn 0.1.0 - Open files or URLs using associated programs.  http://hackage.haskell.org/package/opn-0.1.0 (AndersClaesson)
15:18:06 <naudiz> Axman6: I can't do it this way because it requires cyclic depedencies in my case
15:18:29 <Fuuzetsu> http://hackage.haskell.org/package/internetmarke damn is there something that Thielemann hasn't written?
15:18:30 <nomeata> dfeuer: where in the world are you actually?
15:18:37 <Axman6> maybe you should explain your real problem
15:19:02 <dfeuer> nomeata: Near Washington, D.C., in Maryland.
15:19:08 <naudiz> Axman6: oh... actually it doesn't and I'm jsut stupid m) forgot that a type can be an instance of multiple classes
15:19:14 <naudiz> s/jsut/just
15:19:25 <naudiz> Axman6: thanks for your help
15:19:27 <nomeata> Fuuzetsu: what about Thielemann’s list of things that Thielemann has not written?
15:19:50 <nomeata> Fuuzetsu: did he write this list on the list?
15:20:01 <nomeata> dfeuer: ok. I’m in portland right now, for DebConf
15:20:17 <Fuuzetsu> nomeata: I'm sure he's using classes rather than lists
15:20:20 * Axman6 wishes he could go to ICFP :(
15:20:33 <Sotek> glguy: like ... I do forkIO, I do withMVar, and those two things are the closest I get to touching pointers anywhere. And those are both done cleanly inside IO like they're supposed to be. so I have no idea what's going on or how to figure it out. I wasn't able to build a repro case.
15:21:23 <glguy> Sotek: You mentioned issues with uninitialized mutable vectors, are you using those or is Aeson?
15:21:33 <Sotek> Aeson and/or Bytestring are.
15:22:02 <Sotek> I think it's actually ByteString, because I can turn my Aeson value into a Builder no problem, it's turning that Builder into a ByteString that trips it.
15:22:14 <glguy> Well, without code the best anyone can do is guess
15:22:20 <benmachine> Sotek: be aware that laziness might mislead you about where the error is
15:22:39 <Sotek> benmachine: I know. I put a bunch of tracing and seq and whatnot.
15:22:44 <dfeuer> nomeata: that puts you a few thousand miles away. You don't happen to plan to swing by Dulles on your way out, do you?
15:22:53 <Sotek> I'm pretty sure it's exactly there,
15:23:04 <kgadek> re self: nvm me — didn't spot the `instance RandomGen PureMT` which solves my question
15:23:05 * hackagebot simple-pipe 0.0.0.23 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.23 (YoshikuniJujo)
15:23:07 * hackagebot heroku 0.1.2.1 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.2.1 (GregWeber)
15:24:50 <Sotek> https://github.com/MichaelRalston/hgame/blob/master/Engine/Mechanics.hs line 61 of this file is the place where the encoding lives and explodes.
15:24:57 <benmachine> Sotek: I'm not sure if seq works properly on Builder values
15:25:11 <Sotek> benmachine: ah, hmm. so it might be in Aeson after all.
15:25:24 <benmachine> Sotek: it's important that you take "not sure" literally here :)
15:25:38 <benmachine> but underneath, Builder is a function type
15:25:44 <Sotek> benmachine: gotcha, yeah. Yeah, I see.
15:25:48 <Sotek> so it might not evaluate some inner stuff
15:25:52 <Sotek> and that could be what's actually blowing up.
15:25:56 <benmachine> could be
15:26:20 <benmachine> my intuition is that ByteString is more mature than Aeson so much less likely to have a bug
15:26:30 <benmachine> but that's only intuition, could be totally wrong
15:26:35 <nomeata> dfeuer: no, sorry, stopping in amsterdam and frankfurt
15:27:19 <arianvp> :) Amsterdam
15:27:31 <arianvp> I'm in Amsterdam next week!  not going to ICFP though :(
15:27:50 <arianvp> I'll be at LaraCon
15:28:05 * hackagebot opn 0.1.1 - Open files or URLs using associated programs.  http://hackage.haskell.org/package/opn-0.1.1 (AndersClaesson)
15:28:09 * magicman is in Amsterdam every weekday, and also not going to ICFP >_>
15:28:27 <arianvp> there are worse places to be every weekday
15:29:12 <magicman> True!
15:29:32 <joelteon> like hell!
15:29:37 <joelteon> not the shell, but the location
15:29:45 <arianvp> so if people are up for an IRL 'haskell caf'  ;)
15:29:46 <glguy> Sotek: Your ToJSON instance for GameLog is missing some cases
15:29:57 <glguy> Sotek: any chance you're trying to encode one of those?
15:30:42 <Sotek> glguy: ... holy crap yes
15:30:44 <Sotek> that's exactly it
15:30:53 <Sotek> well I haven't confirmed I actually fixed it, yet
15:30:56 <Sotek> but that's ... very plausible
15:31:25 <Sotek> now why didn't the compiler whine at me for that, I wonder.
15:31:36 <magicman> There used to be a Haskell User Group in NL, meeting in Utrecht every once in a while. Would be fun to reboot something like that.
15:31:45 <magicman> I'd do it if I could find the time >_<
15:32:01 <arianvp> I'm up for such a thing.  Preferably in Utrecht!  I can bike then, hehe
15:32:50 <Sotek> glguy: anyway I'll go off and implement a whole bunch of case-instances for things and then see if it works, so at least you've given me a path forward. Thanks! :)
15:33:10 <arianvp> and we've got http://www.meetup.com/fp-ams/
15:33:17 * slack1256 wishes there were haskell user group where he lives
15:35:21 <Sotek> hmm, although traces suggested it was crashing in the vicinity of the screenObject. which is a Map, and in my code in question it's just Map.empty, so that shouldn't be relevant. Still, laziness.
15:35:24 <enferex> I have a basic question regarding teh Get Monad.  I have some code and the error I am getting posted at: http://lpaste.net/109946
15:35:48 <Fuuzetsu> is there a package with Arbitrary instance for Strings in UTF8 range?
15:36:01 <Fuuzetsu> I always end up having to define such instance/helper myself and it's dumb
15:36:04 <magicman> Ooh, interesting. Didn't know about the FP-AMS group.
15:36:10 <seangrove> Is this anywhere near idiomatic for making a palindrome in Haskell? https://www.refheap.com/89424
15:36:14 <arianvp> :)
15:37:23 <magicman> I live in Utrecht too, btw :p
15:37:24 <zalatovo> seangrove: I would think something like palindrome xs = xs ++ reverse xs
15:37:27 <seangrove> I know it could also be written as pl = xs ++ reverse xs
15:37:47 <Fuuzetsu> @pl pl xs = xs ++ reverse xs
15:37:47 <lambdabot> pl = ap (++) reverse
15:37:48 <seangrove> zalatovo: Yeah, just thinking about the structure of the function using guards, helpers, etc
15:37:58 <seangrove> Would it be more likely to have it all in one fn, for example?
15:38:01 <glguy> Sotek: Check out the type of (.=), I don't think you need to write:  "key" .= toJSON x.    "key" .= x   should do
15:38:03 <magicman> seangrove: I don't like the init/last combo. Much better to somehow recurse on head/tail.
15:38:11 <glguy> Sotek: I don't think that's your bug, though
15:38:24 <arianvp> seangrove:  how about:  xs ++ reverse xs ?
15:38:30 <arianvp> oh Fuuzetsu beat me at it
15:38:49 <Sotek> glguy: I think there might be a context or two where there's a type ambiguity otherwise
15:38:50 <zalatovo> seangrove: In your helper, you're using a guard to test if ys is []
15:39:05 <Fuuzetsu> palindrome _ = "aba" ;)
15:39:11 <seangrove> Well, I was trying to put helper as a let binding inside of pl, for example, couldn't quite get it to work syntax-wise
15:39:17 <zalatovo> seangrove: You can use pattern matching to do that
15:39:22 <barrucadu> seangrove: You could pattern match on xs
15:39:29 <hiptobecubic> > let p = (++) <*> reverse in p "woo "
15:39:31 <lambdabot>  "woo  oow"
15:40:11 <glguy> Sotek: That might be something else, it shouldn't have any difference in type inference behavior
15:40:52 <Sotek> welp, adding the missing GamelogMessage ToJSON instances gets me to segmentation fault instead of the previous error.
15:40:55 <Sotek> let's try a clean build just in case.
15:41:12 <zalatovo> seangrove: And your helper is just reverse
15:41:15 <Sotek> yeah, clean build gives me the vector error again.
15:42:03 <glguy> Sotek: This probably isn't your bug, either, but it's a bad idea: instance EntityId entity => ToJSON (ZoneDisplay, [ScreenEntity entity]) where
15:42:11 <glguy> the overlapping the existing (,) instance part
15:42:47 <Sotek> hmm, noted.
15:43:09 <seangrove> barrucadu: Good suggestion, thank you
15:43:19 <seangrove> zalatovo: True, I suppose I should have named it better
15:43:19 <glguy> but it's interesting that you're getting the bug around the point you're using that instance
15:43:32 <enferex> My Data.Binary.Strict.Get parser returns one of my custom data types.  However, I keep getting an error at runGet expecting my data type but actually recieving an Essential instead.  I am a bit confused.  My code is similar to the package docs
15:43:39 <Sotek> commenting out that instance and doing a clean build now gives me a segfault.
15:44:30 <Sotek> which I guess means I changed /something/
15:45:08 <Sotek> is there a reasonable way to get anything useful out of the fact it segfaulted?
15:45:42 <Sotek> gdb is currently completely unhelpful but I don't know if that's just a matter of compiling with some kind of debug flags or what.
15:47:05 <arianvp> Sotek: no core dump?
15:47:21 <arianvp> not that it will be very useful
15:47:40 <Sotek> arianvp: gdb sees a core dump, the backtrace shows a two-element stack, the top being a pointer in ?? and the bottom being a null pointer.
15:48:07 <arianvp> very useful indeed
15:50:31 <d-snp> what haskell library should I use for working with filesystem paths? (it'll only have to work on linux)
15:50:38 <d-snp> since it's just linux, perhaps I should just be concatenating strings with '/'
15:50:57 <dfeuer> No.
15:51:17 <Sotek> man, this is weird. if I have my dubious instance, I get Data.Vector.Mutable. if I remove it, I segfault. If I add traces, I segfault. removing the unimportant toJSON's has no effect, at least. so that's good.
15:51:19 <dfeuer> Why would you do that?
15:51:22 <zalatovo> d-snp: System.FilePath
15:51:29 <luite> Sotek: GHC 7.10 is getting DWARF info which should help showing a bit more stack
15:51:48 <Sotek> super weird to me that a trace changes it from Data.Vector.Mutable: uninitalized element to just ... segfault.
15:51:51 <luite> Sotek: recompile your vector package with -fsafe to see if you're not overrunning anywhere
15:53:04 <Sotek> luite: how do I tell cabal to do that. also, I don't /have/ a vector package in my code, it's being included by something I'm including.
15:54:18 <luite> Sotek: install in a sandbox
15:54:38 <Sotek> luite: I am!
15:54:41 <d-snp> alright thanks zalatovo
15:54:43 <Sotek> (I think.)
15:55:04 <goedlel> whats a fast way to parse a date+time from string and convert it to milliseconds?
15:55:19 <luite> Sotek: i'm not quite sure if it will honour a -fsafe flag for dependencies, if it doesn't, just unpack vector, add-source it to your sandbox and set the flag manually
15:55:48 <goedlel> i tried using LocalTime -> NominalDiffTime but its very slow
15:56:01 <Sotek> luite: I don't know how to pass any kind of flags to anything with a cabal sandbox.
15:56:14 <luite> cabal configure -fsafe
15:57:14 <Sotek> I do that, then do a build and it says it has never been configured.
15:58:13 <Sotek> hmm, I guess cleaning wipes configurations?
15:58:19 <dcoutts_> yes
15:58:29 <dcoutts_> use cabal clean -s to clean while saving the config
15:59:16 * Sotek tries install -fsafe --only-dependencies
15:59:37 <arianvp> Sotek:  you pass -fsafe to configure, not install
15:59:39 <arianvp> (I think)
15:59:57 <Sotek> arianvp: well I want to have my dependencies have that flag.
16:00:08 <Sotek> and install /does/ take it without complaint.
16:02:37 <luite> arianvp: configure flags are also passed when doing install. it wouldn't work for cabal build
16:03:13 <glguy> configure is separate from install
16:03:13 * hackagebot keystore 0.5.0.4 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.0.4 (ChrisDornan)
16:03:21 <glguy> you don't configure before an install
16:06:22 <Sotek> hmm. got the uninitialized element error again.
16:07:08 <Sotek> and yeah, if I comment out that instance I get a segfault
16:07:18 <Sotek> how is it even possible, given that it doesn't even get to enter that code?
16:07:34 <Sotek> I guess it might cause/prevent inlining or something, but wow
16:09:09 <trap_exit> does haskell compile to ocamlyet?
16:14:09 <Sotek> okay! I think I figured out my problem. I have no idea how it was manifesting the way it did, but er, my ToJSON instnace for Screen was ... "special". let's go with that.
16:14:51 <glguy> Sotek: this? toJSON = toJSON
16:15:00 <Sotek> glguy: yes. /o\
16:15:09 <Sotek> I'm just going to bow my head in shame and shuffle away now.
16:15:49 <Sotek> (and, you know, figure out how to write an actual instance for this, since I need one.)
16:49:46 <t4nk303> hi evryone
16:52:55 <lispy> hello
16:55:40 <Ouyang> hey, does anyone know of a way to make Haskell complete tasks similar to what AutoHotKey does?
16:56:52 <lispy> Ouyang: how does it complete tasks?
16:57:28 <t4nk303> hi, i was looking for some help on tuple intersection
16:57:50 <Ouyang> Exports key presses, when activated by a keypress. for example, hitting f9 would cause it to simulate hitting enter and typing a message you put in
16:58:40 <carter> so like  gui macro scripting thingy?
16:59:01 <lispy> Ouyang: I don't think I know much about that
16:59:10 <lispy> t4nk303: what is a tuple intersection?
16:59:29 <Ouyang> carter: not sure.  I was going to make a gui program that does it though just as a project
16:59:38 <carter> for what OS?
16:59:54 <Ouyang> windows 8.1
17:00:04 <carter> huh
17:00:07 <stalintrotsky> If I wanted to learn Yesod, would I have to use persistent or could I use acid-state with it?
17:00:25 <carter> stalintrotsky: Acid-State is more like an atomic log
17:00:35 <carter> stalintrotsky: that said, you can mix an dmatch howver you please
17:00:47 <stalintrotsky> ok
17:00:48 <lispy> Ouyang: I once wrote a program in C for windows that did macro hot keys and I had to use the Win32 API at a pretty low level I think. Sadly I no longer have the code and it's easily been a decade.
17:00:57 <stalintrotsky> maybe I'll learn some yesod and see how things fit together first
17:00:59 <t4nk303> i have two lists of tuples ls1=[(1, 2), (2,3), (4,5)] ls2 = [(1, 3, "s"), (4, 1, "s"), (2, 3, "s")] i want ls1 intersect ls2 based on fisrt value of the tuples
17:01:29 <Ouyang> lispy: yeah I wasn't sure how low level it would be.  I just wanted to use something other than AHK to learn some things.
17:02:34 <edgar`> why would fmap g (x:xs) = g x : g x : fmap g xs not be a fmap implementation for []s?
17:02:51 <glguy> because fmap id = id
17:03:23 * hackagebot word-trie 0.2.0.3 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.3 (MateuszKowalczyk)
17:03:23 <lispy> Ouyang: this might be helpful: http://stackoverflow.com/questions/1820825/global-hotkey-with-win32-api
17:03:25 <edgar`> why would that violate that law?
17:03:48 <lispy> Ouyang: there is module that has lots of win32 functions but I don't think it's complete. so you may need to write some ffi
17:04:56 <Ouyang> lispy: I am pretty new to programming.  I'm spread out across languages and bad at all.  I doubt I'll be able to attempt this for a while.  Thank you for your help though
17:05:28 <lispy> Ouyang: good luck!
17:05:30 <t4nk303>  i have two lists of tuples ls1=[(1, 2), (2,3), (4,5)] ls2 = [(1, 3, "s"), (4, 1, "s"), (5, 3, "s")] i want ls1 intersect ls2 based on fisrt value of the tuples so the answer would be something like ls3=[(1,2,3,'s'), (4,5,1,'s')]
17:07:25 <glassresistor> anyone want to make something like twee(twines syntax engine) with js?
17:08:19 <lispy> t4nk303: as warmup it might help to write a function, say find, that takes a value and returns all the tuples that start with it.
17:08:49 <lispy> find 1 [(1, 3, "s"), (4, 1, "s"), (5, 3, "s")] = [(1,3,"3")]
17:09:36 <benzrf> i should probably not use [String] for 609813 lines of text, right?
17:09:51 <Rembane> benzrf: It depends, is it fast enough?
17:09:55 <benzrf> i havent tried
17:10:16 <Rembane> benzrf: Then it, by definition is fast enough
17:12:10 <glguy> t4nk303: http://lpaste.net/109957 There are some handy function in Data.Map for this sort of thing
17:12:18 <edgar`> glguy: oh, is it because that example would change the structure of the list rather than just the elements of the list.
17:13:07 <benzrf> crap
17:13:09 <benzrf> god dammit
17:13:10 <benzrf> >.<
17:13:24 * hackagebot BlogLiterately 0.7.1.7 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.7 (BrentYorgey)
17:13:28 <glguy> edgar`: It's because your definition doesn't satisfy one of the laws of fmap (the one that says: fmap id == id). Thinking about it as preserving "structure" is one way to look at it
17:13:29 <benzrf> parsec uses State but it's a local definition for a type that holds the parsing state
17:13:39 <benzrf> NOT State as in a function from state to (result, state)
17:13:44 <benzrf> er, (state, result)
17:13:48 <benzrf> that confused the heck out of me -.-
17:13:55 <lispy> benzrf: It usually depends on what you do with the [String]. Text is probably the right thing given that you have so many lines, but without more info it's hard to say.
17:14:02 <benzrf> im doing diffing
17:14:10 <augur> hey lispy
17:14:17 <lispy> howdy
17:14:19 <benzrf> i have logs from 2 people that may have gaps and im trying to reconstruct proper logs
17:14:38 <benzrf> but one of them doesnt have dates, so i was thinking id do some kind of programmatic diffing instead of plain old unix diff
17:14:39 <augur> do you happen to know if the .a file that cabal generates can be used in isolation from other files cabal generates?
17:14:45 <qrada__> anyone here experienced with elm-lang?
17:15:12 <lispy> augur: Sorry, never tried
17:15:20 <augur> aww :(
17:16:01 <thenewguy> hey guys. quick question……. if I match (x:xs) on [], how can I test if x is null given that x is an Integer
17:16:12 <lispy> augur: you could use nm to see if it has undefined symbols and ldd to see if it requires other libraries
17:16:26 <glguy> thenewguy: x can't be null if it's an Integer
17:16:28 <lispy> actually, wait ldd should say .a files are non dynamic
17:17:01 <thenewguy> @gulguy is it possible its “nothing” or something like that
17:17:02 <lambdabot> Unknown command, try @list
17:17:45 <thenewguy> i can just not match the pattern there…. or use list@(x:xs) right?
17:17:46 <augur> wowsers lispy i dont know what this means at all :D
17:17:54 <thenewguy> and hten see if null list
17:18:40 <glguy> thenewguy: No, but if it's type was "Maybe Integer" then it might be a "Nothing" or "Just x" where "x :: Integer"
17:18:50 <thenewguy> ahhhh
17:18:51 <thenewguy> cool
17:18:55 <thenewguy> thank you VERY much
17:21:01 <spopejoy>  /msg lambdabot
17:21:44 <spopejoy> :t on
17:21:45 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:22:16 <lispy> :t (==) `on` fst
17:22:17 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
17:22:26 <lispy> So magic!
17:22:49 <lispy> (in the sense that I like how it reads like pseudo english)
17:22:52 <thenewguy> one more random question…. does haskell compile into machine code or into something else and then get JIT compiled?
17:23:04 <thenewguy> just had something run VERY quickly the second time I called it
17:23:11 <lispy> machine code
17:23:15 <thenewguy> interesting
17:23:18 <thenewguy> gracias
17:23:19 <lispy> There is a big run-time that comes with the code
17:26:30 <lispy> thenewguy: that might have been lazy evaluation.
17:26:47 <thenewguy> oh interesting
17:26:52 <lispy> also, ghci does use a bytecode
17:26:57 <thenewguy> ok
17:27:00 <thenewguy> it was in ghci
17:27:39 <thenewguy> so i’m generating primes with a super simple algorithm just to get the hang of these comprehensions and stuff
17:27:48 <thenewguy> so if i’m in ghci
17:27:52 <thenewguy> and i say take 5 primes
17:28:00 <thenewguy> it has to generate 5 primes…… lazyily
17:28:14 <thenewguy> i say take 5 primes again, does it “remember” those or generate them all fresh
17:29:02 <lispy> I don't think ghci can remember, but there might be things it doesn't have to do the second time.
17:29:29 <thenewguy> <listpy> thanks
17:29:34 <lispy> laziness is really about two or more things referencing the same thing and once that referenced thing gets computed it doesn't have to be recomputed.
17:29:34 <thenewguy> <lispy>
17:29:41 <thenewguy> cool
17:29:54 <thenewguy> i have….. no idea how irc works lol. but so far everyone here ro cks
17:30:04 <lispy> > let bigsum = sum [1..1000000] in bigsum + bigsum
17:30:07 <bitemyapp> I am confuzzled by some MVar stuff.
17:30:07 <lambdabot>  1000001000000
17:30:10 <bergmark> if you just type `take 5 primes' it will recalculate the whole thing, if you assign that to a variable it won't have to calculate it several times
17:30:21 <bitemyapp> I have only one take'r and one put'er in a single function.
17:30:27 <thenewguy> gotcha.
17:30:30 <bitemyapp> one other function is reading
17:30:31 <lispy> thenewguy: that bigsum only needs to be computed once in my example
17:30:33 <bitemyapp> https://github.com/bitemyapp/blacktip/blob/master/src/Database/Blacktip.hs
17:30:33 <thenewguy> is there seriously a lambda bot in here ?
17:30:44 <silver> @botsnack
17:30:45 <lambdabot> :)
17:30:47 <bitemyapp> http://i.imgur.com/Adtrtmf.png
17:31:10 <bitemyapp> why does it block indefinitely? it seems the putMVar by initWriter succeeded
17:31:16 <bitemyapp> writeTimestamp is using readMVar
17:31:23 <bitemyapp> I tried it with modifyMVar as well, no dice.
17:31:25 <bitemyapp> same error.
17:31:43 <bergmark> bitemyapp: is there still something that is waiting to read from it?
17:32:02 <bitemyapp> bergmark: there is only one use of takeMVar in the entire library.
17:32:13 <bitemyapp> bergmark: it starts out an emptyMVar
17:32:20 <bitemyapp> https://github.com/bitemyapp/blacktip/blob/master/src/Database/Blacktip.hs#L37
17:32:32 <bitemyapp> generateUniqueId detects the MVar is empty, fires off initWriter
17:32:40 <bitemyapp> initWriter puts the MVar and fires off the timestamp writer.
17:32:43 <bitemyapp> the writer uses readMVar, not take.
17:32:57 <bitemyapp> but the MVar is empty when it gets to the takeMVar.
17:33:12 <bitemyapp> bergmark: I linked my logs (putStrLns) in that imgur.
17:33:40 <bitemyapp> I feel like I must be missing something silly.
17:33:49 <lispy> bitemyapp: what version of base?
17:34:12 <bitemyapp> GHC 7.8.3, I don't know precisely what version of base, 4.7.0.1 I presume.
17:34:14 <bitemyapp> lispy: why?
17:34:40 <lispy> I saw a compatibility note here that talked about readMVar blocking: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent-MVar.html#v:readMVar
17:34:43 <bitemyapp> yeah, 4.7.0.1 in my global package dir.
17:35:03 <bitemyapp> lispy: readMVar blocking isn't a problem.
17:35:39 <bitemyapp> lispy: the problem is a putMVar occurred but the next takeMVar is blocking on an empty MVar indefinitely.
17:35:54 <bitemyapp> but I'll see if I can remove some code to see what happens anyway.
17:36:33 <bitemyapp> yep, if I eliminate starting the timestamp writer (source of the readMVar) it still blocks indefinitely.
17:36:40 <bitemyapp> so it's not that.
17:38:45 <bitemyapp> a manual put in GHCi works fine
17:38:52 <bitemyapp> readMVar doesn't take from the MVar as one would expect.
17:39:00 <bitemyapp> or at minimum, cleans up after itsef.
17:39:02 <bitemyapp> itself*
17:39:05 <lispy> bitemyapp: and if you change the takeMVar to a tryTakeMVar in an infinite loop does it see the value?
17:39:31 <bitemyapp> ew. I can try.
17:41:37 <vanila> http://arxiv.org/pdf/1402.1699v1.pdf lol an academic paper that cites hackage
17:41:41 <bitemyapp> lispy: it keeps getting nothing over and over.
17:42:08 <lispy> Then it's empty :)
17:42:13 * lispy shrug
17:42:14 <bitemyapp> lispy: there should be something *in* the MVar when it reaches the take, initWriter was invoked before-hand
17:43:36 <bitemyapp> "post putMVar initWriter" shows up in stdout
17:43:44 <bitemyapp> it should have done the put by then.
17:44:28 <bitemyapp> huh. It's full immediately after the put, but empty by the time it reaches the take.
17:45:34 <lispy> won't you get a new MVar everytime you run serverState?
17:46:35 <bitemyapp> lispy: oh ffs.
17:46:55 <bitemyapp> lispy: you're probably right.
17:46:59 <bitemyapp> what's the proper way to handle that?
17:47:38 <barrucadu> Create your MVar once and pass it around. You could use Reader to hide it away.
17:47:40 <bitemyapp> newMVar?
17:47:47 <bitemyapp> barrucadu: not going to happen.
17:49:02 <lispy> bitemyapp: http://www.haskell.org/haskellwiki/Top_level_mutable_state
17:49:25 <bitemyapp> lispy: already there.
17:49:49 <lispy> the noinline unsafePerformIO is the simplest and would work here
17:50:01 <bitemyapp> lispy: with newMVar?
17:50:10 <bitemyapp> or emptyMVar?
17:50:11 <lispy> But I prefer barrucadu's suggestion sans Reader.
17:50:13 <bitemyapp> I just wanted an empty one.
17:50:24 <lispy> It shouldn't matter too much which way you create it
17:50:25 <bitemyapp> lispy: it's semantically part of the application that there is a single global serverState.
17:50:32 <lispy> The problem now is that it gets created lots of times
17:50:35 <bitemyapp> lispy: there's only supposed to be one of these running on the entire server.
17:50:56 <bitemyapp> lispy: and what prevents it from re-running the action? unsafePerformIO or no-inline?
17:51:15 <bitemyapp> https://ghc.haskell.org/trac/ghc/ticket/5558
17:51:15 <lispy> @quote readLine
17:51:16 <lambdabot> No quotes match.
17:51:23 <bitemyapp> @quote NOINLINE
17:51:24 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:51:30 <bitemyapp> @quote unsafePerformIO
17:51:31 <lambdabot> mmorrow says: {-# RULES "HAI; CAN HAS STDIO?"  id = unsafePerformIO (system "killall -9 breathingMachine && xeyes &" >> return id)  #-}
17:51:39 <bitemyapp> hrm.
17:52:13 <lispy> bitemyapp: the type `IO (MVar ...)` means that whenever you run severState you get the result of running the action (the empty/new mvar)
17:52:25 <bitemyapp> Right.
17:52:27 <lispy> So the unsafePerformIO changes the type so that it is a top level MVar
17:52:34 <bitemyapp> so binding it will keep firing it off, right
17:52:49 <bitemyapp> lispy: thanks.
17:52:53 <lispy> The noinline is there to make sure ghc doesn't get clever and still make several (by inlining the unsafePerformIOs)
17:53:54 <bitemyapp> lispy: right. Got it.
17:53:56 <bitemyapp> lispy: thanks so much.
17:54:01 <lispy> yw
17:54:05 <bitemyapp> there's my derp for the weekend :)
17:54:18 <bitemyapp> lispy: the code now terminates and breaks in the ways I would expect/hope :)
17:54:22 <lispy> in my experience, you only ever make this mistake once :)
17:54:40 <bitemyapp> lispy: oy vey.
18:07:54 <dmj`> how many characters is a field allowed to be in an algebraic data type
18:08:29 <joe9> I cannot figure out how to wait until the CHLD signal handler has finished (basically block until all children die) http://codepad.org/Z93hzoVk . I cannot get awaitSignal to block. Any suggestions on what I am missing, please?
18:13:31 * hackagebot random 1.0.1.3 - random number library  http://hackage.haskell.org/package/random-1.0.1.3 (CarterSchonwald)
18:21:43 <dmj`> joe9: what ghc and OS are you using?
18:21:55 <dmj`> joe9: https://ghc.haskell.org/trac/ghc/ticket/4504, it looks like this was fixed in 7.0
18:28:28 <joe9> dmj`:  Thanks a lot. http://codepad.org/Wy8iUDTB worked . not sure if it is the correct way of doing it.
18:28:38 <joe9> dmj`: I am using ghc 7.8.3 and linux
18:30:20 <joe9> dmj`: that was a very helpful line. Thanks a lot.
18:34:38 <dmj`> joe9: great! glad it works
18:34:52 <spopejoy> is there a lens dialect for sublists? all i can find is tuples with _2, etc. I have code that is map (map (map ...) ...) ... and it seems like i should get all lensy on it
18:39:01 <dmj`> spopejoy: care to paste your code?
18:42:27 <spopejoy> contrived example:
18:42:41 <spopejoy> > map (map (map (\i -> if (odd i) then i+10 else i))) [[[1,2],[3,4]],[[5,6,7],[8,9,10]]]
18:42:43 <lambdabot>  [[[11,2],[13,4]],[[15,6,17],[8,19,10]]]
18:44:13 <glguy> The lens version will be longer and less clear in this case
18:45:01 <dfeuer> nomeata, another thing that's really a right fold, but not written like one: filterM.
18:45:58 <nomeata> dfeuer: isn’t that true for lots of the fooM functions? E.g. mapM?
18:46:00 <vanila> > (map . map . map) (\i -> if (odd i) then i+10 else i) [[[1,2],[3,4]],[[5,6,7],[8,9,10]]]
18:46:02 <lambdabot>  [[[11,2],[13,4]],[[15,6,17],[8,19,10]]]
18:46:21 <dfeuer> nomeata, I have no idea. Could be!
18:46:30 <glguy_> > [[[11,2],[13,4],[5,6,7],[8,9,10]]] & mapped . mapped . mapped . filtered odd +~ 10
18:46:32 <lambdabot>  [[[21,2],[23,4],[15,6,17],[8,19,10]]]
18:46:35 <nomeata> @src mapM
18:46:36 <lambdabot> mapM f as = sequence (map f as)
18:46:45 <glguy_> That's probably the "full lens" version
18:46:46 <nomeata> well, let’s hope that sequence is a good consumer :-)
18:46:51 <nomeata> @src filterM
18:46:51 <lambdabot> Source not found. My brain just exploded
18:47:22 <dfeuer> nomeata, sequence looks like it is.
18:47:27 <spopejoy> glguy: that's helpful
18:47:41 <nomeata> and mapM is INLINE, so that’s right
18:47:42 <glguy_> and the code above is OK using filtered because +10 preserves being "odd"
18:48:00 <nomeata> so yes, filterM is a good candidate to be writen in a fusable style
18:48:34 <dfeuer> Good.
18:48:40 <johnw>  nomeata: hi!
18:49:25 <nomeata> johnw: hi!
18:49:32 <nomeata> johnw: greetings from DebConf
18:49:55 <estulticia> nomeata: I have a few friends on debconf
18:49:56 <johnw> greetings to you and all of DebConf!
18:50:04 <joe9> dmj`: again, Thank you so much for that. I got it working. I was banging my head for the last 4 hours about this.
18:50:15 <spopejoy> glguy: how do I lensify an arbitrary Int -> Int function in place of "+~ 10" above?
18:50:25 <edwardk> %~ f
18:50:43 <dmj`> joe9: great! glad its working :)
18:50:52 <glguy> Oops I sent that answer from the wrong window
18:51:01 <glguy> %~ f
18:51:10 <dmj`> > [1..10] & ix 3 .~ 99
18:51:12 <lambdabot>  [1,2,3,99,5,6,7,8,9,10]
18:51:21 <johnw> glguy: you have a window where you say things as edwardk?
18:51:35 <edwardk> =P
18:51:47 <edwardk> don't think about it too hard
18:51:59 <Hafydd> Oh my god, my whole life was a liea.
18:52:19 <dfeuer> Huh?
18:53:44 <Hafydd> I thought I had something special with glguy, but it was just edwardk.
18:54:05 <Hafydd> At least there's still ekmett.
18:54:14 <edwardk> =P
18:54:28 <johnw> maybe we're all edwardk, we just rotate amongst ourselves
18:54:43 <nomeata> that would be, edwardk
18:54:45 <nomeata> eh
18:54:46 <nomeata> awkward
18:54:47 <johnw> all you really need to do to simulate edwardk is drink enough diet coke
18:55:13 <johnw> it's reminds me of the mentats drinking their juice in Dune
18:55:20 <edwardk> after enough caffeine it all starts to blur together
18:55:22 <johnw> the juice of safu
18:55:42 <johnw> edwardk starts his coding by saying, "And now I set my mind in motion."
18:58:32 <dfeuer> nomeata, foldM!
18:58:58 <copumpkin> mokus: you around?
18:59:17 <MorpheusBeing> question - how can I get lambdabot running in another room?
18:59:59 <dfeuer> MorpheusBeing, download lambdabot, install it on your server, and follow the instructions? Just a guess.
19:00:21 <carter> MorpheusBeing: or ask int-e  to add it
19:00:29 <carter> if youw ant the one true lambdabot primary
19:01:05 <MorpheusBeing> ok
19:01:21 <MorpheusBeing> About to organise a vps and want it in a special room
19:03:37 * hackagebot xml-pipe 0.0.0.11 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.11 (YoshikuniJujo)
19:03:54 <dfeuer> nomeata, these higher order folds confuse me. I *think* foldM is a right fold, but I'm not really sure yet.
19:03:55 <splintax> i don't want to discourage you but there was a person in here who was having trouble building lambdabot all last week :P
19:04:33 <shachaf> foldM is a left fold.
19:04:44 <shachaf> "left" and "right" is typically confusing terminology anyway.
19:05:41 <dfeuer> shachaf, of course you're right.
19:08:32 <dfeuer> Actually, shachaf, I'm not quite seeing that. It looks like a weird left/right hybrid thing going on.
19:08:39 <dfeuer> Reminiscent of scanl.
19:08:47 <dfeuer> But I could be wrong.
19:09:52 <shachaf> See http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#v:foldM
19:10:08 <shachaf> > foldl f z [a,b,c,d] -- and compare
19:10:09 <lambdabot>  f (f (f (f z a) b) c) d
19:11:04 <nomeata> dfeuer: as a rule of thumb: if it has an accumulating parameter, it is a left fold
19:11:48 <shachaf> > runIdentity $ foldM (\x y -> Identity (f x y)) z [a,b,c,d]
19:11:50 <lambdabot>  f (f (f (f z a) b) c) d
19:12:28 <dfeuer> nomeata, maybe I am confused, but the accumulation seems to happen in the monad (from left to right) but the monad looks like it gets build from right to left. Or am I crazy?
19:13:18 <shachaf> I don't know what it means for a monad to get built.
19:13:32 <nomeata> dfeuer: not at all
19:13:39 <nomeata> dfeuer: (not at all crazy)
19:13:55 <spopejoy> how does one hoogle un-hoogled packages, namely lens? ix, ~+ don't come up
19:14:02 <nomeata> dfeuer: the argument function is left-folded over the list, but the monadic effect is, in a sense, a right fold
19:14:44 <shachaf> spopejoy: Try Hayoo.
19:14:46 <shachaf> @where hayoo
19:14:47 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
19:14:47 <dfeuer> The immediate question is whether it can actually be *written* using foldr or foldl.
19:15:00 <shachaf> Everything can be written using foldr.
19:15:36 <dfeuer> Hahahaha.
19:15:40 <dfeuer> Yes, this is true.
19:15:47 <platz> maybe I should make a docker image which just has lambdabot installed
19:17:57 <shachaf> Hm, that wasn't especially intended to be funny...
19:19:17 <dfeuer> shachaf, what was it intended to be, then?
19:39:48 <vanila> How do I do a mutable cell store like the ST monad, but be able to roll back a whole bunch of changes if an exception occurs?
19:44:05 <dfeuer> vanila, I'm sure it depends on just what you mean. State is better than ST for that sort of thing, I would think.
19:44:24 <vanila> I can't do this with state though because i need a store that has mutable variables of different types
19:46:26 <carter> vanila: hrmm
19:46:31 <carter> vanila: STM kinda does that
19:46:59 <carter> vanila: so you want to take a snap shot in a godo state
19:47:29 <benzrf> hey
19:47:43 <benzrf> is there something like Data.Algorithm.Diff that works on arbitrary streams
19:48:03 <carter> benzrf: like you have two streams over some alphabeta?
19:48:03 <benzrf> i want to do parsing on diffing on files with hundreds of thousands of lines and regular lists are not too great for that
19:48:11 <carter> hrm
19:48:14 <carter> Ropes!
19:48:17 <benzrf> Data.Algorithm.Diff works on [] i mean
19:48:19 <carter> ah
19:48:26 <carter> benzrf: probably you want Lazy Text?
19:48:32 <benzrf> uhhhhhh
19:48:32 <carter> or Vector Char?
19:48:37 <benzrf> im not sure that's the problem
19:48:38 <carter> hrmm
19:48:56 <benzrf> the problem is loading a hundred thousand lines into memory and trying to list-operate on it
19:49:06 <benzrf> i think a pipe might be good for this
19:49:13 <carter> benzrf: ooo
19:49:14 <benzrf> but like i said, Data.Algorithm.Diff works on lists, not pipes
19:49:23 <carter> rolling hashes
19:49:30 <benzrf> rolling hashes?
19:49:35 <carter> @google rolling hash
19:49:36 <lambdabot> http://en.wikipedia.org/wiki/Rolling_hash
19:49:36 <lambdabot> Title: Rolling hash - Wikipedia, the free encyclopedia
19:49:55 <carter> benzrf: its a neat way to detect when you have possibly identical chunks
19:50:06 <carter> thats robust against shifting the text
19:50:23 <benzrf> basically i have two yearlong irc logs from 2 people of the same channel
19:50:31 <benzrf> and im trying to fill in the gaps in each other and normalize the format
19:50:35 <benzrf> hence diff
19:50:36 <carter> ah
19:50:38 <carter> neat
19:50:51 <carter> @google patience diff haskell
19:50:52 <lambdabot> https://hackage.haskell.org/package/patience
19:51:06 <carter> hrmm
19:51:08 <carter> but on lists
19:51:19 <benzrf> yeah
19:51:19 <carter> benzrf: so 1 year of IRC logs is like, < 10mb right?
19:51:32 <benzrf> theyre both 34NM
19:51:35 <benzrf> * 34M
19:51:42 <carter> ok
19:51:54 <benzrf> 608669 lines in one, 524145 in the other
19:52:00 <benzrf> they have slightly different time frames
19:52:01 <carter> so if this is a one off thing, doing the dumb thing is fine
19:52:18 <carter> make it a list of lines
19:52:21 <benzrf> i tried
19:52:21 <carter> where you've normalized all the lines
19:52:22 <benzrf> i did
19:52:23 <carter> ah
19:52:28 <carter> which package did you use?
19:52:33 <benzrf> log <- lines <$> readFile "thelog"
19:52:36 <benzrf> then i tried `length log'
19:52:40 <benzrf> and my comp slowed down
19:52:45 <benzrf> while it hung
19:52:48 <carter> hrm
19:52:50 <carter> ah
19:52:55 <carter> readFile does lazy io
19:52:58 <benzrf> oh
19:52:59 <carter> right?
19:53:01 <benzrf> yeah
19:53:14 <carter> load it as one big ole Data.Text chunk
19:53:16 <athan> Hey guys, dumb question: Is there a class like Applicative but only with `pure`, and no `ap`?
19:53:29 <carter> athan: kinda, but its boring
19:53:41 <athan> carter: ): What's it called?
19:53:45 <carter> i think Point
19:53:48 <carter> but it doesn't exist
19:53:51 <carter> at least in base
19:53:54 <athan> semiobdufactiveendomedachanicuoid?
19:53:59 <carter> athan: whats the actual goal
19:54:06 <carter> athan: tell us the actual goal
19:54:06 <benzrf> pure is mostly interesting for how it interacts with ap and bind
19:54:08 <benzrf> er, join
19:54:12 <geekosaur> Pointed, but it was never implemented because it does nothing useful
19:54:15 <athan> carter: Something lame haha. Just to wrap & unwrap
19:54:26 <carter> athan: have you considered just using newtype?
19:54:27 <benzrf> athan: no need for a typeclass
19:54:30 <athan> yeah I thought so
19:54:35 <geekosaur> it is probably discussed in the Typeclassopedia
19:54:39 <benzrf> athan: have the caller pass in a wrapping func
19:54:50 <benzrf> @hoogle FileName -> IO Text
19:54:51 <athan> I just like purpose-oriented vocabulary, sorry :)
19:54:52 <lambdabot> Warning: Unknown type FileName
19:54:53 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
19:54:53 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
19:54:58 <benzrf> @hoogle Strin -> IO Text
19:54:58 <lambdabot> Warning: Unknown type Strin
19:54:59 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
19:54:59 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
19:55:00 <benzrf> @hoogle String -> IO Text
19:55:01 <lambdabot> Data.Text.Lazy.IO readFile :: FilePath -> IO Text
19:55:01 <lambdabot> Data.Text.IO readFile :: FilePath -> IO Text
19:55:01 <lambdabot> Prelude readIO :: Read a => String -> IO a
19:55:03 <benzrf> aha
19:55:22 <athan> thanks guys
19:56:44 <benzrf> diff vs patience
19:56:46 <benzrf> whats the difference
19:56:48 <benzrf> :y
19:56:59 <athan> Actually, if this makes it clearer: It's a unary-polymorphic product type that I'm trying to make default values for
19:58:21 <carter> benzrf: patience diff tries to batch matching a bit
19:58:22 <carter> i forget
19:58:33 <carter> benzrf: but looks like you can lines your text chunks and runn patience
19:58:36 <carter> assuming the line format is the same
19:58:41 <carter> and time stamps are compatible
19:58:47 <vanila> carter, I'm looking into STM and I wonder how I could do that snapshop thing? I made an example of what sort of thing I want to do http://lpaste.net/109960 -- I'd like to take a snapshot before starting test2, and it if fails (gives Nothing) undo those writes
19:58:47 <carter> benzrf: actually
19:59:37 <athan> Is there a language extension that lets you define infix operators like -- x `foo` y = ...?
20:00:07 <carter> athan: try `foo`
20:00:12 <carter> :)
20:00:22 <carter> it actually works afaik
20:00:33 <geekosaur> > let x `foo` y = x + y in 5 `foo` 3
20:00:34 <athan> carter: I did in ghci! It pooped
20:00:35 <lambdabot>  8
20:00:44 <carter> athan: try harder
20:01:01 <carter> vanila: i think thats called "make the stm action fail"
20:01:05 <Hafydd> Does it allow x `f` y z = ...?
20:01:07 <vanila> ooh
20:01:08 <vanila> ok
20:01:17 <Hafydd> Wait, that doesn't make sense.
20:01:17 <carter> Hafydd: sure
20:01:23 <carter> infix totes allows that
20:01:35 <Hafydd> (x `f` y) z, it should be, and that doesn't really work.
20:02:02 <vanila> how do I make stm fail?
20:02:04 * athan $ determination
20:02:10 <athan> It's super effective
20:02:14 <carter> > let  x `f` y z =  x+ y +z  in 1 `f` 3 4
20:02:16 <lambdabot>  <hint>:1:12: Parse error in pattern: y
20:02:20 <carter> ok
20:02:30 <carter> > let  f x ` y z =  x+ y +z  in 1 `f` 3 4
20:02:31 <lambdabot>  <hint>:1:14: parse error on input ‘z’
20:02:39 <carter> > let  f x ` y z =  x+ y +z  in 1 `f` 3  $ 4
20:02:40 <lambdabot>  <hint>:1:14: parse error on input ‘z’
20:02:52 <carter> > let  f x  y z =  x+ y +z  in 1 `f` 3   4
20:02:54 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
20:02:54 <lambdabot>    arising from the ambiguity check for ‘e_1134’
20:02:54 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
20:02:54 <lambdabot>                    GHC.Num.Num a1,
20:02:54 <lambdabot>                    GHC.Num.Num a)
20:02:58 <carter> > let  f x  y z =  x+ y +z  in 1 `f` 3  $ 4
20:02:59 <lambdabot>  8
20:03:24 <vanila> I guess I'll use always and return false
20:03:44 * hackagebot spice 0.3.3.2 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.3.2 (Crockeo)
20:06:15 <NemesisD> what would loosening a version upper bound on the base package necessitate as far as the PVP?
20:06:42 <carter> NemesisD: that it works? :)
20:06:45 <NemesisD> seems like it would be minor version, C in A.B.C
20:07:01 <carter> ohhh
20:07:02 <carter> well
20:07:03 <NemesisD> i mean as far as bumping my version
20:07:03 <vanila> no i dont see how
20:07:16 <carter> NemesisD: relaxing your bounds can never break anyone elses bounds
20:07:23 <carter> unless they're not following PVP :)
20:07:34 <NemesisD> so then update D?
20:07:40 <carter> well
20:07:43 <carter> yeah
20:07:52 <carter> unless the PVP has something to say on this
20:08:31 <NemesisD> it says Note that modifying imports or depending on a newer version of another package may cause extra non-orphan instances to be exported and thus force a minor version change.
20:08:49 <NemesisD> i guess conceivably a base upgrade could create new instances to export
20:09:00 <monochrom> vanila: STM is an instance of MonadPlus, perhaps mzero is the failure you want. It's also an instance of Alternative, so empty should do the same.
20:10:04 <vanila> thanksv ery much monochrom that works perfect
20:16:59 <athan> wtf... cabal repl isn't repl-ing
20:17:12 <carter> how so?
20:17:15 <carter>  it is a relatively new feature
20:17:16 <athan> it's just telling me "Preprocessing library leap-0.1.0.0..." then going back to the shell :/
20:17:29 <carter> @hackage leap
20:17:29 <lambdabot> http://hackage.haskell.org/package/leap
20:17:37 <athan> o.o
20:17:38 <carter> i dont see such a lib
20:17:48 <athan> oh, that's my lib
20:17:51 <carter> ah
20:17:53 <athan> not on hackage
20:17:58 <carter> hah
20:17:59 <carter> well
20:18:02 <athan> i didn't host it on hackage
20:18:13 <athan> :S
20:18:31 <athan> ! exposed modules, maybe? :D
20:19:14 <athan> yep, that was it
20:19:16 <athan> sorry
20:20:07 <carter> is :P
20:20:09 <carter> :)
20:20:46 <athan> carter: infix operators are failing still :/
20:20:51 <gcganley> does anyone know a way i can hoogle something from emacs?
20:21:08 <carter> athan: i can't help things that don't @lpaste links
20:21:09 <carter> or something
20:21:16 <athan> > let a `/?` b = (a `mod` b) == 0
20:21:18 <lambdabot>  <hint>:1:8: parse error on input ‘/?’
20:21:23 <athan> ahh
20:21:27 <carter> athan: symbols are always infix
20:21:34 <carter> its alphanum stuff that needs ``
20:21:50 <carter> > let a /? b = (a `mod` b) == 0
20:21:50 <athan> carter: symbols?
20:21:51 <lambdabot>  not an expression: ‘let a /? b = (a `mod` b) == 0’
20:22:06 <carter> @#@$%^&*-=
20:22:07 <lambdabot> Unknown command, try @list
20:22:10 <athan> lol
20:22:20 <carter> !@#$%^&*_+=-
20:22:24 <carter> those are symbols
20:22:26 <carter> mofo
20:22:27 <carter> :)
20:22:36 <athan> > let a {:D} b = (a `mod` b) == 0
20:22:38 <lambdabot>  <hint>:1:8: parse error on input ‘:’
20:22:41 <athan> damn
20:22:57 <carter> athan: you can't mix symbosl and alphanum
20:23:02 <carter> and {} aren't symbols
20:23:08 <carter> they're block delimiters
20:23:09 <athan> :O~!
20:23:14 <athan> hmm
20:23:19 <carter> @google Haskell 2010 grammar
20:23:19 <lambdabot> https://www.haskell.org/onlinereport/haskell2010/
20:23:23 <benzrf> @hoogle String -> Text
20:23:24 <lambdabot> Data.Text.Lazy pack :: String -> Text
20:23:24 <lambdabot> Data.Text pack :: String -> Text
20:23:24 <lambdabot> Prelude read :: Read a => String -> a
20:23:30 <carter> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
20:23:56 <athan> I'll make it (%=)
20:24:01 <athan> thanks carter :)
20:24:47 <carter> that might clash with lens if your'e using lens
20:24:51 <carter> but otherwise go crazy
20:25:01 <Iceland_jack> @let a ∣ b = (b `mod` a) == 0
20:25:03 <lambdabot>  Defined.
20:25:05 <Iceland_jack> > 3 ∣ 15
20:25:07 <lambdabot>  True
20:25:49 <athan> carter: ~~:O~~ GET WIGGLEY
20:25:52 <t4nk303> how to convert from [(1,["aa","bb","cc"]), (2,["aa","bb","cc"]), (3,["aa","bb","cc"])] to [(1,("aa,bb,cc")), (2,("aa,bb,cc")), (3,("aa,bb,cc"))]
20:26:07 <carter> athan: that mixes things
20:26:08 <carter> :P
20:26:16 <athan> Iceland_jack: !
20:26:28 <carter> t4nk303: intercalate
20:26:29 <carter> or whatever
20:26:35 <glguy> ?type intercalate ","
20:26:36 <lambdabot> [[Char]] -> [Char]
20:26:44 <carter> ok, so not quite that :)
20:26:50 <carter> oh
20:26:52 <carter> yes that
20:26:53 <carter> :)
20:27:18 <carter> glguy: ++
20:27:26 <Iceland_jack> ‘intercalate’ and ‘intersperse’ are the few functions that always trip me up
20:27:30 <athan> Wait a tic... does a --------------------- block delimit scopes?
20:27:48 <carter> athan: whats the standard say?
20:27:56 <glguy> ?type over _2 (intercalate ",") [(1,[" an","CD"])]
20:27:58 <lambdabot> (Field2 [(t1, [[Char]])] t [[Char]] [Char], Num t1) => t
20:27:58 <athan> :(
20:28:15 <glguy> I didn't mean to? Type that
20:28:21 <athan> carter: Hold on let me get my cane
20:28:24 <glguy> Phone keyboard
20:28:47 * hackagebot phash 0.0.3 - Haskell bindings to pHash, the open source perceptual hash library  http://hackage.haskell.org/package/phash-0.0.3 (MichaelXavier)
20:29:10 <carter> i always forget what michael's irc handle is
20:31:34 <t4nk303> how to convert from [(1,["aa","bb","cc"]), (2,["aa","bb","cc"]), (3,["aa","bb","cc"])] to [(1,("aa,bb,cc")), (2,("aa,bb,cc")), (3,("aa,bb,cc"))] [23:26] <carter> athan: that mixes things
20:32:27 <carter> t4nk303: map \x -> (fst x, map (intercalate ",") $ snd  )
20:32:48 <benzrf> how do i use Parsec on Data.Text
20:33:04 <glguy_> Anyone know what the shortest distance between a Haskell program and capturing a still image from my webcam on OS X is?
20:33:55 <Iceland_jack> > [ (i, intercalate "," j) | (i, j) <- [(1,["aa","bb","cc"]), (2,["aa","bb","cc"]), (3,["aa","bb","cc"])] ] -- also
20:33:57 <lambdabot>  [(1,"aa,bb,cc"),(2,"aa,bb,cc"),(3,"aa,bb,cc")]
20:34:23 <glguy_> benzrf: You just give the "parse" function a Text to parse
20:34:32 <glguy_> benzrf: There is a Stream instance for Text
20:34:44 <benzrf> oh
20:34:47 <glguy_> parsec knows how to extract Char from Text
20:34:48 <benzrf> i didnt have it imported :o
20:35:28 <dmj`> > [ (n, (x,y,z)) | (n, [x,y,z]) <- [(1,["aa","bb","cc"])] ]
20:35:30 <lambdabot>  [(1,("aa","bb","cc"))]
20:36:02 <bobert> hello
20:36:43 <carter> bobert: WELCOME
20:37:02 <bobert> im using this webchat.freenode site
20:37:05 <bobert> its nice
20:37:13 <carter> hrmm
20:37:21 <bobert> no more seperate irc client
20:37:30 <bobert> just use a tab per channel
20:37:30 <carter> i wonder how long till someone uses ghcjs to write a browser based irc client
20:37:55 <bobert> hmm
20:38:01 <bobert> they might use yesod
20:38:07 <bobert> or elm
20:38:12 <carter> yesod or snap don't build on ghcjs yet I think
20:38:13 <carter> i looked
20:38:20 <bobert> i really like elm
20:38:59 <bobert> so yesod and snap dont compile to JS?
20:39:09 <bobert> you have to write the JS by hand?
20:39:14 <dolio> You wouldn't want that anyway, would you?
20:39:31 <dolio> You don't compile the web server into code that you run on the client.
20:40:10 <t4nk303> thanks carter and Iceland_jack
20:40:30 <carter> yeah, you don't need a server
20:40:38 <carter> t4nk303: go forth and hack merrily
20:41:00 <bobert> you  just need the client
20:41:13 <bobert> to connect to irc
20:41:21 <bobert> what port is irc usually?
20:41:35 <carter> depends on the server
20:42:13 <dmj`> bobert: 6667
20:45:13 <bobert> i personally like the use of tabs for different channels
20:45:48 <carter> cool
20:46:03 <danneu> Noob question: i want to build a sequence of user-input integers from stdin until they input 0. in clojure i would do something like (take-while (comp not-zero? parse-int) (repeatedly read-line)). my effort so far `putStrLn $ show $ takeWhile (/="0") (? getLine)`
20:46:13 <bobert> simplicity
20:46:40 <bobert> how good is ghcjs?
20:47:01 <dolio> danneu: You could use interact and lines.
20:47:06 <bobert> to me it seems like it will be a subset of haskell that has its own problems
20:47:43 <danneu> dolio: thanks
20:48:35 <dolio> There are probably other libraries that would make it look more similar to the clojure version, but I don't know them.
20:48:46 <johnw> danneu: mapM_ putStrLn $ takeWhile (/= "0") . lines . getContents
20:48:46 <dolio> And for this particular problem, they're probably overkill.
20:49:05 <carter> bobert: ghcjs is full haskell
20:49:06 <johnw> oops, =<< getConents
20:49:11 <carter> the only think it lacks is c ffi powers
20:49:12 <merijn> danneu: You probably want to use some form of recursion to repeatedly query getLine "foo = do { x <- getLine; print x; when (x /= 0) foo }"
20:49:12 <johnw> and use parens instead of $
20:49:19 <carter> because its a pain to compiler C to js
20:49:38 <bobert> to compiler
20:49:48 <carter> ?
20:49:49 <merijn> bobert: ghcjs supports every extension and library that GHC does (minus those that require linking C code, obviously)
20:49:54 <bobert> type error
20:50:22 <bobert> expected verb: actual noun
20:50:38 <merijn> johnw: Won't getContents ruin your ability to read stuff from stdin later?
20:50:47 <carter> natural language is way more plastic than comptuer language
20:50:51 <johnw> I didn't realize that was a requirement, sure it will
20:51:00 <bobert> plastic?
20:51:11 <carter> malleable
20:51:13 <carter> flexible
20:51:19 <bobert> oh i see
20:59:30 <danneu> merijn: yeah, that sounds kinda like my first attempt https://gist.github.com/danneu/fa0d6c70f2b806de695c, but my friend told me it was distant from the Haskell Way
21:00:24 <johnw> that code snippet really isn't that horrible
21:00:44 <johnw> it's clear to read, and does job
21:01:14 <Ralith> you could conceivably write it in a clever little oneliner
21:01:36 <Ralith> the only way that could be haskellier would be factoring out the IO, though, really
21:01:43 <johnw> (takeWhile (/= "0") . lines) <$> getContents >>= mapM_ putStrLn
21:01:53 <johnw> but it doesn't prompt, or interact with the user
21:02:18 <johnw> or maybe doing it with pipes
21:03:01 <dmj`> forever $ readMaybe <$> getLine >>= \(x :: Maybe Int) -> Data.Foldable.forM_ x print
21:03:09 <dmj`> @typ forever $ readMaybe <$> getLine >>= \(x :: Maybe Int) -> Data.Foldable.forM_ x print
21:03:10 <lambdabot> Not in scope: ‘readMaybe’
21:06:59 <Ralith> of course, you should add error handling
21:07:14 <solatis> for the ones that missed it, i found this article to be incredibly informative: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
21:07:22 <solatis> "Using Emacs for Haskell development"
21:07:25 <dmj`> readMaybe is the magic
21:14:41 <t4nk303> how to print in a tabular format in haskell?
21:15:37 <dmj`> t4nk303: like display a grid in the terminal like using mysql from the command line?
21:16:38 <dmj`> like this? http://0.s3.envato.com/files/367024.png
21:17:02 <dmj`> or do you mean like creating csv or excel files?
21:18:22 <t4nk303> ya like the png
21:19:12 <t4nk303> cause the columns have varying length row vaules and are not aligned properly
21:19:19 <dmj`> I wrote some code to do that a long time ago, it was ugly, but it worked
21:19:50 <t4nk303> i tried using \t but no luck as the values are not of same length
21:20:51 <t4nk303> i don't want the fancy lines. I just need the columns aligned
21:22:20 <dmj`> yea its complicated
21:22:35 <dmj`> https://github.com/dmjio/adhocdb/blob/master/Data.hs the showTable function does it, but its quite unreadable
21:23:40 <triliyn> t4nk303: you might look into https://hackage.haskell.org/package/boxes
21:24:04 <splintax> omg why did it take me so long to find this diagram http://www.haskell.org/haskellwiki/File:Typeclassopedia-diagram.png
21:25:59 <dmj`> t4nk303: this might interest you: http://jtdaugherty.github.io/vty-ui/
21:26:13 <stalintrotsky> should mapM_ writeChan be writing each value in a [a] individually into a Chan a?
21:27:35 <merijn> stalintrotsky: assuming you partially applied writeChan with a Chan, yes
21:27:50 <stalintrotsky> oh yeah, that's what I meant, it has a . in my code
21:27:55 <benzrf> :t ($>)
21:27:57 <lambdabot>     Not in scope: ‘$>’
21:27:57 <lambdabot>     Perhaps you meant one of these:
21:27:57 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
21:27:58 <benzrf> huh
21:28:05 <johnw> do you mean <$?
21:28:32 <benzrf> yea
21:28:40 <benzrf> but i had a thing where ($>) didnt error
21:28:48 <johnw> i think it's in lens
21:28:54 <johnw> $>, that is
21:29:49 <glguy_> Not that I know of
21:30:05 <dmj`> stalintrotsky: mapM_ writeChan :: [Chan a] -> a -> (), it expects a list of chans... so I think you want:
21:30:09 <dmj`> \vals chan -> Control.Monad.forM_ vals $ writeChan chan
21:30:16 <johnw> it's in comonadand semigroupoids
21:30:18 <dmj`> :: [a] -> Chan a -> IO ()
21:30:22 <benzrf> yeah but i dont have lens importd
21:30:33 <glguy_> lens has <&>, but not $>
21:30:42 <johnw> right, I misremembered
21:32:20 <splintax> how do i read "<*>"?
21:32:35 <glguy_> very carefully
21:32:38 <benzrf> splintax: by focusing your eyes on it
21:32:44 <stalintrotsky> would mapM_ . writeChan be correct too?
21:32:51 <glguy_> It doesn't have an official name
21:32:52 <dmj`> splintax: apply a function in a lifted context to a value in the same lifted context
21:33:24 <dmj`> stalintrotsky: yes
21:33:26 <splintax> by the sapir-whorf hypothesis i can't understand it properly unless i have a short word i can use to mentally pronounce it
21:33:26 <dmj`> mapM_ . writeChan :: Chan a -> [a] -> IO ()
21:33:47 <dmj`> > pure (+1) <*> (Just 1)
21:33:48 <lambdabot>  Just 2
21:33:53 <stalintrotsky> I'm still having some trouble, I think it's related to a different part, I have the relevant code in http://lpaste.net/109961
21:33:55 * hackagebot oo-prototypes 0.1.0.0 - Support for OO-like prototypes  http://hackage.haskell.org/package/oo-prototypes-0.1.0.0 (MateuszKowalczyk)
21:34:42 <stalintrotsky> I have a thread reading the other end of the channel and sending websocket messages, and if I do it multiline instead of separate calls to send it will only send the first line
21:35:28 <dmj`> stalintrotsky: the type of send expects an argument, but your signature is just a state, should send be [String] -> StateT Bot IO
21:35:29 <stalintrotsky> also I wrote the type wrong
21:35:31 <stalintrotsky> yeah
21:35:44 <stalintrotsky> I didn't have the explicit annotation because it was a class function
21:36:07 <splintax> i guess i can think of it as "applicative fmap". a functor has a way to map functions, an applicative functor has a way to map applicative functions
21:36:08 <stalintrotsky> I mean I didn't write it in and was too lazy to go find it
21:37:03 <pjdelport> splintax: You can think of <*> as lifted function application (as in, pure function application that's been lifted into the functor)
21:37:23 <pjdelport> splintax: That is in fact quite literally what it is: (<*>) = liftA2 ($)
21:37:33 <pjdelport> :t ($)
21:37:35 <lambdabot> (a -> b) -> a -> b
21:37:40 <pjdelport> :t (<*>)
21:37:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:37:43 <stalintrotsky> the actual type is String -> StateT Bot IO
21:38:12 <pjdelport> splintax: So that's why <*> chains just like pure function applications chains, for example.
21:39:21 <pjdelport> splintax: And why laws like like  pure (f a b) == pure f <*> pure a <*> pure b  hold.
21:39:52 <MorpheusBeing> Help - what is syntax to get lambdabot to join another room on freenode?
21:40:01 <dmj`> send s = messChan <$> get >>= \chan -> liftIO (writeLinesToChan chan (T.lines . T.pack $ s))
21:40:07 <dmj`> stalintrotsky: ^
21:40:18 <splintax> pjdelport: ah that's kind of cool. since * is like $ lifted four keys to the right ... ;)
21:40:24 <pjdelport> MorpheusBeing: You'll probably have to petition whoever admins it.
21:40:37 <splintax> and also gives some insight into the <$> operator
21:40:59 <MorpheusBeing> hmm, have tried the simple example from github, but no success. thanks for answer
21:41:09 <pjdelport> splintax: Yup; f <$> x == pure f <*> x of course.
21:41:29 <splintax> i don't think i really like using infix notation for ... non-endomorphic? functions
21:41:52 <mcbears> hm, is there a way to instantiate type variables in ghci? being able to see the specific case of a type signature might help beginners trying to figure out what, say, ((->) r)'s fmap is supposed to do
21:42:12 <mcbears> without doing it in your head and testing to see if the annotation is right
21:42:27 <splintax> for me infix operators weakly imply that the arguments are of the same type, and even commutative
21:42:39 <stalintrotsky> is doing T.lines after T.pack faster than doing lines before T.pack?
21:43:07 <dmj`> stalintrotsky: not using String at all is fastest
21:43:40 <dmj`> statlintrotsky: if you're receiving input do it with Bytestring, then convert to Text via T.decodeUtf8
21:43:53 <glguy> Splintax: you'll have to get over that, then ^_^
21:43:55 <stalintrotsky> alright, thanks
21:43:56 <pjdelport> splintax: Yeah, <*> deserves more emphasis than <$>. "pure f <*> x" makes it a lot more obvious that you can equally do things like "f <*> pure x", for example.
21:43:57 <dmj`> Data.Text.Encoding.decodeUtf8
21:44:29 <glguy> Because there are lots of cases of common operators where it's not true
21:45:54 <stalintrotsky> I'm still having the same issue with only the first message being sent, not sure how that's happening
21:46:09 <geekosaur> I find myself wondering what splintax thinks of c++
21:46:42 <geekosaur> (I'm thinking of >> on [io]streams)
21:47:03 <geekosaur> rather >> on istream and << on ostream
21:47:14 <stalintrotsky> oh, I see what's wrong
21:48:30 <stalintrotsky> it was something in another module, I have to prepend the messages with something and breaking it up like that ruined it
21:48:46 <stalintrotsky> I'll try to refactor Text into other portions of the code too, so it runs faster
21:49:32 <splintax> geekosaur: i find it hard to read! also that exact thing confused the heck out of me when i tried to learn c++ as a first language as a teenager
21:50:47 <splintax> just to understand hello world requires you to confront the ideas of streaming IO and stdin/out/err
21:52:28 <dmj`> stalintrotsky: how are you getting the data to write to the channel?
21:53:39 <kristof> splintax: odd first language :P
21:54:32 <splintax> agreed, it made me think that i just wasn't smart enough to 'get' programming until i discovered python
21:55:22 <splintax> i never really thought of asking for advice though and C++ has a catchy name, it's like the canonical programming language amongst non-programmers
21:56:16 <stalintrotsky> the data depends
21:56:34 <stalintrotsky> sometimes it comes from an acid-state database, sometimes it comes from the server
21:56:57 <stalintrotsky> sometimes it's a constant in the code
21:57:19 <dmj`> I thought I was the only one who used acid-state :)
21:58:33 <dmj`> stalintrotsky: ok, if from stdin or a tcp socket I was going to recommend using io-streams
21:59:33 <dmj`> stalintrotsky: what is your project for? Just curious
22:00:24 <dmj`> brb
22:01:18 <stalintrotsky> It's a chatbot for pokemon showdown
22:02:04 <spopejoy> i'm trying to be a good fold-er and always foldr but foldl seems necessary in particular cases.
22:02:05 <luite> DD
22:02:07 <luite> oops
22:02:21 <stalintrotsky> https://github.com/raymoo/pins-ps is the repo
22:02:24 <stalintrotsky> readme is outdated
22:02:49 <spopejoy> namely, in a concatMap-style effort, but where you interpolate with recursive calls to the foldl function.
22:03:11 <spopejoy> should i be avoiding foldl like the plague?
22:19:27 <augur> if i compile a library with cabal, it spits out a .dylib and a .a
22:19:45 <augur> what do i need to do to now use this lib in C?
22:20:27 <coppro> augur: -l against the .a
22:20:47 <augur> coppro: -l?
22:21:15 <augur> in the compiler, you mean? suppose im using Xcode
22:21:41 <coppro> yes
22:21:56 <coppro> I don't know how to configure compile flags in Xcode
22:22:09 <augur> ok
22:22:14 <coppro> the .dylib is the shared library, which you also ought to be able to link against
22:22:46 <augur> do i need to use it? im not sure what i need to use for this
22:25:35 <coppro> same as any library, use either the static library or the dynamic one
22:25:51 <coppro> you shouldn't need both, which one to use is preference. I don't know the default on OSX, but I imagine it's to use the dynamic
22:25:55 <augur> does it matter which i want?
22:26:49 <copumpkin> Mac OS, outside of GHC, almost never uses static linkage
22:27:10 <augur> whats the difference, in principle?
22:27:51 <copumpkin> point to a different file, or make one monolithic file that contains all dependencies
22:28:35 <dobblego> @type optional
22:28:36 <lambdabot> Alternative f => f a -> f (Maybe a)
22:29:33 <coppro> augur: when you make an executable binary, you need to include all the symbols (functions & variables) in the final product. A static library does this at compilation time. A dynamic library does it at run time.
22:29:44 <augur> copumpkin: if i use the dynamic lib, what does it look for?
22:30:28 <coppro> For a dynamic library to work, you need to have a copy around at run time, but it reduces duplication as you then need only one copy of the library on the system, and many different binaries can make use of it. It also means that they can be upgraded to use new libraries just by swapping them out, rather than recompiling.
22:30:32 <augur> like, what beside the .dylib do i need to include in the project? the whole dist directory?
22:31:33 <merijn> I forget, did we have first-class patterns yet?
22:31:34 <augur> oh, well, im just looking to make a pre-compiled library thats going to be used to back up a larger library
22:31:49 <merijn> i.e. patterns I can pass to a function and then match on?
22:31:55 <augur> so i dont need to link to the haskell library from multiple places
22:33:33 <coppro> augur: dylib and headers
22:33:56 <augur> coppro: of which files? all of them?
22:34:10 <coppro> only any API you intend to use from C
22:34:22 <coppro> the headers are just so that you have correct prototypes of the C functions and such
22:34:30 <augur> ok. i collected all of the API stuff into one file
22:35:26 <coppro> and of course this header would have nothing to do with the Haskell source
22:39:19 <MorpheusBeing> Question re lambdabot - is it possible to change the "@" for command prefix to another symbol?
22:39:42 <solatis> :t @
22:39:43 <lambdabot> parse error on input ‘@’
22:40:07 <solatis> too bad it's not self-aware yet
22:40:46 <MorpheusBeing> Trying to use in another location with other software where "@" is used for another purpose
22:41:40 <MorpheusBeing> I have connected to #retroshare which bridges via a bot to retroshare-irc chat lobby.
22:41:56 <lispy> I don't think it's configurable via a config file but you could change the source
22:42:13 <c_wraith> source is just the authoritative config file anyway
22:42:33 <lispy> My other config file is a Haskell file.
22:42:40 <MorpheusBeing> And I wish to make some of the features of lambdabot available into RetroShare. Hmm - I was hoping there was a way to reset from cli
22:43:00 <lispy> submit a patch :)
22:43:29 <MorpheusBeing> My knowledge of Haskell, is getting better, but I don't think past raw beginner yet.
22:43:59 <lispy> Not with that attitude :/
22:44:08 * hackagebot yi-language 0.1.0.0 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.0 (MateuszKowalczyk)
22:44:22 <MorpheusBeing> I can do what I want with it from within irc but no response from RS room yet. I am slowly learning. been doing some work with yesod for web pages
22:44:30 <spopejoy> My .plan file is literate haskell.
22:45:31 <MorpheusBeing> anyway thanks for assistance, I will go and start reading over the source, and adjust as required.
22:45:48 <lispy> MorpheusBeing: easiest thing for now is just search for @ and change it
22:57:34 <trap_exit> what module exports liftIO? I want to get liftIO. how do I get liftIO ?
22:57:39 <trap_exit> http://www.haskell.org/hoogle/?hoogle=liftIO is not very helpful
22:58:00 <trap_exit> it oes not appear to be Control.Monad or Control.Monad.IO
22:58:42 <Hafydd> Control.Monad.IO.Class
22:58:48 <glguy> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-IO-Class.html
22:58:59 <c_wraith> I think Control.Monad.Trans also exports it
22:59:05 <bergmark> yup
22:59:07 <Hafydd> However, the instances for liftIO you need might be in different modules.
22:59:10 * hackagebot yi-language 0.1.0.1 - Collection of language-related Yi libraries.  http://hackage.haskell.org/package/yi-language-0.1.0.1 (MateuszKowalczyk)
22:59:21 <bergmark> it's in a pretty annoying location
22:59:25 <trap_exit> ah
22:59:25 <trap_exit> nice, thanks!
22:59:34 <trap_exit> I wans't aware that there were module names that ended in Class.hs
23:00:01 <c_wraith> Class doesn't conflict with class. :)
23:00:14 <trap_exit> yeah
23:00:27 <trap_exit> let's have modules named If.hs , Let.hs
23:01:30 <Hafydd> Import.hs
23:01:41 <Hafydd> That's sensible, I suppose.
23:01:45 <benzrf> bye
23:01:53 <bergmark> I think i stumbled upon a cabal bug with naming files Import.hs :-)
23:02:03 <bergmark> but I haven't reproduced it properly yet...
23:03:23 <comerijn> @hoogle a -> b -> Bool -> Either a b
23:03:25 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
23:03:26 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
23:03:26 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
23:03:37 <comerijn> Any suggestions for a function like that?
23:04:01 <augur> comerijn: what do you mean suggestions
23:06:02 <comerijn> augur: I'm sure I'm forget obvious library function along those lines
23:06:26 <comerijn> Initially I thought I'd do something with guard, but either is no MonadPlus
23:06:52 <augur> fyi @hoogle leaves out a lot of stuff
23:07:39 <bergmark> @type \a b -> bool (Left a) (Right b)
23:07:40 <lambdabot> a -> b -> Bool -> Either a b
23:08:34 <comerijn> :t bool
23:08:36 <lambdabot> a -> a -> Bool -> a
23:08:54 <comerijn> augur: Hence why I ask people here for suggestions?
23:09:28 <augur> comerijn: but, full hoogle, not just @hoogle, says theres nothing
23:09:36 <augur> so.. i dont know. roll your own!
23:09:43 <bergmark> @pl \a b -> bool (Left a) (Right b)
23:09:43 <lambdabot> (. Right) . bool . Left
23:10:04 <comerijn> Rolling my own is the backup plan, Hoogle is stupid and people here are not
23:10:50 <augur> what context are you using it in?
23:11:20 <bergmark> comerijn: usually with eithers you can find something crazy in Control.Arrow
23:11:55 <comerijn> I have a function that wants an "a -> Either SomeError b" and I basically only wanna check that 'a' is == to some value
23:12:24 <comerijn> So I need to turn "a -> Bool" into "a -> Either SomeError ()" or similar
23:13:03 <bergmark> unless p (throwError SomeError) ?
23:13:28 <comerijn> :t throwError
23:13:30 <lambdabot> MonadError e m => e -> m a
23:13:38 <comerijn> Where's that from?
23:13:59 <bergmark> mtl
23:19:12 * hackagebot language-c 0.4.6 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.6 (BenediktHuber)
23:23:01 <begriffs> What's an elegant way to filter a "Map k a" to contain only certain keys? I'll eventually be calling toList :: Map k a -> [(k, a)] so maybe filtering the resulting list would be easier. Thoughts?
23:23:57 <augur> begriffs: certain keys how?
23:25:12 <begriffs> I have a list of keys -- strings as it happens -- and a Map. I would like to create a new map that forgets the key value mappings for keys not in my list of strings.
23:25:42 <comerijn> begriffs: difference?
23:27:09 <begriffs> Well it's not that I have two maps and want their difference, it's that I have a Map k a and a list [k].
23:27:31 <hiptobecubic> Very off-topic, but damn. Guys. http://vimeo.com/103425574 Guys.
23:27:33 <hiptobecubic> Damn.
23:28:53 <merijn> begriffs: zip the list with "repeat ()" and use fromList?
23:28:57 <merijn> tada, instant map
23:30:40 <begriffs> Ohhh nice
23:35:56 <begriffs> merijn: thanks it works
23:49:16 * hackagebot word-trie 0.2.0.4 - Implementation of a finite trie over words.  http://hackage.haskell.org/package/word-trie-0.2.0.4 (MateuszKowalczyk)
23:59:57 <t4nk714> Hi how can I convert [Int] to the result of runST?
