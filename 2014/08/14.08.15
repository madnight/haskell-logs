01:05:50 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF | XCode 5 issues? http://is.gd/H4sEub'
01:05:50 --- topic: set by monochrom!trebla@216.138.220.146 on [Sun Aug 03 09:04:00 2014]
01:05:50 --- names: list (clog startling aarvar1 paullik tgkokk folone_ Sonderblade MindlessDrone RustemS zec_ d_k HalfWayMan drjeats jutaro Nizumzen r444 vijaykiran Trollinator ventonegro Jackneill Kaini xenog laar NikolajK edsko Beetny ormaaj vamega1 oakwhiz nkoep shintahW msgodf DrCode stalintrotsky fujimura_ BoR0 Swizec gilligan- gfixler mattyw blazb_ PragCypher anttih apricity ForNeVeR JanBessai hinidu ique raichoo arenz hackagebot albertid DanZimm_ dibblego makalu latk bennofs)
01:05:50 --- names: list (d3m1g0d- _0xAX klaut archblob alenn hkon_ quaestor1 jonke MercurialAlchemi lzy001 OscarZ jtcwang quchen rrmckinley zereraz funrep phyrex1an sopvop thevishy xificurC MitchW fumieval adas adlan statusbot thunderrd danvet niklasb orbifx charlie koi forgottenone hamid angerman tomku Sauvin Plasmastar syunull artyomkazak banister gentleben monochrom sivteck ilk ksh kyb3r_ tumdedum choosegoose u-ou vili genericpersona coaupiff jordanl SilverKey Ralith lfairy Wertax)
01:05:50 --- names: list (joachifm dimday rekahsoft megajosh2 zarul tstc dfeuer kcj mgregson Platyp ARCADIVS lambdabot xinming jophish_ kvda Cale amiri Jesin zwer mgomezch alxgnon andyt jml jxnl mgaare yfeldblum dgvncsz0f Castor0 otto_s guampa corgifex pweaver_ glguy ropav shanse tismith armyriad chrisdotcode Axman6 exio4 phay kerrick badi merijn apaku balakalaka theorbtwo steamboat Total_1mmersion blicero dabradley Desheng yacks cdk Gurkenglas dgpratt dsantiago \q jedws _ikke_)
01:05:50 --- names: list (agjacome_ lithiumdeuteride predator217 michaelneale codesoup normanrichards Sgeo pavonia alvdav ddere lpvb cerchio Scorchin edwardk dolio fikusz FreeFull ajyasgar ellipsis_ amosr l0cust JagaJaga ThatOtherPerson jasonjckn bbloom_ Kobata_ araujo bitraten SmileyKeith slashus2 sxn cobakobodob Polarina OlegYch3 sprang WraithM slth vital carlosgaldino `^_^ Excureo David arpunk MitchellSalad cjenkin2 pxqr Guest25963 shachaf augur_ phaskell comma8 isomorphic)
01:05:50 --- names: list (MagneticDuck Iloiny whaletechno bergey Heffalump soggybread centrinia spaceships enthropy ccasin saep FragByte jcsims ceii haskoiner albel727 alpha123 triliyn phischu deavid pyon brandonw tgeeky so cow_2001 zanchoPansa DT`` eazar001 ivan\ Kazurik martingale Willia___ btubbs Longlius eeezkil R2ZER0 colluphid mawuli__ negatratoron_ MagnusVortex o0oo0o melter tb01110100 nullbyte SwashBuckla boot13 Mon_Ouie dagle djcoin_ luite hbar fling fxr plutoniix codeburg)
01:05:50 --- names: list (horlicks_ reizuki__ ikke tmct Guest41291 NeueWelt eevar infinity0 roconnor_ falafel osa1 deevus SoupEvil nemesit|znc KorriX wchun tomboy65 tnks blz37 ryanakca_ itb Tesseraction himikof teeteewhy andrewsw acikers_ pnielsen aninhume1 XMunkki_ Razz BlastHardcheese cryon ffledgling|away mrpantou1le bwe_ mrmonday_ stew Blkt effy tero- javex Iceland_jack asfp sbyl EvanR_ cap3lla drbean rejuvyesh joeyh Maxdamantus Nimatek_ c74d ixian8 ziman klugez acharles)
01:05:50 --- names: list (Phillemann Belgarion0 cmn jonathanj skilpat NinjaPenguin wjlroe _jrp_ doshitan metaf5 Internet13 lpsmith _5kg asjo linduxed ion shmookey fqsxr canta StoneToad pranz1 dyreshark reggie1 myme sbrg chrisdone bjornars __main__ ij Pythonfant lpaste_ Jello_Raptor alang indiv0 mickk suOya__ Tordek jrslepak felixn_ Freundlich pp^ jj2baile helgar m4farrel_ radix eyem scopedTV rudi_s elij Bwild_ Jonno_FTW redtricy1le SHODAN integral_ ljhms_ Dodek thirsteh_ fionnan_ gws)
01:05:50 --- names: list (tridacty1a bd__ aprescot1 danking_ jix_ poucet_ ehamberg qwandor|quassel RevJohnnyHealey bgyss stvc_ NobbZ shennyg jmcc zling__ eamelinky asabil lacrosse rschulman PatrickRobotham zph biscarch dlackty_ serjeem_ mbrcknl jonsterling mankyKitty oldmanstanley_ posco Natch petercommand ilmig ernst stevely_ M-ou-se Rufflewind iXeno jlyndon joshsz korpse________ bgamari vsayer iteratee ian_mi ruukasu kaol hc digixtc yeltzooo dogmaT nisstyre execut3 Philonous orion)
01:05:50 --- names: list (yukko bb010g tromp Eagle_Erwin thoughtpolice gereedy vikraman ckw JZTech101 sea-gull stepcut oberstein zz_LoRdToLsToI Nickeeh codile fall_ LordDeath ThePhoeron Reiser si14 lfp Diskord ggherdov GGMethos fergusnoble Svedrin ttuegel trez sw1nn kongo2002 jrw Boreeas strmpnk orzo Jaxan raid idnar Yawgmoth_ gspr jennmoneydollars Xorlev yeshuah k4r1m_ puzza007 sdx32 billyiii aloiscochard kirjs__ MiracleBlue NemesisD` lenstr cdidd bjorkintosh ninedotnine bcoppens)
01:05:50 --- names: list (omefire2 cmsd2 DasIch shapr mero Laney @ChanServ tomaw iulian thorstadt gx^ sgronblo phaer osnr Cathy geekosaur elfangor tromp__ hsc natte demolithion gdsx_ aupo uncleBlazer GaveUp _1126 Preyer petantik milli fnordbert SLi zeiris KaneTW fyolnish TakSuyu `0660 iron_houzi kosmikus PHO_ blenny katis danneu marsbot Th0mas clementd Spockz callumacrae feltnerm_ saurik zq [swift] koala_man d3lxa jnott elgot caasih_ george2 acfoltzer Vbitz nkpart cin Bigcheese agrif)
01:05:50 --- names: list (charliekilo Walther adimit ByronJohnson sipa mandu Clint alcabrera|afk k00mi l3kn seanparsons machrider spion Transfusion ChongLi companion_cube davorak_ fabjan_ tomejaguar_away knyppeldynan cyrusdavid mgomes_ tsou banyan cjay jlewis somenick- felipe_ mrd Na6hu7Ud_ Kinnison kandinski michaelpj electrogeek dario chasecaleb maurer joshc itsmonktastic mlen Tene cursork Bane^ Chousuke Liskni_si nexion cross Adeon mokus Jei keko_ qtplatypus srbaker Gracenotes_)
01:05:50 --- names: list (Ezku opto mnemon humppa heikkih peddie Ke cynick pyrtsa pqmodn agolsme_ Harbinger Sagi rtl helgikrs1 dcoutts hegge cyphase kloplop321 dmilith ahihi `bps jasu0 Guest63619 Tiktalik opqdonut adrienneleigh drone| noidi Bootvis comboy ggreg pfoetchen knyon nicoo sajith jameseb marienz Hardolaf stiell notdan dmead mephx zoink pdxleif petterw dixie xnyhps jacobw T_X sarlalian Dashkal averell Lacriatch neektza Jyppe gidogeek [mth] dxld_ ChewieBe1rdy AshyIsMe iota_)
01:05:50 --- names: list (KitC_ dottedmag hiredman zachmassia flux BrianHV kini wollw ParahSailin jrp6 rieper Wayneoween liuw Fuuzetsu jin_jin sordina2 zymurgy dh mak` srhb barrucadu eagleflo monsieurp Nanar jackhill amontez_ dju sellout JustAPerson joe_k z0d kipras`away djapo wei2912 therealklanni ivan` felixsch lahwran noddy kjanosz _flow_ waynr qr42 go|dfish wting wormphlegm DigitalKiwi ivoscc parallel21 vladan brackets yan_ alloyed epta sleepynate moop mangaba_leitosa mjo flori)
01:05:50 --- names: list (vhz_ numberten tlevine nulpunkt OrangeDu1k bxc empyreal finnrobi qrada_ froztbyte oconnore bbastian td123 evax_ sodaplayer bernalex cwc mrowe Draggor liori anachron peder pharaun jmct xaimus pfn sviterok Kabaka lieven_ adnap zalami filinep McManiaC ephess mrkishi Cheery sunnavy owlglass asm89 RayNbow`TU phaazon akurilin vpm kakos Boney meretrix staffehn dowski SaBer pi8028 rs0 bstrie davean claudiyoh noplamodo_ idoru CaveJohnson Nivim amiller kuyatzu noctux)
01:05:50 --- names: list (cow-orker burp Fubar^ chirpsalot defanor thomassgn betawaffle sokoll mathu nitrix pm5 Raynes splintax Ulrar Derander hng Rutger` xintron Or1 andreasrx edk statusfailed mietek jlouis tekacs Twey majoh anders^^ mikeizbicki ndeine g0dmoney- pingu dilinger Okasu magicman Krakarn popl FliPPeh qrada__ earldoug1as stbuehler Eliel_ int-e julmac MK_FG jchee levi Sornaensis macron brisbin seliopou pieter vincom2 zz_anildigital catsup everett tristero mechairoi Nshag)
01:05:50 --- names: list (spacebug osfameron zenzike joneshf heudebeu ab9rf cods ircbrowse koninkje_away karls EvanR mrshoe lulf alinab isomorphismes ft Guest74109 flebron machineslearn jglukasik Kruppe dp_wiz mixi Saizan JPohlmann fractalcat b_jonas jaspervdj dustinswan ClarusCogitatio jayne gargawel_ fryguybob xpika Erstarrung dv- bjobjo bvad heyj irssi_ jorj schlumpi coconnor byorgey rblackwe blast_hardcheese pikhq FireFly Hafydd kragniz doismellburning eddd xplat alorente kgadek)
01:05:50 --- names: list (janne Plazma saiam Cryovat Artpicre ens sixthgear jungnam Rembane hanDerPeder otterdam nwf cepheus nikola heaumer Watcher7 mirsal Martty not_a_bear amf brixen cpa enko yam krakrjak hpc honza `micro Arnar_ Intensity zomg annulus thorkilnaur_ rabisg bergmark dqd Profpatsch lyxia peltchu Deewiant zerokarmaleft aoh aford joefiorini qz geal raek sofancy mononofu friden Corey djahandarie emlow kalloc gbarboza mami obiwahn hodapp Luke- jakutis mortberg dropdrive)
01:05:50 --- names: list (periodic vamega nik_89 drlemon waxjar stelleg mmaruseacph2 kaiza DustyDin1o ssedov slobo_ cyanoacry ktosiek honkfest1val chit Entroacceptor lispy MasseR pii shlevy tessier benmachine heath j0ni_ mxf zebr devn arrdem Gothmog_ abc56889 taruti bitemyapp theDon thebnq BeardedCoder mimi_vx CosmicRa` greymalkin abh Taneb diginet_ johnw Edoxile bra drdo andyland nyuszika7h s_e_ SegFaultAX Someguy123 iross ipuustin TheMoonMaster benbangert frsilent hpd bbee jrib)
01:05:51 --- names: list (ezrios mikeplus64 no_name jnoah Shin-LaC bartavelle henrikhodne sohum Baughn ciaranm kloeri tych0 umib0zu tamiko cschneid skarn hmax s4msung oblivian werdna indigo frms hyPiRion srcerer nesqi emma Ornedan kennyp supki kittenso1p mayski_ eL_Bart0 jtobin jdiez Tehnix tomprince harski paz arun kav_ yac farn papna inr tippenein haroldwu mutable Paks luzie Klumben stoned _d3f DarkFox Starfire gridaphobe Pad^ LeaChim wtw mavam wto StolenToast ido zz_mopemope)
01:05:51 --- names: list (SenorSenpai mwestrik n-dolio frerich repnop edran obcode BeLeKy sveit Burton AncientPC ChristianS Soft purefn simcity2000 wagle mike4 ninzine fall` rlp10 amatsu ps-auxw eyenx Desoxy otulp ibid noteventime perrier unsymbol jcurbo mads- Cr8 omefire3 grynn brycelane ajcoppa seagreen Lindrian robbert benzrf|offline thetallguy bydo thetallguy1 lusory jonh copumpkin Bazzie hamishmack phadej mr- CindyLinz shiona lifenoodles Brando753 saml case39 Drezil zeroskillor)
01:05:51 --- names: list (Rarrikins yusukesuzuki Biohazard solirc bsmt tsani Rylee ortmage c-rog dan64 imalsogreg cjwelborn Zekka TDJACR Draconx deni tov antoniy semberal gseitz ninegrid yano Gilfoyle Rakkin bens AleXoundOS relrod mountaingoat mornfall jlamothe Shogun KitD maoe1 murphy_ liyang coppro mceier hvr kalz sunfun pygospa wizonesolutions MediumDivision ReinH dstockwell cloudhead MMuse_ jabbslad__ jzelinskie mrb_bk ocharles alphonse23_ metadave akahn Karethoth_ tarcwynne _tca)
01:05:51 --- names: list (superjudge__ mindos_cloud___ mno2 sindresorhus AlainODea emmanueloga m_george sclv teehemkay bchar etrepum termos tobyp avdi steshaw wjt yrashk jroesch_ c9sould Imdsm aristid zpconn_________ chas Raynos cstrahan jodaro andreypopp blindscreen SethTisue_______ nick1234abcd CARAM raphie__ skuggi boegel|work Kneiva dsirenko bounb afleck bmuk carter wjm xpinguin preyalone waterlaz user___ rom1504 notori0us joelteon troydm Lefeni plucas shouya jpierre03 sm Dtgr)
01:05:51 --- names: list (haasn Paprikachu kmicu d-snp IanKelling estewei_off kungp dlundy mattp_ igorii AntiSpamMeta nifty kardboardb estulticia dougia nolan_d naudiz jaimef Khisanth vmeson ThatCantBe savanni eyck etabot terlar jwheare2 ousado mendez frontendloader hongminhee Floyd_ liszt MrGwen jle` arch_ purefn1 adamse Nik05 tg divyanshu Athas kfish jake_l erickedji cjheath L8D mkrtem Aeriff Jaak descender lokydor kmapped ekroon_ leifw shelf pjdelport dreixel_ prinsen dkua kylcarte)
01:05:51 --- names: list (neptunepink peterhil` yakutori_ ozataman_ mikecaruso1 javawizard funfunctor1 japesina- xahry_ gandr flojistik squimmy gsilvis ZsoL_ mjrosenb twopoint718 curlywur2y solarus jlewis__ ahf plhk_ oubiwann xrz Laquendi Vq Licenser subleq ValicekB kshannon shergill tpsinnem kqr franckverrot Enigmagic joneshf-laptop)
01:06:17 <kvda> this might be a simple question, but how can I can conditionally append to a list with no action taken in conditional test if False?
01:06:46 <Mon_Ouie> ((-) 1) works like the other operators:
01:06:50 <Mon_Ouie> > ((/) 2) 4
01:06:52 <lambdabot>  0.5
01:07:01 <merijn> kvda: Just return the old list in case of false?
01:07:02 <pjdelport> kvda: if c then xs ++ [x] else xs ?
01:07:13 <pjdelport> kvda: Appending is a worst-case operation for lists, though.
01:07:15 <enthropy> > [1,2,3] ++ (guard False >> [4,5,6])
01:07:17 <lambdabot>  [1,2,3]
01:07:17 <pjdelport> (in case that matters)
01:07:23 <dibblego> if p then ((++) list . return) else id
01:07:24 <enthropy> > [1,2,3] ++ (guard True >> [4,5,6])
01:07:25 <lambdabot>  [1,2,3,4,5,6]
01:07:39 <kvda> dibblego, that looks interesting..
01:07:46 <kvda> pjdelport, merijn thanks
01:07:47 <dibblego> enthropy's is better
01:08:06 <kvda> pjdelport, i'm techincally consing
01:09:05 <kvda> dibblego, i have no idea what's going on in enthropy suggestion :)
01:10:09 <enthropy> > [1,2,3] ++ concat [ [4,5,6] | True ]
01:10:11 <lambdabot>  [1,2,3,4,5,6]
01:10:35 <pjdelport> kvda: It's using the MonadPlus interface to lists.
01:10:47 <enthropy> > [1,2,3] ++ do guard False; [4,5,6] -- minimal parens
01:10:48 <lambdabot>  [1,2,3]
01:14:09 <ChristianS> kvda: anyway, it you often need appending, consider the DList type (dlist package)
01:14:43 <kvda> thanks ChristianS, looking at it now
01:14:54 <splintax> the concept of "lambda lifting" is using the phrase "lifting" in a completely different way to liftM and friends, right?
01:15:13 <pjdelport> > guard True :: [()]
01:15:15 <lambdabot>  [()]
01:15:17 <pjdelport> > guard False :: [()]
01:15:19 <lambdabot>  []
01:15:23 <merijn> splintax: Yes and no
01:15:43 <merijn> splintax: Lifting in general just implies "transforming something to work on something else"
01:15:48 <pjdelport> And then the >> either replaces the single () with what's on the right, or keeps it as nothing.
01:16:06 <johnw> http://en.wikipedia.org/wiki/Lambda_lifting
01:16:30 <pjdelport> splintax: I'd say yes. Both are "lifting" in a very, very general sense, but they don't really have anything to do with each other.
01:17:37 <johnw> from what I can see there, liftM and friends don't change the bindings of any variables, which is sort of what lambda lifting is all about
01:25:15 <johnw> @src map
01:25:15 <lambdabot> map _ []     = []
01:25:15 <lambdabot> map f (x:xs) = f x : map f xs
01:26:14 <hvr> grab it while it's fresh! new bike-shedding opportunity @ http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/22665
01:49:26 <naudiz> How so I convert from [Char] into Text?
01:49:37 <johnw> Data.Text.pack
01:51:28 <naudiz> thanks, couldn't find it
01:53:42 <trap_exit> how long is "cabal install cabal-install" supposed to take? seems to have hung (> 5 minutes) at "Build Cabal-1.20.0.2 ..." for me
01:54:08 <trap_exit> please advise on (1) Ctrl-C, (2) wait patiently, (3) kill -9, or (4) unplug power cord
01:55:10 <johnw> can I choose "All of the above"?
01:55:27 <oakwhiz> time cabal install cabal-install: 34 seconds
01:55:31 <aarvar> (5) sledge hammer
01:55:57 <trap_exit> still fucking hung
01:56:01 <trap_exit> so this is OSX + latest haskell platform
01:56:07 <trap_exit> "cabal update; cabal install cabal-install"
01:56:16 <trap_exit> oakwhiz: what OS are you on?
01:56:24 <oakwhiz> Linux 3.15
01:56:48 <trap_exit> maybe timing cabal makes it go faster since it knows its being watched
01:56:54 <trap_exit> hmm, according ot top, ghc is still running
01:56:54 * dottedmag suppresses the urge to make a joke about Linux being just a kernel, not an OS
01:57:07 <trap_exit> does cabal have this option to say "use all 4 cores"
01:58:37 <trap_exit> whoa
01:58:38 * trap_exit does dance
01:58:38 <trap_exit> it finished
01:58:53 <johnw> cabal install -j4
01:59:01 <johnw> will build up to 4 packages concurrently
01:59:03 <trap_exit> reading stackoverflow
01:59:07 <johnw> but not within each package
01:59:08 <trap_exit> people claim -j installs _packages concurrently_
01:59:11 <trap_exit> but not concurerncy within a single package
01:59:11 <trap_exit> ah
01:59:29 <trap_exit> so there's nothing like "make -j8" right now?
01:59:47 <johnw> i think GHC supports it, but it's not in cabal yet
01:59:50 <trap_exit> ther emust be a serious reason why such a pure language is not so easily parallelized
02:00:08 <johnw> because build times were never anyone's research interest?
02:00:22 <trap_exit> oh right, haskell is "avoid success at all costs" :-)
02:00:25 <johnw> people confuse Haskell with mainstream commercial languages
02:00:26 <dottedmag> trap_exit: I remember reading an explanation -- some global mutex or data structure in ghc which took time to get rid of.
02:00:56 <johnw> when we get gajillions dollars in funding to make GHC better, you can bet it will build code faster ;)
02:01:44 <trap_exit> someone needs to write a messaging app in haskell/ghcjs and get acquired by $38 billion by google
02:01:56 <oakwhiz> trap_exit: looks like most of those xeons will be sitting idle until then :-)
02:02:36 <johnw> yeah, if you are spending most of your time rebuilding the same Haskell package over and over, many-core really buys you nothing except slower single cores
02:02:39 <trap_exit> oakwhiz: haven't ordered yet :-)
02:03:15 <johnw> I'm still using my laptop for everything, so I hit my thermal ceiling pretty much continuously throughout the day
02:05:04 <superlinux-hp> hi all.
02:05:08 * frerich bites his tongue ranting about hot laptops supposedly hurt fertility, which would be a shame since you'd hope that Haskell people reproduce!
02:05:28 <johnw> my laptop is up on a stand plugged into a big monitor; no heat is felt
02:06:50 <superlinux-hp> well.. this is my first day in haskell. but I need to know, where haskell is mostly used? I understand that it's a language like any language. but there should be a field where haskell is heavily used.
02:07:10 <Axman6> people seem to love writing compilers with it
02:07:22 <Axman6> there's also plenty of web stuff going on with
02:07:46 <johnw> Haskell is used in lots of areas
02:08:14 <johnw> I wouldn't say there's a "main theme" the way there is for Ruby
02:08:14 <trap_exit> basically haskell is used any time when a functional guy looks at a domain and is like
02:08:21 <trap_exit> I can beat 100 of those imperative idiots if I use haskell
02:08:30 <Axman6> it's also commonly used for research into programming languages and also the mathematical foundations of programming (particularly category theory)
02:09:01 <johnw> I write imperative code all the time in Haskell :)  "Machine, do this; machine, do that."
02:09:33 <superlinux-hp> ok. thank you.
02:09:43 <Axman6> superlinux-hp: it's pretty awesome to write all sorts of network servers (though there aren't really any well known examples I guess)
02:10:17 <johnw> superlinux-hp: Haskell does excel at concurrent and parallel computing
02:10:42 <pjdelport> superlinux-hp: http://www.haskell.org/haskellwiki/Haskell_in_industry
02:10:53 <superlinux-hp> also I am feeling it's hard to learn , but I am  breaking through
02:11:17 <trap_exit> johnw: I ask you, in your role as an op, to kick johnw for promoting imperative programming in haskell
02:11:19 <Axman6> it is hard to learn, especially if you've already been broken by OOP/imperative ideas ;)
02:11:20 <johnw> superlinux-hp: you join all of us in having had that feeling then :)
02:11:25 <superlinux-hp> my understand of programming is like C and Java..
02:11:35 <johnw> http://stackoverflow.com/questions/6622524/why-is-haskell-sometimes-referred-to-as-best-imperative-language
02:11:47 <trap_exit> the hardest thing to learn about haskell is to realize
02:11:53 <Axman6> superlinux-hp: come over to #haskell-beginners =)
02:11:58 <trap_exit> that haskell code optimizes for readability, not writability (i.e. inverse of perl)
02:12:46 <trap_exit> whoa, why is htere #haskell-beginners ? is #haskell not beginner friendly?
02:12:57 <trap_exit> I don't think I ever got critiized for asking stupid qeustions here
02:13:27 <johnw> I don't think that's why it was made
02:13:33 <Axman6> helping beginners can get noisy. that's fine, but people would also like to be able to talk about other stuff
02:17:19 <PotatoGim> Hi
02:17:29 <guhou> Hello
02:18:23 <t7> @hoogle Bool -> a -> m a
02:18:25 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
02:18:25 <lambdabot> Control.Exception assert :: Bool -> a -> a
02:18:25 <lambdabot> Control.OldException assert :: Bool -> a -> a
02:20:27 <guhou> Has anyone had experience using Uniplate with GADTs?
02:21:17 <_1_Vampire> oop
02:22:29 <trap_exit> I want to have ghc allow me to have #ifdefs / conditional compilation. Do I want http://projects.haskell.org/cpphs/ ... or do I want osmeting else?
02:25:47 <ion> trap_exit: Just {-# LANGUAGE CPP #-} and #ifdef … #endif in the file.
02:26:22 <t7> @hoogle Set (Set a) -> Set a
02:26:23 <lambdabot> Data.Set deleteMax :: Set a -> Set a
02:26:23 <lambdabot> Data.Set deleteMin :: Set a -> Set a
02:26:23 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
02:26:35 <t7> how is that still not a thing
02:27:47 <trap_exit> ion: no way ... and can I pass def flags in GHC ?
02:27:53 <trap_exit> where is the manual page on this?
02:27:59 <trap_exit> ion: google gave me http://www.haskell.org/haskellwiki/Cabal/Developer-FAQ#Conditional_compilation which is not helpful
02:28:47 <trap_exit> https://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html is also light on how to use CPP
02:30:48 <pjdelport> t7: fold
02:30:57 <supki> trap_exit: -Dkey=value
02:31:13 <trap_exit> supki: this is life changing
02:31:24 <t7> pjdelport: you can do pretty much anything with a fold
02:31:34 <t7> does that mean we dont need a map function?
02:31:55 <pjdelport> > fold $ S.fromList [S.fromList [1,2,3], S.fromList [3,4,5]]
02:31:59 <lambdabot>  fromList [1,2,3,4,5]
02:32:40 <pjdelport> :t fold
02:32:41 <lambdabot> (Monoid m, Foldable t) => t m -> m
02:32:53 <pavonia> @src map
02:32:53 <lambdabot> map _ []     = []
02:32:54 <lambdabot> map f (x:xs) = f x : map f xs
02:33:02 <pjdelport> Set doubles as both Foldable and Monoid :)
02:41:10 <t7> @hoogle (a -> Bool) -> [a] -> Maybe a
02:41:19 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:41:19 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:41:19 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
02:44:31 * hackagebot cab 0.2.13 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.13 (KazuYamamoto)
02:47:48 <t7> @hoogle m a -> a -> a
02:47:49 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
02:47:49 <lambdabot> Prelude asTypeOf :: a -> a -> a
02:47:49 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
02:49:36 <t7> also why does ghci not load the modules into scope when type checking fails
02:49:42 <t7> the imports i mean
02:49:50 <t7> i cant get type sigs for stuff
02:49:55 <t7> its stupid
02:51:07 <pjdelport> t7: :set -fdefer-type-errors
02:51:44 <t7> i do want to see type errors though
03:06:08 <adas> is Identity an instance of MonadIO? or is that a wrong question?
03:06:37 <Axman6> it can't be really, it can't perform IO
03:07:00 <Axman6> and I don't think the idea of IdentityT makes sense (but it probably exists somewhere)
03:14:23 <haasn> newtype App f a = App { runApp :: f a } is effectively IdentityT, right?
03:15:16 <{AS}> haasn: no, it has a different kind
03:15:33 <haasn> :k MonadTrans
03:15:34 <lambdabot> ((* -> *) -> * -> *) -> Constraint
03:15:57 <haasn> instance MonadTrans App where lift = App
03:16:39 <{AS}> hmm, interesting
03:17:32 <{AS}> Oh, you said IdentityT (I read it as identity)
03:17:42 <{AS}> sorry, for the confusion
03:20:23 <vozz> How easy or hard is it to create a Haskell library that you can call from other languages?
03:21:16 <dottedmag> Is there annotated guide for Prelude? I'm interested in pragmatics like "read is very simplistic, usually you'd want XXXYYY instead" or "map is too constrained, consider using fmap for polymorphism".
03:24:41 <abc56889> how do you manage a project with local dependencies? is there a way to get cabal to find them automatically before downloading them from the web?
03:25:33 <dottedmag> abc56889: cabal sandbox add-source
03:25:51 <abc56889> dottedmag: woo thanks
03:27:28 <pjdelport> vozz: What kind of calling do you have in mind?
03:29:08 <pjdelport> vozz: You can use GHC's C API from other languages; for example, https://github.com/sakana/HaPy lets you call Haskell code from Python.
03:32:11 <vozz> pjdelport: I was thinking of rewriting a C library in Haskell, it's basically an API for distributed messaging, so you pass it messages etc. In particular it'd need to be callable from java on android, and objective c or swift on ios, as well as whatever language on other platforms
03:36:12 <pjdelport> vozz: Well, anywhere you can embed something with a C FFI you can in theory get GHC / Haskell going.
03:36:32 <pjdelport> But it's not exactly a tiny language runtime.
03:37:22 <vozz> I guess you have to translate everything from whatever language, to C, and then to haskell?
03:37:54 <pjdelport> Well, you just go through the C FFI
03:38:04 <pjdelport> It doesn't actually have to involve much C
03:38:19 <pjdelport> For example in the Python case, it uses ctypes if i'm not mistaken.
03:38:36 <pjdelport> (which is (one of) Python's C FFI)
03:39:48 <vozz> Oh right, cool. You have to start the haskell runtime though, right? but other than that it's mostly just calling the C versions of the haskell functions?
03:42:00 <pjdelport> vozz: There are a few ways to use it; http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html has some more details.
03:43:21 <vozz> pjdelport: looks like just what I was looking for, thanks!
03:51:02 <mmmm_> Is there a variant of unfoldr that also returns the unconsumed portion of the list?
03:56:13 <quchen> Unfoldr doesn't consume a list.
03:56:31 <quchen> :t unfoldr
03:56:32 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:58:40 <trap_exit> i need to, sequentially, write a large file (which I generate on the fly) to disk
03:58:42 <trap_exit> what should I use ?
03:59:42 * hackagebot edenskel 2.0.0.1 - Semi-explicit parallel programming skeleton library  http://hackage.haskell.org/package/edenskel-2.0.0.1 (JostBerthold)
04:00:01 <hpc> trap_exit: there's pretty much all you need here: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html
04:00:16 <trap_exit> hpc -- hmm, not http://hackage.haskell.org/package/text-0.7.1.0/docs/Data-Text-Lazy-IO.html ?
04:00:24 <trap_exit> i was doing my own research on the side
04:00:25 <mmmm_> ah yes, quchen, I meant the seed had yet to be consumed when Nothing appears
04:00:29 <mmmm_> so b in the last interation
04:01:16 <hpc> trap_exit: yeah, those are basically the same api, different string-y type
04:01:23 <hpc> what kind of data are you writing?
04:01:41 <trap_exit> i'm generating a giantass svg file
04:01:44 <trap_exit> and writing it to index.html
04:01:56 <hpc> oh cool
04:02:14 <hpc> you probably want one of the Text types
04:02:56 <hpc> i would go with strict Text just so it's easier to reason about performance
04:03:34 <pjdelport> mmmm_: I don't think there's a standard one.
04:04:15 <trap_exit> hpc: ah, I'm familiar with strict/lazy text :-)
04:04:24 * trap_exit puts on the "I know what I'm doing hat" :-)
04:04:27 <hpc> heh
04:08:41 <Alexa22>  Here some videos. I hope you like them! http://bit.ly/1mFMmyS
04:14:28 <trap_exit> hmm, does System.IO have a move file ? i.e. "mv" of Linux
04:15:20 <hpc> http://hackage.haskell.org/package/directory-1.2.1.0/docs/System-Directory.html#v:renameFile
04:15:21 <bennofs> @hoogle renameFile
04:15:22 <lambdabot> System.Directory renameFile :: FilePath -> FilePath -> IO ()
04:19:06 <latk> If I'm in a monad transformer, e.g. EitherT String m a, and the monad m has an instance of a class, can I access it somehow from the EitherT monad ?
04:26:13 <sgronblo> latk: I'm a noob to monad transformers, but can't you like runEither to get the contents and then pattern match to get the monad and then use >>= to "unwrap" it (please advise me what term is more preferrable)?
04:28:05 <_0xAX> Hello all, i'm trying to write simple parser, and imported BinaryString and Attoparsec to my module, also i have simple data structure like: data MyData = End deriving (Show), when i'm trying to write End in ghci i'm getting following error: https://gist.github.com/0xAX/bb772aa1e36939dc1402
04:28:11 <_0xAX> anybody met this?
04:28:55 <hexagoxel> latk: what do you mean by "access an instance"?
04:34:47 * hackagebot music-util 0.17 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.17 (HansHoglund)
04:39:05 <_0xAX> ah, found how to solve it
04:43:16 <magicman> @hoogle Eq b => (a -> b) -> [a] -> [[a]]
04:43:18 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
04:43:18 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
04:43:18 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
04:45:38 <magicman> Sweet. Didn't know about the GHC.Exts module.
04:49:41 <adas> am i correct in saying that in a "MaybeT m a" computation where "MaybeT m" is a monad, if "a" is Nothing then the entire computation fails?
04:49:49 * hackagebot fixed-vector 0.7.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.7.0.0 (AlexeyKhudyakov)
04:51:41 <tabemann> adas: no
04:52:05 <tabemann> it'd only fail if the Maybe component was Nothing
04:55:35 <adas> tabemann: you mean if "Maybe a" was Nothing in the type "MaybeT m (Maybe a)"?
04:55:50 <tabemann> tes
04:55:51 <tabemann> yes
04:59:50 * hackagebot simple-pipe 0.0.0.12 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.12 (YoshikuniJujo)
05:14:53 * hackagebot fixed-vector-hetero 0.2.0.0 - Generic heterogeneous vectors  http://hackage.haskell.org/package/fixed-vector-hetero-0.2.0.0 (AlexeyKhudyakov)
05:19:54 * hackagebot xml-pipe 0.0.0.7 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.7 (YoshikuniJujo)
05:36:01 <trap_exit> in haskell,
05:36:03 <trap_exit> how do I wait on a child?
05:36:09 <trap_exit> i.e. a child does forkIO
05:36:15 <trap_exit> but I don't wnat the main thread to finish until the child is done
05:36:25 <trap_exit> in this particular case, child = web server
05:36:40 <Fuuzetsu> it's shown how in Paralell and Concurrent Haskell
05:37:30 <trap_exit> Fuuzetsu: I have the book now.
05:37:33 <trap_exit> I don't see it in the table of contents.
05:37:36 <trap_exit> Which page / chatper are you referring to?
05:37:52 <Fuuzetsu> don't know off the top of my head, it was near the async stuff I think?
05:37:56 * Fuuzetsu flips through
05:38:23 <trap_exit> hmm, index join ==> joining a chatroom; dohn
05:38:42 <trap_exit> so currently, my strategy was : well, create emty mvar, wait on it
05:38:45 <Fuuzetsu> Async provides ‘wait’
05:38:47 <trap_exit> but ghc is like: you dumbass, this code deadlocks
05:39:35 <trap_exit> https://gist.github.com/anonymous/8e81e3034e3913116f18 <-- this also works
05:39:43 <trap_exit> the trick is to, after the webserver finishes, put a () into the mvar
05:39:44 <frerich> trap_exit: what I once did was to wrap forkFinally so that I get an MVar which I can 'take' on in order to wait, see https://github.com/frerich/lambdacrawler/blob/master/src/Control/Concurrent/ThreadPool.hs#L33
05:39:47 <trap_exit> this way, ghc doesn't bitch about it deadlocking
05:39:56 <trap_exit> frerich: ha, I think I have the exact same solution
05:40:17 <trap_exit> frerich: the part I previous missed is that after the webserver finishes, I need to put a () into the mvar -- otherwise ghc statically reasons that there's a deadlock
05:40:38 <Fuuzetsu> trap_exit: which is pretty much what wait does ;P
05:40:40 <NikolajK> :k Functor Maybe
05:40:41 <lambdabot> Constraint
05:40:48 <Fuuzetsu> wait (Async var) = readMVar var (page 144)
05:40:50 <NikolajK> What does this mean?
05:41:05 <trap_exit> Fuuzetsu: are you referring to https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html for the Async ?
05:41:27 <trap_exit> Fuuzetsu: I see it now
05:41:33 <Fuuzetsu> yes
05:41:49 <trap_exit> Fuuzetsu: cool; thanks!
05:42:23 <frerich> Yeah, I think it would be a lot nicer with 'async'. Alas, back when I wrote my code, I was just new to STM and Simon Marlow's book wasn't even written. :}
05:42:47 <trap_exit> frerich: tell me about dinosaurs
05:42:55 <Fuuzetsu> no problem; note that the library you linked uses STM in it so the stuff on pages 140ish is not what the actual lib looks like
05:43:06 <Fuuzetsu> it does go into the STM + Async in 180ish
05:43:14 <trap_exit> Fuuzetsu: I like understanding how it works under the hood
05:43:19 <trap_exit> page 144 makes it very clear how it works
05:43:20 <trap_exit> I like
05:43:34 <Fuuzetsu> trap_exit: Right, but that's not actually how the lib works
05:43:35 <trap_exit> I hate black, opaque magic
05:43:59 <trap_exit> Fuuzetsu: oh, you're saying they have different semantics
05:44:21 <Fuuzetsu> well, the book develops the Async it introduces throughout chapters to adapt it to various use-cases
05:45:21 <neutronest> is anyone who faced a problem that when "cabal install http-enumerator", it said that there was some rejecting...
05:46:12 <neutronest> I tried to rm the .ghc, and .cabal, and then cabal update, but it was not useful.......
05:46:38 <trap_exit> neutronest: please past full msg into gist.github.com
05:46:52 <trap_exit> the entireity of "cabal install ..."
05:46:55 <trap_exit> down to the actual error msg
05:49:49 <supki> neutronest: http-enumerator is long deprecated, btw
05:49:57 <trap_exit> neutronest: do you have a gist paste?
05:50:03 <trap_exit> err, ignore me, listen to what supki said
05:50:41 <trap_exit> hmm, can I overload + to do : Vec2 -> Vec2 -> Vec2, and Vec2 -> BBox -> BBox, and BBox -> Vec2 -> BBox ?
05:50:49 <trap_exit> err, overload (+)
05:51:00 <trap_exit> Vec2 * Vec2 is not defined, I just want to define (+)
05:51:00 <Fuuzetsu> fundeps
05:51:03 <neutronest> Oh, thank you! ლ(╹◡╹ლ)
05:51:15 <Iceland_jack> You can't overload + from Num to do that
05:51:17 <supki> neutronest: use http-conduit (or http-client if you don't need conduit interface)
05:51:20 <Fuuzetsu> right
05:51:26 <trap_exit> http://www.haskell.org/haskellwiki/Functional_dependencies
05:51:28 <trap_exit> yep, looks liek what I need
05:51:35 <Iceland_jack> You can also use type families
05:51:55 <Iceland_jack>     type SumTy Vec2 BBox = BBox
05:52:21 <trap_exit> IceLand_jack: I really want to use +
05:52:27 <trap_exit> rather than use Vec2_add
05:52:31 <trap_exit> err, rather than use vec2_add
05:52:33 <Iceland_jack> The type of + isn't right for that
05:52:39 <Iceland_jack> @ty (+)
05:52:40 <lambdabot> Num a => a -> a -> a
05:52:44 <trap_exit> + has to be a -> a -> a ?
05:52:50 <pointed_set> trap_exit: you can declare instance Num Vec2 / instance Num BBox. For now, you cant do Vec2 + BBox
05:52:55 <trap_exit> it won't allow me to do Vec2 + BoundingBox = BoundingBox ?
05:52:58 <Fuuzetsu> no, it has no be Num a => a -> a -> a
05:52:59 <pointed_set> no
05:53:00 <Iceland_jack> No
05:53:10 <NikolajK> I learned that when I write ":k", the word "Constraint" can come up, next to "*" and "->". Is there something else?
05:53:12 <trap_exit> hmm
05:53:18 <trap_exit> 3 nos :-(
05:53:55 <pointed_set> trap_exit: Unless you hack import Prelude () and declare your own Num class... but its an overkill
05:54:11 <trap_exit> yeah
05:54:16 <trap_exit> I don't want it _that_ badly
05:54:24 <trap_exit> is @+ taken ?
05:54:28 <trap_exit> @ty (@+)
05:54:29 <lambdabot>     Not in scope: ‘@+’
05:54:29 <lambdabot>     Perhaps you meant one of these:
05:54:30 <lambdabot>       ‘++’ (imported from Data.List), ‘+’ (imported from Prelude),
05:54:37 <pointed_set> try +.
05:54:41 <Fuuzetsu> +'
05:54:46 <pointed_set> less annoying to look at
05:55:02 <Fuuzetsu> I don't like . in my operators
05:55:05 <trap_exit> hmm, I should call it `MY_SPECIAL_SUM`
05:58:11 <bernalex> is there a way to start "cabal repl" with the packages for the tests visible?
05:59:05 <Fuuzetsu> blind guess: cabal configure --enable-tests && cabal repl
06:00:23 <bernalex> ah. I only ran install with --enable-tests
06:00:48 <Fuco> The 3rd law here: http://www.haskell.org/haskellwiki/Catamorphisms#Laws isn't very sensible... it would imply f = id. It should probably be phi and psi (or some different) letter for the second cata. I can't edit the wiki but can someone with an account please fix it?
06:01:09 <trap_exit> fundeps + +' has won
06:01:10 <trap_exit> I like +
06:01:11 <bernalex> Fuuzetsu: didn't help though
06:01:13 <trap_exit> I like +'
06:01:15 <trap_exit> ti's like add-prime
06:01:17 <Fuuzetsu> hm ok
06:01:22 <bernalex> hidden package ‘hspec-wai-0.3.0’
06:01:45 <bernalex> I did cabal configure --enable-tests, and then started cabal repl, and did import Test.Hspec.Wai.JSON
06:02:14 <bennofs> bernalex: cabal repl <name of test-suite>
06:02:41 <bernalex> bennofs: ty!
06:14:53 <bernalex> I think maybe there's something I don't understand. how do I lazy bytestring -> string?
06:15:22 <bernalex> I thought "L8.unpack $ L.pack "test" `L.append` L.pack "test"" should work but errr no
06:45:05 * hackagebot clientsession 0.9.0.4 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.0.4 (FelipeLessa)
06:49:13 <NikolajK> In haskell.org/haskellwiki/Hask, why do they call "undefined :: a -> b" a morphism? If the objects are types, then this isn't term of any Hom, but a polymorphic thingy, still.
06:50:05 * hackagebot cabin 0.1.0.2 - Cabal binary sandboxes.  http://hackage.haskell.org/package/cabin-0.1.0.2 (nclarke)
06:52:42 <pyon> NikolajK: I guess monomorphic types are morphisms, while polymorphic types are natural transformations.
06:53:13 <pyon> (But perhaps there is some gotcha to it.)
06:53:37 <pyon> NikolajK: I mean, monomorphic function types and polymorphic function types.
06:54:45 <pyon> NikolajK: Or, errr... monomorphic functions and polymorphic functions themselves.
06:55:07 * hackagebot clientsession 0.9.0.5 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.0.5 (FelipeLessa)
07:00:40 <NikolajK> pyon: Yeah, so the function (id::Int->Int) is term of Hom_{Hask}(Int,Int), while id itself, the polymorphic function, corresponds to a program, but not a morphism of Hask. From this perspective, I find the explanation problematic. Without type annotations in the expression, there is not reason to require "undef1 . id = undef1" for undef1 in the first place.
07:30:15 * hackagebot sasl 0.0.0.1 - SASL implementation using simple-pipe  http://hackage.haskell.org/package/sasl-0.0.0.1 (YoshikuniJujo)
08:02:03 <bennofs> Is it possible to use cabal repl even if the package doesn't build?
08:07:52 <clrnd> bennofs, afaik yeah
08:08:14 <bennofs> ah sorry, forgot to say what happens when I try it: it tries to build the project, and then exits
08:08:58 <clrnd> bennofs, ah, is it a library?
08:09:02 <bennofs> clrnd: yes
08:10:20 * hackagebot Hipmunk 5.2.0.16 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.16 (FelipeLessa)
08:11:19 <clrnd> bennofs, yeah I think its a bug in cabal ...
08:11:38 <clrnd> :/
08:15:20 * hackagebot dfrac 0.1.2.0 - A package for precise decimal arithmatic using rationals.  http://hackage.haskell.org/package/dfrac-0.1.2.0 (georgerogers42)
08:16:21 <Gamabasagaaa> kalachamuga
08:20:09 <{AS}> Hi, does typeable work with GADTs?
08:20:12 <{AS}> Typeable*
08:20:52 <bennofs> {AS}: Typeable doesn't care how the ADT looks like, but Data is problematic iirc
08:21:05 <{AS}> bennofs: What do you mean
08:21:29 <bennofs> {AS}: Typeable should work for GADTs
08:21:43 <bennofs> {AS}: but if you use Typeable, you often also want Data, which doesn't work for GADTs
08:22:18 <jkarni> bennofs: why doesn't Data work for GADTs? I remember coming across that, but not investigating it much further
08:22:36 <{AS}> bennofs: Ah, thanks
08:23:01 <{AS}> bennofs: how about type families and such?
08:23:31 <bennofs> jkarni: oh, looking at it again, I'm not sure anymore it doesn't work for GADTs. idk. I confused Data with GHC.Generics
08:24:19 <bennofs> {AS}: what do you mean? do you have an example?
08:25:03 <{AS}> bennofs: I was just wondering if typeable works for all possible type extensions, and if it could be made to work with a dependent type system
08:25:21 * hackagebot rainbox 0.6.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.6.0.0 (OmariNorman)
08:25:41 <vanila> {AS}, I'm curious what use case you have? (if it's too complex to explain that's fine :) )
08:26:02 <vanila> maybe in #idris
08:26:27 <bennofs> {AS}: in data Foo bar qux = ..., Typeable only depends on Foo bar qux. It doesn't care at all about what ... is
08:26:46 <bennofs> {AS}: so you can use whatever extension you like in ...
08:27:21 <{AS}> bennofs: Ah, thanks
08:36:34 <oliffia> why is "instance Foo a b => Bar a b" a decidability issue but "instance Baz a => Zork b" is not?
08:36:42 <oliffia> "instance Baz a => Zork a"*
08:37:25 <geekosaur> multiparameter typeclasses are problematic in general
08:38:35 <glguy> oliffia: Both of those are decidability issues
08:38:46 <oliffia> the compiler only warns me about the former
08:38:48 <glguy> but different, what's 'a'?
08:39:21 <oliffia> if i have neither a nor b reference a, b, Foo, or Bar will I be okay mostly?
08:39:56 <glguy> I'm guessing that your Baz Zork example isn't what you actually gave to the compiler
08:40:08 <glguy> but I think you've elided important details about why it works and the other one doesn't
08:41:11 <oliffia> i havent tried to make instances of them
08:41:45 <oliffia> oh i *do* get the warning for both, nevermind :P
08:44:15 <Cale> Even if they weren't decidability issues, instances like that would overlap with absolutely everything, so if you're tempted to write them, probably you don't want to be using type classes.
08:44:30 <eacameron> is it easy to make my monad a monad transformer?
08:44:39 <Cale> eacameron: Depends.
08:44:46 <eacameron> Cale: on?
08:44:51 <Cale> What your monad is
08:44:55 <glguy> ^_^
08:45:07 <eacameron> Cale: well, in my case, it's just a ReaderT Something
08:45:14 <Cale> Then yeah, it's easy
08:45:32 <Cale> Because it already is one :P
08:45:51 <eacameron> it is?
08:46:04 <Cale> ReaderT Something is already a monad transformer
08:46:41 <Cale> If you newtype that, you can use newtype deriving to get the instance of MonadTrans for your newtype
08:47:11 <glguy> eacameron: It might help to paste the type in question to make sure you aren't omitting details that make the question more interesting
09:03:13 <NikolajK> okay, so something is wrong with the argument on the haskellwiki/Hask page. Let's clarify first: What is the list of Haskell functions for which "f" is "\x->f x" fails on the value level? (undefined being one example)
09:05:11 <NikolajK> The wiki article argues that f.id=g "might be a problem", but that's not true
09:06:52 <Cale> NikolajK: undefined
09:07:06 <Cale> > (undefined :: Int -> Int) `seq` 0
09:07:08 <lambdabot>  *Exception: Prelude.undefined
09:07:17 <Cale> > ((\x -> undefined x) :: Int -> Int) `seq` 0
09:07:19 <lambdabot>  can't find file: L.hs
09:07:21 <Cale> > ((\x -> undefined x) :: Int -> Int) `seq` 0
09:07:23 <lambdabot>  0
09:07:48 <Cale> NikolajK: ^^ seq allows for undefined and const undefined to be distinguished, which screws things up a bunch
09:11:05 <NikolajK> okay thx
09:13:00 <NikolajK> I'd change the Hask article in that a) the first paragraph, which looks like a definition of Hask, should already contain the extensional identification of functions to be morphisms. also, the last sentence of the second paragraph claims \_ -> undefined corresponds to a morphism, which is wrong without further type annotations.
09:14:04 <NikolajK> "Thus undef1 and undef2 are different values, but the same morphism in Hask" … while both are polymorphic as defined above, they are not term of any hom-set
09:15:10 <arossouw> is haskell just an academic language, or can it be considered a production ready?
09:16:16 <NemesisD> arossouw: both. there are definitely companies using it in the wild
09:16:32 <Taneb> arossouw, I really want to answer that with "yes"
09:16:42 <NemesisD> finance is a common one it seems
09:16:45 <arossouw> i'm very addicted to haskell, just find it a steep learning curve
09:17:19 <NemesisD> arossouw: that it is. that may have something to do with its industry adoption
09:17:24 <clrnd> arossouw, addicted is the proper term, I'm finding myself in a simillar situation
09:17:30 <Taneb> More seriously, while it does have some deficiencies, there are companies using Haskell in the wild, it seems investment banking is the most commo
09:17:31 <Taneb> n
09:17:35 <NemesisD> but I think it is a worthwhile language to learn despite the curve
09:17:38 <josephle> haskell has decent optimizations, is fairly stable, and has robust libraries
09:17:51 <josephle> I would think it is "production ready" :)
09:18:01 <arossouw> haskell is beautifull :-)
09:18:03 <josephle> well s/haskell/ghc/
09:18:06 <clrnd> it's more production ready than php, at least
09:18:09 <NemesisD> performance has a lot of meanings. for instance: haskell will typically beat the pants of of anything i write in ruby
09:18:30 <codile> clrnd: :D
09:18:33 <TallerGhostWalt> streaming video is really hard in haskell
09:18:35 <TallerGhostWalt> so no
09:18:57 <NemesisD> TallerGhostWalt: that's surprising to me actually, except if the reason is library support. Haskell has lots of stuff for streaming
09:19:13 <NemesisD> streaming in the generic sense
09:19:27 <TallerGhostWalt> NemesisD: Yeah, lib support is what is driving me nuts right now
09:19:41 <arossouw> josephle: thanks, i hope haskell becomes mainstream someday, it just makes sense
09:20:30 <arossouw> i'm confused on building parsers, some say bytestrings are evil, which i dont disagree with, but its much faster
09:21:32 <arossouw> the documentation on building parsers with Data.Text is lacking, maybe someone can enlighten me
09:21:58 <NemesisD> arossouw: i like attoparsec for parsing
09:22:10 <NemesisD> except for the error handling
09:22:24 <arossouw> i also used attoparsec, but i dont know when to use bytestrings or data.text
09:22:40 <josephle> text is when you want to do string manipulations
09:22:47 <glguy> use text when you're parsing text and use bytestring when you're parsing a binary format
09:23:31 <arossouw> glguy: what can be considered as binary format?
09:24:18 <NemesisD> i recently worked on a uri parser in bytestrings, it was not nearly as nice as working with text but the spec for URI did not require the use of text, and bytestring was what was coming off the wire
09:24:35 <arossouw> i've seen a benchmark where data.text is really slow, compared to bytestrings, but i also had a thought that if the code is more efficient, in other words using less resources, whats the problem
09:24:41 <pjdelport> arossouw: Who says bytestrings are evil?
09:25:21 <arossouw> pjdelport: someone mentioned that bytestrings don't catcht utf-8 encoded files, it misses characters
09:25:28 <glguy> One where the format specifies the encoding of the content at a byte and word alignment, say an mp3 file or zip file or various network packet formats
09:25:30 * hackagebot binary-typed 0.2.3 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.2.3 (quchen)
09:25:32 <arossouw> s/catcht/catch/g
09:25:57 <pjdelport> arossouw: Oh, yes; bytestrings are just binary data, not Unicode text.
09:26:36 <arossouw> i'm trying to understand the difference between binary and unicode, can someone illustrate basic example
09:26:46 <pjdelport> arossouw: You would UTF-8 decode a bytestring to Text to work on it as text, and then UTF-8 encode it back to ByteString for stuff that wants that.
09:27:01 <pjdelport> arossouw: It's like bytes versus str in Python, or so on.
09:28:22 <arossouw> pjdelport: do you have an example or some link that i can see example of utf-8 decode to bytestring to text and encoding back to bytestring?
09:28:42 <SwashBuckla> http://learnyouahaskell.com/input-and-output#bytestrings
09:28:51 <SwashBuckla> I was just reading about these in LYAH!
09:28:56 <SwashBuckla> cool stuff
09:29:07 <arossouw> thanks
09:29:43 <pjdelport> arossouw: http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Encoding.html
09:33:37 <arossouw> just quick question, if you define a haskell function and the data doesn't conform to the type , how would you catch the errors to log file ?
09:33:59 <NikolajK> after writing function extensionality right in the Hask definition, I'd make this the second paragraph: http://pastebin.com/2g6jsXbm
09:36:52 <nclarke> arossouw: I'm not sure what you mean. Such a program wouldn't compile
09:37:01 <nclarke> Unless you're doing unsafe casts and things
09:37:24 <arossouw> if youre passing data to a function and the data happened to be malformed
09:37:37 <naudiz> Does anyone know how to increase upload limit within Yesod?
09:38:16 <pjdelport> arossouw: Your parsing function would have to define its error behavior.
09:38:32 <nclarke> arossouw: As in the memory has become corrupted? Or you are parsing this from somewhere?
09:38:47 <pjdelport> arossouw: A common strategy would be to return Maybe or Either: the code that uses the result has to explicitly decide how to handle a failed parse.
09:39:05 <nclarke> If your data is being corrupted in memory, I would typically expect a runtime error and crash: you can redirect stderr to a file outside of the program
09:53:26 <wcaleb> i could use help with a particular function, isPageFile: https://github.com/wcaleb/gitit/commit/4cee2e4bc5c2a657801c374dd72f77507866d872
09:53:57 <wcaleb> as you can see, i've modified the function so that it's type has changed from FilePath -> Bool to FilePath -> GititServerPart Bool
09:54:20 <wcaleb> but it would really help in the rest of the codebase if I could somehow reduce this back to FilePath -> Bool here
09:55:33 * hackagebot network-wai-router 0.3.0.1 - A routing library for wai  http://hackage.haskell.org/package/network-wai-router-0.3.0.1 (georgerogers42)
09:56:11 <wcaleb> GititServerPart is a type synonym defined here: https://github.com/wcaleb/gitit/blob/cfgPageExtension/Network/Gitit/Types.hs#L409
09:57:00 <wcaleb> someone on IRC yesterday suggested to get the Bool value from GititServerPart, id need to do the GititServerPart action on Bool, but as a newbie, I'm struggling to do that
09:59:00 <oliffia> do i have to do something other than enable -XUnicodeSyntax to get C☺ to be a valid identifier? im getting   parse error on input `<stderr>: commitBuffer: invalid argument (invalid character)
09:59:22 <nclarke> I don't think you can mix letters and unicode symbols
09:59:48 <nclarke> E.g. C: is not a valid identifier
10:00:22 <oliffia> :C
10:00:50 <merijn> oliffia: Unicode is natively supported, BUT unicode operator symbols can only be part of operators and unicode letters can only be part of VarId/ConId
10:01:16 <bennofs> > generalCategory '☺'
10:01:18 <lambdabot>  OtherSymbol
10:01:25 <bennofs> > generalCategory '+'
10:01:27 <lambdabot>  MathSymbol
10:01:39 <oliffia> i wanted to have an enumeration of code page 437 characters like i can in scala
10:01:46 <merijn> oliffia: For exact details, consult the report: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
10:02:23 <oliffia> i wonder if TH could help me...
10:04:10 <merijn> TH can't generate invalid syntax, you could use a newtype wraper around Char for your enumeration? Depends what you wanna use it for
10:04:33 <oliffia> could TH find a unicode symbol, perhaps wrapped in additional syntax, and transform its name to something valid?
10:04:59 <slack1256> Any way to exit the program from a nested IO call? I would prefer not to use the Cont monad for such effect
10:05:16 <merijn> slack1256: Define "exit"?
10:05:18 <oliffia> i want to be able to put something similar to ☺ in my file and have it be CodePoint 1 '☺' '\u2631'
10:05:36 * hackagebot cabal-bounds 0.8.2 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.2 (DanielTrstenjak)
10:05:36 <merijn> slack1256: You mean crash? Normal program termination?  or what
10:06:02 <merijn> oliffia: What's stopping you from just writing '☺ '?
10:06:12 <merijn> > let x = '☺ ' in succ x
10:06:14 <lambdabot>  <hint>:1:10: parse error on input ‘☺’
10:06:17 <merijn> oh, wait
10:06:22 <merijn> lambdabot doesn't do unicode >.>
10:06:32 <slack1256> crash should be
10:06:32 <Iceland_jack> > let x = '☺' in succ x
10:06:34 <lambdabot>  '\9787'
10:06:39 <Iceland_jack> merijn: extra space
10:06:51 <Iceland_jack> > let x = '☺' in char (succ x)
10:06:53 <lambdabot>  ☻
10:06:53 <oliffia> i want it to be members of a type
10:07:00 <oliffia> a member of*
10:07:03 <merijn> oliffia: You can't
10:07:11 <slack1256> as in the funtion that parses returned IO (Either ConfigError a), and there is a Left value and I want to terminate the program right there.
10:07:15 <slack1256> *function
10:07:15 <oliffia> okay, too bad. thanks
10:07:36 <merijn> slack1256: System.Exit
10:09:18 <oliffia> how do i see what code CPP generated?
10:10:22 <merijn> I think ghc just supports -e like gcc?
10:10:46 <oliffia> unrecognized command
10:10:55 <enthropy> -ddump-something
10:11:18 <enthropy> possibly -ddump-prep
10:12:09 <slack1256> merijn: This is just what I needed, that shows me the value of knowing your standard library. Thanks
10:13:55 <enthropy> oliffia: worst case you can call ghc with -v and it'll show you what it calls the cpp with
10:17:15 <oliffia> figured it out, -v -keep-tmp-files :)
10:17:16 <oliffia> thanks
10:17:26 <oliffia> (-v to find the name of it)
10:18:53 <SrPx> Is there any syntax for pattern matching, but also giving a name to the whole matched expression? Ie, `foo (x:xs) = let list = x:xs in ...`
10:19:18 <oliffia> so theres simply no way to turn ☺ into a legal identifier at compile time (like smiley or whatever) using quasiquotes/TH?
10:19:28 <bam365> let whole@(x:xs) = ...
10:19:50 <alcabrera> SrPx: yes. they're know as as-patterns. bam365 gave the syntax above. :)
10:20:11 <SrPx> alcabrera: bam365: yes, that worked. Thanks guys.
10:20:37 <merijn> oliffia: You can turn it into a legal identifier, but only for operators
10:20:38 * hackagebot imm 0.6.0.2 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir.  http://hackage.haskell.org/package/imm-0.6.0.2 (koral)
10:21:00 <merijn> > let (☺) = (+) in 1 ☺ 2
10:21:02 <lambdabot>  3
10:21:09 <oliffia> and then compile
10:25:39 * hackagebot cabal-bounds 0.8.3 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.3 (DanielTrstenjak)
10:40:40 <Johnner> hi guys
10:40:41 * hackagebot lit 0.1.0.0 - A simple tool for literate programming  http://hackage.haskell.org/package/lit-0.1.0.0 (cdosborn)
10:40:48 <Cale> Hello!
10:41:09 <Johnner> sup :)
10:41:16 <sm> hello Cale
10:42:45 <johnw> hello all
10:44:13 <vanila> hi
10:44:34 <cmisenas> Hello
10:45:39 <dmj> hey
10:45:41 * hackagebot lit 0.1.0.1 - A simple tool for literate programming  http://hackage.haskell.org/package/lit-0.1.0.1 (cdosborn)
10:55:33 <WraithM> Hello!
10:55:42 <NikolajK> hi
10:56:06 <WraithM> dmj: You got rid of your signature `
10:56:24 <dmj> WraithM: it fell off
10:56:28 <WraithM> lol
10:56:44 <dmj> WraithM: jle` took it
10:58:21 <jle`> :/
10:58:23 <jle`> ;_;
10:58:30 <jle`> we are no longer ` buddies
10:59:06 <dmj> jle`: :(
10:59:17 <jle`> we are still life buddies tho
10:59:23 <jle`> or maybe both in the three letter club
10:59:26 <jle`> ...if i count
10:59:54 <dmj> this is true, our friendship transcends backticks
11:03:29 <johnw> I wondered who dmj was
11:04:07 <dmj> johnw: :) the backtick makes for good camo
11:04:59 <Mathnerd314> so why is UNPACK not called PACK? PACK seems like a much better name
11:05:23 <johnw> if you think of a "box" as being like a "package", then unpack gets rid of the box
11:05:43 * hackagebot lit 0.1.0.2 - A simple tool for literate programming  http://hackage.haskell.org/package/lit-0.1.0.2 (cdosborn)
11:06:19 <MagneticDuck> the "applicative-monad" proposal make instances of a datatype as Monad but not Applicative
11:06:41 <MagneticDuck> ?
11:07:37 <Mathnerd314> johnw: but if you think of memory as being like a suitcase, then "unpack" puts stuff strictly into memory
11:08:07 <Mathnerd314> johnw: whereas box puts in little pieces of paper that say "IOU"
11:08:26 <johnw> if memory is the suitcase, and unpack puts stuff into memory, then I don't get the analogy...
11:08:57 <Mathnerd314> exactly... it should be called 'pack' :-)
11:09:36 <NikolajK> is "Contraint" a kind?
11:09:36 <NikolajK> :k Functor
11:09:38 <lambdabot> (* -> *) -> Constraint
11:09:48 <lpvb> A burrito is missing here somewhere.
11:09:52 <johnw> NikolajK: yes
11:09:59 <jle`> :k forall a. Functor a
11:10:00 <lambdabot> Constraint
11:10:14 <MagneticDuck> lenses are like space suits stuffed full of burritos
11:10:19 <MagneticDuck> ^ brilliant analogy
11:10:21 <codile> )lol
11:10:24 <NikolajK> what are kinds, other than *, Constraint, and their closure using ->
11:10:25 <MagneticDuck> you can quote me but you have to give me rights
11:10:25 <edwardk> and toxic waste, lit on fire
11:10:39 <codile> MagneticDuck: which rights?
11:10:40 <johnw> NikolajK: we have the master of kind manipulation right here
11:10:46 <MagneticDuck> codile: all of them!
11:10:54 <NikolajK> who would that be
11:10:54 <codile> "lenses are like space suits stuffed full of burritos
11:10:55 <johnw> NikolajK: kind are a bit like "type spaces"
11:11:03 <codile> "lenses are like space suits stuffed full of burritos" - Thomas Jefferson
11:11:08 <johnw> NikolajK: a kind of * is the kind of any concrete type
11:11:10 <jle`> that burrito's name?
11:11:12 <jle`> albert einstein
11:11:16 <codile> XD
11:11:27 <johnw> NikolajK: a kind of Foo is the kind of data constructors of Foo promoted to the type level
11:11:33 <codile> and then it rained 100 bills and condoms
11:11:41 <johnw> NikolajK: a kind of Constraint is the kind of all typeclass constraints, etc.
11:11:44 <Zekka> :k Constraint
11:11:45 <lambdabot>     Not in scope: type constructor or class ‘Constraint’
11:11:45 <lambdabot>     Perhaps you meant ‘Contains’ (imported from Control.Lens)
11:11:45 <Mathnerd314> NikolajK: there's #, the type of unboxed things. And then jhc has a lattice for *, #, Constraint, etc. with ?? as the top IIRC
11:11:49 <edwardk> NikolajK: you can make other kinds with the DataKinds extension
11:12:13 <johnw> there is even kind polymorphism, where you can specify kind variables as you might type variables in a definition
11:12:59 <Mathnerd314> NikolajK: see http://repetae.net/computer/jhc/manual.html#jhc-core-type-system
11:13:07 <edwardk> NikolajK: Also, # is the kind of unboxed data types, where you can't do polymorphic things. We used to have other kinds for unboxed tuples, but thats gone now, there is a limited notion of subkinding employed to let (->) take and return # as well as *, and (a,b) can be a Constraint if a and b are constraints as a syntactic hack in the typechecker
11:13:07 <NikolajK> "a kind of Foo", "a kind of Constraint", I don't know to read this
11:13:29 <Zekka> NikolajK: The same way you read "a type of [x]"
11:13:50 <NikolajK> x being a term?
11:13:52 <edwardk> kinds are 'the types of types'
11:13:57 <lazyboy> hi every
11:14:02 <johnw> "Functor is a kind of Constraint" means just what it does in both English and Haskell
11:14:16 <benzrf> Functor has kind * -> Constraint
11:14:18 <benzrf> :k Functor
11:14:19 <lambdabot> (* -> *) -> Constraint
11:14:21 <benzrf> er
11:14:22 <Zekka> Oh, wait, I misunderstood the context
11:14:22 <johnw> ah, yes, sorry
11:14:23 <benzrf> oops
11:14:28 <edwardk> i'd say that Functor is a type of kind (* -> *) -> Constraint
11:14:46 <Zekka> I thought people were talking about "the kind of Constraints" and similar expressions
11:14:47 <NikolajK> I'm confuse
11:15:01 <NikolajK> Functor has kind (*->*)->Constraint, right
11:15:08 <johnw> "Functor is the kind of type constructors taken as Constraints"
11:15:13 <johnw> I misspoke
11:15:13 <edwardk> other folks reserve 'type' for types of kind *, and call all other types type constructors, but i find that terminological distinction not very useful and prefer to refer to types of all kinds as types, and call type constructors the things that start my types, Maybe, Int, etc.
11:15:16 <Zekka> "x is a kind of y" meaning "y is x's kind" is analogous to "y is x's type"
11:15:33 <johnw> taken to*
11:15:51 <edwardk> i'd usually say 'x is of kind y'
11:15:54 <gratimax> I just thought i understood kinds, now this conversation happened
11:15:59 <Zekka> NikolajK: Yeah.
11:16:13 <johnw> gratimax: hahaha
11:16:21 <johnw> gratimax: haven't I been there a million times
11:16:21 <Zekka> So let's say you write (Functor f) => a -> f a
11:16:35 <NikolajK> "x is a kind of y" meaning "y is x's kind" … that can't be good terminology
11:16:42 <edwardk> NikolajK: its not =)
11:16:49 <Mathnerd314> edwardk: but doesn't that mean that e.g. '1' is a type?
11:16:59 <edwardk> Mathnerd314: sure, 1 is a type of kind Nat.
11:17:01 <johnw> :k 1
11:17:02 <lambdabot>     Illegal literal in type (use DataKinds to enable): 1
11:17:03 <edwardk> we have a Nat kind.
11:17:14 <johnw> if DataKinds were enabled it would have said Nat
11:17:31 <Zekka> For that to typecheck we need f to be a * -> * (so that the left side kindchecks into a constraint)
11:17:41 <Zekka> and we need f to be a functor (so the constraint's actually met)
11:17:43 <johnw> thus letting you do things like: data Foo :: (Nat -> *), such that Foo is a type family indexed by natural numbers
11:17:55 <edwardk> it doesn't have any terms because its not an 'inhabited type', like * or # or Constraint where you can talk about what it does, but you can pass it to other types to get to an inhabited type where you have terms or dictionaries or whatever
11:17:57 <Mathnerd314> edwardk: so what happened to the simple convention of calling 1 a value?
11:18:09 <Zekka> Is this a correct description? I don't often work with kinds but I thought I uderstood them
11:18:10 <edwardk> Mathnerd314: no, 1 is a value, but there is also a type named 1 as well
11:18:38 <NikolajK> I don't quite get Functor being (*->*)->Constraint. What is the point of the second ->?
11:18:48 <MitchellSalad_> what's a kind's type called? a sort?
11:19:07 <Zekka> NikolajK: Things that go on the left side of an => are called constraints
11:19:20 <Zekka> so that says that Functor takes a (* -> *) and gives you  a thing that goes on the left side of a =>
11:19:30 <edwardk> Mathnerd314: data Vec (n : Nat) (a :: *) where Zero : Vec 0 a; Succ :: a -> Vec n a -> Vec (n + 1) a -- notice the constructor references +, etc. we have a type Nat, with inhabitants that look like numbers and a solver for them and stuff
11:19:37 <gratimax> the (*->*) is the kind of a typeclass that you can apply the Functor constraint to
11:19:48 <gratimax> and when you do(second ->), you get a Constraint
11:19:56 <Zekka> gratimax: You mean the kind of a type, right?
11:20:17 <edwardk> NikolajK: Functor takes an argument of kind (* -> *) and gives back something of kind Constraint.   you can use constraints on the left hand side of => in haskell, which if we could write it in isolation would look like (=>) :: Constraint -> * ->*
11:20:21 <gratimax> yeah, sure
11:20:22 <Zekka> in `Functor f =>`, isn't f a type?
11:20:46 <edwardk> Zekka: f has kind * -> * there. Functor takes that and gives back something of kind Constraint, then => expects a Constraint on its left hand side
11:21:00 <edwardk> Zekka: that is how that kind checks
11:21:00 <NikolajK> :k (=>)
11:21:01 <lambdabot> parse error on input ‘=>’
11:21:04 <Zekka> edwardk: That's what I thought: gratimax said f was a typeclass, which confused me
11:21:10 <edwardk> NikolajK: you can't write it directly
11:21:12 <gratimax> true. I use typeclasses most of the time though so I think the terms are interchangeable, when they shouldn't be
11:21:23 <johnw> if anyone is further interested in this discussion on kinds, I highly recommend: http://dl.dropbox.com/u/137615/Fun%20with%20kinds%20and%20GADTs.pdf
11:21:26 <edwardk> NikolajK: but if such a beast could typecheck then that would be its kind
11:21:31 <Zekka> because last I checked if you refer to a typeclass inside a typesig they generally have kind ? -> Constraint?
11:21:36 <edwardk> NikolajK: in fact, i have a constructed form of (=>) around, lemme see
11:21:38 <johnw> "Fun with Kinds and GADTs", a presentations on these extensions
11:22:00 <Zekka> Can you use evil to define HolyHell :: ((* -> *) -> Constraint) -> Constraint
11:22:16 <edwardk> NikolajK: https://github.com/ekmett/hask/blob/master/old/src/Hask/Constrained.hs#L28 -- see the kind of (|-) from the comment, that is basically (=>) wrapped up so i can talk about it
11:22:17 <merijn> Zekka: That doesn't even require evil
11:22:25 <NikolajK> okay, so how does "Functor Maybe" return a Constraint? The word alone is not much, is it?
11:22:26 <merijn> Zekka: That's pretty simple to define using TypeFamilies
11:22:33 <edwardk> Zekka: that isn't even evil
11:22:38 <ian_mi> Does anyone know how the progress on Explicit Type Application is going?
11:22:47 <ian_mi> I would like to try kind-indexed type classes
11:22:53 <Zekka> Really? Maybe my standards of evil are misguided
11:22:54 <edwardk> @let class f (g a) => ComposeC f g a; instance f (g a) => ComposeC f g a;
11:22:55 <lambdabot>  Parse failed: Illegal class assertion
11:22:58 <edwardk> shucks
11:23:04 <ian_mi> They seem almost necessary for working with PolyKinds
11:23:09 <edwardk> anyways that works with constraint kinds turned on
11:23:17 <Iceland_jack> ian_mi: Have you looked at the singletons library?
11:23:26 <edwardk> and you get                ComposeC :: (j -> Constraint) -> (i -> j) -> i -> Constraint
11:23:30 <edwardk> and it is _useful_
11:23:37 <ian_mi> Iceland_jack: a bit, yes
11:23:42 <Iceland_jack> They do: class (a ~ Any) => SingKind (a :: k) where
11:24:01 <edwardk> Iceland_jack: we have newer ways to encode that, no need for the Any hack any more
11:24:12 <Zekka> edwardk: I think I understand that.
11:24:14 <Iceland_jack> How is it encoded now
11:24:28 <Zekka> It's just a specialization of composing type-level functions?
11:24:32 <NikolajK> okay, so if I can't enumerate all basic block I can form kinds with, at least is "->" the only non-primitive thing to construct kinds?
11:24:48 <edwardk> Iceland_jack: you make a newtype KProxy a = KProxy -- and then take a type of kind KProxy a instead, which is always 'KProxy
11:24:51 <ian_mi> Is it possible to simulate class Functor f (domain :: BOX) (codomain :: BOX) ?
11:24:59 <Zekka> (i.e. you  might be able to define a more general ComposeC' :: (j -> k) -> (i -> j) -> (i -> k) ?)
11:25:01 <Iceland_jack> Ah I see
11:25:07 <edwardk> NikolajK: you can make data kinds up that let you compose them in other ways
11:25:09 <MitchellSalad_> i believe without any extensions turned on the only kinds/kind constructors are *, #, and ->
11:25:31 <NikolajK> and Constraints?
11:25:41 <NikolajK> "Constraint"
11:25:42 <edwardk> Given a of kind j,   and b of kind k  then '(a,b) has kind (j,k)
11:26:07 <NikolajK> so products kinds are a thing too
11:26:20 <Zekka> Is there a type analogue for kinds?
11:26:34 <edwardk> or given a, b, and c  of kind x then (a ': b ': c ': '[])  has kind [x]
11:26:36 <Zekka> (and do we ever deal with it when we use Haskell?)
11:27:01 <NikolajK> okay, thx all, I go eat sushi
11:27:21 <edwardk> Zekka: the problem with that is while i can define it by abusing Any madness (and have) we lose the Any trick to encode it in 7.10, and it is evil in that it makes a new distinguished inhabitant of every kind.
11:27:42 <johnw> it's a bit like the "undefined" of kinds...?
11:27:56 <Zekka> edwardk: You mean the problem with ComposeC'?
11:27:59 <edwardk> so you'd have kind Bool inhabited by True, False and now Compose f g where (f :: i -> Bool)
11:28:05 <edwardk> er
11:28:10 <edwardk> and now Compose f g a
11:28:11 <JohnTalent> instance Eq Foo where (F i1) == (F i2) = i1 == i2    how is this evaluated
11:28:13 <Zekka> or Compose if you're calling it that?
11:28:14 <edwardk> and you could case match on that
11:28:16 <benzrf> gompose
11:28:18 <ian_mi> I am trying to implement categories k -> k -> * for any kind k. The problem is if I define an instance Functor f, the family Domain f has kind forall k. k -> k -> * when I really want to specify the kind k
11:28:30 <johnw> JohnTalent: the '=' has higher precedence than the '=='
11:28:34 <edwardk> Zekka: this is something i abuse in earlier versions of hask actually, but its deeply unsettling =)
11:28:36 <johnw> JohnTalent: also, the parens are unnecessary in that example
11:28:52 <edwardk> so i've been working on ways to adjoin extra inhabitants like that without infecting the original kind
11:28:59 <edwardk> which is hard
11:29:03 <JohnTalent> johnw: okay. thanks.
11:29:23 <Zekka> I'm a little confused about where the evil actually comes from
11:29:25 <Zekka> let me try to restate it
11:29:36 <edwardk> Zekka: you can hang instances on it
11:30:10 <Zekka> Basically Compose f g a is a Bool (where we're talking about Bool the kind), but  you can in some cases treat it as a different entity from the normal inhabitats of Bool?
11:30:22 <edwardk> Zekka: you lose the ability to know that all inhabitants of kind (j,k) look like '(a,b) so you can't look at x : (j,k) and blow out x to '(x',x'') for x' in a and x'' in k
11:30:37 <edwardk> Zekka: because now Compose is a new _distinguished_ inhabitant of Bool
11:30:39 <edwardk> you can write a type family
11:31:00 <Zekka> 'distinguished' meaning that when you i.e. pattern match over it it's a separate pattern from conventional patterns?
11:31:16 <edwardk> but you can't write that as a data type or a data family (if we extend data families to allow open kinds on the end, due to the generativity of data families)
11:31:27 <Zekka> so you basically have no guarantee that matchcing over True and False is acctually exhaustive?
11:31:32 <edwardk> Zekka: exactly
11:31:39 <edwardk> bbiab, meeting
11:31:49 <Zekka> Alright. I may be gone by then, I have something in about a half hour
11:33:42 <bmuk> Is there semantic highlighting for haskell in emacs or any other editor?
11:34:19 <Zekka> bmuk: When you say "semantic highlighting", what do you mean?
11:34:47 <Zekka> I don't know any editors that do more than just lexing right offhand but there's probably a few that accumulate at least a little context
11:35:02 <Zekka> (I don't use Emacs and can't really comment on that)
11:36:07 <bmuk> Instead of highlighting differences in syntax such as making variables a different color than functions, code is colored more by the scope in which it was defined, or something like this - https://medium.com/@evnbr/coding-in-color-3a6db2743a1e
11:36:54 <Zekka> bmuk: I don't know any editors that do that, although it looks really useful
11:38:12 <bmuk> I guess it's pretty new - I found a sublime plugin but I've put so much time into emacs I can't see myself switching because of that
11:38:35 <bmuk> I might try on the emacs irc, just figured I'd ask here first since it would have to be haskell specific
11:38:49 <arianvp> bmuk: write one :D
11:38:54 <arianvp> >:)
11:38:58 <arianvp> i'd use it
11:39:07 <arianvp> wait I wouldn't. im a vim user. but still, would be cool.
11:39:20 <bmuk> haha I might just do that!
11:40:11 <Zekka> It reminds me functionally of the role of i.e. paren coloration in lisp editors
11:40:22 <arianvp> yeh. like rainbow-parens
11:40:40 <arianvp> well basically it'd be the exact same thing. haskell being lexically scoped helps as well
11:40:46 <bmuk> Yes! I use rainbow-parens a lot when working with lisps
11:41:02 <Zekka> My current lisp editor colors i.e. function definitions with red-to-brown and expressions with shades of blue and green
11:41:08 <Zekka> which makes it really easy to figure out the structure
11:41:18 <Zekka> It doesn't do anything for variable names although IMHO it would be very useful for it to do that
11:41:45 <arianvp> Zekka: though that would only worked in a statically-scoped lisp
11:42:13 <arianvp> s/worked/work
11:42:28 <bmuk> Is there some lispified haskell? I.e. you write haskell code in an ast?
11:42:29 <Zekka> arianvp: I'm guessing you could infer pretty often where a variable is defined just by inspecting the code but there may be edge cases where you can't
11:42:39 <Zekka> bmuk: I think so but I can't remember what it's called
11:42:50 <arianvp> bmuk: https://hackage.haskell.org/package/haskell-src-exts
11:43:33 <arianvp> iirc
11:46:00 <arianvp> ugh ubuntu. and my mouse stopped working
11:49:14 <MagneticDuck> who needs mice?!
11:50:48 * hackagebot clafer 0.3.6.1 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.6.1 (mantkiew)
11:57:36 <mdgeorge4153> Hi.  I'm trying to install a cabal package that needs an older version of glut than I have.  The older version doesn't compile
11:57:50 <mdgeorge4153> is there an easy way to allow it to use the newer version?
12:00:09 <bennofs> mdgeorge4153: if your cabal version that is recent enough, maybe --allow-newer works
12:00:12 <Iceland_jack> n
12:00:25 <mdgeorge4153> bennofs: let me try that
12:00:50 <mdgeorge4153> bennofs: on =(
12:00:54 <mdgeorge4153> bennofs: no =(
12:06:39 <mdgeorge4153> bennofs: not even with the version of cabal-install that is in cabal
12:15:51 * hackagebot lit 0.1.0.3 - A simple tool for literate programming  http://hackage.haskell.org/package/lit-0.1.0.3 (cdosborn)
12:20:51 <pjdelport> bmuk: There are a few, actually
12:21:23 <pjdelport> bmuk: https://github.com/haskell-lisp/liskell
12:21:30 <pjdelport> bmuk: https://github.com/haskell-lisp has a bunch of related projects
12:21:33 <pjdelport> (in theme)
12:21:44 <bmuk> pjdelport++
12:28:17 <fread2282> anyone know the status of DoCon?
12:30:51 <fread2282> (or another haskell CAS, if it exists)
13:04:37 <carette> is @Cale == cgibbard ?
13:04:50 <Cale> carette: yep :)
13:05:08 <johnw> can I get GHC to read command-line options from a file?
13:05:17 <johnw> I mean, for the ghc executable
13:09:52 <MagneticDuck> #bash4life
13:09:59 <MagneticDuck> johnw: ^ answer
13:10:08 <merijn> Hey, should the Xcode5 issues link maybe be amended that the new platform fixes everything?
13:12:45 <johnw> merijn: I think so
13:13:01 <johnw> MagneticDuck: I'm hitting a kernel limit, not a shell limit
13:19:20 <Ankhers> Does anyone know if there is already an initiative to built a Haskell driver for Aerospike?
13:24:56 <glguy> edwardk: Could you take a look at the lens build system on travis at some point, I think that the 7.8.2 build is using GHC 7.6.3
13:25:18 <edwardk> heh
13:25:19 <edwardk> sure
13:25:38 <glguy> also, is it possible to install some of the dependencies from packages rather than rebuilding the whole stack?
13:25:58 <glguy> You'd done some stuff to bootstrap with pre-built stuff at one point I think
13:27:40 <glguy> actually, they all appear to be building with 7.6.3 now...
13:28:10 <glguy> or maybe the output is just wrong, I'm not sure
13:31:36 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF' by ChanServ
13:55:49 <modeller> Question on Layout, report 2.7: "and if it is indented less, then the
13:55:49 <modeller> layout list ends (a close brace is INSERTED)". Does the INSERTION of "}" happen at BEGINNING of the line?
13:56:37 <merijn> modeller: } happens before the token that is indented less
13:57:06 <modeller> merijn: got it. thankx
14:00:52 <bb010g> > (42, Rev, Zalgo, Rev, "chaos")
14:00:54 <lambdabot>  (42,̳̣̫̅̌̑̈͛͋ͤ,̅ͥ͂͟"͇̭̞ͧͩ͊͗̅c̩̙̜̭ͨ͡h̴̠̣̤͉͇͚̒̆̈ạͧͫ͠ͅô̰̱̱s͑ͨ̔̈̂̏̐"̗̱̟̳̆̏̔̋̐͠...
14:01:03 * hackagebot hdaemonize 0.5.0.0 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.5.0.0 (FrederickRoss)
14:07:55 <vanila> http://kukuruku.co/hub/haskell/cellular-automata-using-comonads
14:08:08 <vanila> that's so cool!! Using things like comonads to make a difficult task simple
14:08:33 <edwardk> vanila: https://www.fpcomplete.com/user/edwardk/cellular-automata/part-1
14:08:43 <edwardk> there are a couple more parts that abuse comonads more and more
14:08:50 <vanila> oh this is the original!
14:09:40 <modeller>  Question on 2.7 of the report: "If the indentation of the non-brace lexeme immediately following a where, let, do or of is less than or equal to THE CURRENT INDENTATION LEVEL, ..".  DOES "the current indentation level" mean the indentation level of keyword where, let, do or of?
14:09:45 <edwardk> you can also click the 'run' button (not, Open in IDE, but the thing next to it!) to get it to work interactively in the browser.
14:10:11 <edwardk> modeller: it means the indentation level you were in before you went to open a new one
14:10:19 <edwardk> e.g. it starts at the top level of the file, left most column
14:14:10 <modeller> http://lpaste.net/109449
14:15:28 <modeller> edwardk: so when we are writing the body of 1st let, the CURRENT indentation level is what?
14:16:23 <edwardk> modeller: until you get to the first identifier past let      'b'   the starting indentation level is 0 way out in the left column, when you see the 'b' it becomes the indentation of the b.
14:16:27 <hpc> modeller: the indentation level is the first non-whitespace character after the let
14:16:31 <edwardk> now it stays there for that line and the c line
14:16:33 <hpc> so the column of 'b'
14:16:36 <edwardk> until you go 'offside'
14:16:40 <hpc> ditto for 'in'
14:16:41 <edwardk> then it moves back to column 0
14:16:59 <edwardk> then after the next let it starts up again at the column where the 'a =' starts.
14:17:01 <merijn> hpc: in doesn't introduce indentation
14:17:17 <edwardk> until you go offside with the second in, then the indentation level stays at 0
14:17:18 <merijn> hpc: Since the thing following 'in' is always a single expression anyway
14:17:30 <hpc> merijn: you can write one expression across multiple lines
14:17:34 <edwardk> in here is being used to go 'offside' by breaking out of indentation
14:17:37 <hpc> and the indentation rule continues
14:17:39 <edwardk> hpc: in doesn't introduce layout
14:17:39 <hpc> iirc?
14:17:50 <edwardk> hpc: where, do, let, of
14:17:51 <edwardk> thats it
14:17:54 <hpc> ah, k
14:18:05 <edwardk> in is being outdented to break layout
14:18:25 <merijn> hpc: You can write an expression that's multiple lines, but you only need to indent past the start of the indent before in
14:18:40 <edwardk> but then layout has a silly rule that says if you could avoid a syntax error by breaking layout you can do that too, so the in can be left over indented often  and it 'does the right thing'
14:18:43 <merijn> hpc: So here the indent should be further than bar, iirc
14:19:07 <modeller> So the "Current Indentation Level" is defined by the 1st lexeme (a.k.a token) after a KEYWORD.
14:19:30 <hpc> modeller: after the specific ones edwardk mentions
14:19:31 <edwardk> whatever the indentation level you currently have if you outdent to that level you get a virtual semicolon, if you outdent farther you go 'offside' and break the layout.
14:19:37 <merijn> modeller: After a *layout introducing* keyword
14:19:49 <merijn> modeller: The layout introducing keywords being where, do, let and of
14:19:50 <hpc> do guards count as layout?
14:19:59 <modeller> ok. added "layout introducing keyword"
14:20:06 <edwardk> so what modeller showed desugars to bar = let { b = 2 ; c = True } in let { a = b } in (a, c)
14:20:34 <merijn> hpc: No, they can be at anything from the same to further indent as their definition
14:20:45 <edwardk> guards have no special status
14:20:53 <modeller> I see. Great example.
14:20:55 <edwardk> we _tend_ to indent them like they do
14:21:01 <edwardk> but its style not substance
14:21:08 <modeller> "If the indentation of the non-brace lexeme immediately following a
14:21:08 <modeller> where, let, do or of is less than or equal to the current indentation level, then instead of starting a layout,
14:21:08 <modeller> an empty list “{}” is inserted, and layout processing occurs for the current l"
14:21:09 <edwardk> we just need to indent them farther than the start of the statement
14:21:22 <edwardk> otherwise you get ;'s in the middle which breaks things up in syntactically illegal ways
14:21:29 <modeller> but why the standard says add an EMPTY "{}"
14:21:31 <edwardk> so they have to be indented but they don't have to be aligned
14:22:05 <edwardk> modeller: you can write foo = blah where -- with an empty where clause, and it basically is self terminating. the next statement if its at the top level would end the where clause
14:22:10 <edwardk> as it goes offside
14:22:51 <merijn> modeller: In practice, as long as you write sanely formatted code and use spaces it "Just Works" (TM)
14:22:52 <edwardk> some things handle empty clauses gracefully, e.g. where, let but empty cases used to be disallowed (now requiring an extension) and an empty do block is nonsense.
14:23:20 <modeller> edwardk:  bar = let {}{ b = 2 ; c = True }
14:23:20 <modeller> 	  in let {} { a = b } in (a, c)
14:23:29 <modeller> did I add the {} correctly?
14:23:57 <modeller> If I am to literally follow the rule.
14:24:27 <modeller> ops. ignore that
14:24:36 <modeller> it is not less than the current indentation level
14:24:58 <modeller> I like the empty where example
14:26:06 * hackagebot hapistrano 0.1.0.2 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.1.0.2 (jsl)
14:27:27 <modeller> merijn: thanks for the comments too. I agree writing sanely following the format is better.
14:28:04 <modeller> Just wanted to literally understanding the rule, in case I see some evil code (but follow the rule)
14:28:21 <modeller> then I know  how to apply detailed analysis
14:31:20 <modeller> In the 2nd definition, did I add {} correctly? http://lpaste.net/109450
14:32:25 <modeller> The concern is that in the 2nd "let", the following "a" is less indented than let, correct?
14:34:16 <merijn> modeller: tbh, I don't think there's more than a handful of people that know how that is parsed :)
14:34:44 <merijn> modeller: I would say "try running GHC on it" and see what (if anything) it complains about :)
14:35:13 <modeller> merijn: I see.
14:37:43 <merijn> modeller: The most evil layout I've ever encountered in "real" code was like 10 times less difficult than that. You're already in "obfuscated haskell" territory :)
14:41:52 <Cale> modeller: no, that's incorrect. It should be  let { b = 2 ; c = True } in let { a = b } in (a,c)
14:42:06 <Cale> oh
14:42:19 <Cale> he disconnected *right* before I sent my message :P
14:43:28 <hpc> does that even work?
14:43:35 <hpc> :t let {}a=5 in a
14:43:37 <lambdabot> parse error on input ‘a’
14:43:51 <Cale> Yeah, his version with {} doesn't work
14:45:21 <Cale> For anyone who doesn't already know, the way it works is that the first non-whitespace character after 'let', 'do', 'of', or 'where' sets the starting column for the block, and effectively a { is inserted before this point. Each subsequent line which starts in that column will continue the block, and be separated by semicolons. If a line starts in a deeper column, it's treated as a continuation of the previous line (an
14:45:21 <Cale> d no semicolon is placed). If a line starts in a shallower column, the block is closed with }
14:57:19 <trap_exit> https://gist.github.com/anonymous/34e4c0dbd0ea494e7402 <-- why do I get parse error on ')' ?
14:57:22 <trap_exit> is (+') :: illegal ?
14:57:39 <prophile> I don't think ' is legal in operators?
14:57:52 <spaceloop> indeed
14:58:07 <trap_exit> damn it
14:58:12 <trap_exit> someone lied to me yesterdahy
14:58:20 <trap_exit> I wanted a + that was Vec2 -> BoundingBox -> BoundingBox
14:58:23 <trap_exit> and they suggested I use +. or +'
14:58:27 <trap_exit> but +' is llegal :-(
15:16:01 <grache28> I just need someone to give me a little insight into this 2 lines of code: http://lpaste.net/109452
15:18:29 <twanvl_> grache28: what kind of insight do you need? do you know what the function is supposed to do?
15:18:51 <grache28> the type is : a -> (b -> b) -> b -> b ; The first a is 'n', (b->b) is f, the next b is x, and the last b is what it returns. Functions have precedence over all other operators, so ap 2 ((ap 2) (+5)) 0
15:20:13 <grache28> First calls the nested (ap 2), which it partially applies (curries, no?) then takes the (+5), curries again, .... then goes back to the initial ap 2 ??
15:20:35 <vanila> grache28, f ( ( ap (n-1) f) x) this is hard to read
15:20:45 <napping> it might be clearer written like ap 0 f = id; ap n f = f . ap (n-1) f
15:20:50 <grache28> vanila: tell me about it ;) it's not my code
15:20:51 <vanila> it should be written:  f (ap (n-1) f x)
15:21:02 <grache28> tks vanila  napping
15:21:07 <vanila> now you can see that for example  ap 3 f x = f (f (f x))
15:21:22 <napping> and app 2 . app 3 = app 6
15:22:21 <grache28> sorry, google sucks when searching for operators that are punctuation
15:22:29 <grache28> what is '.' in haskell?
15:22:47 <napping> function composition
15:23:18 <Iceland_jack> grache28: you can use sites like Hoogle to search for those
15:23:21 <Iceland_jack> @hoogle (.)
15:23:23 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
15:23:23 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
15:23:23 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
15:24:16 <modeller> I finally get a hang about the wording in the haskell report of the layout section.
15:24:26 <grache28> tks everyone
15:25:16 <grache28> next to understand why : ap 2 ((ap 2) (+5)) 0 == 20 and ap 2 (ap 2) (+5) 0 == 45
15:25:53 <grache28> s/20/30/
15:26:07 <napping> really?
15:26:08 <modeller> There are actually two contexts in parser: one is w.r.t. the source file text (including whitespace); the other is a so called "lexeme stream" which is actually a list of tokens with white-spaces trimmed away.
15:26:15 <vanila> (ap 2) (+5) adds 5 twice
15:26:18 <vanila> so it adds 10
15:26:28 <vanila> therefore
15:26:29 <grache28> napping: meh, aplicar 2 ((aplicar 3) (+5)) 0
15:26:37 <vanila> ap 2 ((ap 2) (+5)) 0 = ap 2 (+10) 0
15:26:40 <grache28> ^ that gives 30
15:26:45 <modeller> Hope that I am not too wrong about that interpretation.
15:26:46 <vanila> and ap 2 (+10) 0 adds 10 twice, so it adds 20
15:26:50 <vanila> = (+20) 0
15:27:00 <vanila> does that help
15:27:14 <grache28> aplicar 2 ((aplicar 3) (+5)) 0 gives thirty
15:27:27 <grache28> without the parens aplicar 2 (aplicar 3) (+5) gives 45
15:29:01 <napping> 3^2 * 5 = 45
15:29:20 <vanila> grache28
15:30:14 <grache28> napping: perfectly clear now, thank you
15:31:39 <napping> ap 3 (ap 3) (ap 3) (+1) 0 runs for a bit, doesn't it?
15:42:13 <johnny934759> so is constructing a list of typeclass instances against the type checker?
15:47:37 <merijn> johnny934759: I don't understand your question?
15:49:41 <hexagoxel_> johnny934759: https://www.haskell.org/haskellwiki/Existential_type
16:11:21 <mmachenry> :t sort . reverse
16:11:22 <lambdabot> Ord a => [a] -> [a]
16:12:29 <mmachenry> Why is sort.reverse [()] -> [()] when I do let f = sort . reverse but not when I do :t
16:13:24 <vanila> I think it's a bug in GHC called the monomorphism restriction, where it assigns less general types to your code
16:13:43 <vanila> if you put {-# LANGUAGE NoMonomorphismRestriction #-} as the first line it might fix it?
16:13:50 <shachaf> It is a feature in the Haskell standard, not a bug in GHC.
16:14:09 <mmachenry> That did it
16:14:10 <shachaf> You can turn it off, and many people do, but before you do that you should find out why it exists.
16:14:17 <mmachenry> I shall read about NoMonomorphismRestriction thanks
16:14:24 <shachaf> @where dmr
16:14:24 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:14:53 <hexagoxel_> another way to get around that behaviour (instead of the flag) is to add a type signature
16:17:52 <johnny934759> hexagoxel_: hey thanks, that link did the trick!
16:31:52 <tac_> Data/Array/Accelerate.hs:1:1:
16:31:52 <tac_>     Ambiguous module name ‘Prelude’:
16:31:59 <tac_> Why would I be getting something dumb like that :(
16:32:31 <shachaf> I don't know, but maybe the answer is after the colon.
16:32:37 <tac_>       it was found in multiple packages: base haskell98-2.0.0.3
16:32:49 <rom1504> here it is
16:32:52 <vanila> maybe you have to specify the language 98 or 2010 in the .cabal
16:39:24 <phaazon> come on seriously
16:39:39 <phaazon> still stuck at ghc-7.6.3 on debian unstable
16:40:01 <phaazon> when do we get MODERN stuff :D
16:40:12 <phaazon> I think I’m gonna install my archlinux distro again…
16:41:52 <tac_> is it safe to move sandboxes with linux's mv?
16:42:23 <bennofs> phaazon: nixos has binary haskell packages compiled with ghc 7.8.3, and it very many packages from hackage :=)
16:43:24 <geekosaur> tac_, I doubt it; the local ghc package database is likely to have absolute paths in it that will need to be edited, then something like "cabal sandbox hc-pkg -- recache --user"
16:43:43 <tac_> yeah. I'll just recreate it
16:47:30 <tac_> is it a bad idea to remove your user-level .cabal file at /home/<username>/.cabal?
16:48:01 <merijn> tac_: Define "bad"
16:48:06 <ideasman42> Hi, I dont know haskell (except for some messing about with xmonad)...
16:48:20 <ideasman42> does anyone know if it would be a good environment for writing a 3d modeller?
16:48:21 <tac_> merijn: I think i accidentally forgot to create a sandbox in this subdirectory
16:48:30 <tac_> merijn: and the packages got installed to my user-level directory
16:48:33 <tac_> I want to know how to remove them
16:48:46 <ideasman42> like Wings3D -  http://www.wings3d.com/- written in erlang
16:48:55 <merijn> tac_: "ghc-pkg list" to list them, "ghc-pkg unregister <package>" to remove
16:49:13 <merijn> tac_: Note that unregister won't delete the installed files, but unless you worry about disk space you can just leave them there
16:49:35 <tac_> If I wanted to delete them, would I just remove them from the .cabal/lib directory?
16:49:40 <merijn> ideasman42: I would say it's probably about as good as erlang
16:49:42 <ideasman42> Im not sure how mutable state might apply to a modeling application
16:49:45 <tac_> err .cabal/packages?
16:49:53 <merijn> tac_: Then you just remove the right subdir from there, yes
16:49:59 <ideasman42> since you may not want to store many copies of a mesh in memory
16:50:57 <chrisdone> here's the Functor viewer idea i was playing with: http://chrisdone.com/fmap type in a function and see it applied to 6 instances
16:51:12 <chrisdone> pretty slow because it abuses tryhaskell's backend dumbly, but there's the proof of concept
16:51:37 <merijn> ideasman42: Haskell can do mutable state perfectly fine
16:52:08 <merijn> ideasman42: And lots of time you don't even need truly mutable state because you can get away with faking purely functional state
16:52:34 <ideasman42> merijn, yep, I know it can do - but then I wonder what advantages it has too
16:52:39 <chrisdone> i'd like to do something similar for Monad, which would have much more interesting results. return and >>= and join do interestingly different stuff in most instances
16:52:57 <ideasman42> basically, I wonder if I would be able to get advantages of using it
16:53:10 <ideasman42> cool - some people already had some plans :) http://www.haskell.org/haskellwiki/H3D
16:53:40 <ideasman42> all talk so far
16:53:41 <merijn> ideasman42: The advantages? I would say the type system
16:54:17 <luite> chrisdone: shouldn't it print the arguments somewhere?
16:54:34 <chrisdone> luite: hm?
16:54:36 <merijn> ideasman42: There's a reason Joe Armstrong said that "if I'd known about type systems when I implemented erlang, I would have made it statically typed" :) (see also, Guido van Rossum proposing a type system for python :p)
16:54:38 <ideasman42> merijn, yep, not being a haskell dev tho Im not sure how it would help a lot
16:54:57 <ideasman42> I work on a modeler now, and its not like I have trouble with types much
16:55:09 <merijn> ideasman42: Well, haskell still also gets you most (not quite all yet) of Erlang's nice features, like lightweight processes
16:55:11 <ideasman42> you have verts/edges/polygons... its not _that_ complicated
16:55:33 <chrisdone> luite: oh, possibly. i considered it probably redundant given `id`
16:55:45 <chrisdone> luite: as fmap id = id :3
16:55:49 <luite> chrisdone: it uses 'Right 4' for the last one
16:55:51 <luite> ah
16:56:02 <luite> sure but then you have to change the input
16:56:02 <merijn> ideasman42: Which language are/were you working in?
16:56:07 <ideasman42> merijn, btw, am not trying to start some argument... just interested to know...
16:56:09 <ideasman42> C
16:56:20 * hackagebot bloodhound 0.3.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.3.0.0 (bitemyapp)
16:56:22 * hackagebot cublas 0.2.0.2 - FFI bindings to the CUDA CUBLAS and CUSPARSE libraries  http://hackage.haskell.org/package/cublas-0.2.0.2 (bmsherman)
16:56:32 <shachaf> Are there MonadState laws?
16:56:46 <shachaf> What are they? put-put, put-get, get-put?
16:57:17 <ideasman42> Im interested in haskell, but am also finding C quite fast and I dont really have troubles with buffer overruns and leaks as some people would have you believe
16:57:45 <chrisdone> ideasman42: not that you're aware of
16:57:57 <merijn> shachaf: Yeah, I think that's pretty much it
16:58:15 <ideasman42> well, we have bugs, but rarely are they typical C leaks/overruns etc
16:58:29 <ideasman42> normally they are logical erros in system... typical bugs you get anywhere
16:58:30 <shachaf> merijn: How would you phrase them in particular?
16:58:56 <shachaf> (put x >> put y) = put y
16:59:00 <ideasman42> chrisdone, yep, - I dont say we are free of low level bugs, just its not taking up a lot of our time
16:59:15 <shachaf> (get >>= put) = return ()
16:59:18 <ideasman42> every so often they are reported, and we fix
16:59:19 <shachaf> What about the third one?
16:59:56 <merijn> shachaf: Ah, yeah, that's tricky
17:00:02 <shachaf> (put x >> get) = (put x >> return x)? That's not very nice.
17:00:14 <merijn> shachaf: Yeah, that the only thing I could think of
17:00:17 <ideasman42> the other thing I was considering is using haskell more like a scripting language
17:00:31 <ideasman42> write core in C, OpenGL - then all tools in haskell
17:00:42 <ideasman42> extension language**
17:01:14 <ideasman42> http://www.haskell.org/haskellwiki/H3D --- these guys are looking at using a game engine in a roughly similar way
17:04:54 <shachaf> What about ComonadStore laws?
17:05:45 <prophile> peek (pos x) x = extract x presumably
17:07:20 <shachaf> i,i pos >>= peek = extract
17:07:48 <shachaf> Anyway, seems reasonable, what else?
17:13:03 <amf> is there a way to do: data AllTypes = OtherComplexType | AnotherType ... ? i have a number of complex types, but i want to give a global "its going to be one of these" without having them redfined
17:13:54 <Cale> amf: Well, supposing you want those things to be types and not data constructors, you'll want to write data constructors before each one.
17:14:05 <Cale> But yes, you can do that
17:14:24 <Cale> data AllTypes = OCT OtherComplexType | AT AnotherType | ...
17:14:33 <heatsink> amf: Are you asking for a way to avoid explicitly converting to and from AllTypes?
17:14:49 <Cale> That'll define functions OCT :: OtherComplexType -> AllTypes,  AT :: AnotherType -> AllTypes, etc.
17:14:57 <Cale> which you can pattern match away
17:15:10 <amf> im going to have a top level parser that is going to try a number of parsers and i want the return to be AllTypes
17:15:23 <amf> Cale: ah ha! that looks like what i want. thanks!!
17:15:50 <Cale> Then you probably want a data type like this, yeah
17:16:21 <heatsink> I'm confused.  Isn't that what amf said in the original question, aside from forgetting to write the constructors?
17:16:59 <Cale> heatsink: Yeah, I think he was just getting the syntax wrong.
17:17:09 <heatsink> ok
17:17:37 <Cale> (or expected there to be some kind of intersection type or something)
17:20:34 <trap_exit> can I publish osx mac store apps with ghc
17:20:38 <trap_exit> or do I need to use ghcjs + node ?
17:21:14 <heatsink> I presume that you need to use the mac store software interface
17:21:25 <tac_> weird. cabal install <package> doesn't actualyl install <package> into your sandbox?
17:21:35 <tac_> it just builds it in the directory
17:22:01 <heatsink> Do you mean using ghc to publish the apps, or publishing apps that are compiled by ghc?
17:23:07 <merijn> trap_exit: If you can publish C apps using the mac app store, then you can also publish haskell apps
17:23:25 <trap_exit> ghc has a "compile to C" option ?
17:23:54 <kini> is there some way to intercept my own stdout and do something?
17:24:30 <kini> I mean, this is horrible, but suppose I'm using libraries that print out stuff to stdout, but I want to make sure that my process doesn't actually print anything to stdout, but instead emails it somewhere, say
17:26:11 <merijn> trap_exit: No, but compiled haskell is binary code in the same way C is
17:26:27 <merijn> kini: Yup, easy even
17:26:34 <merijn> kini: Well, if you're okay with *nix only
17:26:41 <kini> that should be fine
17:27:01 <joelteon> to be fair, you could compile haskell to a C file that is one chunk of inline ASM
17:27:04 <hiptobecubic> kini, why would you print to stdout if you don't want to print to stdout?
17:27:24 <heatsink> kini: I don't know if there's a haskell way.  You can use the c function freopen to redirect stdout to a pipe
17:27:34 <hiptobecubic> piping stdout working fine on windows if you have a program that reads from stdin
17:27:35 <kini> I see by googling that nominolo has a blog post about this
17:27:38 <hiptobecubic> works*
17:27:41 <kini> http://nominolo.blogspot.com/2010/04/haskell-tip-redirect-stdout-in-haskell.html
17:28:16 <kini> hiptobecubic: because I have a codebase with a bunch of "print" calls in it, and I'm too lazy to thread some state involving "what to do when I want to output stuff" through the whole program :P
17:28:19 <merijn> kini: Yeah, that's what I was gonna suggest
17:28:35 <hiptobecubic> kini, ah :) carry on then
17:28:48 <merijn> More people should read "Advanced Programming in the UNIX Environment" for these sorts of tricks
17:29:38 <merijn> For example, did you know it's possible to replace a running server with a new binary without dropping any network connections? :)
17:29:44 <kini> merijn: φ(..) *memo memo*
17:39:10 * tac_ leers at cabal install.
17:39:58 <tac_> I still have no idea why accelerate is dying over there being two packages with Prelude in it.
17:40:18 <tac_> I hid the haskell98 package, and I added the 'use Haskell2010' language option
17:42:49 <kvanb> merijn: how?
17:43:19 <tac_> also, how are "the follow packages likely to be broken by the reinstalls" if I just deleted and recreated my damn sandbox T____T
17:51:18 <merijn> kvanb: exec doesn't close open filedescriptors (including sockets), so if your server has a protocol for communicating that info you can keep using them
17:51:50 <kvanb> interesting
17:52:34 <merijn> kvanb: The usual approachs is: 1) old code gets restart signal 2) does cleanup 3) opens a unix socket 4) forks 5) exec new code with "restart" flag 6) new process connects to socket (it will have open copies of the file descriptors of the parent) 7) old binary dumps client info to unix socket 8) new binary rebuilds state from unix socket dump
17:52:56 <merijn> kvanb: I learned this trick from MUD coders who'd use it to reboot their MUD without disconnecting any players :)
17:53:45 <lpvb> kvanb: hi
17:53:49 <trap_exit> what is the correct way to install haskell platform on nixos ?
17:54:21 <shachaf> merijn: You can even send file descriptors over a UNIX socket to a process that didn't have them.
17:55:16 <merijn> shachaf: On linux, yes, I'm not 100% how portable that is
17:55:31 <MP2E> trap_exit: nix-env -iA haskellPlatform
17:55:33 <merijn> I think FreeBSD supports it nowadays too, but I have no clue about anything else
17:55:34 <MP2E> note that it isn't the newest
17:55:45 <trap_exit> MP2E: yeah, I want latest :-)
17:55:54 <MP2E> update it and send a pull request :P
17:55:58 <trap_exit> there appears to ber a 7.9 wrapper too for ghc, but I want 7.8.x for ghcjs
17:56:08 <trap_exit> update what?
17:56:20 <trap_exit> MP2E: want to teach me how to do this in nixos?
17:57:58 <amf> whats considered the go to date / time library?
17:58:32 <kini> why is a bunch of the documentation for base missing?
17:58:44 <kini> for example http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-IO-FD.html
18:01:32 <zq> hm
18:01:51 <zq> anyone know how i could make this run faster? https://gist.github.com/bryant/b5259cd4804c2aaf37bc
18:02:53 <zq> it's a braindead max collatz length benchmark using Data.List.Streams
18:03:21 <heatsink> Have you read the core?  If you're optimizing stream code, that's helpful.
18:03:30 <dunric> Hi
18:03:42 <vanila> zq, you could cache intermediate results
18:04:49 <heatsink> Oh, that's what it's doing
18:04:52 <dunric> Any idea how to use from inside a pure functions chain a value from IO monad without refactoring ?
18:05:35 <zq> heatsink: i'm not really sure how to make sense of core
18:05:52 <zq> heatsink: i understand the syntax just fine, but the problem is how to bridge the gap between core and generated assembly
18:06:06 <heatsink> Ok
18:06:23 <zq> barring that, i don't even know what constitutes a fast vs. slwo construct
18:06:31 <dunric> Do I have to put related function inside MonadReader context and propagate result of IO through it ?
18:06:35 <zq> core's still a functional language
18:06:37 <heatsink> as vanila pointed out, you can use memoization to improve the performance
18:06:58 <zq> i'm trying to improve the performance of the codegen, not the algorithm itself
18:06:58 <heatsink> That's an algorithmic improvement that could give you better than a constant factor speedup
18:07:30 <zq> note the comparison of the haskell version (collatz-fusion) against c (a.out) in the second output
18:08:10 <heatsink> Which one is collatz_len?
18:08:14 <Anders22>  Here some videos. I hope you like them! http://bit.ly/1mFMmyS
18:09:31 <zq> heatsink: collatz_len is line 12-15 of the haskell version
18:09:45 <zq> i also just added the c source for reference
18:14:16 <vanila> That's weird
18:14:22 <vanila> I tried memoizing it, and it got a lot slower
18:18:20 <heatsink> It generates an inner loop without allocation
18:18:30 <heatsink> The outer loop doesn't fuse, though
18:19:43 <augur_> so, new project @languagengine with jonsterling that uses haskell as a backend! :D
18:21:52 <heatsink> zq: Can you use the llvm backend?
18:22:21 <heatsink> zq: The performance difference could be loop overhead or allocation overhead in the outer loop.
18:23:01 <TallerGhostWalt> auger_:  saw that any more details?
18:23:51 <augur_> TallerGhostWalt: what sort of details were you interested in?
18:24:11 <zq> heatsink: outer as in the loop in main?
18:24:16 <heatsink> yes
18:25:05 <zq> the benchmarks were created with -fllvm
18:25:42 <zq> how can you tell about the outer vs. inner loop?
18:25:44 <TallerGhostWalt> auger_: all i saw was the twitter handle
18:26:13 <augur_> oh! http://www.languagengine.co/
18:26:15 <augur_> :)
18:26:36 <heatsink> In the core output, the maximum value is computed by a recursive function that takes a list as an argument
18:26:53 <bb010g> augur_: That font looks really thin
18:27:15 <TallerGhostWalt> auger_ perfect!
18:27:26 <heatsink> Since this function inspects the list, all the list cells have to be allocated
18:28:13 <heatsink> zq: Can you find strictMaximum in the core dump?
18:28:23 <TallerGhostWalt> auger_ sounds really neat
18:28:39 <zq> heatsink: yep
18:28:49 <augur_> bb010g: what browser?
18:29:03 <bb010g> Firefox on Windows 8.1
18:29:16 <bb010g> (32.0)
18:29:29 <augur_> bb010g: good to know, thank you :)
18:29:50 <haasn> Looks fine here http://i.srsfckn.biz/59.png
18:30:27 <augur_> wow haasn whatd you do XD
18:30:28 <augur_> thats not how it looks!
18:30:52 <augur_> tho it DOES look pretty cool like that
18:31:04 <heatsink> zq: main calls enumFromTo1 and passes the list to strictMaximum
18:31:20 <heatsink> so that wasn't fused
18:31:33 <heatsink> probably because strictMaximum peels the first iteration
18:31:40 <haasn> The headings don't seem to render correctly, though. They are not rendered in Terminus :(
18:31:55 <heatsink> If you rewrite it as a strict fold with 0 as the initial value, it should fuse.
18:32:16 <bb010g> augur_: http://imgur.com/zNyc1B1
18:32:58 <bb010g> haasn: What browser?
18:33:09 <haasn> bb010g: Firefox v24.6.0
18:33:26 <bb010g> haasn: Custom CSS?
18:33:30 <augur_> bb010g: use chrome! x3
18:33:42 <augur_> ill see what i can do about this. thanks for letting me know
18:34:01 <haasn> bb010g: Not really, but like that
18:34:07 <bb010g> augur_: But but but Google & NSA & Tab Panorama
18:36:39 <kvda> bb010g, it's almost 2015 and you're still on windows?
18:36:54 <benzrf> bb010g: this is a disgrace
18:36:59 <bb010g> kvda: I dual boot with Nix; I wanted to do some gaming
18:37:06 <benzrf> i am so, so disappointed in you
18:37:45 <kvda> :p
18:38:19 <kvda> windows would be dropping marker share even quicker if not for gaming
18:38:24 <bb010g> benzrf: I haven't been able to get Nvidia drivers working on Linux (Lenovo Y410P), so I'm stuck there
18:38:40 <bb010g> Hence why Mathematica's on this side also
18:38:49 <benzrf> lame!
18:39:29 <zq> heatsink: i manually fused the map and maximum to "main = print $ Stream.foldl' (\m t -> max m (collatz_len t)) 0 [1..2000000]", but the bench results are the same
18:40:43 <bb010g> benzrf: I'm hoping to pawn it off to a friend who may be needing a new lappy soon and get a Sager NP7338
18:42:21 <heatsink> zq: The difference will probably show up in the assembly code, then
18:42:23 <zq> heatsink: the core output is identical in both cases
18:47:05 <heatsink> Maybe there's no fusion rule for enum
18:47:53 <benzrf> bb010g: for lappies there is no finer than the 486
18:47:55 <benzrf>   http://benzrf.com/misc/g/lappy.png
18:48:00 <zq> hm
18:48:49 <heatsink> Yeah, that's it
18:49:07 <heatsink> If I write [1..1000] in terms of unfoldr, then it fuses
18:50:22 <heatsink> Stream.unfoldr (\x -> if x > 1000 then Nothing else let x' = x + 1 in x' `seq` Just (x', x')) 1
19:17:51 <wkoiking> Hello
19:19:21 <wkoiking> is this right place to ask haskell related questions?
19:20:00 <lfairy> wkoiking: this is #haskell :D
19:20:03 <lfairy> go for it
19:20:44 <wkoiking> I have problem installing & loading network-2.5.0.0 on Windows 7
19:21:18 <wkoiking> does anybody have same problem?
19:22:15 <glguy> network is one of the packages that comes with the Haskell Platform. It's harder than other packages to install on Windows on its own because it requires (I believe) an msys installation
19:22:36 <wkoiking> I installed haskell platform 2014.2.0.0 and installed network-2.5.0.0 using cygwin
19:22:42 <wkoiking> so far so good
19:23:08 <wkoiking> however, when I try to load the package, it fails with
19:23:40 <wkoiking> unknown symbol `_shutdownWinSock'
19:25:10 <wkoiking> with following command log:
19:25:11 <wkoiking> http://lpaste.net/109456
19:25:54 <wkoiking> I have no idea what to do :(
19:26:10 <glguy> I haven't heard that it works with any build environment by MSYS
19:26:10 <zq> heatsink: i see that it's fused, but it's actually slower now.
19:26:29 <zq> whatever, i'm not sure the extra speed is worth the effort
19:26:36 <glguy> but*
19:31:42 <heatsink> zq: You should be able to see the rest of the performance differences by comparing the C and Haskell assembly code.
19:32:57 <zq> heatsink: of the bianry itself? or -ddump-asm?
19:33:08 <zq> heatsink: i think -ddump-asm requires -fllvm to be turned off
19:34:59 <heatsink> With the -S flag, gcc outputs an assembly file
19:35:02 <heatsink> *ghc
19:35:09 <heatsink> gcc does too
19:38:17 <wkoiking> Haskell Platform 2014.2.0.0 comes with network-2.4.2.3 and is there any way to use it instead of 2.5.0.0 when I install network dependent packages?
19:39:07 <wkoiking> it seems network-2.4.2.3 bundled with haskell platform works fine
19:39:42 <wkoiking> however, cabal automatically try to install 2.5.0.0 when installing network dependent packages
19:39:57 <lfairy> wkoiking: which packages require 2.5?
19:41:51 <wkoiking> I met my problem when I try to install imagesize-conduit etc.
19:42:26 <wkoiking> cabal automatically install network-2.5.0.0
19:42:36 <wkoiking> but it won't work on my Windows PC
19:43:35 <wkoiking> I'm using cabal sandbox by the way
19:43:59 <lfairy> wkoiking: try checking each package individually with `cabal install $package --dry-run`
19:44:11 <lfairy> you'll then know which one needs network 2.5
19:44:25 <plabasra> what do you guys think about go lang?
19:44:41 <plabasra> i started looking at it and it seems so incredibly ugly :S
19:44:50 <wkoiking> ok
19:46:51 <plabasra> wtf just happened
19:47:25 <plabasra> well some isp just went down
19:48:27 <systemfault> Netsplit
19:49:25 <systemfault> plabasra: It means that one of the servers disconnected from the rest
19:49:45 <systemfault> The server will eventually reconnect to the network and you'll see a flood of "joins"
19:50:08 <plabasra> i read yesterday that some large american isp was causing global network issues because they are reorganizing their network
19:58:41 <lfairy> a netsplit happened over at synirc as well
20:06:02 <wkoiking> lfairy: it seems no package depend on 2.5 although conduit-extra depends on network >= 2.3
20:06:48 <wkoiking> cabal automatically install the newest one I suppose
20:08:46 <wkoiking> "cabal install --dry-run" says
20:08:50 <wkoiking> network-2.5.0.0 (new version)
20:12:40 <trap_exit> someone need to invent a market
20:12:45 <trap_exit> where I can speculate on hte popularity of languages
20:13:01 <trap_exit> ie.. I should be able to buy an option which pays off when Haskell reaches a certain level of popularityh
20:13:31 <Philippa> like an assassination market for languages? :p
20:14:11 <trap_exit> well, in this case, I don't think the language `assassin` gets paid
20:16:18 <wkoiking> is there any way to just use the older packages when using cabal?
20:20:09 <wkoiking> cabal always try to install the newest package even if there is already older package installed
20:20:20 <wkoiking> is above understanding is correct?
20:20:23 <glguy_> You can add constraints to your cabal config to only use the installed version of a package
20:21:34 <wkoiking> glguy_: you mean by adding like "network == 2.4.3.2"?
20:21:48 * hackagebot algebra 4.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-4.0 (EdwardKmett)
20:23:06 <glguy_> Use --constraint="network installed"
20:23:30 <glguy_> Or add constraint: network installed
20:23:45 <glguy_> To your cabal config
20:26:31 <wkoiking> glguy_: thanks! I didn't know the --constraint="network installed"
20:29:16 <nitrix> Would you recommend Scheme before Haskell?
20:29:33 <plabasra> nah
20:29:35 <nitrix> I'm learning about haskell and I realise there's a LOT of syntaxic sugar, more than first meets the eyes.
20:30:02 <plabasra> what language are you coming from?
20:30:04 <nitrix> I really would like the understand the fundamentals first and build upon that.
20:30:06 <nitrix> plabasra: C.
20:30:09 <plabasra> ah
20:30:21 <plabasra> well it really isnt much more complicated than c in terms of syntax
20:30:24 <plabasra> just different
20:30:33 <joelteon> nitrix, do you mean in terms of reading other peoples' code?
20:30:35 <glguy_> For context what's an example of the kind of syntactic sugar you're struggling with?
20:31:12 <nitrix> Well, I'm not complaining or anything, but it just seems like pattern matching, case of, guards are very similar.
20:31:17 <nitrix> let in and where too...
20:31:24 <structuralist> Is there ever a valid reason for GHC to say "Expected type: [something]    Actual type: [the exact same thing]", or could that be a bug?
20:31:34 <joelteon> nitrix: pattern matching, case, and guards are *meant* to be very similar
20:31:40 <nitrix> do that is essentially >> and >>=
20:31:48 <joelteon> they accomplish the same thing
20:31:53 <joelteon> structuralist, what are the types
20:31:56 <glguy_> Structuralist it usually means you installed multiple versions of the same package
20:32:34 <wkoiking> hmm, it seems i can not go with network-2.4.2.3 because of dependency issue :(
20:33:03 <glguy_> You should be able to install new network once you have msys
20:33:14 <nitrix> joelteon: I guess the question is, Wouldn't I like Scheme better to learn the most concise design, then look at how Haskell makes it convenient?
20:33:40 <structuralist> http://lpaste.net/109462
20:33:40 <joelteon> why not try it?
20:33:59 <plabasra> nitrix: scheme has a completelly different syntax from haskell..
20:34:10 <nitrix> I doubt learning two languages at the same time is very productive...
20:34:24 <nitrix> So I'd have to pick.
20:34:43 <plabasra> it doesnt have some features that people find difficult in haskell such as monads
20:34:44 <structuralist> joelteon: that's a snippet, the whole thing is kind of a mess at the moment
20:34:51 <joelteon> ok
20:34:56 <plabasra> you should just learn the language you want to know directly
20:35:02 <joelteon> I was going to say, if you were doing Text vs Text, it was probably Strict vs Lazy
20:35:07 <heatsink> In my opinion, it's not that hard to see what's under the syntactic sugar in Haskell.
20:35:08 <joelteon> but if not, it's what glguy_ said
20:35:25 <nitrix> plabasra: I'm bothered because there's freaking 200 ways to do the same thing.
20:35:33 <plabasra> nah
20:35:34 <heatsink> The basic language is pretty close to lambda calculus.
20:35:36 <structuralist> I have no imports except Prelude.Unicode
20:35:36 <glguy_> Structuralist it can also be a kind mismatch
20:35:41 <plabasra> its very simple dude
20:35:47 <plabasra> its all about the types
20:35:48 <structuralist> hmm
20:36:22 <plabasra> once you start thinking in terms of types, it even helps you remember the other parts of the language
20:36:25 <nitrix> plabasra: I'm slowly picking up on the type system and it seems more obvious to me now than it was before (which is like 2 days ago), but still
20:36:33 <heatsink> You can always avoid the syntactic sugar that you don't need, nitrix
20:36:42 <wkoiking> glguy_: I will try msys then, thanks!
20:36:49 * hackagebot algebra 4.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-4.1 (EdwardKmett)
20:36:55 <nitrix> plabasra: it still feels like too many things can be done it too many different ways. While some people enjoy it, I personally feel lost.
20:37:18 <pavonia> structuralist: What is U'?
20:37:21 <plabasra> nitrix: i dont think there is any more syntactic sugar other than the ones you mentioned
20:37:28 <plabasra> which was like 5 things?
20:37:35 <joelteon> I can understand that being overwhelming, though
20:37:47 <joelteon> let/where do exactly the same thing, as do case, guards, and multiple definitions
20:37:52 <joelteon> well, *almost* exactly the same thing
20:37:55 <heatsink> What are you doing for practice, nitrix?
20:37:55 <joelteon> the almost is the important part
20:38:02 <Philippa> there's a lot of ways to apply the libraries and that's possibly scarier?
20:38:33 <joelteon> nitrix, would it be helpful to have a guide that advises you on the best construct to use in a given situation?
20:38:35 <structuralist> ok, I fixed the error. but I still don't get why that error message
20:38:37 <nitrix> heatsink: A terminal game right now. It's not the greatest thing, but it keeps me entertained as far as I'm making progress.
20:39:05 <Philippa> terminal games're good
20:39:16 <structuralist> pavonia: http://lpaste.net/109462
20:39:51 <nitrix> joelteon: Well, yes, it'd help, but... you know, the feeling the language isn't "as concise as it could be" bothers me.
20:40:09 <joelteon> yeah
20:40:27 <nitrix> I think I'm too much of a minimalist.
20:40:33 <nitrix> I'll probably never find what I want :/
20:41:05 <heatsink> You have complexities in scheme, too
20:41:16 <heatsink> like two different ways of testing equality, eq and eqv
20:41:33 <plabasra> nitrix: haskell allows you to write very elegant, short code - you should like it
20:41:55 <nitrix> plabasra: It's the best I came accross so far.
20:41:57 <heatsink> also = and equal.  So four ways of testing equality.
20:42:05 <glguy_> One way to do something wont help you to write concise code
20:42:17 <glguy_> It'll just take away your flexibility
20:42:26 <nitrix> Well at least you know it's the only way, concise or not.
20:42:46 <nitrix> You're not pondering about readability or whatever trade off.
20:43:29 <nitrix> It almost makes everyone consistently approach the same problems in a similar way, I don't know.
20:43:49 <heatsink> Scheme has simple syntax but complex semantics.  I think that's a worse tradeoff.
20:44:10 <ReinH> Of the three things you mentioned, only pattern matching in function definitions and in case statements are similar
20:44:44 <ReinH> and they do have different use cases
20:44:57 <nitrix> ReinH: I understand that. I just wanted to more generally point things out. They do have slightly different behavior and usage.
20:45:16 <nitrix> I suppose I'll get used to it over it. I was just ranting, sorry guys.
20:45:22 <nitrix> er, over time
20:45:27 <ReinH> Show me a language with exactly one way to do everything and I'll show you a language no one actually wants to use :p
20:45:46 <ReinH> because then you can't do any better than the decisions of the people who designed the language
20:46:32 <ReinH> At the same time, I agree that it is possible to have too many ways to do something. I don't think Haskell has that problem, but it's subjective enough that someone might.
20:46:50 <plabasra> is it just me or is golang ugly as shit?
20:47:09 <glguy_> Wrong channel for language bashing
20:47:14 <plabasra> I just don't understand how they came up with that syntax
20:47:29 <plabasra> glguy_: why?
20:47:48 <tac_> plabasra: take it to #haskell-blah
20:47:55 <nitrix> plabasra: As someone who's written imperative code for years, Go felt like heaven.
20:48:41 <nitrix> plabasra: I think it definitively got a few things right. Like the `for` or the switch statement that defaults to break with a fallthrough keyword.
20:49:24 <tac_> nitrix: again, save Go for the #haskell-blah channel please
20:49:30 <nitrix> Got it.
20:50:13 <IceStar3030> #join
21:01:37 <platz> interesting - regarding IVar : "despite all of the monad mania surrounding what are essentially glorified callbacks, no one actually uses this monad when it comes to Haskell. Why not? For one reason, Haskell has cheap and cheerful preemptive green threads, so we can write our IO in synchronous style in lots of threads"
21:01:52 * hackagebot type-natural 0.2.1.4 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.4 (HiromiIshii)
21:02:38 <platz> So threads aren't the devil as long as they're 'green' and as long as we have MVar
21:02:53 <cdsmith> Anyone have a quick idea how to get a list of modules in base, sorted by the number of times they are imported (say, from all of Hackage, or some other representative code base)?
21:06:52 * hackagebot pandoc 1.13 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.13 (JohnMacFarlane)
22:00:01 <Clarice> heatsink is gone, but Scheme has its different equality tests for different reasons. Haskell has no concept of objects with identity because of immutability, so what good would a pointer comparison operator have?
22:02:01 <Clarice> plabasra: You mean to say that Scheme doesn't have *typeclasses*.
22:05:44 <Clarice> And even then, that's not totally accurate. You would have just to delay typeclass checking to runtime.
22:09:16 <trap_exit> MP2E: yo
22:10:04 <MP2E> trap_exit: hey
22:10:13 <trap_exit> MP2E: alright, do you hav e10 mins?
22:10:18 <trap_exit> I feel comfirable with NixOS now
22:10:28 <trap_exit> and would like ot ask for your help in porting 2013 to 2014 for gthc platform for nix
22:10:29 <MP2E> sure
22:10:34 <MP2E> no problem
22:10:39 <trap_exit> great, lets' do this in #nixos
22:10:41 <MP2E> uhh #nixos though, this is offtopic here :P
22:30:41 <adas> is there anyway to do IO inside a "MaybeT (StateT Sometype Identity) a"? lift doesn't work .. cos lifting gives "MaybeT IO a" and liftIO don't work cos "Identity" does not have a MonadIO instance..
22:31:30 <shachaf> No, that doesn't make sense.
22:32:19 <adas> shachaf: could you elaborate? i would like to understand
22:33:23 <shachaf> What do you know about how IO in Haskell works?
22:33:36 <adas> shachaf: my guess is .. the "MaybeT (StateT Sometype Identity) a" has no way to do IO in the stack..cos none of the stacked monads got IO in them
22:33:49 <dv-> that's right
22:34:15 <shachaf> (MaybeT (StateT Sometype Identity) a) is a fancy way to write (Sometype -> (Maybe a, SomeType))
22:36:24 <adas> shachaf: how did you get (Sometype -> (Maybe a, Sometype))?
22:36:46 <adas> shachaf: got it
22:37:16 <adas> its just the state monad
22:38:06 <ReinH> @unmtl StateT s m a
22:38:06 <lambdabot> s -> m (a, s)
22:38:48 <Fuuzetsu> @unmtl MaybeT
22:38:48 <lambdabot> Plugin `unmtl' failed with: `MaybeT' is not applied to enough arguments, giving `/\A B. A (Maybe B)'
22:38:59 <Fuuzetsu> @unmtl MaybeT s m
22:38:59 <lambdabot> s (Maybe m)
22:41:18 <adas> what is "unmtl"?
22:41:48 <adas> unwrap monad transformer library?
22:43:15 <ReinH> it shows the underlying type for monad transformers in mtl (the thing their newtype wraps)
22:43:16 <ReinH> e.g. http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-State-Lazy.html#t:StateT
22:43:40 <ReinH> @help unmtl
22:43:40 <lambdabot> unroll mtl monads
22:45:07 <ReinH> and State s is a type synonym for StateT s Identity
22:46:18 <ReinH> So if you combine that with the MaybeT
22:46:30 <ReinH> @unmtl MaybeT (StateT s m) a
22:46:31 <lambdabot> (StateT s m) (Maybe a)
22:46:54 <ReinH> you get s -> (Maybe a, s)
22:50:01 <adas> hm.. seems like i can get there by substituting the MaybeT constructor and the State constructor as well. thats nice
22:50:52 <ReinH> How did you substitute those?
22:57:10 <adas> MaybeT m a = MaybeT m (Maybe a). In this case .. m a is (StateT s Identity) (Maybe a) which is (s -> (Maybe a, s).. No?
22:58:55 <adas> ofcourse, since its a newtype constructor .. internally I believe there is some internal compiler optimization that doesn't check for the MaybeT data constructor
22:59:07 <adas> i hope im not blabbering
23:37:31 <kvanb> type --> newtype isn't so straightforward for me
23:37:35 <kvanb> could somebody please help me: http://lpaste.net/109468
23:40:16 <trap_exit> haskell, as a language, does it fall into the category of intelligent design, or of evolution ?
23:43:38 <ChristianS> trap_exit: both, but mostly the former
23:45:23 <kvanb> trap_exit: starting with goals, and tiny not monolithic helped
23:45:48 <kvanb> the fact that a lot of the language is just in Prelude makes evolution easier.
23:46:38 <trap_exit> I waas just ovserving how hard it was for other langauges to add features
23:46:43 <trap_exit> and it surprised me that haskell got so many things right
23:46:53 <trap_exit> must be intelligent design, I say
23:50:15 <glguy> Kvanb did you figure out your question yet?
23:50:38 <kvanb> glguy: no
23:50:41 <kvanb> just about to post on stack overflow
23:51:00 <kvanb> actually, there's a lot more info in this stack overflow question I'm writing up
23:51:06 <glguy> Type is just an alias
23:51:51 <glguy> New type makes a new type that is distinct and doesn't support any of the original operations
23:52:21 <glguy> But which is implemented internally by the type you put in the newtype
23:53:04 <glguy> So you won't be able to use the new type in places that expected the old type
23:53:15 <kvanb> does the error spell that kind of thing though?
23:53:36 <kvanb> A 'could not match' error kind of tells me I'm missing a constructor or something
23:53:48 <kvanb> 'could not deduce' errors are a lot easier to fix with GNDD
23:53:55 <kvanb> question now @ http://stackoverflow.com/questions/25337712/haskell-changing-type-alias-to-newtype-yields-error
