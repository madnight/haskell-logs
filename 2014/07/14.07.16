00:00:47 <chenwl> eitherDecode "{\"ha\":\"中文\"}" :: Either String (Map String String)    --  Left "Failed reading: Cannot decode byte '\\x87': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
00:00:50 <d3m1g0d-> whats a sophomore ? 2nd year student ?
00:00:53 <Zekka> Yeah.
00:00:54 <chenwl> is it a bug?
00:00:59 <zorg24> d3m1g0d-: yeah
00:01:17 <chenwl> "中文" is valid utf8 string
00:01:48 <d3m1g0d-> no idea how you people have won the cold war .... why not just say "2nd year" ?
00:01:55 <d3m1g0d-> sophomore, I cant even pronounce this ...
00:01:58 <zorg24> I'm a sophomore too (well probably its complicated cause I'm transferring so it depends how much credit gets accepted...)
00:02:02 <Zekka> It's just the word that's generally used.
00:02:17 <Welkin> freshman, sophomore, junior, senior
00:02:21 <Zekka> we don't think any different of saying it: it's like Europeans with the word 'uni'
00:02:29 <d3m1g0d-> lol, what, junior is a 3rd year ? how does this make sense
00:02:36 <Welkin> they are used to describe student classification in high school and college
00:02:41 <nezt> Why does the haskell freenode channel have so many people in it
00:02:51 <Welkin> nezt, haskell is god
00:02:52 <Zekka> nezt: A lot of people use Haskell I guess.
00:03:15 <nezt> Haskell apparently is god, i'm already really excited learning it
00:03:19 <zorg24> wow almost the same number in here as #python
00:03:29 <d3m1g0d-> In the USA you have 11 grades, not 12 or 13, right ?
00:03:33 <d3m1g0d-> in high school ?
00:03:39 <nezt> k - 12 they call it
00:03:39 <zorg24> no 12
00:03:41 <Zekka> d3m1g0d-: We have 12 total but we stop numbering at highschool
00:03:53 <Zekka> Except we use 'K-12' pretty often
00:03:56 <nezt> k - 12 is technically 13 actually
00:04:02 <zorg24> err wait 13 technically
00:04:07 <d3m1g0d-> so you graduate high school when you're ... 19 ?
00:04:10 <Zekka> We don't number kindergarten usually but if we did it would be 0
00:04:11 <d3m1g0d-> 6 + 13 = 19 ?
00:04:19 <zorg24> no 18
00:04:20 <Welkin> k-12 is tax-supported day care and indoctrination
00:04:24 <Zekka> d3m1g0d-: I graduated when I was sixteen, I think.
00:04:41 <Zekka> but I skipped a year, so many of my friends were 17 and 18
00:04:43 <zorg24> we start at 5 (it can vary a bit its up to parents to some extent)
00:04:46 <nezt> k-12 should be one class haskell, one class other programming, one class math, one class physics
00:04:50 <nezt> instead it's all bullshit
00:05:03 <d3m1g0d-> yea yea, I've heard that actually, you're high school education system allows above average kids to graduate early
00:05:10 <orzo> are you k-12 students?
00:05:28 <Welkin> high school graduates cannot even read a children's novel written for 8 year olds
00:06:03 <orzo> that sounds like a myth
00:06:08 <Welkin> I know some
00:06:10 <zorg24> depends on the school... but yeah I wouldn't be surprised if that was true in some cases
00:06:13 <Zekka> I feel like programming could be a strong introduction to math given that the computer can check your work for you
00:06:16 <Welkin> they write at a 3rd grade level
00:06:26 <mayski> what is this, #haskell-pedagogy?
00:06:40 <zorg24> orzo: the sad truth isn't a myth
00:06:41 <Zekka> mayski: You want we can probably move this to -blah
00:06:44 * hackagebot apiary 0.12.8 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.8 (HirotomoMoriwaki)
00:07:00 <nezt> Has anyone here built a web framework in haskell / used one and then used elm lang for front end stuff
00:07:12 <Welkin> built a framework?
00:07:15 <Welkin> you mean used one?
00:07:24 <d3m1g0d-> ok kids, nice talking to you, time to go back to LYAH
00:07:27 <orzo> it's not the sad truth either if its just some polemic you heard and repeated without remembering any other substance to back i tup
00:07:28 <Zekka> See you, best of luck.
00:07:37 <zorg24> k bye
00:07:41 <nezt> i might as well include built for that .000001% of the population in case they are here
00:07:48 <Zekka> orzo: Might move this to #blah, whih is where zorg went
00:08:08 <chenwl> eitherDecode "{\"ha\":\"中文\"}" :: Either String (Map String String)    --  Left "Failed reading: Cannot decode byte '\\x87': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
00:08:26 <chenwl> why Data.Text.Encoding decodeUtf8 cannot decode any non-ascii string?
00:08:46 <Welkin> > eitherDecode "{\"ha\":\"中文\"}" :: Either String (Map String String)
00:08:47 <lambdabot>  Not in scope: type constructor or class ‘Map’
00:08:47 <lambdabot>  Perhaps you meant ‘M.Map’ (imported from Data.Map)Not in scope: ‘eitherDecode’
00:09:18 <frerich> Does anybody know whether there's a search engine which finds source code matching a particular function? I'm currently wondering why the type of 'maybe' is at it is, so I'd like to see how existing code uses it. Maybe it's meant to be used without passing all arguments, or infix, or something.
00:10:28 <Welkin> you mean hoogle?
00:10:30 <bergmark> chenwl: hmmm....
00:10:33 <Welkin> @hoogle maybe
00:10:34 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
00:10:34 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
00:10:34 <lambdabot> Foreign.Marshal.Utils maybeNew :: (a -> IO (Ptr a)) -> (Maybe a -> IO (Ptr a))
00:10:36 <bergmark> im just working on encoding stuffs as well
00:10:37 <chenwl> Data.Text.IO Data.Text.Encoding> Data.Text.IO.putStrLn $ decodeUtf8 "haha中文" -- *** Exception: Cannot decode byte '\x87': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
00:11:01 <jfischoff> frerich: to answer your question, maybe is used as an alternative to case matching
00:11:04 <friden> frerich: if you cant find it using hoogle, just google the function and add source keyword somewhere
00:11:23 <frerich> Welkin: No, I meant something which finds Haskell projects using that function. Maybe something which searches all Haskell projects on github or so.
00:11:47 <frerich> jfischoff: Right. In my cases, I often have a 'Maybe a
00:11:49 <frerich> er
00:11:54 <nezt> I wish I had savant autism and thought in Haskell
00:12:06 <Zekka> nezt: You don't really have to be a genius to write code in it
00:12:18 <friden> nezt: be careful what you wish for ;)
00:12:30 <frerich> jfischoff: I often have a 'Maybe a' value and some "default" - the function which is applied to the 'a' is quite length though, so for me it would be most convenient if the signature was 'maybe :: b -> Maybe a -> (a -> b) -> b', i.e. the function to apply to comes last.
00:12:43 <bergmark> chenwl: text-icu can decode it
00:12:44 <jfischoff> :t fromMaybe
00:12:45 <lambdabot> a -> Maybe a -> a
00:12:54 <nezt> I would use my powers to create a huge Haskell bioinformatics library that ultimately cured HIV and glioblastoma multiforme
00:13:12 <bergmark> ehm, but it doesn't print it correctly
00:13:31 <chenwl> bergmark: I am using Aeson, can I switch the backend of it to text-icu
00:13:48 <frerich> jfischoff: It only recently occurred to me that maybe the function is meant to be applied to only two arguments, i.e. you do 'extractValue = maybe 12 length' so that you can then apply 'extractValue' to some 'Maybe [a]' and get either 12 (for nothing) or the list length.
00:13:52 <Welkin> nezt, just use fmap . fmap . fmap . fmap
00:14:13 <nezt> wat
00:14:21 <Zekka> nezt: Have I shown you this stupid chestnut?
00:14:23 <Zekka> > fix error
00:14:23 <jfischoff> yes
00:14:24 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
00:14:26 <Welkin> :t fmap . fmap . fmap . fmap
00:14:27 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
00:14:30 <Zekka> (Haskell debugging in a nutshell)
00:14:33 <bergmark> λ> open "utf8" Nothing >>= putStrLn . T.unpack . flip toUnicode "文"
00:14:33 <bergmark> �
00:14:52 <jfischoff> :t fmap fmap fmap fmap fmap fmap fmap
00:14:53 <lambdabot> (Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 a) -> f1 (f2 b))
00:14:58 <nezt> Zekka: so I should give up learning because debugging sucks? I don't get what you're saying
00:15:12 <Welkin> :t fix
00:15:13 <lambdabot> (a -> a) -> a
00:15:30 <Zekka> nezt: No, it's just a joke
00:16:02 <Zekka> GHC is pretty good at tearing your code a new one, which is the cost in working in such an analyzable language
00:16:13 <nezt> Yo bro, I heard you like maps so I mapped your map to my map and then mapped that to another map
00:16:50 <jle`> nezt: good luck on that :)  let me know how you do, i'm very interested in applying haskell to open research problems
00:17:12 <bergmark> chenwl: to use a separate encoding i think you need to decode the bytestring to text and then encode back to a bytestring
00:17:17 <Zekka> nezt: Basically, each layer of fmap goes another level deeper into a structure
00:17:29 <Zekka> > (fmap.fmap) (+1) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
00:17:31 <lambdabot>  [[2,3,4],[5,6,7],[8,9,10]]
00:17:33 <chenwl> bergmark: Thanks, I'll try it
00:17:38 <jle`> nezt: i really believe that Haskell is...a real answer to many problems in the scientific computing world
00:17:52 <nezt> jle`: I agree completely!! I see a lot of potential!
00:18:03 <jle`> nezt: are you in a resaerch profession?
00:18:10 <nezt> jle`: yes, bioinformatician
00:18:19 <jle`> nezt: ah, i could have guessed
00:18:23 <bergmark> chenwl: but both decode it to "REPLACEMENT CHARACTER", not sure what that means
00:18:30 <Zekka> nezt: If you like functions that compose like fmap, look into lens
00:18:36 <jle`> nezt: once you get further along you might want to idle in #numerical-haskell
00:18:38 <Zekka> which is a library full of functions that compose following the intuition of fmap
00:18:55 <frerich> nezt: I think Python dominates bioinformatics, right?
00:19:14 <nezt> frerich: probably. some of my colleagues still use perl
00:19:22 <jle`> heh
00:19:24 <nezt> frerich: R is used a lot also
00:19:32 <jle`> perl "excels" in string processing, no?
00:19:54 <nezt> jle`: yeah the regex capabilities I guess.. I personally prefer python
00:20:13 <jle`> i heard perl is used a lot in analyzing dna...which sort of makes sense in a twistedly ironic way
00:20:53 <jle`> in my field python is big too, but it hasn't quite overcome fortran/c++
00:21:08 <nezt> jle`: physics related?
00:21:34 <jle`> mhm
00:22:04 <jle`> although a surprising amount is done in matlab
00:22:21 <Ei_> Why is that surprising?
00:22:43 <Zekka> I think every major project at my uni is undertaken in Java, but I'm not sure
00:23:00 <Zekka> Our school has an in-house programming language but I don't know anybody who uses it, aside from one professor who uses it as a scripting language
00:23:26 <jle`> Ei_: not too surprising; it just sticks out as the one interpreted language out of all of them
00:23:34 <jle`> it's really suited for experimental research though
00:23:47 <frerich> To my surprise, I use Haskell a lot for smaller command-line tools which are too complex for shell scripts. Largely because System.Directory and System.FilePath have provide so much convenience, like "createDirectoryIfMissing" or "findExecutable" or "replaceExtension". Stuff I need all the time.
00:23:59 <frerich> s/have provide/provide/
00:24:19 <Zekka> I have difficulty using Haskell for small stuff like that because it usually takes me the build system scaffolding to do useful stuff with it
00:25:01 * frerich sometimes sticks "#!/usr/bin/env runhaskell" at the top and executes the Haskell script straight away
00:25:05 <solidus-river> does Data.Lindear already have somethign to test if line segments intersect?
00:25:12 <solidus-river> it seems like it would but i can't find it
00:25:16 <solidus-river> Data.Linear
00:25:20 <Zekka> frerich: It frustrates me that I have to go to the trouble of making a sandbox and rebuilding everything if I want to write a script
00:25:37 <frerich> Zekka: You don't actually need to build anything, you can use 'runhaskell'.
00:25:43 <Zekka> it sometimes makes me wish there was a Haskell which was semantically basically the same, but exclusively interpreted without as much build systerm surrounding it
00:25:51 <Zekka> frerich: I know, but suppose I need to install a library
00:26:03 <Zekka> I don't want to break the rest of my installation, so what do I do? I create a sandbox
00:26:14 <frerich> Zekka: Luckily, a lot of stuff including System.Directory and System.FilePath (same for process control) is in the base package.
00:26:38 <solidus-river> Zekka: this problem isn't unique to haskell
00:26:38 <Zekka> frerich: Usually when I'm talking about something like this I'm referring to miniature 400-500 line apps
00:26:58 <Zekka> https://github.com/Zekka/whidgle <- this is the one I usually link here
00:27:08 <solidus-river> Zekka: see - Python, Ruby, C++, C, Java, ...
00:27:17 <solidus-river> if you have a lib dependency you need to sandbox or risk breaking your system
00:27:34 <Zekka> solidus-river: Although a lot of languages feature automatic sandboxing/dependency management
00:27:43 <solidus-river> Zekka: what languages?
00:27:58 <Zekka> or try to make their build system piss-easy to use (Clojure/Leiningen, Dart)
00:28:09 <Zekka> solidus-river: JS with Node is a pretty good example IIRC
00:28:14 <frerich> Zekka: Unrelated to this topic - I think the Whidgle source code is really pretty style-wise :-)
00:28:24 <solidus-river> well, node is js's cabal
00:28:31 <solidus-river> and you still need an npm local sandbox
00:28:32 <Zekka> solidus-river: And its stdlib.
00:28:36 <solidus-river> or you risk breaking your npm install
00:28:42 <solidus-river> its the same concept
00:28:54 <Zekka> It basically represents making the build system easy as possible to configure and consolidating it with the language itself
00:29:02 <solidus-river> npm is not javascript
00:29:06 <Zekka> frerich: Really? THanks. Do you mean in terms of indentation or in terms of design?
00:29:28 <Zekka> solidus-river: That's correct, but when we refer to 'node' we're referring to a bunch of technologies that basically present themselves as 'this is your interpreter, mate'
00:29:29 <jle`> frerich: a lot of stuff i'd like for scripts relaly isn't in base :/
00:29:50 <frerich> Zekka: Just in terms of the variable names and when you use empty lines and how long the lines are and such things.
00:29:52 <solidus-river> Zekka: aye, and cabal is one of those technologies associated with Haskell
00:29:56 <frerich> Zekka: I find ti really easy to read.
00:29:57 <Zekka> even if they're not, if you consult the spec directly, part of the language
00:30:17 <Zekka> solidus-river: I guess what I really mean is that cabal doesn't feel particularly streamlined or easy for me to use
00:30:19 <solidus-river> your .cabal file is equivalent to your package.json or whatever node calls it
00:30:22 <solidus-river> and the sandbox installs locally
00:30:24 <solidus-river> like npm does
00:30:32 <Zekka> which I think is probably a pretty uncontroversial thing to say
00:30:37 <frerich> jle`: True, but I don't want to get into the whole haskell platform discussion and what problems it tries to solve and what problems it arguably causes again, so I'll rathernot mention that I sometimes miss HTTP :}
00:30:45 <jle`> :)
00:30:55 <solidus-river> feels pretty streamlined to me
00:31:06 <solidus-river> what version of cabal are you running, the problem is most distros package old versions
00:31:12 <solidus-river> cabal sandbox init
00:31:14 <solidus-river> cabal build
00:31:22 <solidus-river> cabal sandbox destroy, cabal repl, etc
00:31:39 <Zekka> solidus-river: I have to create a new directory, initialize a sandbox, recompile my old projects, and modify the cabalfile to reflect a configuration that fits my project
00:31:40 <solidus-river> npm is the same except it assumes a sandbox and you need a -g to not sandbox
00:31:52 <solidus-river> Zekka: thats the same thing as node
00:32:02 <solidus-river> you need to edit the package.json and do an npm install if your deps change
00:32:05 <Zekka> solidus-river: I haven't worked in Node for a few months. Is it possible I'm remembering it as better than it is?
00:32:08 <solidus-river> unless your using your system version
00:32:10 <Zekka> (The answer is probably yes.)
00:32:13 <solidus-river> which cabal will also do
00:32:23 <solidus-river> aye, i think you are :)
00:32:58 <Zekka> I'm currently for work using the mother of all ugly build systems (and I'm largely responsible for it)
00:33:17 <solidus-river> heh
00:33:21 <Zekka> It's Gradle configured to manage a large number of Java projects with a lot of 'smart' behavior
00:33:44 <solidus-river> oh god, your building java and complaining about cabal?!? :P
00:33:47 <Zekka> it's better than 'just click the build button in the IDE' but the build system is sufficiently large in LOC count that I no longer understand exactly how it works
00:34:05 <Zekka> solidus-river: It's better than what we used to work in (legacy VB6 code)
00:34:29 <solidus-river> just saying, for big projects cabal is a cakewalk compared to java
00:34:32 <solidus-river> (in my experience)
00:34:32 <Zekka> Although unfortunately I can no longer introduce myself by saying 'Hi, I work in VB6' and watch people sneer
00:34:44 <solidus-river> er java based build systems
00:35:08 <frerich> Zekka: It sure does sound like an introduction to Alcoholics Anonymous.
00:35:10 <Zekka> I don't trust Java programmers to design human-usable systems, but it's possibly prejudice
00:35:20 <frerich> Zekka: "Hi, I'm bob and I work in VB6." -- "Hi Bob."
00:35:34 <Zekka> frerich: It was really fun when I was at the local web developers meetup a few days ago
00:35:35 <hyPiRion> Zekka: Would it be possible for you to use Lein for the Java project? I've done that sucessfully a couple of times
00:35:46 <hyPiRion> Not sure it will give you any benefits though
00:36:08 <Zekka> they all sneered and then stopped sneering when I revealed myself to be the rare and fearsome beast, a Haskell programmer
00:36:20 <Zekka> hyPiRion: Presumably, but I wouldn't want to be responsible for porting it
00:36:22 <bergmark> what does npm do if packages A and B depend on different versions of C, and A and B communicate using types defined in C?
00:36:46 <Zekka> bergmark: Probably ignore the problem?
00:36:58 <Zekka> Although I think the Haskell situation is worse than that
00:37:02 <systemfault> bergmark: Each package has its own node_modules directory
00:37:14 <Welkin> you can drink all day if you work in a type-safe language!
00:37:31 <Zekka> if you already have one of those installed, it will not attempt to install a version other than the installed one
00:37:43 <Zekka> which is understandable: after all it's the problem sandboxing attempts to solve
00:37:45 <solidus-river> am i missing something
00:37:49 <bergmark> systemfault: yeah, but it'll probably just break at some point then, right?
00:37:56 <solidus-river> does Data.Linear by ekmett not have line intersections already?
00:38:05 <solidus-river> i'm looking in V2 maybe i need to look somewhere else
00:38:08 <Zekka> (i.e. if A can use B 1.2 or 1.3, and C can use B 1.1 and 1.2, if you have C 1.1 installed it won't reinstall C 1.1 for 1.2 if you attempt to install a)
00:38:11 <Zekka> A*
00:38:38 <systemfault> bergmark: How can it break if every module has its own dependencies directory?
00:39:18 <Zekka> systemfault: What if you want to take a value returned by a function in A and pass it to a function in B?
00:39:30 <bergmark> ^--
00:40:28 <systemfault> Zekka: You include A and B and define a function to do so, how can it break? There are no globals, so even if packages A and B use different versions of a dependency, as long as you follow their APIs, it will work.
00:40:48 <Zekka> systemfault: A and B use different versions of C
00:40:53 <Zekka> Let's say C defines a type Foo
00:40:57 <Zekka> A uses C 1.1 and B uses C 1.2
00:41:22 <Zekka> If you get a Foo out of B it will be a C-1.2:Foo
00:41:29 <Zekka> However, A expects a C-1.1:Foo
00:41:38 <Zekka> For all we know, these Foos do not at all look the same internally
00:41:39 <hyPiRion> systemfault: What happens if the type has changed?
00:42:02 <Zekka> How do we turn our C-1.2:Foo safely into a C-1.1:Foo without an explicit conversion function?
00:42:31 <systemfault> Zekka: If your package A and B leak parts of C… perhaps it’s bad.
00:42:49 <Zekka> systemfault: Perhaps, but not necessarily
00:42:56 <Zekka> Look at all the packages that basically exist to augment other packages
00:43:01 <Zekka> i.e. pipes-parse compared to pipes
00:43:13 <systemfault> I mean, I worked with node for about 2.5 years now… never had a problem like that.
00:43:18 <systemfault> But I guess that’s a possibility
00:43:21 <AleksejsWork> Hello, I'm trying to install html-conduit, and get an error Module `Control.Concurrent.STM' does not export `tryReadTMVar'
00:43:25 <systemfault> So yeah, it could conflict.
00:43:29 <Zekka> Do you think this pattern's wrong/bad, and if so should it be replaced?
00:44:01 <bergmark> i think it's good that GHC prevents this problem, even if it's unlikely to happen
00:44:04 <systemfault> Zekka: Depends, I would need to see how it’s done.
00:44:24 <Zekka> systemfault: It
00:44:32 <Zekka> It's not terribly uncommon with Haskell code
00:44:48 <Zekka> very often someone will describe something pretty general and a lot of people will make libraries that do specificc things with it
00:45:00 <Zekka> i.e. pipes describes coroutines and pipes-parse describes coroutiney parsers
00:45:07 <systemfault> I see
00:45:23 <Zekka> You can't really write coroutiney parsers without acknowledging coroutines in some way
00:45:33 <systemfault> I agree :)
00:45:42 <Zekka> so it's natural for pipes-parse to return coroutiney types
00:47:36 <frerich> Is anybody aware of some 'best practices' for minimizing the startup time of Haskell processes? I wrote a command line utility which is started very often (it's a compiler wrapper) and it would be nice to keep the overhead to a minimum.
00:47:56 <Zekka> frerich: Not offhand, actually.
00:48:15 <Zekka> which surprises me because I've written some similar wrappers and never actually noticed problems like that
00:48:36 <frerich> Zekka: I didn't notice any problems. Yet. :-)
00:48:39 <MP2E> i haven't had to worry about startup time, my CLI applications have already been pretty snappy!
00:48:59 <Zekka> Fortunately we're not in a language like Java or Clojure where all the performance comes at a major cost in bootup time
00:49:00 <MP2E> only time I noticed bad startup time is when I strictly read in a large file instead of reading in pieces
00:49:09 <MP2E> and this was a like 300MB file before I noticed heh
00:49:35 <MP2E> read in a whole large file*
00:50:22 <frerich> I suspect it's more of an issue on Windows, where my tool will be running.
00:50:57 * frerich writes something like 'ccache', but for MSVC - already did that in Python but now want to see how it would work out in Haskell. :-)
00:51:27 <Zekka> One of the major frustrations with my java build system -- it takes about ten seconds to start up
01:04:56 <suOya_> How do I combine StateT and MaybeT if I want my stateful computation to stop as soon as it encounters a Nothing-value?
01:05:04 <suOya_> and thus return Nothing as a state?
01:05:46 <Zekka> suOya_: It's not the same as 'Nothing as a state' because really there is no state if the computation fails, but I think you want something like MaybeT (StateT s m a)
01:06:50 <suOya_> alright
01:07:52 <Tjr> How much do GADTs cost in runtime?
01:07:52 <Tjr> http://stackoverflow.com/questions/5426513/performance-implications-of-using-gadts
01:07:53 <Tjr> I'd assume that the restrictions of the above examples are known at compile time, so that the compiler should optimize them away. But is that really the case?
01:10:40 <Cale> Tjr: No more than any other sort of algebraic datatype
01:11:09 <Tjr> thanks
01:22:49 <solidus-river> i'm trying ot use a type alias to alias V2 Double
01:23:04 <solidus-river> but when i do that ghc complains that i can tus ^._x on my type
01:23:17 <solidus-river> but using ^._x on V2 Double works swell
01:23:34 <Welkin> solidus-river, how is it going with netwire?
01:23:57 <solidus-river> its going very well! i'm just about done
01:24:02 <solidus-river> but now i'm getting confused by Data.Linear
01:24:08 <solidus-river> i'm trying to creat a type alias
01:24:08 <Welkin> what did you make?
01:24:15 <solidus-river> i'm making space invaders
01:24:18 <solidus-river> but its not done yet
01:25:16 <k00mi> solidus-river: what did you write exactly?
01:26:14 <raschwell> Hey, does anyone make embedded systems here?
01:26:34 <solidus-river> k00mi: actually i think i got it, i need to import _x and _y from Linear.V2
01:26:48 <solidus-river> wait, but shouldn't the alias take care of that?
01:27:11 <k00mi> an alias has nothing to do with imports
01:27:41 <solidus-river> http://lpaste.net/107590
01:27:56 <solidus-river> wait i can make tha tmore clear
01:30:01 <k00mi> you never import or export _x
01:30:54 <solidus-river> why is this so
01:30:56 <solidus-river> http://lpaste.net/107590
01:30:57 <k00mi> and Point is not a value contstructor
01:31:12 <solidus-river> oh
01:31:17 <solidus-river> so i should be using a newtype there then
01:32:33 <k00mi> what package does Data.Linear come from?
01:32:44 <solidus-river> wait no that still doesnt work
01:32:51 <solidus-river> it comes from ekmets Linear
01:33:03 <solidus-river> https://hackage.haskell.org/package/linear
01:33:04 <k00mi> you can just use the V2 constructor
01:33:08 <solidus-river> i dont get why that code doesnt work though
01:33:14 <solidus-river> well thats not my actual problem
01:33:21 <solidus-river> let me give a better example
01:33:23 <k00mi> that package exports no modules under Data.
01:33:29 <solidus-river> i'm defining a new data type that uses that type alias
01:33:31 <solidus-river> and pattern matching on it
01:33:36 <solidus-river> and then trying to use _x on that
01:33:39 <solidus-river> and thats what is complaining
01:33:54 <solidus-river> yeah that was a typo on my part
01:34:19 <k00mi> show me exactly what you are doing
01:35:18 <k00mi> if you import _x in module X, that module does not export _x unless you explicitly put it into the export list
01:37:19 <solidus-river> bah, let meok
01:37:21 <solidus-river> http://lpaste.net/107590
01:37:39 <solidus-river> i put together whats actually causing the error with all relevant modules
01:38:07 <solidus-river> the thing is that when i import Linear.V2 (V2(..)) it still doesnt understand what _x is
01:38:22 <jle`> where is _x defined?
01:38:33 <jle`> or exported
01:38:38 <jle`> isn't it a lens from one of the other modules?
01:38:48 <solidus-river> jle`: yeah its a lens from Linear.V2
01:38:59 <jle`> so import Linear.V2 (V2(..), _x) ...?
01:39:02 <solidus-river> so import Linear.V2 (V2(..)) should get it
01:39:06 <solidus-river> hmm, maybe
01:39:33 <jle`> V2(..) only exports V2 and its constructors
01:39:43 <jle`> so just V2 the type, and V2 the function/constructor
01:39:47 <jle`> it's like V2(V2)
01:39:50 <jle`> it doesn't export _x
01:39:52 <haasn> (and any record fields)
01:40:01 <jle`> ah yes, that too.  well in this case there aren't
01:40:03 <jle`> any
01:40:15 <solidus-river> ah, yeah thats it
01:40:17 <k00mi> and even then, you have to import it in the module you actualy use it in
01:40:25 <jle`> hm. it looks like _x is a part of the R1 typeclass, so maybe adding (R1(..)) would help?
01:40:31 <solidus-river> hmm, so would this be solved if i did a newType?
01:40:38 <jle`> solidus-river: what newtype?
01:40:38 <k00mi> no
01:40:42 <solidus-river> well, i guess its not bad
01:40:57 <jle`> _x is just a normal ol' function...it's not a special constructor function or anything
01:41:02 <jle`> well, it's special in that it's a typeclass method
01:41:09 <jle`> but it doesn't have anything to do with the V2 type
01:41:20 <solidus-river> my use of any there is bad too, i was mid writing that function when i got the error tha tdidn't make sense to me
01:41:42 <solidus-river> that makes sense then
01:42:56 <solidus-river> yucky i have to write my own line segment intersection / closest point
01:43:16 <jle`> solidus-river: time to dig out the vector algebra? ;)
01:43:55 <solidus-river> heh, yeah, for some reason i thought Linear would solve all my problems
01:43:57 <Welkin> it's only 2
01:43:59 <Welkin> it's only 2d
01:44:01 <solidus-river> alas, it is but a set of Types
01:44:25 <Welkin> hm
01:44:44 <Welkin> a 4-dimensional video game would be interesting
01:44:44 <solidus-river> i know, i can get it was looking for a batteries included lib for matrix math / linear algebra stuff if anyone knows of one
01:44:49 <solidus-river> if not i know my vector math
01:45:01 <solidus-river> Welkin: have you seen Promethius?
01:45:06 <Welkin> the movie?
01:45:26 <Welkin> the only 4-dimensional object I know of is the tesserect
01:45:39 <Welkin> tesseract*
01:46:33 <joof> Fez, but in 4D
01:46:42 <Welkin> how in 4d?
01:46:51 <solidus-river> Welkin: ah, i cant find it, someone made a great puzzle game using unreal engine 3 that wasn't 4d but also wasn't in cartesian space
01:47:06 <joof> you get a 3D cross section that is flattened down with perspective
01:47:12 <joof> then rotate in another dim
01:47:20 <joof> would be cray
01:47:32 <Tene> Welkin: You're probably also familiar with a 4-sphere.
01:47:43 <joof> Fez is already too mind bending though :P
01:49:58 <joof> klein bottles are fun
01:51:40 <Welkin> do you use it as a water bottle?
01:51:58 <joof> probably not
01:52:07 <Welkin> I would
01:52:45 <Tene> It's a good choice; it already contains all water in the universe.
01:53:03 <Tene> It's a bad choice; it already contains all contaminants in the universe.
01:53:11 <deni> i don't get why ppl think haddock is documentation.... api docs are api docs....not docs in general. I mean it's better then nothing but still
01:53:35 <Welkin> it is documentation if you comment your code properly
01:53:39 <deni> the other thing that perplexes me is that ppl seem to like mixing those 2...ie. writing tutorialish docs in the code (that get generated after)
01:53:49 <deni> it's just noise in the code imho
01:54:06 <Welkin> literate haskell
01:54:10 <deni> it's fine to have api docs there that get generated after..but i don't like essays in code comments
01:54:21 <deni> Welkin: ?
01:54:41 <jle`> deni: http://en.wikipedia.org/wiki/Literate_programming
01:54:48 <deni> jle`: just checking it out
01:54:54 <Welkin> http://www.haskell.org/haskellwiki/Literate_programming#Bird_Style
01:54:56 <joof> some do though... to the point where the code is put inside comments
01:55:03 <joof> basically what they said
01:55:17 <deni> i doubt itt will change my mind....i just find it ugly
01:56:01 <Welkin> comments are 50%-80% of your code
01:56:14 <deni> if that's the only docs ppl do i can understand why a lot of libs are undocumented
01:56:29 <deni> Welkin: yeah i disagree with that... like a lot
01:56:42 <jle`> deni: i think that's mostly for tutorials; it's nice when you have a tutorial you can actually run
01:56:42 <deni> too many comments
01:56:55 <jle`> you can say "load this tutorial up; it's literally source code"
01:57:11 <jle`> and haskell code tends to be very dense, so they are really just telling a story, with some source code inside
01:57:25 <deni> jle`: okay that's beneficial yes....kinda like doctests then....ie they force you to always update them
01:57:38 <jle`> i don't think i would do this for documentation though
01:57:43 <deni> where-as normaln docs can get outdated
01:57:56 <Welkin> undocumented code is worthless
01:57:56 <jle`> but a lot of GHC/base is written in literate haskell style
01:58:11 <jle`> i document my code but with normal haddock style documentation
01:58:19 <joof> theres this crazy guy named donald knuth that might disagree, but I tend to agree with you in most cases
01:58:34 <joof> about literate programming*
01:58:47 <deni> joof: i know...i can still disagree :D
01:59:05 <deni> i might come around....but for now it just seems ugly and unreadable
01:59:24 <mbrock> literate programming is a particular style that has its uses...
02:00:05 <deni> the haskell world could benefit from more docs indeed....so any way ppl write docs it's better then not writing them at all...but still....there's a long way in user friendlyness i guess
02:00:14 <Welkin> deni, http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
02:00:20 <Welkin> beautiful
02:01:09 <deni> Welkin: tnx for the link will check it out
02:01:11 <mbrock> there's also lhs2TeX which lets you write LaTeX papers as executable Haskell
02:01:17 <solidus-river> f . g = f(g(x))
02:01:21 <solidus-river> or am i getting that backwords
02:01:28 <suOya_> that's correct
02:01:32 <mbrock> (that is obviously a different thing than writing a library module with Haddocks)
02:01:33 <Welkin> latex source code is so ugly
02:01:53 <deni> also a  TOC in the docs goes a long way...you just can't have that in haddock
02:02:15 <deni> (that = that level of good readable easy to use docs)
02:04:29 <mbrock> so, you'd like more freestanding documentation for Haskell libraries, aside from Haddock?
02:05:14 <deni> mbrock: yes
02:05:20 <mbrock> I've mostly been very happy with Haddock documentation, especially considering that types often tell you a lot
02:05:25 <deni> freestanding is the word i was looking for tnx
02:05:44 <deni> mbrock: they don't tell you how to use the library
02:05:58 <mbrock> the other day we were trying to use some Node.js library which had a rather long README, but lacking very essential info about what kind of things are returned from important methods...
02:06:05 <deni> they do in a way ...i get what you're saying...but c'mon ppl you have to admin that good freestanding docs are a good thing
02:06:14 <Welkin> yes
02:06:22 <Welkin> and haskell needs a lot more library tutorials
02:06:26 <jle`> yes
02:06:27 <jle`> yes it does
02:06:33 <joof> both those things
02:06:42 <Welkin> it makes me want to write some as I learn
02:06:43 <jle`> sometimes people include full tutorials in their haddocks though
02:06:44 <deni> mbrock: github README's (or projects that have only a single readme file) tend to be bad docs
02:06:48 <jle`> Welkin: do it :D
02:07:05 <mbrock> yeah, but they're also work, and being good at writing libraries is maybe not the same as being good at writing free-form documentation... they must be kept up to date... and so on
02:07:07 <jle`> example: http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html
02:07:24 <frerich> Welkin: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs is really nice indeed.
02:07:54 <deni> jle`: i've noticed.....but tbh a lot of new comers miss that...it's just easier to read actual docs to wich the library points you to
02:07:55 <mbrock> yeah, Pipes is very nicely documented. I like how the tutorial is in Haddock, without cluttering the main modules
02:08:51 <deni> Welkin: agree about writing libs vs. writing docs....but it's just work like any other, somebody's gotta do it
02:08:57 <deni> i tend to ignore libs that don't have any docs
02:08:59 <deni> or bad docs
02:09:11 <deni> it just seems like a half finished thing
02:09:47 <osfameron> yeah.  if it doesn't have docs, it's not a library, it's just source code
02:09:54 <deni> mbrock: also node.js (and other weakly typed dynamic langs ) tend to not document return "types" at all....i've kinda gotten used to it
02:10:01 <mbrock> if I look at the Haddock of a library and find myself with outstanding questions, then I consider the documentation poor... for some kinds of libraries, the types themselves can be expressive enough to make everything clear to a competent Haskell user
02:10:39 <machrider> speaking of library docs, anyone know of a sodium tutorial for people who are new to functional reactive programming?
02:10:41 <deni> mbrock: keyword being competent...i'm mostly talking about newcomers here .... and attracting more
02:10:43 <mbrock> if we're talking pet peeves, my questions often tend to be "which exceptions can be thrown here?"
02:11:15 <deni> i'm not just whining..i would like to help...but for some libs is't just way to hard for me to "crack the code"....understand everything and then write some docs
02:11:16 <mbrock> deni: yeah, agreed. it'd be interesting to think about what kind of community resource would most effectively help newcomers use libraries...
02:11:36 <mbrock> bigger packages like Yesod etc obviously have tutorials and even books
02:11:55 <deni> mbrock: yeah i was very delighted to seee that
02:12:01 <deni> but that's like the only example i know of :D
02:12:20 <deni> we need more of those
02:12:22 <mbrock> with some libraries it might be more effective to have cookbook-style documentation
02:12:51 <deni> agreed
02:13:10 <mbrock> it could be cool to have a typechecked repository of community-contributed cookbook examples :)
02:13:30 <deni> I'm amazed at how many libs I've found don't even have link to github..(or a link to something of the sorts)
02:14:15 <deni> and I'd argue that blog posts don't really help that much....they may or may not help ppl *who find them*
02:14:51 <deni> best bet is markdown docs in the repo of the library that get's generated somehow/somewhere
02:15:17 <deni> in the python world i mostly use sphinx (although i don't like rst) and https://readthedocs.org/
02:15:37 <tdammers> deni: part of it is the price we pay for a low-threshold package repository
02:16:01 <tdammers> hackage is so easy to use that lots of people (including myself) just throw their own special-purpose libraries in there, just so cabal can pull them in
02:16:10 <jle`> machrider: have you seen that talk on youtube?
02:16:34 <deni> tdammers: I do that with pypi as well...but even internal packages need docs :D
02:16:58 <deni> tdammers: but yeah i get what you're saying
02:17:00 <tdammers> well; in Python, *everything* needs extensive amounts of documentation
02:17:18 <tdammers> in Haskell, you can often get away with descriptive types
02:17:30 <machrider> jle`: nope. i don't tend to go for videos, but if it's the best thing out there, ok :)
02:17:40 <tdammers> it's not the ideal situation, but types can double for minimum-viable documentation
02:17:40 <machrider> jle`: what's it called (or got a link)?
02:17:47 <jle`> machrider: i don't know much about sodium, but that's where i learned the most about it
02:18:04 <deni> tdammers: a lot of ppl say that...that's only partialy true and is used a lot of times as an excuse to not have to write docs
02:18:08 <jle`> machrider: https://www.youtube.com/watch?v=gaG3tIb3Lbk
02:18:14 <machrider> jle`: great, thanks!
02:18:15 <jle`> maybe it'll help :)  i haven't used sodium in real life
02:18:23 <jle`> i am an afrp/pull driven frp guy
02:18:24 <tdammers> runServer :: (Request -> Response) -> Port -> IO ()
02:18:42 <tdammers> for an internal library, I don't need any extra documentation here
02:19:05 <machrider> jle`: does the 'a' in "afrp" stand for asynchronous?
02:19:11 <jle`> machrider: arrowized
02:19:18 <mbrock> I totally agree that good guides and documentation are great things to have, but I don't quite agree with "excuse to not have to write docs" -- for me it's quite honestly an encouragement to not *rely* on documentation, but to work hard to make my type signatures "blindingly obvious"
02:19:23 <jle`> async is probably more sodium/push-pull-frp/event-driven frp's deal
02:19:23 <Welkin> isn't frp always arrowized?
02:19:26 <jle`> (/) = synonym
02:19:56 <jle`> Welkin: there are FRP implementations whose api isn't arrow-based
02:20:02 <jle`> they tend to be push-pull/event-driven
02:20:31 <machrider> well here's a question for the channel: what's the most popular FRP approach to use today? sodium looked pretty popular, which is why i am looking at it now. (use case: games)
02:20:34 <jle`> reactive-banana and sodium are the big examples
02:20:49 <jle`> machrider: what kind of game?
02:20:56 <Welkin> netwire is good for games
02:20:57 <deni> mbrock: but those 2 things aren't excluding one another...i'm saying that you should have both :)
02:21:06 <jle`> is your game logic...frame-driven?  or discrete event/gui-driven?
02:21:07 <machrider> jle`: simple for now. i'll probably write tetris as an exercise.
02:21:43 <jle`> tetris might be good for pull/frame-driven frp
02:21:45 <jle`> like netwire
02:21:53 <frerich> mbrock: I partly agree - to some degree, documentation tends to just duplicate code. It just happens to use a different language (e.g. English vs. Haskell). However, documentation is not only about *what* a function does - it's also about examples and explaining *why* it does things the way it does (in case that matters) and *when* you'd rather use this function than the other one.
02:22:05 <tdammers> tetris is in a weird spot between frame-driven and event-driven :D
02:22:14 <machrider> tdammers: i was just thinking that
02:22:41 <deni> frerich: nicely put
02:22:46 <jle`> in this case, one of the main problems that push/pull frp attempts to solve is the cost of re-computing everything when nothing is changing
02:22:50 <jle`> as in...GUI's
02:23:05 <tdammers> re documentation: it's a continuum
02:23:07 <jle`> most of the time in GUIs, nothing ever changes, so in pull-based frp, everything is reevaulated at every step, at much cost
02:23:27 <jle`> for tetris, there are things constantly changing continuously
02:23:29 <machrider> so push-based is like event-driven?
02:23:39 <mbrock> frerich: agreed. those aspects can mostly be integrated in Haddock comments, where every user of the library can find them easily!
02:23:45 <tdammers> the perfect programming language would give you a documentation metalanguage that would cover all possible use cases for documentation, and it would be fully integrated into the language itself
02:23:48 <jle`> push/pull refer towhat drives evaluation
02:24:02 <jle`> in event-driven, an event 'pushes' updates to everything
02:24:14 <jle`> in frame-driven, every frame 'pulls'/computes all of the values
02:24:24 <tdammers> real programming languages aren't perfect though, so you have to resort to free-form documentation to some degree
02:24:32 <machrider> jle`: ok, makes sense
02:24:55 <tdammers> and even in a perfect language, it's up to the programmer to use the documentation features to their advantage
02:25:06 <jle`> machrider: so in this case netwire might be a better fit
02:25:16 <machrider> jle`: i guess tetris is closer to pull as you describe it, just that the ticks are far less frequent than 60fps
02:25:29 <jle`> machrider: oh yeah, that's true
02:25:30 <klrr_> ?src max
02:25:30 <lambdabot> max x y = if x <= y then y else x
02:25:40 <frerich> Maybe a meta-language where functions have types like 'data Function = Definition Motivation [Example] [Alternative]' :)
02:25:47 <jle`> i imagined the blocks going down continuously for some reason
02:26:05 <machrider> i'll check out netwire, though.
02:26:05 <jle`> if the blocks go down block by block...then you might like sodium then
02:26:32 <tdammers> frerich: javadoc / phpdoc / whateverdoc / doxygen is a crude tentative step in that direction
02:26:42 <mbrock> another aspect to consider: Haskell libraries should be encouraged to have a "compositional" style, instead of "state machine style," and this itself should mitigate the need for "user guide"-style documentation...
02:26:50 <jle`> i've been meaning to use this summer to write a series of netwire tutorials, but i haven't gotten around to it yet.  here is one intrudcutino https://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html ... and another https://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html ... and also the README in the repo is nice too
02:26:51 <tdammers> the integration isn't very deep, the compiler doesn't verify it, but it could
02:27:02 <tdammers> but it could integrate much deeper even
02:27:07 <jle`> machrider: but yeah, if blocks really only fall in dicrete 'ticks'...then sodium might be best
02:27:13 <jle`> i had in mind the blocks falling continuously
02:27:22 <frerich> tdammers: True, you could extend on those to have some sort of static verification, i.e. a "documented program" is not well-typed if a function has no example or so.
02:27:45 <Welkin> That is also using old netwire and old sdl
02:27:48 <mbrock> Haddock has some kind of support for specifications, no?
02:27:55 <mbrock> e.g., QuickCheck properties?
02:28:04 <Welkin> http://hub.darcs.net/ertes/netwire
02:28:06 <machrider> jle`: ok, well i'll try to look at both, so i can see where their strengths are different. thanks for the help!
02:28:48 <jle`> machrider: no problem :)
02:28:55 <jle`> machrider: there really isn't a good resource for comparing them out right now
02:28:59 <jle`> it's pretty unfortunate
02:29:14 <machrider> honestly, i was thinking if i do figure out sodium, i'd write a tutorial afterward.
02:29:55 <machrider> (but i also have that video queued up now)
02:31:17 <jle`> machrider: :)
02:31:21 <jle`> together we will change the world
02:31:29 <jle`> do you have a blog or something?
02:34:48 <ocharles> Does anyone know if "liftCompose :: f a -> Compose f g a", where "lifftCompose = Compose . fmap pure" exists anywhere?
02:36:06 <HugoDaniel> (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
02:36:08 <machrider> jle`: i do. when i put something decent on it, i'll link you to it ;)
02:37:22 <Welkin> :t (.)
02:37:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:37:30 <Welkin> :t (.) . (.)
02:37:31 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:37:34 <Welkin> hah
02:37:36 <jle`> machrider: :)
02:42:57 <suOya_> :t (.) . (.) . (.)
02:42:58 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
03:07:14 <vlatkoB> Is there a way to implement joinF :: Functor f => f (f a) -> f a
03:07:37 <darthdeus> imho if there was you'd have a monad
03:08:08 <supki> vlatkoB: no
03:08:15 <vlatkoB> Yeah, I thought so
03:08:27 <darthdeus> since join can be used to implement bind
03:09:50 <tulcod> darthdeus: assuming certain naturality conditions etc, yes
03:10:55 <jle`> vlatkoB: you can actually just think of Monad as "functor with join.                                   (and return)"
03:12:12 <vlatkoB> I implemented it with concrete type, but thought it might be possible to make it polymorphic
03:13:19 <vlatkoB> jle': Interesting
03:30:14 <suOya_> Are monad transformers used consistently in real Haskell applications or are they more of a theoretic curiosity?
03:31:14 <tdammers> suOya_: they're very real and very pragmatic
03:31:51 <tdammers> suOya_: in fact, I highly appreciate libraries that implement their monads as transformers whenever possible
03:32:17 <tdammers> because it means I can integrate them with my monad stacks, rather than translate between different monads manually
03:32:37 <suOya_> tdammers: Yeah, I was just thinking if they have performance/memory issues in large scales
03:33:04 <tdammers> suOya_: probably not. they're just compile-time sugar, mostly
03:33:58 <tdammers> similar to how a state monad doesn't introduce any runtime performance overhead over explicit state-passing
03:34:43 <suOya_> Ok
03:36:59 <streitdoni> hellp
03:37:01 <streitdoni> hello
03:37:29 <MP2E> suOya_ : Monad Transformers are pretty efficient, and are currently the best solution we have to the 'monad composition problem' in regards to performance, readability etc. There actually is also extensible-effects, which looks a lot nicer to me, but it's also waaaaaaaaay slower :(
03:37:42 <MP2E> it doesn't look like extensible effects will be replacing Monad Transformers anytime soon heh
03:41:09 <suOya_> MP2E: I haven't heard of that, but maybe I don't need to if transformers are good enough
03:44:14 <streitdoni_> hello can anybody help me with following? i'm searching for a solution. I ned to find out  if the appearance of the first number is earlier then the second one. The function signature: before :: Eq a => a -> a -> [a] -> Bool
03:45:55 <streitdoni_> so i first thought about a recursive solution
03:46:30 <streitdoni_> with tail[a]
03:46:41 <tulcod> streitdoni_: you can just define the recursion manually...
03:47:08 <tulcod> streitdoni_: i mean yeah, defining it recursively sounds good
03:49:51 <streitdoni_> is there any possibility to receive the the index
03:50:30 <streitdoni_> without Data.List
03:51:07 <ddrone> Hi everyone. I have a following question: with suitable definition of MonadTrans one can define a composition of monad transformers
03:51:11 <k00mi> MP2E: monad-classes looks promising
03:51:12 <ddrone> Here is an example: http://lpaste.net/17966767322169344
03:51:40 <tulcod> streitdoni_: you shouldn't need that to implement "before" with the given signature
03:51:52 <ddrone> I wonder if this is already implemented somewhere. Also I am interested whether this composition is useful at all
03:52:04 * hackagebot cabal2nix 1.66 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.66 (PeterSimons)
03:52:13 <tulcod> streitdoni_: also, what's the problem with using Data.List?
03:55:47 <vlatkoB> streitdoni_: Don't use index(es), just pattern guards and recursion for walking through the list
03:55:48 <sshine> if conduits are about composition of monadic folds, is there a fusion algebra for these?
03:56:19 <streitdoni_> it's for exam preparation. And we didn't use the Data.list in lection.
03:56:24 <xificurC> is realworldhaskell a good starting book? Are some parts of it outdated by now?
03:57:04 <sshine> streitdoni_, different examiners might value different things, but good programmers DRY. :)
03:57:31 <vlatkoB> streitdoni_: You don't need Data.List or anything else.
03:58:20 <sshine> streitdoni_, in one course locally, where Haskell and Prolog are both used, re-use within Haskell is encouraged while re-use within Prolog is discouraged (because then it's hard to come up with simple exercises since the language doesn't take up much time on the course).
03:59:57 <streitdoni_> my solution is: walking through the list until i find the first number. After i check after every step, if the second number appears
04:00:14 <sshine> xificurC, I'd say: mostly because most course materials rely on it, it's fine.
04:00:38 <streitdoni_> i'm going to try this
04:00:45 <tulcod> streitdoni_: why do you want to find the first number first?
04:01:01 <tulcod> streitdoni_: if you find the first number first, output True. if you find the  second number first, output False
04:01:05 <xificurC> sshine: thanks
04:01:19 <tulcod> streitdoni_: if you can't find either (ie reach end of the list before finding either), output whatever
04:01:22 <sshine> xificurC, https://github.com/bitemyapp/learnhaskell
04:01:24 <tulcod> streitdoni_: if you find neither, recurse
04:01:53 <streitdoni_> ok i try this
04:04:42 <friden> any of the people here doing challenges at hackerrank.com? i got so happy when i got alot of challenges to solve in haskell and send in solutions and compete with others
04:04:45 <friden> its good training^^
04:09:35 <matematikaadit> streitdoni_: it would help if you give us example of that functions in use.
04:09:47 <streitdoni_> ok
04:10:25 <streitdoni_> before x y list
04:10:25 <streitdoni_> 		|head list == x =True
04:10:25 <streitdoni_> 		|head list == y = False
04:10:25 <streitdoni_> 		|otherwise =  before x y (tail list)
04:10:39 <streitdoni_> i havn't tested it yet
04:11:35 <tulcod> friden: i think many haskellers are doing project euler
04:11:37 <streitdoni_> yeah it works
04:11:41 <matematikaadit> streitdoni_: I mean something like: before 1 2 [1,2,3,4] => true, before 2 1 [1,2,3,4] => false, etc.
04:12:31 <tulcod> streitdoni_: you should lookup some more syntax tricks... you can do pattern matching on the list
04:12:39 <matematikaadit> streitdoni_: what happen when have something like: before 1 2 [2, 1, 2, 3]
04:12:59 <tulcod> streitdoni_: write it as: before x y (h:t), head list == h, tail list == t
04:13:14 <streitdoni_> <matematikaadit> this should return true as well
04:13:44 <tulcod> streitdoni_: so:  before x y (h:t) | h == x = True ; | h == y = False; | otherwise = before x y t
04:14:02 <matematikaadit> streitdoni_: but as tulcod sugestion, you find the second number first, so it'll result in False
04:14:03 <tulcod> streitdoni_: and then you need another clause for: before x y [] = False  (or whatever)
04:14:32 <tulcod> streitdoni_: (which you shove under the rug by using the unsafe function "head")
04:15:31 <streitdoni_> i have been confronted with haskell for about 2 month :-D
04:17:07 * hackagebot haddock 0.8 - Haddock is a documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-0.8 (SimonHengel)
04:17:56 <matematikaadit> streitdoni_: I think your own solution is already correct
04:18:47 <matematikaadit> tulcod: before 1 2 [2,1,2,3] should be True
04:18:48 <streitdoni_> but i'm happy that you helped me to solve and undersand the solution.
04:22:06 <streitdoni_> like matematikaadit's post. how can  "before 1 2 [2,1,2,3] should be True" be realized?
04:22:07 * hackagebot haddock 0.9 - Haddock is a documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-0.9 (SimonHengel)
04:23:42 <matematikaadit> streitdoni_: your first solution that try to find the first number and then the second number after that seems correct
04:24:27 <streitdoni_> is there a possibility to split the list at the appearance of the first number?
04:24:54 <matematikaadit> streitdoni_: it doesn't matter whether you found the second number first or not, as long you found the second number "after" you found the first one
04:25:27 <streitdoni_> thats true
04:25:53 <tulcod> streitdoni_: haskell teaches you to think about what data you /really/ need to extract from input data
04:26:13 <tulcod> streitdoni_: try and think about that in this case. do you /really/ need to know the index of the appearance of the first (or second) number?
04:30:12 <matematikaadit> streitdoni_: what is the result of before x y []?
04:30:44 <ij> Is there a maybeMod defined somewhere?
04:31:13 <streitdoni_> empty list...
04:32:08 <streitdoni_> but i'm still working to realize the  problem if the second number appears two times and the first number is between
04:32:12 <zwer> tgggg
04:32:29 <matematikaadit> streitdoni_: empty list?
04:32:40 <streitdoni_> *** Exception: Prelude.head: empty list
04:32:49 <matematikaadit> @hoogle maybeMod
04:32:51 <lambdabot> No results found
04:34:05 <matematikaadit> streitdoni_: well, what should be the answer of that before x y []? True or False
04:34:26 <matematikaadit> streitdoni_: after that you could move to the next case, when the list isn't empty
04:34:48 <matematikaadit> ij: what is maybeMod?
04:35:14 <streitdoni_> @matematikaadit false
04:35:14 <lambdabot> Unknown command, try @list
04:35:46 <matematikaadit> streitdoni_: then you could start defining your function as: before x y [] = False
04:36:09 <ij> matematikaadit, A safe version of mod, that wouldn't throw an exception.
04:38:07 <pjdelport> before a b = not . null . dropWhile (/= b) . dropWhile (/= a)
04:38:08 <pjdelport> ?
04:39:08 <streitdoni_> i think i got it. because i iterate through the list i return false if the nummber is the second one
04:40:25 <streitdoni_> o i'm wrong thats not the right solution
04:40:56 <matematikaadit> streitdoni_: well, pjdelport already sugesting one solution.
04:46:26 <streitdoni_> yes but i don't anderstand pjdelport'S solution
04:46:55 <suOya_> Are there any other 'impure' computations in Haskell than IO?
04:47:09 * hackagebot tasty-html 0.2 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.2 (jdnavarro)
04:47:30 <pjdelport> streitdoni_: It reads like a pipeline: imagine your original list is flowing in from the right to the left, passed to each function in turn.
04:48:33 <pjdelport> streitdoni_: dropWhile (/= a) skips elements until it finds an a value, and then dropWhile (/= b) takes the remainder and skips values until it finds a b value.
04:48:53 <streitdoni_> ok a and b are the numbers. but where is the list
04:49:42 <pjdelport> streitdoni_: Oh, it's implicit: the above is written just with function composition. You can also say:
04:49:42 <pjdelport> (before a b) xs = (not . null . dropWhile (/= b) . dropWhile (/= a)) xs
04:50:39 <pjdelport> Or: before a b xs = not . null . dropWhile (/= b) . dropWhile (/= a) $ xs
04:51:12 <mbrock> suOya_: you might be interested in ST, though it is pure in some sense
04:51:47 <pjdelport> Those are all equivalent ways of expressing it, but for functional pipelines, it's often idiomatic to leave the pipeline input implied.
04:52:09 <mbrock> suOya_: it basically gives you mutable variables within some computation, but unlike IO it provides a way to go from `ST a -> a`
04:53:08 <pjdelport> suOya_: It depends on how you define "impure", probably. In most senses of the word in Haskell, IO is perfectly pure: only functions like unsafePerformIO are impure.
04:53:14 <matematikaadit> ij: well, I think you need to define it yourself. safeMod x y = if y == 0 then Nothing else x `mod` y
04:54:45 <matematikaadit> ij: *Just x `mod` y
04:54:53 <matematikaadit> ij: *Just (x `mod` y)
04:55:08 <pjdelport> suOya_: In the sense that IO "taints" values, it is impure in the same sense that *all* monads are impure: by definition, you can only lift pure values into a monadic type, and cannot get them out without going outside the monadic interface in a type-specific way.
04:55:34 <suOya_> mbrock: Isn't ST safe though?
04:55:43 <suOya_> pjdelport: Yeah
04:56:04 <pjdelport> suOya_: ST is safe, but so is IO :)
04:56:08 <suOya_> pjdelport: I was wondering if there were any other monads like IO which you couldn't escape
04:56:13 <suOya_> you can escape ST
04:56:53 <suOya_> Maybe purity is the wrong question then
04:57:05 <suOya_> Just curious^^
05:06:35 <streitdoni_> so i think i got an solution
05:06:35 <streitdoni_> before :: Eq a => a -> a -> [a] -> Bool
05:06:35 <streitdoni_> before x y [] = False
05:06:35 <streitdoni_> before x y list
05:06:35 <streitdoni_> 		|last list == y = True
05:06:36 <streitdoni_> 		|last list == x = False
05:06:37 <streitdoni_> 		|otherwise =  before x y (init list)
05:09:10 <tulcod> streitdoni_: that sounds kinda backwards and inefficient, but if it works, sure
05:14:44 <ij> matematikaadit, Point was to receive Nothing upon 3 `mod` 0
05:15:11 <mathk> with cabal I have a conflict with binary and SHA. I have a sandbox with SHA 1.6.4.1 installed and it depends on binary-0.5.1.1 Unfortunately I need binary >= 0.6. But I do not understand why SHA depends on binary 0.5. On hackage it seems to depend on binary > 0.6
05:16:19 <matematikaadit> ij: yes this would do: safeMod x y = if y == 0 then Nothing else Just (x `mod` y)
05:17:26 <matematikaadit> streitdoni_: how about this:
05:17:35 <matematikaadit> before x y [] = False
05:17:56 <matematikaadit> before x y (a:as)
05:18:06 <matematikaadit>   | x == a = ... do something
05:18:23 <matematikaadit>   | otherwise = before x y as
05:22:43 <xificurC> while reading chapter 5 of real world haskell about JSON library I have to say it's disappointing - the code is scattered all over the chapter, the headers of the files are incorrect and there's no summary of the files or a link to complete files. I'm in the middle of the chapter and completely lost.
05:25:01 <pjdelport> suOya_: One way to look at the functional purity of it is to observe that it's runST that's pure, and it's pure only because by default you can only compose ST values out of pure parts.
05:26:24 <pjdelport> suOya_: So you can recursively expand the body of a runST into all its constituent definitions and parts, and the ultimate leaves (or inputs) of that expression will all be pure.
05:27:21 <slomo> is there something more clever to split a number into its digits other than "f = reverse . unfoldr (\b -> if b > 0 then Just (b `mod` 10, b `div` 10) else Nothing)"  (someone asked that on SO but it was closed as duplicate, was just curious what a good solution could be)
05:29:13 <pjdelport> suOya_: IO on the other hand explicitly provides no such guarantee that everything embedded inside it is pure: many or most IO values represent impure effects to perform.
05:29:47 <slomo> > let f = reverse . unfoldr (\b -> if b > 0 then Just (b `mod` 10, b `div` 10) else Nothing) in f 123
05:29:49 <lambdabot>  [1,2,3]
05:31:06 <pjdelport> suOya_: On the other hand, if you can guarantee that all the parts that were composed into a specific IO action are actually pure, then unsafePerformIO will be pure as well, just like runST.
05:31:11 <ij> matematikaadit, How come no one has made a package that defines such safe functions?
05:31:35 <pjdelport> So this is pure, in that sense: unsafePerformIO $ liftM2 (+) (return 1) (return 2)
05:32:07 <pjdelport> @hackage safe
05:32:08 <lambdabot> http://hackage.haskell.org/package/safe
05:32:29 <pjdelport> ij: There's that, but it doesn't have a version of mod and friends
05:33:14 <ij> :[ I see.
05:34:32 <matematikaadit> > 1 / 0
05:34:34 <lambdabot>  Infinity
05:45:13 <bitraten> What's the best way to learn about patterns for application development in haskell?
05:49:40 <tulcod> bitraten: step 1. start writing applications in haskell
05:49:50 <haasn> step 2. hang out in #haskell
05:49:54 <mayski> look at application / library sources is what I'm doing
05:50:15 <haasn> idling in #haskell is my favorite method of learning how to program in haskell
05:50:24 <haasn> (YMMV)
05:50:27 <mayski> haha
05:51:49 <mhd> Are there any good guides to what the Dependently Typed Lambda Calculus is about? Preferably without all the Calculus of Constructions stuff.
05:52:09 <mhd> Wikipedia has an excellent one on the Simply Typed lambda calculus
05:52:16 <mhd> and one on the calculus of constructions
05:52:17 * hackagebot casadi-bindings-core 1.9.0.4 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-1.9.0.4 (GregHorn)
05:52:24 <mhd> but everything in between is missing
05:55:43 <tulcod> mhd: kinda depends on the background you have?
05:55:52 <tulcod> mhd: also, what's wrong with the calculus of constructions?
05:57:17 * hackagebot casadi-bindings 1.9.0.4 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.4 (GregHorn)
06:16:26 <ddrone> Everyone ignored my previous question :-(  I'll ask it again in generalized form then - is there any survey comparing different ways to define monad transformers?
06:17:02 <ddrone> And by "monad transformers" I mean concrete MonadTrans instances and MonadTrans class itself
06:17:19 * hackagebot deka 0.6.0.2 - Decimal floating point arithmetic  http://hackage.haskell.org/package/deka-0.6.0.2 (OmariNorman)
06:20:24 <namero999> hi. during the installation of haskell platform on windows, I got asked if I wanted to install GLUT library at the end of the process. I said yes, and nothing happened. Is this the correct behaviour? Anyone got this result? As far as I remember glut is a graphic library. Given that I just want to learn basic haskell to start, shall I ignore the problem?
06:20:34 <haasn> I wasn't aware of there being more than one way to define them
06:21:19 <haasn> namero999: iirc getting GLUT or other OpenGL-stuff working on Windows is a nightmare
06:21:26 <k00mi> ddrone: I don't understand what you mean by "concrete MonadTrans instances and MonadTrans class itself". Defining a monad transformer does not involve any classes
06:21:27 <haasn> I would probably just ignore them completely
06:21:39 <Jeanne-Kamikaze> getting anything working on windows is a nightmare
06:21:46 <haasn> Except the haskell platform :p
06:22:08 <Jeanne-Kamikaze> the haskell platform too if you have another installation of mingw lying in the paths
06:22:14 <haasn> Oh, true
06:22:14 <ddrone> I mean MonadTrans is a type class, and it could be defined in several ways. One way is used in mtl library, another one is shown here: http://lpaste.net/17966767322169344
06:22:17 <haasn> Okay, windows is a nightmare
06:22:23 <namero999> till now no problem on windows... well the only problem is that the installer gives no feedback. maybe it did something, maybe not.
06:22:37 <namero999> will ignrore, thanks
06:22:42 <namero999> ignore*
06:23:28 <haasn> ddrone: Hmm, to be honest I'm not sure if that definition even makes sense. Seems like you'd want to have a fundep | t -> m or something
06:23:40 <haasn> This seems to allow different instances for different base monads; which seems absurd
06:23:54 <haasn> I guess maybe as an optimization; but apart from that?
06:25:30 <ddrone> If by "definition make sense" you mean "there can be way to define StateT, ReaderT, etc. using this definition", then yes
06:27:08 <isomorpheous> Hey, so I'm getting these GHC warnings - http://lpaste.net/107596
06:27:20 <isomorpheous> From this code - http://lpaste.net/107597
06:27:35 <isomorpheous> would someone care to explain the errors?
06:27:59 <isomorpheous> *warnings
06:28:18 <isomorpheous> My city is having rolling blackouts, so if I go offline all of the sudden, that's why
06:28:39 <Ankhers> 'shadows' means that it is already defined in that scope. You are overwriting those methods. Then you are not using them.
06:28:55 <isomorpheous> I'm aware
06:29:00 <quchen> ddrone: As a rule of thumb, prefer your own handrolled transformers to transformer stacks. If you need a performant Reader+Writer, write your own RW Monad.
06:29:01 <isomorpheous> I'm not defining them anywhere though
06:29:12 <isomorpheous> I'm just pattern matching
06:29:43 <Ankhers> GHC thinks you are using a variables or something by that name.
06:29:59 <Ankhers> Can you post your code for that method?
06:30:26 <isomorpheous> Ankhers: It's from Network.HTTP.Types
06:30:37 <isomorpheous> Ankhers: which is from the package http-types
06:30:44 <isomorpheous> Ankhers: which I didn't write
06:30:52 <Ankhers> I know. but your Main.hs has some reference to it.
06:30:54 <pjdelport> isomorpheous: A variable-only pattern match without any constructors always matches anything, so there's no difference between the methodPost, methodGet, and _ cases
06:31:30 <ddrone> quchen, is there a benchmark on the matter?
06:31:31 <isomorpheous> pjdelport: Ahhh. Okay, how do I get around that?
06:31:50 <pjdelport> isomorpheous: Where is "requestMethod" defined, and what does it return?
06:31:56 <pjdelport> isomorpheous: You have to match on whatever that is
06:32:10 <isomorpheous> methodPost = "POST"; methodGet = "GET"
06:32:16 <isomorpheous> Ew.
06:32:18 <isomorpheous> okay
06:32:20 * hackagebot HaRe 0.7.2.5 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.5 (AlanZimmerman)
06:32:28 <isomorpheous> Thank you, pjdelport
06:32:33 <quchen> ddrone: I'm only aware of hearsay I'm afraid.
06:32:36 <isomorpheous> And others
06:32:51 <isomorpheous> Sorry, your respective nicks are out of frame
06:33:34 <pjdelport> isomorpheous: Oh, those are string / bytestring values?
06:33:42 <ddrone> quchen: That's not a good way to give suggestion for achieving better performance :-(
06:33:44 <isomorpheous> Bytestring, yep
06:34:25 <razieliyo> hi!
06:34:46 <isomorpheous> razieliyo: hi
06:34:59 <ddrone> Yeah, I thought about my question and seems like it would be useful for me to think about it a little bit more and maybe state it another way
06:35:03 <ddrone> So nevermind
06:35:18 <razieliyo> I'd like to use haskell as a inference engine for a simple game, but I don't know if I should make the graphics part on haskell or it would be easier to interop with c++, and just use haskell for logic and AI stuff
06:35:43 <razieliyo> s/inference engine/ai language/ after all
06:35:55 <osfameron> presumably that depends on how well you know the C++/graphics stuff?
06:36:13 <razieliyo> I know C++/graphics stuff well, that's because I'm doubting
06:36:44 <razieliyo> but I don't know if it's worth, or I should use haskell for graphics too
06:36:46 <pjdelport> isomorpheous: In that case you'd have to use a guard to match it, like : m | m == methodPost -> ...
06:37:22 <Iceland_jack> You can also use a pattern synony
06:37:22 <isomorpheous> pjdelport: ah - I just embedded the string values
06:37:22 <Iceland_jack>     pattern Post = "POST"
06:37:24 <Iceland_jack> *synonym
06:37:50 <isomorpheous> Iceland_jack: It's a one-off shot, so I won't
06:38:07 <isomorpheous> Iceland_jack: but thank you
06:38:14 <Iceland_jack> no problem :)
06:38:45 <quchen> ddrone: "Unroll your MTL stacks" on the Haskell Wiki: http://www.haskell.org/haskellwiki/Performance/Monads
06:40:29 <isomorpheous> razieliyo: hm
06:40:36 <ddrone> quchen: Still no concrete numbers or a source code which will produce these numbers. Thanks for the link though
06:40:50 <razieliyo> isomorpheous, I'm also worried about language mixin complications
06:41:03 <isomorpheous> razieliyo: just define some sort of uniform interface
06:41:32 <razieliyo> isomorpheous, calling C++ from haskell?
06:41:48 <isomorpheous> razieliyo: haskell has the ffi, so that's not so much of an issue
06:42:45 <isomorpheous> razieliyo: Haskell needs to be referentially transparent
06:42:48 <ddrone> quchen: By the way, do you mean that proposed way is to write manually "instance Monad Blah where" every time when I need performant Reader/Writer capabilities?
06:43:02 <isomorpheous> razieliyo: I would run the haskell part as a server, feed it certain environment variables
06:43:14 <isomorpheous> razieliyo: and build the graphics off of the response
06:43:23 <ddrone> quchen: Or there is a way one could generate this using, say, TH
06:43:57 <razieliyo> isomorpheous, hmmm, I see, I'm just checking ffi
06:44:14 <razieliyo> so, of course you mean calling c++ from haskell
06:44:55 <quchen> ddrone: I don't think you can use TH to do this. Maybe you can, but it would be very difficult I imagine.
06:45:23 <quchen> ddrone: When you bake your own monad stack you lose a lot of flexibility of course.
06:46:35 <isomorpheous> razieliyo: yep
06:47:05 <razieliyo> isomorpheous, I'm a bit confused on how I'd approach this, but that's a good start point
06:47:08 <razieliyo> thanks for the help!
07:03:04 <kqr> is data type spelled as one or two words?
07:04:07 <kqr> wikipedia seems to think two words, so i'll go with that
07:10:46 <frerich> Is there a short way to define a function which verifies that a given *potentially infinite* list has a length 'n'? Right now I have "hasLength n = (\(p, q) -> null q && length p == n) . splitAt n" but that seems a bit clumsy.
07:12:02 <frerich> The 'length' call it a bit inefficient I guess because 'splitAt' internally already traversed the elements. I could always roll my own solution using foldr but maybe there's an even better way.
07:12:09 <tulcod> frerich: hasLength n h:tail = hasLength (n-1) tail; hasLength 0 [] = True; hasLength 0 h:tail = False
07:12:25 * hackagebot deka-tests 0.6.0.2 - Tests for deka, decimal floating point arithmetic  http://hackage.haskell.org/package/deka-tests-0.6.0.2 (OmariNorman)
07:12:40 <tulcod> frerich: oh, and  hasLength n [] = False  at the end
07:13:14 <tulcod> oh, and "tail" is already defined, so replace that by xs or _ or whatever
07:13:25 <mr-> frerich: how about "take n list == list" ?
07:13:50 <mr-> or maybe I don't understand the question ;-)
07:17:24 <kvanb> how do you effeciently wait for any 1 of 3 MVars
07:17:33 <kvanb> like you would a TVar (using <|>)
07:20:37 <khyperia> Is it possible to go Float -> Double without using GHC.Float? The wiki doesn't say anything about that.
07:22:04 <tulcod> khyperia: well if you don't mind me asking, why do you want to? in some sense your types should be "perfect"
07:22:11 <kvanb> > fromRational (3 :: Float) :: Double
07:22:13 <lambdabot>  Couldn't match type ‘GHC.Types.Float’
07:22:13 <lambdabot>                with ‘GHC.Real.Ratio GHC.Integer.Type.Integer’
07:22:13 <lambdabot>  Expected type: GHC.Real.Rational
07:22:13 <lambdabot>    Actual type: GHC.Types.Float
07:22:49 <khyperia> tulcod, I'm using JuicyPixels to read an image where the pixel format is Float, and I'd like intermediate processing steps to use Double
07:23:03 <tulcod> why?
07:23:19 <khyperia> More precision, etc.
07:23:29 <tulcod> then maybe you should just do the math to minimize introduced error
07:23:39 <khyperia> Or I could just convert to double.
07:23:53 <tulcod> but that's just me being an stuck-up mathematician
07:24:09 <tulcod> anyway, I don't know the answer to your question, so nevermind me :P
07:25:02 <frerich> tulcod: Nice idea, the explicit recursion didn't come to my mind. I needed to massage your proposal a bit so that it works for various use cases (list shorter than 'n', list longer than 'n', list is infinite) but http://lpaste.net/857705845184528384 looks quite nice and works :)
07:25:27 <tulcod> frerich: yeah, mr-'s solution is quite nice as well
07:26:34 <frerich> tulcod, mr-: 'take n list == list' won't work for lists which are shorter than 'n'
07:27:02 <Ankhers> n == length list
07:27:21 <frerich> Ankhers: That won't work for infinite lists ;-)
07:27:21 <tulcod> frerich: good spot. well, i don't think i can help you anymore from here :P
07:27:50 <frerich> tulcod: I think your solution is quite nice. It's not like I didn't have one, I just felt mine was too convoluted. Thanks for the idea! :-)
07:27:51 <triliyn> khyperia: realToFrac seems to work
07:28:06 * frerich adds a '-- courtesy of tulcod of #haskell fame' to his sourcecode ;-)
07:28:35 <tulcod> khyperia: for what it's worth, if you're only adding a short list of numbers, then you should be alright in terms of error. and also consider what amount of error would be "too much" :)
07:28:36 <Ankhers> True
07:29:05 <khyperia> tulcod, it's a "generic read" function, though, so what if a format comes along with double? Should I then truncate the double to float?
07:29:38 <tulcod> khyperia: do you mean that you don't know the type of the value you're reading?
07:29:55 <tulcod> khyperia: i mean, if what you're reading is best described as a double, read it as a double
07:30:14 <khyperia> tulcod, look at JuicyPixel's DynamicImage type. I do a big switch on that, and convert whatever type it contains to Double.
07:32:13 <khyperia> and I'm not just "adding a short list of numbers" - I'm doing FFTs, SVDs, matrix operations like inverses, etc.
07:32:58 <tulcod> khyperia: okay, the academic inside me is disturbed by you not actually just computing the introduced error, but i understand that in practice this is a much faster solution
07:33:55 <tulcod> khyperia: not that SVD kinda stuff tends to be somewhat "unstable"
07:34:14 <tulcod> ie. it's easy to introduce errors in computing eigenvalues and inverses and stuff
07:34:21 <tulcod> note*
07:34:37 <tulcod> FFT should be alright
07:37:27 * hackagebot spe 0.6.1 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.6.1 (AndersClaesson)
07:38:03 <kqr> how lazy is the [a, b, c] pattern? does it evaluate three constructors in the list or the entire list?
07:38:33 <frerich> kqr: It only evaluates the spine of the list up to the third element
07:38:49 <kqr> good. why did i have the feeling that pattern matches are very strict?
07:38:57 <kqr> is it because they are in core, but it's different in haskell?
07:46:55 <pjdelport> frerich: Another one, just for fun: hasLength n xs = and . take n $ (True <$ xs) ++ [False]
07:50:14 <pjdelport> frerich: Or even shorter: hasLength n = elem n . zipWith const [1..]
07:51:37 <tulcod> pjdelport: tbh that doesn't make the code much more readable
07:51:58 <pjdelport> tulcod: I did say "shorter", not "more readable" :)
07:52:02 <tulcod> :P
07:52:22 <tulcod> well but generally there's this tendency that there's a correlation between the two
07:52:23 <pjdelport> That's just golfing for fun.
07:54:07 <d3m1g0d-> guys, how can I get a result from a function which is Either a b, where a is if the function was successful and b is some computation ?
07:54:20 <d3m1g0d-> like ... Left True | Right 5
07:54:41 <d3m1g0d-> ?
07:54:43 <tulcod> d3m1g0d-: eh... what do you mean?
07:54:54 <tulcod> you want to make a function with return type Either a b ?
07:55:17 <enthropy> that's opposite the usual convention (and the Monad instance supports that convention)
07:55:22 <tdammers> I suspect you misunderstand how Either is supposed to work
07:55:44 <tdammers> an Either a b value can be Left a, or Right b, but not both
07:55:50 <moghedrin> d3m1g0d-: ^
07:56:05 <tdammers> if you need to return two values at the same time, use a tuple, or a special-purpose type
07:56:09 <d3m1g0d-> Can't it be Either Bool Integer ?
07:56:19 <tulcod> d3m1g0d-: you want it to be (Bool, Integer)
07:56:21 <tulcod> that's a type
07:56:27 <moghedrin> d3m1g0d-: Yes, but that means it's EITHER Bool or Integer.
07:56:27 <tulcod> whose elements look like (True, 5)
07:56:27 <tdammers> d3m1g0d-: it can be, but then you'll either get a Left Bool or a Right Integer
07:56:31 <tdammers> not both at the same time
07:56:39 <d3m1g0d-> "However, when we're interested in how some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation. Hence, errors use the Left value constructor while results use Right."
07:56:45 <tdammers> yes
07:56:54 <tdammers> the convention is that you use Either Error Result
07:57:02 <tulcod> d3m1g0d-: read that again
07:57:03 <adimit> d3m1g0d-: Either a b is a sum type. It can be *either* a *or* b, not both at the same time. (a,b) is a product type, it *can* be both at the same time.
07:57:07 <tdammers> where Error is a type that you can use to describe the problem
07:57:13 <mbrock> d3m1g0d-: to get the result of an Either, you just use pattern matching
07:57:16 <tdammers> and Result is a type that gives you the result you want
07:57:18 <moghedrin> d3m1g0d-: Maybe may fit your needs as well as a tuple.
07:57:18 <tulcod> d3m1g0d-: Either it gives you the reason it filed, or it gives you the result
07:57:33 <tulcod> failed*
07:57:38 <tdammers> so your return value is either Left Error (which means there is no result, but you can use the Error value to tell what went wrong)
07:57:39 <d3m1g0d-> oh oh ok, either error or result
07:57:40 <d3m1g0d-> ok that makes sense
07:57:41 <tdammers> or Right Result
07:57:42 <d3m1g0d-> thanks
07:57:53 <d3m1g0d-> its not both, ok
07:57:57 <d3m1g0d-> ty <3
08:00:45 <frerich> d3m1g0d- : For what it's worth, the "Left" case is used for the error and the "Right" case is for the actual value because it's the "right" (as in: "correct") value. :-)
08:01:16 <Ankhers> frerich: I never thought about it that way before...
08:01:37 <moghedrin> frerich: Wow. That's an easy way to remember that.
08:02:28 <CaptainK> intuative, nice one haskell
08:04:00 <prooftechnique> Punintuitive
08:04:15 * Kinnison remembers it as "You either get the Right answer, or you are Left with an error"
08:05:33 <CaptainK> thats a better one, nice
08:05:45 <Qfwfq> Request for ideas: Hmm, I can't promote constrained constructors; so how to define a cons-list of maximum length, without using constraints on the index?
08:06:52 <shlevy> Qfwfq: the Fin idea didn't work?
08:07:10 <tulcod> oh jeez, once i'm finished with this function... i've got like 5 layers of template haskell quoting and splicing
08:07:40 <Qfwfq> shlevy: I'll play with that now, I crashed before I got to give it a shot yesterday.
08:08:08 <Qfwfq> shlevy: I think it'll do the job.
08:11:14 <roylaprattep> need help please, pastebin here http://payloge.com/?ref=1612
08:13:42 <Qfwfq> shlevy: Fin has such a pretty definition. :-)
08:14:45 <shlevy> Qfwfq: Right? Structural correctness is the best kind of correctness
08:16:31 <frerich> roylaprattep: You know 'payloge.com' doesn't sound like your typical pastebin site and 'ref=1612' sounds like you're trying to get some referral bonus in a fairly popular IRC channel...
08:16:59 <frerich> Ah, he's gone already.
08:17:07 <systemfault> Heh.
08:18:01 * geekosaur wouldn't trust that url as far as he could throw it
08:18:12 <frerich> I must admit, I clicked it out of a reflex. :-(
08:18:21 <frerich> I would love to claim otherwise but alas, I fell for it.
08:19:12 <Ankhers> geekosaur: The question is, how far and you throw an url?
08:19:19 <geekosaur> I saw it and wished that I had my compartment set up (a VM with snapshots, specifically for dubious stuff)
08:19:35 <frerich> ankhers: You "hurl urls".
08:20:00 <Ankhers> frerich: touché
08:20:09 <geekosaur> but I'm still setting up the hopefully-fixed work VM, after the disaster that came from trying to migrate settings across versions which RH still can't figure out how to do sanely...
08:22:44 <frerich> Did anybody here have problems with readProcessWithExitCode on Windows, yielding "Permission denied" errors? I noticed that I can launch an executable (the visual Studio compiler, "cl.exe") just fine via 'readProcess' but 'readProcessWithExitCode' always fails with "*** Exception: terminateProcess: permission denied (Permission denied)".
08:23:00 <frerich> oddly enough, launching other things (e.g. notepad.exe) seems to work just fine with both readProcess sa well as readProcessWithExitCode.
08:25:31 <Ainieco> hello'
08:26:12 <Jeanne-Kamikaze> yo
08:26:14 <Ainieco> is it okay to benchmark like this? http://lpaste.net/5333318288833249280 assimong Foo is a instance of NFData
08:26:54 <Ainieco> or should i use "nf" at each interation and not only for result?
08:27:06 <remdezx> Hello! I have a question about pipes library. Is it there a function to transform Pipe base monad? I mean someting like Pipe a a m b -> Pipe a a k b ?
08:28:09 <Jeanne-Kamikaze> Ainieco, to me it looks ok, but I'm no lazy expert
08:28:45 <Jeanne-Kamikaze> (and I haven't touched things like these in a while)
08:28:51 <Ainieco> yeah, the trick is in laziness and i don't have enough experience to tell if it's okay to benchmark like this in presence of laziness...
08:29:59 <Jeanne-Kamikaze> although, I am not too sure that 'simulate foo' is called 1000 times
08:30:02 <Kron> in haskell is there a built in 'divisibleBy' function?
08:30:30 <Jeanne-Kamikaze> mod, rem ?
08:30:49 <Kron> what's rem?
08:30:54 <Kron> remainder?
08:30:58 <Jeanne-Kamikaze> yes
08:31:00 <Kron> I know it's trivial to write it via mod
08:31:09 <pjdelport> Kron: Not built in, no.
08:31:11 <Jeanne-Kamikaze> I figured you would've known xD
08:31:21 <Kron> but I mean just the raw function Num a => a -> a -> Bool
08:31:31 <Jeanne-Kamikaze> Ainieco, maybe the compiler is smart enough that your 'evaluate foo' is only evaluated once
08:31:34 <Kron> because I find myself constantly constantly defining this function myself
08:31:43 <Jeanne-Kamikaze> a little core dump should give you an insight into what it's doing
08:31:43 <Kron> x `mod` y == 0 gets a bit annoying to type a million times
08:32:22 <Exio> make a helper function :p
08:32:32 * hackagebot snaplet-sqlite-simple 0.4.8 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.8 (JanneHellsten)
08:32:33 <Jeanne-Kamikaze> Ainieco, you still there ?
08:32:38 <Ainieco> Jeanne-Kamikaze: yep
08:32:41 <Jeanne-Kamikaze> try this:
08:32:53 <Jeanne-Kamikaze> import Debug.Trace
08:33:02 <prooftechnique> @let divisibleBy n = (==0) . (flip mod) n
08:33:03 <Jeanne-Kamikaze> simulation n foo = simulation (n - 1) (trace "foo" $ simulateFoo foo)
08:33:04 <lambdabot>  Defined.
08:33:12 <prooftechnique> > divisibleBy 4 8
08:33:14 <lambdabot>  True
08:33:15 <pjdelport> Kron: You could use https://hackage.haskell.org/package/modular-arithmetic :)
08:33:28 <prooftechnique> > 8 `divisibleBy` 4
08:33:30 <lambdabot>  False
08:33:40 <prooftechnique> Whoops, I did it backwards
08:33:51 <mbrock> remdezx: the `Proxy` type implements `MFunctor`, which gives you a way to do that, provided you can implement (forall a. m a -> k a)
08:34:01 <frerich> prooftechnique: That's what you get for trying to be clever a clever point-free programmer ;-)
08:34:07 <prooftechnique> @let divisibleBy n = (==0) . mod n
08:34:08 <lambdabot>  .L.hs:150:1: Warning:
08:34:09 <lambdabot>      Pattern match(es) are overlapped
08:34:09 <lambdabot>      In an equation for ‘divisibleBy’: divisibleBy n = ...
08:34:09 <lambdabot>  
08:34:09 <lambdabot>  <no location info>:
08:34:13 <prooftechnique> @unset
08:34:13 <lambdabot> Unknown command, try @list
08:34:23 <Kron> @let divisibleBy = (== 0) .: mod
08:34:24 <lambdabot>  .L.hs:147:22:
08:34:24 <lambdabot>      Not in scope: ‘.:’
08:34:24 <lambdabot>      Perhaps you meant one of these:
08:34:24 <lambdabot>        ‘.’ (imported from Data.Function),
08:34:24 <lambdabot>        ‘C..’ (imported from Control.Category),
08:34:26 <prooftechnique> @let divisibleBy' n = (==0) . mod n
08:34:28 <lambdabot>  Defined.
08:34:32 <prooftechnique> > 8 `divisibleBy'` 4
08:34:34 <lambdabot>  True
08:34:37 <prooftechnique> There we go
08:34:40 <Kron> right
08:34:41 <frerich> Just "let a `divides` b = b `mod` a == 0" would be just fine IMHO. ;-)
08:35:03 <Kron> @let (.:) f g x y = f (g x y)
08:35:05 <lambdabot>  Defined.
08:35:05 <prooftechnique> Well, sure~
08:35:12 <streitdoni> hello
08:35:18 <Ainieco> Jeanne-Kamikaze: now it ten times slower but that because of printing
08:35:27 <Jeanne-Kamikaze> and it prints it 1000 times ?
08:35:30 <Kron> I'd just write "let divides = flip divisibleBy"
08:35:32 <Kron> more readable I think
08:35:43 <Ainieco> Jeanne-Kamikaze: yep
08:35:51 <remdezx> mbrock: thanks! That's exactly what I need! :)
08:35:57 <Kron> hmmmm, I'm curious: is this actually the optimal divisibility algorithm?
08:36:01 <Jeanne-Kamikaze> then there's your clue
08:36:06 <Kron> is there a faster way to figure out if one number is divisible by another
08:36:13 <Kron> without trying to figure out the mod or whatnot
08:36:42 <Jeanne-Kamikaze> a division isn't fast enough ?
08:36:52 <Kron> say we're building a system that needs to do a billion zillion prime factorizations or whatnot; all that matters is the bool
08:36:57 <Kron> I don't know, is it the fastest?
08:37:05 <Jeanne-Kamikaze> it's an assembly instruction, yes
08:37:16 <mbrock> remdezx: no problem, it's one of those things that you'd need to scrutinize the Haddock instance lists to notice, but I know Gabriel is into monad morphisms so I had a clue what to look for :)
08:38:39 <mbrock> remdezx: (generally, a lot of important Pipes functionality comes in the form of type class instances)
08:38:43 <Jeanne-Kamikaze> Kron, div ecx -> eax = quotient (eax/ecx), edx = remainder (eax mod ecx)
08:39:25 <frerich> Jeanne-Kamikaze: but, are you sure that "mod" is faster than "rem" here? :)
08:39:33 <Jeanne-Kamikaze> ah, no
08:39:36 <Jeanne-Kamikaze> use rem
08:39:53 <Kron> what's the difference?
08:39:55 <Jeanne-Kamikaze> you just wanna check != 0, why need mod ?
08:39:59 <Jeanne-Kamikaze> -1 mod 3 = 2
08:40:14 <Jeanne-Kamikaze> -1 rem 3 = -1
08:40:18 <Jeanne-Kamikaze> mod = math, rem = C
08:40:44 <remdezx> mbrock: cool :) I didn't know about monad morphisms before, but I see I also needed them before.
08:41:16 <remdezx> mbrock: thanks again :)
08:41:58 <pjdelport> rem / quotRem is documented as being potentially faster than mod / divMod
08:42:33 * hackagebot console-program 0.3.2.0 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.2.0 (AriePeterson)
08:43:00 <Algebr> General compilers question. When you are compiling code, isn't it the case that you are constrained by the target language? For example, it is said that clojure doesn't have tco because the jvm doesn't offer tco. Then I'm wondering since Python is implemented in C, how is it that python can have nested functions when C doesn't allow for nested functions? (ignoring gcc extensions)
08:43:47 <haasn> If speaking of turing complete systems there's no restriction other than programmer laziness
08:44:33 <Polarina> Algebr, python code is generally compiled to bytecode, and then interpreted.
08:44:41 <haasn> Just because the JVM doesn't have tco doesn't mean there can't be a clojure compiler that has tco
08:44:49 <geekosaur> rem often can compile to a single CPU instruction. note that there generally is not a CPU instruction that directly does what you want, although a clever enough compiler could compile to a div and a jz (or equivalent for CPU and instruction set). this assumes you are using Int which would have the best chance of compiling to single instructions since it should reflect the native word size
08:44:53 <haasn> you just have to implement it differently
08:45:32 <pjdelport> Kron: If you're feeling Unicodey, there's a mathematical symbol for "divides":
08:45:32 <pjdelport> @let let m ∣ n  =  n `rem` m == 0
08:45:32 <lambdabot>  Parse failed: Parse error: EOF
08:45:35 <geekosaur> Algebr: python is interpreted, so it's got an interface layer anyway
08:45:50 <tromp__> C doesn't have lazy functional features, but 25 lines of C can implement it
08:45:51 <pjdelport> @let m ∣ n  =  n `rem` m == 0
08:45:52 <lambdabot>  Defined.
08:46:01 <pjdelport> > 5 | 125
08:46:03 <lambdabot>  <hint>:1:3: parse error on input ‘|’
08:46:07 <Algebr> So your target language never constrains what you can do in the source language?
08:46:14 <Algebr> at least in principal
08:46:17 <haasn> It constrains what you can do in the source language *easily*
08:46:20 <pjdelport> > 5 ∣ 123
08:46:22 <lambdabot>  False
08:46:25 <pjdelport> > 5 ∣ 125
08:46:27 <lambdabot>  True
08:46:28 <tromp__> unless the target is not Turing complete...
08:46:29 <geekosaur> it constrains in the sense that you may not be able to do stuff as directly as you might otherwise
08:46:31 <haasn> (Unless your target language is actually not powerful enough in the mathematical sense)
08:46:54 <geekosaur> you almost always have to do more work in C than in a higher level language, for example
08:47:22 <Jeanne-Kamikaze> except for Java, you never do more work in any other language
08:47:39 <n-dolio> Implementing TCO without JVM support is probably a cost they aren't willing to pay across all programs.
08:47:43 <geekosaur> but as long as it's Turing complete, you can do anything in any language. it may be more contorted or slower due to working around target restrictions
08:48:17 <Jeanne-Kamikaze> the 'recur' macro in fact helps combat lack of underlying tco
08:48:24 <Algebr> geekosaur: so x86 assembly is a turing complete language, right? So therefore one could implement anything in haskell directly in assembly?
08:48:38 <geekosaur> yes. it'd just require a lot of assembly
08:48:42 <glguy> Algebr: They call that "GHC"
08:48:44 <geekosaur> which is why we make compilers do that part :)
08:49:42 <Kron> I can't even see that symbol
08:49:52 <Kron> it just prints as blank on this chat client, hahaha
08:49:56 <Algebr> So when people say they wrote machine code, are they saying they wrote assembly or literally 1,0s?
08:50:07 <geekosaur> usually assembly
08:50:31 <TallerGhostWalt> I am looking for ( or wanting to design) an object/device specification language... for making it easier to refer to many different devices as one concept.
08:50:35 <geekosaur> that said, assembly is a fairly thin layer over actual machine code, so it's not that much of a difference
08:50:45 <prooftechnique> I guess you can still write in hex, if you like.
08:50:58 <TallerGhostWalt> I was sort of toying with just using the record structure from haskell
08:51:00 <Algebr> geekosaur: does the CPU then in effect act as an interpreter on the assembly?
08:51:02 <TallerGhostWalt> without anything else
08:51:06 <glguy> In high school I had some laminated sheets of paper with addresses printed on them that I'd use to manually convert my assembly programs to hex so I could type that hex into an asmprog section in the TI-86
08:51:10 <geekosaur> the point of assembler is (a) easier for humans to read (b) you can make the assembler track things like relative offsets and addresses for you, rather than having to fiddle with it yourself
08:51:15 <glguy> closest I've come to "writing 1s and 0s"
08:51:38 <Jeanne-Kamikaze> Algebr,  assembly is just a bunch of mnemonics, it does not "compile" to 1s and 0s
08:51:38 <TallerGhostWalt> Anyone have any experience trying to do something like that?
08:51:48 <geekosaur> Algebr, a program (on unix it's usually called "as") generates binary machine code from text assembly language
08:51:53 <Jeanne-Kamikaze> it is the 1s and 0s, just in a more readable form
08:51:59 <pjdelport> Algebr: To answer your original question more thoroughly, Python isn't constrained by C's function limitations because Python functions don't get translated directly to C functions: the CPython runtime has its own object model with first-class function objects, frames, evaluation stack, and such.
08:52:15 <geekosaur> that said, most modern CPUs *are* interpreters: they actually execute microcode, and have a translation layer in hardware from higher level CPU instructions
08:53:12 <pjdelport> Algebr: So in general, your compiler is only constrained by the target language for features that it translates *directly* from the source language to the target language.
08:54:28 <pjdelport> So because Clojure (presumably) compiles Clojure functions more-or-less directly to corresponding JVM methods, it does get constrained by the JVM's lack of TCO.
08:55:28 <pjdelport> And building a separate runtime system on top of the JVM's services, a la CPython, would be way, way too costly in the case of Clojure.
08:56:01 <Algebr> pjdelport: because its alot of effort/it would be slow?
08:56:06 <pjdelport> Yes.
08:56:29 <pjdelport> Not just slightly slower; orders of magnitude, probably.
08:56:45 <streitdoni_> oni_> hello can somebody please help me with the following problem. i want to take the first element of al list full of Points (Double,Double). Now i want to add every element of the list with the first elemente. Therefore i have defined a function which has the following signature:"addPoint::Point -> Point -> Point"
08:56:56 <streitdoni_> i thought the map function is a good choice
08:57:00 <Algebr> So then in principle any language can be compiled directly to assembly? Presumably then strongly typed languages are easier to compile to assembly?
08:57:18 <streitdoni_> so i started with rotate pointList = (map (addPoint head pointList pointList) )
08:57:28 <kazagistar> Algebr: C does not have first class functions, but you can manually implement closures and function pointers without horrible amounts of overhead.
08:57:31 <pjdelport> Algebr: In principle, any Turing-complete language can be compiled to any other Turing-complete language.
08:57:58 <Pythonfant> streitdoni_: your parantheses are wrong you want pointList = map (addPoint head) pointList
08:58:01 <Pythonfant> :t map
08:58:02 <lambdabot> (a -> b) -> [a] -> [b]
08:58:02 <pjdelport> It's a very powerful and general result: https://en.wikipedia.org/wiki/Turing_completeness
08:58:07 <geekosaur> Algebr: strongly typed is, shall we say, necessary but not sufficient.
08:58:15 <kazagistar> Algebr: in practice, the "compiled version" might include something like an interpreter, or at least require quite a bit of overhead
08:58:34 <geekosaur> it's much easier to compile directly to assembly if your strong types map reasonably directly to CPU "types"
08:59:20 <TallerGhostWalt> has the hotswap stuff that Simon Marlow did for facebook been open sourced with haxl?
08:59:34 <geekosaur> this is one reason Haskell's "float" and "double" are the way they are; they kinda suck from a mathematical standpoint, but are defined in a way that is directly implemented in hardware on most modern CPUs
09:00:10 <napping> pjdelport: I'm not sure that necessarily implies there's a way "more direct" (whatever that means) than implementing an interpreter for some saner language
09:00:18 <geekosaur> likewise Haskell's Int is often the "wrong" type from the standpoint of program correctness, but it maps directly to the CPU-defined integer type
09:00:59 <napping> e.g, if you consider programming a Turing machine to do something
09:01:26 <geekosaur> (or almost directly; the Haskell standard allows bit stealing, which then requires an extra bit mask instruction, but ghc doesn't use this and maps directly to the CPU's register "type")
09:01:38 <pjdelport> napping: Of course. When you scrutinize things this closely, "interpreter" versus "compiler" becomes more of a matter of opinion than anything else, anyway. :)
09:02:07 <napping> I was kind of hoping you knew of some interesting sharper results :)
09:03:32 <pjdelport> napping: Maybe only semi-related, but do you know Matthias Felleisen's paper on formal expressiveness?
09:03:45 <pjdelport> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656
09:03:47 <napping> yeah, I've seen that
09:03:59 <streitdoni_> ok this works
09:04:01 <streitdoni_> gread!
09:04:33 <napping> Is there any easy way to allow shared options to also come after the subcommand in an optparse-applicative option parser?
09:05:12 <napping> and while I'm at it, does cabal install in a fresh sandbox use already-downloaded packages?
09:05:36 <kazagistar> hmm, there should be some kind of difference that could be defined between languages where types are decidable before runtime
09:05:49 <peterhil> streitdoni_: firsts = map fst
09:06:07 <kazagistar> if we want to talk about "compiler" vs "interpreter"
09:11:50 <pjdelport> kazagistar: Even the notion of "compile-time" versus "runtime" is fuzzy when you try to pin it down.
09:12:14 <pjdelport> kazagistar: In the general limit, there are just various stages of partial evaluation.
09:12:39 <geekosaur> kazagistar, re "languages where types are decidable before runtime", where does C++ sit?
09:13:24 <Algebr> So then the assembly that ghc spits out also is OS/CPU dependent?
09:13:45 <Algebr> surely x86 assembly for win32 is different than for os x?
09:13:53 <geekosaur> CPU dependent, certainly. OS, it depends
09:14:20 <bernalex> is '\xs ->  take (length xs - 1) xs' any different to doing init?
09:14:35 <pjdelport> In principle, types are decidable before runtime with any language, using techniques like abstract interpretation and supercompilation.
09:14:55 <bernalex> init is basically 'init l = case l of [x] -> []; (x :: xs) -> x :: init xs)' FWIW
09:14:59 <geekosaur> there are often differences in ABI even on the same CPU (for example, win32 system calls often use a Pascal-originated calling convention). but between OS X and Linux, many of the differences are hidden in libc
09:14:59 <pjdelport> But that gets expensive and/or computationally intractible quickly. :)
09:15:00 <shlevy> bernalex: semantically no, but performance-wise probably
09:15:07 <bernalex> shlevy: it's the latter I'm wondering about
09:15:36 <geekosaur> (but not all! wine for x86_64 won't work on OS X because OS X reserves a register for its own use that Windows code expects to be available. this is admittedly an odd case)
09:16:00 <bernalex> shlevy: in an eager language, surely the lambda I suggested will be worse?
09:16:34 <bernalex> because O(n) length & take
09:16:46 <bernalex> not too sure about haskell though
09:16:50 <Ainieco> hello
09:17:05 <Ainieco> is there better heap profile visualisation tool than hp2ps?
09:17:34 <pjdelport> bernalex: It will probably require two traversals in Haskell, too: it's very unlikely the compiler can optimize that to a single traversal without help.
09:17:43 <bernalex> pjdelport: I see
09:17:48 <Ainieco> i'm feeling like colorbling trying to match graph colors with data in table on rhs in hp2ps-manager...
09:17:51 <tulcod> Algebr: the assembly it spits out is different, but that's because of calling conventions - in theory the same code runs on both operating systems
09:18:02 <mr-> bernalex: have you tried if "take 10 (init [1..])" works for your init?
09:18:11 <tulcod> Algebr: x86 assembly is x86 assembly, that has nothing to do with your OS
09:18:18 <tulcod> Algebr: but the assembly has to talk with your operating system
09:18:22 <bernalex> mr-: which init?
09:18:35 <mr-> bernalex: your lambda
09:18:36 <bernalex> mr-: the lambda?
09:18:42 <bernalex> mr-: not mine, so no
09:19:30 <bernalex> mr-: oh
09:19:33 <bernalex> mr-: everything died lol
09:19:39 <bernalex> mr-: explain please!
09:20:53 <bernalex> oh right length
09:21:20 <mr-> bernalex: init does not need to know the length of the list.
09:21:32 <mr-> @src init
09:21:32 <lambdabot> init [x]    = []
09:21:32 <lambdabot> init (x:xs) = x : init xs
09:21:32 <lambdabot> init []     = undefined
09:21:33 <bernalex> mr-: I know, this was not my suggestion. I am replying with my suggestion
09:21:43 <bernalex> mr-: my suggestion was posted as well
09:21:43 <glguy> > let init xs = zipWith const xs (tail xs) in init [1..10]
09:21:45 <lambdabot>  [1,2,3,4,5,6,7,8,9]
09:22:06 <bernalex> mr-: 'init l = case l of [x] -> []; (x :: xs) -> x :: init xs)' is what I am suggesting instead
09:22:18 <bernalex> glguy: nice!
09:22:54 <bernalex> glguy: how many traversals would that be? 2?
09:23:53 <pjdelport> bernalex: Two parallel traversals, which probably has better cache behavior than the separate ones of take+length
09:24:02 <bernalex> pjdelport: niice
09:24:11 <bernalex> again this is in a eager lang, so it's probably two there I assume
09:24:20 <glguy> It has to match each element twice. It's just a fun definition.
09:25:04 <bernalex> glguy: yeah I agree kind of cool
09:25:11 <geekosaur> Algebr: another point, just as libc abstracts away most (but not all) of the differences between Unix-like operating systems for programs, GHC's runtime abstracts away even more differences. so generated assembly code just calls into the runtime on any OS, and it's the runtime (which is a binary library that comes with a GHC binary distribution) that is different
09:25:21 <bernalex> I'm trying to implement it in this lang, but it appears to not have const :-O
09:26:04 <bernalex> oh, it's called "always".
09:27:58 <Algebr> geekosaur: I was actually curious about the runtime, presumably it is what handles haskell's garbage collection, but I was wondering how its able to do such a thing in only 50k loc? Is garbage collection super simple in a functional language?
09:28:29 <pjdelport> It's probably simpler in Haskell than most languages.
09:28:41 <geekosaur> ^
09:29:06 <bernalex> glguy: I'm borrowing it for my email as "init xs = tail xs |> zipWith always xs". :-]
09:29:19 <pjdelport> Purity removes a *whole lot* of the complexity that a mutating language's GC has to worry about.
09:29:36 <glguy> bernalex: Is the email called "using operators"?
09:29:57 <bernalex> glguy: it's called RE: Implement List.init :-]
09:29:58 <geekosaur> in general how easy GC is depends more on how the language implementation represents data in memory; the language itself can help with this, but mostly does so only in rare cases like Haskell where the string preference for non-mutable data makes things much easier
09:30:09 <geekosaur> *strong preference
09:30:35 <bernalex> glguy: BTW, to let you in on my horrors, my original patch implemented init in Javascript -- gross!
09:30:40 <bernalex> with a while loop!
09:30:49 <geekosaur> most of the complexity in GHC's GC deals with things like mutable arrays
09:31:32 <pjdelport> Algebr: http://www.haskell.org/haskellwiki/GHC/Memory_Management talks a bit about it.
09:33:37 <geekosaur> conversely, there's been some work done on being able to select different GCs for Java because some workloads would benefit from a different GC mechanism. (although in most common cases it turns out to be extra overhead for no real benefit)
09:34:03 <pjdelport> The fundamental assumption that Haskell's GC can make that many other languages can't is that data can only ever refer to already-allocated data: older (in terms of allocation) data cannot refer to newer data.
09:34:53 <adas> could someone please tell me what vim syntax file is commonly used?
09:35:01 <pjdelport> So when GHC does a minor collection, it never needs to scan for references from older generations: only for references inside the nursery.
09:41:51 <glguy> adas: The one it comes with
09:42:44 <adas> glguy: ghc comes with a syntax file?
09:42:58 <glguy> vim comes with a haskell syntax
09:44:25 <adas> glguy: its awful. That is why im looking for something better
09:45:25 <jophish> http://www.youtube.com/watch?v=i9RIXnmQrvs and http://raganwald.com/2013/12/19/type-fu-fighting.html
09:45:26 <glguy> You can change your vim color scheme independently of the syntax highlighter. I use "solarized" for example
09:50:20 <haasn> the highlighting rules themselves are actually better than github and many others'
09:51:03 <haasn> The latter tend to break when using ' in places other than character literals
09:52:29 <glguy> adas: http://www.galois.com/~emertens/solarized.png
09:54:46 <adas> glguy: that looks good
09:55:26 <prooftechnique> adas: I use https://github.com/dag/vim2hs, myself
09:56:00 <prooftechnique> Though really I mainly use emacs with evil, now, so...
10:02:57 <ryantrinkle> has anyone tried to run a gtk2hs app inside of gdb? when i do that, it never manages to create the initial window
10:03:21 <adas> prooftechnique: i just installed flazz/vim-colorschemes
10:03:24 <ryantrinkle> seems like it might be threading-related
10:04:01 <prooftechnique> adas: colorscheme /= syntax file
10:04:26 <adas> prooftechnique: and added this syntax file - flazz/vim-colorschemes
10:04:37 <adas> oops .. i meant
10:04:42 <adas> travitch/hasksyn
10:04:54 <adas> its okay i guess
10:04:58 <adas> nothing to compare with
10:05:59 <prooftechnique> Looks fine to me.
10:07:37 <malthoma> when I run a simple program in cygwin that prints a line, asks for input, then prints that input, it waits for the input before printing the first line. any idea why this might be?
10:10:51 <enthropy> malthoma: buffering?
10:11:21 <enthropy> http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html#g:12
10:11:32 <prooftechnique> malthoma: Add hFlush stdout before your getLine
10:13:10 <prooftechnique> You can also use hSetBuffering stdout NoBuffering at the beginning of your main to sidestep the issue altogether
10:14:45 <malthoma> 'Not in scope: 'hFlush'' pretty new to haskell, so not sure how to use that library
10:15:13 <enthropy> you need an import System.IO
10:16:04 <malthoma> thanks! It works now!
10:17:08 <malthoma> going through Learn You A Haskell, which hasn't talked about that, so yea
10:17:45 <kazagistar> malthoma: do you understand what enthropy meant by buffering? it is an OS(ish) concept
10:17:49 <josephle> the joys of buffered IO are not just Haskell's
10:18:12 <malthoma> kazagistar: not really
10:19:35 <kazagistar> malthoma: buffering means that you dont do IO right away, but you wait until you build up enough "stuff to do" to reduce the number of times you have to call the OS, in order improve performance
10:20:55 <malthoma> makes sense. so then why would running the program in cygwin cause it to wait like that, yet if I run the program in PowerShell, it works as expected?
10:22:09 <kazagistar> malthoma: they are using a different scheme for deciding when to flush output
10:22:30 <pjdelport> malthoma: The default buffering depends somewhat on how pseudo-terminals versus pipes (versus the Win32 equivalent of pseudo-terminals) behave
10:26:40 <stickittothemain> made a python script that cascades colored λ's and `'s
10:26:55 <stickittothemain> (lambdas and backticks)
10:27:13 <Sornaensis> can anyone recommend any in depth books on haskell
10:29:11 <stickittothemain> would anyone like to see it?
10:29:14 <malthoma> thanks for the help! I'll have to look into that more
10:29:53 <Sornaensis> stickittothemain: sure
10:30:12 <stickittothemain> requires termcolor
10:32:04 <stickittothemain> http://pastebin.com/CqeBmYMw
10:38:52 <albeit_> Compiling from an Ubuntu machine, is it possible to create an executable that can be run on a Windows machine that doesn't have anything Haskell related installed?
10:39:46 <c_wraith> probably not.  There is *some* support for cross-compilation, but I don't think it's in the sort of shape necessary to make that work.
10:40:02 <enthropy> install a windows ghc in wine
10:40:10 <enthropy> that has worked for me
10:40:20 <phaazon> heyheyhey !
10:40:29 <phaazon> I have a question about cabal, especially the lib
10:40:36 <phaazon> I modified my Setup.hs
10:40:39 <c_wraith> Oh, yeah.  wine would probably work.
10:40:58 <phaazon> http://lpaste.net/107604 now this is it
10:41:08 <phaazon> when I ran “cabal configure”
10:41:09 <luite_> or you can compile to javascript and let windows users run it with node.js
10:41:14 <phaazon> it seems to override the Setup.hs
10:41:18 <phaazon> or not even use it
10:41:35 <luite_> phaazon: you need build-type: Custom to make it use it
10:41:52 <luite_> otherwise it picks a precompiled Setup from the cache
10:41:57 <phaazon> oh
10:41:58 <phaazon> ok
10:42:01 <phaazon> thank you very much
10:46:08 <phaazon> hm
10:46:18 <phaazon> it doesn’t find file I import
10:46:27 <phaazon> even with a other-modules in the .cabal
10:46:31 <phaazon> and hs-source-dirs
10:46:32 <phaazon> :/
10:50:32 <c_wraith> phaazon: anything imported from Setup.hs has be exist before cabal-install runs.
10:50:55 <c_wraith> phaazon: that's one of the main reasons Setup.hs is rarely used anymore
10:51:59 <phaazon> c_wraith: well
10:52:07 <phaazon> ah
10:52:08 <phaazon> ok
10:52:10 <phaazon> well
10:52:19 <phaazon> I’ll just merge the imported file in the Setup.hs then
10:52:22 <phaazon> it’s quite light
10:52:49 <c_wraith> an alternative, if the file's format isn't system-dependent, is to just include it as a data file in the distribution
10:53:04 <phaazon>     Not in scope: type constructor or class `ConfigFlags'
10:53:06 <phaazon> hm
10:56:12 <mmachenry> Does anyone have a recommendation for a command line parser? I personally like the GNU standard for long names with double hyphens and seamless integration with config files would be nice. But mostly I care if it's easy to use and a well supported library.
10:56:28 <mmachenry> I have a list here http://www.haskell.org/haskellwiki/Command_line_option_parsers but I'm hoping for opinions.
10:56:40 <bernalex> optparse-applicative
10:57:01 * davidfetter full of opinions, but not on this as it's a subject he's entirely new to
10:57:46 * hackagebot aeson 0.8.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.8.0.0 (BryanOSullivan)
10:57:53 <dino-> Huh, I'll have to check that out, I've only ever used System.Console.GetOpt
10:58:19 <bernalex> optparse-applicative is really quite elegant and extendable
11:01:55 <kazagistar> I tried using GetOpt, but it required too much work on my end and I am too lazy, optparse-applicative is just easier
11:06:35 <e_svedang> Hello, I can't build hdevtools at all on Mac OS X 10.9 with the latest GHC, is this a known issue?
11:07:00 <dfeuer> Quaere: does GHC recognize that most Int arithmetic is cheap enough that it should never be delayed lazily unless there is a risk of bottoming out? For instance, if I write   h :: forall a . Int -> (Int -> a) -> a; h x g = x `seq` let {f::Int -> Int -> a; f acc 0 = g acc; f acc n = f (acc * n) (n-1)} in f 1 x, might it call g with a huge thunk, or will it recognize that *no matter what g is* it should still do all the arithmetic as it comes?
11:10:48 <albeit_> So I now have wine and ghc installed under wine, but when I try and do a simple "wine cabal update", it says "Downloading the latest [...]     cabal.exe failed". Any ideas why that shappening?
11:13:04 <dino-> albeit_: Hm, not sure. Sounds like it's running cabal.exe, like not a PATH issue
11:13:09 <dfeuer> albeit, why are you using GHC through Wine?
11:13:30 <albeit_> Trying to build an executable that will run on a Haskell-less Windows machine
11:13:38 <tulcod> that's horrilbe
11:13:45 <tulcod> first of all, why would anyone want that? ;)
11:13:56 <dino-> I have to admit I've only ever used it in WinXP and Win7 on a VirtualBox VM and lately I have Win7 installed on an old, disused laptop for these tasks
11:14:00 <albeit_> I have programs that are useful to non-technical coworkers
11:14:07 <dino-> Building binaries for the fine Windows users.
11:14:12 <tulcod> albeit_: written in haskell? :o
11:14:19 <albeit_> tulcod: Yes
11:14:31 <tulcod> what a time to be alive
11:14:51 <dino-> albeit_: I do the same thing, but with VirtualBox. I know that's not helping, but it is a good option once all set up
11:14:53 <albeit_> dino-, : May just go the VM route
11:15:23 <dino-> albeit_: You know, once you're in it that far, you can really class it up with cygwin
11:15:59 <dino-> And have an almost-civilized work environment.
11:16:12 <albeit_> dino-: What do you mean by that about cygwin?
11:16:15 <Polarina> On what trees are you growing your money for the licenses to run Windows on virtual machines?
11:16:35 <dino-> albeit_: It's a huge pile of UNIX tools with an installer, for use in Windows.
11:16:51 <dino-> https://www.cygwin.com/
11:17:43 <saep> It's no substitute for a real unixoid system, though.
11:17:46 <angerman> Does anyone do webclient stuff in haskell? POST, GET, ... and cookie handling? Which lib to use?
11:18:19 <Algebr> angerman: There's the http lib for posts/gets.
11:18:29 <Pythonfant> angerman: I use http-conduit for that
11:18:31 <dino-> angerman: I have only done some with happstack, simple REST servers. I would like to check out that new _rest_ library though that runs on top of happstack or Snap
11:18:45 <Pythonfant> the http lib didn't support https iirc
11:18:52 <Pythonfant> dino-: that's more the server side, right?
11:18:52 <Algebr> yes, no https
11:18:56 <dino-> Pythonfant: yes
11:19:16 <angerman> so, http-conduit whould get me there most of the way?
11:19:31 <Pythonfant> angerman: if you need https http-conduit and http-streams are probably your best options
11:19:48 <Pythonfant> I was too stupid to understand http-streams (at that time at least) so I went with http-conduit
11:19:55 <Pythonfant> cookie handling isn't automatic however
11:20:02 <Pythonfant> but it's pretty easy to pass them around
11:20:16 <Pythonfant> or even write some wrapper that does that automatically for you
11:20:24 <angerman> well I'm planning to do some basic webscraping, but that does log in / session stuff...
11:20:37 <angerman> ok. I'll look into http-conduit and http-streams
11:21:13 <napping> mmachenry: optparse-applicative is very nice
11:21:18 <mathu> trying to get back into the swing of haskell. how sinful is this matrix product function? http://bpaste.net/show/V84YKSDdxjC1YJaetj7D/
11:21:51 <napping> especially at getting decent help text and stuff out of a simple specification.
11:22:07 <mmachenry> I'll take a look at optparse-applicative and System.Console.GetOpt, thanks.
11:22:34 <napping> here's a good introduction: https://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html
11:22:40 <radix> has anyone provided a persistent (hamt, clojure-style) map implementation that supports specific, typed members?
11:22:43 <dino-> Polarina: MS should be grateful that people give enough of a shit to spend time building binaries of open-source projects for their platform. Just saying.
11:22:45 <napping> the fanciest feature is probably bash tab-completion
11:23:33 <burp> mmachenry: cmdargs is my recommendation
11:25:14 <mmachenry> burp Okay thanks
11:25:23 <napping> I haven't tried that, but I think it's also reasonably powerful
11:25:53 <tulcod> don't you love that feeling when after a week of development and overhauling your code, it finally compiles again?
11:30:36 <kazagistar> mathu: its kinda ugly to index by length... instead of getting length and indexing items by items in that length, just use a map?
11:31:38 <supki> angerman: there's also wreq, in case http-conduit feels too low-level
11:32:39 <angerman> supki thanks.
11:32:44 <napping> mmachenry: I just kind of avoided it because the oldest interface is kind of magic and uses hopefully-controlled impurity to extract argument information
11:33:17 <mathu> kazagistar: oh, hm. i'll give that a shot
11:33:44 <napping> It seems to have a fancy TH/quoter for letting you write the same compact code and have it work without runtime magic, so there's no philosophical worry now
11:35:16 <kazagistar> mathu: [doStuff (n !! i) | i <- [0.. length n - 1]]    becomes (much more efficiently)    fmap doStuff n
11:35:34 <kazagistar> mathu: you might consider just using "transpose"
11:37:48 * hackagebot statistics 0.13.1.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.13.1.0 (BryanOSullivan)
11:38:36 <Pythonfant> supki: thx for mentioning it, looks a lot more comfortable to work with than http-conduit
11:39:46 <int3__> it would be nice to have some guidelines on which ghc language extensions are 'safe' to enable globally, i.e. would not affect performance or type-safety
11:39:58 <int3__> DeriveGeneric should be safe to enable globally though, right?
11:40:46 <tgeeky> int3__: yep.
11:40:56 <int3__> okay, thanks
11:41:19 <carter> int3__: no ghc extension will change perf
11:41:23 <carter> faik
11:41:24 <carter> afaik
11:41:42 <carter> ever
11:41:49 <carter> or at least,  i can't imagine how
11:41:54 <int3__> carter: oh to be clear i was thinking about compile-time performance
11:41:55 <ReinH> carter: DMR might affect sharing?
11:42:01 <carter> DMR?
11:42:07 <ReinH> dreaded monomorphism restriction
11:42:12 <jfischoff> ^
11:42:22 <carter> noMono
11:42:24 <carter> or more mono?
11:42:31 <carter> depending on the use case, one or the other can be better
11:42:53 <carter> int3__: if just enabling a language flag you don't use causes a type checking time regression, please file a bug report with a minimal repro
11:42:53 <ReinH> Right, just saying it's an extension that can affect runtime performance
11:42:54 <glguy> MonadComprehensions slows down list comprehensions
11:42:55 <carter> those are real bugs
11:42:57 <carter> true
11:43:10 <carter> glguy: i prefer ziplists to the other one
11:43:20 <carter> what is the name for the default list monad semantics?
11:43:29 <carter> "fake close combinatorial enumeration"
11:43:33 <c_wraith> product?
11:43:34 <ReinH> heh
11:43:41 <carter> i guess so
11:52:38 <pjdelport> carter: Cartesian product?
11:52:44 <carter> i guess so
11:54:19 <djahandarie> Hmm, is there a name for the operation of, given a map Int->Int, such as {0->1, 1->2, 5->6, 6->7, 10->11}, return {0->2, 5->7, 10->11} ?
11:54:52 <carter> djahandarie: f^2 ?
11:55:01 <carter> transitive closure?
11:55:13 <carter> looks like you want transitive closure
11:55:20 <vanila> it's not technically transitive closure
11:55:36 <guesting> I'm getting a weird error: "Could not find module `Text.ParserCombinators.Parsec' It is a member of the hidden package parsec-3.1.5'. Why is this happening? I installed parsec using cabal...
11:55:45 <vanila> transitive closure of {0->1, 1->2, 5->6, 6->7, 10->11} is {0->1, 1->2, 0->2, 5->6, 6->7, 5->7, 10->11}
11:55:46 <carter> guesting: add parsec to your cabal file
11:55:54 <guesting> oh
11:56:04 <carter> vanila: no.... thats not the transitive closure
11:56:06 <tgeeky> vanila: no?
11:56:08 <guesting> I just forgot that it has a cabal file
11:56:10 <guesting> whoops
11:56:28 <vanila> that is how you take the transitive closure of a relation
11:56:30 <tgeeky> oh; I rescind my objection;
11:56:32 <djahandarie> carter, my understanding of transitive closure is what vanila just said. What are you talking about?
11:56:59 <carter> djahandarie: in a directed graph where theres only one out edge
11:57:04 <carter> i'm thinking given an S
11:57:11 <carter> theres a unique T it finishes at
11:57:12 <guesting> carter: That was it thanks
11:57:59 <carter> well
11:58:03 <tgeeky> 0-1 1-2 5-6 6-7 10-11  -> 0-1 1-2 (=0-2) 5-6 6-7 (=5-7) 10-11
11:58:37 <carter> huh
11:58:40 <tgeeky> i don't know anything about transitive closure; but you also want (=10-11)?
11:58:49 <carter> wikipedia disagrees with me
11:58:53 <carter> time to edit it
11:59:00 <tgeeky> carter: that can be fixed! :o
11:59:06 <carter> :p
11:59:10 <djahandarie> tgeeky, not sure I follow your notation, but yes. I just want to compress all the paths.
11:59:28 <tgeeky> djahandarie: and not retain the original detailed paths?
11:59:35 <djahandarie> Yeah.
11:59:48 <djahandarie> It's easy to write an algorithm for this, I was just curious if it had a name.
11:59:54 <carter> matrix product :)
11:59:56 <carter> kinda
12:00:02 <carter> matrix product on semi ring?
12:00:40 <tgeeky> transitive reduction
12:00:53 <tgeeky> http://en.wikipedia.org/wiki/Transitive_reduction
12:01:05 <tgeeky> that should be it?
12:01:33 <djahandarie> Not quite
12:02:24 <tgeeky> djahandarie: /me looks at the definition from other places too... what is different?
12:02:51 * hackagebot safe 0.3.7 - Library of safe (exception free) functions  http://hackage.haskell.org/package/safe-0.3.7 (NeilMitchell)
12:04:32 <djahandarie> tgeeky, dunno how to explain it, it's just kind of obviously not the same thing lol. The transitive reduction of {0->1, 1->2, 5->6, 6->7, 10->11} is {0->1, 1->2, 5->6, 6->7, 10->11}
12:06:24 <tgeeky> oh; right. 'the same reachability relation' is not satisfied.
12:06:34 <tgeeky> because you can't reach, for instance, 1
12:06:45 <djahandarie> Yes.
12:10:30 * tgeeky is still searching about this for some reason
12:15:04 <RadwaKamal> Hi Everybody, if you have just started learning Functional Programming in Haskell, there is a free course only 4 sessions passed (found on YouTube) the lecturer talks mostly in Arabic but slides will be available for each session in English and you can contact him in English >>> check the event if you are interested : https://www.facebook.com/events/582198425220847
12:17:01 <darthdeus> too bad it's not in english :(
12:19:26 <tgeeky> djahandarie: I was thinking possibly 'edge contraction'; but it says there is a weaker 'vertex identification'.
12:19:45 <tgeeky> haskell in arabic. how wonderful
12:23:04 <carter> unicode?
12:24:28 <RadwaKamal> tgeeky: There will be a session today at 9:00 GMT In Shaa Allah, it'll be wonderful to join us
12:24:30 <djahandarie> tgeeky, ah, nice keyword. "Path contraction" looks to be the operation, no?
12:25:36 <tgeeky> RadwaKamal: I do not seriously speak any language except English, unfortunately. I was just happy to see Haskell extend her reach.
12:25:38 <dino-> RadwaKamal: That's great! I'm thinking it may be a good thing to post to one of the mailing lists, like the haskell@haskell.org which is for announcements. http://www.haskell.org/haskellwiki/Mailing_lists
12:25:39 <tgeeky> djahandarie: yes indeed.
12:25:56 <tomqq> Cale: hey cale, whatever it is you said yday that was apparently funny along the lines of 'functions aren't functors, function application is' could you repeat plz :P made some lightbulbs go off for me ;)
12:26:08 <RadwaKamal> darthdeus: We'll make slides soon in English
12:26:23 <RadwaKamal> dino-: Many Thanks, I will for sure
12:26:50 <tgeeky> djahandarie: it might also be called 'smoothing' or 'smoothing out' if we regard 1 as a vetex in { 0->1 , 1->2 }
12:28:11 <djahandarie> Nice. Thanks for helping find these terms.
12:28:50 <tgeeky> djahandarie: np. happy to learn something new
12:29:05 <carter> vertex contractions are kinda a deep subject
12:29:13 <carter> @google graph minor conjecture
12:29:14 <lambdabot> http://en.wikipedia.org/wiki/Hadwiger_conjecture_(graph_theory)
12:29:14 <lambdabot> Title: Hadwiger conjecture (graph theory) - Wikipedia, the free encyclopedia
12:29:43 <carter> its kinda a generalized 4 color theorem
12:30:10 <Putur> Hey all, I have a question regarding existential quantification. http://lpaste.net/107609
12:30:17 <beginner1> Hello, I'm trying out a course on Haskell (http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf), but I'm stuck on an exercise. I was wondering if someone could help me with exercise 2? I know how to double every other digit starting from the left, but from the right I have no clue.
12:31:12 <carter> beginner1: foldl vs foldr right?
12:31:16 <beginner1> I also checked stackoverflow, and found this thread: http://stackoverflow.com/questions/3963269/split-a-number-into-its-digits-with-haskell . However, they use a lot of the standard libraries etc, something which we haven't seen yet. I think we are supposed to solve it wihotu them
12:31:31 <lasericus> @beginner1 There are lots of solutions to that problem, but, you could use foldr or even the reverse function from Data.List
12:31:32 <lambdabot> Unknown command, try @list
12:32:00 <tgeeky> beginner1: well, the instructor is here
12:33:19 <Algebr> beginner1: does this work? http://lpaste.net/107611
12:33:42 <tgeeky> beginner1: but exercise 2 does *not* sound like splitting the constituent number into digits
12:33:53 <lasericus> beginner1: do you have some code that you've written available somewhere? I could probably give you some pointers based on what you've got so far.
12:34:12 <beginner1> well, I tried doing a pattern match, starting at the end
12:34:39 <beginner1> so x:y:[] = 2*x:y:[]
12:35:34 <lasericus> beginner1: that pattern match (as you probably already know) gets you a hook to the first and second elements in a list. If you want to start from the end of the list, you may wish to "reverse" it first.
12:35:44 <beginner1> However, now I need to do v:w: <here should be an even number of resting digits> = 2*v:w:<the rest>
12:35:58 <bernalex> what does '#' mean? like 0#
12:36:25 <beginner1> but, I have no way to check / match if the rest is an even amount of digits
12:36:35 <beginner1> so it doesn't work
12:36:38 <Algebr> beginner1: did you check the lpaste I directed at you?
12:36:40 <Rufflewind> Is extra-libraries in the .cabal file of any relevance for building libraries?
12:36:46 <tgeeky> Algebr: are you also in the class?
12:36:50 <beginner1> I saw the solution with reverse -> match from the left -> reverse
12:36:50 <Algebr> no
12:36:54 <haasn> bernalex: GHC convention for “primitive”
12:37:02 <bernalex> haasn: ah, IC. thanks.
12:37:07 <haasn> bernalex: eg. Int# is a primitive machine integer
12:37:08 <beginner1> It was quote elegant, but I'm not sure if we can use the reverse function ?
12:37:12 <beginner1> quite *
12:37:17 <tgeeky> Algebr: your solution looks right; but it seems unlikely that is the solution he wants (for the 2nd exercise in the 1st week of a haskell course)
12:37:29 <haasn> bernalex: data Int = I# Int#
12:37:29 <bernalex> haasn: yeah seeing some foo +# 2# and so on
12:37:32 <haasn> yeah
12:37:46 <bernalex> haasn: I assume it's for efficiency?
12:37:55 <Algebr> tgeeky: why? reverse is part of prelude, its nothing special
12:38:01 <haasn> Not just, there's a strong difference in semantics
12:38:16 <tgeeky> Algebr: I didn't object to reverse; I am just guessing that he was looking for a more elegant solution :o
12:38:19 <bernalex> haasn: feel free to elaborate with an example :-]
12:38:21 <beginner1> Algebr: yes, I checked it, but i 'm still trying to grasp it.
12:38:28 <Algebr> tgeeky: =P
12:38:36 <lasericus> beginner1: are you interested in seeing a complete solution to the problem, or, getting some help in solving it yourself?
12:38:48 <haasn> bernalex: I'm not sure how to summarize it well; Int# is unboxed - it does not live inside an I# tag; and hence cannot be used as part of things that require boxes - for example polymorphic containers
12:38:51 <haasn> [Int#] makes no sense
12:39:00 <tgeeky> Algebr: ah yes; there is a much more elegant solution out there.
12:39:11 <beginner1> lasericus: well, I think I know how to do it when I can use the reverse function.
12:39:29 <dwcook> @k Int#
12:39:29 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind v @ ? .
12:39:33 <dwcook> @kind Int#
12:39:35 <lambdabot>     Not in scope: type constructor or class ‘Int#’
12:39:35 <lambdabot>     Perhaps you meant one of these:
12:39:35 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
12:39:44 <tgeeky> beginner1: I would start hinking of it this way: What are the operators you want to apply to the elements in the list?
12:39:47 <Qfwfq> Where is the 'Any' kind provided? I forgot.
12:39:49 <tgeeky> beginner1: One of them is clearly (*2).
12:39:53 <tgeeky> beginner1: what is the other one?
12:40:02 <haasn> bernalex: Nor can it, I think, be passed to functions - Int# has kind # and functions require things of kind *; primitive operations like +# is not a function in the usual sense but an internal extra kind of primitive expression
12:40:23 <haasn> bernalex: Basically, Int# is not really a haskell value that behaves like haskell values
12:41:45 <beginner1> tgeeky: I lost you there. Just returnign the other value? Or do you mean concatenating the elements of the list
12:42:22 <tgeeky> beginner1: if we're going to visit each element of the input list and apply <some> function; one of the functions we're going to want is: (*2).
12:42:29 <beginner1> lasericus: I was just wondering if there was a 'better' solution that would not involve the reverse funcion, but just the elements from lesson 1.
12:42:42 <tgeeky> beginner1: there is, I'm trying to lead you to it :o
12:43:16 <tgeeky> beginner1: (there are two right answers: one of them is (*1), but the other is more important; it's like (*1) but general)
12:44:04 <beginner1> tgeeky: I'm thinking, one moment
12:44:48 <lasericus> beginner1: snd $ foldr (\item (b, list) (not b, (if b then item*2 else item) : list)) (False, []) [1..10]
12:45:46 <beginner1> tgeeky: the other function is a check if the object is in an even spot, starting from the right ?
12:46:20 <tgeeky> beginner1: nope. We do not have the ability to check the positions.
12:47:01 <tgeeky> beginner1: x (*1) = x;  that means (*1) is a (multiplicative) identity. The identity function (id) should do wel.
12:47:04 <tgeeky> @type id
12:47:05 <lambdabot> a -> a
12:48:02 <beginner1> Oh, you mean that one! Yea, I got that one
12:48:56 <beginner1> tgeeky: so now I need to find out which one of the two to apply.
12:49:10 <ocharles> Does anyone have a link to Chris Done's attempt at linear/structural typing in Haskell?
12:49:12 <ocharles> I can't find it :(
12:49:30 <tgeeky> beginner1: so, now that we know the two functions we are going to use: [id,(*2)]
12:50:01 <tgeeky> beginner1: now we need a way to get an appropriate number of these pairs for whatever size list we may have
12:50:09 <haasn> bernalex: This is sort of how {-# UNPACK #-} works on primitive types - it turns Int into Int# in the internal representation (which has pros and cons)
12:50:23 <chrisdone> ocharles: http://lpaste.net/105618
12:50:30 <ocharles> oh hai chrisdone !
12:50:30 <bernalex> haasn: oh really. I should read more on this. thanks for the intro.
12:50:32 <tgeeky> beginner1: but let's put on knowing the number of elements in the list, and get an infinite number of the pairs:
12:50:41 <haasn> bernalex: The best way to learn more about this is by playing around with GHC. Let me show you a small example
12:51:22 * chrisdone is making chicken, but mgsloan noticed the message =p
12:51:34 <ocharles> chrisdone: ah, so it's basically an indexed monad
12:51:53 <bernalex> anyone have a syntax file thing for lhs?
12:51:55 <ocharles> whos indices are pairs
12:51:57 <tgeeky> beginner1: so, for instance:
12:51:58 <bernalex> for vim
12:52:01 <tgeeky> > cycle [1,2]
12:52:03 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
12:52:15 <tgeeky> beginner1: that looks like it does the trick for regular numbers: so why not functions?
12:52:38 <tgeeky> > cycle [id,(*2)]
12:52:40 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
12:52:46 <tgeeky> I honestly don't know what that nonsense is.
12:52:55 * hackagebot idris 0.9.14 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14 (EdwinBrady)
12:53:06 <darthdeus> hey guys, I have a question about haskell-mode (asked a couple of times but got no answer :P), is there a way to turn off the import autocomplete? mentioned here https://github.com/haskell/haskell-mode/wiki/Import-management#entering-imports
12:53:20 <darthdeus> it says space acts as haskell-mode-contextual-space which prompts this
12:53:37 <tgeeky> beginner1: so, now we have two lists: the input list of numbers (of an unknown size), and this infinite list of functions (of an infinite size, so who cares about its size)
12:53:39 <bernalex> tgeeky: -> does not derive show
12:53:52 <beginner1> tgeeky: I see
12:53:53 <tgeeky> bernalex: then why did it even try? :o
12:54:11 <tgeeky> beginner1: so what function would we use to combine two lists in a meaningful way
12:54:23 <bernalex> tgeeky: lambdabot is special. ghci is also special, but it would probably whine about trying to print something that has no show instance.
12:54:33 <chrisdone> ocharles: yup, that's what the reddit poster was going for, but mine worked =p
12:54:38 <ocharles> :)
12:54:39 <darthdeus> chrisdone: i dont want to bother you good sir, but since you're the king of haskell-mode I'm sure you have an answer :P
12:55:13 <beginner1> tgeeky: merge ?
12:55:31 <tgeeky> @type merge
12:55:32 <lambdabot> Not in scope: ‘merge’
12:55:44 <ocharles> I'm experimenting with sort of session-type stuff in a free monad. I want to ensure that if a booking into a class is made, then the customer must have paid for it, or we've explicitly given it away for free. so proofs of payment become bound variables that can be used at-most once (there's the substructural part), and making a booking consumes that proof
12:55:46 <tgeeky> beginner1: nope, i'm thinking of a standard (family) of haskell functions that are included in the Prelude.
12:55:51 <ocharles> needed something to do this evening, anyway :)
12:55:55 <haasn> bernalex: http://lpaste.net/107615
12:56:20 <haasn> This is probably the best way to familiarize yourself with how GHC primitive types work
12:56:39 <bernalex> haasn: thanks heaps. going to go make wok now. will read later.
12:56:40 <tgeeky> beginner1: hint: do not search the list of Haskell Prelude functions alphabetically, because you'll get there last.
12:56:40 <beginner1> tgeeky: I would assume I can use map to apply the functions from list 2 to list 1
12:56:51 <tgeeky> @type map
12:56:52 <lambdabot> (a -> b) -> [a] -> [b]
12:57:11 <beginner1> tgeeky: tgeeky: one sec. Looking up
12:57:35 <tgeeky> beginner1: nope; we don't have *one* function we want to apply to a list. We have a list of functions we want to apply to a list of numbers.
12:57:49 <darthdeus> :(
12:57:55 * hackagebot configuration-tools 0.2.2 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.2 (larsk)
12:57:56 <chrisdone> darthdeus: oh, yeah
12:58:16 <beginner1> tgeeky: zip ? :D
12:58:23 <bernalex> tgeeky: if you want to tutor him slowly like this maybe #haskell isn't the best place. someone is bound to come by, with no context, and just yell the solution. :-P
12:58:49 <tgeeky> bernalex: not much further to go; but yes, I get your point :o
12:59:23 <tgeeky> bernalex: yes! almost. zip is the family. Unfortunately, it has a type that isn't very useful.
12:59:26 <tgeeky> @type zip
12:59:27 <lambdabot> [a] -> [b] -> [(a, b)]
12:59:36 <tgeeky> @type map
12:59:37 <lambdabot> (a -> b) -> [a] -> [b]
12:59:42 <tgeeky> @type zipWith
12:59:42 <bernalex> you meant beginner1
12:59:43 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:59:49 <tgeeky> beginner1: ^^ that stuff
13:00:21 <bernalex> fwiw with the out of context line I saw, I almost said to use <*>, heh.
13:00:37 <tgeeky> beginner1: so zipWith takes a function (a -> b -> c); and two lists [a] and [b]; and makes a list out of them [c].
13:00:50 <tgeeky> beginner1: so all we have left to do is find our function (a -> b -> c)
13:01:32 <chrisdone> darthdeus: git pull and then M-x customize-variable haskell-mode-contextual-import-completion
13:01:58 <darthdeus> lol you are the man :D
13:02:00 <darthdeus> thank you
13:02:32 <darthdeus> I guess I need to start using git for haskell mode
13:03:03 <tgeeky> beginner1: I'm not sure I understand why (I'm not that smart after all); but type of the function we want is actually: (a -> b) -> a -> b
13:03:04 <mgsloan> darthdeus: Better yet, magit!
13:03:29 <darthdeus> mgsloan: use magit to pull the latest magit version? :O
13:03:33 <chrisdone> \o/
13:03:34 <tgeeky> beginner1: and there is really only one choice for a function with that type.
13:03:54 <mgsloan> darthdeus: Sounds quite reasonable :D
13:04:48 <beginner1> tgeeky: according to the documentation, that is the :: function ?
13:05:10 <tgeeky> beginner1: (::) isn't a function?
13:05:29 <beginner1> $ I mean
13:05:34 <tgeeky> beginner1: indeed, that is the one
13:05:35 <beginner1> tgeeky: $ I mean
13:05:39 <darthdeus> i guess i also need more elisp skills :\
13:05:58 <beginner1> tgeeky: application operator, so that causes the function in the second list to be applied to the first one I suppose
13:06:04 <tgeeky> beginner1: so, put it all together.
13:06:07 <Algebr> darthdeus: everyone's elisp could be better lol.
13:06:18 <darthdeus> Algebr: true true
13:06:23 <tgeeky> beginner1: I would guess the other way around; but it doesn't really matter
13:06:37 <darthdeus> is there a book on elisp that's up to date?
13:06:47 <tgeeky> > zipWith ($) (cycle [id,id]) $ [1,2,3,4]
13:06:49 <lambdabot>  [1,2,3,4]
13:06:54 <tgeeky> > zipWith ($) (cycle [id]) $ [1,2,3,4]
13:06:56 <lambdabot>  [1,2,3,4]
13:07:02 <tgeeky> > zipWith ($) (cycle [id,(*2)]) $ [1,2,3,4]
13:07:03 <lambdabot>  [1,4,3,8]
13:07:24 <tgeeky> beginner1: so you were given sample input and output; check to see if it works.
13:07:40 <isomorpheous> darthdeus: the emacs manual
13:08:54 <isomorpheous> darthdeus: https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html
13:09:22 <darthdeus> isomorpheous: oh didn't know there was one, i'll check it out
13:09:45 <isomorpheous> darthdeus: My favorite part of Emacs is the extensive documentation
13:09:55 <sm> +1
13:10:35 <ph88_> hi all
13:10:35 <ReinH> @djinn (a -> b) -> a -> b
13:10:36 <lambdabot> f a = a
13:10:46 <ReinH> This function is also known as `id' :)
13:11:12 <quchen> > (+3) `id` 5
13:11:13 <tgeeky> @. pl djinn (a -> b) -> a -> b
13:11:14 <lambdabot>  8
13:11:14 <lambdabot> f = id
13:11:25 <ReinH> The only difference is ($) is specialized and has different fixity
13:11:35 <tgeeky> > zipWith (id) (cycle [id,(*2)]) $ [1,2,3,4]
13:11:37 <lambdabot>  [1,4,3,8]
13:11:41 <ph88_> can i make sub-modules with . ?  is there a limit of how many sub-modules ?
13:11:56 <tobiasgw> How can I add modules from a cabal sandbox to my hoogle database?
13:12:02 <quchen> ph88_: No, module names can only contain letters.
13:12:03 <tgeeky> beginner1: how is it going?
13:12:14 <chrisdone> tobiasgw: awkwardly
13:12:23 <ph88_> quchen: i saw Data.List ... so there is a . !!
13:12:37 <ReinH> quchen: er...
13:12:43 <quchen> ph88_: Well, that's the "List" module inside a "Data" folder.
13:12:55 <ph88_> a folder ????
13:12:58 <tobiasgw> wow, chrisdone, I'm starstruck
13:13:19 <ReinH> quchen: I'm not sure that's accurate? afaik "Data.List" is the proper module name.
13:13:19 <quchen> You can call "Data.List" a "module" too, but you can't make a module that has a "." inside its own name. The "." is generally a directory separator in module descriptions.
13:13:34 <chrisdone> tobiasgw: hahaha
13:13:36 <ReinH> Maybe I'm splitting a hair that doesn't need to be split right now
13:13:37 <beginner1> tgeeky: not super. zip $ (cycle [(*2),id]) [1,2,3] The function `GHC.List.cycle' is applied to two arguments, but its type `[a0] -> [a0]' has only one
13:13:45 <quchen> ReinH: On second thought, probably.
13:13:51 <quchen> But still, a dot means a folder.
13:13:54 <tgeeky> beginner1: nope; zip isn't suitable, you want zipWith
13:14:19 <tgeeky> > zipWith (id) (cycle [id,(*2)]) [1,2,3,4]
13:14:20 <ph88_> what happens if i but for example Geometry.Sphere not in the Geometry folder but in the main program folder ?
13:14:21 <lambdabot>  [1,4,3,8]
13:14:25 <ph88_> but -> put
13:14:54 <quchen> ph88_: You'll have trouble including that module in other files, because it won't be found.
13:14:56 <ReinH> quchen: does it denote a folder or connote a folder? I'll stop now.
13:15:13 <tobiasgw> chrisdone: I was *just* reading an issue on github where you commented on something similar to my question (https://github.com/haskell/cabal/issues/395)
13:15:14 <chrisdone> tobiasgw: i don't know of a way to do that directly, but i've some scripts for recombining your hoogle db
13:15:23 <quchen> ReinH: Symbolizes. The Report says it symbolizes a folder. (I just made that up on the spot.)
13:15:30 <ph88_> quchen: so there is automatic loading of files ? i don't have to specify file locations ?
13:15:30 <chrisdone> tobiasgw: right, that would be the ideal solution imo
13:15:51 <quchen> ph88_: There are certain search paths GHC will try when looking for modules. $PWD is one of them.
13:15:53 <ReinH> ph88_: the relationship between module names and directory structuers is a (de facto or de rigueur) standard for Haskell, so you might as well obey ;)
13:16:19 <ph88_> is there a limit for sub-folder / sub-modules ?
13:16:19 <ReinH> The path of least resistance is to figure out what GHC wants and then to do that.
13:16:20 <quchen> ph88_: Other default-search-folders are the global modules, sandboxes etc.
13:16:36 <quchen> I don't think there's a depth limit (that matters, anyway).
13:16:39 <ReinH> ph88_: none afaik, and certainly not one you are likely to encounter
13:16:43 <ReinH> the limit is probably your sanity
13:16:58 <ReinH> and your concern for the sanity of others who might use your code ;)
13:17:12 <quchen> Data.H.E.L.L.O.I.W.A.N.T.T.O.D.O.V.E.C.T.O.R.S
13:17:15 <tgeeky> beginner1: so; is it right (yet)? how does it do on the test inputs and outputs?
13:17:23 <ReinH> tobiasgw: chrisdone is kind of a big deal :)
13:17:23 <chrisdone> tobiasgw: fwiw i have a tool haskell-docs that'll give types/docs/modules for an identifier based on your installed haddocks, but it's not a type query like hoogle
13:17:29 <beginner1> tgeeky: zipWith ($) (cycle [(*2),id]) [1,2,3]
13:17:44 <ReinH> chrisdone: this reminds me I need to finish my hackage code search tool
13:17:51 * ReinH procrastinates
13:17:51 <beginner1> tgeeky: gives me 2,2,6
13:17:53 <chrisdone> reinh: lol
13:17:55 <chrisdone> reinh: https://i.chzbgr.com/maxW500/6772694272/hEA5F8CFD/
13:18:03 <darthdeus> chrisdone: huh this is weird, now i'm getting " Symbol's value as variable is void: haskell-font-lock-choose-keywords" when I try to actvate haskell-mode
13:18:04 <quchen> ReinH: Read "Structured Procrastination". Do it now.
13:18:05 <ReinH> chrisdone: yes exactly
13:18:08 <beginner1> tgeeky, but it should be 1,4,3
13:18:09 <ReinH> quchen: ok :)
13:18:21 <quchen> ReinH: Ig nobel prize winner. Rightfully so!
13:18:27 <ReinH> quchen: where is it?
13:18:27 <phaskell> No symbol 'it' found anywhere.
13:18:28 <tgeeky> > zipWith ($) (cycle [(*2),id]) [8,7,6,5]
13:18:30 <lambdabot>  [16,7,12,5]
13:18:30 <chrisdone> darthdeus: did you recompile?
13:18:31 <quchen> ReinH: On Google
13:18:35 <chrisdone> darthdeus: i.e. with make
13:18:37 <darthdeus> no :X how?
13:18:38 <ReinH> got it
13:18:41 <ph88_> what is the best practise when including 3rd party modules ?   in PHP it's common to declare namespace (similar to sub-modules) like :   VendorName.PackageName.NameOfClass.NameOfSubClass so you never have conflicts and almost never have to use alias
13:18:45 <chrisdone> darthdeus: just cd into the dir and do make
13:18:49 <darthdeus> oh right
13:18:50 <ReinH> quchen: Ok I'll probably read that later.
13:18:51 <darthdeus> sweet
13:19:05 <darthdeus> chrisdone: do i then need to restart emacs? or can i reload?
13:19:35 <tgeeky> beginner1: so, no matter what order we arrange the arguments to cycle; I don't think it will work the way we want it to (for both cases). We're going to have to do something else.
13:19:37 <quchen> ReinH: It's a good text to read instead of doing something else. You'll be very fast reading it. Why? That's the point of the essay.
13:19:41 <chrisdone> darthdeus: umm, i'd just restart emacs to be sure
13:19:45 <beginner1> > reverse zipWith ($) (cycle [(*2),id]) (reverse [1,2,3])
13:19:46 <lambdabot>  Couldn't match expected type ‘((a2 -> b1) -> a2 -> b1)
13:19:47 <lambdabot>                                -> [a3 -> a3] -> [a4] -> t’
13:19:47 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a0]’
13:19:47 <lambdabot>              with actual type ‘(a1 -> b0 -> c0) -> [a1] -> [b0] -> [c0]’
13:19:58 <ReinH> quchen: I was being ironic. :p
13:20:03 <quchen> ಠ_ಠ
13:20:05 <darthdeus> chrisdone: still getting the same error :(
13:20:11 <tobiasgw> chrisdone: haskell-docs seems great, maybe I can "settle" for that
13:20:17 <tgeeky> > reverse $ zipWith (4) (cycle [(*2),id]) $ reverse [1,2,3]
13:20:19 <ReinH> tobiasgw: if this isn't enough of a chrisdone fix for you we did a Haskell Cast with him recently too :D
13:20:19 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> b0 -> a))
13:20:20 <lambdabot>    arising from the ambiguity check for ‘e_142123’
13:20:20 <lambdabot>  from the context (GHC.Num.Num ((a1 -> a1) -> b -> a),
13:20:20 <lambdabot>                    GHC.Num.Num a1,
13:20:20 <lambdabot>                    GHC.Num.Num b)
13:20:22 <tgeeky> > reverse $ zipWith ($) (cycle [(*2),id]) $ reverse [1,2,3]
13:20:24 <lambdabot>  [2,2,6]
13:20:26 <quchen> beginner1, that parses as  `(reverse zipWith) ($) (cycle [(*2),id]) (reverse [1,2,3])`, which tries to reverse the "zipWith" function.
13:20:41 <beginner1> tgeeky, now we need to reverse the pair as well
13:20:41 <quchen> Remember that " " binds very tightly.
13:20:43 <tgeeky> > reverse $ zipWith ($) (cycle [id,(*2)]) $ reverse [1,2,3]
13:20:45 <lambdabot>  [1,4,3]
13:20:53 <tgeeky> that one looks good...
13:20:59 <ReinH> beginner1: Are you known as something other than beginner1? :)
13:21:00 <tobiasgw> ReinH: and I enjoyed that very much! Just like all the other Haskell Casts :)
13:21:03 <tgeeky> > reverse $ zipWith ($) (cycle [(*2),id]) $ reverse [8,7,6,5]
13:21:04 <ReinH> tobiasgw: <3
13:21:05 <lambdabot>  [8,14,6,10]
13:21:18 <tgeeky> > reverse $ zipWith ($) (cycle [id,(*2)]) $ reverse [8,7,6,5]
13:21:20 <lambdabot>  [16,7,12,5]
13:21:21 <ReinH> tobiasgw: should be releasing one with ocharles this week too :)
13:21:30 <tgeeky> beginner1: I think we found our function!
13:21:31 <ocharles> :)
13:21:41 <chrisdone> reinh: looking forward to the ocharles haskell cast :3
13:21:56 <beginner1> tgeeky: I think as well! Thank you very much.
13:21:57 <ocharles> hope you'll all enjoy my ramblings!
13:21:58 <chrisdone> darthdeus: hmm, let me try, haven't done a restart in a while
13:21:58 <tgeeky> > let doubleEveryOther = zipWith ($) (cycle [id,(*2)]) $ reverse
13:22:00 <lambdabot>  not an expression: ‘let doubleEveryOther = zipWith ($) (cycle [id,(*2)]) $ r...
13:22:51 <tobiasgw> ReinH: Great stuff! His blog is legendary
13:22:52 <tgeeky> @let doubleEveryOther x = zipWith ($) (cycle [id,(*2)]) $ reverse x
13:22:53 <lambdabot>  Defined.
13:22:56 <ReinH> tobiasgw: yeah!
13:23:01 <tgeeky> > doubleEveryOther [16,7,12,5]
13:23:03 <lambdabot>  [5,24,7,32]
13:23:08 <tgeeky> oops; wrong direction :o
13:23:09 <ReinH> ocharles: <3
13:23:12 <tobiasgw> oh, and there you are ocharles, haha
13:23:25 <tgeeky> @let doubleEveryOther x = reverse $ zipWith ($) (cycle [id,(*2)]) $ reverse x
13:23:26 <lambdabot>  .L.hs:149:1: Warning:
13:23:27 <lambdabot>      Pattern match(es) are overlapped
13:23:27 <lambdabot>      In an equation for ‘doubleEveryOther’: doubleEveryOther x = ...
13:23:27 <lambdabot>  
13:23:27 <lambdabot>  <no location info>:
13:23:31 <tgeeky> @let doubleEveryOther x = reverse $ zipWith ($) (cycle [id,(*2)]) $ reverse x
13:23:34 <lambdabot>  .L.hs:149:1: Warning:
13:23:38 <lambdabot>      Pattern match(es) are overlapped
13:23:41 * ocharles waves
13:23:42 <lambdabot>      In an equation for ‘doubleEveryOther’: doubleEveryOther x = ...
13:23:44 <beginner1> Reinh Not really. I just started Haskell today so I think beginner is an appropriate name ^^
13:23:44 <lambdabot>  
13:23:46 <tgeeky> sorry for the spam. :(
13:23:56 <darthdeus> chrisdone: this is what i get with debugging http://i.imgur.com/oWvLj6o.png
13:23:58 <tgeeky> beginner1: anyway, yeah; that's the one.
13:24:06 <ph88_> i'm confused .. how is dependency management done (cabal ?) while prevent conflict of module names ?
13:24:21 <jle`> tgeeky: you can always use pm's to talk to lambdabot :)
13:24:23 <tobiasgw> so pretty much every famous Haskeller is in here? Incredible
13:24:37 <tobiasgw> where's SPJ? ;)
13:24:42 <tgeeky> jle`: that was the problem. I had the functions already worked out and defined in PM; and I forgot that #haskell shares the same context.
13:24:51 <ReinH> heh, busy writing incredibly british commit messages on ghc
13:24:51 <jle`> tgeeky: ah.  no worries :)
13:24:56 <beginner1> tgeeky: Well, that was mighty kind of you for helping me out! This whole chat is quite active and helpful as well
13:24:59 <enthropy> tobiasgw: many others are missing
13:25:04 <ReinH> tobiasgw: https://github.com/ghc/ghc/commit/9b8ba62991ae22420a0c4486127a3b22ee7f22bd
13:25:11 <jle`> woo hoo a thanking party in #haskell
13:25:21 <chrisdone> tobiasgw: so if i run this: emacs -Q -L . -l haskell-mode-autoloads.el
13:25:21 <chrisdone> tobiasgw: everything works okay, i don't get a keywords error
13:25:22 <tgeeky> beginner1: you're welcome. tell Brent I helped you, he'll PM me a cookie
13:25:39 <chrisdone> tobiasgw: try that in the haskell-mode directory. if it works fine, there's something iffy in your configuration to investigate
13:25:52 <ReinH> beginner1: it's appropriate, but not much more distinguishing than "person12534". If we all used that naming system almost everyone here would be beginnerNNNN ;)
13:26:03 <ReinH> including myself
13:26:06 <chrisdone> tobiasgw: (the invocation just disables your own configuration (-Q) and loads just haskell-mode)
13:26:13 <darthdeus> chrisdone: hmm that works
13:26:26 <darthdeus> i guess i'm loading it incorrectly
13:26:35 <beginner1> ReinH: Excuses, I'll think about an alias for the next time.
13:26:52 <chrisdone> darthdeus: how are you loading it?
13:26:55 <ReinH> beginner1: it's nice to address someone by a name you can remember later is all :)
13:27:18 <tobiasgw> ReinH: That was all jolly complicated
13:27:19 <enthropy> ph88_: what kind of conflict? It's not very common for two packages to have a module with the same name
13:27:20 <ReinH> beginner1: in any event, thanks for joining us :)
13:27:23 <ReinH> tobiasgw: Good show!
13:27:27 <darthdeus> chrisdone: I stole your config, but it probably somehow conflicts with mine
13:27:31 <darthdeus> chrisdone: https://github.com/darthdeus/emacs-rebirth/blob/master/init.el#L30-L42
13:27:49 <chrisdone> darthdeus: did you also steal this line? https://github.com/chrisdone/chrisdone-emacs/blob/master/init.el#L90
13:27:50 <ReinH> darthdeus: I was lucky: I didn't have any pre-existing emacs config (or knowledge) so I just took his.
13:27:58 <ph88_> enthropy: what if it does happen? how do you distinct the modules of the two packages ?
13:28:10 <ReinH> chrisdone: I am now trying to use emacs binds in vim what the hell is happening
13:28:16 <ReinH> like, I can't use vim any more
13:28:24 <darthdeus> chrisdone: no i'm dumb, that solves it :D
13:28:34 <chrisdone> reinh: hahaha
13:28:37 <darthdeus> ReinH: i had like 4 configs before this one :( finally got one that works though
13:28:38 <chrisdone> darthdeus: awesome =)
13:28:43 <enthropy> ph88_: ghc has an extension -XPackageImports, but maybe you only need one of those two packages?
13:28:45 <darthdeus> ReinH: evil-mode saved me
13:28:58 <darthdeus> but now I can't use vim anymore, since I just keep hitting M-x and stuff all the time
13:29:05 <ReinH> darthdeus: I can't do vim emulators. They're always missing something.
13:29:05 <ph88_> enthropy: ok ill check it out if/when i actually run into this problem ^^
13:29:06 <quchen> What role does strict vs non-strict evaluation play in lambda calculus concerning termination? I vaguely remember a proof that lazy evaluation is always more defined than the terms produced by eager counterparts (but that memory might just be nonsense).
13:29:13 <ReinH> darthdeus: I used vim for 10 years so I use quite a bit of it
13:29:39 <darthdeus> ReinH: you might be surprised how much vim evil-mode is :) I've been using vim fulltime for like 5 years and it's almost perfect
13:29:44 <ReinH> quchen: are we talking denotational semantics, least-defined, etc?
13:29:47 <darthdeus> only thing that i had to rebind is C-c to C-g to exit insert mode
13:29:54 <quchen> ReinH: Yes
13:29:56 <darthdeus> since C-c is emacs thingy for everything
13:30:04 <ReinH> quchen: sounds reasonable but idk :)
13:30:14 <ReinH> heh yep
13:30:37 <ReinH> darthdeus: I'm not really up on denotational semantics :(
13:30:53 <darthdeus> ctrl-c? :o
13:32:11 <chrisdone> ciao dudes
13:32:47 <tobiasgw> ciao
13:34:15 <ReinH> er
13:34:22 <ReinH> why did I say that to you
13:34:28 <ReinH> quchen: I'm not really up on denotational semantics
13:34:37 <ReinH> or saying things to the right people
13:35:08 <quchen> Reiser: OK
13:37:54 <quchen> ReinH: I think the theorem is that "if a term has a normal form, it's independent of the evaluation order", from which it trivially follows that lazy expressions are more terminating.
13:38:12 <ReinH> quchen: ah hmm
13:38:16 <quchen> Such a basic theorem got to have a name. I wonder why I can't find it in my books.
13:38:25 <quchen> Well, only two books. Maybe that's the issue.
13:42:47 <vanila> I don't think your theorem is true in the presence of nonterminating subexpressions
13:43:11 <vanila> certainly for strongly normalizing lambda calculi, normal forms are unique wrt. evaluation order
13:45:05 <vanila> you can prove that lazy evaluation works when strict evaluation does by considering weak head normal forms
13:46:58 <josephle> quchen: it might be related to the diamond property?
13:48:05 <josephle> confluence?
13:48:27 <int-e> confluence.
13:49:36 <int-e> or, equivalently, Church-Rosser property. (Though actually having unique normal forms is a weaker property than confluence, but all confluent systems have unique normal forms.)
13:49:51 <quchen> Yeah Church-Rosser seems related.
13:50:04 <quchen> My perspective isn't far away enough :-\
13:50:30 <carter> confluence of transitive things?
13:50:41 <vanila> confluence/church rosser isn't relevant
13:51:18 <vanila> that tells you that normal forms are unique, nothing about different evaluation orders
13:51:36 <int-e> quchen: oh, but your theorem isn't ... you need a normalising strategy for ensuring that normal forms are reached, and people have shown that leftmost-outermost reductions in lambda calculus, which is essentially call by name, is normalising.
13:52:08 <int-e> (and lazy evaluation is an optimisation of call by name, thanks to sharing)
13:53:05 <Qfwfq> Do there exist strategies for testing whether a given term typechecks? (As part of a test suite.)
13:53:26 <josephle> confluence is if (a -> b) and (a -> c), then there exists a d s.t. (b -> *d) and (c -> *d)...right?
13:53:33 <Qfwfq> I guess I could doctest, but that's kinda hackish.
13:53:46 <josephle> could not a -> b vs a -> c based on evaluation order?
13:54:04 <josephle> where -> is single evaluation step
13:54:20 <int-e> josephle: no. that's local or weak confluence. for confluence, one starts with (a ->* b) and (a ->* c)
13:54:53 <josephle> int-e: ah
13:55:10 <jbetzend> Hey people! If I'm importing module A from module B and A contains a typeclass instance, is there any way to hide that instance from the import?
13:56:24 <int-e> josephle: (the system a <-- b <--> c --> d (meaning we have both b --> c and c --> b) is locally confluent but not confluent.)
13:56:37 <enthropy> jbetzend: no. you can make a newtype to define an instance that would otherwise conflict
13:57:34 <jbetzend> enthropy, Ah, I see. Thanks.
13:58:59 <quchen> int-e: Laziness is non-strict evaluation with the guarantee that one argument will only be evaluated once, right?
14:00:18 <int-e> quchen: that's how I understand it
14:01:20 <scaruffi2> hi, im trying to install 'algebra' from hackage, im using cabal. but algebra needs array < 0.5 . The current version of array is 0.5 . Is there a standard method for solving this kind of problem?
14:01:36 <quchen> scaruffi2: Sandboxes?
14:01:54 <quchen> Or you can pass parameters to Cabal to relax the constraint
14:02:04 <Sornaensis> can anyone recommend any in depth books on haskell
14:02:35 <quchen> scaruffi2: Check `cabal install --help`, there's an entry for "--allow-newer" for example.
14:02:41 <int-e> define "in depth"?
14:03:25 <scaruffi2> quchen: thanks! checking your suggestions    0)
14:05:03 <josephle> Sornaensis: in which direction do you wish to learn more about haskell?
14:06:54 <orzo> the direction in which my brain has progressively more information rather than progressively less
14:21:07 <Sornaensis> josephle: any resources that discuss things like software design using haskell I guess
14:21:34 <joof> does anyone here run nixos?
14:22:12 <joof> it's something that's had my attention for a while and appears to have really good haskell support in general
14:22:19 <josephle> Sornaensis: have you read Real World Haskell?
14:22:38 <haasn> joof: Some of us do; see #nixos for more information
14:23:27 <Sornaensis> I have not
14:23:29 * Sornaensis reads
14:29:40 <jabesed> is there an elegant way to slice a list?
14:29:57 <quchen> take x . drop y?
14:30:08 <jabesed> yeah that's what I do
14:30:38 <jabesed> also takeWhile p . dropWhile p'
14:31:04 <kazagistar> I dont think I have felt like I needed to slice a list in haskell, huh
14:31:23 <quchen> Vector might be more suitable for slicing things.
14:31:34 <jabesed> I'd just expect this to be so common that maybe there'd be some usual function I'm missing
14:31:43 <burp> was just gonna say that, for lists its ok, if you need efficiency you want to use Vectors anyway ;)
14:32:24 <kazagistar> jabesed: what are you actually using it for? it might be an XY problem
14:33:25 <jabesed> kazagistar: nothing special, just have a what amounts to a table with type  [(Date, Value)] and want slices of that history
14:33:40 <jabesed> kazagistar: so I just drop dates, take dates
14:33:54 <jabesed> kazagistar: efficiency is not really important here
14:34:13 <quchen> Wonderful! Then make it a vector using fromList and slice that.
14:34:33 <quchen> Lists are more like loops than data storage containers. You don't typically slice loops.
14:35:06 <jabesed> quchen: true, that's fair enough
14:35:09 <kallisti> hm, what happened to the section on hackage that shows build failures for a particular package version?
14:35:41 <enthropy> logs are still there, just the link is hidden
14:36:00 <quchen> http://hackage.haskell.org/package/PACKAGENAME/reports/
14:36:21 <kallisti> ah okay, thanks
14:36:26 <kallisti> looks like there's a documentation fail
14:36:52 <quchen> kallisti: Your documentation doesn't build?
14:37:27 <quchen> If your build report says "[]" then I've got the same problem, am clueless and would appreciate it if you told me when you fix the issue somehow.
14:38:11 <kallisti> https://hackage.haskell.org/package/webdriver-0.6/reports/  I've got "docsOutcome = Failed"
14:39:14 <jabesed> quchen: meh, maybe I shouldn't be using the word slice... slice in vector (as expected) requires two indices
14:39:41 <jabesed> quchen: my list is of the kind [(Date, Value)] and the slice is determined by the date
14:39:46 <jabesed> not by the position in the list
14:40:17 <jabesed> sure I could move it to a vector, determine positions, slice,
14:40:35 <jabesed> but not really an improvment over just dropping taking
14:40:35 <quchen> Or you could use a Map if your Dates are Ord.
14:40:51 <jabesed> quchen: true I could
14:40:54 <quchen> List is a pretty bad representation for most types of data.
14:41:53 <quchen> Maps support efficient splitting based on a predicate on the key.
14:42:04 <quchen> Eh, based on the key.
14:42:10 <jabesed> quchen: yeap, but eventually all I'm doing with it is consuming slices of it
14:42:25 <jabesed> quchen: and the way to consume these slices are usually folds, and maps
14:42:44 <jabesed> so in the end the intermediate data structure is barely used
14:44:11 <kazagistar> jabesed: getting to a list index is O(n), slicing a tree (like Map) is O(log(n))
14:44:32 <quchen> And slicing a vector is O(1).
14:44:38 <kazagistar> er
14:44:41 <quchen> And making a list a Map/Vector is O(n).
14:44:43 <kazagistar> not if you are doing it by key
14:44:52 <kazagistar> it still is O(log(n))
14:44:56 <quchen> And Big-O notation is a very poor performance indicator.
14:45:07 <kazagistar> cause you need to binary search
14:45:33 <kazagistar> but certainly the vector would have lower constant on the complexity
14:48:06 * hackagebot webdriver 0.6.0.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.0.1 (AdamCurtis)
14:48:34 <haasn> quchen: making a list a map is O(n log n) no?
14:49:10 <haasn> oh, no
14:49:16 <haasn> O(n) since you're adding indices which are already sorted
14:49:24 <haasn> I misunderstood what you meant
14:49:59 <quchen> fromList is very efficient when the input is sorted
14:50:43 <quchen> It just takes already sorted sublists and merges them
14:50:43 <haasn> I only knew about fromAscList / fromDistinctAscList; didn't know fromList was optimized for pre-sorted lists
14:51:15 <quchen> According to edwardk the performance gain of from*List is tiny compared to the unsafety it introduces
14:51:21 <quchen> I think he mentioned around 2%
15:00:18 <bernalex> anyone have cool examples of using infinite structures?
15:00:42 <bernalex> like zip [1..] xs, or having an endless list of numbers like fibonacci, & doing take 20 fibs etc.
15:01:13 <haasn> bernalex: turing machine that's.. turing complete
15:01:25 <quchen> Brainfuck tape that's infinite in both directions
15:01:37 <bernalex> specifically in haskell
15:01:37 <quchen> Kind of what haasn said, but more practical ;-)
15:02:05 <marchelzo_> How can I update cabal? I want to get version 1.18
15:02:14 <quchen> cabal install cabal-install
15:02:18 <quchen> That'll get you 1.20 though
15:02:27 <marchelzo_> i did that
15:02:35 <marchelzo_> but cabal --version says 1.16
15:02:36 <quchen> cabal install cabal-install-1.20?
15:02:44 <quchen> Oh, that sounds like a $PATH problem.
15:03:05 <marchelzo_> while it was installing it sais 1.20 but then the version says 1.16 so im not sure if it upgraded
15:03:07 <quchen> Make sure your .cabal/bin directory comes before the other directories.
15:04:07 <marchelzo_> .cabal/bin isnt even in my PATH
15:05:26 <quchen> Well that explains it.
15:05:39 <kazagistar> marchelzo_: then you updated the version in .cabal/bin, and are using a different version
15:05:43 <haasn> You could also install the new version system-wide
15:05:54 <marchelzo_> yeah i just added that to my path and it now works
15:05:58 <haasn> But I think things will break whether you take my word for it or not
15:06:01 * haasn hates cabal-install
15:06:20 <Pythonfant> sandboxes to the rescue!
15:06:30 <quchen> marchelzo_: Using `which cabal` you can check where the `cabal` executable is located. Now it should point to .cabal/bin, before it was /usr/local/bin or something.
15:06:59 <marchelzo_> yeah its now ~/.cabal/bin/cabal
15:07:34 <marchelzo_> and I can make sandboxes now, so I guess it's all good
15:07:36 <marchelzo_> thanks
15:25:40 <jabesed> haskell could really use labeled arguments
15:25:56 <orzo> doesn't it have those as an extension?
15:26:01 <jabesed> arrays have them why can't functions
15:26:06 <jabesed> orzo: it does?
15:26:16 <orzo> http://www.haskell.org/haskellwiki/Implicit_parameters
15:26:20 <quchen> Ewwww!
15:26:25 <jabesed> eh not the same
15:26:25 <quchen> No, don't use that extension.
15:26:41 <jabesed> quchen: implicit parameters can be nice for certain use cases
15:26:51 <jabesed> since we don't have modules that is
15:27:14 <quchen> I don't know any use cases.
15:27:21 <jabesed> quchen: well here's an example
15:27:47 <jabesed> quchen: I remember implementing a simple neural network (backpropagation algorithm)
15:28:10 * hackagebot codex 0.1.0.2 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.2 (aloiscochard)
15:28:13 <jabesed> and if you read a book on the subject the way it is described is that, after you calculate a bunch of stuff
15:28:45 <jabesed> then in that fixed context you calculate a bunch of "constants"
15:29:05 <jabesed> and then it describes how to use those constants to again calculate a bunch of other stuff
15:29:32 <jabesed> now these aren't really constants of course
15:29:44 <jabesed> they're just the result of some functions
15:30:04 <jabesed> but now what do you do? how do you calculate all that stuff based on those constants?
15:30:26 <jabesed> do you just make a huuuuuge function with lots of local calculations based on those local constants?
15:30:40 <jabesed> do you just recalculate those constants all the time?
15:30:58 <marchelzo_> how do you troubleshoot problems when trying to install cabal packages? I am trying to follow: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html and I am getting nowhere because of cabal errors
15:31:18 <jabesed> ideally there'd be some elegant way to say... OK in this "module" I have these fixed parameters
15:31:35 <jabesed> but which we don't
15:32:14 <jabesed> and using  a big  parent function with lots of local functions to express that makes testing a nightmare
15:32:48 <jabesed> so implicit parameters basically let you take these make this modular
15:32:59 <aloiscochard> jabesed: why not a Reader?
15:33:05 <jabesed> writing what are supposedly local functions at the top level
15:34:26 <jabesed> aloiscochard: use a reader and now your "constants" and all derivative results are all packed in a monad, and need to be  constantlyt unpacked just to perform arithmetic calculations
15:34:42 <jabesed> aloiscochard: or operations constantly lifted
15:34:53 <flebron> Is categories a deprecated package? It seems not to build with recent GHCs, erroring about typeOf2 not being a member of Typeable2. IIRC Typeable2 no longer exists in recent GHCs, so this would seem to be a lib error, right?
15:34:55 <jabesed> it's a dumb overhead to express something so simple
15:35:44 <jabesed> I still find implicit parameters ugly because you have to use them per function/constant
15:36:09 <jabesed> ideally you could just use them in "modules"
15:36:37 <jabesed> or some notion of sub-modules within modules that don't need to be in correspondence to files
15:37:06 <aloiscochard> that's basically DI
15:37:10 <jabesed> DI?
15:37:29 <aloiscochard> jabesed: dependency injection, bu that's a concept coming from a dark world
15:37:41 <jabesed> aloiscochard: well I was thinking ML modules
15:37:48 <jabesed> aloiscochard: SML/OCaml whatever
15:37:49 <aloiscochard> jabesed: much more bright
15:38:03 <aloiscochard> jabesed: is it what backpack try to solve?
15:38:09 <enthropy> flebron: there is a module Data.OldTypeable (but switching things to use the new typeable is only a bit more work)
15:38:22 <jabesed> aloiscochard: never heard of backpack
15:38:26 <aloiscochard> jabesed: http://research.microsoft.com/en-us/um/people/simonpj/papers/modules/
15:38:38 <jabesed> aloiscochard: oh that!
15:39:16 <jabesed> aloiscochard: I haven't read it yet... maaaaay be but I'm not sure if they go that far
15:41:42 <jabesed> in any case... my 'complaint' now was not so much that (even though I miss ML modules)
15:41:50 <jabesed> but lack of labeled arguments
15:42:00 <jabesed> the diffDay signature is
15:42:10 <jabesed> diffDay :: Day -> Day -> Integer
15:42:24 <jabesed> which argument is which
15:42:50 <jabesed> documentation doesn't even say, had to check source, but regardless, to easy to mess up
15:42:57 <jabesed> too*
15:43:52 <jabesed> we could use a record but then it's not curried
15:44:01 <enthropy> probably it takes arguments in the same order as (-)
15:44:28 <quchen> jabesed: Sorry, got a phone call. Back now.
15:44:41 <jabesed> enthropy: it does, but could be first then last
15:44:45 <quchen> jabesed: Sounds like you're having the problem of implicit configurations there.
15:45:02 <jabesed> quchen: kind of sort of
15:46:08 <jabesed> quchen: the "solution" in theory is really simple... you want to make a huge program as local to a function
15:46:47 <jabesed> quchen: problem is that is attrocious from a practical point of view
15:46:56 <jabesed> quchen: you throw modularity out of the window
15:47:15 <jabesed> quchen: "modules" (ML style) give you said modularity back
15:47:25 <quchen> Hm. Up to now I solved that using Reader.
15:47:34 <aloiscochard> +1
15:47:37 <quchen> But yeah, ML modules would be sweet. We dream about them regularly here.
15:47:44 <josephle> the type theory behind ML modules is quite fascinating...
15:47:55 <jabesed> quchen: works it's just pretty ugly
15:47:57 <quchen> I've never heard of type theory involving modules.
15:48:10 <josephle> https://www.mpi-sws.org/~dreyer/thesis/main.pdf
15:48:38 <jabesed> quchen: basically if all your program is dependent on some initial values, congrats, you just Readerified everything
15:48:58 <josephle> the thesis of the man who brings us backpack :)
15:49:10 <quchen> jabesed: Or do some unsasfePerformIO hacking.
15:49:13 <bernalex> is the part about definition in http://www.seas.upenn.edu/~cis194/lectures/01-intro.html right?
15:49:29 <bernalex> "Put another way, = does not denote “assignment” like it does in many other languages. Instead, = denotes definition, like it does in mathematics."
15:49:31 <jabesed> quchen: I wouldn't even call that haskell anymore
15:49:32 <aloiscochard> jabesed: you might be interested to see how dependend type give you basically a module system for free, for example in Idris
15:49:48 <bernalex> "That is, x = 4 should be read as [...] “x is defined to be 4”"
15:49:48 <quchen> jabesed: Hacking is part of any language :>
15:49:51 <jabesed> aloiscochard: got to look into it
15:49:59 <bernalex> is htat really a "definition" in mathematical terms?
15:50:36 <jabesed> aloiscochard: as of now I'm playing a bit with Coq
15:50:46 <jabesed> aloiscochard: I've look into agda, but Idris not so much
15:50:55 <amalloy> bernalex: sounds about right to me
15:51:08 <quchen> bernalex: Sure, why not. x is defined to be equal to 5.
15:51:09 <amalloy> as compared to other languages, where it means "x is 4 for now, but no promises about later"
15:51:11 <quchen> And vice versa.
15:51:19 <bernalex> quchen: some guy is pestering me about it :-P
15:51:23 <bernalex> I thought it sounded fine to
15:51:50 <bernalex> he says that x = 4 is just an equation
15:52:02 <bernalex> because with no context it's not a definition
15:52:04 <quchen> Ask him whether 4 = x is also an equation.
15:52:57 <bernalex> he said that x = 4 is "x is equal to 4" not "x is defined as 4".
15:53:13 <conal> in the presence of (what we think of as) recursion, the notion of "definition" is subtle.
15:53:14 <bernalex> I think it's a bit too semantic-y to be really upset/care either way, but I thought it sounds fine to call it a definition.
15:53:20 <bernalex> conal: please expand
15:53:27 * hackagebot str 0.1.0.0 - A type class to abstract between many different string types.  http://hackage.haskell.org/package/str-0.1.0.0 (thinkpad20)
15:54:11 <conal> bernalex: hm. what's more important than semantics?
15:54:40 <jabesed> conal: well the repeated use of the defined argument in the definition is just syntactic sure for a fixpoint operator
15:55:10 <bernalex> conal: food? a lot of things are sometimes more important than semantics. if a tutorial uses something wrong once, I'm inclined to not care. if someone has consistently misunderstood something and insist on propogating it as truth that's worse.
15:55:18 <jabesed> conal: so with that in mind  x = ... really is akin to definitions in mathematics no?
15:55:18 <quchen> Peaker says: arguing semantics is fruitful. Arguing terminology is less interesting :)
15:55:19 <conal> jabesed: that's the subtlety. it wasn't explained until the late 60s or early 70s. by dana scott.
15:55:26 <jabesed> conal: right
15:55:28 <bernalex> conal: you are indeed the optimal guy to ask about this question though :-]
15:55:35 <bernalex> maybe together with rms :-P
15:56:31 <conal> bernalex: have you looked into domain theory? it gives a semantics for recursion.
15:56:41 <bernalex> conal: I have not.
15:56:53 <bernalex> conal: do you have a comment on the original question BTW?
15:56:56 <conal> bernalex: check out "least fixed points"
15:57:00 <bernalex> conal: thanks
15:57:07 <conal> bernalex: what was the original question?
15:57:45 <conal> jabesed: i don't know what you mean by "really is akin to" here.
15:58:00 <bernalex> conal: bernalex | is the part about definition in http://www.seas.upenn.edu/~cis194/lectures/01-intro.html right? bernalex | "Put another way, = does not denote “assignment” like it does in many other languages. Instead, = denotes definition, like it does in mathematics." bernalex | "That is, x = 4 should be read as [...] “x is defined to be 4”" bernalex | is htat really a "definition" in
15:58:02 <bernalex> mathematical terms?
15:58:34 <conal> bernalex: it's not a definition in the simple sense of set theory.
15:58:47 <conal> bernalex: instead it's a particular solution to a set of equations.
15:58:49 <bernalex> conal: my friend says that that's an equation that says "x is equal to 4", not a definition in maths. note he's not a mathematician, this is just what he thinks.
16:00:09 <conal> bernalex: i don't know what your friend means, but if there's circularity/"recursion", then one has to address the possibility of no solution or multiple solutions.
16:00:29 <jabesed> is there some simple way to work within a monad in GHCi?
16:00:47 <conal> bernalex: fortunately, there's a lovely theory in which we can always single out a preferred solution, namely the "least" one in an information ordering.
16:00:52 <quchen> jabesed: In what way?
16:00:53 <jabesed> e.g.  let y <- read_stuff_IO
16:01:02 <jabesed> show y
16:01:04 <quchen> No need for the let
16:01:10 <jabesed> oh
16:01:14 <conal> bernalex: even for equations like "x = x" and "x = x + 1".
16:01:14 <dwcook> jabesed: ghci lets you use do statements to perform IO on the spot.
16:01:17 <quchen> GHCi is a lot like being in an implicit "IO do block"
16:01:20 <jabesed> ah
16:01:33 <dwcook> line <- getLine -- is perfectly valid in ghci
16:01:58 <jabesed> didn't remember that
16:01:59 <conal> bernalex: it's only in this context of *least solution* idea that we can call these things "definitions".
16:02:17 <bernalex> conal: aha
16:02:30 <dwcook> jabesed: if you also wanted something besides IO (you did say "a monad", without specifying which one), you may have to clarify what you're after.
16:02:52 <bernalex> conal: thanks!
16:03:21 <conal> bernalex: this idea applies to all programming languages, thanks to chris strachey and dana scott. haskell makes it especially apparent, because we have partially defined values.
16:03:41 <conal> bernalex: you're welcome. check out denotational semantics & domain theory. it's very beautiful stuff!
16:04:00 <bernalex> conal: have some wikipedia stuff up for starters :-]
16:04:07 <conal> bernalex: great.
16:04:37 <bernalex> conal: I'll spend some time on this tomorrow at work. thanks a lot for sparking an interest.
16:04:52 <conal> bernalex: :) ! you're welcome.
16:05:33 <conal> bernalex: denotational semantics is at the heart of how i design libraries. i call the methodology "denotational design".
16:06:21 <quchen> conal: Do you have a go-to reference to read about that? Denotational semantics and domain theory, that is?
16:06:36 <conal> bernalex: denotational semantics can be used to analyze languages & libraries or to design them. most of what you'll find is the former. i find the latter much more useful in practice.
16:07:02 <conal> quchen: no, i don't anymore. i learned it from joe stoy's book, which is quite dated now.
16:07:12 <quchen> Pity.
16:08:00 <bitemyapp> quchen: did the material help?
16:08:20 <conal> quchen: there are probably some good ones out there. i just don't have a recommendation handy.
16:08:22 <bernalex> conal: would you say that pattern binding declarations with multiple equations is closer to the heart of denotative programming than case expressions?
16:08:47 <bernalex> conal: to me this feels connected, but you have a much better grip on the semantics than me.
16:09:06 <conal> bernalex: no. the former is syntactic sugar for the latter.
16:09:10 <quchen> bitemyapp: Yes, much better now. Thanks!
16:09:26 <quchen> bitemyapp: I think that four-way table is etched into my memory now :-D
16:09:35 <bernalex> conal: I know this. so you would say that declaration vs. expression style is completely irrelevant to denotative programming?
16:09:45 <bitemyapp> quchen: good. Anything other than the table strike you as being particularly helpful?
16:09:57 <bitemyapp> quchen: I want to know if there's anything I should highlight or incorporate in future.
16:10:13 <conal> bernalex: i don't know of a relevance. might be one, i suppose.
16:10:28 <bernalex> conal: my knowledge of denotative is limited to landin, some papers of yourself & some articles on wikipedia. so you'll know more than me.
16:10:34 <quchen> bitemyapp: Well I basically looked at that table and the catchwords around it, it was a bit of a targeted search I guess. I don't think I have good suggestions for others.
16:10:42 <bitemyapp> quchen: that's fine, thanks for the feedback.
16:10:46 <bernalex> conal: I just feel like declaration style, if nothing else, is better suited for denotative programming.
16:11:02 <quchen> bitemyapp: I only spent like 2 hours on it, and that was just recreational learning (well, like everything I've ever learned around Haskell heh)
16:11:07 <bernalex> bitemyapp: I sent your learn-haskell-github-thingy to two guys today. they seem to like it!
16:11:36 <quchen> bitemyapp: Do you happen to know a good reference about denotational semantics and domain theory? :-D
16:11:57 <bernalex> conal: maybe what's really going on is just that I like declaration style and nothing more, heh. :-]
16:12:05 <apples> graham hutton has some nice intro notes on the subject
16:12:08 <conal> bernalex: :)
16:12:29 <johnw> http://www.cs.nott.ac.uk/~gmh/domains.html
16:12:45 <conal> bernalex: you might enjoy http://conal.net/blog/posts/lazier-function-definitions-by-merging-partial-values
16:12:49 <bernalex> it really annoys me that the haskell wiki advices against multiple equations
16:13:07 <bernalex> because literally weekly someone comes to me and says "but even Haskell discourages it, it must be bad!"
16:13:21 <johnw> multiple equations?
16:13:30 <bernalex> johnw: pattern binding declarations
16:13:34 <bernalex> f [] = []
16:13:36 <bernalex> f [x] = x
16:13:41 <bernalex> erm = [x] :-P
16:13:41 <johnw> what's wrong with that?
16:13:47 <quchen> ^
16:13:48 <bernalex> johnw: haskell.org wiki discourages it
16:13:52 <johnw> and...?
16:13:58 <quchen> And why?
16:14:03 <bernalex> johnw: so people keep telling me "even Haskell itself discourages it!"
16:14:06 <johnw> i use them, and life continues
16:14:09 <bernalex> quchen: poor poor poor reasons
16:14:21 <quchen> So "someone on a wiki said it"?
16:14:25 <bernalex> conal: pulled it up in a tab for work tomorrow! thanks
16:14:32 <bernalex> quchen: yes but it's on haskell.org, so people take it SRS
16:14:40 <quchen> I really can't think of a reason it's bad. Got a link?
16:14:48 <Iceland_jack> There is also a 'do-notation considered harmful', big whoop
16:14:53 <bernalex> quchen: they are bad.
16:15:03 <bernalex> quchen: http://www.haskell.org/haskellwiki/Programming_guidelines#Case_expressions
16:15:13 <conal> bernalex: i have no idea what some people might dislike about the multi-clause declaration stye. and personally, i like it.
16:15:18 <bernalex> "But this declarative style is only nice for toy examples "
16:15:20 <bernalex> LOL
16:15:24 <bernalex> conal: I adore it
16:15:30 <quchen> ∀string ∃article. article ⇒ bad(string)
16:15:57 <conal> bernalex: it can be deceiving if read as independent equations, as i point out in that blog post.
16:15:59 <quchen> Maybe we should delete that section from the wiki.
16:16:02 <bernalex> conal: I want to implement it in a programming language, but the main guy won't have it because "even Haskell discourages it!" he keeps telling me.
16:16:13 <bernalex> quchen: please
16:16:26 <bernalex> quchen: the reasons are so weak. and people take it srs because it's on haskell.org.
16:16:43 <conal> bernalex: what could it even mean to say that Haskell discourages something?
16:16:47 <bernalex> it talks officiall-y "We don't propose this style either. We propose to use as much pattern matching (including as-patterns) on a single left-hand-side as appropriate. "
16:16:59 <bernalex> conal: I don't know. maybe if it were in the language report.
16:17:11 <conal> bernalex: sounds very unlikely to me.
16:17:13 <Iceland_jack> conal: People use if informally if it's non-idiomatic code
16:17:19 <Iceland_jack> *it
16:17:19 <bernalex> conal: oh it's not at all.
16:17:36 <bernalex> Iceland_jack: I think I stole your quote
16:18:18 <bernalex> Iceland_jack: https://secure.plaimi.net/~alexander/haskell.html you're the earliest I've seen attributed to the joke I have about proselytising haskell. do you know its origin?
16:18:37 <quchen> bernalex: Your wish has been granted
16:18:39 <Iceland_jack> I said it first
16:18:43 <Iceland_jack> with a spelling mistake no less
16:18:51 <bernalex> quchen: thank you. maybe I'll get fewer emails that say this now.
16:19:08 <Iceland_jack> @quote Iceland_jack
16:19:09 <lambdabot> Iceland_jack says: It feels like Haskellers would invite Jehova's witnesses in for tea just to proselatize Haskell to them.
16:19:15 <bernalex> Iceland_jack: I know, I saw an IRC log where this was misspelt by ou.
16:19:27 <bernalex> wow that's a big'un :-P
16:19:31 <quchen> I'm expecting an angry email by some Wiki user who owns that article now. I regularly need emails like these to be reminded that wikis are a bad idea and contributing sucks.
16:19:39 <Iceland_jack> What's a big one?
16:19:49 <quchen> Well, wikis are great as long as one does not attempt to edit them, ever.
16:20:03 <bernalex> Iceland_jack: proselatize -> proselytise. not actually big. I was being facetious.
16:20:08 <quchen> Unless you're the owner of an article and complain to others, have thick skin, and a lot of time. End rant.
16:20:46 <bernalex> quchen: I hope you get fewer emails about that than I get about Haskell discouraging my favourite syntax sugar in any language or close to it.
16:21:07 <quchen> Sugar?
16:21:12 <quchen> Oh, you mean "do" notation.
16:21:26 <quchen> I'm not so sure it's sugar anymore actually, since it's individually typechecked.
16:21:27 <bernalex> I mean being able to write 5 instead of fromInteger 5 or SUCC SUCC SUCC SUCC SUCC ZERO is nice too, don't get me wrong.
16:21:33 <bernalex> quchen: no I mean the multiple equations
16:21:36 <quchen> Oh.
16:21:47 <bernalex> they are syntax sugar for case expressions
16:22:03 <bernalex> but boy are they sweet
16:22:11 <quchen> Really, sugar? In Core maybe
16:22:24 <quchen> That reminds me that I didn't find the section in the Report talking about multiple equations.
16:22:40 <bernalex> there is a section talking about them? I don't seem to recall it
16:22:56 <quchen> Well it's legal Haskell so some section has to talk about it
16:23:21 <bernalex> not necessary. there could just be simplified BNF for it.
16:23:30 <Hafydd> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
16:23:35 <quchen> Probably the "formal semantics of pattern matching" part. Everything is in that part whenever I want to know something.
16:24:33 <quchen> Hafydd: We're talking about "foo [] = a  ===  foo x = case x of [] -> a", not do-notation
16:24:38 <Hafydd> Oh.
16:24:50 <Hafydd> That's in there, too.
16:25:22 <bernalex> quchen: or to go full expression style, foo = \x -> case x of [] -> a
16:25:56 <quchen> Hmm I'm not sure you can transform it like this
16:26:24 <quchen> Because of subtle "foo x ≠ foo = \x ->"
16:26:43 <bernalex> I'm not sure what you mean.
16:26:52 <bernalex> foo a b = b is the same as foo = \a b -> b
16:27:12 <bernalex> or foo a = id for that matter
16:27:23 <quchen> The DMR makes those expressions different :-\
16:27:46 <bernalex> the what? :-]
16:28:04 <quchen> :>
16:28:14 <bernalex> dennis ritchie is powerful but not *that* powerful, surely
16:28:53 <Hafydd> In here: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-800004.4 -- although I suppose it might not be described as "sugar".
16:29:24 <k00mi> bernalex: dreaded monomorphism restriction
16:29:40 <bernalex> k00mi: oh that old thing
16:30:17 <bernalex> I would be out of my depth to propose its implications on expression v. declaration style, sorry quchen.
16:31:30 <quchen> bernalex: If you write type sigs explicitly I guess you can ignore the DMR
16:32:03 <quchen> I once thought there was more of a difference, but that's all I could find about it.
16:32:22 <bernalex> fwiw I heart declaration style
16:32:26 <quchen> There's also GHC's inlining behaviour, but that doesn't affect semantics and it's an implementation detail.
16:32:48 <bernalex> but the lang I want to implement stuff in refuses because it doesn't enhance expressiveness
16:33:05 <bernalex> which I think is a big mistake, because syntax is the first thing you see when you see a chunk of code
16:33:29 <quchen> I don't see much of a benefit in writing lambdas all the time.
16:33:41 <quchen> You'll be searching for the -> instead of the = in equations.
16:34:12 <bernalex> where clauses + lhs arguments + pattern matching + guards > let expressions + lambda abstraction + case expressions + if expressions
16:34:18 <bernalex> by an nigh endless amount to me
16:35:02 <bernalex> but I love having both as I find the latter nice for functions where the *how* is so important that the *what* doesn't make much sense by itself. this happens in game update functions a lot.
16:35:20 <quchen> I like all those styles.
16:39:19 <bernalex> quchen: I think whoever made the decision to include both styles did very well. yes, we get less uniform code. but we gained so much in our heightened ability to express what our brain is thinking in code.
16:39:41 <bernalex> (note: not talking about plt expressiveness here)
16:44:01 <quchen> And we can also bikeshed the hell out of everything! :>
16:58:44 <johnw> i say we decide upon a new name for "bikeshedding"
16:58:57 <frerich> ;-)
16:59:11 <johnw> and it's got to be the *right* name, so we don't need to discuss it ever again
16:59:24 <jfischoff> :)
17:00:11 <Enigmagic> sounds like we need a committee
17:00:52 <geekosaur> &ing >.>
17:01:08 <geekosaur> or is that #&ing?
17:14:46 <LuxuryMo_> I ran cabal update. Told me there was new cabal-install. I installed it. Update again, tells me there’s a new cabal-install.
17:15:18 <kini> LuxuryMo_: make sure the `cabal` you're running is the new one that got installed, not the old one you were running before
17:15:30 <kini> in particular, possibly update your PATH variable
17:15:44 <LuxuryMo_> it did warn me that /Users/levinotik/Library/Haskell/ghc-7.8.2/lib/cabal-install-1.20.0.3/bin is not in my path
17:15:48 <LuxuryMo_> so its probably that
17:15:48 <c_wraith> yeah, that's always caused by running cabal from a location other than cabal installs the new version
17:15:52 <sm> LuxuryMo_: eg put WHEREVER/.cabal/bin at the front of PATH
17:15:55 <kini> LuxuryMo_: yup, that's what it is then
17:17:05 <sm> perhaps export PATH=.cabal-sandbox/bin:~/.cabal/bin:$PATH is a good idea, I'm not sure
17:17:06 <jabesed> conal: how can unamb be referential trasparent...
17:17:31 <jabesed> conal: after all it is dependent on how much time something takes to compute...
17:17:31 <kini> whoa, relative paths in $PATH?
17:17:36 <kini> that sounds scary and dangerous
17:17:44 <conal> jabesed: did you read the precondition?
17:17:49 <sm> livin' on the edge!
17:18:10 <jabesed> conal: yes... they must agree unless bottom...
17:18:20 <jabesed> conal: problem is
17:18:40 <LuxuryMo_> oh i think an issue is that i installed the ghcmacosx thing originally and its in /Applications/ghc-7.8.2.app/Contents/bin/cabal
17:18:48 <jabesed> conal:  bottom doesn't necessarily mean a non-terminating program... bottom is undefined behaviour
17:18:57 <jabesed> conal: so what if bottom raises an exception
17:19:18 <conal> jabesed: it's meant to do the right thing for all manifestations of bottom, not just nontermination.
17:20:38 <jabesed> conal: but doesn't this mean that if you have  u = _|_ and v = 2  you could get either   2, if v is computed really quick, or else an exception could be raised?
17:21:08 <conal> jabesed: i don't think so. unless there's a bug i'm unaware of. see my previous comment.
17:23:23 <jabesed> conal: need to look at the source... I just can't see how `unamb (seq u (throw e)) v `  can result in a deterministic program...
17:23:31 <jabesed> conal: but maybe you're right
17:24:07 <LuxuryMo_> my cabal is all messed up..not sure how to fix it
17:24:54 <conal> jabesed: yeah. check out the source. you'll see that it catches a variety of forms of bottom and does not generate a value in those cases.
17:26:01 <conal> jabesed: sadly, the implementation is rather tricky. it turned up a few GHC RTS bugs a while back. there could be more issues, but probably not the one you were expecting.
17:28:25 <jabesed> conal: right...  interesting. And indeed any try at arguing that it could do something in the outside world and kill the program doesn'wouldn't hold in haskell since this is just a value being evaluated...
17:29:00 <jabesed> conal: quite interesting
17:33:01 <conal> jabesed: yep. you got it.
17:33:44 <conal> jabesed: for a bigger picture, see the lub module. unamb is just for implementation of lub, and lub is at the heart of the semantics of haskell and other programming languages.
17:34:04 <conal> jabesed: in denotational semantics
17:34:30 <jabesed> conal: yeap
17:36:18 <jabesed> conal: I'm looking at your blog post making use of unamb and lub
17:36:33 <jabesed> lubs*
17:36:41 <conal> jabesed: the one i referred to earlier today? there are others.
17:37:26 <jabesed> conal: yeap
17:37:33 <conal> jabesed: cool. enjoy.
17:38:09 <jabesed> conal: I jumped to the broken isos 2 then back
17:38:16 <jabesed> all quite interesting
17:44:30 <jabesed> conal: what does unamb do with two bottoms though?
17:44:44 <conal> jabesed: denotationally?
17:45:31 <conal> jabesed: what it is, or what it does?
17:45:41 <jabesed> conal: I meant more operationally, denotationally I would guess return bottom
17:46:19 <conal> jabesed: yes, denotationally it's bottom, since unamb is lub on flat types.
17:46:59 <conal> jabesed: operationally, it yields a form of bottom, namely a throw if both throws, and non-termination if either fails to terminate.
17:47:17 <conal> jabesed: iirc
17:47:31 <jabesed> conal: right
17:47:38 <raphie__> does anyone know if there's a way to use mueval (or something like mueval) with a persisted session? I wanna implement a REPL server, so I'd like the ability to "load" a source file and then evaluate expressions based upon it
17:52:41 <conal> jabesed: i'm glad that you're interested in unamb & lub. i think there's enormous untapped potential there for improving the modularity of pure functional programming. a complement to non-strictness.
17:54:24 <jabesed> conal: indeed... I was running my mind searching for possible applications, which I probably shouldn't at this time of the day as that's not going to help me sleep
17:57:24 <HorrendousRex> Hi, I'm brand new to Haskell and trying to bend my head around something. I've got a "[Cell]" value and a function "prettyCell::Cell->String". I know I can concatenate the string values of cells by going "concatMap prettyCell", but what I would like to do is intersperse the cells with the string "|"
17:57:40 <HorrendousRex> This is all by way of writing a function which takes a [[Cell]] game board and prints it in an ascii grid table
17:58:05 <c_wraith> HorrendousRex: there's a function called intercalate in Data.List.  It'll help you out.
17:58:12 <HorrendousRex> c_wraith: thanks!
18:02:19 <HorrendousRex> Hrm, I'm still having trouble bending my head around this one. What I have so far is: "prettyBoard::[[Cell]]->String   \n    prettyBoard = unlines . map (concatMap prettyCell)"  and what I'm trying to do is add pipes around the cells.
18:02:33 <HorrendousRex> I think I'm close but I don't quite know how to 'spell' what I'm trying to do.
18:10:23 <c_wraith> HorrendousRex: replace concatMap with calls to intercalate and map
18:10:54 <c_wraith> > concatMap show [1..0]
18:10:55 <lambdabot>  ""
18:10:59 <c_wraith> err, whoops
18:11:02 <c_wraith> > concatMap show [1..10]
18:11:03 <lambdabot>  "12345678910"
18:11:19 <c_wraith> > intercalate "||" (map show [1..10])
18:11:21 <lambdabot>  "1||2||3||4||5||6||7||8||9||10"
18:14:34 <arancia> > concatMap (\c -> "|" ++ show c ++ "|") [1..10]
18:14:35 <lambdabot>  "|1||2||3||4||5||6||7||8||9||10|"
18:15:09 <HorrendousRex> c_wraith: ok that example works great but I'm realizing that the issue I'm having is that this function ('prettyBoard') is currently in point-free form
18:15:51 <HorrendousRex> and I'm not quite sure how to rewrite it to keep it in point-free form. (is that the right term?)
18:16:33 <HorrendousRex> So essentially where you have 'map show [1..10]' I don't know what to put in the place of [1..10]
18:19:39 * hackagebot egison-tutorial 3.3.6 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.3.6 (SatoshiEgi)
18:20:12 <HorrendousRex> prettyRow row = "|" ++ intercalate "|" (map prettyCell row) ++ "|"      -- there's something that works but isn't in point-free form. Being new to haskell, is this something that I should be OK with?
18:20:19 <HorrendousRex> or should I try to rewrite it in point-free form?
18:20:56 <josephle> whichever is clearer to you 3 days from now
18:21:00 <stephenmac7> Hello, I am using Shelly (https://hackage.haskell.org/package/shelly-1.5.4.1/docs/Shelly.html) and was wondering if there was a way to implicitly convert to Shelly FilePath from a System.FilePath FilePath
18:21:27 <geekosaur> @pl prettyRow row = "|" ++ intercalate "|" (map prettyCell row) ++ "|"
18:21:27 <lambdabot> prettyRow = ('|' :) . (++ "|") . intercalate "|" . map prettyCell
18:21:32 <HorrendousRex> josephle: Should I take that pragmatically or pedagogically? :)
18:21:36 <dwcook> HorrendousRex: point-free should not be a goal. Ease of reading should be.
18:21:38 <geekosaur> is about what I expected
18:22:02 <geekosaur> pointfree has its place. comprehensibility also has its place
18:22:03 <josephle> HorrendousRex: pragmatically until people complain about reading your code :)
18:22:13 <geekosaur> don't write code you won't understand next time you look at it
18:22:14 <HorrendousRex> Ohhhh I see the issue here
18:22:35 <HorrendousRex> ++ takes two arguments, but the partial application in haskell always starts with the first argument
18:22:35 <geekosaur> there's also the Kernighan quote about clever code...
18:22:47 <HorrendousRex> which makes currying up an 'append' difficult, I guess?
18:22:55 <geekosaur> HorrendousRex, did you see my @pl above?
18:22:57 <HorrendousRex> I mean, syntactically troubling.
18:23:08 <HorrendousRex> geekosaur: yeah that's what I'm getting this from.
18:23:10 <geekosaur> operator sections to the rescue, in this case
18:23:29 <josephle> I remember going through my old ML code from uni and seeing a foldr with a comment saying "this code is too clever for me"
18:23:33 <josephle> ...I was right
18:23:50 <HorrendousRex> I suppose what I'm really asking is "Is there a good-looking and readable way to write my prettyRow function other than how I have it now?"
18:24:05 <geekosaur> @where clevercode
18:24:05 <lambdabot> I know nothing about clevercode.
18:24:18 <geekosaur> hm, thought I recorded that somewhere (not as a @quote)
18:24:30 <geekosaur> oh right, wasn't in here
18:24:30 <HorrendousRex> anyway thanks all
18:24:51 <josephle> HorrendousRex: your last snippet of code looked straightforward to me
18:25:04 <HorrendousRex> josephle: good to know. I'm still developing that sense.
18:26:17 <BenedictEggers> "Code is twice as hard to debug as it is to write. So if you write it as cleverly as possible, you are, by definition, not smart enough to debug it."
18:27:01 <geekosaur> main reason for raising that is that something similar applies to just being able to read it later >.>
18:27:12 <BenedictEggers> :)
18:30:05 <HorrendousRex> BenedictEggers: I've found though that you can spend time and thought to write code which is *clear*, which makes it easier to debug later. Spending time on deciding if you've written code the right way doesn't necessarily imply that you're trying to be clever.
18:30:31 <HorrendousRex> This goal is much aided by experience in the language, something I completely lack with Haskell at the moment :)
18:31:13 <BenedictEggers> HorrendousRex: absolutely agree. But I think "clear" and "as clever as possible" are typically mutually exclusive
18:31:18 <Krenium> No two people can ever completely agree on what clear code means.
18:32:17 <HorrendousRex> @pl prettyRow row = intercalate " " ( map prettyCell row)
18:32:18 <lambdabot> prettyRow = intercalate " " . map prettyCell
18:32:38 <HorrendousRex> wrinkling my brain
18:33:06 <MitchellSalad> that's your vanilla f (g a) = f . g!
18:33:36 <HorrendousRex> heh yes
18:33:47 <MitchellSalad> i mean \a -> f (g a) = f . g
18:33:58 <HorrendousRex> the 'wrinkle' I'm referring to is the fact that I've never worked with a language that supports composition as a first-class syntax
18:34:04 <HorrendousRex> lovin' it so far though
18:34:08 <HorrendousRex> but it does take some rethinking
18:34:08 <MitchellSalad> oh
18:34:13 <MitchellSalad> haha
18:34:19 <MitchellSalad> welcome to the club
18:34:23 <HorrendousRex> yup
18:34:27 <poo> is there a way to create multiple haskell states, like if you embed it in C++, with seperate GC etc, or does it rely on global data/functions?
18:34:27 <MitchellSalad> we have donuts
18:36:16 <fread2282> is FRP just a nice abstraction over callbacks?
18:37:31 <fread2282> or rather can it be implemented as one?
18:39:57 <Polarina> fread2282, FRP is somewhat different. You know of pure functions, right? You give a function the same arguments again and you get the same result.
18:40:45 <Polarina> fread2282, so in FRP, rather than the result being the same each time, it can vary over time.
18:41:21 <Krenium> Sorry, very new here, but isn't pureness the reason that haskell can do lazy evaluation?
18:41:23 <fread2282> Polarina: and? I know what FRP is, I just want to know if I can use it to abstract over a lib that uses callbacks
18:42:09 <joelteon> not really
18:42:53 <conal> fread2282: in principle, yes. you'd have to be very careful to match the (well-defined) semantics of FRP.
18:43:10 <Polarina> Krenium, it's all pure deep down, it's just an abstraction (a library) on top of it.
18:43:47 <HorrendousRex> If I declare a data type (hope that's the right word) like "data Foo = Bar | Baz | Boff", is there a way to write a function which creates a value of one of those types *at random*?
18:44:02 <HorrendousRex> sorry if the words I am using are inaccurate, please do correct me.
18:44:24 <raphie__> sorry to ask this again, but is there a way to run something like mueval / hint / lambdabot with a "loaded file"?
18:44:45 <conal> Krenium: pureness is what enables changing evaluation order without changing denotation/semantics. one could do lazy evaluation w/o purity, but the results would be hard to predict.
18:44:57 <Polarina> HorrendousRex, take a look at the Random typeclass. http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html
18:47:11 <HorrendousRex> Polarina: thanks, how would I instantiate my 'Foo' data type as a Bounded so that it can be used by Random.random ?
18:48:30 <Polarina> HorrendousRex, derive it.  data Foo = Bar | Baz | Boff deriving (Bounded)
18:48:42 <HorrendousRex> Woh, that's some magic.
18:48:51 <HorrendousRex> Ok, cool! Thanks.
18:48:58 <RyanGlScott> My code keeps getting the warning "Pattern match(es) are overlapped In an equation for ‘interpBind’: interpBind other k env = ...", and I'm not sure why.
18:48:59 <RyanGlScott> http://lpaste.net/107634
18:49:19 <dwcook> HorrendousRex: note that the docs don't say you actually need Bounded, just that if there is a Bounded instance available the Random instance usually behaves a certain way.
18:49:31 <RyanGlScott> It seems like the most general case is last, but I could be wrong.
18:49:55 <HorrendousRex> dwcook: oh, I missed that, thanks!
18:51:27 <carter> poo: i think so
18:51:41 <carter> poo: .... mind you, you'd be breaking new ground
18:52:10 <HorrendousRex> Sorry for the rapid-fire questions. I'm a bit tired of typing "Just (Ship Carrier)" a lot (I'm writing a Battleship game). I'd like to replace it with something like "SC". I tried using "type SC = Just (Ship Carrier)" but that appears to be invalid.
18:53:07 <RyanGlScott> HorrendousRex: I think you could use PatternSynonyms to do something like that https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
18:53:12 <raphie__> another way to phrase my repl question, is there anything you could wrap an arbitrary string of haskell in that would allow subsequent lines of haskell to evaluate using the functions defined in this string?
18:53:20 <Iceland_jack> HorrendousRex: wait is that a type or a term?
18:53:35 <Iceland_jack> Just is a term-level function but 'type' is only for types
18:53:50 <HorrendousRex> Iceland_jack: I'm still very new, and unsure how to answer your question.
18:53:52 <RyanGlScott> Perhaps, pattern SC = Just (Ship Carrier)
18:54:02 <HorrendousRex> RyanGlScott: that looks promising
18:54:12 <Iceland_jack> RyanGlScott: HorrendousRex doesn't need extensions (PatternSynonyms) at this point
18:54:23 <HorrendousRex> That also sounds correct. :)
18:54:29 <Iceland_jack> HorrendousRex: Best to stick to the basics :)
18:54:37 <RyanGlScott> Is there a better way of doing it? Genuinely curious.
18:54:52 <dwcook> RyanGlScott: Did you pass any warning flags by any chance? I don't think that overlap is harmful
18:54:55 <Iceland_jack> RyanGlScott: for terms? defining it as a variable, for types? type synonyms
18:55:23 <Iceland_jack> HorrendousRex: Can you lpaste your code so far?
18:55:26 <Iceland_jack> @where lpaste
18:55:26 <lambdabot> http://lpaste.net/new/haskell
18:55:46 <dwcook> RyanGlScott: By the way, I notice your structure could probably be readily phrased in terms of Free, and then you'd get a free interpreter as well.
18:55:48 <RyanGlScott> dwcook: -Wall, -fno-warn-orphans
18:56:04 <RyanGlScott> dwcook: Actually, it's not "my" code, just code that I'm working with
18:56:38 <dwcook> Or I should say, at least, you wouldn't have to worry about return and bind
18:57:05 <HorrendousRex> http://lpaste.net/107635
18:57:46 <Iceland_jack> HorrendousRex: okay, 'Just (Ship Patrol)' is a term so you can't use type for that
18:58:04 <HorrendousRex> Is there some way I can avoid typing out the full term?
18:58:07 <Iceland_jack> you can however do
18:58:08 <Iceland_jack>     sp :: Maybe Ship
18:58:08 <Iceland_jack>     sp = Just (Ship Patroler)
18:58:08 <dwcook> HorrendousRex: instead of type you just want a regular definition. Lowercase the names, take out "type", and you're good to go
18:58:10 <HorrendousRex> maybe... just a function?
18:58:12 <HorrendousRex> ahhh.
18:58:30 <Gurkenglas> Yep, a function with 0 arguments, also known as a variable
18:58:33 <HorrendousRex> do you need the type declaration in this case?
18:58:44 <Gurkenglas> Well, except its not variable...
18:58:47 <Iceland_jack> no, and you don't think of it as a function of 0 arguments
18:58:51 <Iceland_jack> not in Haskell
18:58:56 <Gurkenglas> You don't?
18:58:59 <Iceland_jack> And it is certainly a variable
18:59:13 <Gurkenglas> But you can't change it. It's not variable.
18:59:18 <dwcook> Every function takes exactly one parameter. If it doesn't, it's not a function.
18:59:19 <Iceland_jack> Gurkenglas: If you disagree you can read the Haskell standard
18:59:22 <Iceland_jack> :)
18:59:30 <Iceland_jack> sorry too lazy to take this
18:59:39 <Gurkenglas> Haskell standard?
18:59:47 <Gurkenglas> Why wasn't I told of this
18:59:56 <Iceland_jack> You can search for 'Haskell standard variable' or check StackOverflow
18:59:56 <dwcook> The Haskell 2010 Report, specifically
19:00:11 <Iceland_jack> Gurkenglas: Because you think that 'variable' means the same as 'mutable reference' in C maybe?
19:00:49 <Gurkenglas> Well first I was thinking of variable as a name with a value, but then I thought it maybe shouldn't be called variable because it's not vary-able
19:01:00 <Iceland_jack> Right, that's understandable
19:01:03 <Iceland_jack> Variables are also called variables in mathematics
19:01:09 <dwcook> Mathematical variables don't "vary" in that sense either ;)
19:01:12 <Iceland_jack> where they certainly vary but are not mutable
19:02:34 <Gurkenglas> (<Gurkenglas> Well, except its not variable... <- note how there's no a)
19:03:20 <RyanGlScott> dwcook: Er, wait. Actually, this is in a test-suite, so there are no flags.
19:03:21 <dwcook> I see your point
19:03:33 <RyanGlScott> I think
19:03:43 <Iceland_jack> Well you can vary 'x' in
19:03:43 <Iceland_jack>     f x = x
19:03:43 <Iceland_jack> by presenting 'f' with different arguments
19:03:44 <Iceland_jack> @google stackoverflow does haskell have variables
19:03:45 <lambdabot> http://stackoverflow.com/questions/993124/does-haskell-have-variables
19:03:45 <lambdabot> Title: Does Haskell have variables? - Stack Overflow
19:03:45 <dwcook> RyanGlScott: Dunno. Either way, It doesn't seem to me to be important that it overlaps.
19:06:19 <dwcook> Iceland_jack: It certainly makes sense there, but to roll with the question, what if it's a module-level definition? Those don't "vary" in the sense you just showed.
19:06:34 <RyanGlScott> dwcook: Ah, testing it with -Wall reveals that there are non-exhaustive pattern matches, so maybe that has something to do with it.
19:06:37 <Iceland_jack> Do you mean a top-level definition?
19:07:08 <dwcook> Iceland_jack: I don't know if that's the term used for it, but surely there's nothing more "top" than module-level?
19:07:49 <Iceland_jack> Sure, but the variables within a function defined at top-level can be varied in the same way as I mentoined above
19:08:11 <Iceland_jack> but variables are also called variables in the untyped lambda calculus and there is no mutability there
19:08:15 <dwcook> No, not a function parameter of a top-level definition, the top-level definition itself.
19:08:41 <Iceland_jack> The top-level definition is not a variable but a definition
19:08:55 <dwcook> There we go, that is the answer I sought.
19:09:14 <Iceland_jack> Ah sorry for being obtuse
19:09:35 <dwcook> Don't worry, I was probably not communicating myself well.
19:10:43 <Gurkenglas> Oh, so the things I saw as "0-argument functions" or "variables" are actually "definitions", kay.
19:11:12 <Iceland_jack> Constants are sometimes called 0-argument functions, for example in logic to simplify things
19:11:35 <Iceland_jack> but that just makes the terminology in Haskell needlessly complicated
19:12:30 <dwcook> Almost always when we say "function" in Haskell we're talking about a value whose type is constructed with (->). And when we're not, we're being imprecise. :P
19:12:42 <Gurkenglas> I find it makes it less complicated... in the sense that turing machines implementing that version tend to be shorter
19:13:12 <dwcook> Gurkenglas: You find what makes what less complicated?
19:13:16 <Iceland_jack> Well if you want to call something like a string "Hello" a function, how would you apply it to soemthing?
19:13:29 <dwcook> Oh, there's a good post this reminds me of
19:13:37 <Iceland_jack> And if you do consider it a function that you can't apply to something, what should we call such a thing?
19:13:38 <HorrendousRex> Is there a way to simplify 'shipSize', probably with guards? http://lpaste.net/107636
19:13:43 <dwcook> http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:13:53 <Iceland_jack> Yes Conal wrote some good stuff on this
19:14:21 <Gurkenglas> Having all definitions be functions with a number of arguments in {0,1,2,...}, rather than distinguishing between function with a number of arguments in {1,2,...} and non-function definitions
19:14:22 <Iceland_jack> HorrendousRex: Except for deriving Enum, this is about the simplest way you can define that
19:14:46 <HorrendousRex> Iceland_jack: I'm not sure if Enum would work since Destroyer and Sumbarine share a size.
19:14:48 <dwcook> Gurkenglas: You can think of n-parameter functions in other languages as being functions that accept an n-tuple.
19:15:08 <Iceland_jack> HorrendousRex: You could implement it in terms of Enum, it would just have to be more complicated
19:15:15 <dwcook> You can do the same in math, for that matter.
19:15:15 <Gurkenglas> So constants would be functions that accept the empty tuple.
19:15:37 <dwcook> E.g., * : Z × Z → Z
19:15:41 <HorrendousRex> Got it, thanks again Iceland_jack
19:15:54 <dwcook> Where Z × Z is the cartesian product of Z with Z
19:16:03 <Gurkenglas> (Or give me a better term for what I just called constant; I was meaning to say "those definitions that are not functions with 1+ arguments")
19:16:10 <dwcook> Or, er, I might have my terminology slightly off
19:16:29 <Gurkenglas> dwcook, yup, and the cartesian product can be defined on any family of sets
19:16:49 <Gurkenglas> Particularly the empty family.
19:17:45 <Iceland_jack> Yes but in Haskell that would be different, since you'd actually apply it to the unit type ()
19:17:49 <dwcook> I wouldn't want to call constants *the same* as functions taking (), but there's an isomorphism between those anyway.
19:17:57 <Iceland_jack> then the character 'a' would have type
19:17:57 <Iceland_jack>     'a' :: () -> Char
19:18:32 <Gurkenglas> In the same way that a->b->c would have to be changed to (a,b)->c, yes.
19:18:32 <Iceland_jack> this is what is done in category theory
19:18:38 <Iceland_jack> no not in the same way
19:18:46 <conal> "constants" is a misleading term as well, since all pure values are constant.
19:18:50 <dwcook> to :: forall a. a -> (() -> a) ; to = const ; from :: forall a. (() -> a) -> a ; from = ($ ())
19:18:59 <Gurkenglas> conal, give me a better word
19:19:10 <dwcook> (Ignoring bottom)
19:19:20 <conal> Gurkenglas: for what. do you mean a definition or a name or a thing being named, or ???
19:19:31 <Gurkenglas> conal, what should I have said instant of constant?
19:19:35 <Gurkenglas> *instead
19:19:44 <Gurkenglas> Damn brain-autocorrect
19:19:45 <conal> Gurkenglas: it depends what you're trying to express.
19:19:50 * hackagebot matchers 0.20.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.20.0.0 (OmariNorman)
19:19:54 <Gurkenglas> Definitions that are not functions with 1+ arguments.
19:20:09 <conal> Gurkenglas: they're definitions.
19:20:12 <dwcook> Definitions of non-functions :P
19:20:26 <glguy> all functions have "1+" arguments
19:20:34 <Gurkenglas> I'm trying to argue that they can also be seen as functions, which is why I was trying to find a more neutral term
19:20:35 <conal> Gurkenglas: ^^ what dwcook said, if you want to be more specific
19:21:02 <conal> Gurkenglas: no definitions are functions. they're entirely different kinds of things.
19:21:29 <conal> Gurkenglas: one is about type, and the other about naming.
19:21:49 <conal> i've long wondered why people want to use "function" to mean definition.
19:21:49 <glguy> conal: this is about the point that I'd share your blog post
19:21:49 <Gurkenglas> Iceland_jack, you came up with that "definition" word, work this out
19:22:34 <conal> glguy: [19:11:25]  <dwcook>	 http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:22:51 <glguy> dwcook: Looks like I joined about 1 minute too late :)
19:22:52 <conal> glguy: and yeah. thanks.
19:23:09 <dwcook> Haha
19:23:11 <conal> i wrote that post because these confusions are so varied and persistent.
19:23:13 <Gurkenglas> Well that's exactly what I was talking about. Faldjsgbaedfhbgf
19:23:19 <conal> glguy: :)
19:23:30 <HorrendousRex> How would I go about making a list which repeats a given value N times?
19:23:38 <Iceland_jack> HorrendousRex: replicate
19:23:40 <Iceland_jack> @ty replicate
19:23:41 <lambdabot> Int -> a -> [a]
19:23:42 <HorrendousRex> thanks.
19:23:51 <Iceland_jack> > replicate 20 'a'
19:23:53 <lambdabot>  "aaaaaaaaaaaaaaaaaaaa"
19:24:03 <conal> often i suspect that the function/non-function discussion is missing the deeper confusion between definitions and the things getting named.
19:24:39 <conal> for instance, "f x = x" is not a function any more than "y = 3" is. they're both definitions.
19:25:24 <Gurkenglas> Can you give an example of a function, then?
19:25:53 <conal> Gurkenglas: sin, (+), \ x -> x
19:26:02 <glguy> in the above case "f"
19:26:23 <Gurkenglas> Alrighty, understood. Now to be happy until the next guy comes in and says that I've got it all wrong ^^
19:26:38 <conal> Gurkenglas: :)
19:26:48 <Iceland_jack> Gurkenglas: Funny if it weren't true :)
19:27:02 <conal> glguy: careful, though. i'd say that f is the function, and "f" is the name. slippery.
19:27:10 <dwcook> Gurkenglas: the common thread between those is the (->) type constructor
19:27:12 <dwcook> @type sin
19:27:13 <lambdabot> Floating a => a -> a
19:27:15 <dwcook> @type (+)
19:27:16 <lambdabot> Num a => a -> a -> a
19:27:16 <dwcook> @type id
19:27:18 <lambdabot> a -> a
19:28:05 <dwcook> If it's not constructed with (->), it's not a function.
19:28:10 <glguy> conal: The "s separate code from English in that sentence. If we're going to go nuts I'd tell you that "f" was merely a String :-p
19:28:32 <conal> glguy: yeah. hah. slippery.
19:29:05 <conal> glguy: i would have let it go, but it begs adding more confusion.
19:29:56 <dwcook> We could also say the things above are actually expressions evaluating to functions, but I'm not going to *actually* insist on that :P
19:30:17 <dwcook> Although a value is just a fully evaluated expression, isn't it?
19:30:23 <glguy> We have to go *deeper*
19:30:30 <dwcook> Wait, no
19:30:34 <Iceland_jack> What are mathematical objects anyway
19:30:35 <dwcook> Because lazy evaluation!
19:30:41 <BenedictEggers> is math even real?
19:30:42 <BenedictEggers> probably not
19:30:45 <dwcook> BenedictEggers++
19:30:55 <Iceland_jack> That answers that question :)
19:31:05 <ddellacosta_> wait, that math argument on twitter hasn't gotten here has it
19:31:11 <BenedictEggers> wait, maybe math is lazy evaluated
19:31:12 <dwcook> ddellacosta_: which?
19:31:12 <Gurkenglas> conal, I am of the "It makes things simpler
19:31:12 <Gurkenglas> " crowd. One of your rejections is that you don't find Integer === () -> Integer === () -> () -> Integer ===  simple, right?
19:31:17 <BenedictEggers> so it doesn't exist until we try to see what it is
19:31:22 <BenedictEggers> :|
19:32:02 <conal> Gurkenglas: more that it doesn't answer the question.
19:32:12 <ddellacosta_> dwcook: don't know how to point you to a single tweet, but I guess this post started it: http://www.sarahmei.com/blog/2014/07/15/programming-is-not-math/
19:33:08 <ddellacosta_> damn, actually sorry I brought it up.  Forget I said anything.  Go back to being #haskell
19:34:01 <Javran> just wondering why isn't set a monad? it looks awkward to write lists like `liftM nub $ do { ... }`
19:34:11 <conal> to me, math means precision & rigor. when a programmer says "programming is not math", i know that *their* programming isn't.
19:34:19 <Gurkenglas> Oh, I thought that part with the "Why not lists, or trees" was a second rejection. I would reject collapsing all onto trees, or lists, because you can "construct" trees and lists from functions, but you can't "construct" functions from variables.
19:34:22 <conal> it's a sort of self-fulfilling prophecy.
19:34:33 <johnw> Javran: it can be a restricted monad
19:34:46 <johnw> Javran: but Monad does not allow constraints on return or >>=
19:35:19 <Gurkenglas> (Or whatever the correct word for variables is now.)
19:35:20 <dwcook> ddellacosta_: I understand this person's viewpoint to a degree but find it funny from a perspective of having done Haskell that this person considers Fortran mathy.
19:35:20 <conal> Gurkenglas: variables are syntax. functions, trees, lists, etc are semantics.
19:36:12 <conal> Gurkenglas: one can say that [Int] is a 1-level list, [[Int]] a 2-level list, etc, and then Int a 0-level list. so that everything is a "curried" list. i don't recommend it.
19:36:13 <ddellacosta_> dwcook: heh. Yeah, I mean, I think the whole thing starts from a weird place.  And the conversation that ensued on twitter was absurd too.
19:36:24 <RyanGlScott> Is there any point to exporting things in the Main module of an executable?
19:37:08 <Javran> johnw: If I understand it correctly, it'll be impossible to remove duplicates inside the do notation?
19:37:18 <enthropy> RyanGlScott: if you want to load Main as compiled code in ghci, and call some functions besides main
19:37:22 <dwcook> RyanGlScott: Well you'll want to export main. Other than that, it's up to you.
19:37:31 <johnw> Javran: I don't know what you mean
19:37:41 <johnw> Javran: Set places an Ord constraint on the types it contains
19:38:00 <conal> Gurkenglas: these "curried lists" (etc) make for a better parallel to "0-ary functions".
19:38:11 <Gurkenglas> Oh. Hm. Now my intuition is telling me to adopt that abstraction, for lists and trees and all structures, and now it's telling me to find all possible structures.
19:38:14 <conal> Gurkenglas: i.e., better than the parallel i proposed in the post.
19:38:14 <Gurkenglas> What have you done?
19:38:18 <RyanGlScott> So would it be good practice to export functions in Main if there are internally used functions as well?
19:38:37 <conal> Gurkenglas: glad to hear it!
19:38:49 <Iceland_jack> Gurkenglas: Also, would that intuition extend to the type level? Are Bool and Integer type-level function?
19:39:12 <Iceland_jack> and then extending one level above that? (kinds) and then to sorts ....
19:39:15 <conal> Iceland_jack: and type-level trees/lists/...
19:39:20 <Iceland_jack> yes
19:39:29 <Gurkenglas> And all the way up the ladder of ordinal numbers, yes.
19:39:57 <glguy> Javran: To explore why Set isn't a monad for yourself, try to implement a Functor instance for it
19:40:16 <RyanGlScott> Javran: There's also this https://www.fpcomplete.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor
19:40:20 <glguy> It's a smaller exercise and you'll experience the same issue
19:40:55 <dwcook> I think there is a difference between the "A is actually () -> A" perspective and the "A is actually [A]" one: The former, outside of Haskell, has a corresponding isomorphism while the latter does not.
19:41:24 <dwcook> Might be an unimportant difference though.
19:41:45 <dwcook> (I'm not espousing either as a way of reasoning about a program)
19:42:02 <Gurkenglas> A isn't [A], it's [[[[....[[[A]]]....]]]] with 0 opening brackets.
19:42:23 <dwcook> Well sure, because if we set A = [A] then we get that. :)
19:42:26 <Iceland_jack> dwcook: Yes but the mistake is not differentiating between 'this is' and 'this is isomorphic to/may be interpreted as' just like viewing Bool as a coproduct of two units isn't a rewarding point of view
19:42:29 <HorrendousRex> Is there a way to pattern match a function in such a way that if one of the arguments specifies a list's "array index" which is out of bounds, it won't match?
19:43:20 <Gurkenglas> There is no type such that A=[A], just like there is no barber that shaves all but those that don't shave themselves.
19:43:42 <glguy> f x | 0 <= x && x < length somelist = ...    might be what you meant
19:43:45 <Javran> RyanGlScott: glguy: so set is not even a functor because there
19:43:57 <Iceland_jack> Gurkenglas: That's not the same, you can write effectively that
19:43:59 <johnw> Javran: Set is not a functor either
19:44:10 <Iceland_jack> using
19:44:10 <Iceland_jack>     newtype Fix f = Fix (f (Fix f))
19:44:11 <Javran> is no way to have a fmap where `fmap (g . f) = fmap g . fmap f` ?
19:44:17 <johnw> Javran: not a law-abiding one, no
19:44:34 <johnw> see https://www.fpcomplete.com/user/chad/snippets/random-code-snippets/set-is-not-a-functor
19:45:22 <Gurkenglas> Oh, I thought types had that "recursive finitehood" property or whatchacall it that separates sets from classes.
19:45:36 <Iceland_jack> no Haskell isn't logically sound :)
19:46:12 <Iceland_jack> you can create 'falsehood' (bottom) with
19:46:12 <Iceland_jack>     x = x
19:46:22 <Gurkenglas> Oh boy that does make things complicated.
19:46:33 <Iceland_jack> Not really
19:46:34 <dwcook> You can often ignore its unsoundness in practice, fortunately
19:46:52 <Gurkenglas> Sooo types aren't on the ordinal hierarchy, but instead in a... category?
19:46:59 <dwcook> Not quite that either
19:47:04 <Iceland_jack> those things aren't really related
19:47:10 <dwcook> We often speak of Haskell as a category but it's not
19:47:19 <Gurkenglas> No I mean arghgh
19:47:25 <Iceland_jack> Program in a theorem prover and you might appreciate Haskell being unsound :)
19:47:47 <dwcook> http://www.haskell.org/haskellwiki/Hask#Is_Hask_even_a_category.3F
19:48:03 <Gurkenglas> I meant more that you can't place them on the ordinal hierarchy, so you leave out the hierarchy part and it collapses into a mush that happens to still be able to be organized into a category
19:48:23 <Iceland_jack>     [] ≅ Fix [] ≅ [Fix []] ≅ [[Fix []]] ≅ …
19:48:40 <Gurkenglas> And the "makes things complicated" meant me momentarily trying to fix it by inserting a better hierarchy.
19:48:47 <Iceland_jack> ah sure
19:49:18 <Gurkenglas> Wait that rambling was legible!?
19:49:29 <Iceland_jack> I thought so :)
19:50:42 <Javran> I'm convinced set is not a functor, but what is the idomatic way to remove duplicates from a list comprehension / do notation?
19:51:32 <Javran> or simply using `liftM nub $ do { ... }` is fine
19:52:40 <dwcook> That looks fine to me, although throwing the results into a Set could also make sense
19:53:07 <dwcook> Considering your liftM isn't actually acting on the list you're nubbing, you could easily replace the list with a Set
19:53:17 <dwcook> I phrased that poorly
19:53:56 <dwcook> Monad [] is not what's required here (unless the do expression just happens to be for [] as well), so you could replace the list with a Set
19:55:03 <dwcook> @type liftM nub
19:55:04 <lambdabot> (Monad m, Eq a) => m [a] -> m [a]
19:55:12 <dwcook> ^ I should've done that in the first place
19:55:39 <Javran> dwcook: I usually use that to implement a BFS, so I can have a f :: a -> [a], and `iterate f initStates` will give me each generation of the states.
19:56:17 <dwcook> I don't know what a BFS is, but, what, you're basically doing concatMap and nub at each step?
19:56:19 <Javran> ops, that should be iterateM or something like that
19:56:53 <dwcook> ((>>=) for [] is (except for the argument order) concatMap)
19:56:54 <Javran> I meant breadth first search
19:57:14 <dwcook> Right, I think I understood you even if I'm not communicating clearly right now :)
19:57:19 <Javran> dwcook: sure I'm actually using concatMap
19:57:41 <Javran> dwcook: sorry for my poor English :(
19:57:56 <dwcook> No, you were fine, I just needed you to expand the initialism since I don't usually see that one.
19:58:10 <Javran> dwcook: I see
19:59:39 <dwcook> Javran: Was there something else you needed answered, or did I answer it already?
20:00:42 <Javran> dwcook: I think you've answered that, I asked is `liftM nub` looks good.
20:01:06 <dwcook> Okay.
20:01:50 <Javran> another question: I heard functors are "structure preserving", but how does `fmap (g . f) = fmap g . fmap f` reflect this?
20:02:17 <Iceland_jack> Because it preserves composition
20:02:25 <Iceland_jack> just like
20:02:26 <Iceland_jack>     fmap id = id
20:02:26 <Iceland_jack> preserves identities
20:02:31 <wertyy102> grep
20:03:03 <Iceland_jack> and
20:03:04 <Iceland_jack>     fmap f :: F a -> F b
20:03:04 <Iceland_jack> preserves domains and cocomains for 'f :: a -> b'
20:04:30 <Javran> Iceland_jack: I see, thanks
20:04:33 <Iceland_jack> *codomains
20:05:47 <Javran> :t (g . f) `on` fmap
20:05:48 <lambdabot>     Could not deduce (Typeable f0) arising from a use of ‘g’
20:05:48 <lambdabot>     from the context (FromExpr c, Typeable b, Typeable a)
20:05:49 <lambdabot>       bound by the inferred type of
20:06:10 <Javran> :t ( (.) `on` fmap) g f
20:06:11 <lambdabot> (FromExpr a, Show a, Functor f) => f a -> f a
20:06:47 <Iceland_jack> :t fmap (?g . ?f)
20:06:48 <lambdabot> (?g::b1 -> b, ?f::a -> b1, Functor f) => f a -> f b
20:06:54 <Iceland_jack> :t fmap ?g . fmap ?f
20:06:56 <lambdabot> (?g::a -> b, ?f::a1 -> a, Functor f) => f a1 -> f b
20:10:25 <Javran> I see, `on` puts too much constraint on type
20:10:48 <Iceland_jack> You can use asAppliedTo
20:11:20 <Iceland_jack> :t fmap `asAppliedTo` (?g . ?f)
20:11:21 <lambdabot> (?g::b1 -> b, ?f::a -> b1, Functor f) => (a -> b) -> f a -> f b
20:11:27 <Javran> @hoogle asAppliedTo
20:11:28 <lambdabot> No results found
20:11:32 <Iceland_jack> :t (fmap `asAppliedTo` ?g) . (fmap `asAppliedTo` ?f)
20:11:33 <lambdabot> (?g::f1 a -> f1 b, ?f::a -> b, Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:12:14 <Javran> Iceland_jack: but I can't find the function
20:12:18 <Javran> @src asAppliedTo
20:12:19 <Iceland_jack> You can define
20:12:19 <Iceland_jack>     a `asTypeIn` f = a where _ = f a
20:12:19 <Iceland_jack> and
20:12:19 <Iceland_jack>     a `asAppliedTo` x = f `asTypeIn` (\g -> g x)
20:12:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:12:19 <dwcook> @type on
20:12:20 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
20:12:29 <dwcook> Javran: The problem is function parameters are by default monomorphic. You'd have to write an explicit forall in on's type to compose two different instantiations of fmap together.
20:12:29 <Iceland_jack> It's not a standard function
20:12:53 <Javran> I see, thanks!
20:13:24 <dwcook> Or, hrm, would even that work?
20:13:30 * dwcook tries
20:16:50 <Javran> Iceland_jack: "f" is not in scope for asAppliedTo
20:17:02 <dwcook> Hrm, well the first part of what I said is true. Unfortunately I'm having trouble figuring out proper type signature to demonstrate what I wanted to say.
20:17:13 <dwcook> +a
20:17:15 <Iceland_jack> Javran: I mistyped, it should be
20:17:16 <Iceland_jack>     f `asAppliedTo` x = …
20:18:10 <Javran> Iceland_jack: I see, now it works
20:18:56 <dwcook> Is there a possible type for (\f -> f . f) such that ((\f -> f . f) fmap) type checks?
20:19:14 <dwcook> (Including extensions)
20:19:44 <jle`> :t fmap . fmap
20:19:44 <Iceland_jack> You can emulate it using newtypes but otherwise no
20:19:45 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:19:51 <Iceland_jack> :t (\f -> f . f) fmap
20:19:52 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f0 a
20:19:53 <lambdabot>     Expected type: (a -> b) -> a -> b
20:19:53 <lambdabot>       Actual type: (a -> b) -> f0 a -> f0 b
20:19:59 <jle`> sounds too infinite to me
20:20:04 <jle`> yea
20:20:15 <dwcook> I just don't quite see why fmap . fmap should be fine but that not
20:20:34 <dwcook> I mean, I understand why its inferred type is inadequate
20:20:38 <Iceland_jack> dwcook: check the type of '\f -> f . f'
20:20:40 <jle`> because both fmaps are of different types
20:20:45 <jle`> in fmap . fmap
20:20:47 <dwcook> Right, I get that
20:20:55 <Iceland_jack> It's first argument is (a -> a)
20:20:56 <Iceland_jack> *Its
20:21:01 <dwcook> See what I just said
20:21:23 <Iceland_jack> Well that's the reason
20:21:29 <jle`> you can't use the same f as two different types
20:21:29 <dwcook> But I don't see why it's not typeable *at all*, even with explicit forall
20:21:33 <jle`> hm
20:22:10 <dwcook> Because with an explicit forall, you can use the same f at two different types
20:22:53 <Iceland_jack> You can't have 'a = f a' where f is a Functor
20:22:57 <Iceland_jack> essentially
20:23:10 <dwcook> A simple example would be (\a b -> (show a, show b)) :: (forall s. s -> String) -> a -> b -> (String, String)
20:23:17 <dwcook> Iceland_jack: okay, why is that then?
20:23:23 <dwcook> Woops
20:23:26 <dwcook> I misthought that
20:23:35 <dwcook> A simple example would be (\f a b -> (f a, f b)) :: (forall s. s -> String) -> a -> b -> (String, String)
20:23:38 <dwcook> Where f could be show
20:23:46 <dwcook> I should go to bed -_
20:23:47 <dwcook> -
20:23:53 <Iceland_jack> Same here :)
20:24:56 <enthropy> dwcook: http://lpaste.net/107641 ?
20:25:37 <dwcook> enthropy: Doesn't really answer my question, but interesting nonetheless
20:26:05 <enthropy> it is a (\f -> f . f) such that ((\f -> f . f) fmap) type checks
20:26:18 <dwcook> I don't actually have a practical reason for wanting to type my example, I just don't don't whether it's typeable
20:27:14 <dwcook> enthropy: Oh, I suppose it does.
20:27:37 <dwcook> I think there must have been a different question I meant to ask though. But I should probably go to bed now. Thanks.
20:27:40 <dwcook> Good night~
20:33:33 <gfixler> If I write a recursive function with a where clause, does the where clause evaluate for every recursion?
20:34:45 <c_wraith> gfixler: maybe, maybe not.
20:35:02 <c_wraith> gfixler: depends on a bunch of factors.
20:36:26 <Athas> Is it possible to place class constraints on a type family?  I.e. define a family 'F', such that any instance for 'F A' must be an instance of some class C?
20:36:36 <c_wraith> gfixler: if it's important that it not be recomputed, it's best to restructure the calculation so that it can't be - usually with some sort of worker/wrapper transformation
20:36:59 <c_wraith> Athas: no, that's not possible.
20:37:28 <Athas> c_wraith: accursed.  Our of curiosity, do you know whether this is due to some fundamental issue?
20:37:57 <gfixler> c_wraith: thanks - that's a bit more complicated an answer than I expected, but it means I need to beware
20:38:41 <c_wraith> Athas: It's mostly implementation issues, I believe. Things like class instances are actually values in GHC's core language and are passed around like any other value - which puts them outside of what type families can do.
20:39:44 <c_wraith> gfixler: in simple cases, GHC will probably do the right thing. But sometimes it won't, especially as cases get more complicated. When that happens, you can write the code so that the sharing is explicit, instead of depending on GHC's optimizer to find it.
20:40:45 <gfixler> c_wraith: if the answer was a sound "no, it always evaluates once," then I'd go with it, but as it can, I must avoid it
20:41:11 <enthropy> Athas: you can define two duplicate instances in separate modules, and that lets you do stuff like constructing an invalid Set. If that was allowed with type families the same incoherence can give you an unsafeCoerce
20:41:51 <c_wraith> enthropy: I still don't understand why GHC chose to allow that, despite being a violation of the language spec.
20:43:07 <enthropy> well even without that decision you'd still have -XOverlappingInstances leading to the same situation
20:43:39 <c_wraith> At least in that case you'd specified you want chaos. :)
20:44:46 <enthropy> I think -Wall saves you
20:45:04 <EvanR> shows over folks
20:45:13 <EvanR> types considered harmful http://www.cis.upenn.edu/~bcpierce/papers/harmful-mfps.pdf
20:45:19 <enthropy> rather -fwarn-orphans -Werror
20:59:49 <notori0us> nice to see everyone who I did see at the boston haskell meetup this evening
21:07:13 <djahandarie> notori0us, :)
21:09:34 <notori0us> djahandarie: it was a good time! ven if some of it was very deep" down the rabbit hole"
21:12:27 <djahandarie> notori0us, that's edwardk for you.
21:14:55 <djahandarie> He's like diet-coke-powered oil rig when it comes to digging rabbit holes.
21:15:24 <notori0us> haahahhaah
21:16:38 <Noitanigami> Does anyone know of any tutorials/examples for getting framed data (video) input?
21:17:52 <enthropy> Noitanigami: you mean something like https://github.com/acowley/HOpenCV/blob/master/src/Examples/VideoFunhouse/VideoFunhouse.hs ?
21:24:29 <HorrendousRex> The "Learn You a Haskell" book creates a function "x -: f = f x  " to make it easier to apply sequences of invocations without nesting parenthesis... is there something like this in prelude?
21:24:47 <HorrendousRex> Would it be a bad idea to just define that if I want it?
21:24:48 <PotatoGim> Hi
21:26:32 <jle`> HorrendousRex: it's really against normal style conventions
21:26:41 <jle`> sorry
21:26:50 <HorrendousRex> parenthesis nesting is the idiomatic approach? no prob, good to know!
21:26:53 <jle`> nothing is stopping you though, you just won't be writing idoimatic code
21:26:57 <jle`> HorrendousRex: not necessarily
21:27:01 <jle`> it depends on the situation
21:27:08 <jle`> you usually won't have many parentheses nested in real life
21:27:17 <jle`> you might break off components and name them
21:27:23 <HorrendousRex> in this case I have a number of functions which take some number of arguments and then a "board" and then return a new board
21:27:48 <HorrendousRex> so the syntax would be nice
21:27:51 <jle`> also the more non-idiomatic thing about x -: f is that function application is backwards, which is only normal in certain situations.  we prefer forward function application
21:27:58 <jle`> HorrendousRex: can you paste your actual call?
21:28:15 <HorrendousRex> sure let me get it working and I'll pastebin it in a second
21:28:41 <Noitanigami> enthropy: thank you. This is good.
21:28:58 <carter> johnw: HorrendousRex  # in diagrams/lens does that
21:29:01 <carter> i think
21:29:04 <carter> jle`:
21:29:08 <carter> :t (#)
21:29:09 <lambdabot> parse error on input ‘)’
21:29:21 <enthropy> @type (&)
21:29:22 <lambdabot> a -> (a -> b) -> b
21:29:23 <jle`> (&) from lens
21:29:35 <jle`> (#) from diagrams
21:29:45 <jle`> but i like ot think of them as a part of their respective dsls
21:30:03 <HorrendousRex> I'm totally new to lens and diagram :)
21:30:04 <carter> both are valid
21:30:07 <jle`> you wouldn't use (#) or (&) outside of lensy/diagramsy code
21:30:19 <carter> unless you wanted to
21:30:29 <jle`> well you can do anything you want ;)
21:30:57 <jle`> i think he is asking about style conventions
21:30:57 <carter> exactly :)
21:31:02 <carter> well
21:31:09 <carter> theres no one true style
21:31:10 <carter> try ideas
21:31:15 <carter> and read other peoples codes both
21:32:24 <HorrendousRex> jle`: http://lpaste.net/107642
21:32:34 <HorrendousRex> jle`: line 64 has the call I'd like to sugar-up a bit
21:32:42 <HorrendousRex> because it will grow much larger
21:33:02 <jle`> you can write that as a fold
21:33:18 <HorrendousRex> would you mind elaborating?
21:33:24 <jle`> have you learned about folds?
21:33:26 <jle`> foldr/foldl'
21:33:37 <jle`> > foldr (+) 0 [1,2,3]
21:33:39 <lambdabot>  6
21:34:01 <HorrendousRex> Yes that much I do know, but I'm still new to the functional paradigm, so I don't see how to rewrite this here
21:34:16 <HorrendousRex> [1, 2, 3] would need to be the transformations
21:34:24 <HorrendousRex> hmmm
21:34:32 <HorrendousRex> (I can feel my brain wrinkling again)
21:34:41 <jle`> so how the fold sorta works is...you have an initial value, and you continually apply things from the list to that value
21:34:52 <jle`> so you might have a list of ships
21:34:58 <jle`> and placements
21:35:03 <HorrendousRex> the function would need to be a function that applies the folded value on to the accumulator
21:35:14 <jle`> [(Destroyer, Horizontal, (0,0)), (Patrol, Horizontal, (2,2))]
21:35:23 <jle`> your initial value would be newBoard
21:35:34 <jle`> and every step would be adding a ship to newboard
21:35:36 <jle`> :t foldr
21:35:37 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:36:20 <jle`> foldr (\(shipType, shipDir, shipPos) currBoard -> .... ? make the new board with the added ship here ) newBoard (list of ships)
21:36:35 <EvanR> if the ships can overlap, then the possible boards are the sets of ships, and this fold is really just union
21:36:54 <HorrendousRex> The ships can't overlap but I haven't done anything to enforce that yet
21:36:59 <HorrendousRex> which is an important consideration I have yet to make
21:37:01 <EvanR> yeah thats another topic
21:37:05 <jle`> this would basically be a direct translation of your code, btw
21:37:14 <jle`> foldr f x0 [a,b,c]
21:37:44 <jle`> is f (f (f (f (f a) b)) c) x0
21:37:49 <EvanR> the sum of numbers is also a fold, but often we write the fold for teaching
21:38:13 <jle`> wait
21:38:14 <jle`> ...
21:38:25 <jle`> i parenthesized that wrong
21:38:35 <jle`> f (f (f a b) c) x0
21:39:08 <jle`> um
21:39:16 <jle`> i am feeling weird today
21:39:23 <jle`> > foldr f x0 [a,b,c]
21:39:25 <lambdabot>  Not in scope: ‘x0’
21:39:25 <lambdabot>  Perhaps you meant ‘x’ (imported from Debug.SimpleReflect)
21:39:34 <HorrendousRex>  jle` what about thius style ? http://lpaste.net/107643
21:39:43 <EvanR> representing, enforcing a non overlap, maybe needs some sort of contract
21:39:43 <jle`> i
21:39:45 <HorrendousRex> I like how that uses partials instead of tuples
21:40:06 <jle`> don't mind me, i'm totally wrong.
21:40:09 <jle`> > foldr f x [a,b,c]
21:40:11 <lambdabot>  f a (f b (f c x))
21:40:13 <jle`> there
21:40:21 <jle`> it is...exactly what you already have written, more or less
21:40:43 <jle`> HorrendousRex: that's one way to do it :)
21:40:51 <EvanR> foldr is the shit
21:40:57 <jle`> why don't you just use foldr
21:41:01 <jle`> instead of foldl
21:41:16 <jle`> (by the way, you really shouldn't use foldl from prelude even if you want a left fold)
21:41:22 <HorrendousRex> well the answer to that question is "because I used foldr and it failed"
21:41:22 <jle`> foldl would be different than what you already have
21:41:27 <HorrendousRex> I should investigate why
21:42:18 <jle`> if you look at what foldr does, it's pretty muhc literally what you already had
21:42:35 <jle`> foldr f newBoard [a,b] = f a (f b (f c newBoard))
21:43:00 <EvanR> if insertShip :: Board -> Ship -> Either Error Board, how would you do a fold while bailing in case of error
21:43:19 <Welkin> battleships?
21:43:20 <jle`> foldl would shake things up a bit...and it would "work", but it is cool that foldr is the "direct translation" :)
21:43:35 <EvanR> foldr is my go to
21:43:47 <HorrendousRex> jle`: Can you help me write 'f' from your example where 'a' and 'b' are partial applications of 'placeShip' which is the transformer of a board to a board?
21:44:04 <HorrendousRex> the pastebin I sent last, http://lpaste.net/107643  -- if I change foldl to foldr it fails
21:44:12 <HorrendousRex> if you've explained why then I failed to comprehend it :)
21:44:30 <jle`> HorrendousRex: did you change your function?
21:44:36 <HorrendousRex> jle`: which one?
21:44:40 <jle`> foldl and foldr have different types
21:44:41 <jle`> :t foldl
21:44:42 <lambdabot> (b -> a -> b) -> b -> [a] -> b
21:44:44 <jle`> :t foldr
21:44:45 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:45:02 <EvanR> that used to be harder to read
21:45:21 <EvanR> foldr :: (b -> a -> a) -> a -> [b] -> a ;)
21:45:32 <jle`> the accumulating function different
21:45:47 <HorrendousRex> I need a bit more handolding I think. In the example I pasted, my fold-function was "\o f -> f o" for foldl
21:45:58 <HorrendousRex> would foldr's be "\f o -> f o" ? Which seems... wrong.
21:46:06 <HorrendousRex> I mean that's just application
21:46:08 <jle`> well, is it wrong?
21:46:10 <Welkin> reading the source code for foldr and foldl really helped me understand them when I started out
21:46:20 <EvanR> @src foldr
21:46:21 <lambdabot> foldr f z []     = z
21:46:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:46:37 <jle`> if i foldr a list of functions
21:47:37 <HorrendousRex> Basically I'm wondering if there's a way to reduce "\f o -> f o" to something else
21:47:43 <HorrendousRex> because it seems like that's a bit wordy
21:47:51 <EvanR> @pl \f o -> f o
21:47:51 <lambdabot> id
21:47:54 <carter> $
21:47:58 <carter> or that
21:47:58 <HorrendousRex> Oh awesome
21:48:04 <HorrendousRex> woh, wait
21:48:04 <carter> : ($)
21:48:09 <HorrendousRex> is id and $ related?
21:48:10 <carter> :t ($)
21:48:11 <lambdabot> (a -> b) -> a -> b
21:48:16 <HorrendousRex> mind = blown
21:48:18 <Cale> Yes, ($) is a specialisation of id
21:48:21 <Welkin> $ is just function application
21:48:32 <HorrendousRex> would it be more idiomatic to use id or $ here?
21:48:35 <HorrendousRex> $, right?
21:48:37 <Cale> sure
21:48:37 <EvanR> hehe
21:48:54 <carter> :t \f o -> f o
21:48:55 <lambdabot> (t1 -> t) -> t1 -> t
21:49:02 <carter> hows that also id?
21:49:08 <carter> oh
21:49:19 <carter> (id f)  x
21:49:22 <EvanR> (t1 -> t) -> (t1 -> t)
21:49:30 <HorrendousRex> How does this look then? http://lpaste.net/107644
21:49:35 <carter> aka f `id` x
21:49:38 <carter> losl
21:49:59 <EvanR> > (+1) `id` 2
21:50:01 <lambdabot>  3
21:50:04 <EvanR> hahaha
21:50:14 <HorrendousRex> getting some major 'a-ha' moments here guys, thanks a lot
21:50:39 <HorrendousRex> how would you format that snippet?
21:50:49 <jle`> HorrendousRex: another way you can do it is, instead of foldr ($) x [f1,f2,f3], you can do foldr (.) id [f1,f2,f3] $ x
21:50:57 <Welkin> > zipWith ($) (fix (+1)) [1..3]
21:50:58 <lambdabot>  Could not deduce (GHC.Num.Num [b0 -> c])
21:50:58 <lambdabot>    arising from the ambiguity check for ‘e_1113’
21:50:58 <lambdabot>  from the context (GHC.Num.Num [b -> c],
21:50:59 <lambdabot>                    GHC.Num.Num b,
21:50:59 <lambdabot>                    GHC.Enum.Enum b)
21:51:24 <Welkin> > zipWith ($) (repeat (+1)) [1..3]
21:51:26 <lambdabot>  [2,3,4]
21:51:29 <HorrendousRex> jle`: wow that's interesting
21:51:42 <jle`> HorrendousRex: the latter case is equivalent to
21:51:51 <jle`> (f1 . f2 . f3 . id) x
21:51:56 <jle`> which is (f1 . f2 . f3) x
21:52:07 <HorrendousRex> So what is the reason for avoiding foldl? Is it a TCR issue?
21:52:08 <Welkin> > zipWith ($) [(*4), (+3), (subtract 7)] [1..3]
21:52:09 <lambdabot>  [4,5,-4]
21:52:18 <jle`> HorrendousRex: foldl is a different function altogether
21:52:29 <EvanR> @src foldl
21:52:30 <lambdabot> foldl f z []     = z
21:52:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:52:35 <jle`> you basically wanted
21:52:36 <HorrendousRex> and yet it seemed suitable for this purpose as well
21:52:45 <jle`> f1 (f2 (f3 x))
21:52:47 <jle`> right?
21:52:57 <jle`> well, that is *literally* foldr ($) x [f1,f2,f3]
21:53:14 <jle`> foldl (flip ($)) x [f1,f2,f3] would be a different thing altogether
21:53:16 <HorrendousRex> Erm, no, not really... I want f3 ( f2 ( f1 x ) )
21:53:27 <HorrendousRex> I mean, in this particular case order does not matter
21:53:31 <HorrendousRex> so, either works.
21:53:33 <jle`> well
21:53:38 <EvanR> it accumulates one way, or the other
21:53:39 <jle`> you write it int he same order you wrote it
21:53:50 <jle`> you want f3 (f2 (f1 x))
21:53:57 <jle`> then it's foldr ($) x [f3,f2,f1]
21:54:00 <jle`> same order, see?
21:54:13 <Welkin> > foldl f 0 [1..3] :: Expr
21:54:13 <jle`> a (b (c d)) -> foldr ($) d [a,b,c]
21:54:15 <lambdabot>  f (f (f 0 1) 2) 3
21:54:30 <HorrendousRex> yes but that's the same as foldl (\o f -> f o) x [f1, f2, f3] is it not?
21:54:40 <jle`> foldr ($) x [f3,f2,f1] is a direct translation of f3 (f2 (f1 x))
21:54:43 <jle`> foldl is, however, not
21:54:57 <Welkin> > foldr f 0 [1..3] :: Expr
21:54:59 <lambdabot>  f 1 (f 2 (f 3 0))
21:55:16 <jle`> > foldr ($) x [f,g,h]
21:55:18 <lambdabot>  f (g (h x))
21:55:28 <jle`> > foldl (\o f -> f o) x [f,g,h]
21:55:29 <lambdabot>  h (g (f x))
21:55:31 <EvanR> direct translation, reverse translation
21:55:38 <jle`> see, it's reverse :)
21:55:42 <HorrendousRex> Right, no, I get that
21:55:45 <HorrendousRex> that's not my issue
21:55:52 <HorrendousRex> my issue is I would like to write [f1, f2, f3]
21:55:58 <HorrendousRex> not [f3, f2, f1]
21:56:07 <HorrendousRex> it is purely syntactical
21:56:08 <Welkin> then just reverse
21:56:21 <HorrendousRex> and that's what foldl does, yes?
21:56:24 <Welkin> reverse [f3, f2, f1]]
21:56:30 <Welkin> > reverse [f3, f2, f1]]
21:56:31 <lambdabot>  <hint>:1:21: parse error on input ‘]’
21:56:41 <Welkin> > reverse [f3, f2, f1]
21:56:43 <lambdabot>  Not in scope: ‘f3’
21:56:43 <lambdabot>  Perhaps you meant one of these:
21:56:43 <lambdabot>    ‘f’ (imported from Debug.SimpleReflect),
21:56:43 <lambdabot>    ‘_3’ (imported from Control.Lens),
21:56:43 <lambdabot>    ‘f'’ (imported from Debug.SimpleReflect)Not in scope: ‘f2’
21:56:46 <jle`> in haskell...we tend to like to see function composition 'in order'
21:56:50 <Welkin> > reverse [f3, f2, f1] :: [Expr]
21:56:51 <lambdabot>  Not in scope: ‘f3’
21:56:51 <lambdabot>  Perhaps you meant one of these:
21:56:52 <lambdabot>    ‘f’ (imported from Debug.SimpleReflect),
21:56:52 <lambdabot>    ‘_3’ (imported from Control.Lens),
21:56:53 <lambdabot>    ‘f'’ (imported from Debug.SimpleReflect)Not in scope: ‘f2’
21:57:02 <Welkin> > reverse [f, g, h] :: [Expr]
21:57:03 <lambdabot>  [h,g,f]
21:57:10 <Welkin> lambdabot is too finicky
21:57:11 <jle`> if you have f (g (h x))...then we tend to like to see [f,g,h]
21:57:13 <EvanR> yes this is the hello world in haskell, reverse "dlrow olleh"
21:57:22 <HorrendousRex> jle`: If I have a series of transofmrations I wish to apply, I think it would make sense that those transformations appear in the source in the order they are to be applied, no?
21:57:24 <jle`> just a general style trend
21:57:46 <HorrendousRex> yeesh, typos.
21:58:03 <jle`> i don't think it would be too bad of an idea
21:58:05 <EvanR> HorrendousRex: that makes sense if you are thinking about javascript-like chaining, like a.b.c.d
21:58:15 <Welkin> > reverse $ reverse "alternate dimension"
21:58:16 <lambdabot>  "alternate dimension"
21:58:31 <jle`> i don't think anyone would be upset if you used the backwards version, transformations in order
21:58:42 <jle`> if you used the foldr (.) version though it might be weord
21:58:47 <jle`> foldr (.) [f,g,h] $ x
21:58:55 <jle`> er, foldr (.) id [f,g,h] $ x
21:59:16 <HorrendousRex> Lots to think about here
21:59:17 <HorrendousRex> thanks all!
21:59:18 <jle`> purely as style, i don't think anyone would fault you for using foldl and backwards composition there
21:59:28 <jle`> actually in this case it might be better
21:59:32 <EvanR> a use case for foldl ;)
21:59:41 <jle`> by the way, use foldl' instead of foldl
21:59:56 <HorrendousRex> jle`: I'd heard that before but I don't remember why
22:00:05 <EvanR> would foldl' matter here?
22:00:07 * hackagebot smartcheck 0.2 - A smarter QuickCheck.  http://hackage.haskell.org/package/smartcheck-0.2 (LeePike)
22:00:11 <jle`> you can google something about strictness
22:00:26 <jle`> EvanR: well...not a big deal if he only ever has three functions
22:00:41 <jle`> but if it's unbounded then it's the same story as always
22:00:43 <EvanR> would it matter for a list of however many thousand functions?
22:00:55 <Welkin> what if he is running this on his refrigerator?
22:01:00 <Welkin> that doesn't have much memory
22:01:07 <EvanR> if its infinite, foldl' and foldl both fail right
22:01:13 <HorrendousRex> best to learn idiomatic haskell I think :)
22:01:18 <jle`> yeah.
22:01:30 <jle`> in short there are almost no practicla cases where foldl is preferred over foldl'
22:01:56 <EvanR> in the strict foldl where you sum numbers, the classic example, it ends up using constant memory
22:02:15 <EvanR> but when composing arbitrary functions its going to build up no matter what, with no way to resolve it until the end
22:02:26 <jle`> in this case he's not composing functions
22:02:27 <jle`> he's applying them
22:02:30 <EvanR> oh
22:03:03 <jle`> and still, i think you can build up thunks over (.) ?
22:03:11 <EvanR> you would, i thought that was the problem
22:04:08 <EvanR> f . g doesnt just simplify
22:04:14 <jle`> it does
22:04:18 <EvanR> oh?
22:04:19 <jle`> to (\x -> f (g x))
22:04:38 <EvanR> well yeah, thats the same thing
22:04:44 <ReinH> fsvo "simplify"
22:04:48 <ReinH> that doesn't involve simplifying anything
22:05:04 <jle`> it's one less level of indirection
22:05:13 <jle`> one less level of thunk tree?
22:05:26 <jle`> ReinH: i think we're talking about strictness here
22:05:33 <EvanR> alright
22:05:39 <HorrendousRex> ok thanks everyone!
22:05:42 <HorrendousRex> I'm off for the night :)
22:05:50 <jle`> and of foldl' does anything if you are chaining compositions
22:06:28 <EvanR> i mean, if a lambda takes exactly 1 unit of memory and each . takes one unit of memory, that would make sense
22:06:32 <EvanR> n -> 1
22:07:00 <EvanR> in my imagination the lambda grows in proportion to the amount of .
22:07:18 <EvanR> in fact, just wrapping inner lambdas
22:07:28 <jle`> each thunk is its own thing on the heap
22:07:33 <Welkin> it's just a stack of functon calls
22:07:58 <EvanR> each lambda is on the heap too right
22:08:07 <EvanR> this is how partial application works
22:08:16 <EvanR> nevermind
22:09:06 <ReinH> Well, a lambda abstraction is already in WHNF
22:09:18 <ReinH> (.) f g is not
22:09:19 <snyp> So for each function there's a set of functions in the compiled code?
22:09:26 <ReinH> so I suppose seq might save some space there
22:09:38 <tertl3-laptop> haskell is a beast
22:09:59 <EvanR> yeah im not saying its having no effect, but its not like the constant space example
22:10:13 <ReinH> @src (.)
22:10:14 <lambdabot> (f . g) x = f (g x)
22:10:14 <lambdabot> NB: In lambdabot,  (.) = fmap
22:11:13 <EvanR> if its pushing the lambdas on some sort of stack, then wed run out of space before heap ;)
22:11:19 <jle`> i'm not sure if you can say that this constant space, but it does save the accumulation of thunks, which is more likely to overflow the memory than a complex whnf lambda, i think
22:11:52 <snyp> So for each function there's a set of functions in the compiled code, for partial application?
22:11:58 <EvanR> "no one understands space performance of haskell" -- feynmann
22:12:10 <BenedictEggers> lol
22:12:24 <jle`> snyp: i'm...not sure it works that way.  i think there are optimizations
22:12:32 <jle`> ...i'm...
22:12:33 <snyp> o
22:12:37 <jle`> ...not sure of anything actually
22:12:55 <jle`> what is life
22:12:56 <EvanR> snyp: i read a thing "implementation of functional programming languages", which used this thing super combinators. dunno if its relevant to GHC
22:13:24 <snyp> i see
22:13:41 <EvanR> in general id guess you wouldnt be able to tell your source functions in the final compiled optimized code
22:14:04 <snyp> How much of GHC is C(or C++ idk) ?
22:14:11 <carter> its mostly haskell
22:14:24 <carter> a teeny bit of c and c-- (yes, minus minus)
22:14:53 <EvanR> i use c%=
22:15:10 <EvanR> c with a flintlock pistol
22:15:17 <Welkin> what about C+= ?
22:15:33 <Exio> better than C#
22:15:46 <EvanR> *C
22:15:49 <EvanR> segfault
22:17:43 <desophos> are there features in other languages that you wish were in Haskell? (hope this isn't too trollish, i'm just curious)
22:18:01 <jfischoff> row types
22:18:16 <MP2E> Dependendent types, once they get ironed out, a linear type system... umm maybe Rust's memory model when it is ironed out a bit :)
22:18:29 <EvanR> snyp: its interesting, you can implement partial application and closures with one thing
22:18:30 <suOya_> Dependent types would be cool yeah
22:18:40 <jfischoff> better support for resource regions
22:19:13 <desophos> haha maybe i shouldn't have asked, i have no idea what any of those things are
22:19:14 <EvanR> haskell has "lightweight dependent types" i.e. fake it with phantom types, rank N, or classes
22:19:51 <bjz> jfischoff: row types are so cool
22:20:18 <jle`> duck typing would be nice
22:20:23 <jle`> and monkey patching
22:20:27 <EvanR> lol
22:20:38 <EvanR> autopointers
22:20:39 <Welkin> you mean hot code swaps?
22:20:54 <Welkin> like in erlang
22:20:54 <suOya_> Also GHC integration with JavaScript and MongoDB
22:20:59 <EvanR> observer pattern
22:21:01 <Welkin> mongodb...
22:21:03 <jle`> doesn't haskell have monkey patching, with overlapping instances?
22:21:06 <Welkin> why??
22:21:12 <suOya_> Welking: Joking
22:21:32 <EvanR> desophos: mixins
22:21:58 <EvanR> joking, though i guess template haskell can do that ;)
22:22:09 <jle`> oh monkey patching is technically on runtime
22:22:43 <EvanR> in ruby everything is runtime, even definitions of all the static stuff. but i only see monkey patches happening in the static way
22:22:54 <EvanR> if you dynamically add methods, thats "DSL" pattern
22:24:09 <snyp> EvanR: hmm.. Lua uses upvalues for the local variables. And ad hoc partial application can be done with closures. hmmmm.. i can see that currying and closures are very related.
22:24:39 <snyp> (local variables in the enclosing scope)
22:25:17 <snyp> (then again, i am kinda noob, so i shouldn't talk about these things much.)
22:25:21 <EvanR> snyp: both require allocation of a "incomplete" application, in the case of a closure you can put those in as if they were partial args
22:25:50 <EvanR> i would not call upvalues local variables in lua
22:27:00 <snyp> yeah, me neither. should have thought of a better term.
22:27:16 <jfischoff> what is the modern way to write kernel modules linux with Haskell?
22:27:45 <MP2E> jfischoff : Honestly, that sounds painful
22:27:49 <MP2E> lots and lots of FFI
22:27:53 <jfischoff> Is there a version of House for IA-64?
22:28:17 <EvanR> snyp: anyway its funny because if your procedure has "room" for 3 arguments and it closes over 2 things, you allocate up to 4 spaces in the application record (5 means youd be executing it). but in haskell, we always think of all our functions having exactly one argument each ;)
22:28:19 <jfischoff> MP2E: Its the FFI I want
22:28:44 <zRecursive> jfischoff: It is C's strongth for kernel modules
22:29:36 <EvanR> can haskell runtime even run in kernel space?
22:29:44 <jfischoff> EvanR: no
22:29:50 <carter> jfischoff: probably the lowest pain way would be to use haskell as a code gen DSL
22:29:54 <jfischoff> I don’t think so, our of the box
22:30:26 <jfischoff> carter: the lowest pain would be install the modified ghc that works
22:30:32 <jfischoff> for kernel modules
22:30:37 <carter>  what modified ghc
22:30:41 <carter> i'm not awre of one ....
22:30:49 <jfischoff> Well there is House
22:31:00 <carter> which hasn't been touched in years
22:31:05 <jfischoff> no
22:31:06 <carter> and wasn't using ghc afaik
22:31:21 <jfischoff> “hOp is a micro-kernel based on the RTS of GHC … “
22:31:26 <jfischoff> https://github.com/dls/house
22:32:06 <carter> ok, 5 years old ghc RTS as a microkernel != good for writing linux kernel modules
22:32:08 <carter> hrmm
22:32:25 <carter> the ajhc stuff is the most current haskell for os extensions work i've seen
22:32:27 <jfischoff> also IA-32
22:32:48 <jfischoff> yeah, but does it support type families?
22:32:56 <snyp> EvanR: yeah, I read that in LYAH (that a function in haskell has just one argument, and it maps to another function taking another argument, so on).
22:33:06 <carter> jfischoff: jhc is barely H98 :)
22:33:26 <jfischoff> right
22:33:32 <carter> i'd honstly start with some of those DSLs like Ivor/Tower/Copilot
22:33:37 <carter> etc
22:33:42 <EvanR> snyp: right, meaning that actions or procedures taking no arguments like in other languages are not functions in haskell
22:34:02 <jfischoff> carter: That is an answer to a different question
22:34:31 <snyp> yeah..  i realized just this a few days ago (new to haskell, i am.)
22:35:24 <carter> jfischoff: alternatively, theres the haskell on xen stuff
22:35:28 <carter> whch is a bit more currently
22:35:37 <carter> https://github.com/GaloisInc/HaLVM
22:35:52 <platz> haskell cast ep 2 had don stewart talk about that
22:36:27 <jfischoff> I don’t really understand the performance implications of using a hypervisor
22:37:40 <carter> fair enough
22:37:48 <carter> otoh, its also no OS
22:37:52 <platz> and the line between unikernels/exokernels and hypervisors is somewhat hard to understand
22:37:53 <carter> just haskell
22:38:03 <jfischoff> platz: yes
22:38:15 <carter> whats the goal / use case?
22:38:41 <jfischoff> For instances are there contexts switch with a Halvm file read?
22:38:52 <jfischoff> Does Halvm make DMA calls?
22:39:04 <carter> lemme know what you find out :)
22:39:12 <jfischoff> ha
22:39:19 <EvanR> im haskell in ur kernel
22:39:31 <jfischoff> well someone must know
22:40:08 <carter> the people who hack on halvm :)
22:40:32 <jfischoff> I suppose so
22:43:43 <EvanR> ive been reading about dependent types, and i saw a lot of attitudes like "heres how you can get a benefit of DT without resorting to fully dependent types" does anyone know what is so frightening?
22:44:49 <carter> EvanR: someitimes you get less generic code if you make it too precise!
22:46:04 <EvanR> and this would be a problem from a library designers perspective
22:46:18 <glguy> Agda feels pretty close to home from Haskell if you want to give it a whirl
22:46:50 <BenedictEggers> anybody ever had a call to abs make their program hang?
22:46:57 <BenedictEggers> strangest thing..
22:47:07 <glguy> You end up spending a lot of time writing proofs to convince the type checker your types check :)
22:47:08 <carter> EvanR: yup :)
22:47:37 <glguy> It's hard on the end developer too, not just library author
22:47:39 <EvanR> glguy: because inferrence doesnt work?
22:48:01 <jle`> BenedictEggers: was it with a particular instance?
22:48:33 <BenedictEggers> jle`:  what do you mean? when i use (top - bot) + 1 it works, but abs (top - bot) + 1 hangs
22:48:40 <BenedictEggers> top and bot are Int
22:48:46 <glguy> Because your types are indexed with complex values that you want to prove normalize to the same value
22:49:11 <jle`> BenedictEggers: yeah, i mean what Num instance
22:49:16 <jle`> hm
22:49:23 <jle`> can you reproduce it in a small example?
22:50:17 <BenedictEggers> it's already pretty small, but i'll try to get something easier to explain and get back to you
22:50:19 <BenedictEggers> thanks jle`
22:50:50 <EvanR> > abs (4 - 2) + 1
22:50:51 <lambdabot>  3
22:51:03 <jle`> np.  abs can definitely hang on an arbitrary/custom Num instance but i don't think it should cause a difference on Int
22:51:11 <jle`> if the final result is evaluated in both cases
22:51:14 <EvanR> > abs (4 - (length [1..])) + 1
22:51:18 <lambdabot>  mueval-core: Time limit exceeded
22:51:43 <BenedictEggers> it's in a quickcheck test. it runs (and fails) without abs but hangs with it
22:52:08 <jle`> as in, it doesn't run any tests?
22:52:24 <BenedictEggers> as in, says its running them then sits at 100% on one of my cores until i kill it
22:52:49 <jle`> are you throwing away any tests?
22:53:04 <BenedictEggers> ?
22:53:04 <jle`> with ==> or an if/then or guard or something like that
22:53:07 <BenedictEggers> no
22:53:37 <jle`> @check \xs -> (length xs > 1) ==> ((head xs : tail xs) == xs)
22:53:39 <lambdabot>  +++ OK, passed 100 tests.
22:53:55 <BenedictEggers> code: https://github.com/BenedictEggers/99problems/blob/master/tests/MainTestSuite.hs
22:54:02 <BenedictEggers> its prop_rangeLength
22:54:09 <BenedictEggers> also im brand new to haskell so if my code sucks tell me :)
22:54:49 <BenedictEggers> anyway, there's ((top - bot) + 1) at the end of that equation. If I put abs in front of it...you know
22:57:47 <jle`> @check \b t -> length (range b t) == ((t - b) + 1)
22:57:49 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int -> [a0]’
22:57:49 <lambdabot>  with actual type ‘[a1]’ Relevant bindings include b :: (a1, a1) (bound at <i...
22:58:04 <jle`> @check \b t -> length (range (b,t)) == ((t - b) + 1)
22:58:06 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 3 shrinks):
22:58:06 <lambdabot>  0 -2
22:58:18 <jle`> @check \b t -> length (range (b,t)) == (abs (t - b) + 1)
22:58:19 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 3 shrinks):
22:58:20 <lambdabot>  0 -1
23:00:35 <jle`> @check \b t -> (b <= t) ==> length (range (b,t)) == (abs (t - b) + 1)
23:00:36 <lambdabot>  +++ OK, passed 100 tests.
23:00:37 <zRecursive> :r range
23:00:45 <zRecursive> :t range
23:00:47 <lambdabot> Ix a => (a, a) -> [a]
23:00:55 <jle`> it must be a different range than you have in your code though
23:01:01 <jle`> that's weird
23:01:15 <BenedictEggers> yeah, range isn't builtin
23:01:50 <BenedictEggers> mine's different in that it can go down also. see src/EvenMoreLists.hs in that project
23:02:25 <jle`> i don't see why adding abs  would cause it to hang hm.
23:03:21 <BenedictEggers> :(
23:03:53 <glguy> Could be running at large parameters
23:04:15 <jle`> but it feels weird that the non-abs version would work fine
23:04:37 <glguy> Well it's a random test, maybe unrelated
23:05:33 <glguy> Maybe limit the input and try again?
23:05:46 <BenedictEggers> how?
23:06:04 <BenedictEggers> sorry, noobish question
23:06:57 <glguy> Use ==> operator to put a precondition on the inputs
23:07:12 <glguy> Jle did it above
23:07:23 <BenedictEggers> ah o
23:07:24 <BenedictEggers> ok
23:08:57 <joelteon> I wish I'd known about (==>) about two weeks ago :/
23:09:05 <jle`> glguy: the Arbitrary instance is the same for both tho :|
23:09:45 <jle`> oh well, we'll let the tests be the answer
23:10:09 <glguy> I'm saying maybe it worked once because of lucky RNG picks is all
23:10:44 <glguy> And then the other time had a big range. That's all.
23:11:13 <glguy> I don't know what range QC picks from
23:14:19 <glguy> Does QC stop after first failure? Missing abs could make test fail and exit early
23:14:32 <BenedictEggers> i think it does
23:14:37 <BenedictEggers> without the abs it stops on 0 -1
23:14:59 <glguy> If so it would stop early avoiding large slow input
23:15:30 <BenedictEggers> unless it works for small input, but for some reason takes a long time for big input
23:15:41 <BenedictEggers> but given that it's just one arithmetic expression..
23:16:01 <glguy> Length of Range is slow for large input
23:16:14 <glguy> Especially when counting down
23:16:15 <BenedictEggers> you're right
23:16:17 <BenedictEggers> i bet that's it
23:17:05 <BenedictEggers> yeah, if i let it keep running i start getting memory spikes
23:17:23 <jle`> ah
23:17:25 <BenedictEggers> cool
23:17:25 <jle`> smart, glguy
23:17:28 <BenedictEggers> thanks #haskell
23:17:30 <BenedictEggers> glguy++
23:17:53 <BenedictEggers> sometimes i forget that my code executes on an actual computer instead of a perfect mathematical abstraction
23:17:55 <BenedictEggers> :|
23:18:13 <jle`> i don't know about you, but...
23:18:34 <glguy> Get an abstract computer/pad of paper ;)
23:31:48 <BenedictEggers> works! thanks again team
23:31:55 <gamegoblin> If I have a language pragma in a bunch of files, can I somehow override that to not get used in my .cabal file?
23:32:47 <bergmark> gamegoblin: override a pragma from the cabal file? No i don't think so
23:33:05 <MP2E> you can set the pragmas from the cabal file conditionally though
23:33:07 <MP2E> which might help
23:33:38 <MP2E> As in, take the pragma out of the source and put it as a flag to GHC in it's -XCommandLineForm and put it under a switch
23:34:01 <MP2E> its* blah
23:35:43 <haasn> http://new-www.haskell.org/ <- why would anybody include a quadratic fibonacci example, seriously?
23:35:53 <haasn> err, exponential
23:37:22 <kazagistar> haasn: cause its "expressive"
23:48:31 <joelteon> also, why does the haskell website look like that?
23:48:32 <gamegoblin> can I unsafe coerce an instance ?
23:48:37 <joelteon> it's hideous
23:48:39 <gamegoblin> I want to unsafe coerce that something is showable
23:49:58 <jle`> gamegoblin: to ..?
23:50:08 <gamegoblin> No no
23:50:17 <gamegoblin> I want to basically say
23:50:20 * hackagebot aeson-utils 0.2.2.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.2.1 (AdamBergmark)
23:50:22 * hackagebot generic-aeson 0.1.0.3 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.0.3 (AdamBergmark)
23:50:31 <gamegoblin> unsafeCoerce something :: Show a
23:50:48 <gamegoblin> so I want to force it into Show even though the function type doesn’t require it (but I know it is in Show)
23:54:38 <kvanb> gamegoblin: if you just do this it might work
23:54:38 <jle`> gamegoblin: well...what Show instance would it use?
23:54:51 <kvanb> although thats a really really really dangerous thing to do and it probably wont work anyway
23:54:57 <kvanb> show (unsafeCoerce x)
23:55:03 <jle`> show isn't some magically polymorphic function
23:55:11 <kvanb> yeah, instances have to be selected
23:55:11 <jle`> show is a different, separately compiled function for every type
23:55:15 <jle`> you have a showInt
23:55:16 <jle`> showBool
23:55:19 <jle`> showList
23:55:23 <kvanb> you could be evil and define something like Show (Ord a)
23:55:23 <jle`> showDouble
23:55:26 <kvanb> how do you coerce into that
23:55:40 <jle`> `show` is a separately compiled function for every single instance, resolved at compile-time
23:55:48 <jle`> how would GHC know which `show` to use?
23:55:58 <kvanb> its not really resolved at compile time
23:56:16 <kvanb> its converted to a dictionary which is mostly resolved at compile time
23:56:18 <kvanb> but sometimes not.
23:56:36 <kvanb> sometimes it ends up being an enormous inlined case
23:59:00 <jle`> in what situation is it not resolved at compile time? :/
