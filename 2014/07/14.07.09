00:00:33 <jle`> let is just almost like an alias
00:00:41 <solidus-river> man, when the wires become tangled
00:00:48 * solidus-river queues up drums
00:01:15 <jle`> heh
00:06:02 <blz37> which web framework is haskell.org using ?
00:08:09 <haasn> blz37: I think it's just MediaWiki
00:08:13 <augur> woo
00:08:17 <dmj`> apache :)
00:08:18 <augur> chart parsing in 87 lines :)
00:08:30 <dmj`> Server:Apache/2.2.22 (Debian)
00:08:39 <haasn> Ah, so Apache+PHP+MySQL+MediaWiki most likely
00:09:03 * hackagebot hgl-example 0.0.2 - Various animations generated using HGL  http://hackage.haskell.org/package/hgl-example-0.0.2 (HenningThielemann)
00:09:03 * hackagebot saferoute 0.0.0.0 - A simple type-safe routing library.  http://hackage.haskell.org/package/saferoute-0.0.0.0 (pharpend)
00:09:41 <haasn> Yep, http://www.haskell.org/haskellwiki/Special:Version MediaWiki 1.19.5-1+deb7u1, PHP 5.4.4-14+deb7u8 and MySQL 5.5.37-0+wheezy1
00:16:52 <augur> so
00:17:06 <solidus-river> where do i find runIdentity
00:17:11 <solidus-river> hoogle is not being hepfull
00:17:12 <jle`> solidus-river: Data.Functor.Identity
00:17:14 <ReinH> augur: so
00:17:15 <augur> my chart parser takes ~40 seconds to find all 2 674 440 parses of "a + a + a + a + a + a + a + a + a + a + a + a + a + a + a"
00:17:20 <jle`> it's just the record field for Identity
00:17:57 <augur> which is 66,861 parses per second
00:18:08 <solidus-river> should i be using mtl or transformers
00:18:42 <ReinH> augur: seems good?
00:18:52 <augur> 14.956 Œºs/parse
00:19:05 <augur> i wish it were nanoseconds! :|
00:19:31 <jle`> solidus-river: use transformers unless you need mtl
00:19:34 <augur> oh, and im not optimizing
00:19:46 <blz37> haasn, dmj, none of the haskell web framework ?
00:22:15 <haasn> blz37: No, although it's a topic that pops up every now and then (moving haskellwiki to a haskell-based wiki)
00:22:35 <haasn> A lot of the infrastructure is written in Haskell, but not Haskell.org it seems :p
00:22:37 <haasn> Probably just historical
00:22:52 <augur> aggressive optimization isnt improving things
00:22:59 <augur> i guess my algorithm is that tight
00:23:01 <augur> aww yeah
00:29:30 * jle` hands augur sunglasses to put on dramatically
00:29:43 <augur> jle`: :P
00:33:18 <solidus-river> jle`: whats the difference between the s in Wire and the s in Session
00:34:43 <augur> solidus-river: well, there's none in Wire, but three in Session!
00:34:55 <augur> 8D
00:37:19 <solidus-river> :)
00:37:23 <solidus-river> that took me a bit too long
00:37:33 <trap_exit> is there something like sqlite but written in haskell?
00:38:14 <solidus-river> trap_exit: theres haskell bindings to sqlite
00:38:54 <trap_exit> yeah
00:38:54 <trap_exit> but I want to read haskell code
00:38:56 <trap_exit> not sqlite C code
00:41:53 <gamegoblin> So you want a simple RDBMS in Haskell?
00:43:29 <frerich> Does anybody here have experience with document-based databases in general, and Haskell bindings to them in particular? I need to store a couple of files (usually ~3 files with a total size of ~1.5MB) using a previously computed hash as the key. So far, I just store them in a custom directory structure but I wonder whether maybe something like CouchDB could simplify this.
00:44:29 <pjdelport> trap_exit: acid-base ?
00:44:43 <pjdelport> err, acid-state
00:44:51 <pjdelport> http://acid-state.seize.it/
00:45:16 <lfairy> acid-state is great
00:45:49 <pjdelport> That slip makes me realize that "acid-base" would be a much more amusing and punny name for it.
00:45:49 <levi> frerich: You can talk to CouchDB via an HTTP api, right? Might be the easiest way to interface from Haskell.
00:46:01 <lfairy> you tell acid-state to save your structure
00:46:05 <lfairy> then it saves it
00:46:07 <lfairy> it's amazing
00:46:13 <trap_exit> pjdelport: noted, thanks
00:47:46 <frerich> levi: Hmmm, interesting idea, I'll consider that.
00:48:36 <systemfault> Noob here‚Ä¶ Is liftM the fmap of the Monad world?
00:49:27 <Iceland_jack> systemfault: yes, it's just there because Applicative isn't a superclass of Monad
00:49:37 <Iceland_jack> but it will change in the next GHC version
00:49:40 <Iceland_jack> @ty liftM
00:49:41 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
00:49:42 <Iceland_jack> @ty fmap
00:49:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:50:25 <Iceland_jack> systemfault: Searching for 'liftM' and 'fmap' should give plenty of resources
00:50:27 <Iceland_jack> @google liftM fmap
00:50:28 <lambdabot> http://stackoverflow.com/questions/7463500/why-do-we-have-map-fmap-and-liftm
00:50:28 <lambdabot> Title: list - Why do we have map, fmap and liftM? - Stack Overflow
00:50:36 <augur> systemfault, Iceland_jack: fmap is the fmap of the monad world
00:50:47 <augur> @src liftM
00:50:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:51:04 <augur> by the monad laws, this is the same as fmap
00:51:35 <Iceland_jack> >
00:51:35 <Iceland_jack>     The fact that we have both fmap and liftM is an unfortunate consequence of the fact that the Monad type class does not require a Functor instance, even though mathematically speaking, every monad is a functor. However, fmap and liftM are essentially interchangeable, since it is a bug (in a social rather than technical sense) for any type to be an instance of Monad without also being an instance of Functor.
00:52:00 <augur> @src Monad
00:52:00 <lambdabot> class  Monad m  where
00:52:00 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:52:00 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:52:00 <lambdabot>     return      :: a -> m a
00:52:00 <lambdabot>     fail        :: String -> m a
00:52:08 <augur> huh. i wonder why it doesnt require Functor
00:52:11 <augur> how strange
00:52:41 <systemfault> So the whole Functor -> Applicative -> Monad mess is going to be fixed for 7.10?
00:52:42 <hyPiRion> augur: has to do with history
00:52:50 <Iceland_jack> systemfault: yes basically
00:52:52 <augur> hyPiRion: as if thats a good reason
00:52:53 <systemfault> Nice
00:53:03 <hyPiRion> augur: I didn't say it was a good reason ;p
00:54:30 <systemfault> Good, I‚Äôm now ready to start RWH :)
00:54:40 <Iceland_jack> good luck systemfault
00:54:41 <systemfault> Thank you, I love the community.
00:55:15 <ctangent> it's seriously amazing how something as powerful as a monad can be defined so simply in five lines of haskell
00:56:01 <Iceland_jack> ctangent: it could be defined in fewer lines if you'd remove 'fail' :) (>>) can also be defined in terms of (>>=)
00:56:11 <ctangent> true :p
00:56:37 <Iceland_jack> (If you have the Applicative constraint you can also do away with ‚Äòreturn‚Äô but then you're just moving the lines elsewhere)
00:56:48 <ctangent> bind and return is all f# needs to define a "workflow"
01:01:28 <kvanb> is there a trifunctor?
01:02:00 <augur> kvanb: trifunctor?
01:02:11 <kvanb> I need something like Either
01:02:15 <kvanb> but with 3 slots
01:02:17 <kvanb> ideas?
01:02:25 <augur> what do you mean
01:02:28 <Iceland_jack> http://hackage.haskell.org/package/category-extras-0.1/docs/Control-Functor.html has a trifunctor
01:02:33 <augur> just.. define it?
01:02:58 <Iceland_jack>     class Trifunctor f where
01:02:58 <Iceland_jack>         trimap :: (a -> a') -> (b -> b') -> (c -> c') -> f a b c -> f a' b' c'
01:03:07 <kvanb> i want it to be generic
01:03:09 <levi> ctangent: Plenty of really powerful things can be defined very simply. The untyped lambda calculus itself is nearly trivial.
01:03:14 <kvanb> I was going to pull the logic out into a package and put it on hackage
01:03:34 <augur> how do i load a package module? :(
01:03:50 <kvanb> whats with the hackage page
01:03:52 <ctangent> levi: i did a simple typed lambda calculus in haskell in about 20 lines the other day, straight from a textbook... it was pretty amazing
01:03:54 <kvanb> not showing the documentation
01:03:54 <levi> augur: What do you mean by 'load a package module'?
01:04:01 <augur> Criterion is a package module
01:04:06 <augur> ghci complains if i try to :load it
01:04:31 <augur> oh, if i do :m it works
01:04:31 <augur> ok
01:04:34 <levi> :m + Criterion ?
01:05:03 <kvanb> Iceland_jack: what is it called
01:05:13 <kvanb> it's not Trifunctor, I can't find it anyway
01:05:48 <kvanb> oh, it's in bifunctor now
01:07:20 <kvanb> No, actually, it was removed.
01:07:45 <levi> ctangent: On a related note, I finally got DeBruijn indices my last time through the early chapters of TAPL and whipped up a working implementation in very little time.
01:07:45 <Iceland_jack> It's not terribly useful
01:08:02 <ctangent> levi: hah, that's the very book I'm working through too
01:08:39 <kvanb> I guess I have to do a nested either
01:08:41 <kvanb> :\
01:10:55 <solidus-river> my game loop is successfully wired!
01:10:58 <solidus-river> today is the best day
01:11:48 <augur> hmm
01:11:53 <augur> criterion is taking forever
01:13:15 <dagle> Hmmm. Why does "Try it" on the haskell homepage only return the type and not the answer?
01:13:27 <augur> dagle: it gives an answer for me
01:13:33 <dagle> hmm.
01:13:36 <dagle> I only get the type.
01:13:59 <augur> dagle: are you sure?
01:13:59 <augur> :x
01:14:14 <dagle> 5+5 :: Num a => a
01:14:27 <dagle> (I typed 5+5)
01:14:32 <augur> well its not wrong!
01:14:38 <augur> 5+5 does indeed == 5+5!
01:14:39 <augur> :x
01:15:00 <systemfault> It prints the answer and the type after (for me)
01:15:03 <dagle> no, I typed 5+5 and it responded with ":: Num a => a"
01:15:27 <systemfault> dagle: And the line before?
01:15:28 <augur> dagle: are you using the new page, or tryhaskell?
01:15:32 <Pythonfant> I get 10
01:15:40 <Pythonfant> and in the line below that the type
01:15:43 <dagle> augur: http://new-www.haskell.org/
01:15:44 <solidus-river> goodnight all, and as always, thanks jle` :)
01:15:54 <augur> dagle: well thats liable to be buggy
01:16:08 <augur> i mean, for me it shows 10 :: Num a => a
01:16:09 <augur> but
01:16:31 <dagle> augur: That's why I asked, if it was a bug, since printing just the type seemed kinda silly. :P
01:16:43 <augur> that site is an experimental prototype
01:16:46 <augur> why are you using it?
01:17:14 <dagle> "using"
01:17:56 <levi> Why not use it?
01:18:14 <augur> heeelppp :(
01:18:17 <augur> criterion is being naughty
01:18:18 <augur> :(
01:18:41 <trap_exit> argh
01:20:44 <levi> How's it being naughty?
01:21:57 <mcjohnalds> I have a data type `data Cell = Bool Bool Bool Bool`. I want an unboxed 2d array of Cells, but writing an instance of IArray (specifically IArray UArray Cell) seems overcomplicated. What is my best option?
01:22:01 <augur> levi: its just hanging
01:22:04 <augur> its not doing anything
01:23:53 <jle`> yeah the try it on the new homepage is a bit buggy
01:25:03 <systemfault> map (*3) [1..10]
01:25:04 <systemfault> can't find file: Imports.hs
01:25:05 <systemfault> :/
01:25:20 <systemfault> The interpreter on the that ‚Äúnew‚Äù page is messed up
01:28:05 <ab9rf> aw
01:29:17 <jle`> systemfault: enter it again
01:29:22 <jle`> it usually works the second time
01:29:27 <jle`> but yeah, it's slightly messed up :/
01:29:48 <jle`> it's okay, it's not officially the new one yet right?
01:30:01 <systemfault> Right
01:30:03 <systemfault> It worked
01:30:26 <codygman> When opening ghci, I type in ":t String" and get "<interactive>:1:1: Not in scope: data constructor ‚ÄòString‚Äô" I'm pretty sure this didn't happen before.
01:30:36 <Pythonfant> Is there something like a tuple that can only contain one type, has a fixed size like tuple but allows to write methods that work with all sizes? basicly I'm looking for something to use as vectors
01:30:57 <codygman> xb
01:31:03 <Pythonfant> codygman: should be correct, try :i String
01:32:02 <codygman> Pythonfant: Oh... duh... newtype of char. What should I be able to show the type of when opening ghci?
01:32:57 <Pythonfant> codygman: ‚Äúsomething that is on the right side of a data statement‚Äú
01:33:12 <Pythonfant> so data Bool = True | False
01:33:18 <Pythonfant> you can :t True or :t False
01:33:25 <Pythonfant> but :t Bool doesn't make sense
01:33:29 <Pythonfant> because it's not a value
01:35:50 <ReinH> String is not a new type, just a synonym of [Char]
01:35:59 <ReinH> *newtype
01:36:09 <codygman> ReinH: My mistake, thanks.
01:36:29 <tsahyt> Does anyone have experience with GTK and OpenGL?
01:36:51 <codygman> Pythonfant: Thanks
01:37:30 <pjdelport> Pythonfant: arrays or vector?
01:38:28 <Pythonfant> pjdelport: thx
01:38:48 <pjdelport> @package vector
01:38:48 <lambdabot> http://hackage.haskell.org/package/vector
01:39:39 <pjdelport> vector is basically like Array, but Faster‚Ñ¢, so if you don't care too much about that, you can probably just use arrays.
01:40:16 <Iceland_jack> pjdelport: the API is also far nicer
01:40:17 <pjdelport> (and vectors are Int-indexed rather than by arbitrary Ix, and so on.)
01:40:33 <Iceland_jack> Unless you're working with multidimentional arrays
01:41:31 <pjdelport> Iceland_jack: I would say simpler vs. richer, rather than either being nicer. "Nice" is relative to what you want to accomplish. :)
01:41:50 <codygman> I just used "nix-env -iA nixos.pkgs.haskellPackages_ghc783.ghc" and now everything is broken (can't import Control.Random for instance), how can I go back to using ghc 7.6.3 as default?
01:51:01 <knapper_tech> I need to find an example of really simple Heist useage to produce strings
01:51:45 <knapper_tech> Getting destroyed by trying to figure out how to coerce higher order shit back to strings
01:54:23 <Saizan> codygman: it seems like you just have to install the libraries for that ghc version too, i don't know how to go back to 7.6.3 though
01:54:51 <Saizan> codygman: maybe you still have the versioned exe ghc-7.6.3 though
02:00:34 <codygman> Saizan: Thanks for the help. I just reinstalled ghc763 and it changed the symbolic links ;)
02:09:22 <jle`> codygman: you can also ask for the kind
02:10:07 <jle`> which is probably somewhat of a more meaningful answer to "what is the 'type' of the String newtype"
02:10:24 <jle`> but yeah, String doesn't have a Haskell type; only data has types
02:19:39 <merijn> *only values have types
02:19:56 <merijn> data is a rather ambiguous term
02:19:58 <codygman> I just wrote this code based on the wikibooks state monad tutorial (http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State) for rolling dice, won't it always be the same though? It seems to be in ghci. Here is code: http://lpaste.net/107166
02:20:13 <merijn> For example, functions are definitely values in haskell, are they "data"?
02:20:32 <Iceland_jack> codygman: yes because you're always passing in the same seed
02:20:50 <merijn> codygman: Yes, but repeated invocation should be different, though
02:20:57 <jle`> merijn: thanks :)
02:21:04 <jle`> value is a better word
02:21:07 <merijn> :t repeatM
02:21:07 <lambdabot>     Not in scope: ‚ÄòrepeatM‚Äô
02:21:08 <lambdabot>     Perhaps you meant one of these:
02:21:08 <lambdabot>       ‚Äòrepeat‚Äô (imported from Data.List),
02:21:14 <Iceland_jack> @ty replicateM
02:21:15 <lambdabot> Monad m => Int -> m a -> m [a]
02:21:23 <merijn> Right, that's what I was looking for :)
02:21:26 <Iceland_jack> :)
02:21:46 <codygman> merijn: I tried doing "evalState rollDice (mkStdGen 5)" twice in the repl and got the same thing.
02:21:48 <merijn> codygman: Try replicateM on rollDice and you should get a bunch of different die rolls
02:21:55 <codygman> Iceland_jack: So I have to pass a random seed?
02:21:57 <johnw> repeatM would have no way to finish
02:21:58 <bollu> hey all
02:21:58 <codygman> merijn: alright
02:22:18 <bollu> how come I can't import Reader within GHCI?
02:22:18 <Iceland_jack> codygman: You can get a new seed with something like ‚ÄònewStdGen‚Äô or ‚ÄògetStdGen‚Äô
02:22:29 <merijn> codygman: The point is that your State computation updates your seed every dice roll, if you call "evalState" twice with the same starting seed it will return the same result
02:22:39 <bollu> I'm trying to import it as Controler.Monad.Reader
02:22:47 <pyrtsa> newStdGen >>= setStdGen >> rollDice
02:22:53 <Iceland_jack> bollu: it should be *Control*
02:22:54 <bollu> I'm trying to import it as Control.Monad.Reader *
02:23:01 <bollu> Iceland_jack: yeah, I used Control*
02:23:47 <jle`> codygman: remember, State is just a thin wraper around normal functions
02:23:54 <bollu> http://pastebin.com/sRAgW4hG <-
02:23:56 <merijn> codygman: your GeneratorState represents a computation where every dice roll will update the generator with the result of the old one, generating a pseudo-random stream of dice rolls
02:23:58 <jle`> you can write it yourslef from scratch without much effort
02:24:01 <bollu> http://pastebin.com/sRAgW4hG <- me trying to import Reader
02:24:08 <bollu> any help?
02:24:16 <jle`> and if you pass a function with the same input...
02:24:17 <merijn> codygman: This stream is still pure, so evaluating it twice with the same seed will produce the same result
02:24:26 <jle`> yoer, if you call a function with the same input
02:24:29 <jle`> you'll get the same answer
02:25:30 <codygman> merijn: I think I get it.
02:25:37 <bollu> http://pastebin.com/sRAgW4hG <- help? >_<
02:25:53 <jle`> bollu: is mtl installed?
02:26:02 <codygman> pyrtsa: Wouldn't it be "newStdGen >>= setStdGen >> return rollDice"?
02:26:21 <merijn> codygman: You already see this inside your rollDice, it uses rollDie twice and each one of those returns a different result
02:26:22 <pyrtsa> codygman: Sorry, didn't check the type of rollDice before typing.
02:26:25 <bollu> jle`: that a library?
02:26:27 <bollu> jle`: and no, it's not
02:26:30 <jle`> yes
02:26:38 <jle`> it's the library that offers the Control.Monad.Reader module
02:26:50 <bollu> jle`: ohh. I thought it was part of stdlib
02:27:02 <jle`> it's a part of the platform i think, but not in base :)
02:27:12 <bollu> jle`: ah, I see.
02:27:42 <jle`> you can also try the transformers package
02:27:52 <jle`> if you're new to haskell it has slightly simpler types for its functions
02:27:55 <jle`> and has a lot less baggage
02:27:56 <bollu> jle`: is that similar?
02:28:03 <bollu> jle`: ooh, thanks!
02:28:03 <jle`> Control.Monad.Trans.Reader
02:28:16 <jle`> it offers a subset of the functionality, but is conceptually a lot simpler
02:28:19 <jle`> for someone new
02:28:26 <codygman> How would I get the (Int, Int) out of "IO (GeneratorState (Int, Int))"? My initial guess didn't work: (_,(x,y)) <- newStdGen >>= setStdGen >> return rollDice
02:28:36 <bollu> perfect :)
02:34:26 <jle`> codygman: why don't you try breaking it up into do block statments :)
02:34:58 <codygman> jle': Alright
02:37:51 <peterhil> Can I define both executables and a library in a .cabal file?
02:38:39 <supki> peterhil: yes
02:39:11 <supki> actually, you can define any number of executables but only one library
02:39:18 <peterhil> Ok, thanks
02:49:50 <merijn> peterhil: In fact, it's rather common to define a library with all shared functionality and have multiple executables depend on the library inside the same package to share code :)
02:51:33 <mcjohnalds> I have a data type `data Cell = Bool Bool Bool Bool`. I want an unboxed 2d array of Cells, but writing an instance of IArray (specifically IArray UArray Cell) seems overcomplicated. What is my best option?
02:52:17 <codygman> jle`: That helped, I got it working in do notation, but I'm not sure how I'd write shorthand: http://lpaste.net/107167
02:58:47 <jle`> codygman: no real need
02:58:54 <jle`> you can always use @undo on lambdabot
02:59:45 <jle`> @undo do { g <- newStdGen; let diceRes = rollDice; let res = evalState diceRes g; print res {
02:59:45 <lambdabot> <unknown>.hs: 1: 46:Parse error: let
02:59:58 <jle`> @undo do { g <- newStdGen; let {diceRes = rollDice; res = evalState diceRes g}; print res {
02:59:58 <lambdabot> <unknown>.hs: 1: 86:Parse error: EOF
03:00:04 <jle`> @undo do { g <- newStdGen; let {diceRes = rollDice; res = evalState diceRes g}; print res }
03:00:04 <lambdabot> newStdGen >>= \ g -> let { diceRes = rollDice; res = evalState diceRes g} in print res
03:00:39 <jle`> if i were to write it without do notation i would probably do something like...
03:00:47 <jle`> print . evalState diceRes =<< newStdGen
03:01:18 <jle`> (diceRes should be rollDice)
03:01:52 <jle`> outside of do notation, (=<<) is a much more sensible operator
03:02:03 <jle`> than the monstrosity that is (>>=)
03:06:31 <codygman> jle`: Thanks, that is exactly what I was looking for! I didn't know about undo previously either. While doing tutorials I like to put the do notation version of my code and shorthand that I can look back to later.
03:08:12 <jle`> no problem :)
03:08:20 <jle`> (=<<) puts you back into normal haskell thinking mode
03:08:31 <nawal> hey guys
03:08:35 <nawal> I'm playing with GLUT
03:08:53 <nawal> and I tried using the datatype Vector2
03:08:57 <nawal> sorry, Vecor3
03:09:02 <nawal> Vector3
03:09:05 <nawal> third time lucky
03:09:16 <nawal> but I can't seem to import it with the parenthesis
03:09:31 <nawal> If I do import Graphics.UI.GLUT, I can use Vector3
03:09:38 <nawal> But if I do import           Graphics.UI.GLUT ( ($=), ($~!), color, vertex, Vector3, Color3, GLfloat, PrimitiveMode( Quads )   )
03:09:49 <nawal> , I can use everything else, but not Vecotor3 and Color3
03:10:09 <jle`> nawal: you aren't importing the constructors, only the type
03:10:11 <pjdelport> codygman: A more understandable approach perhaps is to make a helper that evals your GeneratorState with a fresh generator.
03:10:47 <pjdelport> codygman: evalRandIO :: GeneratorState b -> IO b; evalRandIO f = evalState f `fmap`newStdGen
03:10:50 <jle`> nawal: consider import Prelude (Maybe), which lets you use the Maybe type in your type signature and stuff
03:10:54 <jle`> type signatures
03:10:58 <jle`> but you can't use Just and Nothing
03:11:07 <jle`> import Prelude (Maybe(Just, Nothing))
03:11:11 <pjdelport> (Or "evalState f <$> newStdGen" if you're feeling applicative)
03:11:16 <jle`> will give you both the type (Maybe) and the constructors, Just and Nothing
03:11:31 <jle`> or if you want to import all the constructors, import Prelude ( Maybe(..) )
03:11:57 <pjdelport> codygman: Then you can just say "> evalRandIO rollDice" in GHCi, and each invocation will give a different result.
03:13:23 <pjdelport> codygman: That's essentially the same as evalRandIO from http://hackage.haskell.org/package/MonadRandom-0.1.13/docs/Control-Monad-Random.html
03:14:08 <knapper_tech>     Couldn't match expected type ëIO (HeistState m)í
03:14:08 <knapper_tech>                 with actual type ëEitherT [String] IO (HeistState n0)í
03:14:16 <knapper_tech> So I'm not handling the error case?
03:14:37 <nawal> Thanks guys :-)
03:14:48 <nawal> Works now
03:15:08 <knapper_tech> How do I get the IO (HeistState n0) out of my EtherT [String] IO (HeistState n0)?
03:15:18 <knapper_tech> Just...left right.  Jesus =D
03:17:05 <zipper> Is haskell + docker a thing?
03:17:31 <jle`> nawal: yay!
03:17:43 <jle`> @unmtl EitherT [String] IO (HeistState n0)
03:17:43 <lambdabot> EitherT [String] IO (HeistState n0)
03:17:45 <haasn> knapper_tech: important to note that EitherT is not Either
03:17:54 <jle`> hm
03:18:01 <jle`> @unmtl EitherT [String] IO
03:18:01 <lambdabot> EitherT [String] IO
03:18:09 <jle`> oh EitherT is not in mtl
03:18:22 <haasn> it's not a left error case and right IO (HeistState m) case; it's more like IO (Either [String] (HeistState m))
03:18:37 <haasn> So you need to bind inside IO and handle the error case and HeistState m case there, separately
03:18:38 <jle`> EitherT e m a ~ m (Either e a)
03:19:16 <knapper_tech> I can't just write a function that returns a HeistState outside of a do block?
03:19:35 <knapper_tech> I'm pretty much lost here.
03:19:42 <jle`> knapper_tech: what do you mean
03:19:47 <jle`> what is the type you are expecting?
03:20:02 <jle`> EitherT [String] IO (HeistState n0) -> IO (HeistState n0) ?
03:20:02 <knapper_tech> I need to "Bind inside IO and handle the eror case"
03:20:26 <Heather> hi
03:20:26 <knapper_tech> jle`:  I need the return value in that signature
03:20:36 <knapper_tech> I have the argument type
03:20:44 <Heather> how to get handle / or terminale some process running in OS ?
03:21:05 <jle`> knapper_tech: is that the type signature you are looking for?
03:21:20 <knapper_tech> jle`:  yes.  it describes exactly what I have and what I need
03:21:31 <jle`> EitherT e m a can be thought of as just a "type synonym", or newtype wrapper, around m (Either e a)
03:21:43 <jle`> so your EitherT [String] IO (HeistState n0)
03:21:55 <jle`> is "actually" an IO (Either [String] (HeistState n0))
03:22:04 <jle`> this is the truth; it's actually been this the whole time, in disguise
03:22:23 <jle`> the conversion function to reveal the true form is runEitherT
03:22:27 <jle`> ..i think that's what it's called?
03:22:39 <jle`> runEitherT :: EitherT e m a -> m (Either e a)
03:22:45 <knapper_tech> jle`:  you just explained difference between Either and EitherT?
03:22:53 <jle`> no, i'm explaining what EitherT is
03:22:58 <jle`> so you can know how to handle it :)
03:23:09 <jle`> so anyways you can use runEitherT to get your IO (Either [String] (HeistState n0))
03:23:13 <knapper_tech> I think I follow
03:23:14 <jle`> is this problem now easier for you?
03:23:25 <jle`> can you go from IO (Either [String] (HeistState n0)) -> HeistState n0 ?
03:23:28 <jle`> er
03:23:38 <jle`> IO (Either [String] (HeistState n0)) -> IO (HeistState n0) ?
03:24:17 <jle`> as in, are you able to go from here, or would you like more?
03:24:29 <haasn> EitherT [String] IO (HeistState n0) -> IO (HeistState n0) to me seems like a signature that makes no sense
03:24:33 <haasn> Or shouldn't exist
03:24:54 <haasn> Maybe you want Either [String] a -> IO a
03:25:23 <haasn> That signature should hopefully be more transparent about what is being done
03:26:18 <jle`> EitherT [String] IO (HeistState n0) -> IO (HeistState n0) should make sense, shouldn't it?  provided he has an Either [String] (HeistState n0) -> HeistState n0 function
03:26:32 <jle`> which he would have if he had some sort of default heiststate
03:26:55 <jle`> if we call it f, it'd just be fmap f (runEitherT etio)
03:27:51 <jle`> there's actually a convenience function of just that type in kmett's either library
03:28:08 <jle`> of a more generalized type
03:28:37 <knapper_tech>     Couldn't match expected type ëIO (HeistState m)í
03:28:37 <knapper_tech>                 with actual type ëEitherT [String] IO (HeistState n0)í
03:28:49 <peterhil> @tell jfischoff My OpenAL audio playback and capture code can be found on Github: https://github.com/peterhil/hs-openal-proto
03:28:49 <lambdabot> Consider it noted.
03:29:15 <peterhil> I hope I didn't mess anything when I packaged it with cabal...
03:29:23 <knapper_tech> This is where I'm at.  I have EitherT [String] IO (HeistState n0) and I need HeistState n0.
03:29:40 <haasn> jle`: IO a -> IO b seems like something silly in general
03:29:43 <haasn> why not a -> IO b
03:30:05 <haasn> Actually, that's not true in general; you may wish to wrap another action
03:30:07 <haasn> Hmm
03:30:11 <knapper_tech> I'm just trying to write a function that returns a HeistState =)
03:30:27 <knapper_tech> that I can use in some other function until I have a string
03:30:49 <jle`> knapper_tech: you use runEitherT to turn your EitherT [String] IO (HeistState n0) into an IO (Either [String] (HeistState n0))
03:31:05 <jle`> then i am *presuming* you have an Either [String] (HeistState n0) -> HeistState n0 function
03:31:10 <jle`> ...if you don't, then you're out of luck
03:31:16 <haasn> knapper_tech: What other function do you have that requires you to have an IO (HeistState m) ?
03:31:18 <jle`> do you have a "default value" in case of an error?
03:31:20 <haasn> I don't understand the context at all
03:31:32 <jle`> i mean, a Left
03:31:43 <knapper_tech> Okay, here we are:       Couldn't match type ëEither [String] (HeistState n0)í
03:31:43 <knapper_tech>                   with ëHeistState mí
03:32:15 <jle`> do you have an Either [String] (HeistState n0) -> HeistState n0 function?
03:32:19 <knapper_tech> No, I haven't set up a default value
03:32:32 <knapper_tech> in case of error (template dir doesn't exist) etc
03:32:32 <jle`> then how are you going to magically handle teh case where there is no HeistState n0 available?
03:32:51 <jle`> did you want to throw a runtime error ... ?
03:32:58 <knapper_tech> jle`:  yes.
03:33:15 <knapper_tech> jle`:  if the server starts and the templates directory doesn't exist, something is horribly wrong.
03:33:28 <jle`> ew.  well then you might want to write it by hand.
03:33:41 <jle`> stateFromEither (Right h) = h
03:34:24 <haasn> do res <- runEitherT firstAction; case res of Left s -> putStrLn ("Errors:\n" ++ unlines s); Right h -> doSomethingElse h
03:34:27 <jle`> stateFromEither (Left xs) = error [a very detailed runtime error message]
03:34:43 <haasn> This is how work with EitherT
03:35:45 <jle`> ah that does sound a bit more reasonable, to be able to do (a -> m c) instead of (a -> c) to branch on a new IO ation in case of error
03:35:56 <haasn> (Or, even better, lift doSomethingElse into EitherT and just use bind; moving this error-handling thing to the top level)
03:36:01 <haasn> (Depends on where and when you want your errors)
03:36:09 <jle`> eitherT :: Monad m => (a -> m c) -> (b -> m c) -> EitherT a m b -> m c
03:36:14 <jle`> encapsulates the first pattern
03:36:38 <haasn> Of course, knapper_tech still hasn't told us what doSomethingElse is; so we're left with wild speculation as to what the actual goal is
03:37:20 <knapper_tech> In the case that there are errors, I have no HeistState to return
03:37:56 <knapper_tech> Alright, my function sig can't be HeistState in this case I think
03:38:13 <knapper_tech> It's not guaranteed that the function will return a HeistState
03:38:20 <knapper_tech> It might return nothing
03:38:39 <knapper_tech> and instead spit out an error message
03:38:42 <jle`> you can leave it as Either, in the IO monad, by using runEitherT...then in the monad yuou can treat it like a nomrla Either value
03:38:56 <jle`> ssh lag, sorry
03:39:16 <knapper_tech> I'm really beginning at this area of Haskell, so let's go slow
03:39:51 <jle`> so if you do { res <- runEitherT theetio; ... }
03:40:09 <jle`> in the rest of the do block, you have `res` to access, as an Either [String] (HeistState n0)
03:41:00 <knapper_tech> http://lpaste.net/107168
03:41:04 <knapper_tech> This sucks.  How fix it?
03:41:31 <knapper_tech> The compiler error was that I might return ()
03:42:58 <jle`> knapper_tech: both branches have to return the same type
03:43:10 <knapper_tech> oh, cool
03:43:39 <jle`> if you really really really want your function like that, then you can put a runtime exception there.  but like haasn said, why don't you just "do what you want to do with the h", in the Right h -> branch?
03:43:52 <jle`> the "what you want to do" is presumably of type IO (), right?
03:44:15 <knapper_tech> jle`:  I want to eventually get a string back so I can spit it out of Scotty
03:45:14 <knapper_tech> It's web.  I'm using warp.  Scotty has methods to return strings.  I have used them and they work.  I would like to go from a HeistState to a string.
03:45:42 <jle`> so you want to return it as a response to a scotty route?
03:45:47 <knapper_tech> Yep
03:45:49 <jle`> well, if you want a String at the end
03:45:57 <knapper_tech> I just know how to use strings
03:46:02 <knapper_tech>  there may be a better way
03:46:06 <jle`> is your (HeistState n0) -> String function pure?
03:46:08 <knapper_tech> right now I don't understand the flow control at all
03:46:16 <jle`> i mean, is your function HeistState n0 -> String ?
03:46:22 <jle`> or HeistState n0 -> IO String
03:46:40 <knapper_tech> jle`:  I'm just attempting to write a function that returns HeistState n0
03:46:59 <jle`> we have to look further ahead; how would you turn that HeistState n0 into a string?
03:46:59 <knapper_tech> I have seen other functions from HeistState -> x -> y -> z -> String
03:47:13 <jle`> okay
03:47:43 <jle`> in that case, you can make your function EitherT [String] IO (HeistState n0) -> IO String, right?
03:47:47 <jle`> is that what you want in the end?
03:48:12 <jle`> hm
03:48:14 <jle`> if you're using scotty
03:48:17 <knapper_tech> builder <- maybe (error "oops") fst $
03:48:17 <knapper_tech>          renderTemplate heistState "simple"
03:48:17 <knapper_tech>     toByteStringIO B.putStr builder
03:48:27 <jle`> why don't you have the Left case create a scotty route failure
03:48:29 <knapper_tech> heistState is pretty obviously a HeistState
03:49:03 <knapper_tech> jle`:  I'd like to just get to a stopping point with something that compiles right now.
03:49:37 <jle`> see, your function that returns IO (HeistState n0) either doesn't make sense, or isn't what you need in the long run
03:50:00 <knapper_tech> why not?
03:50:05 <jle`> it doesn't fit into any sort of meaningful architecture, really
03:50:12 <knapper_tech> how do you know?
03:50:28 <jle`> unless you go the route of a runtime exception
03:50:39 <jle`> which probably isn't what you want, if you are using scotty
03:51:07 <Ainieco> hello
03:51:10 <jle`> what you can do is just use runEitherT inside whatever block you are using to handle your route, and then branch on there
03:51:29 <Ainieco> how to create instance of deepseq-1.3.0.2:Control.DeepSeq.NFData for record type?
03:51:48 <knapper_tech> jle`:   honestly this doesn't make sense either.  I would never initialize my HeistState in every route
03:52:19 <knapper_tech> I should be binding the HeistState before the Scotty do block.
03:52:21 <jle`> knapper_tech: if you really really want to handle it with a runtime exception --- which sort of makes sense here if it is the result of an IO error
03:52:43 <jle`> then you can write an Either [String] (HeistState n0) -> HeistState n0 function
03:52:45 <jle`> using pattern matching
03:53:05 <Ainieco> or is there a way to workaround "No instance for (deepseq-1.3.0.2:Control.DeepSeq.NFData MyRecordType)" error without creating NFData instance for MyRecordType?
03:53:10 <jle`> but if this is all done before, you can just have...your thing "not" initialize scotty
03:53:19 <jle`> you initialize scotty inside a do block, right?
03:53:31 <jle`> you can just have the left case not initialize scotty, and the right case initialize it, with the h
03:54:37 <knapper_tech> jle`:  yes, main = do; setup; scotty port = do...
03:54:46 <haasn> jle`: if you're in IO, you don't want runtime exceptions/error/pattern match failures; since we can throw actual IO exceptions
03:54:51 <haasn> 2. a pattern match failure has *never* helped *anybody*
03:55:09 <haasn> (unless I misinterpreted)
03:55:12 <jle`> knapper_tech: where do you actaully run scotty?
03:55:21 <jle`> in main?
03:55:48 <jle`> how would your Scotty routes get your HeistState?
03:56:16 <jle`> oh
03:56:21 <jle`> that should be a dollar sign, right?
03:56:23 <jle`> not an equals sign
03:56:25 <knapper_tech> http://lpaste.net/107169
03:56:31 <knapper_tech> I
03:56:31 <Ainieco> anyone?
03:56:33 <knapper_tech> Don't konw
03:56:35 <jle`> that makes a lot more sense
03:56:40 <jle`> you wrote scotty port = do
03:56:43 <jle`> but you meant scotty port $ do
03:56:43 <Ainieco> deepseq-th doesn't work with 4.8 base
03:57:06 <knapper_tech> um.  okay =)
03:58:36 <knapper_tech> so,....if I'm already in a do block,
03:58:51 <jle`> knapper_tech: i added an annotation http://lpaste.net/107169
03:59:17 <jle`> that should demonstrate what i'm talking about
03:59:21 * hackagebot MonadCatchIO-transformers 0.3.1.2 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.3.1.2 (AriePeterson)
04:00:02 <quchen> Hackage rebuilds its docs once a day, no?
04:01:05 <mcjohnalds> Does anyone know what I should use for storing a 2d array of a data type `data Cell = Bool Bool Bool Bool`
04:01:36 <mcjohnalds> Of constant size, but I need to update and read elements a lot
04:02:07 <quchen> Vector+ST?
04:03:11 <pjdelport> mcjohnalds: You could use a STUArray and encode your cell as a Word8?
04:03:25 <pjdelport> (if compactness is important)
04:03:37 <mcjohnalds> quchen: I'm not familiar with either of them, I didn't think Vector could easily do 2D arrays
04:04:04 <adimit> yeah, i would use some binary numeric representation for the cells, and bitwise ops to mutate them. Especially if you know cell size is constant.
04:04:22 * hackagebot console-program 0.3.1.4 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.1.4 (AriePeterson)
04:04:33 <mcjohnalds> Oh ok, that shouldn't be too difficult, thanks!
04:04:34 <adimit> mcjohnalds: it doesn't need to. You use a vector of a binary data type. that type encodes the second dimension. The vector remains one-dimensional.
04:04:39 <pjdelport> With Vector, you'd have to manually do the equivalent of Ix (a la C or such)
04:05:19 <quchen> mcjohnalds: Array has 2D indexing (n-D, in fact) baked in, but its API is very limited. Vector is a 1-D "array", but if you combine it with Ix (for 2D indexing) you get nice 2D vectors. You can also use `Vector (Vector a)` to represent 2D, of course.
04:05:29 <quchen> And ST allows you to do the mutable updates efficiently.
04:05:48 <quchen> So there are really two subproblems here: 2D vector, and mutable updates.
04:06:13 <pjdelport> quchen: What are the limitations of the Array API relative to Vector?
04:06:38 <mcjohnalds> Oh, i'm not sure that it *has* to be immutable, IDK how fast immutable arrays are
04:07:15 <quchen> pjdelport: Vector just has *much* more.
04:07:18 <quchen> Array: http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array.html
04:07:23 <quchen> Vector: http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector.html
04:07:26 <mcjohnalds> Well for one Array can't store any datatype, only some simple built in ones :(
04:07:36 <Ainieco> while benchmarking with criterion is it possible to avoid nf in favor of something everett equially strict but without need of specifying NFData instances?
04:07:47 <pjdelport> mcjohnalds: Array can store any data type.
04:07:59 <quchen> mcjohnalds: What? Array can store anything
04:08:07 <Ainieco> s/everett//
04:08:18 <haasn> mcjohnalds: Are you thinking of UArrays?
04:08:32 <pjdelport> mcjohnalds: What i suggested with further packing to Word8 is only for further space efficiency.
04:08:33 <quchen> The indices have to be Ix, but the data is fully polymorphic.
04:08:47 <mcjohnalds> Oh yea, I was looking at IArray lol
04:09:35 <Ainieco> hello?
04:09:43 <mcjohnalds> Ok, well both Array and Vector look pretty great, I'm probably too lazy to use Word8s but thanks! I know what to look at now
04:10:06 <quchen> IArray is also fully polymorphic.
04:10:57 <quchen> (Also, it's a class, not a type.)
04:11:21 <mcjohnalds> Oh, `IArray UArray Foo` then I guess
04:12:31 <quchen> Ah, then we're in unboxed territory, and that's limited to a few content types, yes.
04:15:02 <Ainieco> geez how is deepseq-generics is more superior to th version? https://github.com/hvr/hs-deepseq-th/pull/7
04:15:23 <pjdelport> mcjohnalds: You can just use a normal STArray then, if you need mutation.
04:15:32 <pjdelport> (without the unboxing)
04:15:33 <Ainieco> i've already wrote 100 lines of standalone deriving and instance boilerplate!
04:16:28 <tr444> People awake at this hour?
04:16:33 <Ainieco> Can't make a derived instance of ‚ÄòGeneric StdGen‚Äô D:
04:16:44 <mcjohnalds> Ainieco: Oh yea know that I know I just have to use an unboxed array there's tons of choices, I'll probably play around with some of them
04:16:49 <mcjohnalds> boxed*
04:16:53 <mcjohnalds> Uhh
04:18:00 <jle`> tr444: it's usually daytime somewhere in the world
04:18:05 <jle`> ...at least i think that's how it works
04:18:31 <Ainieco> argh
04:18:34 <tr444> Can someone explain to me how the read function works? Using ":info read" I see:
04:18:35 <tr444> read :: Read a => String -> a 	-- Defined in `Text.Read'
04:18:37 <tr444> So it's a stand-alone function. It's not part of the Read type class.
04:18:38 <tr444> My question is, when I do
04:18:39 <tr444> read "5" :: Int
04:18:40 <tr444> how does Haskell know what to do? Does the function "read" look at the resulting type inside of it somehow?
04:18:51 <Ainieco> how can i "deriving instance Generic (StdGen)" make it work?
04:18:59 <tr444> jle`: lol yeah
04:19:23 * hackagebot parsec-extra 0.1.0.5 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.5 (AriePeterson)
04:19:32 <Ainieco> it looks like there is no way to create NFData instance for StdGen
04:19:33 <quchen> Ainieco: Why do you want a Generic instance for StdGen anyway?
04:19:38 <donri> Ainieco: http://stackoverflow.com/a/10857227
04:19:49 <jle`> tr444: basically, for every type instancing Read, it has a "read" function defined.  that's the idea of a typeclass
04:19:54 <Ainieco> quchen: I want NFData instance of my record type, one field of it is StdGen
04:19:55 <r444> tr444: poser
04:20:03 <jle`> tr444: GHC just picks the one that matches the type you request
04:20:05 <pjdelport> tr444: That's type classes at work. Each Read instance provides its own version of the Read methods, and the type class determines which instance to use based on type inference (or explicit types)
04:20:07 <knapper_tech> how do I search for methods that accept HeistState?  I just want to do something trivial to my HeistState to get the code to compile
04:20:07 <donri> not being able to derive instances for stdgen is a feature of generic (well, standalone-deriving)
04:20:14 <knapper_tech> I would prefer to do nothing.  Can I do that?
04:20:23 <donri> being able to with th is a misfeature
04:20:23 <jle`> knapper_tech: const (return ()) ?
04:20:24 <Ainieco> quchen: does it make sense?
04:20:33 <donri> sometimes misfeatures are convenient :P
04:21:00 <Ainieco> donri: oh, so there is no way to create NFData for record type wich fields contain StdGen?
04:21:01 <donri> basically th allows breaking module boundaries
04:21:20 <quchen> Ainieco: You could just write the instance yourself and skip that field. "rnf (Foo a b c d _ e f) = rnf (a,b,c,d,e,f)"
04:21:33 <donri> duno, it might be possible to handwrite the instance if it doesn't require the constructor
04:21:41 <jle`> tr444: so you have a String -> Int, a String -> Bool, a String -> Double, etc...all those types define a String -> themselves, as the Read typeclass demands.  GHC picks the function that unifies/matches with the type you are asking for.  If it's "4" :: Int, it's not going to pick the String -> Bool one
04:22:03 <jle`> tr444: it's not the "function" that has to "know"; every read function is a unique, separately compiled, defined-in-a-different-place function
04:22:10 <r444> argh, it highlights me when someone are referring to tr444 :(
04:22:10 <donri> arguably random should depend on deepseq and provide the instance itself
04:22:21 <jle`> it's GHC/Haskell that chooses which function you mean
04:22:34 <r444> can't i be unique with this kind of shitty nickname?
04:22:42 <tr444> r444: sorry. will fix. coincidence.
04:22:43 <Ainieco> quchen: is there GHC extension or something to replace NFData altogether it looks like a lot of work to make an instance of it
04:22:51 <jle`> sorry r444 :'(
04:23:17 <jle`> h43j242: so it's like...you know how the '1' literall in Haskell is polymorphic?  '1' can be read as an Int or a Double or an Integer or a Float or a Rational, etc.
04:23:32 <r444> it's not your fault, guys, just let me grumble a little :|
04:23:36 <quchen> Ainieco: NFData instances are usually very short. What's your data type?
04:23:50 <donri> @hoogle StdGen
04:23:50 <lambdabot> System.Random data StdGen
04:23:50 <lambdabot> System.Random getStdGen :: IO StdGen
04:23:50 <lambdabot> System.Random mkStdGen :: Int -> StdGen
04:24:02 <glass-soldier> hi, i'm looking into representing 3D meshes in some boundary representation, however I also need to be able to operate on objects with edges, vertices or faces missing
04:24:03 <h43j242> jle`: so all of these different read methods are still outside the Read type class arent they
04:24:11 <r444> h43j242: thanks
04:24:14 <Ainieco> quchen: record with 50 fields mostly of other record types with large amount of fields too
04:24:14 <jle`> the '1' doesn't decide whether or not it wants to be what type...GHC/haskell picks the specific '1' that it wants, based on the type; a 1  Double and a 1 Integer and a 1 Rational
04:24:19 <jle`> are completely different things
04:24:19 <h43j242> r444: sure
04:24:24 <jle`> 1 Int has nothing to do with 1 Double
04:24:27 <glass-soldier> and the half-edge data structure is not able to do that, any ideas?
04:24:56 <jle`> h43j242: most of them are defined in the instance declaration, I think...
04:25:03 <jle`> but they are all just normal functions
04:25:17 <jle`> readInt :: String -> Int; readInt = read
04:25:33 <pjdelport> h43j242: You can think of type classes as defining an interface, only; the instances for specific types define the method implementations.
04:25:33 <jle`> that's how you can sort of "get" the specific read function associated with the Int instance of Read
04:25:36 <Ainieco> quchen: i've already create around 100 line of braindead boilerplate code but there are a lot left undone and i'm ready to give up on this because it's just so brain dead a can't stand it
04:25:48 <donri> Ainieco: deepseq-th might be better suited for this (questionable) use case (that of adding orphan instances to types outside your control); deepseq-generics is preferable for use with your own types and classes and then you don't need standalone-deriving or instance boilerplate
04:25:51 <pjdelport> (Although classes can also provide default implementations of methods.)
04:25:51 <jle`> now note that if you try doing readInt "5" :: Double, it doesn't work
04:25:56 <Ainieco> donri: it's deprecated
04:26:26 <Ainieco> donri: https://github.com/hvr/hs-deepseq-th/pull/7
04:26:46 <donri> well you could comment with your use case and see if the maintainer thinks it's sufficient to keep it alive
04:27:02 <jle`> ghc sees "okay they want one of the many 'read' functions I have at my disposal...i have a readInt, a readBool...which one do i think they want?" and it picks it based on inference, and uses that one.  so it's not like "the read function chooses which type"; it's tht every type has its own unique read function, and GHC picks which one to "put there"
04:28:56 <h43j242> jle`: ":info readInt" doesn't find anything
04:29:08 <jle`> h43j242: i made up the name :)
04:29:18 <jle`> sorry
04:29:21 <jle`> i also defined it earlier
04:30:09 <glass-soldier> any ideas how I can make something like a half-edge data structure that can also represent objects without edges? :)
04:31:09 <donri> confusingly, there *is* a generic read function that you can pass around and everything, but you can't apply it because any time you do the type checker substitutes in the relevant type-specific function or gives you an ambiguity error
04:33:39 <jkarni> donri: what's the generic read?
04:34:02 <donri> but it is splitting hair; even without type classes a generic function can be specialized to some types as an optimization etc
04:34:06 <knapper_tech>     Couldn't match expected type ëBuilderí
04:34:06 <knapper_tech>                 with actual type ëMaybe (Builder, MIMEType)í
04:34:08 <donri> :t read
04:34:09 <lambdabot> Read a => String -> a
04:34:57 <h43j242> donri: so where are all the other "read" functions? ":info read" only finds this general one
04:35:41 <knapper_tech> jle`: gotta get from Maybe (Builder, MIMEtype) to Builder.  No idea why Builder needs to return MIMEType.  it's from Blaze
04:35:43 <donri> h43j242: they don't necessarily have top-level names but you can disambiguate to have the type checker give you a specialized variant
04:35:50 <donri> :t read :: String -> Int
04:35:51 <lambdabot> String -> Int
04:36:34 <knapper_tech> sorry, that's Heist's renderTemplate output
04:37:45 <h43j242> so basically, i shouldn't worry about it? "it's an implementation detail" is an answer i kind of like when it can be used
04:37:51 <donri> knapper_tech: you could try fold . fmap fst
04:38:35 <donri> which might be the same as foldMap fst, hmm
04:38:54 <pjdelport> h43j242: What are / were you worrying about?
04:39:53 <h43j242> pjdelport: about where all the different read functions come from, and why they aren't all listed when I do ":info read"
04:40:12 <pjdelport> h43j242: Ah, they come from instance declarations, yeah.
04:40:18 <knapper_tech> donri: foldr?  fold not in scope
04:40:25 <donri> knapper_tech: Data.Foldable
04:40:28 <h43j242> pjdelport: which instance? like Int?
04:40:35 <h43j242> or Num?
04:40:36 <pjdelport> h43j242: :info Read will list the instances for you
04:40:55 <donri> > foldMap fst (Just ("hi", 123))
04:40:56 <lambdabot>  "hi"
04:41:07 <donri> > foldMap fst Nothing :: String
04:41:08 <lambdabot>  ""
04:41:20 <donri> should work since Builder is probably a Monoid
04:42:03 <pjdelport> h43j242: Basically, a class declaration like "class Read a where ..." is what declares the type class (where a is the type parameter)
04:42:40 <donri> h43j242: basically type classes add a hidden argument that the type checker inserts for you, so it's like you have read t = case t of Int -> read an int ...; Char -> read a char ...
04:43:05 <pjdelport> h43j242: And then each instance declaration provides an implementation of the class for a specific concrete type, like "instance Read Int where ...", and so forth.
04:43:12 <donri> h43j242: so asking where readInt is is like asking where that sub-expression inside that case switch is :)
04:43:34 <donri> h43j242: but you can get at it with "read Int" (pseudo code) which in real code is (read :: String -> Int)
04:43:50 <knapper_tech> donri: http://lpaste.net/107168
04:44:34 <knapper_tech> donri:  error message currently is...
04:44:37 <h43j242> pjdelport: so what can I do ":info" on in order to see the "read :: String -> Int" function?   I tried ":info Int", ":info Num", ":info Integral"   but no read function is to be seen
04:45:01 <pjdelport> h43j242: To see the source code?
04:45:31 <h43j242> oh
04:45:54 <donri> h43j242: you can see instances with :info Read (note upper case) which tells you what you can substitute "a" for in (read :: String -> a)
04:47:06 <knapper_tech> donri: http://lpaste.net/107168   error is:      Couldn't match expected type ëB.ByteStringí
04:47:07 <knapper_tech>                 with actual type ëMaybe (Builder, MIMEType)í
04:47:07 <knapper_tech>     In the first argument of ëB.putStrí, namely ëbuilderí
04:47:14 <h43j242> donri: but how does Haskell connect Read with read, to make sure that all Read instances implement its own read?
04:47:21 <h43j242> read is not a part of Read, so I ask
04:47:21 <knapper_tech> I tried your solution, but I started diverging into other errors
04:48:33 <pjdelport> h43j242: The Read type class doesn't actually provide read directly; it provides these methods: http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#t:Read
04:48:41 <donri> h43j242: ah ok bad example then. "read" is a single function that happens to be built on the generic functions from Read
04:48:53 <pjdelport> @src read
04:48:54 <lambdabot> read s = either error id (readEither s)
04:49:07 <h43j242> donri: ok THAT explains it
04:49:07 <pjdelport> @src readEither
04:49:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:49:20 <jollygood> trying to learn to use arrays in haskell.  as far as I can tell there is no way to return a copy of the array with one element changed without doing it manually?
04:49:33 <jollygood> with immutable array
04:50:10 <donri> h43j242: so everything we said above is for e.g. "readsPrec" rather than "read"
04:50:18 <h43j242> donri: yeah. makes sense now, thanks
04:50:23 <donri> cool
04:50:33 <h43j242> only that I'm not even gonna bother worrying about readsPrec and readPrec
04:50:39 <h43j242> until I actually wanna create my own Read class
04:50:42 <h43j242> probably never
04:51:27 <donri> h43j242: are you sure you did no other changes to the code? anyway there's probably a function Builder -> ByteString
04:51:43 <knapper_tech> leave/ peace out.  need food
04:51:44 <pjdelport> h43j242: Haskell will give you an error if your instance doesn't provide an implementation of all methods (modulo defaults), so the only way to "miss" a method is to explicitly define it to "undefined" or something.
04:51:46 <donri> sorry that was for knapper_tech
04:52:02 <h43j242> pjdelport: ok
04:52:06 * knapper_tech is away: peace out.  need food
04:52:10 <donri> h43j242: usually best to just derive Read
04:52:16 <donri> data ... deriving (Read)
04:52:17 <jollygood> oh nevermind, // does it
04:52:18 <h43j242> yeah
04:52:25 <pjdelport> jollygood: You can say: arr // [(i, newElement)]
04:52:37 <jollygood> yeah I figured it out right after asking, thanks still
04:53:36 <jollygood> I like how you can change more than one element at the same time. I don't think I saw that in languages that have immutable arrays (usually string)
04:53:38 <pjdelport> h43j242: If you find yourself wanting to do parsing, don't reach for implementing your own "Read", by the way; there are almost always better options.
04:54:37 <h43j242> pjdelport: yeah
04:54:41 <pjdelport> h43j242: Read is more or less supposed to be the inverse of Show, so usually you should be manually defining both, or neither, but not one or the other.
04:55:20 <zwer> pjdelport why more or less?  shouldn't that always be the same?
04:55:25 <zwer> the case*
04:56:24 <jollygood> is there a function like this already? toArray xs = listArray (0, length xs - 1) xs
04:56:25 <donri> IMO usually you should be deriving Show and not have a Read :P
04:56:32 <h43j242> thanks for the help
04:56:52 <donri> Show is useful for ghci debugging; Read not really and there are much better solutions for serialization
04:57:37 <pjdelport> zwer: There are a bunch of things you can Show but not necessarily Read in any sensible way.
04:58:04 <pjdelport> zwer: For example file handles, or things like that.
05:06:02 <pjdelport> jollygood: There isn't a library function like that. It may seem attractive, but it's not very general: index types can be finite, and lists can be infinite, and dealing with either case requires case-specific insight.
05:18:55 <jollygood> pjdelport can Data.Map.map be infinite?
05:19:05 <jollygood> Data.Map.Map
05:22:20 <h43j242> LYAH says: "To be an instance of Num, a type must already be in Show and Eq"
05:22:30 <h43j242> is this true? I don't see the dependence when I do ":info Num"
05:23:06 <pjdelport> jollygood: I think it has to be finite, too.
05:23:08 <ivanm> h43j242: it used to be
05:23:18 <h43j242> ivanm: when did they change it
05:23:21 <ivanm> h43j242: those constraints were removed a few GHC versions ago
05:23:23 <jollygood> pjdelport and yet we still have fromList :)
05:23:26 <h43j242> i see
05:23:29 <h43j242> cool
05:25:54 <gilligan-> newbie question : given a list [FilePath] how can I filter that with doesFileExist :: FilePath -> IO Bool ? my brain is stuck right now
05:26:18 <jollygood> :t filterM
05:26:19 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
05:26:39 <h43j242> is GHC virtually the only compiler used out there, by over 99% of haskell users?
05:26:59 <adimit> h43j242: there's UHC, and JHC. But most people do use GHC.
05:26:59 <haasn> Note: is doesFileExist really what you want?
05:27:13 <pjdelport> jollygood: That's because Map is not contiguous, so you don't need to know what the index bounds are.
05:27:59 <haasn> h43j242: ivanm: That's a divergence from the report afaik
05:27:59 <gilligan-> haasn, well i have a list of files and i want to filter it down to those that exist. So i guess doesFileExist is right for that ?
05:28:05 <haasn> It's listed in the GHC user manual as such
05:28:06 <jollygood> pjdelport not sure why that matters if fromList to either Map or Array would result in the same thing, infinite loop
05:28:16 <haasn> gilligan-: Yes but why?
05:28:32 <haasn> Do you want to do something else with those files?
05:28:34 <h43j242> ok
05:28:41 <haasn> (Like opening them?)
05:29:20 <gilligan-> haasn, because i am passing those files as arguments to a system process which will fail otherwise - and i want to prevent that (ignoring the nonexistent files)
05:29:36 <gilligan-> haasn, what's the alternative ?
05:29:39 * hackagebot fclabels 2.0.2 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.2 (ErikHesselink)
05:29:56 <haasn> gilligan-: The alternative is pretending all files exist and handling failure gracefully; using doesfileExist for that is really setting yourself up for some trouble
05:30:14 <haasn> gilligan-: For example, what if you're checking 1,000,000 files in a doesFileExist loop; and the first file gets deleted before you're done checking the millionth?
05:30:30 <haasn> Your tool will fail, since you fail to account for the possibility of external changes in between ‚ÄúdoesFileExist‚Äù and doing something with that file
05:31:05 <pjdelport> jollygood: Well, in Map's case, you never have to worry about running out of key space: the keys are provided directly.
05:32:21 <pjdelport> jollygood: With Ix, you can't really avoid having to give the bounds explicitly.
05:32:55 <ivanm> haasn: yes, it was meant to be added to Haskell' but then the process got paused
05:33:13 <gilligan-> haasn, i'll keep it in mind but right now the scenario is rather limited and the files i am checking are very unlikely to change while the code is running
05:33:38 <gilligan-> haasn, valid points though. thank you
05:34:42 <haasn> (Another possible alternative may be to do something like 1. check file A for existence, 2. run tool on A iff it exists, 3. check file B for existence, 4. run tool on B iff it exists, etc.)
05:34:52 <haasn> Rather than 1. check files A-Z for existence, 2. run tool on A-Z at once
05:35:04 <haasn> That way you avoid the filterM thing
05:35:08 <jollygood> pjdelport are you worried that we couldn't make more than maxBound :: Int elements?
05:35:28 <pjdelport> jollygood: So in a sense, "listArray :: Ix i => (i, i) -> [e] -> Array i e" and "fromList :: Ord k => [(k,a)] -> Map k a" take the same parameters: the (i, i) range just takes the place of the tupled k's.
05:35:32 <gilligan-> haasn, yep. that is what i'll be doing
05:37:49 <haasn> So like forM_ files $ doesFileExist >>= bool (return ()) doSomething
05:38:00 <haasn> err, \f -> doesFileExist f
05:38:44 <pjdelport> jollygood: So an analogous version of Map's fromList would be something like: listMap (l, u) as = fromList $ zip [l..u] as
05:38:59 <gilligan-> haasn, good starting point. thank you
05:39:04 <haasn> oh, bool (return ()) x b is just ‚Äúwhen b x‚Äù
05:39:05 <haasn> :t when
05:39:06 <lambdabot> Monad m => Bool -> m () -> m ()
05:39:31 <jollygood> pjdelport I think that having anything other than a zero-based array indices is pretty uncommon. and if you were indeeded worried about maxBound :: Int limitation, then genericLength could be used.
05:39:33 <pjdelport> It still requires specifying the keys, but now just as the same kind of bound that listArray does.
05:40:47 <haasn> Isn't the big difference between Map and Array that Map can dynamically grow (lazily, with the Lazy version) and Array has a fixed size?
05:41:29 <pjdelport> haasn: The big difference is probably that Array is contiguous, while Map isn't
05:41:49 <haasn> Oh, of course; that too
05:41:52 <ivanm> not to mention the constraints on the types
05:42:30 <pjdelport> haasn: The lazy map is still strict in the keys, though.
05:44:53 <jollygood> pjdelport you don't think that 0-based array indices that grow incrementally is a reasonable default for array? most other languages don't even give you ability to set other indices, and I haven't heard a lot of people complain ingabout it
05:45:13 <pjdelport> grow incrementally?
05:46:37 <jollygood> yes, as in 0,1,2.. as far as I can see array allows you to have gaps in between, so that, say, only even indices are available.
05:47:51 <jollygood> :t array
05:47:52 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
05:48:48 <jollygood> or I guess that leaves the other elements unset?
05:50:43 <pjdelport> jollygood: An Array's values can be undefined, but they're still allocated. (If you try to access them, you get bottom.)
05:51:35 <pjdelport> jollygood: It's essentially the same as explicitly setting the index to undefined or (error "uninitialized element")
05:51:53 <pjdelport> (well, s/uninitialized/undefined/)
05:52:18 <mikem> is there a persistwnt database that stores the data in a human readable text format?
05:53:52 <pjdelport> jollygood: There is also Vector, which is a naturally Int-indexed array.
05:53:55 <mikem> something like acid-state but with human readable output, that can be changed with a text editor
05:54:39 <jollygood> yeah I found it. repa too
06:00:38 <trap_exit> i'm trying to figure out what I like so much about haskell
06:00:45 <trap_exit> and now I feel like I understand it
06:00:48 <trap_exit> haskell is precision engineering
06:00:57 <trap_exit> it's like "building mud houses" vs "building skyscrapers"
06:01:05 <trap_exit> type systems ==> precision engineering
06:04:45 <matematikaadit> trap_exit++
06:05:17 <kvanb> trap_exit: for me, it's the confidence I get out of it
06:05:29 <kvanb> I can code for 6 hours straight without testing my program
06:05:33 <trap_exit> the confidence of building out of steel rather than mud
06:05:39 <kvanb> run it once at the end, and there's a 95% chance it'll work first time
06:05:50 <kvanb> when I code javascript I test it every time I delete a comment
06:05:52 <tdammers> it's not about the %
06:05:53 <kvanb> because I don't trust it.
06:05:58 <trap_exit> very different from coding in lisp's repl
06:06:05 <tdammers> it's about the kind of errors you can and cannot produce
06:06:07 <mikem> when storing data in acid-state how do you handle when the records you are storing changes, and your database is no longer valid?
06:06:25 <trap_exit> mikem: precisely this reason is why I'm still using json
06:06:30 <kvanb> fourtunately all of the errors I can't find are the ones the compiler stops.
06:06:58 <tdammers> also, it's not just that the type system somewhat passively protects you from bugs
06:07:13 <tdammers> you can actively use it to build more robust code and add safeguards
06:07:24 <tdammers> (Int, Int) -> (Int, Int)
06:07:27 <tdammers> or:
06:07:43 <tdammers> Speed -> Speed
06:08:06 <tdammers> both can carry the same information (assuming that Speed is defined as data Speed = Speed Distance Duration)
06:08:20 <tdammers> (and newtype Distance = Distance Int, etc.)
06:08:23 <trap_exit> type Speed = (Int, Int)
06:08:27 <kvanb> also, immutability
06:08:29 <kvanb> is so nice.
06:08:35 <kvanb> I hate mutability
06:08:41 <tdammers> trap_exit: that's just an alias though, it won't protect you
06:08:48 <tdammers> the data Speed one however will
06:08:58 <trap_exit> tdammers: yes, but it looks nice in type annotations (for function)
06:09:08 <tdammers> trap_exit: yes, but so does the newtype
06:09:11 <trap_exit> I annotate every function with it's type, and I'd prefer to see Speed -> speed rather than (Int, Int) -> (Int, Int)
06:09:24 <tdammers> and the newtype has the added benefit that the compiler typechecks it
06:09:30 <kvanb> or forbid, int -> int
06:09:31 <kvanb> ;)
06:09:40 <tdammers> Speed Duration Distance won't work, because it's supposed to be Speed Distance Duration
06:09:51 <tdammers> voila, you have just eliminated a very easy to commit error
06:10:02 <kvanb> I don
06:10:08 <kvanb> t really bother newtyping to that extent
06:10:25 <_Vi> How do I split Data.Conduit dataflows and merge them later? I've tried, but don't know how to complete the function: http://ideone.com/ZlA5jK
06:10:34 <kvanb> I feel that I don't make those kinds of errors
06:12:10 <ajcoppa> trap_exit: do you understand what tdammers said? newtypes are actually enforced by the compiler, types allow you to call it by the semantic name but don't enforce anything extra
06:14:00 <tdammers> if I had defined `type Distance = Int; type Duration = Int`, then the compiler would allow me to use them interchangeably
06:14:10 <trap_exit> ajcoppa: no, I don't understand
06:14:44 * hackagebot yesod-mangopay 1.7.0 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.7.0 (FelipeLessa)
06:14:59 <ajcoppa> with "type", i can pass any old Int or (Int, Int) into a function that takes a Distance or a Duration
06:15:24 <ajcoppa> well, ignore the (Int, Int) part for notw
06:15:42 <ajcoppa> basically "type" allows you to use e.g. Distance and Int interchangeably
06:16:28 <tdammers> ...or Distance and Duration
06:16:36 <tdammers> because to the compiler, they're the same thing
06:16:42 <tdammers> just alternate names for Int
06:16:42 <ajcoppa> "newtype" means that if i say that a function takes a Distance, i must use a Distance constructor to wrap it. i can't accidentally pass in any random integer that semantically means something different
06:18:29 <trap_exit> ajcoppa: so "newtype" is like "Data"
06:18:30 <trap_exit> got it
06:19:27 <ajcoppa> i wouldn't say it exactly like that -- there are some differences
06:19:44 * hackagebot focus 0.1.2 - A general abstraction for manipulating elements of container data structures  http://hackage.haskell.org/package/focus-0.1.2 (NikitaVolkov)
06:19:52 <petercommand> trap_exit: newtype is a bit different from Data
06:20:06 <ajcoppa> good info here: http://www.haskell.org/haskellwiki/Newtype
06:22:17 <pjdelport> You can think of newtype as giving you a subset of the functionality of data, along with the guarantee of no run-time overhead.
06:25:35 <adimit> I always thought of it as a type alias with *compile time* representation (i.e. renaming (the copy of a) type)
06:26:09 <adimit> (since type aliases with 'type' are resolved at a lexical/parsing level, and the type checker doesn't need to bother with them.)
06:29:59 <MagneticDuck1> pjdelport: *superset? A newtype instance coupled with a typeclass instance for the newtype gives you a superset of the functionality of the data, right? It seems to generally be used like that
06:31:27 <pjdelport> MagneticDuck1: I mean a subset of the functionality in that it's a restricted data declaration; that is, it only allows one constructor with one field.
06:32:02 <MagneticDuck1> ahk
06:32:16 <MagneticDuck1> was not interpreting in accordance with your intention
06:33:27 <haasn> MagneticDuck: Sometimes a subset, too
06:33:51 <MagneticDuck> yes, if you want to free it from typeclass instances for some reason
06:34:05 <haasn> newtype Natural = Natural Integer
06:34:21 <MP2E> ok I don't know how anyone has zsh working here, I have like 5 different options enabled for it and I even explicitly disabled bash, and yet somehow bash is still getting selected as the login terminal
06:34:28 <MP2E> wtf
06:34:51 <MagneticDuck> go to #haskell-blah, we can help you with that :D
06:35:07 <Forgetaboutit> MP2E: did you set zsh in /etc/passwd?
06:36:05 <MP2E> I didn't, but I just tried that and it didn't change anything for some reason
06:36:14 <MP2E> echo $SHELL is still showing bash after a relogin
06:36:18 <Forgetaboutit> not sure if you have to login again
06:36:32 <Forgetaboutit> uh
06:36:51 <MP2E> oh wait
06:36:55 <MP2E> I had to log out of all instances
06:36:58 <MP2E> now it works, thanks Forgetaboutit
06:37:36 <MP2E> rofl I just realized this is #haskell, sorry
06:37:41 <MP2E> I meant to put this in #nixos tbh
06:37:48 <Forgetaboutit> MP2E: nevermind :)
06:51:44 <nclarke> Is it just me seeing an exodus?
06:51:52 <td123_> so I'm using a jar command in my haskell program, anyone have any opinions on whether I should package it in the cabal package?
06:52:29 <td123_> it's a 3rd party provided jar which might be more reason to not include it
07:00:01 <Forgetaboutit> what are the possibles ways in Haskell to "send" data from multiple threads to one?
07:02:36 <donri> @google marlow parallel concurrent haskell
07:02:37 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
07:02:38 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
07:02:57 <jkarni> Forgetaboutit: also http://en.wikibooks.org/wiki/Haskell/Concurrency if you need a quick answer
07:03:10 <jkarni> Forgetaboutit: although simon marlow's book is really wonderful
07:03:13 <donri> @where+ parconc http://chimera.labs.oreilly.com/books/1230000000929
07:03:13 <lambdabot> Nice!
07:03:43 <Forgetaboutit> donri, jkarni: thanks, will check that out :)
07:03:57 <donri> Forgetaboutit: i would default to stm unless i had a reason not to
07:04:36 <Forgetaboutit> is STM well-suited for a producer-consumer design?
07:04:53 <donri> sure
07:04:57 <donri> @hackage stm
07:04:58 <lambdabot> http://hackage.haskell.org/package/stm
07:05:17 <donri> it's what http://hackage.haskell.org/package/pipes-concurrency is built on for example
07:05:21 <bennofs> Forgetaboutit: for producer/consumer, another possibility is to use pipes with pipes-concurrency
07:16:12 <bollu> could someone explain to me how Reader is supposed to be used? I don't get it - it takes a function, and then constructs a readerT? like, how does one *use* this readerT? (I'm referring to Control.Monad.Trans.Reader)
07:16:42 <ajcoppa> bollu: do you understand monad transformers generally?
07:17:14 <bollu> ajcoppa: nope.
07:17:29 <bollu> ajcoppa: oh, the T stands for a transformer?
07:17:36 <ajcoppa> yep
07:17:52 <bollu> ajcoppa: oh.. so.. well, care to explain to me how it works? :)
07:18:50 <ajcoppa> i'm not an expert so i'm going to do my best to introduce the concept, and someone else will have to carry on from there
07:19:14 <bollu> ajcoppa: sure thing
07:19:33 <matematikaadit> bollu: do you wanna understand Reader or ReaderT?
07:19:37 <bollu> ajcoppa: I have a background - I know that transformers are used to attach bits of functionality to a Monad
07:19:44 <bollu> matematikaadit: which makes more sense to a newbie?
07:20:19 <ajcoppa> bollu: if you just want to understand Reader, monad transformers can probably be saved for later
07:20:25 <bollu> ajcoppa: ah, okay
07:20:27 <ajcoppa> or at least divorced from the context of just learning about Reader
07:20:28 <bollu> ajcoppa: reader it is then
07:21:35 <bollu> ajcoppa: like, how would I use the Reader monad?
07:22:19 <joshc> the type 'Reader r a' represents a computation which returns an 'a', but which might consume a read-only environment of type 'r'
07:22:46 <ajcoppa> i think the explanation here is pretty good: http://www.haskell.org/haskellwiki/All_About_Monads#The_Reader_monad
07:22:51 <bollu> joshc: hm, interesting.
07:22:59 <bollu> joshc: can't you pass the r as a parameter? why use a monad?
07:23:00 <nclarke> `Reader` monad basically lets you run a computation with some context, whilst not having to pass that context around explicitly
07:23:12 <bollu> nclarke: that makes more sense
07:23:12 <nclarke> `ReaderT` lets you add this functionality to another monad
07:23:18 <ajcoppa> bollu: exactly. with Reader you don't have to change all of your methods to pass that context around manually
07:24:03 <Ainieco> hello
07:24:25 <bollu> ajcoppa: isn't it somewhat of a hack? like, "oh look, I want to avoid passing a parameter, so I'll create create a _Monad_!"
07:24:29 <bollu> Ainieco: hey!
07:25:13 <Ainieco> i want to "instance NFData Gr" but Gr have two type arguments, what to do? instance NFData a b => NFData (Gr a b) doesn't work either because to many arguments to NFData
07:25:45 <donri> bollu: well it avoids mistakes like passing the wrong environment around and makes it easier to refactor when something doesn't need the environment at all or suddenly does
07:26:14 <Ainieco> is it possible to add forall somehere there?
07:26:38 <donri> Ainieco: (NFData a, NFData b) =>
07:26:38 <bollu> donri: hm, okay. So, how do I construct a reader? I can't access its data constructor.
07:27:00 <joshc> > runReader (do x <- ask; return (x + 1)) 4
07:27:00 <Ainieco> donri: oh, thanks!
07:27:02 <lambdabot>  5
07:27:59 <nclarke> > runReader (ask >>= return . reverse) "Hello World"
07:28:00 <lambdabot>  "dlroW olleH"
07:28:19 <donri> bollu: you'll rarely use the constructor directly. just write things in terms of monads and use "lift" for any non-Reader monad operations, then apply runReaderT
07:28:22 <bollu> nclarke: thanks, the explicit >>= makes it much simpler
07:28:37 <nclarke> And you can use ReaderT to add this to another monad:
07:28:54 <nclarke> > runReaderT (ask >>= return . reverse) "Hello World" :: Maybe String
07:28:55 <lambdabot>  Just "dlroW olleH"
07:29:03 <nclarke> > runReaderT (ask >>= return . reverse) "Hello World" :: Either Int String
07:29:04 <lambdabot>  Right "dlroW olleH"
07:29:18 <bollu> nclarke: so, can you break the expression runReader (ask >>= return . reverse) "Hello World" down?
07:29:28 <bollu> you're clearly giving two parameters to runReader
07:29:33 <bollu> the 2nd parameter is a String
07:29:35 <donri> :t runReaderT (lift putStrLn =<< ask)
07:29:37 <lambdabot>     Couldn't match type ‚ÄòReaderT r m a‚Äô with ‚ÄòIO ()‚Äô
07:29:37 <lambdabot>     Expected type: String -> ReaderT r m a
07:29:37 <lambdabot>       Actual type: String -> IO ()
07:29:41 <donri> :t runReaderT (lift . putStrLn =<< ask)
07:29:41 <nclarke> The first is the computation to run in the environment
07:29:42 <lambdabot> String -> IO ()
07:29:48 <nclarke> The second is the environment
07:30:13 <donri> @unmtl Reader String a
07:30:13 <lambdabot> String -> a
07:30:20 <joshc> :t ask
07:30:21 <bollu> :t ask
07:30:21 <lambdabot> MonadReader r m => m r
07:30:22 <lambdabot> MonadReader r m => m r
07:30:25 <donri> in fact -> is the trivial reader monad
07:30:53 <donri> in a way runReaderT just unwraps the newtype giving you this trivial -> monad
07:30:57 <int-e> @type ask >>= tell
07:30:58 <bollu> runReaderT ask "HelloWorld"
07:30:58 <lambdabot> (MonadWriter a m, MonadReader a m) => m ()
07:31:02 <bollu> > runReaderT ask "HelloWorld"
07:31:04 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
07:31:04 <lambdabot>    arising from a use of ‚ÄòM2156528637059806416349.show_M2156528637059806416349‚Äô
07:31:04 <lambdabot>  The type variable ‚Äòm0‚Äô is ambiguous
07:31:04 <lambdabot>  Note: there are several potential instances:
07:31:04 <lambdabot>    instance [safe] GHC.Show.Show a =>
07:31:06 <jkarni> > runReader (do { w <- ask; return $ reverse w }) "Hello world"
07:31:08 <lambdabot>  "dlrow olleH"
07:31:17 <jkarni> ^^ might be a bit easier to understand
07:31:42 <donri> bollu: ambiguous monad there, try runReader
07:31:47 <Ainieco> what does "instance NFData StdGen" mean? there is no "where". it compiles just fine and throws nothing at runtime...
07:31:50 <donri> or select a monad
07:31:52 <bollu> jkarni: so, in the do block, what context is the do operating in? like, whats the monad in that case?
07:32:05 <jkarni> bollu: Reader
07:32:10 <joshc> well, Reader String
07:32:16 <donri> Ainieco: it means use the default definitions
07:32:17 <bollu> :t Reader
07:32:18 <lambdabot>     Not in scope: data constructor ‚ÄòReader‚Äô
07:32:18 <lambdabot>     Perhaps you meant ‚ÄòReaderT‚Äô (imported from Control.Monad.Reader)
07:32:26 <int-e> runreaderT ask === return
07:32:40 <donri> Ainieco: for NFData it only works correctly for types that are already fully evaluated
07:32:41 <bollu> I'm sooo confused
07:32:49 <donri> Ainieco: but it doesn't check this for you
07:32:56 <int-e> :t reader
07:32:57 <lambdabot> MonadReader r m => (r -> a) -> m a
07:33:14 <Ainieco> donri: thank you for an explanation!
07:33:22 <joshc> MonadReader just muddles everything :\
07:33:41 <int-e> bollu: Reader is a type alias nowadays, Reader r a = ReaderT r Identity a
07:33:47 <donri> mtl is easier; transformers simpler :)
07:34:11 <bollu> int-e: is writer any better? :)
07:34:31 <bollu> :t writer
07:34:33 <int-e> bollu: huh? it's different
07:34:33 <lambdabot> MonadWriter w m => (a, w) -> m a
07:34:35 <joshc> that depends, do you understand monoids? :)
07:34:58 <donri> bollu: basically Reader *is* ReaderT but with the base monad set to Identity, a monad that adds no structure
07:35:05 <bollu> int-e: yeah, but I assumed they would be similar so that I could draw parallels
07:35:17 <nclarke> bollu: I wouldn't worry about MonadReader
07:35:33 <bollu> donri: in that case, care to tell me what transformers do?
07:35:35 <nclarke> To understand Reader, I would just focus on `Reader`, `runReader`, and `ask`
07:35:41 * joshc nods
07:35:43 <bollu> nclarke: ah, thanks
07:35:56 <nclarke> Everything else just builds on that
07:36:04 <joshc> and don't let mtl confuse you, 'ask' has type 'Reader r r'
07:36:29 <donri> bollu: it's the package providing these monad transformers
07:36:36 <ajcoppa> bollu: monad transformers allow you to perform computations that use multiple different effects (from different monads)
07:37:08 <bollu> ajcoppa: so, simplest example?
07:37:11 <ajcoppa> e.g. ReaderT lets me take a monad that i have, like State or IO or Writer, and "add" the ability to read from a shared environment on top of it
07:37:38 <bollu> unrelated: edwardk = lens guy edwardk?
07:37:42 <bollu> ajcoppa: go on
07:37:42 <ajcoppa> imagine a computation where i want to be able to read some shared configuration (Reader) and write out some logging data (Writer)
07:37:58 <edwardk> bollu: yes
07:38:14 <ajcoppa> i could wrap a ReaderT around a Writer to do that
07:38:28 <donri> bollu: mtl is another package, building on transformers, using type classes to minimize the number of "lift"s required and moving the significance of the order of the monad stack to the call site
07:38:29 <int-e> > runWriter (runReaderT (do ask >>= tell; local reverse (do ask >>= tell)) "hello")
07:38:30 <lambdabot>  ((),"helloolleh")
07:38:55 <bollu> :t ask
07:38:57 <lambdabot> MonadReader r m => m r
07:38:59 <bollu> :t tell
07:39:00 <lambdabot> MonadWriter w m => w -> m ()
07:39:09 <int-e> :t local
07:39:10 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
07:39:10 <bollu> :t local
07:39:11 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
07:39:37 <ajcoppa> ask gives you the shared environment in a Reader computation. tell writes to the shared output in a Writer computation
07:39:55 <bollu> what's the () in the tuple?
07:40:04 <bollu> the return value of the actual expression?
07:40:22 <ajcoppa> () is an empty tuple, basically indicating no useful result
07:40:23 <donri> :t tell
07:40:24 <lambdabot> MonadWriter w m => w -> m ()
07:40:34 <donri> it comes from tell, which ends with return ()
07:40:36 <int-e> (local modifies the value to be read, but the modification has local scope, it only affects the monad action that was passed to the 'local' function.)
07:40:44 <bollu> donri: ohh.
07:40:45 <ajcoppa> the point of tell is just to have the effect of writing a value to shared output
07:41:00 <ajcoppa> it doesn't give back any meaningful value
07:41:16 <bollu> hm
07:41:19 <ajcoppa> make sense?
07:41:19 <bollu> what about State?
07:41:21 <bollu> ajcoppa: yep
07:41:50 <donri> @unmtl State s a
07:41:51 <lambdabot> s -> (a, s)
07:41:53 <ajcoppa> State lets you model computations that can both read from and write to a shared state.
07:42:22 <bollu> ajcoppa: for example?
07:42:36 <donri> ie. a state computation is a function from a state to a computed value and the updated state
07:43:02 <bollu> m a -> m b?
07:43:20 <ajcoppa> do you want an example application of why i might want to use the State monad?
07:43:33 <bollu> ajcoppa: no, an example of it being used
07:43:40 <bollu> ajcoppa: I can see uses for it
07:43:44 <ajcoppa> k
07:43:59 <bollu> ajcoppa: well, state = "state machine" I suppose is where the name came from?
07:44:16 <tdammers> bollu: "State", because it models mutable state
07:44:24 <bollu> tdammers: ah.
07:44:25 <donri> > runState (do modify (+1); get) 1
07:44:26 <lambdabot>  (2,2)
07:44:43 <bollu> :t get
07:44:45 <lambdabot> MonadState s m => m s
07:44:55 <ajcoppa> :t modify
07:44:56 <lambdabot> MonadState s m => (s -> s) -> m ()
07:45:10 <bollu> donri: without do notation?
07:45:11 <donri> > runState (do modify (+1); s <- get; return (s + 2)) 1
07:45:13 <lambdabot>  (4,2)
07:45:42 <int-e> > let step = (do modify (+1); get) in runState (do a <- step; b <- step; c <- step; return (a,b,c)) 0
07:45:44 <bollu> oh, interesting
07:45:46 <lambdabot>  ((1,2,3),3)
07:46:11 <bollu> donri: so it both outputs and updates internal state at the same time
07:46:32 <int-e> :t state
07:46:33 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:46:37 <donri> > runState (put 2 >> get >>= return . (+2)) 1
07:46:38 <lambdabot>  (4,2)
07:46:55 <tdammers> on the imperative side of things, State acts like a context that provides exactly one context-global mutable variable
07:47:13 <bollu> :t put
07:47:14 <lambdabot> MonadState s m => s -> m ()
07:47:15 <tdammers> but it is implemented by passing that variable from one pure function to the next in the chain
07:47:26 <donri> bollu: well runState returns the final state and the return value, so ending with "get" gets you a tuple of the state twice
07:48:06 <bollu> donri: don't understand. but I'll think about this :)
07:48:15 <donri> :t runState
07:48:16 <lambdabot> State s a -> s -> (a, s)
07:48:28 <ajcoppa> bollu: i found this post helpful when i was learning http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/
07:48:38 <donri> > runState (return "value") "state"
07:48:40 <lambdabot>  ("value","state")
07:48:55 <donri> > runState (put "updated state" >> return "value") "initial state"
07:48:56 <lambdabot>  ("value","updated state")
07:49:12 <bollu> ajcoppa: thanks!
07:49:24 <donri> > runState get "state"
07:49:26 <lambdabot>  ("state","state")
07:49:27 <ajcoppa> bollu: more generally, the NICTA course is a *fantastic* way to force yourself through actually implementing functors/applicatives/monads/monad transformers
07:49:33 <ajcoppa> https://github.com/NICTA/course
07:49:39 <bollu> ajcoppa: ooh, ty
07:49:56 <ajcoppa> it is difficult but extremely rewarding. do it and ask questions in here or #haskell-beginners when you get stuck
07:50:09 <bollu> ajcoppa: will do!
07:50:09 <donri> > runState (put "updated state") "state"  -- put returns ()
07:50:11 <lambdabot>  ((),"updated state")
07:50:38 <bollu> donri: because you don't return anything?
07:51:01 <donri> bollu: because the last action returns ()
07:51:23 <bollu> donri: ah
07:51:41 <bollu> donri: still confused, less so though :)
07:52:08 <donri> there's also evalState and execState to only get the final state or final value
07:52:16 <donri> :t evalState
07:52:17 <lambdabot> State s a -> s -> a
07:52:18 <donri> :t execState
07:52:19 <lambdabot> State s a -> s -> s
07:52:21 <bollu> donri: how do you know what's "fina" ?
07:52:24 <bollu> final*
07:52:30 <bollu> when it stops returning?
07:53:36 <donri> it's what isn't monadically bound to anything more, the last action in a do sequence
07:54:21 <donri> note >>= is called bind
07:54:57 <bollu> donri: yep, knew the >>= bit
07:55:15 <donri> well if you mean the final value. the final *state* is determined by the last issued "put" or "modify" or it is the initial state
07:55:29 <donri> well there's also a "state" function that can update the state
07:57:42 <donri> > runState ((,,) <$> state random <*> state random <*> state random) (mkStdGen 123)
07:57:44 <lambdabot>  ((5912679320616661859,5085716927896574010,-5356009888664962999),982125647 14...
07:58:17 <donri> :t state random
07:58:18 <lambdabot> (Random a, RandomGen s, MonadState s m) => m a
07:58:22 <bollu> donri: what the hell, you can apply on a tuple?
07:58:28 <bollu> can use applicative*
07:58:38 <donri> :t (,,)
07:58:39 <lambdabot> a -> b -> c -> (a, b, c)
07:58:45 <bollu> that's aweomse
07:58:48 <donri> it's syntax, nothing to do with applicative :)
07:58:48 <bollu> awesome*
07:59:01 <KorriX> Hi! I have strange problem with Defining instance for Ord: http://lpaste.net/107179 What I'm doing wrong?
07:59:05 <bollu> donri: ah, right, you're just pushing it to State space :)
07:59:14 <donri> > (1,,3) 2
07:59:16 <lambdabot>  (1,2,3)
07:59:20 <bollu> donri: even so, constructing a tuple that way is cool
07:59:33 <donri> this version only works with -XTupleSections though
07:59:41 <donri> but (,,) always works
07:59:44 <bollu> donri: ahh
08:00:31 <bollu> > runState (state random) (mkStdGen 1)
08:00:33 <lambdabot>  (7917908265643496962,545291967 2103410263)
08:01:42 <bollu> what package is the State monad located in?
08:01:54 <dmwit> bollu: transformers, I think
08:02:00 <dmwit> bollu: But mtl has some nice instances.
08:02:20 <donri> it's defined in transformers and re-exported in mtl
08:02:33 <KorriX> Simplified version: http://lpaste.net/107180
08:02:52 <dmwit> KorriX: Ord is a subclass of Eq.
08:03:06 <dmwit> KorriX: So you need an Eq instance of Tick a b c to make an Ord instance of it.
08:03:17 <dmwit> KorriX: Since the Eq instance is derived, it depends on Eq instances for a, b, and c.
08:03:37 <dmwit> KorriX: Hence making an Ord instance for Tick a b c requires an Eq instance for all of a, b, and c, even though you only ever call compare on a values.
08:03:57 <KorriX> dmwit: Thanks
08:04:09 <bollu> dmwit: thanks
08:06:02 <bollu> how normal is it to feel extremely stupid when learning haskell? :)
08:06:12 <donri> it's abnormal not to
08:06:51 <tdammers> unfortunately, you'll keep feeling stupid for quite a while
08:07:17 <bollu> donri: makes me feel much better. tdammers how so? -_^
08:07:30 <tdammers> endosemicofunctoroids and all that
08:07:34 <tdammers> ;)
08:07:54 <bollu> tdammers: heh
08:08:09 <bollu> tdammers: I can't tell if that's a real thing or not >_>
08:09:30 <frerich> bollu: I've been tinkering with Haskell on and off for the last three years, and I still feel stupid very often.
08:09:32 <tdammers> bollu: neither can I :D
08:10:11 <bollu> tdammers: :D frerich: well, haskell seems to have __so much__.
08:10:37 <frerich> Most recent case: a thread on haskell-beginners (beginners!!) about whether functors are injective (I'm somewhat proud that I know what 'injective' means in this case) where somebody writes 'The fact that type constructors are injective is encoded directly into the equality rules for the type system.  In the original paper on System FC, the formal system underlying GHC's core language, this is the rule labeled "Right" in Figure 2 on page 5.'.
08:10:44 <frerich> And the referenced paper is http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
08:11:06 <frerich> So if you open that and look at page 5, you know that if this kinda stuff is discussed on -beginners then you're up for a ride.
08:11:25 <bollu> frerich: xD that's hilarious
08:11:41 <donri> frerich: what, doesn't *everybody* know that?
08:12:10 <frerich> donri: Of course *cough*
08:12:12 <frerich> ;-)
08:12:15 <donri> (:
08:12:21 <frerich> It's right there, page five, figure 2!
08:12:23 <bollu> I don't even know how to read that >_<
08:12:51 <bollu> oh my god, there's "syntactic sugar" in there to
08:12:53 <bollu> too*
08:14:15 <Antoine59> gt/WIN 18
08:14:24 <Antoine59> sorry :(
08:14:56 <bollu> so, if I want to see what >>= looks like on Maybe, how do I specialize it in ghci?
08:15:02 <nclarke> I don't know what the tilde means there
08:16:27 <donri> :t (>>=) `asAppliedTo` Nothing
08:16:29 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
08:16:38 <bollu> donri: oh, ty
08:16:45 <donri> but you don't have that itn ghci
08:16:50 <bollu> donri: aww
08:17:00 <bollu> donri: so the equivalent in ghci?
08:17:04 <bollu> () ? :)
08:17:42 <popx> nclarke: in the system fc paper? I believe tilde is type equality
08:18:31 <Iceland_jack> @kind ~
08:18:32 <lambdabot> parse error on input ‚Äò~‚Äô
08:18:34 <Iceland_jack> @kind (~)
08:18:36 <lambdabot> k -> k -> Constraint
08:19:15 <donri> bollu: it's just const with a special type signature
08:19:18 <donri> :t asAppliedTo
08:19:19 <lambdabot> (a -> b) -> a -> a -> b
08:19:38 <bollu> donri: oh, so it forces specialization
08:19:41 <bollu> neat
08:20:04 <donri> add to ~/.ghci: let asAppliedTo = const :: (a -> b) -> a -> a -> b
08:20:47 <bollu> donri: ahh
08:22:07 <frerich> :t (>>=) `asAppliedTo` (>>=)
08:22:08 <lambdabot> Monad m => (m a -> (a -> m b1) -> m b1) -> (((a -> m b1) -> m b1) -> m a -> b) -> m a -> b
08:23:00 <bollu> frerich: oh my god why did you tell me that you can do that?!
08:25:10 <marchelzo_> Does the Text.Regex regexp module support the ? in regular expressions?
08:26:54 <merijn> nclarke, popx: I'm unsure about the System F paper, but in haskell "a ~ b" forces 'a' to unify with 'b'
08:28:30 <bollu> when you're faced with a new monad, how do you figure out what it does?
08:30:53 <nclarke> So, I am reading "Œì ‚ä¢CO Œ≥ : œÉ1 œÉ2 ‚àº œÑ1 œÑ2" as "Given Gamma, we have a type gamma which exhibits that o1 o2 unifies with t1 t2"
08:30:57 <nclarke> Is that about right?
08:31:30 <nclarke> And then the deduction rules tells us that, in that case, we have a type "right gamma" which exhibits that o2 unifies with t2
08:31:39 <Pythonfant> bollu: I look at the implementation of (>>=)
08:31:59 <bollu> Pythonfant: ah
08:32:05 <popx> merijn: nclarke under 2.1 in the paper ~ is defined as type equality indeed
08:32:29 <donri> bollu: i read the docs ;)
08:32:45 <bollu> donri: :)
08:33:23 <nclarke> i.e. that f a = f b implies that a = b, e.g. f is injective for all type constructors f
08:52:31 <kazagistar> to be fair, I have a hard time finding docs on the details of how a type implements a typeclass quite often
08:54:10 <kazagistar> even something like Eq a => Eq (Maybe a) does not, afaik, specify if nothing is before or after, you just have to guess or look in the source
08:54:19 <donri> yeah, it would be nice if haddock linked [source] for instances
08:55:12 <donri> before or after?
08:55:40 <kazagistar> > Just 3 > Nothing
08:55:42 <lambdabot>  True
08:56:36 <donri> i don't follow
08:56:40 <rwbarton> (that's Ord)
08:56:44 <kazagistar> oh
08:56:45 <kazagistar> lol
08:56:55 <kazagistar> I was thinking Ord and typing Eq
08:57:19 <kazagistar> your confusion is entirely logical and what I was typing is entirely illogical
08:58:15 <kazagistar> in any case, the rule for deriving Ord is pretty simple, but you have to learn it an look at the source to veryify if it was autoderived and what the order of the ADT is
08:58:57 <kazagistar> and having to look at the source to find out how something works is, to some extent, a failure of documentation
09:00:06 <gigamonkey> hey, taking my first steps in haskell. Suppose I have a function that takes, for example, Maybe Int
09:00:10 * hackagebot imagesize-conduit 1.0.0.3 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.0.0.3 (mbrock)
09:00:26 <gigamonkey> I can write foo :: Maybe Int and then 'foo (Just i) = ... and foo Nothing = ...
09:00:52 <donri> that's not a function
09:00:52 <gigamonkey> Is there any way to write a single definition with guards?
09:00:57 <sveit> what do people use for fast multi-dimensional data? right now I have a list of Data.Vectors but this is obviously non-optimal. Is Repa stable enough to be used?
09:01:02 <donri> :tmaybe
09:01:08 <gigamonkey> donri: Sorry, foo :: Maybe Int -> Int
09:01:18 <donri> gigamonkey: what do you want to happen for Nothing?
09:01:34 <gigamonkey> Who knows. Return -1. That's not the point. I'm just asking about syntax.
09:01:53 <rwbarton> you can't do it with guards alone (unless you use other helper functions of course)
09:01:57 <donri> foo ma = case ma of Just a -> a; Nothing -> (-1)
09:02:15 <gigamonkey> Okay. Cool.
09:02:25 <donri> foo = maybe (-1) id
09:03:43 <donri> foo = fromMaybe (-1)
09:03:56 <mimblewabe> what's the simplest way to create a chatbot? I just want to listen to HTTP and post HTTP and nothing else
09:04:19 <donri> mimblewabe: scotty, happstack-lite
09:05:04 <mimblewabe> thanks, will take a look
09:07:17 <rwbarton> nclarke: it is "equals", not "unifies with". and I would call gamma, right gamma "coercions"
09:07:48 <nclarke> rwbarton: Thanks!
09:08:43 <nclarke> I think I need to read it in more detail to work out what a "coercion" is
09:09:45 <rwbarton> it's maybe easiest to start with whatever section(s) explain how the theory applies to Haskell
09:10:24 <kazagistar> gigamonkey: are you looking for case expressions?
09:10:28 <jkarni> I have a type     unLookupST :: StateT LookupTbl (MaybeT m) b
09:10:37 <rwbarton> i.e. newtypes give rise to coercions, type family instances give rise to coercions
09:11:01 <jkarni> 'm' is sometimes Identity, but then I need to 'change' it to, say, IO
09:11:24 <jkarni> if I have a starting value, I could run it all, and then repackage it
09:11:51 <jkarni> and so I guess there's a way of doing that without the starting value
09:12:05 <jkarni> but it seems like running and repackaging isn't very elegant
09:12:22 <jkarni> is there a way to neatly target "return . runIdentity"?
09:12:50 <donri> mmorph?
09:13:40 <jkarni> donri: yes, that looks exactly like the ticket, thanks!
09:15:27 <nclarke> rwbarton: So, a coercion is a type which witnesses a more generalised notion of type equality, effectively>
09:15:43 <nclarke> s/>/?/
09:19:30 <gdoteof> if I have a `Maybe [a]` called foo..  is there an 'elegant' way of getting a length of zero out of a Nothing?
09:20:44 <michaelt> > maybe 0 length $ Just "abc"
09:20:46 <lambdabot>  3
09:20:57 <matematikaadit> gdoteof: "maybe 0 length foo"
09:20:57 <michaelt> > maybe 0 length Nothing
09:20:58 <lambdabot>  0
09:21:10 <gdoteof> sweet
09:21:11 <gdoteof> thanks
09:23:06 <rwbarton> nclarke: yes, in general, the equality is non-syntactic, determined by additional axioms
09:25:12 * hackagebot pipes-group 1.0.1 - Group streams into substreams  http://hackage.haskell.org/package/pipes-group-1.0.1 (GabrielGonzalez)
09:26:06 <rwbarton> in the application to Haskell, if I have 'newtype Y = MkY X', then X and Y are equal in this sense, even though syntactically 'X' and 'Y' are not equal
09:26:14 <nclarke> rwbarton: Right. Where syntactic identity is just building up equality from the language construction - .e.g. \x.x == \y.y?
09:26:35 <nclarke> s/identity/equality/
09:26:41 <rwbarton> even simpler than that, since there are no type level lambdas, so it's just Maybe Int = Maybe Int, etc.
09:27:23 <nclarke> Okay
09:27:27 <nclarke> That makes sense
09:27:35 <nclarke> rwbarton: Thanks for the explanations!
09:28:11 <nclarke> I am gradually trying to pick up some computer science
09:29:46 <rwbarton> System FC itself makes no assumptions about what the non-syntactic equality actually "means"
09:30:16 <rwbarton> except that you have to set things up so that the system is consistent, i.e., there are no coercions from Bool to Int etc.
09:30:33 <nclarke> Yep, sure. It just defines the derivational rules to determine when one can exhibit it
09:31:52 <nclarke> Would that make the system inconsistent? What axioms would that break?
09:36:34 <rwbarton> well, if you could produce a coercion badgamma : Bool ~ Int, then you could use it to pass a Bool to a function that expects an Int, which presumably might cause your program to crash or something
09:38:33 <rwbarton> since Bool and Int might have totally different representations
09:39:51 <nclarke> rwbarton: But is that intrinsic in System F_C? The only place where I can see using type equality to show anything about terms is in (Cast). But that says there is another term (e>\gamma) of type tau, not that the original term is of type tau
09:40:17 <nclarke> In other words, I can't see that it would be inconsistent to have a 'cast' which doesn't represent an isomorphism
09:42:45 <rwbarton> if I coerce again with gamma^-1, I get back the original value, right?
09:44:05 <rwbarton> or "sym gamma" in the paper's notation
09:44:18 <rwbarton> though actually i don't know whether that is an axiom
09:45:23 <rwbarton> hmm
09:45:40 <rwbarton> the intent is that the coercions be erased at runtime
09:46:44 <rwbarton> then if you have a coercion from Bool to Int, you can use it to break the "well-typed programs don't go wrong" property
09:46:50 <rwbarton> even if maybe it's not logically inconsistent
09:47:09 <nclarke> I can see that an implementation that would break that would be bad, but yes, I don't think it would be inconsistent
09:48:53 <nclarke> There's no rule saying, e.g.  Œì ‚ä¢e e : œÉ Œì ‚ä¢CO Œ≥ : œÉ ‚àº œÑ |  Œì ‚ä¢e e > Œ≥ > sym Œ≥ == e
09:49:48 <nclarke> I guess because there's no notion of term-level equality?
09:49:50 <nclarke> That I can see
09:51:18 <rwbarton> well, rule Comb says we can rewrite it to e > (Œ≥ o sym Œ≥), but now I think we are stuck
09:52:32 <rwbarton> IMO it's probably intended that Œ≥ o sym Œ≥ be "equal" somehow to refl, and they don't talk about this because the intent is to erase coercions anyways
09:53:05 <rwbarton> maybe KPush somehow implies it
09:55:15 * hackagebot creatur 5.5.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.5.1 (AmyDeBuitleir)
09:57:10 <rwbarton> I think it does, say T = Bool, K = False, gamma : Bool ~ Bool, then case False > gamma of { False -> e1; True -> e2 } reduces to case False of { False -> e1; True -> e2 }
09:57:26 <nclarke> rwbarton: Ah, I had missed the operational semantics!
09:59:13 <rwbarton> it seems to say (among other things) that a coercion from T s1 ... sn to T t1 ... tn has to act as the identity on the constructors of T
10:00:54 <rwbarton> so that should imply that you can't have a coercion between data types with different numbers of constructors
10:03:30 <rwbarton> also, from the reduction rules as a whole, if you had a coercion between a function type and a non-function type, evaluation would get stuck
10:05:17 * hackagebot haskell-token-utils 0.0.0.3 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.3 (AlanZimmerman)
10:05:18 <nclarke> I don't think I've fully wrapped my head around those rules yet, but I think I follow. Although I still can't see anything outlawing Int ~ Bool
10:05:35 <nclarke> Oh, wait, sorry
10:05:36 <nclarke> Ignore me
10:05:42 <nclarke> Constructors
10:05:54 <rwbarton> it would get stuck on evaluation too, actually
10:06:29 <rwbarton> there is no rule for case K ... > gamma of ... unless gamma is a coercion from T s1 ... sn to T t1 ... tn
10:13:11 <nclarke> rwbarton: Think I will have to spend some more time looking at this to fully grok what's going on there
10:20:18 * hackagebot amazon-products 0.1.0.0 - Connector for Amazon Products API  http://hackage.haskell.org/package/amazon-products-0.1.0.0 (andrewrademacher)
10:25:19 * hackagebot amazon-products 0.1.0.1 - Connector for Amazon Products API  http://hackage.haskell.org/package/amazon-products-0.1.0.1 (andrewrademacher)
10:25:24 <TheKing444> I got myself a question for yall.
10:25:46 <TheKing444> Do ye got the answers?
10:26:24 <TheKing444> How do I get code with overlapping pattern matching to compile?
10:26:31 <TheKing444> Ain't there a language extension?
10:26:48 <ReinH> TheKing444: by fixing it.
10:27:02 <TheKing444> It isn't a problem though.
10:27:17 <TheKing444> case fmap process message of
10:27:17 <TheKing444> 			Left eofErrorType -> return ()
10:27:17 <TheKing444> 			Left (a::IOError) -> throw a
10:27:17 <TheKing444> 			Right (Just msg)  -> atomically (writeTChan recvChan msg) >> loop
10:27:17 <TheKing444> 			Right Nothing     -> loop
10:27:19 <geekosaur> overlapping patterns are a warning, aren't they?
10:27:22 <geekosaur> don't paste into the channel
10:27:25 <geekosaur> @paste
10:27:25 <lambdabot> Haskell pastebin: http://lpaste.net/
10:27:32 <TheKing444> wait, nevermind?
10:27:37 <TheKing444> it did compile
10:27:50 <TheKing444> I am good know.
10:27:56 <TheKing444> *now
10:27:57 <donri> that code doesn't make sense
10:27:59 <TheKing444> thx
10:28:01 <kwf> TheKing444: You're trying to pattern-match specifically on something of a certain type.
10:28:09 <ReinH> I mean, you aren't good, but ok.
10:28:13 <TheKing444> It actually did work.
10:28:20 <TheKing444> Why aren't I good?
10:28:29 <kwf> You will never, ever take the second branch of the case statement.
10:28:31 <ReinH> Because the second Left case will never execute
10:28:39 <TheKing444> Oh, and the type is just to get the type checker to work.
10:28:47 <TheKing444> Type inference is funny for exceptions.
10:29:10 <kwf> You're trying to pattern match on types.
10:29:23 <donri> i think you mean for the first one to be a guard
10:29:33 <kwf> This is not something which is possible, without more advanced trickery.
10:29:38 <donri> and then to have the corresponding guard in the second one
10:29:50 <geekosaur> TheKing444, eofErrorType is a fresh variable, not a value match
10:30:20 <TheKing444> https://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO-Error.html#v:eofErrorType
10:30:30 <geekosaur> yes, o?
10:30:37 <ReinH> TheKing444: that's a function.
10:30:42 <ReinH> This is not.
10:30:43 <geekosaur> you are overriding that with a new local binding thta matches anything\
10:30:48 <TheKing444> What, no it ain't.
10:30:55 <TheKing444> @type eofErrorType
10:30:56 <lambdabot> Not in scope: ‚ÄòeofErrorType‚Äô
10:31:00 <ReinH> Ok. That's a value. This is not.
10:31:03 <TheKing444> @import System.IO.Error
10:31:03 <lambdabot> Unknown command, try @list
10:31:11 <TheKing444> > import System.IO.Error
10:31:12 <lambdabot>  <hint>:1:1: parse error on input ‚Äòimport‚Äô
10:31:15 <TheKing444> :P
10:31:16 <geekosaur> pattern matches do not test arbitrary values. you are creating a new binding there
10:31:27 <TheKing444> ?
10:31:38 <donri> i think you want isEOFError
10:31:39 <rwbarton> turn on -Wall and ghc will explain
10:31:39 <kwf> You could try using a guard‚Ä¶
10:31:52 <geekosaur> you are expecting that case to test the value against eofErrorType
10:31:58 <geekosaur> that is not what case patterns do
10:32:07 <donri> Left e | isEOFError e = return () | otherwise = throw e
10:32:20 <donri> s/=/->/
10:32:32 <geekosaur> there is precisely no difference between Left eofErrorType and Left a
10:32:39 <ReinH> > case True of fmap -> True
10:32:40 <geekosaur> except the name of the new local binding
10:32:40 <lambdabot>  True
10:32:45 <ReinH> Do you think I'm calling fmap there?
10:32:56 <mimblewabe> gulp, I'm stuck in a monad :(
10:32:59 <TheKing444> OH!
10:33:00 <TheKing444> okay
10:33:07 <TheKing444> I will use isEOFError e then
10:33:23 <TheKing444> so uh, how do you know when you can pattern match something?
10:33:32 <donri> it starts with a capital
10:33:33 <geekosaur> uppercase initial letter
10:33:36 <donri> or a colon
10:33:44 <geekosaur> lowercase is always a new local binding
10:33:46 <mimblewabe> I used haskell interpreter to evaluate a string. Thas has given me IO String, more or less. How do I break out of IO to do something else with it (in my case, I want to return it as HTML with scotty ActionM monad)
10:33:47 <TheKing444> okay
10:33:48 <ReinH> Or []
10:34:01 <TheKing444> mimblewabe
10:34:06 <TheKing444> use do notation
10:34:09 <mimblewabe> I kind of feel that the answer will be monad transformers but I have no clue in what way
10:34:11 <ReinH> as in, "is a data constructor"
10:34:22 <ReinH> mimblewabe: the short answer is that you do not
10:34:27 <geekosaur> mimblewabe, you don't. you use <- in do notation to pretend to do so, or use >>= to chain an action onto it
10:34:32 <kwf> mimblewabe: Is the ActionM monad a wrapper around IO?
10:34:38 <donri> mimblewabe: probably ActionM Is a MonadIO and you need to use liftIO
10:34:41 <ReinH> mimblewabe: the slightly less short answer is that writing a Haskell program involves getting everything else *into* IO.
10:34:41 <mimblewabe> No, it's not AFAIK
10:34:55 <kwf> donri: You took the words out of my mouth. :)
10:35:21 * hackagebot mailgun 0.1.0.4 - Connector to Rackspace's Mailgun Service  http://hackage.haskell.org/package/mailgun-0.1.0.4 (andrewrademacher)
10:35:23 <mimblewabe> yeah, scotty uses that monad to build their HTML and finally they transform it into IO
10:35:29 <TheKing444> well, if you want your haskell program to do anything
10:35:32 <mimblewabe> liftIO sounds reasonable
10:35:40 <donri> :t liftIO
10:35:41 <lambdabot> MonadIO m => IO a -> m a
10:35:47 <TheKing444> :t fix
10:35:48 <lambdabot> (a -> a) -> a
10:35:57 <TheKing444> :t fix liftIO
10:35:58 <lambdabot> IO a
10:36:04 <TheKing444> and that is everything you need to know
10:36:25 <TheKing444> > fix liftIO
10:36:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
10:36:27 <lambdabot>    arising from a use of ‚ÄòM337663220056019612619142.show_M3376632200560196126...
10:36:27 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
10:36:27 <lambdabot>  Note: there are several potential instances:
10:36:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
10:36:29 <donri> whatnow?
10:37:10 <mimblewabe> I'm going to mess around with the stuff you guys suggested, hopefully I'll make some sense out of it
10:37:14 <mimblewabe> thanks a lot
10:37:25 <TheKing444> don't forget the fixed points
10:37:31 <TheKing444> you may need functor fixed points as well
10:37:43 <ReinH> TheKing444: what? No.
10:37:57 <TheKing444> :k Fix
10:37:58 <lambdabot> Not in scope: type constructor or class ‚ÄòFix‚Äô
10:38:05 <TheKing444> :t cata
10:38:06 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
10:38:07 <nadirs> hello! I have a question about fix (http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad-Fix.html#v:fix): what does it mean the "least defined x"?
10:38:11 <TheKing444> :t ana
10:38:12 <lambdabot>     Not in scope: ‚Äòana‚Äô
10:38:12 <lambdabot>     Perhaps you meant one of these:
10:38:12 <lambdabot>       ‚Äòand‚Äô (imported from Data.List),
10:38:17 <ReinH> TheKing444: you can /q lambdabot.
10:38:39 <TheKing444> okay sorry
10:38:41 <TheKing444> troll mode off
10:38:50 <TheKing444> okay, here is how I think of fix
10:39:04 <TheKing444> fix finds whatever value you can plug into a function and it is the same
10:39:09 <TheKing444> > (*1) 0
10:39:11 <lambdabot>  0
10:39:24 <TheKing444> so 0 is a fixed point of (*1)
10:39:25 <TheKing444> but
10:39:28 <TheKing444> so is bottom
10:39:31 <TheKing444> > (*1) undefined
10:39:33 <lambdabot>  *Exception: Prelude.undefined
10:39:51 <TheKing444> fix will also choose bottom (as an infinite loop) if it is a fixed point
10:40:02 <ReinH> nadirs: it might be useful to know that this should parse as "least (defined x)", not "(least defined) x"
10:40:12 <TheKing444> so always try undefined in your function before you fix point it
10:40:14 <ReinH> TheKing444: do you know the difference between greatest fixed point and least fixed point?
10:40:18 <nadirs> ReinH: AH!
10:40:37 <TheKing444> least fixed point is the one with the most undefined-ness in it
10:40:46 <ReinH> nadirs: it's saying that `fix x' finds the least fixed point of x
10:40:46 <TheKing444> > (*1) 0
10:40:47 <nadirs> ReinH: so "least" in terms of how much you have to "say" about x?
10:40:48 <lambdabot>  0
10:40:51 <TheKing444> > (*1) undefined
10:40:53 <lambdabot>  *Exception: Prelude.undefined
10:40:56 <TheKing444> > fix (*1)
10:41:00 <lambdabot>  mueval-core: Time limit exceeded
10:41:08 <TheKing444> see, it choose bottom over 0
10:41:08 * ReinH sighs
10:41:40 <ReinH> nadirs: the least fixed point is the fixed point which is less than each other fixed point, according to the order of the set
10:41:54 <TheKing444> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
10:41:59 <TheKing444> This is how to make it rigourous.
10:42:10 <ReinH> so the least fixed point of f(x) = x¬≤ is x = 0
10:42:22 <ReinH> since the only other fixed point is x = 1 and 0 < 1
10:42:23 <TheKing444> not the least
10:42:30 <ReinH> TheKing444: please stop.
10:42:32 <TheKing444> not least in terms of number
10:42:34 <nadirs> ReinH: oh, ok, it needs to be determined by the context. Very clear!
10:42:51 <TheKing444> what no
10:43:00 <nadirs> also, another question (more of a curiosity): is the "fix" function part of the Y combinator definition? I think it is but I'm not sure
10:43:08 <TheKing444> > fix (\x->x^2)
10:43:12 <lambdabot>  mueval-core: Time limit exceeded
10:43:14 <rwbarton> we are talking about fix right? the context is, "least" means "least defined"
10:43:18 <TheKing444> see, it isn't 0
10:43:23 <TheKing444> ReinH is wrong
10:43:35 <nadirs> TheKing444: I think that happens because (^) is strict, no?
10:43:37 <ReinH> TheKing444: if you don't know what you're talking about, please don't talk.
10:43:37 <TheKing444> it is least defined
10:43:50 <TheKing444> No, you don't know what you are talking about.
10:43:56 <TheKing444> It has nothing to do with 0<1
10:44:04 <ReinH> TheKing444: Yes it does. ffs.
10:44:06 <ReinH> http://en.wikipedia.org/wiki/Least_fixed_point
10:44:07 <TheKing444> fix is about least defined
10:44:28 <TheKing444> that is not haskell's fixed point
10:44:35 <TheKing444> that is a completely different fixed point concept
10:44:45 <rwbarton> it's a different "least" concept
10:44:51 <rwbarton> same fixed point concept
10:44:52 <TheKing444> exactly
10:44:59 <TheKing444> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
10:45:02 <ReinH> It's the same fixed point.
10:45:02 <TheKing444> you need to read that
10:45:11 <TheKing444> nadirs
10:45:22 * hackagebot thumbnail-plus 1.0.4 - Generate thumbnails easily and safely.  http://hackage.haskell.org/package/thumbnail-plus-1.0.4 (FelipeLessa)
10:45:24 <TheKing444> fix always finds the least fixed point
10:45:34 <TheKing444> > fix (const "Hello World")
10:45:35 <lambdabot>  "Hello World"
10:46:13 <nadirs> so, just for understanding: is the least fixed point for a function on a Monoid always mempty?
10:46:16 <ReinH> TheKing444: I apologize.
10:46:29 <TheKing444> It is fine.
10:46:34 <nadirs> or am I mixing concepts?
10:46:43 <TheKing444> We where just having an internal discussion.
10:46:45 <ReinH> TheKing444: but you might want to not start by trolling the channel if you want to be taken seriously.
10:46:50 <TheKing444> Sorry
10:46:56 <TheKing444> That probably was a bad idea.
10:47:06 <TheKing444> Do you want to take over, or should I?
10:47:11 <ReinH> Let's both.
10:47:14 <TheKing444> okay
10:47:19 <ReinH> TheKing444: <3
10:47:29 <nadirs> :D
10:47:36 <TheKing444> so when we say least, we mean basically with the most "undefined" in int
10:47:41 <TheKing444> s/int/it
10:47:53 <TheKing444> for example, give us a function of type a->a for some a
10:48:13 <ReinH> f = undefined QED
10:48:21 <ReinH> Ok now I'm trolling :p
10:48:33 <TheKing444> yes, ignore that last remark
10:48:42 <TheKing444> like, for example (*4)
10:48:47 <TheKing444> :t (*4)
10:48:47 <lambdabot> Num a => a -> a
10:48:49 <nadirs> ok
10:48:59 <TheKing444> okay, now what do you know that (*4) x = x
10:49:23 <TheKing444> what times 4 is itself?
10:49:47 <phaazon_> hey
10:49:48 <nadirs> 1, the least fixed point of (*4) !!!
10:49:55 <nadirs> no, sorry 0
10:49:56 <TheKing444> > (*4) 1
10:49:57 <lambdabot>  4
10:50:00 <TheKing444> oh okay
10:50:03 <TheKing444> > (*4) 0
10:50:05 <lambdabot>  0
10:50:08 <TheKing444> that is A fixed point
10:50:11 <TheKing444> but there is another
10:50:15 <TheKing444> > (*4) undefined
10:50:17 <lambdabot>  *Exception: Prelude.undefined
10:50:27 <TheKing444> note that undefined has more "undefined-ness" then 0
10:50:29 <TheKing444> SO
10:50:32 <TheKing444> > fix (*4)
10:50:36 <lambdabot>  mueval-core: Time limit exceeded
10:50:40 <TheKing444> we get an error
10:50:57 <TheKing444> becaues bottom (which is undefined or infinite loop) is the least fixed point
10:51:06 <TheKing444> least, meaning, least amount of defined-ness
10:51:16 <TheKing444> but let's take (const "Hello World")
10:51:22 <TheKing444> > const "Hello World" undefined
10:51:23 <ReinH> ignoring the fact that undefined isn't a wel-behaved bottom, we get bottom in both cases.
10:51:24 <lambdabot>  "Hello World"
10:51:37 <TheKing444> > const "Hello World" undefined
10:51:38 <lambdabot>  "Hello World"
10:51:44 <nadirs> ok, but then is undefined always the LFP?
10:51:50 <TheKing444> > fix (const "Hello World")
10:51:52 <lambdabot>  "Hello World"
10:51:59 <ReinH> nadirs: this is a counterexample to that question :)
10:52:06 <TheKing444> you see (const "Hello World") undefined != undefined
10:52:11 <donri> > unlines ["bottom line", undefined]
10:52:13 <lambdabot>  "bottom line\n*Exception: Prelude.undefined
10:52:19 <TheKing444> undefined is only the least fixed point if it is a fixed point in the first place
10:52:27 <nadirs> a-ha! undefined is not a fixed point in that case, right!
10:52:32 <TheKing444> yep
10:52:39 <nadirs> wow
10:52:47 <TheKing444> so it MUST go with "Hello World"
10:52:53 <TheKing444> since it is the only fixed point
10:53:11 <TheKing444> another example
10:53:47 <TheKing444> (\fibs->0:1:(zipWith (+) fibs $ tail fibs) undefined
10:54:06 <TheKing444> > (\fibs->0:1: (zipWith (+) fibs $ tail fibs) undefined
10:54:08 <lambdabot>  <hint>:1:54:
10:54:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:54:11 <TheKing444> whoops
10:54:22 <TheKing444> > (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) undefined
10:54:24 <lambdabot>  [0,1*Exception: Prelude.undefined
10:54:32 <TheKing444> no a fixed point, since it started with a list
10:54:37 <TheKing444> head undefined
10:54:42 <TheKing444> > head undefined
10:54:43 <lambdabot>  *Exception: Prelude.undefined
10:54:51 <TheKing444> > head $ (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) undefined
10:54:52 <lambdabot>  0
10:55:07 <TheKing444> so (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) undefined != undefined
10:55:10 <ReinH> TheKing444: (the scanl definition is a bit easier to fix)
10:55:12 <TheKing444> the fixed point is
10:55:25 <TheKing444> is it?
10:55:31 <TheKing444> > fix (\fibs->0:1: (zipWith (+) fibs $ tail fibs))
10:55:32 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:55:47 <ReinH> > let fibs = fix ((0:) . scanl (+) 1) in take 10 fibs
10:55:49 <TheKing444> because that infinite list is a fixed point
10:55:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
10:56:08 <TheKing444> (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) fibs
10:56:17 <TheKing444> > (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) fibs
10:56:18 <lambdabot>  Not in scope: ‚Äòfibs‚Äô
10:56:33 <TheKing444> @def fibs = fix  (\fibs->0:1: (zipWith (+) fibs $ tail fibs)) fibs
10:56:34 <lambdabot>  .L.hs:146:23:
10:56:34 <lambdabot>      Couldn't match expected type ‚Äòt -> t‚Äô with actual type ‚Äò[a0]‚Äô
10:56:34 <lambdabot>      Relevant bindings include
10:56:34 <lambdabot>        fibs :: t -> t (bound at .L.hs:146:15)
10:56:34 <lambdabot>        fibs :: t (bound at .L.hs:146:1)
10:56:39 <ReinH> it doesn't require the lambda abstraction
10:56:40 <ReinH> Anyway
10:56:43 <TheKing444> okay
10:56:53 <nadirs> an infinite list is a fixed point? Is it because it's the only possible outcome of that function?
10:56:59 <TheKing444> sorry, I couldn't copy and paste yours because it turned into a frowny face in pidgin
10:57:09 <ReinH> TheKing444: heh
10:57:10 <TheKing444> nadirs, it is the only fixed point
10:57:18 <TheKing444> try putting in a space
10:57:23 <ReinH> fibs = fix ((0 :) . scanl (+) 1)
10:57:25 <ReinH> yep
10:57:31 <TheKing444> no there is a happy face
10:57:32 <ReinH> It doesn't matter though
10:57:35 <ReinH> hahahahaha
10:57:45 <ReinH> fibs = fix ((0 : ) . scanl (+) 1)
10:57:49 <TheKing444> there we go
10:57:58 <ReinH> TheKing444: you might want to turn that "feature" off for #haskell ;)
10:58:01 <ReinH> sorry for the digression
10:58:03 <nadirs> :t fix ((0 :) . scanl (+) 1
10:58:04 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
10:58:09 <nadirs> :t fix ((0 :) . scanl (+) 1)
10:58:10 <lambdabot> Num a => [a]
10:58:20 <TheKing444> it is a list of numbers
10:58:34 <TheKing444> :t iterate
10:58:35 <lambdabot> (a -> a) -> a -> [a]
10:58:36 <ReinH> nadirs: an infinite list is still a value.
10:58:54 <nadirs> ReinH: yes, but how it can be a fixed point escapes me
10:59:00 <TheKing444> ((0 : ) . scanl (+) 1) undefined
10:59:05 <TheKing444> > ((0 : ) . scanl (+) 1) undefined
10:59:06 <lambdabot>  [0,1*Exception: Prelude.undefined
10:59:10 <TheKing444> not fixed point
10:59:15 <rwbarton> why not just start with fix (\xs -> 1 : xs)
10:59:22 <TheKing444> yeah
10:59:32 <TheKing444> > fix (1:)
10:59:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:59:50 <TheKing444> > (1: ) undefined
10:59:51 <lambdabot>  [1*Exception: Prelude.undefined
11:00:04 <TheKing444> > (1: ) (1:undefined)
11:00:05 <lambdabot>  [1,1*Exception: Prelude.undefined
11:00:13 <TheKing444> > (1: ) (1:1:undefined)
11:00:14 <lambdabot>  [1,1,1*Exception: Prelude.undefined
11:00:22 <TheKing444> notice how none of these are fixed points
11:00:27 <TheKing444> but they approach a limit
11:00:32 <TheKing444> > repeat 1
11:00:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:00:35 <ReinH> nadirs: consing a 1 onto an infinite list of 1's gives you... an infinite list of 1s
11:00:42 <TheKing444> > (1:) $ repeat 1
11:00:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:00:48 <TheKing444> see, fixed point
11:00:51 <TheKing444> only fixed point
11:00:57 <nadirs> ReinH: ok, and it sort of makes sense
11:01:06 <TheKing444> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics try reading that
11:01:09 <TheKing444> it helps
11:01:10 <nadirs> but for a list like the fibonacci sequence, how can it be fixed?
11:01:27 <TheKing444> you see, (1:) will change anything except repeat 1
11:01:28 <nadirs> TheKing444: yeah, maybe I should start from there
11:02:09 <TheKing444> It is a bit mathy, but not to hard.
11:02:19 <TheKing444> Not like numbery math.
11:02:50 <TheKing444> The coolest thing though is that fix will ALWAYS find a fixed point.
11:02:58 <TheKing444> Even if that fixed point is an infinite loop.
11:03:18 <nadirs> TheKing444: and this magic is explained by the denotational semantics, right?
11:03:22 <TheKing444> (It would be cool if there was a greatest fixed point function, wouldn't there. I don't think that can exist though.)
11:03:27 <TheKing444> nadirs: Yep
11:03:34 <TheKing444> It explains all the magic.
11:04:06 <TheKing444> You can skip down to where it talks about bottom and you will be fine I think.
11:04:45 <TheKing444> oh, and to get fix, I recommend import Data.Function (fix). If you import Control.Monad.Fix, people will think you are doing MONADIC fixed points.
11:04:57 <TheKing444> By the way, can anyone explain Monad fix points to me?
11:05:03 <nadirs> Ok. One last thing: does this definition of Fix (https://github.com/jwiegley/hnix/blob/2ee2f718327dfc23c29151d3edcab0a68f3095c9/Nix/Types.hs#L14)
11:05:05 <TheKing444> after nadirs is good?
11:05:05 <nadirs> have anything to do with all we've said here?
11:05:26 <nadirs> TheKing444: I'm good thanks a lot to you and ReinH! I'm going to read :D
11:05:33 <TheKing444> ONly if you like category theory.
11:05:44 <TheKing444> If not, it is just a seperate, (but still awesome) thing.
11:06:34 <TheKing444> https://hackage.haskell.org/package/unification-fd/docs/Data-Functor-Fixedpoint.html
11:06:39 <TheKing444> this is where it came from by the way
11:06:43 <TheKing444> the functor fixed point
11:06:46 <TheKing444> oh, one last thing
11:06:52 <TheKing444> fix f = f fix f
11:06:57 <TheKing444> that is its definition
11:07:01 <TheKing444> for regualr fix
11:07:05 <TheKing444> that we where talking about
11:07:21 <ReinH> TheKing444: that's the fixed point of a functor, which gets to your Monad fix points question ;)
11:07:22 <TheKing444> > let fix' f=f fix' f in fix' const "Hello World"
11:07:23 <lambdabot>  can't find file: L.hs
11:07:40 <TheKing444> I mean with mfix.
11:07:49 <TheKing444> And lambda bot crashed
11:08:04 <donri> > "nope"
11:08:05 <lambdabot>  "nope"
11:08:10 <TheKing444> oh
11:08:10 <rwbarton> you need more parens also
11:08:11 <TheKing444> https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad-Fix.html
11:08:16 <donri> race prone code
11:08:35 <TheKing444> > let fix' f=f (fix' f) in fix' (const "Hello World" )
11:08:36 <lambdabot>  "Hello World"
11:08:43 <TheKing444> there we go
11:09:00 <TheKing444> gtg, read up on denotional semantics
11:10:01 <mimblewabe> okay, I'm stuck again. I get the way other monads are related to IO know but in my case that doesn't seem to help. hopefully someone here familliar with Scotty can point me in the right direction
11:10:11 <mimblewabe> there are two transformers ScottyT and ActionT
11:10:18 <mimblewabe> ScottyT is a MonadIO, ActionT isn't
11:10:46 <mimblewabe> but I need to lift to ActionT (or at least I think I do, since that's where all the request handling should occur). what do I do?
11:11:54 <mimblewabe> to be absolutely precise, ActionT ScottyError IO is a MonadIO but that doesn't seem to be my case, I have ActionT Text IO
11:12:29 <mimblewabe> I guess I should just go read a chapter on monad transformers first? :)
11:12:55 <dwcook> mimblewabe, seeing the documentation of the relevant instances might help.
11:13:16 <mimblewabe> http://hackage.haskell.org/package/scotty-0.8.1/docs/Web-Scotty-Trans.html
11:13:31 <mimblewabe> and http://hackage.haskell.org/package/scotty-0.8.1/docs/Web-Scotty.html#t:ScottyM
11:14:07 <iriomk> hey guys, I am having some trouble to understand how Haskell compose functions
11:14:26 <rwbarton> why do you have ActionT Text IO?
11:14:47 <iriomk> could someone explain if my understanding in https://gist.github.com/Irio/430a457be0a5d8ab580d is right?
11:14:55 <rwbarton> wait
11:15:01 <dwcook> mimblewabe, ScottyError is a typeclass, not a type. There is an instance for Text.
11:15:03 <rwbarton> Text is an instance of ScottyError
11:15:07 <mimblewabe> oh
11:15:15 <mimblewabe> in that case, it's weird that it doesn't typecheck
11:15:23 <dwcook> mimblewabe, show the error.
11:15:37 <mimblewabe> No instance for (MonadIO
11:15:37 <mimblewabe>                        (Web.Scotty.Internal.Types.ActionT
11:15:37 <mimblewabe>                           Data.Text.Internal.Lazy.Text IO))
11:15:37 <mimblewabe>       arising from a use of ‚ÄòliftIO‚Äô
11:16:47 <rwbarton> maybe you don't have the instance imported somehow
11:17:50 <rwbarton> well that seems pretty unlikely actually
11:17:53 <tulcod> is storable-record "reliable"? can i practically assume it works fine?
11:17:57 <rwbarton> maybe you have multiple versions of something installed?
11:18:14 <dwcook> mimblewabe, have you actually imported Web.Scotty.Trans?
11:18:36 <mimblewabe> I tried now, it didn't help. but it gives prettier error
11:18:47 <mimblewabe> No instance for (MonadIO (ActionT Data.Text.Internal.Lazy.Text IO))
11:19:04 <dwcook> mimblewabe, a link to your code would probably be helpful. I'm stumped so far.
11:19:18 <TheKing444> https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Monad-Fix.html#v:mfix
11:19:28 <TheKing444> Could someone explain to me how mfix works?
11:19:29 <rwbarton> my guess is multiple versions of mtl or scotty or text
11:19:33 <TheKing444> Or what it does?
11:19:47 <dwcook> TheKing444, what it "does" depends on the instance. I'd suggest reading those.
11:19:55 <TheKing444> well, I did
11:20:08 <TheKing444> but I mean what is the concept behind mfix, what does it find
11:20:19 <mimblewabe> I'll show the code in a minute, if I still can't figure this out
11:20:22 <TheKing444> fix finds the fixed point that has the most undefined's in it
11:20:28 <dwcook> TheKing444, it fixes a Kleisli arrow much like you might fix a plain function.
11:20:32 <mimblewabe> as for multiple instances, is there a way to find this out with cabal?
11:20:40 <mimblewabe> or could it be cabal vs. native pkg manager issue?
11:20:56 <dwcook> TheKing444, I believe the least fixed point but I could be wrong
11:20:59 <bergmark> mimblewabe: ghc-pkg list
11:21:19 <rwbarton> ^ or equivalent depending on your sandbox setup
11:21:21 <joshc> TheKing444: perhaps it's worth reading the "Value Recursions in Monadic Computations" paper, it's pretty readable
11:21:40 <mimblewabe> I have both transformers and mtl in two versions :(
11:21:55 <mimblewabe> I'll try to sort it out
11:22:19 <mimblewabe> thanks again for all the help
11:22:55 <TheKing444> Œª <Prelude Control.Monad.Fix>: mfix Just
11:22:55 <TheKing444> Just ^CInterrupted.
11:22:55 <TheKing444> Œª <Prelude Control.Monad.Fix>: fix (>>= Just)
11:22:55 <TheKing444> ^CInterrupted.
11:23:05 <TheKing444> they are different it looks like
11:23:19 <TheKing444> (^CInterrputed means _|_)
11:23:34 <dwcook> It doesn't, it just means you cut off the computation early
11:23:43 <dwcook> However in this case I'd say they are likely to be _|_
11:24:06 <TheKing444> Thats what I meant.
11:24:59 <TheKing444> where is a link to the paper?
11:25:21 <TheKing444> up, found it
11:25:24 <TheKing444> reading it now
11:26:04 <dwcook> Oh, I see what you were trying to do with those two examples
11:26:31 <dwcook> Well those two aren't supposed to be equivalent
11:26:37 <TheKing444> I know
11:26:51 <TheKing444> Although, I do believe they are both fixed points of (>>= Just)
11:27:02 <TheKing444> > Just undefined >> Just
11:27:03 <lambdabot>  Couldn't match expected type ‚ÄòData.Maybe.Maybe b‚Äô
11:27:04 <lambdabot>              with actual type ‚Äòa0 -> Data.Maybe.Maybe a0‚Äô
11:27:14 <TheKing444> > Just undefined >>= Just
11:27:15 <lambdabot>  Just *Exception: Prelude.undefined
11:27:25 <TheKing444> a ha, it is a fixed point, just a different one
11:28:54 <dwcook> TheKing444, do you know what Kleisli arrows are?
11:30:15 <TheKing444> a->ma
11:30:22 <TheKing444> simple
11:30:26 * hackagebot hoogle 4.2.34 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.34 (NeilMitchell)
11:30:34 <dwcook> Almost: a -> m b for some monad m
11:30:41 <TheKing444> oh yeah
11:30:49 <dwcook> They're analogous in quite a few ways to general functions
11:30:49 <TheKing444> So it could be a -> m a
11:30:58 <dwcook> Yes it could, just as you can have a function a -> a
11:31:03 <TheKing444> Is there some functor for it?
11:31:15 <TheKing444> or other category thingy?
11:31:39 <dwcook> Good question. Probably, I haven't thought about that in particular.
11:31:48 <dwcook> But you can compose them for example
11:31:55 <jle`> there's the obvious functor instance, if that is what you're asking
11:31:58 <dwcook> (<=<) is analogous to (.)
11:32:18 <dwcook> (=<<) is analogous to ($)
11:32:19 <TheKing444> okay
11:32:22 <TheKing444> okay
11:33:16 <dwcook> And, in this instance, we're taking the fixed point of a Kleisli arrow like you might do with a general function, although what that means depends on the specific monad we're working with
11:33:33 <turnt> Why doesn't this type check? I'm pretty sure it has to do with the fact that I have a class constraint in my typeclass method, but I can't figure out why this wouldn't be typesafe... http://lpaste.net/107191
11:33:35 <TheKing444> which fixed point though?
11:33:58 <TheKing444> (>>= Just) has at least two fixed points. _|_, and Just _|_
11:33:59 <jle`> turnt: what is the error?
11:34:56 <dwcook> I'm not sure, I don't have a very good picture of what mfix does at the value level myself
11:35:02 <TheKing444> okay
11:35:06 <TheKing444> I will read the paper.
11:35:36 <turnt> jle`: oo I understand my mistake
11:35:50 <turnt> oh wai
11:35:51 <turnt> t
11:36:17 <rwbarton> my impression is that the concept of mfix is not very well understood
11:36:18 <jle`> there should be an error online 13, right?
11:36:26 <turnt> yeah
11:36:31 <jle`> i mean, 14
11:36:35 <turnt> Right
11:36:50 <jle`> the type signature of ToFooable in that case is
11:37:02 <jle`> Fooable foo => Foo -> foo
11:37:03 <rwbarton> there are laws on the paper, but I don't know if they uniquely determine mfix when it exists
11:37:08 <rwbarton> *in the paper
11:37:09 <jle`> or maybe in more generic terms
11:37:14 <jle`> Fooable f => Foo -> f
11:37:16 <rwbarton> (if you print it out then they are on the paper)
11:37:29 <turnt> right...
11:37:33 <jle`> basically this means that you can turn Foo into "any" Fooable
11:37:54 <jle`> as in, I can write "toFoo x :: Foo", and that should work
11:37:56 <TheKing444> Who prints things out of the interenet any more? Besides when you go off the computr.
11:38:05 <jle`> but i can also write "toFoo :: HasFoo", which should also work
11:38:11 <jle`> or er, toFoo x :: HasFoo
11:38:12 <dwcook> Even then you've got your cell phone or tablet or whatnot :P
11:38:48 <jle`> just like read, Read a => String -> a.  that type signature means that i can "get" *anything* in Read, from a String
11:39:00 <turnt> Hmm I was thinking it meant that it would turn it into __something__ that supports the "Fooable" interface
11:39:02 <TheKing444> :t read
11:39:03 <lambdabot> Read a => String -> a
11:39:07 <jle`> or a type signature like x :: Num a
11:39:13 <jle`> means that x is "any" Num instance
11:39:24 <jle`> so toFoo x :: Fooable f => f
11:39:24 <TheKing444> :t 3
11:39:25 <lambdabot> Num a => a
11:39:32 <jle`> means that toFoo x must be "any" Fooable instance
11:39:56 <guesting> Can anyone recommend any good csv parsers? I see cassava is good, but it uses bytestrings and I need Data.Text.
11:40:12 <turnt> jle`: ah I see
11:40:13 <ion> You could decode the bytestrings.
11:40:15 <guesting> * without writing my own preferable
11:40:34 <guesting> ion: I could, but that's an extra step which takes up additional time
11:40:39 <jle`> turnt: do you see why x :: Show a => a; x = True
11:40:40 <jle`> doesn't work?
11:40:53 <dwcook> guesting, not familiar with it, but would decodeUtf8 or whatnot in the right place work?
11:40:56 <guesting> ion: Is there a benefit of using Data.Text over bytestrings
11:41:03 <jle`> > let x :: Show a => a; x = True in show x
11:41:05 <lambdabot>  Could not deduce (a ~ GHC.Types.Bool)
11:41:05 <lambdabot>  from the context (GHC.Show.Show a)
11:41:05 <lambdabot>    bound by the type signature for x :: GHC.Show.Show a => a
11:41:05 <lambdabot>    at <interactive>:1:10-20
11:41:05 <lambdabot>    ‚Äòa‚Äô is a rigid type variable bound by
11:41:08 <dwcook> (Possibly with a layer or two of fmap)
11:41:20 <guesting> I could just go all out bytestrings, but people always said text was better for non binary
11:41:54 <turnt> jle`: well in that case you are using a type variable to describe a fully constructed concrete value
11:42:10 <turnt> True can only be Bool
11:42:11 <ion> guesting: Text is a representation of text, ByteString is a representation of byte arrays. It depends on whether you want to process the data as text or blobs.
11:42:24 <jle`> turnt: same here; your toFoo x :: Fooable f => f, but your implementation of toFoo Foo :: Foo
11:42:47 <jle`> toFoo (Foo i) has to be of type Fooable f => f
11:42:57 <jle`> but as you wrote it, your implementaiton makes it of type Foo
11:42:59 <guesting> ion: So I should be using text.
11:43:12 <jle`> just like if I want to write a function Show a => a
11:43:14 <jle`> i can't make it = True
11:43:23 <kini> ok, how is the --enable-library-coverage cabal option supposed to work? I have sometimes gotten it to work in the past, but never figured out how I did it
11:43:42 <kini> are you supposed to do `cabal configure --enable-library-coverage` and then `cabal test`, and then it will generate the coverage reports?
11:44:42 <turnt> jle`: I see. Well my intention was to have an interface "Fooable", and a way to conform several different datatypes to that interface when needed
11:44:53 <turnt> Is that misguided?
11:45:34 <jle`> why don't you just give the data types themselves that interface?
11:45:59 <jle`> if they can be converted to something with that interface then it seems like any of those types must also support to through conversion
11:46:10 <dwcook> guesting, I just took a look at that library and it looks like you don't even need an intermediate text representation if you don't want. You can translate directly to some data structure of your design.
11:46:26 <jle`> the only way your HasFoo can work is if you make toFoo be able to return "any" Fooable that the user might request, at the call site
11:46:39 <jle`> in the samy way that read "hello" can return *any* Read
11:46:46 <jle`> or 1 can return *any* Num that the user may ask for
11:46:51 <jle`> > 1 :: Integer
11:46:53 <lambdabot>  1
11:46:55 <jle`> > 1 :: Int
11:46:57 <lambdabot>  1
11:46:59 <turnt> sure sure
11:47:01 <jle`> > 1 :: Double
11:47:02 <lambdabot>  1.0
11:47:04 <turnt> i understand that
11:47:05 <jle`> those are all very different 1's
11:47:12 <kini> actually, how does `cabal install` interact with `cabal configure`? Often I have run `cabal install` but then when I run `cabal configure` I get a message saying "this package has never been configured"
11:47:21 <kini> yet `cabal install` takes many of the same flags as `cabal configure`...
11:48:04 <bergmark> kini: install does configure+build+install
11:48:22 <bergmark> i'm not sure why it would say it hasn't been configured though
11:48:24 <kini> bergmark: even in the presence of sandboxes?
11:48:24 <turnt> I'm essentially just looking for a way to overload record fields I think...
11:48:47 <bergmark> kini: it does the same thing in sandboxes afaik
11:49:37 <rwbarton> why would "cabal configure" say the package has never been configured, ever?
11:49:51 <rwbarton> that is weird
11:49:57 <kini> er, sorry, that message came from `cabal test` I guess
11:50:17 <dwcook> guesting, by the way, there is a FromField instance for Text, so you're all set either way
11:50:22 <rwbarton> did you cabal install with --enable-tests?
11:50:27 * hackagebot csound-expression-dynamic 0.0.5 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.5 (AntonKholomiov)
11:50:29 * hackagebot csound-expression-typed 0.0.5.1 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.5.1 (AntonKholomiov)
11:50:31 * hackagebot csound-expression 3.3.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-3.3.1 (AntonKholomiov)
11:50:36 <guesting> dwcook: Really? Let me check this out
11:53:20 <guesting> dwcook: But the entire structure is still in Bytestrings, right?
11:53:30 <guesting> dwcook: All of the methods require bytestrings
11:54:04 <dwcook> guesting, doesn't matter, that just means you read the file or whatnot in as ByteString and feed it to an appropriate parser
11:54:37 <guesting> dwcook: So it would read as a bytestring and convert to a text--that must be pretty slow...hmmmm
11:54:53 <dwcook> guesting, no slower than what you'd normally do
11:55:35 <guesting> dwcook: Load directly to text and split on ","?
11:56:26 <dwcook> guesting, I don't imagine that'd be much faster, but what were you thinking of using to read in as Text?
11:56:47 <guesting> dwcook: I mean, using readFile from text
11:57:56 <kini> rwbarton: http://ix.io/dk3
11:57:56 <kini> here's a demonstration both of cabal thinking that a package has never been configured even after I've `cabal install`ed it, and of `cabal build` clearly doing something that `cabal install` does not
11:58:10 <kini> (i.e. trying to access the dist/build directory)
11:59:14 <kini> <rwbarton> did you cabal install with --enable-tests?
11:59:15 <kini> you mean, in order to generate the "package has never been configured" message?
11:59:28 <rwbarton> steps 3 and 4 seem rather cruel, though admittedly step 5 should error then
11:59:40 <rwbarton> yeah
12:00:07 <dwcook> guesting, my reading the source code for that came up inconclusive. Still, if that library ends up being too slow for your purposes, you can always choose another one.
12:00:15 <geekosaur> does this happen if you make your sandbox somewhere other than /tmp?
12:00:24 <rwbarton> oh
12:00:28 <kini> geekosaur: not sure why that would matter, but I can try...
12:00:32 <rwbarton> this is a weird sandbox thing
12:00:32 <geekosaur> I am wondering if something is assuming that /tmp means it's installing directly
12:00:33 <kini> (my /tmp isn't a tmpfs or anything)
12:00:51 <guesting> dwcook: True, thank you for you rhelp!
12:01:05 <rwbarton> steps 3 and 4 are irrelevant
12:01:19 <geekosaur> (that is, `cabal install PACKAGE` unpacks it in /tmp and installs form there, whereas `cabal install` uses the current directory. but something may be assuming /tmp is always the former)
12:01:28 <rwbarton> why does "cabal install" build into "dist/dist-sandbox-d92f0862/build" but "cabal build" installs into "dist/build"? sandboxes are too hard
12:02:05 <kini> that seems like a bug, doesn't it?
12:02:15 <kini> or does it not?
12:02:20 <rwbarton> probably? I don't pretend to understand sandboxes
12:03:03 <kini> well, forgive me - I just started using cabal recently and was told that I absolutely must use sandboxes because everything goes to hell in a handbasket if I don't :)
12:03:49 <rwbarton> I wonder where "d92f0862" even comes from
12:03:56 <kini> it's a nonce for the particular sandbox I guess
12:04:15 <kini> btw `cabal --require-sandbox build` still tries to access dist/build
12:04:36 <kini> if `cabal build` isn't supposed to use sandboxes then surely `--require-sandbox` should error out when you try to follow it up with the `build` subcommand
12:05:54 <rwbarton> well the meaning of "cabal build" doesn't change when you use sandboxes
12:06:01 <rwbarton> the meaning of "cabal install" does, now it is supposed to install into the sandbox
12:06:05 <rwbarton> so I guess that is somehow relevant
12:06:08 <kini> that makes sense
12:06:15 <rwbarton> well, sort of :)
12:06:17 <l0cust> Hey, about to publish a library, would one of you be kind enough to look at it, make sure I didn't do anything stupid https://github.com/pharpend/wai-responsible
12:06:36 <kini> I guess cabal build should at least become aware of packages that are in the sandbox, if the code it's building tries to import modules from those packages
12:06:39 <rwbarton> I wouldn't be surprised if there was some utterly inscrutable reason why this behavior is considered correct
12:07:00 <rwbarton> right, same for cabal install, but that is covered by the sandbox config
12:07:02 <kini> so I guess the workflow should be, like...
12:07:38 <kini> when hacking on a cabal project, install the dependencies into the sandbox, but just build your package in the normal way, rather than installing it into the sandbox and having it get built in some transient directory somewhere with a hash in its name
12:08:32 <rwbarton> maybe the idea is if you were to "cabal install otherpackage" inside the sandbox then it would use dist/dist-sandbox-someotherhex/build"
12:08:34 <kini> luckily there is a --dependencies-only flag to `cabal install` that can be used for that first part...
12:08:46 <michaelt> l0cust: well, it passes the first test, it compiles
12:08:50 <kini> rwbarton: well, maybe, but sandboxes don't have to be in ./.cabal-sandbox
12:09:01 <kini> you can do `cabal sandbox --sandbox /path/to/sandbox/somewhere init`
12:09:02 <l0cust> michaelt: and 'cabal check' shows no warnings
12:09:11 <rwbarton> true
12:09:20 <kini> and then it would be weird if the build directory were related to $PWD rather than to where the sandbox is... wouldn't it? maybe?
12:09:24 <rwbarton> so then where would it store temporary build products
12:09:37 <kini> I would assume somewhere inside the sandbox, but maybe not
12:10:16 <michaelt> l0cust: it looks like it could do with more documentation, but maybe it's obvious how to use it if youre in wai land
12:10:34 <rwbarton> "cabal sandbox --sandbox /path/to/sandbox/somewhere init" still creates a cabal.sandbox.config in your working directory
12:10:35 <l0cust> michaelt: I will add more documentation later, it's needed for a couple projects I'm working on
12:10:46 <kini> true
12:11:05 <rwbarton> huh there is no "cabal install --sandbox"
12:11:05 <kini> well, it had better create something in your working directory, otherwise how will anything know what sandbox the current project is tied to? :)
12:11:13 <kini> yup
12:11:16 <bennofs> is it possible to have cabal re-run the preprocessing stage when doing :r in cabal repl and a .hsc file changed?
12:11:18 <kini> it reads what sandbox to install to from cabal.sandbox.config
12:11:22 <rwbarton> oh because it uses the config right
12:11:26 <Guest65722> what is a nice way to produce this kind of list [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1),(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2) ] ?
12:11:37 <rwbarton> well hmm
12:11:41 <donri> rwbarton: cabal --sandbox-* install
12:11:51 <rwbarton> it didn't make a dist/ directory in my current directory
12:12:05 <kini> when you did what?
12:12:22 <joelteon> [(f c, g r) | f <- [(+2),(-2),(+1),(-1)], g <- [(+2),(-2),(+1),(-1)]]
12:12:26 <rwbarton> cabal install mtl with a sandbox config
12:12:36 <joelteon> oh, except instead of (-2) and (-1) you'll need (subtract 2) and (subtract 1)
12:12:38 <rwbarton> it is using /tmp/mtl-2.1.3.1-22770/mtl-2.1.3.1/dist
12:12:44 <parc> is there a way to derive Applicative/Functor if you've already written a Monad instance?
12:12:45 <kini> joelteon: that includes (c+2,r+2)
12:12:56 <joelteon> oh I couldn't even read the list properly
12:13:02 <joelteon> don't mind me
12:13:13 <Guest65722> thx :)
12:13:20 <donri> parc: yes, fmap = liftM and (<*>) = ap and pure = return
12:13:22 <joelteon> Guest65722, that's not right
12:13:40 <kini> rwbarton: fun...
12:13:58 <Ch0c0late> Actually, have gotten stuck with a problem known as prime factorization. The question what is the largest prime factor of a given number? Need some piece of advice.
12:14:14 <Ch0c0late> *the question is
12:14:16 <rwbarton> same if I go back to my /tmp/cabal-test
12:14:16 <parc> donri: i mean automating that. like an extension that would allow you do deriving (Applicative, Functor) in the data declaration
12:14:32 <rwbarton> so in summary, I have no idea what the use of dist/dist-sandbox-d92f0862/build/ is
12:14:40 <ReinH> Ch0c0late: folks are probably familiar with prime factorization here. What are you having trouble with?
12:14:44 <rwbarton> maybe submit a bug report/question on cabal github?
12:14:45 <donri> parc: no, but you can derive Functor with DeriveFunctor
12:14:50 <donri> parc: independent of any Monad
12:15:00 <kini> can one submit questions to a bug tracker...?
12:15:14 <ReinH> (and then make it a monad for free, if you're into that kind of thing)
12:15:23 <rwbarton> well, you can show how "cabal install; cabal build" acts oddly, and then either it will get fixed or answered :)
12:15:29 * hackagebot wai-responsible 0.0.0.0 - Response interface for WAI.  http://hackage.haskell.org/package/wai-responsible-0.0.0.0 (pharpend)
12:15:44 <kini> true I guess. I mainly just want to figure out what kind of workflow I should be using with sandboxes
12:16:08 <kini> I mean, when I'm just writing code and making sure it compiles, sticking to `cabal install` works just fine
12:16:08 <eacameron1> what's the preferred string formatting lib?
12:16:24 <ReinH> My biggest issue with sandboxes right now is just that the tooling in the ecosystem hasn't really gotten around to supportung them very well. :/
12:16:28 <kini> but when I want to run the tests, I run `cabal test`... and I guess that runs `cabal build`, which reads configuration from `cabal configure`, all of which are independent of the version of my package I've set up in the sandbox with `cabal install`
12:16:30 <dwcook> eacameron, text, I guess? What do you mean by formatting?
12:16:30 <Ch0c0late> ReinH: Want to get all prime factors of a given number(< 10^6) and then find the largest one.
12:16:46 <ReinH> Ch0c0late: Ok, what have you tried and where are you having trouble?
12:16:46 <eacameron> I mean like python's string.format
12:16:49 <rwbarton> kini: yes, it seems so
12:17:00 <kini> so any flags I pass to `cabal install` like --enable-tests or --enable-library-coverage or whatever only apply to the version sitting in the sandbox, and not the version sitting in the cabal project's normal directories like dist/build
12:17:04 <ReinH> @paste
12:17:04 <lambdabot> Haskell pastebin: http://lpaste.net/
12:17:05 <kini> at least... I think that's how it works...???
12:17:06 <dwcook> eacameron, is that anything like printf?
12:17:38 <rwbarton> well, at a low level of abstraction, they apply to dist/dist-sandbox-d92f0862/build/ but not dist/build/
12:17:45 <eacameron> technically it supports a lot, but mainly I'm interested in keyword expansion
12:17:47 <donri> eacameron: I like interpolatedstring-perl6; formatting might be good too
12:17:58 <dwcook> eacameron, what is keyword expansion?
12:18:18 <kini> rwbarton: I don't even know how much of the configuration is in that directory and how much might be somewhere else, maybe in the sandbox, or in my ~/.cabal or ~/.ghc, or who knows where else
12:18:19 <eacameron> maybe wrong term: "Hi {name}".format(name="you")
12:18:40 <Ch0c0late> ReinH: Well, just tried something with paper and pencil. Nothing more. Trying to get how to formalize it? Well, how to get 10 = 5 * 2
12:18:50 <dwcook> Hmm, don't know of anything in particular that does that, but try donri's suggestions
12:19:46 <rwbarton> kini: AFAIK "cabal configure" basically writes the file dist/setup-config
12:19:57 <rwbarton> (so I should have said "dist/dist-sandbox-d92f0862/" vs "dist/")
12:20:21 <kini> ah, hmm
12:20:26 <ReinH> Ch0c0late: well, let's start with a simpler problem? How would you determine if a number is divisible by 2?
12:20:30 <rwbarton> it might do other stuff along the way but I think that file is the interface between cabal configure and subsequent cabal commands
12:20:51 <Ch0c0late> ReinH: 0 == x `mod` 2. Right?
12:21:56 <ReinH> Ch0c0late: Right, now how would you determine how many times a number was divisible by 2?
12:22:00 <Ch0c0late> ReinH: Oh my, oh my, think got it. Should I list dozens of prime numbers and the same thing I did with 2. For example, 0 == x `mod` 5
12:22:14 <Ch0c0late> *do the same thing
12:22:23 <ReinH> Ch0c0late: you can do that but there's a simpler way
12:22:42 <Ch0c0late> Yes. Answering your question ...
12:24:19 <michaelt> > [ ( c `b` a, r `b'` a') | a <- [1,2] , a' <- [1,2] , b <- [(+), (-)], b' <- [(+),(-)], a /= a']
12:24:21 <lambdabot>  [(c + 1,r + 2),(c + 1,r - 2),(c - 1,r + 2),(c - 1,r - 2),(c + 2,r + 1),(c + ...
12:24:22 <Guest65722> joelteon: works ok as [(f c, g r) | f <- hop, g <- hop] where hop = [(+2),(+1),(subtract 1),(subtract 2)]
12:24:47 <ReinH> michaelt: simplereflect is so good
12:24:53 <Guest65722> better ways?
12:25:55 <Guest65722> could this be made applicative somehow?
12:26:10 <michaelt> oooh, yes
12:26:12 <ReinH> Sure.
12:26:36 <michaelt> wait, there is the constaint that you don't use 2 twice , to judge from your list
12:26:42 <codygman> Thanks pjdelport
12:27:14 <ReinH> Ch0c0late: let's start with a naive partial solution
12:27:47 <Guest65722> michaelt: what did you mean?
12:28:13 <michaelt> well, the really obvious first start would be something like
12:28:18 <ReinH> > let twos 2 = 1 in twos 2
12:28:20 <lambdabot>  1
12:28:31 <ReinH> Ch0c0late: pretty naive, right? ;)
12:31:05 <chrisdone> lots of tryhaskell users at present http://tryhaskell.org/ due to the new-www
12:31:16 <ReinH> chrisdone: it looks great <3
12:32:10 <corgifex> I type "2 + 2"
12:32:19 <corgifex> result: ":: Num a => a"
12:32:56 <corgifex> does that mean I can only use type-level computation?
12:33:04 <Ch0c0late> ReinH: Sorry, had to go. Mommy called me.
12:33:27 <ReinH> Ch0c0late: np
12:33:41 <chrisdone> corgifex: it means the evaluation took too much time and mueval killed the thread, so tryhaskell falls back to trying to get the type instead
12:33:43 <ACSpike> I'm reading about making Either a functor by partially applying the Type Constructor. Does something like flip exist for type constructors?
12:33:50 <chrisdone> reinh: thanks babe <3
12:34:01 <ReinH> chrisdone: 2 + 2 is apparently too much for baby tryhaskell
12:34:11 <chrisdone> reinh: ;)
12:34:15 <ReinH> Ch0c0late: let me know when you want to continue :)
12:34:35 <michaelt> chrisdone: its awesome. maybe one of the demo lines should note the goofy syntax for let f x = x +1 in f 2
12:34:41 <chrisdone> there're 20~ active users at present
12:35:12 <Ch0c0late> ReinH: Okay. I'm ready. To determine how many times a number is divisible by 2 we should dive it it by 2 permanently.
12:35:13 <chrisdone> michaelt: tryhaskell the tutorial itself teaches let syntax
12:35:32 <michaelt> yes
12:36:00 <chrisdone> okay, 30~ active users
12:36:00 <ReinH>  Ch0c0late: let's redo our twos to give the list of 2s instead, so twos 4 = [2,2]
12:36:08 <ReinH> Ch0c0late: if we start with our rather naive
12:36:14 <ReinH> > let twos 2 = [2]
12:36:15 <lambdabot>  not an expression: ‚Äòlet twos 2 = [2]‚Äô
12:36:18 <chrisdone> lol
12:36:24 <ReinH> > let twos 2 = [2] in twos 2
12:36:25 <lambdabot>  [2]
12:36:31 <ReinH> we want to extend this to work on numbers that are not 2
12:36:39 <ReinH> let's try to extend it in a naive way
12:36:57 <ReinH> let twos n | n `mod` 2 == 0 = [2] | otherwise = [] in twos 2
12:37:03 <ReinH> woops
12:37:09 <ReinH> >  let twos n | n `mod` 2 == 0 = [2] | otherwise = [] in twos 2    [12:35]
12:37:12 <lambdabot>  Couldn't match expected type ‚Äò[[a1]] -> t‚Äô with actual type ‚Äò[t0]‚Äô
12:37:13 <ReinH> :( sorry
12:37:22 <ReinH> chrisdone: argh ERC stahp
12:37:35 <ReinH> anyway, that works for 2 but pretty obviously won't work for, say, 4
12:37:45 <pseudolio> Are you sure that's how you should do it? :)
12:37:51 <ReinH> Ch0c0late: what do we need to do to get it to work for even numbers other than 2?
12:38:00 <ReinH> pseudolio: yes.
12:38:55 <Ch0c0late> ReinH: Well, we should have n `mod` 4, 6, etc. Right?
12:40:11 <chrisdone> hehe, watching people type things in tryhaskell
12:40:30 <ReinH> Ch0c0late: well, once we factor out a 2, we need to try again, right?
12:40:31 * hackagebot saferoute 0.1.0.0 - A simple type-safe routing library.  http://hackage.haskell.org/package/saferoute-0.1.0.0 (pharpend)
12:40:43 <chrisdone> expressions are coming in constantly
12:40:43 <ReinH> so we need to check 8 `mod` 2, then 4 `mod` 2, then etc
12:40:47 <Ch0c0late> ReinH: Yes.
12:40:53 <ReinH> so we need... recursion!
12:42:26 <int3__> is there a guide on how to use recursion-schemes? the library has pretty much no documentation :/
12:42:47 <int3__> or do I have to understand the bananas paper first
12:42:55 <kazagistar> chrisdone: how do you view that?
12:42:57 <ReinH> > let twos x | x `mod` 2 == 0 = 2 : twos (x `div` 2) | otherwise = [] in twos 4
12:43:00 <lambdabot>  [2,2]
12:43:08 <ReinH> Ch0c0late: do you see what's going on there?
12:43:27 <Ch0c0late> ReinH: Yes. Thanks. The explanation is great.
12:43:36 <chrisdone> kazagistar: just on the server i have tail on the logs =)
12:44:00 <chrisdone> kazagistar: i thought about exposing it so people could see what other people are trying
12:44:09 <ReinH> Ch0c0late: now you need to try numbers other than 2 and there's an observation that might help:
12:44:20 <ReinH> once we have factored out all the 2s, there won't be any factors of 4 left
12:44:59 <Ch0c0late> Yes. ReinH: We can produce new result from old result. Right?
12:45:26 <kazagistar> chrisdone: I suspect people probably would rather it stay private by default, but adding the opt-in ability for someone to view your session might be nice
12:45:34 <ReinH> Ch0c0late: yes, but because each composite number has prime numbers as factors, and since we test all prime numbers before we test any composite number, no composite number will ever have any factors left
12:46:07 <Ch0c0late> Yes. ReinH
12:46:27 <chrisdone> kazagistar: another fun idea could be to expose a lil' API for broadcasting messages onto a public board
12:46:44 <chrisdone> but it's easy to abuse
12:46:47 <phaazon_> https://hackage.haskell.org/package/happstack-server-7.3.7/docs/Happstack-Server-Routing.html
12:46:57 <phaazon_> the doc for the http function sounds wrong
12:47:00 <phaazon_> (the example)
12:47:12 <phaazon> I guess it should be do http
12:47:15 <chrisdone> docs should be compiled by haddock
12:47:20 <Ch0c0late> ReinH: It's going to be somehow like Dynamic Programming.
12:47:28 <ReinH> Ch0c0late: not really
12:47:31 <chrisdone> there should be a way to write a haskell code sample and have it be type checked
12:47:41 <donri> phaazon: send a patch :)
12:47:49 <phaazon> yeah, right :)
12:47:50 <ReinH> Ch0c0late: it's just an observation that we can test the numbers in order starting with 2 and not worry about whether they are prime
12:48:01 <donri> chrisdone: doctest sorta does that no?
12:48:12 <Ch0c0late> ReinH: Yes
12:48:14 <phaazon> arg, it‚Äôs using darcs
12:48:22 <ReinH> Ch0c0late: worrying about whether they are prime is an optimization we can do
12:48:44 <chrisdone> donri: yeah haddock could use it
12:49:20 <donri> although no type checking or doctesting would have caught this mistake
12:49:49 <ReinH> Ch0c0late: so now we can write primeFactors in a way that recurses and checks each number successively
12:50:21 <Ch0c0late> ReinH: Yes.
12:50:36 <ReinH> we can try: primeFactors n m | n `mod` m == 0 = m : primeFactors (n `div` m) m | otherwise = primeFactors n (m + 1)
12:50:52 <ReinH> where n is the number we are factoring and m is the current potential factor we are trying
12:51:00 <ReinH> the problem is that this recursion doesn't have a base case.
12:51:06 <ReinH> both branches of the guard recurse
12:51:12 <ReinH> so what is our base case?
12:51:38 <ReinH> in other words, when can we stop checking if n has any prime factors?
12:51:56 <phaazon> donri: I can‚Äôt make my darcs work
12:52:03 <phaazon> (dammit curl ssl)
12:53:38 <Ch0c0late> ReinH: 0
12:53:43 <donri> phaazon: cabal get -s happstack-server; cd happstack-server; fix shit; darcs send
12:53:45 <donri> what could be easier
12:54:43 <ReinH> Ch0c0late: or 1
12:54:46 <donri> well ok darcs record first ;)
12:54:55 <phaazon> cabal: Package happstack-server-7.3.7 does not have any usable source
12:54:56 <phaazon> repositories.
12:55:01 <Ch0c0late> ReinH: Can I PM you?
12:55:03 <ReinH> Ch0c0late: so: primeFactors 1 _ = []; primeFactors n m ...
12:55:14 <ReinH> Ch0c0late: sure, or we can take it to #haskell-overflow
12:55:27 <phaazon> why don‚Äôt you guys just use git :)
12:55:32 * hackagebot hjsmin 0.1.4.7 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.7 (AlanZimmerman)
12:56:21 <phaazon> a friend told me ‚Äúpatches-oriented versionning tools are too oldish, the new way is the time-oriented/snapshot‚Äù
12:56:31 <phaazon> I‚Äôd rather like the darcs‚Äô patches though
12:56:48 <phaazon> if it was faster and handles better big project :(
12:56:52 <S11001001> phaazon: http://www.reddit.com/r/haskell/comments/1zmi4s/haskeleton_a_haskell_project_skeleton/cfv85sz#cfwqsqg
12:57:33 <Forgetaboutit> phaazon: just curious: what's particularly interesting about darcs?
12:58:23 <donri> darcs doesn't guess when merging histories
12:58:57 <Forgetaboutit> donri: in contrast to? Git?
12:59:05 <donri> for one yes
12:59:33 <donri> phaazon: you need darcs in $PATH for cabal get to work
13:00:01 <ReinH> Ch0c0late: there are two obvious optimizations we can do here
13:00:05 <phaazon> Forgetaboutit: the fact it‚Äôs not snapshot-oriented
13:00:16 <phaazon> you don‚Äôt have people ‚Äúbehind‚Äù your head
13:00:21 <phaazon> nor ‚Äúabove‚Äù
13:00:33 <ReinH> Ch0c0late: the first is to stop at ceiling (sqrt n), the second is to use a list of prime numbers instead of just successive numbers
13:00:35 <phaazon> but I _love_ branches
13:00:40 <phaazon> and darcs doesn‚Äôt have that
13:00:50 <Ch0c0late> ReinH: Yes.
13:00:50 <donri> the only way to merge snapshots is by guessing
13:00:58 <donri> but there are some cool stuff about git too
13:01:09 <phaazon> I guess
13:01:11 <phaazon> to me
13:01:16 <donri> in a way git is "pure"
13:01:21 <ReinH> for the first we can add another guard: primeFactors n m | m * m > f = [n]
13:01:25 <Forgetaboutit> hm, but can't you calculate patches by diffing snapshots anyway?
13:01:32 <pseudolio> Pure garbage?
13:01:45 <donri> well the git object store
13:01:57 <donri> it's a lot like a pure immutable data structure
13:01:59 <ReinH> for the second we can start by switching from an int to a list of ints: primeFactors n (m:ms), replacing m + 1 with ms
13:02:12 <Forgetaboutit> donri: except for rebase ^^
13:02:13 <phaazon> the pro for darcs: extremely simple, friendly ; the cons: slow, buggy with huge files. pro for git: fast and works for all kind of projects; the cons: extremely hard to get your head around all those rubbish commands
13:02:23 <ReinH> then we can call that primeFactors' and write primeFactors n = primeFactors' n [1..]
13:02:28 <Ch0c0late> ReinH: And for the second a list like a = [1,2,3,5, 7, 11, 13]
13:02:42 <ReinH> Ch0c0late: finally we can use some nice, performant list of prime numbers and write primeFactors n = primeFactors n primes
13:02:50 <ReinH> er, with a ' on the right hand side
13:03:07 <phaazon> btw, who actually uses svn anymore? :D
13:03:11 <ReinH> note that [1..] and primes can both be infinite lists
13:03:16 <pseudolio> LLVM uses svn.
13:03:18 <ReinH> ([1..] obviously is)
13:03:23 <donri> Forgetaboutit: rebase doesn't change anything
13:03:24 <phaazon> arf
13:03:49 <donri> Forgetaboutit: git gc is the main offender
13:03:54 <Ch0c0late> ReinH: Yes
13:04:04 <ReinH> Ch0c0late: if you've already solved the previous problems you should have a list of primes lying around ;)
13:04:15 <Forgetaboutit> donri: ah, right. Not a Git expert here :)
13:04:20 <donri> but then again git gc isn't all that different from say ghc gc
13:04:23 <ReinH> Ch0c0late: and there's also
13:04:24 <ReinH> @hackage primes
13:04:25 <lambdabot> http://hackage.haskell.org/package/primes
13:04:29 <Ch0c0late> ReinH: heh, Yes.
13:05:10 <ReinH> Ch0c0late: does that all make sense?
13:05:52 <Ch0c0late> ReinH: Yes. Got the whole story.
13:05:57 <ReinH> Ch0c0late: awesome
13:06:11 <Ch0c0late> ReinH: Good Job.
13:06:15 <ReinH> Ch0c0late: :)
13:06:50 <donri> Forgetaboutit: in fact rebase is a good example of just how "pure" it is. you can't rewrite history without ending up with a new "branch"
13:07:25 <ReinH> donri: the mutable thing here is just the pointer in .git/refs/heads
13:07:28 <donri> rebase makes new commits, it doesn't "mutate" history
13:09:40 <donri> and a git commit hash represents the whole history leading up to that commit including the full contents of every tracked file for each commit, so that's kinda cool
13:09:54 <ReinH> Forgetaboutit: so branches in git are literally text files in .git/refs/heads that contain the SHA of the tip of the branch. That's it. When you "mutate" a branch you are actually updating the object space in a non-destructive way and then just changing the "pointer", the SHA in that text file.
13:10:33 <donri> i put branch in quotes because i didn't mean "gt branch" but rather simply a branch in the DAG
13:10:37 <ReinH> same as when you git reset, commit, etc
13:10:37 <Forgetaboutit> ReinH: I was aware of this.  I didn't know however, that rebase creates new commits
13:10:48 <donri> (although that's all git branches are, with labels)
13:10:58 <donri> s/gt/git/
13:11:01 <ReinH> Forgetaboutit: well, since commits are cryptographically protected against being modified, there's no alternative.
13:11:25 <Forgetaboutit> kinda cool :)
13:12:13 <donri> git is a great content tracker. it's not a great revision and merge tool though
13:12:15 <ReinH> the git history and object space are pretty much functional data structures ;)
13:13:00 <Forgetaboutit> donri: can you name concrete pain points?
13:13:07 <savanni> This is going to be random, but, is there a typeclass for the Data.Time.* types for getting back the day associated with a particular time?
13:13:50 <kazagistar> related to this thread... http://www.reddit.com/r/haskell/comments/2a56d2/learn_why_isnt_integer_an_adt/ ... wouldn't an ADT simply be any type that has a kind other then just (*)?
13:13:50 <donri> Forgetaboutit: as mentioned earlier, git has to guess when merging
13:14:18 <kazagistar> (ADT referring to abstract data type in that thread)
13:14:38 <donri> Forgetaboutit: it also has to guess about files being renamed, and frequently gets that wrong, which makes file-specific logs much less useful
13:14:42 <ReinH> donri: it's not very good, but it's still better than most of the alternatives
13:15:04 <ReinH> with the caveat that I don't know darcs
13:15:09 <donri> :)
13:15:34 * hackagebot git-annex 5.20140709 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140709 (JoeyHess)
13:15:45 <sm> speak of the devil!
13:15:47 <Forgetaboutit> donri: hm, I didn't experience these kind of problems yet
13:16:18 <Forgetaboutit> I only know that SVN is genuinely not my favorite VCS
13:16:58 <chrisdone> git's main gripe is the pure-content thing and the fact it's too (intentionally) dumb
13:17:04 <chrisdone> it really cares about order
13:17:25 <chrisdone> as opposed to darcs which cares more about commuting and whether the end result is the same
13:18:12 <ReinH> chrisdone: I have noticed that if I work in a way that makes git happy, it often increases my happiness as well
13:18:25 <Forgetaboutit> chrisdone: ah, I think I know what you're talking about
13:18:54 <ReinH> chrisdone: for instance, for prosey stuff when I switched to breaking lines in semantic places like at the end of thoughts, it made git happier and it made editing easier too.
13:19:32 <donri> Forgetaboutit: http://r6.ca/blog/20110416T204742Z.html
13:19:33 <ReinH> diffs now tend to be "old thought -> new thought" rather than just "old line -> new line", which is quite nice
13:20:09 <platz> for the most pedantic there is also this issue: http://r6.ca/blog/20110416T204742Z.html basically you can't predict how git will merge - it doesn't follow the ‚Äúmerge associativity law‚Äù
13:20:17 <chrisdone> donri: i think that blog is a good example of the darcs perspective
13:20:21 <platz> but which is probably never an issue in day to day work
13:20:36 <chrisdone> the darcs is that you want the tool to think for you
13:20:41 <Forgetaboutit> donri: tbh, I never merge because I find rebasing a lot nicer
13:20:47 <chrisdone> the git perspective is that you don't trust your tools so you have to think for it
13:20:51 <ReinH> To be extra pedantic I should point out that this isn't "git's" problem per se, it's a problem with the default merge strategy. Unless someone has proven that it's impossible to write a "correct" strategy.
13:21:08 <ReinH> platz: :p
13:21:15 <donri> Forgetaboutit: merging isn't just "git merge"
13:21:33 <ReinH> Forgetaboutit: rebasing is a lot nicer when you have exactly one committer, in my experience.
13:21:46 <ReinH> at which point you're basicallly using git in a degenerate SVN-compatible mode ;)
13:22:15 <ReinH> Which is fine: git is really a tool for constructing change control workflows.
13:22:16 <chrisdone> i like rebasing because order matters to me. commits for me are a sequence of actions done to the code
13:22:23 <ReinH> And if that workflow works for you then it works.
13:22:41 <chrisdone> merging and the darcs "do it for me and i don't much care what it looks like at the end" attitude is too fuzzy wuzzy for me
13:23:01 <ReinH> chrisdone: I like merging because it works, whereas rebasing often does not.
13:23:03 <ReinH> :p
13:23:15 <donri> merging keeps more information...
13:23:22 <ReinH> Yes, and that information is actually quite useful
13:23:23 <chrisdone> reinh: exactly, you want the tool to "just work"
13:23:32 <ReinH> The Puppet open source project had a strict rebase policy for a while
13:23:43 <chrisdone> merging keeps information about who ran what source control command when
13:23:52 <chrisdone> rebasing records actual code changes in a logical manner
13:23:55 <ReinH> We had to develop tooling to deal with the problems of rebasing 100s of different committers' work across various original branches
13:24:07 <ReinH> The maintenance of these tools eventually cost us a full-time developer's salary
13:24:10 <donri> merging keeps information about which set of commits came from which merge
13:24:16 <ReinH> Then we finally switched to merging and the problems just disappeared
13:24:16 <pseudolio> It records fictional code changes.
13:24:30 <donri> that makes it easier to revert, for one
13:24:31 <pseudolio> And lets you hide mistakes.
13:24:39 <Forgetaboutit> ReinH: Do you still rebase locally?
13:24:42 <ReinH> So merging literally saved us a hundred thousand dollars
13:24:44 <chrisdone> why would you want to keep mistakes?
13:24:44 <pseudolio> That is, make mistakes that are harder to detect.
13:24:52 <ReinH> Forgetaboutit: I rebase in some very specific cases, yes
13:25:00 <ReinH> But I've made merging my default
13:25:06 <pseudolio> Sometimes you make mistakes when you merge.
13:25:16 <pseudolio> When you rebase, it looks like you made the mistake from the start.
13:25:25 <pseudolio> When you merge, you can tell that it was a merge mistake.
13:25:26 <chrisdone> technically you did
13:25:27 <Cale> I like darcs because it fails horribly less often for me. I always seem to manage to get git into weird states where it doesn't want to do what I tell it to do and its explanation of why makes no sense to me, so I end up cloning a new repo and moving changed files into it, which kind of defeats the purpose of having a revision control system somewhat.
13:25:34 <rwbarton> merge conflict diffs are unreadable, so that's a pretty good way to hide mistakes too
13:25:37 <pseudolio> No, you did not technically do that.
13:25:44 <chrisdone> you did, here's why
13:25:44 <ReinH> Cale: git definitely has a big UX problem.
13:26:01 <chrisdone> the reason you rebase is because YOUR code has lower priority than the code you're rebasing onto
13:26:03 <RyanGlScott> How do you marshal a struct type in c2hs?
13:26:06 <ReinH> chrisdone: the question isn't whether you did that, it's *when* you did that.
13:26:14 <platz> I've never been a big fan of git bisect, so that argument against merging always felt shallow to me
13:26:34 <ReinH> platz: git bisect actually does pretty well with merges, I'm not sure where that particular FUD comes from.
13:26:44 <chrisdone> merging is for public tracking between developers
13:26:53 <ReinH> chrisdone: I think I would agree with that.
13:26:59 <pseudolio> If git bisect doesn't work with merges, that's idiotic, because merges should give it more information about where the problem came from.
13:27:01 <donri> chrisdone: oh i think it's a good idea to rebase before a pull request, but usually upstream is better of merging pull requests
13:27:14 <donri> better off
13:27:21 <ReinH> The rule is that you don't "rewrite" shared history.
13:27:32 <ReinH> Pretty much everything else follows from this and gives a sane workflow.
13:27:36 <rwbarton> pseudolio: I think that's not really true if you had to resolve a merge conflict manually
13:27:42 <Cale> Also, the fact that git doesn't take the history of changes into account when determining how to merge seems bad.
13:27:48 <chrisdone> a rebase says "i've been working on this repository, but meanwhile someone else has changed things. so i need to re-consider everything i've done and apply my changes ontop of what they did" rebasing makes you work through that and if you have conflicts some commits might not even be relevant anymore. a merge will include any stupid stuff you have, pointlessly, and hide things
13:28:02 <donri> although squash pulling is also nice for merging contributions
13:28:23 <donri> throws away more information but still keeps the merges "isolated"
13:29:09 <chrisdone> donri: right, rebase before a pull request. or in another case: merging upstream repos that you're rebasing onto
13:29:24 <pseudolio> rwbarton: How does that make it not true?
13:29:30 <ReinH> I wonder if anyone has any Haskell questions...
13:29:31 <chrisdone> e.g. if i have a modified version of lens, it makes 100% sense that i rebase my modifications ontop of lens, rather than merging the remote
13:29:47 <donri> pull requests with commits for "merge master from upstream" every other commit are ugly
13:29:54 <chrisdone> i think the darcsy approach is to merge everything cleverly
13:30:24 <rwbarton> rebase forces you to resolve the merge patch for each patch you rebased individually
13:31:11 <donri> duno if i'd call darcs "clever". it's meant to be well-defined and repeatable
13:31:18 <donri> as opposed to the guess work required to merge snapshots
13:31:22 <Cale> ReinH: Yeah, this is a bit offtopic :)
13:31:51 <ReinH> Cale: seems like a reasonable #haskell-blah discussion, and we wouldn't all feel slightly guilty about it ;)
13:32:48 <donri> #haskell-blah, also known as #haskell-minus-chrisdone
13:32:55 <ReinH> hahaha
13:33:03 <ReinH> Also sometimes known as #world-cup-spoilers :(
13:34:34 <RyanGlScott> How do you properly {#get #} a nested struct in c2hs?
13:35:05 <RyanGlScott> e.g., typedef struct { int x; other_struct_t y; } some_struct_t;
13:35:36 <Cale> RyanGlScott: This document describes all the hooks that c2hs has. It's a little light on stuff for accessing structs, but there's {#offsetof ...#} which should be useful in writing Storable instances. https://github.com/haskell/c2hs/wiki/Implementation%20of%20Haskell%20Binding%20Modules
13:36:06 <Cale> Oh, right, there're get hooks too
13:36:23 <RyanGlScott> I've seen that page. If you just try doing {#get some_struct_t.other_struct_t #}, it will complain
13:36:37 <RyanGlScott> "There is not automatic support for marshaling of structures and unions"
13:36:59 <RyanGlScott> I can manually define a Storable instance for the Haskell equivalent of other_struct_t, but after that, I'm stuck
13:37:19 <chrisdone> <rwbarton> rebase forces you to resolve the merge patch for each patch you rebased individually +1
13:37:46 <chrisdone> (sorry, dropped out of the convo)
13:38:29 <RyanGlScott> Is there a way to get c2hs to convert {#get some_struct_t.other_struct_t #} to (\ptr -> peekByteOff ptr <num> :: IO OtherStructInHaskell)?
13:38:57 <chrisdone> oh, it died. oh well, next time ;)
13:40:16 <RyanGlScott> I guess I'd have to manually type (ptr -> peekByteOff ptr {#offsetof some_struct_t.other_struct_t #}) then
13:40:43 <Cale> RyanGlScott: I sort of think that's what it ought to do -- it's complaining when you do that?
13:41:04 <Cale> "An access path of the form apath.cid specifies that the value of the struct member called cid should be accessed."
13:41:41 <RyanGlScott> I haven't tried the latter approach, but the first approach will never work since c2hs will abort upon trying to get a struct/union type
13:42:00 <RyanGlScott> I guess I should file an issue, since I feel like this would be easy to fix
13:45:14 <joelteon> does anyone know how I can use the haddock build hook to pass GHC options to haddock?
13:46:04 <lispy> joelteon: I always look for example Setup.hs files
13:46:17 <lispy> joelteon: Or wait, you mean with cabal right?
13:46:19 <joelteon> well, it looks like it ignores haddockProgramArgs
13:46:23 <joelteon> yeah, I mean with cabal
13:46:36 <joelteon> the default hook just invokes haddock, and haddock itself doesn't do anything with haddockProgramArgs
13:46:47 <tibbe> edwardk: is this http://stackoverflow.com/questions/12230088/how-can-i-recover-sharing-in-a-gadt still the state of the art for recovering sharing in GADTs?
13:47:02 <lispy> joelteon: what are you trying to pass as an arg?
13:47:11 <joelteon> I'm trying to force GHC to use cpphs
13:47:26 <joelteon> I can pass the argument during cabal haddock, but standalone-haddock doesn't accept any extra arguments
13:47:30 <joelteon> so I'm trying to do it with my Setup.hs instead
13:47:48 <lispy> standalone-haddock?
13:48:04 * lispy is getting confused about what works and what is not working
13:48:07 <joelteon> it's a tool that converts links inside the package to relative links and links outside to hackage so you can host your own documentation somewhere
13:48:21 <joelteon> my package doesn't build with clang CPP but it does with cpphs, which is my default
13:48:27 <lispy> oh, standalone-haddock is a tool. Gotcha.
13:48:30 <joelteon> but standalone-haddock uses clang CPP and can't be overridden
13:48:46 <joelteon> so my solution was to change my Setup.hs so that the haddock invocation calls cpphs instead of clang -E
13:49:10 <joelteon> but when you pass GHC options to haddock in the haddock hook, they do nothing
13:49:31 <joelteon> so now I'm stuck
13:49:35 <lispy> Thanks. That helps.
13:50:10 <lispy> joelteon: I'm not really familiar with any of the code/details, but could it be that you need to unpack them from the GHC options and move them to some haddock-specific options in the hook?
13:50:32 <joelteon> well, this is what HaddockFlags looks like
13:50:34 <joelteon> http://hackage.haskell.org/package/Cabal-1.20.0.1/docs/Distribution-Simple-Setup.html#t:HaddockFlags
13:50:58 <lispy> and you're trying to use haddockProgramArgs ?
13:51:15 <lispy> When you say it ignores those flags, are you using --verbose=3 or some other way to see that they are ignored?
13:51:17 <joelteon> right, but this module http://hackage.haskell.org/package/Cabal-1.20.0.1/docs/Distribution-Simple-Haddock.html#v:haddock does not feature any use of the identifier "haddockProgramArgs"
13:51:44 <joelteon> if I use v3, I see the arguments passed to haddock, none of which are the ones I asked for
13:52:25 <lispy> sorry, I have to run
13:52:28 <joelteon> okay
13:52:30 <zorg24> How would I something like: print $ maximum $ map power [1..999999] if I want the second argument of power to be say 3
13:53:01 <inf-groupoid> (`power` 3) perhaps
13:53:09 <Cale> zorg24: Or (\x -> power x 3)
13:53:19 <zorg24> cool thanks
13:53:59 <codygman> The library I'm using (webdriver) uses throwIO from lifted-base for exceptions. How should I handle the exceptions it throws? I would like to abort out of the entire block running if any errors happen after printing error messages.
13:57:27 <zorg24> Also I have a recursive function and I suspect memoizing would alot, but I have no clue how to go to about that could anyone help me out with that
13:59:32 <zorg24> Oh here's the code https://gist.github.com/anonymous/4b8511229947d0d94960
14:01:51 <zorg24> In python I'd just slap them in a dict to memoize the function, but I have no clue what to do in Haskell
14:03:42 <pjdelport> zorg24: The standard way to do it in Haskell would be to just reify the function in some data structure.
14:04:19 <pjdelport> zorg24: For sequences, it's common to stick it in a list; for random access, you might want to look at an Array.
14:04:24 <zorg24> pjdelport: What do you mean by reify?
14:05:14 <c_wraith> I actually like conal's memotrie library
14:05:20 <zorg24> Also if you look at the code the second parameter doesn't actual affect the output by more a constant amount
14:05:20 <pjdelport> zorg24: To make the structure of the function become embodied in a persistent data structure, basically.
14:05:24 <zorg24> oh
14:05:58 <c_wraith> memotrie has a really slick interface, unless you need to add your own instances.  Then it's just an ok interface. :)
14:06:00 <pjdelport> zorg24: For example, the usual Fibonacci sequence example as a list would be: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:06:10 <zorg24> I guess I could get around the second parameter, by having a recursive helper function and only memozing the main function
14:08:53 <zorg24> hmm I really can't think of a great way to memoize this b/c of the second parameter
14:10:02 <c_wraith> zorg24: that code has a second performance issue, though
14:10:16 <zorg24> What's that?
14:10:28 <c_wraith> zorg24: it never forces the second argument, so it builds up a linear chain of (+ 1) function calls in memory
14:10:36 <pjdelport> zorg24: Just using (`collatzDist` 0) as the function should be fine.
14:11:26 <c_wraith> zorg24: the simplest change to fix that issue is changing the $ on lines 6 and 7 to $!
14:11:34 <zorg24> ok
14:11:56 <zorg24> does $! force it to not be lazy?
14:12:06 <c_wraith> it does something more specific than that.
14:12:15 <zorg24> What?
14:12:36 <benzrf> it evaluates the 2nd arg to whnf before applying, iir
14:12:38 <benzrf> c
14:12:52 <zorg24> oh cool
14:12:55 <pjdelport> $! is basically like $, but strict in the second argument
14:13:21 <pjdelport> An equivalent way to do it is to enable BangPatterns, and change the len parameter to !len
14:14:08 <zorg24> pjdelport: yeah but it won't memoize well because oh second parameter for example you'd end up memoizing: collatzLen 5 0; collatzLen 5 1; collatzLen 5 2;....
14:14:28 <zorg24> all the which would be off by the second argument
14:14:50 <zorg24> the memoization would probably end up doing nothing....
14:15:14 <c_wraith> don't make it tail-recursive.
14:15:17 <c_wraith> That'll help.
14:15:26 <c_wraith> Then it can actually memoize
14:15:52 <c_wraith> (tail recursion is not usually an optimization in haskell)
14:16:27 <zorg24> c_wraith: How should I do it then?
14:17:05 <Forgetaboutit> c_wraith: no TCO guaranteed?
14:17:23 <Cale> Forgetaboutit: There's no call stack
14:17:24 <joelteon> given a PackageDB, how do I get the absolute path to it?
14:17:27 <pjdelport> zorg24: The simple way to reify it would be something like: array (1,999999) [ (i, collatzLen i 0) | i <- [1..999999] ]
14:17:36 <Cale> Forgetaboutit: So, "TCO" is a bit of a weird thing to talk about
14:17:52 <pjdelport> err, collatzDist
14:17:56 <c_wraith> pjdelport: that doesn't actually work with the collatz sequence, though
14:17:58 <Forgetaboutit> Cale: oh, interesting
14:18:07 <c_wraith> pjdelport: values can grow much larger than their starting point
14:18:20 <pjdelport> zorg24: Then you get individual entries with collatzDists ! n
14:18:35 <pjdelport> zorg24: The array persists the values, so they'll only be computed once.
14:19:02 <zorg24> pjdelport: gotcha, one question though what does array (1,999999) do?
14:19:09 <rwbarton> collatz is more like the second memoization problem you should solve
14:19:10 <pjdelport> c_wraith: collatzDist doesn't return the sequence itself; it counts how long a starting point takes to reach 1 :)
14:19:19 <rwbarton> for the reason c_wraith mentioned
14:19:21 <Cale> Forgetaboutit: Under lazy evaluation, expressions are evaluated outermost-first. GHC does happen to use a stack, but rather than function calls, it primarily keeps track of what are effectively case expressions waiting for their scrutinee to be sufficiently evaluated to pattern match on.
14:19:26 <c_wraith> pjdelport: that's irrelevant
14:19:39 <c_wraith> pjdelport: the important part is what arguments the recursive call uses
14:20:20 <pjdelport> zorg24: That's the bounds of the array
14:20:23 <c_wraith> pjdelport: the recursive call for 999999 will try to look up the result at 999999*3 + 1, for instance.
14:20:36 <zorg24> oh ok
14:20:48 <njcomsec> is haskell cheeki breeki iv damke?
14:21:13 <zorg24> one more question my datastructure instincts say to use a HashMap, why'd you go for an array
14:21:15 <Forgetaboutit> Cale: so I can think of functions as a graph of thunks which may or may not be evaluated?
14:22:11 <pjdelport> c_wraith: Not in the above definition; that's just for persisting the final counts.
14:23:01 <c_wraith> pjdelport: but if the intermediate calls don't use the table, you're not gaining anything from your memoization.
14:23:06 <Cale> Forgetaboutit: Yeah, typically I tend to think in terms of graph reduction (which is pretty close to what actually exists in memory), or well, even just thinking about it in terms of rewriting expressions is good enough in most cases.
14:23:08 <zorg24> actually I guess an array would be fine (might waste some memory, depends on how they're implemented in Haskell)
14:23:43 <pjdelport> c_wraith: You're still gaining only calculating each entry once (even if each is calculated separately).
14:23:50 <Cale> Forgetaboutit: For an example of how you can get a stack overflow, let's look at how  foldl (+) 0 [1,2,3]  is evaluted (and imagine that the list might be much longer)
14:23:58 <Cale> @src foldl
14:23:59 <lambdabot> foldl f z []     = z
14:23:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:24:01 <codygman> @undo do { b <- findElem $ ByXPath "//input[@value='Update Cart']"; click b }
14:24:01 <lambdabot> findElem $ ByXPath "//input[@value='Update Cart']" >>= \ b -> click b
14:24:23 <gigamonkey> Okay, my hoogle-fu is weak. I feel like this function must exist ...
14:24:23 <pjdelport> zorg24: An array is more compact and efficient than HashMap for contiguous ranges.
14:24:28 <zorg24> c_wraith: yeah I think you're right I'm not convinced memoizing it as it is will help
14:24:29 <gigamonkey> foo :: Maybe a -> Maybe a -> Maybe a
14:24:33 <gigamonkey> foo a def = case a of Nothing -> def; x -> x
14:24:42 <Cale> foldl (+) 0 [1,2,3] -> foldl (+) (0 + 1) [2,3] -> foldl (+) ((0 + 1) + 2) [3] -> foldl (+) (((0 + 1) + 2) + 3) [] -> ((0 + 1) + 2) + 3
14:24:50 <gigamonkey> I mean, clearly it does exist. But with a better name. ;-)
14:25:08 <c_wraith> zorg24: are you willing to use an external library and deal with spoilers? I have a version using the memotrie library that's basically instantaneous.
14:25:45 <jle`> gigamonkey: you can use maybe
14:25:47 <Forgetaboutit> Cale: Ah ok, I understand :)
14:25:53 <zorg24> c_wraith: I'd like to trty to memoize it myself
14:25:56 <Cale> Up to here, the stack has barely been used (zero or one stack element gets used, depending)
14:26:12 <jle`> foo a def = maybe def Just a
14:26:12 <quchen> :t \def -> maybe def Just -- gigamonkey
14:26:13 <lambdabot> Maybe a -> Maybe a -> Maybe a
14:26:14 <zorg24> but go ahead and give me the link for reference I guess
14:26:14 <pjdelport> zorg24: You can define the array in terms of itself, too, to take advantage of shared substructure, but then you have to deal with numbers going out of bounds, as c_wraith pointed out.
14:26:16 <Pythonfant> gigamonkey: <|>
14:26:23 <Cale> The only thing we've been matching on has been the list, and it was already evaluated, so there wasn't much waiting around
14:26:29 <Pythonfant> Nothing <|> Just 3
14:26:31 <Pythonfant> > Nothing <|> Just 3
14:26:32 <lambdabot>  Just 3
14:26:33 <jle`> oh yeah, (<|>)
14:26:35 <jle`> doh
14:26:38 <Cale> Forgetaboutit: But now, the outermost function is (+) in (...) + 3
14:27:04 <Cale> Forgetaboutit: and (+) needs to know what its left argument is in order to evaluate (it will internally be doing some pattern matching)
14:27:21 <gigamonkey> Where does <|> come from? I get "Not in scope: `<|>'"
14:27:27 <Cale> Forgetaboutit: So, this waits on the stack while ((0 + 1) + 2) is evaluated
14:27:30 <quchen> ?hoogle (<|>)
14:27:31 <zorg24> yeah pjdelport the issue I have with what you did is you get no speed gain when calculating that array from the memoization so it should take about the same amount of time
14:27:32 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
14:27:32 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
14:27:32 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
14:27:33 <pjdelport> zorg24: There are a few approaches to that; you can either fall back to non-memoized calculation when it overflows, with a conditional check, or you could do something like make the result a Maybe, and just fail entries that go out of bounds. (So that you can do your experimentation, and increase the bounds if necessary until all the numbers you care about
14:27:33 <pjdelport> are covered.)
14:27:36 <Cale> and of course, then you have the same issue
14:27:47 <Forgetaboutit> Cale: So this could actually overflow for huge lists, right?
14:27:50 <Pythonfant> gigamonkey: http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Applicative.html#v:-60--124--62-
14:27:50 <Cale> Yes
14:27:54 <Pythonfant> control.applicative
14:27:58 <gigamonkey> Yup. Thanks.
14:28:27 <zorg24> pjdelport: I don't follow why it would overflow
14:28:29 <Cale> GHC is smart enough to avoid this particular stack overflow if optimisations are on (strictness analysis fixes things up)
14:28:29 <rwbarton> Alternatively (so to speak), mplus from Control.Monad
14:29:14 <Forgetaboutit> Cale: or I could just use foldr or foldl'
14:29:17 <Cale> But in general, yeah, this is how most stack overflows happen: you build up a large expression made up of strict functions (ones which need to pattern match on their arguments), and then as all the nested matches happen, you consume the stack
14:29:25 <Cale> In this case, you'd want to use foldl'
14:29:45 <Cale> foldr also generates a stack overflow in this case, but in a slightly different way
14:30:00 <Cale> foldr (+) 0 [1,2,3] -> 1 + foldr (+) 0 [2,3]
14:30:02 <pjdelport> zorg24: If your array goes up to 100, then the calculation for 35 will try n*3+1 == 106 next, which is out of bounds of the array.
14:30:08 <zorg24> oh
14:30:24 <Cale> and then the (+) happens, and needs to match on its second argument
14:30:41 <Cale> and that waits on the stack, and the foldr (+) 0 [2,3] gets evaluated
14:30:45 <pjdelport> zorg24: Array is strict in its indexes, so you can't easily have it "grow" dynamically.
14:30:56 <pjdelport> (Aside from reallocating it)
14:31:01 <zorg24> I suppose you could use a HashMap seeing as I can't think oh a way to predict the bounds due to that
14:31:19 <Forgetaboutit> Cale: I see
14:31:28 <zorg24> or just make the array huge....
14:31:35 <pjdelport> zorg24: The thing is that a HashMap adds a *great* deal of overhead compared to an array. You'd probably get more efficiency just by using a comparatively bigger array.
14:31:51 <rwbarton> the key to this problem is to not get so hung up on the idea of memoization
14:31:55 <pjdelport> zorg24: HashMap makes more sense if your keys are sparse, but for Collatz they'll be pretty dense.
14:31:58 <Cale> and of course, it evaluates to 2 + foldr (+) 0 [3], and then *that* (+) is evaluated and it needs to match on its second argument, so another stack entry is used, and so on
14:32:37 <pjdelport> zorg24: For a dense, contiguous range, you can't really beat Array's efficiency.
14:32:38 <zorg24> yeah I suspect going somewhere between like 3 - 6 times the max would cover most of them
14:33:10 <pjdelport> zorg24: Do you have a specific range you care about? Or just as big as feasible?
14:34:04 <zorg24> well technically I only care about up 999999 for the Porject Euler, but I'd feel kind of cheaty if it didn't scale past that
14:34:27 <zorg24> I still think you have an issue in that actually making that array doesn't use the memoization, so it doesn't feel like you'd save much time
14:35:08 <pjdelport> zorg24: If you define the array circularly, it does memoize.
14:36:26 <zorg24> right but the issue is you're inly memoizing for when len is 0, and the majority of the calls won't have len = 0
14:37:32 <rwbarton> you can use the lookup table even when len is not 0
14:37:55 <pjdelport> zorg24: No, with a circular definition, you define the array in terms of a lookup against itself. Lazy evaluation takes care of resolving that. :)
14:38:18 <zorg24> really? that feels like magic
14:39:03 <dfeuer> Could someone explain what Oleg's general point is in http://okmij.org/ftp/Haskell/impredicativity-bites.html ?
14:39:18 <zorg24> I would you have to like, subtract len from the what gets looked up or something
14:39:36 <zorg24> err add
14:39:39 <quchen> Is there a way to see why Hackage won't generate my docs? Access to the Haddock logs, for example?
14:39:44 <TheKing444> > error "add"
14:39:46 <lambdabot>  *Exception: add
14:40:52 <matematikaadit> how do you call this operator (<|>)?
14:41:02 <TheKing444> ah
14:41:33 <donri> alternate? :)
14:41:34 <c_wraith> matematikaadit: informally, I call it "or"
14:41:41 <Cale> matematikaadit: From which library? In parsec, that's disjunction/alternation of parsers, which you'd probably read as "or"
14:42:30 <matematikaadit> the one in Alternative
14:42:36 <jle`> or
14:42:39 <jle`> or mplus
14:42:43 <jle`> ...i guess, aplus
14:42:45 <inf-groupoid> Is there any type that is both an instance of Alternative and Monoid, and for which (<|>) is not the same as mappend?
14:42:47 <dfeuer> Also, what *is* the current state of ImpredicativeTypes in GHC, and what does its future look like?
14:42:54 <jle`> inf-groupoid: Maybe
14:43:02 <inf-groupoid> Oh.
14:43:08 <jle`> > Just "hello" <|> Just "world"
14:43:10 <lambdabot>  Just "hello"
14:43:13 <jle`> > Just "hello" <> Just "world"
14:43:14 <lambdabot>  Just "helloworld"
14:43:24 <Cale> Yeah, it's intended to be used with parsing libraries for the same thing, so "or", typically.
14:43:24 <quchen> There is no type that's both an instance of Alternative and Monoid.
14:43:38 <inf-groupoid> quchen: Ah, right.
14:43:38 <inf-groupoid>  
14:43:40 <zorg24> pjdelport: I'm guess I want this immutable IArray right?
14:43:47 <inf-groupoid> Alternative is for type constructors.
14:43:52 <quchen> Exactly.
14:44:12 <quchen> But you're right, often times they seem to act similar.
14:45:17 <TheKing444> There is no "type" that is an instance of Alternative.
14:45:25 <jle`> Alternative for Maybe acts like the Monoid instance of First a
14:45:41 <donri> the monoid instance for maybe acts like complete utter insanity
14:46:00 <jle`> it's supposed to be a...semigroup promoter
14:46:23 <c_wraith> conal: ping! I'm getting <<loop>> spit out when using the Int instance for HasTrie (from Data.MemoTrie) in GHC 7.8
14:46:26 <jle`> promote any semigroup to a monoid
14:46:27 <donri> well the Option monoid is completely sensible :)
14:46:46 <c_wraith> conal: and if I switch to Integer, it works correctly.
14:46:50 <jle`> i see you point :)
14:47:06 <conal> c_wraith: hm. looking at the source.
14:47:08 <inf-groupoid> I was originally under the impression that "Alternative f" was a "template monoid" of sorts that had to be consistent with "Monoid (f a)".
14:47:22 <donri> the maybe monoid kinda-sorta has two identity elements, but not really, but kinda-sorta, maybe.
14:47:25 <donri> crazy.
14:47:37 <jle`> inf-groupoid: nah, it has different semantics
14:47:44 <TheKing444> Just 4 <> Nothing
14:47:49 <TheKing444> > Just 4 <> Nothing
14:47:51 <lambdabot>  No instance for (GHC.Show.Show a0)
14:47:51 <lambdabot>    arising from a use of ‚ÄòM656978972009649297422857.show_M6569789720096492974...
14:47:51 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
14:47:51 <lambdabot>  Note: there are several potential instances:
14:47:51 <lambdabot>    instance [safe] GHC.Show.Show
14:48:14 <meretrix> How can I make mapM evaluate each thunk before creating a new one?  Each iteration should return a single value, but it's clearly creating all of the thunks at once and then evaluating them, which uses a ton of memory.
14:48:19 <zorg24> pjdelport: I'm very new Haskell, If you don't mind, I think at this point I'd benefit the most from seeing an implementaion, since is my first time memoizing a function
14:48:29 <pjdelport> zorg24: Yep, one sec. :)
14:48:34 <TheKing444> :t mapM'
14:48:35 <lambdabot>     Not in scope: ‚ÄòmapM'‚Äô
14:48:35 <lambdabot>     Perhaps you meant one of these:
14:48:35 <lambdabot>       ‚ÄòmapM‚Äô (imported from Control.Monad.Writer),
14:48:42 <TheKing444> bummer
14:48:55 <benzrf> :t mapM_
14:48:56 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:48:58 <benzrf> oh you mean strict
14:49:07 <meretrix> Yeah
14:49:16 <benzrf> :t sequence_
14:49:17 <lambdabot> Monad m => [m a] -> m ()
14:49:19 <kazagistar> > mempty :: Maybe Int
14:49:21 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
14:49:21 <lambdabot>    arising from a use of ‚ÄòData.Monoid.mempty‚Äô
14:49:23 <benzrf> hmm
14:49:29 <meretrix> I tested by using mapM_ and just printing each result, which forces evaluation, and then it uses very little memory.
14:49:41 <kazagistar> oh, right
14:49:47 <TheKing444> you could roll your own
14:49:51 <TheKing444> :t mapM
14:49:52 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:50:03 <inf-groupoid> Is there any way to look for specific instances using hoogle?
14:50:07 <kazagistar> > mempty :: Maybe []
14:50:08 <lambdabot>  Expecting one more argument to ‚Äò[]‚Äô
14:50:08 <lambdabot>  The first argument of ‚ÄòData.Maybe.Maybe‚Äô should have kind ‚Äò*‚Äô,
14:50:08 <lambdabot>    but ‚Äò[]‚Äô has kind ‚Äò* -> *‚Äô
14:50:19 <TheKing444> @hoogle (a -> m b) -> [a] -> m [b]
14:50:19 <dwcook> I forget, was it just sequence and mapM or was it also sequence_ and mapM_ that were considered to have undesirable properties?
14:50:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:50:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:50:20 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:50:25 <kazagistar> > mempty :: Maybe [Int]
14:50:26 <lambdabot>  Nothing
14:50:38 <TheKing444> > mempty :: Maybe a
14:50:40 <lambdabot>  No instance for (Data.Monoid.Monoid a1)
14:50:40 <lambdabot>    arising from a use of ‚ÄòData.Monoid.mempty‚Äô
14:50:40 <lambdabot>  Possible fix:
14:50:40 <lambdabot>    add (Data.Monoid.Monoid a1) to the context of
14:50:40 <lambdabot>      an expression type signature: Data.Maybe.Maybe a1
14:50:57 <TheKing444> :t sequenceM
14:50:58 <lambdabot>     Not in scope: ‚ÄòsequenceM‚Äô
14:50:58 <lambdabot>     Perhaps you meant one of these:
14:50:58 <lambdabot>       ‚Äòsequence‚Äô (imported from Control.Monad.Writer),
14:51:00 <kazagistar> ugh yeah, that is a bit awkward
14:51:03 <TheKing444> :t sequence
14:51:04 <lambdabot> Monad m => [m a] -> m [a]
14:51:12 <TheKing444> sequence []=[]
14:51:13 <wabash> Hi, folks. Can someone give me a one liner about haskell's interoperability with optimized BLASs?  Such as CudaBLAS and Atlas?
14:51:20 <rwbarton> dfeuer: I don't know what Oleg thinks the point is but as I see it it's not very relevant to Haskell, which has value-level recursion already
14:51:25 <conal> c_wraith: hm. i don't recall whether i've used the Int instance. looks fishy in its conversion to & from words.
14:51:29 <c_wraith> conal: http://lpaste.net/107213 ghc 7.8
14:51:39 <c_wraith> err, 7.8.2, precisely
14:51:43 <donri> > Nothing <> Just "" <> Just "two identities!"
14:51:44 <lambdabot>  Just "two identities!"
14:51:46 <jchee> dwcook: sequence and mapM have bad memory behavior
14:51:48 <TheKing444> sequence (x:xs)=x `seq` xs `seq` (:) `fmap` x `ap` xs
14:51:50 <c_wraith> conal: oh, well.  In that case.  :)
14:51:51 <rwbarton> dfeuer: but it shows how easily general recursion can slip in unintended
14:52:04 <dwcook> jchee, not to mention they don't stream
14:52:04 <kazagistar> it requires a Monad, but then does not use that monad instance to generate the mempty for Maybe
14:52:52 <conal> c_wraith: I see that Luke covers these types in data-memocombinators.
14:52:54 <jchee> dwcook: right, foldM might be a step in the right direction, but an iteratee-like solution might be necessary
14:53:11 <c_wraith> conal: but your library is cooler. (when it works)
14:53:18 <TheKing444> I think the problem is that monads are sequential.
14:53:35 <dwcook> jchee, yeah, I'm familiar with pipes for example, I was just trying to remember if there was something wrong with sequence_ and mapM_ as well.
14:53:43 <c_wraith> monads aren't sequential.  Kliesli composition is sequential.  Wait, those are the same thing.
14:54:09 <conal> c_wraith: i could probably steal the underlying implementation from Luke.
14:54:29 <TheKing444> @src mapM
14:54:29 <lambdabot> mapM f as = sequence (map f as)
14:54:37 <TheKing444> :t map'
14:54:38 <lambdabot>     Not in scope: ‚Äòmap'‚Äô
14:54:38 <lambdabot>     Perhaps you meant one of these:
14:54:39 <lambdabot>       ‚ÄòmapM‚Äô (imported from Control.Monad.Writer),
14:54:44 <TheKing444> bummer
14:54:44 <quchen> c_wraith: Reverse State Monad anyone?
14:54:45 <jchee> dwcook: I don't think so, since they just need to evaluate the computation/side-effect and then move on, I believe they are implemented or get optimized to a constant-stack iteration
14:54:51 <TheKing444> what is the strict map again?
14:55:14 <c_wraith> There isn't one, iirc.
14:55:23 <c_wraith> Unless you count like parmap whnf
14:55:23 <conal> c_wraith: or more directly from data-inttrie
14:55:30 <TheKing444> :t parmap
14:55:31 <lambdabot>     Not in scope: ‚Äòparmap‚Äô
14:55:31 <lambdabot>     Perhaps you meant one of these:
14:55:31 <lambdabot>       ‚Äòrmap‚Äô (imported from Control.Lens),
14:55:36 <TheKing444> :rmap
14:55:38 <TheKing444> :t rmap
14:55:40 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
14:55:49 <TheKing444> Oh, so profunctors solve the problem. Okay
14:55:59 <quchen> c_wraith: There will be a new operator (<$!>) in the next release that's a strict fmap
14:56:03 <c_wraith> profunctors are entirely unrelated.  rmap goes with lmap.  :)
14:56:03 <jchee> :t parMap
14:56:04 <wabash> anybody?
14:56:04 <lambdabot>     Not in scope: ‚ÄòparMap‚Äô
14:56:05 <lambdabot>     Perhaps you meant ‚Äòpara‚Äô (imported from Control.Lens)
14:56:20 <dwcook> TheKing444, profunctors don't really have to do with your question
14:56:21 <TheKing444> :t para
14:56:22 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
14:56:32 <TheKing444> Okay, how about Plated?
14:56:42 <c_wraith> para looks a lot like foldr
14:56:46 <quchen> f <$!> mx = do { x <- mx; return $! f x }
14:56:59 <TheKing444> map' [] = []
14:57:01 <zorg24> pjdelport: wow I just tried curious how long it would take memoized, and in ghci I ran out of memory
14:57:04 <c_wraith> quchen: so it needs Monad instead of Functor?
14:57:09 <quchen> c_wraith: Yes
14:57:09 <TheKing444> map' f = []
14:57:17 <TheKing444> map' f [] = [] there we go
14:57:27 <pjdelport> zorg24: How are you memoizing it?
14:57:41 <zorg24> pjdelport: that was unmemoized
14:57:46 <TheKing444> map' f (x:xs) = let z = fx in z `seq` z:(map' f xs)
14:58:13 <TheKing444> mapM' f xs = sequence (map' f xs)
14:58:16 <TheKing444> problem solved
14:58:20 <TheKing444> mapM' is strict
14:59:14 <benzrf> :t map'
14:59:15 <lambdabot>     Not in scope: ‚Äòmap'‚Äô
14:59:15 <lambdabot>     Perhaps you meant one of these:
14:59:15 <lambdabot>       ‚ÄòmapM‚Äô (imported from Control.Monad.Writer),
14:59:27 <zorg24> One other little question how do I use maximum on an array of tuples where I want to find the max based on fst
14:59:29 <TheKing444> map' f [] = []
14:59:47 <TheKing444> map' f (x:xs) = let fx = f x in fx `seq` fx : (map' f xs)
15:00:14 <quchen> "fx `seq` fx" is identical to "fx".
15:00:37 <dfeuer> Presumably   fx `seq` (fx : map' f xs)    is not.
15:00:37 <TheKing444> what binds tighter, : or `seq`?
15:00:50 <dfeuer> Dunno, TheKing444
15:01:14 <jchee> seq is only whnf also, you may need to rely on deepseq
15:01:20 <TheKing444> > tail $ let z = undefined in z `seq` z : []
15:01:21 <zorg24> never mind I found it
15:01:21 <lambdabot>  *Exception: Prelude.undefined
15:01:42 <TheKing444> I think : binds tighter.
15:02:05 <TheKing444> > tail $ let z = undefined in (z `seq` z) : []
15:02:08 <lambdabot>  []
15:02:10 <TheKing444> yep
15:02:19 <dfeuer> @pointless a `seq` b : c
15:02:19 <lambdabot> a `seq` b : c
15:02:27 <dfeuer> Meh.
15:02:42 <TheKing444> @pointless \a b c -> a `seq` b : c
15:02:42 <lambdabot> ((:) .) . seq
15:03:09 <quchen> seq is infixr 0
15:03:16 <TheKing444> nice
15:03:17 <quchen> (:) is r 5
15:03:29 <TheKing444> :infix :
15:03:36 <TheKing444> @infix :
15:03:36 <lambdabot> bzzt
15:10:23 <TheKing444> @help infix
15:10:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:10:30 <TheKing444> @list infix
15:10:30 <lambdabot> No module "infix" loaded
15:12:10 <icecrime> hi! I'm trying to understand the reason of my dramatic performance on this code, if anyone wants to give a hand! http://stackoverflow.com/questions/24664515/abnormally-slow-haskell-code
15:12:32 <jle`> icecrime: it looks like you are using list or string
15:12:50 <TheKing444> I'll take a look too.
15:13:20 <TheKing444> It should also be on code review, not stack overflow.
15:13:57 <jle`> stack overflow might be ok for asking questions about code that doesn't work for all practical purposes
15:14:24 <jle`> icecrime: try using something besides List and String, you might get some boosts there
15:14:28 <jfischoff> Are there any haskell libraries out there for making DMA requests to network cards?
15:14:29 <icecrime> I'll remove the last sentence which indeed sounds like I'm asking for code review
15:14:33 <TheKing444> I hear the sqrt's are expensive.
15:14:47 <TheKing444> (Not sure why, they are O(1). How much better can ya get.)
15:14:57 <benedikt> I'm getting type errors that I dont understand when i try compling this: http://lpaste.net/107216
15:15:14 <jle`> benedikt: what errors?
15:15:26 <icecrime> jle`: do you have any alternative to recommend?
15:15:36 <benedikt> jle`:     Couldn't match type `Digest HashedPassword' with `HashedPassword'
15:15:45 <jle`> icecrime: text for text
15:16:42 <jle`> benedikt: what line?
15:16:49 <jle`> can you put up the entire message?
15:16:56 <TheKing444> you did -O2 when you complied, right?
15:17:03 <TheKing444> ghc -O2 whatever.hs
15:17:09 <icecrime> TheKing444: I didn't
15:17:21 <TheKing444> oh, well you got to do that
15:17:29 <TheKing444> ghc -O2 yourfilename.hs
15:17:47 <TheKing444> it will make ghc shuffle your code around til it goes real fast
15:17:50 <TheKing444> without breaking anything
15:17:53 <benedikt> jle`: sure
15:18:02 <TheKing444> (If you want to break things, just go to -O3 or higher)
15:18:39 <icecrime> it doesn't seem much better :(
15:18:46 <TheKing444> oh
15:18:53 <TheKing444> well, keep it on -O2 just in case
15:19:14 <TheKing444> https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/profiling.html
15:19:20 <benedikt> jle`: http://lpaste.net/3206021541175230464 # error
15:19:24 <TheKing444> this teaches ya how to find what is messin with it
15:20:22 <TheKing444> if you have multi core, parallezing it might be a good idea too
15:20:26 <TheKing444> its real easy in haskell
15:22:14 <TheKing444> https://hackage.haskell.org/package/stream-fusion
15:22:39 <TheKing444> icecrime: that is more effcient list stuff
15:23:02 <icecrime> alright I'll take a look
15:23:03 <icecrime> thanks
15:23:13 <TheKing444> try the profilling
15:23:20 <TheKing444> I bet identify takes most of the time.
15:23:31 <silasm> TheKing444: I'd say it's relatively easy. It still introduces its own set of complications. Getting a correct program that runs in parallel is relatively easy, setting it up so you get a big benefit from it often isn't.
15:23:34 <TheKing444> wait, never mind
15:24:40 <silasm> e.g. depending on the framework you're using you might end up actually doing all your evaluations in serial because of lazy evaluation.
15:24:58 <TheKing444> he is doing list stuff
15:25:04 <TheKing444> A good parMap could go a long way.
15:25:08 <silasm> he should be relatively fine then, yeah
15:25:25 <silasm> I think the main time I had trouble was trying to merge-sort trees.
15:25:37 <silasm> I still need to go back to that.
15:25:37 <rwbarton> > 784*500*5000
15:25:39 <lambdabot>  1960000000
15:25:50 <TheKing444> > "It's over 9000!!!!!!!!"
15:25:51 <lambdabot>  "It's over 9000!!!!!!!!"
15:27:07 <rwbarton> it took 80 seconds here
15:27:10 <Clint> corgifex: ping
15:27:44 <rwbarton> and you are doing something like 2 billion "fromIntegral $ (a - b) * (a - b)"s
15:29:10 <icecrime> tbh it's one of my first Haskell codes, I just did a very similar naive implementation in F# earlier and performances are about 10x worse, so I was hoping I was missing something obvious
15:29:31 <icecrime> but thanks for the suggestions, I'll be trying these out
15:29:32 <rwbarton> what data structure did you use to store the "Pixels" in F#?
15:29:40 <icecrime> int[]
15:29:52 <icecrime> so perhaps something more like a Data.Vector?
15:29:52 <rwbarton> is that an array?
15:29:56 <silasm> icecrime: after a quick glance my guess would be your bottleneck is that you're using string's readFile. You might benefit from switching to ByteStrings.
15:29:59 <rwbarton> or an Array
15:30:17 <TheKing444> could wee see your csv file?
15:30:20 <rwbarton> preferably an unboxed array
15:30:29 <rwbarton> if you run it it's pretty clear that most of the time is not spent parsing
15:30:30 <icecrime> TheKing444: https://github.com/c4fsharp/Dojo-Digits-Recognizer/tree/master/Dojo
15:30:32 <codygman> I have a list of WebDriver actions that error with throwIO from lifted-base. Couldn't I use runResourceT or something to run each of these actions exiting on any failure and printing the error message?
15:30:34 <codygman> http://lpaste.net/107218
15:30:53 <jdabinett> hey there, is there an applicable resource for someone who doesn't know programming to learn haskell?
15:31:06 <TheKing444> gtg, but try the profilling
15:31:19 <rwbarton> though if 'identify' was 10x faster then the parsing might become a substantial portion of the time spent
15:32:24 <dfeuer> TheKing444, the sqrts are expensive because they are, or at least appear to be, completely unnecessary.
15:33:41 <rwbarton> even getting rid of the sqrts and the fromIntegral made no difference
15:34:04 <silasm> dfeuer: there's that, but he converted this from a F# implementation which probably had the same thing.
15:35:05 <rwbarton> it must be limited by memory latency traversing all these linked lists
15:36:14 <rwbarton> (5000 linked lists of length 784)
15:39:01 <dfeuer> rwbarton, you mean making distance::Pixels->Pixels->Int and identify::Digit->[Digit] ->(Digit,Int)?
15:39:51 <rwbarton> right
15:44:35 <dfeuer> I would say that the training sample is indeed likely a problem. Making it a Vector (or even an unboxed vector) and reading it in with non-lazy IO would probably help.
15:44:54 <chrisdotcode> what does "<-" desugar to in do statements?
15:45:22 <chrisdotcode> "do { x <- getFromIO "foo"} => ???
15:45:32 <rwbarton> @undo do { x <- getFromIO "foo"; f x }
15:45:33 <lambdabot> getFromIO "foo" >>= \ x -> f x
15:45:44 <chrisdotcode> oh, sweet
15:46:01 <chrisdotcode> @undo do { x <- getFromIO "foo"; return x}
15:46:01 <lambdabot> getFromIO "foo" >>= \ x -> return x
15:46:06 <chrisdotcode> thanks, rwbarton
15:46:26 <chrisdotcode> @undo do { x <- getFromIO "foo"; otherAction; f x}
15:46:27 <lambdabot> getFromIO "foo" >>= \ x -> otherAction >> f x
15:47:35 <phaazon> https://hackage.haskell.org/package/happstack-clientsession-7.2.7/docs/Happstack-Server-ClientSession.html
15:47:43 <dfeuer> Kinda sorta.
15:47:51 <phaazon> why does ClientSession even exist?
15:48:02 <phaazon> it sounds exactly to be Default
15:48:09 <dfeuer> Because if x  is a pattern, things are a little more complicated.
15:48:45 <chrisdotcode> @undo do { x <- getFromIO "foo"; otherAction; y <- getFromIO "bar"; f x}
15:48:46 <lambdabot> getFromIO "foo" >>= \ x -> otherAction >> getFromIO "bar" >>= \ y -> f x
15:49:12 <chrisdotcode> and one more
15:49:14 <chrisdotcode> @undo do { x <- getFromIO "foo"; otherAction; y <- getFromIO "bar"; qux y; f x}
15:49:14 <lambdabot> getFromIO "foo" >>= \ x -> otherAction >> getFromIO "bar" >>= \ y -> qux y >> f x
15:49:18 <rwbarton> chrisdotcode: BTW, you can PM lambdabot too (/msg lambdabot)
15:49:25 <chrisdotcode> that helps :)
15:51:39 <rwbarton> dfeuer: hmm, I wonder whether @undo knows about that
15:51:43 <rwbarton> @undo do { Just x <- getFromIO "foo"; f x }
15:51:44 <lambdabot> getFromIO "foo" >>= \ a -> case a of { Just x -> f x; _ -> fail ""}
15:51:48 <rwbarton> nifty
15:55:53 <Mysterious_Light> why undo converts it to case expression, not just to getFromIO "foo" >>= \ (Just x) -> f x ?
15:56:03 <jle`> Mysterious_Light: because of fail
15:56:10 <jle`> :t fail
15:56:11 <lambdabot> Monad m => String -> m a
15:56:18 <jle`> fail can be defined on a per-monad basis
15:56:29 <jle`> and is called during a pattern match failure in a do block
15:56:41 <jle`> your lambda version will throw a pattern match error
15:57:04 <jle`> but if someone defined the Monad instance of Maybe such that fail _ = Nothing, then it wo'nt error; it'll just resolve the whole block to Nothing
15:58:19 <jle`> actually i think Maybe is actually defined that way >_>
15:58:31 <Algebr> Ocaml seems to be veryyy similar to haskell, or would it be more accurate to say that haskell is very similar to ocaml.
15:58:32 <silasm> jle`: yeah, he's just not using Maybe as his monad there.
15:58:55 <jle`> silasm: in any case, fail is almost always different from a simple pattern match error
15:59:00 <jle`> in terms of the error message
15:59:36 <jle`> Algebr: some of the syntax is similar, and type inference and stuff, but the underlying semantics and things are different; and the deeper you look, the more different they become
15:59:50 <dfeuer> Algebr, you've got your history backwards.
16:00:13 <Algebr> dfeuer: so ocaml, then haskell?
16:00:13 <jle`> many of the things that make Haskell as good or useful as it is cannot be reproduced in ocaml semantcs
16:00:29 <dfeuer> No, Algebr, Haskell, then OCaml.
16:00:35 <Algebr> jle`: yes, just found out there are no type classes in ocaml
16:00:41 <Mysterious_Light> jle`: interesting. It's a first time when fail operator is used. I used to consider this operator as bad-design inheritance.
16:00:48 <Algebr> dfeuer: ah, thank you.
16:00:50 <jle`> Mysterious_Light: well, you're still right :P
16:01:08 <jle`> i'm not saying that it's a good thing; that's just the reason behind the desugaring
16:01:23 <Mysterious_Light> i see
16:01:26 <Mysterious_Light> thx
16:01:42 <jle`> originally I believe there was a separate Monad and MonadFail typeclass; fail lived in there
16:02:09 <jle`> then if you wanted to write any do blocks with pattern matching, you'd need (MonadFail m) =>
16:02:14 <jle`> (if you wanted it to be generic)
16:02:32 <jle`> but then you'd also have to instance every Monad as MonadFail
16:02:43 <jle`> or else you can't ever use pattern matching in it
16:02:49 <jle`> (the way the spec defines pattern matching in do blocks)
16:04:16 <jle`> there are some useful abuses of fail though :)
16:04:48 <jle`> > do { Just x <- [Nothing, Just 5, Just 2, Nothing]; return (show x) }
16:04:50 <lambdabot>  ["5","2"]
16:05:27 <jle`> 2
16:05:29 <jle`> 1
16:05:48 <jle`> er sorry, wrong window
16:06:12 <silasm> by the way, is there a reason list comprehensions aren't generalized to other monads like in idris?
16:06:23 <glguy> They are if you turn on that extension
16:06:25 <geekosaur> there's an extension
16:06:37 <silasm> that was going to be my second question :)
16:06:38 <geekosaur> withput it, well, the haskell committee likes to make conservative language decisions
16:06:39 <glguy> "MonadComprehensions"
16:06:48 <silasm> makes sense.
16:07:10 <dfeuer> silasm, I seem to recall that they were originally monad comprehensions.
16:07:45 <geekosaur> one of many things that got lobotomized because they were afraid newcomers would be terrified of the type errors
16:08:36 <shlevy> If I have a socket protocol that represents integers as 32-bits, little-endian, what's the best way to construct the relevant ByteStrings to send over the Socket from Ints?
16:08:57 <dfeuer> Yes, https://ghc.haskell.org/trac/ghc/ticket/4370 indicates that was the case.
16:09:45 <jfischoff> shlevy: with Blaze Builder
16:10:13 <meretrix> If I change the last line of my (IO String) function from "print s >> return s" to "return $! s", shouldn't it be just as strict?
16:10:28 <meretrix> The change causes memory usage to go from 1% to 90%..
16:10:43 <geekosaur> $! only evaluates to the first constructor
16:10:45 <dfeuer> No.
16:10:47 <jfischoff> shlevy: http://hackage.haskell.org/package/bytestring-0.10.2.0/docs/Data-ByteString-Builder.html#v:int32LE
16:10:49 <geekosaur> print evaulates the whole thing
16:10:58 <shlevy> jfischoff: Ah perfect, thanks
16:11:09 <meretrix> Ah. How can I emulate it's behavior?
16:11:16 <dfeuer> deepSeq
16:11:25 <meretrix> Thanks
16:11:31 <jfischoff> shlevy: and then use hPutBuilder to put it on the socket. I think that is the fastest
16:11:45 <jfischoff> shlevy: http://hackage.haskell.org/package/bytestring-0.10.2.0/docs/Data-ByteString-Builder.html#v:hPutBuilder
16:11:58 <rwbarton> or use a strict Text perhaps
16:12:36 <haasn> jfischoff: What about binary or cereal?
16:12:44 <jfischoff> shlevy: and this will also be helpful: https://hackage.haskell.org/package/network-2.5.0.0/docs/Network-Socket.html#v:socketToHandle
16:12:45 <pavonia> Is there a way to make GHCi release memory to the OS?
16:12:50 <jfischoff> haasn: sure
16:12:57 <shlevy> jfischoff: Can't convert my socket to a handle, need to be able to send fds over it
16:13:04 <jfischoff> ah
16:13:07 <benedikt> Compiling this gives me  http://lpaste.net/107216 this error http://lpaste.net/3206021541175230464 and i'm pretty new to haskell and just have a gut feeling of what is wrong
16:13:52 <pjdelport> zorg24: Still there?
16:13:52 <haasn> Oh, that requires it to be a Word32 or whatever, though
16:13:58 <pjdelport> zorg24:  http://lpaste.net/107220
16:14:06 <zorg24> pjdelport: awesome thanks
16:14:11 <haasn> (But you can go from Int to Word32 a bit easily, not guaranteed to be a round trip or work in reverse order though)
16:16:01 <shlevy> jfischoff: Should I use Network.Socket.ByteString.Lazy?
16:16:11 <shlevy> jfischoff: Or somehow get strict bytestrings out of the builder?
16:16:36 <pjdelport> zorg24: That's not the prettiest code, but the idea is that collatzDists and collatzDist are defined in terms of each other, with collatzDist using the array for values in its limit, and falling back to direct iteration for values over the memoizing limit.
16:16:40 <zorg24> pjdelport:  I'm confused as to what's going on at line 21
16:17:04 <jfischoff> shlevy: I don‚Äôt know. My guess would be lazy would be better, but I‚Äôve never profiled them against each other
16:17:05 <pjdelport> zorg24: You can adjust the memo size independently of the input to collatzDist
16:17:23 <shlevy> jfischoff: OK, thanks
16:17:40 <pjdelport> zorg24: The "!" ? That's array indexing.
16:17:41 <jfischoff> shlevy: Ideally you want the builder to write directly to the socket, but I don‚Äôt know if there is an easy way to do that
16:17:45 <dfeuer> shlevy, why don't you look at binary and cereal?
16:17:53 <zorg24> no why is there i'
16:18:03 <shlevy> dfeuer: OK, will take a look...
16:18:11 <pjdelport> zorg24: That's defined in the where block: i' = collatz i
16:18:26 <zorg24> oh gotcha
16:18:27 <pjdelport> It's just the next Collatz iteration of i.
16:19:18 <shlevy> dfeuer: Any idea off the top of your head if either of them have efficient methods of writing to a socket?
16:19:33 <dfeuer> No clue.
16:19:34 <zorg24> pjdelport: thanks that helped a ton!
16:19:48 <pjdelport> zorg24: Experimentally, the sweet spot seems to be when the array size equals the maximum bound that you check.
16:20:38 <zorg24> interesting, I'd guess its b/c the overflow is unlikely to be called more than once
16:21:10 <pjdelport> zorg24: When you make the memo bigger than the range you check, for example limit = 999999 * 10 (while only checking up to 999999), then it becomes slower, probably because of allocating a lot of unused thunks, yeah.
16:21:50 <pjdelport> zorg24: Likewise, when you make the memo smaller than the range to be checked, it becomes a lot slower too (as expected)
16:22:17 <zorg24> cool
16:22:32 <augur> hrmph
16:22:50 <augur> i wish i could make a heterogeneous map type :(
16:22:52 <pjdelport> zorg24: Oh, with this kind of problem, you have to aware of Int overflow, by the way.
16:23:01 <zorg24> ya
16:23:05 <lyxia> benedikt: Lines 46 and 48, http://lpaste.net/107216 (just fixing well-typedness, no idea about the logic, there may still be errors)
16:23:13 <zorg24> that just happened when I tried to compile it...
16:23:24 <dfeuer> shlevy, you'll probably not be using the Binary or Serialize classes; just the parts behind them.
16:24:32 <zorg24> pjdelport: I got a stackoverflow when I tried to run it
16:24:33 <pjdelport> zorg24: In this case, using Int for the keys is fine, because we constrain the starting points to 999999, and it's unlikely to grow near maxBound :: Int, but even so, it would be better to have a safety check in the collatz function to bail out if an odd number grows to maxBound `div` 3, for example.
16:24:42 <pjdelport> zorg24: Are you compiling with -O2 ?
16:24:53 <pjdelport> zorg24: stack overflow is a different thing to Int overflow.
16:25:03 <zorg24> no that was w/o, got a different error with -O2
16:25:18 <zorg24> ya I know, that's the recursion depth
16:25:59 <pjdelport> zorg24: I kept the result type Integer, as i had it originally, but Int will probably do there fine, too. (Int vs. Integer didn't seem to make much of a difference to speed, in this case.)
16:26:12 <pjdelport> zorg24: That's strange; it works fine here.
16:26:31 <zorg24> pjdelport: with -O2 I got euler14.exe: Ix{Int}.index: Index (-1812855948) out of range ((1,999999))
16:27:15 <pjdelport> Oh, bugger, that's Int overflow, yeah.
16:27:18 <zorg24> pjdelport: oh you know what I know I'm on an old ghc (I'd messed with haskell a while back, but forgot to update) could be it
16:27:24 <pjdelport> 32-bit machine?
16:27:36 <pjdelport> I'm 64-bit, that's probably why I don't get it.
16:27:38 <zorg24> pjdelport: nope 64, I'm on windows though...
16:27:47 <pjdelport> 32-bit GHC build?
16:27:58 <zorg24> pjdelport:hmm let me check
16:28:20 <zorg24> yep that was it
16:28:33 <pjdelport> zorg24: Just change the types to collatzDists :: Array Integer Integer and collatzDist :: Integer -> Integer
16:28:45 <zorg24> weird I can't imagine why I wouldn't have gotten the 64 bit
16:28:45 <pjdelport> Should work fine then.
16:28:58 <pjdelport> (It doesn't seem to affect performance too much.)
16:29:04 <zorg24> pjdelport: wait how'd that effect a stack overflow?
16:29:16 <zq__> :T typeOf
16:29:21 <zq__> :t typeOf
16:29:22 <pjdelport> zorg24: That won't affect a stack overflow, but it will prevent the index out of range error.
16:29:22 <lambdabot> Typeable a => a -> TypeRep
16:29:30 <zorg24> pjdelport: oh gotcha
16:30:09 <benedikt> lyxia: it just gave me another error instead. But why did you use `let` only with passwd and not hash_ ?
16:30:39 <pjdelport> zorg24: What's happening with that error is that some 3*n + 1 overflowed Int and wrapped into the negative.
16:30:48 <zorg24> oh
16:31:54 <meretrix> Why does "s `deepseq` return s" fix space leaks, but not "return $ s `deepseq` s"?
16:32:11 <zorg24> pjdelport: holy moly, I knew memoization would speed it up, but that was crazy fast
16:32:17 <lyxia> benedikt: getPassword doesn't return a monadic value, so you don't use a monadic binding but just a let-binding to use that value.
16:32:23 <pjdelport> zorg24: What I mentioned with checking that i < (maxBound :: Int) `div` 3 before calculating i' = collatz i would have caught that error. :)
16:33:06 <pjdelport> zorg24: But the lesson should rather be "Just use Integer, unless you know it's a bottleneck and can code safely for Int"
16:33:25 <benedikt> lyxia: i think i understand
16:33:39 <zorg24> pjdelport: yeah I thought Integer would actually be noticeably slower, but I guess nit
16:33:55 <silasm> one might also point out the benefits of using Int32 or Int64 vs. using Int here...
16:34:01 <pjdelport> It depends a bit on what operations you do, but usually it's not so much slower.
16:34:30 <zorg24> pjdelport: plus I've heard that its not uncommon project euler problems to overflow an Int64...
16:34:49 <pjdelport> zorg24: Yep.
16:35:22 <pjdelport> It's sort of antithetical to Haskell to use a silently-overflowing Int type
16:35:25 <zorg24> out of curiousity does Integer use GMP?
16:35:56 <pjdelport> That's something that still bugs me, coming from Python (which has a dual int / long type that automatically switches representation)
16:36:12 <augur> hrmph
16:36:23 <silasm> pjdelport: I think automatically switching representation has evils in itself, though.
16:36:51 <zorg24> because to be GMP is so optimized that I wouldn't be surprised if it does silent overflowing behind the scenes....
16:37:08 <pjdelport> zorg24: IIRC GHC uses GMP by default, yes, although there is a pure Haskell version too.
16:37:17 <zorg24> oh cool
16:37:33 <dfeuer> Is there a way to ask GHC or GHCi for types of locally defined things?  Like  f x = let g x = blah in bloop   what is the type of g?
16:37:45 <pjdelport> silasm: I'd take whatever those evils are over silent overflows any day :)
16:37:48 <benzrf> dfeuer: you can use type hoels
16:37:54 <dfeuer> hoels?
16:38:20 <geekosaur> that was a typo. TypeHoles extension
16:38:25 <pjdelport> If you could tell Haskell to crash early when Int overflows / underflows, that would already be an improvement for me.
16:38:40 <geekosaur> there's also implicit parameters, which are a neat hack you can use to get types out of ghci or lambdabot
16:38:50 <dfeuer> Ah.
16:38:58 <TheKing444> : typeOf
16:39:01 <TheKing444> :t typeOf
16:39:02 <lambdabot> Typeable a => a -> TypeRep
16:39:30 <TheKing444> let g x=typeOf g in g 'a'
16:39:33 <dfeuer> Implicit parameters do this how?
16:39:39 <TheKing444> > let g x=typeOf g in g 'a'
16:39:40 <lambdabot>  Char -> TypeRep
16:39:42 <geekosaur> they show up in the type as a context
16:39:55 <TheKing444> ta da, just got type within a let block
16:39:59 <lcfrs> This is the Church encoding of Free: newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r }. Does anyone know the Church encoding of Operational?
16:40:02 <geekosaur> :t map ?f []
16:40:03 <lambdabot> (?f::a -> b) => [b]
16:42:16 <benzrf> ugh
16:44:08 <dfeuer> I don't really see how holes help me with this.
16:44:26 <TheKing444> dfeuer
16:44:31 <TheKing444> just use typeOf
16:44:32 <geekosaur> you would use _ in place of g and it would output the type
16:44:54 <geekosaur> "Found hole of type ... "
16:46:00 <dfeuer> How does typeOf help me?
16:46:02 <zorg24> pjdelport: well thanks for all the help. I gtg now, but I'll definitely be back with more questions in the future (probably more project euler stuff) :D
16:46:22 <TheKing444> > let g x = x in typeOf g
16:46:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
16:46:24 <lambdabot>    arising from a use of ‚ÄòData.Typeable.Internal.typeOf‚Äô
16:46:24 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
16:46:24 <lambdabot>  Note: there are several potential instances:
16:46:24 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:46:33 <TheKing444> > let g True = Flase in typeOf g
16:46:34 <lambdabot>  Not in scope: data constructor ‚ÄòFlase‚Äô
16:46:34 <lambdabot>  Perhaps you meant ‚ÄòFalse‚Äô (imported from Data.Bool)
16:46:42 <TheKing444> > let g True = False in typeOf g
16:46:44 <lambdabot>  Bool -> Bool
16:46:51 <TheKing444> there we go
16:47:05 <glguy> dfeuer: The holes that geekosaur mentioned will prompt GHCi to tell you the types of all the locally defined things in addition to the type of the hole
16:47:13 <dfeuer> Ah.
16:47:36 <dfeuer> But I have to wait till I've upgraded to 7.8._
16:48:02 <glguy> Yeah, you'll have to wait until this past April befor eyou can use it
16:49:17 <dfeuer> It seems that the next version of HP is waiting for 7.8.3, while 7.8.3 is waiting for --- not sure. One of the developers is on vacation; maybe that's that trouble?
16:49:22 <pjdelport> zorg24: Cool :)
16:50:01 <geekosaur> but they how have the HP sorted so they can generate RCs as soon as 7.8.3 comes out
16:50:06 <glguy> There was an email about how a new HP is imminent this morning
16:50:27 <glguy> maybe with a new release HP will become relevant again
16:50:46 <geekosaur> actualy that message was about a new way of putting HP together, so there is less of a delay on the HP end of things
16:50:53 <geekosaur> still have to wait on GHC though :/
16:51:28 <glguy> OK the status was "Good-to-go", not "imminent" :-p
16:54:35 <qwebirc85809> can anyone help me with a problem to do with a dsl http://lpaste.net/107223
16:54:39 <c_wraith> dfeuer: no reason to handcuff yourself to the platform, though.
16:55:04 <TheKing444> whatz the problem?
16:55:47 <qwebirc85809> i have a number of a number of events that are in xml. i wrote a little dsl for matching against the events but it is awkward
16:55:53 <phaazon> god
16:55:59 <benzrf> data Type = Atom | Int | Type :-> Type
16:56:00 <phaazon> is it me, or the latest cabal version is FAST
16:56:01 <benzrf> oops
16:56:12 <dfeuer> c_wraith, I suppose not, but it makes it easier to get a working base upon which to build the usual Cabal dependency hell.
16:56:31 <c_wraith> dfeuer: I have never experienced said "hell"
16:56:59 <glguy> GHC.Generics generated Lens's http://lpaste.net/107186
16:57:04 <dfeuer> c_wraith, either you know much more about using it than I do, or you're lucky, or very likely both.
16:57:16 <c_wraith> dfeuer: I have experienced conflicting dependencies, but they're nearly always easy to resolve (or the answer is that they don't have a resolution, because there's a real incompatibility)
16:57:18 <dfeuer> [as I know very little about using it]
16:58:36 <matematikaadit> geekosaur: um... what's that "map ?f [] things"?
16:58:54 <c_wraith> dfeuer: I guess the problems are kind of like bees.  If you panic at the sight of them, they attack.  If you don't worry about it, they don't bother you. :)
16:59:23 <geekosaur> ?if is an implicit parameter. I used to to get lambdabot to tell me the type of something that wasn't convenient to extract in a directly typeable way, as an example
16:59:24 <lambdabot> Maybe you meant: id bf
16:59:28 <dfeuer> c_wraith, you have to know what spells to mutter over it, and I haven't done enough research to now.
16:59:29 <dfeuer> know.
16:59:45 * geekosaur baps lambdabot
17:00:07 <c_wraith> dfeuer: well, the correct spell used to be "rm -r .ghc", but these days "cabal sandbox init" and "cabal sandbox delete" handle it more easily.
17:00:15 <solidus-river> is there a symbol for mplus
17:00:30 <c_wraith> solidus-river: often <|> is the same thing, but that's not required
17:01:04 <solidus-river> > Just 1 + Just 1
17:01:06 <lambdabot>  No instance for (GHC.Show.Show a0)
17:01:06 <lambdabot>    arising from a use of ‚ÄòM670453490608513989924861.show_M6704534906085139899...
17:01:06 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
17:01:06 <lambdabot>  Note: there are several potential instances:
17:01:06 <lambdabot>    instance [safe] GHC.Show.Show
17:01:12 <dfeuer> c_wraith, I meant to make it try harder to find a way to make things work.
17:01:39 <c_wraith> > Just 1 `mplus` Just 1 -- this isn't really any better
17:01:40 <lambdabot>  Just 1
17:02:01 <geekosaur> > let (<|>) = mplus in Just 1 <|> Just 1
17:02:04 <lambdabot>  Just 1
17:02:10 <c_wraith> did you really want something like liftM2 (+)   ?
17:02:12 <geekosaur> or pick some other symbol
17:02:24 <augur> its a real shame type classes arent first class
17:02:28 <augur> then you could do things like
17:02:44 <c_wraith> > let (<+>) = liftM2 (+) in Just 1 <+> Just 1
17:02:45 <lambdabot>  Just 2
17:02:57 <solidus-river> > liftM2 (+) (Just 1) (Just 1)
17:02:59 <lambdabot>  Just 2
17:03:09 <solidus-river> > liftM2 (+) (Just 1) (Nothing)
17:03:11 <lambdabot>  Nothing
17:03:19 <augur> instance Show X where let def = deriving Show X in show x = toLower (def.show x)
17:03:23 <jle`> i forgot how to implement arr using Applicative (r a)
17:03:27 <jle`> darnt
17:03:43 <jle`> er, Category r => Applicative (r a)
17:03:46 <jle`> oh
17:09:04 <solidus-river> jle`: workin on more of the category instances
17:09:08 <solidus-river> think i got IAuto
17:09:10 <solidus-river> http://lpaste.net/107226
17:09:30 <solidus-river> except in (i>>>) >>> should be i>>>
17:10:09 <jle`> solidus-river: congrats :)  yeah
17:10:14 <jle`> now you can sort of see what inhibition does
17:10:24 <jle`> it only blocks for that single tick
17:10:29 <solidus-river> yeah, so autob never gets run
17:10:30 <jle`> but it blocks the entire 'rest of the chain'
17:10:35 <jle`> yeah
17:10:39 <jle`> becuase...there's nothing to run it "with"
17:10:42 <jle`> you couldn't even force it to run
17:10:48 <jle`> if autoa returns Nothing
17:11:17 <solidus-river> they type of timedSession is wierd
17:11:31 <solidus-river> (() -> Timed NominalDiffTime ())
17:11:39 <solidus-river> why is it keeping a set or monoid
17:11:42 <solidus-river> instead of a value
17:12:20 <solidus-river> i know () is just void
17:12:33 <solidus-river> but why Monoid, does it ever have to combine s?
17:12:44 <matematikaadit> > array (0,5) [(i,i) | i <- [1..]]
17:12:46 <lambdabot>  array *Exception: Ix{Integer}.index: Index (6) out of range ((0,5))
17:14:05 <jle`> solidus-river: i think just Monoid for mempty
17:14:11 <jle`> if i recall correctly
17:14:20 <jle`> mempty to give "now"
17:14:25 <jle`> as in, dt of 0
17:14:40 <solidus-river> ah, kk that makes sense
17:15:17 <dfeuer> () is not exactly Void.
17:15:29 <solidus-river> i thought it was ~ Void
17:15:37 <Zekka> Nope
17:15:41 <solidus-river> what is it exactly?
17:15:45 <Zekka> Void has no members, () has exactly one
17:16:13 <solidus-river> but cant you use () to denote you don't care about what that return type is kind of?
17:16:15 <solidus-river> er
17:16:22 <solidus-river> i always though IO () was that
17:16:27 <solidus-river> so whats the point of the () in IO ()
17:16:35 <Zekka> Well, you use it in effectful code to denote 'no meaningful return-value'
17:16:42 <Zekka> But that's not the same as 'no return value'
17:16:54 <Zekka> IO () is an () in IO: IO Void is a Void in IO
17:16:55 <benzrf> if something results in Void, that means that it doesn't terminate
17:17:04 <solidus-river> when is Void used then?
17:17:10 <benzrf> if something results in (), it means that it terminates but has no result
17:17:12 <benzrf> or rather
17:17:13 <Zekka> If you have an IO Void, evaluating it will probably cause funny things to happen
17:17:15 <benzrf> has no meaningful result
17:17:18 <phaazon> :t (<@)
17:17:19 <lambdabot>     Not in scope: ‚Äò<@‚Äô
17:17:19 <lambdabot>     Perhaps you meant one of these:
17:17:19 <lambdabot>       ‚Äò<‚Äô (imported from Data.Ord), ‚Äò<=‚Äô (imported from Data.Ord),
17:17:35 <solidus-river> interesting so what non meaningfull return value does an IO action usually have?
17:17:40 <Zekka> (it recurses forever or it errors out)
17:17:53 <phaazon> I wonder if there‚Äôs anyone except edwardk that has ever used <@> or similar :)
17:17:53 <Zekka> solidus-river: (), that's the only member of the type
17:18:04 <Zekka> so if you print a line to stdout it always gives you ()
17:18:18 <Zekka> which means *technically* you can bind over it and all but actually doing that isn't terribly useful
17:18:21 <Zekka> it's all effects, no value
17:18:43 <Zekka> If you have an IO Void it means it has a funny value that indicates nontermination
17:18:50 <solidus-river> ah, are the effects "kept track of" in () or is it just a book keeper for side effects
17:18:53 <solidus-river> er, effects
17:18:54 <Zekka> so IO () is 'I don't have a meaningful return value', IO Void is 'I will throw up on you'
17:18:57 <jle`> IO () represents the concept of "void" in other languages
17:18:59 <Zekka> solidus-river: The effects are in IO
17:19:02 <jle`> but void isn't Haskell's Void
17:19:06 <Zekka> () is the value minus effects
17:19:22 <Zekka> Just like in [a] the context is [] and the type of the value in that context is a
17:19:22 <solidus-river> yeah if Void only means non terminating, why not use bottom / undefined
17:19:31 <phaazon> 02:15 < benzrf> if something results in Void, that means that it doesn't terminate
17:19:33 <Zekka> solidus-river: Those are valid Voids
17:19:33 <jle`> solidus-river: undefined/bottom are values
17:19:39 <phaazon> I‚Äôm not quite sure what you mean, benzrf‚Ä¶
17:19:41 <Zekka> > (undefined :: Void)
17:19:42 <jle`> Void is a type
17:19:43 <lambdabot>  Not in scope: type constructor or class ‚ÄòVoid‚Äô
17:19:51 <benzrf> jle`: i'm ignoring bottom :
17:19:52 <phaazon> I used void to type closed arithmetic expression
17:19:53 <benzrf> * :p
17:19:55 <Zekka> @data Void
17:19:55 <lambdabot> Unknown command, try @list
17:19:57 <solidus-river> so is Void a type that has no definedness?
17:19:57 <phaazon> and it‚Äôs quite finite
17:20:05 <phaazon> s/void/Void
17:20:09 <Zekka> solidus-river: It's a type with no values other than values describing nontermination
17:20:24 <phaazon> solidus-river: data Void
17:20:27 <Zekka> i.e. you can let x = x :: Void
17:20:28 <solidus-river> heh, can there be levels of definedness for nontermination then?
17:20:29 <phaazon> no ctor
17:20:29 <benzrf> solidus-river: there are no values of type Void that are not polymorphic
17:20:45 <benzrf> solidus-river: think about it
17:20:47 <solidus-river> like does Void include undefined and something else
17:20:54 <phaazon> there‚Äôs only one thing that has type Void :)
17:21:04 <benzrf> if a computation terminates, it must have a result
17:21:05 <shlevy> Anyone know if sqlite-simple is threadsafe?
17:21:11 <benzrf> there is no possible value of type Void (ignoring bottom)
17:21:17 <Zekka> solidus-river: It includes undefined/errors in Haskell
17:21:19 <benzrf> therefore, a computation of type Void cannot terminate
17:21:26 <Zekka> minding that those aren't meaningfully 'values' -- they  represent kinds of nontermination
17:21:29 <phaazon> benzrf: wait
17:21:30 <benzrf> at least, not without values
17:21:34 <benzrf> *bottoms
17:21:39 <phaazon> I have a pastebin for you :)
17:21:48 <Zekka> Just like how let x = x :: Void is valid but actually evaluating x does nothing useful
17:22:08 <solidus-river> cool
17:22:29 <phaazon> benzrf: http://lpaste.net/107229#line80
17:22:38 <solidus-river> i read up on fix the other day and i'm confused about one thing
17:22:48 <phaazon> you can perfectly evaluate E Void
17:22:52 <Zekka> In practice, you could probably (I hvaen't done this) define a lot of effectful functions to result in m Voids instead of m ()s
17:22:53 <solidus-river> the article i read clamed it does iterative fixed point to find the least determined fixed piont
17:23:02 <solidus-river> but isnt that always bottom?
17:23:18 <Zekka> in which case evaluating will end up with a runtime error (the 'value's are "undefined: try again, chump!")
17:23:27 <benzrf> phaazon: yes, E Void is not Void
17:23:28 <Zekka> but I think using unit ( () ) is more elegant
17:23:29 <benzrf> i said Void
17:24:10 <phaazon> oh, ok
17:24:16 <phaazon> sorry for the misunderstanding
17:24:23 <Zekka> It's not too hard to come up with types that you can parameterize over Void and still construct
17:24:37 <Zekka> :t Const
17:24:38 <benzrf> Const ()
17:24:38 <lambdabot> a -> Const a b
17:24:52 <Zekka> > show (Const 4 :: Const Void)
17:24:53 <lambdabot>  Not in scope: type constructor or class ‚ÄòVoid‚Äô
17:24:54 <phaazon> Zekka: in the case of lpaste I pasted, ‚Äúnot being able to construct‚Äù is power
17:25:14 <phaazon> it disable people to use free variables in the expression, for instance
17:25:16 <phaazon> disables
17:25:22 <Zekka> phaazon: But the point is that you can still construct it -- you just can't use the 'V' constructor if you've parameterized it over Void, yes?
17:25:24 <solidus-river> no, i think its good that theres a difference between non-meaningfull result / effect and nontermination
17:25:36 <phaazon> Zekka: yes, that‚Äôs the point
17:25:37 <Zekka> Because this is very similar to the case with Const
17:25:38 <phaazon> no V
17:25:42 <benzrf> @let data Void
17:25:43 <phaazon> so no free variable
17:25:44 <lambdabot>  Defined.
17:25:47 <phaazon> so closed expression :)
17:25:51 <Zekka> benzrf: Oh, is that how you d o it?
17:25:56 <benzrf> Zekka: yes
17:26:03 <Zekka> > show (Const 4 :: Const Void)
17:26:04 <lambdabot>  Expecting one more argument to ‚ÄòControl.Applicative.Const L.Void‚Äô
17:26:04 <lambdabot>  Expected a type,
17:26:04 <lambdabot>    but ‚ÄòControl.Applicative.Const L.Void‚Äô has kind ‚Äò* -> *‚Äô
17:26:11 <Zekka> > show (Const 4 :: Const Int Void)
17:26:12 <lambdabot>  No instance for (GHC.Show.Show
17:26:13 <lambdabot>                     (Control.Applicative.Const GHC.Types.Int L.Void))
17:26:13 <lambdabot>    arising from a use of ‚ÄòGHC.Show.show‚Äô
17:26:18 <benzrf> http://sadtrombone.com/
17:26:21 <Zekka> =(
17:26:43 <phaazon> > show . unConst $ (Const 4 :: Const Int Void)
17:26:45 <lambdabot>  Not in scope: ‚ÄòunConst‚Äô
17:26:45 <lambdabot>  Perhaps you meant one of these:
17:26:45 <lambdabot>    ‚Äòuncons‚Äô (imported from Control.Lens),
17:26:45 <lambdabot>    ‚ÄòBSC.uncons‚Äô (imported from Data.ByteString.Char8),
17:26:45 <lambdabot>    ‚ÄòBSLC.uncons‚Äô (imported from Data.ByteString.Lazy.Char8)
17:26:47 <benzrf> > instance Show a => Show (Const a) where show (Const
17:26:47 <benzrf> oop
17:26:48 <lambdabot>  <hint>:1:1: parse error on input ‚Äòinstance‚Äô
17:26:50 <Zekka> :t Const 4 :: Const Int Void
17:26:51 <lambdabot> Const Int Void
17:26:54 <Zekka> hey looky it typechecks
17:27:03 <benzrf> > instance Show a => Show (Const a) where show (Const a) = "Const {getConst = " ++ show a ++ "}"
17:27:04 <lambdabot>  <hint>:1:1: parse error on input ‚Äòinstance‚Äô
17:27:11 <benzrf> dang
17:27:13 <benzrf> @let instance Show a => Show (Const a) where show (Const a) = "Const {getConst = " ++ show a ++ "}"
17:27:14 <jle`> @
17:27:14 <lambdabot>  .L.hs:149:28:
17:27:14 <lambdabot>      Expecting one more argument to ‚ÄòConst a‚Äô
17:27:14 <lambdabot>      The first argument of ‚ÄòShow‚Äô should have kind ‚Äò*‚Äô,
17:27:14 <lambdabot>        but ‚ÄòConst a‚Äô has kind ‚Äò* -> *‚Äô
17:27:14 <lambdabot>      In the instance declaration for ‚ÄòShow (Const a)‚Äô
17:27:17 <benzrf> mfw
17:27:21 <benzrf> @let instance Show a => Show (Const a b) where show (Const a) = "Const {getConst = " ++ show a ++ "}"
17:27:22 <lambdabot>  Defined.
17:27:27 <phaazon> > show . getConst $ (Const 4 :: Const Int Void)
17:27:28 <lambdabot>  "4"
17:27:29 <benzrf> > Const 4 :: Const Int Void
17:27:31 <lambdabot>  Const {getConst = 4}
17:27:43 <phaazon> it‚Äôs due to laziness
17:28:43 <Zekka> solidus-river: You can use Void to describe things like 'a Maybe that never has a value' or 'an Either that always Lefts'/'an Either that always Rights'
17:28:55 <Zekka> and then pass those to functions which are polymorphic over those types
17:30:22 <jle`> you can't take the rights away from my Either
17:30:27 <jle`> i'll fight for it in court
17:30:42 <jle`> power to the people
17:35:40 <phaazon> oh
17:35:43 <phaazon> come on‚Ä¶
17:35:45 <phaazon> https://hackage.haskell.org/package/happstack-clientsession-7.2.7/docs/src/Happstack-Server-ClientSession.html#ClientSession
17:35:56 <phaazon> data-default is exactly designed for that purpose :4
17:35:57 <phaazon> :(
17:36:48 <Cale> phaazon: Yeah, but this has a specific meaning
17:37:05 <Cale> While data-default is kind of arbitrary
17:37:11 <phaazon> well
17:37:25 <phaazon> a default session has full meaning to me
17:37:52 <phaazon> no?
17:39:16 <tejing>  I'm trying to write a function that finds the distance between the first and second copies of the first repeated value in a list but whatever I do it gets so convoluted it's impossible to keep track of what's going on. Any suggestions on how to do it?
17:40:14 <Cale> phaazon: Well, I dunno. I'd usually prefer to err on the side of caution when it comes to using 3rd party type classes which don't have any particular laws associated with them for that kind of thing.
17:40:18 <phaazon> tejing: index the whole list, sort, win
17:40:47 <phaazon> Cale: I perfectly understand :)
17:40:59 <phaazon> I‚Äôm used to write code via def
17:41:05 <phaazon> it might be wrong
17:41:30 <phaazon> but in a most cases, when I say ‚ÄúI‚Äôd like the default behavior‚Äù, Default seems to suit the job to me
17:41:57 <phaazon> tejing: let‚Äôs say you have [a,d,f,c,x,q,d,a]
17:42:06 <phaazon> index it (zip l [0..])
17:42:08 <phaazon> you get:
17:42:41 <phaazon> [(0,a),(1,d),(2,f),(3,c),(4,x),(5,q),(6,d),(7,a)]
17:42:45 <phaazon> I reversed the zip
17:42:48 <phaazon> zip [0..] l
17:42:50 <phaazon> whatever
17:42:56 <phaazon> then, sortBy (comparing snd)
17:43:02 <phaazon> you get something like
17:43:08 <silasm> > zip [0..] [a,b,c,d,e] :: Expr
17:43:09 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
17:43:10 <lambdabot>              with actual type ‚Äò[(a0, Debug.SimpleReflect.Expr.Expr)]‚Äô
17:43:20 <silasm> I always screw that up :S
17:43:24 <Cale> > zip [0..] "adfcxqda"
17:43:26 <lambdabot>  [(0,'a'),(1,'d'),(2,'f'),(3,'c'),(4,'x'),(5,'q'),(6,'d'),(7,'a')]
17:43:29 <phaazon> :t zip [0..] "silasm"
17:43:30 <lambdabot> (Num a, Enum a) => [(a, Char)]
17:43:39 <Cale> > sortBy (comparing snd) . zip [0..] $ "adfcxqda"
17:43:40 <lambdabot>  [(0,'a'),(7,'a'),(3,'c'),(1,'d'),(6,'d'),(2,'f'),(5,'q'),(4,'x')]
17:43:55 <silasm> > zip [0..] [a,b,c,d,e] :: [Int,Expr]
17:43:57 <phaazon> I guess something even better would be:
17:43:57 <lambdabot>  Illegal type: ‚Äò'[Int, Expr]‚Äô Perhaps you intended to use DataKinds
17:44:21 <jle`> so close
17:44:23 <silasm> nope. I need to actually get Expr locally and mess with it before I flood the channel D:
17:44:32 <phaazon> sortBy (comparing snd <> comparing fst) ‚Ä¶
17:44:34 <jle`> silasm: you can also just query/pm lambdabot
17:44:55 <Cale> > groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz"
17:44:56 <phaazon> (in order to get distance in the right order)
17:44:57 <lambdabot>  [[(3,'c')],[(1,'d'),(6,'d')],[(2,'f')],[(5,'q')],[(4,'x')],[(0,'z'),(7,'z')]]
17:45:19 <jle`> > zip [0..] [x,y,z] :: [(Int, Expr)] -- silasm
17:45:21 <lambdabot>  [(0,x),(1,y),(2,z)]
17:45:36 <kazagistar> tejing: try using "splitOn" and then grab the length of the second item
17:45:58 <Cale> > concatMap (\(x:xs) -> map ((,) x) xs) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz"
17:45:59 <lambdabot>  [((1,'d'),(6,'d')),((0,'z'),(7,'z'))]
17:46:11 <tejing> phaazon: I'm not seeing how your method gets me the first repeated value as opposed to some other repeated value
17:46:29 <ReinH> ... it doesn't ;)
17:46:31 <Cale> > sort . concatMap (\(x:xs) -> map ((,) x) xs) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz"
17:46:32 <tejing> kazagistar: that would be good except I don't know what the repeated value is
17:46:33 <lambdabot>  [((0,'z'),(7,'z')),((1,'d'),(6,'d'))]
17:47:22 <phaazon> well, I think it does
17:47:29 <phaazon> with comparing snd <> comparing fst
17:47:40 <ReinH> phaazon: does 1 come before 0?
17:48:03 <Cale> phaazon: You have to be careful, if you sort based on the elements of the list, you'll end up with the smallest elements first, not necessarily the ones which occurred first in the original list
17:48:14 <Cale> So, once you get the pairs of equal values, you have to sort that again
17:48:29 <phaazon> Cale: hm, so compare snd <> compare fst might be wrong I guess
17:48:40 <Cale> > concatMap (\((k,x):xs) -> map ((,) k . fst) xs) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz"
17:48:42 <lambdabot>  [(1,6),(0,7)]
17:48:45 <Cale> > sort . concatMap (\((k,x):xs) -> map ((,) k . fst) xs) . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz"
17:48:47 <lambdabot>  [(0,7),(1,6)]
17:48:53 <kazagistar> tejing: then fold the items into a (Map item index), and look each item up as you go, and return on the first repeat?
17:49:09 <Cale> ^^ that works
17:49:27 <Cale> Probably that concatMap could be written more nicely
17:49:59 <Cale> Note that the pattern match will never fail because groupBy only ever produces nonempty lists as elements
17:50:49 <phaazon> maybe with the list monad
17:50:53 <Cale> [(k,j) | ((k,x) : xs) <- groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz", (j,y) <- xs]
17:50:58 <Cale> > [(k,j) | ((k,x) : xs) <- groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz", (j,y) <- xs]
17:50:59 * hackagebot peyotls 0.0.0.22 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.22 (YoshikuniJujo)
17:51:00 <lambdabot>  [(1,6),(0,7)]
17:51:18 <phaazon> :)
17:51:20 <Cale> > [j - k | (k,j) <- sort [(k,j) | ((k,x) : xs) <- groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "zdfcxqdz", (j,y) <- xs]]
17:51:22 <lambdabot>  [7,5]
17:52:19 <Cale> > [(k,j) | ((k,x) : xs) <- groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "abracadabra", (j,y) <- xs]
17:52:20 <lambdabot>  [(0,3),(0,5),(0,7),(0,10),(1,8),(2,9)]
17:55:59 * hackagebot sql-simple 0.3.0 - common middle-level sql client.  http://hackage.haskell.org/package/sql-simple-0.3.0 (HirotomoMoriwaki)
17:56:01 * hackagebot sql-simple-sqlite 0.3.0 - sqlite backend for sql-simple  http://hackage.haskell.org/package/sql-simple-sqlite-0.3.0 (HirotomoMoriwaki)
17:56:03 * hackagebot sql-simple-postgresql 0.3.0 - postgresql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-postgresql-0.3.0 (HirotomoMoriwaki)
17:56:05 * hackagebot sql-simple-mysql 0.3.0 - mysql backend for sql-simple  http://hackage.haskell.org/package/sql-simple-mysql-0.3.0 (HirotomoMoriwaki)
17:56:07 * hackagebot sql-simple-pool 0.3.0 - conection pool for sql-simple  http://hackage.haskell.org/package/sql-simple-pool-0.3.0 (HirotomoMoriwaki)
17:57:04 <suOya_> s
18:05:18 <isomorpheous> Would someone be so kind as to install my app and try to get openssl keys working?
18:06:08 <isomorpheous> https://github.com/pharpend/podium/tree/tls
18:06:24 <isomorpheous> Every time I run it, I get the error "podium: no keys found"
18:18:20 <bitraten> hi, how can i parse with the HeaderParser from cassava?
18:20:50 <td123_> I got the following warning in hlint, I think the suggestion might actually be a bug: http://lpaste.net/107231
18:20:58 <td123_> I have a custom module called List
18:22:54 <bergey> Apparently people still use http://hackage.haskell.org/package/haskell98 -- 445 downloads this month.
18:25:51 <kazagistar> yeah, I guess it does not check for that
18:25:56 <augur> hmm...   data Tree (Key : Set) (El : Key -> Set) : Set where { empty : Tree Key El ; branch : (k : Key) (e : El k) (l r : Tree Key El) -> Tree Key El }
18:26:54 <augur> data Ref : {Key : Set} (El : Key -> Set) -> Set where ref : (k : Key) -> Ref (El k)
18:27:09 <augur> mm nope
18:27:33 <rwbarton> bergey: it's funny because haskell98 also is included with ghc...
18:27:46 <rwbarton> I don't think upgrading it is very likely to work?
18:27:51 <augur> data Ref {Key : Set} {El : Key -> Set} : Set -> Set where ref : (k : Key) -> Ref (El k)
18:28:07 <rwbarton> maybe it's a sort of wrapper around base
18:28:13 <td123_> opened an hlint bug for that behavior: https://github.com/ndmitchell/hlint/issues/60
18:28:18 <augur> probably would need to make El explicit
18:33:27 <pavonia> td123_: Maybe you should rename your module names so that they don't clash with the base modules' names
18:34:10 <brunoalano> Hey guys
18:43:52 <kazagistar> pavonia: so what you are saying is that the error should say "Module name clashes with standard module."?
18:44:33 <pavonia> That would probably be a better warning, yeah
18:48:51 <chrisdotcode> how often do people with commit access check the hackage github? I sent a pull request.
18:56:07 <tejing> regarding my earlier question, I think I came up with something simple enough: succ $ head $ (\(x:xs) -> elemIndices x xs) $ head $ filter (\(x:xs) -> x `elem` xs) $ tail $ scanl (\a x -> x:a) [] "kahfjkauirvn"
18:57:20 <mjrosenb> question: is it possible to get cabal-install to migrate all local packages to global packages?
18:58:29 <luite_> mjrosenb: i don't think cabal-install can do that, but do you need the installation locations to be changed too?
19:01:23 <mjrosenb> luite_: probably
19:02:10 <pavonia> >  succ $ head $ (\(x:xs) -> elemIndices x xs) $ head $ filter (\(x:xs) -> x `elem` xs) $ tail $ scanl (\a x -> x:a) [] "kahfjkauirvn"
19:02:11 <lambdabot>  5
19:02:55 <mjrosenb> i'm now trying to build darcs, via aur, but it doesn't see deepseq, probably because it was installed via cabal?
19:03:24 <mjrosenb> unless deepseq came with ghc, in which case, I have no clue why darcs isn't building.
19:06:52 <mjrosenb> http://bpaste.net/show/449948/
19:07:06 <mjrosenb> oh, nevermind? I onlt read the last line
19:07:16 <mjrosenb> anyhow, I'm still not sure how to fix this.
19:08:47 <augur> wow
19:08:48 <augur> ok
19:08:53 <augur> who's a criterio professional here?
19:08:57 <augur> anyone?
19:09:23 <augur> because criterion has been running for like 12 hours without producing any output
19:12:57 <dfeuer> augur, your statement lacks context.
19:13:29 <augur> Criterion is a benchmarking library
19:14:00 <dfeuer> Yes, I am aware, augur. Maybe your code is very slow, or you are running it too many times?
19:14:15 <augur> im not specifying how many times to run it
19:14:25 <mjrosenb> oh, great! cabal install darcs fails with the same error!
19:14:26 <augur> im using the standard defaultMain + bench method
19:16:05 <dfeuer> augur, what's your defaultMain invocation look like?
19:16:20 <dfeuer> What happens when you run your code other than in Criterion?
19:16:34 <dfeuer> s/in/with
19:16:36 <augur> outside of criterion it works fine
19:17:05 <augur> defaultMain [bench "foo" (nf foo val)]
19:18:27 <dfeuer> augur, when you're running it otherwise, are you forcing it all the way to normal form?
19:18:37 <augur> dfeuer: yep
19:18:40 <dfeuer> HMMM
19:19:27 <dfeuer> That is very peculiar then.
19:21:08 * hackagebot propellor 0.8.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.8.1 (JoeyHess)
19:25:11 <isomorpheous> Hey, y'all
19:27:35 <mzero> hi
19:29:18 <isomorpheous> Would someon ehere mind looking at my library
19:29:43 <isomorpheous> https://github.com/pharpend/podium/tree/tls
19:29:45 <isomorpheous> it compiles
19:30:01 <isomorpheous> But it doesn't quite work
19:30:49 <isomorpheous> When you try to view the site, it outputs "no keys found"
19:47:58 <sveit> suppose i have a function "f x y z = reverse . fst $ foldl' someFunct 0 (expensiveFunction x y)" and i have another function g = ... for z in bigSet ((f x y) z), will expensiveFunction get re-computed many times
19:54:23 <parc> @pl \f (x,y) = case f x of { Left e -> Left e ; Right b -> Right (b,y) }
19:54:23 <lambdabot> (line 1, column 10):
19:54:24 <lambdabot> unexpected "="
19:54:24 <lambdabot> expecting pattern or "->"
19:54:25 <levi> Yes; f introduces new bindings for x and y on every usage in g, even if you pass the same values.
19:54:30 <parc> @pl \f (x,y) -> case f x of { Left e -> Left e ; Right b -> Right (b,y) }
19:54:30 <lambdabot> (line 1, column 25):
19:54:31 <lambdabot> unexpected '{'
19:54:31 <lambdabot> expecting variable, "(", operator or end of input
19:55:23 <sveit> levi: why? what if g x y = ... for z in bigSet ((f x y) z)?
19:55:25 <sveit> still?
19:56:15 <ReinH> what is this for ... in ... ?
19:56:44 <sveit> ReinH: just that other stuff might be done in the function g
19:56:58 <levi> ReinH: I assume it's handwavey 'pseudocode'
19:57:15 <sveit> exactly. it doesn't really have to be there
19:57:38 <ReinH> ok
19:58:33 <levi> sveit: Lazy evaluation doesn't magically memoize things. It just reduces the overhead of call-by-name by sharing results *within* a lambda.
19:58:51 <parc> @pl \f (x,y) -> either Left (Right . ((,) <$> id <*> const y)) $ f x
19:58:52 <lambdabot> (`ap` snd) . (. fst) . (flip (either Left . (Right .) . ((,) <$>) . (id <*>) . const) .)
19:59:36 <levi> So if you bind x in a lambda, and it appears twice in the body, it will still be evaluated at most once.
20:00:01 <brunoalano> I need know about lambda-calculus to learn Haskell?
20:00:14 <ReinH> brunoalano: nope
20:00:15 <stolaruk> brunoalano: No
20:00:23 <levi> A pure call-by-name implementation would have to evaluate x twice if both copies of x in the body were scrutinized.
20:00:24 <dwcook> brunoalano, know, though you are likely to learn a few things about it in learning Haskell.
20:00:28 <dwcook> s/know/no/
20:00:38 <pjdelport> brunoalano: No, but you can certainly apply any knowledge of lambda calculus inside Haskell. (no pun intended)
20:00:54 <dwcook> pjdelport, took me a moment to find the pun :P
20:01:00 <dwcook> I cringed
20:01:00 <levi> brunoalano: You don't have to know about it, but you'll probably learn a lot about lambda calculus in the process.
20:01:02 <stolaruk> I find I have a lot of "maybe" calls that look like: "maybe (return ()) f myMaybeVal" - is there a good generalization of this?
20:01:05 <brunoalano> Thanks (:
20:01:08 <dwcook> @quote fugue
20:01:08 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:01:45 <sveit> levi: ok, but if i instead define f x y = \z -> stuff where e = expensiveFunction x y, then expensiveFunction only gets called once?
20:01:47 <levi> Haskell is a typed lambda calculus with a lot of syntactic sugar. :)
20:02:08 <brunoalano> Other question, current I'm studying AI (NLP, ML), Haskell is a good language for those implementations?
20:02:50 <parc> :t \f (x,y) -> case f x of { Left e -> Left e ; Right b -> Right (b,y) }
20:02:51 <lambdabot> (t -> Either a t1) -> (t, t2) -> Either a (t1, t2)
20:02:59 <parc> :t (`ap` snd) . (. fst) . (flip (either Left . (Right .) . ((,) <$>) . (id <*>) . const) .)
20:03:00 <lambdabot> (b -> Either a (a2 -> a1)) -> (b, a2) -> Either a (b1 -> (a1, b1))
20:03:01 <levi> sveit: Yes, if you bind an expensive expression to a variable, then it will only be computed once *per invocation of the lambda inside which the binding occurs*.
20:03:24 <mzero> brunoalano: I'm not sure what makes a langague good or bad for AI.
20:03:40 <parc> @pl \f (x,y) -> case f x of { Left e -> Left e ; Right b -> Right (b,y) }
20:03:41 <lambdabot> (line 1, column 25):
20:03:41 <lambdabot> unexpected '{'
20:03:41 <lambdabot> expecting variable, "(", operator or end of input
20:03:53 <mzero> But sure - Haskell is good for most things
20:04:02 <stolaruk> Why was there such an AI boom around lisp back in the day?
20:04:04 <brunoalano> mzero: for example, presence of abstract structures
20:04:14 <dwcook> brunoalano, oh yes, Haskell definitely has that
20:04:19 <stolaruk> brunoalano: Haskell is knee deep in abstract goo
20:04:20 <parc> @pl \f (x,y) -> either Left (Right . ((,) <$> id <*> const y)) $ f x
20:04:21 <lambdabot> (`ap` snd) . (. fst) . (flip (either Left . (Right .) . ((,) <$>) . (id <*>) . const) .)
20:04:29 <mzero> but you need that for ANY comp. sci. project
20:05:02 <parc> what the heck. the function i get back with @pl has a very different type
20:05:16 <levi> stolaruk: The AI boom was correlated with Lisp, but it's more true that Lisp and Prolog and whatnot rose from attempts to work on AI than the other way around.
20:05:19 <brunoalano> Some book reccomendation to start learning Haskell? I know already languages like C, C++, D
20:05:36 <sveit> levi: ok. just wondering, what happens then if i do (with the same f with the where as above), and i define g x y z = for z in bigSet ((f x y) z), f x y only gets evaluated once?
20:05:36 <jollygood> is there a nicer way of writing this?
20:05:39 <jollygood> > map (\(x, y) -> (show x, show y)) [(1,2),(3,4)]
20:05:39 <brunoalano> Actually I use Python 3 for some implementations
20:05:40 <levi> Learn You a Haskell is a reasonable start.
20:05:41 <lambdabot>  [("1","2"),("3","4")]
20:05:42 <mzero> I'd still suggest breezing through Learn You A Haskell
20:05:52 <stolaruk> levi: So those languages have some roots in attempts to solve AI problems?
20:07:37 <pjdelport> > (show &&& show) <$> [(1,2),(3,4)]
20:07:39 <lambdabot>  [("(1,2)","(1,2)"),("(3,4)","(3,4)")]
20:07:50 <kazagistar> "Mathematics is the study of abstractions which don't leak."
20:08:00 <mzero> I'd say it is more that the other language at the time didn't have the properites needed for the method of exploration that the AI folks were working on
20:08:03 <kazagistar> I like that quote (randomly saw on reddit)
20:08:06 <levi> sveit: If you only want stuff inside *f* to be evaluted once, you're going to have to only evaluate *f* itself once.
20:08:41 <mzero> and so Lisp was born out of a need for a kind of language system in general, rather than the needs of AI in particular
20:08:42 <levi> kazagistar: Which article was it in response to?
20:08:56 <jollygood> we are still repeating function name twice though :)
20:09:04 <mzero> kazagistar: tell that to G√∂del...
20:09:24 <pjdelport> > (show *** show) <$> [(1,2),(3,4)]
20:09:25 <lambdabot>  [("1","2"),("3","4")]
20:09:33 <dwcook> jollygood, did you know your example is actually polymorphic in such a way that you could be using two different shows?
20:10:26 <levi> sveit: If you invoke f a bunch of times, it will be evaluated a bunch of times.  The only way to keep it from being evaluated a bunch of times is to bind the expression that you want to be evaluated only once to a variable outside of whatever map/fold/iteration you are doing.
20:10:38 <dwcook> jollygood, anyway, I think you could get something like that using lens's over and both
20:10:41 <dwcook> @type over
20:10:41 <sveit> levi: i see
20:10:42 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:10:42 <dwcook> @type both
20:10:43 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
20:11:03 <stolaruk> Anyone here read Parallel and Concurrent Programming in H? I'm working thru the concurrency section now.
20:11:03 <dwcook> Maybe the types are a bit abstract to comprehend easily :P
20:11:06 <jollygood> jollygood true. but in my real example the function doesn't take a typeclass
20:11:16 <sveit> levi: it would get bound if i do something like "map (f x y)"? what if (for some other function h) "map (h . (f x y))"?
20:11:17 <mzero> jollygood: if you find that you need to apply the same function to both parts of a tuple often.... try defining a helper:   onBoth f (a,b) = (f a, f b)
20:11:36 <jollygood> s/jollygood/dwcook :)
20:11:48 <luite_> mjrosenb: some absolute locations can be hardcoded through the Paths_package module, so in general you cannot migrate the installation location
20:11:52 <mzero> > let onBoth f (a,b) = (f a, f b) in map (onBoth show) [(1,2), (3,4)]
20:11:54 <lambdabot>  [("1","2"),("3","4")]
20:12:01 <levi> sveit: You need a 'let' or 'where' to keep a subexpression that's re-used many times from being evaluated each time.
20:12:04 <jollygood> mzero, that is probably most readable
20:12:12 <luite_> mjrosenb: you can copy the package config files to the global db and recache it, but that's probably not wat you want
20:12:12 <dwcook> jollygood, in short, I think that's practically as good as you'll get without defining something else yourself or introducing packages besides base
20:12:15 <mzero> I tend to go for readable in my code base
20:12:29 <mjrosenb> luite_: I just want to rebuild everything that is local as global
20:12:32 <dwcook> Yeah, I like mzero's example
20:12:47 <stolaruk> clever vs. readable
20:12:51 <mjrosenb> possibly recursively building deps that have the path hardcoded
20:13:03 <luite_> mjrosenb: ah right
20:13:14 <sveit> levi: really? why? can you point me to some documentation? of course i trust what you are saying is true, i am just trying to understand it. outside a monad i don't see why i would NEED a "where" clause to bind a function liek that
20:13:26 <Clint> (show *** show) is perfectly readable
20:13:27 <sveit> levi: as in my "map (f x y)"
20:13:56 <dwcook> @type show *** show
20:13:57 <lambdabot> (Show a, Show b') => (a, b') -> (String, String)
20:14:13 * dwcook did not know about (***)
20:14:41 <levi> sveit: If (f x y) evaluates to a function, then it's only going to be evaluted once per evaluation of the map.
20:14:42 <stolaruk> @type over both show
20:14:43 <lambdabot> (Data.Bitraversable.Bitraversable r, Show a) => r a a -> r String String
20:15:12 <dwcook> That's more like I was thinking but forgot the exact usage :P
20:15:20 <levi> sveit: I'm sorry if my answers have been confusing; it's difficult to follow the hand-wavey pseudocode.
20:16:57 <mzero> Clint - it might be for show
20:17:26 <levi> sveit: The reason that (f x y) will only be evaluated once is that the expression is bound to a variable as one of the arguments to map while map is being evaluated. So (f x y) will be map's 'f'.
20:17:28 <sveit> levi: oh ok, that makes more sense. i'm sorry for being unclear myself. i mean suppose i have a function like map that takes a function as an argument, and i give it (f x y), for every time i call the map, (f x y) gets evaluated only once as an argument to map?
20:17:46 <levi> Yes, that's right.
20:18:00 <mzero> but I'd probably rather see    map (onBoth $ frabulate smixture (+)) listOPairs
20:18:28 <mzero> than    map ((frabulate smixture (+)) *** frabulate smixture (+))) listOPairs
20:18:31 <sveit> levi: thanks very much. how about something like map (g . (f x y))?
20:18:45 <mzero> or even     let f = frabulate smixture (+) in map (f *** f) listOfPairs
20:18:51 <Clint> mzero: yeah, fair enough
20:19:00 <sveit> for every map, (g . (f x y)) is bound as a variable
20:19:11 <levi> sveit: That whole expression will again be bound within the body of map to its first argument variable, so it will be evaluated at most once.
20:19:20 <mzero> (hat off to anyone who sneaks a function call frabulate into their package....)
20:19:21 <stolaruk> Does Haskell do STM better than other languages?
20:20:01 <levi> stolaruk: It has a pretty good STM implementation; I am unfamiliar with other language implementations of STM.
20:20:11 <stolaruk> levi: So am I :)
20:21:11 <sveit> levi: ok. still getting used to functions as first-class objects :)
20:22:05 <stolaruk> Do ppl often use MVar simply as a container for mutatable state, outside the context of concurrency?
20:22:31 <dwcook> stolaruk, TVar or IORef would be better for that. MVar is basically a single-item queue.
20:22:43 <dwcook> s/single/at-most-single/
20:23:02 <stolaruk> dwcook: What in the world is IORef anyway?
20:23:15 <dwcook> stolaruk, it's like a TVar but less safe and as a result faster, iirc.
20:23:22 <levi> A reference to a mutable cell.
20:23:42 <stolaruk> levi: Any blocking inherent?
20:24:06 <levi> I don't think so.
20:24:06 * dwcook really should have learned by now to be more rigorous than to use the word "safe" unqualified
20:24:38 <dwcook> That's the basic idea, TVar has transactional access whereas IORef does not.
20:24:59 <dwcook> If more than one thread uses an IORef, you may run into undesirable behavior.
20:25:58 <kazagistar> what undesireable behavior? one writing and one reading at the same time?
20:26:24 <isomorpheous> Ewww I don't like filing bug reports
20:26:25 <mzero> stolaruk: I don't think I ever use IORef... and only use MVar for passing between threads
20:26:32 <dwcook> The standard problems you run into when multiple threads try to use a mutable store at once.
20:26:32 <mzero> ... I've kicked the mutable state habit!
20:26:36 <dwcook> Race conditions, etc.
20:27:11 <mzero> Haskell: Enemy of the Mutable State!    http://www.ozonehouse.com/mark/enemy/
20:27:19 <dwcook> TVar, on the other hand, is accessed from STM transactions, which makes it somewhat safer.
20:27:26 <stolaruk> Concurrent programming can be very very complicated
20:27:32 <dwcook> Frick, I said "safer" again.
20:27:53 <dwcook> You see, whenever I say "safe" the little shachaf voice in my head calls me on it.
20:28:31 <levi> Heh.
20:29:33 <dfeuer> kazagistar, you you can understand Data.List.permutations, but you need to ask why it's a bad idea for two threads to stomp on the same IORef?
20:30:24 <dwcook> dfeuer, your question would seem to imply you think there's a single knowledge *level* rather than little bits of knowledge you pick up at a time
20:30:59 <dfeuer> dwcook, it was a joke, mostly.
20:31:09 <dwcook> Oh, okay, sorry. I failed to read it that way.
20:31:52 <dwcook> It's just I've heard enough of people actually stomping on each other's ignorance that I react to it somewhat automatically.
20:31:54 <kazagistar> I am imagining it as being a single pointer to a datastructure. Reads and writes simply mean that you have to ensure cache synchronization to memory to be safe, right?
20:32:48 <dwcook> kazagistar, in short, I'd suggest not using an IOVar directly at all if you need to use it in a potentially conflicting way from more than one thread.
20:32:53 <dwcook> A TVar is usually sufficient.
20:33:12 <kazagistar> k, fair enough, I was mostly just wondering what the differences were
20:33:18 <rwbarton> you can read an IORef atomically and you can write it atomically and you can even modify it with a pure function atomically
20:33:26 <dwcook> Oh, okay. Well there is an SO post that is specific on that, so lemme find it.
20:33:56 <rwbarton> but you cannot do anything more complicated atomically
20:34:00 <kazagistar> rwbarton: really, you can modify it with a pure function atomically? so there is some sync?
20:34:42 <rwbarton> @hoogle atomicModifyIORef
20:34:44 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
20:35:15 <rwbarton> it is a compare-and-swap
20:35:21 <dfeuer> rwbarton, by "more complicated" assume you mean combining it with another IORef?
20:35:54 <rwbarton> for example, or reading the value, doing an IO action with it to produce a new value and writing that back
20:36:05 <dwcook> Hmm, I couldn't seem to find the one I was thinking of, but this and related posts might be of help. https://stackoverflow.com/questions/5545517/difference-between-state-st-ioref-and-mvar
20:36:50 <dwcook> That also includes State and ST, which seems almost like a non sequitur to me, but meh.
20:39:26 <bitraten> hi, what's the most efficient way to load large csv files into haskell?
20:39:42 <kazagistar> dwcook: its kinda annoying mostly because it perpetuates the misconception that State means "mutating state" as opposed to "composing a state machine"
20:39:44 <maybefbi> bitraten, i have the same question
20:39:55 <kazagistar> the rest is informative
20:41:12 <dwcook> kazagistar, I prefer to just state outright that State s a is a wrapper of s -> (a, s). Anything other than that just seems confusing or avoiding the issue to me.
20:42:33 <dwcook> bitraten, maybefbi, I can't speak for efficiency, but earlier someone came in here and mentioned cassava which seems to be reasonably well designed.
20:43:09 <dwcook> To actually get a ByteString from a CSV file you'll want readFile from Data.ByteString or the like
20:43:24 <maybefbi> dwcook, my program here slows down over time although it only 1000 rows at any given time from a 300 MB file: http://lpaste.net/107234
20:43:34 <maybefbi> *it only plots
20:43:47 <dwcook> maybefbi, have you profiled to see where the slowdown comes from?
20:44:02 <maybefbi> dwcook, how do i profile?
20:44:09 <kazagistar> dwcook: I think if you are just coming to haskell, its not clear what the purpose of wrapping s -> (a, s) is, nor what I should use to store some thing and do stuff to it... personally, the difference between ST and State was really confusing to me when I first came to haskell, and the idea of monads was fuzzy in my head
20:44:16 <dwcook> I'm afraid I couldn't answer that question
20:44:26 <dfeuer> But "slows down over time" suggests you're holding on to things you shouldn't.
20:44:56 <maybefbi> dfeuer, yeah i have this lazy byte string array which holds all rows in the 300 MB file
20:45:05 <dfeuer> kazagistar, yeah, that's still a bit confusing to me.
20:46:05 <dfeuer> maybefbi, you want to be sure that the system knows you're chewing on that ByteString in order and not going backward....
20:46:36 <dwcook> kazagistar, then you just explain as the questions come up. If you start out by giving metaphors rather than the actual meat, you don't even give them the *opportunity* to try to grasp it correctly from your words.
20:46:43 <maybefbi> dfeuer, what data structure can tell the system that?
20:46:56 <schell> hey i just saw the new haskell.org front page on HN - it looks really good!
20:47:05 <dfeuer> maybefbi, it's more about how you're using the data structure. You'd need to show some actual code, I think.
20:47:08 <schell> props to whomever put that together
20:47:19 <maybefbi> dfeuer, http://lpaste.net/107234
20:48:04 <dfeuer> maybefbi, why are you importing Data.ByteString.Internal?
20:48:10 <dwcook> schell, hmm, I can't put my finger on what's different. Are you sure you're looking at haskell.org?
20:48:32 <dwcook> I do remember chrisdone or someone was working on a new, nicer Haskell site
20:48:43 <schell> dwcook: http://new-www.haskell.org/
20:48:57 <schell> it‚Äôs not live yet, but already linked on HN - probably this morning
20:48:59 <dwcook> Ah, yes, that's the one
20:49:03 <maybefbi> dfeuer, i need c2w from Internal to split lazy bytestring by char
20:49:31 <schell> dwcook: it really drives the big, glaring, awesome points of haskell
20:49:49 <dwcook> A lot of that is chrisdone's work if I'm not mistaken, I like the work they did on it
20:50:11 <dfeuer> maybefbi, can't you just use breakByte?
20:51:03 <schell> dwcook: well props to chrisdone, he consistently makes nice things :)
20:51:16 <maybefbi> dfeuer, breakByte only breaks the first occurrence.
20:51:28 <benzrf> is it usually:
20:51:28 <benzrf> foo bar baz
20:51:28 <benzrf>  | foo
20:51:28 <benzrf> or
20:51:28 <benzrf> foo bar baz
20:51:30 <benzrf>   | foo
20:51:38 <benzrf> for guards, i mean
20:51:57 <dfeuer> maybefbi, that's okay. I think I may have found the problem with your code, and it's that line.
20:52:36 <maybefbi> dfeuer, so i shouldn't use LBS.split (BS.c2w c) ?
20:52:37 <dfeuer> Well, the next one, actually.
20:52:39 <dfeuer> rows = splitBy '\n' input
20:52:45 <maybefbi> ah ok
20:53:02 <maybefbi> dfeuer, is that strictly evaluated?
20:53:28 <dfeuer> But there's no need for an internal splitter anyway, and you shouldn't use it. The problem is that you're NAMING the split-up input.
20:53:43 <dfeuer> (I think that's the problem, anyway)
20:53:56 <dfeuer> And naming a lot of other things too.
20:54:12 <maybefbi> dfeuer, naming causes evaluation?
20:54:12 <dfeuer> All that naming is asking the GC to kindly keep stuff live.
20:54:17 <dfeuer> Stuff you don't want to be live.
20:54:26 <maybefbi> dfeuer, i see
20:54:46 <rwbarton> prices in particular is live forever
20:55:28 <kazagistar> dwcook: there is nothing with starting with "State is (s -> (a,s))" but that is not enough to be useful to a new user, you have to explain the reasoning behind it and what purpose it serves I think
20:55:37 <rwbarton> but more likely the reason it gets slower over time is your list indexing stuff
20:55:49 <kazagistar> oh my
20:55:55 <dfeuer> I hadn't read that far, rwbarton.
20:57:18 <dfeuer> But yes, indexing into lists is *very expensive*.
20:57:55 <kazagistar> also, you really shouldn't use do blocks and have everything live in the IO monad
20:58:04 <benzrf> somebody pls
20:58:22 <bitemyapp> benzrf: no
20:58:34 <benzrf> bitemyapp: why
20:58:37 <bitemyapp> dfeuer: is it?
20:59:04 <dfeuer> bitemyapp, well, it is if you want anything far from the head of the list.....
20:59:08 <rwbarton> how long is this list of prices?
20:59:19 <maybefbi> rwbarton, if evaluated fully?
20:59:25 <bitemyapp> dfeuer: are you sure?
20:59:25 <rwbarton> yeah
20:59:43 <kazagistar> benzrf: I use two spaces, cause | plus a space makes for another two, so the start of the line proper is lined up on a multiple of two, but I dunno
20:59:47 <dfeuer> bitemyapp, are you trying to mess with my head or something?
20:59:48 <dwcook> kazagistar, I think an outright ban on do expressions is a bit much, however I will agree they are overused, and, for that matter, so are monads
21:00:23 <kazagistar> dwcook: no, that was in reference to maybefbi's code, I didnt make that clear
21:01:16 <maybefbi> rwbarton, 3128027 rows down, 43 columns wide.
21:01:19 <dwcook> kazagistar, but yeah, about your previous comment, yes, there may be explanation necessary, but less than if you start out explaining something that doesn't really correspond with reality :)
21:02:00 <rwbarton> > 3128027 * 43
21:02:01 <maybefbi> rwbarton, but i only plot 1000 rows at a time.
21:02:02 <lambdabot>  134505161
21:03:03 <rwbarton> ok so when you are on step 50 million, you scan from the start of prices to find the 50 million through 50 million + 1000th entries
21:03:20 <rwbarton> then when you are step 50 million + 1, you scan from the start of prices to find the 50 million + 1 through 50 million + 1001st entires
21:03:25 <rwbarton> right?
21:03:35 <dfeuer> maybefbi, what you want to do is chew on the end of the list.
21:03:36 <Luke> what's the difference between GHC.Conc.forkIO and Control.Concurrent.forkIO?
21:03:43 <maybefbi> rwbarton, i drop all rows except the last 1000
21:03:47 <dfeuer> You want to swallow it as you go.
21:04:03 <rwbarton> you still have to scan through the first 50 million entries to drop them!
21:04:11 <dfeuer> You do not want to be just licking it here and there.
21:04:48 <maybefbi> how do i change line 102, so that it only evaluated the last 1000 rows, and drops the rest without evaluation?
21:04:58 <maybefbi> *evaluates
21:05:03 <rwbarton> you can't, because you always start from the start of the list
21:05:18 <rwbarton> you want to do what dfeuer says, and put "the rest of the prices we haven't gotten to yet" into the World data structure
21:05:37 <rwbarton> (alternatively, just load the whole thing into a big array and use array indexing, it's not that big)
21:06:57 <maybefbi> dfeuer, i only store one of the inits in the World now.
21:07:08 <maybefbi> are you saying instead of that i store the prices there?
21:07:31 <maybefbi> btw i thought inits was lazily evaluated
21:07:41 <kazagistar> take the list, use Data.List.Split.chunksOf on it, and then do some kind of folds over the chunks in a pure function
21:08:01 <maybefbi> kazagistar, ok hmm
21:08:13 <rwbarton> it is lazily evaluated, but when you need the 50 millionth element, that does not do you much good!
21:08:33 <rwbarton> btw, inits xs !! n = drop n xs (more or less)
21:09:08 <Algebr> Looking to build from source haskell-platform but instructions say I need to have 7.6 installed beforehand? Is this really the case?
21:09:41 <mzero> yes - the source release of haskell platform doesn't come with the compiler
21:09:41 <maybefbi> rwbarton, haskell is like C when it comes to memory management. we gotta think on behalf of the GC
21:09:46 <glguy> > inits [1..5]
21:09:48 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
21:10:04 <mzero> but you can install the built compiler from GHC, then build HP from source...
21:10:26 <mzero> assuming you are trying to build HP 2013.2.0.0?   Or are you trying to build the pre-alpha HP from the HP repo
21:10:27 <mzero> ?
21:10:54 <mzero> (side note: compiling GHC from source requires a prior GHC install as well...)
21:10:59 <Algebr> mzero: wait, so I could build from source 7.10 and then build from source the platform? I'm going off what this page says: http://www.haskell.org/platform/linux.html
21:11:08 <Hafydd> <maybefbi> rwbarton, haskell is like C when it comes to memory management. we gotta think on behalf of the GC
21:11:12 <Hafydd> What?
21:11:17 * hackagebot unagi-chan 0.1.0.0 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.1.0.0 (BrandonSimmons)
21:11:27 <Algebr> mzero: seriously? gotta have prior version of the compiler as well??
21:11:27 <maybefbi> Hafydd, oh yeah?
21:11:28 <mzero> Algebr: there is no 7.10, unless you mean HEAD of the GHC repo....
21:11:37 <Algebr> oh, sorry, I meant 7.8
21:11:55 <Hafydd> maybefbi: isn't it more like a language with a GC, like Java?
21:12:11 <rwbarton> um, I meant inits xs !! n = take n xs of course
21:12:13 <mzero> well, no, 2013.2.0.0's packages will almost certainly not compile against 7.8's core packages
21:12:35 <maybefbi> Hafydd, Java GC can handle shitty code.
21:12:37 <mzero> BUT, we are on the cusp of having a 7.8.3, and a new HP 2014.2.0.0 that works against it
21:12:40 <mzero> er, with it
21:13:07 <Algebr> mzero: so if I just compile ghc, I will basically have nothing?
21:13:18 <mzero> Algebr: it depends on what you are trying to do (re. having the compiler)... if you want to compile GHC 7.8 from source -- you need some working GHC installed already
21:14:14 <Algebr> mzero: Say I have nothing haskell related on the machine and I want 7.8. It seems I have to get 7.6 first and then compile 7.8?
21:14:20 <mzero> If you install GHC from the binary distribution, then you can compile Haskell Platform  - so long as you compile a HP that was released to match that compiler (that is the point of the platform - a larger set of packages and tools all known to work and compile together with a specific version of the compiler)
21:14:25 <kazagistar> maybefbi: no, it cannot. Java cannot handle you creating an LinkedList, jamming a hundred million items in it, and then indexing it, jamming it into a second linked list (both still in some object) etc.
21:14:36 <mzero> Algebr: there are binary distributions of 7.8.2
21:14:58 <mzero> is there a reason you want to subject yourself to the 3 hour build of GHC?
21:15:18 <maybefbi> kazagistar, wanna bet? i think i can do it with the -Xmx flag on the JVM
21:15:34 <Algebr> mzero: ah, 3 hours...
21:15:34 <mzero> but yes, if you do, you need to get 7.6... but to build that you'll need 7.0... and to build that you'll need 6.x.... well, you get the picture
21:15:38 <rwbarton> this has nothing to do with the GC
21:16:14 <dwcook> How does one develop GHC if it takes so long to compile?
21:16:21 <mzero> Algebr: the bulk of GHC is written in.... surprise.... Haskell! So you need a working Haskell compiler to compile the GHC Haskell compiler!
21:16:23 <dfeuer> maybefbi, what I said was all wrong. Please listen to rwbarton.
21:16:32 <maybefbi> dfeuer, ok
21:16:41 <rwbarton> it wasn't all wrong, it was just irrelevant in comparison to what came later :)
21:17:06 <dfeuer> rwbarton, it's not clear to me that it had any rightness at all in context.
21:17:13 <Algebr> mzero: I'm just trying to get an update to date version of haskell on debian wheezy
21:17:14 <mzero> dwcook: well, once built the first time, if you twiddle the compiler, you only need to rebuild a bit. AND, a development build is quite a bit faster (2/3rds?) from a production grade build
21:17:24 <Algebr> mzero: and everything is outdated in apt-get
21:17:32 <dwcook> mzero, ah, got it.
21:17:35 <Luke> does anyone know if tibbe's System.Event is still the preferred way to use epoll?
21:17:43 <mzero> Algebr: what do you have now? Is there a 7.6 based Haskell Platform in debian Wheezy's repositories?
21:17:44 <Luke> I want to have a single thread read from multiple sockets
21:17:48 <Luke> what's the best way to do that?
21:17:56 <dwcook> Luke, using multiple threads
21:17:56 <mzero> if so - use it - that's good enough for most things, unless you need 7.8 featues
21:18:05 <Luke> dwcook: yeah
21:18:14 <Luke> dwcook: do you know what epoll is?
21:18:25 <Algebr> mzero: I think its like 7.4. I'm not so worried about the compiler itself, but the libraries.
21:18:34 <rwbarton> yes, it's what ghc will use under the hood to implement your "multiple threads" :)
21:18:59 <Luke> rwbarton: but with a single haskell thread I don't have to merge everything back together
21:19:00 <dwcook> Luke, in generalities. I can tell you that Haskell threads are quite cheap though and the idiom, if there is one, tends to be one or two threads per socket.
21:19:09 <mzero> Algebr: I imagine many things will be fine.... most library maintainers are good about supporting the last two or three major revs back
21:19:30 <Luke> its not about cost of multiple threads. its about not merging all the data
21:19:49 <dwcook> Luke, use a channel, such as Chan or TChan
21:20:23 <Luke> yeah I guess - i have to preserve the socket id in the chan if I want it right?
21:20:33 <rwbarton> you could use multiple TChans
21:20:36 <rwbarton> and wait on all of them
21:20:42 <Luke> oh how do I do that?
21:20:46 <Luke> that might be what I want
21:21:01 <Luke> i don't want to have to loop over all my Chans
21:21:16 <rwbarton> well, it is sort of the same thing
21:21:19 <rwbarton> how many Chans are we talking about?
21:21:33 <rwbarton> or how many sockets rather
21:21:44 <Luke> 5000
21:22:04 <rwbarton> ok you should probably not use 5000 TChans then
21:22:07 <Luke> i think you're missing the point: epoll allows me to constant time select any number of FDs
21:22:27 <rwbarton> sure
21:22:43 <drjeats> hi haskellers, I'm a newbie playing with the new tryhaskell tutorial on the new site
21:22:55 <drjeats> it tells me `Try to get the 'a' value from (10,"abc")`. so I put in `let (_,a:_) = (10, "abc") in a` and I get 'a'
21:22:58 <schell> drjeats: hiya
21:23:18 <drjeats> but the tutorial doesn't advance unless I use `let (_,(a:_)) = (10, "abc") in a`
21:23:27 <drjeats> whoop, caught me midpaste, greeting schell :)
21:23:43 <mzero> Algebr: if you really want, you could install the binary built-for-linux packages from GHC directly: http://www.haskell.org/ghc/download_ghc_7_8_2
21:23:47 <dwcook> drjeats, that sounds like a bug, notify the maintainers, perhaps through the Github repo linked at the bottom.
21:24:20 <drjeats> dwcook: will do, thank you!
21:24:28 <mzero> that 7.8.2... then if you have any cabal installed...    cabal install cabal-install   to update cabal.... and now don't worry abotu the platfomr
21:24:42 <mzero> mind you... 7.8.3 is like coming out this week...
21:24:49 <kazagistar> now for the more fun question, how do you verify they actually got THAT a, instead of a different a?
21:25:07 <dwcook> It sounds like the tutorial does an AST analysis of some sort
21:25:12 <kazagistar> I mean, as a tutorial writer
21:25:13 <Algebr> mzero:  ahh, gonna bite the bullet for 7.4
21:25:44 <mzero> well, that is easiest - if you're just learning Haskell... that'll do you just fine for a few months!
21:26:07 <rwbarton> Luke: it looks like tibbe's System.Event is very similar to the new event manager in GHC (GHC.Event)
21:26:16 <rwbarton> not sure what the history is there
21:26:22 <rwbarton> but maybe you can just hook into the latter directly?
21:26:28 <mzero> Algebr: I see Wheezy's package repo has haskell-platfrom 2012.2.0.0 --- installing that should pull in all you need
21:26:29 <Luke> i know tibbe worked on the new event manager
21:26:33 <Luke> i didn't know how to get access to it
21:27:05 <Luke> rwbarton: this is it... this is what I was looking for. Thanks!
21:27:16 <Luke> what's the deal with GHC.* packages? are those GHC only?
21:27:34 <Algebr> mzero: yea, I'm more at the intermediate stage, just hoping the web frameworks don't expect 7.6+ (rewriting my python web app)
21:27:34 <mzero> why yes, yes they are
21:28:06 <mzero> Yesod tends to need the latest of everything .... Snap might install more smoothly
21:28:25 <Luke> rwbarton: what does "This module should be considered GHC internal." mean?
21:28:26 <Luke> not use?
21:28:27 <mzero> Mind you - there *was* a Yesod that worked on 7.4 smoothly at one point
21:28:50 <rwbarton> Luke: well, it's not guaranteed to be very stable between versions of GHC
21:29:08 <Luke> what higher level stuff uses it that I should be using instead?
21:29:10 <rwbarton> the Officially Supported thing to do is make 5000 threads
21:29:33 <mzero> Luke: Give yourself to the Dark Side... you know you want to use it... import GHC.Internal.*....
21:29:34 <rwbarton> that *is* the IO manager
21:29:36 <Algebr> mzero: Is ubuntu better with keeping up with versions?
21:29:49 <mzero> Algebr: not sure - to be honest!
21:30:08 <Luke> rwbarton: ok makes sense. why are you suggesting TChans instead of Chans?
21:30:24 <mzero> Ubuntu Trusty has Haskell Platform 2013.2.0.0 and GHC 7.6.3 --- that is the current platform
21:30:31 <mzero> (until next month that is!  )
21:30:40 <mzero> so, yes, Ubuntu Trusty is pretty up-to-date
21:30:53 <rwbarton> oh, because you can wait on multiple TChans at once
21:31:04 <Algebr> mzero: ah, thank you so much for all your help. gonna dump wheezy for ubtuntu
21:31:17 <Luke> rwbarton: with what function? and do you know if that uses epoll select underneath?
21:31:19 <mzero> Ubuntu Precise is still where Wheezy is... so be sure it is a new Ubuntu
21:31:23 <rwbarton> but waiting on 5000 TChans isn't efficient
21:31:50 <rwbarton> using readTChan and orElse
21:32:33 <rwbarton> waiting on the TChans doesn't itself use epoll, it uses STM which is a Haskell thing
21:32:38 <rwbarton> it's just a matter of internal thread notification
21:32:49 <rwbarton> the 5000 Haskell threads blocking on sockets will use epoll though
21:33:14 <Luke> rwbarton: I think STM wait is doing a transaction not an optimized multi-fd select
21:33:26 <rwbarton> STM has nothing to do with fds at all
21:33:36 <rwbarton> or any OS concurrency primitive
21:33:40 <Luke> rwbarton: TChan does though
21:33:43 <rwbarton> nope
21:33:52 <Luke> orElse...
21:33:59 <Luke> its in STM
21:34:09 <rwbarton> the 5000 threads could all be scheduled on one OS thread
21:34:26 <Luke> doesn't matter. it's the select that's costly
21:34:32 <rwbarton> there is no select
21:34:37 <rwbarton> however, it is costly
21:34:43 <Luke> using an STM transaction to try to read them all at once is not the same as the select
21:34:58 <rwbarton> I don't really understand why we're talking about both of these things at once
21:35:07 <Luke> my point is using TChan to get orElse doesn't have the same effect as epoll select
21:35:39 <Luke> you're telling me to use TChan to read from multiple channels at once but I don't care about the transaction. I care about the epoll behavior
21:35:40 <rwbarton> you shouldn't use 5000 TChans for this because it will take linear time to set up the transaction every time you wait
21:35:55 <rwbarton> when you said "multiple sockets" I didn't know whether you meant 5000 or like, 5
21:36:01 <rwbarton> right
21:36:10 <Luke> again even with 5: the transaction orElse isn't what I want
21:36:12 <rwbarton> the epoll behavior is totally determined by the threads that are reading from sockets
21:36:23 <rwbarton> it has nothing to do with TChan or STM
21:36:36 <Luke> remember you suggestion TChan to read all the FDs at once like epoll
21:36:47 <Luke> i'm explaining that's not the same kind of "read all at once"
21:37:09 <rwbarton> TChan doesn't read FDs
21:37:15 <AshyIsMe> if anyone feels like critiqueing some haskell code i've just done a pull request to the snaplet-redis project: https://github.com/dzhus/snaplet-redis/pull/7
21:37:16 <Luke> i never said it did
21:37:36 <AshyIsMe> im still a haskell newbie so feel free to rip it to pieces
21:37:38 <Algebr> Seems like Yesod and Snap are the two big, well established web frameworks.
21:38:39 <Luke> afk
21:38:55 <rwbarton> I am totally lost now, sorry.
21:39:04 <rwbarton> I don't know what "the epoll behavior" is.
21:46:20 * hackagebot sized-vector 1.4.1.0 - Size-parameterized vector types and functions.  http://hackage.haskell.org/package/sized-vector-1.4.1.0 (HiromiIshii)
21:56:10 <int3__> kazagistar: I think I figured out how to define a zip-like operation on my Trie, based on the two-level types thing described here http://blog.ezyang.com/2013/05/the-ast-typing-problem/
21:56:18 <int3__> just thought I'd let you know ^_^
22:16:22 * hackagebot hspec-expectations 0.6.0 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.6.0 (SimonHengel)
22:26:23 * hackagebot hspec 1.10.0.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.10.0.1 (SimonHengel)
22:50:46 <johnw> http://www-ps.iai.uni-bonn.de/cgi-bin/exfind.cgi# is pretty awesome
22:50:53 <johnw> it's like djinn on steroids
22:54:57 <trap_exit> is there a cloudhaskell book somewher? i.e. something that shows me how to use cloudhaskell
22:59:52 <augur> @faq can haskell do cloud?
22:59:53 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:59:56 <augur> :(
23:00:07 <augur> WHO RUINED LAMBDABOT?
23:00:23 <corgifex> @nixon
23:00:24 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
23:00:39 <augur> lol
23:01:24 <carter> rwbarton: i like mvars :)
23:02:27 <carter> actually, would 40 cores pulling work chunks that take > 50 milli seconds each from a list in an MVar prevent scaling to have a 40 core perf boost?
23:02:59 <Enigmagic> so 1 mvar fetch per milli?
23:03:14 <Enigmagic> doubt that would be a bottleneck
23:03:17 <carter> yeah
23:03:21 <carter> agree
23:03:43 <carter> even when i made the work chunkier didn't make a big diff
23:03:50 <carter> basically i did forkOn
23:04:09 <carter> with 1 worker thread per capability   0 ... N-1
23:04:16 <carter> but i wasn't seeing linear scaling
23:05:01 <carter> and it wasn't somuch data that the BUS would be saturated
23:05:16 <Enigmagic> i have more problems with the GC than anything else at 12 cores..
23:05:21 <carter> yeah
23:05:35 <carter> lock contention for anything past nursery right?
23:05:36 <Leimy> Haskell platform on the mac... it tells me to install cabal-install, and then it tells me to install cabal-install, and then it tells me....
23:05:40 <Leimy> I like recursion and all
23:05:41 <Leimy> but
23:05:48 <Leimy> how to break the cycle?
23:06:07 <carter> Leimy: ohhh
23:06:10 <carter> check your path
23:06:10 <carter> :)
23:06:17 <corgifex> have you tried installing cabal-install?
23:06:18 <carter> i bet the place it installed to isn't in your path
23:06:20 <Leimy> the path is what Haskell Platform told me to do
23:06:33 <Leimy> it installed the new cabal not in my path
23:06:39 <Leimy> but... why the hell would it do that? :-)
23:06:40 <carter> fix your path
23:06:47 <Leimy> yeah I can fix the path
23:06:52 <Leimy> but then the platform has bad advice
23:06:52 <carter> cool
23:06:55 <Leimy> in it's post install
23:07:07 <Leimy> er its
23:07:08 <carter> Leimy: talk with mzero :)
23:07:08 <Leimy> lol
23:07:12 <carter> and fix your path
23:07:17 <carter> and write a patch for haskell platform
23:07:19 <Leimy> So when it updates again
23:07:21 <carter> venting wont fix it
23:07:24 <Leimy> I have to fix the path again
23:07:25 <carter> fix your path
23:07:26 <carter> no
23:07:28 <Leimy> it's gonna suck every time
23:07:29 <Leimy> yes
23:07:30 <carter> fix your path correctly
23:07:30 <Leimy> I will
23:07:32 <Leimy> no
23:07:36 <Leimy> you're not paying any attention
23:07:41 <carter> ~/.cabal/bin
23:07:42 <carter> :)
23:07:47 <Leimy> /Users/dave/Library/Haskell/bin/cabal
23:07:49 <carter> yes
23:07:53 <Leimy> there is NO .cabal/bin
23:07:59 <carter> there will be :)
23:08:03 <Leimy> there will not be
23:08:05 <carter> rm ~/.cabal/config
23:08:07 <carter> cabal update
23:08:08 <Leimy> this version installs nothing there.
23:08:13 <carter> cabal install cabal-install
23:08:18 <carter> then tehre will be
23:08:21 <Leimy> hmmm
23:08:26 <Leimy> why the heck would I know to do that?
23:08:31 <carter> because i told you
23:08:32 <carter> :)
23:08:42 <Leimy> great
23:08:51 <Leimy> So everyone talk to you :-)
23:08:52 <carter> then check cabal --version
23:08:55 <Leimy> that's a bad answer :-)
23:09:01 <carter> Leimy: nope, you can improve the wiki
23:09:05 <carter> i'm busy improving other things
23:09:11 <Leimy> carter: which wiki?
23:09:15 <Leimy> cuz I will
23:09:15 <carter> idk
23:09:19 <Leimy> oh great
23:09:21 <carter> :)
23:09:21 <Leimy> "the wiki" :-)
23:09:27 <carter> haskell wiki?
23:09:32 <Leimy> ugh
23:09:37 <carter> or the newhaskell web page
23:09:43 <Leimy> well hopefully the next haskell platform will be out soon
23:09:45 <carter> @google cabal-install binary
23:09:46 <lambdabot> http://www.haskell.org/haskellwiki/Cabal-Install
23:09:46 <lambdabot> Title: Cabal-Install - HaskellWiki
23:09:48 <carter> should be out this week
23:09:55 <Leimy> that's great news
23:10:08 <carter> Enigmagic: yeah, i dont see any improvements beyond -N10 / -N15
23:10:18 <carter> i really wanted to have -N30 / -N40 make a difference
23:10:51 <Leimy> carter: so the config doesn't get updated it looks like
23:10:55 <Leimy> and you have to manually clobber it
23:11:00 <Leimy> because I did not change my path
23:11:01 <carter> yup
23:11:03 <Leimy> oof
23:11:07 <Leimy> that's a neat little thing
23:11:11 <carter> Leimy: "echo $PATH"
23:11:13 <carter> whats it say
23:11:13 <Leimy> at least it finally makes sense
23:11:15 <Leimy> my path is right
23:11:23 <carter> proof or dont care
23:11:25 <carter> :)
23:11:29 <Leimy> /Users/dave/Library/Haskell/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/CrossPack-AVR/bin:/Users/dave/opt/bin:/Users/dave/work/plan9/bin
23:11:36 <carter> cool
23:11:43 <Leimy> Oh forgot about CrossPack
23:11:44 <Leimy> lol
23:11:46 <Leimy> arduino :-)
23:11:49 <Leimy> it's been a while
23:11:49 <carter> neat
23:11:54 <carter> and plan9
23:11:57 <Leimy> yes
23:12:00 <Leimy> plan9port
23:12:01 <carter> anyways
23:12:02 <Leimy> I use Acme a lot
23:12:08 <carter> ls ~/.cabal/
23:12:23 <Leimy> config		config.platform	packages
23:12:32 <Leimy> weird characters
23:12:34 <Leimy> hmm
23:12:37 <carter> cool
23:12:42 <Leimy> well it's those two files
23:12:45 <carter> ok
23:12:46 <Leimy> er things :-)
23:12:49 <Leimy> not sure if they're files
23:13:00 <carter> Leimy: i need you to focus please
23:13:06 <carter> or im wandering off :)
23:13:23 <Leimy> carter: it stopped asking me to consistently upgrade already
23:13:31 <carter> http://www.haskell.org/cabal/download.html you can DL a NEW top line cabal-install there
23:13:37 <carter> whats your current cabal --version
23:13:38 <Leimy> only had to clobber that config file
23:13:55 <Leimy> carter: that looks weird
23:13:57 <Leimy> carter: cabal --version
23:13:57 <Leimy> cabal-install version 1.20.0.3
23:13:57 <Leimy> using version 1.20.0.1 of the Cabal library
23:14:03 <carter> cool
23:14:03 <Leimy> hmmm
23:14:07 <Leimy> is that right?
23:14:11 <Leimy> version mismatch?
23:14:11 <carter> yup
23:14:13 <carter> no
23:14:17 <Leimy> ah ok
23:14:20 <carter> cabal install != cabal
23:14:31 <Leimy> right makes sense
23:14:32 <carter> cabal the libs  vs cabal-install the package for the cabal app
23:14:36 <carter> ok
23:14:41 <Leimy> hey thanks
23:14:47 <Leimy> But this was bugging me on and off all week
23:14:48 <carter> now AGAIN do rm ~/.cabal/config ;  cabal update
23:14:51 <Leimy> I hate asking for help :-)
23:15:00 <carter> so you can have a 1.20 style cabal config file
23:15:04 <carter> and you'll have paralle builds
23:15:19 <Leimy> carter: doing that
23:15:21 <carter> note that NEW binaries will start landing in ~/.cabal/bin
23:15:28 <carter> so you'll need to add that to your path
23:15:30 <Leimy> oh that's good
23:15:32 <Leimy> I used to do that
23:15:37 <Leimy> in old Haskell Platforms
23:15:42 <Leimy> it was easier
23:15:45 <carter> yeah
23:15:50 <carter> you don't need to use haskell paltform on mac
23:15:54 <carter> just ghc + cabal
23:16:02 <Leimy> Yeah, I'm thinking I can get away with a new GHC package
23:16:05 <carter> yup
23:16:13 <ivanm> carter: I would suggest a mv ~/.cabal/config{,.bak} in case you want to transfer over configs, rather than just rm'ing it
23:16:25 <carter> ivanm: i dont think Leimy  has any custom stuff :)
23:16:28 * hackagebot ghc-mod 4.1.4 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-4.1.4 (KazuYamamoto)
23:16:35 <Leimy> ivanm: i'm starting from scratch but yes that's good advice normally
23:16:44 <carter> i git version all my config files
23:16:47 <carter> so i can break them :)
23:16:51 <Leimy> carter: that's a great idea
23:17:00 <Leimy> carter: and thanks
23:17:08 <Leimy> ivanm: thank you too
23:39:33 <gamegoblin> How is list concatentation done under the hood? In terms of traversals and allocations.
23:39:51 <carter> the obvious way? :)
23:40:01 <carter> :info (++)
23:40:10 <carter> or do you mean (:)
23:40:14 <gamegoblin> ++
23:40:29 <carter> @source  (++)
23:40:29 <lambdabot> Unknown command, try @list
23:40:38 <kazagistar> @src (++)
23:40:39 <lambdabot> []     ++ ys = ys
23:40:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:40:39 <lambdabot> -- OR
23:40:39 <lambdabot> xs ++ ys = foldr (:) ys xs
23:41:05 <alphonse23_> would you say the most usefully thing to come out of haskell functional programming style is reactive functional programming?
23:41:22 <carter> nope
23:41:31 <gamegoblin> Hmmm ok, it‚Äôs implemented how I thought, then
23:41:41 <carter> the most useful thing is "the code i write that does what I wan"
23:41:46 <gamegoblin> copy xs and make a new version whose last element points to ys
23:41:57 <alphonse23_> but that's not what haskell does
23:41:58 <carter> tyeah
23:42:06 <carter> alphonse23_: nope, its a programing language
23:42:07 <alphonse23_> it generally sucks at doing anything
23:42:10 <carter> it helps me write software
23:42:14 <alphonse23_> aside from just being really interesting a pure
23:42:26 <carter> alphonse23_: tell that to the people paying me to write the codes :)
23:42:27 <trap_exit> the most useful thing about haskell
23:42:30 <alphonse23_> *being really interesting and pure
23:42:39 <trap_exit> is as a test for hiring people
23:42:43 <carter> nah
23:42:49 <alphonse23_> fine carter, what do you make in haskell that's such a big money maker
23:42:49 <antho> I'm sorry, I'm very new. What's the difference between (x:xs) and xs? To my my understanding, they both seem to be a list.
23:42:54 <alphonse23_> I'd really love to hear this
23:43:06 <carter> alphonse23_: i write tools that people need
23:43:08 <alphonse23_> x:xs gives you the head of the list
23:43:10 <carter> its really that simple
23:43:12 <alphonse23_> xs is the whole list i believe
23:43:18 <antho> thank you
23:43:21 <carter> alphonse23_: nope, its Cons
23:43:26 <gamegoblin> I smell a stupid debate brewing
23:43:38 <alphonse23_> ok, then everything except the head
23:43:38 <carter> gamegoblin: ++
23:43:52 <alphonse23_> name the tool carter?
23:44:06 <carter> alphonse23_: cant, NDAs :)
23:44:11 <gamegoblin> alphonse23_: haskell is good at some things and not as good at other things. Everyone has different preferences on the things they value.
23:44:24 <alphonse23_> that is a totally cop out answer
23:44:30 <alphonse23_> *total
23:44:33 <gamegoblin> Too bad
23:44:34 <carter> its also an accurate answer
23:44:43 <carter> trade offs exist
23:44:48 <gamegoblin> You‚Äôre looking to argue with people and that isn‚Äôt what this channel is for
23:44:56 <alphonse23_> I'm not looking to argue dude
23:45:07 <alphonse23_> I'm just trying to have an educated discussion
23:45:10 <knapper_tech> http://lpaste.net/107236
23:45:10 <carter> not really
23:45:13 <kazagistar> alphonse23_: its the only answer, actually. If you use a lot of frp, and it is important to you, then it is the most important thing out of haskell, simple
23:45:13 <alphonse23_> and I wanted to talk about FRP
23:45:28 <knapper_tech> Figuring out this whole error handling thing
23:45:38 <kazagistar> but each person might answer something else
23:45:55 <knapper_tech> What do my '->' arrows indicate in the Left/Right?
23:46:26 <gamegoblin> knapper_tech: do you mean below the ‚Äúcase res os‚Äù ?
23:46:27 <gamegoblin> of*
23:46:30 <knapper_tech> Type error for the curious stands at:   Expected type: Maybe (IO (), b0)
23:46:30 <knapper_tech>       Actual type: Maybe (Maybe (Builder, MIMEType))
23:46:31 * hackagebot yesod 1.2.6.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.2.6.1 (MichaelSnoyman)
23:46:57 <knapper_tech> gamegoblin:   yes, things compile up to the Right case
23:47:10 <knapper_tech> but I'm needing to get squared away on a lot of syntax and things
23:49:35 <gamegoblin> knapper_tech: If you change it to ` Right h -> undefined` does it compile?
23:50:34 <knapper_tech> gamegoblin:       Couldn't match expected type ëEitherT
23:50:35 <knapper_tech>                                     e0 ((->) (HeistConfig m0)) a1í
23:50:35 <knapper_tech>                 with actual type ëHeistConfig n0
23:50:35 <knapper_tech>                                   -> EitherT [String] IO (HeistState n0)í
23:51:09 <gamegoblin> knapper_tech: You have some deeper issues. Unfortunately I don‚Äôt have the packages you‚Äôre using so I can‚Äôt really compile to help on my end
23:51:10 <knapper_tech> What do the arrows in the Left/Right style thing indicate?
23:51:24 <knapper_tech> gamegoblin:  I need probably just to walk backwards and figure out what I know
23:51:35 <levi> Those are part of the case analysis.
23:51:36 <gamegoblin> knapper_tech: if you are unfamiliar with those arrows, you‚Äôve skipped a lot of basic Haskell
23:52:03 <gamegoblin> knapper_tech: not to mean any offense or anything! But you should definitely go skim through Learn You A Haskell for a bit.
23:52:04 <levi> The left of the arrow is the pattern, the right is the expression to evaluate if the pattern matches.
23:52:24 <frerich> knapper_tech: You mean 'a -> b' vs. '(->) a b'?
23:52:42 <gamegoblin> frerich: I think he just means case _ of _ -> arrows
23:52:53 <knapper_tech> and Left/Right is the typical way to handle errors?
23:53:09 <knapper_tech> What type do I expect to match one of Left/Right?
23:53:11 <gamegoblin> knapper_tech: When you want to propogate an error message and handle it yourself (rather than crashing), yes
23:54:48 <frerich> knapper_tech: You can think of 'Either' with its data constructors 'Left' and 'Right' in much the same way as 'Maybe' vs. 'Just' and 'Nothing'. Except that for the 'Nothing' case, you can also pass some payload.
23:56:05 <levi> knapper_tech: How'd you get that code put together?
23:56:28 <knapper_tech> levi:   A cargo plane landed on my island and I built a runway.
23:56:33 <knapper_tech> Am I doing it right?  =D
23:57:29 <knapper_tech> It seems like I -must- do something with the HeistState or else the compiler is not happy.  Simply creating it isn't allowed in the case statement
23:57:49 <levi> I think your res should be a HeistState at that point. You used the `either` function earlier, which is the other way to deal with Either values.
23:58:05 <knapper_tech> there's a possibility that I get a working HeistState for the case statement, therefore I have to deal with it.
23:58:54 <knapper_tech> Am I right?  I have to have my Right branch do something on a HeistState?
23:59:00 <levi> No, you *always* have a HeistState, not an Either. If there was a Left, it would have evaluated the error function.
23:59:12 <levi> You don't want a case there!
23:59:23 <knapper_tech> hmm
23:59:24 <knapper_tech> k
23:59:39 <levi> You did the Church-style case analysis with 'error'
