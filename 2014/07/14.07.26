00:00:02 <prooftechnique> trap_exit: Not to belabor a point, but http://ghcformacosx.github.io
00:00:17 <trap_exit> prooftechnique: lol, this is turning into a sad comedy
00:00:28 <trap_exit> prooftechnique: I've broken xcode
00:00:32 <trap_exit> but I haven't broken my osx install yet
00:00:35 <prooftechnique> How?
00:00:52 <GeraldCode> trap_exit,  being mac isnt cool anymore
00:00:56 <prooftechnique> xcode-select something-or-other should fix it
00:00:57 <GeraldCode> they are even worse than microsoft now
00:01:06 <prooftechnique> GeraldCode: Take it to #haskell-blah
00:01:11 <GeraldCode> lmao
00:01:16 <trap_exit> prooftechnique: unfortunately, I've already rm -rf /Library/Developer
00:01:18 <GeraldCode> sorry
00:01:48 <prooftechnique> trap_exit: Well, I can see how that might break things, yeah :D
00:03:31 <trap_exit> I donm't understand how App store still thinkgs that xcode is installed
00:04:54 <GeraldCode> isnt this more a mac issue than a haskell?
00:05:02 <GeraldCode> not being  dick..not trying to anyway
00:05:09 <trap_exit> sorry
00:05:10 <trap_exit> yes
00:05:13 <trap_exit> I'll stop complaining here
00:05:29 <prooftechnique> trap_exit: #haskell-blah works if you want to continue the conversation
00:05:39 <trap_exit> "I have a broken xcode on osx" is definitely more osx than haskell :-)
00:39:46 <int3__> how do I hook up data.derive to my project?
00:39:57 <int3__> is it merely an import
00:40:04 <int3__> plus those magic comments
00:41:21 <zereraz> hello people, how do I do , floor sqrt (fromIntegral (5::Int)), I saw the type of floor but did not understand it
00:41:47 <zereraz> sqrt reuturns a float
00:41:52 <zereraz> returns*
00:41:59 <zereraz> which floor does not accept
00:42:26 <joelteon> zereraz, floor only takes one argument
00:42:54 <zereraz> oh, that was the problem. I knew floor took one
00:43:01 <zereraz> but I didn't know the brackets problem
00:43:10 <int3__> nvm i figured it out
00:43:17 <jle`> :t floor
00:43:18 <lambdabot> (RealFrac a, Integral b) => a -> b
00:43:31 <zereraz> yeah
00:43:41 <jle`> Float is an instance of RealFrac
00:43:44 <zereraz> I've never seen RealFrac
00:43:45 <jle`> yay! :D
00:44:00 <zereraz> and how is it accepting a tuple
00:44:03 <jle`> oh yeah, the numerical typeclasses hierarchy is a bit weird
00:44:12 <hask3> when do people define functions directly under a type class as opposed to under instances of that type class?
00:44:16 <jle`> zereraz: oh, have you seen typeclasses before?
00:44:36 <zereraz> jle`: I think so, but not read about them in detail
00:44:41 <jle`> floor :: a -> b, where a has to be an instance of the RealFrac typeclass, and b has to be an instance of the Integral typeclass
00:45:07 <jle`> that's what the (RealFrac a, Integral b) => means
00:45:17 <jle`> you might have seen this in the type of (+)
00:45:20 <jle`> :t (+)
00:45:21 <lambdabot> Num a => a -> a -> a
00:45:24 <zereraz> oh
00:45:27 <int3__> zereraz: i.e. it is not a tuple
00:45:27 <jle`> (+) :: a -> a -> a, where a has to be an instance of the Num typeclass
00:45:43 <jle`> it's just...in floor, there are two typeclass constraints to be said
00:45:43 <zereraz> why did they put it in ()
00:45:52 <zereraz> oh
00:45:53 <zereraz> got it
00:46:01 <jle`> how about this function:
00:46:09 <zereraz> also can we use let anywhere?
00:46:10 <jle`> @let myFunc x y = if x > y then x else y
00:46:13 <lambdabot>  Defined.
00:46:14 <jle`> :t myFunc
00:46:15 <lambdabot> Ord a => a -> a -> a
00:46:18 <jle`> oops
00:46:37 <jle`> @let myFunc2 x y = if x > y then (x + y) else (x * y)
00:46:38 <lambdabot>  Defined.
00:46:41 <jle`> :t myFunc2
00:46:42 <lambdabot> (Ord a, Num a) => a -> a -> a
00:46:56 <zereraz> why is this?
00:46:57 <jle`> see, both x and y have to be both Num (because you use + and *) and Ord (because you use >)
00:47:07 <jle`> you compare x and y --- if x > y
00:47:11 <jle`> and then you add/multiply them
00:47:15 <zereraz> so we use > once and ord comes
00:47:17 <jle`> comparison means it has to be an instance of Ord
00:47:22 <jle`> yeah, becuase (>) is only defined for Ord instances
00:47:27 <jle`> and (*) and (+) are only defined for Num instances
00:48:06 <zereraz> in the code I wrote I didn't write the ord typeclass but I can still do <=
00:48:13 <prooftechnique> @info Ord
00:48:14 <lambdabot> Ord
00:48:14 <zereraz> like I don't get error
00:48:21 <jle`> zereraz: you might have used a concrete instance
00:48:26 <prooftechnique> Aww, I was hoping it would spit out some useful info
00:48:28 <jle`> (or an old version of GHC)
00:48:33 <zereraz> jle`: what does that mean
00:48:39 <jle`> prooftechnique: @info spellchecks to @echo or something
00:48:45 <jle`> zereraz: you might want to look up a typeclass reference
00:48:47 <zereraz> countTill :: Int -> Int -> IO String countTill n m =   if n<=m     then do
00:48:53 <zereraz> code snippet
00:49:00 <jle`> zereraz: what is your programming background?
00:49:02 <jle`> have you ever done, say, Java?
00:49:17 <zereraz> little c,c++,java , javascript,python
00:49:18 <zereraz> not much
00:49:29 <jle`> have you heard of java interfaces?
00:49:33 <zereraz> yeah
00:49:41 <zereraz> implements
00:49:45 <prooftechnique> zereraz: Int is a concrete instance of Ord, by the way
00:50:00 <zereraz> prooftechnique: oh, ok got it
00:50:04 <jle`> Ord is "kinda" like an interface.  meaning, if something is Ord, then it defines (>), (<=), etc.
00:50:21 <jle`> typeclasses are actually more powerful than interfaces, but Ord is one case where it's mostly interface-like
00:50:39 <jle`> but in your countTill, you gave it Int, which is an instance of Ord
00:50:40 <zereraz> also I wanted to know can I use 'let' anywhere
00:50:45 <jle`> Int is a type that "implements" <=
00:50:54 <zereraz> yeah got it thanks
00:50:55 <jle`> so you don't need to say that Int is an Ord --- it already is an Ord
00:51:02 <prooftechnique> Whereas `countTill' :: a -> a -> IO String ...` likely wouldn't type-check without the explicit constraints
00:51:07 <jle`> you can't use let anywhere
00:51:28 <jle`> there are two situations you can use let in haskell source
00:51:41 <jle`> the first is as an expression, in places where you can normally use expressions
00:51:49 <prooftechnique> > let x = "world!" in "Hello " ++ x
00:51:51 <lambdabot>  "Hello world!"
00:52:03 <jle`> (let ... in ...) is an expression
00:52:13 <zereraz> ok
00:52:15 <jle`> so anywhere you can use an expression --- like (2 * 4), or [1,2,3], etc., you can use "let ... in ..."
00:52:19 <jle`> the other place is in a do block
00:52:25 <zereraz> ok
00:52:31 <jle`> there is no 'in', in this case
00:52:44 <jle`> let x = 5 in a do block means that 'x' is defined as 5 for the rest of the block
00:52:48 <zereraz> no 'in' in the do case?
00:52:55 <jle`> yeah, the "in" is assumed to be the rest of the block
00:53:05 <jle`> well, do blocks are basically syntactic sugar
00:53:10 <jle`> in the desugaring, the 'in' pops back in
00:53:25 <jle`> @undo do { let {y = 3}; f y }
00:53:25 <lambdabot> let { y = 3} in f y
00:53:32 <zereraz> how can syntactic sugar reduce functionality
00:53:35 <jle`> so that's how a do block desugars
00:53:49 <jle`> do { let {y = 3}; f y } is syntactic sugar for let y = 3 in f y
00:53:53 <prooftechnique> > do {let {x = 5}; return x }
00:53:55 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
00:53:55 <lambdabot>    arising from a use of ‘M654469089299023949410359.show_M6544690892990239494...
00:53:55 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
00:53:55 <lambdabot>  Note: there are several potential instances:
00:53:55 <lambdabot>    instance [safe] GHC.Show.Show a =>
00:53:55 <zereraz> oh we just don't use in
00:53:58 <zereraz> got it
00:53:58 <hask3> when do people define functions directly under a type class as opposed to under instances of that type class?
00:54:04 <hask3> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
00:54:08 <hask3> "Then, we define several functions. It's not mandatory to implement the function bodies themselves, we just have to specify the type declarations for the functions."
00:54:09 <prooftechnique> Whoops, lambdabot's a little old
00:54:11 <hask3> This confuses me
00:54:13 <hask3> Which is why I ask
00:54:15 <systemfault> Does the Monad >> operator has a name?
00:54:19 <prooftechnique> Or too safe, anyway
00:54:26 <prooftechnique> systemfault: Many people say "then"
00:54:35 <zereraz> ok thanks guys
00:54:36 <jle`> systemfault: some people call it fast forward...i call it "and then"...or semicolon, sometimes
00:54:44 <systemfault> Ah ok :)
00:54:51 <jle`> ...probably shouldn't go arund calling it a semicolon
00:55:12 <systemfault> It acts like one though…
00:55:25 <prooftechnique> hask3: A type class describes a set of behaviors that its instances must define, sort of
00:55:27 <jle`> in some sense, yes
00:55:37 <Sirscoots> hi
00:55:41 <jle`> hi Sirscoots
00:55:46 <prooftechnique> hask3: An instance has the implementations for a given type
00:56:06 <Sirscoots> im bored
00:56:10 <prooftechnique> hask3: Though you can also define default implementations in the type class
00:56:25 <Welkin2> systemfault: (>>) is also "blind bind" because it doesn't care about the result being passed into it
00:56:35 <prooftechnique> Welkin2: Ooh, I like that one
00:56:46 <hask3> prooftechnique: ok, so if i define default implementations, can those be either overriden in the implementation or just kept the default (by not implementing it)?
00:56:51 <systemfault> Welkin2: Ah, not bad
00:56:55 <prooftechnique> hask3: Exactly
00:56:59 <hask3> prooftechnique: are you sure?
00:57:00 <Welkin2> :t (>>)
00:57:01 <lambdabot> Monad m => m a -> m b -> m b
00:57:08 <prooftechnique> hask3: Yup.
00:57:08 <jle`> it's not really a bind though
00:57:12 <Welkin2> @src (>>)
00:57:12 <lambdabot> m >> k      = m >>= \_ -> k
00:57:12 <hask3> prooftechnique: ok thanks!
00:57:14 <jle`> it is fundamentally Applicative
00:57:16 <int3__> how do I pass arguments to the underlying program when running via cabal?
00:57:29 <jle`> int3__: you can just add them after, right?
00:57:33 <jle`> cabal run arg1 arg2
00:57:54 <jle`> :t (*>)
00:57:55 <lambdabot> Applicative f => f a -> f b -> f b
00:57:57 <jle`> :t (>>)
00:57:58 <lambdabot> Monad m => m a -> m b -> m b
00:58:24 <int3__> jle`: okay, I actually need to modify my question, sorry -- that seems to work with 'cabal run', how do I do it if I'm running 'cabal bench'?
00:58:45 <int3__> cabal bench -o bench.html gives me cabal: unrecognized 'bench' option `-o'
00:59:03 <int3__> cabal bench -- -o bench.html gives me unrecognized 'build' option `-o'
01:00:03 <jle`> oh
01:00:07 <prooftechnique> int3__: cabal bench --benchmark-options="-o report.html"
01:00:08 <jle`> (>>) is also called sequence in some contexts
01:00:19 <jle`> but not in many, because there's actually a function called sequence in Prelude
01:00:24 <int3__> prooftechnique: ahh, thank you
01:00:40 <jle`> (>>) ma mb    = sequence mb after ma
01:01:23 <jle`> and if you say do { ma; mb; mc } "sequences" ma, then mb, then mc...well, that's just ma >> mb >> mc
01:07:23 <ph88> how does Data Parallel Haskell relate to Control.Parallel ? I saw DPH has functions like zipP, and CP has par monad. Which ones is easy to get started with ?
01:08:44 <zereraz> hello can some one explain foldr
01:08:53 <zereraz> I did not understand it
01:09:56 <Welkin2> > foldr f 0 [1..3] :: Expr
01:09:57 <lambdabot>  can't find file: L.hs
01:10:18 <zereraz> I saw this example Input: foldr (/) 2 [8,12,24,4]  Output: 8.0
01:10:24 * hackagebot xml-pipe 0.0.0.0 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.0 (YoshikuniJujo)
01:10:44 <shachaf> That means: 8 / (12 / (24 / (4 / 2)))
01:10:50 <zereraz> and this Input: foldr (+) 5 [1,2,3,4]  Output: 15
01:11:08 <shachaf> That means: 1 + (2 + (3 + (4 + 5)))
01:11:08 <zereraz> oh
01:11:10 <zereraz> thanks
01:11:19 <zereraz> shachaf: got it thanks
01:11:35 <zereraz> 1 more doubt
01:11:48 <Welkin2> zereraz: when in doubt, read the source code
01:11:57 <Welkin2> it is well documented and written
01:12:12 <zereraz> Welkin2: I saw the definition at http://zvon.org/other/haskell/Outputprelude/foldr_f.html
01:12:16 <zereraz> and got confused
01:12:18 <Welkin2> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#foldr
01:12:25 <Welkin2> that helped me understand folds
01:12:37 <ph88> zereraz: http://learnyouahaskell.com/higher-order-functions#folds
01:12:53 <zereraz> wow, thats awesome, I was not aware of the docs
01:13:07 <zereraz> ok 1 more thing
01:15:24 * hackagebot xml-pipe 0.0.0.1 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.1 (YoshikuniJujo)
01:17:51 <zereraz> map (2`div`)[1..4] this means that divide by 2 to each element of list
01:18:09 <zereraz> how do I do something like divide this element by all the elements of the list
01:18:28 <Welkin2> 2 `div` means you are dividing 2 by something
01:18:35 <jle`> > foldr (/) 2 [8,12,14,4] :: Expr
01:18:36 <lambdabot>  8 / (12 / (14 / (4 / 2)))
01:18:47 <zereraz> oh I just learn't that
01:18:48 <jle`> another neat way to look at how foldr unfolds...it's been useful to me in the past
01:18:54 <zereraz> silly me
01:19:15 <zereraz> thanks!!
01:19:17 <jle`> zereraz: remember, (2 `div`) means it's waiting for something to go on the "missing side"...and you're missing something on the right side
01:19:34 <zereraz> jle`: yeah
01:19:42 <jle`> > foldr (+) 5 [1,2,3,4] :: Expr
01:19:43 <lambdabot>  1 + (2 + (3 + (4 + 5)))
01:19:52 <jle`> > foldl (+) 5 [1,2,3,4] :: Expr
01:19:53 <lambdabot>  5 + 1 + 2 + 3 + 4
01:20:04 <zereraz> wait
01:20:13 <zereraz> foldr returns the resullt
01:20:15 <zereraz> result*
01:20:21 <Welkin2> lambdabot doesn't like when I try to use :: Expr
01:20:22 <zereraz> I want a list of each division
01:20:35 <jle`> you'd use map?
01:20:37 <zereraz> like a list of result of each division
01:20:45 <hiptobecubic> > fmap (2 /) [1.0, 2.0, 3.0]
01:20:45 <jle`> > map (/ 2) [4,6,9,10]
01:20:46 <lambdabot>  [2.0,1.0,0.6666666666666666]
01:20:46 <lambdabot>  can't find file: L.hs
01:20:49 <jle`> > map (/ 2) [4,6,9,10]
01:20:51 <lambdabot>  [2.0,3.0,4.5,5.0]
01:20:59 <jle`> or yeah, depending on what you want
01:21:01 <ph88> jle`: what's that  :: Expr   ?
01:21:14 <jle`> it's from the reflections package i think or something like that
01:21:22 <hiptobecubic> ph88, a data type with a nice Show instance that doesn't reduce
01:21:26 <jle`> it uses a custom Num instance
01:21:28 <Welkin2> > map f [1..3] :: Expr
01:21:30 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
01:21:30 <lambdabot>              with actual type ‘[b0]’
01:21:33 <jle`> so it loads 1 as an Expr
01:21:36 <hiptobecubic> > x :: Expr
01:21:37 <lambdabot>  x
01:21:38 <Welkin2> > map f [1..3] :: [Expr]
01:21:40 <lambdabot>  [f 1,f 2,f 3]
01:21:47 <hiptobecubic> > foldr f [x, y, z] :: Expr
01:21:48 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
01:21:49 <lambdabot>              with actual type ‘[a0] -> [Debug.SimpleReflect.Expr.Expr]’
01:21:52 <ph88> jle`: instead of   (2 `div`)  is it possible to put (div 2)  ?
01:21:55 <hiptobecubic> > (foldr f [x, y, z]) :: Expr
01:21:56 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
01:21:56 <lambdabot>              with actual type ‘[a0] -> [Debug.SimpleReflect.Expr.Expr]’
01:21:59 <Welkin2> ph88: yes
01:22:03 <jle`> and because it's a Num, it also has (+), (/), etc.
01:22:03 <zereraz> how do I find the mod of each element
01:22:05 <hiptobecubic> > foldr f ([x, y, z] :: Expr)
01:22:06 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
01:22:06 <lambdabot>              with actual type ‘[Debug.SimpleReflect.Expr.Expr]’
01:22:09 <hiptobecubic> > foldr f ([x, y, z] :: [Expr])
01:22:10 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr
01:22:10 <lambdabot>                      [Debug.SimpleReflect.Expr.Expr])
01:22:10 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
01:22:10 <lambdabot>  from the context (GHC.Show.Show a)
01:22:10 <lambdabot>    bound by the inferred type of
01:22:13 <hiptobecubic> CHRIST
01:22:16 <zereraz> ok got it
01:22:16 <Welkin2> zereraz: `mod`
01:22:24 <zereraz> yeah did it
01:22:25 <zereraz> thanks
01:22:30 <jle`> hiptobecubic: you can pm lambdabot if you want :)
01:22:43 <hiptobecubic> jle`, it was supposed to be a one-off example
01:22:49 <jle`> ah i c
01:23:01 <trap_exit> Setup: Unrecognised flags: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld  Error during cabal-install bootstrap: Configuring the Cabal package failed.
01:23:04 <trap_exit> this is with xcode5.1.1
01:23:09 <trap_exit> and cabal-install/bootstrap.sh
01:23:26 <Welkin2> trap_exit: mac woes with haskell; they never seem to end
01:23:30 <Welkin2> I just got started with them
01:23:32 <ph88> instead of (`div` 2)  is it possible to write that prefix?  maybe (div _ 2)  ?
01:23:37 <jle`> hiptobecubic: perhaps you are forgetting that foldr takes three arguments?
01:23:43 <trap_exit> Welkin2: I don't know what to be pissed off at
01:23:47 <jle`> ph88: you can use flip
01:23:48 <trap_exit> Welkin2: I love my mbp and I lov ehasell
01:23:50 <hiptobecubic> jle`, Yes forgot zero.
01:23:56 <jle`> but there is nothing from the syntax that would let you do that, no
01:24:00 <trap_exit> I guess this must be what it's like to have two children who hate each other.
01:24:03 <Welkin2> trap_exit: clang
01:24:08 <jle`> there might be a library that gives you an operator that would behave like your _, in that case
01:24:11 <jle`> and i'm sure there is, actually
01:24:15 <hiptobecubic> > foldr f z [x, y] :: Expr
01:24:16 <lambdabot>  f x (f y z)
01:24:27 <trap_exit> is there a way to tell xcode "don't fucking using clang" ?
01:24:34 <ph88> jle`: is that a rare operator ?
01:24:37 <trap_exit> I am a reasonable man
01:24:41 <jle`> ph88: it's not very widely used
01:24:42 <Welkin2> ghc settings?
01:25:00 <ph88> jle`: how to do it with flip ?
01:25:00 <Welkin2> I have had to switch between clang and gcc-4.8 to get stuff working
01:25:04 <jle`> if that case is what you need, you can just say <??> = flip
01:25:14 <jle`> > (flip div 10) 5
01:25:15 <lambdabot>  0
01:25:22 <jle`> > let <??> = flip in (div <??> 10) 5
01:25:23 <lambdabot>  <hint>:1:5: parse error on input ‘<??>’
01:25:26 <jle`> oops
01:25:31 <jle`> > let (<??>) = flip in (div <??> 10) 5
01:25:32 <lambdabot>  0
01:25:36 <ph88> jle`: can you use a function that takes 3 parameters in an infix manor ?
01:25:39 <hiptobecubic> > let € = flip ($)
01:25:40 <lambdabot>  <hint>:1:5: parse error on input ‘€’
01:25:45 <jle`> ph88: yes
01:25:50 <hiptobecubic> > let (€) = flip ($)
01:25:51 <lambdabot>  not an expression: ‘let (€) = flip ($)’
01:25:52 <k00mi> lens has (??)
01:25:57 <hiptobecubic> @let (€) = flip ($)
01:25:58 <lambdabot>  Defined.
01:26:02 <jle`> but you it is only in between the first two arguments
01:26:05 <ph88> jle`: where would the 3rd element go ?
01:26:05 <k00mi> > subtract ?? 3 $ 4
01:26:07 <lambdabot>  -1
01:26:07 * hiptobecubic needs to practice with lammy more
01:26:19 <hiptobecubic> > x € f :: Expr
01:26:21 <lambdabot>  f x
01:26:21 <jle`> ph88: it's in between the first two arguments, the "third one" goes after
01:26:26 <jle`> ph88: but remember, all functions in haskell take one argument
01:26:29 <Welkin2> unicode characters as operators...
01:26:45 <Welkin2> imagine how much fun edwardk can have with chinese
01:26:51 <jle`> so if f :: a -> b -> c -> d, then x `f` y is (c -> d)
01:27:00 <ph88> > (flip \ 10) 5
01:27:01 <jle`> you'd do something like (x `f` y) z
01:27:02 <lambdabot>  <hint>:1:7: parse error on input ‘\’
01:27:10 <ph88> > (flip (\) 10) 5
01:27:11 <lambdabot>  <hint>:1:9: parse error on input ‘)’
01:27:20 <jle`> i don't think \ is a valid character for an operator
01:27:28 <ph88> > (flip / 10) 5
01:27:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
01:27:29 <lambdabot>    arising from a use of ‘M539753828432555186211340.show_M5397538284325551862...
01:27:29 <lambdabot>  The type variable ‘c0’ is ambiguous
01:27:29 <lambdabot>  Note: there are several potential instances:
01:27:29 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
01:27:34 <edwardk> (\) is stolen for lambda
01:27:35 <ph88> > (flip (/) 10) 5
01:27:37 <lambdabot>  0.5
01:27:43 <sivteck> >flip (/) 10 3
01:27:43 <Welkin2> (\) must be reserved because it is a keyword, right?
01:28:18 <jle`> a common operator that is defined as a three-argument function is (.)
01:28:24 <jle`> @src (.)
01:28:24 <lambdabot> (f . g) x = f (g x)
01:28:24 <lambdabot> NB: In lambdabot,  (.) = fmap
01:28:43 <jle`> "three-argument", of course
01:28:45 <quchen> ^ that last line should probably be changed.
01:28:50 <int3__> weird, I'm getting rather bimodal results from my criterion benchmarks. seems like the GHC runtime is wising up halfway through the benchmark execution
01:29:11 <oakwhiz> > let (💩) = (+)
01:29:12 <lambdabot>  not an expression: ‘let (💩) = (+)’
01:29:18 <zereraz> how do I mod 1 element by a whole list one element at a time and return a list(this is what I wanted to know before and got confused)
01:29:23 <Welkin2> why is that a smiling poop?
01:29:35 <jle`> emojis, i presume
01:29:41 <oakwhiz> > 2 💩 2
01:29:43 <lambdabot>  Not in scope: ‘💩’
01:29:59 <prooftechnique> zereraz: Can you give an example of how you would call the function and the expected output?
01:30:02 <jle`> zereraz: can you give an example input and an example output?
01:30:05 <jle`> oh
01:30:07 <zereraz> like, yeah
01:30:07 <jle`> i type too slow
01:30:13 <zereraz> 1 sec
01:30:20 <ph88> how is (.) a three-argument function ?
01:30:31 <jle`> ph88: look at how it's defined
01:30:33 <zereraz> 5 divided by all elements of [1..5]
01:30:33 <prooftechnique> jle`: I definitely thought I had just written that twice for a second
01:30:36 <zereraz> of modded
01:30:38 <jle`> (f . g) x = ...
01:30:38 <ph88> :t .
01:30:39 <lambdabot> parse error on input ‘.’
01:30:45 <ph88> :t (.)
01:30:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:30:47 <jle`> it's an operator with "three arguments"
01:30:48 <zereraz> basically I am using it to find prime
01:31:05 <Welkin2> what would be a fun experiment to write a language using only chinese characters as operators
01:31:09 <zereraz> 5 mod [1..5]
01:31:13 <jle`> a (b -> c), an (a -> b), and an a
01:31:14 <Welkin2> that would be*
01:31:14 <ph88> jle`: but i only saw it used between functions   map . sum  or something like that
01:31:14 <zereraz> something like that
01:31:32 <Welkin2> operators/keywords
01:31:40 <jle`> ph88: well yeah, that's becuase all haskell functions are really only one argument functions...i'm using some loose reasoning
01:31:46 <jle`> zereraz: what would the output be?
01:31:50 <jle`> ph88: look at the type signature
01:31:54 <jle`> :t (.)
01:31:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:32:02 <jle`> one can chose to leave it like that
01:32:10 <jle`> but one can also see the parentheses around (a -> c)
01:32:18 <jle`> (b -> c) -> (a -> b) -> (a -> c)
01:32:18 <oakwhiz> the universe is a function with arity zero
01:32:25 <jle`> a function that takes two functions and returns a third one
01:32:43 <jle`> so if you use (.) on two functions, you get a function
01:32:45 <zereraz> 5 mod [2..5] output [1,2,1,0]
01:32:53 <jle`> if you use (.) on two functions and a value, you get a value
01:33:04 <jle`> :t (+2) . (*4)
01:33:05 <lambdabot> Num c => c -> c
01:33:08 <zereraz> [5mod2,5mod3,5mod4,5mod5]
01:33:16 <ph88> > let (<??>) = flip in (<??> / 10) 5
01:33:17 <lambdabot>  <hint>:1:28: parse error on input ‘/’
01:33:20 <jle`> :t ((+2) . (*4)) 6
01:33:21 <lambdabot> Num c => c
01:33:27 <ph88> > let (<??>) = flip in (<??> (/) 10) 5
01:33:28 <lambdabot>  Could not deduce (GHC.Num.Num (a -> (a0 -> a0) -> c))
01:33:28 <lambdabot>    arising from the ambiguity check for ‘e_1105’
01:33:28 <lambdabot>  from the context (GHC.Num.Num (a -> (a1 -> a1) -> c),
01:33:28 <lambdabot>                    GHC.Real.Fractional a1)
01:33:28 <lambdabot>    bound by the inferred type for ‘e_1105’:
01:33:38 <jle`> zereraz: so you want [5 `mod` 2, 5 `mod` 3, 5 `mod` 4 ... ]
01:33:43 <zereraz> yeah
01:33:48 <jle`> that sounds like you just want to map (`mod` 2)
01:33:57 <zereraz> no
01:34:00 <jle`> oops
01:34:04 <jle`> map (5 `mod`)
01:34:07 <zereraz> I want the 2 to come from list
01:34:09 <jle`> which is the same as (mod 5)
01:34:11 <jle`> sorry
01:34:24 <zereraz> no problem
01:34:32 <prooftechnique> > map (5 `mod`) [2..5]
01:34:33 <lambdabot>  [1,2,1,0]
01:34:40 <jle`> [2,3,4] -> [(5 `mod`) 2, (5 `mod`) 3, (5 `mod`) 4]
01:34:55 <jle`> [2,3,4] -> [f 2, f 3, f 4]
01:35:03 <jle`> where f = (5 `mod`)
01:35:10 <zereraz> I feel like an idiot
01:35:10 <zereraz> ok
01:35:12 <prooftechnique> @let modThing n = map (n `mod`) [2..n]
01:35:12 <zereraz> thanks
01:35:13 <lambdabot>  Defined.
01:35:15 <jle`> zereraz: you aren't an idiot! :)
01:35:16 <prooftechnique> > modThing 5
01:35:18 <lambdabot>  [1,2,1,0]
01:35:26 <jle`> this is not easy for many people
01:35:33 <zereraz> thanks
01:36:37 <Welkin2> :t extend
01:36:38 <lambdabot> Not in scope: ‘extend’
01:36:44 <prooftechnique> jle`: I was playing with a dastardly abuse of scanl :D
01:36:52 <jle`> rly
01:37:13 <jle`> oh, for this?
01:37:16 <prooftechnique> Yeah, haha
01:37:24 <jle`> you can do this with a mapAccum too ;)
01:37:27 <jle`> in a silly way.
01:37:36 <Welkin2> :t extract
01:37:37 <lambdabot> Not in scope: ‘extract’
01:37:43 <prooftechnique> I was going for maximum silliness
01:37:54 <jle`> :t scanl
01:37:55 <Welkin2> no comonads in lambdabot?
01:37:55 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
01:38:02 <jle`> Welkin2: i think they are qualified
01:38:27 <jle`> :t Control.Comonad.extend
01:38:28 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
01:38:41 <jle`> such arrows, such backwards
01:39:17 <jle`> :t (=<<)
01:39:18 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:39:24 <jle`> neato
01:39:33 <edwardk> IIRC Control.Comonad doesn't pass safe haskell for lambdabot
01:39:49 <ph88> jle`: i am trying your example of . with 3 arguments. The type works but why doesnt it print a number ?
01:39:51 <jle`> is it too dangerous to our minds
01:39:55 <ph88> > (+2) . (*4) 6
01:39:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
01:39:56 <lambdabot>    arising from a use of ‘M793952058950365244211638.show_M7939520589503652442...
01:39:56 <lambdabot>  The type variable ‘a0’ is ambiguous
01:39:56 <lambdabot>  Note: there are several potential instances:
01:39:56 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
01:40:04 <jle`> ph88: association is weird
01:40:15 <jle`> that's parsed as (+2) . ((*4) 6)
01:40:21 <quchen> int-e: ping?
01:40:27 <jle`> you want ((+2) . (*4)) 6
01:40:44 <prooftechnique> ph88: Or (+2) . (*4) $ 6
01:40:45 <ph88> why is the precendence like that ?
01:40:51 <jle`> function precedence is highest
01:40:56 <jle`> function application
01:41:09 <jle`> so ((*4) 6) binds tighter than any operator
01:41:11 <merijn> ph88: Because haskell precedence is as follows: 1-9 operators, 10 function application, 11 record syntax
01:41:17 <merijn> higher == binds tighter
01:41:24 <prooftechnique> ph88: And ($) is just function application with the lowest possible precedence
01:43:21 <Welkin2> (&) is reverse function application?
01:43:26 <Welkin2> :t (&)
01:43:27 <lambdabot> a -> (a -> b) -> b
01:43:36 <angerman> so (>>= f) is \x -> f >>= x, right?
01:43:39 <jle`> yeah...it's only idiomatic in certain places
01:43:44 <jle`> angerman: not quite
01:43:45 <merijn> angerman: No
01:43:55 <jle`> angerman: in section syntax, it's waiting for something to fill in the "missing" side
01:44:03 <merijn> angerman: (>>= f) is "\x -> x >>= f"
01:44:08 <ph88> ok got that noted
01:44:09 <jle`> (/ 2) --> there is a number missing on the left hand side
01:44:12 <jle`> > (/ 2) 10
01:44:14 <lambdabot>  5.0
01:44:24 <angerman> merijn, jle`: ok, so I got the side wrong.
01:44:32 <jle`> (10 /) --> there is a number missing on the right ahnd side
01:44:34 <jle`> > (10 /) 5
01:44:35 <lambdabot>  2.0
01:44:36 <merijn> angerman: "(f >>=)" or "(>>=) f" are what you thought
01:44:44 <Welkin2> how is (&) commonly used?
01:44:51 <jle`> (>>= f) --> there is something missing (an m a) on the left hand side
01:45:01 <jle`> Welkin2: it's mostly used with other lens operators and combinators
01:45:09 <jle`> by mostly i mean really only
01:45:15 <Welkin2> I have seen it to supposedly make a pipeline easier to read from right to left in a do block
01:45:41 <ph88> how does Data Parallel Haskell relate to Control.Parallel ? I saw DPH has functions like zipP, and CP has par monad. Which ones is easy to get started with ?
01:45:43 <angerman> merijn: yes. I considerd (>>= f) to be the partial application of f to >>=. So I got the syntax mixed up :D
01:46:33 <jle`> Welkin2: you might have, but i don't think it's commonly accepted
01:46:40 <jle`> or used that way
01:47:57 <jle`> and it's weird to import Control.Lens only to have (&) anyway >_>
01:48:11 <jle`> i mean...that's a lot of dependencies for a flip ($)
01:48:13 <Welkin2> it's just flip ($)
01:48:31 <jle`> yeah, flip ($) also shows up as (|>)
01:48:42 <jle`> i think thats how it is in Elm's base?
01:48:46 <Welkin2> yes
01:48:48 <jle`> diagrams also has its own flip ($) as (#)
01:48:50 <Welkin2> I see that in Elm
01:48:54 <Welkin2> is that also in haskell?
01:48:58 <jle`> no, it isn't
01:49:03 <jle`> i've seen people define it here and there
01:49:17 <jle`> but in general in haskell we like to apply functions in normal order
01:49:36 * jle` hopes nobody notices the inherent begging of the question
01:49:44 <edwardk> jle`: in 7.10 (&) is going in Data.Function
01:49:49 <jle`> noooooo ;_;
01:49:54 <Welkin2> edwardk: bastard!
01:49:55 <isomorpheous> :t (&)
01:49:55 <lambdabot> a -> (a -> b) -> b
01:49:57 <angerman> :t liftM
01:49:58 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:49:59 <jle`> you did this didn't you
01:50:00 <jle`> :'(
01:50:03 <edwardk> its in a module you have to explicitly import
01:50:18 <jle`> yes but now people are going to be like 'if it's in base then it must be an ok idiom to use'
01:50:24 <jle`> 'for any which situation'
01:50:34 <edwardk> jle`: actually first time it came up i pulled the proposal, the second time i finally let it go to the core libraries committee and abstained and it passed unanimously
01:50:47 <Welkin2> head and last are in prelude and they are not okay to use
01:50:49 <edwardk> so i'm if anything reluctantly letting it go through
01:50:54 <jle`> ah ok
01:50:59 <edwardk> folks like it.
01:51:01 <jle`> :/
01:51:25 <edwardk> it isn't like it is going in Prelude ;)
01:51:34 <jle`> im crushed
01:51:41 <Welkin2> I think (|>) and (<|) look nicer
01:51:44 <jle`> maybe i should just sign off now
01:51:49 <jle`> my spirit is broken
01:51:49 * pantsman- prepares the troll post to submit to reddit: "Haskell FINALLY lets you apply functions in the right order"
01:52:07 <quchen> edwardk: Oh wow, what happened so that (&) was accepted? Library committee steam hammer?
01:52:24 <edwardk> & reads better in many ways  f & x .= 1 & y .= 2   -- can be read as 'f and x = 1 and y = 2'  -- in the colloquial and then sense
01:52:26 <jle`> I GUESS i can rationalize that (&) makes more sense with lambda syntax than ($) does
01:52:39 <jle`> x & \y -> y * 2
01:52:42 <quchen> edwardk: Oh I missed the line where you said exactly that. Nevermind.
01:52:43 <jle`> it lines up with the arrow
01:52:56 <jle`> which is the same reason why i was able to justiy (>>=) to myself
01:53:07 <edwardk> quchen: it came up again and again and 6 months ago someone started trotting it out again, so i put it forth to the committee and explicitly recused myself from the process
01:53:08 <jle`> the left-to-right stuff aligns much more with lambda syntax
01:53:48 <jle`> i guess if people are consistent i don't mind too much, but...another problem is that there really isn't a flip (.) that doesn't look like noise
01:53:52 <quchen> edwardk: When (&) lands you have a grace period of five weeks until the discussions about flipping (.) start
01:54:11 <quchen> I take that back. You have a grace period of minus 20 seconds, starting now.
01:54:16 <jle`> lol
01:54:18 <edwardk> lens internally avoided the |> idiom because it is a bad haskell cultural fit in some ways. we have <|> for very very different purposes, and a history of using |> and <| for cons like operators
01:54:25 <jle`> we have (>>>)
01:54:29 <jle`> but it's pretty noisy
01:54:34 <darthdeus> is there a way to tell emacs to render :: and -> and => using the unicode characters in haskell mode?
01:54:34 <edwardk> we have flip (.) = (>>>) already
01:54:35 <angerman> :t (,)
01:54:35 <jle`> esp compared to (&)
01:54:36 <lambdabot> a -> b -> (a, b)
01:54:36 <edwardk> done
01:54:52 <edwardk> there isn't another 1 character operator you can steal that won't get you lynched
01:55:02 <jle`> yeah...soultion = no (&) ^_^
01:55:07 <quchen> ☃ -- edwardk
01:55:10 <jle`> lol
01:55:21 <jle`> if anything it'll encourage x & f & g & h
01:55:23 <edwardk> & was 'poisoned' by the fact that its natural pair (|) as seen by C++ types isn't available due to guards
01:55:39 <quchen> Good thing this isn't C.
01:55:42 <edwardk> so folks mostly didn't use it
01:55:46 <jle`> and we don't like h $ g $ f $ x
01:55:51 <edwardk> you don't
01:55:53 <edwardk> i use it all the time
01:56:06 <Welkin2> when people use non-ascii characters in their code, do they have an extension for their text editor that converts it automatically?
01:56:07 <edwardk> i tend to prefer $ to (.) because the former behaves better in the presence of rank-n types
01:56:18 <zereraz> what does parse error on input if mean?
01:56:19 <jle`> you don't prefer h . g . f $ x ?
01:56:20 <jle`> ah
01:56:20 <edwardk> i have enough non-trivial rank-n type code that that makes a huge difference, so i just use it most of the time
01:56:36 <jle`> but it's a bit easier to equationally-reason for new peops
01:56:38 <edwardk> i don't use the cale-ism of h . g . f $ x
01:56:38 <quchen> Welkin2: Depends on where you use non-ASCII. In identifiers it's just fine, for built-in operators there's an extension. A bad extension.
01:56:41 <Welkin2> I don't understand how anyone could write like that, but I have seen code on github using non-ascii versions of (->) and (::)
01:56:47 <jle`> to be able to factor out the (h . g), hg . f $ x
01:56:53 <jle`> and see that function composition is monoidal
01:56:59 <jle`> i always used it as a teaching point
01:57:06 <int3__> what do you guys usually use for deriving stuff like NFData? I was trying Data.Derive but it seems to choke on a lot of language extensions, and doesn't provide a way to tell it which extensions are in use
01:57:34 <jle`> int3__: can't you just derive Generic and write the blank instance?
01:57:41 <edwardk> i'm happy to teach it, but i'm also used to running into things like newtype Nat f g = Nat { runNat :: forall a. f a -> g a } -- now when i want to compose in nat3 = Nat . Nat . Nat $ f -- i'm dead in the water
01:57:52 <edwardk> and need to switch
01:58:03 <int3__> jle`: oh uh let me try that
01:58:03 <quchen> int3__: deepseq-generics is a good start
01:58:12 <int3__> thanks!
01:58:31 <jle`> ok
01:58:38 <jle`> haskell is going to be really different in a year or two
01:58:42 <quchen> "instance NFData a where rnf = genericRNF", done
01:58:56 <jle`> quchen: wait, the blank instance doesn't work? >_>
01:59:04 <edwardk> jle`: it always is. that is what i love about this place
01:59:16 <quchen> jle`: No, as that would require you to modifify the NFData class to add the default cases
01:59:16 <zereraz> what does parse error on input if mean here http://lpaste.net/108177 line 32
01:59:25 <lfairy> jle`: since default implementations need to be defined in the class, probably not
01:59:30 <edwardk> 2 years ago lens didn't exist. polykinds didn't exist, constraint kinds were just coming around
01:59:40 <quchen> jle`: As a third-party lib you have to write the whopping boilerplate that is `rnf = genericRNF`
01:59:48 <jle`> lfairy: there aren't any default implementation for NFData?
02:00:02 <quchen> jle`: There are!
02:00:05 <edwardk> i've literally spent the last 3 weeks writing code that uses little _but_ those features ;)
02:00:08 <quchen> rnf x = x `seq` ()
02:00:13 <lfairy> quchen: ^
02:00:14 <jle`> well...a bunch of libaries allow blank instances
02:00:17 <jle`> like Binary, Serialize
02:00:21 <jle`> and they just work(tm)
02:00:53 <jle`> edwardk: yeah, but i think (&) becoming idiomatic in normal everyday code is going to be a more fundamental shift
02:01:11 <jle`> you're not going to be seeing new people use polykinds, lens, and constraint kinds on their first or second haskell project
02:01:29 <edwardk> i don't think it'll be that big a deal really. they need to find it down in Data.Function alongside 'on'
02:01:45 <edwardk> it'll see a bit more use than on but meh
02:01:46 <jle`> mark my word, this is my prophecy
02:01:55 <jle`> (&) will be as common as ($)
02:01:59 <jle`> within two years
02:02:03 <Welkin2> false prophet!
02:02:11 <zereraz> ?
02:02:14 <jle`> imma come back and tell you guys i told you so
02:02:15 <Welkin2> lambdabot is our true savior
02:02:20 <edwardk> and my prophecy is that its used by maybe 10-15% of users now, and i expect you'll get a 10-15% uptick.
02:02:25 <int3__> I am using simple lens stuff in my first haskell project, fwiw :P it's pretty convenient for tuple stuff, plus some libraries already come with lenses supplied
02:02:28 <supki> edwardk: will we have <&> also in base?
02:02:30 <Qfwfq> jle`: http://predictionbook.com Remember to describe methodology in advance.
02:02:37 <supki> I find it more useful than &
02:02:41 <edwardk> (<&>) was not included in the proposal
02:02:46 <supki> =(
02:02:48 <edwardk> it has more bikeshedding points
02:02:58 <edwardk> the fixity it uses is hard to defend, and hard to change
02:03:05 <zereraz> help someone
02:03:10 <jle`> thank you Qfwfq
02:03:16 <Welkin2> @src (<&>)
02:03:16 <lambdabot> Source not found. You untyped fool!
02:03:24 <Welkin2> @info (<&>)
02:03:24 <lambdabot> (<&>)
02:03:25 <jle`> zereraz: can you post the full error?
02:03:25 <edwardk> pretty much anything tried there is going to generate more heat than motion
02:03:27 <trap_exit> so I just installed yesod ... and am now wondering -- wtf, is yesod even Haskell?
02:03:31 <trap_exit> it seems to be it's own DSL
02:03:35 <jle`> Welkin2: (<&>) is flip (<$>)
02:03:44 <trap_exit> in its own DSL land, with it's own language
02:04:08 <jle`> zereraz: you're missing an `in`
02:04:13 <jle`> zereraz: let ... in ...
02:04:25 <zereraz> I tried to put do
02:04:33 <zereraz> what do I do in 'in'
02:04:41 <jle`> let (bindings) in (expression)
02:04:42 <zereraz> I have put everything in let
02:04:43 <edwardk> it has fixity set to match up with (>>=) for various reasons. it fits in a (>>=) chain well as a result, and it wasnt going to work with the (<$) (<$>) (<*) (<*>)  chain stuff anyways, but then you have to explain why its lower fixity than its counterpart.
02:04:46 <jle`> > let x = 4 in x = 5
02:04:48 <lambdabot>  <hint>:1:16: parse error on input ‘=’
02:04:53 <jle`> > let x = 4 in x + 5
02:04:55 <lambdabot>  9
02:05:08 <edwardk> but for folks who haven't done an exhaustive amount of programming the other higher fixity seems more natural
02:05:17 <zereraz> can I declare in 'in'
02:05:18 <edwardk> er an exhaustive amount of programming with it
02:05:18 <jle`> zereraz: do blocks are only for sequencing & stuff for monads like IO
02:05:29 * hackagebot LambdaHack 0.2.14 - A roguelike game engine in early development  http://hackage.haskell.org/package/LambdaHack-0.2.14 (MikolajKonarski)
02:05:36 <zereraz> but I don't know what to use 'in' in mine
02:05:38 <jle`> zereraz: let (declarations) in (expression)
02:05:57 <jle`> so here you are doing let (limit = blah, etc.) in if ((...)) then ... else...
02:06:12 <zereraz> oh
02:06:14 <zereraz> in if
02:06:44 <angerman> The more I read about Functors, Applicatives and Monads the more confused I become. I guess that's just normal.
02:06:58 <jle`> edwardk: introducing something in base will cause a decent jump in usage, i think...also, this is something that new people from other languages have been clamouring and asking for for a long time, and the only thing stopping them was that it wasn't in base.  sometimes that doesn't even stop them; they define their own
02:07:12 <jle`> edwardk: i think there are floodgates waiting to be opened.
02:07:13 <ph88> how can i print something then wait 2 seconds then print something else ?
02:07:14 <trap_exit> dude
02:07:14 <trap_exit> yesod is awesome
02:07:19 <trap_exit> yesod is brillaitn genius
02:07:26 <edwardk> jle`: good. more lens users ;)
02:07:27 <jle`> ph88: you can use threadDelay :: Int -> IO (), or something like that
02:07:53 <zereraz> jle`: after compiling I am getting error because of using floor and sqrt there, why is that wrong
02:07:56 <ph88> ok i will search on haskell threadDelay
02:08:11 <jle`> zereraz: you are applying sqrt to an Int
02:08:12 <zereraz> jle`: like why can't I do floor and sqrt there
02:08:19 <jle`> :t sqrt
02:08:20 <lambdabot> Floating a => a -> a
02:08:31 <jle`> if you go to ghci and type :i Floating, you'll see that Int isn't an instance
02:08:38 <Welkin2> angerman: sure, it's fine. you'll get used to it once you start using them in your code
02:08:55 <jle`> edwardk: :o
02:08:55 <Welkin2> angerman: just jump right in and play with functors, monads, etcs
02:09:12 <jle`> anyways my prophecy is locked in stone so i'm just going to have to wait two years before telling you guys i told you so
02:09:19 <jle`> :)
02:09:30 <angerman> Welkin2: after all it's just a Data Type, what's part of a Type Class, right?
02:09:47 <jle`> Welkin2: Functor is a typeclass...not a data type
02:09:50 <jle`> oops, angerman ^^
02:10:00 <ph88> jle`: this is maybe easier then thread delay ?   http://www.haskell.org/pipermail/haskell-cafe/2009-February/055473.html
02:10:35 <lfairy> ph88: uh, just use threadDelay
02:10:41 <jle`> "Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead."
02:10:52 <ph88> ok ok
02:10:52 <jle`> note the date on that post, btw :)
02:11:49 <angerman> jle` what I ment was. Data Type X is a Funtor/Applicative/Monad, if X is made part of the Functor/Applicative/Monad Type Class and does not violate the respective laws.
02:12:21 <zereraz> jle`: I just put n::Int in () and it worked
02:12:33 <jle`> zereraz: yay!
02:12:49 <jle`> zereraz: yes, before you were using ((fromIntegral n) :: Int)
02:12:55 <jle`> zereraz: so you were basically turning n into an Int
02:12:58 <jle`> and trying to sqrt that Int
02:13:23 <Welkin2> I love telling people about haskell. They get so excited about it and want to start learning it immediately.
02:13:35 <zereraz> I actually do not understand that line
02:13:43 <zereraz> jle`: I wrote it by looking some where
02:13:46 <pjdelport> angerman: That's right. Those things are probably easier to understand if you ignore Monad at first and really focus on Functor first, then Applicative.
02:13:54 <jle`> :t fromIntegral
02:13:55 <lambdabot> (Num b, Integral a) => a -> b
02:13:59 <pjdelport> and then Monad.
02:14:06 <pjdelport> Each of them builds on the previous.
02:14:25 <jle`> fromIntegral turns an Integral (an instnace of the Integral typeclass), like Int, into an instance of the Num typeclass, like Double
02:14:31 <zereraz> jle`: it worked because it becomes fromIntegral ?
02:14:33 <jle`> in your case, fromIntegral :: Int -> Double
02:14:45 <zereraz> jle`: ok understood
02:14:48 <angerman> pjdelport: definately1
02:14:56 <zereraz> 1 more thing, can you review the code
02:15:13 <zereraz> jle`: its my first code in haskell that has like 30+ lines
02:15:13 <jle`> zereraz: i would probably prefer guards over explicit if/thens
02:15:24 <zereraz> jle`: I need to learn those
02:15:27 <Welkin2> yes
02:15:38 <Welkin2> don't use if/then/else
02:15:43 <Welkin2> that is not idiomatic
02:15:47 <jle`> zereraz: have you been using some sort of guide/course for haskell?
02:15:51 <zereraz> code here http://lpaste.net/108177
02:16:05 <zereraz> jle`: not really
02:16:18 <Welkin2> zereraz: use LYAH
02:16:20 <jle`> zereraz: hm.  i might recommend you use one, it'll help you fill in these small holes like guards and let...in...'s
02:16:21 <Welkin2> @LYAH
02:16:22 <lambdabot> Unknown command, try @list
02:16:25 <zereraz> jle`: I know the resources but I am never able to learn from 1 source
02:16:28 <Welkin2> @google LYAH
02:16:29 <lambdabot> http://learnyouahaskell.com/
02:16:29 <lambdabot> Title: Learn You a Haskell for Great Good!
02:16:32 <jle`> @where lyah
02:16:33 <lambdabot> http://www.learnyouahaskell.com/
02:16:38 <zereraz> Welkin2: yeah I know all good haskell resources
02:16:51 <zereraz> I just am not able to concentrate and learn from 1 sources
02:16:58 <zereraz> *source
02:17:06 <Welkin2> zereraz: it is a fun book to read just on its own
02:17:09 <zereraz> so I just decide to code and solve problems
02:17:12 <Welkin2> like a bedtime story
02:17:22 <Welkin2> I used it as a bedtime story for a while
02:17:28 <jle`> zereraz: also, i'm not sure that IO String really is meaningful
02:17:31 <jle`> are you doing anything with the String?
02:17:33 <zereraz> Welkin2: I tried , but I am not able to continue and drift off
02:17:33 <jle`> why not just IO () ?
02:17:34 <Welkin2> then I started using the typeclassopedia to put me to sleep
02:17:45 <Welkin2> in a good way!
02:18:00 <zereraz> jle`: it is because I am printing not prime
02:18:09 <jle`> :t print
02:18:10 <lambdabot> Show a => a -> IO ()
02:18:14 <jle`> print doesn't return anything
02:18:21 <jle`> (also, you probably want putStrLn)
02:18:38 <jle`> print doesn't return anything; it is an IO action that produces no result.  well, except ()
02:18:43 <ph88> can i write this problem in a way to not use a do block ?   http://lpaste.net/7998932265843294208
02:18:53 <lfairy> zereraz: either replace 'return "end"' with 'print "end"', or 'return ()'
02:19:06 <jle`> zereraz: you can also use when...i'm adding an annotation
02:19:07 <zereraz> lfairy:  ok
02:19:11 <jle`> ph88: you can use sequence if you want
02:19:13 <lfairy> zereraz: then the function will be 'IO ()'
02:19:15 <quchen> ph88: Yes, any 'do' block can be rewritten in terms of >>=, >>, and let.
02:19:20 <Welkin2> zereraz: LYAH has short tutorials embedded inside that teach you how to write scripts that do things like take input and print out to the terminal
02:19:25 <jle`> but this is one of the neat advantages of the do block notation
02:19:39 <ph88> so it's best to use the do block in this case ?
02:19:58 <Athiwat> What does liftIO do in a do block?
02:20:03 <Athiwat> :t liftIO
02:20:04 <lambdabot> MonadIO m => IO a -> m a
02:20:21 <zereraz> so i change the IO String to IO()?
02:20:32 <quchen> ph88: In this case it's the best readable way to write it. But it's a good exercise to write everything in "do" and in ">>=" form in the beginning until the correspondence is obvious to you.
02:20:36 <lfairy> zereraz: yep
02:20:49 <quchen> ph88: RWH has a chapter talking about "desugaring of do blocks" where it mentions the translation laws.
02:20:57 <zereraz> then why was it working for IO String?
02:21:07 <jle`> zereraz: it was working because you returned an IO String
02:21:07 <ph88> thx
02:21:12 <jle`> but the String is a bit meaningless/useless/redundant
02:21:13 <lfairy> zereraz: because before, you were returning "end" rather than printing it
02:21:16 <Athiwat> Oh wow, I can talk to lambdabot personally
02:21:28 <zereraz> wlhlm: I actuallly got bored because I was reading basics again and again, I'
02:21:33 <lfairy> zereraz: that fixed it to String rather than ()
02:21:36 <zereraz> I'll retry
02:21:56 <zereraz> lfairy: so I shoud now return ()?
02:22:04 <lfairy> zereraz: yeah, that'll work
02:22:31 <zereraz> it worked!!
02:22:36 <zereraz>  thanks
02:22:38 <zereraz> thanks everyone
02:22:39 <lfairy> zereraz: :)
02:22:54 <zereraz> its generating primes
02:23:00 <Welkin2> a sieve?
02:23:02 <zereraz> between 2 numbers
02:23:13 <zereraz> Welkin2: this is without sieve
02:23:25 <zereraz> Welkin2: I will try to implement that next
02:23:31 <zereraz> this is just practice
02:23:37 <zereraz> and fun
02:25:34 <jle`> zereraz: fixed up some formatting using guards and various higher order functions
02:25:36 <jle`> http://lpaste.net/108177
02:25:38 <jle`> in an annotation
02:25:40 <zereraz> 1 more doubt, when I am printing not prime what if I just want nothing there
02:25:46 <zereraz> jle`: wow thanks
02:25:56 <jle`> it's tstill the same logic, that's all you :)
02:25:58 <zereraz> like I want to return () there aswell
02:26:36 <jle`> oops, a redundant do
02:26:52 <zereraz> jle`: you guys helped else this simple task was impossible for me :)
02:27:28 <jle`> zereraz: i have a redundant do on line 19 which hlint didn't catch for some reason
02:28:10 <zereraz> jle`: why is it redundant?
02:28:16 <zereraz> because 1 IO?
02:28:16 <jle`> do x = x
02:28:22 <jle`> @undo do { x }
02:28:22 <lambdabot> x
02:28:28 <jle`> do { x } desugars to x
02:28:31 <jle`> yeah, basically
02:28:49 <zereraz> if you had another putStrLn then you had to use that right?
02:29:25 <jle`> yeah
02:29:29 <jle`> @undo do { x; y }
02:29:30 <lambdabot> x >> y
02:29:32 <jle`> or you can just do that
02:29:38 <zereraz> also what do I do if I do not want to print "not prime"
02:29:45 <zereraz> like I just want to return ()
02:30:11 <jle`> you can use when
02:30:21 <jle`> when prime (print x)
02:30:39 <jle`> will print x when `prime` is true, and return () otherwise
02:30:49 <jle`> when True x = x
02:30:53 <jle`> when False _ = return ()
02:30:53 <lfairy> I think you need to import Control.Monad for that
02:31:02 <jle`> oh yeah that too
02:31:03 <jle`> @src when
02:31:04 <lambdabot> when p s = if p then s else return ()
02:31:10 <jle`> boo
02:31:11 <zereraz> ok so I am letting that go
02:31:17 <zereraz> advanced for me
02:31:26 <jle`> do you understand pattern matching?
02:31:36 <zereraz> little bit yes
02:31:39 <jle`> it's basically like
02:31:45 <jle`> when (isPrime x) (print x)
02:31:50 <jle`> so when x is prime, it prints it
02:31:53 <jle`> when it's not, it returns ()
02:31:57 <jle`> you can see this in the definition of when
02:32:07 <jle`> when True x = x
02:32:11 <jle`> when False _ = return ()
02:32:13 <zereraz> what I do not understand is why is it not working here
02:32:25 <jle`> where is here?
02:32:25 <phaskell> No symbol 'here' found anywhere.
02:32:26 <zereraz> like why cant I replace print "not prime" with return ()
02:32:35 <jle`> becuase "not prime" is a string
02:32:42 <jle`> return () in this case would not be a string
02:32:51 <jle`> it'd be an IO (), or something else maybe...but not a String
02:33:05 <jle`> remember that if/then/elses are just normal expressions
02:33:07 <zereraz> but I am not doing print return ()
02:33:09 <jle`> both branches have to be the same type
02:33:13 <zereraz> why should it expect string
02:33:17 <u-ou> he said print "not prime"!
02:33:27 <jle`> oh i see
02:33:41 <jle`> i don't think you ever print "not prime"in any code you gave me
02:33:43 <zereraz> I replaced with return () like I did a few lines below it
02:33:49 <jle`> can you upload your code?
02:33:58 <zereraz> http://lpaste.net/108177
02:33:58 <zereraz> 16
02:34:02 <zereraz> line 16
02:34:14 <lfairy> zereraz: on a completely unrelated note -- if you click on the first warning under your paste, it gives you an example of guards right there
02:34:21 <jle`> what are you replacing with return () ?
02:34:33 <zereraz> lfairy: yeah I learn't that yesterday
02:34:47 <zereraz> lfairy: just find guards weird, will try to use them more
02:34:56 <zereraz> print "not prime"
02:35:01 <zereraz> the whole print
02:35:05 <jle`> you don't have print "not prime" in there
02:35:07 <zereraz> like else return ()
02:35:07 <lfairy> zereraz: they definitely help with the nesting
02:35:19 <jle`> are you replacing "not prime" with return () ...?
02:35:21 <zereraz> oh
02:35:28 <zereraz> lol
02:35:29 <zereraz> I didn't notice
02:35:37 <zereraz> ok so replacing the String with return ()
02:35:51 <zereraz> very sorry about that
02:35:56 <jle`> np
02:37:00 <zereraz> it says couldn't match expected type 'Char' with actual type ()
02:37:47 <jle`> yes, that's because you can't replace a String with return ()
02:37:50 <jle`> becuase they aren't the same type
02:38:29 <zereraz> why does it expect a char there
02:38:31 <jle`> if/then/elses are just expressions in haskell.  if the condition is true, it's the value of the first expression; if the condition is false, it's the value of the second
02:38:35 <zereraz> my return type is IO()
02:39:02 <jle`> zereraz: actually, return is kinda "polymorphic", and can actually be [()]
02:39:05 <jle`> that's not really important right now
02:39:15 <zereraz> ok
02:39:18 <jle`> what's the main problem is that you can't just swithc out a String for a return ()
02:39:21 <jle`> if x then y else z
02:39:28 <jle`> if x is true, then the expression is y
02:39:34 <jle`> if x is false, then the expression is z
02:39:39 <jle`> do you see why y and z have to be the same type?
02:39:59 <zereraz> jle`: yeah I finally understand
02:40:16 <zereraz> jle`: you guys taught me this yesterday but I forgot that part
02:40:20 <jle`> what you can do is move the "putStrLn" into the if/then, so that both branches are if type IO ()
02:40:40 <jle`> if primeCheck n then print n else return ()
02:40:55 <jle`> that way, the 'then' branch is IO (), and the 'else' branch is also IO ()
02:41:06 <jle`> also, remember the definition of 'when'
02:41:16 <jle`> when p s = if p then s else return ()
02:41:42 <jle`> compare to: if (primeCheck n) then (print n) else return ()
02:42:00 <jle`> do you see how you can replace that if/then with a call to `when`?   what would `p` be, and what would `s` be?
02:42:00 <zereraz> jle`: ok will dothat
02:42:19 <jle`> i might be going a bit fast, sorry
02:42:25 <zereraz> jle`: I am yet to learn when properly
02:42:30 <zereraz> np
02:42:43 <jle`> when is just a normal function
02:42:44 <zereraz> I appreciate this thanks
02:42:51 <jle`> do you know how function evaluation works in haskell?
02:43:03 <jle`> in some sense it is pretty much like basic subsitution
02:43:16 <zereraz> yeah
02:43:21 <jle`> if f x = x + x ..... f 1 is "substituted" for 1 + 1
02:43:42 <zereraz> ok yeah
02:43:44 <jle`> so if you have when p s = if p then s else return (),     when x y is literally "substituted" for if x then y else return ()
02:43:45 <int-e> > 1
02:43:47 <lambdabot>  1
02:44:11 <zereraz> understood that
02:44:25 <jle`> so here's the puzzle... when p s = if p then else else return ().   what do you need to put in for 'p' and for 's', so that when p s expands to if primeCheck n then print n else return () ...?
02:45:21 <zereraz> else else?
02:45:44 <jle`> hm.
02:45:56 <jle`> what does "when X Y" expand to?
02:46:09 <zereraz> I have not learnt when
02:46:16 <zereraz> never used it
02:46:22 <jle`> oops sorry, i gave a bad definition
02:46:28 <jle`> when p s = if p then s else return ()
02:46:30 <jle`> it's just a normal function
02:46:32 <pkmx> it's `when p s = if p then s else return ()`
02:46:53 <jle`> and remember...for something like `f x = x + x`, f 1 expands to 1 + 1
02:47:01 <zereraz> oh that is what it means
02:47:03 <jle`> so when p s = if p then s else return ()
02:47:08 <jle`> when is just a normal function
02:47:14 <jle`> so what does when X Y expand to?
02:47:31 <jle`> here's a simpler one... if f x = x + x, what does f Y expand to?
02:47:32 <zereraz> if X then Y else return ()
02:47:37 <jle`> oh good :)
02:47:42 <zereraz> Y+Y
02:47:54 <jle`> okay, so what you *want* is: if (primeCheck n) then (print n) else return ()
02:47:56 <jle`> right?
02:48:05 <jle`> so what do you need 'p' and 's' to be, to expand to that?
02:48:24 <jle`> when X Y   ----> if (primeCheck n) then (print n) else return ()
02:48:26 <zereraz> when (PrimeCheck n) (Print n)
02:48:30 <jle`> yay!
02:48:33 <jle`> lowercase letters of course
02:48:38 <zereraz> I got it!
02:48:46 <jle`> it's a bit like a puzzle, isn't it?
02:48:50 <jle`> in fact, you can even use equational reasoning
02:48:54 <zereraz> jle`: yeah thanks
02:49:02 <jle`> when X Y    ==?==   if (primeCheck n) then (print n) else return ()
02:49:07 <jle`> expand out when X Y ->
02:49:18 <jle`> if X then Y else return ()  ==?== if (primeCheck n) then (print n) else return ()
02:49:23 <zereraz> if X then Y else return ()
02:49:27 <jle`> so the X matches up with primeCheck n, and the Y matches up to print n
02:49:34 <zereraz> yeah
02:49:35 <jle`> so you can "solve" for X and Y
02:49:56 <zereraz> yeah I will
02:50:01 <jle`> of course you can always manually write out if primeCheck n then print n else return ()
02:50:24 <jle`> but that pattern is very common, so we like to use a higher order function like `when` to reduce repitition
02:50:39 <jle`> and to improve clarity/readability
02:50:50 <zereraz> ok
02:50:55 <zereraz> thanks allot
02:51:21 <jle`> np
02:51:54 <zereraz> how do I get when?
02:52:00 <zereraz> import something?
02:52:25 <zereraz> control.monad
02:52:42 <jle`> Control.Monad
02:52:49 <jle`> have you heard of hoogle?
02:52:53 <jle`> @where hoogle
02:52:53 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
02:53:05 <jle`> it should tell you what modules these things live in
02:53:07 <jle`> @hoogle when
02:53:08 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
02:53:08 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
02:53:08 <lambdabot> Test.QuickCheck whenFail :: Testable prop => IO () -> prop -> Property
02:53:15 <Welkin2> except hoogle doesn't always work
02:53:39 <Welkin2> @hoogle (<&>)
02:53:39 <lambdabot> No results found
02:54:16 <zereraz> ok thanks
02:54:27 <jle`> yeah, it's not perfect, but it has everything in base, at least :)
02:54:29 <zereraz> first such monad import
02:54:30 <jle`> http://www.haskell.org/hoogle/?hoogle=(%3C%26%3E)+%2Blens , btw
02:54:33 <Athiwat> Welkin2: is <&> the fmap thing?
02:54:51 <Welkin2> Athiwat: flip <$>
02:54:53 <Welkin2> supposedly
02:55:02 <Athiwat> I see
02:55:33 <jle`> i actually wouldn't mind a flip fmap sometimes
02:55:46 <jle`> to go along with the flip mapM that we have
02:56:10 <Athiwat> I'm quite new, still have problems writting long programs
02:56:35 <Welkin2> I'm mostly having trouble with unreleased packages...
02:56:59 <Welkin2> using cabal to install them in a sandbox
02:57:11 <Welkin2> has anyone used sdl2-gfx?
02:59:49 <Athiwat> Anyone have a tutorial that teach us to write real world programs? Most of them that I found are just short codes.
03:00:13 <Welkin2> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
03:00:39 <Welkin2> you can learn Parsec through that as well
03:00:44 <jle`> Athiwat: i like just going over old programs you have written in other languages and trying to make them work in haskell
03:00:47 <jle`> there's also
03:00:53 <jle`> @where p&ch
03:00:53 <lambdabot> I know nothing about p&ch.
03:00:59 <jle`> @where parallel and concurrent haskell
03:00:59 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
03:01:04 <jle`> >_>
03:01:18 <jle`> http://chimera.labs.oreilly.com/books/1230000000929
03:01:34 <Welkin2> @where marlow
03:01:34 <lambdabot> I know nothing about marlow.
03:01:38 <Welkin2> @where simon
03:01:38 <jle`> which is for short projects still, i guess, but longer than a few functions
03:01:38 <lambdabot> I know nothing about simon.
03:01:58 <Athiwat> jle`: I'm still have problems with Monad/do thing, lift stuff. Just can't write long program with them.
03:02:01 <Welkin2> @where spj
03:02:01 <lambdabot> I know nothing about spj.
03:02:07 <Welkin2> @where haskell
03:02:07 <lambdabot> http://haskell.org
03:02:35 <Welkin2> Athiwat: use that scheme tutorial, it uses a lot of monands and lift/monad transformers
03:02:43 <Welkin2> monads*
03:02:46 <Athiwat> Welkin2: thanks
03:04:29 <Athiwat> Wow, the name of that tutorial
03:04:52 <Athiwat> I would never read it if you didn't suggested it to me.
03:06:58 <Welkin2> will runhaskell let me install in a sandbox?
03:09:17 <jle`> Welkin2: runhaskell doesn't install anything
03:09:35 <Welkin2> well, I mean runhaskell Setup.hs
03:15:36 <fizbin> 'm sure this is an FAQ, but I can't find it anywhere - how do I get myself unstuck from the error of running "cabal upgrade"? lens-4.2 failed to install with the error src/Control/Lens/Internal/Zoom.hs:47:8:
03:15:36 <fizbin>     Could not find module `Control.Monad.Trans.Except'
03:16:20 <fizbin> I'm now stuck, in that any "cabal install" command tries to install lens-4.2 and fails.
03:17:10 <fizbin> Sorry, wrong command. How do I recover from running "cabal install cabal-install" ?
03:20:39 * hackagebot abc-puzzle 0.1 - Generate instances of the ABC logic puzzle.  http://hackage.haskell.org/package/abc-puzzle-0.1 (PatrickBahr)
03:53:43 <ATuin> hi
03:54:23 <ATuin> im having a problem compiling haskeline, when linking ld is not able to found: -lHSterminfo-0.4.0.0-ghc7.8.2 any clue?
03:54:33 <_ikke_> Can anyone explain why something like data Either a a = Left a | Right a; doesn't work?
03:56:02 <Pythonfant> _ikke_: your specifying two type variables for Either but they have the same name so they conflict
03:56:18 <Pythonfant> if you want Left and Right to have the same type Either only depends on one type variable
03:56:26 <Pythonfant> so you get data Either a = Left a | Right a
03:56:49 <_ikke_> Ok
03:56:53 <_ikke_> Makes sense
03:58:23 <Pythonfant> the alternative is ofc data Either a b = Left a | Right b
03:58:38 <_ikke_> I'm trying to figure out something a bit more fundamental. I was reading lyah about functors. So you have an instance Functor (Either a); where fmap can be applied to Right, but can't apply it to Left
03:59:44 <_ikke_> Either has kind * -> * -> *.
03:59:45 <Cale> _ikke_: That's correct
03:59:49 <Pythonfant> Left for Either usually represents failure
04:00:01 <Cale> So Either a has kind * -> * which is the right sort of kind for a Functor to be
04:00:12 <_ikke_> Yeah
04:00:30 <Cale> and then fmap's type specialised in this case will be  (t -> s) -> Either a t -> Either a s
04:00:46 <_ikke_> Yeah, that I understand
04:00:58 <Cale> So it must be applying the function to the Right portion
04:02:17 <_ikke_> What does the a represent in this case, when you only have a Right value?
04:03:05 <_ikke_> Right "ab" means b represents a String type
04:03:43 <jle`> > Right "ab" :: Either Int String
04:03:45 <lambdabot>  Right "ab"
04:03:59 <Pythonfant> a is the type of the left value of the Either
04:03:59 <jle`> > Right "ab" :: Either Bool String
04:04:01 <lambdabot>  Right "ab"
04:04:03 <jle`> good question, _ikke_ !
04:04:13 <jle`> the Left value doesn't exist...so what is `a` really?
04:04:17 <jle`> it seems like it can be anything!
04:04:32 <_ikke_> lyah says that a is fixed, while b can be anything
04:04:40 <jle`> `a` only makes sense if you use functions using more than one Either
04:04:42 <_ikke_> because of the (Either a) part
04:04:45 <jle`> or converions and stuff
04:05:06 <jle`> _ikke_: yeah, fmap cannot change the `a`
04:05:22 <jle`> :t Left 4
04:05:23 <lambdabot> Num a => Either a b
04:05:41 <jle`> :t fmap not (Left 4)
04:05:42 <lambdabot> Num a => Either a Bool
04:05:58 <jle`> no matter what you fmap onto an Either, the `a` won't change
04:06:25 <jle`> :t (Right 4 :: Either Bool Int)
04:06:26 <lambdabot> Either Bool Int
04:06:34 <jle`> :t fmap (*2) (Right 4 :: Either Bool Int)
04:06:35 <lambdabot> Either Bool Int
04:06:58 <jle`> ...but what does the `a` even mean, if your value is a Right...?
04:07:15 <jle`> a related question:
04:07:21 <jle`> [] :: [a]
04:07:26 <jle`> the empty list is of type [a]
04:07:30 <jle`> ...but what does that `a` mean?
04:07:36 <jle`> there aren't any elements in that list...
04:08:00 <jle`> when does the `a` matter?
04:08:33 <jle`> > 2 : ([] :: [Int])
04:08:35 <lambdabot>  [2]
04:08:40 <jle`> > 2 : ([] :: [Bool])
04:08:42 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
04:08:42 <lambdabot>    arising from the literal ‘2’
04:08:50 <jle`> :t (:)
04:08:50 <lambdabot> a -> [a] -> [a]
04:09:19 <_ikke_> [a] is a type constructor, right
04:09:22 <_ikke_> "??
04:09:32 <jle`> [] is the type constructor in this case, [a] is a concrete type
04:09:40 <_ikke_> ok
04:09:58 <jle`> but [] is also a data constructor --- it's the empty list
04:10:00 <jle`> :t []
04:10:01 <lambdabot> [t]
04:10:40 <jle`> i guess what i'm saying is that the `a` in Right 4 :: Either a Int is the same `a` that's in [] :: [a]
04:11:16 <jle`> and that it begins to "matter" when you use it in functions that require all the a's to be the same
04:11:44 <sivteck> are the lists defined like: data [] a = [] | (:) a ([] a)   ?
04:12:17 <jle`> sivteck: more or less.  i like to say data [a] = [] | a:[a]
04:12:20 <jle`> some sugar involved
04:12:27 <sivteck> ah, ok
04:12:29 <jle`> _ikke_: it also begins to matter when you pattern match on an Either
04:12:40 <jle`> case Right 4 of Right x -> ...; Left y -> ...
04:12:50 <_ikke_> Why does does not work for example: instance Functor (Either a) where; fmap f (Left x) = Left (f x)
04:13:00 <jle`> _ikke_: check out the types
04:13:03 <_ikke_> (assuming the Right part is also defined)
04:13:33 <jle`> so if i map an (a -> c) onto an Either a b in the manner that you are defining...what si the type of the result?
04:13:49 <jle`> and do you see why it can't possibly fit into the type of fmap?
04:13:51 <jle`> :t fmap
04:13:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:14:50 <jle`> there's also an even bigger problem
04:14:50 <_ikke_> hold on
04:15:20 <jle`> if f ~ Either e, the fmap becomes (a -> b) -> (Either e) a -> (Either e) b
04:15:36 <jle`> if your function is (a -> b)...how are you applying it to an e?
04:15:44 <jle`> (assuming instance Functor (Either e) where..)
04:16:34 <_ikke_> what does f ~ Ether e mean?
04:17:13 <int-e> whaletechno: ~ denotes type equality.
04:17:19 <_ikke_> ok
04:18:48 <_ikke_> I'm trying to wrap my head around it
04:18:49 <Hafydd> I wish to use something like ErrorT, but without the behaviour of catching errors produced by Control.Monad.fail. Is there any better option than writing my own Monad instance?
04:20:32 <jtcwang> what's your usecase?
04:21:19 <jle`> _ikke_: i use it to mean "let f = Either e, in the type signature", sorta
04:21:45 <_ikke_> I think I get it
04:21:46 <jtcwang> Hafydd, I used EitherT from errors library for my program's error handling
04:21:51 <jle`> fmap :: Functor f => (a -> b) -> f a -> f b... so if we "let f = Either e", we get fmap :: (a -> b) -> (Either e) a -> (Either e) b
04:22:07 <jle`> so all of the Left's are of type `e`...so you can't use your (a -> b) on them
04:23:40 <_ikke_> f is a type constructor in this case
04:23:56 <jle`> yes
04:24:11 <jle`> well, it's a type variable, standing in for a type constructor
04:24:14 <jle`> sorry
04:24:16 <rio> but you can use id on the left's!
04:24:26 <jle`> (Either e) is a type constructor
04:24:29 <_ikke_> jle`: right
04:25:02 <_ikke_> And because the type is e, it is not guaranteed that the types match
04:25:34 <jle`> yeah
04:26:09 <_ikke_> I get it now
04:26:14 <jle`> :D
04:26:24 <_ikke_> thanks
04:27:12 <rio> jle`: i wouldn't expect (a->b) -> (Either e a -> Either e b) to do anything on Left's
04:27:23 <Hafydd> jtcwang: I see. That looks like a good library.
04:27:31 <jle`> rio: yeah, that's a good way of looking at it
04:27:44 <jtcwang> Hafydd, it's quite nice to work with
04:27:54 <jle`> parametricity actually dictates taht there is only one total implementation, I believe
04:28:02 <jle`> @djinn (a -> b) -> Either e a -> Either e b
04:28:02 <lambdabot> f a b =
04:28:02 <lambdabot>     case b of
04:28:02 <lambdabot>     Left c -> Left c
04:28:02 <lambdabot>     Right d -> Right (a d)
04:28:47 <angerman> Did anyone try to see how close they got implementing Functors, Applicatives or Monads in ObjC?
04:29:15 <Axman6> they're probably having a lot more luck in swift (see Swuftz)
04:29:16 <jtcwang> Hafydd, if you want some example of how I used it, see https://github.com/jtcwang/HaskSplit/blob/master/src/exe/Main.hs
04:29:21 <Axman6> Swiftz*
04:29:59 <Hafydd> jtcwang: the use case is a monad like EitherT ErrorValue (StateT StateValue), where I want certain computations to be able to raise errors to halt the computation prematurely, but I want pattern matching errors inside such functions to fail in the old-fashioned way.
04:30:05 <angerman> Axman6: Well swift is one thing :) I'm more wondering if it's possible to write it in objc, as that might be easier to understand for some.
04:30:13 <rio> jle`: exactly, if you only have an (a->b) you can't do anything to an e, that would require an e->e
04:30:46 <Axman6> angerman: I think it would be quite difficult to express in Obj-C
04:31:05 <jtcwang> Hafydd, can't you 'return' prematurely if there's an 'error'?
04:31:13 <Axman6> doable, but the type system is so limited it would be very hard to know it's right or not
04:31:13 <rio> which would take us to (e->f) -> (a->b) -> Either e a -> Either f b in the general case
04:31:28 <angerman> Axman6: type system? :D It's all id :D
04:31:39 <Axman6> well, there's C's type system too
04:31:42 <jtcwang> Hafydd, i.e. return a Left "error message"
04:31:53 <Hafydd> jtcwang: no, because a subcomputation might either produce a value or fail, depending on the state.
04:31:54 <Axman6> but no paremtric polymorphism
04:32:30 <Hafydd> (And I do not wish to inspect every returned value to see if it's erroneous.)
04:32:53 <angerman> Axman6: hmm.
04:33:37 <Hafydd> I was initially writing something like that, actually, but it became cumbersome, and I wanted my functins to be more composable.
04:34:03 <jtcwang> Hafydd, so are you using the fail function for Monads?
04:34:52 <Hafydd> jtcwang: I
04:35:43 <jtcwang> Hafydd, I'm not too experienced in error handling in Haskell, the code I showed you was my first attempt :P
04:36:20 <Hafydd> jtcwang: I was initially using functions of the type "StateValue -> (Maybe ErrorValue, StateValue)"; what I'm now planning to do would not involve using "fail", but rather some other function to raise an error.
04:36:33 <jtcwang> Hafydd, I see
04:37:57 <jtcwang> Hafydd, can you do "StateValue -> Either StateValue ErrorValue"?
04:39:11 <QuantumGravity> hello
04:39:12 <Hafydd> jtcwang: no, since I wish to be able to inspect the state upon an error.
04:39:46 <jtcwang> QuantumGravity, hello
04:40:02 <Hafydd> It is a simulation of a machine that may halt in various ways, and afterwards be restarted.
04:40:32 <QuantumGravity> I'm a computer engineering student and I would like to create the first native Haskell computer
04:40:40 <jtcwang> Hafydd, I catch you. Let me think about it
04:40:51 <QuantumGravity> tips?
04:41:09 <jtcwang> QuantumGravity, undergraduate?
04:41:18 <QuantumGravity> no phd
04:41:34 <jtcwang> QuantumGravity, define 'native'
04:41:41 <Hafydd> QuantumGravity is a troll. They were just trolling ##math.
04:41:45 <Axman6> QuantumGravity: see the reduceron
04:41:58 <QuantumGravity> Hafydd:  I think you have me mistaken
04:42:02 <QuantumGravity> Axman6:  ok thx
04:42:12 <QuantumGravity> I will look into it
04:43:11 <jtcwang> Hafydd, so you want a function like "StateValue -> StateValue" but could throw an exception, which would be caught by the parent function?
04:44:13 <Hafydd> jtcwang: more like StateValue -> (a, StateValue), to allow a value to be computed.
04:44:30 <Hafydd> Otherwise... yes.
04:45:30 <phaazon> is there DanielG here? :)
04:45:42 <Hafydd> For example, there might be a function "pop" which pops a value off a stack inside the machine and returns it; but it might also fail due to stack underflow.
04:45:42 <jtcwang> Hafydd, will your function produce a value if an error occurs?
04:45:48 * hackagebot monad-journal 0.2.2.0 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.2.0 (DimitriSabadie)
04:46:29 <jtcwang> "StateValue -> (StateValue, Either a ErrorMsg)" bit ugly haha
04:46:38 <Hafydd> jtcwang: no, it won't produce a value.
04:47:00 <jle`> @unmtl ErrorT e (State s) a
04:47:00 <lambdabot> (State s) (Either e a)
04:47:16 <jle`> ...which should be
04:47:16 <Hafydd> That's isomorphic to EitherT ErrorValue (StateT StateValue), of course.
04:47:28 <jle`> s -> (Either e a, s)
04:48:09 <Hafydd> I currently have a Monad instance written for that expanded type, actually, but it felt like reinventing the wheel.
04:49:38 <jtcwang> Hafydd, to allow for 'errors' from a function isn't it good to make it explicit? I mean otherwise it'll just be like Java with all the null pointers for implicit failure
04:50:56 <jtcwang> Hafydd, ofc, this is coming from my puny knowledge, but I'd prefer more explicit type signatures which tells me that there could be an error
04:51:23 <jtcwang> bit like Java's 'throws' keyword I guess
04:51:35 <Hafydd> jtcwang: it would be explicit in the type StateValue -> (Either ErrorValue a, StateValue), surely.
04:51:58 <Hafydd> And also in EitherT ErrorValue (StateT StateValue) a, and the same for ErrorT.
04:52:32 <Hafydd> I'm not suggesting anything with implicit errors, as far as I know.
04:54:36 <jtcwang> Hafydd, my misunderstanding then haha. I subconciously link ErrorT with exceptions, for some reason
04:55:25 <merijn> For exceptions you don't really need a special transformer, you can use any MonadIO instance
04:56:03 <Guest80975> :q
04:59:01 <k00mi> merijn: but then you don't have a type indicating what exceptions might be thrown, do you?
05:03:56 <k00mi> ideally, I would like Control.Exception with type annotations saying what exceptions might be thrown
05:04:19 <k00mi> transformers are not nearly flexible enough in my experience
05:05:43 <Tjr> k00mi: the extensible-effects package is more flexible than transformers. (not sure if it fits your needs, just chiming in)
05:07:25 <merijn> k00mi: Haskell exceptions are unchecked, yes. On the one hand that's kinda annoying, on the other hand checked exceptions don't always improve things. I agree that some inferred effect checking style thing would be nice, but I don't think retrofitting that into Haskell's type system is very easy
05:07:35 <merijn> ocharles: ping?
05:08:15 <ocharles> merijn: aloha
05:08:26 <k00mi> Tjr: it doesn't solve the problems I have with exceptions-as-transformers, no
05:08:50 <Axman6> k00mi: I wrote something to allow you to do that (though it requires annotating prelude functions with which exceptions they may throw)
05:09:13 <merijn> ocharles: I finally got around to looking at your bug report from a while back, but I'm not sure I understand what's going
05:09:14 <k00mi> Axman6: oh, can I see?
05:09:29 <Axman6> k00mi: https://gist.github.com/axman6/19adc08a809d919a2efb
05:09:57 <ocharles> merijn: heh, link me again?
05:10:18 <merijn> ocharles: This one: https://bitbucket.org/merijnv/transformers-supply/issue/1/monadsupply-is-almost-impossible-to-use
05:10:26 <hpc> if you want checked exceptions, us ErrorT
05:10:45 <hpc> or a similar alternate type
05:10:53 <Axman6> could probably use some more examples, but you can use things like openFile = ThrowsI Prelude.openFile :: ThrowsI es (Insert FileNotFound es) File (or whatever it is that openFile returns and throws)
05:11:02 <ocharles> merijn: ok, let me refresh my memory
05:11:54 <k00mi> Axman6: neat
05:12:11 <merijn> ocharles: Actually, I think this might even be "not a bug"
05:12:38 <ocharles> merijn: it's not a bug, but it did mean I couldn't really use the MonadSupply type class
05:13:08 <Axman6> k00mi: it could also probably have something like type WithE e a = ThrowsI es (Insert e es) a, not sure if that'd work though. It was more an exercise in playing with DataKinds and several other extensions than something to be useful
05:13:17 <merijn> ocharles: You're having trouble with the fact that you can't "runSupplyT" a value of type "MonadSupply s m m => m a", but the same thing applies to the fact that you can't runReaderT a value of type "MonadReader r m => m a"
05:13:52 <ocharles> I don't think it's that - i'm just tyring to find my code
05:14:08 <merijn> ocharles: There's an attached bit of code :)
05:14:17 <ocharles> oh!
05:14:22 <ocharles> how organised of me
05:14:49 <merijn> ocharles: But actually the clue is in the IRC chat bit
05:14:55 <k00mi> Axman6: I was actually just thinking of doing something like that myself with the same intention :)
05:16:11 <Axman6> well, I hope that's useful or inspiring for you =)
05:16:26 <Axman6> It was a lot of fun, like learning to program Haskell for the first time again
05:17:31 <ocharles> merijn: So do you think in my example there is a way to use MonadSupply in its current form?
05:18:14 <k00mi> I think singletons should have some of those type level functions btw.
05:18:17 <merijn> ocharles: The point is, if you want to do "stepWire" and do something with the result, you need to fix the type of the result
05:18:40 <Axman6> probably, but where's the fun in that?
05:18:50 <eliasdiem> what's a good resource to learn how to use XML in Haskell?
05:18:51 <Axman6> I learny about indexed monads too which is cool
05:19:03 <k00mi> hehe yeah :)
05:19:03 <merijn> ocharles: For the same reason that "runReaderT" requires you to fix the type before you can start running it
05:19:04 <Axman6> learnt*
05:19:25 <ocharles> merijn: I don't understand what you mean by fixing it. I am obviously choosing types when I call 'runSupplyT' on the outside
05:19:29 <ocharles> But presumably that's not what you mean
05:22:32 <merijn> ocharles: If you want to have SupplyT at the "outside" of your monad stack, I don't think you want to use MonadSupply in the first place, but just SupplyT directly
05:23:50 <merijn> ocharles: i.e. "(Applicative m, MonadReader (Wires.Event DOMEvent) m) => Wires.Wire (SupplyT Int m) [Element] (Element, Wires.Event ())"
05:24:18 <merijn> ocharles: Then "stepWire" gives you a "SupplyT Int m (Element, Wires.Event ())" that you can "runSupplyT"
05:25:36 <merijn> ocharles: The base case of the MonadSupply class is "(Functor m, Monad m) => MonadSupply s m (SupplyT s m)" i.e. I want to generate effectful action in monad 'm' within my Supply transformer
05:26:05 <merijn> ocharles: But your "MonadSupply Int m m" constraint says "I want to generate Supply action within the Supply monad", which doesn't make sense
05:27:03 <merijn> ocharles: You could write "MonadSupply Int m (SupplyT Int m)", but that'd be silly, you're better of writing explicitly what I just wrote
05:27:30 <ocharles> Which suggests to me that MonadSupply isn't particularly useful...
05:28:03 <merijn> ocharles: MonadSupply is more intended for things like "MonadSupply ByteString IO m" where 'm' is a monad stack involving IO
05:28:58 <ocharles> Hum
05:29:04 <ocharles> Well, if it's not a problem then feel free to close the bug :)
05:29:42 <merijn> ocharles: Well, I agree that the current typeclass constraint is probably a bit tricky to write what it's for, so I'm considering just scrapping it...
05:29:58 <merijn> ocharles: Anyway, the explitit SupplyT inside Wire should Just Work (TM)
05:31:14 <merijn> Anyone know if the suggestion to merge binary and cereal into a single library dealing with both strict and lazy ByteString is ever gonna happen?
05:31:24 <ocharles> Right, I was generally trying to avoid that, but I can do it if need be
05:31:30 <ocharles> but I'm also not working on this code anymore :P
05:31:41 <ocharles> But thanks for the discussion!
05:31:56 <merijn> ocharles: Why where you trying to avoid that? If you need to immediately run the SupplyT then you have to fix it on the outside anyway
05:32:32 <ocharles> I like to keep the types as general as I can, and let the caller determine them
05:36:56 <merijn> ooh, binary already has incremental decode :)
05:56:30 <tac> @hoogle guard
05:56:31 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
05:56:31 <lambdabot> package guarded-rewriting
05:56:31 <lambdabot> Language.Haskell.TH.Lib guardedB :: [Q (Guard, Exp)] -> BodyQ
05:58:38 <int3__> heh, I'm starting to feel like it's more useful to read the code than the documentation for most of e-k's libraries :P
05:59:10 <int3__> the math terms kind of bowl me over, but then i look at the code and i'm like, eh, those are pretty reasonable abstractions
05:59:49 <int3__> but I suppose things will get better once I get down to reading category theory
06:00:42 <fizbin> I have some code that seems to be falling into an infinite loop when given certain inputs. How do I go about debugging this? In some other language I'd print out the arguments to some recursive function each time I invoked it, or at the very least I'd fire up the IDE and set a breakpoint and step through it, but I'm a bit at a loss as to how to do that here.
06:01:29 <int3__> fizbin: there's Debug.Trace
06:02:05 <mwhit> ^^^
06:02:06 <ClaudiusMaximus> fizbin: i'd try +RTS -xc  and see what gets printed on ctrl-C
06:04:09 <Axman6> fizbin: ghci also does have a debugger btw (though I have no idea how to use it)
06:04:48 <fizbin> Yeah, that's my issue: I know this stuff is there, but "how do I use it" tutorials are notably absent.
06:05:18 <ClaudiusMaximus> fizbin: also try -Wall and see if you accidentally shadowed something or didn't use the right number of ' on a binding vs use site
06:05:48 <fizbin> My theory is that in the Haskell community we don't want to show how we debugged some broken piece of code because we don't want to admit to writing broken code.
06:05:50 <mwhit> Debug.Trace is very simple to use, it's an unsafe IO operation so you can just plop it wherever you want in code
06:05:58 <Axman6> I'm sure they exist, I just haven't ever really needed it
06:06:15 <Axman6> fizbin: not at all
06:06:20 <int3__> fizbin: in particular, Debug.Trace has traceShow and traceShowId
06:06:34 <Axman6> I've seen many posts about broken code and how it was fixed
06:06:39 <int3__> those are the functions i use most from that module
06:06:45 <Axman6> :t traceShow
06:06:46 <lambdabot> Not in scope: ‘traceShow’
06:06:49 <Axman6> bleh
06:06:54 <Axman6> @hoogle trace
06:06:54 <lambdabot> Debug.Trace trace :: String -> a -> a
06:06:54 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:06:54 <lambdabot> package trace-call
06:07:31 <merijn> fizbin: The GHC manual covers ghci's debugger
06:07:45 <merijn> fizbin: And GHC's manual in general is very in-depth, more people should look at it :)
06:07:46 <allsystemsarego> @check \myList -> let headOfSortedList = head . sort $ myList in and [ headOfSortedList <= i | i <- take 10 myList ]
06:07:48 <lambdabot>  +++ OK, passed 100 tests.
06:07:54 <int3__> I have a question regarding type declarations
06:07:58 <int3__> newtype AnnoList k v = AnnoList [(k, v)]
06:07:58 <int3__> type GameTree = (Cofree (AnnoList Move)) Game
06:08:05 <int3__> can I rewrite this without the newtype?
06:08:26 <int3__> I'd like to have something like `type GameTree = (Cofree [(Move, a)]) Game`
06:08:28 <merijn> int3__: No, because partially applied type aliases are not allowed
06:08:48 <Axman6> and you can't partially apply [(a,b)]
06:09:02 <Axman6> I think
06:09:12 <merijn> You could if you had partially appliable type aliases :p
06:09:15 <mwhit> well AnnoList could be a second type alias
06:09:16 <merijn> Which is why they don't exit :D
06:09:17 <mwhit> instead of newtype
06:09:24 <merijn> mwhit: Nope
06:09:27 <mwhit> no?
06:09:29 <mwhit> hm
06:09:31 <int3__> mwhit: nope, I tried that
06:09:42 <merijn> mwhit: AnnoList only has one argument in the second type
06:09:51 <merijn> mwhit: Type aliases *must* be fully applied
06:09:53 <mwhit> oh right
06:10:12 <int3__> i suppose allowing partially applied type aliases breaks the type system somehow
06:10:52 <merijn> int3__: Yeah, partially applied type aliases are equivalent to type-level lambda, which breaks inference
06:14:55 <fizbin> merijn: My problem is that the manual does not seem to describe what I see. For example, the manual claims "Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on.", and yet when I attempt that I get an empty history.
06:16:40 <fizbin> Also, the manual doesn't tell me useful things like how to exit the debugger back to top level.
06:17:21 <merijn> mmm, I don't remember too many details of it, tbh
06:19:09 <Cale> fizbin: Yeah, sometimes that happens, if there don't happen to be many profiler annotations in your loop
06:19:31 <fizbin> Is there some way to add profiler annotations?
06:20:03 <Cale> Well, first of all, did you build with -fprof-auto ?
06:20:19 <fizbin> Hrm. I'm also in the middle of "cabl repl", not plain ghci, and so maybe not.
06:20:37 <Cale> oh, right, break on exception
06:20:44 <Cale> I was thinking of -xc
06:20:52 <mmmm> Is there anything dangerous about a) FlexibleInstances b) MultiParamTypeclasses
06:20:55 <fizbin> Though all the code in question was loaded with :l and so should be interpreted.
06:21:01 <Cale> mmmm: no to both
06:21:48 <Cale> fizbin: You might try compiling the code for profiling with -prof -fprof-auto and then run the program with +RTS -xc
06:22:06 <Cale> and then Control-C should get you a "stack trace" of sorts
06:22:28 <Cale> (of cost centres)
06:22:34 <fizbin> I wish I knew how to bust out of the debugger breakpoint and back to top level in ghci...
06:22:58 <Cale> :abandon ?
06:23:08 <mmmm> thanks Cale
06:23:43 <fizbin> Cale: That seems to drop me back to my infinite loop...
06:23:54 <Cale> mmmm: In fact, for years, FlexibleInstances was just silently how GHC operated until someone pointed out that it was not really Haskell 98 :)
06:24:07 <fizbin> But a second ^C breaks that, so good.
06:24:45 <Cale> fizbin: So like, :history didn't give you anything?
06:24:54 <fizbin> No.
06:25:08 <Cale> yeah, I dunno
06:25:10 <fizbin> Prelude G Te CrowdScript.Backend.StringMatchTest> :trace (G.noNodes $ crunchFromFront 0 gr')
06:25:11 <fizbin> ^CStopped at <exception thrown>
06:25:11 <fizbin> _exception :: e = _
06:25:11 <fizbin> [<exception thrown>] Prelude G Te CrowdScript.Backend.StringMatchTest> :hist
06:25:11 <fizbin> Empty history. Perhaps you forgot to use :trace?
06:25:18 <Cale> I've never really used the GHCi debugger all that much
06:25:41 <fizbin> Not helpful, ghci.
06:25:42 <Cale> Interesting
06:26:03 <Cale> Well, maybe try the profiler
06:26:49 <Cale> (this can sometimes be a challenge, if you discover that you have to rebuild absolutely everything with profiling, then don't bother, there are other things we could try, like Debug.Trace.trace
06:26:52 <Cale> )
06:27:20 <merijn> mmmm: Most extensions are safe in the sense that the worst thing they'll do is loudly fail during compilation (some of them add extra keywords) else everything just works the same as without said extension.
06:27:27 <Cale> You can add an always failing pattern to the start of any function like:
06:27:51 <fizbin> Well, first I'm shrinking this test case down to the minimal example I can find.
06:28:02 <Cale> f x y z | trace (unwords ["f", show x, show y, show z]) False = undefined
06:28:13 <fizbin> Since right now it depends on a nasty graph structure to trigger it.
06:28:20 <merijn> mmmm: There's only like 1 or 2 extensions that can silently cause code to misbehave (IncoherentInstances, I think. OverlappingInstances I think is also a bit suspicious, but even that's not outright dangerous, I think)
06:28:26 <Cale> and that'll print a message to the terminal each time f is evaluated with the parameters that were used
06:28:35 <fizbin> Cale: got it.
06:28:56 <mmmm> so UndecidableInstances is also safe?
06:29:26 <fizbin> Unfortunately, what I really need to do is trace only a small bit so I can find the forest for the trees. So I'll likely trace only based on a different calculation, but that's straightforward enough.
06:29:47 <merijn> mmmm: UndecidableInstances can cause GHC to infinite loop, but will never generate wrong code when it does generate code
06:29:52 <Cale> mmmm: UndecidableInstances is slightly more controversial.
06:30:20 <Cale> Not just because it can result in programs which take forever to compile, but also because it usually means you're abusing typeclasses a bit
06:30:44 <merijn> mmmm: In general GHC is rather strict about what it allows, to ensure that typechecking terminates. UndecidableInstances loosens those restrictions (at the risk of accidentally getting an infinite typechecking loop)
06:31:04 <Cale> Some uses of it are okay, especially if that's *all* that you need
06:31:22 <Cale> If you also need OverlappingInstances, then you should really start to think about doing things differently
06:32:38 <mmmm> Yes my typeclass is a bit wrong but it's to maintain backwards compatability until we have time to properly change the structure
06:32:47 <int3__> so now I have this 'annotated rose tree' structure from earlier. I'd like to do a fold on it, and I'm sure there's some recursion scheme that does this already, but I don't know what it is or what it might be called... basically I'd like to have `fold f (Tree v arr) = f v (fmap f arr)`
06:32:48 <Cale> In particular, whether you really want to be using a type class at all
06:32:57 <int3__> not exactly a Foldable
06:33:10 <Cale> Remember that you can pretty much always replace a type class by a data type holding those methods.
06:33:12 <int3__> more like a... top-down fold rather than any kind of left-to-right, plus f takes two arguments, not one
06:34:27 <Cale> int3__: Well, there's one particular "fold" which might be of some use, I don't know if it's what you mean...
06:34:50 <Cale> I'm assuming you have something like... data Tree a = Branch a [Tree a] ?
06:34:57 <int3__> Cale: yeah, pretty much
06:35:31 <Cale> foldTree branch = f where f (Branch x ts) = branch x (map f ts)
06:35:55 <mmmm> So my use case is we have a number of different modules, each of them has some sort of state and some states share the same fields as each other but not all. For each possible field there is a type class with get and set methods which means we can use general functions on the different kinds of state as long as the correct instances are defined. Is that abusing type classes?
06:36:00 <int3__> Cale: I do know how to write it 'by hand', I was wondering whether there was a recursion scheme that already covered it
06:36:31 <Cale> int3__: This is the catamorphism for the type
06:36:35 <merijn> Anyone have a good heuristic for what size to pass to hGetSome?
06:36:44 <Cale> (what I wrote)
06:36:59 <int3__> Cale: right, I thought that was the name for it. can I get catamorphisms derived automatically?
06:37:33 <Cale> mmmm: So long as the fields are actually related to each other and don't just happen to have the same name, it's not too abusive.
06:38:41 <Cale> If you're just trying to sidestep the fact that you can't name things the same way, I'd just say bite the bullet and add prefixes or something to make the names actually different. If you're not going to really make use of the polymorphism that the typeclass affords you somehow, then you're abusing the typeclass.
06:39:18 <Cale> int3__: Not in plain Haskell.
06:39:24 <mmmm> ok thanks
06:39:31 <int3__> Cale: so my tree is actually of the form `data Tree a = Branch a [(k, Tree a)]`, which is why I didn't just use Data.Tree... instead I used Cofree on [(k, a)], and the cofree library provided an unfold function so I didn't need to write it by hand, which was nice. it doesn't seem to provide a fold function though, and I'm wondering where to look for that
06:39:34 <hpc> merijn: the default block size is 4096
06:40:02 <hpc> merijn: are you getting a network resource or a local resource?
06:40:04 <int3__> sorry, I hope that was a clearer explanation of my question ^
06:40:07 <merijn> hpc: Network
06:40:11 <Cale> int3__: If you redefine your tree type in terms of a fixed point datatype and a particular functor, then you can have a generic cata which works on such things.
06:40:12 <merijn> hpc: Well, both, really
06:40:38 <Cale> ah
06:41:26 <hpc> merijn: start with 4096 and see what issues arise
06:41:54 <hpc> (for huge files where you know the network is reliable, you can probably bump it up to jumbogram range, for instance)
06:41:58 <joe9> http://codepad.org/GPCNogTs Any suggestions on how to fix this error, please?  Perhaps you haven't installed the "dyn" libraries for package `mtl-2.1.3.1'?
06:42:08 <tac> Does Parsec have any debugging tool where it shows you a trace of the parse?
06:42:23 <tac> Something like that would be super helpful to me at this moment
06:42:32 <int3__> Cale: hm, does that 'fixed point datatype' mean 'Free'?
06:42:48 <Cale> int3__: Oh, yeah, probably.
06:43:04 <Cale> It's pretty similar
06:43:09 <Cale> (not exactly the same thing)
06:43:44 <int3__> ok, let me see if I can figure this out. thanks!
06:43:49 <Cale> But at least with free, you'd have iter
06:44:00 <tac> oh, figured it out :D
06:44:04 <Cale> iter :: Functor f => (f a -> a) -> Free f a -> a
06:44:20 <Cale> which is not as general as the fold I was thinking of, but it's close
06:44:38 <hpc> merijn: and if you feel like getting fancy, you can write something to increase the block size you request until you are saturated
06:44:49 <hpc> based on the data you receive
06:45:56 <merijn> hpc: Yeah, that'll go on the "Features that I'll forget before I implement them" list ;)
06:46:12 <hpc> ;)
06:46:40 <hpc> it's a pretty fun piece of code to write, though
06:46:59 <hpc> i did something similar for an httpd benchmarking utility, where it spins up threads that are all making serial requests
06:47:05 <hpc> and does this until the answers slow down
06:48:35 <darthdeus> what's the ~ in this? instance t ~ Endo b => Rewrapped (Endo b) t
06:48:58 <hpc> darthdeus: it's the constraint for type equality
06:49:01 <tac> darthdeus: type equality
06:49:12 <darthdeus> meaning t == Endo b?
06:49:23 <hpc> it's different from Rewrapped (Endo b) (Endo b) in ways that i am too sleepy to explain :P
06:49:35 <tac> darthdeus: It means "if t is the same as Endo b, then (whatever term) has type Rewrapped (Endo b) t
06:49:57 <tac> what hpc said. It's the difference between definitional and propositional equality
06:50:22 <darthdeus> uhm not sure if i understand the difference
06:50:31 <tac> they ARE equal. But the compiler isn't trusted to figure it out on its own. So unless you explain to it explicitly that they are equal, the type checker will scratch its head and say "DOESN'T TYPECHECK!"
06:50:55 <darthdeus> but why can't I just write Endo b => Rewrapped (Endo b) (Endo b) ?
06:51:11 <tac> So basically, they are equal. But you have to explain WHY they are equal or else the typechecker will reject your program
06:51:35 <tac> darthdeus: a case where that doesn't work is if you have a newtype equal to Endo b
06:51:51 <tac> like newtype Blah = Endow b
06:52:14 <darthdeus> hmmm
06:52:21 <darthdeus> so ~ would work even through newtypes?
06:52:22 <merijn> Well, technically ~ means the two types unify
06:52:25 <tac> Blah is equal... but not by definition.
06:52:40 <darthdeus> like "equal no matter how much it is wrapped in newtypes"
06:52:55 <tac> It's the equality type in System Fc, isn't it merijn ?
06:53:07 <tac> p. much, unless merijn wants to correct me :)
06:53:18 <darthdeus> cool, now it makes sense :)
06:53:26 <merijn> (Maybe a ~ Maybe Int) IFF "a ~ Int"
06:53:56 <hpc> wait, (~) goes through newtypes?
06:54:03 <tac> merijn: is ~ really not the same as propositional equality?
06:54:04 <merijn> tac: Well, a polymorphic and monomorphic type aren't equal, but CAN unify
06:54:15 <darthdeus> so if I say "a ~ Int", then I can say "Sum 3 ~ 3"?
06:54:35 <tac> merijn: well yeah, but you're better of thinking of a polymorphic type as a System F term with some inference ;O
06:54:37 <darthdeus> Sum being the newtype monoid wrapper htingy
06:54:43 <tac> but tac /opinions
06:54:49 <merijn> darthdeus: That doesn't make any sense, I think?
06:54:55 <merijn> darthdeus: 3 is not a type (usually...)
06:55:28 <darthdeus> merijn: no i mean that if i have like "a ~ Int", then that means I can put "Sum 3" in place of "a" and it would work, since Sum is a newtype wrapper?
06:55:38 <tac> Int ~ Sum is the thing you want, I think
06:55:41 <tac> err
06:55:42 <tac> maybe
06:55:44 <tac> @kind Sum
06:55:45 <lambdabot> * -> *
06:55:50 <tac> > Sum 3 <> Sum 4
06:55:51 <lambdabot>  Sum {getSum = 7}
06:55:55 <tac> @type Sum
06:55:56 <lambdabot> a -> Sum a
06:56:01 <tac> hmmm
06:56:18 <merijn> You can write "Int ~ Sum", but that constraint should never hold
06:56:22 <tac> w/e >_>
06:56:29 <tac> yeah
06:56:29 <darthdeus> uhm
06:56:30 <hpc> > 3 :: (Int ~ Sum Int => Int)
06:56:31 <lambdabot>  Couldn't match type ‘GHC.Types.Int’
06:56:31 <lambdabot>                with ‘Data.Monoid.Sum GHC.Types.Int’
06:56:31 <lambdabot>  Inaccessible code in
06:56:31 <lambdabot>    an expression type signature:
06:56:31 <lambdabot>      GHC.Types.Int ~ Data.Monoid.Sum GHC.Types.Int => GHC.Types.IntCouldn't m...
06:56:32 <tac> I thought Sum was different
06:57:00 <darthdeus> is there a simple example of ~ that makes sense? it's kinda hard for me to understand it in abstract terms
06:57:17 <tac> you could read the System Fc paper. It's not too bad, I don't think
06:57:23 <merijn> darthdeus: I have an example, but it includes some more type abuse like TypeFamilies/DataKinds, so I'm not sure it helps :)
06:57:28 <tac> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
06:57:30 <merijn> Any pipes wizards around?
06:57:42 <darthdeus> merijn: type families and data kinds are sort of ok I guess :)
06:57:55 <merijn> darthdeus: https://gist.github.com/merijn/6130082
06:57:58 <darthdeus> tac: does it make sense to read that if i dont know system f?
06:58:03 <tac> darthdeus: oh, ~ is also really useful for GADTs and a few other Haskell features I don't personally use.
06:58:15 <hpc> System F is pretty simple
06:58:18 <tac> darthdeus: I'd say learn some System F ^^
06:58:28 <tac> It's actually really great if you want to learn the core
06:59:02 <tac> Benjamin Pierce does a fantastic job in Chapter 23 in his book, Types and Programming Languages
06:59:05 <darthdeus> merijn: hmm, that's maybe a little bit beyond my understanding :D not sure how the first and second pattern match differ
06:59:27 <darthdeus> tac: heh that book is on my wishlist :P maybe time for buying it then :\
06:59:29 <tac> darthdeus: If I had a little more time, or if you catch me later, I can explain the basics
06:59:47 <darthdeus> tac:  i'll probably be here a long time today
07:00:15 <merijn> darthdeus: The first pattern has the type variable 'a' twice, the other once
07:00:30 <darthdeus> oh right
07:00:31 <darthdeus> hmm
07:00:44 <merijn> darthdeus: So the first only matches if 'a' is equal to the type at the head of the list
07:01:01 <tac> I highly recommend TaPL. It is very technical in places, but miraculously, you can ignore almost all the technical details and just learn the basics of each language and extension it presents
07:01:03 <darthdeus> merijn: so this basically means the list must have all different types?
07:02:26 <darthdeus> tac:  does it have to be read sequentially or can i just skip over to chapter 23? :)
07:02:54 <tac> You can skip a ton of it. The book goes on and on about subtyping
07:02:57 <merijn> darthdeus: No, it means the first argument to Restrict is not allowed to be in the list
07:03:21 <darthdeus> merijn: yeah but then it recurses to the rest
07:03:27 <darthdeus> oh but it still uses x for the recursion
07:03:28 <darthdeus> now i see
07:03:29 <darthdeus> sorry :X
07:04:07 <tac> chapter 1, 3, 5, 8, 9, optionally 11/14, then finally 22 and 23.
07:04:09 <btcNeverSleeps> I don't know if my question makes sense but... If a function takes the State monad as an argument and does not modify it, shouldn't that function not take the monad as an argument but simply the value contained inside the monad?
07:04:12 <darthdeus> so foo is identity "given any type except () and Int"
07:04:45 <merijn> btcNeverSleeps: "State s x" *is* a value
07:04:56 <tac> basically, you build up your understanding of evaluation-based languages in the first few chapters
07:05:04 <merijn> btcNeverSleeps: There is no value *inside* State
07:05:05 <tac> show how to do simple types with them to prevent badness
07:05:19 <merijn> btcNeverSleeps: State is a "stateful computation that produces a result"
07:05:24 <btcNeverSleeps> merijn: so a function taking "State s x" can still be pure?
07:05:35 <merijn> btcNeverSleeps: *everything* in haskell is pure
07:05:47 <merijn> There are no impure things (unless you use unsafePerformIO)
07:05:55 <tac> the optional stuff is a bunch of cool topics on how to do more advanced things (recursion, disjoint union types, ML-style mutable references, exceptions)
07:06:00 <tac> then jump into System F
07:06:42 <btcNeverSleeps> merijn: ok but... A function which takes the State monad can still modify the monad right?
07:07:15 <darthdeus> tac: hmmm, interesting
07:07:17 <merijn> What does "modifying the monad" mean? :)
07:07:37 <btcNeverSleeps> returning a monad which is not the same as the one that what passed to the function?
07:07:42 <merijn> btcNeverSleeps: btw, I would recommend reading this post (it talks about IO, but all the same logic applies to State): http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
07:07:58 <merijn> btcNeverSleeps: Can you give me the type of the function you're talking about?
07:07:59 <int-e> merijn: change its functor or join?
07:08:04 <btcNeverSleeps> merijn: bookmarked
07:08:46 <btcNeverSleeps> merijn: wait, watched many YouTube Haskell videos, don't remember in which one it was
07:08:48 <Cale> btcNeverSleeps: Monads are not values.
07:08:52 <int-e> @type lift -- hmm.
07:08:53 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
07:09:08 <Cale> State s is a monad for any type s. Maybe is a monad. IO is a monad. get is not a monad, Just 5 is not a monad, getLine is not a monad.
07:09:20 <int-e> (lift "changes the monad".)
07:09:21 <merijn> int-e: "Bro, do you even (MonadTrans t, Monad m) => m a -> t m a?!"
07:11:00 <mwhit> btcNeverSleeps: those issues aside, probably what you want is to just fmap your function inside the State s functor
07:11:25 <btcNeverSleeps> ok, found it: it's here, can be seen for example at 14:28    https://www.youtube.com/watch?v=4q3v2p2-Cmc
07:13:20 <btcNeverSleeps> there are two functions: "terminator" and "terminator'", both having the State monad in their type signature, for a IntMap used to cache/memoize results
07:13:22 <varnie> hello. I am a novice in Haskell seeking for wisdom. I don't get why does the following program outputs two different results: http://lpaste.net/108185 . Could you enlighten me?
07:14:01 <btcNeverSleeps> damnit... I take it it's a bad example because the functions are mutually recursive: it's not the question I had in mind
07:14:21 <int-e> > length . lines $ "abc\ndef"
07:14:22 <lambdabot>  2
07:14:42 <int-e> btcNeverSleeps: that string has 1 newline character but 2 lines.
07:15:23 <merijn> btcNeverSleeps: I think people overthink the whole "monad in the function type signature", "terminator is a function that takes an Int and returns a value of type "State (IntMap Foo) Int" (or whatever it was)
07:16:33 <merijn> btcNeverSleeps: Values of types "State (IntMap Foo) Int", represent computations that have an "IntMap Foo" as state and produce an Int
07:16:50 <merijn> And you can run these computations using runState
07:17:12 <btcNeverSleeps> merijn: ok but in a case where I'd only to read a key/value from the IntMap, why should I pass a State monad to my function?  Why not directly pass the IntMap?
07:17:34 <merijn> btcNeverSleeps: Where are you "passing a State monad to your function"?
07:17:45 <varnie> int-e, you were responding to my question?
07:18:05 <int-e> varnie: err, yes. sorry.
07:18:10 <merijn> btcNeverSleeps: The idea of State is to automate the plumbing of State, it is in fact LITERALLY the same thing as passing function arguments
07:18:31 <merijn> btcNeverSleeps: You can see this when you implement your own State monad (which is a good exercise for seeing how it works)
07:18:45 <btcNeverSleeps> merijn: ok, I'll try to do so
07:18:45 <varnie> int-e, is it possible to fix that buggy function?
07:18:53 <merijn> btcNeverSleeps: If you want homework, take these type signatures and implement the functions + their Functor/Monad instance
07:19:46 <merijn> btcNeverSleeps: "data MyState s a = MyState (s -> (a, s))", "get :: MyState s s", "put :: s -> MyState s ()", "modify :: (s -> s) -> MyState s ()"
07:20:04 <btcNeverSleeps> but it's still not clear: if I'm returning a State monad, I can somehow "carry" / return / transport / etc. the result of a computation right?
07:20:25 <merijn> "instance Monad (MyState s) where"
07:21:07 * hackagebot free-game 1.1.78 - Create games for free  http://hackage.haskell.org/package/free-game-1.1.78 (FumiakiKinoshita)
07:21:08 <merijn> btcNeverSleeps: When you return the "State (IntMap Foo) Int" you are returning a computation that can be run (or discarded, or run multiple times)
07:22:01 <btcNeverSleeps> ok and can I have a function which both accept a "State (IntMap Foo) Int" and also return a "State (IntMap Foo) Int"?
07:24:41 <int3__> okay I've gotten myself all confused over what's probably a rather simple thing, but... how do you define lists in terms of Free?
07:24:51 * DogeDylan Get FREE Bitcoins at http://www.123bit.com/index.php?page=free-bitcoins
07:24:59 <int3__> in particular, how do you define the empty list, when Pure a contains a value of type 'a'?
07:25:18 <btcNeverSleeps> The thing I *think* I really don't understand is this: if "State (IntMap foo) Int" represents a computation which can be run/discarded/etc. and I pass it to a function which return, also, a "State (IntMap foo) Int", how do I know if the "State (IntMap foo) Int" passed to the fn represent the same computation as the one given back by the fn?
07:25:57 <merijn> btcNeverSleeps: You don't and you can't
07:26:14 <merijn> btcNeverSleeps: The same way you can't know that "f :: Int -> Int" returns the same Int that you give it
07:26:47 <int3__> all the examples I've seen say 'lists are free monads', and '[]' is analogous to 'Pure a', but... it seems like an imperfect analogy
07:27:16 <btcNeverSleeps> merijn: so I take it I'm back to very first question... In case I'm *not* going to give back another computation (iow: I'm not going to "modify" the monad), the type signature does not help me. Am I then not better to simply pass the IntMap to my function?
07:27:45 <Cale> btcNeverSleeps: You can take a computation as a parameter and have a function which modifies it
07:27:46 <merijn> btcNeverSleeps: "It depends"
07:28:28 <Cale> Note, the State computation value itself shouldn't be referred to as a monad. Monads are type constructors, they're things which live to the right of the ::
07:29:12 <Cale> If you said "modify the monad", people would think of an operation whose type looked something like M a -> N a or something, where M and N are monads
07:29:21 <btcNeverSleeps> oh I see
07:29:32 <Cale> (different monads)
07:29:52 <btcNeverSleeps> I'm using an incorrect terminology because I'm just starting : )
07:30:00 <Cale> yeah, it's a common thing
07:30:03 <btcNeverSleeps> By the way does my question make sense ?
07:30:12 <Cale> yeah, I sort of know what you're asking
07:30:33 <Cale> You can't know whether or not something of that type is the identity function or not without really looking at what it does
07:30:57 <Cale> For example, it might be  foo x = do v <- x; v <- x; return (v + v)
07:31:11 <Cale> Or any number of other things
07:31:53 <Cale> If you give me an action x, I might use it to build another action which runs x many times, and does something with the results.
07:32:10 <Cale> You can use this to construct control structures
07:32:33 <Cale> In fact, that's kind of the whole point of the monad abstraction, is that there are lots of control-structure-like operations which will work using any monad
07:32:49 <Cale> as a primary example, consider
07:32:56 <Cale> sequence :: (Monad m) => [m a] -> m [a]
07:33:05 <btcNeverSleeps> ok
07:33:28 <Cale> sequence is a function which takes a list of actions (whose result has type a), and produces a single action which when executed will run them all and collect a list of results
07:33:42 <Cale> We can write it recursively like this:
07:33:48 <Cale> sequence [] = return []
07:34:02 <Cale> when the list is empty, we just produce the action which does nothing, but results in the empty list
07:34:14 <Cale> (which is what return is for)
07:34:22 <Cale> sequence (x:xs) = do ...
07:34:27 <btcNeverSleeps> return "wraps" [] inside a monad?
07:34:51 <Cale> return v is the action which "does nothing" (whatever that means in context), except to produce v as its result
07:35:16 <btcNeverSleeps> it produces v as its result, but inside a container?
07:35:45 <varnie> int-e, sorry for bothering you. I finally fixed it. thanks for the hint.
07:35:53 <Cale> For each monad, there will always be some kind of interpretation for what it means to "run" the actions. For the list monad for instance, "running" a list means to pick an element from it in all possible ways
07:36:04 <btcNeverSleeps> ok ok
07:36:10 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
07:36:12 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
07:36:19 <int-e> varnie: one can hack something with foldBytes, but a proper solution would use 'lines' and Control.Monad.Free.iter or iterM, I have not thought this through to the end.
07:36:50 <Cale> So, here "running" the list [1,2,3] results in x being bound to either 1, 2, or 3, and in the end, we collect all the possibilities generated from these choices into a list
07:37:11 <int-e> varnie: no worries. It's just that I have not used pipes myself, so had to explore a bit.
07:37:12 <Cale> (this is pretty much the same thing as a list comprehension)
07:37:23 <Cale> in the list monad, we have return v = [v]
07:38:01 <Cale> It might be a little hard to see why that's the right interpretation for "does nothing"
07:38:05 <btcNeverSleeps> that makes sense: it's actually the only context in which I've used return so far
07:38:10 <Cale> okay
07:38:14 <joe9> can anyone please help with this: http://codepad.org/fMSd25XZ . I cannot install darcs with a new cabal-install
07:38:26 <joe9> It says it is missing profiling libraries of mtl.
07:38:36 <Cale> so in the State monad's case, return v is a computation which when executed won't change the current state, but will result in v
07:39:07 <Cale> Or in the IO monad's case, return v is an IO action which doesn't do anything, but again results in v
07:39:17 <varnie> int-e, it is weird than in many tutorials when author speaks about basic functions (Prelude), he/she shows that example of lines count using length and lines functions.
07:39:25 <varnie> s/than/that/
07:39:28 <Cale> btcNeverSleeps: Okay, so back to sequence...
07:39:41 <Cale> sequence (x:xs) = do ...
07:40:02 <Cale> If the list is nonempty, we know we want to run x at least, so...
07:40:07 <Cale> sequence (x:xs) = do v <- x; ...
07:40:12 <Cale> we'll do that, getting some result v
07:40:28 <Cale> and then we want to run the rest of the list of actions xs, and we'll do that recursively:
07:40:35 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
07:40:41 <pjdelport> For any functorial structure, "pure a" (a.k.a. "return a") represents a distinguished "default structure" that you can insert a pure value into.
07:40:43 <Cale> getting some list of results vs
07:41:15 <btcNeverSleeps> :t sequence
07:41:16 <lambdabot> Monad m => [m a] -> m [a]
07:41:24 <Cale> and then we want the result of our overall action to be the combined list (v:vs), so in order to accomplish that, we'll use return, as the result of the action we're writing is the result of the last action in the do-block
07:41:29 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:42:08 <Cale> So, in the list monad, sequence applied to a list of lists is going to run each of the lists, collecting up a list of results in all possible ways
07:42:18 <Cale> and recalling that "running" a list means picking an element from it
07:42:27 <btcNeverSleeps> ok
07:42:33 <Cale> this will amount to finding a Cartesian product of sorts:
07:42:38 <btcNeverSleeps> and sequence works on any monad?
07:42:43 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
07:42:44 <Cale> yes
07:42:44 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
07:43:07 <tibbe> How do I create a Data.Vector.Mutable from a list? I expect a fromList but I can’t find one.
07:43:14 <btcNeverSleeps> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
07:43:16 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
07:43:25 <Cale> That type signature says "for any monad m, sequence will accept a list of m-computations with results of type a, and produce an m-computation whose results have type [a]"
07:44:03 <pjdelport> If i may drive-by comment for a moment, i'd just like to add that i like the Applicative derivation of sequence a whole lot more.
07:44:24 <Cale> tibbe: thaw an immutable vector perhaps?
07:44:33 <arianvp> Hey guys
07:44:45 <Cale> pjdelport: Well, yes, there's a very pretty way to write sequence as a foldr
07:44:55 <Cale> But for beginners, I don't think it's as helpful
07:45:02 <tibbe> Cale: yea, sounds a bit inefficient though
07:45:03 <arianvp> I want to pass extra options in Cabal to ghc.  so I used   `ghc-options: --with-js=./lib/bundle.js`
07:45:09 <arianvp> but -- is consired as a comment
07:45:10 <btcNeverSleeps> well, I've got more reading and experimentation to do for sure but your explanations really helps
07:45:25 * btcNeverSleeps will brb
07:45:40 <Cale> btcNeverSleeps: So, yeah, for the IO monad, we can take a list of IO actions and combine them into an IO action producing a list of results
07:45:44 <pjdelport> Cale: Maybe, but as a beginner, sequence didn't really make sense for me until i learned the applicative version of it.
07:46:00 <pjdelport> So it may help for some folks, at least. :)
07:46:15 <Cale> btcNeverSleeps: like   sequence [getLine, readFile "foo.txt"]
07:46:23 <Cale> pjdelport: That's interesting
07:46:43 <Cale> pjdelport: Usually I don't even really consider introducing Applicative until people are comfortable with Monad
07:47:46 <arianvp> Anyone got a clue?
07:48:20 <Cale> arianvp: does it work to use quotes?
07:48:32 <pjdelport> Cale: I'm a huge fan of the other way around: Functor, then Applicative, then Monad. I didn't understand Monad until after I understood the others as foundation.
07:51:04 * merijn mumbles something grumpy about lack of recursive imports
07:51:09 * hackagebot lifted-async 0.2.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.2.0.1 (MitsutoshiAoe)
07:51:41 <Cale> pjdelport: I guess Applicative is still a bit of a second-class citizen in my head. There are not *so* many libraries which define Applicatives that aren't also Monads
07:52:25 <Cale> and I sort of feel that (<*>) is probably harder to explain than (>>=) for people who are new, but maybe I'm wrong in some cases
07:52:30 <pjdelport> btcNeverSleeps: To understand sequence from the Applicative perspective, recall that Applicative simply lets you perform function application "lifted" into any functor (or any applicative functor).
07:53:03 <pjdelport> So, for example, a pure application: (++) "foo" "bar"  (results in "foobar")
07:53:08 <Cale> Yeah, that's... just saying that it's "lifted" doesn't tell you anything about what it's doing.
07:53:27 <Cale> It says something about the type it should have
07:53:32 <Cale> but not about the behaviour
07:53:47 <pjdelport> And an Applicative application, in IO in this case: (++) <$> getLine <*> getLine  (reads two lines, and yields the concatenation of them)
07:54:43 <pjdelport> and synonymously to <$> and <*> you can also use the liftA* helpers: liftA2 (++) getLine getLine
07:55:47 <pjdelport> So the core idea is just that you can take any function of pure values and turn it into a function of *functorial* values using those lifted application operations.
07:56:29 <merijn> Man, I wish fromIntegral had a shorter name...
07:57:23 <Cale> merijn: fI = fromIntegral
07:58:31 <Cale> merijn: It tends to be a rather expensive operation though, so if you care about performance, leave the name annoying to type so you'll be tempted to reduce the number of times it occurs when possible ;)
07:59:10 <merijn> Cale: I'm parsing a binary protocol where I get values as Word64, but all ByteString operations demand Int :\
07:59:44 <Cale> merijn: yeah, not so much you can do about that :/
08:00:04 <Cale> I kind of hate all the specialisation to Int which occurs.
08:01:32 <pjdelport> Now consider a *list* of functorial values, like [getLine, getLine, getLine]
08:01:33 <pjdelport> Lists are of course just applications of (:) and [] under the hood: (getLine : (getLine : (getLine : [])))
08:03:39 <pjdelport> What happens if you lift the applications of (:) and [], to take them from outside of the functor to inside it? You get something like:
08:03:39 <pjdelport> let (#:) = liftA2 (:); nil = pure [] in (getLine #: (getLine #: (getLine #: nil)))
08:06:42 <pjdelport> Now, just like "liftA2 (++) getLine getLine" reads two lines and yields (++) applied against those lines, the above will read several lines, and apply (:) to them, building a list of the individual results.
08:08:17 <pjdelport> The similarity to pure application is key: ("foo" : ("bar" : ("baz" : []))) versus (getLine #: (getLine #: (getLine #: nil)))
08:13:00 <pjdelport> For *any* function application, you can turn it into an Applicative application by inserting functorial values (that is, replacing "foo", "bar", and "baz" with getLine above), and then lifting the rest (that is, liftA2 (:) and pure [] above)
08:14:01 <angerman> if I have data `MyData = MyFnConstr (Int -> Int) | MyValueConstr Int`, can I implement `pure` to make it part of the Applicative class? I have some trouble dispatching on the type of `x` in `pure x = ...`
08:15:22 <pjdelport> It works with any functorial value, so:
08:15:23 <pjdelport> > let (#:) = liftA2 (:) in (Just 'a' #: (Just '1' #: (Just 'x' #: Just [])))
08:15:24 <lambdabot>  <hint>:1:8: parse error on input ‘)’
08:16:54 <pjdelport> Weird. Why doesn't lambdabot like that?
08:17:45 <benmachine> > let (#:) = 3 in 4
08:17:46 <lambdabot>  <hint>:1:8: parse error on input ‘)’
08:17:59 <benmachine> > let ($:) = 3 in 4
08:18:01 <lambdabot>  4
08:18:17 <pjdelport> Works in ghci. Oh well:
08:18:17 <pjdelport> > let (-:) = liftA2 (:) in (Just 'a' -: (Just '1' -: (Just 'x' -: Just [])))
08:18:18 <lambdabot>  Just "a1x"
08:18:56 <pjdelport> So that's just the Applicative way of saying:
08:18:56 <pjdelport> > ('a' : ('1' : ('x' : [])))
08:18:58 <lambdabot>  "a1x"
08:19:31 <pjdelport> But of course, with Maybe, you can have Nothing in the mix:
08:19:31 <pjdelport> > let (-:) = liftA2 (:) in (Just 'a' -: (Nothing -: (Just 'x' -: Just [])))
08:19:32 <lambdabot>  Nothing
08:20:21 <hask3> Here is a diagram of functions calling each other in a haskell program: http://f.cl.ly/items/3D0d1F2N011S1f1R2m2c/haskell-function-calls.png
08:20:22 <hask3> Is this an accurate depiction of the impure vs. pure parts of the program?
08:20:23 <hask3> Sort of like the "dirt" begins at main and goes down like a "tree". At some point, when we hit a pure function (ordinary function), the dirt stops and we're pure from there.
08:20:24 <hask3> Is this accurate?
08:20:26 <pjdelport> Using lists, you get choice instead:
08:20:26 <pjdelport> > let (-:) = liftA2 (:) in ("abc" -: ("123" -: ("xyz" -: Just [])))
08:20:27 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
08:20:28 <lambdabot>  Expected type: [[GHC.Types.Char]]
08:20:28 <lambdabot>    Actual type: Data.Maybe.Maybe [GHC.Types.Char]
08:20:37 <NikolajK1> the wikipedia page
08:20:38 <NikolajK1> http://en.wikipedia.org/wiki/Monad_(functional_programming)#Monad_laws
08:20:38 <NikolajK1> says "The ≡ symbol indicates equivalence between two Haskell expressions in the following text." and then goes on to use ≡ and = alternatively. Is this just an artifact of different authors?
08:20:39 <pjdelport> > let (-:) = liftA2 (:) in ("abc" -: ("123" -: ("xyz" -: [[]])))
08:20:41 <lambdabot>  ["a1x","a1y","a1z","a2x","a2y","a2z","a3x","a3y","a3z","b1x","b1y","b1z","b2...
08:20:45 <Cale> angerman: Your type has the wrong kind to be an instance of Applicative
08:20:57 <Cale> angerman: (or Functor, for that matter)
08:21:07 <Cale> angerman: It needs to have a type parameter
08:21:13 <Cale> :k Maybe
08:21:14 <lambdabot> * -> *
08:21:17 <Cale> :k Maybe Integer
08:21:17 <lambdabot> *
08:21:21 <Cale> :k IO
08:21:22 <lambdabot> * -> *
08:21:27 <Cale> :k Either
08:21:28 <lambdabot> * -> * -> *
08:21:30 <Cale> :k Either Integer
08:21:31 <lambdabot> * -> *
08:21:35 <Cale> :k Either Integer String
08:21:36 <lambdabot> *
08:21:51 <Cale> Functors need to have kind * -> *
08:21:59 <pjdelport> So the point of all the above examples is that they all fundamentally do the same thing: they lift the application of the (:) constructor from outside the functor to inside it.
08:22:56 <angerman> Cale: ok. thanks :D That's what I tried to figure out. If I was either too stupid to write pure or if there was something higher holding me back.
08:23:32 <pjdelport> And if you want to do that more generically for any list, you can start with the identity fold, which replaces each constructor with itself: foldr (:) []
08:23:32 <pjdelport> and then change it so that it replaces each constructor with its lifted equivalent: foldr (liftA2 (:)) (pure [])
08:24:26 <benmachine> NikolajK1: there is a distinction, but sometimes it's just a mistake
08:24:52 <pjdelport> And you can also see from its type that it lifts the constructors into the functor:
08:24:52 <pjdelport> :t foldr (liftA2 (:)) (pure [])
08:24:53 <lambdabot> Applicative f => [f a] -> f [a]
08:24:55 <NikolajK1> benmachine: I've seen you discussing your name on SE or MO :)
08:25:04 <lf94> Excuse my ridiculously bad Haskell, but I was wondering if there was some elegant way to store  bjbj_discount x 0.25 into a variable to use twice?...: http://paste.debian.net/111784/
08:25:31 <angerman> Cale: I'm writing down all I think I have understood that far, and was trying to keep things as simple as I could, thus ending up with an unparameterized data type, trying to make it a functor
08:26:15 <benmachine> NikolajK1: oh, neat
08:26:31 * hackagebot Plot-ho-matic 0.4.0.1 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.4.0.1 (GregHorn)
08:26:31 <benmachine> NikolajK1: yeah I kinda ought to change my IRC nick as well, but haven't got around to it
08:26:52 <NikolajK1> how is "1/0 equal to Infinity" justified?
08:27:01 <benmachine> NikolajK1: in what context?
08:27:03 <Nik05> not
08:27:15 <NikolajK1> it's what the prelude does
08:27:24 <NikolajK1> and -0/1 is -Inifnity
08:27:34 <NikolajK1> ah, I mean -1/0
08:27:41 <benmachine> lf94: looks like you only use it once?
08:27:50 <lf94> I know, I want to use it twice...
08:27:56 <benmachine> NikolajK1: oh, that's floating point
08:28:23 <NikolajK1> and by the way, is there a correspoinding algberaic 2 element extension of the rationals where this all works out
08:28:32 <benmachine> NikolajK1: it's not completely unreasonable, especially if you consider 0 as "a very small positive number" and Infinity as "too big to be represented"
08:28:33 <NikolajK1> choosing the signs seems arbitrary
08:28:53 <benmachine> NikolajK1: in floating point numbers there is a distinct concept of negative zero
08:29:13 <benmachine> which compares equal to positive zero, but has different results when you divide one by it
08:29:19 <pjdelport> hask3: That's more or less accurate, yeah.
08:29:24 <benmachine> if this sounds mathematically indecent to you you're not the only one to have noticed
08:29:30 <benmachine> lf94: yes there's a way to do it, sec
08:29:40 <hask3> pjdelport: ok. good to know.
08:29:46 <lf94> benmachine: essentially I want to do this: (bjbj_discount x 0.25) - ((bjbj_ldiscount (bjbj_discount x 0.25) 0.05) + (bjbj_ldiscount (bjbj_discount x 0.25) 0.07))
08:29:52 <tgeeky> benmachine: zero from below, zero from above! but not motivated by good reasons, just hysterical raisins, right?
08:30:01 <hask3> pjdelport: but what do haskell programmers do if they want to, all of a sudden, output some stuff they're doing WAY DEEP in some pure function?
08:30:05 <lf94> But obviously it's inefficient to run the same function 3 times
08:30:11 <tgeeky> or implementation details, I guess
08:30:11 <lf94> benmachine: gotchya :)
08:30:14 <pjdelport> hask3: Lift the pure function :)
08:30:27 <NikolajK1> I'd instantly find it mathematically decent once I know which proper algebraic theory is employed, if there is one - then I just say this system is implemented
08:30:47 <benmachine> lf94: http://paste.debian.net/111785/
08:30:53 <hask3> pjdelport: ok i'll keep that in mind when I get to lifts in LYAH. not there yet
08:30:54 <hask3> thx
08:31:06 <pjdelport> hask3: The examples i gave just before you asked are a good example of it.
08:31:10 <lf94> Ah! Forgot about that
08:31:12 <lf94> Thank you :)
08:31:36 <benmachine> tgeeky: representing arbitrary real numbers in 64 bits is not easy, there could be a lot of argument as to how to do it
08:31:40 <lf94> benmachine: how would I do it for the rest?
08:31:59 <pjdelport> hask3: Pure function: (++) "foo" "bar"
08:31:59 <pjdelport> hask3: Suddenly wanting an IO action in there: pure (++) <*> getLine <*> pure "bar"
08:32:01 <lf94> I could assign them all in the where
08:32:08 <lf94> But surely there's a better way?
08:32:27 <hask3> pjdelport: ok cool
08:32:35 <benmachine> lf94: there's also let z = blah in z + z
08:34:05 <pjdelport> hask3: So a pure application is "f x y ...", and a lifted application is "f <*> x <*> y <*> ..."
08:34:38 <hask3> pjdelport: ok i'll keep that in mind. i've no clue what <*> is yet but i'll get there in LYAH eventually!
08:34:41 <pjdelport> And you use "pure" to lift an arbitrary pure part into the above; so for example: "pure f <*> pure x <*> pure y <*> ..."
08:34:46 <lf94> benmachine: I think a better way is just to return the discount amoutn
08:34:48 <pjdelport> :t (<*>)
08:34:49 <lf94> and then operate
08:34:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:34:53 <lf94> instead of using a where
08:34:58 <pjdelport> :t ($)
08:34:59 <lambdabot> (a -> b) -> a -> b
08:35:07 <benmachine> lf94: very possibly
08:35:45 <benmachine> lf94: also (possibly irrelevant) you can do this http://paste.debian.net/111786/
08:36:00 <pjdelport> hask3: <*> is just a lifted version of function application; you can see that it has the same type as $, except that each part is "in a functor"
08:36:51 <pjdelport> > (+) 2 3
08:36:52 <lambdabot>  5
08:37:00 <pjdelport> > Just (+) <*> Just 2 <*> Just 3
08:37:02 <lambdabot>  Just 5
08:37:06 <pjdelport> > Just (+) <*> Just 2 <*> Nothing
08:37:07 <lambdabot>  Nothing
08:37:17 <pjdelport> > Nothing <*> Just 2 <*> Just 3
08:37:19 <lambdabot>  Nothing
08:38:17 <pjdelport> The above example is lifting the application "(+) 2 3" into Maybe, which lets you fail if any of the parts are Nothing.
08:39:10 <hask3> heh ok
08:39:18 <lf94> benmachine: bjbj_other_discount discounted_price lt
08:39:20 <lf94> whoope
08:39:24 <lf94> benmachine: http://paste.debian.net/111787/
08:40:04 <NikolajK1> when I flatten [[1,2],[],[3]] I get [1,2,3] right? (forgot how flatten is called in the prelude)
08:40:10 <pjdelport> hask3: It may also help to read the the pure version as: (+)  $  2  $  3
08:40:19 <pjdelport> to make the funtion applications explicit
08:40:38 <pjdelport> Note that all we did was just replace each $ with <*>
08:40:47 <dv-_> NikolajK1: concat
08:42:48 <pjdelport> hask3: So in terms of your diagram, you can think of the functorial values as the red parts of the program, and the pure parts (i.e. everything lifted with "pure x" or equivalent) as the blue parts.
08:44:22 <benmachine> lf94: makes sense
08:44:31 <hask3> pjdelport: thank you!
08:44:36 <hask3> very elegant
08:44:48 <hask3> IO more flexible than i thought
08:45:55 <pjdelport> hask3: Control.Applicative has several more helpers that are essentially just shortcuts for using <*>.
08:46:05 <hask3> ok
08:46:35 <pjdelport> So instead of "pure (++) <*> getLine <*> getLine", you can say "(+) <$> getLine <*> getLine"
08:46:46 <pjdelport> <$> is like <*> with an implicit "pure" on the left.
08:46:51 <pjdelport> :t (<$>)
08:46:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:47:01 <pjdelport> And you might also recognize it as fmap :)
08:47:07 <hask3> yeah
08:47:52 <pjdelport> Then there are shortcuts for lifting functions of multiple arguments, so you can also say: liftA2 (++) getLine getLine
08:48:09 <mmmm> can you have a typeclass with no methods? Is it idiomatic to do so?
08:48:42 <pjdelport> That's especially nice for partial applications, so you can pass "liftA2 f" to something instead of having to say "\x y -> f <$> x <*> y"
08:48:55 <francesco1> quit
08:52:11 <pjdelport> mmmm: You can, yes.
08:52:31 <pjdelport> mmmm: The use is somewhat limited, of course.
08:53:23 <pjdelport> For example, you could say "class Blessed a", and then have functions like: idBlessed = id :: Blessed a => a -> a
08:53:53 <pjdelport> And then idBlessed will only accept types that you say "instance Blessed Foo" for.
08:54:37 <mmmm> I was planning on using it like this: class MonadParser a; instance (Stream s m t) => MonadParser (ParsecT s st m a)
08:55:54 <mmmm> then I can write other type classes more generally
08:56:11 <mmmm> exploiting the MonadState + MonadReader instances already defined
08:56:24 <xinming_> There is a function named chr in Char module. What does chr stand for please?  (Just for more emphasised memory)
08:57:22 <merijn> xinming_: I think it just stands for char :p
08:58:05 <bob_____> ord is its opposite, meaning ordinal
08:58:46 <xinming_> Ok, Thanks. I'll wrote these down.
08:58:59 <btcNeverSleeps> pjdelport: how long ago did you start learning Haskell?
08:59:28 <xinming_> Just now I tried something like  2^10241024 in ghci, And takes a long time. Seems ghc doesn't have any limit on length :-)
08:59:44 <nisstyre> Integer is unbounded
08:59:48 <xinming_> Yes.
08:59:51 <xinming_> That's what I mean
08:59:58 <nisstyre> Int is not though
09:00:04 <nisstyre> it can overflow
09:00:30 <btcNeverSleeps> and Integer is using GMP under the hood? (I've done some testing and Haskell seem very fast for crypto stuff: 2048-bit integers multiplication, modulo, etc.)
09:00:48 <xinming_> Got it now, Int != Integer
09:00:52 <pjdelport> btcNeverSleeps: A few years, maybe, on and off. I come from a Python background, and started playing with Haskell in my free time, to learn.
09:01:51 <pjdelport> GHC uses GMP, but it also has a pure Haskell Integer implementation you can use (primarily for applications that can't use GMP's license, if i'm not mistaken)
09:02:44 <btcNeverSleeps> I want to use Haskell in production.  Got lots of nasty issues with Java: gigantic codebase, hard to refactor, hard to reason about concurrency (no STM, ...).  So I did learn Clojure and started using it.  But I kinda don't like the "gigantic untyped hashmap" mess that Clojure can be.
09:02:58 <pjdelport> There's been some effort more recently to build a native Haskell library good enough to replace GMP more effectively: https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
09:04:48 <lf94> Why the heck is ghc thinking I want a "Type" String for all my functions:  No instance for (Num String)
09:07:12 <lf94> Here's another:  No instances for (Integral String, RealFrac String)
09:07:36 <lf94> http://paste.debian.net/111793/
09:08:18 <bob_____> try putStrLn (show $ bjbj 70.00)
09:08:51 <lf94> Oh, that fixed that then :)
09:08:59 <merijn> Or "print"
09:09:02 <merijn> :t print
09:09:03 <lambdabot> Show a => a -> IO ()
09:09:55 <btcNeverSleeps> pjdelport: replacing GMP!? Woaw! GMP has to be one of the lib out there with the most crazy assembly optimization.  When a new CPU comes out the GMP dev start analyzing the cpu-cycle every instruction is taking to see if they could shave a few milliseconds here or there : )   It seems like an ambitious project: GMP is never "done", it's an ever moving target.
09:10:25 <lf94> Do I need to explicitly state that this is a float? loyalty_discount = 0.05
09:10:27 <pjdelport> btcNeverSleeps: The goal is just to have it be "good enough".
09:10:52 <haasn> btcNeverSleeps: I *think* the major complaint against GMP is due to its (non-)handling of errors
09:10:55 <pjdelport> btcNeverSleeps: So it will almost certainly be slower by some factor, but the idea is to have that factor be small enough that the advantage of having it be entirely Haskell-native outweigh it.
09:11:07 <pjdelport> (For easier porting, maintenance, etc. etc.)
09:11:20 <haasn> Which can make Haskell programs terminate unexpectedly with no way to catch the error
09:11:21 <GeraldCode> btcNeverSleeps, I also am trying to switch to function al programming
09:11:30 <haasn> Like if GMP tries allocating too much memory
09:11:47 <GeraldCode> just need to learn more, then convince the boss to let me do this instead of PHP/ASP
09:12:12 <arancia> lf94: If the exact type doesn't matter, no
09:12:22 <lf94> hm
09:12:33 <lf94> I really have no idea what's going on then
09:12:46 <lf94> http://paste.debian.net/111794/
09:12:47 <btcNeverSleeps> pjdelport: I've done some (very crude) testing for some crypto algos recently: C + GMP was the fastest, Haskell (using GMP under the hood) was about 20% slower than C + GMP (so quite good), Go + GMP was a bit slower and Java/Clojure's BigInteger was rreeallyy dog slow (Java's BigInteger is so slow for some stuff that there exists Java wrappers around GMP ; )
09:13:27 <arancia> lf94: What error do you get?
09:13:55 <lf94> Ambiguous type variable `a0' in the constraints:
09:14:00 <lf94> I'll pastebin it
09:14:05 <lf94> Fairly large
09:14:08 <arancia> yeah
09:14:26 <lf94> http://paste.debian.net/111795/
09:14:29 <btcNeverSleeps> GeraldCode: I'm using Clojure since nearly two years, so I'm lucky in that I'm already familiar with lazyness (not exactly non-strictness but there are similarities), higher-order functions, etc.  I wonder how long it's going to take to be as productive in Haskell as I'm in Clojure.
09:14:51 <GeraldCode> btcNeverSleeps,  awesome! you have a leg up on me
09:14:59 <GeraldCode> you will probably get good really soon
09:15:14 <lf94> Haskell is so mind bending, I love it
09:15:39 <GeraldCode> I like how painful it is
09:15:43 <GeraldCode> it forces you to do things right
09:15:46 <GeraldCode> which is what I want
09:17:07 <lf94> Heh..."Haskell - Become a sadist today!"
09:17:10 <ClaudiusMaximus> lf94: your problem is   floor a / b   -- needs more fromIntegral, like   fromIntegral (floor a) / b
09:17:43 <btcNeverSleeps> So far Haskell is blowing my mind: I love how easy and concise it is to define ADTs, I like pattern matching a lot, I'm already in love with the Maybe and Either monads but...
09:18:12 <btcNeverSleeps> I'm still quite confused about the do notation and many other things : )
09:18:19 <lf94> :o Woo!
09:18:26 <lf94> Thanks ClaudiusMaximus
09:18:53 <lf94> Alright everything works
09:18:56 <lf94> So sick
09:19:26 <int3__> btcNeverSleeps: heh I just started on haskell a couple of weeks ago too and it's been insanely fun. I'm particularly enamored with abstracting recursion, and haskell has so much of that :D
09:19:35 <pjdelport> btcNeverSleeps: Applicative style is more often better than do notation than people think!
09:20:13 <pjdelport> It's relatively newer, so it probably doesn't have all the awareness that it deserves.
09:20:21 <lf94> ClaudiusMaximus: Is it because of what floor returns? (Integral?)
09:20:22 <btcNeverSleeps> pjdelport: yup, I was considering doing away with the do notation at first but the "problem" is that just sooo many tutorials (and code) are using it that you cannot really ignore it :-/
09:20:23 <arancia> lf94: In general you should give type signatures to all top-level functions, otherwise errors might occur at places different from the actual problem
09:20:39 <lf94> arancia: Yeah I started doing that but more errors appeared
09:20:44 <lf94> So I stopped X)
09:20:53 <lf94> But essentially everything is a Float
09:21:15 <ClaudiusMaximus> lf94: yeah it gets stuck looking for something both Integral (result of floor) and Fractional (argument of /)
09:21:17 <GeraldCode> btcNeverSleeps,  when I realized that do was just sugar it stopped seeming weird
09:21:31 <pjdelport> btcNeverSleeps: Do you have an intuition for how do syntax maps to applicative?
09:21:31 <arancia> You can also fix all types to Float or Double
09:21:44 <lf94> fromIntegral converts to a Num though, so how does that work
09:21:53 <lf94> Are all numbers of Num type?
09:22:15 <benmachine> Num is a class, it's a collection of types, and all numeric types are in it
09:22:18 <pjdelport> For example, "do x <- xs; y <- ys; foo x y"  →  "foo <$> xs <*> ys"
09:22:27 <lf94> Sorry, typeclass, right
09:23:01 <lf94> So / doesn't need an explicit Fractional?
09:23:13 <benmachine> does need Fractional
09:23:15 <benmachine> er
09:23:17 <benmachine> / does need Fractional
09:23:35 <NikolajK1> is there a list somewhere, of all the Kleisli adjunctions worked out for common Haskell monads?
09:23:37 <lf94> But fromIntegral returns Num, does ghc further convert to Fractional?
09:23:57 <benmachine> lf94: fromIntegral returns a type that is in the collection Num, some of those types are also in Fractional
09:24:09 <benmachine> lf94: for example, Float is in Num
09:24:13 <benmachine> so it can choose that
09:24:21 <lf94> Integral is Num too though, isn't it?
09:24:25 <benmachine> (it probably chooses Double, in fact)
09:24:32 <benmachine> Integral is another collection, not a type
09:24:36 <benmachine> it includes Integer
09:24:50 <rwbarton> fromIntegral requires Num for its return type, / additionally requires Fractional
09:24:51 <lf94> So Integer isn't apart of the Num typeclass?
09:25:06 <benmachine> lf94: it is! it's just also a part of the Integral one
09:25:14 <lf94> Holy crap my brain
09:25:39 <benmachine> lf94: sorry :P type classes are one of the more difficult concepts in Haskell, I think
09:25:45 <tgeeky> @src Num
09:25:45 <lambdabot> class  (Eq a, Show a) => Num a  where
09:25:45 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:25:45 <lambdabot>     negate, abs, signum     :: a -> a
09:25:45 <lambdabot>     fromInteger             :: Integer -> a
09:25:47 <lf94> So we make Integral more generic, and then we're good
09:25:49 <tgeeky> @src Integral
09:25:49 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:25:49 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:25:49 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:25:51 <lambdabot>     toInteger           :: a -> Integer
09:25:57 <tgeeky> ^ that might help; or hurt
09:26:02 <rwbarton> you have things upside down a bit I think
09:26:27 <lf94> rwbarton: We're making Integral less generic?
09:26:37 <benmachine> lf94: ok so there are so-called "concrete types" like Integer and Double and Char and String and IO ()
09:26:43 <lf94> Right
09:26:45 <rwbarton> I don't understand that sentence
09:26:52 <arancia> lf94: We add additional contraints
09:27:05 <benmachine> lf94: and then there are "type classes" which are collections of types, and Integral and Fractional and Num are all examples of these
09:27:31 <arancia> :t \x -> fromIntegral x
09:27:32 <lambdabot> (Num b, Integral a) => a -> b
09:27:35 <arancia> :t \x -> fromIntegral x / x
09:27:36 <lambdabot> (Integral a, Fractional a) => a -> a
09:27:43 <btcNeverSleeps> :t <$>
09:27:44 <lambdabot> parse error on input ‘<$>’
09:27:58 <tgeeky> @type (<$>)
09:27:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:28:44 <rwbarton> oh, now I understand the context
09:28:52 <btcNeverSleeps> is this some lambdabot specific syntax or can I do that at my REPL too without having imported Data.Functor (?)  ?
09:29:09 <ReinH> NikolajK1: not afaik but that sounds like a fun project!
09:29:14 <btcNeverSleeps> the @type (<$>) thinggy
09:29:44 <arancia> btcNeverSleeps: @type needs an expression, <$> isn't an expression
09:29:52 <lf94> arancia: fromIntegral x / x <- that changes what fromIntegral returns?...
09:29:55 <btcNeverSleeps> but <$> is like fmap?
09:29:58 <btcNeverSleeps> :t fmap
09:29:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:30:00 <benzrf> btcNeverSleeps: it IS fmap
09:30:04 <benmachine> lf94: so fromIntegral can have type Integer -> Double or Integer -> Rational or Integer -> Integer
09:30:05 <btcNeverSleeps> loool
09:30:10 <benmachine> Int -> Integer
09:30:11 <btcNeverSleeps> nice, one less thing to learn
09:30:14 <davean1> simcity2000: Postgresql has done "document store" for ages, it has JSON, XML, and kv
09:30:21 <ReinH> btcNeverSleeps: wrapping an operator with parens makes it an expression. This is Haskell syntax.
09:30:31 <davean1> simcity2000: and by ages, I mean before any of the other DBs you heard about doing it
09:30:43 <btcNeverSleeps> @type (<$>)
09:30:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:30:52 <arancia> lf94: Hhm, no
09:30:56 <davean1> ssorry, i seem to have been scrolled up
09:30:58 <lf94> No I know I'm wrong
09:30:58 <btcNeverSleeps> works here but says "parse error on input '@'" at my REPL
09:31:07 <lf94> arancia: thank you for your efforts though lol
09:31:11 <ReinH> ghci doesn't have @type, it has :t
09:31:12 <lf94> Really trying over here
09:31:16 <tgeeky> btcNeverSleeps: the @ is because I typed it in private message first
09:31:28 <tgeeky> btcNeverSleeps: many of lambdabot's commands begin with @ but not with :, so I am in the habit of using it.
09:31:40 <btcNeverSleeps> ReinH: thanks...   :t (<$>)    is what I was after
09:31:41 <lf94> benmachine: when you say "can have", you mean the argument can be of type?...
09:31:41 <tgeeky> btcNeverSleeps: but in ghci, things begin with :
09:31:51 <tgeeky> :t (<$>)
09:31:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:31:54 <btcNeverSleeps> tgeeky: got it
09:32:01 <benmachine> lf94: right. fromIntegral adopts a different type depending on where and how you use it
09:32:10 <benzrf> lf94: ad-hoc polymorphism!
09:32:13 <benmachine> lf94: oh, wait, no
09:32:15 <lf94> Yeah
09:32:20 <lf94> I think that part of it is confusing me
09:32:23 <benmachine> lf94: I mean fromIntegral can *be* that type
09:32:34 <lf94> It's a function though
09:32:39 <benmachine> you can use fromIntegral where you need a function of type Int -> Integer
09:32:44 <ParahSailin_> "However it is a common strategy to serialize data structures to something like a JSON string and then save them to a SQL column - Persistent now automates this process." does anyone know if this is documented somewhere?
09:32:46 <benmachine> or of type Integer -> Double
09:32:52 <NikolajK1> ReinH: I conjecture that all the monads using pairs in some way (state, writer, …) could turn out to actually nontrivial (but well known) adjoints. And in particular, I'm interested in seeing how the Continuation monad turns out - it must be something big, functor to Cat or so. After all, the monad maps types a to (a->r)->r, i.e. Hom(Hom(A,-),r) … i.e. the return map is an explicit morphism guarantieed by the Yoneda lemma Hom(Hom(A,-),Fr)=Fa for F
09:33:10 <benzrf> ParahSailin_: that sounds like a terrible idea
09:33:15 <lf94> benmachine: ok
09:33:15 <ReinH> NikolajK1: continuation monad is a yoneda embedding
09:33:16 <pjdelport> @src fromIntegral
09:33:16 <lambdabot> fromIntegral = fromInteger . toInteger
09:33:30 <ParahSailin_> benzrf: how so?
09:33:34 <benmachine> NikolajK1: hold on, be careful with what your Homs, they don't type-match
09:33:41 <NikolajK1> ReinH: It's what I read, also on nLab, but I don't really see it yet
09:33:56 <benmachine> NikolajK1: Cont isn't that related to Yoneda as far as I know
09:34:07 <ReinH> benmachine: it definitely is
09:34:10 <benmachine> NikolajK1: it's worth mentioning that each monad can come from several different adjunctions
09:34:13 <pjdelport> fromIntegral is a helper; fromInteger and toInteger are methods of Num and Integral, respectively.
09:34:20 <lf94> Thank you everyone for explaining this to me, really appreciate it
09:34:30 <benzrf> ParahSailin_: for the same reason people use SQL instead of saving their data to named files
09:34:35 <NikolajK1> the embedding would be a to forall b.a->b
09:35:00 <NikolajK1> at least on wikipedia, they fix an "return type R", so it's obscured and I don't see it
09:35:02 <ReinH> newtype Yoneda = Yoneda { runYoneda :: forall b. (a -> b) -> f b }
09:35:06 <ParahSailin_> postgresql has supported json fields for several years now
09:35:12 <NikolajK1> http://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Continuation_monad
09:35:17 <ReinH> Cont is (a -> b) -> b
09:35:22 <lf94> Time to figure out plotting data now :) Here comes the paaain
09:35:23 <ReinH> Cont is Yoneda specialized to Identity
09:35:26 <ReinH> it is a Yoneda embedding
09:35:28 <benzrf> ReinH: isnt that supposed to be Yoneda a
09:35:36 <ReinH> yes, Yoneda a, sorry
09:35:38 <benmachine> ReinH: ...but also without the forall
09:35:43 <benmachine> which is kind of important
09:35:45 <ReinH> benmachine: that's true
09:36:03 <benzrf> ParahSailin_: oh, you can query them?
09:36:07 <ReinH> but doesn't change the fact that it's a Yoneda embedding
09:36:08 <NikolajK1> but that's not the embedding y(A):=Hom(A,-)
09:36:24 <benmachine> ReinH: I think it does: Yoneda lemma is about natural transformations, and Cont isn't
09:36:27 <benzrf> ParahSailin_: alright, i thought you were talking about storing your data as featureless blobs in sql
09:36:34 <ReinH> ...
09:37:10 <benmachine> ReinH: ok so they're related but there are important differences
09:37:41 <NikolajK1> benmachine: since all functors in Hask are endofunctors, the nats are kinda obscured. in particular, Yoneda identifies nats with normal morphisms, so you'd not see them explicitly
09:37:59 <benmachine> NikolajK1: it's possible I misunderstand exactly what is being claimed
09:38:02 <GeraldCode> how you get so smart NikolajK1
09:38:18 <NikolajK1> #haskell
09:38:23 <GeraldCode> ah :)
09:38:34 <NikolajK1> (not really)
09:38:38 <NikolajK1> :)
09:38:40 <GeraldCode> ok
09:39:03 <NikolajK1> I should lurk more though
09:39:06 <ReinH> Cont is literally Yoneda specialized to Identity, the only difference is the rank 2 quantification, but this only restricts the way you can construct values
09:39:20 <ReinH> Cont is flip ($)
09:39:24 <ReinH> Yoneda is flip fmap
09:39:47 <ReinH> modulo quantification
09:39:48 <benmachine> ReinH: but the rank 2 quantification being absent means you can use Cont at concrete types, which is why it can do so much more than the trivial things
09:40:19 <benmachine> like, it's pretty much necessary for the whole thing where any other monad embeds in it
09:40:20 <phaazon> https://github.com/DanielG/monad-journal/commit/1982b0c9964342085092e3472fae7025e905a7b5#commitcomment-7162162 is that a haddock bug?
09:40:35 <ReinH> That embedding is a yoneda embedding. That's my point.
09:40:59 <ReinH> That embedding is *precisely* a Yoneda embedding.
09:41:30 <ReinH> http://golem.ph.utexas.edu/category/2008/01/the_continuation_passing_trans.html
09:41:48 <ReinH> http://bartoszmilewski.com/2013/10/08/lenses-stores-and-yoneda/
09:41:57 <NikolajK1> yeah, I don't speak C++
09:42:16 <NikolajK1> an embedding of object being types, you claim right. But that a must be mapped to forall b.a->b
09:42:34 <NikolajK1> not "forall b.(a->b)->b"
09:43:06 <ReinH> no C++ anywhere?
09:43:35 <NikolajK1> he says "Assume A and B are types; the continuation passing transform takes a function (here I’m using C++ notation)"
09:43:52 <ReinH> Oh. Ew.
09:45:02 <ReinH> I thought you meant Bartosz, but he's doing Haskell now
09:45:55 <benmachine> NikolajK1: to return to your original question, isn't the Kleisli adjunction basically always the same?
09:46:38 <benmachine> like, F is the identity on objections and (return .) on morphisms, and G is M on objects and (=<<) on morphisms
09:46:40 * hackagebot base-prelude 0.1.3 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.3 (NikitaVolkov)
09:46:40 <ReinH> benmachine: what do you mean by "the same"?
09:46:56 <NikolajK1> the construction is the same, but for different return/bind, you get different nats adjoint functors
09:47:27 <NikolajK1> the task would be "take the writer monad M" and compute the associated F and G
09:47:39 <NikolajK1> you get two endofunctors in Hask - which?
09:47:47 <benmachine> you don't get endofunctors in Hask
09:47:53 <ReinH> benmachine: multiple adjunctions can give rise to a monad
09:47:57 <vanila> NikolajK1, every monad rises from an adjunction
09:47:58 <benmachine> you get a functor to the kleisli category and back
09:48:04 <vanila> it's called the eilenberg moore category
09:48:21 <ReinH> Kleisli gives the initial object among adjunctions and Eilenberg-Moore the terminal object
09:48:23 <benmachine> every monad arises from the Kliesli and the E-M adjunctions (which need not be different) and can arise from others as well
09:48:30 <NikolajK1> yeah okay, a subcategory of Hask
09:48:40 <benmachine> NikolajK1: kleisli isn't a subcategory, I don't think
09:48:47 <benmachine> the morphisms are different, the composition is different
09:49:15 <NikolajK1> okay okay, but whatever you get, it lives in haskell
09:49:20 <NikolajK1> just define a new composition
09:49:26 <benmachine> ok, sure
09:49:41 <ReinH> btw, this adjunctions -> monads, monads -> adjunctions thing forms... an adjunction in higher-dimensional category theory :)
09:49:57 <benmachine> but then you can't easily define functors in the sense of Functors because they're not endofunctors
09:50:24 <NikolajK1> I guess
09:50:41 <ReinH> You need a bit more machinery to work with these things in Haskell
09:50:48 <benmachine> it is interesting to look at what non-Kleisli adjunctions give rise to various monads though
09:50:59 <benmachine> like the State monad comes from the product/exponential adjunction
09:51:09 <NikolajK1> I've seen packages on presheaves — go search that for Java libraries ^^
09:51:37 <benmachine> the Cont monad comes from the fact that (-> r) is self-adjoint on the right
09:51:51 <lf94> What does .~ do? I see it a lot with the Chart library
09:52:38 <ReinH> lf94: does the Chart library use lenses?
09:53:09 <benmachine> (lens .~ value) is a function that sets the thing specified by lens to value
09:53:25 <benmachine> > (3,4) & _1 .~ ":O"
09:53:32 <lambdabot>  (":O",4)
09:53:36 <benmachine> > (3,4) & _2 .~ ":O"
09:53:41 <Cale> This wouldn't need as much explaining if people would just write 'set' instead.
09:53:44 <lambdabot>  (3,":O")
09:54:00 <benmachine> > set _2 ":O" (3,4)
09:54:02 <lambdabot>  (3,":O")
09:54:08 <benmachine> that's up to people, I guess
09:54:56 <Cale> Note that the version with 'set' was actually fewer characters :D
09:55:16 <ion> > set _2":O"(3,4)
09:55:18 <lambdabot>  (3,":O")
09:55:46 <Cale> & is also really dumb and I have no idea why it exists
09:55:57 <benmachine> it sometimes makes things read more naturally
09:55:59 <ReinH> Cale: so people can read things from left to right
09:56:08 <ReinH> s/read/write
09:56:12 <Cale> They can read them left to right anyway :P
09:56:12 <mmmm> Is there any way to get around the duplicate instances restriction, ie I want to define two instances (MonadReader Int m) => MyClass m and (MonadState Int m) => MyClass m
09:56:19 <Cale> It just means something different :D
09:56:23 <mwhit> i avoid the operators whenever possible
09:56:36 <mwhit> i just feel like there has to be a better way than 150 different pieces of punctuation
09:56:39 <benmachine> mmmm: you can't do that because then it won't be clear which to use when both are available
09:56:40 <mwhit> even if there is a system to them
09:56:44 <lf94> The more I learn about Haskell the more I feel like it's all over the place
09:56:50 <lf94> Is this normal
09:56:59 <Cale> lf94: What do you mean by that?
09:57:01 <mwhit> lf94: what, operators?
09:57:16 <Cale> There are lots of people programming Haskell now, and they have differing tastes
09:57:16 <monochrom> what is all over the place?
09:57:23 <Cale> is that what you mean?
09:57:44 <lf94> .~ is also set and not everything reads the same way and apparently everything is boiled down to functions that take no parameters
09:58:02 <darthdeus> tac: so i bought that book from amazon :P
09:58:03 <Cale> lf94: Functions always take parameters
09:58:09 <Cale> lf94: Or else they're not functions
09:58:10 <tac> darthdeus: awesome
09:58:22 <tac> I have some free time if you want a short introduction.
09:58:24 <lf94> Apparently when they are 'desugared', they don't
09:58:25 <Cale> lf94: Functions are things of type A -> B for some types A and B
09:58:32 <darthdeus> tac: yes :)
09:58:32 <lf94> Just something that another haskeller told me
09:58:35 <mwhit> cale: yeah, but you know he means pointfree
09:58:36 <ReinH> lf94: what does "desugaring a function" mean?
09:58:41 <Cale> hm?
09:58:44 <tac> darthdeus: Do you know what I meant by the simply typed lambda calculus?
09:59:10 <darthdeus> tac:  i know that lambda calculus is untyped, and that there are things like type level lambdas (with the capital lambda symbol :P)
09:59:14 <lf94> I have nearly zero haskell experience so please tell me I'm wrong :) (so far looks to be like I am, which is a very good thing...I really like the ideas behind haskell)
09:59:15 <darthdeus> tac:  but that's about all i know
09:59:21 <Cale> lf94: Anyway, there are a lot of options for how to write code in any language
09:59:30 <benmachine> darthdeus: untyped lambda calculus is untyped, there are typed kinds as well
09:59:36 <lf94> ReinH: I don't even know
09:59:39 <ReinH> lf94: I'm not sure what "desugared" means here
09:59:40 <lf94> Not my words
09:59:46 <ReinH> but it doesn't sound true in any way I can see
09:59:47 <tac> darthdeus: well, the simply typed lambda calculus is basically what happens when you add a very very simple type system to lambda calculus
09:59:49 <benmachine> lf94: it sounds like someone told you something confusing
09:59:55 <mwhit> lf94: I suspect what you mean by "functions that take no arguments" is point-free definitions
09:59:57 <lf94> Yeah that's most likely the case
10:00:01 <mwhit> so like i can write add3 = (+ 3)
10:00:01 <ReinH> probably best to forget about it
10:00:05 <tac> the only types are: Int, and those generated by ->
10:00:07 <mwhit> which looks like it takes no arguments but it does
10:00:11 <darthdeus> tac: i mean i've read a book about that was something like "functional programming through lambda calculus" but didn't really give me much more understanding, etc.
10:00:17 <tac> so Int, Int -> Int, Int -> Int -> Int, (Int -> Int) -> Int, etc
10:00:18 <darthdeus> tac: ok so far that makes sense
10:00:52 <lf94> Maybe people are trying to sabotage the Haskell user base
10:00:54 <trap_exit> I'm doing http server in haskell. I need 2 things: (1) websocket, (2) able to serve a static directory. What should I use?
10:01:17 <tac> So you might have \x:Int. x + x. What type would that have?
10:01:34 <ReinH> trap_exit: ocharles has been doing websockets stuff with snap iirc
10:01:42 <mwhit> lf94: alternatively, maybe he meant all functions take *one* argument?
10:01:52 <darthdeus> tac: Int -> Int
10:01:52 <ReinH> mwhit: ah hmm
10:02:06 <ReinH> I could see how that would make sense
10:02:09 <tac> darthdeus: right.
10:02:14 <tac> Most of your intuition from haskell will apply
10:02:15 <ReinH> weird way to say it though. There's no sugaring going on here.
10:02:18 <lf94> mwhit: To be honest I actually knew that
10:02:24 <tac> You just have to remember: no polymorphism, no typeclasses
10:02:29 <lf94> And when he said otherwise I was extremely, extremely baffled
10:02:31 <mwhit> lf94: well, i got nothin then
10:02:33 <tac> and lambdas are typically explicitly annotated*
10:02:36 <trap_exit> ReinH: https://ocharles.org.uk/blog/posts/2013-12-19-websockets.html ?
10:02:37 <lf94> "Is everything I'm learning about Haskell just a lie?"
10:02:47 <benmachine> lf94: evidently some things are :P
10:02:49 <darthdeus> tac: hmm
10:02:57 <bob_____> the only desugaring that comes to mind is the do syntax
10:02:57 <ReinH> trap_exit: https://ocharles.org.uk/blog/posts/2014-07-13-announcing-socket-io-for-haskell.html
10:02:59 <tac> also, no algebraic data types, unless they are "builtin"
10:03:16 <darthdeus> tac: so all of that stuff has to be removed before it gets transformed to that
10:03:18 <tac> So since I decided Int is the only builtin (base) type, we don't have [Int] or Maybe Int
10:03:19 <lf94> I've been reading though learnyouahaskell and realworldhaskell, but it just isn't the same until you start using it
10:03:29 <darthdeus> tac: like inlined vtables for typeclasses?
10:03:29 <ReinH> lf94: yep
10:03:36 <tac> no typeclasses eithe
10:03:37 <tac> r
10:03:47 <mwhit> lf94: true. lyah is good but too superficial. rwh is good, but outdated
10:03:54 <mwhit> the better way to start these days is probably
10:03:54 <tac> darthdeus: the simply typed lambda calculus is a stepping stone. A good pedalogical language, but no one would ever write ANYthing in it
10:03:57 <mwhit> @where yorgey
10:03:57 <lambdabot> I know nothing about yorgey.
10:03:59 <mwhit> hmm
10:04:09 <mwhit> http://www.seas.upenn.edu/~cis194/lectures.html
10:04:17 <ReinH> lf94: we're kind of missing a modern Haskell textbook right now, but there are some older ones that will help you think in a more functional way, etc.
10:04:29 <tac> darthdeus: I have a simply implementation for the simply typed lambda calculus here:
10:04:29 <tac> https://bitbucket.org/_tactics/simply-typed-lambda-calculus/src
10:04:30 <mwhit> then https://github.com/nicta/course
10:04:32 <ReinH> Thompson is really good, and Bird is good but more a FP book that uses Haskell examples.
10:04:42 <ReinH> Hutton is good but short and a bit oddly organized
10:04:45 <tac> It doesn't even have a compiler, nor an evaluator. It was just an exercise to write a typechecker
10:04:56 <ReinH> lf94: anyway my list of recommendations is http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
10:05:11 <darthdeus> tac: oh interesting, so it parses the notation and then typechecks it? :O
10:05:15 <mwhit> @where nicta
10:05:15 <lambdabot> I know nothing about nicta.
10:05:21 <mwhit> how do i tell lambdabot about links
10:05:31 <tac> darthdeus: test.lc has a sample program and test.out.txt has the output from running the progrmam.
10:05:34 <tac> yep
10:05:37 <tac> (can't run it though!)
10:05:42 <ReinH> There are some courses that have been helpful, but they are difficult to do without a mentor to work through them with
10:05:52 <ReinH> NICTA, byorgey and bos have nice courses
10:05:59 <tac> the output is a proof-tree. The tree shows WHY that term has the type it figured out
10:06:23 <darthdeus> ReinH: heh I have "How to Prove It" just lying on my table :)
10:06:32 <ReinH> darthdeus: :)
10:06:37 <darthdeus> tac:  i don't understand the output at all :X
10:06:43 <darthdeus> ReinH: haven't read it yet though :(
10:06:48 <tac> It's a little hard to read
10:07:23 <ReinH> This is the closest thing to a modern survey of Haskell http://dev.stephendiehl.com/hask/
10:07:33 <bob_____> @unpl wrap i j m f = m (f . i) . j
10:07:33 <lambdabot> wrap i j m f c = m (\ g -> f (i g)) (j c);
10:07:35 <tac> but it uses inference notation. Check the bottom of this wiki page for some examples: https://en.wikipedia.org/wiki/Rule_of_inference
10:07:45 <ReinH> darthdeus: you should!
10:07:54 <merijn> Anyone know if Renzo Carbonara is on IRC occasionally? (Or do we have any people familiar with pipes-parse/pipes-binary?)
10:08:00 <mwhit> @where+ yorgey http://www.seas.upenn.edu/~cis194/lectures.html
10:08:00 <lambdabot> I will remember.
10:08:13 <mwhit> @where+ nicta https://github.com/nicta/course
10:08:13 <lambdabot> Done.
10:08:25 <ReinH> mwhit: nice
10:08:39 <tac> basically, each horizontal ----------------------- says "everything below is true because everything above is true"
10:08:42 <mwhit> surprisingly hard to find the command list
10:08:44 <ReinH> merijn: Tekmo is occasionally on
10:08:47 <mwhit> @where+ commands http://users.ece.cmu.edu/~allbery/lambdabot/COMMANDS
10:08:47 <lambdabot> Nice!
10:08:55 <ReinH> heh
10:09:01 <ReinH> mwhit++
10:09:02 <tac> But admittedly, it's confusnig the way I've outputted it :(
10:09:04 <tac> in ASCII
10:09:17 <darthdeus> tac: but uhm ... I guess I don't really understand the notion of having a type as a proof
10:09:18 <darthdeus> i mean
10:09:19 <monochrom> you should output SVG :)
10:09:43 <lf94> Thanks guys
10:09:44 <tac> maybe on the next iteration!
10:10:05 <monochrom> "proof" means explanation. the proof explains why your expression has its type
10:10:08 <tac> so let me break down what this means (and this is chapter 1 through 3in the book)
10:10:13 <darthdeus> this is such a completely new universe
10:10:40 <xinming_> maxmin :: [a] -> (a, a)    <--- In this example, why will I get error but    maxmin :: [Integer] -> (a, a)   doesn't please?
10:10:43 <merijn> ReinH: Yeah, but not now :p
10:10:44 <tac> x : A |- b : B means: "the variable x is in scope. It has type A. And b is a program/term that is defined in terms of the in-scope variables. It has type B"
10:10:58 <xinming_> This is the example from <<Begining haskell, a project based approach>>
10:11:01 <ReinH> merijn: :(
10:11:06 <xinming_> Not example,
10:11:12 <darthdeus> tac: that makes sense
10:11:18 <tac> so the very first line... kinda to the right, you see "x : A, g : A -> B, f : B -> C |- ...."
10:11:20 <xinming_> Not examlpe, It's just an excerise to write maxmin
10:11:25 <darthdeus> tac: so x is like a parameter to the thing on the right?
10:11:27 <tac> So x, g, and f are the three variables we have in scope
10:11:35 <tac> sorta kinda :)
10:11:39 <ReinH> xinming_: what did you try to do and what error did you get?
10:11:41 <ReinH> @where paste
10:11:42 <lambdabot> Haskell pastebin: http://lpaste.net/
10:11:47 <monochrom> xinming_: you need to show complete code
10:12:01 <tac> one of the rules is that if you have x : A |- b : B, you can type |- (\x:A. b) : A -> B
10:12:05 <darthdeus> i wish you had done x: A instead of x : A :D
10:12:12 <darthdeus> yes
10:12:19 <xinming_> ReinH: BBL
10:12:20 <tac> and that's what most of this is doing
10:12:35 <tac> it takes elements from the left hand side (we call the left hand side the Context)
10:12:45 <tac> and turns them into the variables we stick in front of the lambdas
10:12:54 <octopuscabbage> is that guy who wanted a haskell project still on i just thought of a pretty good one
10:12:56 <darthdeus> tac: so it's rewriting it from the left until there's no context left
10:13:11 <tac> If you ever have a thing that looks like |- blah : Blah (with NO variables in the context), we call blah a *CLOSED* term
10:13:14 <darthdeus> like making   foo x = x + 1 into foo = \x -> x + 1
10:13:25 <tac> yes, sort of!
10:13:27 <darthdeus> hmm
10:13:28 <xinming_> ReinH: monochrom http://lpaste.net/108191
10:13:31 <darthdeus> this reminds me of prolog
10:13:40 <tac> It's very proofy, and prolog is also proofy
10:13:52 <tac> The top law for instance says something that seems obvious
10:14:07 <ReinH> xinming_: Does the book not mention the need for an Ord constraint?
10:14:11 <tac> translated, it says "if x, g, and f are in scope (with the proper types), then g has type A -> B"
10:14:20 <xinming_> But I got something like   maxmin l :: Ord a => [a] -> (a, a) make it worked. and [Integer] -> (Integer, Integer) worked too.
10:14:25 <darthdeus> i only had one semester of prolog, so i can kinda understand the thinking behind it, so this helps knowing that it's sort of similar :D
10:14:40 <monochrom> then the correct type signature is "maxmin :: Ord a => [a] -> (a,a)"
10:14:43 <ReinH> xinming_: does the book say anything about why you need the Ord a =>, i.e. the constraint?
10:14:46 <xinming_> ReinH: Not yet. It just gave an examlpe, But I believe in later chapter it'll explain this. :-)
10:14:46 <darthdeus> tac: the space after that means a second proof?
10:14:52 <darthdeus> since there's a missing - on the line below
10:15:05 <ReinH> xinming_: what example did it give exactly? I'm trying to figure out if the book has lead you astray.
10:15:07 <xinming_> ReinH: Not yet. As far as I read, It doesn't, Because it's just first pages of examples. :-)
10:15:18 <tac> yes. It's a tree :)
10:15:29 <tac> so the space indicates you're jumping to your sibling node
10:15:36 <mwhit> xinming_: Probably will. If you're interested, "Ord a" means that the type a has a total ordering. If a type is not ordered, there can't be any notion of "max" or "min"
10:15:38 <ReinH> So it literally said implement a function maxmin :: [a] -> (a,a) ?
10:15:49 <xinming_> ReinH: that code is the example from book except the " maxmin :: [a] -> (a, a) " thing
10:16:02 <dolio> Decidable total ordering.
10:16:03 <ReinH> xinming_: what type does the book give maxmin?
10:16:09 <dolio> Well, semi-decidable.
10:16:10 <darthdeus> tac:  but all of the lines below belong to the left subtree, right?
10:16:17 <darthdeus> or is the root of the tree on line 11?
10:16:23 <tac> this tree is kind of degenerate. It has 4 notes in a row, then a branch: one of which just goes on one more node, and the other branch branches again (and each terminate with one more node each)
10:16:34 <xinming_> ReinH: It use this function to introduce the tuples
10:16:42 <tac> the line below are the parent node
10:16:44 <tac> is*
10:16:53 <darthdeus> ah ok
10:17:03 <darthdeus> .dot graph would be nice :D
10:17:09 <tac> the book explains this better than I can
10:18:00 <monochrom> this is a bad book on account of using head, tail, null. see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
10:19:00 <ReinH> xinming_: looking at the example code that comes with the book, ewwwwwwww
10:19:06 <tac> darthdeus: page 2 of this PDF has some decent examples of how you would typeset this in LaTeX:
10:19:07 <tac> http://www.math.nagoya-u.ac.jp/~garrigue/lecture/2012_tenbo/typed.pdf
10:19:41 <darthdeus> tac: oh shit i remember seeing this notation in some presentation and skipping over like 50% of it because I couldn't understand what it means
10:19:47 <darthdeus> what's the Γ ?
10:19:50 <ReinH> This example code makes me very sad
10:19:52 <xinming_> ReinH: sorry, was taking medcine just now.
10:19:58 <ReinH> xinming_: np
10:20:12 <darthdeus> oh nvm it's explaind in there
10:20:21 <tac> the Γ (greek capital gamma) is a metavariable for any context
10:20:24 <ReinH> if/else instead of pattern matching, not putting a type on the only function that has a non-obvious type
10:20:32 <tac> So Γ might stand for x:Int, y:Int
10:20:37 <xinming_> ReinH: The code come with the book just missing type declarations, But I had long ago (10 years ago) tried haskell once, So, I just want to get them as quick as possible.
10:20:38 <tac> or it might stand for the empty context
10:20:38 <NikolajK1> yeah okay, so I got it. The embedding isn't what the continuation monad does, the embedding is from functions to continuations.
10:20:38 <NikolajK1> The Yoneda functor's arrow map, maps functions f::a->b to f' in nat(Hom(a,-),Hom(b,-)). This is, for r in place of "-", (a->r)->(b->r), which is equivalent to b->(a->r)->r. For any term s::b, we have a term t:=f(s) and the yoneda embedding above is the map from f to the continuation with the return map g::a->r to g t::r
10:20:48 <ReinH> xinming_: does the book mention that minmax is a partial function and what that implies?
10:20:51 <tac> the empty context means "top level"
10:21:07 <tac> your context will be nonempty inside a function definition or lambda
10:21:30 <ReinH> I was going to buy the book to see if it was worth recommending
10:21:34 <ReinH> Looks like I don't have to now
10:21:35 <ReinH> :/
10:21:41 <monochrom> which book is it?
10:21:50 <ReinH> monochrom: beginning haskell: a project based approach
10:21:55 <xinming_> ReinH: Nope, If I understand you correctly, partial function means  function with multiple args have partial args applied
10:22:06 <ReinH> xinming_: that's partially applied
10:22:12 <darthdeus> tac: that makes sense
10:22:19 <ReinH> partial here means that it isn't defined for all inputs
10:22:29 <ReinH> or that it errors for some inputs
10:22:41 <tac> darthdeus: in the notation people use, Γ and capital delta are often used for contexts. x y z for variables. a b, t, s for terms (=programs), and S T A B for types
10:23:08 <dolio> NikolajK1: I think you forgot to swap a and b.
10:23:13 <tac> but we call them METAvariables because we have to distinguish between variables in the math we're using to describe it... versus the variables in the language we're writing
10:23:20 <ReinH> monochrom: this is some example code from chapter 2 http://lpaste.net/108192
10:23:26 <tac> (sometimes that can get confusing)
10:23:29 <ReinH> I have problems with this code.
10:23:44 <NikolajK1> dolio: where
10:23:51 <monochrom> this is what's wrong with "project-based" people
10:24:01 <dolio> Either in f, or in the rest of your message.
10:24:07 <NikolajK1> right
10:24:12 <NikolajK1> f goes to a
10:24:17 <mwhit> ReinH: my eyes
10:24:17 <darthdeus> tac: it also says that λ-Term is the same as Proof in logic, is that because it's like prooving that the types match? (given that it says that the types are a proposition)
10:24:18 <ReinH> NikolajK1: yeah
10:24:20 <ReinH> mwhit: indeed
10:24:34 <ReinH> xinming_: I have to say that book seems bad and I'm sorry.
10:24:38 <darthdeus> tac: so a metavariable is from the context
10:24:51 <darthdeus> tac: and a variable is not from a context but from some inner implementation?
10:24:57 <tac> no. Γ is the metavariable :)
10:25:21 <darthdeus> i meant 'a' as the english 'a', not as "the variable 'a'" :D
10:25:34 <tac> it means "we can use any context for this rule. Just copy&replace Γ with an actual context"
10:25:44 <tac> in the code, it's more clear, IMO
10:25:47 <xinming_> monochrom: BTW, I think the book is not that bad, The book leads to use coding examples to implement some basic operators first in that book.
10:26:19 <ReinH> xinming_: I can't speak for the whole book, but those code examples are problematic to say the least
10:26:26 <mwhit> xinming_: the code ReinH just linked is very, very bad code. Code like that shouldn't be in a book teaching haskell, even for expediency
10:26:27 <ReinH> and it doesn't sound like the exposition is much better
10:26:29 <benzrf> firstOrEmpty scarred me
10:26:57 <xinming_> The book first gave you head and tail and some hints, then, ask you to try to implement the +++ which does the same thing as ++ by yourself.
10:27:09 <ReinH> xinming_: if the book starts with head and tail instead of pattern matching then it's terrible
10:27:10 <xinming_> and also implement reverse2. something like that.
10:27:11 <ReinH> I'm sorry
10:27:22 <ion> What ReinH said
10:27:23 <xinming_> >_<
10:27:24 <xinming_> Ok.
10:27:29 <ReinH> doing this forces you to write terrible Haskell code
10:27:29 <sanjoyd> Can emacs be set up so that I can automatically split a function argument into clauses?  If so, what is the easiest way to do so?
10:27:35 <dolio> What book is it?
10:27:37 <ReinH> Haskell is fundamentally a pattern matching language
10:27:40 <monochrom> did anyone read my http://www.vex.net/~trebla/haskell/crossroad.xhtml ?
10:27:41 <mwhit> there's no reason anyone should be using head or tail in 2014, really
10:27:46 <ReinH> that's how expressions are evaluated: by pattern matching
10:27:54 <ReinH> not teaching pattern matching when teaching how to write expressions is terrible
10:28:03 <ReinH> dolio: beginning haskell: a project-based approach
10:28:09 <xinming_> I'll continue. :-)  I know the author just first try to gave you some primitive stuff, then, later, He gave you pattern matching thing so you know what saves you.
10:28:14 <ReinH> xinming_: I have some book recommendations here http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
10:28:16 <darthdeus> tac: uhm, where in the code? :D
10:28:20 <ReinH> xinming_: Some of them can be found as pdfs
10:28:20 <darthdeus> tac: i'm looking but not finding
10:28:23 <xinming_> ReinH: Ok, Thanks.
10:28:24 <darthdeus> in the output?
10:28:30 <benzrf> firstOrEmpty is horrifying though
10:28:36 <ReinH> xinming_: Real World Haskell is free and, while it has its own problems, is way way way better than this
10:28:50 <benzrf> ReinH: what kinda problems does it have?
10:28:50 <ReinH> xinming_: please don't let this author teach you how to write terrible Haskell :(
10:28:51 <c_wraith> mwhit: If only there was some other way of writing something like (map (head &&& tail) . group) as nicely
10:28:57 <c_wraith> err
10:28:58 <mwhit> benzrf: Oh my god, i just glossed over firstOrEmpty the first time
10:29:00 <mwhit> that "empty" string
10:29:01 <mwhit> oh my god
10:29:05 <ReinH> benzrf: it's obsolete and contains errata, some exposition is confusing
10:29:06 <c_wraith> head &&& length is what I meant
10:29:09 <benzrf> ReinH: alright
10:29:10 <darthdeus> xinming_: what are you reading?
10:29:26 <dolio> group could have a more specific type.
10:29:34 <ReinH> I didn't realize this book was this bad.
10:29:35 <ReinH> :(
10:29:37 <benzrf>  :t group
10:29:39 <c_wraith> mwhit: because doing RLE with code that concise is nice.
10:29:47 <xinming_> ReinH: I believe I have the ability to distinguish the bad and good ones. But if examples gave you ideas on something, Then, it's good to me.
10:29:51 <benzrf>         
10:29:53 <monochrom> xinming_: pattern matching is more elementary than using null-head-tail. pattern matching comes earlier, not later. even pedagocially.
10:29:54 <ion> c_wraith: That would be just fine if head :: NonEmptyList a -> a and group :: … -> [NonEmptyList a] :-P
10:30:01 <xinming_> darthdeus: <<Begining haskell - A project based approach)
10:30:02 <tac> darthdeus: I use "ctx" instead of gamma everywhere
10:30:04 <benzrf> :t group
10:30:06 <lambdabot> Eq a => [a] -> [[a]]
10:30:07 <mwhit> c_wraith: NonEmpty works nicely there
10:30:16 <c_wraith> ion: sure, but that turns into a huge mess if you really try to use it
10:30:16 <ReinH> xinming_: I'm just worried that this book is teaching you bad practices
10:30:34 <tac> So typechecking works like this (through the typeCheck function)
10:30:41 <ReinH> since it's started out teaching terrible practices
10:30:54 <ReinH> if I had bought it in a bookstore I'd take it back and try to get a refund :(
10:30:55 <tac> You give it a term t an a context Γ and it fills in the blank: Γ |- t : _ with a Type, if it can
10:30:58 <xinming_> ReinH: well, It later has enhancements
10:31:10 <ReinH> xinming_: the thing is, you don't start with the terrible, anti-good way to do something
10:31:10 <xinming_> This is just raw expressions, later the author gave the more cleaner one. :-)
10:31:13 <ReinH> and then introduce the better one
10:31:16 <ReinH> that's bad exposition
10:31:26 <tac> well, actually, typeCheck just takes a term and figures out |- t : _ with an empty context...
10:31:36 <ReinH> there's absolutely no good pedagogic reason to introduce head and tail but not (x:xs) pattern matches
10:31:45 <ReinH> it's so bad
10:32:06 * hackagebot scotty-cookie 0.1.0.0 - Cookie management helper functions for Scotty framework  http://hackage.haskell.org/package/scotty-cookie-0.1.0.0 (MartinsMacs)
10:32:10 <monochrom> the book proves its own logical flaw
10:32:12 <tac> typeCheckD shows you how the typechecking actually works (the tree you see is called a derivation)
10:32:17 <ReinH> monochrom: how so?
10:32:29 <tac> (TypeDeriv is a type derivation, and typeCheckD = typecheck derivation)
10:32:36 <xinming_> Well, I just skipped pages, and nav around, I found the next section, when it introduces data type matches, It introduces the list match.
10:32:48 <dolio> There may be if you're writing for some audience that is already used to writing code in that manner, and you're just trying to introduce the syntax.
10:32:49 <monochrom> "first learn how null-head-tail can be written, then use null-head-tail to implement concatenation"
10:32:49 <darthdeus> tac: but if you give it an empty context, how can it ever give you a type if all it uses is the context?
10:32:50 <xinming_> Pattern match
10:32:52 <dolio> But other than that....
10:33:02 <ReinH> monochrom: ugh
10:33:08 <monochrom> to learn how null-head-tail can be written, you must learn pattern matching
10:33:10 <tac> darthdeus: If I want to type the identity function Int -> Int
10:33:19 <dolio> How to Translate your Lisp Directly to Haskell
10:33:29 <monochrom> after you have learned pattern matching, you can already write concatenation and circumvent null-head-tail
10:33:34 <tac> I would type it as x : A |- x : A     (meaning if x has type A in scope, then x has type A... obvious, right?)
10:33:38 <ReinH> xinming_: I'm not mad at you. I'm mad at this book.
10:33:46 <tac> then, I hit it with the rule that lets me make lambdas, and I get
10:34:00 <tac> |- (\x:A. x) : A -> A
10:34:12 <darthdeus> tac: ah so you typecheck it after you get the lambda?
10:34:22 <ReinH> monochrom: this makes me so sangry
10:34:42 <xinming_> ReinH: But thanks anyway, I'll read the books in your urls.
10:34:47 <monochrom> "exercise 1: use a simple mechanism to build a messy mechanism. exercise 2: use the messy mechanism to build practical things"
10:34:48 <tac> If I typecheck \x:A. x, then the program figures out that I need to "pull the x out" into the context
10:34:58 <tac> Or you can think of it as "we look inside the lambda"
10:35:18 <ReinH> monochrom: right exactly
10:35:27 <tac> \x:A. x can be defined at the top level, and the context is empty. But when we go inside the lambda, we see a : A is in scope.
10:35:37 <monochrom> and above all, "I'm doing this for pedagogical purposes. in chapter 10 I will tell you how to use the simple mechanism directly!"
10:35:49 <darthdeus> tac: that makes total sense :O
10:35:51 <xinming_> monochrom: Where do you read these?
10:35:57 <ReinH> exercise 1: use the fundamental description of Haskell expression evaluation to write a messy mechanism. exercise 2: forget about how Haskell actually works and use your messy thing instead.
10:35:58 <monochrom> the book you're reading
10:36:00 <tac> gtg
10:36:02 <tac> ttyl darthdeus
10:36:07 <xinming_> monochrom: Or, You read that book?
10:36:12 <darthdeus> tac: thanks! \o
10:36:23 <monochrom> I don't need to. you're already telling me everything I need to know
10:36:25 <ReinH> xinming_: I think he's "paraphrasing" ;)
10:36:51 <Athiwat> Why does "newtype Prob a = Prob { getProb :: [(a,Rational)] }" work?
10:36:58 <ReinH> The book could be significantly improved by never introducing null, head, and tail, let alone in chapter 1 or w/e.
10:37:02 <monochrom> I'm deducing the logical conclusion to how this book explains things
10:37:09 <ReinH> Athiwat: why do you expect it not to work?
10:37:23 <Athiwat> Shouldn't "a" be the whole type? as in "newtype Prob a = Prob { getProb :: [a] }"
10:37:29 <xinming_> monochrom: But actually, I'm kind of person who learn things this way.
10:37:32 <ReinH> Athiwat: Ah. a is a type variable.
10:37:46 <Athiwat> ReinH: So it doesn't work like a function?
10:38:09 <ReinH> Athiwat: it does work like a function at the type level: Prob is a type constructor that takes a type and gives a "concrete" type.
10:38:13 <xinming_> The reason I picked haskell again is because yesterday I use perl to simulate the State monad successfully. Still messy code, But at least I know how to do it in haskell cleverly.
10:38:18 <mmmm> Is it possible to write a type class instance which says "If the type has a MonadState instance then use this instance"
10:38:21 <Athiwat> ReinH: I see thanks
10:38:37 <mwhit> mmmm: not without UndecidableInstances
10:38:39 <ReinH> Athiwat: so you'd have types like : Prob Int is [(Int, Rational)]
10:38:40 <pjdelport> Athiwat: What that newtype means is that wherever you see "Prob a" in your code, at runtime there will only be "[(a,Rational)]"
10:38:52 <pjdelport> (where "a" is any other type)
10:39:03 <ReinH> Athiwat: it just says: you'll need to specify a type `a'. I'll use the type you specify to fill in the right hand side.
10:39:10 <monochrom> I don't care about cleverly. I care about reasonably.
10:39:51 <mmmm> So does that mean my structure is wrong somewhere mwhit?
10:40:00 <xinming_> well, I do mean how haskell simplify these things when you try to do that in other language.
10:40:02 <ReinH> monochrom: one principle I use for good pedagogy is "lie as little as possible" in the Wittgenstein "lies to children" sense.
10:40:06 <mwhit> mmmm: No, it just means being able to do that would let you write undecidable things
10:40:11 <ReinH> monochrom: this book seems to pessimize for that
10:40:25 <mwhit> mmmm: What if I write "instance Foo a => Bar a"
10:40:32 <mwhit> then I write "instance Bar a => Foo a"
10:41:39 <vlatkoB> Does "blah :: [a] -> [b]" implies that 'a' and 'b' must have different types? Can't b have the same type as a?
10:42:00 <pjdelport> vlatkoB: Yes, they can always be unified to the same type.
10:42:44 <mwhit> mmmm: Adding -XUndecidableInstances is basically promising GHC that you won't write things like that, and lets you define instances that way
10:43:19 <vlatkoB> pjdelport: But "blah xs = xs" doesn't compile.
10:43:22 <pjdelport> vlatkoB: Type variable work similarly to plain variables in that sense: when you have a function "\a b -> ... using a and b ...", then a and be can be different, but they can also be the same (by just supplying the same value for both a and b)
10:43:55 <mwhit> vlatkoB: what's the type of blah and xs? what's the error?
10:44:11 <mmmm> mwhit: thanks, I understand why it is bad, I'm now trying to restructure my code to get around this
10:44:18 <Athiwat> pjdelport: ReinH thanks
10:44:35 <pjdelport> vlatkoB: Ah, when you say blah xs = xs, the implementation is saying that a and b *must* be the same.
10:44:40 <pjdelport> That's a different matter.
10:44:53 <monochrom> "blah :: [a] -> [b]" means that the user, not the author, chooses what to plug into a, and what to plug into b.
10:44:55 <vlatkoB> Type is "blah :: [a] -> [b]". Errora are 'a' is rigid, and 'b' is rigid
10:44:58 <pjdelport> :t let blah xs = xs in blah
10:44:59 <rwbarton> vlatkoB: "blah xs = xs" does not have type, for example, [Int] -> [String]
10:44:59 <lambdabot> t -> t
10:45:02 <mwhit> mmmm: If your typeclass is closed, you can probably just use UndecidableInstances without feeling too dirty
10:45:14 <monochrom> so what if the user chooses a=Int, b=String?
10:45:43 <pjdelport> :t let blah (x:xs) = x:xs; blah [] = [] in blah
10:45:44 <lambdabot> [a] -> [a]
10:46:10 <Athiwat> newtype doesn't inherit any class right?
10:46:15 <monochrom> right
10:46:30 <Athiwat> and I can use deriving?
10:46:34 <vlatkoB> pjdelport: Got it. Thanks.
10:46:38 <monochrom> yes for some
10:46:47 <Athiwat> monochrom: thanks
10:47:04 <pjdelport> vlatkoB: So in other words, given a valid function :: [a] -> [b], you can always *specialize* it to [a] -> [a], but you cannot do the reverse.
10:47:26 <pjdelport> And blah is already limited to being only [a] -> [a], by definition.
10:47:53 <vlatkoB> Got to go. Sorry... Thanks.
10:48:11 <lf94> Is it better to use recursion to go over an array (in a function I define myself) or should I use something like foldr/foldl?...
10:48:28 <monochrom> depends on your task
10:48:42 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:48:50 <mwhit> lf94: usually things like foldr/scanl are better if they fit the task
10:49:01 <mwhit> its harder to screw thigns up
10:49:12 <monochrom> but if you really want a general answer, I have one
10:49:23 <monochrom> it is best to hire me and pay me money.
10:49:46 <ReinH> hahahaha
10:50:06 <pjdelport> lf94: It's almost always better to use existing recursion patterns where you can.
10:50:31 <lf94> I'm trying to write something simple that takes an item from my array, applies the function, and prints it, but I can't even do that ;_;
10:50:43 <pjdelport> They simplify the implementation, and make it easier to generalize, prove properties, and transform the code in useful ways.
10:50:51 <mwhit> lf94: any arbitrary item?
10:50:53 <lf94> http://paste.debian.net/111808/
10:51:04 <lf94> Last few lines
10:51:06 <lf94> no
10:51:06 <int3__> lf94: it's sort of analogous to using for loops instead of goto in imperative languages :)
10:51:07 <lf94> A float
10:51:15 <pjdelport> :t mapM
10:51:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:51:20 <pjdelport> :t mapM_
10:51:21 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
10:51:21 <rwbarton> main can't be a Float
10:51:38 <rwbarton> ... among other problems
10:51:43 <lf94> Ah I guess my definition is- yeah
10:51:45 <mwhit> :t putStrLn
10:51:46 <lambdabot> String -> IO ()
10:51:49 <monochrom> lf94: at present you have type problems
10:51:51 <lf94> You made me realize some big problems :)
10:51:53 <mwhit> the type of your function is wrong
10:52:02 <pjdelport> lf94: In this case, you can do: mapM_ print $ someList
10:52:15 <mwhit> in fact the two pattern matches have different types
10:52:22 <lf94> Ok so I should just create a list of new values and print them
10:52:22 <xinming_> ReinH monochrom I just read pages later, Yes, the pattern matching is done after the author introduces the Data type declaration, and he first uses the case x of  thing to match, later he describes that case x of is error prone and tedious, then, He gave the alternative syntax about the pattern matching.
10:52:37 <mwhit> :t mapM putStrLn
10:52:39 <lambdabot> [String] -> IO [()]
10:52:45 <mwhit> :t mapM print
10:52:46 <lambdabot> Show a => [a] -> IO [()]
10:52:47 <xinming_> Sleep time, bye all.
10:52:56 <monochrom> "case x of" is neither error-prone nor tedious
10:53:10 <monochrom> I can only agree that it's slightly longer
10:53:31 <pjdelport> lf94: mapM_ applies a function "(a -> m b)" (such as print) to each element of a, and sequences all the resulting actions.
10:53:43 <pjdelport> So it prints all the elements in the case of mapM_ print
10:54:08 <xinming_> I'm wrong
10:54:10 <pjdelport> The mapM_ variant is more efficient when you don't care about the result.
10:54:31 <pjdelport> (it just throws it away, instead of collecting it into a result list)
10:55:19 <monochrom> lf94: do you think you already know what I talk about in http://www.vex.net/~trebla/haskell/IO.xhtml ?
10:55:46 <lf94> Most likely not
10:56:23 <mwhit> lf94: As an aside, it's good practice to have type signatures for all top-level definitions. Helps other people (and you, and GHC) keep track of types much more easily
10:56:23 <xinming_> author didn't say it's erronr prone, Just said it we can do pattern match makes us feel similiar to the way we write mathenmatical functions. :-)
10:56:26 <xinming_> sleep now. bye all
10:56:43 <lf94> mwhit: Yes someone told me to do that- I totally agree :)
10:57:57 * merijn refuses to trouble shoot newbie code without signatures
10:58:09 <merijn> It's like trying to read python code, I never know what types anything has :\
10:58:26 <monochrom> but you could ask ghci to tell you types
10:58:42 <merijn> monochrom: If I need to copy their code from lpaste it's too much work to bother
10:59:03 <barrucadu> That'll give you what GHC thinks the types are, not what they think the types are
10:59:43 <monochrom> yes, that may be so. but bear in mind part of the need of troubleshooting is that the newbie type sigs may be wrong and untrustworthy in the first place
11:00:11 <merijn> monochrom: That's why they should include compiler errors :)
11:00:23 <mwhit> monochrom: sure, but that's what happened here, and having it still made diagnosing the problem a lot easier
11:00:30 <monochrom> then that's a reasonable position
11:00:58 <ReinH> monochrom: looks like I'm going to need to write my Recommendations^Op list, where instead of an arrow towards a book it's an arrow away from the book.
11:01:02 <monochrom> people should pay us money to do more work
11:01:04 <merijn> ugh, I hate when my coding hits a brick wall until I get outside input >.<
11:01:31 <monochrom> coding is not a pure function.  <duck>
11:02:11 * hackagebot scotty-cookie 0.1.0.1 - Cookie management helper functions for Scotty framework  http://hackage.haskell.org/package/scotty-cookie-0.1.0.1 (MartinsMacs)
11:02:26 <lf94> Is there a way to say "Use any type from the typeclass Fractional" ? Don't tell me how, I'd like to figure it out on my own, but I'd like to know if that exists lol
11:02:36 <pjdelport> monochrom: It's a moneydic function?
11:02:38 <barrucadu> Yes
11:02:40 <ReinH> lf94: yes
11:02:44 <NikolajK1> asked about cleaning up the category aspects here
11:02:45 <NikolajK1> http://math.stackexchange.com/questions/878903/continuations-vs-yoneda
11:02:47 <merijn> People who have libraries, but aren't on #haskell 24/7 to troubleshoot me are so inconsiderate >.>
11:02:53 <monochrom> yes, there is. if you have in mind "the user can choose, the author cannot choose"
11:02:55 <lf94> I've seen a few examples like: func :: Fractional e => a -> e
11:02:56 <pjdelport> (a Kashli arrow?)
11:02:58 <ReinH> pjdelport, monochrom: Ironic, then, that it can't be applied with $
11:03:05 <ReinH> pjdelport: oh god
11:03:06 * monochrom hates "any type"
11:03:14 <lf94> Is that bad practice? :s
11:03:17 <kazagistar> lf94: then you have seen exactly how it is done
11:03:19 <lf94> I'm dealing with money here
11:03:32 <monochrom> haha pjdelport
11:03:36 <lf94> kazagistar: ah
11:03:43 <lf94> so a is anything I take it?
11:03:45 <ReinH> lf94: that's how typeclass constraints are used, although putting the constraint on the return type might make things a bit difficult
11:03:50 <benzrf> lf94: for money use Ratio
11:03:56 <benzrf> > 4 % 10
11:03:57 <lambdabot>  2 % 5
11:04:20 <benzrf> > 4 % 10 + 1 % 3
11:04:22 <lambdabot>  11 % 15
11:04:29 <lf94> How would I type in $11.19
11:04:36 <ReinH> And that type specifically is a pretty useless one
11:04:38 <monochrom> lf94: in "func :: Fractional e => a -> e", user chooses a, no contraint; user chooses e, only constraint is Fractional
11:04:39 <lf94> (excluding the dollar sign of course)
11:04:41 <benzrf> > 11.19 :: Rational
11:04:43 <lambdabot>  1119 % 100
11:04:50 <lf94> Oh nice
11:04:50 <kazagistar> lf94: it is a type variable, with the constraint that it has to be Fractional
11:05:10 <benzrf> lf94: to be precise, 'Ratio' is a type constructor, and 'Rational' is 'Ratio Int'
11:05:13 <benzrf> or maybe Ratio Integer
11:05:14 <benzrf> i dont remember
11:05:20 <lf94> kazagistar: I thought e only had that contstraint- so a has it too?
11:05:22 <ReinH> > 11 + (51 % 100)
11:05:24 <lambdabot>  1151 % 100
11:05:36 <ReinH> lf94: only e
11:05:55 <pjdelport> @src Rational
11:05:55 <lambdabot> type Rational = Ratio Integer
11:06:10 <benzrf> @src Ratio
11:06:10 <lambdabot> data (Integral a) => Ratio a = !a :% !a
11:06:15 <benzrf> :-o
11:06:18 <kazagistar> lf94: oh, I see, no, it can be anything, which means that your function seems a little strange
11:06:27 <kazagistar> lf94: I misread it
11:06:33 <benzrf> > 6 :% 8
11:06:35 <lambdabot>  Not in scope: data constructor ‘:%’
11:06:35 <lambdabot>  Perhaps you meant one of these:
11:06:35 <lambdabot>    ‘:+’ (imported from Data.Complex),
11:06:35 <lambdabot>    ‘Seq.:>’ (imported from Data.Sequence),
11:06:35 <lambdabot>    ‘Seq.:<’ (imported from Data.Sequence)
11:06:41 <benzrf> pfft
11:07:22 <pjdelport> lf94: For money, a newtype may be useful.
11:07:44 <kazagistar> { func :: Fractional e => a -> e } says "this function must be able to return to you any kind of fractional, given anything at all"
11:07:59 <lf94> Right, as monochrom said
11:08:04 <mwhit> for which the only possible definition is "const {some fractional}"
11:08:28 <ReinH> which is why I said it was pretty useless ;)
11:08:42 <monochrom> it is a made-up type, so I wouldn't worry about what concrete examples it may have
11:09:54 <monochrom> > 6 % 8
11:09:56 <lambdabot>  3 % 4
11:10:06 <lf94> Ok so...Ratio is not part of the base haskell library (prelude?) or something?: http://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Classes.svg/480px-Classes.svg.png
11:10:10 <trap_exit> in acid-state,
11:10:19 <trap_exit> what do I do when the type of the state changes ?
11:10:24 <mwhit> @hoogle Ratio
11:10:25 <trap_exit> i.e. if I add a new fielld or delete an old field
11:10:25 <lambdabot> Data.Ratio module Data.Ratio
11:10:25 <lambdabot> Data.Ratio data Integral a => Ratio a
11:10:26 <lambdabot> Prelude type Rational = Ratio Integer
11:10:33 <monochrom> Ratio is not in prelude. but still part of the standard
11:10:52 <lf94> Ok
11:11:14 <int-e> it's a bit confusing because the 'Rational' type is actually exported from the Prelude, but % is not.
11:11:17 <mmmm> Does anyone know why Parsec's type has a user state field?
11:11:40 <mmmm> Is it because it pre-dates idiomatic use of monad transformers?
11:12:12 * hackagebot conduit-combinators 0.2.8.2 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.2.8.2 (MichaelSnoyman)
11:12:46 <geekosaur> mmmm, I think it has to do with backtracking
11:13:06 <geekosaur> if you use a state trandformer, you can't "undo" state modifications when the parser backtracks
11:13:27 <darthdeus> ReinH: btw when is the next haskellcast coming out? :P
11:13:39 <ReinH> darthdeus: we just released one, give us a *minute* :p
11:13:55 <darthdeus> I think the people would appreciate if you could make at least one per week
11:13:58 <darthdeus> kthxbai
11:14:04 <ReinH> heh
11:14:07 <darthdeus> :D
11:15:41 <mmmm> geekosaur: There is a ParsecT transformer though, you'd hope that did the right book keeping for you?
11:15:51 <kazagistar> would it make sense to use a Control.Monad.Trans.MonadPlus in Parsec?
11:16:03 <geekosaur> huh? State has no interface for another monad to tell it to roll back to a previous version
11:16:30 <geekosaur> and if ParsecT had it built in, it would mandate use of a sparate state monad with it even if you didn't need it
11:16:59 <geekosaur> so, it carries a state value that is tied to the current parse state, so if it goes back to an earlier parse state the associated value state follows
11:17:09 <int-e> > runStateT ((put 2 >> mzero) `mplus` (return 1 :: StateT Int [] Int)) 0
11:17:10 <lambdabot>  [(1,0)]
11:17:49 <mmmm> yes you're right, so it says in the comments
11:18:40 <int-e> mmmm: I think your reasoning goes the wrong way, StateT Parsec would reset the state on backtracking.
11:19:37 <kazagistar> int-e: oh I get it, I always forget that they are kinda... inside out
11:19:51 <lf94> So I'm looking into https://hackage.haskell.org/package/base-4.2.0.1/docs/Data-Ratio.html, to find out how to convert my Rational to a Fractional, but alas there is nothing. Any tips?
11:20:33 <lf94> Oh, I think I found it
11:21:15 <monochrom> realToFrac is a general converter for that kind of conversions
11:21:16 <int-e> mmmm: I guess there's a small performance advantage for having a builtin state in parsec, if that state is used.
11:21:18 <mwhit> :hoogle (Fractional a) => Rational -> a
11:21:22 <mwhit> err
11:21:26 <mwhit> @hoogle (Fractional a) => Rational -> a
11:21:27 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
11:21:27 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
11:21:27 <lambdabot> Data.Data FloatConstr :: Rational -> ConstrRep
11:22:10 <monochrom> half of realToFrac is fromRational. theoretically.
11:23:04 <int-e> @src realToFrac
11:23:05 <lambdabot> realToFrac = fromRational . toRational
11:23:37 <frankbro> Do any of you would have a clue if it would be possible to use core has a target language without any of the parts of haskell? Also, is laziness only within haskell or is it translated into the runtime system as well?
11:24:00 <mmmm> int-e: So is there a difference between ReaderT Parsec and ParsecT Reader?
11:24:14 <geekosaur> there used to be a thing called external core, but I think it bitrotted
11:24:30 <geekosaur> as for laziness, it's built into the runtime, which is a graph reduction engine at heart
11:24:41 <geekosaur> (read up on the "stg-machine")
11:25:28 <benzrf> mmmm: yes
11:27:25 <int-e> mmmm: yes, though it's fairly small. look here: http://hackage.haskell.org/package/parsec-3.1.5/docs/src/Text-Parsec-Prim.html#ParsecT  ... ReaderT r Parsec  puts an  r ->  in front of the whole type, wheras ParsecT (Reader r) would have an r -> for every 'm'.
11:37:07 <SirLalala> Heya guys, which package would you recommend for some 2d drawing?
11:37:37 <SirLalala> I've tried some samples of gloss but I cannot get to install the dependency with cabal
11:37:39 <monochrom> "diagrams"
11:38:01 <monochrom> gloss is good too
11:41:39 <int-e> mmmm: actually the difference is larger than I thought. The implementation of 'local' for the ParsecT MonadReader instance is subtle
11:41:49 <carter> SirLalala: what dep was missing? what os?
11:42:22 <SirLalala> carter: I'm on a mac right now it's stopping with gloss-raster complaining about llvm
11:42:26 <carter> oh
11:42:31 <carter> brew install llvm
11:42:37 <SirLalala> carter: didn't fix it for me
11:42:55 <carter> SirLalala: do you NEED gloss-raster?
11:43:18 <carter> @lpaste the exact error so i can help
11:43:19 <lambdabot> Haskell pastebin: http://lpaste.net/
11:43:20 <SirLalala> carter: the gloss-examples do need it
11:43:31 <carter> SirLalala: but you don't need it :)
11:43:49 <carter> what ghc --version
11:43:52 <carter> how did you install it
11:43:55 <carter> what llvm version
11:44:07 <carter> do you have opt or opt-someversionnumber
11:44:09 <carter> inyour path
11:44:15 <SirLalala> ghc 7.6.3, I installed haskell-platform with brew
11:44:25 <carter> NOO
11:44:26 <carter> noo
11:44:29 <carter> sorry
11:44:40 <SirLalala> :(
11:44:41 <carter> i'm going to have to ask you to not use brew ghc
11:44:54 <carter> brew formula for ghc isn't maintained properly
11:45:18 <carter> use http://ghcformacosx.github.io/ if you want an easy install
11:45:43 <SirLalala> sorry didn't knew :(
11:45:47 <carter> dont frowny
11:45:51 <carter> no frowns
11:46:16 <carter> anyways
11:46:43 <lf94> main = map bjbj [0..3000], bjbj :: Fractional e => Rational -> e
11:46:48 <carter> ghcformacosx gives you a nice app bundle based install, and pester etrepum  if you hav eproblems, because its his baby
11:47:57 <SirLalala> hey nice, etrepum has been looking at my exercism submissions!
11:48:08 <carter> also 7.6 is hosed on recent OS X
11:48:12 <carter> just period hosed
11:48:35 <mwhit> lf94: main has to be :: IO ()
11:48:48 <lf94> Ah.
11:48:49 <carter> 7.8.3 onwards will work on anyyyy os x version
11:49:02 <fuzzyhorns> what does =<< and >>= mean?
11:49:12 <mwhit> oh boy
11:49:42 <lf94> mapM_ print (map bjbj [0..3000]) Aw yeah!
11:50:21 <int-e> lf94: why not: mapM_ (print . bjbj) [0..3000]?
11:50:35 <BenedictEggers> question: are monads a haskell peculiarity that were implemented to make it easier to work with, or are they a fundamental FP concept?
11:50:36 <lf94> Because I don't know what the hell I'm doing %60 of the time :)
11:50:40 <lf94> 60%*
11:50:51 <mwhit> BenedictEggers: the former
11:50:55 <BenedictEggers> thanks
11:51:00 <mwhit> they are a CT concept, not a FP one
11:51:07 <carter> monads aren't that interesting
11:51:16 <lf94> int-e: what does . do
11:51:22 <BenedictEggers> they're pretty cool
11:51:25 <carter> :P
11:51:27 <BenedictEggers> seems like i should learn some CT
11:51:28 <carter> applicatives are cool
11:51:30 <fadoodle> :t (.)
11:51:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:51:31 <carter> no CT needed
11:51:35 <BenedictEggers> textbook recommendations?
11:51:36 <carter> except for funsies
11:51:43 <BenedictEggers> well im a cs/math undergrad so it sounds kinda fun :D
11:51:44 <mwhit> it's also not exactly a haskell peculiarity. other FP languages have them, or approximations to them. they just usually call them something else
11:51:46 <carter> BenedictEggers: do you have an abstract algebra background?
11:51:47 <int-e> lf94: it composes functions. (f . g) x = f (g x)
11:51:53 <BenedictEggers> carter: no
11:52:00 <benzrf> BenedictEggers: its not too hrad
11:52:02 <benzrf> *hard
11:52:03 <lf94> Oh!
11:52:06 <carter> BenedictEggers: honestly, the most "concrete" category theory stuff is made a bit more concrete with a bit of abstract algebra background
11:52:12 <carter> or at least the fancy stuff
11:52:17 <dv-_> fuzzyhorns: >>= is bind
11:52:18 * hackagebot scotty-cookie 0.1.0.2 - Cookie management helper functions for Scotty framework  http://hackage.haskell.org/package/scotty-cookie-0.1.0.2 (MartinsMacs)
11:52:19 <BenedictEggers> hmmm okay
11:52:20 <carter> haskell uses pretty "elementary" categorical concepts
11:52:33 <mwhit> unless you read an ekmett library source
11:52:39 <benzrf> BenedictEggers: i was able to learn basic abstract algebra and i have no formal math training beyond high school
11:52:48 <benzrf> its fun \o/
11:52:51 <lf94> int-e: wow that's exactly what I was looking for
11:53:14 <lf94> "How could I possibly pass the values coming in from map to the inner function?...No idea so lets try something else..."
11:53:16 <benzrf> when i first looked into CT i misunderstood morphisms
11:53:18 <BenedictEggers> benzrf: that's encouraging, what resources did you use?
11:53:22 <benzrf> i thought they were just graph edges
11:53:26 <mwhit> yeah i picked up some basic abstract algebra in grad school for chem phys, and the only formal college math I took was vector calc
11:53:30 <benzrf> didnt realize they were things with a typing
11:53:38 <benzrf> BenedictEggers: mostly ##math and wikipedia tbh
11:53:40 <BenedictEggers> because i think im gonna drop my math major, so i probably won't take abstract algebra
11:53:45 <benzrf> probably not the best way
11:53:56 <BenedictEggers> lol
11:53:59 <benzrf> note that i only know the elementary stuff
11:54:18 <benzrf> enough to understand references to it in CT tho
11:54:18 <dv-_> benzrf: how far did you get?
11:54:56 <benzrf> dv-_: i know the basic important structures, magma/semigroup/monoid/group, rings & fields
11:55:09 <benzrf> concepts like homo/endo/iso/automorphisms
11:55:35 <benzrf> sporadic knowledge of stuff like cyclic groups and torsion elements and kernels of homomorphisms
11:55:46 <dv-_> benzrf: have you tried solving textbook problems?
11:55:50 <benzrf> n
11:56:05 <benzrf> BenedictEggers: why're you dropping your math major
11:56:24 <BenedictEggers> benzrf: go deeper into TCS, do more research, actually enjoy college a little bit
11:56:27 <TheKing444> > drop major
11:56:29 <lambdabot>  Not in scope: ‘major’
11:56:30 <BenedictEggers> im also studying chinese so its a bit much
11:56:39 <benzrf> TCS?
11:56:43 <benzrf> theor. comp sci
11:56:43 <BenedictEggers> theoretical CS
11:56:55 <TheKing444> > take 5 "credits"
11:56:57 <lambdabot>  "credi"
11:57:00 <BenedictEggers> i find that all the math i really enjoy is basically just TCS
11:58:31 <vanila> TCS?
11:58:38 <vanila> oh computers
11:58:42 <BenedictEggers> love those things
11:58:51 <BenedictEggers> not sure what they're good for though
11:59:04 <vanila> they're kind of annoying
11:59:08 <benzrf> BenedictEggers: you know what a monoid is, right
11:59:12 <vanila> never seem to do what I want
11:59:12 <BenedictEggers> lol yes
11:59:29 <benzrf> BenedictEggers: because if you grasp the notion of a set or type with an operation and other features and laws
11:59:40 <benzrf> that's the central idea of abstract algebra
11:59:41 <BenedictEggers> i understand groups and rings, at least on a basic level
11:59:43 <benzrf> kk
11:59:51 <benzrf> so you know what a group homomorphism is?
12:00:05 <BenedictEggers> i couldn't rigorously define it, so that's probably a good place for me to start studying
12:00:11 <benzrf> kk
12:00:26 <monochrom> if you know groups and rings (or generally at least two algebraic structures), you are ready for basic category theory i.e. what can "morphism"/"arrow" stand for
12:00:39 <monochrom> (in fact why the name "morphism" to begin with!)
12:00:48 <BenedictEggers> haha okay. thanks guys
12:00:50 <TheKing444> It is an arrow in the category of groups.
12:00:59 <BenedictEggers> <3 #haskell
12:01:44 <benzrf> TheKing444: we prefer morphism around here
12:01:45 <vanila> group homomorphism: Let G,H be groups - then f : G -> H is a group hom when f(1)=1, f(ab)=f(a)f(b) and f(x^-1)=f(x)^-1
12:02:10 <dv-_> i.e. a function between groups that preserves the group structure
12:03:37 <vanila> exercise: f(ab)=f(a)f(b) implies f(1)=1 and f(x^-1)=f(x)^-1
12:04:50 <int3__> i just started studying cat theory tonight :D from Algebra of Programming
12:05:10 <int3__> natural transformations are taking a while to wrap my head around
12:05:37 <SirLalala> vanila: shouldn't 1 be e as of kernel?
12:05:53 <SirLalala> my vague memories of algebra
12:05:54 <TheKing444> natural transformation in python is something of type "f x -> g x" for some Functors f and g (and all x)
12:05:58 <vanila> I don't know what you're asking sorry
12:06:00 <TheKing444> I mean haskell
12:06:06 <TheKing444> why did I say python?
12:06:15 <BenedictEggers> is Algebra of Programming worth reading?
12:06:20 <BenedictEggers> i've been debating picking up a copy
12:06:21 <TheKing444> :t maybeToList
12:06:22 <SirLalala> <vanila> exercise: f(ab)=f(a)f(b) implies f(1)=1 and f(x^-1)=f(x)^-1
12:06:22 <lambdabot> Maybe a -> [a]
12:07:01 <TheKing444> maybeToList is a natural transformation in the category of Hask, from the Functor from Hask to Hask called maybe, to the Functor from Hask to Hask called List.
12:07:09 <vanila> a natural transformation is a map from one functor to another with some condition like G . nu = nu . F
12:07:20 * hackagebot Plot-ho-matic 0.4.0.2 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.4.0.2 (GregHorn)
12:08:04 <int3__> TheKing444: right, I know the examples, I'm just trying to map the idea to the object/morphism terms
12:08:16 <carter> SirLalala: oooo, i just remember, "cabal install  gloss-raster --ghc-option="-fasm"  "
12:08:19 <carter> would also fix your issue
12:08:19 <int3__> I'll figure it out in a bit, I think my brain just needs to simmer on it :)
12:08:26 <carter> but you shouldn't use brew ghc anyways
12:08:26 <TheKing444> Ah oh key.
12:09:07 <SirLalala> carter: already switched to the mac build you sent me, thanks!
12:09:12 <carter> yay
12:09:21 <carter> SirLalala: ghc detects if thers an llvm at install time
12:09:32 <carter> SirLalala: SOO, it should just work magicaly now
12:09:36 <carter> assumeing you've got an llvm installed
12:09:41 <carter> llvm < 3.5 mind you
12:09:45 <int3__> BenedictEggers: well I just started on it, but IMO it is the first book I've found that's rigorous yet goes quickly from basics to stuff that seems most relevant for reading FP papers. it looks like Awodey doesn't cover natural transformations till chapter 7, for example.
12:09:54 <TheKing444> It basically is a "polymorphic" (really just a collection of) arrows, such that for arrow z: fmapG (z) . nat = fmapF (z) . nat, meaning that fmap commutes with the natural transformation.
12:10:00 <BenedictEggers> int3__: thanks
12:10:43 <vanila> I think that fact (that polymorphic haskell functions satisify that natural-transform-looking fmap law you gave) is really nontrivial
12:10:55 <mmmm> I'm reading that too int3__
12:10:59 <mmmm> let's start a reading group :P
12:11:04 <TheKing444> wait I messed it up
12:11:17 <TheKing444> fmapG (z) . nat = nat . fmapF (z)
12:11:33 <TheKing444> (The other thing doesn't make sense.)
12:11:51 <TheKing444> Note that those two "nats" aren't the same arrow.
12:12:20 <int3__> mmmm: well, #haskell is the informal reading group, right? :P
12:12:26 <int3__> TheKing444: right, I was puzzling over that just now
12:12:37 <int3__> uh, so how do you get one 'nat' from the other
12:12:56 <int3__> oh, they're polymorphic, so they basically do the 'same thing' but with different objects?
12:13:00 <TheKing444> What is the proof that all functions of the form "(Functor f, Functor g) => forall x. f x -> g x" is a natural transformation?
12:13:20 <TheKing444> int3__ You see, you figure out your "nat" by "type-inference" sort of.
12:13:21 <vlatkoB> pjdelport: Sorry, I had to leave suddenly. I'm looking at RankNTypes.
12:13:22 <vlatkoB> Wouldn't "blah :: [a] -> (forall b. [b])" mean the caller chooses a, and blah chooses b?
12:13:22 <vlatkoB> (so "blah xs = xs" could be correct?)
12:13:31 <vanila> TheKing444, there's a difficult paper about it by Wadler
12:13:47 <vanila> Unless this is true for simpler reasons, but I'm not sure about that
12:13:50 <TheKing444> vlatoB, the caller chooses both
12:14:29 <TheKing444> forall a. [a] -> (forall b. [b]) == forall a b. [a] -> [b]
12:14:41 <rwbarton> if you could write [a] -> (exists b. [b]), it would mean what you said
12:14:45 <rwbarton> however that's not Haskell
12:14:55 <mmmm> The paper is called Theorems for free, Wadler 1989
12:15:09 <TheKing444> thx
12:15:43 <pjdelport> vlatkoB: Regardless of whether you can express a *type* like that, that's not what the implementation "blah xs = xs" is doing :)
12:16:02 <mwhit> vlatkoB: that means blah can take *some* type [a] and convert it to *any* type of the form [b]
12:16:19 <TheKing444> meaning that it is const []
12:16:21 <mwhit> whereas blah :: [a] -> [b] is *some* type [a] to *some* type b
12:16:23 <mwhit> [b]
12:16:33 <dolio> It's not very surprising if you consider the informal origins of parametricity, rather than the stuff that tries to give a formal statement of that informal idea.
12:16:35 <TheKing444> :t const []
12:16:36 <lambdabot> b -> [t]
12:16:40 * monochrom frowns at this mincing of words "some" and "any".
12:17:00 <TheKing444> :t const [] :: (forall a. [a] -> (forall b. [b]))
12:17:01 <lambdabot> [a] -> [b]
12:17:16 <TheKing444> How do you that action thing monochrom?
12:17:18 <monochrom> especially since "forall a. [a] -> (forall b. [b])" and "forall a b. [a] -> [b]" are equivalent
12:17:20 <TheKing444> In irc?
12:17:21 * hackagebot yesod-auth 1.3.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.2 (MichaelSnoyman)
12:17:23 * hackagebot yesod-bin 1.2.12 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12 (MichaelSnoyman)
12:17:23 <dolio> That is, parametric things are supposed to be uniform in what they do for each choice of instantiation.
12:17:25 <monochrom> /me
12:17:25 * hackagebot yesod-core 1.2.18 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.18 (MichaelSnoyman)
12:17:27 * hackagebot yesod-form 1.3.12 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.12 (MichaelSnoyman)
12:17:29 * hackagebot yesod-newsfeed 1.2.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.2.1 (MichaelSnoyman)
12:17:35 * TheKing444 learns about /me.
12:17:44 <dolio> Which is rather what natural transformations are. Collections of arrows that are uniform in some manner.
12:18:26 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
12:18:27 <TheKing444> Now an interesting function rank 2 function is (forall f. (Functor f) => (i->f i)->(o->f o)
12:18:30 <benzrf> i thought natural transformations were mappings between functors
12:18:31 <TheKing444> )
12:18:33 <benzrf> or are those isomorphic concepts
12:18:58 <benzrf> TheKing444: thats a van laarhoven lenstr
12:19:01 <benzrf> a non-polymorphic one
12:19:16 <benzrf> forall f. (Functor f) => (a -> f b) -> (s -> f t)
12:19:21 <TheKing444> The collection of arrows are "maps" from the codomain of one Functor to the codomain of the other.
12:19:22 <benzrf> <-> Lens s t a b
12:19:35 <benzrf> TheKing444: yeah
12:19:43 <TheKing444> What are those for?
12:20:29 <dolio> benzrf: They are more uniform than arbitrary collections of maps F z -> G z.
12:20:52 <vanila> a natural transformation is a map from one functor to another with some condition like G . nu = nu . F
12:21:33 <benzrf> well, i know how they work mechanically
12:21:38 <Zekka> vanila: Usually a natural transformation basiccally comes with somethign that's kind of like the functor laws, correct?
12:21:52 <vanila> no
12:22:18 <TheKing444> Here is the officalish definition of a natural transformation in category theory that is easy to understand.
12:22:31 * hackagebot yesod-routes 1.2.0.7 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.7 (MichaelSnoyman)
12:22:33 * hackagebot yesod-form 1.3.13 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.13 (MichaelSnoyman)
12:22:43 <TheKing444> Let us say you have functors F: X -> Y, G: X->Y
12:22:46 <vanila> The nice definition is that a natural transform is a map from the category of functors to another category of functors
12:23:16 <TheKing444> Now, for every x of X, make an arrow F x -> G x.
12:23:27 <TheKing444> Call this u, and u_x the arrow for x.
12:23:40 <Zekka> OK, I'm following so far
12:23:57 <TheKing444> Now, this is natural, if you everywhere arrow f:: x' -> x'' in X (drum roll please)
12:24:04 <vlatkoB> hmax, back to study some more. I understand when you say it, but do not see it by myself. Yet. :-)
12:24:37 <TheKing444> F (f) . u_x' = u_x'' . G (f)
12:25:14 <TheKing444> In haskell, any function of the form (forall x. F x -> G x) **will** be a natural transformation.
12:25:20 <TheKing444> For example
12:25:22 <Zekka> TheKing444: So that says smething along the lines of "it doesn't matter whether you lift first or lift after"?
12:25:24 <TheKing444> > listToMaybe
12:25:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:25:26 <lambdabot>    arising from a use of ‘M875298912068808927423383.show_M8752989120688089274...
12:25:26 <lambdabot>  The type variable ‘a0’ is ambiguous
12:25:26 <lambdabot>  Note: there are several potential instances:
12:25:26 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:25:26 <allsystemsarego> why isn't there a 'scanM' the same way there is a 'foldM'?
12:25:29 <TheKing444> exactly
12:25:35 <TheKing444> :t maybeToList
12:25:36 <lambdabot> Maybe a -> [a]
12:25:37 <benzrf> a natural transformation in haskell is a polymorphic function from F a to G a
12:25:45 <benzrf> basically
12:25:54 <benzrf> you 'apply' it to an object in Hask to get a morphism in Hask
12:25:59 <benzrf> by unifying it with a monomorphic type
12:26:04 <benzrf> yielding a function
12:26:07 <benzrf> aka a morphism
12:26:15 <Zekka> That application operation being turning i.e. f a -> g a into f Int -> g Int?
12:26:20 <TheKing444> @test (maybeToList . fmap (f)) z == (fmap (f) . maybeToList) z
12:26:20 <lambdabot> Maybe you meant: tell list let leet
12:26:25 <benzrf> you get a morphism in Hask because functors in haskell are generally endofunctors
12:26:28 <TheKing444> @test
12:26:29 <lambdabot> Maybe you meant: tell list let leet
12:26:34 <benzrf> @check
12:26:35 <lambdabot>  <unknown>.hs: 1: 1:Parse error: EOF
12:26:46 <User316> Hey folks! Sorry to be cutting in abruptly, I'm getting this weird error when downloading msgpack-rpc from cabal   "Could not find module `Data.Conduit.Attoparsec'...Failed to install msgpack-rpc-0.9.0"
12:26:49 <Zekka> benzrf: Meaning that when you apply a haskell functor, you still get an object in Hask?
12:26:52 <TheKing444> @check (maybeToList . fmap (f)) z == (fmap (f) . maybeToList) z
12:26:53 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1’
12:26:54 <lambdabot>  with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match expected type...
12:26:59 <benzrf> Zekka: yeah
12:27:04 <benzrf> well, when you apply a haskell Functor
12:27:12 <Zekka> oh, right
12:27:14 <benzrf> there are obviously non-endofunctors from Hask
12:27:19 <benzrf> but not within the language
12:27:30 <Zekka> But we don't represent them on the type level because if we did then they would presumably be endofunctors?
12:27:37 <benzrf> well, i suppose you might be able to set something up. But it wouldnt have a Functor instance
12:27:58 <TheKing444> I thing to look at is the haskell category package.
12:28:08 <TheKing444> It allows you to have different categories.
12:28:13 <benzrf> Zekka: a non-endofunctor from Hask would need a function from Haskell types to something else
12:28:15 <TheKing444> Like Klesli arrow category.
12:28:32 <benzrf> Zekka: strictly, i guess typeclass constructors meet thta
12:28:32 <TheKing444> benzrf: Not necesarrily, it could be to different arrows.
12:28:34 <benzrf> *that
12:28:44 <benzrf> TheKing444: hmm, true
12:28:47 <Zekka> benzrf: In that typeclass constructors can consume types but create constraints, not types?
12:28:52 <benzrf> yep
12:28:54 <benzrf> hmmmm
12:28:55 <benzrf> i wonder
12:28:56 <Zekka> (they have kind * -> Constraint, not * -> *)
12:29:02 <benzrf> do constraints form a category?
12:29:16 <benzrf> if so, typeclass constructors could form the object mapping of a non-endofunctor
12:29:24 <TheKing444> The category of Klesli arrows has types has objects and values of x -> m x as arrows for some monad m.
12:29:34 <benzrf> *form object mappings
12:29:40 <benzrf> TheKing444: yeah
12:29:56 <benzrf> so thats not an endofunctor
12:30:03 <benzrf> its not a Functor instance though
12:30:09 <allsystemsarego> why isn't there a 'scanM' the same way there is a 'foldM'? Does something exist that's even better?
12:30:30 <TheKing444> Meaning it couldn't be part of the typeclass Functor in haskell.
12:30:35 <TheKing444> :t foldM
12:30:36 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:30:48 <Zekka> benzrf: Would a thing that creates (* -> (* -> *))s (i.e. Either) also be a potential non-endofunctor for the same reason that an (* -> *) is not an *?
12:30:56 <TheKing444> @pl foldr
12:30:56 <lambdabot> foldr
12:30:57 <benzrf> Zekka: bifunctor
12:30:59 <benzrf> :k Bifunctor
12:31:01 <lambdabot> (* -> * -> *) -> Constraint
12:31:11 <benzrf> in category theory, a Bifunctor is a functor from the product of two categories to another
12:31:14 <benzrf> err, bifunctor
12:31:36 <benzrf> Zekka: the Bifunctor class in haskell is for functors from Hask x Hask to Hask
12:31:39 <Zekka> benzrf: Well, Hask x Hask isn't Hask, is it?
12:31:40 <benzrf> although it's curried
12:31:41 <Zekka> Oh, same thought
12:31:59 <benzrf> Zekka: ok, so i pulled 'you cant really have non endofunctors in haskell' out of my ass
12:32:11 <vanila> Zekka, I think that Hask x Hask ~ Hask and Hask^Hask ~ Hask and stuff
12:32:15 <Zekka> I guess objects in Hask x Hask can be represented in Hask though
12:32:16 <vanila> I mean this informally
12:32:21 <TheKing444> It just is really hard.
12:32:24 <Zekka> vanila: Because (a, b) is in Hask where a and b are inHask?
12:32:28 <vanila> but its a CCC because it models lambda calculus, no?
12:32:34 <vanila> yeah
12:32:36 <TheKing444> Haskell is mostly a one category language without outside packages.
12:32:37 <benzrf> i guess what i really meant is that you cant have Functor instances for non endofuntors
12:32:54 <TheKing444> Category theory at the type level, lambda calculus at the value level.
12:33:15 <Zekka> vanila: CCC means morphisms are objects in Hask IIRC: does it mean anything else?
12:33:21 <Zekka> I'll google, atually
12:33:47 <TheKing444> Oh, you mean because of the types.
12:33:52 <TheKing444> Its called an exponential object.
12:34:02 <TheKing444> look at nlab exponential object
12:34:49 <vlatkoB> so, callee can only choose type of input for the function given as parameter? As in "f :: (forall a. a -> b) -> c -> b"
12:35:22 <TheKing444> by the way, that is an impossible type
12:35:43 <benzrf> TheKing444: are you sure
12:35:50 <TheKing444> I think so without bottom.
12:35:54 <benzrf> const 3
12:35:58 <benzrf> ^ forall a. a -> Int
12:36:22 <TheKing444> can you make a function f :: (forall a. a -> b) -> c -> b
12:36:31 <vlatkoB> I left out some. This is more meaningfull:  f :: (forall a. Show a => a -> b) -> c -> b
12:36:42 <benzrf> @let totallyPossible :: (forall a. a -> b) -> c -> b; totallyPossible f v = f v
12:36:43 <monochrom> vlatkoB: in that type, callee chooses "a". I don't know what is "type of input for the function given as parameter". callee chooses a, but does not choose b. does callee choose a->b, then?
12:36:45 <lambdabot>  Defined.
12:36:48 <benzrf> TheKing444: :-)
12:36:58 <TheKing444> :t totallyPossible
12:36:59 <lambdabot> (forall a. a -> b) -> c -> b
12:37:19 <TheKing444> oh wait, yeah
12:37:28 <TheKing444> never mind
12:37:34 <allsystemsarego> @foldM_
12:37:34 <lambdabot> foldoc ...... The Free On-line Dictionary of Computing
12:37:46 <allsystemsarego> @src foldM_
12:37:46 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
12:37:54 <TheKing444> @djinn (forall a. a -> b) -> c -> b
12:37:55 <lambdabot> -- f cannot be realized.
12:37:57 <monochrom> it seems to me all attempts at paraphrasing in English fails. you're better off saying explicitly which type variable you're talking about.
12:37:57 <vlatkoB> monochrom: That would be a. bad wording.
12:38:06 <TheKing444> huh
12:39:16 <monochrom> the point of a programming language being symbolic is that imprecise English doesn't cut it, and precise English is too long.
12:39:34 <monochrom> similarly formulas in math
12:39:36 <benzrf> TheKing444: djinn is no djinn
12:39:40 <benzrf> its not got the poewr
12:39:54 <bitraten> is there a simple way to read strings to float, where possibly the leading zero is missing?
12:40:11 <TheKing444> :t read :: String -> Float
12:40:12 <lambdabot> String -> Float
12:40:12 <mwhit> > read ".03" :: Float
12:40:14 <lambdabot>  *Exception: Prelude.read: no parse
12:40:18 <TheKing444> oh
12:40:30 <mwhit> hm
12:40:31 <TheKing444> :t read . ('0':)
12:40:32 <lambdabot> Read c => [Char] -> c
12:40:45 <mwhit> yeah that would work, seems slightly hacky though
12:40:55 <mwhit> > (read . ('0':)) ".03" :: Float
12:40:57 <lambdabot>  3.0e-2
12:41:10 <bitraten> i think that works for me, thanks!
12:41:26 <hpc> @let magic str@('.':_) = read ('0':str); magic str = read str
12:41:28 <lambdabot>  Defined.
12:41:30 <hpc> :t magic
12:41:31 <lambdabot> Read a => [Char] -> a
12:41:34 <hpc> > magic ""
12:41:36 <lambdabot>  *Exception: Prelude.read: no parse
12:41:37 <Athiwat> for monads I can do "Just 4 >>= (\x -> return x + 2)" but how can I return a fail? Do I have to do " -> Nothing"?
12:41:49 <hpc> > magic "0.5" :: Float
12:41:51 <lambdabot>  0.5
12:41:54 <hpc> > magic ".5" :: Float
12:41:56 <lambdabot>  0.5
12:41:58 <benzrf> Athiwat: yes
12:42:02 <benzrf> and the former case is covered by functor
12:42:03 <TheKing444> Athiwat, instead of return, just type Nothing
12:42:14 <TheKing444> > Just 4 >>= (\x->Nothing)
12:42:15 <lambdabot>  Nothing
12:42:20 <benzrf> fmap (\x -> x + 2) (Just 4)
12:42:27 <benzrf> > fmap (\x -> x + 2) (Just 4)
12:42:28 <TheKing444> or use mzero
12:42:29 <lambdabot>  Just 6
12:42:31 <Athiwat> benzrf: TheKing444 The problem with that is I have to know it a "Maybe"
12:42:36 <nisstyre> I just realized the name of read is probably inspired by lisp
12:42:41 <TheKing444> > Just 4 >>= (\x -> mzero)
12:42:43 <lambdabot>  Nothing
12:42:47 <TheKing444> :t mzero
12:42:48 <lambdabot> MonadPlus m => m a
12:42:50 <Athiwat> TheKing444: thanks
12:43:05 <TheKing444> Just note, it only works for MonadPlus
12:43:07 <TheKing444> .
12:43:27 <Athiwat> Yeah, but I think it's much better.
12:43:29 <TheKing444> Because not all monads would support it.
12:43:37 <darthdeus> guys is there a way to run a function in ghci so that the threads it creates don't persist after it dies?
12:43:55 <TheKing444> (Can you make newtype Identity a = ID a work in your case?)
12:46:17 <phaazon> hey!
12:46:21 <darthdeus> chrisdone: hey I got a question about your DevelMain if you dont mind :P my app is forking a thread (in makeApplication), but it seems to persist through the calls to update, even though that kills the application's thread ... uhm what should I do?
12:46:24 <User316> cabal install msgpack-rpc  -> error:  Could not find module `Data.Conduit.Attoparsec`  Anybody?
12:46:37 <darthdeus> seems wrong to explicitly capture the thread i fork and kill it as well
12:46:39 <phaazon> is there a chan where we can discuss about linkedin accounts in order to connect?
12:46:46 <phaazon> here? #haskell-blah?
12:46:59 <monochrom> #haskell-blah is a good place
12:52:24 * hackagebot xml-pipe 0.0.0.2 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.2 (YoshikuniJujo)
13:08:42 <bitraten> how can i measure execution time, without the time printing the results?
13:09:06 <TheKing444> :t timeit
13:09:08 <lambdabot> Not in scope: ‘timeit’
13:09:14 <TheKing444> :t System.Timeit.timeit
13:09:16 <lambdabot> Not in scope: ‘System.Timeit.timeit’
13:09:26 <TheKing444> :t System.TimeIt.timeit
13:09:27 <lambdabot> Not in scope: ‘System.TimeIt.timeit’
13:09:34 <TheKing444> well, its something like that
13:09:40 <bitraten> yeah, thanks :)
13:09:56 <Darwin226> Hey has anyone used ghc-mod?
13:10:15 <darthdeus> is there a way to make a thread die when it's parent thread dies?
13:10:17 <darthdeus> Darwin226: yes
13:11:02 <Darwin226> darthdeus: Could you tell me what the requirements are to be able to get the type of an identifier? I tried just ghc-mod type myfile.hs mymodule 15 0
13:11:09 <Darwin226> but it just doesn't do anything
13:11:20 <Darwin226> As in, it doesn't output anything
13:11:29 <int3__> Darwin226: not 100% sure, but it might start numbering columns from 1
13:11:51 <Darwin226> int3_: Do I need to have a cabal project file in the directory?
13:11:57 <int3__> nope
13:12:44 <mwhit> Darwin226: what do you use for editing? emacs and vim both have ghc-mod plugins that let you use its features interactively
13:12:52 <mwhit> just cursor on the identifier and hit a hotkey
13:13:15 <Darwin226> mwhit: I'm interested in using it from the command line
13:13:24 <mwhit> fair enough
13:13:27 <platz> what is this solution to the expression problem called?  It seems simpler that "datatypes-a-la-carte" .. or is it identical to that?  https://gist.github.com/jonschoning/5e9ee150121010741ed0
13:13:33 <Darwin226> mwhit: Hopefuly, I can make a visual studio integration package.
13:13:37 <platz> just based on typeclasses
13:14:01 <platz> or are the constraints that it sucks at in certain situations
13:14:07 <int3__> Darwin226: chances are, you've misplaced the line/column. I think ghc-mod fails silently in that case.
13:14:43 <darthdeus> yeah it definitely fails silently
13:14:45 <Darwin226> int3_: This does seem to be the case. I actually got some output when I tried any of the lines FOLLOWING the one I want
13:15:01 <Darwin226> 7 18 27 10 "[String]" 7 10 27 10 "String" 7 1 27 10 "String"
13:15:05 <Darwin226> What does that mean?
13:15:20 <int3__> start line/column, end line/column
13:15:31 <int3__> 3 entries because of nesting
13:15:46 <int3__> so you have a [String] type nested in a String type etc
13:16:10 <int3__> darthdeus: just fyi, I have a PR for using ghc-modi for the type and info commands in the vim plugin
13:16:16 <platz> ah, I think it is equivalent to datatypes-a-la-carte, it just looks simpler because there aren't infix operators
13:16:31 <int3__> I recognize your username from the relevant issue :P
13:16:47 <darthdeus> int3__: the one fixing it's slowness? :O
13:17:04 <Darwin226> int3__: Interesting. Does it work with identifiers or jsut expressions? Because the position it's pointing me to is the start of a list (the "[" char)
13:17:13 <darthdeus> int3__: can you link me?
13:17:14 <int3__> darthdeus: yup. check/lint still uses the slow version though, because modi is kind of broken for that
13:17:29 <darthdeus> int3__: how broken? my wrapper works with it
13:17:35 <platz> the only downside is that you have to compose the chain of types in a left-associative fashion
13:17:40 <int3__> darthdeus: https://github.com/eagletmt/ghcmod-vim/pull/54
13:17:44 <platz> or it can fail
13:18:11 <int3__> darthdeus: broken enough to fail the tests in ghcmod-vim :P it works with predictable bugginess
13:18:34 <int3__> Darwin226: identifiers and expressions
13:19:02 <Darwin226> int3__: I think I've figured it out now. Thanks for the help
13:19:05 <chrisdone> @yow
13:19:05 <lambdabot> I own seven-eighths of all the artists in downtown Burbank!
13:19:19 <platz> Darwin226: you're working on a visual studio integration package?
13:20:24 <Darwin226> platz: Yeah. Why?
13:20:57 <platz> Darwin226: I think that's pretty awesome
13:20:59 <chrisdone> is there not already a visual studio one?
13:21:07 <chrisdone> or is there only the eclipse one
13:21:08 <darthdeus> int3__: lol :P
13:21:29 <Darwin226> chrisdone: Not a functional one AFAIK
13:21:31 <geekosaur> there was a visual studio package once, it broke with every vs update and they gave up on it
13:22:09 <platz> I think they've redone the plugin architecture since then
13:22:19 <Darwin226> platz: If I ever get this working, I'll make sure to share. Don't expect much though. Probably just syntac highlighting and type information. (And errors/warnings if I can manage that
13:22:22 <Darwin226> )
13:23:10 <platz> I don't know if the eclipseFP stuff is open, but if so it might be good to mine for ideas
13:23:25 <joelteon> why does the thread created by forkIO ignore ThreadKilled?
13:23:43 <luite> joelteon: async exceptions might be masked
13:23:58 <joelteon> damn it, async exceptions again
13:24:10 <luite> the forked thread inherits the mask state from the parent, so check that
13:24:12 <Darwin226> platz: Fighting the VSPackage framework is where the bulk of the work is so I don't think the eclipse one would help much :D
13:24:18 <joelteon> does forkIOWithUnmask avoid that?
13:24:35 <mkster_> Hello I am new to Haskell and I always get errors I can't fix when using / here is the code: http://lpaste.net/108197
13:25:10 <luite> joelteon: that's when you still start with exceptions masked, but unmask them explicitly later
13:25:14 <joelteon> okay
13:25:17 <joelteon> damn
13:25:56 <platz> Darwin226: ah, I haven't done vs plugins.  I mean, they recently added a Node plugin to vs.  supposedly it's just a shell that interfaces with V8 or whatever runtime
13:26:00 <luite> async exceptions are one of the more tricky corners of haskell, to use and to implement :)
13:26:25 <platz> but yeah I imagine there are a lot of hairy API's there to work with
13:26:48 <Darwin226> Can I get type info from a file that contains errors?
13:27:08 <luite> Darwin226: yes, use -fdefer-type-errors
13:27:30 <Darwin226> luite: As a ghc option?
13:27:54 <luite> Darwin226: yeah, it'll turn them into runtime errors
13:28:30 <Darwin226> luite: What If I have syntactic errors?
13:28:46 <Darwin226> luite: (talking about ghc-mod)
13:28:48 <luite> Darwin226: then no
13:28:57 <luite> not from GHC at least
13:29:20 <Darwin226> luite: Well, that does make sense but it would be nice if it somehow processed the working part of the file
13:29:25 <mwhit> mkster_: first of all, always annotate top-level definitions with what type signature you think it has
13:29:34 <mwhit> this will help GHC tell you what's going wrong
13:29:37 <darthdeus> int3__: are you planning on fixing the check inconsistency issue? :P
13:30:04 <mkster_> mwhit: I tryed nextCollatz :: Double -> Double but I have no idea
13:30:23 <mwhit> in this case, your function has type (Num a, Integral a1, Fractional a1) => a -> a1
13:30:35 <mwhit> no default type satisfied both Integral and Fractional
13:30:52 <mwhit> use `div` instead of / and that will probably do what you want
13:31:03 <luite> Darwin226: it'd be an interesting project to replace GHC's parser with an incremental parser and have the typechecker propagate inferred constraints in a way that's associative
13:31:14 <int3__> darthdeus: I tried building ghcmod yesterday, and *I think* the devs are building against GHC HEAD, because cabal complains that my 7.8.3 depends on an conflicting outdated version of transformers, or something
13:31:16 <mwhit> new people get tripped up by basic numerical stuff because haskell is very rigorous about what operations can be applied to what kinds of numbers
13:31:21 <int3__> darthdeus: so, probably not :P
13:31:41 <Darwin226> luite: That's outside the scope of my project and my mental capacity I'm afraid :D
13:31:47 <darthdeus> int3__: hehe, last time i tried to fix this by introducing a server wrapper i spent like 3 days on it and didn't get very far :||
13:32:09 <darthdeus> int3__: https://github.com/darthdeus/ghc-mod-ng :D
13:32:39 <int3__> darthdeus: was ghc-modi not available then?
13:32:59 <int3__> but yeah, the code isn't exactly what I'd call pretty
13:33:24 <int3__> but I'm glad someone took the effort to figure out enough of ghc to get that much working
13:33:36 <mkster_> mwhit: still not working http://lpaste.net/108198
13:34:15 <luite> Darwin226: just upgrade your mental capacity :)
13:34:33 <mwhit> mkster_: It's good you added the annotation, but the important point was "no default type satisfies both Integral and Fractional"
13:34:43 <darthdeus> int3__: it was but I'm not really inclined to vimscript
13:34:47 <mwhit> your function is demanding that the return type be both an integer and a non-integer
13:34:49 <nick_named> mkster__: why are you using Fractional?  You only divide even numbers in the Collatz sequence
13:35:07 <mwhit> nick_named: He just added the type that ghc inferred
13:35:20 <nick_named> mkster__: User `div` for Integral division, instead of (/)
13:35:29 <mkster_> oh ok thanks nick_named
13:35:29 <nick_named> :t div
13:35:30 <lambdabot> Integral a => a -> a -> a
13:35:34 <mwhit> yeah i told him
13:36:07 <mkster_> but if I'd liked to use \ in theory how would I do that?
13:36:10 <Darwin226> luite: Afraid that would need a hardware upgrade.
13:36:12 <nick_named> mkster__: You should memoize that function for great speed, I'm assuming you're doing project euler #14
13:36:38 <mkster_> I am not but thanks
13:37:07 <nick_named> Still, its easy to memoize using an Array
13:38:08 <luite> Darwin226: but with some additional layout processing, you can probably reasonably reliably find the next 'reset point' (top level) if parsing something fails. then you'd return one errored declaration and continue as normal after dropping all tokens until that point
13:38:57 <kazagistar> nick_named: can you do that kind of memoization in a transparent way in haskell?
13:39:16 <int3__> darthdeus: oh, I guess you were trying to add your own server that could be invoked like usual from the command line, but would look up a server in the background. When you said 'wrapper' I imagined an external script interfacing with ghc-modi -- it could launch modi, save its process number to a hidden file, then check for the existence of that process the next time it gets invoked. kind of what the vimscript is doing, actually, just more ha
13:39:16 <int3__> cky
13:39:43 <darthdeus> int3__: yes :) i actually have a working version of that in ruby
13:39:44 <int3__> darthdeus: would be easier to hack up, probably, but it does feel rather wrong
13:39:46 <int3__> ah
13:39:50 <darthdeus> int3__: https://github.com/darthdeus/ghc-modi-wrapper
13:40:21 <darthdeus> it just forks a process and uses domain sockets for talking with ghc-modi
13:40:21 <chrisdone> oh no
13:40:23 <int3__> oh, yeah, I realize I must've seen that before
13:40:27 <chrisdone> i looked at the source and then read the README
13:40:28 <int3__> when googling for solutions
13:40:40 <darthdeus> chrisdone: hah :P
13:41:00 <chrisdone> will they come late in the night? (゜。゜)
13:41:22 <joelteon> can't I force a forkIO'd thread to die when its parent dies?
13:41:27 <nick_named> kazagister: One of the general patterns is to use a helper function to generate a table that refrences the table.
13:41:39 <luite> joelteon: nope
13:41:45 <darthdeus> chrisdone:  ╯‵Д′)╯彡┻━┻
13:41:48 <joelteon> really?
13:41:49 <joelteon> damn
13:41:52 <chrisdone> joelteon: with async you can
13:42:11 <monochrom> or you can do what async does internally
13:42:47 <luite> joelteon: you'll have to do it explicitly, or use some lib for it, since the rts doesn't keep track of parents of forkIO threads
13:42:57 <kristof> Do forked async processes have lifetimes tied to their parents?
13:42:58 <joelteon> oh, so that'll involve using the RTS
13:43:12 <chrisdone> http://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html#v:link
13:43:21 <darthdeus> any solution at all will do :P
13:43:54 <darthdeus> chrisdone: isn't that the other way around?
13:44:18 <darthdeus> since that links the async's exception to the parent
13:46:53 <chrisdone> oh, uh, the reverse, withAsync
13:47:32 <darthdeus> that doesn't seem to be what I need
13:47:47 <darthdeus> basically the problem is that DevelMain.hs throws ThreadKilled to the main yesod thread
13:47:58 <darthdeus> but that doesn't child any of the threads I've forked myself
13:48:30 <monochrom> so perhaps don't fork yourself, use withAsync throughout
13:48:42 <chrisdone> right
13:49:06 <darthdeus> but
13:49:24 <chrisdone> otherwise greg webber has some code for this too, hang on
13:49:38 <darthdeus> withAsync doesn't do what I want
13:49:44 <darthdeus> i mean
13:49:51 <darthdeus> withAsync == async + cleanup no?
13:49:58 <monochrom> pretty much
13:50:07 <monochrom> like withFile
13:50:31 <darthdeus> but withAsync is using forkIO
13:50:34 <chrisdone> https://github.com/yesodweb/yesod-scaffold/pull/21#issuecomment-45419994
13:50:36 <darthdeus> isn't it?
13:50:38 <monochrom> yes internally
13:50:50 <darthdeus> then how can it do something I can't do with forkIO?
13:51:22 <monochrom> it doesn't just forkIO, do you understand? it also remembers the thread ID for killThread later
13:51:41 <monochrom> <monochrom> or you can do what async does internally
13:52:15 <monochrom> you can always look at async's source code and do the same thing yourself. do your own bookkeeping. do your own bracketting. etc etc.
13:52:51 <darthdeus> hmm
13:53:05 <darthdeus> let me test this out
13:53:24 <chrisdone> depends what your threads are for
13:53:42 <chrisdone> if they're launched just once in your yesod application you could withAsync it
13:55:26 <chrisdone> if they're launched on web handlers, yeah, i don't see anything in the async api. it's just more reliable to use async when it does what you want as it handles all the mess
13:56:32 <chrisdone> making programs tear down better would be a nice general direction
13:56:42 <chrisdone> i run and restart almost everything in ghci these days =3
13:57:27 <darthdeus> I'm basically just running a loop that sends some requests and logs some things
13:57:49 <chrisdone> so it's just a single worker thread?
13:57:50 <platz> is there a way to set -fdefer-type-errors in ghc-mod while in a vim session, so I can get types of exprs inside vim?
13:57:56 <darthdeus> chrisdone: yes
13:58:23 <platz> (or emacs for that matter)
13:58:44 <chrisdone> darthdeus: so you're launching it inside Application.hs?
13:58:59 <darthdeus> hmm looks like   flip withAsync wait myMAgicWorker    does work
13:59:07 <darthdeus> chrisdone: yes inside makeFoundation/makeApplication
13:59:11 <chrisdone> cool
13:59:21 <darthdeus> I haven't found a better way to put it
13:59:23 <darthdeus> :(
13:59:29 <chrisdone> seems the proper way to do it
13:59:36 <chrisdone> 'proper' as in the yesod way
14:01:05 <darthdeus> I'm like uber confused now, withAsync in my implementation just calls bracket (async x) cancel wait
14:01:07 <darthdeus> and it works
14:01:18 <chrisdone> ok?
14:01:26 <darthdeus> but why didn't it exit before?
14:01:50 <darthdeus> I mean bracket is just like try/catch with masking and a finalizer
14:01:53 <chrisdone> the 'cancel' kills the child thread
14:01:59 <darthdeus> but what prompts the cancel?
14:02:07 <darthdeus> oh shit is that the ThreadKilled?
14:02:08 <chrisdone> the ending of the main thread
14:02:10 <chrisdone> lol yeah
14:02:22 <int3__> platz: https://github.com/kazu-yamamoto/ghc-mod/commit/c8fbdcfa2f332cd6325961f6b2b208198e452ac0 suggests that the answer is 'yes', but I'm not sure if it's turned on by default. if you look at the vim-ghcmod docs there's a way to pass custom options to ghc, so that might be helpful. let me know if you find out :P
14:02:36 <darthdeus> ok here's more noob question, if the ThreadKilled was previously captured by the toplevel handler, how come it continues running?
14:02:45 <darthdeus> i mean it had to bubble from my action up
14:02:50 <darthdeus> otherwise bracket wouldn't catch it
14:02:57 <chrisdone> so let's break this down
14:03:07 <platz> int3__: oh thanks! today is a good day :)
14:03:26 <chrisdone> your DevelMain is running forkIO and keeping hold of the ThreadId for your whole yesod application
14:03:38 <chrisdone> and then later when restarting, it runs killThread on that id, right?
14:03:43 <darthdeus> yes
14:03:59 <darthdeus> and that raises ThreadKilled in all children, who ignore that exception in their toplevel handler, afaik
14:04:10 <platz> int3__: I'll let you know if i find anything
14:04:51 <chrisdone> darthdeus: no, killThread only targets the thread you give it. children aren't tied to parents
14:05:06 <chrisdone> but the code
14:05:09 <int3__> platz: I spent two days trying to make my vim experience more pleasant, and was partially successful, but I now remember why I loathe vimscript so much :P so I've been answering ghcmod questions but I refuse to fiddle with the code any more
14:05:41 <darthdeus> chrisdone: but the docs for forkIO say this "The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and ThreadKilled, and passes all other exceptions to the uncaught exception handler"
14:06:04 <darthdeus> and if I understand correctly, that handler is at the top level of the thread, otherwise my bracket wouldn't be able to catch ThreadKilled
14:06:19 <chrisdone> darthdeus: right, but what does that have to do with different threads?
14:07:04 <darthdeus> chrisdone: I thought that when you killThread on the main, it sends ThreadKilled to all the children, who ignore that exception by default
14:08:14 <chrisdone> hmm, i think the process ending just kills threads
14:08:33 <chrisdone> λ> do tid <- forkIO (do forkIO (do threadDelay (1000 * 1000 * 2); putStrLn "Hello!"); threadDelay (1000 * 1000 * 1);  putStrLn "World"); killThread tid
14:08:34 <chrisdone> Hello!
14:08:50 <chrisdone> "Hello!" is still printed here, despite its parent thread being killed
14:08:58 <monochrom> darthdeus: in bracket, the "finalizer" is literally Java's "finally", it is run on normal exit as well as exceptional exit
14:09:19 <platz> int3__: lord, it looks like it actually works
14:09:23 <platz> let g:ghcmod_ghc_options = ['-fdefer-type-errors']
14:09:35 <monochrom> and you can read bracket's source code to see why
14:09:53 <chrisdone> it would be neat if lambdabot supported threads and putStrLn
14:10:18 <chrisdone> just a few IO functions
14:10:19 <platz> although it kind of hides the errors too well, need to do a :GhModCheck to tell if there are any problems
14:10:36 <monochrom> unfortunately, when main exits (normally or exceptionally), GHC runtime does not care about the rest of the threads. they just disappear.
14:10:45 <chrisdone> right
14:10:46 <int3__> platz: oh, nice. it really should be enabled by default, heh
14:11:09 <chrisdone> if you run :main in ghci and main launches some threads, they'll keep running afterwards
14:11:12 <monochrom> but you can use "bracket" or "finally" to do whatever cleanup you see fit.
14:11:33 <int3__> platz: does it mean that GhcModCheck doesn't pick up type errors too?
14:11:33 <platz> int3__: maybe, maybe not.  kind of misleading when you have main :: IO (); main = 2
14:11:43 <monochrom> you have to explicitly care about the threads you care about, in other words.
14:11:56 <platz> int3__: it does show the warnings, yes
14:12:06 <darthdeus> I guess I still don't understand the part where bracket figures out that the parent actually died
14:12:08 <int3__> ah okay
14:12:22 <monochrom> huh? read bracket's source code, it's easy
14:12:26 <platz> int3__: but if you do GhcModType on something wierd it might "lie" toyou
14:12:27 <darthdeus> I'm reading it
14:12:32 <chrisdone> monochrom: like monoids?
14:12:34 <platz> like main = 2
14:12:57 <int3__> platz: obvious solution would be to run 'type' with defer-type-errors but 'check' without
14:12:59 <monochrom> no, bracket is not quite like monoids
14:13:09 <darthdeus> ok let's decompose this, if a parent dies, does the child get an exception raised in it?
14:13:20 <chrisdone> no, i demonstrated that above
14:13:20 <monochrom> not automatically
14:13:24 <chrisdone> λ> do tid <- forkIO (do forkIO (do threadDelay (1000 * 1000 * 2); putStrLn "Hello!"); threadDelay (1000 * 1000 * 1);  putStrLn "World"); killThread tid
14:13:25 <int3__> platz: but I don't know if that requires ghcmod level support or can be done from the plugin
14:13:25 <chrisdone> Hello!
14:13:38 <darthdeus> then how does bracket call it's finalizer
14:13:42 <chrisdone> however, withAsync *does* do that:
14:13:44 <darthdeus> the onException part never happens
14:13:44 <chrisdone> λ> withAsync (do threadDelay (1000 * 1000 * 2); putStrLn "Hello") (const (return ()))
14:13:45 <chrisdone> λ> withAsync (do threadDelay (1000 * 1000 * 2); putStrLn "Hello") (const (threadDelay (1000 * 1000 * 3)))
14:13:45 <chrisdone> Hello
14:14:06 <chrisdone> bracket is a resource allocation tool
14:14:08 <monochrom> "how does bracket call its finalizer" is orthogonal to parent-child relations
14:14:16 <platz> int3__: well GhcModCheck will show the type errors as warnings with -fdefer-type-errors, so if you're ok with warnings then it just works
14:14:18 <chrisdone> 1) acquire the resource, (2) use the resource, (3) free the resource
14:14:31 <darthdeus> monochrom: yes, given that bracket returns immediately, where comes the finalizer call from?
14:14:50 <monochrom> bracket does not return immediately
14:14:52 <platz> not sure how your vim is set up to highlight exprs
14:14:57 <platz> on errors
14:15:04 <darthdeus> if the action is forking a thread it does no?
14:15:13 <int3__> platz: ah, right, I didn't properly read what you typed earlier
14:15:31 <chrisdone> λ> bracket (forkIO (do threadDelay (1000 * 1000); putStrLn "I'm just a kid!")) (const (putStrLn "Hello!")) killThread
14:15:32 <chrisdone> Hello!
14:15:44 <monochrom> then the finalizer runs immediately after
14:15:45 <chrisdone> the child is killed by bracket after the putStrLn finishes
14:16:45 <chrisdone> bracket <acquire> <use> <free>
14:17:05 <monochrom> the line "_ <- after a" runs the finalizer
14:17:14 <chrisdone> λ> bracket (forkIO (do threadDelay (1000 * 1000); putStrLn "I'm just a kid!")) (const (error "Oh noes!")) killThread
14:17:14 <chrisdone> *** Exception: Oh noes!
14:17:29 <jle`> he was just a kid :/
14:17:31 <chrisdone> ^ see also how this *still* runs killThread. killThread runs in any eventuality
14:17:49 <darthdeus> I need to cleanup my example, one sec
14:17:49 <sleepomeno> in emacs interactive-haskell repl i get weird output with a lot of "^H" when I run a verbose quickcheck test. How do I get rid of that? It looks like that: "Falsifiable (after 2 tests and 2 shrinks)..." and so on
14:17:58 <chrisdone> jle`: http://favim.com/orig/201103/26/Favim.com-8742.jpg
14:18:16 <jle`> heh
14:18:21 <chrisdone> sleepomeno: oh, it's because quickcheck assumes it's talking to a terminal. umm
14:18:25 <jle`> im going to...lock my doors really quickly
14:19:13 <chrisdone> sleepomeno: i can probably add support for this somehow
14:19:17 <chrisdone> Feuerbach: hey dude =)
14:19:57 <darthdeus> oh shit now i understand
14:19:58 <chrisdone> sleepomeno: ^H is a kind of eraser character for terminals
14:20:41 <chrisdone> sleepomeno: can you give me a simple example i can copypaste into my repl?
14:20:58 <darthdeus> I thought that I can do this in a way that it would print "waiting" and then 2 seconds later "hello"
14:21:05 <darthdeus> withAsync (threadDelay 2000000 >> putStrLn "hello") wait >> putStrLn "waiting" >> threadDelay 10000000
14:21:16 <darthdeus> but I can't since the wait is blocking
14:21:57 <sleepomeno> chrisdone: just a moment..
14:22:19 <darthdeus> chrisdone: i guess I understand the bracket part, but now I don't know how to run my thread and have it killed as well
14:24:37 <sleepomeno> chrisdone: http://lpaste.net/108201
14:25:22 <chrisdone> sleepomeno: thanks, i can reproduce
14:25:45 <darthdeus> chrisdone: i mean in this example ... withAsync (do threadDelay (1000 * 1000 * 2); putStrLn "Hello") (const (threadDelay (1000 * 1000 * 3))) ... it requires me to put everything in the app after my async thing
14:26:08 <darthdeus> but I can't do that in makeFoundation since that call needs to return
14:27:11 <chrisdone> darthdeus: hmm, yeah, makeApplication or makeFoundation don't have control
14:27:54 <chrisdone> darthdeus: nevermind then, i guess just stick a threadid in your App type and kill it in develmain or however you want
14:27:58 <darthdeus> so I guess I have to store the threadId on the App
14:27:59 <darthdeus> yeah :|
14:28:10 <darthdeus> well thanks anyway :)
14:28:27 <chrisdone> welcome ≖‿≖
14:28:46 <chrisdone> sleepomeno: i'll try making ^H actually delete characters in the output
14:30:26 <monochrom> this is a good time to say: I hate^H^H^H^Hlove haskell-mode :)
14:30:37 <chrisdone> ;)
14:32:26 <darthdeus> oh and about haskell-mode :P is there a way to make the repl "not stop working" when I start typing like this λ>1+1  instead of λ> 1+1  (note the extra space) ... ? I'm quite often doing C-c C-k
14:32:29 <monochrom> hi, I have main = putStrLn "I hate\b\b\b\blove haskell-mode", I run it in emacs...
14:32:34 <darthdeus> or is that like emacs repl-ish limitation?
14:33:48 <chrisdone> darthdeus: umm, i could make the prompt read-only ;)
14:34:05 <chrisdone> i'm surprised it's not, actually. seems an oversight
14:34:16 <darthdeus> huh you never happened to accidentaly delete it?
14:34:22 <ReinH> Yeahhhh
14:34:23 <jle`> chrisdone: you're supposed to say it's a feature
14:34:24 <darthdeus> happens to me like bazillion times a day
14:34:38 <chrisdone> darthdeus: no, i guess we navigate differently
14:34:48 <kini> I thought that was the standard emacs way lol
14:34:53 <kini> M-x shell has the same problem
14:34:58 <kini> I'm always deleting my prompt by mistake
14:35:03 <darthdeus> chrisdone: especially since I use evil-mode ... and when I'm in insert mode and press Esc I go one character back, then in insert mode again and I'm one space to the left than I should be :P
14:35:03 <monochrom> haha feature
14:35:04 <kini> or part of it
14:35:06 <chrisdone> my cursor is always after that position, it'd only get there if i manually chose to go before teh start
14:35:09 <kini> darthdeus: same!
14:35:14 <chrisdone> oh, evil-mode. bah
14:35:16 <kini> ok, so evil-mode is the cause of this
14:35:17 <kini> lol
14:35:18 <darthdeus> kini: hah I'm happy I'm not the only one using evil
14:35:22 <darthdeus> ah i am
14:35:23 <darthdeus> :(
14:35:25 <kini> or rather, the movement patterns resulting from using evil-mode
14:35:37 <chrisdone> yeah, evil-mode doesn't seem to respect normal emacs things
14:35:42 <darthdeus> hmm it is read only
14:35:54 <kini> evil-mode lets you delete stuff that's "read-only" when in normal state
14:35:55 <darthdeus> but if I go to insert mode in the middle and start typing i can modify it
14:36:02 <chrisdone> C-a in the REPL takes you to "λ> ". but i bet evil-mode takes you to "λ>"
14:36:03 <darthdeus> kini: even in insert
14:36:08 <darthdeus> well not delete but insert
14:36:10 <kini> not by backspacing into it
14:36:30 <kini> chrisdone: no, "A" is "go to end of line and enter insert state", and that works fine
14:36:31 <darthdeus> chrisdone: C-a works, but not if you're already in the wrong place
14:36:49 <darthdeus> yeah A works
14:36:56 <kini> it's just that vim's behavior is to move back one character when going from normal state to insert state, and you can't highlight beyond the end of the line
14:36:59 <chrisdone> darthdeus: sure, if you're in the wrong place it assumes you want to do something funky and just does it =p
14:37:02 <kini> so if you're already at the end of the line and hit "i" then you'll be in the wrong place
14:37:09 <kini> you need to use "A"
14:37:33 <monochrom> software is hard
14:37:56 <chrisdone> let's go shopping for software
14:38:02 <darthdeus> would be nice if it automatically moved you to the right place when you start typing in the wrong place :P
14:38:14 <chrisdone> darthdeus: err, that i can do
14:38:14 <dolio> a is what you use to enter insert mode after the character you're on.
14:38:36 <kini> A goes to the end of the line and is what you want on a prompt line anyway
14:38:42 <kini> but a will work too if you happen to be sitting on the last character of the line
14:38:42 <sleepomeno> I also use "A" for that ;)
14:38:43 <darthdeus> chrisdone: would that work even with evil's "writing over readonly characters"?
14:38:59 <kini> btw there is an #evil-mode if anyone wants to talk to the evil people about this behavior in general
14:39:00 <chrisdone> what, evil-mode lets you write over read-only text?
14:39:24 <darthdeus> chrisdone: http://i.imgur.com/FGqaXuq.png
14:39:36 <chrisdone> ah, that text's not read-only
14:39:48 <darthdeus> hmm
14:39:53 <darthdeus> i suck at eamcs
14:39:54 <darthdeus> emacs*
14:40:02 <darthdeus> it doesn't let me change the prompt
14:40:05 <darthdeus> only write in the middle
14:40:11 <darthdeus> or in front, etc.
14:40:19 <chrisdone> well, it's read-only against changing, but i have to disable insert before or w/e
14:40:27 <chrisdone> hang on, i'll do sleepomeno's issue =p
14:40:34 <NikolajK> stupid question, what does "{ … }" mean in type definitions? can the be replaces?
14:40:37 <NikolajK> replaced
14:40:51 <NikolajK> often in assosciaten with runfoo
14:41:09 <chrisdone> { } defines a record data type, it means "here comes some fields"
14:42:25 <monochrom> NikolajK: "data X = Xtor { we :: Int, you :: Bool }" is like "data X = Xtor Int Bool" but you get nice field names you can use
14:44:32 <NikolajK> and if it says data X a = myX { f :: forall b.a->b }
14:44:43 <NikolajK> am I just demanding that f exists?
14:44:51 <monochrom> it cannot say "myX" there. need capital letter
14:44:58 <NikolajK> well okay
14:45:02 <NikolajK> Xmy :)
14:45:31 <monochrom> then it is "data X a = Xmy (forall b. a->b)" and a nice field name "f"
14:45:54 <monochrom> I do not know what means "demand that f exists"
14:46:58 <monochrom> a programming environment is not an economy. I cannot demand or supply in it.
14:47:27 <monochrom> it doesn't even take my bitcoins
14:47:36 <NikolajK> what is a "field name"
14:47:39 <NikolajK> a reserved name?
14:47:47 <monochrom> it is two things
14:47:48 <chrisdone> monochrom: fwiw that phraseology is weird, verb ("means") usually comes after the subject in question form
14:48:01 <jle`> NikolajK: are you following any sort of haskell introductory course or guide?
14:48:14 <jle`> if so, record syntax might come up soon enough, in the right context
14:48:35 <NikolajK> I was reading Real World Haskell, but don't know if it's for me
14:48:36 <monochrom> thing #1: it is a function name. you get this function automatically: we :: X -> Int; we (Xtor r _) = r. similarly you.
14:48:42 <jle`> i'll let monochrom finish though because he will probably explain everything well for you
14:49:16 <chrisdone> monochrom: tho i can't tell whether you're a native speaker or not, so if you are native, just ignore me for pointing out a typo, and if not, take it as a compliment =)
14:49:17 <hiptobecubic> Would anyone using vim+youcompleteme+necoghc that has completion working correctly like to tell me what's up?
14:49:22 <monochrom> thing #2: it can be used in a pattern. "mono Xtor{we=5} = True" is translated to "mono (Xtor 5 _) = True"
14:49:35 <jle`> if i have data IntAndBool = IntAndBool Int Bool, that means that an IntAndBool contains an Int and a Bool
14:49:47 <jle`> @let data IntAndBool = IntAndBool Int Bool
14:49:49 <lambdabot>  Defined.
14:49:58 <hiptobecubic> It's easy enough to set it to trigger after a '.', but you want completion whenever basically anything is typed...
14:50:04 <jle`> so i can create an IntAndBool by doing: myIntAndBool = IntAndBool 3 True
14:50:15 <jle`> i can also access it by pattern matching
14:50:32 <jle`> f (IntAndBool i b) = i + 2
14:50:37 <monochrom> chrisdone: I am not a native speaker. I am just too lazy to type out "what does ___ mean?" in full
14:50:41 <jle`> that'll take the int out of an IntAndBool and add two to it, and return the result
14:50:56 <jle`> record syntax allows you to "name" the fields
14:51:03 <chrisdone> monochrom: =)
14:51:19 <jle`> data IntAndBool = IntAndBool { theInt :: Int, theBool :: Bool }    --- a structurally identical type to the one above
14:51:20 <NemesisD> hey guys. i'm having a lot of difficulty getting haskell interactive mode working with cabal
14:51:48 <jle`> the above type does everything that you can do with the old one --- you can create something with IntAndBool 3 True, and pattern match out of it: f (IntAndBool i _) = i + 2
14:52:06 <NemesisD> when i try to start an inferior process it dies. cabal complains that the program "GHC" version >= 6.4 is required but couldn't be found. i totally have it. its both in my terminal path and ghc is findable via (executable-find "ghc")
14:52:07 <jle`> but giving the fields "names" gives you some neat toys too, to help you use the data type more smoothly
14:52:24 <jle`> for one, i have a free function to "extract" the Int:  theInt :: IntAndBool -> Int
14:52:38 <chrisdone> monochrom: i've another buddy who speaks perfect english, apart from one word he simply prefers and can't shake: in romanian "worth" is a verb, so he says "i don't know if it worths doing". i like this turn of phrase =)
14:52:47 <jle`> theInt is now a function that takes an IntAndBool and gives you the Int.  it's automatically made for you.  and theBool is now a function that takes an IntAndBool and gives you the Bool
14:53:02 <NikolajK> ah, the field named terms are the projections
14:53:07 <jle`> you also have free "setters":  IntAndBool { theInt = 4, theBool = True }
14:53:13 <chrisdone> sleepomeno: ok, i think i have a decent implementation here to apply the ^H deletions
14:53:17 * chrisdone testing
14:53:19 <jle`> NikolajK: yes, projections :)
14:53:34 <monochrom> I take liberty in "English keeps changing" and contribute my change. why not.
14:53:43 <jle`> you also get free setters, so you can 'construct' an IntAndBool in an order that suits you:  IntAndBool { theBool = False, theInt = 3 } works, too
14:54:21 <monochrom> there are a ton of changes I hate. so logically, either I advocate against changing, or I add the changes I like.
14:54:21 <jle`> you can also use it to modify a previous IntAndBool; if x = IntAndBool 4 True, then you can do y = x { theBool = False }, and y will = IntAndBool 4 False
14:54:26 <chrisdone> monochrom: =) indeed, almost everything we say came from some bold person just going for it =p
14:54:52 <jle`> NemesisD: what does ghc -v tell you?  also, are you doing cabal repl?
14:55:21 <NikolajK> theBool is the field name projecting out stuff and a tool to set values at once?
14:55:53 <jle`> NikolajK: yes; it is a function :: IntAndBool -> Bool in the normal value level world, but it also is your "key" in the record setting syntax, the x { .. } syntax
14:56:15 <NikolajK> not sure if that's a good idea
14:56:33 <jle`> what is?
14:57:07 <chrisdone> monochrom: yeah, it's like going into a forest and complaining about a tree growing in an otherwise clear area, blocking the light of the other trees
14:58:24 <NemesisD> jle` http://lpaste.net/108202
14:58:27 <chrisdone> the thousands of trees and diversity in this forest i'll accept, but THIS ONE THING, outrageous!
14:59:12 <hiptobecubic> chrisdone, i wonder if the 'worth' verb is in greek as well. I have a friend who does the same.
15:00:47 <fizbin> So on #haskell you can wander in a n00b and ask a "help?" question and usually get pretty good answers from a variety of people.
15:01:13 <chrisdone> hiptobecubic: interesting
15:01:15 <fizbin> On #haskell-lens you can do the same thing and get answers from ekmett
15:01:55 <fizbin> On #emacs, if your "help?" isn't part of the ongoing conversation, from what I can tell you get ignored.
15:02:29 <chrisdone> fizbin: as opposed to someone who isn't the author of the library that the channel is dedicated to?
15:02:29 <chrisdone> yeah, to get help on #emacs nobody really cares about answering unless it's trivial or interesting
15:02:49 <chrisdone> if it's just "how do i configure org-mode?" people will ignore that
15:03:19 <merijn> fizbin: Try asking "help?" in ##c and ##c++ :D
15:03:28 <fizbin> Fair enough.
15:03:44 <chrisdone> yeah, ##c is notorious for being unfriendly
15:03:46 <merijn> ##c and ##c++ are terrible hives of scum and villainy...
15:03:50 <chrisdone> has always been that way
15:04:11 <merijn> Every single time I have a question (and I like to think my questions are fairly smart and well-informed) I just get yelled at
15:04:30 <NemesisD> #mysql is very much like that. very rarely do i ask a question there and not get abused
15:04:33 <fizbin> I wonder if #ruby is as almost crazy n00b-friendly as the ruby-lang mailing list was back when I was a regular on it...
15:04:35 <chrisdone> yeah, it's a bit stockholmy in ##c too
15:04:40 <lf94> #python is friendly
15:04:49 <joelteon> you don't want to get too friendly, though
15:05:06 <hpc> how would it get "too friendly"?
15:05:15 <NemesisD> #ruby-lang is fairly friendly but frequently nobody in there knows what they're talking about. they try to help in earnest but dont have the knowledge
15:05:16 <merijn> lf94: #python has gone down hill a lot the past 5 years, though. Nowadays they assume everyone is a n00b and won't tell you how to do the dangerous advnaced stuff
15:05:21 <darthdeus> #haskell is imho way better than #ruby or #rubyonrails ... last time I asked a question there I got told to "gtfo unless you can show all the code" :D
15:05:23 <merijn> hpc: See my last line :)
15:05:25 <chrisdone> hpc: sharing brony tastes?
15:05:26 <Twey> lf94: Depends on who's in channel.  #python can certainly get quite unfriendly at times.
15:05:29 <NemesisD> if you manage to be around when a few of the greybeards are there you'll probably have a good time
15:05:54 <darthdeus> in a sense that "hire a contractor if your code is under NDA" :|
15:05:57 <chrisdone> NemesisD: yeah, #javascript is like that
15:06:00 <merijn> Any pipes experts around willing to help me? :p
15:06:12 <ReinH> NemesisD: some of us don't have grey beards :p
15:06:27 <chrisdone> ask a delicate technical question and get a brute answering you with a club
15:06:28 <hpc> NemesisD: in #haskell it's bowties, not greybeards
15:06:28 <NemesisD> ReinH: honorary at least
15:06:31 <Enigmagic> python causes grey hair?
15:06:34 <ReinH> Heh
15:06:35 <chrisdone> takes about 5 minutes to convince them you're not a newbie
15:06:42 <NemesisD> good because my beard only grows on my neck. wish i was kidding
15:06:53 <chrisdone> NemesisD: genetic neckbeard?
15:06:55 <darthdeus> every time I ask a questino here I get an answer from 50 people though <3 :P
15:07:09 <darthdeus> you guys are awsum
15:07:19 <Exio> chrisdone, that is one of the awesome things of #haskell
15:07:27 <ReinH>  Which can be its own problem ;)
15:07:28 <hpc> darthdeus: in majestic stereo? :P
15:07:30 <fizbin> darthdeus: When I was active on the ruby-lang mailing list, rails was just starting, and there was a *dramatic* difference between the pre-rails ruby community and the RoR folks.
15:07:36 <NemesisD> chrisdone: yep. and the neckbeard aint even strong. i max out at horrible neck stubble. i feel like its limiting my technical progression
15:07:48 <Twey> hpc: Surround sound these days, I think :þ
15:07:59 <hpc> @quote contrapunct
15:07:59 <lambdabot> No quotes match. My mind is going. I can feel it.
15:08:03 * Twey has no neck hair at all, feels quite inadequate
15:08:11 <chrisdone> nemesisd: perhaps if you shave it off it'll be like Samson and you'll loose your nerding abilities
15:08:16 <hpc> @quote fugue
15:08:16 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:08:37 <chrisdone> twey: my neck hair seems to grow more enthusiastically than my face
15:09:01 <fizbin> Namely, the pre-rails ruby community was incredibly nice, polite, etc. - basically, the tone set by Matz. The RoR folks... well, let's just say that the creator of RoR has a somewhat different temperament than Matz.
15:10:23 <Twey> chrisdone: Bragging ☹
15:10:36 <serobyte> hi all
15:10:37 <chrisdone> twey: http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310408064982.jpg
15:10:40 <NemesisD> chrisdone: LOL
15:10:46 <Twey> Hahah
15:10:51 <mwhit> i think any time you start getting that kind of attention from web dev in general you'll get that sort of change
15:10:51 <hpc> oh my
15:10:57 <Twey> Oh my, indeed
15:10:59 <mwhit> web dev is just so huge you get all kinds
15:11:23 <Twey> chrisdone: So how quickly does your face grow…?
15:11:26 <hpc> i find it's mostly full of people who think being able to use jquery makes them hot shit
15:11:34 <spott> So, in haskell, `type Time = Double` is pretty much just an alias, right?  But `newtype NewTime = NewTime Double` is a ompletely new type, and any function that works on `Double` won't work on NewTime
15:11:40 <Twey> spott: Yes
15:11:51 <hpc> who lack basic understanding like looking at error logs
15:11:52 <chrisdone> twey: i'm pretty sure my nose is racing my brow, and winning
15:11:59 <spott> so, `Time` is pretty much replaced everywhere with `Double` at compile time
15:12:00 <mwhit> spott: you can derive some typeclass instances that Double has, but other than that yes
15:12:13 <mwhit> yes again
15:12:13 <monochrom> yes
15:12:19 <chrisdone> spott: right, just an alias
15:12:40 <Twey> spott: The same also happens with the newtype, but a bit later.  ☺
15:12:41 <merijn> hpc: JavaScript *all* the things!
15:13:09 <chrisdone> merijn: including JavaScript!
15:13:10 <Twey> spott: A newtype is a type that disappears at runtime, basically.
15:13:23 <Twey> Has anybody written jsjs yet?
15:13:30 <chrisdone> twey: like a dancer, only their footprints are left behind
15:13:31 <monochrom> I am hot shit because I write javascript raw without jquery :)
15:13:35 <chrisdone> (in the form of instance dictionaries)
15:13:53 <spott> So, this idiom is impossible in haskell:  `f :: Time -> Time; f (3 :: Double) -- Fails to compile; g :: Double -> Double; g (3::Time) --Compiles`
15:13:58 <mwhit> spott: Probably the two main use cases for newtypes are defining alternate instances for typeclasses, or restricting the behavior or inhabitable values of the type in some way
15:14:00 <Twey> hpc: I think Web programming suffers from being cut off from the rest of the development community.
15:14:06 <chrisdone> monochrom: Always use protection. JQuery™
15:14:14 <spott> mwhit: I figured
15:14:39 <mwhit> spott: if Time is a newtype, neither of those will compile
15:14:45 <mwhit> if it's a type alias either will
15:14:45 <spott> mwhit: yup
15:14:48 <NemesisD> has anyone used orc? curious how it compares to async if at all
15:15:15 <monochrom> @let type MonoTime = Double; monof :: Time -> Time; monof x = x
15:15:16 <lambdabot>  .L.hs:153:10: Not in scope: type constructor or class ‘Time’
15:15:16 <Twey> mwhit, spott: They can also be nice when you have a type that's implementationally the same as another, but semantically different.  Like Time/Angle/Temperature/&c. — they can all be represented as Double, but you wouldn't want to accidentally use one instead of the other.
15:15:16 <lambdabot>  
15:15:17 <lambdabot>  .L.hs:153:18: Not in scope: type constructor or class ‘Time’
15:15:20 <serobyte> all of you talking about haskell? today is my first time i hear about, i'm a java dev
15:15:29 <monochrom> @let type MonoTime = Double; monof :: MonoTime -> MonoTime; monof x = x
15:15:34 <lambdabot>  Defined.
15:15:38 <serobyte> i like to see this kind of old style community
15:15:41 <monochrom> > f (3 :: Double)
15:15:41 <Twey> serobyte: Welcome to the club ;)
15:15:42 <lambdabot>  No instance for (GHC.Show.Show a0)
15:15:43 <lambdabot>    arising from a use of ‘M913898366670162393325532.show_M9138983666701623933...
15:15:43 <lambdabot>  The type variable ‘a0’ is ambiguous
15:15:43 <lambdabot>  Note: there are several potential instances:
15:15:43 <lambdabot>    instance [safe] GHC.Show.Show
15:15:48 <serobyte> thanks
15:15:49 <serobyte> :)
15:15:50 <monochrom> > monof (3 :: Double)
15:15:52 <lambdabot>  3.0
15:16:16 <chrisdone> serobyte: here's your complimentary bow tie and wizard hat
15:16:27 <spott> Twey: yea, but there are situations where you want to be able to use Time like a double, but you never want to be able to use a Double like a Time...
15:16:32 <chrisdone> (╯°□°）╯︵ X
15:16:35 <spott> Twey: hence the idiom I want to make work
15:16:41 <serobyte> oh great thanks
15:16:49 <spott> brb
15:16:50 <serobyte> I just lost mine lol
15:16:53 <mwhit> spott: in which case you just pattern match on the newtype constructor
15:16:56 <chrisdone> /\ノ( º _ ºノ)
15:17:11 <mwhit> to get at the Double inside
15:17:19 <Twey> spott: ‘Use Time like a Double’ — thankfully, GHC gives you some magic to automatically derive instances of the type inside the newtype.  So you can ‘newtype Time = Time Double deriving (Num)’, for example.
15:17:20 <ReinH>  Lol
15:17:43 <Twey> spott: And then you can ‘use Time like a Double’.
15:17:52 <int3__> Twey: jsjs is 'tachyon' -- a JS JIT in JS :P
15:17:59 <Twey> int3__: Nice, thanks
15:18:02 <mwhit> is Num derivable without GND?
15:18:10 <Twey> mwhit: Nope
15:18:19 <mwhit> didn't think so
15:18:29 <spott> GND?
15:18:42 <mwhit> -XGeneralizedNewtypeDeriving
15:18:43 <Twey> GenericNewtypeDeriving, the name of the extension that gives you this shortcut.
15:18:49 <Twey> Er, Generalized** right.
15:18:52 <spott> ah
15:19:47 <serobyte> guys i'm looking on haskell, but can I understand in practice which kind of software you produce with this language?
15:19:47 <spott> I'll be back later, have to go
15:19:56 <serobyte> *sorry i CAN'T
15:20:19 <mwhit> serobyte: what do you mean? it's a general purpose programming language
15:20:41 <mwhit> people have produced all "kinds" of software with it
15:20:56 <serobyte> i see that hat a very strange kind of programming
15:21:06 <MetaleerIsGay> METALEER IS A FUCKING FRUITY FAGGOT :D fgsdfgdfhdf
15:21:07 <jmcarthur> serobyte: pretty much anything you would use any other language for
15:21:09 <MetaleerIsGay> METALEER IS A FUCKING FRUITY FAGGOT :D fgssgsdgsdgsdg
15:21:11 <serobyte> and was asking if there's something particular
15:21:12 <MetaleerIsGay> METALEER IS A FUCKING FRUITY FAGGOT :D fgsvsdgsdgsdfsd
15:21:13 --- mode: ChanServ set +o monochrom
15:21:16 --- mode: ChanServ set +o jmcarthur
15:21:18 --- mode: monochrom set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.151.200.170.248
15:21:18 --- kick: MetaleerIsGay was kicked by monochrom (MetaleerIsGay)
15:21:19 --- mode: jmcarthur set -o jmcarthur
15:22:04 <serobyte> does make sense make a web application for large use with haskell?
15:22:10 <serobyte> for example
15:22:10 <benzrf> thank u based monochrom
15:22:11 <jmcarthur> sure
15:22:48 <serobyte> do you know any example open source where I can take a look?
15:22:53 <mwhit> serobyte: sure haskell's web frameworks are less mature than some of the more common languages you'd use for that purpose, but it's an area of active development and there's nothing stopping you
15:22:56 <serobyte> of web app
15:23:04 <chrisdone> monochrom, i prescribe to the patient some ointment for that whiplash
15:24:31 <serobyte> mwhit: what is your last work in haskell?
15:24:36 <Twey> serobyte: chrisdone has done quite a few, I think.
15:24:48 <serobyte> mwhit: if it is not a problem to ask
15:25:22 <serobyte> chrisdone: could you show me something???
15:25:50 <serobyte> not your photos
15:25:55 <serobyte> :P
15:25:56 <chrisdone> ( ͡° ͜ʖ ͡°)
15:26:27 <liyang> chrisdone: show serobyte your pokeymans.
15:26:46 --- mode: monochrom set -o monochrom
15:27:00 <chrisdone> serobyte: http://lpaste.net http://ircbrowse.net/ http://haskellnews.org https://new-www.haskell.org https://www.fpcomplete.com/
15:27:05 <chrisdone> serobyte: these are all written in haskell
15:27:35 <serobyte> thanks
15:27:37 <chrisdone> all but the last have a link to a github repo on the footer
15:27:53 <chrisdone> oh also http://tryhaskell.org/
15:27:59 <Twey> chrisdone: So when are we seeing new-www live?  :þ
15:28:20 <chrisdone> Twey: i think some cleanup of the / namespace needs to be done
15:28:45 <chrisdone> Twey: e.g. remnants like this http://www.haskell.org/happy/
15:28:54 <chrisdone> are to be moved to projects.haskell.org or something
15:29:12 <chrisdone> and i want to rewrite the homepage content
15:29:19 <liyang> serobyte: also, http://hackage.haskell.org/
15:29:27 <Twey> Uhuh
15:29:34 <chrisdone> https://github.com/haskell-infra/hl/issues/11
15:29:49 <NemesisD> anyone know what's going on here with haskell-mode? http://lpaste.net/108202
15:29:53 <chrisdone> but i kinda got turned off by the discussion in there, maybe i'll do it if i have nothing better to do :3
15:30:07 <djahandarie> chrisdone, I noticed that you've used both Snap and Yesod. Do you have a favorite these days?
15:32:21 <chrisdone> djahandarie: not much of a favourite. i'm using yesod more these days because i use it at work and have gotten more familiar with it
15:32:38 <chrisdone> the type-safe routes are nice
15:32:56 <chrisdone> http://chrisdone.com/music <- this is in scotty. just because, i felt like trying scotty
15:33:23 <djahandarie> I see. The template haskell has always just scared me. And I've heard horror stories about compile times. But maybe I should try it out.
15:33:27 <djahandarie> (Re Yesod.)
15:33:51 <chrisdone> yeah, i don't like the template-haskell stuff either
15:34:07 <chrisdone> i use it to setup my routes, which i do like
15:34:17 <chrisdone> i don't like the makeApplication stuff because it's basically magic
15:34:27 <chrisdone> and the hamlet embeding widget stuff doesn't appeal to me much
15:34:33 <chrisdone> so i don't use the latter
15:35:42 <djahandarie> (P.S. Orion is a great song.)
15:36:12 <chrisdone> but the alternative is to write out a bunch of data types and instances manually. the base itself is just a set of pretty well thought out type families bore from experience, i think
15:36:21 <chrisdone> djahandarie: yeah, i listened to it on repeat earlier this evening =p
15:38:22 <chrisdone> djahandarie: i think blaze is way better than templates, in so many ways
15:38:49 <benmachine> <3 blaze
15:38:52 <chrisdone> i don't really see any redeeming qualities to hamlet templates
15:40:12 <chrisdone> (1) it's not real HTML, so the "familiarity" for web designers advantange normally spouted by template enthusiasts isn't there
15:40:13 <chrisdone> (2) it's a limited made up language that can only do iteration and casing, no abstraction
15:40:13 <chrisdone> (3) the actual syntax is hard to remember and harder to lookup, you basically have to hunt through the book to see if there's a syntax to do what you want
15:40:28 <chrisdone> (4) bad editor support
15:40:58 <djahandarie> I assume you have similar complaints with Heist?
15:41:25 <mwhit> but the hamlet/cassius/julius names are so terribly clever
15:41:27 <chrisdone> whereas blaze-html:
15:41:27 <chrisdone> (1) good editor support (it's haskell!)
15:41:27 <chrisdone> (2) no teaching/learning required (it's haskell!)
15:41:27 <chrisdone> (3) supports abstraction where abstraction = just like this
15:41:30 <mwhit> surely that counts for something
15:41:30 <chrisdone> (4) supports extension, just define a new function
15:41:33 <chrisdone> (5) the whole API is on haddock, easy to lookup
15:41:45 <chrisdone> djahandarie: yeah, i think all templating languages have the same problem
15:41:53 <chrisdone> i've had the same experience with rails
15:41:56 * djahandarie vaguely agrees
15:41:57 <darthdeus> though blaze takes more time to write than hamlet :(
15:42:10 <darthdeus> (from experience of having one happstack app with everyting in blaze)
15:42:26 <darthdeus> and it's horrible to read when you just have a lot of html
15:42:31 <chrisdone> you have your moustache or whatever template, and you have a "helpers" file of the same name to patch up when your templates can't do something. you end up writing a bunch of code in ruby anyway
15:43:03 <chrisdone> darthdeus: you mean having a big block of code?
15:43:37 <darthdeus> chrisdone: well I've been reading html all my life, so I'm kinda good at reading a lot of html :) but having worked with blaze for a while it feels a bit wrong
15:43:56 <chrisdone> i see ;)
15:44:10 <chrisdone> i tend to just split up things into separate small components
15:44:21 <chrisdone> then i don't have to read "a lot"
15:44:32 <darthdeus> in rails I just use http://slim-lang.com/
15:44:59 <djahandarie> I think one nice thing here would be even better editor support for Haskell. Like being able to inline things as a preview.
15:45:01 <NemesisD> last time i wrote some blaze html i found it kind of resisted abstractions like reader because of the heavy nesting
15:45:12 <NemesisD> i ended up passing in arguments and things got way smoother
15:45:32 <c_wraith> Yeah, I only used blaze once.  It's not a good tradeoff in terms of cost/power
15:45:48 <NemesisD> c_wraith go on
15:45:58 <darthdeus> imho yesod's widgets help with this a bit
15:46:21 * Hodapp reads about all this web stuff, and immediately starts vomiting.
15:46:22 <chrisdone> NemesisD: yeah, i just pass arguments in. it hasn't been bad enough for me to wish for a reader yet
15:46:27 <Hodapp> some warning, please, guys.
15:46:34 <c_wraith> NemesisD: it's more verbose than plain html, harder to use, and it doesn't give you any real safety in return.
15:46:36 <benmachine> TW webdev?
15:46:43 <darthdeus> like i've literally inlined half of my html in quasiquotes in the haskell file, but maybe that's just me sucking at emacs file navigation
15:46:53 <NemesisD> chrisdone i think if i ever got the twinge to do a reader again i'd roll up my context into a bespoke type and would get most of the value
15:47:13 <darthdeus> Hodapp: haha :P
15:47:14 <chrisdone> NemesisD: right
15:47:19 <NemesisD> c_wraith: how do you template with html?
15:47:34 <c_wraith> NemesisD: I switched to writing services that only output json.  :P
15:47:34 <NemesisD> because if you need interpolation im not sure i can agree that its giving you no real safety
15:47:47 <c_wraith> NemesisD: but if I was going to be producing html, I'd use heist
15:47:53 <chrisdone> the hairiest page on lpaste is still pretty legible to me https://github.com/chrisdone/lpaste/blob/master/src/Hpaste/View/Paste.hs
15:48:10 <NemesisD> c_wraith: why would you prefer heist?
15:48:16 * darthdeus looked at the amount of blaze and started vomiting as well
15:48:36 <c_wraith> NemesisD: I get to put html in external files that I can tell my editor to treat at html files, and they just work.
15:48:42 <chrisdone> darthdeus: the Paste.hs is vomit-worthy? =p
15:48:43 <c_wraith> *treat as
15:49:00 * djahandarie thinks it would be neat if an IDE could highlight all the Blaze tags.
15:49:24 <darthdeus> chrisdone: imho one big problem with blaze is that it really mixes the html with haskell, so that you can't actually just scan the document and be like "oh this is just some simple interpolation here and the rest is a form"
15:49:28 <darthdeus> but here i have to read everything
15:49:49 <NemesisD> c_wraith on the html in other files front, you can do that with blaze too though right, just as a module
15:49:56 <darthdeus> like you mentioned that hamlet only supports a few things, but that's a good thing from the person-who-deals-with-ui perspective, since it forces you to put the logic elsewhere :P
15:50:27 <c_wraith> NemesisD: not really.  You have to use haskell syntax rather than html syntax.  Adds a ton of constraints.  You can't just use the html editing toolkits you already have.
15:50:36 * djahandarie wanders off, thx for the discussion
15:50:38 <chrisdone> darthdeus: well, it's all view code. but the declaration type-sigs show what's a form and what's a html
15:50:57 <NemesisD> c_wraith i guess you trade them for the haskell editing toolkits you already have, but i get your point
15:51:38 <darthdeus> chrisdone: what about all that monadic/applicative shit around it? :P
15:52:11 <Exio> if i do "something" :: sometype, will this use read?
15:52:14 <darthdeus> <form action=foo>^{yoloIAMAForm}
15:52:18 <darthdeus> vs
15:52:34 <darthdeus> formlet name $ \value -> do select ! A.name (toValue name) $ forM_ values $ \(key, title) -> do ...
15:52:57 <chrisdone> darthdeus: well, technically it's
15:53:10 <chrisdone> postForm ! A.action (toValue action) $ formletHtml (pasteSubmit pf) pfParams
15:53:25 <vanila> Exio, no you have to write read "something"
15:53:43 <darthdeus> (ಠ_ಠ)
15:53:44 <chrisdone> darthdeus: the yoloIAMAForm is equivalent to pasteSubmit
15:53:52 <chrisdone> darthdeus: so i don't see where they differ
15:54:13 <jle`> one is more vicarious
15:54:40 <darthdeus> in the way that when you're editing the html you don't have any haskell around it, only one interpolation thingy which is highlighted by the editor
15:54:45 <darthdeus> and the rest is nicely highlighted html
15:54:57 <chrisdone> sure, you really really like html, i get that
15:55:01 <darthdeus> :D
15:55:03 <chrisdone> i really like haskell =)
15:55:33 <darthdeus> http://i.imgur.com/mlHxNFo.png
15:55:47 <chrisdone> the trouble also with templating languages is your view will get mixed up with your controller
15:55:52 <darthdeus> i guess it's my html spirit, but it just feels right
15:56:01 <c_wraith> I'm not against generating html with haskell.  I'd just prefer do it at a higher level than putting trees of tags in the code.
15:56:17 <c_wraith> chrisdone: that's also the problem with not using templating languages.
15:56:27 <chrisdone> because you have to write those "helpers". so in practice, i see yesod code all the time where some view code is in haskell, some in the templates, and if you want to find where something is, you don't have just one place to look
15:56:45 <c_wraith> chrisdone: that's a problem with dynamically generating html no matter how you do it.
15:56:51 <jle`> i like seeing views as data, not as logic
15:56:55 <jle`> or code
15:56:56 <chrisdone> c_wraith: not in my experience. my View module is all Markup generation. i have full haskell at my fingertips to generate a pure Markup value
15:57:08 <darthdeus> having "one place to look" imho isn't solved by having a 2000 line blaze file :D
15:57:20 <c_wraith> chrisdone: so you're saying you have a huge block of logic intertwined with your views?
15:57:22 <chrisdone> darthdeus: where do you see a 2000 line blaze file? =)
15:57:47 <chrisdone> c_wraith: no, i'm saying my views are clever enough to handle complicated things like abstraction
15:58:02 <darthdeus> chrisdone: your link has 323, close enough :D
15:58:06 <chrisdone>       detail "Language" $ showLanguage langs (pasteLanguage paste)
15:58:07 <darthdeus> but it feels like 1000
15:58:07 <chrisdone>       detail "Channel" $ showChannel (Just paste) chans (pasteChannel paste)
15:58:07 <chrisdone>       detail "Created" $ showDateTime (pasteDate paste)
15:58:07 <chrisdone>     where detail title content = do
15:58:09 <chrisdone>             li $ do strong (title ++ ":"); toMarkup content
15:58:19 <chrisdone> ^ this simple concept is undoable in hamlet
15:58:44 <c_wraith> chrisdone: there's a reason I said I'd use heist. :P
15:58:49 <darthdeus> what does that even do :O
15:58:54 <darthdeus> ah
15:59:00 <chrisdone> you could extend hamlet to support some kind of functions, ad infinitum until you support full haskell and then wonder why you didn't use haskell in the first place
15:59:00 <darthdeus> i missed the where
15:59:44 <darthdeus> i'm pretty sure i'd inline that
15:59:55 <darthdeus> and it would be more readable :D
15:59:57 <chrisdone> darthdeus: yeah, you love html therefore you hate abstraction =p
16:00:00 <NemesisD> anyone remember a discussion on /r/haskell the other day where someone wanted a (<<) operator? anyone remember what the solution was to that
16:00:16 <jle`> do x; y, chrisdone? :P
16:00:22 <darthdeus> <li><strong>#{showLanguage langs (derpyherp ｡◕‿‿◕｡)}
16:00:25 <jle`> although i guess it's probably the most readable out of the alternatives
16:00:32 <jle`> NemesisD: it's not obvious what (<<) should be
16:00:41 <jle`> NemesisD: any decision would be weird no matter what
16:00:57 <NikolajK> with Applicative, do I usually think of the first argument type "f (a->b)" as containing functions?
16:01:00 <chrisdone> darthdeus: i can write for example: container $ row $ span12 $ h1 "Hello!"
16:01:17 <NikolajK> (i.e. is the functior usually preserving exponential objects)
16:01:21 <darthdeus> chrisdone: yeah that sucks in hamlet
16:01:23 <chrisdone> darthdeus: those are bootstrap layout elements. i can do this because blaze is trivially extendable
16:01:36 <NemesisD> jle` ah, wait i think i want <*
16:01:38 <darthdeus> chrisdone: in slim you can do   .container: .row: .span12: .h1 "Hello!" :P
16:01:44 <darthdeus> i wish hamlet had that
16:01:50 <heatsink> NokolajK: You mean the first argument of <$> ?
16:01:57 <chrisdone> darthdeus: well, the h1 is just a h1 =p
16:02:02 <Cale> NikolajK: Usually not. You should think of f (a -> b) as being some type of "computations" whose results are functions when executed.
16:02:14 <darthdeus> :P
16:02:19 <jle`> NikolajK: f (a -> b) in Applicative represents a function of some sort in some context
16:02:32 <jle`> it depends on the f
16:02:47 <jle`> IO (a -> b) represents an IO action that when executed produces a function
16:02:53 <darthdeus> chrisdone: now you've made me doubt my religion and want to try snap >.<
16:02:53 <NikolajK> yeha I see
16:02:54 <jle`> Maybe (a -> b) represents a function that may or may not be there
16:03:09 <NikolajK> I mean the f (a->b)->f a->f b looks like the type of eval
16:03:18 <chrisdone> darthdeus: anyway, i intentionally showed you the most pathological example i have of blaze to be "honest"
16:03:21 <NemesisD> jle` i wanted "do this monadic action, and then the next one but return the first one"
16:03:24 <jle`> NikolajK: it looks a lot like the type of ($), actually
16:03:30 <jle`> NemesisD: yeah, so you can use (<*) :)
16:03:35 <jle`> :t ($)
16:03:37 <lambdabot> (a -> b) -> a -> b
16:03:44 <jle`> wrap everything in an f, and you get:
16:03:44 <NemesisD> <*:)
16:03:46 <jle`> :t (<*>)
16:03:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:03:53 <Cale> :t liftA2 ($)
16:03:54 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
16:03:57 <jle`> :O
16:04:23 <NikolajK> (a -> b) -> a -> b is the fmap of a functor fixing objects
16:04:33 <Cale> yes
16:04:40 <chrisdone> darthdeus: another one, from ircbrowse, though this isn't as bad https://github.com/chrisdone/ircbrowse/blob/master/src/Ircbrowse/View/Calendar.hs
16:04:49 <Cale> Though, this is a different generalisation :)
16:04:52 <Cale> :t fmap
16:04:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:04:55 <darthdeus> lol
16:05:10 * darthdeus started vomiting blood after seeing the calendar function
16:05:17 <jle`> one way to think about it is that...say you have an `f a`, and you want to apply certain functions to it
16:05:28 <jle`> if you want to apply an (a -> b), you use fmap to turn it into an f a -> f b
16:05:42 <jle`> if you want to apply an f (a -> b), you use (<*>) to turn it into an f a -> f b
16:05:43 <darthdeus> chrisdone: you should show this to people to scare them off :D
16:05:54 <jle`> if you want to apply an (a -> f b), you use (=<<) to turn it into an f a -> f b
16:06:20 <SharonAteSam> watch this on youtube funny as https://www.youtube.com/watch?v=CCu3HnbnCLY
16:06:37 <Cale> I wonder how much longer we have to endure those bots
16:06:41 <chrisdone> darthdeus: not really, people have peculiar tastes with their templating languages. i see some haskell code generating html, you see "this is not a templating language, ew"
16:06:50 <darthdeus> chrisdone: but maybe with custom colors for each blaze function :P
16:07:05 <NikolajK> okay, I get a feel
16:07:14 <chrisdone> darthdeus: but this demonstrates mixing "logic" with view, as you might say. but to me it's *all* view. the years, showDate, etc. is all view code
16:07:15 <jle`> NemesisD: one can interpret (<<) as being to (=<<) what (>>) is to (>>=)
16:07:26 <NikolajK> in the beginning of this
16:07:27 <NikolajK> http://comonad.com/reader/2008/kan-extensions/
16:07:27 <NikolajK> the Ran definition, why is this type "a" involved. I don't see how this is a Kan extension
16:07:29 <jle`> NemesisD: in that case, it's flip (>>), which is not (<*)
16:07:43 <darthdeus> chrisdone: yeah it does make sense, i guess i would just need more colorful syntax to enjoy it fully
16:08:01 <jle`> if you want a monadic (<*), you can use liftM2 const
16:08:08 <jle`> :t liftM2 const
16:08:10 <lambdabot> Monad m => m r -> m a2 -> m r
16:08:15 <jle`> :t (<*)
16:08:16 <lambdabot> Applicative f => f a -> f b -> f a
16:08:19 <darthdeus> chrisdone: hah i have an evil idea ...
16:08:29 <Cale> NikolajK: Let me try to remind myself... these are Kan extensions that have been stomped on very hard to flatten them into the world of what's easily expressible in Haskell.
16:08:37 <NikolajK> I'd guess he sets up the natural transformation from RG to H, but that's not the type forall b. (a -> g b) -> h b
16:08:37 <darthdeus> chrisdone: use emacs' font lock or whatever it's called to render blaze function names as <html> :D
16:08:37 <NikolajK>  as far as I can see
16:09:09 <chrisdone> darthdeus: lol
16:09:16 <chrisdone> darthdeus: yeah, that would make *me* vomit
16:09:46 <benmachine> lotta vomit in this channel this evening
16:10:10 <chrisdone> darthdeus: do you prefer parser generators to parsec? ;)
16:10:42 <jle`> i think you just have to draw the line somewhere between what you want to look at as data, and waht you want to look at as logic
16:10:45 <darthdeus> chrisdone: no i hate those, parsec is the best :D
16:10:51 <darthdeus> chrisdone: https://gist.github.com/darthdeus/3f3732916a195104b87c
16:11:02 <jle`> i'm sure few people would view parsers as data, and not as logic
16:11:08 <jle`> but i think for html...the line is a bit blurry
16:11:14 <darthdeus> that's how scala would've done it lol, with it's xml inlining thingy
16:11:21 <chrisdone> darthdeus: lol good gawd
16:11:34 <darthdeus> beautiful ey?
16:11:35 <chrisdone> there's an xml inliner preprocessor for haskell
16:11:38 <chrisdone> that looks like that
16:11:56 <jle`> what *do* you view as data, chrisdone ?
16:11:59 <jle`> configuration?
16:12:04 <jle`> css?
16:13:05 <chrisdone> jle`: i think html and json and css are data
16:13:13 <chrisdone> but i'm not a robot, i don't want to write them directly
16:13:28 <chrisdone> i have a language at my disposal to generate them for me
16:14:00 <chrisdone> there's a certain massochism and nostalgia to writing data formats by hand
16:15:06 <jle`> well...binary executables are data, and you don't write them by hand, typically...but that doesn't mean you don't view programs through the eyes of logic/program
16:15:19 <jle`> the interface by which you generate it makes a different in your perception of it, i think
16:15:21 <chrisdone> why bother writing
16:15:21 <chrisdone> <li>Hello
16:15:21 <chrisdone> <li>World
16:15:24 <chrisdone> <li>Sup?
16:15:27 <chrisdone> when i can write forM_ (words "Hello World Sup") li
16:16:05 <Cale> NikolajK: still here?
16:16:13 <chrisdone> jle`: yes, that's my point. binary is a data format, i don't want to data formats by hand
16:16:35 <chrisdone> throw away abstraction for no reason
16:16:58 <joelteon> what's the best way to just update a file's mtime?
16:16:58 <Cale> NikolajK: So, given endofunctors on Hask h and g, we want to find a functor Ran g h such that the natural transformation Ran g h (g a) -> h a exists.
16:17:09 <joelteon> or, whatever is the bare minimum that will make ghci reload it?
16:17:18 <jle`> the end result is binary, but the mental tools and abstractions you use to construct it are what is relevant, i think
16:17:21 <jle`> joelteon: touch?
16:17:27 <joelteon> from within haskell?
16:17:39 <jle`> oh
16:17:41 <joelteon> I don't wanna use a subshell for that
16:17:43 <chrisdone> joelteon: perhaps openFile with AppendMode and close it
16:17:46 <Cale> (using the identification of natural transformations with polymorphic functions -- in category theory speak, that's a natural transformation Ran g h . g -> h
16:17:51 <joelteon> okay
16:17:56 <darthdeus> chrisdone: btw have you used http://emmet.io ?
16:17:56 <Cale> )
16:18:14 <chrisdone> darthdeus: nah, i shun toolkits like mosquitos
16:18:32 <darthdeus> lol
16:18:50 <darthdeus> I'm actually not sure if there's emacs mode, but therep robably is
16:18:56 <kjanosz> ShowMOTD
16:19:02 <darthdeus> https://github.com/smihica/emmet-mode
16:19:02 <kjanosz> ups, sorry :D
16:20:15 <NikolajK> Cale: yeah okay
16:20:32 <NikolajK> but the forall is over the b, and the Ran definition involved two types, b as well as a
16:20:41 <Cale> NikolajK: So, if this definition is to work we need a natural transformation (forall b. (g a -> g b) -> h b) -> h a
16:20:42 * geekosaur keeps misreading ekmett-mode >.>
16:21:25 <Cale> NikolajK: and of course, we have such a thing, just application of the given function to the identity on g a
16:21:48 <darthdeus> geekosaur: i would want that mode :D
16:22:00 <chrisdone> joelteon: seems the file opening doesn't work
16:22:06 <Cale> Of course, we haven't considered whether this is universal yet, but at least this is a start :)
16:22:10 <joelteon> damn
16:22:49 <NikolajK> you said we want Ran g h (g a) -> h a, i.e., categorically a map from g a to h a. That I guess. But why do you end up with (forall b. (g a -> g b) -> h b) -> h a?
16:22:57 <NikolajK> why is that so long all of a sudden?
16:23:10 <Cale> I substituted in the definition of Ran g h
16:23:33 <Cale> newtype Ran g h a = Ran { runRan :: forall b. (a -> g b) -> h b }
16:23:58 <NikolajK> but what does this forall b. (a -> g b) -> h b correspond to in the first place?
16:24:01 <chrisdone> joelteon: you can use the unix package if you're just working on unix and don't care about windows
16:24:07 <NikolajK> in the diagram say,
16:24:13 <joelteon> well, I might care about windows someday, but certainly not now
16:24:19 <Cale> NikolajK: Well, we're going to show that it satisfies the appropriate diagram and has the correct universal property
16:24:24 <chrisdone> joelteon: http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Files.html#g:12
16:24:34 <Cale> NikolajK: and then we don't care what it is :)
16:26:38 <Cale> NikolajK: So, this map:  ran :: Ran g h (g a) -> h a  is the required 2-cell in the triangle you'll see in the definition of a right Kan extension
16:27:13 <Cale> ran (Ran f) = f id
16:27:36 <hiptobecubic> Does anyone know why Pipes has it's own bytestring type?
16:27:45 <Cale> Or maybe I should call it eta or something, I dunno
16:28:06 <Cale> hiptobecubic: It does?
16:28:39 <Cale> hiptobecubic: I'm pretty sure that's not true
16:28:46 <hiptobecubic> Cale, .... No. I was using Lazy and it wants strict apparently.
16:28:59 <hiptobecubic> Although it does... reexport it i guess
16:32:29 <heatsink> Apparently, it's not so easy to randomly generate a monotonic function.
16:33:26 <benzrf> heatsink: heh
16:37:34 <benzrf> hmm
16:37:49 <benzrf> heatsink: why not something like, uh
16:37:55 * benzrf has forgotten how to use scan
16:37:58 <benzrf> :t scanl
16:37:59 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:38:01 <benzrf> :t scanr
16:38:02 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
16:38:08 <benzrf> :t gens
16:38:09 <lambdabot>     Not in scope: ‘gens’
16:38:09 <lambdabot>     Perhaps you meant one of these:
16:38:09 <lambdabot>       ‘lens’ (imported from Control.Lens),
16:38:12 <benzrf> hmm.
16:38:21 <benzrf> how do i get a list of ints from a Gen again?
16:38:25 <benzrf> :t newStdGen
16:38:27 <lambdabot> IO StdGen
16:38:30 <mwhit> :t generate
16:38:31 <heatsink> I'm making a monotonic function on sets, not on numbers
16:38:32 <lambdabot> Gen a -> IO a
16:38:36 <benzrf> heatsink: ooooh
16:38:42 <benzrf> whats your ordering
16:38:47 <heatsink> set inclusion
16:38:53 <benzrf> :o
16:39:02 <NikolajK> Cale: in the blog, he later sets up "type Yoneda = http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Ran Identity". So I think
16:39:02 <NikolajK> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#t:Ran { http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-KanExtension.html#v:runRan :: forall b. (a -> g b) -> h b }
16:39:03 <NikolajK> is nat(Hom(a,G-),H)
16:39:39 <Cale> NikolajK: That's right
16:40:03 <Cale> NikolajK: We think of  forall a. f a -> g a as being Nat(f,g)
16:40:14 <NikolajK> right I know
16:40:15 <heatsink> I think I can start by making a random function f :: T -> Set T, then use that to get (Set.join . Set.map f) :: Set T -> Set T
16:40:20 <heatsink> as my monotonic random function
16:41:01 <NikolajK> by why nat(Hom(a,G-),H) is the type of eta for the Kan extension is still open to me
16:41:44 <NikolajK> well
16:42:23 <NikolajK> first you apply G, that's right. Then we'd have to apply the extension R. I think what they do is just say all functors are representable by Hom(a,-)
16:42:43 <bettycla1p> I have "class G a b where e :: a -> b", "instance (C a) => G a a where e = <default implementation>", and "instance C X". But when I try "e c", where c is a value of type C, I get "Warning: No explicit method nor default method for `e'". Can someone shed light?
16:43:24 <benzrf> bettycla1p: C is a class not a type
16:43:26 <benzrf> ???
16:43:29 <benzrf> do you mean a value of type X
16:43:53 <benzrf> bettycla1p: also can you give us some more-concrete code
16:43:56 <bettycla1p> benzrf: yes, I meant X, thx
16:45:45 <benzrf> bettycla1p: i assume 'where e = id'?
16:46:48 <bettycla1p> benzrf: that assumption seems unnecessary, but feel free to use it, if it helps.
16:47:49 <Cale> NikolajK: Okay, so let's look at what the universal property should be. We ought to have a (unique) function  delta :: (Functor m) => (forall a. m (g a) -> h a) -> (m a -> Ran g h a), which, given any other functor m, and natural transformation m . g -> h will give us the supposedly unique natural transformation m -> Ran g h making the appropriate diagram commute
16:48:40 <Feuerbach> hey chrisdone. sorry, I rarely pay attention to here =)
16:48:54 <benzrf> bettycla1p: i tried your example in ghci
16:48:56 <benzrf> it worked for me
16:49:03 <benzrf> Prelude> e O :: X
16:49:03 <benzrf> O
16:49:13 <bettycla1p> hmmm
16:49:52 <Cale> oops
16:50:11 <Cale> no, no, that's right
16:51:03 <Cale> So, delta mu m = Ran (\f -> mu (fmap f m)) fits, and it's essentially the only thing which will typecheck there
16:52:18 <benzrf> https://gist.github.com/1c4b7a9824b79192750f bettycla1p
16:52:27 <Cale> and the condition we need to check is that eta . delta mu = mu, so eta (delta mu m) = eta (Ran (\f -> mu (fmap f m))) = (\f -> mu (fmap f m)) id = mu (fmap id m) = mu m
16:52:51 <Cale> and so it checks out
16:54:02 <Cale> Uniqueness is really a bit more work if we want to do it right... but when I defined delta, I didn't have any real choice about how I did it, given the things that I had.
16:55:01 <Cale> NikolajK: I don't know if that's reasonable to follow :)
16:55:34 <Cale> (It would probably help to have the diagrams I have on paper in front of me)
16:56:09 <trap_exit> (1) I'm writing a sever in Haskell. (2) I want the server to restart whenever the binary changes. (3) I'm looking at http://hackage.haskell.org/package/hinotify-0.3.1/docs/System-INotify.html . (4) I have two questions: (a) how do I get the fs location for "current prog that is running" and (b) how do I safely tell a multi threaded haskell program to quit
16:57:10 <StoneToad> is the haskell platform being updated? the website says the next version was due out last year...
16:57:36 <mwhit> i thought the new version was supposed to be released, like, last week actually...
16:57:40 <mwhit> not sure what happened with that
16:57:43 <mwhit> or if i'm imagining things
16:58:06 <StoneToad> well, h.o/platform says 2013.4.0.0 is next release
16:58:22 <trap_exit> https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Environment.html
16:58:52 <StoneToad> if a new version's going to be out really soon, I'll just wait to install on this computer
16:58:57 <luite> trap_exit: you might want fsnotify instead which is a cross platform wrapper around the lower level apis
16:58:58 <Cale> NikolajK: If you need any help sorting out my mess, I could probably draw some useful diagrams
16:59:05 <NikolajK> Cale: let's say I believe your calculations :)
16:59:07 <StoneToad> since I'd rather not go through the pain of installing twice in a short timeperiod
16:59:22 <mwhit> stonetoad: what os are you running
16:59:24 <NikolajK> the fmap chain lost me
16:59:46 <NikolajK> also the fact that it's in Haskell, I must read more code
16:59:54 <Cale> NikolajK: I used the fact that eta (Ran f) = f id
16:59:56 <luite> trap_exit: and yep, getExecutablePath :)
17:00:02 <StoneToad> mwhit: win7 here, I still have at least a partial dev environment on my linux os, which is an out of date ubuntu so... yea...
17:00:05 <Cale> NikolajK: and then the fact that fmap id x = x
17:00:28 <mwhit> StoneToad: don't know much about windows installation, sorry
17:00:36 * Hodapp attempts to comprehend Curry-Howard Correspondence.
17:00:46 <mwhit> but i think regardless of os you're better off not installing via platform until it's updated
17:00:53 <mwhit> since it's quite out of date at the moment
17:01:16 <StoneToad> yea, that's what was worrying me
17:01:29 <NikolajK> Hodapp: take one type constructor at a time
17:01:49 <geekosaur> there are prerelease h-p packages out now
17:01:55 <Cale> Hodapp: The key to that is to look at how in logic, when we want to prove that A implies B, we start by assuming A, and trying to derive some proof of B, while in the lambda calculus, if we want to construct a function of type A -> B, we start by assuming we have some term x : A, and try to construct from it some term y : B, and then (\x -> y) is the required function.
17:02:14 <Hodapp> NikolajK: it finally sort of clicked why the a -> b -> c.... notation for functions is not just coincidentally the same at the notation for logical implication
17:02:15 <Cale> Hodapp: and in logic, if we know that A -> B, and we know that A, then we can derive B
17:02:31 <Cale> while in the lambda calculus, if we have f : A -> B, and x : A, then we obtain f x : B
17:02:32 <moghedrin> Can I get somebody to look at what I'm doing wrong with my class instances? Ghc keeps complaining that it can't deduce some of my types :L
17:02:35 <moghedrin> http://pastebin.com/Twb0p9sV
17:02:45 <StoneToad> wowa, the roadmap page got updated within the last 2 days
17:03:24 <Hodapp> Cale: the Software Foundations book did it pretty cleanly, I think, by showing how a value of a given type corresponds to evidence or proof of a proposition corresponding with that type.
17:03:36 <NikolajK> Hodapp: given that it was only seen in the 70's or so, you could say the naming is coincidence. but they are similar because they have some idea in common which was clear before, I guess
17:03:36 <Cale> Hodapp: yes
17:03:59 <StoneToad> thanks everyone, man, I love haskell, I start looking for something and blam, it's getting fixed/implemented already :D
17:04:11 <Cale> NikolajK: hmm... are you sure it's not really much older than that?
17:04:33 <Cale> NikolajK: After all, the lambda calculus started out as an attempt at logical foundations, not as a means to computation.
17:04:50 <Hodapp> NikolajK: In Coq, at least, it's not coincidence at all.
17:05:10 <moghedrin> Nobody? :O
17:05:25 <Cale> So, depending on how you think about it, maybe it's as old as the simply typed lambda calculus itself.
17:05:46 <mwhit> moghedrin: the type signature for fizz says that the instance for Bazz Buzz must produce a result of type Bazz Buzz
17:05:58 <mwhit> but b in that instance definition can be anything of class Foo
17:06:00 <Cale> moghedrin: Okay, I guess I can copy your file and run ghc on it in order to see what error you're getting
17:06:08 <mwhit> there's no way to guarantee that Bazz b is :: Bazz Buzz
17:06:22 <NikolajK> I'd guess it's at best as old as http://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation
17:06:40 <mwhit> that's what "could not deduce (b ~ Buzz)" means
17:06:52 <mwhit> ~ is equivalence in type expressions
17:07:10 <Cale> yes, that's right
17:07:19 <Hodapp> NikolajK: well, this looks a lot closer to the approach that SF (and possibly Coq) takes.
17:07:26 <Cale> (I agree with mwhit's explanation)
17:07:55 <NikolajK> Hodapp: Coq is done on computers, of course that's long after the 70's.
17:07:56 <mwhit> (also, paste the error messages so I don't have to re-type everything into ghci =))
17:08:13 <moghedrin> mwhit: Ah! I see. Okay! When you explain it like that, it's obvious. (And I will remember that for next time XD)
17:08:23 <Hodapp> NikolajK: I'm talking about the specific interpretation which that Wikipedia article gives.
17:10:13 <NikolajK> Hodapp: do you know dependent types and identity types? that's when it gets confusing :)
17:10:25 <Hodapp> NikolajK: I've looked a little bit at dependent types.
17:10:34 <Hodapp> tried to get through the Hasochism paper.
17:10:43 <Hodapp> SF has touched on dependent types in Coq a bit
17:10:54 <Iceland_jack> that paper is not a good introduction to dependent types though
17:11:06 <Hodapp> No, but it's not my first exposure to them.
17:11:17 <Hodapp> it's just the most Haskellian thing I'm aware of when it comes to dependent types!
17:12:15 <moghedrin> mwhit: Okay, so while I understand the issue, I am uncertain how I would go about fixing this (apparently). Any pointers?
17:12:25 <NikolajK> at first I liked dependent types (a:A, B(a)) much more than type polymorphism alla System F, but now with natural transformations as polymorphic functions, I like both :)
17:13:58 <Hodapp> LALALALA I CAN'T HEAR YOU
17:14:02 * Hodapp ignores other stuff he hasn't learned yet
17:14:24 <hae> Spoilers.
17:14:33 <NikolajK> Hodapp: in any case, what people like to to at the moment (current pushed research topic) is to take logical equality, i.e. A=B, and consider that thing "A=B" a type, depending on types "A" and "B". That's an identity type. And the terms of it are - of course, proofs of the equality of A and B. And then someone came along and said A=B is an object in algebraic topology http://en.wikipedia.org/wiki/HoTT#Interpretation
17:14:35 <Hodapp> aren't dependent types orthogonal to type polymorphisms?
17:15:06 <mwhit> moghedrin: that kind of depends on what you want to achieve here. There's no way to make Bazz Buzz a (useful) instance of Bar given just the information shown in your paste, because there's no way to construct a value of Buzz Bazz from a Buzz Bazz and any kind of Foo, other than by just ignoring the second argument and returning the first as-is
17:15:37 <Hodapp> NikolajK: HoTT is on my list to read, somewhere.
17:15:42 <Hodapp> sometime.
17:16:11 <NikolajK> I read into the book, but they use it for stuff which is hard to be interested in
17:16:21 <Hodapp> though I wonder if it'd just confuse me further.
17:16:28 <NikolajK> hurr durr, let's re-proof homotopy groups of n-spheres...
17:16:57 <mwhit> do you *want* fizz to make a Bazz a from any kind of Foo a?
17:17:05 <NikolajK> (yes, it would … I mean it confused me to force path motion interpretation on proofs)
17:18:10 <NikolajK> you know, let's consider two proofs q and p that A and B are equal, i.e. q:A=B and p:A=B, and then think about the proofs that the proofs are equal q=p, at nauseum
17:18:39 <NikolajK> ad nauseum
17:18:49 <moghedrin> mwhit: I want fizz to make a Bazz from a Buzz, in this instance.
17:19:00 <moghedrin> mwhit: Rather than any kind of Foo a
17:19:16 <mwhit> then fizz should be :: a -> Buzz -> a
17:20:18 <moghedrin> mwhit: Let me rephrase - for the Bazz instance of Buzz, I want Fizz to make a Bazz from a Buzz (Whew. It's getting very Dr. Suess explaining this).
17:20:19 <NikolajK> and I really tried to make sense of http://en.wikipedia.org/wiki/Univalence_axiom, but I think it's only a great insight if you did some essential homotpy theory via higher categories
17:20:58 <moghedrin> *Bazz instance of Bar
17:21:33 <trap_exit> what is the haskell command for "dude, we need to quit; kill all threads" ?
17:21:37 <mwhit> moghedrin: so you want the type of b to be determined by the type of a?
17:21:37 <trap_exit> I know it should ahve type IO ()
17:21:46 <trap_exit> but besides that, I'm slightly clueless
17:21:52 <moghedrin> mwhit: Yes :)
17:21:57 <mwhit> moghedrin
17:22:00 <mwhit> : perfect
17:22:08 <mwhit>  you want MultiParamTypeClasses
17:22:21 <mwhit> then just change the class declaration to "class (Foo b) => Bar a b where"
17:22:36 <heatsink> Maybe System.Exit.exitSuccess or System.Exit.exitFailure
17:24:10 <mwhit> and fizz just becomes :: a -> b -> a
17:24:24 <mwhit> and the instance becomes "instance Bar (Bazz Buzz) Buzz"
17:24:59 <jle`> does anyone else hear a bee in the room
17:25:30 <trap_exit> trap_exit: https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Exit.html
17:25:32 <trap_exit> trap_exit: thanks!
17:25:55 <alphonse23_> are Church encoding the same as Serialization in other languages?
17:26:06 <moghedrin> mwhit: Thanks! :)
17:26:15 <whigmaleerie> trap_exit: https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Environment.html getExecutablePath
17:27:21 <rufs> I'm a bit upset that these kind of things don't trigger some kind of warning:
17:27:21 <alphonse23_> does anyone know what church encoding is?
17:27:25 <rufs> ohFoo :: [a] -> Int
17:27:25 <rufs> ohfoo [] = 4
17:27:25 <rufs> ohFoo xs = 3
17:27:36 <rufs> wasted to much time to find that :p
17:27:57 <Cale> alphonse23_: They really have very little to do with serialisation
17:28:23 <Cale> alphonse23_: If you have some algebraic data type, you can turn it into a representation which uses only lambdas that take the constructors as arguments
17:28:49 <Cale> alphonse23_: For example, suppose you have a binary tree datatype like:  data Tree a = Tip a | Branch (Tree a) (Tree a)
17:29:21 <Cale> alphonse23_: You might have a binary tree like  Branch (Branch (Tip 1) (Tip 2)) (Tip 3)
17:29:49 <Cale> alphonse23_: A Church encoding of this value would look like (\tip branch -> branch (branch (tip 1) (tip 2)) (tip 3))
17:30:24 <Cale> alphonse23_: In this way, you can reduce all values to lambda terms, which is useful in, e.g. the untyped lambda calculus, as that's all you have.
17:30:56 <alphonse23_> so a church encoding just changes the format of a data type to untyped lambda calculus
17:31:18 <alphonse23_> is it easy to convert them back and forth? wouldn't removing the types make that hard
17:31:32 <Cale> Well, you'd have to know the type to convert back
17:31:37 <alphonse23_> Cale: now what makes church encoding usefull?
17:32:00 <Cale> alphonse23_: Mostly representing data in systems like the untyped lambda calculus and System F
17:32:16 <Cale> alphonse23_: You're not likely to see it used much in Haskell.
17:33:09 <alphonse23_> Cale: I read that they're used in attoparsec, even though I don't know what attoparsec does
17:33:13 <Cale> However, occasionally converting things to functions can result in performance gains. In particular, the list fusion stuff in GHC uses a representation of lists as functions
17:33:32 <Cale> (essentially, as the fold over the list)
17:34:12 <Cale> e.g. instead of the list [1,2,3,4,5], you could use a function like (\cons nil -> cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
17:34:30 <Cale> which is the same thing as (\cons nil -> foldr cons nil [1,2,3,4,5])
17:35:21 <Cale> and in the other direction, we have build f = f (:) [], to recover a normal list from such a function
17:36:07 <Cale> various higher order operations on lists can be performed efficiently on such functions without allocating intermediate data structures
17:40:15 <alphonse23_> aaaaa, so serialization is more for converting code conveniently for transfer and storage. Church encodings convert data structures into untyped lambda calculus, and by doing so one can pick up certain performance gains through ways of dealing with an untyped structure. I guess if I really wanted to understand this I'd have to go through some examples of
17:40:15 <alphonse23_> benchmarks, id say
17:40:40 <Cale> Well, when we use them in Haskell, they're typed, they just have function types
17:41:02 <Cale> :t (\cons nil -> cons 1 (cons 2 (cons 3 nil)))
17:41:04 <lambdabot> Num a => (a -> t -> t) -> t -> t
17:41:14 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (+) 0
17:41:16 <lambdabot>  6
17:41:23 <Cale> ^^ we can add the elements of the list like that
17:41:26 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (*) 1
17:41:27 <lambdabot>  6
17:41:29 <Cale> ^^ or multiply them
17:41:34 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (:) []
17:41:36 <lambdabot>  [1,2,3]
17:41:43 <Cale> ^^ we can recover the original list
17:41:43 <trap_exit> hmm, System.Exit.exitSuccess
17:41:48 <trap_exit> seems to kill only the thread I can it from
17:41:49 <trap_exit> and not all threads
17:41:53 <trap_exit> how do I kill all threads?
17:42:18 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (\x xs -> show x ++ ", " ++ xs) "."
17:42:20 <lambdabot>  "1, 2, 3, ."
17:42:24 <Cale> oops :)
17:42:32 <Cale> well, you get the idea
17:42:52 <Cale> (would have to be more clever to get the end right)
17:43:43 <jle`> :t \cons nil -> cons 1 (cons 2 (cons 3 nil))
17:43:44 <lambdabot> Num a => (a -> t -> t) -> t -> t
17:43:46 <slack1256> trap_exit: I've wondering the same, I caught the signal on the main threat, use throwTo to kill each ThreadID and the exitSuccess
17:43:52 <slack1256> *thread
17:44:02 <trap_exit> ah, I must call System.Exit _from the main thread_
17:44:18 <trap_exit> hmm, I think my solution is simpler (but less robust)
17:44:24 <slack1256> But don't your threads have any cleanup to do?
17:44:27 <trap_exit> I don't do anything for the forkIO threads (I don't ahve to record their thread IDs)
17:44:35 <trap_exit> I just call "System.Exit.exitSuccess" on the main thread
17:44:38 <trap_exit> and boom, they all die
17:44:52 <slack1256> yep
17:45:18 <slack1256> AFAIK if you kill the main thread or it terminates the whole program terminates also.
17:47:07 <trap_exit> slack1256: newb power! *high five* :-)
17:47:19 <trap_exit> digging through docs, and making types match is almost fun
17:47:19 <hiptobecubic> I would like to parse and broadcast shoutcast streams in haskell. This involves inserting variable length bytestrings to binary audio data. I'm planning to use Pipes to handle the IO, but what should I use for interacting with the data itself?
17:47:21 <trap_exit> it's like detective work
17:47:49 * hackagebot keystore 0.4.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.4.0.0 (ChrisDornan)
17:47:50 <slack1256> Heh
17:47:56 <tommah> the code `[0,0.7..4]` generates a list of floats approximating [0,0.7,1.4,...3.5] <= 4. How can I do the same with items of Rational type? So I want something like [0%0,1%7,2%7..5%7] Should I do something like zipWith (*) [0.7,0.7..] [1..6]?
17:48:06 <moghedrin> mwhit: Alright, I've (hopefully) one last issue...
17:48:21 <slack1256> Though sometimes I wish the type of IO could tell more about it.
17:48:25 <Cale> > [0,0.7..4] :: [Rational]
17:48:26 <lambdabot>  [0 % 1,7 % 10,7 % 5,21 % 10,14 % 5,7 % 2,21 % 5]
17:48:30 <moghedrin> mwhit: http://pastebin.com/TdV2Epdj
17:48:33 <rwbarton> don't write [0,0.7..4]
17:48:35 <hiptobecubic> The format is roughly: <m bytes audio data><1 byte encoding an integer z><z bytes utf-8 encoded text>
17:48:42 <slack1256> like "Does this call forkIO underhood?" I usually have to read the code to check that out.
17:48:46 <tommah> cale when you do that doesn't it first cast things to float and then rationalize the appxoimations?
17:48:53 <Cale> tommah: No
17:49:05 <Cale> tommah: Fractional literals always start as Rational values
17:49:09 <whigmaleerie> hiptobecubic: http://hackage.haskell.org/package/binary-0.4.1/docs/Data-Binary.html
17:49:17 <Cale> tommah: So, it doesn't have to do much to convert in this case
17:49:45 <whigmaleerie> has potential
17:49:55 <Cale> > 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068 :: Rational
17:49:57 <lambdabot>  7853981633974483096156608458198757210492923498437764552437361480769541015715...
17:50:04 <tommah> cale: i do that code and i get [0 % 1,7 % 10,7 % 5,21 % 10,14 % 5,7 % 2,21 % 5]
17:50:07 <moghedrin> mwhit: This time I just put the real code down so it's a little more concrete than the example.
17:50:11 <tommah> but isn't the 2nd thing the fraction 10/7?
17:50:17 <tommah> 10/7 = 1.428
17:50:19 <Cale> no, it's 7/10
17:50:35 <tommah> oh i see
17:50:36 <Cale> 7 % 10 means 7/10
17:50:48 <Cale> (but specifically the Rational value 7/10)
17:50:49 <tommah> 0%1 = 0, 7%10=0.7
17:50:54 <tommah> i misunderstood the delimiters
17:50:59 <tommah> thanks
17:51:18 <trap_exit> alright
17:51:18 <trap_exit> reloading working now
17:51:19 <trap_exit> I deserve dinner
17:51:45 <tommah> oh i WAS doing [toRational x | x<-[0,0.7..4]]
17:52:17 <tommah> which i guess doesnt work "right" because the "Real" type must have float approximations?
17:53:26 <Cale> fromRational is what gets used
17:53:29 <Cale> :t fromRational
17:53:31 <lambdabot> Fractional a => Rational -> a
17:53:57 <Cale> for any fractional literal, that function is secretly being applied
17:54:27 <tommah> thanks
17:56:19 <rwbarton> there it was defaulting the type of x to Double
17:57:11 <BillR> about Attoparsec: how do i compose parser (char 'A')  and parser (char 'B') to get a parser that accepts "AB"? thx
17:57:50 * hackagebot tightrope 0.1.0.0 - Nice API for a Slackbot  http://hackage.haskell.org/package/tightrope-0.1.0.0 (ian)
17:57:52 * hackagebot papillon 0.1.0.0 - packrat parser  http://hackage.haskell.org/package/papillon-0.1.0.0 (YoshikuniJujo)
17:59:02 <joelteon> would a set where values "disappear" after a certain amount of time be helpful?
17:59:12 <joelteon> wait, that would be called a "cache" wouldn't it :)
17:59:26 <joelteon> is there a good cache implementation in the HP somewher
18:00:08 <moghedrin> So, I'm fairly confident I understand the issue here, but does anybody want to point out how I would fix this?
18:00:11 <moghedrin> http://pastebin.com/TdV2Epdj
18:03:36 <heatsink> moghedrin: Class parameter 'b' isn't used anywhere, so it can't be determined from the code
18:05:04 <heatsink> moghedrin: Can you give two examples of classes Player S T and Player S U ?
18:05:08 <benzrf> BillR: (>>) or (*>)
18:05:23 <benzrf> BillR: monadic/applicative interface, remember
18:05:51 <mwhit> moghedrin: sorry, went away for a while
18:06:08 <moghedrin> mwhit: np
18:06:21 <mwhit> as heatsink alluded, if you have an instance "Player a b1" and "Player a b2", and they have different implementations of the class methods
18:06:25 <mwhit> there's no way to figure out which to use
18:06:31 <mwhit> there's a couple of ways to solve it
18:06:49 <mwhit> the most immediate that comes to mind is to add a functional dependency
18:07:28 <mwhit> if you enable -XFunctionalDependencies, you can change the class to "class .. Player a b | a -> b"
18:07:36 <mwhit> you can read "a -> b" there as "a determines b"
18:07:51 * hackagebot xml-pipe 0.0.0.3 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.3 (YoshikuniJujo)
18:08:02 <mwhit> this basically says that the choice of a provides a *unique* choice of b
18:08:23 <moghedrin> mwhit: Unfortunately, that doesn't hold here :L
18:08:26 <mwhit> ah
18:08:56 <mwhit> then probably p{X,Y} and s{X,Y} don't belong in Player
18:09:03 <mwhit> and you'll have to go back and make some deeper changes
18:10:40 <BillR> benzrf: thx
18:12:07 <moghedrin> mwhit: Thanks for your help :)
18:12:24 <moghedrin> mwhit: I actually think that I can add that dependency, after looking through things :)
18:12:49 <mwhit> great
18:13:00 <mwhit> if I can make a suggestion beyond your immediate problem though
18:13:14 <mwhit> is there a reason Inventory and Player are typeclasses and not datatypes?
18:13:31 <cjheath> Haskell newb here, be gentle. Can a Haskell parameterised type be designed to be instantiated with an arbitrary number of parameters?
18:13:35 <mwhit> it seems like positions and maps of items are a pretty straightforward representation
18:13:40 <benzrf> cjheath: no
18:13:59 <benzrf> cjheath: but there's probably a better solution for whatever youre trying to do
18:14:00 <cjheath> benzrf: Thanks
18:14:22 <mwhit> and you're creating a lot of added complexity for greater polymorphism than you'll need, almost certainly
18:14:34 <cjheath> I’m exploring how to map a general structure I’ve built in other languages
18:14:53 <jle`> consider that some structures useful in other languages aren't so useful in haskell, and vice-versa :)
18:15:05 <cjheath> Yes, Agree.
18:15:18 <Cale> There is a way, kinda, you can have lists of types with some of the fancy new stuff.
18:15:24 <mwhit> technically, you could parametrize it with lists of types
18:15:27 <mwhit> with some fancy wizardry
18:15:31 <mwhit> but that's probably not what you want
18:15:33 <cjheath> In Ruby, I use metaprogramming to create a lot of stuff from a very succinct definition, whereas in other languages I use a generator
18:15:45 <benzrf> cjheath: i know ruby !
18:15:49 <benzrf> what structure are you trying to map?
18:15:54 <jle`> me too! o/
18:16:02 * jle` is left hanging
18:16:06 <dfeuer> Does GHC automatically apply the static argument transformation to enable inlining, or is the current definition of unfoldr really just as bad as it looks?
18:16:06 <cjheath> I’ve not seen it described elsewhere. I call it a Constellation
18:16:18 <mwhit> sounds exciting already
18:16:27 <ruzu> eww ruby
18:16:45 <cjheath> it arises in fact-based programming, following the tradition of Object Role Modeling, if you know that?
18:16:53 <benzrf> ruzu: ruby is kinda neat
18:17:11 <benzrf> cjheath: explain its role
18:17:21 <rwbarton> dfeuer, it should automatically do the static argument transformation here
18:17:41 <ruzu> i have a deep, seething, mostly knee-jerk hatred for "method_missing"
18:17:41 <moghedrin> mwhit: Eh, there's not really a good reason besides my liking the idea of it.
18:18:14 <mwhit> moghedrin: a good rule of thumb when starting out in haskell is that if you think you need a typeclass, you probably don't
18:18:15 <cjheath> a model is a collection of object types (which are divided into value types (also known as lexical object types; things which have a written form) and entity types, things with are identified by a “definite description”, and a collection of fact types that assert relationships between (or characteristics of) those types
18:18:19 <dfeuer> rwbarton: oh good. I'll take a look at the Core when I'm not on Android to be sure. That leaves only the problem that it doesn't fuse with foldr.
18:18:31 <cjheath> a constellation is a collection of objects and facts according to such a model
18:18:32 <mwhit> they're similar in logic to OO interfaces, but much different in the actual use cases
18:18:47 <octopuscabbage> why does bitwise and and or require the two arguments to be of the same type
18:19:21 <moghedrin> mwhit: I'll keep that in mind.
18:19:31 <Cale> octopuscabbage: Because it helps type inference.
18:19:41 <Cale> octopuscabbage: and is usually what you want regardless
18:19:47 <octopuscabbage> Cale: Can I make it not d that
18:19:53 <joelteon> convert the arguments instead
18:19:54 <arianvp> do people tend to use `mtl` or `transformers`??
18:19:57 <jle`> moghedrin: i'm going to echo mwhit's statement that typeclasses are almost never the solution to any given problem
18:19:58 <cjheath> So I’m looking at Haskell as a way of getting to Constellation values.
18:20:04 <rwbarton> dfeuer: hmm, actually, it seems not to have done it
18:20:11 <mwhit> mtl is built on top of transformers, I believe
18:20:21 <jle`> arianvp: i use transformers by default and mlt if i want to do those polymorphism tricks
18:20:30 <Cale> arianvp: I think mtl is what things usually import at the moment
18:20:40 <Cale> but it's changed around a bunch in the past
18:21:04 <heatsink> octopuscabbage: When the arguments have the same type, it's clear how to "pair up" input bits, apply the bit operation, and put the result into the output.
18:21:10 <cjheath> The Scala implementation is blowing out as too verbose.
18:21:32 <rwbarton> dfeuer: maybe it considers the body of unfoldr too large
18:21:36 <dfeuer> rwbarton: I will include that in the bug report then. It should be written using build, which turns foldr c n (unfoldr f q) into something really nice, and it should *definitely* be inlinable, because inlining can sometimes/often/usually erase the Maybes.
18:21:37 <heatsink> octopuscabbage: If you take the bitwise and of an Integer with a 2D array of booleans, what should the result be?
18:22:11 <cjheath> mwhit benzrf: Was that a sufficient description?
18:22:27 <octopuscabbage> heatsink: padd the smaller one with zeros and do it
18:23:27 <jle`> octopuscabbage: on which side?
18:23:29 <octopuscabbage> heatsink: i understand that that's not necessarily /part/ of a bitwise operation, but there should at least be a way to do it
18:23:30 <heatsink> octopuscabbage: Which one is smaller?  If the array is 16x16 and the Integer is 32 bytes, they both contain the same number of bits.
18:23:32 <jle`> octopuscabbage: it all seems kinda arbitrary...doesn't it?
18:23:59 <jle`> octopuscabbage: you can explicitly convert things to the same type
18:24:05 <jle`> there, all confusion is gone :)
18:24:07 <octopuscabbage> heatsink: then they're both the same size
18:24:15 <octopuscabbage> jle`: oh how do i do that?
18:24:25 <rwbarton> write some functions
18:24:28 <jle`> it's the same way you can add a Integer and a Double
18:24:35 <jle`> > (1 :: Int) + (3.2 :: Double)
18:24:36 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
18:24:37 <lambdabot>              with actual type ‘GHC.Types.Double’
18:24:38 <joelteon> How would you implement (.&.) for (Bits a, Bits b)?
18:25:00 <jle`> > fromIntegral (1 :: Int) + (3.2 :: Double)     -- convert the Int to a double, thjen you can add
18:25:01 <lambdabot>  4.2
18:25:20 <jle`> > (1 :: Int) + round (3.2 :: Double)     -- or convert hte Double to an Int
18:25:21 <lambdabot>  4
18:25:55 <jle`> octopuscabbage: it depends on your specific types
18:26:43 <joelteon> ok
18:27:05 <benzrf> > 3.2 :: Ratio
18:27:07 <lambdabot>  Expecting one more argument to ‘GHC.Real.Ratio’
18:27:07 <lambdabot>  Expected a type, but ‘GHC.Real.Ratio’ has kind ‘* -> *’
18:27:09 <benzrf> > 3.2 :: Rational
18:27:11 <lambdabot>  16 % 5
18:27:23 <benzrf> > 3.2837498938 :: Rational
18:27:25 <lambdabot>  16418749469 % 5000000000
18:27:31 <benzrf> i dont knw what i expected
18:28:01 <benzrf> cjheath: iunno
18:28:31 <mwhit> ^^^
18:28:43 <benzrf> cjheath: its basically an association of information and objects?
18:28:45 <mwhit> cjheath: afraid I don't really understand this domain well enough to say much about it
18:28:55 <benzrf> cjheath: youre being awfully abstract and imprecise at the same time
18:28:57 <dfeuer> Anyone know where I can find real code using scanr, scanl, or takeWhile? Carter and nomeata want me to write some benchmarks for proposed replacements, but I'm not sure how they're really used.
18:29:21 <cjheath> Map the domain to databases; a Constellation is like a database, the model is like the schema
18:29:21 <benzrf> :t scanr
18:29:22 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
18:29:30 <cjheath> so mnow I want to define what a database is
18:29:32 <heatsink> cjheath: Also, fact-based programming is hard to find with an internet search.
18:29:34 <benzrf> cjheath: what are you *using* it foret
18:29:37 <benzrf> *for
18:29:39 <dfeuer> I found exactly one use of scanl in the GHC compiler code, and no uses of scanr.
18:30:06 <jle`> cjheath: many types in haskell have an associated TypeRep...and TypeRep is an Ord, so you could store it in a Data.Map
18:30:08 <cjheath> It’s hard to find b/c fact-based has only relally been used with modelling
18:30:13 <jle`> i'm not sure what exactly you want to use it for though
18:30:24 <benzrf> :t newStdGen
18:30:25 <lambdabot> IO StdGen
18:30:26 <jle`> can you give a concrete application?
18:30:30 <benzrf> @hoogle Int -> StdGen
18:30:31 <lambdabot> System.Random mkStdGen :: Int -> StdGen
18:30:32 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
18:30:32 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:30:33 <benzrf> hmm
18:30:39 <cjheath> I didn’t want to get into a long rant about it.
18:30:44 <benzrf> > scanr (flip (-)) 1000000 (mkStdGen 4785878434)
18:30:46 <lambdabot>  Couldn't match expected type ‘[a]’
18:30:46 <lambdabot>              with actual type ‘System.Random.StdGen’
18:30:47 <benzrf> oh wait bluh
18:30:50 <cjheath> but...
18:30:52 <benzrf> @hoogle StdGen -> [Int]
18:30:53 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
18:30:53 <lambdabot> Data.IntMap.Strict keys :: IntMap a -> [Key]
18:30:53 <lambdabot> Data.IntMap.Lazy keys :: IntMap a -> [Key]
18:31:05 <benzrf> > scanr (flip (-)) 1000000 (randoms (mkStdGen 4785878434))
18:31:10 <lambdabot>  mueval-core: Time limit exceeded
18:31:12 <benzrf> dang
18:31:20 <benzrf> > scanl (-) 1000000 (randoms (mkStdGen 4785878434))
18:31:22 <lambdabot>  [1000000,3904121979916016801,10353882290011073429,19417646279701919211,26353...
18:31:34 <benzrf> lol, underflow
18:31:56 * heatsink is reading Object-Role Modeling on Wikipedia
18:32:17 <benzrf> cjheath: it sounds to me like constellation is a means to an end and not an end
18:32:18 <jle`> dfeuer: scanl is pretty useful for successive sums
18:32:25 <jle`> dfeuer: er, cumulative sums
18:32:26 <dfeuer> I would love a way to ask a machine "what packages/modules/functions use package:module.function.
18:32:38 <benzrf> and furthermore, an extremely object-oriented means
18:32:43 <dfeuer> jle`: okay, but where is it used so?
18:32:43 <cjheath> in a transactional system, each transaction has some incident data associated with an event, and it goes and fetches a bunch of stuff from the database, checks it againstthe indicent data, then maybe changes some stuff and saves the changes back. The Constellation is used to represent - as elementary facts - all the in-memory data of the transaction
18:32:55 <cjheath> that’s the main application
18:33:16 <benzrf> 'incident data associated with an event'
18:33:18 <benzrf> wut
18:33:21 <heatsink> cjheath: It seems to be loosely related to relational databases, with facts being relations
18:33:22 <cjheath> essetnially it’s a microcosm of the system state, sufficient for deciding and saving a state change
18:33:32 <cjheath> yes, but relations are not elementary
18:33:43 <jle`> dfeuer: there are some applications on the wiki page, http://en.wikipedia.org/wiki/Prefix_sum
18:33:44 <cjheath> if you have all your relations in 6NF, then sorta
18:34:27 <cjheath> “elementary fact” in this context means “cannot be further broken down without loss of information
18:34:41 <benzrf> cjheath: what are you using your constellation to accomplish
18:35:04 <cjheath> up-end the entire world of software development andrequirements analysis :D
18:35:12 <mwhit> informative
18:35:25 <cjheath> I won’t rant here, read http://datsconstellation.com
18:35:26 <benzrf> cjheath: just use monads ( ͡° ͜ʖ ͡°)
18:35:32 <heatsink> heh
18:35:39 <jle`> >____>
18:36:05 <cjheath> The goal is to unify a sufficient language between IT and “the business”
18:36:17 <benzrf> cjheath: its difficult to hear you over the buzz
18:36:27 <mwhit> cjheath: You keep using words and not saying anything
18:36:27 <cjheath> We’re obsessed with better and better ways of writing the wrong program
18:36:34 <hiptobecubic> cjheath, broken link
18:36:40 <benzrf> hiptobecubic: s/dats/data
18:36:47 <mwhit> and the website is even more uninformative
18:36:56 <cjheath> I’m not trying to discuss a ten-year project in five minutes, it’s just not feasible
18:37:05 <mwhit> we're not asking you to do that
18:37:06 <dfeuer> jle`: that's helpful, but what I am looking for is really Haskell code in actual applications that uses these functions. Practice, not theory.
18:37:07 <cjheath> I just wanted to know about some Haskell language features that might help
18:37:11 <mwhit> we're asking you to describe a data structure
18:37:20 <mwhit> "a collection of facts" is not an operational definition
18:37:21 <heatsink> or describe a computational problem
18:37:39 <cjheath> Sorrt for the broken link: http://dataconstellation.com
18:37:56 <rwbarton> you can parameterize a type family or data family on a type-level list
18:37:59 <jle`> dfeuer: it looks like if you find a library that does polynomial interpretations, you might find it there :)
18:38:02 <benzrf> rwbarton: ew
18:38:04 <cjheath> mwhit: it is an operational definition, but you don’t have the required other definitions
18:38:09 <benzrf> cjheath: cute
18:38:13 <cjheath> Object Role Modeling is a first-order logic
18:38:19 <cjheath> that provides the required context
18:38:22 <jle`> or gray codes/counting sorts
18:38:24 <jle`> hm
18:38:25 <mwhit> okay, here's an actual thing that means something
18:38:26 <mwhit> http://dataconstellation.com/ActiveFacts/examples/highlighting/index.shtml
18:38:33 <benzrf> does anybody know if erik's talk from lambdajam is on the internet yet
18:38:41 <benzrf> cuz id like to cut out bits of it and send them to cjheath
18:38:50 <jle`> i remember using a cumulative sum in an application i wrote once but i forgot where it was
18:38:52 <cjheath> I’ve shown this to Erik
18:38:58 <cjheath> he was extremely impressed
18:39:00 <benzrf> cjheath: which erik
18:39:12 <cjheath> and almosty incredulous that it was almost all the work of one man
18:39:18 <cjheath> The F# Erik
18:39:33 <cjheath> that;s the one you mean, yeah?
18:39:43 <mwhit> cjheath: Sorry if we're seeming less than helpful, but it's very off-putting that you seem to be selling to us more than actually asking a question
18:39:51 <benzrf> cjheath: i dont know
18:39:54 <benzrf> i meant erik meijer
18:39:59 <cjheath> I’m trying reallyt REALLY hard not to discuss my project
18:40:06 <cjheath> I just asked questiona abut Haskell
18:40:22 <cjheath> and got asked a flurry of questions abou tthe context
18:40:32 <cjheath> Yes, that Erik
18:40:32 <mwhit> well, questions typically require context to answer
18:40:35 <benzrf> @google xy problem
18:40:36 <lambdabot> http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem
18:40:37 <lambdabot> Title: What is the XY problem? - Meta Stack Exchange
18:40:50 <benzrf> he spent a decent amount of his recent talk complaining about usage of new buzzwords instead of using established terminology
18:40:56 <cjheath> The trouble is, that the fact-based approach is really not widely known
18:41:02 <cjheath> and is a whole world in itself
18:41:07 <Hodapp> benzrf: this is the aforementioned lambdajam talk?
18:41:10 <cjheath> so it’s very hard to provide context
18:41:11 <benzrf> Hodapp: yeah
18:41:19 <Hodapp> benzrf: sounds like someone I'd like.
18:41:22 <benzrf> lol
18:41:45 <mwhit> cjheath: from what I can see here it pretty much just looks like a DSL for defining relational schema
18:41:48 <mwhit> http://dataconstellation.com/ActiveFacts/examples/highlighting/index.shtml
18:42:07 <benzrf> Hodapp: it was about applying various kinds of mathematical transformations to functions and interfaces to get interesting and useful variations. but he focused on rx, and in doing so complained about 'non blocking back pressure, what does that even mean'
18:42:24 <Hodapp> rx?
18:42:27 <benzrf> reactive streams
18:42:31 <cjheath> I met Erik Meijer at YOW in Melbourne in 2012
18:42:54 <benzrf> oh i guess rx != reactive streams precisely
18:42:55 <cjheath> mwhit: What was the question?
18:42:55 * hackagebot atomic-primops 0.6.0.6 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.6.0.6 (RyanNewton)
18:42:56 <benzrf> mb
18:43:55 <cjheath> mwhit: If by ‘relational” you mean “as Codd intended” then yes, that’s part of it.
18:44:17 <cjheath> But the point is that ordinary folk (non IT trained) can read it and understand
18:44:24 <benzrf> cjheath: thats usually not a good idea
18:44:33 <cjheath> it’s strongly linked to natural linguistics
18:44:37 <benzrf> ugh
18:44:43 <benzrf> that sounds terrible :p
18:44:48 <mwhit> and that could potentially be cool if it works well
18:44:58 <cjheath> benzrf: That comment encapsulates the arrogance of the entire IT world
18:45:02 <benzrf> theres a reason natural language programming isnt that popular ¬_¬
18:45:04 <mwhit> but you could have just said "A DSL for defining database schema" and we would have actually known what you were talking about
18:45:10 <benzrf> mwhit++
18:45:24 <cjheath> we’re really very good at writing programs, very bad at communicating about what program we should write
18:45:31 <benzrf> cjheath: well yes
18:45:35 <cjheath> that’s the problem I care about
18:45:56 <mwhit> ok sure
18:46:05 <cjheath> CQL is not a DSL, it’s a controlled natrural language, for a start
18:46:07 <Hodapp> "very good at writing programs, very bad at communicating..." suggests that perhaps one is not as good at the former as one suspects.
18:46:12 <mwhit> but you ostensibly came in here asking about technical details about representing that
18:46:23 <cjheath> secondly, that’s a language, but I came he asking how to build a Constellation - differet thing
18:47:03 <benzrf> cjheath: maybe you shouldnt be making a constellation
18:47:08 <benzrf> it sounds awfully object oriented
18:47:12 <benzrf> this is FP
18:47:36 <cjheath> The word “Object” was used in Object Role Modeling long before the O-O crowd invented their use of the word
18:47:41 <cjheath> and no, they’re not related
18:47:51 <benzrf> uh huh
18:47:51 <cjheath> an Object is simply an individual, in Logic
18:47:57 <Hodapp> cjheath: benzrf's comment really does not encapsulate the arrogance of the entire IT world. I don't hail from the IT world, and it still sets off red flags anytime someone tries to explain that something will be powerful, yet readable and understandable by "ordinary folk".
18:47:57 <ruzu> an atom?
18:48:11 * benzrf is looking at http://dataconstellation.com/ActiveFacts/index.shtml
18:48:17 <benzrf> > CQL text is so similar to natural language that even smart text editors cannot correctly add syntax highlighting, but you can generate an HTML version with highlighting for publication, using the CQL compiler.
18:48:18 <lambdabot>  <hint>:1:113: parse error on input ‘,’
18:48:40 <ruzu> @1+1
18:48:40 <lambdabot> Unknown command, try @list
18:48:46 <benzrf> http://dataconstellation.com/ActiveFacts/examples/highlighting/index.shtml
18:48:47 <benzrf> oh my god
18:48:49 <cjheath> benzrf: The parser is not LL1
18:48:53 <mwhit> cjheath: The reason everyone here is reacting the way they are is that you came in here asking a technical question, then proceeded to only describe your problem in marketing-speak
18:49:18 <benzrf> what the hell is this
18:49:32 <cjheath> FBM has its own vocabulary. It’s like trying to explain something using a foreign language
18:49:45 <benzrf> this looks like SQL with even more inappropriate english
18:49:54 <cjheath> so I revert to wooley words b/c I can;t use my specific ones
18:49:55 <ruzu> is this like DDD gone wild
18:50:08 <benzrf> ruzu: DDD?
18:50:36 <ruzu> domain driven design... i'm not super versed in it, but one component ddd peeps talk about is vocabulariy
18:50:46 <cjheath> FWIW, I’ve built some very large and very wel-accepted systems using this langauge, it’s not a toy
18:51:03 <cjheath> (ddd folk have part of the picture right)
18:51:13 <cjheath> and yes, there are similarities
18:51:20 <Hodapp> Big toys that everyone plays with are still toys.
18:52:09 <benzrf> im sorry but this language scares me
18:52:10 <cjheath> Hodapp: Are you feeling particularly objectionable today, or are you always like this?
18:52:12 <benzrf> it reminds me of
18:52:14 * benzrf shudders
18:52:15 <benzrf> applescrit
18:52:18 <benzrf> *script
18:52:23 <benzrf> it looks write-only
18:52:25 <benzrf> err, read-only
18:52:46 <Iceland_jack> Whether or not something is a 'toy' is relative, I think interesting that someone said that on #haskell
18:52:54 <cjheath> It’s isomprphic to the ORM diagrams, but perhaps that’s not obvious
18:53:29 <Hodapp> benzrf: applescrit? Is that like Sanskrit?
18:53:45 <systemfault> Wow, DDD discussions on #Haskell
18:53:45 <Iceland_jack> Proto-Indo-Apple
18:53:49 <cjheath> FWIW, it’s nothing like Applescript
18:54:40 <ruzu> haskell driven domains
18:54:44 <systemfault> (There’s nothing preventing the use of DDD in Haskell.. I’d even say that Haskell is more suited to things like DDD/CQRS+ES than other OOP languages)
18:54:53 <systemfault> :)
18:55:07 <benzrf> cjheath: i mean in terms of englishy-looking, extremely complicated and therefore hard to manage, grammar
18:55:49 <cjheath> benzrf: Yes, it’s hard to parse. Yet it does parse, and unambiguously at that.
18:55:54 <Hodapp> When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
18:56:17 <benzrf> cjheath: things that are hard to parse are usually hard to write
18:56:21 <benzrf> again, look at applescript
18:56:25 <ruzu> Hodapp: it's english (or your preferred human language); the compiler is the programmer(s)
18:56:26 <cjheath> it is amazing to be able to use something so like natural language to make formal statements
18:56:48 <Hodapp> That's really not particularly amazing.
18:56:51 <cjheath> for example, in a system that knows about people, patrties, invitations, etc, I can say
18:57:12 <Iceland_jack> Maybe this belongs in #haskell-overflow
18:57:12 <cjheath> “Gatecrashing is where some person came to some party and was not invited to and that party is invitation-only”
18:57:18 <benzrf> cjheath: can i say:
18:57:18 <Hodapp> The last time I heard folks describe that as amazing was sometime in the 80's.
18:57:20 <cjheath> and it can translate that to an SQL view
18:57:27 <heatsink> cjheath: Lawyers more or less use English to make formal statements all the time.  Despite it being English, it is difficult for English speakers to understand.
18:57:28 <benzrf> Gatecrashing occurs when a person arrives to a party to which they were not invited?
18:57:30 <cjheath> and I can thengo “SELECT * from Gatecrashing”
18:57:32 <benzrf> cjheath: ^is that valid
18:57:47 <heatsink> Not just because of legal jargon, but because legal text isn't structured like most other English text.
18:57:49 <cjheath> That compiles, yes
18:57:57 <benzrf> cjheath: does it mean what it means in english?
18:58:09 <cjheath> legal text hs a different kind of controlled language with different objectives
18:58:23 <cjheath> it defines what “Gatecrashing” means
18:58:28 <benzrf> cjheath: ok.
18:58:37 <benzrf> is it as correct as your example?"
18:58:39 <cjheath> in terms of existingk known fact types and objects
18:58:44 <cjheath> “Person”, Party”
18:58:59 <cjheath> and “was invited to”, “Came to”, “is invitation-only”
18:59:00 <cjheath> etc
18:59:13 <benzrf> cjheath: yes, but i could do that in a more structured, less natural-language way
18:59:34 <mwhit> heatsink: It just occurred to me the other day that legalese was a lot like a declarative programming language and sort of blew my own mind
18:59:45 <mwhit> heatsink: and here you are saying something similar
18:59:46 <benzrf> cjheath: in general, if something is truly similar to natural language, it's very hard to parse. and if it's only superficially similar to natural language, there isnt much advantage to it over something equivalent but more traditional
19:00:07 <ruzu> reminds me of cucumber/gherkin or w/e that stuff was
19:00:07 <benzrf> mwhit: some people want to invent a truly formalized declarative language for specifying laws
19:00:10 <benzrf> :-)
19:00:14 <benzrf> ruzu: thats whta i thought of too
19:00:15 <chadbrewbaker> After Lambajam I got extremely interested in taking portions of the Iowa Code and formalizing them in Coq/Agada. Attorneys waste so much time chasing proofs.
19:00:19 <benzrf> but i didnt think people here would know it
19:00:29 <cjheath> bezrf: The aim is that un-trained business folk who understand the domain being described, can read and correctly interpret the statements
19:00:31 * Hodapp adds "read what lambdajam is" to his TO-DO list
19:00:51 <benzrf> cjheath: ok, so why not write a simple program that parses SQL and translates it to something similarly englishy?
19:00:56 <Hodapp> Ah, so it's meant to be a common business-oriented language?
19:00:58 <benzrf> then you can write SQL as usual
19:01:02 <benzrf> Hodapp: bwahahahahahha
19:01:13 <cjheath> because databases in SQL dont have the natural semantics
19:01:18 <cjheath> for example
19:01:24 <cjheath> in an insurance system I worked on
19:01:37 <cjheath> the Claims table had a “BloodTest” field
19:01:42 <cjheath> I asked why
19:01:54 <cjheath> Here is the semantic linkage:
19:01:59 <cjheath> A claim is for an incident
19:02:10 <cjheath> if its a motor policy, the incident is a vehicle incodent
19:02:22 <cjheath> perhaps that incident happened while the vehicle was being drived
19:02:28 <cjheath> if so, then there was a driver
19:02:34 <cjheath> pehaps that driver was hospitalised
19:02:46 <cjheath> if so, perhaps there was a blood test
19:02:55 <cjheath> and the result of that might redice our liability
19:03:01 <benzrf> cjheath: that all sounds incredibly crufty
19:03:02 <cjheath> all that semantics encoded in one field
19:03:11 <benzrf> cjheath: why not write actual code?
19:03:17 <cjheath> that;s the tru semantics of the motor insurance domain
19:03:23 <cjheath> whats crufty about it?
19:03:39 <cjheath> because the business rules have to be defined in detail before you know WHAT CODE TO WRITE
19:03:56 <cjheath> Besides, this IS CODE
19:04:05 <cjheath> it’s just code that business folk can read
19:04:13 <benzrf> bleh
19:04:33 <cjheath> You can write it in an ORM diagrammig tool too
19:05:09 <benzrf> look, all i can say is that this is not a language i want to use in the slightest
19:05:12 <mwhit> this has gone way off-topic for some time, please move it to #haskell-overflow
19:05:48 <mwhit> (he says as a guy who actively participated in it)
19:05:50 <cjheath> Folk can ping me off-line. I didn’t come here to discuss it anyhow
19:06:01 <Hodapp> let's see... yes, "Computers in Business Management" is still on my bookshelf, (c) 1985, and they're still talking about this notion like it is going to revolutionize programming Real Soon Now(tm)
19:06:31 <cjheath> Hodapp: It’s not about programming
19:06:36 <cjheath> it’s about communication
19:06:48 <Hodapp> cjheath: Oh, you have the same textbook?
19:06:52 <benzrf> cjheath: why would the management be reading code anyway
19:07:17 <Iceland_jack> cjheath shouldn't have to defend their choice of language, framwork or anything
19:07:21 <benzrf> cjheath: isnt the semantic linkage you just pasted recorded somewhere outside of the code anyway
19:07:30 <Iceland_jack> *framework
19:07:34 <mwhit> <mwhit> this has gone way off-topic for some time, please move it to #haskell-overflow
19:07:40 <cjheath> business has no way to formally describe their requirements - so they use BAs to write reams of waffle
19:07:55 <cjheath> and leave programmers to figure it out, which amazingly, we can sometimes do
19:08:20 <ruzu> mmm, waffles
19:08:26 <ruzu> i should've picked some up :\
19:08:34 <mwhit> ruzu: are you a fruit guy or a no-fruit guy?
19:08:39 <cjheath> Speaking of which, time for brunch
19:08:56 <ruzu> flip a coin
19:11:43 <Hodapp> ooh, this text from 1985 has a lovely write-up on "fourth-generation languages"
19:12:26 <ruzu> i wonder using core.typed end-to-end would make clojure less scary
19:12:43 <solidus-river> can anoyone point me at a concrete use-case thats pretty intuitive for a co-monad
19:13:09 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:13:11 <Cale> solidus-river: ^^
19:13:48 <alpounet> +1 for this post, it's the one that made it click for me back a couple of years ago
19:14:12 <solidus-river> thanks! I hope a click happens soon for me :)
19:14:38 <Hodapp> It's somewhat sobering to read a paper or a text from the '60s, or the '70s, or the '80s, touting something as the next big thing, and then fast-forward to 2014 and see the same thing basically repeated verbatim.
19:14:57 <solidus-river> also, this is just a curiosity, if you try to profile a program that is not terminating and kill it, do you get a partial profile / partial view into what the code was doing
19:15:05 <solidus-river> or does profiling only work correctly if you can observe a full execution
19:15:16 <solidus-river> id imagine it can work with partial executions
19:15:27 <Hodapp> ahhh, Neighborhood of Infinity has written some good posts
19:15:41 <Hodapp> I think it was that post that made it make some sense to me too
19:15:47 <Hodapp> even if I've yet to have any practical experience with it
19:16:06 <solidus-river> are there any other languages that implimente STM? it seem slike the implimentation is completly on the compilers side
19:16:26 <benzrf> 'you could have invented monads' sort of helped me
19:16:32 <hiptobecubic> solidus-river, clojure
19:16:42 <benzrf> but in retrospect eh
19:16:48 <octopuscabbage> solidus-river: experimental support in python
19:17:15 <solidus-river> do i need to worry abaout how the compiler actually impliments it?
19:17:26 <Hodapp> solidus-river: I could have sworn I saw an STM implementation in Clojure.
19:17:28 <solidus-river> it seems like watching a set of TVars for changes could get some poor pervformance fast
19:17:41 <Hodapp> oh, hiptobecubic just said that.
19:17:41 <solidus-river> *performance
19:21:15 <solidus-river> I wonder how many years it will be before all languages enforce the right use of their libraries with a type system instead of (hopefully) carfull correct comments and diligent correct coders
19:21:34 <Cale> solidus-river: It will probably never happen?
19:21:47 <solidus-river> that sounds bad
19:22:02 <solidus-river> well, by all i mean a majority of popularly used ones
19:22:12 <mwhit> eh it's heresy in here, but i do think dynamic languages have their place
19:22:14 <mwhit> for example:
19:22:19 <mwhit> my day job is in data science
19:22:21 <solidus-river> as libraries and computation becomes more complex / varied it seems like the only sane solution
19:22:22 <cjheath> Not sure that (according to Godel) that “correct” is well-defined
19:22:27 <mwhit> which sometimes means building elaborate models
19:22:34 <mwhit> but a lot of times means exploratory data analysis
19:22:40 <mwhit> and exploratory visualization
19:22:58 <Cale> I don't understand why programmers are so concerned with what tools their competitors use
19:23:01 <mwhit> if I had to use a statically typed language without actually knowing in advance what I was going in there to do I'd shoot myself
19:23:48 <Hodapp> cjheath: You're correct to be unsure, since that really only applies once you've hit the level of Turing-completeness.
19:24:32 <solidus-river> Cale: i'm concerned because it affects the ecosystem in which i work / iterate on ideas
19:24:48 <solidus-river> Cale: and i'm bloody sick of doing that more and more in python / javascript
19:24:50 <solidus-river> :P
19:24:58 <octopuscabbage> solidus-river: you don't iterate on ideas here, we only allow mapping and filtering on ideas
19:25:07 <mwhit> *rimshot*
19:25:25 <mwhit> someone add @rimshot to lambdabot for recording haskell puns
19:25:25 <Hodapp> mwhit: I used Python quite a bit at my last job for doing all sorts of one-off things from ill-formed data with ill-expressed problems. And since it was a real job, the one-off things never were really one-off things, and Python actually made this way more manageable than some of the other languages of choice for scripting there, like JScript and MATLAB.
19:25:27 <solidus-river> my filter can be rewritten as mempty
19:26:00 <benzrf> @rimshort
19:26:01 <lambdabot> Unknown command, try @list
19:26:10 <benzrf> mwhit: tell me the precise semantics and ill write up a PR
19:26:14 <benzrf> :^)
19:26:26 <mwhit> haha
19:26:47 <benzrf> mwhit: i do enjoy using pry for screwing around with data
19:27:44 <Hodapp> benzrf: pry?
19:27:54 <NemesisD> any haskell users here?
19:27:58 <mwhit> don't get me wrong, I WISH it was reasonable to use Haskell for that sort of stuff, just because it's such a joy to use
19:28:06 <mwhit> but that requires a framework that doesn't exist yet
19:28:06 <NemesisD> woah wrong wrong question. any tasty users*
19:28:29 <Iceland_jack> NemesisD: Are you looking for #cannibalism? :)
19:28:35 <NemesisD> it seems like tasty automatically runs your tests in parallel. i've got some tests that write pidfiles and spawn child procs and stuff so i need that to not happen
19:28:45 <benzrf> Hodapp: excellent ruby shell
19:28:48 <NemesisD> Iceland_jack: lol!
19:29:09 <Hodapp> mwhit: Have you read, "Beautiful Code, Compelling Evidence" from Jeff Heard? That fellow seemed to prefer Haskell for all sorts of data analysis.
19:29:23 <benzrf> Hodapp: the standard one doesnt really support anything beyond 'type an expr, see the result'
19:29:37 <Hodapp> benzrf: what's the standard one nowadays? Back in '03 I used irb
19:29:44 <benzrf> irb still
19:29:54 * Hodapp <- Ruby hipster, used Ruby before it was cool.
19:30:02 <mwhit> Hodapp: I have not. Thanks for the suggestion, I'll have a look
19:30:11 <benzrf> pry supports syntax highlighting, indents for you, has commands for viewing docs and available methods, tab completion
19:30:21 <Hodapp> mwhit: It's a short-ish paper. It may not be the same sort of data analysis you're interested in, but it's a nice write-up.
19:30:22 <benzrf> generally much nicer
19:30:35 <Hodapp> mwhit: Let me know if you can't find the PDF online.
19:30:40 <mwhit> just found it
19:30:43 <mwhit> thanks
19:32:32 <solidus-river> mwhit: from a dumb perspective it seems like writing exploratory code in a loosly type language and then looking for what comes up is adding extra step and obfuscation to looking for exploring what you might be able to see while writing the visualization code
19:33:30 <solidus-river> you could be missing opportunities to form your final visualization by jumping to its end form before thinking about what that might mean
19:34:15 * solidus-river puts the weed down
19:34:17 <mwhit> solidus-river: I'm not sure I follow
19:34:18 <trap_exit> besides that one chapte rin RWH, what is a good tutorial on sqlite3 + haskell bindings ?
19:34:22 <mwhit> haha
19:34:26 <mwhit> that explains it
19:34:26 <Hodapp> solidus-river: pass that here please
19:34:32 <NemesisD> so if i wanted to have a bunch of parallel tests to be forced to be sequential, would i use a MSem with 1?
19:35:52 <isomorpheous> Hodapp: i'm next
19:37:11 <Hodapp> isomorpheous: have you been waiting in the woodwork the whole time?!
19:37:27 <isomorpheous> Hodapp: sort of just watching the channel as I do actual work
19:38:21 <mwhit> couldn't keep away from the weed chat though
19:38:57 <Hodapp> solidus-river: my take is that sometimes when one is exploring data and really has no idea what one is looking at going in, the looser languages can be quicker for the actual exploration, before one really has a clear idea what sort of types and structures might be needed.
19:39:23 <mwhit> ^^^
19:39:29 <Hodapp> solidus-river: I also say this having never even _tried_ to do any real data exploration in Haskell.
19:39:33 <Hodapp> so, take that how you will.
19:39:47 * solidus-river passes one over to mwhit
19:39:59 <mwhit> what you need is something like the pandas/matplotlib/sklearn/ipython notebook stack that python has
19:40:01 <Hodapp> "Beautiful Code" makes.... maybe not the opposite case, but not quite the same one.
19:40:04 <solidus-river> i'm saying this only ever done data exploration in d3js really so i'm defintely not one to talk
19:40:06 <mwhit> haskell has none of those, really
19:40:13 <mwhit> charting is passable
19:40:36 <solidus-river> but it seems like you might miss an insight into your data you'd get by trying to well form your visualization by going straight to your visualization
19:40:40 <Hodapp> solidus-river: and you found it still rather sloppy and obfuscated in d3js?
19:41:21 <solidus-river> Hodapp: no, i thought it was great! but d3js isn't your average javascript lib
19:41:44 <td123> I would like to convert Text which represents hex numbers into an actual number (Word32) , i.e. f "a" = 10 anyone have any suggestions
19:42:07 <mwhit> > read "a" :: Word32
19:42:08 <lambdabot>  *Exception: Prelude.read: no parse
19:42:12 <mwhit> guess not
19:42:48 <isomorpheous> @hoogle :: Text -> Word32
19:42:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:42:50 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
19:42:50 <lambdabot> Data.Text.Lazy.Internal foldlChunks :: (a -> Text -> a) -> a -> Text -> a
19:42:54 <isomorpheous> td123: there you go
19:43:01 <mwhit> haha
19:43:02 <mkrtem> td123: import Numeric
19:43:04 <mkrtem> readHex
19:43:23 <td123> isomorpheous: unsafeCoerce looks like the one I want ;)
19:43:31 <mwhit> > readHex "a"
19:43:31 <isomorpheous> td123: no, it isnt
19:43:33 <lambdabot>  [(10,"")]
19:43:37 <td123> isomorpheous: /s
19:43:42 <isomorpheous> td123: phew
19:44:02 <Iceland_jack> you can also use Numeric.Lens
19:44:03 <Iceland_jack> > "a" ^? base 16
19:44:05 <lambdabot>  Just 10
19:44:19 <Iceland_jack> > "abcd12345" ^?! hex
19:44:21 <lambdabot>  46117495621
19:44:47 <mwhit> i swear to god every Haskell program is a one-liner in lens but fuck if i can figure out anything more complicated than getters/setters
19:45:08 <Iceland_jack> mwhit: This one is quite simple :) https://hackage.haskell.org/package/lens-3.8.5/docs/Numeric-Lens.html
19:45:25 <Iceland_jack> > "1010101" ^?! base 2
19:45:26 <lambdabot>  85
19:45:47 <benzrf> > "18" ^?! base 2
19:45:49 <lambdabot>  *Exception: (^?!): empty Fold
19:46:01 <Iceland_jack> chrisdone actually just added my requests for adding bases for `formatting`
19:46:02 <benzrf> > "18" ^‽ base 2
19:46:04 <lambdabot>  Not in scope: ‘^‽’
19:46:08 <Iceland_jack> *accepted
19:46:13 <benzrf> >not using interrobangs
19:46:20 <Iceland_jack> @hackage formatting
19:46:21 <lambdabot> http://hackage.haskell.org/package/formatting
19:47:23 <td123> mwhit: I think I will go with your suggestion because I am also not familiar with a lot of lens'
19:47:38 <td123> thanks yall
19:47:39 <Iceland_jack> If you haven't got lens installed you shouldn't definitely not use it just for that :)
19:47:59 <platz> prism seems to be the hot thing these days - should probably learn it tonight
19:50:09 <mwhit> and just throw the word "folded" in there a few times and it just figures out what function you meant magically
19:50:12 <mwhit> as far as i can tell
19:50:25 <td123> Iceland_jack: I don't mind dependencies, it's just my unfamiliarity :P
19:50:32 <mwhit> i should really sit down with it sometimes
19:50:37 <mwhit> you probably would mind a lens dependency
19:50:40 <mwhit> it is not small
19:50:44 <Iceland_jack> What mwhit said
19:50:58 <Iceland_jack> Especially when the alternative is in Numeric
19:52:55 <Iceland_jack> @let atBase n str = str ^?! base n
19:52:57 <lambdabot>  Defined.
19:52:57 * Hodapp . o O ( I've had a lens dependency since about age 18... )
19:53:01 <Iceland_jack> > atBase(2) "1010101"
19:53:03 <lambdabot>  85
19:53:06 <Iceland_jack> Nothing complicated about that
19:53:14 <mwhit> @rimsho
19:53:14 <lambdabot> Unknown command, try @list
19:53:17 <mwhit> damn
19:53:18 <mwhit> still nothing
19:53:22 <Iceland_jack> :)
19:55:24 <solidus-river> hmm, reading that paper on cellular automata
19:55:39 <joelteon> Hey, can optparse-applicative represent arguments that take either an argument or nothing?
19:55:45 <joelteon> switches?
19:56:00 <solidus-river> i understand how he is using cojoin and fmap to appply a rule to all iterations of a certain state
19:56:11 <solidus-river> but then how does he then filter on that rule?
19:56:24 <solidus-river> eventually he will want to find where that rule is true, this would be quite expensive
19:56:38 <solidus-river> how does he take a state where tha trule is true and iterate on it further?
19:59:01 <solidus-river> i guess thats not really the problem that cellular automata are trying to solve though
19:59:11 <solidus-river> just seem slike his =>> function is only doing one part of applying the rule
19:59:26 <solidus-river> theres a second part which is finding out for which universes that rule is true
20:01:45 <johnw> joelteon: yes
20:01:59 <joelteon> sorry, I hope that question was well-formed
20:02:09 <alphonse23_> why didn't the E programming language take off?
20:02:30 <mwhit> people were sick of the alphabetical naming scheme
20:03:17 <johnw> joelteon: use 'flag'
20:03:35 <Hodapp> what's special about E?
20:03:39 <Hodapp> (the language, not the drug)
20:03:47 <joelteon> well, flag doesn't take options
20:03:49 <Cale> Besides, everyone knows that the letter after C is P.
20:03:51 <joelteon> it just toggles something on and off
20:03:52 <alphonse23_> message passing, all the way back in 1998
20:03:53 <mwhit> Hodapp: after 2 seconds of wiki-ing, the whole langauge is built around message-passing
20:04:02 <johnw> I see it taking 3 arguments
20:04:04 <Hodapp> mwhit: sounds like Smalltalk >_>
20:04:14 <solidus-river> it offers both parallellism and perpindicularity in one form
20:04:17 <johnw> "A flag that switches from a "default value" to an "active value" when encountered."
20:04:22 <alphonse23_> smalltalk was an early oo though
20:04:23 <johnw> have the default value be Nothing
20:04:25 <alphonse23_> very differnt
20:04:46 <jfeltz> is there a haskell analogue to perl's template-toolkit? I.e. (a Buffer -> Buffer function, which takes {{{str}}} and replaces it with a variable defined for str?
20:04:54 <Hodapp> alphonse23_: but Alan Kay regretted calling it object-oriented, he later said, because he wanted the focus to be on the messaging, not on the objects.
20:04:56 <johnw> you may need to drop down to argument, for arbitrary values
20:05:06 * solidus-river goes and takes a time out
20:05:07 <Hodapp> solidus-river: perpendicularity?
20:05:08 <johnw> jfeltz: see heist and shakespeare
20:05:15 <solidus-river> Hodapp: made it up :P
20:05:27 <Cale> jfeltz: Perhaps http://hackage.haskell.org/package/heist
20:05:34 <Hodapp> solidus-river: I guess you fooled me. It seemed plausible.
20:05:35 <jfeltz> cool, thanks
20:05:42 <Cale> jfeltz: There are a bunch of other things like that
20:06:19 <solidus-river> the E has both parallel and perpendicular lines therefore whats special about E is that it offers both parallelism and perpindicularity in one form
20:06:30 <joelteon> hey, I found a use for ScopedTypeVariables
20:06:56 <Cale> solidus-river: "orthogonality" :)
20:07:01 <solidus-river> darn
20:07:04 <solidus-river> :P
20:07:15 <mwhit> but what about obliqueness?
20:09:17 <mwhit> joelteon: Do they have a reputation for being un-useful? I've occasionally found them helpful
20:09:30 <jfeltz> cale: omg heist is nice, thanks again
20:09:31 <joelteon> mwhit: I just mean one that wasn't giving a type signature to a lambda
20:09:39 <mwhit> oh
20:09:41 <mwhit> well then i got nothin
20:09:49 <Cale> jfeltz: no problem!
20:10:11 <sjouke> http://lpaste.net/108206
20:10:48 <sjouke> wouldn't these overwrite each other?
20:11:03 <mwhit> sjouke: only if they shadow particular names
20:11:13 <mwhit> otherwise they just get combined into a single namespace
20:11:36 <prophile> nom
20:11:36 <solidus-river> mwhit: a single form with obliqueness orthogonality and parallelism is impossible. See: CAP theorem
20:11:40 <solidus-river> E's trying it's best
20:12:26 <sjouke> mwhit: oh that's neat
20:14:05 <mwhit> man, if I wrote as much Haskell as I talked and read about it I would have so much done
20:15:06 <benzrf> mwhit: lol
20:15:09 <benzrf> same
20:17:54 <trap_exit> is there
20:18:05 <trap_exit> is there a EDSL for SQL in haskell, or is http://book.realworldhaskell.org/read/using-databases.html state of the art?
20:19:14 <joelteon> trap_exit: esqueleto
20:19:37 <johnw> esqueleto is quite nice
20:19:53 <joelteon> it's not perfect but it's good
20:20:04 <johnw> oh, are there perfect libraries? :)
20:20:11 <trap_exit> is there a good tutorial
20:20:14 <trap_exit> or should I start with https://hackage.haskell.org/package/esqueleto ?
20:20:21 <joelteon> I know of at least one perfect program
20:20:25 <joelteon> use that, trap_exit
20:20:28 <johnw> the null program?
20:20:29 <trap_exit> the readme is slightly short : https://github.com/prowdsponsor/esqueleto/
20:20:35 <joelteon> main = putStrLn "Hello, world!"
20:20:45 <johnw> the exclamation mark could be a bit taller
20:20:59 <trap_exit> also
20:21:02 <trap_exit> I think you forgot "main :: IO ()"
20:21:12 <trap_exit> it's a good policy to write hte type of functions you define
20:21:15 <johnw> and your program is riddled with IO
20:21:32 <trap_exit> also, it may be racist to non-English speaking people
20:21:34 <trap_exit> why "Hello World" ?
20:21:38 <trap_exit> how about "Bonjour"
20:21:42 <trap_exit> or "Ni Hao"
20:22:32 <trap_exit> hmm, I'm templted very much to say "screw SQL" and "use acid-state" https://hackage.haskell.org/package/acid-state
20:22:43 <trap_exit> I wish I could read more about the tradeoffs somewhere
20:24:40 <trap_exit> Lemmih
20:26:45 <haasn> One of the trade-offs is that acid-state is not a database
20:26:51 <platz> I don't know, I thought there were many issues with hackage using acid-state?
20:26:59 <Hodapp> I was just reading the description... does acid-state use anything else at the backend?
20:27:19 <platz> like if they had started over, they would never have picked it
20:27:21 <haasn> For one, it's not designed to be distributed or networked; for two, it's not designed to be offline or external - you load the entire saved state into memory during startup
20:27:22 <trap_exit> well
20:27:33 <trap_exit> if you have persistence, query, and update
20:27:36 <trap_exit> why do you need a database?
20:27:46 <trap_exit> I thought acide-state = load all keys into memory, but not necesairly all of db into memory
20:27:51 <haasn> Shared usage, large amounts of data, distributed redundance, etc.
20:28:23 <trap_exit> well, I was about to use sqlite3
20:28:29 <trap_exit> which doesn't support any of those 3
20:29:18 <Welkin2> use mongo!
20:29:20 <Welkin2> it's webscale
20:29:59 <platz> I'd like to learn cassandra - seems to be used by some big players
20:30:30 <platz> netflix et al..
20:30:45 <Welkin2> who cares what big companies use?
20:30:49 <Welkin2> most of them use shitty technology
20:31:01 <Welkin2> java? php?
20:31:10 <trap_exit> there is an issue of stability
20:31:12 <xpika> is it possible to load a library in ghci without increasing the size of the prompt?
20:31:16 <trap_exit> if a billionaire dollar company sues a package
20:31:24 <trap_exit> it means that if you pay hundereds of millions, you can get engineers to make it work
20:31:30 <Hodapp> trap_exit: I hope you mean "uses", not "sues"
20:31:42 <trap_exit> right, uses
20:31:45 <platz> Welkin2: when you build a distributed system bigger than netflix's, let me know
20:31:49 <Iceland_jack> xpika: You can set the 'prompt' variable
20:31:52 <Hodapp> because companies have attempted stupider things
20:31:55 <Iceland_jack>     ghci> :set prompt "ghci> "
20:32:46 <Welkin2> platz: building something doesn't mean you are an expert on it
20:33:07 * hackagebot haskmon 0.1.0.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  http://hackage.haskell.org/package/haskmon-0.1.0.0 (pjrt)
20:33:19 <Welkin2> there was an interesting talk given by Joe Armstrong (inventor of Erlang) where he analyzed twitter's infrastructure and criticized how wasteful it was
20:33:39 <Welkin2> he built telecom infrastructure
20:34:22 <trap_exit> is there any haskell package for providing journaled IO ?
20:36:07 <Hodapp> Welkin2: If you are talking about a company that has successfully scaled to a size like that, the mere fact that they've done it probably carries with it some relevant experience and experimentation.
20:36:35 <platz> Erlang's pretty compelling - yeah.  except for the untyped goo flying around.  still the OTP stuff is incredible
20:36:57 <trap_exit> platz: tell mea bout it
20:37:12 <Hodapp> Welkin2: The existence of giant enterprises where "Me too!" is their entire philosophy on design and tools doesn't mean that no companies exist that can actually set up huge systems competently.
20:40:54 <vamega1>  Hi.
20:41:03 <vamega1> With Heist's attribute substitution
20:41:39 <vamega1> Does the ${name} need to be the only text in the attribute field?
20:41:48 <vamega1> Or can it just be a part of it
20:42:14 <vamega1> For example href="http://mysite.com/${url}"
20:42:41 <vamega1> This is with regards to snap, if that makes any difference.
20:49:02 <cboling> is there a way to express that a datatype is an class instance only under certain constraints, when the constraints apply to a type variable that does not appear in the instance head because the type constructor in question is partially applied?
20:49:04 <xpika> Iceland_jack: thanks!
20:50:18 <cboling> like for instance I would like to have for some data MyType k, an instance MyClass MyType, which requires that k belongs to Eq
20:51:29 <jle`> cboling: no
20:51:42 <jle`> cboling: not in an easy way at least
20:51:53 <jle`> cboling: usually if you do this, you might be finding the solution for the wrong problem
20:52:17 <mwhit> so here's an odd question: if i have a function wrapped in a newtype, is there anyway I can make that function "applyable" without unwrapping it?
20:52:23 <mwhit> I am trying to do this: https://news.ycombinator.com/item?id=8091699
20:52:36 <mwhit> and I have a function that will do what I want but i have to wrap it in a newtype
20:52:37 <cboling> I tried wrapping MyType in an existential type, which at least typechecks, but it gets quite messy when I want to apply functions with nontrivial types to the MyType inside the instance definition
20:53:00 <jle`> cboling: yes, because an existential type is almost always not what you are looking for :)
20:53:14 <jle`> cboling: can you give an example of what you are trying to do?
20:53:17 <cboling> hahaha yes I had heard this
20:53:23 <isomorpheous> jle`: hi jle`
20:53:30 <jle`> hi isomorpheous
20:53:33 <jle`> hru?
20:54:14 <jle`> mwhit: you can give it an applicative instance and use (<*>) maybe  :|
20:54:35 <mwhit> yeah but it has to be the exact syntax of function application by the rules, sadly
20:54:39 <jle`> hm.
20:54:40 <mwhit> shame, I came so close
20:54:45 <mwhit> but i'm not sure it's possible
20:54:45 <jle`> such sad
20:54:50 <isomorpheous> jle`: Can't complain. How about yourself?
20:55:16 <jle`> not too bad.  a nice lazy saturday fixing up some stuff around the house
20:57:14 <augur_> is it sensible to have C code that calls haskell code that calls C code? or should i try to push the C stuff together?
20:57:15 <jle`> mwhit: the challenge, or the newtype application?
20:57:19 <spopejoy> hi y’all. If I have a function “runProc :: String -> StateT Env IO ()”, how do I call something like putStrLn in a do block?
20:57:27 <mwhit> jle`: either
20:57:35 <jle`> mwhit: it looks like it claims to be solved for haskell?
20:57:38 <augur_> the parts of the C stuff are distinct, performing two completely different tasks
20:57:45 <jle`> if i were to do it i might try something like the printf hacks
20:57:46 <jle`> "hacks"
20:58:01 <jle`> spopejoy: you can use liftIO, or (more fragilly) lift
20:58:15 <jle`> liftIO :: IO a -> StateT Env IO a
20:58:22 <jle`> lift has the same type signature in this context too
20:59:03 <spopejoy> jle`: makes sense, but do I do that in a single line like do … liftIO >> putStrLn $ “hello”?
20:59:13 <mwhit> jle` boo, well that's disappointing
20:59:16 <cboling> jle`: here is a simplified example: http://lpaste.net/3076477502097457152
20:59:24 <mwhit> somewha less elegant than my not-quite-a-solution
20:59:25 <cboling> assuming I did the pastey thing right
20:59:30 <mwhit> or at least that's what I'm telling myself
20:59:46 <jle`> spopejoy: liftIO is a function
20:59:53 <jle`> spopejoy: it takes an IO a, and turns it into a StateT Env IO a
21:00:18 <jle`> so you give it an IO ()....say, putStrLn "hello"
21:00:25 <jle`> you apply liftIO to that
21:00:26 <jle`> what do you get?
21:01:14 <spopejoy> so, liftIO $ putStrLn “hello"
21:01:22 <spopejoy> lifts the IO into the StateT
21:01:33 <jle`> yeah
21:02:01 <jle`> one way you can think of it is that it makes it the right 'shape' to put into the do block
21:02:41 <jle`> cboling: one thing you can do is add the Eq constraint to the definition of member
21:02:42 <benzrf> monad transformers suuuuuuuuuuuuuuck
21:02:58 <jle`> member :: Eq a => f a -> f a
21:03:17 <jle`> benzrf: surely you aren't referring to this current context, right? :)
21:03:26 <spopejoy> benzrf: better option?
21:03:26 <benzrf> eh
21:03:28 <mwhit> how's them extended effects coming along anyway
21:03:35 <benzrf> spopejoy: i do not know u_u
21:03:45 <jle`> this question really isn't about monad transformers
21:03:49 <jle`> it's about monad morphisms
21:03:50 <jle`> in general
21:03:59 <jle`> which is actaully a nice concept, i think
21:04:02 <mwhit> extended effects are supposed to be, but they're not really fleshed out in haskell afaik
21:04:11 <mwhit> extensible*
21:04:20 <spopejoy> benzrf: don’t worry don’t know u either. buhbye
21:04:31 <jle`> spopejoy: no it was supposed to be an emoticon :O
21:04:34 <jle`> u_u
21:04:38 <jle`> see? it's like a face with closed eyes :)
21:04:44 <spopejoy> :)
21:04:47 <benzrf> downturned eyes, even
21:04:50 <mwhit> looks like adventure time
21:04:54 <jle`> why the long face
21:04:54 <spopejoy> we can all poke at each other no?
21:04:56 <benzrf> mwhit: adventure time ftw
21:05:13 <jle`> but i like explaining jokes to the point that i kill their humor :/
21:05:34 <spopejoy> jle`: so liftIO is not a mtl thing?
21:05:48 <cboling> jle`: right, but what if the class is more general than that? the operands of my member function aren't required to have anything to do with Ord in general, but for this instance it's necessary in order to define some operations.
21:06:15 <jle`> spopejoy: it's from transformers, but it actually is more general of an idea than monad transformers
21:06:28 <jle`> it's the idea of a monad morphism
21:06:47 <jle`> let's say you had your arbitrary monad MyMonad
21:07:05 <jle`> having a MonadIO instance says "you can turn any IO a into a MyMonad a, and it'll behave sensibly"
21:07:40 <jle`> so basically, you can do your entire program in a MyMonad monad
21:07:58 <jle`> and you can freely convert any IO into your MyMonad
21:08:02 <jle`> so that they all fit together
21:08:10 <jle`> sort of like a greatest-common-denominator thing
21:08:33 <jle`> in fact, you can define a whole bunch of m a -> MyMonad a's, for various "source" monads
21:08:57 <jle`> what's important is that...you can now sequence together IO's, and m's , and whatever source monads...even though they come from different sources, you can now use them all together
21:09:05 <jle`> as if they were all originally from MyMonad
21:09:06 <spopejoy> interesting, more a type class approach than xxxT
21:09:44 <spopejoy> same for MonadState then?
21:09:50 <jle`> in your case, you didn't make MyMonad from scratch...the way it was constructed gave you a *free* MonadIO
21:09:54 <vamega1> Hi
21:09:57 <jle`> and it also gives you a free MonadState, too
21:10:01 <hiptobecubic> Is there no unfoldM
21:10:04 <hiptobecubic> ?
21:10:10 <jle`> your monad has a free MonadState instance, by construction
21:10:18 <vamega1> Can anyone explain how I'm able to access the ## function by importing Data.Heist
21:10:23 <jle`> so you can turn any MonadState s m "into" your monad
21:10:24 <vamega1> even though https://hackage.haskell.org/package/heist-0.13.1.2/docs/Heist.html
21:10:28 <vamega1> Doesn't describe that at all
21:10:31 <jle`> hiptobecubic: is it in monad-loops?
21:10:59 <vamega1> And according to haddock the ## function is defined in Heist.SpliceAPI
21:11:02 <rs0> which alternatives to monads have been explored for capturing the presence of side effects, other than the main :: [Response] -> [Request] approach I read about somewhere?
21:11:04 <jle`> cboling: there is a way to do this with type families and constraint kinds
21:11:34 <jle`> cboling: but consider a non-typeclass-based solution to whatever problem you are trying to solve :)
21:11:37 <Cale> rs0: Arrow based FRP systems, for instance
21:12:25 <mwhit> vamegal: because the Heist module re-exports the entire Heist.SpliceAPI module
21:12:27 <rs0> Arrow as in Control.Arrow, I guess?
21:12:27 <mwhit> https://hackage.haskell.org/package/heist-0.13.1.2/docs/src/Heist.html
21:12:28 <jle`> spopejoy: in order for monad morphisms to work this way and give you this sort of 'can compose monads from all sources' behavior, they have to follow some laws, of course
21:12:31 <mwhit> the very last entry in the export list
21:12:33 <hiptobecubic> So i have  a pipes parser that gives me (parsedValue, unused) and I suppose what i really want is ([parsedValues], unused)
21:12:36 <Cale> rs0: yeah
21:12:54 <jle`> spopejoy: oh, also, can you imagine a function that can take a State Env a into your big monad?
21:13:07 <Cale> rs0: Also, it's a little unfair to lump everything which happens to be a monad into one basket
21:13:09 <spopejoy> liftState?
21:13:18 <jle`> a monad morphism from State Env a?  just like we had another monad morphism from IO a?
21:13:22 <jle`> spopejoy: it's already defined
21:13:27 <Cale> rs0: not all approaches which happen to have a Monad instance need to look anything like IO
21:13:31 <jle`> i think it's just called `lift`
21:13:40 <jle`> wait
21:13:43 <jle`> no
21:13:48 <johnw> rs0: you can see the "extensible effects" paper by Oleg too
21:13:56 <jle`> yeah, it's not defined, you'd have to write one yourself
21:14:03 <spopejoy> jle`: i had to use ‘lift’ for InputT (using Haskeline)
21:14:05 <jle`> spopejoy: but if you have time, i would encourage you to write one :)
21:14:17 <jle`> just for funsies
21:14:22 <jle`> a State s a -> StateT s m a
21:14:44 <jle`> you might find it handy
21:14:49 <spopejoy> :t liftIO
21:14:50 <lambdabot> MonadIO m => IO a -> m a
21:15:08 <jle`> another useful one would be ReaderT s m a -> StateT s m a
21:15:15 <cboling> jle`: I'm thinking about alternatives. do you know of any articles or existing codebases that demonstrate that off the top of your head? should I get a hankering to dabble in ye darke artes
21:15:16 <jle`> where you swap all of the ask's for get's
21:15:29 <jle`> cboling: what stuff?  the type families and constraint kinds?
21:16:07 <joelteon> hi, fsnotify doesn't support ignoring filesystem changes that were caused by the current process. hfsevents does and I'd like to support it if possible. what should I do?
21:16:13 <cboling> jle`: yeah, is this kind of thing those features are typically useful for?
21:16:52 <jle`> perhaps.  it's a fairly new feature and we're still exploring usages.  but...i'm going to take a wild guess and say that the best solution to your specific problem does not involve typeclasses at all
21:17:04 <jle`> now that i have stated my disclaimer, here's http://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/
21:17:07 <cboling> I've worked with type families some and I think I understand the concept of constraint kinds, but the path forward is far from obvious to me.
21:17:34 <mwhit> i'm really interested in what cboling's specific problem is, but i missed the beginning and don't want to make him repeat it
21:18:03 <jle`> mwhit: there is a link to logs in the topic if this situation pops up in the future, if you want :)
21:18:19 <jle`> not that i discourage just asking questions to people
21:18:31 <rwbarton> well, you can start by writing something like class MyClass t c where foo :: c a => t a -> t a
21:19:39 <cboling> mwhit, jle`: specifically I'm trying to define some instances that classify the category of finite-dimensional vector spaces, trying to use some existing libraries to avoid writing my own vector space code.
21:20:40 <cboling> I'm not averse to writing my own vector space library if it becomes apparent that it's necessary, since I'm basically in this for the learning experience.
21:21:15 <cboling> but I doubt that it is since there are several really nice options.
21:21:16 <spopejoy> jle`: looks like I need something else. Now I need to call ‘get’ in a function of type ‘InputT (StateT Env IO) ()’. Would the liftState fun you’re describing fit this, or is this more mtl-y?
21:21:39 <johnw> spopejoy: are you sure you want to throw away state changes if the user presses Control-C?
21:22:27 <spopejoy> johnw: hadn’t thought about it, but it’s probably fine, but say I didn’t?
21:22:44 <johnw> if you didn't, you'd use StateT Env (InputT IO) ()
21:22:56 <bb010g> Dang, the http://ghc.haskell.org/trac/ghc/wiki/PatternFamilies looks sweet. :)
21:23:20 <cboling> jle`: thank you very much for the link and the input
21:23:33 <spopejoy> johnw: interesting. main is ‘main = runStateT (runInputT settings loop) (Env "" "" "")'
21:23:33 <jle`> cboling: np! i'm interested in seeing what you do with it
21:23:56 <spopejoy> state is strict
21:25:24 <bb010g> mwhit: http://hackage.haskell.org/package/effin seems to be coming along nicely in the extensible effects department (no Typeable constraints).
21:26:06 <lpvb> x/quit
21:27:00 <gamegoblin> What do you guys thing the nicest way of expressing “given t microsecnds and n bytes, read up to n bytes from a handle, but if n bytes aren’t read by time t, return what was read”?
21:28:47 <johnw> you'd need to use timeout, and a loop that accumulates chunks into an IORef
21:29:06 <gamegoblin> That’s what I was hoping to avoid T_T sigh
21:30:52 <jle`> you might be able to use a streaming library to help?
21:31:27 <glguy> gamegoblin, This will probably help http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:threadWaitRead
21:32:29 <glguy> unless you just plan to have a dedicated thread that owns the Handle
21:35:14 <fumieval> edward
21:42:59 <carter> joelteon: what can't you use the latter?
21:45:07 <benzrf> pipes is hella
21:45:56 <benzrf> glguy: looks like it suffers from the lack of proper row polymorphism
21:46:05 <benzrf> ah, bb010g, not glguy
21:46:25 <carter> cboling: vector spaces?!
21:46:28 <carter> what'chu upto?
21:48:33 <joelteon> carter: cross platforming
21:48:52 <benzrf> joelteon: is that like mario, but u play as a cross
21:48:52 <carter> joelteon: so the issue is that the os x lib by luite is nice, and the others are meh/
21:49:02 <carter> ?
21:50:05 <tejing> Is there a function that's equivalent to unfoldr except it also returns the final value of the accumulator?
21:50:34 <carter> state + traverse could let youy do th that
21:50:46 <carter> *traverse + State
21:50:56 <carter> at every entry, put the valueinto the State
21:51:04 <copumpkin> tejing: there is no final value!
21:51:06 <carter> after teh traverse, get the State value
21:51:12 <carter> oh
21:51:12 <jle`> that sounds slightly overkill
21:51:13 <carter> unforldr
21:51:19 <carter> jle`: its FAST
21:51:21 <carter> in my case
21:51:27 <jle`> how about mapAccumL ?
21:51:35 <jle`> :t mapAccumL
21:51:36 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:51:36 <copumpkin> mapAccumL is mapM over State
21:51:47 <jle`> :t mapAccumR
21:51:48 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:51:49 <copumpkin> and mapM is traverse
21:52:03 <jle`> hm. oh
21:52:06 <carter> :)
21:52:10 <jle`> heh
21:52:12 <jle`> it all makes sense now
21:52:13 <copumpkin> proof that great minds think alike!
21:52:17 <carter> jle`: traverse aint over kill, it beautiful
21:52:17 <copumpkin> >_>
21:52:17 <jle`> it's just traverse without the newtype
21:52:23 <jle`> it's beautiful
21:52:26 <jle`> i cry
21:52:28 <jle`> ;_;
21:52:30 <joelteon> carter: it's either that, or inotify doesn't actually support doing what I want to do
21:52:44 <carter> and where the inotify docs/
21:53:04 <joelteon> I didn't really think of that
21:53:05 <jle`> this is p cool
21:53:12 <jle`> im going to stare at it for a while
21:53:22 <joelteon> it doesn't look like it
21:53:23 <carter> jle`: i use travser + state A LOT in Numerical.Array.Layout.Dense
21:53:27 <joelteon> but I'm not very good at reading manpages
21:53:57 <jle`> once the state newtype is removed, it's literally just mapAccumL, but with the arguments flipped
21:54:42 <jle`> :t traverse
21:54:44 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:54:44 <carter> jle`: whose?
21:54:56 <carter> jle`: in my version its also not recursive :)
21:55:04 <carter> so it gets optimized to hellllll magic
21:55:31 <jle`> traverseState :: acc -> (x -> acc -> (y, acc)) -> [x] -> ([y], acc)
21:55:37 <carter> joelteon: sad news
21:55:38 <carter> Limitations and caveats
21:55:38 <carter>        The inotify API provides no information about the user or process
21:55:39 <carter>        that triggered the inotify event.  In particular, there is no easy
21:55:40 <carter>        way for a process that is monitoring events via inotify to
21:55:41 <carter>        distinguish events that it triggers itself from those that are
21:55:42 <jle`> ...don't mind me, just manually unwrapping the newtype wrappers
21:55:42 <carter>        triggered by other processes
21:55:43 <carter> http://man7.org/linux/man-pages/man7/inotify.7.html
21:55:59 <joelteon> hey, look, something osx did right
21:56:00 <carter> jle`: i use my own custom copy of StateT
21:56:05 <jle`> you do?
21:56:07 <joelteon> I'll use that to start the list of things osx did right
21:56:08 <jle`> link pls
21:56:08 <prophile> there's a more recent file notification system isn't there?
21:56:17 <carter> jle`: you know where to look damn it :p
21:56:36 <jle`> oh yes i do ^.^
21:56:37 <carter> jle`: its basically a copy of StateT with INLINE rubbed onto everything
21:56:44 <prophile> fanotify
21:56:52 <jle`> heh
21:57:01 <carter> because in my use case i'm only computing on static sized lists of lenght < 5
21:57:14 <carter> so i want the abstractions to evaporate at compile time
21:57:22 <prophile> and fanotify does have pids in it
21:57:39 <gamegoblin> Let’s say someone is sending an http request, and they send a header field once every 10 seconds. How can you know, programmatically, if they are done sending their request, or just really slow at sending the data? Does the socket know when they’ve finished writing?
21:57:40 <joelteon> "there is no support for create, delete, and move events"
21:57:43 <joelteon> maybe I can use a mix of both
21:58:10 <jle`> carter: oic
21:58:16 <jle`> so the recursion is inlined away
21:58:18 <carter> yes
21:58:25 <carter> jle`: 'cause i hve that type class induction trick
21:58:30 <carter> technique
21:58:33 <jle`> super cute
21:58:35 <carter> for my static sized lists
21:58:47 <carter> jle`: lpaste.net/107923
21:58:54 <carter> is the core from the unit tests for my Shape type
21:59:09 <carter> it basically all  evaporates
22:00:14 <jle`> i'm impressed
22:00:20 <carter> http://man7.org/linux/man-pages/man7/fanotify.7.html#NOTES
22:00:26 <carter> fyi joelteon
22:00:40 <carter> jle`: ironically, i was doing a very different design in the spring
22:00:43 <carter> that was more comlpicated
22:01:07 <xinming_> Just curious, Is there a haskell programming standard (defacto or not, Or best practise) on indention and newline for haskell source?
22:01:13 <xinming_> I mean wether we have an article on this
22:01:20 <carter> xinming_: thers a few style guilds on trhat level
22:01:23 <carter> tibbel has one
22:01:29 <xinming_> carter: Thanks. I'll google it
22:01:32 <carter> @google haskell style guild tibbel
22:01:33 <lambdabot> https://github.com/tibbe/haskell-style-guide
22:01:36 <gamegoblin> I use 4 spaces… that’s just me though
22:01:37 <carter> BAM
22:01:41 <carter> i use 2
22:01:54 <carter> because othewise my code would nest too much
22:01:54 <gamegoblin> I use 4 spaces in every language
22:02:11 <gamegoblin> I try not to go more than 3 indentation levels deep in any function
22:02:13 <rs0> gamegoblin: even Go?
22:02:14 <gamegoblin> if I do, I try to refactor
22:02:21 <gamegoblin> rs0: I don’t use Go
22:02:22 <carter> i wish my code was simple enough that i couldnt have that rule
22:02:28 <rs0> gamegoblin: what about Makefiles? =)
22:02:29 <carter> gamegoblin: i can't in mine
22:02:30 <xinming_> space is not the problem, Because 2 or 4 is based on personal preference, I use 4 spaces in all my projects too. But I do see some good programmer prefer 2 space indent
22:02:33 <xinming_> :-)
22:02:38 <gamegoblin> rs0: Don’t use make either
22:03:24 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Layout/Sparse.hs#L569-L615
22:03:54 <gamegoblin> Is there a way to take an attoparsec Parser type and turn it into a Partial without feeding it any input?
22:04:19 <carter> feed it an empty string?
22:04:28 <gamegoblin> empty string in attoparsec == no more input
22:04:46 <gamegoblin> I wish attoparsec used a Maybe ByteString where Nothing signified no more input
22:04:58 <gamegoblin> so you could feed empty strings
22:05:09 <carter> gamegoblin: padd the parse with a char "\ " and  feed it a \
22:05:43 <xinming_> Just read the style guide, I don't like the idea by putting , in front of the line. Though I did that before in SQL. >_<
22:05:58 <carter> xinming_: , in front is easier to do correctly
22:06:02 <bb010g> benzrf: How so? I'm not too familiar with the type gymnastics involved.
22:06:07 <jle`> it's easier to align everything, heh
22:06:08 <gamegoblin> carter: that does work I guess… I could do `toPartial p = parse (char8 ‘ ‘ >> p) “ “`
22:06:13 <jle`> and deleting/adding lines is much easier
22:06:24 <carter> gamegoblin: :)
22:06:51 <gamegoblin> I wish attoparsec had a builtin toPartial. It’s a one liner. toPartial (Parser p) = Partial p
22:07:21 <liyang> gamegoblin: Partial (parse yourParser) :: IResult ByteString YourResultType does what you want, no?
22:07:43 <benzrf> bb010g: looked like it uses ordered lists of effects
22:07:53 <gamegoblin> liyang: I think you may be right
22:08:19 <benzrf> bb010g: in real row polymorphism you can match on any element of a set and the remainder
22:08:22 <benzrf> i.e.
22:08:50 <benzrf> Eff (random :: Random, trace :: Output | r) a -> Eff r a
22:08:55 <benzrf> ^purescript
22:09:21 <benzrf> unordered, as befits sets of types
22:09:24 <benzrf> *effects
22:09:56 <bb010g> Could it still not require typeable and use sets?
22:10:02 <benzrf> probably not
22:10:12 <benzrf> im saying haskell doesnt have good enough language level support for this kind of type hax
22:11:46 <bb010g> benzrf: What effect does the ordering of the list have to do with the implementation? You require and use effects pretty much the same way (at least from what I've seen).
22:12:19 <trap_exit> why does HappStack.Server use String instead of Text? see http://www.happstack.com/docs/crashcourse/index.html#parsing-request-data-from-the-query_string-cookies-and-request-body
22:15:09 <bb010g> benzrf: How would you even make an unordered set at the type level? It would still be ordered internally and I don't see how you could hide it except for not showing the constructors underneath (which is what I think effin uses).
22:16:34 <benzrf> bb010g: the ordering matters because you can only pull out effects in the predefined order that you set the type
22:16:55 <benzrf> example it gave:
22:17:01 <benzrf>  runException :: Effect (Exception e ': es) a -> Effect es (Either e a)
22:17:12 <benzrf> ^this only works if Exception is the first effect in the list
22:17:25 <benzrf> what if i want to runException on something in a different order?
22:17:34 <djef> Hola. I tried to install IHaskell via cabal, and it says that it installed, but there is no IHaskell on my system when it's done. OSX 10.9.4. no idea what to do from here.
22:18:15 <Iceland_jack> By projecting from a type like in Datatypes a la Carte
22:18:24 <dmj`> djef: is cabal bin in your path? are you using a sandbox?
22:18:34 <benzrf> Iceland_jack: ?
22:18:39 <djef> not using a sandbox, cabal in my path.
22:19:29 <djef> when i do "cabal install ihaskell --reorder-goals" i get "...All the requested packages are already installed..." and says i have ihaskell-0.4.1.0
22:19:40 <djef> but "IHaskell" is nowhere to be found on my system.
22:19:59 <djef> unless it's someplace odd.
22:20:36 <dmj`> djef: did you check your cabal bin directory
22:21:08 <djef> i have cabal in /usr/bin/ but nothing about ihaskell in there.
22:21:56 <dmj`> is it in  ~/.cabal/bin ?
22:22:21 <djef> i have ~/.cabal but no bin subdir
22:24:54 <dmj`> djef: try creating a sandbox and installing it in there, then check the .cabal-sandbox/bin/ dir, mkdir ~/Desktop/mydir && cd mydir && cabal sandbox init && cabal install ihaskell
22:28:18 <djef> wild,  found the binary it made. it put it into ~/Library/Haskell/ghc-7.6.3/lib/ihaskell-0.4.1.0/bin
22:29:43 <djef> when i add that to my path it runs. but what a zany place to put it.
22:33:09 <cronocronopio> Hi guys!
22:33:36 <isomorpheous> cronocronopio: hi
22:34:28 <cronocronopio> isomorpheus, how are u?
22:34:37 <cronocronopio> I am a newbie on IRC haha
22:35:01 <benzrf> hello cronocronopio
22:35:06 <isomorpheous> cronocronopio: I'm good, how about yourself?
22:35:09 <benzrf> welcome to the gr8est form of internet chat
22:35:31 <isomorpheous> cronocronopio: benzrf is correct
22:35:43 <cronocronopio> Im fine! Im from Argentina
22:35:55 <cronocronopio> Hello benzrf!
22:36:15 <cronocronopio> Sorry for my english, it is some fuzzy
22:36:28 <augur_> so
22:36:33 <augur_> in case anyone new is listening
22:36:46 <augur_> is it reasonable to have C that calls Haskell that calls C
22:36:52 <augur_> if the two C parts are unrelated?
22:37:07 <isomorpheous> augur_: yep
22:37:43 <augur_> i worry this might be kind of obnoxious
22:37:45 <isomorpheous> cronocronopio: That's fine, as long as you get your point across.
22:37:55 <isomorpheous> cronocronopio: I'm from 'murica
22:39:06 <cronocronopio> Perfect!
22:39:08 <isomorpheous> cronocronopio: your sleep schedule is nearly as terrible as mine. It's 02:30 in Buenos Aires
22:39:37 <cronocronopio> What is exactly the main topic of this channel? I comes here randomly haha
22:39:44 <augur_> its 1:38am here
22:39:46 <augur_> time for lunch!
22:39:59 <isomorpheous> cronocronopio: It's discussion & help about a programming language called "Haskell"
22:40:33 <cronocronopio> Oh, I understand!
22:40:39 <isomorpheous> As you can see, we're all insomniacs who have no life
22:40:41 <xinming_> This is my second time try to start learning haskell, With more old programming exp, I found the best thing in functional programming is, We don't care about the work flow. In functional programming, We just care about the data relations. :-)
22:40:54 <isomorpheous> xinming_: sort of true
22:41:10 <cronocronopio> haha, so ill feel as in my home
22:41:16 <compton_plusplus> yoooo
22:41:21 <platz> xinming_: hrm, if you really push that, you end up with prolog
22:41:27 <isomorpheous> xinming_: a more accurate description is "there is no workflow"
22:41:45 <isomorpheous> cronocronopio: Do you know any programming?
22:41:55 <jle`> has anyone seen my spoon?
22:42:02 <cronocronopio> Yes, I am a freelance programmer
22:42:09 <compton_plusplus> isomorpheous: Did you know Haskell is for fucking faggots?
22:42:11 <benzrf> jle`: there is no spoon
22:42:14 <gws> welp
22:42:19 <jle`> :o
22:42:22 <isomorpheous> jle`: are you back on the horse?
22:42:25 <isomorpheous> @where ops
22:42:25 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:42:26 <cronocronopio> Currently, i works on Workana, a job platform
22:42:43 --- mode: ChanServ set +o shachaf
22:42:48 --- mode: shachaf set +b *!*zubir@*.hsd1.fl.comcast.net
22:42:48 --- kick: compton_plusplus was kicked by shachaf (compton_plusplus)
22:42:49 --- mode: shachaf set -o shachaf
22:42:52 <xinming_> platz: I didn't try prolog, I just know perl and use closure much in my program. But when I use haskell, The start point is totally different, Before I wrote program is, First, I want to init something, then, I process something.
22:42:53 <isomorpheous> shachaf: thank you
22:43:17 <isomorpheous> platz: never tried prolog
22:43:28 * jle` gives isomorpheous chocolate to heal emotional wounds
22:43:39 <shlevy> When should extensions go in the source file vs the .cabal file?
22:43:52 * isomorpheous happens to be sucrose intolerant. Sorry jle`
22:43:59 <xinming_> But When I read haskell tutorial, I found, the first is we define data type for one thing, and define other for another thing. then, we start write functions to process them separately.
22:44:08 <joelteon> shlevy, it's your call
22:44:14 <joelteon> I prefer source file but I forget why
22:44:15 <isomorpheous> shlevy: really a matter of taste
22:44:15 <jle`> shlevy: i like putting them in the source code so that someone can open up any given file and not have to read the cabal file to know what's enabled
22:44:22 <joelteon> yeah, that's why
22:44:26 <joelteon> now I remember
22:44:27 <shlevy> OK makes sense
22:44:27 <platz> isomorpheous: me neither, but it seems more 'interesting' now because the clojure folks started including some relational logic in their libs
22:44:43 <isomorpheous> platz: hm
22:44:44 <jle`> i don't put anything in the cabal file, even though some projects i have OverloadedStrings on every file, and in almost all my projects i have ScopedTypeVariables turned on everywhere
22:44:49 <jle`> xinming_: i see what you mean :)
22:45:05 <jle`> it also fits well into 'hole-driven development'
22:45:08 <jle`> if you have the right types
22:45:09 <platz> xinming_: I understand, yeah.  Although I think can still achieve a similar flow in haskell if you like that
22:45:11 <jle`> and data
22:45:20 <isomorpheous> I always end up turning on OverloadedStrings, type families
22:45:38 <platz> xinming_: it probably depends mostly on the kind of problem you're working on
22:45:49 <jle`> isomorpheous: it was sucrose free chocolate
22:45:55 <isomorpheous> cronocronopio: Have you ever played with Haskell?
22:46:09 <isomorpheous> jle`: Also maltose and lactose intolerant.
22:46:16 <isomorpheous> jle`: but I appreciate the gesture
22:46:22 <isomorpheous> jle`: I can have monosaccharides
22:46:25 <cronocronopio> isomorpheous: Not really! I only tried Lisp
22:47:01 <isomorpheous> cronocronopio: Haskell's a nice language. It's built by a bunch of Europeans, so you might want to stay away from it.
22:47:20 <isomorpheous> cronocronopio: Stick with 'murican languages like Emacs Lisp and Perl
22:47:53 <cronocronopio> hahha !
22:48:09 <cronocronopio> Is Haskell an interpreted or compiled language_
22:48:12 <hiptobecubic> Emacs lisp is the world's worst lisp.
22:48:15 <isomorpheous> cronocronopio: can be either
22:48:21 <isomorpheous> hiptobecubic: except brainfuck lisp
22:48:26 <hiptobecubic> nope
22:48:33 <jle`> cronocronopio: you'll find that haskell is a very different type of 'functional programming language' than lisp
22:48:33 <shlevy> cronocronopio: Usually used compiled but works fine interpreted
22:48:46 <jle`> this is something that didn't expect to learn
22:48:47 <joelteon> haskell isn't interpreted...
22:48:55 <jle`> sometimes i forget that they classify them both under 'functional'
22:49:15 <isomorpheous> joelteon: runhaskell, hugs
22:49:34 <isomorpheous> joelteon: technically, runhaskell is a run-on-compiler, but basically the same thing
22:49:50 <joelteon> yeah, guess it depends on your definition of interpreted, doesn't it
22:49:51 <isomorpheous> cronocronopio: To answer your question, it is usually compiled
22:49:55 <jle`> i don't think the Report specifies anything about whether or not haskell should be interpreted or compiled?
22:50:01 <cronocronopio> I understand
22:50:39 <cronocronopio> Can I use Haskell integrated with other technologies as PHP? (I am a PHP Programmer hahah)
22:51:16 <jle`> "This report defines the syntax for Haskell programs and an informal abstract semantics for the meaning of such programs. We leave as implementation dependent the ways in which Haskell programs are to be manipulated, interpreted, compiled, etc. This includes such issues as the nature of programming environments and the error messages returned for undefined programs (i.e. programs that formally evaluate to
22:51:19 <jle`> ⊥)."
22:51:47 <joelteon> cronocronopio: not easily
22:51:48 <jle`> cronocronopio: you can, and i believe they do this at Facebook :)
22:51:51 <jle`> oops
22:52:04 <jle`> i hear that haskell is integrated to facebook's php codebase pretty tightly facebook?
22:52:14 <joelteon> what
22:52:36 <jle`> they have a lot of infrastructure for message passing and connections between the two
22:52:47 <jle`> *tightly at facebook
22:53:05 <jle`> and they run side by side on a lot of systems i think...
22:54:07 <jle`> hm.  i should find my sources
22:54:17 <jle`> most of this i think i heard from ReinH's haskellcast with simon marlow
22:54:41 <ReinH> hai
22:54:51 <ReinH> I don't remember any of that but ok :)
22:55:02 <jle`> oh
22:55:09 <jle`> am i dreaming
22:55:30 <jle`> no there was another podcast with simon marlow i think
22:55:55 <jle`> maybe i am going crazy.  ignore everything i am saying
22:56:01 <jle`> until i find a source
22:56:43 <gws> haskellcast #4 had simon marlow talking about haskell at FB
22:59:26 <isomorpheous>  /window merge
22:59:30 <isomorpheous> dammit, hit space
23:01:34 <dfeuer> Aloha,
23:01:49 <isomorpheous> dfeuer: Saluton!
23:02:11 <dfeuer> Not even carter will want benchmarks to tell which is better: https://ghc.haskell.org/trac/ghc/ticket/9369#ticket
23:02:18 <dfeuer> Shalom, isomorpheous!
23:02:56 <carter> dfeuer: no, always benchmark
23:03:01 <isomorpheous> Mrhbtiin, dfeuer
23:03:02 <carter> nothings obvious unless you've measured :)
23:03:20 <dfeuer> carter, please apply your eyes to the Core....
23:03:37 <carter> dfeuer: thats not much core :)
23:04:00 <carter> i agree one looks a teeny bit simpler
23:04:01 <dfeuer> carter, that is part of what makes it obvious which is better :)
23:04:01 <carter> BUT
23:04:09 <carter> measure
23:04:22 <isomorpheous> carter: you sound like my contractor
23:04:43 <carter> isomorpheous: he probably gets paid betetr when he says measure
23:04:53 <dfeuer> Teeny bit simpler?  It erases: an intermediate list, a whole slew of Maybes, *and* all the boxing for the Doubles. It introduces ... NOTHING.
23:05:30 <dfeuer> But sure, carter, I'll benchmark it. Specially for you.
23:05:44 <carter> yay
23:06:09 <carter> dfeuer: but my requesting aside, keep up the good work :)
23:06:29 <dfeuer> *sigh*
23:06:43 <dfeuer> I'll try.
23:06:45 <carter> i found a funnn bug in ghc
23:06:54 <isomorpheous> carter: let's hear it
23:07:20 <dfeuer> Can you maybe explain the attention drawn to eta expansion in GHC's map code?
23:07:34 <carter> theres a lib where theres an exponential slow down when you try to use parallel ghc builds
23:07:53 <platz> they say programmers are like the plumbers of the digital era
23:07:55 <carter> dfeuer: you mean map = \f  x -> kinda stuff?
23:08:00 <dfeuer> I think?
23:08:31 <dfeuer> There's a comment in the source that says something like "Note: eta expansion" with no indication of why that's important.
23:08:35 <benzrf> be back tomorrow
23:08:44 <benzrf> bye
23:09:00 <isomorpheous> benzrf: bye
23:09:03 <carter> dfeuer: switching to #ghc
23:09:28 <glguy> Dfeuer it might be allowing something to inline at that call site
23:09:30 <int3__> what are Mu and Nu in https://hackage.haskell.org/package/recursion-schemes-4.1/docs/Data-Functor-Foldable.html?
23:09:39 <int3__> and how are they different from Fix?
23:09:43 <int3__> I understand Fix, pretty much
23:12:14 <int3__> edwardk: well I guess it can't hurt to ping the creator of the library
23:13:07 <ReinH> int3__: Mu is the least defined fixed point, Nu is the most defined fixed point.
23:13:11 <ReinH> s/most/greatest
23:13:56 <edwardk> there are 2 notions of fixed point that matter. Mu and Nu, Mu is stuff you can deconstruct because its finite basically, Nu is stuff you construct but have no knowledge it is finite so you work coinductively
23:14:07 <edwardk> :t unfoldr uncons
23:14:09 <lambdabot> Cons b b a a => b -> [a]
23:14:20 <edwardk> :t unfoldr
23:14:21 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:14:30 <int3__> what is plain Fix then?
23:14:36 <edwardk> nothing says that the list output by unfoldr will be finite. you may keep returning Just's
23:14:45 <edwardk> well, in haskell it turns out that Mu = Nu
23:14:52 <edwardk> in other languages you have to maintain the distinction
23:14:54 <angerman> So, the type Int -> Int, which I think is equivalent to ((->) Int Int), describes functions that take an Int to an Int. What does ((->) Int) do? It's a partialy applied type. But it's not the same as ((->) Int a). Does it say "functions from Int"?
23:15:06 <joelteon> yes
23:15:08 <int3__> ah, so I can just use Fix and all the stuff in that library will work?
23:15:12 <edwardk> eah
23:15:14 <edwardk> er yeah
23:15:15 <ReinH> angerman: it is a partially applied type, yes
23:15:27 <edwardk> if you ever work with 'invariant functors or something you'd need to switch to caring
23:15:28 <ReinH> ((->) Int) is a type constructor of kind * -> *
23:15:37 <ReinH> it is a partially applied (->)
23:15:40 <ReinH> :k (->)
23:15:41 <lambdabot> * -> * -> *
23:15:47 <joelteon> what do you call a partially applied kind?
23:15:48 <edwardk> and some times you want to use the Mu or Nu approach for efficiency reasons
23:15:54 <edwardk> but usually you don't care
23:15:54 <ReinH> joelteon: a kind :p
23:16:00 <joelteon> damn it
23:16:09 <edwardk> they exist because they should, not because they are necessary ;)
23:16:16 <int3__> haha okay
23:16:20 <int3__> thanks!
23:16:29 <ReinH> joelteon: :p
23:16:34 <edwardk> anyways if you look at cata in terms of Mu it is basically vacuous
23:17:09 <angerman> ReinH: thanks. type constructor, that's what I was looking for :)
23:17:29 <ReinH> angerman: I figured one of those things I said would work ;)
23:17:40 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a  -- flipped is Functor f => Mu f -> (f a -> a) -> a -- but that is just the definition of runMu or whatever!
23:17:53 <edwardk> its defining Mu in terms of the fact that you can fold it with a catamoprhism
23:17:59 <edwardk> Nu is defined similarly vacuously
23:18:28 <int3__> I think I see, yes
23:18:34 <edwardk> I write down the universal property as the definitions
23:18:38 <edwardk> Fix is more subtle you have to know the deep abiding connection between Mu and Nu, it is an accidental correspondence that makes them the same in haskell, etc.
23:19:05 <edwardk> writing cata for Fix is more work
23:20:37 <angerman> ReinH, I'll need to think about this some more to make the transition more clear for me :)
