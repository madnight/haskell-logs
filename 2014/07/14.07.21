00:00:01 <edwardk> there
00:00:10 <pingu> this, seems obvious now, given that I watched the beginning of one of your lens talks
00:00:24 <edwardk> you can use mapMOf   or just use the lens directly, the latter is better at 'applicative effects. mapMOf works when there is no applicative for your monads
00:00:50 <pingu> there's something kind of neat about just using the lens itself, I think.
00:00:58 <edwardk> yeah
00:01:10 <edwardk> it reinforces the fact that these are just combinators like traverse
00:07:49 * hackagebot hsnsq 0.1.1.0 - Haskell NSQ client.  http://hackage.haskell.org/package/hsnsq-0.1.1.0 (PaulBerens)
00:07:49 * hackagebot trifecta 1.4.3 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4.3 (EdwardKmett)
00:23:22 <frerich> Even though my humble first proposal to libraries@ about adding an 'equating' function received only very little support, I'm very positively surprised by how the proposals are discussed and about how people rarely (never?) repeat arguments. A very considerate atmosphere and a positive experience overall. :-)
00:24:18 <basdirks> Is there a good alternative to the time library?
00:34:12 <solidus-river>  /ws 7
00:50:54 <Guest______> Hey, at what point were you guys going to stop brigading reddit?
00:51:26 <mmmm> What are you talking about
00:51:59 <frerich> Guest______ : What is "brigading"?
00:55:59 <lithiumdeuteride> sounds like some kind of military maneuver
00:56:27 <Guest______> It's where you link a reddit submission so you can shitpost in it.
00:56:40 <Guest______> See: Peaker, kqr, tomejagu1r
00:56:44 <Guest______> + more
00:57:13 <ReinH> Starting out with a classic loaded question. Let's see how it goes from here.
00:58:17 <omario> klk
00:59:18 <kqr> Guest______, do you want a friendly, level-headed discussion or do you want to assign blame?
00:59:25 <kqr> Guest______, if the latter, you're in the wrong place
00:59:52 <Guest______> I want to be able to have a discussion on the pros and cons of Haskell on reddit without it being obviously shit all over by #haskell
01:00:29 <glguy> Is there a pro con post on Reddit now?
01:00:45 <kqr> Guest______, can you reference which of my comments you feel like "shit all over" you?
01:01:05 <kqr> Guest______, i'm terribly sorry if you've got that impression because it was far from my intent
01:01:38 <kqr> glguy, nah, there was a blogpost about iorefs
01:02:00 <kqr> glguy, which some people seem to think in combination with unsafePerformIO means the entire IO subsystem is rendered useless
01:02:13 <kqr> because it is, after you account for cultural reasons, easy to circumvent
01:02:53 <Guest______> kqr: Actually, you were probably the best of the bunch. I don't think I ever replied to you because I got sick of saying the same thing 5 times in 5 different threads.
01:03:16 <glguy> You can
01:03:42 <dolio> Is this now a forum for complaining about reddit?
01:03:45 <glguy> That's what I was about to suggest
01:08:59 <Opux> kqr: Also, my intent was never to say "the existence of unsafePerfomIO made IO useless". Someone said that variables are always immutable, I pointed out performUnsafeIO and followed it up with "I live haskell, but it's big win is the type system and not its purity".
01:09:06 <Opux> Apparently that is a cardinal sin.
01:09:14 <Opux> love*
01:10:24 <ReinH> I think a lot of haskellers would disagree with that statement
01:10:37 <ReinH> I hope they would do so civilly
01:11:23 <dfeuer> Dang, Bob Gibson was good.
01:12:29 <kqr> Opux, well the idea is that you don't have to use unsafePerformIO, and if you don't, you reap all the benefits of the type system
01:12:49 <Cale> Opux: The purity makes the type system meaningful
01:12:50 <kvanb> I can't wait for that cabal change
01:12:53 <kqr> Opux, if you can't trust the library maintainers to use it responsibly (i.e. only for performance optimisations that do not break anything) then simply don't use their libraries
01:12:56 <kvanb> that lets you install multiple versions of packages
01:13:07 <kvanb> rid of transformers hell, here we gooo
01:13:42 <Opux> ReinH: I think the purity of Haskell is great in theory, but it doesn't translate well to computer architecture and most arguments for this being ok revolve around having a "sufficiently smart compiler", which is where I just tune out.
01:14:27 <ReinH> Opux: and I respectfully disagree
01:14:41 <dfeuer> Opux, it's very easy to shoot yourself in the head with unsafePerformIO, and hard to do very many things with it *without* shooting yourself in the foot.
01:15:16 <dfeuer> I believe very few libraries even touch it.
01:15:35 <Opux> Cale: Then why do so many libraries feel the need to make use of performUnsafeIO? Shouldn't this signify there is room for improvement?
01:15:50 <kqr> dfeuer, mostly the low-level performance oriented ones from what i've experienced (can't remember any particular examples, but think bytestring, vector and so on)
01:15:56 <kvanb> Opux: there are suffeciently smart compilers
01:15:59 <kvanb> i.e. jhc
01:16:03 <Cale> Opux: I can count the number of times I've actually needed unsafePerformIO on one hand, and I've been programming in Haskell for about 12 years
01:16:05 <kvanb> or the uhc supercompiler
01:16:12 <ReinH> If anyone is claiming that there is no room for improvement in Haskell they should stop.
01:16:16 <mbrock> I just grepped through our whole server code base at Silk; there is *one* use of unsafePerformIO, and that's only to create a new IORef
01:16:18 <Cale> Opux: Not many libraries actually need it
01:16:29 <kvanb> ReinH: like?
01:16:39 <kvanb> I like Haskell where it's at right now.
01:16:42 <ReinH> Opux: the record system, for one
01:16:45 <Opux> ReinH: I'm glad to hear it from someone, as it seems like a lot of people treat haskell like a religion instead of a programming language.
01:16:46 <kvanb> simple enough to grasp after a year of painful learning
01:17:03 <ReinH> plenty of places to improve Haskell and GHC
01:17:07 <kvanb> but complex enough to make me hate my day job
01:17:08 <kqr> Opux, do you have a specific example of someone in that discussion claiming haskell can't be improved?
01:17:26 <levi> "simple enough to grasp after a year of painful learning" doesn't exactly sound like a ringing endorsement.
01:17:43 <kqr> levi, nothing worth having comes easy or whatever they say
01:17:44 <kvanb> levi: I'm pretty sure theres a curve
01:17:45 <ReinH> Cabal is frankly a bit of a mess, but there are some improvements in the pipeline that are exciting
01:17:56 <dfeuer> kvanb, I read "whole program analysis" on the wiki page on jhc and pretty much tuned out....
01:18:13 <Opux> kqr: Specific example? No. But you get the feeling that they've drank the kool-aid when you hear the same stuff over and over.
01:18:14 <kvanb> dfeuer: idris does whole program compilation too
01:18:18 <Cale> I want proper dependent types in a lazy-by-default setting
01:18:21 <kvanb> people don't make a big deal about it over there
01:18:50 <dfeuer> kvanb, how do they handle compilation time?
01:18:54 <levi> Learning curves are inevitable, but a year of "painful learning" might point to an area for possible improvement.
01:19:00 <kvanb> dfeuer: it's not that bad
01:19:04 <kqr> Opux, the people who were most vehement, from what i could see, are fairly well-known names in the community and they usually have rational opinions, so I think you might be reading more into it than there is
01:19:10 <kvanb> I don't know how idris does it, but jhc keeps caches
01:19:21 <kvanb> of modules after parsing/first pass optimisations and stuf
01:19:23 <kqr> Opux, the people who disagree with you in text are probably not the same people who downvote you either
01:19:39 <johnw> Cale: me too
01:19:42 <johnw> Cale: I really wish Idris had gone that route
01:19:52 <kqr> Opux, if someone takes the time to write out an explicit response, they usually think your opinion is valuable enough to not get buried
01:19:56 <kqr> Opux, just so you don't confuse the two
01:20:13 <Opux> kqr: True, but it was a completely empty thread with one perfectly fine thread between me and tomejagu1r, and then about 2 hours in it exploded.
01:20:14 <kvanb> johnw: theres this ticket I posted on the trac about an optimisation
01:20:26 <Opux> kqr: So you can understand why I'd be frustrated.
01:20:37 <kvanb> and someone brought up a thought that the type systme could be extended so that types scrutinised by cases
01:20:58 <kqr> Opux, sure, i understand your frustration and i think the whole downvoting thing is a bad idea in fora where you are supposed to be able to have civil discussion
01:20:59 <kvanb> could have generic type parameters by alpha equivalence
01:21:21 <kqr> Opux, but you don't make the best impression when your reaction is to come here and accuse 1300 people of brigading
01:21:24 <kvanb> then you could have declarative types using BlankDataDecls and sum types!
01:21:41 <kvanb> sorry, dependant
01:21:57 <Cale> Opux: Anyway, there are legitimate uses for unsafePerformIO, but they're pretty few and far between, and really they're all either stuff dealing with FFI (constructing pure interfaces to otherwise impure foreign libraries), or stuff which you'd otherwise have to extend the compiler to do. Both of those are situations which need to be handled with a lot of care.
01:22:06 <Cale> and they're not things which come up every day either
01:22:45 <ReinH> There seems to be this idea the unsafePerformIO infects the rest of Haskell with its lack of referential transparency
01:23:26 <Cale> Yeah, there's that too -- if you're using unsafePerformIO *properly*, then nobody who is importing your module should actually be able to tell for certain that you're using it.
01:23:38 <Opux> kqr: It was obvious the discussion was posted here. It wasn't an accusation to the channel in general, just to whomever decides that "hey, there is a conversation going on I don't like, let's ruin it!" is a good idea.
01:23:39 <kvanb> consider: Foo a b = Bar a | Qux b in case (Bar 3 :: Foo Int Int) of { x -> ... } . Here x can have type "Foo Int a" if you're clever enough
01:23:39 <ReinH> Maybe people think that it means that Haskell is broken in the same way that Russel's Paradox broke naive set theory. I don't know.
01:24:16 <kvanb> then you can actually use void types to do some really clever things that require you to scrutinise types before you pass them to functions
01:24:24 <kvanb> which I think is akin to dependent types a little bit?
01:24:27 <ReinH> Opux: I have to protest just a bit. This is an accusation to the channel in general: 12:50 AM <Guest______> Hey, at what point were you guys going to stop brigading reddit?
01:24:27 <dfeuer> Because just about any time unsafePerformIO gets "exposed", codes tends not just to break but to break extremely badly and unpredictably.
01:24:36 <ReinH> It's pretty hard to read it as anything else
01:24:48 <Cale> ReinH: Haskell actually is broken in *that* way
01:24:49 <levi> Opux: I don't recall seeing any link to the discussion here. Did you find it in the channel logs?
01:25:04 <Opux> ReinH: It's not that it "breaks Haskell", it just seems silly to tout purity as one of Haskell's best feature, but break it so often in widely used libraries.
01:25:08 <ReinH> They're available online, the link is in the /topic, and they are searchable
01:25:10 <Cale> But so is pretty much everything else except for Agda and Coq and a few other proof assistants :)
01:25:26 <ReinH> Opux: You've said that twice but haven't presented any evidence yet.
01:25:39 <ReinH> Which widely used libraries often use unsafePerformIO?
01:25:51 <Cale> I guess there's ByteString
01:25:52 <kvanb> I can't really think of that many
01:26:05 <kvanb> Cale: that's only to call malloc though
01:26:07 <jle`> ByteString has a pure interface, though...so it doesn't really use unsafePerformIO to circumvent purity, right?
01:26:08 <kvanb> or something, isn't it?
01:26:11 <kvanb> and do pointer stuff.
01:26:13 <Cale> ByteString is one of those things which would be built-in by now if it weren't using unsafePerformIO
01:26:23 <dfeuer> There are probably some more that use unsafeInterleaveIO.
01:26:28 <ReinH> And, more specifically, which of them do it a) without showing the correctness of doing so or b) without using it to interact with non-Haskell code via FFI?
01:26:29 <Cale> i.e. this is a "modify the compiler" sort of thing
01:26:34 <glguy> The channel is logged, and it isn't common that someone would post a reddit link here for some "shitposting" actually. Those users just check reddit religiously :)
01:26:47 <kqr> Opux, for the record, i can't find any mention of that discussion here
01:27:03 <Cale> jle`: right, it does
01:27:15 <ReinH> It's interesting to me that the users mentioned are a few of the only users I've seen that are both regular #haskell users and regular reddit users.
01:27:25 <Cale> jle`: Whether it's using it to circumvent purity I suppose depends on what you mean by that
01:27:31 <dfeuer> Cale, what do you mean by "built in" and why does using unsafePerformIO preclude that?
01:27:34 <jle`> ...i don't know of any libraries that use unsafePerformIO to circumvent purity. and I can't name any unsafePerformIO usages that aren't used for FFI purposes
01:27:46 <jle`> Cale: the API/interface it offers is pure, is what i mean
01:27:55 <jle`> at the high level
01:27:56 <levi> Opux: There's a difference between "observable side effects" and "benign side effects".  There shouldn't be any use of unsafePerformIO that takes an *observably* impure action.
01:27:57 <Cale> dfeuer: I mean that GHC would have special primitive support for ByteStrings if unsafePerformIO didn't exist
01:28:52 <Cale> The only reason it doesn't is because unsafePerformIO allowed that low-level hackery to be done as a library
01:29:00 <dfeuer> levi, there are some such in base, but I don't know if there are others. As I said earlier, though, unsafeInterleaveIO and unsafeInterleaveST probably show up a bit more.
01:29:22 <jle`> doesn't array use unsafePerformIO ?  but again, it offers a pure high level interface/api...and presumably no user would be able to call any functions that aren't referentially transparent or pure in a same-answer-same-result sense
01:29:35 <ReinH> Cale: you can get a lot done with naive set theory as long as you don't try to construct the set of all sets that are not members of themselves ;)
01:29:38 <mbrock> purity in Haskell is still an extremely important concept, and indeed a major win, despite the very occasional necessity for locally impure code in low-level libraries
01:29:57 <levi> Opux: Purity in Haskell actually *does* enable some advanced optimizations, implemented now in GHC, that are not generally available in languages like Standard ML that are not so dedicated to purity.
01:30:25 <Cale> Yeah, and ironically enough, one of the biggest users of that is the ByteString library as well :D
01:30:30 <dfeuer> Yes. Functions that start with the word "unsafe" usually mean "the proof obligation for this code isn't just necessary to prevent incorrect results, but to prevent crashes and other horribleness."
01:30:35 <ReinH> Cale: heh
01:30:49 <dfeuer> Unfortunately, some functions called "unsafe" are much less unsafe than that, so it's confusing.
01:30:59 <Opux> ReinH: I was going to point to ByteString. levi, kqr: If it wasn't posted here I apologize, I wasn't aware of the logs and when 4+ people who entered a conversation at around the same time were also on this channel... well you can see how one can jump to conclusions.
01:31:05 <ReinH> dfeuer: what about the ones that are called reallyUnsafe?
01:31:10 <ReinH> Opux: Ok, that's one.
01:31:25 <kqr> Opux, probably just a time zone waking up. no worries :)
01:31:44 <Cale> The stream fusion rewriting that it does likely wouldn't work correctly if it were observably breaking purity
01:31:47 <dfeuer> (unsafeShiftR is an example of one that's actually not unsafe, but just incompletely specified)
01:31:48 <ReinH> One library is not exactly "so many libraries".
01:31:58 <jle`> what about what about the ones prefixed accursedUnutterable
01:32:23 <Opux> ReinH: There are more, I was just pointing towards a widely used on I could remember the name of.
01:32:27 <Opux> one*
01:32:30 <dfeuer> :D
01:32:48 <ReinH> Opux: there probably aren't as many people seem to think
01:33:04 <dfeuer> Opux, Cale's point is that you can think of those few libraries as "compiler plugins" or something.
01:33:17 <ReinH> unsafePerformIO is usually used for FFI, when the alternative would just be *not* interfacing with that function at all.
01:34:10 <ReinH> And if the argument is that Haskell developers in practice can't make use of purity to reason about or have the compiler optimize their programs, that's pretty clearly untrue.
01:34:30 <ReinH> And I think that last is what most of us actually care about.
01:34:35 <mbrock> indeed
01:34:41 <Cale> Right, any code which is merely *using* ByteString doesn't have to care that there are occurrences of unsafePerformIO in there
01:35:01 <Cale> The library behaves the same way as if ByteStrings were implemented by lists of Word8
01:35:14 <Cale> (but performs better)
01:36:19 <levi> Opux: While it's true that at some level all programs are going to have to "get dirty" and modify state, Haskell's approach to purity has real, observable benefits. There are a few drawbacks as well, but we like to call them "active research areas" ;)
01:36:29 <Opux> ReinH: I'm not saying it's impossible, I just don't think it's worth the hassle for industry. You also touch on another point, which is how lazy evaluation makes it hard to reason about time/space requirements, but I'm not going to touch that in this channel with a 10' pole.
01:36:53 <ReinH> Opux: that what isn't impossible, and what hassle are you referring to?
01:36:54 <Cale> Lazy evaluation makes it *different* to reason about time/space requirements
01:37:27 <Cale> But those differences are possible to get used to. You don't start out programming efficiently in strict languages either, you learn how to do it well through years of experience.
01:37:38 <jle`> Opux: you seem to want to give us not much of a chance to prove we are civil :)
01:38:05 <Cale> Lazy evaluation actually makes it easier to write efficient programs a lot of the time.
01:38:21 <Cale> Or it makes the efficient programs easier to write, at least :D
01:38:39 <Opux> ReinH: Haskell's purity makes it hard to use in practice because you need to work with impure code in all parts of an applicatin stack. So if you want to use Haskell you either do the whole thing in Haskell, and reinvent large parts of the wheel, or you go through the hassle of getting Haskell to interface with everything else.
01:38:51 <ReinH> Opux: your premise is not true.
01:39:03 <Cale> Opux: Yeah, I don't see why you think that's the case.
01:39:14 <kqr> Opux, when you get more experience with haskell, you see more and more ways to factor the impurity out and get a cleaner design as a result
01:39:27 <Cale> It's usually possible to make *most* of a program pure. Only code which is actually doing I/O should typically have effects.
01:39:35 <kqr> Opux, it's true that when people start out with haskell coming from imperative languages, one of their big stumbling blocks is that they want impure code everywhere
01:39:52 <kqr> Opux, but you learn with time that that's not actually required (or even preferably)
01:39:52 <Opux> kqr: I have about... 6ish years of experience with Haskell. Not a ton, but enough to be out of the rose tinted goggles stage. ;)
01:39:56 <levi> Cale: To be honest about it, Lazy evaluation does make it *harder* as well as different. There have been highly formalized models for the space/time cost of strict operational semantics in functional languages for many years, and with lazy models it's still at the level of general rules of thumb, unless I've missed some recent publications.
01:40:05 <Cale> If you're familiar with model/view/controller, the "model" is the pure part, and well designed code will make that part as large as possible, and keep the "view" and "controller" small.
01:40:31 <ReinH> Opux: I don't understand this "do the whole thing in Haskell" argument. Are you regularly seeing other languages that borrow critical components from completely different languages?
01:40:32 <kqr> Opux, oh. interesting that our experiences diverge then
01:40:44 <ReinH> Or does each language implement its own socket handling, its own HTTP parsing, its own etc?
01:42:00 <ReinH> If languages are borrowing so much from other languages, wouldn't you prefer to do it in a language that forces you to think about the correctness of your interactions with foreign functions?
01:42:17 <Cale> levi: Maybe formally there are some edge cases which make things far more difficult. Informally, at least in my experience, I don't think you often run into cases where it's so difficult to figure out performance. Of course, in big complicated programs where lots of things have smallish costs, it can be tricky to figure out which things to focus on, but that's true in any language.
01:42:19 <Opux> ReinH: No, I'm saying the startup cost compared to other languages that don't care about purity is too large.
01:42:27 <frerich> Opux: In my experience, it actually turns out that you don't "need to work with impure code in all parts of an application stack.". You can certainly write Haskell programs that way, but you really do yourself a favor if you manage to factor your code such that code doing IO is separated from code processing data, the latter being 'pure fucntions'. In fact, the same design is also a good idea in other languages
01:42:27 <frerich>  (say: C) since pure functions have a lot of nice properties such as being easily testable.
01:42:29 <ReinH> Why is a language that is mostly pure worse than a language that has no concept of purity?
01:42:37 <ReinH> Opux: what startup cost?
01:42:43 <mmmm> Anyone previously used the HoleyMonoids package?
01:42:51 <ReinH> Ok, so you think that Haskell imposes some cost or "hassle" that other languages don't
01:42:57 <ReinH> I'd be interested to know what these are.
01:43:16 * mbrock usually stays away from arguments made with casual reference to "the industry"
01:43:21 <Cale> Well, it kind of does, if you're assuming that people already know some languages which are very different from Haskell.
01:43:39 <Cale> I don't think that Haskell it any harder to learn in absolute terms than Python.
01:43:43 <Cale> is*
01:44:01 <Cale> It's about 5 to 10 times simpler than C++ depending on how you measure :)
01:44:09 <ReinH> I can think of a few costs or hassles involved with Haskell. I'm interested to know what Opux means specifically.
01:44:29 <Iceland_jack> Cale: Learning C++ is 1003 milliC++s of difficulty
01:44:30 <splintax> i think haskell is harder to learn than python if you're writing glue code (ie. consume this JSON API, use it to send a request to another JSON API)
01:44:48 <Opux> ReinH: Making everything conform to Haskell's type-system, notion of purity, and lazy execution semantics.
01:45:10 <splintax> which is pretty common for "my first project in <new language">
01:45:11 <ReinH> Opux: I can't distinguish that from "writing Haskell code that compiles".
01:45:21 <Cale> splintax: Well, I'm talking about as a first programming language
01:45:30 <levi> Cale: I agree that it's not a damning problem by any means, and strict languages have their own problems. But I think reasoning about time/space usage is definitely an area where strictly evaluated languages have an advantage at present.
01:46:00 <Cale> levi: It would certainly be nice to have better *formal* tools there.
01:46:42 <kqr> splintax, i think that is mostly because a lot of the teaching material sucks
01:46:56 <ReinH> Opux: I would say that all three of the things you just mentioned are areas where Haskell has significant advantages over most languages
01:46:59 <kqr> splintax, with python, you have books and introduction material going through exactly those kinds of problems
01:47:12 <splintax> i "learned" haskell as a first programming language at university (aside from some really awful PHP i wrote in high school) and it was great, but we basically just wrote pure functions in hugs
01:47:40 <kqr> splintax, with haskell, the introductory books are further removed from the real world (with the obvious exception of RWH, which is targeted at a slightly higher level of study, from what i've been able to tell)
01:47:54 <splintax> once i started trying to solve my own problems with it (which invariably were almost entirely about IO, and didn't actually involve non-trivial computations), i found myself completely out of my depth
01:47:56 <ReinH> kqr: (although RWH has its own issues)
01:48:03 <Opux> ReinH: Which is a great buzzy thing to say, and I've heard it a ton. But to say that Haskell using those 3 things are all no-brainers instead of being a bunch of trade-offs is disingenuous.
01:48:12 <Cale> splintax: Yeah, the university courses sometimes have a bit of a funny way of missing out all the practical stuff.
01:48:16 <kqr> ReinH, as does anything. were you thinking of something specifically that affects my point?
01:48:23 <ReinH> Opux: no one here has said that
01:48:35 <splintax> Cale: i guess because they also thought IO = monads = too hard for first-years
01:48:38 <Cale> splintax: IO isn't that hard to learn either, if you have someone teaching it properly :D
01:48:54 <Opux> ReinH: Your last statement sure implied it.
01:49:01 <ReinH> Opux: it sure did not.
01:49:11 <glguy> It takes some time for some people to transition from "the types are stopping me from doing what I want to do" to "the types infer to reflect what I want to do"
01:49:19 <ReinH> Saying that something has advantages does not imply that it has no disadvantages
01:49:44 <mbrock> programming well is difficult, teaching programming is difficult, Haskell is difficult, everything worth doing is difficult
01:49:56 <johnw> glguy: it took me a while to realize that the types were telling me that I didn't fully understand what I was trying to do :)
01:50:11 <ReinH> kqr: your point stands, but I don't think RWH is a very good way to learn Haskell today.
01:50:12 <johnw> now I "converse with the types" to help explore design ideas
01:50:20 <kqr> ReinH, sure. we agree
01:50:59 <Cale> Well, difficulty is all relative
01:51:11 <kqr> johnw, I was lucky enough to realise early on that if I start with type signatures, I can have the compiler tell me what I'm trying to do instead of having to understand it on my own :)
01:51:30 <Cale> I've taught Haskell to some people for whom it was their first language, and IO was never really too much of an issue.
01:51:34 <ReinH> Opux: what my statement did imply is that I think the trade-offs work out in Haskell's favor.
01:51:35 <johnw> I was fortunate enough to be told to always write type signatures for everything early on
01:51:41 <frerich> johnw: I concur, I often find that when a program doesn't type-check, I go "What the... hmm... I guess that case can happen, how to handle this?... why is this state even possible at all?" e.g. with inexhaustive pattern matches or similiar. :-)
01:51:55 <hipsterslapfight> ReinH: what would you say *is* a good way to learn Haskell today?
01:52:01 <kqr> Cale, out of curiosity, did you use do sugar or operators?
01:52:08 <ReinH> hipsterslapfight: We've got a bit of a problem there tbqh.
01:52:18 <hipsterslapfight> oh :(
01:52:23 <levi> I enjoy the fact that I can use types I'm fairly sure about to help me get the right code, and also use code I'm fairly sure about to help me figure out the right types.
01:52:40 <Cale> kqr: Both, but I tend to start out with do-notation, and eventually bring up how things generalise and desugar
01:52:47 <kqr> Cale, cool
01:52:49 <ReinH> LYAH is too shallow, Bird and Hutton are too old and not focused on practical use
01:52:57 <dfeuer> Cale, C++ is only hard if you want your code to work correctly. If you just want it to compile and run, you can probably make *something* stick to the wall.
01:53:07 <kqr> lyah is also too removed from what an actual program is like
01:53:16 <kqr> you can't stick around in the interpreter forever
01:53:24 <ReinH> byorgey's course notes are good bud too difficult for self-study
01:53:29 <ReinH> *but
01:53:41 <hipsterslapfight> I'm on LYAH right now, trying to figure where I go after here
01:53:49 <Cale> dfeuer: Well, sure, but that's really not saying a whole lot :D
01:54:12 <ReinH> hipsterslapfight: exactly
01:54:25 <mbrock> I've heard good things about "Beginning Haskell: A Project-Based Approach"
01:54:36 <kqr> me too, but it's not cheap :(
01:54:40 <Cale> dfeuer: I mean, if you want to really understand the language to the point of not being surprised by the behaviour of other people's code which might use little language lawyery details of the specification, how much effort is it?
01:54:40 <ReinH> mbrock: I wasn't impressed
01:54:48 <Opux> ReinH: I guess we disagree on that count, then. :)
01:54:51 <ReinH> The "project-based approach" seemed like it was bolted on as an after-thought
01:55:01 <ReinH> Opux: I'd be surprised if we agreed on everything
01:55:14 <MP2E> Cale : after 6 years of playing with C++, I *still* often find code in other people's projects that surprise me
01:55:21 <MP2E> "How does this even work?" moments still occur :P
01:55:42 <isomorpheous> MP2E: What are we talking about?
01:55:45 <Cale> I feel like if all the C++ compilers and specifications disappeared from the world, nobody exists who could actually reproduce the C++ spec.
01:56:39 <johnw> Cale: that is completely true
01:56:47 <frerich> Maybe you could derive a "simplified C++" though, which might be a good thing. Or you end up with a bastardized language incorporating all the proprietary extensions under the sun.
01:56:48 <MP2E> isomorpheous: : well the discussion is on good ways to learn Haskell as a beginner, but we got kinda sidetracked with a comparison to C++
01:56:48 <ReinH> Cale: I could point out that one of the authors of the ANSI C spec called the C type system "corrupt". ;)
01:57:03 <johnw> I know world experts in C++ who have admitted to me that they only really know the chapters of the standard that they implemented themselves; they defer to other experts for other chapters
01:57:37 <isomorpheous> One can draw a number of parallels between C++ standards and ordinary Perl scripts
01:57:40 <johnw> C doesn't have a type system; it has a cast motivation system
01:57:42 <alpounet> johnw: i've heard the very same thing, and not sure we know the same people
01:57:50 <alpounet> that's really not a coincidence :p
01:57:52 <ReinH> johnw: not disagreeing
01:58:12 <MP2E> cast motivation system haha
01:58:32 <mbrock> Opux: talking about how Haskell doesn't "work in the real world" or isn't "suitable for industry," and such things, seems to discount the actual experience of people who happily do use Haskell -- it's like talking to a group of cyclists saying "sorry, I disagree with your enthusiasm, bikes don't work in the real world"
01:58:33 <levi> That's fairly common in the world of specifications and standards bodies though, I think.
01:59:10 <johnw> Opux: having used Haskell successfully in industry, I can tell you that there are people who have used Haskell successfully in industry :)
01:59:38 <Opux> ReinH: If you actually want to enforce some level of purity, I think an imperative language with an effect system would find greater acceptance than using monads in haskell to do something equivalent.
01:59:54 <Cale> Opux: Then go write it
01:59:56 <dfeuer> Cale, I was kidding. I attempted to learn C++ when I was in middle school or high school or something, reading a Borland C++ manual. It was completely impossible nonsense. C, however, was K&R goodness, and then some less-pleasant but decently readable Advanced Programming in the UNIX Environment.
01:59:56 <MP2E> greater acceptance is not a goal of Haskell though
02:00:18 <johnw> dfeuer: which version of Borland C++?
02:00:28 <MP2E> Haskell is often cited as "avoiding success at all costs" and this is because Haskell does not make decisions based on popularity
02:00:31 <MP2E> this is a great thing
02:00:42 <MP2E> if it started making decisions to be popular, I think a lot of us would have to find another language :P
02:00:52 <johnw> Haskell even goes so far as the promote a hair-shirt philosophy, much to its credit I feel
02:01:00 <levi> The point of Haskell is to be Haskell. If industry finds it useful, great!  If not, then maybe it'll give them some ideas for a language more suited to their purposes.
02:01:17 <kqr> dfeuer, not to pretend c++ isn't a mess, but saying C is easy to learn is kind of cheating. yes, the C standard is small, but that's in part because a lot of operations are marked as "undefined behaviour"
02:01:19 <alpounet> industry finds it more and more useful every year
02:01:20 <splintax> Opux: you seem to be describing Rust
02:01:22 <dfeuer> johnw, an old one :P
02:01:26 <b_jonas> what? "hair-shirt"?
02:01:37 <Opux> splintax: Rust doesn't have an effect system to my knowledge.
02:01:39 <kqr> dfeuer, if you took the standard for any language and cut out pieces of it at random and replaced it with "undefined behaviour" then sure, they'd be "easy" to learn too
02:01:41 <johnw> b_jonas: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
02:01:42 <MP2E> kqr : A fun experiment would be to figure out how many C source files depend on undefined behavior
02:01:46 <MP2E> My guess? almost all of them
02:01:59 <kqr> MP2E, i think that'd be more depressing than fun tbh :(
02:02:04 <MP2E> true
02:02:05 <MP2E> heh
02:02:05 <Cale> Yeah, all my jobs lately have been Haskell jobs, but I don't even really care if Haskell finds industry success or not. Part of me wants it not to get too much success too quickly, because that's how languages die in the sense of not changing any longer.
02:02:11 <johnw> where is merijn
02:02:16 <johnw> he has a great C puzzler for everybody
02:02:19 <dfeuer> kqr, well yeah. If you want something clean, use R6RS Scheme minus call/cc minus apply.
02:02:20 <splintax> Opux: right, i didn't appreciate that there is a distinction between an "effect system" and a method of isolating impure code
02:02:23 <johnw> *nobody* at OPLSS got it right
02:02:26 <Iceland_jack> b_jonas: It's used to refer to self-denial
02:02:41 <Cale> In fact, Haskell is the most practical language that I'd probably take a job working in right now :)
02:02:57 <dmwit> Should we expect OPLSS attendees more likely to be C experts for some reason?
02:03:00 <johnw> Cale: Haskell could also do a Python 2->3 type split, and not have to worry about users anymore
02:03:09 <Cale> Or the most popular anyway
02:03:24 <Opux> Cale: Why?
02:03:27 <johnw> dmwit: well, they tend to have experience with multiple languages; but that's just where he asked it
02:03:27 <dfeuer> Haskell might have to do that to fix the numerical tower.
02:03:44 <ReinH> Opux: If Hsakell doesn't enforce "some level of purity" to your satisfaction then probably no language that does anything other than heat up your server room can either.
02:03:57 <Cale> Opux: Because I don't want to put up with the headaches of programming in bad programming languages which ignore the last 30 years of research.
02:04:05 <MP2E> I think the issue is that Monads are being seen as a workaround to getting effects
02:04:13 <MP2E> Monads are themselves very powerful, and not really a workaround at all
02:04:18 <zipper> Would it be okay to delete my ~/.cabal and just start over?
02:04:18 <MP2E> parsers are a pretty good example of this
02:04:25 <Cale> (and at least for the time being, I have enough freedom to just decline stuff if it doesn't interest me)
02:04:27 <Opux> Cale: That seems unfair. Where is Haskells dependent types, for instance?
02:04:28 <isomorpheous> zipper: probably
02:04:36 <johnw> zipper: keep your .cabal/config
02:04:38 <kqr> b_jonas, a hair shirt is something that's uncomfortable to wear
02:04:41 <saep> zipper: also delete ~/.ghc
02:04:45 <dfeuer> It's so lovely in Java passing a data structure to a function and having no clue if it will make it out he other side in one piece.
02:04:46 <ReinH> Monads have nothing to do with impurity. There is no way to use the monad interface to do impure things.
02:04:49 <Cale> Opux: Oh, I'd happily take a job programming in a dependently typed programming language.
02:05:00 <kqr> b_jonas, in this case it's a joke referring to haskell programmers being able to take a certain amount of discomfort in order to reap the benefits it brings in the long run
02:05:02 <alpounet> dfeuer: well, re. numerical stuffs, I think it may be solved by some set of packages that agree on some reasonably designed interface, but IMO that won't become a part of base, that'll remain external to anything standard, because otherwise people will bikshed and disagree and it won't get merged into base or another of the "standard" packages
02:05:14 <ReinH> (that you can't do without the monad interface)
02:05:21 <alpounet> bikeshed*
02:05:36 <Cale> Opux: Most of those are not very far along yet when it comes to the existence of practical libraries
02:06:01 <johnw> Cale: have you seen Ulf's new stdlib for Agda he's started?
02:06:08 <ReinH> It's not really true that dependent types are strictly better than Haskell's types
02:06:34 <MP2E> Yeah if dependent types were strictly better, don't you think we would have them? :P They have some ... kinks to be worked out
02:06:40 <Cale> johnw: I haven't
02:06:45 <Cale> johnw: Is it cool?
02:06:59 <b_jonas> ah, thanks
02:07:02 <johnw> one sec, find you a link
02:07:02 <b_jonas> kqr: thanks
02:07:22 <Opux> ReinH: I was comparing it to none at all.
02:07:29 <frerich> johnw: Maybe you meant http://mauke.hopto.org/stuff/c/sizeof.c ?
02:07:37 <Opux> ReinH: Not saying that Haskell only has "a little" purity.
02:07:50 <johnw> Cale: https://github.com/UlfNorell/agda-prelude/tree/compat-2.4.0/src/Prelude
02:07:56 <gfixler> Anyone else having an exciting night of finally grokking what a functor is?
02:08:16 <johnw> gfixler: what grokkage did you come to?
02:08:28 <ReinH> Opux: so you're saying that Haskell doesn't have any purity? Or?
02:08:30 <Cale> Opux: Also, Haskell's type system is basically a research laboratory regarding the question of how close you can get to dependent typing without giving up solid type inference for programs that H-M can infer types for.
02:08:45 <gfixler> johnw: I'm a newb, so who knows if I'm actually even right (I think I am)
02:08:55 <kqr> gfixler, (i think that's why he asked ;) )
02:08:58 <gfixler> I didn't understand the f a -> f b part
02:09:08 <gfixler> it looked like function application, and was screwing me up
02:09:20 <Opux> ReinH: No. I'm saying that if you want provable purity in a language, you're likely better off with an effect system than using monads.
02:09:34 <Opux> Opux: But that's my opinion.
02:09:34 <ReinH> Opux: again, monads have nothing to do with purity
02:09:37 <johnw> gfixler: I'll just say that Functors aren't complex, but their interactions can be; it is a very deep and profound subject.  I think people stop paying attention to Functors much too quickly, thinking that monads are "where it's at"
02:09:38 <Opux> Er, ReinH
02:09:55 <Opux> ReinH: No, but monads can be used to model it.
02:09:59 <gfixler> johnw: yeah, I feel already like there's more hiding in there
02:10:30 <gfixler> I got 3/4 through LYAH chapter 7 and decided to start over
02:10:36 <gfixler> I'd read a lot and had some conversations in the meantime
02:10:45 <gfixler> amazing how much my brain glossed over the first time
02:10:52 <gfixler> it felt like someone added a bunch of new sentences to the chapter
02:10:55 <ReinH> If you want provable purity, you're better off removing things that, while extremely useful, break purity.
02:10:57 <johnw> edwardk does a very good job of exploring what Functors are capable of
02:11:39 <gfixler> of course, I'm still creeped out by typeclasses
02:11:56 <gfixler> I finally figured out what Just is - air
02:11:56 <johnw> gfixler: try writing a manual typeclass as a record type and passing around a "dictionary" yourself
02:12:01 <johnw> then typeclasses won't seem complex at all
02:12:04 <gfixler> :)
02:12:18 <ReinH> I'm not really sure how you go from "Purity is a problem in Haskell" to "Monads are a problem in Haskell". Is this the same argument?
02:12:23 <Iceland_jack> gfixler: You should get very used to them if you can, johnw's suggestion is good
02:12:37 <splintax> i still haven't been able to move beyond "typeclasses = interfaces"
02:12:39 <kqr> gfixler, do you know what fmap (+3) (Just 5) does? fmap (+3) [1, 2, 3]? fmap head getLine?
02:13:00 <merijn> splintax: Well, typeclasses are slightly different from interfaces in a few important ways
02:13:05 <johnw> merijn!
02:13:06 <gfixler> fmap (+3) (Just 5) == Just (5+3) no?
02:13:09 <johnw> what was that C question you asked us?
02:13:11 <kqr> gfixler, correct
02:13:23 <merijn> johnw: The sizeof one?
02:13:25 <gfixler> kqr: I was all set to get to the bottom of this Just thing
02:13:26 <johnw> yeah
02:13:29 <gfixler> and then it turned out that was the bottom
02:13:32 <johnw> I was telling people here about it
02:13:33 <gfixler> Just is 4 characters
02:13:39 <splintax> merijn: i'm aware that they are (or else they'd be called interfaces!), i just haven't grokked just how. yet.
02:13:43 <merijn> kqr: I think + is a bad example, since it doesn't change types
02:13:52 <ReinH> The "problem" with monads in Haskell is that they're a surprisingly simple concept with surprisingly complicated implications for structuring programs.
02:13:53 <Iceland_jack> > fmap show (Just 10)
02:13:55 <lambdabot>  Just "10"
02:14:02 <Opux> ReinH: Monads and effect systems are equivalent but different ways of doing the same thing. It was my opinion that an effect system in an imperative language is a better way to constrain impurity that using a monad in Haskell (IO).
02:14:06 <merijn> splintax: Well, a few simple examples!
02:14:07 <kqr> merijn, maybe
02:14:07 <gfixler> Iceland_jack: nice!
02:14:15 <gfixler> yeah, there are a lot of subtle things I'm going to be discovering now
02:14:22 <merijn> splintax: Consider "(==) :: Eq a => a -> a -> Bool"
02:14:33 <Iceland_jack> splintax: Not that people have any qualms about giving new names to something that already exists :)
02:14:44 <johnw> splintax: you _may_ find this interesting: http://tonymorris.github.io/blog/posts/type-classes-are-nothing-like-interfaces/
02:14:51 <merijn> splintax: Compare with "bool equals(Comparable a, Comparable b)" where comparable is an interface
02:15:14 <merijn> splintax: The former tells you much more (i.e. both operands must not only be comparable, but ALSO be the exact same type)
02:15:27 <gfixler> splintax: surpringly, the interfaces thing I do get, even though everything Java baffles and dazzles me
02:15:33 <merijn> splintax: The latter just tells you "two values that both happen to implement the comparable interface, but that's all we know"
02:15:38 <johnw> merijn: C puzzle!  C puzzle!
02:16:05 <orion> When I follow these instructions, http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ -- I get the following output when executing "yesod devel": "Exit code: ExitFailure 138" and GHC leaves a core dump. Does anyone know what could be going wrong?
02:16:25 <merijn> johnw: http://lpaste.net/107825
02:16:27 <orion> I am using GHC 7.6.3 on FreeBSD 10.0-RELEASE.
02:16:29 <ReinH> For example, people seem to think that monads are about "constraining impurity" ;)
02:16:32 <johnw> merijn: thx :)
02:16:36 <merijn> splintax: Make sense so far?
02:16:41 <splintax> merijn: isn't that a consequence of the type of (==), and not a property of the typeclass Eq?
02:16:53 <johnw> who here can tell what merijn's paste will do, without actually compiling and running it?
02:17:01 <merijn> splintax: A bit of both
02:17:08 <johnw> (even though this isn't really a Haskell question, so I'll take answers in #haskell-blah)
02:17:19 <merijn> splintax: Without typeclasses it's really hard to encode a type like that
02:17:26 <frerich> johnw: I suppose a better comparison would be to compare '(==)' with something like 'public static <T extends Comparable<T>> bool eq( T x, T y );'
02:17:59 <merijn> splintax: Furthermore, consider that typeclasses can be polymorphic in return values, not just arguments, i.e. "read :: Read a => String -> a"
02:18:05 <Opux> johnw: Looks like it's going to either print the char code for 'C' or 'E' depending on where you compile it.
02:18:15 <kqr> johnw, d = 65 or something?
02:18:25 <ReinH> And I suppose that's not a terrible way to think about monads, but I don't think it's strictly accurate either.
02:18:34 <frerich> johnw: I guess '1'
02:18:39 <merijn> splintax: (Or similarly, the notion that you have "polymorphic"/typeclass values like minBound and maxBound)
02:18:39 <merijn> :t minBound
02:18:40 <lambdabot> Bounded a => a
02:18:45 <merijn> > minBound :: Int
02:18:46 <ReinH> It's certainly similar to the way they were introduced
02:18:46 <lambdabot>  -9223372036854775808
02:18:46 <frerich> johnw: (the result of merijns program)
02:18:49 <johnw> frerich: based on what?
02:18:51 <merijn> > minBound :: Char
02:18:52 <lambdabot>  '\NUL'
02:18:54 <Opux> ReinH: I never said that is what they were for. I said that is what the can be used for. Big difference.
02:18:55 <kqr> johnw, i don't know because i'm not sure what sizeof returns
02:19:09 <kqr> johnw, but it's going to index into the alphabet string
02:19:13 <frerich> johnw: It's 'sizeof ((0)["ABC"..])'
02:19:13 <johnw> sizeof returns the size, in bytes, of the type, or type of the expression, it's given
02:19:17 <merijn> kqr, frerich: I suggest we take the C discussion to -blah :)
02:19:17 <ReinH> Opux: although I'd like to point out that the paper that introduces monads for structuring functional programs *begins* by discussing the tradeoffs of lazy vs strict and impure vs pure languages
02:19:18 <frerich> johnw: I.e. the sizeof a char
02:19:21 <johnw> frerich: good job
02:19:33 <kqr> frerich, oh wow
02:19:36 <kqr> frerich, should have known
02:19:39 <merijn> frerich: Oooh! You deserve a cookie and a "I know C" t-shirt :)
02:19:54 <ReinH> It says things like " Pure languages are easier to reason about and may benefit from lazy evaluation, while impure languages offer efficiency benefits and sometimes make possible a more compact mode of expression."
02:20:02 <frerich> Yay!
02:20:05 <ReinH> So Haskellers have a pretty rich tradition of appreciating the tradeoffs between these things
02:20:07 <merijn> frerich: For bonus points, is this implementation defined behaviour?
02:21:02 <johnw> good night all
02:21:33 <frerich> merijn: That's tough. I think '0["ABC"]' is indeed defined via communtativity of addition. I'm not sure about the type of 'sizeof' in C, if it's size_t then maybe you could venture into undefined-land by truncating size_t to int on some platforms?
02:21:48 <splintax> merijn: i'm still not 100% sure what's special about (==) :: Eq a => a -> a -> Bool, but the return type constraint is something cool that i didn't think of :)
02:22:29 <merijn> splintax: Also, once you consider (this requires a GHC extension, but still!) multi parameter typeclasses you get an even bigger difference
02:22:35 <splintax> actually, kind of makes sense now
02:23:37 <kqr> orion, there's a google groups thread thing with the same problem as you, have you checked that?
02:23:48 <merijn> splintax: Consider "class Convertible a b where convert :: a -> b", which lets you do things like "instance Convertible Int String where convert = show" and "instance Convertible Bool Int where convert False = 0; convert True = 1"
02:24:21 <merijn> splintax: Then you get a function "convert :: Convertible a b => a -> b"
02:24:55 <merijn> frerich: Naah, truncating coercion is fine
02:25:02 <ReinH> Opux: the good news, at least, is that if you'd prefer an imperative language with an effect system, Haskell is great at implementing imperative runtimes and effect systems can be transformed into monads, so you can do it in Haskell! ;)
02:26:38 <splintax> merijn: yeah, i see. i think i just need to write more haskell: i can see how various examples are difficult to translate into OOP, but i still have yet to actually solve a problem with typeclasses and think "i'm glad i didn't have to use interfaces for that" :P
02:26:48 <splintax> difficult/impossible
02:27:06 <merijn> splintax: I don't think that's a thought you are likely to have anyway
02:27:17 <ReinH> And, if nothing else, the ability to transpose effect systems into equivalent monads gives us another algebraic tool to *reason* about the behavior of effects systems ;)
02:27:58 <merijn> splintax: "Typeclasses aren't interfaces" is more of a warning to not mistakingly try to apply your experience with interfaces to typeclasses
02:28:26 <merijn> splintax: For example, defining a typeclass as interface for a record type is generally is bad plan
02:28:39 <frerich> splintax: IMHO, it's useful to become smart enough to grok typeclasses, and then become smart enough to realize that in the majority of cases where you think you need to write a typeclass, you actually don't.
02:28:54 <merijn> splintax: You'll see people who are designing a GUI framework defining a "Widget" typeclass for example, and that makes very little sense, imo
02:29:18 <frerich> Standard reading in this context: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:29:50 <int3___> is it a bad idea to fire up two 'cabal install's simultaneously?
02:29:50 <kqr> i still don't quite understand that article, but i have had bad experiences with writing a bunch of typeclasses needlessly
02:30:53 <gfixler> I just figured out what typeclasses are, so I'm primed and ready to abuse them now
02:31:00 <orion> kqr: https://groups.google.com/forum/#!search/exitfailure$20138$20haskell$20yesod/yesodweb/rlJdT8CfRrM/WkLIPrxgYfYJ <-- the workaround did not work for me.
02:31:03 <quchen> int3___: Maybe. Why don't you install both packages with the same cabal command? `cabal install pack1 pack2`
02:31:36 <int3___> quchen: yeah I suppose that's the right way to do it. was just curious :)
02:32:03 <quchen> I guess the answer is "find out only if you have to" ;-)
02:32:47 <Javran> is there a way to write predicates like `\x -> length x >= n` without using `length`? since sometimes I don't really care what exactly is `length x`
02:33:02 <kqr> orion, i don't know then, sorry
02:33:19 <quchen> :t null . take n -- Javran
02:33:20 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Expr’
02:33:20 <lambdabot>     In the first argument of ‘take’, namely ‘n’
02:33:20 <lambdabot>     In the second argument of ‘(.)’, namely ‘take n’
02:33:29 <quchen> :t \n -> null . take n -- Javran
02:33:30 <lambdabot> Int -> [a] -> Bool
02:33:47 <joshkirklin> If I have a quasiquoter like so: QuasiQuoter { quoteExp = \s -> [| words s |] }
02:33:54 <quchen> Or variations of that with drop, takeWhile, …
02:33:57 <Javran> quchen: cool! thanks
02:34:01 <joshkirklin> will the words s be evaluated at run time or compile time?
02:34:22 <quchen> Javran: The "drop" version will work particularly better when the list is infinite.
02:36:34 <Javran> quchen: comparing with what?
02:36:59 <merijn> joshkirklin: Compile time
02:37:15 <merijn> joshkirklin: Actually
02:37:52 <rio> int3___: i'd expect cabal to set a lock if there was a problem with doing that
02:38:07 <merijn> joshkirklin: AFAICT, this will at compile time take a string and produce a quasiquote for "words <that string>"
02:38:41 <int3___> rio: yes, I'd expect the same, but reasonable expectations aren't always met ;)
02:39:12 <joshkirklin> merijn, that's what I suspected. would I have to do something more like (but obviously not) QuasiQuoter { quoteExp = \s -> mapM (\w -> [| s |]) $ words s } for it to evaluate the words at compile time?
02:39:32 <rio> int3___: if it doesn't and you run into problems, you can file the most outrageful bugreport
02:39:46 <int3___> haha fair enough
02:40:37 <merijn> joshkirklin: Something along those lines, yeah. I'm not entirely at home with the way quasiquoters work yet, though
02:40:55 <joshkirklin> merijn, groovy, thanks
02:41:03 <merijn> joshkirklin: Easiest way would just be playing around for a bit and use the "dump splices" option to get GHC to output the code it produces after TH
02:41:19 <merijn> joshkirklin: Exact option name should be somewhere in the GHC manual
02:41:59 <joshkirklin> think I have it now actually
02:42:03 <joshkirklin> QuasiQuoter { quoteExp = \s -> (\ws -> [| ws |]) $ words s } seems to work
02:45:11 <orion> Why is it good practice to use Data.Text instead of String?
02:45:37 <grohne> is there a simple way to list all functions + all (inferred or explicit) type signatures in all modules of a cabal package?
02:46:09 <arancia> orion: Text stores the data more efficiently than String
02:46:10 <tdammers> orion: performance, mainly
02:46:12 <jle`> grohne: on ghci?
02:46:20 <jle`> grohne: haddock lists it, if you want an html
02:46:44 <bergmark> orion: it handles unicode better too
02:46:58 <grohne> jle`: I tried ghci, but I'd need to invoke for each module manually, no?
02:47:16 <grohne> jle`: in the end I want something machine-processable, so html shall do.
02:47:33 <jle`> grohne: if you go to a haddock index
02:47:41 <jle`> like http://hackage.haskell.org/package/pipes
02:47:51 <jle`> scroll down to past the "Modules" section
02:47:57 <jle`> you'll see a link [Index]
02:48:10 <jle`> it should list all functions and operators there
02:48:15 <jle`> oh, but it doesn't list the types
02:48:22 <jle`> boo
02:48:36 <grohne> well, that'll be a little scraping. doable.
02:49:22 <jle`> i don't think it would be too impractical for haddocks to do it
02:49:45 <jle`> but then again index might not be the place
02:50:00 <jle`> Fuuzetsu is our resident haddock maintainer if you want to ask him
02:50:42 <darthdeus> :t liftM
02:50:43 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:51:17 <darthdeus> guys why is ghc-mod sometimes showing GHC.Prim.Any as a type of something when I inspect the type?
02:52:38 <tdammers> bergmark: does it?
02:52:51 <jle`> orion: if you think about it a linked list of individual characters really is a silly way to store text
02:53:18 <tdammers> bergmark: I was under the impression that String is full 32-bit, while Text uses utf-16 internally, and has some rare edge cases for 32-bit code points
02:53:27 <tdammers> I may be mistaken though
02:53:34 <orion> jle`: Ahh, linked list. I see.
02:53:47 <jle`> orion: every *individual* character is located randomly around the heap
02:53:54 <tdammers> jle`: but then, I'd argue that String isn't for storing strings, but for iterating over them ;)
02:54:09 <jle`> tdammers: :)  it has a purpose
02:54:29 <jle`> iterating over characters, you mean?
02:54:37 <Fuuzetsu> jle`: there are issues open for types in index and I have already been playing with it, hopefully it will be in next release
02:54:44 * Fuuzetsu → bed
02:54:52 <jle`> Fuuzetsu: oh, cool :)
02:55:04 <jle`> nice to know that it is something you guys have found worthwhile to work on
02:55:10 <grohne> jle`: I still fail to invoke haddock in a way that does not fail, but I have a hack involving ghci now:
02:55:17 <grohne> jle`: { echo ":load Main"; find src -name "*.hs" | sed 's,^src/,:browse ,;s,\.hs$,,;s,/,.,g'; } | cabal repl
02:55:33 <jle`> haha
02:56:25 <quchen> Meth, not even once
02:56:34 <tdammers> jle`: yes, of course
02:57:02 <MP2E> s/Meth/regexps
02:57:03 <tdammers> otoh, conduits are probably a saner and more powerful way of piping things through streams and such
02:57:03 <MP2E> :P
02:58:02 * hackagebot generic-aeson 0.1.1 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.1 (AdamBergmark)
02:58:27 * frerich wonders why his brain turns 'hackagebot' and 'aeson' into 'kaesebot'...
02:59:01 <Kinnison> cheesy
03:00:35 <rio> frerich: if it was properly it would turn it into käsebrot
03:00:51 <rio> *working properly
03:05:05 <danilo2> Hello! Is there any environment variable which tells ghc (in particular runhaskell) where to searc h for files when invoking import command ? something like PYTHONPATH
03:05:36 <kqr> orion, Data.Text corresponds more closely to the normal string type in any other language. String is just a linked list of Chars, which is not efficient at all for most common string operations
03:07:36 <tech2> Snap, Yesod, Happstack, Scotty, Warp... how does one decide which web framework to use when starting out? In many other languages the frameworks have had time to settle and have some leaders, but coming from outside this community it's a little hard for me to make an informed decision.
03:08:01 <kqr> tech2, it depends a little on what you want. do you need a full-fledged framework or a microframework?
03:08:13 <kqr> tech2, as far as i know, warp is more of a server than a framework too
03:08:14 <danilo2> ach! -i works this way! :)
03:09:01 <tech2> kqr: for the most part it's an "in", I just need something to allow me to write meaningful code and learn, rather than just playing with mathematical idioms in the repl.
03:10:15 <kqr> tech2, right. scotty is realy easy to get started with and it'll allow you to write simple web apps. if you need more power (authentication and the like) you'll probably want to switch to snap, yesod or happstack
03:10:48 <int3___> I vaguely recall reading about a cabal option that allows for packages to be force-linked against newer versions of their dependencies, but I'm unable to find it right now
03:10:48 <int3___> does that ring a bell with anyone?
03:10:49 <tech2> Cool, scotty it is then I guess, thanks kqr.
03:10:53 <tdammers> kqr: authentication isn't difficult in scotty either, you just can't go with a pre-made solution
03:11:01 <int3___> oh nevermind
03:11:10 <tdammers> tech2: scotty is nice, you'll love it
03:11:14 <int3___> --allow-newer, of course. i should really try help before googling.
03:11:38 <kqr> tech2, tdammers, yeah, that's what i meant. sorry if it came out the wrong way
03:12:27 <tech2> thanks tdammers, here's hoping. I have a fair bit of learning not just the language, but the ancillary stuff like cabal and the way people structure applications which are often forgotten in tutorials etc.
03:13:13 <tech2> kqr: no problem, it's just a starting point, I just need a foot in the door, so to speak.
03:13:24 <zipper> WHat changed in cabal? I try cabal sandbox init and keep getting unrecognised command.
03:13:34 <zipper> `cabal sandbox init`
03:13:55 <int3___> zipper: what version of cabal are you using?
03:14:35 <zipper> int3___: 1.16.0.2
03:14:52 <zipper> 1.16.0
03:14:55 <zipper> int3___: ^
03:15:05 <int3___> zipper: I think sandboxes were introduced in 1.18
03:15:05 <zipper> The former is for cabal install
03:15:14 <int3___> there was even this cartesian closed comic about it...
03:15:30 <zipper> int3___: What? but I've used sandboxes before on my computer
03:15:46 <kqr> zipper, hsenv or something like that?
03:15:46 <int3___> zipper: did you downgrade cabal somehow
03:15:52 <kqr> or downgrading cabal
03:15:52 <zipper> int3___: cabal update cabal should work right?
03:16:05 <int3___> zipper: cabal install cabal-install
03:16:05 <zipper> int3___: I don't remember doing so
03:16:21 <kqr> could have been accidental
03:16:40 <int3___> http://ro-che.info/ccc/22
03:16:44 <zipper> Well I just deleted my ~/.cabal and my ~/.ghc
03:16:57 <zipper> and tried installing stuff again
03:17:30 <mmmm> have you added ~/.cabal/bin to your path
03:17:38 <zipper> mmmm: Yes
03:18:16 <mmmm> and "which cabal" gives you the right answer?
03:20:08 <zipper> I am runnning cabal install cabal-install It seems to be installing cabal 1.20 I think it will work.
03:20:11 <zipper> mmmm: ^
03:20:23 <zipper> mmmm: Let me try that
03:21:10 <zipper> mmmm: /usr/bin/cabal
03:22:44 <RchrdB> zipper, before you try changing things, you can find out exactly what version of cabal-install and Cabal you have set up now, by running: "cabal --version".
03:23:01 <zipper> It says it installed cabal-install 1.20.0.3 but cabal --version says it's still using 1.16.*
03:23:45 <RchrdB> What does "~/.cabal/bin/cabal --version" say?
03:24:02 <zipper> RchrdB: I am running cabal version 1.16.0 and cabal-install version 1.16.0.2
03:24:45 <joshkirklin> mv /usr/bin/cabal /usr/bin/cabal-old
03:24:50 <RchrdB> Well, the fact that you're running cabal version 1.16.0 is why "cabal sandbox init" doesn't work for you, because sandboxes were added to cabal in version 1.20.
03:24:53 <zipper> RchrdB: That one says 1.20.0.* :D
03:25:03 <RchrdB> that sounds about right
03:25:04 <zipper> RchrdB: I think I should edit my PATH or something
03:25:10 <zipper> What should I do?
03:25:22 <RchrdB> joshkirklin, please don't advise people to mess with software that was installed by their OS's package manager. :(
03:25:38 <joshkirklin> RchrdB, good point
03:25:53 <RchrdB> zipper, I would put ~/.cabal/bin at the front of your PATH so that the new cabal which you installed will be found before the old cabal.
03:26:04 <joshkirklin> that's more sensible
03:26:10 <zipper> RchrdB: Yeah thanks
03:26:25 <RchrdB> or if you have ~/bin at the front of your PATH already then you could symlink (or hardlink) ~/.cabal/bin/cabal to ~/bin/cabal, but that's a stylistic choice.
03:26:28 <zipper> RchrdB: So I shouldn't try replace it with the new cabal because of dependencies maybe
03:27:57 <RchrdB> on modern, package-controlled OSes (by "modern" I mean, like, "post 2002-ish") you really don't want to alter the packages that were installed and are managed by your package manager.
03:29:20 <RchrdB> if you only add things to your homedir and config files, in the worst-case scenario you can just delete all the software you installed by hand and rebuild it from scratch, whereas if you start altering the packaged bits you can get into *real* messes.
03:39:44 <zipper> RchrdB: Thank you
03:39:49 <zipper> Thank you everyone
03:40:03 <RchrdB> Good luck.
03:42:25 <friden> I've done a lot of concurrent stuff in java, but now i want to try it in haskell. I want to spawn a few processes, do work in paralell and be able to communicate between them in some way. What is the recommended way (package?) to do this?
03:43:57 <friden> I googled around a bit and a few sites referred to CHP, is it the way to go or does someone with more experience have another advice?
03:44:06 <frerich> friden: When you say 'spawn a few processes', do you mean literal OS processes or are you rather thinking in terms of 'tasks', i.e. potentially some sort of threads?
03:45:24 <friden> if it's messier to spawn OS process, i can settle with tasks until i get the rip of it. i just want to do different things in paralell at the moment, does not really care about performance as of now^^
03:46:53 <frerich> friden: One of the basic tools for writing concurrent programs is 'forkIO', which creates something roughly corresponding to 'green threads' in Java.
03:47:02 <friden> basically i wanted to write myself an IRC communication thingy to do some networking, but i really wanted a task for reading data from the server and one that writes data. then a third to handle interaction with the user and order stuff to the previous two mentioned tasks
03:47:34 <frerich> friden: Technically, you could launch a process in each thread -- but of course, if you want to do concurrence on the OS-process level then you'll need to figure out how to do IPC without losing too much hair.
03:47:39 <friden> yeah, i've used forkIO some, but only to spawn then and do stuff independent of eachther, now im just asking how to do the actual communication between threads^^
03:47:47 <tero-_> friden: I use Control.Concurrent.Chan for thread communication
03:47:49 <RchrdB> so in that case you almost certainly want to spawn threads with forkIO.
03:47:55 <arancia> An overwiew to start with: http://www.haskell.org/haskellwiki/Concurrency
03:48:08 <arancia> Also RWH has a chapter on concurrency
03:48:09 <friden> tero-_: thanks, that seems to be what im after :D
03:48:13 <arancia> @where rwh
03:48:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:48:23 <frerich> friden: I like to use STM for this, in particular the 'channels' abstraction as documented on http://hackage.haskell.org/package/stm-2.1.1.2/docs/Control-Concurrent-STM-TChan.html
03:48:28 <saep> @google Parallel and Concurrent Haskell
03:48:29 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
03:48:29 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
03:49:02 <RchrdB> friden, Control.Concurrent.MVar, Control.Concurrent.Chan, and if you want to have any thread-safe data structure at all then you almost certainly want to use STM for it so that it won't immediately exhibit race conditions and blow up.
03:49:08 <friden> awesome, quick question about the channels. are they "multicasting" to each connected client or do i send to specific pids?
03:49:28 <joash> they multicast
03:49:33 <joash> if you duplicate them
03:49:48 <friden> ok, then i'll handle the pids myself^^
03:50:00 <friden> ... if i duplicate them?
03:50:01 <RchrdB> If you use dupChan to duplicate a channel 'n' times then it'll broadcast to all of the listening ends.
03:50:25 <RchrdB> If you share a single Chan without dupChan'ing it then only one reading thread will get each message enqueued.
03:50:29 <RchrdB> so you get to chose.
03:50:33 <friden> ok i think i have to read some documentation to understand that^^
03:50:33 <RchrdB> *choose
03:50:46 <JRancher> So I just tried cabal install purescript and it failed to install terminfo-0.4.0.0, missing curses.h, ncurses.h? First time using cabal, not sure what I'm doing wrong. Does anyone have a suggestion for me to try?
03:51:48 <ion> Try installing the development package for ncurses using your system package manager.
03:52:23 <JRancher> ion: ok I will try that
04:00:00 <JRancher> ion: thanks that worked
04:01:28 <RchrdB> friden, here's an example that shows the difference between sharing a single Chan and dupChan'ing: http://lpaste.net/107826
04:41:54 <mmmm> What is the best way to construct and AST with holes in to fill in later?
04:46:39 <bergmark> mmmm: it depends...
04:47:37 <bergmark> mmmm: will you replace all holes at the same time or can just some of them be filled?
04:48:42 <mmmm> At the same time
04:48:49 <bergmark> are they all the same type?
04:48:58 <mmmm> yes
04:49:06 <bennofs> sounds like monad :P
04:49:38 <bergmark> then you can parametrize your type `data AST ann = Expr ann Foo', initialize it to () and then transform that into something else
04:50:37 <int3___> mmmm: http://blog.ezyang.com/2013/05/the-ast-typing-problem/
05:02:10 <merijn> Anyone have any good pointers to papers on the design/implementation of OCaml's (or OCaml-style) module systems
05:20:53 <tech2> is there a preferred way to install haskell on ubuntu (latest release), since the standard ghc package led to cabal install cabal-install giving me "The following packages are likely to be broken by the reinstalls: ghc-7.6.3" (and a few others)
05:21:12 <tech2> otherwise I end up with cabal at 1.16 which doesn't support sandbox (I think)
05:21:22 <ion> tech2: Dunno about the preferred way but this is what i do: https://gist.github.com/ion1/2815423
05:22:30 <tech2> ion: wow, that's a little extreme. I was kinda hoping for a ppa on the outside, but sure... I guess.
05:23:19 * hackagebot generic-aeson 0.1.1.1 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.1.1.1 (AdamBergmark)
05:25:02 <tech2> ion: thanks, I'll give it a go. I guess years of package-management have softened my approach to this kind of thing.
05:25:05 <merijn> tech2: That's what I usually end up doing on linux boxes (although, to be fair, I'm not really a linux user and don't have admin rights on those machines)
05:25:53 <merijn> tech2: The nice thing about this approach (combined with the fact that cabal/ghc use per-GHC-version databases) is that it's really easy to have and switch between multiple parallel GHC installs
05:27:23 <tech2> merijn: thanks for the second vote-of-confidence. Sometimes it's hard to tell what the expected approach is.
05:28:08 <merijn> tech2: On OSX/windows I usually use the platform, but I usually still use this approach to keep one or more copies of various HEAD versions around
05:33:20 * hackagebot json-schema 0.6.1.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.6.1.1 (AdamBergmark)
05:34:01 <shlevy> johnw: Based on the comment in http://hackage.haskell.org/package/lifted-base-0.1.0.1/docs/Control-Exception-Lifted.html#v:bracket , shouldn't sourceFile use Control.Exception.Base.bracket?
05:45:02 <danilo2> Hello! Is there in haskell a class providing function morph :: forall a . m a -> n a ? Something like here, but there is no such class: http://hackage.haskell.org/package/mmorph-1.0.3/docs/Control-Monad-Morph.html#t:MMonad
05:52:56 <bennofs> danilo2: I couldn't find such a class, however, there are many classes for "special cases": for example, if m ~ f (f a) and n ~ f, and f is a Monad, you can use join. Or if m ~ t (f a), n ~ f (t a), and t is Traversable and f an Applicative, you can use sequence, etc
05:54:44 <bennofs> danilo2: or as another example: if m ~ f (w a), n ~ w (f a) and f is a Functor and w is Distributive, you can use distribute
05:55:39 <danilo2> bennofs: I know them, I need just m a -> n a , where m and n are monads and in this partuicular example are my monads created out of newtypes
05:55:56 <danilo2> bennofs: I think I'll just create my own MonadMorph class :)
05:56:04 <danilo2> bennofs: thank you :)
05:58:24 * hackagebot spe 0.6.2 - Combinatorial species lite  http://hackage.haskell.org/package/spe-0.6.2 (AndersClaesson)
05:58:26 * hackagebot engine-io 1.0.2 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.0.2 (OliverCharles)
06:05:00 <shlevy> johnw: Implementing hnix path serialization as a Source. If I encounter an unsupported file type, should I throw an exception (since I'm in MonadIO) or somehow use left?
06:08:45 <tech2> is there a standard way of building a build-depends list automatically for an application.cabal file, or is it just something to be managed manually? Can you pull the package-list installed in a sandbox for example?
06:09:44 <benmachine> tech2: by and large you have to manage it manually -- note that the package list installed in a sandbox will include transitive deps that you don't necessarily need
06:09:55 <ClaudiusMaximus> tech2: `cabal init` might do what you want, but make a backup first
06:10:03 <donri> tech2: cabal init if you don't have a .cabal file already. or temporarily rename it and hand merge
06:10:32 <tech2> Thanks all.
06:18:27 * hackagebot engine-io 1.1.0 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.1.0 (OliverCharles)
06:23:28 * hackagebot engine-io-snap 1.0.1 -   http://hackage.haskell.org/package/engine-io-snap-1.0.1 (OliverCharles)
06:23:30 * hackagebot socket-io 1.0.1 -   http://hackage.haskell.org/package/socket-io-1.0.1 (OliverCharles)
06:37:33 <Javran> I spotted some useful functions in Util from ghc package, but when I try to import it from ghci, it says "It is a member of the hidden package `ghc-7.6.3'", how can I get access to these functions?
06:38:29 * hackagebot ekg-carbon 1.0.1 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.1 (OliverCharles)
06:38:31 * hackagebot network-carbon 1.0.1 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  http://hackage.haskell.org/package/network-carbon-1.0.1 (OliverCharles)
06:38:32 <geekosaur> ghci -package ghc-7.6.3
06:39:18 <geekosaur> however you should probably not get in the habit of using things from the ghc package unless you're actually using the compiler in your program
06:39:47 <geekosaur> (you're pulling the compiler itself as a library)
06:41:18 <Javran> geekosaur: I see
06:42:15 <shlevy> Any basic tutorials for https://hackage.haskell.org/package/plugins ?
06:42:58 <Javran> http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/ghc/Util.html#v:lengthIs I think lengthIs / lengthAtLeast / lengthExceeds are quite useful, but I haven't found anything equivalent in other packages
06:43:59 <allsystemsarego> javax, copy/paste the code into your program?
06:44:11 <allsystemsarego> Javran, ^
06:48:20 <Javran> allsystemsarego: that should work, just wondering if there're already existing somewhere.
06:48:59 <Ankhers> shlevy: http://hub.darcs.net/stepcut/plugins/browse/testsuite Is the test suite for that package. They should show basic usage.
06:49:14 <shlevy> thanks
06:49:25 <osa1> http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html#t:RandT is there a reason to not have Applicative instance of this?
06:50:30 <benmachine> no
06:51:03 <osa1> I hate when this happens. I want my applicative operators.
06:51:38 <merijn> osa1: Only 1 more year until 7.10 and AMP ;p
06:58:56 <Kaligule> Hi there,
07:00:56 <Kaligule> Is there a tool that can wich of my programms imports which  other programm (In a tree-like struckture)? I can assume they are all Haskell files in a single directory.
07:03:05 <aloiscochard> hey folks, I was asked to propose a talk for conference which have FP track... the cool thing is that it's not PL specific (I'm usually speaking in scala conf).... so I thought I might speak about haskell
07:03:08 <kqr> what alternatives do i have when it comes to oauth 2.0 libraries?
07:03:15 <aloiscochard> what you guys think is a good subject to attract coders?
07:03:31 <aloiscochard> I thought about showing all the win purity bring... but I'm not sure, maybe something more trivial
07:03:39 <aloiscochard> if you have suggestions, please shout!
07:05:32 <allsystemsarego> aloiscochard, pick one of the miniature "cultural revolutions" that originated in Haskell and then spread like wildfire into other programming languages, something like QuickCheck, STM, Lens
07:05:49 <tdammers> ...FP
07:05:58 <aloiscochard> allsystemsarego: oh yeah good point, even Linq could be a good example
07:06:33 <aloiscochard> allsystemsarego: that's a cool idea, thank you very much :-) showing how haskell influence others PL, the one people in the audience are using
07:06:54 <aloiscochard> "How Haskell made your PL better." ;-)
07:10:38 <tdammers> PL == Personal Life? I'd listen to that talk.
07:11:10 <aloiscochard> Programming Language :-D
07:11:23 <aloiscochard> tdammers: initially I thought about "how laziness changed my life", but that's maybe a bit over the top
07:11:37 <tdammers> aloiscochard: in my case, that wouldn't be a huge change
07:12:28 <tdammers> aloiscochard: I had planned to procrastinate today, but I figured I should get some coffee first, and check IRC and reddit and hacker news and then go recategorize the files in my home dir
07:12:50 <shlevy> What's the state of the art for writing haskell plugins?
07:12:51 <aloiscochard> tdammers: hahaha, I know that feeling
07:13:08 <tdammers> shlevy: plugins? you mean libraries?
07:14:15 <merijn> shlevy: Dons had a nice paper, but the link I had for it is dead and I don't remember the title :\
07:31:33 <zoink> are monads always (or almost always) used for IO?
07:32:49 <bennofs> zoink: I'm not sure I understand your question. In haskell, you have to use the IO monad if you want to do IO, if that what you mean
07:32:55 <tdammers> zoink: most definitely not
07:33:03 <tdammers> zoink: most monads are not about IO at all
07:33:05 <zoink> okay, got it
07:33:26 <rio> check out the state monad
07:33:28 <zoink> what is their most common use, then?
07:33:31 <bitemyapp> zoink: monads are used for all sorts of things.
07:33:43 <bitemyapp> zoink: IO is fairly common, but so are other things like Maybe.
07:33:54 <bitemyapp> zoink: you won't learn what monads are by having a menagerie rattled off at you.
07:33:57 <bennofs> zoink: I think Reader/Writer/State/Either/Maybe are all pretty commonly used
07:34:03 <bitemyapp> zoink: https://github.com/bitemyapp/learnhaskell
07:34:09 <zoink> ok
07:34:23 <bitemyapp> bennofs: most people use EitherT, StateT, WriterT, ReaderT though, don't they?
07:34:26 <bitemyapp> bennofs: and MaybeT
07:34:47 <bennofs> bitemyapp: yeah probably.
07:35:54 <bitemyapp> alright, I'd better head to the airport.
07:36:06 <bitemyapp> btw proofgeneral + coq + emacs is frickin' wizardly. thanks johnw
07:39:46 <merijn> bennofs: You missed the list monad, STM and more :p
07:40:35 <xmonadlover> Could someone quickly review my tiny haskell-program here, and suggest how to add a color option as an argument? https://github.com/jfremstad/harchey/blob/master/harchey.hs
07:41:20 <xmonadlover> I'm guessing I have to use getArgs, but if I bind the value to color inside the main function my other functions can't use it
07:43:07 <kqr> bennofs, list is pretty common too, and the unwrapped reader aka (->)
07:43:33 <merijn> xmonadlover: Why can't your other functions not use them?
07:43:39 <frerich> xmonadlover: The simplest would be to do something like 'args <- getArgs; let color = case args of [color] -> color; _ -> "blue"' or so. You could then either pass this value on to other functions as an argument, or you have a global value 'color :: IO String' which does this (but of course that means you can only retrieve the color from other functions doing IO)
07:44:12 <tolt> xmonadlover: You could get the args and then make a printWithColor function that takes in a color and a string to print so you would have String -> String and then partially apply the  function so that after you read in the color you could define a printColor function that
07:44:35 <tolt> has the arguments of String so each one is the same without repeating the String -> String -> IO () function
07:45:09 <Qfwfq> @pl \(a,b,c,d) -> (a,c)
07:45:10 <lambdabot> (line 1, column 7):
07:45:10 <lambdabot> unexpected "c"
07:45:10 <lambdabot> ambiguous use of a non associative operator
07:45:15 <xmonadlover> This is my attempted modification: http://lpaste.net/5547673372067889152
07:46:11 <Qfwfq> Huh.
07:46:45 <xmonadlover> AFAIK I can't assign color multiple values, it says something about shadowing
07:46:49 <tolt> xmonadlover: whatColor doesn
07:46:55 <frerich> xmonadlover: 'whatColor' doesn't need to do any IO. And 'printColor' takes one argument too few
07:46:57 <tolt> doesn't have to return IO String
07:47:26 <xmonadlover> frerich: It was the only thing that would make the compiler shut up about type errors :(
07:47:41 <frerich> xmonadlover: I bet there was an alternative way to make the compiler shut up :)
07:48:12 <xmonadlover> frerich: Ah, I used a static color variable previously, so I have to make it an argument, got it
07:48:56 <frerich> xmonadlover: It ight be convenient to make 'color' the first argment so that in 'main' you can do something like 'let p = printColor color' and then just use 'p' throughout the rest of the function
07:49:57 <latk> I'm sure this is a pretty common question, but what is the state of elm/purescript/ghcjs/etc ? Are any of them as mature as, clojurescript, say?
07:50:02 <xmonadlover> frerich: I will try that, however I'm getting color is not in scope all the time
07:53:34 <tolt> xmonadlover: look at this? http://lpaste.net/107838
07:53:45 <subleq> is there a way to get a list of types that are Eq but not Ord?
07:56:02 <merijn> subleq: What does that mean?
07:56:56 <subleq> merijn: what do you mean what does that mean? i don't know how else to phrase it
07:57:27 <xmonadlover> tolt: Thanks, I think I'll be able to work the rest out now :)
07:57:34 <tolt> Good! Good luck.
07:57:47 <merijn> subleq: Well, what are you hoping to get? What are you trying to do?
07:58:06 <merijn> oh, wait
07:58:14 <merijn> You mean examples of types that are Eq but not Ord?
07:58:22 <subleq> yes
07:58:28 <glguy> I don't know an automated way beyond using haddocks to compare
07:58:39 <glguy> Or asking GHCi with :i
07:58:57 <subleq> well, some programmatic way to search types get the examples would be nice
07:59:16 <merijn> subleq: I don't think there is a comprehensive way to get everything, but if you just want a few examples one of them would be "MVar a" being an Eq instance, but not an Ord instance
08:00:11 <iasoon> subleq: Not sure about actual Haskell datatypes, but I can imagine loads of datatypes that would fit this description.
08:00:47 <glguy> That sounds like a bug in mvar
08:01:55 <merijn> glguy: Why?
08:02:09 <subleq> iasoon: for example?
08:02:12 <merijn> glguy: "MVar a" equality == pointer equality
08:02:23 <merijn> i.e. you can check whether two MVars are the exact same MVar
08:02:33 <merijn> Seems sensible enough?
08:03:12 <glguy> Because it's implementable and would allow people to more efficiently check mvars for membership in a set or similar
08:04:28 <merijn> I guess
08:04:51 <glguy> Drive time
08:06:00 <quchen> merijn: Oh, I never noticed that. I guess I always thought MVar equality compared the contents, but that doesn't typecheck. Still, I didn't see that.
08:06:50 <iasoon> subleq: Equality does not imply order. Take this MVar as an example: You can check whether two MVars are the same reference (they point to the same spot in memory), but there is no (obvious) way to order them.
08:08:38 <pjdelport> subleq: You could probably dive into the GHC API if you wanted to build a programmatic way to search that.
08:08:52 <pjdelport> Might need some elbow grease, though.
08:08:58 <subleq> glguy makes sense though that it's possible and useful to implement Ord for MVars
08:09:36 <int3__> gah, function composition inside Applicatives always seems terribly awkward to me.
08:12:00 <pjdelport> int3__: You could use: (f <.> g) x = f <$> g x
08:12:21 <pjdelport> (analogous to (f . g) x = f $ g x )
08:13:09 <int3__> pjdelport: mm yes that seems useful
08:15:26 <int3__> yeah, it would definitely 'round out' the applicative syntax.
08:15:58 <pjdelport> I keep wishing for it, yeah.
08:16:00 <merijn> Sounds like you're looking for Kleisli composition?
08:16:05 <pjdelport> and/or locally defining it
08:16:23 <joshkirklin_> say I have a compiled program /usr/bin/foo. is there an IO function I can use to run it and collect stdout?
08:16:27 <pjdelport> merijn: Nah, that's more like plain composition.
08:16:38 <merijn> int3__: Are you dealing with actual Applicatives or is Monad good too?
08:16:59 <int3__> merijn: actual applicatives (threepenny's Behavior, in this particular case)
08:17:06 <merijn> Ah
08:17:11 <pjdelport> merijn: It lets you write e.g. "doubledOdds xs = (2*) <$> filter odd xs" as "doubledOdds = (2*) <.> filter odd"
08:17:21 <merijn> I was thinking you might be able to get away with >=>
08:17:53 <pjdelport> or  \xs -> toLower <$> reverse xs  as  toLower <.> reverse
08:17:55 <allsystemsarego> subleq, cabal unpack base; cd base-4.7.0.0; git init; git add .; git grep 'instance.*Eq.*where' > eq.txt; git grep 'instance.*Ord.*where' > ord.txt
08:17:57 <merijn> pjdelport: eh, why not just use normal composition with <$> in that case?
08:18:11 <allsystemsarego> subleq, then massage eq.txt and ord.txt
08:18:15 <pjdelport> merijn: Because then you need to squeeze an additional fmap in there
08:18:18 <merijn> doubleOdds xs = (2*) . filter odd <$> xs
08:18:39 <pjdelport> merijn: It's not as cleanly analogous as just having <.> for <$> in the same way you have (.) for ($)
08:19:01 <pjdelport> yeah, but that's still pointy :)
08:19:05 <merijn> So?
08:19:15 <merijn> Death to pointfree code >.<
08:19:26 <quchen> ITS TIME FOR …
08:19:35 <quchen> ?pl \a b c -> [a,b,c]
08:19:36 <lambdabot> (. ((. return) . (:))) . (.) . (:)
08:19:46 <merijn> I'd rather not have to figure out what "(2*) <.> filter odd" means a few months after I forget...
08:20:33 <quchen> Would (<.>) even be associative?
08:20:41 <pjdelport> merijn: It's not ">.<", it's "<.>" :)
08:20:41 <subleq> allsystemsarego: nice
08:20:41 <quchen> What would be its identity?
08:21:00 <int3__> quchen: pure id?
08:24:05 <rio> quchen: is the appearing return there just \x -> [x]?
08:24:12 <quchen> Yes
08:24:29 <bennofs> @let f <.> g = (f <$>) . g
08:24:31 <lambdabot>  Defined.
08:24:36 <bennofs> :t (<.>)
08:24:36 <int-e> @type (:[])
08:24:37 <lambdabot>     Ambiguous occurrence ‘<.>’
08:24:37 <lambdabot>     It could refer to either ‘L.<.>’,
08:24:37 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:149:3
08:24:39 <lambdabot> a -> [a]
08:24:55 <bennofs> :t (<.>)
08:24:55 <lambdabot>     Ambiguous occurrence ‘<.>’
08:24:56 <lambdabot>     It could refer to either ‘L.<.>’,
08:24:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:149:3
08:25:11 <quchen> int3__: The problem is both sides of <.> have different types, so you can't have an identity
08:25:14 <bennofs> @undef
08:25:14 <lambdabot> Undefined.
08:25:23 <int-e> :t let f <.> g = (f <$>) . g in (<.>)
08:25:23 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
08:25:29 <int-e> :t (<.>)
08:25:30 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
08:25:33 <bennofs> ah lens right
08:25:47 <pjdelport> @pl \a b c d e f g -> g f e d c b a
08:25:48 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
08:25:50 <bennofs> what
08:25:52 <bennofs> :O
08:26:04 * pjdelport likes the fractal structure of that
08:26:47 <quchen> pjdelport: Fractal structure you say? Try the following in GHCi.
08:26:53 <quchen> NOTE THE GHCi PART.
08:26:54 <quchen> let a x = (x,x) b = a.a c = b.b d = c.c in  d ()
08:27:20 <quchen> (This makes GHC's prettyprinter seem really impressive.)
08:27:33 <rio> <interactive>:2:19: parse error on input ‘=’
08:27:41 <quchen> Oh woops
08:27:46 <quchen> I joined lines on multiline code.
08:27:56 <quchen> Like this: http://lpaste.net/107840
08:28:10 <bennofs> > let a x = (x,x); b = a.a; c = b.b; d = c.c in  d ()
08:28:12 <lambdabot>  (((((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),(...
08:28:28 <quchen> bennofs: :t it
08:28:37 <bennofs> :o nice
08:28:37 <quchen> (Did I not say "do it in GHCi"?)
08:28:54 <bennofs> quchen: yeah, but I saw nothing else than in lambdabot
08:29:04 <pjdelport> quchen: I have some grains of rice and a chessboard to tell you a parable about. :)
08:29:21 <quchen> pjdelport: That chess board grows only exponentially, i.e. slow! ;-)
08:29:50 <tdammers> quchen: pjdelport: optimization: add exponential amounts of pigeons
08:29:52 <quchen> Using that schema above you can really easily consume all memory
08:29:54 <Yuu_chan> I've encountered a weird error: "GHCi runtime linker: fatal error: I found a duplicate definition for symbol   _hs_bytestring_long_long_int_dec", what to do?
08:30:05 <bennofs> Yuu_chan: restart GHCi and try again ?
08:30:12 <bennofs> Yuu_chan: I sometimes got that and restarting helped
08:31:35 <Yuu_chan> bennofs: nope (it ceases to work anyway). Seems it tries to load two verisons of ByteString. Something is configured wrong, probably?
08:31:54 <bennofs> Yuu_chan: what packages do you use? Do you use TH?
08:32:04 <int3__> quchen: oh, right. I guess `f <.> g = (.) <$> f <*> g` would be the proper Applicative analog of normal composition.
08:33:09 <pjdelport> Right.
08:33:34 <quchen> Wouldn't that just be <*> again?
08:33:41 <pjdelport> <.> is just the syntactic analog to (.) / ($), for <$>
08:34:26 <Yuu_chan> bennofs: explicitly — no
08:34:27 <quchen> Applicative law: `u <*> (v <*> w) ≡ pure (.) <*> u <*> v <*> w`, set v<*>w = x
08:34:29 <pjdelport> To make it work properly, you also want it infixr 5, like (.) is.
08:34:50 <quchen> Eeek, fixity mistake, nevermind.
08:34:56 <int3__> quchen: oh, uh, right... welp okay I guess I got a bit lost with the types there.
08:35:13 <Yuu_chan> Though I'm not sure if one of used packages uses TH underneath.
08:36:04 <quchen> int3__: FWIW your function is just liftA2 (.)
08:37:32 <int3__> quchen: yup, I know about the conversion between liftAn and <$> .. <*> ..
08:38:14 <Yuu_chan> Could that be a result of careless forced package updates?
08:38:37 <kqr> is there a hayoo 2 or something? i want to recall there is
08:39:45 <mmmm> What's the technique called where you have a polymorphic AST?
08:40:38 * Yuu_chan needs into sandboxes
08:45:05 <Yuu_chan> Eww, that dependencies hell :( Is there a way to manage this current situation?
08:45:53 <mmmm> delete ~/.cabal and ~/.ghc
08:45:57 <mmmm> reinstall and hope for the best
08:46:06 <mmmm> in a sandbox helps things a little bit
08:48:26 <Yuu_chan> mmmm: thanks, I'll try
08:59:25 <adas> is there any standard library for genetic algorithms? like quickcheck for testing?
09:01:56 <vikraman> hi, how do I convert an aeson Value to ByteString ?
09:03:57 <bergey> http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson-Encode.html
09:19:21 <Ankhers> Is there some way of using printf with a list of strings? Or would there be a better way of doing something like this?
09:19:42 <mzero> just like in C, not really
09:20:00 <mzero> what is your intention - to apply the same printf formating to all strings?
09:20:17 <mzero> to have some fixed printf protion, followed by the list interpolated with commas?
09:20:29 <mzero> there are easy solutions for either of these… what’s your use case?
09:20:43 <adas> im installing a package from hackage in a sandbox. and there is a compile error that i would like to fix. where in the sandbox can i find the source to that package?
09:20:57 <adas> searched the .cabal-sandbox folder...couldn't find anything
09:21:01 <mzero> adas - it isn’t there
09:21:31 <mzero> like any cabal install <package>, the source is unpacked and built in a temporary dir.. then installed into the sandbox
09:21:35 <mzero> if you want to muck with the package
09:21:55 <mzero> then   cd .. ; cabal unpack <pkg>
09:22:20 <Ankhers> mzero: I'm honestly not 100% the use case yet. I should probably figure that out before attempting to over-engineer the solution... Thanks for the help!
09:22:22 <mzero> cd into the <pkg> dir and do     cabal sandbox —sandbox-dir=../<myproject>/.cabal.sandbox init
09:22:50 <mzero> Ankhers: know that printf doesn’t get as much use in Haskell as in other languages….
09:23:35 <Ankhers> mzero: Is there some alternative that is more suited to Haskell?
09:23:56 <adas> mzero: if i unpack in a non-sandbox folder ..won't it contaminate the main cabal install?
09:24:49 <mzero> Ankhers: it’s just that many simple tasks that in other systems are done by printf, are, in Haskell just open coded as they are so easy
09:24:59 <adas> by "main cabal install" i mean .. the cabal files in my home folder?
09:25:12 <mzero> adas: unpacking never contaminates anything … only “cabal install” ever does
09:25:17 <Ankhers> mzero: Fair enough. Thanks again.
09:25:39 <mzero> but if you do the    cabal sandbox —sandbox-dir=    thing I mentioned, then this unpack will use the other sandbox
09:25:44 <mzero> an alternative to doing that is
09:25:47 <mzero> do the unpack
09:26:07 <mzero> but then in your project director, you can do a    cabal sandbox add-source    to add the explicit source up and over
09:26:19 <mzero> then you build in *your* project,…. but it compiles the other one
09:27:39 <adas> so i can cabal unpack <pkg> in the existing sandbox.
09:27:43 <adas> make my changes..
09:28:10 <adas> and then add this unpacked <pkg> as a dependency in the cabal file of the sandbox..
09:28:30 <adas> and then whenever i do cabal install , it will compile and install the unpacked pkg as well?
09:28:47 * hackagebot MFlow 0.4.5.5 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.5 (AlbertoCorona)
09:28:54 <mzero> no no
09:28:56 <Sornaensis> hi does anyone here know how to disable certificate authentication for the Network TLS package
09:28:58 <mzero> cabal unpack up and over
09:29:01 <Sornaensis> errr
09:29:03 <Sornaensis> verification
09:29:21 <mzero> well… you can unpack in yoru project dir… but that seems messy to me
09:29:35 <mzero> but otherwise, yes
09:29:40 <mzero> you’ve got the flow
09:30:55 <adas> mzero thnkas. ill try the second one
09:31:12 <orion> In the first code block here: http://en.wikibooks.org/wiki/Haskell/GADT#GADTs what is written looks almost like a type class. Why can't a type class be used there?
09:33:36 <ph88> hey guys, im new to haskell and ive been thinking for a while now on how to do something like this. I hope someone can read this program http://pastebin.com/mXse7uKQ
09:34:40 <ph88> in haskell i'm trying to solve it with map ... but when i put a map in a map then i don't have the outer map variable available in the inner map
09:35:59 <rio> ph88: can you just write what you expect as an output when given [4,5,6]?
09:37:46 <Ankhers> ph88: I think you want recursive functions instead of a map.
09:40:09 <adas> why do we have libraries that do not compile on hackage? not complaining. just curiuos?
09:44:17 <josephle> ph88: a translation of your program using higher-order functions will probably use a zip, a map, and a fold
09:48:54 <hunt> have any of you guys been to glasgow/
09:49:00 <hunt> to visit the university?
09:49:14 <hunt> im wondering if haskells bgi there
09:49:15 <fread2282> what's the lambdabot quickcheck command?
09:49:31 <hunt> > quickcheck (+1)
09:49:32 <lambdabot>  Not in scope: ‘quickcheck’
09:49:32 <lambdabot>  Perhaps you meant one of these:
09:49:32 <lambdabot>    ‘quickCheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
09:49:32 <lambdabot>    ‘myquickcheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
09:49:40 <hunt> > quickCheck (+1)
09:49:41 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary a0)
09:49:41 <lambdabot>    arising from a use of ‘Test.QuickCheck.Test.quickCheck’
09:49:41 <lambdabot>  The type variable ‘a0’ is ambiguous
09:49:41 <lambdabot>  Note: there are several potential instances:
09:49:42 <lambdabot>    instance Test.QuickCheck.Arbitrary.Arbitrary ()
09:49:47 <fread2282> @check
09:49:48 <lambdabot>  <unknown>.hs: 1: 1:Parse error: EOF
09:50:07 <hunt> @check ((+1) :: Int->Int)
09:50:08 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable GHC.Types.Int)
09:50:08 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’
09:50:21 <hunt> ?
09:50:23 <hunt> why fail
09:51:41 <levi> adas: Libraries on hackage generally compiled at some point. There are a lot that aren't actively maintained and are no longer compatible with the latest version of the compiler/base packages.
09:52:17 <hunt> @check show
09:52:18 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable
09:52:18 <lambdabot>  [GHC.Types.Char]) arising from a use of ‘Lambdabot.Plugin.Haskell.Check.Show...
09:52:40 <hunt> @check (++"hunt
09:52:40 <lambdabot>  <unknown>.hs: 1: 4:Improperly terminated string
09:52:43 <hunt> @check (++"hunt")
09:52:44 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable
09:52:44 <lambdabot>  [GHC.Types.Char]) arising from a use of ‘Lambdabot.Plugin.Haskell.Check.Show...
09:53:08 <hunt> @check (:('c':[]))
09:53:09 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable
09:53:09 <lambdabot>  [GHC.Types.Char]) arising from a use of ‘Lambdabot.Plugin.Haskell.Check.Show...
09:53:26 <hunt> can somebody show me how to use this thing
09:53:36 <fread2282> what's the correct versions of lines and unlines?
09:53:57 <hunt> fread2282: correct versions?
09:54:06 <adas> levi: yes. i guessed that much. just sent an email to the author.
09:54:21 <ClaudiusMaximus> hunt: you need a function that gives a bool
09:54:35 <ClaudiusMaximus> @check \a b -> a + b == b + a
09:54:37 <lambdabot>  +++ OK, passed 100 tests.
09:54:41 <fread2282> hunt: the ones that do less whacky stuff
09:55:09 <josephle> @check \a -> (+ 1) a == (+ a) 1
09:55:10 <lambdabot>  +++ OK, passed 100 tests.
09:55:10 <hunt> @check \a b -> a / b == a * b
09:55:12 <lambdabot>  *** Failed! Falsifiable (after 1 test):
09:55:12 <lambdabot>  0.0 0.0
09:55:18 <kqr> if you use Data.Aeson.Lens, and you have a lens that focuses on a String field of a json document, what is the recommended way to turn the json string to a haskell string?
09:55:47 <supki> :t Data.Text.Lens.unpacked
09:55:48 <lambdabot> (Data.Text.Lens.IsText t, Profunctor p, Functor f) => p String (f String) -> p t (f t)
09:56:19 <glguy> The "JSON String" is just a Haskell Text
09:56:51 <RyanGlScott> I have a style question. Is it considered bad form to have Maybe arguments?
09:57:01 <flan3002> For a simple 3D vector, is defining operations like V3 a b c + V3 d e f = V3 (a Prelude.+ d) (b Prelude.+ e) (c Prelude.+ f) the correct way?
09:57:03 <glguy> It totally depends on context
09:57:22 <glguy> RyanGlScott: ^
09:57:26 <RchrdB> RyanGlScott, as optional arguments? It's unwieldy to have *dozens* of them.
09:57:51 <RchrdB> It's not really "bad style" though because it does communicate your intent.
09:57:51 <RyanGlScott> As in, foo :: Maybe Bar -> Maybe Baz -> Quux
09:57:53 <josephle> flan3002: are you trying to overload the (+) operator?
09:58:03 <flan3002> josephle: Yeah, trying fits it. :)
09:58:09 <RyanGlScott> Should I instead make four different functions with all combinations of Bar and Baz?
09:58:18 <trap_exit> in haskell, is there a library for (1) load an image, clip a section of it, and (2) save the clipped section to disk ?
09:58:20 <flan3002> josephle: It's utterly stupid? :P
09:58:27 <RchrdB> RyanGlScott, depends on context. =)
09:59:08 <RchrdB> if you have huge numbers of arguments to something, sometimes the nicest way is to make a datatype that encapsulates them, with a "default" value clearly labelled in the docs.
09:59:15 <kqr> glguy, but wrapped in a String constructor, so that it has a Value type. i'm probably just very tired or missing something, but I still don't find it obvious how to make it a Text value
09:59:23 <josephle> flan3002: you should probably make Vec3 a instance of the Num typeclass then
09:59:27 <glguy> kqr: _String
09:59:32 <RchrdB> RyanGlScott, anything that clearly communicates what you want is stylistically fine by default, though. =)
09:59:48 <RyanGlScott> Actually, a default data value would probably work better for me anyway, now that you mention it.
09:59:52 <josephle> flan3002: that's where (+) and other arithmetic operations are defined. Also this means you don't have to keep doing (Prelude.+)
10:00:09 <flan3002> Great, sounds good. :)
10:01:21 <kqr> glguy, ...oh. i had even tried that but forgot to import data.aeson.lens at which point I hastily concluded i must be doing it wrong. thanks!
10:02:10 <silasm> josephle: how would you define signum for vectors? o.O
10:02:16 <glguy> point-wise
10:03:10 <josephle> silasm: I guess that's the unit vector in direction of the input vector :P
10:03:26 <RyanGlScott> Is there a list of autoderivable typeclasses somewhere? (e.g, Read, Ord, Show, Enum)
10:03:29 <silasm> hmm, that'd work I guess. fromInteger would also be weird.
10:03:35 <glguy> 3D vectors don't make for nice Num instances other than to just do all the operations point-wise
10:04:03 <silasm> In general I think it's discouraged to implement a typeclass just for its syntax (e.g. some libraries implement monad w/o following the laws because they like do notation)
10:05:21 <josephle> fair enough, the fromInteger objection is a reasonable one
10:06:01 <trap_exit> hmm
10:06:03 <trap_exit> imagemagick for the win
10:06:27 <c_wraith> I always argue that Vectors should be an affine space over points, anyway.  (No, vectors and points are not interchangeable)
10:06:31 <RchrdB> RyanGlScott, e.g. say you have a single function that is an entry point to something huge like, say, wrapping a Haskell API around gcc. The number of parameters is *huge* and will change every version. So you define something like, data GCCOptions = GCCOptions { optLevel :: Char, extraLinkerPaths :: [FilePath], extraIncludePaths :: [FilePath], fPIC :: Bool, ... }, and you leave a value "defaultGCCOptions
10:06:31 <RchrdB> " around, and any user of your API will call it like «gcc (defaultGCCOptions { extraLinkerPaths = ["/opt/mything/include"] }) ["file1.c"]»
10:07:03 <RchrdB> There is at least one example of this somewhere in the libraries that come with GHC, I think, but I can't remember where.
10:07:03 <RyanGlScott> RchrdB: Ooh, I like that approach even better.
10:07:10 <pjdelport> > let foo xs = let l = genericLength xs in zipWith (\k v -> sum [ v * (exp (k*i)) | i <- [0..l-1] ]) [0..] xs in foo [4,5,6]
10:07:12 <lambdabot>  [12.0,55.53668963694848,377.9232367924493]
10:07:17 <RyanGlScott> RchrdB: I believe Cabal uses it with defaultSettings, IIRC
10:07:19 <pjdelport> ph88: Is that the function you wanted?
10:07:20 * stobix concurs
10:07:21 * stobix is concurrent
10:07:23 <rio> c_wraith: you associate vectors with affine spaces and points with vector spaces?
10:07:26 <Flora21>  Hi! I give you some videos. I hope you like! http://bitly.com/1sFvA68
10:07:45 <RchrdB> RyanGlScott, ah yes, Cabal's defaultSettings is a great example of where that's done because the data type is expected to *change* without breaking the API. =)
10:07:57 <c_wraith> rio: as a matter of fact, yes. :)
10:08:08 <silasm> is there a reason Flora21 hasn't been banned yet? I feel like he does that every day.
10:08:11 <rio> c_wraith: that seems the wrong way around
10:08:40 <glguy> silasm: Because the Internet is big and people invent new nicks
10:08:43 <bennofs> silasm: I think it's always an other name
10:08:48 <c_wraith> rio: it's a case of something getting misnamed somewhere along the line.  But it's clearly true that vectors form an affine space over points.
10:08:49 <silasm> ah :S
10:09:17 <c_wraith> rio: actually, points don't form a vector space, either.  You can't add points together.
10:09:21 <iasoon> I guess Flora1 - Flora20 has been banned already
10:09:35 <glguy> You won't believe how vastly, hugely, mind-bogglingly big it is :)
10:09:54 <Hodapp> glguy: it's a long way down the road to the chemist though...
10:09:54 <rio> c_wraith: i'd say "points" are elements of some affine space, while "vectors" are elements of some vector space
10:10:05 --- mode: ChanServ set +o glguy
10:10:21 <rio> so you can add vectors, but can't add points
10:10:23 --- mode: glguy set +b *!*@5.254.104.*$#haskell-ops
10:10:38 --- mode: glguy set -o glguy
10:11:34 <c_wraith> rio: I suppose that is right.  Whoops, got my terminology backwards.  But regardless, I hate it when types don't prevent me from adding two points like that's an operation that makes sense.
10:18:23 <rio> c_wraith: well a vector space is always an affine space over itself, so in this case the elements are both vectors and points ;)
10:18:51 * hackagebot github-backup 1.20140721 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20140721 (JoeyHess)
10:29:23 <ph88> rio: http://codepad.viper-7.com/dRwjK3
10:29:46 <ph88> josephle: i was using a zip and a map, but why a fold ?
10:30:14 <rio> ph88: yeah i didn't mean the numerical results, i meant something like [4*exp(bla blub), ...]
10:30:52 <ph88> pjdelport: yes perfect, it's the same as the php program  ... i will have a look how you have constructed this !!
10:31:59 <jfischoff> Is there an pipes/conduit + mmap package out there?
10:32:35 <n3dr1n> Evening, anyone got any experience with sslstripping https so you can sniff the network and see the https pages in clear text? I've tried following securitytube's video but it seems like it's outdated, it's beeing done with Burp Suite, any video's would be appreciated
10:33:06 <ph88> rio: http://codepad.viper-7.com/pNEjeq
10:35:49 <ph88> i didn't know output of generators could have variables from outside
10:39:03 <adas> is there a way to cabal sandbox remove source?
10:39:55 <adas> cabal sandbox delete-source
10:40:15 <rio> > zipWith (*) [sum [exp(x*y) | y <- [0..2]] | x <- [0..2]] [4,5,6]
10:40:17 <lambdabot>  [12.0,55.53668963694847,377.9232367924493]
10:40:59 <ph88> nice one rio
10:41:00 <rio> ph88: ^
10:41:10 <ph88> someone else just gave this one, but yours looks nicer
10:41:12 <ph88> > let foo xs = let l = genericLength xs in zipWith (\k v -> sum [ v * (exp (k*i)) | i <- [0..l-1] ]) [0..] xs in foo [4,5,6]
10:41:14 <lambdabot>  [12.0,55.53668963694848,377.9232367924493]
10:42:03 <rio> ph88: i used v*a+v*b = v*(a+b) to simplify the calculation
10:42:03 <ph88> rio: why do you do * ?
10:42:09 <ph88> oh
10:42:52 <ph88> i'm not really seeing it
10:42:56 <adas> seems like i can't use delete-source
10:43:45 <rio> ph88: your second entry would be 5 * exp(1 * 0)+ 5 * exp(1 * 1)+ 5 * exp(1 * 2) for example
10:44:01 <rio> ph88: we can write that as 5 * (exp(..) + exp(..) + exp(..))
10:44:17 <ph88> i didn't know you can use variables from outside the generator in the generator output
10:45:05 <adas> apparently there is a problem with delete-source. the git issues page for cabal recommends against using it
10:45:10 <ph88> rio: since i'm new to haskell i would like to know how i can write this in several lines. I read about pattern matching, guards and where .. maybe that can be used ?
10:46:11 <rio> ph88: the essence of that expression is
10:46:12 <rio> > [[(x, y) | y <- [0..2]] | x <- [0..2]]
10:46:14 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)]]
10:46:25 <dfeuer> rio, did this turn into the algebra channel?
10:46:33 <ph88> rio: yes i understand the generator !!
10:46:41 <rio> dfeuer: maybe?
10:48:02 <rio> ph88: regarding "using something from outside in the generator": in [ ... | x <- xs ], you can use x in ..., that's all
10:48:17 <rio> in this case it happens that ... is another list comprehension
10:48:33 <adas> how do i determine if the package about to be installed will be installed from the sandbox source or from hackage?
10:48:48 <dfeuer> Speaking of such, what does Haskell call (^^^) where m^^^n is a list of all total functions from the list n to the list m?
10:49:01 <ph88> rio: why do you use in foo [4,5,6] at the end ? can i put that somewhere else ?
10:49:12 <rio> i don't
10:49:26 <ph88> ups sorry
10:49:30 <ph88> looking at wrong line :/
10:49:32 <dfeuer> downs not sorry
10:50:45 <ph88> rio: what if i want to split off the inner part   [sum [exp(x*y) | y <- [0..2]] | x <- [0..2]]   how can i refactor this to another line ?
10:51:18 <rio> define a function that takes 2 as an argument and returns that list of lists
10:51:46 <ph88> ok i will try, thx
10:52:21 <benzrf> dfeuer: do you mean the one that creates all permutations of a list
10:52:32 <adas> im about to install a dependency in a sandbox. i did a dry run and saw that the dependency is about to be installed. but how can i be sure that cabal will install the source version of the dependency added using add-source and not the one on hackage?
10:52:39 <benzrf> dfeuer: oh, i guess those are only equivalent when length m = length n
10:52:48 <dfeuer> benzrf, they're never equivalent.
10:52:59 <dfeuer> Unless n = 1 or something.
10:53:08 <dfeuer> n=1 or n=0.
10:53:28 <adas> should the dependency name be the same in the cabal file as when adding the source?
10:53:33 <benzrf> dfeuer: if you have a predefined ordering of m, a function from m to n is equivalent to a permutation of n
10:53:55 <rio> a function doesn't need to be injective, nor surjective
10:54:02 <rio> permutations are both
10:54:31 <dfeuer> Ezzackly.
10:55:18 <rio> dfeuer: overkill solution: take the powerset of A×B and filter for functions
10:55:59 <jarek> Hi
10:56:08 <benzrf> rio: i was assuming a bijection
10:56:08 <benzrf> oops :|
10:56:13 <jarek> is there any naming convention for variables that hold values of option type?
10:56:35 <benzrf> jarek: wat?
10:56:39 <jarek> like e.g. "maybeName" or "nameOpt" for a variable that holds user name
10:56:45 <merijn> benzrf: He means Maybe
10:57:03 <benzrf> jarek: how about just name
10:57:22 <merijn> jarek: I wouldn't bother, if it's passed along directly I'd do that, if it's used I'd pattern match and name something inside the Just
10:57:28 <dfeuer> rio, that is funny overkill.
10:57:29 <jarek> benzrf: is this this naming convention used in other languages that support optionals?
10:58:01 <rio> dfeuer: i guess expressing m^^^n in terms of m^^^(tail n) would give a nice recursive implementation
10:58:09 <jarek> I'm working with Swift and something like "if let name = name" looks confusing
10:58:10 <ph88> i used to have    main = do    and then i could use let and it was easy .. but i was told not to use a do block   .. since then i'm having a hard time to declare new functions
10:58:19 <jfischoff> jarek: I usually prefix it with an ‘m’ but I don’t know how common that is
10:58:51 * ocharles gulps
10:59:05 <glguy> ph88: It's perfectly find to use do-notation to define your main.
10:59:21 <ph88> bernalex told me not to ^^
10:59:24 <glguy> ph88: fine* Also you can declare top-level functions and call them within main
10:59:30 <merijn> It's perfectly fine to use do-notation everywhere, I just recommend beginners don't until they get comfortable writing without do notation
10:59:33 <ph88> ok
10:59:52 <bernalex> I told them to not have his entire program as a do block in main.
10:59:57 <bernalex> uhm s/his/their
11:00:07 <merijn> Ah, right
11:00:08 <glguy> ph88 is probably just one person
11:00:15 <glguy> also you can use "let ... in ..." when you're writing expressions
11:00:29 <merijn> glguy: Although you probably shouldn't >.>
11:00:29 <bernalex> glguy: in English, you say they/them about people, not it.
11:00:49 <bernalex> ph88: did you see my paste annotations? I did a few more steps for you yesterday.
11:01:04 <dfeuer> Indeed. ph88, one good thing to try is explicitly "desugaring" your do blocks. Figure out how you would write them without do.
11:01:10 <ph88> bernalex: i saw the annotations you made at first just before i left .. but i dont know if you made any more after those
11:01:22 <bernalex> ph88: if you have the link, you can just refresh it and see.
11:01:30 <ph88> dfeuer: i'm trying to figure out :P
11:01:40 <dfeuer> glguy, it's best not to make assumptions about gender; not everyone has one.
11:01:45 <ph88> http://lpaste.net/3751977451467571200
11:02:03 <ph88> damn you did a lot
11:02:05 <donri> bernalex: i like the elverson pronouns
11:02:18 <merijn> Can we take this out of #haskell?
11:02:49 <dfeuer> ph88,  do {x <- m; morestuff} = m >>= (\x -> morestuff)
11:03:06 <dfeuer> Er... sorry.
11:03:14 <bernalex> ph88: first I separated them into functions. then I added typesigs. that's it.
11:03:15 <ph88> x <- m ? i only know this from within [ ] generator block
11:03:18 <dfeuer>  do {x <- m; morestuff} = m >>= (\x -> do morestuff)
11:03:24 <bernalex> dfeuer: I'm not convinced we should be confusing them with do notation atm
11:03:40 <bernalex> dfeuer: they had their entire program as an imperative-looking thingy in main. there are other issues here.
11:03:45 <ph88> dfeuer: also >>=  never seen before
11:04:01 <dfeuer> bernalex, I think I did not recognize the relevant context. Sorry.
11:04:11 <bernalex> dfeuer: http://lpaste.net/3751977451467571200 is the program
11:04:14 <dfeuer> I did not mean to confuse.
11:04:19 <bernalex> NP
11:04:48 <ph88> bernalex: on the 3rd paste (2nd annotation) why do you don't declare all the stuff before main? but after main? it seems out of order
11:05:06 <bernalex> ph88: haskell is a parallel language. it does not really matter where things are
11:05:10 <dfeuer> I'm a pretty inexperienced Haskeller myself, so I tend to assume other people know as much as I do if not much more.
11:05:28 <bernalex> ph88: you can put it at the bottom if you want/if that makes more sense to you. :-)
11:05:35 <bernalex> ph88: have you read LYAH?
11:05:40 <ph88> do you write programs from bottom to top ?
11:05:51 <dfeuer> Yes, read Learn You a Haskell for Great Good!
11:05:56 <ph88> i've been reading http://learnyouahaskell.com/chapters
11:06:00 <ph88> chapter 1 to 8
11:06:22 <dfeuer> ph88, different people do things differently and the same people do things differently different times.
11:06:26 <bernalex> ph88: I use whichever style the program I am contributing to uses. it doesn't matter much to me.
11:06:31 <ph88> now i'm trying to practise. But for sure i didn't remember 100% on the first read/try
11:06:56 <benzrf> I/O in haskell works by building up 'actions' or 'plans'
11:07:17 <bernalex> ph88: maybe you should consider reading http://www.seas.upenn.edu/~cis194/ ? it has assignments for you, so you can exercise
11:07:19 <benzrf> when you write a do block you're specifying what should be done and getting a value representing that description as a result
11:07:22 <benzrf> ...sort of
11:07:46 <dfeuer> Commonly, but not always, Haskell modules look like Big idea 1 Big idea 2 Big idea 3 ..., where each Big idea looks like  Main point Supporting point 1 Supporting point 2 ...
11:07:54 <bernalex> a do block is just syntax sugar for composing functions.
11:08:09 <benzrf> bernalex: it is in the reader monad
11:08:11 <dfeuer> For composing actions.
11:08:33 <bernalex> dfeuer: one thing to note is that IO (and other potentially naughty bits) are usually separate from the other parts.
11:09:59 <kazagistar> benzrf: you could eliminate the "sort of" by saying "do block in the case of IO", right?
11:10:08 <dfeuer> Brief side note: the funny-looking type () is basically  data () = (), a type with only one good value.
11:10:42 <bernalex> () is unit. it is sort of like void if you know languages with that type.
11:10:47 <ion> Void = 0, () = 1, Bool = 2
11:11:02 <benzrf> data Unit = Unit
11:11:09 <benzrf> ^in this case Unit is both a type and a value
11:11:19 <benzrf> that's completely the same as () except with Unit instead of ()
11:11:19 <dfeuer> Important note: main is, or should be, a value of type IO().  You can think of the type IO t as the type of recipes for doing things that produce values of type t.
11:11:43 <dfeuer> So main is a recipe for doing something and producing something of type ().
11:12:41 <dfeuer> You can write recipes that produce things of various types and then put those recipes together to make super-recipes.
11:12:44 <benzrf> i think 'plan' works better than 'recpie'
11:12:46 <benzrf> *recipe
11:12:59 <dfeuer> benzrf, that's a good way of putting it.
11:13:17 <bernalex> I don't understand any of these analogies, so I don't see a point to them.
11:13:34 <benzrf> bernalex: tsk
11:13:49 <kazagistar> the "point" of () or Unit is that we can require an expression to be evaluated before it can be observed, so it bypasses the normal "pull only" nature of lazy evaluation to achieve side effects
11:14:41 <kazagistar> we need a value that acts as evidence that a system with a side effect actually executed, and then we can "pull" that evidence to request that execution
11:14:53 <dfeuer> The recipes are put together using one or a few operators. The simplest operator for doing that is >>.   plan1 >> plan2 is a plan: it's a plan that first follows the steps of plan1 and then follows the steps of plan2.
11:15:49 <dfeuer> A more general operator is >>=.  plan1 >>= f   is a plan: it's a plan to follow the steps in plan1 to get a result, apply the function f to that result to get a new plan, and then follow the new plan.
11:16:41 <ph88> bernalex: how can i split this up .. http://lpaste.net/4638867230061232128
11:16:41 <dfeuer> There's one more basic operator, return.  return makes trivial plans that don't do anything.  return 3, for example, is a plan: it's a plan to produce the number 3.
11:16:49 <rio> i never found any use in those kind of analogies
11:17:25 <dfeuer> rio, different brains need different kinds of explanations.
11:17:50 <rio> yeah, maybe i'm not the typical guy learning a language being a mathematician
11:18:02 <kazagistar> what is generally useful is not analgoies, but translations and examples
11:18:14 <benzrf> FOR EXAMPLE
11:18:18 <benzrf> getLine >>= putStrLn
11:18:29 <benzrf> getLine is an action or plan to get a line of input
11:18:34 <benzrf> it has type 'IO String'
11:18:42 <benzrf> putStrLn takes a string and returns an action that prints tha tstring
11:18:45 <benzrf> *that string
11:18:47 <bernalex> ph88: I don't think that makes much sense. [exp(fromIntegral(n)*fromIntegral(k)) | k <- [0..nL-1]] -- here you are using n, but you only specify what k is.
11:18:48 <dfeuer> Most normal people look at the monad laws and can understand them mechanically but cannot see the meaning behind them.
11:18:50 <benzrf> it has type 'String -> IO String'
11:19:06 <kazagistar> translations being "here is the paradigm you are used to, and here is what it is in the new form" and just as importantly "here is the new paradigm, and here is something similar in the old form"
11:19:17 <ph88> bernalex: ok so it's not the right solution ... but that first line of code .. i would like to split it up in several parts
11:19:17 <benzrf> getLine >>= putStrLn makes a new action that first runs getLine, then runs the result of putStrLn applied to the line you read
11:19:21 <dfeuer> benzrf, no it does not.
11:19:32 <benzrf> dfeuer: yes it does
11:19:41 <dfeuer> putStrLn :: String -> IO ()
11:19:46 <benzrf> oh wait derp
11:19:57 <benzrf> i thought you meant the 'makes a new action' bit
11:19:58 <bernalex> ph88: it would be better if you said what you are actually doing
11:20:06 <bernalex> ph88: i.e. what is this code supposed to do?
11:20:20 <ph88> that one line ?
11:20:26 <bernalex> ph88: yes
11:20:59 <ph88> i'm not sure what you are asking .. it does what it is supposed to do, give me this list of numbers: [1.41424,1226.3169273615465,1144961.4725869843,1.3283882859976106e9,-2.6043943853401746e11,-1.1290937460834593e15,-1.43536382857289e18,-1.8272066748148894e21]
11:21:23 <Ainieco> hello
11:21:26 <bernalex> ph88: what is the point of that? I'm sure they can be obtained otherwise.
11:21:41 <bernalex> not that I think that line of yours is particularly scary as is
11:21:53 <ph88> bernalex: they serve as a part of the program to calculate the discrete fourier transform
11:22:12 <RyanGlScott> I need to bind several things to the same value. In Java, I can use a = b = c = ... = z = 0; Is there something similar in Haskell?
11:22:40 <ph88> bernalex: see first two lines http://lpaste.net/3751977451467571200
11:22:43 <Ainieco> mkdir foo -> cabal sandbox init -> cabal install darcs -> conflict with deepseq and time. what's wrong? cabal sandbox should be clean slate, shouldn't it?
11:22:55 <bernalex> RyanGlScott: why on earth would you need that? I guess let a = 1; b = a; c = a; and so on.
11:22:56 <RyanGlScott> I could use let [a,b,c,...,z] = replicate 26 0, but it seems a bit hacky
11:22:58 <periodic> RyanGlScott: Normally you create multiple values to initialize them for later mutation.  In Haskell everything is immutable so why would you need different names for the same thing?
11:23:17 <ph88> bernalex: i would just like to know about this line how i can refactor it into two lines, functions ?
11:23:22 <Ainieco> is darcs broken globally and it doesn't depends on sandbox at all?
11:23:23 <RyanGlScott> periodic: I'm doing stuff involving Foreign.Ptr, so there are mutable in a way.
11:23:55 <jle`> if you have mutable references, you probably don't want to assign them all to the same pointer
11:23:55 * hackagebot stylish-haskell 0.5.10.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.10.1 (JasperVanDerJeugt)
11:24:00 <ph88> bernalex: i found it actually myself !
11:24:00 <dfeuer> RyanGlScott, that sounds very flaky.
11:24:02 <jle`> i would guess you'd want to assign them all to different pointers
11:24:07 <bernalex> ph88: OK, great
11:24:12 <jle`> and initialize every pointer to the same value
11:24:13 <RyanGlScott> Well, it would actually be replicate 26 nullPtr, I suppose
11:24:19 <periodic> RyanGlScott: Aaah, creating things in IO?  You might use something like [a,b,c] <- sequence $ replicate 3 newForgeinPtr
11:24:26 <ph88> bernalex:   singlePoint nL = [sum (oneSample n) | n <- [0..nL-1]]       2nd line:  where oneSample n = [exp(fromIntegral(n)*fromIntegral(k)) | k <- [0..nL-1]]
11:24:33 <jle`> sequence . replicate n = replicateM n
11:24:36 <periodic> RyanGlScott: I'll assume you're in the IO monad if there is mutation like that.
11:24:41 <bernalex> ph88: sure.
11:25:11 <RyanGlScott> periodic: Yeah, I am. I was wondering if there was a non-List way of doing it, since that seemed like a strange way of doing it :P
11:25:15 <dfeuer> You can't mutate the variables themselves (even unsafely), so you don't want to initialize them actually to the same value.
11:25:51 <adas> does cabal have the ability to automatically read git tags and infer version from the source?
11:26:01 <jle`> yeah, i'm not relaly sure what assigning them all to nullPtr would gain
11:26:18 <Ainieco> hello?
11:26:24 <jle`> you might as well name one of them nullPointer
11:26:26 <kazagistar> RyanGlScott: I am not familliar with Foreign.Ptr specifically, but wont that mean that a, b, c, d are all referring to the same pointer, to the same instance of Storable, etc?
11:26:49 <periodic> RyanGlScott: Well, in a more mutable language, if you were doing something like allocating memory you wouldn't write a = b = c = new Foo().  You'd do them all separately.  Which is what you'd do in Haskell too.
11:26:55 <RyanGlScott> Here, I'll post a link to the code I'm translating to Haskell
11:26:55 <jle`> Ainieco: do you cabal init first?
11:26:58 <glguy> Ainieco: darcs hasn't be updated since February 2013 and doesn't build with the current GHC
11:27:09 <bernalex> Ainieco: #darcs
11:27:14 <RyanGlScott> http://people.csail.mit.edu/albert/bluez-intro/x604.html#sdpdesc
11:27:17 <Ainieco> glguy: ah, thanks
11:27:53 <RyanGlScott> I have to call a bunch of functions which set values to pointers, so having a bunch of null pointers handy is useful (maybe necessary)
11:28:18 <jle`> RyanGlScott: those are seven different allocations on the stack
11:28:25 <kazagistar> I would expand periodic's excellent example to { a = b = c = new ImmutableFoo() } to be really explicit about the sillyness
11:28:33 <jle`> stting let a = 1, b = 1, etc. are seven different definitions
11:28:40 <adas> todays ignorecount is 4 so far : (
11:28:51 <jle`> adas: sorry, nobody is ignoring you :(
11:28:55 <jle`> adas: we might just not know the answer?
11:29:10 <bennofs> adas: what do you mean by "read git tags and infer version"? do you have an example?
11:29:17 <RyanGlScott> Except they're initially null, so they don't get allocated until passed until the scary-looking C functions.
11:29:18 <adas> yup. that must be the case. )
11:29:30 <bennofs> adas: so you can omit 'version:' from the cabal file?
11:29:34 <jle`> RyanGlScott: the *pointers* are allocated
11:29:41 <jle`> RyanGlScott: the thing they are pointing to are allocated later
11:29:44 <RyanGlScott> With nullPtr?
11:30:01 <RyanGlScott> I was under the impression it didn't do that.
11:30:02 <jle`> RyanGlScott: yes, there is a seperate slot on the stack for every pointer
11:30:11 <RyanGlScott> Oh, sorry, I read wrong
11:30:12 <jle`> and the value at every slot is initilized to zero
11:30:20 <RyanGlScott> Yes, that's right
11:30:24 <periodic> Yeah, if you say a = b = c = null; in C, then the compiler allocates three variables on the stack and assigns them all the same value.
11:30:32 <RyanGlScott> Right, that's my intention.
11:30:39 <jle`> later, things are allocated on the heap, and the pointers are mutated to point to those new things
11:30:39 <adas> bennofs: i meant, when i did cabal sandbox add-source moo and then did a dry run with 'moo==1.0' in the cabal file, cabal figured out latest is 1.1 and mentioned that in the dry run even though hackage only has version moo 1.0
11:30:43 <fread2282> help! cabal install --disable-documentation isn't working
11:30:55 <RyanGlScott> Absolutely.
11:31:11 <bennofs> adas: but I don't think cabal supports anything related to git. Because then it also had to support darcs, mercurial, bazaar, ... (too much)
11:31:13 <bernalex> fread2282: what does "isn't working" translate to?
11:31:22 <fread2282> still trying to build docs
11:31:27 <jle`> RyanGlScott: so the  equivalent of let a = b = c = d = 1 would be allocating a single pointer on the stack
11:31:30 <bennofs> adas: does moo have a moo.cabal with version:1.1?
11:31:44 <jle`> at is, allocating *a
11:31:44 <adas> bennofs: checcking
11:31:48 <jle`> and then creating a CPP macro
11:31:55 <jle`> #define b a, #define c a
11:31:57 <jle`> heh
11:32:10 <periodic> So I'd go with "a <- nullPtr; b <- nullPtr" or "[a, b] <- replicateM 2 nullPtr" (assuming nullPtr creates a mutable pointer)
11:32:19 <RyanGlScott> What concerns me about the "let [a,b,c,...,z] = replicate 26 nullPtr" approach is that it could be easy for it to manifest as a runtime error if the number is wrong.
11:32:32 <phaazon> hey
11:32:41 <phaazon> who knows John Goerzen?
11:32:43 <RyanGlScott> If, for example, I removed z, but it still replicated 26 times.
11:32:46 <periodic> RyanGlScott: then list it explicitly on each line.  That's the cleaner way to set up multiple names.
11:32:46 <phaazon> I’m seeking for him
11:32:56 <adas> bennofs: moo does have a moo.cabal file..but no mention of 1.1
11:32:57 <periodic> Looks like the C code does that basically anyway.
11:33:00 <RyanGlScott> Alright, I'll suck it up and do it that way then :)
11:33:08 <jle`> well, [a,b,c,..z] isn't going to work, syntax wise
11:33:18 <bennofs> adas: so it also has a version: 1.0 line?
11:33:27 <jle`> one thing you can do to be safe is
11:33:48 <jle`> hm
11:33:51 <RyanGlScott> Sorry, sequence $ replicate 26 nullPtr perhaps
11:33:51 <adas> bennofs: oops.. sory wait a minute.. it does have a line which says "version:          1.1"
11:34:01 <bennofs> adas: yeah, then that's what cabal uses
11:34:02 <jle`> sequence . replicate n = replicateM n
11:34:12 <RyanGlScott> Oh, that's handy
11:34:13 <kazagistar> RyanGIScott: the let version has the same problem that jle` is describing. Anything that uses nullPtr must be entirely referrentially transparent, in other words, similar to a simple macro
11:34:16 <benzrf> :t nullPtr
11:34:17 <lambdabot> Not in scope: ‘nullPtr’
11:34:24 <adas> oh okay.. so its has nothing to do with git tags.. Thanks for the clarification
11:34:33 <jle`> kazagistar: unless nullPtr is an IO action or something
11:34:33 <adas> i thought cabal was being smart : )
11:34:36 <jle`> we aren't totally sure
11:34:55 <kazagistar> jle`: I looked it up, and it is not, it is just data
11:35:10 <RyanGlScott> Speaking of macros, I noticed that tuple-th has a tupleFromList function which uses Template Haskell to make a tuple of a certain length from a list
11:35:10 <jle`> ah i see
11:35:11 <jle`> well then, yeah
11:35:34 <jle`> sorry :)
11:35:38 <RyanGlScott> That might possibly get around the partiality problem of the list pattern-match approach
11:35:44 <kazagistar> jle`: its instances are basically just Eq, Ord, Show, Storable, Typeable
11:35:53 <friden> #haskell, forkIO takes an IO (),spawns a thread, and returns the thread id. But how do i get the thread id from inside the thread? As the IO function is defined when spawning it i have no way of "sending" the pid in after it's begun to tick...
11:36:15 <jle`> friden: you can use an MVar?
11:36:22 <jle`> but there might be a better way
11:36:35 <friden> jle`: I dont know that that is sorry xd
11:36:38 <bennofs> friden: I think there is myThreadId or something similar
11:36:44 <friden> yeah i saw that one
11:36:46 <bennofs> @hoogle myThreadId
11:36:47 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
11:36:48 <lambdabot> GHC.Conc.Sync myThreadId :: IO ThreadId
11:36:48 <lambdabot> GHC.Conc myThreadId :: IO ThreadId
11:36:48 <friden> but it said GHC only
11:37:04 <friden> "Returns the ThreadId of the calling thread (GHC only)."
11:37:06 <jle`> RyanGlScott: you can do a:b:c:_ <- replicateM 3 stuff, and it'll "ignore" things if the list is too long
11:37:15 <jle`> will still runtime error if the list is to short
11:37:17 <friden> i dont know if that affects me, but it sounds like there is situations where it will not work
11:37:42 <bennofs> friden: GHC means it only is available when you use GHC to compile your code
11:37:47 <RyanGlScott> jle`: I'm starting to think I've overthought this whole thing. Listing out each thing is probably the safest and least hacky approach.
11:37:57 <jle`> RyanGlScott: probably  :)
11:38:18 <kazagistar> RyanGlScott: I suggest you do it the hard way first, and I think eventually you will figure out why it was not needed in the first place
11:38:31 <bennofs> friden: but as GHC is *the* major haskell compiler today, that might not be a problem (most people use GHC)
11:39:07 <RyanGlScott> kazagistar: Which are you referring as "the hard way"?
11:39:48 <friden> is it Clang that will "replace" ghc in a while?
11:39:58 <friden> ir whas it something else that clang was gonna replace? xd
11:40:19 <kazagistar> RyanGlScott: each assignment on its own line, IE, what you do if the a = b = c = 1 feature is not availible in a language
11:40:24 <dfeuer> friden, I think clang is a C compiler.
11:40:26 <friden> or what thas gcc...
11:40:27 <bennofs> friden: gcc is a C compiler, clang is a C compiler (which could therefore replace gcc) but ghc is a haskell compiler
11:40:50 <friden> yeah, things are falling into place now^^
11:41:02 <dfeuer> Clang will only replace gcc if clang continues to get better and gcc doesn't catch up.
11:41:12 <fread2282> which is happening
11:41:23 <fread2282> clang compiles are faster
11:41:38 <dfeuer> Too bad. It's nice when there's good competition.
11:41:38 <friden> i wrote an c compiler in haskell that outputed llvm assembler a while ago xd
11:41:40 <RyanGlScott> What is the status of clang right now? Can you fully substitute it for GCC with use in GHC?
11:41:55 <friden> think it used llvm and clang somewhere...
11:41:57 <bennofs> RyanGlScott: GHC doesn't use GCC
11:42:16 <fread2282> gcc's optimizations still win for  now though
11:42:31 <dfeuer> GHC outputs C-- or LLVM, I believe.
11:42:34 <RyanGlScott> bennofs: Eh? How come you need it when installing GHC and cabal's bootstrap.sh?
11:42:43 <bennofs> RyanGlScott: LLVM (which clang also uses) can be used as backend for code generation by GHC
11:42:49 <dfeuer> I know there used to be -fvia-c, but I don't know if that exists anymore.
11:42:55 <bennofs> RyanGlScott: because the haskell RunTimeSystem is written in C
11:43:20 <bennofs> RyanGlScott: and also because cabal contains C files which it calls via the FFI to bind to native system APIs
11:43:24 <RyanGlScott> bennofs: That's what I meant. I was curious about it, since I couldn't get GHC to use clang properly when installing GHC on FreeBSD.
11:43:26 <fread2282> -fllvm has better runtime speed than -fvia-C
11:43:38 <fread2282> IIRC even -fasm beats -fvia-C
11:43:38 <RyanGlScott> Maybe the situation is different in OS X.
11:43:40 <bennofs> fread2282: not always.
11:43:52 <fread2282> bennofs: :o
11:44:30 <bennofs> fread2282: -fllvm could also be slower than -fasm, because LLVM doesn't work too well yet with the kind of code GHC generates (explicit stack via CPS is a problem IIRC)
11:44:51 <rudi_s> bennofs: CPS?
11:45:06 <bennofs> rudi_s: continuation passing style
11:45:06 <merijn> Continuation Passing Style
11:45:13 <rudi_s> Thanks.
11:45:14 <friden> i love spinnoffs of random questions here in #haskell :D
11:45:19 <merijn> fread2282: -fvia-c is deprecated
11:45:34 <merijn> fread2282: It's only kept around for potential porting/bootstrapping other architectures
11:45:51 <dfeuer> Ah, it looks like -fvia-C does exist, but has to be compiled into GHC with special options, intended for use when porting GHC to a new platform.
11:46:05 <kazagistar> the situation with Clang on OSX as I experienced early this spring was "a clusterfuck of compiling bugs for libraries confusing clang and gcc" but I haven't used OSX for a while now
11:46:30 <fread2282> merijn: disabled on non-bootstrapping even
11:46:36 <RyanGlScott> kazagistar: Interesting. I thought my colleague claimed that he installed GHC on OS X with clang, but I could have mishead that.
11:46:40 <bennofs> I think -fvia-C is not maintained and it requires *much* work if you want to use it (not documented well either)
11:46:43 <ReinH> Woo new Haskell Cast with ocharles :D
11:46:49 <dfeuer> I would guess, without knowing, that -fvia-C is likely used little enough that the risk of bitrot is high, and you're probably better off using -fllvm for that purpose.
11:47:00 <fread2282> clang has some problems with following the standard and not GCC be default
11:47:02 <merijn> RyanGlScott: It's possible, just a bit of a hassle. GHC still uses gcc for CPP and clang's CPP is not compatible
11:47:11 <merijn> RyanGlScott: So it works, but any code using CPP breaks
11:47:12 <bernalex> ReinH: nice! I'm lagging on the casts, but now I'll have to get up to date for sure.
11:47:21 <ReinH> :)
11:47:29 <fread2282> s/be/by/
11:47:35 <geekosaur> clang's cpp partly works with the right options
11:47:42 <RyanGlScott> merijn: Ah, then I must have been imagining it, because I know for sure he's using CPP in Haskell.
11:47:45 <kazagistar> RyanGIScott: I think the problem was not with GHC itself, but with some libraries with FFIs that assumed GCC specific things on OSX, and then OSX removing support for GCC, not 100% sure
11:47:57 <fread2282> merijn: you can get it to work by following the standard instead of GCC or passing flags to clang
11:48:15 <merijn> fread2282: It's impossible to follow the standard
11:48:37 <merijn> fread2282: The standard is incompatible with valid haskell code, that's why GHC uses -traditional with gcc
11:48:50 <merijn> But clang's -traditional is not compatible with gcc's
11:48:53 <fread2282> merijn: oh
11:48:56 <bennofs> there is also an issue where cabal haddock results in the CPP being executed twice, and only GCC behaves in a way that GHC handles well
11:49:00 <joelteon> that's what cpphs is for
11:50:14 <Marquis> hello, i have a list of Tokens with the Type data Token = Int int | Bin int.  I want to save the indices of the Bin _ variables in a list. could you help me out with that task?
11:50:55 <joelteon> Marquis: [ ix | (ix, Bin _) <- zip [0..] myTokenList ]
11:51:26 <Marquis> looks good on first sight
11:51:30 <Marquis> i ll check that, thanks
11:53:21 <ph88> i'm trying to refactor my program into smaller functions, but i'm having problems with the Types. The program works with the single line  http://lpaste.net/1135522007975198720
11:54:24 <jle`> ph88: well...what's the problem?
11:56:49 <ph88> jle`: with output at bottom http://lpaste.net/2634338768189915136
11:56:51 <bergmark> ph88: RealFloat is a type class, not a type, try removing the type signatures and compiling with -Wall
11:58:02 <ph88> bergmark: i just use  runhaskell
11:58:21 <jfischoff> ph88: still applicable
11:58:49 <ph88> yes works that way!
11:59:18 <ph88> i would like to work with types
11:59:37 <ph88> i take this as reference http://learnyouahaskell.com/types-and-typeclasses
11:59:40 <fread2282> ph88: use ghci?
11:59:58 <ph88> fread2282: i have this written down in a file
12:00:09 <fread2282> ph88: :l filename
12:00:22 <jfischoff> ph88: or ghci filename
12:00:37 <jfischoff> or runhaskell -Wall filename
12:00:46 <kazagistar> ph88: do you know how typeclasses are written in function names? you should be able to ask the system for the type signature that it figured out, if yours is not correct
12:00:57 <jfischoff> which will print out the type an declaration without a type signature
12:01:21 * jfischoff can’t seem to write ‘any’ all the way
12:01:32 <ph88> kazagistar: no i don't know
12:01:53 <kazagistar> :t (/)
12:01:54 <lambdabot> Fractional a => a -> a -> a
12:02:08 <fread2282> (/) :: Fractional a => a -> a -> a
12:02:11 <ph88> jfischoff: it just prints out the results of the program, nothing else
12:02:21 <haasn> > [Left 1, Right 2, Left 3, Right 4] ^.. folded._Right.asIndex
12:02:23 <lambdabot>  [1,3]
12:02:36 * jfischoff checks runhaskell
12:02:44 <benzrf> 'folded'?
12:02:49 <benzrf> :t (^..)
12:02:49 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
12:03:02 <chaoyi> 3
12:03:05 <benzrf> > [1, 2, 3] ^.. traverse
12:03:06 <lambdabot>  [1,2,3]
12:03:09 <kazagistar> ph88: Fraction is a typeclass, "a" is a variable which represents any type for which an instance of Fraction has been declared (ie, it is something for which division makes sense)
12:03:30 <ph88> kazagistar: right yes that i knew .. i just figured out i can inspect function types _of a file loaded into ghci_
12:03:32 <benzrf> > [(1, 2), (3, 4), (4, 6)] ^.. (traverse . _1)
12:03:33 <lambdabot>  [1,3,4]
12:03:41 <benzrf> kool
12:03:44 <benzrf> :t folded
12:03:45 <lambdabot> (Contravariant f1, Indexable Int p, Foldable f, Applicative f1) => p a (f1 a) -> f a -> f1 (f a)
12:03:51 <fread2282> :i folded
12:03:56 <fread2282> @i folded
12:03:56 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
12:03:57 <jfischoff> ph88: Weird, it prints Top-level binding with no type signature: …
12:04:00 <Darwin226> Hey guys, I'd appreciate if someone could take a look at my code here: http://codereview.stackexchange.com/questions/57605/primitive-stack-based-code-interpreter
12:04:01 <jfischoff> for me
12:04:02 * benzrf flinches
12:04:03 <fread2282> :(
12:04:21 <ph88> kazagistar: if Fractional is a type class, what's a type and what's a concrete type ?
12:04:25 <fread2282> lambdabot needs :i
12:04:45 <ph88> or is a type the same as a concrete type
12:04:58 * merijn really dislikes the term "concrete type" it's so vague
12:05:37 <merijn> I prefer "monomorphic" or "type of kind *" to describe the relevant option
12:06:53 <benzrf> fread2282: write the parser for :i's output
12:06:55 <merijn> ph88: For example "a" or "Maybe a" are polymorphic types (they have a type variable), but "Int" and "Maybe Bool" are monomorphic (it just means the absence of polymorphism/type variables)
12:06:58 <benzrf> the rest is trivial :i
12:08:04 <bennofs> benzrf: lambdabot doesn't execute GHCi
12:09:07 <benzrf> bennofs: tell that to the code for :t
12:09:20 <bennofs> benzrf: wait, :t calls out to GHCi?
12:09:31 <benzrf> something along those lines
12:09:38 <bennofs> benzrf: I thought it used the GHC API
12:09:40 <merijn> Probably not
12:09:41 <benzrf> @google int-e lambdabot plugins-haskell
12:09:41 <lambdabot> https://github.com/mokus0/lambdabot/commits/master
12:09:44 <benzrf> hmm
12:09:45 <benzrf> 1 sec
12:09:47 <kazagistar> ph88: Int and Float are both instances of Num. They are also both instances of Show, Eq, Ord, etc. A type of kind * has potential values.
12:09:48 <merijn> I'm pretty sure it uses GHC API
12:09:50 <ph88> merijn: i don't see how "a" would explain what a type is
12:10:36 <merijn> That's a surprisingly tricky question to answer, now that I think of it
12:10:37 <ph88> Int is a type, and Num a typeclass ?
12:10:58 <merijn> Types describe the possible values of an expression
12:11:12 <benzrf> https://github.com/int-e/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Type.hs <- bennofs
12:11:32 <merijn> For example, if an expression has the type "Bool", we can conclude that it's only possible values are "True" and "False" (this is a white lie)
12:11:35 <ph88> is a type like an interface to a function then ?
12:11:48 <fread2282> ph88: "a" doesn't explan what type is it, but (Num a => a) is any type that has Num
12:11:50 <benzrf> ph88: i am not sure what you mean by that
12:12:05 <benzrf> ph88: a type is a description of what possibilities there are for a value
12:12:16 <ph88> ok ok
12:12:20 <benzrf> for example, the type Int denotes that it could be an integer
12:12:24 <bennofs> benzrf: :O that looks dangerous security-whise
12:12:30 <benzrf> bennofs: whise?
12:12:31 <benzrf> :p
12:12:36 <bennofs> s/whise/wise
12:12:38 <bennofs> :)
12:12:42 <benzrf> bennofs: hows it insecure
12:12:44 <dwcook> ph88, the other way around, really: for example, a function taking an Integer and returning another Integer would have type Integer -> Integer.
12:12:50 <kazagistar> ph88: a typeclass acts very similar to an interface from OOP, in the sense that it describes what you can do with it, but does not directly perscribe what it is
12:13:18 <jle`> ph88: i sometimes like to understand typeclasses as providing similar functionality as Interface from Java, except with with more expressible things
12:13:22 <benzrf> ph88: a typeclass indicates that there are some particular functions that you can call on it
12:13:40 <benzrf> ph88: a value with a Num constraint may be passed to abs
12:13:40 <bennofs> :t let a = join (,); b = a.a.a; c = b.b.b; d = c.c.c; in d
12:13:42 <jle`> ph88: so you can think of an Ord typeclass instance as something like Comparable from Java
12:13:44 <ph88> http://learnyouahaskell.com/types-and-typeclasses#believe-the-type     removeNonUppercase :: [Char] -> [Char]    so removeNonUppercase is of type "[Char] -> [Char]"  ??
12:13:46 <benzrf> but you dont necessarily know what the actual value is
12:13:59 <bennofs> benzrf: that could take a while for lambdabot to compute
12:14:04 <bennofs> > 1
12:14:06 <lambdabot>  1
12:14:16 <jle`> ph88: in fact I think that Ord can be implemented as an interface
12:14:26 <jle`> ph88: Num, however, can't be implemented as an interface
12:14:28 <kazagistar> { Num a => a -> a -> a } means "for any type that has a numeric interface, we can plug in that type for a in this function" more or less
12:15:14 <ph88> kazagistar: ok but there is 4x an a there
12:15:53 <ph88> can  "[Char] -> [Char]"  be a type ?
12:15:57 <monochrom> yes
12:16:01 <bennofs> benzrf: readProcessWithExitCode has no timeout in lambdabot, has it?
12:16:01 <merijn> ph88: It *is* a type
12:16:24 <ph88> what's  "[Char]" in type "[Char] -> [Char]"  ?
12:16:34 <ph88> another type ?  so a type in a type ?
12:16:34 <monochrom> list of Char
12:16:40 <monochrom> yes
12:16:45 <jle`> bennofs: int-e might have fixed it ;)
12:16:52 <ph88> ok things starting to become clear
12:17:11 <levi> ph88: The -> notation and [] notation are "syntactic sugar" for function and list types.
12:17:16 <monochrom> (x+y)*z is "expression in expression". why not allow the same to types.
12:17:25 <benzrf> ph88: '[Foo]' is basically 'List Foo'
12:17:29 <benzrf> ph88: List is like a function on the type level
12:17:32 <merijn> ph88: -> is the type constructor for functions, in other words "a -> b" is a function that takes a value of type "a" and returns a value of type "b"
12:17:33 <kqr> if i'm doing `instance FromJSON Person where { parseJSON (Object v) = Person <$> v .: "name"` where the field in Person is a ByteString, and I get "No instance for (FromJSON ByteString)", what am I missing? it looks like there should be such an instance
12:17:35 <benzrf> you apply it to a type and get back a new type
12:18:23 <merijn> ph88: So "[Char] -> b" is a function that takes a value of type "[Char]" and returns a value of type "b", and similarly "[Char] -> [Char]" is a type of a functions that also takes a value of type "[Char]", but this time returning a value of type "[Char]"
12:18:46 <ph88> sample :: (Floating t, Integral t1) => t1 -> t1 -> [t]      on the left of => are the type classes of types used to the right of =>   ?
12:18:53 <tech2> the amusing part is for functions with "multiple arguments" (if coming from another language background)
12:19:19 <supki> kqr: it was removed in aeson-0.7
12:19:22 <ph88> merijn: how can it return a value of type b when type b is not defined ?
12:19:26 <angerman> if I have `runhaskell` tell me: script.hs: Prelude.(!!): index too large, how do i figure out which line that was?
12:19:32 <kqr> supki, oh. any particular reason?
12:20:12 <tech2> ph88: takes something of type t1 (an integral), returns a function that takes an integral and returns a list of Floating
12:20:48 <kazagistar> ph88: that translates to something like "given that t is some type that has the interface Floating, and t1 has the interface Integral, this function takes two t1's and produces a list of [t], for all t and t1"
12:20:49 <fread2282> ph88: it can only run functions of type a, so it can run error and id only IIRC
12:20:57 <ph88> tech2: so => must especially be used when returning a function ?
12:20:58 <fread2282> :t error
12:20:59 <lambdabot> [Char] -> a
12:21:17 <fread2282> ph88: oh, the type of error is a lie
12:21:41 <levi> angerman: I'm not sure if there's a really easy way, but do you have a lot of uses of !! in script.hs?
12:21:48 <tech2> ph88: I suspect the => is only used to provide a shorthand way of stating the types of the arguments/return-values
12:22:16 <fread2282> ph88: error is not a real function, whenever the a is needed your program errors
12:22:16 <tech2> ph88: I don't know the word for that part of the syntactic sugar (parts of this language I get, others, not so much :) )
12:22:23 <angerman> levi: quite a bit. Does it help if I load it up in ghci and call the function from there?
12:22:36 <monochrom> "a->b" is not a good example. don't worry about it.
12:23:03 <kazagistar> tech2: it provides a shortcut for passing a record containing instances all the functions declared by the typeclass, automatically
12:23:27 <ph88> i' m just reading:   Everything before the => symbol is called a class constraint
12:23:37 <monochrom> yes
12:23:39 <levi> angerman: You might try the first answer here: http://stackoverflow.com/questions/6724434/how-to-debug-haskell-code
12:24:27 <tech2> given a function: sample :: a -> a -> b   can a == b or must they be different?
12:24:34 <angerman> levi: thanks, will give it a try.
12:24:43 <fread2282> ph88: it's actually a Constraint, it can do stuff other than classes
12:24:44 <levi> I try to avoid using partial functions like !! for just this reason.
12:24:49 <fread2282> :k Eq
12:24:50 <lambdabot> * -> Constraint
12:24:58 <lyxia> tech2: Yes they can be equal.
12:25:03 <donri> tech2: they can be the same type, but you can't know when they are
12:25:13 <tech2> lyxia, donri, thanks.
12:25:26 <kazagistar> ph88: the type { a -> a -> a } would promise to work for any possible type. The type { Int -> Int -> Int } works only for integers. The type { Num a => a -> a -> a } it the middle ground between the two, that works for multiple types, but requires they provide some interface so you can actually do something with them
12:25:30 <ion> donri: FSVO “you”
12:25:32 <donri> also not sure that function can return anything other than bottom...
12:25:45 <ph88> i think i finally figured it out. I'm thinking use types directly like so   [Char] -> [Char]   or if your input/output can be several types (of the same class) then use type constraint instead like so:  (constraint a) => a -> a
12:26:06 <fread2282> :k Int
12:26:06 <lambdabot> *
12:26:10 <fread2282> :k Eq Int
12:26:10 <lambdabot> Constraint
12:26:17 <supki> kqr: they were encoded as JSON strings, but JSON strings can only be valid unicode and not arbitrary bytes
12:26:31 <ph88> kazagistar: i think in case of type { a -> a -> a }  then all 2 input variable and 1 output variable must be of the same type
12:26:41 <fread2282> so Eq is a function that takes a type and gives you a Constraint
12:26:54 <levi> ph88: Sounds like you're getting the hang of it.
12:27:07 <ph88> levi: thx :P
12:27:12 <tech2> levi: aren't all functions partial, by definition (currying etc.)?
12:27:23 <kqr> supki, ah, i see. thanks
12:27:32 <ph88> how can i do a lookup of which type implement a certain typeclass ?
12:27:46 <int3__> I have written a bunch of code using FRP in threepenny, only to find out that it doesn't support dynamic switching, and that there seems to be little way around it other than to rewrite all my code in a non-FRP style (or use another library altogether). this is distressing.
12:27:56 <levi> tech2: Curried functions and partial functions are different things in math/functional programming terminology.
12:27:57 <fread2282> tech2: yea, haskell doesn't have totality checking
12:28:02 <ion> tech2: A partial function is something that returns bottom for a parameter that is not bottom.
12:28:15 <kazagistar> ph88: right, but there are very few possible functions that have type { a -> a -> a }, and most of them are not terribly useful, because there is nothing I can do with an { a } alone, other then pass it around
12:28:24 <tech2> ion: okay, so my lexicon fails me here, define "bottom" please?
12:28:44 <ion> tech2: Infinite loop or an exception. E.g. “head” when applied to “[]”
12:28:47 <fread2282> tech2:  infinite loop or error in the context of haskell
12:28:52 <tech2> thanks.
12:28:57 <monochrom> bottom = no answer
12:29:00 <ph88> also the other way around: how can i lookup all the typeclasses that a type implements ?
12:29:02 <levi> tech2: A partial function is one that's not defined for part of its domain, which in Haskell is the type of the first parameter.
12:29:02 <fread2282> there's a more formal definition though
12:29:09 <fread2282> ph88: :i <type>
12:29:17 <fread2282> in GHCi
12:29:22 <ph88> and from typeclass to types ?
12:29:29 <ion> Clarification: head is partial, “when applied to []” just demonstrates that.
12:29:29 <fread2282> :i <typeclass>
12:29:33 <tech2> fread2282: there always is, sadly I barely have time to read the abstract, let alone the entire dissertation.
12:29:39 <ph88> > :i Floating
12:29:41 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:29:48 <ph88> hmm
12:29:51 <merijn> tech2: bottom is logic/math terminology, it is the "least defined value", in programming languages this is synonymous with non-termination/crashing
12:29:57 <fread2282> tech2: which dissertation?
12:30:17 <fread2282> ph88: lambdabot doesn't do :i
12:30:28 <kazagistar> ph88: remove the >, you just use the :t or whatever directly
12:30:38 <merijn> kazagistar: Not with lambdabot
12:30:43 <levi> Was trying to type a good answer WRT bottom, but I think merijn nailed it.
12:30:46 <tech2> fread2282: sorry, a bad attempt at humour. Whenever I see a statement like "there's a more formal definition" in this channel, I'm assuming something explicit and longwinded, and likely a hard read.
12:30:48 <merijn> kazagistar: lambdabot only does :t, not :i or :k or anything else
12:30:58 <fread2282> tech2: haha
12:31:11 <kazagistar> :k []
12:31:11 <lambdabot> * -> *
12:31:18 <merijn> ooh
12:31:22 <merijn> lambdabot does :k now?
12:31:22 <kazagistar> it does :k just fine :P
12:31:31 <merijn> Does it do :kind! too?
12:31:35 <merijn> :kind! String
12:31:39 <merijn> awww
12:31:39 <haasn> Unfortunately not
12:31:43 <levi> It's done :k for a while; not sure how long.
12:32:07 <kazagistar> I dunno, it worked the first time I tried it, but I have only been around like half a year?
12:32:24 <merijn> > let x :: a; x = x in x -- bottom
12:32:27 <lambdabot>  mueval-core: Time limit exceeded
12:32:57 <trap_exit> what should I use? png-file or pngload for reading pngs in haskell ?
12:33:01 <merijn> tech2: Clearly that expression typechecks as any type, but never terminates
12:33:36 <monochrom> I still have to write my tutorial on denotational semantics
12:33:56 <ph88> i have a function  where haskell says it's of type  sample :: (Floating t, Integral t1) => t1 -> t1 -> [t]    why can't i define the type myself as  sample :: a -> b -> [c]  ??  error: http://lpaste.net/931558735552184320
12:33:56 <levi> If you would like to dig more into the idea of bottom as "least defined value", the idea comes to Haskell through the denotational semantics of programming languages, for which the subject of "domain theory" was invented, which builds upon "order theory" which is a long-established and widely used field of mathematics.
12:34:07 <merijn> tech2: If you think of types in terms of "sets of possible values" (for example "Bool" being the 2 element set of values "True" and "False") then "bottom" is a member of every set (or, more formally, it "inhabits every type")
12:34:35 <merijn> tech2: Getting rid of bottom means getting rid of unbounded recursion, which means you lose Turing completeness (this is not necessarily a big deal, though)
12:34:53 <kazagistar> tech2: the point of bottom is to give a simple way of notating the semantics of evaluation... for example { True || _|_ = True } while { _|_ || x = _|_ }
12:34:56 <trap_exit> what should I use? png-file or pngload for reading pngs in haskell ?
12:35:06 <merijn> tech2: As a bonus for losing that you (can) get totality (i.e. have a guarantee that every expression terminates)
12:35:23 <kazagistar> tech2: (_|_ being the symbol for bottom, more or less)
12:35:32 <ReinH> And a nicer category
12:35:42 <ReinH> (Cartesian closed)
12:36:12 <ReinH> so you get initial and terminal objects, which are totes useful
12:36:14 <merijn> tech2: For example, Untyped Lambda Calculus is Turing complete, but not total. Simply Typed Lambda Calculus is not Turing-complete, but it is total. Every expression terminates (obviously no Halting problem either)
12:36:47 <merijn> Languages like Agda and Coq are experimenting with "how close to Turing complete can we get while still being total"
12:37:03 <tech2> merijn: given that, what becomes more difficult to do/represent in a language with totality?
12:37:13 <kazagistar> tech2: it lets you notate exactly where evaluation should be skipped, basically, by expressing how certain functions interact in the presence of "potential failure" of some kind
12:37:42 <monochrom> a while loop with a custom-made condition is difficult to do in a total language
12:38:16 <RyanGlScott> Is there an easy way to convert a Word32 from big-endian to little-endian?
12:38:24 <kazagistar> tech2: regular expressions are an example of a simple "total" language
12:38:39 <monochrom> in other words satisfying both "interesting algorithm" and "write what you mean"
12:38:43 <merijn> kazagistar: Only "true" regular expressions, PCRE is not
12:39:11 <fread2282> ph88: you're using functions from Flating and Integral and returning a List
12:39:21 <fread2282> s/Flating/Floating/
12:39:36 <ReinH> merijn: the regular ones ;)
12:40:01 <levi> RyanGlScott: Depending on what you're doing, you might find Data.Binary helpful for dealing with endianness issues.
12:40:20 <tech2> monochrom: yes, but most loops I'm aware of (other than something simple, like iterating while true) have some form of terminating condition over an input (whether it's external input or a given iterable). Unless I'm misunderstanding? I understand that while True: ... whatever may be impossible, but is that actually _useful_?
12:40:49 <RyanGlScott> levi: Hm, binary seems a bit convoluted since it requires going through ByteStrings. I don't need anything incredibly efficient.
12:41:02 <pseudolio> tech2: The problem is getting the system to recognize that your condition is terminating.
12:41:52 <tech2> pseudolio: I guess I'd really have to come across the issue myself to recognise it (that and it's the end of the day and I'm tired, so maybe I'm not thinking about this correctly)
12:42:09 <RyanGlScott> But suppose I have to use Data.Binary. How can I make a Word32 -> Word32 conversion function with it?
12:42:21 <monochrom> write dijkstra's shortest path algorithm in a total language
12:42:42 <levi> RyanGlScott: If you look at the source to the endianness conversion functions, you can probably adopt them for your own use without the whole library.
12:43:09 <pseudolio> Is the endianness thing even well-defined.
12:43:13 <pseudolio> ?
12:43:18 <monochrom> write union-find in a total language
12:43:20 <merijn> RyanGlScott: Actually
12:43:37 <merijn> RyanGlScott: Check the networking library for host-to-network and network-to-host functions?
12:43:46 <pseudolio> You can assume a Word32 is big-endian, and compute what the corresponding little-endian version would be.
12:43:54 <pseudolio> But you don't necessarily know which it is.
12:43:56 <RchrdB> RyanGlScott, ah, why do you care about the endianness while it's in Word32 format? You should normally really only care about endianness when you're serialising or deserialising to byte-strings.
12:44:20 <levi> RyanGlScott: Data.Bits gives you the standard bit-manipulation operations, if you want to go in that direction.
12:44:24 <RyanGlScott> I'm dealing with UUIDs, which expect the opposite endianness of what the Data.UUID representation is.
12:44:55 <ph88> fread2282: yes i know ... but i think that   sample :: a -> b -> [c]   should match    anything -> anything -> anything inside a list
12:44:58 <levi> Data.Word has some byte swapping functions as well.
12:45:28 <fread2282> ph88: a != b != c, and a list can only have one type
12:45:31 <levi> Since base 4.7.0.0, anyway.
12:45:46 <RyanGlScott> levi: Ooh, let me try that.
12:46:00 <gamegoblin> Is there a way to get the number of bytes an object takes up in memory?
12:46:08 <RyanGlScott> levi: byteSwap32 is exactly what I needed. Thanks!
12:46:19 <ph88> fread2282: why is a != b  ?? there is no type defined for both a and b so they could be of the same type ??
12:46:46 <fread2282> ph88: they are variables so they can be the same type but you can't rely on that
12:47:06 <fread2282> @src fromString
12:47:06 <lambdabot> Source not found. Where did you learn to type?
12:47:30 <ph88> fread2282: of course i would like to have strict type definitions, but for my understanding of type declarations i would like to know why it throws an error on   a -> b -> [c]
12:48:29 <fread2282> ph88: what's the function?
12:48:42 <ph88> sample n nL = [exp(phi n k nL) | k <- [0..nL-1]]
12:48:48 <fread2282> :t phi
12:48:49 <lambdabot>     Not in scope: ‘phi’
12:48:49 <lambdabot>     Perhaps you meant ‘pi’ (imported from Prelude)
12:48:58 <ph88> phi n k nL = fromIntegral(k*n)
12:49:01 <monochrom> @let sample n nL = [exp(phi n k nL) | k <- [0..nL-1]]
12:49:01 <lambdabot>  .L.hs:149:21:
12:49:02 <lambdabot>      Not in scope: ‘phi’
12:49:02 <lambdabot>      Perhaps you meant ‘pi’ (imported from Prelude)
12:49:08 <monochrom> what is phi?
12:49:12 <ph88> ^
12:49:14 <fread2282> ph88: phi expects the types to be the same
12:49:32 <monochrom> also you have to write * for multiplication. haskell is not mathematica.
12:50:12 <ph88> monochrom: there is only one multiplications and * is used
12:50:26 <monochrom> ok, then I'll try again
12:50:46 <monochrom> @let {sample n nL = [exp(phi n k nL) | k <- [0..nL-1]]; phi n k nL = fromIntegral(k*n)}
12:50:48 <lambdabot>  Defined.
12:50:53 <monochrom> @type sample
12:50:54 <lambdabot>     Ambiguous occurrence ‘sample’
12:50:54 <lambdabot>     It could refer to either ‘L.sample’,
12:50:54 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:150:1
12:50:59 <monochrom> @type L.sample
12:51:00 <lambdabot> (Integral t1, Floating t) => t1 -> t1 -> [t]
12:51:01 <fread2282> :t L.sample
12:51:02 <lambdabot> (Integral t1, Floating t) => t1 -> t1 -> [t]
12:51:16 <fread2282> :t phi
12:51:17 <lambdabot> (Num b, Integral a) => a -> a -> t -> b
12:51:18 <monochrom> it is not a->b->[c]. at best it's a->a->[c]
12:52:01 <ph88> forget about the sample function. Since phi is the "lowest" function let's use this one because the problem happens here too.
12:52:12 <ph88> phi :: a -> b -> c -> d      phi n k nL = fromIntegral(k*n)
12:52:22 <ph88> Couldn't match expected type `b' with actual type `a'
12:52:25 <fread2282> :t (*)
12:52:26 <lambdabot> Num a => a -> a -> a
12:52:33 <fread2282> ph88: ^
12:52:44 <monochrom> perhaps it's a good time to harp my "not anything" rhetoric.
12:53:08 <ph88> fread2282: aha i understand, * demands both side to be of the same type
12:53:11 <ph88> interesting !
12:53:17 <monochrom> a type like "a -> b -> c" does not mean "anything -> anything -> anything". it's sloppy thinking.
12:54:19 <ph88> so maybe   a -> b -> c    is   anything -> anything but a -> anything but a or b    ?
12:54:35 <monochrom> a type like "a -> b -> c" means: suppose you're the author of "multiply :: a -> b -> c", and I'm the user, then I, not you, get to choose which type for a, which type for b, which type for c, at my call site.
12:55:05 <monochrom> I have the freedom to choose a=Int, b=Double, c=Float.
12:55:21 <monochrom> this may not be what your multiply code can actually support
12:55:25 <ph88> and also the freedom to choose a=Int, b=Int, c=Int  ?
12:55:37 <monochrom> yes, I have that freedom too.
12:55:41 <ph88> o_O
12:55:46 <monochrom> but it's my call, not yours.
12:56:05 <rio> hm, can there be something of type a -> b -> c anyway?
12:56:14 <ph88> then why does my program work without this declaration but    phi :: a -> b -> c -> d   breaks it ?
12:56:25 <ph88> phi n k nL = fromIntegral(k*n)
12:56:26 <monochrom> your code, in reality, may only support this: the two arguments must have the same type. then your type should be "a -> a -> c"
12:56:30 <rio> shouldnt the output type be something dependent on the input types?
12:56:31 <fread2282> ph88: GHC infers types
12:56:47 <triliyn> rio: having a function's return type be completely polymorphic isn't really possible, because then the user can request that you return a Void
12:56:56 <triliyn> Which you obviously can't implement
12:57:07 <monochrom> let me infer the type of phi for you
12:57:17 <ph88> phi :: (Integral a, Num b) => a -> a -> t -> b
12:57:18 <rio> yeah that's what i'm thinking, so reasoning about that case isn't very fruitful
12:57:33 <monochrom> you're doing k*n. this immediate says that they have the same type. it's a requirement of *
12:57:48 <ph88> yes im with you on that
12:58:06 <monochrom> let's use type variable "a" for it. so k::a, n::a.
12:58:23 <ph88> why not use k::a and n::b  ?
12:58:30 <monochrom> same type
12:58:49 <ph88> i just asked you   and also the freedom to choose a=Int, b=Int, c=Int  ?    you say yes
12:58:55 <ph88> so a and b can both be of type Int
12:59:03 * hackagebot cmdargs 0.10.8 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.8 (NeilMitchell)
12:59:11 <monochrom> the user also has freedom to choose unequal types. are you ignoring it?
12:59:28 <ph88> not in my eventual program of course not
12:59:34 <LysergicDreams> Is there a way to document Persistent's DB Models/Fields with Haddock?
12:59:59 <MP2E> I think a better question would be, why on earth do you need a -> b if you're immediately passing it to *?
13:00:04 <int3__> does anyone know of libraries aside from threepenny that provide a seamless interface between a web interface and haskell code? I really like that I don't have to explicitly serialize / deserialize my haskell data structures when talking to the browser
13:00:05 <MP2E> GHC is going to make it a -> a anyway
13:00:09 <monochrom> then you cannot give out that freedom
13:00:29 <ph88> i just like to know which rule i am breaking and why does this rule apply when i declare the type definition of   phi :: a -> b -> c -> d   for function  phi n k nL = fromIntegral(k*n)
13:00:56 <monochrom> k*n requires k and n to have the same type
13:01:18 <ph88> sure, but if a is of type Int and b is of type Int   then k and n are both of type Int
13:01:33 <ph88> i think a maps onto n   and b maps onto k
13:02:16 <monochrom> if you like Int so much, then write "phi :: Int -> Int -> t -> Int". the compiler will be happy.
13:02:20 <tech2> ph88: you don't need to specify the types though, ghc can infer a lot by itself, you could just say phi n k nL = fromIntegral(k*n)   and let it work out the signature.
13:02:22 <ruuns> Does someone regularly write a blog about haskell here? :)
13:02:52 <monochrom> I don't understand "a maps onto n".
13:03:05 <LysergicDreams> ph88: phi :: a -> a -> b -> c
13:03:54 <ph88> yes i understand this is the solution AND there are better practises !  but what i don't understand why the compiler refuses to un my program on   phi :: a -> b -> c -> d   for function  phi n k nL = fromIntegral(k*n)
13:04:04 * hackagebot hlint 1.9.1 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.1 (NeilMitchell)
13:04:22 <ph88> what rule am i violating here that it wants to throw this error   http://lpaste.net/931558735552184320
13:04:43 <geekosaur> ph88, your type signature asserts that a, b, c, and d can be different, but the function you gave it doesn't allow that
13:04:47 <tech2> ph88: because you've said to the compiler that a and b can be different types, but a function it calls disagrees, since it requires they be the same
13:04:48 <MP2E> Because phi becomes 'forall a b c d. a -> b -> c -> d' then you used (*) on a and b
13:05:00 <MP2E> (*) needs a and b to be the same, therefore compile error
13:05:08 <josephle> :t (*)
13:05:09 <lambdabot> Num a => a -> a -> a
13:05:25 <ph88> sorry that last paste is of the wrapping function. this is the actual error for  phi  http://lpaste.net/196751962203488256
13:05:47 <bergmark> typescript allows this (or maybe they fixed it now)
13:05:52 <ph88> aaahh
13:05:59 <MP2E> My point still stands
13:06:07 <bergmark> it resulted in boom crash
13:06:16 <tech2> ph88: worked it out? :)
13:06:21 <ph88> ok so it checks the type declaration at compile time AND the function on compile time
13:06:29 <ph88> i thought the function was only checked on runtime
13:06:32 <ph88> ok solved that one :P
13:06:34 <ph88> yes tech2
13:06:45 <ph88> very good
13:06:47 <ph88> i like this
13:06:48 <ph88> thx guys
13:06:50 <MP2E> Haskell is about catching errors as quickly as possible, so if it can catch something at compile-time it will
13:06:55 <ph88> monochrom thx too
13:06:58 <MP2E> type system is great for that
13:07:24 <MP2E> why wait til you run it anyway? :P
13:07:44 <ph88> i'm just learning the boundaries of what i can do and can not do :P
13:08:22 <bergmark> -fdefer-type-errors :-) :-O
13:08:49 <MP2E> I didn't know you could do that, though I'm not sure why you'd want to :P
13:08:52 <bergmark> still not sure why that's useful
13:09:18 <tech2> bergmark: it's friday and you just want to commit to the repo? ;)
13:09:51 <ph88> so here i am obligated to define typeclass Num for c because fromIntegral can only return values of this typeclass and no other class is allowed  http://lpaste.net/7636267319018127360
13:09:54 <bergmark> usually i just deploy things before i leave on friday, but adding that would be icing
13:10:04 <platz> bergmark: what if I want to infer a type in my editor in the top part of my file, but the bottom part is still unfinished?
13:10:34 <platz> not that I've tried that, but it seems like a plausible use case
13:10:40 <bergmark> platz: then i a typed hole, or just undefined
13:10:50 <bergmark> use*
13:10:58 <fread2282> also Data.Dynamic
13:11:10 <ph88> i think i'm starting to understand
13:11:12 <fread2282> Dynamic is safe though
13:11:20 * ph88 not sure if really breathing air
13:11:33 <platz> bergmark: yes that works, but might have to put a "lot" of undefineds
13:12:18 <bergmark> maybe yeah, but i like it that way, i usually do hole = undefined and don't add a type signature for it so i'll get a warning in case i forget to remove it
13:12:32 <bergmark> then gradually replace them with the actual implementation
13:13:16 <platz> bergmark: yep agreed - just trying to "sneakily" build an argument here against dynamic typing
13:13:20 <Tjr> RWH's FFI chapter shows how to treat C functions that return something by modifying a pointer. The proposed solution goes through the IO monad. How do I get rid of IO, especially when the C function modifies only one pointer?
13:13:57 <platz> I'm not sure undefined gives one the same experience, but it's a technique I quite like
13:14:28 <LysergicDreams> ph88: The fromIntegral function has a Num typeclass restriction on its output which gets considered when you use it in your function
13:14:32 <LysergicDreams> :t fromIntegral
13:14:33 <[swift]> Tjr: FFI is a situation where you may need to use unsafePerformIO
13:14:33 <lambdabot> (Num b, Integral a) => a -> b
13:15:13 * fread2282 prefers todo = error "TODO" w/ DEPRECATED pragma
13:15:14 <ph88> how can i add   constraint Num for c ?    phi :: (Num a) => a -> a -> b -> c     i tried (Num a, Num c)    and  (Num a -> Num c)
13:15:26 <[swift]> Tjr: (obviously whether that's a good idea depends on whether the C function is conceptually pure)
13:15:30 <jfischoff> Tjr: https://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Marshal-Unsafe.html
13:15:48 <Tjr> [swift]: is that socially acceptable within the haskell community?
13:15:49 <LysergicDreams> ph88: phi :: (Num a, Num c) => a -> a -> b -> c should work
13:15:59 <jfischoff> hmm “It is expected that this operation will be replaced in a future revision of Haskell."
13:16:10 <[swift]> Tjr: sure, it's inherently necessary
13:16:23 <Tjr> ok, good to know.
13:16:52 * davidfetter wonders which of (Foreign, Marshal, Unsafe) is the problem
13:16:53 <Tjr> jfischoff: Thanks, noted.
13:17:11 <ph88> thanks all !
13:17:18 <ph88> learned a lot
13:18:47 <Tjr> davidfetter: if I had to guess: the undefined behavior part.
13:19:14 <davidfetter> Tjr, ah, i can see how that would be a problem
13:19:19 <merijn> Tjr: Modifying something through a pointer *is* IO
13:19:30 * davidfetter ponders Gödel's Incompleteness
13:19:30 <merijn> Tjr: Modifying any state is inherently non-pure
13:20:02 <LysergicDreams> Is there a way to document Persistent's DB Entity/Fields with Haddock?
13:20:05 <jle`> perhaps...modifying the state of the CPU is the domain of a data structure encapsulating what instructions about CPU manipulation
13:20:28 <jle`> how did that what sneak in there
13:20:39 <Tjr> merijn: on the C side, agreed.
13:22:13 <EvanR_> modifying something through a pointer doesnt have to be IO, or impure from the perspective of one side of an interface
13:22:48 <[swift]> the way i think of it is that situations where 'unsafePerformIO' is appropriate are analogous to situations where 'mutable' is appropriate in C++. just as you use 'mutable' when you have code that is 'const' semantically but requires some mutation internally to work, you use 'unsafePerformIO' when you have code that is pure semantically but requires some IO internally to work
13:23:35 <[swift]> in both cases, the conventional wisdom is to avoid those features if you can, but sometimes they are the right tool for the job, and you shouldn't be shy about using them in those cases
13:23:58 <EvanR_> powerfulPerformIO
13:24:01 <EvanR_> ;)
13:24:32 <EvanR_> probablyBadPerformIO
13:25:07 <merijn> Tjr: I meant that if the C operation isn't pure, then calling that operation from haskell should be in IO. "Removing" IO tells GHC it's safe to execute the code 0, 1 or more times due to inlining, etc. if that's not true (because you modify state) you're asking for subtle bugs
13:25:29 <ChristianS> [swift]: what do you mean by "code that is pure semantically"? code seems to be stateless and free of side effects?
13:25:32 <merijn> EvanR_: accursedUnutterablePerformIO?
13:26:14 <merijn> EvanR_: (that one's real, btw)
13:26:23 <fread2282> ChristianS: example: bytestring. it uses pointers under the hood
13:26:29 <[swift]> ChristianS: code that does not perform any IO that's externally observable. (meaning, for example, that it's safe to call it an arbitrary number of times, as merijn mentioned)
13:26:50 <EvanR_> if im not mistaken, unsafePerformIO actions may also be executed concurrently by multiple threads
13:27:07 <Tjr> merijn: what about the case that I know exactly which spots the C code modifies, and initialize / restore their state before and afterwards? Can there still be surprises?
13:27:42 <[swift]> Tjr: EvanR_ pointed out a good one, if you're modifying *global* state
13:27:51 <fread2282> Tjr: maybe you should still use a mutex?
13:27:53 <[swift]> Tjr: state on the stack is fine
13:28:10 <Tjr> what is a mutex?
13:28:20 <EvanR_> i mean, if you have a thunk that may be evaluated by two threads depending on a race, they may both begin
13:28:29 <[swift]> you could use a mutex, but just keeping all state thread-local (preferably by keeping it on the stack) is vastly preferable
13:28:58 <EvanR_> so if your thing depends on global state, that is iffy
13:29:06 <[swift]> Tjr: does your C function just modify its arguments because it uses that as a substitute for multiple return values?
13:29:07 <EvanR_> x=x+1
13:29:27 <[swift]> tjr: that's a good example of a situation where unsafePerformIO is justified
13:29:40 <fread2282> if you call out the right way (the one that blocks the current thread, don't remember what one that is)
13:29:47 <Tjr> [swift]: that's the case I'm mostly interested in. At this stage, I'm not doing anything, I'm just reading RWH and wondering how to purify stuff.
13:30:16 <fread2282> Tjr: a mutex in haskell would be a http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TSem.html 1
13:30:49 <EvanR_> or withMVar
13:31:16 <fread2282> a mutex is a syncronization primitive that only lets one run at a time
13:31:23 <Tjr> RWH warns about code that is not reentrant. I never dealt with threading in C. How do I tell if C code is reentrant?
13:31:27 <Pythonfant> Does the haskell runtime allocate something on the stack and if yes what or is everything allocated on the heap?
13:31:41 <Tjr> fread2282: can I think of it as a lock?
13:31:52 <fread2282> Tjr: yep
13:32:11 <fread2282> but not associated w/ anything I guess
13:32:18 <jle`> Pythonfant: it uses a stack-like structure on the heap during evaluation, i believe
13:32:26 <fread2282> Pythonfant: everything that can be
13:32:56 <jle`> but that's only for evaluation...i think all data is actaully allocated in the heap
13:33:03 <pjdelport> Pythonfant: Haskell doesn't really have any intrinsic stack or heap in the imperative language sense.
13:33:22 <ffflexo> Hello, I’m trying to setup yesod and It doesn’t want to work. Trying Ubuntu 13.10/14.04 MacOs. In the end it is always cabal complaining about dependencies. Is there an OS + Tutorial which does work currently?
13:33:23 <[swift]> Tjr: in general code that is not reentrant is code that modifies global state.
13:33:34 <fread2282> Pythonfant: http://www.well-typed.com/blog/94/ explains it I think
13:33:45 * Tjr is astonished that knowledge about stack, heap, data segment, etc from MS-DOS days is still relevant.
13:33:45 <[swift]> Tjr: lots of C standard library functions are not reentrant, for example, because they manipulate errno, which is a global variable
13:33:56 <Pythonfant> fread2282: ok I'll read that and get back here if I still have questions, thx
13:34:04 <Pythonfant> thx to jle` and pjdelport aswell
13:34:19 <[swift]> Tjr: (though i believe newer libc's make errno thread local to avoid this problem. not sure - haven't had to deal with it in a while)
13:34:33 <pjdelport> Pythonfant: http://www.haskell.org/haskellwiki/GHC/Memory_Management might also interest you
13:34:40 <pjdelport> for how GHC does it
13:35:06 <fread2282> Pythonfant: but the stack is 60% memory in recent versions IIRC, haskell uses all the registers it can
13:35:36 <Pythonfant> ok thx
13:36:10 <fread2282> maybe it's 66%, I dunno
13:36:36 <Tjr> The debian package manager knows "provide", e.g. sendmail, qmail, exim all provide sendmail and can be installed as a drop-in replacement for client code.
13:36:36 <Tjr> How does cabal do this, i.e. how would I say my new package is a drop-in replacement for, say, Prelude?
13:37:01 <fread2282> Tjr: cabal doesn't
13:37:17 <MP2E> yeah there's no way to do that in cabal afaik
13:37:22 <Tjr> how come?
13:37:50 <Tjr> I'd expect that writing "better" replacement libraries is a problem that somebody else has had, before.
13:38:02 <fread2282> but if you want to use a new prelude you can do {-# LANGUAGE NoImplicitPrelude #-} import MyPrelude at the top of your file
13:38:13 <Tjr> prelude is just an example.
13:38:14 <fread2282> Tjr: cabal is a rather simple tool
13:38:32 <Tjr> then what do the pros use?
13:38:36 <fread2282> cabal
13:38:41 <kazagistar> Tjr: see backpack for possible future expansions to do something like this http://www.mpi-sws.org/~dreyer/papers/backpack/paper.pdf
13:38:50 <hiptobecubic> "cabal is not a package manager" is what everyone says
13:38:58 <fread2282> isn't backpack actually in the works now?
13:39:01 <Tjr> hipsterslapfight: that sounds like a sore excuse
13:39:24 <fread2282> http://plv.mpi-sws.org/backpack/ better website IMO
13:39:25 <kazagistar> "possible future" as in "its not stable enough to recommend for broad usage" afaik
13:39:47 <MP2E> if you want alternatives to cabal, there is nix
13:40:08 <MP2E> and cabal2nix so you don't have to do much writing of course :P
13:40:11 <fread2282> kazagistar: yea but I remember eyzang talking about it on reddit
13:40:18 <fread2282> nix rocks
13:40:53 <MP2E> yeah, I'm the type of user that hit cabal hell *a lot* and had like 5 different sandboxes for different situations
13:40:55 <Tjr> what is nix?
13:40:56 <MP2E> but no longer
13:41:14 * Tjr knows about Unix
13:41:19 <kazagistar> Tjr: but replacing a library with another is not really something that you want to do in the build system usually, the only time it is really useful is if you have two packages that want two versions of, say, "a hash function", and you could just make it one
13:41:24 <fread2282> *ezyang
13:41:53 <fread2282> Tjr: nix is the best package manager
13:42:02 <MP2E> nix is a purely functional package manager, there's also NixOS which is a Linux distribution created and managed by Nix http://nixos.org/
13:42:51 <fread2282> yep http://www.reddit.com/r/haskell/comments/28v6c9/backpack_an_mllike_module_system_for_haskell/cif3171
13:43:57 <kazagistar> hmm, does nix support the idea of interfaces then? the debian "provide" concept?
13:44:13 <earthy> kazagistar: well, yes and no
13:44:48 <MP2E> With nix expressions, it's not really so much an issue of whether the package manager provides it :) It doesn't explicitly, but the purely functional language you are using can allow for a slot like system
13:44:54 <earthy> kazagistar: nix basically takes an sha-1 hash of the exact sources used to build a certain package against, and makes sure that exact dependency gets installed
13:45:05 <Tjr> kazagistar: concrete usage case: there are various types, newtypes, ... for probability distributions scattered around hackage. Some demand that probabilities are Double, others let you use Fractionals. Some cannot handle constraints (ideal for monads), others can (ideal for an efficient implementation). And so on.
13:45:06 <Tjr> Before I publish something probability-related, I'd like to make some kind of "provides everything" so that my library will work with any other.
13:45:42 <Tjr> (I'm not promising anything, but it's a scenario worth answering.)
13:45:43 <kazagistar> earthy: that sounds like "very very much no"?
13:45:56 <fread2282> kazagistar: it can
13:46:04 <earthy> kazagistar: the trick is in the definition of 'exact sources' ;)
13:46:54 <earthy> and in its early incarnations, it was a full stop no
13:47:04 <earthy> but that's like... 8 years or somesuch ago
13:47:12 <kazagistar> ah, so you would define a source that contains logic like "Install one of these packages, and as part of the config, you can pick, or have a default, etc"?
13:47:13 <earthy> I haven't really kept tabs on nix since hten
13:47:24 <earthy> kazagistar: something like that yeah
13:47:27 <MP2E> pretty much
13:47:59 <earthy> kazagistar: and then once you've picked, that is hashed once more at install time
13:48:06 <earthy> iiuc
13:48:11 <kazagistar> so nix lets you write interfaces, but does not support them as a special case, and may or may not have libraries built to help for that case?
13:48:57 <earthy> I'm not aware of the libsupport currently, I know work has been done on it.
13:50:07 <kqr> hey, i have a more general design question. i'm reading configuration from a file, which includes a username and password. immediately after i've read said config file, i want to do a call to a function "Config -> IO Config" which replaces the username/password with a token you get from logging in. does anyone know how to best handle this? (when I tried, I got like 7 layers of case…of nesting due to all
13:50:09 <kqr> the little things that can go wrong)
13:51:04 <earthy> https://nixos.org/nix/about.html
13:51:16 <kazagistar> its sounds, though, like the idea of interfaces is exactly opposed to Nix philosophy... interfaces say "package is too specific, we need something more broad" while Nix says "package is too broad, we need versions to be independant to ensure exact builds"?
13:51:21 <fread2282> kazagistar: looks like no need so far, but you can "override" packages and give them a different package than what they call for in your global config
13:52:00 <fread2282> kazagistar: nix only requires the shaa on source downloads
13:52:12 <fread2282> everything else is automatically generated
13:52:50 <fread2282> kazagistar: if you "override" a package nix will notice it and rebuild everything that depends on it
13:53:10 <fread2282> kazagistar: #nixos
13:53:17 <kazagistar> gotcha
13:53:37 <kazagistar> nix is a project ill figure out in the near future :D
13:55:19 <fread2282> nix is really nice for say haskell development because it does *really* aggressive caching (no outputs are thrown away until you GC) and it's really easy to switch GHC versions
13:56:04 <kazagistar> kqr: case ... of nesting might be an Either in disguise? are the exceptions error cases, or cases where simple defaults exist or something?
13:58:23 <kqr> kazagistar, error cases (examples include failure to log in, failure to read the token and such)
13:59:09 <kqr> kazagistar, there are a lot of Eithers, but a part of me feels like I've been writing nothing but EitherT code lately so it feels like I must be doing something wrong
13:59:09 <kazagistar> kqr: and is there some pattern in how you deal with them?
13:59:54 <kqr> kazagistar, not that i've been able to find
14:00:51 <kqr> i remember seeing my pattern ("first read the config file, then use its contents to update it") somewhere though, but i can't remember where
14:01:00 <kqr> nor can i remember if that took care of error conditions, but it ought to have
14:02:20 <kazagistar> what do you do with error conditons, exactly?
14:02:33 <kqr> the process is like this
14:03:07 <kqr> sec
14:03:15 <kqr> i'll write it somewhere where i have access to more than one line
14:04:36 <dfeuer> Any idea why takeWhile is defined recursively instead of using foldr?
14:05:08 <dfeuer> Specifically, takewhile p = foldr go [] where go x rest = if p x then x:rest else []
14:06:18 <ruuns> maybe to avoid an additional abstraction? :)
14:07:34 <rio> maybe because that definition using foldr reads like crap? :)
14:07:41 <tromp__> the std definition is closer to its specification, hence more straightforward
14:08:42 <kqr> kazagistar, something like this: http://lpaste.net/1410127824446029824
14:09:18 <kqr> kazagistar, i'm prepared to drop step 2 and combine 6 ad 8 if that makes things simpler
14:09:28 <EvanR_> you need a goto monad now
14:10:44 <kqr> kazagistar, i guess part of the problem is that i'm trying to replace the username and password with a token, instead of having them coexist in the config... that necessarily creates another level of nesting
14:12:05 <RchrdB> EvanR, ContT? :)
14:12:19 <kqr> EitherT/ExceptT would work too I think
14:12:35 <kqr> but it feels like I'm pretty much only writing ExceptT code so I'm starting to think I might be doing something wrong
14:13:01 <kazagistar> I mean, lenses make nesting easy, but you might want to separate update out... Username -> Password -> ExceptT NetworkErrors IO Token
14:13:33 <kqr> i do use lenses, but they didn't seem to make anything easier in this case
14:13:41 <kqr> maybe that's just my lack of lens-foo though
14:14:01 <kqr> lens-fu*
14:14:03 <kqr> i guess
14:14:18 <EvanR_> RchrdB: i cant find it, but theres a BASIC monad
14:14:34 <RchrdB> I remember that.
14:15:43 <kazagistar> all I can say is that steps 5-8 seem like a natural EitherT
14:16:27 <RchrdB> EvanR, I'm not sure if http://hackage.haskell.org/package/BASIC-0.1.5.0 is it or not.
14:16:45 <EvanR_> haha
14:17:19 <kazagistar> yeah, thats it
14:17:39 <ruuns> basic monad, holy .. :)
14:17:40 <RchrdB> There was one *really* weird (Num) instance in it, for making the line numbers sorta work.
14:18:49 <EvanR_> seems like general do notation abuse
14:18:56 <EvanR_> very funny though
14:19:19 <EvanR_> a subset of this which lets you goto line numbers would probably be found useful ;)
14:19:36 <kazagistar> uhhh
14:20:49 <kazagistar> instance Num (FOR -> Expr a -> Expr b)
14:23:56 <jle`> lol
14:26:13 <kazagistar> so I guess "Num" instances are used to build "syntax tree constructing functions with tagged line numbers" or something horrible like that, genius
14:26:20 <EvanR_> > 3 4
14:26:22 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
14:26:22 <lambdabot>    arising from the ambiguity check for ‘e_134’
14:26:22 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
14:26:22 <lambdabot>    bound by the inferred type for ‘e_134’:
14:26:22 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
14:26:26 <EvanR_> aw
14:28:28 <asfp``> I need a compiler for the berkeley packet filter (BPF) in the linu kernel.  Is there an example of a simple compiler for a simple architecture that supports branching somewhere?
14:28:47 <asfp``> if not, what's a good approach?
14:30:14 <tac_> In Network.HTTP, the ResponseCode type is defined as (Int, Int, Int), but it doesn't really say what those Int's represent
14:30:18 <tac_> The docs say this: For easy pattern matching, HTTP response codes xyz are represented as (x,y,z).
14:30:30 <tac_> But that's not really helpful. Any help on what that means?
14:30:38 <merijn> tac_: HTTP response codes are three digits
14:30:39 <apples> each digit is its own Int, maybe?
14:30:45 <merijn> tac_: like 404, 200, 301
14:30:45 <levi> asfp``: I don't know of a Haskell compiler for it, but I think there's one in libpcap that you can use via tcpdump.
14:30:50 <tac_> is that really it? :X
14:30:55 <pjdelport> asfp``: I don't know, but maybe https://code.google.com/p/piffle/wiki/PiffleWiki is interesting
14:30:57 <merijn> tac_: I'd expect so
14:31:02 <tac_> all righty
14:31:12 <merijn> tac_: What else could it sanely mean?
14:31:15 <nschoe> tac_, I suppose it allows you to sort of based on categories : 4xx are errors for instance.
14:31:38 <tac_> Not the way I'd do it, but I guess it's what I get
14:31:40 <tac_> thank you
14:31:51 <EvanR_> "400"
14:32:22 <asfp``> pjdelport: thanks.  I think I need to find something simpler.
14:35:00 <pjdelport> HTTP status code should be (x,yz), if anything
14:36:48 <EvanR_> a three digit string is simple enough
14:37:13 <EvanR_> maybe a IsString instance
14:37:38 <EvanR_> definitely not an integer
14:39:08 <pjdelport> integer is fine too
14:39:15 <EvanR_> gross
14:39:27 <pjdelport> with (`divMod` 100) to split it :)
14:42:17 <EvanR_> you can encode any computable entity using integers ;)
14:42:44 <joelteon> you can encode any computable entity using zeroes and ones
14:42:49 <joelteon> i've heard
14:43:04 <EvanR_> well, a string of zeros and ones
14:43:13 <EvanR_> or one integer
14:43:47 <moghedrin> EvanR_: Two integers, if I'm not mistaken.
14:43:57 <djahandarie> joelteon, though a computer isn't proof of that.
14:44:16 <EvanR_> two integers can be mapped to one integer and back
14:44:54 <c_wraith> There is such a thing as a self-delimiting number.  You can encode arbitrarily many numbers into one number, reversably, with no prior knowledge of the numbers being encoded.
14:45:11 <joelteon> If you have a big enough piece of paper.
14:45:19 <c_wraith> yes, it needs to be very big.
14:45:55 <moghedrin> EvanR_: Ah, I see.
14:46:03 <moghedrin> EvanR_: Nevermind me, then XD
14:48:42 <EvanR_> c_wraith: interesting.... trying to find the AOL keywords for that
14:53:03 <c_wraith> EvanR_: You can imagine very primitive (inefficient) encodings easily, like..  you can store an arbitrary number of bit strings in one bit stream by doing something like unary encoding of the length of a bit string by a sequence of 1s, then a 0 as a terminator, then that many bits are the first bit string stored in the number, etc.  You can be way more efficient, but that gets the point across.
14:54:49 <tac_> What's wrong with the following lens code?
14:54:50 <tac_>  body ^? key "id" . _String
14:54:58 <tac_> oh
14:55:08 <tac_> I'm guessing it needs to be a String, not Text
14:55:11 <tac_> "    No instance for (AsValue Text) arising from a use of `key'
14:55:12 <tac_> "
14:56:18 <mokkake> hi, what's the quickest and most effective way to sort data types by comparing a field ?
14:56:30 <merijn> mokkake: sortBy + on
14:56:38 <merijn> :t sortBy
14:56:39 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
14:56:43 <merijn> :t comparing
14:56:44 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
14:56:48 <merijn> :t on
14:56:49 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:56:57 <merijn> :t comparing `on` fst
14:56:58 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ b -> a
14:56:58 <lambdabot>     Expected type: (b -> a) -> (b -> a) -> b -> Ordering
14:56:58 <lambdabot>       Actual type: (b -> a) -> b -> b -> Ordering
14:57:05 <c_wraith> Depending on the complexity of the extraction operation, a schwartzian transform might do better.
14:57:08 <c_wraith> :t comparing fst
14:57:09 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
14:57:09 <merijn> hmm
14:57:24 <c_wraith> merijn: comparing already incorporates on
14:57:27 <merijn> oh, right comparing already does that
14:57:46 <mokkake> comparing seems to do the trick, thanks!
14:57:53 <merijn> :t sortBy (comparing fst)
14:57:54 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
15:10:37 <tac_> Is there any HTTP library that both supports HTTPS and doesn't require understanding Conduit?
15:11:00 <tac_> apparently Network.HTTP does not meet those requirements
15:11:12 <joelteon> tac_: hang on, I think there is one
15:11:16 <joelteon> let me go find it
15:11:20 <tac_> ty
15:12:15 <joelteon> I opened an issue for it on Github but I can't figure out how to read through my old issues :/
15:13:45 <joelteon> tac_, I think this does TLS: http://hackage.haskell.org/package/wreq
15:14:00 <tac_> thanks joelteon. I'll give it a try
15:16:00 <Twey> All these years doing Haskell, and I just realized that (,) is a data constructor
15:16:15 <Twey> > let (,) x y = (3, 5) in x * y
15:16:16 <lambdabot>  15
15:16:59 <Zekka> Twey: It's also sugar IIRC
15:17:08 <Zekka> just like how (:) is a data constructor that comes with sugar
15:17:29 <Twey> The (x, y) syntax is sugar, yeah
15:17:30 <Zekka> After all, ((a, b), c), (a, (b, c)), and (a, b, c) are distinct, no?
15:18:13 <Twey> But I never realized that (,) was a constructor in its own right — I always assumed that the (x, y) syntactic sugar was the only way to match on pairs
15:18:23 <Twey> Don't know why; bit daft now I think about it
15:18:23 <benzrf> same
15:18:30 <Zekka> I wonder if this works
15:18:46 <Zekka> > let (,,) x y z = (3, 5, 7) in x * y * z
15:18:47 <lambdabot>  105
15:19:13 <Twey> Yeah, the higher tuple constructors are (,,), (,,,), (,,,,), &c.
15:19:46 <Zekka> Twey: I didn't actually know they were defined as constructors, though
15:19:59 <Zekka> (,)'s rules at least look like a natural extension of Haskell's syntax, but (,,)'s is obvious sugar
15:20:03 <Twey> Makes sense that they would be if (,) is :þ
15:20:20 <Zekka> ((,) could plausibly be an infix data constructor ignoring naming conventions)
15:20:31 <Twey> (,) and (,,) are just normal constructors (apart from using an otherwise disallowed identifier)
15:20:51 <Twey> It's the (x, y, z) syntax that's magic
15:20:57 <Zekka> I figured (,,) was kind of like the Rational thing
15:21:15 <Zekka> a wrapper function for a type with its own less obvious constructor
15:21:29 <Twey> Yeah, I think that's what I subconsciously assumed, too
15:21:32 <pjdelport> Haskell, where the plain is actually magic, and the magic actually isn't. :)
15:21:35 <tac_> hmm
15:21:40 <benzrf> same
15:21:44 <tac_> cabal failed to install one of wreq's prerequisites :(
15:21:59 <tac_> $ cabal install http-client-tls-0.2.1.2
15:22:00 <tac_>     Could not find module `Control.Monad.Trans.Except'
15:23:08 <Twey> Zekka: If (,) were a syntactically normal infix constructor, you'd be able to write: let x , y = (3, 5) in x * y
15:23:23 <Twey> > let x , y = (3, 5) in x * y
15:23:24 <lambdabot>  <hint>:1:11: parse error on input ‘=’
15:24:05 <Zekka> Twey: Don't you mean infix function?
15:24:14 <Zekka> You'd need a data declaration if it were a constructor
15:24:20 <Zekka> Oh, wait
15:24:23 <Zekka> I see what you mean
15:24:32 <Zekka> never mind, I completely misread your intent
15:25:22 <Twey> Well, you could write x , y = 3 , 5 generally
15:25:42 <gfixler> how can I zip lists that are in a list?
15:25:58 <gfixler> zip [[1,2,3],[4,5,6]]
15:26:07 <Zekka> gfixler: You can't do this in a typesafe way
15:26:18 <Twey> But you can ‘transpose’
15:26:20 <Zekka> The type would be different depending on how many lists are in the outer list
15:26:32 <Twey> > transpose [[1, 2, 3], [4, 5, 6]]
15:26:33 <lambdabot>  [[1,4],[2,5],[3,6]]
15:26:41 <gfixler> ah, transpose, of course
15:26:44 <Twey> (note the inner lists rather than tuples)
15:26:55 <gfixler> Zekka: makes sense
15:27:14 <gfixler> Zekka: actually, does it? aren't the contents of lists type-matched?
15:27:31 <Zekka> gfixler: I'll give an example
15:27:57 <Zekka> zipLists [[a, b, c], [d, e, f]] results in [(a, d), (b, e), (c, f)], right?
15:28:21 <Twey> ∷ [(a, a)]
15:28:35 <Zekka> zipLists [[a, b, c], [d, e, f], [g, h, i]] results in [(a, d, g), (b, e, h), (c, f, i)], though
15:28:45 <Twey> ∷ [(a, a, a)]
15:29:04 <Zekka> So in one case, we have zipLists :: [[a]] -> [(a, a)] ad in the other we have zipLists :: [[a]] -> [(a, a, a)]
15:29:19 <Twey> > transpose [[1, 2, 3], [4, 5]]
15:29:21 <lambdabot>  [[1,4],[2,5],[3]]
15:29:28 <gfixler> Zekka: I see - typesafe issues on the output
15:29:30 <Zekka> The value of the first argument, regardless of its type, determines the type of the result
15:29:30 <Twey> ∷ [?!]
15:29:52 <Zekka> Twey has another point, minding that it's resolved by the default behavior of zip
15:29:57 <Twey> You can do it with dependent types and therefore probably encode it into Haskell somehow
15:30:16 <Zekka> (which just shortens the longer list)
15:30:32 <Zekka> Or you can use a type where (a, a) and (a, a, a) are both members
15:30:37 <Zekka> which would be []
15:30:51 <Zekka> because a list can have any number of elements
15:30:56 <Twey> zipLists ∷ (as : [[a]]) → [Vec (max $ map length as) a]
15:31:01 <Twey> Or something
15:31:07 <benzrf> Twey: transpose?
15:31:17 <Twey> benzrf: Read up ☺
15:31:18 <Zekka> benzrf: See above
15:31:37 <Twey> But yeah, it's no fun.
15:31:43 <Zekka> he wanted zip, but typesafe zip between multiple lists is either interesting dependent types solution or just transpose
15:33:43 <gfixler> I'm new to the world of caring about types (Python day job)
15:34:43 <gfixler> Thanks, Twey and Zekka
15:34:49 <Zekka> No problem, best of luck
15:35:38 <Zekka> Obviously necessary to mention that just because it's not typesafe in Haskell doesn't mean that it's not typesafe in some other language
15:36:01 <Zekka> I just don't feel qualified to comment on languages like i.e. Idris where those things start to become possible to encoe
15:37:13 <gfixler> Zekka: Python doesn't care about anything
15:37:33 <gfixler> which, as I'm learning more and more about Haskell and types, is becoming increasingly creepy
15:37:53 <Zekka> Yeah, kind of irks me that a lot of languages go the 'not caring' route about types
15:38:23 <Zekka> I don't really want to claim that types are the only way to get static guarantees of safety but I feel like generally speaking it's something more languages should try to bring to the table
15:38:45 <gfixler> I do TDD, but when I look back through my tests, a lot of them are basically checking types
15:38:55 <gfixler> in Python, that is
15:39:23 <kazagistar> python cares that, at runtime, something in its attribute resolution system for an object has something tagged with the same name that you requested, and not much else
15:39:45 <Zekka> I actually used to write a ton of Python code but I kind of fell out of that
15:40:01 <tac_> gfixler: Dynamic typing will do that to ya
15:40:23 <kazagistar> the attribute resolution system usually is just "look in a dictionary, or in the dictionary of my parent classes", but there is a fuckton of metaprogramming hackery that you can build around most of it
15:40:45 <gfixler> kazagistar: been there
15:41:05 <kazagistar> including, in python 3, "compile time" typechecking, if you were so inclined and crazy enough :P
15:41:41 <Zekka> I used to do a lot of Python metaprogramming
15:41:55 <Zekka> oftentimes stuff like functions returning classes
15:42:13 <gfixler> I'm new, but I'm finding the combo [so far] of a good type system, laziness, recursion, and pattern matching to make for very small code
15:42:28 <Zekka> Basically I feel like Python doesn't really embrace the idea of "we're just manipulating tables"
15:42:32 <kazagistar> in python, there are type signatures that the language ignores, but that can be introspected, and you can add hooks into stuff at "class declaration time"
15:42:47 <kazagistar> Zekka: thats why lua is so fun :P
15:42:58 <Zekka> lately I've been toying with Clojure which I'm ambivalent about but which goes much further towards that extreme
15:43:19 <gfixler> Zekka: same here - I was very excited about Clojure at first, but it's being dampened by two things
15:43:20 <josephle> I'm pretty sure OOP is basically table manipulation. C++ doesn't hide this fact at all.
15:43:22 <gfixler> 1) Haskell
15:43:27 <gfixler> 2) all that Java craziness
15:43:58 <Zekka> josephle: I'm not sure if I'd equate those things but I'd say that's how it often ends up
15:44:15 <kazagistar> Simple Made Easy is a talk about clojure that inspired me to make the jump from imperative... to haskell
15:44:23 <Zekka> Generally when I think of OOP I think of 'operations on data are closely coupled to the data itself'
15:44:34 <gfixler> the Haskell community is a very chatty one, but it all feels like it's leading somewhere important
15:44:46 <josephle> Zekka, this is a jab at how OOP is implemented in general
15:44:57 <gfixler> the Java community is also highly chatty, but it all feels like thick implementation details that aren't changing me for the better
15:45:15 <tac_> to me, OOP is just "I feel uncomfortable if my language doesn't do it sorta like Java does"
15:45:21 <Zekka> Personally I'm a little skeptical of the Java community's thoughts on design, but probabl moreso than I ought to be
15:45:37 <gfixler> I've been moving from OO to FP this year, and the change is dramatic
15:45:46 <josephle> tac_: objective-C people might want to have a word with you
15:45:47 <gfixler> far smaller, more expressive code
15:45:52 <Zekka> it's probably partially prejudice but I feel like they've taken a lot of bad ideas and run with them
15:45:52 <gfixler> far better composability and reuse
15:46:03 <Zekka> Which is something a lot of people say about FP dudes, of course
15:46:08 <gfixler> and actually getting things done, instead of pacing for 3 months trying to figure out how to make something work right
15:46:11 <tac_> josephle: Objective C is the one where calling a method on a null variable results in null, right?
15:46:24 <kazagistar> Zekka: I think the idea is that OOP starts from the idea that "we start with a semantic model, and then build code close to it" and then just hopes that objects are simple and composable enough... or something
15:46:24 <benzrf> gross
15:46:44 <kqr> is it possible to accomplish "Either a b -> (a -> c) -> Either e c" with lenses somehow?
15:46:58 <Zekka> kqr: There's probably a Prism for left, not sure what it's called
15:46:58 <jle`> kqr: here does the e come from?
15:46:59 <josephle> tac_: heh, that is true. I never said Obj-C is good
15:47:04 <Zekka> oh, wait
15:47:05 <gfixler> kazagistar: I had 11 classes for a system I was building, and I spent months running into dead ends and writing volumes of code
15:47:06 <Zekka> what's the e
15:47:24 <kqr> oh wait... let me correct that signature
15:47:27 <gfixler> I finally started to see the patterns, and in one day it shrunk to 7 classes, then 5, then 3, 2, and in a huge surprise 1
15:47:39 <gfixler> and then a few weeks later I realized the whole thing just needed to be a few maps
15:47:40 <jle`> gfixler: hopefully it can be 0 ;)
15:47:46 <jle`> ah, i spoiled the ending
15:47:46 <benzrf> gfixler: lol
15:47:46 <gfixler> jle`: yep!
15:47:50 <gfixler> :)
15:47:56 <gfixler> I moved the methods out to functions
15:47:57 <kqr> is it possible to accomplish "Either a b -> (a -> b) -> Either e b" with lenses somehow?
15:48:08 <gfixler> and it all became so beautifully reusable and simple
15:48:17 <Zekka> kqr: Sounds like catchError to me
15:48:19 <kazagistar> kqr: what is the e? where would it come from?
15:48:20 <Zekka> :t catchError
15:48:21 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
15:48:27 <kqr> kazagistar, polymorphic in the e
15:48:30 <gfixler> I've had a toy dataflow idea that I've pecked at for 6+ years
15:48:31 <benzrf> kazagistar: do you mean Either Void b?
15:48:34 <gfixler> could never get it to work nicely
15:48:36 <benzrf> err, kqr
15:48:39 <Polarina> kqr, why not just { \(Left a) f -> Right $ f a } ?
15:48:40 <Zekka> kazagistar: Seems to me like the idea is that you always end up with a Right
15:48:41 <kqr> kazagistar, since it can only return Right whatever
15:48:48 <gfixler> then one night this year I thought "Wait... do I just need a map?"
15:48:56 <kqr> Polarina, in my real case it's buried a few levels down in a data structure
15:48:57 <gfixler> by the end of the next day I had the whole thing working
15:48:59 <Zekka> Polarina: Because that dies on Right?
15:49:07 <benzrf> kazagistar: how about 'either (Right . f) Right'
15:49:08 <gfixler> tiny, solid, and I even implemented a bunch of things I was worried I wouldn't be able to figure out
15:49:20 <benzrf> :t \f -> either (Right . f) Right
15:49:21 <lambdabot> (a -> b) -> Either a b -> Either a1 b
15:49:23 <gfixler> it's all wonderful, but makes me feel like I wasted so much of my life on OO
15:49:24 <Zekka> kqr: Can't you go that deep into the data structure and then %~ Either (Right . f) Right?
15:49:26 <Polarina> Zekka, how would you satisfy the type { Either a b -> (a -> c) -> Either e c } otherwise?
15:49:43 <Zekka> Polarina: I wouldn't: he posted a corrected type.
15:49:50 * Polarina must've missed that.
15:49:53 <Zekka> he meant Either a b -> (a -> b) -> Either e b
15:49:57 <Zekka> But with the old type I'm on your side
15:50:51 <jle`> we should have a non-polymorphic (&&&) or (***) somewhere in base
15:50:58 <jle`> we have either
15:51:05 <kqr> Zekka, that's close to what i'm doing currently. maybe that's as good as it gets
15:51:05 <jle`> so we should also have its dual
15:51:08 <Polarina> How about { \e f -> either f id e } ?
15:51:41 <Polarina> Scratc that.
15:51:44 <Zekka> Polarina: Not sure but I don't think that has the right type
15:51:53 <Zekka> benzrf's is close but with the wrong argument order
15:52:04 <kazagistar> kqrfunc e f = Left $ either f id e
15:52:05 <Zekka> \x f > either (Right . f) Right x
15:52:12 <jle`> analogous to (&&&) we have (|||), but nobody uses (|||) because we have either
15:53:07 <Cale> jle`: There's uncurry...
15:53:09 <benzrf> Zekka: oh?
15:53:20 <benzrf> :t (|||)
15:53:20 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
15:53:26 <Zekka> benzrf: It's a minor thing -- he wanted the function to be the second argument, not the first
15:53:27 <benzrf> ah
15:53:28 <kqr> closer to what I really have: Either a b -> (a -> Maybe c) -> (a -> c) -> Either a c
15:53:29 <kqr> if that helps
15:53:30 <jle`> Cale: i'm talking about an (a -> b) -> (a -> c) -> (a -> (b, c))
15:53:56 <kqr> whoops
15:54:00 <kqr> closer to what I really have: Either a b -> (a -> Maybe c) -> (b -> c) -> Either a c
15:54:04 <jle`> the dual of (a -> c) -> (b -> c) -> (Either a b -> c)
15:54:06 <kqr> that should be better
15:54:45 <jle`> or maybe i should say (b -> a) -> (c -> a) -> (Either b c -> a)
15:54:56 <jle`> to make it fit nicer with (a -> b) -> (a -> c) -> (a -> (b, c))
15:55:08 <kqr> i was hoping you could focus on the _Left side without losing the ability to assign to the greater whole (to be able to change the Left into a Right)
15:56:09 <kqr> but i might just be rambling at this point
15:56:12 <jle`> kqr: i'm not sure that would be a structure-preserving thing
15:56:13 <kqr> i should really catch some sleep
15:56:18 <jle`> so if it was a prism or lens it might be unlawful
15:56:25 <kqr> yeah, maybe
15:56:28 <jle`> ...not that i know too much about prism/lens laws
15:56:39 <kqr> a little intuition goes a long way!
15:56:53 <jle`> that's the hope!
15:57:18 <Zekka> If you could join Either (Either a b) b into an Either a b you could do it
15:57:36 <Zekka> unfortunately join :: Either a (Either a b) -> Either a b
15:57:38 <jle`> @djinn Either (Either a b) b -> Either a b
15:57:38 <lambdabot> f a =
15:57:38 <lambdabot>     case a of
15:57:38 <lambdabot>     Left b -> b
15:57:38 <lambdabot>     Right c -> Right c
15:58:07 <Zekka> So we want this bifunctor to be a monad over its first argument instead of its second
15:58:23 <Zekka> Don't ask me what that sort of structure is called!
15:59:01 <Zekka> (note -- by 'you could do it', I mean 'you could do it, afterwards unsafely turning your Either a b into an Either e b')
15:59:21 <Zekka> (which in general you would not do, if you're trying to generalize this variation of binding)
15:59:45 <bennofs> :t over swapped (join . fmap (view swapped)) :: Either (Either a b) b -> Either a b
15:59:46 <lambdabot> Either (Either a b) b -> Either a b
16:00:25 <Zekka> http://stackoverflow.com/questions/13556314/biapplicative-and-bimonad <- this dude's typeclasses might be a step in the right direction
16:00:33 <jle`> :t either id Right
16:00:34 <lambdabot> Either (Either a b) b -> Either a b
16:00:44 <bennofs> oh man, I overcomplicate things :P
16:01:07 <jle`> :P
16:01:39 * JHaas is away: Away = | garbage_collect |  idle_cycle | sleep_mode
16:01:49 <ReinH> So who all's going to LambdaJam?
16:02:25 <benzrf> @tell JHaas i do not think your away message is valid code
16:02:25 <lambdabot> Consider it noted.
16:02:44 <jle`> @let f <,> g = \x -> (f x, g x)
16:02:44 <lambdabot>  Parse failed: Parse error: ,
16:02:53 <JHaas> benzrf, no it's not
16:02:53 <benzrf> :t (<.>)
16:02:54 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
16:03:00 <benzrf> pfft
16:03:01 <JHaas> benzrf, not for haskell
16:03:03 <benzrf> i propose
16:03:15 <benzrf> @let f <.> g = fmap f . g
16:03:16 <lambdabot>  Defined.
16:03:36 <benzrf> then you can write something like
16:03:39 * tac_ would like to have gone to LambdaJam
16:03:45 <tac_> ReinH: are you located in Chicago?
16:03:50 <JHaas> I'll have to change it, then benzrf
16:03:58 <benzrf> (+1) <.> (getLine <=< readLn)
16:04:04 <benzrf> wait wrong type for (<=<)
16:04:05 <ReinH> tac_: No, but I am en route.
16:04:09 <bennofs> Velpoman: r
16:04:18 <ReinH> I will be loced in chicago in about an hour.
16:04:19 <tac_> ReinH: cool
16:04:22 <ReinH> *located
16:04:24 <ReinH> tac_: agree!
16:04:25 <bennofs> benzrf: that operator isn't even symmetric in the type
16:04:33 <benzrf> bennofs: i know
16:04:37 <jle`> :t (<.>)
16:04:38 <lambdabot>     Ambiguous occurrence ‘<.>’
16:04:38 <lambdabot>     It could refer to either ‘L.<.>’,
16:04:38 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:151:3
16:04:42 <tac_> ReinH: you have to buy tickets in advance, right?
16:04:43 <benzrf> bennofs: that's the point
16:04:46 <aphury> Hello! This might be a dump questiom but: Can I use the fastcgi lib with mod_fcgid instead of mod_fastcgi ?
16:04:47 <jle`> :t (L.<.>)
16:04:47 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
16:04:48 <tac_> and they were like 100$+
16:05:03 <benzrf> bennofs: i keep finding myself wanting to write 'opOnA . aToFA'
16:05:06 * JHaas is away: Away = { garbage_collect ;  idle_cycle ; sleep_mode }
16:05:07 <jle`> i think they're like $400
16:05:08 <bennofs> benzrf: why not: (<.>) = liftA2 (.) and then pure (+1) <.> (....)
16:05:14 <tac_> o_____O
16:05:17 <JHaas> benzrf, happy?
16:05:22 <benzrf> bennofs: i think that's the wrong type
16:05:25 <benzrf> JHaas: ;)
16:05:30 <benzrf> you're using snake_case though
16:05:35 <benzrf> which is in fact superior to camelCase
16:05:37 <benzrf> but not haskell convention
16:05:43 <bennofs> benzrf: note the *pure* (+1)
16:05:45 <benzrf> :t liftA2 (.)
16:05:46 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
16:05:50 <benzrf> bennofs
16:05:54 <benzrf> :t (L.<.>)
16:05:55 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
16:06:02 <benzrf> the *result* of the 2nd arg is a functorial value
16:06:12 <benzrf> f <.> g = fmap f . g
16:06:13 <bennofs> ah i see
16:06:18 <benzrf> so you can write
16:06:30 <benzrf> pointful name = (+1) <$> getUser name
16:06:34 <bennofs> ah, so (>=>) . (return.)
16:06:40 <bennofs> :t (>=>) . (return.)
16:06:41 <benzrf> pointfree = (+1) <.> getUser
16:06:41 <lambdabot> Monad m => (a -> b) -> (b -> m c) -> a -> m c
16:06:47 * JHaas is away: let Away = { garbage_collect ;  idle_cycle ; sleep_mode }
16:06:49 <benzrf> bennofs: no...
16:06:51 <bennofs> ok, nearly
16:06:54 <benzrf> ha
16:07:01 <bennofs> :t (<=<) . (return.)
16:07:02 <lambdabot> Monad m => (b -> c) -> (a -> m b) -> a -> m c
16:07:09 <benzrf> yeah
16:07:10 <bennofs> just for APplicative
16:07:15 <benzrf> no, for Functor
16:07:19 <benzrf> f <.> g = fmap f . g
16:07:22 * benzrf smacks bennofs 
16:07:27 <benzrf> obviously you can also do
16:07:29 * bennofs should really go sleep
16:07:35 <benzrf> pointfree = fmap (+1) . getUser
16:07:39 <benzrf> but then it confuses non haskellers less
16:07:50 <ReinH> tac_: yeah
16:07:57 <ReinH> tac_: are you in Chicago?
16:08:00 * JHaas is away: let Away = { garbage_collect ;  idle_cycle ; sleep_mode }
16:08:07 <tac_> I am.
16:08:11 <benzrf> JHaas: you cannot let data constructors you boob
16:08:17 <tac_> but I will not be attending lambdajam
16:08:18 <benzrf> oh wait, i guess you could be pattern matching
16:08:36 <JHaas> ffs
16:08:38 <JHaas> benzrf, http://msdn.microsoft.com/en-us/library/dd233184.aspx
16:08:47 <JHaas> with that, adieu
16:08:49 * JHaas is away: let Away = { garbage_collect ;  idle_cycle ; sleep_mode }
16:08:52 <benzrf> JHaas: >f#
16:08:55 <jle`> > let Nothing = Just 4 in 10
16:08:57 <lambdabot>  10
16:09:00 <benzrf> >microsoft proprietary nonsense
16:09:11 <ReinH> "you boob"?
16:09:12 <bennofs> JHaas: put a do in front of that: let Away = do { ... }  -- now working in the Away monad and pattern matching on it
16:09:14 <benzrf> ReinH: i dunno
16:09:19 <ReinH> tac_: hallway track?
16:09:21 <benzrf> ReinH: lambdabot had a 'quote the Brain' feature
16:09:24 <bennofs> then it's even valid haskell!
16:09:29 <ReinH> tac_: beers?
16:09:30 <benzrf> it included 'it must be inordinately taxing to be such a boob'
16:09:36 <benzrf> and i started using it elsewhere x.x
16:09:36 <tac_> ReinH: no plans at all to attend in any capacity
16:10:01 <haasn> bennofs: A better idea would be to disable away messages
16:10:18 <bennofs> haasn: ofc, that too
16:10:40 <benzrf> i like how erlang does the exact opposite of haskell w.r.t. capitalization of variables and atom-ish things
16:10:44 <ReinH> tac_: what about beers?
16:10:53 <ReinH> Or $DRINK_OF_CHOICE
16:10:56 <tac_> heh
16:11:11 <ReinH> benzrf: Erlang does the exact opposite of Haskell in a lot of ways ;)
16:11:25 <tac_> I can't say there will be a lot of Haskellers, but I have been slowly trying to convert my local hackerspace to the wonders of Haskell
16:11:28 <tac_> (it hasn't been working)
16:11:33 <ReinH> haha
16:11:45 <tac_> if you wanted to show up and preach with me, feel free to stop by
16:12:09 <benzrf> i looooooooooooove preaching
16:13:04 <Zekka> I think my friends get a little sick of me: I talk about Haskell pretty often
16:13:25 <tac_> Oh wow, the Hotel is pretty far south
16:13:44 <[swift]> Zekka: it's understandable. for me, Haskell was the most fun i'd had programming in many years
16:14:02 <tac_> Zekka: yes. I think many of us know that experience.
16:14:16 <tac_> Functors and Applicatives and Monads (Oh my!)
16:14:39 <Zekka> At least one of my friends has started grudgingly working in Haskell, although I don't think he likes it
16:14:42 <jle`> tac_: that happened to me too
16:14:47 <jle`> ...
16:15:05 <merijn> benzrf: FYI, you're wrong about not being able to let constructors
16:15:10 <lamer14059110540> Are there any online Haskell courses? I mean live courses with instructors and help and such?
16:15:12 <merijn> > let () = () in True
16:15:14 <lambdabot>  True
16:15:34 <merijn> > let True = 1 < 2 in ()
16:15:35 <lambdabot>  ()
16:15:45 <merijn> It's not very useful, but it's not wrong :p
16:16:06 <Zekka> It's useful when those constructors have arguments!
16:16:13 <Zekka> let Just x = Nothing in x
16:16:17 <lamer14059110540> > * 2 2
16:16:19 <lambdabot>  <hint>:1:1: parse error on input ‘*’
16:16:19 <Zekka> > let Just x = Nothing in x
16:16:21 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Dat...
16:16:28 <Zekka> lamer14059110540: Do you mean this?
16:16:30 <Zekka> > (*) 2 2
16:16:32 <lambdabot>  4
16:16:33 <jle`> hey, then you can use errors to debug!
16:16:41 <lamer14059110540> > + 1 1
16:16:42 <lambdabot>  <hint>:1:1: parse error on input ‘+’
16:16:49 <merijn> jle`: How so?
16:16:51 <lamer14059110540> > 1 + 1
16:16:52 <Zekka> You're only allowed to treat an operator as a value when you surround it with parentheses
16:16:53 <lambdabot>  2
16:16:55 <jle`> oh, nvm
16:16:55 <Zekka> > (+) 1 1
16:16:56 <lambdabot>  can't find file: L.hs
16:17:02 <Zekka> > (+) 1 1
16:17:03 <lambdabot>  2
16:17:10 <merijn> jle`: Also, if you wanna debug, just use Debug.Trace?
16:17:18 <lamer14059110540> thanks Zekka
16:17:21 <jle`> oh i was trying to make a joke solution
16:17:25 <jle`> but it didn't work out as i thought
16:17:49 <negatratoron> All instances of Functor are endofunctors from the category of Haskell types to itself, right?
16:18:04 <bennofs> negatratoron: yes
16:18:08 <acowley> negatratoronyes
16:18:11 <benzrf> negatratoron: law-abiding ones
16:18:19 <toblerone> What is the benefit of the implicit parameter extension? I'm reading the documentation here: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html and is utility still is unclear to me.
16:18:34 <negatratoron> Is there a typeclass that lets you specificy functors between specific types?
16:18:38 <bennofs> benzrf: in category theory, there is no non-law abiding functor. that wouldn't be a functor
16:18:42 <Zekka> benzrf/bennofs/etc. - Can you explain what that means?
16:18:47 <negatratoron> class Functor a b where fmap : (a -> a) -> b -> b
16:19:04 <bennofs> Zekka: a functor is a "mapping" between categories
16:19:12 <benzrf> merijn
16:19:14 <benzrf> i said:
16:19:20 <benzrf> 06:07 < benzrf> oh wait, i guess you could be pattern matching
16:19:24 <benzrf> IMMEDIATELY afterward
16:19:24 <benzrf> :P
16:19:30 <Zekka> bennofs: Where a category is a bunch of objects and arrows between them?
16:19:33 <jle`> negatratoron: a functor isn't a way to go from one type to another, actually
16:19:40 <Zekka> i.e. Haskell types and functions over Haskell types?
16:19:55 <bennofs> Zekka: yeah, and you have composition of arrows and this composition has an identity and is associativ
16:20:03 <benzrf> Zekka: a category is a collection of objects and a collection of morphisms between then and a composition operator on morphisms
16:20:06 <benzrf> Zekka: with some laws
16:20:10 <benzrf> Zekka: here, read this:
16:20:13 <benzrf> http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf
16:20:14 <Zekka> bennofs: Right, so you have objects, arrows, and (.) for arrows?
16:20:17 * benzrf is about halfway through
16:20:19 <bennofs> Zekka: yes
16:20:26 <jle`> negatratoron: there isn't a standard typeclass that gives you that kind of behavior, but lens can encapsulate it somewhat
16:20:26 <negatratoron> jle`: take each type as a category
16:20:26 <Zekka> er, not 'arrows' in the Arrow sense, of course
16:20:38 <negatratoron> a functor is just a mapping between categories
16:20:38 <bennofs> Zekka: then, a Functor translates arrows to arrows and objects to objects
16:20:39 <jle`> negatratoron: each type as a category?  what are the morphisms, and what are the objects?
16:20:39 <ruuns> Does anyone write regurlary a blog about haskell? :] (i'm looking for interesting developer experience and blogs)
16:20:43 <benzrf> Zekka: a functor is essentially a homomorphism between cats
16:20:47 <benzrf> categories, w/e
16:21:04 <jle`> ruuns: i do :)  well, about once or twice a month...i don't do as much 'live dev-ing' blogs anymore
16:21:34 <jle`> i kind of should though
16:21:35 <ruuns> can i get your url :p ?
16:21:37 <acowley> negatratoron: That would require that morphisms are between particular values
16:21:37 <merijn> Zekka: In haskell terms we are dealing with the set Hask where haskell types are objects and functions are morphisms, the haskell Functor typeclass is actually an endofunctor
16:21:41 <jle`> ruuns: blog.jle.im
16:21:48 <Zekka> benzrf: So, for instance, Const a is a homomorphism from its argument to a?
16:21:56 <negatratoron> jle`: the objects are the instances of the type, and the morphisms are functions from the type a -> a
16:21:58 <jle`> ruuns: if you hang out at the haskell subreddit, you'll see a lot of nice blogs pop up
16:22:01 <bennofs> Zekka: and it "preserves" the structure, meaning it translates id to the id in the target category and a composition of arrows f,g in the source category is translated to the composition of the arrows f,g in the target category
16:22:02 <benzrf> Zekka: uhhh
16:22:06 <benzrf> i dunno about that
16:22:10 <benzrf> Zekka: i mean
16:22:11 <merijn> Zekka: i.e. it maps objects from Hask to objects in Hask (i.e., types to types) and functions in Hask to functions in Hask
16:22:16 <benzrf> you know what a homomorphism is, right?
16:22:25 * benzrf needs to bind a key to insert 'morphism'
16:22:32 <Zekka> benzrf: It's a mapping from a type to another type that isn't necessarily reversible?
16:22:37 <Zekka> Or is there another rule I'm forgetting?
16:22:40 <benzrf> Zekka: i mean in the general mathematical senes
16:22:41 <benzrf> *sense
16:22:48 <benzrf> like what you see in abstract algebra
16:22:59 <Zekka> I don't know a description more general than homomorphisms between sets
16:23:03 <merijn> Zekka: the mapping isn't always reversible, no
16:23:10 <jle`> negatratoron: hmm ok.  so a thin category
16:23:25 <benzrf> homomorphism is a function between two mathematical structures
16:23:27 <benzrf> i.e. between monoids
16:23:32 <jle`> negatratoron: there isn't a standard typeclass that gives you this, actually
16:23:37 <benzrf> where the function respects the structure
16:23:44 <jle`> negatratoron: but like i mentioned before, lens gives you some sort of way to encapsulate this concept
16:23:53 <bennofs> Zekka: functor is like a homomorphism between categories
16:23:56 <benzrf> Zekka: for example, a monoid homomorphism is a function from 1 monoid to another that maps id to id and distributes as a unary operation over mappend
16:24:08 <jle`> negatratoron: a Lens' s a gives you the ability to do an (a -> a) -> (s -> s), like you want
16:24:21 <benzrf> Zekka: i believe length is a monoid homomorphism from [a] to Sum Int
16:24:26 <ruuns> great, don't stress yourself :)
16:24:26 <benzrf> i.e.
16:24:33 <jle`> :t over (undefined :: Lens' b a)
16:24:34 <lambdabot> (a -> a) -> t -> t
16:24:35 <benzrf> > getSum (length mempty)
16:24:35 <Zekka> benzrf: Yeah, that's fair
16:24:36 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Sum a’
16:24:36 <lambdabot>              with actual type ‘GHC.Types.Int’
16:24:37 <negatratoron> jle` Interesting, I still haven't really learned lenses
16:24:38 <jle`> negatratoron: ^^
16:24:45 <benzrf> lambdabot: u wot
16:24:55 <benzrf> oh
16:24:58 <Zekka> We drop the sum for convenience but you can  view it as a fold using mappend = (+)
16:24:59 <jle`> negatratoron: no worries.  it actually is sort of an awkward concept for haskell typeclasses, becuase it is deep in functional dependencies
16:25:01 <benzrf> bah
16:25:06 <Zekka> er, the Sum*
16:25:13 <benzrf> Zekka: anyway
16:25:18 <Zekka> Or we can use foldMap I guess
16:25:21 <ruuns> what kind of country is actually .im domain? :D
16:25:23 <Zekka> there's more than one way to do it
16:25:29 <benzrf> Zekka: an X homomorphism is a function between X's that respects the structure of an X
16:25:44 <jle`> negatratoron: but yeah...you can "assemble" these yourself in multiple ways
16:25:46 <benzrf> Zekka: so a functor is a function from 1 category's objects to anothers, and its morphisms to the other's
16:25:49 <benzrf> that respects some laws
16:25:55 <jle`> negatratoron: that is, you can create a Lens' s a yourself, using some helper functions
16:26:01 <Zekka> And when we say 'respects the structure' we mean the functor laws?
16:26:06 <benzrf> yep
16:26:17 <benzrf> for example, given categories C and D
16:26:21 <benzrf> and a functor F : C -> D
16:26:23 <jle`> negatratoron: if you have an (Int -> Int) and you want to turn it into a (Int, Bool) -> (Int, Bool)
16:26:26 <acowley> I'd expect expressing a thin category in most type systems is iffy
16:26:35 <jle`> negatratoron: that would be a Lens' (Int, Bool) Int
16:26:40 <benzrf> if A and B are objects in C, and f is a morphism in C (f : A -> B)
16:26:48 <benzrf> then F(f) : F(A) -> F(B)
16:26:50 <benzrf> or you're cheating!
16:27:04 <benzrf> Zekka: Functor instances are endofunctors
16:27:18 <benzrf> Zekka: objects in Hask are types, morphisms are functions (the actual values, not the types)
16:27:21 <benzrf> so
16:27:25 <benzrf> take the functor Maybe
16:27:30 <benzrf> the object mapping is the type constructor
16:27:39 <benzrf> Maybe maps types to other types
16:27:41 <bennofs> :k Maybe
16:27:42 <lambdabot> * -> *
16:27:45 <Zekka> Maybe is a Functor from things to Maybe-things, right
16:27:52 <jle`> negatratoron: in this case you you need to use the 'lens' function, and provide a "getter" and a "setter": lens (\(x, y) -> x) (\(x, y) newX -> (newX, y) :: Lens' (a, b) a
16:27:55 <Zekka> and Just is an endofunctor from values to Maybe-values?
16:27:56 <negatratoron> jle`: I would probably just write "class Functor a b where fmap : (a -> a) -> b -> b"
16:27:58 <benzrf> fmap maps a morphism between a and b to a morphism between Maybe a and Maybe b
16:28:03 <benzrf> Zekka: Just is not an endofunctor!
16:28:05 * benzrf smacks Zekka 
16:28:13 <jle`> :t lens (\(x, y) -> x) -> (\(x, y) newX -> (newX, y))
16:28:14 <lambdabot> parse error on input ‘->’
16:28:15 <benzrf> Zekka: a functor must map objects and morphisms
16:28:18 <benzrf> Zekka: Just maps neithre
16:28:20 <jle`> :t lens (\(x, y) -> x) (\(x, y) newX -> (newX, y))
16:28:21 <lambdabot> Functor f => (a -> f t) -> (a, t1) -> f (t, t1)
16:28:23 <jle`> oops
16:28:27 <jle`> Lens' is a type synonym, but yeah.
16:28:31 <negatratoron> jle`: (using some other name for it) and instance it for the types I'm interested in
16:28:34 <fread2282> @src _1
16:28:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:28:39 <Zekka> benzrf: Alright, what is an endofunctor?
16:28:40 <bennofs> negatratoron: that's MonoFunctor from mono-traversable, iirc
16:28:49 <benzrf> Zekka: a functor from a category to itself
16:28:54 <fread2282> :t _1
16:28:55 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
16:28:57 <benzrf> just as an endomorphism is a homomorphism from something to itself
16:29:02 <Zekka> Oh, OK.
16:29:04 <benzrf> Zekka: all Functor instances are endofunctors
16:29:12 <benzrf> because you cannot map to a category besides Hask
16:29:13 <Zekka> So all Haskell functors are Endofunctors
16:29:16 <benzrf> yep
16:29:17 <Zekka> right, that makes sense
16:29:32 <benzrf> Zekka: lrn2abstractalgebra
16:29:40 <fread2282> _1 is the lens you want
16:29:46 <Twey> Wellll you can map to a category besides Hask, but not with Functor
16:29:51 <benzrf> Twey: my point :p
16:29:58 <jle`> fread2282: yeah, just demonstrating how you make your own lenses between arbitrary types with arbitrary getters/setters :)
16:30:09 <benzrf> Zekka: the Category class is for types representing morphisms in some category that shares objects with Haske
16:30:12 <benzrf> *Hask
16:30:15 <jle`> negatratoron: ah yeah, i think that should work, with some extensions.
16:30:18 <Zekka> Twey: Well, in what cases can you? I can't think of any cases where a Haskell function can spontaneously produce an object that's not in Haske
16:30:22 <Zekka> Hask*
16:30:22 <hexagoxel> there is bifunctor; i guess it would be trivial to add trifunctor or nfunctor (but the last might be hard to express in haskell, no idea)
16:30:23 <Zekka> just by definition
16:30:23 <benzrf> Zekka: for example, consider the Kleisli newtype
16:30:29 <jle`> negatratoron: the thing is that there is often more than one way to instance that for every type
16:30:50 <jle`> negatratoron: the Lens' approach means you can pick and choose how to do so
16:31:12 <Zekka> benzrf: Right -- the Category typeclass describes 'for a given way to map between objects in Hask, this is how you compose it'?
16:31:18 <jle`> for example, i might have an (Int -> Int) function that I want to turn into a (String -> String)
16:31:20 <benzrf> Zekka: well
16:31:22 <benzrf> look
16:31:25 <benzrf> just read http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf, ok
16:31:25 <benzrf> it
16:31:28 <benzrf> *it's quite good
16:31:30 <fread2282> negatratoron: the other problem is that it's not polymorphic (you can't change the type of the inner value)
16:31:31 <jle`> i can "lift" this by applying it to the number contained in the string
16:31:35 <Zekka> OK, OK
16:31:35 <benzrf> Zekka: it might assume a tiny bit of abstract algebra
16:31:36 <benzrf> :p
16:31:46 <jle`> but i can also "lift" it by applying it to, say, the length of the string
16:32:05 <benzrf> Zekka: if you come up with some category that also uses Haskell types as objects but something other than functions (a -> b) as morphisms from a to b
16:32:08 <negatratoron> jle` Thanks for the warning, but I don't think I'll run into that in my use case
16:32:11 <bennofs> Zekka: you can have a functor from Hask x Hask -> Hask, called a Bifunctor in haskell
16:32:16 <benzrf> then you can describe that category by making a Category instance
16:32:27 <fread2282> negatratoron: see MonoFunctor
16:32:37 <fread2282> @hackage mono-traversable
16:32:37 <lambdabot> http://hackage.haskell.org/package/mono-traversable
16:32:42 <jle`> negatratoron: ok :)  in general, we like to discourage creating ad-hoc type classes for specific uses
16:32:54 <Zekka> bennofs: Aren't all objects in Hask x Hask also in Hask?
16:32:59 <Zekka> Or am I missing your point?
16:33:01 <jle`> actually yeah monofunctor might be what you want
16:33:03 <bennofs> Zekka: yeah right
16:33:05 <negatratoron> Good point.  I'm not even using haskell though :)
16:33:11 <fread2282> negatratoron: lens is *much* *much* more powerful
16:33:22 <jle`> but then you can only have one (a -> a) for every (s -> s)
16:34:21 <jle`> negatratoron: ah.  well then, feel free to do what you want :)  yeah, the (a -> a) -> (s -> s) design pattern is more often encapsulated in lens or in monotraversable (for fixed a per n).  not so much typeclasses.
16:34:26 <jle`> if that answers your original question
16:34:48 <bennofs> Zekka: Do you know DataKinds?
16:34:52 <negatratoron> It does
16:34:59 <negatratoron> I would consider my original question answered
16:35:07 <Zekka> bennofs: No, I've heard of it but I don't know mch about it
16:35:25 <negatratoron> I was just looking for prior work on this (a -> a) -> s -> s subject, and found a shit ton
16:35:42 <jle`> negatratoron: oh really?  i might be interested in some reading :)
16:35:50 <negatratoron> I'm just talking about Lens and MonoTraversable
16:35:56 <jle`> ah i see
16:35:58 <jle`> haha
16:36:00 <jle`> sorry
16:36:17 <bennofs> Zekka: hmm well, I'm not really sure what belongs to Hask and what doesn't
16:36:44 <jle`> yeah, Lens lets you basically map arbitrary (a -> a)'s to arbitrary (s -> s)'s, and MonoTraversable is for things like ByteString or Text, where it makes sense to do (Char -> Char) -> (Text -> Text), but nothing else beside Char would make sense
16:37:47 <Zekka> benzrf: Hm: in short, tip is (:[]), (:) is (:), cons is (:), (++) is (++), join is prefix (++), Seq is map, <+> is mappend, and <+>/ is mconcat?
16:38:03 <edwardk> bennofs: the library or the category
16:38:07 <edwardk> > ("hello","world") & _2 %~ length
16:38:08 <lambdabot>  ("hello",5)
16:38:33 <fread2282> jle`: lens lets you do (a -> b) -> (s -> t) though
16:38:44 <jle`> fread2282: yeah, it does, so it's more powerful than that
16:38:44 <bennofs> edwardk: category. Is a "type" of kind (* -> *)  in Hask? Probably not, because you cannot have "functions" from that "type"
16:38:55 <jle`> fread2282: just wanted to tailor it for negatratoron's problem at hand :)
16:39:04 <edwardk> bennofs: the hask library covers * -> * as natural transformations from Hask -> Hask
16:39:04 <fread2282> you can do a limited form of that w/ MonoFunctor though
16:39:14 <edwardk> er natural transformations over functors that go from Hask -> Hask
16:39:17 <negatratoron> It sounds like Lens is a sort of framework for working with types as if they were other, perhaps more canonical types
16:39:41 <fread2282> negatratoron: it also does Isos, Traversals, etc
16:39:49 <edwardk> negatratoron: lens is a toolbox for separating the concerns of "what to do to it" from "what to do it to"
16:40:06 <fread2282> negatratoron: a Lens is a thing that works on an inner part of a type
16:40:16 <jle`> fsvo 'inner' :)
16:40:17 <negatratoron> The "A lens is..." train has started
16:40:18 <negatratoron> choo choo
16:40:20 <jle`> haha
16:40:26 <fread2282> lol
16:40:26 <edwardk> you get composable vocabulary for putting together the description of how to get to the target(s) and a composable vocabulary for describing what to do with them that is based on existing combinators
16:40:31 <edwardk> negatratoron: well, i wrote it ;)
16:41:09 <jle`> i think the 'inner' metaphor sort of limits how you can think/express with lenses
16:41:14 <fread2282> negatratoron: the real power hower comes with the other Lens-likes
16:41:14 <bennofs> edwardk: hmm, what do you call something of kind * -> *? or even Nat -> SomeOtherWeirdKind ? type or type constructor?
16:41:21 <jle`> in the same way the 'inside' metaphor limits your thinking with Functor/Monad
16:41:54 <negatratoron> edwardk: that really describes my problem at hand: getting the targets and describing what to do with them
16:41:55 <jle`> negatratoron: in short, yes, lens does allow you to do that, + more :)
16:41:57 <fread2282> jle`: probably, but useful IO lenses aren't a thing (AFAIK)
16:42:14 <edwardk> bennofs: the type constructors are things like '(,)'  'Const', 'Identity', or even 'Eq' or 'Functor'. you can get to * ->* by applying a type constructor to several arguments for instance.
16:42:37 <jle`> fread2282: i'm talking about things like...
16:42:50 <jle`> > "7a04e" ^? hex
16:42:52 <lambdabot>  Just 499790
16:43:02 <jle`> > over hex (*2) "7a04e"
16:43:03 <lambdabot>  "f409c"
16:43:10 <jle`> i mean...yeah, the hex number is 'inside' the string, but...
16:43:16 <fread2282> :t hex
16:43:17 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
16:43:20 <jle`> really what the hex prism allows you to do is treat the string as if it were an integer
16:43:20 <fread2282> not a Lens
16:43:27 <Zekka> fread2282: It's more general
16:43:30 <fread2282> y9ep
16:43:34 <fread2282> s/9//
16:43:37 <Zekka> it's a Prism
16:43:38 <jle`> ah i was intending more about the lens library
16:43:48 <Zekka> Well, I shouldn't say "more general"
16:43:51 <jle`> and about its goals/aims
16:44:33 <jle`> not about the specific Lens type
16:44:35 <tac_> hey all
16:44:39 <jle`> if you want, i can demonstrate something similar with a Lens
16:44:40 <tac_> Any ideas on what this error is caused by?
16:44:40 <tac_> http://lpaste.net/107859
16:44:41 <benzrf> Zekka: yes
16:44:45 <bennofs> goal: introduce lots of new names to make puns about :)
16:44:46 <benzrf> Zekka: sorry i was getting fudge
16:44:50 <edwardk> lens is mostly about things that only vaguely resemble lenses =)
16:44:52 <Zekka> No worries, I'm still reading
16:44:56 <benzrf> Zekka: hella
16:45:33 <jle`> @let _strLength = lens (\xs -> length xs) (\xs n -> take n (xs ++ repeat ' '))
16:45:34 <lambdabot>  Defined.
16:45:35 <benzrf> Zekka: fyi <+>/ denotes foldr1 <+>
16:45:41 <benzrf> Zekka: for some <+>
16:45:48 <benzrf> Zekka: i.e. +/ indicates foldr1 (+)
16:45:52 <jle`> > over _strLength (`div` 2) "hello world"
16:45:53 <benzrf> anyway bbl
16:45:54 <lambdabot>  "hello"
16:45:55 <bennofs> jle`: doesn't look like a valid lens to me
16:45:56 <Zekka> "Function ⊕/ is called the reduce-with-⊕ or
16:45:56 <Zekka> the fold-with-⊕; the neutral element of ⊕ is the outcome on the empty sequence [ ] .
16:45:59 <Zekka> "
16:46:07 <bennofs> jle`: it's not a valid lens
16:46:11 <jle`> aw darn
16:46:12 <Zekka> benzrf: Seems to me like it's more like foldr implicitly taking the identity for <+>
16:46:14 <jle`> :(
16:46:22 <jle`> oh yeah you're right
16:46:31 <bennofs> > ("123" & strLength .~ 10) ^. strLength
16:46:32 <lambdabot>  Not in scope: ‘strLength’
16:46:32 <lambdabot>  Perhaps you meant ‘_strLength’ (line 146)Not in scope: ‘strLength’
16:46:32 <lambdabot>  Perhaps you meant ‘_strLength’ (line 146)
16:46:32 <edwardk> jle`: you can make one to go back and forth between Natural and [()] though
16:46:40 <jle`> ah yeah, that's probably better :)
16:46:43 <edwardk> but over l id will fail
16:46:47 <edwardk> you want that to be id
16:46:52 <Zekka> > over hex (*2) "no hex"
16:46:54 <lambdabot>  "no hex"
16:47:02 <jle`> > over _strLength id "hello world"
16:47:03 <lambdabot>  "hello world"
16:47:07 <jle`> isn't that id?
16:47:14 <tac_> anyone?
16:47:20 <bennofs> > ("123" & _strLength .~ 10) ^. _strLength
16:47:21 <lambdabot>  10
16:47:23 <tac_> http://lpaste.net/107859 <-- has anyone seen this kind of error before?
16:47:30 <bennofs> oh hthat works
16:47:32 <Zekka> AFAIK the Traversal power (Applicative) is used so that if you're not pointing at hex, then it doesn't "target" anything
16:47:40 <edwardk> over l f . over l g = over l (f . g) should blow up then. didn't read closely
16:47:51 <jle`> tac_: i have never seen ghc talk in first person to me before
16:48:03 <Zekka> otherwise, let me check my intuition -- would it be an Iso?
16:48:03 <tac_> jle`: I know right? That seems like a bad thing.
16:48:11 <jle`> how about
16:48:49 <tac_> oh
16:48:50 <tac_> hmm
16:48:53 <jle`> hm can't you turn any Prism' s a into a Lens' s (Maybe a) ...?
16:48:57 <tac_> this isn't coming from my cabal sandbox
16:49:00 <Zekka> jsFunction ⊕/ is called the reduce-with-⊕ or
16:49:01 <Zekka> the fold-with-⊕; the neutral element of ⊕ is the outcome on the empty sequence [ ] .
16:49:04 <Zekka> er, oops
16:49:08 <tac_> I bet I probably have a haskell-platform library interfering
16:49:08 <Zekka> jle`: Intuitively, yes
16:49:15 <Zekka> haven't tried it but I'm pretty sure you can
16:49:24 <Zekka> I think you can turn it into an Iso' s (Maybe a), actually
16:49:24 <jle`> so yeah, you can think of hex as treating a String "as if it were" a Maybe Int
16:49:25 * hackagebot engine-io-yesod 1.0.0 -   http://hackage.haskell.org/package/engine-io-yesod-1.0.0 (TimBaumann)
16:49:41 <Zekka> but I haven't tried it
16:50:07 <edwardk> Zekka: it is a prism, which is a 'co-lens' in the sense that if a lens offers view :: Lens' s t a b -> s -> a    and set :: Lens s t a b -> s -> b -> t    then a prism offers the opposite operations review :: Prism s t a b -> b -> t    and instead of a set that takes s and b -> t  you get 's -> Either t a'
16:50:20 <edwardk> > _Left # 4
16:50:21 <lambdabot>  Left 4
16:50:26 <jle`> fread2282: the point i was sort of making was that if you think of Lens' s a as being able to access the a "inside" the s, it's a bit limiting of a viewpoint because Lens' s a can encapsulate much more
16:50:30 <edwardk> > Left 4 & _Left +~ 2
16:50:31 <jle`> than just a way to look "inside"
16:50:31 <lambdabot>  Left 6
16:50:36 <bennofs> jle`: hmm, I'm failing to find a counterexample for your _strLength lens
16:50:38 <Zekka> edwardk: Hold up, parsing.
16:50:39 <edwardk> > Right "not a number" & _Left +~ 2
16:50:41 <lambdabot>  Right "not a number"
16:51:02 <Zekka> That seems like an accurate formal definition but I don't think it gives a strong intuition
16:51:17 <jle`> fread2282: in one way, it's a way to treat an s "as if it were" an a ... and i think the "inside" metaphor limits that intuition
16:51:19 <qwebirc34552> \nick gbwey
16:51:28 <bennofs> jle`: it might even be valid
16:51:34 <Zekka> IIRC somebody claimed that Prisms were basically analogous to data constructors, in that they act like Traversals but are reversible and target 0 to 1 thing?
16:51:35 <edwardk> bennofs: shorten then make it long again
16:51:44 <Zekka> (that is, you can use them to construct, not just to traverse)
16:51:47 <edwardk> you lose more information than just the length
16:51:54 <bennofs> edwardk: ah right, didn
16:52:05 <bennofs> 't think of that. but it felt weird :)
16:52:35 <jle`> laws schmaws
16:52:39 <edwardk> set _setLength 100 . set _strLength 2 /= set _strLength 100
16:52:47 <bennofs> > over _setLength succ . over _setLentgh pred $ "abc"
16:52:48 <lambdabot>  Found hole ‘_setLength’
16:52:48 <lambdabot>    with type: Control.Lens.Setter.Setting (->) b0 c a0 a0
16:52:48 <lambdabot>  Where: ‘b0’ is an ambiguous type variable
16:52:48 <lambdabot>         ‘a0’ is an ambiguous type variable
16:52:48 <lambdabot>         ‘c’ is a rigid type variable bound by
16:52:59 <bennofs> > over _strLength succ . over _strLentgh pred $ "abc"
16:53:00 <lambdabot>  Found hole ‘_strLentgh’
16:53:00 <lambdabot>    with type: Control.Lens.Setter.Setting
16:53:00 <lambdabot>                 (->) [GHC.Types.Char] [GHC.Types.Char] a0 a0
16:53:00 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
16:53:08 <fread2282> > let {_ord = iso ord chr; ioref = sets (\f r -> (f <$> readIORef r) >>= writeIORef r) } in do {r <- newIORef 'a'; over (ioref._ord) (+1) r; readIORef r}
16:53:10 <lambdabot>  Not in scope: ‘readIORef’
16:53:10 <lambdabot>  Perhaps you meant ‘readSTRef’ (imported from Data.STRef)Not in scope: ‘write...
16:53:10 <lambdabot>  Perhaps you meant ‘writeSTRef’ (imported from Data.STRef)Not in scope: ‘newI...
16:53:10 <lambdabot>  Perhaps you meant ‘newSTRef’ (imported from Data.STRef)Not in scope: ‘readIO...
16:53:10 <lambdabot>  Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
16:53:10 <bennofs> i can't type
16:53:14 <edwardk> third time's the charm
16:53:31 <bennofs> > over _strLength succ . over _strLength pred $ "abc"
16:53:32 <lambdabot>  "ab "
16:53:38 <Zekka> edwardk: Is the above intuition correct? I don't remember where I heard it from but it seems to hold from the definition of the Prism type
16:53:53 <fread2282> > let {_ord = iso ord chr; ioref = sets (\f r -> (f <$> readSTRef r) >>= writeSTRef r) } in do {r <- newSTRef 'a'; over (ioref._ord) (+1) r; readSTRef r}
16:53:54 <lambdabot>  <<ST action>>
16:53:59 <fread2282> :(
16:54:00 <jle`> Zekka: i think you need more to make a Prism
16:54:02 <edwardk> Zekka: a prism is basically a 'smart constructor'
16:54:04 <jle`> Zekka: hm.  wait
16:54:14 <jle`> no, because you can use set Nothing
16:54:16 <edwardk> Zekka: you can compose them with other prisms and get a 'deeper' constructor, etc.
16:54:22 <edwardk> > _Left._Right # 4
16:54:23 <nick_named> If I want to approximate the multiplication of a large Integer, 10^1000, by a float, is there a more elegant way than just multiplying the float by like 10^10, performing the multiplicaiton, then dividing by 10^10?
16:54:24 <lambdabot>  Left (Right 4)
16:54:35 <edwardk> Left (Right 12) ^? _Left._Right
16:54:35 <fread2282> Y u no ref, lambdabot?
16:54:41 <Zekka> edwardk: Right, and in that it has the properties I listed that make it act like a data constructor in the ways we expect?
16:54:57 <Zekka> even if (as with 'hex') it doesn't correspond to an actual data constructor?
16:55:21 <edwardk> Zekka: you can use it to traverse, and it does nothing if it doesn't match. and you can use it to build a value and to try to match a case
16:55:26 <edwardk> here the 'case' that it is a valid hex string
16:55:37 <edwardk> it is technically a little wonky as it canonicalizes the choice of hex string
16:55:48 <jle`> edwardk: how do i access the (b -> t) in a prism?
16:55:54 <bennofs> :t review
16:55:55 <lambdabot> MonadReader b m => AReview s t a b -> m t
16:55:58 <Zekka> jle`: #?
16:56:03 <bennofs> :t (#)
16:56:04 <lambdabot> parse error on input ‘)’
16:56:11 <Zekka> (#) :: AReview s t a b -> b -> t
16:56:13 <edwardk> review    (#)   or view . re
16:56:14 <Zekka> according to the docs
16:56:22 <jle`> > revew _Left 4
16:56:24 <lambdabot>  Not in scope: ‘revew’
16:56:24 <lambdabot>  Perhaps you meant ‘review’ (imported from Control.Lens)
16:56:26 <jle`> > review _Left 4
16:56:28 <bennofs> oh, lambdabot has magi hash?
16:56:28 <lambdabot>  Left 4
16:56:28 <fread2282> > over (dividing (10**10)) (+2) 10000000000000000
16:56:30 <lambdabot>  1.000002e16
16:56:31 <jle`> oh neat
16:56:40 <fread2282> nick_named: using lens, ^
16:57:03 <Zekka> edwardk: And an Iso is like a constructor that always matches?
16:57:07 <fread2282> wait, no
16:57:15 <edwardk> Zekka: yeah you can use an iso as a prism _or_ as a lens
16:57:21 <edwardk> it is both simultaneously
16:57:41 <Zekka> edwardk: Right, because it only requires Functor instead of Applicative (i.e. it looks more like a Lens, less like a Traversal)?
16:57:43 <jle`> one of these days i'm going to sit down and learn how to write over, set, and view/preview for lens, prism or iso
16:57:49 <jle`> *and
16:58:00 <Zekka> e.g.*
16:58:38 <edwardk> Zekka: yeah and you can pick the profunctor involved to be (->) to match up with lens
16:58:46 <edwardk> prisms need the applicative on f because they can fail
16:59:14 <fread2282> nick_named: Numeric.Lens has lenses that might help you, if you like lens
16:59:24 <fread2282> s/Lenses/Isos/
16:59:37 <jle`> edwardk: i guess the original question was, does every Prism' s a have a corresponding equivalent Lens' s (Maybe a) ?
16:59:57 <edwardk> jle`: no
17:00:03 <edwardk> in fact most don't
17:00:21 <bennofs> jle`: what happens when you set to Nothing?
17:00:24 <nick_named> fread2282: I've never used lenses before, so I'll have to check it out.
17:00:31 <edwardk> bennofs++
17:00:33 <Zekka> Is the issue that while it's easy to get a Nothing out of a failing Prism, it's hard to get a Prism out of a Nothing?
17:00:40 <jle`> bennofs: i see
17:00:43 <edwardk> Zekka: yeah
17:00:46 <Zekka> er, Bennofs has stated it more concisely
17:00:46 <edwardk> well
17:00:48 <edwardk> not exactly
17:00:49 <jle`> yeah i should have thought of that
17:00:53 <edwardk> its a bit different, but bennofs hit it
17:01:09 <Zekka> Yeah, I'm using "Prism" kind of informally here at least
17:01:13 <edwardk> 'set' for a lens needs to be injective (as long as the thing you are setting on exists)
17:01:31 <fread2282> nick_named: lens is a really nice library and produces really nice code but is also big, too big IMO for a dependency most of the time
17:01:43 <edwardk> set l s a -- if s /= Void then (set l s a) is injective in a
17:01:49 <jle`> how about Prism s t a b -> Lens s t (Either s a) (Either t b)  ......?
17:02:00 <jle`> wait no
17:02:05 <fread2282> you can write a tiny version of it really easy, but then you loose a lot of the benefits
17:02:07 <edwardk> view l s -- if s /= Void then that has to be surjective in s
17:02:15 <edwardk> er surjective in the result
17:02:28 <bennofs> jle`: I think there is something like that
17:02:31 <edwardk> :t ouside
17:02:32 <lambdabot>     Not in scope: ‘ouside’
17:02:32 <lambdabot>     Perhaps you meant one of these:
17:02:32 <lambdabot>       ‘outside’ (imported from Control.Lens),
17:02:33 <edwardk> :t outside
17:02:34 <lambdabot> (Data.Profunctor.Rep.Representable p, Functor f) => APrism s t a b -> (p b r -> f (p a r)) -> p t r -> f (p s r)
17:02:43 <edwardk> that is more intelligible from the haddocks
17:03:03 <edwardk> that turns prisms into lenses by 'filtering the function' to just the cases that match the prism and letting you replace those cases
17:03:13 <edwardk> :t inside
17:03:13 <lambdabot> (Data.Profunctor.Rep.Corepresentable p, Functor f) => ALens s t a b -> (p e a -> f (p e b)) -> p e s -> f (p e t)
17:03:14 <nick_named> fread2282: Its only for ProjectEuler, so the library size doesn't really matter, I'm just learning and optimizing big-O runtimes
17:03:15 <bennofs> outside :: Representable p => APrism s t a b -> Lens (p t r) (p s r) (p b r) (p a r)
17:03:28 <edwardk> replace p with (->) and its almost comprehensible
17:03:29 <jle`> outside :: APrism s t a b -> Lens (t -> r) (s -> r) (b -> r) (a -> r)
17:03:42 <jle`> ...what is APrism?
17:03:43 <edwardk> that was fun to invent
17:03:49 <edwardk> it is ... a prism
17:04:03 <bennofs> jle`: APrism is like Prism but without RankN
17:04:08 <jle`> i see
17:04:21 <edwardk> bbiab, plane
17:04:23 <jle`> oh it uses Market
17:04:43 <Zekka> Let's see, parts of Lens I don't really know: do any of you feel like explaining Action?
17:04:47 <fread2282> nick_named: cool, lens optimizes away. there's probably a faster way to do it though, algorithmically
17:05:35 <Zekka> actually, come to think of it, this looks kind of straightforward
17:05:44 <Zekka> I'll puzzle over it a bit and come back later for questions
17:06:05 <bennofs> Zekka: I guess you won't find many people with a deep understanding of actions :p
17:06:30 <Zekka> bennofs: I'm just going through the diagram and going into stuff I don't know too well
17:06:34 <nick_named> fread2282: I doubt it, I'm just finding the first Fibonacci number w/ 1000 digits, it should just be 1 log, 1 exponentiation, negligable additions
17:06:51 <ReinH> Any folks in Chicago for LambdaJam yet? I need to find something to do for a couple hours until I can get into my hotel room.
17:07:04 <bennofs> Zekka: the Control.Lens.Plated stuff is quite useful IMO
17:07:15 <bennofs> @type ala
17:07:16 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
17:07:30 <bennofs> Zekka: also, Control.Lens.Wrapped helps if you work a lot with newtypes
17:07:38 <fread2282> plated is cool, you have uniplate but nicer
17:07:41 <fread2282> @type non
17:07:42 <lambdabot> (Profunctor p, Functor f, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
17:08:38 <fread2282> non is cool, you can use it to turn a prism into an iso if you have a default value AFAICT
17:09:01 <bennofs> fread2282: no, not really
17:09:16 <fread2282> bennofs: ?
17:09:23 <bennofs> fread2282: you can use it to turn Lens' a (Maybe b) into Lens' a b if you have a default value
17:09:29 * hackagebot haskell-neo4j-client 0.1.0.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.1.0.0 (asilvestre)
17:14:44 <acowley> ReinH: A bunch of the usual twitter people are there
17:16:24 <iasoon> I was wondering, is it possible to do any kind of subclassing/superclassing in haskell?
17:16:39 <gregork> ReinH: I live in Chicago but I’m way up on the Northwest side
17:17:43 <Zekka> iasoon: Not in the same way you do it in i.e. Java
17:17:46 <Zekka> What behavior are you looking for?
17:18:19 <jophish> https://medium.com/cool-code-pal/the-hassle-of-haskell-a74862541dfb
17:18:21 <jophish> wow
17:18:38 <iasoon> Zekka: I'm not looking to solve a specific problem, just wondering
17:19:26 <mwhit> jophish: blatant satire man. just look at the author/publisher descriptions at the bottom
17:19:50 <Zekka> iasoon: There's a few ways people get the same behaviors
17:19:58 <jophish> mwhit, ah yes, I see that now
17:20:06 <bennofs> or read the reddit comment. but i also was a bit unsure if it's serious or not
17:20:30 <Zekka> You can use i.e. existential quantification to get part of the way there -- it lets you treat everything that instantiates a specific typeclass as a single type
17:20:35 <jophish> egg and my face :)
17:20:58 <Zekka> @data ShowMe = forall a. Show a => ShowMe a deriving (Show)
17:20:59 <lambdabot> Unknown command, try @list
17:21:04 <Zekka> @let data ShowMe = forall a. Show a => ShowMe a deriving (Show)
17:21:05 <lambdabot>  .L.hs:150:22:
17:21:06 <lambdabot>      Can't make a derived instance of ‘Show ShowMe’:
17:21:06 <lambdabot>        Constructor ‘ShowMe’ must have a Haskell-98 type
17:21:06 <lambdabot>        Possible fix: use a standalone deriving declaration instead
17:21:06 <lambdabot>      In the data declaration for ‘ShowMe’
17:21:28 <Zekka> hm, if any of you knows how to convey my sentiment to Lambdabot, be my guest
17:21:44 <Zekka> The gist of it is that you get the same 'not caring about the underlying type' behavior as in a language like Java
17:21:47 <iasoon> Wouldn't that be an universal quantification?
17:21:58 <bennofs> @data ShowMe = forall a. Show a => ShowMe a
17:21:58 <lambdabot> Unknown command, try @list
17:22:03 <bennofs> @let data ShowMe = forall a. Show a => ShowMe a
17:22:05 <lambdabot>  Defined.
17:22:20 <bennofs> @let instance Show ShowMe where show (ShowMe x) = show x
17:22:22 <lambdabot>  Defined.
17:22:54 <Zekka> iasoon: I'm not actually entirely sure what people mean when they say universal vs existential quantification in the context of types even though I know at least in some cases how forall corresponds to universal  quantification
17:23:20 <Zekka> > map show [ShowMe 1, ShowMe "abc", ShowMe [1, 2, 3], ShowMe Nothing]
17:23:22 <lambdabot>  ["1","\"abc\"","[1,2,3]","Nothing"]
17:23:43 <iasoon> So, you used a datatype to wrap things up there.
17:23:57 <Zekka> iasoon: The extension required to define datatypes like that is called ExistentialQuantification, though
17:24:09 <Zekka> you might have to ask a mathematician about the derivation
17:24:14 <Zekka> Yeah.
17:24:19 <iasoon> I understand typeclasses are unlike OO classes, but they do correspond to sets, right?
17:24:27 <Zekka> iasoon: In what sense?
17:24:33 <zomg> jophish: oh god that article you linked... :D
17:24:38 <Zekka> You can talk about the set of instances of a given typeclass
17:24:42 <iasoon> Or cathegories, not sure about the correct terminology here
17:25:07 <zomg> jophish: I'm not entirely convinced if it's a joke or not
17:25:09 <Zekka> They don't really correspond to categories AFAIK
17:25:30 <Zekka> iasoon: You can, if you want, speak about the set of types instantiating a given typeclass
17:25:55 <Zekka> likewise you can use a typeclass to constrain a polymorphic function
17:25:57 <Zekka> :t sort
17:25:58 <lambdabot> Ord a => [a] -> [a]
17:25:59 <Maxdamantus> Though they're not necessarily types (assuming type = *)
17:26:11 <Zekka> Yeah, Maxdamantus is technically right
17:26:23 <Zekka> because 'Maybe' for instance, instantiates the Functor typeclass, but you can't have a value of type 'Maybe'
17:26:45 <iasoon> But for example the functor / monad thing
17:26:46 <jle`> "for instance"
17:26:49 <jle`> pun?
17:26:51 <zomg> iasoon: if you want an OO-style explanation, typeclasses are a little bit like interfaces :)
17:26:51 <jle`> :)
17:26:52 <Zekka> you can have a 'Maybe a' which is a value of 'something in a Maybe, we don't know what', but that's not the same as having a 'Maybe'
17:27:04 <Zekka> jle`: Not an intentional one
17:27:18 <iasoon> Suppose I was writing this myself, how would I express that every monad is also a functor?
17:27:30 <iasoon> That was what I was wondering about.
17:27:33 <jle`> iasoon: instance (Functor m) => Monad m where ...
17:27:52 <jle`> oh
17:27:54 <jle`> no that's wrong
17:27:57 <Maxdamantus> interfaces for "singleton" objects, maybe.
17:27:57 <iasoon> Isn't that the opposite?
17:27:58 <jle`> class
17:28:08 <Maxdamantus> but it's still a bit weird.
17:28:17 <jle`> class Functor m => Monad m where ...
17:28:19 <Zekka> Yeah, I think he means class
17:28:26 <jle`> oh do you mean class as in the OOP class
17:29:26 <iasoon> Nope, typeclasses :)
17:30:03 <Zekka> I'm not really sure what "inheritance" would entail on Haskell types
17:30:09 <jle`> that's the syntax for saying "osmething is a Monad if it has these methods...oh and it also must be a Functor instance as well."
17:30:21 <Zekka> You might be interested in Vinyl, which provides some cooler record types
17:30:37 <sipa> Ha. Vinyl. Record.
17:30:38 <silasm> `class Functor m => Monad m' states "Every Monad must be a Functor". `instance (Monad m) => Functor m' states " Every Monad is a functor".
17:30:43 <Zekka> https://hackage.haskell.org/package/vinyl
17:31:03 <Zekka> They actually apparently have a channel at #vinyl, which I didn't know
17:31:06 <iasoon> I'll look into that, thanks for the pointer
17:31:07 <mwhit> silasm: the latter is illegal without -XUndecidableInstances, isn't it?
17:31:22 <silasm> pretty sure, yeah.
17:31:27 <Zekka> You could also look into i.e. elm, which provides extensible records as a language feature
17:31:36 <fread2282> vinyl's lens integration looks poor though
17:33:45 <iasoon> I'm stuck at how these two statements are different, silasm
17:34:05 <iasoon> Well I understand that they're different things, but conceptually
17:34:45 <Zekka> iasoon: I'll try to explain
17:35:01 <Zekka> Basically, when you say the first one you're saying "if you're going to claim that a thing is a Monad, you'd better explan how it's a functor first"
17:35:21 <Zekka> If you say the second one you're saying "by the way, if a thing is a monad then here's an explanation of how it's also a functor"
17:35:23 <iasoon> Yes, but they express the same relation, right?
17:35:37 <bergey> fread2282: What else would you want besides rLens & rLens'?
17:35:40 <Zekka> Well, yes, you're right that if you wrote either then all monads would be functors
17:36:11 <fread2282> bergey: polymorphic versions
17:36:14 <iasoon> But I guess the behaviour one would want is the latter.
17:36:22 <Zekka> Basically, the first says 'monadness requires functorness'
17:36:30 <Zekka> the second says 'monadness implies functorness'
17:36:48 <Zekka> So if you say the second then you're just saying that if anyone says their thing is a monad you can just deduce how it's a functor too
17:36:53 <silasm> iasoon: it's kind of like a contrapositive, but the effect in haskell is different, since the former adds requirements to defining an instance, and the latter gives you instances for free if you have that instance defined.
17:37:21 <fread2282> also TH support would be nice
17:37:54 <iasoon> I see. Free instances was indeed what I was looking for.
17:38:10 <iasoon> But I figure we can't really have that in Haskell?
17:38:10 <darthdeus> is there a good way to write something like (<*>).(<*>) to reach into two applicatives in the same way that I can write fmap.fmap to reach into two functors?
17:38:22 <Zekka> iasoon: You can get instances for free if you want
17:38:34 <bennofs> :t liftA2.liftA2
17:38:35 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
17:38:37 <darthdeus> except for liftA2 (<*>)
17:38:40 <bennofs> :t liftA2.liftA2.liftA2
17:38:40 <darthdeus> oh cool
17:38:41 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
17:38:44 <Zekka> @let class Cofunctor f where cofmap :: (f b -> f a) -> f b -> f a
17:38:45 <darthdeus> thanks :P
17:38:46 <lambdabot>  Defined.
17:38:48 <silasm> iasoon: the issue is that those free instances are going to be undecidable if you use that method :S
17:39:00 <Zekka> @let instance (Functor f) => Cofunctor f where cofmap = fmap
17:39:01 <lambdabot>  .L.hs:159:18:
17:39:01 <lambdabot>      Could not deduce (b ~ f b)
17:39:01 <lambdabot>      from the context (Functor f)
17:39:01 <lambdabot>        bound by the instance declaration at .L.hs:158:10-35
17:39:01 <lambdabot>        ‘b’ is a rigid type variable bound by
17:39:13 <Zekka> oops
17:39:18 <Zekka> @let class Cofunctor f where cofmap :: (b -> a) -> f b -> f a
17:39:18 <lambdabot>  .L.hs:158:1:
17:39:19 <lambdabot>      Multiple declarations of ‘Cofunctor’
17:39:19 <lambdabot>      Declared at: .L.hs:154:1
17:39:19 <lambdabot>                   .L.hs:158:1
17:39:19 <lambdabot>  
17:39:26 <Zekka> @let class Cofunctor' f where cofmap :: (b -> a) -> f b -> f a
17:39:27 <lambdabot>  .L.hs:160:9:
17:39:27 <lambdabot>      Multiple declarations of ‘cofmap’
17:39:27 <lambdabot>      Declared at: .L.hs:156:9
17:39:27 <lambdabot>                   .L.hs:160:9
17:39:29 <fread2282> @help unlet
17:39:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:39:31 <Zekka> oh, never mind
17:39:34 <fread2282> @help list
17:39:34 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
17:39:34 <Zekka> Oh, right
17:39:34 <bennofs> Zekka: thats just functor
17:39:39 <Zekka> bennofs: That's the point!
17:39:42 <bennofs> @undef
17:39:42 <lambdabot> Undefined.
17:39:44 <darthdeus> bennofs: but what if I'm using liftA2 in order to implement <*>? it seems that it's defined in terms of <*>
17:39:49 <Zekka> I'm trying to show how you can get cofunctor for free
17:39:54 <Zekka> @let class Cofunctor f where cofmap :: (b -> a) -> f b -> f a
17:39:56 <lambdabot>  Defined.
17:40:00 <Zekka> @let instance (Functor f) => Cofunctor f where cofmap = fmap
17:40:01 <lambdabot>  Defined.
17:40:07 <darthdeus> oh wait i'm not
17:40:13 <darthdeus> i already have <*> for the applicatives
17:40:17 <darthdeus> never mind what I said :D
17:40:17 <Zekka> iasoon: So this says that if you already have a functor, you get cofunctor for free
17:40:46 <Zekka> The alternative would be to say "thou shalt define Functor instances before defining Cofunctor instances
17:40:49 <Zekka> "
17:40:54 <jle`> Zekka: um your Cofunctor is the same as Functor, is that intentional?
17:40:55 <fread2282> iasoon: Cofunctor == Functor
17:40:58 <Zekka> jle`: Yes.
17:41:01 <jle`> cool
17:41:19 <Zekka> There's only one way any Functor will ever be a Cofunctor (or any Cofunctor will ever be a Functor)
17:41:27 <jle`> i think when the AMP is done, MonadPlus will be the same way
17:41:32 <Zekka> And that one way always works so there's no point in making people define it manually
17:41:36 <Luke> how do I get cabal to install dependencies for test and other executables in my cabal file?
17:41:56 <fread2282> @let {cofmap' :: (b -> a) -> f b -> f a; cofmap = fmap}
17:41:56 <jle`> class (Alternative m) => MonadPlus m where
17:41:57 <lambdabot>  .L.hs:154:1:
17:41:57 <lambdabot>      The type signature for ‘cofmap'’ lacks an accompanying binding
17:41:57 <lambdabot>  
17:41:57 <lambdabot>  .L.hs:155:1:
17:41:57 <lambdabot>      Multiple declarations of ‘cofmap’
17:42:02 <fread2282> @let {cofmap' :: (b -> a) -> f b -> f a; cofmap' = fmap}
17:42:03 <lambdabot>  .L.hs:155:11:
17:42:03 <lambdabot>      No instance for (Functor f) arising from a use of ‘fmap’
17:42:03 <lambdabot>      Possible fix:
17:42:05 <lambdabot>        add (Functor f) to the context of
17:42:07 <lambdabot>          the type signature for cofmap' :: (b -> a) -> f b -> f a
17:42:10 <iasoon> Whow, wait, how did that just work?
17:42:16 <fread2282> @let {cofmap' :: Functor f => (b -> a) -> f b -> f a; cofmap' = fmap}
17:42:17 <lambdabot>  Defined.
17:42:21 <fread2282> :t cofmap'
17:42:22 <jle`> oh wait it's not analogous
17:42:22 <lambdabot> Functor f => (b -> a) -> f b -> f a
17:42:25 <Zekka> iasoon: A Cofunctor is the same as a Functor.
17:42:43 <mwhit> Luke: Do you have a test-suite target in your .cabal file?
17:42:49 <Luke> yes
17:42:49 <haasn> What is a Cofunctor?
17:42:54 <bergey> fread2282: Yeah, makes sense.
17:43:00 <Zekka> haasn: Flip the arrows in fmap for a big surprise!
17:43:04 <darthdeus> bennofs: hmm I guess I was wrong, I do need liftA2 (<*>) in order to reach two applicatives deep, since if I have  "f (g (a -> b))" and "f (g a)" I can't do liftA2.liftA2
17:43:07 <Zekka> (it's a Functor)
17:43:12 <mwhit> Luke: cabal isntall --enable-tests
17:43:15 <mwhit> install*
17:43:17 <Luke> thanks
17:43:27 <haasn> (a <- b) <- f a <- f b
17:44:25 <ReinH> The problem is that cofunctor is sometimes used to mean contravariant functor
17:44:33 <ReinH> the dual of a Functor is a Functor.
17:44:34 <jle`> Zekka: i think the confusion is that Functor does actually have a dual, it's Contrafunctor, which has (b -> a) -> f a -> f b
17:44:38 <jle`> oh
17:44:42 <jle`> yeah oops
17:44:44 <jle`> sry
17:44:52 <jle`> i actually read about that last week >_>
17:44:55 <Zekka> Yeah, a lot of people say 'Contrafunctor'
17:45:01 <fread2282> bergey: also I can get close enough to nice records with less code using classes and lens
17:45:08 * jle` sinks into the sand
17:45:20 <ReinH> jle`: there there
17:45:21 <Zekka> er, a lto of people say 'Cofunctor' meaning 'Contrafunctor'
17:45:22 <fread2282> contravariant functor
17:45:34 <jle`> it's cozy in here :)
17:45:36 <prophile> contrabassoon
17:45:46 <ReinH> Such bassoon wow
17:45:47 <Zekka> I shouldn't actually pretend to have very much theoretical grounding: this is just Kmett's standard-issue example of a typeclass that appears to be useful but is really equivalent to another
17:46:13 <haasn> I like how in this case we can actually show that it's the same using alpha equivalence
17:47:06 <dwcook> Maybe I'm doing it wrong, but it seems to me that if you flip *all* the arrows in fmap's signature you get (f b -> f a) -> b -> a
17:47:11 <transfuturist> I'm trying to install SFML-control. I followed the SFML package instructions exactly, and I get unrecognized symbols __imp__foo when loading SFML
17:47:17 <dwcook> which seems like a not-so-useful type
17:47:33 <Zekka> It's useful, it's just alpha-equivalent to fmap's type
17:47:36 <haasn> (Alongside parametricity)
17:47:40 <iasoon> Zekka: I'm stuck for a moment. Did you just do that cofunctor thing with language extentions?
17:47:40 <ReinH> dwcook: the f's are a Haskellism.
17:47:59 <Zekka> iasoon: That last one didn't actually take any language extensions
17:48:01 <fread2282> Zekka: alpha-equivalent means much easier to get
17:48:02 <dwcook> ReinH, yeah, I understand Functor is not equivalent to the categorical concept of functor (or endofunctor)
17:48:07 <ReinH> the dual of a morphism between categories is a morphism between categories
17:48:17 <dwcook> So this would be a case of trying to apply CT too literally to Haskell :P
17:48:27 <haasn> ReinH: Is it a morphism between dual categories?
17:48:33 <transfuturist> __imp__foo and _foo are defined in the static MSVC import library for CSFML, while foo with no leading underscores is in the .dll
17:48:34 <Zekka> fread2282: Really? What kind of equivalence do I mean?
17:48:38 <ReinH> the dual of F : C -> D is a functor from D to C
17:48:52 <fread2282> Zekka: than reversing the arrows (Cofunctor)
17:48:57 <ReinH> no, the categories are objects.
17:48:58 <haasn> Oh, right; not C^op -> D^op or something
17:49:04 <ReinH> only arrows are flipped.
17:49:22 <ReinH> Dom and codom are switched and composition is reversed
17:49:31 <ReinH> that gives... another functor
17:49:34 * hackagebot hstatistics 0.2.5.2 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.5.2 (VivianMcPhail)
17:49:37 <hiptobecubic> wouldn't that function just be something like     backwards f = runIdentity . f . return   ?
17:49:48 <haasn> There is a functor taking C to C^op and vice versa, right? Mapping X to X and f : X -> Y to f : Y -> X
17:49:55 <fread2282> alpha-renaing is free in haskell (and pretty much every other language ever)
17:49:59 <haasn> wait, no
17:50:10 <hiptobecubic> I use runIdentity there because I don't know of a uniform way to get something out of a functor
17:50:11 <haasn> That doesn't work
17:50:22 <haasn> It would have to map X to Y and vice versa but that doesn't work in general
17:50:43 <dwcook> hiptobecubic, well, it'd likely be per-instance, and I doubt there'd be that many instances. Identity'd be one of course
17:51:18 <iasoon> Zekka: when I try your example, ghc tells me I need flexibleinstances.
17:51:24 <hiptobecubic> dwcook, but the point is that that function doesn't care about the functor instance
17:51:25 <Zekka> iasoon: Really? Maybe you do.
17:51:27 <hiptobecubic> just the value in it
17:51:31 <Zekka> My mistake if that's so
17:51:35 <ReinH> haasn: it maps X to X for all X on C and morphisms to their dual, right?
17:51:44 <ReinH> *in
17:51:47 <dwcook> hiptobecubic, it does, f would be the instance parameter.
17:51:49 <iasoon> Zekka: I'm quite sure you do
17:52:50 <dwcook> hiptobecubic, I really should've written (WhatEvenIsThis f) => (f b -> f a) -> b -> a -- :P
17:53:17 <fread2282> iasoon: you get ((a -> b) -> f a -> f b) to ((b -> a) -> f b -> f a) by "alpha renaming", that is, you substitute b for a and a for b
17:53:23 <Zekka> By the way, speaking of contrafunctors!
17:53:28 <fread2282> compilers do this for you
17:53:38 <Zekka> Hey iasoon, what does a type that looks like this make you think of? (a -> b) -> f b -> f a
17:54:19 <iasoon> lifting?
17:54:21 <hiptobecubic> dwcook, no sure. It "cares" but not really. You don't need to know what f is. You just need a way to get the function that's mapping over it *out* so you can apply it directly to b
17:54:44 <ReinH> dwcook: an impossibility? ;)
17:54:47 <hiptobecubic> dwcook, but since you can't do that, you can just stick the b value in a trivial f and then extract it again
17:54:55 <ReinH> without additional structure at least?
17:55:28 <hiptobecubic> :t backwards f = runIdentity . f . return
17:55:29 <lambdabot> parse error on input ‘=’
17:55:35 <Zekka> iasoon: Ooh, but an (a -> b) comes in, yet an (f b -> f a) comes out. OooOOOooo!
17:55:37 <hiptobecubic> :t let backwards f = runIdentity . f . return in backwards f
17:55:38 <lambdabot> (FromExpr (Identity c), Show (m a), Monad m) => a -> c
17:55:49 <hiptobecubic> errrr
17:55:51 <haasn> ReinH: That doesn't work; the dual of f : X -> Y is f' : Y -> X; but functors per definition map f : X -> Y to F(f) : F(X) -> F(Y); so if F(f) = f' then F(X) = Y, which breaks the mapping of F(1 : X -> X) to 1 : X -> X
17:55:54 <haasn> (the dual of 1)
17:56:12 <hiptobecubic> :t let backwards d = runIdentity . d . return in backwards d
17:56:13 <lambdabot>     Couldn't match expected type ‘m0 a -> Identity c’
17:56:13 <lambdabot>                 with actual type ‘Expr’
17:56:13 <lambdabot>     In the first argument of ‘backwards’, namely ‘d’
17:56:28 <hiptobecubic> :t let backwards unused = runIdentity . unused . return in backwards unused
17:56:28 <lambdabot>     Not in scope: ‘unused’
17:56:28 <lambdabot>     Perhaps you meant ‘united’ (imported from Control.Lens)
17:56:33 <haasn> A functor taking C to C^op only works on discrete categories, it seems
17:56:47 <hiptobecubic> :t let backwards unused = runIdentity . unused . return in backwards (fmap f)
17:56:48 <lambdabot> (FromExpr c, Show a) => a -> c
17:56:53 <fread2282> also turns out that fmap for (->) == (.)
17:56:57 <hiptobecubic> Alright i don't know
17:57:08 <haasn> (Hmm, discrete category is not the right word for what I wanted)
17:57:17 <ReinH> haasn: hmm
17:57:18 <iasoon> Zekka: I'm not entirely sure what you mean
17:57:27 <ReinH> haasn: you aren't at LambdaJam are you?
17:57:42 <fread2282> (fmap (+1) (+1)) 1
17:57:43 <ReinH> haasn: concrete? unsure
17:57:45 <fread2282> > (fmap (+1) (+1)) 1
17:57:47 <lambdabot>  3
17:58:06 <Zekka> iasoon: How does the (a -> b) turn the (f b) into an (f a)? OoooOOOOOOOooo!
17:58:16 <Zekka> (I thought contrafunctors were confusing and scary when I ran into them first)
17:58:52 <iasoon> Zekka: Ah! I did not even notice the flip, it's getting late :p
17:59:14 <jle`> much spooky
18:00:54 <fread2282> > let (#) = fmap in ((+1) # (*2) # (+1)) 1
18:00:55 <lambdabot>  <hint>:1:7: parse error on input ‘)’
18:00:56 <haasn> I don't know what LambdaJam is; what I meant is that all arrows are endomorphisms - but looking at it more closely, even that breaks because if F(f) = f' and F(g) = g' and F(f.g) = g'.f' (the dual of f.g) then it violates F(f.g) = F(f).F(g) = f'.g' unless f'.g' = g'.f' and I think that implies that f'=g'=1
18:01:53 <iasoon> But, returning to my initial question, I can not simply say "hey GHC, every functor is a cofunctor, for free"?
18:02:06 <fread2282> iasoon: you can
18:02:21 <haasn> Zekka: iasoon: You need FlexibleInstances because (Cofunctor f) is not an instance head of the form (T a₁ a₂ ... a_n)
18:02:21 <Zekka> Apparently it takes an extension though
18:02:46 <haasn> iasoon: If you want to do that, you need to say class Cofunctor f => Functor f
18:02:52 <nezt> Did anyone here read real world haskell in its entirety
18:02:55 <Zekka> haasn: But that's subtly d ifferent
18:02:58 <ReinH> haasn: a FP conference thing going on now. I'll have to think about this more when I'm not in a taxi and can draw diagrams ;)
18:03:00 <fread2282> iasoon: Cofunctor is the same thing as Functor in any reasonable sense
18:03:02 <Zekka> That's "every cofunctor must be a functor"
18:03:10 <Zekka> You still have to manually define the cofunctor instances
18:03:26 <Zekka> fread2282: Yes, that's the reason I used it as an example
18:03:45 <Zekka> everybody does not need to fall over themselves to point out the apparent chink in the armor that was the point of the example
18:03:52 <iasoon> haasn: You also need undecideableinstances, I think?
18:03:57 <haasn> Zekka: You mean “every functor must be a cofunctor”, which is the same in terms of what GHC can derive from a context - but you're right that defining instances requires more overhead
18:04:28 <haasn> Zekka: In either scenario, it's redundant because there is no Cofunctor that is not a Functor - so you can merge the two
18:04:32 <Zekka> Yeah, I just mean that you have to write the instance declarations manually
18:04:50 <Zekka> haasn: But the reason I used it was as an example in general of how you can tell GHC 'go deduce instances for me'
18:04:50 <haasn> iasoon: I don't believe you do, have you tested it?
18:05:03 <Zekka> I don't really care about the Cofunctor case: I just wanted something trivial
18:05:23 <iasoon> haasn: Yes.
18:05:56 <Zekka> I don't think you need undecideable instances
18:06:06 <Zekka> You need flexible instances for the reason haasn described earlier
18:06:06 <haasn> I don't know the decidableinstances rules by heart; but I guess that's because the instance head is not provably smaller than the head
18:06:10 <Zekka> but that's a major difference in degree of evil
18:06:39 <iasoon> Indeed, haasn
18:11:59 <iasoon> But what exactly is 'evil' about undecidable instances?
18:12:39 <haasn> I *believe* the only danger is GHC not terminating
18:12:59 <haasn> But then again, there are far cheaper ways of causing GHC to consume arbitrary (but finite) amounts of resources
18:13:22 <haasn> like type-checking the fmap fmap fmap fmap fmap stuff
18:13:40 <fread2282> if you define more specific instances you have no way of knowing which one will be picked
18:14:04 <Zekka> fread2282: Isn't that Overlapping/IncoherentInstances?
18:14:39 * hackagebot simple-pipe 0.0.0.5 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.5 (YoshikuniJujo)
18:14:55 <haasn> Right, IncoherentInstances is not to be confused with UndecidableInstances
18:15:37 <Zekka> I was under the impression that the evil pecking order is basicaclly the following: no extensions < Flexible < Overlapping < Incoherent
18:15:50 <Zekka> er, Undecidable between Flexible and Overlapping
18:16:26 <haasn> I think No extensions = Flexible
18:16:30 <fread2282> Zekka: IIRC you will get compile errors if you define more than one instance
18:16:59 <Zekka> I'm not sure if you can actually break anything with just Flexible
18:17:11 <fread2282> (that match the same thing) (and you will get compile errors at use site)
18:17:19 <Olegna> I'm a noob to programming, why should I learn Haskell?
18:17:37 <Zekka> Olegna: Because it's easy to use!
18:17:40 * Zekka </facetious>
18:18:01 <Zekka> More seriously, because it does a lot of things "right" which other languages tend to neglect
18:18:03 <roconnor> Olegna: you should learn Agda first.
18:18:10 <Hodapp> Olegna: Because learning a language like Haskell will make you depressed for the rest of your days as you realizes how pathetic most mainstream languages are in comparison.
18:18:12 <Zekka> which is the reason people tend to claim it makes you a better programmer
18:18:16 * Hodapp thwaps roconnor
18:18:29 <fread2282> Olegna: it's very concise and will take much longer than other languages to cease to amaze you
18:18:30 <poseidons-minion> what piles of manure most websites are assembvled from?
18:18:30 <Olegna> haha ok. Interesting
18:18:35 <roconnor> Hodapp: I'm trying an experiment.  I actually think it is a good idea.
18:18:54 <haasn> Zekka: I'm positive that you can't. I don't remember if you can break anything with overlapping, either
18:18:56 <Hodapp> roconnor: experimenting no people?!
18:19:00 <Hodapp> s/no/on/
18:19:06 <haasn> I think you can with orphan instances
18:19:08 <poseidons-minion> haskell intrigues me but the book I have uses a term without defining it, I hate that
18:19:09 <haasn> But not without
18:19:09 <Zekka> I'll clarify what I said a little bit. Some of the things it does "right" are subjective but others it's basically  the difference between acknowledging and not acknowledging the situation
18:19:22 <Zekka> Olegna: Here's an example
18:19:31 <poseidons-minion> I mean I never properly learned to program so I gota sorta learn everything at once, but haskell seems able for almost any task..
18:19:32 <Zekka> er, that is, of the second
18:19:33 <roconnor> Hodapp: It's okay; it's the internet.
18:19:59 <Zekka> A lot of languages tend to use a feature called "types" to catch errors before they happen
18:20:02 <haasn> Olegna: Because it will make you regain faith in computer science
18:20:04 <haasn> (Just ask edwardk)
18:20:08 <nezt> What's the best resource? I feel like RWH is very verbose
18:20:13 <Zekka> That's not all they do but it's a major feature of what they do
18:20:19 <haasn> I dislike RWH with a passion
18:20:42 <Zekka> However, in a lot of languages types heavily restrict what kind of code you're able to write and there's often a mechanism in place to escape the type system entirely
18:20:47 <Hodapp> In some languages, types are more like gods that you must sacrifice to.
18:21:02 <Hodapp> and if you offend the type god, you must apologize to it in some other way.
18:21:03 <haasn> poseidons-minion: How does one “properly” learn to program?
18:21:17 <poseidons-minion> paul graham said ml and strongly typed stops exploratory programming
18:21:22 <Zekka> As a result it's become very popular to ignore the type problem and use a strategy of running until you fail
18:21:26 <nezt> what resources for learning Haskell do you all recommend
18:21:28 <fread2282> quick agda question: can you emulate typeclasses satisfactory
18:21:42 <fread2282> (that sentence is bad grammar, I know)
18:21:43 <poseidons-minion> I dont know!  I know bash and tcl fairly well, tad of forth lisp python and forth
18:21:50 <haasn> nezt: LYAH is probably the most commonly cited introduction
18:21:53 <haasn> @where lyah
18:21:53 <lambdabot> http://www.learnyouahaskell.com/
18:21:54 <Olegna> hmm what are some good resources? What Nezt said
18:22:01 <poseidons-minion> for great good!
18:22:01 <haasn> Opinions are mixed
18:22:07 <fread2282> @where rwh
18:22:07 <Zekka> Now, here's the objective part: Haskell takes this problem very seriously and pays a lot of attention to it
18:22:07 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:22:15 <Olegna> It really seems set apart from most other langs
18:22:41 <Zekka> Here's the subjective-but-nobody-will-seriously-dispute-it part: Haskell's solution is much less verbose than many languages even though it's as restrictive or more than most of them
18:22:55 <fread2282> Olegna: from other well-known langs yes, but there are plenty of haskell-like langs
18:22:57 <Zekka> (see, for instance, type inference, type erasure)
18:23:03 <iasoon> nezt: Olegna: can reccomend both of these books.
18:23:27 <fread2282> Olegna: also this channel :)
18:23:33 <iasoon> *recommend
18:23:39 <Zekka> And the super subjective part is that the benefits in terms of correctess/safety/speed of having a strong type system outweigh the disadvantages of slight verbosity
18:23:50 <Olegna> haha that seems to be the best resource. Consulting with those who have experience with it
18:23:54 <haasn> Haskell takes to the extreme the concept of freedom originating from restrictions
18:24:00 <fread2282> but haskell really isn't that verbose
18:24:03 <haasn> Only by giving up all possibilities do you gain so many more
18:24:23 <Zekka> What you'll generally see in Haskell is a lot of situations that ordinarily look like tradeoffs turnedi nto not-tradeoffs
18:24:38 <platz> Freedom is Slavery
18:24:39 <Zekka> because Haskell's both less verbose than a lot of typeless languages and safer than a lot of type-dense ones
18:25:05 <Zekka> er, in that case, that is
18:25:27 <haasn> I'd say Haskell approaches programming from the top down, not the bottom up - semantics are a first principle, the implementation can follow later - not the reverse
18:25:47 <Zekka> You'll also see it with i.e. effects/control flow: a lot of languages come with builtin effects/control flow and a lot of languages which generally try to scare you off of both
18:26:01 <Zekka> because in most cases it's an ease-of-use/safety tradeoff
18:26:07 <fread2282> haskell is really only verbose compared to lisp or python
18:26:20 <benzrf> fread2282: it is less verbose than python o.O
18:26:25 <jle`> o.o
18:26:28 <jle`> ._.
18:26:29 <fread2282> benzrf: disagree
18:26:37 <benzrf> haasn: haskell is gr8 for bottom up programming, though
18:26:38 <Zekka> In Haskell you generally get pretty good ease of use and a lot of safety at the same time
18:26:58 <jle`> it's less verbose than python if you consider the amount of python you'd have to write to provide the same guaruntees as one line of type signature in Haskell
18:26:59 <Zekka> I'm reluctant to say "great" ease of use but it actually excels in most of the situations other languages excel in
18:27:06 <haasn> The only language I can think of that I'd consider as more concise than Haskell include Agda and APL
18:27:21 <Zekka> its implementation makes things that are much harder to do very visible
18:27:25 <dolio> I wouldn't say Agda is less verbose than Haskell.
18:27:36 <benzrf> map (foo . bar) baz
18:27:37 <benzrf> VS
18:27:39 <dolio> Unless you're doing something that you just shouldn't do in Haskell.
18:27:40 <platz> haasn: I would imagine combining parsers a bottom-up technique, but it would be more difficult to build and entire application that way
18:27:47 <benzrf> [foo(bar(i)) for i in baz]
18:27:52 <Zekka> So in the places where Haskell's take on effects does pretty poorly, most languages with arbitrary effets don't have very much to say at all
18:28:09 <Zekka> compare i.e. Javascript futures to the Asynchronous monad
18:28:22 <fread2282> benzrf: python is more concise with boring imperative code
18:28:33 <benzrf> Zekka: how about promises
18:28:38 <benzrf> promises are functorial and monadic
18:28:39 <jle`> imagine a python sorting algorithm
18:28:43 <Zekka> benzrf: 'future' == 'promise'
18:28:47 <dolio> Maybe you should stop writing boring code. :)
18:28:47 <benzrf> ah
18:28:47 <fread2282> (which there usually exists a nice abstraction for though)
18:28:49 <jle`> in Haskell, you can just say Ord a => ...
18:28:50 <moghedrin> fread2282: If that was the measure by which I measured my language, I would only write in perl.
18:28:53 <Zekka> They're monads but they don't look like normal JS flow control
18:28:54 <haasn> Haskell also takes to the extreme the concept of “power from simplicity” - by giving up all language complexity, we enable ourselves to explore much more
18:28:54 <fread2282> lol
18:28:58 <jle`> in python, you litearlly have to check that each object is not None
18:29:04 <jle`> and that it also has comparators defined
18:29:08 <Zekka> er, promise/future are both monadic types
18:29:12 <haasn> (both within reason; Haskell has limits and they are genuine and circumventing them requires some sort of sacrifice)
18:29:43 <fread2282> jle`: python has exceptions
18:29:49 <Zekka> So you have normal flow control -- line-by-line execution -- and you have promises/futures, which are monadic flow control
18:30:14 <Olegna> I certainly appreciate all the input. This is painting me a great picture of what to expect
18:30:17 <jle`> fread2282: so...hm, you'd only have to check at one place?
18:30:23 <Zekka> which is much larger and much scarier than just having monads
18:30:38 <Zekka> Olegna: Obviously, of course, you're speaking to an opinionated audience
18:30:53 <iasoon> Olegna: also, this community is great ^^
18:31:04 <haasn> Olegna: To me, the defining feature of Haskell at any rate is “correctness”, and that's what keeps me using it. I want to write programs that are provably, statically or intuitively “correct”
18:31:05 <Zekka> I'd argue that pretty much everything the folks here have said is *right*, but if we were all insane freaks we would probably not know that
18:31:48 <fread2282> jle`: no. just because everything can be None doesn't mean it is. most python code just uses exceptions and then you have try blocks
18:32:10 <fread2282> (obviously it's not as safe as haskell)
18:32:11 <jle`> it's also important, haasn, Olegna, that the correctness happens with minimal overhead
18:32:21 <Maxdamantus> monads for promises seems weird to me.
18:32:21 <Zekka> Generally I'd say Python doesn't require that much manual checking and its strategy works pretty well most of the time
18:32:29 <haasn> For that reason, I like purity, sum types, parametricity, referential transparency and probably a lot of other terms that make no sense right now
18:32:32 <jle`> fread2282: doesn't the exception handling provide for less concise code?
18:32:35 <fread2282> yes yes haskell is probably the fastest high-level language
18:32:36 <Zekka> it's not great but it's not really user-hostile
18:32:38 <Maxdamantus> (and futures)
18:32:44 <fread2282> jle`: depends on the code :)
18:33:01 <jle`> fread2282: i guess we can't make any meaningful statement about conciseness then :)
18:33:20 <Zekka> Sufficiently clever Haskell can occasionally square up with C although you can't usually make that claim in general
18:33:48 <fread2282> jle`: lol true, but you still have to deal with your Just or Either monads somewhere (or exceptions, where it becomes the same thing)
18:33:56 <Zekka> For what it's worth my anecodtal statement is that Haskell is probably on a slightly higher expressivity tier than Python: Python is shorter for a lot of programs but it's very ceremonial and will make you cringe a lot
18:33:57 <haasn> I would definitely not make that claim. In fact, I'd almost claim that Haskell can very easily be slow. Haskell isn't a magic performance bullet; imperative languages make it tons easier to write fast code imo
18:34:17 <jle`> fread2282: i'm speaking in the case of a sorting algorithm, where all you have to do to write a "safe sorter" is Ord a => ...
18:34:24 <haasn> The main offender here is laziness
18:34:33 <nezt> did anyone here actually read every sentence of real world haskell? or is it meant more as a ref
18:34:35 <haasn> On the flipside, Haskell makes it easy to turn slow code into fast code
18:34:42 * hackagebot peyotls 0.1.1.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.1.0 (YoshikuniJujo)
18:34:47 <Zekka> I didn't like Real World Haskell enough to finish the first few chapters
18:34:56 <haasn> I don't like RWH's code examples
18:34:57 <jle`> nezt: i never went through RWH :/  by the time i was learning haskell, it was already out of date enough to make it hard to justify to myself
18:34:58 <haasn> I think they're all ugly
18:34:58 <fread2282> on the flipside, profiling haskell is hard
18:35:07 <haasn> fread2282: Depends on the tools :)
18:35:31 <haasn> fread2282: I think the main issue with profiling Haskell is the fact that nobody other than a select elite understands the tools that make it easy
18:35:49 <haasn> I certainly learned a lot from simon marlow's book on parallel and concurrent programming, for example
18:35:52 <jle`> nezt: my path was LYAH -> lots of blog posts -> lots of papers -> parallel & concurrent haskell -> more papers and blog posts -> hi
18:35:57 <platz> at least haskell actually has profiling tools, which many langs lack
18:36:10 <fread2282> jle`: http://rosettacode.org/wiki/Quicksort#Python
18:36:22 <fread2282> haasn: true
18:36:25 <nezt> jle`: what's your academic background?
18:36:28 <Zekka> I'd recommend HaskellForAll if you want a source of good blog posts, but I think it's targeted at moderate-to-advanced users
18:36:35 <haasn> Oh no, more “let's look at this quicksort in haskell” FUD :(
18:37:10 <jle`> nezt: not much...just finished up an undergrad...minor in cs, major in physics w/ a computational emphasis
18:37:56 <nezt> jle`: i just finished a CS degree (undergrad) but don't really have a physics background. do you think it's worth taking more courses or just going on to graduate school for comp sci
18:38:10 <ruuns> there are very good lectures from simon peyton jones on youtube, he's very enjoyable to follow :]
18:38:27 <jle`> nezt: well...it depends on what you want to do
18:38:40 <jle`> i'm not sure if it's too relevant to haskell? :)
18:38:46 <fread2282> the SPJ videos are however mostly for beginners
18:38:53 <haasn> nezt: My path was wikibooks.org/Haskell -> LYAH -> #haskell and from there on it exploded into a fractal of links, papers, blog entries and working with code
18:39:03 <jle`> oh yeah, #haskell was along the entire road
18:39:19 <fread2282> oh yeah, wikibooks is good too
18:39:53 <haasn> I don't remember if it was actually good, I just stumbled upon it by accident and that's how I learned about Haskell and got interested. I wish I could remember what link took me there
18:39:55 <jle`> fread2282: my point was simple things like Ord a => .. in haskell account for a lot of guaruntees in your code that are pretty verbose or out of your way to express in python.  comparing a haskell qsort to a python qsort *with the same length* or the same style is nice...but it hides the "true benefit" of haskell
18:40:07 <jle`> the true benefit of haskell isn't necessarily the nice functional style...it's the safety that you get almost for free
18:40:30 <fread2282> jle`: true
18:41:23 <jle`> but python isn't about correctness, so i'm not sure if it's a "fair" comparison to make ;)
18:41:29 <fread2282> heh
18:41:40 <haasn> Haskell is probably the most powerful language I know when it comes to code reuse and abstractions
18:41:47 <haasn> You can factor everything out and generalize it
18:41:47 <Zekka> I don't know, I think your problem starts to become about "correctness" whenever you're dealing with more than a screenful of code at once
18:41:49 <fread2282> it is possible to write very bad haskell code. see for example yi
18:41:56 <Zekka> er, those quotes are not necessary
18:41:57 <haasn> And you can re-use existing patterns everywhere
18:42:32 <haasn> fread2282: What's wrong with yi?
18:42:34 <platz> I enjoy learning Haskell because it provides a much needed antidote to the OO paradigms I had learned
18:42:50 <Zekka> I was actually considering taking apart Yi for the output system and scripting support earlier
18:42:59 <Zekka> What should I be afraid of?
18:43:06 <haasn> I think the main issue with yi is that it's slooooooow
18:43:19 <fread2282> haasn: have you ever tried to work on it? not enough abstractions
18:43:23 <jle`> Zekka: it was slightly tongue in cheek...python programmers do care about programs behaving correctly --- see all the stuff about TDD and coverage, etc. --- but the python language itself wasn't really built to help it in any way.  correctness comes from outside the language
18:43:41 <jle`> and to many people, That's OK (tm)
18:43:55 <fread2282> haasn: it's slow b/c of Rope (of ByteStrings) -> String -> ByteString conversions in the UI code
18:44:03 <haasn> fread2282: I've dug through the code a bit; my experience has actually been the opposite - everything was hidden behind layers upon layers upon layers of abstractions and generalizations, all of which made basic operations such as “move the cursor one place to the right”​ really slow
18:44:11 <fread2282> Zekka: we really need more peoplei to help
18:44:36 <Zekka> I hadn't actually been planning to work on it: I'm annoyed with my IRC client and was considering writing a new one
18:44:48 <fread2282> haasn: the actual code is slow mostly because of the bad external UI libraries that use String
18:45:02 <Zekka> but I didn't want to do that without a foothold in scripting support and a good terminal-mode output system
18:45:03 <fread2282> Zekka: in Yi?
18:45:18 <Zekka> fread2282: No, using code frankensteined together out of stuff from the Yi codebase
18:45:50 <fread2282> Zekka: yi doesn't have either of those, vty is what we use for terminal output, but it's slow. the scripting support is poor
18:46:14 <Zekka> fread2282: What would you suggest?
18:46:32 <fread2282> Zekka: no clue
18:46:57 <Zekka> I actually liked my brief experiences scripting Yi, even though I know it does a lot of recompilation
18:47:00 <ruuns> How's performance compared to python approximated in general? :]
18:47:05 <fread2282> vty is probably only slow because of the yi backend
18:47:10 <Zekka> ruuns: Blows it out of the water AFAIK
18:47:15 <fread2282> also Yi doesn't have incremental update
18:47:35 <fread2282> that's the real issue
18:47:52 <haasn> Zekka: Speaking of IRC clients, I would personally be super hyped about a haskell scripting plugin for weechat
18:47:54 <haasn> Oh, yi comes with a graphical mode?
18:47:56 <haasn> My performance issues were in the text mode, which ran through my normal terminal emulator (rxvt-unicode, which is among the fastest)
18:47:58 <haasn> ruuns: An order of magnitude, I'd guess?
18:48:00 <haasn> ruuns: Python isn't generally compiled, GHC otoh produces native code that doesn't go through much interpretation
18:48:01 <fread2282> haasn: vty and gtk+
18:48:02 <haasn> Haskell doesn't have as much baggage and complexity as python, which makes it “easy” to compile via machines like the STG
18:48:44 <Tiktalik> so I heard xmonad has bullshit implementation of haskell stuff?
18:48:54 <haasn> Tiktalik: huh?
18:48:54 <benzrf> Tiktalik: bullshit?
18:49:09 <Tiktalik> eh, weird and improperly implemented
18:49:41 <fread2282> and sure yi has abstractions but hey are poorly designed (for example we store the point your cursor is in a buffor for a specific window *inside the buffer structure* instead of inside the window structure)
18:49:58 <fread2282> s/hey/they/
18:50:07 <benzrf> Tiktalik: what do you mean 'of haskell stuff'
18:50:14 <Tiktalik> eh, don't mind me
18:50:16 <Tiktalik> i'm stupid and clueless
18:50:21 <Tiktalik> (seriously)
18:50:22 <fread2282> but OTOH, it's in haskell, so it's actually pretty fun to use and script
18:50:23 <benzrf> xmonad is *in* haskell
18:50:49 <Tiktalik> i'm sorry benzrf, i'll shut up until i get a decent night's sleep
18:51:03 <benzrf> heh
18:51:20 <Tiktalik> but someone was telling me that experienced haskell programmers had trouble making configs for it
18:51:44 <fread2282> Zekka: you could dig through the code, but probably better to just start from scratch with maybe vty
18:51:49 <haasn> I don't think that's the case. xmonad configs is actually one of the first haskell I had ever written, it's so simple you could do it without even knowing haskell
18:52:00 <haasn> Tiktalik: Maybe you're thinking of xmobar?
18:52:29 <haasn> Iirc xmobar has a config file that *looks like* Haskell code but is actually parsed using a custom parser that in no way resembles actual haskell syntax
18:52:31 <benzrf> haasn: maybe theyre both true!
18:52:45 <benzrf> maybe beginners find it easy but experienceds find it dificult
18:52:49 <Tiktalik> haasn: that's possibly it?
18:52:49 <benzrf> *difficult
18:52:53 <Zekka> fread2282: I'm on *nix, but do you know if it builds on Windows?
18:53:22 <Zekka> Some of my pals use Windows and I'd feel bad excluding them
18:53:52 <haasn> Tiktalik: It definitely has caused me lots of trouble because it behaves so unpredictably
18:53:55 <fread2282> Zekka: yi? I think it does
18:54:02 <Fuuzetsu> I can confirm that xmobar's config file simply looks like Haskell but is not actually Haskell
18:54:03 <Zekka> fread2282: I meant vty
18:54:18 <Fuuzetsu> so you're shit out of luck if you try to break things up with regular functions like ++ &c
18:54:41 <haasn> Imo xmonad is actually a great example of configuration for haskell programs
18:54:43 <haasn> One that yi adopts
18:54:44 * hackagebot Zora 1.1.10 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.10 (bgwines)
18:54:56 <fread2282> Zekka: nope
18:55:11 <Zekka> haasn: What does xmonad do that you're a fan of?
18:55:32 <fread2282> Zekka: I've been playing around w/ an IRC client in haskell too
18:55:50 <slack1256> Hi, I'm installing ajhc but I read somewhere it doesn't use Cabal. How do I link modules together?
18:55:51 <haasn> Zekka: 1. Lets me extend my WM not only with configurations of existing logic but also with new logic, 2. lets me generate my configuration in Haskell
18:56:08 <fread2282> I got super simple protocol support working nicely and am constructing a layer on top of it w/ conduit
18:56:14 <haasn> 3. lets me reload this configuration without restarting the program
18:56:51 <haasn> Zekka: for example, instead of providing a hard-coded list of workspaces, I generate them using a haskell function, like: workspaces = workspaceNames 9
18:57:19 <haasn> This is much more concise and flexible than anything expressible in a simple config file, even if it's a haskell record like with xmobar
18:58:01 <slack1256> I am gonna miss XMonad is someday we got Wayland
18:58:12 <slack1256> *s/is/if
18:58:40 <joseph07> slack1256: Scary thought. I have a lot of workflow built into my xmonad.hs
18:59:18 <haasn> I'm not sure if Wayland will ever take off, but if it does, I'm sure somebody will work on providing an xmonad clone
18:59:35 <haasn> #xmonad has voiced strong disapproval of wayland and its concepts in the past, though
19:00:05 <slack1256> I think they are pretty confortable with the current implementation to want it to change
19:00:16 <fread2282> Zekka: I'm p lanning to publish irc-pipes (yes, I'm switching to pipes) which is a lib that gives you runServer :: ServerConfig -> Conduit ServerMessage IO ServerCommand -> IO () (but whatever the pipes version is) where ServerMessage and ServerCommand are nice versions of the IRC protocol that do a good part of the parsing and grouping for you
19:00:41 <haasn> fread2282: I would be super interested in a powerful IRC client built on top of pipes
19:00:48 <haasn> fread2282: Let me know if there's anything I could do to help
19:00:56 <slack1256> I was writing some systray in haskell for the post X world (using dbus instead of XEmbed and evdev), as is just too different to use the same model of X in XMonad in something new.
19:01:20 <fread2282> right now it's just "go through the list of irc messages and implement them"
19:01:28 <byorgey> @tell cheater that looks like a bug, End should be promotable.  You should file a ticket.
19:01:29 <lambdabot> Consider it noted.
19:01:31 <Zekka> fread2282: I think that'd be super cool
19:01:49 <Zekka> I implemented an IRC bot in Haskell a while back but I didn't really parse the messages heavily
19:02:03 <Zekka> instead I just read them into a format where I split each one's head from the rest
19:02:11 <haasn> What's always scared me about implementing IRC is the capacity for servers to be very, very weird
19:02:33 <Zekka> So the internal representation was essentially a fancy version of ("PRIVMSG", ["#haskell", "oh god I'm trapped in a Haskell program"])
19:03:12 <haasn> Like, ideally I'd want to parse all of the “PREFIX=(ohv)@%+ CHANMODES=beIqa,kfL,lj,psmntirRcOAQKVCuzNSMTG CASEMAPPING=ascii EXTBAN=~,cqnr ...” messages sent by the server and actually make sense of them
19:03:18 <fread2282> yea, for example lambdabot does basically that
19:04:03 <joseph07> I recently wrote an asteroids clone, attempting to use the most straight-forward haskell I could. By far the worst looking part was the record updating. I wanted to avoid lens (in the spirit of straght-forwardness) so ended up basically creating haskell 98 lenses. Made me wonder what's so great about lens that a -> (b, b -> a) can't do
19:04:25 <haasn> fread2282: I'd be interested in an IRC architecture that's powerful enough to easily extend it with a mechanism to, say, auto-authenticate to a specific type of service; or to track nick changes (and persist a collection of known “identities”) - sort of like writing middlewares for a web server
19:05:43 <haasn> joseph07: It boils down to re-use of operators, and simplicity of composition
19:05:48 <Zekka> joseph07: Can you compose those?
19:06:01 <haasn> joseph07: with twan's approach you can compose traversals with lenses, lenses with folds, isomorphisms with prisms etc. using just (.)
19:06:18 <MP2E> joseph07 : http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html  <- that article explores creating lenses 'from scratch' and the reasoning behind some of the decisions
19:06:29 <haasn> joseph07: Also, with lens' approach, you can use, say, “toListOf” with traversals, with folds, with lenses, etc.
19:06:50 <haasn> There is a lot of generality involved
19:06:50 <joseph07> Zekka: Yes they form a category
19:07:21 <Zekka> Actually, you're right, they do, although how you do it isn't obvious
19:07:22 <MP2E> You can write a category instance, but the regular prelude (.) won't work
19:07:54 <benzrf> > toListOf _1 (4, 5)
19:07:56 <lambdabot>  [4]
19:08:08 <haasn> @djinn ((a -> (b, b -> a)) -> ((b -> (c, d -> a)) -> ((a -> (c, c -> a))
19:08:08 <lambdabot> Cannot parse command
19:08:13 <joseph07> haasn: it's true that you get a lot of extra goodies with folds traversals prisms etc. but as far as simple record updating goes I don't know if you get a big win
19:08:24 <haasn> @djinn (a -> (b, b -> a)) -> (b -> (c, d -> a)) -> (a -> (c, c -> a))
19:08:25 <lambdabot> f a b c =
19:08:25 <lambdabot>     case a c of
19:08:25 <lambdabot>     (d, e) -> case b d of
19:08:25 <lambdabot>               (f, _) -> (f, \ _ -> e d)
19:08:44 <haasn> yikes, those _ look dangerous
19:09:18 <haasn> joseph07: One of the more minor advantages is “being able to define lenses without depending on the lens library”
19:09:27 <joseph07> haasn: it's actually secretly the representation that data-lens provides
19:09:29 <Zekka> haasn: I think your typesig contains a mistake
19:09:36 <joseph07> haasn: that's true
19:09:42 <haasn> Zekka: oh, indeed
19:09:51 <haasn> @djinn (a -> (b, b -> a)) -> (b -> (c, c -> b)) -> (a -> (c, c -> a))
19:09:52 <lambdabot> f a b c =
19:09:52 <lambdabot>     case a c of
19:09:52 <lambdabot>     (d, e) -> case b d of
19:09:52 <lambdabot>               (f, g) -> (f, \ h -> e (g h))
19:10:10 <Zekka> Yeah, that's not really pretty but it works OK
19:11:29 <haasn> joseph07: Performance might be involved; I think with lens' approach you can get even more performance by inlining the dictionary and coercing the newtypes (safely, with 7.8)
19:13:17 <haasn> Then again, the same probably applies for the (a -> (b, b -> a)) representation
19:13:23 <joseph07> haasn: the thing is that writing asteroids made me think about young haskellers out there getting hung up on record updating and finding that the answer is lens, but then spending half their time reading about lens theory
19:14:07 <haasn> I can certainly agree with the fact that lens is complete overkill if all you need is lenses - lens is less about lenses and more about traversals, folds, prisms and all the other associated lenslikes
19:14:16 <benzrf> haasn: optics
19:14:41 <haasn> edwardk himself has said something along the lines of “it should have been named traversals”
19:15:01 <joseph07> haasn: didn't know that... probably tough to change it now
19:17:32 <joseph07> anyway, I did make a Asteroids branch using lens, and then derived my own lens from scratch which turned out to be pretty much data-lens
19:17:51 <benzrf> haasn: y not `optic'
19:18:03 <slack1256> How do I specify libraries in Ajhc?
19:18:04 <joseph07> optic sounds weird
19:19:09 <fread2282> haasn, Zekka: I'll throw it up on github tomorrow
19:19:21 <fread2282> what I have so far
19:19:57 <fread2282> if you're interested
19:21:23 <isd> Hey; I've got a list of values of type (K -> IO K), which I want to bind in sequence (i.e. [w,x,y,z] becomse w >>= x >>= y >>= z. it would be trivial to write a function that just that to the list, but I have to imagine there's one in the standard library somewhere that I should just use. I'm having trouble finding it though; any hints?
19:21:49 <joseph07> isd: foldr?
19:24:09 <isd> I feel silly now.
19:24:11 <isd> thanks.
19:24:31 <tac_> cabal install is saying I have a package (network-2.5.0.0) installed... but ghc-pkg list doesn't show it as being actually installed
19:24:38 <tac_> any ideas why I'm getting this discrepancy?
19:26:23 <rasfar> tac_: are you in a sandbox?
19:26:25 <tac_> yes
19:26:30 <tac_> rasfar: ^
19:26:40 <rasfar> ah! try cabal exec -- ghc-pkg list
19:26:52 <tac_> with the space after the -- ?
19:26:56 <rasfar> yep
19:26:58 <tac_> kk
19:26:59 <joseph07> isd: no problem (probably foldr (=<<) I think)
19:27:11 <tac_> (what does the double dash do?)
19:27:36 <rasfar> cabal exec takes some options, then after the -- things are handed over to the command you exec
19:27:42 <tac_> ah ok
19:27:54 <tac_> that would be what's causing my bigger issue
19:27:55 <rasfar> (i'm not sure -- is nec. in every case, but it was needed to run a shell script)
19:28:07 <tac_> there's an extra copy of network (different version) causing problems
19:28:27 <haasn> From cabal exec --help: “Usage: cabal exec [FLAGS] COMMAND [-- [ARGS...]]”
19:28:36 <rasfar> you should be able to unregister it from the sandbox using cabal exec -- ghc-pkg unregister
19:29:12 <rasfar> there is also "cabal sandbox hc-pkg" which i just heard of yesterday, does something similar
19:29:12 <zq> any haskell people here?
19:29:55 <zq> more precisely, any pl people here who could tell me why things like typeclasses and record accessors aren't namespaced
19:30:27 <haasn> record accessors not being namespaced gets some mixed opinions
19:30:38 <rasfar> the other way to go is to provide the explicit path to your package db to ghc-pkg
19:30:40 <haasn> But usually to control namespaces we use modules and the module import system
19:30:47 <rasfar> ghc-pkg --package-db=./.cabal-sandbox/i386-linux-ghc-7.8.1-packages.conf.d <command>
19:31:19 <haasn> So the idea is that if you want to have different class methods and/or record fields collide, you'd put them into separate modules that can be imported qualified
19:31:25 <monochrom> there is also "cabal hc-pkg"
19:31:38 <rasfar> cabal sandbox hc-pkg, yeah
19:31:39 <zq> yeah but that's mega unwieldy
19:32:13 <zq> because each file contains at most one module
19:32:33 <rasfar> (no doubt the three ways each have their peculiarities)
19:33:20 <slack1256> is not that bad on medium/small projects, but for big project the possibility of name clashed gets higher. So in 7.10? we will have a new record system.
19:33:25 <bergey> Instances aren't namespaced because you don't want different functions picking different instance definitions for the same type.
19:33:37 <zq> slack1256: wow what
19:34:02 <zq> bergey: i never asked about instances being namespaced, just the typeclasses
19:34:03 <slack1256> zq: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields?redirectedfrom=Records/OverloadedRecordFields/Plan
19:34:09 <zq> not even sure how instance ns-ing would work
19:34:31 <zq> so for instance SqlPersistT.askConnSql
19:34:35 <dfeuer> zq, I think Oleg Kiselyov may have done some work on that.
19:34:53 <zq> dfeuer: typeclass namespacing or the new record stuff in 7.10?
19:37:15 <enthropy> zq: what do you mean by namespaced classes? You can certainly have many different classes called C in scope
19:37:50 <dfeuer> zq, there was something about local instances or some such in a paper he wrote or co-authored.
19:38:02 <enthropy> @hackage HListPP
19:38:02 <lambdabot> http://hackage.haskell.org/package/HListPP
19:38:36 <enthropy> is one approach to avoiding conflicts from record accessors with the same name that do the same thing
19:39:46 <zq> enthropy: for instance, Eq.==
19:39:49 <dfeuer> Oh, that. Blech. Not sure what I think about that extension, but it sounds shady.
19:40:07 <zq> slack1256: thanks for the link
19:40:52 <enthropy> zq: so being able to get a function like groupBy out of group?
19:41:15 <zq> enthropy: Data.List.group, you mean?
19:41:19 <enthropy> yeah
19:41:20 <haasn> enthropy: That sounds a lot like reflection
19:42:04 <enthropy> oh namespaced meaning that Prelude.== is Prelude.Eq.== instead
19:42:23 <pingu> Is there a way to abort a haskell program without any chance of having an exception caught or a bracket run?
19:42:32 <slack1256> np :-)
19:42:34 <pingu> best I've got is: raiseSignal sigABRT
19:42:58 <pingu> Is there nothing more idiomatic?
19:43:14 <haasn> not having brackets run seems unidiomatic in the first place
19:43:45 <pingu> well, sometimes you really want to be sure that nothing further happens.
19:43:55 <zq> enthropy: class Functor f where { fmap :: f (a -> b) -> f a -> f b; }; let z = Functor.fmap in z (+1) [1..23]
19:44:13 <zq> enthropy: of note is Functor.fmap
19:44:27 <zq> where the dot is a namespace resolution
19:44:38 <zq> i hesitate to call it a member accessor because member conjures oop imagery
19:44:39 <enthropy> some exceptions are supposedly uncatchable... probably sigABRT is unix-specific?
19:45:40 <pingu> enthropy: yeah, that's the only reason I don't want to use it
19:45:55 <enthropy> zq: maybe it's the same idea as this imaginary syntax:   module Prelude (head, tail, blahblah, module qualified Data.Functor as Functor) where
19:45:58 <pingu> enthropy: do you know where it's said that some exceptions are uncatchable?
19:46:30 <enthropy> you can re-export modules like that, but you just can't re-export them qualified
19:47:50 <enthropy> pingu: we have the opposite problem http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/24819
19:50:12 <bms1> What does putting a ' symbol in front of a constructor do?
19:50:30 <bms1> (Particularly, I'm seeing it in front of the list constructors)
19:50:57 <bms1> https://hackage.haskell.org/package/HList-0.3.4.1/docs/src/Data-HList-HList.html#HList (see the first data declaration)
19:51:46 <gfixler> am I right that the following is wrong?
19:51:55 <Cale> bms1: Lifts it to the type level
19:52:08 <gfixler> instance Functor (Map k) where fmap f (Map k) v = Map k (f v)
19:52:33 <gfixler> LYAH chapter 8 asked me to figure it out, but it doesn't seem to address every value
19:52:36 <Cale> gfixler: Yes, that's incorrect
19:52:44 <bms1> Cale: I don't think I've had to do this for my own types when I promote them. Is it because they're infix or something?
19:52:51 <gfixler> Cale: thought so, thanks
19:52:52 <Cale> Map probably isn't a data constructor
19:53:15 <gfixler> I'm just using it as a stand-in
19:53:18 <gfixler> like Either
19:53:24 <Cale> gfixler: how is LYAH's Map data type defined?
19:53:47 <gfixler> It isn't - it just wanted me to see if I could figure out how Functor is defined for maps
19:54:01 <monochrom> either LYAH has its own Map, or LYAH is just asking you to imagine
19:54:02 <gfixler> map k v
19:54:04 <bms1> Cale: Oh, Haskell doesn't object if I add that tickmark before my own data kinds as well, cool
19:54:15 <gfixler> monochrom: yes, I'm to imagine
19:54:41 <gfixler> it shows instance Functor (Either a) where ...
19:54:43 <Cale> bms1: https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html see 7.8.2.1 here, it's just to handle possible ambiguity
19:55:10 <gfixler> then said "Try figuring out how Map k is made an instance of Functor by yourself!"
19:55:27 <Cale> gfixler: Is it using Data.Map?
19:55:31 <gfixler> I don't know how to check if I'm right, though
19:55:33 <bms1> Cale: thanks!
19:55:35 <monochrom> I think it's an ill-posed question.
19:55:43 <benzrf> is Map a Monad?
19:55:43 <gfixler> Cale: yes, theoretically
19:55:46 <gfixler> I'm not actually running this
19:55:53 <Cale> You could write it in terms of toList and fromList
19:55:57 <gfixler> but presuming Data.Map style maps
19:55:59 <Cale> (with a bit of an efficiency hit)
19:56:10 <Cale> Data.Map already contains a map function though
19:56:12 <gfixler> Cale: that's what I'm missing
19:56:18 <Cale> which you could also use to implement fmap
19:56:21 <gfixler> how to work on all of the map
19:56:34 <monochrom> do you even know how Map is implemented?
19:56:43 <monochrom> and does LYAH even say?
19:56:50 <Cale> I don't think it does
19:56:52 <gfixler> monochrom: no
19:56:55 <Cale> (just scanning here)
19:56:57 <gfixler> I presumed with hashes
19:57:00 <Cale> Nope!
19:57:05 <Cale> It's binary balanced trees
19:57:07 <gfixler> tries?
19:57:11 <gfixler> ah, I think it did say that
19:57:17 <gfixler> sets and maps as balanced trees
19:57:20 <gfixler> but it was an aside
19:57:43 <gfixler> Chapter 8: "Sets and maps from Data.Set and Data.Map are implemented using trees, only instead of normal binary search trees, they use balanced binary search trees, which are always balanced. But right now, we'll just be implementing normal binary search trees."
19:57:45 <monochrom> at this stage it's like I teach you a course, I tell you how to write "f x = x + x" in the lecture, then I give out an assignment "figure out how to write fib yourself!"
19:57:47 <gfixler> that's all it says
19:57:48 <Cale> Data.Map doesn't export the data constructors for the trees, so you can't write the really efficient map function directly by pattern matching
19:57:56 <gfixler> monochrom: pretty much
19:58:09 <gfixler> I don't think it was actual homework - more like "Give it a try!"
19:58:23 <gfixler> It may revisit things later (not sure)
19:58:43 <Cale> However, you could use toList and fromAscList to get an O(n) implementation, where the latter is a somewhat unsafe function that presumes that the list is already sorted by key (and generates a garbage Map if not)
19:59:08 <gfixler> Asc being "Ascending?"
19:59:15 <Cale> yes
19:59:31 <gfixler> it did teach toList and fromList, but it was awhile ago, and they slipped my memory
19:59:46 <Cale> yeah, if you don't care too much about performance, those'll do
19:59:49 <gfixler> I think I have everything needed to do this; I don't actually need to know how maps are implemented
19:59:59 <gfixler> it' definitely not about performance at this point
20:00:12 <gfixler> it's more about holding on for my life and screaming
20:00:29 <Cale> Yeah, there's another possible implementation which recurses through the tree, but that requires you to actually have access to the constructors, which Data.Map doesn't export
20:01:02 <gfixler> performance is way down the road
20:01:09 <gfixler> I'm currently trying to accomplish anything at all
20:01:31 <Cale> okay
20:01:39 <gfixler> I just wanted to confirm that I did in fact need to go through all the keys manually
20:01:53 <Cale> So if you apply toList to some map m, you'll get a list which looks like [(k1,v1), (k2,v2), ...]
20:02:01 <gfixler> i.e. that I'm required to visit everything in my fmap implementations (which I was pretty sure of)
20:02:08 <gfixler> Cale: right
20:02:15 <Cale> which you could then process with a list comprehension (or map for lists), in order to apply a function to each of the v's
20:02:27 <gfixler> yep - LYAH did give me the tools
20:02:33 <gfixler> I just wasn't seeing the connections yet
20:07:04 <gfixler> instance Functor Map where fmap f m = fromList [(k,f v) | (k,v) <- toList m]
20:07:11 <gfixler> closer?
20:08:01 <Cale> yes!
20:08:05 <gfixler> \o/
20:08:14 <gfixler> it's the little things
20:08:17 <Cale> oh, one little thing
20:08:24 <gfixler> aww, I knew it
20:08:26 <Cale> The instance of Functor is for Map k
20:08:32 <gfixler> ok
20:08:41 <jle`> :t fmap
20:08:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:08:43 <benzrf> fromList . map (second f)
20:08:46 <Cale> i.e. instance Functor (Map k) where ...
20:08:46 <benzrf> :t fromList . map (second f)
20:08:47 <lambdabot>     Not in scope: ‘fromList’
20:08:47 <lambdabot>     Perhaps you meant one of these:
20:08:47 <lambdabot>       ‘IM.fromList’ (imported from Data.IntMap),
20:08:49 <jle`> see why Map doesn't make sense to go in there?
20:08:53 <benzrf> :t M.fromList . map (second f)
20:08:54 <lambdabot> (FromExpr a, Show b, Ord k) => [(k, b)] -> M.Map k a
20:08:56 <jle`> (a -> b) -> Map a -> Map b ...?
20:08:58 <gfixler> because fmap requires a type constructor of 1 parameter
20:08:58 <benzrf> :-)
20:09:13 <Cale> This is a kind error. Kinds are like the "types of types"
20:09:16 <gfixler> instance Functor (Map k) etc...
20:09:16 <Cale> :k Integer
20:09:16 <jle`> (a -> b) -> Map k a -> Map k b, is more like it :)
20:09:17 <lambdabot> *
20:09:27 <Cale> Ordinary types with values in them have kind *
20:09:32 <Cale> :k Maybe
20:09:33 <lambdabot> * -> *
20:09:43 <Cale> Type level functions like Maybe have kind * -> *
20:09:47 <gfixler> benzrf: much nicer pointfree
20:09:49 <Cale> :k Map
20:09:50 <lambdabot>     Not in scope: type constructor or class ‘Map’
20:09:50 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
20:09:52 <Cale> :k M.Map
20:09:53 <lambdabot> * -> * -> *
20:10:11 <Cale> Map takes two type parameters and produces a type
20:10:17 <Cale> :k Functor
20:10:18 <lambdabot> (* -> *) -> Constraint
20:10:24 <gfixler> I *just* got to kinds in LYAH
20:10:26 <gfixler> haven't read it yet
20:10:30 <Cale> ^^ Functor needs a parameter of kind * -> *
20:10:41 <Cale> :k M.Map Integer
20:10:42 <lambdabot> * -> *
20:11:02 <Cale> So it's possible for Map k to be a Functor, for each type k
20:11:16 <gfixler> I think that makes sense
20:11:28 <Cale> :k Either
20:11:29 <lambdabot> * -> * -> *
20:11:31 <Cale> :k Either Integer
20:11:32 <lambdabot> * -> *
20:11:34 <Cale> :k Either Integer String
20:11:35 <lambdabot> *
20:11:40 <gfixler> nice
20:12:00 <gfixler> is this the same as/similar to currying?
20:12:12 <Cale> yeah, these type constructors are curried :)
20:12:37 <gfixler> good, because I understand currying (probably)
20:12:39 <Cale> :k (->)
20:12:39 <lambdabot> * -> * -> *
20:12:52 <Cale> :k IO
20:12:53 <lambdabot> * -> *
20:12:55 <gfixler> hmmm
20:13:01 <Cale> :k StateT
20:13:02 <lambdabot> * -> (* -> *) -> * -> *
20:13:03 <gfixler> I'd expect :k (->) to be * -> *
20:13:19 <Cale> Well, (->) takes two types, and produces the type of functions from one to the other
20:13:22 <jle`> :k Int -> Bool
20:13:23 <lambdabot> *
20:13:27 <jle`> :k (->) Int Bool
20:13:28 <lambdabot> *
20:13:32 <jle`> :t (->) Int
20:13:33 <lambdabot> parse error on input ‘->’
20:13:37 <jle`> :k (->) Int
20:13:38 <lambdabot> * -> *
20:13:41 <jle`> :k (->)
20:13:42 <lambdabot> * -> * -> *
20:14:18 <gfixler> Cale: got it
20:14:51 <gfixler> Haskell is a bag full of really simple things that keep blowing my mind
20:15:00 <Cale> :D
20:15:15 <gfixler> like when I finally understood how Just was working
20:15:23 <jle`> @let data Crazy m f a b = Crazy (f a b -> m a -> a b)
20:15:24 <lambdabot>  Defined.
20:15:24 <gfixler> and that it really wasn't actually anything
20:15:27 <jle`> :k Crazy
20:15:28 <lambdabot> ((* -> *) -> *) -> ((* -> *) -> * -> *) -> (* -> *) -> * -> *
20:15:42 <gfixler> Kirby dance?
20:15:57 <jle`> pointy nose kirby
20:16:33 <gfixler> I haven't gotten to the chapter on Functional Kirbies yet
20:17:29 <Cale> @let data S x y z = S (x z (y z))
20:17:30 <lambdabot>  Defined.
20:17:33 <Cale> :k S
20:17:34 <lambdabot> (* -> * -> *) -> (* -> *) -> * -> *
20:17:58 <Cale> aw, we need kind polymorphism...
20:18:00 <Cale> :D
20:18:03 <gfixler> siamese kirby -> regular kirby -> ghost kirby
20:18:19 <Cale> haha
20:19:19 <jle`> kind is nice because it gives us vocabulary to say things like "why can't Map be a Functor"
20:19:24 <jle`> amongst other things
20:20:36 <Cale> :k MonadTrans
20:20:37 <lambdabot> ((* -> *) -> * -> *) -> Constraint
20:20:54 <Cale> such kirbies
20:21:26 <gfixler> I was already excited about learning Haskell, but now that there are Kirbies...
20:22:07 <toblerone> what does "Constraint" mean in that kind signature/
20:22:08 <toblerone> ?
20:22:09 <jle`> @let (^-^) = ("(^-^)"++).repeat.head
20:22:10 <lambdabot>  Defined.
20:22:15 <jle`> > (^-^)"~~>"
20:22:16 <lambdabot>  "(^-^)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~...
20:24:11 <jle`> toblerone: it's a Constraint, something that can go before a =>
20:24:15 <jle`> ...at least that's how i understand it
20:24:25 <jle`> :k Functor
20:24:26 <lambdabot> (* -> *) -> Constraint
20:24:39 <haasn> I guess in a sense, you could say that (=>) :: Constraint -> * -> *
20:24:52 <jle`> haha
20:24:54 <Zekka> :k (=>)
20:24:54 <lambdabot> parse error on input ‘=>’
20:24:57 <Zekka> =(
20:25:04 <Cale> Yeah, except that variable binding messes with that a bit
20:25:14 <jle`> Constraints form a Monoid under (,)
20:25:24 <jle`> (,) :: Constraint -> Constraint -> Constraint ???
20:25:26 <jle`> :k (,)
20:25:26 <benzrf> :k Num a
20:25:27 <lambdabot> * -> * -> *
20:25:27 <lambdabot> Not in scope: type variable ‘a’
20:25:30 <Cale> heh
20:25:33 <jle`> :k (,)
20:25:33 <benzrf> :k forall a. Num a
20:25:33 <lambdabot> * -> * -> *
20:25:34 <lambdabot> Constraint
20:25:34 <jle`> oh yeah
20:25:38 <Cale> There's also no way to refer to that thing on its own
20:25:38 <jle`> it's the product >_>
20:25:44 <benzrf> :k forall a. (Num a, Show a)
20:25:45 <lambdabot> Constraint
20:25:48 <benzrf> :-o
20:25:54 <benzrf> shouldnt it be [] then
20:26:02 <toblerone> hmm interesting... I guess I didn't realize constraints were represented at the kind level... not that I really understood kinds all that well to begin with...
20:26:09 <haasn> Cale: Right, if (=>) had a kind signature then ConstraintKinds should allow us to manipulate it (eg. in a type family)
20:26:13 <benzrf> :k (=>)
20:26:14 <lambdabot> parse error on input ‘=>’
20:26:15 <Cale> benzrf: wow, I didn't know *that* was valid
20:26:15 <gfixler> lambdabot race conditions - I don't know which output to believe
20:26:17 <haasn> (=>) really is a syntax form of its own
20:26:18 <jle`> toblerone: it's nice because sometimes you want to provide a Constraint to type families
20:26:30 <benzrf> :k Num a => a
20:26:31 <lambdabot> *
20:26:34 <benzrf> :k Num Int
20:26:35 <lambdabot> Constraint
20:26:37 <jle`> like...you'd want to provide a Constraint to a type-level function
20:26:47 <jle`> and it's nice to say "this parameter has to be a constraint, not a *"
20:27:08 <Cale> You'd really want to say something about how the variables in the constraint relate to the variables in the type-level function.
20:27:15 <Cale> or the parameters
20:27:34 <jle`> ah, yeah
20:27:50 <haasn> jle`: you can use it to construct constraints
20:28:10 <haasn> for example type family NotEq a b :: Constraint where NotEq a a = (1 ~ 0); NotEq a b = ()
20:28:28 <haasn> This could be used to construct a “not equal” constraint, sort of like the opposite of (~); but I'm not sure how well that actually works in practice
20:28:37 <jle`> that's neat
20:28:50 <stolaruk> Is it considered to be a code smell for a large program to have a lot of data in the State monad?
20:28:57 <tac_> Has anyone seen cabal install just... hang... right after it says Resolving Dependencies?
20:28:58 <haasn> But you could also use it for something like EnsureComplicatedTuringCompleteCondition a b c d ~ 'True => ...
20:29:06 <haasn> where Ensure... is some type family calculating the condition you want to check
20:29:09 <jle`> stolaruk: data?
20:29:23 <haasn> With ConstraintKinds you can just make that thing itself a constraint instead of returning 'True
20:29:24 <stolaruk> jle`: Well a large structure
20:29:35 <dcoutts> tac_: it's probably not hanging but working rather hard. Did you check top?
20:29:36 <jle`> stolaruk: as in, your State s a has a large structor for s?
20:29:41 <benzrf> :k 1 ~ 0
20:29:41 <lambdabot>     Illegal literal in type (use DataKinds to enable): 1
20:29:45 <benzrf> tsk
20:29:52 <jle`> :k Int ~ Bool
20:29:53 <lambdabot> Constraint
20:29:54 <tac_> dcoutts: let's take a looksee
20:29:54 <stolaruk> jle`: I am writing a game and all the state of the game world is in the State monad, in the form of nested record types
20:29:55 <benzrf> :k Int ~ String
20:29:55 <lambdabot> Constraint
20:30:03 <Zekka> :k (~)
20:30:03 <lambdabot> k -> k -> Constraint
20:30:14 <Zekka> What's a k?
20:30:21 <Zekka> Is it polymorphic over what's on the sides?
20:30:23 <benzrf> Zekka: kind var
20:30:25 <benzrf> forall k.
20:30:46 <benzrf> @let impossible :: Int ~ String => String; impossible = "how'd you get this?!"
20:30:46 <lambdabot>  Parse failed: TypeFamilies is not enabled
20:30:49 <tac_> dcoutts: ah, it just terminated. It looks like I have a dependency loop somewhere....
20:30:49 <benzrf> dang
20:30:55 <jle`> stolaruk: i'm personally not a fan of using state monad for games, but...you can do this in a structured/disciplined way if you try your best to write your individual State s a's with s's that are a "small part" of the big state
20:30:56 <benzrf> @let impossible :: (Int ~ String) => String; impossible = "how'd you get this?!"
20:30:56 <lambdabot>  Parse failed: TypeFamilies is not enabled
20:30:59 <benzrf> ?!
20:30:59 <lambdabot> Maybe you meant: v @ ? .
20:31:05 <toblerone> jle`: what do you mean by constraints form a monoid under (,)? What is (,) in the context of constraints? A tuple?
20:31:08 <tac_> "Backjump limit reached (change with --max-backjumps).
20:31:09 <tac_> "
20:31:22 <benzrf> toblerone: the operator that goes between constraints
20:31:22 <jle`> stolaruk: for example, if your giant state is GiantState, and you have a small component SmallPart
20:31:34 <benzrf> toblerone: (Num a, Show a)
20:31:39 <jle`> stolaruk: if you have a function that only "needs" SmallPart, you can write it in State SmallPart monad
20:31:46 <haasn> Zekka: think of it like an unbound variable in the type system; in the spirit of (~) :: forall k. k -> k -> *
20:31:56 <Zekka> haasn: Yeah, I follow
20:31:57 <haasn> so yes, it's kind-polymorphic
20:31:57 <jle`> stolaruk: and then use a function (State SmallPart a) -> (State GiantState a)
20:32:01 <benzrf> :k (,)
20:32:02 <lambdabot> * -> * -> *
20:32:07 <benzrf> meh
20:32:08 <jle`> stolaruk: in order to "use" it in your big giant state monad
20:32:12 <stolaruk> jle`: That's interesting...
20:32:18 <jle`> stolaruk: you can do this easily using the lens library
20:32:20 <haasn> err, Constraint not *
20:32:25 <stolaruk> jle`: YEs I am using lens
20:32:34 <jle`> stolaruk: where if you had a lens from GiantState to SmallPart, there's a simple function to turn a State SmallPart a into a State GiantState a
20:32:41 <jle`> stolaruk: i believe it's called zoom
20:32:42 <stolaruk> jle`: Lens gives me concise and beatufiul syntax for drilling down into the state
20:32:43 <toblerone> benzrf: what just happened there? Did it just return the kind of a tuple, or the "constraint operator"?
20:32:56 <toblerone> tuple right?
20:33:07 <Cale> toblerone: yes
20:33:11 <jle`> stolaruk: the problem here isn't the ability to access --- the problem is that every function in the naive approach basically has access to the *entire* state
20:33:14 <Zekka> jle`: What do you use instead of State for this sort of problem?
20:33:14 <stolaruk> jle`: I haven't used zoom yet but yea zoom will let you "focus" on an inner part of the structure
20:33:19 <Cale> toblerone: (,) is the type constructor for pairs
20:33:24 <toblerone> right
20:33:28 <jle`> stolaruk: which is something that we use Haskell to avoid in the first place, right?  global state = bad? :)
20:33:30 <haasn> (,) is a bit hard to work with in the context of constraints for the same reason as =>, we can't really refer to it directly
20:33:38 <jle`> stolaruk: it's something even OOP languages have realized was bad :)
20:34:03 <toblerone> but (Int, Int) is a pair, while (Num a, Show a) is something else...
20:34:04 <haasn> there is a family of constraints (a, b); (a, b, c); (a, b, c, d) and so on, where a,b,c... are constraints
20:34:12 <jle`> stolaruk: if you peek around http://hackage.haskell.org/package/lens-4.3/docs/Control-Lens-Zoom.html, i think you'll be able to find a way to do that 'lifting'
20:34:16 <haasn> but there is not a (,) “constraint constructor”
20:34:17 <stolaruk> jle`: Yes. What prompted me to ask the question is that I also have a logging service and I am thinking of putting stuff related to the concurrency of the logging service (TBQueue and Async) in the state as well.
20:34:32 <stolaruk> jle`: Bcus I don't know where else I can put it
20:34:35 <jle`> stolaruk: yeah, it sort of has to go there.
20:34:38 <haasn> There is also a constraint () which is always true, eg. id :: () => a -> a
20:34:44 <haasn> :t id :: () => a -> a
20:34:45 <lambdabot> a -> a
20:34:45 <stolaruk> jle`: I wonder if my State might just continue to grow...
20:34:52 <stolaruk> jle`: Could it get "too big"?
20:35:01 <stolaruk> jle`: Like some kind of OOP God Class
20:35:05 <jle`> stolaruk: actually, that can go in the reader part of an RWS monad
20:35:05 <Cale> toblerone: right... there's no way to directly refer to that operation on constraints. All this representation of constraints at the kind level stuff is relatively new. If it had been designed this way right from the beginning, perhaps the notation for gluing constraints together would be different.
20:35:13 <jle`> stolaruk: yes, this is the problem with using State monad for games :)
20:35:20 <jle`> stolaruk: the disciplined approach i was talking about can mitigate it, slightly
20:35:21 <Zekka> jle`: You still haven't said what you should do instead
20:35:27 <stolaruk> jle`: I thought of that but... what if I want to restart the logging service? Then I need new state!
20:35:39 <jle`> stolaruk: you separate your "concurrecny related" state, and your "game-related" state, whenever possible
20:35:55 <jle`> stolaruk: you write functions dealing with your game-related state, and functions delaing with your concurrecny-related state, in the proper State s
20:36:02 <jle`> then use combinators from 'zoom' to make them work on your giant state
20:36:19 <jle`> in that way, when you "add new components" to your giant state, you can still re-use your old code
20:36:28 <jle`> it's...still not really scalable, i think
20:36:37 <haasn> Cale: I guess the closest we can get is with a type family (a :: Constraint) * (b :: Constraint) :: Constraint where a * b = (a,b)
20:36:43 <haasn> Then we can refer to (*) itself
20:36:51 <jle`> but so far it's the best way i've found to use the State monad approach with discipline that takes off *some* of the major drawbacks/downsides
20:36:54 <stolaruk> jle`: Well I could make a (bigger) tree of nested record types... at the top is "GameState" / "LogState".... with lots more under GameState
20:37:00 <jle`> stolaruk: yeah, exactly
20:37:08 <jle`> well, my recommend approach would be a locally stateful route :)
20:37:10 <Zekka> jle`: How do you feel about people who repeat themselves?
20:37:12 <Cale> haasn: yeah
20:37:19 <Zekka> Oh, alright. What does that entail?
20:37:20 <jle`> Zekka: heh.  sorry, i just wanted to finish the thought
20:37:23 <jle`> before i moved on
20:37:30 <dfeuer> (flip . flip . flip) . (flip . flip . flip) $ (*)
20:37:35 <Zekka> (I tend to use *uberstate* in my programs)
20:37:44 <jle`> Zekka: you use components that maintain their own internal state, and compose them
20:38:09 <jle`> i go a bit in-depth to this in the introduction/README to my auto library
20:38:12 <jle`> https://github.com/mstksg/auto
20:38:17 <jle`> (still in development)
20:38:17 <Zekka> I'll read it
20:38:28 <jle`> and i explain the principles of locally stateful composition, and its advantages over giant-state-monad approaches
20:38:49 <jle`> and i repeat the problems i mentioned here, and present an alternative :)
20:39:42 <Zekka> Elevator pitch looks alright, where do I go from there?
20:39:59 <jle`> there are current implementations of locally stateful composition, like netwire
20:40:04 <jle`> and arguably frp in general
20:40:19 <jle`> however those operate using a semantic framework designed for continuous time contexts
20:40:27 <Zekka> oh, an examples project
20:41:12 <jle`> yeah heh.  come back in a month or so and i'll hopefully have a release version ready for auto so i can say "use my library! :D"
20:41:21 <jle`> but right now there are some motivating example projects up that demonstrate this
20:41:41 <Zekka> I kind of want to plunder it for ideas and see if I can do anything interesting with them
20:41:49 <jle`> you are welcome to do that too :)
20:42:01 <Zekka> lately I do a lot of hackery in Elm and that's pretty explicitly targeted at games
20:42:01 <jle`> for now, if your game is in continuous time, you can use an FRP library
20:42:23 <jle`> if it's not, or you want to stick with the giant state monad approach, i think the zoom/lens based way offers the best disciplined approach
20:42:27 <Zekka> but it's simultaneously (IMHO) not too good at managing state and afraid of "complicated" abstractions like monads
20:42:44 <jle`> oh!  also one other principle for disciplined State monad usage
20:42:55 <jle`> if you ever want a function that uses the state read-only
20:43:07 <jle`> try writing a function readOnly :: Reader s a -> State s a
20:43:22 <jle`> and then you can write your functions in a "read-only" monad, and then "lift" them into the State
20:43:28 <jle`> this gives you guaruntees on mutability and stuff
20:43:39 <Zekka> Let's see, I was also planning on writing a programming language at some point because I'm pissed off about how my last one went
20:43:54 <jle`> ...but really, you're basically re-inventing OOP in a way :/
20:44:38 <Zekka> and part of my motivation for the next attempt has been taking trendy stuff like lens and seeing if I can define instances of it for the stdlib so people actually treat it as idiomatic/normal
20:44:57 <jle`> Zekka: :)  keep me updated
20:45:02 <jle`> do you have a blog or github or something?
20:45:09 <Zekka> jle`: I have a github but I don't update it very often
20:45:24 <jle`> ic
20:45:33 <Zekka> I can keep you posted but I don't plan to implement whatever I come up with terribly quick
20:45:40 <jle`> mhm, no worries
20:45:49 <Zekka> as it stands not too much is defined, partially because a lot of hte projects I'm really interested in I still don't grok the details of yet
20:46:25 <Zekka> Have you seen the coroutine-based extensible effects implementation? My gut is that their work with type-level sets would work really well with Vinyl-style extensible records since the fields of a record basically constitute a set of kv-pairs
20:46:57 <jle`> i've looked at it but i am not familiar enough with it to comment in this context in a meaningful way
20:47:06 <stolaruk> jle`: I have a bunch of top level bindings that various modules use... would you recommend I combine them into a record type that I then put in the Reader monad?
20:47:19 <Zekka> but that requires 1) coming up with extensible records that aren't hairy and are still general enough to express type-level sets and/or lists and 2) coming up with a take on their work that doesn't turn out stupid when you've done that
20:47:42 <jle`> stolaruk: if they are top level bindings, aren't they globally accessible already?
20:48:03 <stolaruk> jle`: Yeah so I guess the question is, would I gain anything by using Reader monad?
20:48:12 <Zekka> Extensible records actually look a little less like sets and a little more like stacks if you allow duplicate fields, which IMHO is a Good Idea
20:48:22 <dfeuer> If you want OOP, Smalltalk is down that hall, three doors down.
20:48:45 <jle`> oh there's actaully ##smalltalk, heh
20:48:46 <Zekka> which is nice because stacks are super easy to define on the type evel
20:48:58 <jle`> stolaruk: i can't comment much on this, but i have been lazy and just referred to them as global stuff in the past
20:49:10 <stolaruk> jle`: ok thx
20:49:21 <stolaruk> Luv this channel.
20:49:24 <jle`> Reader monad is actaully in most cases not so useful
20:49:31 <stolaruk> jle`: Right?!
20:49:38 <stolaruk> jle`: I haven't found a use for it yet.
20:49:46 <dfeuer> Allegedly ReaderT is useful for something.
20:49:58 <jle`> yeah, it's useful in context with things that work with monads
20:50:02 <jle`> like monad transformers
20:50:08 <Zekka> Of course there's the minor downside that using stacks without any optimizations is pretty slow
20:50:09 <stolaruk> dfeuer: Well if I used Reader it would be ReaderT since I'm already in a stack
20:50:34 <Zekka> and optimizations make it super hairy
20:50:40 <stolaruk> Zekka: What do you mean by optimization
20:50:40 <jle`> it has some use in data types that take a monad to internally compose effects
20:50:47 <Zekka> stolaruk: I'm talking about something different from what you are
20:50:59 <stolaruk> Zekka: oh ok
20:51:00 <Zekka> I'm talking abouut "representing extensible records as type-level stacks of kv pairs"
20:51:17 <stolaruk> Zekka: Right :)
20:51:32 <stolaruk> :t liftIO
20:51:33 <lambdabot> MonadIO m => IO a -> m a
20:51:34 <Zekka> Optimizations on that kind of representation are pretty hairy but I can't think of any offhand that would significantly change the semantics
20:53:00 <jle`> stolaruk: i'm going to be afk for a bit, but i'm just going to leave here that #haskell-game is a nice channel if you want to ask about specific game design stuff, or architecture/framework/approach stuff like this
20:53:21 <stolaruk> jle`: Oh great I'll check it out. Thanks for your help!
20:53:32 <jle`> np!
20:54:51 <stolaruk> What do ppl think of Multi-Way If? Like it? Use it?
20:55:02 <stolaruk> I've found some pleasing uses for it.
20:56:22 <rwbarton> I don't use it because I assume the emacs indentation mode would choke on the syntax
20:56:45 <rwbarton> but maybe it does work
20:56:53 <stolaruk> It might; I dunno, it seems fine in my vim setup.
21:06:17 <nezt> what text editor do you all use when you code haskell
21:06:27 <dfeuer> Someone must have been against obfuscation when they made `elem` infix rather than infixl. That makes me want to write  x `elem` True `elem` [False]
21:06:45 <dfeuer> nezt, I use vim badly. I also use Kwrite, also badly.
21:07:06 <Cale> I'm about the same. Mostly vim, though I don't really use many of its features.
21:07:17 <Cale> Occasionally gedit or gobby.
21:07:47 <Cale> It doesn't really matter so long as your editor can convert tabs to spaces (and maybe do a little syntax highlighting and maintain the indentation level for you)
21:07:49 <nezt> my brain cant remember all the vim hotkeys
21:08:09 <Cale> But converting tabs to spaces is the important thing, and most editors can do that
21:08:19 <haasn> I use vim, but also badly
21:08:28 <MP2E> I'm trying out yi, and I'm liking it quite a bit
21:08:39 <MP2E> but it's definitely a DIY editor, it doesn't come with everything out of the box
21:08:42 <ruun> your fingers have to remember the keys :D
21:08:44 <MP2E> be prepared to read lots of code/configs :P
21:09:08 <dfeuer> What is augment?
21:09:11 <listofoptions> MP2E: so emacs + windows?
21:09:25 <listofoptions> :P
21:09:32 <Zekka> MP2E: My summary of Yi having worked with it briefly and written my own configuration
21:09:34 <MP2E> listofoptions: Probably, I haven't tried Emacs on Windows but that sounds nightmare esque hehe
21:09:39 <Zekka> it's the editor for people who really, really like writing Haskell
21:10:09 <MP2E> Zekka : A good observation, I think I fit that category
21:10:12 <listofoptions> MP2E: it's not much worse than on linux, finding a precompiled version is the fun though
21:11:01 <dfeuer> Hmm... I want to try this Yi.
21:11:06 <MP2E> I'm going a bit haskell nuts lately, I'm using xmonad, yi, nixos
21:11:14 <dfeuer> Emacs will work on anything.
21:11:38 <dfeuer> I bet you can even get it on classic MS-DOS.
21:11:55 <listofoptions> dfeuer: yup
21:12:10 <nezt> Have there been any viruses /worms /malware written in haskell?
21:12:13 <nezt> i mean
21:12:18 <dfeuer> NixOS looks like fun too, but I think my next "learn Unix better" endeavor will probably be Arch.
21:12:19 <nezt> it doesn't make much sense, right? not everyone has ghci
21:12:22 <Zekka> nezt: Sounds like a good project!
21:12:26 <nezt> lol
21:12:39 <kazagistar> nezt: thats irrelevant, static linking solves that problem
21:12:46 <MP2E> dfeuer : That sounds like a good idea to me, Arch is the 'best way' to learn Linux, in my honest opinion
21:12:49 <Zekka> Haskell programs tend to build to fairly large executables, but there's no law against writing Haskell code generators
21:12:55 <haasn> Since when is ghci a runtime requirement for haskell code?
21:12:55 <MP2E> nice and vanilla packages with a sane and simple core/philosophy
21:13:04 <kazagistar> nezt: plus it would confuse the shit out of people used to decompiling C :P
21:13:33 <MP2E> hahah
21:13:35 <Zekka> I mean, there is a law against using those and then generating and distributing malware
21:13:40 <Zekka> but that's an entirely different kind of law
21:13:43 <dfeuer> MP2E, I have little doubt, without having tried it. Arch is a big box of pieces and a really damn good set of instructions.
21:14:03 <haasn> MP2E: You mean gentoo, right? ;)
21:14:18 <MP2E> I'm torn actually because I *really* like gentoo too
21:14:25 <MP2E> :P
21:14:38 <dfeuer> I'm really okay with using precompiled binaries.
21:14:42 <MP2E> I'm probably more apt to use gentoo but I also compulsively compile everything and I have a tendency to modify OS packages
21:14:49 <MP2E> which is not something most people do
21:14:51 <MP2E> sooo >_>
21:14:59 <haasn> I've been thinking about a possible Gentoo+Nix merger; I heard there's a Nix implementation in Haskell in the works too
21:15:11 <dfeuer> I'm just learning enough to start mucking about with some of the easier Haskell libraries.
21:15:12 <haasn> portage is in dire need of replacement
21:15:13 <MP2E> That sounds awesome
21:16:02 <kazagistar> I considered gentoo, and then realized I have no qualms with anything that compiler optimizations would fix for actual desktop usage
21:16:12 <nezt> haasn : idk , sorry i'm still a big noobie plus tired atm
21:17:42 <MP2E> It isn't about the compiler optimizations for me, because really at most you'll gain like 3%-5%
21:17:50 <MP2E> it's more about the increased flexability that a source distributions provides
21:17:55 <MP2E> want to use a different init system? Go for it
21:17:58 <MP2E> anything goes
21:18:09 <dfeuer> MP2E, you can do that with Arch too.
21:18:10 <ruun> a friend of mine loves gentoo for cross compiling
21:18:18 <dfeuer> You don't need to compile from source just for that.
21:18:35 <MP2E> dfeuer: I haven't tried, but stripping out systemd does not look fun
21:18:35 <kazagistar> I almost never even touch the configs let alone compiler options
21:18:53 <MP2E> ruun : it's great for that too, I'm a pretty heavy cross compiler myself
21:18:59 <MP2E> though thankfully nixos has me covered there
21:19:02 <dfeuer> MP2E, changing init systems in a distro isn't going to be fun whether your distro is built from source or not.
21:19:04 <haasn> nezt: ah; well, the de-facto standard Haskell compiler (GHC) can produces statically linked executables which pretty much only depend on gmp (and commonly found libraries)
21:19:04 <MP2E> nixos has a great cross compilations ystem
21:19:14 <haasn> nezt: So portability is not much of an issue
21:19:24 <MP2E> dfeuer : It's much more fun wehn you don't *have* an init system and you bootstrap your own
21:19:24 <Zekka> Minding that GHC executables are kind of big
21:19:31 <MP2E> vs ripping one out and putting a new one
21:19:54 <Zekka> so if you really want to send malware to all your friends you're going to have to explain why it's five megabytes in size
21:19:55 <dfeuer> MP2E, that does not sound like fun either.
21:20:03 <dfeuer> Why would I want to write my own init system?
21:20:22 <haasn> (Gentoo comes with an init system, and it's called OpenRC)
21:20:27 <MP2E> You don't write it, you make the choice as to which package you install to cover the init system 'slot'. You may be able to do this in Arch, but I didn't see an option
21:20:51 <MP2E> Seemed like everything was tuned for systemd and that's it
21:21:03 <haasn> systemd is actually what's keeping me from trying NixOS :(
21:21:10 <MP2E> understandable, I fucking hate systemd
21:21:16 <MP2E> I put my hate aside for a little bit but it's still driving me nuts
21:21:21 <dfeuer> MP2E, systemd is far more than an init system.
21:21:22 <MP2E> everytime I reboot it takes like 2 minutes because of some silly bug
21:21:34 <MP2E> makes me miss gentoo and it's openrc awesomeness :V
21:21:43 <dfeuer> But I think it's pretty cool.
21:21:45 <MP2E> I actually left Arch because of systemd
21:21:48 <MP2E> and went to gentoo
21:21:49 <MP2E> heh
21:21:56 <dfeuer> If you're having trouble with boot times, ask someone for help.
21:22:03 <MP2E> I did, other people in #nixos have the same issue
21:22:04 <dfeuer> I chose Fedora in part *because* it has systemd.
21:22:13 <MP2E> no one seems to know what's going on
21:22:23 <MP2E> it's not a kernel bug and I can't get a log of the issue because when I turn on logging the issue disappears
21:22:26 <MP2E> most mysterious .
21:22:38 <haasn> Keep logging on, problem solved
21:22:43 <dfeuer> Wow, a proper Heisenbug!
21:22:51 <dfeuer> Those are rare.
21:23:00 <kazagistar> dfeuer: I did the same, but fedora doesn't roll... I think I am getting over that though
21:23:35 <haasn> What I enjoy about Gentoo is that it liberates me from cabal-install. Do you know if any other distros do that effectively? I know NixOS definitely does
21:23:36 <dfeuer> The non-rolling thing is unfortunate from a Haskell perspective.
21:23:56 <MP2E> haasn : i've tried a few distros with cabal 2 whatever conversion tools, the only ones worth their salt were gentoo and NixOS
21:24:00 <MP2E> Arch's was a bit depressing
21:24:09 <MP2E> barely worked
21:24:17 <ruun> fedora isn't bleeding edge anymore?
21:24:18 <haasn> Hmm, that's the impression I was getting also
21:24:58 <dfeuer> ruun, the release cycle doesn't synchronize with the Haskell Platform's.
21:25:09 <kazagistar> so wait, is nixos systemd default or not?
21:25:47 <MP2E> kazagistar: nixos is systemd through and through, as far as I know
21:25:52 <MP2E> as I said, I put my systemd hate aside for nix :P
21:26:06 <MP2E> still not loving the systemd experience though, it is the one thing detracting from this
21:26:25 <haasn> From what I can tell, NixOS isn't morally anti-OpenRC, it's just that nobody has bothered porting any scripts
21:27:07 <kazagistar> hmm, I never really had issues with systemd, but the only init system I actually did have issues with was Upstart with ubuntu
21:27:51 <listofoptions> god upstart...
21:28:33 <listofoptions> went back to debian due to that
21:29:19 <kazagistar> getting a system that refuses to boot because my external hard drive containing no files of importance is missing was a shock
21:30:52 <listofoptions> ....was that your only problem kazagistar ? I got that (due to a flash drive plugged in during updating) and that my ati card didnt support VESA....
21:31:55 <MP2E> yikes, a flash drive plugged in during updating screwed things up?
21:32:10 <MP2E> must have overwritten /etc/fstab with a layout depending on the flash drive or something
21:32:14 <MP2E> which is absolutely horrible
21:33:24 <kazagistar> listofoptions: it worked under any other init system, upstart wanted EVERYTHING finished before it would actually load up, useful or not, meh
21:33:58 <MP2E> I miss Ubuntu before they went all NIH on everybody
21:34:01 <kazagistar> its not like I am a server admin, I dont actually use anything more then restart and "it should be pretty fast without me doing any work"
21:36:08 <AfC> Am I a bad person for thinking System.Log.Logger is horrendous?
21:36:50 <haasn> @where hayoo
21:36:51 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
21:36:58 <haasn> Hmm, any mirrors?
21:37:44 <solidus-river> darn, i thought haskell could handle circular imports
21:37:55 <haasn> Haskell can
21:38:01 <haasn> GHC can't
21:38:12 <haasn> (but you can work around it with .hs-boot files)
21:39:29 <solidus-river> http://lpaste.net/107863
21:39:33 <solidus-river> so how do i work around it?
21:39:38 <solidus-river> i guess i could also rearrange my files
21:39:58 <haasn> solidus-river: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
21:42:38 <solidus-river> haasn: hmmm, that complicates my code base much more than shoving them back in the Bounded class definition would :P
21:42:53 <solidus-river> thats probably the "right" thing to do anyway
21:44:50 <lfairy> AfC: probably not. I personally don't think the Java-style API transferred well
21:45:06 * hackagebot streaming-commons 0.1.4.1 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.4.1 (MichaelSnoyman)
21:46:04 <AfC> lfairy: surely there would be something better... simpler
21:46:26 <lfairy> AfC: fast-logger?
21:46:28 <AfC> lfairy: I read tekmo's posts about wrapping a Pipe around everything, which was cool
21:46:32 * AfC looks
21:46:56 <lamer14059110540> Are there any online haskell training programs with real instructors live?
21:47:11 <haasn> You mean like #haskell?
21:47:26 <MP2E> lol
21:47:27 <AfC> haasn: we're alive?
21:47:49 <MP2E> Alive? You mean turing complete right? ;P
21:47:55 <AfC> lamer14059110540: you're looking for video recordings, or a live 1:1 tutor?
21:47:57 <lamer14059110540> lol
21:48:23 <lamer14059110540> AfC live 1:1 tutors or a public session, but a more structured program
21:49:05 <jle`> i don't feel very turing complete
21:49:31 <listofoptions> my compiler always makes me feel dumb
21:49:34 <lamer14059110540> I understand #haskell is a good tool, but I just need to get something to get me past the initial learning curve. I did an entire 44 page intro to Haskell. I forgot all that I did pickup. So want something more than just a few morsels.
21:49:57 <haasn> I find that if you're forgetting what you read then you need to spend more time putting it into practice instead of just reading
21:49:58 <jle`> lamer14059110540: try LYAH, and then do a couple of small-scale single-file projects
21:50:03 <listofoptions> especially GHC
21:50:04 <jle`> like command line hangman or someting
21:50:07 <jle`> the post it here
21:50:10 <jle`> and we will review it for you :)
21:50:11 <jle`> for freeeee
21:50:14 <jle`> :)
21:50:18 <lamer14059110540> lol
21:50:35 <lamer14059110540> Ok sounds fair.
21:50:35 <jle`> if you want we can even recommend projects :)
21:50:53 <lamer14059110540> Ja Ja.
21:51:10 <lamer14059110540> What do I start with?
21:51:21 <jle`> lamer14059110540: first of all, what have you already done/read?
21:51:22 <lamer14059110540> I mean as a project.
21:51:25 <haasn> What about command line hangman?
21:52:23 <lamer14059110540> I read through a gentle introduction to haskell. But that was a while ago.
21:52:42 <jle`> i should probably compile a small list of beginner projects...
21:52:48 <jle`> been meaning to
21:53:08 <lamer14059110540> jle` I can be your test monkey. If that helps. LOL.
21:53:33 <jle`> try reading an introduction or a course, like lyah or bitemyapp's path
21:53:40 <jle`> https://github.com/bitemyapp/learnhaskell
21:53:44 <jle`> i think he recommends the NICTA course
21:54:17 <jle`> i always recommend command line hangman for someone fresh out of lyah or some other haskell introduction/someone with familiarity with syntax and some semantics
21:54:52 <kazagistar> with no syntax and semantics, you wont get far anyways
21:55:05 <jle`> yeah...so you should probably go through some course or introduction first
21:55:56 <solidus-river> has anyone written a haskell in laymans terms introduction yet?
21:56:26 <solidus-river> my friends always scoff when i talk about haskell then i explain it to them with minimal use of Monad and they get it immediately / dive in
21:56:59 <solidus-river> like the beginner haskeller doesnt need to know what a monad is i think as much as they need to be able to conceptualize making a program with some do blocks and some pure code
21:57:07 * lamer14059110540 sends a bunch of print commands to eternally silence some trees ...
21:57:15 <jle`> solidus-river: lyah ... ?
21:57:31 <kazagistar> solidus-river: I mean, I am not sure where people get the idea that you are supposed to use monads right away, I cant think of a beginner text that emphasizes them until a few chapters in?
21:57:40 <solidus-river> jle`: in my experience that freaks people out still
21:57:49 <solidus-river> kazagistar: aye but its hard to think of how to actually write a meaningfull program without monads
21:57:51 <jle`> i don't think anyone introduces monads right away
21:57:54 <jle`> hm.  really?
21:57:59 <solidus-river> well.. i think it is
21:58:07 <solidus-river> most programs want to print at least
21:58:10 <solidus-river> thats a monad right there
21:58:15 <jle`> you don't need anything monadic to print
21:58:52 <kazagistar> solidus-river: interact gets you to a very large number of potential useful programs with 0 monaic things
21:58:54 <lamer14059110540> bytemyapp recommends Brent Yorgey's course over "NITMA" and lyah
21:58:57 <jle`> i mean... IO is a Monad...but so is list
21:58:59 <haasn> I use Haskell more from within the GHCi repl than outside it
21:59:12 <haasn> And I think that is the way to go not only to explain Haskell, but also to explain any programming language cool enough to have REPLs
21:59:14 <jle`> are you saying that take 2 [1..10] is monadic?
21:59:24 <jle`> or [1,2,3] is monadic, even?
21:59:31 <jle`> "hello" is monadic?
22:00:34 <centrinia> It is in a monad.
22:01:15 <MP2E> Right but there's a difference between something being monadic, and happening to occur with a monad :)
22:01:21 <lamer14059110540> What does this mean? Yann Esposito's HF&H
22:01:23 <kazagistar> it is in something which is an instance of monad
22:01:29 <kazagistar> as well as a number of other things
22:01:43 <jle`> you don't need to tell some "okay, i'm going to teach you how to use the List Monad.  here: [1,2,3]."
22:01:56 <jle`> you don't need to know anything about monads to be able to do [1,2,3]
22:02:09 <jle`> "i'm going to tell you about lists...but...first, i need to tell oyu what a monad is :)"
22:02:45 <kazagistar> seriously, interact is amazingly simple to start with
22:03:14 <kazagistar> I wrote some serious learning mini-projects with interact :P
22:03:14 * lamehaskeller is confuesed with all the talk around "monads", sounds scary.
22:03:41 * lamehaskeller hides from the big bad Haskellers with monads ...
22:03:52 <MP2E> lamehaskeller : Monads are actually pretty easy, the problem is that they are blown up to be a bigger deal than they are
22:04:01 <listofoptions> lamehaskeller: data goes in, doesnt come out. you do stuff on it and dont need it to come out
22:04:18 <solidus-river> jle`: i guess your right, i just wish people weren't so scared of it
22:04:31 <jle`> solidus-river: i think people could just...not mention it
22:04:35 <kazagistar> dont try to explain it, is irrelevant, you just show the uses of it, and explain it as needed
22:04:39 <solidus-river> jle`: well i feel like a lot of haskellers do that though
22:04:53 <jle`> why would you need to explain anything about monads to explain how to create a new list?
22:04:59 <solidus-river> most of my friends that i've helped understand have had other pepole try to teach them and they start by hitting them in the face with monads
22:05:08 <jle`> why do you need to explain anything about monads to explain how to print something to the screen?
22:05:13 <kazagistar> like ... but how do I get the information out of print IO? there is a function that does that called >>=, dont mind the type signature
22:05:15 <solidus-river> and thats 'scary' stuff / doesn't relly give a good first step
22:05:15 <lamehaskeller> Ok, I get it. All you can eat buffet, only nothing comes out at the end.
22:05:29 <kazagistar> er, out of a getstrln or whatever
22:05:30 <jle`> lamehaskeller: heh. the point we are trying to make is that knowing about monads is pretty irrelevant for a good portion of your journey
22:05:36 <lamehaskeller> Much like a beginning Haskeller.
22:05:53 <MP2E> I agree with jle`
22:05:54 <lamehaskeller> I read everything and nothing comes out on the screen.
22:06:03 <lamehaskeller> Just scary syntax :)
22:06:07 <MP2E> in fact, given enough raw experience with Haskell, you may find that you have invented a few monads without recognizing the pattern
22:06:16 <MP2E> which is probably the best way to learn them!
22:06:19 <listofoptions> ^
22:06:42 <joelteon> like Identity!
22:06:46 <lamehaskeller> I read somewhere, that you could have invented monads among the tutorials. Maybe I will leave that for later.
22:06:58 <MP2E> That is a pretty good article
22:07:00 <listofoptions> i just figured that they where functions over a c++ style container type
22:07:05 <jle`> lamehaskeller: yeah, just go through a course :)  most of them are carefuly arranged so that they introduce things in the right order :)
22:07:30 <listofoptions> but a lot more complicated
22:07:42 <listofoptions> (read more awesome)
22:09:55 <lamehaskeller> Cool. Let's see how far I can get this time. I am following this one: http://www.seas.upenn.edu/%7Ecis194/lectures/01-intro.html
22:12:10 <kazagistar> why would you invent Identity without inventing the monad abstraction first?
22:25:11 * hackagebot wai 3.0.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.1 (MichaelSnoyman)
22:36:33 <solidus-river> can an infix function take more than 2 arguments?
22:39:00 <dwcook> solidus-river, remember: every function takes exactly one argument.
22:39:11 <dwcook> That said, you can certainly do this: (g . f) x
22:39:24 <jle`> > let (x <++> y) z = z * x + y in (4 <++> 7) 10
22:39:25 <lambdabot>  47
22:40:09 <dwcook> (There is nothing special about (.), anything could be used that way.)
22:40:39 <solidus-river> is that considered bad?
22:40:57 <solidus-river> i kinda want it because it makes it clearer that this function is testing based on the first argument
22:40:57 <dwcook> Not at all, things of the form of my example are seen all the time for one thing
22:42:16 <solidus-river> hmme
22:42:34 <carter> let (....) a b c d = a . b. c .d  in   (+2) .... (+3) (+2) (-7)   1/2
22:42:37 <dwcook> solidus-river, the thing I was trying to stress with my first comment, by the way, is this fact: A function applied infix to two things can return any sort of value, even a function.
22:42:39 <carter> > let (....) a b c d = a . b. c .d  in   (+2) .... (+3) (+2) (-7)   1/2
22:42:40 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> b -> c) -> a0 -> b -> c))
22:42:40 <lambdabot>    arising from the ambiguity check for ‘e_1232712’
22:42:40 <lambdabot>  from the context (GHC.Num.Num ((a1 -> b -> c) -> a1 -> b -> c),
22:42:40 <lambdabot>                    GHC.Num.Num (a1 -> b -> c),
22:42:40 <lambdabot>                    GHC.Num.Num a1,
22:42:47 <solidus-river> let (<++>) x y z = z * x + y in (4 <++> 7) 10
22:42:48 <carter> boo
22:43:36 <solidus-river> carter: you killed him!
22:43:47 <dwcook> solidus-river, > in front
22:43:56 <solidus-river> > let (<++>) x y z = z * x + y in (4 <++> 7) 10
22:43:58 <lambdabot>  47
22:44:01 <enthropy> which sorts besides mergesort and quicksort are worth trying at type level?
22:44:04 <solidus-river> carter: he's alive!
22:44:08 <solidus-river> :P
22:44:48 <enthropy> for whatever reason, mergesort does much better (on already-sorted input)
22:46:05 <dwcook> enthropy, how do you do a type-level sort?
22:46:10 <rwbarton> well are you using the first element of the list as the pivot?
22:46:18 <rwbarton> in quicksrot
22:46:19 <enthropy> yes
22:46:40 <rwbarton> so that's O(n^2) on sorted input
22:47:34 <enthropy> dwcook: http://lpaste.net/107864
22:48:15 <dwcook> Neat.
22:48:17 <enthropy> rwbarton: oh true. I guess I'll pick another one
22:48:22 <gamegoblin> Does OverloadedStrings work in pattern matching? Can I have f :: ByteString -> (); f “lol” = ()
22:49:29 <kazagistar> gamegoblin: that seems easy to try
22:49:33 <jle`> gamegoblin: i know one way to find out :)
22:49:36 <dwcook> gamegoblin, I believe so.
22:49:43 <gamegoblin> Was wondering if any of you knew off the top of your head
22:49:43 <dwcook> Also what they said :)
22:49:57 <enthropy> or I guess I can add a case to check of already-sorted ones
22:50:01 <dwcook> I'm about 80% sure off the top of my head.
22:50:03 <gamegoblin> Gotta break out the terminal now… so much work…
22:51:00 <rwbarton> enthropy: clearly you should promote GHC's sort algorithm with the singletons library
22:51:14 <enthropy> singletons doesn't support that stuff
22:51:23 <enthropy> this is easier than fixing up singletons
22:52:12 <haasn> I believe merge sort is absolutely the way to go on the type level
22:52:27 <haasn> Especially if you can use pre-sorted inputs
22:52:32 <jle`> type level sort, as in sort a list of types?
22:52:47 <enthropy> jle`: exactly
22:52:56 <enthropy> and sort an actual list that has such a type
22:53:06 <jle`> enthropy: what is the criteria of comparison?
22:53:13 <jle`> is it an arbitrary type family?
22:53:36 <enthropy> GHC.TypeLits.CmpSymbol and CmpNat
22:54:47 <enthropy> haasn: why do you say that?
22:54:57 <jle`> ah so you're sorting specific types in a family
22:55:00 <jle`> not like Int and Bool
22:55:34 <haasn> enthropy: It has a very low implementation complexity, especially on the type level where sub-functions, pattern matches and data types are all PITAs
22:56:24 <enthropy> jle`: well if you write "instance HEqBy HLtFn Int Bool True; instance HEqBy HLtFn Bool Int False", you can sort those ones
22:56:30 <gamegoblin> > chr 65
22:56:31 <lambdabot>  'A'
22:56:53 <jle`> enthropy: oh yeah, they are open
23:05:54 <cgag>  does anyone know of a tool that will turn this: https://www.haskell.org/onlinereport/haskell2010/haskellli1.html#x2-1000 into huge single page of text?
23:06:26 <cgag> or know what these pages are made with, i know i've seen other docs that look ver ysimilar
23:08:46 <dwcook> cgag, check the page source, it says: <meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" />
23:09:33 <cgag> brilliant, thanks
23:09:42 <dncr> I feel like I still don't really understand why reading millions of say little-endian Int32s from a file to an array, even using unboxed vectors and unsafeWrite, is so much slower in Haskell than C.
23:09:50 <tgeeky> and what do you mean by hard?
23:09:54 <tgeeky> oops; wrong window.
23:10:01 <tgeeky> (hard sudoku)
23:10:10 <jle`> thank you for the clarification tgeeky
23:10:18 <dwcook> ##sudoku ?
23:10:18 <tgeeky> yeah; i left myself hanging there.
23:10:27 <tgeeky> dwcook: ##kspmodders on EsperNet
23:10:30 <jle`> dncr: do you have an example/sample of what you are comparing?
23:11:35 <dncr> jle`: I just took the method from vector-binary-instances
23:11:50 <dncr> dons wrote it so I know it's fast haskell
23:12:00 <ar-curunir> Hi guys, I'm pretty new to haskell, and I was wondering whether it is possible to instantiate two typeclasses at the same time. Like for example "instance (Group, Monoid) ModN where ..."
23:12:28 <haasn> ar-curunir: Nope
23:12:31 <jle`> ar-curunir: hm.  well.  i'm not sure what benefit you expect to get from it :)
23:12:43 <jle`> i guess it's a bit more succint
23:12:46 <haasn> jle`: Saves 1-2 lines :)
23:12:46 <ar-curunir> Just uctting out some extra typing I guess =)
23:12:47 <jle`> but yeah, not in haskell
23:13:02 <jle`> yeah, i see :)  didn't notice you used Group and Monoid
23:13:09 <jle`> where one is presumably the superclass of the other
23:13:19 <jle`> that'd be handy anctaully :)
23:13:26 <ar-curunir> Hmm I didn't structure it that way, but yeah I guess that would work
23:13:30 <ar-curunir> thanks =)
23:13:51 <ar-curunir> I was just playing around creating Rings and Groups and Fields, etc.
23:13:54 <dncr> jle`: maybe there's something faster with unsafeCoerce
23:14:32 <haasn> If one's a super-class of the other that has been defined with default method implementations for the subclass then you could just write “instance Monoid ModN; instance Group ModN where ...”
23:14:43 <haasn> And save some effort that way
23:15:03 <dncr> jle`: but I'm wondering more if anyone can say what the extra work going on is when you slurp up e.g. little endian Ints into a vector in haskell. vs c.
23:15:33 <streitdoni_> hey. Good morning. Does anybody know what lifting in haskell means. I've read this in contex with Geo Information Systems. I also found an Haskell article but it is too theoretical for me. http://www.haskell.org/haskellwiki/Lifting  . Does anybody know this?
23:16:12 <levi> Sure; let me look at your reference.
23:16:19 <streitdoni_> thanks
23:17:06 <levi> OK. Well, first of all, how much of a haskell background do you have?
23:17:13 <ar-curunir> haasn: Yeah, I ended up doing that qhwn defining Ring. my Ring is a typeclass that 'inherits' (right term?) from Group and Monoid. I just needed to instantiate my ModN type as Group and Monoid, and since I'd defined Ring in terms of those two, I had less typing to do =)
23:17:44 <streitdoni_> not as much to understand this;-D.
23:18:17 <streitdoni_> Lifting is a concept which allows you to transform a function into a corresponding function
23:18:27 <streitdoni_> f::(a->a) ->a
23:18:45 <levi> Have you heard of functors before?
23:19:20 <streitdoni_> no. I allready read the wiki article about it. but i havn't worked with it before
23:19:23 <dncr> streitdoni_: I would say just look at the Pair example code there.
23:20:18 * hackagebot uxadt 0.0.16.0 - Cross-language extensible representation for algebraic data type instances.  http://hackage.haskell.org/package/uxadt-0.0.16.0 (AndreiLapets)
23:20:35 <jle`> streitdoni_: do you have any programming experience?
23:20:47 <streitdoni_> yes
23:21:28 <streitdoni_> about 3 years but haskell only about a few weeks
23:21:31 <levi> OK. Well, a functor is a math construct, very general. The basic idea is that it transforms types and functions some other domain of types and functions.  In Haskell, we really only have one domain of types and functions, but we can represent other ones with parameterized data types. The type represents the "extra stuff" that the functor supplies.
23:22:23 <jle`> streitdoni_: have you ever used a 'map' function?  it shows up a lot in ruby, python, some circles of javascript
23:22:37 <levi> A List is an example of a functor.  And 'lifting' a function to a List makes that function apply evenly to all the members of the list.  We call the function that 'lifts' a function to List by the name 'map'.
23:22:52 <dncr> streitdoni_: Whereas in general the things you do on pairs are more general, like you could add 1 to the first part and multiply the second part by 2, you can see how \(Pair x y) -> Pair (x + 3) (y + 3) corresponds in some way to the function \z -> z + 3. It is that function "lifted" into our Pair type.
23:23:12 <streitdoni_> @levi thats like the map function isn'T it
23:23:12 <lambdabot> Maybe you meant: let leet leave
23:23:23 <levi> streitdoni_: That's exactly the map function!
23:23:37 <jle`> streitdoni_: ah, so you've used map :)
23:23:40 <streitdoni_> aahh you wrote this
23:23:48 <jle`> let's say you have a function (Int -> Bool)
23:23:52 <jle`> but you have an [Int]
23:23:55 <MP2E> > fmap (+5) [1,2,3,4,5]
23:23:57 <lambdabot>  [6,7,8,9,10]
23:23:57 <levi> There's a more general function that belongs to the Functor type class called 'fmap' that applies to all types with instances of Functor defined. How familiar are you with type classes?
23:24:04 <jle`> ...your function is sorta useless...right?
23:24:16 <jle`> I have an Int -> Bool, but I have an [Int]...how can I apply my Int -> Bool to that?
23:24:22 <jle`> the answer: lift your function :)
23:24:31 <jle`> turn your Int -> Bool into an [Int] -> [Bool]
23:24:48 <jle`> and now, you are good to go!   You have an [Int] -> [Bool]....and you have an [Int]
23:24:52 <MP2E> > fmap even [1..10]
23:24:53 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
23:24:55 <haasn> (What about m a -> t m a?)
23:24:57 <jle`> so your function can be safely applied to your list
23:25:18 <jle`> s/safely/meaningfully
23:25:30 <jle`> :t even
23:25:31 <lambdabot> Integral a => a -> Bool
23:25:40 <jle`> :t map even
23:25:41 <lambdabot> Integral a => [a] -> [Bool]
23:25:53 <jle`> see?  the fmap function turns an a -> Bool into an [a] -> [Bool]
23:25:56 <jle`> er, the map
23:26:20 <saep> :t fmap even
23:26:21 <lambdabot> (Functor f, Integral a) => f a -> f Bool
23:26:22 <MP2E> fmap = map with lists, so with my examples you can replace fmap with map
23:26:23 <jle`> the concept of lifting is actually a lot more general than this...but if you're new to haskell, this might put you on the track for a sort of intuition by which to understand the more generalized caes
23:26:24 <levi> For the List type, the definition of 'fmap' is just 'map'. But quite a lot of Haskell types also have instances of Functor defined for them, and they have somewhat different (but always fairly straightforward) implementations of fmap.
23:26:54 <glguy> s
23:28:42 <streitdoni_> i know type classes too
23:28:51 <MP2E> streitdoni_ : But yeah fmap is what lifting *is*
23:29:43 <MP2E> :t fmap
23:29:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:30:06 <jle`> one way of looking at the Functor typeclass is that it encapsulates "things that can you can lift functions into"
23:30:20 <jle`> for example, you might like to turn an (a -> b) into an ([a] -> [b])
23:30:25 <jle`> so...[] is a Functor
23:30:35 <jle`> you also might like to turn an (a -> b) into a (Maybe a -> Maybe b)
23:30:41 <jle`> so... Maybe is a Functor, if you've heard of it
23:30:50 <jle`> you also might like to turn an (a -> b) into an IO a -> IO b
23:30:54 <jle`> ^^ very very useful in Haskell
23:31:00 <jle`> well...IO is a functor :)
23:31:34 <streitdoni_> i understood the map function now
23:31:53 <jle`> so this process --- turning an (a -> b) into IO a -> IO b, can be said to "lift your function into IO"
23:32:09 <jle`> really...all of these lifting functions can be written on their own
23:32:15 <streitdoni_> and i also know what type classes are. but with fmap i have my problems
23:32:23 <jle`> that is, you can write a liftIO, a liftMaybe, a liftList
23:32:38 <jle`> Functor is just a typeclass that gives us a common vocabulary/tool for talking about lifting "in general"
23:32:51 <streitdoni_> ah ok
23:32:57 <jle`> that is, instead of writing liftIO for (a -> b) -> (IO a -> IO b)
23:33:04 <jle`> and liftMaybe for (a -> b) -> (Maybe a -> Maybe b)
23:33:12 <jle`> and liftList/map for (a -> b) -> ([a] -> [b])
23:33:19 <jle`> we recognize that there is some generalized design pattern going on here
23:33:27 <streitdoni_> yes
23:33:33 <jle`> and so we can use `fmap` to "generically" do this
23:33:38 <streitdoni_> ahhh ok
23:33:41 <jle`> so we can write fmap to sort of do it for all of them
23:33:49 <jle`> note that this is sort of almost like sugar/neat interfaces in a way
23:33:55 <jle`> when this is all compiled down...liftIO is compiled
23:34:01 <jle`> liftMaybe is compiled; liftList/map is compiled
23:34:24 <MP2E> yeah fmap doesn't really 'exist' it's just really convenient :)
23:34:24 <streitdoni_> i'm writing an exam. The last one for my master. And it is about Haskell in Geoinformatiks. I'm sure i have to do something wit fmap^^
23:34:25 <jle`> if you write fmap (*2) [1,2,3], it's actually compiled as map (*2) [1,2,3]...but fmap just lets us use the same function/word for all of these examples, when we write our code
23:34:41 <haasn> fmap exists
23:34:47 <haasn> I don't understand what this is about
23:35:02 <haasn> fmap is just a function, and “lift” is not precisely defined in Haskell
23:35:12 <haasn> The only so-named “lift” I know is that of MonadTrans
23:35:21 <MP2E> haasn : the point is that there isn't one magic instance of fmap being instantiated to each case, fmap is defined seperately for each type that it is needed in. In other words 'there's no magic'
23:35:35 <haasn> Aka type classes
23:35:47 <MP2E> Right
23:35:55 <jle`> i think...there are multiple levels of things that have to be explained here, because he comes from a somewhat patchwork haskell background
23:35:56 <streitdoni_> so you answered my question.
23:36:07 <streitdoni_> so thanks for that
23:36:08 <jle`> that's the point of the fmap function *in haskell*
23:36:17 <jle`> the idea of a "lift" is a vague-ish word
23:36:20 <jle`> like haasn said
23:36:28 <arj> In the REPL I get a map lookup error. Any chance to get a stack trace like thingy?
23:36:35 <arj> if yes, how?
23:36:47 <jle`> but understanding this case i think helps start building an intuition for what the idea of "lift" sort of encapsulates
23:36:56 <rwbarton> @where xc
23:36:57 <lambdabot> I know nothing about xc.
23:37:04 <jle`> "lifting"
23:37:14 <ctangent> so, are liftM and fmap the same in many cases?
23:37:27 <haasn> ctangent: liftM and fmap are the same for all legal instances of Functor/Monad
23:37:35 <ctangent> cool.
23:38:10 <rwbarton> @where rts-xc
23:38:10 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
23:38:31 <dfeuer> Any idea what this $wscanl function is I see in this Core?
23:38:33 <haasn> Is the -prof and -fprof-auto and -osuf even needed here?
23:38:41 <haasn> I thought just ghc -rtsopts foo.hs && ./foo +RTS -xc works
23:38:50 <dfeuer> It's obviously related to scanl, but it doesn't seem to be the same.
23:38:56 <haasn> dfeuer: Can you paste the context?
23:39:01 <MP2E> arj : What's the lookup error?
23:39:03 <arj> rwbarton: is it possible in repl or do I have to compile it?
23:39:13 <arj> MP2E: *** Exception: Map.!: given key is not an element in the map
23:39:25 <MP2E> Ah
23:39:42 <levi> dfeuer: I think it's related to worker/wrapper transformation that GHC applies when it can.
23:39:49 <arj> the actual key would help, though it is clear to me that map can't print it because of no show requirements
23:39:50 <enthropy> if you're in ghci (and the code is all interpreted) you can :set -fbreak-on-exception
23:40:05 <MP2E> arj : a stack trace could definitely help you, but have you looked at the function trace?
23:40:17 <arj> MP2E: how would I do that?
23:40:30 <levi> dfeuer: I'm not sure though without seeing it.
23:40:37 <dfeuer> Context: http://lpaste.net/107870
23:40:45 <arj> enthropy: only adds some more text but nothing helpful.
23:40:54 <dfeuer> Let me know if you want more context, but that should probably be enough.
23:41:07 <MP2E> arj: trace lets you print messages and variables to the console in a pure function without it becoming IO. This is obviously 'bad' but very useful for debugging purposes
23:41:22 <jle`> fsvo 'bad' :)
23:41:22 <MP2E> so you could print all accesses of map for instance
23:41:42 <rwbarton> arj: I think you can't run profiled code in ghci at all, so you have to compile
23:41:46 <arj> MP2E: yes, I am aware of that. I hoped to circumvent that.
23:41:53 <MP2E> ah okay, just making sure :P
23:41:57 <arj> rwbarton: I see, thanks
23:43:48 <dfeuer> levi, did you see the link?
23:47:22 <levi> dfeuer: I'm guessing that wscanl is a specialized wrapper function.
23:47:43 <haasn> dfeuer: Apparently $w does indeed stand for “worker”
23:48:13 <dfeuer> Huh.
23:48:36 <dfeuer> I guess I need to read more about the transformation. I read a little at some point, but I've forgotten whatever I understood of it.
23:50:13 <ctangent> is it just me or is cabal a little painful?
23:50:15 <levi> There are some papers on it.
23:50:26 <levi> ctangent: Not just you; what pain are you experiencing?
23:50:49 <MP2E> ctangent : it's a little more than a tickle, but a little less than paying your taxes
23:50:58 <ctangent> I'm installing some packages here and there as I learn
23:51:01 <mayski> :D
23:51:06 <ctangent> I just tried to install yesod from cabal and cabal is not amused
23:51:16 <ctangent> it's warning me that a bunch of stuff will be broken by reinstalls
23:51:21 <jle`> ctangent: what version of cabal / ghc do you have?
23:51:46 <ctangent> ghc is 7.6.3, cabal is 1.21.0.0
23:54:12 <d3m1g0d-> hi guys.
23:56:39 <Aleksejs> Hi, I'm studying haskell by developing my IRC bot. I use this http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source as base. I've already modified a lot (for example, I use new Exceptions). But now I stuck with the s/ command. For example, if someone writes "haskell is good" and then "s/good/great" the bot should find a previous message by this user, replace good with great and show "<nickname>
23:56:40 <Aleksejs> haskell is great". There is no problem to write a replace function, but I have a problem with message stack: I have no idea how to implement it the right way. Can someone help me with this?
23:57:15 <tac_> Aleksejs: also consider using the simpleirc package
23:57:59 <tac_> also, http://lpaste.net and paste your code
23:58:13 <jle`> Aleksejs: you could get a RWS stack insead of a ReaderT, and have the message stack in the State part
23:58:59 <jle`> type Net = RWST Bot () MessageStack IO
23:59:41 <jle`> RWST takes a 'reader' part (unchanging, Bot), a 'writer' part (we're not using it, so ()), and a State part (that functions can modify, MessageStack)
23:59:58 <jle`> this is assuming you more or less have the exact architecture as the haskellwiki article
