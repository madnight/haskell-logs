00:08:30 * hackagebot yesod-angular 0.1.0.0 - Yesod AngularJS integration.  http://hackage.haskell.org/package/yesod-angular-0.1.0.0 (ChristopherReichert)
00:08:30 * hackagebot http2 0.4.0 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.4.0 (KazuYamamoto)
00:33:49 <jle`> aw, haddock cannot yet parse "foo :: Num a => Monad m => m a"
00:35:33 <frerich> Hm, is anybody aware of a function which replaces (or "translates") all elements of a list matching a predicate with some other value? I.e. something like
00:35:33 <frerich> translateBy :: (a -> Bool) -> a -> [a] -> [a]
00:35:33 <frerich> translateBy p ch = foldr (\x acc -> if p x then ch:acc else x:acc) []
00:35:33 <frerich> ...except that I don't have to roll it myself? I could've sworn I saw "replaceBy" or something like that in Data.List, but I cannot find it anymore...
00:36:42 <johnw> \p y -> map (\x -> if p x then y else x)?
00:37:32 <frerich> johnw: Oh yeah, good point - by now my function is just a 'map'. Still, I wish I could remember where I saw this already :)
00:37:44 <johnw> doesn't ring a bell
00:38:20 <frerich> Data.List.Utils maybe hmmm
01:08:29 * hackagebot peyotls 0.0.0.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.0 (YoshikuniJujo)
01:18:30 * hackagebot eros 0.4.1.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.4.1.0 (pharpend)
01:23:30 * hackagebot alsa-pcm 0.6.0.3 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.6.0.3 (HenningThielemann)
01:28:31 * hackagebot alsa-seq 0.6.0.5 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.6.0.5 (HenningThielemann)
02:06:47 <grohne_> can someone tell me what is wrong with this snippet? http://lpaste.net/106698 (ghc 7.6 -XDeriveDataTypeable)
02:17:14 <jkarni> grohne_: I don't think GHC supports deriving typeable for kinds * -> * yet
02:17:36 <jkarni> grohne: I think you'll have to write the instance yourself
02:19:55 <grohne> jkarni: so http://hackage.haskell.org/package/pointless-haskell-0.0.9/src/src/Generics/Pointless/Functors.hs really lacks a version constraint on ghc >= 7.8?
02:24:13 <danilo2> Hello! :) Could somebody tell me why such closed type family does not work? While compiling the file (especially the instance in line 20) GHC chooses ALWAYS the definition from line 14, but shoudl choose the one from line 15. http://lpaste.net/106699
02:25:09 <jkarni> grohne: Since GHC 7.8.1, Typeable is kind-polymorphic (see Section 7.8, “Kind polymorphism”) and can be derived for any datatype and type class. Instances for datatypes can be derived by attaching a deriving Typeable clause to the datatype declaration, or by using standalone deriving (see Section 7.5.2, “Stand-alone deriving declarations”). Instances for type classes can only be derived using standalone deriving. For data families, Typeable should o
02:25:24 <jkarni> grohne: I guess so
02:25:43 <jkarni> this is from https://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
02:26:10 <grohne> yeah, I read that, but I am still stuck on 7.6
02:26:58 <jkarni> grohne: and presumably you can't build pointless-haskell 0.0.9?
02:27:15 <grohne> jkarni: of course. that was where I started. ;-)
02:28:00 <grohne> jkarni: 0.0.8 contains explicit instance declarations and builds
02:28:25 <jkarni> grohne: submit a patch!
02:29:05 <grohne> never did that before. where can I find the bug tracker for hackage?
02:30:33 <jkarni> grohne: hackage doesn't have it's own bug tracker - usually there's a link to github or wherever the project is hosted, but when that's missing, you can email the patch to the maintainer
02:30:43 <grohne> that link is 503
02:31:34 <grohne> to me it seems like hackage is a dumping ground for broken packages... I managed to cabal install world without problems.
02:31:49 <grohne> errm I *never* managed to cabal install without problems
02:33:32 <jkarni> grohne: to be fair, that's probably because the community isn't as big as with some other languages
02:33:41 <jkarni> grohne: submitting a patch is a small way to help!
02:34:06 <jkarni> grohne: but I also am sometimes frustrated
02:34:18 <jkarni> grohne: the link is broken, but presumably the emails aren't
02:34:24 <grohne> can you explain how that patch would help? assuming there would be a new version of pointless-haskell declaring incompatibility with ghc 7.6, then cabal would back down to the next supported version 0.0.9
02:34:31 <grohne> so how would I fix that?
02:35:20 <jkarni> grohne: I think the best thing would be to submit a patch going back to the manual instance declaration, so 0.0.9 is *also* compatible with 7.6
02:35:42 <grohne> can hackage releases retroactively be changed?
02:36:14 <grohne> isn't that running counter the concept of a "version"?
02:36:31 <jkarni> grohne: yeah, sorry, I mean 0.0.9.1 or whatever
02:37:57 <grohne> so yeah ok, adding back that compatibility seems like a good idea, but why can't this happen in the open? why hide patches away in private mail?
02:38:15 <grohne> how do I know how many others have submitted the same patch?
02:41:24 <jkarni> grohne: The package just happens not to have a bug tracker - that probably makes maintaining it a little more annoying, true
02:42:03 <jkarni> grohne: you can email the maintainers and ask - I've usually found people to be quite nice and responsive
02:42:20 <grohne> ok
02:42:32 <jkarni> grohne: if you don't want to do the work only to find out there's a reason to not support 7.6, or someone has already submitted the patch
02:44:35 * grohne tries
02:45:42 <sie> I'm stuck with this. http://stackoverflow.com/questions/24500978/why-doesnt-hxts-xpath-searcher-doesnt-return-a-simple-query
02:50:36 <grohne> jkarni: sent a mail describing the problem and drafting the two solutions (version constraint, explicit instance declarations).
02:50:46 <jrk> hi y'all
02:50:56 <grohne> jkarni: thanks for your help
02:51:20 <jrk> i've got a quick question concerning the "new" data.typeable as of 4.7: http://lpaste.net/106701
02:52:07 <jrk> i've got a working instance for Typeable1 with Data.OldTypeable, but I don't know how to get it to work with the new Data.Typeable
03:35:34 <steveo_> how well do gtk2hs programs handle high ppi monitors?
03:47:31 <yitz> steveo_: same as the gtk2  c libs, whatever that is. gtk2hs is just a binding to that.
03:49:14 <bollu> how many sub-communities exist within Haskell? I've encountered FRP and Lenses, what else exists?
03:50:04 <steveo_> yitz and how well do they work? :). gtk channel only has 12 users and i cant connect to gnome server
03:53:22 <Javran> is there a parser in parsec that consumes nothing and always fails?
03:54:11 <Javran> oneOf [] does the trick but I think there should be a straightforward one.
03:55:39 <frerich> Javran: There's "parserZero"
03:56:12 <frerich> Javran: Never used that one myself but the documentation says "parserZero always fails without consuming any input." -- which seems to match your question. :-)
03:56:57 <quchen> Javran: Even easier: Alternative's empty
03:57:21 <quchen> (Which is defined via parserZero, but you don't need Prim modules for it)
03:57:51 <Javran> quchen, frerich: got it, thanks!
04:00:56 <jle`> there's also mzero
04:01:14 <jle`> Javran
04:02:40 <Javran> jle`: yep, I just saw the document
04:04:35 <Peaker> The OpenGL package has wrong, overly permissive upper bounds in 2.8.0.0  :(
04:05:12 <Peaker> And the newer OpenGL broke the API in non-obvious ways
04:33:45 * hackagebot rest-core 0.31.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.31.1 (ErikHesselink)
04:33:47 * hackagebot rest-gen 0.14.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14.1 (ErikHesselink)
04:46:42 <danilo2> Hello! Would somebody be so nice and tell me why this 4-line code does not compile? Why GHC typechecker complains here? http://lpaste.net/106708
04:49:30 <jkarni> danilo2: Because 'a' appear in the context, but not in the instance head (right-hand side of =>)
04:49:52 <jkarni> danilo2: so ghc can't really figure out what to instantiate it to (it's "ambiguous")
04:50:41 <danilo2> jkarni: Hmm, yes it should appear so ... Look - are we even able to somehow write type for the function testme2 ? If we ammot the type, ghc cannot infer it either, but this is a valid function
04:51:13 <danilo2> jkarni: *If we omit (...)
04:52:07 <hexagoxel> danilo2: i think a functional dependency will help. but it depends on the semantics of the class if that is sensible.
04:52:28 <danilo2> hexagoxel: I cannot use functional dependencies here :(
04:53:10 <hexagoxel> why not? what about type families?
04:53:15 <danilo2> hexagoxel: but still I'm very suprised GHC complains about it - this is a very simple case - We want to use twice a function from a class
04:53:44 <danilo2> hexagoxel: I cannot use neither fundeps nor type families, I'll post an example in a moment
04:55:16 <hexagoxel> yeah but "from a class" is exactly the problem. the actual "catch" to use depends on the instance for a b and c, so these types must not be ambiguous.
04:56:36 <danilo2> hexagoxel: Look at the annotation - the code works perfectly fine, but if we change it to use fundeps, we get fundep conflict
04:57:09 <danilo2> hexagoxel: this is caused by a simple thing, fundeps "think", that "(UnsafeBase base e a)" is the same as "(UnsafeBase (UnsafeBase base e a) e2 a)"
04:57:34 <int3__> I've been scanning GHC docs on stream fusion and its limitations, and I'm not too clear if it will optimize the following code: concatMap f (map (\x -> concatMap g x) xs)
04:58:21 <int3__> ideally, I'd hope that the creation of intermediate lists by the inner call to concatMap is somehow fused away
04:58:49 <danilo2> hexagoxel: closed type families does not work here as well because of the same reason
04:59:18 <int3__> earlier today I was told that a foldr over my tree (using (:) instead of concat) would definitely be efficient, but concatMap makes for a more elegant expression IMHO
05:01:38 <jmcarthur> int3__: stream fusion does very poorly with concatMap. however, just to make sure you aren't mixing them up, ghc doesn't use stream fusion for lists out of the box. it uses a different kind of fusion
05:02:11 <jmcarthur> int3__: maybe not the best link, but the first i could find that seems to explain anything http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
05:02:38 <jmcarthur> int3__: off the top of my head, i don't know for sure what short cut fusion is going to do with that expression, but we can find out!
05:02:54 <hexagoxel> danilo2: hmm that code makes ghc 7.6.3 crash :D
05:03:40 <int3__> jmcarthur: oh hey it's you again :D yeah I found that link too, but I still don't understand what it means for my example code... how do you find out?
05:03:48 * hackagebot TrendGraph 0.1.0.1 - A simple trend Graph script  http://hackage.haskell.org/package/TrendGraph-0.1.0.1 (AlperAYDIN)
05:05:59 <danilo2> hexagoxel: heh. It works in 7.8.2
05:06:04 <danilo2> hexagoxel: :)
05:06:14 <jmcarthur> int3__: you can look at the core generated by ghc
05:06:32 <jmcarthur> int3__: -ddump-simpl or, if you install it, you could use ghc-core for something a bit prettier
05:06:52 <jmcarthur> int3__: there are also flags to see what rewrite rules fired, etc.
05:07:17 <int3__> jmcarthur: cool, I'll try that out
05:07:18 <rwbarton> does anyone know how to turn a page on HaskellWiki into a redirect?
05:07:57 <danilo2> hexagoxel: I mean that my exampel works in 7.8.2 - the problem is still the same :(
05:07:59 <jmcarthur> int3__: it might be a little overwhelming at first, but it's actually pretty simple. it's mostly the naming that's confusing
05:09:53 <rwbarton> it's not really valid
05:09:53 <rwbarton> ghc is protecting you from yourself
05:11:05 <hexagoxel> danilo2: a b -> c works, b c -> a does not, correct?
05:11:49 <jmcarthur> int3__: http://lpaste.net/106710
05:12:34 <jmcarthur> int3__: so i see a use of map that didn't get fused away in there, but i haven't gone to the trouble of figuring out where it came from
05:13:00 <jmcarthur> int3__: note also that fusion is generally more impressive when the output type isn't a list :)
05:14:19 <int3__> jmcarthur: I don't see any concats in there, that seems like a good sign... right?
05:14:29 <int3__> (eating dinner now, will read up on Core syntax later)
05:14:36 <jmcarthur> yeah that's a pretty good sign
05:14:54 <jmcarthur> the thing you want to look out for is allocations
05:15:25 <jmcarthur> at least allocations that (to you) are obviously unnecessary
05:15:52 <int3__> mm okay
05:16:46 <jmcarthur> int3__: "let" is generally a sign of bad things happening in Core, and i do see a let there
05:16:58 <danilo2> hexagoxel: Ok, I see the problem :) You are right - fundeps are here necessary :)
05:17:07 <jmcarthur> s/generally/usually, when trying to write tight code,/
05:17:12 <int3__> ah I see
05:17:39 <danilo2> hexagoxel: Thank you very much :) I saw exactly where the problem is now - should I write "why" here also, or you know it as well ? :)
05:18:09 <hexagoxel> danilo2: so my question would be "does a b -> c make sense from semantic standpoint / are you sure there wont be conflicting instances?"
05:20:29 <danilo2> hexagoxel: I was able to transfgorm this code in such way, that there are no conflicting isntances. I've got although another example, where such transformation is not possible (or at least I do not see it) and I've got exactly the same issue there. But in the other case, I do not need to construct such functions so its fine. And yes, in this example "a b -> c" maskes sense and works well
05:33:35 <Flonk> Is there a way to compile source from stdin?
05:33:51 <Flonk> echo "main=interact id" | ghc -e, or something along those lines
05:34:28 <danilo2> Flonk: according to manpage, no
05:34:47 <danilo2> Flonk: but its straightforward to make script, which will put such file to tmp dir and compile it
05:35:15 <Flonk> danilo2: Yeah,  was just hoping for a 'cleaner' solution
05:35:17 <danilo2> Flonk: https://ghc.haskell.org/trac/ghc/ticket/2427
05:35:28 <danilo2> Flonk: opened 6 years ago, heh
05:35:54 <Flonk> danilo2: Haha, shouldn't be expecting much, then
05:36:02 <haasn> Flonk: Would runhaskell help?
05:36:07 <danilo2> Flonk: I love a commont there (4 years ago): "Milestone changed from 6.12.3 to _|_"
05:36:46 <danilo2> haasn: runhaskell is just a bash script ...
05:36:46 <Flonk> haasn: Oh wow, I've never heard of that!
05:37:00 <danilo2> haasn, Flonk: It will not, unfortunatelly :)
05:37:14 <danilo2> haasn, Flonk: the script has got around 10 lines of bash
05:37:26 <l0cust> Being a math guy, I hate to admit that chemists do anything right
05:37:29 <l0cust> but their notation is just flawless
05:37:34 <l0cust> Notation in mathematics is a clusterfuck, at best
05:37:51 <haasn> But feeding STDIN into runhaskell works (although your example wouldn't, because there's no STDIN left for the actual program!)
05:38:29 <haasn> So if runhaskell is just a 1 line invocation of ghc, then GHC is clearly capable of interpreting things from STDIN
05:39:29 <haasn> Ah, it's a wrapper for “runghc”, which is a 32k-sized ELF
05:39:57 <Flonk> Yeah, I'm reading through the source aswell
05:40:20 <Flonk> It's probably easiest to just roll my own solution
05:40:47 <danilo2> haasn: but runhaskell cannot run things from stdin as far as I know
05:41:13 <haasn> Works fine here
05:41:28 <danilo2> haasn, Flonk: I've got a simple idea - is it a problem for you to use ghc api and write such program? Of course without all the command line args, but doing what you need?
05:41:45 <haasn> nand@nanodesu ~ λ echo 'main = putStrLn "Hello, world!"' | runhaskell
05:41:47 <haasn> Hello, world!
05:42:00 <danilo2> haasn: Oh!
05:42:20 <Flonk> danilo2: But like haasn said, then there's no stdin left for the actual program
05:42:26 <jmcarthur_mobile> You could use a fd instead of a pipe: ghc <(commandthatproduceshaskellcode)
05:43:04 <jmcarthur_mobile> Or runhaskell or whichever
05:43:40 <haasn> jmcarthur_mobile: iirc; that, on the other hand, does *not* actually work
05:43:50 <haasn> But maybe it's fixed in HEAD or 7.8
05:44:13 <haasn> Yep, still broken: *** Exception: /dev/fd/63: hFileSize: inappropriate type (not a regular file)
05:44:32 <jmcarthur_mobile> Ew!
05:45:29 <Flonk> mh, I guess I'll just place the code it in a uniquely named temporary file which I delete afterwards
05:45:33 <Flonk> Seems easy enough
05:45:38 <jmcarthur_mobile> I guess there's always zsh's =(command) feature (makes actual tmp file)
05:46:03 <jmcarthur_mobile> Not sure if bash has an equivalent
05:46:44 <Flonk> Seems like you can "cat /proc/sys/kernel/random/uuid" to get a unique name
05:47:09 <jmcarthur_mobile> Flonk: just use mktemp if that's all you're after
05:47:51 <jmcarthur_mobile> Flonk: or maybe try the zsh feature I mentioned
05:48:18 <Flonk> jmcarthur_mobile: Oh, that's cool!
05:48:25 <Flonk> I'll check that out, thanks! :)
05:50:27 <ksf_> why's that in /proc, not /dev?
05:51:27 <ksf_> also, man 1 mktemp
05:52:38 <ksf_> and shell scripts should be limited to #!/bin/sh
05:52:43 <ksf_> *not* zsh, not bash, sh.
06:00:21 <jmcarthur_mobile> ksf_: for personal use, I'll use whatever I want for a shell script :p
06:00:49 <jmcarthur_mobile> ksf_: and even for other stuff, I think bash is fine. I wouldn't require anybody to use zsh though
06:01:31 <jmcarthur_mobile> I have never once regretted using a more modern language for a shell script
06:03:01 <ksf_> if your shell script is complex enough to benefit from any feature sh doesn't have, it shouldn't be a shell script.
06:03:08 <ksf_> but that's, you know, just my opinion, man.
06:03:26 <rwbarton> well it's not a shell script, it's a zsh script
06:03:28 <rwbarton> problem solved
06:03:49 <pjdelport> ksf_: OTOH, wouldn't it be great if POSIX shell had sane quoting behavior by default, a la zsh?
06:04:51 <ksf_> don't get me wrong, my shell is zsh, but if something like the ghc wrapper script doesn't run with plain sh you're doing it wrong.
06:05:20 <ksf_> even firefox has sane wrapper scripts, by now.
06:05:54 <l0cust> ksf_ is correct, although he shouldn't be
06:05:59 <zomg> backwards compatibility is a mess
06:06:01 <zomg> :P
06:06:02 <goit790> http://newxxxhd.com/all-new-brazzers-movies-in-hd-for-free/
06:12:51 <Ainieco> hello
06:14:38 <Ainieco> is it okay to have class which requires from instances only a lens field to be defined and then rest of functions within class will operate on that lens field?
06:15:34 <Ainieco> i haven't seen such pattern before so i'm a bit suspicious about it - maybe there is other abstraction to handle such things
06:17:37 <yoeight> Hi all ! Does someone know how to make 'cabal haddock --hyperlink-source' work when a package is uploaded to hackage use external dependencies like Data.Text for instance ?
06:18:36 <quchen_> yoeight: I think Cabal checks your locally installed documentation for this only.
06:18:55 <quchen_> If you have links to packages that were built without docs, you won't get any links.
06:19:39 <quchen_> You can configure Cabal to automatically build docs in your cabal config, it has a Haddock section now (finally!).
06:19:46 <supki> Ainieco: it's hard to say without seeing your code
06:20:37 <yoeight> quchen_:thanks ! Does that feature related to ~/.cabal/config somehow ?
06:21:05 <supki> Ainieco: makeClassy fits your description, for instance, and it's perfectly OK to use makeClassy
06:21:51 <helge_> say I have a fairly complex data structure (Game, containing two players, who each contain a list of cards they have in hand, a list of cards on the board, etc.), what is an ideomatic way to change something deep into the data structure and return a new Game with that change in it?
06:22:30 <lieven_> helge_: lens
06:22:35 <helge_> Maybe something in one of the cards needs to be changed, and I need a new Game value that represents the state after that change.
06:22:45 <Ainieco> supki: that's what i needed, thank you kindly
06:23:38 <helge_> lieven_: that was.. not the easiest documentation, but I'll look into it
06:24:28 <lieven_> helge_: try to find a tutorial. the implementation diagram is daunting to say the least
06:24:35 <helge_> lieven_: so, the "naitive way" would be to recreate the whole Game value, specifying each attribute that didn't change, then change the one attribute that should be changed, right?
06:27:32 <joshc> Ainieco: not that I'm that familiar with it, but it sounds similar to snap/heist's HasHeist class
06:28:07 <lieven_> helge_: you don't need to specify the unchanged fields. newvalue = oldvalue {changedField=changedValue} works fine. it just becomes unwieldy quickly for deeply nested structures
06:28:16 <jkarni> helge_: no, you can update a single record field with eg object { field = newvalue}
06:28:46 <helge_> oh, that's good then. but I'll look into lens too. thanks!
06:28:47 <quchen_> yoeight: Yes. You want to set "documentation" and probably also "hyperlink-source" to True in the config. The latter includes source and links to it into the docs (like on Hackage). (You have to have hscolour installed to make it work, cabal install hscolour)
06:29:10 <quchen_> From that point on, you'll see "updating documentation" at the end of your builds, that's when Haddock is run.
06:31:03 <yoeight> quchen_:thanks a lot !
06:43:39 <yoeight> quchen_: I reinstall everything after I updated my ~/.cabal/config and yet generated html files stll point to documentation located in my current sandbox. Did I miss something ?
06:45:06 <quchen_> Oh, you want the links in your local docs to point to Hackage?
06:45:21 <quchen_> I've never heard of that. I thought you just wanted good interlinking like on Hackage.
06:45:59 <quchen_> (Hackage knows all packages, so when it generates docs, all links work out properly. Locally you can reproduce that behaviour in isolation.)
06:46:11 <quchen_> (But you obviously don't have all packages) :-)
06:46:57 <yoeight> quchen_: No. What I want is when I upload my lib documentation to hackage, hyperlinking works
06:47:52 <quchen> yoeight: That should work automatically when you've used proper markup.
06:47:53 <yoeight> quchen_: Sadly, it always point to my local sandbox after uploading
06:48:26 <quchen> Hackage should build the docs for you if you don't upload any, manual uploading is only necessary in special cases as far as I remember.
06:48:30 <yoeight> quchen: I pretty I'm doing something wrong, just doesn't know where :)
06:48:56 <yoeight> quchen: True but hackage take a lot of time to do so
06:48:57 * hackagebot open-typerep 0.1 - Open type representations and dynamic types  http://hackage.haskell.org/package/open-typerep-0.1 (EmilAxelsson)
06:48:59 <quchen> Where's your package on Hackage?
06:49:32 <quchen> yoeight: Hackage runs the doc builder once a day if I remember correctly. It's a pretty big task so doing it on every upload would be quite a hassle.
06:49:42 <yoeight> quchen: https://hackage.haskell.org/package/deiko-config-0.5.0.0
06:50:26 <yoeight> quchen: I'm ok with that, that is why I try to do it my self :)
06:52:01 <quchen> I'm afraid I can't help you with that then, I've never uploaded my own docs to Hackage :-\
06:52:35 <jkarni> yoeight: take a look at http://fuuzetsu.co.uk/blog/posts/2014-01-06-Hackage-documentation-v2.html  - might be related
06:52:47 <hooplahoops> Hi, is there anything to guess the type of a CSV column?
06:53:14 <quchen> String would be my guess ;-)
06:53:19 <bergmark> hooplahoops: i'm working on that :-o
06:53:21 <yoeight> quchen: thanks for your time, you had fixed my cabal setup !
06:53:28 <hooplahoops> quchen: tee hee :)
06:53:31 <Rembane> hooplahoops: read! :D
06:53:35 <hooplahoops> bergmark: cool! How's that going?
06:53:52 <yoeight> jkarni: That looks like the answer thanks very much !
06:53:57 * hackagebot data-accessor 0.2.2.6 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.6 (HenningThielemann)
06:54:00 <quchen> hooplahoops: On the non-silly side, you could use decoding functions like "CSVEntry -> Maybe a" and chain them using <|>. The first successful decoding will be picked.
06:54:04 <hooplahoops> Rembane: lies! I have to tell read what I think it is :)
06:54:32 <hooplahoops> quchen: ah cool let me try that. Is this in Cassave?
06:54:34 <quchen> getInt x <|> getFloat x <|> getString x
06:54:45 <quchen> hooplahoops: No, that's just the Alternative instance of Maybe
06:54:55 <hooplahoops> Oh I see, ok
06:55:06 <bergmark> hooplahoops: the basic algorithm i have gives each column an accuracy based on how easy it is to parse each value as that type
06:55:07 <Rembane> hooplahoops: Meh. :D
06:55:47 <quchen> hooplahoops: I'm not sure how Cassava works, but conceptually what you want is what I said above: "try all those different interpretation and pick one that works".
06:57:24 <quchen> hooplahoops: Cassava has the "FromField" typeclass which has a "parseField :: Field -> Parser a" function. Parsers are Alternatives, so you could use that.
06:58:58 * hackagebot data-accessor-transformers 0.2.1.5 - Use Accessor to access state in transformers State monad  http://hackage.haskell.org/package/data-accessor-transformers-0.2.1.5 (HenningThielemann)
06:59:00 * hackagebot data-accessor-transformers 0.2.1.6 - Use Accessor to access state in transformers State monad  http://hackage.haskell.org/package/data-accessor-transformers-0.2.1.6 (HenningThielemann)
06:59:19 <quchen> data Guess = IntVal Int | FloatVal Double | OtherVal Text; instance fromField Guess where parseField x = (IntVal <$> parseField x) <|> (FloatVal <$> parseField x) <|> pure x
06:59:22 <quchen> Something like that
07:00:43 <hooplahoops> quchen: theoretically it sounds good, but I need to structure columns in say, unboxed vectors
07:00:55 <hooplahoops> quchen: so it's more likely that I have to guess over a sample
07:01:18 <hooplahoops> e.g. I could have values "1" and mistake them for "Int", but it may actually be a "Float"
07:01:34 <hooplahoops> it can't always get it right of course
07:02:52 <quchen> hooplahoops: Hmm. In that case, maybe as a makeshift solution, you could parse the column as Text, and then do the guessing in another pass over the data.
07:03:37 <hooplahoops> quchen: right, that's what I was working towards, thanks
07:03:58 * hackagebot data-accessor-mtl 0.2.0.4 - Use Accessor to access state in mtl State monad class  http://hackage.haskell.org/package/data-accessor-mtl-0.2.0.4 (HenningThielemann)
07:04:00 <hooplahoops> I think your technique is useful and just I need to make that work under conjunction
07:07:07 <Peaker> Is ByteString allocation very expensive, due to GC pinning or some such?
07:07:27 <Peaker> Getting some degradation in performance when changing some (short variable name) Strings to ByteStrings
07:07:38 <Peaker> (the laziness of the strings is not used)
07:08:42 <rwbarton> ByteStrings are pinned yeah, try Text maybe?
07:08:59 * hackagebot explicit-exception 0.1.7.3 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.7.3 (HenningThielemann)
07:10:11 <Peaker> rwbarton: yeah, trying, thanks
07:13:59 * hackagebot syntactic 2.0 - Generic representation and manipulation of abstract syntax  http://hackage.haskell.org/package/syntactic-2.0 (EmilAxelsson)
07:16:13 <Ainieco> is it okay to have State Foo () type of function?
07:17:09 <Axman6> aschroeter: sure, why not?
07:17:12 <Axman6> uh, Ainieco
07:17:15 <Axman6> :t put
07:17:16 <lambdabot> MonadState s m => s -> m ()
07:17:23 <Axman6> bleh
07:17:45 <Axman6> :t put :: s -> State s ()
07:17:46 <lambdabot> s -> State s ()
07:18:59 * hackagebot jack 0.7.0.3 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.7.0.3 (HenningThielemann)
07:19:40 <Ainieco> Axman6: thanks, sorry just lacking of intuition of what is good and what is bad in haskell
07:20:07 <Ainieco> thankfully there aren't much "bad" things in haskell
07:24:00 * hackagebot midi 0.2.1.3 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1.3 (HenningThielemann)
07:29:01 * hackagebot pooled-io 0.0.0.1 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0.0.1 (HenningThielemann)
07:29:01 <Ainieco> how can i append element to list lens?
07:30:00 <quchen> <>~ does that
07:30:27 <quchen> > ("hello", "w") & _2 <>~ "orld"
07:30:28 <lambdabot>  ("hello","world")
07:34:01 * hackagebot sox 0.2.2.5 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.2.5 (HenningThielemann)
07:34:03 * hackagebot storable-record 0.0.3 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.3 (HenningThielemann)
07:34:38 <Ainieco> > [1,2] <>~ 3
07:34:40 <lambdabot>  Couldn't match type ‘[t0]’
07:34:40 <lambdabot>                with ‘(a0 -> Data.Functor.Identity.Identity a0)
07:34:40 <lambdabot>                      -> s -> Data.Functor.Identity.Identity t’
07:34:40 <lambdabot>  Expected type: Control.Lens.Setter.ASetter s t a0 a0
07:34:40 <lambdabot>    Actual type: [t0]
07:35:22 <quchen> If you want to target every single element, you'll have to map over the list.
07:35:23 <quchen> > [1,2,3] & mapped +~ 10
07:35:25 <lambdabot>  [11,12,13]
07:36:05 <Ainieco> quchen: i just want to add element to list
07:36:15 <Ainieco> via lens
07:36:18 <quchen> > [1..10] & id <>~ [11]
07:36:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11]
07:36:27 <Ainieco> thanks
07:36:35 <quchen> Not sure why that would be useful though.
07:36:45 <quchen> You could just do it without lens, [1..10] <> [11]
07:37:04 <edwardk> lens is typically bad at changing the shapes of things
07:37:26 <Ainieco> quchen: i want to update record list field
07:37:38 <Ainieco> record's*
07:37:48 <edwardk> ah then that is what <>~ is for =)
07:37:51 <Peaker> edwardk: is it possible for   LensLike f s s a b    to ever be law abiding (when a and b differ)?
07:38:30 <edwardk> Iso a a (Const a b) (Const a c)
07:39:19 <edwardk> :t _Unwrapping Const
07:39:20 <lambdabot> (Profunctor p, Functor f) => p (Const a' x') (f (Const a'1 x'1)) -> p (Unwrapped (Const a' x')) (f (Unwrapped (Const a'1 x'1)))
07:39:27 <edwardk> er that ;)
07:39:56 <quchen> ಠ_ಠ
07:40:23 <edwardk> :t Data.Dynamic.Lens._Dynamic
07:40:24 <lambdabot> (AsDynamic t, Choice p, Applicative f, Typeable a) => p a (f a) -> p t (f t)
07:40:32 <edwardk> ^- that used to allow 'a' and 'b' to differ as well
07:40:41 <edwardk> but we changed it at one point for little good reason
07:40:50 <edwardk> well, good reason at the time
07:40:54 <edwardk> but not good in the long term
07:41:36 <edwardk> in general though you can't expect the inner type family to be a function of the outer one
07:41:45 <edwardk> its common, but not necessary
07:45:26 <Peaker> edwardk: ah, thanks
07:45:55 <Ainieco> edwardk, quchen: is it possible to use (:) with lens to add element ot list lens?
07:46:06 <edwardk> use %~ to go in
07:46:34 <edwardk> > (a,[y,z]) & _2 %~ (x:)
07:46:36 <lambdabot>  Ambiguous occurrence ‘x’
07:46:36 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:204:1
07:46:36 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
07:46:36 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
07:46:36 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
07:46:43 <edwardk> > (a,[y,z]) & _2 %~ (w:)
07:46:45 <lambdabot>  (a,[w,y,z])
07:47:51 <Peaker> weird!  A little type inference engine that used Strings for type-vars. Replace String with Text. Same performance. Replace it with unboxed Vector of Word8, and *total* performance goes down 1.5x!
07:47:56 <Ainieco> edwardk: Thanks!
07:48:45 <quchen> Peaker: What's Text internally?
07:49:48 <pjdelport> Peaker: Do you have a diff of the code somewhere?
07:50:04 <rwbarton> is "performance goes down" good or bad?
07:50:22 <Peaker> quchen: It has its own weird Array implementation
07:50:26 <Peaker> rwbarton: very bad
07:50:28 <pjdelport> Peaker: What kind of operations are done on the strings?
07:50:56 <Peaker> pjdelport: construction ("a5", "a6", typevar generation) and Ord instance
07:51:00 <Peaker> (very short strings)
07:51:02 <edwardk> Peaker: does vector do the shortcut where it can check for backing storage equality in O(1)?
07:51:17 <Peaker> edwardk: no idea..
07:51:27 <Peaker> but the strings are so short it should be cheap O(1) anyway
07:53:04 <Ainieco> i wonder if there is a conventional way to render sum types in JSON vai Aeson? e.g my record Foo has a "fooBar :: Bar" field where Bar = Int | String
07:53:34 <Ainieco> i know there is no sum types in json but wonder if someone already came up with something clever to deal with it
07:56:03 <Peaker> pjdelport: https://github.com/Peaker/Algorithm-W-Step-By-Step/commit/4cb60d6adf5a63a805d73ca837b1413446e2b8ad  <-- converting typevar names from String to ByteString -- made it slower by ~10%
07:56:08 <wagle> how do i geet cabal to recompile everything?
07:56:16 <wagle> how do i get cabal to recompile everything?
07:56:35 <rwbarton> Peaker, would be interesting to see profiler output
07:56:55 <rwbarton> and also whether GC overhead is significantly different, that's even easier
07:57:25 <Ainieco> is it possible to create pattern match to ignore constructor of sum type but extract value from constructor? e.g for "Bar = BarInt Int | BarString String" have something like "f (_ x) = show x"
07:57:36 <Peaker> rwbarton: +RTS -s ?
07:57:51 <rwbarton> yeah (and build with -rtsopts)
07:58:11 <thoughtpolice> do you need -rtsopts for -s? I thought that restriction was lifted
07:58:14 <pjdelport> Peaker: Hmm, what are you using as the benchmark? (Does it feature the pretty-printing?)
07:58:17 <rwbarton> oh, maybe not
07:58:30 <thoughtpolice> but yes, -s is always a good start, it can quickly show GC changes that account for speed differences in a lot of cases
08:00:17 <Peaker> pjdelport: I think not -- testing now
08:01:15 <Peaker> pjdelport: https://github.com/Peaker/Algorithm-W-Step-By-Step/blob/blah/src/benchmark.hs
08:01:27 <Peaker> Criterion doesn't whnf the "a" in an "IO a" bench, does it?
08:01:36 <pjdelport> Peaker: What rwbarton said, though: it's probably a good idea to profile both versions, and compare to see where the major differences are happening.
08:05:58 <Peaker> so there appears to be no difference in RTS -s output in the slow Vector version and String
08:09:03 * hackagebot bloodhound 0.2.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.2.0.0 (bitemyapp)
08:10:07 <rwbarton> Peaker: except in the MUT time I assume?
08:11:13 <quchen> I need something like Hashable, but so that it works for sending (and checking) hashes over the network. Since Hashable creates Int, the hashes can differ from machine to machine, based on the Int size. Is there an easy way out of this?
08:11:29 <quchen> In other words, is there a Hashable that produces WordN somewhere?
08:11:34 <c_wraith> quchen: there are lots of hash packages that use standardized algorithms
08:11:41 <Peaker> rwbarton: yeah
08:11:43 <int3__> is there a way to find out (e.g. in ghci) which typeclasses a type is an instance of?
08:11:49 <quchen> int3__: :i
08:12:04 <int3__> quchen: ahh thanks
08:12:08 <Peaker> int3__, quchen: But that only shows instances of classes that are imported/in scope
08:12:13 <c_wraith> quchen: http://hackage.haskell.org/package/murmur-hash for instance
08:13:00 <quchen> c_wraith: I'm currently using MD5, but that introduces a new (large-ish for its purpose) dependency, so I'm trying to avoid that.
08:13:16 <osa1> can I have a list with type of something like [MyClass a] without creating a new type using existentials? I don't want to wrap values with a data constructor.
08:13:28 <quchen> Murmur looks nice though.
08:13:36 <c_wraith> quchen: yeah, its dependencies are small
08:14:04 * hackagebot yesod-angular 0.1.0.1 - Yesod Angular JS integration.  http://hackage.haskell.org/package/yesod-angular-0.1.0.1 (ChristopherReichert)
08:14:09 <c_wraith> osa1: how much benefit do you actually get from that representation, anyway?
08:14:14 <quchen> c_wraith: And the module mainly defines a Hashable64 class, which is what I would have reinvented :-)
08:14:23 <quchen> So thanks
08:14:31 <osa1> c_wraith: I can use `map classFunction`
08:15:00 <c_wraith> osa1: So..  What you really want is something like a list that automatically applies classFunction on insertion?
08:15:08 <Peaker> Haskell performance is a puzzling thing
08:15:15 <c_wraith> osa1: or even a helper function that does that with normal lists
08:15:44 <Peaker> pjdelport: Removed the PP from the benches, and it didn't change anything
08:15:52 <Peaker> pjdelport: (so it wasn't actually being used)
08:16:09 <osa1> c_wraith: I want to apply on construction. I have this code [a, b, c, d] where elements are all instances but have different types.
08:16:39 <osa1> c_wraith: assume this list has a lot more elements so I don't want to wrap every element with a funcall manually
08:16:39 <c_wraith> osa1: so what you really want is syntactic sugar for list literals that aren't well-typed.
08:16:59 <osa1> c_wraith: they should be well typed under some type system :)
08:18:27 <osa1> c_wraith: something like `[a, b, c, d] :: MyClass a => [a]`
08:18:42 <c_wraith> osa1: that's not what that syntax means, though
08:19:04 <osa1> c_wraith: what does that syntax mean?
08:19:11 <c_wraith> osa1: Why not just define an operator like (&) :: MyClass a => a -> [ResultType] ; x & xs = classFunction x : xs ; infixr 4 &   and then use it like a & b & c & d & []
08:19:42 <c_wraith> osa1: that's like one token more than a list literal would be
08:19:47 <osa1> c_wraith: that works too but list syntax and a map/fmap call is more convenient because I'll need to make less amounts of chages
08:20:07 <c_wraith> osa1: will you really?  Because by my count it should be basically the same.
08:20:57 <c_wraith> Though come to think of it, I'd define that operation as infixr 3 instead of infixr 4
08:22:09 <osa1> will we ever have something like OverloadedLists ?
08:22:13 <c_wraith> We have it
08:22:21 <osa1> really? in 7.8.2 ?
08:22:23 <c_wraith> But it doesn't remove the requirement that lists be well-typed
08:22:25 <carter> yeah
08:22:47 <osa1> c_wraith: I don't understand what makes you think I need not well-typed lists here
08:22:56 <carter> i think it'd be cool to have overloaded list syntax actually be sugar for cons
08:22:58 <osa1> c_wraith: if I could overload (:) function I could have that easily
08:22:59 <carter> then you could do crazy shit
08:23:18 <osa1> c_wraith: (:) = (&) in your example
08:23:34 <bitemyapp> osa1: Idris has something kind of like what you're talking about.
08:23:47 <bitemyapp> rebindable list syntax and overloaded functions.
08:23:49 <rwbarton> yeah I was just looking into OverloadedLists, it looks like basically it just slaps a fromList function in front of your list
08:24:05 * hackagebot yaml-rpc 1.0.1 - Simple library for network (HTTP REST-like) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-1.0.1 (IlyaPortnov)
08:24:15 <c_wraith> MyClass a => [a] doesn't mean "every element is some type that's an instance of MyClass".  It means "Every element of this list is an element of any instance of MyClass that you want it to be."
08:24:45 <rwbarton> you could imagine instead desugaring into new type class methods 'cons' and 'nil'
08:24:53 <c_wraith> :t [mempty, mempty]
08:24:54 <lambdabot> Monoid t => [t]
08:25:18 <c_wraith> That could be a [[]].  It could be a [Maybe Dragon]
08:25:42 <c_wraith> err, it'd have to be [[()]]
08:25:46 <c_wraith> Some concrete type
08:25:48 <c_wraith> anyway.
08:25:50 <osa1> I see, I guess I'll need that "forall" inside the list
08:26:00 <osa1> [forall a. MyClass a => a]
08:26:11 <c_wraith> Also doesn't do what you want.
08:26:14 <moghedrin> Using template haskell, is there a way to look at the variables a function expects?
08:26:19 <osa1> c_wraith: now what's wrong?
08:26:19 <c_wraith> You can do that with ImpredicativeTypes
08:26:41 <osa1> c_wraith: I'm not talking about having that in Haskell rather I'm just thinking that in some type system something like that should be possible
08:26:44 <c_wraith> But it means that each element must be polymorphic.  [mempty, mempty] would still qualify
08:27:16 <c_wraith> What you mean to say you want is [exists a. MyClass a => a]
08:27:34 <osa1> right... well Haskell's existential syntax uses forall :)
08:27:35 <c_wraith> I don't think you really want to deal with the consequences of that in real code, though.
08:28:03 <c_wraith> osa1: no, it doesn't.  Existentials are encoded via the duality they have with universals.
08:28:19 <c_wraith> osa1: But the difference really matters.
08:28:58 <c_wraith> osa1: in particular, when you use the universal + constructor representation, you are providing a place to store the proof that your type is an instance of the class - in the data constructor.
08:29:44 <c_wraith> osa1: with a bare existential type, you don't get a place to store the proof.  And that's really a big deal, because in GHC, that proof corresponds with the instance dictionary
08:30:58 <osa1> interesting stuff, thanks c_wraith.
08:31:14 <osa1> TIL why GHC uses forall in ExistentialQuantification syntax
08:32:00 <vova> Hi all, Could someone provide me with the code examples how to parse the html tables using HXT package. I found some, but they are not useful for me.
08:32:33 <c_wraith> I suppose it would be nice if RebindableSyntax let you rebind list syntax.  I don't think that extension is a big win in general anyway, but if it's going to exist, I don't see a problem with it doing more of what it does.
08:35:58 <osa1> yeah that would be really cool.
08:36:38 <bergmark> or add listfix even :-)
08:36:57 <osa1> although I can't see how it would be useful in my case, handling scoping might be a problem.
08:37:01 <bergmark> i guess that's kind of what overloaded lists is
08:37:16 <bennofs> :i IsList
08:38:05 <c_wraith> My big issue with RebindableSyntax is that it's inherently limited to doing what you could write combinators for.  I don't think there's enough syntax in haskell to really be a big gain in using it instead of combinators.
08:39:16 <bergmark> yeah i don't have any good use cases for it apart from the hackery that's in fay
08:39:41 <quchen> Does derived Binary introduce a one-byte overhead for the single constructor of a newtype? I'm not sure whether generics allow distinguishing between data and newtype.
08:40:29 <c_wraith> quchen: that's a good question.  You could always GND it, though, to avoid that overhead
08:40:51 <c_wraith> (if it exists)
08:41:04 <quchen> I'll try it out then
08:41:45 <rwbarton> is "cabal install --only-dep packagename" supposed to work when run standalone (not in packagename's directory)?
08:41:47 <c_wraith> I'd hope the instance generation would be smart enough to not produce output for the constructor of a single-constructor type, though
08:42:05 <bergmark> rwbarton: yeah, i'm pretty sure it works
08:42:05 <c_wraith> Since newtype or not, it's never information in the serialized form.
08:42:10 <rwbarton> hmm
08:42:32 <bergmark> rwbarton: confirmed
08:43:29 <bergmark> rwbarton: you can only pass one package as an arg to it though
08:43:45 <quchen> c_wraith: Oh, it's smarter than that even!
08:43:55 <quchen> http://lpaste.net/106736
08:44:01 <quchen> All of those serialize to the same size
08:44:19 <quchen> So it even checks whether there are single-field "data" types
08:44:56 <c_wraith> quchen: I did make a comment to that effect! if a type has a single constructor, which constructor it uses isn't information. :)
08:44:56 <rwbarton> bergmark: oh I see what I was doing wrong
08:44:57 <rwbarton> thanks
08:45:22 <c_wraith> quchen: even for data.  (though for data, whether that constructor has been evaluated is information - it's always evaluated during serialization, so it loses that information)
08:45:41 <moghedrin> :t isNothing
08:45:42 <lambdabot> Maybe a -> Bool
08:46:05 <quchen> c_wraith: Yes, and the strictness doesn't matter for serialization anyway. I just wasn't sure how smart Binary was.
08:46:22 <c_wraith> moghedrin: While that function exists, it's rare for it to be the best option.  Are you sure it's what you really want?
08:46:27 <bergmark> quchen: this may be a pretty new thing, i remember simon meier was working on a more space efficient format last year
08:47:50 <cschneid> Can somebody link me the actual source for Eq? hackage has a 404 on it
08:48:04 <c_wraith> @source Eq
08:48:04 <lambdabot> Unknown command, try @list
08:48:08 <c_wraith> @src Eq
08:48:08 <lambdabot> class  Eq a  where
08:48:08 <lambdabot>     (==), (/=)   :: a -> a -> Bool
08:48:16 <c_wraith> Darn, that's not the real source
08:48:17 <cschneid> c_wraith: well, there's a default impl of both of those
08:48:25 <cschneid> ya, already did that in privchat w/ lambdabot :)
08:48:54 <moghedrin> c_wraith: I'm fairly confident. I can't think of a better way to conveniently convert a function with a similar to (a -> b -> IO c) into something that looks like (b -> StateT a IO c)
08:48:59 <quchen> Lambdabot's ?src is a text file.
08:49:00 <quchen> Lambdabot @src database: https://github.com/int-e/lambdabot/blob/master/lambdabot/State/source
08:49:59 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html#Eq
08:50:02 <c_wraith> moghedrin: I don't even see how a Maybe fits into that conversion
08:50:17 <moghedrin> c_wraith: Did I say something about a maybe? :O
08:50:33 <moghedrin> c_wraith: *Maybe
08:50:57 <moghedrin> c_wraith: Oh!
08:51:02 <moghedrin> c_wraith: I see!
08:51:14 <moghedrin> c_wraith: Thought you were answering the question I asked earlier XD
08:51:30 <c_wraith> moghedrin: oh, sorry.  Missed the earlier question. :)
08:51:41 <moghedrin> Using template haskell, is there a way to look at the variables a function expects?
08:51:44 <moghedrin> XD
08:52:08 <cschneid> thanks. How does the compiler spit out the `No explicit implementation for either ‘==’ or ‘/=’` error? How does it know?
08:52:24 <cschneid> or is that just the default for typeclasses that have default impls for all functions?
08:52:28 <c_wraith> cschneid: that's new as of GHC 7.8
08:52:49 <cschneid> oh, fancy
08:52:59 <c_wraith> cschneid: classes can now have pragmas that specify the minimum complete implementation, and GHC will check to be sure it's met
08:54:01 <cschneid> c_wraith: we were guessing that here - that there was additional tagging, but I hadn't found evidence - thanks
08:54:12 <thoughtpolice> yes, and most of the classes in 'base' should have MINIMAL pragmas now
08:54:28 <thoughtpolice> (definitely one of the nicest additions in 7.8 IMO, people seem to get tripped up on that quite a lot)
08:55:02 <c_wraith> yeah, it's an excellent quality-of-life improvement.
08:55:12 <c_wraith> There's no real downside - it makes everyone happier.
08:55:24 <c_wraith> ..  Except people making hacky Num instances to show off dumb tricks. :)
08:57:01 <c_wraith> cschneid: as a contrasting example, look at the Exception class.  It has default implementations for everything, and the minimal complete definition is leaving everything default.
09:06:15 <cschneid> c_wraith: cool. thanks for the examples - certainly a nice feature
09:06:19 <danilo2> Hello All! :) Does anybody know if is there any "hook" to process a haskell file before compilation? I would love to use it with cabal and with runhaskell (but if its not possible with runhaskell its fine with cabal only)
09:06:39 <danilo2> I want to run a simple python script, which will modify the content of the haskell file
09:06:50 <c_wraith> danilo2: you can create a custom Setup.hs file
09:06:55 <Peaker> A StateT on a parameterized monad is much slower than StateT Identity :-(
09:07:03 <c_wraith> danilo2: look into cabal-install and the Cabal library for details
09:07:04 <Peaker> Haskell abstractions are supposed to be cheap, but often aren't
09:07:20 <c_wraith> danilo2: it won't work with runhaskell, though
09:08:40 <moghedrin> danilo2: Just out of curiosity, what sort of things do you plan on modifying in the haskell file?
09:08:58 <bergmark> danilo2: you can hack this with the CPP flags
09:09:00 <danilo2> c_wraith: ok, thank you. And what if I would like to add a "custom language extension", which will just run a script before parsing a file - is it possible ?
09:09:08 <geekosaur> options_ghc with -pgmF ?
09:09:26 <bergmark> it might not even be a "hack" :-)
09:09:27 <geekosaur> is that the right option?
09:09:27 <c_wraith> danilo2: geekosaur was answering your second question, by the way. :)
09:09:56 <c_wraith> danilo2: the -pgmF flag is part of the set of flags that allow you specify a custom preprocessor for your code
09:09:57 <bergmark> i think it's -pgmP
09:10:08 <danilo2> c_wraith, geekosaur: thank you very much! :)
09:10:16 <geekosaur> pgmP overrides CPP, pgmF overrides -F
09:10:20 <bergmark> ah ok
09:19:33 <moghedrin> @hoogle a -> IO b -> IO (a -> b)
09:19:34 <lambdabot> No results found
09:19:37 <path[l]> hi, I have a question. I’m trying to declare an arbitrary instance for my new Stack type. This is what I’m trying to do. instance Arbitrary (Stack Int) where arbitrary = fromList `fmap` (arbitrary :: Gen [Int]). It fails because it says that Arbitrary (Stack Int) is an illegal instance declaration
09:19:58 <moghedrin> @hoogle (a -> IO b) -> IO (a -> b)
09:19:59 <lambdabot> No results found
09:20:07 <benzrf> path[l]: haskell has bullshit restrictions on instances
09:20:16 <benzrf> basically, unless you enable certain GHC extensions
09:20:26 <moghedrin> @hoogle (a -> f b) -> f (a -> b)
09:20:27 <lambdabot> No results found
09:20:27 <benzrf> all instances must be of the form 'TypeConstructor only variables here'
09:20:40 <benzrf> path[l]: since Int is not a variable, it violates that rule
09:20:51 <benzrf> if you enable -XFlexibleInstances you can do that
09:21:01 <benzrf> but there might be other solutions
09:21:06 <path[l]> benzrf: so when I try to instead do this. instance Arbitrary (Stack a) where arbitrary = fromList `fmap` (arbitrary :: Gen [a]) it still complains
09:21:13 <benzrf> path[l]: about what?
09:21:27 <path[l]> No instance for (Arbitrary a1) arising from a use of `arbitrary' Possible fix:
09:21:35 <path[l]> add (Arbitrary a1) to the context of
09:22:22 <joelteon> path[l]: in that context, the a in Gen [a] is not the same as the one in Stack a
09:22:40 <path[l]> whoa ….
09:22:42 <path[l]> why?
09:22:44 <joelteon> path[l]: you don't even need to annotate the call to arbitrary; the call to fromList will force the compiler to assume it
09:22:50 <path[l]> hmmm
09:22:56 <joelteon> arbitrary = fmap fromList arbitrary
09:23:11 <benzrf> path[l]: when you do that
09:23:27 <benzrf> path[l]: in your old version, it knew that the items in the stack were Ints
09:23:32 <benzrf> which are Arbitrary
09:23:38 <benzrf> but your new version allows stacks of anything
09:23:50 <benzrf> and the typechecker doesnt know for sure that the items in the stack are Arbitrary
09:23:54 <path[l]> joelteon: that complains with  —> “No instance for (Arbitrary a) arising from a use of `arbitrary' “
09:23:56 <benzrf> add a constraint to your instance head
09:24:12 <benzrf> instance (Arbitrary a) => Arbitrary (Stack a)
09:24:21 <benzrf> now the instance will only hold for stacks whose items are Arbitrary instances
09:24:41 <path[l]> oh … I was not expecting that
09:25:02 <path[l]> wow, thanks
09:25:50 <benzrf> path[l]: no problem :-)
09:25:53 <benzrf> this is a common pattern
09:26:27 <benzrf> for example, the default Maybe Monoid instance works like this:
09:26:34 <benzrf> > mappend (Just "foo") (Just "bar")
09:26:35 <lambdabot>  Just "foobar"
09:26:44 <benzrf> > mappend (Just "foo") Nothing
09:26:46 <lambdabot>  Just "foo"
09:26:58 <benzrf> path[l]: obviously this only works for (Maybe a) when a is a Monoid
09:27:01 <benzrf> so the instance looks like:
09:27:11 <benzrf> instance (Monoid a) => Monoid (Maybe a) where ...
09:27:45 <rwbarton> path[l]: for future reference, note that ghc suggested doing exactly this: "add (Arbitrary a1) to the context of ..."
09:27:51 <path[l]> hmm
09:28:06 <benzrf> path[l]: so if you have (Maybe NotAMonoid), you can't use mappend on that
09:28:12 <benzrf> because Maybe a is only a monoid when a is a monoid
09:28:15 <path[l]> rwbarton: yeah, I misinterpreted that error message :)
09:28:15 <benzrf> very useful!
09:28:59 <path[l]> hmmm
09:33:16 <benzrf> path[l]: similarly, most monad transformers have a (Monad m) constraint on their Monad instance
09:33:26 <benzrf> path[l]: here's another example
09:33:28 <benzrf> @src Const
09:33:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:33:32 <benzrf> blah
09:33:48 <benzrf> path[l]: newtype Const r a = Const {getConst :: r}
09:33:55 <benzrf> path[l]: is this a functor?
09:35:56 <path[l]> well because it’s a newtype, I guess it’s not because it has no instance declaration?
09:36:43 <Javran> @pl \ (a,b) g = g a b
09:36:44 <lambdabot> (line 1, column 11):
09:36:44 <lambdabot> unexpected "="
09:36:44 <lambdabot> expecting pattern or "->"
09:36:57 <Javran> @pl \(a,b) g -> g a b
09:36:57 <lambdabot> uncurry (flip . flip id)
09:37:38 <Lutin`> Javran: uncurry g (a,b) = g a b
09:37:45 <athan> Has anyone had any luck deploying haskell web applications for cheap? I'm trying heroku right now for Yesod with a fair amount of teeth-pulling... any suggestions?
09:38:25 <Javran> Lutin`: I'm wondering if there's a version that can allow
09:38:36 <Javran> me to give arguments first
09:38:54 <kgadek> hi. ghc-7.8.2 from source on OS X 10.9, `make install` gives error "ghc-cabal: LICENSE: does not exist". Details here: https://www.evernote.com/shard/s204/sh/9b99bf5c-0b2e-4051-ae68-ca68ca1c0ef1/d3ffa91e43768d87e7d03bd85e1825c6
09:39:06 <Lutin`> :t flip uncurry
09:39:10 * hackagebot synthesizer-alsa 0.5.0.2 - Control synthesizer effects via ALSA/MIDI  http://hackage.haskell.org/package/synthesizer-alsa-0.5.0.2 (HenningThielemann)
09:39:10 <lambdabot> (a, b) -> (a -> b -> c) -> c
09:39:14 <Lutin`> Like that?
09:39:59 <athan> kgadek: From source? Are you cloning the git repo?
09:40:03 <shapr> athan: I just get a $5/month VPS from lowendbox.com
09:40:05 <kgadek> source
09:40:48 <athan> kgadek: There are many sources... did you clone ghc's git repo? Or are you trying to install the distributed tarball?
09:41:04 <Javran> Lutin`: sure, exactly! thanks
09:41:21 <athan> kgadek: Are you aware of the haskell-platform / ghc 7.6.x & ghc 7.8.x deficiency?
09:41:30 <athan> shapr: Thanks, I'll check it out :)
09:41:44 <kgadek> athan: I downloaded it from http://www.haskell.org/ghc/dist/7.8.2/ghc-7.8.2-src.tar.xz .
09:41:56 <joelteon> > repeat "hip"
09:41:58 <lambdabot>  ["hip","hip","hip","hip","hip","hip","hip","hip","hip","hip","hip","hip","hi...
09:41:58 <shapr> athan: although that means I usually get less than a gig of RAM and have to optimize for low memory usage
09:42:04 <kgadek> yes, I know the difference b/w GHC & haskell-platform :)
09:43:39 <athan> shapr: That's okay, so you're compiling from your development machine and deploying the binary?
09:44:32 <athan> kgadek: Hold on, let me investigate a little... :)
09:44:47 <kgadek> athan: ok, thanks :)
09:47:32 <athan> kgadek: Did you follow any guides? I know that there are a lot of dependencies that need to be installed like libgmp and a happy/alex, have you been following any guides? (I know the LICENSE file was just missing, but let's be thorough ;) )
09:49:11 * hackagebot hsexif 0.5.0.2 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.5.0.2 (EmmanuelTouzery)
09:49:33 <kgadek> athan: not guide, only https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart . Also the ~/.ghc78 I got there was compiled from source. Give me a sec, I'll rerun ./configure and dump it…
09:50:57 <kgadek> athan: https://www.evernote.com/shard/s204/sh/9b99bf5c-0b2e-4051-ae68-ca68ca1c0ef1/d3ffa91e43768d87e7d03bd85e1825c6
09:52:41 <averell> how long is the build time for ghc on an average i7 say?
09:53:43 <athan> kgadek: man, that's weird...
09:53:47 <athan> averell: I've always had to give it a day :/
09:54:07 <Lutin`> averell: I suggest building on /tmp if you have the memory
09:54:10 <rwbarton> averell: depends on build settings, but around 15-30 minutes assuming you have several cores to run it on
09:54:11 * hackagebot xmobar 0.21 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.21 (JoseAntonioOrtegaRuiz)
09:54:15 <Lutin`> Removes a lot of the IO bottleneceks
09:56:58 <Lutin`> averell: Here are some tips on speeding up build times if looking to hack on GHC
09:56:59 <Lutin`> https://ghc.haskell.org/trac/ghc/wiki/Building/Using#HowtomakeGHCbuildquickly
09:57:50 <athan> kgadek: I've never seen that... is there a license file under the source you downloaded..? o.o
09:58:14 <athan> kgadek: Sorry man, I'm going to split right now, but I'll be back on later if you still haven't solved this
09:58:28 <kgadek> athan: yeah… anyway, just heard that there's a possibility that 7.8.0 is unable to build 7.8.2… I'm giving that a shot
09:58:45 <kgadek> I'll leave a note to you if you're interested
09:58:56 <athan> kgadek: I definitely wouldn't, I think they messed up some stuff with that release haha
09:59:03 <athan> definitely!
09:59:17 <athan> I compiled it fine with 7.6.2
10:10:15 <benzrf> :t fix $ \rec v -> rec v
10:10:16 <lambdabot> t -> t1
10:10:36 <benzrf> :t fix ($)
10:10:37 <lambdabot> a -> b
10:10:40 <benzrf> cool
10:11:05 <benzrf> > fix f
10:11:06 <lambdabot>  No instance for (GHC.Show.Show a0)
10:11:06 <lambdabot>    arising from a use of ‘M607652250296160496214866.show_M6076522502961604962...
10:11:06 <lambdabot>  The type variable ‘a0’ is ambiguous
10:11:06 <lambdabot>  Note: there are several potential instances:
10:11:06 <lambdabot>    instance [safe] GHC.Show.Show
10:11:09 <benzrf> dang
10:11:12 <benzrf> :t f
10:11:13 <lambdabot> FromExpr a => a
10:11:47 <pchiusano> is it possible to disable orphan instance warnings just for a single module?
10:12:31 <pchiusano> without disabling them for all modules?
10:13:04 <rwbarton> {-# OPTIONS_GHC -fno-warn-whatever #-} ?
10:13:06 <jkarni> pchiusano: {-# OPTIONS_GHC -fno-warn-orphans #-} in the module doesn’t work?
10:13:49 <pchiusano> jkarni: ah, it does!
10:13:55 <pchiusano> i did not know about that syntax
10:14:00 <pchiusano> thanks!
10:14:31 <jkarni> pchiusano: no problem!
10:15:25 <c_wraith> :t fix . const
10:15:26 <lambdabot> c -> c
10:16:35 <koala_man> zq: sorry, it's my first haskell project :(
10:19:13 * hackagebot synthesizer-dimensional 0.7.0.2 - Audio signal processing with static physical dimensions  http://hackage.haskell.org/package/synthesizer-dimensional-0.7.0.2 (HenningThielemann)
10:20:55 <danilo2> Hello! I'm trying to write my own preprocessor for GHC (using -pgmF option as suggested by c_wraith and bergmark) but I want this preprocessor to take place only when my own LANGUAGE pragma is found. unfortunetally it seems ghc is parsing the pragmas before running preprocessor, which results in compilation error. Is there any wya to oit this behaviour?
10:20:56 <path[l]> I have a question. If I write a function that takes an “a” and is a property. Is it possible for me to quickcheck it for a particular type of ‘a'
10:23:00 <c_wraith> danilo2: you can use an OPTIONS_GHC pragma to set it to only happen in certain files, but it might always happen after the CPP pass - I'm not sure
10:23:51 <danilo2> c_wraith: ok, thank you :)
10:24:14 * hackagebot yaml-rpc 1.0.2 - Simple library for network (HTTP REST-like) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-1.0.2 (IlyaPortnov)
10:24:16 * hackagebot yaml-rpc-scotty 1.0.2 - Scotty server backend for yaml-rpc  http://hackage.haskell.org/package/yaml-rpc-scotty-1.0.2 (IlyaPortnov)
10:24:37 <danilo2> c_wraith: it does not work as I want, but I think there is no such solution I want. Anyway - I can make a workaround for it, not so pure, but it will work :)
10:27:49 <path[l]> I’ve written foo :: a -> Property, but it looks like I have to write out fooWithInt :: Int -> Property, and fooWithString :: String -> Property. Is there no way I can quickCheck foo (where a is Int) directly?
10:28:59 <c_wraith> path[l]: GHC has to know which type you mean in order to select the correct instance
10:29:22 <c_wraith> path[l]: you could write quickCheck (foo :: Int -> Property), for instance
10:29:27 <path[l]> ooh ok
10:29:29 <path[l]> yeah that works
10:30:53 <path[l]> c_wraith:  thanks, thats what I wanted :)
10:31:15 <jamiehannaford> If I have a function battle :: Battlefield -> Rand StdGen Battlefield, how can I execute `battle' n amount of times so that the result is a list of Rand StdGen Battlefield ?
10:31:47 <c_wraith> jamiehannaford: would Rand StdGen [Battlefield] as the result type work for you?
10:32:17 <c_wraith> jamiehannaford: I suspect that type is actually more useful for you - it's also easier to generate
10:32:20 <ajcoppa> i'm guessing the result of the nth invocation should depend on the result of the n-1th invocation, right?
10:32:38 <ajcoppa> like, the changes to the first battlefield as a result of the first battle need to be taken into account when running the second battle
10:32:50 <c_wraith> Oh, I see
10:32:52 <jamiehannaford> c_wraith yes, that's fine - I was going to use sequence on the list anyway
10:33:20 <c_wraith> :t foldr (<=<) return
10:33:21 <lambdabot> Monad m => [b -> m b] -> b -> m b
10:33:34 <c_wraith> :t \n -> foldr (<=<) return . replicate n
10:33:35 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
10:33:52 <c_wraith> Oh, that doesn't give you the intermediate results
10:34:15 * hackagebot graphics-drawingcombinators 1.5 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.5 (LukePalmer)
10:37:15 <benzrf> mmorph is intristing
10:37:25 <benzrf> just when i think i understand monads x.x
10:37:53 <c_wraith> :t \n f x -> sequence . map ($ x) . take n $ iterate (<=< f) return -- jamiehannaford this would work, but it's needlessly wasteful.  I think to get proper sharing, you just need to write it out recursively.
10:37:54 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m [a]
10:38:25 <jamiehannaford> replicateM might do it
10:38:52 <c_wraith> It's not quite right, either
10:39:15 * hackagebot synthesizer-midi 0.6.0.2 - Render audio signals from MIDI files or realtime messages  http://hackage.haskell.org/package/synthesizer-midi-0.6.0.2 (HenningThielemann)
10:40:14 <kgadek> @tell athan re "the missing LICENSE file" issue: GHC 7.6.3 has built the 7.8.2 successfully… so yeah, that was apparently a problem with 7.8.0
10:40:14 <lambdabot> Consider it noted.
10:40:45 <athan> kgadek: Sorry I wasn't more of help! :)
10:41:22 <kgadek> thanks anyway :)
10:42:00 <c_wraith> :t let f g x n | n == 0 = return [] | otherwise = do { x' <- g x ; xs <- f g x' (n - 1) ; return (x':xs) } in f -- jamiehannaford: this is the simplest form I can come up with
10:42:01 <lambdabot> (Num a, Monad m, Eq a) => (t -> m t) -> t -> a -> m [t]
10:42:29 <jamiehannaford> c_wraith thanks :) I'll keep on playing around with this exercise
10:42:34 <c_wraith> jamiehannaford: it's certainly possible to make it shorter, but that works.
10:42:59 <athan> kgadek: No prob haha. Is this your first time using 7.8.x (a lot, I mean?)
10:43:42 <kgadek> well, for quite a long time I had it installed and used that but no big programming involved
10:45:25 <bennofs> Is there any data type that has more than 1 possible Monad instance?
10:45:41 <codesoup> when using smart constructors and views, is there a standard naming convention for how the real/smart/view constructors should be named?
10:45:42 <c_wraith> bennofs: [] does
10:46:06 <johnw> c_wraith: what does the other one do?
10:46:10 <bennofs> c_wraith: what is the alternative to the "standard" instance?
10:46:29 <c_wraith> bennofs: it's a diagonalization, the same as a Stream instance would look.
10:46:39 <dspies> Hi, I'm having trouble with accelerate
10:46:45 <dspies> Can anyone help?
10:46:48 <dspies> http://lpaste.net/106746
10:47:02 <rwbarton> bennofs: Writer Int
10:47:20 <bennofs> rwbarton: hmm right, didn't think of that :)
10:47:26 <rwbarton> you can pick many different monoid structures on Int, and they give you different Monad instances for Writer Int
10:47:53 <michaelochurch> Hi. Noob here.
10:48:02 <benzrf> michaelochurch: hi. intermediate here
10:48:04 <c_wraith> michaelochurch: cool.  we were all noobs once. :)
10:48:17 <michaelochurch> ~5 years Clojure, decided to get deep into Haskell.
10:48:26 <michaelochurch> and ~1.5 year OCaml.
10:48:27 <benzrf> michaelochurch: good choice :3
10:48:32 <michaelochurch> so far I like it a lot
10:48:39 <benzrf> \o/
10:48:44 <c_wraith> 5 years in Clojure?  You got into it pretty early, didn't you?
10:48:47 <dspies> Does anyone here know accelerate?
10:48:50 <michaelochurch> yeah, late 2008
10:49:09 <johnw> dspies: I think it may have to do with your use of 'succ' there
10:49:13 <johnw> but I don't know accelerate
10:49:36 <michaelochurch> c_wraith: and I spent 6 months doing C++ at Google but don't talk about that.
10:49:50 <rwbarton> I also don't know accelerate but maybe try count + 1?
10:49:56 <c_wraith> michaelochurch: it's ok, I learned to program in Coco2 BASIC. :)
10:49:57 <michaelochurch> c_wraith: and then some Scala, which is great to write but *reading* other people's Scala...
10:50:04 <michaelochurch> rwbarton: are you Reid?
10:50:09 <rwbarton> yep
10:50:14 <dspies> johnw: You were right, I changed it to (count + 1) and it worked
10:50:22 <michaelochurch> rwbarton: What've you been up to of late?
10:50:33 <dspies> how did you guess that
10:50:50 <michaelochurch> rwbarton: it must have been 15 years (MOP 1999) since I've seen you. How've you been?
10:50:51 <bennofs> c_wraith: does that also form a monad if you allow finite lists?
10:50:54 <dspies> johnw: or rather, how can I find things like that out in the future
10:51:21 <c_wraith> bennofs: I..  think I've heard that it does, but I don't recall for sure.  I never worked it out myself.
10:51:49 <johnw> dspies: succ is based on the Enum typeclass, for which GHC was saying no instance existed for the value you were trying to manipulate
10:52:24 <rwbarton> michaelochurch: oh, hi!
10:52:28 <donri> i think it's saying the instance is there, but the method not defined
10:52:40 <donri> why else an exception not a type error
10:52:50 <donri> though weird message "no instance"
10:53:23 <dspies> johnw, donri: yeah, it happens at runtime, not compile-time
10:54:01 <bernalex> who's the lpaste guy?
10:54:04 <jamiehannaford> what's the best way of dividing the length of a list (Int) by an Integer to get a float? i.e. 1000 / (length a)
10:54:18 <donri> bernalex: chrisdone
10:54:25 <bernalex> donri: ah. thought so.
10:54:32 <RchrdBrrll> jamiehannaford, 1000 / fromIntegral (length a)
10:55:19 <jamiehannaford> thanks! :)
10:56:49 <RchrdBrrll> No problem.
10:59:55 <mmmm_> Anyone know if there's already a good unicode -> ASCII transliteration library?
11:00:48 <donri> wouldn't that be a lossy operation?
11:01:36 <mmmm_> Yes but it's better than having unrepresentable characters
11:01:55 <benzrf> mmmm_: why is this necessary?
11:02:20 <mmmm_> because pdflatex doesn't read unicode
11:02:28 <benzrf> mmmm_: u wot
11:02:50 <benzrf> mmmm_: it doesnt handle any encodings?
11:03:03 <mmmm_> Not that well
11:03:08 <donri> concrete data is always encoded :)
11:03:37 <benzrf> donri: stop being pedantic
11:03:39 <benzrf> fine
11:03:42 <donri> :)
11:03:51 <benzrf> IT DOESNT PROPERLY INTERPRET ANY UNICODE ENCODINGS AS CODE POINTS
11:04:13 <donri> there's text-icu and ghc's encoding system
11:05:04 <donri> which is most conveniently used via text-locale-encoding
11:05:42 <mmmm_> text-icu just normalises the unicode but doesn't have ascii mappings I thought?
11:06:09 <Clint> why did you think that
11:06:28 <mmmm_> because I read the documentation
11:06:34 <mmmm_> and that's what I thought
11:06:41 <Clint> http://hackage.haskell.org/package/text-icu-0.6.3.7/docs/Data-Text-ICU-Convert.html
11:08:43 <PragCypher> are there any examples of packages using detialed-1.0 for testing?  Or is it not being used?  All of the ones I've found so far use exitcode-stdio
11:09:31 <Eva> hello
11:09:44 <johnw> what does detailed-1.0 even do?
11:11:06 <PragCypher> its used in for the 'type' parameter in .cabal files
11:11:26 <Exio4> a random question, if i do something like http://dpaste.com/1AW7KQ8, would ghc optimize the second call? (and call terr' once)?
11:15:08 <johnw> check the Core that is generated
11:15:18 <johnw> but I don't think so
11:17:13 <danilo2> Hello! Is it possible somehow to use -pgmF with runhaskell?
11:18:11 <PragCypher> danilo2: runhaskell is just a wrapper for ghc i believe
11:18:25 <rwbarton> Exio4: this is where it's useful that where scopes over a set of guards
11:18:29 <danilo2> PragCypher: no, its wrapper for runghc
11:18:43 <c_wraith> danilo2: which is still a wrapper for ghc
11:19:02 <geekosaur> did you note that -pgmF requires -F?
11:19:37 <danilo2> PragCypher, c_wraith: hmm, strange, because "ghc -F -pgmf preprocessor.py Main.hs" works, whenever "runhaskell -F -pgmf preprocessor.py Main.hs"
11:19:38 <geekosaur> although I am not sure how that interacts with pragmas since ghc is already reading the file at that point
11:19:54 <geekosaur> I think it needs something else to pass options to ghc
11:19:56 <danilo2> PragCypher, c_wraith: *does not
11:20:05 <geekosaur> because runhaskell/runghc also has its own options
11:20:23 <c_wraith> danilo2: doesn't mean the wrapper script passes the options you provide through to GHC
11:21:15 <c_wraith> danilo2: anyway, if you want it to work with runhaskell/runghc, I'd really tend towards using an OPTIONS_GHC pragma
11:21:32 <c_wraith> danilo2: unless you only want it to happen conditionally, I guess.
11:21:40 <danilo2>  PragCypher, c_wraith: oh! I found the solution! It works if we put no whitespace after the -pgmF option!
11:22:02 <c_wraith> ah
11:23:08 <danilo2> c_wraith: hmm, but with OPTIONS_GHC I would need to put the -pgmF option per file - am I right?
11:23:54 <geekosaur> yes
11:24:04 <c_wraith> danilo2: it's true, you would.  It's useful when you only want to preprocess specific files, rather than all of them
11:24:59 <danilo2> c_wraith: ok, now I;ve got the perfect solution :) Thnak you very much for the help! :)
11:29:44 <donri> danilo2: -optF
11:31:55 <Marquis> hello haskellers. Is here anybody who is familiar with the fgl raph Library?
11:31:58 <mmmm_> Thanks for your suggestion Clint but text-icu doesn' try to approximate as far as I can see
11:33:13 <benzrf> Marquis: i used it once
11:33:16 <benzrf> "used it"
11:33:34 <benzrf> Marquis: i copied an SO answer to convert something isomorphic to a rose tree into an fgl grah
11:33:38 <benzrf> *graph
11:33:44 <Marquis> i would like to use it too, but i dont understand a thing
11:33:45 <benzrf> thats the depth of my experience
11:33:57 <benzrf> Marquis: it seems pretty fucking inconvenient from what ive seen of it
11:33:57 <benzrf> >:o
11:34:02 <benzrf> Marquis: whats your problem?
11:34:12 <Marquis> i just want to add nodes and edges to a graph, pretty simple stuff. then compute the shortest path
11:34:28 <Marquis> but i dont know how to start
11:34:49 <c_wraith> Well - start by building the graph. :)
11:34:57 <Marquis> i just need some good sample code where you put node a and b into the graph and an edge between them
11:35:07 <donri> danilo2: btw you know it's -pgmF not -pgmf?
11:35:10 <c_wraith> Marquis: http://web.engr.oregonstate.edu/~erwig/fgl/haskell/old/fgl0103.pdf might be of interest
11:35:43 <hooplahoops> How can I say "I'll some some text-like thing" and operate on that? I'm currently defining a custom typeclass "TextLike", and constraining the input variable, is that a bad sign?
11:35:46 <Marquis> thanks wraith, i read it, but was not able to get anything done :(
11:35:48 <danilo2> donri: yes! It really works only if I do not put space there in "runhaskell" . In ghc it works both ways
11:36:12 <donri> danilo2: odd. have you tried it with runghc?
11:36:22 <danilo2> donri: yes, the same result
11:37:06 <hooplahoops> It seems a little weird to "commit" to either String, Text or one of the bytestring variants. How do you typically deal with this in a satisfying manner?
11:37:06 <luqui> hooplahoops: how is "text-like thing" different than Text or String?
11:37:17 <donri> danilo2: sounds like a bug? file a ticket!
11:37:24 <hooplahoops> luqui: it isn't, those are instances of TextLike
11:37:37 <luqui> hooplahoops: there are two options
11:37:46 <danilo2> donri: I'm doing it for couple of minutes right now - I want to prepare a nice example :)
11:37:53 <luqui> (1) make a typeclass including the parts of text-like that you need, or (2) commit to one of them.
11:38:03 <luqui> often (2) is better than you'd think, depending on the algorithm
11:38:04 <donri> danilo2: \o/
11:38:06 <danilo2> donri: but I have to do sthng now - I'll file it today and If you want, I'll send you a link to it :)
11:38:06 <hooplahoops> luqui: right, ok
11:38:19 <donri> danilo2: no need
11:38:25 <luqui> i.e. if you're processing character-by-character, you might as well just use String
11:38:26 <danilo2> donri: :)
11:38:30 <luqui> and let the user convert
11:38:30 <hooplahoops> luqui: yeah, so the thing is that I'm trying to design a new model, and it feels like String or Text is right
11:38:43 <hooplahoops> luqui: but I know that some other moudle which is going to use it is using ByteString
11:39:16 <shapr> !seen TheHunter
11:39:19 * shapr is sad
11:39:34 <chrisdone> donri!
11:39:45 * chrisdone gives shapr a cup of happiness juice
11:40:03 * chrisdone sploshes it in his face, "wake up! the raptors are coming!"
11:40:23 <shapr> chrisdone: now that's motivation!
11:40:41 <luqui> hooplahoops: what kinds of manipulations do you intend to do with the text-like-thing?
11:40:52 <c_wraith> Marquis: so what part are you having trouble with?
11:40:56 <shapr> chrisdone: My next Haskell website will be a travel agency for dinosaurs. TRAVELOCIRAPTOR!
11:40:59 <donri> hooplahoops: the trick is to know what encoding the consumer will be expecting
11:41:04 <shapr> luqui: howdy! How's code?
11:41:05 <chrisdone> shapr: lol
11:41:48 <michaelochurch> shapr: Dinosaurs have assistants and expense accounts. You learn how to negotiate one in MBA school.
11:42:12 <luqui> shapr: eh.. complicated
11:42:18 <luqui> shapr: howdy. longtime
11:42:24 <hooplahoops> luqui: I really just need to parse it, but inherently unstructured (just from the socket or file)
11:42:33 <Marquis> in the example code the run_ monad (?) is used, but i am not familiar with monads and would like to just use the insNode and insEdge functions
11:42:43 <shapr> luqui: well, I hope it gets simpler!
11:44:10 <Exio4> i checked the core, it seems it applies the function a single time
11:44:13 <Nik05> Hello, is there an untilM an until that works for monads? Hoogle doesnt find it
11:44:23 <chrisdone> perhaps in monad-loops
11:44:26 <chrisdone> @hackage monad-loops
11:44:26 <lambdabot> http://hackage.haskell.org/package/monad-loops
11:44:40 <Iceland_jack> yup it's in monad-loops
11:44:41 <luqui> hooplahoops: oh, you want to parse from socket?  using parser combinators?
11:44:46 <Iceland_jack> I guess you could find it with this as well
11:44:46 <Iceland_jack> @google 'untilM' hackage
11:44:47 <lambdabot> http://hackage.haskell.org/package/monad-loops-0.3/docs/Control-Monad-Loops.html
11:44:47 <lambdabot> Title: Control.Monad.Loops
11:45:34 <luqui> shapr: how's haskell-land.  I've been out of the community for a while, as you seem to have noticed
11:45:57 <hooplahoops> luqui: kind of, I'm parsing CSV and I need to know the type of a column
11:46:02 <Itkovian> any idea if bootstrapping cabal-install 1.20.0.2 is supposed to work?
11:46:14 <hooplahoops> luqui: so I'm taking a sample and then I want to see whether it parses as an Int, Float etc
11:46:31 <shapr> luqui: me too, so not much to say.
11:46:43 <Nik05> ok thank you
11:46:45 <hooplahoops> luqui: I'm already stuck there, because 'read' throws exceptions (I'm trying to write as little new code as possible)
11:46:47 <Itkovian> hi shapr
11:46:52 <shapr> hoi Itkovian!
11:47:02 <Nik05> why doesnt hoogle in all hackage packages?
11:47:12 <Nik05> *insert search
11:47:54 <luqui> maybeRead = fmap fst . listToMaybe . reads
11:48:02 <MagnusVortex> Good day!
11:48:48 <Iceland_jack> Good day MagnusVortex
11:49:05 <luqui> hooplahoops: ah.  that doesn't seem too heavy, and you only need the initial bit of the text, so String's laziness might do you well
11:49:26 <slomo> is there a "locale" package somewhere? old-locale (as used by e.g. time) suggests that it's an old version of something
11:49:27 <hooplahoops> luqui: ok I'll roll with that, thanks!
11:51:00 <wavewave> @djinn a -> b -> a
11:51:00 <lambdabot> f a _ = a
11:51:11 <wavewave> @djinn a -> (a -> b) -> b
11:51:11 <lambdabot> f a b = b a
11:51:42 <wavewave> @djinn a -> (a -> (a ->b)) -> b -> a
11:51:42 <lambdabot> f a _ _ = a
11:51:55 <Nik05> ok i dont get which function i should use from Monad.Loops. I got a function a -> m a, a predicate (a -> Bool), and a starting a
11:54:57 <luqui> Nik05: yeah I don't see one that fits what you have well
11:55:29 <jle`> Nik05: how about unfoldM?
11:55:40 <luqui> :t unfoldM
11:55:41 <lambdabot>     Not in scope: ‘unfoldM’
11:55:41 <lambdabot>     Perhaps you meant one of these:
11:55:41 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
11:56:04 <jle`> if you use (\x -> if p x then Just x else Nothing)
11:56:09 <jle`> or
11:56:23 <jle`> mfilter . Just
11:56:30 <jle`> er, mfilter p . Just
11:56:41 <jle`> to turn your (a -> m a) into an (a -> m (Maybe a))
11:57:00 <luqui> unfoldM :: Monad m => m (Maybe a) -> m [a]
11:57:01 <jle`> then you can use unfoldM to keep on producing values until you get a Nothing
11:57:04 <jle`> oh
11:57:08 <jle`> really?
11:57:12 <luqui> right?
11:57:30 <luqui> There's nothing "iterate"-like it seems
11:57:37 <Nik05> hm why are they using Maybe and not a Bool?
11:57:50 <jle`> it's parallel to unfoldr in Data.List
11:57:59 <jle`> yeah, i've consistently had to write my own iterateM-like functions
11:58:15 <jle`> unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
11:58:45 <jle`> that might do it
11:59:39 <johnw> there are several variants of iterateM in monad-extras
11:59:40 <jle`> if you fmap (mfilter p . Just . join (,)) to your resulting m a
11:59:52 <johnw> http://hackage.haskell.org/package/monad-extras-0.5.8/docs/Control-Monad-Extra.html
11:59:53 <jle`> johnw: really?
11:59:58 <jle`> that changes everything :|
12:00:06 <johnw> iterateM, lazyIterateM, iterateMaybeM
12:00:11 <jle`> omg they have discard
12:00:21 <jle`> why isn't discard in Control.Monad
12:00:30 <johnw> in 7.10, discard will be meaningless
12:00:39 <johnw> since void's Functor constraint will be satisfied by any Monad
12:00:50 <jle`> well for now
12:00:55 <jle`> ah.
12:01:07 <jle`> it would have been useful to me in many situations in the past
12:01:15 <jle`> but i guess it's silly to add it in at this point only to take it out later
12:01:20 <jle`> and be backwards incompatible
12:01:41 <jle`> liftMaybe :: MonadPlus m => Maybe a -> m a
12:01:43 <jle`> genius
12:02:21 <johnw> yeah, these are all functions I've implemented numerous times
12:02:23 <jle`> wish i had known about this a long time ago
12:02:25 <johnw> finally decided to package them
12:02:41 <jle`> who is behind this
12:02:45 <jle`> oh, it's you
12:02:47 <johnw> me and chrisdone
12:02:49 <jle`> :)
12:02:54 <jle`> thank you, on behalf of the world
12:03:07 <johnw> sure!  and if you have candidates for inclusion, let me know
12:03:11 <Nik05> sorry im back, was bleeding all over my keyboard
12:03:21 <johnw> did you install openssl or something?
12:03:27 <Nik05> :)
12:03:42 <jle`> johnw: will do
12:10:22 <tnks> interesting to read that Ed isn't a fan of Prelude hiding.
12:10:42 <johnw> Ed isn't a fan of Emacs either, so now I suspect him in all things ;)
12:11:23 <tnks> Ed made two arguments:  1) it's a hassle . . . which leads to 2) it may impede adoption
12:11:32 <spacebug> tnks: link? or is it on haskell-cafe?
12:11:38 <tnks> spacebug: http://comments.gmane.org/gmane.comp.lang.haskell.libraries/22265
12:11:40 <tnks> that's some of it.
12:11:49 <tnks> I'm sure it's also in other places.
12:12:02 <spacebug> tnks: thanks
12:16:29 <Nik05> ok i think i just implemented my own untilM in 3 lines :)
12:16:32 <jle`> woo hoo i made my first prism
12:17:17 <Nik05> http://lpaste.net/106756
12:17:28 <benzrf> jle`: swag
12:17:35 <benzrf> :t untim
12:17:36 <lambdabot>     Not in scope: ‘untim’
12:17:36 <lambdabot>     Perhaps you meant ‘until’ (imported from Prelude)
12:17:48 <corgifex> what's untilM'?
12:18:04 <jle`> @let _uncons = prism (uncurry (:)) (\x -> case x of (y:ys) -> Right (y,ys); [] -> Left x)
12:18:05 <lambdabot>  Defined.
12:18:13 <Nik05> untilM' :: (Monad m, MonadPlus f) => m a -> m Bool -> m (f a)
12:18:28 <chrisdone> huh
12:18:34 <chrisdone> the argument order is weird
12:18:47 <jle`> > [1,5,2] & _uncons %~ \(h,t) -> (h*3, h:t ++ [10])
12:18:49 <lambdabot>  [3,1,5,2,10]
12:19:01 <jle`> > [] & _uncons %~ \(h,t) -> (h*3, h:t ++ [10])
12:19:03 <lambdabot>  []
12:19:10 <jle`> a minor achievement for the day
12:19:27 <zq> .lastlog zq
12:19:40 <zq> oy i feel bad now
12:19:42 <chrisdone> jle`: congrats. what does it do?
12:20:40 <Nik05> chrisdone of what?
12:21:02 <chrisdone> Nik05: untilM'
12:21:06 <Nik05> 21:17 < chrisdone> the argument order is weird
12:21:16 <tnks> as much as I never thought I'd buck advice from Ed. . . I think I do want to hide Prelude.
12:21:17 <Nik05> sorry, yes :P
12:21:27 <jle`> chrisdone: idk
12:21:29 <Nik05> all monadic functions have a strange order
12:21:39 <jle`> chrisdone: oh it's a prism over a list as a tuple of the head and the tail
12:21:40 <Nik05> >>= is also inconsistent
12:21:44 <tnks> just not sure about the difference between "import Prelude ()" and the NoImplicitPrelude extension.
12:22:04 <hiptobecubic> instances maybe?
12:22:29 <c_wraith> yes, instances
12:22:37 <jle`> chrisdone: was just thanking johnw for monad-extras btw, and i pretty sure you're involved too.  thanks for it
12:22:39 <jle`> good work
12:23:15 <Nik05> oh corgifex sorry in my paste i got untilM', sorry thats a typo
12:23:43 <jle`> hm lens people is there any way to access the (b -> t) part of a prism
12:24:21 <jle`> like view accesses the (s -> a) part of a lens
12:24:28 <Itkovian> I am trying to build packages using ghc-7.8.2, and every time Setup complains it cannot find a package, though I know it is there, as it is being shown by ghc-pkg
12:24:28 <Itkovian> any pointers?
12:24:59 <cococo> What are some examples of large products/companies using Haskell in production?
12:25:10 <supki> jle`: review
12:25:11 <jle`> cococo: imvu i guess
12:25:23 <jle`> > review uncons (1,[2,3])
12:25:25 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe
12:25:25 <lambdabot>                         (a1,
12:25:25 <lambdabot>                          Data.Tagged.Tagged a0 (Data.Functor.Identity.Identit...
12:25:25 <lambdabot>                with ‘Data.Tagged.Tagged s0 (Data.Functor.Identity.Identity t)’
12:25:25 <lambdabot>  Expected type: Control.Lens.Review.AReview s0 t a0 (t0, [t1])
12:25:27 <jle`> > review _uncons (1,[2,3])
12:25:28 <lambdabot>  can't find file: L.hs
12:25:30 <jle`> > review _uncons (1,[2,3])
12:25:32 <lambdabot>  [1,2,3]
12:25:34 <jle`> oh neat
12:25:45 <jle`> thanks supki
12:26:14 <jle`> review is like a .... co-view
12:26:17 <tolt> cococo: We aren't extremely large or anything but we do nothing but haskell/javascript (frontend) for automation/data logging
12:27:43 <benzrf> but + will not do thjt
12:27:59 <chrisdone> cthulhu thjt'gn
12:28:05 * chrisdone chants
12:28:07 <Pythonfant> Is there something like (a, m b) -> m (a, b)
12:28:10 <cococo> Surprised Imvu is still a thing, let alone using something as "hip" as Haskell
12:28:13 <chrisdone> > cycle "cthulhu"
12:28:14 <lambdabot>  "cthulhucthulhucthulhucthulhucthulhucthulhucthulhucthulhucthulhucthulhucthul...
12:28:14 <jle`> Pythonfant: strong, right?
12:28:19 <johnw> chrisdone: heya!
12:28:19 <jle`> er, strength
12:28:28 <chrisdone> johnw: ayeh!
12:28:34 <cococo> tolt: what do you do?
12:28:38 <tolt> Pythonfant: Wouldn't that be Sequence in traversable?
12:28:38 <tolt> (Maybe. It's close.)
12:29:27 <tolt> cococo: A lot of automation for oil fields, water treatment, etc. (or do you mean what do I specifically do?)
12:29:37 <benzrf> j
12:29:38 <Pythonfant> jle`: strength?
12:30:01 <albeit> If I'm configuring a server to be used with some soft real-time Haskell programs, should I be looking at more cores at a lower clock or fewer cores at a higher clock? Or does it matter with Haskell?
12:30:04 <benzrf> jle`: wrong
12:30:05 <Pythonfant> tolt: not quite sure, to be more precise I have something like (1, Just 3) and want to get Just (1,3) or in case of nothing Nothing
12:30:07 <benzrf> strength is different
12:30:10 <jle`> benzrf: :'(
12:30:20 <benzrf> Pythonfant: you want something like
12:30:33 <benzrf> um
12:30:34 <cococo> tolt: that's what I was looking for, thanks. Just trying to understand where Haskell is being used today (though I know it's still a relatively new language)
12:30:35 <benzrf> crap 1 sec
12:30:45 <benzrf> Pythonfant: do-notation is useful for this
12:30:51 <jle`> http://comonad.com/reader/2008/deriving-strength-from-laziness/
12:31:04 <jle`> strength :: (m a, b) -> m (a, b)
12:31:07 <jle`> so i got it backwards
12:31:08 <c_wraith> cococo: the first version of the language spec was released in about 1990.  It's older than java. :P
12:31:09 <benzrf> jle`: oh
12:31:13 <jle`> :(
12:31:15 <benzrf> i coulda sworn...
12:31:49 <benzrf> Pythonfant: in general 'sequenceA' tends to be good for 't (f a) -> f (t a)'
12:31:52 <jle`> strength fa b = fmap (,b) fa
12:31:55 <benzrf> > sequenceA (1, Just 3)
12:31:57 <lambdabot>  Not in scope: ‘sequenceA’
12:31:57 <lambdabot>  Perhaps you meant one of these:
12:31:57 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
12:31:57 <lambdabot>    ‘sequence’ (imported from Control.Monad.Writer),
12:31:57 <lambdabot>    ‘T.sequence’ (imported from Data.Traversable)
12:32:00 <benzrf> > T.sequenceA (1, Just 3)
12:32:02 <lambdabot>  Just (1,3)
12:32:08 <cococo> c_wraith: oh whaaat. Well it seems to be rising in popularity lately.
12:32:17 <benzrf> Pythonfant: most built in applicagtives have Traversable instances
12:32:29 <corgifex> we have failed to avoid success
12:32:33 <c_wraith> cococo: that much is true.
12:32:34 <tolt> cococo: standard chartered uses it a lot. Thats a pretty large company. There's a podcast with Don Steward that talks about that a lot.
12:32:47 <c_wraith> tolt: *Stewart
12:32:51 <jle`> > let strength fa b = fmap (,b) fa in flip strenth (1, Just 3)
12:32:52 <lambdabot>  Not in scope: ‘strenth’
12:32:52 <lambdabot>  Perhaps you meant ‘strength’ (line 1)
12:32:56 <jle`> > let strength fa b = fmap (,b) fa in flip strength (1, Just 3)
12:32:57 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:32:57 <lambdabot>    arising from a use of ‘M149617855711904003217289.show_M1496178557119040032...
12:32:57 <lambdabot>  The type variable ‘a0’ is ambiguous
12:32:57 <lambdabot>  Note: there are several potential instances:
12:32:57 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:33:14 <jle`> oh yeah i forgot to uncurry
12:33:30 <tolt> Sorry. yeah. Thanks c_wraith.
12:33:54 <c_wraith> tolt: normally I wouldn't care about small typoes outside of code, but it *is* a guy's name.  And I've met him, he's a nice guy. :)
12:34:14 <c_wraith> *typos.  I make plenty of my own. :)
12:34:24 <tolt> c_wraith: I agree. I knew it was Stewart. I was just semi-distracted.
12:34:46 <prototrout> In ghci is there a way to see what classes a type synonym is an instance of? For `data' declarations I can do :info to see that, but not for `type's.
12:35:29 <Luke> bergmark: doesn't aeson already have support for GHC.Generics? Why have the generic-aeson package?
12:35:31 <jle`> > let strength fa b = fmap (,b) fa in uncurry strength (Just 3, 1)
12:35:33 <lambdabot>  Just (3,1)
12:35:51 <jle`> but if your thing is on the right then the applicative instance of (,) a is probably the better wy ;)
12:35:57 <dwcook> prototrout, try using :info on the outermost type on the right-hand side of the type equation.
12:35:58 <bergmark> Luke: different serialization format
12:36:06 <jle`> or well\~
12:36:09 <enthropy> prototrout: you can do :info a few times and eventually you'll get to an actual data type
12:36:12 <Luke> bergmark: is the difference documented anywhere?
12:36:20 <jle`> it's the better way in either case because i don't think strength is in any library
12:36:21 <jle`> how odd
12:36:36 <Luke> bergmark: also docs aren't generating for the json-schema package
12:37:08 <prototrout> Thanks dwcook and enthropy; it's not a lot of effort but I was just curious ifthere was a way to have that done automatically.
12:37:17 <bergmark> Luke: i don't know what aeson's built in generics look like (this package originated from the time before aeson)
12:37:42 <Luke> bergmark: might be nice to consolidate them
12:37:46 <Pythonfant> jle` & benzrf: thx
12:37:56 <bergmark> Luke: i'm not that familiar with aesons format, but ours is more minimalistic, you can see this test suite https://github.com/silkapp/json-schema/blob/master/tests/Main.hs
12:38:15 <bergmark> Luke: we can't switch, that would break our apis
12:38:38 <Luke> bergmark: or aeson takes your format
12:38:45 <Luke> bergmark: don't you version your APIs?
12:39:08 <bergmark> yeah, we could switch to a new representation for new versions
12:39:21 <bergmark> but i think we are in agreement that our format is nicer
12:39:36 <Luke> bergmark: but if your representation is better why not just push that into aeson?
12:39:49 <bergmark> i think it can cause some ambiguity
12:40:09 <Luke> your type->json representation is ambiguous?
12:41:40 <bergmark> I'm not sure about this, but i think the serialization for Nothing and Just Nothing are the same
12:42:09 <Luke> hmm
12:42:19 <bergmark> which isn't a problem for us in practice, we don't nest maybes, but perhaps it's not a good default for aeson to use
12:43:30 <Luke> bergmark: well if you're not interesting in consolidating w/ aeson's built in GHC.Generics impl, maybe document the differences?
12:43:41 <Luke> it will be hard to know which to use otherwise
12:44:29 <bergmark> yeah that's a good idea
12:44:49 <michaelochurch> is > the in-channel REPL?
12:44:51 <michaelochurch> > 5 + 6
12:44:53 <lambdabot>  11
12:44:55 <michaelochurch> cool
12:44:58 <michaelochurch> > :t 5 + 6
12:44:59 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:45:03 <chrisdone> :t 5 + 6
12:45:04 <lambdabot> Num a => a
12:45:21 <bernalex> michaelochurch: you can play with lambdabot using /msg too, if you want
12:46:29 <geekosaur> ":t" doesn't use a > prefix, it is itself a prefix
12:47:31 <albeit> If I'm running a Haskell program on a computer with two processors of four cores each, and I compile with "-threaded" and run with "+RTS -N8" will it use all available cores? Or is it limited to a single processor?
12:48:15 <michaelochurch> msg didn't seem to take
12:49:21 <MP2E> albeit : 2 processors on each core? You mean hyperthreading?
12:49:31 <MP2E> it will in that case
12:50:49 <eikke__> to unsafePerformIO or not to unsafePerformIO? https://gist.github.com/NicolasT/cbb103a73cca42877a94#file-gistfile1-hs-L47
12:51:02 <c_wraith> albeit: The important part is that -N<X> determines how many OS-level threads/processes to execute on.  How those map to CPUs depends on the OS
12:51:02 <albeit> MP2E: Wrong terminology on my part probably, two separate processors/CPUs in the server, and each one has four cores.
12:51:26 <albeit> c_wraith: Ah, okay
12:53:39 <MagnusVortex> So, not being a Haskell user or well trained in mathematics, I have to say that "uncurry" made me giggle.
12:53:41 <albeit> c_wraith: Do you know how Linux/Ubuntu maps OS-level threads to the CPUs? Would it be able to take advantage of all the CPUs?
12:54:05 <eikke__> albeit: use taskset to choose for yourself
12:54:30 <c_wraith> albeit: by default, I believe it attempts to load-balance across all the available cores.
12:55:02 <RchrdBrrll> albeit, how detailed an answer do you want? Linux tries to leave no cores idle, and has a feature called "weak affinity" wherein it tries (albeit not very hard) to schedule each thread/process on the same CPU core that it was scheduled on.
12:55:43 <RchrdBrrll> If you have 12 threads all doing CPU-bound work and 12 cores, you can happily expect any modern operating system kernel to take full advantage.
12:55:50 <mgrabovsky> hello
12:56:09 <mgrabovsky> is this the friendly haskell channel?
12:56:18 <c_wraith> hi mgrabovsky.  We like to think we're friendly. :)
12:57:02 <mgrabovsky> ok, I have a beginner question
12:57:26 <mgrabovsky> ghci tells me that the type of (1 2) is `(Num (a -> t), Num a) => t`
12:57:30 <mgrabovsky> what does this mean?
12:57:36 <albeit> c_wraith RchrdBrrll: Thats detailed enough, I'll do some more research on that. Thanks!
12:57:36 <RchrdBrrll> We love beginner questions.
12:58:09 <RchrdBrrll> When you write (1 2) in Haskell, it gets parsed as the number 1 being called as a function which takes the number 2 as a parameter.
12:58:25 <RchrdBrrll> Did you mean to write a list, such as [1, 2] instead?
12:58:27 <kirkite> > (1 2)
12:58:29 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
12:58:29 <lambdabot>    arising from the ambiguity check for ‘e_112’
12:58:29 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
12:58:29 <lambdabot>    bound by the inferred type for ‘e_112’:
12:58:29 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
12:58:29 <xeno> hi, my ghc installation got cabal 1.16, while I've run cabal to upgrade and it's installed 1.20 for my user. Is this setup optimal? especially given that I would never wanna run 1.16...
12:58:29 <RchrdBrrll> or a pair, (1, 2)?
12:59:09 <RchrdBrrll> mgrabovsky, I could go into why it's talking about (Num (a -> t)) but if you're just beginning then the answer might be more detail than you really wanted.
12:59:11 <kirkite> > (1,2)
12:59:13 <lambdabot>  (1,2)
12:59:20 <mgrabovsky> I thought that it was being called
12:59:46 <mgrabovsky> I was curious about the signature, so yes please, RchrdBrrll, you can go into more detail
12:59:53 <chrisdone> “what happened to the nice vicar who was here last week?” “gone, they're all gone. banished by the bishop, and we're back.” “who?” “the horribly twisted and mean people who are still unaccountably vicars”
12:59:57 <RchrdBrrll> Cool. Okay.
13:00:25 <RchrdBrrll> :t 1
13:00:26 <lambdabot> Num a => a
13:00:43 <RchrdBrrll> The type of the expression "1" in a Haskell source file is (Num a) => a.
13:01:37 <RchrdBrrll> In English, that means that the type is, "some a, where 'a' is a kind of number".
13:02:05 <chrisdone> a type of number =p
13:02:18 <RchrdBrrll> Sorry, a numerical type.
13:02:27 <mgrabovsky> I understand that, I'm a bit familiar with typeclasses
13:02:36 <RchrdBrrll> ("kind" has a specific meaning in Haskell)
13:02:41 <dwcook> There's also sorts of kinds of types
13:02:44 <dwcook> all*
13:02:44 <RchrdBrrll> This is how Haskell implements the fact that you can use the numeric literal '1' whether you're defining an Int with the value 1 or an Integer with the value 1 or a Double or a Word32 or whatever.
13:02:57 <dwcook> Dang it my pun was ruined by a typo that made it more correct
13:04:11 <RchrdBrrll> So. When you write (1 2) in Haskell, it infers the type (Num (a -> t), Num a) => t, because...
13:04:21 <RchrdBrrll> it's inferring (Num a) for the '2'.
13:04:51 <RchrdBrrll> and it's inferring (a -> t) for the '1' because you supplied an 'a' to the '1' as an argument.
13:05:26 <mgrabovsky> ooh, I think I'm being enlightened
13:05:40 <RchrdBrrll> Haskell is really open minded about what typeclasses could exist, so it's perfectly workable that there *could* exist a Num instance for some type shaped roughly like (a -> b).
13:05:50 <c_wraith> > 1 2
13:05:52 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
13:05:52 <lambdabot>    arising from the ambiguity check for ‘e_112’
13:05:52 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
13:05:52 <lambdabot>    bound by the inferred type for ‘e_112’:
13:05:52 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
13:06:00 <RchrdBrrll> For example, you could probably define a pretty good Num instance for linear transforms.
13:06:00 <c_wraith> Nope, lambdabot doesn't have that instance these days
13:06:07 <c_wraith> Sometimes lambdabot *does* have instances like that!
13:06:27 <dwcook> instance (Num b) => Num (a -> b) where … -- ?
13:06:36 <jle`> yeah i put some in sometimes when i feel like being disruptive in a minimally annoying way
13:06:37 <RchrdBrrll> but you get an error message from it because there isn't any default Num instance that matches that shape.
13:06:59 <RchrdBrrll> since there isn't a Num instance that fits, the compiler doesn't find one, so it throws the problem back in your face. :)
13:07:12 <RchrdBrrll> mgrabovsky, do you feel that you understand, please, and would you like any part elaborated on?
13:07:43 <mgrabovsky> RchrdBrrll: I *think* I understand, but I'll ponder upon it some more,  sleep on it and maybe come back tomorrow
13:07:58 <mgrabovsky> RchrdBrrll: thank you, either way, it makes sense
13:08:03 <c_wraith> dwcook: sometimes lambdabot lets you write (sin^2 + cos^2) x  and returns something within rounding errors of 1.  :)
13:08:06 <RchrdBrrll> Cheers! ^_^
13:09:18 <dwcook> c_wraith, that does seem like it'd be handy sometimes, is there a specific reason it's not standard?
13:09:36 <c_wraith> dwcook: because people aren't used to numeric literals being functions. :)
13:09:57 <dwcook> I think even numpy does something like that, if I recall
13:09:58 <c_wraith> dwcook: and very often if they attempt to use a numeric literal as a function, it's a typo.
13:10:03 <dwcook> c_wraith, that's true.
13:10:57 <dwcook> c_wraith, it seems like one of those cases where it'd make sense for GHC to give a special suggestion
13:12:36 <enthropy> dwcook: it should suggest "f is applied to too few arguments" similar to what it currently does when you supply too many arguments?
13:13:50 <c_wraith> :t printf "%s"
13:13:50 <lambdabot> PrintfType r => r
13:13:54 <c_wraith> :t printf "%s" "foo" 5
13:13:55 <lambdabot> PrintfType t => t
13:13:57 <dwcook> enthropy, it could say that you might have accidentally done that, yeah.
13:14:04 <c_wraith> Sadly, it doesn't always know that. :)
13:14:24 <dwcook> c_wraith, if there's no relevant instance in scope
13:19:30 * hackagebot bytable 0.1.0.0 - data from/to ByteString  http://hackage.haskell.org/package/bytable-0.1.0.0 (YoshikuniJujo)
13:30:01 <jle`> scoped type signatures.  can't imagine ever wanting it to be off
13:30:44 <Iceland_jack> jle`: Sometimes I reuse basic type variables (a, b, ...) locally and they clash with the top-level signature
13:30:56 <Iceland_jack> but in general you'd want them on
13:31:44 <jle`> ah
13:31:50 <thoughtpolice> well, ScopedTypeVariables will only conflict if the top-level signature variables are quantified explicitly via 'forall', which is probably somewhat uncommon unless you *do* want to scope them anyway
13:31:54 <jle`> in that case i can just create a new local scope, right?
13:32:17 <Iceland_jack> thoughtpolice: yes that has only happened twice to me by accident, it's not really a concern
13:34:31 * hackagebot peyotls 0.0.0.1 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.1 (YoshikuniJujo)
13:37:12 <hexagoxel> ah i think i finally understand the magic for let+rec in arrow notation. only had to un-de-sugar some sample code :D
13:38:11 <tnks> just to save me the trouble of looking this up or testing it. . . if two modules have the same name for an exported function. . . does one win out based upon a precedence?  Or is it a compilation error?
13:38:26 <tnks> (if the two modules are imported)
13:38:47 <rwbarton> it's an error if you refer to that name
13:38:52 <tnks> k.
13:39:01 <tnks> that's good, and what I'd hoped.
13:39:07 <Iceland_jack> referring to the function gives you an error and need to either qualify it or hide it from either of the modules
13:39:33 <tnks> I want to avoid accidentally calling the wrong function.
13:39:42 <tnks> and it seems the compiler is helpful.
13:51:33 <napping> Hey, given class Foo a where mkFoo :: a, why can't I write instance (?x::a, Show a) => Foo String where mkFoo = show ?x
13:54:17 <benzrf> napping: why are you using implicit args
13:54:22 <dwcook> What's an easy way to read a line from a handle into a ByteString, terminated by either \n or \r\n, and leaving off that ending? Currently I'm using hGetLine but that doesn't seem to respect NewlineMode.
13:55:19 <napping> I'm trying implicit args for context information rather than building up big records and making funny typeclasses for getting info back out
13:55:30 <benzrf> napping: don't use implicit args
13:55:37 <rwbarton> I think that was determined to be a bug
13:55:48 <rasfar> dwcook, are you sure you wouldn't prefer Data.Text? if you convert to ByteString that would fuse, right?
13:56:09 <napping> I think using them in an instance is probably a bad idea, but I'm slightly surprised that doesn't work
13:56:22 <dwcook> rasfar, I think it shouldn't be text right away. Some of the content might not need to be decoded.
13:56:37 <napping> benzrf: why not?
13:56:37 <rasfar> ah
13:56:39 <rwbarton> it used to work, it was specifically removed, I think
13:56:44 <dwcook> rasfar, I don't know what you mean about fusing.
13:57:09 <rasfar> well, just that B.fromList . T.toList is supposed to cost almost nothing
13:57:30 <benzrf> napping: .............................
13:57:34 <rasfar> (so if Data.Text gave you the line termination support you needed, it might be an option)
13:57:35 <napping> rwbarton: not terribly surprising that it would be specifically excluded
13:57:52 <kwf> keshav, sanklesaria: http://fdiv.net/2012/04/01/objectivist-c
13:58:15 <benzrf> napping: i would put the arg constraint in the class def
13:58:17 <benzrf> not in the instance
13:58:23 <kwf> (sorry, ignore — though it is funny — wrong IM window)
13:58:38 <rasfar> i'm glad we're talking about classes and instances! i have a question....
13:58:43 <napping> benzrf: yeah, this usage is pretty crazy and I'm not surprised it's diassallowed
13:58:50 <napping> putting it on the class would be even crazier, though
13:58:52 <benzrf> napping: i believe arg constraints have to go on function type decls
13:58:58 <jle`> is there a nice way to do (id &&& f)
13:59:04 <benzrf> could be wrong
13:59:12 <benzrf> jle`: is that not nice enough
13:59:13 <benzrf> :p
13:59:15 <napping> benzrf: it's a Constraint
13:59:20 <donri> jle`: fmap?
13:59:24 <napping> you can generally pick up more Constrains in an instance
13:59:34 <benzrf> @pl \f v -> (v, f v)
13:59:34 <lambdabot> ap (,)
13:59:34 <napping> just not implicit params, I guess
13:59:39 <rasfar> can i use the default method to cover some constructors, and pick up the rest in the intance?
13:59:42 <donri> jlewis: second?
13:59:47 <benzrf> jle`: lambdabot sez ap (,)
13:59:59 <napping> benzrf: is there any reason I shouldn't use implicits instead of reader monads in otherwise pure code?
14:00:00 <benzrf> > ap (,) (+1) 3
14:00:00 <jle`> donri: second is (id *** f)
14:00:01 <lambdabot>  (3,4)
14:00:16 <donri> i can never keep &&& and *** apart
14:00:17 <napping> especially if I want the possibility to be rather fine-grained about which information which functions require?
14:00:24 <donri> :t (&&&)
14:00:25 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:00:27 <dwcook> I guess I might as well check if a \r is on the end and strip it off if so.
14:00:31 <benzrf> napping: it's gross :{
14:00:32 <rasfar> i wish i could but think it's not possible -- is there an extension for that?
14:00:44 <napping> I'd be reasonably happy with overloaded records, I think
14:00:44 <benzrf> rasfar: what
14:00:47 <benzrf> that makes no sense
14:00:56 <jle`> benzrf: ty
14:00:56 <benzrf> oh wait
14:01:09 <benzrf> rasfar: sorry i thought you meant constructors of the instantiating type
14:01:10 <rasfar> maybe it makes sense to me; i can explain more
14:01:13 <benzrf> rasfar: my bad
14:01:30 <benzrf> rasfar: you could make a delegating function
14:01:33 <rasfar> um, no, is something called Pattern which is used over all the instances
14:01:45 <rasfar> thank you, concrete idea to look into!
14:02:02 <rasfar> does that live in the class declaration? (i should just look it up...)
14:02:12 <benzrf> rasfar: i mean, let them write a partial function
14:02:17 <benzrf> for the method
14:02:30 <benzrf> then write a function that calls the method if it's a case that it doesnt know
14:02:32 <benzrf> i.e.
14:02:39 <benzrf> delegatingFunc 1 = 2
14:02:42 <benzrf> delegatingFunc 2 = 3
14:02:46 <benzrf> delegatingFunc n = theMethod n
14:02:51 <rasfar> yes ... you mean partial, as in not all cases are covered ... oh this is lovely, thank you
14:02:57 <benzrf> it feels slightly off to me
14:03:00 <benzrf> but i cant think how else
14:03:15 <benzrf> in general you probably shouldnt be writing partial functions but i dont know how else :\
14:03:50 <rasfar> so, the instantiation has an extra case at bottom to call the delegator? i get it thanks, that's a price worth paying
14:04:04 <rasfar> (that is, if making classes is even what I sould be doing!)
14:05:10 <benzrf> rasfar: no the other way around
14:05:14 <rasfar> i was hoping the default method matches would take over automagically; i suppose an extension to do that would be possible, but that's academic, the delegation will be okay
14:05:21 <benzrf> the delegator has a case at the bottom to call the instance
14:05:27 <benzrf> then you call the delegator, never the actual method
14:05:45 <ifesdjeen> @bitemyapp ping
14:05:45 <lambdabot> Unknown command, try @list
14:05:57 <benzrf> perhaps you mean
14:05:58 <benzrf> @ping bitraten
14:05:59 <lambdabot> pong
14:06:01 <benzrf> @ping bitemyapp
14:06:01 <lambdabot> pong
14:06:14 <ifesdjeen> ping bitemyapp
14:06:15 <rasfar> oh... now i don't understand. so if it's class Foo a where foo :: Pattern -> a -> String
14:06:35 <codygman> Is this a sensible way to implement a function that may return Text or fires an exception the desired Text value is Nothing? Would I be better off using an Either? http://lpaste.net/106763
14:06:40 <benzrf> theDelegatingFunctionThat'sNotInTHeClass somePattern v = 4
14:06:46 <rasfar> i ... do i need a default foo method at all? (i'm very new to classes)
14:06:47 <benzrf> oops i mean
14:06:57 <benzrf> theDelegatingFunctionThat'sNotInTHeClass (SomePattern n) v = n
14:07:05 <benzrf> theDelegatingFunctionThat'sNotInTHeClass (AnotherPattern _) v = 3
14:07:20 <benzrf> theDelegatingFunctionThat'sNotInTHeClass somethingElse v = theActualMethod somethingElse v
14:07:34 <benzrf> rasfar: so if it's one of your predefined cases, it will catch it
14:07:38 <benzrf> otherwise it calls the class method
14:07:49 <ifesdjeen> bitemyapp: hey
14:08:11 <rasfar> thanks benzrf, i
14:08:17 <rasfar> ''ll think about that
14:09:28 <pjdelport> codygman: It's usually better to let errors propagate as values, rather than using error
14:10:00 <pjdelport> codygman: Is there any particular reason that getLoginToken can't just return the Maybe directly?
14:10:22 <pjdelport> The caller can then decide how to handle that.
14:10:29 <codygman> pjdelport: There is not. I was actually considering doing just that and then doing a case match on the maybe in the caller(s).
14:11:04 <pjdelport> You can use Either, too, but probably only if the Left value adds something on top of Nothing.
14:11:51 <rasfar> benzf: i'm still confused how individual instances work. they're expected to implement the class method foo. It seems like they'd each have to have their own version of the delegating function.
14:12:13 <pjdelport> codygman: By the way, if you keep it to returning a Maybe, you can simplify that function to: getLoginToken = parseLoginToken <$> cursorFor "http://localhost/loginWithToken"
14:12:53 <rasfar> basically I don't need the "generic" delegating function to do anything, except ignore the cases not covered by the instance.
14:13:07 <codygman> pjdelport: Thanks for your help
14:13:26 <rasfar> so it seems like I'd write in my instance: foo (SomePattern n) v = n
14:13:54 <benzrf> rasfar: no, the delegating function is not a method
14:13:58 <rasfar> foo p v = delegate v -- final case
14:14:00 <benzrf> it's an outside func
14:14:05 <benzrf> let me show you an example...
14:14:08 <rasfar> sorry, I should have said function
14:14:20 <benzrf> rasfar: delegate calls foo
14:14:22 <benzrf> not vice versa
14:14:31 <rasfar> but that leads me to my next question which is, wouldn't it be cleaner to have that delegation function as a class method?
14:14:40 <benzrf> what purpose would it serve?
14:14:49 <benzrf> it's not different from instance to instance
14:15:11 <rasfar> well, I'm just thinking of the API, the contract -- Foo has a method foo; users expect to be able to call foo on instances...
14:15:31 <benzrf> hold on
14:15:35 <benzrf> let me write an example >.<
14:15:37 <rasfar> so the instance must have a foo in scope (whether it's defined locally, or is the default class mthod) [?]
14:15:54 <rasfar> this is why I assume the calling chain must be foo -> delegate
14:16:25 <rasfar> * foo ---> delegate
14:17:04 <benzrf> rasfar: http://bpaste.net/show/426213/
14:17:21 <rasfar> as to your point "it's not different from instance to instance" -- that's exactly why I wanted it to live in the class, where it can be shared by all instances
14:17:25 <rasfar> thanks checking...
14:17:42 <benzrf> rasfar: then you always call delegate and not foo from anywhere else
14:17:56 <monochrom> I agree with benzrf's design
14:17:58 <benzrf> rasfar: if you pass in a 0 or a 10, delegate will immediately return some result
14:18:05 <benzrf> rasfar: anything else, it'll pass it on to the specific instance
14:19:03 <rasfar> so the API would show a class with no (visibel) methods, and the API would also make it clear you should call 'delegate' to use it?
14:19:59 <benzrf> rasfar: ya
14:20:04 <rasfar> hmm... I guess the problem is, I'm trying to "pick up the crumbs", the catch-all case, rather than cover any specific cases, in the delegate (I'm not sure this matters but it feels like it)
14:20:08 <kini> [2014-07-01 13:57:06] <kwf> (sorry, ignore — though it is funny — wrong IM window)
14:20:08 <kini> oh hi lol
14:20:24 <benzrf> kini: irony!
14:20:52 <kini> indeed :)
14:21:01 <rasfar> will give it more thought; it's not a show stopper in any case
14:23:32 <rasfar> (it's just warnings about "Pattern match(es) are non-exhaustive"; I can put the base case in each instance, it's trivial; just hoping for the cleaner code)
14:25:05 <benzrf> kk
14:36:03 <thevishy> haskell compiles into binary code
14:36:04 <thevishy> ?
14:36:11 <hpc> it can
14:36:20 <hpc> it can also compile to bytecode, it can be interpreted, whatever
14:36:27 <hpc> (ghc will do all three of those)
14:36:35 <thevishy> interesting  , right hpc
14:37:16 <hpc> the language itself doesn't specify what needs to be done to run code, so even weirder ways to run code can be added in the future
14:37:31 <corgifex> just like C!
14:37:43 <monochrom> perhaps compile haskell to agda
14:39:47 <napping> hpc: can you easily compile to bytecode outside the interpreter?
14:40:09 <hpc> napping: probably not :P
14:40:27 <corgifex> if it doesn't compile to javascript, it's not a real language
14:40:50 <monochrom> forget real. I want complex.
14:41:07 <monochrom> complex languages compile to agda
14:41:59 <hpc> i want imaginary
14:42:16 <corgifex> hyperrealism
14:42:52 <hpc> constructivism?
14:43:14 <hpc> (there should be an art style called integerism, we can have one for every numeric class)
14:43:31 <corgifex> deconstructive proof
14:43:35 <tolt> Wanting your library to work like conduits is a lot easier than getting it to look like conduits.
14:43:46 <ion> detonational semantics
14:44:00 <monochrom> I like detonational semantics :)
14:44:02 <johnw> tolt: how do you mean?
14:44:43 <tolt> After working with really generic functions for a couple of hours it has gotten really confusing to think about.
14:45:10 <corgifex> tfw really gf
14:46:14 <benzrf> tolt: *I* use pipes
14:46:17 <benzrf> -smug-
14:47:17 <tolt> benzrf: Haha. I just meant that I wanted to write something that had the operators like conduits and the functions I'm writing have a lot of b -> a, c -> a, c type things in them.
14:48:11 <tolt> They're actually more like (b -> a) -> (c -> a) -> c -> ... type things.
14:51:16 <johnw> tolt: I still kind of have no idea what you mean :)
14:52:14 <tolt> johnw: I'm starting to write gneric functions like the ones that are in conduit ((=$) :: Monad m => Conduit a m b -> ConduitM b c m r -> ConduitM a c m r) and it's really interesting to try to reason about.
14:52:48 <johnw> you mean, just Arrows?
14:53:00 <johnw> or do you mean abstracting over Monad?
14:53:04 <johnw> or is this really about streaming?
14:55:37 <tolt> It's not about streaming. It's something like arrows. It's the classification of time series data. I want to be able to combine classifications in different ways.
14:57:26 <johnw> I wonder if your classifications form a monoid, or maybe even a group
14:57:45 <johnw> for example: http://twdkz.wordpress.com/2013/05/31/data-analysis-with-monoids/
14:58:18 <tolt> I'm almost certain they do. I'm working on getting the ground work done first.
14:58:30 <eikke__> thats's a really good post, the one johnw pasted
14:58:40 <tolt> Thanks for that though. I'm going to read that when I'm off work.
14:58:47 <ion> We love monoids.
14:59:20 <eikke__> we need more monoid-based-automatic-parallellism
15:00:57 <tolt> The sad part is that I know a lot of the cool things aren't going to be able to happen because the data isn't perfect.
15:01:15 <benzrf> groups is neat
15:01:25 <benzrf> tolt: have you tried pipes
15:01:30 <benzrf> :v :v :v
15:02:02 <tolt> As in there are a lot of ways that the classification could be combined if I had better data. I haven't that much but it's a different problem. I have to build up a weird data structure on bifunctors
15:02:08 <napping> hpc: O'Caml certainly seems to like keeping a bytecode backend, distributing bytecode programs, etc.
15:02:53 <eikke__> napping: yup, although in production you wouldnt use that
15:03:22 <cschneid> what kind of overhead does a free monad approach to separating out an interpreter for some code impose? ie, if the goal is to have different interpreters for runtime vs. test time - is that a big or tiny overhead?
15:03:33 <kvanb> vouch for pipes
15:03:44 <kvanb> its a lot better than it used to be and its super easy to use now
15:03:52 <napping> eikke__: what's it good for? portability? things that don't need to be too fast?
15:04:02 <johnw> cschneid: if you use free-operational, not too much, just an evaluation cost
15:04:04 <MP2E> cschneid : overhead is somewhat large because of the fact that if you use bind with a free monad it has to traverse the entire structure each time, but this can be mitigated
15:04:09 <johnw> if you use plain jane free monads, a lot
15:04:17 <MP2E> what johnw said
15:04:19 <eikke__> napping: compilation is faster, it's used to compile to javascrpit by js_of_ocaml, the time-traveling debugger uses it,...
15:04:31 <cschneid> johnw / MP2E: interesting. I'll dive into free-operational and see what that is :)
15:04:49 <benzrf> kvanb: i pulled out the essential core of pipes (Proxy, F/A/M/MT instances, 4 categories identity and pointful composition)
15:04:54 <johnw> the key trick is the use of Coyoneda to reassociate the binds
15:05:00 <benzrf> kvanb: it's small enough to work with lambdabot's @letlpaste
15:05:01 * eikke__ looking forward to what ekmett will do with that paper oleg and atze published
15:05:09 <napping> he's already working on it
15:05:14 <benzrf> kvanb: you can now import part of Pipes.Core into lambdabot
15:05:14 <benzrf> :3
15:05:16 <johnw> edwardk is an oleg paper to Haskell compiler
15:05:27 <eikke__> napping: I know
15:05:40 <benzrf> @letlpaste 106669
15:05:44 <lambdabot>  Defined.
15:05:53 <hpc> holy what, that's a thing now?
15:06:08 <eikke__> johnw: and adding non-Haskell98 & lots of dependencies during the translation ;-) (J/K)
15:06:09 <benzrf> hpc: i pr'd it in about a week ago
15:06:30 <cschneid> johnw: I've heard coyoneda before, but no idea what it is. More reading.
15:06:50 <johnw> cschneid: this is a much simpler read: https://github.com/jwiegley/notes/blob/master/MoreFree.hs
15:07:07 <napping> johnw: is that mostly good for interepreters?
15:07:10 <johnw> it distills the essence of what free-operational is about, without the Program machinery that it layers on top (and which is perhaps the most useful part)
15:07:14 <benzrf> > let ones = forever $ respond 1; take' n = replicateM n (request ()); pipeline = const ones +>> take' 5; in runIdentity (runEffect pipeline)
15:07:16 <lambdabot>  [1,1,1,1,1]
15:07:33 <benzrf> kvanb: :-3
15:07:38 <johnw> napping: it's good for whenever you want to examine how the action was specified before evaluating into a real monadic action
15:07:54 <napping> johnw: That Coyoneda doesn't look as nice for things like recursion schemes
15:08:11 <johnw> why not?
15:08:29 <napping> like, if I want to use a term as data rather than evalute it as a real monadic action
15:09:22 <johnw> I'm not sure I see why you're relating the two ideas
15:10:00 <johnw> recursion schemes also lets you express structures as fixed points of functors, yes.  The free monad's structure is restricted to the structure of a monoid algebra over functors
15:10:58 <benzrf> whenever i see 'bananas and lenses' for a second i think of reactive-banana and lens before remembering brackets
15:11:15 <napping> You mentioned this implementation as a replacement for free moands
15:11:30 <napping> and one of the things I wanted from a base functor was a free monad, for terms with variables
15:11:30 <johnw> a replacement?
15:11:37 <johnw> I'm sorry, I'm lost
15:12:10 <napping> You said free-operational was fast for using a free monad approach to interepteres
15:12:21 <johnw> right
15:12:28 <napping> I was wondering if it might also be fast for using free monads more like data
15:12:41 <Energy> hello suckers of my dick !
15:12:48 --- mode: ChanServ set +o johnw
15:12:48 --- mode: johnw set +b *!~Energy@25.104-66-87.adsl-dyn.isp.belgacom.be
15:12:48 --- kick: Energy was kicked by johnw (Kicked)
15:12:48 --- mode: johnw set -o johnw
15:12:58 <johnw> napping: hmm, I guess you'd have to try
15:13:07 <johnw> but I don't see how it really helps there
15:13:15 <johnw> I mean, if you have the free monad structure, you have your data
15:13:37 <napping> Probably take a closer look at the Coyoneda bit, I suspect if you wanted to just pull off one level you'd have to run it into something more structural, and then convert the children back
15:13:42 <johnw> free-operational is for when you want to evaluate it down to the base monad
15:13:46 <kvanb> benzrf: cool!
15:13:52 <napping> then again, if I was doing a catamorphism over the whole structure or something it might not actually cost must
15:14:11 <benzrf> what a dong
15:14:24 <johnw> napping: yeah, maybe, would be interesting to explore
15:14:27 <kvanb> > runEffect $ each [1..5] >-> print
15:14:28 <lambdabot>  Not in scope: ‘>->’
15:14:28 <lambdabot>  Perhaps you meant one of these:
15:14:28 <lambdabot>    ‘>>’ (imported from Control.Monad.Writer),
15:14:28 <lambdabot>    ‘>>>’ (imported from Control.Arrow),
15:14:28 <lambdabot>    ‘>=>’ (imported from Control.Monad.Writer)
15:14:46 <johnw> I'm using the recursion schemes idea for an untyped lambda calculus evaluator I'm currently working on
15:14:59 <johnw> it does simplify some things
15:15:16 <napping> hmm, I guess it might be orthogonal to using something like data types ala carte for building up the functor
15:15:31 <kvanb> benzrf: guess we can't use Pipes.Prelude?
15:15:33 <napping> I think I'd be happy with real polymorphic variants
15:16:10 <zq> what's the rule for the (.) operator?
15:16:13 <napping> you've seen to O'Caml demo with ANF transformation or something?
15:16:17 <jle`> zq: rule?
15:16:36 <zq> jle`: data D = C Int
15:16:48 <jle`> (f . g) = \x -> f (g x)
15:16:49 <zq> jle`: how would haskell distinguish between C.head and C . head?
15:16:52 <dwcook> @src (.)
15:16:52 <lambdabot> (f . g) x = f (g x)
15:16:52 <jle`> oh
15:16:52 <lambdabot> NB: In lambdabot,  (.) = fmap
15:16:58 <benzrf> kvanb: i could try adding small parts of it to the paste
15:17:00 <dwcook> Ignore that last line
15:17:01 <zq> no no, i mean syntactically
15:17:05 <jle`> if it's after something with a capital letter
15:17:14 <jle`> if there is no space, it is considered a qualified import
15:17:20 <benzrf> but you realize that `p >-> c = const p +>> c', right
15:17:21 <dwcook> zq, you want its fixity then? Check :i (.) in ghci, I forget off the top of my head
15:17:27 <dwcook> fixity/associativity
15:17:36 <jle`> if it's after a normal lowercase identifier, it's considere dna operator
15:17:46 <zq> jle`: yeah except not
15:17:46 <kvanb> I was never good with +>> and stuff
15:17:49 <zq> wait, let me paste
15:17:54 <benzrf> kvanb: u need to learn the core !
15:17:56 <jle`> in foo.bar, (.) is an operator... in Foo.bar, it's considered a qualified import of bar
15:18:05 <benzrf> :t mapM respond
15:18:05 <jle`> even if Foo is a data constructor
15:18:06 <lambdabot> Monad m => [a] -> PProxy a' a1 b a m [b]
15:18:20 <jle`> > (Just . negate) 5
15:18:21 <lambdabot>  Just (-5)
15:18:24 <jle`> > (Just.negate) 5
15:18:25 <lambdabot>  Not in scope: ‘Just.negate’
15:18:30 <dwcook> Foo.bar.baz, on the other hand…
15:18:42 <kvanb> > Just <$> negate $ 5
15:18:43 <lambdabot>  Just (-5)
15:19:13 <zq> ls
15:19:15 <benzrf> > runWriter . runEffect $ const (mapM respond [1..5]) +>> forever (request () >>= lift . tell)
15:19:17 <lambdabot>  No instance for (GHC.Show.Show w0)
15:19:17 <lambdabot>    arising from a use of ‘M131910560747617048919507.show_M1319105607476170489...
15:19:17 <lambdabot>  The type variable ‘w0’ is ambiguous
15:19:17 <lambdabot>  Note: there are several potential instances:
15:19:17 <lambdabot>    instance [safe] GHC.Show.Show
15:19:20 <benzrf> shiz
15:19:31 <benzrf> > runWriter . runEffect $ const (mapM respond [1..5]) +>> forever (request () >>= lift . tell . show)
15:19:33 <lambdabot>  ([(),(),(),(),()],"12345")
15:20:02 <zq> jle`: https://gist.github.com/bryant/735dbf59efcbe414af22
15:20:04 <benzrf> or perhaps
15:20:08 <benzrf> > execWriter . runEffect $ const (mapM respond [1..5]) +>> forever (request () >>= lift . tell . show)
15:20:10 <lambdabot>  "12345"
15:20:13 <benzrf> cool
15:20:21 <zq> jle`: no, not 'even if Foo is a ctor'
15:20:41 <benzrf> zq: wbat if it's a fun ctor
15:21:14 <zq> benzrf: then it'd know how to have a good time? i'm not sure what you mean by func ctor
15:21:16 <rasfar> > typeOf typeOf  -- and haha benzrt
15:21:17 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:21:17 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
15:21:17 <lambdabot>  The type variable ‘a0’ is ambiguous
15:21:17 <lambdabot>  Note: there are several potential instances:
15:21:17 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:21:18 <jle`> zq: er, is there an error there?
15:21:26 <zq> jle`: nope
15:21:33 <jle`> huh.
15:21:41 <benzrf> > typeOf 3
15:21:42 <lambdabot>  Integer
15:21:44 <zq> so yeah, the space makes a difference, which leads me to ask what the rules are
15:21:48 <benzrf> > typeOf show
15:21:50 <lambdabot>  () -> [Char]
15:21:55 <benzrf> > typeOf typeOf
15:21:57 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
15:21:57 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
15:21:57 <lambdabot>  The type variable ‘a0’ is ambiguous
15:21:57 <lambdabot>  Note: there are several potential instances:
15:21:57 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:22:00 <benzrf> so lame!
15:22:20 <rasfar> > typeOf (typeOf::Typeable t => t -> TypeRep t)
15:22:21 <lambdabot>  ‘Data.Typeable.Internal.TypeRep’ is applied to too many type arguments
15:22:25 <jle`> zq: I don't get it, Ligtht . head $ [1,2,3] should be a tpy error?
15:22:28 <jle`> my entire world is rocked
15:22:28 <rasfar> > typeOf (typeOf::Typeable t => t -> TypeRep)
15:22:30 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
15:22:30 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
15:22:30 <lambdabot>  The type variable ‘t0’ is ambiguous
15:22:30 <lambdabot>  Note: there are several potential instances:
15:22:30 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:22:32 <ninja_code> jle`: ping
15:22:32 <jle`> oh wait
15:22:34 <jle`> no it shouldn't be
15:22:36 <ninja_code> jle`: everything worked
15:22:43 <ninja_code> jle`: thanks for all your time + patience yesterday
15:22:44 <jle`> zq: the rule sstill appy
15:22:50 <jle`> ninja_code: no problem :)  glad it worked!
15:23:10 <benzrf> kvanb: its quite simple
15:23:23 <jle`> zq: is a :: Int and b :: D Int ?
15:23:36 <benzrf> kvanb: a Proxy can send a value downstream and then wait for a value to come from downstream, send one up and wait for one to come from up, or terminate
15:24:10 <zq> jle`: head [1..3] :: Int, Litht :: Int -> D
15:24:11 <benzrf> kvanb: respond v sends v down and results (as an action) in the next thing to come up
15:24:12 <napping> also run a step in whatever monad the Proxy is lifted over
15:24:19 <jle`> zq: but what about a and b
15:24:20 <benzrf> kvanb: request sends up and waits for something to come down
15:24:39 <zq> jle`: they're two different things, yes. that was the point.
15:24:45 <jle`> zq: so the rules still apply
15:25:00 <jle`> Ligtht.head is head from the Ligtht module
15:25:10 <benzrf> kvanb: (+>>) sticks together a Proxy that sends a down and takes b from down and one that takes a from up and sends b up
15:25:12 <jle`> Ligtht . head is head composed with the Ligtht constructor
15:25:30 <benzrf> kvanb: the 1st arg is a function taking a b and giving the aforementioned Proxy
15:25:31 <zq> yes, but if i commented out line 3
15:25:33 <jle`> it's treated as a constructor if there is no space and the identifier is capital letter
15:25:42 <benzrf> kvanb: the 2nd arg is the 2nd aforementioned Proxy
15:25:49 <zq> or rather
15:25:56 <benzrf> kvanb: the 1st arg has to be a function because otherwise what do you do with the first upstream send from the downstream Proxy?
15:26:01 <jle`> if you commented out line 3 it'd be a compile error
15:26:20 <jle`> name resolution
15:26:22 <benzrf> kvanb: in this model, it gets fed to the function. then the result is run until it produces a value, which is sent downstream, etc pingponging
15:26:22 <zq> commenting out line 1 makes line 5 a composition
15:26:29 <zq> no, it doesn't. what is going on.
15:26:32 <kvanb> sec, reading everything
15:26:32 <jle`> yeah
15:26:38 <dwcook> zq, if I'm reading the Report correctly, the rule is that it's qualifying if there are no spaces around the . and what precedes is a valid module name.
15:26:44 <jle`> it'll treat it as a qualified import
15:26:48 <jle`> and find that there's nothing qualified as that
15:26:50 <jle`> so it'll error
15:26:55 <dwcook> zq, see here http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-18000010.5
15:27:10 <zq> > :t let (f, g) = (drop 1, take 1) in f.g
15:27:12 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:27:21 <zq> erf
15:27:26 <kvanb> :t const
15:27:27 <lambdabot> a -> b -> a
15:27:30 <zq> > :t let f = drop 1 in f.f
15:27:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:27:45 <jle`> with spaces = composition; without spaces = qualified if the left is lowercase/valid qualified identifier, composition if lowercase/otherwise
15:27:47 <dwcook> zq, take off the :t
15:27:55 <kvanb> Pipes are always functions?
15:27:55 <jle`> see:
15:28:03 <jle`> > Just . subtract $ 5
15:28:04 <dwcook> zq, or if you're trying to find the type take off the >
15:28:05 <lambdabot>  Just <Integer -> Integer>
15:28:05 <benzrf> kvanb: no, Pipes are Proxides
15:28:08 <jle`> > Just.subtract $ 5
15:28:09 <lambdabot>  Not in scope: ‘Just.subtract’
15:28:09 <benzrf> *Proxies
15:28:14 <kvanb> Proxides, hehe
15:28:18 <jle`> er
15:28:19 <benzrf> kvanb: `foo >-> bar' is just `const foo +>> bar'. since foo doesnt pay attention to anything coming upstream and bar doesnt send anything meaningful upstream, you dont need to do anything with the 1st upstream-sent value. similarly, await and yield are request and respond, but sending () and resulting in () respectively
15:28:22 <jle`> > Just . negate $ 5
15:28:23 <lambdabot>  Just (-5)
15:28:25 <jle`> > Just.negate $ 5
15:28:27 <lambdabot>  Not in scope: ‘Just.negate’
15:28:36 <dwcook> > Just. negate $ 5
15:28:38 <lambdabot>  Just (-5)
15:28:40 <zq> :t let f = drop 1 in f.f
15:28:40 <dwcook> > Just .negate $ 5
15:28:41 <lambdabot> [a] -> [a]
15:28:42 <lambdabot>  Just (-5)
15:28:50 <benzrf> await = request ()
15:28:51 <dwcook> So it seems like it's as I said above
15:28:54 <zq> so it's the capitalization
15:29:06 <benzrf> yield v = () <$ respond v
15:29:07 <dwcook> zq, basically
15:29:08 <zq> this is too hard, i'm gonna go shopping
15:29:14 <jle`> zq: yes, as i have been saying :) or more technically, a valid qualified name
15:29:18 <jle`> er, qualifier name
15:29:28 <zq> i'm just wondering
15:29:32 <dwcook> zq, this is probably one reason why we habitually write spaces around .
15:29:43 <zq> what if you start allowing for lowercase namespaces, like in ml
15:29:54 <dwcook> zq, well then other changes in the syntax would have to be made
15:29:56 <zq> then you'd get ambiguous parses
15:30:08 <kvanb> :t (<$)
15:30:09 <lambdabot> Functor f => a -> f b -> f a
15:30:57 <benzrf> kvanb: v <$ f = fmap (const v) f
15:31:04 <benzrf> > 3 <$ NOthing
15:31:05 <lambdabot>  Not in scope: data constructor ‘NOthing’
15:31:05 <lambdabot>  Perhaps you meant ‘Nothing’ (imported from Data.Maybe)
15:31:06 <benzrf> > 3 <$ Nothing
15:31:07 <lambdabot>  Nothing
15:31:08 <benzrf> > 3 <$ Just 1
15:31:10 <lambdabot>  Just 3
15:31:20 <benzrf> kvanb: it's handy for making types line up
15:31:27 <jle`> it's kind of like "replace the value"
15:31:28 <benzrf> among other things
15:32:15 <kvanb> > 2 <$ Left 5
15:32:16 <lambdabot>  Left 5
15:32:20 <kvanb> I wondered.
15:32:25 <dwcook> I like to think of it as "Replace the type with a specific type; here's a value of it in case you need it"
15:32:27 <kvanb> > 3 <$ Right 3
15:32:29 <lambdabot>  Right 3
15:32:30 <kvanb> woops.
15:32:36 <kvanb> > 5 <$ Right 3
15:32:38 <lambdabot>  Right 5
15:32:49 <jle`> dwcook: better
15:33:29 <dwcook> But of course "replace the value" is a valid way of thinking in quite a few cases
15:34:38 <kvanb> > () <$ id 3
15:34:40 <lambdabot>  Could not deduce (GHC.Num.Num (f b0))
15:34:40 <lambdabot>    arising from the ambiguity check for ‘e_13’
15:34:40 <lambdabot>  from the context (GHC.Num.Num (f b), GHC.Base.Functor f)
15:34:40 <lambdabot>    bound by the inferred type for ‘e_13’:
15:34:40 <lambdabot>               (GHC.Num.Num (f b), GHC.Base.Functor f) => f ()
15:34:52 <kvanb> > 3 <$ add 2
15:34:53 <lambdabot>  Not in scope: ‘add’
15:34:53 <lambdabot>  Perhaps you meant one of these:
15:34:53 <lambdabot>    ‘odd’ (imported from Prelude), ‘and’ (imported from Data.List),
15:34:53 <lambdabot>    ‘F.and’ (imported from Data.Foldable)
15:35:08 <kvanb> Hmm, functions are a little trickier.
15:35:41 <rasfar> > undefined <$ True
15:35:42 <lambdabot>  Couldn't match expected type ‘f b0’
15:35:42 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:35:42 <benzrf> > (3 <$ id) "wut"
15:35:44 <lambdabot>  3
15:35:53 <rasfar> > undefined <$ const True
15:35:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
15:35:54 <lambdabot>    arising from a use of ‘M361240260362990704820022.show_M3612402603629907048...
15:35:54 <lambdabot>  The type variable ‘b0’ is ambiguous
15:35:54 <lambdabot>  Note: there are several potential instances:
15:35:54 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:36:05 <jle`> > (3 <$ (\x -> error "hello")) 6
15:36:06 <lambdabot>  3
15:36:21 <rasfar> > 1 <$ const True
15:36:22 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
15:36:23 <lambdabot>    arising from a use of ‘M183067793906619177920056.show_M1830677939066191779...
15:36:23 <lambdabot>  The type variable ‘b0’ is ambiguous
15:36:23 <lambdabot>  Note: there are several potential instances:
15:36:23 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
15:36:27 <rasfar> > 1 <$ True
15:36:28 <lambdabot>  Couldn't match expected type ‘f b0’
15:36:29 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:36:36 <benzrf> > (1 <$ const) True
15:36:38 <lambdabot>  1
15:36:39 <rasfar> (sorry, i'm done there)
15:36:40 <jle`> (<$) takes an `c` and turns an `a -> b` into an `a -> c`
15:37:16 <jle`> in the only way that makes sense
15:37:27 <jle`> (from parametricity)
15:37:33 <benzrf> jle`: an `c`
15:37:41 <benzrf> sounds wrong to me :3
15:37:44 <DanielDiaz> @src (<$)
15:37:44 <lambdabot> (<$) = (<$>) . const
15:37:58 <kvanb> (3 <$ undefined) True
15:38:01 <kvanb> > (3 <$ undefined) True
15:38:03 <lambdabot>  3
15:38:08 <kvanb> What's the point, then.
15:38:16 <jle`> benzrf: :P
15:38:34 <benzrf> kvanb: it works for any Functor, remember
15:38:53 <jle`> > 6 <$ Just 4
15:38:55 <lambdabot>  Just 6
15:39:05 <kvanb> ah yes
15:40:40 <rasfar> > 3 <$ Just True
15:40:42 <lambdabot>  Just 3
15:45:56 <r444> :t (<$)
15:45:57 <lambdabot> Functor f => a -> f b -> f a
15:47:57 <rasfar> it almost feels like you're doing something with generics, the way it looks / was explained :) / I'm off
15:54:22 <benzrf> :t \b c d = (,,) <$> b <*> c <*> d
15:54:23 <lambdabot> parse error on input ‘=’
15:54:29 <benzrf> :t \b c d -> (,,) <$> b <*> c <*> d
15:54:30 <lambdabot> Applicative f => f a2 -> f a1 -> f a -> f (a2, a1, a)
15:54:43 <benzrf> orite
16:02:16 <Abathurr> What's a good way to get software ideas? i need a new project but I don't know where to start
16:03:30 <r444> Abathurr: just scratch your own itch
16:04:51 <jle`> Abathurr: a learning project?
16:05:12 <Abathurr> jle: Not necessarily, just something to stifle my boredom and maybe r
16:05:18 <Abathurr> jle: reinforce what
16:05:19 <Abathurr> damn
16:05:20 <Abathurr> it
16:05:31 <Abathurr> reinforce what I'm laerning in school
16:05:53 <kvanb> aww benzrf is gone
16:06:43 <mmmm_> What have you done before Abathurr
16:07:16 <Abathurr> mmm_: Nothing special, I've designed a couple of websites, programmed a Tetris game...that's about it
16:09:13 <Gurkenglas> My last few pieces of code I made to advise me about what to do in a game or another
16:09:31 <mmmm_> and you want something to improve your haskell or just for general interest?
16:10:31 <Ralith> Abathurr: procedural graphics is always fun
16:10:44 <Ralith> numerical optimization problems, too
16:11:03 <Gurkenglas> ie a table of the probabilities by which a number of dice wins against another in kdice, or a simulation to find a good strategy for maximizing mana generation over time in a pen and paper game I was playing
16:11:20 <Abathurr> mmm_: Yes, I'm looking for something I can do in Haskell as a real-world project, but not necessarily something that is *only* to improve my haskell
16:11:55 <mmmm_> the classic haskell project is to write a compiler, don't know if that interests you
16:12:05 <Abathurr> Gurkenglas: That's a good idea. I play a lot of sc2, perhaps I could program a build order optimizer
16:12:09 <Gurkenglas> So my advice would be, pick up a sort of hobby where having a computational genie is handy; that'll improve your haskell and get you something out of it
16:12:17 <Abathurr> mmm_: Does that require a lot of compiler theory knowledge?
16:13:02 <mmmm_> No
16:13:33 <RchrdBrrll> Abathurr, I'd say yes, but not all at once. ;)
16:13:42 <kvanb> a build order optimizer sounds brilliant
16:13:42 <Abathurr> mmm_: Then that seems very interesting. I'll have to look into it
16:13:59 <mmmm_> it depends how complex you get obviously but at a simple level it will be fine
16:14:01 <RchrdBrrll> Compilers are very nice programs to write; they do very little I/O and they are very easy to break up into distinct phases.
16:14:06 <Abathurr> kvanb: At the least very interesting :)
16:14:14 <mmmm_> it's a good way to introduce monad transformers
16:14:28 <RchrdBrrll> you can write a pretty decent compiler at the same time as learning the theory about the specific bit that you're writing at the time. :)
16:14:42 <Abathurr> mmm_: Thanks! I think that's right up my alley then. I'm going to google some stuff and get started
16:15:20 <Abathurr> RchrdBrrll: Sounds amazing. I want to know more about the esoteric things like OS Design and Compilers but I need something I can jump into right now, so if it
16:15:24 <kvanb> Monad transformers are simple
16:15:31 <Abathurr> isn't too hard to get started that would be great
16:15:34 <kvanb> its jsut nobody explains them in a way that doesn't really really suck
16:15:37 <kvanb> or entrenched in the types
16:16:03 <mmmm_> once you know what you're doing then yes.. same as anything in life
16:16:24 <kvanb> someone needs to explain them directly in terms of what lift does with pictures
16:17:02 <kvanb> can haddock embed pictures?
16:17:24 <mmmm_> kvanb: yes
16:22:39 <mmmm_> Abathurr: This will probably help you out http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
16:57:50 <danielsmw> Could someone advise me on a problem with Data.Traversable? The hackage page says it exports instances for certain types, but I'm getting errors about those instance definitions not existing.
16:58:46 <danielsmw> In particular, running Data.Traversable.mapM (return . (+) 1) (Right 1) in ghci says that there's no instance for (Either a)
17:01:58 <orzo> i'm running out of steam on my project and could use a collaborator to help me get to the finish line.  I've cloned in haskell the NSS x509 validation algorithm used by firefox and have it passing a great many tests, http://jerkface.net/~joe/nss-clone/results.html
17:02:42 <orzo> the tests are originally from libpkix (http://libpkix.sourceforge.net/)
17:04:21 <orzo> as you can see, it's passing 744 out of 806 tests.  The failed tests are mainly due to unimplemented functionality such as CRL revocation.
17:05:45 <hexagoxel_> i currently have code that does not terminate. if i replace one expression with "undefined", it terminates (and _not_ with an error). is that.. supposed to be possible?
17:06:21 <dwcook> hexagoxel, threaded code may not terminate all threads upon evaluating bottom
17:06:24 <orzo> it's certainly possible with unsafe IO
17:06:34 <hexagoxel> dwcook: nothing to do with threads
17:07:04 <dwcook> hexagoxel, show some code perhaps
17:07:14 <dwcook> Someone might be able to offer more insight
17:07:40 <kvanb> hexagoxel: are you compiling with optimizations?
17:07:52 <kvanb> if not, you should
17:07:54 <hexagoxel> kvanb: using repl atm
17:07:59 <hexagoxel> so, no, i guess
17:08:16 <kvanb> in a perfect world, everything would work with -O0
17:08:31 <kvanb> but certain libraries fail to even build valid code without at least -O1 I've heard.
17:09:06 <kvanb> ie SHA1 I've often heard silently or otherwise fails to produce valid code without optimisations
17:09:36 <kvanb> but it could be your fault too
17:09:40 <kvanb> so please do show us ! :)
17:10:02 <benzrf> wait hwat
17:10:16 <benzrf> i thought optimizations can theoretically break things
17:10:19 <benzrf> but never vice versa
17:10:44 <hexagoxel> yeah moment, let me clean up an example
17:11:16 <kvanb> benzrf: historically, the other way around has been more common for ghc, I think
17:11:25 <kvanb> particularly because -O0 _sucks_ for functional languages
17:11:26 <benzrf> wut
17:11:39 <benzrf> gihhick
17:12:50 <danielsmw> Can anyone explain to me why Data.Traversable.mapM (return . succ) ('a',2) can't find an instance for ((,) Char)? It seems like Data.Traversable exports it.
17:13:00 <kvanb> well, think about it. When you don't perform inlining, one line of code can easily 5 function invocations or applications
17:13:00 <lfitz> hi, i'm trying to get a book database set up and it has build dependencies.  whenever I try to use cabal to install i get the following errors: http://lpaste.net/106767
17:13:07 <kvanb> a simple thing like this, right
17:13:13 <lfitz> there is also version information in the paste as well
17:13:34 <lfitz> it seems as though text-1.1.1.3 fails to build
17:13:38 <kvanb> lift $ foo bar $ map qux
17:14:05 <kvanb> you end up with 2 unknown arity, I think, and all the $'s don't get inlined?
17:14:20 <kvanb> that sounds more troublesome for the code generator than pretty tight loops.
17:14:25 <hexagoxel> dwcook, kvanb: http://ideone.com/0K1B9M
17:15:18 <hexagoxel> line 60
17:15:44 <hexagoxel> Build-Depends is CCA only, i think
17:16:02 <kvanb> hexagoxel: this is quite complex.
17:16:08 <kvanb> could you be doing the list monad accidentally?
17:16:49 <hexagoxel> uhm it's arrow notation
17:18:48 <kvanb> I have no idea, sorry. This is way over my head.
17:18:58 <lfitz> is text-1.1.1.3 similar to a library?
17:19:07 * lfitz knows nothing about haskell
17:19:20 <kvanb> lfitz: yes, it's a library
17:19:37 <kvanb> http://hackage.haskell.org/package/text-1.1.1.3
17:19:51 <lfitz> i tried to install text-1.1.1.3 with cabal install <pkg> and it fails to build
17:19:57 <lfitz> error -9
17:20:05 <kvanb> ghc --version?
17:20:15 <hexagoxel> well i am (yet again) testing the do-rec notation, and this seems to be not too far from a minimal testcase, to my best knowledge.
17:20:22 <lfitz> kvanb: http://lpaste.net/106767
17:20:35 <benzrf> how does do-rec work o.O
17:20:47 <lfitz> kvanb: 7.8.2
17:20:53 <benzrf> hmm
17:21:04 <benzrf> recursive let can be implemented with a lambda like this:
17:21:07 <benzrf> let v = ...
17:21:07 <hexagoxel> benzrf: via loop, in some magic way that i have not completely uncovered
17:21:10 <benzrf> becomes
17:21:17 <kvanb> lfitz: are you like out of disk space or something?
17:21:21 <benzrf> no wait
17:21:24 <kvanb> or maybe memory?
17:21:27 <benzrf> let x = y; v = ...
17:21:36 <benzrf> fix (\v x -> ...) $ v
17:21:38 <lfitz> possibly memory its a digital ocean vps with 512mb
17:21:41 <benzrf> fix (\v x -> ...) $ y
17:21:48 <kvanb> ah
17:21:55 <kvanb> I was unable to build lambdabot on a small vps
17:21:56 <hexagoxel> yeah, loop is fix for arrows
17:22:04 <kvanb> failed every time at different places
17:22:19 <kvanb> I think you can remediate it though
17:22:19 <benzrf> :t loop
17:22:20 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
17:22:23 <c_wraith> benzrf: the MonadFix class
17:22:26 <benzrf> yo what
17:22:29 <benzrf> :t mfix
17:22:29 <lambdabot> MonadFix m => (a -> m a) -> m a
17:22:34 <benzrf> duuuuude
17:22:40 <benzrf> duuuuuuuuuuuuuuuuuuuude
17:22:45 <benzrf> > mfix Just
17:22:49 <lambdabot>  mueval-core: Time limit exceeded
17:22:58 <benzrf> :t fix
17:22:59 <lambdabot> (a -> a) -> a
17:23:00 <benzrf> heuh
17:23:05 <benzrf> > fix Just
17:23:06 <lambdabot>  Occurs check: cannot construct the infinite type:
17:23:06 <lambdabot>    a ~ Data.Maybe.Maybe a
17:23:06 <lambdabot>  Expected type: a -> a
17:23:06 <lambdabot>    Actual type: a -> Data.Maybe.Maybe a
17:23:10 <benzrf> i see
17:23:20 <benzrf> > fix (:[])
17:23:21 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ [a]
17:23:22 <lambdabot>  Expected type: a -> a
17:23:22 <lambdabot>    Actual type: a -> [a]
17:23:29 <benzrf> oh right that's what Mu's for
17:23:53 <lfitz> kvanb is there a way to make the compilation process less intensive? it fails at like 75%+ memory
17:24:04 <lfitz> possibly with nice im guessing
17:24:34 <hexagoxel> benzrf: i added the do-rec version of the function to my paste
17:24:44 <kvanb> I think ghc will prefer to quit instead of swapping out
17:25:17 <kvanb> I dont know whether this could be your issue or whether its an issue at all though
17:25:27 <kvanb> and you say there's no build error?
17:25:28 <hexagoxel> i thought my translation to loop would be equivalent, but it does not terminate unless i do some weird swapping-of-statements.
17:26:28 <hexagoxel> hmm let me try what happens with optimzations on
17:26:55 <lfitz> kvanb it only says 'failed to build text-1.1.1.3'
17:27:00 <kvanb> lfitz: try
17:27:06 <kvanb> cabal get text-1.1.1.3
17:27:13 <kvanb> then edit the cabal file to add ghc-options:
17:27:22 <kvanb> +RTS -s -H1.6G
17:27:31 <kvanb> well, change 1.6G to i.e. 1G
17:27:38 <kvanb> and see if it swaps out.
17:27:52 <kvanb> if it works, it will run *very* slowly
17:28:18 <kvanb> oh, after editing the cabal file, just `cabal install` in the directory
17:28:21 <kvanb> will install the local copy
17:29:19 <benzrf> :t maybe
17:29:20 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:29:30 <hexagoxel> the behaviour is the same with -O2, for my testcases
17:30:04 <benzrf> @@ hoogle ty maybe id
17:30:04 <lambdabot>  hoogle ty maybe id
17:30:09 <benzrf> @. hoogle ty maybe id
17:30:09 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
17:30:13 <benzrf> mfw
17:30:15 <benzrf> @. hoogle type maybe id
17:30:16 <lambdabot> Parse error:
17:30:16 <lambdabot>   (a -> a1 -> a1) -> Maybe a -> a1 -> a1
17:30:32 <benzrf> @. hoogle type flip maybe id
17:30:33 <lambdabot> Parse error:
17:30:34 <lambdabot>   a -> Maybe a -> a
17:30:37 <benzrf> man!
17:30:59 <lfitz> kvanb tried +RTS -s -H512M and it failed with ExitFailure(-9)
17:31:05 <lfitz> at the same spot
17:32:04 <kvanb> lfitz: is it a private codebase?
17:32:10 <kvanb> would you like me to try in a sandbox
17:32:47 <lfitz> not private, its on github, if you could run it in a sandbox that'd be great
17:34:17 <lfitz> this is my ghc-options line: ghc-options: -Wall -fwarn-tabs -funbox-strict-fields -O2 +RTS -s -H512M
17:34:50 <kvanb> remove the +RTS stuff now
17:34:56 <kvanb> send me the link to the repo
17:35:04 <hexagoxel> but just to be sure: it would be a bug if expression evaluates to non-bottom with an "undefined" as a particular subexpression, and to bottom when "undefined" is replaced with something else, right?
17:35:27 <kvanb> hexagoxel: not necessarily
17:35:37 <kvanb> ghc might infer different types
17:35:42 <kvanb> which could cause different instances to be used
17:35:50 <kvanb> I think.
17:36:12 <kvanb> try (undefined :: Expected Type Here)
17:37:35 <hexagoxel> kvanb: yeah, still the same behaviour
17:37:46 <kvanb> ok, that sounds like a bug
17:39:04 <hexagoxel> ok thanks.
17:40:05 <kvanb> lfitz: does your VPS have a swap file?
17:40:32 <johnfn> hey guys, when I do [a | _ <- [0..5] with -Wall I get this warning saying that 0 and 5 are defaulting to Int. what exactly is the concern? and is there a nice way to get it to go away?
17:41:56 <kvanb> > [a | _ <- [0..5 :: Int] ]
17:41:58 <lambdabot>  [a,a,a,a,a,a]
17:42:03 <orzo> johnfn: maybe its the monomorphism restriction.  Add a type signature
17:42:25 <johnfn> oh no… not the dreaded monomorphism restriction!!!
17:42:31 <orzo> oh wait
17:43:00 <joshc> it's ambiguous without a type signature, you could have meant type Integer, which also has both Enum and Num instances
17:43:02 <orzo> well, probably not the monomorphism restriction, but nothin ga type signature can't fix
17:43:11 <johnfn> i can get it to work like this: [a | _ <- [(0 :: Int) .. (5 :: Int)]
17:43:26 <kvanb> try just one :: Int after the 5
17:43:28 <kvanb> no brackets should work
17:43:37 <kvanb> or alternatively, _ <- [whatever] :: [Int]
17:43:39 <kvanb> should work too
17:43:41 <orzo> [ a | _ <- [0..5] :: [Int] ]
17:43:49 <Iceland_jack> johnfn: If your example actually looks like this, use ‘replicate 6’ instead
17:43:50 <orzo> > replicate 5 'a'
17:43:51 <lambdabot>  "aaaaa"
17:43:54 <Iceland_jack> @ty replicate 6 'a'
17:43:55 <lambdabot> [Char]
17:44:01 <kvanb> _ <- anything in a list comprehension is nuts though
17:44:01 <johnfn> Iceland_jack: ah, it doesn’t, but thanks for the tip
17:44:25 <johnfn> im actually doing a 2d array with nested list comps, if there’s a nicer way to do that though :)
17:44:27 <Iceland_jack> > length [0..5]
17:44:29 <lambdabot>  6
17:44:40 <orzo> Iceland_jack: ok, my bad
17:44:43 <orzo> :P
17:44:45 <Iceland_jack> :)
17:45:02 <Iceland_jack> quite possibly, I haven't been following the conversation so I don't know the details
17:45:05 <johnfn> ah yes, a single type sig is sufficient, nice.
17:45:50 <Iceland_jack> johnfn: When you type [0..5] it gets desugared to 'enumFromTo 0 5'
17:45:50 <Iceland_jack> > enumFromTo 0 5
17:45:52 <lambdabot>  [0,1,2,3,4,5]
17:45:58 <Iceland_jack> and the type of that is
17:45:58 <Iceland_jack> @ty enumFromTo
17:45:59 <lambdabot> Enum a => a -> a -> [a]
17:46:11 <johnfn> oh, good to know
17:46:20 <Iceland_jack> so if you give the type of a single argument, or of the result everything else is determined
17:46:26 <Iceland_jack> (concrete type)
17:46:32 <johnfn> right ofc
17:47:09 <kvanb> benzrf: around?
17:47:11 <Iceland_jack> you can also use (<$)
17:47:22 <Iceland_jack> If you really are so inclined
17:47:23 <Iceland_jack> > a <$ [0..5]
17:47:25 <lambdabot>  [a,a,a,a,a,a]
17:47:27 <benzrf> kvanb: yes
17:47:50 <kvanb> I want to turn the thing below into the type highlighted: https://github.com/kvanberendonck/pipes-server-template/blob/master/src/Main.hs#L37
17:47:56 <kvanb> any idea how I might do that?
17:48:28 <johnfn> Iceland_jack: what lib is <$ from?
17:48:48 <kvanb> encoder is not an idiomatic pipe. Type is encoder :: Monad m => (a -> Put) -> Producer a m r -> Producer ByteString m r
17:48:51 <johnfn> seems like it’s not in my ghci
17:48:55 <Iceland_jack> You can import it from Control.Applicative
17:49:10 <kvanb> decoder is decoder :: Monad m => Get a -> Producer ByteString m r -> Producer a m r
17:49:26 <johnfn> cool
17:51:06 <fenix_br> .
17:51:30 <benzrf> i dont have enough Context
17:51:32 <kvanb> benzrf: more generalised, I need (Producer ByteString m ... -> Producer ByteString m ...) -> Pipe ByteString ByteString m ...
17:51:43 <benzrf> ah
17:51:45 <kvanb> that's actually the whole problem, the code is not relevant sorry
17:51:53 <benzrf> kvanb: in what way is that a pipe?
17:52:23 <kvanb> I just get the feeling it's one.
17:52:37 <kvanb> it reads from the inner producer and yields stuff out of itself
17:52:52 <benzrf> ?
17:52:58 <benzrf> ok stop
17:53:04 <benzrf> you have a function that takes a producer and gives one back
17:53:11 <benzrf> what are the actual semantics here
17:53:41 <kvanb> it's because I can't just use a Pipe. That's too tricky because it has an internal state which can do partial parses and stuff
17:54:00 <kvanb> I guess it could never be a pipe?
17:54:05 <benzrf> why cant you just use a pipe
17:54:08 <benzrf> what are you tryin to do
17:54:43 <kvanb> I want the Pipe ByteString ByteString to take in network packets, decode them, process them through a handler, encode them again and yield bytestrings
17:54:52 <kvanb> then I'm going to compose them sequentially with >>
17:55:24 <benzrf> kvanb: why cant you make a pipe that does that
17:55:58 <kvanb> actually, I guess
17:56:01 <kvanb> I could.
17:56:08 <kvanb> I think.
17:56:51 <kvanb> I just realised a scenario where I need to anyway
18:01:37 <kvanb> benzrf: thanks. You've helped me gain clarity just by giving me someone to talk to
18:01:37 <kvanb> hehe
18:01:48 <benzrf> i am ur rubr dug
18:02:08 <kvanb> <:
18:04:22 <d10genes> I'd like to see if there's a point-free way to make a function like (a, b) -> (a -> c) -> (b -> d) -> (c, d)
18:04:29 <d10genes> If given a tuple, can I apply a function to each argument and return a new tuple?
18:04:37 <d10genes> for example, if I do `(,) . (length . fst)`, this will apply `length . fst` to the first element. Is there a point free way to apply (length . snd) to the second?
18:04:45 <Iceland_jack> You're asking for (***) btw
18:04:53 <Iceland_jack> :t (***)
18:04:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:05:54 <d10genes> trying to deconstruct the emoticon… (**:/?
18:06:05 <d10genes> aha
18:06:10 <d10genes> i see it now, thanks!
18:06:39 <Zekka> d10genes: Pretty sure there's also a way of doing this in bifunctors
18:06:48 <Iceland_jack> yes, it's the bimap of the product category
18:07:01 <Zekka> Yeah, I didn't know if there was a default instance for (,)
18:07:40 <Iceland_jack> :t bimap :: (a -> b) -> (a' -> b') -> (a, a') -> (b, b')
18:07:41 <lambdabot> (a -> b) -> (a' -> b') -> (a, a') -> (b, b')
18:07:50 <Iceland_jack> :t (***) :: (a -> b) -> (a' -> b') -> (a, a') -> (b, b')
18:07:51 <lambdabot> (a -> b) -> (a' -> b') -> (a, a') -> (b, b')
18:07:59 <d10genes> zekka: looks like I'd better do my homework on bifunctors…a built in library?
18:08:07 <Iceland_jack> no
18:08:09 <Zekka> d10genes: Not that I know of
18:08:23 <Zekka> http://hackage.haskell.org/package/bifunctors-4.1.1.1/docs/Data-Bifunctor.html <- here's a description of the typeclass
18:08:23 <Iceland_jack> You don't need to use bifunctors for it
18:08:31 <Zekka> Arrow would work, bifunctors is a little more general
18:08:35 <Iceland_jack> If you only want that single function, import 'Control.Arrow'
18:09:18 <Iceland_jack> bimap generalizes (***) and (+++) but it doesn't generalize the arrow type
18:09:31 <Zekka> That's what I mean
18:09:33 <d10genes> Iceland_jack: ok, thanks…still curious about this bifunctor thing though :)
18:09:45 <Iceland_jack> d10genes: you don't need to know anything, but if you want to learn more that's great
18:10:01 <Iceland_jack> > (succ *** pred) ('b', 10)
18:10:02 <lambdabot>  ('c',9)
18:10:10 <solidus-river> :t sequence
18:10:11 <lambdabot> Monad m => [m a] -> m [a]
18:10:11 <Zekka> A bifunctor is basically what it sound like -- a type which is a (covariant) functor over each of its arguments
18:10:46 <d10genes> zekka: which is always or at least often used with pairs?
18:10:48 <Zekka> So bimap for (a, b) takes a function representing what to do with a and a function representing what to do with b, and then zips them back up into a tuple
18:10:57 <benzrf> d10genes: class Functor f => Bifunctor f where bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
18:11:01 <benzrf> :t bimap
18:11:02 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
18:11:02 <Zekka> d10genes: It's often used with pairs, but also with a few other types
18:11:15 <Iceland_jack> benzrf: Bifunctor doesn't have a Functor constraint
18:11:19 <benzrf> Iceland_jack: oh
18:11:20 <Iceland_jack> that wouldn't kind-check
18:11:24 <benzrf> ah right
18:11:24 <benzrf> derp
18:11:31 <benzrf> > bimap (+1) (++"foo") (1, "hi")
18:11:34 <lambdabot>  (2,"hifoo")
18:11:34 <Zekka> benzrf: It provides two other methods but they can be defined in terms of bimap
18:11:38 <benzrf> Zekka: i k
18:11:39 <solidus-river> :t mapM
18:11:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:11:45 <d10genes> is a pair a functor?
18:11:53 <Iceland_jack> d10genes: pairs are bifunctors
18:11:55 <Zekka> d10genes: ((,) a) is a functor
18:11:59 <Zekka> ((,)) is a bifunctor
18:12:06 <Iceland_jack> but you can form a functor out of pairs in many ways
18:12:16 <Iceland_jack> by left-sectioning as Zekka mentioned
18:12:22 <Iceland_jack> right-sectioning or by making them diagonal
18:12:27 <Zekka> To clarify, I'm describing how Haskell defines it
18:12:43 <Iceland_jack> sure
18:12:50 <Zekka> jack's being a little more theoretical
18:13:06 <Zekka> > fmap (+1) (1, 2)
18:13:08 <lambdabot>  (1,3)
18:13:09 <Iceland_jack> You can define
18:13:10 <Iceland_jack>     data Pair a = Pair a a
18:13:10 <Iceland_jack> as a (mono-)functor
18:13:20 <Zekka> > bimap (-1) (+1) (1, 2)
18:13:21 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
18:13:22 <lambdabot>    arising from the ambiguity check for ‘e_11112’
18:13:22 <lambdabot>  from the context (GHC.Num.Num (a -> b),
18:13:22 <lambdabot>                    GHC.Num.Num d,
18:13:22 <lambdabot>                    GHC.Num.Num a)
18:13:31 <Iceland_jack> > bimap (subtract 1) (+1) (1, 2)
18:13:33 <lambdabot>  (0,3)
18:13:33 <Zekka> > bimap (subtract 1) (+1) (1, 2)
18:13:34 <Iceland_jack> but Zekka is more practical
18:13:34 <lambdabot>  (0,3)
18:13:35 <Zekka> Oh, beat me to it
18:13:39 <Iceland_jack> as I should be
18:14:06 <Zekka> It's fine, I've given the profunctor talk a few too many times
18:14:16 <Zekka> recently got an intuition for them so it's kind of tempting not to
18:14:36 <Iceland_jack> Zekka: I just remember someone explaining free monoids to someone who didn't get 'basic lists' ([]) in Haskell
18:14:43 <Iceland_jack> and I've wowed not to become that person
18:15:05 <Zekka> There was some guy earlier who  was trying to figure out what (+) and (++) have in common
18:15:20 <Zekka> some other guy was trying to guide him into Monoid
18:15:43 <d10genes> wow, interesting, thanks a lot guys
18:15:49 <Zekka> He made a few comments that briefly had me trying to guide him towards figuring out what a free structure was
18:16:22 <Zekka> but I couldn't think of another readily obvious free structure that doesn't look like a list in lots of other ways
18:16:22 <Iceland_jack> Yeah #haskell is sometimes like a parody of itself :)
18:16:51 <Iceland_jack>     I don't understand what lists are
18:16:51 <Iceland_jack>         Ah you need to learn about free structures!
18:16:52 <Zekka> "nonempty list" (free semigroup) vs "emptiable list" (free monoid) was not a good pair of types to draw the comparison using
18:17:11 <Zekka> A monad's just a monoid in the domain of endofunctors, what's the problem?
18:17:45 <benzrf> CATEGORY of endofunctors
18:17:48 * benzrf whacks Zekka 
18:17:51 <Zekka> Category, you're right!
18:17:53 <benzrf> also
18:17:57 <benzrf> since when is that a monoid
18:18:06 <Iceland_jack> Since when is what a monoid?
18:18:08 <Zekka> benzrf: Since return/(<=<)?
18:18:21 <benzrf> hrm
18:18:32 <Zekka> Think of functions (a -> a), then think of id/(.)
18:18:47 <Zekka> (or, well, think of Endo)
18:18:55 <benzrf> bwaah
18:19:50 <Zekka> :t return
18:19:51 <lambdabot> Monad m => a -> m a
18:19:53 <Zekka> :t (<=<)
18:19:54 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:20:10 <Zekka> benzrf: Does that help at all? I can just write the Monoid instance if you don't feel like deriving it
18:21:35 <benzrf> oh right
18:21:51 <benzrf> :t read <> show
18:21:52 <lambdabot> String -> String
18:22:20 <Zekka> :t return <> return
18:22:20 <lambdabot> (Monoid (m a), Monad m) => a -> m a
18:22:22 <Iceland_jack> > text ((read <> show) "\"hello\"")
18:22:23 <lambdabot>  hello"\"hello\""
18:22:27 <benzrf> :t (<>) `asAppliedTo` show
18:22:28 <lambdabot> Show a => (a -> String) -> (a -> String) -> a -> String
18:22:46 <benzrf> o.O
18:22:52 <benzrf> oh!
18:23:05 <Iceland_jack>     f <> g = \a -> f a <> g a
18:23:05 <Zekka> The default monoid instance for functions just operates on return values IIRC
18:23:08 <benzrf> eya
18:23:10 <Zekka> exactly as Jack described
18:23:12 <Iceland_jack> lifting the functions
18:23:32 <Zekka> which I'd personally argue isn't a terribly useful definition but I could be persuaded
18:23:45 <benzrf>       wjjjjjjjj
18:23:47 <benzrf> oops shit
18:24:24 <Zekka> > (read <> show) "a test of the emergency broadcasting system"
18:24:25 <lambdabot>  "*Exception: Prelude.read: no parse
18:24:31 <Zekka> > (read <> show) "1"
18:24:33 <lambdabot>  "*Exception: Prelude.read: no parse
18:24:38 <Zekka> > (read <> show) "\"1\""
18:24:39 <Iceland_jack> > (read <> show) "\"1\""
18:24:39 <TheKing444> @type <>
18:24:40 <lambdabot>  "1\"\\\"1\\\"\""
18:24:40 <lambdabot>  "1\"\\\"1\\\"\""
18:24:41 <lambdabot> parse error on input ‘<>’
18:24:48 <TheKing444> @type (<>)
18:24:49 <lambdabot> Monoid m => m -> m -> m
18:24:56 <Zekka> TheKing444: It's infix mappend
18:25:18 <Iceland_jack> :t (<>) ∷ Monoid m ⇒ (a → m) → (a → m) → (a → m)
18:25:19 <lambdabot> Monoid m => (a -> m) -> (a -> m) -> a -> m
18:25:40 <benzrf> friggin unicode syndax
18:25:54 <TheKing444> wait, so Monoid m => (a->m) is a monoid
18:25:58 <Iceland_jack> Yes
18:26:08 <Iceland_jack> Functions are monoids if their codomain is
18:26:08 <TheKing444> ah
18:26:22 <Iceland_jack> Allowing the definition I mentioned before
18:26:22 <Iceland_jack>     f <> g = \a -> f a <> g a
18:26:22 <dagle> Yeah, when you get "cat with hat, happy cat with hat, sad cat with hat"... thats when unicode went to far.
18:26:26 <TheKing444> ah
18:26:30 <Iceland_jack> since 'f a' and 'g a' are monoids
18:26:35 <benzrf> ⩴
18:26:45 <benzrf> Iceland_jack: no they arent
18:26:45 <Zekka> Man, I should have asked that guy who wanted to know about bifunctors to try deriving bifunctor for (->)
18:26:46 <benzrf> :3
18:26:54 <benzrf> Zekka: thats mean
18:26:55 <TheKing444> (read "1") <> (show "1")
18:27:02 <Iceland_jack> benzrf: Sorry?
18:27:09 <TheKing444> > (read "1") <> (show "1")
18:27:10 <benzrf> Iceland_jack: f a isnt a monoid
18:27:11 <lambdabot>  "*Exception: Prelude.read: no parse
18:27:26 <benzrf> Iceland_jack: f a's type is a monoid
18:27:27 <TheKing444> (read "\"Yolo\"") <> (show "1")
18:27:33 * benzrf has a shit-eating grin
18:27:40 <TheKing444> > (read "\"Yolo\"") <> (show "1")
18:27:42 <lambdabot>  "Yolo\"1\""
18:27:48 <TheKing444> Yeah!
18:27:58 <Iceland_jack> The only thing worse than being pedantic is being pedantic and wrnog
18:27:58 <Zekka> I kind of favor Benzrf's pedantry when talking with new programmers, mind
18:28:22 <TheKing444> Strings are monoids under (++)
18:28:35 <Zekka> when I was trying to teach Haskell to a friend of mine they regularly conflated typeclasses and types (and sometimes values)
18:29:05 <benzrf> Iceland_jack: im not wrong though
18:29:07 <Zekka> They tended to confuse the types of functions with the definitions of the functions too, for some reason
18:29:27 <benzrf> TheKing444: strings arent monoids
18:29:28 <benzrf> String is a monoid
18:29:29 <benzrf> :3
18:29:34 <Zekka> so I'd ask them to define fmap for [] and they'd say fmap = (a -> b) -> [a] -> [b]
18:29:46 <TheKing444> > mempty :: String
18:29:47 <lambdabot>  ""
18:29:57 <TheKing444> Lol
18:30:10 <benzrf> @djinn (a -> b) -> [a] -> [b]
18:30:11 <lambdabot> Error: Undefined type []
18:30:14 <Iceland_jack> It's very normal to refer to instances of soemthing as that thing
18:30:21 <TheKing444> Sounds like they need category theory.
18:30:26 <benzrf> Iceland_jack: only among newbs
18:30:27 <benzrf> B)
18:30:28 <TheKing444> It should some how help.
18:30:36 <benzrf> yo monochrom back me up
18:30:50 <Zekka> I'll sometimes say it casually, but I shouldn't
18:31:14 <Zekka> actually, come to think of it, I can't think of an example of where I'd casually say it
18:31:33 <Zekka> "integers are monoids under addition" just sounds too wrong
18:31:48 <d10genes> are arrows looked down on by advanced haskellers or am I making that vibe up? they seem unusually intuitive, but I don't see them used often
18:31:52 <TheKing444> why?
18:31:52 <Geraldus> Hi friends!
18:32:05 <benzrf> d10genes: they seem to be
18:32:09 <Zekka> I don't actually know Arrow all that well
18:32:10 <benzrf> Hi Geraldus!
18:32:35 <Iceland_jack> Arrows have in a lot of ways been superceded by Applicative
18:32:37 <Zekka> From what I hear the general assessment is that it's not really very general which means it's rare to see it actually used
18:32:45 <Zekka> I've also heard what Jack's saying
18:33:20 <benzrf> i hear that the Arrow instance for a given type of kleisli arrow is equivalent to the Monad instane
18:33:23 <benzrf> *instance
18:33:24 <Zekka> (I feel disinclined to comment too much on them because I mostly use Arrow as a repository of utility functions for (->) and occasionally Kleisli)
18:33:37 <d10genes> they're a special case of what can be done with applicatives?
18:34:03 <Geraldus> Colloquy crashes every wakeup and LimeChat has weird two panels with chat messages :)
18:35:52 <benzrf> Zekka: same
18:35:57 <benzrf> :k Kleisli
18:35:58 <lambdabot> (* -> *) -> * -> * -> *
18:36:34 <benzrf> :t (&&&) `asAppliedTo` (Kleisli (join replicate))
18:36:35 <Zekka> Let's see, that's m, a, and then b, right? (in a -> m b)
18:36:36 <lambdabot> Kleisli [] Int Int -> Kleisli [] Int c' -> Kleisli [] Int (Int, c')
18:36:59 <TheKing444> > asAppliedTo
18:37:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
18:37:01 <lambdabot>    arising from a use of ‘M754647724763857007122593.show_M7546477247638570071...
18:37:01 <lambdabot>  The type variable ‘b0’ is ambiguous
18:37:01 <lambdabot>  Note: there are several potential instances:
18:37:01 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:37:17 <TheKing444> @type asAppliedTo
18:37:18 <Zekka> TheKing444: It's const with a type that makes it good for pedagogical purposes
18:37:18 <lambdabot> (a -> b) -> a -> a -> b
18:37:39 <Zekka> Read that as (a -> b) -> a -> (a -> b)
18:37:39 <jle`> d10genes: not a special case, but rather an equivalent formulation that is considered more aawkward to work with
18:37:41 <TheKing444> Ah, so it fixes the argument sort of.
18:37:49 <TheKing444> like asTypeOf
18:37:57 <benzrf> :t Kleisli (join replicate) &&& Kleisli (enumFromTo 1)
18:37:58 <lambdabot> Kleisli [] Int (Int, Int)
18:38:01 <jle`> d10genes: Arrows were what we worked with before Applicative got trendy
18:38:02 <d10genes> jle`: ok, thanks
18:38:03 <benzrf> :t fromKleisli
18:38:04 <lambdabot>     Not in scope: ‘fromKleisli’
18:38:04 <lambdabot>     Perhaps you meant ‘runKleisli’ (imported from Control.Arrow)
18:38:21 <Zekka> d10genes: By the way, I meant to tell you
18:38:24 <benzrf> runKleisli (Kleisli (join replicate) &&& Kleisli (enumFromTo 1)) [1, 2, 3]
18:38:27 <d10genes> Applicative is more awkward to work with?
18:38:29 <Zekka> you should totally try to define Bifunctor (->)
18:38:30 <benzrf> > runKleisli (Kleisli (join replicate) &&& Kleisli (enumFromTo 1)) [1, 2, 3]
18:38:32 <lambdabot>  Couldn't match type ‘[t]’ with ‘GHC.Types.Int’
18:38:32 <lambdabot>  Expected type: [t] -> [t] -> [[t]]
18:38:32 <lambdabot>    Actual type: GHC.Types.Int -> [t] -> [[t]]
18:38:33 <benzrf> Zekka: shut it
18:38:34 <d10genes> lol
18:38:37 <jle`> d10genes: Applicative is the less awkward to work with
18:38:43 <d10genes> oh ok
18:38:47 <benzrf> :t runKleisli (Kleisli (join replicate) &&& Kleisli (enumFromTo 1))
18:38:48 <lambdabot> Int -> [(Int, Int)]
18:38:52 <solidus-river> hmm, i'm looking for a function of type
18:38:52 <benzrf> oh
18:38:53 <TheKing444> They are making applicative do notation you know.
18:38:58 <benzrf> > runKleisli (Kleisli (join replicate) &&& Kleisli (enumFromTo 1)) 4
18:38:59 <lambdabot>  [(4,1),(4,2),(4,3),(4,4),(4,1),(4,2),(4,3),(4,4),(4,1),(4,2),(4,3),(4,4),(4,...
18:39:06 <benzrf> shiz
18:39:10 <Zekka> :t (>>)
18:39:11 <lambdabot> Monad m => m a -> m b -> m b
18:39:15 <Zekka> :t (*>)
18:39:16 <lambdabot> Applicative f => f a -> f b -> f b
18:39:20 <benzrf> solidus-river: hoogle that shit
18:39:20 <TheKing444> Actually it is just the monad do notation, except that if it can possibly be applicative it become applicative.
18:39:21 <d10genes> i'll get back w/ you with the answer on that next month, zekka
18:39:29 <benzrf> d10genes: it's a trap!
18:39:30 <Zekka> TheKing444: I was just about to ask about that
18:39:31 <benzrf> there's no such instance
18:39:49 <TheKing444> I think GHC 7.10 will get it.
18:39:55 <TheKing444> Along with FAM.
18:39:58 <d10genes> thanks benzrf, you just saved me a month's work
18:40:03 <TheKing444> I mean FAMP.
18:40:04 <Zekka> Do they expose (<*>)?
18:40:14 <TheKing444> I don't know.
18:40:15 <Zekka> Offhand I'm not sure there's a natural way to do it
18:40:18 <solidus-river> benzrf: highly effective
18:40:28 <solidus-river> foldM
18:40:31 <TheKing444> @lambdabot Do they expose (<*>)?
18:40:31 <lambdabot> Unknown command, try @list
18:40:36 <solidus-river> cant believe i had to hoogle that though
18:40:38 <Zekka> because binding over it would get a value you're only allowed to apply non-applicative functions to
18:40:39 <TheKing444> WHY DO YOU FAIL US LAMBDA BOT?
18:40:46 <carter> lol
18:40:54 <carter> :)
18:41:05 <Iceland_jack> #haskell is in a weird mood
18:41:09 <carter> theres going to be a lot of neat little things making it into 7.10
18:41:11 <carter> Iceland_jack: sup
18:41:14 <Zekka> there's not a neat (>>=)-like thing that can be defined for applicative as far as I know right offhand
18:41:17 <Iceland_jack> hey carter :) long time
18:41:24 <carter> Iceland_jack: hows the hacking
18:41:28 <carter> what're you up to again?
18:41:28 <d10genes> wow, I just realized lambdabot's not some benevolent haskeller quickly answering everyone's ghci queries
18:41:33 <TheKing444> https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
18:41:38 <carter> TheKing444: i know
18:41:43 <Iceland_jack> I've hit a bit of a lull with my thesis carter, but I create a proposal for an extension
18:41:44 <carter> i read ALL of teh ghc tickets
18:41:50 <carter> Iceland_jack: whats the project again?
18:41:51 <jle`> d10genes: these days the main applications of Arrow these days are in Hxl (a templating library, I think) and FRP
18:42:00 <Iceland_jack> the EDSL for FPGAs
18:42:07 <Zekka> People are doing arrow FRP?
18:42:09 <carter> Iceland_jack: what do you think of clash?
18:42:18 <Zekka> I haven't really read up on FRP but I thought most folks were doing it with Applicative
18:42:21 <TheKing444> d10genes It is. It just isn't considered "human", but we don't judge here.
18:42:26 <d10genes> jle` I've been learning a bit of them in HXT
18:42:32 <benzrf> :t foldM
18:42:32 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:42:35 <Iceland_jack> carter: clash is cool :) there is interesting stuff there
18:42:41 <d10genes> or whatever the html parser's called
18:42:47 <TheKing444> :t forM
18:42:48 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
18:42:52 <jle`> d10genes: ah, is it hxt? not totally sure, i haven't used it
18:42:59 <Zekka> TheKing444: So they really are doing <-, but only with pure functions?
18:43:08 <carter> Iceland_jack: wanna propose a talk for haskell implementors workshop?
18:43:13 <carter> you'll be nearby right?
18:43:16 <TheKing444> Oh let me check the site.
18:43:25 <Zekka> I'm not a fan of that at all given that their usecase is "sometimes the monad bind has disastrously wrong behavior that isn't obvious in type"
18:43:34 <Iceland_jack> oh I'll be volunteering for ICFP, I'm not sure about the workshop
18:43:46 <jle`> in any case those are the few domains where Arrow has some apparent benefits of usage over Applicative-based interfaces.  but note that all Arrows have an associated Applicative instance, so in many of those libraries you use them togethere
18:43:51 <carter> Iceland_jack: i meant propose a talk about compiling haskell to funny things
18:43:55 <jle`> togethere
18:43:56 <TheKing444> No, it is just like Monad do notation. Exactly like it.
18:43:59 <carter> jle`: have you ever used arroes?
18:44:06 <carter> *arrows
18:44:13 <jle`> o ye arroes
18:44:14 <TheKing444> The compiler determines at compile time whether it is monad or applicative.
18:44:21 <Zekka> TheKing444: I know
18:44:21 <Iceland_jack> I might be interested in that yes
18:44:31 <Zekka> I mean that it makes me feel a little paranoid that it might >>= when I want it to <*>
18:44:39 <jle`> carter: i use them for frp and i'm designing a toy interactive/automation library using an arrow interface
18:44:43 <TheKing444> I think it basically means no branching.
18:44:46 <Zekka> which as they explicitly said is often evilwrongbad
18:44:47 <jle`> ...sometimes i wonder what i'm doing with my life
18:44:52 <TheKing444> If there is no branching, you get applicative.
18:45:01 <Iceland_jack> (there is always the https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo proposal)
18:45:09 <TheKing444> I why would it matter. You are following the monad-applicative laws, right?
18:45:24 <Zekka> TheKing444: Like they said, there are cases where the wrongness is not reflected in type
18:45:44 <Zekka> i.e. <*> is concurrent, >>= is sequential for whatever type
18:45:56 <jle`> Zekka: how aboat you make a wrapper newtype and only derive the Applicative instance and not the Monad instance
18:46:03 <jle`> probleme?
18:46:06 <Iceland_jack> Where
18:46:06 <Iceland_jack>     do a <- ma; b <- mb; return (f a b)
18:46:06 <Iceland_jack> turns into the applicative
18:46:06 <Iceland_jack>     do (x, y) <- (,) <$> ma <*> mb; return (f x y)
18:46:14 <Zekka> jle`: Oh, yeah, never mind then. That nicely resolves it.
18:46:47 <jle`> Zekka: well, it's a bit annoying still ^_^  but it might give you type safety
18:47:03 <nexion> hey guys, what's a clean way to get from [Just 3, Nothing, Just 1] to [3, 1]? filter out the Nothings, and collect the Justs into a list
18:47:04 <jle`> especially in cases where (<*>) is evaluated differently than ap
18:47:04 <TheKing444> Also it is an extension anyway.
18:47:14 <TheKing444> Not just happening.
18:47:15 <jle`> nexion: um. mapMaybe id? :)
18:47:17 <Iceland_jack> @ty catMaybes
18:47:18 <lambdabot> [Maybe a] -> [a]
18:47:21 <jle`> oh yeah that
18:47:27 <TheKing444> > catMaybes  [Just 3, Nothing, Just 1]
18:47:27 <Zekka> jle`: There's the argument to be made in this case that what the programmer really wants is "as concurrent as possible"
18:47:29 <lambdabot>  [3,1]
18:47:30 <Iceland_jack> > catMaybes [Just 3, Nothing, Just 1]
18:47:32 <lambdabot>  [3,1]
18:47:35 <nexion> oh
18:47:39 <copypasta> newbie cabal help? last month I wrote my first haskell project inside a cabal sandbox, with dependencies on yesod, lens, and diagrams. now I'm trying to build my project on a different computer and I can't install the latest version of both yesod and lens
18:47:46 <Zekka> i.e. GHC will presumably be smart enough to turn any code that doesn't actually have to be monadic into Applicative
18:47:47 <TheKing444> @src catMaybes
18:47:47 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:47:51 <nexion> excellent, thank you
18:47:53 <Iceland_jack> nexion: You can find it like this in the future
18:47:53 <Zekka> (this is probably not very hard)
18:47:53 <Iceland_jack> @hoogle [Maybe a] -> [a]
18:47:54 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
18:47:54 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
18:47:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
18:48:08 <jle`> `
18:48:22 <copypasta> do i need to add specific constraints to all the dependencies shared by both yesod and lens (like mtl)?
18:48:25 <TheKing444> We should have a way to give lambdabot treats.
18:48:29 <Zekka> In that case I think it's reasonable to point out that it would probably be kind of hard to accidentally write monadic code when you mean applicative
18:48:46 <Zekka> you'd need to depend on/branch on a value from higher up the chain
18:48:59 <Zekka> In which case there's often not a good way to Applicatively rewrite it and you actually *meant* Monad
18:49:00 <edwardk> if someone can point to a current version of something lens doesn't work with, i'll happily fix my side
18:49:33 <TheKing444> Why is the lens package so massive? I think it should be broken up.
18:50:46 <copypasta> hi edwardk! I'm on a fresh install of haskell-platform from ubuntu 14.04 (ghc 7.6), and after installing lens 4.2, I can't install yesod-platform and yesod-bin, or vice versa, without dependency conflicts (the --force-reinstalls message)
18:51:18 <edwardk> TheKing444: https://github.com/ekmett/lens/wiki/faq#lens-core
18:52:09 <copypasta> I'm using this command for lens: cabal install lens --constraint=aeson=0.7.0.6, and for yesod: www.yesodweb.com/page/quickstart
18:52:09 <edwardk> copypasta: if you nuke ~/.ghc  and then 'cabal install lens yesod-platform' together what conflicts?
18:52:34 <edwardk> that forces the build plan to consider both
18:52:47 <edwardk> @botsnack
18:52:47 <lambdabot> :)
18:53:06 <copypasta> I'll try that now! I didn't even know that was possible... back in a few minutes :) (and i love having the giant lens package btw, I'm using bits and pieces from all over the place in lens)
18:53:20 <TheKing444> @botsnack
18:53:20 <lambdabot> :)
18:53:24 <TheKing444> Yeah
18:53:26 <edwardk> copypasta: i'm not in a hurry to break it up ;)
18:53:29 <TheKing444> @list
18:53:29 <lambdabot> What module?  Try @listmodules for some ideas.
18:53:33 <TheKing444> @listmodules
18:53:33 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
18:53:41 <TheKing444> @list more
18:53:41 <lambdabot> more provides: more
18:53:45 <TheKing444> @more
18:53:48 <TheKing444> @help more-
18:53:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:53:52 <TheKing444> @help more
18:53:52 <lambdabot>  @more. Return more output from the bot buffer.
18:53:56 <edwardk> the @list chatter should probably move to /msg
18:53:57 <TheKing444> ah
18:54:06 <TheKing444> @slap
18:54:06 <lambdabot> *SMACK*, *SLAM*, take that !
18:54:12 <TheKing444> @todo
18:54:12 <lambdabot> 0. SamB: A way to get multiple results from a google search
18:54:12 <lambdabot> 1. dons: improve formatting of @dict
18:54:12 <lambdabot> 2. dons: write Haskell Manifesto
18:54:12 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
18:54:12 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
18:54:14 <lambdabot> [39 @more lines]
18:54:26 <TheKing444> @more
18:54:27 <lambdabot> 5. TheHunter: @type 1 :: Int
18:54:27 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
18:54:27 <lambdabot> 7. dons: Implement @whatis
18:54:27 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
18:54:27 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
18:54:28 <lambdabot> [34 @more lines]
18:54:31 <edwardk> *hint*
18:54:36 <Zekka> TheKing444: You should probably /query and do it there
18:54:39 <Lutin`> ^
19:02:48 <benzrf> who uses /query?
19:03:09 <benzrf> /msg is where its at
19:06:32 <copypasta> I'm running "cabal install lens yesod-platform yesod-bin --max-backumps=1 --reorder goals" and after ten minutes cabal is still trying to solve dependency constraints :) - think I should kill it and just try lens and yesod-platform without the flags?
19:15:24 <d10genes> is there a quick way for me to find out that `f <*> a = \x -> f x (a x)
19:15:24 <d10genes> ` for ((->) a) with hoogle or something?
19:15:57 <johnw> hmm...
19:16:01 <johnw> I don't think so actually
19:16:14 <Iceland_jack> lambdabot: has sources for many things but not that
19:16:15 <Iceland_jack> @src [] (<*>)
19:16:15 <lambdabot> (<*>) = ap
19:17:29 <d10genes> looks confused with
19:17:30 <d10genes> @src ((->) a) (<*>)
19:17:30 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:18:07 <Iceland_jack> @src (->) (<*>)
19:18:07 <lambdabot> (<*>) f g x = f x (g x)
19:18:09 <Iceland_jack> I was wrong :)
19:18:40 <Iceland_jack> lambdabot apparently has (<*>) definitions for [], Maybe, IO, ((->) a) and ((,) a) instances
19:18:45 <Iceland_jack> (and Maybe)
19:19:36 <d10genes> did l-bot list them for you?
19:19:47 <Iceland_jack> no I just looked here https://github.com/jwiegley/lambdabot/blob/master/State/source
19:20:41 <d10genes> thanks
19:21:54 <d10genes> so I'm assuming there's not a more general hoogle-like way to find `instance Applicative ((->) a)` either?
19:22:18 <d10genes> with all the function (method?) def's
19:22:24 <Iceland_jack> There is a program called haskell-src
19:22:30 <Iceland_jack> @hackage haskell-src
19:22:30 <lambdabot> http://hackage.haskell.org/package/haskell-src
19:22:48 <Iceland_jack> no sorry, it was called something else
19:23:03 <Iceland_jack> haskell-docs
19:23:06 <Iceland_jack> @hackage haskell-docs
19:23:06 <lambdabot> http://hackage.haskell.org/package/haskell-docs
19:24:08 <Iceland_jack> (actually ignore what I'm saying, that's just for documentation and it's not that great)
19:24:14 <Iceland_jack> ~/bin % ./haskell-docs Control.Applicative '<*>'
19:24:14 <Iceland_jack> Sequential application.
19:26:05 <johnw> does anyone know of a proof that applicative functors are closed under composition?
19:27:57 <Iceland_jack> johnw: You can implement
19:27:57 <Iceland_jack>     (Applicative f, Applicative g) => Applicative (Compose f g)
19:27:58 <Iceland_jack> for
19:27:58 <Iceland_jack>     newtype Compose f g a = Compose (f (g a))
19:28:00 <Iceland_jack> and show that's a valid Applicative
19:28:16 <Iceland_jack> sorry if you already knew about Compose and were only looking for the proof
19:28:16 <johnw> right, I would like a bit more formal proof
19:28:32 <dolio> Monoidal functors are closed under composition. QED.
19:28:40 <Iceland_jack> heh
19:28:55 <johnw> I'm doing this proof in Coq right now, and I have all the laws proven except for composition, which is proven inordinately difficult
19:29:20 <Iceland_jack> well can you prove the case for 'pure = pure . pure'?
19:29:20 <johnw> I thought if I could find a paper proof of the same, it would guide me in the right direction
19:29:34 <Iceland_jack> (modulo {,un}wrapping)
19:29:36 <johnw> yes, pure = pure . pure is part of the definition of the composition
19:29:43 <johnw> (of the functors)
19:30:13 <johnw> in case anyone has any thoughts: https://github.com/jwiegley/simple-conduit/blob/master/coq/Functor.v#L460
19:30:31 <johnw> the laws are stated on line 144
19:32:04 <bms1> Has anyone here used the java-bridge package?
19:33:58 <johnw> dolio: maybe I can import you as a module
19:34:38 <johnw> dolio is the arbiter of all truth -> lemma holds. ∎
19:35:03 <Iceland_jack> Proof by know-it-all
19:35:18 <dolio> Which part are you missing?
19:35:27 <dolio> You have five proofs listed, right?
19:35:51 <johnw> pardon the idiom brackets, but I must prove that:
19:36:01 <johnw> [|apply [|apply [|apply (pure (pure (.))) u|] v|] w|] = [|apply u [|apply v w|]|]
19:36:05 <dolio> Oh, is it the one with admit?
19:36:09 <johnw> yes
19:36:26 <johnw> i'm able to transform both sides into many things, but not anything that is anywhere near compatible in a single simplification step
19:37:10 <copypasta> cabal install lens yesod-platform hits the backjumps limit (even up to 4) :( any tips on other things I could try? since installing lens and yesod-platform concurrently worked for me a few weeks ago, I could look in my old sandbox packages for specific versions
19:39:37 <edwardk> copypasta: not sure what is happening to you. try #haskell-lens perhaps? i'd look but my machine isn't in a good state to build other people's code =(
19:40:10 <copypasta> edwardk: thanks, will ask there!
19:40:29 <edwardk> proof by dolio works pretty well if you can manage to get him interested in your problem
19:43:21 <johnw> I need Isabelle's sledgehammer, with dolio as a remote solver
19:44:32 <dolio> johnw: I think you're missing at least one axiom.
19:44:42 <dolio> fmap f (pure x) = pure (f x)
19:45:10 <johnw> i have that as monad_law_4
19:45:27 <dolio> Is that available for applicative?
19:49:08 <johnw> no, but there's no reason it needs to be a monad law
19:49:11 <johnw> i'll just move it into applicative
19:49:16 <johnw> thanks for the suggestion!  trying now
19:50:35 <johnw> i wonder why this is always given as a monad law; we need AMP for the laws :)
19:51:12 <dolio> It's a consequence of pure being a natural transformation.
20:03:42 <johnw> dolio: I can get it down to:
20:03:49 <johnw>  apply <$> ((apply ∘ fmap compose) <$> u <*> v) <*> w = apply <$> u <*> (apply <$> v <*> w)
20:03:50 <johnw> but I'm not sure where/how to apply this new lemma
20:04:34 <johnw> just where
20:05:16 <johnw> oh, wait, this new lemma connects with app_homomorphism
20:07:52 <johnw> dolio: that law is implied by app_homomorphism and app_fmap_unit, btw
20:08:00 <johnw> i don't need to posit it as a fundamental applicative law
20:17:18 <deech> I setup a local Hoogle using the instructions here:https://gist.github.com/blitzcode/8123168 but while the searches are local the links to documentation are to Hackage. How do I generate Haddock locally and tell Hoogle about it?
20:19:27 <benzrf> > [| foo bar |]
20:19:28 <lambdabot>  <hint>:1:2: parse error on input ‘|’
20:19:31 <benzrf> dagle:
20:19:32 <benzrf> *dag
20:19:46 <johnw> deech: Linux?
20:20:42 <deech> johnw: yes.
20:20:42 <heatsink> > {-# LANGUAGE TemplateHaskell #-}
20:20:43 <lambdabot>  not an expression: ‘{-# LANGUAGE TemplateHaskell #-}’
20:21:20 <benzrf> heatsink: nice try
20:21:31 <deech> I'm doing a `cabal world --reinstall --force-reinstalls` right now.
20:25:09 * hackagebot peyotls 0.0.0.2 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.2 (YoshikuniJujo)
20:25:19 <enthropy>  @let {-# LANGUAGE TemplateHaskell #-} -- would have a better chance of working
20:27:39 <johnw> deech: rebuild the world with documentation enabled
20:29:36 <benzrf> enthropy: it doesnt
20:29:42 <benzrf> @let (:^_) = 3
20:29:42 <lambdabot>  Parse failed: Parse error in pattern: :^ _
20:29:45 <benzrf> dang
20:35:11 * hackagebot peyotls 0.0.0.3 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.3 (YoshikuniJujo)
20:36:25 * Clint squints.
20:39:10 <dolio> johnw: I thought it might be.
20:47:35 <lispy> that todo list is as old as the internet
20:48:04 * lispy is referring to the lambdabot todo list
20:50:14 * hackagebot peyotls 0.0.0.4 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.4 (YoshikuniJujo)
21:04:43 <johnw> dolio: any other ideas?
21:07:42 <johnfn> it kind of bugs me that function composition is in reverse order - like i would prefer to consider it as taking some data structure X and piping it through functions a, b and c and then getting some result, rather than c . b . a X which just seems confusing. is there any sort of notation that would get me that?
21:08:19 <johnw> define yourself another operator?
21:08:23 <johnw> lens has & for that
21:08:32 <johnw> others use |>
21:08:40 <johnw> some even like #
21:08:49 <johnfn> mm
21:08:53 <johnfn> there’s no standard?
21:09:12 <johnw> no, I would think that most of us like the current composition order
21:09:15 <johnfn> really
21:09:23 <johnfn> weird :p
21:09:26 <johnw> it better models the "data pull" flow of pure functional languages
21:09:38 <johnfn> can you explain that more?
21:09:46 <johnw> one sec, I'll find you a good explanatiuon
21:09:53 <johnfn> k
21:10:06 <benzrf> johnfn: f (g (h x))
21:10:09 <benzrf> f . g . h
21:10:51 <johnfn> benzrf: yeah, i understand that, but to me that’s more easily understood e.g. in scala as mything.nextStep().nextStep()
21:11:32 <johnfn> f . g . h is reverse order so i have to read backwards … i mean if you’re telling me i’ll eventually get over it than ok
21:12:14 <johnw> I'm not finding the data source that I was thinking of
21:12:19 <johnfn> darn
21:12:23 <johnw> anyway, if you look at a non-side-effecting Haskell function
21:12:34 <johnw> you can view it as a flow of data from arguments to result
21:12:39 <johnw> however, results are only computed as needed
21:12:55 <johnw> so it's rather like a sieve, where you pull at one end, and it draws through all the information it needs to give you that answer
21:13:11 <johnw> the computation is driven by the question you ask, in other words
21:13:19 <johnw> rather than the computation being decided by the arguments you pass in
21:13:53 <johnw> this can be modeled as a data flow graph, in fact
21:13:57 <johnw> which is the reference I was looking for
21:14:12 <johnw> so whenever I see a function composition, I think of the data as being drawn through it
21:14:18 <johnw> rather than push down it
21:14:21 <johnw> pushed
21:14:32 <johnfn> huh
21:14:34 <johnw> because if I put in a variable and no one needs the result, it's not going to go anywhere
21:14:39 <johnw> s/variable/value
21:14:46 <johnw> to use a motive metaphor
21:14:53 <johnfn> hmmmm
21:15:00 <johnfn> that’s interesting
21:16:15 <johnfn> a lil hard for me to grasp right now prob because i dont really have a good feel for how data flows through haskell programs in general, but i’ll keep it in mind
21:16:33 <benzrf> sounds like justification to me
21:16:45 <benzrf> haskell compo is the way it is because of mathematical compo
21:17:00 <benzrf> and math compo is probably the way it is because f(g(x)) -> f o x
21:17:03 <johnw> since I was explaining why I like it, it kind of was exactly justification :)
21:18:01 <johnfn> like i said i get why its the way that it is… but it bothers me that it will be execued reverse of how we type it
21:22:41 <bollu> Question - why is ((->) e) a Monad? It doesn't represent any varying value / State / Computation / impure / non-mathematical thing at all. So why is returning something a Monad? I don't get it.
21:23:58 <joelteon> > liftM2 (||) isAlpha isDigit '3'
21:23:59 <lambdabot>  True
21:24:08 <joelteon> there's one reason
21:24:14 <johnw> Identity is a Monad and it doesn't either
21:24:17 <copumpkin> bollu: nothing in the definition of monad says any of those things oyu listed
21:24:48 <copumpkin> bollu: also, it "is" a container if you squint
21:25:25 <bollu> copumpkin: how so? johnw : Identity is more of a trivial example / simplest monad sort of thing than an actual thing right?
21:25:30 <copumpkin> bollu: say you have an infinite stream of As, that's equivalent to Nat -> A
21:25:42 <johnw> Identity is actually a Monad
21:25:48 <MP2E> bollu : Reader is the idea of reading a fixed value out of an environment. It can be useful if you have a 'global' variable that multiple functions read from. Monads just allow you to thread this 'global environment' without much boilerplate
21:26:04 <MP2E> in this context
21:26:11 <int3__> hm, I wish haskell had a convenient intersection function that took a map and a set and returned a map with keys from the set
21:26:18 <johnw> don't confuse what monads are with what some particular monads do, like State
21:26:21 <int3__> it's annoying to be limited to map + map or set + set
21:27:20 <bollu> johnw: hm, okay. MP2E: -> is called the Reader monad? isn't Reader a different monad?
21:27:45 <bollu> copumpkin: I don't understand what you're trying to say with the Nat -> A thing
21:28:19 <copumpkin> so I have a type of infinite streams
21:28:28 <copumpkin> and it contains values
21:28:41 <copumpkin> data Stream a = Cons a (Stream a) for example
21:28:42 <bollu> copumpkin: okay. with you so far
21:28:53 <copumpkin> it has a function index :: Stream a -> Nat -> a
21:28:59 <copumpkin> to look stuff up in it
21:29:30 <nexion> is there a takeUntil for lists?
21:29:32 <bollu> copumpkin: okay
21:29:33 <copumpkin> you can think of that as a two-argument function, but you can also see it as index :: Stream a -> (Nat -> a)
21:29:49 <copumpkin> now you see it as taking a stream to a function from nats to values
21:29:53 <bollu> so, given a stream, it gives me a function to index it
21:29:56 <copumpkin> yeah
21:29:57 <glguy> ?type takeWhile
21:29:58 <lambdabot> (a -> Bool) -> [a] -> [a]
21:29:58 <dmj`> nexion: takeWhile predicate
21:29:59 <Ralith> int3__: so write one?
21:30:06 <Ralith> int3__: set and map aren't magic...
21:30:07 <copumpkin> bollu: that function fully encodes everything that the stream has to say
21:30:17 <copumpkin> bollu: it is entirely equivalent to the other stream type
21:30:26 <bollu> copumpkin: hm, right, cause the stream is just this function indexed from 0..
21:30:30 <copumpkin> you could write a tabulate :: (Nat -> a) -> Stream a
21:30:36 <copumpkin> and they'd be inverses
21:30:41 <bollu> copumpkin: sure
21:30:45 <nexion> dmj`: oh ya.. thanks
21:30:54 <copumpkin> bollu: so Stream happens to be a monad/applicative/functor
21:31:02 <lfairy> bollu: newtype Reader r a = Reader (r -> a)
21:31:06 <bollu> copumpkin: lost me there. how is it a Monad?
21:31:14 <int3__> Ralith: I was just hoping someone would point out an existing library that takes care of this already :P but yes, I could certainly write one. although my current hack with ordered lists works well enough for my purposes
21:31:22 <copumpkin> bollu: you look down "the diagnoal" for join :: Stream (Stream a) -> Stream a
21:31:24 <bollu> copumpkin: it's just an ADT right? why is it a monad?
21:31:34 <copumpkin> bollu: can't you say the same thing about List?
21:31:47 <bollu> copumpkin: that was actually another question that I had
21:31:48 <copumpkin> it's a monad because I can define the relevant functions that respect the laws
21:31:58 <copumpkin> that's all it takes
21:32:20 <lfairy> bollu: a monad is just an interface. if there's some way in which a structure can implement that interface, then it's a monad
21:32:21 <bollu> copumpkin: that's a skewed way of looking at it no? Oh, this fits x cause it obeys what x is supposed to do? >_<
21:32:28 <copumpkin> bollu: that's literally the definition
21:32:42 <bollu> copumpkin, lfairy: okay, I'll accept that.
21:32:53 <MP2E> 'A monad is a monoid in the category of endofunctors'. This definition at first will make no sense, but one day the realization hits that it's all a monad really *is* :P
21:32:58 <copumpkin> monad is literally just an interface with some properties it's expected to respect
21:33:07 <copumpkin> if you can provide that interface and those properties, you get a bunch of other goodies for free
21:33:12 <lfairy> bollu: yeah, that's how math works
21:33:13 <bollu> MP2E: someone on the IRC explained what that means to me
21:33:24 <bollu> lfairy, copumpkin go on :)
21:33:35 <bollu> copumpkin: what did you mean by the "look down the diagonal" bit?
21:33:48 <copumpkin> well, you have an infinite stream of infinite streams
21:33:49 <cjenkin2> copumpkin: maybe you can help me understand comonads when you have a chance
21:34:08 <copumpkin> cjenkin2: I'm about to go to sleep, but sure, if you can ever catch me when I'm not out :)
21:34:08 <MP2E> cjenkin2 : What's confusing you about Comonads? :>
21:34:08 <bollu> copumpkin: okay, I can imagine that
21:34:37 <copumpkin> bollu: so you take the 0th element from the 0th outer stream, the 1st from the 1st, 2nd from 2nd, and so on
21:34:41 <copumpkin> that's the "diagonal"
21:34:44 <cjenkin2> MP2E: I actually think I understand them OK, I am struggling with a specific instance of them: cellular automata
21:34:45 <bollu> copumpkin: okay
21:34:50 <copumpkin> bollu: that satisfies the monad laws
21:34:57 <bollu> copumpkin: why?
21:35:08 <bollu> copumpkin: just cause you can index the diagonal means it's a monad? how?
21:35:17 * hackagebot peyotls 0.0.0.5 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.5 (YoshikuniJujo)
21:35:18 <copumpkin> well, you check the laws and see that it works out :)
21:35:20 <johnw> cjenkin2: maybe I can help too
21:35:26 <bollu> a[i][i] is legal <- whoo, it's a monad? >_<
21:35:30 <copumpkin> yup
21:35:38 <cjenkin2> johnw: lol, you probably know what I'm on about
21:35:39 <dmj`> int3__: M.filterWithKey (\k _ -> k `elem` S.toList set) map'
21:35:43 <johnw> cjenkin2: :)
21:35:49 <johnw> cjenkin2: where are you having troubles?
21:35:55 <johnw> cjenkin2: can you show me where your code is at now?
21:36:09 <bollu> copumpkin: ... okay, I believe you. (but I'm not sure what the id and join laws have to do with the diagonal) continue
21:36:25 <cjenkin2> I have a hard time thinking that a generic cellular automata qualifies as a comonad. At the very least it has to be non-trivial (non-empty)
21:36:33 <cjenkin2> Sadly, all the comonad stuff is in my head right now
21:36:35 <copumpkin> bollu: that's all there is to it. And if you view the stream as Nat -> a, then the monad instance for ((->) Nat) is the same monad instance
21:36:56 <cjenkin2> I'm thinking, maybe a CA + Index type qualifies instead?
21:37:24 <copumpkin> anyway, really tired
21:37:26 <bollu> copumpkin: ((->) Nat) === (Nat ->) right? (not syntactically, but in terms of meaning)
21:37:27 <cjenkin2> So like, a CA that's "focused" on a particular element
21:37:29 <copumpkin> yeah
21:37:58 <bollu> copumpkin: so, like, (Nat ->) means that  return *something* from a domain of naturals correct?
21:38:04 <copumpkin> yeah
21:38:11 <MP2E> cjenkin2 : cellular automata generally need an index in the actual datastructure to be able to 'extract' the current context we are looking at
21:38:17 <int3__> dmj`: unless haskell does some optimization magic, that would probably be O(logN) less efficient than an intersection of two maps... not significant I know, I'm just being perfectionistic here heh
21:38:24 <MP2E> cjenkin2 : you can implement 'relative' positioning but it ultimately still uses this absolute index
21:38:26 <johnw> cjenkin2: have you seen http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html?
21:38:30 <johnw> see also http://blog.emillon.org/posts/2012-10-18-comonadic-life.html
21:38:31 <johnw> which shows the game of life
21:38:31 <cjenkin2> MP2E: That makes sense.
21:38:37 <cjenkin2> No I have not.
21:38:41 <bollu> copumpkin: 1) don't an infinite number of functions satisfy that property? 2) so, how is this "diagonalizable"? 3) am I keeping you up? :)
21:39:32 <cjenkin2> I'm thinking I should look up a mathematical definition of a CA and see how much it fits my intuition
21:39:33 <copumpkin> bollu: 1) yes! 2) the diagonal analog is the stream of streams, i.e., Nat -> (Nat -> a), and taking the diagonal just means passing the same argument in twice 3) nah, going to sleep in about one minute
21:39:44 <copumpkin> :)
21:39:59 <bollu> copumpkin: :) thanks, I'll transfer over questions to lfairy :P good night!
21:40:06 <copumpkin> good luck!
21:40:11 <glguy> bollu: When people say "T is a Monad" they mean that there are a set of functions fmap, return, join (or return/bind) that satisfy the monad laws for that type
21:40:13 <bollu> copumpkin: thanks. I need it!
21:40:27 <cjenkin2> I'm thinking 1) extract function with an index and 2) a way to assemble a CA of type b when given a function CA a-> I -> B
21:40:31 <dmj`> int3__: it would be O(nm) where n is the # of keys in the map, and m the # of elements in the set
21:40:36 <bollu> glguy: how would one implement >>= on this (Nat->a) ?
21:41:05 <cjenkin2> So: update :: (CA a -> I -> b) -> CA a -> CA b
21:41:21 <johnw> the I should be within CA
21:41:29 <johnw> that is, your CA should know where it has been focused
21:41:31 <MP2E> cjenkin2: That's pretty much right, except I should be in the CA because it is an inherent part of the comonad
21:41:52 <MP2E> But otherwise, sounds spot on. You've essentially declared extract and extend
21:42:02 <cjenkin2> MP2E: How do you mean? It's going to be the same I as in extract
21:42:12 <cjenkin2> extract :: CA a -> I -> CA a
21:42:18 <johnw> extract :: CA a -> a
21:42:20 <MP2E> extract is just CA a -> a
21:42:21 <dmj`> int3__: you can use parallelism
21:42:29 <MP2E> and the I inside of CA is used to 'extract' a
21:42:34 <cjenkin2> I'm using Agda as my mental model, it will be parameterized in a record
21:42:37 <int3__> dmj`: lookup in a map is O(log n) right, so shouldn't it be O(m log n)?
21:42:53 <cjenkin2> MP2E: Eh, I don't know that I like that. *Which* element am I supposed to extract from a CA ?
21:43:05 <cjenkin2> It makes more sense to supply an index
21:43:11 <cjenkin2> (to me)
21:43:24 <dmj`> int3__: I'm filtering, so it would traverse every element
21:43:25 <MP2E> cjenkin2 : the one you are looking at :P and you can supply an index, but that is typically the function peek
21:43:29 <bollu> lfairy, glguy: I accept that (Nat->a) is a monad. now, how does >>= work on this ? because now, my "m" is (Nat->) right? so >>= becomes (Nat->) a -> (a-> (Nat->b) -> Nat b. what does that even mean?
21:43:29 <cjenkin2> and then the comonad is a focused CA I
21:43:43 <cjenkin2> MP2E: Ah, I see. Interesting
21:43:53 <cjenkin2> Think I want to make that explicit, but that makes sense
21:44:50 <johnw> take the list zipper ([a], a, [a]) as an example comonad; there are many values isomorphic to it ('n' to be exact), with each one presenting a different 'a' between the left and right lists
21:44:59 <edwardk> bollu: its clearer if you consider join
21:45:08 <glguy> bollu: I'll have to work out what bind is for steams off the top of my head, I'll have to work it out
21:45:12 <johnw> so, ([], 1, [2,3,4]) ([1], 2, [3,4]), ([1, 2], 3, [4]), etc.
21:45:18 <johnw> this way we encode the focus in the data type
21:45:30 <edwardk> (Nat -> Nat -> a) -> Nat -> a -- you have a nat pass it for both arguments
21:46:00 <int3__> dmj`: ah. then that does seem even more inefficient than mapping the set to the lookup values of the map...
21:46:17 <bollu> edwardk: join converts m m a to m a right?
21:46:19 <edwardk> @djinn (nat -> nat -> a) -> nat -> a
21:46:19 <lambdabot> f a b = a b b
21:46:25 <edwardk> yeah
21:46:41 <edwardk> @djinn (nat -> a) -> (a -> nat -> b) -> nat -> b
21:46:41 <lambdabot> f a b c = b (a c) c
21:46:43 <bollu> edwardk: hm okay, I can see how join would be implemented - same way you index a 2d array in 1d
21:46:58 <edwardk> well, it walks the diagonal of the array
21:47:08 <edwardk> it doesn't hit the whole thing
21:47:19 <bollu> edwardk: join? why only the diagonal?
21:47:41 <edwardk> because it calls a i i     with the same i
21:48:00 <edwardk> when you work it out that is actually the only thing it can do
21:48:02 <bollu> edwardk: what is "it" in that sentence?
21:48:12 <edwardk> :t join
21:48:13 <lambdabot> Monad m => m (m a) -> m a
21:48:17 <edwardk> the monad for (->) x
21:49:05 <bollu> edwardk: no, but it's Nat -> Nat -> a right? so it takes *two* naturals right?
21:49:14 <bollu> edwardk: why does it only take "one" natural?
21:49:22 <Abathurr> cover letters are worthles
21:50:09 <edwardk> (Nat -> Nat -> a) -> Nat -> a  -- you have to convert from 1 natural to 2 -- in a way that is associative and such that it has return as the identity. the only choice is the diagonal function that takes and calls with the same argument both times
21:50:16 <glguy> Abathurr: that'd definitely not true
21:50:18 * hackagebot peyotls 0.0.0.6 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.6 (YoshikuniJujo)
21:50:23 <edwardk> there are no interesting comonoids on Hask, and anything else would imply one exists ;)
21:51:11 <edwardk> return :: a -> Nat -> a   -- is const
21:51:18 <bollu> edwardk: you have to convert from *2* naturals to *1* right?because you take 2 naturals on your LHS and you return a function which takes *1* Nat and gives you a on the RHS
21:51:22 <edwardk> so you need a function that when you ignore its second argument gives you the first
21:51:30 <edwardk> wrong direction
21:51:42 <edwardk> you take a function that needs 2, and you need to give me a function that takes 1
21:51:54 <edwardk> you have a function that wants 2 naturals and you only have one to give
21:52:12 <bollu> edwardk: why do I only have one natural to give?
21:52:21 <edwardk> (Nat -> Nat -> a) -> Nat -> a
21:52:50 <edwardk> f :: Nat -> Nat -> a  -- is the function you need to call   x :: Nat  is your only Nat
21:52:59 <edwardk> now, give me an a
21:53:05 <edwardk> you can call f x x
21:53:28 <edwardk> you can try to do other things to the Nat you have to get two different nats, but i can shoot all of them down with the monad laws
21:53:42 <edwardk> so the only thing you can do is call f x x
21:54:37 <bollu> let's say d = (Nat -> Nat -> a) and r = (Nat -> a). so join:: d -> r, where d takes 2 naturals, and r takes 1 natural
21:55:21 <bollu> edwardk: what you're saying is that I need to call join with only one Nat -> a, so the only way I can do it is to pass the diagonal
21:55:24 <bollu> right?
21:57:13 <edwardk> turn your perspective around a bit
21:57:22 <edwardk> you are writing a function (Nat -> Nat -> a) -> Nat -> a
21:57:25 <edwardk> so you get two arguments
21:57:27 <bollu> edwardk: yes
21:57:30 <edwardk> one f :: Nat -> Nat -> a
21:57:34 <edwardk> one x :: Nat
21:57:43 <edwardk> now you have to derive a result :: a
21:57:51 <bollu> edwardk: ah
21:58:00 <edwardk> to get there the only things you can do is try to massage x into two nats to call f
21:58:02 <edwardk> thats all you have
21:58:15 <edwardk> since f is your only lifeline to get out an a
21:58:37 <edwardk> it turns out if you try to pass a modified x as one of the arguments to f i can call you out on it
21:58:53 <kvanb> does anyone know how to work with mtl if you have 2 layers of StateT?
21:58:54 <bollu> edwardk: I wasn't considering the x::Nat, I was considering a partially applied version of it.
21:58:56 <edwardk> when you go to check the monad laws w.r.t. return, since the return :: a -> Nat -> a  = const
21:59:01 <kvanb> must you explicitly lift one?
21:59:09 <lfairy> kvanb: use lift
21:59:09 <kvanb> even if it's, say, 4 layers deep
21:59:15 <kvanb> bugger
21:59:22 <kvanb> and I assume get/put only detect the outmost?
21:59:28 <kvanb> So I should put the inner one the one I use less
21:59:37 <Zekka> kvanb: You can define a MonadState instance for either one, but only for one of them
21:59:43 <edwardk> kvanb: my recommendation is to avoid multiple states. make some kind of class that lets you access the part of the states you want, then use those
21:59:48 <bollu> edwardk: return would be return::a -> Nat a right?
21:59:57 <edwardk> class HasFoo t where getFoo :: t -> Foo; setFoo :: Foo -> t -> Foo
22:00:06 <kvanb> well, pipes-parse uses a StateT internally for parse tracking
22:00:11 <edwardk> now you can work with gets getFoo   -- instead of get
22:00:15 <kvanb> but I need my own state too
22:00:19 <kvanb> that's the only reason I need two.
22:00:24 <cjenkin2> lfairy: by "lift" you mean converting one monad to another explicitly?
22:00:40 <lfairy> kvanb: try wrap your StateT in a newtype, and defining new primitives on top
22:01:11 <kvanb> doesn't that create n^2 instances?
22:01:11 <lfairy> cjenkin2: yep
22:01:15 <kvanb> if I'm using mtl
22:01:22 <bollu> edwardk: return :: a -> (Nat -> a) is your return, okay. so you return a stream [a, a, a..] ?
22:01:32 <kvanb> or well, just n instances.
22:01:51 <dmj`> int3__: if you're using Int as the key to your Map, why not use an IntMap?
22:01:51 <lfairy> kvanb: what's your use case? you only need n instances if you want automatic lifting
22:01:59 <cjenkin2> I was hoping there was some other way, but I guess I *was* doing it correctly
22:02:45 <cjenkin2> lambdabot: :t lift
22:02:55 <edwardk> bollu: yeah only thing it can do. it has to work for all choices of a
22:02:58 <MP2E> :t lift
22:02:58 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
22:03:00 <edwardk> so it has to be oblivious to the choice of nat
22:03:06 <MP2E> weird, it doesn't like being highlighted I guess :P
22:03:17 <bollu> edwardk: right, okay
22:03:21 <kvanb> lfairy: that was the whole point because otherwise I'd just skip all the trouble and use lift . lift . lift everywhere
22:03:37 <bollu> edwardk: what happens if I put some sort of constraint on my Monad, such that a has to be Num or something?
22:04:09 <cjenkin2> MP2E: So that says, give me a monad m and some way of doing transformations on it?
22:04:13 <cjenkin2> :t MonadTrans
22:04:14 <lambdabot> Not in scope: data constructor ‘MonadTrans’
22:04:16 <lfairy> kvanb: why not just define a few helper functions? liftFoo = lift . lift; liftBar = lift . lift . lift
22:04:22 <cjenkin2> :k MonadTrans
22:04:23 <lambdabot> ((* -> *) -> * -> *) -> Constraint
22:04:30 <cjenkin2> yuk
22:04:53 <cjenkin2> what's the doc function?
22:04:54 <kvanb> tbh I'm not enlightened by the idea
22:04:55 <bollu> edwardk: but do continue. so, I have return (which returns a constant stream), and I have join(which uses the diagonal)
22:05:02 <bollu> edwardk: so what does that imply ?
22:05:04 <kvanb> I'll just refrain usage to as little places as possible and hardcode it
22:05:52 <lfairy> kvanb: I just don't understand why you have a stack 4 layers deep :P
22:05:57 <kvanb> an :: Inner wrapper type would be cool, that autolifts one layer deeper
22:05:59 <MP2E> cjenkin2 : It just says "give me a monad or a function that operates on a monad and I will lift that to the Monad Transformer plane" It's sorta like fmap, except only for Transformers
22:07:17 <MP2E> cjenkin2 : using multiple lift functions composed into each other allows you to push a function 'down' into a Transformer stack
22:07:40 <edwardk> bollu: the constraints on your monad where? on the a ? you can't put constraints on the result
22:07:59 <MP2E> I say down, because despite the type looking like 'm a -> t m a' the Transformer actually sandwhiches itself in between the base monad and the regular type
22:08:26 <cjenkin2> MP2E: So, for what do MonadIO and MonadTrans have in common?
22:08:33 <bollu> edwardk: hm, okay, so I can't constrain a to Num or something. fine. so, now, I get how return and join would work
22:08:44 <cjenkin2> it's not clear from the source
22:08:51 <edwardk> they do work. just check the laws
22:08:57 <bollu> edwardk: what abour fmap? :) we take a function a then return another infinite stream with the function applied correct?
22:09:09 <edwardk> fmap is fully determined by the types
22:09:14 <edwardk> yeah
22:09:51 <bollu> edwardk: so now we have join, return and fmap, hence it's a Monad?
22:10:00 <MP2E> cjenkin2 : MonadTrans is a typeclass that defines anything that is a Monad Transformer, MonadIO is a typeclass that covers anything to do with IO. mtl decided to do this to avoid writing similar code twice
22:10:09 <MP2E> cjenkin2: for instance, look at the definition of State, it might surprise you :P
22:10:20 <MP2E> it will probably make more sense after that
22:11:39 <bollu> edwardk: did I get that right?
22:11:50 <cjenkin2> MP2E: One more question: where does this Constrain pop up? I don't see it in the definition of MonadTrans
22:11:54 <cjenkin2> *Constrant
22:12:04 <cjenkin2> wow, can't spell tonight
22:12:12 <MP2E> which constraint?
22:12:21 <MP2E> MonadTrans being the base of any transformer?
22:12:30 <roboguy_> cjenkin2: it's because it's a type class
22:12:30 <cjenkin2> MP2E: Yup
22:12:35 <solidus-river> jle`: can i bug you with another netwire question?
22:12:42 <roboguy_> :k Functor
22:12:43 <lambdabot> (* -> *) -> Constraint
22:12:45 <cjenkin2> roboguy_: so any type class is a constraint?
22:12:48 <cjenkin2> gotcha
22:13:09 <cjenkin2> roboguy_: can you relate Constraints to me in Agda terms?
22:13:35 <roboguy_> cjenkin2: I'm not familiar with Agda, but Constraints are the things that go on the left side of => in type signatures in Haskell
22:13:53 <roboguy_> they are essentially propositions about types
22:13:53 <cjenkin2> roboguy_: So, typeclass? xP
22:13:57 <roboguy_> yep!
22:14:07 <roboguy_> well
22:14:09 <roboguy_> :k (~)
22:14:10 <lambdabot> k -> k -> Constraint
22:14:12 <roboguy_> that too
22:14:24 <roboguy_> that's the type equality operator
22:15:19 <maybefbi> why people people add co- prefix to some typeclasses like cofunctor, comonad, coapplicative, etc.
22:15:26 <maybefbi> *why do people
22:15:28 <cjenkin2> roboguy_: Ok, Constraint refers to a specific type of proof-inhabitant
22:15:30 <roboguy_> maybefbi: it comes from category theory
22:15:36 <MP2E> maybefbi : co is the mathematic term, it means opposite
22:15:42 <cjenkin2> maybefbi: becase sometimes we like to reverse the direction of the arrows :D
22:15:45 <MP2E> flip the arrows around
22:15:45 <MP2E> !
22:15:54 <maybefbi> oh cool
22:15:59 <roboguy_> maybefbi: if you take a category and flip all the morphisms around, you get the "opposite category" and opposite categories name's are traditionally prefixed with "co-"
22:15:59 <maybefbi> yeah makes sense
22:16:11 <cjenkin2> maybefbi: so for instance, comonads are the "opposite" of monads
22:16:12 <maybefbi> hehe thats a nice convention
22:16:16 <roboguy_> usually there is a nice relationship between a category and its opposite category
22:16:25 <cjenkin2> they consume context rather than produce it
22:16:42 <roboguy_> and it lets you have a nice precise definition of things like contravariance (w.r.t. functors)
22:16:57 <maybefbi> so comonad bind would be bind :: m a -> (m a -> b) -> m b
22:17:23 <roboguy_> maybefbi: yep!
22:17:25 <roboguy_> :t (=>>)
22:17:26 <lambdabot>     Not in scope: ‘=>>’
22:17:26 <lambdabot>     Perhaps you meant one of these:
22:17:26 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
22:17:28 <MP2E> maybefbi: exactly, they call it extend usually
22:17:37 <maybefbi> lol thats cool
22:17:50 <MP2E> extend/extract
22:17:55 <roboguy_> maybefbi: and "coreturn" is m a -> a
22:17:56 <cjenkin2> maybefbi: they call "coreturn" peek: w a -> a
22:17:58 <kvanb> I am very confused. I keep getting "Type synonym ‘Parser’ should have 3 arguments"
22:18:02 <cjenkin2> it's usually spelled w
22:18:03 <MP2E> not *quite* as useful as monads, but comonads are very fun in their own ways :)
22:18:07 <cjenkin2> like, an upside down m xD
22:18:20 <maybefbi> ok
22:18:20 <kvanb> My type looks like this: type ServerState m = ErrorT ServerPipelineException (Parser ByteString m)
22:18:20 <edwardk> maybefbi: also note 'cofunctor' = functor, for technical reasons. so when someone says cofunctor they aren't making sense ;)
22:18:34 <edwardk> maybefbi: the other co- constructions usually do make sense ;)
22:18:38 <cjenkin2> edwardk: or making a joke
22:18:42 <kvanb> where type Parser a m r = forall x. StateT (Producer a m x) m r
22:18:51 <maybefbi> hehe yeah cofmap :: (b -> a) -> f b -> f a
22:19:00 <maybefbi> yeah it looks the same
22:19:10 <kvanb> .. but clearly I can't have the result inside my synonym ?
22:19:16 <roboguy_> maybefbi: well, there are contravariant functors too
22:19:21 <bollu> edwardk: thanks for the help, I think I get it now :)
22:19:36 <roboguy_> which isn't quite the dual, but it does have one part flipped
22:19:43 <merijn> kvanb: You cannot have partially applied type synonyms
22:19:45 <Zekka> Contravariant functors implement contramap :: (a -> b) -> f b -> f a
22:20:06 <merijn> kvanb: Add extra parameters to the ServerState definition to ensure all type synonyms inside are completely applied
22:20:16 <roboguy_> maybefbi: here's an interesting exercise, if you haven't seen them before: find a contravariant functor
22:20:21 * hackagebot peyotls 0.0.0.7 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.7 (YoshikuniJujo)
22:20:21 <kvanb> merijn: that's a bugger because ErrorT wants * -> *
22:20:28 <kvanb> if I fully apply Parser it becomes * and I lose
22:20:56 <Zekka> Here's another fun one: find a functor that's both contravariant and covariant
22:20:57 <merijn> kvanb: Manually expand the Parser synonym in your type? :)
22:20:57 <kvanb> if I don't fully load Parser then I get the "should have 3 arguments" error
22:21:13 <kvanb> well, ok.
22:21:58 <Zekka> that is, implement contramap :: (a -> b) -> f b -> f a *and* fmap :: (a -> b) -> f a -> f b
22:22:36 <maybefbi> :)
22:23:10 <kvanb> merijn: nope, can't  get it.
22:23:28 <kvanb> I end up with type ServerState m = ErrorT ServerPipelineException (StateT (Producer ByteString m x)) m r
22:23:38 <kvanb> woops.
22:24:39 <enthropy> Zekka: are there useful ones? (Const seems to be pretty useless)
22:24:43 <augur> ok haskellers
22:24:43 <augur> question time
22:24:52 <Zekka> enthropy: There may be but I don't know one offhand
22:24:59 <Zekka> Also, Const isn't useless! But I can understand why you'd feel that way.
22:25:05 <roboguy_> enthropy: they are useful for lenses
22:25:13 <augur> how can i represent a collection of values which have a hierarchical "more-specific/less-specific" structure?
22:25:21 * hackagebot peyotls 0.0.0.8 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.8 (YoshikuniJujo)
22:25:37 <roboguy_> enthropy: there's a nice property that all types that can implement both contravariant and covariant type classes have that make them useful for lens
22:25:39 <merijn> kvanb: That's not the same type, "type ServerState m r = forall x . ErrorT ServerPipelineException (StateT (Producer ByteString m x) m r"
22:25:40 <augur> for example: `word` is less specific, and has some more specific variants, namely, `verb`, and `noun`
22:25:59 <merijn> kvanb: But in general having pipes-parse parser on the bottom of you stack is most likely not what you want
22:26:00 <augur> `verb` has several more specific variants as well, namely, `untensed-verb` and `tensed-verb`
22:26:01 <roboguy_> enthropy: also, Const can be handy. especially it's Applicative instance
22:26:08 <cjenkin2> augur: you sure know how to ask the easy questions xD
22:26:14 <kvanb> why not
22:26:18 <augur> and `tensed-verb` also has more variants, namely `past-tense-verb` and `present-tense-verb`
22:26:22 <cjenkin2> how about: OO inheritance xP
22:26:24 <augur> cjenkin2: :)
22:26:41 <augur> cjenkin2: that is unfortunately how this is usually handled in linguistics
22:26:43 <edwardk> enthropy: Const r  has that property, so does Reverse (Const r)   and Backwards (Const r)
22:26:46 <augur> well, not quite OO, but
22:27:10 <cjenkin2> augur: I actually thinking prototype based OO is the best suited for NP
22:27:14 <edwardk> enthropy: that matters to lens since it tends to just use the contravariance to its advantage as needed and picks up those functor wrappers as it goes based on what you compose in
22:27:20 <augur> cjenkin2: np?
22:27:22 <cjenkin2> I wonder if anyone has done research along those lines
22:27:27 <cjenkin2> NLP, sorry
22:27:34 <cjenkin2> I've a few drinks tonight
22:27:40 <edwardk> everything that is a legal Functor and Contravariant in that same argument actually can't use the argument.
22:27:53 <kvanb> Oof
22:27:56 <kvanb> I need rank2types
22:28:01 <kvanb> that's just horrendously leaky
22:29:07 <cjenkin2> augur: Basically I think trying to define interfaces separate from the data is far too brittle, even if you are taking a snapshot of a language and not modeling it through time
22:29:34 <augur> cjenkin2: the only solution i know of is to have an actual explicit tree structure representing the "subtyping", and just have a set of values
22:29:59 <augur> like...   data Vals = Word | Noun | Verb | UntensedVerb | TensedVerb | PastTenseVerb | PresentTenseVerb | ...
22:30:00 <cjenkin2> augur: That's the only thing I could think of too, besides inventing a type theory for prototype based objects :)
22:30:02 <merijn> kvanb: What is leaky?
22:30:15 <cjenkin2> have at it
22:30:16 <kvanb> the forall
22:30:21 * hackagebot peyotls 0.0.0.9 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.9 (YoshikuniJujo)
22:30:31 <augur> and then have a tree   Tree Word [Tree Noun ..., Tree Verb [Tree UntensedVerb ..., Tree TensedVerb ...]]
22:30:37 <merijn> kvanb: I have no clue what you mean by leaky w.r.t. the forall
22:30:47 <cjenkin2> Yes, and how tedious and error prone that would be
22:30:52 <merijn> pipes-parse needs Rank2Types anyway, afaik
22:31:10 <kvanb> I'm just a sad sop right now, sorry.
22:31:33 <cjenkin2> Natural language did not develop in a nice top-down, abstract way.
22:31:51 <cjenkin2> It's never going to be modeled well that way, imo
22:32:03 <roboguy_> augur: what about a property set?
22:32:21 <roboguy_> that might not be as type safe as you'd like though
22:34:14 <johnw> cjenkin2: did you resolve your issue?
22:34:20 <kvanb> merijn: Must I expand out the type?
22:34:33 <cjenkin2> johnw: with comonads? I think so. It was a conceptual one.
22:34:43 <kvanb> I would really prefer to use the synonym provided by pipes.parse
22:34:46 <johnw> how did you fix the concept?
22:34:47 <cjenkin2> People here seem to be saying I'm on the right track - I was convinced I was missing something
22:34:47 <roboguy_> you might be able to throw in a phantom type to help
22:34:54 <kvanb> I made it compile, finally, using the type you provided
22:35:11 <cjenkin2> Oh, apparently "peek"/"coreturn" is usually formulated to have an implicit focus
22:35:12 <merijn> kvanb: Well, why are you trying to wrap the ErrorT around the parser, rather than the Parser around the ErrorT?
22:35:22 * hackagebot peyotls 0.0.0.10 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.10 (YoshikuniJujo)
22:35:25 <MP2E> Only thing I could really think of is to have seperate datatypes for each sub-level. Like have one that is : 'data AbstractVals = Noun | Verb | Adjective | Preposition | Punctuation' and then have a pass that evaluates it to a more specific data-type in passes
22:35:28 <kvanb> I had little success wrapping a Pipe around the latter
22:35:29 <cjenkin2> and I decided I didn't like that, but i was sure I was making a mistake
22:35:34 <MP2E> isn't the cleanest either :D
22:35:37 <kvanb> exactly the same error, the Pipe expects * -> *
22:35:51 <cjenkin2> *mistake in thinking of how the focus was done.
22:36:09 <johnw> right, makes sense
22:36:24 <cjenkin2> So I would probably define a CA with a cell type and an index type
22:36:34 <cjenkin2> and declare the comonad type to be a CA x I
22:37:08 <kvanb> so, if I do this: type ServerState m r = Parser ByteString (ErrorT ServerPipelineException m) r
22:37:27 <merijn> kvanb: I'm not sure exactly what you're trying to do, you might wanna ask the pipes mailing list, they're usually really helpful
22:37:47 <roboguy_> cjenkin2: sounds like a zipper
22:38:15 <cjenkin2> roboguy_: just about to read that article, actually :) But it's 2D, so don't know what the proper analogy is
22:38:25 <roboguy_> cjenkin2: a 2D zipper
22:38:28 <cjenkin2> I kind of like to think of it as a lens, but that's taken. Microscope?
22:38:57 <cjenkin2> Well if that's what it's called I guess I have no choice but to conform. But I like microscope better xD
22:39:16 <bluebelle> What do you do if a package failed to install due to missing .dylib (in OSX)?
22:39:20 <augur> roboguy_: you mean like have a bunch of lists like..   verb = [PastTenseVerb, PresentTenseVerb, ProgressiveVerb, ...]   and   tensedVerb = [PastTenseVerb, PresentTenseVerb] etc?
22:39:22 <bluebelle> Is fore-reinstall safe?
22:39:26 <roboguy_> cjenkin2: haha, yeah that's what I'd probably call it. you can generalize zippers to arbitrary dimensions
22:39:55 <roboguy_> in fact, you can generalize them so that they don't (necessarily) involve lists iirc
22:40:02 <roboguy_> augur: yeah
22:40:07 <roboguy_> well
22:40:14 <cjenkin2> roboguy_: or "eye of god" but that's too long and charged
22:40:15 <roboguy_> I was thinking pretty much the opposite of that
22:40:21 <roboguy_> but something like that
22:41:13 <roboguy_> what I was thinking was more along the lines: pastTenseVerb = Set.fromList [Past, Tensed, Verb]
22:41:32 <augur> oh
22:41:34 <cjenkin2> So if your declaration is: class Functor w => Comonad w where
22:41:42 <cjenkin2> does that mean you must be a Functor first?
22:41:46 <roboguy_> yeah
22:41:55 <cjenkin2> Aight, thanks
22:41:58 <merijn> cjenkin2: What does "first" mean?
22:42:02 <augur> roboguy_: well, i dont think it makes sense to separate these
22:42:04 <augur> i mean
22:42:08 <augur> tense only appears on verbs
22:42:14 <augur> and past is a special case of tensedness
22:42:32 <cjenkin2> merijn: I mean, before you can even be a Comonad you must also be a Functor
22:42:35 <roboguy_> augur: you could probably add a phantom type to restrict that: Tensed :: WordProperty Verb
22:42:36 <merijn> cjenkin2: It means "w is an instance of Comonad IFF w is a Functor"
22:42:49 <johnw> merijn: heya!
22:42:49 <augur> roboguy_: eh..
22:42:50 <merijn> *is an instance of Functor
22:42:56 <roboguy_> augur: and then the no-heterogenous list thing would actually help!
22:43:04 <cjenkin2> merijn: not sure, since you must also supply these other functions
22:43:05 <merijn> johnw: Ola, I'm still jetlagged to hell :p
22:43:12 <augur> thats a really ugly solution :(
22:43:18 <cjenkin2> roboguy_: oh, I've had a small epiphany I think
22:43:42 <cjenkin2> The same notation but with "instance" gives you a "if you're an X then you're automatically a Y"
22:43:49 <roboguy_> augur: yeah. OO is probably the nicest looking solution and I can't think of a good way to embed this subtype relationship in haskell. deja vu, haha
22:44:00 <merijn> cjenkin2: My point was more that "first" implies an ordering of instances, but there is none. There is (in GHC's view) no such thing as "this Functor instance comes before this Comonad instance"
22:44:01 <glguy> merijn: Not "IFF", just "only if"
22:44:25 <cjenkin2> glguy: ^
22:44:56 <cjenkin2> merijn: I'm only talking about logical precedence. Functor is necessary for Comonad
22:45:20 <roboguy_> cjenkin2: a type must always satisfy the propositions on the left of a => for it to type check
22:45:33 <roboguy_> all the types involved have too, that i
22:45:34 <roboguy_> is
22:45:38 <cjenkin2> roboguy_: right, of course.
22:46:08 <cjenkin2> I'm actually fairly hip with proof objects. Just not with Haskell's way of doing it
22:46:48 <roboguy_> I like the type proposition view of type classes because it extends nicely to multiparameter type classes being like relations between types
22:48:06 <cjenkin2> roboguy_: no co-product typeclasses out there, right?
22:48:25 <cjenkin2> I don't think that's a thing, anyway
22:48:49 <roboguy_> cjenkin2: actually, kinda
22:48:58 <roboguy_> cjenkin2: the Choice class http://hackage.haskell.org/package/profunctors-3.2/docs/Data-Profunctor.html
22:50:12 <cjenkin2> heh
22:50:21 <cjenkin2> that's kind of neat
22:52:49 <roboguy_> it's not a type class, but Either is like a coproduct in the category of Haskell types and functions
22:53:02 <roboguy_> actually, I think it is a coproduct exactly
22:53:27 <cjenkin2> roboguy_: it definitely is
22:54:07 <MP2E> oh coproduct = sum type
22:54:09 <MP2E> derp
22:54:10 <MP2E> yeah
22:54:17 <MP2E> List is also a Sum AND Product type :)
22:54:18 <cjenkin2> oh geez, i'm such a perfectionist. I just realized my zipper has to have it's left be a snoc list
22:54:22 <cjenkin2> *its
22:55:07 <cjenkin2> MP2E: So is Nat I think, if you think of it as carrying trivial information
22:55:19 <cjenkin2> nice parallels there
22:55:22 <dwcook> cjenkin2, everything is a trivial sum and product
22:55:38 <dwcook> a ~ Either Void a
22:55:44 <dwcook> a ~ ((), a)
22:55:54 <dwcook> (barring bottom)
22:56:14 <augur> dwcook!
22:56:15 <cjenkin2> dwcook: actually bottom is the nullary sum
22:56:22 <cjenkin2> and top the nullary product
22:56:29 <dwcook> cjenkin2, no, I mean those isomorphisms hold only in the absence of bottom
22:56:30 <augur> cjenkin2: wrong top/bottom
22:56:32 <dwcook> augur!
22:56:46 <cjenkin2> augur: oh whoops
22:56:48 <augur> cjenkin2: "bottom" in the sense dwcook means it is "non-termination" / "error" value
22:56:53 <augur> not "empty type"
22:57:04 <cjenkin2> heh, not the "empty but not really" type
22:57:43 <cjenkin2> dwcook: I'm coming from a total language, pardon the confusion
22:57:52 <dwcook> cjenkin2, no worries
22:58:57 <cjenkin2> roboguy_: The thing I like about my approach to CA is it's shape-agnostic
22:59:38 <cjenkin2> I would only try n-dimensional zippers in J or APL
23:00:09 <roboguy_> cjenkin2: lens had a zipper like that but they took it out so that they can move it (at some point) to a separate package
23:00:17 <roboguy_> https://hackage.haskell.org/package/lens-3.7.1.2/docs/Control-Lens-Zipper.html
23:03:18 <glguy> http://hackage.haskell.org/package/zippers
23:03:36 <roboguy_> glguy: oh, I didn't know it was on hackage yet. nice!
23:15:25 * hackagebot http-kit 0.5.1 - A low-level HTTP library  http://hackage.haskell.org/package/http-kit-0.5.1 (SimonHengel)
23:33:15 <lessless> Hi folks! Help me please with task in the book: Write an expression that concatenates two lists given inside another lists. For example, it should return "abcde" for ["abc","de"].
23:33:37 <lessless> I really have doubts about how I solved this
23:33:48 <solidus-river> lessless: how did you solve it?
23:33:56 <Hafydd> Is that really what the task says?
23:33:58 <lessless> at first I tried  (head ["asd","dad"]) ++ (tail ["dcea","zcx"])  but tail tail ["dcea","zcx"] returns [[Char]] and head  returns  [Char] which are incompataible, so I added extra head
23:34:09 <Pythonfant> lessless: what should happen if there are less or more than two lists inside the outer list?
23:34:09 <lessless> (head ["asd","dad"]) ++ (head(tail ["dcea","zcx"]))
23:34:26 <solidus-river> > flatten ["abcd","efgh"]
23:34:28 <lambdabot>  Couldn't match expected type ‘Data.Tree.Tree a’
23:34:28 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
23:34:32 <solidus-river> lol
23:34:41 <Zekka> lessless: That seems to be a separate problem
23:34:43 <solidus-river> > flatten [["abcd"],["efgh"]]
23:34:45 <lambdabot>  Couldn't match expected type ‘Data.Tree.Tree a’
23:34:45 <lambdabot>              with actual type ‘[[[GHC.Types.Char]]]’
23:34:47 <Zekka> > concat ["abcd, "efgh"]
23:34:48 <lambdabot>  <hint>:1:23:
23:34:49 <lambdabot>      lexical error in string/character literal at end of input
23:34:49 <solidus-river> i give up
23:35:01 <Zekka> > concat ["abcd, "efgh"]
23:35:02 <lambdabot>  <hint>:1:23:
23:35:02 <lambdabot>      lexical error in string/character literal at end of input
23:35:05 <Zekka> Oh, I missed a quote
23:35:09 <Zekka> > concat ["abcd", "efgh"]
23:35:10 <lambdabot>  "abcdefgh"
23:35:12 <platz> The zippers in clojure are particularly nice (http://clojuredocs.org/clojure_core/clojure.zip/zipper).  Unfortunately there are several different zipper impl in haskell
23:35:14 <solidus-river> lol
23:35:26 <Hafydd> Well done, #haskell.
23:35:27 * hackagebot peyotls 0.0.0.11 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.11 (YoshikuniJujo)
23:35:37 <lessless> Pythonfant, idk, it's just a first chapter :)
23:35:53 <Pythonfant> lessless: well still the exercise needs to tell you what to do
23:35:53 <nisstyre> I've written more lines of C and Forth this week than Haskell, I wonder if I can keep that up >.>
23:36:13 <Pythonfant> concat/flatten will work with a variable number of lists
23:36:27 <Pythonfant> but if you want exactly two it won't work exactly as you want
23:36:38 <Zekka> If you want to flatten a specific number of lists, though, ask yourself if list is the type you want
23:36:41 <zRecursive> @src foldl'
23:36:41 <lambdabot> foldl' f a []     = a
23:36:41 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:36:47 <Pythonfant> it's certainly not
23:36:50 <Zekka> you may want a tuple or an ADT
23:38:03 <Pythonfant> lessless: but to not confuse you further, the problem in your code is that tail doesn't return the last element of the list but everything in the list without head. If you want only the last element you need to use last
23:38:08 <lessless> Folks, I'm a javascript programmer who just finished first chapter Beginning Haskell:  where were introduction to the few basic functions - head and tail. I don't know nothing about ADT :D
23:38:33 <Pythonfant> lessless: http://s3.amazonaws.com/lyah/listmonster.png
23:38:41 <Pythonfant> I love this graphic
23:38:43 <zRecursive> @src foldr'
23:38:43 <lambdabot> Source not found. :(
23:38:49 <zRecursive> @src foldr
23:38:49 <lambdabot> foldr f z []     = z
23:38:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:39:16 <nisstyre> lessless: have you encountered linked lists before?
23:39:35 <lessless> Pythonfant, last, exactly!
23:39:38 <lessless> nisstyre, sure
23:39:45 <nisstyre> lessless: haskell lists are linked lists
23:40:46 <nisstyre> lessless: oh I misunderstood, I thought you were asking for info on head and tail
23:50:23 <Pythonfant> lessless: but if you want only two elements I would find it more intuitive to use the first two instead of the first and the last
23:51:22 <solidus-river> 'night all :)
