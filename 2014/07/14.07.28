00:01:04 * hackagebot comonad 4.2.2 - Comonads  http://hackage.haskell.org/package/comonad-4.2.2 (EdwardKmett)
00:04:27 <orion> How is something like (*) <$> [1,2,3] <*> [10,100,1000] non-deterministic? If I write a function which computes that, I'm going to get the same answer every single time.
00:04:37 <orion> Wouldn't that mean it's deterministic?
00:05:08 <Cale> orion: The idea is that you're thinking of lists as computations with multiple results
00:05:12 <dwcook> orion, "non-deterministic" in this case would probably just be a fancy way of saying that instead of a "single" value you get a list of such values
00:05:28 <dwcook> (although a list is also a "single" value of sorts)
00:05:35 <Cale> orion: This is nondeterminism in the same sense as nondeterministic finite automata or Turing machines
00:05:44 <Cale> Not randomness
00:05:55 <augur_> orion: its a simulation of all the possible "worlds" you could be in
00:06:05 * hackagebot haskbot-core 0.0.1.1 - Easily-extensible chatbot for Slack messaging service  http://hackage.haskell.org/package/haskbot-core-0.0.1.1 (jonplussed)
00:06:28 <Cale> The resulting list is a list of all possibilities obtained by multiplying an element of [1,2,3] with an element of [10,100,1000]
00:06:28 <augur_> orion: if x is a non-deterministic value that is either 1 or 2 or 3, then the list [1,2,3] is all of the possible values of x
00:06:41 <augur_> orion: its deterministic in haskell, yes
00:06:45 <augur_> orion: you're correct about that
00:07:04 <augur_> orion: but the haskell list [1,2,3] "simulates" the non-deterministic value
00:07:33 <orion> I see.
00:08:20 <augur_> orion: by treating non-deterministic values that way, the end result of the computation consists of all the possible outcomes
00:08:42 <zwer> "I cant determine what computation you want, so here are all the possible computations"
00:08:43 <augur_> orion: at the end, if you need a single randomly chosen outcome, you can of course use a random number generator to pick one
00:09:20 <augur_> orion: if you know about quantum mechanics in the pop-sci sense, think of [1,2,3] as the superposition of the values, like schrodingers cat which is simultaneously alive and dead
00:09:39 <augur_> its only when you look that you collapse the wave function -- ie, when you use a random number generator to actually pick a value
00:10:41 <Cale> Well...
00:14:00 <Cale> I'd hesitate a little about making analogies to QM, since that's a whole other sort of thing :)
00:14:20 <augur_> Cale: yeah, but its a useful analogy at the surface
00:16:41 <Yep> Hi, is there a shortcut to get n anyChar in parsec? e.g. 32Char = ???
00:17:54 <arj> Yep:  count 32 anyChar ?
00:19:04 <ropav> Any self taught programmers here?
00:19:17 <augur_> ropav: hello
00:19:24 <tdammers> ropav: yow
00:19:29 <dwcook> ropav, so many
00:19:35 <frerich2> ropav:  sure
00:19:49 * tdammers believes that all good programmers are mostly self-taught
00:20:44 <Yep> arj: thanks
00:20:52 <arj> welcome
00:21:06 * hackagebot lens 4.3.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.2 (EdwardKmett)
00:21:16 <puffie> ropav: relatively few people are taught haskell by anyone but themselves :D
00:21:36 <dwcook> Besides getting help from #haskell of course
00:21:58 <dwcook> Though of course you must put in a decent amount of personal effort still
00:22:12 <tdammers> I believe this is the case for every kind of actual learning
00:22:20 <puffie> dwcook: very true, #haskell has helped me massively
00:22:24 <dwcook> I think I'd tend to agree, though I haven't seen the stats
00:22:58 <Yep> puffie: But I would point out many haskell programmers already know an existing language... also possibly self-taught of course.
00:23:08 <tdammers> it can help to have a teacher to point you in the right direction and provide key insights, but you always have to do the grinding work yourself
00:23:15 <ropav> I've been stuck for quite sometime and I understand that everyone learns differently, but it's great to see/hear of the trials others went through while learning.  I went to school for computer science and dropped out after two years because I didn't really feel like school was where I wanted to be, and since then I've been trying to teach myself but can't seem to break real ground. I jumped around a lot and it doesn't feel
00:23:15 <ropav> like i'm retaining much.
00:23:47 <tdammers> ropav: keep at it. There's more to learn out there than any human can possibly ever keep up with
00:23:55 <tdammers> ropav: don't let that discourage you
00:24:16 <arj> Yep: more combinators involving counts and such things can be found here https://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html
00:24:32 <puffie> ropav: CS, like just about everything else, is learned in an exponentially accelerating manner
00:24:50 <Yep> arj: thx
00:25:13 <puffie> ropav: the more you know, the more you can learn in a few minutes. Things that used to take an afternoon to understand become obvious after five minutes of reading
00:25:25 <tdammers> that, too
00:25:31 <puffie> I don't purport to be anything close to a CS wizard
00:26:00 <arj> ropav: what are you struggling with?
00:26:13 <puffie> I'm just noting that the way in which my understanding has increased over the ~2 years i've been studying CS has been amazing, and that most people experience that
00:26:44 <dwcook> ropav, I too quit a CS program that I don't think fit me well. But don't let that stop you. You do need a certain amount of self-determination but you probably have it.
00:28:46 <ropav> Explanations have always been difficult for me, but I've spent the better part of two years not really grasping anything beyond basic concepts from multiple languages.  I end up starting down a road and hitting a fork and taking a path that brings me right back to the same spot with just a new language and nothing really to show for it.
00:29:41 <arj> I'd stick with one language. The mixing of several languages often veils the important parts because of different syntax and semantics.
00:30:01 <Peaker> Hey, anyone knows the ins and outs of the awesome optparse-applicative? :)
00:30:01 <Peaker> I want to create an strOption that allows no actual value to be given
00:30:01 <Peaker> i.e:  -F is fine, but -Fvalue is also fine
00:31:18 <gfixler> ropav: I had an idea and started trying to write it, and failed, and then did that every now and then over the next 6 years
00:31:27 <gfixler> then I started learning functional programming, and seeing things differently
00:31:50 <gfixler> then I realized all the idea needed was a map - not all the classes I was trying to describe the problem in
00:32:01 <gfixler> Then I implemented most of the component ideas for it in 3 days
00:32:35 <johnw> is there a way to get profiling output to show me time spent in library functions as well as my own functions?
00:32:56 <johnw> for example, instead of telling me that foo is slow, where foo = nub, I want it to say that nub is being slow
00:33:10 <Kazagistar> Peaker: how is what you want different from "switch"?
00:33:25 <arj> ropav: what kind of fork? can you be more specific? maybe in private, for it is still the haskell room
00:33:42 <Peaker> Kazagistar: I want to allow an str value to follow
00:34:15 <Kazagistar> Peaker: oh, but you want it to be optional I see
00:34:38 <Peaker> Kazagistar: maybe it's not allowed because it's ambiguous
00:35:06 <Peaker> Kazagistar: so for now I just have the short one be a switch (actually a flag') and the long one have a following value
00:36:14 <Kazagistar> Peaker: yeah, the ambiguity makes it ugly
00:37:31 <ropav> Well, to be frank, i'm at least aware that i've let outside influences deter me from sticking to one particular language for long.  I happen to live to SF where I've worked for several different startups and each time i've tried to pick up whatever language they were using to fulfill this dream of joining the team as an engineer.
00:38:41 <Kazagistar> "dream of joining the team as an engineer" sounds a touch coolaid-y, but I might have missed context
00:43:01 <ropav> Perhaps your right.  It may not even be completely that, but more-so looking for some sort of direction and basing it off of my current surroundings.
00:46:38 <Walther> Anyone got experience with Haskell and Postgres?
00:48:18 <linduxed> Walther: with both separately, but not together :-P
00:50:52 <Walther> Heh. Mainly looking for a yes/no for "is it sane/doable to complete a 'webapp'-course with haskell+postgres instead of something else recommended like java+mysql or php+postgres
00:51:10 * hackagebot adjunctions 4.2 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.2 (EdwardKmett)
00:52:53 <int3__> i wish there was a nicer way to compose functions with multiple parameters
00:53:03 <int3__> ((.).(.)) f g is kind of awkward
00:53:54 <frerich> int3__: I think it becomes nicer if you define '(.:) = (.).(.)' because then 'f .: g' is a bit like 'f . g' except that the two dots suggest that 'g' takes two arguments.
00:54:09 <Kazagistar> I was thinking about how a simple irc bot to provide a repl for many languages, and I was wondering if it would be considered abusive or something for it to PM other bots like lambda and use them to eval instead of doing it itself
00:55:12 <int3__> frerich: aha, I found this http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html which does have that .: operator
00:55:20 <int3__> no idea why it 'isn't based on Prelude's (.)' though
00:56:01 <int3__> oh, he didn't want a dependency on base, meh
00:56:11 * hackagebot kan-extensions 4.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.1 (EdwardKmett)
00:56:42 <frerich> int3__: Yeah, '(.:)' is a really common name no matter whether you use Data.Composition or not (I wasn't even aware of that module...)
00:57:07 <int3__> ah okay
00:58:25 <trap_exit> is there a way in haskell, to specify a bunch of ENUMs, and have them take on consecutive negative values,
00:58:42 <trap_exit> i.e. something like CAT, DOG, FOO, BAR, SUPERMAN, and have them take on values of -1, -2, -3, -4, -5
00:58:57 <trap_exit> so the main constraint is that (1) I want the enums to be negative, and to also have differen tvalues
00:59:00 <trap_exit> and I want to do setomhgi like
00:59:14 <trap_exit> defEnum cat, dog, foo, bar, superman
00:59:24 <trap_exit> and have it be equal to (cat = -1 :: Int), (dog = -2 :: Int), ...
00:59:53 <splintax> well your "enum" is a standard algebraic data type ie. data Thing = Cat | Dog | ...
01:00:33 <trap_exit> but I want them to be Ints ...
01:00:38 <splintax> to get the rest of that behaviour you probably want implement the Eq typeclass
01:00:41 <jle`> trap_exit: what do you want to do with them ...?
01:01:02 <trap_exit> so I have a map Int Value
01:01:04 <jle`> cat = -1 :: Int should just be fine, right?
01:01:06 <trap_exit> where the keys are Ints
01:01:12 * hackagebot monad-st 0.2.4 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.4 (EdwardKmett)
01:01:23 <trap_exit> jle`: yes, but I don't wnat to specify the values manually
01:01:26 <jle`> so you want to just do cat = -1; dog = -2
01:01:27 <trap_exit> I want Haskell to assign the values for me
01:01:34 <jle`> do you gain anything from the keys being Ints?
01:01:36 <trap_exit> jle`: hmm, that should work
01:01:42 <jle`> why can't the keys just be MyEnum?
01:01:44 <frerich> trap_exit: You could define 'toId = negate . fromEnum'
01:01:45 <jle`> Map MyEnum Value
01:01:45 <trap_exit> jle`: efficiecy; Strings in haskell make stuff slow
01:02:01 <jle`> don't use strings as keys :P
01:02:05 <Iceland_jack> trap_exit: You don't have to use Strings
01:02:10 <Iceland_jack> You can just use the values directly
01:02:19 <trap_exit> yeah, they used to be "cat", "dog", "hamster"
01:02:38 <trap_exit> hmm, so you are suggesting data ID = IInt Int | IEnum Enum
01:02:44 <trap_exit> data Enum = Cat | Dog | Hamster | Foo
01:02:48 <trap_exit> is that what you are sugesting I do?
01:02:54 <jle`> do you need to mix them and Ints together?
01:03:10 <jle`> can't you have data MyEnum = Cat | Dog | ..., and have a Map MyEnum Value ?
01:03:17 <jle`> that way you enforce type safety, too
01:03:21 <trap_exit> they can either be an enum or an Int
01:03:26 <jle`> and you can't accidentally look up an Int that doesn't exist
01:03:28 <trap_exit> so think of a DOM tree
01:03:31 <trap_exit> a node has children
01:03:35 <trap_exit> these children might either be named or unnamed
01:03:44 <trap_exit> and unnamed = it gets assigned an int (via a counter that increments)
01:03:56 <trap_exit> named = something like "CloseButton", "OpenButton", "SlideBar", "TitleBar"
01:04:05 <splintax> you can make your data type derive Ord
01:04:18 <trap_exit> unnamed / Int ==> maps to things like line-1 of text, line-2 of text, line-3 of text
01:04:21 <splintax> and then treat the "unnamed" case as == 0
01:04:30 <trap_exit> thus, children can either be Ints of Enums
01:04:53 <jle`> sounds like a job for an ADT
01:05:11 <xaimus> dl
01:05:18 <xaimus> sorry, wrong window!
01:05:57 <frerich> trap_exit: If you have ' data Things = Cat | Dog | Foo | Bar deriving (Enum)' then you can define 'toId :: Things -> Int' as 'toId = negate . fromEnum . (+1)'. This means 'toId Cat' is -1, 'toId Dog' is -2 etc.
01:06:12 * hackagebot folds 0.6.2 - Beautiful Folding  http://hackage.haskell.org/package/folds-0.6.2 (EdwardKmett)
01:06:21 <splintax> whoops i meant deriving Enum not Ord
01:09:11 <trap_exit> splintax, frerich, jle`: noted, thanks
01:10:28 <solatis> i'm fairly new to haskell, and currently trying to get a feeling of what approaches are better/worse
01:10:47 <solatis> i'm looking at function composition, and i can already see two ways;
01:10:58 <solatis> foo . bar or bar >>> foo
01:11:09 <splintax> :t (>>>)
01:11:10 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
01:11:34 <solatis> it's basicly the inverse of each other
01:11:57 <solatis> foo >>> bar >>> wombat to me more naturally describes the 'stream'
01:12:17 <solatis> but wombat . bar . foo seems to be more functional, since it is actually translated to wombat(bar(foo()))
01:12:37 <splintax> if i'm reading typeclassopedia correctly, >>> is a generalisation of .
01:12:44 <solatis> yes it is
01:13:08 <solatis> http://stackoverflow.com/a/5725427/1764661
01:13:12 <Peaker> neither is "more functional" but (.) is far more conventional
01:13:13 <solatis> that's where i found out about it
01:13:28 <frerich> solatis: In a sense '.' has a very nice data flow stream as well because the ultimate value of the whole thing is at the left hand side. I.e. 'foo = a . b . c' means that the data goes fromt he right to the left. In 'foo = c >>> b >>> a' it flows from left to right, only to then jump to the very left ('foo').
01:13:38 <angerman> After some meditating about Applicatives and Monads, I wonder if I'm right when I end up with: Unless I need depended computations, a monad has nothing to offer over an applicative. The only added functionality is `bind`, which allows to parameterize a computation with the result of a computation. Am I over simplifying? Or am I missing something?
01:13:43 <Peaker> hah, funny to see 2011 me commenting there
01:14:41 <splintax> frerich: interesting. that's just a consequence of whether (.) and (>>>) are defined with infixr or infixl right?
01:14:51 <splintax> s/right/correct/ would make that clearer, heh
01:15:05 <pjdelport> angerman: That's about right.
01:15:18 <solatis> Peaker: it's actually one of the top google results when googling for 'haskell function composition'
01:15:53 <pjdelport> angerman: Specifically, you need Monad for join: Applicative does not provide that functionality.
01:16:13 * hackagebot sparse 0.9.1 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.9.1 (EdwardKmett)
01:16:15 <solatis> frerich: yes that was what i was thinkning too. i think i will just stick with '.' because everyone appears to prefer it
01:16:18 <frerich> splintax: I think you could say so. FWIW in the beginning (when I head a more imperative mindset) I also felt that >>> is more natural since people around here read left-to-right, top-to-bottom.
01:16:50 <pjdelport> (angerman: bind is just fmap followed join, of course)
01:16:54 <angerman> pjdelport: i think that's a different way to look at it though.
01:17:05 <solatis> frerich: exactly -- i'm afraid it might be my brains trying to hold on to the imperative model a bit too much
01:17:18 <splintax> frerich: yeah, (.) is unintuitive to me. every time i use it i have to think back to dot operator in maths and reason out the order of computation
01:17:49 <jle`> solatis: we like (.) because it actually looks like real function application
01:17:55 <splintax> it doesn't seem correct to say (>>>) = flip (.) though (as in the stack overflow answer)
01:17:56 <jle`> splintax:
01:18:17 <jle`> in other languages and in haskell, if you have a function foo and a function bar and you want to apply it to x
01:18:24 <jle`> you would do foo( bar(x) )
01:18:29 <jle`> in haskell, foo (bar x)
01:18:39 <jle`> you wouldn't do ((x)bar)foo
01:18:44 <jle`> ...if that even makes sense in your syntax
01:18:49 <solatis> :)
01:18:56 <solatis> nothing makes sense to me yet
01:19:02 <hyPiRion> jle`: it makes sense if you think of it as a pipeline
01:19:05 <splintax> yeah, i'm familiar with function composition, i just find that for me reasoning about the order of application takes conscious overhead
01:19:07 <jle`> i mean, in whatever programming language you think of
01:19:21 <jle`> (foo . bar) x = foo (bar x)
01:19:24 <kvanb> splintax: really?
01:19:44 <jle`> also, there is something special in particular about haskell
01:19:51 <kvanb> you can think of it like a tunnel
01:19:54 <jle`> in foo (bar (baz x))
01:19:56 <solatis> splintax: yeah like i said, it more directly translates to the actual code
01:19:58 <jle`> foo "drives" the evaluation
01:20:03 <kvanb> what goes in the right hand side goes through all the functions and pops out the left
01:20:15 <jle`> foo is arguably the most important function --- it drives the evaluation of the entire expression
01:20:20 <jle`> so foo being first sort of makes sense
01:20:24 <kvanb> > (+2) . snd $ (1,4)
01:20:26 <lambdabot>  6
01:20:38 <jle`> (take 4 . filter (+3) . map (*2)) [1..]
01:20:44 <jle`> take 4 is what is "calling the shots"
01:20:48 <solatis> yep
01:20:53 <splintax> kvanb: yeah, that tunnel idea doesn't work well for my mind without the explicit parentheses and pointful notation
01:21:01 <jle`> take 4 tells filter (+3) what to do, which tells map (*2) what to do
01:21:05 <kvanb> well, I add all the dots first, make it sane
01:21:09 <kvanb> and then just throw a $ infront
01:21:13 <solatis> but i now have code like this:
01:21:14 * hackagebot structures 0.2 - "Advanced" Data Structures  http://hackage.haskell.org/package/structures-0.2 (EdwardKmett)
01:21:17 <solatis>         openRequest url >>= (return . decode . openBody)
01:21:24 <splintax> like, i get that they're equivalent. it just requires thought because to me it's more natural to think of foo . bar as "foo, then bar", than foo(bar(x))
01:21:38 <solatis> compared to this:
01:21:42 <solatis>         openRequest url >>= (openBody >>> decode >>> return)
01:21:42 <jle`> splintax: i really don't think it takes too much adjustment
01:21:50 <jle`> solatis: both are bad ;)
01:21:51 <kvanb> solatis: to be fair, I would prefer
01:22:02 <solatis> jle`: haha good answer :)
01:22:06 <jle`> it should be fmap (decode . openBody) (openRequest url)
01:22:14 <splintax> jle`: not saying that i disagree with haskell's choice, just commenting about what's probably a personal idiosyncrasy
01:22:15 <kvanb> return . decode . openBody =<< openRequest url
01:22:22 <kvanb> which I think might work, could need braces
01:22:29 <jle`> nah, that should work
01:22:45 <jle`> you can also do decode . openBody <$> openRequest url
01:23:05 <jle`> everything "moves" right to left :)
01:23:22 <splintax> iirc in group theory it is also common to reverse the notation for function application
01:23:40 <solatis> yeah
01:23:45 <solatis> i think that was my problem
01:23:53 <solatis> i was using >>=, which moves from left to right
01:24:07 <solatis> now that that is turned around, the whole code reads from right to left
01:24:18 <splintax> and the main context i've seen sequences of pointfree functions in was a group theory class, so maybe that's biased me :P
01:24:27 <jle`> splintax: that's fair enough :)
01:25:03 <jle`> i too asked for some sort of left-to-right pipeline sort of thing at first...but i've gotten used to the right-to-left, and i like a lot about how it matches how functions are applied in haskell
01:25:14 <jle`> and how it sort of forms a consistent picture when used with other operators
01:25:55 <jle`> i think there are advantages and disadvantages to both, but it didn't take me too long to get used to (.), and yeah, it is apparently a general haskell community style choice
01:26:03 <solatis> ok
01:26:05 <splintax> hmm, is there a version of >>= that does things in the usual order
01:26:11 <splintax> "usual" :-P
01:26:15 * hackagebot profunctors 4.1 - Profunctors  http://hackage.haskell.org/package/profunctors-4.1 (EdwardKmett)
01:26:18 <johnw> does anyone know of tricks for speeding up a Parsec parser?
01:26:19 <jle`> =<<
01:26:20 <solatis> <<=  ?
01:26:35 <splintax> amazing
01:26:36 <solatis> ehr that's what i meant
01:26:41 <johnw> it's taking about 10s for it to parse a 4 MB file
01:26:45 <jle`> f =<< x = x >>= f
01:26:55 <jle`> putStrLn . map toUpper =<< getLine
01:27:01 <splintax> that's beautiful
01:27:09 <jle`> yeah, it also looks pretty nice with do notation :)
01:27:16 <jle`> res <- putStrLn . mapToUpper =<< getLine
01:27:23 <jle`> it looks kind of like a giant ASCII art arrow :)
01:27:33 <solatis> looks nice
01:27:37 <jle`> x <- pewpew =<< y
01:27:51 <jle`> conversely, you have (>>=), which matches well with the lambda syntax
01:28:01 <solatis> also, someone said i should use fmap instead of return
01:28:13 <solatis> is that becase of the IO monad or something else i don't understand?
01:28:16 <jle`> getLine >>= (\x -> blah )
01:28:27 <jle`> solatis: if anything it is because monad is more power than you really need
01:28:53 <jle`> fmap :: (a -> b) -> (IO a -> IO b)
01:28:59 <jle`> it allows you to apply a "normal" function to an IO a
01:29:08 <jle`> and in the case earlier...you were just applying a normal function
01:29:13 <jle`> the problem is if you have an (a -> IO b)
01:29:22 <jle`> in that case you need (=<<) or (>>=)
01:29:25 <solatis> i can see that
01:29:28 <solatis> fmap f xs  ==  xs >>= return . f
01:29:29 <jle`> (=<<) :: (a -> IO b) -> (IO a -> IO b)
01:29:41 <jle`> see the parallel to the type signature for fmap?
01:30:11 <jle`> return . f =<< xs, to be easier on my eyes, pls :P
01:30:20 <solatis> jle`: roger i noticed the parallel
01:30:24 <jle`> @src liftM
01:30:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:30:36 <jle`> liftM is fmap implemented using return and (>>=)
01:30:45 <jle`> :t liftM
01:30:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:30:48 <jle`> @undo do { x1 <- m1; return (f x1) }
01:30:49 <lambdabot> m1 >>= \ x1 -> return (f x1)
01:31:36 <solatis> i'm still in the phase that my mind has to really "click" on the monads, so all this is a bit too abtract for me.. but i'm getting there
01:31:56 <jle`> solatis: don't worry about it :)
01:32:04 <jle`> i recommend not thinking too hard about monads
01:32:08 <jle`> and just thinking about how to use IO
01:32:12 <solatis> i know
01:32:16 <jle`> if you have an (IO a)
01:32:19 <jle`> and you have an (a -> b)
01:32:30 <jle`> you use fmap :: (a -> b) -> (IO a -> IO b), so you can use it on your IO a
01:32:41 <solatis> i had to understand that all IO is driven by the main :: IO () event, and all other IO is derived from that
01:32:49 <jle`> if you have (a -> IO b), you use (=<<) :: (a -> IO b) -> (IO a -> IO b), so you can use it on your IO a
01:32:53 <solatis> hmmm
01:33:12 <jle`> if you IO (a -> b), you use (<*>) :: IO (a -> b) -> (IO a -> IO b), so you can use it on your IO a
01:33:13 <solatis> for some reason in my current construct, the casting from IO(a) -> a already works ?
01:33:21 <solatis> as in, the functions are pure
01:33:42 <jle`> hmmm it isn't that main drives your IO
01:34:00 <jle`> IO can be thought of as a data structure representing a computation to be performed by a computer
01:34:04 <solatis> jle`: well my first intuition was to lift all IO, which is the wrong way to look at it
01:34:19 <jle`> in haskell, you have a lot of "primitive" values of IO a, so to speak
01:34:32 <jle`> and you assemble these primitive IO a's to get one giant IO (), which represents the program you desire
01:34:51 <solatis> yeah i have rewritten my IO code to not use 'do' blocks but rather =<< and >>=, which seems to more naturally 'describe' the monad transformations to me
01:34:56 <jle`> and then ghc compiles your IO () into a binary...it sort of acts like an IO () -> Binary function
01:35:11 <jle`> yeah, you can think of (>>) as an IO combinator
01:35:32 <jle`> that takes two such objects, and returns a new shiny object that represents performing the two in sequence
01:36:20 <jle`> IO a -> a doesn't make any sense, because...haskell can only evaluate, not execute
01:36:26 <solatis> exactly
01:36:39 <jle`> if an IO a represents actions for a CPU to produce an a...then the only thing that can produce the a is a CPU
01:36:43 <jle`> not a haskell function
01:36:45 <solatis> so IO a -> IO() does make sense, you consume 'a' and return the IO
01:37:06 <jle`> you basically assemble all your IO a's into one IO (), call it main, and ghc compiles that
01:37:13 <solatis> ok
01:37:21 <solatis> and you write all your functions pure?
01:37:30 <jle`> all of your functions are pure in haskell
01:37:38 <solatis> yes sorry
01:38:03 <solatis> but right now, all my IO-dealing code returns IO ()
01:38:13 <jle`> let's say i have a compilex function (String -> Int), that basically is my entire program
01:38:26 <jle`> entire modules and libraries are dedicated to just constructing foo :: String -> Int
01:38:39 <solatis> yeah
01:38:43 <jle`> now, to create a program that reads in a string, runs the function on the string, and print it out
01:38:48 <jle`> the program will be an IO ().
01:39:01 <jle`> a program that reads a string would be getLine :: IO String
01:39:09 <solatis> yep, but what if your getLine() is actually deep down in your code
01:39:12 <jle`> you can apply your (String -> Int) function to getLine, by using fmap
01:39:15 <solatis> in my case, a http client
01:39:21 <jle`> so you have fmap foo getLine :: IO Int
01:39:32 <solatis> you keep 'bubbling up' the IO context from that function, not?
01:39:38 <CARAM_> how do I force cabal to install a certain version of a dependency?
01:39:44 <jle`> solatis: i'm not sure i understand, sorry :)
01:39:58 <solatis> jle`: no problem, your advice is already helping a lot
01:40:05 <solatis> what i mean is in a non-trivial situation
01:40:08 <splintax> jle`: liftM is fmap implemented using return and bind, because fmap doesn't work on monads due to historical design mistakes?
01:40:20 <johnw> pretty much exactly that
01:40:28 <johnw> it doesn't work for any Monad m, to be precise
01:40:29 <jle`> (the final conclusion to my story is then that you use print :: Int -> IO (), and you watn to apply it to the IO Int you have...so you would do print =<< fmap foo getLine)
01:40:43 <johnw> but it will in GHC 7.10!
01:40:46 <jle`> yaay!
01:40:50 <johnw> man, that will be awesmoe
01:40:54 <jle`> yeah i have too many liftM's in my code :/
01:41:01 <jle`> also liftM2's too
01:41:19 <johnw> I've replaced <$> with `liftM` far too many times
01:41:19 <splintax> yeah liftM is ugly and scared the crap out of me very early on
01:41:31 <solatis> I have some code which returns IO(Text) deep in my code -- I cannot "get rid of" the IO monad, and have to eventually return that IO monad from main, right?
01:41:43 <jle`> solatis: yeah
01:42:00 <solatis> jle`: ok, then i understand correctly
01:42:03 <jle`> you can think of assembling a haskell io program as manipulating IO a's using the various combinators you have, untio you get an IO ()
01:42:08 <jle`> an IO () that represents doing what you want
01:42:21 <solatis> jle`: all IO in haskell is "driven" by the main :: IO ()
01:42:23 <splintax> in my (limited) experience it seems to be rare to actually need to put an IO-returning function deep in your code
01:42:55 <solatis> hmmm
01:43:01 <jle`> solatis: you can say "driven"; i don't really like that word myself.  i just like to say that main :: IO () is the only IO value taht is actually compiled
01:43:29 <solatis> isn't it better to say that it is the only IO value that is actually executed?
01:43:41 <jle`> there are other ways of doing this in haskell though!  you might be using some DSL or library that lets you construct your program in a nice way where you never touch IO
01:43:46 <jle`> and then at the end provide a DSL -> IO () function
01:43:50 <solatis> (sorry, i'm reading to much haskell comments and bikeshed :))
01:44:00 <jle`> solatis: no, because that implies that haskell goes and picks and chooses which IO values to execute
01:44:18 <jle`> haskell doesn't execute any IO's
01:44:21 <jle`> it evaluates them
01:44:28 <solatis> but i feel like haskell IO is forcing me to structure programs in a different way than i usually do
01:44:28 <jle`> your computer is what executes them
01:44:34 <solatis> which is actually good i think!
01:44:37 <jle`> :)
01:45:59 <solatis> but i just have to avoid doing the wrong things right now, due to lack of understanding things
01:46:26 <pjdelport> solatis: Maybe paste the code in context, for advice?
01:46:52 <jle`> if you want, i have finished-but-unreleased post gathering up all of the concepts i just mentioned
01:47:36 <jle`> but yeah, if you have specific problems, you should post specific code here :)
01:47:37 <solatis> pjdelport: http://lpaste.net/108259
01:47:52 <solatis> i do not have specific problems
01:48:38 <solatis> my specific problem is that i still lack understanding
01:48:54 <jle`> solatis: best way is just to keep on writing code :)
01:49:03 <jle`> johnw: what was the name of your utils package again?
01:49:05 <solatis> and learning from mistakes :)
01:49:29 <johnw> monad-extras?
01:49:48 <supki> CARAM_: cabal install $foo --constraint='$dependency == $version'
01:49:54 <solatis> but as you can see, my library runs forever, executes all IO actions using sequence_, and returns the eventual IO () context
01:50:08 <solatis> is that the way a library like this should be designed?
01:50:16 <jle`> johnw: ah that was it, thanks :)
01:50:36 <CARAM_> supki: thanks
01:50:52 <solatis> i have the feeling i'm doing too much in the library, and need to make it more modular -- separating the IO actions from the functions that actually deal with real values
01:51:15 <solatis> but gah, these things you only learn after experience
01:51:37 <jle`> solatis: btw, sequence . map f has a convenient alias, mapM f
01:51:47 <jle`> sequence_ . map f is....can you guess?
01:51:58 <solatis> mapM_ ?
01:52:08 <jle`> hooray!
01:54:04 <jle`> solatis: also, you might be able to take advantage of a functor law here
01:54:17 <jle`> you do map f foo, and foo = map g xs
01:54:20 <solatis> jle`: enlighten me, i am someone who learns a lot by example
01:54:29 <jle`> foo is urls
01:54:43 <jle`> if you expand out the definition of foo --- and we can do this because of referential transparency
01:54:48 <solatis> yes, i was feeling that part could be done better
01:54:51 <jle`> that's map f (map g xs)
01:54:59 <jle`> which is (map f . map g) xs
01:55:05 <jle`> and what's the first Functor law...?
01:55:58 <solatis> i am trying to think of something to say, you're probably talking about fmap
01:56:05 <shachaf> fmap id x = x
01:56:10 <solatis> but i lack the ability to say something clever about it
01:56:12 <jle`> oh yeah v.v
01:56:15 <jle`> what's the second?
01:56:19 * hackagebot contravariant 1.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.1 (EdwardKmett)
01:56:37 <shachaf> The identity law is the really important one.
01:56:43 <solatis> fmap (p . q) = (fmap p) . (fmap q)
01:56:48 <edwardk> jle`: the second follows given a free theorem + the first
01:56:48 <solatis> you mean that one?
01:57:04 <jle`> solatis: yeah :)
01:57:04 <edwardk> you just need to prove fmap id = id and your functor is a functor
01:57:20 <jle`> edwardk: yeah heh.  i'm trying to show him how to rewrite a part of his code
01:57:28 <jle`> and i think seeing it explicitly laid out might help :)
01:57:36 <solatis> yep
01:57:37 <edwardk> it is admittedly a bit of a non-trivial example of free theorem reasoning to show the two maps would have to be the same map
01:57:37 <jle`> solatis: map is fmap for lists
01:57:37 <solatis> it does
01:57:46 <shachaf> edwardk: The free theorem assumes that you have a functor, though.
01:57:55 <jle`> so how can you simplify (map f . map g) xs ?
01:58:19 <edwardk> it describes the action of the natural map. that is why i said its a bit non-trivial. you suppose there are 2 then you show they have to be the same, etc.
01:58:19 <shachaf> So the reasoning is a bit circular if you don't know that your type is a functor in the first place. But if you do know it can help you prove fmap.
01:58:24 <solatis> yeah my urls () is already a map, and i then map over those urls
01:58:37 <solatis> so i can better map just once and use a composed function?
01:58:46 <shachaf> Unless there's a part of the standard proof that I'm missing. :-)
01:59:05 <edwardk> shachaf: we worked it through with this caveat once a few years ago
01:59:25 <jle`> solatis: yeah, you can just do sequence . map (parse . request . generateUrl) $ urls
01:59:32 <jle`> and then you can use mapM_
01:59:39 <jle`> mapM_ (parse . requeset . generateUrl) urls
01:59:55 <jle`> oh that should be [0,100..]
02:00:17 <shachaf> If that "we" is including me, then I've forgotten.
02:00:38 <jle`> solatis: that is, unless you want to name mapM generateUrl urls for other reference somewhere else
02:02:32 <jle`> solatis: so yeah, it looks like, if your exit point is `accept`, then your `accept` function basically provides an IO () that represents a non-terminating program that contually does...that requesting and parsing, one after the next
02:02:45 <jle`> by function i mean value, sorry
02:02:47 <jle`> oops he left
02:02:50 <shachaf> I think it's pretty likely that the thing people always say is true, I just haven't seen a proof.
02:04:58 <shachaf> (And I'm not entirely sure -- a counterexample would be interesting.)
02:05:28 <solatis> jle`: sorry my internet here in cambodia is really bad
02:05:47 <solatis> but i read your replies in the logs @ tunes.org
02:05:57 <jle`> solatis: oh good!
02:06:05 <solatis> thanks for that
02:06:16 <solatis> i think it's now my turn again to use your advice for great good
02:06:21 <edwardk> shachaf: roconnor was involved, maybe he remembers the core trick
02:07:25 <edwardk> shachaf: ultimately if fmap id = id holds though you have no way to get a 'grip' on the fact that someone is changing your type on you
02:07:31 <edwardk> but that isn't the formal argument
02:08:01 <edwardk> the formal argument has to do with looking at the way the natural map commutes with your map and using that law twice somehow
02:08:24 <johnw> shachaf: https://gist.github.com/4714f933bc0d9689ad88
02:08:28 <johnw> there's a proof for you
02:08:49 <johnw> I am assuming functional extensionality to make expression of the theorem easier
02:08:51 <edwardk> johnw: you're really getting into this coq thing
02:08:55 <johnw> yeah, it's fun :)
02:09:23 <johnw> however, that proof proves nothing
02:09:26 <johnw> since I never use the premis
02:09:28 <johnw> e
02:09:33 <johnw> back to the drawing board
02:09:51 <johnw> i'm just proving the free theorem, which is useless
02:10:05 <shachaf> edwardk: But what if F is some bizarre non-Functor type?
02:11:21 <edwardk> suppose it is, you don't get any instance telling you which 'b' you fed back
02:11:33 <edwardk> you have no trickery available to get a grip on the type change
02:11:39 <johnw> maybe this is more interesting?  map (@id A) = id -> length xs = length (map f xs)
02:11:50 <johnw> no, not
02:11:52 <johnw> n/m
02:12:14 <johnw> ok, so I'm curious now is to what the circumstance is where I need to know map id = id
02:12:29 <edwardk> johnw: fmap f (a,b) = (a + 1, f b)
02:12:54 <johnw> so, how I state a theorem that says that F doesn't change?
02:13:09 <shachaf> instance Functor [] where map f _ = []
02:13:36 <johnw> i guess that's what map id = id is saying
02:14:17 <shachaf> I don't know what it means to say that F doesn't change.
02:14:44 <johnw> given F a, if we call F the functoral context, then fmap f (a, b) = (a + 1, f b) changes that context
02:16:53 <splintax> does it ever make sense to use "return" in the context of the IO monad?
02:17:05 <johnw> splintax: all the time
02:17:06 <edwardk> johnw: fmap f _ [] -- is a perfectly cromulent counter-example as well
02:17:07 <shachaf> What does "functoral context" mean?
02:17:18 <johnw> edwardk: yes, it was; I've used it myself in a conversation just a couple days ago
02:17:29 <johnw> shachaf: if it's not obvious already, never mind
02:17:50 <shachaf> I think if you answer that question it might help you figure out what you're looking for.
02:17:56 <johnw> all that which is F and not a
02:19:12 <splintax> johnw: when? isn't the "creation" of IO instances something that should only be done by special unsafe functions like putStrLn
02:19:34 <johnw> splintax: IO isn't special in this regard
02:19:46 <johnw> if you're writing an IO function, and you do some actions, and then you want the result of that function to be a value
02:19:52 <johnw> you might very well 'return' that value
02:20:17 <merijn> splintax: putStrLn isn't unsafe...
02:20:36 <jle`> splintax: return x is basically a "no-op" IO value, that just immediately returns the result x
02:20:38 <splintax> um, i guess what i meant was "implemented in an unsafe way"?
02:21:14 <merijn> splintax: "return" is just the "no-op IO computation"
02:21:20 <jle`> if you want to think of putStrLn as an IO primitive (it isn't, but...), you can think of return :: x -> IO () being a sort of IO primitive as well.
02:21:25 <jle`> er, return :: a -> IO a
02:21:36 <jle`> it's the no-op
02:21:42 <merijn> splintax: The same way "const 5" returns '5' regardless of argument, "return 'c'" is the IO computation that always immediately returns 'c'
02:21:45 <splintax> right, which makes me wonder why you would ever need to use it
02:21:46 <jle`> or the no-op creator
02:21:48 <edwardk> had fun figuring out that the day convolution of representable profunctors is representable, which is 'obvious', but took me a minute to get right, because i don't think i can write the distributive law for them using just distributive
02:21:50 <splintax> maybe "makes sense" was a confusing phrase
02:22:08 <edwardk> er of representable functors
02:22:11 <merijn> splintax: Well, for example to write things like liftM2
02:22:13 <raichoo> I'm having a problem grokking the yoneda lemma in terms of haskell. In CT it's Hom(yC,F) = FC and in some blogposts it's presented as forall b. (a -> b) -> F b = F a. yC should yield a contravariant functor but I read off the haskell typesig as a nat transformation between functors (->) a and F where (->) a is covariant… where am I going wrong here :/ I presume I got something fundamentally wrong here :/
02:22:17 <sleepomeno> in threadscope spark pool view what does that grey area mean opposed to the black graph line? --> https://www.dropbox.com/s/bq98ytxs7k5zdks/pool.png
02:22:21 <edwardk> i should add profunctor day convolution now that i think about it
02:22:38 <jle`> splintax: say you wanted to make an IO String that is a lot like 'getLine'...but says "thank you!" after the line is received
02:22:55 <edwardk> probably can't do it without real hask style profunctors though
02:22:58 <jle`> do { str <- getLine; putStrLn "thank you!"; return str }
02:23:02 <merijn> splintax: "liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c; liftM2 f x y = do { xVal <- x; yVal <- y; return (f x y) }"
02:23:11 <jle`> without the extra return at the end, you "lose" the result; it'd just be an IO ()
02:23:17 <jle`> you'd lose the result of the getLine, that is
02:23:21 <edwardk> raichoo: the yoneda lemma has several forms
02:23:34 <splintax> jle`: great example! thanks
02:24:04 <danilo2> Hello! I know that when we are doing TemplateHaskell we should define it externally and import to the final files, but If I remember good, there were some exceptions from this rule. Am I right?
02:24:08 <raichoo> edwardk: I struggle with the yC part since the resulting functor does not seem to be what I expected.
02:24:16 <merijn> splintax: 'f' returns a plain 'c', but the resulting expression has to be 'm c', so you can use return to stuff the result back into the relevant monad
02:24:18 <edwardk> raichoo: the one we use in haskell is based on the end/coend presentation
02:24:21 <splintax> merijn: i think of that sort of thing as "extending the language" somehow, although i'm not sure i can actually give a concrete definition of what i consider is and isn't "extension" :P
02:24:59 <splintax> merijn: i get the idea of return "injecting" a value into a monad, i guess i was just seeing that concept as useless in the particular case of the IO monad
02:25:02 <raichoo> edwardk: I'm unaware of what those are, any sources you can recommend to read that up?
02:25:18 <edwardk> raichoo: ncatlab is always good.
02:25:46 <edwardk> they are what you get when you see an integral sign in category theory
02:25:56 <raichoo> edwardk: ncatlab is a trap :D I alway end up with 50 open tabs when researching one concept ^^ j/k I'll check it out. Thanks :)
02:26:03 <edwardk> with a subscript you are taking an end, superscript you are taking a coend
02:26:07 <merijn> splintax: In the case of IO return serves the same sort of purpose as functions like 'id'/'const', etc. which make more sense in the context with higher-order functions
02:26:14 <shachaf> "injecting" is probably confusing mental imagery when you're trying to figure these things out.
02:27:22 <splintax> i am just using it as a word to describe what "a -> m a" is doing to m, and not meaning to imply more than that
02:27:30 <edwardk> raichoo: you can get the yoneda lemma a bunch of ways, as a limit over a comma category, the v-valued (co)presheaf you get when you fix an object of a category on one side or the other of the hom functor, etc.
02:27:53 <splintax> i suppose thinking of "a -> m a" as "doing something" to m is also loaded terminology :P
02:28:54 <shachaf> A value of type "IO A" is a program which does some IO and produces a value of type A.
02:30:13 <shachaf> The value "return x", where x :: A, is the program which does no IO and produces x.
02:30:20 <edwardk> the yoneda embedding says if you fix c,   then what is left of your Hom(-,c) :: [ C^op,  Set ]      so if we look at the morphisms between presheaves, [C^op, Set]( Hom(-,c), F )    that is in isomorphism with F -- this is the contravariant version of the yoneda lemma.
02:31:16 <superman78> Hi, if I have a function that has a type: String -> String, is there any possibility that it performs some IO/side effects before it returns a String?
02:31:47 <pjdelport> superman78: In general, no.
02:31:54 <shachaf> superman78: Only if it uses unsafe functions.
02:32:13 <edwardk> if we package that up with an end around it on the left you get (end x. Set(Hom (x,c), F(x)) ) ~ F(c)
02:32:43 <edwardk> in haskell terms an end is a forall.  so (forall x. (x -> c) -> F x) ~ F c
02:32:55 <jle`> superman78: it'll also always do the same thing every time you apply it to the same string
02:32:59 <jle`> barring unsafe stuff
02:33:01 <merijn> And with proper -XSafe/Trustworthy flags to GHC you should be able to guarantee it doesn't do IO, even if tries to use unsafe functions
02:33:02 <edwardk> here F is contravariant
02:33:06 <edwardk> so it supports contramap
02:33:15 <jle`> s/do/return
02:33:34 <edwardk> contramap :: (x -> c) -> F c -> F x
02:33:38 <edwardk> if you flip that
02:33:40 <edwardk> that is one side of the isomorphism
02:33:45 <edwardk> if you pass it identity it is the other
02:33:54 <edwardk> the proof it is an isomorphism follows from the functor laws
02:34:26 <superman78> jle`: right, that's the guarantee by RT. If we have some Lazy I/O, that means it doesn't necessarily execute the same I/O action again, right?
02:34:48 <jle`> hm. lazy io doesn't really apply in this context
02:34:56 <edwardk> raichoo: the version you probably saw was covariant rather than contravariant, so you have to do all that over with Hom(c,-) :: [C, Set]   giving you copresheaves, and morphisms between them, and in the end you use fmap not contramap. dan piponi's presentation used that
02:34:56 <jle`> can you elaborate on what you mean?
02:34:57 <superman78> jle`: Let's say in F#, let foo x y = printfn "blah"; x + y;;
02:35:15 <jle`> what is the type of printfn?
02:35:30 <jle`> oh, it's F#
02:35:37 <jle`> okay, go on
02:35:49 <superman78> jle`: In that function, "blah" is only printed once, the result if I use the same values, it will always return the same result. I/O is lazy here.
02:36:25 <edwardk> note in the above code, Set and Hom both wind up being (->), because we're working over haskell data types of kind * so everything is boring
02:36:42 <jle`> so if you run foo with the same thing twice, "blah" is only printed once?
02:36:43 <superman78> jle`: shachaf mentioned unsafe actions (unsafePerformIO?) - is there anything like that in haskell or is it just taken to be pure functions?
02:36:46 <raichoo> edwardk: I got the CT yoneda version from awodey's book. Copied your explanation into a buffer for later research, seems to make sense but I need some time to wrap my head around that :)
02:36:53 <superman78> jle`: I believe so, yes.
02:37:00 <jle`> haskell doesn't do implicit memoization
02:37:18 <edwardk> raichoo: there are 4 encodings of Yoneda in my kan-extensions package
02:37:24 <merijn> superman78: There is an unsafePerformIO, but the compiler behaves like it doesn't exist, so if you *do* use it, you are very, VERY, *VERY* to shoot yourself in the foot
02:37:26 <edwardk> see Data.Functor.Contravariant.Yoneda, Coyoneda, etc.
02:37:28 <jle`> the problem is a bit tricky though when you consider unsafePerformIO
02:37:43 <jle`> unsafePerformIO sort of breaks the semantic model of what IO in haskell represents
02:37:50 <edwardk> raichoo: all are basically the end/coend presentations for co and contravariant functors
02:38:03 <merijn> superman78: So in general, you can assume people don't use unsafePerformIO (unless they trying to do low-level high performance libraries like ByteString)
02:38:05 <jle`> the details on how it works aren't too relevant to understanding Haskell
02:38:13 <superman78> merijn: I didn't ask that question to use unsafe I/O actions. I was reading through RWH and it mentioned something about guarantees from type system. I was curious if it's possible at all it violated this.
02:38:19 <shachaf> Coyoneda always seemed much more straightforward to me from a Haskell perspective.
02:38:27 <merijn> superman78: Also, with SafeHaskell it is possible to stop your dependencies from sneaking IO into non-IO functions
02:38:30 <shachaf> superman78: The guarantees are mostly to stop you from making mistakes.
02:39:03 <edwardk> yeah, from haskell its playing with flip fmap and ($ id)
02:39:06 <shachaf> If you use a function whose name starts with "unsafe" (among other things) then they no longer apply.
02:39:07 <edwardk> :t flip fmap
02:39:08 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:39:16 <edwardk> :t flip fmap . ($ id)
02:39:17 <lambdabot> Functor f => ((a1 -> a1) -> f a) -> (a -> b) -> f b
02:39:47 <merijn> superman78: Right, so IO actions are exactly executed the number of times you expect from your code path. For pure functions the compiler is allowed to run them, 0, 1 or more times and expect that all of those are indistinguishable
02:39:49 <superman78> merijn: where can I look up more about SafeHaskell? hackage?
02:39:54 <edwardk> :t ($ id) . flip fmap
02:39:55 <lambdabot> Functor f => f a -> f a
02:39:58 <merijn> superman78: GHC documentation
02:39:58 <raichoo> edwardk: Thanks for your explanation. I appreciate it :)
02:40:03 <merijn> superman78: It has a chapter on it
02:40:29 <edwardk> there's a quantifier missing on the flip fmap . ($ id) side that makes that messier
02:40:30 <jle`> superman78: things are weird when you assume unsafeness, so we usually like to assume it isn't there when we reason about code
02:40:36 <merijn> superman78: However, if you write for example "f 1 2 + f 1 2" GHC is allowed, in principle, to only execute "f 1 2" once and add the result to itself
02:41:14 <merijn> superman78: And GHC does indeed occasionally apply common sub-expression elimination (although it's not fool proof and if you want to guarantee it's not run twice, it's better to it yourself)
02:41:30 <babu> Is it possible to use printf without declaring the type of 'a' first?  printf "Value is %.2f\n" a ---> "No instance for (Fractional a0) arising from the literal"
02:41:52 <merijn> babu: No, but you can just annotate 'a' on the spot
02:41:52 <shachaf> babu: It won't figure it out from the format string, if that's what you mean.
02:42:03 <jle`> babu: it has to have a type, because it has to be compiled to a concrete type
02:42:16 <Iceland_jack> babu: Consider using the ‘formatting’ library
02:42:18 <Iceland_jack> @hackage formatting
02:42:19 <lambdabot> http://hackage.haskell.org/package/formatting
02:42:29 <merijn> superman78: GHC guarantees (not sure about haskell in general) that in "let x = f 1 2 in x + x" x will be evaluated at most once
02:42:32 <jle`> usually in real code, ghc will be able to infer the type of `a` if you use it elsewhere
02:42:48 <merijn> jle`: Bleh, I wish people would stop using the term "concrete type"
02:42:59 <jle`> what's a better word? :)
02:43:05 <merijn> No one seems to be able to explain what they mean by a "concrete type"
02:43:09 <jle`> hm
02:43:16 <jle`> i guess it also shows up in multiple context
02:43:16 <merijn> jle`: Depending on what you mean, either "monomorphic" or "type of kind *"
02:43:17 <superman78> merijn: "concrete types" are something of a holdover from Java/C++ :-)
02:43:18 <jle`> s
02:43:28 <tdammers> merijn: one whose name starts with a capital letter ;)
02:43:30 <jle`> because i'm stealing it from another context and abusing the terminology >_>
02:43:50 <frerich> merijn: I concur with tdammers, I often heard it when distinguishing type variables from types.
02:44:07 <merijn> frerich: Then use monomorphic
02:44:08 <frerich> The former being "some type" and the letter being "some concrete type" :)
02:44:17 <superman78> merijn: Thank you for all that information. I'm reading through GHC docs on SafeHaskell now
02:44:23 <jle`> superman78: note that all of this headache with IO and evaluation goes away when you leverage haskell's IO type with well-defined semantics, allowing you to preserve RT and purity when reasoning about IO
02:44:40 <merijn> "Maybe" <- monomorphic type of kind * -> *, "Maybe a" <- polymorphic type of kind *, "Maybe Int" <- monomorphic type of kind *, etc.
02:44:42 <hyPiRion> tdammers: Oh, so Maybe is a concrete type? ;)
02:44:42 <babu> If I have a = 40.2 and then say "printf "Value is %.2f\n" a" why can't it figure out that a is a float or double? Cannot be a string or boolean.
02:44:58 <jle`> superman78: and all of the other equational reasoning tools you'd expect to have with all normal functions
02:45:01 <superman78> hyPiRion: "higher kinded type", maybe? :D
02:45:03 <merijn> hyPiRion: Exactly the question why I dislike the term :)
02:45:18 <hyPiRion> hehe
02:45:23 <Iceland_jack> babu: because Haskell's type system isn't powerful enough
02:45:40 <ion> Does anyone happen to have a golfed Haskell program that produces digits of pi in base-16 or any base-2^n?
02:45:42 <lfairy> babu: format strings are checked at runtime. you can do printf "%.2f" "totes a float" and it'll crash when you run it
02:45:47 <merijn> babu: Because that would require parsing the String at compile time, which is not what printf does
02:45:53 <shachaf> merijn: You know, stamped, pervious, high-performance, vacuüm, shotcrete, etc.
02:45:57 <superman78> jle`: Thank you - I have another question that can get on all your nerves (all you haskell folks), I'll leave that for another day. :-)
02:46:22 <superman78> jle`: especially since you mentioned headaches around IO :D
02:46:24 * hackagebot mtl-prelude 0.1.0 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-0.1.0 (NikitaVolkov)
02:46:24 <Iceland_jack> ghci> format ("Value is " % fixed 2) pi
02:46:24 <Iceland_jack> "Value is 3.14"
02:46:26 * hackagebot aws-sign4 1.1.0.1 - Amazon Web Services (AWS) Signature v4 HTTP request signer  http://hackage.haskell.org/package/aws-sign4-1.1.0.1 (ChrisDornan)
02:46:29 <merijn> babu: You could use a quasi quoter to do this statically checked, I'm willing to bet someone already implemented a typesafe printf quasiquoter
02:46:52 <lfairy> babu merijn: or, as Iceland_jack demonstrated, text-format
02:47:00 <Iceland_jack> lfairy: Actually ‘formatting’
02:47:12 <lfairy> Iceland_jack: dammit. knew I got that wrong
02:47:16 <Iceland_jack> ;)
02:47:19 <raichoo> edwardk: Re-read your answer. I think a get it :D Thank you VERY much :D
02:47:45 <babu> But typing a = 40.2 and then printf "Value is %.2f\n" a on ghci prompt works. What is the difference?
02:48:08 <lfairy> babu: if you put the a on its own line, type defaulting kicks in
02:48:10 <jle`> babu: there is a default type inferred for a in ghci
02:48:27 <lfairy> it's got nothing to do with printf
02:48:32 <jle`> well, in < 7.8
02:48:46 <jle`> if you put it on a separate line in haskell source i think it might act the same way
02:53:28 <splintax> hmm, am i falling victim to the "i just worked out monads, i should write a monad tutorial" fallacy, or is the intro to https://en.wikipedia.org/wiki/Monad_(functional_programming) really bad
02:53:56 <babu> :q
02:53:59 <babu> :q
02:54:46 <pjdelport> splintax: It's not very good.
02:57:15 <splintax> do monads (in general) "represent computations" in any meaningful sense? that seems only to apply to the IO monad to me
02:57:59 <Rembane> splintax: The Maybe monad is very nicely representing computations. +grammar
02:58:23 <Rembane> splintax: If things fail along the computation line it returns early and returns Nothing.
02:58:26 <shachaf> Other introductions being bad might be taken as an indicator that yours would be bad, rather than that it would be good. :-)
02:58:46 <Rembane> Less bad = better? :)
02:59:00 <Iceland_jack> splintax: The original paper by Moggi was called “Notions of computations and monads”
02:59:25 <shachaf> "computation" isn't a terrible intuition, exactly, but you have to be precise about what it means (a value of type M a for some monad M-- so you haven't gained much).
02:59:30 <shachaf> M++
02:59:46 <ion> @karma M
02:59:46 <lambdabot> M has a karma of -1
02:59:50 <shachaf> Also keep in mind that the "computation" isn't the monad, it's the value of type M a. The monad is M itself.
02:59:51 <Iceland_jack> splintax: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf why not read it?
03:00:03 <shachaf> I like the word "action", so you should use that word.
03:00:05 <splintax> Iceland_jack: interesting. the concept (as defined by the monad laws) seems general enough that i would have thought someone else would have come up with it independent of its utility as a functional programming tool
03:00:13 <splintax> Iceland_jack: thanks for the link, i'll check it out
03:00:24 <jle`> splintax: i like to think of a monadic interface is useful for many applications and situations; one application is to aid in representations of computations
03:00:39 <jle`> splintax: it kind of splits the tricky subject of "what a monad is" from "what monad allows you to do"
03:00:51 <Iceland_jack> splintax: Monads did exist outside of functional programming, if that's what you're asking
03:00:54 <jle`> it's one thing to say what something *is*
03:01:02 <jle`> it's another to say what it's useful for
03:01:13 <jle`> or at least a couple of situations in which it is useful
03:01:27 <Iceland_jack> Moggi calls a monad M a ‘notion of computation’ which I like
03:01:30 <splintax> jle`: yeah. the wiki article starts off with two paragraphs about how you can use it to "chain computations" before introducing the formal definition
03:01:53 <nexx> "You Could Have Invented Monads! (And Maybe You Already Have.)"
03:02:09 <jle`> it's like...a lot of people sya that a Functor is a "wrapped object".  but really, that doesn't have anything to do with what a functor actually *is*
03:02:21 <jle`> it doesn't even have anything to do with what a Haskell Functor "is"
03:02:40 <jle`> (you'd have to stretch it)
03:02:53 <splintax> and what it "actually is" is a thing that implements fmap, right?
03:02:56 <tdammers> "a functor is something you can fmap over" is the best definition I've heard so far
03:03:06 <jle`> yeah.  lawfully
03:03:16 <tdammers> :t fmap
03:03:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:03:27 <tdammers> that's really all you can reasonably say about the matter
03:03:33 <xpika> if ghc says a variable is ambiguous and there is only one instance available. is there a language option to make it shut up about it?
03:03:45 <tdammers> if you can reasonably and usefully implement fmap, then you have a functor
03:03:45 <yitz> it's ok to say that monads represent computations - as long you mean "computation" in the mathematical sense, not in the imperative programming sense.
03:04:02 <xpika> Note: there is a potential instance available: instance [overlap ok] RunResult (IO [String])
03:04:23 <jle`> in many data structures which have a concept of wrapping a value, a fmap will sort of correspond to applying a function to the wrapped values.  but taht doesn't mean that that's what fmap *is*, as a concept, or what Functor *is*, as a concept
03:04:28 <shachaf> yitz: What is the mathematical sense of "computation"? Does it involve the word "monad"?
03:04:29 <tdammers> xpika: OverlappingInstances?
03:04:43 <jle`> xpika: that sounds pretty finicky ;)
03:04:58 <shachaf> @quote kmc forget
03:04:58 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
03:05:14 <jle`> xpika: import a module that imports a module that imports a module that has another instance, or maybe accidentally switch instances
03:05:25 <jle`> and "only in-scope instance" is a bit of a finicky thing
03:05:32 <tdammers> xpika: I'd rethink the design though - the problem is that you can't guarantee that no other instances will ever exist
03:05:46 <jle`> or if a user imports *your* module
03:05:47 <yitz> shachaf: it's a very imprecise word commonly used to mean deriving one thing from another by applying some kind of transformations that follow some kind of rules
03:05:50 <jle`> and defines a new instance
03:05:52 <jle`> then your module will break
03:06:05 <jle`> *defines a new instance in their code
03:06:19 <tdammers> worse yet, it will break in subtle, face-palm-inducing, heisenbuggish ways
03:06:31 <tdammers> breakage-at-a-distance ;)
03:06:42 <jle`> spooky breakage at a distance
03:06:45 <nexx> lol
03:07:04 <yitz> shachaf: the point is, though, that once you've done a mathematical "computation", you have shown that the thing you started with and the thing you ended up with were really related in that way all along.
03:07:28 <yitz> shachaf: not that you have made it so by doing the computation.
03:08:03 <xpika> tdammers: nope. im using the function run from the library HSH which can return either String or [String] but even when only [String] Typechecks it still asks me to put the type annotation in
03:08:04 <yitz> tdammers has invented quantum computing
03:08:34 <tdammers> yitz: I fear the day when I have to debug quantum programs
03:09:05 <yitz> tdammers: sounds to me like you've been debugging them for quite a while already :)
03:09:08 <jle`> xpika: surely you use the value somewhere else, so it can be inferred?
03:09:16 <tdammers> yitz: hard to tell for sure
03:09:27 <jle`> yitz: if he tries to think about it, the answer might change
03:10:17 <tdammers> jle`: indeed. also, if I find that I am debugging them right now, it means I will have started doing so some time in the future, but in order to tell when exactly, I lose the ability to tell whether I am in fact debugging them right now
03:10:39 <bernalex> saw an interesting question on the café: has "\x y. x" ever been valid syntax in haskell? i.e. lambda calculus style '.' instead of '->'.
03:11:00 <yitz> bernalex: yes - at the type level.
03:11:18 <jle`> heh really?
03:11:23 <yitz> sort of
03:11:32 <Iceland_jack> (Not really)
03:11:37 <bernalex> do you mean forall a. a -> a and so on?
03:11:45 <yitz> bernalex: yeah
03:11:46 <bernalex> anyway I meant at term level
03:12:13 <jle`> :k forall a. Maybe a
03:12:15 <lambdabot> *
03:12:21 <jle`> doesn't really look like a lambda to me
03:12:29 <jle`> :/
03:12:43 <Iceland_jack> Haskell having type-level lambdas would be news to me :)
03:12:46 <nexx> xD
03:12:47 <jle`> \x -> f x should be of something like a -> something
03:12:52 <jle`> instead of something
03:13:10 <jle`> fsvo something
03:13:19 <jle`> forall something.
03:13:21 <yitz> Iceland_jack: oleg claims haskell has had type-level lambdas all along. but not with dot syntax.
03:13:44 <bernalex> yitz: did he write an 80pps paper with obscure examples to support this claim?
03:13:59 <yitz> bernalex: something like that, yeah :)
03:14:05 <bernalex> link? :-]
03:14:28 <bernalex> his co-authored paper on object-oriented haskell was simultaneously incredibly painful and absolutely thrilling to read.
03:15:44 <nexx> bernalex Haskell's overlooked object system?
03:18:13 <xpika> jle`: my bad, look like the problem was being caused by Overloaded Strings
03:18:19 <jle`> yay!
03:18:34 <jle`> np, glad you solved it
03:18:47 <ocharles> Does anyone have any tips on how to model data structures when I don't want persistency? Lets say I have a list of classes and each class has a class type, which itself has some metadata. Obviously I want each class to point to have a class type, and it would be best to use sharing to store the class type once in memory. But now if I change the class type
03:18:48 <ocharles> all the existing classes point to the wrong class type, so I'd need to update them
03:18:49 <bernalex> nexx: yeah. it's fantastic.
03:19:57 <ocharles> I could have classes have some sort of pointer into a structure of class types (e.g., Int's indexing into an IntMap), but that introduces partiality when I do lookups
03:20:04 <nexx> bernalex yes, but while it has some tough spots I wouldn't call it "incredibly painful"
03:20:23 <bernalex> nexx: painful as in NOOO DON'T DO IT NOOOOO
03:20:32 <bernalex> nexx: not as in difficult to read
03:20:34 <nexx> :)
03:20:41 <bernalex> nexx: well, difficult to read, but not difficult to understand
03:21:08 <bernalex> nexx: and then when you get down to it, laughing your arse off at a drawRectangle function that returns IO (), it suddenly dawns on you: this is how most languages do it. o_O
03:21:36 <SaBer_> ocharles: if you want a mutable variable, you could use e.g. an IORef
03:21:48 <ocharles> Yea, but that feels messy...
03:21:54 <ocharles> Hmm, ixset is apparently what backs acid-state
03:22:18 <bernalex> C++ is basically just like Haskell. except that C++ categories have a really suboptimal Kleisli arrow.
03:22:35 <nexx> bernalex I think your Haskell/Not-Haskell ratio is better than mine
03:22:58 <bernalex> nexx: what is "better" in this case, and what is yours? :-]
03:23:21 <yitz> bernalex: sorry, oleg re-arranged his site. took me a while to find it. http://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level
03:23:24 <nexx> bernalex better means you are doing more Haskell
03:23:40 <yitz> bernalex: (i think that's it.)
03:23:46 <bernalex> yitz: thanks a lot
03:23:53 <bernalex> nexx: how much are you doing?
03:25:37 <nexx> So few it is hard to quantify
03:25:41 <yitz> bernalex: maybe this is better: http://okmij.org/ftp/Haskell/types.html#computable-types
03:25:54 <yitz> bernalex: anyway, a ton of olegy stuff there.
03:26:57 <bernalex> nexx: https://www.openhub.net/accounts/alexanderb/languages is a somewhat faithful look at what languages I am using for publicly available source code at least.
03:27:16 <bernalex> nexx: more than 6 times as much C++ as haskell. >_<
03:27:22 <bernalex> yitz: thanks! yeah I know his site. insane.
03:28:53 <yitz> ocharles: indirection doesn't introduce paritality if there is a zero class type.
03:29:33 <ocharles> yitz: point is I have no guarantee that lookups will find the data I want
03:29:56 <ocharles> I don't want the zero, I want the data I'm asking for which I can reason is there, but proving that in Haskell is somewhat painful
03:30:15 <yitz> ocharles: why? if it's not in the structure, it's the zero class type. you always get an answer.
03:30:56 <ocharles> because it *is* is in the structure, but insertion doesn't give you any proof that what you inserted is now in the structure
03:31:20 <nexx> bernalex why did you do your master thesis in Haskell and C++?
03:31:20 <ocharles> insert :: k -> v -> Map k v -> Map k v for example won't guarantee that a subsequent lookup will work
03:33:34 <nexx> bernalex never mind
03:35:30 <yitz> ocharles: not sure i'm following. but the two approaches are: 1. give an interpretation to Nothing, so that lookups always succeed by definition. 2. use a data structure that is guaranteed at the type level to have what you are looking for, like NonEmpty.
03:35:49 <yitz> ocharles: you're right that 2 can be complicated in haskell for anything with any complexity.
03:36:15 <yitz> ocharles: is what you really want dependent types?
03:36:38 <ocharles> It doesn't feel like it needs DT
03:36:54 <ocharles> but it's ok, I'll probably go with ixset for now
03:38:51 <Rufflewind> does anyone know why <> and <+> in the PrettyPrint module are infixl rather than infixr? (I assume semantically it's identical since it's associative, but I was curious if there was perhaps a performance benefit?)
03:39:21 <ocharles> perhaps they recurse on their right argument, which could mean that infixl has performance gains
03:41:13 <yitz> Rufflewind: yeah, interesting. for example: infixr 6 Data.Monoid.<>
03:41:16 <bernalex> nexx: yes. :-]
03:41:51 <Rufflewind> Oh looks like I dug up the reason: http://www.haskell.org/pipermail/libraries/2011-November/017066.html
03:41:52 <yitz> Rufflewind: those are very old. could be in those days that was just assumed to be the more obvious way to do things.
03:42:31 <danilo2> Hello all! :) Is there any way in haskell to "print" signatures of functions with polymorphic values? like "print $ myshow id" or just "print id" ? :)
03:43:40 <yitz> Rufflewind: that's not a reason it should be that way. it's just a reason that changing it would break legacy code.
03:44:28 <Rufflewind> yitz: OK I see, so if I'm careful enough I can use Monoid's <> without bad things happening?
03:44:35 <isBEKaml> @t id
03:44:36 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
03:44:41 <isBEKaml> :t id
03:44:42 <lambdabot> a -> a
03:44:50 <isBEKaml> danilo2: do you mean this?
03:45:00 <danilo2> isBEKaml: yes
03:45:22 <yitz> Rufflewind: sure. use mconcat instead where appropriate.
03:45:23 <isBEKaml> danilo2: you can do that in your ghci. Just type :t function_name
03:45:46 <danilo2> isBEKaml: I know, I want to get this Stirng in my compiled executable
03:46:23 <isBEKaml> danilo2: hrm - I'm not sure haskell has metaprogramming capabilities like that. :)
03:46:36 <isBEKaml> danilo2: I'll leave it to others in the know
03:47:11 <danilo2> isBEKaml: I know I never saw something like that, but if GHCI could do it, maybe there is a way that using some GHC Api is it possible?
03:48:02 <isBEKaml> danilo2: yes, it could be in GHC API. I can't comment on this since I haven't seen actually seen through that part of GHC :)
03:48:18 <Rufflewind> if your type is an instance of Data.Typeable, you can use: print $ typeOf x
03:49:20 <Rufflewind> oh wait I see, polymorphic
03:51:13 <danilo2> Rufflewind: exactly, we cannot do it with polymorphic, like "id"
03:52:12 <Rufflewind> there might be a clever type system hackery that allows you to abstract over constraints but nothing builtin afaik :\
04:11:52 <jle`> i mean, it'd break parametricity
04:12:04 <jle`> i think
04:12:30 <jle`> hm
04:26:59 <WarzoneCommand> is there an O(1) way of 'splitting' an array at a given index?
04:28:28 <WarzoneCommand> e.g. I have some Data.Array A defined on [1..n], and given i \in [1,n] , I want to get two arrays B[1..i], and B[i+1..n] that just index A
04:28:48 <WarzoneCommand> or do I have to define a newtype and maintain the bounds myself
04:28:52 <WarzoneCommand> in order to do that
04:29:00 <merijn> On the one hand I don't see why that shouldn't exist, on the other hand it sounds like a potential space leak waiting to happen
04:31:36 * hackagebot multistate 0.1.1 - like mtl's ReaderT/StateT, but more than one contained value/type.  http://hackage.haskell.org/package/multistate-0.1.1 (lspitzner)
04:32:00 <WarzoneCommand> hmm yes, maybe
04:32:27 <k00mi> Data.Vector.splitAt is O(1)
04:32:58 <WarzoneCommand> I can only use stuff that is in HP though
04:33:45 <WarzoneCommand> thanks though
04:34:05 <WarzoneCommand> that does seem to be exactly the thing that I need
04:35:26 <k00mi> ah, too bad, vector's API is much nicer than array's
04:36:36 <WarzoneCommand> hmm that definately seems to be the case indeed
04:38:01 <andreasrx> trying to install trifecta from hackage in a sandbox I get some errors:
04:38:30 <andreasrx> reuleaux@mirabelle ~/etc/foo $ cabal sandbox init
04:38:30 <andreasrx> Writing a default package environment file to
04:38:30 <andreasrx> /home/reuleaux/etc/foo/cabal.sandbox.config
04:38:30 <andreasrx> Creating a new sandbox at /home/reuleaux/etc/foo/.cabal-sandbox
04:38:30 <andreasrx> reuleaux@mirabelle ~/etc/foo $ cabal update
04:38:33 <andreasrx> Downloading the latest package list from hackage.haskell.org
04:38:35 <andreasrx> reuleaux@mirabelle ~/etc/foo $ cabal install trifecta
04:38:38 <andreasrx> Resolving dependencies...
04:38:40 <andreasrx> cabal: Could not resolve dependencies:
04:38:43 <andreasrx> trying: trifecta-1.5.1 (user goal)
04:38:45 <andreasrx> trying: semigroups-0.13.0.1/installed-a55... (dependency of trifecta-1.5.1)
04:38:48 <andreasrx> trying: parsers-0.12.1 (dependency of trifecta-1.5.1)
04:38:50 <andreasrx> next goal: attoparsec (dependency of parsers-0.12.1)
04:38:53 <andreasrx> rejecting: attoparsec-0.10.4.0/installed-d9f... (conflict: parsers =>
04:38:55 <andreasrx> attoparsec>=0.12.1 && <0.13)
04:38:58 <andreasrx> rejecting: attoparsec-0.12.1.0 (conflict: semigroups =>
04:39:00 <andreasrx> text==0.11.3.1/installed-e38..., attoparsec => text>=1.1.1.3)
04:39:03 <andreasrx> rejecting: attoparsec-0.12.0.0, 0.11.3.4, 0.11.3.3, 0.11.3.2, 0.11.3.1,
04:39:05 <andreasrx> 0.11.3.0, 0.11.2.1, 0.11.1.0, 0.10.4.0, 0.10.3.0, 0.10.2.0, 0.10.1.1,
04:39:08 <andreasrx> 0.10.1.0, 0.10.0.3, 0.10.0.2, 0.10.0.1, 0.10.0.0, 0.9.1.2, 0.9.1.1, 0.9.0.0,
04:39:10 <andreasrx> 0.8.6.1, 0.8.6.0, 0.8.5.3, 0.8.5.2, 0.8.5.1, 0.8.5.0, 0.8.4.0, 0.8.3.0,
04:39:13 <andreasrx> 0.8.2.0, 0.8.1.1, 0.8.1.0, 0.8.0.2, 0.8.0.1, 0.8.0.0, 0.7.2, 0.7.1, 0.6,
04:39:15 <andreasrx> 0.5.1, 0.5, 0.4 (conflict: parsers => attoparsec>=0.12.1 && <0.13)
04:39:18 <andreasrx> Backjump limit reached (change with --max-backjumps).
04:39:20 <andreasrx> Note: when using a sandbox, all packages are required to have consistent
04:39:23 <andreasrx> dependencies. Try reinstalling/unregistering the offending packages or
04:39:25 <andreasrx> recreating the sandbox.
04:39:28 <andreasrx> reuleaux@mirabelle ~/etc/foo $
04:39:30 <andreasrx> what's the proper way to handle these?
04:39:45 <AshyIsMe> andreasrx: you should use a pastebin instead of pasting lots of lines here
04:39:48 <Iceland_jack> andreasrx: Please don't flood the channel like that, use lpaste
04:39:49 <k00mi> andreasrx: next time when posting more than one line, use lpaste.net
04:39:55 <AshyIsMe> http://lpaste.net/
04:40:02 <andreasrx> OK, sorry, next time
04:55:30 <benzrf> geez
04:55:37 <benzrf> sometimes i forget Monoid isnt in the prelude
04:55:49 <benzrf> its a disgrace
04:56:39 * hackagebot keystore 0.5.0.2 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.0.2 (ChrisDornan)
04:57:31 <andreasrx> trying to install trifecta from hackage I get some errors currently, cf. http://lpaste.net/108273
04:57:43 <andreasrx> what's the proper way to handle those?
05:00:08 <zomg> andreasrx: I think the problem is you have some other package installed which depends on an incompatible version of `text`
05:01:32 <zomg> or possibly the wrong version of attoparsec :P these are always kinda confusing
05:01:33 <zomg> lol
05:01:57 <andreasrx> zomg: hm, maybe globally, but I started in fresh sandbox
05:02:00 <zomg> anyway, you could clear your sandbox, and then just make sure you install all the packages you want in one go.. this usually ensures the correct constraints are applied, and correct package versions are picked
05:02:15 <zomg> hm, that's weird then, I'm not really familiar with how the sandboxes work tbh
05:02:18 <k00mi> hm, builds fine for me
05:04:04 <andreasrx> zomg, k00mi: OK, thanks anyway.
05:05:09 <k00mi> andreasrx: the first thing I notice is that it builds semigroups-0.13.0.1, but it installed the newest version for me
05:08:13 <k00mi> andreasrx: can you try 'cabal install trifecta --constraint=semigroups==0.15.2 -v'
05:08:20 <benzrf> bbl
05:08:41 <andreasrx> k00mi: OK, will try that, thanks
05:09:38 <bernalex> anyone feel like helping me with a bunch of error msgs like /home/alexander/git/tempuhs-server/dist/build/libHStempuhs-server-0.0.0.a(Server.o):(.text+0x30b4): undefined reference to `tempuhszmserverzm0zi0zi0_TempuhsziServerziDatabase_runDatabase1_info' ?
05:12:27 <erikd> bernalex: are you building with cabal? have you added a new file and forgotten to add it to the cabal file?
05:12:40 <bernalex> erikd: building with cabal, yes. but I have added the new files.
05:13:28 <mmmm_> bernalex: I haven't found a good way to deal with errors like that.. maybe try cabal clean and rebuild or rebuild your sandbox?
05:17:55 <andreasrx> k00mi: yes, that --constraint=semigroups==0.15.2 -v did it, thanks a lot.
05:19:26 <bernalex> mmmm_: I tried even rm'ing the sandbox and starting anew. might need to try to cabal init a new file & look at it
05:19:27 <k00mi> andreasrx: great, -v is just more verbose output, and I have no idea why that version of semigroups wasn't chosen in the first place
05:19:59 <bernalex> ohh ohh ohh I was missing a file after all! phew
05:21:36 <darthdeus> is there a way to get a ThreadId if I know the actual number? the type is abstract :\
05:22:04 <darthdeus> like for example if i log the id
05:22:10 <darthdeus> and then I want to threadKill it from ghci
05:29:26 <darthdeus> or is there at least a way to "kill all threads spawned in ghci"?
05:31:44 * hackagebot stm-containers 0.1.3 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.1.3 (NikitaVolkov)
05:32:27 <k00mi> exit ghci is one option
05:42:12 <darthdeus> k00mi: yeah I don't like that option :P
05:43:19 <aloiscochard> hey guys, I'm a bit confused about the status of stackage vs platform, and specially why having both and not concentrating effort, they look redundant to me?
05:51:03 <Dodek_> hey, i want to create a client for some protocol. do you recommend using plain sockets, or is there any additional layer handling stuff like buffering, reconnecting etc?
05:55:09 <kuribas> If I wanted to use a floating point comparison within tolerance for Data.Set or Data.Map, that would mean the property (a == b && b == c => a == c) doesn't hold.  Would that be a problem?
05:55:24 <anddam> hello
05:55:43 <kuribas> For example (a == b = abs (a - b) < 1e-10)
05:56:38 <kuribas> Data.Set and Data.Map use a binary tree internally.
05:57:12 <frerich> kuribas: Note that no single epsilon will be appropriate for all floating point values since the numbers are not spread with gaps of equal size between them. Instead, the epsilon should be choosen depending on the value of 'a' and 'b'.
05:57:29 <kuribas> frerich: True, I picked this just as an example.
05:57:39 <anddam> I'm trying to configure pandoc on OS X with macports provided libraries, the setup script says "Setup: At least the following dependencies are missing:" and then lists several libraries that are in fact installed on the system
05:58:15 <anddam> what could prevent runhaskell from "seeing" the libs?
05:58:45 <anddam> https://gist.github.com/anddam/f1c9aee0b71a926dbae9 for the actual output
05:58:51 <frerich> kuribas: If you create a custom float type (e.g. "newtype MyFloat = MyFloat Float") then you could have a custom instance of 'Eq' which makes (==) do whatever you want.
05:59:16 <frerich> I.e. 'instance Eq MyFloat where a == b = abs (a - b) < 1e-10'
06:01:07 <kuribas> For example with that definition 2 == (2+0.9e-10) && (2+0.9e-10 == 2+1.8e-10) but 2 /= 2+1.8e-10
06:01:24 <kuribas> frerich: yes
06:01:33 <kuribas> frerich: That's what I am using.
06:02:15 <kuribas> frerich: I am actually working with 2D points, and I want to group close together points in the binary tree.
06:02:24 <anddam> ah here it is th ebug I stumbled upon https://trac.macports.org/ticket/42082
06:02:50 <quchen> frerich: That instance wouldn't be transitive though :-\
06:04:51 <frerich> quchen: That's true, but in my defense: the definition of equality is not by me but rather a direct qote of what kuribas wrote (who also acknowledged that it's just an example).
06:05:30 <kuribas> (<) and (>) are transitive though.
06:05:31 <quchen> Oh I see.
06:05:58 <kuribas> quchen: It was actually my question, if I can still use it safely in a search tree?
06:07:03 <quchen> Depends on your tree, in general I'm not sure. Do you want to use Double as keys for a Map or something?
06:07:26 <kuribas> Point Double Double actually
06:07:46 <kuribas> But to consider two points the same if they are close together.
06:08:10 <kuribas> (for example magnetic handles in a graphic drawing program).
06:08:39 <quchen> Hm. I'm not sure Map is the right type for that. When you have location information there are other data structures, such as quad trees. But I'm not very familiar with those.
06:08:58 <kuribas> I might use a KD-tree...
06:21:01 <kvanb> heads up atom supports proper soft tab tabstops now
06:21:23 <kvanb> works beautifully with haskell now as a nag-free alternative to sublime text :)
06:34:10 <zrho> Does anyone know of a non-scary formulation of higher order dynamic pattern unification for dependent types?
06:37:44 <dario> "general abstract nonsense" :P
06:39:51 <hyPiRion> You can always attempt to do the clickbait trick
06:39:58 <hyPiRion> "You will never believe what this weird trick will do with your programs"
06:43:44 <ion> I suppose System.Random does not have the guarantee that all future versions will output the exact same numbers given the same seed? Any suggestions on which random library to pick if i want that guarantee?
06:44:38 <merijn> ion: oh, that's a tricky one...
06:44:54 <merijn> I'm not even sure how you would guarantee that at all
06:45:24 <ciaranm> c++11 comes with certain well-defined random number generators with specified seeds that you can use
06:45:42 <ciaranm> http://www.cplusplus.com/reference/random/mt19937/ for example
06:45:54 <ion> merijn: Well, if i implemented, say, the MT19937, it should always output the same numbers given the same parameters.
06:46:11 <MagnusVortex> ion: Why would you want non-random numbers?
06:46:19 <ciaranm> reproducibility
06:46:33 <ion> magnusvortex: For a hashing function that gives the same hash for the same data on both our computers.
06:46:44 <ion> More precisely, BuzHash.
06:46:54 * hackagebot modulo 1.9.1 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.9.1 (HansHoglund)
06:47:15 <bjornars> use a stream cipher?
06:47:24 <ion> I need a “random” but constant Word8 → Word32 table and i’d prefer to have it generated in a reproduceable way.
06:47:32 <ion> bjornars: /me googles, thanks for the pointer
06:47:54 <quchen> ion: Since Word8 has only 256 values, why not hardcode the table?
06:48:10 <ion> quchen: I might, but i’d still prefer to have it generated in a reproduceable way. :-)
06:48:32 <quchen> You mean if you lose the source and have to regenerate it?
06:48:32 <ion> “-- This table was generated with the following command: …”
06:48:33 <MagnusVortex> So then what you want is simply a hashtable?
06:49:07 <MagnusVortex> not a salted hash - not secure, just something that will store your data without collisions and in a fast way.
06:49:18 <ciaranm> some hash functions need a big table of random bits
06:50:00 <tdammers> ion: pick a crypto PRNG, pick a seed, go
06:50:24 <Acer__> hello everyone I have this simple code, http://lpaste.net/108276 in this a person enters a number and that is added to list. Now I normally for getting more elements I call main again but in this case the xs becomes [] each time, how to do what I am trying to achieve ?
06:50:32 <tdammers> (crypto not because security, but because you'll get a good uniform distribution)
06:50:52 <quchen> ion: Use a common hash function like MD5? i -> md5 (BS8.pack ("Salt blabla ++ show i))
06:51:07 <ion> tdammers: Right, thanks.
06:52:15 <MagnusVortex> Acer__: I don't know jack about haskell, but it seems to me that your problem is line 5: xs = []
06:52:27 <ion> quchen: I’m going to use a common rolling hash function like BuzHash, namely BuzHash. :-P The only preëxisting Haskell implementation i saw was in the hash package and it didn’t quite match my needs.
06:53:04 <Acer__> MagnusVortex, I know, but I don't know how to use something like a global list
06:53:05 <MagnusVortex> Acer__: if you reset the list, you just deleted everyone who was in it before you tried adding person n
06:53:18 <Acer__> MagnusVortex, I know
06:53:19 <martinhath> Acer__: do you call main two times?
06:53:48 <Acer__> martinhath, normally that is what I do to create something like a forloop
06:54:01 <Acer__> when not dealing with lists
06:54:16 <Acer__> like if I want a number and then another so I call main again
06:54:42 <Acer__> but I thought about inserting elements to list, but I tried and failed
06:57:15 <Acer__> ?
06:58:36 <joshc> Acer__: how do you know when to stop reading? (what is the terminating condition for reading your list?)
06:59:15 <Acer__> joshc, I'll probably take another input and when the length becomes equal to that then end recursion
06:59:23 <bitraten> what's the function to convert "aaabbcc" to "abc"?
06:59:33 <Acer__> nub
07:00:08 <joshc> Acer__: things are a bit simpler if you have the length up front, as you can use replicateM
07:00:12 <Acer__> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:nub
07:00:31 <joshc> otherwise, you can explicitly recurse and use a list as an accumulator
07:00:38 <bitraten> ok bad example... "aaabbcca" to "abca"?
07:01:03 <Acer__> joshc, I don't know about either accumulator or replicateM
07:02:50 <Acer__> basically I just want to know how people take numbers and add them to list
07:02:56 <Acer__> in haskell
07:03:17 <joshc> :t (:)
07:03:18 <lambdabot> a -> [a] -> [a]
07:03:49 <Acer__> let me retry and come back
07:03:54 <ajcoppa> > map head . group $ "aaabbcc" -- bitraten
07:03:55 <lambdabot>  "abc"
07:04:04 <ajcoppa> > map head . group $ "aaabbcca" -- bitraten
07:04:05 <lambdabot>  "abca"
07:04:12 <bitraten> ajcoppa: thanks!
07:04:16 <ajcoppa> not sure if that's the best way
07:04:54 <joshc> assume your input is a line with an integer n, followed by n lines with integers.  in order to read the n integers into a list, replicateM is well suited:  main = do { n <- readLn; xs <- replicateM n readLn; print xs; }
07:05:27 <Acer__> joshc, ok thanks
07:06:09 <joshc> you'll probably need some explicit type annotations, too.
07:06:50 <Acer__> ok, I'll first read up on the replicateM
07:10:10 <centrinia> @djinn (Not b -> Not a) -> (a -> b)
07:10:10 <lambdabot> -- f cannot be realized.
07:10:13 <centrinia> Why not?
07:10:33 <Saizan> centrinia:  l
07:10:44 <Saizan> centrinia: that's only valid classically
07:11:33 <Saizan> @djinn Either b (Not b) -> (Not b -> Not a) -> (a -> b)
07:11:34 <lambdabot> f a b c =
07:11:34 <lambdabot>     case a of
07:11:34 <lambdabot>     Left d -> d
07:11:34 <lambdabot>     Right e -> void (b e c)
07:12:40 <SaBer> what's Not?
07:13:23 <frerich> Is there some standard module scheme which defines the 'toplevel identifiers' like 'Control', 'Data', 'System' and so on? A bit like a filesystem hierarchy standard? Or is it just naturally grown with some conventions based on good taste?
07:13:32 <Saizan> Not a = a -> Void
07:15:04 <Saizan> frerich: i think that's left to common sense
07:15:30 <croyd> frerich: if you create a new cabal package via `cabal init` I think it lists a bunch of them
07:15:35 <ddellacosta> I'm working through the typeclassopedia and I'm having a really hard time understanding how to implement a functor for (->).  Specifically, I don't know what goes in fmap f _ <-- here
07:16:05 <ddellacosta> seeing that (->) applies to kinds, I feel like I'm thinking on the wrong level of abstraction
07:16:22 <ddellacosta> not sure exactly what to ask to wrap my head around this, I'm sorry!
07:16:32 <zereraz> hello can someone tell me why I am getting error here http://lpaste.net/108276
07:16:40 <Iceland_jack> ddellacosta: Start with the type signature for 'fmap'
07:16:58 <Iceland_jack> then replace every 'f' with the Functor instance
07:17:15 <ddellacosta> Iceland_jack: okay, thanks--let me go through that exercise and see what I discover
07:19:11 <croyd> zereraz: you need to align the `xs <- replicateM a readLn` line with the `let` line
07:19:53 <croyd> zereraz: and disambiguate the type of xs
07:20:00 <zereraz> croyd, stil not working
07:20:20 <zereraz> it says naked expression at top level
07:20:59 <zereraz> ^forget that error
07:21:45 <zereraz> how do I remove the ambiguity
07:21:51 <croyd> zereraz: http://lpaste.net/108281
07:22:26 <zereraz> ok thankyou
07:22:32 <croyd> zereraz: that will read a list of Int's
07:22:50 <croyd> zereraz: also, there's no need to "initialize" xs in the let
07:22:56 <croyd> zereraz: that line can just be deleted
07:23:09 <zereraz> croyd, why is that?
07:23:27 <zereraz> because replicateM returns a list?
07:25:29 <croyd> zereraz: using a `let` doesn't create a "variable" or some such. It just associates a name with an expression
07:26:01 <tdammers> croyd: isn't that what a variable is about? :x
07:26:24 <zereraz> croyd, then why does it work without let?
07:26:40 <croyd> tdammers: I guess it depends on how it's supposed to "vary"
07:27:25 <croyd> zereraz: because `xs <- replicateM a (readLn :: IO Int)` also binds the name xs
07:27:52 <zereraz> croyd, ok thanks
07:34:54 <orion_> https://github.com/i-tu/Hasklig
07:35:00 <orion_> Interesting!
07:45:04 <zereraz> myfunc (x:xs:y) = y:x why is this infinite?
07:46:38 <edwardk> zereraz: the two sides of (:)  don't have the same type   (:)  :: x -> [x] -> [x]
07:47:16 <zereraz> edwardk, myfunc (x:xs:y) = x:y works
07:48:08 <joshc> what is myfunc's intended purpose?
07:48:20 <joshc> > let myfunc (x:xs:y) = x:y in myfunc []
07:48:22 <lambdabot>  *Exception: <interactive>:3:5-25: Non-exhaustive patterns in function myfunc
07:48:30 <zereraz> joshc, I thought it would put the first to the last
07:48:41 <edwardk> zerokarmaleft: so when you plug in (x : xs : y) what you're saying is 'i have (x :: a) : (xs :: a) : (y :: [a])    then you turn it into y : x   which is really backwards because y : [a]   and x is only :: a , not the [[a]] it'd have to be
07:48:46 <edwardk> er zeroaz
07:49:29 <edwardk> on the other hand with (x:xs:y)  both x and xs are still a's and y is [a], so when you turn that into x : y    x :: a   and y :: [a] typechecks just fine
07:49:37 <edwardk> :t (;)
07:49:39 <lambdabot> parse error on input ‘;’
07:49:41 <edwardk> :t (:)
07:49:42 <lambdabot> a -> [a] -> [a]
07:49:50 <edwardk> the two sides aren't the same
07:50:02 <edwardk> the left side is an element of the list, the right side is a whole list
07:50:19 <edwardk> x:y:zs  is two elements and a whole remainder of a list
07:51:27 <zereraz> edwardk, I do not understand the part x:y
07:51:30 <zereraz> x is a
07:51:34 <zereraz> and y is [a]
07:52:23 <edwardk> > let x = 1; y = [2,3] in x:y
07:52:25 <lambdabot>  [1,2,3]
07:52:49 <edwardk> notice 1 is an element, y is a whole list
07:52:54 <zereraz> yes
07:53:04 <zereraz> oh
07:53:05 <zereraz> got it
07:53:14 <zereraz> sorry I forgot the type :
07:53:17 <zereraz> thanks
07:53:38 <joshc> [1,2,3] is the same thing as 1:2:3:[], if that helps.
07:53:52 <joshc> just a little friendlier syntactically
07:53:58 <gamegoblin> Is there anything that is like ` a -> [a -> m a] -> m a ` . So basically you have a list of these functions and it would be equivalent of binding from one to the next, in order
07:54:01 <zereraz> joshc, I was trying to reverse the list
07:54:26 <zereraz> joshc, reimplementing reverse
07:54:47 <joshc> sounds like a worthwhile excercise!
07:54:52 <joshc> exercise*
07:54:52 <vanila> :t foldr (>>=) return
07:54:53 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ b -> b
07:54:54 <lambdabot>     Expected type: (b -> b) -> (b -> b -> b) -> b -> b -> b
07:54:54 <lambdabot>       Actual type: (b -> b) -> (b -> b -> b) -> b -> b
07:55:26 <zereraz> joshc, its part of the 99 haskell problems
07:55:28 <gamegoblin> call it >>>=, so ` 5 >>>= [Just, Just, const Nothing, Just] ` would return ` Nothing `
07:55:47 <vanila> hmmm
07:55:48 <edwardk> :t foldr (>=>)
07:55:49 <lambdabot> Monad m => (b -> m c) -> [b -> m b] -> b -> m c
07:55:59 <edwardk> :t foldr (>=>) return
07:56:01 <lambdabot> Monad m => [c -> m c] -> c -> m c
07:56:06 <edwardk> gamegoblin: ^- that?
07:56:07 <vanila> oooh
07:56:13 <gamegoblin> That looks right
07:56:45 <edwardk> :t foldr (<=<) return
07:56:46 <lambdabot> Monad m => [b -> m b] -> b -> m b
07:56:55 <edwardk> pick your direction =)
07:58:28 <gamegoblin> > (foldr (>=>) return) [Just, Just, const Nothing, Just] 5
07:58:30 <lambdabot>  Nothing
07:58:47 <gamegoblin> > (foldr (>=>) return) [Just, Just, Just, Just] 5
07:58:48 <lambdabot>  Just 5
07:59:12 <gamegoblin> > (foldr (>=>) return) [Right, Right, Left , Right] 5
07:59:14 <lambdabot>  <hint>:1:42: lexical error at character '\b'
07:59:26 <Dodek> hmm, i'm trying to use forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId. it seems that if i want to call show on SomeException, the type a must also be of class Show. how can i work around this?
08:00:10 <gamegoblin> :t (>=>)
08:00:10 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:01:09 <mbrock> Dodek: that doesn't sound right. you should always be able to show a SomeException
08:01:26 <mbrock> Dodek: however, if you tried to show a value of type Either SomeException a, then a would need a Show instance
08:02:50 <Dodek> mbrock: http://lpaste.net/108284
08:03:50 <vanila> Dodek, Left e -> show e
08:04:26 <Dodek> ah, makes sense
08:04:31 <Dodek> thanks
08:15:02 <zereraz> hello, I was wondering why do we need tuples when we have list? what does tuple provide?
08:15:58 <tdammers> zereraz: tuple -> fixed number of elements, different types per element; list -> dynamic number of elements, same type for all
08:16:22 <tdammers> (Int, String, IO (Maybe Double)) -- can't do this with lists
08:16:53 <tdammers> f []; f [1,2,3]; f [12] -- can't do this with tuples
08:19:14 <ddellacosta> I just don't get this. How do you write fmap for this? "instance Functor ((->) e) where ..."  What is ((->) e) actually?  It's a partially applied function type constructor?  But how do you represent that as a functor in the definition for fmap?
08:19:40 * ddellacosta pulls his non-existent hair, 
08:20:19 <Dodek> ddellacosta: "((->) e) f" is the same as "e -> f"
08:20:36 <zereraz> tdammers, thanks!!
08:20:39 <vanila> :t fmap
08:20:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:20:42 <Dodek> ddellacosta: so ((->) e) is just type constructor with a single argument, just like Maybe or IO
08:20:52 <vanila> fmap :: (a -> b) -> (e -> a) -> (e -> b)
08:21:08 <thoughtpolice> ddellacosta: here's a tip - take the type of fmap, '(a -> b) -> f a -> f b', and replace all the occurrences of 'f' with '(->) e' as suggested, keeping in mind the transformation Dodek gave
08:21:22 <tdammers> zereraz: best to forget everything you know about lists and tuples in python ;)
08:21:29 <thoughtpolice> when you write out the 'full type' in such a way, you will get what vanila said - which has a very straightforward implementation
08:21:46 <ddellacosta> Dodek, thoughtpolice: I've tried that like so, but I'm still not getting something very basic: fmap f (a -> b) = (a -> (f b))
08:21:50 <lf94> When you have myfunc :: Int -> Int -> Int, myfunc a b = a + b, What exactly is happening during compilation? Is there a paper or blog post or something that explain this?
08:23:02 <Dodek> ddellacosta: fmap takes a function (a -> b), and gives you a function (f a -> f b)
08:24:00 <ddellacosta> Dodek: yeah, I'm getting confused between the type sig and the implementation of fmap
08:24:11 <randomguy> I'm trying to implement a loan repayment formula in Haskell but keep getting the wrong results. I'm wondering, did I overlook the order of evaluation? http://lpaste.net/108285
08:24:15 <vanila> once you have the type, you just need to fill in the value to match it
08:24:17 <vanila> that part is easy :)
08:24:25 <vanila> fmap :: (a -> b) -> (e -> a) -> (e -> b)
08:24:26 <vanila> so you start
08:24:29 <vanila> fmap f g e = _
08:24:37 <vanila> and then you need to write a 'b' using your f,g and e
08:25:08 <zereraz> tdammers, I know little about them in python too
08:25:24 <ddellacosta> vanila: I've already tried something just like that: fmap f g e = g f e, should that not be it?
08:25:34 <vanila> that's almost it!
08:25:38 <vanila> look at it this way
08:25:38 <vanila> you have
08:25:41 <vanila> f :: a -> b
08:25:44 <vanila> g :: e -> a
08:25:46 <vanila> e :: e
08:25:50 <vanila> and want to make b
08:25:58 <vanila> so put e into g:  (g e)
08:26:02 <vanila> that gives you g e :: a
08:26:10 <vanila> and then put that into f:   f (g e) :: b
08:26:43 <ddellacosta> vanila: thanks, processing that
08:26:55 <tdammers> zereraz: ah, ok, ignore that then
08:27:49 <zereraz> tdammers, what is the difference ?
08:28:09 <Sornaensis> ahhh, the joys of working on two computers at the same time with a KVM switch
08:29:51 <tdammers> zereraz: in python, they're the same thing, except that lists are mutable while tuples are not
08:30:00 <tdammers> zereraz: which is kind of a nasty can of worms in itself
08:30:22 <tdammers> Sornaensis: real men use ssh and screen/tmux for that
08:30:47 <zereraz> tdammers, main difference is the type right
08:30:58 <zereraz> like same type and multiple types
08:31:06 <zereraz> between them
08:31:10 <tdammers> zereraz: oh, you mean in haskell
08:31:28 <tdammers> I'd say they don't even have an awful lot in common
08:31:31 <zereraz> tdammers, between haskell and python lists and tuples
08:31:42 <zereraz> ok
08:32:09 <tdammers> python basically has two sorts of lists; one that you can update in-place, called "list", and one that you can't, called "tuple"
08:32:22 <tdammers> in Haskell, they don't have a lot in common at all
08:32:33 <zereraz> ok thanks
08:33:06 <zereraz> so in python we could do everything with lists that we cannot do in tuples
08:33:19 <zereraz> can do*
08:34:08 <ddellacosta> vanila: wait, it's just as simple as that? fmap f g e = f (g e)
08:34:17 <vanila> ddellacosta, that's it!
08:34:22 <Sornaensis> tdammers: I have a windows machine alongside my arch linux box
08:34:23 * ddellacosta *sobs* over the last hour
08:34:31 <vanila> How can we be sure it's correct? FIrst of all it typechecks that's a really good sign
08:34:35 <Sornaensis> KVM slightly more convenient :p
08:34:38 <vanila> but this is very important
08:34:40 <vanila> fmap id = id
08:34:42 <tdammers> Sornaensis: check.
08:34:47 <vanila> fmap (f . g) = fmap f . fmap g
08:35:05 <vanila> fmap id g e = id (g e) = g e  #1 correct
08:35:25 <ddellacosta> I guess the problem is I'm having a really hard time mapping that to what ((->) e) actually is, and what f g and e are concretely
08:35:35 <vanila> fmap (f . g) h e = (f . g) (h e) = f (g (h e)) = (fmap f . fmap g) (h e)  #2 correct
08:36:29 <Aesop> hey guys I'm trying to run effectful computations till they fail and save the accumulated data structure with data.binary but my data keeps geting corrupted if there appears an failure while otherwise it is fine
08:36:31 <vanila> ddellacosta, fmap is actually just (.) function composition, in the ((->) e) case
08:36:38 <Aesop> i wrote a function http://lpaste.net/108288
08:36:55 <Aesop> any ideas what could go wrong with it?
08:37:07 <ddellacosta> vanila: thanks so much for your help, I really appreciate it.  I'm going to have to think through all of this and try to understand...what I don't understand.
08:37:13 <haasn> Aesop: looks correct to me, the error might be somewhere else
08:37:21 <ddellacosta> vanila: but your help was really great!
08:37:52 <Aesop> ok but what could fail the data file gets written
08:38:08 <Aesop> but when i want to read it back in it says not enough bytes
08:38:19 <Aesop> which i guess means its corrupted
08:38:41 <Aesop> i thought maybe lazy evaluation is a problem but i cant get my head around why
08:39:27 <haasn> Aesop: I'm quite sure you need to show more of the code
08:39:35 <Aesop> sure
08:40:16 <Aesop> http://lpaste.net/4594208611088990208
08:44:00 <haasn> It doesn't look like lazy evaluation is involved at all
08:44:29 <Aesop> Mhh I thought haskell is lazy be default
08:44:31 <haasn> Oh, wait
08:44:35 <haasn> “encodeFile” is indeed lazy
08:44:39 <kstt> hi,
08:45:22 <kstt> GHC 7.6 and 7.8 are crashing on WIN 7 32bits when trying to install package Chart-cairo.
08:45:32 <haasn> Or is it? Hmm, the documentation says yes but the source code suggests no
08:45:48 <Aesop> but if it were could it be problem?
08:45:50 <kstt> How can I investigate please ? Is there a flag I can use (I'm using cabal)
08:46:22 <haasn> Aesop: It might be a problem that the program is terminating before “encodeFile” is finished writings its data, somehow
08:46:33 <haasn> Oh, I think I know what it means by “lazy” - it means the data is produced and written incrementally
08:46:36 <haasn> But it's not “lazy IO”
08:46:41 <haasn> since it uses lazy bytestring
08:47:06 <haasn> Still, that shouldn't be a problem; unless perhaps “getChartRaw” actually terminates the program prematurely
08:47:08 * hackagebot git-sanity 0.0.2 - A sanity checker for your git history.  http://hackage.haskell.org/package/git-sanity-0.0.2 (aloiscochard)
08:47:16 <haasn> Aesop: You say you only get corruption if the program errors, right?
08:47:22 <haasn> That is if you hit the Nothing branch
08:47:28 <Aesop> true
08:47:39 <geekosaur> also consider buffering, which is another form of "laziness"
08:48:03 <haasn> Then I would investigate to see if getChatRaw possibly causes your program to terminate prematurely
08:48:05 <haasn> In that case
08:48:30 <haasn> Although that still doesn't really make sense - *unless* it returns _|_ somewhere
08:49:58 <haasn> That makes the most sense to me - getChartRaw returns Just _|_; which causes your sequenceTillNothing to continue happily (since it doesn't force anything), and eventually you (lazily) produce a map which is also _|_; but then encodeFile starts writing out the data for it and once it forces the map (and thus the _|_) it errors and terminates the program?
08:50:00 <haasn> I don't know
08:50:00 <Aesop> but if the trigger putStrLn "Error: Nothing!" in sequenceTillNothing dosent it mean that getChartRaw didnt actually terminate?
08:50:17 <haasn> Oh, do you get the “Error: Nothing!”
08:50:24 <Aesop> yes
08:50:30 <haasn> Here's what you could try
08:51:47 <haasn> Add something like:  deepseq newDB' $ putStrLn "foo" before the encodeFile, perhaps; or if you can, even print it out to STDOUT to confirm that it's correct and stuff. That might give you some more clues as to where the error is coming from
08:53:17 <Aesop> ok will try unfortunately I needs quite a few minutes till it hits an error
08:53:34 <Aesop> and thanks of course
08:54:22 <haasn> Or perhaps let bytestr = encode newDB'; print bytestr; L.writeFile chartsPath bytestr
08:54:49 <haasn> That way you know the entire data is forced and serialized *before* doing any file I/O
08:55:09 <Aesop> sounds like the way to go
08:56:51 <mrpro> hi
08:57:03 <mrpro> http://youtu.be/irUzEUJOB00
08:57:16 <aranea> I just spent 15 minutes writing code for recursing over the files in a directory hierarchy, but as it turns out, ripping out that code and doing "find dir -type f | xargs myhsprog" is faster...
08:59:06 <mbrock> laziness, the primary virtue of a programmer :)
09:00:00 <dutchie> aranea: do one thing and do it well ;)
09:00:27 <aranea> Exactly.
09:01:28 <aranea> The only drawback is that the length of the argument list is limited, therefore it won't work with too many files
09:01:39 <mbrock> xargs takes care of that, no?
09:01:46 <mbrock> by invoking your program several times
09:02:03 <aranea> sometimes that can be avoided with -n10000 or so, but I need to handle all files in the same program run
09:02:31 <mbrock> oh, I see...
09:02:55 <aranea> I guess I
09:03:34 <kstt> GHC crashes on Windows when installing Chart-cairo dependency. Please, could someone teach me how to gather all available information for a bug report. Thank you.
09:03:43 <aranea> .. I'll try and rewrite the program so that the files can be split up over several program runs
09:04:17 <mbrock> otherwise you could, um, do something like xargs echo, and just have your program read lines from stdin?
09:06:29 <fragamus> hey my research project at VMware is ending... are there any bay area haskell jobs out there
09:08:56 <aranea> mbrock: Hey, thanks! I didn't think of that :)
09:09:33 <aranea> (btw, xargs echo is a no-op, I can just pipe directly from find)
09:09:41 <mbrock> uhh, yeah (:
09:09:58 <Guest16187> Eq a => a -> [(a, b)] -> Maybe b
09:10:10 <mbrock> :t lookup
09:10:11 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
09:10:28 <Guest16187> ghci complains that b is rigid type variable
09:10:29 <mbrock> if that was the question (:
09:10:35 <Guest16187> :)
09:11:10 <Guest16187> Could not deduce (b ~ Maybe b)
09:11:11 <haasn> “rigid type variable”​ means “this should be polymorphic, you can't instantiate it”
09:11:50 <haasn> b ~ Maybe b is also a no-no; that would be like “Maybe (Maybe (Maybe (Maybe (Maybe ....” and Haskell doesn't allow that
09:12:02 <haasn> You probably have some other error
09:12:13 <Guest16187> seems
09:12:57 <mbrock> basically, you seem to have told GHC that your list has type [(a, Maybe b)], perhaps by using the result of `lookup` in an unsound way
09:13:07 <bb010g> Are arrows a special case of semifunctor?
09:13:18 <haasn> What's a semifunctor?
09:13:45 <mbrock> Guest16187: "could not deduce (x ~ y)" means "your code tells me that x and y should be the same type, but they're not"
09:13:58 <bb010g> http://hackage.haskell.org/package/semigroupoids-4.0.4/docs/Data-Semifunctor.html
09:14:49 <Guest16187> oh, may be I am doing wrong at some other place
09:14:51 <Guest16187> :(
09:15:17 <mbrock> GHC always forgives...
09:15:42 <mbrock> ...unless you use unsafeCoerce
09:16:01 <Guest16187> got it thanks
09:16:06 <haasn> bb010g: Every category is a semigroupoid (trivially); and hence every functor is also (trivially) a semifunctor - since arrows give rise to two functors (one covariant and one contravariant) on regular categories, it logically follows that arrows also give rise to two semifunctors
09:16:38 <Guest16187> I was telling ghci to have type Maybe but one of the path was evaluating to b
09:16:43 <haasn> so yes, you can write a Semifunctor ((->) r) (->) (->) instance
09:16:44 <Guest16187> just made it Just b
09:16:52 <haasn> And this is also WrappedFunctor ((->) r)
09:18:08 <haasn> Not sure if that's the answer you were looking for
09:18:17 <aranea> Most of the information returned by the stat() system call is available from System.Directory, but I don't see anything about file sizes in there. How do I find out these?
09:18:36 <bb010g> haasn: I meant the Control.Arrow type, but that's interesting also.
09:18:42 <aranea> fstat(), of course
09:18:49 <haasn> bb010g: Ah, similar reasoning applies - every Arrow type can be made into a Functor
09:20:04 <schell> i’m getting an error in ghci that i’m not getting when compiling with cabal - (No instance for MonadIO…) - does that sound like a common ghci gotcha?
09:20:15 <haasn> newtype WrappedArrow a b c = WrappedArrow (a b c); instance Functor (WrappedArrow a b) where fmap f (WrappedArrow g) = WrappedArrow (arr f <<< g)
09:20:31 <haasn> since arr id = id and id <<< g = g this passes the Functor laws
09:20:31 <schell> the type in question is fully applied with MonadIO instances all the way down, if that makes sense
09:21:03 <schell> it just seems that ghci can’t figure out…where they’re defined?
09:21:13 <haasn> (and hence the semifunctor laws)
09:21:28 <haasn> There are probably more ways to make Arrow into Semifunctor; but that's the easiest I can think of and a simple answer “yes” to your question
09:21:32 <bb010g> haasn: Cool. Thanks!
09:21:52 <haasn> (by more ways I mean into making it a semifunctor on different semigroupoids other than (->) (->))
09:23:29 <aranea> Looks like I can get the size via hFileSize from System.IO, but I'd have to open the file first for that.
09:26:14 <aranea> Ahh, there's fileSize in System.Posix.Files, but why isn't there anything in System.Directory? As I said, the other stat() information is there (modification time, access permissions)...
09:26:57 <haasn> I don't know; but I did find System.Posix.Files.ByteString.getFileStatus :: RawFilePath -> IO FileStatus which might come in handy for getting all of the stat() information at once
09:27:24 <haasn> Maybe there's something related to Windows?
09:27:53 <haasn> Like, does Windows have an equivalent way to get the file size easily? I would imagine so, hmm
09:29:16 <aranea> haasn: yes, I have to call getFileStatus, fileSize wants that as an input
09:30:00 <aranea> haasn: I guess you're right that something non-unix-related is the cause
09:30:24 <aranea> but who uses non-unix systems anyway? >:)
09:31:18 <Mkster> What would be the signature for a function using a list of lists as argument? Is is [[Int]]?
09:31:19 <haasn> I guess as far as performance is concerned there's no way you're improving on fmap fileSize . getFileStatus  either way, right?
09:31:41 <haasn> Mkster: [[a]] for whatever type a, yes
09:31:53 <Mkster> Ok thanks
09:36:37 <darthdeus> I wish threads had callbacks on exit :(
09:36:52 <darthdeus> that I could set in the middle of the thread running :P
09:37:21 <mzero> meaning you want the thread to call something on exit? Or something in the thread to be called before reaping?
09:38:13 <aranea> haasn: Yes, that should be pretty fast. I was just wondering why one has to dig so deep in just to get such basic information.
09:39:42 <Mkster> haasn: what am I doing wrong then: http://lpaste.net/108293
09:40:34 <mzero> > let tst (x:xs) = x in tst [[1,2][3,4]]
09:40:36 <lambdabot>  Couldn't match expected type ‘[t1] -> t’ with actual type ‘[t0]’
09:40:51 <mzero> > let tst (x:xs) = x in tst [[1,2], [3,4]]
09:40:52 <lambdabot>  [1,2]
09:40:58 <mzero> the problem was in your test case!
09:41:22 <Mkster> Now I see it
09:41:26 <Mkster> Ok thanks
09:41:47 <mzero> btw, Mkster - your type signature can be more general:   tst :: [[a]] -> [a]
09:42:02 <mzero> and it will still work with Int !
09:42:23 <Mkster> Yes I know but thanks
09:42:29 <aranea> haasn: On the occasion, I switched my whole program to System.Posix, that way I can use ByteStrings as FilePaths and get a little bit more performance
09:42:35 <darthdeus> mzero: i want to do some cleanup before the thread exits, or even after it exists
09:42:41 <haasn> It's also missing a case for [] :)
09:42:50 <haasn> aranea: Not to mention correctness!
09:42:51 <darthdeus> mzero: but i don't have access to the outter scope of the thread, i'm somewhere deep
09:43:02 <haasn> ByteString increasing performance should only be a side effect :)
09:43:05 <mzero> aranea: have you actually measured the performance improvement by having ByteString FilePaths? I’d be interested to know if it were significant
09:43:10 <haasn> It's the right thing to do on POSIX systems
09:43:20 <haasn> File paths are not Strings nor have they ever been
09:43:42 <mzero> darthdeus: I’m thinking an MVar (IO ())  might be the friend you are looking for
09:44:14 <darthdeus> mzero: I can't reach to the end of the thread, since the problem i'm having is because ghci doesn't kill of child threads
09:44:37 <darthdeus> mzero: more details in my SO question :P http://stackoverflow.com/questions/24999636/is-there-a-way-to-kill-all-forked-threads-in-a-ghci-session-without-restarting-i
09:44:58 <darthdeus> but basically i just want to kill whatever threads I started when I call a function
09:45:01 <mzero> haasn: yes, that is certainly true… though some OSes are moving in other directions… but nonetheless, I was piqued by the “little bit more performance” issue… I’m amazed it is even measureable
09:47:08 <aranea> mzero: I don't know if it's measurable. I'll have a look when I'm done (It'll take some minutes, as I have to re-implement some functions - for example, there's no getDirectoryContents, just readDirStream which gives one directory entry at a time.
09:47:15 * hackagebot unicoder 0.4.1 - Make writing in unicode easy.  http://hackage.haskell.org/package/unicoder-0.4.1 (ZankokuOkuno)
09:47:54 <mzero> aranea: my guess is that it is almost certainly not…unless you are doing something like implementing ‘find’ utility… and even then I’d be surprised….
09:48:46 <mzero> I’d use FilePath type that is convenient… in many modern OS installations, all user created file paths are UTF-8 anyway.. and that is what the user expects
09:50:55 <eriksensei> hi all, what's the difference between the defaultTimeLocale from old-locale vs. the one from haskell98?
09:51:38 <RyanGlScott> Is there a ghc flag for cleaning up the various object files it produces? (.hi, .o, etc.)
09:51:38 <eriksensei> it seems I need one of them to format a date
09:52:27 <aranea> mzero: Yeah, I already decided to stick with FilePath. It's really not worth the hassle, the program I'm writing atm is an one-shot anyway :)
09:52:51 <mzero> exactly!
09:58:29 <estulticia> hello, is there anyone running haskell on archlinux-raspi?
09:59:04 <estulticia> pacman -Ss ghc returns nothing
10:00:12 <orion> What is the most common way people code themselves in to a box with Haskell?
10:01:20 <locallycompact> People => Box People
10:01:21 <StoneToad> it seems like all the more recent opengl turorials are using the linear library, while older ones used Vec or vect-opengl, does anyone have thoughts as to any particular resone for this?  (well, other then Vec's horribly obtuse no instance type errors...)
10:01:26 <pjdelport> ...not using newtypes or strict fields?
10:05:23 <lf94> How can I install profunctors 4.1 on debian wheezy?...
10:05:45 <lf94> I'm trying to use Charts-diagrams/cairo but neither can install because profunctors 4.1 is a dependency
10:06:41 <dwcook> lf94, is that a distro package or a cabal package or something else?
10:06:47 <k00mi> StoneToad: the author of linear (Edward Kmett) is well known for producing quality libraries, that's probably part of the reason
10:06:59 <lf94> dwcook: cabal
10:07:11 <dwcook> lf94, then just install profunctors using cabal
10:07:21 <lf94> Chart-1.2.3 depends on profunctors-4.1 which failed to install.
10:07:35 <dwcook> lf94, use lpaste to show the logs of the attempt
10:07:40 <lf94> src/Data/Profunctor.hs:37:5: parse error on input `type'
10:07:44 <lf94> That's the only error
10:08:01 <StoneToad> k00mi: thanks! that makes a lot of sense, I will go with that then
10:08:20 <lf94> It's probably because debian wheezy is using an older ghc
10:08:29 <lf94> The Glorious Glasgow Haskell Compilation System, version 7.4.1
10:08:51 <StoneToad> always nice to use a library that's commonly used (since they tend to be well supported)
10:08:59 <StoneToad> and have the bugs banged out
10:09:13 <dwcook> lf94, hmm, maybe. You could install the binaries for the latest GHC perhaps. http://www.haskell.org/ghc/
10:11:24 <lf94> dwcook: should I get the platform install
10:11:26 <lf94> or just the binary
10:12:02 <dwcook> lf94, it's entirely possible a more recent platform would work as well but the only two things you really need are GHC and cabal-install
10:24:06 <kstt> Help wanted : Is it a well known fact that GHC on windows crash when compiling a module that uses Template Haskell ?
10:25:11 <RyanGlScott> kstt: What module?
10:25:50 <kstt> Hi RyanGlScott. In this case : Graphics.Rendering.Chart.Backend.Cairo
10:26:35 <kstt> RyanGlScott: but I had a problem looking similar earlier, with a module of mine.
10:27:10 <jfischoff> is there a async equivalent of forkFinally?
10:27:25 <RyanGlScott> kstt: Are you trying to build the Chart-cairo package?
10:27:56 <jfischoff> I guess I should mask exceptions before a wait
10:28:28 <kstt> RyanGlScott: yes.
10:28:44 <RyanGlScott> kstt: Let me see if I can build it.
10:28:52 <yitz> kstt: generally TH works fine on Windows. it will crash if the specific TH code tries to runs something that doesn't work.
10:29:11 <yitz> just like on any other platform.
10:29:18 <kstt> RyanGlScott, details here : https://github.com/timbod7/haskell-chart/issues/39
10:29:34 <kstt> RyanGlScott: this is really nice, much appreciated
10:30:16 <rwbarton> first of all, try adding --ghc-option=-v to the cabal install command line
10:30:46 <kstt> yitz: I am going through hell trying to build on Windows a project that has been developed on Linux.
10:31:14 <kstt> rwbarton: I needed this flag ! Thank you, I am trying right now and will report ASAP.
10:32:41 <joe9> I have a json request that I am building using encodeJSON of Text.JSON. I have a datatype which can have values of ONE, TWO or "". Which haskell data type would be a good fit for such data?
10:33:24 <joe9> I had it as enum: jsonEnum = ONE | TWO deriving (Eq, Show, Enum, Bounded, Data. Typeable)
10:33:42 <joe9> but, not sure how to specify the "" (blank string). Any thoughts, please?
10:33:45 <barrucadu> joe9: "Maybe {some data type which can have the values ONE or TWO}"?
10:34:43 <joe9> barrucadu: would have check if encodeJSON puts "Just ONE" or just "ONE" when using Maybe though.
10:41:39 <yitz> kstt: sorry to hear that. we develop back and forth between linux and windows without too many problems, generally.
10:41:42 <kstt> rwbarton: GHC output pasted to bug report https://github.com/timbod7/haskell-chart/issues/39 . Thank you very much.
10:42:18 <yitz> kstt: but cairo has traditionally been part of the gtk ecosystem, which definitely has some pretty deep linuxisms.
10:42:20 <kstt> yitz: I'm happy to read that you have success.
10:42:42 <kstt> Indeed.
10:42:47 <orion> hmm
10:42:56 <orion> :t (<$>)
10:42:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:43:12 <kstt> yitz: I wish I had an other viable option than GTK/Cairo.
10:43:15 <yitz> orion: (<$>) == fmap
10:43:27 <orion> yitz: Indeed. I am confused by this code:
10:43:54 <yitz> kstt: writing a gui?
10:44:12 <orion> yitz: get = MessageHeader <$> getWord32be <*> get <*> getWord32le <*> get
10:44:27 <kstt> yitz: Yes, GUI + Charts
10:44:45 <orion> Where MessageHeader is a 4-ary data constructor
10:44:59 <kstt> orion: see applicative functors
10:45:42 <yitz> orion: roughly, that means apply the four-argument function MessageHeader to the values you get from running those four get operations inside the Applicative.
10:45:43 <rwbarton> kstt: hmm, mysterious. so it doesn't appear to be during Template Haskell expansion after all; but I don't understand what went wrong
10:46:20 <yitz> orion: (presumably, the Applicative here is Get from the binary or cereal package)
10:46:21 <kstt> rwbarton: did you succeed to build it ?
10:46:26 <orion> yitz: Indeed.
10:46:35 <rwbarton> no, I haven't tried, but I don't have windows anyways
10:46:52 <kstt> rwbarton: ok. It builds fine on my linux box.
10:47:12 <kstt> The report has been updated with more data.
10:47:33 <rwbarton> right, I saw that
10:48:10 <rwbarton> the messages from ghc all look normal
10:48:24 <orion> yitz: So, "MessageHeader <$>" will lift the MessageHeader function in to the Data.Binary context, then "getWord32be <*>" will apply the result of getWord32be to MessageHeader, which results in another function, this time a 3-ary one, is that correct?
10:48:33 <yitz> orion: that is the common idiom for Applicatives. you have a single <$> followed by zero or more <*>. it means apply the function to the left of <$> to the arguments you get from running the things separated by <*>.
10:48:56 <lf94> any ideas on how to fix this?: /usr/bin/ld: cannot find -lHStagged-0.7.2-ghc7.8.3
10:49:20 <kstt> rwbarton: do they ?
10:49:22 <yitz> orion: right. well, MessageHeader is applied to the result of getWord32be, not the other way around.
10:49:42 <augur_> hmm. can Foreign.Storable be used for more complex types like lists and maps?
10:50:01 <trap_exit> does EDSL in haskell generally mean (1) use template haskell or (2) lots of operator overloading ?
10:50:25 <orion> yitz: Ahh ok, but the key point is that the application of a the MessageHeader function results in another function.
10:50:26 <trap_exit> more precisely: I want to learn how to create EDSLs in Haskell. However, examples i've seen so far (Yesod) seems kind of over complicated.
10:50:33 <orion> I assume
10:50:33 <trap_exit> Whats' a good way to get started with designing EDSLs in haskell ?
10:50:43 <yitz> > (:) <$> Just 3 <*> Just [4,5] -- orion, another example
10:50:44 <lambdabot>  Just [3,4,5]
10:50:57 <yitz> orion: exactly
10:53:02 <rwbarton> kstt: well, everything up to "This application has requested the Runtime to terminate it in an unusual way." does
10:55:02 <joe9> barrucadu: encodeJSON adds the "Just" for Maybe datatypes.
10:56:09 <vanila> please can someone help me with emacs haskell-mode?
10:56:14 <trap_exit> https://gist.github.com/anonymous/2e9128fd4321a5cfc8be
10:56:19 <trap_exit> how do I install ghcjs-boot --dev
10:56:24 <jcullen> vanila: whats your problem?
10:56:28 <vanila> http://lpaste.net/108298 these are the three places "tab" puts my parameter
10:56:32 <vanila> I need it next to the () though
10:56:52 <vanila> This is from (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
10:57:06 <vanila> what should I put in .emacs to make it do something sensible?
10:57:28 <jcullen> try using haskell-indent-mode instead
10:57:43 <jcullen> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent')
10:57:53 <yitz> vanila: i use turn-on-haskell-indent, like jcullen.
10:58:05 <jcullen> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
10:58:05 <jcullen> that is
10:58:10 <jcullen> or if you have more time
10:58:15 <jcullen> take a look at chris done's structured haskell mode
10:58:16 <vanila> thanks very much - I'm trying this out now
10:58:17 <vanila> it says Indent cycle (3)... and I get the same behavior for that though
10:58:27 <jcullen> I've just started using it and its pretty sweet, and avoids the need for any of the indent modes
10:58:46 <jcullen> its a bit weird to get used to though
10:59:03 <vanila> I need a 4th indent place, so I can align my parameter
10:59:17 <yitz> vanila: but in general, i view the tab indentation as just a helper, and don't expect it to do exactly what i want all the time. it's often right, but if not, i pick the one that's closest.
10:59:31 <yitz> vanila: and then move to where i want from there.
10:59:33 <vanila> is there a way that I can just do 100% manual indentation?
10:59:43 <yitz> vanila: ^J
10:59:55 <vanila> when I didn't have an indentation mode pressing tab would make an error window come up instead of spacing to the next tab stop
11:00:10 <jcullen> yeah I've noticed the same thing vanila
11:00:16 <jcullen> and I spent a while investigating why
11:00:22 <jcullen> and couldn't figure it out
11:00:25 <yitz> vanila: sorry, ^M. (^J is the same as enter)
11:00:29 <jcullen> if anyone knows why that happens I'm curious too
11:00:49 <yitz> ah
11:01:26 <yitz> vanila: maybe try turn-on-haskell-simple-indent
11:02:38 <yitz> vanila: personally i use ^U-SPC and ^U-^U-SPC for manual indentation
11:02:50 <vanila> ok thanks! I think simple-indent gets out of my way enough to work :)
11:03:03 <yitz> great!
11:03:14 <joe9> vanila: this is my haskell init for emacs: http://codepad.org/o7ZzZYVK
11:03:50 <vanila> thanks :)
11:03:54 <joe9> could not get shm to work properly. I think Stylish-haskell is better.
11:08:43 <augur_> johnw: can storable be used for compound data like lists and maps?
11:10:42 <schell> does anyone know why ghci can’t find my MonadIO instance?
11:11:23 <rwbarton> at a guess, perhaps you have multiple versions of mtl and/or transformers installed
11:11:31 <schell> it’s giving me an error “No instance MonadIO…” for my type which is a concrete (fully applied)…
11:11:41 <schell> rwbarton: oh, that’s a thought
11:12:00 <schell> it’s only ghci and hdevtools that is doing it, ghc/cabal compiles fine
11:12:25 <schell> rwbarton: how do i check in that case?
11:12:32 <schell> ghc-pkg?
11:12:41 <bb010g> Does Yi have a GUI?
11:13:10 <schell> rwbarton: ooh - i have two of each
11:17:14 <marchelzo_> Can someone who knows a bit about parsec explain to me why this parser fails to parse a single digit number? http://lpaste.net/108300
11:18:21 <vanila> marchelzo_, try ading try before parseDouble
11:18:41 <vanila> I think the problem is that "many1 digit" succeeds in parseDouble, so it commits to parsing a double - then fails to see a "." so it fails overall
11:19:22 <marchelzo_> vanila: ohh its consuming any digits before the decimal, so where there is no decimal, parseInt is attempting to parse an empty string
11:19:24 <marchelzo_> thank you!
11:19:54 <marchelzo_> it works now :)
11:20:06 <David> Hi guys
11:20:24 <rwbarton> schell: unregister the new ones (probably mtl-2.2.1 and transformers-0.4.1.0)
11:20:59 <rwbarton> schell: and then follow these instructions: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#lockdown
11:21:11 <schell> rwbarton: thanks - that seems to have done the trick
11:21:40 <schell> sooo much less annoying! i can now get warnings and actual errors :)
11:22:18 <schell> ahhh - constraints, right
11:22:29 * hackagebot yesod-auth 1.3.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.3 (MichaelSnoyman)
11:23:12 <eacameron> does anyone know of a database implementation in haskell? With cloud haskell on the way, I imagine that haskell would be quite good at scalable databese implementation. I'm particularly interested graph databases actually
11:23:39 <David> What's the idiomatic way to do a tree modification in haskell? I have a data structure Node{bit :: Bool, children :: [Node], mainChild :: Node} | Leaf and I want to walk through the tree and convert a fixed number of bits to true in this order: current node first, and then mainChild, and then the mainChilds of children, and then the mainChilds of the children of mainChild, etc.
11:25:58 <schell> eacameron: there’s acid-state and then a number of adapters for other dbs
11:26:58 <stolaruk> David: Can't you just fold over it?
11:26:58 <schell> acid-state is kind of like a roll your own database system, it persists your own types
11:27:03 <eacameron> schell: acid-state is the only one I can think of that's actually implemented in haskell, any others (I'm not referring to bindings to the countless dbs out there)
11:27:09 <David> stolaruk: not sure how I would do that
11:27:19 <schell> eacameron: yeah, that’s all i’ve seen
11:27:59 <schell> i wonder what acid-state on HalVM would be like (or if it’s doable)
11:28:01 <Ankhers> Does Haskell have a data type like a Map with O(1) complexity on lookup?
11:28:08 <David> if I were doing this imperatively I'd have two queues of pointers, and when I visit a node push its mainChild into queue 1 and then its children into queue 2, then when queue 1 is empty move everything in queue 2 to queue 1
11:28:12 <David> but that's rather unfunctional
11:28:41 <stolaruk> David: Are you familiar with the Foldable typeclass?
11:28:46 <stolaruk> I think that's what you'll want.
11:29:51 <David> stolaruk: I'm not sure how to apply foldable here
11:29:54 <eacameron> Ankhers: try HashTable
11:30:16 <David> since I'm not really folding the tree, but rather outputting a modified version with the exact same structure (only a few flipped bits)
11:31:34 <eacameron> Ankhers: HashTables requires that you do things in IO or ST monads but it's the fastest implementation so far as I know. HashMap is also really fast ( essentially O(1) ) but allows you to stay pure
11:32:01 <David> This smells more like something you'd do with Lens, but I'm not familiar enough with Lens and I'm fine with a quick and dirty solution
11:32:43 <Ankhers> eacameron: I thought hashmap was deprecated.
11:32:58 <mmachenry> Is there a better way to write a simple arithmetic on integers with a lot of conversion? My code "fromIntegral agents - (fromIntegral transfers + fromIntegral (dialing+answered)*transferRate) > 0"
11:33:08 <kludgy> David: As you described the problem is sounds something like an fmap..
11:33:12 <jfischoff> Ankhers: the hashmap in unordered-containers
11:33:20 <jfischoff> Data.HashMap.Strict
11:33:35 <mmachenry> Oh also transferRate :: Float
11:34:11 <David> kludgy: true, except for one thing - I want to flip a finite number of bits, and those should be the bits belonging to the first n nodes encountered in the traversal I described
11:34:15 <kludgy> David: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Traversable.html ?
11:34:24 <eacameron> on another note: Is Haste the most mature hs-to-javascript compiler at this point?
11:34:28 <kludgy> David: ah
11:34:58 <Ankhers> jfischoff, eacameron: Thanks. I will look into those.
11:35:01 <David> and I don't know exactly how many nodes I need to traverse, since I need to change n nodes from False to True
11:35:26 <David> and I don't already know which ones are False and which ones are True
11:35:29 <David> ahead of time
11:36:36 <begriffs> I'm working with numerical ranges (from, to) and I would like to allow the range to be unbounded above. Should I use "infinity" from Data.Number.Transfinite or is there a more Haskelly way to model the problem?
11:36:59 <vanila> you could use data Unbounded a = Infinity | Bounded a
11:37:02 <kludgy> David: So your traversal will at the very least need to accumulate a running total through the computation.
11:37:12 <David> kludgy: yes
11:37:29 <David> my current (rather kludgy) idea is to add a unique ID to each element in the tree
11:37:42 <kludgy> David: My thought is to count first, then map
11:37:52 <begriffs> vanila: it would be nice if I could compare Int with this type using the normal operators and get e.g. 2 < Infinity
11:37:57 <David> and then do the traversal, collect a list of IDs corresponding to the ones to flip, and then do another traversal flipping those
11:38:02 <David> but that seems rather ugly
11:38:11 <vanila> :t (>)
11:38:12 <lambdabot> Ord a => a -> a -> Bool
11:38:18 <David> (at least it's linear time, though...)
11:38:28 <vanila> if you create an Ord instance for Unbounded then you can do that -- but it will cast '2' to unbounded
11:39:04 <phaazon> hey, I have a tree with several ctors to build the nodes
11:39:14 <phaazon> I’d like to modify the AST
11:39:18 <phaazon> like AST a -> AST a
11:39:26 <phaazon> but I have no idea how to deal with that kind of issue
11:39:30 <phaazon> I guess lens would help
11:39:37 <phaazon> but I don’t see what I’m supposed to do
11:40:43 <orion> What web DSL for Haskell is most similar to that of Sinatra's?
11:41:12 <joelteon> hmm...maybe snap
11:42:29 <kludgy> David: You want a breadth-first traversal. If you have that, then you should be able to apply list-like functional equivalents.. take, drop, map, etc.
11:42:56 <kludgy> David: Should give the pieces needed.
11:43:12 <johnw> augur_: sure, although I'm not sure if they have instances already
11:44:16 <kludgy> David: Matter of finding the right hackage or rolling your own
11:44:48 <David> kludgy: is there a way to do it in one pass?
11:45:48 <platz> orion: pretty much states it right on hackage http://hackage.haskell.org/package/scotty
11:45:50 <rwbarton> David: I am still stuck on "etc."
11:47:46 <rwbarton> is it all the things reached by alternating "mainChild" and "children", always ending with "mainChild"?
11:48:32 <David> essentially, I want to get all the mainchilds first
11:49:03 <David> so all the nodes that can be accessed via mainChild $ mainChild $ mainChild [...]
11:49:12 <David> and then all the nodes that have one children in the call
11:49:16 <rwbarton> oh
11:49:21 <David> so mainchild* children mainchild*
11:49:31 <David> and then all the nodes that need two children calls to access them
11:49:33 <David> etc, etc
11:50:08 <d3lxa> how can I enable profiling for a program using cabal? it says "Warning: 'ghc-options: -prof' is not necessary and will lead to problems when used on a library.", it fails to compile, what should I do?
11:50:31 <luite> --enable-library-profiling  or --enable-executable-profiling
11:50:51 <d3lxa> luite: I tried to add them to ghc-options but it says not recognized
11:50:59 <luite> d3lxa: it's a cabal configure option
11:52:05 <d3lxa> luite: alright!
11:52:37 <orion> platz: From hackage: "Conforms to WAI Application interface" <-- how redundantly redundant.
11:54:45 <d3lxa> luite: ok, now I tried to start the freshly installed program and "the flag -p requires the program to be built with -prof", what's wrong?
11:58:16 <rwbarton> d3lxa: possibly you did something wrong? :)
11:58:21 <luite> d3lxa: for executables you need --enable-executable-profiling, cabal should pass the -prof option to GHC automatically, don't add things that might conflict with it to ghc-options
11:59:56 <aasdf> hello, anyone free to answer a quick haskell question
12:00:06 <dmj`> aasdf: yes
12:00:16 <aasdf> why is it so much shittier than Python?
12:00:29 <lf94> lol
12:00:37 <dmj`> aasdf: It's not, in fact I often ask the opposite.
12:00:45 <lf94> aasdf: you mean why can't your understand haskell?
12:00:50 <lf94> your/you
12:01:06 <David> thanks for the help!
12:01:08 <d3lxa> luite: I tried --enable-executable-profiling but it complains I may not have base, whereas library correctly compiled… my ghc-options: -Wall -threaded -rtsopts -auto-all -caf-all -fforce-recomp
12:01:23 <aasdf> strong typing is for pussies
12:02:01 <luite> d3lxa: that looks ok
12:02:28 <bb010g> aasdf: Typeable is an implementation of dynamic typing in Haskell. http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Typeable.html
12:02:42 <aasdf> sry guys I just haven't trolled anywhere in a long time.
12:02:44 <luite> d3lxa: but you still need --enable-executable-profiling, so you'll need to fix the underlying problem first
12:02:56 <aasdf> was feelin' the itch. I'll let you carry on.
12:03:02 <dmj`> aadsf: once you go types, you don't go back.
12:03:16 <d3lxa> dmj`: or later you regret it :D
12:03:43 <luite> aasdf: don't worry, it's ok, most trolls here give up after a while. some of them learn haskell after that
12:03:52 <dmj`> aadsf: bugs are big business though, and can often be lucrative, so I see why people like to keep them around :)
12:04:05 <bb010g> dmj`++
12:04:07 <d3lxa> luite: is this related to compiling all dependencies with the correct flags for profiling?
12:04:37 <luite> d3lxa: yep, although if you're missing profiling libs for base, there's something more wrong with your ghc installation
12:05:05 <d3lxa> luite: why? is profiling enabled by default?
12:05:08 <dmj`> python concurrency vs. haskell concurrency... nuff said
12:05:20 <rwbarton> on debian/ubuntu the distro ghc package doesn't include profiling libraries, they are in a separate package
12:05:52 <d3lxa> rwbarton: I put everything I could into sandbox, I have the bare minimum within my PM
12:06:19 <rwbarton> apparently less than the minimum
12:06:33 <rwbarton> (PM?)
12:06:42 <rwbarton> sorry let me back up
12:06:46 <luite> d3lxa: a default ghc installation (source/binary distribution) comes with them, but development builds (quick) or packages can come without
12:06:48 <rwbarton> what OS are you on and how did you install ghc?
12:07:08 <d3lxa> rwbarton: ok, it's not the bare minimum, but it's small http://sprunge.us/VUbY something wrong?
12:07:46 <luite> yep less than minimum :)
12:07:57 <rwbarton> I don't know what I'm looking at here
12:08:08 <luite> dpkg package list i presume
12:08:14 <rwbarton> probably you want 'ghc-prof' though
12:08:16 <sdeframond> Hi there
12:08:27 <d3lxa> rwbarton: list of intsalled package i=installed A=auto <package name> - <description> (aptitude format)
12:08:41 <sdeframond> Is there a way to derive Eq for GADTs types ?
12:09:01 <SrPx> What is (->)? What is the meaning of "instance Functor ((->) e) where"
12:09:23 <luite> SrPx: functions
12:09:24 <rwbarton> SrPx, (->) e a  is  e -> a
12:09:43 <sdeframond> I just cannot find the right page on haskell wiki...
12:09:55 <sdeframond> must somewhere though >.<
12:09:56 <SrPx> rwbarton: ?
12:09:58 <SrPx> > let a = (->) a (a * a)
12:09:59 <d3lxa> rwbarton: should I install it from cabal or debian?
12:10:00 <lambdabot>  <hint>:1:10: parse error on input ‘->’
12:10:07 <johnw> (->) is the partially applied function arrow at the type level
12:10:14 <rwbarton> d3lxa, debian
12:10:18 <johnw> ((->) e) a would be the same as e -> a
12:10:28 <SrPx> johnw: hmm okay, I see
12:10:30 <johnw> we need to use it because type operators don't support sectioning
12:10:43 <rwbarton> SrPx, you cannot write "let a = a -> (a * a)" either
12:11:04 <johnw> why _don't_ type operators support sectioning, btw?
12:11:10 <johnw> it would be so handy
12:11:42 <rwbarton> sdeframond, try with standalone deriving?
12:12:20 <d3lxa> rwbarton: huh ho… it seems installing ghc-prof broke my entire sandbox (ld cannot find -lH… etc)
12:13:49 <orion> Does the RTS cache the outputs of pure functions?
12:13:54 <sdeframond> rwbarton, Thanks for your help. I must be doing it the wrong way. Can you look at this ? http://lpaste.net/108302
12:14:35 <rwbarton> sdeframond: nope you're not doing anything wrong. it's just impossible to derive Eq for a type like this with an existential
12:14:54 <jcullen> David: did you end up figuring it out?
12:14:56 <rwbarton> well, you aren't using standalone deriving but I'm 99% sure it won't work either
12:15:54 <rwbarton> sdeframond: you cannot really implement Eq at all for this type without special conditions on Shape
12:16:03 <dfeuer> @type foldM
12:16:04 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:17:03 <rwbarton> sdeframond: standalone deriving would look like (as a separate declaration) "deriving instance Eq Object"
12:17:07 <ast__> Anyone using gloss and having 100% cpu usage in display mode?
12:17:12 <rwbarton> d3lxa: can you paste the whole error?
12:17:14 <rwbarton> @where lpaste
12:17:15 <lambdabot> http://lpaste.net/new/haskell
12:17:17 <pjdelport> orion: It's not so much caching; lazy applications turn into thunks, and thunks only get evaluated once, and are shared among all their bindings.
12:17:51 <orion> pjdelport: ah ok
12:17:59 <pjdelport> orion: So if you say "let foo = f x in foo + foo", f x will only be evaluated once.
12:18:41 <pjdelport> (If you say "f x + f x", the compiler *might* turn that into the former, but it's not guaranteed.)
12:19:21 <d3lxa> rwbarton: I just remade my whole sandbox but it's still broken :S http://sprunge.us/YJNK
12:19:34 <sdeframond> rwbarton, thanks, looking at that right now
12:19:41 <joelteon> jle`, I liked your blog post
12:19:54 <NikolajK> is there a list of primitive IO functions one can use?
12:20:13 <joelteon> NikolajK: for what purpose?
12:20:41 <rwbarton> d3lxa: well, you also need to install profiling versions of all your dependencies
12:20:48 <NikolajK> I just want to find the edge of impurity - what are the ways you can interact with what has been coded
12:21:24 <NikolajK> what are the ways of entering input to the code to work with - and so I thought I ask for the primitive ones
12:21:53 <joelteon> NikolajK: as far as I know, IO is used in catching exceptions, input/output, and unsafe FFI bindings
12:22:01 <joelteon> also in threading
12:22:01 <d3lxa> rwbarton: ok, let me remake my sandbox with --with-library-profiling-enabled this time
12:22:08 <joelteon> i think that might be all
12:22:43 <johnw> joelteon: also for managing threads
12:22:50 <johnw> and interacting with the garbage collector
12:22:53 <johnw> and a few other things
12:22:56 <joelteon> right
12:23:15 <joelteon> exceptions, actual "IO", FFI, threading, and GC
12:23:24 <johnw> bitemyapp: ping
12:23:40 <sdeframond> rbwarton: there seem to be an error indeed "Could not deduce (a ~ a1)"
12:24:07 <shachaf> sdeframond: Now you're getting to the "just impossible" part.
12:25:13 <d3lxa> rwbarton: btw, isn't there an other way to profile without profiling libraries? I want to know the profile the program not the dependencies, blackbox mode, isn't that possible?
12:25:19 <rwbarton> no
12:25:24 <sdeframond> rwbarton, sachaf, so, should I do a full instance declaration like "instance Eq Object where" ?
12:25:28 <rwbarton> they have different ABIs
12:25:35 <sdeframond> or should forget about giving Eq to Object ?
12:25:50 <shachaf> sdeframond: Go for it, and see whether you can make it work by hand.
12:25:54 <sdeframond> ok
12:26:34 <rwbarton> programs built for profiling use a different layout for heap objects, etc.
12:26:37 <d3lxa> rwbarton: different ABIs? why not just count before and after entering each library function, in blackbox, doesn't that make sense?
12:26:58 <zq> is there a 'findall' combinator for parsec?
12:27:09 <mmmm_> which does what zq?
12:27:10 <johnw> zq: what would that do?
12:27:39 * hackagebot yesod-comments 0.9.2 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.9.2 (PatrickBrisbin)
12:27:53 <zq> johnw: given a combinator p, find return a list of all occurrences of p?
12:28:13 <johnw> what is an "occurrence of p"?  do you mean the "many" combinator?
12:28:14 <bitemyapp> johnw: hum?
12:28:20 <johnw> bitemyapp: hiya!
12:28:56 <zq> johnw: somewhat like "many (p <|> anyChar)"
12:29:14 <zq> but that doesn't typecheck for arbitrary p
12:29:43 <johnw> what do you want that to return?
12:29:49 <johnw> you could do it with Either
12:29:57 <johnw> many ((Left <$> p) <|> (Right <$> anyChar))
12:30:02 <benzrf> yo johnw
12:30:06 <johnw> benzrf: hi
12:30:13 <benzrf> i implemented leftovers in pipes
12:30:20 <johnw> show!
12:30:24 <benzrf> it was like 40 lines w/ split-line type sigs
12:30:29 <benzrf> probably not production quality
12:30:30 <benzrf> 1 sec
12:30:43 <benzrf> https://gist.github.com/7e9fd6b8a7336929fbf8 <- example
12:30:50 <benzrf> https://gist.github.com/7373445898bd319759c0 <- impl
12:31:02 <benzrf> ^pretty hackish, probably not suitable for actual use
12:31:07 <benzrf> just an exercise in cleverness :p
12:31:18 <benzrf> sup pjdelport
12:31:20 <benzrf> * pyon
12:31:34 <pyon> benzrf: Hi.
12:32:00 <johnw> benzrf: ok, that's not the same as conduit's leftovers, but it is a leftover solution
12:32:13 <benzrf> johnw: well you did not elaborate :p
12:32:16 <johnw> true!
12:32:30 <eacameron> does haste compiler have its own IRC?
12:32:36 <benzrf> anyway, why not just have a segment that grinds the data into appropriately-sized piece
12:32:48 <benzrf> isnt that basically equivalent to leftovers
12:32:49 <johnw> conduit allows injection of an arbitrary number of elements of any type, so actually one consumer could produce *all* of the data that another consumer sees, even if the real producer never produced a single thing
12:32:57 <benzrf> i guess if the leftovers depend on the processing...
12:33:10 <johnw> but I like the limitations of your solution actually
12:33:17 <benzrf> johnw: wait, am i misunderstanding how leftovers work?
12:33:17 <johnw> only one possible leftover, and it must be of the input type
12:33:19 <eacameron> or, does anyone know when haste will support GHC 7.8?
12:33:20 <johnw> there is value in that too
12:33:31 <benzrf> johnw: actually it has a monoid constraint
12:33:32 <johnw> benzrf: your solution is more like an "unget" limited to one element
12:33:35 <benzrf> for the thing
12:33:36 <johnw> ah
12:33:39 <benzrf> read the code
12:33:45 <johnw> I see it now
12:33:51 <benzrf> it just attaches an upstream pipe to the one you give it
12:34:01 <benzrf> and the modified await and so on use upstream communication
12:34:13 <benzrf> hence why it's hacky
12:34:29 <johnw> it's fun implementing stuff just because of an argument on IRC, isn't it
12:34:33 <benzrf> :^)
12:34:41 <benzrf> johnw: so how do leftovers work exactly
12:34:47 <benzrf> when i say 'leftover "foo"', what does that do?
12:34:59 <johnw> benzrf: http://unknownparallel.wordpress.com/2012/07/30/pipes-to-conduits-part-6-leftovers/
12:35:45 <benzrf> i dont have time for reading the implementation
12:35:48 <benzrf> ( ͡° ͜ʖ ͡°)
12:35:59 <johnw> coincidentally, I don't have time to explain the implementation
12:36:04 <benzrf> johnw: so how is the actual usage different from what i implemented?
12:36:12 <johnw> the web is full of examples, I'm busy with other things benzrf
12:36:20 <benzrf> :[
12:36:55 <benzrf> johnw: oh i see what you meant
12:36:56 <benzrf> nvm
12:37:08 <benzrf> eh that probably wouldnt be too hard to implement either
12:37:28 <benzrf> i went with monoids because it seemed apropos to things like parsing, when you want to feed back strings or concat them or something
12:37:55 <d3lxa> rwbarton: after getting out of cabal dependency hell, "yesod: yesod: on the commandline: You can't use Template Haskell with a profiled compiler" too bad :(
12:37:57 <johnw> you could do something sexy with Data.Seq
12:38:01 <benzrf> but i could use a list instead of maybe as the accumulator, in which case it'd be like what you said
12:38:05 <benzrf> or yeah data.seq
12:38:23 <johnw> that would allow the producer to keep add at the left, and the consumer to add at the right
12:39:34 <d3lxa> rwbarton: thanks anyway
12:39:42 <benzrf> i do kinda feel like adding leftovers to the core type is kind of like having fail in the Monad class
12:40:00 <johnw> you're not alone in that opinion, for certain
12:40:35 <sdeframond> rwbarton: doesn't work either. Seems like I will have to find another way... bummer.
12:40:41 <sdeframond> Thanks anyway!
12:41:39 <benzrf> johnw: hmmmmm
12:41:43 <benzrf> i just had a horribly evil idea
12:41:56 <johnw> implement a new streaming library based solely on leftovers?
12:42:00 <benzrf> lol no
12:42:13 <benzrf> i wonder if you could write something where a pipe can indicate to rewind one it's connected to
12:42:15 <kstt> System.IO.Temp withSystemTempFile leads to runtime crashes on windows XP. Known bug ?
12:42:49 <benzrf> obviously a terrible idea given that you can have arbitrary effects layered into a pipe
12:42:56 <kstt> It produces paths like C:\Document~/..
12:43:09 <benzrf> kstt: why are you using xp?
12:43:13 <benzrf> it's officially deprecated
12:43:19 <kstt> benzrf: I'm officially deprecated
12:43:20 <benzrf> and has been for a decent while
12:43:28 <seydar> k, `cabal install cabal-install` on my mac os 10.9 is killing me: http://lpaste.net/108303 LOOK AT HOW I HAVE NO COMPILE ERRORS and yet, at the end it all fails
12:44:06 <kstt> benzrf: my customers wants a WinXP32 binary.
12:44:20 <kstt> Don't know if I can build one from Windows 7, though
12:44:24 <benzrf> kstt: your customers are awful
12:44:34 <kstt> I live in France
12:44:34 <benzrf> 32 bit, even?!
12:44:45 <benzrf> are they time travellers from 2003?
12:45:18 <heudebeu> win xp 64 bit is even more terrible then the 32 bit version
12:46:00 <kstt> That said, GHC crashes on my Windows 7 machine.
12:46:09 <kstt> Both GHC 7.6.3 and 7.8.3
12:46:28 <kstt> https://github.com/timbod7/haskell-chart/issues/39
12:46:54 <kstt> So I'm happy it works on WinXP, after all ...
12:47:07 <mzero> seydar: actually, the compile of Cabal (the lib) worked and installed… but cabal-install didn’t even configure
12:47:57 <mzero> because of a problem with HTTP library
12:48:22 <seydar> mzero: how do i kill the http
12:48:56 <mzero> well - I don’t know what the actual problem is — notice the line   use -v for more information
12:49:11 <mzero> so perhaps run    “cabal install -v cabal-install” and lpaste that so we can see what is the matter
12:49:38 <mzero> you could also   do   ghc-pkg list     and    ghc-pkg info HTTP    and put those in the lpaste too
12:50:20 <mzero> lastly - I’m guessing you have an old cabal installed ….     cabal —version    will tell us
12:51:15 <seydar> mzero: http://lpaste.net/108304, cabal --version: 1.8.0.4
12:52:41 * hackagebot data-variant 0.26.0.0 - A variant data type, useful for modeling dynamically-typed programming languages  http://hackage.haskell.org/package/data-variant-0.26.0.0 (TobiasDammers)
12:52:43 * hackagebot hpaco-lib 0.26.0.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.26.0.0 (TobiasDammers)
12:52:45 * hackagebot hpaco 0.26.0.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.26.0.0 (TobiasDammers)
12:52:53 <mzero> 1.8.0.4? that is the Cabal lib.. not cabal install itself — but in any case, that is from 2010 - very old
12:53:28 <seydar> dammit, i totally thought i had reinstalled cabal completely. why do i suck
12:53:52 <mzero> seydar: you are on Mac
12:54:02 <rwbarton> d3lxa: wait, a profiled compiler?
12:54:02 <seydar> mzero: yes, 10.9
12:54:10 <mzero> perhaps you did, but the cabal you built before is perhaps not in your path?
12:54:17 <mzero> because the cabal you are running is very old
12:54:35 <mzero> (how did you get 7.6.3? via bindist? platform?)
12:54:41 <seydar> i'll have you know that i am over 4 years old and i run just fine. in fact i run better now than when i was just born
12:54:48 <rwbarton> d3lxa: how did you get one of those?
12:54:53 <seydar> mzero: haskell platform
12:55:24 <mzero> hmmm…   which cabal    — run that — it should be /usr/bin/cabal   — which in turn should be a symlink into   /Library/Haskell/bin
12:55:37 <rylev> Hey all! I'm on Mac OSX and having a hard to parsing tab characters with Parsec. I'm using the tab parse provided in Text.ParserCombinators.Parsec.Char but it's not parsing ^I characters. Anyone have any experience with this?
12:56:20 <rylev> cat -vet shows my sample text does have ^I characters in it
12:56:37 <mzero> rylev: that shouldn’t be an OS specific problem
12:56:46 <monochrom> seydar: explain to me how to run like I'm 5-year-old :)
12:56:55 <mzero> the source of tab is pretty terse:     tab = char '\t' <?> "tab"
12:57:49 <benzrf> :t (<?>)
12:57:50 <lambdabot>     Not in scope: ‘<?>’
12:57:50 <lambdabot>     Perhaps you meant one of these:
12:57:50 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
12:57:52 <benzrf> meh
12:58:02 <mzero> benzrf: it labels parse errors nicely
12:58:28 <rylev> mzero: yea. I still get parse errors even if I use char '\t'
12:58:30 <benzrf> oh
12:59:11 <latk> Does anyone know if wreq automatically does url encoding with functions like get ?
12:59:28 <mzero> rylev: right - so, I’m pretty sure that tab itself is right — my guess is that the error is elsewhere in your parser than that — unless you are running in some strage Locale set up, it is hard to imagine that not matching a tab
12:59:44 <rylev> mzero: I think I found it. I was excluding whitespace characters elsewhere in my parser. Derp.
12:59:52 <mzero> tada
12:59:52 <rylev> Apologize for bothering you
12:59:55 <mzero> no problemo
13:00:15 <seydar> mzero: you're right, i was using a cabal that was elsewhere in my path. i thought i had cleaned up everything, but alas i had not
13:00:41 <d3lxa> rwbarton: no idea :S
13:01:29 <sdeframond> Is there a way to have polymorphic lists (like [Wrapper 'a', Wrapper 1]) and to be able to check its elements for equality ?
13:02:55 <benzrf> sdeframond: probably not
13:02:58 <sdeframond> (or is it a bad idea for some reason ?)
13:02:59 <benzrf> at least
13:03:03 <benzrf> not without terrible hacks
13:03:17 <benzrf> sdeframond: oh wait, i thought you meant actually heterogenous
13:03:21 <benzrf> *heterogeneous
13:03:34 <sdeframond> benzrf, I think I do mean heterogeneous
13:03:35 <benzrf> sdeframond: if you have a predefined sum type to wrap the items, thats entirely feasible
13:03:50 <benzrf> sdeframond: 'actually heterogenous' as in [1, "foo", []]
13:03:53 <benzrf> sdeframond: vs,
13:04:11 <benzrf> data Wrapper = N Int | S String | L [Int]
13:04:18 <benzrf> [N 1, S "foo", L []]
13:04:31 <benzrf> former is tricky, not very useful, and generally a bad idea
13:04:38 <sdeframond> benzrf, yes, like that!
13:04:40 <benzrf> latter is perfectly fine in many circumstances
13:04:48 <benzrf> sdeframond: like the former?
13:05:47 <sdeframond> benzrf: ok, I thought it was mandatory to specify the wrapped type: data Wrapper a = N Int | S String | L [Int]
13:06:38 <benzrf> you cant just do the former
13:06:55 <benzrf> you have to enable certain extensions and use a wrapper with some kind of constraint
13:07:00 <benzrf> and even then it's not very useful
13:07:08 <benzrf> @quote raft
13:07:09 <lambdabot> johnw says: Haskell is like using a finely crafted blade to whittle yourself a canoe, as your friends pass by on their cruise liner and wonder what you're up to
13:07:10 <benzrf> hmm
13:07:24 * benzrf pms lambdabot to find the quote
13:07:45 <seydar> mzero: so close and yet so far: http://lpaste.net/108306
13:10:43 <seydar> cabal v. 1.16
13:13:49 <latk> When I try the following code: http://lpaste.net/108307 I get this exception: http://lpaste.net/108308 . This appears to be because of the squared brackets. Are square brackets not allowed in a url ? Or do I have to percentage encode them ?
13:14:37 <simcity2000> latk: what package is this?
13:15:05 <latk> simcity2000: Ah, sorry. Network.Wreq
13:15:30 <Pythonfant> latk: http://en.wikipedia.org/wiki/Percent-encoding the brackets are here so I guess you need to encode them
13:15:51 <simcity2000> latk: gotcha. in any case, I think square brackets generally fall under the category of things you should probably encode
13:16:01 <latk> Cool, thanks!
13:16:28 <bergmark> latk: http://hackage.haskell.org/package/uri-encode-1.5.0.2/docs/src/Network-URI-Encode.html#isAllowed
13:17:38 <latk> bergmark: Aha. Ok, cool.
13:25:43 <marchelzo_> is there a way to use a case inside of the IO monad using do notation? Like do { let maybeString = getMaybeString :: Maybe String; case maybeString of (Just s) -> putStrLn s; Nothing -> putStrLn "Error"; } ?
13:27:43 <mmmm_> marchelzo_: Have you tried it?
13:27:53 <marchelzo_> mmmm_, yes
13:28:30 <mmmm_> and what happened
13:28:52 <arancia> You need extra braces, I think
13:29:02 <arancia> case e of { ... }
13:29:04 <mmmm_> it should work
13:29:52 <marchelzo_> oh. I had something like "... else let ... = ...; case ... of ...". I should have had a "do" after the "else"
13:30:05 <marchelzo_> my mistake
13:37:47 * hackagebot hlint 1.9.3 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.3 (NeilMitchell)
13:41:52 <begriffs> I'd like to use (=~) and am wondering which regex library to choose. Is this one good are are there better ones? http://hackage.haskell.org/package/regex-posix-0.93.1/docs/Text-Regex-Posix.html
13:44:17 <mkster_> let y (x:xs) = x in "abc"
13:44:29 <mkster_> Why does this not return 'a'?
13:45:02 <glguy> did you mean ... in y "abc"
13:45:23 <mkster_> let y (x:xs) = x in y "abc"
13:45:45 <mkster_> I guess so works without y for me though
13:46:00 <vanila> > let y (x:xs) = x in y "abc"
13:46:02 <lambdabot>  'a'
13:46:13 <mkster_> Huh
13:46:28 <vanila> it's parsed liek this let { y (x:xs) = x } in (y "abc")
13:46:29 <glguy> If you forget the 'y' then you're just returning the value "abc"
13:46:41 <mkster_> Oh ok thanks
13:49:07 <notdan> hm what's a prefered way to write parsers in haskell nowadays?
13:49:14 <notdan> attoparsec? trifecta?
13:49:35 <mmmm_> why not parsec?
13:49:46 <mmmm_> It depends what you want to do
13:50:15 <notdan> Well I forgot a lot of stuff about parsers
13:50:23 <notdan> I want decent error reporting
13:50:25 <lf94> /usr/bin/ld: cannot find -lHStransformers-compat-0.3.3.4-ghc7.8.3
13:50:25 <lf94>  <- how can I fix this?
13:50:37 <hpc> there's also alex/happy if you like your programming with a side of LSD ;)
13:53:13 <Exio> because i was lazy i ended using bnfc
13:53:24 <Exio> and went to easier way
13:53:53 <notdan> Exio: is it much easier?
13:55:14 <Exio> you write a "labelled" BNF and then you get a parser
14:00:26 <kludgy> David: I'm not sure whether there's a way to do it in one pass, I can only suspect as I haven't done any work to figure it out. I just know where I'd start: with list-like traversals in a well-defined order. :) Very good question about different algorithmic approaches maybe others might have more experience with?
14:02:50 * hackagebot filestore 0.6.0.3 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.3 (JohnMacFarlane)
14:04:55 <frerich_> Is NixOS a particularly popular Linux flavor for Haskellers? I suppose the “purely functional package management” approach is kind of attractive to Haskell fans but it’s still noteworthy that in many cases (e.g. http://hackage.haskell.org/package/filestore-0.6.0.3 ) the package version for NixOS is the most recent.
14:06:33 <quchen> I think a couple of people here use Nix with other distros, some of them with NixOS.
14:06:35 <johnw> frerich_: it is a fantastic choice, that's for sure
14:06:40 <levi> frerich_: There is some overlap between Haskellers and NixOS users. I don't know about relative popularity.
14:06:41 <solidus-river> how does one upload their application to hackage and is there any criteria for what should or should not be uplaoded there?
14:06:44 <johnw> I use Nix with Mac OS X and it does wonders for my Haskell development
14:07:02 <johnw> solidus-river: you get a Hackage account, and then use "cabal sdist" and "cabal upload <FILE>"
14:07:08 <johnw> after setting your user and pass in ~/.cabal/config
14:07:27 <c_wraith> I upload from the web site.  But either way, it's the same basic thing
14:07:35 <frerich_> johnw: Interesting, I didn’t even know you could run Nix on non-Linux… let me google for that...
14:08:04 <johnw> frerich_: Nix runs very nicely in parallel with anything Linux-based, because it is its own hermetically sealed ecosystem
14:08:35 <frerich_> johnw: That sounds more attractive than Homebrew, where the first step is to chmod /usr/local to 0777 or something :-}
14:08:55 <johnw> sure, I used to use Homebrew, now I'm 100% Nix
14:09:02 <frerich_> Granted - I never hda any problems with Homebrew so far, but the ‘all or nothing’ mentality is kinda worrying.
14:09:23 <dfeuer> Following my interrupted discussion with johnw, I decided to figure out what a right monadic fold would be, and eventually determined that, perhaps unsurprisingly, foldrM f q xs = foldM (flip f) (reverse xs). I could also see why foldrM would be useless for something like IO. What I couldn't figure out is whether foldrM would ever be useful for some other, lazier, monad.
14:10:23 <johnw> pretty much no, due to the way monads work
14:10:34 <johnw> for an applicative foldA, yes, it could matter
14:12:28 <solidus-river> will someone get really angry at me if i upload personal projects to hackage or should i keep those to github and only uplaod things that might benefit others to hackage
14:12:51 <joelteon> solidus-river, I'd stick with packages that other people might find helpful
14:12:56 <hpc> it depends on the quality, really
14:13:06 <johnw> for a partially ordered set, what do you call the subset for which every element in the subset is either unrelated to, or <=, every other element in the poset?
14:13:06 <joelteon> err on the side of caution
14:13:09 <hpc> i don't think anyone will be angry, but it might be removed
14:13:11 <joelteon> people already get annoyed about the Acme category :)
14:13:19 <hpc> joelteon: that's ridiculous
14:13:33 <hpc> Acme has a long proud perl tradition
14:13:48 <eacameron> I've been using a construct that I rather like, but I imagine that I can't be the first to use it. I define a "Defaultable" typeclass with an (|>) operator that basically just provides some sort of last-ditch default. With Maybe and Alternative, you can write things like `a <|> b <|> c |> myDefault`. Since you've provided a default, there's no need for "fromJust" or anything. Of course, other types have sensible instances too. Am I a
14:13:51 <johnw> ah, I think it's the downward closed subset
14:14:16 <quchen> eacameron: There's the "Default" typeclass, yes.
14:15:06 <eacameron> quchen: where is that defined? I asked SO on this a while ago and noone seemed to know about anything
14:15:10 <quchen> > (def, def, def) :: (Int, Maybe (Double -> Integer), String)
14:15:12 <lambdabot>  (0,Nothing,"")
14:15:18 <quchen> Data.Default I think
14:15:37 <eacameron> oh, but that provides a default for the whole type, right?
14:15:48 <eacameron> mine allows you to define a default per usage
14:15:50 <dfeuer> johnw: that seems reasonable, but I wish I had a better understanding of just why that is in general, as opposed to just for monads that look like IO.
14:16:23 <quchen> eacameron: Yes, it's per type.
14:16:52 <johnw> dfeuer: because given m >>= f, m must always be "executed" first in order to call f
14:16:55 <quchen> `<|> pure x` should be your per-site-defaulting thing.
14:17:17 <johnw> but with f <*> x, you may "execute" either f or x first before calling (f' x')
14:17:56 <eacameron> quchen: Yeah that is not too bad, except now you have to extract your value out of the wrapper. there's no need to do that in many cases since you know there will be a value
14:18:20 <notdan> Exio: sounds easy enough, wonder how hard will it be to plug my existing types in
14:18:39 <eacameron> quchen: you need something redundant like fromJust $ a <|> b <|> Just 5
14:19:32 <dfeuer> johnw: I still don't quite get that, but I'm going to put it on the back burner until I understand effectful streams.
14:19:37 <johnw> sure
14:19:45 <johnw> it's a subtle point
14:19:54 <johnw> it's also part of the beauty of applicatives
14:20:28 <Exio> notdan, it is quite easy, and i don't think it'll be that hard, if you're using recursive datatypes, that is... ;P
14:25:26 <_sebastian_> @hayoo test
14:25:27 <lambdabot> Unknown command, try @list
14:26:01 <_sebastian_> hm. looks like lambdabot needs a new command
14:26:41 <quchen> eacameron: In that case I don't know a solution. Just extracting values isn't really all that common, and what you would need is something like `x |> d = extract (x <|> pure d)`.
14:27:40 <quchen> And since you cannot safely extract data from many types this "extract" class would be quite limiting.
14:29:37 <eacameron> quchen: I'm not terrifically experienced in haskell, so I'm not sure what's "common" or not. Perhaps theres' a better way. I just find that I don't to "dive into" a particlar monad (usually Maybe) by using fmap all the time and sometimes I want to "extract" the value out into current monad (IO or something)
14:29:52 <eacameron> *don't want to
14:31:02 <quchen> Extracting values is usually done using pattern matching; some common type have deconstructor functions like `maybe` and `either`.
14:31:39 <eacameron> right, I guess the point of |> is just to provide a common interface to those two at least
14:31:58 <quchen> Monads in particular allow you to get to "m a" from nothing and from arbitrary nestings; there is no way out in general. Comonads are similar, but they allow you to get away from "w a" easily and no general way in exists.
14:32:52 <eacameron> interesting! I've never worked with Comonads explicitly.
14:32:57 <quchen> All types that are both monads and comonads I know are useless for your purpose (namely Identity).
14:33:26 <quchen> Hm I guess non-empty lists are also instances of both.
14:33:51 <quchen> But there certainly isn't something that lets you extract a value from a `Maybe a`, which is what you were asking for.
14:34:02 <johnw> NonEmpty lists should be both monads and comonads
14:34:04 <quchen> A typeclass just unifies possible things, it does not create impossible new functions.
14:34:33 <eacameron> well not really extract by itself but with a default
14:38:18 <bitemyapp> johnw: gonna patch semigroups then?
14:38:35 <bitemyapp> johnw: or do you mean you believe the instances should be in the library?
14:39:05 <johnw> bitemyapp: the instance is here: http://hackage.haskell.org/package/comonad-4.2.2/docs/Control-Comonad.html
14:39:05 <NikolajK> what did Idris give up to have dependent types?
14:39:23 <johnw> NikolajK: first born child
14:39:50 <NikolajK> what would that be
14:40:09 <quchen> Decidable type inference
14:40:16 <NikolajK> thought so
14:40:20 <johnw> yeah, you have to be explicit about a lot more stuff
14:40:24 <quchen> Which Haskell has, for the most part
14:40:28 <jfischoff> NikolajK: I’m going to guess. Some type inference (top level at least), performance from erasure
14:40:37 <johnw> although, Idris is good at making a lot of things truly implicit, moreso than Agda
14:40:45 <NikolajK> and it's proven that you can't get inference back?
14:40:47 <johnw> (i.e., you don't have to state them at all)
14:40:59 <bitemyapp> johnw: the overloading still makes me uncomfortable.
14:41:02 <johnw> you get some inference, just not as much
14:41:19 <NikolajK> why the name
14:41:21 <NikolajK> Idris
14:41:33 <bitemyapp> NikolajK: it's named after a dragon.
14:41:34 <quchen> It's a dragon from a British children's TV show.
14:41:57 <quchen> I guess they ran out of famous 19th century logician names for the new language ;-)
14:42:38 <quchen> NikolajK: Termination is undecidable in general, and when types can depend on values that kills decidable inference quite directly.
14:43:00 <phaazon> hey
14:43:04 <etandel> hammer time
14:43:07 <phaazon> I just did that for fun:
14:43:10 <phaazon> http://lpaste.net/raw/108316
14:43:12 <etandel> oh, not that's "stop"
14:43:14 <phaazon> does this look correct?
14:43:25 <phaazon> the fac is implemented very naively
14:43:41 <quchen> It certainly doesn't look incorrect.
14:43:44 <phaazon> fac :: Integer -> Integer; fac n | n == 1 = 1 | otherwise = n * fac (n-1)
14:43:46 <johnw> does Idris detect when dependent types are not involved, in order to get some of the inference magic back?
14:43:48 <quchen> It has a lot of zeros at the end, which is reassuring.
14:43:57 <johnw> I know it does that when you use "mutual"
14:44:08 <johnw> (i.e., ensure that dependent types are not involved)
14:44:19 <quchen> johnw: Yes I think there are different ways of exporting values, and only some can be used in dependent types if I recall correctly
14:44:37 <NikolajK> it's correct
14:44:52 <NikolajK> 10000! - 28462596809170545189064132121… in Mathematica :D
14:45:01 <bitemyapp> johnw: there's only extreme limited, local type-inference
14:45:08 <bitemyapp> johnw: it's, AFAICT, worse than Scala in that respect.
14:45:15 <bitemyapp> johnw: but the type system is saner, so it makes up for that.
14:45:31 <bitemyapp> johnw: you can leave type assignments off where clauses if the function makes it immediately obvious what's going on
14:45:37 <bitemyapp> ie, it's picking up freebies, little else.
14:45:38 <quchen> Since types are much more part of your program than in Haskell omitting types in Idris is a bit like omitting code in Haskell though
14:45:48 <phaazon> quchen: thank you
14:46:01 <phaazon> I friend just told me “Yeah, computing 10000! would take seconds”
14:46:06 <orion> I really want to write a library or program or something in Haskell, but I'm fresh out of ideas. What is Hackage lacking?
14:46:11 <phaazon> my naive fac is immediate
14:46:12 <bitemyapp> orion: talk to me.
14:46:16 <phaazon> :P
14:46:20 <bitemyapp> orion: do you want to write boring infrastructure stuff?
14:46:24 <bitemyapp> orion: libraries people need for work?
14:46:34 <quchen> phaazon: The bottleneck is usually the printing.
14:46:50 <phaazon> so haskell has nice IO prints?
14:46:59 <dfeuer> Why do dependent type systems lose erasure?
14:47:01 <quchen> For small-ish factorial arguments at least.
14:47:31 <quchen> dfeuer: Types aren't all known at compile time, some of them can only be found out about at runtime
14:48:24 <quchen> Edwin talked a little about the evaluation model of Idris (and how dependent types make it different) in #idris a couple of weeks ago, but I don't think the channel is logged :-(
14:48:32 <NikolajK> what's the most popular language with identity types? :)
14:48:37 <arianvp> Hey guys
14:49:14 <arianvp> I'm trying to write a library that both runs on Haste and GHC.   "haste-inst install --only-dependencies" works but "cabal install --only-dependencies" fails and I have no idea why
14:49:44 <arianvp> cabal file: http://lpaste.net/4075025650019205120
14:49:48 <arianvp> anyone got a clue?
14:50:13 <arianvp> oh and the error: http://lpaste.net/1654749263042707456
14:50:25 <lf94> /usr/bin/ld: cannot find -lHStransformers-compat-0.3.3.4-ghc7.8.3 <- how can I fix this guys
14:51:10 <orion> bitemyapp: I want to write something that people will use.
14:51:11 <jfischoff> arianvp : “Dependency tree exhaustively searched” cabal can’t find a package with that name and versino
14:51:22 <bitemyapp> orion: well Haskell might not be the best choice then!
14:51:32 <bitemyapp> orion: but anything web apps need is usually a good guess for that.
14:51:46 <bitemyapp> orion: I do know (not for me, for others) updating and finishing tcrayford's Kafka client would be appreciated.
14:51:48 <felixn> lf94: dunno if it helps but shot in the dark, I always pop on "-no-user-package-db -package-db .cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d" for sandboxes
14:51:51 <arianvp> jfischoff: but it's in hackage ..
14:51:57 <bitemyapp> orion: we're going to expand support for DynamoDB soon as well.
14:51:58 <orion> Every piece of code I've ever written since I was a kid went in to the trash because it was useless *except* for helping me learn.
14:52:06 <arianvp> WAIT NVM. IT's not in hackage haha
14:52:08 <lf94> felixn: thanks, I'll give that a go
14:52:17 <arianvp> that explains :)
14:52:20 <jfischoff> arianvp: :)
14:52:21 <bitemyapp> orion: hum. I wouldn't worry about it too much.
14:52:30 <bitemyapp> orion: learn about Kafka and messaging infrastructure. See if it interests you.
14:52:38 <bitemyapp> orion: if it does, get in touch.
14:52:39 <felixn> lf94: your exact path will differ ... on whatever platform you're on
14:52:53 <orion> bitemyapp: Is it similar in any way to ZMQ?
14:52:54 <jfischoff> orion: wrap an awesome c or c++ library
14:53:00 <NikolajK> so the guy doing Idris also did whitespace...
14:53:00 <lf94> cabal: unrecognized option `-no-user-package-db'
14:53:09 <orion> jfischoff: boost. :p
14:53:12 <bitemyapp> orion: it's a bit off to the side.
14:53:17 <lf94> felixn: I'm trying to install something from hackage with a different ghc version
14:53:18 <bitemyapp> orion: so I'm going to say "no"
14:53:24 <bitemyapp> orion: different layers of abstraction, different purpose.
14:53:35 <lf94> I installed the new ghc in the /usr/local/bin directory, but how do I tell cabal to use that
14:53:39 <bitemyapp> orion: zeromq is an embedded thing. Kafka is a service.
14:53:48 <arianvp> Oh I wish cabal would be more like Nix
14:53:59 <arianvp> sandboxes work I guess... but it's not an elegant solution
14:54:15 <bitemyapp> sandboxes work. People are exploring stealing from Nix as we speak.
14:54:26 <arianvp> awesome
14:54:44 <monochrom> lf94: there is --with-compiler=PATH. have you read "cabal install --help" lately?
14:55:04 <tolt> bitemyapp: Do you know how much is completed with haskakafa
14:55:05 <lf94> No, I haven't, but I have tried cabal --help with no luck lol
14:55:07 <lf94> Thanks :)
14:55:10 <felixn> orion: honestly I think the best thing you could do is use haskell in production, and be the guy that fixes things that are broken ... and write blogs to show people the way!
14:55:37 <bitemyapp> tolt: https://github.com/tcrayford/hafka I dunno, let me know
14:57:01 <felixn> orion: right now haskell needs help with sandboxes ... that would greatly affect me, and many people :) http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
14:57:25 <arianvp> hmmm
14:57:32 <jfischoff> orion: template heavy c++ is difficult to wrap
14:57:43 <rjq5490>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <mwj7065>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <oqy1691>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <qaj5290>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <ntc3899>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <kro1469>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <aco9138>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:43 <tjc3362>  HELLO MOTHER-F-UCKERS DO YOUR MOTHERS SUCK C0CK FOR FREE?
14:57:58 <arianvp> buts!
14:58:01 <arianvp> bots*
14:58:03 <arianvp> :D
14:58:36 <eevar> speaking of messaging, gnatsd looks good latency wise: http://www.bravenewgeek.com/dissecting-message-queues/
14:58:37 <MitchellSalad> those bots got us guys
14:58:42 <arianvp> so I have a flag in my cabal file...  "ghc-options:--with-js=./lib/bundle.js" that only needs to be called when using the haste-compiler instead of the ghc-compiler
14:58:45 <arianvp> is that possible? :P
14:59:06 <felixn> orion: read "What are sandboxes and why are they needed?
14:59:22 <felixn> it explains why cabal sucks right now
15:01:07 <hjulle> Why are people using the ((->) a) Applicative/Monad instance for anything else then obfuscating code?
15:01:30 <monochrom> I don't understand the question.
15:01:53 <felixn> hjulle: because it looks like a type signature?
15:02:07 <bitemyapp> hjulle: one day, you are going to want a particular type for something
15:02:27 <bitemyapp> hjulle: and you're going to realize it's an instance for monoid/functor/applicative/alternative/validation/monad/comonad/monadplus/semigroup/magma
15:02:42 <sipa> what's validation?
15:02:45 <bitemyapp> hjulle: and then you'll realize reification of the algebras into things we can refer to by name makes a ton of sense
15:02:49 <bitemyapp> sipa: one-off alternative
15:02:57 <bitemyapp> hjulle: and that we might as well steal from mathematicians
15:03:06 <hjulle> All code I've seen that uses that instance has been obfuscated (on purpose or not)
15:03:27 <glguy> I believe that hjulle is objecting to people striving for pointless code via the Applicative/Monad instance of ((->)r)
15:03:31 <monochrom> is there an objective definition for "obfuscation"?
15:03:32 <hjulle> It just makes the code harder to read in my opinion.
15:03:32 <glguy> Not objecting to people using Applicative
15:03:43 <bitemyapp> hjulle: you're objecting to Reader?
15:03:50 <jfischoff> hjulle: Where are you seeing people use it that way
15:04:18 <felixn> hjulle: can you post a gist of some example code?  I'm not following :(
15:04:26 <hjulle> http://stackoverflow.com/questions/12659951/how-does-this-piece-of-obfuscated-haskell-code-work?rq=1
15:04:50 <jfischoff> haha
15:05:07 <jfischoff> that is awesome
15:05:17 <monochrom> that is clearly recreational code, not production code
15:05:24 <hjulle> stackoverflow.com/questions/24985757/list-of-all-collatz-sequences-from-1-to-n/24998309#answer-24998309#24998309
15:05:33 <jfischoff> the fix is like the icing on the cake
15:05:52 <rwbarton> @unpl fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
15:05:53 <lambdabot> (fix ((((<$>) <$> ((:))) <*> ((((\ j k -> k >>= j) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2)) 1))
15:05:58 <rwbarton> @pl fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
15:05:59 <lambdabot> fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
15:06:01 <rwbarton> aw
15:06:17 <benmachine> you really need type information to make any sense of that
15:06:24 <joshc> man, that unencyclopedia article is hilarious :)
15:06:25 <lf94> felixn: it failed
15:06:35 <lf94> monochrom: failed
15:06:51 <felixn> lf94: I dunno >_<  I'm not a ghc pro either unfortunately ... maybe post a gist.github.com and someone else can help
15:06:53 <hjulle> Is there any way to get the type signature of all parts of an expression?
15:07:06 <lf94> I'm literally just doing cabal install distributive
15:07:22 <monochrom> map ((:) <*> next) [1..] is not obfuscation to some reasonable, learned people
15:07:37 <monochrom> this is why I asked <monochrom> is there an objective definition for "obfuscation"?
15:07:45 <MitchellSalad> you asked yourself?
15:07:54 <MitchellSalad> ho ho
15:08:32 <hjulle> monochrom: Do you instantly reallize what it means?
15:08:38 <monochrom> no
15:08:43 <none> wow
15:08:46 <lf94> https://gist.github.com/lf94/a6a923abc9c1a938e091 failing to make distributive someone please for haskell's sake help me
15:08:59 <monochrom> but why should I matter?
15:09:02 <none> i went here just for curiosity
15:09:16 <rwbarton> lf94: try 'ghc-pkg check'
15:09:46 <athan> Are algebraic structures sane superclasses of each other in 7.10? I know applicative will be a superclass of monad, but what about semigroups and monoids? Groups and rings
15:09:49 <athan> ?*
15:09:50 <lambdabot> Maybe you meant: v @ ? .
15:09:51 <none> i've never heard one talking about haskell
15:10:09 <quchen> hjulle: The function Applicative/Monad should be used sparingly, but sometimes the instances can be useful.
15:10:13 <hjulle> monochrom: My point is that it makes the code harder to read.
15:10:22 <none> can anyone give me an example? i mean, a good software written in haskell
15:10:29 <levi> none: What sort of "talking about haskell" were you expecting to hear?
15:10:31 <jfischoff> lf94: something is screwing in your setup. What does ghc-pkg check reveal?
15:10:35 <monochrom> I do not, for example, immediately realize what 99% of production python code means. do you deduce that 99% of production python code obfuscation?
15:10:51 <levi> none: xmonad is a pretty nice X window manager.
15:10:58 <monochrom> everything you haven't learned is hard to read. how does that define obfuscation?
15:11:11 <monochrom> Japanese is also hard to read
15:11:13 <lf94> rwbarton, jfischoff: https://gist.github.com/lf94/a6a923abc9c1a938e091 edited gist, results at bottom
15:11:15 <levi> none: I use pandoc all the time for lightweight markup conversion.
15:11:38 <hjulle> monochrom: Ok, that was an exaggeration. But I still think it makes it more diffucult to understand.
15:11:42 <rwbarton> uh
15:11:43 <monochrom> so, is there an objective definition for obfuscation?
15:11:47 <none> levi let me see, brb
15:11:53 <hjulle> quchen: When is it useful?
15:11:57 <rwbarton> oh ok
15:12:40 <quchen> > (zip`ap`tail) [1..] -- the canonical example
15:12:42 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
15:13:10 <hjulle> monochrom: There is for deliberate obfuscation at least. Forget what I said about unintentional obfuscation.
15:13:48 <none> it's pretty similar to *box family, isn't it?
15:13:52 <rwbarton> lf94: are you sure /usr/local/bin/ghc-pkg matches up with /usr/local/bin/ghc?
15:14:01 <none> levi /\
15:14:05 <rwbarton> lf94: didn't you say you did some manual installation involving symlinks?
15:14:05 <felixn> hjulle: I completely agree with you, I think haskell could be better in this regard, check this out: https://gist.github.com/munro/2fe9b017f5b12ad7fc12
15:14:12 <lf94> I didn't do any symlink stuff
15:14:18 <lf94> I simple did make install as root
15:14:20 <lf94> simply*
15:14:22 <felixn> hjulle: unfortonately things start to break down with type class instances start overlapping in haskell
15:14:48 <lf94> rwbarton: you mean are they in the same directory or is ghc-pkg referencing /usr/local/bin/ghc?
15:14:55 <levi> none: xmonad is a tiling window manager, yes.
15:15:00 <rwbarton> I just want to make sure they are for the same version of ghc
15:15:03 <rwbarton> using the same package directories etc.
15:15:32 <levi> none: Though there are a *lot* of extension libraries that allow it to act in other ways as well.
15:15:35 <rwbarton> what does 'ghc-pkg describe transformers-compat-0.3.3.4' say?
15:15:48 <rwbarton> sorry, /usr/local/bin/ghc-pkg, if you have another version installed also
15:16:53 <hjulle> felixn: I didn't get what your point was with the gist?
15:17:31 <felixn> hjulle: it looks less obfuscated since you can apply (+) to monads directly
15:17:49 <hjulle> yes, that is true.
15:18:20 <none> levi do you write code in haskell?
15:18:27 <felixn> hjulle: honestly <*> and <$> look like code bugers to me, if type classes were more powerful you could just use the computation directly on monads
15:18:30 <bb010g> felixn: The thing is, your meaning changes. (+) no longer is only on Nums, but Nums in things. The liftA2 makes that explicit.
15:18:37 <rwbarton> lf94: specifically there should be a line "library-dirs: ..."
15:18:48 <lf94> rwbarton: updated gist
15:19:05 <lf94> it's looking in ~/.cabal/lib/
15:19:22 <hiptobecubic> What a great article: "The innovative Go Notation is syntactic sugar for the highly sophisticated mathematical construct of Gonads which are used for J/O (Haskell's alternative to I/O). Gonadic J/O is practiced by very few and understood by still fewer; the Haskell expert will be adept in their handling of Gonads."
15:19:25 <rwbarton> oh
15:19:32 <bb010g> felixn: That should really be ``instance (Applicative f, Num a) => Num (f a) where { (+) = liftA2 (+); ... }
15:19:42 <rwbarton> lf94: what version of cabal do you have?
15:19:43 <levi> none: I do, on occasion. It's a hobby, though, so I don't do it all the time.
15:19:54 <felixn> bb010g: ah nice
15:19:59 <lf94> cabal-install version 0.14.0
15:19:59 <lf94> using version 1.14.0 of the Cabal library
15:20:04 <rwbarton> ah that's too old
15:20:09 <lf94> fff
15:20:10 <rwbarton> you need at least 1.18 with GHC 7.8
15:20:11 <lf94> Ok
15:20:16 <lf94> Thank you XD
15:21:42 <johnw> there are more days I wish =<< bound lower than $ than not
15:21:54 <johnw> or, that I had a function 'bind'
15:22:40 * quchen goes the chrisdone way and parenthesizes, =<< problem solved-ish
15:22:46 <bb010g> felixn: You can overload numbers to be functions, too. It's not a limitation, but a meaning change. (+) <$> x <*> y shows the movement and application of (+) into the applicative functor and value of x and that application inside the applicative to y. You're dealing inside something. x + y shows two numbers, not numbers in things. It's noise, but it helps
15:22:46 <bb010g> you remember what the hell you were doing with your code 2 months ago.
15:23:12 <hjulle> Is there any editor plugin or other way to automatically infer the type of an expression from it's context?
15:23:43 <bb010g> hjulle: GHCi & type holes
15:23:46 <merijn> hjulle: Depends which editor, emacs and vim do
15:23:48 <bb010g> s/type//
15:23:48 <orion> felixn: "the best thing you could do is use haskell in production" -- I don't know what to produce. I don't have anything in development or production. I'm unemployed.
15:23:52 <rwbarton> in ghc 7.8 if you replace the expression by _ it will tell you the expected type
15:23:58 <joe9> I am trying to use newtype to create a JSON instance, but, cannot get it correct. error: http://codepad.org/YfUBdL1a , code: http://codepad.org/CCRHyhQb Any help, please?
15:24:14 <merijn> rwbarton: Which is not quite as convenient as having a plugin just query the type of an existing expression
15:24:27 <bb010g> orion: Make something you want or think is missing. Make it better than it has been done. Sell it.
15:24:31 <merijn> Or rather, it's nice for different use cases
15:24:35 <bb010g> (Or give it away.)
15:24:40 <rwbarton> indeed
15:24:41 <johnw> quchen: yeah, I'm not quite ready to go with chrisdonelisp
15:25:12 <quchen> johnw: I don't know his current style, but "try to avoid dollars" served me really well so far
15:25:14 <merijn> hjulle: hdevtools and ghc-mod both are tools that let you typecheck code and have editor plugin to query types
15:25:31 <johnw> i likes dollars
15:25:32 <quchen> johnw: When you've got a "))))))" you should probably introduce a new binding though
15:25:40 <benzrf> quchen: agreed
15:25:59 <johnw> quchen: example of what I'm talking about: https://gist.github.com/7ec4342e2fe20808390b
15:26:00 <quchen> I also like `(f . g . h) x` style a lot.
15:26:00 <benzrf> johnw: i was thinking i might make a proper module out of the idea of that leftovers impl
15:26:01 <felixn> orion: then work on GHC if you want to be part of haskell!  I can pay you $0/hr to work on my site, lol getringer.com ... you can rewrite the backend in haskell if you want
15:26:20 <benzrf> johnw: like, set up a proper data type for commands and allow switching between buffering and feeding back and stuff
15:26:27 <hjulle> merijn: bb010g: Thanks!
15:26:27 <quchen> johnw: Oh, "do" and "atomically" and "unsafePerformIO" are fine with dollars.
15:26:31 <josephle> joe9: your readJSON function has return type JSON (MaybeBlank String) rather than JSON (MaybeBlank a)
15:27:29 <josephle> actually, I take that back
15:28:41 <athan> Are there invertable monads in the category of autofunctors?
15:29:45 <lf94> cabal install cabal; so sweet
15:30:27 <trap_exit> does that really work?
15:30:30 <trap_exit> I keep on getting outdated cabal when I try that way
15:31:23 <lf94> Yep, I'm getting 1.20 as we speak
15:31:27 <lf94> (Updating from 0.40 lol)
15:31:33 <quchen> Wat
15:31:38 <quchen> Cabal 0.40?
15:31:41 <lf94> Yeah
15:32:01 <lf94> Debian is pretty behind on packages, as always
15:32:08 <quchen> Did you find a computer digging in pyramids?
15:32:16 <felixn> zing!
15:32:38 <quchen> I mean 1.16 is old already, I've never seen < 1.10, so 0.40 takes the prize
15:32:50 <bb010g> athan: Try asking on #haskell-lens also, Edward Kmett's pretty boss with that stuff.
15:33:13 <athan> bb010g: Thanks :)
15:34:49 <fread2282> does runST copy?
15:37:27 <quchen> I don't think so.
15:37:49 <quchen> runST st = runSTRep (case st of { ST st_rep -> st_rep })
15:38:06 <quchen> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
15:38:23 <quchen> Whatever that means, there are no new values constructed, only old ones extracted.
15:41:07 <dfeuer> What's the downside of -fstatic-args keeping it out of -O2?
15:41:12 <merijn> Wait, really? cabal 0.40?
15:42:13 <merijn> Is that like a pre-python/java/ruby version of cabal? :>
15:43:15 <dolio> I don't think any version of cabal predate any of those.
15:44:14 <dfeuer> merijn: To the best of my knowledge, Cabal still isn't written in Python, Java, or Ruby.
15:46:19 <StoneToad> isnt' cabal written in haskell?
15:47:18 <felixn> https://gist.github.com/munro/0e719e1792df00de073e <-- could someone help me with this computation?  obviously I can't put "unexptected :: String -> *" in the return .. but not sure how to how rewrite it
15:47:42 <lf94> Ok so I've installed Cabal 1.20, but how do I run it? Where was it installed?
15:47:57 <merijn> dfeuer: No, I meant that that version of cabal predates the existence of those languages :p
15:48:50 <felixn> https://gist.github.com/munro/0e719e1792df00de073e <-- ah I fixed it, but is there a better way to write this?
15:48:52 <joshc> felixn: you probably want: if str == "" then unexpected "Don't do it bro" else return str
15:49:18 <lf94> Guys where did my meta cabal install install itself
15:49:19 <joshc> err, with the correct string literal, of course :)
15:49:37 <arutnev> lf94: what OS are you using?
15:49:44 <lf94> debian
15:49:45 <joshc> (the key point being: remove the outer 'return' and move it into the 'else' case)
15:49:46 <lf94> wheezy
15:49:56 <bb010g> felixn: First thing: Unnecessary do
15:50:05 <bb010g> @undo do { if str == "=" then unexpected "Don't do it bro" else (return str) }
15:50:06 <lambdabot> if str == "=" then unexpected "Don't do it bro" else (return str)
15:50:08 <arutnev> lf94: if you did cabal install it's probably at ~/.cabal/bin/cabal
15:50:24 <lf94> It isn't, the only thing there is 'operational-TicTacToe'
15:50:38 <lf94> How that even got there I have no idea
15:51:17 <bb010g> felixn: Could you give an example of ideal input and output?
15:51:47 <arutnev> lf94: did you install it with 'sudo'? if so it could've ended at /root/.cabal ...
15:52:18 <lf94> I didn't use sudo, but logged in a root :) alrighty
15:52:34 <felixn> bb010g: sure! https://gist.github.com/munro/0e719e1792df00de073e
15:52:56 <felixn> bb010g: joshc: thanks for the fix!  and now for the code golfing :)
15:53:33 <arutnev> lf94: i'm kind of noob, but from my understanding you should invoke cabal with your normal user for whatever you want regarding user-wide package installs
15:53:57 <arutnev> and then for specific projects you should `cabal sandbox` and leave the rest of the system alone
15:54:05 <lf94> arutnev: apparently I did
15:54:15 <lf94> @ installed as normal user
15:54:25 <bb010g> felixn: operator = operatorStr >>= (\str -> return $ Operator str)
15:54:31 <lf94> I have a zillion terminals open but when I went to check to see if I did, I did it as normal user
15:55:01 <lf94> So where could it be if I installed it as a normal user
15:55:05 <bb010g> felixn: Abstracting a bit, you have operator = operatorStr >>= f where f str = return $ Operator str
15:55:15 <bb010g> felixn: Can you make f point free?
15:56:48 <felixn> bb010g: probably could just apply Operator to operatorStr!
15:57:08 <felixn> bb010g: operator = Operator <$> operatorStr
15:57:29 <felixn> all tests pass :)
15:57:30 <bb010g> felixn: Yep. :)
15:58:29 <felixn> I love doctest ... ever since I saw rust putting tests in source, it's made so much since, it increases coherency, and provides good documentation for functions
15:58:37 <felixn> sense*
15:59:33 <bb010g> felixn: Next thing I can think of is making operator Applicative, but that would require recursion in separate functions, so I think that's it for golfing.
15:59:59 <bb010g> felixn: However, you can drop the return ret since ret is the last thing evaluated.
16:00:03 <merijn> pffft, did Tekmo get a job that isn't paying him to answer mailing lists or something? >.>
16:00:05 <felixn> bb010g: ah yea no worries, I was really just wonder if I could combine the "ret <- ..." and "return ret"
16:01:30 <joshc> felixn: you could probably rework your parser to not even explicitly make use of 'unexpected'
16:01:51 <joshc> using the parsing combinators
16:04:03 <begriffs> Is there a way to take a regular function a -> b and make a Maybe version (Maybe a -> Maybe b)? Hoogle didn't come up with anything.
16:04:10 <joshc> fmap!
16:04:16 <begriffs> Oh duh
16:04:18 <begriffs> thanks
16:15:16 <TheKing444> Hello, I am having a problem with Constraint kinds.
16:15:45 <ij> How does "odds = 1 : (odds >>= (\a -> return $ a + 1))" unravel? This probably not what happens: odds = 1 : (odds >>= f) = 1 : (1 : (1 :... right?
16:18:34 <c_wraith> TheKing444: explain your problem, and you'll probably get more feedback.
16:18:47 <TheKing444> wait, never mind
16:19:42 <kini> ij: shouldn't that be "+ 2"?
16:19:49 <c_wraith> ij: first things first - specialize the monad instance.  odds = 1 : (concatMap (\x -> [x + 1]) odds)
16:20:13 <joshc> ij: consider that (\a -> return $ a + 1) is the same thing as (fmap (+1)), which specialized to lists is (map (+1)) making: odds = 1 : map (+1) odds...does that help?
16:20:34 <Cale> joshc: That's not true
16:20:52 <Cale> (\a -> return (a + 1)) is not the same thing as fmap (+1)
16:21:15 <c_wraith> throw the >>= in front of it and it is.  Right result, wrong explanation. :)
16:21:15 <joshc> hmm, okay, maybe "the same" is misleading
16:21:40 <pjdelport> odds >>= (\a -> return $ a + 1) is the same(ish) thing as (1+) <$> odds
16:21:44 <Cale> :t (\a -> return (a+1))
16:21:45 <lambdabot> (Num a, Monad m) => a -> m a
16:21:51 <Cale> :t fmap (+1)
16:21:52 <lambdabot> (Num b, Functor f) => f b -> f b
16:21:56 <kini> also I might be mistaken but it seems like ij wants to know the operational behavior of that expression, not its general semantics ("how does it unravel")
16:22:04 <bb010g> :t return . (+1)
16:22:05 <lambdabot> (Num b, Monad m) => b -> m b
16:22:24 <kini> in which case c_wraith's hint to specialize the Monad instance is the correct first step
16:22:25 <joshc> Cale: ah, yes of course, thanks for correcting me!
16:22:50 <bb010g> :t fmap (+1)
16:22:52 <lambdabot> (Num b, Functor f) => f b -> f b
16:23:04 <spopejoy> is there a significant penalty for all the closures created with the State monad and ilk? does GHC do anything to simplify? conversely, is it enough of a penalty to worry about?
16:23:08 <bb010g> :t pure (+1)
16:23:10 <lambdabot> (Applicative f, Num a) => f (a -> a)
16:23:39 <bb010g> :t pure . (+1)
16:23:41 <lambdabot> (Applicative f, Num b) => b -> f b
16:23:57 <merijn> spopejoy: "Probably still tons faster than python/ruby"
16:24:07 <merijn> spopejoy: I wouldn't worry until profiling shows it's a bottleneck
16:24:15 <spopejoy> of course
16:24:45 <spopejoy> In my Java life I’m constantly creating one-off closures and it hasn’t bitten me yet, and this is in low-latency environments
16:25:05 <merijn> spopejoy: Also, realise that "creating closures" is basically what GHC's code generation is optimised for as that's 90% of what evaluating haskell is about ;)
16:25:45 <spopejoy> i’m just responding to something in Real World Haskell in the monad xformer chapter
16:25:50 <merijn> Well, let's say 50%, the other 50% being pattern matches
16:26:25 <hpc> also 50% garbage collection and 50% threading
16:26:44 <spopejoy> plus 50% type inference
16:26:45 <hpc> so that's 50% plus 50% plus 50% plus 50% plus 90% = 100%
16:27:24 <spopejoy> i’d love to read something about how GHC optimizes such things
16:27:51 <merijn> spopejoy: If you want to read about how haskell compiles to native code, then the STG paper is fairly instructive, if a bit out of date
16:27:52 <hpc> spopejoy: https://ghc.haskell.org/trac/ghc/wiki/Commentary -- this will get you started
16:27:58 <spopejoy> a simple State function does an astonishing amount of StateT constructor calls
16:28:02 <hpc> STG is good for basic theory
16:28:41 <hpc> for a few more years of reading: https://ghc.haskell.org/trac/ghc/wiki/ReadingList
16:28:51 <spopejoy> the Commentary. Reminds me of Lion’s Commentary on Unix
16:29:10 <arutnev> afaik in .NET closures are syntatic sugar for methods and scope helper objects, probably in Java works the same way
16:29:34 <merijn> spopejoy: Here, this one: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
16:30:39 <merijn> spopejoy: It's good if you want an intuition of how you can compile something like haskell to machine code
16:31:21 <spopejoy> in Java I was doing one-method interfaces, not “closures” like the kids are all excited about these days
16:31:40 <spopejoy> i think they’re almost identical though
16:31:44 <spopejoy> under the hood
16:32:28 <spopejoy> I’m wondering more what GHC can infer when it’s constantly pushing and pullling values in and out of a function wrapper
16:33:07 <hpc> part of the optimization process is strictness analysis
16:33:34 <hpc> which removes excess wrapping and unwrapping, and can sometimes convert operations into mutation (where it would be safe)
16:33:35 <arutnev> I know that library authors can hint the GHC on how to optimize some patterns so that the compiler can actually throw away some of the wrap-unwrap
16:34:14 <hpc> arutnev: you are thinking of rewrite rules, which you can use to simplify an expression to the point where ghc can detect it and take over
16:35:27 <arutnev> hpc: that's right
16:35:42 <hpc> it's definitely not magic, so i don't know exactly the conditions ghc is able to spot
16:36:08 <spopejoy> I wonder if RWH should have even mentioned it.
16:36:46 <kludgy> spopejoy: I'm slowly reading this right now, which seems related: http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
16:37:12 <hpc> RWH could use more real worldliness
16:37:28 <hpc> perhaps drop the entire "learn the language" section
16:38:58 <spopejoy> I was actually looking for resources about using MonadState, MonadIO, MonadReader etc
16:39:10 <spopejoy> RWH is one of the few
16:40:23 <hpc> that's about the level RWH should be going for the whole way through
16:40:41 <kgadek> hi. I have problems installing arithmoi on OS X 10.9.4… I hit this bug: https://ghc.haskell.org/trac/ghc/ticket/7143 in particular — this thingy: http://stackoverflow.com/questions/24796874/cant-install-diagrams-arithmoi-on-mac
16:40:45 <hpc> easy tutorials for frequently used libraries (and hopefully more state of the art ones too)
16:40:52 <kgadek> BUT if I install in fresh sandbox, it's all okay
16:41:02 <kgadek> could anybody hint me how to debug this?
16:41:47 <StoneToad> hpc: having some list of canonical recommended libraries would be huge
16:41:55 <kgadek> https://gist.github.com/3b002e1212317e2a4e35 <-- this is fresh sandbox log
16:42:19 <spopejoy> kludgy: is that stuff going into GHC?
16:45:01 <arutnev> kgadek: how did you install your system-wide cabal?
16:45:44 <dfarm> Hi all, I was looking for a suggestion on what library to use for processing large XML files (1-8 GB range) -- anyone have any experience with this kind of thing and/or tips?
16:45:58 <Fuuzetsu> dfarm: not HXT
16:46:05 <kludgy> spopejoy: I think it must be there already.. at least SpecConstr. Someone linked the paper for me when I requested more information about SpecConstr pathologies leading to long compile times in the optimization passes.
16:46:32 <dfarm> Fuuzetsu: Ok, that's useful information! Thanks.
16:46:55 <dfarm> I was leaning towards just hexpat, but figured I'd ask here since there are a surprising amount of XML libraries.
16:46:56 <kgadek> arutnev: …I think I just hit the rubber-duck effect — I spotted the script I use passes a --with-gcc=<path> to cabal install.
16:47:12 <kludgy> spopejoy: You'll probably get much better answers in #ghc
16:47:58 <kgadek> arutnev: but anyway, this is necessary for other things to build (can't remember now which packages got mad at gcc-clang, but I was the one to add that --with-gcc)
16:48:26 <Fuuzetsu> kgadek: --with-gcc is able to take clang in many situations (maybe all now but there are still some bugs IIRC), you should try on #ghc or the ghc mailing lists
16:49:02 <Fuuzetsu> or rather, any gcc-option-thing should be able to take clang
16:49:42 <kgadek> Fuuzetsu: ok, I'll try that in a second
16:50:43 <arutnev> kgadek: all problems I had with build stuff complaining about not having llvm or clang were solved by accepting Xcode's EULA 'cause it had to be done after an OS upgrade
16:51:19 <Fuuzetsu> I'd consider accepting an EULA more of a workaround ;)
16:51:25 <arutnev> kgadek: if you do a clang --version do you get meaningful results? :P
16:51:43 <kgadek> arutnev: well, did that once in the past. Now Xcode does not complain. // yeah, "Apple LLVM version 5.1 (clang-503.0.40)"
16:52:23 <kgadek> Fuuzetsu: welcome to apple world, agree EULA and have a nice day :)
16:53:37 <arutnev> that's the kind of problem that makes me miss strace on OSX
16:54:17 <kgadek> I just removed --with-gcc=<stuff>, let's see what happens…
16:55:42 <kgadek> noope.
16:55:57 <kgadek> let's try --with-gcc=$(which clang) then
16:58:47 <kgadek> aaand again the 'could not execute: opt'. But now that's strange, I thought that --with-gcc is to blame but seems it's not…
16:59:35 <geekosaur> kgadek, sounds like it's using -fllvm
16:59:37 <bms1> Is PrimMonad supposed to be lazy? Because it is
16:59:46 <kgadek> geekosaur: yes, it is
16:59:53 <geekosaur> do you have a full llvm installed? (xcode does *not* include opt)
17:00:10 <bms1> And using PrimMonad instead of specializing to IO caused me to have absolutely awful performance for this reason
17:00:15 <geekosaur> generally you need to install a full llvm from macports/homebrew/whatever to use -fllvm on os x
17:00:38 <geekosaur> this is not something ghc can fix
17:01:25 <kgadek> geekosaur: oh ok, so `brew install llvm` and then use --with-gcc=$(which clang), rith?
17:01:29 <kgadek> *right
17:01:32 <TheKing444> Expected kind `* -> Constraint',
17:01:32 <TheKing444>     but `MaybeC' has kind `(* -> *) -> Constraint' http://lpaste.net/108319
17:01:44 <geekosaur> something liek that, yes
17:01:47 <TheKing444> Can anyone help with the code, it is a monad transformer experiment.
17:01:58 <geekosaur> may need to make sure it's using the clang that goes with the installed llvm
17:01:59 <TheKing444> ConstraintKinds is being weird.
17:02:06 <geekosaur> (that is, you'll also want to brew install clang)
17:02:24 <geekosaur> and join the long line of complainants to apple that they only ship half of llvm
17:03:39 <TheKing444> http://lpaste.net/108319 I think the kind inference is off.
17:04:09 <TheKing444> A slight modification gives "Not in scope: type constructor or class `Constraint'"
17:05:51 <marchelzo_> Why does "(take 3) $! [1..]" return [1,2,3]? Shouldn't it go on for ever?
17:06:16 <TheKing444> marchelzo_
17:06:18 <benmachine> marchelzo_: $! only evaluates far enough to decide whether [1..] is [] or (x:xs)
17:06:22 <TheKing444> $! does normal form
17:06:30 <benmachine> only up to the first constructor
17:06:33 <TheKing444> (take 3) $!! [1..]
17:06:43 <TheKing444> > (take 3) $!! [1..]
17:06:44 <lambdabot>  Not in scope: ‘$!!’
17:06:44 <lambdabot>  Perhaps you meant one of these:
17:06:44 <lambdabot>    ‘$!’ (imported from Prelude), ‘!!’ (imported from Data.List),
17:06:44 <lambdabot>    ‘^!!’ (imported from Control.Lens)
17:06:50 <TheKing444> I mean weak normal form.
17:07:05 <dolio> bms1: What do you mean it's "lazy"?
17:07:08 <benmachine> weak head normal form, I've usually heard it called
17:07:22 <TheKing444> marchelzo_ look up NFData, it will explain it
17:07:35 <sipa> marchelzo_: those are two different questions; i assume it's clear that the right answer is [1,2,3]; but perhaps you wonder why it isn't taking infinite time?
17:07:39 <marchelzo_> TheKing444, ok
17:08:18 <kgadek> marchelzo_: basically you got the constructor CONS 1 SOMETHING
17:08:23 <bms1> dolio: I had a loop that essentially was like "go u i = V.write u i i >> go u (i + 1)", where u :: Data.Vector Int, i :: Int"
17:08:31 <bms1> (though obviously the loop stopped)
17:08:34 <kgadek> that's the weak head form — evaluate up to the outermost constructor
17:08:39 <kgadek> here CONS = (:)
17:08:46 <kgadek> SOMETHING = rest of the generated list
17:08:56 <marchelzo_> kgadek, why would that ever be useful?
17:09:20 <marchelzo_> sipa, yes
17:09:32 <bms1> dolio: And performance was horrible, so I looked a the simplifier output, and it looked let-allocated the recursive call before executing the write statement
17:09:33 <kgadek> hm, because sometimes that's all you need
17:09:35 <kgadek> for example
17:09:48 <kgadek> let's say you have a VERY time consuming function F
17:10:06 <kgadek> what's the result of `length [F 100, F 101, F 102, F 103]` ?
17:10:19 <dolio> The entire recursive call?
17:10:28 <kgadek> to get that you don't need to evaluate F 100 or any other
17:10:38 <kgadek> all you need is the… hmr
17:10:50 <kgadek> the layout of the data structure
17:11:06 <bms1> dolio: I believe so; I just changed the type signature to IO and everything worked well. I could undo it and check more exactly
17:11:07 <kgadek> in the example with Fs you had a list of 4 elements
17:12:18 <marchelzo_> kgadek, sure, but you could do that without ($!)
17:12:39 <kgadek> yes, but the $! is too weak to evaluate that
17:12:53 <kgadek> $! only evaluates 'to outermost level'
17:13:09 <marchelzo_> So when would $! ever be useful?
17:14:04 <benmachine> @src scanl'
17:14:05 <lambdabot> Source not found. Sorry.
17:14:11 <kgadek> for example to force evaluation of some value
17:14:26 <ij> kini, c_wraith, joshc — that totally helped, got it now.
17:14:29 <ij> thanks
17:14:30 <kgadek> sometimes you need to help the GHC's strictness analyser
17:14:33 <kazagistar> its useful as a slightly different form of seq...?
17:14:34 <kini> ij: cool :)
17:14:58 <kgadek> kazagistar: exactly
17:15:24 <bms1> dolio: I just checked: it let-allocates the result of the recursive call
17:15:43 <kazagistar> @src ($!)
17:15:44 <lambdabot> f $! x = x `seq` f x
17:17:52 <dolio> bms1: What version of ghc?
17:18:04 <bms1> dolio: 7.6.3
17:18:15 <dolio> Oh. That's too old for me to test.
17:18:20 <marchelzo_> I've never seen seq before. What is a concrete example of where it might be useful?
17:18:23 <dolio> Also, are you compiling with optimizations?
17:18:49 <bms1> dolio: I have -O2 on
17:19:29 <dfeuer> Out of one mouth, Haskeller's talk about using `seq` to improve performance. Out of the other mouth, they say it's not guaranteed to do what it often does that can sometimes improve performance, and if you want that you should use pseq.
17:19:43 <kgadek> marchelzo_: basically GHC tries to guess what values will be necessary so they are evaluated immediately, not creating a thunk (a computation, unevaluated value, lambda — call it whatever you like). Sometimes you need to help it to get better performance
17:20:09 <bms1> dolio: I'll try to make a minimal example
17:20:33 <kgadek> other usage is parallel processing… but that's a different story. For this path I'd recommend the great "Parallel and Concurrent Programming in Haskell"
17:20:48 <kgadek> by Simon Marlow
17:20:52 <marchelzo_> kgadek, ah. ok, thanks
17:21:26 <dfeuer> There's a comment in the code defining enumFromTo for Int that indicates that it is supposed to be lazy. But it looks like it's not lazy. Is that comment an admission that the author chose to make it stricter than it should be for performance, or am I missing something?
17:21:45 <kazagistar> I think I have come up with a "easy-medium" difficulty project for learning haskell: "write a program that simulates a turing machine, given a string, initial state, final states, and a list of states+transitions"
17:21:47 <dfeuer> Er... sorry, I mean enumFrom.
17:22:14 <dfarm> <interactive>: out of memory -- oh well. Maybe tomorrow :P
17:23:31 <kgadek> kazagistar: if you like new 'fun' concepts, read this: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
17:23:53 <dolio> bms1: You can try, but it looks like ghc 7.8 isn't doing this. At least, not for something like the example you gave above.
17:24:56 <bms1> dolio: Okay, thanks for checking! Maybe once I finish my example you can test that in ghc 7.8
17:25:11 <kazagistar> kgadek: uh...
17:25:30 <dfeuer> kazagistar: a Turing machine tape looks like a fairly easy zipper (the infinite part requiring some care). You just earned yourself an assignment: write a 2D Turing machine that wanders around on an infinite grid.
17:25:36 <kgadek> that's what we call 'fun' here at #haskell ;)
17:25:51 <kgadek> geekosaur: for the record — I solved the issue with your help :) `brew install llvm --all-targets --with-clang --with-lld --with-python && export PATH=/usr/local/opt/llvm/bin:$PATH`
17:26:31 <kgadek> geekosaur: (that's that issue with arithmoi & OS X)
17:26:45 <trap_exit> in haskell, I can define [!Double], but the list itself might be lazy
17:26:50 <trap_exit> can I define something like ![!Double]
17:26:55 <trap_exit> where the list itself is also strict ?
17:27:05 <trap_exit> well, I know that I can not define !{!Double]
17:27:17 <trap_exit> but I would like to define ![!Double] <-- is there a way to define somethign like this?
17:27:28 <kazagistar> dfeuer: Care? Only if you care about performance. Otherwise you just use a Map and call it good.
17:28:09 <Hafydd> @hoogle Monad m => Maybe (m a) -> m (Maybe a)
17:28:12 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:28:12 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
17:28:12 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:28:38 <kazagistar> trap_exit: out of curiosity, why would you possibly want a strict list? that sounds horrifying
17:29:03 <trap_exit> kazagistar: it's x,y coordinates for a svg text element
17:29:21 <trap_exit> data Vec2 = !Double !Double; then I want ! [ !Vec2 ]
17:29:44 <dfeuer> kazagistar: I don't see how a map makes anything about that easier. The care I refer to is that you want to extend the tape when you step off the edge, and you want to shorten the tape when moving the tape head if there are no non-blank spots in the direction you're moving away from
17:31:09 <kazagistar> trap_exit: Arrays or Vectors will actually give you random access, and are much better for storing something if you intend to access it many times, unless you need to insert in the middle
17:31:48 <kazagistar> dfeuer: all missing keys are assumed blank, only non-blank keys are stored
17:32:19 <trap_exit> kazagistar: so the question is not "why do you want a strict list" but "why are you using a list at all" ?
17:32:22 <trap_exit> kazagistar: that's a good question
17:32:41 <trap_exit> one which I don't have a good answer to
17:32:43 <geekosaur> trap_exit: the problem with ![!Double] is that if it were allowed, you would think it applies to the whole list but it could only apply to the head of it
17:32:51 <geekosaur> you need a list type that is itself strict to do it
17:33:00 <trap_exit> oh right, whnf
17:33:36 <geekosaur> well, more to the point is that it can't propagate it into the *definition* of list, only to the constructor it is applied to
17:34:04 <kazagistar> trap_exit: lists make sense if you are using them lazily, as iterations. But if you intend to keep long lists around in memory... ugh, linked lists
17:34:28 <Hafydd> @pl f (Just m) = Just <$> m; f Nothing = return Nothing
17:34:29 <lambdabot> (line 1, column 13):
17:34:29 <lambdabot> unexpected " "
17:34:29 <lambdabot> expecting operator
17:34:58 <dfeuer> kazagistar: that's ugly. A Turing machine's tape positions aren't numbered and are only accessed sequentially.
17:35:52 <orion> > foldl (+) 0 [1, 2, 3]
17:35:54 <lambdabot>  6
17:36:00 <orion> > foldl (^) 3 [3, 3, 3, 3, 3, 3, 3, 3, 3]
17:36:03 <lambdabot>  1505416414522092624314329803339865454307614347353742782362836158803762154357...
17:36:45 <trap_exit> so I'm reading this: http://stackoverflow.com/questions/9611904/haskell-lists-arrays-vectors-sequences and it's still not clear to me what the trade off of Array vs Vector is
17:36:49 <trap_exit> What is the tradeoff of Array vs Vector?
17:37:11 <kazagistar> dfeuer: your aesthetic sense is different from mine then
17:38:14 <bms1> dolio: I made a relatively simple example that has a let allocation for me
17:38:18 <bms1> http://lpaste.net/108323#line71
17:38:29 <jmcarthur> trap_exit: vector is only indexable by Ints, whereas Array is indexable by any instance of Ix. vector is implemented in such a way that composed vector operations fuse into one loop or at least very few loops
17:38:37 <bms1> (line 71 points to the let allocation of the recursive call)
17:38:42 <orion> > foldr (^) 3 [3, 3] == foldl (^) 3 [3, 3]
17:38:44 <lambdabot>  False
17:38:46 <orion> Why? ^
17:38:55 <dfeuer> kazagistar: I like the simpler
17:39:06 <dfeuer> simplest structure that gets the job done properly.
17:39:09 <trap_exit> jmcarthur: so if my indexes are all Ints, Vector dominates Array
17:39:14 <trap_exit> jmcarthur: is above correct?
17:39:53 <jmcarthur> trap_exit: well, i would normally go with vector in such a case, but it's not *necessarily* clear that it dominates. there may be some other factor i'm not thinking of.
17:39:55 <rwbarton> usually the kind of code that would use Array won't be subject to fusion anyways
17:40:11 <kludgy> orion: Look at the definition of foldr vs foldl. (^) isn't commutative
17:40:13 <dfeuer> A Turing machine is a pair of stacks, an extra symbol, and a lookup table.
17:40:22 <jmcarthur> rwbarton: well, some people use Array for stuff that could have been done with Repa
17:41:27 <orion> kludgy: Which one (foldl vs. foldr) follows correct order of operations?
17:41:44 <kazagistar> dfeuer: I like the simpler, extendible code. The only difference between 1D and 2D in my model is which movement directions are defined, and Map Integer Symbol vs Map (Integer, Integer) Symbol
17:43:16 <kludgy> orion: I guess that depends on what your various 3's mean in the application to (base ^ power). You can probably make it work either way, but foldr is generally preferred.
17:43:35 <benzrf> kazagistar: i feel like Ix comes in there somewhere
17:43:52 <dfeuer> kazagistar: a Turing machine simply is not a map, conceptually.
17:44:48 <kazagistar> dfeuer: basically, I can isolate "proximity" and "arrangement" and whatnot... your dimensions are entirely determined by a (Ord index) and movements ([ index -> index ]), and now, if you feel like it, you could make it 4 dimentional and have three dimentions wrap around in some crazy spiral klein glass, and the runtime wouldn't care
17:44:50 <dfeuer> orion: how does a fold relate to exponentiation?
17:46:50 <dfeuer> kazagistar: I understand and appreciate your point.
17:47:53 <bms1> Could someone with GHC 7.8 try this example code, and see if they get the let allocation of the recursive call in the simplifier output that I am getting on line 71?
17:47:56 <bms1> http://lpaste.net/108323#line71
17:47:59 <kazagistar> dfeuer: if I was implementing a simple, traditional turing machine, I agree that zippers are an elegant solution
17:50:49 <kludgy> bms1: What's the command line to produce the core output?
17:53:16 <rwbarton> -ddump-simpl
17:53:43 <bms1> kludgy: ghc -O2 -ddump-tofile -ddump-simple is what I'm running
17:53:51 <kludgy> bms1: Trying now
17:53:58 <bms1> sorry, that's -ddump-to-file
17:54:01 <bms1> kludgy: Thanks!
17:54:04 <kludgy> bms1: ok
17:54:15 <kludgy> bms1: Waiting for vector to build :P
17:54:35 <kludgy> bms1: Move over to #ghc?
17:54:35 <dfeuer> kazagistar: there's also quite a tradition of simulating more complicated Turing-style machines with simpler ones. Puzzles!
17:54:45 <kazagistar> dfeuer: (I was learning about manifolds recently, so I can't help but be suspicions of "normal directions" :P)
17:55:20 <orion> https://hackage.haskell.org/package/enumerator-0.4.20/docs/Data-Enumerator.html -- "Compatibility note: Iteratee will become abstract in enumerator_0.5." -- What does "abstract" mean here?
17:56:31 <RchrdB> orion, usually, "we expose the existence of the data type, but not its constructors, so you can't pattern match or construct its values directly, but have to go through other functions".
18:03:16 <mizu_no_oto> I'm writing a simple roguelike in Haskell, and, from what I understand, most games represent the world state by having 2 dimensional arrays of monsters, dungeon terrain, items, etc.  What's the most practical representation of this in Haskell?  Array (Int, Int) a?  Vector (Vector a)?  Map (Int, Int) a?
18:07:25 <kazagistar>  mizu_no_oto:	Map is good if it is mostly empty, because it is sparse, but it might be a bit slower, an MArray would be good if you know the size beforehand and it is pretty full, dunno about Vector
18:07:43 <kazagistar> mizu_no_oto: when you say "most games" you mean "games that use tiles", right?
18:08:42 <kazagistar> like, older 2d and isometric games with grid-limited movement, etc
18:08:49 <mizu_no_oto> kazagistar: yes.
18:09:10 <btcNeverSleeps> I don't understand why the following works: if I have the type signature    "quux :: Int -> State (M.IntMap Int) Int"      how comes I can, say:  "do   m <- get"   and access the hashmap  when I implement quux?   How comes quux's type signature is not something like:   "quux :: Int -> State (M.IntMap Int) Int -> Int"
18:09:15 <mayski> yay for haskell roguelikes
18:09:18 <mizu_no_oto> Actually, what do modern games with more continuous movement do?
18:10:20 <mayski> mizu_no_oto: are you using hscurses?
18:10:55 <mizu_no_oto> I was actually thinking of using diagrams and gtk, and having it just use a simple tileset.
18:11:07 <mizu_no_oto> instead of being curses based
18:11:11 <mayski> oh you're going graphical
18:11:13 <mayski> ok
18:11:35 <btcNeverSleeps> I'm confused because when I read "quuxx :: ... -> State ...", to me it looks like I'm returning a State.  Yet I can access that state I'm returning?   (I don't know if my question makes any sense)
18:12:06 <joelteon> btcNeverSleeps: State (M.IntMap Int) Int is a computation that carries an IntMap and produces an Int
18:12:07 <kazagistar> btcNeverSleeps: Because State is already a fancy wrapper for { s -> (a, s) }... you are getting confused by the "do notation" and how it translates to binds, maybe?
18:13:06 <btcNeverSleeps> kazagistar: yes maybe... But I'm not sure I'd be any less confused with binds in that case.  I kinda understand that it represents a computation and not the result of the computation itself.
18:13:17 <kazagistar> @undo do { m <- get; return (m,m); }
18:13:17 <lambdabot> get >>= \ m -> return (m, m)
18:13:18 * hackagebot diagrams-core 1.2.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.1 (bergey)
18:13:20 <joelteon> if you want to run the computation, that's when you use runState
18:13:20 * hackagebot diagrams-lib 1.2.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.1 (bergey)
18:13:31 <joelteon> up until then, everything that starts with State is just composing multiple state computations together
18:13:57 <joelteon> take "get"; it's a trivial state computation, one which carries a state 'a' and also returns the value of that state
18:14:06 <btcNeverSleeps> ok
18:14:21 <kazagistar> @src get
18:14:21 <lambdabot> Source not found. Whoa.
18:14:26 <kazagistar> worth a try :P
18:14:35 <joelteon> get is defined in terms of the StateT constructor
18:14:37 <btcNeverSleeps> I'll "undo" the do I wrote, maybe it's going to be a bit clearer
18:14:38 <joelteon> or it used to be
18:14:40 <joelteon> don't worry about it
18:15:37 <btcNeverSleeps> and "State (M.IntMap Int) Int", which represents the computation, is a function right?
18:15:49 <joelteon> it's a newtype around a function
18:16:09 <btcNeverSleeps> ok
18:16:14 <joelteon> sorry, i came in late. what are you trying to do?
18:16:25 <joelteon> understanding the internals of State isn't always necessary to write code that uses State
18:16:32 <btcNeverSleeps> me? I'm trying to understand the state monad :)
18:16:37 <joelteon> oh, ok
18:16:41 <MP2E> lol :P
18:16:48 <joelteon> fair enough
18:16:52 <btcNeverSleeps> ;)
18:17:15 <joelteon> well, State is a way to make code that passes a (state, value) tuple around nicer to read and write
18:17:56 <MP2E> it's a pattern over a function that takes some kind of State, returns an output and an altered State in a tuple
18:18:03 <joelteon> 'get' and 'put' worry about the state; 'return' produces the value
18:18:19 * hackagebot diagrams-contrib 1.1.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2 (bergey)
18:22:06 <btcNeverSleeps> so "State (M.IntMap Int) Int" is a newtype around a function returning an (Int, M.IntMap Int) tuple?  And a function "quux :: ... -> State (M.IntMap Int) Int"   returns a State monad, which is a function?
18:22:54 <subleq_> if types are propositions, how do you represent something like the transitivity of equality as a type?
18:23:08 <dwcook> btcNeverSleeps, "State monad" is not the correct term for what that returns. You could say it returns a State value.
18:23:19 <btcNeverSleeps> dwcook: ok (taking notes)
18:23:41 <dwcook> btcNeverSleeps, "State monad" would refer to the instance of Monad for State
18:24:06 <dwcook> btcNeverSleeps, the rest of that sounded okay I think
18:24:57 <btcNeverSleeps> dwcook:    "State monad" would refer to the instance of Monad for state  <-- yup, right... I already did that very mistake in here (two days ago or so)
18:25:03 <Cale> subleq_: As a function which takes arguments of type (x == y) and (y == z) and produces a result of type (x == z)
18:25:36 <subleq_> Cale: ok, but what's the type (x == y) ?
18:25:43 <Cale> subleq_: More precisely, the type would look something like  forall A : Type, forall x y z : A, (x == y) -> (y == z) -> (x == z)
18:28:10 <btcNeverSleeps> The other thing with which I've got some problems is that nearly every tutorial about the State monad starts by rewriting its own state monad.  And then there this Control.Monad.State (which I'm experimenting with) and the same with Lazy and/or Strict added and then some 'ST' stuff, etc.  It's kinda hard to find where to begin : )
18:28:21 <btcNeverSleeps> But I won't bother the channel with that : )
18:28:30 <dwcook> btcNeverSleeps, ST is unrelated to State.
18:28:38 <btcNeverSleeps> dwcook: oh that's a good news
18:29:54 <Cale> subleq_: For any type A and values x, y : A, there is a type Id(A,x,y). This type has a single constructor refl : forall x : A, Id(A,x,x)
18:30:31 <Cale> subleq_: and Id(A,x,y) is written x == y where A is implicit
18:30:56 <Cale> subleq_: Obviously, this requires dependent types
18:31:19 <subleq_> Cale: you've lost me. is this something that can be expressed in haskell?
18:31:23 <Cale> no
18:32:04 <platz_> If I install a library (non-executable)  into a sandbox, can I then somehow "link" to that sandbox from my home .cabal dir so I can import those libs.  It's kind of a wierd case because it's not "project-specific" like I think add-source is intented for?
18:32:12 <Cale> But it's the standard thing to do in dependently typed languages such as Coq, Agda and Idris
18:32:17 <platz_> kind of wanting to have my cake and eat it too
18:33:20 * hackagebot diagrams-cairo 1.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2 (bergey)
18:34:37 <platz_> maybe "cabal sandbox init --sandbox /path/to/shared-sandbox"
18:34:59 <platz_> might not work for the home dir though
18:35:15 <subleq_> Cale: is there a nontrivial example of types as propositions that is expressible in haskell?
18:35:42 <Cale> subleq_: Well, the function <-> implication connection is still pretty strong.
18:36:15 <Cale> subleq_: In logic, if you want to prove A -> B (that is "A implies B"), you start by assuming A, and try to construct a proof of B from there.
18:37:01 <Cale> subleq_: In lambda calculus (or Haskell), if you want to construct a function of type A -> B, you start by assuming you have some x :: A, and try to construct an expression y :: B, and then (\x -> y) :: A -> B
18:37:41 <Cale> In logic, if you know that A -> B, and you know that A, then you can deduce B. In lambda calculus, if you have f :: A -> B, and x :: A, then you get f x :: B.
18:38:21 * hackagebot diagrams-svg 1.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1 (bergey)
18:38:36 <subleq_> Cale: sure, but the examples of proofs of that type i've seen aren't very interesting. The stuff like (a, b) -> a just seems trivial
18:39:00 <Cale> subleq_: Well, it's just simple propositional logic, how nontrivial do you expect it to be?
18:39:52 <Cale> subleq_: If you want to see it developed into a system which is sufficient to do all of mathematics, then you'll want to look into dependently typed languages.
18:39:55 <platz_> recursion gives you induction, if memory serves
18:40:03 <Cale> Yes.
18:40:20 <Cale> subleq_: Also, in Haskell, things are somewhat broken by the fact that we have general recursion:
18:40:22 <Cale> :t fix
18:40:23 <lambdabot> (a -> a) -> a
18:40:26 <Cale> :t fix id
18:40:27 <lambdabot> a
18:40:29 <jle`> subleq_: how about: ((a ∨ (a → b)) → b) → b
18:40:42 <Cale> ^^ so you get a proof of anything, the system is inconsistent
18:40:54 <jle`> if either a or (a implies b) imply b, then b is true
18:41:01 <jle`> not quite so trivial
18:41:09 <jle`> but the haskell proof writes itself :)
18:41:10 <burn77> Hi
18:41:27 <jle`> @djinn (Either a (a -> b) -> b) -> b
18:41:27 <lambdabot> f a = a (Right (\ b -> a (Left b)))
18:41:37 <jle`> hi burn77 !
18:41:50 <burn77> Hi jle :)
18:42:21 <burn77> What is the main topic hete @ jle
18:42:36 <jle`> here?
18:42:38 <jle`> we talk about haskell! :D
18:42:44 <jle`> it's a 24/7 haskell party
18:42:46 <Exio> and lots of cool stuff
18:42:48 <Cale> burn77: The Curry-Howard correspondence, at present
18:42:49 <dfeuer> HASKELL.
18:42:59 <vanila> hello
18:43:11 <burn77> Thanks jle
18:43:17 <vanila> jle, i came across your blog randomly - it's very good
18:43:19 <jle`> all day all night haskell
18:43:21 * hackagebot diagrams-postscript 1.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1 (bergey)
18:43:25 <dfeuer> @msg lambdabot > null [undefined..]
18:43:25 <lambdabot> Not enough privileges
18:43:27 <jle`> oh thanks vanila :)
18:43:36 <dfeuer> Errr
18:43:45 <dfeuer> > null [undefined]
18:43:46 <lambdabot>  False
18:43:55 <dfeuer> > null [undefined..]
18:43:56 <lambdabot>  No instance for (GHC.Enum.Enum a0)
18:43:57 <lambdabot>    arising from the arithmetic sequence ‘GHC.Err.undefined .. ’
18:43:57 <lambdabot>  The type variable ‘a0’ is ambiguous
18:43:57 <lambdabot>  Note: there are several potential instances:
18:43:57 <lambdabot>    instance GHC.Enum.Enum GHC.Types.Double
18:44:02 <subleq_> jle`: is that (Either a ((a -> t) -> t)) or ((Either a (a -> t)) -> t) ?
18:44:05 <dfeuer> > null [(undefined::Int)..]
18:44:07 <lambdabot>  *Exception: Prelude.undefined
18:44:32 <benzrf> dfeuer: hmm
18:44:33 <dfeuer> See, that's wrong. And there's a comment in the source *saying* that it should be lazy, but it's *not*.
18:44:40 <benzrf> dfeuer: i think i know why thats wrong
18:44:48 <benzrf> o wait never mind
18:44:50 <jle`> subleq_: it's (Either a (a -> b) -> b) -> b
18:44:54 <benzrf> hmm, what does [n..] desugar to
18:44:58 <dfeuer> And I don't understand why they documented the bug instead of fixing it.
18:45:02 <jle`> benzrf: enumFrom n, i think
18:45:05 <dfeuer> enumFrom n
18:45:08 <jle`> @pl \n -> [n..]
18:45:08 <lambdabot> enumFrom
18:45:13 <jle`> thank you @pl
18:45:24 <jle`> @pl \x y -> [x..y]
18:45:25 <lambdabot> enumFromTo
18:45:26 <dfeuer> And the problem is that it unboxes its argument immediately and sends it to a helper.
18:45:28 <benzrf> ah, and the Enum impl for Int is strict on the int
18:45:42 <burn77> Are you guys,developing an open source project ?
18:45:52 <jle`> it's kind of weird that succ from Enum is defined to be partial for Bounded
18:45:54 <subleq_> jle`: I can't tell what the two arguments to Either are
18:46:02 <jle`> subleq_: Either a (a -> b)
18:46:09 <jle`> a ∨ (a → b)
18:46:24 <subleq_> ok
18:46:36 <dfeuer> Whereas what it *should* do is enumFrom x = x : case x of I# x# -> eftInt# (x# +# 1#) maxInt#
18:46:45 <jle`> so... ((a ∨ (a → b)) → b) → b  says, "If either a or (a -> b) being true implies b, then b is true"
18:46:55 <jle`> hm mixing up some things there
18:47:05 <jle`> "if either a or (a implying b) being true implies b, then b is true"
18:47:05 <vanila> burn77, yes!
18:47:12 <jle`> burn77: yea! :D
18:47:52 <johnw> if anyone is looking for a small library that makes use of STM and async to play around with in order to get a feel for these libraries, I just wrote git://github.com/jwiegley/taskpool.git
18:47:55 <johnw> as a bonus you'll learn fgl :)
18:48:15 <jle`> subleq_: the proof is a little tricky to work through if you just look at the proposition...but if you try to implement the haskell function, it's pretty straightforward and not so painful :)
18:48:22 * hackagebot diagrams-rasterific 0.1 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1 (bergey)
18:48:24 * hackagebot taskpool 0.0.1 - Manage pools of possibly interdependent tasks using STM and async  http://hackage.haskell.org/package/taskpool-0.0.1 (JohnWiegley)
18:48:25 <burn77> Ok thank's
18:48:30 <jle`> ooh i always wanted to learn fgl
18:48:53 <johnw> it makes very simple use of fgl; it's a much easier to use library than I ever realized
18:49:07 <burn77> I'm a c,js,php program,where i can start to help u
18:49:07 <johnw> I'm using it as an optimal representation for a partially ordered set
18:49:23 <johnw> where node edges indicate the existence of relation
18:49:43 <benzrf> johnw: did u hear my idea a bit earlier
18:49:49 <johnw> benzrf: maybe not
18:49:59 <johnw> you were going to implement pipe leftovers as a package?
18:50:01 <johnw> sounds like a great idea!
18:50:12 <benzrf> johnw: no, pipes-parsing handles that
18:50:33 <benzrf> what i was thinking was generalizing my hacky implementation a bit
18:50:49 <benzrf> defining a more generic upstream component that you can send commands to with upstream yielding
18:50:57 <benzrf> which could buffer or accept leftovers, etc
18:51:21 <benzrf> im not sure how useful that would be but it sounds like fun to implement
18:52:01 <jle`> subleq_: alternatively you can also truth table it out ;)
18:52:07 <jle`> that's not so fun
18:53:14 <vanila> careful with truth tables: they are classical logic
18:53:24 <jle`> oh yeah, i forgot.
18:53:29 <jle`> good call
18:56:47 <jle`> > let x ~> y = not (x && not y) in do { a <- [False, True]; b <- [False, True]; guard (((a || (a ~> b)) ~> b) ~> b); return (a, b) }
18:56:48 <lambdabot>  [(False,False),(False,True),(True,False),(True,True)]
18:57:36 <benzrf> what is (~>)
18:57:44 <jle`> > let x ~> y = not (x && not y) in do { a <- [False, True]; b <- [False, True]; guard ((a ~> b) ~> b); return (a, b) }
18:57:46 <lambdabot>  [(False,True),(True,False),(True,True)]
18:57:49 <benzrf> its not xr...
18:57:53 <benzrf> *xor
18:57:57 <bms1> benzrf: classical implication: i.e., not A or B
18:58:07 <burn77> I started learning  haskell n it looks smart n lazy
18:58:10 <benzrf> ah
18:58:18 <jle`> wait that did not work out as i expected
18:58:24 <jle`> burn77: it's fun :)
18:58:38 <benzrf> bms1: 'if x is true, y must be true'
18:59:16 <jle`> i like thinking of it as "cannot hold, if a truth implies a falsehood"
18:59:28 <jle`> but...that's the same thing heh.
19:00:16 <burn77> Yes jle , am a math/comp scien university student i've liked it,game of logic
19:01:35 <dfeuer> I also don't understand why fromEnum deals with all that unboxing and special rules explicitly, for either enumFrom or enumFromTo. For bounded types, I will try both using my fixed unfoldr. For Integer, enumFrom should ideally use a strictly accumulating version of iterate, which doesn't seem to exist yet.
19:02:21 <rwbarton> dfeuer: might be worth checking git blame... though that code may be very old
19:02:59 <dfeuer> I still haven't a clue about git, rwbarton. And I don't care who's to blame.
19:03:21 <rwbarton> not who, but why
19:04:18 <dfeuer> Ah. Yeah, I doubt git existed when that was written.
19:05:12 <rwbarton> well, that comment is present in the initial revision in 2001
19:05:25 <rwbarton> so no help there
19:05:52 <michaelt> dfeuer: You are working on the fusion in Data.List?
19:06:35 <dfeuer> michaelt: trying. Lots to learn!
19:07:04 <dfeuer> But there are some obvious missed opportunities, yeah.
19:08:01 <michaelt> I've been studying it to see if it could be translated to a monadic version, sort of like this attempt, which is more developed http://hub.darcs.net/ertes-ag/fuse/browse/Data/Fuse
19:08:51 <michaelt> dfeuer: there are too many things to keep track of
19:10:02 <michaelt> dfeuer: oh, I like the suggestion of an uncons. Every type that has unfoldr should have an uncons. Then you can translate between them, V.unfoldr B.uncons, etc
19:10:24 <dfeuer> Why, michaelt? Do you have some ideas?
19:10:50 <michaelt> Nope, just studying....
19:11:12 <michaelt> Have you noticed that the vector library is missing an `uncons` too?
19:14:56 <ByteEater> hi, all! is there a way to define an uninhabited type Void using "data Void", i.e. not introducing a Void constructor like Data.Void, and then to define a function absurd :: Void -> a?
19:15:25 <burn77> NickServ REGISTER
19:15:48 <michaelt> ByteEater: yes, with EmptyDataDecls
19:15:51 <dfeuer> michaelt: my IRC client did something weird, so I just saw your messages.
19:15:53 <jmcarthur> ByteEater: the usual way is to just use EmptyDataDecls, but then absurd has to be defined with undefined or error, which i'm not a huge fan of
19:16:03 <dfeuer> I'm also about to drop—low battery.
19:16:15 <jmcarthur> ByteEater: my favorite way uses RankNTypes:    newtype Void = Void { absurd :: forall a. a }
19:16:28 <michaelt> does the new EmptyCase extension amount to anything?
19:16:50 <jmcarthur> oh i forgot about that
19:16:52 <Cale> Yes, you can write absurd x = case x of
19:17:05 <Cale> Using EmptyCase
19:17:26 <jmcarthur> okay that seems the way to go now that we have that extension
19:18:54 <jmcarthur> hmm... what is   case (undefined :: Void) of   ? bottom, i hope? kind of weird that it would have to be strict even without any patterns, but i can't think of any other sensible behavior
19:20:11 <Cale> *** Exception: Prelude.undefined
19:20:20 <cmears> If ghci reinterprets a module instead of loading its object file because of "[flags changed]", is there some way to see how the flags are different?
19:20:34 <dolio> "case <anything> of" is bottom.
19:21:01 <augur> johnw: is there any option other than Storable? im not sure how i feel about trying to implement an instance for lists and maps :\
19:21:30 <shachaf> In particular, it's bottom for all the cases you don't match, just like every other case.
19:21:40 <johnw> augur: iterate over the list, poking each thing in and advancing the pointer by the size of the thing you just poked
19:21:49 <johnw> I'm pretty sure there is a Storable instance for arrays
19:21:50 <rwbarton> so it should be an incomplete pattern match exception right?
19:21:52 <jmcarthur> maybe the question i'm really asking is "is absurd strict?" and i think the answer is yes.
19:21:56 <subleq_> if "case <anything> of" is bottom, why is it more pleasing to use EmptyCase than just saying undefined?
19:22:06 <dolio> It is vacuously strict.
19:22:06 <johnw> maps would be much tricker
19:22:09 <shachaf> For some reason it seems to give you the bottom you pass it.
19:22:20 <jmcarthur> subleq_: because ghc would warn you if there was actually something to pattern match on
19:22:22 <johnw> augur: you could also turn your Haskell data string into a ByteString, via serialization.  Those are Storable
19:22:25 <shachaf> Which I suppose it's allowed to do.
19:22:37 <dolio> Presumably you want to know about operational semantics.
19:22:43 <rwbarton> but not if I give it non-bottom
19:22:51 <rwbarton> case 3 of {} -> *** Exception: <interactive>:3:1-4: Non-exhaustive patterns in case
19:22:56 <shachaf> I mean in particular with Void.
19:22:59 <augur> johnw: yeah. mostly i just need to store lists of numbers, maps of numbers, etc
19:23:17 <shachaf> Oh, er, never mind.
19:23:24 <shachaf> It just forces the bottom you pass it, of course.
19:23:41 <shachaf> Which is what you would probably write by hand anyway, for Void.
19:23:51 <rwbarton> case x of {} seems to behave the same as x `seq` error "Non-exhaustive patterns ..."
19:23:55 <ByteEater> thanks for the nice solutions; it seems I have to update my Haskell, as it's too old to recognize the EmptyCase extension
19:24:01 <shachaf> Yes.
19:24:25 <orion> Hey, I am trying to compile hs-noise from github (https://github.com/thoughtpolice/hs-noise) in a sandbox and I am getting this error: http://lpaste.net/7633279993170100224 -- does anyone know what could be going wrong?
19:25:22 <jmcarthur> well, absurd for Void defined with EmptyDataDecls but without EmptyCase would not necessarily force its argument (e.g.  absurd _ = undefined), but absurd defined with RankNTypes would (e.g.  absurd (Void a) = a)
19:26:27 <Fuuzetsu> orion: the ‘nacl’ package it depends on is not on Hackage
19:26:29 <michaelt> orion: the github repo is version 0.0.0 but the one on hackage is ahead of it.
19:27:32 <Fuuzetsu> michaelt: actually, the noise hackage package is a different project (ping thoughtpolice, might want to rename that)
19:27:52 <Fuuzetsu> in any case, version 0.0.0.0 would indicate that the project is probably not ready to be used
19:27:59 * Fuuzetsu → bed
19:28:27 <michaelt> Fuuzetsu: oh, sorry. but I think it was nevertheless part of cabal's confusion.
19:28:31 <benzrf> Fuuzetsu: that's impossible without bottoms
19:28:50 <benzrf> @djinn Fuuzetsu -> bed
19:28:50 <lambdabot> Error: Undefined type Fuuzetsu
19:28:53 <benzrf> meh
19:28:57 <benzrf> @help djinn
19:28:57 <lambdabot> djinn <type>.
19:28:57 <lambdabot> Generates Haskell code from a type.
19:28:58 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
19:29:03 <benzrf> isnt there a thing for defining types in it
19:30:30 <michaelt> orion: if I put both git repos in one sandbox directory, I seem not to have trouble with cabal install ./hs-nacl/ ./hs-noise
19:35:02 <dolio> jmcarthur: GHC could if it wanted to.
19:36:12 <kazagistar> I wrote a simple State ( https://gist.github.com/kazagistar/e7fed3302e3748b4553d )
19:39:17 <benzrf> kazagistar: hella
19:39:38 <thoughtpolice> orion: michaelt - you can also use 'cabal sandbox add-source' to add a reference to the nacl project
19:39:46 <thoughtpolice> so you don't need one sandbox.
19:39:50 <NemesisD> does anyone happen to know of haskell shops that are hiring? building a list
19:39:59 <halogenandtoast> I almost hate asking, but I feel so out of my depth here. How would I shuffle this Deck? https://gist.github.com/halogenandtoast/235e48e6f90aabfd49c2
19:40:05 <thoughtpolice> anyway, the nacl bindings aren't done (despite the fact I've been working on them for like over a year on and off). I should really get around to releasing them
19:40:36 <shachaf> thoughtpolice: I would want bindings that have a reasonable Haskell API for NaCl itself and no add-ons.
19:40:45 <thoughtpolice> orion: and if you're *actually* interested in hs-noise, it is now out of date wrt the spec, and needs updating. AFAIK that is the only Noise implementation around, and the spec changed a month or two ago. it doesn't support 448-bit elliptic curves or AES-GCM
19:40:46 <shachaf> Surely that's easier to release. :-)
19:40:49 <thoughtpolice> shachaf: I know you do
19:41:19 <thoughtpolice> and also yes, I realized later 'noise' was taken on hackage... I'll probably rename it 'quiet' or 'crypto-noise' or something else, I dunno
19:41:38 <michaelt> thoughtpolice: Yes, I was just making sure that the whole thing was coherent, and that the missing nacl was orion's only problem, as Fuuzetsu suggested.
19:42:56 <kazagistar> halogenandtoast: shuffling is not the most pretty thing http://www.haskell.org/haskellwiki/Random_shuffle
19:43:05 <thoughtpolice> I should get around to finishing that set of sub-projects one day; I have two or three related ones in this area that need finishing including those two
19:43:29 <halogenandtoast> kazagistar: I read through that but I get Haskell error messages that I am not capable of reading.
19:43:29 <michaelt> thoughtpolice: hm, nacl broke down on its cbits in the end; maybe it's an OS X thing; src/cbits/util/randombytes.c:1:0: error: bad value (native) for -march= switch; src/cbits/util/randombytes.c:1:0: error: bad value (native) for -mtune= switch
19:43:40 <thoughtpolice> michaelt: ugh, I thought I fixed that
19:43:45 <thoughtpolice> yes, that's an OSX/clang thing
19:43:53 <halogenandtoast> The function `randomIO' is applied to one argument, but its type `IO a0' has none In a stmt of a 'do' block: j <- randomIO (i, n)
19:43:57 <bb010g> thoughtpolice: It would seem easiest using ST & Knuth's random shuffle.
19:44:13 <bb010g> & a random seed
19:44:19 <jle`> shuffling isn't too hard, is it...?
19:44:26 <dfeuer> michaelt: I think I finally understood what you said about uncons and unfoldr. I guess foldr cons1 nil1 . unfoldr uncons2 converts from one representation to another?
19:44:42 <michaelt> thoughtpolice: Oh, I see; my setup my not be exemplary
19:44:49 <halogenandtoast> jle`: I don’t know, currently destroying my mind.
19:44:50 <thoughtpolice> michaelt: oh, I only fixed it 99% of the way
19:45:00 <thoughtpolice> michaelt: removing '-march=native' in nacl.cabal should be fine
19:45:04 <jle`> oh i meant, it doesn't have to be too complicated
19:45:15 <thoughtpolice> (It was needed previously for some other crap that I ended up removing because it was painful)
19:45:49 <vanila> bb010g, that's a nice way to do it
19:46:23 <bb010g> thoughtpolice: It looks like the second example on that wiki page is it, actually. So use that.
19:46:23 <kazagistar> halogenandtoast: that is a pretty silly bug, hmm. Its good to understand the code you are looking at, but depending on your level, you might not be able to... do you know how to work with monads?
19:46:32 <thoughtpolice> bb010g: ?
19:46:42 * thoughtpolice thinks bb010g is replying to the wrong person
19:46:47 <bb010g> Sorry, halogenandtoast
19:46:51 <jle`> map fst . sortBy (comparing snd) . zip xs . randomRs <$> getStdGen
19:46:51 <michaelt> dfeuer: I was just thinking that it was that V.unfoldr L.uncons :: [a] -> Vector a;  B.unfoldr V.uncons :: Vector Word8 -> ByteString etc etc.
19:47:35 <halogenandtoast> kazagistar: The only thing I know about monads is >>=
19:47:35 <kazagistar> halogenandtoast: you can just make a shuffling algorithm with a really really stupid time complexity that is fairly simple... do you know fisher-yates?
19:47:39 <michaelt> dfeuer: if all the libraries with unfoldr also had uncons, there would be no need for `toVector` `toByteString` etc.
19:47:46 <bb010g> jle`: How's the time on that?
19:47:51 <halogenandtoast> kazagistar: Is that the sequal to fisher-price?
19:47:58 <jle`> :t \xs -> map fst . sortBy (comparing snd) . zip xs . randomRs <$> getStdGen
19:47:59 <lambdabot>     Couldn't match type ‘g0 -> [a1]’ with ‘[a0]’
19:47:59 <lambdabot>     Expected type: (a1, a1) -> [a0]
19:47:59 <lambdabot>       Actual type: (a1, a1) -> g0 -> [a1]
19:48:05 <jle`> oops
19:48:05 <bb010g> https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
19:48:06 <dfeuer> Ah, I think I see, michaelt. Maybe. I will need to look at that again.
19:48:13 <jle`> :t \xs -> map fst . sortBy (comparing snd) . zip xs . randoms <$> getStdGen
19:48:15 <lambdabot> [b] -> IO [b]
19:48:24 <jle`> it's about as efficient as a shuffle can be
19:48:31 <jle`> fisher yates and all
19:48:37 <bb010g> jle`: For linked lists, I presume?
19:48:43 <jle`> yeah
19:49:07 <bb010g> :t \xs -> (map fst . sortBy (comparing snd) . zip xs . randoms <$>)
19:49:08 <lambdabot> (RandomGen a, Functor f) => [b] -> f a -> f [b]
19:49:30 <dfeuer> michaelt: that's ... really pretty.
19:49:35 <michaelt> dfeuer: without unfoldr and uncons you need quadratically many toX fromX functions
19:49:53 <kazagistar> halogenandtoast: that is the algorithm being implemented by all those functions... anyways, it does not matter, you can just do an algorithm like "pick a random card, put in resulting deck, repeat" and call it good if you want
19:50:01 <bb010g> :t \xs -> (fmap fst . sortBy (comparing snd) . zip xs . randoms <$>)
19:50:02 <lambdabot> (RandomGen a, Functor f) => [b] -> f a -> f [b]
19:50:39 <halogenandtoast> kazagistar: Okay, I’ll ponder on that, my Haskell is terrible at this point, but I only learn by making things.
19:50:54 <jle`> > map fst . sortBy (comparing snd) . zip "hello world" . randoms $ mkStdGen 15
19:50:55 <lambdabot>  "wedlll oohr"
19:51:01 <jle`> > map fst . sortBy (comparing snd) . zip "hello world" . randoms $ mkStdGen 8917345
19:51:04 <lambdabot>  "e lwhldolro"
19:51:29 <kazagistar> that works :P
19:51:38 <jle`> i guess the real significant function is the
19:51:39 <dfeuer> michaelt: you still want to have specially optimized conversions for related types, but yes, your approach is lovely.
19:51:54 <kazagistar> and it is faster then the repeated picking, so that is something
19:51:54 <bb010g> @hoogle (a -> b -> c) -> t1 a -> t2 b -> [c]
19:51:56 <jle`> :t \g xs -> map fst . sortBy (comparing snd) . zip xs . randoms $ g
19:51:57 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:51:57 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:51:57 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:51:58 <lambdabot> RandomGen s => s -> [b] -> [b]
19:52:10 <jle`> hm
19:52:16 <jle`> :t \xs g -> map fst . sortBy (comparing snd) . zip xs . randoms $ g
19:52:16 <bb010g> Can't you make zipWith with a fold?
19:52:17 <lambdabot> RandomGen s => [b] -> s -> [b]
19:52:20 <jle`> there, that's the function you want
19:52:28 <jle`> so you can lift it to an IO StdGen
19:52:31 <jle`> by using fmap
19:52:31 <dfeuer> Not well, bb010g. Sadly.
19:52:39 <dfeuer> So long for now!
19:52:54 <halogenandtoast> jle`: is g a seed?
19:53:03 <jle`> halogenandtoast: yeah, that's a pure function on a seed g
19:53:17 <jle`> map fst (sortBy (comparing snd) (zip xs (randoms g)))
19:53:21 <bb010g> :t \xs -> map fst . sortBy (comparing snd) . zip xs . randoms
19:53:23 <lambdabot> RandomGen a => [b] -> a -> [b]
19:53:23 <joelteon> jle`: i liked your blog post
19:53:24 <jle`> would be the application-style version
19:53:28 <jle`> thanks joelteon :)
19:53:50 <jle`> halogenandtoast: if you are in a do block, you can get a StdGen by using the function newStdGen :: IO g
19:53:55 <jle`> you can bind ig using <-
19:54:02 <jle`> and then return (shuffle xs g)
19:54:04 <kazagistar> alas, it isn't PERFECTLY random... you need to add nub in there to make sure that stable sorting does not ruin randomness
19:54:18 <shachaf> whoa, naturality is such a great concept
19:54:28 <shachaf> alt. parametricity
19:54:35 <bb010g> Is Data.Foldable imported to lambdabot qualified as F?
19:54:35 <shachaf> i should understand it properly one of these days
19:54:52 <jle`> bb010g: one way to find out :)
19:54:53 <shachaf> bb010g: Yes.
19:55:02 <kazagistar> \xs g -> map fst . sortBy (comparing snd) . zip xs . nub . randoms $ g
19:55:05 <jle`>  /q lambdabot :t F.toList
19:55:08 <shachaf> (Easy enough to test yourself.)
19:55:41 <kazagistar> you gotta do that or else random number collisions will cause items to be slightly more likely to stay in the same order as reversed
19:55:51 <kazagistar> so you have to make sure the randoms are unique
19:56:22 <jle`> oh if you are in haskell you'l need to say that you want randons to produce [Double]
19:56:38 <jle`> i wonder where the best place would be to add the annotation
19:58:30 * hackagebot wai-extra 3.0.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.1.1 (MichaelSnoyman)
19:58:32 * hackagebot conduit-extra 1.1.3 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.3 (MichaelSnoyman)
19:59:50 <johnw> query bitemyapp
20:02:39 <lf94> haskell is the best how come I wasn't using haskell when I first started programming
20:02:51 <lf94> How come everyone isn't using haskell
20:02:51 <NemesisD> very few people start out that way
20:02:53 <jle`> lf94: i don't knwo! :D
20:02:59 <jle`> life's great mysteries
20:03:04 <johnw> lf94: yeah, it's a real mystery to me too
20:03:21 <NemesisD> lf94: check by /r/haskell about once a week to see that mystery hashed out again and again
20:03:24 <johnw> popular and good are hardly connected, is a general rule of life
20:03:25 <lf94> Honestly I started to realize mathematical notations for programming were extremely expressive about 2 years ago
20:03:35 <lf94> But now that I'm actually using a mathematical based language
20:03:45 <lf94> Holy shit programming should've been this years ago
20:04:04 <shachaf> @quote kmc mathematicians
20:04:04 <lambdabot> kmc says: Haskell isn't really designed by mathematicians.  it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
20:04:17 <NemesisD> the closest satisfactory answer i've seen is that haskell is quite different and may take longer to get "productive" and that most devs will choose feeling productive early over a better language
20:04:46 <lf94> shachaf: I didn't say designed by mathematicians
20:04:52 <johnw> yeah, a lot of people fail to see the value in paying your costs up front
20:04:53 <orion> mitchty: Did you have to add-source on hs-nacl?
20:05:48 <mitchty> orion: que?
20:06:05 <NemesisD> i'm currently scouting out haskell dev shops. hoping to make the jump pretty soon
20:06:37 <lf94> NemesisD: nice answer
20:07:05 <orion> mitchty: Nevermind
20:08:10 <orion> thoughtpolice: Curious, there is a saltine package on hackage that seems reasonably complete. How come you opted to create hs-nacl?
20:11:29 <thoughtpolice> orion: the origins of my package predate Saltine by quite a long time (well over a year). in fact the author, Joseph, has been quite interested in my package for a long time, but I was lazy to release it so he wrote his own I suppose. Saltine uses libsodium. hs-nacl uses pure C code (meaning it supports windows with zero effort) derived from SUPERCOP (or friends) to achieve this.
20:11:55 <octopuscabbage> is it alright to visualize >>= as the unix pipe and >> as imperitive execution
20:12:02 <thoughtpolice> the project originally started in, hm, mid-2012 or so. I learned a lot from what I wanted out of the API design and distribution needs for that
20:12:17 <thoughtpolice> mid last year I ended up rewriting the whole damn thing into hs-nacl, which is far more portable and supports more features.
20:13:09 <thoughtpolice> hs-nacl is now about 90% and works quite great from what I can tell, so I need to polish it off and finish the remaining 90% of the work now that the initial 90% is done :)
20:13:12 <jle`> octopuscabbage: they're both imperative execution
20:13:21 <jle`> octopuscabbage: er, sequencing
20:13:30 <jle`> one just allows the result to be used by the other side
20:13:33 <jle`> and one doesn't
20:13:34 <orion> thoughtpolice: It's not ready for hackage yet?
20:13:37 <octopuscabbage> jle`: ah i see now
20:13:45 <octopuscabbage> jle`: so when shoudl i use it over $ or .
20:13:47 <bb010g> octopuscabbage: Somewhat. The Unix pipe would more be an operator like <<< (Data.Category).
20:14:05 <jle`> octopuscabbage: types
20:14:09 <octopuscabbage> jle`: is it just when a monad is involved?
20:14:18 <jle`> the types will guide you
20:14:29 <jle`> (>>=) is more like a flip ($) ofc.
20:14:58 <thoughtpolice> orion: not quite. mostly documentation, and a few final things I need to complete. things like finishing off a few final parts of the key API, and exposing that in the 'top level interface' (Crypto.Nacl) for easy use.
20:15:38 <jle`> octopuscabbage: (>>=) allows you to apply an (a -> m b) to an (m a)
20:15:49 <octopuscabbage> jle`: ahhh i see i see
20:15:49 <jle`> octopuscabbage: ($) allows you to apply an (a -> b) to an a
20:16:00 <octopuscabbage> jle`: okay i see now
20:16:06 <jle`> it also allows you to apply an (a -> m b) to an a, for that matter...but yeah.
20:16:10 <thoughtpolice> orion: in reality I could have released it quite a long time ago, but I mostly wanted the initial release to be dependable with good documentation, examples, etc.
20:16:23 <octopuscabbage> and i've heard that visualizing an m as tranformation on a is a good way of thinking of it?
20:16:28 <octopuscabbage> in the type m a
20:17:28 <thoughtpolice> orion: it's becoming clear I should get this over with though, because I get pestered about it once every 2 months or so it seems with increasing regularity :)
20:17:48 <orion> thoughtpolice: Is there anything I can do to help?
20:17:49 <jle`> octopuscabbage: i don't know
20:17:57 <jle`> octopuscabbage: i don't like thinking about m as anything besides m :)
20:18:03 <jle`> in general, of course
20:18:04 <bb010g> :t (<<<)
20:18:06 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
20:18:11 <octopuscabbage> jle`: i would like that too if i fully understood m
20:18:24 <jle`> if you know what your specific Monad is, then you can substitute what the instance is
20:18:47 <jle`> IO a represents a computation that returns an a
20:18:55 <jle`> Maybe a represents a value that may or may not contain an a
20:18:59 <jle`> [a] contains multple a's
20:19:15 <octopuscabbage> what does >> do on [a]?
20:19:18 <jle`> that is, i don't like assigning a general intuition to what the `m` means
20:19:40 <jle`> octopuscabbage: i might suggest that you play around and see :)
20:19:47 <jle`> (>>=) might be interesting on [] as well
20:21:02 <thoughtpolice> orion: examples and some benchmark comparisons would be nice, e.g. vs OpenSSL for hashing, key generation speeds, etc. the documentation probably is spotty in various areas and could be improved ('grep TODO' might help). the types in the package are probably missing a lot of instances of some very basic typeclasses
20:21:22 <jle`> octopuscabbage: incidentally enough i wrote a couple of blog posts on a practical application of (>>=)/(>>) for list, http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus
20:22:20 <octopuscabbage> jle`: i was just reading your blog actually, that's what got me onto the subject. you clever bastard and your hiding talking about monads :P
20:22:56 <shachaf> Talking about IO without saying the word "monad" isn't "talking about monads".
20:23:14 <thoughtpolice> orion: the tests could also be variously improved in several ways I'm sure, since they really only check certain roundtrip conditions. some of the C bits could probably be replaced with higher-speed versions, and the C code itself could probably use a bit of a cleanup
20:23:31 <jle`> yeah, i'm not really hiding it...i'm talking about the subset of IO manipulation where Monad is irrelevant
20:23:43 <jle`> which is...a fairly large subset
20:23:49 <SrPx> Does anyone know what is the right answer to the last question of http://www.seas.upenn.edu/~cis194/lectures/11-applicative2.html ? Here is a print: http://o7.no/UHFOUM . I can implement those functions in a way that typecheck, no problems. But it is certainly not what the guy was asking for, and as I don't know what he wants, I can't really do much about it... http://lpaste.net/108335
20:24:09 <octopuscabbage> jle`: well i know that now, after reading the first paragraph of this post.
20:25:03 <jle`> i cringe a little whenever people say "the IO monad" when they're just referring to Haskell's IO type
20:25:18 <benzrf> jle`: it's become embedded into my brain
20:25:22 <benzrf> i'm sorry :'(
20:25:38 <jle`> that's like saying "let's learn how to use 'the List monad'", and all they are talking about is [1,2,3], pattern matching, cons...
20:25:57 <jle`> i mean yeah...List has a monad instance...but if you're just talking about pattern matching and list literals...it's kind of a weird way to say it
20:25:59 * benzrf shudders
20:26:22 <benzrf> SrPx: do you mean replicateA
20:27:02 <benzrf> > sequenceA (1, Just "foo")
20:27:03 <lambdabot>  Not in scope: ‘sequenceA’
20:27:04 <lambdabot>  Perhaps you meant one of these:
20:27:04 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
20:27:04 <lambdabot>    ‘sequence’ (imported from Control.Monad.Writer),
20:27:04 <lambdabot>    ‘T.sequence’ (imported from Data.Traversable)
20:27:06 <benzrf> > T.sequenceA (1, Just "foo")
20:27:08 <lambdabot>  Just (1,"foo")
20:27:10 <benzrf> neat
20:27:21 <SrPx> benzrf: pardon?
20:27:21 <jle`> what a strong function
20:27:27 <benzrf> jle`: ?
20:27:35 <jle`> it's a pun heh.
20:27:37 <benzrf> SrPx: 11:22 < SrPx> Does anyone know what is the right answer to the last question of  http://www.seas.upenn.edu/~cis194/lectures/11-applicative2.html ? Here is a print: http://o7.no/UHFOUM . I
20:27:42 <jle`> admittedly a lame one
20:27:56 <thoughtpolice> orion: all of those would actually be really useful, if you want to help! my time is limited these days to work on those projects (surprisingly writing Haskell for a job somewhat leaves you drained to write more at home :) I'm a bit busy during the day, but mostly around on IRC, so I can certainly answer questions if you want to send some patches to me, and direct you on anything you might want to improve.
20:28:06 <benzrf> SrPx: ah, all of those?
20:28:47 <benzrf> oic
20:28:47 <SrPx> I'm not sure I get it, so sequenceA is supposed to take the Just out in that case... but I don't really see what it is supposed to do in general
20:28:48 <thoughtpolice> orion: (there are certainly some things you could improve that would be a bit hard to summarize over IRC, but I'd be willing to write up an actual issues about them if you're interested)
20:28:53 <bb010g> Is there a class/something else of pairs of categories that have a transformation? E.g. bind would be a case of class (Category c1, Category c2) => CatTransform c1 c2 where { (>>=) :: c1 b c -> c2 a b -> c2 a c } and instance CatTransform (->) Kleisli where { (>>=) = Data.Monad.(>>=) }
20:28:54 <benzrf> SrPx: ok, let's look at (*>) first
20:29:12 <benzrf> SrPx: pick some random concrete applicative, please
20:29:15 <bb010g> I don't know how many other instances you'd find, though
20:29:23 <orion> thoughtpolice: ok, thanks. I am unemployed at the moment, but I may get a job doing php/drupal/chef/devops. I am curious if doing PHP drains people from working on Haskell and vice versa.
20:29:32 <SrPx> benzrf: all the type says is `f a → f b → f b`. The obvious thing would be discarding the first argument
20:29:33 <SrPx> benzrf: lists?
20:29:46 <benzrf> SrPx: actually lists are kind of a bad example for this particular function
20:29:47 <benzrf> :p
20:29:50 <benzrf> got anything else
20:29:58 <SrPx> :(
20:30:02 <thoughtpolice> orion: I was writing PHP just the other day :)
20:30:04 <SrPx> maybe
20:30:14 <orion> thoughtpolice: Does that drain you as much as Haskell does?
20:30:15 <thoughtpolice> (I had absolutely no idea what I was doing, FWIW)
20:30:15 <benzrf> i mean you can use lists there, but it's less obviously useful
20:30:39 <benzrf> SrPx: ok how about, uh, Maybe
20:30:48 <SrPx> yes, Maybe.
20:30:50 <benzrf> SrPx: let's say you have a function `Maybe a -> Maybe b -> Maybe b'
20:31:03 <benzrf> if you're not just writing const, what's the only really reasonable thing to do here?
20:31:18 <thoughtpolice> orion: well, different projects :) working on GHC and client stuff is draining in different ways. for PHP, it was draining in the sense I was mostly floundering around figuring out what to do :P
20:31:31 <SrPx> benzrf: okay, hmm... if the first argument is nothing, I return nothing... if not, I return the second?
20:31:35 <benzrf> SrPx: ok, sure
20:31:45 <SrPx> ok that makes sense, but that is specific to Maybe...
20:31:47 <thoughtpolice> (but luckily the project I was working on has very excellent, nice upstream maintainers who held my hand when I needed :)
20:31:51 <benzrf> SrPx: hold on :-)
20:31:55 <benzrf> SrPx: how about lists, then
20:31:58 <benzrf> i guess it's not THAT bad an example
20:32:19 <benzrf> SrPx: if i have `[a] -> [b] -> [b]', what's the only thing i can really do with the [a]
20:32:19 <carter> ziplists are fun
20:32:33 <jle`> i/b 26
20:32:36 <jle`> oops
20:32:37 <benzrf> oh wait, i guess theres a couple options there
20:32:37 <SrPx> nothing I can think of, to be honest... just discard it?
20:32:39 <benzrf> blehhhh
20:32:42 <jle`> wow i have too many buffers open
20:32:47 <SrPx> ah
20:32:48 <carter> jle`: i have more
20:32:59 <benzrf> SrPx: alright, the actual answer here if you follow the true pattern im getting at is
20:33:02 <carter> :k ZipList
20:33:03 <lambdabot> * -> *
20:33:12 <carter> @info ZipList
20:33:12 <lambdabot> ZipList
20:33:13 <octopuscabbage> i have a dumb question: is a monad just a typeclass that implements bind?
20:33:14 <SrPx> well if `a` is an `int` and `b` is an `string` you could replicate the strings but I don't know, that seems too specific
20:33:27 <benzrf> SrPx: replace each item in the first list with the second list, then concant
20:33:28 <jle`> in all situations where i've found ziplist to be useful, they were a bit too much syntactical noise to be worht using :/
20:33:30 <benzrf> *concat
20:33:39 <carter> jle`: applicatives make em magic
20:33:49 <benzrf> SrPx: see what i mean, not all that useful out of context :p
20:33:49 <carter> jle`: also, for size lists, ziplist is the only sane applicative
20:33:51 <jle`> benzrf: in Haskell, as of today 7/28/2014, Monad implements return and (>>=)
20:33:51 <carter> *sized
20:33:57 <benzrf> jle`: !!!!!
20:33:58 <SrPx> benzrf: o.o that doesn't sound obvious but okay
20:34:00 <jle`> oops, octopuscabbage
20:34:01 <CaptainK> and they have a cool bot to talk to
20:34:02 <benzrf> SrPx: it certainly isnt
20:34:03 <jle`> octopuscabbage: following the laws
20:34:14 <jle`> carter: ah.  you're talking about the applicative instance for sized lists
20:34:16 <benzrf> SrPx: the point is that that's what (*>) does for lists
20:34:18 <jle`> s/the/and
20:34:24 <jle`> er
20:34:25 <bb010g> octopuscabbage: It could also be type that implements join and has Applicative
20:34:27 <jle`> s/and/an
20:34:28 <SrPx> benzrf: anyway, how could I implement `*>` once to present so different behaviours
20:34:29 <CaptainK> opps wrong ch, was talking to someone else about what is cool over here
20:34:30 <benzrf> SrPx: in general, Applicative allows you to combine two functorial values, right?
20:34:32 <carter> jle`: you saw my sized lists stuff
20:34:37 <bb010g> :t join
20:34:38 <lambdabot> Monad m => m (m a) -> m a
20:34:39 <SrPx> yes benzrf
20:34:55 <benzrf> SrPx: if you have f a and f b, you can join them into f (a, b), or if you have f (a -> b) and f a, you can get f b
20:34:58 <benzrf> etc
20:34:59 <jle`> hm.  is there any other way to write an Applicative instance for a sized list?
20:35:13 <carter> jle`: don't think so
20:35:13 <benzrf> SrPx: what's a way you can use that particular ability, but satisfy the type `f a -> f b -> f b'?
20:35:23 <octopuscabbage> jle`: wait, what laws?
20:35:32 <bb010g> jle`: Sized with nats in the type?
20:35:36 <jle`> octopuscabbage: google monad laws
20:35:45 <carter> jle`: better do
20:35:48 <SrPx> pardon, "if you have f a and f b, you can join them into f (a, b)" ?
20:35:52 <carter> @google monad laws
20:35:52 <jle`> bb010g: no, just any arbitrary container type with a fixed amount of items
20:35:53 <lambdabot> http://www.haskell.org/haskellwiki/Monad_laws
20:35:53 <lambdabot> Title: Monad laws - HaskellWiki
20:36:09 <benzrf> SrPx: that's equivalent in power to (<*>)
20:36:10 <carter> jle`: no, i think bb010g  has got it right
20:36:14 <jle`> data MyContainer a = MyContainer a a a a a
20:36:19 <jle`> oh, that was what i was referring to :|
20:36:21 <benzrf> SrPx: the pair function in the page you linked does exactly that
20:36:32 <carter> jle`: i was talking about SizedList (n::Nat) a
20:36:32 <bb010g> jle`: So, effectively sized with nats
20:36:39 <carter> bb010g: i've a whole library that uses them
20:36:44 <carter> for array indexing
20:36:47 <benzrf> SrPx: in general, you can use an applicative instance to map a multi-arg function across several functorial values
20:36:51 <solatis> jle`: i'm reviewing your blog post right now, excellent material!
20:36:53 <jle`> that makes sense then
20:37:01 <SrPx> hm okay, sure
20:37:03 <benzrf> and you get their structures merged while you supply a function to handle merging any values
20:37:07 <benzrf> if you want to use a container metaphor
20:37:09 <bb010g> type MyContainer a = SizedList S (S (S (S Z))) [a]
20:37:12 <jle`> solatis: thanks :)  hope it was helpful!
20:37:22 <jle`> i'm going to think about other lawful applicative instances
20:37:26 <jle`> but i can't imagine one
20:37:31 <jle`> maybe my imagination is not strong enough
20:37:34 <SrPx> benzrf: (thinking)
20:38:23 <solatis> jle`: it is very helpful -- these kind of posts are exactly the ones newbies need.
20:38:30 <carter> jle`: sometimes theres only one
20:38:33 <carter> lets prove it!
20:38:41 <orion> What's the best way to generate documentation?
20:38:48 <bb010g> jle`: I can't think of anything else besides zipping because for (<*>) they have to have the same type, and the sizing means that they have to have the same size to have the same type
20:38:55 <carter> orion: for a random .hs file or for a whole project?
20:39:01 <carter> bb010g: YUP
20:39:01 <orion> the latter
20:39:02 <carter> :)
20:39:07 <carter> orion: cabal haddock
20:39:12 <orion> thank you
20:39:18 <jle`> Applicatives are weird!
20:39:25 <jle`> there is always only one lawful Functor instance
20:39:26 <benzrf> SrPx: note that in the case of Maybe, you preserved any nothingness, but use any value from the 2nd item. and in the case i told you for lists, you use the structure of the first list (in the sense that you have a series of items of the same length), but all the values you end up with are from the 2nd arg
20:39:26 <carter> haddock main.hs -h
20:39:40 <carter> orion: for a single file haddock main.hs -h works
20:39:43 <jle`> afaik there is only one lawful Monad instance for a given type...but that's only because I can't think of any types with more than one
20:40:02 <jle`> Applicative is weird.  there doesn't seem to be anything meaningful you can say about the number of lawful applicatives for a particular type in general
20:40:05 <benzrf> SrPx: you're merging their structure in a way dictated by the instance, but only keeping values from the 2nd one. hence the signature
20:40:16 <carter> jle`: try to come up with a legal monad instance for a sized type
20:40:31 <benzrf> SrPx: please note that im using a container metaphor and thats not really applicative to all applicatives
20:40:37 <jle`> heh, i meant "if there is an instance, it is unique"
20:40:41 <jle`> there is no Monad instance for the sized thing
20:40:53 <carter> jle`: o rll?
20:40:55 <carter> why not?
20:41:08 <bb010g> Is there a Monad for ZipLists?
20:41:16 <carter> i don't think so
20:41:18 <SrPx> benzrf: I kinda get where you're getting, but, for example, there is nothing I can do using the functor/applicative instance to, say, merge a "Nothing" and a "Just 7" into "Nothing"
20:41:19 <benzrf> bb010g: how would join work
20:41:21 <bb010g> Or are they just Applicative
20:41:26 <benzrf> SrPx: yep
20:41:27 <SrPx> benzrf: right?
20:41:30 <bb010g> benzrf: Good point
20:41:33 <jle`> carter: because
20:41:40 <carter> https://github.com/wellposed/numerical-core/blob/master/src/Numerical/Array/Shape.hs is my static sized list module
20:41:45 <benzrf> bb010g: i actually tend to find it easier to think if monads in terms of join
20:41:53 <benzrf> if only because bind already covers it PLUS i have to keep thinking about fmap too
20:41:59 <SrPx> benzrf: so how can I implement (*>) so it does just that? There is not that information (how to merge 2 Maybe values) in the instances
20:42:01 <carter> jle`: i need a proof argument :)
20:42:05 <benzrf> SrPx: there is!
20:42:10 <bb010g> :t join
20:42:11 <carter> i know you're correct
20:42:12 <lambdabot> Monad m => m (m a) -> m a
20:42:16 <carter> but I don't like "because"
20:42:18 <carter> :p
20:42:18 <benzrf> SrPx: the instance defines how to apply a function in the first functorial value to a value in the second one
20:42:28 <jle`> carter: because because
20:42:32 <jle`> :)
20:42:37 <jle`> i'm going to think about it now >_>
20:42:37 <benzrf> SrPx: remember, if you do 'maybeValue <*> maybeValue', it exhibits the exact same behavior
20:42:39 <carter> jle`: you're not allowed to say that when teaching
20:42:40 <carter> :P
20:42:44 <benzrf> except that it applies a function instead of only keeping the rhs
20:42:49 <jle`> because magic
20:42:50 <SrPx> benzrf: ... a second
20:42:59 <carter> jle`: no, lets talk about ways you could prove it
20:43:00 <jle`> and because i say so
20:43:30 <carter> eh
20:43:43 <jle`> well. the only meaningful return is a fully filled thing
20:43:51 <carter> yes
20:43:54 <carter> SO
20:44:01 <jle`> because that's the only return for which pure f <*> x = fmap f x
20:44:02 <carter> a monad instance exists for the size 1 and size 0 case
20:44:05 <carter> right?
20:44:09 <benzrf> SrPx: if you do 'fs <*> xs', you apply each function in fs to each value in xs. if you ignored the functions in fs, you'd just end up with all the values in xs for each functoin in fs
20:44:14 <carter> huh
20:44:16 <carter> i should add those!
20:44:17 <carter> :p
20:44:23 <jle`> add what?
20:44:27 <bb010g> [[1,2,3],[4,5,6]] could be zipped if a function was in the type... So newtype ZipList' f a = { getZipList :: (f,[a]) }
20:44:27 <SrPx> benzrf: okay it does, so what we want is something like `(*>) a b = second ((,) <$> a <*> b)`
20:44:45 <benzrf> SrPx: you mean fmap snd?
20:44:50 <jle`> yeah, monad instance exists for size 1, size 0, and size (0 or 1)
20:45:03 <carter> with size 2
20:45:05 <carter> it look like
20:45:13 <tertl3-laptop> whats the best editor for haskell with intellisense?
20:45:14 <carter> type Tuple a = Tup (a,a)
20:45:22 <carter> tertl3-laptop: what are you used to?
20:45:37 <carter> i'm an old fogey who just uses the build error messages
20:45:40 <carter> and reads the docs
20:45:41 <bb010g> join $ ZipList' (+) [ZipList' (+) [1,2,3], ZipList' (+) [4,5,6]] == ZipList' (+) [5,7,9]
20:45:43 <carter> but other people use automatigc
20:45:47 <bb010g> Right?
20:45:56 <tertl3-laptop> im used to GUI
20:46:02 <jle`> bb010g: can you guess which law that would violate?
20:46:05 <jle`> oh
20:46:06 <bb010g> (Or something like that)
20:46:06 <SrPx> benzrf: oh of course. Okay, I still have to think a little bit about how the information of merging two Maybes was presented on the instance... give me some mins
20:46:06 <benzrf> tertl3-laptop: get unused
20:46:23 <bb010g> jle`: Which?
20:46:25 <tertl3-laptop> unused?
20:46:25 <carter> benzrf: thats not nice. But tertl3-laptop , tis true
20:46:29 <benzrf> SrPx: 1 sec
20:46:29 <jle`> (if it violates one at all)
20:46:32 <benzrf> SrPx: before you do
20:46:34 <benzrf> you're doing this:
20:46:43 <benzrf> fmap snd $ liftA2 (,) a b
20:46:47 <carter> bb010g: you're assuming monoidal structures
20:46:49 <carter> or semigroupyness
20:46:53 <swgillespie> tertl3-laptop: emacs :)
20:46:54 <benzrf> if you remove the applicative junk you'r edoing:
20:46:59 <benzrf> snd $ (,) a b
20:47:09 <benzrf> there is a simpler way to write that :-)
20:47:12 <carter> tertl3-laptop: i use sublime text 3
20:47:20 <carter> some people use vim
20:47:22 <carter> some people use emacs
20:47:22 <bb010g> carter: Not quite, if you include your zip function in the type, which would act a lot like a monoidal operation
20:47:24 <carter> some people use taom
20:47:31 <bb010g> some people use Yi
20:47:32 <carter> benzrf: ?
20:47:35 <carter> bb010g:?
20:47:37 <jle`> carter: return x = (x, x)...hm.  oh.  by paremetricity there are only a few possible definitions of (>>=), huh
20:47:38 <carter> explain your propsal
20:47:41 <benzrf> carter: i use vim because vim is gr8
20:47:45 <jle`> and we can just check if any of them follow the laws
20:47:48 <SrPx> benzrf: ? (*>) = fmap (snd . lift2A (,)) ?
20:48:13 <SrPx> wait pardon
20:48:13 <tertl3-laptop> i like sublime text
20:48:26 <tertl3-laptop> i didnt know 3 is released
20:48:27 <benzrf> SrPx: not point-free
20:48:29 <benzrf> SrPx: look at what this is:
20:48:36 <bb010g> carter: What are you confused on?
20:48:36 <benzrf> snd ((,) a b)
20:48:43 <carter> exlpain the type again
20:48:45 <swgillespie> 3 is still technically in beta but it'll probably be in beta until 4 comes out
20:48:46 <benzrf> SrPx: what's the more idiomatic way of doing that
20:49:09 <SrPx> benzrf: I'd say just "b"? But we were talking about how that was wrong
20:49:11 <jle`> one possible (x, y) >>= f = f x.  another, (x, y) >>= f = f y.  another, (x, y) >>= f = (fst f x, snd f y).  another, (x, y) >>= f = (snd f x, fst f y).  another, (x, y) >>= f = (fst f y, snd f x).  another, (x, y) >>= f = (snd f y, fst f x)
20:49:12 <carter> bb010g: 'cause i don't understand the proposal
20:49:14 <tertl3-laptop> beta
20:49:20 <jle`> i think i've enumerated all of the possible implementations of (>>=)
20:49:22 <carter> tertl3-laptop: its a very nice beta
20:49:32 <carter> jle`: better yet, just djinn
20:49:33 <jle`> hm. oh and fst/fst and snd/snd pairs
20:49:37 <tertl3-laptop> beta is so subjective
20:49:38 <jle`> djinn only gives me one, right?
20:49:42 <benzrf> SrPx: well, what you're doing is applying (,) across two functorial values, then mapping in snd
20:49:48 <jle`> @djinn (a, a) -> (a -> (b, b)) -> (b, b)
20:49:49 <lambdabot> f (_, a) b =
20:49:49 <lambdabot>     case b a of
20:49:49 <lambdabot>     (c, d) -> (d, c)
20:49:49 <benzrf> SrPx: there is a 1-step way to do ThatOtherPerson
20:49:50 <benzrf> *that
20:50:00 <benzrf> SrPx: as it stands, you're pairing them, then picking out the second
20:50:05 <ThatOtherPerson> benzrf: There is?
20:50:08 <ThatOtherPerson> I had no idea
20:50:13 <benzrf> ThatOtherPerson: :[
20:50:31 <jle`> heh
20:50:34 <SrPx> but the pairing was so we could make use of what <*> does ... if we just picked "b" then it would completely ignore if "a" was nothing
20:50:42 <benzrf> SrPx: here, i'll tell you :p
20:50:42 <carter> :t (<*>)
20:50:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:50:46 <SrPx> :(
20:50:47 <bb010g> carter: data ZipList' a where { ZipList' :: (a -> a -> a) -> [a] -> ZipList' a }
20:50:50 <benzrf> SrPx: a *> b = const <$> a <*> b
20:50:56 <tertl3-laptop> does st have interpreter?
20:51:09 <bb010g> carter: Sorry about the GADT; I think better in them
20:51:32 <benzrf> SrPx: previously you applied (,) across them, which resulted in pairs in the result. then you fmapped something to drop the 1st element
20:51:34 <carter> bb010g: problem is you then need to make sure that theres agreement on the function
20:51:46 <benzrf> in this case, you're explicitly resulting in the 2nd argument when it gives you 2
20:51:53 <jle`> bb010g: what is your pure?
20:51:56 <benzrf> instead of resulting in a pair of them, then doing a 2nd step
20:52:15 <bb010g> carter: Throw away the inner functions.
20:52:31 <carter> bb010g: how
20:52:33 <tertl3-laptop> can you write an OS in haskell?
20:52:34 <jle`> okay so we can eliminate snd/fst combos that swap the internal order, due to the first monad law
20:52:40 <bb010g> jle`: pure a = ZipList' id (repeat a)
20:52:43 <tertl3-laptop> for virtualbox
20:52:55 <bb010g> :t join
20:52:57 <lambdabot> Monad m => m (m a) -> m a
20:53:28 <tertl3-laptop> where can I find a list of words in the dictionary?
20:53:43 <jle`> tertl3-laptop: i think there was a haskell OS written
20:53:47 <jle`> at least for a p.o.c.
20:54:08 <tertl3-laptop> i know but none that boot on vbox
20:54:13 <jle`> tertl3-laptop: the House project
20:54:14 <tertl3-laptop> or qemu
20:54:24 <bb010g> How would you state data ZipList' a where { ZipList' :: (a -> a -> a) -> [a] -> ZipList' a } as a 98-style type?
20:54:46 <jle`> data ZipList' a = ZipList' (a -> a -> a) [a]
20:54:49 <carter> yup
20:55:19 <jle`> actually i can encode all possible (>>=) implementations by enumerating from which tuple the fst/snd come from
20:55:29 <jle`> > liftA2 (,) [1,2] [1,2]
20:55:31 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
20:55:31 <SrPx> benzrf: okay, I see why that typechecks... still...
20:55:42 <jle`> so those are all the legal implementations that pass the first monad law
20:55:44 <benzrf> SrPx: it's a little mind numbing at first
20:55:48 <benzrf> err
20:55:51 <SrPx> benzrf: I need some time to wrap this around my head now
20:55:52 <benzrf> maybe not mind numbing
20:55:55 <tertl3-laptop> house is old project
20:56:00 <benzrf> SrPx: i dnt blame yo
20:56:00 <tertl3-laptop> i want something new
20:56:01 <benzrf> *you
20:56:01 <bb010g> data ZipList' a = ZipList' { getZipList'Fun :: (a -> a -> a), getZipList' :: [a] }
20:56:40 <SrPx> the fact I'm awake for almost a day doesn't help, but I'm too curious I just can't sleep before understanding that
20:56:51 <bb010g> join (ZipList' f xs) = zipWith f (getZipList <$> xs)
20:56:53 <jle`> (1, 1), (2, 2) fail the second monad law
20:56:54 <bb010g> join (ZipList' f xs) = zipWith f (getZipList' <$> xs)
20:56:58 <jle`> so only (1, 2) and (2, 1) are left
20:57:03 <jle`> now for the third law...
20:57:10 <bb010g> Would that work?
20:57:59 <benzrf> SrPx: :-)
20:58:02 <benzrf> SrPx: well, good luck
20:58:14 <benzrf> SrPx: functors are a bit tricky
20:58:19 <benzrf> applicatives are much harder
20:58:24 <benzrf> monads a bit harder than applicatives
20:58:38 <jle`> bb010g: prove your laws ^_^
20:58:40 <SrPx> thanks (:
20:58:48 <jle`> return a >>= f
20:58:52 <benzrf> but they are all extremely abstract, and in a way that makes them hard to really grasp accurately
20:58:54 <jle`> = f a
20:59:01 <bb010g> jle`: Just started up ghci. :)
20:59:04 <jle`> x >>= return = x
20:59:04 <benzrf> SrPx: your trouble is normal
20:59:09 <jle`> ah, ok :)
20:59:28 <jle`> prove them using logic and equational reasoning
20:59:37 <jle`> and then we'll talk
20:59:51 <jle`> by we i mean you and me, but other people are welcome to comment
20:59:57 <joe9> error: http://codepad.org/eIF2Ch2C code: http://codepad.org/O4LQ26QH . How do I fix that error, please? That code used to compile before. But, since I installed Aeson on my system, it seems to have broken down. Any help, please.
21:00:06 <carter> benzrf: nah, i kinda think monads are easier than applicatives
21:00:51 <jle`> i think everything is weird
21:00:56 <benzrf> carter: oh yeah?
21:00:59 <jle`> we live in a weird world
21:01:13 <benzrf> carter: im telling you, im a big fan of f a -> f b -> f (a, b) as the applicative definition
21:01:20 <tertl3-laptop> thats cool house project OS
21:01:26 <orion> hmm
21:01:27 <joe9> i wish effects become more mainstream.
21:01:27 <benzrf> carter: and i think that in general, that's easier to wrap your head aroung than f (f a) -> f a
21:01:32 <tertl3-laptop> looks like X11
21:01:41 <benzrf> carter: it's an external join instead of an internal one
21:01:46 <orion> How do I force cabal to use the locally installed haddock instead of the system one?
21:01:46 <carter> huh
21:01:54 <orion> haddock: internal error: /usr/local/lib/ghc-7.6.3/html: getDirectoryContents: does not exist (No such file or directory)
21:01:59 <jle`> f (f a) -> f a is useful for understanding the instance, but i don't think it gives as good of an intuition about how to practically use them in programs
21:02:05 <benzrf> jle`: perhaps
21:02:35 <jle`> some things that make perfect sense in f a -> (a -> f b) -> f b form take a little bit more thinking to see in the f (f a) form
21:02:49 <benzrf> jle`: you mean in terms of usage, right?
21:02:54 <benzrf> not in terms of implementation?
21:03:04 <jle`> yeah, implementation is a different story
21:03:08 <benzrf> ok yeah i dont argue that
21:03:28 <benzrf> but i think explaining bind as fmap followed by join is easier to digest than throwing bind in all at once
21:03:43 <benzrf> i could be pretty wrong, i already mostly grokked monads by the time i learned that join <-> bind
21:04:10 <benzrf> i just feel like learning bind as an atom forces you to think about fmap and join at the same time
21:04:21 <SrPx> benzrf: ah! I get it (:
21:04:22 <benzrf> instead of saying 'ok, fmap, i know this, then it joins, hmm how does join work'
21:04:26 <benzrf> SrPx: :-D
21:04:34 <jle`> carter has successfully nerdsniped me
21:04:36 <bb010g> NVM, I forgot about Functor requiring (a -> b) but the zipping function requiring (a -> a -> a) and you can't throw that away without breaking fmap id = id...erg. I need to think more.
21:04:45 <benzrf> carter: with what
21:04:49 <benzrf> * jle`
21:04:57 <carter> my "how do you prove its unique"
21:04:59 <benzrf> oh
21:05:00 <carter> or ot question?
21:05:02 <benzrf> i saw that once
21:05:08 <jle`> proving why you can't have a monad instance for arbitrary sized lists
21:05:12 <benzrf> oh
21:05:16 <benzrf> jle`: wouldnt that break the laws
21:05:19 <jle`> arbitrary fixed size
21:05:26 <benzrf> oic
21:05:28 <benzrf> jle`: how do you know you canta
21:05:30 <jle`> yeah, a lawful monad instance
21:05:30 <benzrf> *cant
21:05:34 <jle`> well i know i can't, by intuition
21:05:38 <jle`> hehe
21:05:40 <benzrf> oh wait
21:05:45 <benzrf> if we're going by []'s join
21:05:53 <benzrf> that's pretty obviously wrong...
21:05:55 <jle`> fixed sized lists
21:05:58 <jle`> yeah
21:06:05 <jle`> hm.
21:06:06 <benzrf> jle`: you mean, proof that there is no instnace?
21:06:13 <jle`> yeah, proof that no lawful instnace can exist
21:06:19 <benzrf> oh man
21:06:22 <jle`> right now i'm thinking through the Stream join
21:06:23 <benzrf> i dont wanna get caught up in that x.x
21:06:32 <benzrf> i wont be able to sleep if i do
21:06:33 <SrPx> benzrf: well at least the how, but not the why. I mean, the information is on applicative. I learned it as an extension of fmap for when you have multiple arguments functions.
21:06:34 <jle`> join for infinite streams
21:06:41 <joe9> What is the difference between `bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString'  and Data.ByteString.Lazy?
21:06:42 <jle`> and it seems to pass the first two laws
21:06:52 <joe9> http://codepad.org/tssGVMUy is the error
21:06:57 <jle`> but the third law is idk
21:06:57 <benzrf> SrPx: it's mostly useful for applicatives that model effects
21:07:02 <benzrf> SrPx: do you know the State applicative yet?
21:07:05 <joe9>  is the code: http://codepad.org/zOCz6478
21:07:28 <SrPx> benzrf: to do it you kinda have to decide how two elements combine, as in, the whole Maybe logic is there, on the applicative instance of Maybe.
21:07:48 <bb010g> Just when I think I know what I'm doing in Haskell, boom. :)
21:07:50 <carter> jle`: you could just prove that theres no instance for size 3
21:07:51 <SrPx> benzrf: what I don't get is why. It is kinda awkward
21:07:58 <carter> and then induct
21:08:20 <benzrf> SrPx: why what exactly?
21:08:21 <jle`> i'm still proving there is no instance for size 2 >_>
21:08:26 <carter> ok
21:08:28 <benzrf> hah
21:08:32 <jle`> i've narrowed it down to two possible implementations of (>>=)
21:08:44 <benzrf> jle`: join, man. join!
21:09:02 <benzrf> SrPx: the why of (*>) or of applicatives in general?
21:09:09 <jle`> (x, y) >>= f = (fst (f x), snd (f y)), and (x, y) >>= f = (fst (f y), snd (f x))
21:09:15 <jle`> those are the only two implementations that don't break the first two laws
21:09:21 <jle`> all other implementations break one fo the first two
21:09:22 <SrPx> benzrf: why not an instance to combine two elements, specificaly? `instance Combine Maybe where Combine Nothing _ = Nothing; Combine _ b = b`... something like that, I don't know.
21:09:41 <benzrf> SrPx: because you can implement that on top of applicative
21:09:52 <benzrf> SrPx: plus, applicative is more powerful than that, iirc
21:10:03 <benzrf> SrPx: you can write (*>) in terms of (<*>), but not vice versa
21:10:13 <benzrf> SrPx: so why not go with the more poewrful one for the class?
21:10:28 <benzrf> SrPx: a functorial analogue is (<$)
21:10:29 <jle`> i always have problems with the third law
21:10:34 <jle`> :|
21:10:42 <jle`> because it has arbitrary f/g
21:10:43 <SrPx> benzrf: so let me ask, I'll still not read about monads, but are them implemented on top of Applicative (do they extract that logic from it) or do they redefine that logic?
21:10:46 <benzrf> SrPx: if you say 'v <$ f', that's equivalent to 'fmap (const v) f'
21:10:47 <SrPx> (for now)
21:10:57 <benzrf> SrPx: they define something that encompasses applicative
21:10:57 <carter> whats the 3rd law again?
21:10:58 <jle`> the first and second law are easy because you always just have return
21:11:03 <nezt> hey all, i feel like i understand concepts in haskell pretty well ... now I just need a good syntax reference... When I go to write code, I forget how things look syntactically . what do you all do in that situation?
21:11:17 <benzrf> SrPx: they redefine parts of it in a sense
21:11:17 <SrPx> so every Monad is an Applicative and a Functor
21:11:23 <benzrf> SrPx: it *should* be
21:11:23 <carter> nezt: i just look at random code
21:11:28 <benzrf> SrPx: but in current versions of ghc it's not
21:11:31 <benzrf> for hysterical reasons
21:11:35 <jle`> (m >>= f) >>= g = m >>= (\x -> f x >>= g)
21:11:36 <nezt> carter: from where?
21:11:46 <dmwit> jle`: I've just joined; are you exploring the type Pair a = (a, a) monad?
21:11:51 <jle`> dmwit: yeah
21:11:54 <SrPx> Uhmm... I see. But in practice they all are?
21:11:59 <benzrf> SrPx: yep
21:12:00 <bb010g> nezt: You could go look at some sources from Hackage
21:12:02 <dmwit> jle`: If so, you may find it enlightening to realize it's the same as the type Pair' a = Bool -> a monad.
21:12:05 <benzrf> SrPx: notice that you can define fmap in terms of pure and (<*>), btw
21:12:11 <dmwit> jle`: Which if you grok Reader is dead simple.
21:12:15 <benzrf> SrPx: it's basically the same with Monad and Applicative
21:12:22 <carter> wait, size 2 has a monad
21:12:22 <jle`> dmwit: i enumerated every possible implementation of (>>=) and eliminated all but two from the first and second laws
21:12:25 <jle`> hm ah. i'l think of that
21:12:31 <SrPx> benzrf: interesting (: yea I noticed that
21:12:35 <jle`> that's smart
21:12:38 <jle`> ^_^
21:12:46 <benzrf> SrPx: Applicative is a a superset of Functor
21:13:06 <carter> jle`: dmwit  so fixed size has a monad you run with the choice of index?
21:13:24 <benzrf> SrPx: and monad, depending on the definition, is a superset of applicative
21:13:35 <carter> or am i not understanidng
21:13:37 <SrPx> I see
21:13:39 <carter> i don't think i'm understanding
21:13:56 <dmwit> carter: I'm not sure I understood your claim well enough to say whether it's right or wrong.
21:14:07 <carter> whats the (a,a) istnace
21:14:14 <carter> defn
21:14:16 <carter> for bind
21:14:19 <jle`> if i follow dmwit 's logic
21:14:29 <jle`> (x, y) >>= f = (fst (f x), snd (f y))
21:14:35 <benzrf> SrPx: still, it's not actually a superclass of functor (yet)
21:14:36 <jle`> is what that line of thinking implies
21:14:40 <benzrf> SrPx: so you get ugly things like liftM
21:14:43 <benzrf> :t liftM
21:14:43 <dmwit> right
21:14:44 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
21:15:04 <benzrf> SrPx: if you have some arbitrary value, and you know it's a monadic value, you SHOULD be able to use fmap on it
21:15:05 <SrPx> so liftM is wrong and I should remember not to use/learn about it?
21:15:07 <jle`> more explicitly following the logic, x >>= f = (fst (fst (f x)), snd (snd (f x)))
21:15:09 <benzrf> SrPx: sort of
21:15:30 <dmwit> carter: (x, y) :: (a, a) is "the same as" \b -> if b then x else y :: Bool -> a
21:15:33 <benzrf> SrPx: since Monad isnt actually a superclass of functor, the compiler doesnt allow you to use fmap on monadic values unless you add a functor constraint too
21:15:46 <benzrf> SrPx: so you have to use liftM if you dont want to add that
21:15:48 <jle`> and if Reader is a monad...then this should check out
21:15:56 <jle`> my mind is blown
21:15:56 <SrPx> benzrf: ah I see
21:15:59 <benzrf> liftM is just fmap written in terms of Monad, same as how you can write fmap in terms of Applicative
21:16:00 <dmwit> carter: So, since join for functions applies the argument twice, join for tuples goes in the "same direction" into the tuple twice.
21:16:03 <bb010g> jle`: Wouldn't it be x >>= f = (fst (f (fst x)), snd (f (snd x)))?
21:16:03 <jle`> mind >>= blow
21:16:09 <carter> ok
21:16:11 <jle`> bb010g: yeah, you're right
21:16:13 <benzrf> jle`: what's the type of Mind?
21:16:13 <jle`> heh
21:16:17 <benzrf> *mind
21:16:21 <jle`> IO Mind
21:16:22 <benzrf> Thought Mind
21:16:24 <SrPx> benzrf: well gotta practice all that now, thank you ! (:
21:16:26 <carter> so this gives monad for rank N  tuples?
21:16:27 <benzrf> SrPx: np
21:16:30 <carter> *size n?
21:16:38 <dmwit> carter: Yes, rank N homogeneous tuples.
21:16:38 <jle`> i guess that's what this is implying
21:16:45 <carter> darn
21:16:46 <solatis> jle`: just sent you an email
21:16:48 <jle`> heck, rank N heterogeneous, too
21:16:53 <jle`> ...right?
21:16:57 <dmwit> I don't think so.
21:16:59 <carter> jle`:  a-> b
21:16:59 <solatis> thanks a lot for your help yesterday
21:17:01 <benzrf> jle`: did i just witness history being made?!
21:17:16 <carter> ok
21:17:25 <jle`> well if there really is even an instance for rank N homogeneous tuples, then...
21:17:26 <bb010g> jle`: I'd think so; you could probably throw together some TH for it
21:17:29 <carter> so for static sized lists, i have to add a monad instance
21:17:30 <jle`> this is literally the Stream instance
21:17:34 <jle`> the Monad instance for Stream
21:17:40 <jle`> applied to fixed length lists
21:17:48 <carter> linky?
21:17:56 <jle`> ...in that sense, Stream is just a degenerate version of a fixed length list where L = infinity
21:18:01 <dmwit> jle`: You might like byorgey's post on representable functors, and how they relate monoids to comonads.
21:18:10 <jle`> :O
21:18:15 <bb010g> "fixed length list where L = infinity" :)
21:18:25 <benzrf> jle`: dude
21:18:28 <benzrf> you're blowin my mind here
21:18:33 <dmwit> jle`: http://byorgey.wordpress.com/2011/05/09/themes-on-streams/
21:18:34 <jle`> "understanding Stream is simple.  just understand a fixed sized container of length L, then set L to infinity."
21:18:41 <carter> jle`: where is this defn
21:18:46 <benzrf> jle`: heh heh, heh heh
21:18:51 <carter> ah
21:18:51 <jle`> it's the diagonalization instance
21:19:06 <jle`> imagine every item of m laid out on the x axis
21:19:15 <shachaf> dmwit: You mean just with the usual (e ->) Comonad instance?
21:19:16 <jle`> fmap f onto every item to go across the y axis
21:19:24 <jle`> the result of join is the diagonal
21:19:29 <shachaf> (Or the instance for something isomorphic.)
21:19:42 <benzrf> SrPx: fyi, mapA is right in your lpaste, and replicateA is almost right except for a minor mistake that has nothing to do with applicatives
21:19:48 <benzrf> SrPx: so if you figure out sequenceA, youre done
21:19:49 <shachaf> Ah. Yes.
21:19:49 <dmwit> shachaf: Monoid e => (e ->), yes
21:19:50 <bb010g> Types aren't lazy, right?
21:20:06 <shachaf> Of course, instance Comonoid e => Monad (e ->)
21:20:11 <benzrf> Cmonoid?
21:20:25 <dmwit> shachaf: right =)
21:20:38 <shachaf> And instance Comonoid e => Comonoid (e,), and instance Monoid e => Monad (e,)
21:20:38 <benzrf> what the heck is a comonoid
21:20:52 <dmwit> benzrf: In Haskell... not much of interest.
21:20:56 <benzrf> hmmm
21:21:10 <benzrf> is it like a monoid but instead of being a II-algebra it's a reverse-II algebra?
21:21:29 <dmwit> Whoops, looks like you just went above my pay grade.
21:21:59 <dmwit> It has to have a split :: a -> (a, a) operation.
21:22:03 <shachaf> dmwit: That's why Chu spaces are the future.
21:22:08 <benzrf> dmwit: thats what i meant
21:22:17 <dmwit> And the laws on split are strong enough that split x = (x, x) is the unique law-abiding instance for every type.
21:22:20 <dmwit> I think.
21:22:26 <shachaf> Yep.
21:22:26 <benzrf> F-algebra for an endofunctor F is a morphism from F A to A
21:22:30 <shachaf> You also have counit :: a -> ()
21:22:37 <jle`> this also gives me my proof that the diagonalizing Stream instance is lawful; Stream a is analogous to Nat -> a
21:22:57 <dmwit> jle`: exactly right
21:23:12 <benzrf> oh wait im not sure II is an isofunctor, i probably misspoke
21:23:17 <jle`> i spent a whole night trying to prove it once >___________>
21:23:18 <jle`> i feel silly
21:23:26 <SrPx> benzrf: just one thing, (*>) is really `(const id) <$> a <*> b` right?
21:23:30 <benzrf> is isofunctor even a word
21:23:34 <shachaf> You get the same deal for monoids when you use Either/Void for your monoidal category instead of (,)/()
21:23:41 <benzrf> SrPx: thats another way to write it yeah
21:23:50 <shachaf> (Where you have the operations unit :: Void -> a and mult :: Either a a -> a)
21:23:50 <benzrf> SrPx: you're mapping 'const id' over a, which puts id into it
21:24:01 <bb010g> Could you actually construct infinity in a type with Nats and type families?
21:24:04 <carter> wait, so i can view it as being the trace
21:24:06 <benzrf> SrPx: then you're applying the 'contents' of a to the 'contents' of b, which is just leaving the latter the same
21:24:11 <SrPx> benzrf: but just `const` doesn't work ): you'd get `a` not `b`
21:24:26 <benzrf> SrPx: oh damn
21:24:29 <benzrf> you're right
21:24:35 * benzrf deducts a point from himself
21:24:49 <SrPx> hmm okay
21:25:03 <benzrf> SrPx: well if you noticed a mistake thats a good sign of understanding
21:25:07 <nezt> All the hackage programs are too complex to get basic syntax in an organized way, anyone have a link to simple programs?
21:25:20 <benzrf> nezt: programs for what
21:25:29 <nezt> that demonstrate easy concepts
21:25:31 <jle`> carter: yeah, actually
21:25:32 <bb010g> nezt: What are you confused on?
21:25:39 <shachaf> nezt: Most introductions to Haskell start with simple programs that demonstrate easy concepts.
21:25:45 <SrPx> thanks, I assumed you had that on purpose
21:25:49 <carter> jle`: well, its the trace of a very funny set of operations
21:25:50 <shachaf> So I'd read one of those.
21:26:01 <jle`> carter: i'm trying to imagine what it would be >_>
21:26:03 <nezt> i'm using lyah right now, do you recommend anything else
21:26:04 <jle`> what operation it would be
21:26:09 <benzrf> SrPx: i honestly didnt
21:26:17 <benzrf> i make that kind of mistake all the time when im not paying attention
21:26:20 <carter> jle`: monad is weird here
21:26:21 <benzrf> :p
21:26:26 <carter> i'll write the instance because its legal
21:26:29 <carter> but i'll never use it
21:26:35 <benzrf> by 'paying attention' i mean pasting it into ghci to make sure it type checks
21:26:38 <bb010g> nezt: RWH isn't bad; you can check out https://github.com/bitemyapp/learnhaskell
21:26:51 <benzrf> i managed to trick myself into thinking const returns its 2nd arg >.>
21:26:53 <jle`> carter: i'm trying to think of an application of it in linear algebra
21:26:59 <benzrf> jeez
21:27:25 <carter> jle`: theres none
21:27:27 <jle`> but to be fair, i can't imagine the applicative instance being useful in linear algebra except for liftA2 (+)
21:27:29 <carter> its just a troll
21:27:30 <benzrf> SrPx: ok, so the fact that you didnt 'figure out' my 'alternative solution' is a good thing
21:27:35 <carter> applicatives are magic
21:27:43 <carter> dont knockem
21:27:54 <jle`> whos gonna stop me
21:27:55 <carter> they give a nice way of lifiting binary operations
21:27:58 <carter> I WILL
21:28:09 <carter> you've gone mad with IRC powah
21:28:19 <carter> the FRP has warped yer minds
21:28:21 <jle`> but how many binary operators in are lifted that way in linear algebra
21:28:34 <dfeuer> michaelt mentioned the pretty fact that L.unfoldr V.uncons will convert a vector to a list. How does that compare to V.foldr L.cons L.nil ?
21:28:48 <dmwit> sums and dot products both involve lifted binary operations
21:28:54 <carter> yup
21:28:59 <jle`> as in, how many a -> a -> a's are lifted to (vector a -> vector a -> vector a) correspond to liftA2/component-wise
21:29:04 <dmwit> I think pointwise multiplication is occasionally a thing for matrices, too.
21:29:05 <jle`> yeah, i mentioned the sum
21:29:11 <carter> jah
21:29:11 <jle`> that's the only thing i could imagine
21:29:17 <carter> jle`: you're not being very imaginative :)
21:29:20 <jle`> people use element-wise multiplcation for matrices?
21:29:30 <carter> people do all sorts of pointwise things
21:29:38 <jle`> thats weird ur all weird
21:29:50 <carter> jle`: i think you're tired
21:29:52 <carter> when does grad schools tart
21:30:00 <carter> you'll need to take a break from IRC for a while when that happens
21:30:02 <jle`> they tart in fall
21:30:08 <dmwit> Heck, multi-dimensional matrix multiplication can be nicely represented by "adding" a dimension, doing pointwise multiplication, then "deleting" a dimension again.
21:30:29 <benzrf> man i realllllllllllllly need to learn linear algebra
21:30:40 <carter> dmwit: the join view?
21:30:45 <carter> db join
21:30:47 <carter> not monad join
21:31:03 <carter> erm
21:31:07 <carter> spell this out more plz :)
21:31:14 <dmwit> Something like that. The details are fuzzy, since I figured it out mostly as a lark a few years ago.
21:31:16 <jle`> join for fixed length lists is the trace
21:31:21 <jle`> which is useful
21:31:29 <dmwit> I have some code lying around here somewhere, that ought to spell it out enough.
21:31:35 <jle`> but i can't imagine what (>>=) would be useful for
21:32:24 <dfeuer> Benzrf, we can start a study group.
21:32:29 <benzrf> dfeuer: hella
21:32:35 <carter> :t (=<<) (=<<)
21:32:36 <lambdabot> Monad m => (m a -> a -> m b) -> m a -> m b
21:32:40 <carter> boo
21:32:43 <benzrf> carter: wut
21:32:46 <jle`> OH OH
21:32:53 <carter> ?
21:33:01 <jle`> join for (m (m (m (m a)))) -> m (m a)
21:33:05 <jle`> join . join
21:33:07 <jle`> that might be useful
21:33:08 <dfeuer> fold that boo.
21:33:10 <jle`> for matrix multiplication maybe
21:33:14 <carter> howe do you define join in terms of bind again?
21:33:14 <jle`> ....
21:33:20 <benzrf> carter: bind id
21:33:21 <jle`> >>= id
21:33:27 <carter> (>>=) id
21:33:28 <carter> ahhh
21:33:29 <jle`> (       )
21:33:31 <bb010g> :t join . join . join
21:33:32 <lambdabot> Monad m => m (m (m (m a))) -> m a
21:33:32 <jle`> no, (>>= id)
21:33:33 <dmwit> carter: http://lpaste.net/108338
21:33:55 <jle`> hm.
21:33:57 <dmwit> carter: matrixMult is the piece of interest
21:34:19 <carter> dmwit: thanks
21:34:24 <carter> i'll look at it after i slelp
21:34:38 <jle`> if you can think of a matrix multiplication as an element-wise fmap and join
21:34:40 <jle`> that would be neat
21:34:45 <jle`> ...(does that even make sense?)
21:34:47 <jle`> ...(it might not)
21:34:53 <dmwit> carter: Roughly: copy clones a matrix along an additional dimension.
21:34:57 <dfeuer> Carter sleeeeeep.
21:35:09 <dmwit> carter: e.g. we can turn an X x Y x Z matrix into an X x W x Y x Z matrix
21:35:15 <carter> first one to add the monad instance to my lib for Shape gets a cookie
21:35:20 <dmwit> carter: by having a copy of the matrix at each W index
21:35:25 <carter> dmwit: neat
21:35:39 <carter> dmwit: i'm not awake enough to think deeply right now
21:35:46 <dmwit> carter: Then pointwise multiplication, followed by a sum-fold along the cloned dimension, corresponds exactly to matrix multiplication.
21:36:18 <carter> oh
21:36:22 <dmwit> carter: So, to multiply an M x N and N x P matrix, we make them both M x N x P first.
21:36:24 <carter> so 2 3-d ararays
21:36:26 <carter> one rotated
21:36:28 <dmwit> yes
21:36:29 <carter> then pointwise product
21:36:36 <carter> then collapse
21:36:38 <dmwit> right
21:36:41 <dfeuer> Carter, are you attempting to teach while you sleep?
21:36:42 <carter> thats simpler
21:36:46 <dmwit> Really naive, inefficient, etc.
21:36:52 <orion> hmm
21:36:52 <dmwit> but beautiful =)
21:37:02 <carter> dmwit: the implementation? yes, the idea, kinda cute
21:37:11 <carter> like, thats arelly neat declarative spec
21:37:17 <dmwit> exactly
21:37:21 <dmwit> I would never push it as anything more than that.
21:37:22 <benzrf> @src ap
21:37:23 <carter> gives you room for all sorts of implicit reduction strategies
21:37:23 <lambdabot> ap = liftM2 id
21:37:26 <benzrf> right...
21:37:33 <carter> dmwit:  have you looked at my numerical array lib yet
21:37:34 <carter> ?
21:37:37 <orion> I just compiled some documentation with haddock, but I noticed that in the generated documentation, the source for certain types is in a different module fromt he one I am currently viewing.
21:37:41 <orion> Does anyone know why this happens?
21:37:42 <dmwit> Nah. I'm not really interested in that stuff.
21:37:50 <carter> dmwit: its just a really cool array lib
21:37:50 <dmwit> This was just a weekend curiosity, nothing more.
21:37:52 <carter> you can add new formats
21:37:53 <bb010g> @src liftM2
21:37:54 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:37:59 <carter> and theres some neat geometry
21:38:10 <dmwit> Perhaps there will come a time when I need it, and then I will know where to go. =)
21:38:18 <carter> heh
21:38:26 <carter> dmwit: have a skim some time
21:38:34 <carter> you'll at least find the api engineering novel
21:38:34 <carter> ish
21:38:38 <carter> you can tell its an array lib
21:38:46 <carter> but not in  style you'll have ever seen
21:40:29 <carter> night all
21:41:28 <bb010g> carter: Night
21:43:04 <dfeuer> carter: I figured out why your concerns about code explosion are wrong in the situations under discussion yesterday.
21:43:18 <dfeuer> (I think)
21:43:38 <dfeuer> BBIAB.
21:45:07 <johnw> does anyone know what the difference is at ICFP between "Haskell (Day 1)" and "CUFP Tutorial Day 1"?  They both cost the same, but I don't know if they overlap or not
21:46:14 <sclv> one is the haskell symposium
21:46:23 <sclv> the other is a tutorial session at cufp
21:46:28 <sclv> you’ll probably want the symposium
21:46:38 <johnw> ok, the first one
21:46:40 <sclv> but with a badge nobody cares where you go :-)
21:46:58 <l0cust> johnw: what are we talking abou?
21:47:02 <johnw> ICFP 2014
21:49:54 <l0cust> johnw: eww it's in sweden
22:03:40 * hackagebot egison 3.3.9 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.9 (SatoshiEgi)
22:07:17 <SrPx> benzrf: http://lpaste.net/108335 (:
22:07:51 <benzrf> SrPx: sweet
22:07:56 <SrPx> seems like it is correct, I'm still not sure what mapA does, but I guess I deserve a sleep at this point
22:08:00 <SrPx> thank you !
22:08:13 <benzrf> no prob
22:08:30 <SrPx> good night (:
22:08:41 <benzrf> night m8
22:12:11 <ReinH> sclv: ICFP yay! Have fun!
22:12:17 <ReinH> johnw: also have fun
22:12:24 <benzrf> i am sleeping now
22:12:28 <ReinH> I'll see you when it comes back to the states
22:12:31 <johnw> ReinH: thx :)
22:12:47 <benzrf> bye
22:16:40 <Sornaensis> hello
22:27:28 <orclev> Is the WordPtr type impossible to use for FFI now? It doesn't seem like it exports a constructor so it seems like it would be impossible to use for FFI now
22:33:58 <johnw> use PtrToWordPtr
22:35:33 <orclev> the problem is that I can't use WordPtr in the FFI declaration, it barfs because there's no constructor in scope for it
22:44:22 <ruzu> mo' nads
22:45:24 <davidfetter> shouldn't there be two apostrophes in that?
22:54:07 <nezt> How many haskellers drink in moderation? does moderate ethanol consumption increase or reduce haskell abilities
22:54:40 <Walther> There should probably be a study on that! With free beer, of course.
22:55:31 <Hafydd> My unscientific belief is that value-level programming is improved by alcohol, but perhaps not type-level programming./
23:01:01 <kini> jle`: that blog post you linked on /r/haskell earlier is great!
23:01:30 <pharaun> testing yet for ballmer peak yet?
23:03:46 * hackagebot xml-pipe 0.0.0.5 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.5 (YoshikuniJujo)
23:06:22 <codygman> I get the feeling I should be using something else to do this: maybe (error "No arguments provided") id (headMay args). Not just for command line parsing, but for other things as well.
23:07:01 <kini> (there is a whole cmdargs library for command line argument processing, if you want to go that route)
23:07:28 <Cale> Several of them :)
23:07:39 <codygman> kini: I'm familiar with that, but was wondering about the patter of throwing an error on Nothing/providing value on Just.
23:07:46 <codygman> pattern*
23:07:47 <johnw> how interesting that someone created simple-pipe
23:07:50 <johnw> it's like it's in the air
23:08:13 <Cale> optparse-applicative, System.Console.GetOpt
23:08:17 <lfairy> codygman: try fromMaybe
23:08:23 <kini> Cale: what's your favorite? :)
23:08:26 <lfairy> > fromMaybe (error "ducks") Nothing
23:08:28 <lambdabot>  *Exception: ducks
23:08:38 <lfairy> > fromMaybe (error "ducks") (Just "geese")
23:08:39 <Cale> I don't really know. They're all okay.
23:08:39 <lambdabot>  "geese"
23:13:00 <joelteon> simple-pipe doesn't even use the pipes operators
23:24:27 <benzrf> joelteon: http://lpaste.net/106669
23:24:56 <joelteon> what's that
23:25:41 <benzrf> core o pipes in 80 lines
23:26:29 <angerman> Is there any haskell activity in Kuala Lumpur?
23:26:49 <d3m1g0d-> guys are those syntaxes similar ? data Mydata = .... deriving (MyTypeclass) and data Mydata
23:26:56 <d3m1g0d-> isnstancce MyTypeclass Mydata where ...
23:27:29 <angerman> d3m1g0d-, if ghc *can* derive the typeclass, yes.
23:27:40 <Hafydd> Syntatically, they don't look similar to me at all.
23:27:48 <Hafydd> *Syntactically
23:34:41 <dreixel> @seen bytter
23:34:42 <lambdabot> BY77er
