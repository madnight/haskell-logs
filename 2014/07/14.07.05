00:08:45 * hackagebot ghc-imported-from 0.2.0.6 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.2.0.6 (CarloHamalainen)
00:08:45 * hackagebot bloomfilter 2.0.0.0 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-2.0.0.0 (BryanOSullivan)
00:35:32 <codygman> Shouldn't using overloaded strings make this code work? http://lpaste.net/106954
00:38:50 <jle`> :t (++)
00:38:51 <lambdabot> [a] -> [a] -> [a]
00:38:55 <jle`> ^^ codygman
00:39:19 <codygman> Ah
00:39:43 <jle`> note that the error wasn't about it not being a string but about it not being a list :)
00:50:07 <tolt> Does anyone have any good articles on applicative parsers?
00:53:18 <lfairy> I'm thinking of adding a field to a package's Hackage page
00:53:30 <lfairy> which summarizes all the build reports submitted for it
00:53:43 * hackagebot peyotls 0.0.0.20 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.20 (YoshikuniJujo)
00:53:43 <lfairy> What's a good name for that field?
00:53:49 <lfairy> "Buildability?"
00:54:43 <lfairy> okay, I'm calling it "buildability" for now
01:12:59 <tolt> Is there any good way to parse datetime?
01:13:22 <bitemyapp> tolt: which format? If it's a common one - yes probably.
01:13:35 <tolt> "Sat Jul  5 03:41:55 UTC 2014"
01:14:03 <tolt> Also, thanks for the haskell resources
01:14:15 <bitemyapp> tolt: http://en.wikipedia.org/wiki/ISO_8601 http://hackage.haskell.org/package/iso8601-time-0.1.1/docs/Data-Time-ISO8601.html https://www.google.com/search?sourceid=chrome-psyapi2&ion=1&espv=2&ie=UTF-8&q=parse%20date%20Haskell
01:14:47 <tolt> Thanks. I didn't know what format it was in.
01:29:49 <fyolnish> https://gist.github.com/fjolnir/3586bb1da97fdefd7183 <- can someone explain to me why this is ill typed?
01:30:48 <pavonia> Node 2 Nothing Nothing is not of type Maybe (Tree a)
01:30:59 <fyolnish> ah
01:31:00 <fyolnish> Just
01:31:13 <ninja_code> erlang has riak. Has anyone managed to implement anything database-ish (besides just bindings to existing databses) in Haskell ? Or is Haskell fundamentally bad for implementing dbs.
01:31:14 <fyolnish> thanks :)
01:31:43 <fyolnish> I was looking for the error inside the "(Node" parens for some reason
01:35:39 <lfairy> ninja_code: acid-state is really cool
01:35:48 <slomo> ninja_code: you mean accessing existing database systems, or writing one in haskell? for the latter, acid-state implements something like that for a few use cases. for the former, you'll find lots of different libraries for that, that provide all kinds of APIs for database access
01:36:10 <ninja_code> I don't wnat bindings to existing databases
01:36:17 <ninja_code> I want to see what code for writing a db in haskell looks like
01:36:24 <ninja_code> regardless of whether its' sql, no sql, consistent, or eventually consistent
01:38:14 <tolt> ninja_code: It's still a major work in progress but I've been working on a timeseries db at work for a little while
01:43:02 <ninja_code> tolt: actually, I feel that all databases, in the end, reduces to distributed logging
01:43:26 <tolt> ninja_code: Explain a little bit more?
01:43:40 <ninja_code> nope
01:43:43 <ninja_code> that's where my thought train ends
01:44:41 <tolt> Alright. Sounds good.
02:21:55 <ninja_code> so I pour out a bowl of cereal
02:22:08 <ninja_code> get themilk from the fridge, and suddenly: see expiration date, june 29th :-(
02:22:29 <ninja_code> err, wrong channel, sorry
02:24:17 <chrisdone> ninja_code: first world problems
02:24:35 <ninja_code> this is all haskells' fault
02:24:39 <ninja_code> for not having dependent types
02:24:57 <ninja_code> you can define "pour :: Cereal -> Milk -> Food"
02:25:13 <ninja_code> but what you reall want to define, is a de[pdently typed Milk, which as an expiration date, and have it depend on the current time
02:27:32 <nexx> in Haskell Milk does not expire
02:28:03 <nexx> it is immutable
02:29:14 <ninja_code> lol
03:13:38 <slomo> is there some optimization inside ghc at compile or runtime that will reuse and modify data structures if possible? like when i have a Data.Map and "modify" it by inserting a new value, and nothing else in my code is still using the old map without the value. i guess that might be a bit tricky because of lazyness (there might be some unevaluated thunks that still contain the old map and i don't know about that)
03:20:36 <ninja_code> anyone here
03:20:37 <ninja_code> doing a startup in haskell?
03:20:55 <pjdelport> slomo: The old stuff will be GCed if nothing refers to it.
03:21:59 <pjdelport> (unevaluated thunks that still refer to the old value are seen by the GC, just like any other kind of reference)
03:23:58 <ski> slomo : Clean, which also uses laziness in its implementation, actually does reuse old, from now on unused, data structures like that, in case they're (known to be) unique. it has a type system which helps with that
03:25:55 <slomo> ski: thanks, so ghc does not know and can't possibly do that? i would assume you could implement something like that with reference counting internally
03:26:12 <slomo> pjdelport: sure but that means that a possibly very large map is copied just to insert a single value
03:27:29 <pjdelport> slomo: Nah; Data.Map and most similar structures are trees, so only the nodes that get changed during rebalancing actually change.
03:27:43 <bollu> is it safe to kill cabal while it's building?
03:27:47 <bollu> or does stuff go into limbo?
03:28:00 <bollu> I was building elm but now I've changed my mind >_<
03:28:17 <pjdelport> slomo: Everything else stays shared, to whatever extent is possible. (In particular, the values will all stay shared, even if large portions of the tree gets restructured as part of balancing.)
03:28:23 <slomo> pjdelport: ah of course... makes sense :)
03:28:30 <ski> slomo : it has no type system to help with that (even only internally used), afaik. however there might be analyses it could possibly pull off to determine when datums are no longer live, so it then could generate code to deallocate it (Compile-Time GC, CTCG), or reuse when constructing new ones
03:28:59 <ski> slomo : i know the melbourne mercury compiler has experimented a bit with such analyses, at least
03:33:55 * hackagebot xml-html-conduit-lens 0.3.2.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.3.2.0 (MatveyAksenov)
03:49:17 <__mb> hi, why is the word `section`used to qualify partial application of infix operators ?
03:51:50 <_0xAX> Hello all
03:52:28 <ski> __mb : i'm not sure
03:53:09 <_0xAX> Yesterday i updated ghc to 7.8.2 and cabal and met cabal hell after it, how do you update ghc with cabal, maybe is there right way to do it avoiding many problems with deps?
03:53:18 <ion> Probably because you can section (a + b) into (a +) and b or (+ b) and a.
03:54:10 <insejn> Is there a way to change the following code to not have to include the additional type annotation in the last line of input: http://lpaste.net/106957 (namely `:: (Maybe Int)`)
03:54:21 <ion> 0xax: Whenever i upgrade GHC i also start with a fresh .cabal, and i also use cabal sandboxes for all projects.
03:55:58 <ion> insejn: Define an alternative to fromInteger which is monomorphic or something.
03:56:02 <ski> if i'd speculate, i might say what ion said, or perhaps if you think of `(+)' in terms of its graph, which can be visualized as a surface, then `(a +)' (and `(+ b)') would have graphs that are the curves you get by intersecting (sectioning) the surface with a plane parallel to the applicate axis, and also to the ordinate or abscissa axis (respectively), cutting that latter axis at `a' resp. `b'
03:56:17 <ski> __mb ^
03:56:24 <jle`> insejn: your code works fine, it's your ghci call that's tricky
03:56:45 <jle`> you might want to turn off the monomorphism restriction if you haven't already
03:57:07 <insejn> jle`, ion: thanks!
03:57:09 <jle`> note that this error will pop up with any type
03:57:23 <jle`> er, any Num instance
03:57:37 <jle`> hm
03:57:39 <__mb> ok, thanks ski & ion
03:57:47 <ski> insejn : is this `Prelude.Num' or a custom defined one ?
03:58:11 <insejn> ski: custom
03:58:31 <insejn> sry, i should’ve mentioned that upfront
03:58:37 <jle`> oh that does explain a lot
03:58:49 <ski> __mb : see <https://en.wikipedia.org/wiki/Cartesian_coordinate_system> for "abscissa","ordinate","applicate", if you haven't seen those terms before
03:58:58 <jle`> insejn: yeah, there's no way for ghc to know what type you want
03:59:01 <jle`> it's like read
03:59:25 <jle`> if you've ever used read
03:59:29 <ski> insejn> :t fromInteger
04:00:07 <jle`> you have to let it infer what type it is you want to read into...what type it is you want.  in normal haskell code, this usually isn't necessary, because later on you will end up using it somewhere in a way that ghc can figure out what type you want
04:00:16 <k0ral> In the persistent package, the module Data.Persistent.TH no longer exists; all tutorials I found make use of this module; is there any resource that explain how to do with the new API ?
04:00:26 <jle`> but in ghci, ghc can't travel forward in time to find out how you will use it
04:02:00 <_0xAX> ion: thanks for reply, i'm new in haskell, what does it mean fresh .cabal? are you just removing it before upgrading or something else?
04:03:43 <insejn> jle`: so what makes the Prelude.fromInteger special so that it works fine in ghci: http://lpaste.net/106957
04:05:01 <jle`> insejn: defaulting rules
04:05:06 <jle`> for the typeclass
04:05:19 <jle`> you should be able to have your own custom Num work the same way if you add in defaulting rules i think
04:05:32 <ski> insejn : btw, i'd "eta-reduce" (really use extensionality) on that definition of `fromInteger'
04:05:59 <insejn> ski: yep, good idea
04:06:03 <ninja_code> for haskell data structures, I can magically, autoatically, derive Show
04:06:12 <ninja_code> is there a way to automaticallyd erive toJSon and fromJSon ?
04:06:14 <jle`> ...i don't know the syntax for adding defaulting rules
04:06:29 <insejn> jle`: ok fair enough, i’ll look it up if it’s possible to define those rules, thanks
04:06:44 <jle`> ninja_code: you should be able to; it should be in the documentation for aeson
04:07:01 <jle`> it's done with either generics or TH, not sure which
04:07:04 * ski believes the work ninja_code was searching for was "automagically"
04:07:17 <Pythonfant> ninja_code: http://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson.html
04:07:19 <Pythonfant> look for generic
04:07:54 <jle`> https://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson-TH.html
04:08:11 <Myriam21>  You can find funny videos here. http://bitly.com/1mtSoTT
04:08:23 <jle`> i think generics is probably better
04:08:44 <jle`> https://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson-Generic.html
04:08:45 <ninja_code> hmm
04:08:57 * hackagebot twitter-conduit 0.0.5.2 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.2 (TakahiroHimura)
04:08:59 <jle`> oh there is a red text warning on the latter
04:09:20 <Pythonfant> well this doesn't concern ghc generics
04:09:40 <jle`> oh yeah
04:09:43 <jle`> here it is
04:10:10 <jle`> data Coord = Coord { x :: Double, y :: Double } deriving Generic
04:10:15 <Pythonfant> exactly
04:10:17 <jle`> instance ToJSON Coord
04:10:19 <jle`> voila
04:10:25 <ninja_code> wtf
04:10:34 <ninja_code> burn jle` at the stake for magic
04:10:44 <ninja_code> how does this work?
04:10:45 <jle`> same thing works for Data.Binary
04:10:56 <ninja_code> what is going on
04:11:04 <jle`> when you derive Generic you basically derive some sort of reified structure for your data type
04:11:14 <jle`> so the ToJSON instance can just look at it
04:11:14 <Pythonfant> http://www.haskell.org/haskellwiki/GHC.Generics
04:11:18 <ninja_code> here's my confusion:
04:11:23 <ninja_code> to make this work, the compiler has to do some work
04:11:27 <ninja_code> however, the compiler knows nothing about json
04:11:33 <ninja_code> so how the fuck can it auto magically derive json for me?
04:11:35 <jle`> the only thing the compiler does is Generic
04:11:42 <ski> but `ToJSON' knows about `Generic'
04:12:01 <jle`> Generic gives a data type for aeson to use to write its toJson stuff
04:12:32 <ski> (or rather, the default implementation of `ToJSON', presumably, knows about how to inspect the `Generic' thing for a datum, and use that to generate the JSON in question)
04:12:41 <jle`> Show gives you a String; Generic gives you an object (data) representing the structure of your data type
04:13:13 <ski> (`Show' also takes care of precedence levels)
04:13:35 <ninja_code> alright
04:13:41 <ninja_code> looks like I should just stfu and read http://www.haskell.org/haskellwiki/GHC.Generics
04:14:07 <ion> 0xax: Yeah, i delete ~/.ghc and ~/.cabal right before installing a new version of GHC (which i incidentally install into ~/.ghc but that may not be the best choice for you).
04:14:18 <jle`> ninja_code: like in Coord, it might be something like ADT "Coord" [Constr "x" typeDouble, Constr "y" typeDouble] ----- it's not actually like that, but it should give you the idea that it just creates a normal data type based on your data...and it would be easy to make a json encoder that uses such a thing
04:14:39 <ph88> how should the main function be declared ?
04:14:46 <jle`> ph88: main = ...
04:14:49 <ion> main is not a function.
04:14:54 <jle`> main :: IO ()
04:15:42 <ph88> what to do about this ? http://pastebin.com/r8fzhF6H
04:16:05 <ph88> oh what's ::  and IO ?
04:16:07 <Pythonfant> ph88: what do you want to do?
04:16:10 <Pythonfant> print the result?
04:16:17 <ph88> yes, print 4
04:16:32 <Pythonfant> so write print (doubleMe 2)
04:16:47 <ion> ph88: “4” is not a valid IO action. main needs to be an IO action. Given “print :: Integer -> IO ()” you can make “main = print (doubleMe 2)”
04:16:49 <Pythonfant> doubleMe 2 ist just an Integral
04:17:01 <ph88> Pythonfant: src/Main.hs@3:1-3:19Parse error: naked expression at top level ✖print :: Integer
04:17:19 <Pythonfant> ph88: main = print (doubleMe 2)
04:17:24 <ph88> ok ok
04:17:39 <ph88> nice !
04:17:40 <ph88> thx guys
04:17:43 <Pythonfant> np
04:17:46 <ion> ph88: Have you seen LYAH? It’s rather nice for learning.
04:17:48 <ion> @where lyah
04:17:48 <lambdabot> http://www.learnyouahaskell.com/
04:17:58 <ph88> yes i'm on that page now
04:18:06 <ph88> but at getting started it doesn't cover main
04:18:30 <Pythonfant> yep io is covered later
04:18:54 <ph88> what if i want to do two function calls to doubleMe and print them both ?
04:18:59 <ski> ph88 : `something :: SomeType' means that `something' (which may be a variable, or an expression) has type `SomeType'
04:19:25 <ion> main = do { print (doubleMe 2); print (doubleMe 3) }
04:19:27 <ph88> so i can put main as type IO
04:19:27 <jle`> ph88: print x gives you an IO (), right?  that's an IO action that prints something.  it's a normal object
04:19:33 <pjdelport> ph88: The way to think of it is that IO actions themselves are values: "IO x" is a *value* meaning an IO action that will result in an x.
04:19:38 <jle`> print y also gives you another IO ()
04:19:47 <jle`> you can combine/sequence IO actions with the (>>) function
04:20:06 <ski> ph88 : `main :: IO ()' there is a type signature, declaring that `main' is expected to have the type `IO ()', which means that it's an "I/O-action" (yielding a value of type `()' when executed, iow not yielding an interesting value at all, only the effects of executing it is generally interesting here)
04:20:09 <jle`> main = print (doubleMe 2) >> print (doubleMe 3)
04:20:34 <jle`> you can also do main = io1 >> io2
04:20:42 <jle`> where io1 = print (doubleMe 2)
04:20:50 <jle`>       io2 = print (doubleMe 3)
04:20:55 <ski> ph88 : if you want to, you could prepend the defining equation of `doubleMe' with a type signature, like e.g.
04:21:00 <ski>   doubleMe :: Integer -> Integer
04:21:11 <ph88> ok slow down :D
04:21:21 <ph88> im gonna read the book a bit more first
04:21:41 <jle`> you can always just play around with it on ghci :)
04:21:49 <ph88> https://www.fpcomplete.com/project/49375/QBMTBAuUFu
04:21:52 <jle`> but yes read the book, it should give you instructions on how to deal with this
04:21:53 <Pythonfant> ski: doubleMe :: Num a => a -> a should be enough, right? :P
04:22:04 <ski> ph88 : which would in this case declare that `doubleMe' is expected to be a function that will accept values of type `Integer' as input (i.e. integers), and will compute values of type `Integer' as result (one for each time it is called)
04:22:14 <ski> Pythonfant : yes, but that's more complicated
04:22:18 <ion> pythonfant: No need to complicate things with polymorphism just yet.
04:22:23 <Pythonfant> yep sry
04:23:38 <ski> (pjdelport : picking nits, it's the type of such value, it's not itself such a value)
04:24:08 <ion> ph88: Btw, when writing a do block on multiple lines indented like you did in that link, you can remove the { ; } characters.
04:24:19 <ph88> oki
04:24:29 <ph88> ion: no that doesnt work
04:24:40 <ski> ph88 : it does, if you indent it properly
04:24:42 <pjdelport> ski: Right, right. :)
04:24:52 <ph88> ski: i just used 2 spaces
04:25:12 <pjdelport> ph88: It needs to be indented at least as much as the "do" keyword itself.
04:25:21 <ski> pjdelport : just wanting to be extra careful with terminology with newbies, to not needlessly confuse them by muddling things which really are separate :)
04:25:22 <ion> What i see at the moment in https://www.fpcomplete.com/project/49375/QBMTBAuUFu should parse without the { ; }.
04:25:54 <ph88> o_O
04:26:01 <ph88> ion: can you pastebin what you think should work ?
04:26:24 <ski>   main = do print (doubleMe 2)
04:26:25 <ski>             print (doubleMe 3)
04:26:26 <ski> or
04:26:35 <ph88> with brackets ?
04:26:39 <ski>   main =
04:26:46 <ski>     do print (doubleMe 2)
04:26:50 <ski>        print (doubleMe 3)
04:26:51 <ski> or
04:26:54 <ski>   main = do
04:26:58 <ski>     print (doubleMe 2)
04:26:59 <ski>     print (doubleMe 3)
04:27:12 <ski> are common styles of indenting a `do'-expression
04:28:05 <ph88> nice nice
04:28:12 <ph88> like python
04:28:22 <ski> the important point is that the start of the commands after the `do', here `print (doubleMe 2)' and `print (doubleMe 3)', are aligned, and that any subsequent lines that belong to the whole declaration (here of `main') is indented more than the start of the whole declaration
04:29:08 <ski> (so one couldn't place the `do' directly under `main' here, with the `d' under the `m')
04:29:31 <ph88> oki
04:29:49 <ph88> is prepending to list a small O operation ?
04:30:12 <ph88> because in other languages prepending takes a lot more then appending
04:30:15 <pjdelport> ph88: https://en.wikibooks.org/wiki/Haskell/Indentation has some more on the topic
04:30:36 <pjdelport> ph88: Yeah, (:) is constant-time.
04:30:56 <haasn> talking about time complexity in Haskell takes great care
04:30:59 <ski> if you want to try the `where'-thing jle` suggested, then the `where' must also be indented more than the start of the whole direction, and the "subservient" declarations after the `where' (here of `io1' and `io2') must be indented so that their starting character aligns
04:31:10 <Eelis> ph88: depends on which container you use in those other languages. for example, in C++, prepending an element to a std::list does /not/ take more than appending
04:31:20 <haasn> (++) can exhibit O(1), or O(n), or O(n²) behavior, depending on what you're doing and how you're measuring
04:31:39 <pjdelport> ph88: Haskell lists are linked lists, chained together by (:), so you usually work from the front of the list; it's appending that's slow.
04:31:41 <haasn> But [] is fundamentally similar to a linked list
04:31:43 <ion> Prepending an element to a linked list (given a handle of some kind to its start) is O(1) in any language.
04:32:24 <ski> haasn : by itself `xs ++ ys' is `O(n)', where `n' is the length of `xs' -- assuming you want to see the whole resulting list (if you just want to see the start, e.g., it can be less)
04:32:36 <ph88> didnt know it was a linked list, i thought it was like an array
04:33:09 <ski> (a specific *use* of `(++)' in a loop can easily be `O(n²)', when one'd intuitively expect `O(n)' though, yes)
04:33:24 <haasn> ski: Yes, that sounds like a solid way to state things
04:33:26 <ski> ph88 : there are arrays as well, if you need them
04:33:54 <ph88> [1,2]:[3,4] can i prepend a list to a list ?
04:33:58 <ski> no
04:34:04 <haasn> Yes in general, no in your example
04:34:11 <ski> > [1,2]:[3,4]                            :: [Integer]
04:34:12 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
04:34:12 <lambdabot>              with actual type ‘[t0]’
04:34:15 <ion> @type (:)
04:34:16 <lambdabot> a -> [a] -> [a]
04:34:23 <ph88> i would guess so with a linked list
04:34:25 <ski> @type (++)
04:34:26 <lambdabot> [a] -> [a] -> [a]
04:34:26 <haasn> ph88: You can have lists of lists, but that is separate from something like [1,20++[3,4]
04:34:27 <ski> > [1,2] ++ [3,4]
04:34:28 <lambdabot>  [1,2,3,4]
04:34:29 <haasn> err [1,2]
04:34:50 <ion> > [1,2]:[[3],[4]]
04:34:50 <ski> ph88 : so, you can prepend a list, but you must use `++'
04:34:51 <lambdabot>  [[1,2],[3],[4]]
04:34:58 <ph88> oki
04:35:03 <ski> also what ion said :)
04:35:07 <pjdelport> @src []
04:35:07 <lambdabot> data [] a = [] | a : [a]
04:35:11 <ion> Note how [1,2] has the same type as [3] and [4] that are inside another list.
04:35:36 <haasn> > 1:2:[3,4]
04:35:38 <lambdabot>  [1,2,3,4]
04:35:46 <ski> > 1:(2:[3,4])
04:35:48 <lambdabot>  [1,2,3,4]
04:35:52 <pjdelport> ph88: in plainer syntax, you can think of that as: data List a = Nil | Cons a (List a)
04:36:05 <pjdelport> ph88: (:) is cons
04:36:28 * ski isn't sure whether ph88 has yet seen how to declare new data types
04:36:31 <pjdelport> (If you're familiar with Scheme / Lisp at all, it works pretty much the same way.)
04:36:48 <ph88> ski: aList = [1,2,3]  <-- im here now :P
04:37:19 <ski> ph88 : yes :) .. which doesn't answer my quesion (though it does strongly hint at an answer ;)
04:41:02 <mayski> anyone know if there exists a Haskell wrapper for the VISA library?
04:41:43 <int3__> @pl (\f a b c d e -> f d e a b c)
04:41:43 <lambdabot> ((((flip . (flip .)) .) . flip . (flip .)) .) . flip . (flip .)
04:43:17 <Pythonfant> definitly more readable than the non pointfree (is there a better word for this?) version
04:43:46 <pjdelport> Pythonfant: "Pointful", usually
04:43:52 <Pythonfant> k
04:43:59 <pjdelport> or pointy :)
05:09:58 <ninja_code_> is there a way to install ghc 7.8.2 from cabal ?
05:10:08 <ninja_code_> i.e. I want to do someting like "cabal install get-me-the-fucking-latest-ghc-please"
05:18:51 <XssBite> Hii all
05:19:43 <_0xAX> finally i installed ghc-7.8.2 and new cabal, removed old ghc before it
05:19:44 <gfixler> Given addThree a b c = a + b + c, how could one map addThree [[1,2,3], [3,4,5], etc]]? In Clojure I'd use apply to turn the sublists into arguments.
05:19:47 <_0xAX> ion: thanks for help
05:20:09 <XssBite> Heh guys
05:20:15 <XssBite> Wassup
05:20:37 <ski> map (\[a,b,c] -> mapThree a b c) [[1,2,3], [3,4,5], etc]
05:20:59 <gfixler> so simple - thanks, ski
05:21:15 <ski> that's error out if any element list doesn't have three elements, though
05:21:26 <ski> s/that's/that'll/
05:21:33 <gfixler> right, but that's okay for now
05:21:34 <ski> another option is
05:21:49 <ski>   [mapThree a b c | [a,b,c] <- [[1,2,3], [3,4,5], etc]]
05:22:04 <ski> this will simply drop (ignore, filter out) any element lists of the wrong length
05:22:39 <ski> @let addThree a b c = a + b + c
05:22:40 <gfixler> right - I'm in chapter 6 of LYAH, and I do simple things like this in Python all the time, but it's taking time for it to sink in in Haskell.
05:22:42 <lambdabot>  Defined.
05:22:56 <ski> @let etc = [6,7]
05:22:57 <lambdabot>  Defined.
05:23:02 <ski> > [mapThree a b c | [a,b,c] <- [[1,2,3], [3,4,5], etc]]
05:23:03 <lambdabot>  Not in scope: ‘mapThree’
05:23:10 <ski> er, right
05:23:13 <ski> > [addThree a b c | [a,b,c] <- [[1,2,3], [3,4,5], etc]]
05:23:15 <lambdabot>  [6,12]
05:23:18 <gfixler> hehe
05:23:49 <gfixler> It was completely okay with the bare word etc?
05:23:56 <ski> however, if all your element lists have three elements, you may want to consider using triples (or maybe a custom data type) instead
05:24:08 <ski> `etc' is just a variable name here :)
05:24:16 <ski> (i defined it above)
05:24:17 <gfixler> oh, right
05:24:23 <gfixler> sneaky
05:25:25 <gfixler> Haskell has felt very different than the other 20 or so languages I've learned (Python, Perl, Ruby, Clojure, a bit of C/C++, Assembly, etc)
05:25:38 <gfixler> something about it feels so formal and distant, even though it's been very fun and eye-opening
05:25:50 <ski> perhaps that's because it's a different programming paradigm (the functional programming one)
05:25:55 <gfixler> I'm not sure exactly why, but there's a kind of clinical feel to it.
05:25:57 <gfixler> that may be it
05:26:01 <FireFly> Probably
05:26:09 <gfixler> but I've been playing functionally for awhile in Python and Clojure
05:26:23 <ski> laziness also has its flavour
05:26:23 <gfixler> not to any great degree, but there's something distinctly different in Haskell
05:26:29 <gfixler> it's probably just mental
05:26:29 <ski> as does a good static type system
05:26:56 <gfixler> I think in Python I feel like I'm slopping about, hoedown style - it's felt very loose and playful
05:27:15 <gfixler> Haskell has felt very important, and like I need to carefully craft, and be on my game
05:27:36 <gfixler> there's a tension in my brain as I work in Haskell
05:27:37 <gfixler> :)
05:27:56 * ski fell in love with it early on after encountering it, around 1999 :)
05:28:25 <gfixler> 1999!? Are you ruling the world yet?
05:28:45 <ski> (and of course it does have its share of flaws as well, though they somehow seem to be fewer than in many other languages)
05:29:11 <gfixler> I've only started into Haskell at the beginning of the year, but I've already heard mention of flaws by a few folks. I guess nothing's perfect yet.
05:29:21 <ski> right
05:29:34 <gfixler> Part of the clinical feeling may spawn from the knowledge that I'm heading toward big things, like monads.
05:29:42 <gfixler> I was never heading toward any big anything in Python.
05:29:52 <ski> monads isn't really that big of a thing
05:30:10 <gfixler> I know. I've put it up on quite a pedestal. I'm setting myself up for major disappointment.
05:30:14 <ski> it's just another sometimes useful abstraction
05:30:38 <gfixler> It's absurd how much I've read and watched on the subject, and how clueless I still am.
05:30:59 <ski> if you think monads are this hard or complex thing, that may hindering you from understanding them properly
05:31:16 <gfixler> Beckman's video 3 full times, and a few partial times. Monads and Gonads. The spacesuit thing. The burrito thing. ELI5s on reddit. Discussions on blogs. A few other hour-long videos.
05:31:18 <ski> sure, they're a bit abstract, and so hard to put a finger on, at first
05:32:12 <Pythonfant> just don't try to relate mondas to something you know
05:32:22 <donri> @google monad tutorial fallacy
05:32:24 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
05:32:24 <lambdabot> Title: Abstraction, intuition, and the “monad tutorial fallacy” | blog :: Brent ...
05:32:31 <ski> @where burrito
05:32:31 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
05:32:31 <gfixler> The craziest thing has been how dissimilar all of the various videos and articles have been. There's seemed very little to connect them, like everyone's talking about completely different topics.
05:32:32 <ski> :)
05:32:42 <gfixler> I've read that one, too :)
05:32:45 * ski nods
05:33:22 <gfixler> As I said, completely absurd how much I've invested into still not understanding them.
05:33:27 <ski> gfixler : different monads are quite different. the thing they have in common is usually smaller than in how much they differ
05:33:53 <ski> just knowing it's a monad tells you something, but not everything you need to know
05:33:54 <donri> for me that usually means i haven't tried to use the abstraction for anything real
05:34:10 <ski> you'll need to understand the specific primitives as well for it
05:34:14 <gfixler> yeah - I'm taking it slowly
05:34:21 <gfixler> I need to know monoids, functors, etc
05:34:34 <gfixler> I was jumping into the deep end with monads
05:34:41 <Pythonfant> gfixler: the nicta course might help understanding it a bit more
05:35:16 <donri> but there's no magic to monads, just functions with unfortunate names and confusing infix operators, and syntactic sugar obfuscating the underlying structure
05:35:18 <ski> monoids is a very simple concept from basic (abstract) algebra in math, that's more or less just a useful label to put on some similar things of a specific kind
05:35:27 <uberwach> btw. is there any introduction to monads and their use in FP which is more formal? say if you come from pure mathematics where category theory is applied every day..
05:36:08 <ninja_code_> I only know of one good way to learn about monads
05:36:14 <ninja_code_> read the source cod
05:36:32 <gfixler> donri: that's what I've been thinking is going on - bad names for everything confusing me at every turn.
05:36:39 <ski> gfixler : i take you're familiar with how one can have one priority queue interface (abstract data type), and then have several distinct implementations, implementing the interface, yes ?
05:37:03 <pleax> gfixler: did you read Typeclassopedia?
05:37:12 <gfixler> ski: Well, I'm not a Java person...
05:37:30 <gfixler> pleax: not yet - I stopped when it got a bit confusing and went to LYAH
05:37:55 <donri> i think many people would have much less trouble learning monads if they were a sidenote with no sugar and plain prefix functions, similar to Functor. now people are stuck trying to understand how Monad makes do notation "work"
05:38:01 <ski> gfixler : this applies also to C++, Pascal, Ada, Smalltalk, Modula, Erlang, Clojure, &c. --
05:38:39 <ski> (i'm talking about the idea here, not about how one might express that idea in a particular programming language)
05:38:45 <gfixler> ski: I'm going to go with "I think so."
05:38:54 <pleax> gfixler: it was the ultimate guide for me
05:38:58 <donri> even if you're aware of this, and read a tutorial that takes it into account, you'll subconsciously still be stuck at trying to fit it into the corresponding sugar
05:39:26 <ski> gfixler : ok. e.g. we could have an plain array (or linked list) based PQ, which sorts completely internally, inserting new items at their proper place
05:40:02 <gfixler> ski: implementations of abstract data types I get
05:40:11 <donri> Monad isn't really any more abstract or complex or weird than Functor but still Functor is much easier to learn
05:40:57 <ski> gfixler : another implementation is to have a tree (wither linked or embedded into an array), which represents a "heap", i.e. the element at the root is less than every element in the left and right subtrees (and similarly for the elements at the roots of those subtrees, and so on) -- this doesn't sort completely, but more "on-demand"
05:41:16 <ski> gfixler : these are all different implementations of the abstract PQ idea
05:41:40 <gfixler> right
05:41:42 <ski> gfixler : now, for monads, you could say that all monads are similarly implementations of the abstract `Monad' idea
05:41:57 <donri> alright not quite true; you can derive Functor but rarely one single Monad
05:42:06 <donri> but still (:
05:42:11 <ski> gfixler : the main difference being that just knowing that something is a monad doesn't tell you much about it, you really need *auxilary* operations as well to be able to do anything interesting
05:42:28 <Tjr> has any of you written Android apps in Haskell?
05:43:06 <gfixler> ski: are the auxiliary operations part of the monad, or entirely separate?
05:43:42 <ski> gfixler : another complication is that a (specific) monad is a "generic type" like "array of" (rather than "array of integers") -- generic types are only slowly starting to be used more in mainstream programming languages, and usually one can't abstract over them (but Haskell allows it)
05:44:17 <ski> gfixler : they are part of the particular monad, like e.g. the state monad, but they aren't part of the "monad" interface (in Haskell represented by the type class `Monad')
05:45:07 <gfixler> ski: that they're part of the instance makes sense
05:46:13 <ski> gfixler : heh .. they (the auxilary operations needed to make a particular monad useful) are *not* part of the "monad" interface ! :)
05:47:10 <gfixler> ski: I don't know what the monad interface is
05:47:17 <ski> @src Monad
05:47:17 <lambdabot> class  Monad m  where
05:47:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:47:21 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:47:23 <lambdabot>     return      :: a -> m a
05:47:25 <lambdabot>     fail        :: String -> m a
05:47:26 <ski> that's it
05:47:47 <ski> `(>>)' is just an optimization on `(>>=)', so you may safely ignore it
05:48:16 <ski> and `fail' is only present because matching may fail in Haskell -- it's not really part of the mathematical idea of a monad
05:48:25 <gfixler> I feel like Toto just pulled back the curtain. It's just this little old man?
05:48:42 <ski> so that leaves `(>>=)' and `return' (commonly called `extend' and `unit' in the more theoretical literature)
05:49:05 * hackagebot thrist 0.3.0.2 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.3.0.2 (GaborGreif)
05:49:25 <ski> any type `m' which implements `(>>=)' and `return' (and satisfies three reasonably-sounding laws regarding those operations) is a monad
05:49:28 <ski> that's it
05:49:44 <maybefbi> guys i need some help with this. http://lpaste.net/106964 mapM_ print, can print new lines as I read them, but easy plot cannot plot those new lines as they are read from the file.
05:50:01 <ski> that's of course very vague and abstract -- it doesn't tell you what they're are good for, or how to use them in practice
05:50:27 <ski> so, you really need to look and several different examples of actual monads (together with their respective auxilary operations) to "get it"
05:50:29 <gfixler> ski: I've heard this before - implementing two things and following a few laws; I promise it's slowly sinking in :)
05:50:41 <gfixler> yeah
05:50:44 <zwer> ski >>= is commonly called extend, not bind?
05:51:18 <zwer> in category theory
05:51:30 <ski> gfixler : btw, you may note that the "priority queue" interface also has a couple of (reasonably-sounding) laws, which implementations must satisfy, and which users may depend on
05:51:34 <ski> note the similarity here
05:51:53 <gfixler> ski: noted
05:52:08 <ski> zwer : well, strictly speaking, it's `flip (>>=)', i.e. `(=<<)', which is sometimes called `extend' in the literature -- but it's basically the same thing
05:52:23 <ski> zwer : you're right that `(>>=)' is usually pronounced "bind" in Haskell
05:53:32 <ski> gfixler : personally, i like "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, possibly the first monad tutorial, even though it's slightly dated in places
05:53:47 <ski> (it uses some old names of library stuff)
05:54:10 <jomg> ski: isn't extend also the comonad analog of >>= ?
05:55:25 <ski> jomg : i think it's unfortunate that people have also chosen the name `extend' for (basically) `(=>>)' (i suppose really `(<<=)', then), yes, because `extend' already appears in the literature in places as name for `(=<<)'
05:55:27 <maybefbi> easyplot library needs to strictly evaluate every data point before it can show something on screen. are there any plot libraries which can start showing things on screen before every point in the data has been strictly evaluated?
05:55:45 * ski suggested `preserve' for `(<<=)', but it didn't seem to catch
05:56:32 <jomg> oh well, i guess the context will usually be clear
05:56:47 <ski> gfixler : what that tutorial calls `thenX' is what's now commonly pronounced as "bind", i.e. `(>>=)'
05:57:48 <ski> jomg : though in some sense both could sensibly lay claim to the word "extend", since one extends a value in `a -> m b' to one in `m a -> m b', while the other extends ("preserves") a value in `w a -> b' to one in `w a -> w b'
05:58:18 <jomg> true
05:58:48 <jomg> is there anything besides Identity that's both a monad and a comonad, btw?
05:59:19 <ski> gfixler : also, what it later says is named `accumulate' in the prelude is nowadays called `sequence'
05:59:57 <gfixler> ski: I'll check it out!
05:59:58 <ski> gfixler : still, i think it's a short and to-the-point tutorial. it's only a starting point as well, you need to know about a few of the other commonly occuring monads as well
06:00:39 <ski> gfixler : seeing as you're (reasonably) new to it, i'd be interested to hear whether you think it's helpful to monad newbies
06:01:23 <ski> jomg : i'm not sure, but i suspect there isn't
06:01:35 <ski> hmm, well
06:01:48 <jomg> yea, wouldn't suspect that either, but i'm not really sure
06:01:58 <ski> jomg : actually, streams are both, i think
06:02:51 <jomg> yea, maybe...
06:03:14 <ski> @let infixr 5 :>; data Stream a = a :> Stream a deriving (Show,Ord)
06:03:15 <lambdabot>  .L.hs:164:31:
06:03:16 <lambdabot>      No instance for (Eq (Stream a))
06:03:16 <lambdabot>        arising from the 'deriving' clause of a data type declaration
06:03:16 <lambdabot>      Possible fix:
06:03:16 <lambdabot>        use a standalone 'deriving instance' declaration,
06:03:26 <ski> @let infixr 5 :>; data Stream a = a :> Stream a deriving (Show,Eq,Ord)
06:03:28 <lambdabot>  Defined.
06:03:47 <zwer> =
06:04:05 <benzrf> ;_;
06:04:12 <benzrf> :-:
06:04:26 <ski> @let instance Functor Stream where fmap f (a :> as) = f a :> fmap f as
06:04:28 <lambdabot>  Defined.
06:04:53 <benzrf> > fix (1:>2:>3:>)
06:04:54 <lambdabot>  The operator ‘L.:>’ [infixr 5] of a section
06:04:54 <lambdabot>      must have lower precedence than that of the operand,
06:04:54 <lambdabot>        namely ‘L.:>’ [infixr 5]
06:04:54 <lambdabot>      in the section: ‘1 :> 2 :> 3 :>’
06:04:58 <benzrf> shiz
06:05:03 <benzrf> > fix ((1:>2:>3):>)
06:05:04 <lambdabot>  No instance for (GHC.Show.Show a0)
06:05:05 <lambdabot>    arising from a use of ‘M297714538502502785829154.show_M2977145385025027858...
06:05:05 <lambdabot>  The type variable ‘a0’ is ambiguous
06:05:05 <lambdabot>  Note: there are several potential instances:
06:05:05 <lambdabot>    instance [safe] GHC.Show.Show
06:05:16 <benzrf> dang
06:05:19 <gfixler> ski: found the Winstanley writeup - doesn't look too long.
06:05:27 <benzrf> > fix (("foo":>"bar":>"baz"):>)
06:05:29 <lambdabot>  Couldn't match expected type ‘L.Stream [GHC.Types.Char]’
06:05:29 <lambdabot>              with actual type ‘[GHC.Types.Char]’
06:05:33 <benzrf> >:{
06:05:41 <benzrf> oh
06:05:50 <ski> @let Monad Stream where return a = as where {as = a :> as}; ma >>= amb = join (fmap amb ma) where {join ((a :> _) :> ass) = a :> join (fmap (\(_ :> as) -> as) ass)}
06:05:50 <lambdabot>  Parse failed: TemplateHaskell is not enabled
06:05:53 <benzrf> god damn it
06:05:59 <ski> @let instance Monad Stream where return a = as where {as = a :> as}; ma >>= amb = join (fmap amb ma) where {join ((a :> _) :> ass) = a :> join (fmap (\(_ :> as) -> as) ass)}
06:06:00 <lambdabot>  .L.hs:169:10: Warning:
06:06:01 <lambdabot>      ‘Stream’ is an instance of Monad but not Applicative - this will become ...
06:06:01 <lambdabot>  
06:06:01 <lambdabot>  <no location info>:
06:06:01 <lambdabot>  Failing due to -Werror.
06:06:26 <benzrf> nice try ski
06:06:47 <ski> @let instance Monad Stream where {return a = as where {as = a :> as}; ma >>= amb = join (fmap amb ma) where {join ((a :> _) :> ass) = a :> join (fmap (\(_ :> as) -> as) ass)}}; instance Applicative Stream where {pure = return; (<*>) = ap}
06:06:48 <benzrf> > fix ("foo":>"bar":>"baz":>)
06:06:49 <lambdabot>  Defined.
06:06:50 <lambdabot>  The operator ‘L.:>’ [infixr 5] of a section
06:06:50 <lambdabot>      must have lower precedence than that of the operand,
06:06:50 <lambdabot>        namely ‘L.:>’ [infixr 5]
06:06:50 <lambdabot>      in the section: ‘"foo" :> "bar" :> "baz" :>’
06:06:52 <benzrf> maaan
06:06:58 <benzrf> > fix \v -> "foo":>"bar":>"baz":>v
06:06:59 <lambdabot>  <hint>:1:5: parse error on input ‘\’
06:07:05 <benzrf> > fix $ \v -> "foo":>"bar":>"baz":>v
06:07:06 <lambdabot>  "foo" :> ("bar" :> ("baz" :> ("foo" :> ("bar" :> ("baz" :> ("foo" :> ("bar" ...
06:07:09 <benzrf> FINALLY
06:07:45 <ski> gfixler : hehe, i already provideded a link to it, but ok :)
06:08:09 <gfixler> ski: I've been up all night - I'm a little bleary-eyed :)
06:08:14 <ski> no worry
06:08:57 <benzrf> @let repeatS v = v:>repeatS v
06:08:58 <lambdabot>  Defined.
06:09:58 <benzrf> @let cycleS l = foldr (:>) (cycleS l) l
06:09:59 <lambdabot>  Defined.
06:10:03 <benzrf> :t cycleS
06:10:04 <lambdabot> [a] -> Stream a
06:10:19 <benzrf> > join (repeatS (cycleS [1, 2, 3, 4, 5]))
06:10:20 <lambdabot>  1 :> (2 :> (3 :> (4 :> (5 :> (1 :> (2 :> (3 :> (4 :> (5 :> (1 :> (2 :> (3 :>...
06:10:29 <benzrf> diagonalization :-O
06:10:35 <ski> @let class Functor w => Comonad w where extract :: w a -> a; (<<=) :: (w a -> b) -> (w a -> w b); scaffold :: w a -> w (w a); wab <<= wa = fmap wab (scaffold wa); scaffold = (id <<=)
06:10:37 <lambdabot>  Defined.
06:10:39 <benzrf> neato
06:10:50 <benzrf> scaffold?
06:10:59 <benzrf> do you mean duplicate?
06:11:00 <ski> the dual of `join'
06:11:07 <benzrf> ah
06:11:14 <ski> yes, "duplicate" has also been used as a name for it
06:11:18 <benzrf> edk's comonad package calls it that :v
06:11:29 * ski thinks "duplicate" is too general a term here, though :)
06:11:36 <ski> (i know)
06:12:12 <ski> benzrf : your `repeatS' is `return'
06:12:19 <benzrf> oh shit
06:14:25 <benzrf> @let class Functor t => Coapplicative t where extractA :: t a -> a; duplicateA :: f (a, b) -> (f a, f b)
06:14:26 <lambdabot>  .L.hs:190:1:
06:14:26 <lambdabot>      The class method ‘duplicateA’
06:14:26 <lambdabot>      mentions none of the type variables of the class Coapplicative t
06:14:26 <lambdabot>      When checking the class method:
06:14:26 <lambdabot>        duplicateA :: f (a, b) -> (f a, f b)
06:14:29 <benzrf> oh wait that's not very useful
06:15:03 <benzrf> @let whatLooksLikeItShouldBeDuplicateA = fmap fst &&& fmap snd
06:15:04 <lambdabot>  Defined.
06:15:16 <benzrf> > whatLooksLikeItShouldBeDuplicateA (Just (1, 2))
06:15:17 <lambdabot>  (Just 1,Just 2)
06:15:53 <ski> > (getZipList . foldr (liftA2 (:)) (pure []) . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
06:15:55 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
06:16:26 <ski> benzrf : `Either' ?
06:16:32 <benzrf> ski: ?
06:16:38 <benzrf> what aboot it
06:16:41 <ski> instead of `(,)'
06:16:48 <benzrf> hmmmmmmmmm
06:17:09 <benzrf> that's not a dual of Applicative though
06:17:12 <benzrf> well
06:17:15 <benzrf> im doing duals wrong anyway
06:17:18 <ski> as you say, `fmap fst &&& fmap snd' isn't terribly interesting
06:17:19 <pjdelport> > (getZipList . T.sequenceA . map ZipList) [[1,2,3],[4,5,6],[7,8,9]]
06:17:20 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
06:18:25 <benzrf> Either (f a) (f b) -> f (Either a b)
06:18:43 <benzrf> :t either (fmap Left) (fmap Right)
06:18:44 <lambdabot> Functor f => Either (f a) (f b) -> f (Either a b)
06:18:59 <benzrf> f (Either a b) -> Either (f a) (f b)
06:19:08 <benzrf> yep that's more interesting
06:20:00 <ski> @let takeS :: Integral i => i -> Stream a -> [a]; takeS n _         | n <= 0 = [                ]; takeS n (a :> as)          = a : takeS (n-1) as
06:20:02 <lambdabot>  Defined.
06:20:44 <benzrf> :t \v -> case extract v of Left _ -> Left (fmap fromLeft v); Right _ -> Right (fmap fromRight v)
06:20:45 <lambdabot>     Not in scope: ‘fromLeft’
06:20:46 <lambdabot>     Perhaps you meant one of these:
06:20:46 <lambdabot>       ‘IM.fromList’ (imported from Data.IntMap),
06:20:48 <benzrf> crud
06:21:44 <benzrf> :t \v -> either (extract v) Left (fmap (\(Left x) -> x) v); Right _ -> Right (fmap (\(Right x) -> x) v)
06:21:45 <lambdabot> parse error on input ‘;’
06:22:04 <benzrf> :t \v -> case extract v of Left _ -> Left (fmap (\(Left x) -> x) v); Right _ -> Right (fmap (\(Right x) -> x) v)
06:22:05 <lambdabot> Comonad f => f (Either t b) -> Either (f t) (f b)
06:22:17 <benzrf> close enuf
06:23:00 <ski> @let appendS :: [a] -> Stream a -> Stream a; appendS [    ] sa = sa; appendS (a:as) sa = a :> appendS as sa
06:23:01 <lambdabot>  Defined.
06:23:24 <ski> @let cycleS :: [a] -> Stream a; cycle as = sa where sa = as `appendS` sa
06:23:26 <lambdabot>  Defined.
06:25:46 <benzrf> ski: that's prepend you boob
06:28:12 <ski> @instance T.Traversable Stream where traverse f (a :> sa) = liftA2 (:>) (f a) (traverse f sa); mapM f (a :> sa) = liftM2 (:>) (f a) (mapM f sa)
06:28:12 <lambdabot> Maybe you meant: instances instances-importing
06:28:16 <ski> @let instance T.Traversable Stream where traverse f (a :> sa) = liftA2 (:>) (f a) (traverse f sa); mapM f (a :> sa) = liftM2 (:>) (f a) (mapM f sa)
06:28:17 <lambdabot>  .L.hs:199:47:
06:28:17 <lambdabot>      Couldn't match type ‘[b]’ with ‘Stream b’
06:28:17 <lambdabot>      Expected type: m (Stream b)
06:28:17 <lambdabot>        Actual type: m [b]
06:28:17 <lambdabot>      Relevant bindings include
06:28:22 <ski> hrm
06:28:35 <ski> @let instance T.Traversable Stream where traverse f (a :> sa) = liftA2 (:>) (f a) (T.traverse f sa); mapM f (a :> sa) = liftM2 (:>) (f a) (T.mapM f sa)
06:28:36 <lambdabot>  .L.hs:197:10:
06:28:36 <lambdabot>      No instance for (Foldable Stream)
06:28:36 <lambdabot>        arising from the superclasses of an instance declaration
06:28:36 <lambdabot>      In the instance declaration for ‘Traversable Stream’
06:31:25 <ski> @let instance T.Traversable Stream where {traverse f (a :> sa) = liftA2 (:>) (f a) (T.traverse f sa); mapM f (a :> sa) = liftM2 (:>) (f a) (T.mapM f sa)}; instance F.Foldable Stream where {foldMap = T.foldMapDefault}
06:31:27 <lambdabot>  Defined.
06:31:52 <ski> benzrf : i was thinking to name it `prependS', but then i was thinking that `(++)' is sometimes called `append' ..
06:33:43 <donri> the difference between append and prepend in a pure context is merely about argument order, is it not
06:35:24 <ski> more or less, yes
06:35:37 <ski> or about emphasis of the arguments, perhaps
06:47:21 <efzee> ?part
06:47:21 <lambdabot> Not enough privileges
07:13:32 <gfixler> In the Maybe monad: return a = Just a
07:13:56 <gfixler> return is the thing that lifts a value up into a function so it can join in the composition?
07:14:15 <gfixler> and Just is the functional wrapper that a gets lifted into?
07:14:37 <donri> return gives you the value inside the monadic context, such that that original plain value is "returned" to you on bind
07:15:33 <donri> > do a <- Just 1; b <- Just 2; Just (a + b)
07:15:35 <lambdabot>  Just 3
07:15:59 <gfixler> I think that's the opposite of what I thought
07:16:05 <donri> > do a <- return 1; b <- return 2; return (a + b) :: Maybe Int
07:16:06 <lambdabot>  Just 3
07:16:23 <donri> > do a <- return 1; b <- return 2; return (a + b) :: [Int]
07:16:25 <lambdabot>  [3]
07:16:41 <gfixler> unfortunately, I don't know do notation yet
07:16:42 <donri> it's a monadic "action" without any "effects"
07:17:24 <donri> in Maybe, Nothing is an effect, that of short-circuiting
07:17:27 <gfixler> I see, I was thinking that `return a = Just a` brought something into the monad
07:17:36 <donri> whereas Just is "just" a value :)
07:17:42 <gfixler> but it actually gets something out of it
07:17:49 <donri> no you're right
07:18:04 <gfixler> If I'm right, then I'm still confused :)
07:18:10 <Pythonfant> m >>= return = m might also help to understand this
07:18:19 <Pythonfant> one of the monad laws
07:18:31 <ski> @undo do a <- Just 1; b <- Just 2; Just (a + b)
07:18:31 <lambdabot> Just 1 >>= \ a -> Just 2 >>= \ b -> Just (a + b)
07:18:37 <gfixler> I'm focusing on return a, because >>= scares me
07:19:04 <Pythonfant> gfixler: just look at some implementations of return you know
07:19:08 <ski> gfixler : it may help to define first operations like :
07:19:16 <donri> "return" puts a value inside your monad, such that while working inside the monad, you get that original plain value back on bind
07:19:23 <Pythonfant> > return 1 :: Maybe Int
07:19:24 <lambdabot>  Just 1
07:19:27 <ski>   thenM :: Maybe a -> Maybe b -> Maybe b
07:19:31 <gfixler> donri: that sounds more like I was thinking
07:19:32 <Pythonfant> > return 1 :: Either Int Int
07:19:33 <lambdabot>  Right 1
07:19:38 <ski>   bothM :: Maybe a -> Maybe b -> Maybe (a,b)
07:19:40 <gfixler> in the case of the Maybe monad, the return operation is Just a
07:19:42 <Pythonfant> > return 1 :: [Int]
07:19:44 <lambdabot>  [1]
07:19:47 <gfixler> which 'lifts' the value a up into a function
07:19:50 <gfixler> no?
07:19:55 <Pythonfant> not into a function
07:19:58 <Pythonfant> into the monadic context
07:20:14 <gfixler> Just a isn't the function Just applied to a?
07:20:23 <donri> return = Just
07:20:49 <donri> Just a is a value not a function
07:20:54 <Pythonfant> gfixler: well return is a function but return a is Just a (in case of Maybe) which isn't a function anymore
07:21:15 <donri> in particular, it is a Maybe not a (->)
07:21:22 <gfixler> hmm
07:21:35 <gfixler> are you saying that Just a isn't a function, because it's applied?
07:21:49 <gfixler> Is Just a function?
07:21:55 <Pythonfant> :t Just
07:21:56 <gfixler> Just by itself - is it a function?
07:21:56 <lambdabot> a -> Maybe a
07:21:56 <donri> @google is everything a function
07:21:59 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:21:59 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
07:22:18 <donri> gfixler: yes
07:22:31 <ski> @type Just False
07:22:32 <gfixler> Just a is calling Just on a, or applying Just to a, yes?
07:22:32 <lambdabot> Maybe Bool
07:22:36 <ski> not a function
07:23:25 <ski> donri : perhaps that would warrant a `where' ?
07:23:41 <donri> ski: probably is one but i can never remember their names
07:23:47 <donri> easier to @google :)
07:23:59 <ski> @where+ everything-is-a-function http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:23:59 <lambdabot> Done.
07:24:08 <gfixler> is return a = Just a the same as return = Just?
07:24:08 <donri> is there a @search-where
07:24:12 <ski> not sure
07:24:19 <donri> gfixler: yes
07:24:40 <haasn> A function is a value you can apply
07:24:43 <haasn> Like f in “f x”
07:24:45 <gfixler> so we're just telling Maybe that when it's time to call return (whatever that is - still don't know), then it should use Just?
07:25:09 <donri> functions are terms and every term is a value but not every value is a function
07:25:23 <ski> gfixler : replacing the left definition by the right one is sometimes called "eta-reducing" it (though it's really using "extensionality", not "eta-equivalence", though they are related)
07:25:24 <ocharles> Anyone know if there's a way to "nest" an attoparsec parser in a subset of the input stream?
07:25:28 <donri> or something like that. not sure what the pedantic definition of "term" is
07:25:34 <haasn> “return” is just a function, functions don't get “called” in Haskell, they get applied - and the time to use return is whenever you want the semantics of return
07:25:46 <gfixler> is this like dependency injection?
07:26:00 <gfixler> i.e. we're telling Maybe that for return it should use Just?
07:26:06 <ocharles> E.g., I have "parser = (,) <$> parseType <*> Attoparsec.takeByteString", and now I want to use that with "many $ parseLength >>= nest parser"
07:26:07 <ski> extensionality : two functions are equal if and only if they give equal results for equal inputs
07:26:27 <donri> gfixler: if you're working with the Maybe monad, you can use Just instead of return or vice-versa. but if you're writing generic monad code, you need return, which works for any monad
07:26:43 <gfixler> Right, that's why I'm carefully saying "for Maybe" each time
07:26:49 <donri> @src liftM
07:26:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:26:49 <gfixler> I realize that return can be different per monad
07:26:59 <haasn> gfixler: ‘Maybe’​ does not care about “return”, or “Monad”, or any other abstraction or type class or function you use it with
07:27:03 <haasn> gfixler: Maybe is just a dumb type, nothing else
07:27:10 <ski> so, if `squareAll ns = map (^ 2) ns' (for all `ns', like it would be if that was taken as a definition of `squareAll' in Haskell), then we also know `squareAll = map (^ 2)'
07:27:10 <donri> you can write liftMaybe without return, but not the generic liftM without return
07:27:13 <haasn> There's nothing of semantic importance attached to ‘Maybe’ other than its definition
07:27:13 <ski> gfixler : makes sense ?
07:27:27 <gfixler> no, sorry
07:27:31 <gfixler> the answers are all over the place
07:27:39 <ski> ok, sorry
07:27:40 <gfixler> which means I'm probably way off base
07:28:03 <gfixler> I'm asking "is this like this?" and then I'm getting 5 different definitions of things I've never heard of
07:28:27 <gfixler> I might be trying to go the easy route - I might just need to keep reading (and reading) :)
07:29:05 <haasn> What we're saying with “instance Monad Maybe where return = Just; ...” is precisely that there exists an instance “Monad Maybe”, which is a sort of thing in its own right in Haskell - if anything, it's attached to the “Monad” class; meaning we can instantiate some “Monad m” constranit as​ “Monad Maybe” if we want to
07:29:15 <donri> gfixler: classes are like interfaces and class functions like methods on an object implementing an interface. so return is a bit like something like .toString() or whatever. it "does the right thing" for the type it is called upon, but you can work generically over anything implementing the interface
07:29:27 <ski> gfixler : well, a couple of people here (including me) was attempting to explain a few different (but useful) tidbits of knowledge
07:29:31 <haasn> And when we do this; the function “return” in those values is directly replaced by “Just”
07:29:52 <gfixler> donri: I feel like that's what I keep saying :)
07:30:13 <gfixler> ski: I appreciate it, but I can't make so many new leaps in one moment
07:30:25 <ski> gfixler : you don't necessarily need to know about them all now. if you have anything you're currently wondering about, feel free to ask (again, if need be)
07:30:29 <gfixler> haasn: I feel like you're saying what I've been saying, too
07:30:35 <ski> gfixler : *nod*, no worry
07:30:41 <haasn> I guess I just don't like the terminology and semantics of the “interface” comparison; with interfaces and OOP, the instance members belong to the type
07:30:53 <donri> gfixler: yeah, we're being pedantic. there are no zero-arity functions in haskell. actually there's only unary functions, whose return type can be another unary function etc
07:30:58 <gfixler> I'm saying that Maybe is a particular instance of Monad - right?
07:31:06 <haasn> This breaks down once you enter stuff like MPTC or polymorphic instances; where the instance members can't really be said to “belong” to any type in particular
07:31:09 <ski> gfixler : if we're going too fast, and don't notice it, please just tell us to slow down ;)
07:31:18 <gfixler> WAY too fast :)
07:31:24 <gfixler> wth is MPTC?
07:31:25 * haasn takes a break
07:31:29 <gfixler> (don't answer that)
07:31:31 <haasn> multi-parameter type clas-- oh
07:31:37 <donri> oh dear did someone mention MPTCs now
07:31:46 <donri> we're still on "return" :)
07:31:55 <ski> gfixler : `Maybe' is a particular data type with some useful operations on it. it also happens to be a monad (because it has implementations of `return' and `(>>=)' for it)
07:31:58 <gfixler> Looking at Maybe, it's 3 lines
07:32:07 <gfixler> The first makes sense - instance Monad Maybe where
07:32:14 <donri> :)
07:32:18 <ski> it's first and formost a useful data type in its own right
07:32:24 <gfixler> we're defining a monad, called maybe, and we're about to get into some particulars
07:32:33 <gfixler> the next line has >>= on it, and that's scary, so I'm skipping it
07:32:44 <gfixler> the final line has only: return a = Just a
07:32:49 <donri> it's not very useful without >>= though
07:32:55 <gfixler> I know, baby steps
07:33:21 <donri> return is useful mostly because of the laws about how it interacts with >>=
07:33:46 <gfixler> I was just asking first if return a = Just a was the same as return = Just, and if so, does this just mean that return - one of the two things a monad needs to implement - in the case of Maybe, is the function Just
07:34:07 <gfixler> IOW, each monad will define its own return
07:34:10 <gfixler> but Maybe defines it as Just
07:34:11 <donri> but anyway: return is a function (in this case, the same as the Just constructor function) and the result of applying the function is a value of the type of our monad
07:34:15 <pjdelport> gfixler: Technically speaking, Just is a data constructor (for the Maybe type). In one sense, it's a function, because it acts just like one, but in another sense, constructors are sometimes distinguished from "plain" functions that are not constructors.
07:34:47 <donri> gfixler: exactly!
07:35:00 <gfixler> donri: that's what I've been saying the whole time
07:35:06 <gfixler> well, trying to anyway :)
07:35:33 <donri> return is an "alias" for whatever function the Monad instance we end up with defines it to be
07:35:41 <gfixler> right
07:35:46 <gfixler> this way all monads have a return
07:35:52 <donri> yep
07:35:56 <gfixler> it's very OO
07:35:58 <pjdelport> gfixler: It might be easier to understand Functor and Applicative, first, as stepping stones to Monad.
07:36:04 <gfixler> I'm sure
07:36:06 <ski> gfixler : if `foo x = bar x' for every `x' (where `foo' and `bar' may be arbitrary expressions, though not mentioning `x'), then `foo = bar' -- this is known as "extensionality" .. therefore, since `return a = Just a' (for all `a'), it's also true that `return = Just' here
07:36:12 <donri> but beware that it's not much like "return" in other languages
07:36:18 <donri> it's an unfortunate naming
07:36:18 <gfixler> I'm just being impatient; I've been reading and watching videos about monads for like, 6 months now
07:36:35 <donri> it's more like "new" if anything (but not really)
07:36:57 <gfixler> ski: I'm wondering why Maybe defines it as return a = Just a, instead of just return = Just - does it just need a type in there to work?
07:37:10 <ski> gfixler : either would work
07:37:12 <gfixler> donri: I'm *quite* aware - these names are awful
07:37:30 <ski> (saying `return = Just' *might* perhaps be slightly more efficient, not sure)
07:37:40 <gfixler> in my own code in Python, I've found that if I'm slightly out of tune with my naming, I struggle tremendously to create things
07:37:46 <gfixler> get the name(s) right, and everything just happens
07:37:53 <donri> well if you don't know any other languages, "return" isn't completely senseless in haskell. it gives you a monadic value that "returns" the original value, inside the monad
07:38:03 <donri> but it does confuse people
07:38:16 <gfixler> I was using the unfortunately overused term 'actor' for something, and all the code was fighting me
07:38:33 <pjdelport> > Just (+) <*> Just 2 <*> Just 3
07:38:34 <lambdabot>  Just 5
07:38:47 <gfixler> then I realized the thing was more like a puppet - driven by others, not of its own accord - and changing the name made tons more abstractions fall into place immediately
07:38:47 <donri> actor donot act, there isno try!
07:38:51 <pjdelport> > [(+)] <*> [2] <*> [3]
07:38:53 <lambdabot>  [5]
07:39:07 <pjdelport> gfixler: Consider those two examples.
07:39:20 * ski likes to call every value "of a monadic type", like e.g. values of type `IO String' or `Maybe String' "actions" -- these'd be `IO'-actions and `Maybe'-actions respectively
07:39:38 <gfixler> what is <*>?
07:39:42 <pjdelport> > pure (+) <*> pure 2 <*> pure 3 :: Num a => Maybe a
07:39:44 <lambdabot>  Just 5
07:39:45 <Pythonfant> :t (<*>)
07:39:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:39:49 <ski> gfixler : it's a thing from `Applicative'
07:40:08 <pjdelport> gfixler: It's function application in an applicative functor.
07:40:18 <gfixler> ski: yeah, I need to learn all these other things first
07:40:32 <pjdelport> gfixler: "pure" above is the same as "return".
07:40:33 <gfixler> monoid, functor, applicative
07:40:59 <Pythonfant> functor, applicative, monad is a good order
07:41:02 <ski> > [(+),(*)] <*> [2,3] <*> [10,20]  -- in case you were curious about what it can do. but don't worry too much about it for now (unless you want to cover applicative functors before monads)
07:41:03 <lambdabot>  [12,22,13,23,20,40,30,60]
07:41:17 <donri> i tend to use "actions" too but it can be an unfortunate terminology too - it implies something like side-effects and imperative step-by-step execution, possibly
07:41:21 <gfixler> ski: I don't even know what I want
07:41:26 <pjdelport> gfixler: Now, you'll see that that looks exactly like (+) 2 3; except that each of the three parts are "lifted" into the functor.
07:41:35 <ski> gfixler : *nod*
07:41:41 <donri> someone suggested haskell has effects, not side-effects ;)
07:41:54 <ski> donri : i've been saying that a long time :)
07:41:57 <pjdelport> gfixler: And the nice thing is that the functor can control how the function application works.
07:42:24 <pjdelport> For example, how Maybe works is that if any of the values are Nothing, the whole application will be Nothing.
07:42:29 <ski> donri : i have nothing against calling `[2,3,5,7]' a `[]'-action (list-action), e.g. ;)
07:42:29 <pjdelport> > pure (+) <*> pure 2 <*> Nothing
07:42:31 <lambdabot>  Nothing
07:42:35 <donri> but i don't like saying "effect" for "m a" either, because I tend to view monads as being the combination of some effects "m" with some value "a"
07:42:39 <fumieval> Fuuzetsu: sorry for replying a-month-ago message, but I've not created a function that flips a Bitmap horizontally yet
07:42:40 <pjdelport> > Nothing <*> pure 2 <*> pure 3
07:42:41 <lambdabot>  Nothing
07:42:58 <gfixler> f (a -> b) -> f a -> f b looks like function decomposition
07:42:59 <donri> i sometimes favor "monadic computation", perhaps because it says so little ;)
07:43:31 * ski notes it's slightly noisy here atm, attempts to say less stuff not relevant to the actual questions
07:43:55 <pjdelport> gfixler: So the Maybe applicative functor gives you a way to deal with values that may fail, without your functions actually having to deal with it. You just take a plain computation, and "lift" it with pure, and do the application with <*>.
07:44:12 <ski> gfixler : i'd say learning functors before monads probably will help. maybe applicatives as well, not sure
07:44:32 <pjdelport> gfixler: Similarly, the list functor gives you a way to deal with multi-values expressions, like ski's example.
07:44:36 <donri> lyah and typeclassopedia are good
07:44:40 <ski> (applicative functors didn't exist when i learned monads)
07:45:22 <pjdelport> > pure (+) <*> [10,20,30] <*> pure 5
07:45:23 <lambdabot>  [15,25,35]
07:45:34 <pjdelport> > pure (+) <*> [10,20,30] <*> [1,2,3]
07:45:35 <lambdabot>  [11,12,13,21,22,23,31,32,33]
07:45:36 <gfixler> pjdelport: this all seems like the perfect information for the me that will exist a few months from now :)
07:45:44 <pjdelport> > pure (+) <*> [10,20,30] <*> []
07:45:45 <lambdabot>  []
07:46:12 <pjdelport> gfixler: No, the point is that the above is exactly what return and Monad is, too.
07:47:00 <pjdelport> > return (+) `ap` [10,20,30] `ap` [1,2,3]
07:47:01 <ski> donri : yes, a value of type `m a' (for a monad `m', say) isn't an effect, it *has* (or describes) an effect, together with computing a result value when "executing" it
07:47:02 <lambdabot>  [11,12,13,21,22,23,31,32,33]
07:47:39 <donri> yep
07:48:04 <pjdelport> gfixler: So despite the difference in naming, Applicative's "pure" is essentially the same as Monad's "return", and <*> is the same as Monad's ap.
07:48:12 <donri> > [1|otherwise] :: Just Int
07:48:14 <lambdabot>  Not in scope: type constructor or class ‘Just’
07:48:14 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
07:48:17 <ski> gfixler : since we seem to be talking about `(<*>)' (and `ap', which is basically the same thing) now, you can see how for lists it essentially "tries every possible combination of elements of the given lists"
07:48:22 <donri> > [1|otherwise] :: Maybe Int
07:48:23 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Int’
07:48:23 <lambdabot>              with actual type ‘[t0]’
07:48:26 <pjdelport> gfixler: All Monads are Applicative, too.
07:48:31 <donri> :(
07:48:37 <gfixler> pjdelport: good to know
07:48:56 <donri> lambdabot y u no monad comprehensions
07:49:13 <ski> > [m + n | m <- [10,20,30],n <- [1,2,3]]  -- this list comprehension does basically the same as pjdelport's examples
07:49:14 <lambdabot>  [11,12,13,21,22,23,31,32,33]
07:49:19 <pjdelport> gfixler: Do the above examples with Applicative make sense, and help explain the meaning of pure/return?
07:49:40 <gfixler> pjdelport: Unfortunately no, it's a bit too much at this point
07:49:59 <gfixler> I'm catching small bits here and there, but not the whole picture
07:50:48 <pjdelport> gfixler: Do you understand Functor?
07:50:52 <gfixler> no
07:51:01 <pjdelport> Ah, sorry, then that's the place to start.
07:51:04 <gfixler> I think I arrived here too early
07:51:05 <ski> monads and applicative functors serve more or less the same purpuse (roughly speaking)
07:51:08 <gfixler> is there a #haskell-newbs? :)
07:51:14 <ski> functors are more general
07:51:29 <ski> (but every monad, and every applicative functor, is a functor)
07:51:33 <pjdelport> > (+10) `fmap` [1,2,3]
07:51:36 <lambdabot>  [11,12,13]
07:51:38 <Pythonfant> gfixler: newbs are welcome here
07:51:40 <pjdelport> > (+10) `fmap` Just 5
07:51:42 <lambdabot>  Just 15
07:51:48 <hiptobecubic> gfixler, you're better off here really.
07:51:55 <hiptobecubic> even if there were a #haskell-newbs
07:52:24 <gfixler> what I "know" of functors right now is that they are some mix of types and functions that transform things across categories or sets or something
07:52:34 <gfixler> that could be wrong, but that would just mean that what I "know" is wrong
07:52:49 <ski> @let data RoseTree a = Rose a [RoseTree a] deriving Show
07:52:51 <lambdabot>  Defined.
07:53:03 <pjdelport> gfixler: In simpler terms, in Haskell, a Functor is just a structure that lets you apply a single function inside it.
07:53:13 <pjdelport> :t fmap
07:53:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:53:20 <ski> @let instance Functor RoseTree where fmap f (Rose a ts) = Rose (f a) (map (fmap f) ts)
07:53:21 <lambdabot>  Defined.
07:53:26 <donri> Functor in haskell is an endo-functor on Hask, so not quite that generic ;)
07:53:39 <pjdelport> So lists are a simple functor you already know: fmap is just map for lists.
07:53:50 <ski> > (+10) `fmap` Rose 2 [Rose 3 [Rose 5 []],Rose 4 []]
07:53:51 <lambdabot>  Rose 12 [Rose 13 [Rose 15 []],Rose 14 []]
07:54:14 <ski> `fmap' is roughly for "doing the same thing to every element of a collection"
07:54:29 <gfixler> how long does lambdabot hold onto these definitions?
07:54:34 <pjdelport> gfixler: fmap just extends the idea to other structures, of any kind of shape, as long as they have a "slot" you can operate on.
07:54:42 <ski> until it reboots, or someone does an `@undefine'
07:54:52 <gfixler> should I be afraid of the singularity?
07:54:57 <kvanb> should record fields be strict
07:55:01 <kvanb> if they are function ptrs
07:55:04 <ski> @keal
07:55:04 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
07:55:18 <ski> @help keal
07:55:18 <lambdabot> keal. Talk like Keal
07:55:37 <pjdelport> gfixler: So does "(+10) `fmap` Just 5" make sense?
07:55:43 <ski> (Keal was a .. troll, sortof, that was here, years ago)
07:56:10 <gfixler> ski: wow
07:56:20 <gfixler> pjdelport: I'm scanning...
07:56:31 <ski> @palomer
07:56:31 <lambdabot> Category theory is the Paris Hilton of mathematics
07:56:58 <pjdelport> gfixler: It's basically the same as: (+10) `fmap` [5]
07:56:59 <hiptobecubic> I have yet to see any Category Theory porn
07:57:15 <ski> (palomer wasn't exactly a troll, but got easily on (at least some) people's nerves)
07:57:27 <pjdelport> gfixler: And in the same way that (+10) `fmap` [] gives you [], (+10) `fmap` Nothing gives you Nothing.
07:57:42 <donri> hiptobecubic: https://github.com/konn/category-agda
07:57:43 <gfixler> pjdelport: not *quite* sure what I'm seeing there
07:57:47 <gfixler> (+10) I get
07:57:53 <gfixler> `infix` I get
07:58:16 <gfixler> not sure what fmap itself is doing
07:58:17 <hiptobecubic> donri, NSFW!
07:58:31 <donri> sorry forgot the warning
07:58:41 <pjdelport> gfixler: Well, you know (+10) `map` [1,2,3] right?
07:58:46 * hiptobecubic hates unicode
07:58:51 <gfixler> pjdelport: yes
07:59:12 <donri> hiptobecubic: https://github.com/copumpkin/categories NSFL
07:59:19 <pjdelport> gfixler: The insight is just that `fmap` is a generalization of the same idea to other data structures.
07:59:32 <pjdelport> For lists, fmap = map
07:59:35 <ion> hiptobecubic: You should switch to something else.
07:59:40 <freed0m408> hi, noob on this channel, i hope find the place i spect and hope to help.
07:59:50 <ski> @src Maybe fmap
07:59:50 <lambdabot> fmap _ Nothing       = Nothing
07:59:50 <lambdabot> fmap f (Just a)      = Just (f a)
07:59:58 <gfixler> pjdelport: ah yes, I've encountered this recently in a talk, and then promptly forgot it
08:00:06 <gfixler> fmap allows one to map over anything, e.g. a tree
08:00:16 <ski> freed0m408 : hello. do you have a Haskell-related question ?
08:00:26 <pjdelport> gfixler: You can think of map as lifting a function to operate on lists; fmap lets you lift a function to any Functor instance in general.
08:00:38 <pjdelport> gfixler: Right, that's exactly it.
08:00:40 <freed0m408> not any question now, guive time to time
08:00:48 <ski> that's fine
08:01:08 <pjdelport> gfixler: In this case, Maybe is kind of like a zero-or-one element list.
08:01:13 <ski> freed0m408 : you can stay and lurk, if you want, and ask later if any question crosses your mind
08:01:52 <freed0m408> i rly dont programm haskel, here to found haskel advantages, but i know lots of complex data builds
08:02:18 <hiptobecubic> Not entirely sure I understood that.
08:02:22 <pjdelport> gfixler: If you look at the list of Functor instances, you'll see there's quite a lot of things that are Functors: http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#t:Functor
08:02:58 <gfixler> Functors seem really simple
08:03:07 <ski> they are
08:03:14 <hiptobecubic> gfixler, they aren't hard to get, no
08:03:23 <ski> for every functor, we requre two laws :
08:03:27 <gfixler> they only implement fmap?
08:03:32 <ski> yes
08:03:38 <donri> you can even derive Functor, and there'll always only be one valid definition
08:03:48 <pjdelport> gfixler: A key insight is that Functors can also be things that are not data structures, like IO. So you can say for example: negate `fmap` readLn
08:03:48 <hiptobecubic> following the laws ski was about to state
08:03:54 <ski>   forall f cx.
08:03:58 <gfixler> this is the thing I keep running into - big scary word hides really simple something that hardly seems worthy of a big scary word
08:04:02 <ski>     fmap id cx = cx
08:04:11 <ski> where `id' is the trivial function defined by
08:04:14 <ski> @src id
08:04:14 <lambdabot> id x = x
08:04:19 <pjdelport> gfixler: In that case, you're lifting negate to work inside IO.
08:04:45 <ski> so this law says that using `fmap' to "do nothing" on a data structure of some sort, should always give back the same data structure, unchanged
08:04:47 <gfixler> pjdelport: I'm cool with that, I'm on an OS that thinks literally everything is a file
08:05:03 <gfixler> ski: right
08:05:07 <ski> the other law :
08:05:11 <donri> gfixler: in some way scary words are better than not so scary words-with-baggage, like your earlier "actor" remark
08:05:28 <ski>   forall f g cx.
08:05:28 <ski>     fmap (f . g) cx = fmap f (fmap g cx)
08:05:31 <gfixler> donri: perhaps, but they're still scary
08:05:36 <donri> :)
08:06:07 <ski> this says that using `fmap' once to do `g' then `f' on each element is the same as first using `fmap' once to do `g' to every element, and then using it again to do `f' to every element in the intermediate data structure
08:06:11 <ski> @src (.)
08:06:12 <lambdabot> (f . g) x = f (g x)
08:06:12 <lambdabot> NB: In lambdabot,  (.) = fmap
08:06:33 <gfixler> ski: right, somethingativity
08:06:38 <donri> gfixler: maybe good thing Applicative isn't called StrongLaxSemimonoidalEndofunctor
08:06:46 <ski> is function composition, like a unix pipe (though the information flows from right to left, not left to right. and only one value is passed along, not a whole stream/pipe of them)
08:07:10 <pjdelport> @remember donri maybe good thing Applicative isn't called StrongLaxSemimonoidalEndofunctor
08:07:11 <lambdabot> Done.
08:07:13 <gfixler> donri: one of my favorite videos is on the Retro Encabulator; I might like such names
08:07:16 <ski> gfixler : both these laws are very reasonably things to require of data structures implementing `fmap' (and so becoming functors)
08:07:26 <donri> \o/
08:08:20 <gfixler> ski: I believe in these laws, but can't say I grok the second one yet
08:08:35 <gfixler> I mean, I get roughly what it's saying, but not why it matters
08:08:58 <ski> `f . g'  is the composition of `f' and `g', the function that first does `g' to its input, and then does `f' to the result of that, yielding the result of that as the main result
08:09:05 <gfixler> it *doesn't* say that f (g x) and g (f x) must hold, right?
08:09:21 <ski> > map ((^ 2) . (+ 3)) [0,1,2]
08:09:22 <lambdabot>  [9,16,25]
08:09:28 <ski> > map (^ 2) (map (+ 3) [0,1,2])
08:09:29 <lambdabot>  [9,16,25]
08:09:33 <ski> > map (+ 3) [0,1,2]
08:09:35 <lambdabot>  [3,4,5]
08:09:36 <pjdelport> gfixler: It's the same as saying the following for lists: map (f . g) cx = fmap f (map g cx)
08:09:38 <donri> the laws ensure that legal functors do nothing more than applying the function to every "a" it holds
08:09:43 <ski> > map (^ 2) [3,4,5]
08:09:44 <lambdabot>  [9,16,25]
08:09:48 <dagano> i need to represent a graph with weighted edges and Data.Graph does not appear to let me do this....what are some good options for me?
08:10:11 <pjdelport> (err, except with map, not fmap, in there)
08:10:18 <donri> you can ignore the laws and write a well-typed but unlawful Functor with surprising behavior
08:10:41 <donri> such as only applying the function to every odd element in the list
08:10:54 <gfixler> donri: surprise!
08:10:57 <ski> gfixler : it doesn't say that `f (g x)' must be equal to `g (f x)', no, if that's what you meant to ask
08:11:01 <donri> but the laws can be checked, and expose broken instances
08:11:03 <gfixler> ski: it is
08:11:20 <pjdelport> gfixler: You generally don't need to worry about the laws; they're just a formal way of saying what it means for fmap to be well-behaved. In most cases, it's pretty intuitive.
08:11:31 <donri> actually i'm not sure you can write that Functor I just described but hey
08:11:36 <gfixler> ski: given right-associativity of function application, the second law of functors doesn't seem necessary to me
08:11:50 <donri> seeing as fmap changes the type
08:12:04 <ski> donri : actually, you can't do that, right
08:12:18 <donri> but you can say fmap _ _ = []
08:12:28 <donri> and it will type check, but not do what you want
08:12:41 <ski> donri : however, you could swap the order of every even- and odd- numbered element (except possibly the last one, if odd length), as you `fmap' -- and that would be a law-breaking case :)
08:13:00 <donri> or you can say fmap f xs = reverse (map f xs)
08:13:02 <ski> yes
08:13:14 <ski> that's also not allowed, according to the laws
08:13:23 <donri> or take 5 . map f
08:13:28 * ski figures gfixler is listening in to this
08:13:59 * gfixler is trying
08:14:14 <donri> the laws are a formal and rigorous way to define what it means to "map a function" the way you expect it to behave
08:14:19 <ski> gfixler : first, what do you mean by "right-associativity of function application" here ? (i'm suspecting you mean something else than what that means to most of us)
08:15:09 <gfixler> ski: probably - I mean that f g x is really f (g x), so saying that (f . g) x is the same as f (g x) seems obvious
08:15:28 <ski> normally, if you implement `fmap' in the "sensible way" so as to "transform every element with the function, preserving the structure of the whole thing", the laws will automatically hold, simply because this is the natural thing to do
08:15:37 <donri> laws in haskell aren't typically enforced by types (usually requires complex dependent types and such) but can be checked with property tests like QuickCheck
08:15:43 <ski> usually, you have to go out of your way to succeed in breking the laws of `Functor'
08:16:26 <gfixler> It feels like I've begun to grok functor, but then I see this: fmap :: (a -> b) -> f a -> f b
08:16:36 <gfixler> that says we have a function that transforms a to b
08:16:41 <ski> gfixler : well, `f g x' is `(f g) x', not `f (g x)'. because function application is left-associative (while the function type arrow `->' in types is *right*-associative. these two things are related to each other)
08:16:46 <gfixler> and then I don't know what it says
08:17:25 <gfixler> ski: I thought -> *was* function application
08:17:40 <ski> gfixler : let's say `f' is `Maybe', then it says
08:17:45 <donri> you can either view it as transforming a function (a -> b) to a function (f a -> f b) where f is your Functor type (so e.g. (Maybe a -> Maybe b), ([a] -> [b]))
08:17:46 <ski>   fmap :: (a -> b) -> Maybe a -> Maybe b
08:18:07 <nexx> gfixler is fmap :: Functor f => (a -> b) -> f a -> f b better?
08:18:11 <ski> so, then it takes a function that transforms `a's into `b's, and it also takes a `Maybe a', and it will hand back a `Maybe b'
08:18:13 <donri> or as taking a function (a -> b) and applying it over every "a" in an "f a" to arrive at an "f b"
08:18:25 <ski> nexx : i don't think it helps at this point
08:18:55 <gfixler> nexx: I don't think so
08:19:12 <donri> gfixler: -> is the function *type* (constructor), not application
08:19:21 <ski> gfixler : no, `->' occurs in *types* (and a few other places) .. it's the function type arrow that connects the *type* of a function argument to the *type* of a function result
08:19:56 <gfixler> sorry for the slow replies - you guys are fantastically helpful, and I'm slowly parsing multiple threads of help :)
08:20:10 <ski> gfixler : where's function *application* applies to *values* (of which the first one should be a function) -- so it's one level down from `->', downstairs, if you will
08:20:29 <ski> (if you think of types as "living" one level above values, i.e.)
08:20:33 <donri> yeah we're trying to help you 5 different ways at the same time, overwhelming i can imagine
08:20:43 <gfixler> ski: so a -> a -> is right-associative, but f g h x is left-associative?
08:20:51 <pjdelport> gfixler: Do you understand type classes in general? In other words, what the "Functor f =>" means?
08:21:04 <gfixler> donri: a little, but also wonderful; I can't get anyone in my real life interested in any of this
08:22:01 <jmcarthur> @quote fugue
08:22:02 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:22:27 <gfixler> pjdelport: Maybe Understand :)
08:22:38 <ski> gfixler : if you think it's too noisy, we could try moving into #haskell-overflow (and try to keep it less noisy) -- or we could attempt to decide who will be the "main teacher" at the moment
08:22:42 <ski> gfixler : yes
08:22:56 <gfixler> pjdelport: Functor f => is a type constraint, no?
08:23:14 <ski> gfixler : `a -> a -> [a]' e.g. means `a -> (a -> [a])', while `f g h x' means `((f g) h) x'
08:23:15 <gfixler> ski: I'm cool with this if you all are :)
08:23:19 <ski> ok
08:23:24 <donri> problem is i don't have the attention span to be the "main teacher" but i can't help myself from throwing out a comment here and there either ;)
08:23:29 <gfixler> ski: right (and left :)
08:23:43 <gfixler> donri: no worries, I appreciate your help
08:24:07 <pjdelport> gfixler: Right. It just means that the "f" stands for some type that's some Functor. So for example for lists, it's: fmap :: (a -> b) -> [a] -> [b]
08:24:12 <gfixler> jmcarthur: lol, nice
08:24:25 <pjdelport> That is, the f becomes [].
08:24:37 <ski> gfixler : that one has been rolling around in many variations ;)
08:24:56 <pjdelport> For Maybe, it's fmap :: fmap :: (a -> b) -> Maybe a -> Maybe b
08:25:04 <pjdelport> For IO, it's IO instead of Maybe, and so on.
08:25:41 <ski> (originally it was something about "answered in majestic stereo")
08:25:42 <pjdelport> In fact, it may help to know that you can write the list type as this too: fmap :: (a -> b) -> [] a -> [] b
08:26:00 <pjdelport> That makes it easier to see how the f is []
08:26:41 <donri> well, ([]) a
08:26:50 <donri> wait is that even valid
08:26:55 <ski> @type map :: (a -> b) -> ([] a -> [] b)
08:26:55 <lambdabot> (a -> b) -> [a] -> [b]
08:26:59 <ski> donri : yes
08:27:15 <donri> does it work without the parenthesis?
08:27:19 <ski> yes
08:27:23 <donri> cute
08:27:27 <ski> (as i just showed)
08:27:30 <pjdelport> donri: It's at the type level, so it's not exactly the same as an operator section.
08:27:32 <donri> true
08:27:44 <ski> (also `[]' isn't an operator)
08:27:55 <donri> pjdelport: well it's (->) to section function type :)
08:28:04 <ski> (the `[...]' syntax is sometimes called "distfix")
08:28:14 <donri> circumfix?
08:28:19 <ski> yeah, that too
08:28:45 <donri> preposterousfix
08:28:55 <gfixler> ([] a) feels like Clojure
08:29:06 <ski> (`let ... in ... end' (from SML) would be distfix, while `[ 32 ]' would be both distfix and circumfix)
08:29:16 <gfixler> ({:a "foo"} :a) => "foo"
08:29:19 <donri> aha
08:29:20 <pjdelport> gfixler: Anyway, once you have a grasp on Functor, it's a fairly easy step to Applicative.
08:29:22 <ski> well, in the lisps, every bracket is meaningful
08:29:26 <ski> in Haskell, not so
08:29:30 <gfixler> ski: true
08:30:22 <gfixler> pjdelport: "section" - that was the word I couldn't recall today; I was looking up "slicing"
08:30:52 <ski> (in most languages, brackets can be used to disambiguate / "change precedence ordering" .. since there's no precedence in the lisps, it's not used for that purpose there)
08:31:08 <pjdelport> gfixler: The only difference between Functor and Applicative is that while Functor only allows you to "lift" application of single-argument functions, Applicative allows you to lift values of any arity.
08:31:28 <gfixler> pjdelport: cool, but I'm going to hold back on that for the moment
08:31:51 <FireFly> I wonder how common it is to internally define parentheses as a circumfix "id" operator
08:31:52 <gfixler> this is normal stuff for all of you, but I'm being pummeled with science
08:31:58 <pjdelport> gfixler: Okay, but that's the key insight to keep in mind for later.
08:31:59 <FireFly> (when used for precedence, that is)
08:32:02 * ski thinks gfixler should probably first become comfortable with viewing `fmap' as "lifting" functions to operate on entire data structures, rather than viewing it as "doing something to every element"
08:32:20 <gfixler> ski: agreed - I'm *not quite* getting it
08:32:25 <gfixler> I might need to see it in action a bit first
08:32:28 <pjdelport> (gfixler: And similarly, the only thing that Monad adds to Applicative is the "join" operation.)
08:32:46 <ski> FireFly : could possibly be done with an operator parsing system as they have in Agda
08:33:08 <ski> gfixler : consider
08:33:36 <ski> > fmap (fmap (* 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
08:33:38 <lambdabot>  [[],[0],[2,4],[6,8,10],[12,14,16,18]]
08:33:38 <ski> and recall
08:33:40 <gfixler> this is why I reaaally want a 'tree of knowledge' for computer science
08:33:41 <ski> @src [] fmap
08:33:41 <lambdabot> fmap = map
08:33:46 <ski> so `fmap' is just `map' here
08:34:08 <gfixler> then you can look on the tree, see the branches and leaves below the current topic, and only describe anything at the current level using terms below that level
08:34:10 <pjdelport> gfixler: Try using fmap with IO, like that "negate `fmap` readLn" example.
08:34:20 <ski> note how i can operate on a nested structure (a list of lists, a list where the elements are lists) by passing `fmap (* 2)' as the argument to `fmap' above
08:34:29 <Javran> http://www.reddit.com/r/haskell/comments/1dcfso/a_monadic_joke/ can someone explain this joke? I don't get it..
08:35:44 <gfixler> ski: okay - I was going to ask how that's different than mapping with map, but I guess fmap is map here
08:35:51 <gfixler> so it's not
08:36:13 <gfixler> pjdelport: I haven't worked with IO, negate, or readLn yet
08:36:32 <pjdelport> gfixler: Right; fmap is just the same thing for other structures.
08:36:39 <ski> consider this partial trace :
08:36:47 <ski>      fmap (fmap (* 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
08:36:57 <ski>   =  [fmap (* 2) [],fmap (* 2) [0],fmap (* 2) [1,2],fmap (* 2) [3,4,5],fmap (* 2) [6,7,8,9]]
08:37:09 <ski>   =  [[],[(* 2) 0],[(* 2) 1,(* 2) 2],[(* 2) 3,(* 2) 4,(* 2) 5],[(* 2) 6,(* 2) 7,(* 2) 8,(* 2) 9]]
08:37:18 <ski>   =  [[],[0 * 2],[1 * 2,2 * 2],[3 * 2,4 * 2,5 * 2],[6 * 2,7 * 2,8 * 2,9 * 2]]
08:37:21 <gfixler> ski: that looks like what I'd expect
08:37:22 <ski>   =  [[],[0],[2,4],[6,8,10],[12,14,16,18]]
08:37:37 <gfixler> the next question, I suppose, is how fmap gets defined per type
08:37:47 <pjdelport> gfixler: This may also help:
08:37:48 <ski> so, note how the pattern `fmap (fmap f)' allows us to apply `f' "two levels deep" inside a structure
08:37:49 <pjdelport> > fmap (fmap (*2) [Nothing, Just 1, Nothing, Just 2, Just 3]
08:37:51 <lambdabot>  <hint>:1:59:
08:37:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:38:01 <pjdelport> > fmap (fmap (*2)) [Nothing, Just 1, Nothing, Just 2, Just 3]
08:38:03 <lambdabot>  [Nothing,Just 2,Nothing,Just 4,Just 6]
08:38:14 <pjdelport> (sorry, missing paren)
08:38:21 <ski> gfixler : yes, `fmap' is `map' here. it's just that all this also applies to `fmap' in general
08:38:51 <ski> as pjdelport showed, the kind of data structure at the "inner" level doesn't have to be the same as the kind at the "outer" level
08:38:59 <ski> now, consider this :
08:39:02 <gfixler> pjdelport: very interesting!
08:39:15 <ski>   fmap :: (a -> b) -> [a] -> [b]  -- the usual view of it, for lists
08:39:16 <gfixler> so fmap knows what to do per type
08:39:28 <ski>   fmap :: (a -> b) -> ([a] -> [b])  -- because `->' is right-associative
08:39:37 <gfixler> fmap (*2) Nothing = Nothing
08:39:42 <pjdelport> gfixler: So fmap just means that the two "levels" can be any Functor, not just list. So you can have Maybes inside a list, or lists inside of a Maybe, or any other combination of any two functors nested inside each other, and the fmaps works with all of them.
08:39:46 <ski>   (* 2) :: Integer -> Integer   -- let's settle for integers for the moment
08:40:11 <ski>   fmap (* 2) :: [Integer] -> [Integer]   -- "lifting" the function to operate on lists instead
08:40:12 <pjdelport> gfixler: Right; the knowing what to do per type is what type classes do for you.
08:40:13 <gfixler> pjdelport: okay, and by "the two 'levels'" you just mean in this example, right?
08:40:37 <ski>   fmap (fmap (* 2)) :: [[Integer]] -> [[Integer]]   -- "lifting" it again to operate on (twice nested) lists now
08:40:38 <pjdelport> gfixler: So it's the same idea as "(+) :: Num a => a -> a -> a", which works for any number (Num instance)
08:41:18 <pjdelport> gfixler: Right, just in that example. The two levels of fmap introduce two levels of Functor.
08:41:25 <ski> so, instead of viewing `fmap' as "doing something on every element of a structure", we here instead view it as transforming ("lifting") a function from operating on elements to operating (uniformly) on structures
08:42:07 <ski> in my case, both `fmap's were assumed to be on lists. if we follow pjdelport's example, then the first one will be on `Maybe's, and the second on lists :
08:42:14 <ski>   (* 2) :: Integer -> Integer
08:42:22 <gfixler> pjdelport: cool, got it
08:42:29 <ski>   fmap (* 2) :: Maybe Integer -> Maybe Integer
08:42:39 <ski>   fmap (fmap (* 2)) :: [Maybe Integer] -> [Maybe Integer]
08:42:43 <gfixler> ski: I think I actually follow all of that
08:42:50 <ski> the context decides which version of `fmap' is to be used in each instance
08:43:00 <gfixler> except why fmap knows what to do per type - where is that defined?
08:43:23 <hexagoxel> gfixler: in the instance definition for Functor
08:43:24 <pjdelport> gfixler: The Functor instance for each type implements fmap for that particular type.
08:43:24 <ski> (because, as you remember, `fmap' is overloaded to work on any generic type (aka type function) that is an instance of `Functor')
08:43:37 <int3__> is there some general way to encode the idea of functional dependencies? e.g. I have some functions f, g, h where f depends on g and h, and I only want to recompute f if g or h changes... just a simple example, though. I actually have a whole DAG of dependencies
08:44:38 <ski>   instance Functor Maybe
08:44:41 <ski>     where
08:44:51 <ski>     fmap _  Nothing  = Nothing
08:45:07 <ski>     fmap f (Just a ) = Just (f a)
08:45:18 <ski> is what makes `fmap' work for `Maybe'
08:45:23 <ski>   instance Functor []
08:45:25 <ski>     where
08:45:28 <ski>     fmap = map
08:45:33 <ski> is what makes it work for lists
08:45:42 <ski> gfixler : ok ?
08:46:03 <ski> (if you wanted to, you could have defined there `fmap f as = map f as', but why bother ;)
08:46:05 <gfixler> ski: processing :)
08:46:33 <pjdelport> gfixler: If you haven't gotten to defining type classes and instances, don't worry too much about the above yet.
08:46:51 <ski> an `instance' gives a specific implementation, for some specfic chosen type, for the operations that are specified in the type class
08:46:53 <gfixler> I get it
08:46:59 <gfixler> it makes sense
08:47:25 <ski> in case of the type class `Functor', the only method is `fmap', so that's what we need to implement to make a (generic) type an instance of `Functor'
08:47:44 <ski> `Functor' is defined like
08:47:49 <ski>   class Functor f
08:47:51 <ski>     where
08:47:58 <ski>     fmap :: (a -> b) -> f a -> f b
08:48:33 <ski> so, for each concrete type (function) we want to make an instance of `Functor', we should implement the version of `fmap' that has `f' replaced with that particular type function (/ generic type)
08:48:43 <ski> for `Maybe', we should therefore implement
08:48:49 <ski>   fmap :: (a -> b) -> Maybe a -> Maybe b
08:49:04 <ski> and similarly for the lists case
08:49:12 <ski> gfixler : ok ?
08:50:03 <gfixler> ski: still reading/thinking
08:50:09 <ski> ok, take your time
08:51:50 <hexagoxel> earlier you mentioned "return a = Just a", which would be part of "instance Monad Maybe" (i.e. "the Monad instance for Maybes")
08:52:11 <hexagoxel> (just to put things into context)
08:52:15 * ski nods
08:52:41 <gfixler> ski: ok, but those are just the type definitions
08:52:51 <gfixler> then you implement them?
08:52:51 <frea2282> where can I get utf8 text?
08:52:55 <ski>   fmap :: (a -> b) -> Maybe a -> Maybe b
08:53:01 <ski> is a type signature, not a type definition
08:53:08 <gfixler> ok
08:53:28 <ski> the general type signature for `fmap' as specified in the class declaration for `Functor f' above is
08:53:31 <ski>    fmap :: (a -> b) -> f a -> f b
08:53:34 <pjdelport> frea2282: What do you mean "get"?
08:53:44 <frea2282> pjdelport: find
08:53:55 <frea2282> what library has utf8 text?
08:54:02 <ski> when making an instance, it can be good to know the type signature of the specific thing one is to implement, e.g. before (or after) implementing it
08:54:26 <ski> in the case for making an instance for `Functor Maybe', the type signature becomes
08:54:29 <ski>   fmap :: (a -> b) -> Maybe a -> Maybe b
08:55:10 <pjdelport> frea2282: If you mean Unicode, the builtin Char type is already Unicode. The Data.Text package lets you explicitly decode and encode from and to UTF-8.
08:55:12 <ski> so now we know that we're to take as input a function mapping any kind of thing to any (possibly other) kind of thing, and also a `Maybe a' (where that `a' matches the input of the argument function)
08:55:26 <ski> and return a `Maybe b' (where the `b' matches the output of the argument function)
08:55:26 <frea2282> pjdelport: text is utf16
08:55:35 <frea2282> (Data.Text)
08:55:40 <ski> so, we know that `f' is to be `Maybe' in our specific implementation case
08:55:51 <ski> but we have *no* say as to what `a' and `b' is to be !
08:56:14 <pjdelport> frea2282: The interface to Text is just Unicode; the internal UTF-16 representation is just an implementation detail, and shouldn't affect how you use it.
08:56:20 <ski> that's for the *caller* of `fmap' to decide. we have to be satisfied with any possible choice, making a definition that works either way around
08:56:21 <gfixler> ski: creepy!
08:57:02 <frea2282> pjdelport: well it does since i'm storing a lot of mostly ascii text and i'm using C libs that expect utf8
08:57:07 <pjdelport> gfixler: It's no different to the fact that the caller to (+) decides whether it operates on Int, or Float, or whatever. :{
08:57:09 <pjdelport> :) even
08:57:16 <ski> the *caller* of `fmap' wants to be able to use it with *any* kind of element-transforming function, with no restriction on what the "elements before" and "elements after" can be
08:57:46 <pjdelport> frea2282: Ah, http://hackage.haskell.org/package/utf8-string then?
08:58:06 <ski> gfixler : therefore, the *implementation* of `fmap' has to be so kind and be satisfied with whatever choice the caller makes -- iow, it has to be *uniform* in that choice, or *parametrically* polymorphic
08:58:35 <ski> gfixler : if you don't quite understand those terms, dont' worry. i'm just mentioning them here, so that you know they have something to do with the topic
08:59:29 <ski> gfixler : this business of the caller deciding the type of some things, and the callee having to put up with any such choice has nothing in particular to do with type classes -- but everything to do with (parametric) polymorphism
08:59:33 <ski> @type length
08:59:34 <lambdabot> [a] -> Int
08:59:37 <ski> @type reverse
08:59:38 <lambdabot> [a] -> [a]
08:59:46 <ski> @type zip
08:59:47 <lambdabot> [a] -> [b] -> [(a, b)]
09:00:50 <ski> these are examples of (parametrically) polymorphic functions, because the caller decides what actual type to use in place of the type variables `a',`b'. the callee has to treat values of those types as opaque values, which it can't inspect, only pass on, and store in temporary data structures
09:00:56 <ski> gfixler : am i making any sense ?
09:01:05 <gfixler> ski: yes, I know this part
09:01:15 <ski> `fmap' is also parametrically polymorphic
09:01:19 <ski> @type fmap
09:01:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:01:23 <gfixler> in these cases it doesn't matter what the elements are
09:01:29 <pjdelport> Note that the choice of which Functor implementation to use for fmap (that is, [] or Maybe or whatever) is ad hoc polymorphism, not parametric polymorphism.
09:01:45 <gfixler> so the caller just has to know that their structure is full of Ints, and call fmap with something that handles Ints, no?
09:01:50 <ski> but the `Functor f =>' part adds the additional overloading flavor, based on `f' being an instance of `Functor'
09:02:38 <gfixler> I wouldn't call map (+2) on a list of strings
09:02:44 <ski> yes, the implementation of `fmap' does *not* treat `f' in the type signature for `fmap' opaquely .. it *knows* it's working with a `Maybe a', in the case `f' is `Maybe', e.g.
09:03:37 <ski> so, using `Blah a =>' in a type signature is an explicit permission to not treat the type variable `a' (totally) opaquely
09:04:31 <gfixler> pjdelport: right
09:04:58 <ski> gfixler : anyway, backtracking, knowing that for the instance for `Functor Maybe', we must implement
09:05:02 <ski>   fmap :: (a -> b) -> Maybe a -> Maybe b
09:05:13 <ski> it's not very hard to figure out that the only sensible way to do that is
09:05:16 <ski> @src Maybe fmap
09:05:17 <lambdabot> fmap _ Nothing       = Nothing
09:05:17 <lambdabot> fmap f (Just a)      = Just (f a)
09:05:32 <gfixler> ski: fmap *knows* - is this just dispatching - the correct fmap gets called for the type?
09:05:33 <ski> which is what is written instance the `instance Functor Maybe where ...' instance
09:05:55 <ski> and thus constitutes an implementation (overloading) of `fmap' for `Maybe'
09:06:17 <ski> gfixler : "the correct fmap gets called for the type?" -- yes, and this is decided at compile-time
09:07:14 <ski> (well, there are ways to *express* the situations where you want the actual choice being made at run-time, without doing violence to the above picture -- but that's more advanced stuff)
09:07:18 <gfixler> I think I'm still fighting with where each fmap overload lives
09:07:26 <pjdelport> gfixler: Type inference will figure out which Functor instance to use, or leave it unconstrained if a specific one is not needed.
09:07:31 <gfixler> if I define a new type, and I want it to be able to participate in fmappings, do I just implement fmap in my type?
09:07:37 <pjdelport> gfixler: It lives in instance declarations.
09:07:43 <gfixler> ok
09:07:47 <ski> gfixler : where it lives depends on the *context* in which `fmap (fmap (* 2))' is *used*
09:07:54 <gfixler> and if I don't, what happens when fmap smacks into it?
09:08:47 <ski> > fmap (fmap (* 2)) [Nothing,Just 1,Nothing,Just 3, Just 4]  -- here the first `fmap' is on lists, since we're passing a *list*, and the second (inner) one is on `Maybe', since we're passing a list of `Maybe'-values
09:08:49 <lambdabot>  [Nothing,Just 2,Nothing,Just 6,Just 8]
09:08:50 <pjdelport> So to implement fmap for your own type, you'll say: instance Functor MyType where fmap = ...
09:09:03 <gfixler> pjdelport: right
09:09:07 <ski> > fmap (fmap (* 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]  -- here both `fmap's are on lists, since we're passing a *list* of *lists*
09:09:09 <lambdabot>  [[],[0],[2,4],[6,8,10],[12,14,16,18]]
09:09:47 <gfixler> and fmap is only for container types
09:09:50 <ski> gfixler : "do I just implement fmap in my type?" -- yes, but as pjdelport said, you must place it inside a "containing" `instance' declaration
09:09:54 <gfixler> so I wouldn't implement it on a new type of number
09:10:39 <pjdelport> gfixler: Functor is not necessarily for containers only; you can potentially define it for any parametric type.
09:10:42 <kvanb_> implement a default Functor and Monad
09:10:46 <kvanb_> then watch the world burn.
09:10:56 <ski> gfixler : "and if I don't, what happens when fmap smacks into it?" -- then `fmap' will mean your locally defined one (which is not overloaded), being treated as a separate function from the `fmap' in `Prelude'
09:11:11 <pjdelport> gfixler: So that's why you have a Functor instance for IO, and also for things like functions themselves (Reader).
09:11:44 <ski> gfixler : `fmap' is only for "container" types. the sense of "container" used here is quite general, and may surprise you at times
09:12:05 <ski> kvanb_ :)
09:12:11 <gfixler> well, Ints contain a bunch of 1s :)
09:12:22 <donri> containers like Const
09:12:29 <ski> yes, but the type you make an instand must be *generic*
09:12:56 <gfixler> okay, GenericInts then
09:12:58 <ski> you can't e.g. make strings an instance, because strings only contain `Char's
09:13:38 <ski> you can make the list type an instance because you have "lists of", i.e. you can have lists of *any* (concrete) type the user wishes
09:13:43 <gfixler> maybe we shouldn't dive too far into the edge cases mere seconds after I started to grok functors :)
09:13:46 <ski> similarly for `Maybe'
09:14:25 <ski> if `GenericInt' would be an instance of `Functor', it must be possible to say `GenericInt Int' and `GenericInt Bool', `GenericInt String', and so on
09:14:41 <gfixler> I see
09:15:04 <ski> the thing that is an instance of `Functor' must be a type *function*, a *generic* type
09:15:10 <gfixler> so to sum up all that we went over, what is the functor itself?
09:15:19 <gfixler> it's a few things
09:15:30 <gfixler> it's the fmap
09:15:43 <gfixler> and the instance of the Functor class?
09:15:46 <ski> a functor is a type (function) `f', together with an implementation of `fmap :: (a -> b) -> f a -> f b' for it (satisfying the two laws)
09:16:13 <ski> we tell Haskell these are related by using the `instance' keyword to make an instance declaration of the type class `Functor'
09:17:00 <ski> sometimes if you say "the functor `Blah'" you mean both the type and the corresponding `fmap'. sometimes you just mean the type
09:17:02 <gfixler> but isn't the f left up in the air until you call fmap and pass it in?
09:17:11 <ski> yes
09:17:15 <gfixler> ok
09:17:23 <gfixler> it's like a placeholder in the definition
09:17:49 <ski> but the compiler can see, at compile-time, what's going to flow into `fmap', and so can select the appropriate version of the possibly several overloaded definitions to use
09:17:57 <gfixler> I did it! I asked a question, and the answer was a simple "yes"
09:18:04 * ski grins
09:18:49 <ski> for a use of `fmap', the `f' is up in the blue until one can see enough of the context that determines which `f' to use
09:19:31 <ski> for a specific implementation of `fmap' (inside an `instance' declaration), we already know which `f' we're talking about (it's the one we're attempting to make an instance of `Functor' for, for the current `instance' declaration we're attempting to write)
09:19:42 <ski> anyway ..
09:19:52 <ski> you can see how one can use e.g.
09:20:04 <ski> > fmap exp [0,1,2,3]
09:20:05 <lambdabot>  can't find file: L.hs
09:20:14 <ski> @botsmack
09:20:14 <lambdabot> :)
09:20:22 <ski> > fmap exp [0,1,2,3]
09:20:24 <lambdabot>  [1.0,2.718281828459045,7.38905609893065,20.085536923187668]
09:20:39 <gfixler> ski: you typed the same thing
09:20:47 <gfixler> smacking it works?
09:20:49 <ski> yes, sometimes lambdabot is a bit glitchy
09:21:06 <prophile> smack my bot up
09:21:21 <ski> i think it's probably because someone was attempting to evaluate something at the same time, in another channel, or in private
09:21:32 <ski> @help botsnack
09:21:32 <lambdabot> botsnack. Feeds the bot a snack
09:21:57 <gfixler> @help botcrack
09:21:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:22:01 <gfixler> oh well
09:22:02 <pjdelport> gfixler: The f may remain unconstrained if the context doesn't determine which instance to use. So for example:
09:22:07 <pjdelport> :t fmap (+1)
09:22:08 <lambdabot> (Num b, Functor f) => f b -> f b
09:22:21 <pjdelport> :t sum . fmap (+1)
09:22:21 <lambdabot> Num c => [c] -> c
09:22:52 <ski> (here's a bunch of pictures of lambdabot, btw : <http://kejo.be/ELIS/haskell-blah_lambdabotContest.html>)
09:23:15 <pjdelport> Note how composing sum with it constrained the Functor f) => f b to just [c]
09:23:26 <adas> http://lpaste.net/106967
09:23:30 <pjdelport> Because sum only takes a list: sum :: Num a => [a] -> a
09:23:39 <adas> could someone please tell me what is wrong? ^^^^^
09:24:23 <ski> gfixler : so we've seen how to "lift" a function operating on elements into a function operating on every element of "containers", and then applying that to an example "container" (here a list)
09:25:21 <ski> gfixler : but what if you want to do that with a two-argument function ? i.e. you want to pass in a function taking two elements as inputs, and get back a function taking *two* "containers" as inputs ?
09:25:35 <ski> that's what applicative functors solve
09:25:40 <gfixler> ah ha
09:25:53 <ski> (and if you can do two, then you can do more as well, of course)
09:26:12 <gfixler> of course, but I can't do it now, I have so much to digest already!
09:26:13 <ski> gfixler : of course, it's not obvious how we should "correlate" elements from the two input "containers"
09:26:15 <adas> http://lpaste.net/106967
09:26:38 <gfixler> I need some time to play and absorb
09:26:50 <ski> if they have the same shape, we could try coupling elements that have corrsponding positions, and apply the element-wise function to each such pair of elements, one taken from one container, one from the other
09:27:20 <ski> another option is simply to try to combine every possible element of the first collection with every possible element of the second collection
09:27:23 <ski> compare :
09:28:09 <ski> > liftA2 (+) (ZipList [0,1,2]) (ZipList [10,20,30])
09:28:11 <lambdabot>  ZipList {getZipList = [10,21,32]}
09:28:13 <ski> with
09:28:20 <ski> > liftA2 (+) [0,1,2] [10,20,30]
09:28:22 <lambdabot>  [10,20,30,11,21,31,12,22,32]
09:28:34 <ski> @type fmap
09:28:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:28:37 <ski> @type liftA2
09:28:38 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:28:46 <ski> note the analogy between these two
09:29:12 <ski> gfixler : ok, i just wanted to give you this last as a teaser. i'll stop now :)
09:29:25 <gfixler> ski: phwew! I was starting to sweat
09:29:44 <gfixler> this has been fantastic, easily the best conversation(s) I've had in I don't know how long
09:29:53 <gfixler> I'll definitely be back soon
09:29:56 * ski bows
09:29:59 <gfixler> but now I need to sleep!
09:30:04 <ski> *nod*
09:30:04 <gfixler> and dream about composition
09:30:08 <ski> hehe
09:30:15 <gfixler> thanks everyone!
09:30:26 <ski> yw
09:31:35 <hexagoxel> adas: why the spam? in the first version, you ignore the argument "\_ -> .." so the action is not executed.
09:32:53 <pjdelport> adas: In other words, in the first version, you only end up with (outputStrLn ""), and not (projectView mp >> outputStrLn "")
09:34:03 <adas> pjdelport: but in the first version , projectView is being used..
09:34:36 <ski> @src unless
09:34:37 <lambdabot> unless p s = if p then return () else s
09:34:40 <ski> adas ^
09:34:58 <hexagoxel> > let x = print 42 in 1
09:35:00 <lambdabot>  1
09:35:10 <pjdelport> adas: It gets applied, but then thrown away; it doesn't get used or seen by mapM_ unless you bind it as part of the result value (that is, what >> does).
09:35:21 <hexagoxel> is <print> used here?
09:35:30 <adas> hexagoxel: nope
09:35:38 <adas> hexagoxel: just bound to x
09:35:46 <hexagoxel> you basically do the same thing
09:36:13 <hexagoxel> when you compose, but \_ -> ...
09:36:25 <hexagoxel> you could say \x -> outputStrLn ""
09:37:08 <ski> adas : `((\_ -> outputStrLn "") . projectView . Just) blah' simplifies to `(\_ -> outputStrLn "") (projectView (Just blah))', which simplifies to just `outputStrLn ""'
09:37:34 <hexagoxel> > let _ = print 42 in print 2 -- maybe closer to your example
09:37:35 <lambdabot>  <IO ()>
09:37:38 <pjdelport> adas: Consider: mapM_ ((\_ -> putStrLn "") . print) [1..5]   versus   mapM_ (\n -> print n >> putStrLn "") [1..5]
09:37:40 <ski> (where `blah' would be whatever is passed by `mapM_' to your argument function `(\_ -> outputStrLn "") . projectView . Just')
09:37:43 <hexagoxel> meh lambdabot
09:38:10 <tulcod> how do i set up emacs to work properly in my cabal-based project that uses c2hs?
09:38:14 <pjdelport> adas: The first version constructs print actions, but then throws them away without executing them; the second actually executes each print n.
09:38:42 <tulcod> in particular, i'd like to be able to load it into the interactive thing (inferior-haskell-mode)
09:39:06 <ski> `IO'-actions are only executed when they are incorporated into the whole "ambient" `IO'-action -- which "leads" back up to the `main' definition
09:39:30 <ski> if an `IO'-action isn't somehow made part of `main' (directly or indirectly), then it won't be executed
09:39:57 <ski> (in GHCi, you can also explicitly give a "starting" `IO'-action, similar to `main' in a stand-alone program)
09:40:28 <pjdelport> adas: You can restate your first version as: mapM_ ((>> outputStrLn "") . projectView . Just) (init p)
09:40:28 <adas> so this should work ........ (\x -> outputStrLn "" >> x) . projectView . Just)  ?
09:40:30 <ski> *evaluating* an `IO'-action isn't enough to *execute* it
09:40:43 <ski> adas : .. and in your case, you're not even evaluating it
09:41:20 <pjdelport> adas: Right, except you'll want (>> outputStrLn "") instead of (outputStrLn "" >>) if you want the outputStrLn to happen after the projectView.
09:41:40 <ski> adas : rather `(\x -> x >> outputStrLn "") . projectView . Just)', if you want the same ordering as in the latter example code at the paste
09:41:45 <adas> thanks all those that helped.. i now understand.. so simple yet so subtle
09:42:09 <ski> adas : if you want to, you could write that as `(>> outputStrLn "") . projectView . Just'
09:42:14 <adas> i don't think i've stopped thinking imperatively .. thats the problem
09:42:50 <adas> i assumed projectView will execute when it is encountered..which is the behaviour in an non-lazy language
09:42:52 <ski> here's how i would (slightly) rewrite your `projectView' :
09:43:02 <ski>   projectView :: Maybe String -> InputT (StateT Sessionstate IO) ()
09:43:10 <ski>   projectView Nothing = do
09:43:16 <ski>       ss <- lift get
09:43:26 <ski>       let p = sessionProjects ss
09:43:43 <ski>       unless (L.null p) $ do
09:44:19 <ski>           forM_ (init p) $ \s ->
09:44:41 <ski>               projectView (Just s)
09:44:48 <ski>               outputStrLn ""
09:44:59 <ski>           projectView (Just (last p))
09:45:22 <adas> looks a lot better
09:45:24 <ski> (sorry, `\s ->' should be `\s -> do' there)
09:46:28 <ski> (though i might use two-space indentation instead of four-space ..)
09:48:56 <pjdelport> ski: Probably better to use lpaste for that
09:49:24 <ski> adas : "i assumed projectView will execute when it is encountered" -- execution isn't the same as evaluation in Haskell, though other languages mix them up
09:50:15 <zomg> haskell probably didn't get spanked enough as a kid because it's so lazy
09:51:37 <ski> adas : that's not, directly, about the non-strictness of Haskell, but rather about the clear division between evaluating expressions to reach values, and executing actions for effect (which could in principle also be adopted in a strict language, which evaluated function arguments before calling a function)
09:52:04 <ski> zomg : didn't you know laziness is a virtue ? ;)
09:53:08 <pjdelport> (Obligatory mention that Haskell itself is just non-strict, not lazy: implementations may use lazy evaluation or any other non-strict evaluation strategy.)
09:54:17 <pjdelport> (And also that the lack of side effects is because of purity / referential transparency, not laziness or non-strictness as such.)
09:54:46 <adas> ill be reminding myself for awhile now .. that values are evaluated. and effects are executed. no value. no effect.
10:00:04 <ski> you first need to evaluate an action (at least to some extend), before executing it, to know *what* action you're supposed to take, i.e. to know what effect to perform
10:00:43 <ski> so, executing an action (at least to some extent) necessarily involves evaluating the action (determining what the action really is)
10:00:55 <ski> (and this happens automatically)
10:01:25 <ski> but merely evaluating an action isn't enough for executing it (and the former won't cause the latter)
10:04:02 <adas> thanks for the clarification
10:04:11 <Javran> :t <|>
10:04:12 <lambdabot> parse error on input ‘<|>’
10:04:21 <ski> @type (<|>)
10:04:22 <lambdabot> Alternative f => f a -> f a -> f a
10:04:27 <adas> @src when
10:04:28 <lambdabot> when p s = if p then s else return ()
10:04:33 <adas> @src unless
10:04:33 <lambdabot> unless p s = if p then return () else s
10:04:54 <Javran> @hoogle Alternative f => [f a] -> f a
10:04:55 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:04:55 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:04:55 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:05:28 <ski> @type foldr (<|>) empty
10:05:29 <lambdabot> Alternative f => [f a] -> f a
10:06:03 <ski> `asum' is the general case
10:06:49 <ski> @type F.foldr (<|>) empty  -- is probably the implementation of `asum'
10:06:50 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
10:07:20 <Javran> ski: I see, what if I want to factor out a <|> b <|> c .... in parsec?
10:07:55 <pjdelport> asum [a, b, c] ?
10:08:32 <Javran> pjdelport: I guess so
10:08:34 <ski> yes, or the explicit `foldr'
10:09:12 <Javran> does order matter? say the list is [try a, try b, try c] ...
10:09:51 <Javran> oh that depends on the associativity of <|>
10:10:41 <tulcod> chrisdone: is there a reason shm doesn't install shm-case-split?
10:11:31 <tulcod> chrisdone: ah, i think i need to update :)
10:12:03 <seydar> so i'm still nubbing along and reading up on STM, but my question is: what are the problems holding back STM? why haven't people congregated around a single concurrency method?
10:13:42 <pjdelport> seydar: Different concurrency tools are better or worse at different problems; there usually isn't a universally-applicable approach.
10:14:04 <seydar> pjdelport: can you give me and example or point me somewhere that has examples?
10:14:29 <seydar> because up till now concurrency tools are just different types of hammers for all the nails i have
10:14:54 <pjdelport> seydar: I'm not sure offhand, but you can read http://chimera.labs.oreilly.com/books/1230000000929 online (if you haven't already)
10:20:13 <seydar> pjdelport: AHHHHHHHHHHHHHHHH STM can't do IO because shit has to be able to be rolled baaaaaaaaaaaack i geeeeeeeeeet it
10:20:35 <seydar> so if i'm doing anything with IO, STM is out of the question. if i'm not touching IO, then STM is suitable
10:23:01 <pjdelport> seydar: You can always have an STM transaction return an IO action to execute after it completes.
10:23:27 <dwcook> seydar, what gave you the impression that STM is being "held back"?
10:23:38 <seydar> i'm reading http://research.microsoft.com/pubs/74063/beautiful.pdf right now (which is actually pretty clear)
10:24:19 <seydar> dwcook: i dunno, i guess that there were "problems" with it, like not being able to do IO, and i just figured that all things should have no problems ever
10:24:39 <dwcook> seydar, I'd call it a feature not being able to do arbitrary I/O.
10:25:38 * Hodapp tries to figure out why the name 'dwcook' is familiar...
10:25:50 <dwcook> Hodapp, possibly because I talk in here relatively often. :)
10:26:07 <Hodapp> but I don't.
10:26:10 <dwcook> Ah.
10:26:51 <dwcook> seydar, take for example pure evaluation of expressions. It was intentionally disallowed that you should be able to execute arbitrary I/O from one so as to increase composability and ability to reason. I think there is some of that advantage in STM as well.
10:27:18 <pjdelport> You can always unsafePerformIO (but you don't want to. :)
10:29:01 <dwcook> Hodapp, I used to op in ##javascript, I think that might be where you've seen my nick.
10:29:18 <Hodapp> perhaps.
10:30:04 <parc> seydar: didn't hear the beginning of the conversation, but there are ways to do deterministic concurrency without needing IO if that's all you needed, like with https://hackage.haskell.org/package/lvish
10:30:30 <dwcook> I wasn't present for the original statement either, I just reviewed the logs
10:31:41 <ij> Is there some SDL{,-gfx} version that works on 7.8.2 somewhere?
10:32:40 <seydar> parc: i guess the conversation derives from my frustration with the many concurrency tools that we have nowadays. i feel like i'm going shopping and always talking to used car salesman (unrelated note: the guy i bought my car from was really helpful and nice)
10:33:01 <seydar> there are so many ways to do concurrency, and i just don't know (yet) which one is good for which job
10:33:34 <monochrom> car salespeople are still better than computer salespeople
10:33:52 <Hodapp> Let's pretend that threads and locking primitives are all anyone needs.
10:34:26 <monochrom> the common joke is: what's the difference between them? answer: the car salespeople know what lies they tell
10:34:43 <seydar> dwcook: so STM has the /feature/ of not being able to do arbitrary IO (which i now agree with you on). then is there any reason i shouldn't be using STM all the time from different fork'd threads?
10:35:01 <parc> seydar: yeah, haskell feels like that sometimes. MVars, TVars, cloud haskell processes, IVars, LVars, probably a bunch i haven't heard of
10:35:12 <ij> monochrom: What a great joke!
10:35:25 <ij> (not sarcasm)
10:35:36 <monochrom> yeah I like it too
10:35:56 <dwcook> seydar, use the smallest feature set necessary, then, if you need to compose it with something more featureful, promote it. (This is a paraphrasal of something Tekmo told me, which I've found to be useful.)
10:36:36 <monochrom> you shouldn't allow too many shared variables. this is why you shouldn't use STM all the time. or any communication or synchronization thing all the time.
10:37:32 <dwcook> Although I suppose in the case of STM versus IO there isn't necessarily a clear "smaller feature set".
10:37:34 <parc> seydar: i've read if you construct atomic stm actions that take too long they can block i think. when one interferes with another they have a sort of `undo` button to prevent data races, but you can get the situation where two run, block each other, undo, then both repeat
10:38:58 <seydar> i'm trying to learn more about concurrency by writing a chat program and then implement the concurrency and chat logs in different manners. so far i've just done channels, and i'm planning on doing STM next
10:39:24 <seydar> but i'm still not satisfied with my current program because i just don't think it's pretty enough. it doesn't feel clear enough
10:39:39 <dwcook> seydar, in that case check out TChan. It's an implementation of channels using other STM features.
10:40:12 <dwcook> seydar, you'll learn how to do pretty as you get more used to the library, I imagine.
10:40:42 <dwcook> For now I'd suggest doing the most obvious thing (sometimes the obvious thing is ugly).
10:40:55 <parc> get the the parallel and concurrent haskell book if you don't have it already. it is very excellent
10:41:34 <Adeon> there's a chapter in the concurrency book about STM
10:41:40 <dwcook> I found a certain chapter in, I think it was Real World Haskell, useful regarding concurrency.
10:41:41 <Adeon> it explains some things about what's expensive in STM
10:42:50 <dwcook> Here's an entire chapter on STM: http://book.realworldhaskell.org/read/software-transactional-memory.html
10:42:59 <seydar> thank you
10:43:12 <dwcook> There are also other chapters in that book of interest, read the TOC
10:44:10 <tolt> seydar: If no one else has mentioned it, in the parallel and concurrent book there is an implementation of a chat server.
10:45:07 <Adeon> I would recommend the parallel and concurrent book over RWH if interest is on concurrency specifically
10:47:01 <tolt> I definitely agree. RWH is a great book but I understood a lot more after reading the parallel and concurrent book. That might have just been that I was more experienced.
10:47:37 <parc> is there an extension that allows class declarations like `class X f (**)` instead of `class X f p`. ghci doesn't suggest anything, but i saw in a paper where a guy had declarations like that. tried type operators, but no luck
10:51:54 <seydar> you guys are awesome, i'm gonna buy the parallel and concurrent book right now along with an aloha shirt
10:52:06 <Adeon> well it's available online as well
10:52:07 <seydar> this is the end of my battery life though, so it looks like i'm going to die
10:52:20 <seydar> tell my wife i'm an orangutan
10:52:47 <Adeon> the first recorded conversation with an orangutan
10:55:31 <empyreal> hello.
10:56:10 <empyreal> really simple question. "cabal sandbox init" tells me sandbox not found.
10:56:27 <empyreal> what am I doing wrong with that? I don't see anything on google
10:57:11 <matematikaadit> empyreal: could you paste the full error message (and the command that produce that). that sound weird.
10:57:20 <matematikaadit> @lpaste
10:57:20 <lambdabot> Haskell pastebin: http://lpaste.net/
10:57:43 <empyreal> matematikaadit: one line
10:57:45 <empyreal> cabal: unrecognised command: sandbox (try --help)
10:57:46 <parc> also cabal -V for the version number
10:58:06 <matematikaadit> empyreal: maybe you're using old version of cabal.
10:58:28 <empyreal> matematikaadit: thought of that, ran yum update cabal* and all latest version
10:58:34 <tulcod> empyreal: namely...?
10:58:44 <matematikaadit> empyreal: try cabal -V
10:59:00 <empyreal> cabal-install version 1.16.0.2
10:59:15 <tulcod> empyreal: yeah that's a bit old
10:59:18 <matematikaadit> empyreal: sandbox was in >= 1.18
10:59:52 <empyreal> wtf fedora, get your shit together. :)
11:00:06 <tulcod> empyreal: maybe you're running an old version of fedora?
11:00:07 <empyreal> thanks guys. guess I'll need to find newer rpm sources.
11:00:38 <ski> parc : used to work, i think
11:00:49 <parc> ski: :(
11:01:29 <ski> then for some reason people decided they wanted all operators in types to be type constructors (as opposed to type variables), as opposed to only those starting with `:' (and also `->', of course)
11:01:38 <Pythonfant> empyreal: just update cabal with cabal
11:01:47 <Pythonfant> cabal install cabal-install
11:01:54 <ski> i don't recall whether you can get back the old behaviour with some option/language extension
11:04:05 <parc> ski: well i guess i can use type operators to make p infix at least :/
11:06:18 * ski liked to be able to type `Arrow (~>) => (a ~> b) -> (a ~> (a,b))', e.g.
11:07:05 <Xenasis> How do I import things? The string "import System.Random" didn't work
11:07:23 <ion> What does “didn’t work” mean?
11:07:30 <Xenasis> (and it looked to be of that form when I looked online)
11:07:41 <Xenasis> <no location info>:
11:07:43 <Xenasis>     Could not find module ‘System.Random’
11:07:45 <Xenasis>     It is not a module in the current program, or in any known package.
11:07:47 <tolt> Xenasis: System.Random is part of the random package. You have to have that installed.
11:07:53 <Xenasis> ...ah
11:08:01 <Xenasis> is there a module that comes with Haskell?
11:08:05 <Xenasis> I didn't realise it was external
11:08:24 <dagano> > let toTup (a:b:c) = (a,b,c)
11:08:25 <lambdabot>  not an expression: ‘let toTup (a:b:c) = (a,b,c)’
11:08:34 <ion> It *should* come with GHC, i think.
11:08:36 <dagano> either way .. why does that not give me what I desire?
11:08:43 <dagano> [1,2,3] -> (1,2,3)
11:08:46 <Xenasis> my GHCI is updated fully
11:09:00 <ion> > let a:b:c = [1,2,3] in (a, b, c)
11:09:02 <lambdabot>  (1,2,[3])
11:09:06 <tolt> Yeah. That's usually done with cabal. Do you have cabal installed?
11:09:09 <ion> > let a:b:c:d = [1,2,3] in (a, b, c, d)
11:09:10 <lambdabot>  (1,2,3,[])
11:09:12 <Xenasis> I do have Cabal
11:09:16 <Xenasis> but it's fine
11:09:19 <Xenasis> I'll look elsewhere
11:09:26 <Xenasis> I want to do it with base Haskell and no libraries
11:09:31 <Xenasis> external libraries
11:09:33 <Xenasis> I mean
11:09:59 <tolt> Oh. Alright. I'm not sure if there is a random number gen in base.
11:10:07 <dagano> ion:  thanks .. and to remove the []?
11:10:08 <Xenasis> Really?
11:10:11 <Xenasis> That's kind of surprising
11:10:18 <Xenasis> I guess I could probably call C somehow
11:10:22 <ion> > let [a,b,c] = [1,2,3] in (a,b,c)
11:10:24 <lambdabot>  (1,2,3)
11:11:08 <tolt> A lot of things in haskell are broken up into libraries like that. Base would get really big if it had everything in it.
11:11:37 <Xenasis> Still, randomness isn't exactly something off-the-beaten-track
11:12:01 <dspies> I'm having trouble with template haskell and type families
11:12:19 <dspies> I just started learning template haskell and I'm trying to generate a bunch of boilerplate declarations
11:12:24 <tulcod> Xenasis: why don't you want to use libraries?
11:12:34 <dspies> but the compiler's giving an error
11:13:05 <tulcod> Xenasis: haskell basically is based around the idea of having a huge amount of small libraries
11:13:32 <Xenasis> I do want to use libraries in the future but I shouldn't have to use a library for such a trivial program
11:13:48 <Xenasis> I'd use libraries if I wanted quadtrees or GTK or something
11:14:08 <tulcod> Xenasis: well maybe that's what you're used to from other languages, but haskell is not like that
11:14:22 <Xenasis> Still, I'd rather my code was portable
11:14:29 <tulcod> the libraries /are/ portable
11:14:36 <Xenasis> I'll look into another way to do it, but thanks for your advice.
11:14:41 <Lutin`> the random library is written in Haskell
11:14:44 <Lutin`> Plain old Haskell
11:14:49 <Lutin`> and it's 24 KB
11:14:53 <dspies> What's going on here?
11:14:54 <tulcod> Xenasis: trying to avoid using these libraries is *very* pointless
11:14:55 <dspies> http://lpaste.net/106970
11:14:57 <Lutin`> It's included in the Haskell Platform
11:15:03 <CindyLinz> Xenasis: You can also choose to copy and paste code from libraries XD
11:15:12 <Xenasis> that would be silly
11:15:15 <CindyLinz> Xenasis: Then it works XD
11:15:20 <int3__> I'm trying to write a Scrabble game AI, and to find the best move I calculate a bunch of values per square of the board. As a move is made, these values have to be recomputed... but only for some of the squares. Instead of writing code to mark certain squares as 'dirty', would FRP be a good solution? I'm looking through a couple of libraries now and they are mostly focused around GUI programming, so I'm not sure if I'm looking at the best sol
11:15:20 <int3__> ution to the problem
11:15:30 <int3__> like, I don't need to interact with the IO monad or anything
11:15:38 <Xenasis> the point is - I shouldn't need a library for something so trivial that's probably easy to do in base Haskell
11:16:24 <tulcod> Xenasis: why.
11:16:35 <Lutin`> 'so trivial'
11:16:38 <tulcod> what is your problem with libraries.
11:16:44 <CindyLinz> Xenasis: Didn't you accept the standard library? Something like glibc in C..
11:17:02 <Xenasis> Right, there's going to be something in the standard library
11:17:25 <Xenasis> I'm not trying to create some sort of crypto program
11:17:26 <lispy> int3__: You could express that several ways. FRP is one of them.
11:17:36 <Xenasis> I don't want anything crazy for a simple program
11:17:40 <Xenasis> just something from the stdlib
11:17:51 <tulcod> dspies: i think the problem is with quoting an instance whose class varies
11:17:55 <Xenasis> I (wrongly) assumed System.Random was in the stdlib
11:17:55 <tulcod> dspies: eh, type*
11:17:57 <int3__> lispy: what are the other ways?
11:17:58 <Xenasis> but I'll look elsewhere
11:18:12 <lispy> int3__: comonads and loeb
11:18:19 <lispy> int3__: or just directly :)
11:18:26 <CindyLinz> Xenasis: There are old Random.. # http://www.haskell.org/ghc/docs/latest/html/libraries/
11:18:29 <int3__> lispy: cool, I'll read up on them :)
11:18:37 <CindyLinz> Xenasis: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98-2.0.0.3/Random.html
11:18:41 <lispy> int3__: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
11:18:57 <lispy> int3__: http://www.cl.cam.ac.uk/~dao29/publ/codo-notation-orchard-ifl12.pdf
11:19:10 <tulcod> dspies: if you write the instance explicitly (ie. without quoting, but using explicit constructors) then i think it should work
11:19:11 <dspies> tulcod: I don't understand.  I just started learning template haskell today
11:19:12 <Xenasis> hmm, Random doesn't seem to be in the stdlib either
11:19:15 <int3__> lispy: awesome, thanks!
11:19:23 <Xenasis> I guess it's under a different name
11:19:34 <tulcod> dspies: well the problem is that ghc doesn't understand.
11:19:52 <tulcod> dspies: actually no. the problem is that you wrote "instance" inside the instance.
11:19:53 <CindyLinz> Xenasis: Why you said that @@" Everything listed here is in the stdlib.. # http://www.haskell.org/ghc/docs/latest/html/libraries/
11:20:08 <dspies> tulcod: Where am I supposed to write instance?
11:20:11 <Lutin`> haskell98 is a hidden package
11:20:16 <tulcod> dspies: ugh i'm talking bullshit, second
11:20:18 <dagano> > (\[a,b,c] -> (a,b,c)) [1,2,3]
11:20:19 <lambdabot>  (1,2,3)
11:20:23 <CindyLinz> oh. Then just open it XD
11:20:29 <Xenasis> huh
11:20:33 <Xenasis> import Random
11:20:36 <Xenasis> doesn't work o.o
11:20:36 <dagano> i get a non-exhaustive pattern error for the above lambda. how can i avoid this?
11:20:43 <Xenasis> What am I doing wrong?
11:21:02 <athan> Are there any types that can contain varying subtypes like a tuple, but unordered?
11:21:03 <Xenasis> from googling, I did find that "import Foo" was how it was done
11:21:08 <Lutin`> Xenasis: The reason it's not in the standard library anymore is the point of the standard library is not the same as in a language such as Python
11:21:09 <Xenasis> http://www.haskell.org/haskellwiki/Import
11:21:13 <quchen> dagano: you can do "\x -> case x of { [a,b,c] -> ...; _ -> ... }"
11:21:24 <quchen> Or with LambdaCase, you can abbreviate "\x -> case x of" as "\case"
11:21:25 <Xenasis> According to CindyLinz, it /is/ in the stdlib
11:21:30 <k00mi> Xenasis: import System.Random
11:21:31 <ion> dagano: “\xs -> case xs of [a,b,c] -> …; {- other pattern matches here -}” or “let f [a,b,c] = …; f {- other pattern matches here -} in f”
11:21:39 <Xenasis> k00mi: I did, but got an error
11:21:44 <Lutin`> Xenasis: It used to be. Back with Haskell98
11:21:49 <dagano> do i just need to cover the empty list?
11:21:51 <Xenasis>     Could not find module ‘System.Random’
11:21:53 <Xenasis>     Use -v to see a list of the files searched for.
11:21:55 <Xenasis> Failed, modules loaded: none.
11:21:57 <Lutin`> But when 2010 came out they moved it to a separate package
11:22:10 <pjdelport> int3__: Don't you just want an Array for the board?
11:22:12 <tulcod> dspies: i'm getting "parse error on input instance". what ghc version are you running?
11:22:19 <ion> dagano: You’ll need to cover everything that does not match [a,b,c]
11:22:20 <k00mi> Xenasis: oh right, you need the random package now
11:22:35 <dspies> tulcod: 7.6.3
11:22:40 <CindyLinz> Xenasis: type this in commandline:  ghc-pkg expose haskell98
11:22:46 <Xenasis> Same problem with "import Random"
11:22:52 <CindyLinz> Xenasis: Maybe you need to "sudo"
11:22:57 <dspies> tulcod: Maybe it's because I'm compiling in Eclipse
11:23:03 <dagano> ion: "everything" .. like lists of all possible lengths?
11:23:05 <pjdelport> int3__: When you update an Array, only the changed values actually change; already-evaluated values stay evaluated.
11:23:07 <quchen> You should probably not expose Haskell98 as a beginner.
11:23:07 <dspies> tulcod: And there's a bunch of other stuff too
11:23:10 <tulcod> dspies: actually, i'm an idiot, that's supposed to be "parse error on input 'type'"
11:23:11 <Lutin`> Xenasis: because there are many different ways to implement random number generation so they felt it would be better not to prescribe a certain way and move it to an external package
11:23:19 <Xenasis> I'm using GHCI in Emacs, not command line
11:23:21 <CindyLinz> Xenasis: then you should import Random
11:23:21 <tulcod> dspies: yeah you may wanna update ghc
11:23:22 <Xenasis> but I guess I can try that
11:23:36 <Lutin`> Xenasis: Do you know what Haskell Platform is?
11:23:45 <pjdelport> int3__: FRB and things like Loeb circularity might not be relevant to what you're doing.
11:23:52 <CindyLinz> Xenasis: It will alter the config of the global package database
11:23:55 <dspies> tulcod: This is the one from Ubuntu 14.04 repo
11:24:10 <Xenasis> Lutin`: I do, but it's not very well updated
11:24:11 <int3__> pjdelport: yes, but I need to figure out which values to update
11:24:15 <tulcod> dspies: latest is 7.8.2
11:24:19 <ion> dagano: Yes, apart from three (which is matched by [a,b,c]).
11:24:22 <Xenasis> Now I'm getting - http://lpaste.net/4834181550746632192
11:24:27 <Xenasis> hm
11:24:27 <dspies> tulcod: Ok, I'll try that
11:24:29 <tulcod> dspies: template haskell is a relatively new feature so i'm sure they made some changes there
11:24:37 <Lutin`> Xenasis: Yes I know, but the point is in includes many libraries that haskellers may consider standard
11:24:37 <pjdelport> int3__: What does it depend on?
11:24:37 * hackagebot jmacro 0.6.9 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.6.9 (GershomBazerman)
11:24:51 <int3__> pjdelport: I think FRP or something like that is what I'm looking for -- I'd like to express stuff like 'recompute value at (x, y) if value at (x', y') changes'
11:24:53 <Lutin`> Xenasis: But aren't included in the base install
11:24:57 <Lutin`> Xenasis: random is one of those
11:24:58 <CindyLinz> Xenasis: the purpose of the command "ghc-pkg expose haskell98" is to unhide the package
11:25:02 <quchen> "ghc-pkg expose haskell98" is terrible advice. Xenasis: You want System.Random, and maybe a more up-to-date tutorial.
11:25:05 <Xenasis> Yeah, I typed it
11:25:07 <Lutin`> CindyLinz: Please stop suggesting that
11:25:13 <int3__> pjdelport: the spreadsheet analogy seems like what I'm looking for
11:25:14 <Lutin`> CindyLinz: It's hidden for a reason
11:25:14 <Xenasis> I guess I restart the GHCI
11:25:24 <tulcod> dspies: anyway, even with this later ghc, it still doesn't work.
11:25:38 <CindyLinz> Lutin`: But Xenasis deny to use anything outside of the stdlib ^^|
11:25:49 <dspies> tulcod: But does it not work because of some problem with template haskell or because I don't know what I'm doing?
11:25:59 <tulcod> dspies: quoting is sort of a way to do stuff in TH more quickly - it doesn't always work, especially when you're doing stuff like defining classes and types and all too dynamic stuff
11:26:01 <dspies> tulcod: and I need to write it differently
11:26:12 <Xenasis> http://lpaste.net/8782177259449483264
11:26:13 <tulcod> dspies: i'm not sure. i don't know if you /can/ do this with quoting.
11:26:17 <Xenasis> now this happens
11:26:19 <Xenasis> huh.
11:26:21 <tulcod> dspies: you can definitely do it without. but that's a bit of a PITA
11:26:36 <quchen> Xenasis: "ghc-pkg hide haskell98". Revert that "expose", quickly.
11:26:52 <quchen> And use System.Random, as many others have repeatedly suggested.
11:26:52 <dspies> tulcod: How do I do it without? (It can't be as much of a PITA as the alternative)
11:26:53 <tulcod> dspies: you'd have to write stuff like InstanceD [] t [yadda yadda]
11:27:00 <Xenasis> Well it works now but I guess I don't get my Random
11:27:06 <Xenasis> eurgh, I'll just try writing something else
11:27:08 <tulcod> dspies: ie. you explicitly write down the abstract syntax tree
11:27:24 <tulcod> dspies: (quoting gives you a way to do so in a WYSIWYG kind of way)
11:27:46 <tulcod> dspies: this will be your reference http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH.html
11:28:17 <athan> Does anyone know of a good unordered tuple / pair package? I'm stumped
11:28:30 <quchen> What do you mean with "unordered"?
11:28:33 <Lutin`> Xenasis: You could think of haskell98 as a 16 year old version of base, it's not meant to be used except to run old Haskell programs that may not work without modification.
11:28:41 <tulcod> dspies: see e.g. lines 31 and 44 in https://github.com/tulcod/haskell-wayland/blob/master/Graphics/Wayland/Internal/Scanner.chs
11:28:56 <pjdelport> int3__: How general do you want it to be?
11:29:03 <athan> quchen: where (a, b) = (b, a)
11:29:19 <Xenasis> Right, but I don't want code that wouldn't compile on another machine without them downloading the right package
11:29:20 <Xenasis> or whatever
11:29:30 <Lutin`> Most people have random installed
11:29:33 <Xenasis> Most
11:29:34 <quchen> athan: For what do you need that? Maybe there's a better solution
11:29:38 * hackagebot jmacro-rpc 0.3 - JSON-RPC clients and servers using JMacro, and evented client-server Reactive Programming.  http://hackage.haskell.org/package/jmacro-rpc-0.3 (GershomBazerman)
11:29:38 <Xenasis> Most people who use HASKELL
11:29:39 <Lutin`> Everyone has cabal
11:29:40 * hackagebot jmacro-rpc-happstack 0.3 - Happstack backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-happstack-0.3 (GershomBazerman)
11:29:40 <tulcod> dspies: ie. you explicitly write down a haskell object that represents the syntax tree, htat you can then splice into the program
11:29:41 <Xenasis> have random installed
11:29:41 <dwcook> athan, is it that you want an Eq instance that doesn't respect ordering?
11:29:42 * hackagebot jmacro-rpc-snap 0.3 - Snap backend for jmacro-rpc  http://hackage.haskell.org/package/jmacro-rpc-snap-0.3 (GershomBazerman)
11:29:46 <quchen> (I'm not aware of such tuples, athan)
11:29:48 <Lutin`> Xenasis: You can statically compile your programs
11:29:56 <Xenasis> For certain architectures
11:30:11 <athan> quchen: There are a ton of use cases - edges for undirected graphs, I'm using it to make a category instance of a graph arrow
11:30:13 <Xenasis> (unless the ghc has -march, but that's silly)
11:30:25 <Pythonfant> Xenasis: if you want to write software to compile for people who don't use haskell you can't even asume they have ghc installed
11:30:45 <Xenasis> Right, but they shouldn't have to have a billion dependencies for a simple program
11:30:48 <Lutin`> Xenasis: random is a stable library and can be built with every haskell compiler I know of
11:30:49 <athan> dwcook: Hmm... no, ideally I'd like to compose `a -> (a, b)` and `(b, a) -> c`
11:30:58 <quchen> athan: Shouldn't an edge of an undirected graph be (a,a)?
11:31:16 <athan> quchen: If the graph is uni-typed :p
11:31:20 <Xenasis> Regardless of whether it's stable or not
11:31:25 <quchen> Oh, heterographs? Hmm.
11:31:25 <Xenasis> it requires a new package
11:31:33 <Pythonfant> Xenasis: someone who is willing to download the 800mb for ghc won't have a problem with a few kb of packages
11:31:34 <Xenasis> it's another dependency
11:31:37 <athan> quchen: That's a new term! Thanks haha
11:31:38 <dwcook> athan, write a function to "lift" one into the other, perhaps.
11:31:47 <Pythonfant> Xenasis: that's why there are buildsystems
11:31:51 <Xenasis> I believe they will, Pythonfant
11:31:54 <int3__> pjdelport: not sure how to describe generality. I'm just looking for a way to express spreadsheet-type computations elegantly. no need for IO / event handling, which many FRP libraries seem centered around
11:31:55 <athan> dwcook: Hmm, okay.
11:31:56 <CindyLinz> Pythonfant: It's not that fat for ghc only... XD
11:32:01 <tulcod> Xenasis: if you compile your package statically, no one will need a single dependency installed
11:32:11 <Xenasis> I don't like getting my system messy and I don't appreciate it when a program has silly amounts of dependencies
11:32:16 <Xenasis> If /I/ compile my package
11:32:23 <Xenasis> But if someone else wants to, they can't
11:32:23 <Pythonfant> CindyLinz: right, but that's what the arch pkg needs I guess it's similar for other distros
11:32:25 <dwcook> athan, one of the problems is that you don't simply need an unordered tuple, you essentially want a type-level set, which I'm not sure is a thing
11:32:42 <quchen> dwcook: And if it is it's probably something way out in extension land
11:32:48 <pjdelport> int3__: You *probably* can get away with just plain arrays, depending on how exactly you want to express your constraints.
11:32:49 <athan> dwcook: That's what I was thinking :/
11:32:53 <tulcod> Xenasis: packages in haskell are tiny. it's no issue to depend on many stable haskell packages.
11:32:54 <athan> crud
11:33:03 <Xenasis> That's not really the point
11:33:07 <tulcod> Xenasis: so what is?
11:33:09 <athan> well thanks anyway, dwcook & quchen :)
11:33:20 <Xenasis> a lot of people don't like having 100 different packages on their system
11:33:26 <quchen> athan: Do you know how to make an existential list?
11:33:29 <Xenasis> which are pretty much useless
11:33:32 <Xenasis> myself included
11:33:34 <Pythonfant> why do people count the number of dependencies
11:33:36 <Pythonfant> that's stupid
11:33:38 <pjdelport> int3__: You're right that most FRP things focus on a different kind of domain; in pure Haskell, lazy evaluation usually suffices.
11:33:42 <Pythonfant> if any you should measure size
11:33:46 <tulcod> Xenasis: "a lot of people" meaning the developers or the users?
11:33:46 <athan> quchen: Not yet! I know some basics of quantifiers though
11:33:47 <Xenasis> They don't count them, but it makes their package manager more cluttered
11:33:52 <Xenasis> Users, obviously
11:34:02 <tulcod> Xenasis: right, but as we explained, they won't need to
11:34:16 <CindyLinz> But why not System.Random part of the stdlib? @@"
11:34:17 <quchen> athan: Well, it's the basic way to make a "heterogeneous" list. Your graph type might be something in that direction. If you *really* need what you said, that is.
11:34:17 <Xenasis> But users compile software
11:34:22 <Pythonfant> then recommend them to use cabal sandbox init && cabal install and they won't clutter their pkg manager
11:34:32 <tulcod> Xenasis: if they want to compile your program, they'll need to install 800MB worth of GHC
11:34:41 <athan> quchen: Sounds fun :) Thank you!!!
11:34:49 <tulcod> Xenasis: i don't think they'll be much bothered by the kilobytes worth of packages you're depending on additionally
11:34:57 <Xenasis> The size isn't the problem here
11:35:00 <Xenasis> It's the extra packages
11:35:50 <tulcod> so you'd rather have fewer, bigger libraries, for everything on your system?
11:35:53 <Lutin`> Installing a library with cabal does not mean you have to package that library when distributing
11:36:25 <Xenasis> I'd rather users didn't have to install a tonne of packages, right
11:36:43 <Lutin`> I don't see why a user would be building your package from source
11:36:46 <tulcod> well any linux distro will already require them to install a ton of packages
11:36:50 <jmcarthur> Pythonfant: i use dependency count as a rough proxy for how likely the package is to break in the future
11:36:52 <Lutin`> I would consider that person a developer
11:36:56 <Xenasis> Really?
11:37:01 <Xenasis> A lot of people compile stuff from source
11:37:17 <Xenasis> Hell, just look at gentoo or the AUR
11:37:26 <int3__> Xenasis: developers and gentoo users... that's not really 'a lot'
11:37:36 <Lutin`> Which tend to have a lot of builddeps
11:37:36 <int3__> Xenasis: and in both cases you could say that they know what they're in for
11:37:39 <tulcod> Xenasis: anyway, whatever you think of the library ecosystem in haskell, it works good enough and it's not gonna change in the near future
11:37:57 <Xenasis> I didn't criticise the library system, I just want a way to seed randomness without needing additional packages
11:38:04 <Xenasis> But I'll look elsewhere
11:38:35 <tulcod> randomNumberGenerator :: IO Int ; randomNumberGenerator = return 5
11:39:12 <Xenasis> that's not even a function
11:39:28 <Xenasis> I'd appreciate /some/ effort ;P
11:39:31 <dagano> i'm having a lot of trouble writing a function to convert a list to a tuple ... i know it can't be done in the general case because each tuple of a different length is a different type. can anyone offer pointers?
11:39:35 <tulcod> (related http://xkcd.com/221/ )
11:39:54 <Lutin`> Xenasis: Here's a one line Mersenne twister
11:39:56 <Lutin`> [n | p <- [2..], let (n + 1) = 2^p, iterate (\ s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
11:40:11 <Lutin`> oh wait
11:40:15 <Lutin`> that's a prime generator
11:40:22 <CindyLinz>  XD
11:40:33 <Lutin`> wrong file
11:40:59 <tulcod> dagano: what issue are you trying to solve?
11:41:05 <pjdelport> dagano: To do it in general you'll probably need Template Haskell.
11:41:07 <tulcod> dagano: why do you want tuples from lists?
11:41:30 <quchen> athan: http://lpaste.net/106971
11:41:38 <pjdelport> dagano: To do it without that, you can encode n-ary tuples as nested pairs, perhaps.
11:41:38 <quchen> (List of existentials)
11:41:40 <tulcod> dagano: PS, what you're looking for is "dependent types", which haskell (unfortunately, arguably) doesn't have (yet?)
11:43:30 <tulcod> pjdelport: not in a clean way...
11:43:30 <tulcod> pjdelport: unless you mean "something that's actually just another list"
11:43:30 <dagano> i'm building an IntMap representation of a graph and thought tuples would be easier to work with ... every weighted edge could be (u,v,w) .. i guess i could just use a list (u:v:w) but was having trouble with pattern-matching
11:43:30 <int3__> pjdelport: well, here's the problem description: say you place a word on a scrabble board, horizontally across. this will also make one or more words in the vertical direction. so for each square I record what tiles could be placed in that position to form a valid word in the vertical direction. Say, if we have 'AN', then 'P' could be prepended to it. Now if we appended a 'D' to 'AN', then we'd need to recompute our constraint, because 'PAND'
11:43:30 <int3__>  is not a word. I don't think lazy evaluation handles stuff like that...
11:43:52 <athan> quchen: Hmm! This is similar to a Data.Typable's Dynamic solution, right?
11:44:19 <athan> oh wait, this is made with the qualifier!
11:44:23 <athan> quchen: Holy crap
11:45:23 <pjdelport> int3__: For a simple constraint like that, you can just propagate it directly: whenever a tile is placed, update the four next open tiles in each direction, if any.
11:45:45 <pjdelport> You don't need fully general propagation for that.
11:46:48 <Xenasis> hmm, so I guess there's no Unix module in Haskell since it's purely functional?
11:46:50 <pjdelport> (I think it would probably be more complex to express that particular constraint in "pull"-based terms, anyway.)
11:47:31 <monochrom> there is no Unix module. the reason is not purely functional. the reason is there is something better. there is a whole unix lib containing multiple modules.
11:47:31 <tulcod> Xenasis: there's a Posix module
11:47:45 <pjdelport> Xenasis: There are a bunch of Unix-platform-specific OS interfaces, if that's what you mean?
11:48:04 <tulcod> Xenasis: so the library you're looking for kinda depends on what you want to do
11:48:04 <monochrom> in fact it comes with GHC
11:48:19 <int3__> pjdelport: yeah, I know I could do that... but it strikes me as somewhat imperative
11:48:22 <Xenasis> I'll look at the Posix one, but I googled "Unix" and found nothing
11:48:27 <Xenasis> (Since it's called that in OCaml)
11:48:30 <CindyLinz> I think GHC is also MS-Windows friendly XD
11:48:38 <monochrom> that too
11:48:49 <monochrom> on windows, GHC has a whole win32 lib
11:48:53 <tulcod> Xenasis: well "unix" is the name of an operating system from decades ago
11:48:57 <Xenasis> Well, so is OCaml, but Windows systems work differently to Unix-likes
11:49:05 <int3__> pjdelport: I'm aware I'm kind of overengineering this, but if I can write things declaratively that would be more awesome
11:49:07 <pjdelport> int3__: There's nothing wrong with imperative formulations of a problem when that's simpler and more straightforward. :)
11:49:11 <Xenasis> Aye, but Unix-likes live on
11:49:12 <pjdelport> int3__: The updating is still pure.
11:49:19 <CindyLinz> monochrom: Is that because there are people from MS in the GHC core team?
11:49:22 <tulcod> Xenasis: right, in the form of various standards such as Posix :)
11:49:28 <int3__> pjdelport: There's nothing wrong with overengineering if it means I'm learning more tools in the process, right :P
11:49:31 <Xenasis> Well, not all of them comform to Posix
11:49:33 <pjdelport> int3__: It's still declarative; it's just push-based rather than pull-based.
11:49:35 <Xenasis> I'm not sure GNU/Linux does
11:49:36 <monochrom> no, I think it's simply because people want it
11:49:48 <Xenasis> Or maybe it's a BSD?
11:49:50 <Xenasis> something like that
11:49:58 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.7.0.1/index.html
11:50:04 <tulcod> Xenasis: anyway, why do you want such a library?
11:50:06 <Xenasis> Posix is exactly the module I was looking for, anyway
11:50:16 <pjdelport> int3__: Can you declare that constraint in a pull-based way that's shorter or cleaner?
11:50:24 <CindyLinz> monochrom: hmm
11:50:25 <Xenasis> was wondering if it was possible to do Unix-y stuff in Haskell like in OCaml
11:50:31 <Xenasis> it was a lot more elegant than in C
11:51:07 <Xenasis> stuff like "match Unix.fork () with" is fantastic
11:51:13 <monochrom> https://www.google.ca/search?q=haskell+unix
11:51:19 <tulcod> Xenasis: if you want to run processes, there's System.Process
11:51:29 <tulcod> which is more portable
11:51:36 <athan> quchen: Sadly, though, I need to have the discrete types in the type system for simple checking of inclusion, so that (Int, Foo) can't compose with (Int, Bar) :/ But, this helped tremendously. Thank you!!!
11:51:54 <Xenasis> Right, but that's not really what I want it for
11:52:07 <tulcod> Xenasis: out of interest, what do you want to do?
11:52:11 <pjdelport> @hoogle forkProcess
11:52:13 <lambdabot> System.Posix.Process.ByteString forkProcess :: IO () -> IO ProcessID
11:52:13 <lambdabot> System.Posix.Process forkProcess :: IO () -> IO ProcessID
11:52:13 <lambdabot> System.Posix.Process.ByteString forkProcessWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ProcessID
11:52:19 <pjdelport> Xenasis: -^
11:52:26 <Xenasis> I've wrote a lot of OCaml stuff to do silly little tasks that I want
11:52:34 <Xenasis> and to learn Haskell I'm porting them
11:53:04 <pjdelport> athan: Have you looked at the pair encoding of tuples?
11:53:17 <Xenasis> For example, I've an OCaml program that removes spaces from file names recursively
11:53:33 <athan> pjdelport: I'm not sure what that is o.o
11:53:43 <pjdelport> athan: Oh, nevermind, got my questions crossed.
11:54:03 <athan> pjdelport: Like (a, (b, (c, ...)))?
11:54:07 <Xenasis> but I guess I should just port some list functions first, was just wondering if Haskell could do it, as my first search didn't seem to come up with much
11:54:07 <athan> oh okay haha
11:54:22 <Xenasis> other than a module called "Shelly" for shell scripting
11:54:23 <tulcod> Xenasis: (there are OS-independent interfaces to the filesystem)
11:54:40 <athan> I really like shelly
11:54:59 <Xenasis> Right, but a lot of the stuff I have is for Unix-likes
11:55:16 <Xenasis> which is for me, personally, and Unix-likes work different to Windows systems
12:00:51 <Lutin`> Xenasis: There's the directory library if you want portable directory access
12:01:09 <Lutin`> Which has `getdirectoryContents :: FilePath -> IO [FilePath]`
12:02:09 <Lutin`> Here's some examples on usage such as recursively listing directory contents http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html
12:02:31 <Xenasis> Again, I don't really care much about libraries, and I'll just port my OCaml code
12:06:52 <athan> quchen: http://hackage.haskell.org/package/HList-0.3.4.1 :D
12:08:25 <Lily21>  Hi! I give you some videos. I hope you like! http://bit.ly/1qJ2l1C
12:08:40 --- mode: ChanServ set +o monochrom
12:08:44 --- mode: monochrom set +b *!*@37.221.175.38
12:08:44 --- kick: Lily21 was kicked by monochrom (Lily21)
12:09:05 --- mode: monochrom set -b *!*@37.221.175.38
12:09:09 --- mode: monochrom set -o monochrom
12:10:54 <int3__> pjdelport: sorry, had to think for a bit. I think the declarative expression wouldn't be much different -- 'recalculate constraint at position if a new tile is added to one of the four open squares in either direction' -- but this style is more extensible. I think I'll also need to keep track of which squares are valid 'anchor points' for new words. again, I can recalculate this by adding / subtracting anchor points around the last word playe
12:10:54 <int3__> d, but now my 'make a move' function needs to concern itself with updating two extra things. whereas declaratively I would have each of these things depending on one thing, i.e. the state of the board. intuitively, the set of anchor points and the set of board constraints are unrelated, so it seems inelegant to bundle them in one place
12:15:52 <pjdelport> int3__: Are "anchor points" open squares, or something different?
12:16:48 <int3__> pjdelport: open squares adjacent to filled squares
12:17:21 <pjdelport> Ah, right.
12:21:54 <tulcod> Xenasis: (there are OS-independent interfaces to the filesystem)
12:21:57 <tulcod> oops
12:28:11 <Lutin`> I think he left
12:28:39 <dwcook> Ping timed out, in fact, right after the highlight
12:29:19 <Lutin`> On the upside I wrote a one-line RNG
12:29:24 <benzrf> Lutin`: orlu
12:29:25 <Lutin`> @let random max seed=(max*seed'`div`im):(random max seed') where seed'=(seed*ia+ic)`mod`im;ia=3877;im=139968;ic=29573
12:29:26 <lambdabot>  .L.hs:218:45:
12:29:26 <lambdabot>      Ambiguous occurrence ‘random’
12:29:26 <lambdabot>      It could refer to either ‘L.random’, defined at .L.hs:218:1
12:29:26 <lambdabot>                            or ‘R.random’, imported from ‘System.Random’ at .L...
12:29:27 <benzrf> *orly
12:29:29 <Lutin`> oh
12:29:38 <Lutin`> @let rand max seed=(max*seed'`div`im):(rand max seed') where seed'=(seed*ia+ic)`mod`im;ia=3877;im=139968;ic=29573
12:29:40 <lambdabot>  Defined.
12:29:48 <benzrf> > rand
12:29:50 <lambdabot>  can't find file: L.hs
12:29:52 <benzrf> > rand
12:29:53 <lambdabot>  <Integer -> Integer -> [Integer]>
12:29:56 <benzrf> > rand 34 54
12:29:57 <lambdabot>  [24,13,17,12,13,1,6,27,33,32,25,30,16,13,6,19,29,12,1,11,30,22,29,8,8,22,30,...
12:30:03 <benzrf> how predictable is it
12:30:13 <Lutin`> Haven't figured out the cycle length yet
12:30:49 <Lutin`> It's based of the LCG from the fasta benchmark in the benchmarksgame
12:32:57 <qwebirc27201> i have a number of functions of type IO a, IO b etc Is there some way to create a GADT or something so that I can reference the 'a','b'?
12:33:14 <qwebirc27201> this is what i would like to do:
12:33:16 <qwebirc27201> data Op (IO a) = And (Op (IO a)) (Op (IO b)) ((a,b) -> IO ()) |
12:33:25 <qwebirc27201>                  Or (Op (IO a)) (Op (IO b)) (a -> IO ()) (b -> IO ()) | ....
12:33:29 <qwebirc27201> any ideas?
12:34:18 <dwcook> qwebirc27201, I don't quite get from that what you're after. That's a regular old ADT you wrote there anyway.
12:34:48 <qwebirc27201> but i dont think it is quite legal
12:35:21 <dwcook> Well the only problem is your b is not bound.
12:35:30 <dwcook> You could either include that in the type or use a forall, for example.
12:35:41 <dwcook> The latter requires an extension. Try it and GHC will tell you which one, I believe.
12:35:48 <dwcook> Probably RankNTypes?
12:36:01 <qwebirc27201> excellent i will try that
12:36:02 <dwcook> Which thing you do depends on what you're ultimately after.
12:36:05 <hexagoxel> ExistentialQuantification?
12:36:25 <pjdelport> int3__: It seems like you need something like FRP, but simpler.
12:38:12 <qwebirc27201> i have a number of io actions using async. I am trying to create a simple dsl to allow for 'and's and 'or's and when one of those groups fires it calls a strongly typed function with the values returned
12:38:28 <int3__> pjdelport: yeah, I think so too, which is why I was asking about FRP-related stuff :)
12:38:50 <dwcook> qwebirc27201, your improper use of function earlier calls for clarification - when you say function here, do you really mean a type constructed with (->), or an IO action?
12:39:17 <benzrf> qwebirc27201: youre trying to write something that runs things concurrently and then either waits on both or finishes with the first?
12:39:41 <dwcook> If the answer to benzrf is yes, then the async package is nice
12:39:50 <dwcook> @hackage async
12:39:50 <lambdabot> http://hackage.haskell.org/package/async
12:40:42 <qwebirc27201> if it was a&&b&&c||d&&e then i would have an io action (a,b,c)->IO () and another for the other possibility (d,e)->IO ()
12:40:56 <qwebirc27201> you are right, I meant an io action not a function
12:41:10 <dwcook> qwebirc27201, you're not going to get that sort of polymorphism over tuples without a typeclass
12:42:01 <qwebirc27201> i was hoping a gadt might work ...
12:42:07 <dwcook> Though it's sounding to me like benzrf hit the mark. Did they?
12:42:40 <ski> qwebirc27201 : perhaps you want something like `data Op :: * -> * where And :: Op a -> Op b -> ((a,b) -> IO ()) -> Op (a,b); Or :: Op a -> Op b -> (a -> IO ()) -> (b -> IO ()) -> Op (Either a b)); ...' ?
12:43:18 <qwebirc27201> i am using the async package to do this
12:43:39 <qwebirc27201> ski: yes that looks like what i want
12:44:11 <ski> dwcook : .. btw, `data Op (IO a) = ...' isn't legal
12:44:25 <ski> (you'd need `data' families)
12:44:59 <dwcook> ski, my mistake, I skimmed over that part.
12:45:11 <Trollinator> ski: what is that even supposed to mean?
12:45:18 <qwebirc27201> data Op (IO a) was what i was trying to do but failed
12:45:44 <Trollinator> the data Op (IO a) thing
12:45:47 <benzrf> qwebirc27201: what is that supposed to mean
12:46:04 <benzrf> do you mean something like
12:46:13 <benzrf> data Op a = Constructor (IO a)
12:46:45 <qwebirc27201> it was a way for me to get at the 'a' inside the typeclass: i was just trying to express what i was after
12:47:31 <dwcook> qwebirc27201, FYI, it sounds like you mean "type" rather than "typeclass" there.
12:47:34 <Xenasis_> Any recommendations for Haskell emacs modes with working indentation fixing?
12:47:57 <dwcook> qwebirc27201, it was a good thought, but inventing syntax can often be more confusing than explaining what you want outright.
12:47:58 <qwebirc27201> sorry, quite right
12:48:00 <Xenasis_> the standard haskell-mode's tab just makes a tab, rather than fixing a line's indentation
12:48:47 * Trollinator wishes that text-based source code editing just went away. Programs are trees, not text.
12:50:24 <benzrf> Trollinator: the primary input devices for computers are keyboards and mice
12:50:30 <benzrf> keyboards are optimized for text editing
12:50:48 <benzrf> if you want text-based source to go away, invent an input device for interacting with trees
12:51:03 <benzrf> also invent an operating system that deals in trees instead of text
12:51:05 <benzrf> good luck
12:51:08 <Xenasis_> and then make it ubiquitous
12:51:20 <Trollinator> they are? That's funny because most of the buttons on my keyboard are _not_ for text input.
12:51:35 <StoneCypher> Trollinator: don't bother, he's overly certain of his positions
12:51:35 <Trollinator> I'm pretty sure that applies to your keyboard too.
12:52:14 <benzrf> StoneCypher: im a teenager, that's my prerogative
12:53:32 <Lutin`> Xenasis_: btw if you want a simple PRNG
12:53:35 <Lutin`> let random max seed=(max*seed'`div`im):(random max seed') where seed'=(seed*ia+ic)`mod`im;ia=3877;im=139968;ic=29573
12:55:00 <Lutin`> Xenasis_: RE: indentation - https://github.com/haskell/haskell-mode/wiki/Indentation
12:55:47 <Lutin`> Also take a look at https://github.com/chrisdone/structured-haskell-mode
12:56:45 <Xenasis> Ah, structured-haskell-mode looks like what I want
12:56:58 <Xenasis> It seems silly that haskell-mode doesn't do this already, but whatever
12:57:45 <Xenasis> oh, it's not automatic
12:57:47 <Xenasis> hmm
12:58:06 <Lutin`> You could try the 3 different indentation modes
12:58:23 <Lutin`> There's also M-x align-regexp
12:58:33 <Xenasis> None of those do indentation based on Haskell's syntax
12:58:40 <Xenasis> which is kinda silly
12:58:57 <Lutin`> haskell-indent does fairly well in my experience
12:59:12 <Xenasis> but doesn't that "cycle through possibilities", not indent?
12:59:30 <Lutin`> Oh you said indentation fixing
12:59:35 <Xenasis> Right
12:59:48 <Xenasis> so (indent-region (point-min) (point-max)) would work
12:59:50 <Xenasis> for example
13:00:00 <Xenasis> the current one just adds a tab there, rather than indenting properly
13:00:36 <Trollinator> Lutin`: that looks awesome
13:00:40 <Trollinator> thanks.
13:02:43 <Lutin`> structured-haskell-mode does fairly well, but yeah I don't see a way to just run something to fix the identation
13:02:50 <Lutin`> Maybe chrisdone would have a suggestion
13:03:11 <Trollinator> if only it weren't emacs :(
13:03:50 <ski> Trollinator : with `type' and `data' families, one can do something like that
13:03:53 <Pythonfant> I always managed to mess up with structured-haskell-mode so it was annoying me more than it helped
13:04:00 <Pythonfant> but I should probably try it again
13:04:04 <Xenasis> It's kind of annoying, Emacs can do this for other languages, but I guess they don't enforce odd indentation rules
13:04:23 <Xenasis> But I'm sure there's a way I don't know of yet
13:04:26 <ski> Trollinator : <https://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html>
13:04:38 <Xenasis> (but I just had to debug a function because I'd used one tab and not 2)
13:05:32 <rwbarton> haskell is like python in that the meaning of your program can depend on the amount of indentation
13:05:54 <Trollinator> ski: I don't even understand what it's supposed to do.
13:05:56 <rwbarton> i.e. you cannot just "fix" the indentation based on the rest of the syntax
13:06:03 <rwbarton> (unless you use {;} always)
13:06:11 <Pythonfant> that's why haskell-indent lets you cycle through the possiblities
13:06:15 <Xenasis> Right, it's kind of a silly standard, but surely it should be implemented in elisp by now
13:06:27 <Lutin`> Xenasis: You might be able to use Flycheck to catch these issues on the fly
13:06:41 <Pythonfant> Xenasis: it's impossible to always indent correctly
13:06:45 <Xenasis> Yeah, it is
13:06:52 <Pythonfant> because multiple positions could be correct
13:07:01 <Xenasis> Right, but pick at least one of the correct ones
13:07:06 * StoneCypher is not a fan of whitespace sensitivity
13:07:10 <Xenasis> likewise
13:07:14 * Trollinator is
13:07:18 <Xenasis> why?
13:07:22 <Xenasis> Forcing people into a standard?
13:07:23 <ski> Trollinator : allowing you to define type functions by case analysis on the type parameters
13:07:35 <Xenasis> OCaml does the same as Haskell but without giving you errors because you didn't press the space bar enough <.<
13:07:37 <Trollinator> ski: I see.
13:07:50 <Xenasis> It's obviously not a problem for simple functions
13:08:10 <Trollinator> Xenasis: because that makes it impossible for people to write programs whose indentation doesn't match their semantics.
13:08:17 <Trollinator> i. e. the dangling else problem.
13:08:31 <Xenasis> No, it doesn't
13:08:33 * StoneCypher is often fascinated by programmers who suggest that forcing other programmers into things is a good idea
13:08:34 <Trollinator> i mean e. g., not i. e.
13:08:35 <rwbarton> instead you get errors because you didn't press ; enough
13:08:37 <Xenasis> People can write programs however they like
13:09:01 <StoneCypher> rwbarton: if you need an example why the two are different, javascript
13:09:18 <Trollinator> uh, no. It's not possible to write a dangling else in Python.
13:09:24 <Xenasis> It's like a language forcing everyone into using K&R and certain amounts of spaces for no reason other than fuck you
13:09:28 <Xenasis> Well, it is axactly this
13:09:30 <Xenasis> *exactly
13:09:38 <Trollinator> what?
13:10:07 <Xenasis> There's no compelling argument to cause compiler errors because there isn't the right amount of spaces
13:10:17 <Trollinator> well yes there is.
13:10:20 <Xenasis> when it's provably doable without taking spaces or the like into account
13:10:22 <StoneCypher> "i want to write an annoying language"    <-- Trollinator
13:11:17 <Trollinator> well, you need some kind of syntax, either braces or whitespace or something else like keywords.
13:11:24 <Xenasis> No, you don't
13:11:27 <copumpkin> oh yay, another discussion about syntax
13:11:28 <Trollinator> Yes you do.
13:11:34 <StoneCypher> copumpkin: srsly
13:11:38 <Xenasis> The same language pieces in OCaml work fine
13:11:44 <copumpkin> Xenasis: what is your goal here?
13:11:47 <Xenasis> You don't need indentation for pattern matching
13:11:51 <copumpkin> what will you achieve?
13:11:58 <Xenasis> Well, I was looking for a haskell indentation mode for Emacs
13:12:04 <Xenasis> but no, no, Haskell is perfect
13:12:15 <copumpkin> Xenasis: this is not a productive way to get help
13:12:53 <copumpkin> if you don't like layout, use curly braces and semicolons
13:12:56 <copumpkin> simon pj does that
13:13:07 <Xenasis> I asked, and someone seemed to think I was objectively wrong
13:13:13 <Xenasis> So obviously I'd get annoyed about that
13:13:23 <Trollinator> you are.
13:13:29 <copumpkin> Trollinator: stop it
13:13:29 <Trollinator> There *must* be a means for distinguishing between if (a) { if(b) c } else d and if (a) { if(b) c else d }
13:13:36 <Xenasis> No, there mustn't.
13:13:40 <copumpkin> no u
13:13:43 <Trollinator> so you need either braces or whitespace.
13:13:46 <Trollinator> yes there must.
13:14:37 <Lutin`> Well every if requires an else in haskell so that's not quite an issue
13:15:06 <Trollinator> there are similar issues in Haskell.
13:15:45 <Lutin`> Xenasis: If it helps here is an exact specification of how layout turns into braces and semicolons: http://www.haskell.org/onlinereport/syntax-iso.html#layout
13:21:24 <Lutin`> benzrf: That random cycles after IM-1
13:30:04 <Trollinator> dolio: you mentioned the type of filter in Agda yesterday: Dec P -> List A -> List (Σ A P)
13:31:51 <linman> what is type annotation's affinity- really low, or really high?
13:32:08 <Trollinator> I thought about it a bit and it seems like a lot is missing from that type. Afaics it doesn't specify that the resulting list contains *all* elements of the original list that satisfy the predicate. Returning the empty list would be a perfectly fine implementation.
13:32:37 <Trollinator> You can also duplicate elements
13:32:48 <Trollinator> or change their order.
13:33:10 <tolt> does anyone know who maintained https://twitter.com/hackage?
13:33:13 <byorgey> Trollinator: you are correct.  It is *a* type of filter, but not the most specific one.
13:33:13 <Trollinator> anyway, just random thoughts, I don't know how much that actually matters.
13:33:51 <byorgey> Trollinator: with types, there is always a tradeoff between how complex a type is and how much it captures/specifies.
13:35:01 <byorgey> linman: type annotations have low precedence.
13:35:21 <linman> byorgey: thanks
13:35:23 <ski> you could possibly prove separately that the function has the desired properites, instead of having to litter the type with them
13:35:51 <ski> (basically a use of axiom of (non-)choice)
13:36:13 <Trollinator> byorgey: yes… the thing is that very advanced type systems like Idris' give you a *lot* of rope to hang yourself with.
13:36:23 <byorgey> Trollinator: indeed =)
13:36:39 <Trollinator> and figuring out just the right amount of typing you want to employ isn't going to be easy.
13:37:32 <ski> @type const False $ \_ -> () :: ()
13:37:33 <lambdabot> Bool
13:37:33 <ski> @type const False $ \_ -> () :: Bool
13:37:34 <lambdabot>     Couldn't match expected type ‘Bool’ with actual type ‘()’
13:37:34 <lambdabot>     In the expression: () :: Bool
13:37:34 <lambdabot>     In the second argument of ‘($)’, namely ‘\ _ -> () :: Bool’
13:37:51 <byorgey> Trollinator: in practice, the approach ski mentioned tends to be nicer in practice---that is, prove properties of your functions after the fact rather than encode all the properties in their types
13:38:09 <ski> linman : ^ shows that the `::' in the type ascription here binds tighter than the `->' in the lambda
13:38:32 <byorgey> encoding properties directly in types tends to work well for *invariants*, so the type system can help you ensure you always preserve the invariants
13:38:48 <ski> byorgey : i think Conor has argued for the opposite practice, at least to some extent
13:39:40 <byorgey> ski: you mean like in "Hasochism"?
13:40:52 <byorgey> personally, I think the intrinsic approach (encoding all properties directly in types) would be nicer if it worked well, but the tool/language support to make it convenient isn't there yet
13:40:57 <ski> byorgey : hm, i don't recall that name
13:41:08 <byorgey> just my extremely handwavy opinion with no real evidence to back it up
13:41:19 <byorgey> ski: ok, do you have a reference or link then?  I'm curious
13:41:55 <ski> byorgey : just talking about encoding some properties directly in (e.g.) inductive data types (like using sized vectors instead of lists), instead of separately talking about the properties of the "naked" data structures
13:42:39 <byorgey> right, so this is related to the work on "ornaments"
13:42:50 <ski> okay
13:43:08 <byorgey> I think the argument is different for *data types* vs *functions*
13:43:23 <ski> ok ?
13:46:01 <byorgey> just an intuition.  But this is what I was trying to get at above with my distinction between "invariants" and "behavioral properties".  It seems that it often makes sense to add extra invariants/properties to data types, whereas giving types which explicitly specify the behavioral properties of functions (e.g. filter returns *all* elements that satisfy the predicate, does not duplicate any, etc.) tends to not work as well
13:47:00 <Trollinator> I don't understand what the difference between an invariant and a behavioural property is supposed to be.
13:47:24 <byorgey> I'm not sure I really understand the difference either. =)
13:48:40 <rwbarton> my intuition is that encoding properties directly in the types is bad for software engineering (but probably good for writing papers)
13:49:10 <rwbarton> I don't want a zillion differently structurally-having-property-P list types
13:50:51 <rwbarton> and a zillion^2 conversion functions between them that incur runtime costs
13:50:58 <byorgey> rwbarton: right, hence my comment about tool/language support.  I think this is exactly what the "ornaments" line of work is trying to accomplish, letting you move easily back and forth between those different types.
13:51:45 <rwbarton> yes, but I fear it's still the wrong approach (though undoubtably interesting)
13:51:55 <rwbarton> I should not need heuristics to generate those conversion functions
13:52:29 <rwbarton> they should be all of the same form conv (x : [a], p : P x) -> (x : [a], p' : P' x) and then only heuristic I need is that fst (conv (x, p)) = x
13:52:43 <rwbarton> by proof-irrelevance, this determines the function completely
13:54:59 <rwbarton> you can't write papers about "include one subset of a type into a bigger subset of the same type" though :)
13:56:08 <dagano> i have the following, seemingly standard problem : i want to build up some data structure (a PQueue.Min in this case) from some other data (say a [(a,a)]). is this a good time to use a fold? is this basically what they're about?
13:58:46 <bergmark> dagano: sounds like it!
14:01:26 <rwbarton> obviously it would be possible to take this too far, e.g. I don't want (x : IntOrBool, p : IsActuallyAnInt x), and I don't know how to decide where to draw the line
14:01:57 <dagano> so in the case of : foldr (+) 0 [1..] ... fold is taking apart the structure of lists and putting into some other data structure (which is just a singular number)
14:02:15 <dagano> if i want to transform an IntMap to a PQueue with some function f...
14:02:40 <dagano> then I use IM.fold f ???? intmap
14:02:57 <dagano> where ???? is what? algebraically it's like a unit..what is intmap's unit?
14:03:12 <dagano> s/unit/identity/
14:03:29 <Adeon> if you are constructing a priority queue then aren't you looking for its empty value
14:03:41 <Trollinator> I'm trying to install yi with cabal. It wants ghc-haskell-src-exts which I have installed through rpm already (Fedora 20). Is there a way to make that work?
14:03:59 <Adeon> maybe you are looking something like IM.foldlWithKey' f PQ.empty intmap
14:05:03 <dagano> Adeon: makes sense .. thanks
14:06:30 <guest50> ?
14:06:39 <ski> byorgey : ok
14:06:42 <geekosaur> Trollinator, if it's using the same ghc then it should be found and work. check `ghc-pkg list`
14:06:51 * ski looks at guest50
14:07:36 <Trollinator> oh, seems like it's outdated.
14:07:43 <Trollinator> oh well, I'll use the one from cabal then.
14:07:48 <Trollinator> thanks.
14:13:39 <peterhil> Has anybody got wxHAskell programs to work on Mac OS X 10.9 (Mavericks)? I get this "dyld: Symbol not found: __ZThn912_N12wxHtmlWindow13GetHTMLWindowEv Referenced from: /Users/peterhil/Library/Haskell/ghc-7.6.3/lib/wxc-0.91.0.0/lib/libwxc.dylib" error as in this thread http://comments.gmane.org/gmane.comp.lang.haskell.wxhaskell.devel/994
14:14:59 <peterhil> Or shuold I try to install Gtk2HS? Does it provide a native Quartz GUI, or just something that looks like it? Or is it just X11 on OS X?
14:16:41 <qwebirc31963> i have this snippet of code that runs IO actions with Async until the first condition is matched
14:16:50 <tulcod> peterhil: quartz or not depends on Gtk, not on the haskell bindings to it
14:16:51 <qwebirc31963> eg ex3 = wstuff 6 .&&  wstuff 12 .|| wstuff 8 .&& wstuff 10 .|| wstuff 3 .&& wstuff 5 .&& wstuff 7 .|| wdont 4
14:17:02 <qwebirc31963> I do one pass to pull out the IO actions then another pass to interpret the dsl  This works great as long as I make sure all the types are the same:how do i do this where the types could be different
14:17:14 <dfeuer> Is this something wonky with codepad, or is my syntax off somehow?  http://codepad.org/BPjl80Tn
14:17:58 <tulcod> dfeuer: i'm not seeing a ;
14:18:24 <dfeuer> Tulcod, me neither. Any I don't *think* anything is odd about that layout....
14:18:32 <tulcod> dfeuer: does it compile?
14:18:56 <dfeuer> tulcod, I'm on a smartphone right now; no compiler.
14:18:57 <tulcod> dfeuer: ah. no it's wrong
14:19:05 <tulcod> dfeuer: there's a missing ) on line 7
14:19:52 * hackagebot regex-tdfa-rc 1.1.8.2 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-rc-1.1.8.2 (RomanCheplyaka)
14:21:20 <rwbarton> is codepad using hugs? how cute
14:22:20 <dfeuer> Thanks, tulcod.
14:22:30 <dfeuer> rwbarton, it is indeed.
14:23:46 <ski> dfeuer : missing closing bracket at end of line seven ..
14:23:47 <rwbarton> we all get to play "decode the error message" like we have never used a Haskell compiler before :)
14:23:53 <ski> oh, tulcod said
14:24:25 * ski is quite used to HuGS error messages
14:24:39 <peterhil> tulcod: Sorry, my wording was bad... Anyway, the GTK wiki pages were not so clear if GTK provides something like GIMP on Mac OS X currently or some real integration to Quartz. Also, I found this package: https://github.com/gtk2hs/gtk-mac-integration
14:25:08 <Trollinator> Gtk is not a cross-platform toolkit.
14:25:30 <Trollinator> its maintainers don't really care about that any longer. It's the toolkit for writing gnome, and not much more.
14:25:34 <systemfault> Hmm, why would anyone use hugs when ghc exists? (Haskell noob here)
14:26:12 <ski> it's more portable
14:26:23 <systemfault> Ah, good to know
14:26:43 <ski> it doesn't require as much resources to run
14:26:45 <peterhil> Trollinator: I'd much prefer using QT. On the Python side I looked at Pyside, and with it, all the C++ examples were really easy to translate to Python code. And... They ALL worked! :-)
14:26:59 <ski> it has a couple of extensions not implemented by GHC
14:27:26 <Trollinator> yes. Qt is by now superior to Gtk in almost every imaginable way.
14:27:28 <tulcod> Trollinator: wow. the gnome related teams all went from being known for openness and portability to "head in the sand" kind of development
14:27:37 <simon> can lambdabot show the results of IO actions?
14:27:46 <ski> @help run
14:27:46 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
14:28:05 <ski> `> ' is sugar for `@run '
14:29:00 <Trollinator> > [1,1..]
14:29:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:29:13 <Trollinator> :o)
14:29:26 <nicoo> Trollinator: Hey! What did you expect?
14:29:31 <ski> > [False .. True]
14:29:33 <lambdabot>  [False,True]
14:29:33 <simon> > putStrLn "wat"
14:29:34 <lambdabot>  <IO ()>
14:29:36 <nicoo> Schweeeeeeeeeeps
14:29:40 <ski> > [False ..]
14:29:41 <lambdabot>  [False,True]
14:29:53 * hackagebot tasty 0.8.1.3 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.8.1.3 (RomanCheplyaka)
14:30:19 <dagano> when i'm folding through some data structure ... can I access the 'rest' of it?
14:30:36 <ski> dagano : you might be wanting a paramorphism
14:30:52 <simon> dagano, http://stackoverflow.com/questions/13317242/what-are-paramorphisms
14:31:30 <simon> ski, is a para combinator available in advance somewhere?
14:31:54 <dagano> ie i'm trying to accumulate from some list [(1,2),(2,3),(3,4)] and get in the form of a priority queue where each fst in that list is the key and the value is the min of set of snd values of hte whole list
14:32:02 <dagano> does that make more than 0 sense?
14:32:19 <Kaidelong> @hoogle (t -> [t] -> u -> u) -> u -> [t] -> u
14:32:20 <lambdabot> No results found
14:33:13 <Kaidelong> there is a para in pointless-haskell but it doesn't have that same type
14:33:22 <simon> dagano, what would be the result of your operator applied on [(1,2),(2,3),(3,4)]?
14:34:03 <dagano> PQ = [(1,2),(2,3),(3,4)]
14:34:13 <dagano> ugh that's the same thing
14:35:10 <dagano> will look up paramorphisms..hmmm
14:35:24 <simon> dagano, so foo [(1,2),(2,3),(3,4),(1,3),(3,2)] = [(1,2),(2,3),(3,2)]?
14:36:39 <dagano> ugh sorry .. will return with a better version of this question. tried to simply in my asking and lost something along the way.
14:37:55 <ctangent> would you guys recommend any particular resources for learning about type theory?
14:38:44 <Lutin`> There we go
14:38:57 <ski> @hackage recursion-schemes
14:38:57 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
14:39:00 <ski> simon ^
14:39:30 <Lutin`> This seems to do well with the Knuth spectral test
14:39:35 <ski> (that's a generalized version)
14:39:39 <Lutin`> @let let random max seed=(max*(fromIntegral seed')/(2^64-1)):(random max seed') where seed'=(seed*ia+ic);ia=21733031525;im=2^35;ic=0 :: Word64
14:39:39 <lambdabot>  Parse failed: Parse error: EOF
14:39:52 <joelteon> no extra let
14:39:56 <Lutin`> @let random max seed=(max*(fromIntegral seed')/(2^64-1)):(random max seed') where seed'=(seed*ia+ic);ia=21733031525;im=2^35;ic=0 :: Word64
14:39:57 <lambdabot>  .L.hs:224:52:
14:39:57 <lambdabot>      Ambiguous occurrence ‘random’
14:39:57 <lambdabot>      It could refer to either ‘L.random’, defined at .L.hs:223:1
14:39:57 <lambdabot>                            or ‘R.random’, imported from ‘System.Random’ at .L...
14:40:02 <Lutin`> @unlet
14:40:02 <lambdabot>  Define what?
14:40:06 <Lutin`> Yeah bad paste
14:40:09 <Lutin`> @undef
14:40:09 <lambdabot> Undefined.
14:40:11 <Lutin`> @let random max seed=(max*(fromIntegral seed')/(2^64-1)):(random max seed') where seed'=(seed*ia+ic);ia=21733031525;im=2^35;ic=0 :: Word64
14:40:12 <lambdabot>  .L.hs:150:52:
14:40:12 <lambdabot>      Ambiguous occurrence ‘random’
14:40:12 <lambdabot>      It could refer to either ‘L.random’, defined at .L.hs:149:1
14:40:12 <lambdabot>                            or ‘R.random’, imported from ‘System.Random’ at .L...
14:40:24 <Lutin`> @let rand max seed=(max*(fromIntegral seed')/(2^64-1)):(rand max seed') where seed'=(seed*ia+ic);ia=21733031525;im=2^35;ic=0 :: Word64
14:40:26 <lambdabot>  Defined.
14:40:38 <Lutin`> > take 10 $ rand 100 42
14:40:39 <lambdabot>  [4.948229998761201e-6,40.03855602788464,69.49575116045395,23.700844288578452...
14:41:03 <ski> dagano : for a fold/`cata' (`foldr' for lists), you have access to the current element, and to the *recursive result* on the substructures (the remaining tail for lists) -- but you don't have access to the substructures themselves
14:41:08 <Lutin`> > take 10 $ rand 100 0
14:41:10 <lambdabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
14:41:16 <Lutin`> lol woops
14:41:18 <Lutin`> > take 10 $ rand 100 1
14:41:20 <lambdabot>  [1.1781499997050478e-7,60.47710847685439,68.32132740858223,0.564305816394725...
14:41:25 <Lutin`> Good enough for me
14:41:35 <Lutin`> Maybe drop the first result since it always seems to be low
14:41:41 <ski> dagano : `para' just allows you to also use the substructures directly -- so for lists, you can use both the current element, the tail after it, and the recursive result on that
14:41:54 <rwbarton> ctangent: one suggestion I have heard is Chapter 1 of the HoTT book. skip the introduction though unless you want to learn about the homotopy side of things too
14:42:13 <ski> ctangent : i suppose it depends on your aims and goals
14:42:37 <Lutin`> > sum.take 1000 $ random 1 1
14:42:38 <lambdabot>  Couldn't match expected type ‘a1 -> [c]’
14:42:38 <lambdabot>              with actual type ‘(a0, g0)’
14:42:43 <ski> ctangent : if you just want to brush up on static type systems, as used in programming languages, try TaPL
14:42:47 <Lutin`> > sum.take 1000 $ rand 1 1
14:42:48 <lambdabot>  494.5233279537514
14:42:57 <ctangent> ski: I'm actually working through that one right now, haha
14:43:00 * Lutin` stops spamming lambdabot now
14:43:19 <ctangent> it's a great book so far but my mathematical chops are a little lacking to follow the proofs
14:43:24 <ski> ctangent : if you want the more mathy view, then possibly Per Martin-Löf original treatise can be useful
14:43:44 <ski> ctangent : following TaPL ? or HoTT ?
14:43:47 <ctangent> TaPL
14:43:49 <ski> ok
14:44:13 <ski> ctangent : you can for sure learn useful things in it, even if you skip proofs
14:44:51 <ctangent> okay, great. I've been implementing little systems in Haskell as I go and I've been learning a lot so far
14:44:59 <ctangent> maybe I'll make a second pass over the book later to understand the proofs more
14:45:29 <ski> ctangent : i also suggest taking a look at "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(df|s)>
14:45:32 <Lutin`> ski: TaPL?
14:45:37 <ski> @where TaPL
14:45:37 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:45:46 <Lutin`> Ah gotcha
14:46:02 <ctangent> ski: cool, thanks!
14:46:32 <zzing> Does anyone know if 'persistent' can handle foreign key constraints?
14:47:10 <ski> ctangent : "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> also has useful info
14:48:36 <ctangent> thanks!
14:50:01 <eddiorov> if i want to find the minima of a list (say [1,2,1,1] => [1,1,1]) how would i do this? i have so far considered sorting and taking the first n elements or searching for the minimum first and filtering for that value
14:50:12 <eddiorov> any other ideas?
14:50:30 <simon> :t Data.List.minimum
14:50:31 <lambdabot> Ord a => [a] -> a
14:51:07 <simon> eddiorov, your second suggestion is asymptotically superior.
14:51:29 <simon> wait. just fold through the list. no need to iterate the list twice.
14:52:09 <eddiorov> the classic approach would be to iterate over the list and remember the lowest value; delete the list of minima if a lower one ist found
14:52:10 <simon> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#minimum
14:52:32 <eddiorov> fold?
14:52:38 <simon> sorry, I did not understand that you wanted a list of minimal elements.
14:53:38 <eddiorov> still, what is folding? ( i am new to the whole functional programming thing)
14:54:04 <ctangent> eddiorov: http://www.haskell.org/haskellwiki/Fold
14:54:06 <ctangent> ^ really good article
14:54:11 <rio> eddiorov: fold (+) [1,2,3] is 1+2+3
14:54:54 * hackagebot regex-tdfa-rc 1.1.8.3 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-rc-1.1.8.3 (RomanCheplyaka)
14:54:59 <eddiorov> i see
14:55:18 <simon> foldl f x [a,b,c] = f(f(f(x, a), b), c)
14:55:52 <simon> eddiorov, http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Folds_as_structural_transformations - I like the illustration: basically replace the : operator with another composition function.
14:56:12 <simon> err... those illustrations are in HaskellWiki also :)
14:56:29 <rio> i'd guess thats the source
14:56:34 <simon> I'd guess so, too.
14:58:11 <ski> ctangent : also see "Crash Course on Notation in Programming Language Theory" by Jeremy Siek in 2012-07-26 at <http://siek.blogspot.com/2012/07/crash-course-on-notation-in-programming.html> and "Interactive Tutorial of the Sequent Calculus" by ezyang (Edward Z. Yang) in 2012-05-22 at <http://logitext.mit.edu/logitext.fcgi/tutorial>
14:58:16 <rio> is foldr just foldl for flip f instead of f?
14:58:42 <rio> oh no, its folded from the end, sorry..
14:58:44 <ctangent> great, thanks!
14:58:54 <latro`a> rio--there's no such invariant without some prior assumptions
14:59:09 <latro`a> for example, foldr need not consume the whole list, while foldl must
14:59:37 <rio> yes, i had a minor brainfart
15:00:26 <simon> (In Standard ML, foldr and foldl have the same type signature.)
15:00:34 <ski> eddiorov : did you want to keep all instances of the minimal elements ?
15:00:43 <latro`a> you also really shouldn't think of foldr as "folded from the end" unless the folding function is strict
15:00:51 <ski> simon : yes, that's sometimes handy
15:00:54 <eddiorov> ski: yes
15:01:17 <ski> eddiorov : .. because it appeared to me some others here were assuming you just wanted one instance
15:01:31 <latro`a> > foldr (\_ _ -> 1) undefined (repeat undefined)
15:01:33 <lambdabot>  1
15:03:07 <ski> ctangent : the sequent calculus (-style inference rules) thing isn't quite the same as the natural deduction (-style inference rule) that are most commonly used for specifying a type system, but i think it can help a bit anyway
15:03:14 <simon> ski, a funny incident in a compiler's course I TA'ed: the prof. didn't know SML (the course language) and had only used Haskell for a year. the language to be implemented also featured a foldl-like operator, but with Haskell's type signature. when students implemented the interpreter for the language, they'd use SML's foldl and either get errors or different semantics.
15:03:22 <latro`a> similar:
15:03:30 <latro`a> > foldr const 1 [1..]
15:03:32 <lambdabot>  1
15:03:43 <ski> simon : hehee :)
15:03:49 <ctangent> ski: the more the merrier. I'm diving in as deep as I can :P
15:05:16 <ski> ctangent : generally, the best way to read papers is to attempt to read them. skipping over stuff that you don't grasp (after trying a little), but possibly coming back later again. also check up the bibliography/references at the end for possible links to earlier papers (explaining basic concepts in more detail) and also to survey/tutorial -style papers
15:05:50 <ski> ctangent : it also helps to find researchers that write lucidly :) Wadler e.g. is usually quite good (and often has funny titles)
15:06:22 <ctangent> Yeah... I got similar advice from one of my professors, she says that she pays very little attention during talks and reading papers but always goes over them later to fully understand them :P
15:06:46 <ctangent> thanks for the info!
15:07:38 <ski> ctangent : s/to read/to learn to read/
15:08:09 <ski> ctangent : the end of <http://homepages.inf.ed.ac.uk/wadler/> has links to some pages with papers under various topics
15:08:56 <ski> "How to add laziness to a strict language, without even being odd" at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html> is one example of such a title :)
15:09:03 <ctangent> haha
15:09:30 <ski> (also note that "even" and "odd" in this paper has a special meaning. then it becomes even more witty)
15:10:37 <ski> ctangent : otherwise, many Peyton-Jones papers are good. i recall reading Hutton and others as well -- look in the references section at the end of papers to find other papers that might be interesting
15:10:39 <simon> eddiorov, https://gist.github.com/sshine/68c18988cc9cdc1fad78
15:11:00 <ctangent> i've got a lot to read :P
15:11:01 <ctangent> thanks!
15:11:25 <ski> ctangent : also, you can lurk around on <http://lambda-the-ultimate.org/> (and ask questions, if you dare :)
15:11:39 <ctangent> Haha, I'll probably stay lurking :P
15:11:53 <Lutin`> Huh..summing 1 million elements of a list is faster than accessing the 1 millionth element
15:12:07 <ski> that site has a nice mix of researchers, practitioners, and newbies
15:12:18 <ctangent> I just graduated from undergrad and I realized that I completely missed my research interest :/
15:12:19 <Lutin`> That doesn't seem right
15:12:29 <ctangent> I got a minor in math but it was analysis and such and I didn't really like it
15:13:14 <tulcod> Lutin`: code?
15:13:25 <tulcod> Lutin`: also try using a profiler
15:13:43 <Lutin`> sum . take (1000000) vs (!! 1000000)
15:14:01 <eddiorov> simon: if i read that code correctly, that would be the iterate-over-list-and-update-if-smaller approach?
15:14:05 <Adeon> what's the list
15:14:14 <Adeon> well, how are you feeding a list to that
15:14:22 <Lutin`> A list of randomly generated numbers using my LCG
15:14:36 <Lutin`> The code is uh
15:14:39 <jle`> Lutin`: try using a strict (!!) and see if it's any better
15:14:43 <Lutin`> let rand max seed=(max*(fromIntegral seed')/(2^64-1)):(rand max seed') where seed'=(seed*ia+ic);ia=21733031525;im=2^35;ic=0 :: Word64
15:14:47 <rwbarton> yes what jle` said
15:14:48 <tulcod> ctangent: don't worry about it. i went from being an electrical engineer to a pure mathematician. the road is long and steep but very much worth your time, and a lot of fun
15:14:49 <Lutin`> jle`: Will do
15:14:54 <simon> eddiorov, yup.
15:14:56 <eddiorov> i just found out about lazy sorting, that could be worthwile as well
15:14:57 <jle`> there should really be a strict (!!) in Data.List
15:15:21 <Cale> strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs)
15:15:26 <Cale> just need that thing
15:15:26 <jle`> i've had to write my own on multiple occasions
15:15:31 <jle`> oh ah
15:15:52 <jle`> does that play well with laziness?
15:15:58 <Cale> yes
15:16:00 <jle`> past the desired element?
15:16:02 <jle`> oh that's neat
15:16:04 <Cale> It makes the list a little stricter
15:16:15 <Cale> So when you look at each cons, the element there will get evaluated
15:16:16 <rwbarton> you could also build the list to be a little stricter
15:16:23 <jle`> a strict cons
15:16:31 <snyp> Are data constructors functions?
15:16:36 <jle`> snyp: yes and more
15:16:40 <snyp> i see
15:16:46 <pyon> snyp: Non-nullary ones, yes.
15:16:51 <ski> snyp : some of them are. `False' and `Nothing' are examples that aren't
15:16:51 <jle`> data Maybe a = Nothing | Just a
15:16:59 <jle`> Nothing :: Maybe a, so not a function
15:17:00 <tulcod> pyon: nullary ones would be 0-argument functions, no?
15:17:01 <jle`> Just :: a -> Maybe a
15:17:02 <Cale> I kinda wish that were in Data.List, but Ed's not here to bug apparently :)
15:17:13 <ski> tulcod : no such thing :)
15:17:19 <rwbarton> you could separate out the "make a little stricter" part too
15:17:19 <ctangent> tulcod: thanks! I might just take the same road. My major was CS but it was a very practical degree without much math
15:17:20 <pyon> tulcod: All functions in Haskell have exactly 1 argument.
15:17:24 <Lutin`> Cale: Ah that worked
15:17:25 <rwbarton> foldr ((:) $!) []
15:17:28 <snyp> ski, aahhh.. so this clears my yesterday's confusions, and some more.
15:17:29 <Lutin`> Makes sense, didn't think about that
15:17:31 <jle`> by "and more" i mean, they are also usable as deconstructors for pattern matching
15:17:32 <ybit3> is there a way for cabal to automatically add dependencies in the build-depends portion of the project.cabal file?
15:17:34 <tulcod> ski: in any sense more than implementation wise?
15:17:38 <rwbarton> if I'm not mistaken
15:17:55 <simon> snyp, data constructors also work as pattern constructors which regular functions don't.
15:17:57 <Cale> rwbarton: looks right
15:17:57 <ski> tulcod : functions are values whose type are of the shape `... -> ...'
15:18:07 <tulcod> that's a horrible definition
15:18:16 <rwbarton> mathematician detected
15:18:17 <Cale> tulcod: It's the only sensible definition :P
15:18:18 <ski> tulcod : or, said differently, functions are values you can apply to an argument (of the appropriate type)
15:18:32 <snyp> simon, like for use in case expressions.. right?
15:18:39 <snyp> ah
15:18:42 <tulcod> okay, so are things of the form "() -> a" for a type a, functions?
15:18:43 <Cale> tulcod: At least, in the context of Haskell
15:18:46 <Cale> yes
15:18:52 <Lutin`> Cale: Since I wasn't using seq it delayed the computation of all the previous seeds until it got to the millionth element
15:18:57 <tulcod> but things of the form "a" aren't?
15:19:11 <Lutin`> which is obviously bad for time and space
15:19:16 <Cale> A value is a function if and only if the top-level type constructor in its type is (->)
15:19:23 <simon> snyp, yup. or just in the arguments to functions: foo :: Maybe Bool -> Bool; foo (Just True) = True; foo _ = False
15:19:25 <ski> tulcod : depends :)
15:19:29 <tulcod> Cale: okay, that's getting somewhere
15:19:39 <tulcod> but that makes no sense at all mathematically
15:19:41 <Cale> which is another way to say what ski said
15:19:46 <tulcod> yeah i guess
15:19:53 <Cale> Well, it makes a fair amount of sense mathematically
15:20:01 <Cale> Functions in mathematics always have a domain and codomain
15:20:05 <snyp> simon, ah. yes. we can do that too, i remember.
15:20:06 <ski> tulcod : .. depends on whether the type *variable* `a' there will actually become something of shape `... -> ...' or not
15:20:17 <tulcod> mathematically, points aka elements are just embeddings of a 1-point type/set/whatever into your type/set/whatever
15:20:22 <rwbarton> it makes sense exactly if you truly believe there is no such thing in Haskell as a function of two arguments
15:20:22 <snyp> Cale, yeah i get it now.
15:20:40 <ski> tulcod : s/mathematically/categorically/
15:21:02 <Cale> rwbarton: Well, a function of two arguments is still a function, it's just a function whose codomain is a function type
15:21:16 <tulcod> ski: okay, categorically
15:21:28 <Cale> (or whose domain is a product type)
15:21:29 <rwbarton> i.e. it's a function of one argument
15:21:30 <tulcod> okay whatever. this is not important. you guys are right.
15:22:17 <Cale> Yeah, every function of n+1 arguments is also a function of n arguments for n >= 1.
15:22:31 <Cale> (if you're using curried functions)
15:22:34 <rwbarton> then you should extend to n >= 0
15:22:46 <Cale> Should we?
15:22:54 * ski grins happily
15:22:54 <rwbarton> yes, for the same reason we have 0 in our number system
15:22:59 <rwbarton> anyways let's not go over this again, sorry
15:23:12 <ski> @palomer
15:23:12 <lambdabot> Learning vim is pointless
15:23:14 <Cale> Well, I don't think it's helpful to have things which are not constructed with (->) called functions
15:23:27 <Cale> because then there's no distinction between the word "function" and the word "value"
15:24:11 <ski> @where everything-is-a-function
15:24:11 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
15:24:15 <rwbarton> a "function of 0 arguments" need not be a "function"
15:24:15 <Cale> But perhaps you could take "function of 0-arguments" to possibly not be a function.
15:24:19 <rwbarton> yes
15:24:31 <Cale> I kind of think that's a little weird
15:24:37 <Cale> But it's acceptable I guess.
15:24:41 <rwbarton> eh, it turns out to be useful so I use it
15:25:00 <jle`> @palomer
15:25:01 <lambdabot> Learning vim is pointless
15:25:47 <jomg> Cale: though a function with no arguments could probably be seen equivalent to a function from the empty product type, ie (), by currying
15:25:53 <rwbarton> e.g. liftA2 lifts functions of 2 arguments, liftA = fmap lifts functions of 1 argument, {- liftA0 = -} pure lifts functions of 0 arguments
15:25:56 <rwbarton> there are many patterns like this
15:26:33 <ski> @palomer
15:26:33 <lambdabot> Pfft
15:26:49 <Lutin`> jle`: But vim is a morphism from a 1-set to 1337
15:26:58 <Lutin`> where the 1-set is you
15:27:17 <jle`> sounds reasonable enough
15:27:34 <ski> rwbarton : *nod*
15:28:07 <seydar> i'm reading http://composition.al/blog/2013/09/22/some-example-mvar-ivar-and-lvar-programs-in-haskell/ right now and i have a quick question on MVars
15:28:09 <ski> (can i agree with both of you ?)
15:29:16 <seydar> it says that putMVar blocks if there's already a value. does this mean that it will block until there is another call to takeMVar? as in, it's like a mailbox that can only hold one thing at a time and waits until someone explicitly takes what is there?
15:29:57 <simon> seydar, yes.
15:30:34 <seydar> is there a variant that will allow values to be overwritten?
15:30:53 <ski> @hackage data-ivar
15:30:53 <lambdabot> http://hackage.haskell.org/package/data-ivar
15:30:54 <rwbarton> IORef?
15:30:55 <seydar> oh well i guess you might just call that a variable since it wouldn't have any concurrency safety-ness
15:30:58 <ski> @hackage ivar-simple
15:30:58 <lambdabot> http://hackage.haskell.org/package/ivar-simple
15:31:30 <simon> seydar, MVars and their contracts are described in http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent-MVar.html
15:31:31 <ski> seydar : `SampleVar' allows overwriting
15:32:26 <seydar> ski: is SampleVar useful at all? is it just... a "mutable" variable?
15:32:30 <seydar> simon: thank you, i'll read that now
15:32:50 <jle`> simon: are you one of the ghc simons
15:32:54 <zq> what's the recommended way to declare and use fixed sized arrays?
15:32:56 <simon> jle`, no.
15:33:05 <jle`> aw
15:33:10 <jle`> it's ok i don't think any less of you
15:33:12 <sshine> jle`, I usually go by 'sshine' unless someone asks me that here. :)
15:33:23 <sshine> s/unless/when/
15:33:32 <ski> <http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent-SampleVar.html>
15:33:50 * ski didn't know about <http://hackage.haskell.org/package/SafeSemaphore-0.10.1/docs/Control-Concurrent-MSampleVar.html>
15:34:01 <sshine> jle`, I should have thought of Haskell when I registered 'simon' in NickServ 10 years ago. ;-)
15:34:02 <rwbarton> huh I never knew about this, and just in time :)
15:34:35 <jle`> sshine: you can go ahead and keep your name, it is rightfully yours
15:34:36 <ski> seydar : it can be empty, and so readers can block (and be waken upon write)
15:34:59 <Kaidelong> zq: I'd recommend the vector library, the "official" answer is Data.Array in base
15:35:28 <zq> Kaidelong: no
15:36:26 <zq> Kaidelong: data.{array,vector} do not encode the length in their types
15:36:31 <sshine> jle`, well, it does happen quite often that people ask this, and I mostly go by 'simon' these days when I join some IRC channel that insists I am registered in NickServ before I can talk.
15:36:36 <zq> i really really want it fixed
15:36:41 <zq> and of the dimension i specify
15:36:42 <Kaidelong> oh you are looking for length typed vectors
15:36:42 <Kaidelong> okay
15:36:45 <jle`> you can register sshin, can't you?
15:36:50 <jle`> sshine
15:37:03 <jle`> or at least put sshine as one of your registered alii
15:37:08 <zq> how else would you suggest really really fixing the length?
15:37:09 <sshine> good point.
15:37:10 <jle`> ...aliii ?
15:37:30 <jle`> zq: linear lets you put the size in the type
15:38:19 <sshine> wow, that was easy. /msg nickserv group
15:38:20 <Lutin`> sshine: Just do /nickserv group
15:38:22 <Lutin`> Yeah
15:38:44 * xix_gjilanasi_ch ..::  martinga_  ::..
15:38:47 <matematikaadit> sshine: or /NS GROUP
15:38:59 <jle`> V $(n) Double is a vector of Doubles of length n
15:39:12 <jle`> where $(n) is a TH splice for the type nat
15:39:20 <jle`> ...i'm sure there is some support for actual ghc type nats
15:50:37 <benzrf> wait TH can splice into typs igs?
15:50:39 <benzrf> *type sigs
15:51:09 <tulcod> benzrf: i think it's rather limited
15:52:20 <dfeuer> @tell kazagistar http://codepad.org/x2gBZ8Pz
15:52:20 <lambdabot> Consider it noted.
15:54:12 <jollygood> hello. can one implement liftA3 with liftA2? (a yes or no will suffice, if it is possible I would like to figure it out myself)
15:54:16 <ski> dfeuer : hm, i noticed the cyclic `Tree' before, but forgot to mention it ..
15:54:27 <jollygood> without using <*>
15:56:26 <benzrf> jollygood: of course
15:56:38 <benzrf> you can implement it with liftA ;)
15:56:45 <benzrf> oh wait hold on
15:56:55 <benzrf> yeah i think you can
15:57:03 <benzrf> not with liftA
15:57:06 <benzrf> but w/ liftA2
15:57:27 <jollygood2> yeah I don't think you can with liftA and without <*>. :). if you could, every Functor would also be Applicative
15:57:51 <benzrf> yeah
15:57:53 <benzrf> hence why i said nvm
15:57:58 <benzrf> i was thinkin wrong >.<
15:58:31 <Kaidelong> what examples are there of functors that aren't applicative?
15:58:49 <benzrf> Kaidelong: jollygood means that you could implement applicative in terms of fmap
15:59:27 <Kaidelong> that's not really what I was asking!
16:00:26 <benzrf> jollygood2: the easiest thing is to implement (<*>) with liftA2
16:00:38 <jollygood2> I will try
16:01:08 <jle`> hint: look at the source of ap
16:01:19 <jle`> actually that's not a hint, tha'ts a spoiler
16:01:41 <jollygood2> heh, ok I didn't look
16:02:40 <sshine> why do some hackage package overviews have viewable docs for various modules and others don't? e.g. https://hackage.haskell.org/package/rest-core 's Modules are non-clickable.
16:03:05 <jle`> sshine: sometimes it's because it's new enough that it hasn't had a haddock pass yet
16:03:39 <sshine> jle`, none of its versions have it.
16:03:44 <jle`> ah
16:03:45 <jollygood2> by the way, I am curious too about example of a functor that isn't applicative. I can't think of any
16:04:14 <sshine> jle`, I suspect it's because I access the package overview in one way and it can be accessed in another...
16:04:40 <zq> means no haddock
16:04:58 <zq> git clone ...; cd ...; cabal haddock
16:04:59 <sshine> jollygood2, http://stackoverflow.com/a/7220548/235908
16:05:06 <burp> Prelude Data.Text.Encoding> decodeUtf8 "⚠"
16:05:06 <sshine> zq, thanks!
16:05:07 <burp> "*** Exception: Cannot decode byte '\xa0': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
16:05:09 <burp> is that a bug?
16:06:10 <bergmark> sshine: the documentation building failed because of an older aeson version
16:06:13 <sshine> jollygood2, basically I could only think of Cont as that's the example I've been given before.
16:06:19 <sshine> bergmark, oh!
16:07:23 <bergmark> sshine: http://hackage.haskell.org/package/rest-core-0.31.1/reports/1/log
16:07:44 <jle`> yo what's up with this
16:07:48 <benzrf> when you have a Monad instance on infinite lists where join is diagonalizatoin
16:07:53 <benzrf> *diagonalization
16:08:02 <benzrf> ap is zipWith ($), right
16:08:02 <jle`> > do { Just x <- [Just 1, Nothing]; return () }
16:08:03 <lambdabot>  [()]
16:08:05 <jle`> but
16:08:07 <bergmark> apparently our attempt to retrigger documentation generation failed ;-(
16:08:17 <jle`> > [Just 1, Nothing] >>= (\(Just x) -> return ())
16:08:18 <lambdabot>  [()*Exception: <interactive>:3:24-45: Non-exhaustive patterns in lambda
16:08:21 <jle`> what's up with that
16:08:23 * jle` flips a table
16:08:29 <dfeuer> ski, the type checker let me know, so it's all good. Kazagistar and I were working on understanding the implementation of permutations in Data.List. kazagistar eventually got it, but I didn't quite, so I wrote that implementation. I need to benchmark it when I get home.
16:08:52 <benzrf> jle`: fail
16:09:01 <benzrf> > fail "foo" :: [()]
16:09:02 <lambdabot>  []
16:09:05 <bergmark> sshine: oh, and, we have: http://silkapp.github.io/rest/docs/
16:09:08 <jle`> i guess (>>=) doesn't magically have fail
16:09:10 <jle`> only do notation does
16:09:13 <benzrf> jle`: of course it doesnt
16:09:16 <benzrf> (>>=) i mean
16:09:21 <jle`> @undo do { Just x <- [Just 1, Nothing]; return () }
16:09:21 <lambdabot> [Just 1, Nothing] >>= \ a -> case a of { Just x -> return (); _ -> fail ""}
16:09:25 <jle`> i see
16:09:30 <sshine> bergmark, are you a part of the rest team?
16:09:42 <jle`> boo
16:09:43 <bergmark> sshine: yup!
16:10:10 <jle`> @undo do { Just x <- [Just 1, Nothing]; y <- [x, x+1]; return (y * x) }
16:10:10 <lambdabot> [Just 1, Nothing] >>= \ a -> case a of { Just x -> [x, x + 1] >>= \ y -> return (y * x); _ -> fail ""}
16:10:22 <jle`> is it always fail ""?
16:10:23 <sshine> bergmark, awesome :) I am looking for a minimal example rather than the tutorial and the rest-example/ dir. if I can't find one, I'll make one.
16:10:26 <jle`> why does fail even take a string argument?
16:10:46 <ski> jollygood2 : you can do it with `liftA2' and `liftA' ..
16:10:50 <bergmark> sshine: http://www.reddit.com/r/haskell/comments/29h32i/announcing_rest_a_haskell_rest_framework/cilipfr
16:10:53 <sshine> jle`, I would have preferred Standard ML-like exceptions.
16:11:03 <ski> jollygood2 : .. you can also do it with `liftA2', without `liftA'
16:11:38 <ski> (and in both cases, i also excluded `(<*>)', yes, as well as stuff like `liftA4',&c.)
16:12:07 <sshine> bergmark, excellent!
16:12:45 <ski> dfeuer : btw, i would probably simplify  insertWithin x t = insertWithin' t  into just  insertWithin x = insertWithin'
16:15:05 <gamegoblin> so with cabal init, it will let me name my package “whatever.com"
16:15:41 <gamegoblin> but then it fails to parse the name field upon cabal build
16:15:48 <gamegoblin> I feel like that’s something the init shouldn’t let you do if it’s illegal
16:16:31 <bergmark> gamegoblin: i think everyone will agree
16:16:58 <ski> sshine,jollygood2 : be aware that using `Cofunctor' as in <http://stackoverflow.com/a/7220548/235908> is actually bad naming (imho). what's called `Cofunctor' there is usually called "*contra*variant functor", while the plain old kind of functors (like with `Functor' in Haskell) are known as "(covariant) functors"
16:17:01 <StoneCypher> what the
16:17:07 <StoneCypher> smart quote on the left but not on the right?
16:17:10 <Cale> gamegoblin: Good catch, https://github.com/haskell/cabal/issues
16:17:11 * StoneCypher 's head explodes
16:17:24 <Cale> gamegoblin: It doesn't seem to be listed there, might want to open a ticket
16:17:26 <benzrf> i am told
16:17:27 <benzrf> wait nvm
16:17:31 <gamegoblin> Cale: on it
16:18:33 <Cale> ski: Though I kind of think it's more appropriate than the standard convention in some ways.
16:18:59 <FireFly> StoneCypher: no, it's a backtick and an apostrophe
16:19:29 <dfeuer> Ski, I considered that simplification and rejected it on the basis that doing so makes it harder to read. Is there a reason such expressions are popular among Haskellers?
16:19:32 <StoneCypher> FireFly: not here: [16:13:24] <gamegoblin> so with cabal init, it will let me name my package “whatever.com"
16:19:37 <FireFly> oh
16:19:52 <FireFly> I read the wrong line
16:20:00 * StoneCypher pretends to be deeply offended
16:20:12 * StoneCypher is actually deeply hungry
16:20:39 * dfeuer feeds StoneCypher.
16:20:55 * gamegoblin wonders if this has become haskell-roleplay
16:21:04 <dfeuer> dfeuer >- StoneCypher
16:21:52 <dfeuer> Gamegoblin, Haskell's newtypes are very well suited for roleplay.
16:22:01 <gamegoblin> Haaaaaa
16:22:17 * FireFly wonders what would happen if StoneCypher ate a cockatrice corpse
16:23:12 <ski> Cale : contravariant functors aren't dual to covariant functors
16:23:33 <dfeuer> No, I wouldn't think they were.
16:23:48 <dfeuer> That would in fact make very little sense.
16:23:54 <bergmark> woo i managed to upload documentation
16:25:14 <ski> dfeuer : not sure about Haskellers in general. speaking on my own, it makes it clear that `t' isn't to be used in the local definition
16:25:59 <ski> dfeuer : iow, `x' is a non-local parameter to it, but `t' isn't
16:26:25 <ski> dfeuer : rather than having to scan through the local def to check whether `t' is used or not, i prefer not naming `t'
16:26:47 <ski> also, it's a bit shorter, a looks a bit more tidy, imho :)
16:26:58 <ski> s/a looks/and looks/
16:28:00 * ski is missing the `local'-`in'-`end' of SML in Haskell ..
16:29:12 <pyon> ski: Whoa, I never knew there were people who used that.
16:29:13 <sshine> bergmark, it seems that if I try to install rest-gen-0.14.1, then rest-wai-0.1.0.2 "is likely to be broken", according to cabal.
16:29:25 <dfeuer> Local def?
16:29:51 <pyon> ski: I just give my modules signatures that hide what I do not want to show. :-P
16:30:18 <bergmark> sshine: what if you install them both at once?
16:30:38 <bergmark> sshine: it might be that you reused some older dependency when you installed the first one
16:30:50 <ski> dfeuer : having a bunch of declarations that are local to another bunch of declarations, yes
16:31:03 <sshine> bergmark, I have no idea why that works, but it seems to.
16:31:33 <ski> `let <decls> in <expr> end' is an expression, `local <decls> in <decls> end' is a declaration, in SML
16:32:16 * ski backticks StoneCypher on
16:32:17 <sshine> bergmark, are you saying that when I installed rest-wai first, it said "Ok, I'll just go with the old version you already have." but when I install both at once, it resolves the conflict by upgrading to the version needed by the most demanding package?
16:33:22 <sshine> ski, isn't that what 'where' clauses are good for?
16:33:39 <sshine> I suppose 'local-in-end' lets you share across a set of functions.
16:33:43 <bergmark> sshine: pretty much, yeah
16:34:01 <ski> sshine : no, those are (simplified) of the form `<definition> where <decls>'
16:34:05 <ski> sshine : exactly
16:34:47 <ski> also `where' allows you to use the variables bound by patterns in a defining equation for a function, but `local' doesn't
16:35:16 <sshine> I actually preferred not using local-in-end in SML, and rather would use a closed structure in which they're not exported. (which is similar to not exporting certain declarations in Haskell).
16:35:27 <ski> (and that can be good since then you don't have to check manually whether the local def(s) depend on the params or not)
16:36:14 <sshine> ...except you can do nested structures, too.
16:36:58 <ski> sshine : can work if you have a top-level structure for the whole thing, together with a signature with opaque ascription, for the whole thing, yes
16:37:56 <qwebirc31963> can anyone help me with this code: http://lpaste.net/106983  I am trying to extract a list of io actions from a gadt. Is there a way to do this?
16:39:21 <dfeuer> ski, one obvious thing I could "simplify" is to flip the order of the arguments to attach, as it's always used flipped.
16:39:40 * ski nods
16:40:54 <ski> qwebirc31963 : that `getIOActionList' can't possibly work
16:41:24 <dfeuer> I'd like to get rid of the code duplication between the forest and the trees... I'll have to think about that.
16:41:53 <qwebirc31963> i know. Is there a different approach that would work: using typeclasses?
16:43:14 <rwbarton> well, what are you actually trying to do, given that you know this getIOActionList can't work
16:43:58 <rwbarton> you could, at least for And/Or, return a [IO ()]
16:44:31 <qwebirc31963> i am trying to create a dsl for async
16:44:33 <rwbarton> (btw, why "IO (a,b)" but "Either (IO a) (IO b)"?)
16:44:53 <bergmark> sshine: i think i fixed all the broken docs on hackage now
16:44:54 <sshine> bergmark, I copy-pasted your minimal example and tried to compile it, which resulted in this set of errors: https://gist.github.com/sshine/e6736eed6e82e2f7114c
16:44:59 <sshine> bergmark, ok, cool.
16:45:32 <qwebirc31963> i think i meant it to be IO (Either (a,b))
16:45:34 <sshine> bergmark, I'll try and fix them, but I just thought I'd let you know that that example doesn't work for me.
16:45:36 <bergmark> sshine: you probably want to check out that commit and use the cabal file
16:45:43 <sshine> bergmark, ok.
16:48:03 <sshine> bergmark, when I do 'cabal build' in rest-minimal/, I get the same errors.
16:48:09 <qwebirc31963> what i am trying to do is have a edsl with strong types. so if i using async a&&b||c&&d and c&&d completes first then an action of type (a,b) -> IO ()  is called otherwise (c,d) -> IO ()
16:48:28 <ph88> i installed the haskell platform and i made a small .hs file .. how can i see the output ?
16:48:54 <avocado> putStrLn "output"
16:49:13 <sshine> ph88, you can either run the .hs file in GHCi (interactively) or compile the program, assuming it has a declaration called main :: IO ()
16:49:38 <sshine> ph88, e.g. ghci file.hs
16:49:52 <ph88> ok sshine let me try that
16:49:52 <rwbarton> qwebirc31963: I don't know why you are trying to get out a list [IO a], then. why not just write a "run" function Op (IO a) -> IO a?
16:50:29 <bergmark> sshine: it works here
16:50:34 <sshine> ph88, then in the interpreter, you can call the declarations made in the .hs file to see the results...
16:50:46 <sshine> bergmark, what do you suppose is different between our setups?
16:50:47 <qwebirc31963> i am trying to create a tree whereby if any one of the io actions fail in async then they all fail: nested withasync
16:50:57 <ph88> sshine: it looks some packages, then: Compiling Main   then Ok, modules loaded: Main    and then   *Main>      but not the output
16:51:14 <ph88> sshine: right ok i type main and i see it now
16:51:27 <ph88> sshine: can i run it in one command maybe ?
16:51:32 <sshine> ph88, if you want a runnable program, ghc file.hs; ./file
16:52:11 <rwbarton> you can also run it in one command, runhaskell file.hs
16:52:15 <rwbarton> or runghc file.hs
16:52:17 <ph88> sshine: i would like to see the output of the file in one step.  Right now it's:   ghci test1.hs    then wait, then type:  main
16:52:34 <bergmark> sshine: the fact that the errors have package name+version in them sometimes means you have several versions of a package installed
16:53:01 <sshine> bergmark, I'll try to clear them out and retry.
16:53:07 <qwebirc31963> if i could get that same functionality of cancelling the other asyncs then that would be cool: at the moment i do a first pass to pull the io actions and then a second pass to run the edsl
16:53:31 <bergmark> sshine: `ghc-pkg list aeson' for instance
16:55:04 * hackagebot tasty-golden 2.2.2.4 - Golden tests support for tasty  http://hackage.haskell.org/package/tasty-golden-2.2.2.4 (RomanCheplyaka)
16:55:52 <ph88> sshine: i try with:   ghci test1.hs && main    ... but this doesn't work
16:56:49 <tulcod> hahahaaaa it fucking compiles
16:56:58 <tulcod> oh jeez, that took me long enough
16:58:45 <ph88> congratz tulcod  :P
16:59:09 <rwbarton> ph88: runhaskell file.hs
16:59:26 <ph88> rwbarton: *high five*
17:24:06 <zq> hm
17:24:29 <zq> doesn't haskell know that all monads are functors?
17:25:32 <joelteon> the compiler doesn't assume things you don't tell it
17:26:41 <rwbarton> in 7.10 Functor will be a superclass of Monad
17:27:31 <pyon> And so will be Applicative? (I hope!)
17:28:07 <systemfault> Could that break existing code ? (haskell beginner here)
17:28:09 <joelteon> that's why it's called the Applicative-Monad Proposal
17:28:24 <joelteon> yeah systemfault, that's why GHC 7.8 warns about it
17:34:27 <mm_freak> systemfault: mostly historically broken code:  a monad should always be a Functor
17:42:18 <joelteon> in fact, for *any* instance of Monad, you should be able to define fmap = liftM
17:42:21 <joelteon> or vice versa
17:42:23 <joelteon> assuming you've defined one
17:42:54 <mm_freak> for most monads that's a terrible way to derive Functor
17:43:01 <mm_freak> and even worse for Applicative
17:43:23 <joelteon> right but you should still be able to do it
17:43:26 <joelteon> because a monad should always be a functor
17:43:34 <mm_freak> is
17:43:40 <joelteon> but in haskell terms
17:44:08 <mm_freak> i wonder how long it'll take for GHC 7.8 to become mainstream
17:44:28 <mm_freak> i'm still using 7.6.3
17:45:29 <mm_freak> even though OverloadedLists is really compelling i'll probably wait for my distribution to switch
17:45:35 <systemfault> I also have 7.6.3 (The haskell platform on OSX)
17:45:46 <systemfault> Is the haskell platform bad or what?
17:45:47 <joelteon> does 7.8 have overloaded lists?
17:45:49 <joelteon> I haven't ever actually used them
17:45:54 <mm_freak> systemfault: no
17:46:16 <systemfault> mm_freak: I was starting to worry that it only provides old softwares
17:46:34 <mm_freak> systemfault: the haskell platform is great and a good standard answer to what you should aim your libraries at
17:46:47 <joelteon> yep
17:46:49 <systemfault> Ah ok, thank you :)
17:47:12 <mm_freak> joelteon: it has them, and it would be great to write [1,2,3] rather than fromList [1,2,3]
17:48:37 <mm_freak> this is mostly useful with nested stuff
17:49:04 <mm_freak> fromList (map fromList ["abc", "def"]) would become: ["abc", "def"]
17:50:27 <joelteon> cool, I'm going to have to use some
17:50:38 <joelteon> I wonder how much overhead there is on average for "fromList []" vs "empty"
17:50:52 <mm_freak> the final missing piece is a SafeLiterals extension
17:51:01 <mm_freak> safeFromInteger :: (Num a) => Integer -> Maybe a
17:51:06 <mm_freak> uhm
17:51:10 <mm_freak> safeFromInteger :: (Num a) => Integer -> Either String a
17:51:23 <mm_freak> joelteon: depends on your instance
17:51:41 <mm_freak> if it simply translates to 'empty' and is inlined, then the overhead is zero
17:51:54 <joelteon> well, now I'm upset because my travis tests are failing, but my tests locally and on an ubuntu VM are passing
17:53:08 <mm_freak> oh, and i would also love to see a 'codo' notation, but that's probably not going to happen
17:54:03 <mm_freak> (codo imageHere <- imageThere; y) = extend (\imageHere -> y) imageThere
17:57:35 <snyp> is 'Default' a typeclass?
17:58:17 <mm_freak> snyp: could be anything without context…  it is a type class defined by the 'data-default' package
18:00:00 <benzrf> mm_freak: nice
18:00:12 <benzrf> mm_freak: hmm.....
18:01:02 <benzrf> mm_freak: you could get that with that one extn that locally scopes teh types
18:01:08 <benzrf> :t (>>=)
18:01:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:01:10 <benzrf> :t extend
18:01:11 <lambdabot> Not in scope: ‘extend’
18:01:12 <benzrf> dang
18:01:27 <snyp> mm_freak, oh i see
18:01:28 <benzrf> *teh operators
18:01:29 <snyp> yes
18:01:51 <benzrf> @google ghc extension override operator used in do
18:01:52 <lambdabot> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/syntax-extns.html
18:01:52 <lambdabot> Title: 7.3.�Syntactic extensions
18:01:56 <benzrf> heuh
18:02:16 <mm_freak> benzrf: Comonad isn't even in base, but using 'extend' isn't so bad really
18:02:26 <daniel-s_> Hi. I have a question about lambda calculus, I'm not sure if it's better to ask here or in ##math. Anyway, I think it should be simple for someone familiar: http://www.texpaste.com/n/m3qm6t0f
18:02:28 <mm_freak> would be just a convenience when you have to next it
18:02:31 <mm_freak> s/next/nest/
18:02:31 <benzrf> mm_freak: no i mean
18:02:52 <benzrf> theres a ghc extn that makes it so that resolution of (>>=) in do-block desugaring is locally scoped
18:02:55 <benzrf> instead of from Prelude
18:03:09 <benzrf> so you can locally redefine (>>=) to extend, enable the extn, then use do
18:03:41 <mm_freak> daniel-s_: what's square brackets there?
18:03:47 <mm_freak> just regular parenthesis?
18:03:47 <benzrf> mm_freak: actuallllllyyyy.... hmm
18:03:50 <benzrf> :k Free
18:03:51 <lambdabot>     Not in scope: type constructor or class ‘Free’
18:03:51 <lambdabot>     Perhaps you meant ‘Tree’ (imported from Data.Tree)
18:04:02 <mm_freak> benzrf: that's RebindableSyntax
18:04:03 <benzrf> mm_freak: you could use Free to replace bind with extend
18:04:04 <benzrf> mm_freak: aha
18:04:12 <mm_freak> benzrf: but that one rebinds to (>>=), which is for monads
18:04:20 <daniel-s_> mm_freak: yea, are they not allowed?
18:04:31 <mm_freak> would become weird when you abuse it to get comonadic composition+
18:04:54 <mm_freak> daniel-s_: square brackets are often used for substitution, so you may want to use regular parentheses there
18:05:05 <benzrf> mm_freak: noo
18:05:15 <benzrf> mm_freak: if you said (>>=) = extend
18:05:23 <benzrf> i imagine do notation would work!
18:05:32 <mm_freak> benzrf: it would, but it would be weird
18:05:40 <benzrf> mm_freak: it would still work :3
18:05:48 <benzrf> you could do
18:05:51 <benzrf> foo = do
18:05:52 <benzrf>   bar
18:06:00 <benzrf> where (>>=) = extend
18:06:01 <benzrf> or something
18:06:26 <mm_freak> daniel-s_: (\y -> (\y -> x y) (\x -> x)) ≠ (\y -> x (\x -> x))
18:06:59 <ski> benzrf : not hygienic
18:07:19 <mm_freak> daniel-s_: but they seem to be beta-equivalent, i.e. reduce to the same thing when applied
18:07:23 <benzrf> ski: how so?
18:07:30 <benzrf> oic
18:07:48 <benzrf> well u could also use Free
18:07:49 <rwbarton> do you want flip extend?
18:07:50 <l0cust> Hey, y'all. I have this file - http://lpaste.net/106991
18:07:55 <benzrf> rwbarton: probably
18:07:57 <rwbarton> ok
18:08:15 <snyp> trying to install a package(which results in reinstall of some other global packages) in a cabal sandbox results in cabal saying some globally installed packages may break... how does this happen?
18:08:21 <l0cust> I'm getting this error when I try to compile it - http://lpaste.net/106992
18:08:24 <l0cust> I understand the error
18:08:31 <l0cust> But I'm sort of looking for a workaround
18:08:38 <mm_freak> snyp: cabal doesn't really handle reinstalls/version changes
18:08:40 <snyp> How do I get rid of these kinds of errors
18:08:41 <l0cust> Is there a way to have a list of things that all fall into the same type class?
18:08:47 <Enzo21>  Hi! I give you some videos. I hope you like! http://bit.ly/1onszle
18:08:52 <mm_freak> snyp: the safest thing is to rebuild the sandbox
18:09:20 <ski> benzrf : if a hygienic macro expands to some code, then identifiers named in the definition of the macro that are being emitted in the expansion will refer to whatever they refered to at the macro definition site, not what that identifier may refer to at the macro expansion site
18:09:21 <EvanR> l0cust: thats usually how lists go because all things in the list are the same type ;)
18:09:32 <benzrf> ski: 09:05 < benzrf> oic
18:09:37 <ski> benzrf : this is basically just macros interacting properly with static/lexical scoping
18:09:44 <rwbarton> l0cust: the simple workaround is routables :: [Route]; routables = [getRoute Home, getRoute BootstrapCss, ...]
18:09:49 <mm_freak> l0cust: no (this is a well-meant lie)
18:09:49 <benzrf> ski: 09:05 < benzrf> oic
18:09:50 <benzrf> :P
18:09:56 <ski> benzrf : now, the expansion for `do'-syntax can be considered a macro expansion
18:10:08 <l0cust> mm_freak: ah, something not type-safe, eh?
18:10:16 <l0cust> rwbarton: ah okay, thats a good idea
18:10:19 <mm_freak> l0cust: what rwbarton said
18:10:41 <rwbarton> well, I guess I forgot about Eq
18:10:45 <lfairy> l0cust: "Routable r => [r]" means given *any* Routable type r, I can give you a list of it
18:10:50 <jle`> can i get an isLeft/isRight from the _Left and _Right lenses?
18:10:53 <l0cust> lfairy: ah, that makes sense
18:10:54 <snyp> mm_freak, i am trying to build a book's accompanying source code, so I just go in the directory and do 'cabal build' or do i do 'cabal install --only-dependencies' first?
18:11:07 <benzrf> jle`: isJust . preview?
18:11:09 <benzrf> :t isJust . preview
18:11:10 <lambdabot> MonadReader s Maybe => Getting (First a) s a -> Bool
18:11:14 <benzrf> its a bit gross
18:11:17 <benzrf> theres probably a better way
18:11:17 <rwbarton> but the only thing you could do with Eq is compare one element of the list to itself, rather useless
18:11:19 <jle`> indeed :|
18:11:24 <benzrf> hmmm
18:11:27 <lfairy> l0cust: yeah, so giving specific values doesn't make sense
18:11:36 <l0cust> rwbarton: well, that doesn't work, because I need a Map from routes to their controller
18:11:36 <rwbarton> jle`: has
18:11:45 <benzrf> ahaha wow
18:11:49 <daniel-s_> mm_freak: Thanks
18:12:01 <rwbarton> l0cust: well then you were in big trouble before
18:12:08 <rwbarton> l0cust: now all you need is an instance Ord Route
18:12:15 <jle`> > has _Left (Left 5)
18:12:16 <lambdabot>  True
18:12:23 <jle`> > has _Left (Right 5)
18:12:25 <lambdabot>  False
18:12:27 <rwbarton> before you would have needed to compare values that aren't even of the same type!
18:12:27 <Iceland_jack> > hasn't _Right (Left 'a')
18:12:29 <lambdabot>  True
18:12:29 <snyp> mm_freak, cabal build worked it seems
18:12:30 <jle`> cool, thanks :)
18:12:32 <l0cust> rwbarton: Routes are just Text, so Ord is taken care of
18:12:45 * ski . o O ( `has _Kell' )
18:12:48 <l0cust> rwbarton: line 59 - type Route = L.Text
18:12:50 <jle`> hm
18:12:57 <snyp> mm_freak, didn't require installing dependencies.. strange. why is this so?
18:13:00 <jle`> > has hex "a7fee"
18:13:01 <lambdabot>  True
18:13:03 <rwbarton> oh, ok
18:13:08 <jle`> > has hex "a7feer"
18:13:10 <lambdabot>  False
18:13:22 <jle`> neat
18:13:37 <lfairy> l0cust: should that be strict Text? you don't need laziness there
18:13:49 <snyp> where can i read about haskell package versions and dependencies and related?
18:13:50 <benzrf> :t hex
18:13:51 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
18:13:56 <benzrf> ski: whats _Kelly
18:13:59 <benzrf> *Kell
18:14:03 <jle`> > "a7fee" ^? hex
18:14:04 <lambdabot>  Just 688110
18:14:06 <benzrf> :t _Kell
18:14:07 <lambdabot>     Found hole ‘_Kell’ with type: t
18:14:07 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
18:14:07 <lambdabot>                the inferred type of it :: t at Top level
18:14:11 <benzrf> fiured
18:14:12 <benzrf> *figured
18:14:20 <benzrf> oh wow im a idiot
18:14:21 <benzrf> ahaha
18:14:52 <jle`> @check \xs -> has hex xs == all isHexDigit xs
18:14:54 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:14:54 <lambdabot>  ""
18:15:17 <jle`> @check \xs -> not (null xs) ==> (has hex xs == all isHexDigit xs)
18:15:18 <Iceland_jack> @check \(NonEmpty xs) -> has hex xs == all isHexDigit xs
18:15:19 <lambdabot>  +++ OK, passed 100 tests.
18:15:20 <lambdabot>  +++ OK, passed 100 tests.
18:15:45 <jle`> i didn't realize that nonempty exported the data constructor
18:15:46 <l0cust> lfairy: Probably not
18:16:06 <benzrf> :t NonEmpty
18:16:07 <lambdabot> [a] -> NonEmptyList a
18:16:10 <ski> @type and (map _f "foo")
18:16:11 <lambdabot>     Found hole ‘_f’ with type: Char -> Bool
18:16:11 <lambdabot>     In the first argument of ‘map’, namely ‘_f’
18:16:11 <lambdabot>     In the first argument of ‘and’, namely ‘(map _f "foo")’
18:16:11 <jle`> oh
18:16:12 <mm_freak> snyp: 'cabal configure' should install all required dependencies
18:16:18 <benzrf> > NonEmpty []
18:16:20 <lambdabot>  NonEmpty {getNonEmpty = []}
18:16:22 <jle`> that's a different NonEmpty than the semigroups one, huh
18:16:25 <lfairy> that's a strange NonEmpty
18:16:30 <lfairy> yeah
18:16:33 <rwbarton> probably from quickcheck?
18:16:35 <Iceland_jack> lfairy: It's just used for the Arbitrary instance
18:16:38 <rwbarton> for exactly this use case
18:16:53 <Iceland_jack> It's from .Modifiers
18:17:10 <tulcod> what's the best solution for generating haddock documentation at compile time?
18:17:13 <jle`> newtypes for different arbitrary instances, that's a nice qc idiom that i probably should ahve heard of
18:17:27 <tulcod> (like, i only know at complie time what the documentation strings are going to be)
18:17:35 <Iceland_jack> jle`: Simple versions of that can be replaced with view patterns
18:17:48 <Iceland_jack>     prop_foo (abs → x) (abs → y) = ...
18:18:07 <mm_freak> tulcod: haddock does work with template-haskell-generated code
18:18:26 <jle`> indeed Iceland_jack
18:18:27 <tulcod> mm_freak: but it doesn't allow you to document the spliced functions, does it?
18:18:40 <snyp> mm_freak, if a package is not installed in the sandbox, will cabal(ghc) build the binary agains the global package? just confirming.
18:18:42 <ski> jle` : exporting it for matching would be ok, if we had something like O'Camls private types <http://caml.inria.fr/pub/docs/manual-ocaml-4.01/extn.html#sec221>
18:18:53 <mm_freak> tulcod: i don't see an easy way to do it, but you could be able to document them in the export list
18:19:08 <mm_freak> snyp: not sure
18:19:15 <tulcod> mm_freak: the export list of a module cannot be influenced using template haskell
18:19:44 <rwbarton> or if we had something like pattern synonyms https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-synonyms
18:19:51 <rwbarton> (I think?)
18:19:53 <snyp> mm_freak, cabal configure shows no dependencies.. so it must be that the packages required are installed globally(indeed data-default is in my ~/.cabal/..)
18:19:53 <mm_freak> tulcod: yes, but if you have an export list, you need to mention the generated functions in order to export them…  perhaps haddock allows you to document them there
18:20:16 <tulcod> mm_freak: i don't know at developing time what the list of functions are going to be
18:20:17 <snyp> mm_freak, so when i do cabal install --only-dependencies, why does it try to install packages?
18:20:40 <rwbarton> the nonempty list in semigroups is structurally nonempty though
18:20:50 <rwbarton> not a "smart constructor"
18:20:54 <mm_freak> tulcod: i don't think haddock goes as far as to extract comments from generated code, but i might be wrong
18:21:19 <tulcod> well TH doesn't generate code
18:21:55 <rwbarton> maybe you could use a custom preprocessor
18:22:13 <mm_freak> snyp: i don't know, sorry…  i don't use sandboxes
18:23:01 <snyp> mm_freak, oh i see.
18:23:21 <rwbarton> if you're in a sandbox it should not use your local package db ~/.cabal/...
18:23:33 <rwbarton> really ~/.ghc/...
18:23:43 <snyp> rwbarton, oh yeah.. that folder
18:23:52 <rwbarton> it will however use the global one
18:24:02 <rwbarton> that includes the packages that came with ghc
18:24:07 <mm_freak> rwbarton: if it uses ~/.ghc, it most likely uses ~/.cabal as well
18:24:11 <rwbarton> well, yes
18:25:02 <snyp> where are the packages' .so's kept?
18:25:26 <rwbarton> wherever the package description file says, but that will be in ~/.cabal/lib/
18:25:39 <mm_freak> i think sandboxes are only isolated (builds in a sandbox don't affect other stuff), not intrinsic
18:25:45 <rwbarton> for packages installed to your per-user db
18:26:02 <rwbarton> ghc-pkg describe foo will tell all
18:26:21 <snyp> rwbarton, and the package description files are the .conf files in .ghc/x86.../package.../*.conf?
18:26:43 <rwbarton> yep
18:26:50 <mm_freak> snyp: those form your per-user GHC registry
18:27:06 <mm_freak> the actual package files are still in ~/.cabal/
18:27:44 <rwbarton> the .hi files are needed for compiling too and they are located alongside the libraries
18:28:00 <snyp> i see.
18:28:36 <mm_freak> the ~/.ghc/ directory is really only there to tell GHC which packages are found where
18:29:17 <snyp> i see
18:30:26 <snyp> rwbarton, the packages required inside a sandbox.. where are they installed?
18:31:19 <snyp> somewhere inside ~/.cabal/ or somewhere inside myproject/ ?
18:31:25 <mm_freak> snyp: the latter
18:31:26 <zq> hm
18:31:37 <zq> :t do { let v = 23; return (); }
18:31:38 <lambdabot> parse error on input ‘;’
18:31:53 <zq> doesn't do notation allow a let binding?
18:31:56 <rwbarton> "cabal sandbox hc-pkg" is the sandbox-aware version of "ghc-pkg"
18:32:11 <mm_freak> :t do let { v = 23 }; return ()
18:32:12 <lambdabot> Monad m => m ()
18:32:19 <rwbarton> zq, yes but you wrote do { let { v = 23; return (); } }
18:32:22 <geekosaur> let *also* introduces layout
18:32:39 <zq> what
18:32:42 <geekosaur> so you need extra braces if you're not doing layout
18:32:58 <rwbarton> as you could have instead written do { let { v = 23; w = 24; } }
18:33:06 <mm_freak> zq: 'let' without braces starts a layout block
18:33:09 <zq> so if i wanted to do the non-braced version of let v = case x of \n ...
18:33:11 <zq> i'd need braces?
18:33:27 <mm_freak> zq: this is not a problem when you use layout with 'do'
18:33:31 <mm_freak> do let v = 23
18:33:32 <mm_freak>    return ()
18:33:52 <geekosaur> if you're using layout there is no problem. it's only when you're one-liner-ing for ghci or lambdabot that it's an issue
18:33:54 <mm_freak> when you don't the parser needs to know where your 'let' stops
18:34:25 <mm_freak> do let x = 1; y = 2; return (x + y)
18:34:31 <mm_freak> do you see the problem?
18:34:45 <zq> nvm, i needed an extra bit of indentation
18:34:50 <geekosaur> yes
18:34:59 <zq> man, off sides rule
18:35:41 <mm_freak> rule of thumb:  readable is often equivalent to well laid out =)
18:36:17 <zq> yeah, no
18:37:01 <zq> haskell's offsides requires that the cases of a let x = case of ... begin past the "x"
18:37:20 <zq> it makes sense, though
18:37:50 <mm_freak> that's because the block starts at the x
18:38:39 <mm_freak> you can override that by using parentheses though
18:38:52 <mm_freak> let x = (case … of
18:39:11 <mm_freak> but that's probably not a good idea anyway
18:39:22 <dfeuer> Haskell syntax is too confusing. ML syntax is easier, I think.
18:39:53 <mm_freak> dfeuer: haskell syntax follows a few basic rules, and you can mostly just use your intuition
18:41:11 <l0cust> mm_freak: "A few basic rules" Ha!
18:41:11 <joelteon> so I'm having a weird issue with doctest
18:41:18 <joelteon> where it can't find some instances that are supposed to be in scope
18:41:20 <l0cust> mm_freak: I come from Lisp, though
18:42:00 <dfeuer> Yes, it will work most of the time. The rest of the time it will give you a completely useless error message because GHC's parser does not represent any of the fine qualities parsers written in Haskell can have.
18:42:06 <mm_freak> l0cust: indent past the starting column, use parentheses to override…  that's pretty much it
18:42:34 <mm_freak> dfeuer: GHC's parser represents the haskell standard
18:43:00 <mm_freak> also i'm not quite sure which rule in particular you find confusing
18:43:18 <dfeuer> mm_freak, in my limited experience you don't want to indent that far because you will run off the edge of the world.
18:43:46 <rwbarton> I don't think you can actually override the rule with parentheses
18:44:01 <mm_freak> dfeuer: i don't think i ever ran into this
18:44:13 <dfeuer> mm_freak, the indentation rules in general are confusing. My beef with GHC's parser is that it seems to offer approximately one error message.
18:44:27 <mm_freak> rwbarton: you can
18:44:58 <rwbarton> can you give an example?
18:44:59 <mm_freak> rwbarton: parentheses introduce a new layout block that continues to the closing parenthesis
18:45:37 <mm_freak> rwbarton: main = (do
18:45:37 <mm_freak> putStrLn "hello")
18:45:52 <mm_freak> where the second line is not indented
18:46:12 <rwbarton> oh, hmm
18:46:16 <rwbarton> but I can't put the ( after the do
18:46:45 <mm_freak> rwbarton: that's correct, but you can put it after the = in a 'let'
18:47:22 <rwbarton> tried that, didn't work: main = let x = (\n2+2) in putStrLn "hello"
18:47:52 <dfeuer> What does (\n2+2) mean?
18:48:14 <rwbarton> \n is supposed to be a newline
18:48:21 <mm_freak> rwbarton: hmm, you're right
18:48:30 <snyp> rwbarton, how do i remove all manually installed packages from the system?
18:48:43 <rwbarton> your original example doesn't work with {-# LANGUAGE Haskell2010 #-} so I think it has to do with NondecreasingIndentation
18:48:52 <mm_freak> snyp: first make sure you don't have anything important in ~/.cabal/config and ~/.cabal/world
18:49:07 <rwbarton> in fact, it works without the parentheses too, very funny-lookng
18:49:08 <mm_freak> snyp: if you don't, then:  rm -rf ~/.cabal ~/.ghc
18:49:25 <lfairy> mm_freak: you don't need to delete .cabal
18:49:41 <snyp> mm_freak, ok
18:49:48 <mm_freak> snyp: you may want to keep ~/.cabal/packages/ to save some bandwidth
18:49:49 <dfeuer> mm_freak, do you now understand why I consider Haskell syntax too confusing? What is NonDecreasingIndentation? Is that some new part of the standard that makes the code fall of the edge of the screen?
18:50:13 <mm_freak> snyp: this only deletes your per-user packages though…  deleting global packages may be more difficult
18:50:34 <rwbarton> mm_freak: and then (if I remove the parentheses from your example) the rest of the file is in the do-block whether I like it or not :)
18:50:44 <mm_freak> dfeuer: yes, i do, but honestly i've been using haskell for almost six years now, and i never ran into any syntax issues
18:50:50 <mm_freak> haskell syntax seems to fit my mental model
18:50:58 <snyp> mm_freak, i have never installed packages as root...
18:51:01 <rwbarton> dfeuer: it's a nonstandard extension that tries to do the opposite (keep the code to the left)
18:51:04 <mm_freak> snyp: then that's enough
18:51:15 <snyp> ok
18:52:00 <mm_freak> lfairy: you would want to delete ~/.cabal/{bin,lib,share}
18:52:22 <mm_freak> otherwise you're just wasting space
18:53:40 <snyp> i think i will try arch haskell packages.
18:53:54 <lfairy> mm_freak: fair enough. I assumed the problem was dependency hell, not disk space
18:54:29 <mm_freak> lfairy: snyp is facing cabal upgrade hell =)
18:54:39 <rwbarton> I've had some weird issues that I think may have been due to not removing ~/.cabal/lib
18:54:52 <rwbarton> and then cabal reusing build products
18:54:59 <rwbarton> but I have no proof
18:55:02 <snyp> i just learned 'cabal is not a package manager'
18:55:28 <mm_freak> snyp: and not a deployment system
18:55:43 <snyp> hmmm
18:56:47 <benzrf> so how is cabal any use without cabal-install/
18:56:50 <dfeuer> Yes, which means that Haskell *has no* package manager, so life is hard.
18:57:38 <mm_freak> benzrf: cabal-install is just a convenience…  i use regular Setup.lhs together with nix
18:57:38 <rwbarton> good thing we can still cabal install packages anyways
18:58:02 <khanage> hi all, sorry for the beginner question: i'm thrashing with monad transformers a little. I have some (MonadIO m) which the docs state will raise a fail. I'd like to wrap that up with an ErrorT to "catch" the errors and bring them back into the type system
18:58:10 <benzrf> mm_freak: Setup.lhs?
18:58:18 <mm_freak> nix does dependencies and deployment, Cabal (the real Cabal) does configuration and building
18:58:44 <benzrf> khanage: not how it works, sorry
18:58:44 <khanage> i'm not quite sure how one goes about catching these errors or putting them inside that transformer
18:58:45 <mm_freak> benzrf: the thing you use when you don't have cabal-install =)
18:58:50 <MP2E> benzrf : every haskell project ships with Setup.hs or Setup.lhs. You can compile that and run ./Setup configure && ./Setup build && ./Setup install
18:58:52 <khanage> benzrf: oh?
18:58:57 <benzrf> khanage: well
18:59:03 <benzrf> it depends on what exactly youre trying to do
18:59:12 <benzrf> MP2E: oic
18:59:14 <khanage> benzrf: that might go a way toward explaining why i'm having such a hard time ;)
18:59:34 <mm_freak> khanage: 'fail' is not an exception mechanism…  you would typically use Control.Exception for errors
18:59:36 <benzrf> khanage: you might not want to bother with the Monad* classes if youre new to transformers
18:59:42 <benzrf> try just sticking with concrete types :u
18:59:43 <mm_freak> khanage: at least for throwing them
19:00:20 <mm_freak> khanage: /catching/ exceptions is more involved across monad transformer boundaries, and many abstractions exist to deal with it
19:00:28 <mm_freak> most notably monad-control and the exceptions package
19:00:34 <khanage> mm_freak: and that would typically be in the type system? i'm using the mongo drivers and they don't expose anthing more than IO
19:01:22 <mm_freak> khanage: which package?
19:01:48 <khanage> mm_freak: http://hackage.haskell.org/package/mongoDB
19:02:29 <khanage> specifically the Access monad
19:02:37 <khanage> at http://hackage.haskell.org/package/mongoDB-2.0/docs/Database-MongoDB-Query.html
19:04:11 <mm_freak> khanage: Access or Action?
19:05:14 <mm_freak> khanage: Action is just a predefined ReaderT, so it's easy enough to use the 'exceptions' package or even write your own lifting of 'catch'/'try'
19:06:07 <khanage> mm_freak: ahh, thanks, that might be the hint that i needed
19:14:45 <meretrix> Is it possible to use a custom cabal flag to control the executable's name?  I want it to either build foo_dev or foo_prod based on the flag.
19:15:12 <mm_freak> meretrix: you'd need two executable blocks for that
19:15:18 <mm_freak> a bit inconvenient, but possible
19:15:38 <meretrix> Yeah I was hoping not to duplicate everything and possibly have a difference.
19:15:46 <meretrix> Ok thanks.
19:15:46 <aprescott> is it possible to write this in point-free style, given the appearance of str in the lambda to find? foo str = find (\char -> (==1) $ length $ elemIndices char str) str
19:15:56 <mm_freak> meretrix: works without duplication for everything except the name =)
19:16:35 <mm_freak> aprescott: it's always possible, but it's going to be ugly in this case
19:16:52 <matt1> I'm trying to use parsec to parse scheme characters of this form: '#\A', '#\a ', '#\newline'
19:17:13 <zwer> @pl \str -> find (\char -> (==1) $ length $ elemIndices char str) str
19:17:14 <lambdabot> find =<< (((1 ==) . length) .) . flip elemIndices
19:17:19 <matt1> however I'm having a hard time distinguishing between things like '#\n ' and '#\newline'
19:17:22 <aprescott> whoa
19:17:30 <matt1> here's my code:
19:17:36 <matt1> https://gist.github.com/mr/0353becee54e750a17f5
19:17:50 <aprescott> i've yet to learn =<< so i'll make a note to come back to that one :)
19:17:51 <matt1> particularly line 9
19:17:51 <meretrix> mm_freak: You mean an executable stanza can share things like build-depends?
19:18:04 <mm_freak> aprescott: it's just flip (>>=)
19:18:17 <aprescott> mm_freak: i've yet to learn >>= too :)
19:18:19 <mm_freak> aprescott: and the corresponding monad is the reader monad:  (->) e
19:18:24 <mm_freak> aprescott: ah, ok =)
19:18:31 <mm_freak> nevermind then
19:18:36 <aprescott> i'm reading through learnyouahaskell and haven't quite yet monads proper
19:19:08 <mm_freak> meretrix: no, i mean that you need only one stanza unless the name depends on a flag
19:19:34 <meretrix> Ah got it.
19:20:16 <mm_freak> meretrix: with a custom Setup.lhs you could have some kind of post-build hook
19:20:33 <mm_freak> meretrix: but may be more complicated than just writing two stanzas
19:29:38 <benzrf> stanzas?
19:30:05 <benzrf> aprescott: have you gotten to functors?
19:30:34 <aprescott> benzrf: yes, but it wasn't a very clear explanation, particularly around the Maybe example
19:30:44 <benzrf> orly
19:30:58 <benzrf> aprescott: well functors are bretty impotrant
19:31:00 <benzrf> *important
19:31:05 <aprescott> sure
19:31:15 <benzrf> aprescott: do you grok typeclasses?
19:32:29 <aprescott> benzrf: grok would be a bad description for someone who is only on day 2. i will eventually understand them fully, along with monads :)
19:33:04 <benzrf> typeclasses are not that bad
19:33:08 <benzrf> aprescott: do you know java
19:33:16 <zq> typeclasses are just abstract interfaces
19:33:27 <benzrf> zq: "just"
19:33:37 <zq> virtual class blah / abstract public school void interface blah
19:33:56 <zq> benzrf: the image of
19:35:36 <aprescott> benzrf: i don't really want to try and understand haskell through the eyes of a java programmer :)
19:35:43 <benzrf> ok
19:35:51 <benzrf> just that typeclasses are VERY similar to interfaces
19:35:54 <benzrf> so if you know tose...
19:35:56 <benzrf> *those
19:35:56 <rau> benzrf: Please stop abusing your return key, you ugly cuntface.
19:36:07 <benzrf> rau: jeez, such harsh words :(
19:36:21 <zq> is that a bot?
19:36:31 <der|> Hi, why does `addNumbers :: (Int a) => a -> a -> a` says that Int is applied to too many type arguments? :k Int is * (newbie here, please bare with me)
19:36:45 <benzrf> zq: ircname seems to suggest so
19:36:52 <benzrf> i wonder who thought #haskell would appreciate this
19:36:53 <benzrf> tsk
19:37:10 <benzrf> der|: Int is not a typeclass
19:37:22 <benzrf> der|: also, Int
19:37:28 <der|> benzrf: I’m still a bit confused, so Int is a type constructor ?
19:37:30 <benzrf> *Int's kind is *, not * -> *
19:37:35 <benzrf> der|: Int is a type
19:37:38 <der|> ah true!
19:37:38 <zq> der|: nope, it's a type, proper
19:37:39 <Iceland_jack> benzrf: You mean * -> Constraint
19:37:55 <benzrf> Iceland_jack: i thought i'd gloss over that ;p
19:37:55 <zq> der|: a type con would have arity, so * -> * -> ...
19:38:05 <der|> zq: got it, makes sense
19:38:10 <der|> so * -> * is a type const
19:38:21 <der|> a type would just be *
19:38:37 <der|> concrete type, that’s the world… (at least from the learn you a haskell book)
19:38:40 <benzrf> der|: a typeclass constructor has kind * -> Constraint
19:38:41 <der|> ** word
19:38:42 <benzrf> :k (~)
19:38:43 <lambdabot> k -> k -> Constraint
19:38:58 <zq> there are tc ctors now?!
19:38:59 <der|> benzrf: thanks
19:39:11 <matt1> If anyone cared, I asked a question earlier about Parsec and I just solved it with the 'try' function
19:39:39 <matt1> if you know what try does, I was pretty much asking if that function existed
19:40:31 <Maxdamantus> So Monad isn't a type class, but a type constructor class?
19:40:39 <Maxdamantus> Since it's (* -> *) -> Constraint
19:40:56 <benzrf> Maxdamantus: something like that :-O
19:41:43 <benzrf> Iceland_jack: youre an op, right
19:41:53 <der|> In which fields is Haskell most used in? systems, web, etc...
19:42:00 <benzrf> i find rau to be a pretty obnoxious bot
19:42:25 <Iceland_jack> No I'm not an op
19:42:36 <Iceland_jack> <rau> benzrf: Please stop abusing your return key, you ugly cuntface.
19:42:36 <Iceland_jack> Should definitely be kicked
19:42:58 <benzrf> it appears to draw from a random insult pool
19:43:07 <benzrf> it called me an 'abhorrent wannabe' in #ruby
19:43:13 <benzrf> apparently it also uses 'aspie
19:43:25 <benzrf> @op
19:43:26 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
19:43:28 <benzrf> hm
19:43:32 <Iceland_jack> @where ops
19:43:32 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:44:14 <geekosaur> saw that elsewhere as well
19:44:15 --- mode: ChanServ set +o geekosaur
19:44:26 --- mode: geekosaur set +b *!*rau@87.117.225.*
19:44:26 --- kick: rau was kicked by geekosaur (rau)
19:44:41 <zq> rau :: Void
19:44:52 <StoneCypher> wat
19:45:13 <StoneCypher> whoa, he did it in here too
19:45:32 <benzrf> when i triggered it in #ruby somebody applauded
19:45:33 <benzrf> =[
19:45:38 <benzrf> >tfw ruby community
19:45:43 <geekosaur> also in #freebsd
19:45:52 --- mode: geekosaur set -o geekosaur
19:47:41 <benzrf> and ##math
19:49:48 <zq> are there any viable alternatives to monad transformers?
19:49:55 <benzrf> zq: few
19:50:03 <benzrf> at least, few as general
19:50:11 <benzrf> there may be domain-specific solutions, depending
19:50:29 <zq> such as? the general ones
19:50:46 <benzrf> there's something called extensible-effects
19:50:49 <benzrf> i dont know much about it
19:56:35 <pjdelport> zq: You can compose Applicatives without transformers, if you don't need monadic joins.
19:57:14 <zq> no i really do need >>= to do what it does best
19:59:39 <benzrf> zq: oh?
19:59:45 <benzrf> whats that
19:59:56 <jle`> presumably, bind
20:00:16 <benzrf> zq: you know that almost any case where the later actions dont depend on the earlier result can be applicative'd fyi
20:03:17 <gsingh93_> I'm trying to learn how to use quickcheck, but I can't figure it out
20:03:34 <gsingh93_> I have a stack data structure I want to test: http://pastebin.com/6VvsHQQZ
20:03:56 <gsingh93_> i'm not sure how to write the tests for it
20:04:17 <benzrf> gsingh93_: write a function that returns a boolean
20:04:26 <benzrf> (or other type satisfying the typeclass)
20:04:29 <benzrf> and takes a stack
20:04:33 <benzrf> then write an Arbitrary instance for stack
20:04:34 <benzrf> poorf
20:04:58 <gsingh93_> apparently I have to pass quickCheck a "property"
20:05:03 <gsingh93_> how do i do that?
20:05:30 <benzrf> gsingh93_: generally youll want to pass it a function from some value satisfying Arbitrary to some kind of testable result
20:05:40 <benzrf> usually, the type you want to test to boolean
20:05:41 <benzrf> for example:
20:06:06 <benzrf> @check \l -> reverse l != l
20:06:07 <lambdabot>  Not in scope: ‘!=’
20:06:07 <lambdabot>  Perhaps you meant one of these: ‘!’ (imported from Data.Array), ‘M.!’ (impor...
20:06:11 <benzrf> @check \l -> reverse l /= l
20:06:13 <lambdabot>  *** Failed! Falsifiable (after 1 test):
20:06:13 <lambdabot>  []
20:06:22 <Iceland_jack> gsingh93_: Just any function returning a Bool (or Property)
20:06:39 <gsingh93_> what is a property though?
20:06:43 <Iceland_jack> you can ignore that
20:07:12 <Iceland_jack> but if you want to say, ignore all even numbers, you'd do
20:07:12 <Iceland_jack>     prop_foo n = even n ==> ...
20:07:29 <Iceland_jack> '==>' creates a property, but ignore that: it's trivial to use
20:09:02 <dagano> i'm trying to fold an IntMap [(Int,Int)] into a PQueue.Min (Int,Int) with a fold function :
20:09:05 <dagano> makePQ gr = IM.fold (PQ.insert) PQ.empty gr
20:09:26 <dagano> takes : fromList [(1,[(2,3)]),(2,[(5,2),(4,6),(3,4)]),(3,[(4,5)]),(4,[(5,7)])]
20:09:29 <dagano> this intmap
20:09:33 <dagano> to this pqueue
20:09:41 <dagano> fromAscList [[(2,3)],[(4,5)],[(5,2),(4,6),(3,4)],[(5,7)]]
20:09:50 <gsingh93_> How do I implement arbitrary for a data structure?
20:10:28 <Iceland_jack> gsingh93_: You should probably learn how to use QuickCheck for existing data structures first, but you just make an Arbitrary instance
20:10:42 <benzrf> > shrink 3
20:10:43 <lambdabot>  [0,2]
20:10:46 <benzrf> ??
20:10:50 <benzrf> what does shrink do?
20:11:02 <Iceland_jack> gsingh93_: For your case I would create an arbitrary list and turn it into a Stack
20:11:12 <benzrf> gsingh93_: you provide a random generator of that type
20:11:17 <Iceland_jack> for further information see http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
20:11:28 <benzrf> gsingh93_: it should be simple enough to just turn a gen for lists into a gen for stacks
20:11:31 <Iceland_jack>     instance Arbitrary a => Arbitrary (Stack a) where
20:11:48 <benzrf> fmap (foldr Cons Nil) arbitrary
20:11:50 <benzrf> or something
20:11:52 <Iceland_jack>         arbitrary = stackToList <$> arbitrary
20:12:06 <Iceland_jack> *listToStack ofc
20:12:32 <Iceland_jack> But definitely learn the basics of QuickCheck first
20:13:23 <benzrf> gsingh93_: the core idea of QuickCheck is that you provide something that takes a random value for t and returns whether t satisfies some kind of conditoin
20:13:29 <gsingh93_> benzrf: How can you just call fmap over the arbitrary function like that?
20:13:31 <benzrf> then quickcheck automatically generates cases to test your assertion
20:13:38 <benzrf> gsingh93_: arbitrary is a value
20:13:42 <benzrf> well
20:13:47 <Iceland_jack> gsingh93_: read this http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
20:13:51 <benzrf> a field of the Arbitrary typeclass
20:14:03 <Iceland_jack> Arbitrary is an instance of Functor, that's why you can fmap over it
20:14:10 <benzrf> Iceland_jack: you mean gen
20:14:12 <benzrf> *Gen
20:14:22 <Iceland_jack> no
20:14:35 <Iceland_jack> no you're right
20:14:39 <benzrf> gsingh93_: Arbitrary is the typeclass that specifies how to pick random cases for a type to feed to your assertions
20:14:42 <benzrf> Iceland_jack: ;p
20:16:48 <gsingh93_> btw, what does that <$> operator you used above do, Iceland_jack
20:16:54 <Iceland_jack> <$> is fmap
20:17:02 <Iceland_jack> @src (<$>)
20:17:02 <lambdabot> f <$> a = fmap f a
20:17:09 <gsingh93_> oh, kk
20:17:18 <jle`> what dark times we are living in, on the verge of the AMP finally being resolved
20:17:24 <jle`> we're going to look back on these days in two or so years
20:17:33 <jle`> and think "how did they ever get anything done...i'm glad i wasn't born in those times."
20:17:44 <kvanb> jle`does AMP mean monads are functors too?
20:17:47 <Iceland_jack> gsingh93_: A simple example how how to use QuickCheck
20:17:47 <Iceland_jack>     quickCheck (\a b -> a + b == b + a)
20:17:47 <jle`> yes
20:17:52 <kvanb> yay
20:17:57 <Iceland_jack> you can then give the property a name
20:18:05 <jle`> no more having to use liftM
20:18:14 <benzrf> Applicative Monad Proposal, maybe?
20:18:19 <jle`> everyhwere
20:18:33 <jle`> benzrf: yes
20:23:08 <Javran> someone has asked me a question that I don't know how to answer: what's the point of making `getArgs` an `IO [String]`, does that change / reading that has side effects during execution?
20:23:21 <benzrf> Javran: yes
20:23:33 <benzrf> the value cannot be ascertained without running it
20:23:41 <jle`> :t getArgs
20:23:42 <lambdabot> Not in scope: ‘getArgs’
20:23:46 <benzrf> i mean without running the process
20:23:51 <Iceland_jack> :t System.Process.getArgs
20:23:52 <lambdabot> Not in scope: ‘System.Process.getArgs’
20:23:55 <benzrf> Javran: it's not a function of its arguments
20:23:55 <Iceland_jack> :t System.Environment.getArgs
20:23:56 <lambdabot> IO [String]
20:23:57 <Javran> but he argued that we can keep it as a constant for each process
20:24:03 <benzrf> that's sort of true
20:24:06 <benzrf> but it feels wrong
20:24:09 <jle`> what would it be if not IO [String] ?
20:24:09 <Iceland_jack> that can that
20:24:12 <Iceland_jack> *that can change
20:24:18 <jle`> just [String] ?
20:24:26 <benzrf> Iceland_jack: yeah, but for any given haskell instance it will always be a constant
20:24:30 <benzrf> so you could pretend that it's predefined
20:24:30 <ReinH> We could, but why?
20:24:35 <benzrf> but it's sort of dirty
20:24:41 <genisage> just [String] or Just [String]?
20:24:43 <benzrf> it's theoretically possible
20:24:44 <Iceland_jack> You can still modify argv from an external process
20:24:53 <benzrf> but it doesnt seem right
20:25:03 <ReinH> Haskell programs execute main anyway.
20:25:35 <Javran> is getArgs a wrapper for some system calls?
20:25:39 <benzrf> if you want to treat varying values like plain ones perhaps youd like FRP
20:25:45 <benzrf> Javran: of course
20:25:48 <rwbarton> Javran, no
20:25:52 <benzrf> rwbarton: really
20:25:53 <benzrf> ?
20:25:56 <rwbarton> just reading some global variable
20:26:00 <jle`> i like the idea that anything outside of the compiled binary is IO
20:26:08 <benzrf> oh i suppose args come from main
20:26:13 <benzrf> as opposed to from a sys call
20:27:39 <Javran> that sounds good if reading arguments is in some sense like reading env variables
20:35:18 <dmwit> ?seen Tjr
20:35:18 <lambdabot> tJR
20:35:23 <dmwit> err
20:35:36 <dmwit> I guess we don't have a seen-bot anymore.
20:35:37 <dmwit> Too bad.
20:36:17 <Iceland_jack> ?seen leet
20:36:17 <lambdabot> Le3T
20:36:49 <Javran> ?seen lambdabot
20:36:49 <lambdabot> LAMBda8o7
20:37:13 <Iceland_jack> ?seen elite
20:37:13 <lambdabot> leet
20:37:38 <dmwit> ?tell Tjr Another reason lazy IO is bad that other people didn't mention is that it destroys compositionality. The accepted answer to http://stackoverflow.com/q/6668716/791604 has a great explanation of this complaint.
20:37:38 <lambdabot> Consider it noted.
20:37:38 <dfeuer> @seen seen
20:37:39 <lambdabot> $33n
20:37:54 <Iceland_jack> @leet seen
20:37:55 <lambdabot> sEen
20:38:18 <jle`> seen was preflex
20:38:24 <jle`> but preflex is no longer with us
20:38:39 <dmwit> In an age long past, \bot, too, had a seen plugin.
20:39:37 <jle`> a curious thing, time
20:43:42 <dfeuer> So why don't we have a seen bot anymore, on a channel that is, after all, logged?
20:44:33 <dmwit> I think it was removed from \bot because it was buggy.
20:45:15 <dmwit> Probably preflex isn't around any more because its owner isn't around any more.
20:49:49 <codygman> Can someone help me understand what is wrong with this code: http://lpaste.net/106998
21:00:37 <tolt> codygman: have you found this http://www.yesodweb.com/book/persistent ?
21:01:09 <codygman> tolt: Yes, I've looked at it (and read the whole chapter/tutorial once) but it's not making things more clear for me.
21:01:15 <codygman> Looking again now though.
21:03:20 <tolt> So, it's not being ran inside a monad that has an insance of MonadLogger. If you look at the type for runMigration it has MonadSqlPersist m on m. If you look into MonadSqlPersist you can see that it requires m to also have a MonadIO and MonadLogger instace. (http://hackage.haskell.org/package/persistent-1.3.1.1/docs/Database-Persist-Sql.html#t:MonadSqlPersist)
21:03:48 <glguy> codygman: check the type of migrateAll, it probably requires to be run at a type that has a MonadLogger constraint
21:04:56 <tolt> if you look at http://hackage.haskell.org/package/persistent-sqlite-1.3.0.5/docs/Database-Persist-Sqlite.html#v:runSqlite you can see that runSqlite runs something in the SqlPersistT monad which has an instance of MonadLogger
21:05:15 <tolt> hopefully that makes sense codygman
21:05:25 <codygman> tolt, glguy: Thanks, I'm looking at the docs now.
21:06:04 <ddellacosta_> [newb-filter] I'm using this tutorial for getting a cabal sandbox going, but it begs the question--has anyone automated this to any degree? http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
21:07:01 <Cale> ddellacosta_: If so, then I'm not aware of it
21:07:23 <codygman> tolt: It was fairly easy to make it work with the runSqlite function, but I'm wondering what the author of this gist: https://gist.github.com/egonSchiele/5400694 was trying to do with the runDb combinator. Im' guessing that adding a constraint to the runDB function for monad logger would make this code work now?
21:09:52 <tolt> Good. It might be a new requirement. I'm not sure as I haven't done much with that but you could always remove the type signature and see if it works...
21:10:13 <dmwit> (That's not what "begs the question" originally meant.)
21:12:30 <ddellacosta_> Cale: okay, thanks. Coming from the Clojure world, I'm spoiled by all the hand-holding that leiningen does for you when starting a new project.  Mostly I'm still trying to understand what makes up a coherently structure haskell project, so that's why I ask.
21:12:47 <ddellacosta_> *structured
21:12:48 <benzrf> wat does lein do for you precisely that cabal et al doesnt
21:13:05 <benzrf> ddellacosta_: a basic cabal skeleton should probably handle your needs...
21:13:16 <tolt> ddellacosta_: you might be interested in https://hackage.haskell.org/package/hi
21:13:21 <ddellacosta_> benzrf: well--and this could be my ignorance, so please forgive me if I'm mistaken--it generates the equivalent of the config file, for example, and a default directory structure
21:13:25 <tolt> I don't know why hi isn't used as much.
21:13:36 <ddellacosta_> (ignorance of what cabal or Haskell provides I mean)
21:13:43 <ddellacosta_> tolt: ah, thanks, let me try that
21:13:46 <benzrf> ddellacosta_: it makes a cabal conf file and a simple boilerplate file to run it
21:13:52 <benzrf> what do you need, exactly?
21:14:22 <ddellacosta_> benzrf, tolt: yeah, hi looks like it--that's exactly what I was looking for: a skeleton and boilerplate file for config
21:14:34 <benzrf> i doubt hi adds much useful
21:14:52 <benzrf> afaict you dont need much in a haskell project dir besides a src tree, a Setup.hs, a cabal file, and maybe a test dir
21:14:56 <khanage> another thing lein gives you is user supplied templates
21:15:02 <khanage> looks like hi has something similiar
21:15:05 <dmwit> ddellacosta_: Have you tried "cabal init"?
21:15:09 <khanage> but not quite as sophisticated
21:15:12 <ddellacosta_> benzrf: yeah, I'm just ignorant of those basics
21:15:31 <tolt> benzrf: It's not like you couldn't do it yourself but it's nice to not have to worry about that when you don't know how to use cabal.
21:15:40 <khanage> with lein you can run "lein new compojure name" and have a web project ready to roll
21:15:51 <ddellacosta_> dmwit: I ran cabal sandbox init, and of course I see the sandbox config file
21:15:59 <benzrf> tolt: you just type cabal init
21:16:10 <jle`> cabal init usually does everything i need
21:16:19 <ddellacosta_> yeah, it's more just that I don't know yet what is needed and what isn't in Haskell
21:16:35 <benzrf> ddellacosta_: all you need is a project conf file and a source tree basically
21:16:39 <benzrf> the Setup.hs is boilerplate
21:16:40 <khanage> it would be awesome to have something similiar for the cabal ecosystem
21:16:40 <ddellacosta_> so was looking for something like hi, and/or docs
21:17:05 <benzrf> ddellacosta_: i guess if youre working in a particular framework you might want scaffolding for that
21:17:06 <ddellacosta_> benzrf: yes, but--what structure is required for source tree, for example?  what are the conventions?  I just am not sure where to look for that stuff.
21:17:11 <benzrf> but yesod has its own tool, for example
21:17:12 <jle`> actually now that i think about it i still really don't know what i'm doing
21:17:15 <benzrf> ddellacosta_: just run cabal init
21:17:15 <ddellacosta_> benzrf: yeah, there's that too I guess
21:17:32 <benzrf> ddellacosta_: after that, cabal build should do everything to build your project automatically
21:17:36 <jle`> i just wing it and hope people don't get mad at me :|
21:17:42 <benzrf> and cabal install if you want to load the exes or libs into your systemfault
21:17:43 <benzrf> *system
21:17:49 <ddellacosta_> benzrf: cabal init vs. cabal sandbox init?
21:17:58 <benzrf> cabal init sets up a project in an empty dird
21:17:59 <benzrf> *dir
21:18:03 <systemfault> benzrf: I don’t want to be loaded with exes and libs :/
21:18:05 <benzrf> cabal sandbox init sets up a sandbox
21:18:14 <benzrf> which you do not need, but may use if you like
21:18:21 <benzrf> it certainly doesnt hurt
21:18:32 <benzrf> ddellacosta_: the .cabal format is pretty self-explanatory
21:18:40 <benzrf> it's vaguely yaml-ish
21:18:40 <dmwit> ddellacosta_: cabal init is distinct from cabal sandbox init
21:18:53 <ddellacosta_> dmwit, benzrf: okay, this is very helpful
21:18:57 <dmwit> ddellacosta_: Perhaps somebody else said that since you replied to me, in which case sorry for the repetition.
21:19:04 <dmwit> (I'm only half here.)
21:19:14 <benzrf> ddellacosta_: the .cabal file lists what libs and exes the project contains
21:19:24 <benzrf> each lib or exe has some info, like what packages are involved
21:19:32 <benzrf> you can manually edit those in, or there may be some tool
21:19:35 <tolt> (and what dependencies it has)
21:20:13 <benzrf> ddellacosta_: the src dir is the typical location for your source tree, but strictly you could tell cabal to load from anywhere
21:20:45 <benzrf> ddellacosta_: the path for a module should be src/[replace all dots in the module name with slashes].hs
21:20:58 <benzrf> so Data.Foo.Base becomes
21:20:59 <ddellacosta_> okay, gotcha
21:21:04 <benzrf> src/Data/Foo/Base.hs
21:21:25 <benzrf> ddellacosta_: that results in the common convention of having whatever/Foo.hs and whatever/Foo/{More,Modules}.hs
21:21:26 <ddellacosta_> benzrf: and are there specific conventions around that (or docs you could point me to to read about the conventions)?
21:21:32 <benzrf> as in Control.Monad and Control.Monad.Whatever
21:21:38 <ddellacosta_> benzrf: and, there's the answer. :-)
21:21:46 <benzrf> ddellacosta_: most of what i know comes from running cabal init and then poking around the file
21:21:50 <benzrf> it's not very complicated stuff
21:21:59 <ddellacosta_> benzrf: gotcha, that's a good clue though
21:22:17 <dmwit> cabal init will guess dependencies for you if you already have some code.
21:22:17 <jle`> still, it'd be nice to have some sort of style guide somewhere for people to look at and agree upon.  barring that, i see why something like hi would be useful
21:22:33 <ddellacosta_> dmwit, tolt, benzrf: thanks to all of you, this is really super helpful stuff. much appreciated!
21:22:36 <dmwit> But it is not smart about merging with an existing .cabal file. It will just clobber it.
21:22:39 <benzrf> if you want a small project to glance at you could check out my repo for vampire
21:22:42 <ddellacosta_> jle`: yeah, that's all I was asking about
21:22:50 <benzrf> https://github.com/benzrf/vampire/
21:22:56 <jle`> it's a bit unscalable to expect everyone to go to the irc channel and ask
21:22:58 <dmwit> There is a style guide on the Haskell wiki.
21:23:00 <benzrf> ^no guarantees on Best Practices here
21:23:02 <benzrf> but it works for me
21:23:08 <jle`> oh yeah, there is.  that's the one i used :)
21:23:09 <tolt> jle`: Yep. We use it at work all the time. It's nice to have a standard that you don't have to worry about.
21:23:14 <dmwit> And there's Acme.HelloWorld or whatever.
21:23:16 <jle`> maybe we should have linked that in the beginning
21:23:17 <benzrf> oh hold on
21:23:21 <benzrf> i didnt even put my stuff in a src dir
21:23:22 <benzrf> oops
21:23:24 <ddellacosta_> haha...yeah, where's that link?
21:23:36 <benzrf> ddellacosta_: iunno which thing i said was wrong
21:23:37 <benzrf> >.>
21:23:43 <ddellacosta_> benzrf: ?
21:23:57 <benzrf> i just realized my repo assumes the project root as the source tree root
21:24:02 <benzrf> instead of being in root/src
21:24:11 <ddellacosta_> benzrf: oh, so that one is not the best example possibly, is what you mean?
21:24:14 <jle`> some people go straight into ./
21:24:26 <jle`> like...libraries from the platform
21:24:26 <dmwit> ddellacosta_: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:24:26 <benzrf> ddellacosta_: probably doesnt make a huge difference
21:24:30 <benzrf> let me just shift that over real quick
21:24:31 <ddellacosta_> well, here's one bit: http://www.haskell.org/haskellwiki/Programming_guidelines#Naming_Conventions
21:24:35 <ddellacosta_> dmwit: ah, okay, thanks
21:26:34 <dmwit> It's not really important to have a separate directory for your code until your package ships both a library and an executable.
21:27:06 <dmwit> Then you will want to put the library code somewhere that's invisible to the executable build to avoid duplicated work.
21:27:25 <benzrf> kk fixed my repo
21:27:25 <dmwit> i.e. making the compiler re-compile library code because it sees a local copy and figures it should prefer that to the installed library.
21:27:29 <ddellacosta_> any convention regarding tests?
21:27:33 <ddellacosta_> as in where they go
21:27:40 <benzrf> ddellacosta_: it should now be an adequate simple example of a cabal project :p
21:27:44 <ddellacosta_> and, other resources?
21:27:48 <ddellacosta_> benzrf: okay, thanks. :-)
21:27:51 <benzrf> actually
21:28:02 <benzrf> whatever dmwit is saying
21:28:03 <benzrf> i didnt do
21:28:05 <benzrf> so
21:28:08 <benzrf> just ignore me
21:28:11 <benzrf> :p
21:28:18 <benzrf> im probably not a model citizen
21:28:29 <ddellacosta_> benzrf: hahaha...no worries, I appreciate the help. :-)
21:28:45 <dmwit> ddellacosta_: The wiki page I linked you has a section on tests.
21:29:07 <ddellacosta_> dmwit: ah, I missed it, sorry!
21:29:16 <ddellacosta_> right, I see
21:29:53 <ddellacosta_> okay, I'm going to actually go, like, write some code now.  Thanks to all for the help.
21:30:00 * ddellacosta_ loves #haskell
21:30:13 <dmwit> Yay, code!
21:30:17 <ddellacosta_> :-)
21:30:49 <tolt> does anyone know who ran https://twitter.com/hackage ?
21:31:24 <benzrf> leiningen vs the ants wp page says:
21:31:25 <benzrf> >Leiningen is also the name of a build tool for Clojure, a programming language for the Java Virtual Machine. Its name is a play on the name of a traditional Java build tool called Ant.
21:31:30 <benzrf> i never got that
21:31:32 <benzrf> wahaha
21:34:52 <startling> that's really funny
21:36:27 <systemfault> Perhaps it’s my english that isn’t good… but what is the link between leningen and ant?
21:36:31 <systemfault> (namewise)
21:36:53 <benzrf> systemfault: an old short story called leiningen vs the ants
21:36:56 <gws> http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants
21:36:56 <benzrf> 12:29 < benzrf> leiningen vs the ants wp page says:
21:36:58 <systemfault> Ahhh
21:37:23 <systemfault> Thank you
21:37:40 <startling> (the other link is that ant is a java build tool and leiningen is a clojure build tool, and clojure is a jvm language.)
21:38:34 <zq> man
21:38:49 <zq> haskell needs a bona fide pkg mgr, not this sort-of-maybe-not-really build shit
21:39:54 <dmwit> Seems a tradeoff.
21:40:01 <dmwit> cabal does a lot of things my package manager doesn't.
21:40:15 <benzrf> i think nix works for pkga
21:40:18 <benzrf> *pkga
21:40:19 <benzrf> ugh
21:40:20 <benzrf> *pkgs
21:40:29 <monochrom> you need to pay money for a haskell package manager
21:41:07 <dmwit> or time
21:41:11 <ddellacosta_> leiningen is nice, but it also is hiding a lot of evil Maven stuff.  You're dealing with a very different beast with a JVM language, comparisons can be tricky
21:43:54 <zq> benzrf: yeah no i'm not too keen on having 50 gb of crud waiting to be 'garbage collected'
21:44:50 <zq> cabal exec doesn't really cut it
21:44:55 <zq> no siree
21:45:07 <Cale> ddellacosta_: You can often get by even without writing a .cabal file btw. It's really for more complex projects or when you start distributing your libraries that you start to need it.
21:45:18 <mzero> zq: what else would you have it do?
21:45:18 <mzero> I suspect that nix, working at the level of individual haskell dev. packages, would fare no better than cabal
21:45:50 <Cale> ddellacosta_: (or sandboxes for that matter)
21:46:07 <zq> mzero: idk, but the problem is that i can't, say, have my bash loaded with a selected sandbox
21:46:13 <zq> mzero: bashrc, that is
21:46:16 <ddellacosta_> Cale: yeah, I've done very basic stuff where I just load up a file before.  I guess I'm trying to make sure I have a sense of what a "real" project consists of at this point.  Something you'd actually package and hope other people could get going with minimal pain.
21:47:02 <zq> obv can't throw in a 'cabal exec bash' inside bashrc, so the only remaining option is to manually export GHC_PACKAGE_DB, but hey, cabal refuses to play with that set meaning i can't cabal install without first unsetting that envvar
21:47:25 <zq> maybe the real problem is why cabal isn't friends with $ghc_package_db
21:48:38 <fumieval> fumieval
21:49:14 <fumieval> ^H^H^H^H^H^H^H^H
21:51:29 <zq> also, cabal sandboxes not being relocatable is a pita
21:51:38 <zq> what does #haskell think of 'cabal relocate'
21:51:45 <mzero> our packages exhibit greater dependencies, our package versions change more quickly, and our likelihood of diamond depdnency issues more likely than the usual collection of unix packages
21:53:52 <zq> mzero: was that a response for me?
21:55:03 <zq> because i'm not seeing how deps are relevant to relocatability
21:57:24 <benzrf> holy crap http://www.anagrammy.com/literary/rg/poems-rg8.html
21:57:40 <benzrf> oops wrong channel
21:57:48 <jle`> is there a way to define an instance locally only for a module
21:58:21 <jle`> like...not export an instance
21:59:48 <mzero> I think because GHC is trying to deprecate the GHC_PACKAGE_DB env var ASAP
22:01:01 <mzero> but, what you're after is running a shell in an environment where all the haskell tools see only the sandbox'd package environment?
22:02:58 <mzero> zq: I think a more powerful thing would to have package.conf.d entreis be relative to the db
22:03:04 <mzero> then you can just move the whole thing around - done
22:03:04 <mzero> actually, I think ghc-pkg db format has this... there is some ${TOPDIR} thing that I don't understand
22:03:26 <mzero> zq: about the shell, yes
22:03:27 <mzero> deps aren't relevant to relocatability -- i just assumed you were being bitten by deps issues - as that is what most people complain about cabal
22:04:07 <mzero> I didn't realize the issues you were having had to do with managing the package environment itself
22:04:22 <pavonia> jle`: No, you can't
22:04:23 <mzero> wrong channel, benzrf - but awesome nonetheless
22:04:30 <jle`> pavonia: :(
22:05:31 <benzrf> how do u even do that level of anagram
22:06:17 <MP2E> very carefully
22:06:55 <benzrf> i guess you can get away with throwing away some extra letters with nonsense bits
22:07:00 <mzero> So love 'NON' and 'FAT' - that's just brilliant
22:07:17 <mzero> it has *less* nonsense than the original monologue!
22:07:52 <benzrf> well its basically a rewritten condensation of the play
22:08:19 <benzrf> which has enough non sequiturs that you can probably get away with a few in a pastiche
22:08:26 <benzrf> handy for anagramming o:
22:08:49 <mzero> dare I ask what channel that was originally intended for?
22:08:52 <solirc> joelteon: Did you solve you issue?
22:08:55 <benzrf> #haskell-blah
22:08:59 <benzrf> where i also posted it
22:09:00 <Shirley21>  Here some videos. I hope you like them! http://j.mp/1j5OXSw
22:09:15 <MP2E> Always SomeName21 with the videos
22:11:45 <zq> maybe set the registered freenode member flag on #haskell
22:13:22 <gfixler> syntactically, would haskell work without all the list commas?
22:14:04 <gfixler> You may have guessed I've been playing in Clojure :)
22:14:37 <sclv_> gfixler: you mean like a list of numbers would like like [1 2 3 4 5]
22:14:42 <sclv_> ?
22:15:08 <lfairy> That could work, but then we'd need parens around the items
22:15:20 <sclv_> the problem is hakell treats “x y” as “x applied to y”
22:15:30 <lfairy> e.g. [(f x) (g x) 42]
22:15:47 <sclv_> lisp-derived syntax treats things like ( and [ as introducing “special forms” that are treated differently
22:15:49 <gfixler> sclv: yep
22:15:54 <sclv_> haskell style s
22:16:11 <sclv_> haskell style syntax is actually more uniform here, but there’s a price we pay...
22:16:35 <nexion> hey guys, I have a question about designing something in Haskell where I suspect that Haskell's type system could allow for safer/cleaner approaches than the naive one I can think of
22:16:36 <sclv_> so yeah, we _could_ use special forms for lists, but the payoff wouldn’t be that great, especially since list/vector literals are much less common in haskell
22:16:40 <gfixler> sclv_: ah, right - function application
22:16:42 <nexion> I've described it at http://pastebin.com/6BMdW044
22:16:50 <nexion> just looking for ideas :)
22:17:20 <lfairy> say... can we actually implement [1 2 3 4 5] syntax using OverloadedLists and a clever Num instance?
22:18:24 <gfixler> lfairy: would 1 2 apply 1 to 2 and yield [1,2], somehow?
22:19:01 <MP2E> Well, [1 2 3 4 5] would desugar to [] 1 2 3 4 5, wouldn't it? Maybe somehow we could make function application cons
22:19:06 <MP2E> Idk how you would do that, tbh
22:19:33 <lfairy> MP2E: you mean (1 2 3 4 5) : []
22:19:41 <MP2E> ah right
22:19:43 <startling> you could do it with instance Num a => Num (a -> a)
22:20:02 <sclv_> nexion: data FinValues a = FinValues [(Date,Integer)] and then you use the phantom a to tag the meaning of the Ints
22:20:06 <startling> er, (Num a, Num b) => Num (a -> b)
22:20:10 <sclv_> now you need to write your other code to deal with that...
22:20:26 <startling> there's probably some ambiguity though -- might need fundeps or use a type family instead.
22:20:28 <sclv_> like return Either (FinValues Unit) (FinValues Cents) or the like...
22:20:33 <nexion> oh, interesting
22:20:50 <startling> [1,000,000] would be more interesting. :)
22:20:57 <benzrf> off the top of my head
22:21:01 <benzrf> you COULD use a sum type
22:21:12 <benzrf> where cents or units are constructors of the same type
22:21:24 <lfairy> hmm... instance Num a => Num ([a] -> [a]) where fromInteger n = (fromInteger n :)
22:22:36 <lfairy> no, that won't work
22:23:09 <nexion> would it make sense to somehow tag FinancialsKey with the type?
22:23:23 <nexion> since one key will map to exactly one type
22:23:58 <Maxdamantus> The `i` quasiquoter thing already defies the application syntax.
22:24:17 <Maxdamantus> [i| a b c d] → a <$> b <*> c <*> d
22:24:19 <nexion> then if I query for that key (NetIncome), the value can only be in cents and not units
22:26:21 <RLIN> stop
22:26:26 <ski> start
22:26:28 <Maxdamantus> hammer time
22:27:08 <RLIN> lol, oops. didn't realize i was inside the chatroom already.
22:27:34 <ski> hehe, it's called a "channel", around these parts :)
22:28:05 <ski> RLIN, welcome to #haskell
22:28:20 <ski> got any Haskell-related question (or comment) ?
22:28:22 <RLIN> as a introduction to haskell, would anyone recommend real world haskell as a good beginner's source?
22:28:34 <RLIN> course*
22:28:50 <ski> i think LYAH is more often recommended to pure newbies
22:29:03 <MP2E> there are many good beginner's courses actually! Real World Haskell and Learn You a Haskell are both great references
22:29:06 <khanage> RLIN: i've introduced a few coworkers to haskell, and had the most positive reactions with LYAH
22:29:07 <ski> perhaps after it, you can try RWH
22:29:45 <RLIN> okay, thanks. i'll look into LYAH too.
22:29:48 * ski learned from "Haskell: The Craft of Functional Programming"
22:29:59 <augur> ey ski
22:30:13 <nexion> I've learned from trying to create a multi-threaded ircd
22:30:19 <nexion> and then failing at it
22:30:28 <nexion> and trying another project, which worked out a lot better
22:30:41 <MP2E> Losing is Fun!
22:30:44 <MP2E> ;P
22:30:44 <ski> lo, augur
22:30:46 <nexion> it was very educational
22:30:53 <nexion> I did it wrong, but I realized why
22:31:04 <RLIN> i tried "write you a scheme in 48 hours", it was miserable, and i couldn't complete any of it.
22:31:09 <augur> in what ways does ML differ from C such that you can say ML is a version of the lambda calculus but C is not
22:31:56 <ski> ML has local functions, and immutable variables
22:32:37 <augur> sure. im sure there are versions of the LC without local functions, however
22:32:43 <ski> RLIN : i suspect it's mostly for people who already know basic Scheme
22:33:10 <augur> as for immutability, C can be seen as a version of the LC embedded within an appropriate monad at all times, surely, so it has immutable, but boring, inaccessible variables
22:34:02 <ski> most typical LC has local functions, though
22:34:16 <augur> eg why cant you view C vars as always being IORefs, and all relevant operations as IO ops?
22:34:43 <ski> you probably can
22:34:56 <augur> i believe you probably can
22:35:11 <pyon> augur: Can you have "dangling IORefs"?
22:35:12 <ski> (you'll need to weave in `IORef' at each level in data structures, though)
22:35:19 <augur> pyon: dont know :)
22:35:52 <augur> i hate it when people are all "ML is the best because it has implicit effects!"
22:35:57 <augur> uh yeah, but.. so does C
22:36:13 <augur> "yeah but you can reason about ML because of x, y, and z"
22:36:19 <Trollinator> what are implicit effects supposed to be?
22:36:23 <augur> yeah, and if you use x, y, and z with C, you can reason about C too
22:36:29 <augur> Trollinator: effects that arent in your types
22:36:30 <glguy> pyon: No, the value pointed to by the IORef can't be GC'd while the IORef still refers to it
22:36:32 <ski> having immutable variables still makes it easier to reason
22:37:09 <augur> ski: sure, and C has them! they're just all immutable variables of type IORef :)
22:37:16 <pyon> augur: Heh, actually the main thing I dislike about ML is the untyped effects.
22:37:21 <pyon> augur: Oh, and the lack of higher kinds.
22:37:39 <ski> Trollinator : state, partiality, exceptions, erratic nondeterminism (from concurrency, e.g.). also continuations in SML/NJ (there's some support in Mlton, as well, iirc)
22:37:42 <Trollinator> Haskell isn't particularly great at that either. Having to stack monads isn't nice.
22:37:45 <glguy> pyon: But you can have a "Weak" reference that doesn't count as a reference for GC, but the operation for reading it is safe (Maybe)
22:38:01 <pyon> glguy: Ah! I never liked weak references. They are hard to reason about.
22:38:08 <ski> augur : but that's a translation :)
22:38:14 <glguy> Trollinator: You don't have to stack monads, people just like to do it because it's a way to reuse code
22:38:20 <augur> ski: sure, but you need a translation for ML too
22:38:34 <pyon> glguy: What I would really love is a purely functional approach to effects: linear types.
22:39:05 <Trollinator> glguy: that's an academic distinction.
22:39:10 <augur> ski: thats why i get disgruntled. you cant reason about ML any more than you can reason about C -- you need to reify your effects out into an appropriate semantics first
22:39:30 <ski> pyon : i don't follow ..
22:39:33 <augur> and if you're going to go that route for ML, then why use ML at all? what makes ML superior?
22:39:43 <pyon> augur: The module system.
22:39:44 <glguy> Trollinator: It's also a practical one. You could just as well write all of your code in IO and have all your effects
22:39:49 <pyon> augur: You know, abstract types are really abstract.
22:40:05 <augur> pyon: yes, MLs modules are nice, ill grant you that
22:40:19 <Trollinator> that defeats the point. The point of monad stacks is to be able to tell *which* effects will occur.
22:40:34 <augur> also i dont know if you can truly avoid a monad stack
22:40:50 <augur> i mean, effects are not independent of one another
22:41:09 <Trollinator> I think the language should support that directly, like DDC and Idris do.
22:41:24 <Ralith> idris does not support that directly
22:41:31 <glguy> Trollinator: The point of purity is to be able to reason about the effects of the code from its types
22:41:32 <augur> Idris doesnt avoid stacks, it just lets you represent certain things orthogonally
22:41:46 <augur> but   Maybe (State s a)   is not   State s (Maybe a)
22:41:47 <Ralith> it just has a type system that is generally expressive enough that you can do some pretty fancy things with it on your own
22:41:53 <glguy> monads are a way to talk about effects, monad transformers are a way to transform monads
22:41:54 <augur> those are very different things
22:42:00 <ski> augur : let's consider Scheme. one problem which makes it harder to reason (for both human and machine) is that variables are mutable. i think several implementations internally box variables in an `IORef'/`ref' like thing, just to make later analyses easier
22:42:21 <ski> augur : even though "it's just a matter of translation", it still matters
22:43:00 <ski> (or rather, they do that for variables that are actually assigned to)
22:43:05 <augur> ski: sure, but then we have the same difficulty of reasoning in ML whenever we have stately types
22:43:27 <augur> ski: that is to say, we can define the "hard" cases in ML too, we just have to go to extra effort to explicitly do so
22:43:41 <ski> not talking about the basic problems about reasoning about state, here
22:43:41 <augur> ok so fine, that means its nice to be explicit about effects, sure, ill grant that
22:43:51 <Trollinator> Also I disagree that ML is so hard to reason about. In order to reason about code, you need to know more about it than (Haskell or ML) types can express. So you have to look at the code anyway. Ensuring that a given function doesn't have side effects doesn't seem all that difficult.
22:43:55 <ski> augur : sure
22:43:58 <augur> but then why shouldnt we just be explicit about _all_ effects?
22:44:08 <augur> ala Haskell (mostly)?
22:44:09 <ski> why, indeed
22:44:32 <augur> this is why i dont get the ML fetishism some people have
22:44:45 <augur> oh haskell is hard because of all the monads, use ML~~~
22:44:56 <augur> ok well, ML is hard because of all the monads, use C~~~
22:45:00 <ski> for an impure language, ML is quite nice
22:45:19 <augur> if you're going to reify some effects, why not reify them all? what benefit is there to partial reification
22:45:44 <ski> (btw, ML isn't (traditionally) explicit about effects in the sense of (e.g.) monads)
22:46:20 <augur> well its explicit if you want something other than IO, afaik. i mean, to get mutable vars, you need something explicit somewhere
22:46:21 <ski> "some effects", which ?
22:46:38 <ski> there's no monad-like thing for state
22:47:06 <augur> in ML? is there no capacity in ML to define the analogy of `State`?
22:47:08 <ski> it's just that the mutable boxes are explicit (and are values)
22:47:40 <augur> oh, ML has actual mutable values too?
22:47:46 <ski> sure, but it's not used for the standard `ref' type and operations (or the mutable record field thing in O'Caml)
22:48:02 <Trollinator> There is no language called “ML”
22:48:07 <augur> shhhh Trollinator :P
22:48:19 <ski> of course, just like Haskell does (in a sense, with `IORef' -- though it depends on how you squint)
22:48:22 <pyon> If ML had purity and higher kinds, it would be an objectively better language than Haskell in all respects.
22:48:29 <augur> ski: if ML has a distinct mutable "variable" thing, thats even worse
22:48:39 <Trollinator> pyon: nonsense.
22:48:51 <augur> because then its like all those languages that have two var types, mutable and immutable
22:48:59 <rwbarton> it does not have mutable variables
22:49:01 <pyon> Trollinator: How so?
22:49:03 <ski> Trollinator : obviously we're talking about more or less the whole ML family. SML,OCaml,Alice ML,F#
22:49:37 <Trollinator> For one thing Haskell is lazy while ML isn't.
22:49:53 <BMeph> þ
22:50:06 <MP2E> Haskell is non-strict, common implementations are lazy*
22:50:07 <BMeph> ...and Mythryl
22:50:23 <ski> pyon : higher kinds, polymorphic components, existential components, and possibly higher-rank types would be quite nice, yeah
22:50:48 <ski> augur : "then its like all those languages that have two var types, mutable and immutable", not quite
22:50:55 <augur> ski: how does it differ?
22:51:36 <ski> a `ref' is a piece of value, can be incorporated as other values in data structures
22:51:48 <ski> variables themselves are always immutable
22:53:50 <pyon> ski: Existential components --> No, first-class modules.
22:54:28 <ski> pyon : works as well, assuming they're not too heavy-weight :)
22:55:11 <ski> anyway, via `ref' (and a few other things), ML has mutable *data*
22:55:40 <ski> (but only where you explicitly allow it, by using those data types in question)
22:56:32 <augur> ski: right
22:56:51 <pyon> ski: Reference cells are one of the warts of the language. Here Rust gets it right with mutexes and locks, but properly expressing them requires linear types. (Which Rust approximates with affine types plus destructors.)
22:57:06 <Trollinator> Those feel like luxury problems to me. People still use Java as a teaching language at universities :'(
22:57:07 <augur> ski: ok so is that at the type level?
22:57:16 <ski> pyon : well .. at least matching on `ref's is a wart, i think :)
22:57:16 <augur> like, x : Ref a  vs x : a?
22:57:32 <ski> yes
22:57:43 <ski> in both cases `x' is an immutable variable
22:57:55 <rwbarton> matching on refs?
22:58:01 <ski> yes
22:58:19 <augur> ski: ok, so ML has an explicit Ref monad, basically
22:58:25 <ski> rwbarton : it makes analysis of pattern-matching harder
22:58:30 <rwbarton> what does that do, like a free dereference?
22:58:38 <ski> augur : no monad, just something corresponding to `IORef'
22:59:02 <augur> ski: well yes but i mean, it has some way to define return and bind righ
22:59:07 <augur> i mean, not as a type class but
22:59:10 <ski> pyon : s/linear/uniqueness/, no ?
22:59:27 <augur> you could define   returnRef : a -> Ref a   and   bindRef : Ref a -> (a -> Ref b) -> Ref b
22:59:28 <augur> no?
23:00:06 <ski> augur : not satisfying the laws
23:00:13 <augur> ski: oh? why not?
23:00:36 <rwbarton> well Ref is not a functor for starters
23:00:37 <ski> `bindRef refA returnRef' will not be the same as `refA', it will be a copy
23:00:40 <rwbarton> just like IORef is not a functor
23:00:43 <rwbarton> and that is why
23:00:54 <augur> rwbarton: why not?
23:01:03 <rwbarton> see above
23:01:41 <augur> ski: hm
23:02:05 <rwbarton> if I am to write (a -> b) -> Ref a -> Ref b, the only way to get Ref b is as a new reference, and then fmap id won't be id
23:02:26 <ski> pyon : by "gets it right with mutexes and locks", i assume you're referring to synchonization trouble wrt concurrency ?
23:03:40 <pyon> ski: Yes.
23:04:04 <pyon> ski: ML-style reference cells basically make concurrency no man's land.
23:04:17 <augur> rwbarton: a copy in that.. if you do    refA' = fmap id refA ; set refA' x   then    get refA   will be not equal to  get refA'   ?
23:04:30 <ski> similarly to how `IORef's generally isn't good to mix with concurrency in Haskell
23:04:46 <ski> (yes, i know there's a primitive to atomically swap the value)
23:04:51 <rwbarton> in that refA will not be equal to refA'
23:04:57 <pyon> ski: Yes, IORef is basically ML ref cells, with the difference that Haskell constrains them to IO.
23:05:05 * ski nods
23:05:07 <augur> rwbarton: right but not-equal in what sense
23:05:18 <rwbarton> in the sense of the equality operation of ML
23:05:19 <ski> augur : observationally different ?
23:05:22 <rwbarton> which is pointer equality
23:05:28 <rwbarton> which is also observational equality
23:05:28 <augur> rwbarton: ok
23:05:43 <augur> ski: yeah, thats why i was asking about the refA vs refA' thing
23:05:47 <ski> even without pointer equality, you can observe the difference, by attempting to mutate one, and then inspect the other
23:05:56 <rwbarton> right
23:05:58 <augur> thats what i said x3
23:06:10 <rwbarton> oh i see the set, yes
23:06:30 * ski nods
23:06:32 <augur> ok so thats even more interesting. mutability in ML is also wonky
23:06:34 <augur> blegh
23:06:43 <rwbarton> what?
23:06:46 <lfairy> startling: http://lpaste.net/106999 :D
23:06:48 <ski> in what sense ?
23:07:06 <rwbarton> it's just the same as Haskell except the IO effects are not tracked
23:07:22 * ski agrees
23:07:28 <augur> well in that its "explicit" in some sense
23:07:56 <augur> i mean, its explicit but not in the sense that you can say "this thing is a stateful program"
23:08:06 <rwbarton> yes, instead of "a = a + 1", "a := !a + 1"
23:08:39 <rwbarton> most languages conflate the reference cell (lvalue) with its value (rvalue)
23:08:42 <augur> so you can in fact write "functions" which mutate things
23:08:59 <rwbarton> of course, they can print things too
23:08:59 <augur> pass a Ref in, mutate it, and return unit
23:09:28 <augur> thats rather unpleasant
23:09:29 <ski> because effects aren't tracked, either by something monad-like, or by another kind of effect system
23:09:53 <ski> no different from Scheme or C or Java there
23:10:25 <pyon> ski: The problem with monads is that now some computations are not really functions (as in Hask-arrows), instead they are Kleisli arrows.
23:10:34 <ski> (btw, it would be possible to use an abstract data type for a monad in a dynamically typed language)
23:10:44 <augur> ski: it seems a lot like these languages that have "val" and "var" distinctions
23:10:45 <pyon> ski: A functional programming language should find some way to make *all* computations go through functions.
23:10:56 <ski> pyon : i don't follow
23:10:58 <rwbarton> what is a computation?
23:12:19 <MP2E> pyon : I don't follow at all.. And there has been work to show that arrows give rise to very little that is unique compared to Category + Applicative
23:12:21 <pyon> ski: In Haskell, an effectful computation (i.e., reading user input) is not a function. Instead, it is some monadic value, like an IO action.
23:12:43 <rwbarton> ok, then change "problem with" to "purpose of"
23:12:44 <pyon> I want a function "readLine: World -> (String, World)".
23:13:41 <MP2E> pyon : Isn't that what IO is? A state monad over the 'RealWorld' which gets passed as a 0-byte token by GHC?
23:13:55 <MP2E> Not precisely of course because IO is "magical"
23:14:08 <pyon> MP2E: Too bad because the RealWorld type is not linear.
23:14:09 <ski> pyon : that's reasonable (though i still don't follow the "instead they are Kleisli arrows" part)
23:14:19 <ski> pyon : s/linear/unique/ :)
23:14:57 <pyon> ski: I got it wrong, I should have said "monadic value" (like an IO action). Of course Kleisli arrows are just (a subset of) regular functions.
23:15:19 <ski> (as we know, in Clean we pass around `World' like the above. if one want to, one could hide it behind an `IO' monadic interface)
23:15:45 <pyon> ski: Why unique? I do not want a uniqueness modality which I can bork by involking weakening and contraction.
23:15:45 <ski> pyon : perhaps rephrase your complaint, then ?
23:16:32 <ski> pyon : at least for stuff like arrays, you want a unique reference
23:17:34 <jle`> what would you want a readLine :: World -> (String, World) for
23:17:36 <ski> pyon : in case your `main' is required to return a unique reference to `World', then you can't in practice duplicate it before, nor discard it (since there's only one at any time)
23:17:38 <pyon> ski: Please correct me if I am wrong, but IIUC, the difference between linearity and uniqueness is that, in a linear setting, the weakening and contraction rules are simply not available, while in a unique setting, you are just telling the type checker "I am not going to use those".
23:18:03 <pyon> going to use those twice or zero times*
23:18:34 <ski> jle` : in Clean, one can decompose `World' into separate subsystems, that one then doesn't have to over-sequence operations on
23:19:18 <jle`> hm
23:19:34 <ski> pyon : in a linear setting, weakening and contraction are only available when you have an "of course"ed thing
23:19:57 <pyon> ski: Ah!
23:20:34 <ski> having something that doesn't have an "of course" wrapped around it doesn't mean it hasn't had that in the past, so you're not ensured you get a unique reference
23:20:51 <pyon> ski: Then I guess uniqueness is what I actually want. But, with an ML-like module system, I would like to have a module that exposes a unique type file_desc, that is internally an int.
23:20:52 <ddellacosta_> say I have a guard, and inside of that guard I want to test another condition: is there a way to do a guard inside a guard, or is there some better way to structure this?
23:21:22 <pyon> ski: file_desc being the unique type of file descriptors, I mean
23:21:26 <ski> ("exposes a unique type" ?)
23:21:35 <jle`> ddellacosta_: how about (&&) ?
23:21:54 <ddellacosta_> jle`: yeah, but I'm trying to avoid repeating myself is all
23:21:54 <ski> the uniqueness isn't in the type itself, but how it's used in other types
23:21:54 <jle`> or do you mean multiple guards branched out of a single guard
23:22:04 <pyon> ski: structure FILE_DESCRIPTOR : sig uniquetype file_desc (* ... *) end = struct type file_desc = int (* ... *) end
23:22:05 <parc> ddellacosta: like just chain predicates? you could do something like \f g -> (&&) `fmap` f <*> g
23:22:07 <ddellacosta_> jle`: the latter, I think?
23:22:09 <pyon> ski: Ah.
23:22:13 <pyon> ski: Then I want linear types again.
23:22:18 * ski grins
23:22:41 <ddellacosta_> parc: yeah, maybe what I want is a function here actually.  Hmm
23:22:44 <ddellacosta_> okay, thanks parc and jle`
23:22:50 <ski> pyon : i think possibly you could make a type function out of "non-unique", though
23:23:21 <pyon> ski: Wikipedia says: "actual linear typing allows a non-linear value to be 'cast' to a linear form"
23:23:29 <ski> yes
23:23:42 <pyon> ski: This is exactly what I want -- it would allow me to expose a linear type of file descriptors, that is internally just int.
23:24:09 <pyon> ski: int is, of course, an ofcourse'd type.
23:24:27 <ski> it means that if you have a non-linear resource (so not really a resource, then), you can pretend that it's a linear resource
23:24:43 <pyon> ski: Yes, that would be useful for safely wrapping POSIX.
23:25:16 <ski> so, if you have something of type `! int', then you can pretend you have something of type `int'
23:25:23 <ski> (where `!' is "of course")
23:25:41 <pyon> ski: I would call "int" what you are calling "! int".
23:25:55 <pyon> For convenience, int would already come in the of-course'd form.
23:26:22 <pyon> Because manually cloning ints is... lame.
23:26:29 <ski> pyon : perhaps you can hide it along the lines of what you're suggesting, in an actual language. i was talking in terms of the standard presentation of linear types
23:26:39 <pyon> Oh.
23:27:30 <ski> pyon : btw, one could possibly have both linearity and uniqueness in a language. you could ask edwardk about that
23:27:36 <pyon> :-O
23:28:15 <pyon> IIUC, linearity is a property of values, while uniqueness is a property of how functions use values right?
23:28:28 <pyon> If this is so, I decidedly like linearity better.
23:28:47 <pyon> I should not have to reassert all the time that I intend to use file descriptors uniquely.
23:29:11 <ski> i'd probably say something like : linearity is a property of how the future will use a value. uniqueness is a property of how the past has used it
23:30:29 <ski> having a linear value means that the future can't duplicate (nor discard, if we're not talking affine instead of linear) it
23:30:47 <ski> having a unique value means the past hasn't duplicated it (of course it hasn't discarded it, otherwise we wouldn't have it here)
23:31:13 <pyon> Ah! That still makes me like linearity better.
23:31:25 <ski> both of these are useful
23:31:29 <parc> is there any sort of extension that will let me encode in the type of a function `loop :: f (Either a b) (Either c b) -> f a c`, that loop is only well typed if there are no free type variables in its input argument?
23:32:24 <pyon> ski: Anyway, we better take it elsewhere. Would #haskell-blah be a good place? :-P
23:32:42 <ski> pyon : having a unique reference is essential to update-in-place, in a pure fashion
23:33:06 <ski> pyon : there's also #haskell-overflow, and #haskell-in-depth
23:33:13 <pyon> ski: Ah!
23:33:27 <ski> .. however, i should probably be leaving now :/
23:33:39 <pyon> ski: Oh, well. Then goodbye! :-P
23:34:03 <ski> (if you want to continue discussion later sometime, you're welcome)
23:34:10 <ski> bye
23:37:14 <ddellacosta_> is there any convention for a function that returns a boolean value in Haskell?  I suppose that the types tell you all you need to know, so not as much use for it as in a dynamically typed language
23:37:43 <ddellacosta_> thinking here of the convention of appending "?" to the end of a function name in Clojure/method name in Ruby
23:38:00 <dmwit> parc: I'm not sure I understand. How can the argument of loop have type variables at all, free or otherwise, in Haskell?
23:39:27 <dmwit> ddellacosta_: There's no real need to put types in the name of a value, since they're so easy to query in ghci.
23:39:46 <ddellacosta_> dmwit: yeah, figured that was the answer. Old habits die hard though. :-)
23:39:53 <dmwit> Or haddock, or by looking at the type annotation in the source since you're annotating all your top-level values, right? ;-)
23:39:57 <parc> dmwit: well I wanted to do something like `loop Right Right`, which haskell inferred as (a -> b). that the output type had no relation to the input type is causing a problem for what i'm doing
23:39:59 <dmwit> ddellacosta_: for sure
23:41:07 <parc> dmwit: essentially i've got an extremely simple DSL, which simply describes swapping variables around in either/pair datatypes, and adding loop to the language makes it possible to create programs that never terminate, which i want to avoid
23:42:43 <dmwit> You won't be able to have a guaranteed-terminating EDSL in Haskell.
23:43:35 <dmwit> I guess you didn't actually say the E. But it sounds like it's there from what you're describing.
23:44:42 <parc> dmwit: i'm not really sure what else `embedded` implies in this context
23:45:18 <dmwit> I mean, you're not parsing a file, right? You're using Haskell as your surface syntax.
23:45:35 <dmwit> If that's right, that's all "embedded" means.
23:46:39 <parc> dmwit: yeah. just the category instance and some other typeclasses. i was worried proving termination wouldn't be possible
23:47:04 <dmwit> I mean, loops have every type. Including the type of your EDSL values.
23:47:19 <dmwit> So that really seems like a non-starter.
23:48:50 <dmwit> I guess you could wish for something lighter, like "if this EDSL expression terminates and produces a value, then my interpreter terminates, too".
23:48:58 <dmwit> That sounds pretty reasonable.
23:49:13 <dmwit> But will still probably be pretty hard to cram into the type system.
23:50:17 <dmwit> I still have no idea what condition you originally wanted to enforce on "loop", though.
23:51:25 <dmwit> I mean, maybe you meant "the *type* of the argument has no free type variables"? But even so I would imagine a monomorphic Right fits that bill and still causes your interpreter to non-terminate.
23:52:00 <dmwit> Or, well, (const (Right 3)) or whatever.
23:53:50 <parc> dmwit: i'm still not 100% sure what i need to express to ensure termination... this is the first time i've ever worked with this kind of problem. literally all the EDSL can do is rearrange terms, so something that implements the typeclass has expressions like: f (a,Either b c) (Either b a, Either b c)
23:54:50 <ddellacosta_> if anyone has the bandwidth to tell me how I could improve this code, I'd be very appreciative. https://github.com/ddellacosta/compsci-practice/blob/master/kmp-search/src/KMPSearch.hs
23:56:24 <parc> dmwit: also things like `f (a,b) (b,a)`, `f (a,(b,c)) ((a,b) c` and you can compose such expressions together. it's just a language for algebraic rearrangement of sum/product types essentially, so they always terminate. but i want to extend it with loop and some other combinators, but even just loop plus the rearrange things allow non-termination, which is kind of annoying
23:56:55 <dmwit> parc: You might like http://arxiv.org/pdf/0908.3347
23:57:31 <dmwit> parc: Chapter 5 is on traced categories.
23:57:35 <kvanb> github .. not loading for me
23:57:37 <kvanb> to review that code.
23:57:52 <dmwit> parc: ...and may have some pointers to other references to read about conditions that make traces sensible.
23:58:12 <parc> dmwit: that looks very helpful, thanks
