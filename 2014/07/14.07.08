00:36:52 <solidus-river> jle`: heh, ran into another hitch, i have a wire of type Wire s e m a b, i want to give it an a and get the (b, w') out of it, does that just look like
00:37:05 <jle`> you can't
00:37:05 <solidus-river> (b, wire') <- wire a
00:37:18 <jle`> oh yeah you monadically bind it
00:37:21 <jle`> er
00:37:27 <jle`> you use runWire
00:37:34 <jle`> sorry, i should have put in the record
00:37:55 <jle`> data Wire s e m a b = Wire { runWire :: t -> a -> m (Either e b, Wire s e m a b) }
00:38:18 <solidus-river> ah but if i use runwire i need to give it a t  :? whats the t
00:38:59 <solidus-river> looking in http://hackage.haskell.org/package/netwire-5.0.0/docs/doc-index-All.html
00:39:15 <solidus-river> all i see is stepWire and stepSession then runKleisli and runIdentity
00:39:33 <solidus-river> but stepWire seems to expect me to manually track a session
00:40:32 <solidus-river> oh, i guess i could pass it a Pure a
00:47:08 <jle`> solidus-river: remember the type
00:47:12 <jle`> constructor
00:47:18 <jle`> you pass in a function t -> a -> ...
00:47:23 <jle`> \t x -> ...
00:47:26 <jle`> that's the t you get
00:48:06 <jle`> the same place where you get your x
00:48:52 <solidus-river> i guess my question then is if i have to manage my own s somewhere in the program, and pass it a dt, not a session, and get the dt from the session via stepSession
00:48:58 <solidus-river> why have the s type in the wire
00:49:06 <solidus-river> what is the s doing there?
00:51:05 <jle`> don't worry about it for now, it makes no difference
00:51:11 * hackagebot taggy 0.1 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.1 (AlpMestanogullari)
00:51:13 * hackagebot taggy-lens 0.1 - Lenses for the taggy html/xml parser  http://hackage.haskell.org/package/taggy-lens-0.1 (AlpMestanogullari)
00:51:21 <jle`> you don't need to know anything about how to get s, or how to manage it, or anything to implement the Category instance
00:51:24 <solidus-river> jle`: ? so i would have to make a session kinda in my main look like MaxDaten does here?
00:51:31 <solidus-river> https://github.com/MaxDaten/netwire-examples/blob/master/NetwireSdlOpenGL.hs
00:51:43 <solidus-river> well, i'm trying to get an extremley basic version of my renderer into wire's
00:51:46 <solidus-river> so i have a game sim wire made
00:51:53 <jle`> did you already write your category instance?
00:51:54 <solidus-river> and it takes key sets and outputs renderables
00:52:45 <jle`> are you asking about where to get the s type in an actual netwire program, or in your Category instance?
00:53:53 <solidus-river> :X no :( i didn't write the category instance yet, maybe i should do that and come back
00:54:15 <solidus-river> i guess my question is it seems odd to have to use stepWire and stepState manually
00:54:24 <solidus-river> but i guess thats the tradeoff of not having a fully frp program
00:54:28 <solidus-river> just parts of it that are frp
00:54:41 <solidus-river> you have to give it the driving force
00:55:00 <solidus-river> and manage the session unless you can kick it all off with a pure or evented input
00:55:51 <jle`> using stepWire is like rendering a vector image pixel-by-pixel
00:56:08 <jle`> sooner or later someone is going to have to render a vector image to pixels
00:56:18 <jle`> ideally it is abstracted over; it is considered low-level :)
00:56:26 <solidus-river> heh, but if i have a backend
00:56:32 <solidus-river> that provides a set of keys each sampling
00:56:42 <solidus-river> and a wire that takes those and produce an output of renderables for the backend to render
00:56:45 <solidus-river> theres no way for me to avoid it right?
00:56:56 <solidus-river> unless i arrowize the whole backend loop
00:57:19 <jle`> you have to turn the crank some time
00:57:34 <jle`> it's outside of FRP
00:57:40 <jle`> this process is unrelated to FRP
00:57:58 <solidus-river> ah, kk, then i guess my backend loop is the crank turner
00:58:15 <jle`> it is only the implementation details of a certain implementation of FRP
00:58:32 <jle`> in the new wires library, ertes provides a Pipe
00:58:46 <jle`> where the pipe input is the stream of inputs and the pipe output is the stream of outputs
00:58:57 <solidus-river> that is niiice
00:59:00 <jle`> something like a Wire m a b -> Pipe a b m r
00:59:10 <jle`> but down at the low level...it's still the crank being turned
00:59:21 <jle`> the crank is still being turned step by step
00:59:36 <jle`> but it's abstracted away ---- the same thing you are doing now
01:01:02 <jle`> (the step of the wire is just being done by the step of the pipe)
01:03:39 <solidus-river> interesting
01:03:46 <solidus-river> he wraps his game wire in a reader
01:03:52 <solidus-river> so that he can step it in an IO do block
01:06:23 <solidus-river> i have a bad tendency to come in here when i should be sleepin for the night
01:06:48 <Hodapp> huh... am I right in some ways to think of STM as similar to coroutines?
01:07:00 <Hodapp> at least, for some of the examples SPJ is giving
01:07:19 <solidus-river> must fight the signal degredation
01:10:22 <Hodapp> in which you've some operations in the STM monad, and one may block there (sort of) until something relevant has happened in a TVar
01:11:13 * hackagebot gtk2hs-buildtools 0.13.0.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.0 (HamishMackenzie)
01:12:11 <levi> Hodapp: Generally coroutines directly call their fellow coroutines rather than just synchronizing on a shared variable.
01:15:02 <levi> Coroutines in haskell are more likes Pipes/Conduit/etc.
01:15:44 <Hodapp> I was looking more at the sort of problems coroutines are often used to solve in other languages
01:17:29 <levi> They are often used to get around a lack of a threaded runtime; STM assumes there is a threaded runtime.
01:18:53 <levi> The worst is when you don't even have a language capable of expressing coroutines; then you approximate them via a partial manual continuation-passing-style transform of your coroutines.
01:19:15 <Hodapp> not sure what you mean there
01:19:35 <levi> Are you familiar with continuation-passing style?
01:20:28 <vanila> there's a name for that
01:20:37 <vanila> co-operative multitasking or something?
01:20:47 <vanila> where each thread has to yeild to let the other thread do some work
01:23:17 <levi> vanila: That's a cooperative threading system; you can implement one in a library given a language with coroutine support.
01:26:46 <jle`> huh...i accidentally generated the fib sequence
01:26:52 * jle` shrugs
01:27:01 <levi> Hodapp: A manual CPS transform means to split your routines that need to yield control at the yield points. At each yield point, you pass on as an extra parameter the next part of your function that needs to be executed.
01:27:02 <jle`> i don't even fully understand how it came about
01:28:37 <levi> Hodapp: I.e., you pass 'what to do next' as a callback.
01:29:20 <vanila> levi: it's pretty amazing how free variable capture saves you making up a data type to store the current state of the procedure so you can pause and come back to that point of execution
01:30:11 <levi> vanila: Yeah; though it's nicer to not have to manually split your procedures at all.
01:32:07 <levi> And it's often still nicer yet to not have to manually interleave execution of concurrent tasks.
01:33:42 <levi> You can work at any of those levels you'd like to, though.
01:40:51 <int3__> I've been trying to define a fold one this Trie without any success: https://github.com/int3/scrabble-solver/blob/master/Trie.hs#L13 ; is it even possible to do so?
01:41:07 <int3__> s/fold one/fold on/
01:42:26 <vanila> I don't think you can define a fold on this
01:42:54 <int3__> vanila: there's sort of an 'extra element' in every fold I try to define, yeah
01:42:54 <levi> Define a toList, then fold on the list.
01:43:11 <merijn> I don't see why you couldn't define a fold?
01:43:26 <merijn> You need to do some thinking whether you want to fold with the keys or just values, but other than that...
01:44:26 <vanila> well I think you could define (Maybe [Char] -> M.Map Char x -> x) -> Trie -> x
01:45:12 <johnw> bitemyapp: still awake?
01:45:53 <int3__> vanila: yeah, I thought of something like that, but now I have an extra 'Maybe' that only takes the value 'Nothing' at the root of the trie
01:47:22 <int3__> though maybe I could do something like ((Bool, [Char]) -> x) -> Trie -> x ... lemme think about this more
01:49:17 <vanila> @let data Trie = Trie { terminal :: Maybe [Char], children :: M.Map Char Trie }
01:49:18 <lambdabot>  Defined.
01:49:22 <vanila> :t let fold f (Trie a b) = f a (M.map (fold f) b) in fold
01:49:23 <lambdabot> (Maybe [Char] -> M.Map Char b -> b) -> Trie -> b
02:54:27 <dzhus> Is there a way to achieve Haskell<->COM interop currently? HaskellDirect/Green Card are long obsolete
02:56:47 <int3__> http://localedge.com/b29817960/Haskell-Tree-Service
03:01:26 * hackagebot marmalade-upload 0.9 - Upload packages to Marmalade  http://hackage.haskell.org/package/marmalade-upload-0.9 (lunaryorn)
03:13:14 <Voidness> r
03:26:29 * hackagebot lz4 0.2.3 - LZ4 compression for ByteStrings  http://hackage.haskell.org/package/lz4-0.2.3 (MarkWotton)
03:36:30 * hackagebot lz4 0.2.3.1 - LZ4 compression for ByteStrings  http://hackage.haskell.org/package/lz4-0.2.3.1 (MarkWotton)
03:38:29 <ZioCrocifisso> http://lpaste.net/107101
03:38:49 <ZioCrocifisso> is it possible to ensure that every type returned by MCToHask is also an instance of SerializeMC?
03:41:53 <dreams> foo  = 1 <- would you call foo a function or a variable?
03:42:02 <vanila> variable
03:42:19 <dreams> vanila: is it formally a variable?
03:43:21 <mortberg> dreams: I would call it a constant as it is a 0-arity function
03:44:40 <vanila> you need type to be like _ -> _ to be a function
03:44:41 <codygman> I've been having some trouble filtering a list of "wd Element" (from webdriver package) types: http://lpaste.net/107102ap
03:44:44 <tdammers> it is a variable that is bound to a nullary function :P
03:44:56 <vanila> it's not a function
03:45:13 <codygman> wd [Element] I should say
03:45:23 <quchen> It's not necessarily a nullary function. It has type Num a => a, which could be anything that's an instance of Num, including functions.
03:45:26 <tdammers> "nullary function" works, but it doesn't help in most context to think of it that way
03:46:17 <dreams> well in the Haskell report, the context-free-grammar has a "varid", but it is confusing since a variable is the same as a function.
03:46:17 <tdammers> quchen: wouldn't that be a nullary function returning a non-nullary function though?
03:47:27 <quchen> I'm not sure there is a difference between "returning" and "being" even.
03:48:04 <vanila> dreams, what do you mean "a variable is the same as a function?" I variable can hold a function or a integer or any other value
03:52:28 <dreams> vanila: x = 1, is x a variable or a nullary function.
03:52:42 <vanila> it's not a nullary function, there is no such thing
03:52:59 <vanila> in haskell we have (->) for function types
03:54:19 <dreams> vanila: variables and functions returns values, and they are syntactically close, which is why it get me confused sometimes.
03:54:45 <vanila> here's a better way to think about it: variables and functions *are* values
03:55:17 <dreams> vanila: you can also have a variable which return a function, so in the type signature it would have ->
03:55:31 <hooplahoops> Hi, can I parse a ByteString as text data without building a String from it? I basically need read/reads without the conversion
03:55:46 <vanila> I don't understand what you mean, would you make an example?
03:56:21 <dreams> vanila: yes they are values, I get that, but to distinguish them is a bit confusing.
03:56:40 <dreams> vanila: I'll make one later, got something on hand to finish.
03:57:12 <hooplahoops> vanila: don't know if this was your question, but f x = ... is the same as f = \x -> ...
03:58:01 <quchen> ByteString and String are completely independent things.
03:58:22 <quchen> And there are some subtleties that make "f x = ..." a bit different from "f = \x -> ...".
04:00:48 <donri> inlining
04:01:07 <donri> oh, i read "and" as "are"
04:01:28 <quchen> donri: inlining is a GHC thing, not a Haskell one though.
04:01:43 <quchen> But there's something else with the DMR in the Report.
04:02:01 <quchen> And I think there's one more issue that I continually forget every time I hear about it.
04:03:54 <hooplahoops> quchen: DMR?
04:04:59 <quchen> Dreaded Monomorphism Restriction
04:05:06 <hooplahoops> haha ok :)
04:05:34 <hooplahoops> I know String and BS are different, but I should be able to parse both the same way
04:06:08 <quchen> And you can!
04:06:38 <quchen> {Atto,}Parsec have ByteString submodules, for example,
04:06:38 <hooplahoops> quchen: how? :)
04:07:49 <alpy> Hey, i have been working on a small project where i am using snap and cabal?
04:08:06 <hooplahoops> quchen: All right I'll check it out, thanks
04:08:29 <alpy> cabal told me that i had a hidden package and advised me to add it to the build-depends
04:09:01 <donri> you need to list all packages you import from directly, under build-depends
04:09:07 <quchen> hooplahoops: I haven't used Parsec with BS, but it seems that it's quite similar to using the String version. The ByteString module says "Make strict ByteStrings an instance of Stream with Char token type.", at least.
04:09:29 <alpy> but now after i addded it to build depends, it tells that parse of field 'build-depends' failed
04:10:06 <donri> alpy: i recommend a new build-depends line for each dependency, but otherwise the syntax is comma between deps
04:10:28 <tlevine> I want to install haskore and am getting stuck on installing process-1.1.0.2.
04:10:37 <quchen> donri: Wait, you can leave away the commas?
04:10:43 <tlevine> System/Process/Internals.hs:283:30: Not in scope: ‘unsafePerformIO’
04:10:57 <donri> quchen: no but you can have more than one build-depends line
04:10:57 <tlevine> Any up-to-date directions on installing haskore or process 1.1?
04:11:33 * hackagebot basic-sop 0.1.0.0 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.0 (AndresLoeh)
04:11:35 * hackagebot generics-sop 0.1.0.0 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.0.0 (AndresLoeh)
04:11:37 * hackagebot pretty-sop 0.1.0.0 - A generic pretty-printer using generics-sop  http://hackage.haskell.org/package/pretty-sop-0.1.0.0 (AndresLoeh)
04:11:39 * hackagebot json-sop 0.1.0.0 - Generics JSON (de)serialization using generics-sop  http://hackage.haskell.org/package/json-sop-0.1.0.0 (AndresLoeh)
04:11:41 * hackagebot lens-sop 0.1.0.0 - Computing lenses generically using generics-sop  http://hackage.haskell.org/package/lens-sop-0.1.0.0 (AndresLoeh)
04:20:06 <codygman> I'm still having trouble filterM'ing a "Webdriver [Element]" list. I have reduced the down as much as I could to demonstrate: http://lpaste.net/107106
04:21:34 * hackagebot generics-sop 0.1.0.1 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.0.1 (AndresLoeh)
04:22:29 <vanila> codygman, why don't you just write:   let textElems = filter ((==) "text" . (`attr` "type")) inputs
04:22:35 <vanila> to replace line 13
04:25:51 <vanila> :t \f l -> filterM (liftM f) l
04:25:52 <lambdabot> Monad m => (a1 -> Bool) -> [m a1] -> m [m a1]
04:25:53 <vanila> might help too
04:29:41 <codygman> vanila: Trying that now
04:36:21 <codygman> vanila: The pure filter didn't work and gaave me quite a few errors I don't understand (think it's because the results from inputs only have those instances within the webdriver monad): http://lpaste.net/107108
04:37:03 <vanila> does this test case run on its own?
04:37:09 <vanila> I mean typecheck on its own
04:37:35 <vanila> I don't understand how to map the line numbers to the error line numbers
04:38:21 <vanila> I guess it doesnt matter much
04:38:25 <vanila> the problem is 'wd0' is unknown
04:38:48 <vanila> can you add a type annotation or make use of textElems in some way that pins the wd0 type down to fix that?
04:45:35 <aloiscochard> I'm looking for a way to have a "fully isolated" cabal sandbox? /cc bitemyapp
04:45:46 <aloiscochard> I mean a sandbox which don't inherit stuff from the global
04:47:18 <bennofs> aloiscochard: not possible because GHC doesn't support it IIRC. Maybe it's possible with GHC 7.8, idk
04:50:01 <Saizan> some stuff has only been available globally
04:50:30 <donri> @hackage hsenv
04:50:30 <lambdabot> http://hackage.haskell.org/package/hsenv
04:50:31 <aloiscochard> :-( I thought I heard bitemyapp had a kind of hack
04:50:46 <aloiscochard> it's quite a pain to try to compile with my lower bounds
04:51:00 <aloiscochard> donri: oh nice
04:51:00 <aloiscochard> ty
04:53:52 <aloiscochard> donri: can't install, hsenv is not compatible with base 4.7
04:54:36 * aloiscochard back to docker ...
04:58:20 <codygman> vanila: I'm not sure how I would "pin down" textElems or write a type annotation so taht wd0 is no longer ambiguous, I moved it into it's own function however. I also fixed the error line numbers: http://lpaste.net/107109
04:59:11 <vanila>  :: WebDriver wd => wd [Element] <-- basically like this yeah
04:59:45 <Forgetaboutit> Is it correct to say that a function using the state monad basically returns an unevaluated function where the evaluation is delayed until `runState' happens?
04:59:48 <vanila> What is the definition of Element?
04:59:56 <vanila> and it looks like OverloadedStrings is adding the problems
05:00:08 <vanila> Forgetaboutit, yes
05:00:38 <Forgetaboutit> So the reason State helps to get rid of manually threading the state is that it makes the actual evaulation happen at a later point, right?
05:01:18 <Forgetaboutit> So in a way, `State' is a partially applied/closed over function
05:01:22 <quchen> Forgetaboutit: Yes, State is for building a chain of "a -> (s, a)" valued functions.
05:02:33 <Forgetaboutit> quchen, vanila: thanks! I wanted to make sure my newly gained understanding is correct.  Actually, I'm amazed by the simplicity of the concept.
05:02:34 <vanila> yeah, the monad holds the state and when you do  m >> n,  it passes the result state from m into the initial state of m
05:03:06 <vanila> n*
05:03:24 <quchen> but "runState" doesn't actually run the stateful computation, it just "marks it as to be run" in a sense. "runState x y" is still just an unevaluated computation.
05:03:50 <Forgetaboutit> vanila: just like function composition, right?
05:04:06 <vanila> yeah
05:04:30 <Forgetaboutit> quchen: because of laziness. "Unwrapping" (from the newtype) was what I meant.
05:04:40 <quchen> Right.
05:06:49 <quchen> The key idea behind State is really that you can 1. represent a stateful computation using `s -> (s, a)`, and 2. that you can write a composition function for functions of type `a -> (s -> (s, b))`.
05:07:14 <quchen> So you can combine two "State s" to a bigger "State s".
05:12:33 <Forgetaboutit> quchen: how would I combine two States?  Could you give an example?
05:13:24 <quchen> Write a function of type "(a -> State s b) -> (b -> State s c) -> (a -> State s c)"
05:13:31 <codygman> vanila: I tried using that type signature, but now I have a different problem. For some reason it's now saying I need the value wrapped in another maybe... here is updated code: http://lpaste.net/107110
05:14:04 <quchen> Those are two stateful computations: one that takes an "a" and produces a "b", and one that takes a "b" and produces a "c". You can chain those to go directly from "a" to "c".
05:14:23 <vanila> let x = textElems [inputs] <-- what about inputs instead of inputs? I don't really know but it looks like progress
05:15:21 <quchen> Note how similar this is to "(a -> b) -> (b -> c) -> (a -> c)", which is (flipped) function composition.
05:15:23 <Forgetaboutit> quchen: That looks an aweful lot like `(.) :: (b -> c) -> (a -> b) -> (a -> c)'.
05:15:31 <Forgetaboutit> yeah
05:16:39 * hackagebot generics-sop 0.1.0.2 - Generic Programming using True Sums of Products  http://hackage.haskell.org/package/generics-sop-0.1.0.2 (AndresLoeh)
05:16:55 <quchen> composeStates fab fbc a = ...?
05:17:13 <codygman> vanila: It decided to give me some error about the webdriver monad: http://lpaste.net/107112
05:17:33 <quchen> (Inb4 someone spoilers the fish)
05:18:10 <codygman> also, I'm still unsure why it is asking for a "Maybe (Maybe T.Text)" when it seems it should be a "Maybe T.Text"
05:18:43 <vanila> that might be from lift? hard to say
05:19:46 <Forgetaboutit> quchen: It's a monad, so presume `>>=' would do.
05:20:15 <quchen> Almost. (>>=) has type `State s a -> (a -> State s b) -> State s b` for the `State s` Monad.
05:20:39 <quchen> The solution uses >>=.
05:21:19 <d3lxa> does anyone is using netwire and haste? I tried a bit elm but I'm far from conviced, I've heard of helm too, any advice for making (cool) games in browsers? thx
05:21:49 <quchen> If you have `fab :: a -> State s b`, `fbc :: b -> State s c`, and `a :: a`, there's not much you can do with them anyway. The only sensible thing I see is applying `fab` to `a`, giving you `fab a :: State s b`.
05:22:13 <quchen> Now it's your job to make a `State s c` out of that, using what you have left.
05:23:23 <Forgetaboutit> quchen: But I can't directly `runState' on `State s b' because that would result in a State of State, right?
05:23:41 <Forgetaboutit> quchen: after applying fbc
05:24:22 <quchen> Sure you can use `runState` on `State s b`, that gives you a `s -> (s, b)` function. But that's not very useful, is it?
05:25:33 <quchen> You have `fab a :: State s b` and `fab :: b -> State s c`. How can you create a `State s c` out of that?
05:26:46 <quchen> Oh, that should have been `fbc :: b -> State s c` there.
05:26:55 <Forgetaboutit> quchen: evalState?
05:26:56 <quchen> (And not "fab :: ...")
05:26:59 <quchen> Nope
05:27:40 <quchen> I'll give you a hint, I've written down the function's name in my last 10 messages somewhere.
05:27:58 <quchen> (And its type as well.)
05:28:23 <Forgetaboutit> `>>'?
05:28:39 <quchen> I never used (>>), that was someone else
05:28:52 <Forgetaboutit> quchen: I'm kinda confused right now
05:31:41 <quchen> It's (>>=). Now, using that, can you write composeStates function? Remember, you already have `fab a :: State s b` and `fbc :: b -> State s c` (and you want a `State s c`).
05:31:42 * hackagebot basic-sop 0.1.0.1 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.1 (AndresLoeh)
05:31:43 * hackagebot pretty-sop 0.1.0.1 - A generic pretty-printer using generics-sop  http://hackage.haskell.org/package/pretty-sop-0.1.0.1 (AndresLoeh)
05:32:07 <quchen> composeStates fab fbc a = … fab a …
05:34:04 <Forgetaboutit> `composeStates fab fbc a = fab a >>= fbc'?
05:34:11 <Forgetaboutit> What's missing?
05:35:05 <vanila> Forgetaboutit, for compose monadic functions:
05:35:07 <vanila> :t (>=>)
05:35:08 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:35:38 <Forgetaboutit> vanila: Ah, I never used this combinator before.
05:35:48 <vanila> it's not as useful as >>= !
05:35:58 <vanila> but it's a monad version of (.)
05:36:31 <quchen> Forgetaboutit: Right!
05:36:42 * hackagebot lens-sop 0.1.0.1 - Computing lenses generically using generics-sop  http://hackage.haskell.org/package/lens-sop-0.1.0.1 (AndresLoeh)
05:36:44 * hackagebot json-sop 0.1.0.1 - Generics JSON (de)serialization using generics-sop  http://hackage.haskell.org/package/json-sop-0.1.0.1 (AndresLoeh)
05:37:18 <quchen> And, as predicted, someone spoiled the solution, luckily it was after you wrote it down. The grand prize for teaching goes to vanila.
05:37:34 <quchen> Anyway, gotta go. Congratulations Forgetaboutit, you can now compose States :-)
05:38:01 * Forgetaboutit wants a badge for this
05:38:40 <Forgetaboutit> quchen, vanila: Thank you for your effort!
05:40:22 <vanila> a badge to show your lambda-level? :P
05:40:43 <Forgetaboutit> vanila: please! ;)
05:40:48 <vanila> i think that's a fun idea
05:41:03 <kazagistar> gamify haskell learning?
05:41:11 <bergmark> isn't that kind of what ++ does
05:41:30 <matematikaadit> Forgetaboutit++
05:41:43 * hackagebot basic-sop 0.1.0.2 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.2 (AndresLoeh)
05:41:47 <matematikaadit> vanila++
05:42:18 <Forgetaboutit> matematikaadit: :)
05:42:26 <kazagistar> not exactly though ++ would qualify as a gamification of haskell educating, rather then learning
05:42:35 <Pythonfant> :t (++)
05:42:36 <lambdabot> [a] -> [a] -> [a]
05:44:07 <kazagistar> we need something like @badge Forgetaboutit state
05:44:37 <Forgetaboutit> kazagistar: Yes please!
05:44:40 <matematikaadit> @version
05:44:40 <lambdabot> lambdabot 5.0-int-e
05:44:40 <lambdabot> git clone git://github.com/int-e/lambdabot.git
05:46:52 <bergmark> wow un-bitrotted lambdabot :-)
05:48:00 <kazagistar> oh, I know, I know
05:48:54 <vanila> i wwas thinking a website with nice badge images and you just click on it when you feel you learned that
05:49:39 <kazagistar> that might work too
05:50:05 <Forgetaboutit> It would also be great for tracking all the techniques that you can use in Haskell
05:51:44 * hackagebot thumbnail 0.7.1 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.7.1 (KatsutoshiItoh)
05:52:16 <Forgetaboutit> I have yet to find a somehow comprehensive list for that
05:52:20 <kazagistar> as an extention feature, you could add something like a text box where you paste an implementation that it typechecks and quickchecks
05:53:13 <kazagistar> Forgetaboutit: I dont think a "comprehensive list" can possibly exist, but you can get many techniques at least
05:55:37 <bergmark> haskellers.com lets you list your proficiencies, it might be on a higher level than what you mean though
05:56:44 * hackagebot hgeometry 0.1.1.1 - Geometry types in Haskell  http://hackage.haskell.org/package/hgeometry-0.1.1.1 (FrankStaals)
05:59:32 <kazagistar> bergmark: that seems like an awkward place to say "I am profficient in the State monad"
06:00:00 <Iceland_jack> “Certified State monad user.”
06:00:49 <kvanb> The state monad is hard
06:00:55 <Forgetaboutit> "Senior Enterprise State Monad Architect"
06:01:00 <kvanb> organising code so your gets don't look retarded
06:01:03 <kvanb> is a true skill.
06:01:06 <vanila> next level is implementing the state monad from scratch
06:02:43 <mietek> How can I exit GHCi when using -ghci-script?  Including `:quit` in the script doesn't seem to work.
06:03:11 <kazagistar> "I am looking for an employee... they need to be able to Use The State Monad, but its ok if they are not yet profficient in Reimplementing The State Monad"
06:06:15 <mietek> All right.  exitImmediately ExitSuccess  does the trick.
06:06:25 <mietek> On POSIX.
06:18:12 <Cheery> on type inference
06:18:19 <Cheery> what is the biggest obstacle C has to not having it?
06:18:39 <vanila> none
06:19:49 <Cheery> is there some description about how would you transform C into type inferencing language, so that one wouldn't need to write type declarations to the variables inside functions?
06:20:21 <Cheery> I'm going to try writing an sort of transpiler for C today.
06:23:19 <vanila> just give each object a fresh unification cell for its type and traverse the AST applying type information you come across from procedure calls and assignment
06:23:43 <Cheery> okay. I'll try that and return when problems arise. :)
06:36:49 <enthropy> Cheery: + can convert one of it's arguments from int to double, so if you know  x+y is a double, knowing that one of them is a double is probably not enough to determine all the types
06:41:09 <kazagistar> enthropy: you might be able to construct some kind of reasonable defaulting rules though, where it tries to guess the "biggest" type possible, and hope for the best?
06:41:27 <grn> Hi! I'm trying to solve Exercise 2 from http://www.seas.upenn.edu/~cis194/hw/04-higher-order.pdf and have trouble writing a function that adds a new element to a tree. The biggest problem is updating the height of a tree. What's the most idiomatic way of doing it?
06:45:49 <kazagistar> grn: it seems like you are supposed to implement an "insert" function, but I might be thinking about it wrong
06:46:43 <grn> kazagistar, yes, and what I'm having trouble with is writing this insert function, specifically how to update the height of a node
06:49:36 <kazagistar> grn: what do you have so far?
06:51:21 <grn> kazagistar, http://pastebin.com/UbRPvbAy
06:53:01 <grn> ooops, that's buggy actually. update  http://pastebin.com/MCA2zquB
06:53:06 <kazagistar> grn: given the height of the left and right node, can you compute the height of the parent node?
06:53:33 <grn> kazagistar, sure, 1 + max(left height, right height)
06:54:08 <kazagistar> grn: but you DO have the height of the left and right node, as you are constructing the new parent node
06:54:18 <grn> ok, I see where this is going
06:55:21 <kazagistar> grn: your pseudocode is almost valid haskell, actually :P
06:56:07 <kazagistar> but you will probably want to use a "let" statement or something
06:56:16 <Cheery> ok.. now I have tokenizer for my mini language... it's funny how writing these things is such a blast.
06:56:22 <grn> kazagistar, that wasn't pseudocode :-)
06:56:29 <Cheery> I must be damn good at writing parsers. :)
06:58:21 <kazagistar> Cheery: when I wrote a compiler for a class in Java, it was a 4000 line slog; parser combinators have made things sooooo easy :)
07:00:21 <Cheery> I hope this language just doesn't come more popular than the language it implements..
07:02:40 <grn> kazagistar, I solved it! Thanks for your help!
07:02:57 <kazagistar> grn: no problem
07:16:52 * hackagebot mangopay 1.8.0 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.8.0 (alanpog)
07:22:16 <Philonous> Why does writeFD in System.Posix.IO.ByteString take a String as input?
07:23:10 <Philonous> Why does that module even exist
07:24:15 <Fuuzetsu> do you mean fdWrite?
07:24:33 <Philonous> Errr, yes
07:25:09 <Fuuzetsu> it tells you why, it will write it out in your locale
07:25:32 <geekosaur> Philonous: because POSIX pathnames are ByteString
07:25:41 <geekosaur> and that's all that module is intended to deal with
07:25:54 <Fuuzetsu> just a more convenient fdWriteBuf I'm guessing
07:26:11 <geekosaur> the details of the stuff you're outputting can't simply be reduced to ByteString so it's left to you
07:26:28 <geekosaur> nobody wants to understand this of course
07:27:05 <Philonous> Ok, obviosuly I don't understand how file descriptors work
07:27:17 <Philonous> I thought I could just write byte to them
07:27:23 <Philonous> bytes*
07:28:18 <Fuuzetsu> you can, fdWriteBuf
07:28:19 <geekosaur> so, it's supposed to be a drop in replacement for System.Posix.IO except that it uses ByteString for paths. this means it includes some things that don't necessarily make sense
07:28:23 <tsahyt> Does anyone have experience with gtkglext, or using OpenGL with GTK in general?
07:29:14 <geekosaur> since it's trying to balance between things that don't make much sense together (interface compatibility vs. strict POSIX compatibility)
07:31:51 <jeltsch> Hi, does anyone know why the link http://hackage.haskell.org/trac/hackage/ticket/636 does not work?
07:32:11 <Philonous> geekosaur, Thanks
07:34:00 <enthropy> jeltsch: hackage's bug tracker seems to be on github now
07:34:28 <enthropy> but it seems they didn't import old issues?
07:34:30 <jeltsch> enthropy: How can I translate the above URL into a GitHub URL? Have ticket numbers been preserved?
07:34:56 <jeltsch> enthropy: So they removed the old bug tracker, but did not migrate its contents to GitHub???
07:35:22 <Tjr> Hmm
07:35:34 <enthropy> https://github.com/haskell/hackage-server/issues?page=5&state=closed starts at #2 in August 2013
07:35:39 <merijn> jeltsch: I think the old bug tracker was only for Hackage and not Hackage 2.0?
07:35:43 <Tjr> this works with 6.12.3, but not with 7.6.3
07:35:46 <Tjr> @let data (Fractional prob) => DiscreteProb prob a = DiscreteProb [ (prob, a) ]
07:35:47 <lambdabot>  .L.hs:150:6:
07:35:47 <lambdabot>      Illegal datatype context (use DatatypeContexts): Fractional prob =>
07:35:54 <merijn> I think Hackage2.0 has always been on github?
07:36:10 <merijn> Tjr: Right, becasue DatatypeContexts is not valid Haskell2010
07:36:21 <enthropy> Tjr: so enable -XDatatypeContexts if you really want it
07:36:23 <merijn> Tjr: Also, DatatypeContexts are a terrible extensions and you should NEVER use them
07:36:28 <jeltsch> I need information about the following bug: Cabal Install sometimes outputs the following error message: cabal: Codec.Compression.Zlib: premature end of compressed stream
07:36:29 <merijn> enthropy: Wrong answer
07:36:33 <Tjr> will that cause problems down the road?
07:36:55 <merijn> Tjr: Yes, the correct solution to "I want datatype contexts" is "want better things"
07:37:04 <enthropy> merijn: don't you ever have a context that's larger than the inferred one on a function?
07:37:23 <geekosaur> datatype contexts don't do what people think they do, and are generally not worth the pain
07:37:42 <Tjr> so what do people think, and what do they really do?
07:37:54 <merijn> hold on, lemme link an in-depth ticket I wrote about this
07:37:56 <jeltsch> I want to install darcs from source, but it is impossible, as I am always getting the above error message from the ZLib package.
07:38:29 * Tjr is under the assumption that data type contexts make it necessary to add that same context to every function that uses the data type.
07:38:33 <geekosaur> people want them to bring the context into scope automatically. in fact they only apply when creating values, not when pattern matching, so even if you have the context you need to be explicit about them in type signatures etc.
07:38:40 <geekosaur> which means they do almost nothing actually useful
07:38:52 <merijn> Tjr: If you use datatype contexts you *still* have to add those constraints on all your functions
07:38:57 <Philonous> geekosaur, I'm confused though, why would it be problematic to have fdWrite take a ByteString? It would be much closer to the Posix API (and it wouldn't have to care about locale at all)
07:38:57 <merijn> Tjr: See my explanation here: https://github.com/jgm/pandoc/pull/1143
07:39:05 <geekosaur> (GADTs fix this, but you must use GADTs and that introduces other restrictions)
07:39:28 <enthropy> the functions that don't have "Fractional prob =>" might be all nonsense
07:39:31 <geekosaur> Philonous, because the stated purpose of that module is to ONLY change the behavior of pathnames to be POSIX compliant
07:39:42 <geekosaur> not to change the entire interface to ByteString
07:39:49 <Philonous> geekosaur, I mean, why bother with encoding strings to begin with?
07:40:02 <geekosaur> ok, please go argue this with the maintainer
07:40:58 <geekosaur> I am apparently stupid because I think that fixing pathnames to be compliant is a good thing, and the rest is too fiddly/annoying to be automated
07:41:39 <geekosaur> and also stupid because I think otherwise maintaining interface compatibility with the rest of base's I/O system is somehow a good thing
07:42:59 <Tjr> apart from XDatatypeContexts, what surprises does the upgrade from 6.12.3 hold?
07:49:28 <Ch0c0late> What's the problem with this piece of code? http://hastebin.com/inalasaves
07:49:38 <Ch0c0late> It gives me       `a' is a rigid type variable bound by
07:50:24 <merijn> Ch0c0late: Type error unfortunately combining with numerical typeclasses
07:50:34 <Tjr> "Fractional a" no longer implies "Eq a".
07:50:44 <Tjr> Are there instances of Fractional that do not support ==?
07:50:46 <Saizan> Ch0c0late: if you have "n <- num" then num is supposed to be a list, but your type signature doesn't say that
07:50:49 <enthropy> merijn: "data IsHList b => HCons a b = HCons a b" seems to be a sensible use of -XDataTypeContexts
07:50:53 <merijn> Ch0c0late: You use "num" as input for your list comprehension, which means num has to be a list
07:51:05 <merijn> enthropy: Better solved with GADTs
07:51:12 <enthropy> GADTs are strict
07:51:24 <merijn> In what way?
07:51:51 <enthropy> you can't lazy pattern match on them
07:52:16 <enthropy> you can't use Data.Coerce with GADTs
07:52:24 <vanila> enthropy, wow I had idea!
07:52:28 <Tjr> What should go on the first line of a haskell source file?
07:52:38 <vanila> that's crazy.. I've been using GADTs all this time without knowing that
07:52:38 <Tjr> I've got a comment there, but emacs highlights it in red, like an error
07:52:43 <vanila> had no idea*
07:52:46 <merijn> enthropy: btw, why is that datatype contexts "sensible" considering any function using HList will already have that constraint?
07:52:50 <nikanda> Hi, is Integral a subtype of Num? I'm getting: "Constraint is no smaller than the instance head"
07:53:04 <enthropy> merijn: because you might forget to add that constraint yourself
07:53:08 <Saizan> vanila: they are not really strict like a datatype in a strict language would be
07:53:29 <nikanda> I have 'class Num a => Foo a where ...' and then 'instance Integral a => Foo a where ...'
07:53:33 <anbaric> vanila: their *fields* aren't strict, you just can't use a lazy (~) pattern match with them
07:55:22 <anbaric> vanila: because the RHS of a GADT case alternative has extra type equalities in the context, and you need a non-bottom value of the GADT type for that to be sound
07:57:40 <nikanda> It only works with UndecidableInstances, is that dangerous?
07:58:45 <vanila> I don't think that it's dangerous, just that it lets you do arbitrary computation in typeclass resolutio
07:58:46 <vanila> n
07:59:19 <Tjr> why does emacs' haskell-mode display the first comment line in red?
07:59:38 <Saizan> nikanda: that instance is going to overlap with everything
08:00:44 <nikanda> Saizan: isn't Integral a subset of Num?
08:01:14 <nikanda> I'd figure that if Integral is a subclass of Num there's no ambiguity?
08:01:16 <geekosaur> nikanda: instance constraints are not involved in instance selection
08:01:16 <anbaric> nikanda: the problem is that the instance head `Foo a` *always* matches no matter what `a` you're trying to find an instance for
08:01:20 <RchrdBrrll> Tjr, I think that it's normal for the first line(s) of the line to contain only a set of {-# LANGUAGE Foo #-} pragmas, then the 'module Foo where', then any other comments.
08:01:27 <geekosaur> the constraint is used as a test after the instance is picked
08:01:39 <Tjr> RchrdB: thanks
08:01:47 <Cheery> http://pastebin.com/BrAVKNeT
08:02:17 <Cheery> feeling like rad after doing this.
08:02:19 <nikanda> anbaric: Ah, so you're saying it matches both, even though Integral is more specific it doesn't take that into consideration? It takes "the only one that matches" which is multiple?
08:02:29 <albeit> I need to convert a "Map a b" into "Map c [(a,b)]" where "c = f a". Any ideas on where to start?
08:02:45 <nikanda> geekosaur: right I see, ok
08:02:51 <nikanda> geekosaur: I see the problem now :)
08:03:14 <nikanda> geekosaur: so I'm simply abusing type classes at this point then?
08:03:17 <Cheery> next it's time to translate this beast to C
08:03:28 <geekosaur> possibly
08:03:40 <nikanda> geekosaur: I don't want to write 'instance Foo Int where ...' for all types Int, Int32, Int64 etc
08:03:51 <nikanda> since all the implementations are the same
08:04:07 <hexagoxel> trying to install darcs into clean sandbox. get dependency problem (http://lpaste.net/878828365497237504). suggestions?
08:04:25 <lyxia> > id . runST $ return 0
08:04:26 <lambdabot>  Couldn't match type ‘m0 a0’ with ‘forall s. GHC.ST.ST s c’
08:04:26 <lambdabot>  Expected type: m0 a0 -> c
08:04:26 <lambdabot>    Actual type: (forall s. GHC.ST.ST s c) -> c
08:04:27 <lyxia> > id $ runST $ return 0
08:04:28 <lambdabot>  0
08:04:39 <lyxia> ^ can someone explain?
08:04:53 <Saizan> nikanda: that's the sensible way though, you can define the implmentation once and reuse it though
08:04:56 <geekosaur> nikanda, the way you normally do that is to put the default implementations in the class definition then use empty instance delcarations
08:05:16 <geekosaur> but you must list each type, you can't really do it by saying "for any member of this other typeclass"
08:05:22 <geekosaur> because that is dynamic
08:05:28 <merijn> lyxia: There's some oddity how RankNTypes combine with composition
08:05:33 <nikanda> geekosaur: Saizan I see, ok
08:05:35 <geekosaur> (that is, what you link your program against can change what types it applies to)
08:05:42 <geekosaur> typeclasses are open
08:05:48 <merijn> :t runST
08:05:49 <lambdabot> (forall s. ST s a) -> a
08:06:01 <nikanda> geekosaur: makes sense, I could have a type that impleemnts two typeclasses, so then it could potentially match multiple instances with equal "specificity"
08:06:03 <anbaric> nikanda: you can use DefaultSignatures to get almost what you want
08:06:16 <nikanda> anbaric: let me look that up! :)
08:06:28 <merijn> lyxia: The composition with id doesn't work due to that "forall" there, although the exact details on why are a bit opaque to me
08:06:29 <enthropy> lyxia: there's a special case in ghc for ($) but not for (.)
08:06:52 <enthropy> runST $ return 0 -- would not work without that special case
08:06:58 * hackagebot diagrams-canvas 0.2 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.2 (jeffreyrosenbluth)
08:07:00 <lyxia> Thanks!
08:10:49 <enthropy> https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcExpr.lhs#L270-L281
08:11:03 <enthropy> is the bit on runST
08:14:50 <lyxia> How would one rewrite runST $ do {...} without that exception?
08:14:56 <pejo> I get the same return value when I run "cabal install --only-dependencies --dry-run" regardless of whether there is something to install or not. Can I distinguish those two cases without parsing the output?
08:15:49 <Saizan> lyxia: runST (do ...)
08:15:59 <lyxia> oh right.
08:23:23 <Trollinator> pejo: I think Cabal can be used as a Haskell library. So why put up with the limitations of shell scripts when you can use Haskell?
08:25:43 <dcoutts> Trollinator: usually I'd agree. For the case of the dependency planner, that's not available in any library yet.
08:26:15 <Trollinator> poop
08:28:48 <thinkpad20> hey guys, I was running into cabal issues and decided to remove my haskell platform. Now I'm trying to install GHC and I'm getting errors. If I run it without sudo, the error is "error: unable to open output file 'rts/dist/package.conf.install.raw': ''". If I run it with sudo, I get "ghc-cabal: /usr/local/share/doc/ghc/html: does not exist"
08:29:00 <thinkpad20> this is when I run `make install` by the way
08:29:38 <thinkpad20> with "ghc-7.8.2-x86_64-apple-darwin-mavericks"
08:35:07 <Ankhers> I'm attempting to use Haskell's FFI. I'm following the example at http://www.haskell.org/haskellwiki/FFI_Introduction . I am getting a warning saying INCLUDE pragmas are deprecated. Will it just know which files to include, or is there some other way of doing it now?
08:41:43 <geekosaur> Ankhers, INCLUDE is nonfunctional unless you use the deprecated compile-to-C mechanism
08:41:58 <geekosaur> C include files don't help at all with the default compile-to-assembler
08:42:21 <geekosaur> if you really need that functionality, you need to write some C glue and FFI to that
08:43:46 <Ch0c0late> http://hastebin.com/disitilasu
08:43:54 <Ch0c0late> No instance for (Integral [Int]) arising from a use of sum'
08:44:14 <Ch0c0late> Am I doing something wrong in that piece of code?
08:44:43 <geekosaur> sure looks like it
08:44:50 <geekosaur> lists are not Integral
08:44:56 <vanila> Ch0c0late, it's like you're doing [1,2,3] + [4,5]
08:45:31 <thinkpad20> in the code `sum' xs = sum (filter is_mul_3_5 [1..(xs-1)])`, xs presumably is a list. So you can't subtract 1 from it
08:46:39 <Ch0c0late> No. I tried it out. xs is number. Bad naming convention. Sorry.
08:47:19 <rwbarton> ok but on line 8 you pass a list
08:48:07 <thinkpad20> if you want sum' to take a number, then you probably want to map sum' over that input list
08:48:15 <timemage> Ch0c0late, sometimes these things become clearer when you add type signatures for your top level function.
08:48:25 <Tjr> In haskell-mode (emacs), how do I autocomplete?
08:48:37 <thinkpad20> print $ map (sum' . (read :: String -> Int)) $ lines inputData
08:48:39 <Ch0c0late> timemage: Yes.
08:49:07 <Ankhers> geekosaur: Thanks.
08:49:32 <Ch0c0late> thinkpad20: Thanks. It worked.
08:49:35 <thinkpad20> and yeah I highly recommend writing out type signatures when you encounter weird errors
08:50:15 <Ch0c0late> thinkpad20: Yes. Good idea. Thanks.
08:51:31 <Ankhers> Tjr: I use company-mode.
08:52:34 <Tjr> Ankhers: Sorry I'm a newbie at emacs. How do I try out company-mode, assuming I have a file open in haskell-mode?
08:52:46 <Ch0c0late> It returns [23,2318].
08:53:09 <Ankhers> Tjr: What version of emacs are you using?
08:53:14 <Ankhers> 24.x?
08:53:31 <Tjr> whatever comes with the lates Ubuntu LTS. How do I find out the version?
08:53:50 <Cheery> hahaa. cool godard. indeed writing parse structures is fucking pointless.
08:54:04 <Ankhers> Tjr: C-h v emacs-version RET
08:54:37 <Tjr> 24.3.1
08:55:10 <Ankhers> You should be able to do M-x list-packages RET
08:56:29 <Ankhers> That will open up emacs package manager. by default you will only be able to see ELPA files. company-mode should be listed there. Just cursor over it, press "i x" to install.
08:56:38 <Ankhers> Let it compile and you should be good to go.
08:56:43 <Tjr> it has company ( but not company-mode) available as an uninstalled package
08:57:01 <Ch0c0late> thinkpad20: How to print the elements inside the returned array in separate line?
08:57:26 <Ankhers> That shouls be the same.
08:57:32 <Ankhers> s/shouls/should
08:59:11 <Tjr> done, 27 files compiled, 1 got an error that I don't understand
08:59:46 <Ankhers> Tjr: put it in a paste?
09:00:27 <Tjr> I quit emacs becaue it wouldn't let me close the buffer
09:00:37 <Tjr> so I can't access the message anymore
09:01:10 <rwbarton> Ch0c0late: you can reverse the process you used to parse the input, with 'show' and 'unlines'
09:01:11 <Ankhers> Tjr: Try opening a haskell file and doing M-x company-mode RET
09:02:30 <Tjr> Ankhers: "company mode enabled"
09:03:29 <Tjr> I just hope autocompetion is not alt-tab. because that switches application windows.
09:04:17 <Ankhers> Tjr: You can set it up however you want. I have mine to give suggestions after a small time of me not typing.
09:04:29 <Ankhers> Tjr: Though, you could also set it up to a keybinding.
09:04:50 <Ankhers> Tjr: Just do a search for "emacs company-mode" if you have any issues.
09:06:06 <Ankhers> Tjr: There is also #haskell-emacs where you can find some information.
09:06:36 <Tjr> Ankhers: thanks
09:06:37 <Tjr> will do
09:10:06 <Tjr> Ankhers: I've set a keybinding. How do I make company-mode launch autoamtically?
09:10:22 <Cheery> http://pastebin.com/r84wWixz
09:11:11 <Ankhers> Tjr: You can use (add-hook 'after-init-hook 'global-company-mode) to have company-mode everywhere. Else, you can just a mode specific hook to only use it in certain places.
09:12:06 * hackagebot snap-testing 0.6.0.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.6.0.0 (DanielPatterson)
09:12:59 <Cheery> http://pastebin.com/pj4Ur7a2
09:13:07 * Tjr copies that into ~/.emacs instead of going down the rabbit hole of making it specific to haskell
09:13:17 <Cheery> next I would have to implement those variables without type signatures..
09:13:38 <Cheery> and some stuff to get this language attach write barrier to some of them.
09:20:26 <jfischoff_> I was threadscoping a program and noticed that tens of thousands of threads were creating by the IO manager for foreign calls, why is that?
09:25:41 <squimmy> so, am i correct in understanding that do notation doesn't let you mix monads within the same do?
09:25:52 <jfischoff_> yes
09:26:02 <jfischoff_> you are correct
09:26:08 <squimmy> is there a way to achieve the same result?
09:26:25 <jfischoff_> MonadTransformers perhaps
09:26:25 <zwer> just like you can't mix different monads with >>=, types don't match
09:26:27 <squimmy> can i have nested dos, perhaps?
09:26:38 <nclarke> You can have nested dos
09:26:48 <vanila> what do you mean "the same result"
09:26:52 <vanila> there is no way to do it
09:26:58 <nclarke> But it's not clear that it does what you want
09:27:14 <squimmy> right. i'm probably not explaining myself well
09:27:37 <squimmy> say i have a list of maybes and i want to map a function through both the list and the maybe
09:27:55 <cschneid> Is there an uncurry for larger than 2 tuples?
09:27:57 <nclarke> (fmap . fmap) will do you
09:28:17 <squimmy> nclarke: huh. ok. i'll try that then, i guess
09:28:18 <squimmy> thanks
09:28:44 <nclarke> > let x = [Just 1, Nothing, Just 2, Nothing, Just 3]
09:28:46 <lambdabot>  not an expression: ‘let x = [Just 1, Nothing, Just 2, Nothing, Just 3]’
09:28:49 <pejo> jfischoff, the io manager puts blocking foreign calls on a native thread
09:29:01 <vanila> @let x = [Just 1, Nothing, Just 2, Nothing, Just 3]
09:29:04 <lambdabot>  Defined.
09:29:06 <squimmy> it would be lovely if just "do {x <- theListOfMaybes; y <- x; return $f y}" worked, but yeah :/
09:29:07 <vanila> now you can use x
09:29:10 <nclarke> vanila: Thanks!
09:29:20 <nclarke> > (fmap . fmap) (*2) x
09:29:21 <lambdabot>  Ambiguous occurrence ‘x’
09:29:21 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:149:1
09:29:21 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
09:29:21 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
09:29:21 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:29:37 <vanila> squimmy, ohh, I see - then it would be nested do like nclarke said
09:29:55 <nclarke> @let xbiggername = [Just 1, Nothing, Just 2, Nothing, Just 3]
09:29:56 <lambdabot>  Defined.
09:30:02 <nclarke> > (fmap . fmap) (*2) xbiggername
09:30:04 <lambdabot>  [Just 2,Nothing,Just 4,Nothing,Just 6]
09:30:04 <vanila> do {y <- x ; return (do z <- y ; return (z+1))}
09:30:08 <vanila> > do {y <- x ; return (do z <- y ; return (z+1))}
09:30:10 <lambdabot>  Ambiguous occurrence ‘x’
09:30:10 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:149:1
09:30:10 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
09:30:10 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
09:30:10 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:30:13 <vanila> oops :|
09:31:18 <squimmy> ok well this looks like enough for me to get things working like i want. thanks all :)
09:31:56 <nclarke> Since you're only using the `Functor` instance rather than the full Monad semantics, it all composes nicely, actually
09:33:54 <thinkpad20> (repost but oh well): Anyone know about GHC installation issues? I was running into cabal issues and decided to remove my haskell platform. Now I'm trying to install GHC and I'm getting errors. If I run it without sudo, the error is "error: unable to open output file 'rts/dist/package.conf.install.raw': ''". If I run it with sudo, I get "ghc-cabal: /usr/local/share/doc/ghc/html: does not exist"
09:34:05 <rwbarton> squimmy: your "do {x <- theListOfMaybes; y <- x; return $f y}" would collapse the lists, if theListOfMaybes was actually a list of lists
09:34:11 <rwbarton> so it's not what you wanted anyways
09:34:49 <thinkpad20> "it" being `make install` after downloading/extracting `ghc-7.8.2-x86_64-apple-darwin-mavericks.tar.xz`
09:35:42 <squimmy> rwbarton: yeah, like a flatmap, right?
09:35:46 <ray1234> Hello, new Haskeller here, I'm having trouble getting `forkFinally` to work with `bracket`. The "resource release" and "in-between" methods of the bracket don't run if I call the bracket with forkFinally (http://lpaste.net/107123)
09:36:04 <rwbarton> thinkpad20: did you run configure first?
09:36:30 <thinkpad20> yes
09:37:37 <squimmy> nclarke: (liftM . liftM) seems to work just the same as (fmap . fmap). if there a resource online somewhere that i can take a look at that explains when these two are different and why?
09:37:58 <rwbarton> and what installation directory did you choose, the default (/usr/local)?
09:38:36 <thinkpad20> i didn't specify one, so yeah it should be default
09:38:46 <nclarke> squimmy: Yes, they are the same thing
09:38:55 <nclarke> http://stackoverflow.com/questions/7463500/why-do-we-have-map-fmap-and-liftm
09:39:14 <rwbarton> ok, so definitely it won't work without sudo
09:39:24 <nclarke> GHC 7.8 has actually made Functor a superclass of Monad, so `liftM` should now just be `fmap`
09:39:47 <nclarke> I would encourage `fmap` over `liftM`
09:40:12 <thinkpad20> well I dunno, I have user permissions on /usr/local
09:40:26 <thinkpad20> but either way it doesn't work
09:40:44 <MagneticDuck> https://github.com/haskell-opengl/GLUT/issues/17
09:40:53 <MagneticDuck> any idea where the maintainers of haskell-opengl are?
09:41:13 <donri> nclarke: that's 7.10 and applicative
09:41:46 <nclarke> donri: Yes, but Functor is a superclass of Applicative, and superclass is transitive
09:41:50 <squimmy> nclarke: so even before GHC 7.8 they're still effectively identical?
09:41:59 <nclarke> donri: Is it 7.10? Thought it was going to be 7.8. Oh well
09:42:00 <donri> nclarke: yes, but not the other way around
09:42:25 <nclarke> squimmy: Yes. If they're not, something is seriously wrong
09:42:32 <squimmy> ok :)
09:42:43 <rwbarton> thinkpad20: I would guess you somehow have an old package database lying around and it is confusing ghc-cabal
09:42:56 <nclarke> donri: Why would it be the other way around?
09:43:14 <rwbarton> but I don't know where it would live on OS X
09:43:37 <rwbarton> probably inside /usr/local though, can you just grep for files containing ghc in there?
09:44:23 <pejo> donri/rwbarton, what are you doing, looking for ghc?
09:44:58 <thinkpad20> I'll look around
09:45:22 <thinkpad20> nothing in /usr/local
09:46:06 <thinkpad20> I'm running a find / for anything ghc related
09:46:17 <thinkpad20> probably should look for cabal stuff too
09:46:45 <shlevy> I'm pretty sure the answer is "no", but is there any way to prevent forkIO from being lifted into (MonadBaseControl IO m => ResourceT m) given there's resourceForkIO?
09:46:49 <rwbarton> alternatively you could try installing ghc somewhere else
09:47:45 <thinkpad20> yeah that's a possibility, do I do that in ./configure?
09:48:06 <rwbarton> yes, ./configure --prefix=/some/path
09:48:21 <donri> nclarke: because i misinterpreted your intended implications that's why
09:52:12 * hackagebot http-conduit-downloader 1.0.19 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.19 (VladimirShabanov)
09:52:13 <nschoe> Hi guys, is there a way to have ghci run inside my cabal sandbox (taking into account the packages installed in the sandbox) ?
09:52:27 <ray1234> cabal repl
09:52:36 <thinkpad20> rwbarton: still no dice :( here's the output I'm getting; does anything jump out at you? http://pastebin.com/15pnWVgW
09:52:57 <nschoe> ah ! This is what "cabal repl" is for ? Thanks, I was trying all possible combinations of ghci -i.cabal-sandbox/...
09:52:58 <nschoe> Thanks
09:53:12 <thinkpad20> nschoe: you can run `cabal exec bash` and run whatever you want from that shell
09:53:15 <rwbarton> oh
09:54:14 <nschoe> thinkpad20, what can I do then ? I tried it, now I have a sort of shell, but "import Text.Blaze" doesn't give me anything ?
09:54:19 <rwbarton> thinkpad20: if you're not running this as root now but you did in the past ... then there might be directories owned by root inside your unpacked ghc tarball
09:54:29 <rwbarton> that you can't write to
09:54:45 <thinkpad20> nschoe: well bash is just a shell like any other; you can run ghci from inside of that with whatever flags you want
09:55:08 <platz> i'm guessing cabal exec bash is needed if you're going to run an editor that uses ghc-mod in a sandbox
09:55:13 <nschoe> thinkpad20, okay but then how is it different from running ghci directly from my shell ?
09:55:34 <thinkpad20> rwbarton: hmm, perhaps that's the case? should I try rm'ing the extracted directory and trying again?
09:55:59 <thinkpad20> nschoe: because you get the updated PATH variable and whatever else `cabal exec` wraps
09:56:00 <rwbarton> yeah
09:56:14 <nschoe> Okay.
09:56:22 <nschoe> Thanks
09:57:00 <thinkpad20> rwbarton: yay! I ran a `sudo chown -R anelson .` and that fixed it
09:57:12 * hackagebot clafer 0.3.6.1 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.6.1 (mantkiew)
09:57:29 <thinkpad20> nschoe: nothing wrong with `cabal repl` of course; just in case you need it the shell can come in handy
09:57:56 <nschoe> thinkpad20, yeah ok. Will try to keep it in mind. For now cabal repl is enough ^^
09:57:58 <nschoe> Thank you
10:02:13 * hackagebot claferIG 0.3.6.1 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.6.1 (mantkiew)
10:02:15 * hackagebot claferwiki 0.3.6.1 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.6.1 (mantkiew)
10:12:00 <oisin620> I'm writing a thin wrapper over OpenGLRaw, and most of my functions look like: _ -> _ -> ... -> IO (). This is because they're wrapping over functions which all return IO (). Is this indicative of anything wrong in my code? Should I be able to find a better representation that eliminates the IO ()? Or is
10:12:48 <k0ral> could someone explain to me whether fixing https://github.com/basvandijk/scientific/issues/15 is a big deal ?
10:13:35 <k0ral> it's been opened for a month with no feedback, I'm considering fixing it myself but I don't know if I'm able to
10:17:00 <nschoe> Can I have some clarifications : I am using happstack with blaze-html and I think I'm lost in the types. I have this piece of code : http://lpaste.net/107125 which fails.
10:17:50 <nschoe> I am just trying to echo back what I receive from the form submission, and try to be safe in case some inputs were not filled in, this is why I use optional. But I'm unable to make it compile :/
10:18:28 <nclarke> Anyone seen this before: looks like a weird interaction of `where` and RankNTypes
10:18:43 <nschoe> With that code, it says Expected type: Maybe Html / Actual type: Maybe Lazy.Text
10:18:51 <nclarke> http://lpaste.net/107126
10:19:22 <dashster18> Is hmatrix a good linear algebra library?
10:19:50 <phaazon_> er, if I only want one page to use session through cookies in happstack, I guess I can just add the ClientSessionT around the ServerPartT IO of the page
10:19:56 <phaazon_> and lift it up in the routes
10:19:57 <rwbarton> nclarke: let- (or where-)bindings aren't generalized when certain extensions are on
10:19:57 <moghedrin> dashster18: It certainly did the trick for me, but that was a while ago.
10:20:32 <rwbarton> nclarke: if you write a type signature for x' it should work
10:21:04 <nclarke> rwbarton: Ah, cheers. Yeah, just had me scratching my head for a while!
10:22:31 <k0ral> as a matter of face, simply replacing integer-gmp with integer-simple in the dependencies of scientific makes it build fine
10:22:36 <k0ral> s/face/fact*
10:22:43 <peterhil> Especially the latter has helped me to get a hold on how to solve problems in the functional programming way.
10:22:46 <nschoe> ah ! Solved it by using <> "title: " <> toHtml (fromMaybe "no title" title)
10:22:55 <peterhil> Oops, wrong window...
10:23:41 <nclarke> rwbarton: Though I can't see how I can write the type signature there - it involves the type inside the Functor, which I don't see how to reference
10:25:03 <rwbarton> oh, it involves the return type of f you mean?
10:25:56 <rwbarton> I think you are allowed to write a type signature for fmap (maybe requires some other extension) and then use ScopedTypeVariables
10:27:15 * hackagebot these 0.4.2 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.4.2 (cmccann)
10:27:16 <glguy> nclarke: Just writing "instance Functor Argument where fmap f (Argument a b) = Argument (liftM f . a) (liftM f b)" or "instance Functor Argument where fmap f (Argument a b) = Argument (\s -> liftM f (a s)) (liftM f b)" worked fine here
10:27:41 <glguy> nclarke: Was the specific problem that you wanted to name x'?
10:27:45 <nclarke> glguy: Yes, that's what my paste shows
10:28:30 <nclarke> glguy: The problem was that my original version had x', and I couldn't for the life of me work out what GHC was complaining about :-)
10:28:44 <nclarke> There's no problem now
10:29:47 <nclarke> But I thought it was interesting enough to share
10:30:04 <glguy> nclarke: both lines you pasted here work fine here, so I was trying to figure out what wasn't working
10:30:38 <nclarke> glguy: "instance Functor Argument where fmap f (Argument x s ) = Argument x' (fmap f s) where x' s = x s >>= return . f" worked for you?
10:30:50 <glguy> Yeah, in GHC 7.8.2 with Rank2Types turned on
10:30:57 <nclarke> Hmm
10:31:21 <Ch0c0late> Solved a problem but seems the solution is naive. 2 test cases fail out of 6 due timeout. The solution is here http://hastebin.com/iqiwicuyal How could I make it better?
10:31:57 <nclarke> glguy: Ah, interesting
10:32:07 <nclarke> It works with Rank2Types, but not with RankNTypes
10:32:14 <bennofs> How can I check for (void*)(-1) in Haskell? there is throwErrnoIfNull, but there doesn't seem to be a throwErrnoIfVoidMinus1
10:33:43 <bennofs> Hmm, nullPtr `plusPtr` (-1) works
10:34:40 <glguy> Ch0c0late: You should be able to find a closed for solution to this "sum' x = sum (filter is_mul_3_5 [1..(x-1)])" instead of summing up all the values
10:34:44 <glguy> form*
10:35:56 <thinkpad20> if I'm explicitly importing prelude, how do I import the List type and its constructors? for example with Maybe I can write `Maybe(..)`... what's the equivalent with List?
10:37:22 <MagneticDuck1> Ch0c0late: filter is_mul_3_5 [1..] is periodic, so you can just use the handy fact that sum [1..x] == (x * (x + 1)) `div` 2 to make a finite time solution
10:37:32 <MagneticDuck1> s/finite/O(1)
10:37:35 <MagneticDuck1> >_<
10:37:52 <MagneticDuck1> uhm, not quite O(1)
10:37:56 <MagneticDuck1> but you get what I'm trying to say =P
10:38:41 <jfischoff_> thickpad20: did you try ([])(..) ?
10:38:49 <geekosaur> syntax error here
10:39:02 <geekosaur> and [](..) gets me the error that Prelude doesn't export it
10:39:07 <glguy> You don't need to explicitly import []
10:39:09 <glguy> It's in scope
10:39:11 <geekosaur> (but it nows where Prelude imported it from)
10:39:12 * jfischoff_ nods
10:39:23 <geekosaur> I think it's syntax, anyway, so perhaps doesn't need import
10:39:25 <nschoe> thinkpad20, "import GHC.Types ([])" ?
10:39:43 <geekosaur> but lists are a bit weird
10:39:49 <glguy> http://lpaste.net/107129
10:39:52 <geekosaur> in standard Haskell they are syntax
10:40:03 <kazagistar> how does the normal prelude import lists?
10:40:04 <glguy> thinkpad20: ^
10:40:07 <geekosaur> in GHC Haskell they're kinda half syntax and half extended-ghc
10:41:22 <thinkpad20> the `:` constructor as well?
10:41:32 <MagneticDuck1> Ch0c0late: if you're trying to impress an employer, then the solution is "f x = sum . (filter $ (\x' -> liftM2 (&&) (x 3) (x 5)) ((==0) .) . `div`)) $ [1..100]"
10:41:40 <MagneticDuck1> or some such thing =P
10:41:59 <glguy> MagneticDuck1: No, I promise that won't impress any employers
10:42:07 <MagneticDuck1> glguy: aww :<
10:42:39 <lithiumdeuteride> what's the best platform/IDE for learning Haskell on Windows?
10:42:42 <MagneticDuck1> I mean, it will only impress them if they don't appreciate dumb things like CODE READIBILITY
10:43:16 <MagneticDuck1> lithiumdeuteride: IDEs are not a good way to learn a language
10:43:19 <Averell> virtualbox with a linux install
10:43:42 <lithiumdeuteride> what would you suggest, then, magneticduck?
10:43:49 <Ch0c0late> MagneticDuck1: Thanks.
10:43:54 <MagneticDuck1> lithiumdeuteride: well, for a first, use linux :D
10:44:08 <lithiumdeuteride> OK, i haven't counted it out
10:44:10 <simcity2000> lithiumdeuteride: you're probably going to have a little less pain if you run a VM with Linux Mint on it
10:44:14 <MagneticDuck1> but if that isn't possible, make your setup force you to deal with everything at a fairly low level
10:44:25 <MagneticDuck1> just make sure you aren't being cushioned by some IDE that does everything for you
10:44:34 <genisage> has anybody here ever tried NixOS?
10:44:39 <MagneticDuck1> learn a good editor, for one (that's essential, imo)
10:44:44 <glguy> There isn't really a risk of a Haskell IDE that does everything for you
10:45:06 <pejo> glguy, how come?
10:45:15 <glguy> Because it doesn't exist yet?
10:45:24 <MagneticDuck1> pretty sure that EclipseFP thing is pretty solid IDE
10:45:25 <simcity2000> lithiumdeuteride: arguments about the utility of IDEs aside, most of what's out there for development in a non-.NET language is oriented towards non-windows users
10:45:45 <MagneticDuck1> but I'm not sure, have barely used it
10:45:45 <simcity2000> and the command prompt is a very poor substitute for a fully functioning terminal
10:45:47 <lithiumdeuteride> i see tutorial videos of folks prototyping stuff, and i always wonder what they're using
10:45:57 <lithiumdeuteride> i take it the majority of it is Linux
10:46:04 <simcity2000> yes
10:46:29 <MagneticDuck1> tbh I'm not sure how you're supposed to do anything in windows
10:46:35 <pejo> glguy, oh, thought you meant that such a thing couldn't be built.
10:46:40 <MagneticDuck1> I mean, I guess the have a shell?
10:46:43 <simcity2000> lithiumdeuteride: personally I use vim with a browser window for documentation and GHCi running to check for issues
10:46:43 <MagneticDuck1> but.. ick
10:47:16 <MagneticDuck1> vim is as powerful as you need an editor
10:47:31 <lithiumdeuteride> are there really obstacles to getting such functionality in windows?
10:47:43 <Averell> no technical ones
10:47:56 <lithiumdeuteride> just not a lot of effort being put towards it?
10:47:56 <MagneticDuck1> after you've been using it for a while and have made / come to use a large selection of tools and workflow thingies, it becomes the envy of any IDE, don't worry
10:47:57 <pejo> MagneticDuck, I think the point of an IDE is to be more than just an editor.  They're comfortable.
10:48:09 <luite> MagneticDuck1: don't tell me what i need :p
10:48:42 <MagneticDuck1> you need: food; water; vim; (sleep); other, less, important things
10:48:44 <luite> i need to fix my emacs setup again :/
10:49:16 <MagneticDuck1> emacs: an very interesting operating system with a kinda crappy editor built in
10:49:25 <Averell> except for evil mode
10:49:27 <chirpsalot> MagneticDuck1: but it has vim built in :).
10:49:39 <MagneticDuck1> it doesn't have vim *built in*
10:49:52 <MagneticDuck1> but yeah, if you have a way of running vim from inside emacs then there's your editor :D
10:49:59 <simcity2000> lithiumdeuteride: I'd be concerned some packages might not build correctly in windows
10:50:00 <dreams> MagneticDuck1: crappy editor?
10:50:16 <MagneticDuck1> I am, of course, referring to the default mechanism for editing text
10:50:26 <chirpsalot> I don't really understand the editor wars. They all kind of suck :(.
10:50:53 <MagneticDuck1> ah, so chirpsalot is battling his own seperate front, the opinion that they "all kind of suck"
10:50:56 <pejo> simcity2000, I think a lot of things do build just fine in Windows. And the package maintainers are on average quite keen to make portable things.
10:51:00 <MagneticDuck1> "EMACS! lisp is cool!"
10:51:15 <MagneticDuck1> "vim, we're (lightweight?)" "nah, you guys all kinda suck"
10:51:31 <chirpsalot> MagneticDuck1: yeah man! Eventually everybody will be as apathetic and depressed as me :).
10:51:39 <dreams> MagneticDuck1: I use both vim/emacs. I don't dislike any but I find scripting in vim to be a pain and ugly as opposed to emacs.
10:51:54 <MagneticDuck1> dreams: vimscript is not, um, the language of the future
10:52:49 <simcity2000> pejo: that's fair--I haven't tried haskell in Windows but I've seen bad things re: incompatibility in Python and Go
10:52:50 <dreams> MagneticDuck1: nor is elisp but its way better.
10:53:09 <kazagistar> lets not editor war and say we didnt
10:53:24 <dreams> Its not a war, we're just exchanging thoughts.
10:53:38 <MagneticDuck1> well, they are all dwarfed by the impossible beauty and practicality of having an editor based in haskell!
10:53:57 <kazagistar> the thoughts have been expressed a million times over the past few decades, they are old thoughts
10:54:00 <chirpsalot> MagneticDuck1: I have been thinking about that recently, actually.
10:54:13 <chirpsalot> MagneticDuck1: I think there are a few kicking about.
10:54:23 <MagneticDuck1> yes
10:54:41 <MagneticDuck1> last I heard there were a few things, but they're far from stable and even farther from being widely used
10:54:47 <lithiumdeuteride> the attraction of Haskell seems to be its ability to manage complexity
10:55:15 <MagneticDuck1> yeah
10:55:45 <lithiumdeuteride> so i don't understand why there isn't a good editor or implementation for windows
10:55:51 <Ch0c0late> MagneticDuck: parse error on input ``'
10:55:57 <Ch0c0late> MagneticDuck1: parse error on input ``'
10:56:09 <pejo> Yi seems usable, so not sure what you mean by far from stable MagneticDuck.
10:56:19 <MagneticDuck1> you're trying to run that thing I posted?
10:56:31 <MagneticDuck1> uhm. it was a bit of a joke, I didn't test it
10:56:37 <dreams> kazagistar: heh, how do you think technology evolved? The same topics were expressed million of times until something better came out of them.
10:56:48 <chirpsalot> lithiumdeuteride: I think most people tend to shy away from Windows development for one reason or another.
10:56:53 <Ch0c0late> MagneticDuck: Yes.
10:57:10 <Pythonfant> lithiumdeuteride: which editor doesn't run on windows?
10:57:15 <chirpsalot> lithiumdeuteride: you should be able to get emacs / vim working, though, no?
10:57:25 <Pythonfant> afaik sublime, vim, emacs, which should be most editors people here use run just fine
10:57:38 <lithiumdeuteride> is it because they feel the Windows environment is capricious and not dependable for long-term stuff?
10:58:11 <chirpsalot> lithiumdeuteride: are you looking for more of an IDE type deal or something? Because then I don't know if there even is a Haskell "IDE".
10:58:35 <lithiumdeuteride> i'm a complete beginner; i don't know what i'm looking for
10:58:54 <simcity2000> lithiumdeuteride: I think that's part of it
10:58:57 <pejo> chirpsalot, there's an eclipse plugin, and an IntelliJ plugin. I don't know whether that qualifies as IDE or not.
10:59:04 <simcity2000> lithiumdeuteride: there are a lot of reasons developers shy away from windows development
10:59:38 <pejo> lithiumdeuteride, is there an editor or IDE that you're already comfortable with?
10:59:52 <lithiumdeuteride> nope, i'm a blank slate
11:00:02 <lithiumdeuteride> i have a keyboard, and know how to type
11:00:06 <chirpsalot> lithiumdeuteride: I would probably recommend emacs for a beginner -- people will disagree and they're not wrong either... But emacs tends to have a nicer learning curve if you're not used to these things than vim.
11:00:29 <MagneticDuck1> Ch0c0late: import Control.Monad, then run
11:00:31 <MagneticDuck1> >   sum . filter ((\x' -> liftM2 (&&) (x' 3) (x' 5)) (flip flip 0 . ((==) .) . div)) $ [1..100]
11:00:33 <lambdabot>  5035
11:00:35 <MagneticDuck1> taa daa
11:00:48 <lithiumdeuteride> apart from keyboard shortcuts, what's the most useful functionality of Emacs?
11:00:50 <MagneticDuck1> haskell is so practical
11:00:54 <genisage> there's leksah, a haskell IDE in haskell
11:00:57 <chirpsalot> lithiumdeuteride: that has been my experience teaching first year courses anyway.
11:01:00 <rrrr12> can someone help me figure out why `connectTo` isn't working on forked threads (`forkIO`)?
11:01:06 <simcity2000> chirpsalot: I've had the opposite experience personally
11:01:09 <pejo> lithiumdeuteride, it allows you to send mail
11:01:10 <chirpsalot> lithiumdeuteride: all of the editors pretty much have equivalent sets of features.
11:01:20 <lithiumdeuteride> haha
11:01:23 <simcity2000> lithiumdeuteride: it's the only editor I know of that's turing-complete
11:01:50 <Ch0c0late> MagneticDuck1: The naive solution returns 2318 but yours returns 5035.
11:01:57 <MagneticDuck1> ;D
11:02:04 <genisage> but if you really want to use a text editor instead of an IDE, I recommend ed.
11:02:10 <chirpsalot> lithiumdeuteride: really the point is there isn't a bad choice between emacs / vim / sublime or whatever. It doesn't really matter. Just pick one and check out the others later.
11:02:21 <lithiumdeuteride> ok, thanks for the advice
11:02:26 <Pythonfant> sublime is probably the easiest
11:02:27 <Ch0c0late> MagneticDuck1: Btw, thanks.
11:02:44 <chirpsalot> lithiumdeuteride: the most important thing is that you get started :).
11:02:46 <MagneticDuck1> Ch0c0late: my code isn't exactly helpful
11:02:55 <lithiumdeuteride> yes, that's the hardest part
11:03:02 <simcity2000> lithiumdeuteride: is this your first languge you're learning?
11:03:27 <MagneticDuck1> > ((100 * 101) `div` 2) - 5035
11:03:28 <lambdabot>  15
11:03:32 <MagneticDuck1> -_-
11:03:32 <lithiumdeuteride> i'm not dev-quality in any language
11:03:39 <sm> why would "cabal haddock" tell me Main is defined in every source file ?
11:03:49 <simcity2000> lithiumdeuteride: gotcha
11:03:50 <jml> is there a standard function that takes an Either and raises an exception if it's Left?
11:03:53 <lithiumdeuteride> i have a scientific background, mainly in Mathematica
11:04:04 <lithiumdeuteride> i learned it was partially modeled after Lisp
11:04:24 <genisage> let exceptionIfLeft (Right x) = id
11:04:43 <lithiumdeuteride> i got a book on Lisp, but the antiquated syntax put me off
11:04:51 <kazagistar> lithiumdeuteride: until you start working on larger codebases, it does not matter. you will probably spend 90% of your thinking and 10% actually modifying code... when it gets more complex, then browsing code efficiently gets more important
11:04:54 <simcity2000> jml: is there something wrong with writing a pattern like f (Left _) = undefined ?
11:04:56 <MagneticDuck1> haskell is a bit better than lisp in syntax
11:05:09 <genisage> * let exceptionIfLeft (Right x) = Right x
11:05:11 <MagneticDuck1> btw, I believe it is possible to write haskell entirely without parens
11:05:29 <peterhil> Has anyone used the OpenAL Haskell bindings' ALC.Capture successfully? All the C examples use getIntegerv to actually read the recorded samples, but the Haskell binding to that is in a hidden module Sound.OpenAL.ALC.QueryUtils, and it doesn't seem to compile...
11:05:33 <simcity2000> MagneticDuck1: sure, but you won't die if you try using them
11:05:36 <kazagistar> MagneticDuck1: right, but the flow sucks and jumps all over
11:05:41 <chirpsalot> lithiumdeuteride: common lisp has so much antiquated cruft. It's like programming with a museum.
11:06:06 <lithiumdeuteride> chirpsalot:  yeah, that's how it appeared to me
11:06:08 <sm> I expect they'll say the same about haskell one day
11:06:22 <kazagistar> chirpsalot: if you ever learn a lisp, clojure and/or racket
11:06:29 <simcity2000> sm: that's true of pretty much any language
11:06:44 <chirpsalot> MagneticDuck1: I don't think that would be a good idea :P. Don't you need parens to pattern match? I guess you would define everything with record syntax?
11:06:46 <lithiumdeuteride> future programmer:  "you mean you used two-dimensional text editors!?"
11:06:49 <pejo> simcity2000, uh. Your program will crash when it hits that undefined. That's pretty terrible.
11:06:50 <sm> well some last longer than others
11:06:57 <kazagistar> er, that was meant at lithiumdeuteride
11:07:01 <peterhil> chirpsalot: Luckily it's not LISP1 anymore... So it's not just (CAR (CADR (CDR ( ... ))
11:07:20 <kazagistar> CDADDDADAR
11:07:21 <chirpsalot> kazagistar: yeah, racket is soooooo much better. I had to use a crippled subset of common lisp for a class, though.
11:07:29 <peterhil> I have a book, which is from the 90's and it's full of code like that... :-)
11:07:38 <simcity2000> pejo: I was just chucking undefined in there since it's the only exception I've used
11:08:23 <simcity2000> pejo: the goal is to raise an exception on a Left, unless it's not to actually raise an exception
11:09:13 <lithiumdeuteride> doing some research, it seemed like Haskell was the laser to Lisp's incandescent bulb
11:09:19 <dwcook> jml, are you looking for Either a b -> IO b ?
11:09:55 <simcity2000> lithiumdeuteride: it depends on your perspective, I think
11:10:09 <simcity2000> lithiumdeuteride: as a language, and only a language, Haskell is very pretty and does some very cool things
11:10:26 <dwcook> jml, though I'd say an explicit handling of the Left in a case expression is likely to be a better choice.
11:10:34 <dwcook> (not with undefined though)
11:10:40 <simcity2000> lithiumdeuteride: as a tool it's also very cool, and very very useful, but you need a little more vigilance in separating out the talk about Haskell as language rather than Haskell as tool
11:10:44 <jml> dwcook: I was, yes.
11:10:47 <simcity2000> jml: don't actually use undefined
11:10:56 <jml> simcity2000: I wasn't intending to.
11:11:00 <simcity2000> haha, good
11:11:25 <simcity2000> but yeah, as a matter of taste I'd handle the Left explicitly
11:11:39 <jml> ok. I'll give that a try.
11:12:28 <simcity2000> jml: you'll often see things like aeson's EitherDecode, where Left is a string error message and Right is the value you'd want
11:12:32 <simcity2000> eitherDecode*
11:13:18 <jml> right, I've seen a lot of Either String b
11:13:25 <jml> sometimes richer objects than String
11:14:12 <simcity2000> jml: right, and you may (or may not) want to do something with that value
11:14:48 <jml> the use case here is reporting command-line usage errors
11:15:19 <kazagistar> jml: you aren't reinventing command line option parsers, right? :P
11:15:31 <jml> kazagistar: hardly. I'm using GetOpt.
11:16:14 <jml> because when there are sixteen or so command line option parsers, you're almost guaranteed choose the wrong one
11:16:19 <kazagistar> I didn't like getopt when I tried it, but that is just a matter of taste
11:16:35 <bergmark> getopt is composable, and that's really nice
11:16:36 <simcity2000> jml: does getopt not have a sensible default in place for failure?
11:17:06 <kazagistar> optparse-applicative just does all I need to to really easily, but yeah, getopt is nice if you want a lot of control I think
11:17:07 <peterhil> Actually, wrt the OpenAL.ALC.Capture, I get these same errors: https://groups.google.com/forum/#!topic/haskell-cafe/jObXgcUs_oQ So this might be easy to fix?
11:17:08 <jml> https://hackage.haskell.org/package/base-4.7.0.0/docs/System-Console-GetOpt.html – it raises an ioError
11:17:19 <jml> at least in the example code for using it
11:18:00 <peterhil> Maybe somebody just hid the QueryUtils module at some point for maintaining buildability with newer GHC versions?
11:25:07 <Ch0c0late> How to keep all fibonacci terms while calculating the fibonacci? I have f x = f (x - 1) + f (x - 2); f 0 = 0; f 1 = 1
11:25:28 <vanila> what you can do is pass the previous value as a parameter
11:25:35 <vanila> so f x = f (x - 1) + f (x - 2);
11:28:12 <vanila> sorry I mean pass the previous value along with the result
11:28:13 <Ch0c0late> I want to append those terms into a list and then do some operation on the list such as summing even-valued terms vanilla
11:29:13 <vanila> oh
11:29:22 <vanila> so you can replace f n with g!!n
11:29:30 <vanila> where g is a list of the results
11:29:42 <vanila> f x = g!!(x - 1) + g!!(x - 2); f 0 = 0; f 1 = 1
11:29:46 <vanila> g = map f [1..]
11:30:31 <vanila> the way I was meaning before was to define a function f' n that returns fib(n) and fib(n-1) as a pair because that lets you speed up the recursion
11:31:47 <simcity2000> vanila: won't the runtime of that be super slow?
11:31:53 <simcity2000> run time*
11:38:55 <genisage> let fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
11:39:03 <ReinH> yes, that
11:39:08 <ReinH> @quote zip`ap`tail
11:39:08 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:40:52 <MagneticDuck1> =P
11:41:15 <MagneticDuck1> more commonly known as ap-zip-tail
11:42:24 * hackagebot strive 0.5.1 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.5.1 (fozworth)
11:42:53 <ReinH> > let fibs = fix ((0:) . scanl (+) 1) in take 10 fibs
11:42:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
11:45:25 * genisage sucks at using fix.
11:45:36 <pejo> Missed the answer earlier so asking again. Is there some way to distinguish when cabal install --only-dependencies --dry-run wants to install something and not, beyond parsing the output?
11:45:44 <dwcook> > fix error
11:45:46 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
11:45:52 <MagneticDuck1> :D
11:46:06 <MagneticDuck1> gotta love fix
11:46:23 <MagneticDuck1> but what was that github snippit I read a while ago about an operator that is somehow above fix..?
11:46:28 <MagneticDuck1> can't remember its name
11:46:28 <kazagistar> that did the opposite of fix the error :P
11:46:30 <dwcook> I just find the difference between the English meaning and the Haskell meaning striking :P
11:46:36 <simcity2000> genisage: does that implementation recreate the fibs list twice to make a third one...?
11:46:56 <genisage> I don't believe so.
11:46:59 <ReinH> simcity2000: no
11:47:19 <simcity2000> spiffy, then
11:47:26 <ReinH> fibs is shared
11:47:34 <MagneticDuck1> if you think "join" "recreates" something "twice", then yes
11:47:57 <ReinH> MagneticDuck1: where's the join?
11:48:26 <MagneticDuck1> well, ap
11:48:37 <ReinH> no ap in his
11:48:42 <MagneticDuck1> "ap (zipWith (+)) tail"
11:48:47 <ReinH> ... wasn't used.
11:48:53 <MagneticDuck1> yes I know
11:49:01 <ReinH> and <*> doesn't need to join for (-> a)
11:49:07 <ReinH> :t (<*>)
11:49:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:49:14 <MagneticDuck1> but (zipWith (+) fibs (tail fibs)) == ((ap (zipWith (+)) tail) fibs)
11:49:22 <ReinH> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
11:49:22 <lambdabot> f a b c = a c (b c)
11:49:36 <simcity2000> ap (zipWith (+)) tail is a lot less readable, though
11:49:38 <MagneticDuck1> it's an "ap-like structure" I guess
11:49:42 <MagneticDuck1> simcity2000: yes I know
11:49:51 <ReinH> MagneticDuck1: right, but if no join is happening...
11:50:01 <MagneticDuck1> I mean "ap", not join
11:50:16 <genisage> Sorry, in the "ap (zipWith (+)) tail" version, where do the initial 0,1 come from?
11:50:36 <ReinH> the default ap is implemented in terms of (>>=)
11:50:36 <MagneticDuck1> you need to supply them
11:50:46 <ReinH> genisage: he left out a bit :)
11:51:18 <ReinH> and (<*>) for (-> e) is a straightforward combinator
11:52:15 <MagneticDuck1> ugh
11:52:49 <ReinH> I'm just trying to figure out why you said that.
11:53:50 <gaze__> hey so... writing an FFI for a c++ based library is a real pain in the ass, right?
11:53:57 <gaze__> what if you turned it inside out
11:54:17 <gaze__> and you made an ffi on the haskell side so you have some C++ that consumes your program like an iteratee
11:54:27 <MagneticDuck1> my "ugh" was inspired by my confusion about all this monad/applicative-foo stuff
11:54:36 <jle`> > (zip <*> tail) [1,2,3,4,5]
11:54:38 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
11:56:05 <MagneticDuck1> :t fmap zip
11:56:06 <lambdabot> Functor f => f [a] -> f ([b] -> [(a, b)])
11:56:27 <MagneticDuck1> :t fmap zip tail
11:56:28 <lambdabot> [a] -> [b] -> [(a, b)]
11:56:38 <MagneticDuck1> oh, ofc x|
11:56:41 <MagneticDuck1> :t ap zip
11:56:42 <lambdabot> ([a] -> [b]) -> [a] -> [(a, b)]
11:57:16 <Guest82336> anyone know up-to-date this doc is? http://www.haskell.org/haskellwiki/Simple_Servers
11:59:59 <ReinH> gaze__: but then you'd be writing your program in C++
12:00:59 <ReinH> MagneticDuck1: which Applicative instance is being used in `zipWith (+) <*> tail'?
12:01:01 <pejo> gaze, there's Language.C.Inline or similar from Manuel Chakravarty. But I think it's mostly ObjC/C so far.
12:01:29 <gaze__> I mean, your c++ is only there to consume your haskell program
12:01:36 <MagneticDuck1> :t ap
12:01:37 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:01:41 <gaze__> it's no more or less code than would ordinarily be needed for an ffi
12:01:48 <gaze__> ideally less for c++
12:01:58 <MagneticDuck1> ReinH: as I said, I'm not very brushed up on this stuff
12:02:02 <pejo> gaze, you want to export your Haskell program as a C(++) function?
12:02:08 <ReinH> MagneticDuck1: well let's think about it
12:02:14 <gaze__> in some sense
12:02:16 <ReinH> :t (<*>)
12:02:16 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:02:24 <gaze__> your haskell program is phrased as an iteratee
12:02:28 <gaze__> which the c++ program consumes
12:02:40 <pejo> gaze, isn't a foreign export enough for that, as long as you stick to exporting C?
12:03:11 <gaze__> that's not the point
12:03:15 <ReinH> means we need an applicative f in both positions
12:03:16 <ReinH> :t tail
12:03:16 <ReinH> er.
12:03:17 <lambdabot> [a] -> [a]
12:03:20 <ReinH> Hmm, I think my IRC client is eating my messages
12:03:31 <ReinH> Ok, there we go, just crazy latency
12:03:46 <slomo> Guest82336: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf this might be interesting for you and is newer
12:03:48 <ReinH> :t zipWith (+)
12:03:48 <lambdabot> Num c => [c] -> [c] -> [c]
12:03:57 <rwbarton> I think you would end up writing more code decoding the instructions from the Haskell side and dispatching to various C++ functions than you would just wrapping the C++ functions in C and exporting those to Haskell
12:04:32 <MagneticDuck1> ReinH: *listening*
12:04:37 <gaze__> rwbarton: Other way around, I mean
12:04:51 <ReinH> MagneticDuck1: so we have zipWith (+) :: [a] -> [a] -> [a] and tail :: [a] -> [a], and these both have to unify with (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:05:27 <ReinH> MagneticDuck1: so starting with the `f a', there's only one choice that unifies with [a] -> [a]: the (-> a) applicative
12:05:28 <gaze__> rwbarton: Maybe your FFI functions become GADTs and the c++ code just runs your code written in the operational monad or something
12:06:08 <gaze__> but yeah you totally could be right... this might be more complicated
12:06:22 <ReinH> so we have [a] -> [a] ~ e -> b gives e ~ [a] and b ~ [a]
12:06:58 <ReinH> MagneticDuck1: then we check that it unifies with the other term: (e -> b -> c) ~ [a] -> [a] -> [a] gives e ~ [a], b ~ [a], c ~ [a] and we're done.
12:07:12 <ReinH> so we just replace f with (-> e)
12:07:49 <MagneticDuck1> very nice
12:07:58 <MagneticDuck1> :t join
12:07:58 <lambdabot> Monad m => m (m a) -> m a
12:08:00 <MagneticDuck1> :t ap
12:08:01 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:08:04 <MagneticDuck1> :t liftM2
12:08:05 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:14:51 <tgeeky> I know there are people here who have worked with the (codata <-> cellular atomata) correspondence; any of them here also interested in physics?
12:15:59 <ReinH> edwardk is but he's out atm
12:16:14 <ReinH> tgeeky: I have a lay interest in physics if that helps
12:16:16 <nschoe> is
12:16:31 <tgeeky> Gerard t'Hooft (Nobel Laureate) is propsing to interpet qauntum mechanics with a rooting in cellular automata http://arxiv.org/pdf/1405.1548v2.pdf
12:16:49 <tgeeky> edwardk once told me he'd had it with physics :O
12:17:25 <Franciman> Hi all
12:17:36 <ReinH> tgeeky: that paper seems like a big deal
12:17:56 <Franciman> I am looking for a complete bnf of ghc's haskell. Where do you think I can get it?
12:18:07 <joelteon> guys, with haddock, can I document entities that I'm re-exporting? they have no documentation yet
12:20:20 <nschoe> Why (in Happstack) does 'optional $ lookText "myVar"' return (Just "") when "myVar" is empty ? Shouldn't it return Nothing ?
12:20:46 <pejo> Franciman, is ghc's parser sufficient for your needs?
12:22:01 <Franciman> pejo the problem is that I find it difficult to understand happy's syntax
12:22:05 <Franciman> well I'll try hard :P
12:22:07 <Franciman> Thanks
12:22:49 <pejo> Franciman, it's not only happy, the grammar is big.
12:23:34 <enthropy> joelteon: you can do something like    module M ( -- $descriptionOfX\n x ) where import SomewhereElse (x)\n -- $descriptionOfX\n -- blah blah
12:23:46 <Franciman> pejo but the grammar file is interspersed with semantics so it's a burden
12:23:53 <Franciman> I'm only interested in syntax
12:24:20 <Franciman> well I'll stick with the report then
12:24:43 <pejo> Franciman, are you trying to parse Haskell, or learn Haskell, or something else?
12:24:46 <tgeeky> ReinH: I agree. He has been on this tack for a year or two now; but this is the first complete document about it I've seen
12:24:59 <Franciman> pejo writing an indenter for vim
12:25:09 <d3lxa> what's wrong with the happy package not found when it's a dependency but it can be installed by hand (The program happy version >=1.17 is required but it could not be found.) is this related to the new version format: X.X.X?
12:25:50 <pejo> d3lxa, happy is not in your path?
12:26:04 <d3lxa> pejo: how it could be, it's not installed yet
12:26:59 <pejo> d3lxa, you said it could be installed but not found?
12:27:12 <d3lxa> pejo: cabal install happy works fine, that's what I meant "by hand"
12:27:13 <Saizan> d3lxa: build-tools are not installed automatically, they don't even need to be haskell packages
12:27:34 <Saizan> d3lxa: but yeah, it would be nice if it worked for those that are
12:27:55 <Saizan> d3lxa: it's working after you installed it by hand though?
12:27:57 <d3lxa> Saizan: sorry I don't understand, what's this build-tools?
12:28:11 <d3lxa> Saizan: yes, it's been the case for a few weeks
12:28:49 <Saizan> d3lxa: build-tools is one of the fields in a .cabal file, it specifies some executables needed to build the package
12:28:57 <tgeeky> anyone who knows who maintains happy's webpage? the changelog is 5 or 6 versions behind: http://www.haskell.org/happy/CHANGES
12:30:01 <d3lxa> Saizan: mh ok… how is that related to the problem with 'happy'?
12:30:27 <bitemyapp> aloiscochard: what
12:30:30 <bitemyapp> aloiscochard: what I do
12:30:54 <pejo> Franciman, there seems to be a lot of these attempts around already. http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
12:32:30 * hackagebot vinyl-gl 0.2.1 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.2.1 (AnthonyCowley)
12:32:50 <Saizan> d3lxa: happy is usually not a proper dependency but a build-tool
12:33:57 <d3lxa> Saizan: yes, ok but why is this even printed then: "setup: The program happy version >=1.17 is required but it could not be found." if I can install it by then, it's in cabal…
12:34:18 <d3lxa> isn't it an error from cabal trying to say it cannot find this package?
12:34:21 <pejo> d3lxa, the happy binary is not in your path.
12:35:41 <d3lxa> Saizan: so it's not part of the normal dependency system but something apart?
12:35:52 <d3lxa> like a line in the cabal build target
12:37:20 <Franciman> pejo, yup. I am doing that just for fun.
12:37:49 <Saizan> d3lxa: the error could be better, but it's saying that the program happy could not be found, not the package, it doesn't even try to look for the package
12:38:07 <Saizan> d3lxa: so, yeah, it's not considered a package dependency
12:38:31 <d3lxa> Saizan: ok, I see, it's much clearer; I thought it was cabal complaining
12:39:19 <Saizan> it's a different part of it complaining :)
12:41:43 <pejo> Franciman, a lot of them seem to be using haskell-src-exts. Maybe a bit easier than reverse-engineering the ghc grammar. Or harder, depends on your background I guess.
12:43:05 <mimblewabe> hello
12:43:29 <mimblewabe> I have a problem with CHP package -- it doesn't build against base 4.7
12:43:40 <Franciman> pejo I don't know whether I can use haskell in vim's scripting language
12:44:04 <Franciman> most likely I can't. Otherwise they would not use that abomination
12:44:20 <Franciman> for that we need to wait neovim I think
12:44:25 <bergmark> Franciman: but you can just invoke some executable, right? that's how you use stylish-haskell in editors
12:44:26 <mimblewabe> I've already written to the maintainer but I was wondering whether there's anything (safe for somehow installing an older version of GHC) that I could do to get CHP working with my GHC 7.8
12:45:02 <bergmark> mimblewabe: is it just an upper bound issue or does the code need to be updated as well?
12:45:09 <mimblewabe> just FTR, I'm quite new to Haskell in general and dealing with Cabal and broken packages in particular, so I have basically no clue :)
12:45:52 <Franciman> bergmark, oh right! Stupid me
12:46:05 <mimblewabe> well, basically the code will work only up to 4.6 because block function in Control.Exception was removed in 4.7
12:47:24 <mimblewabe> So I guess the only two choices are getting an older GHC or updating the code?
12:47:35 <bergmark> mimblewabe: i think so
12:48:44 <mimblewabe> all right, thx for the confirmation
12:49:06 <redding> How is it that I can load a file in ghci without any errors, but trying to compile it with GHC produces a ton of them
12:49:10 <redding> ?
12:50:08 <tgeeky> redding: you have flags that are set somewhere, like .ghci; which allow the compile to take place in that context?
12:50:18 <tgeeky> what kinds of errors? all kinds? some kinds? just one?
12:50:48 <redding> tgeeky: 7 type errors
12:51:13 <redding> yet when i load the same file into GHCI, the program runs as expected
12:51:18 <tgeeky> redding: try :load *modulename
12:51:27 <tgeeky> see if you are loading a previously compiled version
12:51:46 <redding> include the asterisk?
12:52:53 <redding> yep, using cabal repl, and then loading the module in that way produces no errors
12:53:09 <tgeeky> redding: paste the code/errors to lpaste?
12:54:24 <tgeeky> it could be monomorphism if you're on 7.8.1 and you didn't say 7 type errors
12:54:45 <redding> oh, ill try that...
12:55:57 <ocharles> kosmikus: only skimmed g-sop and the paper verry briefly, but can it be used to derive functor? Given the isomorphism between GHC.Generics Rep (not Rep1), i'm guessing not?
12:56:15 <redding> tgeeky: ah, setting NoMonomorphismRestriction seemed to do the trick
12:58:29 <average> is there a haskell advent calendar ?
12:59:10 <redding> also, to compile a project using cabal sandbox I should do something like cabal exec sh?
13:01:08 <kclark> code that runs in ghci doesn't want to load from a module:
13:01:09 <kclark> http://lpaste.net/107141
13:01:13 <kclark> why?
13:03:00 <Cale> kclark: The type signature you gave is wrong
13:03:16 <nexx> kclark remove this line sortNestedList :: [[a]] -> [[a]]
13:03:16 <Cale> kclark: sort requires an instance of Ord for the elements of the list
13:03:43 <codygman>  How can I use ghc 7.8.* with Nix easiest?
13:03:45 <Cale> You can't sort just any list at all, it must be a list for which there's an ordering defined on the elements
13:03:48 <Cale> :t sort
13:03:49 <lambdabot> Ord a => [a] -> [a]
13:04:04 <codygman> Err wrong channel
13:04:09 <redding> damn now I can't get ghc to link :(
13:04:10 <Cale> e.g. it doesn't mean much to try to sort a list of functions
13:04:31 <Cale> redding: Building GHC on an unusual platform?
13:04:42 <redding> nope, osx
13:04:49 <kclark> i'm using the map to build a tuple with (length, a)
13:04:52 <Cale> redding: Oh, in that case, why compile it yourself?
13:04:52 <redding> err i'm not building ghc
13:04:58 <Cale> oh
13:05:02 <kclark> and just using "sort" to work on the first part of the tuple
13:05:07 <redding> I mean, when I'm compiling my program it fails during linking
13:05:14 <kclark> stealing the "Schwartzian Transform" from Perl
13:05:15 <Cale> redding: ah
13:05:22 <Cale> kclark: right
13:05:26 <redding> that wouldn't be caused by cabal exec would it?
13:05:47 <kclark> so the original [[a]] doesn't itself need to be an Ord (?)
13:06:28 <Cale> kclark: In order to compare (x,y) with (x',y'), you compare x with x', and if that's EQ, you compare y with y'
13:06:30 <dwcook> @type sortBy (comparing length)
13:06:30 <lambdabot> [[a]] -> [[a]]
13:06:41 <Cale> You might prefer to use sortBy (comparing fst)
13:06:53 <kclark> ooo, neato
13:07:03 <Cale> :t sortBy (comparing fst)
13:07:03 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
13:07:44 <Cale> (What you're doing overall is equivalent to sortBy (comparing length), but more efficient, as your algorithm will only compute the lengths of the lists once.
13:07:45 <Cale> )
13:08:25 <dwcook> Cale, is that better by superconstant factor?
13:08:32 <kclark> i'll work on this, thanks for the insights!
13:08:34 <Cale> yes
13:08:55 <Cale> dwcook: well, hmm
13:09:38 <Cale> dwcook: You expect to do O(n log n) comparisons
13:09:56 <dwcook> Sure
13:10:47 <carlosgaldino> what exactly infixl 7 mean?
13:10:52 <dwcook> Oh, I see. So you'd compute the length n times instead of n log n I guess
13:11:00 <Cale> So it's just slightly worse than a constant factor, but the constant factor is pretty significant
13:11:28 <carlosgaldino> I'm trying to understand why  10 `div` length [1, 2] works but div 10 length [1, 2] doesn't.
13:11:37 <dwcook> carlosgaldino, the infix operator version of that binding is left-associative and with precedence 7
13:11:42 <Cale> carlosgaldino: it means that the operator is left associating and precedence level 7
13:11:54 <moghedrin> dwcook: Beat me to it.
13:12:00 <dwcook> s/version of/way of writing/
13:12:07 <Cale> carlosgaldino: div 10 length [1,2] = ((div 10) length) [1,2]
13:12:14 <dwcook> @quote fugue
13:12:14 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
13:12:20 <Cale> carlosgaldino: in general, f x y z = ((f x) y) z
13:12:42 <Cale> (div 10 length) is a type error
13:12:58 <Cale> :t div
13:12:59 <lambdabot> Integral a => a -> a -> a
13:13:02 <Cale> :t div 10
13:13:03 <lambdabot> Integral a => a -> a
13:13:05 <Cale> :t div 10 length
13:13:06 <lambdabot> Integral ([a] -> Int) => [a] -> Int
13:13:07 <quchen> Cale: No, actually, it's well-typed.
13:13:14 <quchen> But ill-well-typed :-)
13:13:21 <Cale> Well, it involves a constraint which is unsatisfied
13:13:26 <dwcook> It's well-typed but not what you expected
13:13:35 <Cale> as we don't have an instance of Integral for functions of type [a] -> Int
13:13:48 <Cale> (at least, without adding one)
13:14:24 <Cale> carlosgaldino: You probably want div 10 (length [1,2])
13:14:56 <dwcook> The only thing binding more tightly than function application is record syntax. Any infix operators will bind less tightly
13:15:10 <diana> http://www.4rog.eu/2014/07/cinnamon.html
13:15:28 <dwcook> g a `f` h b = f (g a) (h b)
13:15:44 <carlosgaldino> Cale: yeah, so without infix notation the precedence is which level?
13:16:38 <Cale> carlosgaldino: Function application always binds more tightly than any infix operator
13:16:38 <quchen> Strictly speaking function application has no fixity (since it is special syntax), but you can imagine it as infixl 11.
13:17:32 <_Vi> Is the choice of word "return" in the return functions any good? Maybe it should have been called by some another word, like "wrap"...
13:17:34 <carlosgaldino> Cale: quchen aaaaaaah. now I get it. so 10 `div` length [1, 2] will first apply length
13:17:34 <ReinH> dwcook: And . when used as a module separator, ofc
13:17:35 * hackagebot AlgorithmW 0.1.0.0 - Example implementation of Algorithm W for Hindley-Milner  type inference.  http://hackage.haskell.org/package/AlgorithmW-0.1.0.0 (MartinGrabmueller)
13:17:42 <carlosgaldino> and that's why I don't get a type error
13:17:44 <carlosgaldino> cool
13:17:48 <carlosgaldino> Cale: quchen thanks
13:17:59 <Cale> carlosgaldino: actually, it'll first apply div to 10 and (length [1,2])
13:18:01 <carlosgaldino> and thanks dwcook as well
13:18:12 <dwcook> _Vi, in math it's often called "unit", because it's basically a monoidal unit.
13:18:17 <Cale> But order of evaluation has nothing to do with how the expression is associated
13:18:33 <carlosgaldino> Cale: really? oh
13:18:37 <Cale> _Vi: I like the word 'return'
13:18:40 <mimblewabe> okay, this is really weird. can anyone explain why 1 length typechecks and True length doesn't?
13:18:43 <mimblewabe> :t 1 length
13:18:44 <lambdabot> Num (([a] -> Int) -> t) => t
13:18:47 <mimblewabe> :t True length
13:18:48 <dwcook> carlosgaldino, careful with your use of "first". Don't be fooled into thinking it describes actual order of application.
13:18:48 <lambdabot>     Couldn't match expected type ‘([a0] -> Int) -> t’
13:18:48 <lambdabot>                 with actual type ‘Bool’
13:18:48 <lambdabot>     The function ‘True’ is applied to one argument,
13:18:48 <_Vi> dwcook, Why it is not called so in Haskell. "return" is just as to intentionally confuse C programmers...
13:18:53 <chirpsalot> For some reason I thought you could change the precedence of function application for different functions, but I guess it's just for infix stuff?
13:19:04 <Cale> _Vi: return v is the action which does nothing except to, well, return v.
13:19:16 <quchen> _Vi: C's syntax is a bit confusing, it uses the monadic bind operation for modify-right-shift.
13:19:28 <RchrdB> chirpsalot, yeup, just for binary infix operators.
13:19:29 <chirpsalot> quchen: cute ;).
13:19:59 <Cale> mimblewabe: Numeric literals are polymorphic
13:20:05 <ReinH> _Vi: it could have been called "pure" if Applicative had been added before Monad
13:20:06 <Cale> :t 1
13:20:06 <lambdabot> Num a => a
13:20:20 <Cale> I'm glad return is not called pure
13:20:21 <ReinH> and "pure" could have been called "unit" or "eta", although both are maybe a bit too mathy.
13:20:25 <chirpsalot> RchrdB: I guess that makes sense! Thanks! That actually clears stuff up, because I was sitting here weeping in terror at the possibility of function application changing in precedence.
13:20:32 <Cale> It reads nicely as return in do-notation.
13:20:37 <ReinH> Cale: alternatively, pure could have been called return
13:20:38 * quchen wants to throw "inject" into the race for new names for return
13:20:49 <ReinH> Cale: I think that's the only logical reason to call it return, but it's a good one
13:20:52 <dwcook> I find it sort of bothersome the use of the word "pure" to mean "non-monadic" or "restricted to Identity"
13:20:53 <FireFly> To confuse Ruby programmers? :P
13:20:57 <Cale> Of course, if we want to throw in silly names, how about η ?
13:21:02 <ReinH> The Monad interface was pretty obviously defined in service of do syntax
13:21:06 <FireFly> (I think inject is what Ruby calls folds)
13:21:15 <kclark> thanks for the help, fellas -- here's the corrected pastie:
13:21:16 <kclark> http://lpaste.net/107141
13:21:30 <ReinH> Cale: I did say "eta" :p
13:21:49 <mimblewabe> :t (1 :: Int) length
13:21:50 <lambdabot>     Couldn't match expected type ‘([a0] -> Int) -> t’
13:21:50 <lambdabot>                 with actual type ‘Int’
13:21:50 <lambdabot>     The function ‘1 :: Int’ is applied to one argument,
13:21:54 <mimblewabe> got it, thx
13:22:10 <Cale> ReinH: I think that the fact that return v is an action which returns v is a pretty logical reason to call it return.
13:22:19 <ReinH> example 1: "return". example 2: (>>=) instead of (=<<). example 3: centering return/fmap/bind instead of return/join.
13:22:47 <Cale> ReinH: It's just the fact that return v is an action in itself which is confusing to C or other imperative language programmers
13:22:48 <quchen> class Applicative m => Monad m where eta :: a -> m a; mu :: m (m a) -> m a -- We didn't call Monad "Pipable" so why not go all the math way :-)
13:23:03 <schell> hey all - is there a way to have cabal just build one executable listed in a project’s cabal file?
13:23:06 <ReinH> quchen: :p
13:23:20 <Cale> (and so it doesn't and can't have the control flow behaviour that it has in imperative languages which implicitly wrap every definition in callCC)
13:23:21 <ReinH> quchen: works for me, maybe not so much for non-mathy folks :p
13:23:22 <_Vi> Maybe "return" should have been some couple of characters instead of any word, to match with ">>="?
13:23:28 <quchen> schell: The executables have names in the cabal file, right? "cabal build <name>" should do the trick
13:23:30 <RchrdB> ReinH, don't you mean centreing return/bind instead of return/fmap/join?
13:23:38 <ReinH> RchrdB: why yes I do, sorry
13:23:44 <dwcook> I recently had an epiphany. It used to bother me that the word "return" was used both for the result of a function (A -> B) and the parameter of some monad (M B), but it turns out one's a special case of the other.
13:23:44 <schell> quchen: yes, they do - thanks! :)
13:23:45 <Cale> _Vi: Don't worry, you'll get used to it and probably end up liking the name
13:23:59 <dwcook> It still *somewhat* bothers me because not every monad fits that intuition, but that's a separate discussion. :)
13:24:04 <quchen> schell: If the names clash between libraries and executables somehow I think you can distinguish them using some suffix, like "X-lib" or something. But I'd have to look that up.
13:24:05 <ReinH> dwcook: except that return for the (-> a) monad is const :p
13:24:07 <bb010g> Type algebra question: you have data List x = Cons x (List x) | Nil === L(x) = x*L(x)+1 = 1+x*L(x). Expanded, L(x) = 1+x+x^2+x^3*L(x) = 1+x+x^2+x^3+x^4... Let F(x) = L(x) - 1 = -1 + L(x). Then F(x) = -1 + 1 + x + x^2 + x^3... = x + x^2 + x^3... which means a Foo x type would have either an x or the product of x & x or... but "subtracting" 1 from th
13:24:07 <bb010g> e List data declaration would give Foo x = Foo x (Foo x) which would make Foo x a stream and be F(x) = x^∞ = x*x*x*x*x*x... = x*x^2*x^3... = x*F(x). So I'm seeing that Foo is both infinite and stoppable. Also, F(x) = x*F(x); x = F(x)/F(x) = 1. I'm confused.
13:24:07 <bb010g> Type algebra question: you have data List x = Cons x (List x) | Nil === L(x) = x*L(x)+1 = 1+x*L(x). Expanded, L(x) = 1+x+x^2+x^3*L(x) = 1+x+x^2+x^3+x^4... Let F(x) = L(x) - 1 = -1 + L(x). Then F(x) = -1 + 1 + x + x^2 + x^3... = x + x^2 + x^3... which means a Foo x type would have either an x or the product of x & x or... but "subtracting" 1 from th
13:24:07 <bb010g> e List data declaration would give
13:24:07 <bb010g> Foo x = Foo x (Foo x) which would make Foo x a stream and be F(x) = x^∞ = x*x*x*x*x*x... = x*x^2*x^3... = x*F(x). So I'm seeing that Foo is both infinite and stoppable. Also, F(x) = x*F(x); x = F(x)/F(x) = 1. I'm confused.
13:24:14 <quchen> ಠ_ಠ
13:24:14 <Cale> whoa
13:24:17 <quchen> @where paste
13:24:17 <lambdabot> Haskell pastebin: http://lpaste.net/
13:24:20 <dwcook> ReinH, hmm, good point. I'll need to think on this some more :P
13:24:22 <ReinH> bbee: next time, please use a pastebin
13:24:36 <ReinH> woops
13:24:37 <_Vi> Cale, I am already used; but when I imagine explaining Haskell to somebody, the phrase "Oh, 'return' is not actually a return" comes to mind...
13:24:39 <ReinH> bbee: never mind
13:24:50 <benzrf> @unmtl
13:24:50 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
13:24:54 <benzrf> oops
13:24:57 <benzrf> @unmtl Cont r a
13:24:57 <lambdabot> (a -> r) -> r
13:25:01 <benzrf> hmm
13:25:06 <quchen> benzrf: Before you go on, /q lambdabot.
13:25:07 <mimblewabe> regarding eta, mu -> does Haskell support some notion of adjoint functors and derivation of monads out of that for free?
13:25:12 <benzrf> quchen: :p
13:25:15 <Cale> _Vi: Well, that's probably the least of the differences between Haskell and the average imperative language.
13:25:40 <ReinH> Cale: I think the issue is that it makes it easy to believe in a false equivalency
13:25:41 <Cale> _Vi: Just explaining that return constructs an action which does nothing except to produce the given value as its result should do nicely.
13:25:48 <benzrf> fds
13:25:54 <benzrf> oops
13:25:57 <benzrf> ok so
13:26:07 <benzrf> a value of type Cont r a is... what exactly
13:26:14 <benzrf> it's not a continuation, is it?
13:26:19 <_Vi> Cale, But this thing can trigger something like "Everything so alien... so confused... Oh! 'return' at the end of 'do' block - at last some thing I'm familiar with..."
13:26:31 <Cale> _Vi: You might want to explicitly point out that it doesn't have the control flow effect that return in imperative languages has
13:26:32 <ReinH> mimblewabe: It supports the notion of adjoint functors in a limited way, but not afaik the ability to construct the monads they give rise to for free
13:26:33 <benzrf> :t Cont
13:26:34 <lambdabot>     Not in scope: data constructor ‘Cont’
13:26:34 <lambdabot>     Perhaps you meant one of these:
13:26:34 <lambdabot>       ‘Const’ (imported from Control.Lens),
13:26:37 <benzrf> :t cont
13:26:38 <lambdabot> ((a -> r) -> r) -> Cont r a
13:26:42 <Cale> But such an effect would contradict the monad laws anyway
13:26:44 <ReinH> mimblewabe: but edwardk has been doing a lot of work in that area lately so he'd know better
13:26:48 <dwcook> mimblewabe, you might be interested in the free package
13:26:50 <dwcook> @hackage free
13:26:51 <lambdabot> http://hackage.haskell.org/package/free
13:27:27 <ReinH> mimblewabe: it does let you implement the free functor from functors to monads, which dwcook gave an example of
13:27:28 <benzrf> so a `Cont r a' is a 'contination handler'? something that you can use callCC on?
13:27:38 <Cale> _Vi: at this point, I'm actually glad that return doesn't have this effect, because it makes refactoring easier
13:27:45 <quchen> Cont r a is a wrapper around a (a -> r) -> r.
13:27:48 <benzrf> :t callCC
13:27:49 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
13:27:59 <benzrf> quchen: yes but what is that supposed to 'represent'
13:28:09 <Cale> If you're refactoring a piece of code in which there might be early returns, you have to look more closely at it before chopping out a block and moving it to its own definition.
13:28:18 <quchen> A function in CPS. Instead of returning, it allows you to apply a function to the result before doing so.
13:28:19 <ReinH> benzrf: ... values of type (a -> r) -> r and their associated monadic operations :p
13:28:21 <mimblewabe> interesting, thanks for the references
13:28:24 <Cale> (you might not even be able to do that refactoring)
13:28:29 <benzrf> ReinH: y do u hurt me so
13:28:43 <benzrf> quchen: ok
13:29:06 <ReinH> mimblewabe: in fact you can also play tricks with Yoneda and such in Haskell to improve the asymptotic performance of free monads.
13:29:13 <quchen> That reminds me that I should rewrite my Cont tutorial, because it's awful. I'd like to link to my imaginary new version now.
13:29:55 <Cale> Control.Monad.Cont ought to have getCC and getCC' in it
13:30:03 * dwcook hasn't yet got any idea why Cont is useful
13:30:14 <quchen> Cale: What's that? The "goto" functions?
13:30:26 <levi> Continuations are one of those simple things that are surprisingly hard to fully grasp the consequences of.
13:30:39 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2005-July/010623.html
13:30:45 <Cale> ^^ those ones :)
13:30:58 <quchen> dwcook: One example I've seen is to chain `bracket`s, which has a Cont-y type. You can have a list of actions, and sequencing them all runs all the bracket actions, closing the handles in the end.
13:31:04 <Cale> edwardk: ^^
13:31:33 <quchen> Cale: That's what I meant. :-)
13:31:41 <ReinH> benzrf: well, a generalization of Cont is one of the ways you can "improve" free monads, so they have surprisingly wide application.
13:32:07 <ReinH> edwardk: mimblewabe had a question about adjunctions in Haskell that you are pretty well placed to answer, I think.
13:32:32 <ReinH> edwardk: which is: can you represent adjunctions in Haskell and is there a way to construct the monads they give rise to for "free"?
13:32:58 <benzrf> ReinH: well i used to understand why the cont monad is basically a wrapper around bind
13:33:01 <benzrf> or something like that
13:33:15 <benzrf> iirc ContT m is isomorphic to m, right
13:33:32 <benzrf> @unmtl ContT r m a
13:33:32 <lambdabot> (a -> m r) -> m r
13:33:43 <benzrf> i mean ContT r m <=> m r
13:33:48 <benzrf> or uh, something
13:33:50 <benzrf> i dont remember
13:34:01 <ReinH> heh
13:34:13 <bmuk> Does anyone use aura?
13:34:21 <Cale> :t runCont . sequence . map Cont
13:34:21 <lambdabot>     Not in scope: data constructor ‘Cont’
13:34:22 <lambdabot>     Perhaps you meant one of these:
13:34:22 <lambdabot>       ‘Const’ (imported from Control.Lens),
13:34:24 <Cale> :t runCont . sequence . map cont
13:34:25 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
13:34:30 <benzrf> i just remember that bind on Cont is not very mearningful
13:34:49 <Cale> ^^ how to compose a list of withFoo-style functions together to get one which acquires a list of resources at once
13:35:25 <levi> bmuk: You mean the arch program?
13:35:30 <bmuk> yes
13:35:34 <levi> I have used it.
13:35:37 <quchen> Cale: e.g. launch all the asyncs, crash them all when one fails
13:35:40 <benzrf> ok so
13:36:27 <benzrf> a `Cont r a' is a function taking a callback or continutation from a to r
13:36:32 <bmuk> It seemed really accessible; I was thinking about writing a blog post about how it works.
13:36:37 <benzrf> so
13:36:44 <benzrf> p:
13:37:03 <benzrf> :t (>>=) `asAppliedTo` (undefined :: Cont r a)
13:37:04 <lambdabot> ContT r Identity a -> (a -> ContT r Identity b) -> ContT r Identity b
13:37:08 <levi> bmuk: I have only used it, I haven't looked at the source. But that sounds like a nice project.
13:37:21 <benzrf> Cont r a -> (a -> Cont r b) -> Cont r b
13:37:35 <bmuk> levi: thanks! I was just trying to gauge interest
13:37:37 * hackagebot TransformersStepByStep 0.1.0.0 - Tutorial to monad transformers.  http://hackage.haskell.org/package/TransformersStepByStep-0.1.0.0 (MartinGrabmueller)
13:38:05 <benzrf> wait a sec
13:38:16 <benzrf> :t fmap `asAppliedTo` (undefined :: Cont r a)
13:38:17 <lambdabot>     Couldn't match type ‘ContT r0 Identity a0’ with ‘a -> b’
13:38:17 <lambdabot>     Expected type: a -> b
13:38:17 <lambdabot>       Actual type: Cont r0 a0
13:38:24 <levi> bmuk: I think that's a generally valuable sort of thing to do, both for you and people who are learning to write useful Haskell software.
13:38:25 <benzrf> fft
13:38:32 <benzrf> :t flip fmap `asAppliedTo` (undefined :: Cont r a)
13:38:33 <lambdabot> ContT r Identity a -> (a -> b) -> ContT r Identity b
13:39:07 <benzrf> hmmm
13:40:16 <benzrf> ((a -> r) -> r) -> (a -> b) -> ((b -> r) -> r)
13:40:17 <levi> bmuk: I can't promise internet fame, but I'll read it. ;)
13:41:53 <benzrf> :t let contFmap f cpsf = cpsf . (. f) in contFmap
13:41:54 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
13:42:06 <benzrf> \o/
13:43:00 <benzrf> :t \f g -> f . (. g)
13:43:01 <lambdabot> ((a -> c1) -> c) -> (a -> b) -> (b -> c1) -> c
13:43:08 * iXeno tries to wrap his head around the Reader monad
13:43:10 <benzrf> huh
13:43:12 <iXeno> but so far failing
13:43:18 <benzrf> iXeno: here's the trick
13:43:18 <bmuk> levi: haha thanks! I already wrote something but it's more about using it as a package manager than the haskell behind it. (http://54.88.92.146 if youre interested)
13:43:27 <benzrf> iXeno: dont think about functions
13:43:37 <benzrf> think about hypothetical 'reader things'
13:44:01 <iXeno> that's where I struggle...
13:44:09 <joshc> do you grok State?
13:44:29 <benzrf> iXeno: (>>=) :: Reader r a -> (a -> Reader r b) -> Reader r b
13:44:33 <iXeno> I've even implemented the reader monad (but not ask and the like) - but I just don't see where it fits...
13:44:40 <benzrf> iXeno: i know that feel
13:44:46 <benzrf> iXeno: ok, look at the above signature
13:45:09 <benzrf> think of Reader r a as a 'deferred a' that will show up once an environment of type r is provided
13:45:15 <jfischoff_> I’m getting the following error when I try to post with http-client and http-client-tls: (InternalIOException threadWait: invalid argument (Bad file descriptor))
13:45:22 <iXeno> benzrf: yeah, that's what I got out of it
13:45:39 <benzrf> iXeno: if you have a deferred a and a function from a to a deferred b, you can get a deferred b
13:45:48 <jfischoff_> I’m also receiving UDP packets, not sure if that is relevant.
13:45:48 <benzrf> iXeno: or alternatively
13:46:06 <jfischoff_> It is happening with a range of versions
13:46:08 <iXeno> benzrf: that a reader is a function that takes an argument and returns a static value, and you use >>= to change the value
13:46:15 <benzrf> iXeno: ish
13:46:33 <benzrf> iXeno: think of the Reader monad as being a way to have a static environment that can be seen at any level
13:46:37 <iXeno> benzrf: so you got a function that you can call with any argument to get a static value... now, why would you do that?
13:46:41 <dwcook> iXeno, are you aware that a Reader r a is practically a function r -> a?
13:46:48 <benzrf> iXeno: it's vice versa
13:46:55 <iXeno> dwcook: yeah
13:47:12 <benzrf> iXeno: the main purpose of the reader monad is for when you want to implicitly pass values along
13:47:36 <benzrf> iXeno: for example, if you have program configuration that determines some values
13:47:47 <benzrf> Reader Config a is a value of a that depends on the Config
13:48:05 <iXeno> dwcook: benzrf: so I can make a Reader Int String, construct it with e.g. "hello", and if I do reader 10, I'll get "hello"
13:48:07 <benzrf> so if you have an a that's dependent on the config and a function from a to a b that's dependent on th eocnfig
13:48:21 <dwcook> Well its (>>=) and such can be understood in terms of that translation. (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) -- which is just a special way to compose two functions
13:48:23 <augur> helloooo~
13:48:23 <benzrf> iXeno: thats not really the point
13:48:56 <kini> question: I'm trying to figure out why the "primitive" package gives an unneeded import warning when I try to compile it. The unneeded import is supposedly this line: https://github.com/haskell/primitive/blob/master/Data/Primitive/Array.hs#L32
13:49:12 <dwcook> iXeno, do you mean: return "hello" -- ?
13:49:16 <kini> but I can't see what else in that file could possibly import the symbol runST
13:49:22 <augur> dwcook: !
13:49:26 <dwcook> augur, !
13:49:28 <kini> it indeed compiles just fine if I delete that line, so runST must be getting provided by something...
13:49:32 <iXeno> dwcook: yeah
13:49:38 <benzrf> iXeno: (>>=) on Reader is basically function composition where the 2nd function wants to see the same argument as the 1st function
13:49:40 <dwcook> iXeno, return "hello" = const "hello"
13:49:52 <levi> jfischoff_: You using Linux? If you are, might try an 'strace' on the binary to see which system call is returning a bad fd.
13:49:53 <jfischoff_> kini: because it is only used by older ghc
13:49:56 <augur> dwcook: did i tell you? i now have an HPSG feature structure widget
13:50:04 <jfischoff_> levi: good idea
13:50:06 <benzrf> iXeno: the applicative instance may be a bit easier
13:50:09 <dwcook> augur, that depends, what does HPSG stand for?
13:50:10 <kini> jfischoff_: what is only used by older ghc?
13:50:15 <iXeno> benzrf: hmm... lemme think a bit..
13:50:19 <kini> oh
13:50:20 <augur> dwcook: head-driven phrase structure grammar
13:50:22 * kini smacks head
13:50:24 <benzrf> iXeno: f <*> v is applying the result of f to the result of v
13:50:32 <benzrf> iXeno: where f and v both take the same argument
13:50:33 <kini> thanks jfischoff_ :)
13:50:34 <joshc> window 3
13:50:35 <dwcook> augur, I have no idea what that means, but cool :)
13:50:38 <augur> dwcook: :p
13:50:39 <jfischoff_> kini: :)
13:50:49 <benzrf> iXeno: (f <*> v) x = f x (v x)
13:51:17 <benzrf> iXeno: so let's say you can get a function :: a -> b from a Config value
13:51:22 <benzrf> and a value :: a from a Config value
13:51:23 <iXeno> benzrf: I think I got it
13:51:40 <augur> dwcook: an HPSG-style feature structure is a rooted DAG with labelled edges (that point uniquely, so sort of like records but with sharing)
13:51:40 <benzrf> then you can say, once there's a Config available, apply the values extracted
13:51:45 <iXeno> I just didn't quite read f >>= g = \r -> g (f r) r the right way
13:51:50 <benzrf> :-0
13:51:54 <benzrf> i mean :-)
13:51:55 <dwcook> joshc, FYI, if you're perchance using irssi, Alt+3 does the same thing
13:52:24 <dwcook> (and without as much probability of embarassingly entering commands into a channel :)
13:52:25 <benzrf> (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
13:52:27 <kini> another question - can I invert "#if __GLASGOW_HASKELL__ >= 702\nfoo\n#else\nbar\n#endif" as "#if __GLASGOW_HASKELL__ < 702\nbar\n#else\nfoo\n#endif"?
13:52:38 * hackagebot TransformersStepByStep 0.1.0.1 - Tutorial to monad transformers.  http://hackage.haskell.org/package/TransformersStepByStep-0.1.0.1 (MartinGrabmueller)
13:52:40 * hackagebot AlgorithmW 0.1.0.1 - Example implementation of Algorithm W for Hindley-Milner  type inference.  http://hackage.haskell.org/package/AlgorithmW-0.1.0.1 (MartinGrabmueller)
13:52:46 <benzrf> iXeno: you're basically composing a function (r -> a) and function (r -> b)
13:52:47 <kini> or is there some behavior I need to worry about when __GLASGOW_HASKELL__ is undefined or not a number, that doesn't invert?
13:52:53 <benzrf> iXeno: except that the 2nd function also wants to see the original
13:52:54 <benzrf> r
13:52:56 <joshc> dwcook: heh, yeah, Alt's taken by my WM, but thanks :)
13:52:58 <dwcook> augur, a directed acyclic graph? Is that just a tree with arbitrarily many branches?
13:53:05 <benzrf> oops i mean 'and a function (a -> b)'
13:53:22 <augur> dwcook: no, its a tree where nodes can have multiple parent nodes
13:53:26 <levi> Too many programs, too few modifier keys.
13:53:30 <dwcook> Ah, right
13:53:48 <levi> Need a space cadet keyboard.
13:54:44 <benzrf> iXeno: (>>=) on Reader is basically similar to (<*>) on Reader with the args flipped, except that instead of a deferred function you have a function to a deferred value
13:54:58 <rocketman> Can I say "what country" or is it "which country"?
13:55:03 <dwcook> rocketman, either
13:55:09 <benzrf> iXeno: in practice you'd usually use ReaderT to smuggle environment values into the middle of a computation
13:55:14 * dwcook makes sure this isn't ##grammar
13:55:51 <iXeno> benzrf: now what is this ask function?
13:56:04 <dwcook> (ReaderT r m a is approximately r -> m a)
13:56:08 <joshc> levi: or perhaps a foot pedal :)
13:56:25 <dwcook> ("approximately" in that it's only nominally different, afair)
13:56:53 <benzrf> iXeno: ask :: (r -> r)
13:57:09 <benzrf> iXeno: ask directly returns the environment
13:57:14 <benzrf> it's really just id
13:57:27 <kosmikus> ocharles: no, currently not
13:57:28 <benzrf> except that it's also defined for ReaderT
13:57:38 <benzrf> so you can use it in a stack
13:57:49 <ocharles> kosmikus: ah, ok
13:57:54 <kosmikus> ocharles: something like Generic1 can be done, but that wasn't a priority; and I'd rather have a more general solution anyway
13:57:54 <snyp> lens library is failing to build...
13:58:11 <ocharles> still trying to get someone to write a generics library that lets me derive functor for work's free monad functor (gadt with type class constrainst) :P
13:59:44 <kosmikus> ocharles: :) I'm happy to take another look. Making that the priority may well lead to results.
14:00:03 <dwcook> ask :: (Monad m) => r -> m r -- Huh, that looks a lot like return :)
14:00:16 <ocharles> Sure, let me know if there's anything that would help you
14:00:35 <ocharles> i can post the functor in question if you want to see it
14:01:12 <ocharles> I wonder if GHC 7.8.3 has the patch that improves -XDeriveFunctor. Feel that might be a 7.10 feature
14:01:47 <iXeno> benzrf: so, after you've made a reader, how do you get out of the reader again?
14:04:09 <jfischoff_> levi: running it with strace I get a different error: (InternalIOException epollControl: invalid argument (Bad file descriptor))
14:05:01 <jfischoff_> levi: not sure what to make of the strace spew actually
14:07:59 <ajcoppa> :t runReader
14:08:00 <lambdabot> Reader r a -> r -> a
14:08:01 <ajcoppa> :t runReaderT
14:08:02 <lambdabot> ReaderT r m a -> r -> m a
14:08:04 <snyp> lens is failing to build what do i do?
14:08:20 <ajcoppa> iXeno: i'm assuming that's what you mean by "get out of the reader again"?
14:09:13 <snyp> some kind of version problem it seems: http://paste.debian.net/108789/
14:10:02 <snyp>  Expected type: attoparsec-0.11.3.4:Data.Attoparsec.ByteString.Internal.Parser                     Value     Actual type: attoparsec-0.12.1.0:Data.Attoparsec.ByteString.Internal.Parser
14:10:15 <snyp> how to get around it?
14:10:17 <kini> snyp: did you try with a fresh sandbox? (if that's a viable option for you)
14:10:49 <snyp> kini, i see. can't cabal just update(reinstall) the current attoparsec?
14:11:33 <kini> I don't know the specifics but I get the feeling that it's usually easier to just blow away the sandbox and start over, than to upgrade things within it
14:11:39 <snyp> maybe i should remove all the packages and install all again
14:11:41 <snyp> hmmmmm
14:11:43 <nisstyre> cabal doesn't handle reinstalling well
14:11:49 <bitemyapp> snyp: kill sandbox, recreate cabal, install sandbox.
14:11:53 <kini> if you're using a sandbox, you can just do `cabal sandbox delete` and then `cabal sandbox init`
14:12:03 <bitemyapp> cabal install -j9001
14:12:14 <nisstyre> sandboxes were created to limit the collateral damage in fixing cabal
14:12:14 <iXeno> ajcoppa: more or less
14:12:19 <kini> that's why sandboxes are nice :P if you were cabal installing into your homedir, it would be messier to get rid of the packages you have
14:12:22 <kini> yeah, what nisstyre said
14:12:29 <snyp> nisstyre, i see.
14:14:46 <jml> GetOpt seems to require '=' in long arguments (e.g. --foo=bar works but '--foo bar' does not). Is this correct?
14:14:53 <redding> Any reason why I should be able to get hmatrix to run fine in ghci but fails during linking when I try to compile it with GHC?
14:19:00 <redding> For instance, I can get this to load in ghci without problem http://lpaste.net/107148
14:19:35 <peddie> redding: can you add the error message to your paste?
14:19:44 <RyanGlScott> I'm having trouble using c2hs. I have a simple C function:
14:19:47 <RyanGlScott> void wat(foo_t quux) {
14:19:48 <RyanGlScott>     quux->bar = 42;
14:19:50 <RyanGlScott> }
14:19:58 <RyanGlScott> And then corresponding Haskell code:
14:20:03 <RyanGlScott> {#pointer foo_t as Foo newtype#}
14:20:06 <RyanGlScott> {#fun unsafe wat as ^ {`Foo` id} -> `()'#}
14:20:16 <RyanGlScott> But this gives me a syntax error:
14:20:22 <RyanGlScott> src/Internal.chs:21: (column 41) [ERROR]  >>> Syntax error!
14:20:23 <redding> peddie: http://lpaste.net/2973320187308146688
14:20:24 <RyanGlScott>   The phrase `#}' is not allowed here.
14:20:28 <redding> Im on OSX btw
14:20:41 <redding> whoops
14:20:48 <redding> i put two messages in my paste
14:20:57 <RyanGlScott> Oh wait, I see what I did
14:21:13 <RyanGlScott> `Foo` should actually be `Foo' (the backticks did me in)
14:21:45 <geekosaur> redding: you have stuff from multiple sources
14:22:29 <redding> geekosaur: meaning conflicting installations of something...?
14:22:41 <geekosaur> your ghc is the "official" haskell platform package. whatever you're linking in is built with libraries from either macports or homebrew
14:22:52 <geekosaur> which has a later iconv and different symbol names
14:23:15 <geekosaur> and is forcing that iconv library to be used, so then ghc fails because it wants apple's and not the other one
14:23:51 <geekosaur> if you're going to be using libraries from homebrew with ghc, install haskell platform from homebrew and remove the other one
14:24:03 <geekosaur> (or wherever you're getting libs from)
14:24:35 <redding> geekosaur: well I installed gsl from homebrew because it is required for hmatrix
14:24:50 <geekosaur> then you must use ghc from homebrew
14:24:54 <geekosaur> no way around this
14:25:03 <redding> hmm
14:25:16 <codygman> I thought I understood what was wrong here and that things needed to be lifted into wd, but I was wrong and I don't know what this error means: http://lpaste.net/107149
14:25:24 <snyp> when you say remove the sandbox, you only meant removing cabal.sandbox.config and .cabal-sandbox/ right? and then cabal sandbox init in the directory..
14:25:26 <redding> how else would I install gsl that would avoid thi problem?
14:26:25 <geekosaur> redding: install it from source yourself *and move /usr/local out of the way while configuring/building so it only sees apple libraries*
14:26:34 <quchen> snyp: You can also use `cabal sandbox delete`, that's the automated way of doing what you described.
14:26:58 <snyp> quchen, i see.
14:27:35 <redding> geekosaur: okay so just so I am crystal clear, I should reinstall ghc from homebrew
14:28:03 <geekosaur> that ios the easiest solution if you're going to keep using homebrew, yes
14:28:24 <redding> Should I not use homebrew?
14:28:37 <geekosaur> you have to move /usr/local out of the way if you're building your own stuff because everything looks there by default
14:28:56 <redding> Also, why isn't this a problem when using ghci?
14:29:56 <geekosaur> ghci from haskell platform uses its own linker and is probably resolving each one to its appropriate iconv library. which may work as long as nothing actually tries to use it
14:30:02 <geekosaur> but can lead to core dumps
14:30:29 <geekosaur> (this behavior changes in 7.8)
14:31:06 <redding> so going forward, does this mean I should avoid using the Haskell Platform for future releases?
14:31:45 <geekosaur> ...
14:31:48 <redding> ...
14:32:00 <geekosaur> I take it you took my last comment as saying it's the platform's fault
14:32:07 <redding> yeah
14:32:09 <geekosaur> when what I actually said is that ghci will ALSO not work in 7.8
14:32:10 <redding> i did
14:32:13 <redding> no
14:32:29 <geekosaur> because ghci is breaking the rules in a very risky way in 7.6 and earlier
14:32:45 <geekosaur> and can lead to programs dumping core
14:32:59 <redding> I took it that ghc that comes with the Haskell Platform will run into the problems with iconv.
14:33:04 <geekosaur> no
14:33:16 <redding> and that I should install from homebrew instead
14:33:21 <geekosaur> if you install from homebrew you will be installing the haskell platform from homebrew
14:33:27 <redding> ah
14:33:51 <geekosaur> what doesn't work here is mixing a ghc built against apple libraries with modules built against non-apple libraries
14:34:05 <geekosaur> solution: build everything against the same libraries
14:34:19 <redding> ok
14:34:19 <benzrf> blugh blugh
14:34:22 <benzrf> ok
14:34:33 <benzrf> Cont r a -> (a -> Cont r b) -> Cont r b
14:34:49 <benzrf> join is
14:34:52 <redding> well thanks for your patience :) I must get going though... You've been a lot of hep
14:34:53 <benzrf> Cont r (Cont r a)
14:34:54 <redding> help
14:35:21 <benzrf> something that provides something that provides a's to callsbacks
14:35:27 <benzrf> becomes something that provides a's to allbacks
14:35:29 <benzrf> *callbacks
14:35:47 <snyp> quchen, trying to install lens in the sandbox seems to conflict with some globally installed packages.
14:35:50 <snyp> not sure why this is happening
14:35:52 <snyp> even if i am inside a sandbox
14:36:03 <snyp> (sorry got disconnected)
14:36:07 <tnks> thoughtpolice: who manages Haskell.org?
14:36:12 <benzrf> it takes a callback and gives the callback something that takes a callback and gives the callback a's
14:36:26 <benzrf> so...
14:36:39 <benzrf> let's say
14:36:53 <benzrf> \callback callback 1 ++ callback 2 ++ callback 3
14:36:59 <benzrf> or rather
14:37:10 <benzrf> @let cont_1 \callback callback 1 ++ callback 2 ++ callback 3
14:37:10 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:37:12 <benzrf> @let cont_1 = \callback callback 1 ++ callback 2 ++ callback 3
14:37:12 <lambdabot>  Parse failed: Parse error: ++
14:37:19 <benzrf> oh forgot a ->
14:37:24 <benzrf> @let cont_1 = \callback -> callback 1 ++ callback 2 ++ callback 3
14:37:26 <lambdabot>  Defined.
14:37:33 <benzrf> :t cont_1
14:37:34 <lambdabot> Num a1 => (a1 -> [a]) -> [a]
14:37:36 <kini> so I'm looking at the haskell wiki page on the Functor-Applicative-Monad proposal http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Future-proofing_current_code
14:37:36 <kini> I guess I don't really understand what's going on here. Will all code in the future have three instance declarations instead of one when someone wants to define a monad?
14:37:39 <benzrf> OK
14:37:49 <benzrf> kini: if it doesnt already, youre doing it wrong
14:37:59 <thoughtpolice> tnks: we do, over in #haskell-infrastructure
14:38:02 <thoughtpolice> there is a small team of admins
14:38:04 <quchen> kini: Yes, that's how it's going to be in the future.
14:38:08 <dwcook> kini, note that in many cases Functor can be derived automatically using the DeriveFunctor extension.
14:38:29 <kini> why can't both Functor and Applicative be derived automatically in some way?
14:38:44 <dwcook> kini, e.g., list has at least two valid Applicative instances
14:39:07 <quchen> kini: Semi-automatically, you can define a Monad and then just write "instance Functor X where fmap = liftM" and you're done.
14:39:22 <quchen> Monad provides you with functions you can use as a default for the Functor/Applicative instances.
14:40:04 <benzrf> @unmtl Cont r (Cont r a)
14:40:05 <lambdabot> ((Cont r a) -> r) -> r
14:40:05 <dwcook> instance Functor F where { fmap = liftA } ; instance Applicative F where { pure = return ; (<*>) = ap } ; instance Monad F where …
14:40:23 <benzrf> dang it lambdabot!
14:40:27 <benzrf> @unmtl Cont r a
14:40:27 <lambdabot> (a -> r) -> r
14:40:29 <dwcook> (either liftA or liftM will serve if it's a Monad but liftA will work even with just Applicative)
14:40:42 <benzrf> (((a -> r) -> r) -> r) -> r
14:40:47 <benzrf> geez
14:40:57 <simcity2000> it's not always bad to write a couple of lines, anyway
14:41:15 <kini> I assume the actual Monad typeclass is now going to have "class Applicative m => Monad m where", right? Is the default implementation of return going to be in terms of pure, for example?
14:41:23 <simcity2000> when everything is implicit sometimes it can be very difficult to know what's going on underneath
14:41:39 <benzrf> @let cont_2 = \callback -> zipWith (+) (callback 4) (callback 3)
14:41:42 <lambdabot>  Defined.
14:41:43 <kini> In which case, instead of defining return and bind, I'd just define pure and bind?
14:41:53 <benzrf> @let cont_n = \callback -> callback cont_1 ++ callback cont_2
14:41:54 <lambdabot>  Defined.
14:41:55 <quchen> kini: Yes. "join" is maybe also added to the mix. (Any updates on that, thoughtpolice?)
14:41:57 <benzrf> :t cont_n
14:41:58 <lambdabot> (Num a2, Num a1) => (((a2 -> [a1]) -> [a1]) -> [a]) -> [a]
14:42:00 <dwcook> kini, alternatively, join, pure, and fmap will suffice
14:42:39 <thoughtpolice> 'join' will be left out of 'monad' for now due to a bad interaction with roles. this will probably be fixed later.
14:42:41 <benzrf> @let cont_n :: (((Int -> [Int]) -> [Int]) -> [Int]) -> [Int]
14:42:42 <lambdabot>  Defined.
14:42:44 * hackagebot codex 0.1.0.1 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.1 (aloiscochard)
14:42:45 <benzrf> thoughtpolice: roles?
14:42:51 <benzrf> :t cont_n
14:42:52 <lambdabot> (((Int -> [Int]) -> [Int]) -> [Int]) -> [Int]
14:43:01 <thoughtpolice> otherwise, AMP is basically as it says in the proposal, modulo that one sticky bit
14:43:08 <snyp> Someone help please. Even inside sandbox, cabal install --only-dependecies clashes wtih global packages.
14:43:26 <thoughtpolice> benzrf: it's too annoying to go into here now. but basically we need to keep 'join' out of Monad so that GeneralizedNewtypeDeriving over Monad still works
14:43:27 <k00mi> dwcook: I'm pretty sure there can be more than one Traversable instance for a type, yet DeriveTraversable exists
14:43:39 <thoughtpolice> we know what the problem is; the current Roles mechanism isn't powerful enough to fix it, but it will happen.
14:43:41 <kini> snyp: one solution is to not install the platform at all, just ghc (that's what I did and it works well)
14:43:52 <kini> then you don't have many global packages to clash with
14:44:08 <kini> and the ones that you do have are built into ghc so you couldn't use a different version of them in the sandbox anyway
14:44:12 <kini> (afaik)
14:44:47 <snyp> kini, yeah, but why would it clash with global packages anyway?
14:45:02 <kini> dunno lol
14:45:21 <benzrf> @src Cont (>>=)
14:45:21 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
14:45:23 <benzrf> jesus
14:45:30 <benzrf> :t runCont
14:45:30 <lambdabot> Cont r a -> (a -> r) -> r
14:45:51 <snyp> i was using the only ghc approach before. but resorted to using arch-haskell repository because for package management.
14:46:15 <rwbarton> k00mi: yes. but also there can be more than one Ord instance, yet deriving Ord picks an "obvious" one
14:46:15 <bb010g> Sorry about the spam earlier. I was using Kiwi because I was trying to be quick, and it can be weird sometimes... anyhow, in my normal client. If anyone responded earlier, apologies on not catching it.
14:46:19 <bb010g> Type algebra question: you have data List x = Cons x (List x) | Nil === L(x) = x*L(x)+1 = 1+x*L(x). Expanded, L(x) = 1+x+x^2+x^3*L(x) = 1+x+x^2+x^3+x^4... Let F(x) = L(x) - 1 = -1 + L(x). Then F(x) = -1 + 1 + x + x^2 + x^3... = x + x^2 + x^3... which means a Foo x type would have either an x or the product of x & x or... However, "subtracting" 1 from the
14:46:19 <bb010g> List data declaration would give Foo x = Foo x (Foo x) which would make Foo x a stream and be F(x) = x^∞ = x*x*x*x*x*x... = x*x^2*x^3... = x*F(x). So I'm seeing that Foo is both infinite and stoppable. Also, F(x) = x*F(x); x = F(x)/F(x) = 1. I'm confused.
14:46:38 <snyp> also to make sublimehaskell work, it would require some global packages...
14:46:39 <dfeuer> The `product` function doesn't shortcut zeros. Sometimes it can't because of floating point and other very badly behaved pseudo-instances of Num. Is there a way to write a product function that shortcuts when given well-behaved numbers like Integers and Rationals?
14:47:44 * hackagebot github-types 0.1.0.2 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.2 (wereHamster)
14:49:20 <johnw> is wereHamster here?
14:49:52 <k00mi> rwbarton: which is why I picked a less obviously ambiguous class
14:51:36 <codygman> Could a list of " :: Element"  wrapped in a monad show up as type error like "Expected type: [Element] Actual Type: [[Element]]"?
14:52:22 <quchen> dfeuer: You can write that yourself, http://lpaste.net/107152
14:52:23 <k00mi> rwbarton: my point is that "several possible instances exist" does not explain why no extension to derive an instance exists
14:52:50 <quchen> dfeuer: … and then constrain the type the way you want it. Note that this uses (== 0) internally.
14:53:10 <rwbarton> right
14:53:24 <rwbarton> the question is whether there is an "obvious" instance
14:53:26 <bb010g> codygman: If that monad was List, then yes.
14:53:48 <quchen> dfeuer: Woops, there's a mistake in the last line, that "1" should be a "p"
14:54:00 <rwbarton> that applies in reasonable generality
14:54:06 <bb010g> Or it could be "Expected type: [Element] Actual Type: Maybe [Element]". Any monad.
14:54:31 <_Vi> How to avoid verbose "import qualified", especially in "ghci"? Can I alias is to "iq" or something?
14:54:35 <codygman> bb010g: Thanks. I believe that's the problem I'm dealing iwth.
14:54:58 <bergey> johnw: luite said you might have a Nix derivation for GHCJS.  Is that somewhere public?
14:55:13 <johnw> bergey: github.com/jwiegley/nixpkgs, the branch is ghcjs2
14:55:22 <bergey> johnw: Thanks!
14:55:22 <johnw> it doesn't build at the moment
14:55:23 <dfeuer> Quchen, I meant a function that would shortcut well-behaved numbers and not shortcut ill-behaved ones. It's probably not possible.
14:55:26 <johnw> but assistance is welcome :)
14:55:32 <bergey> sounds good :)
14:55:43 <johnw> we (myself and ryantrinkle) just upgrade it, and haven't fixed why the upgrade broke things
14:56:20 <quchen> dfeuer: There is no "type-case" that lets you choose a different function based on whether it's well-behaved or not. You could emulate that behaviour by writing a "productable" class though. But then you have to write your own instances for every type.
14:56:38 <quchen> With "Prelude.product" as default implementation the latter part could be easy though.
14:59:17 <benzrf> :t product
14:59:17 <lambdabot> Num a => [a] -> a
14:59:21 <benzrf> oh
14:59:27 <dfeuer> That's not a terrible approach, quchen.
15:00:12 <quchen> By the way, does Float not obey 0*x = 0?
15:00:42 <quchen> Oh, the infinities, silly me
15:00:59 <dfeuer> quchen, 0*+inf and 0*NaN
15:01:08 <dfeuer> And 0*-inf
15:01:13 <dfeuer> And commuting.
15:01:22 <donri> @check \x -> 0 * x == (0 :: Float)
15:01:24 <lambdabot>  +++ OK, passed 100 tests.
15:01:47 <dfeuer> > 0*(1/0)
15:01:47 <kini> anyone know where preprocessor definitions like APPLICATIVE_IN_BASE are documented?
15:01:50 <lambdabot>  can't find file: L.hs
15:02:01 <quchen> > 0*(1/0)
15:02:03 <lambdabot>  NaN
15:02:06 <kini> or are they not documented? google can't find any hits for "APPLICATIVE_IN_BASE" not preceded by "#ifdef" (i.e. hits in source code)
15:02:32 <donri> kini: is that not defined per project?
15:02:40 <donri> such as in cabal cpp-options
15:03:06 <kini> donri: hmm, not that I can see here...
15:03:31 <kini> I'm looking at the blaze-builder library
15:05:30 <donri> could be leftover from earlier version
15:05:44 <kini> I grepped the entirety of `git log -p` and found nothing that wasn't preceded by #ifdef, lol
15:06:12 <kini> maybe the author saw this variable in other code and didn't realize they had to define it themselves
15:06:27 <kini> which would explain why it's producing warnings on ghc 7.8.2 where applicative is in fact in base (afaik)
15:06:40 <donri> you know about git grep right
15:07:07 <kini> yes but I wanted to also find what commit it was introduced in if I did find it
15:08:01 <kini> actually come to think of it, does git grep even search history?
15:09:54 <ReinH> kini: if you want to search the contents of files you need to use the "pickaxe", which is the -S option in `git log -S', which takes a string parameter and searches the history for commits that introduce or remove that string
15:10:29 <kini> ReinH: cool, thanks!
15:10:35 <ReinH> np
15:11:16 <kini> `git log -p` and then grepping in the pager does work, but can be slow if there's a lot of irrelevant commits
15:11:25 <kini> `git log -S term -p` seems like a better approach
15:15:22 <ReinH> Yep.
15:15:38 <sveit> i am trying to do some "dirty" profiling in ghci. Is there a way to force a list to be completely evaluated?
15:16:02 <quchen> sveit: deepseq?
15:16:11 <ReinH> sveit: You might as well just use criterion, it's very easy.
15:16:31 <ReinH> There are lots of ways to do profiling wrong, especially in a non-strict language.
15:17:34 <sveit> well i'm running about 10 functions on a single data structure and i want to see which one is taking 2 minutes :)
15:17:49 * hackagebot github-types 0.1.0.3 - Type definitions for objects used by the GitHub v3 API  http://hackage.haskell.org/package/github-types-0.1.0.3 (wereHamster)
15:20:02 <ReinH> sveit: you could just enable RTS profiling with ghc -prof -fprof-auto -rtsopts and look at the report
15:20:21 <ReinH> if a particular evaluation is taking 2 minutes it should be pretty obvious
15:20:31 <Peaker> Is there a way to avoid the need to pass +RTS -N to make use of multicore, while not allowing all RTS opts (security issue)?
15:21:00 <ReinH> (you have to then run with ./Foo +RTS -p)
15:21:09 <quchen> Peaker: You can increase the number of capabilities at runtime, can't you? As long as you've compiled with -threaded
15:21:26 <thoughtpolice> only in GHC 7.8 can you do that
15:21:30 <quchen> setNumCapabilities is the function, if I recall correctly
15:21:45 <thoughtpolice> or, well, *increasing* may work in 7.6, actually
15:21:47 <quchen> thoughtpolice: Are you sure? I thought 7.8 only added decreasing the number.
15:21:48 <quchen> Right.
15:22:10 <thoughtpolice> Peaker: ghc -O2 -with-rtsopts=-N foo.hs -o foo.exe
15:22:22 <glguy> Peaker: The security issue is particular to it being used in CGI context or setuid or similar, but not an issue in general.
15:22:25 <Peaker> quchen: ah, thanks
15:22:26 <thoughtpolice> + '-threaded' obviously
15:22:38 <quchen> Oh, you can bake in RTS options? Interesting!
15:22:39 <Peaker> thoughtpolice: that doesn't require -rtsopts?
15:23:33 <Azulflame> What is the preferred (or most common) IDE for haskell? Does anyone here know?
15:23:45 <zomg> Vim and Emacs probably
15:26:13 <thoughtpolice> Peaker: it might, I can't remember the specifics. either way, -rtsopts is only an issue in the CGI/setuid context as glguy said, which may or may not be a concern for you.
15:26:28 <thoughtpolice> (considering a setuid program is already a big red flag, you probably have other things to worry about)
15:29:16 <Peaker> thoughtpolice: well, I dislike the program overwriting any cmdline-given file/etc, or generally exposing more power than needed in the CLI
15:30:01 <Peaker> +RTS -N1 being the default and -threaded being off by default makes GHC annoying for actual multicore stuff, especially toys
15:30:03 <kini> Azulflame: as zomg said, emacs and vim probably
15:30:20 <kini> there's also an eclipsefp thing for eclipse http://eclipsefp.github.io/
15:30:40 <kini> and leksah, an IDE written in haskell (kind of outdated (?)) http://leksah.org/
15:31:00 <kini> there's also this commercial IDE from fpcomplete: https://www.fpcomplete.com/business/haskell-center/overview/
15:31:21 <kini> and of course the Yi editor http://www.haskell.org/haskellwiki/Yi
15:31:28 <Azulflame> Got it. Thanks. Is vi only executable lin terminal, or has someone convinced it to run in it's own GUI (well, that kind of defeats the purpose, doesn't it?)?
15:31:33 <kini> dunno how many people use those last four though. Everyone I know uses emacs or vim.
15:31:44 <kini> vim has the gvim graphical version
15:31:56 <kini> emacs has a graphical version by default, `emacs -nw` for a terminal version of emacs if you want
15:31:57 <glguy> Azulflame: There is gvim (gtk) which runs in windows/linux and an OS X port of that, macvim
15:32:05 <gfixler> kini: lucky - no one I know uses either :(
15:32:06 <ij> Azulflame, It might come off as a surprise, text is usually not graphical.
15:32:18 <kini> gfixler: I meant every haskell programmer I know, lol
15:32:28 <kini> though most other programmers I know seem to use emacs or vim too...
15:32:32 <gfixler> kini: I only know one of those
15:32:39 <Azulflame> I'm downloading GNOME right now (to run as an alternate to KDE and Cinnamon on openSUSE), but I'll install EMACS as soon as it finishes and take a look
15:32:45 <gfixler> (he's the one who told me about it late last year)
15:33:07 <codygman> Can anyone look at my wrong attempts here to make my textElems function work and tell me what things I should learn about/what I don't understand? http://lpaste.net/107154
15:36:04 <ccapndave> IntelliJ has an alright plugin too
15:36:08 <Azulflame> tf? "Downloading Packages... (Downloaded 280 of 105 packages)" And still only 53% through
15:36:21 <ccapndave> Good if you are using it for other languages anyway so you don't have to go back and forth
15:36:22 <glguy> codygman: How about this? http://lpaste.net/107154
15:37:30 <Peaker> some progress with Lamdu's new type system today.. here's some text output: http://lpaste.net/107156
15:38:11 <bb010g> Is there an extension for type synonym instances?
15:38:12 <Peaker> structural record system with some row polymorphism thrown in, including field-constraints, all seems to work :)
15:38:26 <bb010g> I'm not seeing one for some reason, but I think there is.
15:38:51 <glguy> bb010g: Do you know you can tab complete in GHCI? Type: :set -XT<TAB>
15:39:10 <glguy> -X for language extension and then T because it starts with a T :)
15:39:26 <bb010g> glguy: Thanks; didn't know tab completion worked on those. :)
15:39:37 <joelteon> was fail added to Monad specifically for list comprehensions?
15:39:48 <quchen> No, for "do" notation.
15:39:56 <quchen> List comprehensions are independent of monads.
15:40:01 <joelteon> oh, that's right.
15:40:46 <kini> in what way does do notation require fail?
15:41:02 <joelteon> > do { x <- Nothing; return x }
15:41:02 <glguy> Pattern matching failure
15:41:03 <lambdabot>  Nothing
15:41:08 <joelteon> wait, that's not right.
15:41:13 <joelteon> > do { Just x <- Nothing; return x }
15:41:15 <glguy> do Just x <- m; return x
15:41:15 <lambdabot>  Nothing
15:41:23 <quchen> do { (x:xs) <- []; return x }
15:41:51 <ion> > runIdentity $ do { 1 <- return 0; return 2 }
15:41:53 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:20
15:42:21 <kini> ah, right
15:42:34 <kini> I did think it had to do with pattern matching, but it didn't occur to me that fail is only relevant to that within a do block
15:42:35 <dwcook> It becomes obvious if you read the desugaring in the report
15:42:48 <dwcook> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
15:43:43 <joelteon> > do { 1 <- return 0; return 1 } :: Either String Int
15:43:44 <kini> I guess pattern matching failures within a do block are actually much safer than pattern matching failures in a let expression
15:43:45 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:6
15:44:09 <dwcook> kini, sometimes. Not every monad has a reasonable fail.
15:44:11 <kini> (if you define fail for your monad in a nice way)
15:44:14 <kini> right
15:44:24 <kini> but I guess with let expressions you don't even have the option (?)
15:44:30 <dwcook> Either a is an example. Where do I get a Left a from?
15:45:01 <kini> point
15:45:12 <kini> (take that as you will :P)
15:45:27 <ReinH> (you don't)
15:45:43 <quchen> Don't use fail, https://github.com/quchen/articles/blob/master/fbut.md#fail
15:46:29 <dwcook> Ick, the table of contents doesn't work if JS is disabled. Most likely Github's fault
15:46:44 <quchen> TOC of what?
15:46:48 <dwcook> What you just linked
15:46:58 <dwcook> I mean the links
15:47:10 <quchen> The TOC is a handwritten list of links
15:47:12 <levi> bmuk: Nice article; looking forward to the rest.
15:47:15 <kini> ReinH: but, but, I thought all types in Haskell were inhabited!
15:47:23 <quchen> Oh, but the scrolling is broken. Hmm.
15:47:32 <dwcook> kini, they are, but we try not to rely on that fact if we can help it :P
15:47:34 <kini> :P
15:48:41 <kini> btw I like this "uninhabited" type https://github.com/ekmett/void/blob/master/src/Data/Void.hs
15:49:12 <dwcook> Yes, it can be handy
15:49:37 <ReinH> initial objects are often handy to have lying around ;)
15:49:43 <kini> I've never used it but just reading this file makes me laugh
15:49:44 <kini> it's so silly :)
15:49:55 <glguy> It's not a joke module, though
15:50:11 <dwcook> kini, would you believe me if I told you it were legitimately useful?
15:50:14 <kini> of course
15:50:20 <ReinH> to be fair, the names are rather funny
15:50:20 <kini> I still find it amusing though :)
15:50:27 <dwcook> Yeah :P
15:50:30 <kini> hell, I find agda code full of "refl" everywhere to be amusing too :P
15:50:33 <kini> and that's obviously useful
15:50:37 <dwcook> What's refl?
15:50:44 <kini> reflexivity of equality
15:50:48 <dwcook> Ah, neat
15:50:59 <kini> basically it's the end of the proof tree where you've reduced an equality proof to something that the typechecker "knows by definition"
15:51:57 <quchen> data Refl a b where refl :: Refl a a?
15:52:06 <kini> so the AST of your proof can end up just having a bunch of copies of the word "refl" at the leaves (the atoms in the expression), all combined together with various operators or functions
15:52:14 <kini> quchen: that's heterogeneous equality, isn't it?
15:52:30 <dwcook> It's kind of like how the usage of id might not be immediately obvious
15:52:39 <dwcook> A function that returns its argument unchanged? Why would I want that?
15:52:53 <ReinH> dwcook: ($) :p
15:52:56 <quchen> The only way to create a Refl is using two equal types, I think that's normal Refl
15:53:08 <dwcook> ReinH, meh, that's mostly useful for notation :P
15:53:13 <quchen> :t [id, ($), ask, local]
15:53:14 <lambdabot> MonadReader (m a) m => [(m a -> m a) -> m a -> m a]
15:53:14 <dwcook> Though you do have a point
15:53:23 <deni> is there a comprehensive list of pragmas in one place somewhere? So when I come across a library that uses like 10+ of those i can look it up?
15:53:24 <ReinH> quchen: yep :)
15:53:50 <quchen> deni: They're all in the GHC manual, that's not very good as an overview though
15:53:52 <ReinH> deni: the GHC manual
15:53:56 <kini> quchen: so as I understand it, refl is the data constructor for the equality type, not a "refl type", right?
15:54:15 <ReinH> deni: https://www.haskell.org/ghc/docs/latest/html/users_guide/ and specifically https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
15:54:41 <ReinH> It doesn't do a very good job of motivating them though
15:54:51 <kini> the question is whether refl is a data constructor for a = a or for a = b (in either case, refl itself must take two definitionally equal arguments)
15:54:52 <kini> so is it "refl a a : a = b" or "refl a a : a = a"?
15:55:07 <kini> as far as I understand it, that question leads to some subtle differences in the theory, but I have no idea what they are
15:55:21 <kini> in the end you're still only going to have actual terms of the form "refl a a", never "refl a b"
15:55:29 <deni> ReinH: quchen yeah that's not good for an overview...and i can never find all of them there
15:55:38 <benzrf> ok so
15:55:40 <deni> posibbly because some of them were added before
15:55:46 <deni> (ie. not in the latest ghc)
15:56:00 <benzrf> is it just me or is the Cont monad sort of like the List monad equipped with a reduction function
15:56:49 <bb010g> How do you tell Haskell which instance to pick for a type? I have a line ```pkgbuildUrl p = mconcat [baseUrl, take 2 p, p, "PKGBUILD"]``` and an instance declaration for FilePath (which pkgbuildUrl is typed to take and return). I tried putting ``` :: FilePath``` at the end, but it didn't help.
15:56:56 <deni> ReinH: quchen also where can i see what the latest report is? i assume it's 2010 but i'm unsure
15:57:00 <kini> also as I understand it, agda and coq have the "refl a a : a = a" type of equality, and idris has the "refl a a : a = b" type of equality... (someone correct me if I'm wrong)
15:57:10 <kini> deni: yes 2010 is the latest language standard
15:57:21 <quchen> deni: It's 2010, yes. Reports come out very infrequently, and there will be a big fuzz around a new release.
15:57:39 <kini> previous one before 2010 was 1998, right?
15:57:42 <quchen> Buzz? Something with many z in it.
15:57:43 <quchen> Yes.
15:58:03 <kini> I think in the 90s the versions were more frequent, and were also numbered as version numbers rather than by years
15:58:27 <deni> yeah i gathered the previous one was 98
15:58:49 <quchen> Haskell 1998 was the first standard, I think. There were previous Haskell versions before that in the developmental stages.
15:58:56 <kini> ah
15:59:07 <quchen> Don't quote me on that though :-)
16:02:09 <levi> benzrf: Have you read much about continuations outside of trying to figure out Cont?
16:03:25 <deni> ReinH: kini quchen tnx
16:03:26 <jle`> bb010g: what happens?
16:03:27 <levi> quchen: Haskell Report 1.0 calls itself a language specification.
16:04:07 <bb010g> jle`: It gives an Overlapping instances error with Monoid [a] and Monoid FilePath
16:04:24 <jle`> bb010g: ah.  well, every type can only have one instance
16:04:35 <jle`> also you can't define instances for type synonyms...which is what FilePath is
16:04:42 <levi> "This report is the official specification of the Haskell language and should be suitable for writing programs and building implementations."
16:05:01 <bb010g> jle`: There's no way to force it? (Also, TypeSynonymInstances)
16:05:08 <levi> From http://www.haskell.org/definition/haskell-report-1.0.ps.gz
16:05:38 <jle`> bb010g: force what?
16:05:48 <jle`> being able to define instances for type synonyms?
16:05:49 <bb010g> jle`: Force it to choose one or the other.
16:06:23 <bb010g> I would think explicit typing would do it, but it doesn't help.
16:06:45 <jle`> you might be able to play some games with undecidable instances/overlapping instances, but...this is usually a result of bad design choices
16:06:58 <jle`> what do you mean by 'explicit typing'?
16:07:01 <kini> whoa http://homotopytypetheory.org/2012/11/21/on-heterogeneous-equality/
16:07:02 <kini> "What is actually going on is that an inhabitant of JMeq_eq_axiom is an anti-Univalence-axiom: it says that the Universe of types is totally-disconnected."
16:07:08 <jle`> type synonyms are all equivalent
16:07:28 <bb010g> jle`: Something like ["foo","bar"] :: [FilePath]
16:07:42 <jle`> FilePath is just a type synonym for String
16:07:50 <jle`> so they are relaly the same type
16:08:02 <jle`> there is no real difference between FilePath and String
16:08:19 <bb010g> I know, but I'd think GHC would see that you want the FilePath instance used because of it. I know it's the same type.
16:08:32 <jle`> but...there are no instances for type synonyms
16:08:42 <jle`> there is no such thing as a FilePath instance...you defined a String instance
16:08:50 <bb010g> I'd suppose a newtype would be the next best thing.
16:09:01 <bb010g> Oh...so it just expands in the instance head?
16:09:02 <jle`> newtype would work, but why not just a foldr?
16:09:22 <jle`> bb010g: yeah, the two things are equivalent; when you try to write an instance for FilePath, you are writing an instance for String
16:09:32 <jle`> type synonyms can't be given instances
16:10:16 <jle`> you can do newtypes, but if you only do this in one place, consider just using a specialized foldr instead of a typeclass-based solution
16:11:03 <jle`> if you need to throw in a FilePath into many different generic monoid methods (besides just the one mconcat), then maybe a newtype would help...but if all you want is mconcat, you can just use a fold.
16:11:57 <jle`> i think there might be a way to trick GHC into using a special [Char] instance over an [a] instance using a couple of extensions...but this really wouldn't be considered good practice
16:13:35 <benzrf> somebody tell my why im wrong already
16:15:30 <benzrf> @ping
16:15:30 <lambdabot> pong
16:17:28 <ReinH> benzrf: ?
16:18:12 <benzrf> <earlier benzrf> is it just me or is the Cont monad sort of like the List monad equipped with a reduction function
16:18:28 <benzrf> *i mean, where each list is equipped with one
16:19:50 <quchen> chrisdone: Congratulations on the new website :-)
16:19:56 <benzrf> @let data KindaLikeCont r a = KLC [a] ([r] -> r)
16:19:57 <lambdabot>  Defined.
16:20:08 <benzrf> :t runCont
16:20:09 <lambdabot> Cont r a -> (a -> r) -> r
16:21:12 <benzrf> @let runKLC (KLC xs r) = r . map ?? xs
16:21:12 <lambdabot>  Parse failed: Ambiguous infix expression
16:21:16 <benzrf> @let runKLC (KLC xs r) = r . (map ?? xs)
16:21:17 <lambdabot>  Defined.
16:21:35 <quchen> Eeek, someone jumped the gun and posted a test build. Nevermind :-(
16:22:15 <benzrf> :t runKLC
16:22:16 <lambdabot> KindaLikeCont c t -> (t -> c) -> c
16:23:02 <benzrf> @let instance Functor (KindaLikeCont r) where fmap f (KLC xs r) = KLC (map f xs)  r
16:23:03 <lambdabot>  Defined.
16:23:19 <levi> benzrf: It's kinda like the Free monad, which is kinda like a list.
16:23:22 <benzrf> hmm
16:23:49 <benzrf> @let instance Applicative (KindaLikeCont r) where (KLC fs r) <*> (KLC fs r') = ...
16:23:49 <lambdabot>  Parse failed: Parse error: ...
16:23:51 <levi> But I wouldn't say it's like the List monad.
16:23:52 <benzrf> hmm
16:24:43 <levi> Cont's bind is just chaining continuation-passing functions.
16:26:00 <levi> benzrf: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
16:26:09 <benzrf> i think i know cps
16:27:23 <wabash> Hi folks.
16:27:31 <wabash> wow this channel has grown by 4x since a few years ago!
16:27:33 <wabash> It's great.
16:27:41 <wabash> I have a general haskell question for you all.
16:27:49 <levi> benzrf: That article does a good job of explaining how CPS relates to the Cont monad and callCC.
16:28:07 <levi> Ask away, wabash.
16:29:34 <wabash> I'm reading about green threads in Haskell. I read that they are distributed over a small number of native threads. So just as an example, say I have an 8 core machine. If my haskell program has... 10,000 greetthreads, does it work like:   I can created 8 native threads, 1 per core, and then haskell runtime distributes the greenthreads across native threads based on say, idleness, etc?
16:30:16 <wabash> It's interesting... contrast to JVM where in linux, the Java threads can run on the native thread lib, 1 to 1 ratio.
16:32:07 <benzrf> fuck my brain is frozen
16:32:08 <levi> By my understanding of GHC's threaded runtime, you're basically right. IIRC the 'OS threads' are called 'capabilities' and the green threads are called 'sparks'.
16:32:18 <wabash> levi: I see, thank you!
16:32:23 <levi> More info can be found here: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
16:32:26 <wabash> levi: What other languages do you know?
16:32:34 <wabash> scheme, cl, etc?
16:32:35 <wabash> scala?
16:32:57 <levi> I know a bit about a whole lot of languages.
16:32:57 <wabash> thanks for the link
16:33:00 <wabash> :)
16:33:34 <levi> I have written small/medium programs in Scheme and CL; just a couple of small ones in Scala.
16:33:35 <benzrf> KLC r (KLC r a) = ([([a], [r] -> r)], [r] -> r)
16:34:03 <levi> Also some programs in F# and OCaml.
16:34:13 <wabash> levi: anything in python etc
16:34:31 <levi> Yeah, I've done some python, lua, javascript, etc.
16:34:49 <wabash> levi: And your opinion on static typing having an effect on coding approaches?
16:35:06 <benzrf> :t \(KLC ks red) aToR -> map (runKLC ?? aToR) ks
16:35:07 <lambdabot> KindaLikeCont t (KindaLikeCont b t1) -> (t1 -> b) -> [b]
16:35:23 <levi> I really like using Haskell/ML-style typed languages.
16:35:35 <wabash> I do too. At least, the idea of it.
16:35:36 <benzrf> :t \(KLC ks red) aToR -> KLC (red (map (runKLC ?? aToR) ks)) red
16:35:37 <lambdabot> KindaLikeCont [a] (KindaLikeCont [a] t) -> (t -> [a]) -> KindaLikeCont [a] a
16:35:58 <wabash> python is frustrating to me sometimes. "What's this function? What's it do? What's it return?" Go to docs every 5 minutes.
16:36:33 <benzrf> join for Cont is
16:36:38 <benzrf> uh
16:37:26 <levi> My work coding is nearly entirely in C.  So, I only do hobby coding intermittently, and sometimes I leave things for a long time.  This absolutely destroys my progress in projects written in dynamically-typed languages and especially in javascript.
16:37:59 <Forgetaboutit> wabash: uh, you can have that in so called "statically" typed languages such as C# as well if you have to work with badly designed APIs
16:38:01 <benzrf> :t \yr -> cont $ \v -> runCont yr (runCont ?? ($v))
16:38:02 <lambdabot> Cont b (Cont b ((a -> b) -> b)) -> Cont b a
16:38:24 <levi> My Haskell projects are relatively easy to pick up again, as the type-level information helps a lot in getting my head around the codebase again.
16:40:08 <wabash> Forgetaboutit: i agree.
16:40:15 <benzrf> :t runCont
16:40:16 <lambdabot> Cont r a -> (a -> r) -> r
16:40:21 <Odoxa> https://www.youtube.com/watch?v=If36R0cNum4
16:40:37 <benzrf> Cont r (Cont r a) -> Cont r a
16:41:09 <wabash> And you can write wholly unmaintable spagehetti code without GOTO, and you can write code with a lot of 3 char mnemonic names for variables in Java instead of assembly, etc.
16:41:58 <gaze__> anyone know when reactive-banana will properly handle garbage collection on switching?
16:42:24 <benzrf> :t \yr -> cont $ \v -> runCont yr (runCont ?? v)
16:42:24 <lambdabot> Cont b (Cont b a) -> Cont b a
16:42:29 <benzrf> motherfucker
16:42:31 <Forgetaboutit> wabash: I didn't intend to assume the worst possible conditions, just speaking from experience of my previous project, sadly
16:43:24 <Forgetaboutit> wabash: What makes me even more sad is that people ostensibly often just don't care about types :(
16:44:39 <peterhil> Yes!!!! I finally got audio capturing with OpenAL working! The problem was with not understanding on how to call a C function that mutates the array data. This helped tremondously: http://dev.stephendiehl.com/hask/#ffi
16:45:06 <wabash> Forgetaboutit: haahahahah. My condolences.  Large team at a fortune 500 company?
16:45:41 <peterhil> Now on to make spectrograms... Anybody happen to know a good BSD or MIT licensed FFT functions?
16:46:23 <peterhil> Best I could find is this: http://nayuki.eigenstate.org/page/free-small-fft-in-multiple-languages
16:47:31 <benzrf> :t \(KLC ks r) aToR -> map (runKLC ?? aToR) ks
16:47:32 <lambdabot> KindaLikeCont t (KindaLikeCont b t1) -> (t1 -> b) -> [b]
16:47:33 <Forgetaboutit> wabash: A smallish team (~10) people in a medium-sized company.  I guess my young age didn't help convincing them.
16:48:20 <benzrf> :t (\(KLC ks r) aToR -> map (runKLC ?? aToR) ks) :: KindaLikeCont r (KindaLikeCont r a) -> (a -> r) -> [r]
16:48:21 <lambdabot> KindaLikeCont r (KindaLikeCont r a) -> (a -> r) -> [r]
16:49:22 <benzrf> :t (\(KLC ks r) aToR -> r (map (runKLC ?? aToR) ks)) :: KindaLikeCont r (KindaLikeCont r a) -> (a -> r) -> r
16:49:23 <lambdabot> KindaLikeCont r (KindaLikeCont r a) -> (a -> r) -> r
16:49:28 <benzrf> hueuh
16:49:29 <Forgetaboutit> wabash: But lots of useless, poorly documented APIs based on `object', `string', and magic integers
16:50:52 <jfischoff_> peterhil: you need to create a sliding window fft to make a spectogram
16:51:48 <benzrf> fuck forget it
16:51:49 <benzrf> @undef
16:51:49 <lambdabot> Undefined.
16:52:03 <benzrf> i was almost definitely operating under mis assumptions anyway
16:55:07 <rasfar> what's best practise for hackage uploads these days? I have something I'd like to share but I'm not sure it belongs in the standard namespace.
16:55:18 <augur> is this true:   forall n :: Bits, n - 1 = flipBits (flipBits n + 1)   ??
16:55:45 <rasfar> was going to adopt a policy to prepend my own top-level prefix, but this seems not to be popular on hackage...
16:56:39 <rasfar> it's nice to expose the haddock API using hackage, otherwise I guess it could just stay on my personal site
16:57:00 <jle`> rasfar: what is it that you want to upload
16:57:22 <bb010g> What can cause "parse error in constructor in data/newtype declaration"?
16:57:39 <wabash> levi: Forgetaboutit: thanks for the discussion
16:58:18 <rasfar> jle`: http://fremissant.net/shape-syb
16:58:35 <jle`> bb010g: probably bad syntax? post your code :)
16:58:44 <rasfar> the API is "much nicer" than that blog, which I foolishly wrote before the lib stabilised
16:58:57 <peterhil> jfischoff_: I know. And found a promising FFT library called ffts on #musicdsp channel at EFnet
16:59:26 <rasfar> it was useful to me, and I'd like to start collecting little things like this someplace, but I'm not sure hackage...
16:59:43 <jfischoff_> peterhil: https://github.com/anthonix/ffts this?
17:00:05 <bb010g> jle`: NVM, forgot to put something in. :)
17:00:36 <peterhil> Yes. That compiles easily on OS X with Apple's gcc. This fork might be easier to compile on Linux and Windows https://github.com/henrygouk/ffts
17:00:50 <rasfar> most people seem to be preferring github these days, until concensus find the code a place in the hackage ecosystem. I don't do github yet; not sure I want to go that way.
17:02:15 <jfischoff_> peterhil: cool. I am interested in having a Haskell spectrogram thing too
17:02:56 <peterhil> I can post some code tomorrow somewhere, if you are interested
17:03:17 <jfischoff_> peterhil: yes please
17:03:34 <jfischoff_> leave a note with lambdabot for me
17:04:45 <jfischoff_> @tell jfischoff leave a message like this
17:04:46 <lambdabot> Consider it noted.
17:05:09 <jfischoff_> peterhil: ^
17:05:15 <rasfar> jle` (and anyone): I'll be online for an hour at least and would value your opinions.
17:06:18 <rasfar> also, should I post to the announce list, or cafe, or neither?
17:06:49 <peterhil> jfishoff_: Ok, I'll leave a note if you're not around
17:08:15 <peterhil> Btw, I was told that the test.c of ffts segfaults on Mavericks
17:08:37 <peterhil> If you're running the tests. But also that is the best documentation there is for now... :-)
17:08:50 <peterhil> The test.c file I mean.
17:13:29 <rasfar> edwardk: may I ask your opinion on whether http://fremissant.net/shape-syb could merit a place on hackage? is there a best-practise about adding to hackage? I was thinking of prepending all uploads with "SAI." to avoid polluting the namespace.
17:13:32 <joelteon> does anyone else have trouble generating documentation for primitive and vector?
17:13:38 <joelteon> It says that Main is defined in every output file
17:14:05 <rasfar> (if you're too busy never mind of course)
17:20:11 <rasfar> I've added a link to the Haddock API pages too.
17:22:01 <rasfar> (if you reload the URL given above it's near the top of the page)
17:24:53 <prototrout> 2310
17:27:26 <shlevy> Is there a generally recommended set of ghc-options for libraries?
17:27:51 <shlevy> I'm guessing -Wall -threaded is a good start but I don't know if there are any best practices
17:29:23 <glguy> shlevy: "-threaded" is for when you're linking your executable
17:29:38 <shlevy> glguy: Doesn't affect shared libraries?
17:29:40 <shlevy> OK
17:30:56 <platz> parconc shows running ghc executables with opts for number of processors.  is there a way to bake that info in, or dynamically figure out the right params in-program?
17:31:15 <platz> so that users recieving binaries wouldn't have to supply command line args
17:31:31 <platz> just so that multi-threading works right on their machines
17:32:50 <geekosaur> platz: no need to figure it yourself; -with-rtsopts=-N
17:33:06 <geekosaur> (-N with no number uses the number of cores)
17:33:12 <shlevy> snoyberg: Assuming 'release' isn't called, does runResourceT run the registered actions in opposite order of registration?
17:33:57 <platz> geekosaur: that is done at compile time?
17:34:02 <geekosaur> yes
17:34:09 <platz> thanks
17:34:09 <geekosaur> and specifies default runtime options
17:34:31 <geekosaur> users can still override (at least if built with -rtsopts)
17:34:42 <pqmodn> how is type inference implemented for STLC, given it doesn't have polymorphic terms? what can be done for terms like (\x. x) -- assuming you have more than one ground type, like int, char, etc?
17:35:23 <pqmodn> i think everything i've read assumed a single ground type '*', so (\x. x) has the type * -> *. but what options exist if you have more than *?
17:37:19 <joelteon> how do I get the build logs from hackage?
17:38:33 <shlevy> How can I temporarily suspend all other active threads?
17:40:02 <lfairy> shlevy: you can build a lock using MVar
17:40:13 <shlevy> lfairy: I can't assume cooperation here
17:40:14 <lfairy> I don't think GHC has a dedicated suspend thing
17:40:57 <shlevy> lfairy: I'm connecting to a unix socket in a library, I'm assuming Network.Socket has a 108 character limitation for socket paths so I want to change directory to the socket dir if the path is too long
17:41:17 <shlevy> But chdir is process wide, so I want to make sure everything else pauses while the directory is changed
17:42:04 <lfairy> shlevy: have you tested to see if there is a limitation?
17:44:25 <shlevy> lfairy: Just checked, it calls socket(2) under the hood which has the limitation on POSIX
17:44:44 <shlevy> erm, connect(2) I mean
17:45:43 <triliyn> pqmodn: I think in sltc, you don't have polymorphic lambda abstraction -- you can't just say \x. x, it has to be \x : T. x
17:46:11 <triliyn> *stlc
17:46:46 <pqmodn> triliyn: right. suppose i want to translate untyped lambda calculus to STLC (when possible) using inference, though?
17:47:04 <pqmodn> sorry, i worded my original question weirdly
17:47:06 <shlevy> lfairy: Actually it's even worse than that :D "Applications should not assume a particular length for sun_path or assume that it can hold {_POSIX_PATH_MAX} bytes (256)."
17:47:12 <triliyn> hmm, not sure about that
17:47:25 <shlevy> lfairy: Guess I should just hope the path is short enough
17:47:36 <lfairy> shlevy: can you control where the path is?
17:47:51 <shlevy> lfairy: Nope, it's a parameter
17:48:04 * hackagebot persistent-mongoDB 1.4.1.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.1.1 (GregWeber)
17:48:20 <shlevy> For now I'll just hope it's short enough and if any users ever hit an error I can see about making it more flexible
17:48:22 <lfairy> then why not chuck an error on a parameter that's too long?
17:48:42 <shlevy> I'm assuming (hoping?) connect will do that for me
17:48:54 <shlevy> As I don't actually know how long "too long" is portably
17:49:30 <shlevy> Unless I can access sizeof(addr.sun_path) somehow
17:49:41 <shlevy> sockaddr_un.sun_path
17:50:01 <lfairy> you could always make it in /tmp/$hash
17:50:06 <lfairy> since hashes have a fixed length
17:51:08 <shlevy> lfairy: The library is a client of a server the user may not control
17:51:26 <shlevy> lfairy: But I'm probably being overly defensive here
17:55:38 <lfairy> shlevy: meh. worse is better
17:57:00 <jle`> rasfar: i don't see why not :) if it seems like general-enough functionality that multiple people could take advantage of
17:57:32 <rasfar> thank you for responding jle`, I was beginning to despond :)
17:57:44 <jle`> despond no more!
17:58:11 <rasfar> the logical place for it is Data.Generics.Shape.SYB or Data.Shape.SYB, but I thought that would be a bit brash
17:58:22 <rasfar> so was thinking of prepending "SAI." to all my uploads in future
17:58:47 <rasfar> is that frowned upon in hackage though?
18:01:00 <rasfar> i find it delightfully strange that there's not more negative pressure against "spurious contributions" on hackage
18:01:11 <rasfar> cabal update takes quite a while
18:02:03 <jollygoood> in what haskell version will we be able to give same field to different types?
18:02:08 <lfairy> rasfar: computing power grows exponentially, but packages are only linear :)
18:02:10 <jollygoood> same field name*
18:03:44 <rasfar> jollygoood: http://www.well-typed.com/blog/84/ and http://www.reddit.com/r/haskell/comments/1rpte3/explanation_of_the_new_haskell_records_extension/ -- sounds like it's in HEAD only -- is this what you mean?
18:03:45 <lfairy> hackage is kind of a free-for-all mosh pit... stability and stuff is the responsibility of distro maintainers
18:04:07 <rasfar> lfairy: hee hee
18:05:04 <jollygoood> rasfar yes thats it
18:05:23 <rasfar> I've often wanted it, too; looking forward to that!
18:05:33 <jollygoood> will that make it to the GHC that will be used for the next haskell platform?
18:06:05 <rasfar> yes surely
18:06:18 <shlevy> Are there any good libraries for buffered reads/writes to (unix) sockets?
18:06:34 <rasfar> er, unless 7.8.1r2 is already determined to be the GHC in the next Platform...
18:06:54 <rasfar> I'm going to avoid Platform in my next clean install, and use sandboxes for EVERYTHING
18:07:07 <rasfar> (except global documentation base if possible)
18:07:40 <jollygoood> cabal sandboxes? haven't tried that yet
18:08:05 <rasfar> jollygoood, they're actually very easy and effective
18:08:31 <lfairy> yeah, cabal sandbox init, then everything Just Works
18:08:37 <rasfar> cabal init && <edit your .cabal file> && cabal sandbox init && cabal install --only-dependencies && cabal install
18:09:13 <shlevy> Ah there's socketToHandle, cool
18:09:44 <jollygoood> if I understood it right that will download cabal libraries for each project, and not to a global cabal space like cabal install usually does?
18:09:57 <rasfar> jollygoood: then everything is installed in the sandbox (i.e. under the current directory)
18:10:34 <rasfar> yes. / but it will still use your local (~/.cabal/packages/...) source repo, in case you've already downloaded the deps
18:10:38 <jollygoood> what about ghci though? i often load modules in ghci and play with various functions
18:11:22 <jollygoood> s/often/always
18:12:27 <rasfar> I just started using ghci myself, and it works ... but I find i need to give a -package-db=<sandbox-dir>/.cabal-sandbox/i386-linux-ghc-7.8.1-packages.conf.d or whatever
18:12:36 <creichert> cabal repl
18:12:41 <rasfar> you can also run ghc using "cabal exec" if you have a newer version
18:13:02 <rasfar> cabal exec -- ghci <usual invokation opts/args>
18:13:26 <rasfar> creichert: I come accross cabal repl but never tried it; is it tied in to ghci?
18:13:58 <creichert> rasfar: it opens ghci session for given cabal target
18:14:42 <rasfar> (trying it...)
18:15:42 <rasfar> that works very nicely, thanks creichert
18:15:59 <creichert> good. it's very handy
18:20:52 <creichert> rasfar: you might also like `cabal run`
18:23:10 <rasfar> the only thing I don't like about "cabal *" is, I use a fairly underpowered machine, and cabal seems to be quite slow to start doing things.
18:23:50 <rasfar> I prefer plain make to determine if any rebuild is needed, and if not, the executable is lauched from the shell script that calls make.
18:24:02 <rasfar> then, if rebuild is needed, try to use ghc --make if at all possible.
18:24:17 <rasfar> as a last resort, cabal configure && cabal build !
18:24:22 <rasfar> (or cabal run)
18:25:28 <rasfar> cabal exec is quite fast, and helps eliminate a lot of fuss getting the options right for a raw ghc invocation (no hiding of global packages etc.)
18:26:13 <orzo> hiya
18:26:18 <felixn> can I shorten this? case generalCategory '>' of {  MathSymbol -> True ; _ -> False }
18:26:28 <trap_exit> is it masochistic to actually like compiler errors as "thank god I'm not seeing this error at runtime" ?
18:27:35 <orzo> i have the mozilla x509 validation algorithm implemented in haskell, anybody intrigued by that?  I have a test suite from libpkix and it passes over 744 tests, the vast majority
18:28:42 <orzo> i've no github repository for it, but i'll upload it if there's interest
18:29:05 <rasfar> felixn: sounds like an isMathSymbol function might be handy
18:29:11 <felixn> god damn
18:29:16 <creichert> trap_exit: masochist to _not_ want to know up front
18:29:22 <felixn> rasfar: ... but if there wasn't? :)
18:29:22 <rasfar> the above becomes isMathSymbol '>'
18:29:50 <rasfar> you can write it, no?
18:30:11 <benzrf> trap_exit: are you an erlanger
18:30:14 <felixn> rasfar: oh already have done that .. I was just wondering if there was another way to write that shorter
18:30:23 <trap_exit> benzrf: I was
18:30:38 <benzrf> trap_exit: if you link to me and i quit, will you quit to, or just receive a notification?
18:30:47 <benzrf> *too
18:31:25 <trap_exit> benzrf: before trap_exit, I'd die too; after trap_exit I just receive notification
18:31:37 <rasfar> felixn: nothing comes to mind, without language extensions at least
18:32:19 <jle`> hm
18:32:25 <felixn> rasfar: thanks!  I guess I'm trying too hard
18:32:45 <jle`> f (generalCategory->MathSymbol) = True
18:32:46 <jle`> f _ = False
18:32:56 <jle`> i wonder if that works
18:33:44 <rasfar> that's using PatternBlahs extension? what was it called...
18:34:02 <copumpkin> felixn: you can use PatternGuards, which are standard in 2010
18:34:14 <copumpkin> I like view patterns more for this, but it's not bad
18:34:16 <rasfar> ViewPatterns
18:35:35 <felixn> copumpkin: thanks!  I'm gonna check those things out now
18:35:37 <rasfar> the way felixn presented the question, it's not clear it's a function definition though
18:36:03 <felixn> rasfar: well I was going to use it inline since it was in one spot ... but I can easily just define it
18:36:07 <copumpkin> doesn't need to be
18:36:40 <rasfar> copumpkin: how would you shorten that case statement using PatternGuards or ViewPatterns?
18:36:57 <rasfar> case expression, sorry
18:37:28 <benzrf> copumpkin: so are you like a regular pumpkin but with the arrows flipped?
18:37:31 <copumpkin> yeah
18:37:40 <copumpkin> rasfar: well, that seems unnecessarily narrow
18:37:43 <copumpkin> since it's a constant expression
18:38:15 <copumpkin> if that is indeed the goal, I'd shorten it to True
18:38:31 <rasfar> I see what you mean
18:38:43 <felixn> wait .. I don't see!?
18:38:55 <rasfar> sure you do!
18:39:08 <felixn> no I'm blind
18:39:11 <felixn> I'm using TTS
18:39:12 <rasfar> oh wait
18:39:19 <felixn> lol just kidding ..
18:39:32 <rasfar> we're assuming '<' is indeed a MathSymbol, but who knows!
18:39:37 <copumpkin> no, I checked
18:39:51 <copumpkin> :)
18:40:11 <rasfar> * '>' rather / haha copumpkin
18:40:22 <felixn> v_v
18:40:28 <copumpkin> felixn: it's a constant
18:40:33 <copumpkin> it doesn't depend on any external knowledge
18:40:36 <copumpkin> it will always be True
18:40:39 <sclv_> if pumpkins were a groupoid it wouldn't matter
18:40:47 * felixn shows himself out
18:41:58 <shlevy> Any chance I can somehow automatically import the enum defined in this file, or at least the macros, into a haskell program automatically? https://github.com/NixOS/nix/blob/master/src/libstore/worker-protocol.hh
18:42:27 <shlevy> (it's a c++ header with a single function declaration I don't care about, an enum declaration, and a few macros)
18:45:18 <orzo> maybe there should be an open source collaboration exchange, where people exchange contributing to each other's projects when they start to get bored with their own
18:45:55 <rasfar> Alright, my plan is to upload this shape-syb package (and all future) to hackage in the SAI.* namespace, and to post to announce. I'm not comfortable putting it directly into Data.Generics.Shape. No objections seem to be forthcoming.
18:58:15 * hackagebot ShellCheck 0.3.4 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.4 (vidarhol)
19:08:16 * hackagebot sai-shape-syb 0.2.0 - Obtain homogeneous values from arbitrary values, tramsforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.2.0 (AndrewSeniuk)
19:10:25 <rasfar> hmm, why doesn't the Haddock work? drat...
19:12:35 <rasfar> ah, http://stackoverflow.com/questions/5174973/why-is-the-haddock-documentation-not-showing-up-on-hackage -- probably just need to wait
19:13:01 <creichert> rasfar: yea, sometimes it takes a few minutes
19:14:21 <rasfar> oops, I see I still call it "generic fmap" in the pacakge description, but it isn't an fmap, will need to fix that!
19:14:47 <shlevy> With ghc 7.8.2 I'm getting "the import of System.FilePath is redundant", is that expected?
19:15:55 <shlevy> Oh no
19:16:08 <shlevy> I just turned on -Wall at the same time as I updated my haskell version :D
19:23:18 * hackagebot sai-shape-syb 0.2.1 - Obtain homogeneous values from arbitrary values, tramsforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.2.1 (AndrewSeniuk)
19:28:19 * hackagebot persistent-mongoDB 1.4.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.2 (GregWeber)
19:30:08 <zorg24> Can someone help me with this error (very new to the language and doing some project euler) https://gist.github.com/zorg24/51b9187faf3047db08c5
19:30:33 <zorg24> I think I'm using maximum wrong
19:31:09 <ReinH> zorg24: what is the type of `map collatzDist [1..999999]'?
19:31:39 <ReinH> you can check in ghci
19:31:44 <ReinH> using :t
19:31:45 <zorg24> Int -> Int -> Int
19:31:54 <ReinH> No, that's the type of collatzDist
19:32:11 <zorg24> oh
19:33:01 <zorg24> can't really do that since I get the error when I try to load the file
19:33:42 <ReinH> you can use -fdefer-type-errors to defer type errors until evaluation
19:33:45 <zorg24> oh crud I forgot the second input
19:33:53 <zorg24> oh cool
19:34:25 <ReinH> zorg24: the types will tell all :)
19:34:43 <zorg24> also it gave me an error when I tried ghci -fdefer-type-errors
19:35:34 <ReinH> zorg24: the only way I know to use it with ghci is with an OPTIONS_GHC pragma: {-# OPTIONS_GHC -fdefer-type-errors #-}
19:35:37 <ReinH> Probably should have mentioned that
19:36:09 <zorg24> sorry what is that
19:36:40 <ReinH> It's a language pragma. You put them at the top of files and GHC reads them. https://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
19:36:59 <zorg24> gotcha thanks
19:37:03 <ReinH> np
19:39:06 <zorg24> it said: pstuff.hs:1:16:
19:39:06 <zorg24>     unknown flag in  {-# OPTIONS_GHC #-} pragma: -fdefer-type-errors
19:39:06 <zorg24> Failed, modules loaded: none.
19:39:30 <zorg24> when I put it at the top of the file and tried to load it
19:41:53 <isomorpheous> Hey, y'all
19:42:00 <isomorpheous> friend is interested in learning how to program
19:42:09 <isomorpheous> What's a good newbie language that isn't python
19:42:13 <isomorpheous> Or ruby, or perl
19:42:18 <isomorpheous> Or Common Lisp
19:42:34 <matematikaadit> isomorpheous: #haskell :)
19:42:43 <isomorpheous> matematikaadit: I love Haskell personally
19:43:08 <isomorpheous> matematikaadit: but i have a feeling it isn't the best choice for a newbie
19:43:12 <zorg24> well just ruled out my usual suggestions
19:43:24 <zorg24> maybe Java (Scala?)
19:43:33 <Trollinator> definitely not Java.
19:43:34 <isomorpheous> What about scheme or racket
19:43:43 <isomorpheous> zorg24: scala isn't a bad language
19:43:47 <Trollinator> it's not?
19:43:56 <isomorpheous> Trollinator: compared to Java
19:44:04 <isomorpheous> Trollinator: or any of the scripting languages
19:44:13 <ReinH> zorg24: what version of GHC?
19:44:19 <zorg24> Trollinator: yeah I haven't heard of scala being used to learn programming but it doesn't seem like a bad choice
19:44:25 <Trollinator> scheme *guarantees* tail call optimisation. Scala doesn't have it at all.
19:44:32 <zorg24> ReinH: 7.4.2
19:44:34 <isomorpheous> Trollinator: I love scheme
19:44:42 <ReinH> Trying to learn programming with Scala is a good way to learn to hate functional programming :/
19:44:52 <ReinH> zorg24: Ah, it was added in 7.6.1
19:44:55 <zorg24> oh
19:44:57 <ReinH> 7.4.2 is pretty old now
19:45:19 <isomorpheous> Trollinator: What about C++ or C
19:45:27 <zorg24> yeah, I had messed a little bit with haskell and then stopped, but forgot to update my GHC
19:45:34 <Trollinator> I can't make up my mind which one is more horrible.
19:45:46 <zorg24> when I started again
19:45:54 <ReinH> The design of Scala is a lot like the way Douglas Adams described the design of airports
19:46:11 <benzrf> ha!
19:46:11 <Trollinator> C due to extremely limited expressiveness or C++ due to the crazy complexit.
19:46:13 <Trollinator> y
19:46:20 <ReinH> Scala exposes all the plumbing of the type system on the grounds that it is functional, and hides away all the beauty of type inference, presumably on the grounds that it is not.
19:46:22 <n0n3such> tony morris -> "Children take very easily to Haskell’s syntax"
19:46:32 <n0n3such> http://tonymorris.github.io/blog/posts/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/index.html
19:47:38 <zorg24> I think you should definitely choose a dynamically typed language for the first b/c types tend to give people a lot of trouble at first
19:47:49 <Welkin> scala is too close to java
19:47:57 <Welkin> it is ugly too
19:47:59 <Trollinator> ReinH: you can't really infer a lot when you combine higher order kinds, subtyping and parametric polymorphism.
19:48:40 <n0n3such> zorg24, only if your first language wasn't statically typed
19:48:48 <Trollinator> zorg24: I disagree. You need to think about types anyway. Sweeping it under a rug doesn't make it easier.
19:48:59 <n0n3such> best to learn it first
19:49:11 <Welkin> haskell or python seem best for introductory languages, depending on the typing preference
19:49:24 <Welkin> scheme isn't bad either
19:49:25 <ReinH> I think Haskell is a great first language
19:49:32 <n0n3such> ^
19:49:52 <rasfar> zorg24: regarding your problem, collatzDist expects two arguments; when you map it, you get a list of functions -- each still expects another Int
19:49:55 <isomorpheous> Haskell seems to be the only community with its shit together nowadays
19:50:01 <isomorpheous> besides *vomit* Java
19:50:03 <zorg24> n0n3such: hmm maybe they've never confused me and I learned Java first, and most of the people who were confused by them learned Python first. That's interesting
19:50:23 <zorg24> rasfar thanks I figured it out
19:50:29 <ReinH> Well, it's a bit difficult coming from a language that's allergic to types
19:50:41 <zorg24> yeah I hate Java
19:50:45 <n0n3such> zorg24, they confused me because I learned C first :)
19:50:48 <Trollinator> well, to be fair it took me a while to wrap my head around curried functions.
19:50:54 <rasfar> Miranda was a phenomenal first language, so Haskell ought to be. Maybe using hugs at first?
19:51:11 <zorg24> n0n3such: C/C++ sounds like a horrible first language
19:51:20 <Welkin> c is a terrible first language...
19:51:22 <n0n3such> at the time, it ruled
19:51:23 <zorg24> Miranda?
19:51:24 <Welkin> it was mine
19:51:27 <isomorpheous> What about Emacs Lisp?
19:51:33 <ReinH> Trollinator: well, an earlier Haskell offshoot called GOFER designed for education did favor uncurried functions, so maybe there's something to that
19:51:35 <Trollinator> C is terrible in almost every imaginable way.
19:51:40 <n0n3such> ^
19:51:43 <rasfar> Once you get used to the half-dozen usual pitfalls, C lets you get down to business quickly.
19:51:49 <zorg24> I don't think any lisp is a good first language
19:51:53 <ReinH> It also its type arrows and composition backwards, so maybe not
19:52:02 <ReinH> *put its
19:52:02 <n0n3such> its useful for writing unix version 6 device drivers
19:52:06 <Welkin> assembly (RISC) is a better first language than c
19:52:36 <matematikaadit> umm... what's wrong with Haskell as first language?
19:52:39 <n0n3such> my first language was 8080 assembler
19:52:47 <Welkin> matematikaadit, nothing, it is fine as a first language
19:52:50 <isomorpheous> matematikaadit: lack of resources
19:53:14 <isomorpheous> matematikaadit: nothing wrong with the language itself, it's just that there aren't a lot of books designed for programming newbs
19:53:32 <Welkin> python wins in that regard
19:53:40 <Welkin> as far as resources for complete beginners is concered
19:53:41 <rasfar> there are good toturials though
19:53:46 <n0n3such> http://dev.stephendiehl.com/hask/#cabal
19:54:03 <ReinH> I think Haskell has better resources for complete beginners than for more advanced beginners
19:54:26 <ReinH> The big gap imo is on practical applications of beginner concepts
19:54:33 <zorg24> yeah, Haskell would be a fine first language, but I think they should definitely learn an OO language second
19:54:38 <ReinH> RWH was an attempt but it's rather flawed :/
19:54:41 <rasfar> i would recommend Haskell if the person likes math; if they're more interested in building stuff, Haskell will likely give them fits.
19:54:51 <sshine> ReinH, I liked jekor's video tutorials.
19:54:58 <Trollinator> OO is an exceptionally bad idea that could only have originated in California.
19:55:03 <ReinH> sshine: me too, that's why I'm doing the haskell cast with him :)
19:55:04 <n0n3such> lol
19:55:11 <Welkin> LYAH seems fine for beginning programmers
19:55:23 <sshine> ReinH, what's that?
19:55:30 <ReinH> sshine: a haskell podcast that we do :)
19:55:42 <zorg24> yes but if they want to get a job then sadly they need to know OO
19:55:53 <Welkin> zorg24, no they don't
19:56:00 <Welkin> only at large corporations
19:56:04 <Welkin> startups don't use that
19:56:08 <zorg24> ok fair enough
19:56:17 <sshine> ReinH, cool!
19:56:19 <Welkin> they prefer python/ruby or functional languages
19:56:28 <Welkin> scala is too prevalent, unfortunately...
19:56:32 <Welkin> I wish more used haskell
19:57:04 <Welkin> clojure seems to be spreading quickly because of clojurescript
19:57:12 <Trollinator> well, there isn't *that* much wrong with Scala. Not having tail calls is ugly, but I think that'll be fixed eventually.
19:57:24 <zorg24> a haskell podcast, that sounds cool. What's it called?
19:57:25 <Welkin> anything that works with javascript and makes it easier to build front ends wins
19:57:39 <Trollinator> define “works with JavaScript”
19:57:40 <n0n3such> My startup uses scala
19:57:50 <Welkin> Trollinator, compiles to javascript
19:57:54 <CindyLinz> Welkin: such as ghcjs?
19:58:09 <Welkin> an all-in-one solution like clojurescript/Om
19:58:24 <Welkin> rather than using angular or ember
19:58:31 <Trollinator> there's something called PureScript. I haven't used it though.
19:58:39 <Trollinator> and there's Frege on the JVM.
19:58:53 <Trollinator> I haven't used that either though.
19:59:15 <Trollinator> anyway, no excuses for writing something other than basically-haskell
19:59:17 * StoneCypher4k enjoys erlang
19:59:18 <Trollinator> :-)
19:59:38 <Welkin> StoneCypher4k, that is a different domain
19:59:54 <StoneCypher4k> there's an erlang compile for js
19:59:58 <StoneCypher4k> i think it's emscripten
20:00:06 <StoneCypher4k> a surprising number of modules are implemented
20:00:19 <matematikaadit> http://www.haskellcast.com/ ?
20:00:34 <zorg24> Also I just noticed that there's a Haskell edx class!!! Yay!!
20:08:59 <ReinH> matematikaadit: yep
20:39:41 <trap_exit> what companies use haskell?
20:39:51 <trap_exit> I can't imagine working anywhere that does not use haskell now
20:40:05 <StoneCypher4k> says the guy with the erlang nick
20:40:38 <trap_exit> I will not hide my past
20:40:54 * StoneCypher4k uses bot
20:40:54 <StoneCypher4k> h
20:41:24 <trap_exit> if erlang messages could be typed in a haskell like manner
20:41:25 <trap_exit> I would be so happy
20:41:38 <Zekka> trap_exit: Heard of cloud-haskell?
20:41:46 <StoneCypher4k> for practical purposes pattern matching on a tuple whose leader is an atom gets you pretty far
20:42:08 <trap_exit> it gives you the illusion of making process
20:42:11 <trap_exit> whereas types detects errors at compile time
20:42:21 <StoneCypher4k> dialyzer can work with those.
20:42:21 <Zekka> I can think of a few companies that use Haskell but I don't know too many that use *only* Haskell right offhand
20:42:41 <Zekka> I met some cool guys from Aleph Cloud at BayHac, they seemed to use a lot of it
20:42:43 <trap_exit> alright
20:42:43 <trap_exit> I'll lower my standards
20:42:50 <trap_exit> what about companies that use mostly haskell ?
20:42:56 <StoneCypher4k> you could just start a company that uses haskell
20:43:16 <Zekka> I think Facebook uses a lot (but not mostly) internally: you'd also be working in ML sometimes from what I hear
20:43:17 <trap_exit> i think this is a good idea
20:43:52 <Zekka> Facebook also has a massive bank of PHP code of course so don't get too snooty
20:44:14 <Zekka> IMVU was hanging out there too, apparently a lot of their web service backends use Haskell but I don't really know what they do
20:45:28 <StoneCypher4k> facebook is almost entirely php with a smattering of erlang in production
20:45:47 <StoneCypher4k> not counting stuff they bought
20:46:03 <Zekka> StoneCypher4k: Really? I heard they used a lot of it even though the size of the PHP codebase absolutely dwarfs everything else
20:46:07 <StoneCypher4k> (though the biggest thing they've bought that's in production is erlang)
20:46:23 <trap_exit> man
20:46:27 <StoneCypher4k> maybe in the stuff they've bought?  there's a lot of that
20:46:29 <trap_exit> 19 billion dollars for 50 erlang programmers?
20:46:34 <Zekka> I've heard at least they use a lot of ML
20:46:37 <StoneCypher4k> well, for half a billion users
20:47:00 <Zekka> Googling, it looks like they wrote a lot of internal tooling in Haskell
20:47:13 <trap_exit> who is this pooape
20:47:19 <trap_exit> and why is this person pm-ing me about hate crimes ?
20:47:22 <Zekka> there's also Haxl, which I don't know too much about
20:47:37 <Zekka> trap_exit: I'm getting it too
20:47:52 <StoneCypher4k> haxl seems boring to me
20:48:00 <StoneCypher4k> so does haxe
20:48:04 <StoneCypher4k> so does hack
20:48:24 <trap_exit> i'm using haxe
20:48:27 <trap_exit> err, i'm using Haste
20:48:29 <trap_exit> not Haxe
20:48:37 <Zekka> I feel bad because Hack's probably the result of a legitimate business assessment that found that it was more expensive to do anything but keep working with the scary PHP codebase when necessary
20:49:01 <StoneCypher4k> "scary php codebase"
20:49:02 <StoneCypher4k> lul
20:49:25 <pooape> going to keep hating those niggers and their monkeyshines until the cows come home
20:49:39 <pooape> that is why we are members of ch im pou t  forum
20:49:47 <Zekka> @where ops
20:49:47 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
20:49:54 --- mode: ChanServ set +o copumpkin
20:49:58 --- mode: copumpkin set +b *!~Zektor7@187.153.55.92
20:49:58 --- kick: pooape was kicked by copumpkin (No. Bad.)
20:50:04 --- mode: copumpkin set -o copumpkin
20:50:45 <Zekka> Maybe I'm just biased because I work with a lot of bad code lately and I've never run into a PHP codebase that managed not to offend my delicate sensibilities
20:51:00 <StoneCypher4k> tail of the plane
20:51:05 <shlevy> How can I generate haddock locally  during development?
20:51:13 <geekosaur> cabal haddock?
20:51:31 <shlevy> geekosaur: So obvious it never occurred to me, thanks *facepalm*
20:51:37 <pqmodn> > 1 + 1
20:51:39 <lambdabot>  2
20:52:04 <StoneCypher4k> Zekka: i 'unno, mine always seemed fine
20:52:15 <StoneCypher4k> Zekka: i mean it's not that hard to write clean php
20:52:23 <StoneCypher4k> Zekka: and you do move fast as a motherfucker in php
20:52:24 <trap_exit> startups great
20:52:24 <trap_exit> haskell great
20:52:31 <Zekka> StoneCypher4k: If you think it's OK and code quality is the sort of thing you usually care about then sure I believe you.
20:52:45 <StoneCypher4k> Zekka: but i'm pretty sure you're tail of the plane here
20:52:55 <Zekka> Tail of the plane?
20:53:38 <trap_exit> is there any language with type system most powerfu lthan haskell, but actually usable? Coq is stronger, but hard to use
20:53:54 <Zekka> trap_exit: Idris tries to be, but I don't know it too well
20:54:11 <Zekka> If I remember right Athan's an outspoken fan of it so if he's around sometime bother him
20:54:28 <Zekka> StoneCypher4k: I guess I'll clarify my background a little bit
20:54:47 <Zekka> I'm currently at a VB6 company transitioning to Java/Clojure, and in my spare time I work with a lot of amateurs who tend to use languages like Python and PHP
20:55:18 <Zekka> Python generally seems more concerned with correctness than PHP so the bad python code is much easier for me to work with than the bad PHP code, even though you can write good (and often similar) code in both
20:56:18 <Zekka> I'd say that PHP's advantages seem a little questionable to me on large projects -- stuff like being able to interpolate values goes away when you introduce templating, for instance
20:56:36 <Zekka> and in general I'd say it would rather be speedy than correct
20:56:54 <trap_exit> php is the perfect language
20:57:01 <trap_exit> for those who like deubigging on production systems
20:57:09 <trap_exit> I, on the other hand, like debugging during compilation
20:57:36 <StoneCypher4k> well
20:57:39 <StoneCypher4k> i mean respectfully
20:57:42 <mwc> there's a whole middle ground of "development environment" testing you're kind of leaving out
20:57:53 <StoneCypher4k> my opinion is that the appropriate way to look at things when regarding advantages
20:57:54 <shlevy> Can I make multi-line haddock comments on a function argument?
20:57:57 <StoneCypher4k> is to look at the data
20:58:04 <StoneCypher4k> php's put up a bunch of the largest sites on the web
20:58:10 <StoneCypher4k> facebook, wikipedia, wordpress, etc
20:58:14 <StoneCypher4k> haskell has not
20:58:19 <StoneCypher4k> i don't profess to know what the difference is
20:58:22 <Zekka> StoneCypher4k: But whether it appeals to people doesn't necessarily say much about whether it's well-designed
20:58:23 <StoneCypher4k> but the difference does appear to be there
20:58:40 <athan> Thanks, Zekka. trap_exit: I'm by no means well versed, I've taken a break from them, but I like the ability to have value-level restrictions on types (if I remember correctly), but I'm still a mega noob. I still haven't learned coq, really :)
20:58:42 <trap_exit> StoneCypher4K: I bet there was a time in the history of computing, where (number of x86 programs) > (number of python programs);
20:58:53 <Zekka> You'll notice a bunch of the major PHP sites came up when the argument was framed in terms of "PHP or Cabal?"
20:58:54 <trap_exit> athan: I heard you're an idris fan
20:58:59 <lfairy> StoneCypher4k: all three of those examples were created when alternatives were immature
20:59:07 <Zekka> er, CGI*
20:59:14 <jle`> oh cool my library i was making ahs some mathsy types of properties.  i didn't even intend this
20:59:20 <jle`> i love you haskell
20:59:31 <Zekka> Between PHP and, I don't know, CGI scripts in Perl I'd probably favor PHP because it does a lot of nice things for me.
20:59:39 <lfairy> jle`: what are the mathy properties? :p
20:59:53 <trap_exit> associatve, communitative, distributive
20:59:55 <jle`> lfairy: fancy equational reasonings stuff :O
21:00:03 <jle`> that i can use to optimize or simplify
21:00:05 <jle`> taking advantages of laws
21:00:14 <lfairy> that's pretty vague...
21:00:41 <jle`> things like the monad laws
21:00:43 <jle`> or the functor laws
21:00:57 <jle`> laws of monad morphisms and natural transformations
21:01:03 <jle`> or monoid homomorphisms
21:01:14 <jle`> that allow you to simplify code and guaruntee that it won't change the behavior
21:02:00 <koyd> Hi everyone. Is there a FAQ or something that I can check? Looking for how to start learning.
21:02:04 <Zekka> StoneCypher4k: Personally I think the Haskell pitch (for an example: you could come up with a big list of languages I like better than PHP) is kind of hard to make because it's sort of hard to learn and not a lot of people already know it
21:02:08 <jle`> koyd: for Haskell?
21:02:14 <koyd> jle`: yeah
21:02:18 <Zekka> koyd: I like LYAH, but nobody else seems to, so ask them.
21:02:23 <Zekka> (Learn You a Haskell)
21:02:24 <jle`> koyd: i like LYAH
21:02:28 <jle`> @where lyah
21:02:28 <lambdabot> http://www.learnyouahaskell.com/
21:02:29 <Welkin> everyone likes LYAH
21:02:31 <Welkin> I loved it
21:02:31 <jle`> ther'es also bitemyapp 's guide
21:02:33 <jle`> https://github.com/bitemyapp/learnhaskell
21:02:35 <Welkin> the best programming book ever
21:02:36 <platz> it'd be kind of neat if there was some kind of IDE that did transforms based on equantional reasoning, analagous to how Resharper provides refactorings for C# code
21:02:38 <koyd> hm ok, will check thanks!
21:02:54 <jle`> platz: that'd be neat
21:02:59 <pqmodn> platz: if you're interested, look into KURE
21:03:08 <Zekka> StoneCypher4k: I think with i.e. Python you've got a very marketable, normal-seeming language which pitches itself based on correctness, and that got a lot of adoption
21:03:16 <StoneCypher4k> kay
21:03:24 <StoneCypher4k> so are there big python systems in production?
21:03:26 <Zekka> Whether Python actually really helps that much with correctness is another matter, but I think it demonstrates at least the concern is there
21:03:33 <Zekka> StoneCypher4k: Yes, it's very popular!
21:03:34 <athan> trap_exit: Just for research, I haven't quite gotten anything working yet though :P I like Omega's design, too. It's hard to decide for what I want. Definitely just a fan at the moment though. It's been a few months since I've last touched it - I was working on a proofer for variable-column and ad-hoc restriction schema (which could be recursive, for a sequence of columns described in a closed form) for the towers-of-hanoi problem :) (and optim
21:03:34 <athan> ized routine deriver, kinda. It depends, I didn't really finish it - need food :U )
21:03:47 <StoneCypher4k> Zekka: i mean big.  i mean like name i know big.
21:03:49 <Welkin> at least 50% of the job postings I see for startups are looking for python
21:03:55 <StoneCypher4k> yeah i don't care what startups use.
21:04:00 <StoneCypher4k> startups make bad tool choices every day.
21:04:04 <Zekka> Google uses a lot of Python
21:04:08 <StoneCypher4k> if there's a bad tool out there, there's at least five startups using it.
21:04:16 <StoneCypher4k> i can name three perl startups from this year off the top of my head.
21:04:24 <Zekka> lately they're using Go for a lot of the things they used to use Python for, minding that Go tries to do many of the same things
21:04:24 <Welkin> what startups use today is what large corporations use in ten years
21:04:31 <StoneCypher4k> go is a laugh, pass
21:04:36 <Welkin> also, apple uses python
21:04:43 <StoneCypher4k> Welkin: i don't see anyone using the stuff from ten years ago today though
21:05:05 <Zekka> StoneCypher4k: Python? Ruby?
21:05:07 <StoneCypher4k> Welkin: startups ten years ago were using grails, groovy, haxe, icefaces, d, and lisp still
21:05:16 <StoneCypher4k> Zekka: well i asked you to name a big player using python
21:05:19 <Welkin> hopefully this means we will see large corporations use haskell in 15 years
21:05:21 <StoneCypher4k> Zekka: ruby i can name a few
21:05:25 <Zekka> StoneCypher4k: I named Google
21:05:50 <StoneCypher4k> google uses python internally, not externally, i thought, and it's not a dominant language there i thought.  is that wrong?
21:05:54 <athan> trap-exit: er - proof. Sorry.
21:06:07 <Welkin> StoneCypher4k, yes, python is a widely used language at google
21:06:12 <Zekka> StoneCypher4k: They use a ton of Java too, along with at least C++ and probably some other languages
21:06:21 <Welkin> they want everyone to know/use python and java
21:06:22 <Zekka> I don't know the proportions but Python's not terribly excluded.
21:06:40 <Zekka> I don't know what you mean by "internally, not externally": with web-apps your client-facing code is probably really only going to be in Javascript
21:06:45 <splintax> what difference does it make anyway
21:06:49 <Zekka> StoneCypher4k: Maybe this will help: https://wiki.python.org/moin/OrganizationsUsingPython
21:06:54 <splintax> if it's a big production system it's a big production system
21:07:02 <petercommand> will the @src functionality of lambdabot be implemented in ghci?
21:07:16 <Zekka> petercommand: If it ever is I doubt it will be implementd like it is in lambdabot
21:07:29 <Zekka> from what I hear it's basically a lookup table from names to instructional implementations -- not the actual code
21:07:30 <Welkin> dropbox is probably the fastest growing company using python
21:07:43 <Welkin> they have a huge number of python programmers, including Guido himself
21:08:16 <systemfault> Welkin: Wasn’t Youtube written in Python when Google bought them?
21:08:21 <systemfault> (Not 100% sure)
21:08:31 <Welkin> I'm not sure
21:08:54 <StoneCypher4k> Zekka: by internally vs externally i mean is it tools for staff or tools for customers
21:09:00 <StoneCypher4k> but i appear to be wrong, so nevermind
21:09:26 <systemfault> It is… a small site called youtube is written in Python.
21:09:28 <StoneCypher4k> shopzilla counts
21:09:35 <StoneCypher4k> bf2 counts
21:10:05 <StoneCypher4k> yeah okay, i guess people are.
21:10:08 <platz> looks like the kure folks got some buzz a few years ago http://www.reddit.com/r/haskell/comments/ujdet/introducing_the_hermit_equational_reasoning/
21:10:36 <platz> leverages compiler plugins
21:10:37 <Zekka> StoneCypher4k: Basically, I think languages doing many of the same things Haskell does well (although not necessarily as well) are gaining a lot of popularity
21:10:53 <petercommand> Zekka: does ghci keep the source code of user-defined function?
21:10:55 <Zekka> which doesn't necessarily mean that Haskell will become popular but suggests that unsafe languages might be getting less so
21:11:18 <Zekka> petercommand: I don't actually know right offhand, I don't know too much about how GHC works
21:11:32 <Welkin> Swift is the only evidence you need
21:11:43 <Welkin> a type safe language with functional semantics from apple
21:11:50 <Welkin> everyone will follow suit
21:12:30 <Zekka> Yeah: I'm a little suspicious of parts of it (why nullables, but not Eithers/monads in general) but I think Swift is right in a lot of ways and I have a feeling other people will be right in even more ways in the future
21:12:35 <Zekka> in general?)*
21:12:50 <platz> basically, this: http://wordaligned.org/images/the-challenge-of-effects.jpg
21:13:01 <stolaruk> Is getting concurrency right in Haskell typically quite difficult?
21:13:35 <Zekka> stolaruk: You might read Marlow's book and decide for yourself
21:13:45 <Zekka> my gut reaction is "no, it's not that bad" but I haven't written much concurrent Haskell
21:13:46 <stolaruk> Zekka: Yeah I'm working my way thru it
21:14:29 <Zekka> I think that a lot of Haskell's standard typeclasses will make their way into a lot of languages in bits and pieces -- they already have in i.e. Promises in JS (monads)
21:15:04 <stolaruk> "Promises" sounds like thunks to me :)
21:15:27 <Zekka> But I don't think a lot of languages will neccessarily start formalizing them in terms of typeclasses unless they stack up a lot
21:15:56 <Zekka> and some classes like Traversable are kind of questionably useful until you start trying really hard to think about effects
21:16:22 <Zekka> stolaruk: They're basically a Functor for 'we don't have this value yet' plus 'we might fail to get this value'
21:17:12 <stolaruk> Doesn't sound like a trustworthy promise ;)
21:17:25 <Zekka> stolaruk: It's basically Either with concurrency.
21:18:01 <stolaruk> Is there some blocking built in?
21:18:09 <Zekka> (Traversable actually made its way at least into Dart -- its Futures (promises) let you turn lists of promises into promises of lists)
21:18:30 <Zekka> stolaruk: Creating a promise doesn't block -- you have to bind over it (#then()) to operate on whatever value eventually appears inside
21:19:04 <stolaruk> Never learned me any JavaScript
21:19:25 <systemfault> stolaruk: You don’t miss much… :/
21:19:30 <Zekka> it will do whatever you #then() exactly once if a value ever arrives (even if it arrived before you #then()ed)
21:19:43 <stolaruk> I find it hard to get excited about languages other than Haskell these days
21:19:43 <systemfault> stolaruk: If I could go back in time, I’d unlearn it and learn Haskell instead :P
21:20:00 <Zekka> I don't really dislike Javascript as much as I think a lot of people do but it's not really safe or fun or good
21:20:50 <systemfault> I’m really opinionated about languages… and I think that all languages with dynamic typing are toys and unsuited to write big applications.
21:21:01 <Zekka> Promises basically work the same way as Either except they're asynchronous (not actually concurrent: Javascript is single-threaded) and like with anything else in JS, when you bind something, it may have side effects
21:21:08 <platz> several companies have been competing to make javascript fast, so it is pretty fast
21:21:13 <StoneCypher4k> systemfault: have you built one?
21:21:18 <Zekka> so there's no funny machinery for getting a value 'out' of a promise -- generally you either use side-effects or you let the promise monad eat your whole program
21:21:29 <Welkin> systemfault, what about ones with terrible type systems that may as well not exist like C?
21:21:42 <Zekka> which is really messy because in Javascript you don't have shorthand for monadic flow control because there's no explicit monad involved in ordinary Javascript flow control
21:21:42 <systemfault> StoneCypher4k: Building websites has been my job since the beginning of the 2000s
21:21:59 <StoneCypher4k> not a website.  a large system.
21:22:09 <benzrf> >> Promise.all
21:22:14 <benzrf> hmm
21:22:19 <augur> i find myself often writing partial programs with type signatures in lets, and incrementally wrapping them in things until i get the result i want
21:22:20 <augur> hmm
21:22:22 <systemfault> StoneCypher4k: Yup. Complex domains.
21:22:22 <benzrf> >> 3
21:22:34 <benzrf> o no ecmabot
21:22:49 <Welkin> benzrf, where is there an ecmabot?
21:23:11 <benzrf> oh wow
21:23:14 <benzrf> wrong channel haha
21:23:18 <benzrf> i thought i was in ##javascript
21:23:33 <Zekka> benzrf: Hope I wasn't too rude!
21:23:44 <benzrf> Zekka: i dont like javascript very mych
21:23:45 <benzrf> *much
21:24:04 <Welkin> how could you mistake #haskell for ##javascript?
21:24:10 <benzrf> anyway, firefox & chrome at least have Promise.all which is sequence
21:24:20 <augur> anyone else do this?
21:24:28 <athan> Zekka: Now you got me obsessed over dependent types again...
21:24:29 <benzrf> Welkin: because haskell and javascript were being discussed at the same time and compared
21:24:30 <Zekka> I liked Coffeescript OK last I used it: it was basically Python with worse tooling and everything was an expression
21:24:41 <benzrf> Zekka: cs is more rubyish for that reason imo
21:24:47 <Zekka> You expected ##javascript to know Haskell?
21:24:50 <benzrf> Zekka: yes
21:24:56 <Zekka> I don't hang out there, should I?
21:24:59 <nisstyre> there are some people in there who know it
21:25:02 <nisstyre> like myself
21:25:03 <Welkin> cs?
21:25:04 <systemfault> Zekka: Coffeescript is like the worse altjs language… it brings nothing but syntaxic sugar. It doesn’t improve or fix JS in any way.
21:25:09 <nisstyre> and I know a few other people at least
21:25:11 <Welkin> oh
21:25:17 <systemfault> *worst
21:25:23 <benzrf> having idled there the last day or two, it's pretty ambivalent about js
21:25:26 <nisstyre> I agree about coffeescript
21:25:29 <nisstyre> it's a waste of time
21:25:34 <benzrf> js is different from php in more ways than sucking less
21:25:40 <nisstyre> it actually makes JS worse in some ways
21:25:47 <benzrf> php's community wallows in awfulness because those with sense leave
21:25:54 <nisstyre> newer JS has "let" and I think you can disable the auto global behaviour somehow
21:25:56 <benzrf> but a lot of people are forced to use js who wouldnt otherwise
21:25:57 <Zekka> systemfault: Javascript syntax bothered me most and I don't think there's a way to fix i.e. the type system without losing interoperability
21:26:10 <benzrf> so you get some more knowledgable people there
21:26:15 <nisstyre> CS doesn't let you assign to variables in the outer scope without shadowing
21:26:29 <Zekka> nisstyre: Yeah, I'll agree that's a pretty bad design decision
21:26:52 <Zekka> You tend to end up being very paranoid about introducing new scopes when working in it
21:27:01 <systemfault> Zekka: I don’t think it can be fixed. It’s going to gain nice features over the time but the core is always going to be the way it is now (My opinion)
21:27:33 <platz> Array.prototype.slice.call(arguments, 0);
21:27:33 <Welkin> the future of javascript is as an assembly for the web
21:27:42 <nisstyre> Zekka: you can at least get actual ints in javascript now with typed arrays
21:27:43 <Welkin> where other languages compile down to a subset of it
21:27:45 <Welkin> like asm.js
21:27:48 <Zekka> As far as altjs languages go, I kind of like Elm but I feel like it's not too mature, and I don't feel like I can trust it to interoperate with anything
21:27:49 <nisstyre> although it's fairly esoteric
21:27:50 <systemfault> Welkin: Possibly :)
21:28:02 <nisstyre> I think it has unsigned ints even
21:28:25 <platz> the future of javascript is transpilers
21:28:33 <nisstyre> that word...
21:28:34 <Zekka> I don't feel like Elm provides a terribly compelling solution to the Typeclass Problem even though I think that modules are a good start
21:28:39 <platz> as the language fragments because browsers cannot keep up
21:28:43 <Zekka> (er, records-as-modules, that is)
21:29:32 <systemfault> platz: I think that browser implementors have done a great job the last ~4 years or so
21:30:00 <Zekka> (Elm doesn't have typeclasses and you tend to write most of your reactive code using a specific Applicative instance for which all Applicative functions are specialized: it's very informal)
21:30:15 <systemfault> I’ve heard nice things about purescript
21:30:21 <platz> systemfault: yep, but ES6 is coming too
21:30:21 <systemfault> Haven’t tried it though
21:32:59 <blakehaswell> Yeah from what I’ve seen purescript looks nice
21:33:34 * hackagebot xml-conduit 1.2.0.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.0.3 (MichaelSnoyman)
21:33:36 * hackagebot xml-hamlet 0.4.0.9 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.9 (MichaelSnoyman)
21:34:01 <platz> some of the more complex examples aren't for the feint of heart.. something about lots of foreign imports needed for FFI https://github.com/purescript-contrib/purescript-angular/blob/master/src/Angular/Scope.purs
21:34:07 <blakehaswell> Considering re-writing an existing project to see how it works.
21:34:23 <platz> code typed as strings
21:34:37 <platz> err, typed as functions but implemented as strings
21:35:25 <blakehaswell> Nasty
21:36:49 <petercommand> is it correct to say that functors are based on overloading?
21:37:29 <Zekka> petercommand: In the sense that the functor operations can apply to any type implementing Functor? Yes.
21:37:39 <Zekka> That's where you get Functor and not just [], Maybe, Either
21:37:45 <Zekka> er, Either a*
21:38:11 <platz> overloading seems like the wrong word. very suspicious connotations
21:38:12 <Zekka> The Functor operation fmap is just a lifting operationt that works on any of those types
21:38:34 * hackagebot wai-extra 3.0.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.1 (MichaelSnoyman)
21:38:36 * hackagebot warp 3.0.0.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.4 (MichaelSnoyman)
21:38:49 <petercommand> hmm..
21:41:25 <petercommand> platz: why?
21:41:45 <petercommand> it seems reasonable to me...
21:43:59 <platz> 'overloading' traditionally means ad-hoc polymorphism, but functors are of kind * -> *.  higher order kinds and ad-hoc polymorphism are a bit different conceptually
21:45:57 <platz> overloading is more of an OO thing - that term really doesn't exist in haskell-land because there are things like typeclasses which solve the same problems that overloading solves
21:46:10 <blakehaswell> platz: the FFIs in the example you linked to seem like quite a nasty implementation. Why would you write JS functions as inline strings? Just to simplify the build process or what?
21:46:30 <blakehaswell> In the PureScript example
21:47:26 <platz> blakehaswell: not sure, but presumably just to keep the code and FFI signature in the same file?
21:50:27 <enthropy> platz: why don't you call the polymorphism type classes give you "ad hoc polymorphism"?
21:51:22 <platz> enthropy: I thought I was arguing that typeclasses *were* very similar to ad hoc polymorphism
21:52:23 <platz> as opposed to saying "functors are based on overloading"
21:54:13 <augur> platz: not just similar, they _are_ ad hoc polymorphism :P
21:55:13 <platz> hrmm.. I've read somewhere that this line is kind of blurry - that haskell actually 'simulates' ad-hoc polymorphism with typeclasses because all it knows about is parametric polymorphism
21:58:20 <platz> but i've gotten this wrong before - it may be that i'm trying to make a distinction without a difference
21:58:44 <petercommand> I am new to haskell, and when I look into the haskell tutorial about functors, I thought that: hey, this is just like overloading!
21:58:44 <platz> a vtable may just be a vtable
21:58:50 <Zekka> Well, what's ad-hoc polymorphism aside from 'polymorphism without typeclasses'?
21:59:02 <Zekka> petercommand: Replace 'functors' with 'typeclasses' and I think we've got a deal
21:59:14 <Zekka> (because you can overload operations other than the functor operations with typeclasses!)
21:59:19 <petercommand> yeah
21:59:29 <Zekka> :t (>)
21:59:30 <lambdabot> Ord a => a -> a -> Bool
21:59:39 <Zekka> So what that says is that (>) will work for any ordered type
21:59:48 <augur> is there a nice idiomatic haskell way of doing something like this:
21:59:53 <Zekka> :t (>) `asAppliedTo` (0)
21:59:54 <lambdabot> (Ord a, Num a) => a -> a -> Bool
22:00:01 <Zekka> That one will only work on ordered numbers
22:00:04 <Zekka> :t (>) `asAppliedTo` (0 :: Int)
22:00:05 <lambdabot> Int -> Int -> Bool
22:00:09 <Zekka> And that one will only work on integers.
22:00:32 <augur> while (true) { x' = f(x); if (x' == x) { break; } else { x = x'; } }
22:00:34 <petercommand> what does the "asAppliedTo" mean?
22:00:36 <Maxdamantus> :t fromInteger
22:00:37 <lambdabot> Num a => Integer -> a
22:00:47 <Zekka> petercommand: It's a fancy function that specializes the function you pass it
22:00:59 <enthropy> @src asAppliedTo
22:00:59 <lambdabot> Source not found. Maybe you made a typo?
22:01:03 <Zekka> Basically, if you pass it (>) and an Int, it gives you (>), but only when the first argument is an Int
22:01:05 <enthropy> @src asTypeOf -- same idea
22:01:05 <lambdabot> Source not found. My pet ferret can type better than you!
22:01:05 <Maxdamantus> If you're thinking of Haskell in terms of vtables, things like that don't really work.
22:01:08 <augur> i mean, not quite a fixed point, actually, but
22:01:09 <enthropy> const
22:01:30 <Zekka> :t asAppliedTo
22:01:31 <lambdabot> (a -> b) -> a -> a -> b
22:01:32 <Zekka> @src const
22:01:32 <lambdabot> const x _ = x
22:01:33 <augur> i guess what im looking for is a nice elegant way of computing a saturation point, really
22:01:34 <augur> hmm
22:01:37 <Zekka> Combine those two things.
22:02:00 <Zekka> augur: I'd start with iterate personally
22:02:10 <Maxdamantus> > let a = 42 :: Integer in (fromInteger a, fromInteger b) :: (Int, Double)
22:02:11 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
22:02:11 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
22:02:24 <Maxdamantus> > let a = 42 :: Integer in (fromInteger a, fromInteger a) :: (Int, Double)
22:02:25 <lambdabot>  (42,42.0)
22:02:28 <augur> :t iterate
22:02:29 <lambdabot> (a -> a) -> a -> [a]
22:02:35 <Zekka> :t \f -> dropWhile (length . (<2)) . iterate f
22:02:36 <lambdabot>     Couldn't match type ‘Int’ with ‘Bool’
22:02:36 <lambdabot>     Expected type: [a0] -> Bool
22:02:36 <lambdabot>       Actual type: [a0] -> Int
22:02:45 <Zekka> :t \f -> dropWhile ((<2) . length) . iterate f
22:02:45 <augur> > iterate (+2) 0
22:02:45 <lambdabot> ([a] -> [a]) -> [a] -> [[a]]
22:02:47 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
22:02:51 <augur> aha yes
22:02:57 <Zekka> Er, wait
22:03:03 <augur> :t takeWhile
22:03:04 <lambdabot> (a -> Bool) -> [a] -> [a]
22:03:10 <Zekka> You would need to group them to use my technique
22:03:19 <Zekka> but takeWhile or dropWhile is probably much more appropriate
22:03:33 <Zekka> :t \f x -> dropWhile (/= x) . iterate f
22:03:34 <lambdabot> Eq a => (a -> a) -> a -> a -> [a]
22:03:44 <Zekka> and then you'd take the head
22:03:45 <augur> > takeWhile (not.null) [[0],[1,2],[3],[],[4,5],[6]]
22:03:46 <lambdabot>  [[0],[1,2],[3]]
22:03:49 <augur> bingo
22:03:52 <augur> thats it Zekka!
22:04:02 <Zekka> Thanks, sorry about the false starts
22:04:33 <augur> saturate f x = concat (takeWhile (not.null) (iterate f x))
22:04:45 <augur> @src iterate
22:04:45 <lambdabot> iterate f x =  x : iterate f (f x)
22:04:47 <systemfault> What is “const” for?
22:04:51 <systemfault> :t const
22:04:52 <lambdabot> a -> b -> a
22:05:00 <Zekka> systemfault: It's not really 'for' anything terribly specific
22:05:00 <petercommand> @src const
22:05:00 <lambdabot> const x _ = x
22:05:04 <Zekka> its just a utility function that's often generally useful
22:05:08 <Zekka> it's*
22:05:13 <Zekka> It's sort of like id in that respect
22:05:23 <Zekka> 'id' isn't for anything but oftentimes you find it's a very useful operation
22:05:42 <petercommand> so it takes two arguments and returns the first one
22:05:53 <Zekka> It's 'pure' for ((->) a) if you want trivia
22:05:54 <Zekka> Yes.
22:06:06 <MP2E> huh, interesting
22:06:12 <MP2E> never thought of it like that :P
22:06:14 <enthropy> "\ _ -> x" might be nicer than "const x" though
22:07:30 <Zekka> MP2E: The appliccative instance for ((->) a) is kind of interesting in general (I've given the talk a few times)
22:07:51 <Zekka> :t (->) `asAppliedTo` (undefined :: e -> a -> b)
22:07:52 <lambdabot> parse error on input ‘->’
22:07:57 <Zekka> :t (<*>) `asAppliedTo` (undefined :: e -> a -> b)
22:07:58 <lambdabot> (e -> a -> b) -> (e -> a) -> e -> b
22:08:39 <Zekka> :t (\f g x -> f x (g x)) `asTypeOf` (<*>)
22:08:39 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b
22:09:00 <MP2E> Zekka : can't you define Arrows with the Applicative of ((->) a)?
22:09:00 <Zekka> MP2E: So basically, the primitive S and K combinators are (<*>) and pure respectively for ((->) t)
22:09:14 <Zekka> MP2E: Pretty sure Arrows are equivalent to Applicative, although I don't know Arrow too well
22:10:33 <blipped> Simple question, why does this example terminate? http://lpaste.net/107158
22:10:57 <jle`> every Arrow has an associated Applicaitve instances, if that's what you're asking, MP2E
22:11:08 <jle`> *instance
22:11:09 <blipped> Doesn't the *** have to evaluate before the recursive *** call? And that would mean the list would just rotate?
22:11:14 <Zekka> MP2E: That means you can express any computable function in terms of (<*>) and pure if you're really bored
22:11:31 <Zekka> (http://en.wikipedia.org/wiki/SKI_combinator_calculus )
22:11:56 <glguy> blipped: I don't understand your second question yet, but what inputs were you interested in?
22:12:33 <MP2E> Good to know :P I like Applicative style a lot more than dealing with Arrows
22:12:55 <MP2E> mostly because, despite knowing the typeclasses and common uses for them, I don't feel as though I have developed very good intuition as to what they are
22:12:59 <MP2E> they seem very... *fuzzy*
22:13:18 <blipped> when you call reverse2 why does it terminate? For example [1,2,3,4] reverses, but I don't understand how reverse2 knows when to stop moving values.
22:13:36 <blipped> when is 'list' null?
22:13:58 <Zekka> blipped: When tail list is null?
22:14:38 <Zekka> You mind if I rewrite it in a more conventional style for readability?
22:14:57 <MP2E> blipped : [1,2,3,4] is the same as 1:2:3:4:[]
22:14:59 <MP2E> if that helps
22:15:16 <blipped> but how does (tail list) become null? Doesn't *** have to return a list in order to call reverse2 as reverse2 only accepts one parameter?
22:15:36 <glguy> reverse2 (tail list) *** [head list]  ==== (reverse2 (tail list)) *** [head list]
22:15:41 <Zekka> blipped: Hold up a second, I'll submit it with translations so it's easier to read
22:15:50 <Zekka> I haven't analyzed it too heavily quite yet
22:15:56 <blipped> I would greatly appreciate it.
22:16:11 <Welkin> ====?
22:16:30 <MP2E> 'is the same as'
22:16:39 <blipped> ahhh, glguy, that makes more sense
22:16:42 <Welkin> is that an operator?
22:16:59 <blipped> I am reading it as reverse2 ((tail list) *** [head list])
22:17:03 <glguy> blipped: lst1 *** lst2   just   concatenates lst1 and lst2
22:17:13 <MP2E> Not a parseable Haskell operator, if that's what you mean, no :P
22:17:22 <MP2E> not afaik anyway
22:17:38 <glguy> reverse2 says "reverse of [] is []", and "reverse of (x:xs) is      reverse xs   concatenated with [x]
22:17:43 <blipped> Zekka, no worries, glguy cleared it up.
22:18:11 <Zekka> http://lpaste.net/107158 <- Here's the improvd version if it helps
22:18:33 <Zekka> Your function (***) already has a name
22:19:08 <blipped> Ahh, the *** comes from an example I'm looking at in Beginning Haskell.
22:19:18 <blipped> Thanks!
22:19:27 <Zekka> Yeah. Watch out because (***) is the name of a builtin
22:19:30 <Zekka> @src (***)
22:19:30 <lambdabot> f *** g = first f >>> second g
22:19:37 <Zekka> :t (***)
22:19:38 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:19:47 <jle`> > ((+3) *** show) (5, True)
22:19:48 <lambdabot>  (8,"True")
22:20:27 <jle`> (***) for (->) is :: (a -> b) -> (c -> d) -> ((a, c) -> (b, d))
22:21:00 <Zekka> :t (***) `asAppliedTo` (undefined :: (a -> b))
22:21:00 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
22:21:22 <blipped> Will do
22:21:38 <Darien> @pl (\ x y z p -> x (y p) (z p))
22:21:38 <lambdabot> liftM2
22:21:41 <Zekka> and for fun
22:21:51 <Zekka> > ((+3) `bimap` show) (5, True)
22:21:52 <lambdabot>  (8,"True")
22:21:55 <jle`> > (show *** not) . ((*3) *** (> 4)) $ (5, 9)
22:21:56 <lambdabot>  ("15",False)
22:22:18 <Zekka> So (***) for (->) is bimap for (,)! Handy!
22:23:34 <Zekka> ((***) generalizes the 'function' part, while bimap generalizes the 'both sides' part)
22:24:36 <jle`> in an ideal world we would be using bifunctor for tuple manipulation instead of Arrow
22:25:03 <MP2E> indeed
22:25:04 <Zekka> @hoogle (Bifunctor f, Arrow arr) => arr b c -> arr b' c' -> arr (f b b') (f c c')
22:25:06 <lambdabot> Warning: Unknown class Bifunctor
22:25:06 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
22:25:06 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
22:25:11 <Zekka> Pity!
22:25:32 <jle`> stop typeclass abuse today!
22:25:52 <Zekka> But wait! I think that (->) is too specific!
22:26:08 <jle`> for Bifunctor?
22:26:43 <Zekka> @hoogle (Profunctor q, Bifunctor f, Arrow arr) => q (q (arr b c) (arr b' c')) (arr (f b b') (f c c'))
22:26:43 <lambdabot> Warning: Unknown class Profunctor
22:26:43 <lambdabot> No results found
22:26:57 <Zekka> That is the generality we came to see!
22:27:45 <Zekka> (arbitrary arrows is probably a better fit than arbitrary Profunctors, but I wanted to throw more 'weird' typeclasses into the constraint)
22:27:58 <Zekka> (because I'm fairly sure that's an important step in conceptualizing any Haskell library)
22:28:39 * hackagebot hgl-example 0.0.2 - Various animations generated using HGL  http://hackage.haskell.org/package/hgl-example-0.0.2 (HenningThielemann)
22:31:50 <isomorpheous> Hey, would someone mind looking at my library before I publish it? https://github.com/pharpend/saferoute
22:32:41 <dmj`> isomorpheous: +1 for using a let binding inside a list comp
22:33:10 <isomorpheous> dmj`: as opposed to what?
22:33:33 <isomorpheous> dmj`: and thank you
22:36:31 <solidus-river> how are you supposed to use stepWire inside an IO do block in netwire
22:38:09 <jle`> solidus-river: follow the types :)
22:38:40 <solidus-river> heh, yeah i can just make my wire have an IO monad
22:38:44 <solidus-river> garrr
22:38:51 <solidus-river> its time for me to derive those Category instances
22:38:55 <isomorpheous> solidus-river: monad transformers
22:40:01 <wollw> solidus-river: netwire 5.0?
22:40:24 <jle`> stepWire w s x :: m (Either e b, Wire s e m a b)
22:40:27 <Darien> @pl (\ x y z p q -> x (y p) (z q))
22:40:28 <lambdabot> ((flip . ((.) .)) .) . (.)
22:41:44 <wollw> solidus-river: I can't vouch for it since I'm just starting to mess with netwire and FRP myself, but this is what I currently have open
22:41:47 <wollw> http://lpaste.net/6696623152912400384
22:42:02 <wollw> stepSession and stepWire are working however
22:43:02 <isomorpheous> Question for y'all - what's your second favorite language (assuming Haskell is your favorite)
22:43:23 <MP2E> isomorpheous : hmm that's a good question D:
22:43:24 <nisstyre> isomorpheous: Haskell
22:43:25 <nisstyre> oh sorry
22:43:26 <MP2E> hahah
22:43:39 <isomorpheous> MP2E: I hate to say it, but Ruby
22:43:46 <isomorpheous> That's my favorite
22:43:50 <isomorpheous> *second favorite
22:43:57 <nisstyre> isomorpheous: you're assuming a total ordering on languages?
22:43:58 <isomorpheous> I use it to throw shitty little scripts together
22:43:58 <wollw> Well, the language I use the most outside of Haskell is C...
22:44:05 <wollw> for microcontroller work
22:44:09 <MP2E> wollw : Same. I'm not sure if I want to call that my second favorite though
22:44:19 <nisstyre> wollw: ISO C?
22:44:22 <MP2E> while it is a nice tool, I can't help but find myself complaining about it in comparison to Haskell
22:44:25 <MP2E> heh
22:44:44 <MP2E> hmm
22:44:48 <wollw> nisstyre: well, i'm compiling using gcc and -std=c99
22:44:55 <nisstyre> wollw: use -pedantic
22:45:03 <Cale> isomorpheous: Coq
22:45:31 <wollw> can i turn off binary constant warnings with pedantic?
22:45:36 <Zekka> isomorpheous: Honestly I mostly work between Haskell and whatever I'm doing for my job/experimenting with
22:45:47 <wollw> because binary constants are really useful for working with registers
22:45:56 <isomorpheous> Zekka: I get to use Haskell at my job :D
22:45:58 <solidus-river> http://lpaste.net/107161
22:46:00 <MP2E> Hmm actually I really like C-- but I've never written in it, I thought it'd be fun to make a simple 65816 C-- compiler or something and play around with it
22:46:02 <nisstyre> wollw: -pedantic makes you conform to ISO C
22:46:02 <Zekka> I used to like Python a lot but I don't like it very much now. I can't really think of any languages I particularly like other than it
22:46:03 <solidus-river> theres the ugly error i'm running into
22:46:11 <Zekka> other than Haskell
22:46:21 <nisstyre> wollw: also -Wall, -Wextra, and -Werror are good
22:46:27 <nisstyre> assuming you use GCC
22:46:30 <wollw> yeah, i use -Wall -Wextra and -Werror
22:46:41 <wollw> but I use binary constants too much for -pedantic i think
22:46:48 <isomorpheous> Speaking of Walls and Wextras
22:46:51 <nisstyre> wollw: ISO C is basically just c99 as far as I can tell
22:46:57 <Zekka> isomorpheous: Where do you work, by the way?
22:46:59 <solidus-river> wollw: hmm, maybe i'm trying to be to explicit about my types
22:47:01 <nisstyre> wollw: but -std=c99 just enables those features allowed by it
22:47:11 <nisstyre> at least that is my understanding based on GCC's manual
22:47:14 <isomorpheous> Zekka: A startup with 2 other people
22:47:21 <wollw> you're probably right
22:47:39 <nexion> what's the reasoning behind `div` throwing an exception on divide by 0 while / returning Infinity?
22:47:52 <nisstyre> nexion: IEE 754 I think
22:47:55 <solidus-river> nexion: probably historical
22:48:00 <solidus-river> oh
22:48:03 <solidus-river> maybe not
22:48:05 <nisstyre> *IEEE
22:48:07 <Cale> nexion: That just how IEEE 754 deals with 1/0
22:48:33 <MP2E> solidus-river : well IEEE 754 *is* historical
22:48:38 <Cale> There are floating point representations for Infinity, -Infinity, and NaN
22:48:40 * hackagebot saferoute 0.0.0.0 - A simple type-safe routing library.  http://hackage.haskell.org/package/saferoute-0.0.0.0 (pharpend)
22:48:58 <Cale> which are used to signify those various kinds of numerical failures
22:49:16 <shlevy> Getting this error running cabal haddock: cannot satisfy -package-id network-2.5.0.0-cf48ce29cc9f6301d72644cebc9d6cbb
22:49:24 <shlevy> Even though cabal build works fine
22:50:05 <johnw> shlevy: hey
22:50:10 <johnw> shlevy: you were looking for me before?
22:50:36 <nexion> ty
22:51:00 <Cale> shlevy: Not sure exactly, but maybe try ghc-pkg list -v network
22:51:12 <Cale> shlevy: and check that there's a package with that hash installed
22:51:20 <shlevy> johnw: Yeah, figured it out though :)
22:53:00 <augur> :t lex
22:53:01 <lambdabot> ReadS String
22:53:04 <augur> o_O
22:53:07 <augur> @src lex
22:53:07 <lambdabot> Source not found. My pet ferret can type better than you!
22:53:24 <augur> you know, i really find lambdabot's insults hurtful
22:53:49 <Welkin> > read "lol"
22:53:50 <augur> something must be done about this. we must curb this awful behavior.
22:53:51 <lambdabot>  *Exception: Prelude.read: no parse
22:53:58 <Welkin> > read "5" :: Int
22:54:00 <lambdabot>  5
22:54:06 <Welkin> > read lol
22:54:07 <lambdabot>  Not in scope: ‘lol’
22:54:08 <lambdabot>  Perhaps you meant ‘log’ (imported from Prelude)
22:54:10 <augur> > lex "foo"
22:54:11 <Zekka> > read "5"
22:54:11 <lambdabot>  [("foo","")]
22:54:12 <lambdabot>  *Exception: Prelude.read: no parse
22:54:19 <Welkin> > show "lol"
22:54:20 <lambdabot>  "\"lol\""
22:54:20 <Zekka> I wonder what it tries to read things as if you don't specify
22:54:22 <augur> > lex "foo bar baz"
22:54:23 <lambdabot>  [("foo"," bar baz")]
22:54:25 <augur> ahh
22:54:27 <augur> i see
22:54:34 <jle`> Zekka: ()
22:54:37 <Cale> augur: http://www.haskell.org/onlinereport/standard-prelude.html#$vlex
22:54:43 <Zekka> > read "()"
22:54:45 <lambdabot>  ()
22:54:47 <Zekka> jle`: Why's it do that?
22:54:52 <jle`> defaulting rules
22:54:55 <jle`> i guess
22:55:05 <jle`> just like 1 defaults to Integer
22:55:06 <Zekka> What, so it throws up instead of a nasty type-related error?
22:55:10 <Welkin> > show lol
22:55:11 <lambdabot>  Not in scope: ‘lol’
22:55:11 <lambdabot>  Perhaps you meant ‘log’ (imported from Prelude)
22:55:22 <jle`> Zekka: typeclasses can be assigned default instances
22:55:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/src/GHC-Read.html#lex -- actual implementation here
22:55:25 <Fuuzetsu> Zekka: what type-related error would you want?
22:55:27 <augur> Cale: *nod*
22:55:35 <Fuuzetsu> > readMaybe "5"
22:55:36 <lambdabot>  Not in scope: ‘readMaybe’
22:55:43 <Fuuzetsu> @hoogle maybeRead
22:55:44 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
22:55:53 <Zekka> Fuuzetsu: Not being able to deduce Show given Read?
22:56:00 <jle`> sometimes you'll use typeclasses that don't have default instances...and then you'll get that error
22:56:05 <Zekka> Or something else related to 'all I know is that the return value is a Read-thing'
22:56:13 <jle`> "cannot deduce type 'm0' or something"
22:56:15 <augur> Cale: really i just wanted to know what the heck prelude was doing conflicting with my parser :)
22:56:21 <Zekka> Yeah, something like what jle` 's saying.
22:56:22 <jle`> try compiling main = show mempty
22:56:30 <jle`> Monoid doesn't have defaulting behavior
22:56:33 <jle`> but Read does
22:56:37 <Zekka> > show mempty
22:56:38 <lambdabot>  "()"
22:56:40 <jle`> oh
22:56:42 <Fuuzetsu> yeah but by default it's trying to go with () so it just crashes when it can't read it
22:56:50 <jle`> maybe it does
22:56:57 <Zekka> Fuuzetsu: Yeah, I'm arguing that that's a silly default
22:57:04 <jle`> yeah, it's that way on ghci too...
22:57:06 <solidus-river> so it just doesnt like my session constraints i guess
22:57:07 <solidus-river> hmm
22:57:15 <jle`> but i always run into it for compiled programs.  how weird
22:57:38 <Fuuzetsu> Zekka: it's silly but it's not a problem in practice because if you use it in actual code, it will be inferred for you
22:57:57 <Fuuzetsu> it's only in toy situations like this one where it looks like a problem
22:58:00 <Zekka> Fuuzetsu: Yeah, point.
22:58:18 <Zekka> it'll probably either deduce the correct typesig or (in casees like monomorphism restriction) deduce a hilariously wrong one that breaks the rest of the program
22:58:57 <jle`> the correct type
22:59:06 <jle`> :)
22:59:10 <Fuuzetsu> hopefully your types everywhere else are clearly stated so the latter can't happen
23:01:33 <Cale> jle`: Yeah, the restriction for numeric defaulting to apply is that all the type classes constraining the ambiguous type variable must be Prelude classes, and at least one of the classes constraining it must be a subclass of Num
23:02:10 <Zekka> :t ((read) :: Integral a => String -> a) 1
23:02:11 <lambdabot>     Could not deduce (Read a1) arising from a use of ‘read’
23:02:11 <lambdabot>     from the context (Integral a)
23:02:11 <lambdabot>       bound by the inferred type of it :: Integral a => a at Top level
23:02:20 <Zekka> :t ((read) :: (Read a, Integral a) => String -> a) 1
23:02:21 <lambdabot>     Could not deduce (Num String) arising from the literal ‘1’
23:02:21 <lambdabot>     from the context (Read a, Integral a)
23:02:21 <lambdabot>       bound by the inferred type of it :: (Read a, Integral a) => a
23:02:34 <Zekka> Oh really now?
23:02:39 <Zekka> :t ((read) :: (Read a, Integral a, Num a) => String -> a) 1
23:02:40 <lambdabot>     Could not deduce (Num String) arising from the literal ‘1’
23:02:40 <lambdabot>     from the context (Read a, Integral a)
23:02:40 <lambdabot>       bound by the inferred type of it :: (Read a, Integral a) => a
23:02:58 <Zekka> oh, I see what's wrong. I'll switch to PMs till I get this right
23:06:53 <ab9rf> you're asking it to apply a particular instance of read to 1, but it can't find an instance of Num String
23:07:06 <ab9rf> that's because there is no instance of Num String
23:08:21 <lithiumdeuteride> earlier, i asked about Haskell on Windows, and folks seemed to think it wasn't a good idea
23:08:53 <lithiumdeuteride> now, i understand that if you're using Haskell to write some fancy server code, it's gonna be a Linux server
23:09:04 <ab9rf> i do haskell on windows all the time
23:09:06 <begriffs> Anyone know how to un-nest a string in Haskell? e.g. turn "\"Hi\"" into "Hi" ?
23:09:15 <dmj`> lithiumdeuteride: I'm using haskell on windows, and using concurrency heavily
23:09:16 <solidus-river> i've added time to my cabal file under build depends but cabal install --only-dependencies does not install it yet cabal repl complains that time is a hidden package
23:09:32 <lithiumdeuteride> but what if i want to write a simple program for end users
23:09:42 <ab9rf> in fact, i just wrote a little program to do some fairly simple data transformation for a bespoke personal purpose, on windows
23:09:42 <lithiumdeuteride> and the majority of them are on Windows
23:09:56 <Zekka> lithiumdeuteride: I've been able to get my Haskell code to run on Windows without too much aroundscrewery
23:10:14 <Zekka> some projects have been more difficult than others but none were really hard
23:10:17 <lithiumdeuteride> but there is some friction?
23:10:17 <ab9rf> lithiumdeuteride: so just do that.  ghc produces standalone executables, although you might need some DLLs if you use certain external libraries
23:10:37 <Zekka> lithiumdeuteride: About a half hour in the worst case I've personally had
23:10:49 <Zekka> Although I imagine there must be at least some others who have had more trouble
23:10:58 <Zekka> because my projects are generally pretty small
23:11:30 <dmj`> issue on windows is that network I/O isn't interruptible I believe, and SIGINT doesn't really exist, so bracket won't call its release function on anything but an exception
23:11:38 <lithiumdeuteride> what tools would i need to get started in a Windows environment?
23:11:41 <ab9rf> lithiumdeuteride: gets mre interesting if you try to do anythingwith a GUI
23:11:54 <ab9rf> lithiumdeuteride: honestly, i use a text editor and the haskell platform
23:11:54 <Welkin> lithiumdeuteride, haskell platform
23:11:57 <Zekka> lithiumdeuteride: GHC and a text editor? I'm not sure what else you would need (other than stuff like Cabal)
23:12:08 <dmj`> lithiumdeuteride: cygwin is nice with emacs, can install haskell mode. Use mingw for compiling though
23:12:31 <ab9rf> the windows haskell platform includes enough of mingw to make a working build environment
23:12:38 <ab9rf> i use notepad++ for editing, it has a haskell mode
23:12:48 <lithiumdeuteride> i've got notepad++
23:13:13 <lithiumdeuteride> i was hoping for something more closely integrated with GHC(i)
23:13:14 <blipped> I just started with haskell and use sublime with haskell plug-in or the command-line.
23:13:21 <isomorpheous> It's a bit creepy, my package has no bug reports, forks, feature requests, emails, or anything, but it's getting a lot of downloads
23:13:24 <dmj`> I wouldn't use haskell-platform. Just wget cabal, then ghc. Otherwise you'll end up with some weirdness in the Roaming_Data folder
23:13:50 <Welkin> the other option is to run linux in a vm
23:13:55 <ab9rf> dmj`: that hasn't been a problem for me
23:13:56 <isomorpheous> It's a censorship program, so the only explanation I can come up with is that some government agency is using it to censor dissidents
23:13:57 <Welkin> or just run linux
23:14:05 <isomorpheous> what Welkin said
23:14:15 <ab9rf> dmj`: and avoids UAC issues on windows 6 and later
23:14:36 <kazagistar> did you guy miss the intro? he is building software for windows desktop end users
23:14:46 <isomorpheous> kazagistar: fuck windows end users
23:14:56 <kazagistar> so "run it in a linux VM" is not a solution
23:14:57 <isomorpheous> kazagistar: and, to answer your question, yes
23:15:12 <isomorpheous> kazagistar: I just had to join the linux bandwagon
23:15:26 <Welkin> why does that matter?
23:15:32 <Welkin> you can develop on any platform
23:15:43 <lithiumdeuteride> i'm not even building software
23:15:43 <dmj`> ab9rf: are you using emacs on windows?
23:15:46 <isomorpheous> Welkin: evidently, you can't
23:16:02 <blipped> Windows, Linux, both have their benefits and faults.
23:16:11 <lithiumdeuteride> i want to build toy programs, with the hope of getting good enough to actually write something someone would use
23:16:15 <Welkin> haskell is easiest to set up on linux, mac less so
23:16:19 <Welkin> I never tried on windows
23:16:32 <zorg24> its not to hard on windows
23:16:35 <zorg24> too*
23:17:01 <blipped> you just run the executable.
23:17:17 <Welkin> blipped, for development
23:17:21 <lithiumdeuteride> what obstacles are there in trying to take code developed in a Linux environment and compile it to run in Windows?
23:17:36 <zorg24> yeah and you might need to add something to PATH not sure if the installer does that
23:17:48 <triliyn> The problem on windows is that if you want to use various libraries, you need to install the C libraries that they bind to
23:17:49 <Zekka> lithiumdeuteride: Depending on code that's not Haskell can be a pain
23:18:13 <Zekka> It's a pain in any language, but it's a little more of a pain in Haskell because not a lot of people are particularly dedicated to the problem
23:18:17 <triliyn> And ghci doesn't do that, and they can sometimes be annoying to get without a package manager, and sometimes you won't be able to find development binaries for windows
23:18:33 <dmj`> lithiumdeuteride: the C libraries might be different. Getting HsOpenSSL to link with the windows libraries took time to get right
23:18:34 <triliyn> Everything else is pretty easy
23:18:38 <kazagistar> lithiumdeuteride: depends on how much OS specific stuff they use, GUIs might get especially annoying unless you use Qt or web or something
23:18:56 <triliyn> *cabal
23:18:58 <triliyn> Not ghci
23:19:06 <Welkin> use as many cross-platform libraries as possible
23:19:07 <lithiumdeuteride> let's say i wanted to make a ridiculously simple command line calculator
23:19:18 <Welkin> I don't see any benefit in using windows-specific stuff
23:19:26 <zorg24> that would be trivially cross platform
23:19:36 <lithiumdeuteride> ok, that's what i wasn't sure about
23:19:44 <lithiumdeuteride> i figured GUI stuff would run into problems
23:19:52 <zorg24> yeah that always does
23:19:59 <Welkin> not with SDL
23:20:12 <zorg24> what's SDL
23:20:41 <Welkin> http://www.libsdl.org/
23:20:42 <dmj`> Welkin: intellesting....
23:20:54 <lithiumdeuteride> i understand that Linux is a pillar of dependability for programmers
23:22:04 <zorg24> What does that have to do with GUI's?
23:22:07 <dmj`> http://hackage.haskell.org/package/SDL
23:22:11 <Welkin> https://en.wikibooks.org/wiki/Haskell/GUI
23:22:16 <zorg24> sounds interesting though
23:22:26 <lithiumdeuteride> are the Haskell gurus simply more concerned with their own productivity than with popularization, or are they holding out for a Linux-defeats-all endgame?
23:23:08 <Welkin> most developers use windows or mac
23:23:21 <Welkin> er
23:23:28 <Welkin> most developers use linux or mac
23:23:46 <lithiumdeuteride> writing programs for Linux and/or Mac, i take it
23:23:56 <zorg24> ok that makes way more sense
23:24:06 <Welkin> windows isn't too popular with developers
23:24:15 <Welkin> unless they are .NET developers
23:24:25 <triliyn> lithiumdeuteride: in my experience, the main problem you'll have developing on windows is compiling C libraries
23:24:34 <lfairy> I think web applications are the rage right now, which favors Linux greatly
23:24:35 <zorg24> yeah only people I can think of is people at Microsoft and .NET people
23:24:40 <triliyn> Not anything to do with haskell in particular
23:25:30 <benzrf> id just like to interject for a moment
23:26:26 <Welkin> > :t id just
23:26:27 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:26:30 <Welkin> > :t id Just
23:26:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:26:37 <Welkin> :t id Just
23:26:37 <lambdabot> a -> Maybe a
23:27:23 <Welkin> > id Just "benzrf"
23:27:24 <lambdabot>  Just "benzrf"
23:27:37 <petercommand> @src id
23:27:37 <lambdabot> id x = x
23:27:58 <lithiumdeuteride> so if someone wanted to write a video game for Windows, but take advantage of Haskell's high-level abilities, they'd write an interface with .NET, with Haskell stuff on top?
23:28:13 <Welkin> no lithiumdeuteride
23:28:19 <Welkin> if they wanted to write a videogame they would use SDL
23:28:25 <Welkin> it is fully cross platform
23:28:31 <Welkin> it even runs on raspberry pi
23:29:04 <lithiumdeuteride> you lost me there
23:29:06 <Welkin> you don't need anything from .NET
23:29:13 <lithiumdeuteride> what's SDL?
23:29:15 <Welkin> just use haskell
23:29:34 <Welkin> SDL is a library to interact with video/sound cards and input/output devices
23:29:36 <lfairy> lithiumdeuteride: it's a cross platform media library
23:29:49 <lfairy> it does graphics and input and sound and stuff
23:29:56 <petercommand> are the functor operators left-associative?
23:30:02 <lithiumdeuteride> ah, understood
23:30:10 <petercommand> like <*> or <$>
23:30:14 <Welkin> functor operators?
23:30:17 <Welkin> of, applicatives
23:30:34 <petercommand> Welkin: i mean <*> and ($>
23:30:52 <Welkin> <$> is just fmap
23:31:08 <petercommand> yep
23:31:17 <lfairy> petercommand: use :info (<$>) in ghci
23:31:17 <Welkin> let's see
23:31:27 <lfairy> no need to ask here
23:31:45 <petercommand> ok
23:31:45 <triliyn> For these particular examples you should also be able to deduce it from their types
23:31:51 <triliyn> :t (<*>)
23:31:52 <petercommand> i see
23:31:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:32:02 <Welkin> > (+) <$> Just 2 <*> Just 4 :: Expr
23:32:03 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
23:32:04 <lambdabot>              with actual type ‘Data.Maybe.Maybe b0’
23:32:17 <Welkin> > f <$> Just 2 <*> Just 4 :: Expr
23:32:18 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
23:32:18 <lambdabot>              with actual type ‘Data.Maybe.Maybe b0’
23:32:20 <lfairy> Welkin: Maybe Expr?
23:32:24 <Iceland_jack> > (+) <$> Just 2 <*> Just 4 :: Maybe Expr
23:32:25 <lambdabot>  Just (2 + 4)
23:32:26 <Welkin> > f <$> Just 2 <*> Just 4 :: Maybe Expr
23:32:27 <lambdabot>  Just (f 2 4)
23:32:45 <dmj`> lithiumdeuteride: https://www.youtube.com/watch?v=gVLFGQGRsDw
23:32:52 <dmj`> game written in haskell on windows
23:32:54 <Welkin> > f <$> Just 2 <*> Just 4 <*> Just 7 :: Maybe Expr
23:32:56 <lambdabot>  Just (f 2 4 7)
23:33:12 <lithiumdeuteride> what prevents this SDL library from serving as a platform-independent way of writing any type of program?
23:33:15 <Welkin> > f <$> Just 2 <*> Nothing <*> undefined :: Maybe Expr
23:33:17 <lambdabot>  Nothing
23:33:20 <Welkin> yes
23:33:24 <Welkin> it is left associative
23:34:22 <augur> lithiumdeuteride: what SDL library?
23:34:38 <augur> oh i see
23:34:44 <augur> further in the scrollback
23:34:53 <Welkin> lithiumdeuteride, it is normally used for games
23:35:35 <lithiumdeuteride> i understand games have graphics, sound, and inputs, but those could describe many programs
23:36:07 <lithiumdeuteride> why not write a 3D modeling program (as if it were a video game) using SDL, and gaining total platform-indpendence?
23:36:11 <ReinH> lithiumdeuteride: Lack of native look-and-feel, for one.
23:36:38 <Welkin> things like Qt specialize in GUI building
23:36:50 <ReinH> Lack of any look-and-feel, for that matter.
23:36:51 <lithiumdeuteride> i've heard of Qt
23:37:25 <lithiumdeuteride> ah, so you'd be building custom graphics for everything, instead of relying on native button design and functionality?
23:37:33 <Welkin> yes
23:38:24 <lithiumdeuteride> judging by what people are saying, this native look and feel comes at a price in Windows
23:38:24 <ReinH> Theoretically there's no reason you couldn't write GUI libraries on top of SDL. People have done so but they tend to be pretty rudimentary.
23:38:32 <ReinH> Everything comes at a price in Windows.
23:38:36 <ReinH> Including, well, Windows.
23:38:46 <lithiumdeuteride> touche
23:39:10 <Welkin> web apps are an option
23:39:21 <Welkin> depending on the type of program you are building
23:39:40 <lithiumdeuteride> i'm not even building anything in particular yet, just trying to learn the language
23:39:55 <lithiumdeuteride> but i figure more learning will occur if centered on a specific task
23:39:56 <Welkin> don't forget about mobile (iOS/Android) either
23:40:12 <Welkin> arguably, iOS and Android are more important platforms than windows
23:40:14 <lithiumdeuteride> so i figure i ought to pick something easy and do it
23:40:22 <Welkin> and the web is certainly a more important platform than windows
23:41:04 <Welkin> lithiumdeuteride, https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
23:41:24 <Welkin> that is a good project for beginners once they have some basic knowledge (read through LYAH)
23:41:27 <konzi> maybe you should check out project euler for programming puzzles, that what I enjoy doing when learning a new language
23:41:29 <Welkin> @where LYAH
23:41:30 <lambdabot> http://www.learnyouahaskell.com/
23:41:42 <Welkin> project euler is also great for haskell
23:42:18 <lithiumdeuteride> my programming background is scientific, essentially limited to Mathematica / Matlab
23:42:40 <lithiumdeuteride> of which the former is by far my favorite
23:42:41 <Welkin> lithiumdeuteride, then writing a programming language would be something different and likely fun for you
23:42:50 <kazagistar> which reminds me that I need to finish my ST-based sieve of eratosthenes
23:42:59 <Welkin> scheme is pretty easy to implement
23:43:09 <Welkin> kazagistar, haha
23:43:11 <lithiumdeuteride> and since learning it was based largely on Lisp, looking into Lisp, discarding it, and finding Haskell
23:43:16 <Welkin> I remember writing a couple sieves
23:43:25 <Welkin> eratosthenes and sundaram
23:43:37 <lithiumdeuteride> i figured i had better get started before
23:43:56 <kazagistar> mine is a block sieve, built for cache efficiency :P
23:44:06 <Welkin> yeah, mine was not efficient
23:44:26 <lithiumdeuteride> before my brain becomes a sieve
23:44:28 <solidus-river> this is getting a bit unruly
23:44:32 <solidus-river> how do i type alias something like
23:45:24 <solidus-river> (Monoid s, Monad m) => Wire (s -> Timed NominalDiffTime s) () m (Set Key) Output
23:45:54 <solidus-river> as far is i can tell you cant put class restrictions on a type alias
23:46:01 <solidus-river> but iwthout those i cant make my functions
23:46:05 <solidus-river> but that type is ridiculous
23:46:32 <Welkin> why can't you put class restrictions on an alias?
23:46:47 <solidus-river> Welkin: i guess i've just never seen it done?
23:47:00 <solidus-river> type newtype = (Monoid m) => m ()
23:47:46 <jle`> solidus-river: better to just put the restrictions on the function itself, right?
23:47:47 <solidus-river> yeah that wont work in ghci
23:48:03 <solidus-river> jle`: yeah but if i alias it...
23:48:06 <enthropy> it works if those constrained type variables are not mentioned on the left hand side (and you're happy with what happens when you use -XRankNTypes)
23:48:09 <solidus-river> i cant put restrictions on the types inside the alias
23:48:17 <solidus-river> so i still need to restrict s and m
23:48:26 <solidus-river> but i dont want to type that whole thing everywhere i use a GameWire
23:48:39 <solidus-river> or do i just have to type it
23:48:45 <jle`> your alias has to contain any free types, unless you use existential quantification
23:49:05 <solidus-river> ohhh
23:49:15 <jle`> as in you can't do type MyWire = Wire (s -> Timed NominalDiffTime s) () m (Set Key) Output
23:49:22 <tnks> solidus-river: be careful about putting a type restriction on a data type.
23:49:29 <solidus-river> type GameWire s m = Wire (s -> Timed NominalDiffTime s) () m (Set Key) Game
23:49:32 <jle`> you ahve to do type MyWire s m = Wire (s -> Timed NominalDiffTime s) () m (Set Key) Output
23:49:33 <solidus-river> then i can restrict s / m still
23:49:33 <jle`> yeah
23:49:38 <jle`> in the actual function call
23:49:49 <jle`> if you want you can assign your restriction to an alias
23:50:03 <solidus-river> ooh, didn't know you coul alias a restriction
23:50:04 <jle`> but i don't think that's necessary with only two
23:50:18 <jle`> might not be worth it
23:50:28 <solidus-river> so the last part i need to undestand is how to apply a monad transformer to a wire to get data out of it within an IO block
23:50:31 <solidus-river> i hope
23:50:40 <solidus-river> if i can get this to compile up to that point
23:50:58 <Welkin> solidus-river, are you using any tutorials for netwire?
23:51:13 <jle`> solidus-river: what is your wire's monad
23:51:19 <jle`> you get an m (something)
23:51:24 <Welkin> I'm looking for some good ones
23:52:17 <solidus-river> Welkin: there aren't really any good ones :\
23:52:33 <solidus-river> but everyone in here is helpfull
23:52:37 <solidus-river> and i'll be around :)
23:52:51 <solidus-river> jle`: yeah but is it safe just to replace that m with IO
23:52:57 <solidus-river> i guess i don't understand what that m is doing
23:53:06 <jle`> just set it to Identity
23:53:07 <solidus-river> which is why i should write the category instances
23:53:09 <jle`> until you need it
23:53:24 <jle`> then stepWire will give you Identity (Either e b, Wire s e Identity a b)
23:53:27 <jle`> and then you can use runIdentity
23:53:37 <jle`> to get the (Either e b, Wire s e Identity a b) out
23:54:02 <jle`> if all of your type signatures for all of your functions --- and your main arrow --- are (Monad m) => ...
23:54:06 <jle`> then you can just use Identity
23:54:46 <solidus-river> <- runIdentity $ stepWire game_wire session
23:54:49 <jle`> which can be said to be the Monad that offers nothing else besides just being a contextlus monad
23:54:51 <solidus-river> wtf does runIdentity do?
23:55:01 <jle`> solidus-river: have you ever used Identity?
23:55:06 <solidus-river> jle`: now
23:55:10 <solidus-river> * not till now :)
23:55:11 <jle`> newtype Identity a = { runIdentity :: a }
23:55:17 <jle`> it's just a dumb wrapper
23:55:21 <jle`> with a Monad instance
23:55:35 <jle`> fmap f (Identity x) = Identity (f x)
23:55:41 <jle`> Identity x >>= f = f x
23:55:53 <jle`> Identity f <*> Identity x = Identity (f x)
23:55:56 <jle`> it's like Maybe w/o the Nothing
23:56:02 <jle`> pure = Identity
23:56:24 <jle`> ...if you don't know about newtypes, you can imagine it as data Identity a = { runIdentity :: a}, and it's only slightly different
23:56:37 <jle`> so if stepWire gives you Identity x
23:56:39 <solidus-river> hehheh, this is still looking a bit ridiculous
23:56:44 <jle`> and you want the x
23:56:45 <solidus-river> so in the end in the do block i'd have
23:56:47 <jle`> then you can say
23:57:01 <jle`> let res = runIdentity (Identity x)
23:57:04 <jle`> and res = x
23:57:22 <jle`> remember record accessors... runIdentity :: Identity a -> a
23:57:35 <solidus-river> yeah i guess i just shouldn't be steppin gwires within a o black
23:57:50 <jle`> so if stepWire gives you Identity (Either e b, Wire s e m a b)
23:58:09 <jle`> then runIdentity (stepWire w s x) :: (Either e b, Wire s e m a b)
23:58:10 <solidus-river> i guess its valid to do a straight assignment within a do
23:58:17 <jle`> you can use a let = ...
23:58:37 <solidus-river> what if i want to step different wires depending on IO
23:58:44 <jle`> you can do that in a do block
23:59:22 <jle`> do { w <- iosomething; let x = f w; g x }
