00:06:57 <gamegoblin> Is the only difference between hGetSome and hGetNonBlocking is that hGetSome will block when there is no input at all?
00:08:12 * hackagebot atomic-primops 0.6.0.6 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.6.0.6 (RyanNewton)
00:08:12 * hackagebot haskmon 0.1.0.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  http://hackage.haskell.org/package/haskmon-0.1.0.0 (pjrt)
00:23:41 <angerman> what would be a pratical application of the maybe applicative to solve a real problem?
00:24:23 <johnw> (,) <$> lookup k1 map <*> lookup k2 map
00:24:38 <johnw> writing that without at least the maybe monad is annoying
00:26:36 <angerman> johnw: ok, i'll have to think about that a little to build up a nice example.
00:27:35 <angerman> johnw: for the ((->) a) applicative, the tiny evaluator from the Applicative programming with effects made a great example (at least that's what I think.)
00:27:49 <trap_exit> wtf
00:28:04 <trap_exit> I'm starting to become convinced that one can not have declarative programming
00:28:06 <trap_exit> without having laziness
00:28:27 <angerman> So I'm trying to work my way through various applicatives and try to get a better understanding for their application to real problems.
00:44:08 <johnw> angerman: have you read Gershom's three articles on applicatives?
00:44:20 <johnw> or what ocharles has written about his query applicative?
00:44:23 <jle`> angerman: sometimes you just want to apply an (a -> b -> c) over a Maybe a and a Maybe b
00:44:48 <jle`> angerman: what is a time in the past when you have received a Maybe value?
00:44:50 <angerman> johnw: not sure, got the links?
00:45:14 <johnw> google it
00:46:21 <dfeuer> Ugh. I guess this is understandable, but GHC seems rather more reluctant to inline something if that thing is exported from the module.
00:46:42 <angerman> johnw: alright, thanks.
00:47:06 <johnw> sorry, i could do it ,but I'm into something else now
00:47:17 <dfeuer> So if x uses y, adding or removing y from the export list can make x go slower or faster.
00:47:25 <angerman> jle`: what do you mean by time in the past?
00:47:44 <angerman> johnw: no, it's prefectly fine. Just though you might have had them handy anyway :D
00:47:52 <jle`> angerman: have you ever ran into a Maybe value ever in your haskell experience?
00:48:41 <angerman> jle`: yes. Most often when retrieving stuff.
00:48:50 <dfeuer> The future looks bleak. Formation and evaporation of black holes, neutron decay, possible proton decay .... Things will get very boring, they say.
00:48:57 <jle`> angerman: can you give a concrete example?  so i can work with it
00:49:27 * dfeuer gives jle` some concrete.
00:49:32 <jle`> :P
00:49:40 <angerman> jle`: on top of my head, right now, no, sorry. But will get back to you when I hit it again.
00:49:44 <jle`> angerman: let's say you watn to retrieve two Persons from a database
00:49:50 <jle`> lookup :: Name -> Maybe Person
00:50:00 <jle`> and you had a compatibility function (Person -> Person -> Double)
00:50:08 <jle`> where you give it two people and it tells you their compatibility
00:50:19 <jle`> let's say you had two Names, and your database
00:50:28 <jle`> how would you find the compatibility between those two Names?
00:50:45 <jle`> the compatibility is Maybe Double, because one or both of those names might not exist in the database
00:51:23 <angerman> I just started writing down what I learnd so far in Haskell yester day night. And started with data types, motivated the use of type classes and started introducing the Fuctor. From there build my way int Applicative, and am now trying to support the use of applicatives by illustrating their use on concrete examples, which try to solve real, but tiny problems.
00:51:58 <jle`> yeah, so i'm trying to give you an illustration of a nice concrete example :)
00:52:01 <jle`> do you understand the question?
00:52:19 <angerman> yep, it's similar to those stupid sms games they have on MTV.
00:52:31 <jle`> i have lookup :: Name -> Maybe Person, and compatibility :: Person -> Person -> Double
00:52:38 <jle`> and you have two Names
00:53:07 <jle`> name1 and name2
00:53:25 <jle`> how would you find the compatibility between the People represented by those two names?
00:53:45 <jle`> the compatibility is Maybe Double, because one or either of the names might not correspond to Persons in the database
00:55:06 <jle`> compatibilityByName :: Name -> Name -> Maybe Double.  can you implement it based on lookup :: Name -> Maybe Person, and compatibility :: Person -> Person -> Double ?
00:55:15 <jle`> one way would be to use pattern matching on the two lookups
00:57:15 <angerman> so, traditionally (procedually) I'd probably do something like let { person1= lookup name1; person2 = lookup name2 } in case (person1, person2) of { (Just a, Just b) -> Just $ calculateComatibility a b; _ -> Nothing }
00:57:39 <jle`> angerman: up
00:57:41 <jle`> yup
00:57:43 <jle`> that's good :)
00:57:45 <angerman> or write some if then else if ... tree
00:57:59 <jle`> or
00:58:01 <jle`> consider this:
00:58:10 <jle`> compatibility <$> lookup name1 <*> lookup name2
00:58:13 <jle`> or:
00:58:13 * hackagebot linklater 2.0.0.0 - The fast and fun way to write Slack.com bots  http://hackage.haskell.org/package/linklater-2.0.0.0 (hao)
00:58:21 <jle`> liftA2 compatibility (lookup name1) (lookup name2)
00:58:29 <jle`> let's see the definition of (<*>) for Maybe:
00:58:37 <jle`> Just f <*> Just x = Just (f x)
00:58:43 <jle`> _ <*> _ = Nothing
00:59:06 <jle`> so there would be a concrete example of the usefulness of the Maybe applicative instance
01:08:14 * hackagebot linklater 2.0.0.1 - The fast and fun way to write Slack.com bots  http://hackage.haskell.org/package/linklater-2.0.0.1 (hao)
01:18:15 * hackagebot linklater 2.0.0.2 - The fast and fun way to write Slack.com bots  http://hackage.haskell.org/package/linklater-2.0.0.2 (hao)
01:28:02 <johnw> when is HashMap typically faster than Map?
01:41:37 <prinsen> Im using the Network.HTTP.Client library, how do I decode a response in the form key1=val1&key2=val2?
01:42:08 <prinsen> To some haskell type, like with Aeson.decode
01:48:36 <xinming> Hi, Just curious,   why won't      test_list = [<new_line>  1, 2, 3]      work     but      test_list = [1,<new_line> 2, 3]     worked please?
01:49:04 <xinming> The first one get a parser error.
01:49:25 <xinming> Just curoius, Because I don't know why haskell had this behaviour.
01:51:32 <xinming> It's strange that haskell seems to enforce the ,  to be put in front of the item in list if the item is in a separated line
01:52:28 <xinming> Not enforced, My mistake, But still wonders why  the  newline after  [ won't work
01:56:14 <xinming> understood, needs idention in new line *ALWAYS*
02:02:11 <augur_> anyone know what types are supported through the FFI?
02:02:46 <augur_> can i output declared types (like record types) to C through the FFI?
02:12:59 <johnw> yes
02:13:24 <johnw> they are basically just names for offsets within a memory block
02:14:50 <augur_> johnw: is there a good place to read up on how to do this sort of thing?
02:15:03 <johnw> can you describe a bit more of your situation?
02:15:19 <ruuns> chrisdone, i have seen on github a wrapper for freenect from u :) how's your experience with it?
02:16:08 <augur_> johnw: well, so i have a type   data Cmd = Cmd { pred :: Maybe String, args :: Map String [Int] }
02:16:36 <augur_> johnw: and i'd like to do something like return one of these to some C code
02:16:36 <johnw> i'd take a look at how Bindings-DSL encodes records
02:16:49 <augur_> or maybe to ObjC code
02:17:34 <johnw> if I have a list, what's the fastest way to return just duplicated elements in it?  I.e., [1,2,3,4,4,4] returns [4]
02:17:59 <jle`> xinming: can you post what doesn't work? it might depend on the indent of the next line
02:18:08 <jle`> also, for issues like this, you can always read the Haskell Report :)
02:18:42 <augur_> johnw: probably fold over the list producing two sets, one is list elements, the other is dupes?
02:18:46 <augur_> or at least, a set and a list
02:20:01 <augur_> johnw: also probably you might be able to just do a foldr + filter, and maybe GHC can do fusion to get that automatically
02:20:11 <augur_> maybe.
02:21:24 <johnw> the method I'm using now is xs \\ nub xs
02:21:51 <johnw> http://stackoverflow.com/questions/3710976/counting-unique-elements-in-a-list
02:22:55 <augur_> filter (`member` fromList xs) xs
02:23:07 <augur_> but you'd want to do it in one pass not two
02:23:24 <augur_> but thats not a huge cost, doing it in two passes
02:23:32 <augur_> member is probably not the right name
02:23:38 <augur_> @hoogle a -> Set a -> Bool
02:23:38 <xinming> jle`: Yes, I just now figured it, The next line needs to be indented so the syntax will work. But I got habit from perl which is put the enclosing ] at the variable name start.
02:23:40 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
02:23:41 <lambdabot> Data.Set notMember :: Ord a => a -> Set a -> Bool
02:23:41 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
02:23:44 <augur_> oh, it is!
02:24:04 <augur_> oh, no that definition wouldnt work, hah :)
02:24:16 <augur_> nor will yours, johnw
02:24:32 <augur_> nub xs has all the elements of xs, so xs \\ nub xs will just remove everything
02:24:35 <johnw> > [1,2,3,4,4,4] \\ nub [1,2,3,4,4,4]
02:24:37 <lambdabot>  [4,4]
02:24:42 <augur_> w..what
02:24:47 <augur_> thats weird
02:25:04 <johnw> these are lists, not sets
02:25:04 <augur_> @src (\\)
02:25:05 <lambdabot> (\\) = foldl (flip delete)
02:25:37 <johnw> maybe concatMap tail . group . sort is the easiest
02:25:41 <xinming> http://lpaste.net/108210    <--- Anyone here can help me about this? When the code is loading
02:25:54 <xinming> I got err which is    Multiple declarations of `clientName'
02:25:56 <augur_> johnw: i understand that but i wouldnt expected (\\) to delete all elements not just the first occurrence
02:26:03 <augur_> > [1,2,1] \\ [1]
02:26:05 <lambdabot>  [2,1]
02:26:14 <augur_> > [1,2,1] \\ [1,1]
02:26:16 <lambdabot>  [2]
02:26:22 <xinming> Just curious in this case, How do we add the clientName matching for Individual in this case?
02:26:33 <augur_> i have no idea what (\\) is doing
02:26:46 <augur_> @src delete
02:26:46 <lambdabot> delete = deleteBy (==)
02:26:47 <jle`> augur_: i think it deletes one item per occurrence in the list?
02:27:03 <augur_> @src deleteBy
02:27:03 <lambdabot> deleteBy eq x []     = []
02:27:04 <lambdabot> deleteBy eq x (y:ys) = if x `eq` y then ys else y : deleteBy eq x ys
02:27:04 <kvanb> it's a set type difference thing
02:27:05 <jle`> it goes through each item in the second list, and deletes the first occurrence in the first list at every pass
02:27:18 <jle`> > [1,1,1,1] \\ [1]
02:27:20 <lambdabot>  [1,1,1]
02:27:21 <jle`> > [1,1,1,1] \\ [1,2]
02:27:23 <lambdabot>  [1,1,1]
02:27:24 <jle`> > [1,1,1,1] \\ [1,1]
02:27:26 <lambdabot>  [1,1]
02:27:35 <kvanb> \\ = difference
02:27:50 <kvanb> > ([1..10] ++ [1..10]) \\ [1..5]
02:27:52 <lambdabot>  [6,7,8,9,10,1,2,3,4,5,6,7,8,9,10]
02:27:53 <xinming> anyone intrested in my questoin please? :-)
02:27:57 <jle`> xinming: do you know about record syntax?
02:28:03 <augur_> > [1,2,3,1,2,3] \\ [2,3]
02:28:05 <lambdabot>  [1,1,2,3]
02:28:08 <augur_> > [1,2,3,1,2,3] \\ [3,2]
02:28:10 <lambdabot>  [1,1,2,3]
02:28:14 <jle`> when you do something like data Foo = Foo { fooInt :: Int, fooBool :: Bool }
02:28:15 <xinming> jle`: Yes, I'm testing with it now.
02:28:16 <jle`> you create two functions
02:28:19 <augur_> hm
02:28:21 <jle`> fooInt :: Foo -> Int
02:28:24 <jle`> fooBool :: Foo -> Bool
02:28:25 <xinming> jle`: I understand this
02:28:29 <jle`> so that's your error
02:28:38 <jle`> you create a clientName once, in the record syntax
02:28:45 <jle`> and then you create it again as a function
02:29:08 <xinming> jle`: But the problem is, how do we add an additional function to match the Individual in that example?
02:29:15 <jle`> you can't, not with the same name
02:29:20 <jle`> that's why record syntax is discouraged for sum types
02:29:27 <jle`> for cases with multiplle "options"
02:29:34 <xinming> Or we can't, we have to remove the helper and write them manulally
02:29:36 <jle`> all of the projects are partial/non-total/will error on the wrong thing
02:29:38 <xinming> jle`: Ok, thanks, got it.
02:29:43 <jle`> you can write another function, a helper
02:29:50 <augur_> ok im off for the night
02:29:51 <augur_> ciao!
02:30:01 <jle`> clientNameTotal :: Client -> String
02:30:04 <jle`> and define your cases on that
02:30:09 <xinming> Ok, got that
02:30:15 <jle`> i also don't recommend records at all on sum types like that
02:30:16 <xinming> just like an alias
02:30:21 <jle`> in haskell we like to avoid partial functions
02:30:37 <jle`> and you just defined six
02:30:39 <jle`> :)
02:31:01 <xinming> jle`: So, record syntax is not totally encouraged, right?
02:31:06 <jle`> not for sum types
02:31:10 <jle`> types with multiple "options"
02:31:19 <xinming> Got it, thanks
02:31:20 <jle`> it's more ok for type with only one constructor
02:31:33 <jle`> if you really want a way to project out clientContact, you can write a "Maybe" version
02:31:45 <jle`> clientContact :: Client -> Maybe Person
02:31:46 <xinming> Ok. what do you mean by avoid partial functions?
02:31:54 <jle`> partial functions are functions that aren't defined on all possible inputs
02:31:57 <jle`> so tehy result in a runtime error
02:31:58 <xinming> jle`: It's ok, I just follow the examples in the book. :-)
02:32:09 <xinming> jle`: Ok, Thanks for the clear explaination.
02:32:21 <jle`> in haskell, we have a language where you have the ability to move all runtime errors to compile-time
02:32:27 <xinming> the runtime error which kicks the best thing of strong type which is strict check at compile time. :-)
02:32:30 <xinming> Yes.
02:32:35 <jle`> so having partial functions sort of throws away the best part of haskell
02:32:38 <jle`> one of the best parts, heh
02:32:41 <jle`> yeah :)
02:32:42 <jle`> exactly
02:32:44 <xinming> thanks for the clear explanation.
02:32:46 <dv-_> > head []
02:32:48 <lambdabot>  *Exception: Prelude.head: empty list
02:32:48 <jle`> np, good luck
02:32:58 <jle`> > listToMaybe []
02:33:00 <lambdabot>  Nothing
02:33:02 <jle`> i really wish head/tail weren't in Prelude :/
02:33:20 <systemfault> jle`: (Just curious) Why?
02:33:30 <jle`> cause they usually aren't what you want
02:33:34 <jle`> in most cases
02:33:35 <dv-_> they result in a runtime error
02:33:39 <jle`> also, they are partial
02:33:42 <jle`> yeah.
02:33:47 <isomorpheous> systemfault: you have to do a lot of shit with corner cases
02:33:52 <systemfault> True… they throw exceptions, right
02:34:05 <jle`> yeah...and in haskell, we have a language that allows us to basically move all of our runtime errors to compiletime errors
02:34:12 <jle`> using head/tail is sort of a way to throw all that out the window
02:34:12 <isomorpheous> systemfault: I really don't like how lists are implemented in Haskell
02:34:24 <jle`> in the wrong situation, of course.
02:34:31 <jle`> there are situations where head is good
02:34:44 <jle`> but normally, when new people begin working with lists, 90% of the time tehy use head, it's in a bad situation
02:34:45 <isomorpheous> jle`: string in Haskell is a joke
02:35:03 <jle`> String is, but i think List is pretty awesome
02:35:08 <jle`> it's basically the perfect streaming type
02:35:15 <jle`> perfect for control flow
02:35:15 <isomorpheous> jle`: that's a good point
02:35:35 <jle`> (there are better ones, so it's not perfect, but i think it's really good at what it is meant for)
02:35:57 <isomorpheous> jle`: I do thing String should be removed from the standard library
02:36:02 <xinming> BTW, for ghc, Is the performance get quite a lot faster years of enhancements? IIRC before ghci does do print one by one char kind of thing to print string.
02:36:25 <jle`> ghc gets much better even month-by-month
02:36:30 <xinming> hmm, Ok.
02:36:38 <isomorpheous> jle`: or, at least make string only support ASCII values, so nobody uses them for anything serious
02:37:01 * isomorpheous glares at pandoc
02:37:29 * isomorpheous also glares at anyone who uses the GPL for their library
02:37:32 <jle`> i can't really comment too strongly on that issue, but a lot of people have some strong opinions
02:38:44 <jle`> i remember working with ocaml stirngs, which are real strings and not linked lists of unicode codepoints/characters
02:39:02 <jle`> i didn't have too much problems with it...i even implemented a parser combinator library
02:39:03 <isomorpheous> jle`: i've been meaning to learn OCaml
02:39:16 <isomorpheous> jle`: don't seem to have any time anymore
02:39:16 <systemfault> Guys… is there a difference between higher-kinded types and higher-kinded polymorphism?
02:48:29 <Feuerbach> higher-kinded types are types with non-* kinds
02:48:56 <Feuerbach> higher-kinded polymorphism is presumably a facility to abstract over such types
02:54:15 <xinming> jle`: How do we mix the record syntax and the old plained declaration thing?
02:54:23 <systemfault> Ah, I thought that higher-kinded polymorphism was kind of a synonym with type class, am I wrong?
02:54:51 <jle`> xinming: mix in what way?
02:55:09 <jle`> have some fields be recordy and some fields not?
02:55:10 <xinming> for example,      data Blabla = Company { name :: String, contact ::Person }
02:55:17 <xinming> jle`: Yes, exactly.
02:55:25 <xinming> I want to move the name field to not record type thing
02:55:29 <jle`> hm. i don't think you can do that
02:55:36 <jle`> i'm not 100% sure
02:55:39 <xinming> data Blabla = Company name ... { }
02:55:42 <jle`> the Report should be able to answer you though :)
02:55:42 <xinming> hmm, Ok, Thanks
02:55:46 <jle`> @where report
02:55:46 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
02:56:16 <frerich> Does anybody know whether this function exists on Hackage already: http://lpaste.net/108211 <— I use it like ‘sortByM (<) getModificationTime <$> getDirectoryContents “/tmp”’,  i.e. sorting a list of things by the value returned by an IO action
02:56:31 <frerich> Or alternative, a better name maybe? ‘sortByM’ doesn’t seem right somehow.
02:57:48 <jle`> sortByM sounds familiar
02:58:14 <jle`> (a -> a -> m Ordering) ?
02:58:43 <Feuerbach> systemfault: I haven't heard that term before, so I'm just speculating. Type class is certainly one way to abstract over a type. Parametric polymorphism is another one.
02:58:46 <jle`> :t sortBy
02:58:47 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
02:58:51 <kvanb> can't you just
02:58:53 <kvanb> :t sequence
02:58:54 <lambdabot> Monad m => [m a] -> m [a]
02:58:59 <jle`> sortByM :: (a -> a -> m Ordering) -> [a] -> m [a]
02:59:10 <kvanb> :t (sequence . sortBy)
02:59:11 <lambdabot>     Couldn't match type ‘[a1] -> [a1]’ with ‘[m a]’
02:59:11 <lambdabot>     Expected type: (a1 -> a1 -> Ordering) -> [m a]
02:59:11 <lambdabot>       Actual type: (a1 -> a1 -> Ordering) -> [a1] -> [a1]
02:59:16 <kvanb> :t (sortBy . sequence)
02:59:16 <lambdabot>     Couldn't match type ‘[a1]’ with ‘a -> Ordering’
02:59:17 <lambdabot>     Expected type: [a -> a1] -> a -> a -> Ordering
02:59:17 <lambdabot>       Actual type: [a -> a1] -> a -> [a1]
02:59:22 <kvanb> blegh, gotta do some hacking
02:59:52 <jle`> sortBy can only take (a -> a -> Ordering), so i'm not sure you can do it with a sequence without doing O(n^2) comparisons
03:00:05 <Feuerbach> systemfault: both could potentially restricted to just * types (in Haskell they aren't); in that case you'd talk about the absence of higher-kinded polymorphism
03:00:06 <jle`> you have to be able to chose which comparison to take based on the result of old comparisons
03:00:17 * frerich afk for a moment
03:00:21 <jle`> oh but his version is different
03:00:27 <systemfault> Feuerbach: Ah ok :) Thank you
03:00:43 <jle`> it's not (a -> a -> m Ordering), it's (b -> b -> Ordering) and a mapM
03:00:56 <jle`> so you can do that with a sequence
03:01:01 <jle`> er, a mapM and then sortBy
03:01:17 <jle`> i feel like i've seen an (a -> a -> m Ordering) version somewhere though
03:01:56 <jle`> @hoogle (a -> a -> m Ordering) -> [a] -> m [a]
03:01:57 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:01:57 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:01:58 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
03:02:03 <jle`> guess not
03:03:10 <jle`> i do think if a sortByM existed it would be with an (a -> a -> m Ordering) though, to fit in with foldM etc.
03:04:01 <contrapumpkin> I wouldn't write a sortByM
03:04:25 <contrapumpkin> it doesn't seem to offer much benefit over pairing elements up by the monadic operation?
03:04:35 <contrapumpkin> and has downsides, like no guarantee that it's an actual function
03:04:46 <jle`> if you ran every pair it'd be O(n^2)
03:05:05 <jle`> you have to be able to branch on the results of comparisons
03:05:17 <contrapumpkin> yeah, so make a monadic operation get the thing being compared
03:05:27 <contrapumpkin> and then compare it purely
03:05:46 <jle`> hm
03:05:54 <jle`> actually that makes sense >_>
03:05:58 <jle`> your comparison function should be pure
03:06:08 <jle`> (a -> a -> m Ordering) is kind of silly
03:07:01 <jle`> frerichSort c f = fmap (sortBy c) . mapM f
03:07:16 <jle`> c :: (b -> b -> Ordering) and f :: (a -> m b)
03:07:25 <jle`> it's a little simpler than the version he had posted up
03:07:43 <contrapumpkin> who needs a schwartzian transform
03:07:49 <jle`> oh, but you need to get the original value back
03:08:00 <contrapumpkin> sure
03:08:14 <fredyr> hi, i've tinkered with a edsl for a small assembly language, https://gist.github.com/fredyr/ddd9f1474b38a0ad053b
03:08:19 <jle`> then i guess his impl is ok
03:08:24 <fredyr> does this look okay, or is there a better way for getting the polymorphism, but still enforce the correct registers
03:09:00 * contrapumpkin goes to sleeep
03:17:58 <frerich> jle`: Sorry, I was AFK for a few moments. Reading the backlog, it seems you arrived at the same conclusion as I did? :)
03:19:21 <xinming> What is the best way to enable all extensions in ghc please?
03:20:51 <jle`> frerich: yeah, i can't seem to find anything :/
03:21:04 <jle`> xinming: you probably don't want to do that :) it's made difficult on purpose
03:21:14 <jle`> a lot of extensions might conflict or break each other, i think
03:21:33 <jle`> and some are considered dangerous
03:21:37 <jle`> or change things in unexpected ways
03:21:47 <johnw> I'd like a way to turn on all the safe ones
03:21:58 <xinming> Ok, got it. The book teaches people to use all extensions
03:22:01 <johnw> there are about 20 I simply always use
03:22:05 <xinming> jle`: What about safe ones?
03:22:06 <jle`> what book is this?
03:22:19 <xinming> <<Begining haskell -- a project based approach>>
03:22:49 <xinming> It now introduced 3   { .. }  namedPuns ViewPatters
03:22:56 <int3__> hmm, I'm trying to rewrite my code in terms of recursion schemes, and I don't know what's the best way to 'fold downwards' in a tree. that is, say, I want to annotate a binary tree with integers indicating the node's distance from the root. but catamorphisms start from the bottom of the tree, so I can't use them... I think
03:23:16 <int3__> xinming: those 3 are safe enough
03:23:44 <int3__> xinming: in general the syntactic extensions are all safe to enable, I think. it's only enabling the type system extensions that create tradeoffs (e.g. in compiler error messages)
03:24:12 <johnw> catamorphisms don't start from the bottom
03:24:16 <johnw> it just looks that way due to laziness
03:24:32 <johnw> you can use a catamorphism to install functions at every recursion point
03:24:36 <johnw> and then call the final function
03:24:45 <johnw> this is the same trick by which foldr is used to implement foldl
03:25:07 <johnw> I believe Tim Williams has a slide on this in his Recursion Schemes presentation
03:25:22 <int3__> johnw: oh, right. yeah, that makes sense
03:25:39 <int3__> cool, I have that presentation open in one of my tabs, I'll go look for it
03:27:06 <int3__> xinming: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html
03:27:10 <johnw> should be around slide 70
03:27:18 <johnw> the part about synthesized attributes
03:28:40 <int3__> johnw: yup, it's there. thanks!
03:29:34 <int3__> xinming: in general you should be using cabal for your projects -- so you can specify all the language extensions in your cabal file, and that will apply across the whole project
03:30:10 <int3__> xinming: http://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
03:31:33 <xinming> int3__: Thanks.
03:41:56 <xinming> Just curious, Is itp possible that we create a local function in where and also provides the types constraints for that local function?
03:44:19 <ClaudiusMaximus> > let f x = g x + 1 where g :: Integer -> Int ; g y = fromIntegral y  -- something like this?
03:44:21 <lambdabot>  not an expression: ‘let f x = g x + 1 where g :: Integer -> Int ; g y = from...
03:44:24 <ClaudiusMaximus> oops
03:44:31 <ClaudiusMaximus> > let f x = g x + 1 where g :: Integer -> Int ; g y = fromIntegral y in f 2  -- something like this?
03:44:33 <lambdabot>  3
03:46:12 <xinming> callumacrae: Thanks, I thought it was impossible, definitely, I'm wrong. :-)
03:47:12 <int3__> xinming: with ScopedTypeVariables, you can even do things like `g (y :: Int) = ...`
03:53:30 * hackagebot semiring-simple 0.2.1.0 - A module for dealing with semirings.  http://hackage.haskell.org/package/semiring-simple-0.2.1.0 (pharpend)
03:53:41 <Shamar> Hi, I'm tring to understand how to use the power of lenses without introducing further dependencies but I can't understand how "type Lens s t a b = Functor f => (a -> f b) -> s -> f t" enable to read and change deep data structure
03:58:32 * hackagebot Cabal 1.20.0.2 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.20.0.2 (JohanTibell)
04:02:10 <jle`> Shamar: there was a post on reddit a month or so ago that went over that, but i recommend you trying to see if you cna figure it out :)
04:02:15 <jle`> you know the type of `over`, right?
04:02:38 <jle`> over :: Lens s t a b -> (a -> b) -> (s -> t)
04:02:51 <jle`> can you write its implementation, given what you already know?
04:03:09 <jle`> pick a Functor that would work for you in this way
04:03:25 <jle`> that would help you
04:03:51 <jle`> get :: Lens s t a b -> s -> a
04:04:32 <latk> I'm parsing a load of documents with XMLConduit. Annoyingly, some of the tags are upper case, and some are lower case. Is there some easy way of normalising the tag case ?
04:05:22 <jle`> set :: Lens s t a b -> b -> s -> t
04:05:29 <latk> Ah, looks like laxElement might do it for me..
04:06:02 <korczis> any accelerate fans here?
04:06:26 <isomorpheous> Damn
04:06:36 <isomorpheous> Why can't I use lambdas in an instance declaration?
04:07:13 <jle`> you can't?
04:08:06 <jle`> instance Functor Maybe where fmap f = \m -> case m of Just x -> Just f x; Nothing -> Nothing
04:08:09 * Shamar tring to understand...
04:08:11 <jle`> should work, i think
04:08:48 <isomorpheous> jle`: Really abusively - here's what I'm trying to do http://lpaste.net/108213
04:08:51 <korczis> I am trying to figure out what is most efficient accelerate (talking about http://hackage.haskell.org/package/accelerate) backend for CPU. Any ideas? Default implementation seems to perform horrible.
04:09:12 <isomorpheous> instance Real a => Functor (\a -> Tropical a) where
04:09:31 <jle`> isomorpheous: you mean... type "lambdas"?
04:09:39 <jle`> because there isn't really type lambda syntax in haskell
04:09:40 <isomorpheous> jle`: lol yes
04:09:53 <jle`> anyways, you can't really have constrained functors that way
04:09:56 <jle`> what would the type of fmap be?
04:09:59 * isomorpheous can feel jle` cringing
04:10:04 <jle`> fmap :: (a -> b) -> f a -> f b
04:10:23 <jle`> the power of fmap is that it can take *any* (a -> b), and turn it into an (f a -> f b)
04:10:23 <isomorpheous> fmap :: (Real a, Real b) -> (a -> b) -> f a -> f b
04:10:32 <jle`> but that's not the type of fmap
04:10:33 <jle`> :t fmap
04:10:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:10:45 <isomorpheous> GHC bitches because, exactly, not the type of fmap
04:10:51 <isomorpheous> I guess my thing isn't a functor
04:10:53 <isomorpheous> damn
04:11:10 <jle`> it might be a functor in some sense, but it's not a Functor
04:11:26 <{AS}> How does Real work in Haskell? Or is it just Rationals?
04:11:33 <isomorpheous> Maybe I'll define my own Functor type
04:11:39 <isomorpheous> Like RealFunctor or something
04:11:55 <jle`> you can make a ConstrainedFunctor type, with constraint kinds and type families to have an fmap with arbitrary constraints
04:11:59 <DarkFox> Hello world; just wondering if anyone has the solution for http://lpaste.net/104440 > http://ircbrowse.net/browse/haskell/?events_page=519241
04:11:59 <jle`> or yeah, just a RealFunctor too
04:12:05 <Shamar> jle`, 4 type arguments don't help too much... :-)
04:12:13 <jle`> {AS}: it's a typeclass
04:12:21 * DarkFox 's personal paste - http://ix.io/dBc
04:12:22 <jle`> Shamar: ah, ok
04:12:37 <jle`> you might be able to tell from the type of `over` what the s t a b might mean?
04:12:47 <jle`> over :: Lens s t a b -> (a -> b) - (s -> t)
04:12:49 <DarkFox> Similar issue; not exact and not sure for the best way to get cabal to install darcs here...
04:12:56 <jle`> or maybe look at a simpler case
04:13:15 <jle`> overSimple :: Lens s s a a -> (a -> a) -> (s -> s)
04:13:18 <{AS}> jle`: Ah thanks :)
04:13:21 <jle`> what does that type signature remind you of?
04:13:25 <jle`> the (a -> a) -> (s -> s) ?
04:13:49 <isomorpheous> jle`: somewhat like (.)
04:13:55 <Shamar> I have an intuition of why in can be used to update it (but why the Functor f?) but not about use it to view a value
04:13:56 <isomorpheous> I still don't get the point of lenses
04:14:04 <jle`> well i was going more like fmap
04:14:18 <isomorpheous> jle`: well fmap and (.) are pretty alike
04:14:19 <jle`> fmap lets you turn an (a -> a) into an (f a -> f a)
04:14:36 <jle`> it takes a function on values in one context, and turns them into a function on another
04:14:51 <jle`> over takes a function on (a -> b), and turns it into a function on (s -> t)
04:15:17 <jle`> it's like a 'specialized fmap', of sorts
04:15:26 <isomorpheous> jle`: maybe you can explain
04:15:47 <isomorpheous> jle`: okay, read the Lens haddock
04:15:51 <isomorpheous> jle`: makes more sense
04:16:06 <jle`> there was this post on how to derive over, and view, and set from the vl lens form, and it used hole-based stuff
04:17:27 <jle`> ah, here it is
04:17:30 <jle`> Shamar: http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html
04:17:55 <DarkFox> Anyone here; recently installed darcs ? (If so, how? :P)
04:18:16 <jle`> isomorpheous: heading to bed soon actually :)  but i'm sure people here or at #haskell-lens wouldn't mind answering you
04:18:23 <isomorpheous> jle`: alright
04:18:41 <isomorpheous> jle`: where are you?
04:18:57 <jle`> california
04:18:58 <Shamar> jle`, I thought I had found all lens' tutorials, but, this one is new... :-)
04:19:09 <isomorpheous> jle`: jesus. I'm in Utah, I feel your pain
04:19:11 <jle`> only a week or so old!
04:19:25 <isomorpheous> jle`: Insomniacs unite
04:19:32 <jle`> isomorpheous: why aren't you in #nothaskell ! lots of utah people there :)
04:19:50 <isomorpheous> jle`: I prefer to derail relevant conversations here
04:20:00 <isomorpheous> jle`: and the demonym is "utahn"
04:20:12 <isomorpheous> jle`: in case you didn't know
04:20:27 <jle`> i wasn't aware, actually
04:20:33 <jle`> thank you for enlightening me
04:20:47 <jle`> anyways, probably going to head off now
04:20:50 <jle`> take care
04:20:53 <isomorpheous> jle`: you as well
04:21:01 <isomorpheous> jle`: good night, or morning, or whatever
04:22:04 <jle`> :) yw
04:22:35 <Shamar> jle`, actually an approachable tutorial... thanks :-)
04:22:45 <jle`> np :) good luck in your lensing
04:22:58 <jle`> there's always #haskell-lens if you have more questions, they're pretty friendly
04:27:02 <danilo2> Hello! How do you name the <*> operator? Is it "applicative bind" or sohuld I use other words to describe it? :)
04:29:56 <Krakarn--> danilo2: I think it's usually called 'ap', from the Monad library, I think, that does the same thing
04:31:08 <Twey> danilo2: ‘Apply’, or ‘ap’ for short
04:31:27 <danilo2> Krakarn--, Twey: Thank you very much! :)
04:31:49 <Twey> No problem
04:32:16 <Twey> The existence of #haskell-lens scares me
04:32:40 <Twey> As does the unsafeCoerce count in the channel topic :þ
04:37:37 <mjrosenb> AARGH
04:37:50 <mjrosenb> why did cabal just install everything locally?
04:38:19 <mjrosenb> I have --user-install: False in my config
04:42:04 <mjrosenb> also, does anyone have any clue why cabal is sad here:
04:42:08 <mjrosenb> http://bpaste.net/show/510190/
04:44:38 <coppro> mjrosenb: looks like packages that have specific version limitations (>= and < constraints) causing unsatisfiable/really complicated dependency hell to me
04:45:54 <coppro> mjrosenb: you have array=0.5.0.0 and representable-functors won't work with it would be my guess, if I can parse that output correctly
04:45:55 <Twey> mjrosenb: Because representable-functors is picky about its versions, and it wants versions that conflict with versions you require elsewhere
04:47:57 <Twey> mjrosenb: You're using semigroupoids, which is using comonad-4.2.1, but representable-functors wants <4; you're using text, which is built with array-0.5.0.0, but representable-functors wants <0.5 or <0.4 for earlier versions.
04:49:58 <Twey> mjrosenb: representable-functors is deprecated in favour of adjunctions, so it hasn't been updated in a while, leading to this problem
04:50:43 <Twey> Oh
04:50:59 <Twey> mjrosenb: representable-functors is required by category-extras, but category-extras itself is deprecated
04:51:20 <Twey> mjrosenb: So the root problem is that reactive's dependencies haven't been kept up to date
04:51:44 <Twey> It doesn't look like Conal's touched it in some time
04:52:06 <Twey> I guess sodium or reactive-banana would be the thing to go for nowadays
04:54:33 <rufs> how do you add compiler flags to the compile shortcut (C-c C-l) in emacs?
04:57:35 <genisage> the beginners channel is dead, can anybody here pop in to answer a quick question?
05:01:18 <ion> sure
05:02:15 <ion> Oh, i misread what you said as “can anyone pop in here to ask a quick question”. The answer to your actual question is: one does need to ask to ask.
05:10:44 <merijn> genisage: Eh, why not just ask your question here?
05:11:20 <genisage> because it was a beginner question.
05:12:20 <petercommand> genisage: just ask
05:15:05 <Sugar``GirL``> ping pong
05:15:25 <merijn> genisage: This has always been a channel for all questions, including beginners. #haskell-beginners is a recent thing a few people started so long "lectures" don't clutter up this channel
05:15:56 <genisage> ah, well my question has already been answered, but I'll keep that in mind in the future.
05:38:47 * hackagebot tightrope 0.1.0.1 - Nice API for a Slackbot  http://hackage.haskell.org/package/tightrope-0.1.0.1 (ian)
06:30:27 <pranz> when compiling pandoc I get some type errors, one prominent is: Couldn't match expected type `TestFlags' with actual type `UserHooks'
06:30:48 <pranz> a google search gave nothing, so I came to ask if someone has had similiar problems here?
06:31:20 <bms1> pranz: Try updating Cabal? Just a guess
06:32:53 <xinming> Just curious, Can I say that a function allowed to be used as partial applications is a curried form function?
06:32:59 <mietek> Does anyone have an example of using ParsecT?
06:33:05 <xinming> I read something here, But need more thinking though.
06:33:06 <xinming> http://www.haskell.org/haskellwiki/Currying
06:34:12 <xinming> ignore me, the later paragraph gives the answer
06:35:00 <jedai> xinming: Currying _allows_ you to do partial application in a limited fashion
06:35:38 <jedai> jedai: but the reverse is not always true, the two notions are distincts
06:36:35 <pranz> bms1: wow that was actually it, even though I had 1.20.0.1 and the newest version was 1.20.0.3
06:36:39 <pranz> bms1: now I feel stupid
06:37:14 <nadirs> Hi, I'm not sure if this is an issue related to Haskell/GHC or to the OS, but is there a way to free cached computations?
06:37:15 <nadirs> After the first run the same computation is run instantly and I cannot figure out performance improvements
06:37:20 <bms1> bms1: Glad that worked! I guess pandoc should have changed their cabal bounds
06:38:56 * hackagebot jalaali 0.1.0 - Convert Jalaali and Gregorian calendar systems to each other  http://hackage.haskell.org/package/jalaali-0.1.0 (behrang)
06:39:13 <jedai> nadirs: cached computations only happen to CAG (that is top-level variables that are not a function type and monomorphous)
06:39:17 <bms1> pranz: You might consider reporting that issue here https://github.com/jgm/pandoc/issues
06:40:04 <nadirs> jedai: do you mean that if I add an argument I can force the recomputation?
06:40:08 <jedai> nadirs: on the other hand, it is vaguely possible that optimization do common expression elimination (or something like that) though that is a very restricted optimization
06:40:13 <jedai> nadirs: yes
06:40:38 <jedai> nadirs: there's no automatic memoization in Haskell
06:40:52 <nadirs> jedai: it's got to be Linux then
06:40:57 <jedai> nadirs: though there are good libraries that automate that
06:41:14 <jedai> nadirs: Linux don't memoize your program for you
06:41:45 <jedai> Could you post an example of your problem ?
06:41:45 <sleepomeno> why does the fmap only apply the function on the second element of a tuple in the tuple functor instance? (is there a functor pair type where it is applied to both elements?)
06:42:03 <mwhit> there can't be
06:42:09 <mwhit> tuple elements can be of different types
06:42:18 <nadirs> jedai: ok, let me post it on lpaste
06:42:22 <jedai> sleepomeno: because functors take a type constructor of kind * -> *
06:42:50 <mwhit> ^^^
06:42:55 <jedai> sleepomeno: "(,) a" is of kind * -> * (take a type to construct a type)
06:43:17 <nadirs> jedai: http://lpaste.net/108214
06:43:25 <jedai> sleepomeno: but (,) is of kind * -> * -> * (takes two types to construct a type)
06:44:08 <nadirs> jedai: `total` is called in a separate test file
06:44:13 <mwhit> so for the existing instance, (String,Int) is a tuple over Ints
06:44:18 <nadirs> (it's an Exercism.io exercise)
06:44:24 <mwhit> and so any function Int->b can be fmapped over it
06:44:41 <mwhit> if "both" elements were part of the functor, what would be the type of fmap?
06:45:17 <jedai> nadirs: and what's the problem ?
06:46:06 <nadirs> jedai: I'm trying to optimize `total` which is supposed to take a long time, but after the first time it's being computed instantly
06:46:06 <sleepomeno> jedai: if the type of the two elements is the same i could make an instance like i want, couldn't I?
06:46:07 <latk> If I'm parsing html pages, should I be treating the document as a bytestring, or as text ?
06:46:25 <pranz> LOL
06:46:27 <jedai> if you use total with the same type (which is an integral type so small) twice in the same function, it is very likely that it is optimized away
06:47:09 <jedai> but since if you want to optimize it you change it inbetween, that should not be a problem... You _do_ recompile your programs ?
06:47:13 <btcNeverSleeps> Is there an "append-only" / CRA ("Create Read Append" -- as opposed to CRUD) DB that people typically use with Haskell?  A bit like Datomic for Clojure / Java?  Where by passing a time argument function making DB calls are pure?
06:48:08 <nadirs> jedai: yes I wrote this as a cabal package and run the compiled executable after compiling the package
06:48:09 <jedai> sleepomeno: No and yes, you can't do an instance for (,) (for the reason I gave you) but you could do an instance for "data Pair a = Pair a a"
06:48:31 <SkyWriter> hey there, I've solved http://projecteuler.net/problem=8 with http://lpaste.net/108215, but I feel my solution's a little bit sluggish; in particular I think maxMul can have it's both arguments curried.. is there any elegant way to achieve that?
06:48:32 <sleepomeno> I see..
06:48:55 <jedai> nadirs: I don't get it ? The first time you execute it it takes a certain amount of time and the second time it's far faster ?
06:49:04 <SkyWriter> (yeah, and I'm a Haskell newbie :)
06:49:05 <nadirs> jedai: I'm starting wondering that maybe I made a mistake the first time and wrote `square` as `x*x` instead of `2 ^ (x - 1)`
06:49:35 <jedai> nadirs: that doesn't seem possible and it's certainly not haskell that's doing anything to get that
06:51:12 <nadirs> jedai: no, I mean, maybe the first time I run it I wrote "square x = x*x" and then run it and it was very slow (I Ctrl-C'd it). Then made some changes (rewrote square as power of 2 instead of actual square) and didn't realize that's the reason it's faster
06:52:43 <jedai> nadirs: That seems far more reasonable, in any case, neither Linux nor Haskell would memoize something between execution (except if you wrote the result to a file and loaded it back but you would have to do that explicitly or use some persistence libraries)
06:54:03 <nadirs> jedai: on a side note though GHCi does memoize computation, right?
06:54:33 <jedai> SkyWriter: first, why not just put quotes around your thousand digits rather than force Haskell to transform it into an Integer then show() it ?
06:54:52 <jedai> nadirs: no more than GHC, so only the CAG
06:55:21 <SkyWriter> jedai: oops, that's right, missed that
06:57:05 <nadirs> jedai: ok, I've gone back in vim history and realized the reason was that I originally wrote `foldl' ((+) . square)` which produces much bigger numbers than what I re-wrote later :P
06:57:19 <jedai> SkyWriter: I don't get your slide either, did you want : "slide n = filter ((<n) . length) . map (take n) . tails" ?
06:57:41 <nadirs> jedai: thank you for taking the time to help. One last thing, what does CAG stands for?
06:57:52 <jedai> SkyWriter: though of course that's very innefficient
06:58:23 <jedai> SkyWriter: for this problem, you should only have one division and one multiplication per windown, not twelve multiplications
07:00:03 <jedai> nadirs: sorry, that's an error , it's CAF : http://www.haskell.org/haskellwiki/Constant_applicative_form
07:00:25 <nadirs> jedai: thanks!
07:01:47 <salohcin> I'm new to haskell and trying to get familiar with the bind operator, can someone tell me how I can properly write the following, so the output of getArgs is bound to unwords rather than a second argument to putStr: getArgs >>= putStr unwords
07:02:13 <SkyWriter> jedai: yes, I've meant exactly that :) didn't know of tails function... I see pretty much clearly how an efficient approach with one division and multiplication can be implemented in a procedural language, but I just cannot twist my mind to make it functional
07:02:42 <SkyWriter> jedai: functional, concise and yet efficient
07:02:52 <jedai> salohcin: getArgs >>= \args -> putStr (unwords args)
07:03:42 <salohcin> jedai: Ah, yes. But I was trying to get rid of the variable args, is there anyway around it?
07:03:47 <jedai> SkyWriter: Yes, it is a function that's sometimes useful, though here you can do far better
07:04:06 <jedai> salohcin: maybe you want "getArgs >>= putStr . unwords
07:04:11 <SkyWriter> jedai: I guess all it takes is practice?
07:04:35 <jedai> SkyWriter: For those kind of things practice and experience are really helpful
07:05:07 <salohcin> jedai: beautiful, thank you!
07:05:08 <jedai> SkyWriter: it comes pretty naturally quite fast
07:08:50 <SkyWriter> jedai: thanks again, in case it hasn't been sent before I got dc'ed
07:12:00 <jedai> SkyWriter: You're welcome, though as I said, you can do far better for this problem by splitting (splitAt) the list then scanning (scanl) starting from the product of the first thirteen numbers and advancing with pairs of the (first, fourteenth) then (2nd, 15th) element and so on
07:12:18 <jedai> though I guess with only a thousand digits that's not really needed
07:13:35 <SkyWriter> jedai: anyway I'll try to do that, as a matter of making good habits
07:14:29 <SkyWriter> jedai: to be honest, I've tried that in the beginning, but the code looked totally awkward to me
07:14:34 <jedai> SkyWriter: There are often euler exercices that are simply harder versions of the previous ones (where naive solution don't work anymore) so you may just wait until you get there though
07:15:12 <jedai> SkyWriter: That's probably because you don't have enough experience yet with the combinators in the Prelude and Data.List
07:15:48 <jedai> SkyWriter: here you can do it quite nicely with splitAt, scanl, product and zip
07:16:42 <SkyWriter> jedai: just by chance, do you have on your mind any particularly good tutorials or exercises you'd recommend to get that basic experience?
07:19:41 <jedai> SkyWriter: Well project euler is in fact pretty good though of course it doesn't guide you at all so you can end up with awkward solutions, I'm not aware of any special tutorials, though this answer is pretty good http://stackoverflow.com/questions/1012573/getting-started-with-haskell
07:30:34 <mietek> Any good examples of lexing prior to parsing with Attoparsec?
07:32:44 <allsystemsarego> > unfoldr (\x -> case lex x of [("","")] -> Nothing; x:_ -> Just x) "f118(d06dad(062e1)ab618)d469a2(ef3d)20"
07:32:46 <lambdabot>  ["f118","(","d06dad","(","062e1",")","ab618",")","d469a2","(","ef3d",")","20"]
07:32:55 <allsystemsarego> mietek, ^
07:33:56 <mietek> allsystemsarego: how do you feed this to Attoparsec?
07:35:04 <SkyWriter> now that's what I call a flakey Internet
07:37:45 <int3__> so I have an open recursive datatype like e.g. data TreeF a = TreeF Int [a], and I can make this into a rose tree using Fix, thereby getting all the recursive-schemes for 'free'. Alternatively, I can make a list into a rose tree using Cofree, which automatically gives me all the functions that work on the Cofree instance -- but now the recursive 'knot' is already tied, so I can't use the recursion-schemes. I suppose I could just use Fix and t
07:37:45 <int3__> hen implement the 'unwrap' instance function of Cofree for that datatype, but... is there some other way to 'compose' these knot-tying constructs?
07:37:46 <SkyWriter> jedai: my gratitude for the tutorials link
07:38:47 <jedai> SkyWriter: You're welcome and probably don't try to implement the alternative strategy I proposed, the 0 are annoyings and destroy part of the benefice
07:39:15 <jedai> The sliding approach is fine :
07:40:02 <jedai> slide n = filter ((==n) . length) . map (take n) . tails
07:40:02 <jedai> maxMul n ds = maximum (map product (slide n ds))
07:41:09 <jmcarthur> int3__: you could make an open recursive Cofree. you'd need a version of Fix that is recursive on the first of two type arguments though.
07:41:48 <SkyWriter> now that looks boiled down to the essence :) oh, and is there any way to omit "n ds" in maxMul by using composition?
07:42:59 <int3__> jmcarthur: ah, I see. That seems like more boilerplate than implementing instance functions, though, so I guess that's still a more pragmatic solution
07:54:23 <jedai> SkyWriter: Yes, though really omitting n lead to some uglyness (I would not recommend it), omitting ds is straightforward thoug :
07:54:55 <jedai> maxMul n = maximum . map product . slide n
07:55:44 <vanila> @unpl ((maximum . map product) .) . slide
07:55:45 <lambdabot> (\ d j -> maximum (map product (slide d j)))
07:55:56 <vanila> I don't recommend writing this.. just showing it
07:55:59 <Apocalisp> relrod: sent you an email. LMK if that makes sense.
08:00:45 <lostman_> hi all. is there any better way of converting lazy bytestring to strict than BS.concat . BL.toChunks? I find myself doing that quite often recently and it's becoming annoying really really fast
08:01:25 <merijn> lostman_: Well, the preferred approach is to try and avoid mixing lazy/strict if at all possible (I know this isn't always possible)
08:01:48 <merijn> lostman_: Newer versions of bytestring have toStrict in Data.ByteString.Lazy
08:02:33 <lostman_> merijn: oh yes, I see it now. must've missed it!
08:02:43 <SkyWriter> vanila: thx :) it looks incomprehensible to my unprepared mind tho
08:02:50 <lostman_> merijn: cheers
08:03:15 <vanila> you can just memo the pattern (f .) . g = \x -> f . g x
08:03:16 <merijn> lostman_: What are you getting the lazy ByteString from?
08:03:40 <lostman_> from aeson
08:04:23 <lostman_> I suppose it returns lazy bytestrings for good reason
08:04:32 <merijn> Ah, encode is lazy, annoying
08:05:04 <merijn> lostman_: Yeah, that way you can stream encoding directly to a socket, rather than first generating an entire bytestring in memory before writing it out to disk/network/etc
08:06:14 <lostman_> merijn: true. I'm putting json encoded data into redis actually (using hedis package). hedis uses strict bytestrings though
08:06:57 <lostman_> at the end of the day it's gonna go into redis in some binary encoding; but I'm using json for now for readability
08:09:06 * hackagebot abc-puzzle 0.2 - Generate instances of the ABC Logic Puzzle.  http://hackage.haskell.org/package/abc-puzzle-0.2 (PatrickBahr)
08:09:41 <int3__> I wish instance implementations were easier to view on hackage
08:09:55 <int3__> there isn't even a hyperlink to the location in the source view
08:10:17 <CaptainK> It was Scönfinkel that gave us a way to curry?
08:10:42 <int3__> s/hackage/haddock/
08:14:23 <CaptainK> Moses gave us Haskell.
08:17:28 <CaptainK> > uncurry (*) 3 2
08:17:30 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t, a0 -> t))
08:17:31 <lambdabot>    arising from the ambiguity check for ‘e_132’
08:17:31 <lambdabot>  from the context (GHC.Num.Num (a -> t, a -> t),
08:17:31 <lambdabot>                    GHC.Num.Num (a -> t),
08:17:31 <lambdabot>                    GHC.Num.Num a)
08:17:55 <CaptainK> > uncurry (*) (3,2)
08:17:57 <lambdabot>  6
08:19:36 <phaazon> @hoogle Void
08:19:39 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
08:19:39 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
08:19:39 <lambdabot> package void
08:34:08 * hackagebot linklater 2.0.0.3 - The fast and fun way to write Slack.com bots  http://hackage.haskell.org/package/linklater-2.0.0.3 (hao)
08:34:10 * hackagebot tz 0.0.0.8 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.8 (MihalyBarasz)
08:43:43 <nschoe> Hi, I'm having troubles with Yesod and CSS. I'm trying to understand how to use 'addStylesheet', can anybody explain how to do it ?
08:43:59 <nschoe> I'm following the Yesod book and not using the scaffolded site for now.
08:45:13 <nschoe> I have overridden the defaultLayout function with myLayout, defined my routes : getHomeR and getAdminR  of type Handler Html.
08:46:02 <nschoe> Now I'd like to add some CSS for the HomeR, and the book says addStylesheet takes some type-safe URL. So how do I create a type-safe URL to serve my CSS file ?
08:48:50 <phaazon> do you know how much memory really takes an Int?
08:48:55 <phaazon> (regarding the box)
08:51:33 <rwbarton> an Int itself takes 2 words
08:52:05 <phaazon> 2 words?
08:52:10 <phaazon> so 16 bits?
08:52:18 <rwbarton> 2 machine words
08:52:35 <rwbarton> i.e. 8 bytes on 32-bit systems, 16 bytes on 64-bit systems
08:53:16 <phaazon> so what’s the price for the box?
08:53:32 <rwbarton> that depends on exactly how you count
08:53:47 <Exio> isn't a word 16 bits? (in x86-32)
08:54:09 <phaazon> sizeOf (undefined :: Int) gives me 8 bytes
08:54:25 <rwbarton> that's the size of its Storable instance
08:54:29 <phaazon> (and I’m on a 64-bit arch)
08:54:31 <phaazon> ok
08:54:40 <phaazon> so is there a way to know the Haskell size?
08:54:49 <phaazon> I’m curious about boxing vs. unboxing
08:54:53 <phaazon> in terms of overhead
08:55:06 <rwbarton> pick a concrete example
08:55:29 <phaazon> I don’t have concrete example rwbarton
08:55:37 <phaazon> I just wonder how much a box takes place
08:55:48 <Exio> i think the main problem with boxed values is the indirection
08:55:53 <rwbarton> the point is that it depends on whether you have multiple references to the same Int and so on
08:56:03 <phaazon> let’s say only one
08:56:15 <phaazon> Exio: so it might be the size of a C pointer?
08:56:54 <Exio> isn't a boxed a pointer to the heap?, i think i'm wrong though
08:56:57 <rwbarton> ok let's also assume it is a field of a data constructor
08:57:32 <rwbarton> an unboxed Int field will physically store the integer in the data constructor (1 word)
08:57:55 <rwbarton> a boxed Int field will store a pointer to an Int object (1 word for the pointer + 2 words for the Int object)
08:58:08 <hpc> @src Int
08:58:08 <lambdabot> data Int = I# Int#
08:58:18 <phaazon> I see
08:58:36 <rwbarton> you can think of one of those 2 words as storing 'I#' and the other words as storing the Int#
08:58:43 <rwbarton> *the other word
08:59:06 <Sculptor> mutlu bayramlar
09:00:15 <mwhit> is the # in the I# meaningful or is that just some kind of convention?
09:00:19 <hpc> it's worth noting that this is all GHC-specific
09:00:28 <hpc> the # has no special meaning here
09:00:46 <hpc> it's just convention for GHC internals, similarly to how ' denotes alternate implementations or strict implementations
09:03:52 <rwbarton> Exio: "word" here means the size of a pointer, not "the size of a pointer in 1980" like in x86 assembly :)
09:04:02 <nschoe> Nobody knows for Yesod ?
09:05:00 <Exio> ah
09:05:43 <hpc> as a side note, in addition to Int there are sized types, Int8, Int16, etc
09:05:51 <hpc> and unsigned types, Word, Word8, Word16, etc
09:08:07 <nadirs> nschoe: check this page: http://www.yesodweb.com/blog/2013/01/adding-css-js
09:08:23 <nadirs> nschoe: «To save you from typos, Yesod automatically generates identifiers for all files in your static folder, based on a simple renaming scheme. So to include Bootstrap, you would use something like:
09:08:36 <nadirs> nschoe:   addStylesheet $ StaticR css_bootstrap_css
09:08:39 <nadirs> »
09:08:57 <nschoe> nadirs: ha thanks ! I'll read that right away.
09:09:37 * tac doesn't want to be saved from typos :<
09:10:33 <nadirs> tac: why not? Working with PHP on a daily basis I'd like to have it forced to me at compile time, honestly
09:10:53 <tac> Warnings are good enough, aren't they?
09:14:23 <fizbin> @type let repeatToNone f a = maybe a (repeatToNone f) (f a) in repeatToNone
09:14:24 <lambdabot> (a -> Maybe a) -> a -> a
09:15:14 <jedai> nschoe: but basically, if you already created your base type, HomeR and AdminR should be "url-safe" value
09:15:47 <nschoe> jedai: the problem is that I'd like to do things cleanly, i.e. not write CSS code in my HomeR and AdminR
09:16:02 <jedai> tac: Why the hell would you want to compile something that contains URLs with typos rather than correct them ?
09:16:39 <hostilefork> Hello there.  Seeking help with running this fractal program: http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/
09:16:48 <nschoe> and from the link nadirs gave me, I think I ned to use the scaffolded site :/
09:17:30 <hostilefork> I have installed haskell-platform, and downloaded the three files at the end (YGL.hs, Mandel.hs, ExtComplex.hs).  I can't tell if that's all I need or not, but it has a problem with Float and CFloat compiling that.  Is this anything anyone here can test quickly and tell me what's up?
09:18:52 <jedai> nschoe: Well if you want to serve some static css file, that seems reasonable
09:19:15 <nschoe> jedai: so... I have no other choice but use the scaffolded site ?
09:19:46 <jedai> nschoe: if you want to ensure that the stylesheet is cached and shared between page yes
09:20:10 <jedai> nschoe: if not, you can add it in the page itself but you seem to want to avoid that
09:21:23 <nschoe> jedai: yeah, I'd like to avoid that. Css tend to grow rather big and I don't feel like putting it in my source file.
09:21:51 <jedai> nschoe: I didn't say you add to put it in your source file
09:22:05 <nschoe> jedai: ho ?
09:22:08 <jedai> nschoe: you can simply use widgetFile with a .cassius file
09:22:54 <nschoe> jedai: okay. And in this case, it is not type-safe, right ?
09:23:02 <jedai> then your css (ISTR that cassius is very close to bare css) is included in your page
09:23:07 <jedai> nschoe: why ?
09:23:18 <mjrosenb> Twey: so I just can't use reactive?
09:23:49 <jedai> nschoe: the css will be included in the output, not as an external stylesheet, so there's no "type-safe url" in the process
09:24:11 <nschoe> jedai: well, if I use widgetFile "myCss.cassius", and myCss.cassius doesn't exist. What actually happens ?
09:24:13 * hackagebot herringbone-wai 0.1.1 - Wai adapter for the Herringbone web asset preprocessor.  http://hackage.haskell.org/package/herringbone-wai-0.1.1 (hdgarrood)
09:24:15 * hackagebot herringbone 0.1.1 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.1.1 (hdgarrood)
09:24:17 * hackagebot herringbone-embed 0.1.1 - Embed preprocessed web assets in your executable with Template Haskell.  http://hackage.haskell.org/package/herringbone-embed-0.1.1 (hdgarrood)
09:24:38 <jedai> I was going to say that you may do a typo in the name of your file though... :/
09:24:51 <seydar> i have mac os 10.9 on a macbook pro 64 bit. should i get haskell platform 64 bit or 32 bit? is there any reason for me to get a 32 bit anything?
09:25:26 <sipa> 32 bit likely uses less ram
09:25:28 <jedai> nschoe: but then nothing happen, it will try to load the file with a wrong name, conclude they doesn't exist and so change nothing to the output of your route
09:25:50 <sipa> seydar: you generally want 64 bit stuff
09:25:57 <nschoe> jedai: okay. Thanks then. I'll try using that, then
09:25:59 <hiptobecubic> Can anyone explain why this pipe raises an exception? I was under the impression that the pipe would just close when it ran out of input http://lpaste.net/108221
09:26:02 <jedai> nschoe: that would rather be widgetFile "myCss" though
09:26:26 <nschoe> jedai: okay.
09:26:35 <NikolajK> do people think of the letter f in "fmap" as the name of the functor, or a reminder that functions are being mapped?
09:26:40 <seydar> sipa: thank you, i'm downloading 64 bit now
09:27:00 <mjrosenb> Twey: also, isn't there some sort of a build-bot that makes sure everything in hackage at least builds?
09:28:42 <bergey> mjrosenb: Not really.  There's https://github.com/fpco/stackage which tests a subset of Hackage that usually builds.
09:29:04 <mjrosenb> :-/
09:29:54 <bergey> NikolajK: Functor.  But I try not to think of the 'f' at all. :)
09:29:56 <jml> is there something that is equivalent to map f x if x is a list but [f x] if x is not a list?
09:31:33 <NikolajK> jml shouldn't f determine the possible type?
09:31:59 <Iceland_jack> jml: What do need that for?
09:32:15 <mjrosenb> so I guess reactive is "look, but don't touch" for now?
09:32:47 <mjrosenb> does anyone have a recommended frp library that I can hook arbitrary inputs up to?
09:33:06 <benzrf> mjrosenb: i know banana only
09:33:09 <bergey> mjrosenb: What have you tried?  I hear good things about Sodium and Netwire.
09:33:17 <benzrf> mjrosenb: but i think all of them allow arbitrary inputs...
09:33:36 <mjrosenb> bergey: I tired to install reactive c.c
09:34:18 <mjrosenb> benzrf: I think i've seen some that /really/ want to be used with a particular toolkit.
09:35:17 <mjrosenb> Cool. both sodium and netwire seem to have build just fine.
09:35:45 <mjrosenb> ok, other quetion: why is cabal installing everything locally?
09:36:06 <mjrosenb> oh..
09:36:09 <mjrosenb> I am an idiot
09:36:17 <mjrosenb> good to get that cleared up!
09:37:18 <benzrf> whats cool about sodium vs banana
09:37:28 <Athiwat> I'm still confuse about do block
09:37:37 <Athiwat> How do I use map within do? http://lpaste.net/108222
09:37:44 <benzrf> Athiwat: same as map anywhere else
09:37:54 <Athiwat> benzrf: it says Expected type: IO (FB.Pager FB.User)
09:37:54 <Athiwat>       Actual type: FB.FacebookT anyAuth1 m1 (FB.Pager FB.User)
09:38:15 <benzrf> so u used the wrong type
09:38:18 <Athiwat> benzrf: I still don't quite understand how to use lift
09:38:19 <benzrf> wheres the error
09:38:28 <bergey> benzrf: There are examples using sodium with GHCJS. :)
09:38:31 <benzrf> Athiwat: lift is used to lift a non-transformed mobit into a transformed one
09:38:44 <Athiwat> benzrf: I used it here liftIO $ mapM_ (\searchTerm -> do
09:38:50 <brycelane> vague and controversial question: what are the real world performance differences between haskell and scala for idiomatic code?
09:38:54 <Athiwat> but seem like I lift the wrong value ;(
09:39:07 <benzrf> Athiwat: i.e. if you have an 'IO ()', you can use lift to turn it into a 'StateT String IO ()'
09:39:14 <int3__> oh my. I just realized that lists of functors are functors themselves, and that I've been stacking up my fmap . fmap . fmap for nothing
09:39:14 <benzrf> or any other transformer layered over it
09:39:26 <benzrf> int3__: lists of functors are functorial values
09:39:26 <benzrf> :p
09:39:30 <benzrf> err
09:39:36 <benzrf> lists of functorial values are functorial values
09:39:43 <int3__> Data.List doesn't list the types that it's an instance of, though
09:39:46 <benzrf> int3__: only type constructors are functors
09:39:47 <int3__> is there somewhere I can look that up?
09:39:58 <benzrf> int3__: anyway, fmap on lists is just map
09:40:11 <benzrf> you still need to layer you're fmaps
09:40:14 <bergey> benzrf: I don't know anything particularly bad about reactive-banana.  It seems to do worse than most in speed benchmarks, but I have no idea if that matters in practice, and I don't assume that it's anything fundamental to the design.
09:40:15 <int3__> benzrf: well, I thought 'functors' referred to both the value and the fmap
09:40:23 <benzrf> int3__: nooo
09:40:37 <Iceland_jack> int3__: It's fine informally
09:40:47 <benzrf> if you wanna get all categorical then the actual functor is the type constructor plus the definition of fmap
09:40:49 <jedai> nschoe: Note that lucius seems to be the CSS+ whereas cassius is a bit different, also, apparently you can use luciusFile to get an external file compiled at compile time (so with a compile time error if you make a typo)
09:41:06 <benzrf> Iceland_jack: b-but my pedantry
09:41:36 <jedai> nschoe: though I don't really understand how to put those things together (I just searched a bit, never followed the whole tutorial that would put those things in relation)
09:41:58 <nschoe> jedai: (I feel most comfortable using Cassius ). Yeah I was looking at cassiusFile but I can't manage to make it work
09:42:25 <int3__> benzrf: ah, okay. so the actual values are functorial values. fair enough
09:42:29 <nschoe> And I have just tried loading the scaffolded site, but it generates so many things...I feel lost.
09:42:59 <benzrf> int3__: to be precise a functor is a mapping between categories
09:43:04 <nschoe> I mean, I don't think I have control over anything that is happening with the scaffolded site :/
09:43:12 <benzrf> int3__: and individual values are not mappings, they are the things being mapped
09:43:40 <benzrf> [1, 2, 3] is no more a list functor than "foo" is a show function
09:44:33 <benzrf> hmm, actually the values themselves arent being mapped... the types and functions are
09:44:38 <benzrf> meh
09:45:01 <int3__> benzrf: yes, I did start on the actual math yesterday, so I've seen the definitions. I just forgot the distinction between categorical objects and the values they contain
09:45:11 <int3__> benzrf: also, I entirely misread ghci's output when making my initial statement. so yeah, lists of functorial values aren't functors... but then... why *shouldn't* they be?
09:45:52 <int3__> like, it's pretty natural to see how (fmap (+1) [[1],[2]]) should be evaluated
09:45:56 <jedai> nschoe: oh you have control over a lot of things
09:46:06 <benzrf> int3__: oh yeah that mixed me up too at first
09:46:18 <int3__> and one could write an `instance (Functor f) => Functor [f] where`...
09:46:36 <Athiwat> can someone explain to me how does a and b gets bind? http://lpaste.net/108224
09:46:45 <jedai> but it may not be the easiest to find how :( which is I suppose why you started without
09:46:50 <Athiwat> still confuse about how monad works
09:47:02 <Iceland_jack> int3__: that's not going to be well kinded
09:47:35 <benzrf> int3__: i was lagged, the thing that messed me up was the distinction you mentioned
09:47:41 <benzrf> int3__: [] is already a functor
09:48:01 <benzrf> int3__: and yes, it's quite natural
09:48:18 <benzrf> fmap (+1) [[1], [2]] should be evaluated as [[1] + 1, [2] + 2]]
09:48:20 <benzrf> err
09:48:24 <benzrf> fmap (+1) [[1], [2]] should be evaluated as [[1] + 1, [2] + 1]
09:48:29 <benzrf> sadly, that is not well-typed
09:49:04 <prophile> benzrf: that's valid isn't it?
09:49:08 <nschoe> jedai: yeah, as an experimented Yesod user. But I'm new and I'm kinda lost but all the folders generated o_O
09:49:16 <prophile> benzrf: yeah, it is
09:49:21 <prophile> just provide a num instance for [Integer]
09:49:34 <nschoe> jedai: I'll try reading some materials about the scaffolded site, hopefully understanding more thing .
09:49:36 <benzrf> prophile: :p
09:49:40 <nschoe> jedai: thanks for you help, though !
09:49:48 <int3__> benzrf: Iceland_jack: right. I think I see why it can't be defined now. thanks!
09:50:05 <Iceland_jack> int3__: You can define it using a type composition
09:50:15 <Iceland_jack> But then you need flexible instances
09:50:30 <whigmaleerie> Athiwat: a simple expansion of (return “test” >>= \a -> print a) says put “test” in a monad, >>= effectively take it out and pass it to the function binding it to a
09:50:57 <jedai> nschoe: basically, if you use $widgetFile like it's proposed in the tutorial, you'll be able to put your specific css in a .cassius file
09:51:18 <Athiwat> whigmaleerie: how does it binds to both a and b?
09:51:37 <int3__> Iceland_jack: any good resources on type compositions
09:51:39 <int3__> ?
09:51:40 <benzrf> whigmaleerie: im not sure talking about 'taking things out' gives a good intuition
09:51:43 <benzrf> >.>
09:52:27 <whigmaleerie> benzrf: good point
09:53:06 <Iceland_jack> int3__: just newtype (f ∘ g) a = Comp (f (g a))
09:53:25 <joe9> I want to make some https requests using haskell. I tried http-conduit and it seems to be not that stable. Just wanted to check if there is a standard haskell library for https requests?
09:53:28 <nschoe> jedai: trying that right now ^^
09:53:37 <benzrf> joe9: are you already using conduit?
09:53:48 <benzrf> if not, why would you pick http-conduit instead of a plain http lib?
09:53:52 <whigmaleerie> Athiwat: here is your example without the do syntax (return “asd” >>= \a -> return “test” >>= \b -> print a >>= \_ print b >>= \_ -> print a)
09:54:02 <Iceland_jack> joe9: wreq is good, but the lens dependency is big
09:54:13 <Iceland_jack> http://www.serpentine.com/wreq/tutorial.html
09:54:26 <Athiwat> whigmaleerie: I see, it gets nested. Thanks
09:54:44 <jedai> benzrf: http-conduit contains some functions for those that don't use conduit, it's certainly better now than the old http package (though wreq is very nice)
09:55:15 <joe9> benzrf: no, I am not using conduit.  http://stackoverflow.com/questions/9986404/how-can-i-do-an-https-request-in-haskell from this link, I felt that http-conduit is the only option.
09:55:46 <joe9> Iceland_jack: thanks, will check out wreq.
09:56:16 <benzrf> jedai: h
09:56:18 <benzrf> *oh
09:56:35 <jedai> joe9: it's certainly not the only way, though I don't understand what you mean by "not-stable" ? Is it the API or did you encounter bugs ?
09:56:40 <Iceland_jack> joe9: ‘wreq’ we published in April this year so it's recent
09:57:11 <Iceland_jack> and it uses ‘http-client’ which is basically ‘http-conduit’ minus the conduit
09:58:01 <jedai> Right, http-client may even be the right module (if your needs are very basic and you don't want the lens dependency)
09:58:03 <Iceland_jack> If you want to use the lower-level http-client you'll need ‘http-client-tls’
09:58:05 <Iceland_jack> Yes
09:58:48 <jedai> AFAIK http-conduit is now built over http-client anyway
09:59:07 <Iceland_jack> yeah
09:59:24 <mjrosenb> hrmm, cabal install with global seems to be failing
09:59:40 <mjrosenb> isn't there some config option that tells it to run sudo to get root perissions?
09:59:48 <nschoe> jedai: erf. widgetFile not in scope. And I can't find it anywhere n the Yesod documentaiton. Know how to include it ?
10:00:05 <dfeuer> mjrosenb: cabal-install with global is usually a bad idea. Why are you trying to do that?
10:00:14 <benzrf> :t to
10:00:16 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
10:00:18 <benzrf> eek
10:00:30 <whigmaleerie> :k Conjoined
10:00:31 <lambdabot> (* -> * -> *) -> Constraint
10:00:40 <mjrosenb> dfeuer: so I can use things built with cabal-install to build system packages.
10:00:45 <whigmaleerie> @info Conjoined
10:00:46 <lambdabot> Conjoined
10:00:55 <jedai> nschoe: Are you using the scaffold ?
10:01:07 <joe9> the issue I had with conduit, I could not find reliable documentation. I got some old version that put me off.
10:01:19 <nschoe> jedai: no, not yet.
10:01:21 <joe9> let me checkout http-client-tls too.
10:01:31 <benzrf> whigmaleerie: https://gist.github.com/f8afe8efea9b885ac15a
10:02:09 <whigmaleerie> benzrf: wat!?
10:02:27 <benzrf> whigmaleerie: ikr
10:02:29 <benzrf> welcome to lens
10:03:02 <dfeuer> Messing around rewriting unfoldr to a build expression (to be a good producer for foldr/build fusion) led me to see an issue I'm guessing affects other things too but also could be me doing something wrong.
10:03:14 <jedai> nschoe: it seems to be in Yesod.Default
10:03:47 <jedai> or maybe Yesod.Default.Util if you use $(widgetFileNoReload default "file")
10:04:12 <jedai> $(widgetFileNoReload def "file")
10:04:18 * hackagebot djinn-lib 0.0.1 - Generate Haskell code from a type. Library extracted from djinn package.  http://hackage.haskell.org/package/djinn-lib-0.0.1 (AlejandroSerrano)
10:05:10 <nschoe> jedai: I'll try the FileNoReload. Cause I can't find it the other ones
10:05:20 <dfeuer> In particular, if I define foo = map whatever $ unfoldr blah blahh and also define bar = foldr g b foo, and if foo is exported, then because the build is inlined in foo, it's not available for fusion in bar. Is there any way around this?
10:05:45 <dfeuer> (That is, the build from map is inlined in foo.)
10:06:25 <jedai> nschoe: it's possible that widgetFile itself is defined in the "Import" module that comes with the scaffolded site, to allows you to modify the Widget loading settings
10:07:02 <nschoe> jedai: yeah I think this is.
10:07:20 <int3__> so I've been trying to abstract out the idea of 'labeling every node in a (rose) tree with its depth' -- and this is what I have so far: http://lpaste.net/108227
10:07:44 <nschoe> jedai: how do I get the `def` in scope ?
10:07:47 <int3__> my question is, is there something I could do to make this terser? the whole pattern-matching on a list to see if it's empty strikes me as rather... recursive
10:08:20 <jedai> nschoe: import Data.Default probably
10:08:45 <jedai> nschoe: yes, that's the right import
10:09:02 <nschoe> jedai: ho neat. Sorry. Thanks a lot.
10:09:24 <dfeuer> int3__: , I haven't looked at your code yet, and I'm not an expert, but writing a fold over the tree structure can be useful.
10:09:41 <jedai> nschoe: No good luck, Yesod seems very interesting and deep (much safety) though I think I'll try it with the scaffold first
10:09:55 <jedai> s/No good luck/No, good luck/
10:10:00 <whigmaleerie> :k Traversable
10:10:02 <lambdabot> (* -> *) -> Constraint
10:10:13 <whigmaleerie> @src Traversable
10:10:13 <lambdabot> class (Functor t, Foldable t) => Traversable t where
10:10:14 <lambdabot>     traverse  :: Applicative f => (a -> f b) -> t a -> f (t b)
10:10:14 <lambdabot>     sequenceA :: Applicative f => t (f a) -> f (t a)
10:10:14 <lambdabot>     mapM      :: Monad m => (a -> m b) -> t a -> m (t b)
10:10:14 <lambdabot>     sequence  :: Monad m => t (m a) -> m (t a)
10:10:15 <int3__> dfeuer: it already is a fold :) but there's a non-foldy piece of code that's in my fold, which is perturbing me
10:11:09 <dfeuer> Ah.
10:11:44 <nschoe> jedai: well... I'll do that. Because I can't make it work otherwise. So.. let's go for scaffold. But there are many folders : app, config, deploy, Handler,  etc etc etc.
10:12:29 <mmmm> int3__: See the fixplate library for some ideas
10:13:03 <jedai> nschoe: I think the idea is that you don't need to touch everything in the beginning and that the tutorial guide you towards the more useful first
10:13:08 <mmmm> specifically the annotate module
10:13:59 <int3__> mmmm: I think you mean Attributes :P yeah, I'll go have another look. I'm aware of the library but my brain is a bit fried already
10:14:53 <nschoe> jedai: yes, it makes sense. But that still leaves me with tons of stuff I don't understand :-P
10:15:41 <int3__> mmmm: on an unrelated note, one can't really use both fixplate and recursion-schemes on the same open recursive datatypes, right? because one Mu is not equal to another
10:17:06 <joe9> with http-conduit, how do I set the socksProxy? There was a socksProxy field in an earlier version. But, that is missing now.
10:18:10 <mmmm> It looks like you can int3__ if you write the right instance for the Mu in fixplate, not that I've tried
10:19:33 <int3__> mmmm: but Mu is already defined as a newtype in fixplate (and in recursion-schemes)
10:19:38 <int3__> wouldn't that be a redefinition?
10:22:07 <mmmm> you can hide it from recursion-schems and write the correct instances for the one in fixplate I guess and then use functions from both?
10:22:11 <mmmm> am I missing something?
10:26:02 <int3__> mmmm: I haven't tried it, but I don't believe haskell would work that way... that'd essentially be dynamic scoping
10:27:38 <int3__> mmmm: say the fixplate module has a function f that uses the unFix defined in it's own Mu. even if I only import f into my own module, redefining Mu should not make f use the new unFix
10:27:44 <benzrf> haskell has -XImplicitParams
10:28:53 <mmmm> you want to use cata from recursion-schemes with Mu from fixplate for example?
10:29:07 <int3__> mmmm: yup
10:30:09 <mmmm> See how cata is defined as a typeclass method of the Foldable class? You make the Mu from fixplate a method of that class and you get cata
10:35:31 <int3__> mmmm: oh, I guess project needs to be defined somehow
10:35:40 <int3__> fair enough, that should work
10:35:56 <int3__> I need to figure out this type family stuff then
10:36:11 <mmmm> You're probably better using one or the other though?
10:36:52 <mmmm> pretty sure fixplate has cata defined as well but edward's library probably has a better interface
10:37:11 <mmmm> or! define your own and steal ideas from both
10:37:46 <mmmm> It's funny eh how we're both reading the same book and looking at recursion schemes at the same time
10:37:51 <int3__> fixplate has more stuff defined, actually. but I think edward's libraries probably interface better with the rest of his stuff
10:38:21 <int3__> well recursion schemes are a big part of that book, right
10:39:05 <mmmm> well yes but I didn't know that before I started looking :)
10:39:19 <mmmm> https://gist.githubusercontent.com/mpickering/e8b00f7d843d3762892b/raw/d758d6356eccf12e71667bcaaaab0aece2c848cf/solvingfmonad.lhs
10:39:58 <mmmm> I think my recurse function is something like cata?
10:40:36 <amiri> How can one use spaces in HandsomeSoup attribute selectors? I am trying to use next <- runX $ contents >>> css "a[title=\"Next Page\"]" ! "href", and I get an error about unexpected characters.
10:41:23 <seydar> i seek the mercy and wisdom of the ancients: http://lpaste.net/108229
10:41:34 <benzrf> mangaba_leitosa: is that like beautifulsoup
10:41:46 <seydar> i just killed all ghc off my computer (mac os 10.9) and install the haskell package 7.6.3 and now cabal won't work
10:42:49 <ion> Try deleting ~/.cabal and ~/.ghc (or whatever the equivalent directories are on Steve).
10:43:13 <int3__> mmmm: um, didn't get a close look at it, but it seems like it applies f but doesn't do any recursion itself
10:43:42 <int3__> mmmm: well OTOH I started reading AoP in order to understand recursion schemes, haha
10:44:20 <int3__> I think recursion schemes are what drew me to haskell though. ever since I started 'properly' programming I've always felt that a lot of control flow was very repetitive, but I didn't know what to look for to make it better. design patterns were a start, but rather limited.
10:44:21 <seydar> ion: thank you, here is a song i like as a token of my thanks: https://www.youtube.com/watch?v=RY5lgaeki38
10:44:22 * hackagebot ot 0.1.2.1 - Real-time collaborative editing with Operational Transformation  http://hackage.haskell.org/package/ot-0.1.2.1 (TimBaumann)
10:44:59 <int3__> then I found the various Bird-esque papers and got hooked
10:45:44 <angerman> So with data-types, I can give my data rules. But the types do not necessarily define the actual shape of the specific data I create, yet The same type, and same shape can possibly describe different values?
10:45:45 <narens> Hello, I am working on a blog post on dlist performance and I can't explain the benchmarking results I have. You can ignore the fluff in the beginning. I'd appreciate any insights... http://nanonaren.wordpress.com/2014/07/28/draft-performance-if-you-wondered-when-a-difference-list-helps/
10:47:29 <angerman> Say `data List a = Cons a (List a) | Nil, I can have Cons 1 (Cons 2 (Cons 3 Nil))) and yet Cons 3 (Cons 2 (Cons 1 Nil))), right? the shape is both times the same, the type as well, but the values are different.Am I missing something?
10:48:36 <amiri> To answer my own question, it looks like I have to do next <- runX $ contents >>> css "a" >>> hasAttrValue "title" (==" Next Page") ! "href"
10:50:10 <vanila> angerman, they're both lists of integers, just happen to be different ones
10:50:13 <mmmm> int3__: :) Have you read Pearls of functional algorithm design
10:50:48 <int3__> mmmm: I have it, but I've yet to read it :P
10:56:25 <narens> anyone got any ideas?
10:56:54 <Cale> narens: I'll have a look
10:57:40 <narens> Cale: thanks, no rush...
10:58:09 <Cale> okay, so the question is why does DList perform better with regard to concatenation?
10:58:21 <Cale> It's asymptotically better
10:58:29 <Cale> (.) is an O(1) operation
10:58:38 <Cale> xs ++ ys takes O(length xs) steps to reduce
10:59:00 <narens> Cale: I mean I know why dlist does append better but ++ is only bad if its applied left-associatively but in >>= it is applied using foldr
11:00:02 <vanila> narens, ((a ++ b) ++ c) should be slower than a ++ (b ++ c)
11:00:04 <Cale> narens: xs ++ ys takes O(length xs) time. If the list on the left is long, that's expensive, regardless.
11:00:07 <vanila> narens, but dlist will beat both
11:00:52 <narens> vanila: is it not true that a ++ (b ++ c) performs the same as toList (dlist a `append` dlist b `append` dlist c) ?
11:01:17 <vanila> that looks very slow
11:01:21 <benmachine> I think the latter would actually be slightly slower, especially if c was very long
11:01:27 <benmachine> not sure about that though
11:01:34 <Cale> hm
11:01:39 <Cale> I wouldn't expect it to
11:01:43 <vanila> you should write   (\tail -> x1 : x2 : x3 : tail)  rather than   dlist [x1,x2,x3]
11:01:47 <vanila> for testing
11:02:01 <benmachine> well the latter is essentially a ++ (b ++ (c ++ [])) right?
11:02:03 <vanila> otherwise you have to traverse the entire list
11:02:22 <narens> benmachine: exactly, so that's why i don't udnerstand why dlist is faster in that example
11:02:26 <benmachine> and getting elements from c ++ [] is slightly slower than getting them from c itself
11:03:48 <narens> (the bottom line is) the results show dlist is faster for carteian producting lists and it doesn't make sense if I expand evaluation of >>=
11:04:27 <benmachine> narens: if there are multiple >>=s, perhaps that is relevant?
11:04:31 <Cale> Well, that's a decent point, with these constant lists and the internal use of (++), it's a bit funny to compare. Probably if you want the real answer, -ddump-simpl and look at the core.
11:04:52 <rwbarton> oh
11:04:55 <vanila> narens, where can I download your code to try?
11:05:00 <narens> the link is on the post
11:05:02 <benmachine> as in concat (concat xsss) might involve some left-associations even though each individual thing associates to the right
11:05:04 <rwbarton> probably the dlist destroys sharing, which is good for you
11:05:16 <vanila> https://github.com/nanonaren/blog/blob/master/dlist.lhs
11:05:17 <rwbarton> (not having read your code carefully)
11:05:37 <narens> oops, hang on
11:06:04 <narens> vanila: okay, pushed
11:06:10 <vanila> thanks
11:07:38 <seydar> cabal is giving me more trouble. i think this is a sign that i should be studying instead
11:08:19 <seydar> recently i tried to order a book on a foreign language, and instead the book i received was "the idiot's guide to physics", the subject i'm supposed to be studying for
11:09:24 <vanila> I have to install a million libraries to run this code
11:10:05 <vanila> http://pastebin.com/raw.php?i=bZ7SFNtQ
11:10:18 <narens> yea, criterion is big
11:10:38 <vanila> cabal: Error: some packages failed to install:
11:10:42 <Cale> narens: Out of interest, how does  cartesian f s = fmap (foldl' f s) . sequence  compare?
11:11:04 <vanila> /tmp/pkgConf-vector-th-unbox-0.2.13171.0: hGetContents: invalid argument(invalid byte sequence)
11:11:44 <narens> Cale: checking
11:11:52 <Cale> narens: also, you're compiling with -O2?
11:12:03 <narens> Cale: with -O
11:12:08 <Cale> good enough, probably
11:12:27 <narens> 133/125 for the first one
11:12:33 <narens> quite slow
11:12:44 <benzrf> :t \f s -> fmap (foldl' f s) . sequence
11:12:46 <lambdabot> (Functor f, Monad f) => (b -> a -> b) -> b -> [f a] -> f b
11:12:51 <Twey> mjrosenb: Well, you can also downgrade all your system.  The old versions of packages are still *there*.
11:13:07 <Cale> Oh, given that this is a microbenchmark, maybe use liftM instead
11:13:19 <Cale> (to avoid passing the Functor instance)
11:13:22 <benzrf> :t travserse
11:13:22 <Tekmo> How difficult is it to write a new foreign function interface for ghc?
11:13:23 <lambdabot>     Not in scope: ‘travserse’
11:13:23 <lambdabot>     Perhaps you meant one of these:
11:13:23 <lambdabot>       ‘traverse’ (imported from Control.Lens),
11:13:29 <benzrf> :t T.traverse
11:13:30 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:13:45 <Twey> benzrf: Sodium has dynamic event switching that doesn't leak memory all over your system.  :þ
11:13:49 <Cale> Tekmo: What does that even mean? Reimplement the FFI spec?
11:13:54 <benzrf> Twey: banana leaks memory all over your system?
11:13:55 <Tekmo> Cale: No, I mean for a new language
11:14:09 <Tekmo> Cale: The language I'm interested in interfacing with is Python
11:14:10 <Cale> ah
11:14:31 <Twey> benzrf: Banana currently doesn't garbage-collect dynamic events
11:14:35 <benzrf> rly
11:14:35 <Cale> Does Python have a C API?
11:14:39 <benzrf> i did nt knw that
11:14:41 <benzrf> Cale: duh
11:15:01 <narens> Cale: weird, how could fmap vs. liftM make a difference? the first one gives 118/127
11:15:12 <Twey> benzrf: Heinrich Says it's not a fundamental problem, he just hasn't got around to implementing it
11:15:20 <benzrf> mfw
11:15:22 <Tekmo> Cale: I just checked, and I think it does
11:15:24 <Cale> narens: There's effectively an extra function parameter
11:15:26 <benzrf> well i dont feel like learnin ga new api
11:15:27 <benzrf> ( ͡° ͜ʖ ͡°)
11:15:39 <narens> Cale: and it made dlist slower
11:15:47 <Twey> benzrf: Citation http://apfelmus.nfshost.com/blog/2014/01/29-frp-banana-0-8.html
11:15:57 <Cale> narens: hm!
11:16:14 <Tekmo> Cale: I will give the C bridging interface a try
11:17:45 <benzrf> :t arr
11:17:46 <lambdabot> Arrow a => (b -> c) -> a b c
11:17:47 <benzrf> right
11:18:03 <benzrf> should i look into netwire if i dont know shit about arrows
11:19:10 <Tekmo> benzrf: You don't need to use arrows to program with netwire
11:19:33 <platz> I've been enjoying jle's posts on autos
11:19:42 <benzrf> Tekmo: b-but it says 'arrowized'
11:19:46 <benzrf> arrowised, maybe
11:20:19 <Tekmo> benzrf: Arrows are a really nice feature, but there are other ways to use it
11:20:29 <Tekmo> benzrf: Arrows aren't really that hard to use
11:20:47 <Tekmo> benzrf: If you turn on the `Arrows` extension they are very easy to use
11:21:03 <Tekmo> benzrf: http://www.haskell.org/arrows/syntax.html
11:21:36 <Twey> That's a very confusing page if you don't already know arrows.
11:21:55 <Tekmo> benzrf: This page is also helpful: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
11:23:10 <int3__> so I have a list of functions fs which take lists, and I'm doing `fmap ($ xs) fs`. is there some 'declarative' way to make it return [] if xs == []?
11:23:23 <pepper_chico> after installing Yesod to a cabal sandbox, how should I use it? I'm trying a hello-world.hs inside the sandbox directory but I just get Yesod couldn't be found, I've also tried to cabal init a project inside the sandbox, but I got the same result
11:23:27 <int3__> i.e. aside from pattern matching on xs
11:23:29 <Tekmo> int3__: It already does
11:23:43 <Tekmo> int3__: fmap _ [] = []
11:23:52 <int3__> Tekmo: no, it's not fs that is []
11:24:00 <vanila> int3__, if null xs then return [] else fmap ($ xs) fs`
11:24:01 <int3__> Tekmo: it's xs in `fmap ($ xs) fs`
11:24:15 <Tekmo> int3__: Oops
11:24:38 <int3__> vanila: yeah, but that's kind of like pattern matching... I was just curious if there was any algebraic structure that I wasn't aware of
11:25:04 <vanila> there isn't
11:25:39 <Tekmo> int3__: There might be one, but not one shorter than just defining a helper function
11:26:09 <int3__> fair enough
11:26:19 <pepper_chico> help?
11:26:33 <Tekmo> int3__: However, the general answer is that if you want pattern matching with algebraic properties, then you usually want prisms from the lens lbirary
11:26:59 <int3__> Tekmo: okay, I'll put that on my reading list :)
11:32:50 <joe9> Need help with viewing requestBody of http-conduit, please? error message : "*** Exception: <interactive>:3:5-46: Irrefutable pattern failed for pattern (Network.HTTP.Client.Types.RequestBodyBS bodyString) , code : http://lpaste.net/108232 , how I tried to see it ghci: http://lpaste.net/108233
11:32:54 <joe9> Any thoughts, please?
11:35:00 <Cale> joe9: That says requestBody r doesn't actually match the pattern RequestBodyBS bodyString
11:35:27 <Cale> joe9: Nothing up until the exception actually demanded the evaluation of bodyString, which meant that requestBody r wasn't evaluated until that point.
11:35:33 <joe9> Cale: thanks. it was in the RequestBodyLBS
11:35:43 <joe9> Cale, Thanks.
11:36:25 <joe9> Cale, Do you know how to add socksProxy to http-conduit?
11:36:37 <Cale> I've never used http-conduit, but I could look
11:36:44 <joe9> Cale, no, that is fine.
11:36:55 <joe9> Cale, I do not want to bother you with it.
11:39:29 <phaazon> isn’t there already a way to alias {-# UNPACK #-} to #?
11:39:31 <phaazon> like
11:39:42 <phaazon> data Foo = Foo !#Float
11:39:46 <phaazon> or #!Float
11:42:18 <kuribas> :t Infinity
11:42:19 <lambdabot> Not in scope: data constructor ‘Infinity’
11:42:29 <kuribas> > 1/0
11:42:30 <lambdabot>  Infinity
11:43:10 <kuribas> Can I use (1/0) as Infinity?
11:43:14 <kuribas> portably?
11:43:46 <kazagistar> kuribas: "portably"?
11:44:22 <kuribas> I mean, so that it will not break in the future?
11:45:04 <int3__> edwardk: how do I do a catamorphism over a Cofree structure? Since Mu and Cofree are so similar, I'm sure there's some way to do the same thing to both, but I can't figure out how to...
11:45:47 <edwardk> int3__: you can think of cofree as mu (really nu) applied to a modified form of the base functor
11:46:21 <edwardk> Cofree f = a * f (a * f (....)   -- so what you really have is Nu (Compose ((,) a) f)
11:46:24 <kazagistar> > recip (1/0)
11:46:26 <lambdabot>  0.0
11:47:08 <Ankhers> If I have multiple threads reading from a Chan, is it guaranteed that multiple threads will not retrieve the same value?
11:47:08 <edwardk> similarly Free looks like Mu (Compose (Either a) f) if you squint
11:47:20 <benzrf> > 1 / 0 :: Rational
11:47:21 <lambdabot>  *Exception: Ratio has zero denominator
11:47:24 <int3__> hmm let me lpaste my code, I thought I was writing my `cata f` to match those types but apparently not
11:47:27 <benzrf> man!
11:47:34 <edwardk> on the other hand: IterT f = Nu (Compose f (Either a))
11:47:39 <kazagistar> kuribas: I would at least give it a specific type, since it could be anything of (Num a, Fractional a), which might not have the same properties...?
11:47:45 <edwardk> int3__: you need to write the conversion to/from that form by hand
11:48:00 <int3__> edwardk: ok, I will try that first
11:48:00 <edwardk> int3__: i don't have anything to provide cata-like stuff for Free/Cofree
11:48:03 <int3__> oh
11:48:09 <edwardk> but that is the choice of base functor you need
11:48:12 <benzrf> Free f a = Compose (Either a) f a?
11:48:13 <benzrf> err
11:48:14 <flebron> Hi. What's the friendliest API to run an external program (a-la system("...")), and capture its stdout and stderr as easily as possible?
11:48:16 <benzrf> Free f a = Compose (Either a) f (Free f a)?
11:48:30 <benzrf> oic
11:48:55 <benzrf> an arbitrarily-nested stack of f's over an a
11:48:55 <kuribas> kazagistar: yes, true
11:48:58 <Tekmo> flebron: System.Process.readProcess
11:48:59 <benzrf> neat
11:48:59 <edwardk> benzrf: that is what the wrapping/unwrapping shows you
11:49:37 <flebron> Tekmo: How do I read stderr from that?
11:49:49 <Tekmo> flebron: System.Process.readProcessWithExitCode
11:49:59 <Tekmo> flebron: The latter includes `stderr` as one of its results
11:50:00 <flebron> Ah, nice. Thanks!
11:50:04 <Tekmo> flebron: You're welcome!
11:50:05 <benzrf> is there a way to take a class's methods and mechanically generate a free structure
11:50:38 <benzrf> i am sure that that question is indicative of horribly structured learning :p
11:50:56 <narens> :t fix
11:50:58 <lambdabot> (a -> a) -> a
11:51:27 <benzrf> fix is isomorphic to 'a'!
11:51:50 <kazagistar> benzrf: how would you generate a "free Read"?
11:52:00 <benzrf> kazagistar: heh, fair point
11:52:02 <benzrf> >.>
11:52:24 <narens> > 1+1
11:52:25 <benzrf> and i suppose things like free monads depend on the laws too
11:52:26 <lambdabot>  2
11:52:47 <narens> > take 10 $ fix (\x -> 1 : 1 : 2 : zipWith (+) (tail (tail x)) (tail x))
11:52:49 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
11:52:51 <narens> can we make it any more succint?
11:52:51 <int3__> edwardk: is there a particular reason why you didn't write Cofree in terms of Mu?
11:53:05 <int3__> or Nu, rather
11:53:09 <benzrf> i never fail to read Cofree as Coffee
11:53:16 * benzrf needs a cup of cofree
11:53:18 <vanila> narens, you don't need to tail tail
11:53:24 <int3__> benzrf: *google* never fails to, either. I keep getting spelling suggestions.
11:53:31 <vanila> > fix (\x -> 1 : 1 : zipWith (+) (tail x) x)
11:53:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:53:33 <edwardk> partially because Nu is really really noisy to use in code
11:53:33 <kazagistar> benzrf: I dont know this stuff at all... it might be possible to derive it for any ____, but that structure is not a Haskell class
11:53:47 <int3__> I see
11:53:52 <benzrf> what's Nu?
11:53:57 <benzrf> is it like co-mu
11:53:59 <edwardk> also the existing definition memoizes better than Nu would. comparing to Fix would be more fair
11:54:17 <int3__> benzrf: it is co-mu, as I understand
11:54:46 * benzrf tries to figure out what that could be
11:55:07 <edwardk> newtype Mu f = Mu { runMu :: forall a. (f a -> a) -> a }  -- data Nu f where Nu :: a -> (a -> f a) -> Nu f
11:55:09 <benzrf> newtype Mu f = In (f (Mu f))
11:55:16 <benzrf> edwardk: wait, what
11:55:22 <benzrf> since when is that what Mu is
11:55:24 <benzrf> oh i see thats isormophic
11:55:25 <edwardk> the version of Mu you have there is a nicety of haskell
11:55:28 <benzrf> *isomorphic
11:55:31 <benzrf> edwardk: orly
11:55:45 <benzrf> how so?
11:56:08 <edwardk> there are categories where Mu and Nu are not interconvertible. where you can turn Mu f into Nu f but not back
11:56:15 <vanila> > fix $ ([1,1]++) . (zipWith (+) <$> tail <*> id)
11:56:16 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:56:23 <vanila> using applicative notation to make it pointfree
11:56:23 <benzrf> i dont know shit about mu in category theory
11:56:29 <benzrf> i only know it as type-level fix
11:56:41 <benzrf> and i only slightly know what 'co' as a categorical prefix means
11:56:45 <narens> vanila: pointfree is nice
11:56:58 <edwardk> Mu properly is a claim you can fold something with a catamorphism, Nu is about being able to build it with an anamorphism
11:57:09 <benzrf> oh
11:57:11 <edwardk> in a strict language the thing you can tear down would be finite
11:57:12 <benzrf> neat
11:57:30 <kazagistar> @quote zip'ap'tail
11:57:31 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:57:34 <edwardk> but the thing you build up? nothing says you stop building
11:57:37 <kazagistar> hmm, oh well
11:57:54 <vanila> :t zip `ap` tail
11:57:55 <lambdabot> [b] -> [(b, b)]
11:58:02 <edwardk> so you can think of Mu as talking about something you should be able to tear down, and Nu about something you know how to keep adding layers to using some kind of seed
11:58:22 <edwardk> Mu is about folding, Nu is about unfolding. it _happens_ that in Haskell Fix is both
11:58:49 <benzrf> cool
11:58:50 <edwardk> but if you become more careful about dealing with recursion or work strictly you have to care
11:59:05 <int3__> edwardk: thanks, that was clear
11:59:16 <benzrf> > zip <*> tail $ [1, 2, 3]
11:59:17 <lambdabot>  [(1,2),(2,3)]
11:59:51 <benzrf> flip zipWith (+) <*> tail
11:59:56 <benzrf> zipWith (+) <$> tail <*> id
11:59:59 <kazagistar> @quote zip`ap`tail
11:59:59 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
12:00:08 <benzrf> lmao
12:00:38 <benzrf> <*> is shorter than `ap` though
12:01:05 <benzrf> it could look like an aztec glyph if you tried hard enough, i bet
12:01:25 <vanila> I wonder what the shortest haskell program to generate fibs is
12:01:35 <vanila> :t scanl
12:01:36 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
12:02:24 <vanila> > fix(scanl(+)0.(1:))
12:02:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:02:28 <vanila> my nomination
12:02:43 <vanila> oh you can $ it to make it shorter
12:02:46 <Nik05> probably all over the internet
12:02:51 <vanila> link?
12:03:02 <narens> vanila: imo, shortest /= beautiful
12:03:05 <benzrf> vanila: god damn
12:03:07 <vanila> agreed
12:03:11 <vanila> @narens
12:03:11 <lambdabot> Unknown command, try @list
12:03:30 <benzrf> > scanl (+) 0 [1..]
12:03:32 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
12:03:39 <benzrf> oh
12:03:49 <benzrf> > scanl (+) 0 [1,1..]
12:03:51 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:03:55 <benzrf> wait oops
12:04:00 <benzrf> oh i see derp
12:05:40 <benzrf> > scanl (+) 0 [1]
12:05:41 <lambdabot>  [0,1]
12:05:45 <benzrf> > scanl (+) 0 [0, 1]
12:05:47 <lambdabot>  [0,0,1]
12:05:55 <benzrf> > scanl (+) 0 [1, 0, 1]
12:05:57 <lambdabot>  [0,1,1,2]
12:06:05 <benzrf> > scanl (+) 0 [1, 0, 1, 1, 2]
12:06:06 <augur_> anyone knowhow to use TacticalGrace's C inliner?
12:06:07 <lambdabot>  [0,1,1,2,3,5]
12:06:08 <benzrf> cool
12:12:21 <mmmm> Is there a nice way to "convert" a maybe interface into an Either interface?
12:12:29 <NikolajK> where can I find the code setting up the IO monad? the hackage toturials on hackage first introduce examples and "stories which aren't real" and I don't quite know what I'm at
12:13:15 <narens> "setting up"? the IO monad?
12:13:35 <bergmark> mmmm: easier to go the other way around since Either adds information
12:13:50 <bergmark> mmmm: otherwise Either () a is the only thing you can do
12:14:16 <NikolajK> the main definitions
12:14:20 <ReinH> NikolajK: what you are asking for is a natural transformation :)
12:14:32 * hackagebot vty 5.1.3 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.1.3 (CoreyOConnor)
12:14:34 <ReinH> with Maybe a <=> Either () a being an isomorphism
12:15:00 <NikolajK> I don't quite know what () does, though
12:15:08 <ReinH> NikolajK: it's the unit type: data () = ()
12:15:13 <ReinH> (it's really an empty tuple)
12:15:29 <ReinH> think of it as the terminal object
12:15:35 <NikolajK> I just saw someone saying there is a non-identity function of type a->a
12:15:36 <ReinH> if that helps
12:16:03 <ReinH> NikolajK: that can't be so
12:16:06 <ReinH> if we ignore bottoms
12:16:12 <ReinH> there's f = undefined ofc
12:16:20 <ReinH> and f a = undefined
12:16:46 <hanshoglund> Hi all, I am trying to install GHC 7.8.2 on an AWS Ubuntu instance, but I get 'error while loading shared libraries: libgmp.so.3'. Anyone knows what to do?
12:17:04 <NikolajK> it was something with undefined
12:17:25 <kazagistar> NikolajK: if you want something simple... { maybe (Left "Nothing") Right }
12:17:26 <mmmm> haskoiner: You need to install libgmp :P
12:17:30 <ReinH> NikolajK: right, if we ignore bottoms, there is only one function a -> a and it is id
12:17:33 <kazagistar> er, wait
12:17:40 <kazagistar> that was meant for mmmm
12:17:47 <ReinH> and there is only one function *up to isomorphism* and it is id
12:17:48 <NikolajK> so where is the code for the monad, where is >== defined? or let's say why does IO a seem to be a function returning a pair
12:17:57 <NikolajK> type of*
12:18:04 <ReinH> :t (>>=)
12:18:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:18:07 <ReinH> is defined with the class
12:18:20 <hanshoglund> I got that, so I did ' sudo apt-get install libgmp3-dev' but it didn't help. Maybe the wrong version?
12:18:21 <ReinH> instances are defined separately, and IO's instance is hidden away
12:19:03 <kazagistar> :t maybe (Left ()) Right -- mmmm
12:19:04 <lambdabot> Maybe b -> Either () b
12:21:10 <NikolajK> when I deal with lists and Maybe at once, how does it know which "return" I mean?
12:21:33 <NikolajK> say "return 3", [3] or Just 3
12:21:38 <Clint> through the type system
12:21:54 <kazagistar> NikolajK: depends on what type it expects
12:22:10 <narens> > return 3 :: Maybe Int
12:22:12 <lambdabot>  Just 3
12:22:16 <narens> > return 3 :: [Int]
12:22:18 <lambdabot>  [3]
12:22:19 <kazagistar> > head (return 3)
12:22:20 <lambdabot>  3
12:22:41 <SrPx> is there a way to append a string to the result of getLine without using variables?
12:22:42 <kazagistar> > fromJust (return 3)
12:22:44 <lambdabot>  3
12:23:05 <geekosaur> :t fmap (++ "xxx") getLine
12:23:06 <lambdabot> IO [Char]
12:23:11 <NikolajK> what does head do?
12:23:17 <NikolajK> (forgot, I think)
12:23:25 <kazagistar> NikolajK: takes the first item of a list
12:23:34 <kazagistar> :t head
12:23:35 <lambdabot> [a] -> a
12:23:45 <geekosaur> NikolajK, any expression is in a single monad, you can't switch in the middle
12:23:46 <NikolajK> :t \x->x
12:23:47 <lambdabot> t -> t
12:24:12 <NikolajK> > 3+3
12:24:13 <kazagistar> NikolajK: so because it needs a list, it "tells" return which type to use
12:24:14 <lambdabot>  6
12:24:21 <tobiasgw> hey guys, I'm playing with the idea of visualizing a Haskell library. The idea is to draw a graph with two kinds of nodes: types and functions. Here's a very rough example http://www.tobiasgw.no/http-conduit.pdf
12:24:33 <tobiasgw> made that for http-conduit
12:24:44 <kazagistar> NikolajK: (you can also play with lambdabot through private messages)
12:24:46 <NikolajK> > return 3
12:24:48 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
12:24:48 <lambdabot>    arising from a use of ‘M829579468317554245710013.show_M8295794683175542457...
12:24:48 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
12:24:48 <lambdabot>  Note: there are several potential instances:
12:24:48 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:25:11 <SrPx> geekosaur: thanks, I was doing that... the error was somewhere else
12:25:17 <NikolajK> to whom
12:26:06 <kazagistar> NikolajK: you can /msg lambdabot with your commands instead of in the chat, if you wanna do a lot of noise experimentation or whatever
12:27:10 <kazagistar> NikolajK: the reason the last one had an error is because it could not figure out which "return" you meant, and which "show" it should use to display the resulting value
12:27:57 <Pythonfant> tobiasgw: nice I like that idea
12:28:16 <kazagistar> tobiasgw: that looks pretty cool, even if it is a bit... impractically wide right now :P
12:28:20 <Pythonfant> probably some interactive js stuff would be a bit easier to navigate
12:29:23 <tobiasgw> yes, I'm thinking you should only see the types/functions you select
12:29:25 <tobiasgw> :)
12:29:29 <NikolajK> "type IO a  =  RealWorld -> (a, RealWorld)" says it in "IO Inside". Is that part of the "story" or is it to be taken literally
12:29:32 <kazagistar> that looks like graphviz, right?
12:29:36 <tobiasgw> and that way you can expand the graph in any direction you want
12:29:36 <NikolajK> someone should rewrite that
12:29:42 <tobiasgw> kazagistar: yes
12:29:59 <SrPx> > main = putStrLn <$> (("Hello, " ++) <$> getLine) -- I understand this can't work as the 2nd operand is `IO String`, not `String`. How do I make this work without using variables?
12:30:01 <lambdabot>  <hint>:1:6: parse error on input ‘=’
12:30:04 <benzrf> NikolajK: its close to being literal
12:30:06 <benzrf> but only for ghc
12:30:15 <benzrf> its not in the report afaik
12:30:17 <benzrf> might be wrong
12:30:39 <NikolajK> so every compiler has some freedom about how to implement "IO a"?
12:30:40 <tobiasgw> kazagistar: but I'm looking for some js library I can draw graphs with
12:30:40 <narens> :t ("Hello"++) <$> getLine) >>= putStrLn
12:30:41 <lambdabot> parse error on input ‘)’
12:30:46 <geekosaur> the report indeed doesn't say
12:30:52 <narens> :t (("Hello"++) <$> getLine) >>= putStrLn
12:30:54 <lambdabot> IO ()
12:30:58 <vanila> SrPx, (putStrLn  . ("Hello, " ++)) <$> getLine)
12:31:03 <kazagistar> NikolajK: it expresses the idea that IO acts kinda like the State monad, except that the "state" is the real world
12:31:13 <geekosaur> (except it's not)
12:31:32 <SrPx> narens: ah obvious, thanks (: vanila ty
12:32:01 <rio> geekosaur: so you're saying i don't have the real world inside my computer?
12:37:18 <kazagistar> well, a State does not have a "state", it is just acts as function that, if given a state, will return a new state and a value...
12:37:38 <NikolajK> ReinH: So the empty tuple is inhabited? :P
12:37:44 <flebron> Hi. If I know I have a list of length 2, is there a shorter way than f [x, y] = (x, y) to make a tuple out of it?
12:37:50 <ReinH> NikolajK: yes, by the empty tuple :)
12:38:11 <vanila> flebron, no that's the best/shortest way way
12:38:12 <ReinH> NikolajK: how many sets can you form with zero elements?
12:38:15 <ReinH> (up to isomorphism)
12:38:17 <vanila> -way
12:38:25 <tobiasgw> flebron: that's seems pretty short to me :)
12:38:36 <jfeltz> I just replaced my gcc from one installed from source (gcc-4.7), now ghc is complaining that it can't find /usr/bin/gcc, do I have to recompile ghc or something now?
12:38:41 <flebron> Alright :p
12:38:45 <kazagistar> @pl \[x,y]->(x,y)
12:38:45 <lambdabot> (line 1, column 2):
12:38:46 <lambdabot> unexpected "["
12:38:46 <lambdabot> expecting pattern
12:38:59 <NikolajK> how is the term called?
12:39:03 <NikolajK> () :: () ?
12:39:05 <vanila> liftM2 (,) head (head . tail)
12:39:12 <ReinH> :t () :: ()
12:39:14 <lambdabot> ()
12:39:16 <ReinH> Yep.
12:39:24 <ReinH> We often call it "unit"
12:39:36 <SrPx> Ok, I see I can use >>= in that case as it extracts the string and passes it to putStrLn. But what if the other side is not a monad? `main = putStrLn $ ((("Hello, " ++) <$> getLine) >>= (++ "!!!")) -- obviously won't work
12:40:05 <vanila> SrPx, the best way to write this is
12:40:16 <NikolajK> ReinH so you can call the unit return, which doesn't return at all. great.
12:40:17 <vanila>  do line <- getLine ; putStrLn ("Hello, " ++ line ++ "!!!")
12:40:29 <ReinH> NikolajK: I'm not sure about that last part
12:40:52 <SrPx> vanila: fair enough, but I'm just wondering if there is a way to write without the variable for learning purposes
12:40:56 <NikolajK> return as such only compute the IO action
12:41:01 <NikolajK> doesn't return to the human
12:41:03 <vanila> SrPx, This is short for:  getLine >>= (\line -> putStrLn . ("Hello, " ++ line ++ "!!!"))
12:41:09 <vanila> oops
12:41:16 <vanila> getLine >>= (\line -> putStrLn ("Hello, " ++ line ++ "!!!"))
12:41:17 <ReinH> NikolajK: `return' is a way to construct a value of type Monad m => m a from a value of type a
12:41:19 <ReinH> :t return
12:41:20 <lambdabot> Monad m => a -> m a
12:41:27 <narens> :t (("Hello " ++) <$> getLine) >>= putStrLn . (++ "!!!")
12:41:28 <lambdabot> IO ()
12:41:40 <NikolajK> yeah, I was thinking of IO's return in particular
12:41:42 <vanila> which you can rewrite as:  getLine >>= (putStrLn . ("Hello, " ++) . (++ "!!!"))
12:42:05 <kazagistar> I assume SrPx is trying to do learn "do-less, pointfree" style, which is educational but... not practical
12:42:36 <SrPx> kazagistar: yea, mostly for the educational part. vanila narens thanks
12:42:38 <ReinH> NikolajK: return () means "construct a value of type IO () that has no other 'effects'"
12:42:43 <vanila> The lesson here is: Start with something correct, like the do notation version, and then rewrite it/do program transformation to get it into the form you want
12:43:03 <SrPx> makes sense
12:43:08 <ReinH> NikolajK: () is used with IO similarly to void in some languages: to connote a computation whose return value is not interesting.
12:43:10 <benzrf> time for monad comps
12:43:31 <ReinH> NikolajK: so Either () a connotes an Either whose Left value is unintersting
12:44:12 <ReinH> State () a connotes a state transformation that produces an uninteresting state.
12:44:14 <ReinH> etc
12:46:19 <_sebastian_> Hey all. We've relauched Hayoo (hayoo.fh-wedel.de) the ranking still needs some tweaking, but the old hayoo was offline ...
12:46:47 <ReinH> NikolajK: right, return in Haskell doesn't mean what return means in other languages. It's named (afai can tell) so that when it appears in do notation, it looks familiar to users of other languages.
12:46:55 <ReinH> Whether this was a wise choice is arguable ;)
12:47:18 <NikolajK> they should have avoided accessibility at all cost
12:47:25 <kazagistar> (I still think it should be called "const")
12:47:33 <ReinH> NikolajK: Well, the concern is that it conflates two things that are not the same
12:47:42 <ReinH> NikolajK: and sometimes leads to a wrong understanding of what return does in Haskell
12:47:44 <NikolajK> I think it should be called terminal
12:48:02 <vanila> What is the etymology of 'return'?
12:48:43 <ReinH> NikolajK: we like for things to have accessible names, but we also don't like to confuse people unnecessarily.
12:48:45 <kazagistar> the reason it would be const is because it always "returns" the same thing, and "const" is the same as "return" for the reader monad anyways
12:49:01 <NikolajK> it replaced the name "unit" in the name triples - and triples was replaced by "monad"
12:49:18 <jfeltz> ffff, ok, solved by changing lib/ghc-7.8.2/settings: ("C compiler command", "/correct/path/to/gcc"),
12:49:38 <ReinH> NikolajK: unit, eta, whatever :)
12:49:43 <NikolajK> and units are the polymorphic terminal morphisms associated with one of the functors the triple stems from
12:50:01 <ReinH> NikolajK: is a natural transformation :)
12:50:03 <ReinH> *unit is
12:50:14 <NikolajK> yes, I don't want to alienate here
12:50:54 <ReinH> in Haskell terms it would be from Identity a -> m a, but you have to remove the newtype wrapper and rely on the isomorphism
12:51:04 <NikolajK> I guess they really only renamed it return because of it's role in the IO monad?
12:51:05 <cpa> guys, what's the modern way to use natural numbers at the type level? is this gist still up to date? https://gist.github.com/thoughtpolice/2345391
12:51:16 <ReinH> NikolajK: because of its role in do notation, I might say
12:51:24 <ReinH> of which IO is one of the primary motivators, ofc :)
12:53:16 <flebron> If I want to keep everything but the last 3 elements of a list, what's the most idiomatic way to say that? init . init . init?
12:54:04 <vanila> flebron, drop 3
12:54:16 <flebron> That'll drop the first 3, not the last 3.
12:54:24 <narens> reverse . drop 3 . reverse $ [1..10]
12:54:31 <narens> > reverse . drop 3 . reverse $ [1..10]
12:54:31 <ion> :-D
12:54:33 <lambdabot>  [1,2,3,4,5,6,7]
12:54:33 <ReinH> both traverse the list 3 times
12:54:34 * ReinH shrugs
12:54:34 <vanila> oops, sorry
12:54:35 <flebron> Yeah, but that's not particularly performant though, is it?
12:54:37 <jfeltz> *facepalms*
12:54:37 * hackagebot vty-examples 5.0.1 - Examples programs using the vty library.  http://hackage.haskell.org/package/vty-examples-5.0.1 (CoreyOConnor)
12:54:44 <ReinH> flebron: no less performant than yours
12:54:53 <vanila> hmmm
12:55:02 <vanila> it's kind of tricky to write an efficient function to do that!
12:55:04 <vanila> you can do it though
12:55:11 <flebron> Hrm. Should I write this manually and pattern match?
12:55:14 <narens> the most efficient would be to pattern match
12:55:21 <ReinH> you can do it as a fold that looks at 3 elements at a time, but that doesn't generalize well
12:55:23 <flebron> Sure, it's just checking [a, b, c] or the rest.
12:55:27 <vanila> flebron, yes but generalize it to take an n parameter, and still be efficient
12:55:51 <ion> > listToMaybe [ l | l@[_,_,_] <- tails "hello planet" ]
12:55:51 <flebron> I don't need a general n though, just 3 :)
12:55:53 <lambdabot>  Just "net"
12:56:37 <kristof> I don't know how pattern matches are checked against structures
12:57:24 <kristof> Wouldn't checking if there are exactly 3 elements left in the list mean that on every iteration, you check the next 4 elements?
12:57:40 <vanila> kristof, yeah exactly
12:57:41 <kristof> So you still traverse the entire list thrice, just in a different way
12:57:50 <vanila> it's tricky to do this, especially for a general n
12:57:55 <vanila> it makes an interesting programming problem
12:57:57 <flebron> kristof: Yep :)
12:58:10 <flebron> Though you could drop 3 when you do the check, kristof.
12:58:13 <ion> Pro tip: it’s tricky because we’re using the wrong data structure.
12:58:17 <kristof> ^
12:58:49 <vanila> well one way to do it is like
12:58:57 <kristof> If you know that there's always going to be a "set of three elements" at some fixed location in your data structure
12:59:07 <vanila> parallel recursion on list vs [length list, length list -1, ..]
12:59:10 <kristof> maybe you wanted a tuple, where the first element is a list and the second element is a 3-tuple
13:00:18 <vanila> > let f _ 3 = [] ; f (x:xs) n = x : f xs (n - 1) in f "hello world" (length "hello world")
13:00:20 <lambdabot>  "hello wo"
13:00:32 <NikolajK> we have "type IO a  =  RealWorld -> (a, RealWorld)" so "a" can be passed further and used and influence new computations in along the chain of functions we do?
13:00:41 <vanila> this is O(n), because it traverses the whole list twice
13:00:54 <vanila> it would be hard to do this with a single traversal
13:01:12 <kristof> NikolajK: the parameter of the parametric type IO is used for "stuff you get", so yes. When we're doing output, we use IO () because we "don't care".
13:01:51 <kristof> vanila: Read what I wrote.
13:02:25 <vanila> can you /msg me it or something?
13:02:50 <NikolajK> I must correct myself, the unit is the initial transformation, not the terminal one
13:03:18 <vanila> there's a huge netsplit happening and I don't know what you're referring to
13:03:54 <SrPx> Is it impossible to create a function to extract a string from "getLine"? Ie, an actual `getStr :: IO a → a` function?
13:04:07 <kristof> vanila: All I said was that if you know how many elements you want to "drop" at the end of a list, then maybe you shouldn't have encoded it into a list to begin with. Maybe it was better to have a 2-tuple composed of a list and a 3-tuple.
13:04:38 <_sebastian_> SrPx: I don't think, this type is not the one you intended
13:04:51 <kazagistar> SrPx: getLine does not "contain" a string. It is simple an IO action that fetches a string
13:04:51 <vanila> kristof, good idea actually I pasted a code snipped that uses that:
13:04:53 <kristof> Lists are for dynamically expandable collections that have constant time access to the head and constant time append-to-head.
13:04:54 <vanila> > let f _ 3 = [] ; f (x:xs) n = x : f xs (n - 1) in f "hello world" (length "hello world")
13:04:56 <lambdabot>  "hello wo"
13:05:09 <NikolajK> SrPx: IO is only called via main, right, so it must also output IO in the end (guess)
13:06:05 <kazagistar> SrPx: so you cannot "get a string" but you can make a function that if given a string does stuff, and then compose it with getLine to create a different IO action
13:06:43 <kristof> vanila: That is *not* what I said.
13:06:54 <vektor> Hey folks. Say I have an untrusted function with a non-IO type. What's the simplest way possible to check whether that function can have side effects?
13:06:54 <ion> > let f (a:b:c:xs) = Just (g a b c xs); f _ = Nothing; g a b c [] = [a,b,c]; g _ b c (x:xs) = g b c x xs in f "hello planet"
13:06:56 <lambdabot>  Just "net"
13:07:06 <vanila> kristof, ok
13:07:24 <kazagistar> SrPx: thats why the { type IO a  =  RealWorld -> (a, RealWorld) } story helps reasoning, because it makes it clear that is is more like a function, and less like a value, and you cannot get an a without a RealWorld (which does not exist in your computer)
13:07:28 <hpc> vektor: assume it has side effects :P
13:07:51 <kristof> vanila: That is the most optimum solution for dropping the last n elements of a list, though. But my point was that people... don't want to drop the last n elements of a list.
13:08:00 <SrPx> where can I see how the monad instance is implemented for IO?
13:08:01 <vektor> hpc: well, I want to ensure it doesn't have any.
13:08:01 <vanila> ah, that's a very good point
13:08:09 <NikolajK> haha
13:08:10 <ion> vektor: Kick the person who gave you the function if it does.
13:08:28 <vektor> ion: Well, the person is not a person and can not be kicked. It's a program.
13:08:30 <hpc> use the source, luke?
13:09:13 <ion> Programs are people, my friend.
13:09:15 <vektor> hpc: That's my thought. Which characteristics give away side effects? doesn't contain -XTrustworthy and compiles under -XSafe?
13:09:16 <kazagistar> how does lambdabot do it? just dont export the unsafePerformIO stuff?
13:09:36 <hpc> lambdabot does it with currated imports, yes
13:10:02 <vektor> oh, wait... Trustworthy is a compiler option. So basically, just compile it with -XSafe?
13:10:31 <kristof> vanila: It's like wanting to append to a vector. Or shuffle a list. The point is that you just *don't* do things to certain data structures.
13:11:00 <vanila> it all comes back to data structures - like someone mentioned before
13:11:32 <kristof> Right, so when people ask questions like that, rather than sit around coming up with optimum algorithms, I'd rather just say "that sounds silly".
13:12:13 <vanila> I'm not stopping you!
13:12:24 <rotorooter> nice
13:15:02 <kazagistar> Getting the last item of a haskell list is not something you can do safely anyways since valid lists dont always have endings
13:15:23 <kazagistar> but I guess thats not really the reason it is silly
13:16:44 <vektor> What's Safe Haskells "import safe" for, exactly? Don't seem to understand from reading the trac page...
13:18:04 <spopejoy> hey y’all. given f :: Parsec String; f = string “foo” <|> string “bar” , can I rewrite this using [“foo”, “bar”] somehow using applicatives?
13:19:17 <arancia> spopejoy: Maybe msum $ map string ["foo", "bar"]
13:19:46 <arancia> Watch out if the strings have common prefixes
13:20:39 <Ankhers> Does anyone have an example of how you can use Control.Concurrent.STM.TChan.isEmptyTChan? I don't know how to use the STM Bool that is returned.
13:22:41 <spopejoy> arancia: watch out specifically with this rewrite, or <|>’ing strings in general?
13:24:10 <dwcook> spopejoy, when using (<|>) in general. It does no backtracking by default.
13:24:17 <quchen> spopejoy: Maybe this helps, asum [a,b,c] = a <|> b <|> c
13:24:39 * hackagebot tightrope 0.2.0.0 - Nice API for a Slackbot  http://hackage.haskell.org/package/tightrope-0.2.0.0 (ian)
13:24:41 <arancia> :t asum
13:24:42 <lambdabot>     Not in scope: ‘asum’
13:24:42 <lambdabot>     Perhaps you meant one of these:
13:24:42 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
13:24:47 <arancia> :t F.asum
13:24:48 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:24:55 <arancia> :t msum
13:24:57 <lambdabot> MonadPlus m => [m a] -> m a
13:24:57 <dwcook> spopejoy, for Parsec in particular that is.
13:25:03 <quchen> asum = foldr (<|>) empty
13:25:09 <quchen> msum = foldr mplus mzero
13:25:28 <arancia> Ist mplus == (<|>) in Parsec?
13:25:31 <arancia> *Is
13:25:31 <quchen> Asum is the less restrictive function so I suggest going with that
13:25:32 <quchen> Yes
13:25:59 <quchen> I think Parsec's Alternative is literally contains "(<|>) = mplus"
13:26:13 <arancia> Okay
13:26:19 <croyd> hi all, I'm hitting an error I've never seen before doing some simple fibonacci calculations via matrix exponentiation here: http://lpaste.net/108242
13:26:21 <spopejoy> but then I need to map ‘string’ to each
13:26:23 <quchen> But in general it might be worth knowing about asum :-)
13:26:31 <croyd> does anyone know what could cause that?
13:26:48 <vanila> what error?
13:26:57 <croyd> Bus error: 10
13:27:01 <spopejoy> ie, asum $ map string [“foo”,”bar”]
13:27:07 <vanila> wow!
13:27:24 <vanila> that means an assembly instruction tried to read a misaligned byte or something
13:27:34 <vanila> must be a problem in the compiler
13:27:43 <quchen> croyd: I've never seen that error myself, but you may want to revisit your "negate" function regardless.
13:28:02 <croyd> quchen: good point
13:28:24 <croyd> quchen: it's never going to be used though, just an exercise
13:28:32 <vanila> cryon, it works on my computer
13:28:33 <arancia> spopejoy: What's wrong with mapping string?
13:28:40 <vanila> what CPU do you have?
13:28:42 <jcora> Hello everyone, which books or online articles would you guys recommend if I want to better understand what terms like monads, monoids, functors, categories, etc are? I suppose I should study Abstract Algebra and then Category theory - but do you have some specific suggestions? Thanks.
13:28:53 <quchen> You need category theory to write Haskell the same way you need automaton theory to write C.
13:29:02 <Cale> Which version of GHC? The program finishes fine on my machine
13:29:11 <quchen> Use them. You do not need category theory books to use monads in Haskell.
13:29:25 <spopejoy> arancia: nothing, but it looks like this is what I was thinking: asum $ string <$> [“foo”,”bar”]
13:29:27 <jcora> Well, sure, but I really do want to understand that. I was simply told that people here might have good suggestions.
13:29:38 <spopejoy> i just like getting applicative stuff in there wherever i can :)
13:29:39 <quchen> Oh. Nevermind me then
13:29:40 <Cale> croyd: Does it happen consistently?
13:29:49 <jcora> So my goal is not only to know Haskell - but theory in general better.
13:30:15 <jcora> But I suppose that coming to them in Haskell would be a good idea - I've only covered the basics at the moment, but I plan on progressing.
13:30:23 <croyd> I'm using GHC 7.8.3 on OSX 10.8.4
13:30:27 <spopejoy> jcora: have you checked out the Typeclassopedia?
13:30:42 <vanila> ok if you have an x86 CPU then it doesn't make sense why you'd get a bus error
13:30:45 <croyd> It happens every time I run it in ghci, but I just tried compiling it and didn't see the error
13:30:49 <jcora> spopejoy: I haven't heard of it, thank you.
13:30:54 <bmuk> Hey everyone, is there an easy way to parse a haskell source file to make sure it's valid? I'm thinking this would either use happy, ghc api, ghc with some command line option, or hlint.
13:31:18 <spopejoy> jcora: fantastic, extremely practical, yet it will still make your head spin :)
13:32:06 <Cale> croyd: works for me in ghci as well
13:32:14 <croyd> it seems like it's probably be related to this issue: https://ghc.haskell.org/trac/ghc/ticket/7655
13:32:19 <luite> bmuk: the haskell-src-exts library
13:32:43 <korczis> why is accelerate (talking about hackage) so slow? why it does not use all cores available and does not load them for 100%?
13:32:43 <luite> bmuk: the GHC API is also an option
13:32:44 <Cale> croyd: yeah, quite possibly
13:33:08 <bmuk> luite++
13:33:22 <korczis> anybody doing HPC with haskell? beating c/c++?
13:33:33 <Cale> croyd: perhaps you should submit your program as a test case there
13:33:34 <hpc> me?
13:33:43 <Cale> croyd: It looks like they're having trouble reproducing the problem.
13:33:56 <wyager> Hello everyone. I am trying to parse the contents of /dev/urandom as a stream of Word32s. My first thought was to try this: `wordStream = runGet (sequence (repeat getWord32be))` which is a function BL.ByteString -> [Word32]. However, this appears to greedily consume the input file and causes a stack overflow. Why might this be, and what should I try next?
13:34:22 <rwbarton_> croyd: yes it's probably related to that issue, any information would be greatly appreciated!
13:34:24 <Cale> croyd: oh, it looks like it might have something to do with whether you're using a real gcc or clang?
13:34:39 <spopejoy> HPC, isn’t it easy to beat c/c++ by formulating a problem that requires dynamic (unknown till runtime) memory allocation>
13:34:40 * hackagebot binary-typed 0.2.1.0 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.2.1.0 (quchen)
13:34:40 <spopejoy> ?
13:35:03 <spopejoy> i mean, there’s a class of problems that are better handled with a GC, thus haskell or Java
13:36:22 <rwbarton> croyd: such as if you could provide a crash report like the one in that ticket
13:36:29 <Hodapp> spopejoy: oh yes, that's quite well-documented.
13:36:44 <korczis> spopejoy: but in case of accelerate are the shapes and dimension specified in advance. memory requirements are know in advance.
13:37:03 <Hodapp> spopejoy: that's not even something that requires a GC, just something that handles allocation outside of the OS.
13:37:12 <croyd> rwbarton: ghc --info ?
13:37:40 <rwbarton> that is useful information also, but see the long block that starts with "Process:         ghc [27889]"
13:37:46 <Cale> wyager: Perhaps use runGetOrFail repeatedly in conjunction with drop?
13:37:59 <korczis> spopejoy: talking about following code - https://github.com/korczis/skull-haskell/blob/master/src/Lib/Parallel/Parallel.hs when I run it barely uses one core at all ...
13:38:14 <wyager> Cale: I could certainly just iterate drop on the bytestring and run getWord32be once on it, but that’s… ugly
13:38:16 <vektor> Does GHC, when compiling as Safe, trust Trustworthy libraries?
13:39:32 <spopejoy> korczis: you mean it parallelizes poorly? or it’s so efficient it doesn’t need to?
13:39:53 <korczis> spopejoy: exactly.
13:40:29 <korczis> spopejoy: I tried to do simple +1 operation on big matrix (1000x1000) and i expected to use all cores for 100%. What I am missing?
13:40:58 <Peaker> korczis: possibly unintentional laziness?
13:41:09 <spopejoy> See this book: http://chimera.labs.oreilly.com/books/1230000000929 “parallel and concurrent programming in haskell"
13:41:15 <wyager> So this works, but it’s not pretty: `wordStream input = map (runGet getWord32be) $ iterate (BL.drop 4) input`
13:41:39 <spopejoy> as in, “I don’t know so I’ll handwave with a good book"
13:41:51 <rwbarton> korczis, this is a poor test case
13:41:59 <wyager> I’m also not sure if BL.drop is efficient or not
13:42:07 <augur_> anyone familiar with the FFI?
13:42:28 <augur_> and/or with TacticalGrace's TH library?
13:42:30 <korczis> rwbarton: it is not test case at all, i was just surprised from result and I am trying to figure out what is going on.
13:42:32 <rwbarton> korczis, as the work you intend to do in parallel is not significantly greater than the cost of building the array in the first place, which must be done in serial (unless there is clever fusion happening)
13:42:35 <k00mi> korczis: accelerate is for GPU programming, but you're not using the GPU
13:42:46 <korczis> I know.
13:43:00 <korczis> I expected default implementation (Interpreter) to be more CPU efficient.
13:43:15 <rwbarton> BTW, that's a 100x100 matrix.
13:43:26 <k00mi> from the documentation: This interpreter is meant to be a reference implementation of the semantics of the embedded array language. The emphasis is on defining the semantics clearly, not on performance.
13:43:35 <Cale> wyager: It ought to be pretty efficient
13:43:36 <korczis> rwbarton: I modified the shape size locally.
13:43:53 <korczis> k00mi: ok, i missed that. my fault.
13:44:10 <wyager> Cale: Well ideally, ByString.Lazy.drop doesn’t make a copy of the ByteString, but I’m not 100% sure
13:44:13 <Cale> wyager: Strict bytestrings internally contain an offset into the chunk of memory that a pointer points at
13:44:13 <korczis> is there any CPU efficient accelerate implementation so?
13:44:21 <wyager> Cale: What about lazy ones?
13:44:27 <Cale> Lazy bytestrings are effectively lists of strict ones
13:44:30 <wyager> OK, cool
13:44:47 <k00mi> korczis: have a look at the repa package instead
13:45:41 <marchelzo_> what is the difference between the function 'state' and the data constructor 'State'?
13:45:42 <rwbarton> yes, repa but your example program is mostly non-parallelizable
13:46:33 <Cale> marchelzo_: For whatever reason, the newer versions of mtl decided to define State in terms of StateT
13:46:46 <Cale> marchelzo_: So 'state' is the replacement for the old State data constructor
13:46:55 <marchelzo_> Cale: ah. thank you
13:47:22 <korczis> rwbarton: why it is not parallelizable? the 100x100 operations on matrix can not be done in parallel using accelerate/repa ?
13:48:21 <korczis> I wanted to use the same interface for development and testing on cpu on my mac and than switch backend and run it on jetson tk1 with cuda backend.
13:48:31 <augur_> how do i cabal install something from a github repo?
13:48:50 <rwbarton> korczis, because it takes as much time to initialize the matrix from a list/loop as it does to sum it
13:49:16 <k00mi> augur_: clone the repo, 'cabal install' in the directory with the .cabal
13:49:34 <augur_> k00mi: ill give that a try, thanks :)
13:49:36 <korczis> rwbarton: ok, i will try to build bigger pipeline so and try eliminate laziness.
13:50:23 <korczis> thanks for hints.
13:50:24 <rwbarton> it's not really a laziness issue
13:50:40 <rwbarton> if you can find a way to initialize the array in parallel also, then you can get a full speed-up
13:51:00 <korczis> good point. will try to investigate.
13:54:15 <spopejoy> hmm … I thought <$> was pure, but it’s fmap. I thought the point of <$> in applicative expressions was to call ‘pure’ on the first argument …
13:54:34 <wyager> You thinking of <*>?
13:54:59 <rwbarton> you are thinking of   f <$> x  =  pure f <*> x
13:55:12 <rwbarton> which is one of the Applicative laws
13:55:22 <spopejoy> take the expression (+) <$> [1,2,3] <*> [4]
13:55:41 <spopejoy> i thought it was necessary to lift (+) via pure
13:56:12 <spopejoy> > (+) <$> [1,2,3] <*> [4]
13:56:14 <lambdabot>  [5,6,7]
13:56:21 <wyager> No, because your’re already lifting (+) into the list functor
13:56:27 <wyager> With <$>
13:56:49 <wyager> > ((+) <$> [1,2,3]) <*> [4]
13:56:50 <lambdabot>  [5,6,7]
13:56:58 <wyager> ((+) <$> [1,2,3])
13:57:00 <wyager> >((+) <$> [1,2,3])
13:57:08 <wyager> I wonder if that’s showable
13:57:21 <Cale> > ((+) <$> [1,2,3])
13:57:22 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
13:57:32 <Cale> It is in lambdabot :)
13:57:40 <wyager> Oh, I see, you need a space
13:57:45 <Cale> yes
13:57:49 <Exio> > (+3).(*2) <$> [1,2]
13:57:51 <lambdabot>  [5,7]
13:57:56 <Exio> > (+3) <$> (*2) <$> [1,2]
13:57:58 <lambdabot>  [5,7]
13:58:16 <augur_> *sigh*
13:58:22 <augur_> i hate haskell some times
13:59:04 <wyager> Anyway, yeah. (a -> b -> c) <$> m a   goes to m (b -> c). So you’re already lifting the function into the monad, so no need to call `pure`
13:59:17 <wyager> *lifting into functor
13:59:23 <augur_> i need to install language-c-quote
13:59:25 <augur_> can anyone help me
13:59:32 <augur_> im getting an error from cabal when i install it
13:59:33 <spopejoy> right, and pure == map == <$> == fmap for []
13:59:45 <Cale> augur_: which error?
13:59:51 <augur_> ghc: internal error: MUT_ARR_PTRS_DIRTY object entered!
13:59:51 <augur_>     (GHC version 7.6.3 for i386_apple_darwin)
13:59:51 <augur_>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:59:53 <augur_> Failed to install language-c-quote-0.8.0
13:59:55 <augur_> cabal: Error: some packages failed to install:
13:59:57 <augur_> language-c-quote-0.8.0 failed during the building phase. The exception was:
13:59:59 <augur_> ExitFailure 6
14:00:08 <spopejoy> now i’m wondering, where does pure != fmap?
14:00:24 <Cale> Okay, maybe try and see if that bug still exists in a newer GHC?
14:00:32 <cwraith> spopejoy: everywhere.  They have different types
14:00:44 <spopejoy> i guess i need to get out more often
14:01:00 <spopejoy> :t pure
14:01:01 <c_wraith> However, pure f <*> x is always the same as  f <$> x
14:01:02 <lambdabot> Applicative f => a -> f a
14:01:06 <spopejoy> :t fmap
14:01:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:01:16 <augur_> Cale: i have no idea how to install a newer version of GHC even if it didnt :(
14:01:21 <RyanGlScott> What exactly does hIsTerminalDevice from System.IO check for? e.g., hIsTerminalDevice stdin = True on Windows consoles, but = False on Cygwin.
14:01:34 <Cale> augur_: How did you install your current version of GHC?
14:01:40 <augur_> platform
14:01:50 <Cale> oh
14:02:03 <Cale> I always forget that people use that thing ;)
14:02:06 <mzero> hey!
14:02:10 <mzero> ;-)
14:02:16 <Cale> http://www.haskell.org/ghc/download_ghc_7_8_3#macosx_x86_64
14:02:22 <mzero> no
14:02:24 <mzero> don't use that
14:02:29 <Cale> oh?
14:02:40 <mzero> use either a) the RC1 candidate of the Platform if you want the whole thing
14:02:41 <spopejoy> c_wraith: now i get it, with the applicative law, <$> will always mesh with <*>
14:02:41 <mzero> or
14:02:49 <c_wraith> spopejoy: that's exactly correct
14:02:55 <mzero> b) use the -r3 binddist of 7.8.3 that I put up recently
14:03:07 <augur_> mzero: where are these and how do i use them
14:03:09 <RyanGlScott> There's also ghcformacosx.github.io
14:03:14 <mzero> both can be found here: http://www.ozonehouse.com/mark/platform/
14:03:41 <mzero> well, the GHC in ghcformacosx will likely have the same issues that the bindist on GHC page has
14:03:43 <RyanGlScott> Ooh, there's the new version of the Haskell Platform I keep hearing about
14:03:44 <spopejoy> style-wise, which is better: asum $ string <$> [“f”,”b”]  or  asum $ map string [“f”,”b”]
14:03:54 <wyager> Aren’t fmap and pure very different? e.g. fmap (show) creates a function [a] -> [String], where pure (show) creates a [a -> String]
14:03:56 <mzero> I'm working on the RC2 right as we type
14:03:59 <spopejoy> i like the former
14:04:10 <mzero> I expect it out tonight -- and it will almost certainly be the final release
14:04:11 <augur_> mzero: http://www.ozonehouse.com/mark/platform/Haskell%20Platform%202014.2.0.0%2064bit%20RC1.signed.pkg  ??
14:04:13 <spopejoy> because infix is the rulez
14:04:39 <mzero> sure - that has got the better build of 7.8.3 in it (fixes the haddock build issues! woot!)
14:04:42 <augur_> Cale: do you know anything about FFIing to ObjC?
14:04:54 <Cale> augur_: no, not really
14:04:57 <augur_> :(
14:05:23 <augur_> all i need to do is send data between the two languages, thats all. this is such a pain in the ass. :(
14:05:23 <mzero> only known mac bug in that RC is that it will fail to rebuild a haddock index for user installs
14:05:27 <RyanGlScott> I'm curious about ObjC FFI as well. I've heard that the OSX APIs can also be used with C, but I don't have a Mac to test it out.
14:05:53 <spopejoy> nobody feels like bikeshedding with me
14:06:25 <mzero> augur
14:06:25 <Cale> spopejoy: Either of those is fine. I don't personally tend to use <$> unless I'm also using <*>, but some people do.
14:06:39 <mzero> before you go to all that trouble.... do you want me to see if that package builds under 7.8.3
14:06:39 <augur_> mzero
14:06:52 <augur_> mzero: ive just downloaded it
14:07:01 <Cale> I might also write  asum . map string $ ["f","b"]
14:07:04 <augur_> plus, i want the new version of GHC anyway. i want typed holes!
14:07:09 <mzero> because that error really didn't imply a newer GHC would make it happy
14:07:12 <Lydia21>  You can find funny videos here. http://bit.ly/1zjIhnP
14:07:18 <mzero> oh - well, if you want holes... enjoy!
14:07:25 <RyanGlScott> Heh
14:08:09 <spopejoy> Cale: wow that’s an infix precedence lesson all in itself
14:09:11 <Cale> spopejoy: I tend to replace occurrences of f $ g $ h $ x with f . g . h $ x -- composition is nice where you can get it, because it's associative
14:09:11 <spopejoy> :i ($)
14:09:58 <fread2282> spopejoy: lambdabot doesn't have :i
14:10:05 <Cale> ($) is infixr 0, while (.) is infixr 9
14:10:05 <spopejoy> yes, just noticing that
14:10:05 <fread2282> :t ($)
14:10:06 <lambdabot> (a -> b) -> a -> b
14:10:18 <Cale> It's really too bad that ($) isn't infixl
14:11:10 <Cale> (but given the fact that (.) is associative and the nature of lazy evaluation, infixr is the correct associativity for it to have)
14:13:18 <RyanGlScott> Does anyone know why hIsTerminalDevice stdin gives False on Cygwin/MSYS?
14:13:26 <frerich> How pedantic are you guys with installing packages in sandboxes? I order to avoid the ‘cabal hell’, I made a habit of *always* working in a sandbox. Alas, this seems to mean that I cannot just fire up ‘ghci’ for some experiments anymore since either I’m not in a sandbox (i.e. no packages available) or the sandbox doesn’t ahve the package I need.
14:13:41 <frerich> I considered ‘cabal repl’ instead but it seems that wants to compile the project first. :-[
14:13:49 <rwbarton> I usually don't bother with sandboxes for this reason
14:13:50 <frerich> So I wonder whether I should just install common stuff globally...
14:14:05 <hpc> cabal sandbox repl?
14:14:21 * hpc is still on an old ghc and can't really help
14:14:22 <rwbarton> and only resort to sandboxes when I run into an actual dependency issue
14:14:41 <ernst> you can use cabal exec ghci though with sandboxes?
14:14:44 <frerich> hpc: I think that’s what I meant when I said ‘cabal repl’, I always used this and assume it’s a synonym...
14:15:12 <croyd> rwbarton, Cale: I added a comment to that ticket, thanks for helping out
14:15:13 <frerich> ernst: Ha!
14:15:21 <Cale> croyd: cool
14:15:21 <frerich> ernst: Excellent, that seems to work!
14:15:50 <hpc> frerich: as i understand it, having "sandbox" there matters
14:15:54 <frerich> ernst: It seems that ‘cabal exec ghci’ is what I always thought ‘cabal repl’ would be :)
14:16:16 <hpc> it says how to look for the compiled library (specifically, in the sandbox bin dir)
14:16:33 <frerich> hpc: ‘cabal sandbox repl’ isn’t a valid subcommand of ‘cabal sandbox’ in my version  (1.20.0.0).
14:16:40 <Cale> frerich: I only use sandboxes for specific projects where they're needed, and consider my home directory a kind of "default sandbox" which I wouldn't worry too much about throwing away and starting over.
14:16:53 <hpc> maybe i suck then :P
14:17:09 <hpc> Cale has good advice
14:17:47 <frerich> To be honest, this was the first time I used a cabal-install version with support for sandboxes, maybe I got a bit over-excited...
14:17:57 * frerich threw everything away and started with a sandbox-only setup...
14:18:03 <mzero> oy - the change in cabal layout in 1.18 is causing the platform headaches... but I think I have it under control...
14:18:14 <ernst> frerich: not sure if cabal exec ghci is the proper way to do it. just stumbled over it somehow by accident
14:18:39 <geekosaur> cabal repl?
14:18:53 <frerich> ernst: It seems to work, at least I can use it to tinker without requirng that my code actually typechecks
14:19:31 <trap_exit> haskell so great
14:19:44 <rwbarton> croyd: oh, just to check, where did you obtain your ghc?
14:22:19 <RyanGlScott> How do you check the version of MinGW/MinGW-w64 that is distributed with Windows GHC?
14:26:43 <croyd> rwbarton: bindist
14:26:50 <augur_> does ANYONE know how to do FFI stuff?
14:27:39 <augur_> i dont want to have to re-code this whole thing in Objective C :(
14:27:55 <RyanGlScott> augur_: I'm pretty sure it's possible, since Manuel Chakravarty's written a package for using inline ObjC code in Haskell: https://github.com/mchakravarty/language-c-inline
14:28:04 <RyanGlScott> I'm trying to find some simple examples ATM
14:28:21 <augur_> RyanGlScott: i know its possible, but haskell's resources for learning how to do anything are abysmal
14:28:37 <RyanGlScott> augur_: I fully agree with you there
14:28:46 <augur_> haskell is one of the worst languages as far as documentation goes, it practically unusable in that regard
14:29:21 <augur_> and all the people responsible have this "not my job" attitude that makes me simultaneously want to cry and murder
14:29:34 <augur_> because i end up thinking "why the hell did i waste my time doing this in haskell, what a fool i am"
14:30:07 <augur_> and i am a fool. every time i want to do something useful with haskell, i get almost to the end then get caught by some stupid problem like this
14:30:29 <augur_> every time. i should have learned my lession and abandoned haskell ages ago but i hold out hope :\
14:30:57 <benzrf> augur_: what
14:31:10 <benzrf> haskell usually has pretty good docs as far as i am aware o-O
14:31:22 <trap_exit> haskell has weird docs
14:31:22 <trap_exit> it's just a bunhc of types
14:31:25 <augur_> benzrf: you have low standards
14:31:29 <trap_exit> but if you stare at it a long time
14:31:30 <kristof> lol
14:31:31 <trap_exit> it makes perfect sense
14:31:33 <benzrf> augur_: maybe im not looking at the same things as you
14:31:40 <RyanGlScott> As far as Objective-C—Haskell FFI documentation is concerned, it is pretty sparse
14:31:41 <benzrf> which docs suck
14:31:53 <RyanGlScott> I have trouble distinguishing which things work and which are works in progress
14:32:00 <augur_> benzrf: anything related to the FFI is just abysmal
14:32:15 <RyanGlScott> Here's a proposed extension. I'm not sure if it's official now. https://ghc.haskell.org/trac/ghc/wiki/ObjectiveC
14:32:15 <rwbarton> FFI is easy; Objective-C is hard
14:32:33 <augur_> rwbarton: i can go through C for what im doing, using wrapper functions
14:32:38 <kristof> augur_: Did you read the cookbook?
14:32:40 <augur_> rwbarton: but that doesnt make the FFI docs any better
14:32:43 <benzrf> augur_: ah
14:32:45 <augur_> kristof: the cookbook is awful
14:32:46 <benzrf> i dont really use the ffi
14:32:48 <Peaker> FFI with C is easy until you want to use structs. Which is pretty much always
14:32:58 <Peaker> then it's really tedious
14:33:02 <trap_exit> oh, I use ghcjs + js ffi
14:33:04 <trap_exit> then everythign is just json
14:33:09 <RyanGlScott> Luckily, projects like hsc2hs and c2hs make working with structs much easier
14:33:17 <benzrf> so should i learn sodium & ditch banana
14:33:20 <augur_> Peaker: im just going to use objects in ObjC
14:33:30 <trap_exit> why soul danyone use ghc but not ghcjs?
14:33:37 <augur_> but that doesnt change the fact that the FFI tutorials are useless
14:33:38 <benzrf> it has been noted that bananas have potassium, which is more reactive than sodium
14:34:50 <augur_> a proper tutorial does more than show you how you call a function, it does more than dump a bunch of code on the screen and say "See? easy!"
14:35:13 <RyanGlScott> If you can use C's FFI, I recommend ezyang's tutorial on c2hs http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
14:35:19 <RyanGlScott> It's long, but well worth the read
14:35:45 <RyanGlScott> Wrapping everything in C functions kind of sounds like a bear though
14:38:16 <augur_> RyanGlScott: well thats the only feasible option right now afaict
14:38:44 <augur_> also that ezyang tutorial looks as useless as everything else ive seen
14:39:00 <RyanGlScott> augur_: You're probably right. In fact, I'm starting to think that projects like language-c-inline secretly use C behind the scenes for Objective-C stuff.
14:39:13 <augur_> they do
14:39:41 <augur_> thats what Chakravarty's TH project does for ObjC
14:40:28 <augur_> the problem that i find with all of these tutorials is, they dump a bunch of useless technical shit on you, and say "have fun", as if a pile of technical information is all you need
14:40:32 <hpc> i would expect the solution for objc to be the same as for c++
14:40:38 <hpc> where you do two foreign interfaces
14:40:45 <hpc> objc => c => hs
14:41:17 <augur_> and its like, no, im sorry, that doesnt suffice. you cant just provide technical information. that is not sufficient. you need to provide more than that.
14:41:36 <rwbarton> have you tried the RWH chapter on FFI?
14:41:46 <rwbarton> or is it also "useless technical shit"
14:41:48 <augur_> its like handing someone a language spec and saying, here, now you know the language! no, you dont know the language, there's more to it than just technical details
14:42:55 <augur_> rwbarton: RWH's chapter is so sparse its useless
14:43:37 <augur_> "here's one toy example that barely does anything!"
14:43:39 <rwbarton> you sure like complaining
14:43:42 <RyanGlScott> augur_: I'm not really sure if there's such an all-encompassing guide to Haskell FFI that you keep searching for. I learned it ultimately by trying out several examples and experimenting.
14:44:15 <augur_> rwbarton: if i could do more than complain i would, unfortunately thats all i can do right no
14:44:16 <augur_> w
14:45:13 <augur_> because i have this dread that im going to have to just abandon the whole of my Haskell code and rewrite the thing in ObjC which is going to take forever
14:46:16 <hiptobecubic> If Pipes apparently *doesn't* handle prompt resource finalization the way Conduit does, what is the advantage of using Pipes? I keep finding people talking about it being more elegant, but does it give you anything you can't just do with normal lazy IO?
14:47:48 <c_wraith> hiptobecubic: you get precise control of when the effects happen, unlike lazy IO
14:48:50 <hiptobecubic> c_wraith, ... except for finalization?
14:49:18 <c_wraith> hiptobecubic: no, that happens precisely, too.  You just don't have mechanisms for *early* finalization.  It's still not random.
14:49:51 <c_wraith> hiptobecubic: unlike lazy IO, where it's a function of when the GC decides to get around to it.
14:52:47 <hiptobecubic> c_wraith, i'm looking here http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit at "pipes: Prompt resource finalization"
14:53:13 <c_wraith> hiptobecubic: by "prompt" they mean "earlier than scoping-based mechanisms would allow"
14:54:27 <c_wraith> hiptobecubic: I'm not even sure I really buy the value of prompt finalization. It means you can't use region-based controls to ensure that a resource is valid and in scope at precisely the same times.
14:54:29 <hiptobecubic> does bracket not already give you that?
14:54:46 <hiptobecubic> c_wraith, what are region-based controls?
14:55:20 <c_wraith> hiptobecubic: stuff like http://hackage.haskell.org/package/regions
14:55:47 <augur_> *sigh* i wish ObjC had ADTs :(
14:56:06 <augur_> swift cant come out soon enough
14:56:32 <c_wraith> hiptobecubic: "prompt finalization" specifically implies "making a resource invalid before it goes out of scope".  It can be nice if your scopes are a mess, but it introduces new ways to add bugs to your program.
14:57:25 <rwbarton> is this something like "producer opens a file and produces an item for each line of the file, consumer only needs the first ten items, how to close the file after reading ten lines"?
14:57:31 <rwbarton> is that "prompt finalization"?
14:57:35 <c_wraith> rwbarton: yes
14:58:03 <c_wraith> rwbarton: though, more specifically, it'd be "consumer only needs to read 10 lines, then does a ton more work before finishing."
14:58:14 <rwbarton> right
14:58:34 <Iceland_jack> Has there been any more recent work on regions?
14:59:31 <ShaddowHacker> hi
14:59:52 <c_wraith> hiptobecubic: oh, and to answer your question..  No, bracket is not prompt finalization.  Bracket finalizes when the action ends, not before.
15:00:19 <hiptobecubic> c_wraith, no i'm not saying it's prompt. I'm saying that you get scope-based finalization, like you get in pipes
15:00:56 <c_wraith> hiptobecubic: ah, yes.  except bracket isn't composable, and that's the whole thing that makes pipes interesting. They compose. In like 5 different ways.
15:01:42 <hiptobecubic> I don't have enough pipes experience to appreciate it I guess
15:03:02 <c_wraith> Iceland_jack: I'm not aware of any new work on regions.
15:04:48 * hackagebot hslua 0.3.13 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.13 (OmerAgacan)
15:10:50 <augur_> *sigh* so im getting the following error from Chakravarty's language-c-inline library: http://lpaste.net/108247
15:10:56 <augur_> on the minimal example
15:12:30 <augur_> i dont know if this is due to the library itself, or to the new version of GHC, or what
15:14:03 <RyanGlScott> augur_: I hope it's not a clang vs. gcc issue. I've had a bunch of troubles with using clang with GHC on FreeBSD, so it's possible.
15:15:04 <geekosaur> if you're using clang with ghc, you'll need the "xcode 5 fix" (which is really a clang fix, and I've been wondering how long before someone on a *bsd hit it)
15:16:30 <augur_> RyanGlScott: is there a way to force ghc to use gcc not clang?
15:18:03 <RyanGlScott> Someone correct me if I'm wrong, but I think you have to specify the C compiler that GHC uses when you first install GHC.
15:18:33 <geekosaur> I thought ghc on fbsd used gcc anyway
15:18:45 <geekosaur> it does if you install from ports
15:18:51 <Kaidelong> I am kind of wanting to rip out my haskell installation and re do it to work with Win64
15:18:51 <augur_> RyanGlScott: how? i used the haskell platform
15:18:55 <augur_> mzero: any ideas?
15:18:57 <Kaidelong> well, mingw64
15:19:07 <mzero> augur
15:19:09 <mzero> what's the issue
15:19:09 <Kaidelong> (what is needed at this point to make GHC support windows natively?)
15:19:26 <mzero> if you have 7.8.3 from HP RC1 for OS X... you do *not* need the ghc-clang-wrapper
15:19:27 <augur_> mzero: ghc is using clang and it might be causing me problems with Chakravarty's ObjC inline
15:19:46 <mzero> your system has both clang and gcc on it?
15:19:58 <augur_> i have Xcode installed, so i assume yes
15:20:07 <mzero> no, you don't then
15:20:12 <mzero> as of Xcode 5 - gcc is history
15:20:14 <mzero> it is clang
15:20:16 <mzero> all the way
15:20:42 <mzero> and if Chakravarty's ObjC doesn't work with clang... well, that project has issues - since Apple has left gcc for good! :-)
15:20:51 <RyanGlScott> I recently installed GHC from binary on PC-BSD, and it tries to use clang by default.
15:20:53 <augur_> yeah
15:20:54 <augur_> well
15:21:28 <augur_> i dont know what the issue is, but im getting this error: http://lpaste.net/108247
15:21:29 <RyanGlScott> Kaidelong: I use MSYS2 to install GHC on Windows.
15:21:29 <mzero> augur_: that doesn't look like a clang-vs-gcc issue, BTW
15:21:37 <augur_> mzero: ok
15:21:49 <geekosaur> there is a lot of bitrotted objc stuff in the haskell ecosystem, from what I've seen. think I've hit some "oh, that uses gc, you lose" errors too
15:22:02 <geekosaur> (it's arc only these days)
15:22:05 <mzero> also, for others, as of 7.8.3, there is a lovely settings file entry that let's GCC use clang correctly by allowing the pre-processor arguments to be spec'd
15:22:50 <RyanGlScott> Kaidelong: It comes with MinGW-w64, I think.
15:22:55 <mzero> augur_: that looks like a linker / libs / version of objc runtime issues... but not really sure
15:23:13 <augur_> T_T
15:23:16 <augur_> i hate my life
15:23:23 <mzero> note - if you are using clang, you need a fixed cabal-install as well: the old ones were preprocessing some files twice in a row!
15:23:24 <phaazon_> I love your life!
15:23:45 <mzero> Johan nicely backported the fixes to both 1.18 and 1.20 branches, and they are now present
15:24:08 <phaazon> hey, I have an AST, and I’d like to update only one node (AST a -> AST a); how should I proceed? pattern match the whole thing? sounds horrible
15:24:09 <mzero> er, note - you need the newest Cabal lib, and then the newest cabal-install (in either of those two branhces) to work
15:24:15 <mzero> hackage now has 'em all
15:24:46 <mmmm> you can use generics phaazon
15:26:23 <mmmm> lookup the uniplate library on hackage
15:26:47 <augur_> why does everything have to be such a struggle
15:26:50 <augur_> why cant anything just work
15:27:30 <augur_> all i want to fricking do is send some data between ObjC and Haskell, why does this have to be such a difficult thing >_<
15:27:51 <mzero> because, saddly, no one has worked on the ObjC bindings in ages.... :-(
15:28:06 <mzero> and things bit-rot in the Haskell world /very/ quickly
15:28:22 <mwhit> it's just an issue of community size really
15:28:26 <mwhit> like a lot of things
15:28:37 <u-ou> what is bit rot
15:29:36 <augur_> i really dont want to reprogram this in objective c. i have no idea how im going to do ADT-like things
15:29:55 <mzero> u-ou: bitrot is when code stops working, even though no one has touched the source at all
15:30:09 <RyanGlScott> I'm not well-versed in Objective-C in particular, but you can kind of emulate ADTs in C with structs and unions.
15:30:35 <u-ou> ahh
15:30:37 <mzero> it happens when the things that source depend on (like libraries) change in ways that are not backward compatible, and the old code ceases to compile... or worse, compiles but the run time behavior is now wrong
15:30:52 <u-ou> mmmm
15:30:56 <mzero> in augur_ 's case - it compiles but doesn't link
15:31:04 <geekosaur> apple changes things fairluy quickly and with little thought for backward compatibility (see: clang)
15:31:13 <geekosaur> objc runtime has changed a lot
15:31:46 <augur_> RyanGlScott: unions arent quite right
15:31:53 <mzero> I have a pet theory that it happens in the Haskell world much more quickly because the tools are so good and keeping us safe, we are free to move our code forward, giving up backward compatibility, much more easily and swiftly than in other language ecosystems
15:32:14 <me> hello?
15:32:19 <RyanGlScott> augur_: I didn't say it was a perfect solution :)
15:32:26 <mzero> geekosaur: that's not fair - they had clang in developer's hands for > 2 years before switching over!
15:32:50 <mzero> and the incompatibility is only becuase GHC was depending on non-specified behavior in  the preprocessor
15:32:57 <mmmm> hello me
15:33:04 <augur_> ive become utterly dependent on ADTs, this is an awful situation to be in :(
15:33:27 <Guest63935> does anybody know who is in charge on developing GHC? also, who knows how to develop an extention?
15:33:31 <mzero> I agree... everytime I go to work and have to code in Python... I yearn for ADTs
15:33:42 <mzero> sometimes I just write them out in the comments to keep myself sane!
15:33:59 <mmmm> here's something I've been genuinely wondering, how do you refactor in a language like python?
15:34:07 <mmmm> and make sure everything still works
15:34:08 <mzero> Guest58938: start here: https://ghc.haskell.org/trac/ghc/
15:34:36 <mzero> or better, start here: https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions
15:34:36 <RyanGlScott> It's even more fun to emulate ADTs in Java.
15:34:55 <Exio> an high-order functions
15:35:18 <Exio> being dependant on high-order functions, or things like partial application
15:35:20 <mzero> mmmm: refactoring in Python is like crossing a giant chasam on a swinging rope bridge over a river full of crocodiles
15:35:35 <cjheath> mmmm: Same problem in Ruby; you use TDD/BDD.
15:35:53 <Spark> while piloting an aircraft made out of unit tests
15:36:09 <Exio> with a blindfold*
15:36:15 <kazagistar> mmmm: change code, run unit tests, hope unit tests are comprehensive enough
15:37:05 <mmmm> It's funny when you start to program you get annoyed by types getting in the way
15:38:34 <mzero> amazing - I was once an acolyte of both objects and unit-tests.... now I see them as impediments to software engineering
15:38:37 <Exio> mmmm, normally, people learn to program in languages where the type system isn't really "expressive"
15:39:13 <Ankhers> mzero: So, you don't write tests when you program in Haskell?
15:39:14 <puffie> in GHCi 7.6.3, I get an error when I use the string literal "\x" because it's recognized as hex, but "\\" evaluates to "\\" rather than the expected "\". Real World Haskell seems to say that the latter should happen. What am I missing?
15:39:26 <augur_> mzero: objects are an impediment. a bigger impediment is an unusable language. >_>
15:39:28 <mzero> I prefer to write quck-check properties
15:39:36 <mzero> and I write larger system tests
15:40:03 <cjheath> I think tests as being like double-entry book-keeping
15:40:12 <mzero> but since most good unit-test practices say you shouldn't bother writing tests for that which is obviously right (most examples in texts are things like getters and setters) ---
15:40:28 <mzero> -- in Haskell much much much more is obciously right - or it wouldn't compile!
15:40:28 <cjheath> If you can say what you expect in two different ways, and they agree, you havemore chance that it actually does behave that way
15:40:40 <mzero> So I right an order of magnitude fewer tests... or more
15:40:49 <kazagistar> many tests are trivially provable by the type system, where it makes little sense to write them
15:41:03 <Kaidelong> tests for things that should be obviously right actually seem like they should be really important
15:41:14 <Kaidelong> because if those tests break you know something is seriously wrong
15:41:17 <kazagistar> you already "write the same thing twice" often, once with code, and once with a type signature
15:41:24 <cjheath> using the double-entry analogy, if there’s no better/other/simler way to say what you expect, you can’t do double-entry
15:41:31 <Kaidelong> but a good type system is a better approach to that, unfortunately haskell does not provide that type system
15:41:33 <mzero> cjheath: often in Haskell... there is only one way to say something (modulo trivial syntatic changes)
15:41:40 <cjheath> exactly
15:41:56 <cjheath> why FP is important
15:42:24 <Kaidelong> RyanGlScott: So I should build GHC from source using MSYS on MingW64?
15:42:43 <romanandreg> May I take a few seconds of an attoparsec expert?
15:43:03 <Kaidelong> I would need a 64-bit haskell compiler to bootstrap that I suppose
15:43:09 <kazagistar> romanandreg: you should ask your question directly
15:43:11 <RyanGlScott> Kaidelong: Oh, you mean building from source. I've only built from a binary installation, although MSYS is probably the way to go if you're building from source.
15:43:11 <romanandreg> I’m trying to implement a parser that as far as I can tell, relies on a “lookAhead” kind of functionality
15:43:20 <benzrf> romanandreg: how so
15:43:21 <romanandreg> sadly, can’t seem to find it on the latests versions of attoparsec
15:43:28 <Kaidelong> RyanGlScott: I would defn prefer to not have to do it from source
15:43:35 <benzrf> :t atto
15:43:36 <lambdabot> Not in scope: ‘atto’
15:43:41 <RyanGlScott> Kaidelong: Good, because I've never done that either :)
15:43:41 <Kaidelong> I thought that Win64 GHC was impossible without building from source though
15:43:43 <benzrf> does attoparsec support try
15:43:49 <romanandreg> benzrf: trying to parse various entries, they start with “@@ “
15:44:10 <romanandreg> but between entries there is normal text, so I have to do a takeText up until I find “@@"
15:44:14 <romanandreg> I’m trying to use a many
15:44:16 <kazagistar> I think attoparsec does try automatically with Alternative, but I am not 100% sure, I haven't really used it much
15:44:24 <romanandreg> but if I stop the parser of the previus entry with a string “@@“
15:44:34 <RyanGlScott> Kaidelong: Not in my experience
15:44:36 <romanandreg> the next entry won’t parse correctly because the input has already been consumed
15:45:12 <romanandreg> I fixed the issue by implementing a sort of “lexer” separating the input by lines, and acc entries myself in lists
15:45:20 <romanandreg> but I would like a solution that only uses attoparsec
15:45:26 <romanandreg> ideally
15:45:37 <mzero> there is a win 64 bit release candidate of haskell platfrom if you folks want
15:45:42 <mzero> no need to build GHC from source!
15:45:44 <RyanGlScott> Kaidelong: The trickiest part is installing the network package, I've found.
15:45:57 <mzero> http://www.ozonehouse.com/mark/platform/
15:45:58 <RyanGlScott> Kaidelong: You pretty much have to use MSYS for it to work.
15:46:10 <mzero> second item there
15:46:31 <romanandreg> kazagistar: thanks for the IRC ettiquete rules, feel kind of a dushe asking for help without introducing first
15:47:22 <romanandreg> benzrf: I think try is embedded by default on attoparsec
15:47:32 <romanandreg> however, the problem is not on the matching, is on the consuming side of things
15:48:01 <kazagistar> romanandreg: from the docs "attoparsec parsers always backtrack on failure."
15:49:23 <RyanGlScott> Kaidelong: If you don't like the Haskell Platform, there's also a pre-built binary installation here http://www.haskell.org/ghc/download_ghc_7_8_3#windows64
15:50:02 <mzero> but - he wanted network - which is pre-built in the platform
15:50:04 <RyanGlScott> Kaidelong: You'll have to manually add the bin and mingw/bin directories to your PATH, though.
15:51:02 <romanandreg> kazagistar: yes… that’s right, I think I’m having troubles explaining myself, the problem is, that I’m trying to parse many entries that start an input like “@@ -number,number, +number,number @@ line \newline <many lines content here> \newline @@ -number,number …”
15:51:04 <Kaidelong> RyanGlScott: I like the haskell platform but I don't think a win64 haskell platform exists
15:51:13 <romanandreg> so basically, in order to know when an entry ends
15:51:19 <Kaidelong> so that isn't an option
15:51:27 <romanandreg> kazagistar:  need to parse the start of the next one (or is the end of input)
15:51:29 <mzero> Kaidelong: it does!
15:51:33 <Kaidelong> oh it does?
15:51:36 <Kaidelong> where do I find it?
15:51:47 <Kaidelong> I should uninstall my win32 haskell platform then and install that instead
15:51:51 <Kaidelong> that would be the best solution
15:51:55 <romanandreg> kazagistar: when I do that, the next time I’m trying to parse an entry, it fails because I already consumed the “@@"
15:51:56 <Kaidelong> then hopefully gtk2hs will finally build
15:51:57 <johnw> mzero: everything time I mention your name, my computation aborts
15:52:01 <johnw> every time
15:52:02 <mmmm> romanandreg: the lookAhead combinator
15:52:10 <dfeuer> Can someone suggest a path toward understanding the pipes package? I tried reading the official tutorial, but it's a bit spare.
15:52:18 <johnw> dfeuer: what trouble are you having?
15:52:28 <romanandreg> mmmm: not avaliable on the latest version of attoparsec as far as I can tell
15:52:34 <mzero> we have released Release Candidate 1 of  HP 2014.2.0.0
15:52:41 <dfeuer> johnw: doesn't that depend on which instance of MonadPlus you're using?
15:52:44 <mzero> it is at http://www.ozonehouse.com/mark/platform/
15:52:50 <johnw> dfeuer: real life is in IO
15:52:56 <RyanGlScott> mzero: Do you happen to know what version of MinGW/MinGW-w64 is distributed with HP 2014.2.0.0?
15:53:16 <mzero> there will be an RC 2 today or tomorrow am - but only minor diffs (some docs were missing, some extra files included that shouldn't have been)
15:53:30 <dfeuer> johnw: what trouble .... I'm not even sure I can describe what trouble. I'm just ... lost.
15:53:33 <mmmm> romanandreg: What about peekWord8?
15:53:52 <romanandreg> mmmm: can’t parse only a char at a time
15:53:55 <johnw> dfeuer: are you familiar with the idea of effectful streaming in general?
15:53:58 <romanandreg> I need to consume the first “@"
15:54:12 <augur_> how do OO people represent simple data
15:54:17 <augur_> i dont understand at all
15:54:19 <benmachine> augur_: complicatedly :P
15:54:21 <romanandreg> mmmm: making the next “entry parse” fail for the same reason (input already consumed)
15:54:22 <mzero> RyanGlScott & Kaidelong - release notes are here: http://projects.haskell.org/pipermail/haskell-platform/2014-July/002964.html
15:54:23 <dfeuer> johnw: probably not.
15:54:26 <augur_> they cant possibly use objects do they?
15:54:28 <johnw> dfeuer: meet me in #haskell-in-depth
15:54:35 <augur_> thats such an awful, verbose waste
15:54:50 <romanandreg> I need to parse two “@“, and peek can only give me a lookAhead of one, if I need to check the second one, I will have to parse
15:54:55 <Kaidelong> mzero: tx
15:55:08 <Kaidelong> very helpful
15:55:16 <kazagistar> romanandreg: so you are saying "sepBy" does not work?
15:55:53 <Kaidelong> I take it this is still using the old GHC though?
15:56:17 <Kaidelong> not that I mind that terribly, I haven't ever used 7.8 so I wouldn't be missing anything
15:56:19 <romanandreg> kazagistar: yes, sepBy doesn’t work because all entries start with the “@@ “ header, they are not separted by it, the difference would be, sepBy doesn’t expect the “@@“ in the first entry
15:56:45 <mmmm> parse the first @@ and then use sepby?
15:56:46 <romanandreg> also I need to keep the “@@ “ header contents when parsing, and sepBy discards them
15:56:55 <mzero> Kaidelong: no GHC 7.8.3
15:57:13 <romanandreg> kazagistar: basically I’m trying to do a git diff patch parser with Attoparsec
15:57:22 <quchen> I've got an Int32 and would like to get the first 8 bit as a Word8. Is there a nice built-in conversion function to spare me the bit twiddling?
15:57:22 <Kaidelong> oh yay
15:57:35 <mmmm> You'd probably have an easier time with parsec
15:57:36 <Kaidelong> well thank you for packaging that for us windows users
15:57:45 <kazagistar> romanandreg: why do you need to keep them? are you parsing a second time after you parse? your use case is confusing
15:57:58 <mmmm> there's a pull request on the attoparsec github which adds back lookAhead if you want to build that
15:58:03 <Kaidelong> appreciate the love and attention!
15:58:12 <gamegoblin> > (32 :: Word8) + 5
15:58:14 <lambdabot>  37
15:58:21 <romanandreg> mmmm: yes I saw that, commented why there is no feedback on it :-/
15:58:34 <romanandreg> mmmm: I guess I would try that
15:58:47 <romanandreg> mmmm: just wanted to know if there was something obvious I’m missing
15:59:02 <mmmm> out of interest why are you using attoparsec and not parsec?
15:59:25 <mmmm> performance?
16:00:03 <RyanGlScott> quchen: fromIntegral?
16:00:15 <romanandreg> mmmm: yes, tend to use attoparsec for performance reasons mostly, I preffer bos libraries when possible
16:00:30 <quchen> RyanGlScott: Does that simply truncate? I'm not terribly concerned about which bits I extract, I'm just trying to truncate a well-distributed hash value.
16:00:31 <romanandreg> mmmm: although, truth be told, I’m not expecting huge ammounts of input in the parsers
16:00:39 <Kaidelong> really it's a good enough reason that attoparsec comes with haskell platform and parsec doesn't
16:00:50 <RyanGlScott> > fromIntegral (43214421 :: Int32) :: Word8
16:00:51 <romanandreg> mmmm: the size of a commit change at most, which in normal situtations should not be big
16:00:52 <lambdabot>  85
16:00:52 <benzrf> > 255 :: Word8 + 1
16:00:53 <lambdabot>  <hint>:1:16: Illegal literal in type (use DataKinds to enable): 1
16:00:59 <benzrf> > (255 :: Word8 + 1
16:01:01 <lambdabot>  <hint>:1:17: Illegal literal in type (use DataKinds to enable): 1
16:01:02 <benzrf> > (255 :: Word8) + 1
16:01:04 <lambdabot>  0
16:01:05 <kazagistar> romanandreg: the problem I am having is that @@, in your string, does not seem relevat... what kind of structure or purpose are you parsing this for?
16:01:10 <benzrf> coool
16:01:22 <mzero> Kaidelong: `parsec comes with teh platform
16:01:30 <RyanGlScott> I'm not quite sure if that's truncating.
16:01:45 <romanandreg> kazagistar: I’m not intersted by the ‘@@‘ token by itself, I’m interesting in the elements in the same line after it
16:02:13 <romanandreg> kazagistar: I guess one solution is parse the ‘@@‘ info of the first entry apart from the sepBy usage
16:03:09 <kazagistar> (string "@@" *> restOfLineParser) <|> (otherLineParsers?)
16:04:01 <RyanGlScott> quchen: It looks like 85 is the first 8 bits of 43214421 (0b10100100110110011001010101)
16:04:03 <kazagistar> what I am asking is if there are lines that dont start with @@
16:04:22 <tikhon> Hey, I'm trying to install a cabal package (from a local .cabal file). As far as I can tell, I have all of the dependencies installed already at the correct versions. However, for some reason, cabal wants to reinstall all of them, upgrading *their* dependency on lens from 4.1 to 4.2. Why would it do that?
16:04:29 <RyanGlScott> quchen: The first 8 least-significant bits, I mean.
16:04:33 <quchen> RyanGlScott: Well, as long as it doesn't throw I'm fine I guess. The Report demands all arithmetic done mod 2^n, so I guess fromIntegral follows that.
16:04:42 <tikhon> ie I already have diagrams-1.2 installed
16:04:51 <quchen> So thanks RyanGlScott
16:05:16 <romanandreg> kazagistar: yes… the input would be something like the first code block of this post => http://chimera.labs.oreilly.com/books/1230000000561/ch11.html
16:05:19 <romanandreg> a git diff
16:05:26 <romanandreg> where there could be many chunks
16:05:30 <romanandreg> of changes
16:05:32 <tikhon> erm, more pertinently, I have diagrams-core-1.2.0.1 already
16:05:32 <romanandreg> in a same file
16:05:37 <tikhon> and it wants to reinstall it
16:05:40 <tikhon> "diagrams-core-1.2.0.1 (reinstall) changes: lens-4.1.2.1 -> 4.2"
16:06:10 <tikhon> Where could the change in lens versions be coming from? Lens isn't a dependency in the .cabal file I'm building.
16:07:26 <romanandreg> kazagistar: and I’m trying to create a Parser combinator for each of the “@@ “ entries you find in a diff patch
16:07:38 <rwbarton> lens is implicitly a dependency of all .cabal files. the new world order
16:07:44 <RyanGlScott> tikhon: It's probably a dependency that requires it. Try "cabal install --constraint=lens==4.1.2.1" to see if it conflicts
16:08:01 <romanandreg> (start line parent, length <*> start line child, length <*> body of changes)
16:08:03 <kazagistar> romanandreg: the important thing is what you are spitting out, not just what you are taking in
16:08:40 <tikhon> RyanGlScott: well, that seems to have made cabal happier, so now it's busy building lens
16:08:49 <tikhon> which will take a while :P
16:09:18 <romanandreg> kazagistar: Imagine I’m applying the previous line to (DiffPatchEntry <$>)
16:09:53 <RyanGlScott> tikhon: Yeah, sometimes cabal tries to get you to install the latest version when it isn't needed. (the transformers package comes to mind)
16:09:56 <romanandreg> kazagistar: the “body of changes” part, is the one that I got messed up, because in order to know it ended, I need to either be in the End of Input, or in the start of the next DiffPatchEntry
16:10:11 <romanandreg> and in order to know I’m on a new DiffPatchEntry, I need to parse the “@@"
16:10:12 <tikhon> it's also a bit confusing because 4.2 *isn't* the absolute latest
16:10:28 <romanandreg> that is the only solution I’ve found, there might be others of course
16:10:45 <tikhon> cabal is unholy magic as far as I'm concerned—you have to get the ritual just right, or else the fickle gods will abandon you
16:10:46 <shachaf> tikhon: I think cabal -v tells you the reasoning for particular versions.
16:10:55 <RyanGlScott> tikhon: A dependency might require lens==4.2.*, possibly
16:11:11 <RyanGlScott> tikhon: And it simply hasn't been updated yet
16:11:14 <tikhon> the thing I'm confused about is that all of the dependencies listed in the .cabal file are already installed
16:11:21 <tikhon> at the correct versions
16:11:44 <rwbarton> is it building the version of lens that you already have installed then?
16:11:59 <tikhon> hmm, looks like it is
16:12:15 <tikhon> that's also confusing
16:12:40 <kazagistar> romanandreg: so body of changes can contain any string except "\n@@", and diff starts with "\n@@", and backtracking on alternative should take care of the rest... I think its built into many'...?
16:14:54 * hackagebot xml-pipe 0.0.0.4 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.4 (YoshikuniJujo)
16:16:38 <romanandreg> kazagistar: me try with many’, brb
16:16:48 <romanandreg> kazagistar: let me try*
16:17:15 <tikhon> well, looks like it actually built
16:17:22 <kazagistar> romanandreg:  { many1 (string "\n@@" *> parse diff head <*> string "@@" <*> manyTil (string "\n@@") ) } or something like that is my first guess
16:17:29 <tikhon> thanks for the help; now to see if it really works...
16:20:27 <tikhon> Hey, looks like everything worked! Yay.
16:24:13 <solidus-river> i'm trying to profile a program and am getting this.. whats the way around this?
16:24:30 <solidus-river> Could not find module `Data.List.Split' Perhaps you haven't installed the profiling libraries for package `split-0.2.2'?
16:24:52 <solidus-river> is it common for profiling libraries to be written and distributed seperate from the libraries themselves
16:25:07 <solidus-river> do you have to supply your own profiling libraries for your modules?
16:26:12 <solidus-river> interesting, so profiling is seperate
16:26:27 <solidus-river> does this mean its on every lib maker to make a profiling library for their library?
16:26:52 <arancia> You have to re-install all libraries with -prof enabled, I think
16:27:13 <mzero> solidus-river: profiling is a way of building
16:27:36 <mzero> to profile your code, you need to have every package that it depends on, transitively, has to have been compiled for profiling
16:27:53 <solidus-river> interesting, and i'm guessing i dont want profiling versions by default because they are quite a bit slower
16:28:02 <mzero> this is why it is useful to have   enable-profiling: True    in   ~/.cabal/config
16:28:16 <mzero> and the platfrom on win and mac are distributed built that way so all libs have profiling
16:28:25 <mzero> honestly... I'm not sure why it should ever default to off!!
16:28:44 <mzero> when you enable profiling, you get both versions built
16:28:48 <mzero> profilng and normal
16:29:00 <mzero> and you only use the profiling ones if you build your executable that way
16:29:20 <mzero> so, both build versions of a lib can be installed at the same time
16:29:35 <solidus-river> interesting, yeah it seems wierd then to have it default off
16:29:44 <augur_> copumpkin: do you know how to go between ObjC and Haskell?
16:29:47 <solidus-river> unless the assumption is no one will ever have to profile their code :P
16:29:50 <copumpkin> no
16:31:25 <augur_> copumpkin: :(
16:31:41 <arancia> mzero: When you say there are two separate versions, why can't you add the profiling version afterwards then?
16:31:56 <mzero> well... in theory you could - it is just a recompile
16:32:31 <mzero> but to be honest, I have no idea how to get cabal to "just compile the profiling versions of those packages I have installed w/o profiling libs, then re-register the profiling libs into the package db"
16:32:49 <mzero> it is easier to just just ask cabal to rebuild the whole package again, this time with --enable-profiling turned on
16:36:56 <solidus-river> how do you tell ghc to use gcc to generate the final assembly and is this better or worse than doing -fvia-C
16:37:26 <StoneToad> -fvia-C is depricated for normal use
16:38:53 <solidus-river> oh, by default does it use gcc then?
16:39:07 <StoneToad> my understanding was that it just produced assembly directly
16:39:28 <merijn> solidus-river: GHC by default generates assembly itself
16:39:35 <merijn> solidus-river: Optionally you can use LLVM
16:39:46 <StoneToad> solidus-river: https://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html
16:40:16 <merijn> solidus-river: the via-c options that uses gcc is deprecated and doesn't work unless you build a special GHC. It's only around for porting to/bootstrapping new architectures and probably won't work
16:40:31 <solidus-river> ah
16:40:43 <solidus-river> so llvm is now defacto way to go if you want more performance at cost of compile time
16:40:55 <merijn> solidus-river: llvm isn't always better
16:41:03 <solidus-river> is there any downside to using llvm?
16:41:18 <tikhon> my understanding is that LLVM is better mostly for numeric code
16:41:26 <merijn> solidus-river: LLVM is likely to do well at optimising numerical code, but high-level abstract code I think it's sometimes worse than GHC itself
16:42:58 <solidus-river> interesitn,k so is real world haskells snipped about what -O2 actually does most likely still accurate
16:43:02 <solidus-river> thats the last bit i want to go read
16:43:11 <merijn> augur_: I would say the way to go between ObjC and haskell is through C?
16:43:24 <augur_> merijn: yes
16:43:52 <augur_> merijn: im going to try to create some C functions that handle the interface. i have no idea if itll work but
16:45:03 <solidus-river> augur_: would the existing methods for compiling from haskell to iOS be usefull?
16:45:14 <augur_> sodaplayer: its not the compiling thats the issue
16:45:16 <augur_> er
16:45:18 <augur_> solidus-river: ^
16:46:32 <solidus-river> btw, anyone cross compiled haskell to ios / android and have some feedback on how that performs / respects the expected behavior of applications on those devices?
16:46:35 <Cale> solidus-river: The iOS support in GHC generates ARM code directly rather than Objective C
16:46:45 <Welkin2> solidus-river: did you use sdl2 for your space invaders game?
16:47:07 <solidus-river> Welkin2: no but thats the end plan, as of now i'm using GLFW-b
16:47:30 <solidus-river> i'm getting it working there then switching ot SDL2 and a HTML5 based back end
16:47:38 <solidus-river> and then seeing how many things i can cross compile it to :P
16:48:16 <Welkin2> I've been having trouble figuring out how to use sdl2 properly with the haskell bindings
16:48:37 <Welkin2> since there is... no documentation
16:48:37 <solidus-river> Welkin2: the haskell bindings for sdl2 are only the low level ones
16:48:45 <Welkin2> well, I'm using hssdl2
16:48:47 <solidus-river> i think ekmett is working on the high level ones
16:48:48 <Welkin2> from github
16:48:56 <Welkin2> no, that is ocharles
16:49:22 <Welkin2> started by lemmih
16:49:31 <solidus-river> ah, i cant help with the hssdl2 ones, i've had my eyes on the low level bindings untill hssdl2 is considered done
16:49:35 <Welkin2> https://github.com/Lemmih/hsSDL2
16:49:41 <solidus-river> but that was a pain so i went with GLFW-b
16:49:46 <augur_> where does foreign import look for files?
16:50:04 <edwardk> solidus-river: i stopped. go for it ;)
16:50:37 <solidus-river> edwardk: heh, :P so the hsSDL2 bindings are stagnant now?
16:50:41 <Welkin2> is there a single loop that polls for input anf also renders changes made to the data structures?
16:50:49 <edwardk> i have no idea
16:50:52 <Welkin2> and*
16:51:00 <edwardk> i'm buried in other stuff, haven't looked in months
16:51:06 <carter> lets make a hard real time llvm code gen dsl for games
16:51:08 <Welkin2> I'm not too familiar with game programming
16:51:13 <carter> mwahaha
16:51:23 * carter wanders off and doesn't work on it, but thinks that sounds cool
16:51:29 <solidus-river> edwardk: well, i'll start helping as soon as i get space invaders working then :)
16:52:07 <solidus-river> i just read a post about using Cont for callback injection and assurances that registered callbacks are in place, i think that woudl be fun to play with but i'm not sure you would organize it in a way that plays well with optional callbacks
16:52:45 <solidus-river> forcing people to declair a dummy callback for optional hooks seems bad but the only way around it
16:55:12 <Welkin2> solidus-river: do you have your source code online?
16:56:29 <solidus-river> Welkin2: neg i dont but I'll upload it as soon as its back in a stable state, i'm in the middle of adding the first iteration of Wire logic to the game sim
16:56:55 <Welkin2> I'm just looking for basic examples of how to set up netwire 5 and sdl2 properly...
16:57:55 <solidus-river> Welkin2: its a long journey jle` has an awesome arrow tutorial to start from
16:59:08 <Welkin2> solidus-river: this? http://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines
16:59:52 <zq> what's the haskell equivalent to regex substitutions?
17:00:09 <johnw> um, a regex library?
17:00:56 <darthdeus> http://stackoverflow.com/questions/24986867/is-there-a-way-to-pull-out-the-foundation-type-from-network-wai-application-in-y
17:02:58 <solidus-river> Welkin2: https://github.com/fuag15/functioninvaders
17:03:06 <solidus-river> here, its not in the state i'd want it to be in for people to start looking at it
17:03:14 <solidus-river> but maybe it can help you some
17:03:19 <Welkin2> thanks
17:03:57 <solidus-river> np, its not commented really, i'll be around finishin gup the netwire part of it if you have questions
17:04:30 <ruuns> zq, http://www.haskell.org/haskellwiki/Regular_expressions :]
17:23:55 <benzrf> > Data.Type.Equality.testEquality (Just 1) (Just "foo")
17:23:56 <lambdabot>  Not in scope: ‘Data.Type.Equality.testEquality’
17:23:58 <benzrf> lame
17:24:07 <benzrf> :t Data.Type.Equality.testEquality (Just 1) (Just "foo")
17:24:09 <lambdabot>     Could not deduce (Data.Type.Equality.TestEquality Maybe)
17:24:09 <lambdabot>       arising from a use of ‘Data.Type.Equality.testEquality’
17:24:09 <lambdabot>     from the context (Num a)
17:24:12 <benzrf> ;-;
17:24:26 <benzrf> oh wait i see
17:27:25 <alphonse23_> does anyone know why javascript uses implicitly binding, why did ECMAscript specify that as a language feature?
17:27:39 <alphonse23_> does it have something to do with it's functional-ness
17:27:49 <alphonse23_> and is that a feature of haskell. No right
17:28:04 <alphonse23_> though I doubt haskell uses classes the same way java and ruby do right?
17:29:02 <ruuns> haskell has no classes :]
17:30:16 <benzrf> ruuns: lies
17:30:21 <benzrf> class is a keyword in haskell!
17:30:32 <alphonse23_> so do I have to explicitly bind the scope when running a function?
17:30:40 <ruuns> but type classes are more like interfaces :[
17:30:53 <alphonse23_> you can create classes in javascript to. Just create an object with a constructor
17:30:54 <benzrf> alphonse23_: huh?
17:31:05 <benzrf> explicitly bind the scope?
17:31:11 <benzrf> whatcha mean
17:31:22 <alphonse23_> yes, like apply and call in javascript
17:31:54 <alphonse23_> the first argument, specifies where you're calling from
17:32:09 <zomg> alphonse23_: technically you're not binding the scope, but the `this` reference
17:32:25 <alphonse23_> the this refers to the scope though right, or where you're making the call
17:32:30 <zomg> haskell doesn't have that, but you can emulate it using a reader for example
17:32:50 <benzrf> alphonse23_: no...
17:32:56 <zomg> `this` can refer to whatever pretty much, "scope" on the other hand has variable references which cannot be changed on the fly like `this` can
17:32:59 <benzrf> scope refers to the local information in general
17:33:05 <benzrf> which includes `this'
17:33:09 <benzrf> but also any variables
17:33:29 <alphonse23_> okay then, scope and this are different. I get it
17:33:42 <benzrf> > let closure = (let x = 10 in \v -> v + x) in closure 2
17:33:43 <lambdabot>  12
17:33:59 <benzrf> <->
17:34:20 <benzrf> var closure = function(){var x = 10; return function(v){return v + x}}; closure(2);
17:34:38 <benzrf> no wait
17:34:40 <benzrf> i did that wrong
17:34:44 <benzrf> var closure = function(){var x = 10; return function(v){return v + x}}(); closure(2);
17:34:47 <benzrf> there
17:35:09 <alphonse23_> okay, well like I was originally trying to ask, does anyone know why explicitly binding would be a language feature. I feel like it just confuses everything
17:35:10 <benzrf> i prefer the haskell myself ;)
17:35:18 <benzrf> alphonse23_: in general yes it does
17:35:27 <benzrf> alphonse23_: but haskell has no `this' anyway so it's moot
17:36:02 <systemfault> alphonse23_: ES5 strict mode doesn’t have the “if this is not bound then it’s equal to the global object” problem
17:36:49 <alphonse23_> so then it probably just runs null though right
17:36:56 <alphonse23_> the global object would be window?
17:37:49 <alphonse23_> hmm. I'm really just asking why was javascript and ES5 was designed the way it was.
17:37:50 <systemfault> The “this” is undefined in ES5 and you cannot use variables before declaring them before.
17:37:59 <systemfault> alphonse23_: It was designed in 10 days :P
17:38:11 <systemfault> Can’t do much in 10 days :/
17:38:17 <alphonse23_> really. are you serious?
17:38:47 <systemfault> Yeah, unfortunately.
17:38:54 <alphonse23_> how do you know that?
17:39:39 <ruuns> its true, lol
17:39:46 <Iceland_jack> It's the history of Javascript
17:39:46 <ruuns> never know that about javascript
17:39:47 <ruuns> :)
17:40:09 <tnks> alphonse23_: Brandon Eich has a lot of public talks where he accounts for the development of Javascript.
17:40:29 <tnks> and the stories seem to date undisputed.
17:40:33 <alphonse23_> and he actually admitted to designing javascript in 10 days...
17:41:06 <lf94> all hail the haskell
17:41:21 <hpc> my god, that's 11 days faster than it takes to learn javascript!
17:41:24 <Iceland_jack> haha
17:41:25 <lf94> the vessel to our saviour lambda
17:41:40 <kazagistar> to be fair, js has changed a lot since the original 10 day design, but... its madness remains
17:41:40 <alphonse23_> I read javascript was based on self (which was a language created in the 80s based on small talk) which introduced the concept of prototypes
17:41:41 <Iceland_jack> I was just about to point out the 'Learn Javascript in 21 Days' books
17:41:51 <tnks> alphonse23_: he attributes it to 1) extreme/insane market pressures from the browser wars (especially from Microsoft and 2) never knowing how important it would be.
17:42:12 <hpc> that's understandable
17:42:20 <kazagistar> prototype OOP is actually not as horrible as javascript makes it out to be
17:42:23 <hpc> the guy who made the <blink> tag didn't think anyone would ever use it
17:42:52 <hpc> javascript doesn't even do prototype OO poorly
17:43:04 <hpc> it's a bad language for totally orthoganal reasons
17:43:04 <tnks> this is all a very odd conversation for #haskell.
17:43:13 <hpc> *o
17:43:26 <hpc> tnks: for haskell talk go to -blah ;)
17:43:34 <systemfault> tnks: Well, we often discuss of Haskell on ##JavaScript :P
17:43:34 <kazagistar> I like prototypes in Lua, where they are an optional feature you can use easily when it is useful, and utterly ignore most of the time
17:44:05 <tnks> don't take me seriously; I don't really care.
17:44:13 <alphonse23_> I wouldn't say so. I could go talk about this in mozilla #jslang, where brandon in fact hangout from time to time, but there are only 60 people in there right now. #haskell has a lot of very general knowledgable language design people
17:46:17 <tnks> I'd imagine that if you had objects implemented as records, then lenses would give you all the "prototype OO" you'd need.
17:46:39 <tnks> provided you used fix to recursively tie in a self reference.
17:47:27 <benzrf> isnt it brendan
17:48:19 <tnks> benzrf: possibly, I didn't verify.
17:48:29 <systemfault> JS has changed little since its creation…. an attempt has been made to make it better but it failed (ES4)
17:48:48 <systemfault> ES6 is the second attempt at actually changing things in the language.
17:49:12 <tnks> I'm kind of happy about proper TCE.
17:49:16 <Welkin2> yes, it's brendan eich
17:51:07 <alphonse23_> yes brendan eich, my bad :)
17:52:24 <dsturnbull> ew
17:52:42 <Welkin2> an ewe is a female sheep
17:54:06 <systemfault> TIL...
17:54:25 * geekosaur was wondering for a moment what he had to do with anything...
17:55:10 <pingu> Anyone know if the ghc trac requires some kind of manual verification? I'm getting:
17:55:13 <pingu> TICKET_CREATE privileges are required to perform this operation. You don't have the required permissions.
17:59:14 <solidus-river> Welkin2: also a note about that code base, i'm not really using wires full on, i'm using a state wire for each part of the world, theres no reason invader wire couldn't be made from other wires and not statefull but i think at some point using wires obfuscates what your trying to do and doesnt add a benefit, i'm trying to keep my use of arrows to only the places where they are needed (probably just the GameState wire itself)
18:04:05 <benzrf> Welkin2: isnt it 'a ewe'
18:04:08 <benzrf> not 'an ewe'
18:04:21 <solidus-river> ewe knows
18:04:31 <hpc> only if you have managed to make that word start with a consonant sound
18:04:46 <hpc> but that takes even more linguistic gymnastics than "history"
18:05:06 <hpc> (seriously, unless you are saying it as "'istory" you are lying to yourselves)
18:06:13 <benzrf> ewe is pronounced like 'you'
18:06:48 <korczis> has anybody made accelerate working with 7.8? I am trying to figure out how to fix this - https://travis-ci.org/korczis/skull-haskell/jobs/31003044
18:07:36 <fread2282> how can I conditionally apply a pipe?
18:07:53 <Welkin2> benzrf: I suppose studying other languages messes with your native language
18:08:01 <Welkin2> I look at words differently sometimes
18:08:21 <dfeuer> hpc: ewe does start with a consonant, or what is usually perceived to be one in English.
18:08:36 <benzrf> fread2282: what do u mean
18:08:37 <fread2282> I have an (a -> Maybe b) and a Pipe a b m (), how can I apply the pipe when the function returns nothing?
18:08:41 <benzrf> oh
18:08:50 <benzrf> what d you mean 'apply the pipe'
18:09:01 <Welkin2> apply the pipe to the zombie's head?
18:09:07 <benzrf> oh i see what you're saying i guess
18:09:24 <benzrf> fread2282: i assume you want to get a new pipe out of it
18:09:27 <Welkin2> benzrf: single quotes!? blasphemy!
18:09:30 <Welkin2> you must be a brit!
18:09:36 <benzrf> im not a brit
18:09:40 <benzrf> im murican thank u v much
18:09:48 <fread2282> benzrf: yep, I don't know the right word. connect? fuse?
18:10:02 <benzrf> fread2282: why not write something like
18:10:09 * benzrf ponders
18:10:25 <benzrf> hmm thats actually a good question, i do not know pipes very well i guess
18:10:30 <fread2282> benzrf: the Pipe is user-specified
18:10:36 <benzrf> i got that
18:10:48 <dfeuer> Single quotes have certain acceptable uses in Haskell. They cannot, however, be used to enclose strings.
18:11:17 <Welkin2> I was referencing the use of single quotes for dialogue in british literature
18:11:31 <antho> I've run "$ cabal install ac-vector" so I can use AC-Vector. How do I use functions defined in AC-vector in my own source file?
18:11:46 <dfeuer> Is there an extension to overload character literals?
18:11:57 <benzrf> fread2282: basically you want to get a pipe that accepts a's
18:12:04 <benzrf> then applies the function to each input
18:12:13 <benzrf> if it's a Just, then send the result downstream
18:12:30 <benzrf> otherwise, feed the a to the pipe and run it until it awaits again?
18:12:36 <geekosaur> antho, import the module(s) containing the function(s) you want to use
18:12:53 <fread2282> benzrf: yep
18:13:00 <benzrf> let's see
18:14:26 <benzrf> wait
18:14:36 <benzrf> fread2282: should the pipe be run from the beginning each time
18:14:45 <antho> geekosaur, the module is called Data.Vector and I have "import Data.Vector" at the top of my source file, but the compiler is complaining it doesn't see functions that AC-Vector lists in Data.Vector
18:14:45 <benzrf> or maintain its state between calls
18:14:46 <geekosaur> antho, http://hackage.haskell.org/package/AC-Vector has a list of modules; click on one to get its api documentation
18:15:03 <geekosaur> no, actually it is not
18:15:18 <geekosaur> the modules are Data.Vector.V[1-4]
18:15:52 <antho> I don't understand how you see that from the page that comes up when yhou click a module
18:16:10 <geekosaur> "Vector" is italicized and not a link
18:16:20 <fread2282> benzrf: not sure, I'm translating from conduit. I think it should keep it's state
18:16:43 <geekosaur> under it is a list of modules, and another namespace entry ("Transform") which lists 4 submodules
18:16:49 <benzrf> fread2282: i'm not sure that you can do this without manually dealing with Proxy values
18:17:05 <benzrf> i think the pipes guy uses this channel but idr
18:17:14 <antho> I see now, thank you very much
18:17:34 * benzrf looks at the api docs a little closer
18:21:02 <benzrf> fread2282: oh you might be able to do something with reflecting it and then using the upstream interface or something
18:21:08 <benzrf> nah that seems dumb
18:22:29 <fread2282> benzrf: I think I can also get/use a Producer -> Producer if that  helps
18:23:12 <fread2282> wait, I have no clue about that
18:23:56 <benzrf> fread2282: the problem is that if you want to incorporate another pipe into this one such that its yields become your yields, you end up fully transferring control to it
18:24:22 <benzrf> and if you make a producer or filter or something and then compose it, you cannot yield from the whole thing from the beginning
18:24:41 <benzrf> hmmm
18:25:12 <benzrf> fread2282: if this is really necessary you can reach into the guts of the Pipe and use the internals
18:25:15 <fread2282> benzrf: yea, https://hackage.haskell.org/package/conduit-1.1.7/docs/Data-Conduit.html#g:17 is how I did it with conduit
18:25:16 <benzrf> i know how to implement it that way
18:25:33 <benzrf> fread2282: interesting
18:25:51 <benzrf> hmmm, Proxy implements monadplus
18:25:54 * benzrf looks closer
18:27:27 <benzrf> aha!
18:27:41 * benzrf tries something
18:29:49 <kazagistar> (Is there ever a difference between (MonadPlus a) and (Monad a, Alternative a)?)
18:30:43 <fread2282> benzrf: details of the conduit solution: http://stackoverflow.com/questions/24050141/how-can-i-conditionally-apply-a-conduit/24053267#24053267
18:32:05 <Cale> kazagistar: There could be
18:32:16 <geekosaur> kazagistar, in theory there could be, although I think it's avoided in general. MonadPlus is an older interface, whereas Alternative came in with Applicative and is quite young in Haskell ecosystem terms
18:33:28 <flebron> Hi. I have a text file which is going to be somewhat large (think 2GB). I'd like to periodically (say every 5 seconds) count the number of lines it has. What is an efficient way of doing this?
18:33:44 <flebron> (There's another process that is appending data to this file.)
18:33:53 <joelteon> wc -l
18:34:25 <geekosaur> cache the previous size and number of lines, start counting from that unless the current file is smaller in which case you throw out the cached information and start from the beginning
18:34:50 <flebron> geekosaur: How do I "start counting from that"?
18:35:35 <benzrf> fread2282: ergh
18:35:45 <geekosaur> what library are you using to read it? for the stuff in base, you want http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/System-IO.html#v:hSetPosn (and hGetPosn)
18:36:09 <fread2282> flebron: if you know it'll be only appends, then seek to the previous end
18:36:09 <geekosaur> or hSeek/hTell
18:36:10 <flebron> joelteon: To be honest I was going to go with that unless there was an efficient way to do it in Haskell, since I'm wary of String performance (although there must be Data.Text-based solutions)
18:36:31 <geekosaur> if you know it's going to be ascii, use bytestring
18:36:39 <flebron> Yeah, it's ASCII.
18:36:51 <fread2282> flebron: Text might be overkill if all you need to parse is newlines
18:36:56 <geekosaur> also if you don;t care about the content beyond number of lines, it would be safe to ignore the encoding and treat it as "ASCII"
18:37:08 <geekosaur> (or, what fread2282 just said)
18:37:17 <fread2282> geekosaur: unicode has a number of newline characters though
18:37:26 <joelteon> if it's ascii, \n
18:37:36 <geekosaur> yes, but most log files will not use anything but \n
18:37:46 <fread2282> or \r\n (or \r) (depends on platform)
18:38:03 <joelteon> well, you can still count \n
18:38:05 <joelteon> nobody uses \r
18:38:08 <geekosaur> does anything actually use \r any more? that was a pre-os x mac thing
18:38:30 <joelteon> no, nobody does
18:38:37 <joelteon> nothing
18:41:30 <benzrf> fread2282: oh wow im a idiot its in core
18:41:32 <benzrf> X_X
18:41:43 <benzrf> jeeeeeeeeeez
18:42:05 <geekosaur> so, read from saved position (initially 0) to end of file counting newlines and keeping track of how many characters since the last one seen; when you hit EOF it will probably not be on a newline so subtract the latter count and save as new offset, and report the number of newlines
18:42:19 <geekosaur> save the offset and the last nwline count, and hSeek to the offset and initialize the newline count with the saved value
18:42:57 <geekosaur> there is also the way tail does it, which is to read to eof, and on hitting it keep the handle open and sleep and then try the read again in N seconds
18:43:07 <geekosaur> but this risks missing something if the file gets rotated
18:43:34 <fread2282> geekosaur: you shouldn't need to subtract though, just resume reading in the middle of a line
18:43:37 <geekosaur> (tail needs help with this, in modern ones there is a special option that will check for the file changing out from under it and starts over in that case)
18:44:04 <geekosaur> fread2282, depends on whether you also need the line content for some reason (again think tail(1))
18:44:08 <benzrf> pipeFor f = do {v <- await; case f v of {Nothing -> return v; Just p -> yield p >> pipeFor f}
18:44:23 <fread2282> geekosaur: huh?
18:44:33 <geekosaur> sigh, never mind
18:44:38 <fread2282> oh right nvm
18:45:08 <benzrf> pipeFor :: (a -> Maybe b) -> Pipe a b m a
18:45:11 <benzrf> then you have
18:45:16 <arancia> geekosaur: What do you mean by rotated here?
18:45:27 <cr> is there anyone who could help me with something real quick?
18:45:42 <benzrf> capMaybe f p = pipeFor f >~ p
18:45:59 <benzrf> fread2282: :-)
18:46:09 <geekosaur> arancia, log rotation, that is a system cron job fires up occasionally and checks for logs that have grown past a certain size; if so, they move the current one to a new name and create a new one, then possibly signal a registered program for the logfile to switch to the new one
18:46:28 <geekosaur> `man logrotate` on linux
18:46:29 <fread2282> benzrf: won't that just drop values when it returns Nothing?
18:46:55 <benzrf> fread2282: no
18:47:02 <benzrf> look at what (>~) does
18:47:15 <benzrf> it replaces each await in the 2nd arg with the 1st arg
18:47:16 <arancia> Hhm, interesting
18:47:39 <benzrf> that is to say, when the 2nd arg awaits, it gets replaced with awaiting, then yielding and looping, or returning back to the 2nd arg
18:47:47 <benzrf> when (>~)'d with pipeFor f
18:48:31 <benzrf> pipeFor f will process inputs until it reaches one that f can't handle, at which point it finishes
18:48:40 <benzrf> when you stick that in the place of each await in another pipe
18:48:44 <benzrf> that does exactly what you asked
18:49:15 <fread2282> benzrf: :o
18:49:18 <benzrf> i keep forgetting about (>~) and (~>) because i didnt grok them quite as well as (>->)
18:49:38 <fread2282> pipes is wow powerful
18:50:02 <benzrf> :-)
18:50:04 <fread2282> benzrf: where's pipeFor?
18:50:10 <benzrf> 09:43 < benzrf> pipeFor f = do {v <- await; case f v of {Nothing -> return v; Just p -> yield p >> pipeFor f}
18:50:17 <benzrf> i dropped a bracket
18:50:27 <fread2282> oh cool
18:50:31 <benzrf> let me refactor that real quick
18:50:56 <benzrf> oh wait nvm
18:51:00 <benzrf> wouldnt be too easy to do
18:51:20 <benzrf> its already about as concise as itll get without being less readable i think
18:51:58 <benzrf> i havent really looked into conduit that much, but what i like about pipes is that it's v clean
18:52:10 <benzrf> it's a simple abstraction with useful combinators
18:52:32 <benzrf> i dont think thats specific enough bleh
18:53:04 <benzrf> anyway, if you read the actual code of Pipes.Internal and Pipes.Core
18:53:38 <benzrf> it has that nice quality where it is not actually very complex but still kind of hard to read until it clicks, because most of the complexity is in the ideas, not the codeburg
18:53:41 <benzrf> *cod
18:53:49 <benzrf> similar to things like the state monad
18:54:19 <fread2282> benzrf: that function's of type (Maybe i -> Maybe o) -> ConduitM i o m (Maybe i)
18:54:25 <benzrf> fread2282: huh?
18:54:39 <benzrf> fread2282: you have conduit loaded, not pipes
18:54:40 <fread2282> oh nvm
18:54:41 <benzrf> try again
18:54:42 <benzrf> lol
18:54:42 <fread2282> yea
18:57:44 <benzrf> fread2282: fun fact: Pipes.Core is perfectly symmetrical
18:58:29 <benzrf> fread2282: Pipes (the module) uses a subset of pipes (the lib) with the upstream outputs and downstream inputs papered over
18:59:00 <benzrf> fread2282: but in Pipes.Core, each combinator or builder has an exact opposite that does precisely the same thing but in the other direction
18:59:09 <johnw> benzrf: what leads you to say that pipes in clean, out of interest?
18:59:12 <johnw> s/in/is
18:59:28 <benzrf> johnw: by clean i mean:
18:59:49 <benzrf> 1. the abstraction is not terribly complex (like many of the ones in the Prelude)
19:00:02 <benzrf> 2. most of the implementations are exactly what you'd expect from looking at the types
19:00:25 <benzrf> it's the kind of library where, given explanations of the code next to it, you could digest the inner workings in about a day
19:00:30 <benzrf> or less
19:00:36 <johnw> are we talking about the same pipes library?
19:00:41 <benzrf> maybe not
19:00:51 <benzrf> i know that i read the code and it made total sense to me once i grasped the ideas
19:01:23 <johnw> was that the current pipes version, or something from back in the 1.x 2.x days?
19:01:26 <benzrf> current
19:01:29 <johnw> huh
19:01:38 <benzrf> like i said earlier, it's in the same vein as the State monad; the code is short, and if you understand the usage, simple and clear, but may be intimidating if you rush into it
19:02:11 <benzrf> the kind of thing where it's not too hard to mechanically satisfy the types without understanding the meaning unless you stare at it for a while
19:02:46 <fizbin> What's the extension for "I want to use the same type variables in the where clause as in the top-level expression and have them mean the same thing"?
19:03:12 <fread2282> fizbin: ScopedTypeVariables?
19:03:24 <benzrf> scopedtypevariables
19:03:25 <benzrf> shit
19:03:32 <geekosaur> and don't forget to explicitly forall the type variables you want to share that way
19:03:40 <geekosaur> it's not automatic
19:04:12 <fizbin> ScopedTypeVariables never seems to work the way I want it to.
19:04:18 <benzrf> johnw: its basically just purely functional coroutines
19:04:30 <fizbin> What I mean is this:
19:04:43 <flebron> Another question. What is an easy way of running a process and sending its output to some file, similar to "foo > bar" in the shell? (I'd like this to be streamed, not buffer all the output, I have another thread stat-ing the output file.)
19:04:43 <fizbin> Suppose I have a top-level expression that looks like:
19:04:54 <fizbin> crunch :: (DynGraph gr, Ord x) => (gr t () -> Node -> [Node]) ->
19:04:54 <fizbin>           (gr t () -> Node -> x) -> Node -> gr t () -> gr t ()
19:04:54 <fizbin> crunch nextF grpF n = decrunchier . crunchFrom n . crunchier
19:04:57 <johnw> benzrf: ?
19:05:05 <benzrf> johnw: pipes
19:05:05 <geekosaur> flebron: system "foo > bar"?
19:05:08 <fizbin> Now in the where clause, I want to say:
19:05:10 <johnw> benzrf: can you point me to a type in pipes that is using purely functional coroutines?
19:05:16 <fizbin>       where
19:05:16 <fizbin>         crunchier :: (gr t () -> gr (t, Bool) ())
19:05:16 <fizbin>         crunchier = G.nmap (\a -> (a, False))
19:05:20 <flebron> geekosaur: Hrmph. OK :p
19:05:21 <benzrf> johnw: i mean that's what the point of pipes is
19:05:27 <benzrf> johnw: the core data type in pipes is Proxy
19:05:29 <benzrf> 1 sec
19:05:39 <geekosaur> fizbin, note my comments earlier
19:05:44 <jcullen> fizbin: you need to use an explicit forall for scopedtypevariables to work
19:05:46 <flebron> geekosaur: Is there a way to do this with Haskell?
19:05:46 <benzrf> http://hackage.haskell.org/package/pipes-4.1.2/docs/src/Pipes-Internal.html#Proxy
19:05:51 <geekosaur> you must EXPLICITLY use `forall` to identify the variables to be scoped
19:06:00 <benzrf> johnw: maybe more like generators than coroutines
19:06:03 <fizbin> WTF would you need to do that?
19:06:15 <fizbin> Seriously, why criple the extension like that?
19:06:15 <johnw> benzrf: so, that type is very, very close to Conduit's core Pipe type
19:06:18 <benzrf> johnw: is it?
19:06:21 <johnw> yeah
19:06:22 <benzrf> i wouldnt know
19:06:26 <benzrf> dont use conduit :p
19:06:30 <johnw> they are _almost_ isomorphic, except for leftovers and one other thing
19:07:00 <fizbin> And as I've never used forall types, I', not sure of the syntax there.
19:07:02 <jcullen> fizbin: how is it crippling the extension? it isn't hard to do and it also leaves you the option to not use the feature while the extension is enabled
19:07:06 <DeadChannel> hey
19:07:10 <benzrf> johnw: cant you just handle leftovers with vertical compo
19:07:10 <DeadChannel> I just dropped in again
19:07:11 <benzrf> like
19:07:12 <geekosaur> flebron, use http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:createProcess, open your output file beforehand and pass its handle in a useHandle spec for std_out
19:07:12 <flebron> Ah, runProcess can be passed some filehandles to use as stdout and so forth :)
19:07:13 <johnw> I only ask because lots of people rave about pipes' cleanliness, when in fact conduit is pretty close to being just as clean in that respect
19:07:15 <DeadChannel> To say that all of you people
19:07:18 <DeadChannel> are awesome
19:07:23 <johnw> benzrf: if you _really_ want clean type, see simple-conduit :)
19:07:27 <benzrf> source >-> (consumer1 >> consumer2)
19:07:27 <DeadChannel> pat yourselves on the back.
19:07:29 <geekosaur> close the handle in your process after doing the createProcess so the child has exclusive use
19:07:30 <DeadChannel> you're awesome
19:07:42 <flebron> Or yeah, createProcess seems better, since runProcess is deprecated :p
19:07:49 <johnw> source $= (consumer1 >> consumer2) :)
19:08:04 <benzrf> johnw: is ($=) <-> (>->)
19:08:08 <johnw> the degree of similarity is higher than I think most people realize
19:08:10 <johnw> yeah
19:08:37 <fizbin> Does "forall" go before or after class restrictions in my type signature?
19:08:44 <flebron> geekosaur: Wait, from what I see, createProcess _returns_ a handle to stdout, doesn't take one as a parameter.
19:09:15 <geekosaur> flebron, only with type CreatePipe
19:09:26 <fread2282> johnw: doesn't look like conduit does bidirectional
19:09:34 <benzrf> johnw: so what's with conduit's special leftover handling
19:09:36 <geekosaur> if you use UseHandle instead, it passes the file descriptor from that handle to the child and you get nothing back
19:09:38 <johnw> no, it does not
19:09:44 <flebron> Ah OK, I'll read more carefully then, thanks :)
19:09:49 <johnw> there are a few differences, I'm not saying they're the *same*
19:09:52 <geekosaur> yes, it's a fairly complex interface
19:09:56 <johnw> they're just not as different as most users will ever experience
19:10:02 <geekosaur> sadly there is no simple way to do this kind of thing
19:11:05 <benzrf> johnw: how do leftovers work in conduit, then
19:11:16 <geekosaur> so if you used CreatePorcess then the eturned stdout is Just a Handle, otherwise it's Nothing
19:11:23 <johnw> benzrf: with another constructor to the Pipe type
19:11:27 <benzrf> johnw: i read something about Pipes' issue being that any pipeline component can terminate the whole pipeline
19:11:38 <augur_> anyone happen to know how to use clang to generate files i can use as library code?
19:11:49 <benzrf> johnw: ah, so if the downstream component in the example above terminates, the pipeline as a whole will start sending leftovers downstream?
19:11:52 <benzrf> or something?
19:12:02 <augur_> if i just compile my bridging code it tries to generate an executable
19:12:17 <geekosaur> augur_, -c?
19:12:29 <johnw> benzrf: the consumer is allowed to push data into the stream that the next consumer sees
19:12:31 <augur_> geekosaur: ahh maybe thats it
19:12:53 <geekosaur> and then use ar to create a static library or ld with magic options (probably clang with similar magic options) to make a shared object
19:13:10 <augur_> geekosaur: i dont know what that means :(
19:13:38 <benzrf> johnw: what do you mean exactly
19:13:46 <systemfault> hehe https://twitter.com/octonion/status/493550052657209344/photo/1 Math… Not even once.
19:13:58 <benzrf> johnw: do you mean that there is no such thing as a final component in a conduit pipeline?
19:14:07 <johnw> benzrf: sorry, on a call now; there are so many blog posts on this point, if you are really interested; otherwise, have fun with pipes :)
19:14:10 <geekosaur> you might be happier not knowing :p
19:14:15 <augur_> geekosaur: really all i need is the one file
19:14:34 <benzrf> johnw: i only want to hear about it so that i can condescendingly explain to you how pipes' handling of it is simpler and equally usable
19:14:37 <benzrf> ;)
19:14:38 <geekosaur> then -c so it gives you a .o you can use later
19:14:44 <augur_> ok
19:14:55 <johnw> benzrf: haha, refreshing honesty :)
19:14:58 <geekosaur> shared object creation tends to be arcane on any platform, sadly
19:15:37 <augur_> geekosaur: i just need one file to define some Haskell-ObjC bridging functions
19:19:22 <spopejoy> yo. is it just me or is haskell-mode have wack <tab> functionality
19:19:33 <spopejoy> and indenting in general
19:19:44 <spopejoy> which is normally emacs’ big win
19:25:08 <spopejoy> or maybe it’s columnar to line up your pattern matches all pretty like
19:33:36 <trillioneyes> spopejoy: haskell-mode doesn't have its own tab functionality; there are like three auxiliary packages that you can choose between. You might try switching those
19:33:57 <trillioneyes> If you don't like any of them, you might look into structural-haskell-mode, which is a bit like paredit
19:35:02 <augur_> geekosaur: what file path does foreign import look through to find the requested file?
19:37:11 <augur_> geekosaur: i just get the error
19:37:14 <augur_> Linking ObjCTest ...
19:37:15 <augur_> Undefined symbols for architecture x86_64:
19:37:15 <augur_>   "_hoc_NSLog", referenced from:
19:37:16 <augur_>       _r2vU_info in ObjCTest.o
19:37:18 <augur_> ld: symbol(s) not found for architecture x86_64
19:37:20 <augur_> clang: error: linker command failed with exit code 1 (use -v to see invocation)
19:37:55 <geekosaur> you're missing something else then. NSLog makes me think you need the objc runtime
19:38:41 <augur_> geekosaur: it originally was a .m file but i changed it to a .c and removed all that junk just to see what the problem was
19:38:52 <augur_> so now the function is pure C and compiles fine
19:38:58 <geekosaur> yes
19:39:12 <geekosaur> for objc, the stuff you need to add to the link: -lobjc -foundation Framework
19:39:21 <augur_> geekosaur, no, there is no objc
19:39:22 <geekosaur> er, backwards on those last
19:39:31 <geekosaur> if you are using NSLog then there is
19:39:38 <augur_> ffs
19:39:46 <augur_> #include "HOCBridge.h"
19:39:46 <augur_> int hoc_NSLog() {
19:39:46 <augur_>   return 5;
19:39:47 <geekosaur> you are claling into objc
19:39:48 <augur_> }
19:40:03 <augur_> thats the code
19:40:04 <geekosaur> ok so show your link command
19:40:19 <augur_> all im doing is
19:40:19 <geekosaur> I will try to read your mind better next time
19:40:21 <augur_> ghc ObjCTest.hs -o ObjCTest
19:40:32 <geekosaur> you also need the .o file
19:40:39 <augur_> theres no need to read my mind when my words said there's no objc
19:40:46 <augur_> you just need to read my words and trust that im not a fool :|
19:40:47 <geekosaur> haskell code, ghc can pick up the dependency automatically. C code, not so much
19:41:02 <augur_> what do you mean i also need the .o file?
19:41:14 <geekosaur> you remember asking me about clang -c a bit ago?
19:41:18 <geekosaur> that creates a .o file
19:41:22 <augur_> yes, it did
19:41:31 <geekosaur> if you want to use the function from there, you need to reference the .o file
19:41:47 <geekosaur> ghc ObjCTest.hs whateveritis.o -o ObjCTest
19:41:55 <augur_> i see. ok
19:42:17 <geekosaur> since it can't look in the ghc-pkg registry to find out where your function is
19:42:20 <augur_> that seems to do it!
19:42:23 <augur_> thank you! <3
19:42:31 <augur_> (can you tell i never compile my code? :x)
19:42:45 <augur_> \o/
19:42:52 <augur_> ok. lets try this again with objc
19:43:09 <geekosaur> there you will probably need -lobjc -framework Foundation
19:43:22 <geekosaur> you will certainly need -lobjc
19:43:29 <augur_> hopefully compiling as a .m will be sufficient
19:43:56 <geekosaur> the other only if you are using other standard objc stuff
19:45:08 <augur_> geekosaur: well, it complained some more, so lets try -lobjc
19:45:31 <geekosaur> any objc code is going to use the runtime. just as any haskell code is going to use the haskell runtime
19:45:44 <geekosaur> (even C has a runtime but crt0.o is automatically linked in)
19:46:03 <augur_> oh, also, is this -lobjc an option on clang or ghc
19:46:07 <augur_> probably clang, no?
19:46:11 <geekosaur> both
19:46:13 <augur_> ok
19:46:23 <geekosaur> and despite the name it goes at the *end*, not the start
19:46:43 <augur_> ?
19:47:01 <geekosaur> it's not actually an "option", it's a macro of sorts
19:47:11 <augur_> hm
19:47:19 <augur_> im still getting symbol errors. lets try with Foundation
19:47:27 <geekosaur> it has to go at the point where the linker needs to search for it, which is tyoically after the thing that uses a symbol from it
19:47:58 <augur_> no symbol errors!
19:48:12 <augur_> clang said the lobjc and framework things were redundant tho
19:48:46 <augur_> hah!
19:48:53 <augur_> hahaaa!
19:48:58 <geekosaur> clang would, normally you would include them on the ghc command. but I suspect ghc doesn't know -framework (it does know -l) so you may need some magic there
19:48:59 * augur_ hugs geekosaur
19:49:08 <augur_> the IO order is wrong, but it worked!
19:49:11 <augur_> 2014-07-27 22:47:26.048 ObjCTest[41722:507] world
19:49:12 <augur_> hello
19:49:31 <geekosaur> it would be, they are using different I/O buffers
19:49:42 <augur_> thats ok, i dont need it for IO :)
19:49:44 <geekosaur> and the order it comes out is the order in which their global destruction happens
19:49:49 <augur_> geekosaur: you've saved me from despair!
19:51:06 <geekosaur> aha, ghc does understand -framework on os x
19:51:21 <pepper_chico> guys, how should I use cabal sandboxes? I have installed a recent ghc, with alex and happy installed to userdb (~/.cabal). Everything else I've been installing through sandboxes, but it was all binaries which I symliked to ~/.cabal/bin. Now I want to play with Yesod, but Yesod is more than a simple binary, I have to use it as a library and also the binaries, so, can anyone recommend a link or provide advice on how should I have a
19:51:21 <pepper_chico>  heathy haskell system, with some kind of sandboxes where I can enter a mode for develop for Yesod but not mess with the entire haskell installation?
19:51:22 <geekosaur> nice of it
19:52:31 <swgillespie> pepper_chico: I ran into this issue recently and I used a small bash script + a cabal sandbox to accomplish this
19:52:44 <augur_> geekosaur: thank you again, geekosaur
19:52:52 <swgillespie> the bash script sets the path to your local cabal sandbox
19:52:58 <bitemyapp> pepper_chico: I just link stuff in sandboxes into ~/.cabal/bin or elsewhere.
19:53:15 <swgillespie> so whenever you want to enter your sandbox you can "source myenv.sh" and be good to go
19:53:23 <swgillespie> sort of how python virtualenv does it
19:53:42 <pepper_chico> swgillespie, a cool, but that solves for building a sample haskell file that imports Yesod?
19:54:48 <swgillespie> yeah, if you sandbox has yesod installed, sure
19:55:26 <pepper_chico> swgillespie I thought having the binaries on path solely won't solve for building apps, will try thanks
19:56:26 <pepper_chico> bitemyapp, when it's just some binaries, I do that, but Yesod-platform etc provides too much, I guess swgillespie approach is nicer in that case
20:00:54 <augur_> geekosaur: when i said you saved me from despair, i mean it. i was on the verge of crying earlier because of how difficult it looked like this was going to be
20:03:12 <splintax> isn't it weird how haskell seems to protect you from all kinds of common bugs when you're writing your own code, but when it comes to managing dependencies, you have the same problem as every other language except worse
20:03:42 <splintax> i was working on my first major haskell project last week and it was a really enjoyable and liberating experience
20:04:08 <splintax> except for the parts where i was interacting with poorly documented hackage libraries
20:04:39 <splintax> and struggling to work out whether i was actually using the type that i was reading the documentation for, or something else with the same name
20:09:15 <ruuns> that's probable haskell eco/library system is itself experimental and community driven. Maybe it will change if someday Haskell Prime is coming.
20:09:18 <geekosaur> splintax, sometimes that comes with the territory; removing complexity at one level adds it somewhere else
20:09:36 <geekosaur> in this case it's more that ghc does some things in the name of performance that make dependencies rather nasty
20:10:02 <geekosaur> you can cause exactly the same problems in C, though: "export" your library functionaity as macros
20:10:15 <pepper_chico> swgillespie, I have put Yesod sandboxed binaries under path, but building just gives the same result, Yesod package not found, how should I build and run this simple hello-world? http://lpaste.net/8511123690170089472
20:10:16 <benzrf> bbl
20:10:27 <benzrf> bye
20:10:35 <swgillespie> i don't know, sorry :(
20:10:35 <geekosaur> now, any tiny change to your implementation is going to cause binary visible changes to consumers of your library and things will fall apart quicklu
20:10:40 <geekosaur> (kde used to do this)
20:10:40 <swgillespie> i am a haskell padawan
20:10:48 <splintax> yeah, i'm not really saying that any other language gets this "right", and the problem of poor documnetation is not really haskell's fault at all
20:11:01 <pepper_chico> bitemyapp? any help?
20:11:51 <bitemyapp> buhhh
20:12:25 <bitemyapp> pepper_chico: I dunno what you're doing. Did you install Yesod in the sandbox?
20:12:43 <splintax> although cabal-install seems to have some fairly glaring flaws that seem like they could be fixed without too much effort
20:12:45 <splintax> eg. no uninstall
20:12:57 <pepper_chico> bitemyapp, yes by: cabal install yesod-platform yesod-bin --max-backjumps=-1 --reorder-goals
20:12:58 <splintax> and (apparently) no ability to incrementally update the package list
20:13:16 <pepper_chico> bitemyapp, in a sandbox
20:14:10 <bitemyapp> pepper_chico: nuke it, then try that command again.
20:15:21 <pepper_chico> it's installed in the sandbox, I just dunno how to use it to build that hello-world.hs, I know there's these binaries in the sandbox, yesod for scaffold, they're executable
20:15:32 <pepper_chico> and the sandbox bin path is on PATH
20:16:08 <pepper_chico> but building a haskell file that uses Yesod doesn't work
20:18:15 <pepper_chico> I'm assuming ghc is ignoring the sandbox for dependencies when building a simple .hs and I dunno how to make ghc to assume the sandbox for getting dependencies in the build process
20:21:06 <pepper_chico> bitemyapp did that make it more clear?
20:21:18 <bitemyapp> don't target me. I'm about to go to bed.
20:33:38 <orion> http://www.haskell.org/platform/ <-- it says the next release is 2013.4.0.0, when it should be 2014.2.0.0.
20:57:57 <carter> orion: tell mzero
20:57:58 <carter> :)
21:02:05 <orion> https://github.com/quchen/articles/blob/master/applicative_monad.md <-- where is the implemention of pure here?
21:03:39 <kazagistar> orion: I dont understand that question, but maybe I missed context?
21:04:56 <orion> kazagistar: I just realized that the question makes no sense.
21:05:07 <jackstarrbass> lol
21:05:41 <trap_exit> hmjm, I'm on ubuntu 14; I have installed ghc0-7.8.3 binary; I'm trying to install cabal-install  via bootstrap.sh . I google for my error, I get this http://lpaste.net/103278 (which is not me, but has exact same error as me). How do I fix this?
21:07:16 <trap_exit> question rewritten: how do I install cabal-install via bootstrap.sh ?
21:07:41 <trap_exit> I get this error: https://gist.github.com/anonymous/ea142d14a5ad91cd098a
21:10:41 <luite> trap_exit: just use your existing cabal-install to install both the new Cabal lib and cabal-install
21:10:58 <trap_exit> luite: that breaks ghcjs
21:11:13 <trap_exit> the only way I know how to install ghcjs is to bootstrap.sh the new cabal
21:11:46 <luite> i'm pretty sure bootstrap.sh isn't necessary since i haven't used it in ages :)
21:12:09 <jackstarrbass> i dont use it either
21:12:20 <trap_exit> I bet neither of you are on ubuntu 14
21:12:52 <jackstarrbass> i was..then switched to kali ;)
21:12:54 <luite> trap_exit: what's your current cabal-install version?
21:13:23 <trap_exit> let me apt-get it first
21:15:05 <luite> trap_exit: this approach should work, if those versions are available on your ubuntu: https://github.com/ghcjs/ghcjs/blob/master/.travis.yml
21:15:54 <trap_exit> luite: I think I figure it out
21:16:05 <trap_exit> I'm going to try something else first, and if it fails, look into your suggestion
21:16:13 <orion> Would it be possible/safe to build a Haskell runtime in to Firefox which downloads compiled code from the server and executes a "main" function whose return value is DOM () instead of IO ()?
21:16:27 <orion> That way the user could only effect the DOM, not the rest of the machine.
21:18:08 <trap_exit> orion: I think it's called ghcjs
21:18:14 <luite> orion: removing IO everywhere would make the whole language very different, much of the libraries wouldn't be usable
21:18:28 <trap_exit> ah, I figured it out
21:18:41 <trap_exit> I need to (1) install Cabal manually first, then (2) install cabal-install manually
21:18:55 <trap_exit> so it's "cd Cabal; make; sudo make install; cd cabal-install; ./bootstrap.sh"
21:19:06 <trap_exit> well, after that, it's 'echo "trap_exit is a fucking genius"'
21:19:35 <luite> trap_exit: installing cabal-install 1.18 through apt-get must be the easier way :)
21:20:19 <orion> luite: good point
21:22:35 <luite> orion: safe haskell and exposing only some subset of safe IO things could work
21:24:11 <lostman> I'm running some computations that return Eithers and then I'm feeding these to computations that return Maybes; what's an idomatic way to compose it into something that fails if any of them fails?
21:25:19 <bb010g> Anybody here use Awesome on NixOS?
21:25:48 <l0cust> bb010g: I'm guessing no
21:27:48 <bb010g> I tried xmonad but I couldn't get a config to work.
21:28:23 <jle`> lostman: compose in what way?
21:28:35 <Welkin2> a sonata?
21:28:37 <jle`> lostman: if they all run in parallel, you can use sequence
21:28:42 <jle`> Welkin2: :P
21:29:02 <Welkin2> an orchestra is actually a parallel computation device
21:29:04 <jle`> lostman: you'll need to write a natural transformation/lifter of Maybe a -> Either e a
21:29:10 <jle`> if you want to bring them together
21:29:14 <jle`> or backwards
21:29:18 <jle`> as long as they are all the same type
21:29:28 <trap_exit> luite: (1) I shoul dget credit for the extra heading saying "installation instructions" after the "windows" (2) https://github.com/ghcjs/ghcjs should mention to run "cabal update", (3) I'm kidding about (1) :-)
21:30:49 <pepper_chico> I think what I was looking for relates to this https://mappend.net/posts/ghc-and-cabal-sandbox-playing-ni
21:31:30 <pepper_chico> have to mess not only with PATH for binaries, but also GHC_PACKAGE_PATH
21:33:07 <pepper_chico> ah, there's a cabal exec today...
21:35:40 <pepper_chico> Yes, it worked cabal exec ghc -- hello-world.hs -o hello-world
21:35:45 <pepper_chico> =D
21:36:04 <pepper_chico> this should be mentioned in the cabal post around the web
21:36:09 <pepper_chico> I missed that one
21:36:24 <pepper_chico> s/post/blog posts/
21:43:11 <trap_exit> is there a list of proposals / new features for haskell ?
21:43:17 <trap_exit> i'm curious to study "what can possibly make haskell more fun"
21:44:11 <platz> https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.10.1
21:44:12 <nexx> I guess you could look at language extensions
21:44:30 <sjouke> i don't see it in Data.List, but is there something like a difference function for two lists?
21:45:55 <jle`> sjouke: what do you mean by difference?
21:46:02 <jle`> sjouke: set difference?
21:46:09 <sjouke> jle`: i believe so
21:46:16 <jle`> (can you give us an example of inputs and outputs?)
21:46:33 <sjouke> "foob" - "bar" => "foo"
21:47:00 <jle`> > "foob" // "bar"
21:47:01 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array i e’
21:47:02 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match type ‘GHC.Type...
21:47:02 <lambdabot>  Expected type: [(i, e)]
21:47:02 <lambdabot>    Actual type: [GHC.Types.Char]
21:47:10 <sjouke> Data.List.diff "foob" "bar"
21:47:12 <jle`> huh.
21:47:16 <sjouke> => "foo"
21:47:36 <jle`> > "foob" \\ "bar"
21:47:37 <lambdabot>  "foo"
21:48:05 <sjouke> thank you jle`
21:48:05 <jle`> > "foobaro" \\ "bar"
21:48:07 <lambdabot>  "fooo"
21:48:19 <jle`> i think it only deletes one item per incident in the second list
21:48:23 <jle`> > "foo" \\ "o"
21:48:25 <lambdabot>  can't find file: L.hs
21:48:27 <jle`> > "foo" \\ "o"
21:48:28 <lambdabot>  "fo"
21:48:37 <jle`> np
21:48:56 <bb010g> > "fo|o" \\ "o"
21:48:57 <lambdabot>  "f|o"
21:49:36 <splintax> what's up with those lambdabot error messages
21:49:59 <bb010g> :t //
21:50:01 <lambdabot> parse error on input ‘//’
21:50:02 <Welkin2> for a set, why do the elements need to be of typeclass Ord?
21:50:14 <Welkin2> I don't care about the order --they don't even have one
21:50:21 <bb010g> :t (//)
21:50:22 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
21:50:38 <Hafydd> The ordering is used to look them up efficiently.
21:50:46 <bb010g> Welkin2: Implementation details, so the lookup is efficient. You could do it with just Eq, but it would be slower.
21:50:47 <jle`> Welkin2: it's an implementation detail
21:50:56 <jle`> third answer, that's good enough for me
21:50:59 <Welkin2> well, it broke my code
21:51:24 <jle`> broke?
21:51:29 <Welkin2> I have to use standaloneDeriving
21:51:31 <splintax> docs for Data.Set suggest that there is an implementation that only requires Eq
21:51:47 <jle`> if your things aren't Ord, they wouldn't have been storable in a Data.Set set anyway
21:51:49 <Welkin2> then it says there is another problem with another datatype that is not of Ord
21:52:01 <jle`> because of the implementation of insert
21:52:15 <jle`> there is an unordered-containers that i think requires a Hashable constraint or something
21:52:22 <shachaf> Which docs?
21:52:32 <splintax> i was looking at http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.5.1/Data-Set.html
21:52:34 <shachaf> Certainly there's an obvious possibly implementation, but no standard one.
21:53:04 <splintax> i'm probably wrong though, i still am very confused about how to tell if random documentation i find on google is actually relevant to the code i'm executing
21:53:05 <shachaf> I don't see such a suggestion on that page.
21:53:10 <trap_exit> whoa
21:53:13 <trap_exit> what do we need Using an SMT Solver in the type-checker -  for ?
21:53:19 <trap_exit> is Haskell type checking undecidable ?
21:53:21 <splintax> shachaf: Eq a => Eq (Set a)
21:53:23 <jle`> http://hackage.haskell.org/package/unordered-containers-0.2.5.0/docs/Data-HashSet.html , requires hashable
21:53:26 <splintax> isn't that what that menas?
21:53:27 <trap_exit> I thoguht things are mostly decidable until you hit dependent types
21:53:42 <jle`> trap_exit: why does SMT solver = undecidable problem?
21:53:43 <shachaf> Oh, wait, you're talking about Set equality, not Set operations in general?
21:53:53 <jle`> if our problem was undecidable, an SMT solver wouldn't help :P
21:54:06 <trap_exit> jle`: hmm, it does not
21:54:06 <shachaf> Sure, you can just compare the toAscList or something.
21:54:12 <Welkin2> does anyone know what the difference is between Keycode and Scancode in SDL?
21:54:25 <jle`> trap_exit: we use it to type check
21:54:30 <jle`> er
21:54:32 <jle`> type infer
21:54:49 <jle`> i think there is talk about using an SMT to do cabal package dependencies too
21:55:27 <jle`> not that it's necessary...i think it's just more efficient to use a tool designed to do the job effectively and well and has been well-tested
21:55:41 <sjouke> let diff l1, l2 = l1 \\ l2
22:29:12 <mzero> yikes - installing pandoc requires 71 additional packages!
22:29:48 <benzrf> johnw: just fyi the main reason that people think that pipes is clean is probably that the core functionality (enough that about 70% of the rest of the library is trivial improvising) fits in 80 or so lines: http://lpaste.net/106669
22:30:03 <benzrf> ^slightly edited so that it can be loaded into lambdabot
22:30:36 <johnw> yeah, simple-conduit's core is much tinier still :)
22:30:41 <benzrf> pfft sure
22:30:44 <johnw> if that's your metric
22:31:01 <johnw> conduit is indeed bigger due to leftovers
22:31:05 <joelteon> getLine and putStrLn are both very small
22:31:10 <benzrf> leftovers schmeftovers
22:31:28 <johnw> when you're doing HTTP stuff, leftovers are just convenient as hell sometimes
22:31:56 <benzrf> howre they used then
22:32:05 <benzrf> ugh i need to sleep i dont have time for this
22:32:06 <johnw> the consumer calls "leftover x"
22:32:11 <benzrf> theres a reason i left earlier ;-;
22:32:22 <benzrf> johnw: and that does what?
22:32:27 <johnw> that's it
22:32:32 <benzrf> what does it do, tho
22:32:32 <johnw> now the next "await" will get x
22:32:38 <benzrf> ?
22:32:59 <benzrf> ah, you can defer something to the next await?
22:33:05 <benzrf> i.e.
22:33:06 <benzrf> something like
22:33:20 <johnw> it's like have a pipe over State
22:33:23 <johnw> like having
22:33:48 <benzrf> someConsumer = forever $ do {v <- await; doSomethingWith (take 30 v); leftover (drop 30 v)}
22:33:59 <johnw> yeah, you could certainly do that
22:34:01 <benzrf> why not use a pipe over state then?
22:34:07 <johnw> it complicates the interface
22:34:09 <benzrf> seems like thats a perfectly fine solution
22:34:28 <benzrf> johnw: and its better to bake state into the core type
22:34:29 <johnw> because now that state has to be everywhere, end to end, not just where you need it
22:34:41 <benzrf> johnw: funny, i wouldve said the same about baking it into the core type
22:34:42 <benzrf> ( ͡° ͜ʖ ͡°)
22:34:43 <johnw> benzrf: we're rehashing a constant debate that others have held on numerous occasions, now
22:34:47 <benzrf> blah
22:34:53 <benzrf> ok anyway i need to sleep so bye
22:34:58 <johnw> :)  night!
22:35:01 <benzrf> night
22:35:07 <benzrf> ill yell at you about why youre wrong at a later date
22:35:14 <johnw> don't yell at me
22:35:22 <johnw> just say "why leftovers" on reddit or something, and sit back
22:35:51 <johnw> debating it with me is a waste of your energy
22:37:50 <jle`> forming my opinion about how that conversation went now
22:38:30 <johnw> i see the merits of both approaches, and in some cases would pick one way, in others pick the other; but since I don't care much about leftovers, it's not like I'll put up much fight either way
22:42:22 <augur_> is it possible to have C call Haskell in such a way that the Haskell side maintains state?
22:43:39 <mzero> hmmm.... you mean between multiple calls from C?
22:43:44 <augur_> mzero: yeah
22:43:58 <johnw> sure
22:44:02 <mzero> well... not without invoking things named "unsafe..."
22:44:03 <augur_> do tell!
22:44:04 <johnw> store your state in a "global" IORef
22:44:08 <johnw> or, have C pass a pointer to a memory block
22:44:11 <johnw> and stuff your Storable state into it
22:44:22 <johnw> yeah
22:44:24 <mzero> ah - but that is C maintaining the state!
22:44:25 <johnw> the same way you maintain state in C
22:44:30 <johnw> you can do in C -> Haskell -> C
22:44:33 <johnw> use a pointer to a memory block that all the calls share in common
22:44:37 <johnw> the typical C style is:
22:44:39 <johnw> void *p = get_some_handle();
22:44:46 <johnw> um, maybe I don't understand the question then?
22:44:51 <johnw> state in all cases is just a set of values, it's up to the caller to hand them around
22:44:56 <augur_> i want to have C call some haskell code
22:45:02 <johnw> right
22:45:07 <johnw> the C code can pass in a Ptr ()
22:45:09 <augur_> and i need to send in some config info initially
22:45:20 <johnw> Haskell could deserialize the state from that Ptr ()
22:45:29 <johnw> is that what you mean?
22:45:32 <mzero> or      initMyHaskellStuff :: IO IORef
22:45:40 <augur_> i want the haskell to interpret the config, and keep the interpretation internally
22:45:48 <mzero> then       doFunc :: IORef -> IO Whatever
22:45:52 <johnw> and not hand back a pointer to the interpretation back to C?
22:45:57 <augur_> right
22:45:59 <augur_> ideally
22:46:03 <johnw> yeah, global IORef
22:46:03 <mzero> and      cleanupMyHaskellStuff :: IORef -> IO ()
22:46:26 <augur_> i'd also need the haskell stuff to have some state that changes during execution
22:46:29 <augur_> currently im doing something like
22:46:34 <mzero> Why not just hand the IORef back to C, and let C treat it like void*?
22:46:41 <johnw> yeah, that's what I've been saying
22:46:42 <augur_> interaction :: StateStuff -> IO ()
22:46:46 <johnw> in *that* case it doesn't need to be an IORef at all
22:46:50 <augur_> where interaction recurses by passing the StateStuff along
22:46:52 <johnw> it can just be a pure value
22:47:23 <augur_> so what you're suggesting is, instead of having Haskell do this junk with the interaction state
22:47:27 <augur_> do something like
22:47:28 <mzero> except if you do it pure (which I like), then you need to return it      interaction :: StateStuff -> IO (StateStuff, OtherResult)
22:47:42 <augur_> interaction :: StateStuff -> IO StateStuff
22:47:44 <augur_> or whatever
22:47:48 <johnw> yep
22:47:54 <johnw> the same way the State monad works, ala C
22:47:55 <augur_> return the new state, and keep bouncing it in and out
22:48:33 <augur_> the C side will get a pointer to the data that the haskell stuff needs, the haskell side just needs to (unsafely, probably) coerce to the right type
22:48:35 <xinming> http://lpaste.net/108254   <-- Anyone here would tell me is it possible to write the    case x of in that example to be a pattern match ?
22:48:41 <johnw> not coerce
22:48:44 <johnw> use Storable
22:48:49 <augur_> i dont know storable
22:48:58 <johnw> it's part of the FFI
22:49:04 <augur_> im checking now
22:49:10 <johnw> it lets you render a Haskell value to a series of bytes that get written directly to a memory block
22:49:26 <jle`> xinming: you can use view patterns, but i don't think what you have now is that bad
22:49:45 <johnw> it's the moral equivalent to value * p = malloc(); *p = some_value;  some_value has to implement Storable for the "poke" to work
22:50:03 <jle`> hm actually view patterns would not work too well here either
22:50:05 <mzero> xinming: I don't understand... case /is/ a pattern match
22:50:30 <augur_> whatever the hell poke is :P
22:50:37 <augur_> ok ill look at storable, johnw
22:50:38 <johnw> it's the opposite of peek?
22:50:56 <johnw> back in the old, old, old days of BASIC, peek and poke were the basic memory interaction operations
22:51:12 <jle`> i'm assuming that he means pattern match at the sugary function delcaration level
22:51:20 <augur_> johnw: not that i know what peak is! :)
22:51:30 <johnw> peek is a pointer dereference in C
22:51:37 <johnw> take int * p;
22:51:40 <johnw> *p = 0 is a poke
22:51:43 <johnw> * p is a peek
22:52:02 <xinming> jle`: thanks, I'll try.
22:52:12 <xinming> mzero: Yes, But actually, I want to remove the case thing in that example.
22:52:33 <jle`> yeah, i think as it is now looks prety nice
22:52:50 <mzero> @type isJust
22:52:51 <lambdabot> Maybe a -> Bool
22:52:56 <xinming> I want something like    func a | result_of_x == 'a' = blabla      | result_of_x == 'b' =  blabla
22:53:33 <mzero> why would you use guards for that kind of equality test?
22:53:38 <mzero> rather than pattern matches?
22:54:34 <mzero> func a = case result_of_x of  ;  'a' -> blabla    ;   'b' -> blabla       would be fine if not preferred
22:54:39 <orclev> speaking of FFI, any idea why this is barfing, near as I can tell it doesn't like something about the CPid type? http://lpaste.net/108255
22:55:26 <mzero> xinming: but really, your example could be pretty terse:     myelem item l = isJust $ find (== item) l
22:55:51 <mzero> or even     myelem item = isJust . find (== item)
22:56:03 <xinming> Ok, THanks. I just don't know the function isJust
22:56:08 <xinming> THanks
22:56:10 <c_wraith> orclev: my best guess is that the library defining CPid is really old, and not updated for the fact that the FFI has required constructors to be exported since GHC 7ish
22:56:29 <mzero> xinming: it isn't in Prelude, you'll need to    inlcude Data.Maybe
22:56:40 <mzero> er,import
22:57:10 <c_wraith> orclev: you used to be able to declare a foreign import with only types in scope, but it requires constructors to be in scope too, now.
22:57:17 <orclev> c_wraith: hmm, wonder if it's redefining CPid... it's part of base now so far as I know, but maybe it isn't using the one from base... thanks, I'll keep digging
22:58:30 <c_wraith> orclev: maybe it's importing only the type, and not the constructors?
22:59:28 <orclev> c_wraith: bingo... "import System.Posix.Types (CPid)"
23:00:41 <orclev> hmm, doesn't look like that library has a repo listed... I'd do a fork and pull on github or whatever, but I guess I'll have to settle for e-mailing the maintainer
23:05:58 * hackagebot haskbot-core 0.0.1.0 - Easily-extensible chatbot for Slack messaging service  http://hackage.haskell.org/package/haskbot-core-0.0.1.0 (jonplussed)
23:06:34 <jonplussed> gaaaah don't look at it yet -_-'
23:06:46 <jonplussed> kekeke
23:23:37 <orclev> does the FFI have any new restrictions around newtype wrappers? It looks like this code is choking on WordPtr now which is a newtype around Word it looks like
23:25:10 <c_wraith> orclev: I don't believe so, as long as the other conditions are met
23:27:32 <orclev> c_wraith: aside from the constructor being in scope any other gotchas? I'm assuming this library worked at some point, but it definitly doesn't seem to be working now...
23:29:06 <orclev> alternatively any way to get GHC to tell me what in particular it doesn't like about using WordPtr in a extern declaration?
23:29:41 <c_wraith> orclev: I don't think I can add much else at this point.  It's been a while since I've done any FFI stuff.
23:30:43 <orclev> yeah... this started out as a quick and dirty experiment, and I've now been sucked down the rabbit hole of trying to fix a bunch of old broken libraries...
23:31:00 * hackagebot keystore 0.5.0.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.0.1 (ChrisDornan)
23:45:39 <orion> :t (+)
23:45:40 <lambdabot> Num a => a -> a -> a
23:45:45 <orion> :t ($)
23:45:46 <lambdabot> (a -> b) -> a -> b
23:46:43 <ropav> is that coffeescript?
23:47:21 <c_wraith> ropav: nah, lambdabot doesn't speak coffeescript
23:47:34 <dwcook> Lambdabot's responses are Haskell types
23:49:13 <ropav> Ah.  I'm pretty basic, I hardly have any experience within any language, but the syntax looked vaguely familiar so I decided to venture a guess.
23:49:27 <jle`> nice guess though :)
23:50:35 <c_wraith> ropav: the name of the channel is a hint. :P
23:51:03 * hackagebot contravariant 1.0 - Contravariant functors  http://hackage.haskell.org/package/contravariant-1.0 (EdwardKmett)
23:51:06 <ropav> A better guess would of been haskell, considering it's the channel the bot was responding in.  Just started using IRC again after like 8 years, figured it's a good place to pick things up.
23:56:03 * hackagebot semigroupoids 4.0.4 - Semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-4.0.4 (EdwardKmett)
23:56:05 * hackagebot tagged-transformer 0.7.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-transformer-0.7.1 (EdwardKmett)
