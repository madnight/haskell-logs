00:00:08 <levi> This line: res <- either (error "oops") id <$>
00:00:08 <kazagistar> knapper_tech: why is res run through an either, and then through a case statement matching either?
00:00:21 <levi> kazagistar: That's what I'm talking about.
00:00:22 <kazagistar> oh, I missed like a mile of scrollback
00:00:30 <kazagistar> I was up like 20 lines sorry
00:00:36 <levi> Heh, no prob.
00:00:58 <levi> So, the <$> is Applicative-style `fmap`
00:01:07 <levi> It is also the same as `liftM`
00:01:32 <levi> It lifts the expression on the left into the IO monad and applies it to the expression on the right.
00:01:33 * hackagebot path-pieces 0.1.4 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.4 (MichaelSnoyman)
00:02:02 <knapper_tech> I need to simplify this
00:02:03 <levi> So, the right expression is runEitherT, which extracts an Either out of an EitherT monad.
00:03:35 <levi> So you've effectively got 'either (error "oops") id <some Either value>', since the <- binds the pure value in the context of the next expression in the monad chain (the next line in the 'do' block)
00:05:18 <ReinH> :t runEitherT
00:05:19 <lambdabot>     Not in scope: ‚ÄòrunEitherT‚Äô
00:05:19 <lambdabot>     Perhaps you meant ‚ÄòrunWriterT‚Äô (imported from Control.Monad.Writer)
00:05:24 <levi> The way `either` works is that it takes a function to evaluate with the contents of the Left value, and a function to evaluate with the contents of the Right value, and then an Either. It does the case analysis inside and calls the appropriate one of the two functions.
00:06:53 <levi> So, given that expression, you're either going to crash on a Left or get a HeistState.  So you can be certain that if res gets bound to any non-error value, it'll be a plain HeistState.
00:07:15 <levi> Hopefully that made some sense.
00:07:24 <ivanm> how do you explicitly import a type class and it's methods if the type class's name is a symbol? import Foo ((:->)(..)) ?
00:07:54 <joelteon> yep
00:08:02 <joelteon> just like you would for any other identifier
00:11:36 <isomorpheous> Hey, so, I'm a bit unclear on the terms of the GPL
00:12:12 <isomorpheous> I am writing a web app, currently licensed under the BSD license
00:12:25 <isomorpheous> I want to use Pandoc to do markup conversion
00:12:35 <isomorpheous> do I need to license my app under the GPL?
00:12:41 <isomorpheous> http://en.wikipedia.org/wiki/GNU_General_Public_License#Linking_and_derived_works
00:12:46 <lfairy> isomorpheous: web apps are served, not distributed
00:12:51 <isomorpheous> This seems to be up to debate
00:12:57 <lfairy> no, it's not
00:13:05 <lfairy> in fact, AGPL was created to patch this loophole
00:13:26 <lfairy> (I'm not a lawyer by the way, so don't sue me if I get it wrong)
00:13:54 <maybefbi> are unboxed vectors lazily evaluated?
00:14:26 <isomorpheous> lfairy: hm
00:14:26 <knapper_tech> levi:  http://hackage.haskell.org/package/heist-0.11.1/docs/Heist.html
00:14:37 <knapper_tech> initHeist :: Monad n => HeistConfig n -> EitherT [String] IO (HeistState n)
00:14:39 <kazagistar> maybefbi: how would that work?
00:14:40 <isomorpheous> lfairy: I might ask John Macfarlane, see if he's okay with it
00:15:06 <isomorpheous> lfairy: permission from the copyright holder overrides anything from the license
00:15:06 <knapper_tech> I want to write some simple code to verify that I can get a heist state
00:15:09 <levi> I am fairly sure all unboxed things are strictly evaluated.
00:15:15 <knapper_tech> but that type signature seems to say that I need an extra type variable
00:15:19 <lfairy> isomorpheous: yeah that sounds like a good idea
00:15:30 <maybefbi> kazagistar, hmm i guess they will allocate new vectors when new things need to be evaluated
00:16:33 <knapper_tech>     No instance for (Monad n0) arising from a use of ëinitHeistí
00:16:50 <knapper_tech> I'm just running let res = initHiest HeistConfig { ...
00:16:55 <levi> knapper_tech: It's a monad transformer over some monad you supply. You can use Identity if you don't want any monadic stuff.
00:19:08 <knapper_tech> levi:  Why would I want to supply a Monad?
00:20:00 <knapper_tech> presumably, HeistState is used by renderTemplate whenever I want to render a response to a Scotty route
00:20:21 <knapper_tech> I want my code to compile and do nothing.
00:20:33 <knapper_tech> Doing nothing is great.  I'll move onto the next step.
00:20:35 <levi> Sorry, I realize these are pretty opaque weird things when you're starting; this makes the whole thing very flexible, but you have to be familiar with monad usage patterns.
00:20:35 <knapper_tech> haha
00:21:28 <Zekka> knapper_tech: Think of each monad as being associated with a few superpowers your code now has
00:21:37 <Zekka> with monad transformers you can take multiple groups of superpowers and combine them
00:21:59 <knapper_tech> We'll get there
00:22:09 <tdammers> as to why you'd want to supply a monad: it's so you can combine several contexts with monad semantics into one monad
00:22:10 <Zekka> i.e., if I want to do IO but also the potential for errors I might use EitherT Error IO intead of just IO
00:22:13 <levi> Usually you build some application-specific monad for your app, and this allows you to keep your apps concerns nice and separate from Heist and Scotty concerns.
00:22:39 <Zekka> Like Levi said, you usually wrap it in a newtype that expresses the behaviors you actually want
00:22:43 <knapper_tech> http://lpaste.net/107236
00:23:20 <tdammers> common strategy:
00:23:34 <tdammers> 1. Find the monad transformers that implement the effects you need to build what it is you need
00:23:43 <tdammers> 2. Define a monad stack and wrap it in a newtype
00:24:05 <tdammers> 3. Expose the functionality you want publicly, keep the actual monad stack secret
00:25:08 <Zekka> There's a few strategies to do 3 but 1 and 2 are pretty consistent
00:25:09 <trap_exit> surface pro 3
00:25:10 <trap_exit> can I get internet on it
00:25:10 <trap_exit> wrong channel
00:25:39 <Zekka> (look up mtl and mmorph as libraries that describe strategies to do 3)
00:25:57 <knapper_tech>     No instance for (Monad n0) arising from a use of ëinitHeistí
00:25:57 <knapper_tech>     The type variable ën0í is ambiguous
00:26:22 <knapper_tech> I'm believe that I supply a type variable somewhere in http://lpaste.net/107236   and the compiler doesn't complain
00:26:43 <knapper_tech> the program won't do anything with res, but at first I just want this program to compile
00:27:11 <tdammers> 3 is kind of optional, but I'd recommend it anyway
00:27:18 <tdammers> narrow interfaces and all that
00:27:21 <levi> knapper_tech: You need to use it within the context of a monad; that will determine the type variable there
00:27:33 <kazagistar> is that record syntax valid?
00:28:06 <knapper_tech> levi: what is a generic monad I can use?  mempty?
00:28:38 <levi> Use res <- <exp> instead of let res = <exp>; then n0 will be IO
00:29:57 <levi> I think you could also wrap it in runIdentity.
00:30:36 <kazagistar> runEitherT returns a type of { m (Either¬†e a) }
00:31:02 <kazagistar> where M is going to be IO
00:31:45 <kazagistar> so to unwrap it from being IO (Either e a), you need to use <-
00:32:29 <levi> Well, m is only IO if you make it be IO by using <- in an IO do block.
00:33:00 <kazagistar> yes
00:34:06 <kazagistar> also, knapper_tech, mempty is a Monoid thing, which is different
00:34:52 <levi> Where'd you see an mempty?
00:35:05 <levi> Oh nvm.
00:35:06 <kazagistar> in his comment
00:35:26 <tdammers> I think Scotty's monads also implement Monoid
00:35:39 <kazagistar> that might be
00:35:41 <tdammers> I'd expect Heist to also do that, not sure though
00:35:46 <tdammers> I know Blaze does
00:36:02 <levi> Sure, but that won't help with this problem.
00:36:10 <tdammers> no, but it would explain the mempty
00:36:28 <levi> I think that was just pure confusion.
00:38:31 <knapper_tech> At some point I need a HeistState to call renderTemplate and then pipe all this out of a Scotty route
00:38:52 <knapper_tech> Where can I approach this and obtain working code piece at a time?
00:39:36 <knapper_tech> I have a Scotty route that accepts a string as the input to html.
00:39:55 <knapper_tech> Presumably all string inputs to html work
00:40:04 <knapper_tech> perhaps there's another way to provide the response to the route
00:40:19 <knapper_tech> I'm not entirely sure that I care at this point
00:41:59 <knapper_tech> I used HStringTemplate to get a really quick implementation of templates but decided it was probably going to turn out to be way too limiting in the end.
00:45:50 <knapper_tech> The end result is going to be ten lines that make this program work.
00:46:51 <kazagistar> there are no real shortcuts to understanding here though
00:47:11 <Qfwfq> How is safe indexing achieved with multi-parameter typeclasses? This paper mentions it in passing (..however, there are situations where type-level computation is essential) but doesn't go into the specifics.
00:47:28 <solidus-river> jle`: i think i finished those categories http://lpaste.net/107241
00:48:03 <solidus-river> the only thing that doesnt make sense is that IAuto' doesn't actually seem different than IAuto
00:48:14 <solidus-river> unless IAuto prime is suppose to return the origonal wire on inhibition
00:48:20 <jle`> solidus-river: did you try compiling? ;)
00:48:37 <solidus-river> haha, nope
00:48:41 <jle`> your id's are weird on everything below  line 36
00:48:46 <jle`> also you can't use letters in operators, but that's not a big deal
00:49:11 <solidus-river> whats wierd about id's below 36,
00:49:21 <jle`> IAuto' is actually prett ymuch identical to IAuto, except your failures have an e attached to them
00:49:33 <jle`> Maybe a is equivalent to Either () a
00:49:44 <jle`> id  = \x -> IACons' (\x -> (Either e b, id))
00:49:44 <solidus-river> and also this shows that theres no real reason for the Monoid restriction on t
00:49:51 <solidus-river> but i guess if you want to check for mempty it makes sense
00:50:18 <jle`> Either is not a data constructor
00:50:22 <jle`> :t Either 4 1
00:50:23 <lambdabot>     Not in scope: data constructor ‚ÄòEither‚Äô
00:50:24 <lambdabot>     Perhaps you meant ‚ÄòOther‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
00:50:28 <jle`> you probably meant Right
00:50:54 <jle`> remember, there are no restrictions on the types...just restrictions on the instances and functions dealing with the types
00:51:01 <jle`> you don't check for mempty
00:51:07 <jle`> but some functions on Wires *use* mempty
00:51:12 <knapper_tech> Making zero progress.  I need to reduce my problem down further.  What is a reduced presentation?
00:51:37 <jle`> solidus-river: so for those functions that use mempty, you need the monoid constraint.  i don't think all of them use mempty
00:51:39 <pavonia> Qfwfq: The general idea is to represent the structure of the container value by a type parameter and only allow indexing for proper typed values, I think
00:51:40 <solidus-river> hmm, if i have to chose either Right or Lef than i need to id's
00:51:46 <solidus-river> one for right and one for left, right?
00:51:49 <solidus-river> oh boy
00:51:55 <jle`> solidus-river: no, remember the category laws
00:51:57 <jle`> id . f = f
00:52:00 <jle`> g . id = g
00:52:30 <jle`> between an id with Left and an id with Right, only one satisfies those laws
00:52:35 <knapper_tech> Left/Right is easy.  What is the simpler way to look at this return type of initHeist so that I can build something that works?
00:53:57 <solidus-river> why would Left make that bad
00:54:01 <jle`> solidus-river: actually...you can't even make Left
00:54:17 <jle`> can you see why?
00:54:22 <jle`> ...this is where having a compiler would come in handy :P
00:54:24 <solidus-river> only if we know that left inhibits
00:54:27 <jle`> this is the whole point of the haskell compiler, you know
00:54:35 <jle`> i mean, you literally can't compile an example with Left
00:54:43 <solidus-river> haha, yeah but i dont see why.. hmm
00:54:58 <solidus-river> i'll try compiling it and see what it complains about
00:55:06 <solidus-river> maybe i need to look at the Left Right Monad
00:55:24 <jle`> it's the same reason why you can't have return x = Left x for the Either monad
00:55:37 <jle`> yeah, the compiler is probably your strongest helper in situations like this :P  don't discount it
00:55:45 <jle`> it's an integral part of haskell development
00:55:57 <jle`> i don't do anything without a typechecker that checks everything as soon as i save
00:56:44 <alphonse23_> anyone know how to get the Complex package
00:56:46 <jle`> the error message will tell you exactly why you can't put Left there :)
00:56:58 <jle`> solidus-river: seriously, always develop with a constant typechecker loop
00:56:59 <alphonse23_> is it a simple cabal install Complex, I get a strange error when I do that
00:58:16 <pavonia> alphonse23_: There doesn't seem to be such a package on Hackage
00:58:31 <solidus-river> jle`: for the project i've been doing i've been using grunt / watch to auto lint / unit test / compile on file change
00:58:36 <solidus-river> is there a better tool than grunt for that?
00:58:46 <alphonse23_> hmm. I'm trying to compile some fractal code that imports package call Complex
00:58:46 <jle`> what editor do you use?
00:58:51 <solidus-river> it works but seems wierd using a web oriented node tool in a haskell pipeline
00:58:55 <solidus-river> vim
00:58:55 <alphonse23_> any idea what it's refering too?
00:59:00 <jle`> use syntastic + ghc-mod
00:59:09 <jle`> all type errors and hlint stuff are highlighted
00:59:13 <jle`> on every save
00:59:42 <pavonia> alphonse23_: Do you have a link to that code?
00:59:43 <solidus-river> sweet
00:59:57 <alphonse23_> http://www.ryanlothian.com/projects/haskell_fractals/
01:00:46 <supki> alphonse23_: change Complex to Data.Complex
01:01:41 <pavonia> Complex is the name of a module here, not a package name
01:02:22 <alphonse23_> hmm, i guess it's some old code
01:02:43 <alphonse23_> thanks got past the import error, but now I have some scoping issues
01:02:50 <pavonia> Yes, I think it's part of the heaskel98 package
01:03:03 <pavonia> *haskell98
01:12:24 <knapper_tech> http://snapframework.com/docs/tutorials/heist#initializing-heist
01:12:35 <knapper_tech> Unfortunately this code snippet doesn't quite work.
01:16:43 * hackagebot bzlib-conduit 0.2.1.2 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.2.1.2 (MichaelSnoyman)
01:24:44 <kamatsu> I was looking into ekmett's trifecta library lately. It seems like all the layout parsing (and a bunch of other stuff) is gone in v1.0 that was in v0.53
01:26:51 <kamatsu> does anyone know what happened?
01:29:24 <sopvop> kamatsu: Wasn't it moved to parsers package?
01:30:41 <solidus-river> well, looks like neobundle doesnt want ot install ghcmod-vim or syntastic
01:30:41 <kamatsu> can't find layout in parsers either
01:30:45 <solidus-river> so i'll have to do without them for now
01:30:58 <solidus-river> i looked at the monad declaration for Either i see why Left doesnt work
01:31:07 <solidus-river> :P
01:31:13 <jle`> :P
01:31:17 <jle`> you do'nt have anything of type e
01:31:20 <jle`> to put in the Left
01:31:27 <solidus-river> wierd, in Learn you a haskell it says that Left is for failure only by convention
01:31:34 <solidus-river> with that type of monad instance it seems more than convention
01:31:42 <jle`> you only have something of type a, for Right
01:32:00 <jle`> that's an interesting thing for it to say.  maybe it didn't want to get involved into explaining why
01:32:20 <nisstyre> solidus-river: just because a type is used in a certain way somewhere else that doesn't make it more than convention
01:32:30 <jle`> it's more or less required that the second parameter is the success
01:32:46 <jle`> for the Monad, Functor, Applicative instances
01:32:47 <solidus-river> nisstyre: the monad instance by default uses Left like a failure
01:32:53 <jle`> or any (* -> *) typeclass
01:32:56 <solidus-river> Left a >>= _ = Left a
01:33:03 <nisstyre> solidus-river: yes, I'm saying that the Monad instance isn't necessarily authoritative
01:33:03 <jle`> it's not an arbitrry choice
01:33:41 <nisstyre> solidus-river: but you should use Left as failure because it makes more sense
01:33:42 <jle`> you can't have many meaningful instances involving Either if Left is your "success" semantics
01:34:04 <jle`> only *-kinded typeclasses
01:34:34 <jle`> ...or well, i guess only (* -> *) kinded typeclasses require Left to be failure
01:34:44 <jle`> (* -> * -> *) kinded typeclasses give you more leeway
01:35:08 <nisstyre> jle`: you can write a type level "flip" function (using type families or whatever)
01:35:27 <nisstyre> at least I think that should be easy, never done it myself
01:35:27 <jle`> nisstyre: yeah, but it would be a different type then, no?
01:35:32 <nisstyre> jle`: of course
01:35:37 <jle`> (*2) 4 is not 4
01:35:40 <jle`> flip f is not f
01:35:48 <jle`> ah yeah
01:35:50 <nisstyre> jle`: but it's a different type the same way flip f is a different function
01:35:59 <nisstyre> yeah I agree
01:36:45 * hackagebot mono-traversable 0.6.0.4 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.0.4 (MichaelSnoyman)
01:37:01 <nisstyre> jle`: I'm not sure if it would still be usable
01:37:22 <solidus-river> jle`: so is this more correct
01:39:16 <solidus-river> oh, i never pasted the link
01:39:22 <solidus-river> http://lpaste.net/107241
01:39:38 <solidus-river> i'm going to try to get syntastic to work in the meantime, i wonder why its not loading
01:42:37 <jle`> solidus-river: yeah, try to compile it
01:42:43 <jle`> or get syntastic to work
01:42:52 <jle`> just in line 74
01:42:54 <jle`>   id  = \x -> Wire (\x -> m (Right b, id))
01:42:58 <jle`> `b` is not in scope
01:43:05 <jle`> `m` is not in scope
01:43:12 <mbrock_> say I have a structure of 10,000 nodes. I want to do some IO processing of each node, concurrently, but limited via semaphore to (say) a hundred running threads. the cleanest way, I think, is to spawn all threads and just let them wait. on GHC, does this seem reasonable?
01:43:16 <Lethalman> @type succ
01:43:17 <lambdabot> Enum a => a -> a
01:43:25 <Lethalman> my lambdabot runs code, but does not print types
02:12:12 <solidus-river> jesus, jle` i cant even get the first definition to compile
02:12:22 <jle`> lol
02:12:27 <solidus-river> is there something broad picture i'm missing that i'll gain by trudging through all these errors?
02:12:33 <solidus-river> they are pretty dumb errors
02:12:38 <jle`> yeah that's why a tight typecheck workflow is important
02:12:43 <jle`> um probably not
02:12:50 <solidus-river> like I have to find out how to import Category without importing id, (.), (>>>) from category
02:12:53 <solidus-river> but stillb e able to instance it
02:12:53 <jle`> but you should really not let yourself write code that doesn't typecheck
02:13:07 <jle`> ...it's not a good habit in general
02:13:16 <jle`> :)
02:13:18 <solidus-river> well, i have syntastic workign with ghc-mod now
02:13:23 <solidus-river> ghc_mod
02:13:30 <solidus-river> very nice set of plugins
02:13:36 <jle`> because one of haskell's greatest features is the ability to typecheck everything right away and see when anything goes wrong ever
02:13:46 <jle`> um
02:13:52 <jle`> i looke dthrough what you wrote, most of it you seem to get the idea
02:14:06 <jle`> did you fix line 74?
02:14:13 <jle`> id  = \x -> Wire (\x -> m (Right b, id))
02:14:26 <jle`> id  = \x -> AMCons (\x -> m (Right b, id))
02:14:42 <jle`> stuff like this represents some minor gaps in understanding what's going on/fitting things in your head
02:14:47 <solidus-river> i dont get why b isn't in scope
02:14:54 <jle`> with a tight typechecker loop, you'd see why it doesn't work right away
02:15:00 <jle`> solidus-river: well...what is b?
02:15:02 <jle`> where doe sit come from?
02:15:23 <solidus-river> comes from instance Monad e => Category AutoM e m a b
02:15:25 <solidus-river> in there
02:15:29 <jle`> b is a type there
02:15:30 <jle`> a type variable
02:15:36 <jle`> but you use it with Right... a data constructor
02:15:42 <jle`> > Right Int
02:15:43 <lambdabot>  Not in scope: data constructor ‚ÄòInt‚Äô
02:15:44 <lambdabot>  Perhaps you meant one of these:
02:15:44 <lambdabot>    ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
02:15:44 <lambdabot>    ‚ÄòInR‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
02:15:59 <jle`> > Right Bool
02:16:00 <lambdabot>  Not in scope: data constructor ‚ÄòBool‚Äô
02:16:14 <jle`> b is not a value you can pass into Right
02:16:34 <jle`> you can only pass in values
02:16:40 <jle`> ...of *type* b
02:16:46 <jle`> (in that situation)
02:17:17 <jle`> also remember what type id is supposed to have
02:17:25 <jle`> id :: Wire s e m a a
02:17:27 <jle`> but the way you wrote it
02:17:39 <jle`> it looks like id :: a -> Wire s e m a a
02:17:45 <jle`> (if it could even be called that)
02:18:01 <jle`> oh yeah, your line 4 example is wrong then too, sorry i didn't catch it earlier
02:18:05 <jle`> :/
02:18:59 <solidus-river> yeah, i figured out the errors and its giving me one i dont understand now
02:19:08 <solidus-river> id  = \x -> ACons (\x -> (x, id))
02:19:14 <solidus-river> it doesnt like id in there
02:19:36 <jle`> well, first, you imported Prelude hiding (id, (.)), right?
02:19:49 <jle`> remember, id :: Auto a a
02:19:59 <jle`> but the way you are writing it, it looks like id :: a -> Auto a a
02:20:06 <jle`> or something like that, but it can't even typecheck like that
02:20:29 <danilo2> Hello! Is there any way in Haskell to write a type function other than type families? I can write what I want usig type families, but then I cannot use it in the instance declaration head (its illegal there). I just want to write a simple rule, like this: "IC t m v  :>> t2 = IC t2 (IC t m) v"
02:20:36 <jle`> remember that ACons has to contain a function that returns a `b` and an `Auto a b`....but you passed in `id`, which is an a -> Auto a a-like thing
02:21:02 <jle`> just fix your id and it should go away
02:22:32 <solidus-river> ah, it did but now it doesnt like my >>>
02:22:39 <solidus-river> \x -> is a misstep
02:23:55 <jle`> id = ACons (\x -> (x, id)) should work
02:24:13 <jle`> why don't you just define your (.) right in the Category instance?
02:24:23 <solidus-river> aye, i qualified my category import so i used id = ACons (\x -> (x, C.id))
02:24:38 <jle`> it should be C.id then if you do that, for the first part
02:24:38 <solidus-river> because its easier for me to think about >>> instead of <<<
02:24:50 <jle`> um. it might not be worth your time going through all the type errors
02:25:09 <jle`> the last weird gap is still id  = AMCons (\x -> m (Right b, id))
02:25:15 <jle`> now that doesn't make any sense
02:25:58 <solidus-river> somethings fundamentally wrong with my very first definitoins of >>>
02:26:05 <solidus-river> that funciton is not the right type
02:26:22 <jle`> you need the ACons
02:26:28 <jle`> ACons $ \x ->
02:29:14 <solidus-river> hmm, kk, i'm chuging through some more errors
02:29:37 <solidus-river> it doesnt like my id for IAuto because x isn't of type Maybe b
02:29:56 <solidus-river> oh thats easy
02:29:58 <jle`> :)
02:30:09 <jle`> syntastic is nice
02:30:13 <danilo2> Hello! Is there any way in Haskell to write a type function other than type families? I can write what I want usig type families, but then I cannot use it in the instance declaration head (its illegal there). I just want to write a simple rule, like this: "IC t m v  :>> t2 = IC t2 (IC t m) v"
02:35:34 <solidus-river> jle`: http://lpaste.net/107252
02:35:57 <solidus-river> that doenst make much sense though
02:36:07 <solidus-river> i wish i could format things better in syntastic
02:37:09 <jle`> solidus-river: what's with the type constraints?
02:37:23 <jle`> Maybe isn't a typeclass
02:38:21 <solidus-river> well, i'm geting something out of compiling this
02:38:35 <jle`> why not (>>>+) :: IAuto a b -> IAuto b c -> IAuto a c ?
02:38:39 <solidus-river> turn around time is much better with syntastic than with grunt in another window
02:38:46 <jle`> haha indeed :)
02:39:04 <solidus-river> yeah i fixed IAuto now i'm on IAuto' where the mix up is, i'm going to think at it for a bit
02:39:40 <jle`> no problem, take your time. i actually might be heading off to bed soon...but i'm confident that you can handle what is about to come your way :)
02:49:56 <solidus-river> heh, well i got some of it, if your still around i'm stuck on this, it doesnt like my recursive call to >>> in IAuto'
02:50:00 <solidus-river> http://lpaste.net/107253
02:55:06 <jle`> solidus-river: what is the type of x' ?
02:56:43 <jle`> solidus-river: and what is the type that the first item in the tuple has to be to return an IAuto e a c  .. ?
02:57:16 <solidus-river> x' is Left e
02:57:28 <solidus-river> which should satisfy Either
02:58:09 <jle`> Left e is not a type
02:58:30 <solidus-river> oh then i guess its Either e b
02:58:36 <solidus-river> but the b isn't bound at that point
02:58:59 <jle`> what does "the b isn't bound" mean?
02:59:03 <jle`> it has a type
02:59:05 <jle`> it's Either e b
02:59:07 <jle`> :)
02:59:26 <jle`> and what does the type need to be when you put it in a tuple to return an IAuto e a c?
02:59:50 <solidus-river> it needs to be Either e b
03:00:00 <solidus-river> so if it is Either e b
03:00:06 <solidus-river> and it needs to be either e b...
03:00:43 <jle`> data IAuto' e a b = IACons' { runIAuto' :: a -> (Either e b, IAuto' e a b)}
03:00:52 <jle`> you want an IAuto e a c
03:01:02 <jle`> so it has to be a -> (Either e c, IAuto' e a c)
03:01:13 <jle`> it has to be an Either e c
03:01:28 <solidus-river> but i have no c
03:01:45 <jle`> but you have a way to make an Either e c
03:01:47 <jle`> given an e
03:02:14 <jle`> there's a function
03:02:22 <jle`> e -> Either e c
03:02:29 <solidus-river> i do?
03:02:30 <solidus-river> huh
03:02:33 <jle`> mhm
03:02:39 <solidus-river> hoogle time i gues
03:02:39 <jle`> a function where, given any e, you can make an Either e c
03:03:16 <solidus-river> oh, Left
03:03:19 <solidus-river> but.. thats what x' is
03:03:47 <solidus-river> wierd... when i make the check explicit it compiles
03:03:47 <jle`> x' is Either e b
03:03:55 <solidus-river> but that means wires have to be strict in inhibition?
03:03:57 <jle`> but you can get the e value, using pattern matching
03:04:07 <jle`> you can use Left to turn it into an Either e c
03:04:17 <jle`> this has nothing to do with strictness/nonstrictness
03:04:54 <jle`> x' has the type Either e b...it can be either an e or a b.  if you put it in where you exepct an Either e c, it won't work.  Because it could contain the b --- then what?
03:05:06 <solidus-river> well i guess i dont really look at the e value i just take it and put it somewhere else
03:05:46 <jle`> the thing is, you need to put an Either e c there.  But you don't have an Either e c, you have an Either e b
03:06:04 <jle`> the same thing can't be two different types
03:06:22 <jle`> so what you do is pattern match out the e value, and create a new Either e c, using Left
03:06:44 <jle`> you seem to be okay with putting ¬ù(x', i'autoa' >>>- i'autob) there
03:06:50 <jle`> but why couldn't you put that there..."before" the pattern match?
03:07:03 <jle`> do you see why you couldn't put that before your case statement? let ... in (x', i'autoa' >>>- i'autob) ?
03:11:56 * hackagebot cabal2nix 1.64 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.64 (PeterSimons)
03:12:30 <jle`> solidus-river: it's not like the x' magically changes from an Either e b to an Either e c inside your case statement
03:21:13 <quchen> My package still won't be built on Hackage (doc-wise), I'm out of ideas. Local/Travis builds work. http://hackage.haskell.org/package/binary-typed
03:21:38 <quchen> In particular, "/reports" exists, but it's empty. Shouldn't build errors be in there?
03:21:40 <quchen> http://hackage.haskell.org/package/binary-typed-0.1.0.0/reports/
03:38:05 <donri> quchen: #hackage might be better
03:39:42 <bollu> So, I've been thinking about Reader, and I can't for the life of me see how to implement fmap or bind on the Reader. help?
03:40:16 <bollu> Like, how does one "pass" the context to the function when you're using fmap
03:40:41 <bollu> if you decide to ignore the context, then it's pointless to even use Reader
03:40:45 <donri> bollu: well the reader is itself a function
03:41:52 <donri> so you have an a -> b and an e -> a and need to make an e -> b
03:42:33 <bollu> donri, no, wait, go back a step. start from fmap's definition?
03:43:08 <danilo2> Hello! Is there any way in Haskell to write a type function other than type families? I can write what I want usig type families, but then I cannot use it in the instance declaration head (its illegal there). I just want to write a simple rule, like this: "IC t m v  :>> t2 = IC t2 (IC t m) v"
03:43:22 <donri> fmap f (Reader g) = Reader (\e -> ?)
03:43:44 <solidus-river> i need to pattern match and branch in a do block but cas seems unusable
03:43:53 <solidus-river> *case
03:43:59 <merijn> solidus-river: Why would it be?
03:44:09 <solidus-river> its giving me the wrong type
03:44:17 <solidus-river> but i could be interpreting this error wrong
03:44:24 <donri> solidus-river: lambda-case or bind it to a name first
03:44:39 <solidus-river> lambda-case?
03:44:54 <bollu> donri: the "g" of the Reader is a function correct?
03:45:06 <donri> yes
03:45:07 <bollu> solidus-river: \case
03:45:27 <donri> newtype Reader e a = Reader (e -> a)
03:45:33 <frerich> Is there an efficient function which computes all pairs of a list (i.e. 'pairs :: [a] -> [(a, a)]') but treats (0, 1) as (1, 0) equivalent, dropping the latter? E.g. 'pairs [1,2,3,4]' should yield 6 elements [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)] (not necessarily in that order though).
03:46:03 <frerich> I have something which essentially is 'pairs (x:xs) = map (\e -> (x, e)) xs ++ pairs xs' but the repeated (++) seems worrying
03:46:04 <bollu> donri: the "e" is the context, and the "a" is the value right?
03:46:19 <donri> correct
03:46:52 <donri> frerich: sure you don't want a set of sets there
03:46:59 <solidus-river> http://lpaste.net/107258
03:47:06 <solidus-river> i need to somehow collapse nested do blocks
03:47:18 <bollu> donri: so in that case, the "new" Reader that we construct would also need to have a function e -> b right?
03:47:40 <donri> solidus-river: drop the return $ before case
03:47:53 <donri> solidus-river: and possibly add one after Left e ->
03:48:07 <solidus-river> that complains
03:48:27 <solidus-river> i'm full of crud
03:48:29 <donri> bollu: it needs to be e -> b yes, but note that g is e -> a and f is a -> b
03:48:29 <solidus-river> that doesn't complain
03:48:40 <petercommand> http://pastebin.com/8hi9TimV what does the "h s" mean in "(State h) >>= f = State $ \s -> let (a, newState) = h s "?
03:48:44 <solidus-river> :)
03:48:47 <aspidites> what would cause cabal install to not be able to locate an object file?
03:48:52 <frerich> donri: No, I'm not sure. Something based on sets might be just fine as long as 'pairs' has the same signature. I'm mostly worried about the asymptotic complexity, that 'pairs' function when called on a list [1..n] basically does 'concat [[1..n-1], [1..n-2], ...' which is not terribly clever. :-}
03:49:03 <frerich> donri: I'll look into sets, thanks for the idea.
03:49:05 <bollu> donri: right. so use \e -> f g e ?
03:49:08 <merijn> petercommand: It means "apply function h to s"?
03:49:10 <aspidites> i'm trying to install ghcjs and ghcjs-prim fails with an error about ar not being able to find ghcjs-prim.o
03:49:15 <donri> bollu: close
03:49:24 <petercommand> merijn: yeah, but does it mean in this context?
03:49:25 <donri> bollu: remember precedence :)
03:49:29 <Pythonfant> petercommand: the h is a function s->(a,s)
03:49:52 <kqr> i'm using cabal properly for the first time
03:49:52 <bollu> donri: \e -> f $ g e? >_<
03:49:59 <petercommand> Pythonfant: oh...
03:50:00 <donri> bollu: \o/
03:50:06 <donri> bollu: also note that this is (.) :)
03:50:14 <Pythonfant> petercommand: it's what you get out if you use runState
03:50:16 <kqr> when doing cabal init it asks what the package builds and i can choose between library and executable. what does a website count as?
03:50:20 <bollu> donri: ah, right, I always forget .
03:50:23 <bollu> donri: hm
03:50:30 <bollu> donri: you made it seems simple
03:50:42 <bollu> donri: I was trying to define the entire f a -> f b
03:50:42 <merijn> kqr: I'm guessing you're using something like Hakyll?
03:50:53 <bollu> donri: but you took the f a as a parameter. hmm
03:50:59 <kqr> merijn, scotty
03:51:09 <petercommand> Pythonfant: ok, thx :)
03:51:14 <kqr> merijn, if that changes anything
03:51:25 <merijn> kqr: Then executable, most likely
03:51:32 <bollu> donri: what's the usual style while defining fmap?
03:51:35 <kqr> does it matter? i mean, what does the choice affect?
03:51:36 <merijn> kqr: You're building an executable that runs your website, no?
03:51:37 <donri> bollu: fmap :: (a -> b) -> Reader e a -> Reader e b
03:51:47 <kqr> merijn, yeah that's whta i was thinking
03:51:49 <donri> bollu: style?
03:51:49 <bollu> donri: does one always take the a -> b -> f a part and only return f b ?
03:52:00 <bollu> donri: right
03:52:09 <merijn> bollu: Whichever is most convenient :)
03:52:10 <bollu> donri: I was trying to define fmap from just the a -> b part
03:52:14 <donri> bollu: no, it's a special case of Reader being a function itself
03:52:23 <petercommand> Pythonfant: does the (State h) automatically makes h the s -> (a,s) function?
03:52:32 <bollu> donri: ah. so it __needs__ to be defined with 3 arguments?
03:53:00 <merijn> petercommand: State is defined as "newtype State s a = State (s -> (a, s))"
03:53:03 <Pythonfant> petercommand: your pattern matching on State
03:53:05 <bollu> kqr: it affects what's generated by haskell, if you pick a library it'll generate a .so / .a / haskell's equivalent
03:53:10 <donri> bollu: well, if you have a runReader you can compose with that but same thing
03:53:36 <bollu> donri: hmm
03:53:58 <petercommand> hmm....I think I need to look up the record syntax
03:54:01 <bollu> donri: so the function you give Reader, it only has the context and no other parameter?
03:54:10 <bollu> donri: what does mapping a reader over a function mean?
03:54:11 <Pythonfant> petercommand: if you had Maybes you could pattern match on (Just a), with States you can just do the same (State h)
03:54:17 <donri> bollu: note that runReader (Reader f) = f
03:54:31 <bollu> donri: okay..
03:55:21 <donri> bollu: what do you mean?
03:56:06 <bollu> donri: I'm just.. trying to figure out how it fits
03:56:25 <donri> also note that -> already is a monad, same as Reader, and we only have Reader for saner error messages and because we also want ReaderT
03:56:58 <donri> > (do x <- id; return (x + 2)) 3
03:57:00 <lambdabot>  5
03:57:03 <bollu> donri: yeah, I still don't have an intuition as to how ((->) e)  is a monad
03:57:19 <donri> bollu: same as Reader just without the newtype :)
03:57:22 <bollu> :t id
03:57:23 <lambdabot> a -> a
03:57:29 <bollu> donri: xD
03:57:30 <donri> which also means we don't need runReader
03:57:42 <bollu> donri: in that case, I don't understand Reader either :)
03:57:45 <donri> ask = id, for ->
03:58:05 <donri> return = const  :)
03:58:18 <bollu> donri: hmm
03:58:45 <donri> fmap = (.)
03:59:26 <donri> it's quite mind boggling I know, and yet very simple in actuality
03:59:41 <bollu> donri: yeah, the fmap = . is just insane >_>
03:59:49 <bollu> the fact that it works out..
04:00:01 <bollu> donri: question about the way haskell pattern matches
04:00:19 <bollu> look, when we use fmap, fmap:: a -> b -> Reader e a -> Reader e b correct?
04:00:27 <donri> yep
04:00:36 <bollu> so, now, when you implement fmap
04:00:38 <donri> well need parens there
04:00:43 <donri> (a -> b)
04:00:47 <bollu> donri: hm okay
04:00:59 <donri> because it's one argument that is a function, not two argument that might not be functions
04:01:09 <bollu> donri: ahh
04:01:19 <bollu> donri: okay, now
04:02:03 <bollu> isntance Function Reader where
04:02:11 <donri> Functor
04:02:14 <bollu> fmap f (Reader e a) = ??
04:02:24 <donri> no, Reader e a is a type
04:02:38 <bollu> donri: right, sorry, Functor*
04:02:44 <donri> confusingly, types and terms are separate namespaces
04:03:01 <bollu> donri: what?
04:03:08 <donri> newtype ReaderType e a = ReaderData (e -> a)
04:03:25 <bollu> donri: care to explain that? :)
04:03:36 <donri> fmap :: (a -> b) -> ReaderType e a -> ReaderType e b
04:03:38 <Pythonfant> bollu: you want a data constructor
04:03:40 <Pythonfant> not a type
04:03:42 <donri> fmap f (ReaderData g) =
04:03:47 <Pythonfant> Reader e a is not a data constructor
04:04:15 <bollu> donri: so now how do I access the function within ReaderData given ReaderType?
04:04:24 <Pythonfant> the function is the g
04:04:27 <donri> for example, data Bool = False | True  -- Bool is the type and False and True the terms
04:04:43 <bollu> donri: ahhh now I get what I missed
04:04:45 <donri> bollu: pattern mach on (ReaderData g)
04:04:55 <bollu> donri: awesome
04:05:00 <bollu> donri: so the "type" is ReaderType e a
04:05:15 <bollu> donri: and the actual underlying object is ReaderData g
04:05:17 <bollu> donri: riight
04:05:20 <donri> or if you have newtype Reader e a = Reader { runReader :: e -> a }, you can use runReader to get the g
04:05:20 <bollu> donri: understood
04:05:46 <bollu> donri: I can think of it as an enum with one parameter?
04:05:54 <bollu> enum with one type*
04:06:00 <donri> if it helps :)
04:06:36 <bollu> donri: yeah, it sure does :)
04:06:53 <bollu> donri: cool, this clears a /lot/ of things up ^_^ . Thanks a lot! you too Pythonfant
04:07:14 <Pythonfant> np, took me quite a while to figure this out myself :)
04:07:44 <donri> it's common to use the same name for the type and the term especially if there's only one constructor, and this can of course be quite confusing to beginners (or overworked pros!)
04:08:15 <bollu> donri: yeah, that seems like a weird ... pattern
04:10:21 <pjdelport> bollu: Here's one way to see the intuition behind fmap and (.)
04:10:46 <bollu> pjdelport: no, I got that - by rewriting ((->) e) as e->
04:10:51 <bollu> pjdelport: it becomes clear
04:10:59 <pjdelport> Ah, okay then.
04:11:18 <bollu> pjdelport: was your interpretetion different? If so, do tell!
04:13:44 <pjdelport> bollu: Essentially the same, but I was going to add that a higher intuition behind all Functors is that it's just a structure with a certain arbitrarily-typed "hole" that you can "replace", in a sense, using your function (a -> b)
04:13:54 <donri> note that what fmap does is transform the return value while ignoring the environment. that's exactly what (.) does too
04:14:22 <pjdelport> So you have your general signature fmap :: Functor f => (a -> b) -> f a -> f b, and then specific cases like: fmap :: (a -> b) -> Maybe a -> Maybe b
04:14:28 <pjdelport> and: fmap :: (a -> b) -> [a] -> [b]
04:14:44 <pjdelport> for different choices of f
04:15:14 <pjdelport> And specifically, using pseudo-syntax: fmap :: (a -> b) -> (E-> a) -> (E-> b)
04:15:57 <pjdelport> which is just fmap :: (a -> b) -> (e -> a) -> (e -> b) with the (e ->) more distinguished to show how it's analogous to e.g. [a] -> [b]
04:18:27 <pjdelport> So (E-> x) your structure with a typed hole 'x': and composition with fmap / (.) is "replacing" the result type in sense that's analogous to fmap "replacing" the element type for lists.
04:18:53 <pjdelport> "(E-> x) is your structure", i mean
04:50:02 <danilo2> Hello! :) Would somebody be so nice and look at these instance definitions? Why GHC treats them as overlapping? I was sure, that line 26 will use instance form line 22, which will call the one from 21 - I was even sure I wa able to do something like that in the past
04:50:07 <danilo2> http://lpaste.net/107264
04:53:28 <kqr> if i'm in a monad transformer that wraps IO, how do i do IO?
04:53:42 <kqr> i've never really used transformers before
04:53:56 <ion> @type liftIO
04:53:57 <pavonia> :t liftIO
04:53:58 <lambdabot> MonadIO m => IO a -> m a
04:53:59 <lambdabot> MonadIO m => IO a -> m a
04:54:11 <kqr> ah, that easy huh
04:54:14 <kqr> i'll give it a shot
04:57:28 <kqr> wow that really was easy
04:57:39 <kqr> why have i avoided transformers for so long, thinking they're complicated?
04:58:23 <dv-> they can be
05:02:31 <ion> ‚ÄúStateT [input] [] output‚Äù is my favorite. Its instances provide most of a parsing combinator library out of the box. :-P A library with low performance and no error reporting, but one that works nevertheless.
05:03:00 <ion> s/reporting/messages/
05:10:16 <kvanb> I am so confused
05:11:07 <kvanb> Can someone please look at this for me? http://lpaste.net/107265
05:12:08 <kvanb> I don't understand how I can be transforming it in the Pipe p p' but the compiler complains it has not changed.
05:15:19 <kvanb> @pl (\b = yield (Left b))
05:15:19 <lambdabot> (line 1, column 5):
05:15:19 <lambdabot> unexpected "="
05:15:20 <lambdabot> expecting operator, pattern or "->"
05:15:30 <kvanb> @pl (\b -> yield (Left b))
05:15:30 <lambdabot> yield . Left
05:19:29 <trap_exit> what language, is any, is better than haskell ?
05:20:28 <trap_exit> how does "data" and "newtype" differ?
05:20:53 <kvanb> trap_exit: Some people think the next step on Haskell is dependent types
05:20:55 <kvanb> i.e. Idris
05:21:30 <trap_exit> kvanb: I like dependent types
05:21:32 <trap_exit> Idris, however, is not lazy
05:21:36 <kvanb> newtype differs from data because newtype is like type but generates a fresh type which doesn't use the previous types instances and such
05:21:49 <kvanb> also, at runtime there a guarantee they are exactly the same, I think. It's a performance tool too
05:21:56 <kvanb> with 7.8 they coerce automatically
05:21:57 <donri> idris has optional laziness, but it matters less given totality
05:23:04 <trap_exit> what does 'totality' mean in this context?
05:25:02 <donri> trap_exit: https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem
05:26:10 <donri> total meaning terminating, no bottoms. therefore strict vs non-strict semantics don't change the result
05:29:38 <ion> Is there a very newbie-friendly editor that has cabal sandbox support, hlinting and ghci integration?
05:30:12 <trap_exit> yeah, but laziness, sometimes
05:30:14 <trap_exit> has performance benefits
05:30:27 <donri> ion: presumably sublime, but proprietary nagware
05:30:54 <donri> trap_exit: https://groups.google.com/forum/#!topic/idris-lang/cpKH8-QY0TI optional laziness as a type
05:31:16 <trap_exit> donri: damn it
05:31:21 <ion> donri: Ok, thanks
05:31:23 <trap_exit> what can I possibly hold against idris ?
05:32:00 <donri> it's young for one
05:32:29 <kvanb> looks like crap compared to haskell
05:33:21 <kvanb> and lots of syntax is kind of poor or not very high level/polished, because it came about by X person deciding it would make a good language experiment
05:33:37 <kvanb> nevertheless, as it matures it will probably get better/
05:44:35 <majackson> yarp
05:48:08 <h4j534839> Is there any relation between   let ... in   expressions on the one hand, and    let without in (used in list comprehensions, do blocks, and GHCi)    on the other? If yes, what is this relation? If no, why were they both named "let"?
05:51:02 <jkarni> @undo do { let x = 5; return}
05:51:02 <lambdabot> <unknown>.hs: 1: 23:Parse error: }
05:51:06 <jkarni> @undo do { let x = 5; return }
05:51:06 <lambdabot> <unknown>.hs: 1: 24:Parse error: }
05:51:26 <jkarni> @undo do  let x = 5; return
05:51:26 <lambdabot> <unknown>.hs: 1: 22:Parse error: EOF
05:51:29 <jkarni> ugh
05:51:33 <Mysterious_Light> could you refer to any example where the second type of let-notation is used?
05:51:42 <jkarni> @undo do  let x = 5; return ()
05:51:42 <lambdabot> <unknown>.hs: 1: 25:Parse error: EOF
05:52:15 * hackagebot quickwebapp 2.1.0.0 - A quick webapp generator for any file processing tool  http://hackage.haskell.org/package/quickwebapp-2.1.0.0 (jtanguy)
05:52:20 <jkarni> h4j534839: yeah, they're the same thing; let without in is desugared along with do noation
05:52:36 <kqr> does anyone happen to know what haskell type is compatible with the "interval" postgres type? (trying to use postgresql-simple)
05:52:36 <jkarni> h4j534839: http://en.wikibooks.org/wiki/Haskell/do_Notation
05:52:41 <kqr> i find a few of them at: http://hackage.haskell.org/package/postgresql-simple-0.4.2.3/docs/Database-PostgreSQL-Simple-FromField.html
05:52:48 <kqr> including time, date and timestamp variations, but not interval
05:53:57 <ivanm> is it the correct behaviour that "cabal repl" tries to compile the entire project (thus making it difficult to hack on one module at a time if making breaking changes)?
05:54:37 <h4j534839> Mysterious_Light:
05:54:38 <h4j534839> calcBmis :: [(Double, Double)] -> [Double]
05:54:38 <h4j534839> calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
05:54:39 <ChongLi> kqr: DiffTime
05:54:40 <ChongLi> ?
05:54:47 <h4j534839> That let without in
05:55:06 <kqr> ChongLi, i just thought about trying that
05:55:10 <ChongLi> kqr: hmmm; interval in postgres is 12 bytes
05:55:22 <h4j534839> jkarni: i don't know monads yet so i can't get that page
05:55:26 <h4j534839> i'm not there yet
05:56:22 <trap_exit> it's amazing
05:56:32 <kqr> ChongLi, not DiffTime doesn't have a FromField instance, so probably not that
05:56:34 <trap_exit> that haskell is one of the greatest inventions of humanity
05:56:43 <ChongLi> kqr: DiffTime is a wrapper around Pico
05:57:03 <ChongLi> which itself is a Fixed E12
05:57:42 <ChongLi> kqr: yeah, I don't know
05:57:45 <ChongLi> may have to roll your own
05:57:58 <Mysterious_Light> @undo [bmi | (w, h) <- xs, let bmi = w / h ^ 2
05:57:58 <lambdabot> <unknown>.hs: 1: 41:Parse error: EOF
05:58:04 <Mysterious_Light> @undo [bmi | (w, h) <- xs, let bmi = w / h ^ 2]
05:58:04 <lambdabot> concatMap (\ (w, h) -> let { bmi = w / h ^ 2} in [bmi]) xs
05:58:08 <Mysterious_Light> funny
05:58:12 <kqr> ChongLi, ah shit, i had hoped i could avoid that, but it looks like it
06:00:46 <kqr> second question: what does it mean if i can't do "cabal repl" because unix-time says "unknown symbol _GLOBAL_OFFSET_TABLE_"?
06:01:01 <jkarni> h4j534839: the only context in which do without let happens is in monads
06:01:18 <jkarni> h4j534839: it just so happens that they might be more common then you think (e.g. lists)
06:01:22 <h4j534839> jkarni: i wasn't talking about do without let, but let without IN
06:01:34 <jkarni> h4j534839: sorry, yes, that
06:01:38 <jkarni> h4j534839: my mistake
06:01:39 <kvanb> kqr: uh
06:01:43 <kvanb> is that a build error?
06:01:55 <kqr> kvanb, it doesn't happen when i do cabal build, no
06:01:58 <kqr> kvanb, only when i do cabal-repl
06:02:02 <h4j534839> jkarni: i gave two other examples. list comprehensions and GHCi
06:02:10 <h4j534839> ones i've encountered so far
06:02:11 <jkarni> h4j534839: they're both monads
06:02:15 <kvanb> it means you could be using shared libraries or something
06:02:17 <kvanb> and it exploded.
06:02:21 <kvanb> using latest ghc?
06:02:21 <h4j534839> oh ok
06:02:39 <jkarni> h4j534839: ghci runs in the io monad, in essence
06:03:06 <h4j534839> jkarni: so i first need to learn monads to understand why  let is the same as let..in ?
06:03:08 <jkarni> h4j534839: see Mysterious_Light 's @undo command above for list do-desugaring
06:03:25 <kqr> kvanb, 7.6.3, so probably no
06:05:06 <jkarni> h4j534839: sort of - you can just keep using it and pretend it doesn't bother you
06:05:13 <jkarni> h4j534839: for now
06:05:19 <h4j534839> ok
06:05:55 <jkarni> h4j534839: if you're not explicitly seeking out monads, and writing do-blocks, lists and ghci will likely remain the two cases you see for that
06:06:27 <h4j534839> jkarni: ok thanks for the info
06:06:33 <h4j534839> something to keep at the back of my head for later
06:08:32 <kqr> kvanb, does it help to know the file that causes the error seems to be libHSunix-time-0.3.1.a?
06:08:43 <kqr> kvanb, or is that just a generic name for the entire library when compiled?
06:09:20 <h4j534839> jkarni: but what the hell is that @undo ?
06:09:23 <kvanb> kqr: I don't know ,sorry
06:09:43 <kqr> no problem!
06:09:46 <kqr> i hope someone else does
06:09:54 <kqr> in the meantime i'll try to find the problem
06:10:13 <jkarni> h4j534839: it's a little feature of lambdabot that desugars do-notation
06:10:23 <h4j534839> jkarni: ok thanks
06:10:34 <jkarni> h4j534839: (there's a special sugard notation for monads that's often more pleasant to use)
06:11:04 <h4j534839> ok
06:11:11 <Mysterious_Light> @pl let x = y in f x
06:11:12 <lambdabot> f y
06:11:25 <Mysterious_Light> @pl let Just x = y in f x
06:11:26 <lambdabot> f x
06:12:13 <Mysterious_Light> why the last result is f x? The variable x is not free.
06:12:18 * hackagebot sym 0.11 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.11 (AndersClaesson)
06:13:36 <danilo2> Hello! :) Is there in Haskell a function like ((m a -> m b) -> (t m a -> t m b)) ? Something like fmap but with monad transformers?
06:14:38 <copumpkin> do you really need to have the m a as in put?
06:16:08 <danilo2> copumpkin: yes
06:17:46 <jkarni> danilo2: fmap itself?
06:17:50 <mr-> danilo2: specialize fmap?
06:18:28 <danilo2> jkarni: its not t (ma) its t m a
06:18:34 <danilo2> mr-: What do you mean ?
06:18:58 <ArianVP> Hey I got a noob question about Hackage.
06:19:00 <mr-> danilo2: never mind.
06:19:17 <ArianVP> how come https://hackage.haskell.org/package/protobuf-0.2.0.2 has no documentation but https://hackage.haskell.org/package/protobuf-0.1.3 does?
06:19:26 <ArianVP> while in the source code there is comments in both projects?
06:19:35 <ArianVP> I've seen this happen on server occations on Hackage
06:19:38 <ArianVP> several*
06:20:13 <copumpkin> danilo2: you sure you can't restructure it not to take the monadic actions in? functions of that sort aren't very common
06:20:26 <ArianVP> ?
06:20:40 <danilo2> copumpkin: I know it looks strange, really :) In this case I need something liek that :)
06:20:45 <merijn> ArianVP: hackage does batch processing for building documentation
06:20:55 <merijn> ArianVP: It can take some time to update after a new upload
06:21:01 <copumpkin> danilo2: I'm just afraid of this being an XY problem :P
06:21:10 <merijn> ArianVP: Also, note that you can tell cabal to build local documentation when you install
06:21:11 <copumpkin> http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem
06:21:38 <danilo2> copumpkin: I know - I understand that from your first question.
06:21:48 <ArianVP> merijn: But this package was uploaded months ago.
06:22:02 <merijn> ArianVP: If the build is broken then hackage can't build docs
06:22:03 <danilo2> copumpkin: But it is really a complex thing and I do not want to waste your time explaining it :)
06:22:13 <copumpkin> then don't make it so complex! :P
06:22:17 <copumpkin> anyway, I don't know about that signature
06:22:24 <copumpkin> not sure it's possible in general, but it might be
06:22:30 <danilo2> copumpkin: Heh :)
06:22:34 <merijn> ArianVP: "cabal haddock" requires the package to compile, if the hackage machine can't build it (due to missing C dependencies or what not) docs won't be generated
06:23:06 <ArianVP> ah I see. that sucks. Wouldn't a better system be that package maintainers builds the docs?
06:23:35 <rwbarton> I don't think there are very many t for which you can write this function
06:24:48 <rwbarton> like try t = StateT s     (m a -> m b) -> (s -> m (a, s)) -> (s -> m (b, s))
06:25:02 <rwbarton> can't go from m (a, s) and (m a -> m b) to m (b, s)
06:25:27 <rwbarton> well, you can actually but probably not in the way you want
06:25:42 <evancz> Any theories on why (>>>) and (<<<) are both infixr?
06:25:43 <evancz> https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html
06:27:03 <evancz> it seems pretty surprising to me
06:28:10 <merijn> ArianVP: Maintainers can build and upload docs, but I think many are not aware or don't care enough
06:28:11 <evancz> also, the fact that (.) is infixr 9 and (<<<) is infixr 1?
06:28:39 <merijn> ArianVP: Anyway, local HTML docs and local hoogle exist, so that may be worth looking into
06:28:52 <ArianVP> merijn: Jep will defenitly do.
06:28:58 <ArianVP> Mehh I should go try NixOS
06:29:09 <ArianVP> bit hesitant because dont know if I can set up dual boot
06:29:14 <ArianVP> otherwise I might just try nix
06:32:17 <trap_exit>  programming in ahskell
06:32:18 <trap_exit> is like writing a math proof
06:32:26 <trap_exit> to happens to be executable
06:33:22 <tdammers> http://www.reddit.com/r/programming/comments/2abf2e/test_driven_program_synthesis_is_this_feasible/citdyz9
06:33:27 <tdammers> ;)
06:34:18 <Kinnison> tdammers: +1
06:35:33 <frerich> tdammers: tee-hee :)
06:36:19 <tdammers> I'm not even sure what the point is I made there
06:36:41 <SirSkidmore> with gcc-4.8 installed from homebrew, and running xcode-select --install r, then installing haskell-platform (through the pkg, not homebrew) ghci complains about libiconv being a mach-o
06:36:43 <SirSkidmore> any ideas?
06:37:24 <ReinH> tdammers: I mean, program derivation is a thing, especially in Haskell ;)
06:38:15 <tdammers> I know, but it doesn't work at such a trivial level
06:38:27 <matheus23> Does anybody know how fast harddrives are usually in terms of MB/s write and read speed?
06:38:57 <tdammers> and, more importantly, the difference between using a high-level language to program and using a high-level language to define the constraints for program derivation is really kind of arbitrary IMO
06:39:02 <donri> matheus23: internal or external? usb 2.0 or 3.0? ssd or rotating?
06:39:08 <matheus23> internal
06:39:14 <matheus23> non-ssd
06:39:17 <rwbarton> danilo2: about your question about OverlappingInstances, ghc will only pick an instance when it's not possible that specializing type variables could cause a different, more specific instance to be selected
06:39:18 <matheus23> rotating
06:39:24 <tdammers> I think my point is that programming is hard, but program derivation is also hard
06:39:39 <rwbarton> danilo2: if you don't actually care what your program does and you want to remove this condition, use IncoherentInstances
06:39:41 <em> what is the meaning of program derivation?
06:40:12 <donri> matheus23: around 150 MB/s i'd say is typical
06:40:37 <matheus23> donri: woah cracy... Good, I'm thinking about buying a 250Mb/s 256 GB Usb stick :D
06:40:44 <tdammers> em: pretty much what the blog post suggests - you write down some formal characteristics of the desired program, and the program deriver tries to find a matching program
06:40:56 <donri> matheus23: my ssd is about 1 GB/s :)
06:41:28 <matheus23> yeah, but rotating HDD is usually enough for me and a good-enough trade off for a _really_ small portable system
06:41:40 <danilo2> rwbarton: Hmm, using IncoherentInstances does not help in the example either :( I wanted to pick the second instance (in the example), because we got function (Pure a -> Pure a) and argument of type (Pure Int), so the types a and Int are "distinct" (of course can be the same), so I wanted to pick an instance, which will case them to be threat as the same type (using a1~a2).
06:41:51 <frerich> tdammers: I think your point is fairly clear; if you consider that the "x -> f(x)" mappings mentioned in that blog article can be considered a (declarative) program, then you already have your "program synthesis": it's called a "compiler" which consumes some (more or less abstract) specification and translates it to something suitable for execution.
06:41:54 <rwbarton> a could be Int
06:42:04 <rwbarton> I don't understand
06:42:08 <rwbarton> can you paste the link again?
06:42:20 <danilo2> rwbarton: the exampel does not work with IncoherentInstances either. I see the problem and I understand why it behaves like it does - I'm just looking for any solution, which can help me writing such behavior
06:42:30 <donri> matheus23: note though that you'll probably need usb 3.0 for those speeds and avoid any sort of FAT system on it
06:42:34 <rwbarton> it seems like all your problems stem from type classes
06:42:38 <rwbarton> have you considered using fewer type classes?
06:42:40 <danilo2> rwbarton: http://lpaste.net/107264
06:42:51 <tdammers> frerich: yes.
06:42:56 <donri> matheus23: also this isn't really on-topic for #haskell, perhaps #haskell-blah or i think ##hardware is a thing
06:43:17 <rwbarton> I get a different error with IncoherentInstances
06:43:19 <frerich> tdammers: I.e. the key insight is that you don't necessarily have to create a new tool to translate an abstract "x -> f(x)" style mapping to some existing langauge, because such a tool is caller a compiler and there are plenty of compilers out there. So you may as well see whether any of them (say: a Haskell compiler) can consume a language which allows expressing your "x -> f(x)" mappings concisely.
06:43:26 <danilo2> rwbarton: brb, the exampel is a little to simple, there should be one more instance to show the problem better
06:43:31 <rwbarton> No instance for (Show s0), etc.
06:43:33 <frerich> tdammers: IMHO the point is clear, so thumbs up. :)
06:43:37 <matheus23> donri: Thank you. I have trouble finding appropriate channels, thanks for pointing me to #haskell-blah :D
06:44:05 <trap_exit> in good haskell style
06:44:10 <trap_exit> how long should a *.hs file generally be ?
06:44:42 <ReinH> trap_exit: as long as it takes, but no longer. ;)
06:45:02 <danilo2> rwbarton: or its ok - If you will need, I will expand this example to a little more complicated one. Yes, you are getting error no instance for (Show s0), because IncoherentInstances pick always the first one and Iit does not work
06:45:05 <trap_exit> ReinH: how's that philosophy degree working out?
06:45:32 <rwbarton> do you mean the second one?
06:45:49 <pjdelport> trap_exit: Depends what's in it. A better question is how modular the module is: does it mix concerns, or is it relatively well-defined, easily depended on, and not with unnecessary dependencies?
06:46:12 <trap_exit> pjdelport: hmm
06:47:41 <danilo2> rwbarton: Oh maybe. The behavior I wanted to achive is as follow. To compile the line 26, the instance from 22 will be picked, which will recursively call "pipe", which will pick the instance from line 21. Is it clear now ?
06:48:17 <danilo2> rwbarton: the instance in 22 tells, that both types a1 and a2 are the same, so GHC knows it can safely pick the other instance when recursively calling pipe
06:48:25 <donri> it can also be worth considering that you tend to better default inlining inside one module and that multiple modules (and packages) can compile faster (by skipping unchanged files and building in parallel)
06:48:28 <rwbarton> wait why do you need two instances then?
06:49:28 <trap_exit> how does having lots of small modules vs a single gigantic *.hs file effect compilation time? does lots of small files (a) increase compile time, (b) decrease compile time, or (c) not effect compile time?
06:49:58 <rwbarton> oh hang on
06:50:15 <danilo2> rwbarton: heh, this example is very simplified. Shoudl I post the real one?
06:50:15 <donri> it's also easier to keep things in a few large modules by having access to internals, but on the other hand that arguably makes the code harder to refactor
06:50:22 <Ankhers> I will be running my application across multiple applications. I need to count a series of events, hundreds of thousands / sec across all machines. What would be my options to keep track of these events and sync with the different nodes at a later time?
06:50:23 <pjdelport> trap_exit: I think donri means "when you change one module and recompile"
06:50:37 <Ankhers> across multiple machines.
06:50:51 <donri> yes, but also considering the new ghc -j which can build independent modules in parallel
06:51:16 <rwbarton> danilo2: oh god no
06:51:17 <pjdelport> Ankhers: A well-administered NTP server?
06:51:29 <danilo2> rwbarton: hm? :)
06:52:18 <kqr> how can i make cabal/ghc prefer the package installed in ~/.cabal rather than project/.cabal-sandbox?
06:52:23 * hackagebot sql-simple 0.3.1 - common middle-level sql client.  http://hackage.haskell.org/package/sql-simple-0.3.1 (HirotomoMoriwaki)
06:52:45 <kqr> or rather, the bigger problem: i have a library installed from its sources in ~/.cabal, and i'd like that one to be used in project/.cabal-sandbox as well
06:54:21 <rwbarton> this is kind of interesting
06:54:32 <donri> also there are things you have to have at least two modules for, in particular TH splices have to be defined either locally (let) or come from an import
06:54:39 <rwbarton> danilo2: if you delete line 26 then the original file compiles
06:54:51 <Ankhers> pjdelport: Fair enough. I guess my question should have been more about how to do the counting of hundreds or thousands of different objects. As opposed to the syncing.
06:54:51 <rwbarton> unless I've accidentally edited it some
06:55:27 <rwbarton> but it no longer compiles with IncoherentInstances
06:55:28 <pjdelport> Ankhers: Can you define what "counting" means exactly? I'm not sure what the questions means.
06:56:06 <pjdelport> What's the input and output of the problem?
06:56:32 <danilo2> rwbarton: yes, I know
06:56:56 <danilo2> rwbarton: yes, you are right. It does not work with line 26!
06:57:03 <danilo2> rwbarton: and this is a problem
06:57:44 <rwbarton> well, it's not my problem, sorry :)
06:57:53 <rwbarton> I guess the changing OverlappingInstances to IncoherentInstances thing is not a bug
06:58:22 <rwbarton> the documentation seems to indicate IncoherentInstances lets the compiler pick an arbitrary matching instance
06:58:28 <rwbarton> I suggest you not write programs in this style
06:58:29 <danilo2> rwbarton: of course :) But I do not want to use IncoherentInstances there :) I was just trying to write thesei nstances using only Overlapping and Undecidable ones
06:59:17 <danilo2> rwbarton: If you enable line 26, then GHC tries to choose the instence from 22 (the one from 21 is not matched). But somehow it does not sees it is recursive instance and it is matched then against 21
06:59:47 <Ankhers> pjdelport: I am building a bidder. When an auction opens, they ping me with the information. I need to decide whether or not I want to buy whatever is being sold. If I buy, win or lose, I want to keep track of that. This bidder will have multiple "accounts". I want to keep track of the bid win / lose against those accounts. There are potentially thousands of different counters that I would need to track.
07:00:48 <Ankhers> I'm wondering what my options are to track such large amounts of data. The sync between various nodes I can do easily.
07:01:07 <pjdelport> Ankhers: How does the bidding communication works? Are the accounts on different machines?
07:01:30 <Ankhers> pjdelport: No. Every machine will have to know about every account.
07:01:41 <pjdelport> What data is represented exactly, and what makes it large?
07:02:15 <pjdelport> And how are you syncing them; is it already in some storage backend?
07:03:44 <Ankhers> I just need to track the account id, the number of bids, and the number of wins. I say large because it needs to handle, across all machines, hundreds of thousands of transactions / second. I was originally thinking of spawning a thread for each request, and throwing the data into redis or something to track. But I thought that may be very expensive to do for every transaction.
07:04:54 <Ankhers> For syncing. I was going to take the data and throw it in some database every X minutes.
07:07:19 <pjdelport> Ankhers: Hmm, syncing the DB between machines is probably going to be a much, *much* harder problem than the local transaction rate.
07:07:49 <pjdelport> I think the intuition that the syncing is easy might be off.
07:08:32 <Algebr> Did haskell-mode make a big change recently in how it handles interactions with ghci?
07:09:27 <Ankhers> yes
07:09:32 <Ankhers> Algebr: ^^
07:09:36 <kqr> kvanb, "i" fixed linking problem with unix-time, if you're curious
07:10:07 <kqr> kvanb, apparently there was an issue of it on the repo for unix-time, and the latest commit (10 hrs ago) fixed it
07:10:19 <Algebr> Ankhers: yes, I'm having a hard time getting a repl up and running. Apparently its not interactive-haskell-mode? The inferior mode says deprecated.
07:10:20 <kqr> kvanb, so i just needed to run the head from git instead of the hackage version and it seems to work!
07:10:43 <Algebr> Ankhers: Did you have to add some haskell-mode hooks in your .emacs?
07:10:46 <Ankhers> Algebr: You can continue to use that mode if you want. But yes, it is deprecated.
07:11:21 <Ankhers> Algebr: You need to specify which of interactive mode you want to use.
07:11:34 <Ankhers> Something like: (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
07:11:34 <Ankhers>  
07:11:41 <Ankhers> I'm using the more recent once.
07:13:22 <Ankhers> pjdelport: You might be right. But one step at a time. I don't know how I should go about holding and tracking this data in Haskell.
07:14:03 <pjdelport> Ankhers: It's hard to give any kind of recommendation without knowing more specifics... the above details probably raised more questions than it answers.
07:14:04 <Ankhers> Algebr: There is also #haskell-emacs where you can go for help.
07:15:26 <Ankhers> pjdelport: Alright. Thanks for the help.
07:15:29 <pjdelport> Ankhers: One architecture that comes to mind, if your accounts are independent, is to partition your accounts across multiple machines, and just route the auctions to them.
07:16:33 <Ankhers> Unfortunately, there is not way beforehand to know which account the auction should go to.
07:16:56 <pjdelport> Ankhers: But that's making a lot of assumptions about how the auctioning process works. You may have to write down that protocol somewhere, to have a starting point for discussion?
07:17:53 <pjdelport> Ankhers: If any account can bid on the auction, you could fan out the auctions, and just have the account nodes just send bids for the auctions they're interested in.
07:20:32 <Ankhers> pjdelport: That could potentially work. I will need to think about that. Thanks. As for the protocol, I wouldn't expect someone to look at a 90 page document explaining it.
07:21:03 <pjdelport> Ankhers: Well, just a sketch of its semantics, at least. :)
07:21:29 <Ankhers> pjdelport: Fair enough. If I have more questions, I may do that.
07:21:59 <pjdelport> For a transaction rate in the hundreds of thousands per second, though, you'll probably need to partition and fan it out like that, though.
07:23:18 <pjdelport> Ankhers: You may want to investigate distributed message buses like RabbitMQ as the backbone for something like this.
07:23:46 <kvanb> kqr: heh
07:23:52 <Ankhers> pjdelport: I will. Thanks.
07:24:14 <kvanb> nomeata: hi, wanna talk about that ticket?
07:25:01 <nomeata> kvanb: are you schyler?
07:25:13 <kvanb> yes
07:25:28 <nomeata> sure (but I have to go in 10 minutes)
07:25:41 <kvanb> oh okay, I have to go to sleep anyway
07:25:51 <kvanb> your reply explains your concerns well enough
07:26:49 <eacameron> Is there a library that allows me to write approximately ("str" # int) and get a partial `Int -> String`?
07:27:19 <nomeata> kvanb: ok
07:27:36 <eacameron> so I can build up string formats and then work them back down to actual strings as I apply args?
07:27:43 <phaazon> is sqlite easily ‚Äúpluggable‚Äù to a happstack server?
07:28:30 <eacameron> and possibly even compose things to "int" to do specail processing, like ("str # (round . int))
07:28:49 <eacameron> (I suppose "round" doesn't make much sense in that context, but you get the idea)
07:29:32 <pjdelport> eacameron: Something like https://hackage.haskell.org/package/formatting perhaps?
07:29:51 <pjdelport> https://github.com/chrisdone/formatting <- examples
07:30:11 <eacameron> pjdelport: Yes, actually, that is very close to what I'm looking for; but I can't pass formats directly to other things that just take (Int -> String)
07:30:26 <eacameron> or can I +
07:30:26 <eacameron> ?
07:32:05 <sveit> i have two small speed questions. first: suppose i have to sort a list by the same permutation many times, i.e. with permutation p and list l i would do (unzip . snd . sortBy (comparing fst) . zip P) l . the other option is to build an "inverse" permutation p' such that i can just do (after building it) map (l !!) p'. which is faster?
07:32:06 <merijn> eacameron: Well, it should be pretty easy to write a convenient quasiquoter
07:32:57 <pjdelport> eacameron: I haven't used the library myself, but i think you can
07:34:41 <pjdelport> eacameron: That is, format (int % "!") should give you the equivalent of \n -> show n ++ "!"
07:35:04 <pjdelport> (except with the int formatter's semantics, etc.)
07:35:06 <phaazon> sveit: I‚Äôd say the first one
07:35:16 <phaazon> map (p !!) sounds terrible to me
07:35:36 <phaazon> whereas unzip + zip sounds faster
07:36:33 <sveit> phaazon: but with the sorting still? with the first implementation i'm sorting every time, whereas with the second i only sort once? of course i'm aware (l !!) is quite bad, so that's why i'm asking
07:36:39 <pjdelport> sveit: If you know your permutation is unique, sortBy (comparing fst) is equivalent to just sort
07:37:18 <sveit> pjdelport: oh cool. that shouldn't affect the speed though, right? :)
07:37:19 <pjdelport> sveit: If you're working with permutations a lot, maybe Array is better?
07:37:38 <sveit> pjdelport: well thing is they're short. no more than 5 elements ever.
07:37:50 <pjdelport> Oh, then !! isn't really bad either.
07:38:35 <sveit> pjdelport: this is completely a micro-optimization, that's why i'm asking here :) it's a short list so !! shouldn't kill me, and i'm wondering whether the sort or the !! is worse
07:38:53 <pjdelport> sveit: That's low enough that constant factors might dominate; you might want to benchmark both methods to see.
07:39:14 <pjdelport> sveit: If you're micro-optimizing, you *definitely* should already be benchmarking :)
07:39:35 <pjdelport> sveit: Are you using criterion?
07:39:39 <sveit> pjdelport: and for short collections like that you agree that going to array/vector is probably worse than list, right?
07:39:47 <sveit> pjdelport: starting to, but i'm still getting the hang of it
07:39:58 <pjdelport> sveit: It shouldn't be worse than list, no, but it might also not be significantly better.
07:40:07 <ReinH> You should benchmark.
07:40:10 <ReinH> Not guess.
07:40:41 <pjdelport> But yeah, this will depend on many other factors; you have to benchmark.
07:41:50 <sveit> ok. is there an (easy?) way to get criterion to benchmark not just the main function being called but the functions that function calls as well?
07:43:36 <cgroza> Hi, I am trying to configure haskell-mode for emacs, but I get an error when I do (load-library 'haskell-site-file) . Also, this file does not exist in the haskel-mode directory. I am using Archlinux. What should I do?
07:44:24 <pjdelport> sveit: Criterion measures the total time to apply the function against the specified parameter.
07:45:11 <pjdelport> sveit: You can specify how much the result should be evaluated; fully NF, or WHNF, or something in between.
07:45:49 <pjdelport> sveit: So it will measure however function calls are involved for the level of evaluation you specify
07:45:58 <pjdelport> s/however/whichever/
08:00:00 <ReinH> sveit: you can also use GHC's built-in profiling to measure the cost centers
08:00:09 <ReinH> Or, as the GHC manual calls them, "cost centres".
08:02:19 <sveit> one more question i should probably profile to know the answer to, is it better to use foldl' to build lists backwards and reverse or to just append inside the foldl'? and a specific case: i'm trying to do cumulative products of the elements of a list, i.e. [1,2,3] -> [1, 1*2, 1*2*3]
08:03:04 <sveit> that's embarrassing, just saw scanl and friends, but my first question still holds
08:10:10 <bennofs> sveit: building list backwards and reversing is probably faster, because append is O(n) alone (vs cons which is O(1))
08:11:54 <bennofs> > foldl1' (**) [a,b,c,d,e]
08:11:56 <lambdabot>  (((a**b)**c)**d)**e
08:13:34 <bennofs> sveit: if ** was ++, then to evaluate (a ++ b), the whole list a has to be traversed. Then, to evaluate (a ++ b) ++ c, (a ++ b) must be traversed and so on. You see that the lists that have to be traversed for append get longer each time (because of the left associativity)
08:13:57 <phaazon> what would be the SQL type equivalent for ByteString?
08:14:00 <phaazon> Byte ?
08:14:09 <phaazon> Byte(256), for instance?
08:14:20 <phaazon> BIT VARYING, I guess
08:14:51 <mokkake> hi, just wrote a little grep script, don't know why, it seems to infinitly loop: http://pastebin.archlinux.fr/519795
08:15:03 <mokkake> does someone know why ?
08:16:06 <merijn> mokkake: Not an answer, but ">>= return . intercalate "\n"" <- this is just fmap
08:16:24 <merijn> mokkake: Really anything written ">>= return . f" is just fmap
08:16:49 <bennofs> mokkake: subsequences does more than you want
08:16:54 <bennofs> > subsequences "abcdef"
08:16:56 <lambdabot>  ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","a...
08:17:19 <mokkake> merijn: okay, thanks didn't know i could use fmap in Monad context
08:17:21 <rwbarton> @hoogle isInfixOf
08:17:21 <bennofs> Note that "ad" is also an element of that list, yet grep "ad" "abcdef" should not return anything
08:17:23 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:17:23 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
08:17:23 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
08:17:41 <mokkake> lambdabot: ok, thanks
08:17:55 <pjdelport> mokkake: Monad is basically just Applicative + join
08:18:40 <pjdelport> mokkake: For just fmap/<$>, ap/<*>, and pure/return you don't need Monad.
08:18:43 <merijn> mokkake: Theoretically (and starting with GHC 7.10 also practically) every monad is a functor
08:18:49 <merijn> mokkake: See these two: http://lpaste.net/107270
08:18:55 <merijn> mokkake: FYI, liftM == fmap
08:18:57 <merijn> :t liftM
08:18:58 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
08:19:00 <merijn> :t fmap
08:19:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:16 <bennofs> mokkake: intercalate "\n" is just unlines
08:19:36 <mokkake> yea, i get it
08:19:48 <mokkake> thanks
08:20:00 <merijn> bennofs: oh, good catch
08:20:36 <merijn> Not sure why it doesn't terminate, though
08:21:23 <mokkake> I¬†guess that used on big files, it takes to much to compute because of subsequences
08:25:21 <merijn> mokkake: oh
08:25:35 <merijn> mokkake: This will suck on any file other than really small
08:25:59 <magicman> > "ac" `elem` subsequences "abc" -- and there's this.
08:26:00 <merijn> mokkake: If you were using this on big files it's probably not that it didn't terminate, but that it just took minutes to complete
08:26:00 <lambdabot>  True
08:26:03 <mokkake> merijn: yea, i guess so. This is just for learning
08:26:24 <merijn> mokkake: String's performance really sucks, if you wanted to do something like an actually efficient grep you'd use Text
08:26:46 <mokkake> merijn: isn't Bytestring fine too ?
08:27:32 <Clint> mokkake: depends how unicode-aware you want your grep to be
08:28:32 <mokkake> Clint: as i said, this is just a exercise grep
08:29:13 <merijn> mokkake: ByteString has a different use case than Text
08:29:51 <merijn> mokkake: ByteString is, despite what the name for historical reasons implies, all bytes and no string
08:30:17 <merijn> mokkake: ByteString == densely packed bytes, Text == densely packed unicode text
08:31:01 <albeit> I'm placing Text values in a chan to be consumed later. How can I force the Text to be completely "unthunked" before its placed in the chan? (It will be 100% be used later, so unthunkily lazily later doesn't help)
08:31:22 <mokkake> just for instance, "main :: IO ()" -> does IO () here is at first Functor IO and then using (>>=) "casts" it to Monad IO ?
08:31:25 <mokkake> not sure i got it
08:32:01 <merijn> mokkake: No
08:32:01 <Iceland_jack> mokkake: You're thinking about it a bit wrong, IO is an instance of both Functor and Monad
08:32:12 <ajcoppa> IO is an instance of both the Functor typeclass and the Monad typeclass
08:32:14 <merijn> mokkake: IO is both a functor and a monad, so both functions work on IO
08:32:31 <Iceland_jack> but 'main' is just 'IO ()' nothing to do with Functor and Monad in particular, regardless of if you use (>>=) or fmap or what ever
08:32:44 <mokkake> Iceland_jack: whaat
08:33:14 <moghedrin> Hmmmm. Couldn't match expected type "vty-4.7.5:Graphics.Vty.Attributes.Color.Color" with actual type "Color". How would I resolve that?
08:33:26 <mokkake> my brain
08:33:59 <Iceland_jack> mokkake: You don't really have to think about it to use it
08:34:11 <simcity2000> anybody have any experience with HDBC-ODBC and MS SQL server?
08:34:31 <simcity2000> or just HDBC in general
08:34:37 <mokkake> Iceland_jack: no, i want to understand. gonna read some doc
08:34:59 <Iceland_jack> mokkake: (>>=) requires a Monad constraint, right?
08:35:06 <Iceland_jack> @ty (>>=)
08:35:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:35:24 <zwer> mokkake there's no limit of how many typeclasses a type can be an instance of. take a Char for example, it has an instance of Eq, Ord, Show and a bunch of other typeclasses
08:35:26 <mokkake> yea okay, that's what i missed: data IO a
08:35:29 <Iceland_jack> but you can also pick 'm' to be IO
08:35:42 <Iceland_jack> @ty (>>=) :: IO a -> (a -> IO b) -> IO b
08:35:43 <lambdabot> IO a -> (a -> IO b) -> IO b
08:35:48 <mokkake> and then instance Monad IO, Functor IO
08:36:11 <mokkake> Iceland_jack: yes, i get that
08:36:39 <Iceland_jack> mokkake: Right, so you can define main as
08:36:39 <Iceland_jack>     main = getLine >>= putStrLn
08:36:45 <Iceland_jack> and it's going to have type IO ()
08:36:45 <Iceland_jack> @ty getLine >>= putStrLn
08:36:46 <lambdabot> IO ()
08:36:59 <Iceland_jack> The type doesn't mention Monad
08:37:45 <simcity2000> mokkake: what are you having trouble with?
08:38:00 <mokkake> but in another function than main it could right, in the type constraint
08:38:07 <mokkake> simcity2000: my brain ?
08:38:14 <simcity2000> mokkake: fair enough
08:38:15 <Iceland_jack> mokkake: sure, (>>=) is an example of such a function
08:38:31 <mokkake> yea, got it
08:38:32 <simcity2000> mokkake: (>>=) isn't fixed to any specific monad
08:38:39 <Iceland_jack> then GHC just 'picks' m = IO
08:38:40 <simcity2000> getLine and putStrLn are both IO actions, though
08:38:42 <zwer> main is not a function by the way
08:38:44 <simcity2000> @ty getLine
08:38:45 <Iceland_jack> and (>>=) no longer mentions Monad
08:38:45 <lambdabot> IO String
08:38:50 <Iceland_jack> @ty (>>=)
08:38:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:38:52 <Iceland_jack> @ty (>>=) getLine
08:38:54 <lambdabot> (String -> IO b) -> IO b
08:39:21 <moghedrin> Okay. How do I list an installed package's dependencies?
08:39:43 <rwbarton> ghc-pkg describe
08:39:47 <shlevy> Can I dlopen haskell shared libraries?
08:39:49 <moghedrin> rwbarton: Thank you :D
08:40:19 <merijn> shlevy: If you use the foreign function interface to export symbols it should just work, I think?
08:40:28 <shlevy> Well, obviously I *can*. What I mean is, is there a good way to do so without having to know how ghc mangles symbols?
08:40:29 <simcity2000> mokkake: are you chewing on monads in general, parameterized types, all, none, something else?
08:40:34 <rwbarton> you certainly can dlopen them, what happens next is the question :)
08:40:49 <rwbarton> what are you really trying to do?
08:40:55 <bennofs> shlevy: foreign export
08:40:56 <mokkake> simcity2000: i'm not anymore, thanks
08:40:56 <shlevy> Ah for clarification I want to load haskell code into a haskelll process
08:40:58 <joshc> albeit: Data.Text is strict by default, IIRC...not sure if that helps you
08:41:04 <shlevy> rwbarton: Plugin architecture
08:41:18 <merijn> shlevy: oh, that's a can of worms you're opening there :p
08:41:29 <rwbarton> there is something in the GHC API for this
08:41:30 <merijn> shlevy: dons used to have a paper on that, but my link to it is stale
08:41:57 <simcity2000> mokkake: cool cool
08:42:13 <simcity2000> back to what I was originally wondering--has anybody here worked with HDBC?
08:42:19 <mokkake> so, knowing that, i could define my own class, create an IO instance of it, and use it in main right ?
08:42:48 <simcity2000> mokkake: you don't need to create an IO instance of the class unless it's doing IO things
08:43:21 <mokkake> simcity2000: yes, but in theory, i could
08:43:36 <simcity2000> yes
08:43:40 <simcity2000> @ty f x = return x :: IO Int
08:43:41 <lambdabot> parse error on input ‚Äò=‚Äô
08:43:51 <simcity2000> oh, oops
08:43:53 <simcity2000> that didn't work
08:44:12 <mokkake> no i don't mean "instance IO Int". I mean instance "Newclass IO"
08:44:19 <mokkake> like Functor IO
08:44:52 <simcity2000> like a class that has a monad (or specifically IO) as a type parameter?
08:44:57 <mokkake> yes
08:45:05 <Iceland_jack> mokkake: Sure
08:45:17 <simcity2000> yeah, and that's used in some modules actually
08:45:19 <mokkake> oh, it has to mention (Monad m) ?
08:45:28 <simcity2000> mokkake: not if you specify IO
08:45:29 <Iceland_jack> mokkake: not unless it's using the fact that it's a Monad
08:45:52 <mokkake> okay. Fascinating
08:45:59 <Iceland_jack> you can do
08:45:59 <Iceland_jack>     class Boring m where
08:45:59 <Iceland_jack>       boring :: m a -> m a
08:46:09 <Iceland_jack> and declare
08:46:09 <Iceland_jack>     instance Boring IO where
08:46:09 <Iceland_jack>       boring x = x
08:46:45 <mokkake> okay, i get it
08:46:53 <simcity2000> mokkake: Data.Random makes use of monad parameters with instances for IO if you're curious about what that sort of thing looks like
08:46:54 <mokkake> my brain is back in place
08:46:54 <simcity2000> http://hackage.haskell.org/package/random-fu-0.2.3.1/docs/Data-Random.html#t:MonadRandom
08:47:44 <mokkake> yes, that's why it "contaminates" the function with IO
08:47:46 <simcity2000> Data.Random is also kind of a mess and changes a lot, but the point is people do this sort of thing
08:48:22 <simcity2000> mokkake: the idea (I think) is more that you can define the source of entropy that will be used in a given monad
08:48:35 <simcity2000> so if you're using a MonadRandom IO, you're basically saying you're pulling entropy in from the outside world
08:49:34 <mokkake> yea
08:49:50 <simcity2000> but you can define those instances to suit your own needs
08:51:14 <mokkake> damn haskell is fascinating
08:51:56 <simcity2000> it is; I've been trying to use it more as a tool for work than like a cool language and it's been working well
08:52:34 <simcity2000> non-strict evaluation and pure functions make things like parallelism dirt simple to get running
08:53:15 <mokkake> simcity2000: yes, but it's quite a mess when you don't understand all the pieces
08:53:46 <simcity2000> mokkake: right...I think that's more a function of there being a problem where part of the Haskell community likes it as a language, and part likes it as a tool
08:53:46 <mokkake> damn, my boss would never let me write soft in haskell
08:55:44 <simcity2000> mokkake: better to try your own hand at it and see if the language does what you need
08:56:45 <mokkake> simcity2000: i've been using it for quite a long time actually. XMonad, yi, also wrote a Conway's Lifegame (which doesn't work haha)
08:57:05 <simcity2000> mokkake: nice!
08:57:40 * hackagebot unordered-containers 0.2.5.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.5.0 (JohanTibell)
08:58:07 <mokkake> i'd really like to see haskell used more in the future
08:58:12 <simcity2000> mokkake: I think the perception of there being some massive and unfriendly learning curve to Haskell is kind of unwarranted
08:58:32 <ReinH> simcity2000: yeah, it isn't that unfriendly.
08:58:54 <simcity2000> I think a lot of explanations from the community wind up suffering from a curse of knowledge, though
08:58:55 <mokkake> simcity2000: coming from OOP, it is
08:59:31 <simcity2000> mokkake: I'm thinking more with respect to C and other mid-low level languages
08:59:53 <simcity2000> but even with Java I had a pretty grueling time wrapping my head around some of the weirder software patterns people chuck around
09:00:52 <mokkake> you don't say‚Ä¶
09:01:01 <simcity2000> I think it's easy to understand how Haskell works once you have a context for the way it works
09:01:20 <simcity2000> and what I think most learning materials for the language fail to provide is exactly that context
09:01:36 <mokkake> simcity2000: do you think haskell can be used for any software ?
09:01:49 <mokkake> yes, it's quite a lot of theory
09:02:30 <simcity2000> mokkake: I think that the language itself can be used just fine for pretty much anything. Facebook just released Haxl, which is a Haskell module for data access
09:02:54 <simcity2000> regarding the theory issues, that's absolutely true. I think it's the same with C in a lot of ways
09:03:02 <simcity2000> monads:Haskell::pointers:C
09:03:49 <mokkake> I actually started learning haskell with a language rewrite in C
09:03:57 <MP2E> simcity2000 : I don't see the resemblence
09:04:04 <mokkake> it fits pretty well, unless for Polymorphism
09:04:15 <simcity2000> MP2E: there is no similarity in terms of what the two do
09:04:17 <mokkake> which is very confusing to write in C
09:04:43 <simcity2000> MP2E: I think pointers as a concept trip up a lot of people when they get into C from a higher-level language, or as a first language
09:05:58 <simcity2000> mokkake: polymorphism in C...?
09:06:14 <bitraten> hi, how can i get a sublist with only these indices from a list of indices, [Int] -> [a] -> [a] ?
09:06:25 <mokkake> simcity2000: this is doable
09:06:36 <mokkake> with macros
09:07:20 <simcity2000> mokkake: doable as in enjoyable, or doable as in performing surgery on yourself?
09:07:31 <pjdelport> bitraten: map (xs !!) is
09:07:39 <bennofs> simcity2000: doing c is already perfoming surgery on yourself
09:07:42 <mokkake> simcity2000: this is not enjoyable at all, i confess it
09:08:30 <simcity2000> bitraten, pjdelport: map (xs !!) is will run slowly
09:09:08 <pjdelport> Right; if do a lot of that, you want an Array or similar.
09:15:54 <glguy> bitraten: If you don't care what order you get the elements back you can do it somewhat efficiently
09:16:41 <bitraten> glguy: Well, I have to identify the elements by the index
09:17:39 <glguy> e.g. if:    indexes [1,5,3] "example"    can be    "xml"
09:17:42 * hackagebot postgresql-simple 0.4.3.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.3.0 (LeonSmith)
09:20:06 <bitraten> glguy: I am analyzing a csv file and need only specific columns, but i need to now which is which
09:21:17 <triliyn> You could annotate them with their index if you need them in exotic orders
09:21:29 <triliyn> Or only call the function with the [Int] argument in order
09:21:53 <simcity2000> bitraten: I'm working on it
09:22:07 <bitraten> yeah, the [Int] argument will always be in order
09:23:24 <triliyn> In that case, you can walk through the list once, keeping track of which position you're at
09:23:38 <triliyn> And take elements when you reach the next position in the int list
09:23:49 <simcity2000> triliyn: that's what I've been running with
09:23:55 <simcity2000> it's a fun exercise though
09:24:44 <triliyn> Right :)
09:25:59 <StolenToast> window 12
09:26:58 <simcity2000> bitraten: https://gist.github.com/jnschaeffer/f5d699b5e9122697d9d6
09:29:10 <simcity2000> bitraten: I'm not sure if that covers all cases, and I'm sure you could make it prettier if you wanted to, but it works enough
09:31:44 <bitraten> simcity2000: thanks! in my case it's 0m1.808s with the simple approach vs 0m1.480s with your code :)
09:35:05 <simcity2000> bitraten: sounds like the simpler one is better then!
09:35:33 <simcity2000> if it's for a CSV with only a few (or a few tens of) columns there's no need to overengineer things
09:39:04 <bitraten> simcity2000: 193291 lines with 121 columns each, but it's quite fast, so I'm happy
09:39:51 <simcity2000> bitraten: the O(n^2) performance of map (xs !!) is winds up being nothing for that
09:39:56 <simcity2000> especially if your index list is small enough
09:40:02 <simcity2000> but I guess you already found that out
09:42:45 * hackagebot binary-typed 0.1.0.1 - Type-safe binary serialization  http://hackage.haskell.org/package/binary-typed-0.1.0.1 (quchen)
09:43:21 <jfischoff> I‚Äôm trying to get better thread utilizaiton out of a program. The issue is sometimes when a GC is requested, the thread that prints to stdout does not yield for several milliseconds, but all the others do. Why?
09:46:45 <mbrock> hm, an Applicative instance for IO (IO a): http://lpaste.net/107275
09:47:38 <mbrock> is this a known pattern? it's like a two-step action...
09:47:59 <simcity2000> mbrock: I've never seen IO (IO a) before
09:48:01 <rwbarton> any monad is applicative, and any composition of applicatives is applicative, I think that's what you've got going on there
09:48:06 <rwbarton> from a formal point of view
09:48:17 <Zekka> mbrock: That sounds like the sort of thing you could get out of using fmap when you mean to use (>>=)
09:48:50 <Zekka> If my code was full of IO (IO a)s I'd probably try and figure out whether I should be joining where I'm not joining and binding where I'm fmapping
09:49:48 <mbrock> example: do { v <- newMVar; forkIO (computeInto v); return (readMVar v) }
09:50:07 <mbrock> that's an IO (IO HeavyComputationResult)
09:50:39 <Zekka> mbrock: I'm a little confused, why not just result in readMVar v without the extra return?
09:50:44 <pjdelport> :t let (<<$>>) = (<$>) . (<$>) in (<<$>>)
09:50:44 <pjdelport> :t let (<<*>>) = liftA2 (<*>) in (<<*>>)
09:50:45 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:50:45 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
09:50:56 <pjdelport> mbrock: -^
09:51:15 <mbrock> Zekka: I don't want to block on the MVar immediately
09:51:30 <rwbarton> Zekka, so that you can do other things on the original thread in the meantime
09:51:34 <rwbarton> it's like a "spawn"
09:51:49 <rwbarton> when you want to "join", you run the (IO a) that was returned
09:52:06 <Zekka> Oh, you're right: sorry, concurrent/parallel programming's something I'm not great at reasoning about given that it doesn't show up that much in the types
09:52:26 <mbrock> yeah, I spent all day mucking around with various attempts at implementing futures/promises/whatever
09:52:32 <mbrock> and ended up with this simple IO (IO a) stuff
09:52:32 <Zekka> That seems like a pretty legitimate usecase for IO (IO a).
09:52:49 <mbrock> pjdelport: nice!
09:52:53 <Zekka> I'd probably either typesynonym it or newtype wrap it
09:53:05 <simcity2000> mbrock: if you're interested in concurrency in Haskell there's a really good book out there
09:53:17 <simcity2000> there are already monads and modules for parallelism and concurrency
09:53:24 <pjdelport> simcity2000: IO (IO a) happens all the time, actually
09:53:46 <simcity2000> pjdelport: interesting; I guess I'd just look at it and assume I was doing something wrong
09:54:06 <Zekka> It's kind of unfortunate but this looks like the case where joining too early would introduce subtle bugs that the type don't tell you about
09:54:14 <Zekka> types don't*
09:54:27 <mbrock> yeah, I called it Delayed, and used a newtype so I can provide the Applicative instance, which lets me build up "delayed" structures out of IO (IO a) building blocks, sort of...
09:54:45 <simcity2000> I can see where IO (IO a) would imply "do this action, which will later on do the new action"
09:55:00 <pjdelport> simcity2000: Consider "getLine :: IO String" and "length <$> getLine :: IO Int"
09:55:41 <simcity2000> pjdelport: right
09:55:52 <pjdelport> simcity2000: You can read getLine's IO String type as a "future String"; and length <$> lifts length into that future to give you a "future Int".
09:56:10 <simcity2000> right right, I'm with you
09:56:26 <pjdelport> simcity2000: Now consider what happens when you want to *print* the string: putStrLn <$> getLine :: IO (IO ())
09:57:31 <pjdelport> simcity2000: Now you've lifted putStrLn into getLine's "future", to get a "future future ()", or in other words, a future action that returns a following future action that finaly returns a ()
09:57:42 <simcity2000> pjdelport: right
09:57:47 * hackagebot unagi-chan 0.1.0.1 - Fast and scalable concurrent queues for x86, with a Chan-like API  http://hackage.haskell.org/package/unagi-chan-0.1.0.1 (BrandonSimmons)
09:58:10 <jfischoff> is omit-yields documented? I didn‚Äôt see it here: https://www.haskell.org/ghc/docs/7.8.2/html/users_guide/flag-reference.html
09:58:30 <pjdelport> simcity2000: So how do you sequence the two actions, to get something that runs the first (outer) action, and then the second (inner) one that the first produces, as one action? join
09:58:50 <pjdelport> :t join $ putStrLn <$> getLine
09:58:51 <lambdabot> IO ()
09:58:55 <jfischoff> it is in head at least: https://github.com/ghc/ghc/blob/1c0b5fdc9f2b6ea8166cc565383d4cd20432343c/compiler/main/DynFlags.hs#L2681
09:58:58 <Zekka> So right, you just have to join them and feed the result into your chian
09:58:59 <Zekka> chain*
09:59:28 <thoughtpolice> jfischoff: it's been around for a while
09:59:30 <Zekka> join turns "future future result" into "future result" and feeding it into your chain turns it into "result you can do things to by binding"
09:59:34 <thoughtpolice> it's only listed in the overall flags section, IIRC
09:59:54 <Zekka> (e.g. actually *does* it at some point)
09:59:56 <pjdelport> simcity2000: So, in other words, "f =<< x" is just a shortcut for "join $ f <$> x"
10:00:03 <Zekka> pjdelport: You got it!
10:00:12 <simcity2000> pjdelport: very interesting
10:00:22 <jfischoff> thoughtpolice: where‚Äôs that?
10:00:24 <Zekka> f >>= x = join (fmap f x)
10:00:39 <Zekka> You can define any monad in terms of fmap/join/return
10:00:42 <simcity2000> though I'm a bit stuck on why putStrLn <$> getLine yields IO (IO ()) and not IO ()
10:01:00 <simcity2000> that's probably me being stuck on <$>
10:01:03 <Zekka> (Likewise, going the other way: join x = x >>= id)
10:01:12 <pjdelport> simcity2000: Same reason length <$> getLine yields IO Int and not Int
10:01:18 <Zekka> simcity2000: putStrLn turns a String into an IO ()
10:01:22 <Zekka> getLine is an IO String
10:01:34 <Zekka> So replace the String in IO (using <$>) with IO (), and get IO (IO ())
10:02:44 <pjdelport> :t (<$>)
10:02:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:02:47 <simcity2000> Zekka, pjdelport: right, I forgot fmap takes (a -> b)
10:02:48 <Iceland_jack> (<$>) is just fmap btw
10:02:51 <thoughtpolice> jfischoff: oh, maybe it's only in 7.8.3, i can't remember. i mostly just use HEAD ;P
10:02:54 <thoughtpolice> jfischoff: https://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
10:02:59 <thoughtpolice> ctrl+f 'omit-yields'
10:03:11 <thoughtpolice> it could probably be mentioned somewhere else in the manual. i could have sworn this was in 7.6.3 though
10:03:25 <thoughtpolice> but apparently not
10:03:26 <Zekka> simcity2000: Just being clear, (<$>) is just infix fmap
10:03:26 <pjdelport> simcity2000: So for length <$> getLine, that becomes: (String -> Int) -> IO String -> IO Int
10:03:29 <simcity2000> maps some function over the functor blah blah
10:03:34 <simcity2000> Zekka: yeah, I remember
10:03:41 <simcity2000> so yeah, that all makes sense! it's really neat
10:03:54 <pjdelport> simcity2000: and for putStrLn <$> getLine, that becomes: (String -> IO ()) -> IO String -> IO (IO ())
10:03:57 <simcity2000> pjdelport: and for--right
10:04:33 <pjdelport> somenick: So basically, *all* monadic IO is just the appropriate fmaps, followed by the appropriate joins
10:04:52 <Zekka> pjdelport: All monadic anything
10:05:00 <Zekka> @src (>>=)
10:05:01 <lambdabot> Source not found. Maybe you made a typo?
10:05:06 <Zekka> oh, they probably wouldn't have that
10:05:24 <Zekka> but for all monads: f >>= x = join (fmap f x)
10:05:25 <pjdelport> somenick: You could compose an entire program just using fmap, ending up with a huge nesting of IO's (one for each time the construction of an IO action depends on the result of another IO action)
10:05:32 <pjdelport> err, s/somenick/simcity2000/
10:05:35 <Zekka> join x = x >>= id
10:05:43 <mbrock> here is another example of the IO (IO a) stuff, now using Applicative: http://lpaste.net/107277
10:05:52 <jfischoff> thoughtpolice: I see, I guess I assumed all flags would be in the flag reference section
10:05:59 <pjdelport> simcity2000: And then in a separate pass, apply the appropriate number of joins to sequence all those delayed actions into a single compound action.
10:06:01 <simcity2000> pjdelport: don't do anything until you can do everything!
10:06:09 <simcity2000> right, exactly
10:06:12 <simcity2000> it's really cool
10:06:26 <pjdelport> somenick: So that's why join is the actual sequencing operator, for IO
10:06:45 <pjdelport> sorry, simcity2000
10:06:51 <simcity2000> haha
10:06:51 <Zekka> I don't know if it's fair to say 'actual sequencing operator'
10:06:59 <jfischoff> thoughtpolice: besides not allocating, what are other reasons a thread cannot be interrupted by a GC request?
10:07:05 <Zekka> >>= is a sequencing operator as much as join is
10:07:23 <Zekka> Althoguh I guess you could argue that >>= is 'fmap plus actually do it' where 'actually do it' is join
10:07:54 <pjdelport> Zekka: join is the fundamental one; bind is fmap + join, in that sense
10:08:26 <simcity2000> @ty join fmap
10:08:27 <lambdabot> (b -> b) -> b -> b
10:08:48 <simcity2000> @ty (>>=)
10:08:49 <pjdelport> simcity2000: This is also what people mean when they talk about a monad being a "monoid in the category of endofunctors (etc.)"
10:08:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:09:01 <Zekka> @ty \f x -> join (fmap f x)
10:09:03 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
10:09:15 <simcity2000> Zekka: there
10:09:41 <Zekka> I got the argument order backwardds, silly me, but that's (=<<) (flipped >>=)
10:10:21 <pjdelport> simcity2000: You can think of join as being the monoid operator, and it's associative in the sense that if you have for example a three-level IO action, like IO (IO (IO r)))
10:10:49 <Ainieco> hello
10:10:56 <pjdelport> simcity2000: then it doesn't matter whether you join the outer two layers first, or the inner two layers first, before joining the remainder: both orders give you the same result.
10:11:00 <haasn> Which one you take as ‚Äúfundamental‚Äù is a bit flexible
10:11:03 <Ainieco> is there time library with Random instances for its time types?
10:11:05 <haasn> (>=>) is also a good candidate imo
10:11:08 <simcity2000> pjdelport: very cool
10:11:10 <ReinH> (in this sense, the monad laws are actually monoid laws)
10:11:10 <simcity2000> I'm into it
10:11:12 <haasn> (essentially defining monads in terms of their kleisli categories)
10:11:18 <haasn> (with monad laws being category laws)
10:11:23 <ReinH> regarded as a (Kleisli) category, they are the category laws
10:11:50 <pjdelport> simcity2000: so in other words, join . join == join . fmap join
10:12:49 <knapper_tech> Alright, read back over some monad, applicative, functor stuff
10:13:02 <knapper_tech> probably a little more ready to get some web programming working
10:14:22 <knapper_tech> I'm going to use heist as an external library (not with snap) and Scotty.  I'm going to be using Scotty/Spock since I kind of preferred flask-esque approaches to web architecture in the end with Python.
10:15:03 <thoughtpolice> jfischoff: if it's in an unsafe FFI call
10:15:11 <thoughtpolice> that's the only other major case I can think of
10:15:11 <jfischoff> ah
10:15:27 <Ainieco> hello?
10:15:31 <jfischoff> which I assume c_write is ‚Ä¶ hmm let me check
10:15:49 <thoughtpolice> c_write could very well be unsafe, but generally system call stuff shouldn't be, I think.
10:15:49 <jfischoff> yes
10:16:09 <jfischoff> https://github.com/ghc/ghc/blob/41f5b7e3e0648302b9c5dc485917a391d21d15a1/libraries/base/System/Posix/Internals.hs#L417
10:17:08 <thoughtpolice> i really wish there was something between safe/unsafe for cases like this. perhaps for system calls where you hit the kernel, safe actually doesn't impact much. i haven't done benchmarks on that in a looong time.
10:17:37 <thoughtpolice> (safe is far more expensive than 'unsafe' since it implies talking to thread pools, potential locking etc in the pessemistic cases)
10:18:35 <jfischoff> are you saying a context switch is so expensive the overhead of safe might not matter?
10:19:27 <thoughtpolice> yes, it could very well not matter for cases like that. it probably isn't quite that simple, of course
10:20:42 * jfischoff reads up on the difference between safe and unsafe ffi calls
10:21:25 <eacameron> noob question: Several libraries have basic wrappers around String and they expect you to simlpy use OverloadedStrings to get your literals into their specific type. But I often find I need to dynamically create my strings and of course, I'm usually using Text instead of String. Is there a good way to convert my Text to their type without T.unpack?
10:21:38 <thoughtpolice> jfischoff: 'unsafe' basically just switches to the C stack and directly issues a 'call' instruction to a function, so it's _very_ low overhead in comparison. this is why it blocks the GC, because the RTS has no idea how to interrupt an arbitrary piece of C code.
10:21:39 <rwbarton> in general writing should go through the IO manager, right? not an unsafe call to c_write
10:21:56 <rwbarton> or does the IO manager not manage writes
10:22:02 <mbrock> two different Delayed semantics: http://lpaste.net/107280 (rwbarton, pjdelport, Zekka, ...)
10:22:54 <rwbarton> Delayed' doesn't satisfy the laws
10:23:01 <mbrock> oh, interesting
10:23:01 <rwbarton> e.g. pure id <*> x
10:23:05 <jfischoff> rwbarton: I was directly using c_write because it was faster in the single threaded case, it might not be now that I have two threads
10:23:16 <jfischoff> I should check
10:24:19 <rwbarton> oh I see
10:24:27 <bergmark> eacameron: unless they have something that accepts a text you have to unpack it somehow
10:24:41 <eacameron> bergmark: I was afraid of that
10:24:41 <eacameron> :(
10:24:47 <eacameron> seems slow
10:26:11 <mbrock> rwbarton: hm, how does it violate that law?
10:26:46 <rwbarton> @undo do { x' <- join x; return (return x') }
10:26:46 <lambdabot> join x >>= \ x' -> return (return x')
10:27:00 <bergmark> eacameron: a lot of libraries were written before text existed
10:27:04 <rwbarton> or fmap return (join x)
10:27:32 <rwbarton> fmap return (join x) is always ... something of the form fmap return y
10:28:16 <rwbarton> that means if you have  z = fmap return (join x)  and  z1 <- z  then z1 is of the form return y
10:28:27 <rwbarton> so z1 has no "side effects"
10:28:54 <rwbarton> but in general, if  z = x  and  z1 <- z  then z1 might be something with side effects
10:29:01 <rwbarton> so, fmap return (join x) /= x
10:29:11 <rwbarton> pure id <*> x /= x
10:29:30 <pjdelport> mbrock: That's actually something i poked at the other day!
10:29:57 <rwbarton> basically if you "flatten" x with join, you lose information
10:30:12 <pjdelport> mbrock: What you really want in that case is something akin to "parallel" binding.
10:30:15 <rwbarton> the law "pure id <*> x = x" says you are not allowed to lose information
10:30:25 <pjdelport> mbrock: That is: print =<< (\(a,b) -> liftA2 (,) (prompt a) (prompt b)) =<< liftA2 (,) getLine getLine
10:30:47 <mbrock> rwbarton: interesting, thanks, I'll have to think about it :)
10:30:54 <rwbarton> if you replace IO with [] and try x = [[1,2],3] for example, you can see what is going on
10:31:02 <rwbarton> sorry: x = [[1,2],[3]]
10:31:04 <pjdelport> mbrock: That gives you the behavior of your second version.
10:31:49 <pjdelport> mbrock: While your first version is akin to: print =<< liftA2 (,) (prompt =<< getLine) (prompt =<< getLine)
10:32:22 <pjdelport> mbrock: The only problem is that the tupling in my previous is ugly as heck.
10:34:01 <mbrock> pjdelport: yeah, that seems right
10:34:52 <mbrock> pjdelport: the first version is the one I actually use, to do something related to pre-fetching of resources
10:35:48 <mbrock> pjdelport: on my first try I accidentally implemented the second one, and found that my pre-fetching was not very eager :)
10:40:01 <Guest49060> ÿ™ÿ≠ÿ∞Ÿäÿ±
10:40:01 <Guest49060> warning
10:40:01 <Guest49060>  you may be  watched
10:40:01 <Guest49060> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
10:40:01 <Guest49060> do usa&israel use the internet 2 collect informations,,can we call that spying??
10:40:13 <pjdelport> mbrock: Here's what i came up with when i poked at it: http://lpaste.net/107282
10:40:16 <mbrock> pjdelport: so my outer IO creates an MVar and spawns a worker to fill it, and the inner IO just reads the MVar. then I use traverse/sequence to combine many such Delayeds, and forcing will then start all the workers at once
10:40:38 <educated_idiot> how do I see what ghci's current include path is? (i.e. the path set by :set -isrc)
10:40:46 <pjdelport> mbrock: That doesn't require any extra newtyping, and works with any Applicative / Monad
10:41:08 <mbrock> pjdelport: neat!
10:44:12 <enthropy> educated_idiot: :show paths
10:44:35 <ocharles> Can the GHC RTS be queried for the amount of currently running threads?
10:44:54 <ocharles> I have a feeling we're leaking threads, but would like to try and measure that rather than just assume that's the problem
10:45:10 <educated_idiot> enthropy: my 'cabal repl' ghci doesn't have that :( cabal-install version 1.20.0.3
10:45:44 <ocharles> Maybe I should run through threadscope
10:45:48 <pjdelport> mbrock: The idea is that often you have a bunch of binding applications, like  f =<< x, g =<< y, and h =<< z, and you want to collect the result of all of them, you can relatively easily do them each in sequence, with e.g.: (,,) <$> (f =<< x) <*> (g =<< y) <*> (h =<< z)
10:46:03 <jfischoff> ocharles: there is a heap profiling option to see threads
10:46:10 <jfischoff> xt or something
10:46:14 <ocharles> jfischoff: ah, cool. Should I see +RTS -help?
10:46:30 <jfischoff> yeah if you compiled with profiling
10:46:37 <pjdelport> but of course that executes the *entire* (f =<< x) before moving on.
10:46:38 <ocharles> alright
10:46:44 <rwbarton> educated_idiot: did you include the colon in ":show"?
10:46:56 <educated_idiot> enthropy: yup
10:47:21 <rwbarton> oh it's new in 7.8
10:47:59 <jfischoff> ocharles: in fact it is -xt
10:48:14 <ocharles> jfischoff: hmm, not seeing it in http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
10:48:23 <ocharles> ah, it's in http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#rts-options-heap-prof
10:48:26 <jfischoff> https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/prof-heap.html
10:48:29 <jfischoff> yeah
10:48:42 <ocharles> I think using the event log may be easier
10:48:57 <pjdelport> And evaluating all of x, y, and z before binding them to the functions is difficult with that previous syntax, but with the helpers in that paste, you can say instead:
10:48:57 <pjdelport> (f <&> g <&> h) =<< (x <:> y <:> z)
10:49:00 <ocharles> -ls should give me just scheduler events
10:49:23 <educated_idiot> enthropy: paths doesn't show up on the list of arguments to :show
10:49:51 <educated_idiot> sorry, wrong guy, rwbarton
10:50:23 <enthropy> educated_idiot: it depends on the ghc version, not the cabal-install version
10:50:47 <enthropy> but maybe :show somethingElse will give you what you're looking for
10:51:24 <jfischoff> ocharles: that sounds promising
10:52:44 <educated_idiot> enthropy: ah, I see it there for 7.8.2 in the docs, thanks
10:53:50 <jfischoff> ocharles: It would appear from reading https://hackage.haskell.org/package/ghc-events-0.4.3.0/docs/GHC-RTS-Events.html that one could determine how long threads are alive for, and current thread count over time.
10:54:02 <ocharles> even cooler!
10:54:12 <ocharles> jfischoff: I'm actually just installing that library right now :)
10:54:17 <jfischoff> :)
10:54:30 <ocharles> ghc-events show threads <file>:           Pretty print an event log, ordered by threads.
10:54:32 <ocharles> interesting
10:54:46 * jfischoff nods
10:54:59 <ocharles> pretty much perfect :)
10:57:55 <ReinH> ocharles: o/
10:58:03 <ocharles> \o
11:02:22 <jchmrt> Hey guys, I was trying to install mazes of monad (hackage link: https://hackage.haskell.org/package/MazesOfMonad), but compiling gave the error: "Not in scope 'catch'". After some research I found that catch wasn't in the Prelude anymore, I solved this problem by importing System.IO.Error and replacing all uses of catch with catchIOError. Is this a good solution and does anyone know how to report a bug on a package on hackage?
11:02:59 <dv-> try emailing the maintainer
11:03:40 <corgifex> it is a good solution
11:03:58 <pjdelport> jchmrt: http://jpmoresmau.blogspot.com/2009/07/mazes-of-monad-105-and-maybe-final.html suggests the author isn't maintaining it, but might still fix bugs.
11:04:49 <jchmrt> okay, I will try emailing him.
11:08:56 <napping> ocharles: did you try ghc-events-analyze?
11:09:14 <napping> http://www.well-typed.com/blog/86/
11:10:03 <eevar> anyone have an example demonstrating wreq's  foldGet :: (a -> ByteString -> IO a) -> a -> String -> IO a  on a stream of json data?
11:10:39 <bitraten> has anyone here experience with the Haskell Data Analysis Cookbook?
11:11:20 <eevar> i undertand how to use it, just not sure how to best parse complete json fragments and what'd be the best representation for whatever remains of the bytestring to the next iteration
11:11:44 <ocharles> napping: i haven't tried that yet, no
11:11:59 <ocharles> thanks for the reminder!
11:12:48 <napping> seems to maybe not want to install with GHC 7.8, but it's nice
11:13:47 <napping> it's at least trying with --allow-newer lens
11:15:32 <simcity2000> so I'm trying to use HDBC-ODBC to connect to a MS SQL server and it's working fine on GHCi, but when I try compiling and running the same code I get an error "Unable to connect: Adaptive Server is unavailable or does not exist".
11:16:01 <simcity2000> anybody know why a piece of code that involves network connectivity would fail on ghc but not on ghci?
11:17:56 * hackagebot music-util 0.16 - Utility for developing the Music Suite.  http://hackage.haskell.org/package/music-util-0.16 (HansHoglund)
11:18:12 <corgifex> simcity2000: timing? personal firewall?
11:18:30 <simcity2000> corgifex: no firewall per se, but it's going over a VPN
11:18:31 <ocharles> napping: doesn't build for me sadly
11:19:12 <napping> Failing in an SVG.hs for me
11:19:27 <napping> maybe try with 7.6? You've got that with your fancy nix, right?
11:20:12 <simcity2000> corgifex: adding Control.Concurrent.threadDelay doesn't help...
11:21:11 <ocharles> napping: that was 7.6 :*
11:21:12 <ocharles> :(
11:21:20 <napping> huh, it worked for me there
11:21:39 <napping> I'm not working on performance right now, but it was really nice
11:21:52 <napping> probably worth fixing if it looks like a small amount of effort
11:22:22 <napping> It'll even read out thread names and named events you make with the event API
11:23:06 <ocharles> that's pretty sweet
11:23:30 <napping> seems to be just failing at something about missing Num instances in the SVG output for me
11:24:24 <napping> here, I'll try building from their github repository
11:25:13 <napping> doesn't need any help with dependencies, at least
11:25:31 <napping> I think it's going to be building my Nth copy of lens and taking a while :(
11:25:54 <napping> do you use the nixpkgs channel? Something's wrong with the https
11:26:02 <napping> hey, no lens
11:26:21 <napping> oh, that was just ghc-events that finished
11:36:17 <xilam-balam> hi men
11:36:49 <SCHAAP137> seen the new website already? http://new-www.haskell.org/
11:36:54 <SCHAAP137> love the interactive tutorial
11:40:12 <simcity2000> SCHAAP137: looks way nicer than a firehose about functors and monad laws
11:40:58 <SCHAAP137> def simcity2000
11:41:51 <slomo> the view examples links are supposed to not work?
11:42:06 <SCHAAP137> not sure, just saw the link posted on HN, thought i'd share it here
11:42:15 <silasm> SCHAAP137: I still see no location where I can spend all my moneys on haskell swag. I disapprove.
11:42:32 <SCHAAP137> true, haskell hoodies, mugs, etc
11:42:40 <SCHAAP137> sweatbands
11:42:56 <xplat> jockstraps
11:43:36 <ajcoppa> slomo: it's not finalized yet, so some of the links still need to be filled in
11:45:43 <slomo> ajcoppa: ok :) but looks really nice in any case
11:52:03 <xilam-balam> is there a way  I can get past conversations
11:52:39 <xilam-balam> on this channel?
11:53:14 <sm> at http://ircbrowse.net
11:53:25 <pjdelport> http://www.haskell.org/haskellwiki/IRC_channel#Logs
11:54:05 <sm> has anyone here written a splitter of log files, maybe using conduit or pipes ?
11:54:59 <sm> I can't find an existing one or awk script that does what I want, eg handle multi-line entries
11:55:16 <jfischoff_> what does ‚Äúblocked on asyncDoProc‚Äù mean in threadscope?
11:55:45 <napping> ocharles: builds from github, at least I get a binary
11:56:16 <ocharles> napping: ah, thanks! I'll try switching the source to that soon
11:56:45 <sm> if not.. is there some sort of generic conduit for splitting ? (not just on newlines)
11:56:47 <xilam-balam> greate!
11:57:19 <napping> ocharles: are you actually using nix to have multiple incompatible builds of libraries?
11:59:27 <bennofs>  I tried to install network according to: http://neilmitchell.blogspot.de/2010/12/installing-haskell-network-library-on.html on Windows 7
11:59:47 <ocharles> napping: hm? I'm trying to build it with nix, but it's incompatible with the versions in nixpkgs atm
12:00:16 <bennofs> now, when I try to compile wreq, I get: "unknown symbol: `_getWSErrorDescr'"
12:00:31 <bennofs> does anyone know what I might be doing wrong?
12:01:35 <Luke-> cabal update is failing for me: "cabal: Codec.Compression.Zlib: premature end of compressed stream" -- does this mean SSL/TLS is failing?
12:03:40 <creichert> Luke-: are you in a sandbox?
12:04:12 <creichert> removing .cabal/packages/hackage.haskell.org/* works for me
12:04:45 <napping> ocharles: That was a separate question. Is nixpkgs just some curated set of particular Haskell versions, or is there something fancier going on to cache builds?
12:05:19 <ocharles> napping: nixpkgs contains (usually) one version of each library on Hackage, and that version is pretty close to the latest version there is
12:05:27 <ocharles> some libraries have a few different versions, but we avoid that
12:05:32 <napping> Okay, that's more boring
12:05:57 <ocharles> build caching happens somewhat for free, because as long as the inputs don't change the output doesn't change. so we hash all the inputs and just look up a pre-built binary generated from the same hash
12:06:03 <enthropy> there seem to be quite a few hackage packages missing from nixpkgs though
12:06:11 <ocharles> then add them :)
12:11:00 <Luke-> creichert: no
12:11:07 <Luke-> creichert: i'll try that
12:11:41 <Luke-> creichert: removing that dir didn't fix the problem
12:12:06 <Victor_> Hi
12:15:38 <creichert> Luke-: did you update afterwards? or was the error the same again?
12:25:51 <SamB> ... why is the interesting stuff on http://new-www.haskell.org/ all hiding below the fold ?
12:26:15 <SamB> almost all I can see is useless pictures
12:26:29 <michaelochurch> l
12:26:42 <chrisdotcode> "pointless-fun" is the greatest name for a package, ever
12:27:17 <michaelochurch> This is going to be a noob question, but is this:
12:27:20 <michaelochurch> data Degen a = Degen deriving (Show, Eq, Read)
12:27:45 <SamB> is it what?
12:27:57 <michaelochurch> instance (Monad Degen) where { return x = Degen ; m >>= f = Degen }
12:28:04 <michaelochurch> a legitimate monad?
12:28:23 <napping> why not?
12:28:24 <michaelochurch> (it's degenerate, it's essentially a unit parameterized with a non-used type)
12:28:31 <ion> michaelochurch: http://hackage.haskell.org/package/tagged-0.7.2/docs/Data-Proxy.html
12:28:34 <michaelochurch> I've never seen "the Degenerate monad" used.
12:28:58 <SamB> michaelochurch: well, what would it be useful for?
12:29:11 <michaelochurch> SamB: nothing, except as an example
12:29:17 <napping> how about this next-to-degenerate one? newtype Const a b = Const {getConst :: a}
12:29:18 <michaelochurch> SamB: e.g. "this is the smallest monad"
12:29:55 <michaelochurch> it seems to me that all *useful* monads have a == b <=> return a == return b; am I correct on that?
12:30:28 <michaelochurch> (apparently not looking at Data.Prozy, which seems to be that "degenerate" monad I was looking for)
12:30:30 <chrisdotcode> what's "<=>"? iff?
12:30:34 <michaelochurch> equivalence
12:30:37 <michaelochurch> sorry, not Haskell... math
12:30:53 <SamB> michaelochurch: hmm, I guess it *could* be used to help people stop trying to figure out "what monads are" and realize that it's just about the laws
12:31:00 <michaelochurch> my understanding from all the useful monads is that they're nondestructive
12:31:00 <napping> well, Proxy isn't useful for itself much
12:31:15 <michaelochurch> nondestructive meaning x /= y implies return x /= return y
12:31:42 <Iceland_jack> michaelochurch: Why do you ascribe that to monads?
12:31:43 <ion> Not everything with a Monad instance has an Eq instance. But if a = b then return a = return b
12:32:02 <ion> If a = b then f a = f b
12:32:12 <SamB> that's not even a monad law, that's just referential transparency
12:32:17 <Deadhand> So is this where I learn me a haskell?
12:32:18 <Deadhand> ;)
12:32:20 <napping> michaelochurch: certainly not the case for Applicatives - Const is plenty useful and pure x == pure y for const unconditionally
12:32:27 <Iceland_jack> Deadhand: yup :)
12:32:30 <michaelochurch> ion: right, but f a = f b can happen when a /= b
12:32:31 <Deadhand> :D
12:32:59 <michaelochurch> ion: a = b always implies return a == return b
12:33:01 <SamB> michaelochurch: yeah, well, the first equation was obviously silly
12:33:15 <ion> michaelochurch: Not if there is no (==) for return a.
12:33:16 <michaelochurch> and for every monad I've encountered the reverse implication is true
12:33:33 <michaelochurch> ion: fair enough
12:33:36 <napping> well, the monad laws promise return x >>= f == f x
12:33:45 <ion> =
12:34:52 <michaelochurch> napping: another noob question... are those laws conditioned on Eq (m a)?
12:34:55 <napping> and there are any values m1 m2 of some M A in your monad with m1 /= m2
12:35:12 <michaelochurch> napping: as ion pointed out, not all Monads are Eq types
12:35:29 <napping> no, that's some other equality
12:35:47 <napping> either contextual indistinguishability, or maybe even some kind of observational thing, if you have an opaque representation
12:35:57 <michaelochurch> napping: Ok, so intensionality
12:36:02 <Iceland_jack> > (return 'a' :: IO Char) == return 'a'
12:36:04 <lambdabot>  No instance for (GHC.Classes.Eq (GHC.Types.IO GHC.Types.Char))
12:36:04 <lambdabot>    arising from a use of ‚ÄòGHC.Classes.==‚Äô
12:36:05 <napping> well, not necessarily even that
12:36:12 <michaelochurch> napping: err, I mean extensionality
12:36:26 <michaelochurch> napping: a === b if a and b are indistinguishable in all contexts
12:36:28 <napping> If you hide the implementation, maybe there are different ways to build up a value, and you're only supposed to use certian observation functions
12:36:31 <SamB> I've seen monads that play it a *bit* loose
12:36:32 <napping> it's not terribly precise
12:36:41 <napping> like maybe there's a Foo.Unsafe module that lets you peek under the hood, even
12:37:48 <napping> Back to your question, if there are some values m1 and m2 in your monad that are distingusihable, and you can distinguish x and y enough to write a function f that takes x to m1 and y to m2, then return x >>= f = m1 /= return y >>= f = m2, so return x /= return y either
12:38:09 <napping> so basically return x = return y implies x = y for non-degenerate monads
12:38:36 <michaelochurch> napping: Ok, thanks.
12:38:56 <napping> Applicatives are generally more fun anyway
12:39:13 <michaelochurch> napping: so there are no uses of "projection" monads in other words.
12:39:37 <napping> no, I think I said no monad except for the degenerate one can be a "projection" in that sense
12:40:13 <michaelochurch> napping: got it.
12:40:19 <napping> I mentioned "Const" as something useful which has pure x == pure y for any x and y
12:40:24 <napping> it's only applicative though
12:40:38 <napping> Lens uses it all over the place
12:41:04 <napping> it's how you take a (Functor f) => (a -> f a) -> (s -> f s) and turn it into a function s -> a
12:41:30 <napping> I guess I should say it's at most Applicative
12:42:08 <Algebr> Anyone on OS X, brew using 7.8 installed via brew? Pretty stable?
12:46:41 <bergmark> Algebr: i'm using 7.8 but not through homebrew, global packages can get messy
12:46:59 <mcbears> is there any word on when the next platform (with ghc 7.8) will be released?
12:47:06 <bergmark> mcbears: very soon
12:47:19 <mcbears> cool awesome
12:47:43 <bergmark> they have all the infrastructure set up, they are waiting for ghc 7.8.3
12:47:54 <mcbears> ah okay
12:48:14 <bergmark> Algebr: http://ghcformacosx.github.io/
12:48:41 <Algebr> brew is usually really good about pushing the latest code, afaik.
12:48:44 <kaiko> I have "fn :: (Maybe Foo) -> String -> String -> IO String"  and I want to call fn (in IO monad) only if I Foo is Just. What is the best and shortest way to do it?
12:49:15 <Algebr> bergmark: ah nice! never saw that before
12:50:05 <bergmark> Algebr: yeah, before ghcformacosx homebrew was the easiest way to get things up and running because of the clang madness
12:51:41 <spaceships> kaiko: when (isJust foo) (fn foo ...)
12:51:55 <Algebr> bergmark: So one ought to have either the brew of ghc or this haskellforosx?
12:53:03 <spaceships> kaiko: oops you are returning a string -
12:54:52 <bergmark> Algebr: installing normal binary distribution is also easy
13:00:00 <educated_idiot> when compiling Cabal-1.20.0.1, i get the error "undefined reference to __gmpz_powm_sec", I've tried this with gmp-4.x and 5.x installed from source to a user dir, and this is with a ghc-7.8.2 compiled from source, clue please?
13:00:03 <kaiko> Yes. Should be something like that (this doesn't work): do { x <- if isJust foo then Just ( fn (fromJust foo) "a" "b") else Nothing; return x }
13:01:37 <educated_idiot> wait, ghc-7.8.2 is the binary distribution, sorry
13:09:44 <spaceships> kaiko: i think the expression you gave has type Maybe (IO String) but I think you want IO (Maybe String)
13:10:13 <kaiko> True
13:10:44 <jfischoff> is Brandon Simmons in here?
13:13:09 * hackagebot MazesOfMonad 1.0.8 - Console-based Role Playing Game  http://hackage.haskell.org/package/MazesOfMonad-1.0.8 (JeanPhilippeMoresmau)
13:13:26 <carter> jfischoff: nope
13:13:30 <carter> email works though
13:14:08 <carter> he's pretty ressonsive
13:14:14 <carter> Algebr: never use brew for ghc
13:14:16 <carter> its not maintained
13:14:17 <spaceships> kaiko: how about something like: if isJust foo then do { x <- fn ...; return Just x } else return Nothing
13:14:30 <jfischoff> http://hackage.haskell.org/package/unagi-chan-0.1.0.01 looks intersting but I wonder if he tried other sized queues in the benchmarks.
13:14:50 <carter> sized how?
13:14:53 <benzrf> spaceships: why not fmap or something...
13:14:54 <carter> # of reader writers?
13:15:02 <jfischoff> number of elements
13:15:04 <spaceships> benzrf: yeah
13:15:17 <carter> jfischoff: they're unbounded....
13:15:23 <jfischoff> yes I know
13:15:28 <spaceships> kaiko: if isJust foo then fmap Just (fn ..) else return Nothing
13:15:36 <jfischoff> I see he is measure write and read
13:15:37 <carter> oh
13:15:40 <carter> you mean on his benchmark
13:15:44 <jfischoff> yeah
13:16:00 <carter> 1mm messages is a pretty clear benchmark
13:16:17 <carter> though that doesn't tell you occupancy yeah
13:16:19 <jfischoff> I think a more realistic benchmark is many writers and a few readers, probably one
13:16:33 <carter> or the other direction
13:16:33 <carter> but yeah
13:16:36 <preyalone> Does Haskell have a constant like RUBY_VERSION for detecting its own version programmatically?
13:16:47 <carter> i think his bench was the max contention one
13:16:52 <ion> kaiko: If fn takes a Maybe Foo, you should not need to branch on the Maybe as the caller of fn. Also, use pattern matching instead of isJust.
13:17:04 * jfischoff nods
13:17:09 <joelteon> preyalone, Haskell doesn't have an intrinsic version
13:17:22 <joelteon> preyalone: if you want to detect compiler versions, there are CPP defines
13:17:32 <preyalone> Does GHC offer a constant like this?
13:17:37 <joelteon> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/version-numbering.html
13:17:39 <Iceland_jack> preyalone: yes
13:17:45 <carter> CPP powers
13:17:53 <Iceland_jack>     __GLASGOW_HASKELL__
13:18:09 <joelteon> #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 704 // GHC >= 7.4.1
13:18:24 <carter> and in 7.8.3 onwards you can check the minor version
13:19:36 <preyalone> I can't seem to find __GLASGOW_HASKELL__ from inside a running GHC(i) session
13:19:42 <donri> also System.Info.compilerVersion
13:19:58 <joelteon> preyalone: like I said, it's a CPP define
13:20:20 <joelteon> you can figure out its value during the preprocessing phase, not during runtime
13:20:36 <preyalone> donri: Perfect!
13:20:50 <joelteon> preyalone: why do you want to know the compiler version?
13:21:04 <Iceland_jack> xy problem?
13:21:04 <joelteon> there may be a better way
13:21:34 <preyalone> sometimes a program needs to use different features / behaviors based on the language's version
13:21:44 <kylcarte> anyone know how to avoid the 'cannot satisfy -package-id' version hash mismatch problem with cabal? I used 'cabal add-source' to point to a local dependency, but when I try to use 'cabal repl', it can't find the local dep.
13:21:51 <joelteon> that's why you use CPP. compilerVersion is not the correct way to do this.
13:21:53 <kaiko> spaceships: It really worked although it's not very ... beautiful :)
13:22:02 <Iceland_jack> preyalone: So you don't need to use it but just wanted to know if it was possible?
13:22:16 <preyalone> it may not make sense in Haskell, but i'm building a collection of these sorts of version-printing programs in several, often more dynamic languages. https://github.com/mcandre/version
13:22:22 <spaceships> kaiko: great ;) beauty can wait
13:22:28 <joelteon> well, it doesn't make sense in haskell, you're right
13:22:41 <joelteon> with the wrong compiler version, your code won't compile at all; you can't do runtime checks
13:23:06 <preyalone> imagine a CLI Haskell script for managing several cabal sandboxes... cabal flags, and therefore GHC version, may be relevant.
13:23:06 <kylcarte> like so: http://lpaste.net/107289
13:23:21 <napping> joelteon: it might make a little sense, for tweaking runtime options or something
13:23:38 <joelteon> uh, okay
13:24:03 <rwbarton> if you want to know the version of GHC then you probably should just run ghc --version
13:24:14 <joelteon> or ghc --numeric-version if you absolutely need to do something with the version
13:24:23 <joelteon> but ghc and cabal know how to invoke themselves properly
13:24:24 <Iceland_jack> version = readProcess "ghc" ["--version"] ""? :)
13:24:41 <jkarni> how does one make typeable instances for (DataKind) promoted value constructors?
13:26:14 <Enigmagic> jkarni: deriving instance Typeable 'Bar
13:26:22 <Enigmagic> jkarni: turn on StandaloneDeriving and DeriveDataTypeable
13:27:47 <jkarni> Enigmagic: that works, thanks
13:32:00 <Averell> is there any good advanced book? covering like template haskell, conduits, arrows etc?
13:32:47 <Algebr> carter: I'm really surprised that brew doesn't do well with haskell
13:33:28 <carter> Algebr: its 'cause no one maintains it
13:33:34 <Algebr> carter: are you also in favor of ghcformacosx?
13:33:35 <carter> and the brew people do dumb stuff
13:33:41 <carter> sure
13:33:46 <carter> or the normal bin dist
13:33:57 <carter> both are good
13:34:06 <carter> and handled by folks who know what thy're doing
13:36:47 <jkarni> carter: what dumb things in particular are the brew people doing?
13:37:02 <carter> jkarni: i dont wanna talk about it or i'll get grumpy
13:37:20 <bergmark> :-)
13:37:30 <joelteon> I use the bindists, but I install them into the homebrew prefix because that way I can use 'brew switch'
13:37:58 <carter> when getting them to change something requires a quorum of haskellers agreeing in unison to a piano solo, its too much work
13:38:23 <chrisdotcode> or, you know, you guys could switch to a Linux ;)
13:38:40 <carter> chrisdotcode: don't be an ass please :)
13:38:50 <carter> i've put a LOT of time into helping make ghc work better on mac
13:39:08 <chrisdotcode> grumpy already? :p
13:39:14 <chrisdotcode> I kid, I kid
13:39:25 <carter> my computer is melting because i'm building my own copy of 7.8
13:39:27 <carter> 3
13:39:48 <carter> built a linux one already on a monster server, my macbook air is taking the heat a bit hard though
13:40:03 <chrisdotcode> why not build that one on the server likewise?
13:40:11 <carter> wrong OS
13:41:17 <chrisdotcode> VM?
13:41:29 <chrisdotcode> or cross compile?
13:41:56 <kvanb> joelteon: cask ghc works well
13:42:07 <kvanb> I make sure the cask is up to date :)
13:42:22 <carter> chrisdotcode: that would be slower
13:42:32 <carter> also cross compiling isn't fun
13:42:32 <kvanb> which it is currently not
13:42:35 <kvanb> I'll fix that tonight
13:42:35 <kvanb> :\
13:42:40 <kvanb> carter: did you see my ticket
13:42:50 <carter> kvanb: the casting one?
13:42:53 <carter> clever observation
13:43:21 <carter> really clever
13:45:38 <Algebr> oh this ghcforosx is awesome.
13:45:53 <carter> yup
13:45:55 <carter> it is
13:46:18 <napping> awesomer than just being a working GHC?
13:46:24 <Algebr> so what do when next version comes out? Just delete that .app and repeat process?
13:46:37 <Algebr> its just that its doing it the OS X way, which is nice.
13:47:10 <napping> hmm, okay. I'm probably getting a hand-me-down macbook soon, was planning to try some mostly-GUI stuff
13:47:37 <Algebr> napping: I did some gtk gui stuff on os x, but it ends up looking like ass.
13:47:44 <napping> not necessarily even Haskell, but if there are fancy ways to connect Haskell to native GUIs I might be interested
13:47:55 <carter> theres the objective C binding stuff
13:48:05 <carter> @hackage language-inline-c
13:48:05 <lambdabot> http://hackage.haskell.org/package/language-inline-c
13:48:07 <Algebr> carter: haskell can talk to cocoa?
13:48:20 <napping> I've also heard some of the newer .NET GUI stuff is pretty nifty
13:48:25 <carter> http://hackage.haskell.org/package/language-c-inline
13:48:28 <carter> is the one
13:48:36 <carter> yes
13:48:37 <carter> http://hackage.haskell.org/package/language-c-inline
13:49:03 <kvanb> Algebr: you can install and update it with brew using cask
13:49:12 <kvanb> on the command line
13:49:41 <kvanb> except, I just have to fix some upgrade hitches and make it the r8 (it's back on r6 at the moment, I think, but that's OK most releases don't actually update ghc only utilities)
13:49:52 <napping> gtk bindings are not exactly something new and elegant as far as GUIs go
13:50:17 <kvanb> I'm under the impression there are no nice cross platform ui thingies for haskell that aren't hard to build on windows
13:50:23 <Algebr> qt?
13:50:40 <kvanb> I think even qt is defeated by windows
13:50:48 <kvanb> It would be a miracle if it just built out of the box with only cabal
13:51:34 <kvanb> work, bye
13:52:25 <Algebr> carter: So just to be clear, I can call arbitrary ObjC Cocoa code from haskell?
13:53:55 * Algebr didn't read bottom of wiki for inline-C page, got answer.
14:02:46 <albeit_> Using attoparsec, is there any way to discard input until a specific string (not char) is reached?
14:03:14 <benzrf> albeit_: probably
14:04:07 <corgifex> manyTill?
14:05:05 <albeit_> Oh thats how it works, thanks
14:05:23 <corgifex> and there's probably an algorithm for turning an arbitrary string into a regex
14:05:41 <corgifex> in fact, that sounds like an interesting exercise
14:08:23 <corgifex> crap, I can't even figure out "aa"
14:11:05 <solidus-river> what extra computational power does Category give?
14:11:13 <solidus-river> I understand why most of the others are usefull
14:11:25 <solidus-river> but Category just lets you copy a value into a generic form
14:11:28 <solidus-river> adn then compose that form
14:11:50 <solidus-river> whats an example of what thats good for / why its a class, how is that better than just a raw function that takes a paramenter
14:11:55 <solidus-river> *parameter
14:11:59 <solidus-river> you can compose and copy those
14:14:21 <systemfault> solidus-river: Imagine (==)
14:14:56 <systemfault> solidus-river: Without ‚Äúclass‚Äù, you‚Äôd have a isMyObjectOneEqual x y    isMyObjectTwoEqual x y
14:14:59 <systemfault> etc..
14:15:20 <solidus-river> systemfault: aye but theres already an id for functions right?
14:15:24 <solidus-river> and composition
14:15:28 <solidus-river> so instead of Category foo
14:15:37 <solidus-river> and then foo.id 3
14:15:50 <corgifex> [^a]*(a([^a]+a)*($|[^a]+))?
14:15:50 <solidus-river> i could just doo foo.makeFoo 3
14:15:54 <solidus-river> and still compose it and everything
14:15:55 <corgifex> this is terrible
14:15:57 <Algebr> is it pretty safe to ignore ghc-pkg check warnings about haddock related issues?
14:16:26 <solidus-river> corgifex: what is ^a
14:16:35 <corgifex> no
14:16:52 <corgifex> you have mislexed
14:17:12 <int3__> is there a name / typeclass for monads whose values can be extracted, like Maybe and List? (as opposed to say, IO)
14:17:31 <corgifex> int3__: how do you extract from Nothing?
14:17:47 <int3__> corgifex: fromMaybe / fold
14:17:52 <Algebr> So if I do cabal sandbox, then all cabal install <somelibrary> that I do in that directory will only be for that directory, correct?
14:18:17 <Clint> corgifex: are you mauke?
14:18:29 <corgifex> depends
14:18:40 <corgifex> I'm still computerally crippled
14:18:46 * Clint squints.
14:19:12 <Clint> corgifex: i don't know what that means
14:19:30 <gigamonkey> I have this function:
14:19:32 <gigamonkey> eliminate mb (s, d) = mb >>= removeDigit s d >>= propagateAssignment s >>= propagateToOnlyPlace s d
14:19:33 <corgifex> I have no development environment set up
14:19:38 <Clint> ah
14:19:40 <gigamonkey> that should all be one one line.
14:19:42 <corgifex> also I'm on windows :-/
14:19:45 <int3__> corgifex: I guess Foldable might be what I'm looking for
14:19:51 <gigamonkey> My question is what's the right way to format it across multiple lines?
14:20:01 <Clint> corgifex: are you receiving mail to <l.mai@web.de> ?
14:20:18 <corgifex> theoretically yes, practically I have about 3000 unread emails
14:20:28 <Clint> ok
14:20:34 <silasm> int3__: Is State foldable?
14:21:10 <corgifex> work is taking up so much of my time but I've discovered I like being paid
14:21:17 <int3__> silasm: I guess not :P
14:21:25 <Clint> corgifex: fair enough
14:22:05 <gigamonkey> Ah, never mind. Emacs seems to have figured out a good way.
14:22:12 <silasm> int3__: it'd probably be a pretty simple instance to define though. I don't know if Foldable is the right way to go here in general, but it might be your best bet for things already existing.
14:22:27 <corgifex> @do mb >>= removeDigit s d >>= propagateAssignment s >>= propagateToOnlyPlace s d
14:22:28 <lambdabot> do { a <- do { a <- do { a <- mb; removeDigit s d a}; propagateAssignment s a}; propagateToOnlyPlace s d a}
14:23:00 <int3__> silasm: yeah, I think Foldable works for my use case, but I was also curious if there was a general name for the idea of extractable monads
14:23:27 <gigamonkey> corgifex: yeah, I tried 'do' originally. But then I have to have the temp variable.
14:23:30 <sveit> how would i efficiently write something for Data.Vector with type f :: (a -> v a) -> [a] -> va
14:23:40 <gigamonkey> And I originally gave them all distinct names.
14:23:43 <sveit> sorry, f :: (a -> v a) -> [a] -> v a
14:24:17 <sveit> sorry again, f :: (GV.Vector v a) => (b -> v a) -> [b] -> va
14:24:19 <sveit> sorry again, f :: (GV.Vector v a) => (b -> v a) -> [b] -> v a
14:24:34 <gigamonkey> Oh, rather I had one do not nested do's.
14:25:30 <corgifex> I'd ask you if you're a real gigamonkey but I have a feeling I might have asked this before
14:25:43 <gigamonkey> Define real?
14:25:50 <gigamonkey> If you did it was a couple years ago.
14:26:08 <corgifex> have you written a lisp book?
14:26:09 <gigamonkey> I am the gigamonkey who used to be in #lisp and who wrote PCL (and Coders at Work), if that's the one you mean.
14:26:24 <corgifex> there we go
14:28:09 <sveit> so right now i have f g = Data.Vector.Generic.concat . map g , but this is abysmally slow for large lists
14:28:58 <pepper_chico> hello, is there a way to get fun2 more "wholemeal"? I couldn't come up with other solution and this one is almost the same as the original: http://bl.ocks.org/anonymous/raw/5dbee79b5eb34fc69a96/
14:30:59 <corgifex> fun2 n | even n = n + fun2 (n `div` 2) | otherwise = fun2 (3 * n + 1)
14:31:41 <pepper_chico> ?, it's just the same as the original
14:31:42 <lambdabot> Maybe you meant: v @ ? .
14:31:43 <corgifex> fun2 n | (m, 0) <- n `quotRem` 2 = n + fun2 m | otherwise = fun2 (3 * n + 1)  -- does this even work?
14:33:54 <bms1> Sveit: which implementation are you using for Vector?
14:34:27 <bms1> I think concat might make a copy with each append operation... which would result in n^2 complexity
14:34:33 <corgifex> :t let fun2 n = (n .&. 1) * fun2 (3 * n + 1) + (1 - (n .&. 1)) * (n + fun2 (n `shiftR` 1)) in fun2
14:34:34 <lambdabot>     Ambiguous occurrence ‚Äò.&.‚Äô
14:34:34 <lambdabot>     It could refer to either ‚ÄòData.Bits..&.‚Äô,
14:34:34 <lambdabot>                              imported from ‚ÄòData.Bits‚Äô at /home/lambda/.lambdabot/State/L.hs:57:1-16
14:35:32 <corgifex> :t let (.&.) = (Data.Bits..&.) in let fun2 n = (n .&. 1) * fun2 (3 * n + 1) + (1 - (n .&. 1)) * (n + fun2 (n `shiftR` 1)) in fun2
14:35:33 <lambdabot> (Bits a, Num a) => a -> a
14:37:18 <solidus-river> whats an example of a computation that is made easier via category?
14:38:38 <mzero> I‚Äôm not sure what you mean by that, solidus-river ‚Äî are you asking about compuational complexity? or programmer effectiveness?
14:38:40 <mzero> or?
14:39:48 <deni> can i make a MyInteger type that only has numbers 1..1024?
14:40:22 <Algebr> So if one is trying to install some package and getting cabal errors that are basically all: Couldn't match type ‚Äòtext-1.1.1.3:Data.Text.Internal.Text‚Äô
14:40:22 <Algebr>                   with ‚Äò[Char]‚Äô
14:40:31 <Algebr> Is that the library writer's fault?
14:40:49 <bergmark> deni: make a newtype, don't export the constructor and instead export fromInt :: Int -> Maybe MyType
14:41:00 <mzero> well, you can do    newtype MyInteger = MyInteger Int       ‚Äî then not export the constructor so that people have to use your smart constructor
14:41:01 <napping> Algebr: one way or another
14:41:02 <mzero> heh
14:41:07 <pepper_chico> corgifex, interesting, at my stage I really would never come up with that, although I prefer the original
14:41:38 <napping> Algebr: somebody switched from String to Text, or maybe forgot OverloadedStrings
14:41:43 <mzero> Algebr: it may very well be that the library writer didn‚Äôt put OverloadedStrings in the pragma of the file
14:41:46 <conal> deni: or use a 10-vector of bits/bools, using a type encoding of 10. e.g., see the type-unary library
14:41:56 <mzero> and expected it to be set on the command line -XOverloadedStrings
14:42:15 <Algebr> mzero: so I could do: cabal install <thatPackage> -XOverloadedStrings?
14:42:21 <Algebr> its hs-twitter, fwiw
14:42:30 <sveit> bms1: generic implementation, but I could specify down if that would help
14:42:35 <sveit> i.e. using Data.Vector.Generic
14:42:41 <napping> Algebr: it's possible an upstream dependency is horribly evil and switched from String to Text without changing version numbers much
14:42:46 <bergmark> Algebr: it could be that you have multiple versions of text installed too, the fact that it names the package versions hints at that
14:43:16 <deni> mzero: bergmark conal where in there is encoded that the number can only be in the range 1..1024?
14:43:18 <moghedrin> bergmark: Had that issue just today :L
14:43:21 <napping> Algebr: but probably the package you are installing (though maybe a dependency thing if they didn't set an upper bound)
14:43:40 <deni> can't i just use make MyInt an Instance of Bounded or something like that
14:43:42 <conal> deni: in using a 10-bit representation
14:44:12 <napping> conal: how about for a prime?
14:44:24 <bergmark> deni: it can't go wrong if the constructor isn't exposed, but you may be looking for dependent types
14:44:25 <deni> conal: what about Bounded?
14:44:37 <conal> napping: how about what for a prime?
14:44:39 <napping> conal: sums work for that, I guess
14:44:39 <deni> bergmark: dependent types sound the right thing yes
14:45:12 <bms1> sveit: Nevermind, I just looked at the code, and it should only make one copy
14:45:13 <napping> conal: a tuple of various digit types only gives you types of cardinalities that factor that way
14:45:18 <conal> deni: yeah. you can then give a Bounded instance. and you can do so generically for n-bit numbers.
14:45:36 <napping> conal: but you can throw in a sum too
14:45:47 <conal> napping: do you mean what if you want a bound that's a prime, e.g.?
14:46:06 <napping> Either (Bool,Bool,Bool,Bool) () gives you 17 options
14:46:20 <conal> napping: yeah. okasaki's book includes some of these tricks.
14:47:03 <conal> napping: and relates number systems to data structures
14:48:49 <bms1> How does performance of Data.Vector, Data.Vector.Storable, and Data.Vector.Unboxed compare? I'm guessing best is Unboxed, then Storable, then generic?
14:49:04 <deni> conal: apparently i can't just do this: http://dpaste.com/0V4MPMS
14:49:15 <deni> why can't i export the constructor?
14:49:25 <deni> why do i need the fromInt thing?
14:49:26 <conal> deni: because you're using a type *synonym*
14:49:47 <conal> deni: so your instance conflicts with the existing Bounded instance for Int
14:50:04 <conal> deni: you can use a newtype, however.
14:50:37 <conal> deni: and then you can give altered instances of Num etc as well.
14:50:57 <napping> deni: also, you can't export the constructor if you want it to respect the bound
14:51:38 <napping> newtype MyInt = MkMyInt Int doesn't stop you from writing MkMyInt 1025, so you have to use it carefully and not export the constructor
14:52:37 <deni> napping: but then it's not a compile time check but rather a runtime check? right?
14:53:14 <napping> nothing with Bounded makes a compile-time check either
14:54:18 <napping> If you use a newtype and don't expose the definition, then you can make sure that only in-bounds values can exist at runtime
14:54:28 <napping> you only need a runtime check when converting into the bounded type
14:55:22 <deni> napping: okay that's not what i'm lookin for then
14:55:32 <deni> how would i go about this with dependant types?
14:55:47 <deni> bergmark: ^
14:55:48 <napping> something like {x : nat | x < 1024}
14:56:07 <napping> which again requires an explicit check if you have a nat you want to turn into that type
14:56:42 <deni> napping: nat?
14:57:15 <deni> napping: is this even possible in haskell? or is idris or some other language doing dependant types?
14:57:19 <napping> Inductive nat : Set := O : nat | S : nat -> nat.
14:57:23 <napping> that's how Coq defines it
14:58:01 <evancz> I asked earlier today, but I'm still curious. I noticed that (<<<) and (>>>) are both right associative. Does anyone know why this is the case? Does associativity just not really matter in this case?
14:58:17 <evancz> https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html
14:58:43 <evancz> They also both have really low precedence (1) compared to (.) which has precedence 9
14:59:03 <deni> napping: i get the feeling depentant typing isn't the norm in haskell. right?
14:59:03 <evancz> Any idea how these decisions were made?
14:59:46 <conal> evancz: are you asking whether associativity matters operationally or denotationally? both operators are denotationally associative.
14:59:54 <napping> deni: Haskell doesn't have dependent types. You'd do basically the same thing with a newtype, except you have to remember and check yourself that you are only supposed to build it with values in range
14:59:57 <cloudhead> evancz: perhaps to make them work like ->?
15:00:54 <Brody> Can someone upload Haskell into my brain like kungfu into Neo?
15:01:05 <deni> napping: but "check and do it yourself" means not expose the constructor and use a smart function instead?
15:01:11 <napping> yeah
15:01:14 <sveit> when building with cabal (i.e. cabal build) is ghc-options=".." effective in additing optimization information?
15:01:16 <evancz> conal: just looking for pros and cons. e.g. interactions with other operators, some optimization concerns?
15:01:19 <evancz> not really sure
15:01:28 <deni> napping: right.
15:01:30 <donri> It's a Haskell program! I know this!
15:01:35 <deni> tnx ppl
15:01:36 <evancz> I was just a bit surprised they were both right associative
15:01:37 <napping> deni: if you want to check literals, you could use TH or a quasiquoter, maybe
15:02:04 <deni> napping: just thinking about this...i'm not really there yet to actually implement this stuff
15:02:08 <napping> evancz: I'd kind of expect you wouldn't want to mix them, so you might want to make one right and one left if they are at the same level just to make it an error
15:02:39 <deni> napping: are there any good books on the subject that you would recommend?
15:02:41 <evancz> napping: that's a great point, I really hope people don't do that!
15:03:23 <conal> evancz: probably low precedence because (>>>) was used for sequencing. same as (>>=). and in both cases, the left arg is often smaller than the right, which may have encouraged right-associativity.
15:04:20 <conal> evancz: how (.) came to have high precedence, i don't know. i bet someone on the haskell language committee would remember. these discussions get pretty involved.
15:04:23 <napping> conal: the odd bit is (<<<) being also right associative
15:04:36 <conal> napping: yeah. to me also. breaks the symmetry.
15:05:04 <evancz> I think (.) is right associative? I'll check real quick...
15:05:16 <michaelochurch> :info (.0
15:05:19 <napping> maybe just a bug? I think anything that would be broken by changing it should be
15:05:20 <conal> hard to imagine that there are efficiency issues here, since these operators are overloaded.
15:05:40 <evancz> https://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html
15:05:48 <evancz> yeah, (.) is also infixr
15:05:51 <napping> arr1 <<< arr2 >>> arr3 shouldn't work anyway
15:05:55 <michaelochurch> :info (.)
15:06:02 <michaelochurch> > 4 + 5
15:06:04 <lambdabot>  9
15:06:14 <michaelochurch> lambdabot: :info (.)
15:06:22 <benzrf> michaelochurch: lambdabot doesnt suppose info
15:06:23 <conal> evancz: lennart augustsson might remember.
15:06:28 <evancz> napping: it will parse though right?
15:06:39 <benzrf> michaelochurch: if you can write a parser for :i's output, the rest of the pull request is tribial
15:06:41 <napping> if they are both right associative, sure
15:06:42 <benzrf> *trivial
15:06:48 <benzrf> michaelochurch: we're just all too laz
15:06:51 <benzrf> *lazy
15:07:09 <napping> it parses somehow
15:07:13 <evancz> hmm, thanks conal, I'll try to ask him!
15:07:28 <evancz> so the general feeling is that this is an oddity?
15:07:34 <conal> evancz: you bet. :)
15:08:27 <evancz> haha, okay, I thought I was missing that one weird trick or something :)
15:09:12 <evancz> as for low vs high precedence, I don't write code that mixes function composition with other stuff afaik
15:09:27 <evancz> well, besides with ($)
15:09:44 <evancz> does the precedence really matter that much in practice?
15:10:03 <evancz> seeing 1 and 9 just makes me think something is going on I don't understand
15:10:40 <evancz> Also, am I atypical in this lack of mixing (.) with other stuff?
15:11:01 <napping> not too strange, mostly just with >>=
15:11:08 <ab9rf> i don't use . all that often, but i'm also not very good
15:11:09 <napping> or maybe $
15:11:15 <conal> evancz: function algebra is very useful! and then you're mixing (.) with other operators. e.g., see backus's turing award paper.
15:11:22 <mcbears> I'll do "f . g <$> getLine" or something
15:13:59 <evancz> my feeling is that (f . g <> h . i) where (<>) forces it to parse as (f . (g <> h) . i) would be a bad thing
15:14:06 <conal> evancz: even just arithmetic on functions can be very handy and fits a standard pattern for Num etc on applicative functors.
15:14:12 <sveit> if i declare a foreign import "unsafe", and i parallelize my haskell code over a call to that function, will i actually use multiple cores?
15:15:20 <cwraith> sveit: an unsafe foreign call doesn't interact with thread scheduling directly.
15:16:17 <c_wraith> sveit: the only way in which it interacts with thread scheduling is that there are no places to GC during an unsafe foreign call, which will cause other threads to block if GC is needed.
15:16:23 <evancz> conal, I have to reread the paper to keep up, I know I have read parts, but probably during my first or second year at university :)
15:16:35 <c_wraith> sveit: this is more of a result of stop-the-world GC + cooperative multitasking.
15:17:16 <conal> evancz: the details are dated, but it's the most penetrating analysis of imperative vs denotational ("functional") programming i know of.
15:18:20 <conal> evancz: i like his "edsel" test. in section 9.
15:18:26 <evancz> Okay, so summary: the ideal settings would be (infixr 9 <<<) and (infixl 9 >>>) to ensure that the operators clash if used together and to ensure that function composition binds tighter than competing operators like $ and >>=
15:18:33 <evancz> conal: reading now! :D
15:18:56 <evancz> wait, did I get the associativity switched?
15:21:20 <conal> evancz: i wonder what the edsel test would reveal about elm. i'm guessing it'd be very enlightening and would suggest significant improvements.
15:23:03 <conal> btw, the criticisms of imperative programming in backus's turing lecture/paper apply to Haskell's IO as well as to Fortran.
15:24:02 <albeit_> @pl (\x -> g a =<< h x)
15:24:03 <lambdabot> (g a =<<) . h
15:25:42 <simcity2000> anybody have much experience with FFI?
15:29:36 <dcoutts> simcity2000: ask your question, don't ask if you can ask a question :-)
15:29:55 <dcoutts> you may get an answer, you may not, but certainly not if you never ask
15:33:02 <simcity2000> dcoutts: more specifically I was trying to figure out why HDBC-ODBC doesn't seem to work with GHC but does with GHCi...but it looks like the library itself was last updated 2 years ago
15:34:03 <dcoutts> simcity2000: it should still work fine, and it has a maintainer
15:34:19 <dcoutts> simcity2000: are you linking with -threaded?
15:34:22 <simcity2000> dcoutts: I filed a bug on bitbucket; it *should* be working
15:34:32 <simcity2000> dcoutts: yes, but do I need to do +RTS and specify the number of threads?
15:34:38 <simcity2000> rather, number of workers
15:34:39 <dcoutts> nope
15:34:43 <simcity2000> hmm...alright
15:35:00 <simcity2000> oopsie, netsplit
15:35:13 <simcity2000> I forgot about those...
15:37:12 <simcity2000> dcoutts: it doesn't work with -threaded either.
15:37:26 <dcoutts> simcity2000: added a suggestion in your ticket
15:37:31 <simcity2000> dcoutts: works with ghci, but not ghci -fghci-no-sandbox
15:38:05 <simcity2000> dcoutts: O
15:38:08 <simcity2000> er, I'll give that a shot
15:42:16 <simcity2000> dcoutts: how would you suggest making sure the program doesn't exit before the computation is done? use a Control.Concurrent.Chan?
15:42:56 <dcoutts> simcity2000: simplest is to use an async + wait
15:43:02 <dcoutts> async package
15:44:23 <zeiris> Is there a way to build redistributable binaries with cabal-dev, based out of /usr or /usr/local or /opt?
15:46:19 <simcity2000> dcoutts: I've been working with Go for a while so I figured channels would be a good sync thing, but this works too
15:46:20 <dcoutts> zeiris: you can use ordinary cabal, configure with the intended --prefix, build and then cabal copy --destdir=./image to prepare an installable image
15:46:55 <dcoutts> simcity2000: in Haskell the lower level sync primitive is an MVar, it's like a one-place channel (or like a lock around a mutable var, depend on how you look at it)
15:47:15 <dcoutts> simcity2000: and then Chan and other things are built on top. Or instead of MVar there's STM.
15:47:37 <simcity2000> dcoutts: duly noted
15:48:10 <dcoutts> simcity2000: async is just some well-chosen wrappers around forkIO and MVar/STM capturing standard patterns and doing the exception handling correctly.
15:48:22 <simcity2000> I'm going through Marlow's book to get some familiarity with it--I like the idea of blending functional programming and concurrent/parallel tasks
15:48:26 <Dom_> #lens
15:48:37 <simcity2000> dcoutts: gotcha
15:49:28 <dcoutts> simcity2000: ah good, it's an excellent book.
15:49:49 <josephle> does ghc STM take advantage of HTM when possible?
15:50:33 <zeiris> dcoutts: yeah, that works great with minimal dependencies, but once dep count grows enough cabal-dev looks necessary for sane builds. It looks like it's possible to do some hackery with --sandbox argument that'll work, was curious whether there's a Correct clean way :)
15:50:52 <dcoutts> zeiris: cabal supports sandboxes natively
15:51:07 <dcoutts> zeiris: cabal-dev is thus deprecated now
15:51:33 <dcoutts> josephle: no, but some people have looked at it a bit
15:52:46 <thoughtpolice> josephle: fryguybob is the person to ask about that. Haskell's STM implementation is very different from what Haswell's HTM maps to, for example
15:53:21 <josephle> interesting...
15:54:28 <josephle> I assume the implementation overcomes some of the performance concerns that usually comes with STM?
15:54:37 <dcoutts> josephle: the thought is we can speed up some of the STM internals with HTM, but it's not a case of 1:1 mapping
15:54:53 <thoughtpolice> josephle: a very, very simplistic view of it is that when you use STM, this causes the runtime system to build a transaction log in memory, which can be replayed later in the case of conflicts, or applied if the commit goes through. so there's not really a 'straight line piece of code' to map onto HTM instructions
15:55:19 <simcity2000> dcoutts: I just put my main into main_ and set main = withAsync main_ wait
15:55:27 <simcity2000> dcoutts: sound decent?
15:55:31 <dcoutts> simcity2000: yep
15:55:37 <simcity2000> great!
15:55:54 <dcoutts> josephle: you could only use HTM directly for the transactional vars if you know all the threads that take part, and that the length of the transaction is very short
15:56:15 <thoughtpolice> josephle: so as dcoutts says, you could use HTM for the actual commit phase to ensure things are consistent in the runtime system. but the Haskell code does not map 1:1 with the sort of model most HTM implementations assume
15:56:37 <dcoutts> just looking at one STM transaction that uses only a couple vars isn't enough, you'd need to know what other threads were doing with those vars to know if it's ok to convert them from software TM to hardware TM
15:56:50 <thoughtpolice> right
15:57:00 * thoughtpolice can't remember where fryguybob put his paper detailing their results
15:57:01 <merijn> josephle: A lot of the performance concerns that usually come with STM is how to properly encapsulate mutation, etc. in a transaction. With a pure language that becomes much easier :)
15:57:26 <thoughtpolice> dcoutts: I have thought that we could maybe use HTM to write HTM-powered spinlocks in the RTS, but the exact performance benefits aren't clear to me yet
15:57:27 <dcoutts> Haskell's STM is already pretty competitive with classic MVars
15:57:47 <thoughtpolice> i do have a HTM-enabled spinlock impl sitting around, though. could probably shoehorn it in and try on my Haswell server
15:57:59 <dcoutts> thoughtpolice: right, and glibc's pthreads will start to use HTM anyway. So it'd only be our custom spinlocks.
15:58:12 <josephle> merijn: that's a good point
15:58:13 <thoughtpolice> dcoutts: actually they do not! they use HLE, not the RTM feature of Haswell
15:58:32 <thoughtpolice> well, i guess they're both HTM :)
15:58:35 <dcoutts> thoughtpolice: oh ok, though it's that much of a muchness? it's similar underlying tech
15:58:59 <thoughtpolice> HLE adds a prefix in the 'lock' instruction to be backwards compatible, RTM actually requires new instruction support so it's a lot heavier buy-in
15:59:25 <thoughtpolice> well, it adds a bit to the 'lock' prefix to be more accurate, which is ignored by older intel cpus
15:59:38 <dcoutts> which is rather clever
16:00:02 <thoughtpolice> Haswell RTM is also a bit limited at the moment
16:00:20 <thoughtpolice> transactions can just fail for no reason, so you do need a fallback. but it's probably worth adding HLE bits to our current lock instructions and trying that first
16:00:20 <benzrf> rtm?
16:00:29 <thoughtpolice> since we manually use 'lock cmpxchg' in a lot of the RTS
16:00:52 <thoughtpolice> benzrf: 'Restricted Transactional Memory'
16:02:08 <thoughtpolice> it's something worth exploring, though - HLE actually had decent improvements for glibc. there are also some experiments to use all this stuff in the Linux kernel too, might be a good thing to look into for prior work.
16:13:26 <educated_idiot> for 7.8.2, does :unset -XCPP etc.. actually work in ghci? I keep getting the error "don't know how to reverse -XCPP" after :set -XCPP ..
16:18:12 <michaelt> educated_idiot: does :set -XNoCPP work?
16:19:05 <educated_idiot> Prelude> :unset -XNoCPP
16:19:08 <educated_idiot> don't know how to reverse -XNoCPP
16:19:13 <joelteon> just set it
16:19:18 <joelteon> if you unset NoCPP, that probably sets CPP
16:19:29 <educated_idiot> that was after :set -XCPP
16:19:47 <joelteon> yeah, set -XNoCPP
16:19:58 <educated_idiot> tried it was that as well
16:20:17 <jwl55> :t Eq
16:20:18 <lambdabot>     Not in scope: data constructor ‚ÄòEq‚Äô
16:20:19 <lambdabot>     Perhaps you meant ‚ÄòEQ‚Äô (imported from Data.Ord)
16:20:24 <joelteon> side note, does CPP actually do anything in ghci?
16:20:40 <jwl55> :t EQ
16:20:41 <lambdabot> Ordering
16:20:41 <educated_idiot> tried both XNoCPP and XCPP, can someone just confirm this?
16:20:57 <joelteon> I can't, I'm currently building GHC
16:21:58 <michaelt> educated_idiot: I don'nt know what unset is for; the language extensions mostly have opposites, eg. CPP so you just set -XNoCPP
16:22:44 <michaelt> educated_idiot: I get the same result for :unset -XCPP, but :set -XNoCPP works
16:23:25 <educated_idiot> ffff, ok, i see what you mean *facepalm*
16:24:00 <michaelt> I hadnt noticed unset before, so I'm not sure what we are supposed to expect from it.
16:24:36 <educated_idiot> that seriously pisses me off, why isn't that documented? still filing a bug
16:24:53 <educated_idiot> michaelt: unset expands to options -XArros etc.. with <tab>
16:25:14 <michaelt> educated_idiot: I agree it seems very confusing.
16:25:21 <jwl55> :t  (==)
16:25:22 <lambdabot> Eq a => a -> a -> Bool
16:35:10 <donri> michaelt: presumably :unset removes a :set option so you get the default behavior instead
16:36:55 <donri> oh guess not, it actually tries and fails to "reverse" options
16:37:05 <donri> ignore me + bedtime :)
16:37:36 <kini> so I'm looking at this function which is of type Monad m => Foo -> Bar -> m Baz but the only thing it uses the monad for is to call `fail`
16:38:11 <kini> is there some better way to do this?
16:38:29 <donri> kini: MonadPlus (or more simply, Alternative or Monoid)
16:38:41 <joelteon> or Either
16:38:48 <donri> Either has those instances
16:38:53 <joelteon> oh, right
16:39:00 <donri> or not
16:39:48 <donri> yeah no it can't have, not without further constraints
16:39:57 <benzrf> seriously, fail is some dumb shit
16:40:26 <donri> @hackage failure is a generic way to fail without fail
16:40:26 <lambdabot> http://hackage.haskell.org/package/failure is a generic way to fail without fail
16:40:52 <donri> apparently deprecated though, see exceptions instead
16:46:07 <kini> maybe I can refactor this function to Foo -> Bar -> Baz and throw exceptions instead of failing, and then when I want to incorporate it into some monadic code elsewhere, catch the exception and turn it back into a fail
16:46:33 <kini> it just seems so weird that this code has a monad in its type despite containing no do notation nor binding, only returns and fails
16:46:53 <kini> but throwing and catching exceptions might be even uglier... hmm
16:58:22 <Saizan> kini: use Maybe?
16:58:50 <kini> but then the error messages go away
17:00:02 <pavonia> Use Either?
17:00:07 <kini> yeah...
17:07:01 <jle`> kini: Foo -> Bar -> Either e Baz
17:09:36 <suOya_> How do I grok the State monad? I'm comfortable with Maybe, lists and IO, but I can't seem to understand State's type definition
17:09:52 <suOya_> even after lots of tutorials
17:09:55 <suOya_> it's just weird
17:10:43 <pavonia> @unmtl State a
17:10:43 <lambdabot> Plugin `unmtl' failed with: `State a' is not applied to enough arguments, giving `/\A. a -> (A, a)'
17:10:52 <pavonia> @unmtl State s a
17:10:52 <lambdabot> s -> (a, s)
17:11:38 <pavonia> suOya_: The input is a state, the output a result value and the next state
17:11:52 <suOya_> I understand that
17:12:06 <suOya_> but the bind definition is just
17:12:07 <suOya_> weird
17:12:19 <corgifex> @src State (>>=)
17:12:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:12:39 <corgifex> bind just threads the state through the two computations, doesn't it?
17:13:24 <corgifex> as in: m >>= f = \s0 -> let (x, s1) = m s0 in f x s1
17:14:04 <lfairy> that's right
17:14:06 <ReinH> @unmtl State s a
17:14:06 <lambdabot> s -> (a, s)
17:14:19 <suOya_> I know that too
17:14:19 <sveit> i am a bit confused about the different strategies offered in control.parallel.strategies. in particular, what is/how does rpar work?
17:14:38 <suOya_> But I don't "feel" the State monad the same way I do with lists or Maybe
17:14:40 <suOya_> guess I just need time
17:14:49 <corgifex> suOya_: do you know Reader?
17:15:06 <suOya_> Yes but I haven't looked into it
17:15:12 <suOya_> I don't even know what it's used for
17:15:15 <corgifex> it's similar but simpler
17:15:22 <corgifex> read-only state
17:15:28 <suOya_> right
17:15:41 <corgifex> well, function parameters actually
17:16:46 <ReinH> suOya_: if you ignore the constructor, a State s a value is a *function* that takes a state and gives a tuple of state and some value
17:17:21 <ReinH> suOya_: we can start by looking at how it works as a Functor
17:17:25 <ajcoppa> suOya_: have you heard of the NICTA course?
17:17:29 <ReinH> :t fmap
17:17:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:17:33 <suOya_> ajcoppa: no
17:17:44 <ajcoppa> okay -- first listen to all the helpful people in here
17:17:51 <suOya_> yes
17:18:01 <ajcoppa> but the NICTA course has you implement functors/applicatives/monads for yourself, including eventually State
17:18:04 <ReinH> suOya_: actually, let's start by looking at a simpler one: return.
17:18:06 <ReinH> :t return
17:18:06 <lambdabot> Monad m => a -> m a
17:18:24 <ReinH> if our m is (s -> (a,s)) then return :: a -> s -> (a,s)
17:18:27 <ajcoppa> it will probably be challenging but extremely illuminating to go through the course: https://github.com/NICTA/course
17:18:35 <suOya_> like a -> (s -> (a, s))
17:18:36 <suOya_> ?
17:18:38 <ReinH> suOya_: do you know a function that takes two arguments and turns them into a tuple?
17:18:47 <suOya_> (,)
17:18:49 <ReinH> suOya_: exactly
17:19:18 <ReinH> so return = (,), but it's easier to understand what's going on if we are a bit more explicit
17:19:26 <ReinH> since the value we want is a function, let's write it like this:
17:19:31 <ReinH> return x = \s -> (x,s)
17:20:44 <suOya_> so it takes a value, then returns a function that takes a state and transforms it into a tuple of the given value and next state?
17:20:56 <ReinH> suOya_: the given value and the provided state, yes.
17:21:16 <ReinH> It's reasonable to think of State values as being "state transformations", in fact.
17:21:33 <ReinH> But it's more reasonable to just follow the types and the definitions ;)
17:21:42 <suOya_> oh right now I understand why it's "instance Monad (State a)", not "instance Monad State"
17:21:46 <suOya_> it's curried
17:21:52 <suOya_> or partially applied
17:22:12 <corgifex> :thumbsup:
17:22:12 <suOya_> whichever is the right word
17:22:23 <ReinH> suOya_: yes, partially applied at the type level :)
17:22:32 <suOya_> haskell blows my mind every day
17:22:34 <suOya_> thanks
17:23:03 <ReinH> suOya_: the implementations of fmap and join, or of (>>=), are pretty much the only ones that work for the types.
17:23:06 <ReinH> For example:
17:23:10 <ReinH> :t fmap
17:23:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:23:34 <ReinH> so for f ~ s -> (a,s), we get: (a -> b) -> (s -> (a,s)) -> s -> (b,s)
17:24:04 <ReinH> we can even ask a handy theorem prover to derive an implementation for us
17:24:08 <ReinH> @djinn (a -> b) -> (s -> (a,s)) -> s -> (b,s)
17:24:08 <lambdabot> f a b c =
17:24:09 <lambdabot>     case b c of
17:24:09 <lambdabot>     (d, e) -> (a d, e)
17:24:12 <ReinH> and then look at what it's doing
17:24:17 <ReinH> let's rewrite it a bit:
17:26:47 <ReinH> fmap f st = \s -> case st s of (x, s') -> (f x, s')
17:26:48 <suOya_> ajcoppa: how lond did that course take
17:27:04 <ajcoppa> i mean, it depends on the time you have to spend on it :)
17:27:07 <ajcoppa> but all of it is well-spent
17:27:27 <ReinH> so fmap takes a function to map `f' and a state transition `st' and gives back a function that takes a state, applies the transition to the state, takes out the resulting value, applies `f' to it, and sticks it back in the tuple.
17:27:35 <ReinH> suOya_: does that make sense?
17:27:47 <suOya_> yeah, I understand the way it is a functor
17:27:53 <ReinH> suOya_: oh ok :)
17:28:00 <ReinH> we can do the same thing with (>>=)
17:28:02 <ReinH> :t (>>=)
17:28:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:28:10 <suOya_> it's just the monadic bind that seemed the most complicated to me, but I'm starting to see how it works now
17:28:20 <suOya_> but show me!
17:29:11 <ReinH> suOya_: can you substitute (s -> (a,s)) for m in that type signature and tell me what it would be for our state?
17:29:39 <suOya_> christ
17:29:42 <ReinH> heh
17:29:43 <suOya_> I'll try..
17:29:44 <ReinH> let's break it down
17:29:48 <ReinH> m a == ?
17:29:57 <ReinH> (we already did that one for fmap)
17:30:03 <suOya_> yeah, just a second
17:30:06 <suOya_> (I'm not googling)
17:30:08 <ReinH> no worries :)
17:30:49 <MHD_> How does the dual of Applicative look?
17:31:05 <MP2E> MHD_: It exists in comonad, the library, if you'd like to look at it :)
17:31:10 <MP2E> ComonadApply
17:31:27 <MP2E> I'd describe it to you but it mystifies me a bit, itself
17:31:32 <ReinH> heh
17:31:52 <MP2E> For instance, not exactly sure why ap is the same in both cases
17:32:04 <MP2E> nor why ComonadApply is defined in terms of Comonad and not the other way around
17:32:08 <MP2E> but yeah :V
17:32:11 <suOya_> (s -> (a ,s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
17:32:14 <suOya_> well that turned out ugly
17:32:35 <ReinH> suOya_: why do you think it's given a newtype? ;)
17:32:57 <ReinH> State s a -> (a -> State s b) -> State s b <-- looks a lot better
17:33:03 <suOya_> oh right
17:33:07 <suOya_> I'm a bit tired
17:33:17 <ReinH> suOya_: oh no, I was just kidding!
17:33:31 <ReinH> suOya_: you aren't doing anything wrong :)
17:33:47 <suOya_> yeah I just wrote that the hard way :]
17:34:03 <sveit> is there an effective way to debug an error that appears only the second time I run a pure function?
17:34:06 <ReinH> You wrote it the right way for what we're doing :)
17:34:10 <suOya_> great
17:34:11 <MP2E> Writing it the hard way is definitely convenient, or at least the ability to write it the hard way
17:34:31 <MP2E> err not convenient but nec essary*
17:34:44 <MHD_> ComonadApply isn't a dual of Applicative
17:34:49 <MHD_> it IS Applicative
17:34:50 <ReinH> suOya_: the goal here is to understand what it's doing under the hood, after all
17:35:07 <MHD_> without the "pure" bit
17:35:13 <ReinH> MHD_: Er, are you sure?
17:35:14 <suOya_> now that I understand the type signature better, only the implementation of (>>=) for State is what's puzzling me now
17:35:16 <MHD_> which really needs to sit in Point
17:35:25 <ReinH> MHD_: Apply is Applicative without pure
17:35:26 <suOya_> but maybe we shouldn't write it here, I think this was enough
17:35:33 <ReinH> ComonadApply is "strong lax symmetric semi-monoidal comonad"
17:35:35 <suOya_> ReinH: thanks for help!
17:35:36 <ReinH> s/is/is a
17:36:02 <ReinH> suOya_: as an exercise, try to write a function with that signature :)
17:36:18 <MHD_> ReinH: I was just puzzling over the concept of Co-Apply and needed a reference
17:37:19 <suOya_> I'll try..
17:37:45 <ReinH> MHD_: some ComonadApply are also Applicative
17:37:51 <ReinH> and if they are, they must be the same
17:38:09 <ReinH> Reader and Writer, for instance.
17:38:53 <ReinH> Except that we are operating in the opposite category
17:39:09 <ReinH> so writer becomes reader
17:39:16 <ReinH> instance Monoid m => ComonadApply ((->)m) where
17:43:11 <MHD_> What about a CoFunctor?
17:43:25 <MHD_> cofmap :: (f a -> f b) -> a -> b
17:43:52 <ReinH> A Functor.
17:44:51 <MHD_> hmm
17:45:06 <pavonia> Isn't that (b -> a) -> f a -> f b?
17:45:13 <MHD_> yeah
17:45:14 <ReinH> :t fmap
17:45:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:45:22 <ReinH> functors are self-dual
17:45:33 <MP2E> fmap :: (a -> b) -> f a -> f b to cofmap :: (b -> a) -> f b -> f a
17:45:33 <MHD_> how do you make cofmap from fmap?
17:45:41 <MP2E> which if you notice is the exact same thing just type variables are switched
17:45:43 <ReinH> you get (b -> a) -> (f b -> f a)
17:45:51 <ReinH> which is the same thing up to alpha equivalence
17:46:10 <ReinH> "cofunctor" is sometimes used to mean "contravariant functor"
17:46:15 <MHD_> ok
17:46:22 <ReinH> for instance in this deprecated package https://hackage.haskell.org/package/cofunctor
17:46:39 <pavonia> Oh
17:46:49 <ReinH> but "coX" generally means "the categorical dual of X", so "cofunctor" is passing out of use.
17:47:39 <MHD_> but how does one go from fmap :: (a -> b) -> f a -> f b  into  pamf :: (f a -> f b) -> a -> b ?
17:48:26 <ion> (exists f. f a -> f b) -> a -> b? :-P
17:49:45 <MP2E> ion : does exists mean 'forall in the context of Existential Types' or just for any f that exists
17:50:17 <RchrdB> MHD_, you can't write that function with just the typeclass (Functor f).
17:50:20 <MP2E> actually that isn't really a meaningful question heh
17:50:36 <MHD_> RchrdB: that is what I thought and what confused me
17:50:53 <MHD_> ion: constructive proof of that please, I accept Coq and Agda :P
17:51:12 <MP2E> MHD_ my guess would be 'extract $ fmap' :P
17:51:18 <MHD_> yeah
17:51:18 <ReinH> Ok, we're talking about the arrow mapping part of a functor
17:51:35 <ReinH> Oh, this isn't a question about whether functors are self-dual
17:51:36 <ReinH> sorry
17:52:10 <MHD_> so I am going to safely add CoApply to my collection of category theoretic modules in ML
17:52:26 <MHD_> sorry
17:52:29 <MHD_> CoMap
17:52:32 <prophile> (f a -> f b) -> (a -> b) only exists for a very small number of f, no?
17:52:34 <ReinH> heh
17:52:35 <MHD_> CoApply == Apply
17:52:45 <suOya_> ReinH: In order to make a function with that signature I should make (a -> (b, a)) a functor, am I right?
17:53:06 <MHD_> prophile: yes, one where a general  f a -> a  function exists
17:53:21 <MP2E> now we're getting into f algebras it seems!
17:53:24 <MP2E> :P
17:53:41 <prophile> MHD_: what about f = void?
17:53:47 <triliyn> MHD_: I think you also need an a -> f a
17:53:48 <ReinH> prophile: it exists if f is a comonad or, more generally, an f-algebra :)
17:54:09 <ReinH> at least I think it does
17:54:17 <MHD_> all in all, one can view all these as where the "magic" happens
17:54:31 <ReinH> There is no magic only types.
17:54:34 <prophile> for f = void, it's effectively (void -> void) -> (a -> b)
17:54:34 <MHD_> Monad and pals has the magic happen on the "inwards" way
17:54:40 <prophile> void -> void is ()
17:54:43 <MHD_> and CoMonad and pals has magic in the "outwards" way
17:54:49 <prophile> so that would imply being able to make an a -> b out of nothing
17:55:01 <brrrrian> helllloooooo #haskell
17:55:07 <ReinH> prophile: right, so something something initial something
17:55:07 <prophile> correct me if I'm wrong, which is very possible
17:55:10 <ReinH> brrrrian: hi
17:55:35 <prophile> f a -> a exists in that case though, it's absurd
17:55:37 <ReinH> prophile: const ;)
17:55:39 <brrrrian> I am trying to profile a simple program that does lazy bytestring readFile and then writeFile... so a 'cp' clone.
17:55:49 <ReinH> prophile: which only fails due to parametricity
17:55:50 <brrrrian> And basic profiling isn't really showing me anything
17:56:17 <brrrrian> How can I get finer grained insight into what is actually going on at RTS level?
17:56:25 <bms1> prophile: I think the only possible thing there is f = Identity
17:57:04 <prophile> bms1: the only possible (f a -> f b) -> a -> b?
17:57:15 <bms1> prophile: yeah
17:57:17 <triliyn> It should work for things like nonempty lists too
17:57:19 <MHD_> so CoMap with cofmap :: (f a -> f b) -> a -> b, presupposes a CoMonad-like extraction thingy and some way of getting from a to f a, whereas Map with fmap :: (a -> b) -> f a -> f b presupposes some sort of Monad-like return thingy and a way of getting from f a to a...
17:57:26 <prophile> triliyn is right I think
17:57:28 <MHD_> okay I have now concluded that CoMap is stupid
17:57:42 <ReinH> Why do you need an f-coalgebra?
17:57:50 <ReinH> Ah.
17:57:52 <prophile> for f a = (a, Int), you can turn ((a, Int) -> (b, Int)) into (a -> b)
17:57:58 <bms1> triliyn: oh, that's right
17:58:06 <ReinH> So it needs to be both an f-algebra and an f-coalgebra
17:58:15 <ReinH> so anything that is both a monad and a co-monad
17:58:18 <ReinH> *comonad
17:58:21 <MHD_> *Cave Johnson voice* Category Theory isn't about "why" ! It's about "why not?" !
17:58:22 <ReinH> and maybe a few other things
17:58:38 <triliyn> Also... with State () and any other concrete state type (of which values can be invented)
17:59:00 <triliyn> I think?
17:59:07 <MHD_> IF YOU LOVE SENSIBLE MATH SO MUCH WHY DON'T YOU MARRY IT!
17:59:08 <MHD_> :P
17:59:33 <bms1> triliyn: Well, State () is pretty much Identity, isn't it?
17:59:41 <ReinH> The aforementioned reader/writer duality
17:59:43 <triliyn> hmmm, I guess
17:59:53 <ReinH> see also, http://stackoverflow.com/questions/16551734/can-a-monad-be-a-comonad
17:59:54 <ReinH> ;)
18:00:35 <ReinH> @unmtl State () a
18:00:35 <lambdabot> () -> (a, ())
18:01:00 <triliyn> Things like State Int work too though, don't they?
18:01:25 <triliyn> lower f x = runState (f (return x)) 5
18:01:44 <prophile> when you're having trouble making something into a monad or a comonad
18:01:49 <prophile> try adding monoid constraints
18:02:09 <prophile> guaranteed to give you something that approximately follows the monad laws or your money back
18:02:36 <ReinH> prophile: and if that doesn't work, try waving your hands faster ;)
18:03:08 <prophile> failing that, say "Edward Kmett" into a mirror three times
18:03:29 <ReinH> prophile: last time I did that I was up until 4am receiving a lecture about kan extensions.
18:03:38 <MHD_> So if I get the Reader/Writer Monad/Comonad Monoid mating ritual right; then they remind me strongly of dependent sums and products...
18:03:48 <SamB> prophile: so few sites have user-visible mirrors these days, though
18:03:56 <ReinH> MHD_: they should, sums are coproducts.
18:04:18 <MHD_> ReinH: *facepalms* right, fuck
18:04:38 <ReinH> MHD_: sorry, that wasn't meant as a "duh"
18:04:55 <ReinH> That was meant as a "yes, you're on to something!"
18:04:57 <MHD_> ReinH: no, no, I am just chastising myself for forgetting
18:05:12 <suOya_> What are comonads used for?
18:05:12 <MHD_> then again, it is nice to circularly derive things
18:05:20 <prophile> suOya_: interesting blog posts
18:05:25 <MP2E> hahah
18:05:26 <MHD_> yes
18:05:29 <MHD_> truth
18:05:32 <suOya_> i knew that, but what else? :D
18:05:35 <ReinH> suOya_: Of which this is one https://www.fpcomplete.com/user/edwardk/cellular-automata
18:05:45 <ReinH> (with an actual practical use)
18:05:56 <ReinH> They're also used to make lenses
18:06:23 <SamB> remind me what barbed wire is made of
18:06:51 <ReinH> SamB: CoPointed?
18:07:11 <suOya_> I tried to look into lenses a few days ago but I didn't really understand it the first time. I'm writing some stuff that makes heavy use of items with record syntax and updating, do lenses provide an easier way to deal with that stuff?
18:07:29 <ReinH> suOya_: that's one of the original use cases, in fact.
18:07:39 <suOya_> Great, because I don't like record syntax
18:07:57 <suOya_> I'll have to check lenses out then
18:09:02 <Iceland_jack> That feels a bit like someone asking 'is it possible to make a phone call on a smart phone?' :)
18:10:30 <suOya_> and one more questions that's been on my mind for a while...
18:10:45 <ReinH> Iceland_jack: haha
18:11:14 <ReinH> suOya_: nope, you've reached your quota sorry
18:11:29 <suOya_> Does anyone have any cool examples of monoids? I know they are things that have 1. and identity, 2. something you can append/add together
18:11:33 <ReinH> (not really)
18:11:41 <suOya_> ReinH: I'll ask anyway.
18:11:41 <ReinH> suOya_: I've got *plenty*
18:11:53 <ReinH> suOya_: the appending/adding operation must also be associative
18:11:59 <ReinH> There are some basic ones
18:12:01 <ReinH> strings
18:12:03 <suOya_> Yeah I know that, and that helps with parallelization
18:12:05 <ReinH> with concatenation and the empty string
18:12:18 <ReinH> lists, with concatenation and the empty list
18:12:35 <ReinH> sums, products
18:12:49 <ReinH> also the product of any two monoids is also a monoid
18:12:49 <bms1> suOya: For any type a, functions of type a -> a (with the identify function and composition)
18:12:51 <suOya_> I know those, I've read up on monoids, but I wonder if you guys know any custom examples someone has implemented
18:12:52 <Iceland_jack> square matrices..
18:13:16 <suOya_> like, (hypothetically), someone figures out that a GUI is a monoid
18:13:19 <suOya_> not that extreme though
18:13:25 <ReinH> suOya_: a few less common ones:
18:13:27 <bms1> suOya_: the diagrams package uses monoids heavily
18:13:28 <ReinH> bloom filters are a monoid
18:13:31 <ReinH> in a surprisingly obvious way
18:13:34 <suOya_> how?
18:13:40 <ReinH> bloom filters are a bit vector
18:13:44 <suOya_> yeah
18:13:45 <ReinH> with some rules for updating it
18:13:47 <bms1> pictures are a monoid!
18:13:55 <ReinH> the identity is the zero vector
18:14:09 <ReinH> the monoidal product is bitwise or
18:14:13 <bms1> (with the blank picture, and overlaying one picture on top of another)
18:14:30 <ReinH> hyperloglog is also a monoid in a way I can't explain
18:14:31 <Iceland_jack> Most everything is a monoid, often in many many different ways
18:14:33 <ReinH> (beacuse I don't understand it)
18:14:33 <suOya_> ReinH: Ok I couldn't have came up with that, that's pretty neat
18:14:52 <bms1> suOya_: See http://projects.haskell.org/diagrams/doc/quickstart.html There's a section "Diagrams as a monoid"
18:14:59 <ReinH> the diagrams pearl is great
18:15:09 <ReinH> @google haskell diagrams monoid pearl
18:15:12 <lambdabot> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
18:15:12 <lambdabot> Title: ‚â° ] , , [
18:15:23 <suOya_> bms1: cool
18:15:26 <ReinH> good job lambdabot, you were very close
18:15:56 <ReinH> identity: yours must be a somewhat frustrating nick to have in this channel...
18:16:01 <suOya_> ok, more questions about monoids because I'm curious:
18:16:48 <suOya_> If you can make something a monoid, what can you make out of it?
18:16:57 <suOya_> I know parallelization is one, IIRC
18:17:08 <ReinH> suOya_: you can fold it, you can use it to write divide and conquer algorithms
18:17:17 <kqr> hey i have done "cabal sandbox add-source path/to/patched/library", and when i do "cabal install --only-dependencies" it does indeed re-install the library when it has been changed. however, when i try to "cabal repl", it tells me "cannot satisfy -package-id library-a1e041abad3..."
18:17:18 <ReinH> so even without parallelization you can get asymptotic speedups
18:17:29 <ReinH> not always, but often. You need to find an appropriate monoid morphism.
18:17:30 <MHD_> Monoids are a ver
18:17:42 <kqr> it seems as though it expects an old version of the library, even though it just compiled a new version
18:17:46 <kqr> does anyone know how to deal with that?
18:17:52 <MHD_> Monoids are the basis of an ump-ton of things (give or take commutativity)
18:18:07 <ReinH> All of the divide and conquer algorithms in Richard Bird's Pearls of Functional Algorithm Design are basically "find a way to express this as a monoid morphism"
18:18:10 <MHD_> Integers with Greatest Common Divisor is a monoid
18:18:24 <ReinH> Integers extended to infinity with min is a monoid
18:18:24 <suOya_> awesome
18:18:29 <ReinH> this can be used for pathfinding
18:18:36 <ReinH> or reals, etc
18:18:43 <ReinH> er, negative infinity
18:18:47 <bms1> kqr: try cabal configure?
18:18:47 <ReinH> or naturals with min
18:18:58 <ReinH> these are called tropical monoids
18:19:03 <ReinH> no, really.
18:19:05 <suOya_> why tropical?
18:19:10 <kqr> bms1, thank you
18:19:18 <ReinH> because the mathematician that invented/discovered them is from Brazil
18:19:22 <MHD_> the free monoid construction is also pretty nice
18:19:22 <kqr> bms1, why does that work?
18:19:23 <ReinH> which seems weird, why not use his name
18:19:25 <ReinH> but there it is
18:19:38 <ReinH> we used Abelian for groups after all
18:19:45 <bms1> kqr: I honestly don't really know, but I have to do it all the time because of that problem
18:20:28 <bms1> I think "configure" is the stage where it picks the packages it will use. So if you reinstall, the package it had has disappeared
18:20:34 <MHD_> And if we let things be monoidic up to isomorphism with the monoid laws we get a lot more monoids
18:20:35 <MHD_> like Monads
18:20:40 <kqr> bms1, that makes sense
18:21:00 <kqr> bms1, my previous solution was to nuke the entire sandbox and reinstall everything... doing a quick configure is pretty neat in comparison
18:21:18 <ReinH> MHD_: why do monads require that caveat?
18:21:40 <ReinH> they are literally monoids in the category of endofunctors, but the categorical definition of monoid is a *bit* differently stated.
18:22:27 <MHD_> ReinH: yeah, that is what I mean
18:22:42 <MHD_> there's the regular monoid axioms and then there are the category theoretical monoid axioms
18:22:54 <MHD_> of which the former is a specialization of the latter
18:22:57 <ReinH> Ah, right, where everything is "up to isomorphism" ;)
18:23:08 <MHD_> and the latter takes aproximately six times as many IQ years to grok
18:23:33 <ReinH> MHD_: They're just single-object categories, what's so hard about that (he says, knowing that it is in fact quite hard)
18:23:47 <suOya_> Stop speaking Chinese guys
18:23:51 <MHD_> The classical monoid axioms are the category-theoretical monoid axioms, but in a skeleton category
18:24:03 <ReinH> heh
18:24:17 <suOya_> (jk, go on)
18:24:18 <jle`> i am a category where the only object is me and the only morphism is the identity
18:24:22 <ReinH> oh that reminds me
18:25:16 <ReinH> MHD_: can you explain that one actually?
18:25:18 <MHD_> I wonder if it is possible to discern a category theorist from a second level markov chain fed a few papers
18:25:25 <ReinH> haha
18:25:48 <ReinH> Just use Mac Lane as the corpus and set it loose
18:26:03 <MHD_> The skeleton category of a category is one that eliminates all isomorphisms and keep all other properties (so to speak)
18:26:46 <MHD_> So in a skeleton category, the only isomorphisms are identity morphisms
18:26:50 <MHD_> or, equality
18:26:58 <MHD_> in the first-order logic sense
18:27:04 <suOya_> uhh... Monads are burritos..?
18:27:04 <MHD_> ALL x: x = x
18:27:05 <AshyIsMe> i use codex and ghc-mod with vim to do haskell development, jumping to symbol definitions is great but is there a way to do "find all usages" of a tag?
18:27:14 <AshyIsMe> that isnt just a grep
18:27:23 <benzrf> AshyIsMe: codex?
18:27:37 <AshyIsMe> https://hackage.haskell.org/package/codex
18:27:41 <benzrf> :-o
18:27:55 <AshyIsMe> it uses your cabal file to generate tags for all the libraries you're using
18:28:01 <benzrf> coool
18:28:05 <AshyIsMe> so you can jump to definition of standard library code aswell
18:28:07 <ReinH> AshyIsMe: :help :tselect
18:28:07 <AshyIsMe> yeah it's really nice
18:28:11 <benzrf> now that is sweet as fuck
18:28:19 <benzrf> lambdabot needs to use this for @src
18:28:38 <ReinH> AshyIsMe: and http://vim.wikia.com/wiki/Browsing_programs_with_tags
18:29:07 <AshyIsMe> ReinH: cheers, that seems to find definitions still, rather than usages
18:30:12 <jle`> huh
18:30:14 <jle`> what just happened
19:08:28 <Morpheus> any body about to help learner
19:08:36 <jle`> Morpheus: just ask your question :)
19:11:31 <Morpheus> I have let y = randomRIO (0, 12) and want to put into/create a list of 200 numbers to process in pairs
19:12:00 <Morpheus> to either multiply or divide to test gkids maths tables knowledge
19:12:35 <suOya_> replicateM 200 (randomRIO (0, 12))
19:12:57 <Morpheus> thankyou - I knew there had be a simple way.
19:13:07 <suOya_> but you said you need pairs?
19:13:29 <Morpheus> yes, want to process out in lots of 2 numbers
19:13:51 <Morpheus> so can get 5 * 6 or make 30 / 5 or 30 / 6
19:16:13 <Morpheus> or I can do by creating 2 lists of 100 in each and take one from each list
19:16:36 <Morpheus> Could do in c/c++ but doing to learn to Haskell
19:17:00 <benzrf> hmm
19:17:12 <benzrf> > sequence (Nothing, Just 1)
19:17:14 <lambdabot>  Couldn't match expected type ‚Äò[m a]‚Äô
19:17:14 <lambdabot>              with actual type ‚Äò(Data.Maybe.Maybe a0, Data.Maybe.Maybe a1)‚Äô
19:17:20 <benzrf> o
19:17:23 <benzrf> > T.sequenceA (Nothing, Just 1)
19:17:24 <lambdabot>  Just (Nothing,1)
19:17:30 <benzrf> pfft
19:18:21 <Morpheus> randomRIO(0, 12)
19:18:37 <Morpheus> > randomRIO(0,12)
19:18:39 <lambdabot>  <IO Integer>
19:19:05 <jle`> Morpheus: you can create two lists, and zip them up
19:19:25 <jle`> or create a random tuple
19:19:31 <jle`> and make 100 random tuples
19:19:36 <frankbro> Does anyone know if there is a more recent article on Core? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType has missing cases, compared to https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.lhs#L266
19:20:00 <Morpheus> just learning about tuples - from learn you a haskell
19:20:36 <jle`> Morpheus: you can "combine" IO values with liftA2 etc.
19:20:41 <jle`> so if you have two IO Ints
19:20:46 <jle`> you can use liftA2 (,)
19:20:56 <jle`> liftA2 (,) :: IO a -> IO b -> IO (a, b)
19:21:29 <jle`> so then you can do let randomTuple = liftA2 (,) (randomRIO (0,12)) (randomRIO (0,12))
19:21:31 <Morpheus> create random tuple sounds good, will have to do more reading/learning. Finding it hard to change thinking patterns in old brain from iterative to functional
19:21:37 <jle`> and replicateM 200 randomTuple
19:21:58 --- mode: cameron.freenode.net set +o ChanServ
19:21:59 <jle`> Morpheus: the key here is that you are just "trasforming producers"
19:22:26 <jle`> if x is a producer of a's, and y is a producer of b's, then liftA2 (,) x y transforms them into a producer of (a, b)'s
19:22:37 <jle`> and then if abprod is a producer of (a, b)'s
19:22:53 <jle`> replicateM n trausnforms a roducer of (a,b)'s into a producer of...lists of (a,b)'s n-length long
19:23:24 <jle`> replicateM n :: IO a -> IO [a]
19:23:31 <ais523_> I'm working on a type system and discovered that some of the types were acting "oddly", so I decided to try to translate it to Haskell. What I have so far is http://lpaste.net/107314
19:24:41 <ais523_> here, I define NumericTuple, and can construct instances of it just fine. Can I construct instances of CopolymorphicNumericTuple somehow? I can't see a way to do it
19:25:18 <ais523_> err, that obey the same general rules, e.g. "fst_unscoped (c_make 6) == 6"
19:25:29 <Guest72813> thanks jle' - just copied your responses to vim to process in my head
19:26:25 <paf31> @pl \f -> foldr ((:) . f) []
19:26:25 <lambdabot> flip foldr [] . ((:) .)
19:27:06 <pavonia> Can anyone explain to me why Parsec outputs "unexpected end of input / expecting letter" here? http://lpaste.net/107309
19:28:51 <heatsink> Probably combining the errors from all mplus branches
19:30:21 <heatsink> > parseTest (fail "try again" <|> fail "go home") ""
19:30:23 <lambdabot>  Not in scope: ‚ÄòparseTest‚Äô
19:30:34 <heatsink> pff
19:30:44 <heatsink> Anyway, the error message is "try again or go home"
19:30:56 <heatsink> because it combines the errors from both sides of <|>
19:31:13 <pavonia> Where is the <|> here, in many1?
19:31:17 <heatsink> yes
19:31:42 <Adeon> ais523_: at least for IntTuple you can just use fromIntegral, no? or do you have some other problem
19:32:03 <pavonia> Hhm, is there any way to prevent that, i.e. only fail with "not x"?
19:32:32 <Adeon> oh, right
19:32:35 <heatsink> Use <?>
19:32:45 <heatsink> I don't know quite where to put it
19:32:56 <ais523_> Adeon: this is basically a philosophical problem; I'm not trying to construct a useful program, but rather a useful type system, and I'm discovering that my types are behaving like CopolymorphicNumericTuple here
19:33:02 <heatsink> m <?> "error" gives you "error" when m fails
19:33:15 <heatsink> instead of m's normal error message
19:34:10 <ais523_> what NumericTuple here does is that it's allowed to force a particular type onto both make, and fst_scoped/snd_scoped
19:34:18 <ais523_> because the forall is in contravariant context
19:34:25 <ais523_> CopolymorphicNumericTuple needs the forall in a covariant context
19:34:26 <heatsink> <?> isn't not working like I thought it did
19:34:37 <ais523_> actually, NumericTuple isn't doing what I want it to, I may try to fix that to get a better example
19:35:18 <GerladCode> hello, I am having a hard time grasping Template Haskell...all the tutorials are bare bones, assume you know more than you do, or are written by an Eastern European (no offense!), wish there was a learn you a TEMPLATE haskell..anyone can suggest a good way to learn?
19:36:09 <heatsink> No, I don't know how to change the error message
19:36:58 <AshyIsMe> hmm, has anyone used hscope before?
19:37:34 <GerladCode> btw, I am wanting to learn template haskell to use Yesod framework
19:37:50 <GerladCode> I am sure I could figure out usage..but what is the fun if I don't really know what I am doing
19:37:57 <pavonia> heatsink: <?> only seems to add error massages but not replace them. Well, thanks anyway!
19:38:22 <Adeon> ais523_: I'm not actually sure why but you can easily implement Copoly for IntTuple and it works
19:38:43 <Adeon> intuitively I didn't think that would work
19:38:45 <heatsink> you're welcome.  I couldn't find any way to replace error messages.
19:39:22 <heatsink> GerladCode: I think all of Yesod's template haskell uses customized quasiquote syntax
19:39:39 <heatsink> So you're really learning the syntax of Yesod's parsers
19:39:46 * Adeon notes to self: ais523 is a haskellist
19:39:47 <GerladCode> heatsink, hmm I see, its a rabbit hole essentially
19:39:55 <heatsink> and the only TH part is the [| |] and $() expressions
19:40:02 <ais523_> Adeon: ah right, it's because any integer can be coerced into any numeric via repeatedly adding/subtracting 1 from 0
19:40:07 <GerladCode> Thanks, heatsink, it is helpful to know that
19:40:10 <GerladCode> hmm
19:40:19 <ais523_> so what's happening is a mismatch between the return of fst and the argument to make
19:40:20 <GerladCode> Haskell is hard!
19:40:31 <ais523_> also, I'm not a Haskellist directly, I do type systems research
19:40:39 <ais523_> but there's a lot of type systems research in Haskell already
19:40:48 <ais523_> so it's a good place to test out theories
19:41:07 <heatsink> Yesod is almost its own dialect
19:41:31 <ais523_> anyway, something that's heartening me a lot is that Haskell's type system is just fine with the definition of CopolymorphicNumericTuple I've given there
19:41:36 <GerladCode> heatsink, let me ask you this...
19:42:15 <GerladCode> If my goal with haskell is to have a system that helps me write more reliable code..should I bother with all the extensions?
19:42:36 <GerladCode> I mean..should I just figure out how to do things my own way..since, as you say, Yesod is it's own dialect
19:42:54 <Adeon> many extensions can prove convenient
19:42:57 <MP2E> GerladCode : it really depends on the extension :) most don't compromise safety. Some do, but the ones that are 'bad' are generally documented as such
19:43:21 <MP2E> Like OverlappingInstances is one I typically hear of as a necessary evil :P
19:43:24 <suOya_> look into phantom types and GADTs, those can really help you leverage type-safety. They require just a few extensions
19:43:50 <GerladCode> mp2e, I see thanks
19:43:55 <systemfault> Is haskell usable at all without a million extensions?
19:44:00 <suOya_> yes
19:44:04 <systemfault> Even RHW uses a ton of them
19:44:13 <ReinH> Usable at all? Yep.
19:44:18 <systemfault> (RWH)
19:44:19 <MP2E> it definitely is, it's just that extensions are an embedded part of haskell 'culture'
19:44:19 <ReinH> Usable more than a little? Also yep.
19:44:34 <ReinH> Well, they are also actually useful for specific things.
19:44:34 <MP2E> think of extensions as what might be part of the language in the future, if tried and true
19:45:00 <ReinH> And a way to allow the language to grow and evolve without waiting for another report.
19:45:05 <MP2E> exactly
19:45:13 <ReinH> The second one took 12 years after all
19:45:21 <GerladCode> Does the haskell community look favorably on Template Haskell?
19:45:22 <ReinH> and we've only been 4 so far
19:45:26 <ReinH> (since)
19:45:27 <systemfault> What are other good haskell books beside LYAH and RWH?
19:45:44 <ReinH> systemfault: not a book but I recommend Brent Yorgey's course and NICTA
19:45:48 <johnw> GerladCode: I would be surprised if the whole community agreed on much in terms of what it favors :)
19:45:58 <GerladCode> lol fair enough johnw
19:46:04 <systemfault> I‚Äôm in the middle of RWH.. it‚Äôs cool but the guy is writing programs that I couldn‚Äôt care less.
19:46:19 <ReinH> http://www.cis.upenn.edu/~cis194/ and https://github.com/tonymorris/course, respectively
19:46:51 <ReinH> systemfault: there's a bit of a shortage of good, modern Haskell books atm :(
19:46:52 <MP2E> I think Template Haskell is a fine extension, particularly now with the typed variety
19:46:54 <suOya_> RWH was promising but I left it halfway because it felt too inconsistent for some reason
19:46:57 <systemfault> ReinH: Thank you
19:47:03 <ReinH> but some older ones are still valuable.
19:47:08 <GerladCode> mp2e ok :)
19:47:12 <MP2E> I would say that you shouldn't get too Template Haskell happy though because it's kinda a pain to read error messages from it
19:47:17 <MP2E> hehe
19:47:18 <GerladCode> mp2e, how would a dummy like me learn it though?
19:47:34 <GerladCode> I have a cs degree, been a pro for 15 years, and I get lost
19:48:03 <GerladCode> All the tutorials I read act like I have been doing haskell for 5 years
19:48:07 <suOya_> systemfault: I recently purchased "The Haskell Road to Logic, Maths and Programming", which seems promising, and you should also look up "Parallel and Concurrent Programming in Haskell", which is a really high-quality book if you want to learn that topic.
19:48:11 <GerladCode> and maybe that I know lisp already
19:48:23 <systemfault> Haskell is really hard IMHO, it‚Äôs just that this time‚Ä¶ I won‚Äôt give up until I can use the language effectively
19:48:35 <MP2E> play with oxford brackets and the abstract syntax tree! If you put any bit of code in between [| |] you get the equivalent abstract syntax tree
19:48:40 <GerladCode> systemfault, aye...this is my second crack at it
19:48:41 <systemfault> suOya_: Noted, thank you :)
19:48:47 <GerladCode> I understand monads now..applicative...functors
19:48:51 <GerladCode> I didn't get this far last time
19:49:08 <MP2E> GerladCode : learning Core aka System FC will help you a lot with Template Haskell because that's basically what it is, plus a few features
19:49:22 <MP2E> think of it as a super stripped down haskell
19:49:33 <GerladCode> mp2e, System FC?
19:49:52 <systemfault> GerladCode: Me too.. but the fact I cannot understand most of the conversations here means that I still know nothing at all about haskell :/
19:49:56 <ReinH> systemfault: the haskell road isn't really a "here's how you write real programs with haskell" sort of book. It's a "here's how you can explore logic, math, and a bit of programming with Haskell"
19:50:06 <MP2E> Yeah it's an academic derivative of System F, which is a variant of lambda calculus
19:50:06 <ReinH> It's a great book, but it's not what most people want from an introductory Haskell book.
19:50:13 <suOya_> Is Haskell that hard really? I've heard it's hard because you have to 'unlearn' a lot of stuff if you come from an imperative background. Haskell is my first serious language and I haven't found it too difficult... Maybe I have to 'unlearn' Haskell when I start CS at uni this fall.. ;)
19:50:19 <systemfault> ReinH: Ah ok
19:50:19 <GerladCode> ah ok..thank you so much mp2e, let me look that up
19:50:45 <systemfault> suOya_: Could be because my maths are weak.
19:50:51 <MP2E> suOya_ : I find Haskell so easy on my mind that when I switch to C the mental overhead is quite noticable
19:50:51 <suOya_> systemfault: Mine too
19:50:57 <MP2E> I would say Haskell spoils me :)
19:51:03 <ReinH> systemfault: for learning to "think in Haskell", I would really recommend Richard Bird's Introduction to Functional Programming with Haskell.
19:51:23 <jle`> Haskell isn't hard; haskell is only hard for people who have learned other programming paradigms first
19:51:24 <sveit> i can run a function compiled with -threaded and watch in my system monitor as haskell uses all 8 of my cores. this run takes ~41 seconds on average. i then compile without threading, see haskell use 100% of exactly one core, and average a second lower on execution time. How can this be?
19:51:29 <ReinH> It's a bit older, and it doesn't cover real-world topics like RWH, but there are few better books for learning "the haskell way" imo
19:51:30 <jle`> it's not inherently difficult
19:51:45 <triliyn> I recently returned to an old ludum dare entry of mine in Common Lisp after working with nothing but Haskell and a bit of Idris for years
19:51:48 <systemfault> ReinH: I understand ‚Äúfunctional programming‚Äù, it‚Äôs all the type-fu that I‚Äôm still trying to understand.
19:51:49 <triliyn> It's SO weird
19:51:50 <ReinH> systemfault: both editions are good and I've seen the first one in pdf I think
19:52:00 <ReinH> systemfault: well it covers that too :)
19:52:29 <triliyn> (Though amusingly, portions of my lisp style even back then were slightly haskelly -- I used some abomination with eql methods to simulate pattern matching for some reason)
19:52:50 <systemfault> At one point in RWH, the guy talks for 1 single line about the monomorphism restriction then says that you can use an extension to relax it..
19:52:59 <systemfault> Thanks for the extensive details, mister RWH
19:53:02 <suOya_> MP2E: I also feel that Haskell has 'spoiled' me because I have hard time enjoying Java (which I learned in HS), although I like C because I feel like I have control over lots of details in there
19:53:30 <GerladCode> su0ya, I feel spoiled by C
19:53:33 <suOya_> MP2E: In a nutshell - I enjoy Haskell when I want to stay out of the metal, and C when I want to be close to the metal
19:53:38 <GerladCode> and other C/BASIC like languages
19:53:41 <ReinH> suOya_: if you try real hard you can pretend that Java8 is a really, really, really verbose Haskell98 with a bunch of weird stuff you should never use.
19:53:48 <GerladCode> I have done them so long, that I naturally think in those terms
19:54:03 <ReinH> suOya_: I've been looking at Rust for lower-level stuff.
19:54:12 <ReinH> I just can't in good conscience use C any more ;)
19:54:27 <GerladCode> ReinH, ideally, I can convince my boss to let me do haskell
19:54:31 <GerladCode> but I have to get a lot better first
19:54:37 <suOya_> ReinH: I'm learning C because I feel I just have to know it if I want to call myself a programmer
19:54:46 <suOya_> ReinH: Doesn't mean it's not fun though
19:54:51 <suOya_> ReinH: I like the minimality of it
19:54:52 <GerladCode> Like I could study Ruby, or C# for a month and be ready to make production code
19:55:06 <GerladCode> I feel like I will need another year of haskell (at least) to be there
19:55:14 <systemfault> GerladCode: haha, same.
19:55:34 <systemfault> When I‚Äôll understand 80% of the conversations here, I‚Äôll feel pretty good about myself
19:55:58 <GerladCode> systemfault, I never understand anything here
19:56:06 <GerladCode> :) I only come here to hope it comes in by osmosis
19:56:08 <systemfault> Haha :D
19:56:28 <ReinH> One overarching piece of advice: do the exercises.
19:56:30 <triliyn> GerladCode: I can confirm that you will get it by osmosis if you pay enough attention :)
19:56:31 <systemfault> I‚Äôm learning about ADT‚Ä¶ and people here talk about GADT..then I‚Äôm like.. what?
19:56:43 <ReinH> Whatever book or course you end up doing, do the exercises. Do them.
19:56:46 <suOya_> systemfault: I'm not sure if you know this, but once you've finished an introductory book like LYAH, read Typeclassopedia on Haskell wiki. Types are probably the single most important thing in Haskell...
19:57:03 <suOya_> systemfault: Once you grok the types, the rest comes easily
19:57:03 <systemfault> suOya_: Will do it right away :)
19:57:03 <MP2E> The Typeclassopedia is brililant
19:57:06 <GerladCode> triliyn, I am doing that...20 intermediate haskell exercises..doing euler problems in haskell..readsing this logic book, using haskell
19:57:07 <ReinH> That's a great resource too.
19:57:07 <MP2E> really put things in perspective for me
19:57:17 <GerladCode> I think I have a solid understanding of core haskell
19:57:17 <AshyIsMe> suOya_: the redis codebase is a good c project to read
19:57:34 <systemfault> suOya_: I‚Äôve read LYAH completely.. and I‚Äôm halfway through RWH but not liking it.
19:57:57 <MP2E> hehe I know what you mean, RWH is a bit dry. Invaluable info, but I felt as though I was prospecting for diamonds amidst a bunch of coal :V
19:58:13 <ReinH> It's also severely out of date :(
19:58:13 <MP2E> there's those brilliant bits you don't want to miss but my god is it verbose and boring at points
19:58:19 <suOya_> systemfault: I just quit reading RWH halfway through and moved on to understand types and read resources on the internet
19:58:23 <systemfault> MP2E: I‚Äôm just not interested in what the guy does.
19:58:37 <systemfault> suOya_: That‚Äôs exactly what I‚Äôll do :)
19:59:09 <ReinH> Oh no we've summoned the edwardk
19:59:33 <systemfault> Try casting vanish followed by doom on him
19:59:38 <systemfault> (ff6 reference)
19:59:53 <suOya_> systemfault: and practise a lot, write playful code with whatever data types you can imagine :]
20:00:01 <suOya_> systemfault: Haskell is really fun
20:00:33 <systemfault> suOya_: I used to do that in a weaker language‚Ä¶ C++ using templates
20:00:55 <systemfault> I didn‚Äôt know FP at all back then though.
20:01:12 <suOya_> systemfault: great, so now raise that spirit again :)
20:01:15 * edwardk rises from the depths
20:01:17 <edwardk> Yes. Do the exercises. All of them. Bring for the day of judgment that much sooner.
20:01:19 <edwardk> er Bring forth
20:01:21 <edwardk> Yeah, so much for the gloom and doom Lovecraftian tone. A typo really does it in.
20:01:41 <sveit> i can run a function compiled with -threaded and watch in my system monitor as haskell uses all 8 of my cores. this run takes ~41 seconds on average. i then compile without threading, see haskell use 100% of exactly one core, and average a second lower on execution time. How can this be?
20:01:44 <ReinH> edwardk: it was so close too
20:02:19 <edwardk> Yep. another 50,000 years and i'll get another opportunity to wake the deep ones. Just you wait.
20:03:17 <ReinH> edwardk: http://xkcd.com/1013/
20:03:42 <edwardk> hah
20:03:46 <edwardk> as usual xkcd got there first
20:04:32 <ReinH> ‚ÄúJCPenney is a great place to work for those who respect our beliefs and fear the encroaching twilight of madness as we do‚Äù
20:06:44 <suOya_> systemfault: I also churned through a bunch of Project Euler problems when I was first working on Haskell, helps you get into the way of thinking functionally
20:06:51 <suOya_> systemfault: but whatever you find best :)
20:07:48 <systemfault> suOya_: I did that the first time I tried to learn it and indeed, it helped me to think in terms of fold/map/filter
20:08:05 <systemfault> And it made me a better programmer.
20:08:23 <carter> sveit: wheres the code
20:08:48 <sveit> carter: it's quite hairy
20:08:56 <carter> sveit: multi core perf engineering is a  trial and error
20:09:03 <suOya_> systemfault: Check out problems #19 and #54 on Project Euler and solve them by making custom data types from scratch, that was a lot of fun
20:09:05 <carter> sveit: ddid you compile wiht -rtsopts?
20:09:05 <sveit> carter: you might actually know about this. it uses ffi. is there something that could be going wrong?
20:09:16 <carter> sveit: whats the stuff your'e callling
20:09:20 <carter> i need info
20:09:24 <carter> or i can only arm chair speculate
20:09:40 <sveit> carter: just FORTRAN methods. they're imported "unsafe" if that matters.
20:09:50 <carter> hrm
20:09:53 <pavonia> heatsink: If you're interested, I finally got what I want: http://lpaste.net/107317
20:09:54 <carter> what do they do
20:10:03 <sveit> carter: calculate functions of matrices :)
20:10:06 <carter> ok
20:10:09 <carter> what size
20:10:16 <carter> show me the code
20:10:19 <sveit> 300x300 for now
20:10:25 <sveit> ok i will try to cull it down :)
20:10:28 <carter> no
20:10:31 <carter> show the uglies
20:10:37 <carter> well
20:10:53 <carter> sveit: did you try compiling with -rtsopts and setting +RTS -N4 -RTS ?
20:10:57 <carter> when you run it?
20:11:17 <sveit> i didn't use -rtsopts. will try that now, but calling +RTS -? worked on the executable, so i assumed it was fine...
20:11:29 <benzrf> hmm
20:11:37 <carter> not all the things can be toggled unles you build with -rtsopts
20:11:37 <benzrf> does anybody who is still here use codex?
20:11:41 <carter> try setting -N4
20:11:48 <carter> or something < 8 and > 1
20:11:48 <Krenium> So I'm just beginning and reading LYAH and I just came across this: "That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is." Is this actually true? I'm scared.
20:11:49 <benzrf> and if so, is there a way to get it to make tags for THE ACTUAL PACKAGE
20:11:51 <benzrf> not just the deps
20:11:52 <sveit> carter: you mean as opposed to -N8?
20:11:55 <carter> yes
20:11:55 <sveit> guess so :)
20:12:03 <sveit> carter: may i ask why?
20:12:07 <suOya_> Krenium: not really
20:12:20 <pjdelport> Krenium: Functionally speaking, loops are just a special case of recursion.
20:13:16 <carter> sveit: well, i cant know without seeing your code
20:13:31 <suOya_> Krenium: Lots of examples of recursive definitions are thrown at beginners, but that's just done in order to get you accustomed to the idea.
20:13:44 <carter> but i've embarrasingly paralle code where on a 40 core machine, its actually slower with -N30 than  -N10
20:13:50 <carter> and -N40 actually is painfully slow
20:14:01 <carter> in that case, I THINK the issue is gc's pausing everythi g
20:14:32 <sveit> carter: trying it out now :)
20:14:47 <carter> because theres a shared global heap
20:14:52 <carter> sveit: lots and lots of allocating?
20:15:50 <Krenium> But does Haskell really not have looping constructs other than recursion?
20:15:58 <sveit> carter: quite possible :)
20:16:19 <suOya_> Krenium: technically no, since maps, folds, zips and filters are all recursively implemented
20:16:20 <sveit> carter: still getting the hang of Haskell performance engineering
20:16:26 <carter> sveit: i am too
20:16:36 <carter> so on MANY core things, the issue is theres a single heap
20:16:49 <carter> wherase you'd like to think of each thread as working indepedently
20:16:50 <carter> right?
20:16:53 <suOya_> Krenium: but once you get accustomed to those, you'll miss them when you go back to loops in imperative languages ;)
20:17:30 <GeraldCode> sorry if anyone was trying to respond to my pleas for help..my connection got messed up
20:17:39 <carter> GeraldCode: soke
20:17:40 <suOya_> > map succ [1..10]
20:17:41 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:17:45 <sveit> carter: yeah i would, i don't know much about the shared heap aside from that it's there. btw putting those options into the .cabal file under the "ghc-options" line should work, right?
20:17:53 <carter> sure
20:17:58 <GeraldCode> hello carter, what does 'soke' mean?
20:18:00 <carter> which options
20:18:02 <carter> its oke
20:18:06 <GeraldCode> ah
20:18:46 <carter> :)
20:18:51 <carter> i'm very very idiomatic
20:18:58 <suOya_> > let 2 + 2 == 5 in 2 + 2
20:18:59 <carter> both in natural language and hakell
20:19:00 <lambdabot>  <hint>:1:16: parse error on input ‚Äòin‚Äô
20:19:15 <suOya_> > let 2 + 2 = 5 in 2 + 2
20:19:17 <lambdabot>  5
20:19:29 <sveit> carter like "-O2 -threaded -rtsopts"?
20:19:35 <carter> yeah
20:19:35 <carter> sure
20:19:52 <carter> and then you can add +RTS  -fsveitFlags -RTS to the end of your CLI invocation
20:23:08 <sveit> carter: in my case +RTS -N4 -RTS, right? just ran with criterion, got average runtime ~31.3 seconds, so better, but not a 4x increase
20:23:22 <carter> sveit: so maybe your concurrenc model is wrong
20:23:26 <carter> are you allocating a lot?
20:23:32 <carter> any way you could reuse mem
20:23:34 <carter> or allocate less?
20:23:50 <sveit> carter: i create new 300x300 vectors on every call of a certain function. could this be killing me?
20:23:58 <carter> hrmm
20:24:01 <carter> sveit: what OS are you on?
20:24:03 <carter> and what GHC version
20:24:06 <sveit> carter: mac os x
20:24:17 <sveit> carter: ghc 7.8.2
20:24:52 <carter> sveit: i've got a 7.8.3 build
20:24:57 <carter> wanna update :)?
20:25:03 <carter> lemme upload it first
20:26:12 <sveit> carter: well i'd like to figure out what's going on, but i may do that later :) updating ghc is a pain i don't want to go through right now
20:26:20 <carter> kk
20:26:21 <carter> well
20:26:29 <carter> could you share the dirrty code?
20:26:34 <carter> you've got my attention anyways
20:27:58 <carter> sveit: crazy idea, how many invocations of that function that allocates are live at a time?
20:28:08 <carter> and is it then immediately calling the fortran?
20:33:07 <sveit> carter: i'm cleaning up the code for you (just a tiny bit) putting it up in a sec
20:33:11 <carter> :)
20:36:23 <sveit> ok, here is a minimal example. the back-end code for eigvecs is pretty huge on its own, so hopefully you can see something here: http://lpaste.net/124108268338413568
20:41:55 <sveit> carter: the thing that's bothering me is the relatively small speed boost from parallelism. it's purely mathematical, and when i run (just did) with +RTS -N4 -sstderr -RTS, i get 103.28 seconds MUT and 10.88 seconds in GC (30.56 and 0.48 elapsed seconds respectively) so it doesn't seem as though lots of time is spent in GC
20:42:26 <carter> sveit: lemme tease out a teeny thing i did in work code
20:45:27 <carter> sveit: you do realize each parallel bit could hop cores?
20:45:31 <carter> could you try -N2?
20:45:37 <carter> how long is each fun call?
20:46:58 <sveit> each call to eigvecs is ~0.13 seconds
20:47:02 <carter> ok
20:47:05 <sveit> haven't benchmarked the other code
20:47:15 <carter> sveit: can you reuse the matrix for new work after each call?
20:47:50 <sveit> which one? the large "work" one in eigvecs? yes...
20:47:57 <sveit> also just tried -N2, that was the fastest
20:48:00 <sveit> what is going on
20:48:00 <carter> k
20:48:07 <carter> perf engineering is hard :)
20:48:09 <carter> ok
20:48:10 <carter> now
20:48:37 <ais523_> I'm trying to write a program where I build up a "main" function a bit at a time (to fit better with the flow of the code); in OCaml, I'd do "let main = foo [...] let main = main; bar [...] let main = main; baz" and so on; is it possible to do something like this in Haskell without changing the variable names?
20:48:59 <carter> sveit: have you run any profiling?
20:49:05 <ais523_> the closest I can get is "main1 = foo [...] main2 = main1 >> bar [...] main3 = main2 >> baz" and so on
20:49:06 <carter> GHC has GREAT proviling profiling tools
20:49:21 <sveit> carter: well i'm runing with -sstderr
20:49:26 <carter> no
20:49:28 <sveit> probably not the most advanced stuff :)
20:49:29 <carter> heap profiling
20:50:11 <sveit> thing is i read online that heap profiling is useful if i am doing lots of gc. gc ~ 10% of my running time though, so how could that help?
20:50:18 <sveit> of course i trust you, just trying to understand
20:50:46 <carter> lets view it as a learning exercise
20:50:48 <carter> "try all the tools"
20:51:12 <gamegoblin> Can soeone tell me why these are different? In the first one, everything works as expect, in the second one, it seems the IO action doesn‚Äôt get executed: http://lpaste.net/107321
20:51:19 <carter> sveit: one reason to upgrade ot 7.8.3 is that the  event log tooling got fixed
20:51:24 <carter> its slightly busted in 7.8
20:51:26 <carter> .2
20:53:13 <systemfault> Haha, love the typeclassopedia page
20:53:16 <systemfault> ‚ÄúWhen I asked how to do something I thought was really complicated, people started typing things like zip.ap fmap.(id &&& wtf) and the scary thing is that they worked! Anyway, I think those people must actually be robots because there‚Äôs no way anyone could come up with that in two seconds off the top of their head.‚Äù
20:53:26 <systemfault> That‚Äôs actually what I thought :)
20:53:38 <carter> well
20:53:45 <carter> try stuff and see what happens
20:53:48 <carter> you wont break your computer
20:54:04 <suOya_> systemfault: Why would you think we, the people here on this friendly channel, would be robSegmentaion fault
20:54:13 <systemfault> Hahaha
20:54:31 <carter> sveit: any heap profiles yet?
20:55:14 <gamegoblin> Guys, what‚Äôs the difference in ` liftM f x ` and ` x >>= \y -> f y `
20:55:21 <ais523_> gamegoblin: I've just ben workign it out
20:55:24 <sveit> carter: trying it, it seems i have to install everything with profiling?
20:55:34 <gamegoblin> ais523_: thanks, appreciate any ideas.
20:55:39 <carter> i have that enabled in my ~/.cabal/config file
20:55:56 <carter> sveit: try cabal configure --enable-executable-profiling ; cabal build
20:56:13 <carter> but yeah, you may have to destroy the universe
20:57:38 <suOya_> gamegoblin: you can't do that AFAIK, in order for those two to be equal, the second one should read: x >>= \y -> return (f y)
20:57:42 <sveit> carter: you familiar how to do that kind of stuff with sandboxes? this is going to take forever :)
20:57:54 <carter> sveit: i just blow up the universe
20:58:00 <carter> sveit: ohhh
20:58:03 <carter> you have a stale cabal file
20:58:04 <gamegoblin> suOya_: what if f returns something that‚Äôs in the same monad
20:58:05 <carter> dont you
20:58:17 <carter> sveit: check  if ~/.cabal/config has a line saying $ncpus
20:58:28 <carter> or a line about haddock options
20:58:38 <carter> also cabal --version
20:58:46 <ais523_> gamegoblin: I'd just figured out what suOya_ just told you
20:58:56 <ais523_> there's an extra "return" in the liftM
20:59:00 <gamegoblin> gotcha
20:59:03 <gamegoblin> I have an ` IO a ` and an ` a -> IO () `
20:59:05 <suOya_> > let f x = Just x in liftM f (Just 5)
20:59:06 <lambdabot>  Just (Just 5)
20:59:07 <gamegoblin> What‚Äôs the best way to apply them?
20:59:11 <suOya_> > let f x = Just x in liftM f (Just 5)
20:59:12 <lambdabot>  Just (Just 5)
20:59:18 <gamegoblin> I understand now
20:59:21 <ReinH> gamegoblin: liftM is equivalent to fmap
20:59:22 <gamegoblin> I was getting an IO (IO ())
20:59:54 <gamegoblin> so I have an ` IO a ` and an ` a -> IO () ` ‚Äî wat do?
21:00:09 <ais523_> gamegoblin: use >>= to combine them
21:00:20 <ReinH> :t (>>=)
21:00:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:00:21 <sveit> carter: yes to ncpus, cabal --version == 1.20.0.1
21:00:24 <avocado> > :t (>>=)
21:00:25 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
21:00:27 <gamegoblin> oh duh
21:00:51 <gamegoblin> dumb moment
21:00:53 <ReinH> m is IO and b is ()
21:01:02 <ReinH> gamegoblin: no worries
21:01:14 <Krenium> Is there some significance behind the type variables ghci uses when you use :t ? For instance :t sum is sum :: Num a => [a] -> a but for my own sum' function it says sum' :: Num t => [t] -> t
21:01:16 <suOya_> > let x = 0 : y; y = 1 : x in x
21:01:17 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
21:01:31 <carter> sveit: ok
21:01:53 <Athas> Krenium: does the default sum have a manually specified type signature using 'a'?
21:02:25 <carter> sveit: how many deps do you have?
21:02:29 <ReinH> Krenium: there might be a few special cases, but otherwise it just looks for unbound identifiers
21:02:32 <carter> 8 cpus === most thigns don't take that long
21:02:34 <ReinH> :t (,)
21:02:35 <lambdabot> a -> b -> (a, b)
21:04:02 <gamegoblin> Is there a fancy word for a function that is a less general version of another function? Like intId x = x :: Int is a less general version of id
21:04:33 <sebastian_> hi all. is there a high quality  url module somewhere on hackage?
21:04:44 <gamegoblin> sebastian_: like a parser or a container or what
21:04:48 <ReinH> sebastian_: what do you want to do with it?
21:04:48 <suOya_> gamegoblin: I don't know, but why would you need that?
21:05:04 <carter> sveit: you could set proffiling : True
21:05:06 <sveit> carter: quite a few :)
21:05:17 <carter> library-profiling: True
21:05:18 <carter> shared: True
21:05:22 <gamegoblin> suOya_: just curious. Like $ is a less general version of id. I was wondering what that relation was called.
21:05:36 <carter> sveit: do you have a deadline
21:05:37 <sebastian_> gamegoblin: ReinH, parser and container, I wanto to modify the url, like removing some path elements, removing fragement, etc
21:05:41 <sveit> carter: in what sense?
21:05:47 <gamegoblin> sebastian_: http://hackage.haskell.org/package/network-2.1.0.0/docs/Network-URI.html
21:05:53 <carter> not sure :)
21:06:11 <sveit> carter: anyway, i'm installing the libraries now, when i run cabal build on my current executable, will running cabal build -p be enough or should i add extra things?
21:06:24 <carter> sveit: hangong a sec
21:06:47 <suOya_> gamegoblin: how are id and ($) similar?
21:06:57 <gamegoblin> suOya_: observe
21:06:58 <gamegoblin> :t id
21:06:59 <lambdabot> a -> a
21:07:02 <gamegoblin> :t ($)
21:07:03 <lambdabot> (a -> b) -> a -> b
21:07:10 <lfairy> suOya_: ($) is a specialization of id
21:07:11 <gamegoblin> == (a -> b) -> (a -> b)
21:07:19 <gamegoblin> == x -> x == id
21:07:20 <suOya_> right
21:07:51 <gamegoblin> I was wondering if there was some neat category theory word for that relation
21:08:22 <suOya_> I guess it's called a zygohistomorphic premorphism
21:08:26 <ReinH> ha
21:08:44 <gamegoblin> oh of course.
21:08:47 <gamegoblin> ...
21:08:55 <suOya_> ;)
21:09:02 <mayski> at this point I'm not even sure if that's a joke or not
21:09:09 <suOya_> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
21:09:27 <mayski> oh lawd
21:09:31 <suOya_> Actually that thing IS a joke if I remember
21:10:24 <mayski> in this channel people just throw out incantations like that
21:10:44 <mayski> :D
21:11:05 <gamegoblin> I once had lunch with a guy who knew haskell before I knew haskell
21:11:09 <suOya_> No wonder people see Haskell as difficult. Monads are just like burritos, I bet if we called them that way we'd have a lot more fans
21:11:10 <gamegoblin> and he kept throwing out crazy terms like that
21:11:20 <gamegoblin> and now that I know some category theory, I am 99% sure he was bullshitting
21:11:45 <dolio> Those terms aren't from category theory.
21:11:47 <sebastian_> gamegoblin: ty
21:11:57 <suOya_> gamegoblin: Sounds like he was pretending
21:12:13 <gamegoblin> dolio: I‚Äôm referring to general large words haskellers tend to use, usually containing ‚Äúmorphism‚Äù or ‚Äúfunctor"
21:12:40 <gamegoblin> catamorphism, endofunctor, etc
21:12:54 <dolio> Catamorphism is another one that isn't from category theory.
21:13:10 <suOya_> Maybe when I'm retired I'll start reading on category theory
21:13:27 <Zekka> What's it from? I don't know a lot of category theory so I've just picked up a general body of words from Haskell
21:13:32 <gamegoblin> dolio: from wikipedia ‚ÄúIn category theory, the concept of catamorphism (from Greek: Œ∫Œ±œÑŒ¨ = downwards or according to; ŒºŒøœÅœÜŒÆ = form or shape) denotes the unique homomorphism from an initial algebra into some other algebra."
21:14:10 <dolio> You won't find a book on category theory with that word in it, I think.
21:15:12 <dolio> It's from a paper on recursion with a basis in category theory, but it's not category theory terminology.
21:15:35 <suOya_> Damn programmers now'days with their fancy words n' learnin'
21:15:56 <gamegoblin> back in my day, all we needed was LABEL and GOTO
21:16:19 <suOya_> Back in my day we punched holes in cards!
21:16:24 <suOya_> Now get off my lawn
21:16:38 <carter> sveit: i need to crash
21:17:06 <ReinH> dolio: "a paper on recursion"? Something something barbed wire?
21:17:15 <dolio> Yeah, taht one.
21:17:38 <gamegoblin> Is there a preferred idiom for:      if x then y else ()      ?
21:17:45 <trap_exit> how do I master haskell?
21:17:52 <suOya_> gamegoblin: What do you mean?
21:17:52 <gamegoblin> using it in a do block, so the () is just a placehodler
21:17:53 <ReinH> gamegoblin: I like ()
21:17:53 <trap_exit> I have this obsession to write idiomatic haskell
21:17:54 <dolio> Programming with bananas, lenses, envelopes and barbed wire.
21:18:00 <trap_exit> what ist he most painful / most effective way to write idiomatic haskell?
21:18:01 <Zekka> gamegoblin: That doesn't sound useful
21:18:05 <Zekka> Do you mean 'when'?
21:18:13 <suOya_> gamegoblin: look into when and unless
21:18:15 <gamegoblin> Zekka: when it probably what I want
21:18:16 <Zekka> (the only member of the () type is (), so y would have to also be ())
21:18:16 <suOya_> :t when
21:18:17 <lambdabot> Monad m => Bool -> m () -> m ()
21:18:18 <ReinH> gamegoblin: you might not want to use placeholders that make your program vacuous ;)
21:18:26 <glguy> Unlike the recursion scheme for learning: katamorphism
21:18:27 <Zekka> gamegoblin: Basically, with your version, y has to be () as well
21:18:27 <dolio> Then after that, other people went crazy and made up other similar words.
21:18:33 <gamegoblin> I mean return ()
21:18:35 <Zekka> because () only has one member
21:18:41 <gamegoblin> IO ()
21:18:44 <Zekka> But right, if you want return () then you want when
21:18:52 <ReinH> const (), actually, since it takes an x and then throws it away and gives back a ()
21:18:52 <dolio> With pseudo-Greek and whatnot.
21:18:53 * hackagebot cublas 0.2.0.0 - FFI bindings to the CUDA CUBLAS and CUSPARSE libraries  http://hackage.haskell.org/package/cublas-0.2.0.0 (bmsherman)
21:18:59 <gamegoblin> Yes, that‚Äôs the information I was hoping to extract from you guys
21:19:04 <gamegoblin> I didn‚Äôt know about whem
21:19:06 <gamegoblin> when*
21:19:12 <gamegoblin> :t when
21:19:12 <lambdabot> Monad m => Bool -> m () -> m ()
21:19:41 <Zekka> trap_exit: Look for repetition in your code and then learn tofactor it out
21:19:48 <Zekka> it'll improve eventually
21:20:07 <ReinH> Zekka: don't forget about ‚ä• :p
21:20:33 <Zekka> ReinH: Fine, I'll retreat to my previous statement. "That doesn't sound useful"
21:20:41 <ReinH> :p
21:21:37 <carter> ReinH: i'll explainmore later, but take away from this evening? thoughts?
21:22:31 <suOya_> > System.Exit.exitSuccess
21:22:32 <lambdabot>  Not in scope: ‚ÄòSystem.Exit.exitSuccess‚Äô
21:23:45 <suOya_> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:23:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:25:36 <ReinH> carter: thoughts: you are awesome
21:26:20 <suOya_> > let fact n = product [1 .. n] in (fact . fact . fact) 5
21:26:24 <lambdabot>  mueval-core: Time limit exceeded
21:28:32 <Krenium> <interactive>: out of memory
21:30:46 <biscarch> So I have this code: http://lpaste.net/8493161694556585984
21:31:09 <biscarch> throwing this error: "Could not deduce (MonadState (HaxlEnv u1) (Handler b (HaxlEnv u))) arising from a use of `get'"
21:31:13 <biscarch> because of line 16
21:31:40 <biscarch> There is a `MonadState v (Handler b v)` already written.
21:31:55 <biscarch> How do I say "u and u1 are the same"
21:46:03 <jle`> Krenium: it often times uses the type in the original definition of the functions
21:46:13 <jle`> the type variables, at is
21:46:29 <jle`> @let somevar = undefined :: q -> v
21:46:30 <lambdabot>  Defined.
21:46:32 <jle`> :t somevar
21:46:33 <lambdabot> q -> v
21:46:37 <ReinH> biscarch: that looks more like the MonadState constraint not being satisfied to me?
21:46:53 <ReinH> if u and u1 are unifiable, the inferrer should be able to do that
21:46:54 <jle`> :t id . somevar
21:46:56 <lambdabot> a -> c
21:47:04 <jle`> :t somevar . somevar
21:47:05 <lambdabot> a -> c
21:47:06 <ReinH> unifiable?
21:47:10 <ReinH> words
21:47:40 <Hafydd> What an offensive name.
21:47:55 <ReinH> Hafydd: ?
21:47:59 <jle`> :t (.)
21:48:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:48:01 <Hafydd> ReinH: ?
21:48:02 <jle`> oh thas why
21:48:09 <jle`> hm.
21:48:09 <ReinH> Hafydd: which offensive name?
21:48:11 <jle`> :t somevar somevar
21:48:12 <lambdabot> v
21:48:13 <Hafydd> ReinH: "somevar".
21:48:16 <ReinH> haha
21:48:22 <ReinH> well it's self-descriptive
21:48:24 <ReinH> what more can you want
21:48:31 <Hafydd> No it isn't.
21:48:31 <jle`> did i accidentally pick a racial slur
21:48:33 <jle`> :|
21:49:16 <jle`> :t \x -> somevar (somevar x)
21:49:17 <lambdabot> q -> v
21:49:19 <ReinH> well, it is some variable
21:49:24 <Hafydd> "somefunc" would have been less offensive. It's a name for a value, not for a "variable".
21:49:33 <jle`> ;D
21:49:39 <jle`> this is how i microtroll
21:49:54 <ReinH> Hafydd: if it isn't a "variable" then I wish the Haskell literature would stop calling it one repeatedly
21:49:55 <ReinH> http://en.wikibooks.org/wiki/Haskell/Variables_and_functions
21:50:24 <Hafydd> ReinH: the point is that calling a variable "variable" is completely useless.
21:50:29 <Hafydd> You can tell it'
21:50:38 <ReinH> yes, and it's a completely useless variable
21:50:39 <Hafydd> s a variable from the context and its capitalisation.
21:50:44 <pjdelport> Well, it can vary from one run to the next
21:50:47 * pjdelport ducks
21:51:01 <ReinH> so it's meta-self-descriptive
21:51:06 <biscarch> ReinH: yea, it is. but the two `u`s should be the same thing
21:51:08 <Hafydd> It's comparable to: return 0; // returns 0.
21:51:59 <Hafydd> @let somevar = "somevalue"
21:52:00 <lambdabot>  .L.hs:150:1:
21:52:00 <jle`> is it comparable to naming a variable x? :P
21:52:00 <lambdabot>      Multiple declarations of ‚Äòsomevar‚Äô
21:52:00 <lambdabot>      Declared at: .L.hs:149:1
21:52:00 <lambdabot>                   .L.hs:150:1
21:52:17 <Hafydd> No.
21:52:18 <pjdelport> Also, to be strict, "variable" doesn't necessarily mean it changes, but that it's *changeable* (for example, by substituting it with its value)
21:54:34 <ReinH> We are arguing about a variable named "somevar". It's glorious.
21:56:31 <mayski> :D
22:02:44 <jle`> someargument
22:03:58 * hackagebot peyotls 0.0.0.23 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.23 (YoshikuniJujo)
22:12:45 <trap_exit> is anyone working on adding dependent types to haskell?
22:23:42 <tgeeky> trap_exit: not as such, no; but people are doing precursor steps to that
22:24:06 <tgeeky> if you want dependent types and you want to use haskell, use agda
22:32:40 <johnw> is MVector much faster than MArray?
22:32:55 <johnw> I want the fastest thing possible for an array of fixed length that will undergo constant mutation
22:33:04 <johnw> (it the heap for a simulator)
22:35:06 <Cale> johnw: The main advantage of vector in general vs. the array types would probably be stream fusion. I would expect if you're just directly mutating bits, they should be fairly similar, but I haven't tested.
22:35:22 <codygman> I have the following function in the WebDriver monad which can potentialy throw an error, what is the best way to short circuit the function on error and print out the error message?  This will eventually be in a forever loop, and I'd like this a failure on this function to be logged but not crash the entire program: http://lpaste.net/107324
22:35:35 <Cale> johnw: Well, you also won't be implicitly paying for Ix
22:35:59 <johnw> right
22:36:22 <trap_exit> generally, is it better to buy a house or rent + invest the money?
22:36:32 <johnw> not a question for #haskell
22:36:39 <Cale> codygman: Perhaps take a continuation as a parameter and call that on failure?
22:36:44 <glguy> trap_exit: Are you about to draw a parallel to laziness?
22:36:58 <trap_exit> glguy: you take a shot first
22:37:26 <Cale> codygman: i.e. take an IO () action or a function like ErrorMessage -> IO () as something to use if there's an error
22:39:01 * hackagebot thyme 0.3.5.2 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.2 (LiyangHu)
22:39:03 <codygman> Cale: This is my first experience with error handling in Haskell. I almost feel like I get what you mean, but could you give me a small example? Also any error handling tutorials/best practices you can refer me to?
22:39:45 <Cale> actually, let me look more closely at what you're doing here
22:39:50 <Cale> There are a lot of options
22:40:05 <Cale> I don't know what the WebDriver m constraint entails
22:40:54 <codygman> Cale: Thanks. Yeah, I came across this article saying the same: http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/
22:41:28 <Cale> I think it's reasonable for there to be a lot of options for reporting errors, because there are a lot of different kinds of things we refer to as errors
22:41:45 <johnw> yes, there is definitely a "gradient"
22:41:58 <platz> codygman: also see this http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
22:42:20 <johnw> there are error values, error conditions, and then things that are truly exceptional which almost never happen, and yet you'd like to account for them without having to make it explicit throughout your code (like out of memory errors)
22:44:11 <Cale> codygman: Could you show me the code for the loop and the code which calls the loop?
22:45:28 <Cale> codygman: What do you want the program to do exactly when there is a failure? Report the error and continue looping?
22:45:51 <codygman> Cale: Sure: http://lpaste.net/107324
22:46:40 <ReinH> "No reason to use this, it‚Äôs around for hysterical raisins." <3
22:46:58 <Cale> codygman: Oh, right, you said you hadn't written the forever yet :)
22:48:01 <Cale> codygman: It's possible that if you just have some loop calling itself, like if instead of False -> return () you had  False -> buyDomain <other params>
22:48:39 <Cale> codygman: Then in the True case you'd just log the error however you wanted to do that, and then go on with the same buyDomain ... stuff, or perhaps repeat with the same parameters
22:50:39 <codygman> Cale, so I would have something like: res <- buyDomain paypalCreds domain and then pattern match on it?
22:51:01 <Cale> codygman: Well, I'm assuming there that buyDomain is the thing which never terminates, which probably isn't correct
22:51:21 <codygman> Cale: I think webdriver uses ioError
22:51:24 <Cale> codygman: But whatever the loop is -- whichever IO action executes itself at the end
22:51:54 <Cale> If you want to break out of the loop, one of the easiest ways is just to have the looping IO action just not execute itself again
22:52:06 <Cale> (requires no fancy machinery, exceptions, or anything)
22:53:41 <Cale> like you have something schematically like  loop = do ... some stuff ... ; loop
22:54:02 * hackagebot cublas 0.2.0.1 - FFI bindings to the CUDA CUBLAS and CUSPARSE libraries  http://hackage.haskell.org/package/cublas-0.2.0.1 (bmsherman)
22:54:59 <Cale> and you change that to   loop = do ... some stuff ... ; case someResult of Left s -> print s; Right () -> loop  -- (or something like that)
22:55:37 <codygman> Cale: The loop has to be called again I think. I have a database with a list of domains and the forever loop will be calling checkDomain >>= if True then buyDomain else return() continuously iterating over all of those domains. Perhaps I'm overthinking this and that is why it seems unclear.
22:56:07 <codygman> that isn't valid syntax idt, but hope you see what I mean
22:57:27 <Cale> yeah, try actually writing the loop, and it'll probably amount to just deciding whether you want to either write a message into a log file, maybe sleep for a bit and then call your thing with the same parameters to try again, or else call your function with the tail of the list of of domains to buy to move along
22:57:45 <Cale> The thing will presumably take a list of domains and try to buy them all?
22:58:04 <mbuf> is there a way to sink mplayer to a frame instead of showing up as a float? using xmonad 0.11 on Fedora 20 (x86_64)
22:58:19 <codygman> Cale: That is correct. I think you're right, I need to write the loop and then I'll probably be able to figure things out more easily.
22:59:46 <mbuf> saw this thread http://web.archiveorange.com/archive/v/j8BnAkUlxOaCwfDyNJtG, but it is a bit old
23:18:14 <FUZxxl> Moin.
23:19:51 <Heather> how to iterate some list but make specific task on last element...
23:23:35 <isomorpheous> Heather: hm?
23:24:23 <Heather> isomorph like forM_ but with specific task on last elem... I think I should do it recursive
23:24:35 <suOya_> How can I grok monad transformers? I'd like to combine State and Maybe, but can't wrap my head around transformers ...
23:25:00 <Cale> Heather: do forM_ xs (\x -> ...); otherTask?
23:25:54 <Cale> Heather: Or does the other task need to be mixed in? I suppose you could always tag the elements of the list in a way which makes the last one obvious somehow
23:26:03 <Heather> Cale: yes possibly like that but it will fail if list is empty
23:26:22 <Heather> Cale: I want mixed in otherTask, for last elem
23:26:49 <glguy> Do you want to work with. s -> Maybe (a,s).   Or s -> (Maybe a, s) ?
23:27:34 <Heather> Cale: you mean add some indexes and check ifLast everytime? looks not so good
23:27:35 <Cale> Heather: Perhaps something like forM_ over tails xs
23:28:03 <Cale> Heather: and then pattern match on the tails to handle the [x] case differently
23:28:20 <Heather> Cale: will it be sane-optimized? :S
23:28:24 <Cale> yes
23:28:29 <Cale> That's a sane thing to do
23:28:40 <merijn> Cale: How about "forM" over "zip xs (tails xs)" and special case when snd is empty list?
23:28:48 <merijn> Cale: Seems like it'd be more efficient...
23:28:54 <Cale> yes, that'll also work nicely
23:29:01 <orzo> is there an idiom for implementing a short-circuiting foldl ?
23:29:07 <Cale> and you don't have the awkward empty case
23:29:09 <suOya_> glguy: s -> Maybe (a, s)
23:29:25 <Cale> suOya_: StateT s Maybe a
23:29:43 <Heather> merijn: for what zip?
23:29:50 <Cale> orzo: I'm not sure what a short-circuiting foldl is.
23:29:53 <glguy> Orzo you can use foldM and Either
23:30:10 <johnw> orzo: what do you want to use it for?
23:30:21 <jle`> suOya_: do you understand how the s -> (a, s) monad instance works?
23:30:27 <johnw> simple-conduit is a library effectively built around foldM and Either
23:30:34 <jle`> suOya_: as in, could you write (>>=) and return yourself?
23:30:52 <jle`> suOya_: if so, it would hardly be any more difficult to write an instance for s -> Maybe (a, s) :)
23:31:07 <jle`> without transformers ofc.
23:31:11 <Cale> yeah, you replace let with do, pretty much
23:31:29 <orzo> johnw: well, i have a list of things to process, but i can stop processing once a condition is met
23:31:37 <jle`> instead of let x = y in z, it's just do x <- y; return z, more or less
23:31:43 <Cale> and add a return (for m) in the implementation of return (for StateT s m)
23:31:45 <jle`> suOya_: for a general introduction to monad transformers, i like http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
23:32:18 <johnw> orzo: that's kind of my library is about :)
23:32:18 <Cale> Maybe I should just do this :)
23:32:26 <johnw> kind of what*
23:32:29 <orzo> so i have a processing function f :: x -> st -> st and a predicate p :: st -> Bool and a list of objects xs :: [x]
23:32:38 <Heather> Cale: is there way to simplify forM_ (tails xs) $ \a ->  case a of | [x::xs] ... ?
23:32:44 <jle`> the transformey solution to your problem is to define a general monad instance for s -> m (a, s)...and then use Maybe for your m.  to get s -> Maybe (a, s) :)
23:32:53 <suOya_> jle`: That paper uses some kind of a custom language as an example which I don't get :/
23:32:57 <jle`> the transformer library already defines a monad instance for s -> m (a, s)
23:33:07 <jle`> but i recommend you define your own, for funsies.
23:33:08 <Cale> Heather: You could use the new \case syntax
23:33:23 <jle`> suOya_: do you understand State?  chaining s -> (a, s)'s?
23:33:25 <orzo> i want st' = foldl f st xs, but have it stop when p st is true
23:33:29 <suOya_> jle`: yeah
23:33:41 <jle`> suOya_: can you implement your own (>>=) and return for a newtype wrapper around s -> (a, s)?
23:33:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
23:33:54 <suOya_> jle`: with some effort yes
23:34:14 <orzo> i could use glguy's suggestion probably, but it does seem slightly awkward
23:34:35 <jle`> suOya_: try it yourself as a reminder; write an s -> (a, s) -> (a -> (s -> (b, s))) -> (s -> (b, s))
23:34:49 <jle`> there should be parenthese around the first (s -> (a, s))
23:34:51 <Heather> Cale: thanks, interesting trick
23:35:19 <jle`> suOya_: then wrap it in a newtype, like newtype State s a = State { runState :: s -> (a, s) }
23:35:25 <glguy> Orzo you can write it as a right fold
23:35:29 <jle`> and define (>>=) and return for it.  (>>=) is just the function i mentioned above
23:35:44 <suOya_> I know, I just wrote that because I'm practising using the state monad right now, I just wanted to combine it with Maybe because I'm building a deque where I want the computation to return Nothing if the deque is empty
23:35:58 <glguy> Without losing your left accumulating behavior
23:36:06 <jle`> then, consider function Monad m => (s -> m (a, s)) -> (a -> (s -> m (b, s))) -> (s -> m (b, s))
23:36:10 <jle`> try writing that :)
23:36:18 <suOya_> I wrote that already 15min ago ^^
23:36:36 <jle`> throw it into a newtype, newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
23:36:39 <jle`> suOya_: ah, you did?
23:36:46 <Cale> Heather: zip xs (map (null . tail) (tails xs)) would also work, you could match on (x,True) vs. (x,False)
23:37:01 <jle`> suOya_: are you having trouble using it?
23:37:21 <johnw> orzo: foldM (\st x -> if p st then <compute new st from st and x> else return st) xs
23:37:30 <johnw> oh, insert <initial st> before xs
23:37:38 <suOya_> no I haven't even tried the transformer yet, I just wrote the standard (>>=) for State a moment ago
23:37:54 <suOya_> I'll look up on how to use StateT s Maybe a
23:37:56 <glguy> http://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b
23:38:03 <jle`> suOya_: try writing it first
23:38:15 <jle`> the (StateT s m) Monad instance
23:38:37 <jle`> Monad m => (s -> m (a, s)) -> (a -> (s -> m (b, s))) -> (s -> m (b, s))
23:38:38 <glguy> Orzo write it like the last fold example and don't call rec when you want to escape
23:38:51 <jle`> Monad m => s -> m (a, s)
23:38:53 <jle`> er
23:38:59 <jle`> Monad m => a -> (s -> m (a, s))
23:39:05 <Cale> I recommend not unfolding the definition of StateT like that
23:39:07 <suOya_> jle`: I'm not sure how to do that but I'll try
23:39:12 <orzo> glguy: i think i managed it, but i couldnt load your example as it wants some login
23:39:12 <jle`> Cale: why not?
23:39:13 <glguy> If you don't want to do explicit recursion or foldM
23:39:23 <Cale> Because it's easier to think about if you explicitly apply runState
23:39:28 <Cale> or runStateT
23:39:36 <jle`> suOya_: it should look very, very similar to your State definition
23:39:54 <jle`> Cale: idk, that way sort of feels magicky to me :/
23:39:57 <Cale> In fact, I'll do State here
23:40:05 <glguy> The example is just reddit and shouldn't need a login...
23:40:10 <johnw> orzo: ah, n/m, my foldM example wasn't short-circuiting
23:40:46 <suOya_> jle`: moment...
23:41:08 <Cale> So, remember that our goal with State is to represent computations which manipulate a state value of type s while producing some result of type a, and since we're working with a functional programming language, a natural representation for those is as functions which take an initial state of type s, and produce some final state of type s along with the result of type a:
23:41:14 <orzo> glguy: here's a paste from my code, does it look right? http://lpaste.net/107326
23:41:17 <Cale> data State s a = S (s -> (s,a))
23:41:41 <Cale> Then, to run one of those computations on a given initial state, we can just unpack the function and apply it:
23:41:51 <Cale> runState :: State s a -> s -> (s,a)
23:41:57 <Cale> runState (S f) s = f s
23:42:42 <glguy> Orzo. Seems right to me
23:42:43 <orzo> glguy: i think i see an error on line 2, i meant to refer only to st' and not st after the =
23:42:43 <Cale> return :: a -> State s a  is meant to produce the computation which "does nothing" to the state, but has the given value as its result:
23:43:07 <suOya_> jle`: I'll show the return definition soon...
23:43:13 <Cale> return v = S ... -- we might as well use the S constructor, as we have no other way to make State s computations yet
23:43:22 <suOya_> jle`: Mind you this is the first time I'm trying to grok transformers!
23:43:30 <Cale> return v = S (\s -> ...) -- and S takes a function s -> (s,a) as a parameter, so it might as well be a lambda
23:43:43 <Cale> return v = S (\s -> (s,...)) -- the final state is the same as the initial state
23:43:50 <Cale> return v = S (\s -> (s,v)) -- and the result is v
23:44:20 <Cale> Now, for bind:  (>>=) :: State s a -> (a -> State s b) -> State s b
23:44:48 <Cale> x >>= f is meant to be the action which first runs x on the initial state s, getting some new state s' along with an intermediate result v :: a
23:45:15 <Cale> and then runs f v :: State s b on the state s', getting some final state and result, which will be the final state and result of the whole computation
23:45:19 <Cale> So:
23:45:43 <Cale> x >>= f = S (\s -> ...) -- again, might as well use S and might as well use a lambda, getting the initial state s
23:46:13 <Cale> x >>= f = S (\s -> let (s', v) = runState x s ...) -- we run the action x on the initial state s, getting some new state s' and result v
23:46:44 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'',w) = runState (f v) s' ...) -- we then run the action f v on the new state s', getting some final state s'' and result w
23:46:45 <suOya_> jle`: are you there?
23:46:50 <jle`> suOya_: yes
23:46:58 <bollu>    
23:47:00 <Cale> x >>= f = S (\s -> let (s', v) = runState x s; (s'',w) = runState (f v) s' in (s'',w)) -- which become the final state and result of the whole computation
23:47:33 <suOya_> so for instance Monad (StateT s m), I have the return defined as follows: return x = StateT $ \s -> return (a, s)
23:47:35 <jle`> suOya_: you will also want lift :: m a -> (s -> m (a, s)) .... or lift :: m a -> StateT s m a
23:47:46 <Cale> suOya_: right
23:47:55 <jle`> suOya_: not quite, have you tried to typecheck/compile it?
23:47:59 <Cale> er
23:48:05 <jle`> but you get the picture :)
23:48:07 <suOya_> yeah it cant be right...
23:48:15 <Cale> yeah, the x vs. a is just a typo
23:48:19 <jle`> return x = StateT $ \s -> return (x, s)
23:48:21 <jle`> yeah :)
23:48:33 <suOya_> but how does the compiler know which 'return' I'm referring to?
23:48:38 <jle`> it doesn't help that people commonly use s for both the state type and the state value
23:48:40 <Cale> suOya_: context
23:48:56 <Cale> suOya_: When it typechecks the expression, it works out which instance must be in use
23:49:03 <jle`> suOya_: well, it is instance Monad m => Monad (StateT s m) where ...
23:49:10 <suOya_> oh yes
23:49:16 <jle`> which says StateT s m is Monad for any s and any m where...
23:49:22 <Cale> (that's how type classes work -- the instance parameter which is implicitly passed in depends on which type is inferred for the term)
23:49:36 <jle`> so if you have a StateT s Maybe, then return is the Maybe's return
23:49:45 <suOya_> alright
23:49:56 <suOya_> I'll now try to write the signature for (>>=)
23:50:00 <Cale> and when you're writing this instance, you'll have  instance (Monad m) => Monad (StateT s m)
23:50:16 <Cale> and it'll be this (Monad m) instance which it'll use
23:50:19 <jle`> Cale: i see what you are saying; understanding State as an encapsulation for an action?  however, for me, i never understood State until i saw the unrolling
23:50:43 <jle`> i had seen it presented before as such; but it might just be me
23:50:53 <Cale> suOya_: So, writing the code for (>>=) is much the same thought process as I went through above for (>>=) in State
23:50:59 <Cale> suOya_: But you use do-notation instead
23:51:08 <suOya_> jle`: (Monad m) => State s m a -> (a -> State s m b) -> State s m b
23:51:10 <suOya_> is that correct?
23:51:11 <Cale> x >>= f = StateT (\s -> ...)
23:51:15 <jle`> being able to lok at State s a and think "oh, that's just a type synonym for s -> (a, s)" made everyhting...click for me
23:51:17 <suOya_> oh right StateT
23:51:33 <jle`> suOya_: you won't need the Monad contsraint because it's already in the instance declaration :)
23:51:38 <jle`> but yeah
23:51:38 <Cale> x >>= f = StateT (\s -> do (s', v) <- runStateT x s; ...) -- we run the action x getting some new state s' and result v
23:51:51 <jle`> actually you can't even put a type signature in an instance declartion; what am i saying
23:52:14 <Cale> x >>= f = StateT (\s -> do (s', v) <- runStateT x s; (s'',w) <- runStateT (f v) s') -- we then run the action (f v) on the newer state s', getting some final state s'' and result w
23:52:29 <Cale> x >>= f = StateT (\s -> do (s', v) <- runStateT x s; (s'',w) <- runStateT (f v) s'; return (s'',w)) -- which we return
23:52:39 <suOya_> don't spoil it!
23:52:50 <Cale> (note, I'm using the opposite convention for the pairs, because I prefer it)
23:53:22 <jle`> suOya_: if you wrote code for State, it'll look very familiar to the code you will write for StateT :)
23:53:44 <suOya_> yes it does
23:54:58 <Cale> One thing I often like to fit in between is a discussion of how to implement a monad for parsers
23:55:32 <Cale> A parser for things is a function from strings to lists of pairs of strings and things:
23:55:35 <suOya_> I'll gladly stay out of that discussion for now
23:55:46 <Cale> data Parser a = P (String -> [(String, a)])
23:56:04 <Cale> But this is exactly the same thing as  StateT String []
23:56:11 <knapper_tech> What's a motivating example for monad transformers
23:56:12 <knapper_tech> ?
23:56:19 <Cale> ^^ If anything is, that is.
23:56:28 <johnw> knapper_tech: ReaderT r m a is a classic
23:56:35 <Cale> Monad transformers are highly overrated in general
23:56:45 <johnw> I really like monad transformers
23:56:49 <Cale> They get used in a lot of cases where people probably shouldn't be using them
23:57:03 <suOya_> knapper_tech: The name itself. Tell your programmer friends you know how to use MONAD TRANSFORMERS and they'll shit their pants in awe
23:57:08 <johnw> that's true of many features, Cale
23:57:34 <johnw> i mean, we _could_ do just about everything using plain functions
23:57:46 <Cale> I only use monad transformers in cases where I can ensure the users of the library won't be able to tell that I'm using monad transformers
23:57:49 <frerich> Cale: I can't help but weep at the poetic beauty of that Parser type description. :-)
23:58:19 <Cale> frerich: Dr. Seuss does parsing :D
23:58:36 <Cale> (it's not actually my rhyme, I heard it somewhere a long time ago)
23:58:38 <knapper_tech> Cale:   lol.  My current issue is using Heist and how it seems destined to be plugged into some monad trasnformer stack thing
23:58:57 <knapper_tech> johnw: Do you know a place where I can dig up a ReaderT example?
23:59:19 <knapper_tech> I'm still very bad at evaluating the content of Google results
23:59:21 <johnw> use ReaderT to pass around an "environment" in a command-line app that would otherwise be in IO and pass environment values everywhere
23:59:31 <codygman> > help
23:59:32 <lambdabot>  Not in scope: ‚Äòhelp‚Äô
23:59:43 <suOya_> lambdabot is cruel
23:59:45 <Cale> > fix error
23:59:47 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:59:54 <codygman> LOL
23:59:55 <dwcook> Cale, I've seen a monad used when a monoid would do; is this misuse along those lines or something else?
