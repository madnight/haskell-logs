00:00:41 <ruuns> Hallo :)
00:00:50 * hackagebot lens 4.3.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.3.1 (EricMertens)
00:11:34 <blakehaswell> Hi
00:11:45 <ruuns> Hey :]
00:13:48 <TallerGhostWalt> I am trying to use CPP and #if , it is taking it in one file but not another.
00:15:20 <TallerGhostWalt> Really odd
00:15:36 <blakehaswell> I created a little command line utility today, would you mind reviewing the code a little and let me know where I could look to make improvements?
00:15:38 <blakehaswell> https://github.com/blakehaswell/expose
00:20:37 <cmears> blakehaswell, I have a feeling that "return . map (dir </>) =<< getDirectoryContents dir" can be written differently
00:20:42 <zq> dolio: i didn't understand. are you saying that having local scope imports makes parsing harder?
00:20:50 <cmears> like "map (dir </>) <$> getDirectoryContents dir"
00:21:38 <blakehaswell> Ah, I need to get a better understanding of applicatives
00:21:50 <Cale> Yes, return . f =<< x can always be rewritten as fmap f x or f <$> x
00:22:17 <Cale> All you need is Functor, not even Applicative
00:22:25 <Cale> <$> is the applicative notation for it though
00:22:46 <cmears> I only know enough to recognise these patterns, like the one Cale says
00:22:56 <cmears> I don't have the deep, satisfying understanding yet (:
00:23:00 <glguy_> blakehaswell: You might learn about the System.Console.GetOpt module so that you can parse command line flags like normal utilties
00:23:19 <glguy_> it will handle things like "-ab" being the same as "-a -b" etc
00:23:47 <blakehaswell> Ah, I was a little disappointed that my implementation couldn't handle that, I'll take a look :-)
00:24:56 <blakehaswell> Ah, fmap, of course. Really need to go back and study functors some more
00:25:41 <cmears> blakehaswell, we should really start by saying that overall the program looks nice before we pick away at it (:
00:26:07 <ruuns> nicely small :)
00:26:09 <gamegoblin> > return (return (return 5))) :: [Maybe [Int]]
00:26:10 <lambdabot>  <hint>:1:27: parse error on input ‘)’
00:26:17 <genzoon> is it possible to add two Maybe Ints without checking all the combinations of Just/Nothing?
00:26:20 <gamegoblin> return (return (return 5)) :: [Maybe [Int]]
00:26:22 <cmears> ruuns, yes, I tried to scroll down to see the rest but nothing happened!
00:26:27 <blakehaswell> Thanks :-)
00:26:33 <gamegoblin> genzoon: fmap (+) (Just 5) (Just 3)
00:26:46 <gamegoblin> > fmap (+) (Just 5) (Just 2)
00:26:47 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a1 -> t’
00:26:47 <lambdabot>              with actual type ‘Data.Maybe.Maybe (a0 -> a0)’
00:26:54 <jle`> genzoon: liftA2
00:26:56 <gamegoblin> I mean LiftM2
00:26:56 <zwer> > liftA2 (+) (Just 5) (Just 2)
00:26:57 <lambdabot>  Just 7
00:26:58 <gamegoblin> or LiftA2
00:26:59 <gamegoblin> whoops
00:27:18 <jle`> or you can use the various applicative combinators to lieft arbitrary-arity functions
00:27:19 <gamegoblin> Is LiftA2 any faster than M2?
00:27:24 <genzoon> cool thanks!
00:27:28 <jle`> > (+) <$> Just 5 <*> Just 7
00:27:30 <lambdabot>  Just 12
00:27:30 <jle`> ^^ genzoon
00:27:35 <Cale> gamegoblin: Maybe in some cases, but in general, no
00:27:52 <jle`> when you see it, you're supposed to basically imagine that the <$> and <*> aren't there, and it's like "normal function application"
00:27:56 <gamegoblin> > return (return (return 5)) :: [Maybe [Int]]
00:27:57 <lambdabot>  [Just [5]]
00:28:07 <gamegoblin> lots of returns of different types are hilarious to me
00:28:25 <jle`> > (\x y z -> x + y * z) <$> Just 1 <*> Just 9 <*> Just 4
00:28:26 <genzoon> jle`: I see. I think liftA2 is easier on my eyes
00:28:27 <lambdabot>  Just 37
00:29:00 <genzoon> :t liftA2
00:29:01 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:29:05 <gamegoblin> I have a bad habit of using liftM{N} for everything when I could use fmap or liftA or something instead
00:29:30 <gamegoblin> I liftM into maybes rather than fmapping oftentimes
00:29:34 <jle`> i try to use the generalest thing possible
00:29:41 <genzoon> that signature is way over my head
00:29:48 <adimit> <*> <$> and friends are easier on the eyes once you get used to applicative style. It's actually very useful.
00:30:14 <jle`> yeah, and it sort of abstracts away having to use fmap, liftA2, liftA3, etc.
00:30:25 <jle`> f <$> Just 1
00:30:30 <jle`> f <$> Just 3 <*> Just 5
00:30:36 <jle`> f <$> Just 3 <*> Just 5 <*> Just 9
00:30:53 <adimit> I find the various lift*n really ugly.
00:31:13 <genzoon> adimit: maybe.. but I am not used to either and liftA2 looks clearer to me. I think parens help me group things easier than operators
00:31:14 <jle`> i've gone back and forth
00:31:30 <jle`> between my opinion on what is cleaner
00:31:59 <glguy_> liftXn is nicer in particular when you aren't applying all the arguments directly
00:32:11 <glguy_> somef (liftA2 f)
00:33:43 <blakehaswell> Having seen it again, the applicative syntax is pretty easy to grok, I just need to do some exercises with it to remember it I think
00:33:54 <jle`> i like to think of <$>/<*> as sort of "generalized function application"
00:34:01 <jle`> as in, normally you'd do f 3 5 9
00:34:06 <jle`> with normal values
00:34:08 <genzoon> it is 3am in here and I cant stop learning haskell and writing haskell code
00:34:14 <jle`> but generalize it to things 'inside contexts'
00:34:44 <jle`> so instead f x y z
00:34:51 <jle`> you'd do pure f <*> x <*> y <*> z
00:35:00 <jle`> or f <$> x <*> y <*> z
00:35:33 <genzoon> is pure prefix <$>?
00:35:46 <adimit> genzoon: no, fmap is prefix <$>
00:35:52 <adimit> :t pure
00:35:53 <lambdabot> Applicative f => a -> f a
00:36:04 <adimit> :t (<$>)
00:36:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:37:34 <adimit> :t (pure id <*>)
00:37:35 <lambdabot> Applicative f => f b -> f b
00:37:44 <adimit> :t (id <$>)
00:37:45 <lambdabot> Functor f => f b -> f b
00:38:17 <adimit> (Applicative implies Functor.)
00:40:03 <lunamystry> Hi, I have a directory with both binary files (*.o and *.hi) and text files. I want to process just the text files. How should I go about this?
00:40:35 <gamegoblin> …check the file extensions...?
00:40:52 <adimit> lunamystry: liftM (filter checkPrefix) getDirectoryContents
00:40:54 <adimit> or so.
00:41:12 <jle`> genzoon: basically <*> applies a contextful function to a contextful value
00:41:17 <jle`> > Just (*3) <*> Just 5
00:41:18 <lambdabot>  Just 15
00:41:21 <jle`> like that
00:41:29 <lunamystry> I don't know the file extesions before hand
00:41:40 <adimit> lunamystry: then just filter *out* the o and hi files.
00:41:42 <jle`> genzoon: you can take advantage of partial application and do something like
00:41:49 <jle`> > Just (*) <*> Just 3 <*> Just 5
00:41:50 <lambdabot>  Just 15
00:41:52 <jle`> right?
00:41:54 <gamegoblin> lunamystry: But apparently you can get the filename, so just don’t open the files that don’t end in .txt
00:42:02 <genzoon> I know fmap, I am reading <*>'s signature and documentation but I still cant grasp how it works
00:42:10 <adimit> > pure (*3) <*> Just 5 -- just the same as Just (*3)
00:42:11 <lambdabot>  Just 15
00:42:16 <jle`> genzoon: do you understand Just (*3) <*> Just 5 ?
00:42:21 <jle`> and Just (*) <*> Just 3 <*> Just 5 ?
00:42:23 <genzoon> no
00:42:27 <lunamystry> oh when I say text file I mean *py, *.cpp, *.md
00:43:03 <gamegoblin> lunamystry: regardless of your criteria, you should be able to make a blacklist of files you don’t want, or a whitelist of files you do
00:43:07 <lunamystry> @adimit what is checkPrefix?
00:43:07 <lambdabot> Not enough privileges
00:43:08 <splintax> anyone parsed yaml recently? should i use the yaml package, or yaml-light (HsSyck) wrapper, or something else?
00:43:17 <adimit> lunamystry: it is left as an exercise to the reader.
00:43:25 <splintax> ease of use is more important than performance
00:43:26 <adimit> i.e. you have to write it first.
00:43:56 <blakehaswell> How does Just (*) <*> Just 3 <*> Just 5 work? It is equivalent to (*) <$> Just 3 <*> Just 5
00:44:06 <adimit> blakehaswell: yes.
00:44:17 <jle`> blakehaswell: it's equivalent to (Just (*) <*> Just 3) <*> Just 5
00:44:26 <jle`> which is Just (3*) <*> Just 5
00:44:29 <jle`> which is Just (3*5)
00:44:32 <jle`> which is Just 15
00:44:46 <jle`> genzoon: hm.  would seeing the definition of <*> for for Maybe help?
00:44:51 <supki> splintax: I've only used yaml and it's painless, assuming you're familiar with aeson
00:44:54 <jle`> Just f <*> Just x = Just (f x)
00:44:58 <jle`> _ <*> _ = Nothing
00:44:59 <genzoon> jle maybe..
00:45:23 <genzoon> that looks very simple
00:45:25 <jle`> mhm :)
00:45:30 <jle`> so can you predict what this would be:
00:45:33 <jle`> Just show <*> Just 4
00:45:47 <mkrtem> lunamystry: If you don't know what extensions to look for, there is no way to know for certain which files are binary. Most programs assume a file is binary if it contains a 0 byte.
00:45:49 <genzoon> Just "4
00:45:54 <genzoon> "
00:45:55 <frerich> lunamystry : Instead of using raw System.Directory functions, you might find https://hackage.haskell.org/package/FileManip-0.3.3.1/docs/System-FilePath-Find.html useful
00:45:55 <jle`> mhm
00:46:05 <jle`> how about
00:46:08 <jle`> Just (+) <*> Just 3
00:46:36 <genzoon> let me think
00:46:42 <jle`> first, think what (+) 3 is
00:46:47 <jle`> and then it'll make sense :)
00:46:49 <blakehaswell> Is <*> left associative?
00:47:02 <jle`> blakehaswell: yes, it associates from the left
00:47:09 <lunamystry> thank you. I am checking out System.FilePath.Find now
00:47:11 <blakehaswell> ok, makes sense
00:47:16 <genzoon> (+) 3 is (+3) ?
00:47:20 <jle`> genzoon: yeah :)
00:47:27 <frerich> If I was allowed to only use packages by a single author, I'd probably pick Bryan O'Sullivan. He always does these nicely performing, well-documented hands-down things. :)
00:47:34 <jle`> so Just (+) <*> Just 3 = Just (+3)
00:47:37 <adimit> :i (<*>)
00:47:40 <jle`> now here's the big jump
00:47:50 <jle`> (Just (+) <*> Just 3) <*> Just 5
00:47:50 <splintax> supki: i can't say i'm familiar with aeson, i'm still not very experienced with haskell! but i'll see how it goes :)
00:47:59 <adimit> … oh, lambdabot doesn't do info. blakehaswell, you can always find out operator precedence with :i (in Ghci)
00:48:27 <genzoon> Just (+3) <*> Just 5
00:48:33 <blakehaswell> adimit: thanks
00:48:44 <genzoon> so Just 8
00:49:00 <jle`> genzoon: yeah :)
00:49:10 <jle`> okay, pure for Maybe is Just
00:49:15 <jle`> so pure 4 = Just 4
00:49:21 <genzoon> <*> looks so simple, just takes function out of Just and applies it to value in Just
00:49:27 <jle`> genzoon: yup
00:49:34 <jle`> using it, we can create arbitrary liftAN
00:49:51 <genzoon> by chaining it
00:49:58 <jle`> if f takes 5 arguments, we can do: pure f <*> x <*> y <*> z <*> j <*> k
00:50:13 <jle`> now there's this Applicative law that says pure f <*> x = fmap f x
00:50:31 <jle`> and...it kind of makes sense, right?
00:50:33 <genzoon> :t pure
00:50:34 <lambdabot> Applicative f => a -> f a
00:50:39 <jle`> pure for Maybe is Just
00:50:47 <jle`> fmap (+3) (Just 5)
00:50:49 <jle`> should be the same as
00:50:54 <jle`> Just (+3) <*> Just 5
00:51:13 <genzoon> yes
00:51:38 <jle`> so instead of f <*> x <*> y
00:51:46 <jle`> we can write fmap f x <*> y
00:51:54 <jle`> oh sorry, instead of pure f <*> x <*> y
00:52:03 <jle`> and we have an infix version of fmap, (<$>)
00:52:14 <jle`> so fmap f x <*> y = f <$> x <*> y
00:52:19 <jle`> ...and...that's how we get there
00:53:18 <genzoon> :t (<$>)
00:53:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:53:37 <genzoon> applicative is just <*> then?
00:54:02 <nclarke> What does "Could not deduce a ~ b" mean?
00:54:18 <jle`> genzoon: the Applicative typeclass includes pure and (<*>)
00:54:25 <jle`> (<*>) is sometimes called 'ap'
00:54:34 <jle`> nclarke: it means you try to use a and b as if they were the same type in a function
00:54:42 <jle`> but your type signature says that they don't have to necessarily be the same
00:54:50 <enthropy> @type id :: a -> b
00:54:51 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
00:54:51 <lambdabot>       ‘a1’ is a rigid type variable bound by
00:54:51 <lambdabot>            an expression type signature: a1 -> b1 at <interactive>:1:1
00:55:02 <genzoon> I am not sure what we need pure for
00:55:34 <jle`> genzoon: well, so we can relate it to Functor :)
00:55:39 <jle`> there are a lot of neat usages though
00:55:56 * hackagebot equivalence 0.2.4 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.4 (PatrickBahr)
00:55:59 <nclarke> jle: Okay, thanks. Wasn't sure if it was 'equality' or something else
00:56:02 <genzoon> applicative = functor for functions with multiple arguments?
00:56:15 <jle`> genzoon: you can think of it like that.  it has the same power, i believe
00:56:28 <jle`> genzoon: one nice usage of pure is if you have one argument that isn't in a context
00:56:46 <jle`> like if you have x z being Maybe a, but y is just a
00:56:51 <jle`> you can do f <$> x <*> pure y <*> z
00:57:06 <jle`> the other way you can think of Applicative is as a "functor squasher"
00:57:39 <jle`> that is, if I have Just 3 and Just 5, then i can "squash them" into Just (3, 5)
00:57:47 <jle`> which is something you can't do with just fmap
00:58:13 <jle`> and from there...adding them together is easy.  you can just fmap (\(x, y) -> x + y) (squash (Just 3) (Just 5))
00:58:14 <enthropy> a monad is like a squash
00:58:25 <genzoon> interesting how a simple function like <*> lets us do that
00:58:43 <jle`> enthropy: a squash in a different direction :)
00:58:54 <jle`> maybe merge is a better word
00:58:59 <adimit> squash for monads is jqoin
00:59:01 <adimit> *joitn
00:59:04 <adimit> *join … ffs.
00:59:10 <jle`> but i like the visceral feeling that the word 'squash' evokes
00:59:10 <frerich> 'squish'
00:59:12 <jle`> hehe
00:59:33 <genzoon> > pure 10
00:59:34 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
00:59:34 <lambdabot>    arising from a use of ‘M5376183658112304643417.show_M5376183658112304643417’
00:59:34 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
00:59:34 <lambdabot>  Note: there are several potential instances:
00:59:34 <lambdabot>    instance [safe] GHC.Show.Show a =>
00:59:44 <jle`> Monad lets you turn a Maybe (Maybe a) into a Maybe a..."squashing" it "vertically".  Applicative lets you turn a Maybe a and a Maybe b into a Maybe (a, b)..."squashing" it "horizontally"
00:59:49 <levi> enthropy: Yellow or zucchini?
00:59:50 <jle`> genzoon: you have to say what Applicative instance you want
00:59:51 <adimit> and you cannot join with applicatives. That is a computation in applicative cannot "depend" on the result of another applicative computation.
01:00:00 <jle`> > pure 10 :: Maybe Int
01:00:01 <lambdabot>  Just 10
01:00:16 <jle`> usually though the compiler should be able to infer what type you want
01:00:27 <jle`> > pure (*) <*> pure 5 <*> Just 10
01:00:28 <lambdabot>  Just 50
01:00:37 <enthropy> levi: all of them
01:01:55 <jle`> anyways, writing a liftAn is trivial if you can arbitrarily squish together Just's.  Just squish them all into one giant Just tuple, and then fmap the function over it with the proper untupling/uncurrying
01:02:34 <jle`> it wa sjust decided that the pure + (<*>) approach was a bit nicer and cleaner
01:03:52 <jle`> genzoon: by the way, i suggest checking out the typeclassopedia, which elaborates on this and much more, for a bunch of typeclasses, and shows you how they all link together :)
01:06:16 <genzoon> I will thanks
01:06:49 <jle`> @where typeclassopedia
01:06:50 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
01:17:53 <louisjb> ##rtlsdr
01:42:46 <gh__> hi, has anyone managed to pipe some text to a pager (like 'less') in haskell using functions of System.Process? I'm having the problem described in the following mail: http://lists.osuosl.org/pipermail/darcs-users/2008-May/012072.html
01:45:34 <mmmm> Is it a code smell to have a monad transformer stack with return type ()
01:46:37 <Cale> mmmm: I consider it a code smell to have lots of monad transformers show up outside of a newtype
01:47:19 <Cale> But the return type () doesn't matter -- that just means the action you're describing is only relevant for its effects, which is frequently the case
01:47:46 <mmmm> ok thanks
01:50:24 <mbrock> with conduit, is there anything like a `try`? i.e., run this conduit and then restore its consumed input?
01:51:05 * hackagebot yesod-dsl 0.1.1.19 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.19 (TeroLaitinen)
01:51:50 <lfairy> mbrock: wouldn't that break the constant memory guarantee?
01:52:14 <d3m1g0d-> > :t False
01:52:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
01:52:30 <levi> mbrock: There's something kind of like that in the pipes parsing stuff.
01:52:32 <zereraz> hello everyone, can some one explain or direct me how to use the do and where or let. I am always confused when I write main = do, that what all is allowed after it and what is not. Currently I wanted to make a program that takes input checks if its a particular number if not then keep taking.
01:53:41 <mbrock> lfairy: I'm not really familiar with conduit, it's just something I want to do... I have a HTTP request body stream, and want to first decode a header, and if that succeeds, then download the entire file
01:54:04 <mbrock> both the header decoding and the downloading are already implemented as Sinks
01:54:54 <mbrock> (to clarify, "a header" means some data in the first few bytes of the request body, not an HTTP header...)
01:55:55 <vlatkoB> 9
01:56:47 <quchen> zereraz: There are only a handful of things you can write in that "do" block. 1. a binding, `x <- (something of type IO a)`; 2. a "statementy thing" (something of type IO a in its own line), 3. a `let x = (declarations of any type)`.
01:56:50 <mbrock> maybe I could implement such a `try` using `yieldOr` and a WriterT, or something...
01:57:32 <levi> mbrock: I think there's some way of stuffing data back, but I haven't really used conduits at all.
01:57:36 <zereraz> quchen: how to do I implement a recursive way of taking inputs
01:58:11 <zereraz> that does not end until input is a certain number
01:58:15 <jle`> zereraz: how about try writing a function that takes an input, and calls itself if you want to continue
01:58:30 <quchen> zereraz: Your program would read some input, then check whether it's a properly formatted number, then check whether it's the number you're looking for. If it goes right you can do whatever (print "Bingo" or something), otherwise you just recurse by calling main again.
01:58:47 <zereraz> oh I could call main
01:58:53 <zereraz> I never thought about that
01:59:00 <zereraz> that was what I was missing
01:59:12 <quchen> Well, you could also write this entirely outside of main.
01:59:27 <quchen> And then your main function would be "main = myCheckerLoop" or something.
01:59:46 <quchen> main isn't a special function in any way from the program's perspective.
01:59:49 <zereraz> ok, I'll try it and see if this works, thanks!
02:00:26 <splintax> i seem to be getting confused by ghc's error messages "couldn't match expected type foo with actual type bar"
02:00:41 <jle`> splintax: what part is tripping you up? :)
02:00:49 <splintax> sometimes it feels like it's backwards
02:01:00 <jle`> can you give an example of something that seems backwards?
02:01:09 <quchen> Been there. Actual is what you've given, expected is what GHC thinks it should be.
02:01:11 <frerich> splintax: It might be backwards because the compiler infers a type which you did not expect.
02:01:30 <splintax> yep. i'm using Data.ByteString.readFile :: FilePath -> IO ByteString
02:01:30 <jle`> in that case, it means that it in that place, you GHC expects to find a Foo...but instead, you give it a Bar
02:01:45 <splintax> i thought that would return an IO (Maybe ByteString)
02:01:52 <jle`> and then it'll usually tell you exactly what Bar is being given
02:01:55 <splintax> so i had a case statement to handle the fact that reading fails
02:02:04 <frerich> quchen: btw, I recently forwarded your FAQ on Github to a couple of colleagues - I think it's a really nice "best-practices" kind of thing. You should flesh it out and consider making an "Effective Haskell" book!
02:02:10 <splintax> and it said the expected type was ByteString, and the actual type was Maybe ByteString
02:02:27 <jle`> splintax: can you post an example...?
02:02:35 <quchen> frerich: You mean the FBUT?
02:02:48 <jle`> splintax: also, mind the line number/what identifier the error message is talking about
02:02:50 <quchen> That's hardly enough content for a book, but thanks :-)
02:03:02 <frerich> quchen: Uh, not sure. It's the one which talks about how 'genericLength' is not good (and why)
02:03:14 <quchen> Yeah that's the FBUT.
02:03:22 <quchen> ("Frequently brought up topics")
02:03:24 <frerich> quchen: Sure, it would need some extra content, but I think it's very nice to have this more-or-less-random collection of best practices.
02:03:52 <quchen> The reason I wrote this is so I can link it every time it comes up here.
02:04:56 <quchen> I add things once I've answered the same thing a couple of times in a short period of time, but recently nothing qualified in the last couple of … well, months I guess
02:05:14 <frerich> quchen: I think one addition to why 'genericLength' is bad is that people might argue that 'genericLength' is "better" because it works for arbitrarily long strings, in which case one should point out that if you have a linked list of chars which is longer than what Int represents, then you have bigger problems and probably shouldn't use [a] in the first place :}
02:05:41 <frerich> (that was one of the comments by my colleagues)
02:05:52 <quchen> Good point.
02:05:52 <frerich> I mean, they said "but, but, but, genericLength works for super long strings!"
02:05:54 <tech2> frerich: such a negative outlook :)
02:06:04 <jle`> hence the evil mustache
02:06:06 <quchen> > maxBound :: Int -- Look I have a list longer than that, length sucks
02:06:07 <lambdabot>  9223372036854775807
02:07:20 <frerich> That's bigger than I expected (I thought it's 2^30 or something)
02:07:38 <quchen> Not in x64
02:07:43 <quchen> > maxBound :: Int32
02:07:45 <lambdabot>  can't find file: L.hs
02:07:46 <quchen> > maxBound :: Int32
02:07:48 <lambdabot>  2147483647
02:07:49 <frerich> Ah I think 2^30 is what's *guaranteed*, I just notice that on my system I get 2^31-1
02:08:31 <Wizek> Good Morning!
02:08:35 <frerich> Yeah http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Int.html#t%3aInt syas it's guaranteed to go at least to 2^29-1
02:08:43 <quchen> "at least the range [-2ˆ29 .. 2ˆ29-1]"
02:08:44 <adimit> quchen: why didn't maxBound :: Int32 work the first time?
02:08:56 <zereraz> can someone check this and tell me what all I am doing wrong http://lpaste.net/108015
02:08:58 <quchen> adimit: I don't know, sometimes Lambdabot chokes on a command.
02:08:58 <Wizek> Can I make GHCI always give me the return type like http://tryhaskell.org/ does?
02:09:01 <johnw> adimit: it's been weird like that lately
02:09:11 <adimit> ah, ok.
02:09:19 <quchen> adimit: "Can't find L.hs" means the error is on the other side, so just re-run your command
02:09:43 <quchen> Wizek: Yes, there's a setting for that, hold on
02:09:43 <jle`> Wizek: you can
02:09:50 <adimit> good to know!
02:09:54 <jle`> morning Wizek !
02:10:04 <frerich> quchen: Frankly, if you assume an size of 4 bytes (for the next-node pointer) plus 4bytes for an Int, then you still need a string bigger than 17GB before 'length' doesn't work anymore..
02:10:19 <quchen> Wizek:  :set -t
02:10:20 <adimit> Wizek: :set +t
02:10:27 <quchen> Oh, +t
02:10:29 <Wizek> haha
02:10:31 <frerich> Hm except that technically, I guess you don't need to have the whole strng in memory at once, it could be GC'ed as 'length' traveres.
02:10:36 <Wizek> nice
02:11:16 <quchen> frerich: "length" isn't even limited to maxBound elements, it just overflows to 0 again when you reach the end of your giant string :-)
02:11:55 <zereraz> http://lpaste.net/108015 anyone?
02:11:58 <frerich> quchen: It overflows to some negative value actually
02:12:08 <jle`> > succ maxBound :: Int
02:12:09 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
02:12:14 <jle`> >_>
02:12:18 <adimit> frerich: processing lists of length 2^30 or so is not really the problem if you're doing lazy processing. The problem is running length on them because length is going to WHNF your list's spine. length isn't lazy, it needs to see (and have in memory) the entire list!
02:12:19 <jle`> > maxBound  + 1 :: Int
02:12:20 <lambdabot>  -9223372036854775808
02:12:39 <splintax> jle`: sorry, took me a while to get a minimal example of what i was talking about
02:12:43 <splintax> jle`: main = do a <- getLine; case a of Nothing -> putStrLn "nothing"; Just a' -> putStrLn a'
02:12:55 <splintax> this is wrong because getLine is IO String, not IO (Maybe String)
02:12:56 <adimit> if one goes through a very long list lazily and needs to know its length it's better to use an accumulator.
02:13:07 <splintax> yet the error message says "expected type string, actual type Maybe t0"
02:13:18 <splintax> when i would expect it to be the other way around
02:13:20 <jle`> splintax: on what line/identifier?
02:13:30 <quchen> frerich: Oh right, even worse haha
02:13:59 <splintax> jle`: In the pattern: Nothing
02:14:14 <jle`> ah
02:14:15 <adimit> ew, negative list lengths.
02:14:17 <quchen> adimit: It doesn't have to have the entire thing in memory. All 'length' needs is a counter and a view to the next (:).
02:14:20 <frerich> adimit: Are you sure? The code of 'length' suggests that it could run in constant space...
02:14:22 <jle`> well, it's because you *can* pattern match on a String
02:14:34 <jle`> except you can only pattern match it against the string constructors
02:14:36 <frerich> adimit: (I'm looking at http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-List.html#length )
02:14:42 <jle`> but here you are pattern matching it against Nothing, a Maybe t0
02:14:53 <adimit> frerich: true, it's just what ends up happening most of the time you do use length on a long list.
02:15:07 <adimit> i.e. one would have to make sure *not* to have references to the list that point to its tail somewhere.
02:15:17 <Cale> zereraz: Your text editor isn't configured to convert tabs to spaces. Also, you need a 'do' to glue together the 'print n' with 'main'
02:15:19 <zereraz> help please
02:15:24 <jle`> splintax: for example, case a of "Nothing" -> putStrLn "Nothing"; _ -> putStrLn a works
02:15:26 <frerich> adimit: Of course 'length' forces the list, but my assumption was that maybe the traversed nodes could be garbage-collected already as 'length' traverses.
02:15:45 <adimit> frerich: they will be, as long as they *can* be garbage collected.
02:15:56 <jle`> zereraz: you might be missing a 'do'
02:16:00 <zereraz> jle`: so statements inside a block are not good enough?
02:16:01 <Cale> zereraz: do blocks are used to glue together IO actions into larger ones.
02:16:07 <adimit> but what are you doing with such a long lits if you're not looking at its elements?
02:16:11 <adimit> *list
02:16:11 <zereraz> only IO?
02:16:13 <jle`> zereraz: on line 8
02:16:16 <Cale> Not just IO
02:16:20 <splintax> jle`: yeah. i understand why the code is wrong, i just don't understand why haskell thinks the "actual" type is Maybe t0 and the "expected" type is String, instead of vice-versa.
02:16:24 <Cale> but IO specifically, as in this case
02:16:30 <jle`> splintax: the actual type of Nothing is Nothing
02:16:35 <jle`> splintax: but it expects a String there
02:16:44 <jle`> case a of "Nothing" -> ... would typecheck
02:16:49 <jle`> because it expects a string, and gets a string
02:16:53 <Cale> jle`: Wait, what? The type of Nothing is Maybe a
02:17:02 <jle`> Cale: you caught me
02:17:06 <jle`> thanks :P
02:17:26 <jle`> > case 1 of Nothing -> (); _ -> ()
02:17:27 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe t0))
02:17:27 <lambdabot>    arising from the literal ‘1’
02:17:34 <jle`> hm maybe a bad example
02:17:42 <jle`> > case True of Nothing -> (); _ -> ();
02:17:44 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
02:17:44 <lambdabot>              with actual type ‘Data.Maybe.Maybe t0’
02:17:51 <zereraz> 1 more thing, If I want to end program
02:17:53 <splintax> jle`: again, i understand why the example doesn't typecheck. to me it just seems that the "actual" type is String, and the "expected" type (ie. the type I expected 'a' to represent) is Maybe t0
02:17:56 <Cale> zereraz: Also, a more minor thing, the convention is to lay out if/then/else like so:
02:17:58 <zereraz> what If I do just a return
02:17:59 <Cale> if foo
02:18:01 <Cale>    then bar
02:18:04 <Cale>    else quux
02:18:14 <jle`> splintax: the type that you expect 'a' to represent can only be String
02:18:26 <Cale> The idea being that 'then' and 'else' are siblings and so should line up
02:18:29 <zereraz> ok so else with same tabbing as then
02:18:29 <jle`> or well
02:18:42 <jle`> splintax: ghc knows that 'a' *must* be a String
02:18:48 <zereraz> so my program ends when I do return 0
02:18:49 <Cale> zereraz: But yeah, configure your text editor to convert tabs to spaces
02:19:02 <jle`> splintax: so when you pattern match on 'a', what you put there *must also* be a String
02:19:02 <zereraz> it worked once I put the do
02:19:13 <jle`> splintax: it's expecting you to provide a String there
02:19:16 <zereraz> without the ;
02:19:17 <jle`> on the first case branch
02:19:39 <jle`> splintax: but instead of giving it the String it expects, you give it a Maybe a
02:20:23 <splintax> yeah. i guess i am thinking of the pattern matching process backwards
02:20:41 <jle`> splintax: by the time you get to the case statement, it already has made up its mind about the type of 'a'
02:20:45 <jle`> nothing you do later can change its mind
02:20:53 <Cale> zereraz: I added an annotation showing how I might lay the code out: http://lpaste.net/108015
02:21:08 <splintax> yeah, it makes more sense about it that way. but the correct order can't always be from top to bottom (of your source file), right?
02:21:32 <splintax> probably not a sensible question, nevermind
02:21:42 <zereraz> Cale: Thanks allot, also is there anything else I should do?
02:21:48 <zereraz> jle`: thanks
02:21:54 <jle`> zereraz: remember, main :: IO ().  it's only *one* IO thing.  but things like putStrLn x are IO ().  so if you want to print two strings, you have an IO () and an IO ().  but main only takes one IO ().  so how do you combine them?  either with the (>>) :: IO a -> IO b -> IO b function, to "squish" two IO ()'s together, or with a do block, which is syntactic sugar for the exact same thing
02:22:06 <jle`> @undo do { putStrLn "hello"; putStrLn "world" }
02:22:06 <lambdabot> putStrLn "hello" >> putStrLn "world"
02:22:25 <jle`> see, a do block with the two line-after-line is just syntactic sugar for io1 >> io2
02:22:48 <jle`> splintax: it's the way type inference is implemented, but i'm pretty sure that hindley-milner would also work if you go from the bottom to the top
02:23:01 <rylev> Does anyone know a good way to log request times in Scotty? Most web frameworks I'm familiar with (Rails, Play) have some idea of an "around filter" that wraps requests. But I can't find the same for Scotty.
02:23:16 <zereraz> jle`: what about this putStrLn "abc" do putStrLn "def"
02:23:29 <frerich> Does anybody here some vim scripts which take care of aligning the branches of 'case' or 'if' or 'where' or so consistently? I noticed that I'm a bit inconsistent, sometimes using two, sometimes using four spaces.
02:23:44 <jle`> zereraz: that doesn't really parse, i think
02:23:47 <zereraz> jle`: as it accepts 1 IO, the other we give by do
02:23:53 <mbrock> rylev: isn't that just a Middleware?
02:24:05 <jle`> zereraz: 'the other' ?
02:24:12 <jle`> remember, an IO () is just a normal value
02:24:14 <Cale> zereraz: the do notation glues multiple IO actions together into a single one
02:24:18 <rylev> My understanding of Middleware is that it goes "before" you handle the request
02:24:28 <zereraz> so do has to be in the start
02:24:33 <rylev> But perhaps I read it wrong
02:24:37 <zereraz> jle`: I meant the 2nd putStrLn command
02:24:41 <Cale> yes
02:24:45 <jle`> so do { x; y; z } :: IO () is equivalent to x >> y >> z :: IO ()
02:24:56 <mbrock> rylev: Middleware is simply an Application -> Application
02:25:04 <jle`> if all three are IO (), then their 'sequenced' version is also a single IO ()
02:25:08 <zereraz> and this 'do' is important only for IO glueing or everywhere?
02:25:17 <rylev> Oh ok. Perfect. I should have looked closer. Sorry and thanks for the help!
02:25:33 <jle`> zereraz: do is syntactic sugar for a bunch of (>>)'s and (>>=)'s and some other stuff
02:25:47 <jle`> zereraz: any type that implements (>>), etc. can be used with do notation
02:25:59 <zereraz> jle`: what is >>
02:26:03 <jle`> zereraz: but right now the only one for which you know (>>) for is IO :)
02:26:09 * hackagebot apiary 0.14.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.14.0 (HirotomoMoriwaki)
02:26:11 * hackagebot apiary-logger 0.11.3 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.11.3 (HirotomoMoriwaki)
02:26:12 <jle`> remember? it "squishes"/sequences to IO actions
02:26:13 * hackagebot apiary-persistent 0.13.1 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.13.1 (HirotomoMoriwaki)
02:26:15 * hackagebot apiary-websockets 0.11.4 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.11.4 (HirotomoMoriwaki)
02:26:17 * hackagebot apiary-cookie 0.13.1 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.13.1 (HirotomoMoriwaki)
02:26:19 <jle`> if i have putStrLn "hello" :: IO ()
02:26:23 <jle`> and putStrLn "world" :: IO ()
02:26:31 <jle`> i can "combine" them into one "giant" IO ()
02:26:36 <jle`> putStrLn "hello" >> putStrLn "world"
02:26:41 <jle`> :: IO ()
02:26:42 <zereraz> ah nice I got it!!
02:26:50 <jle`> look carefully at the type signature
02:26:50 <zereraz> its like the c++ >>
02:26:57 <jle`> (>>) :: IO a -> IO b -> IO b
02:27:06 <jle`> it's actually a lot more like the semicolon in bash
02:27:08 <jle`> for IO at least
02:27:15 <jle`> it's also like semicolons in C++ ;)
02:27:27 <mbrock> rylev: e.g. \a -> (\req respond -> do { before; x <- a req respond; after; return x })
02:27:35 <jle`> cout << "hello"; cout << "world";
02:27:39 <zereraz> ok I thanks allot !!
02:27:43 <jle`> um...i forgot how C++ works
02:27:45 <mbrock> rylev: I think would be a valid Middleware, given appropriate `before` and `after`
02:27:50 <jle`> but you can imagine replacing every (;) with a (>>)
02:28:08 <jle`> right now the only type that you know has (>>) is IO, so don't worry about the other types
02:28:16 <zereraz> jle`: c++ uses the same symbol in cin>>a>>b;
02:28:17 <jle`> a lot of types you have encountered probably have (>>) defined on them
02:28:20 <rylev> mbrock: ok let me try that out
02:28:32 <jle`> when you discover (>>) for the other types, it'll be a pleasant surprise :)
02:28:33 <zereraz> but I got what it means in haskell
02:28:44 <jle`> yeah.  the main point is that it is some sort of combining function
02:28:59 <zereraz> so >> basically glues into a giant type?
02:29:03 <jle`> that can take two IO ()'s and turn them into one IO ().  and becuase main :: IO (), you'll need it if you need to do one thing
02:29:04 <zereraz> of any type
02:29:05 <jle`> one giant object
02:29:08 <jle`> not of any type
02:29:14 <zereraz> ok object
02:29:17 <jle`> only types that have (>>) defined
02:29:19 <zereraz> I got the concept
02:29:30 <jle`> remember that in Hasell, IO is just normal data
02:29:30 <zereraz> thanks
02:29:30 <mbrock> rylev: (you may also want to think about exception handling for the call to `a`, since it can probably throw)
02:29:33 <jle`> like a list or an int
02:29:49 <jle`> you already have something that can sort of "glue" two lists together, i think?
02:29:55 <jle`> have you seen (++) ?
02:30:00 <zereraz> yeah
02:30:05 <jle`> > [1,2,3] ++ [4,5,6]
02:30:07 <lambdabot>  [1,2,3,4,5,6]
02:30:14 <jle`> it's another sort of combining-kinda-operator
02:30:18 <zereraz> yeah I've used it today :D
02:30:21 <jle`> yay!
02:30:31 <zereraz> yay!
02:30:35 <jle`> interestingly enough, list also has (>>) implemented, and it's different from (++)
02:30:43 <jle`> one day you will run into it :)
02:30:47 <jle`> today it's not too important
02:30:49 <zereraz> so much to learn
02:31:12 <jle`> but if you ever find out what (>>) does for lists
02:31:16 <jle`> you will see that xs >> ys
02:31:19 * hackagebot apiary-clientsession 0.13.1 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.13.1 (HirotomoMoriwaki)
02:31:21 <jle`> is equivalent to do { xs; ys }
02:31:21 * hackagebot apiary-authenticate 0.14.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.14.0 (HirotomoMoriwaki)
02:31:23 * hackagebot apiary-eventsource 0.11.6 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.11.6 (HirotomoMoriwaki)
02:31:25 * hackagebot haskell-token-utils 0.0.0.5 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.5 (AlanZimmerman)
02:31:27 * hackagebot apiary-purescript 0.14.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.14.0 (HirotomoMoriwaki)
02:31:32 <jle`> do is just syntactic sugar for a series of (>>=) and (>>) and other things
02:31:35 <zereraz> ok
02:31:59 <jle`> you can always as lambdabot to show you what it desguars to
02:32:01 <jle`> with the @undo command
02:32:03 <zereraz> and 1 more question , in the type declarations that have 'a' and 'b', does the b mean functions
02:32:07 <jle`> @undo do { xs; ys }
02:32:07 <lambdabot> xs >> ys
02:32:20 <jle`> zereraz: no, they're just type variables
02:32:23 <jle`> they don't mean anything
02:32:29 <jle`> const :: a -> b -> a
02:32:32 <jle`> but it ight as well have been
02:32:36 <zereraz> ok, I just assumed , but they could be
02:32:39 <jle`> const :: banana -> watermelon -> banana
02:32:51 <zereraz> like they are generic
02:32:58 <jle`> yeah, just like normal data-level variables
02:33:00 <zereraz> any type can come including functions right
02:33:04 <jle`> yup
02:33:10 <zereraz> ok
02:33:16 <zereraz> thanks
02:33:23 <jle`> f x = something-with-x is no different than f y = something-with-y
02:33:41 <zereraz> yeah
02:34:10 <jle`> there is a slight difference in the way variables work in types and the way they work at the value level
02:34:21 <zereraz> so if I want to show that a function can take another function then we use a or b ...
02:34:47 <jle`> if i want to show that a function take sa function, you can use (a -> b), depending on what you want
02:34:53 <jle`> you might have seen ($)
02:34:57 <jle`> ($) :: (a -> b) -> b -> a
02:35:15 <jle`> oops
02:35:19 <jle`> ($) :: (a -> b) -> a -> b
02:35:20 <zereraz> I've used $ to prevent using ()
02:35:29 <jle`> meaning "($) takes a function from a to b, and an a, and then returns a b
02:35:39 <jle`> so ($) takes a function, the (a -> b), the a, and then returns a b
02:35:48 <jle`> you might have also seen map...?
02:35:51 <jle`> :t map
02:35:52 <lambdabot> (a -> b) -> [a] -> [b]
02:36:00 <zereraz> yeah map
02:36:03 <jle`> map takes a function (a -> b), an [a], and returns [b]
02:36:06 <zereraz> takes 2 functions
02:36:10 * hackagebot TypingTester 0.1.0.1 - Command Line Typing speed tester  http://hackage.haskell.org/package/TypingTester-0.1.0.1 (AlanHawkins)
02:36:11 <jle`> just one function :)
02:36:33 <jle`> remember that in haskell you can also *return* functions too
02:36:36 <zereraz> but aren't operators functions too
02:36:41 <jle`> map' :: (a -> b) -> ([a] -> [b])
02:37:03 <jle`> but surprise!  the function types associate to the right
02:37:11 <jle`> so you can drop the paraentheses because of the way they associate
02:37:17 <jle`> map' :: (a -> b) -> [a] -> [b]
02:37:31 <jle`> yeah, operatores are just functions with only symbols in their name that you apply differently
02:37:34 <zereraz> map returns 1 list
02:37:39 <zereraz> why is there [a] and [b]
02:37:54 <jle`> :t map
02:37:54 <Cale> zereraz: it accepts a list as its second argument
02:37:55 <lambdabot> (a -> b) -> [a] -> [b]
02:38:01 <jle`> > map (*2) [1,2,3]
02:38:02 <lambdabot>  [2,4,6]
02:38:07 <zereraz> oh I forgot
02:38:08 <jle`> takes a funciton, a list, and returns a new list
02:38:09 <zereraz> my bad
02:38:10 <zereraz> thanks
02:39:07 <zereraz> I got confused on the thing I knew :P
02:41:03 <jle`> :)
02:41:07 <jle`> don't worry, happens to everybody :)
02:41:12 <zereraz> what does IO Int mean?
02:41:47 <jle`> it's an object representing an IO action that produces an integer
02:41:54 <zereraz> ok
02:42:26 <jle`> when compiled & run by a computer
02:42:27 <zereraz> haskell is quite different
02:42:35 <jle`> yeah, we have first-class statements :)
02:42:43 <jle`> in other languages, statements/io are magic
02:42:50 <zereraz> exactly
02:42:59 <jle`> they're these things where if they are ever evaluated or you get to them, stuff happens willy nilly whenever
02:43:00 <zereraz> io is like the first thing taught
02:43:11 <jle`> in haskell, statements are just...normal data
02:43:13 <kvanb> Have an alternate explanation
02:43:21 <kvanb> this one helps certain people better than others
02:43:40 <jle`> putStrLn "hello" is just a normal data object.  not special, not magical.  just normal data.  like a list or an int
02:43:44 <flux> hmm, 'a = b' in the top level is data in haskell?-)
02:43:55 <kvanb> Say you have an action you want to do, like, printing to the terminal
02:44:04 <kvanb> and you have another action, like grabbing some text from the terminal
02:44:04 <flux> of a data-declaration, it's not data either
02:44:17 <jle`> flux: it's a definition, if that's what you mean
02:44:20 <jle`> ?
02:44:23 <kvanb> in a purely functional programming language how do you know which comes first?
02:44:31 <flux> jle`, it's a statement that is a definition
02:44:36 <flux> the language closest to 'everything is data' would be lisp
02:44:38 <kvanb> it's ofcourse the one that depends on the previous!
02:44:46 <kvanb> IO is actually more like a tuple
02:44:54 <kvanb> (RealWorldState, value)
02:44:57 <b_jonas> no, IO is more like a burrito
02:45:11 <jle`> flux: it's not a statement in the sense of how i'm using it
02:45:13 <gfixler> Um, I'm pretty sure that IO is a spacesuit
02:45:13 <b_jonas> (actually, it's more like a function)
02:45:16 <Pythonfant> and comonads are inverted burritos
02:45:30 <jle`> flux: i'm using statement as an action that changes some sort of program state
02:45:30 <kvanb> b_jonas: that's just plain wrong, it's not a function
02:45:31 <Walther> although IO in haskell isn't very tasty
02:45:52 <zereraz> kvanb: keep going
02:45:56 <jle`> kvanb: i don't know, i think the State RealWorld is actually a harmful metaphor...and not actually how the semantic model of IO works in haskell
02:46:00 <kvanb> Oh, thought people lost interest
02:46:17 <kvanb> Righto, having some thing that prints text to the screen, let's say it has type IO ()
02:46:22 * gfixler is interested in kvanb's explanation
02:46:24 <kvanb> where () is the "unit" or useless type
02:46:26 <Walther> not at all, I'd also like to understand IO in haskell better
02:46:44 <kvanb> and we have the thing that grabs text from the user, let's say it has IO String
02:46:58 <kvanb> We have the types (RealWorldState, ()) and (RealWorldState, String) for each respectively
02:47:48 <kvanb> See how the dependencies line up.
02:47:51 <kvanb> (RealWorldState, ())
02:47:51 <kvanb>        |
02:47:52 <kvanb>        v
02:47:52 <kvanb> (RealWorldState, String)
02:48:34 <jle`> State RealWorldState explanation of haskell IO considered harmful ;_;
02:48:38 <kvanb> When you do something like putStrLn "hello" >> getLine >>= ... you're actually placing a dependency on the RealWorldState in getLine on the RealWorldState in putStrLn
02:48:47 <Pythonfant> jle`: could you elaborate on that?
02:49:03 <kvanb> You can imagine like you're passing around a box which contains everything we know about the universe inside
02:49:17 <kvanb> each time we change the universe outside pure-land it changes a little and the next function needs to know about it
02:49:35 <jle`> it doesn't match with the semantic model of IO in haskell, and it doesn't take long before it starts falling apart as a metaphor
02:49:36 <zereraz> interesting
02:49:47 <kvanb> most monads work like that in their guts
02:49:52 <zereraz> IO is a monad right
02:49:55 <kvanb> yes
02:50:23 <Pythonfant> jle`: do you have a link for me to learn about the actual semantic model of IO in haskell?
02:50:23 <jle`> what other monads work like that?
02:50:24 <zereraz> so If I really wanted to understand IO , I would just have to understand monads right?
02:50:30 <jle`> zereraz: no :'(
02:50:33 <kvanb> jle`: the state monad
02:50:44 <jle`> and...?
02:50:50 <Pythonfant> state != most monads
02:50:50 <kvanb> the writer monad maybe?
02:50:56 <kvanb> most parser monads
02:51:23 <zereraz> jle`: why?
02:51:24 <jle`> parser monad is factored out into just a State and some MonadPlus
02:51:37 <jle`> i don't know :/  i mean, this was how i was told about IO at first too
02:51:40 <jle`> and it gets passed around a lot
02:51:41 <kvanb> prettymuch any monad with a state is most likely going to carry the current state in such a way that each monadic operation depends on the last
02:51:58 <isomorpheous> Is it just my impression, or is aeson not standard-adherent?
02:52:12 <jle`> but i think it's a harmful explanation because it promotes an intuition that falls apart when stretched just slightly
02:52:23 <kvanb> jle`: why does it fall apart?
02:52:26 <mbrock> zereraz: Monad happens to be the interface chosen by Haskell to allow chaining of IO values -- it's sort of like how, um, Iterator is the interface chosen by Java to allow traversing collections
02:52:28 <kvanb> I hack on optimisers for functional code
02:52:33 <jle`> it can't account for concurrency
02:52:33 <kvanb> and they all use this representation ...
02:52:36 <jle`> or parallelism
02:52:59 <isomorpheous> given this date - "2014-07-25", I get the error "user error (could not parse ISO-8601 date)"
02:53:00 <kvanb> when I said put the universe in a box, did you take it literally?
02:53:09 <kvanb> For concurrency, just assume multiple universes.
02:53:15 <jle`> yeah, but what does (>>=) mean?
02:53:17 <mbrock> if you have to use the words "box containing the entire universe" in your explanation of "print", that does seem kind of pedagogically unwieldy
02:53:20 <zereraz> mbrock: so if I want to understand IO i just need to understand monads first right
02:53:24 <jle`> what does (>>) mean?
02:53:26 <jle`> zereraz: you don't
02:53:30 <jle`> you just need to understand IO
02:53:36 <isomorpheous> but this date works fine "2014-07-25T00:00:00Z"
02:53:42 <kvanb> zereraz: not really, but it's nice to understand how to stitch them together
02:53:53 <b_jonas> mbrock: yeah. and that's shown especially how there's at least three versions of Monad that could work: H89 Monad, Monad without fail, and the Monad in new ghc that is a subclass of Applicative.
02:53:58 <zereraz> I have a tutorial of monads in javascript
02:54:10 <zereraz> I could learn about monads
02:54:16 <kvanb> don't look at other languages to teach monads
02:54:26 <frerich> zereraz: You can go a very long way if you odn't bother with what is or isn't a "monad" at all but rather just keep in mind that in Haskell, input/output is done by combining 'actions'. If you know C++ a bit, it's basically the difference between 'cout << "Hello";' (i.e. directly performng output) vs. 'struct CoutAction { CoutAction( const std::string &what ) : m_what( what ) { } void execute() { :cout << m_what;
02:54:26 <frerich>  }; std::string m_what; };, i.e. having a value (C++ people tend to call this a 'functor'...) which by itself doesn't do anything, you can pass them around and stick them into lists and combine them.
02:54:27 <jle`> zereraz: don't learn about monads
02:54:27 <kvanb> usually they get them very wrong
02:54:35 <jle`> it's not worth learning about
02:54:38 <jle`> not for a very long time
02:54:47 <hyPiRion> kvanb: how about OCaml?
02:55:00 * gfixler is taking the slow approach through LYAH, and will let monads happen when they happen
02:55:14 <isomorpheous> Both of those are in accordance with ISO 8601 - http://en.wikipedia.org/wiki/ISO_8601
02:55:21 <zereraz> ok I won't
02:55:24 <kvanb> hyPiRion: how about it?
02:55:25 <zereraz> for now :P
02:55:40 <hyPiRion> kvanb: re "don't look at other languages to teach monads"
02:55:43 <jle`> kvanb: list, Maybe, Reader, Writer (you can't access the state parameter so you can't depend on it), any interpreter monad, Either, etc. don't work this way
02:55:52 <zereraz> frerich: I don't know the difference between the struct coutAction
02:55:58 <jle`> kvanb: and you don't even need to implement State this way
02:56:04 <kvanb> jle`: that's a shallow generalisation
02:56:05 <mbrock> zereraz: monads *in general* are very abstract, so learning about monads in order to learn about IO is a little like learning about group theory to understand arithmetic
02:56:05 <jle`> State can be implemented as an interpreter monad
02:56:06 <kvanb> Maybe works that way
02:56:17 <kvanb> so does Either
02:56:32 <kvanb> you're just not thinking abstractly enough
02:56:34 <zereraz> mbrock: ok now I know why you guys said no
02:56:51 <kvanb> the tag of the data type is no different from a field in it
02:56:57 <frerich> zereraz: Do you know the standard function adaptors in the STL, e.g. std::ptr_fun or so?
02:57:10 <jle`> kvanb: ah.  well i see what you mean there.  in any case, haskell has a very well-defined semantic model for IO that encapsulates concurrency, everything else, etc.
02:57:13 <zereraz> frerich: I know little c++
02:57:16 <jle`> that isn't even difficult to understand
02:57:24 <mbrock> zereraz: still, in order to use IO, you will have to use the functions from the Monad class, but you don't have to be too concerned with the *general* meaning of those functions
02:57:26 <frerich> zereraz: Is there another language you know?
02:57:34 <jle`> you can't meaningfully extend State Realworld to concurrency in a useful way
02:57:38 <jle`> what is forkIO ?
02:57:41 <zereraz> frerich: javascript
02:57:45 <kvanb> I just told you what is happening inside the guys of GHC
02:57:56 <kvanb> any effort to say that it's the wrong explanation is kind of moot.
02:58:03 <kvanb> /s/guys/guts
02:58:12 <zereraz> mbrock: when should I learn monads, like when is it necessary for me
02:58:13 <frerich> zereraz: That'll do. consider the difference between 'alert( "Hello" );' and 'var action = function() { alert( "Hello" ); }'
02:58:29 <jle`> kvanb: that's how it's implemented in GHC, but that's an implementation detail
02:58:29 <zereraz> yes
02:58:38 <frerich> zereraz: Note how the former actually does some IO, it shows a message box or so - the latter doesn't. It just defines an 'action' which you can execute lateron.
02:58:43 <kvanb> that's the only way a stateful monad can be implemented
02:58:44 <jle`> kvanb: GHC doesn't even really obey it
02:58:46 <kvanb> otherwise it can't carry state
02:58:52 <zereraz> frerich: yes
02:58:56 <jle`> but IO isn't supposed to be "a stateful monad"
02:58:59 <frerich> zereraz: In particular, you could also combine those actions, stick them in lists and whatnot.
02:59:03 <kvanb> IO is a stateful monad
02:59:05 <kvanb> that's the whole point.
02:59:10 <zereraz> frerich: yeah
02:59:20 <kvanb> @where lyah
02:59:20 <lambdabot> http://www.learnyouahaskell.com/
02:59:20 <jle`> IO represents computer instructions
02:59:22 <kvanb> zereraz ^
02:59:25 <frerich> zereraz: And the latter is how you do IO in Haskell: you nevre actually do something right away (like printing a message) you always only construct and combine IO actions.
02:59:49 <kvanb> I'm not sure I would say haskell IO is deffered
02:59:55 <frerich> zereraz: Consequently 'main' is not a function in Haskell but an IO action. And the runtime system executes that action. in fact, the runtime system is the only piece which knows how to actually execute actions.
02:59:56 <zereraz> frerich: ok got that , thanks.
03:00:19 <zereraz> frerich: that is very interesting
03:00:26 <kvanb> it's not very right
03:00:26 <jle`> kvanb: haskell's semantic model of IO is not 'a stateful monad', it's an IO action.  a data structure representing instructions for a computer
03:00:48 <jle`> besides, you do'nt even have to implement State this way
03:01:15 <zereraz> frerich: so these actions go to the runtime and there they are executed
03:01:15 <Walther> ..this sounds an awful lot like a reduction to "in haskell, a program is a program! and it's run by the computer!" :P
03:01:45 <isomorpheous> zereraz: there's a mostly incorrect, but incredibly insightful lecture about monads on YouTube, by a guy named Brian Beckman.
03:01:48 <jle`> data State' s a = Get (s -> State' s a) | Put s (State' s a)
03:01:50 <jle`> oops
03:01:55 <jle`> data State' s a = Get (s -> State' s a) | Put s (State' s a) | Return a
03:02:00 <zereraz> isomorpheous: I saw little bit of that
03:02:06 <isomorpheous> zereraz: if you don't rely on it for facts, but just try to extract the general idea, it's really good
03:02:07 <jle`> there, that's a perfectly valid "stateful monad"
03:02:08 <zereraz> isomorpheous: why incorrect?
03:02:12 <frerich> jle`: That's at least a good mental model, yes.IO actions being passed around and combined/chained/whatnot.
03:02:25 <isomorpheous> zereraz: off the top of my head, he claimed that F# was faster than Haskell
03:02:26 <jle`> but in any case, IO is not a "stateful monad"
03:02:32 <kvanb> jle`: all you've done is changed the way the data storage is generalised
03:02:40 <jle`> sorry, the divesion was a bit irrelevant :)
03:02:43 <jle`> i shouldn't have mentioned it
03:02:43 <zereraz> isomorpheous: but not incorrect about monads right
03:02:45 <isomorpheous> zereraz: he claimed that `id` was a monadic property
03:02:55 <bitemyapp> isomorpheous: I did not like that lecture by Beckman at all.
03:02:56 <isomorpheous> zereraz: His definition of monoids is just dumb
03:02:57 <jle`> the semantic model of IO in haskell is literally as data
03:03:02 <jle`> representing machine instructions
03:03:03 <bitemyapp> isomorpheous: it also has nothing to do with IO
03:03:10 <isomorpheous> bitemyapp: it's good if you don't already know about monads
03:03:12 <jle`> forkIO is simple in this sense
03:03:16 <bitemyapp> isomorpheous: it's really not.
03:03:22 <jle`> forkIO transforms a computer instruction into a parallel computer instruction
03:03:25 <isomorpheous> bitemyapp: why so?
03:03:25 <bitemyapp> isomorpheous: you want to just learn Haskell, FP, etc.
03:03:30 <bitemyapp> and stop being distracted by nonsense
03:03:36 <bitemyapp> https://github.com/bitemyapp/learnhaskell
03:03:40 <bitemyapp> seriously
03:03:54 <isomorpheous> bitemyapp: monads are pretty important
03:03:55 <frerich> zereraz: The whole topic of how you can consider this approach of doing IO, by juggling with 'actions', a particular case of a "Monad" is a whole different (and arguably more confusing) thing.
03:03:59 <bitemyapp> stop arguing about the many bad and worse ways to talk about what is fundamentally an algebraic structure
03:04:04 <bitemyapp> and not the only algebraic structure
03:04:12 <bitemyapp> isomorpheous: stop that. You're fetishizing one structure among many.
03:04:32 <isomorpheous> bitemyapp: your pacman commands in your readme are extremely dangerous
03:04:32 <bitemyapp> zereraz: https://github.com/bitemyapp/learnhaskell
03:04:38 <bitemyapp> isomorpheous: so PR them
03:04:42 <isomorpheous> bitemyapp: alright
03:04:44 <bitemyapp> isomorpheous: how do you think they got in there?
03:04:47 <bitemyapp> isomorpheous: I don't use arch
03:04:50 <bitemyapp> I don't care about Arch
03:04:50 <isomorpheous> bitemyapp: ah
03:04:54 <bitemyapp> somebody PR'd, I merged.
03:04:58 <bitemyapp> if you PR, I'll merge.
03:05:03 <zereraz> bitemyapp: I am there
03:05:04 <jle`> haskell's semantic model of IO is just as data representing machine instructions
03:05:17 <bitemyapp> zereraz: good, now ignore silliness and learn Haskell.
03:05:19 <zereraz> bitemyapp: wow
03:05:35 <bitemyapp> zereraz: I will toss you one hint though
03:05:36 <sleepomeno> in threadscope spark pool view what does that grey area mean opposed to the black graph line? --> https://www.dropbox.com/s/bq98ytxs7k5zdks/pool.png
03:05:47 <kvanb> stop listening to this channel until you get up to chapter 3 of LYAH ...
03:05:53 <bitemyapp> zereraz: understanding transformation, reduction; free monads - lends intuition for IO.
03:05:55 <jle`> the State RealWorld model doesn't meaningfully extend in a useful way if you push it too far
03:06:02 <bitemyapp> zereraz: but you need to ignore monads and IO and especially IO
03:06:12 <jle`> the IO instructions model is always useful and always meaningful, in every situation
03:06:15 <bitemyapp> zereraz: and just learn Haskell. You'll get there when you get there and honestly it doesn't matter one whit how IO works.
03:06:18 <kvanb> jle`: dude, please. You can't put machine instructions in a data thingy and claim it's some kind of representation
03:06:24 <kvanb> it's not even pure anymore and breaks every rule
03:06:33 <kvanb> the real representation is the RealWorldState representation
03:06:33 <bitemyapp> jle`: I beg of you and everyone else in this conversation
03:06:33 <jle`> kvanb: the data is pure
03:06:36 <zereraz> bitemyapp: ok
03:06:36 <kvanb> that is the only representation.
03:06:39 <bitemyapp> if you must have this conversation
03:06:48 <bitemyapp> have it somewhere new people won't get confused
03:06:50 <bitemyapp> Please.
03:06:55 <zereraz> kvanb: I only ask my doubts here
03:07:06 <zereraz> kvanb: I don't understand any discussions you guys have
03:07:14 <bitemyapp> zereraz: ignore them. Flee. Go learn Haskell.
03:07:19 <bitemyapp> zereraz: this foolishness is unnecessary.
03:07:30 <mbrock> bitemyapp++ for snarky wisdom
03:07:33 <isomorpheous> bitemyapp: with all due respect, I think you're wrong about monads
03:07:36 <zereraz> bitemyapp: that I am, I was practicing questions of spoj
03:07:45 <isomorpheous> bitemyapp: they are really simple
03:07:48 <kvanb> sparky wisdom
03:07:51 <bitemyapp> isomorpheous: shush
03:07:52 <kvanb> foldr fork
03:09:34 <zereraz> once again thanks everyone, learn't allot today
03:09:45 <jle`> hope you did, zereraz :) come back any time :)
03:09:59 <bitemyapp> zereraz: do what the guide tells you. #haskell-beginners might be less noisy when you need help in future
03:10:14 <zereraz> jle`: I get allot of doubts so I will come
03:10:23 <johnw> bitemyapp: hello!
03:10:33 <bitemyapp> johnw: hi. I need sleep.
03:10:38 <zereraz> bitemyapp: I went to haskell-beginners but there wasn't much activity there
03:10:44 <bitemyapp> johnw: I got hijacked by you-know-who
03:10:47 <johnw> haha
03:10:56 <johnw> poor guy, his flight is so early
03:11:10 <bitemyapp> johnw: rickasaurus took over for me to keep him entertained until his flight
03:11:22 <bitemyapp> they ended up on something machine learning related, I left around 0350
03:11:29 <johnw> ah, nice
03:11:35 <bitemyapp> I'm starting to wonder if I should risk sleep now. Flight is early afternoon.
03:11:35 <johnw> yeah, rickasaurus is good at that stuff
03:11:45 <johnw> oh, ouch
03:11:53 <johnw> set your clock for 3 hours
03:12:02 <johnw> i've heard that's a good amount, if you can only sleep a little
03:12:26 <frerich> Any father of a newborn can tell you: *any* amount is a good amount.
03:12:38 <frerich> :-)
03:14:20 <bitemyapp> I'll give it a shot but fear I'll regret it. Lets see how 0500->0800 goes.
03:15:07 <johnw> when your alarm goes off, turn on every light you have and give yourself 10 more minutes
03:15:29 <bitemyapp> johnw: willpower tricks :)
03:15:31 <johnw> after that, do something engaging like read twitter or something
03:15:54 <johnw> having trouble waking up is basically my existence, no matter how little or much I sleep
03:16:03 <bitemyapp> johnw: sounds like me, really.
03:16:09 <bitemyapp> 3 hours, 11 hours. same deal.
03:16:19 <johnw> 3, 11, 22, 33
03:16:24 <johnw> tried them all, equally as sleepy
03:17:10 * Kinnison used to have terrible trouble with waking up
03:17:25 * Kinnison cannot recommend highly enough getting something which wakes you when you're in NREM1
03:17:31 <Kinnison> I used to use a Jawbone Up! for that
03:17:45 <johnw> now you use Jawbone Down! to get to sleep?
03:17:52 <bitemyapp> coJawbone?
03:17:55 <isomorpheous> Kinnison: I've tried SleepBot on Android doesn't work for me
03:18:03 <isomorpheous> Kinnison: what app do you use?
03:18:06 <Kinnison> isomorpheous: Is that physically attached to your body?
03:18:12 <isomorpheous> Kinnison: no
03:18:13 <Kinnison> johnw: No, I bought a Pebble and wrote my own
03:18:29 <Kinnison> isomorpheous: You need something physically attached to stand any chance of getting good actigraphic data
03:18:33 <johnw> i'm actually fading now, after the espresso I had at dinner with ed
03:18:36 <isomorpheous> Kinnison: Any product you suggest?
03:18:52 <Kinnison> isomorpheous: I liked the jawbone up, but didn't like that it wasn't a watch too
03:18:54 <isomorpheous> johnw: you're a frenchman, aren't you?
03:18:58 <Kinnison> isomorpheous: so I bought a pebble and am writing my own
03:18:59 <johnw> uh, no
03:19:38 <Kinnison> Unfortunately the pebble is way too embedded for haskell, but I have high hopes of being able to write analysis software etc for the datasets in haskell later
03:22:29 <johnw> bitemyapp: sleep well, I'm out
03:23:13 <isomorpheous> bitemyapp: damn, that repo is actually pretty popular
03:23:20 <isomorpheous> bitemyapp: more stars than anything from bos
04:18:49 <Yuu_chan> ICFPC is tomorrow *_*
04:22:27 <av> Hi everyone, I'm trying to make a cabal package for a FFI bindings that use a library shipped with the cabal package -- is that possible?  I'm at the point where I have to specify where the shared object is that I'm using through FFI (in normal ghc parameters, this would be "-Lsomething") and don't know what to do. Any ideas?
04:28:10 <Yuu_chan> There are a lot of command line parsers in Hackage, what to choose?
04:30:24 <kvanb> Yuu_chan: optparse-applicative
04:41:31 <rylev> Does anyone know a better way to do `NominalDiffTime -> Double` than `fromInteger . toInteger . fromEnum`?
04:42:14 <varnie>  /join #haskell-beginners
04:42:31 <varnie> ops ;)
04:43:41 <ion> rylev: fromIntegral converts from integral types, realToFrac converts from real types. In this case, realToFrac.
04:44:12 <ion> (Are you sure you want to use Double for time, though?)
04:44:42 <rylev> It's what's required by the Statsd library I'm using
04:45:24 <rylev> Thank you so much! I knew I was missing a function
04:53:52 <pertl> trying to learn haskell ... can somebody explain what's wrong with this 'instance' defintion? http://lpaste.net/108021
04:54:24 <ion> Do you have an error message?
04:54:31 <pertl> sure ... wait a sec
04:54:57 <pertl> http://lpaste.net/108022
04:55:10 <pertl> that happens when I try to load it with ghci
04:55:50 <ion> FWIW, given that instance, that type class is more or less useless. “yesno :: (Eq a, Num a) => a -> Bool; yesno x = x /= 0” would work everywhere that yesno does.
04:56:27 <ion> Ok, the problem is that you need an extension to define “instance … => Foo a”. But you shouldn’t be doing that anyway.
04:57:22 <pertl> just working through the "Making Our Own Types and Typeclasses" chapter and trying to fool around with haskell ... yesno doesn't make much sense for sure
04:57:26 <ski> pertl : next time, you could *annotate* the original paste with updates .. that way, they'll appear on the same page
04:57:43 <pertl> alright ! :-)
04:57:50 <pertl> s/alright/allright
04:57:59 <ion> “alright” is alright. ;-)
04:58:02 <pertl> oops
04:58:06 <pertl> thanks *lol*
04:58:40 <pertl> so what is the reason why this thing fails to compile?
04:59:04 <pertl> except the almost zero real world usefulness of the instance
04:59:17 <ski> pertl : as ion says, plain Haskell doesn't allow an instance declaration of the form `instance ... => Foo <some type>', when `<some type>' isn't of the form `T a b .. z', i.e. a type constructor applied to zero or more distinct type variables
05:00:40 <pertl> so instances always require a concrete type constructor to be valid in vanilla haskell?
05:00:41 <ski> pertl : generally, lifting this restriction isn't considered problematic, so if you find that you want to do that, you could enable a language extension which allows this
05:00:43 <ion> pertl: By default “instance Foo a” defines the instance for all types “a”, and no constraints you add to that affect which instance is picked, i.e. that instance is picked for everything.
05:01:07 <ion> Well, s/defines/would define/ if it was allowed
05:01:09 <ski> pertl : if you want to try it out here, you could add `{-# LANGUAGE FlexibleInstances #-}' to the top of your file
05:01:24 <pertl> that was my thought, too. pick up the instance for anything that complies to 'Num' and 'Eq'
05:01:38 <pertl> for that I would need the 'FlexibleInstances' switch, right?
05:02:06 <ski> `FlexibleInstances' doesn't change the instance resolution here to consider the context of the instance declaration
05:02:24 <ski> it just makes GHC accept this non-standard instance head shape
05:03:11 <pertl> think I got it ... now I will finish this chapter and enter the monad chapter (probably for the 7th time or so :-)
05:03:22 <ski> pertl : anyway, the above is how you generally enable a language extension in GHC
05:04:24 <pertl> ok ... I will keep that in mind for later :-)
05:04:26 <ski> (some extensions are considered unproblematic. some others are somewhat more contested. some are probably usually a bad idea)
05:05:08 <ski> `FlexibleInstances' and `FlexibleContexts' are pretty benign
05:05:16 <ion> With the language extensions needed to make that work, given ‘yesno "foo"’ GHC would see the instance “YesNo a” and pick it because “a” can match String. Then it will look at the constraints and see that there’s no “Num String” and give an error about that. If you tried to add “instance YesNo String”, you would get an error about overlapping instances because both “String” and
05:05:18 <ion> “a” match String.
05:06:53 <pertl> bit if I defined "instance (Num a) => YesNo a where ..." and additionally "instance YesNo String where ..."  this would work, right?
05:07:13 <ion> pertl: My response to exactly that question is above. :-)
05:07:34 <pertl> ion: ok, forgive a newby haskell learner :-)
05:07:54 <pertl> even with my scheme background it's still quite a challenge
05:08:21 <ion> Yeah, Haskell is very different from Scheme.
05:08:30 <pertl> the type system is almost unique imho
05:09:14 <Taneb> pertl, Rust's type system bears a lot of similarities, but that borrows from Haskell a fair amount
05:10:08 <pertl> so many languages, so little time *sigh*
05:10:29 <ion> FWIW, you can enable OverlappingInstances to make both “instance YesNo a” and “instance YesNo String” work, but you almost certainly should not do that either.
05:10:46 <ion> please see “Cons” in https://ghc.haskell.org/trac/haskell-prime/wiki/OverlappingInstances
05:11:59 <pertl> sounds like it's almost a code smell to use it
05:15:28 <joash> Is serializing data types for transport across a network a good idea?
05:16:26 <frerich> joash: Is the emphasis on 'serializing' or on 'network'?
05:16:30 <frerich> Or on something else? :)
05:17:18 <joash> Network, I guess... I want to communicate to another node on the network
05:17:34 <joash> and handle different message types differently
05:18:03 <joash> but how would I know how to handle the message, If i don't know the type beforehand?
05:18:11 <frerich> joash: Given that a network connection has no concept of 'types' (it's just a stream of bytes) you'll need some sort of serialization, so the answer is a clear 'Yes, it's a good idea' :)
05:18:33 <joash> thanks!
05:18:35 <frerich> joash: Assuming taht you use Haskell on both sides (and exclusively Haskell), Data.Binary might be a good choice.
05:18:42 <joash> ah
05:18:47 <joash> so i could just
05:18:52 <joash> spit out some binary
05:19:03 <joash> and read it back as a haskell data type?
05:20:17 <frerich> joash: That's right, Data.Binary has functions for serialization a large range of types from/to plain bytes.
05:21:09 <joash> I see, so I just have to instance the Binary typeclass
05:21:36 <joash> thanks :)
05:22:20 <frerich> joash: Right, but there are also packages for automatically deriving instances
05:24:45 <joash> cool.. that's really helpful thanks :)
05:39:36 <Yuu_chan> How to use png images with Gloss?
05:43:06 <Yuu_chan> Googled Gloss-Juicy, nevermind :)
05:44:39 <btcNeverSleeps> Could someone quickly explain what's the different between an ADT which is a "product type" and an ADT which is a "sum type"?  Is this an important distinction?
05:46:24 <btcNeverSleeps> I guess my question is: when I create a data type in Haskell using "data ... = ...", do I need to know if I'm creating a product type or a sum type?  Does it have any implication that it is one or the other (or both!?)?
05:48:04 <zomg> sum type is anything which has multiple constructor, product type is the kind which just has one
05:48:46 <zomg> or something along those lines anyway... It doesn't really seem to matter at least as far as I can tell
05:49:53 <Yuu_chan> btcNeverSleeps: a value of A * B holds a value from A _and_ a value from B; a value of A + B holds a value from A _or_ a value from B
05:50:38 <latk> Which module should I be using for filepath manipulation ?
05:50:40 <ClaudiusMaximus> btcNeverSleeps: data defines a sum of products in general, eg data A = B C D | E F G
05:50:46 <latk> e.g. joining paths toget etc.
05:50:49 <latk> together*
05:51:07 <Axman6> :t (</>)
05:51:09 <lambdabot>     Not in scope: ‘</>’
05:51:09 <lambdabot>     Perhaps you meant one of these:
05:51:09 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
05:51:12 <Axman6> bleh
05:51:17 <ClaudiusMaximus> @hoogle FilePath
05:51:19 <lambdabot> Prelude type FilePath = String
05:51:19 <lambdabot> System.IO type FilePath = String
05:51:19 <lambdabot> System.FilePath.Windows type FilePath = String
05:51:23 <kvanb> hint, product and sum type can be remembered by boolean algebra
05:51:26 <kvanb> where + means or.
05:51:26 <ski>   A = C * D + F * G
05:51:35 * hackagebot repa 3.3.1.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.3.1.1 (BenLippmeier)
05:51:36 <kvanb> and * means and.
05:51:44 <zomg> kvanb: assuming one knows boolean algebra =)
05:51:54 <btcNeverSleeps> Yuu_chan: oooh that I understand
05:51:54 <kvanb> <- mechatronics engineer :P
05:51:55 <ski> `A * B' can be thought of as cartesian product of the sets `A' and `B'
05:52:10 <ClaudiusMaximus> latk: you want System.FilePath which re-exports the right implementation for the OS you are on
05:52:19 <latk> ClaudiusMaximus: Cool, thanks
05:52:19 <ski> `A + B' can be thought of as disjoint union (*not* ordinary union) of the sets `A' and `B'
05:52:26 <Yuu_chan> kvanb: or the set theory. * as cartesian product, + as a disjoint union.
05:52:39 <Yuu_chan> Too slow =\
05:52:42 <kvanb> heh
05:52:47 * ski smiles
05:52:50 <kvanb> I can't comment on that, I dont know any set theory
05:53:18 <ski> in set theory, `A * B' is the set of all pairs of elements taken respectively from `A' and `B'
05:53:33 <zomg> Haskell would be so much better if it had been written by true hackers like PHP was, and not by mathematicians!
05:53:35 <kvanb> A U B ?
05:53:38 <zomg> </troll>
05:53:39 <zomg> lol
05:53:46 <frerich> ski: Hm so would 'T a b = T a b' be a product type but 'T a b = A a | B b' be a sum type? and 'T a = T a' is both (a bit absurd, I guess)?
05:53:57 <ski> kvanb : so `{0,1} * {2,3,4}' is the set `{(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)}'
05:53:58 <Yuu_chan> ski: btw, is (*) commutative in set theory?
05:54:09 <ski> frerich : yes
05:54:16 <kvanb> frerich: correct, except the last one is something special
05:54:16 <ski> Yuu_chan : only up to isomorphism
05:54:20 <kvanb> like an identity or something
05:54:36 <btcNeverSleeps> ok so when I define a type in Haskell I'll typically be doing so by creating a disjoint union (?) of A and B, like in "data Bool = True | False"?
05:54:53 <btcNeverSleeps> I mean: the type is the disjoint union of A and B?
05:55:23 <ski> btcNeverSleeps : the `|' in a `data' declaration corresponds to disjoint union
05:55:28 <btcNeverSleeps> ski: ok
05:55:32 <zomg> Does Haskell actually make some use of the concept of sum and product types?
05:55:45 <zomg> I've just seen the words waved around a little a few times and in some articles
05:55:54 <btcNeverSleeps> and does it matter at all when, later, I'm using that type? (for example does it have implication for pattern matching?)
05:56:07 <frerich> zomg: That would have been my next question as well - are there cases where it makes sense to distinguish the two?
05:56:11 <ski> (but you can't say e.g. `data Foo = C (Maybe (X | Y))' or something like that. you can only use `|' with `data' on the "toplevel")
05:56:14 <frerich> (in the context of Haskell)
05:56:17 <btcNeverSleeps> frerich: well, that's basically my question : )
05:56:25 <zomg> frerich: yeah, as far as I can tell there is no difference beyond which one makes more sense in context of modeling your data structure
05:56:36 * hackagebot repa-io 3.3.1.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.3.1.1 (BenLippmeier)
05:56:38 * hackagebot repa-algorithms 3.3.1.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.3.1.1 (BenLippmeier)
05:56:50 <ski> zomg,frerich : it's good to know a little about the terminology, i think
05:56:55 <quchen> zomg: Sure, Lenses are for products, and prisms for sums, for example.
05:57:11 <zomg> quchen: of course lens is the one where this is used
05:57:12 <zomg> :D
05:57:16 <quchen> zomg: You can also use "sum and product" as analogies to check whether two types can possibly be isomorphic.
05:57:33 <quchen> Either Bool Bool = (Bool, Bool)?
05:57:39 <ski> product types and sum types are good for when one's thinking conceptually about types, not necessarily thinking in terms of Haskell types in particular
05:57:40 <quchen> Well, check how many values each side has
05:57:43 <Yuu_chan> ski: is there some type theory concept or extension that would allow your example?
05:58:16 <ski> Yuu_chan : one could certainly say `data Foo = C (Maybe (Either X Y))', assuming `X' and `Y' are defined types
05:58:27 <quchen> zomg: It's also good to know that you can decompose ADTs into sums and products (and powers, i.e. functions). Generics use that principle to write generic functions that work with lots of different classes, for example.
05:58:40 <zomg> I see
05:59:02 <ski> zomg,frerich : e.g., when differentiating types, which is related to zippers, it helps to think conceptually in terms of `*' and `+'
05:59:15 <quchen> data [a] = 1 + a*[a]
05:59:24 <Yuu_chan> Or, like... data Foo a = (Ratio | Maybe) a
05:59:25 <frerich> quchen: A 'power type'? Would that be a recursive definition of a product type?
05:59:40 <quchen> frerich: No, the type "a -> b" loosely corresponds to b^a
05:59:56 <quchen> So if you have "Bool -> Bool" there can be 2^2 total functions with that type
05:59:59 <frerich> For large values of "loosely", I guess...
06:00:05 <frerich> Ah.
06:00:20 <ski> and there's `2^3' total functions of type `Ordering -> Bool'
06:00:21 <frerich> Wait
06:00:28 <quchen> frerich: I'm not sure how "loosely", but there might be some pretty important connection there.
06:00:36 <quchen> This "power" thing is not just coincidence.
06:01:37 * hackagebot repa 3.3.1.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.3.1.2 (BenLippmeier)
06:01:45 <frerich> When you say 'thre are 2^2 total functions with that type' you mean there are 2^2 different ways to map each value of the input set to one (or more) values of the output set?
06:02:28 <quchen> 1. f True = True; f False = False.  2. f True = True, f False = True. 3. f True = False, f False = False. 4. f True = False, f False = True.
06:02:30 <frerich> I'm trying to remember my University courses with sets drawn on the left and right, and a function is basically a (set of) mappings ("projections"?)
06:02:44 <quchen> Those are all the different f you can produce.
06:02:55 <frerich> quchen: Right
06:03:25 <quchen> You can basically see it as a combinatorical problem. You have N inputs and have to somehow connect them to the M outputs.
06:03:37 <frerich> What about 'Bool -> [Bool]'? There's an infinite amount of values possible for '[Bool]', no?
06:03:38 <quchen> (Not all outputs have to be connected of course, no need to be surjective)
06:03:55 <quchen> [a] = 1/(1+a) if I remember correctly ;-)
06:04:40 <quchen> [a] = 1 + a*[a] = 1 + a*(1 + a*[a]) = 1 + a + a*a*[a] = … = 1 + a + a^2 + a^3 + …
06:04:52 <ski> frerich : try writing a function of type `Eq a => [a] -> [b] -> [a -> b]' that given a list of values of type `a' and a list of values of type `b' generates a list of every possibly function mapping those `a' values to those `b' values ?
06:05:08 <ski> quchen : no, `[a] = 1 / (1 - a)' :)
06:05:09 <Yuu_chan> quchen: 1/(1-a)?
06:05:15 <Yuu_chan> Too slow again >_<
06:05:25 <quchen> Eh, that geometric series minus again
06:05:56 <quchen> This is only a symbolic equation of course, since there's no notion of "a < 1" here to make that thing converge
06:06:02 <ski> anyway, a list of `a's either contains no `a' (`1'), or one `a' (`a'), or two (`a^2'), or three (`a^3'), or ...
06:06:16 <ski> is what quchen's derivation above says
06:06:37 * hackagebot repa-io 3.3.1.2 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.3.1.2 (BenLippmeier)
06:06:39 * hackagebot repa-algorithms 3.3.1.2 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.3.1.2 (BenLippmeier)
06:08:03 <frerich> Right, that's what I'm saying: there's an infinite number of values having type [Bool], so there is an infinite number of functions possible with type 'Bool -> [Bool]' -- is it still a 'power type'?
06:08:06 <frerich> Or more like a 'super power'? :)
06:08:20 <Yuu_chan> | is plus, constructor is multiply, -> is power, zipper is derivative, what would be an integral?
06:08:23 <ski> it's still an exponential type, yes
06:08:51 <quchen> Often you treat infinity as a sort of number for "many" here. Infinities are fine, since we're way down in handwavy terrotory.
06:09:21 <ski> (zipper isn't derivative. zipper is *related* to derivative. zipper also relies on some chosen way to "stratify" the data)
06:09:29 <quchen> For example "Either [Bool] ()" is obviously "Either () [Bool]" although in the "numbers" picture you're clearly adding ∞
06:09:53 <ski> yes, disjoint union `+' is only commutative, up to isomorphism
06:11:19 <Yuu_chan> Okaym what would be *related* to integration then?
06:11:38 * hackagebot repa-examples 3.3.1.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.3.1.1 (BenLippmeier)
06:11:45 <ski> i'm not sure
06:12:11 <ski> but the natural exponential function is bags
06:12:15 <quchen> Maybe the question does not even make much sense. Integration isn't the direct opposite of differentiation in many places.
06:12:26 <quchen> (Maybe.)
06:12:33 * Yuu_chan handwaves
06:12:40 <frerich> I think it's quite amusing to think about types like this. I wonder whether one could find a 'difference' type in Haskell, something which has all values of 'A' but not those in 'B'
06:12:40 * ski waves hands
06:13:14 <quchen> frerich: I think merijn has written something like that once, using type families.
06:13:23 <frerich> I suppose that would mean that 'B' would need to be a subset of 'A'. Maybe 'Word16' vs. 'Word8'.
06:13:26 <quchen> It was a list that can contain anything but Bool or something along those lines.
06:13:35 <ski>   Bag a = 1 + a + a^2 / 2 + a^3 / 3! + a^4 / 4! + ...
06:13:48 <Yuu_chan> data NonZero a = a - 0
06:14:10 <ski> i'd think `a - 0' ought to be isomorphic to `a' ?
06:14:50 <Yuu_chan> ski: then the notion is lost...
06:14:57 <mbrock> isn't it just a - 1?
06:15:16 <mbrock> er, well, I dunno anything about this
06:15:21 <ski> it's not clear to me why it would be named `NonZero' ..
06:15:29 <Yuu_chan> Er, I meant 0 as a value/constructor.
06:15:51 <ski> i've been pondering a little sometimes whether one could extend the Grothendieck construction to sets/types
06:15:58 <Kaidelong> does haskell have any way of expression a type level -?
06:16:03 <Kaidelong> expressing*
06:16:12 <ski> Kaidelong : i don't think so
06:16:16 <Kaidelong> someone on reddit was asking about what dependently typed languages can do that haskell can't
06:16:20 <Kaidelong> this might be an example
06:16:26 <Yuu_chan> data Definitely a = Maybe a - Nothing
06:17:02 <ski> Kaidelong : not on types. obviously you can use a value-level subtraction inside types in a dependently types system, though
06:17:29 <Kaidelong> ski: couldn't it be seen as a statically checked constraint?
06:17:30 <ski> and you can probably do something shady with type families, for a particular embedding of e.g. naturals in types
06:17:44 <latk> What should I be using for logging in haskell ?
06:17:51 <Kaidelong> you can manually implement similar things in haskell by hiding constructors to make things like NonEmptyList
06:17:51 <quchen> Yuu_chan: Interesting, that would be a function that guarantees a certain constructor in its result if it mapped to it. I guess "f ~Nothing = 1" has type "Definitely (not a) -> Int" :-D
06:17:52 <ski> Kaidelong : constraint expressing what ?
06:18:14 <ski> Kaidelong : "refinement types" might be related to what you're thinking about
06:18:40 <ski> with refinement types, one could declare something like
06:19:07 <ski>   data refinement EvenList a = [] | a :  OddList a
06:19:19 <ski>   data refinement  OddList a =      a : EvenList a
06:19:47 <Kaidelong> data NonEmptyList t = NonEmpty t [t]
06:19:55 <benzrf> ski: hows that different from just data
06:19:56 <quchen> No, that would be an infinite list.
06:19:57 <ski> so that `EvenList a' and `OddList a' becomes subtypes of `[a]', derived by removing elements
06:20:01 <benzrf> oh
06:20:06 <benzrf> subtypes
06:20:10 <Kaidelong> you can do that but you can't do data NonEmptyList t = [t] - []
06:20:21 <quchen> Kaidelong: NonEmpty a = a :> [a]
06:20:36 <ski> usually with subtyping for variant types, you can *add* more elements to a variant type, and get a supertype
06:20:45 <ski> (and for record types, add more fields, and get a subtype)
06:21:03 <ski> with refinement types, you instead remove alternatives, and get a subtype
06:21:03 <mmmm> Is there a nicer way to write my eval function in this example? http://lpaste.net/108024
06:21:51 <ski> Kaidelong : so, with refinement types, that'd be something like `data NonEmptyList a = a : [a]'
06:22:05 <Yuu_chan> quchen: what's a ~? I enjoyed the pun, though :)
06:22:35 <frerich> mmmm: I don't know a nicer way, but why does "AddF" take two "f a" instead of two "ExpF f a"?
06:23:03 <ski> Yuu_chan : lazy/irrefutable pattern patch, i suppose
06:23:17 <ski> > let f ~Nothing = 1 in f (Just False)
06:23:18 <lambdabot>  1
06:23:32 <ski> > let f Nothing = 1 in f (Just False)
06:23:33 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in function f
06:23:53 <Yuu_chan> Ah, that.
06:23:55 <ski> > let f ~(Just x) = x in f Nothing
06:23:56 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern (Da...
06:24:01 <ski> > let f ~(Just x) = 2 in f Nothing
06:24:02 <lambdabot>  2
06:24:06 <ski> > let f (Just x) = 2 in f Nothing
06:24:07 <lambdabot>  *Exception: <interactive>:3:5-18: Non-exhaustive patterns in function f
06:24:33 <ski> only when `x' is forced is the pattern inside `~' matched
06:24:45 <Yuu_chan> Yes, now I remember that. Couldn't parse in that context due to their rarity :)
06:24:54 <ski> in the `~Nothing' case, there was no variable inside, so it's never forced :)
06:25:04 <fread22282> How can I get a "m (f (m a)) -> m (f a)" when f is Applicative and I can require m to be whatever I need?
06:25:41 <ski> fread22282 : `Traversable m' ?
06:25:50 <mr-> Take m = Identity, then everything is just f a
06:26:19 <fread22282> well, I'd like to not require m to be Identity
06:26:38 <ski> @type T.sequenceA
06:26:39 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
06:26:49 <ski> hm, i suppose the other way around
06:27:15 <fread22282> :t (fmap join . sequenceA)
06:27:16 <lambdabot>     Not in scope: ‘sequenceA’
06:27:16 <lambdabot>     Perhaps you meant one of these:
06:27:16 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
06:27:19 <ski> @type join . liftM T.sequenceA
06:27:20 <lambdabot> (Traversable t, Applicative m, Monad m) => m (t (m a)) -> m (t a)
06:27:32 <fread22282> :t (fmap join . T.sequenceA)
06:27:32 <lambdabot> (Traversable m, Applicative f, Monad m) => m (f (m a)) -> f (m a)
06:27:43 <ski> @type join . liftM T.sequence
06:27:44 <lambdabot> (Traversable t, Monad m) => m (t (m a)) -> m (t a)
06:28:52 <ski> @type (T.sequence =<<)
06:28:53 <lambdabot> (Traversable t, Monad m) => m (t (m a)) -> m (t a)
06:29:07 <danilo2> Hello! Do you use the syb library? I'm asking because I've discovered it - it seems very interesting and I'm just curious if it is widely used and is something liek a standard library, everybody should know? :)
06:30:03 <mmmm> it's a bit old now danilo2 there are other libraries which do similar things
06:30:05 <fread22282> danilo2: syb is IMO obseleted by uniplate, GHC.Generics and lens' plated
06:30:26 <mmmm> thanks frerich, just what I needed
06:30:52 <danilo2> mmm, fread22282 : oh, thank you! I was just feeling that syb is somewhat simmilar to lens by looking fast at the docs :) Thank you! :)
06:30:59 <frerich> mmmm: Oh? I was just thinking -- if that type was a bit different, your 'eval' function would be a lot simpler, too (at least for 'Add') :-)
06:31:25 * ski doesn't like SYB
06:31:46 <ski> it feels dirty
06:31:52 <fread22282> danilo2: in general it isn't, but lens has it's own version of uniplate/syb that uses Traversals and is faster and IMO easier to use
06:32:03 <ski> there's also multiplate
06:32:04 <fread22282> in Control.Lens.Plated
06:32:54 <danilo2> Oh so does uniplate / multiplate do the same than lens version? Or they provide different unctionality?
06:33:10 * ski hasn't looked at the lens one
06:33:32 <eikke__> I ported something from SYB to Lens once, but only very basic code
06:33:40 <eikke__> that was fairly trivial
06:33:41 <fread22282> danilo2: they do the same thing but the lens one is faster and easier to write handwritten instances for
06:34:03 <fread22282> (and gives you a Traversal that works with other lens functions)
06:34:42 <danilo2> fread22282: ok, so if I would need to use something like that, I should just pick the lens one - uniplate / multiplate can be considered just obsolete if they are slower / provide the same functionality? :)
06:34:45 <haasn> It can also work using traversals you give it, meaning you don't even need to write instances
06:35:45 <fread22282> danilo2: yes but GHC.Generics is the fastest (and lens has support for it, but AFAIK it's not really useful) and lens is a bigger package
06:36:41 * hackagebot hackport 0.4.3 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4.3 (SergeiTrofimovich)
06:36:46 <danilo2> fread22282: oh, why Generics is fastest? Its about optimizations or just code generation capability at compile time?
06:37:56 <fread22282> danilo2: GHC.Generics works differently
06:39:44 <danilo2> fread22282: I understand - but could you tell a little more where the difference in speed comes from?
06:41:28 <ski> danilo2 : see <https://skillsmatter.com/skillscasts/3932-a-haskell-lecture-with-leading-expert-andres-loh> for `Generic'
06:43:17 <danilo2> ski: Oh, thank you very much! :)
06:44:40 <fread22282> danilo2: they don't really solve the same problem (GHC.Generics can be used to do what uniplate does but then it's not much faster)
06:44:55 <noteventime> Hmm, how do I specify the C preprocessor search path inside ghci, it should be something like ':set -optP -I/path', but I can't seem to get it right
06:45:37 <noteventime> oh, no space fixed it, sorry :)
06:45:45 <mmmm> actually frerich, I'm not sure that works
06:45:47 <danilo2> fread22282, ski: Ok, thank you for all the info and help :) I'll watch the video ski linked and I'll try to feel the difference by myself now :)
06:46:27 <ski> `Generic' is more or less a way to be able to derive more type classes
06:46:58 <ski> (or rather, that's what it's mostly used for)
06:47:28 <kosmikus> quchen, ski: thanks for advertising my talk
06:47:42 <quchen> kosmikus: Andres?
06:47:49 <kosmikus> quchen: you said yesterday (approximately) that SYB is what triggered GHC.Generics
06:48:01 <kosmikus> quchen: that's not entirely accurate, so I'd like to give my perspective
06:48:01 <quchen> Yes, I remember. Was that not right?
06:48:07 <fread22282> danilo2: IMO yes, but lens is a bigger package
06:48:17 <kosmikus> quchen: GHC.Generics goes back to PolyP
06:48:23 <fread22282> whyps
06:48:27 <fread22282> whops
06:48:31 <ski> kosmikus : i forgot you're Löh :)
06:48:36 <fread22282> danilo2: nvm
06:48:44 <danilo2> fread22282: :)
06:48:56 <kosmikus> quchen: so that's from 1997
06:49:09 * ski recalls reading about PolyP
06:49:11 <kosmikus> quchen: it was followed by Generic Haskell, another preprocessor
06:49:44 <kosmikus> quchen: and ultimately all this evolved into what's now GHC.Generics (and some similar libs, like regualar, instant-generics, emgm, multirec, or generics-sop)
06:50:09 <kosmikus> quchen: the other big line of generic programming which is represented by SYB originally goes back to Strafunski, and before that even to Stratego
06:50:10 <quchen> I see. So the resemblance between SYB and GHC.Generics is just coincidence?
06:50:22 <kosmikus> quchen: Stratego is a domain-specific rewriting language
06:50:39 <kosmikus> see http://strategoxt.org/
06:50:57 <kosmikus> I'm not entirely sure how old Stratego is
06:51:11 <kosmikus> but I'm relatively sure that the origins of Stratego and PolyP are mostly independent
06:51:25 <kosmikus> so while over the years there's certainly been a lot of interaction and influence both ways
06:51:35 <kosmikus> I don't think it's entirely fair to say that one thing triggered the other
06:51:41 <ski> "PolyP - a polytypic programming language" by Patrik Jansson,Johan Jeuring,Ulf Norell at <http://www.cse.chalmers.se/~patrikj/poly/polyp/>
06:51:49 <kosmikus> yes, that's it
06:51:59 <quchen> kosmikus: Are any of those still used, or were they just leading the way to the current state?
06:52:41 <kosmikus> quchen: Stratego is still used, but has nothing to do with Haskell
06:53:14 <kosmikus> quchen: PolyP and Generic Haskell are "dead"
06:53:25 <kosmikus> they come from a time when the Haskell type system was much weaker
06:53:30 <kosmikus> so you needed a preprocessor
06:53:47 <kosmikus> now, you can do everything with libraries, small GHC extensions, and/or TH
06:54:48 <kosmikus> the closest to being "Stratego in Haskell" with state-of-the-art language features right now is, btw, not SYB, but rather KURE
06:55:19 <tech2> whut?
06:56:14 <tech2> Too many acronyms
06:56:28 <quchen> Okay, I will not say anything about where GHC.Generics came from in the future hehe
06:56:55 * tech2 curls into a ball and waits for the kicking to stop.
06:57:41 <kosmikus> quchen: ah, please don't take this as criticism. I thought you'd find it interesting, that's all ;)
06:58:04 <fread22282> danilo2: the realtion between them is that you can write Uniplate/Plated instances using GHC.Generics
06:58:15 <quchen> kosmikus: Don't worry, I was just joking.
06:58:36 <quchen> Thanks for the lesson, and nice to meet you on IRC in person-y :-)
06:58:36 * fread22282 thinks that those instances would be faster than Data.Data ones but slower than hand-written ones
06:58:46 <kosmikus> quchen: :)
06:59:53 <kosmikus> quchen: so my latest attempt at generic programming in Haskell is actually generics-sop, so I'm currently quite fond of that
07:00:08 <quchen> I assume that's on Hackage?
07:00:15 <kosmikus> quchen: https://hackage.haskell.org/package/generics-sop
07:00:32 <latk> Is there some way to expose a module only for tests ?
07:00:59 <kosmikus> quchen: contrary to GHC.Generics, I've at least tried this time to provide reasonable documentation ;)
07:00:59 <latk> e.g. in cabal I have a library and test-suite
07:01:12 <danilo2> fread22282: Oh, ok, good to know that! :)
07:01:13 <quchen> latk: Not really. I usually expose everything, but put the "don't use" parts in "Internal" modules.
07:01:36 <quchen> kosmikus: Yeah documentation wasn't really a good guide last time I tried using generics :-S
07:02:24 <quchen> kosmikus: Should I read the paper, or is there a one-line explanation of what sop does different compared to ordinary generics?
07:02:35 <kosmikus> quchen: it's currently not quite as bad as it used to be, but I'd still classify it as horrible ;)
07:02:52 <quchen> nothing + ε ;-)
07:03:02 <latk> quchen: What do you mean by internal modules ?
07:03:12 <kosmikus> quchen: ordinary GHC.Generics uses binary sums and products and lots of metadata tags in the middle of the structure
07:03:29 <kosmikus> quchen: generics-sop uses n-ary sums and products and separates out all metadata
07:03:37 <quchen> latk: Modules that have "Internal" in their names are not supposed to be used by other packages by convention.
07:03:56 <kosmikus> quchen: I think that makes generics-sop more type-safe (in a certain sense), easier to understand and easier to work with
07:04:03 <quchen> They're "I expose this for some reason, but do not depend on it as internals can change a lot"
07:04:06 <kosmikus> quchen: but it's in principle equally expressive
07:04:28 <quchen> kosmikus: Okay, so is it easier to work with? In other words, what are the benefits?
07:04:30 <kosmikus> quchen: in fact, you can compute the generics-sop strucutral representation from the GHC.Generics one
07:04:54 <quchen> Eh wait, I overlooked your one sentence.
07:04:54 <kosmikus> quchen: well, "easy to work with" is a subjective matter, but I think so, yes
07:05:53 <latk> quchen: Ah, okay.
07:06:07 <eikke__> I read the generics-sop paper a couple of days ago with great interest
07:06:31 <eikke__> not sure I could actually use the API to implement something useful though
07:07:35 <kosmikus> eikke__: you mean, because you lack applications for this kind of generic programming, or because you think the API is bad?
07:09:49 <eikke__> kosmikus: I didnt actually use it yet, but it seemed somewhat complicated to figure out how to go from a problem to a solution using the API
07:09:59 <eikke__> might be because I'm not overly familiar with generic programming though
07:10:39 <kosmikus> eikke__: like with all higher-order functions, learning to make effective use of them may take some time
07:10:56 <kosmikus> eikke__: however, you can always define functions by directly traversing the NS/NP structures
07:11:29 <kosmikus> eikke__: see the two definitions of grnf near the top of https://hackage.haskell.org/package/generics-sop-0.1.0.2/docs/Generics-SOP.html as an example
07:11:57 <kosmikus> eikke__: the first is straight-forward but length, the second is a concise one-liner, but may appear more cryptic at first
07:12:07 <kosmikus> eikke__: s/length/lengthy/
07:12:57 <kosmikus> eikke__: I'd argue that both are still much clearer than the code you'd have to write for GHC.Generics though
07:14:49 <eikke__> kosmikus: I'll take a look :)
07:27:16 <NorfairKing> #icq-lebanon
07:33:17 <vlatkoB> Can't understand why "shortened" bind definition goes into infinite loop. Can someone explain?
07:33:33 <vlatkoB> http://lpaste.net/108027
07:35:32 <supki> join is defined in terms of >>=
07:37:32 <merijn> vlatkoB: >>= calls join, which calls >>=, which calls join, etc.
07:37:39 <vlatkoB> supki: So, join is looping in calling itself?
07:37:52 <ion> If you want to define something in terms of join, you’ll need to write a “where join' = …” now or a definition of join (instead of (>>=)) after GHC 7.10 or so.
07:38:07 <merijn> vlatkoB: Indirectly, yes
07:38:09 <quchen> ion: join won't be part of Monad in 7.10, maybe one release later :-\
07:38:15 <ion> quchen: Aww, okay.
07:38:21 <merijn> vlatkoB: "join x = x >>= id"
07:38:43 <merijn> vlatkoB: And in your example "x >>= f = join (f <$> x)"
07:39:09 <vlatkoB> I understand. Thanks guys. :-)
07:39:09 <quchen> ion: On the other hand, adding it to Monad won't be a big change. (There are some problems with autoderiving Monad I think, and having that is more useful than having join in the class.)
07:39:29 <quchen> Maybe there's more to it, but you get the gist: it's complicated for internal reasons
07:39:35 <ion> aye
07:39:48 <quchen> But a fix is desirable, not only because of join.
07:39:54 <ion> yeah
07:39:55 <merijn> vlatkoB: So you get "x >>= f" -> "join (f <$> x)" -> "(f <$> x) >>= id" -> "join (id <$> (f <$> x))", etc. :)
07:41:37 <vlatkoB> merijn: Yes, all clear now. I'll try to write it another way.
07:44:26 <frerich> Huh, I just did a typo in '' and as it turns out, '<$' is in Data.Functor, too...
07:44:44 <frerich> Er in 'lower-than dollar greater-than' (I wish I knew why this IRC client swallows that)
07:45:38 <quchen> <$>
07:45:41 <quchen> That one?
07:45:45 <frerich> Right
07:45:48 <quchen> $> is in Data.Functor too since 7.8
07:55:53 <shlevy> What's the difference between Control.Concurrent.STM.TBMQueue and Control.Concurrent.STM.TBMChan?
07:56:26 <mathk> Hi I have an issue with the library tuple. I am trying to use curryN but I got a compiler error a bit strange: http://pastebin.com/3CzM7bDn
07:56:30 <quchen> TBMChan? That's not part of the standard lib, shlevy
07:56:52 <shlevy> quchen: Sorry looking at stm-chans
07:57:10 <TheKing444> Well, a Chan can be cloned, a Queue can not, but it is faster.
07:57:15 <shlevy> quchen: I know in the standard lib the queues don't have dup and clones
07:57:30 <TheKing444> Look at https://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TQueue.html .
07:57:40 <mathk> Why the haskell can not infer the type of Maybe a0 ?
07:57:42 <quchen> "A version of Control.Concurrent.STM.TQueue where the queue is bounded in length and closeable. This combines the abilities of Control.Concurrent.STM.TBQueue and Control.Concurrent.STM.TMQueue. "
07:57:46 <shlevy> But I don't see a clone for the Chan
07:57:58 <shlevy> Right, I'm looking at that and the TBMChan page
07:58:05 <shlevy> They seem to offer an identical interface
07:58:16 <frerich> mathk: Can you paste some code which exhibits the issue at lpaste.net ?
07:58:24 <TheKing444> well that is odd
07:58:53 <Javran1> @hoogle Maybe [a] -> [a]
07:58:55 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
07:58:55 <lambdabot> Prelude cycle :: [a] -> [a]
07:58:55 <lambdabot> Data.List cycle :: [a] -> [a]
07:59:34 <Taneb> Javran1, catMaybes :: Maybe [a] -> [a]
07:59:44 <Taneb> @type catMaybes
07:59:45 <lambdabot> [Maybe a] -> [a]
07:59:52 <Taneb> ...whoops, sorry
08:00:01 <Taneb> Misthink
08:00:02 <TheKing444> I guess TBMChan is the same then.
08:00:04 <Javran1> :t fromMaybe []
08:00:05 <lambdabot> Maybe [t] -> [t]
08:00:14 <quchen> :t fold :: Maybe [a] -> [a]
08:00:15 <lambdabot> Maybe [a] -> [a]
08:00:16 <Javran1> just wondering if there's something better
08:00:39 <quchen> > fold (Just [1,2,3])
08:00:40 <lambdabot>  [1,2,3]
08:00:49 <quchen> > fold Nothing :: [Int]
08:00:51 <lambdabot>  []
08:00:55 <Javran1> quchen: Taneb: thanks!
08:01:35 <quchen> Foldable is a pretty useful class, make sure to visit it at some point!
08:02:24 <Javran1> quchen: sure!
08:03:03 <mathk1> frerich, here it is http://lpaste.net/108033
08:04:14 <joshc> > fold [1,2,3,4] :: Product Int
08:04:16 <lambdabot>  Product {getProduct = 24}
08:04:25 <joshc> > fold [1,2,3,4] :: Sum Int
08:04:26 <lambdabot>  Sum {getSum = 10}
08:07:26 <Lara21>  You can find funny videos here. http://bit.ly/1nkMPqk
08:08:02 <quchen> joshc: Oh nice, I didn't know Sum X had a Num instance
08:08:40 <eikke__> > (Sum 10) * (Sum 2)
08:08:41 <lambdabot>  Sum {getSum = 20}
08:08:48 <mathk1> any idea why I have this issue ? frerich
08:10:00 <frerich> mathk1: No, but can you add a couple of relevant signatures, i.e. for parseBranchArgument and curryN (jsut the signatures are enough) as well as the types 'ArmStreamState' and whatever 'B1' is? Ideally enough to have a http://sscce.org/
08:10:01 <phaskell> B1: Diff 8 - https://phabricator.haskell.org/B1
08:10:40 <mathk1> curryN is the method from the hackage tuple
08:11:22 <Kaidelong> what's the issue here exactly?
08:11:44 <mathk1> the issue is : http://pastebin.com/3CzM7bDn
08:14:08 <Kaidelong> mathk1: curryN can't figure out how many arguments Just is expecting, is there a curry3?
08:14:44 <Kaidelong> but why not just write
08:14:56 <Kaidelong> Just(B1,False,args)
08:15:05 <Kaidelong> more parsimonious
08:15:50 <Kaidelong> if you are intending to partially apply Just, you could just eta-expand it
08:15:59 <Kaidelong> \x -> Just(B1,False,args,x)
08:16:29 <mathk1> Kaidelong, I want to use the functor after : (curryN Just Bl False) <$> parse...
08:16:53 * hackagebot mongoDB 2.0.3 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0.3 (GregWeber)
08:17:19 <mathk1> ArmStreamState is a state monad
08:17:57 <Kaidelong> mathk1: isn't that just the eta-expansion case? (\x -> Just(Bl,False)) <$> parse...
08:18:09 <Kaidelong> Just(Bl,False,x)*
08:18:34 <mathk1> Kaidelong, yes but I was willing to avoid the lambda
08:18:46 <Kaidelong> the lambda makes things easier in this case
08:19:07 <mathk1> I can expand it to use applicative
08:19:17 <Kaidelong> the compiler can't tell if you are talking about (a,b,c) -> Maybe r or (a,b,c,d) -> Maybe r or (a,b,c,d,e) -> Maybe r or so forth
08:19:35 <mathk1> curryN Just <$> parse.. <*>  parse.. <*> parse...
08:19:36 <Kaidelong> Just is completely polymorphic in its argument so any one of them could work
08:20:14 <Kaidelong> mmm I think that would still run into the same problem unless you happen to hit the magic number where they stop giving any more instances
08:20:23 <mathk1> :)
08:20:43 <Kaidelong> but that would break if the library authors decide to make even more instances
08:21:25 <Kaidelong> I think Just is just a bit too perverse for curryN's implementation to deal with, although
08:21:31 <Kaidelong> you could do this instead of a lambda
08:22:00 <Kaidelong> curryN (Just :: (T,U,V,B) -> Maybe (T,U,V,B))
08:22:12 <Kaidelong> and resolve the ambiguity by giving an explicit signature
08:22:17 <shlevy> johnw: https://www.newartisans.com/2014/06/simpler-conduit-library is down
08:22:42 <Kaidelong> honestly just using a lambda expression is simpler
08:23:25 <ajcoppa> shlevy: http appears to work fine
08:24:08 <mathk1> Ican define a function justCurry3 :: a -> b -> c -> Maybe (a,b,c)
08:24:46 <Kaidelong> that would work too
08:24:53 <Kaidelong> you could even put it in a where clause
08:25:08 <mathk1> it aslmost as if I was writing the lambda :)
08:25:14 <Kaidelong> you are
08:25:26 <Kaidelong> the only difference is syntax, at least in theory
08:25:44 <Kaidelong> I would recommend you just use the lambda, it's the least bad alternative
08:25:57 <mathk1> I have many place where I would like to use the justCurry3
08:26:15 <S11001001> @pl \a b -> Just . (a,b,)
08:26:15 <lambdabot> (line 1, column 18):
08:26:15 <lambdabot> unexpected ","
08:26:15 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
08:26:59 <shlevy> When should I use MonadBaseControl IO vs MonadIO?
08:27:13 <Kaidelong> @ty ((Just .) .) . (,)
08:27:14 <lambdabot>     Couldn't match type ‘(a, a1)’ with ‘a2 -> b’
08:27:15 <lambdabot>     Expected type: a -> a1 -> a2 -> b
08:27:15 <lambdabot>       Actual type: a -> a1 -> (a, a1)
08:27:59 <Kaidelong> @ty (Just .) . (,)
08:28:00 <lambdabot> a -> a1 -> Maybe (a, a1)
08:28:50 <Kaidelong> @ty ((Just .) . ) . (,,)
08:28:51 <lambdabot> a -> a1 -> a2 -> Maybe (a, a1, a2)
08:29:42 <Iceland_jack> :t let (.::) = (.).(.).(.) in Just .:: (,,)
08:29:43 <lambdabot> a -> a1 -> a2 -> Maybe (a, a1, a2)
08:30:04 <Iceland_jack> It's not really currying though
08:31:18 <Kaidelong> I would recommend against actually using ((Just.).).(,,)
08:31:28 <Kaidelong> although I don't know
08:31:39 <Kaidelong> I consider (f.).g idiomatic
08:31:49 <Kaidelong> so why not the 3 argument case too?
08:32:22 <Iceland_jack> Kaidelong: There isn't much benefit and the simple version is more readable
08:33:11 <Iceland_jack> If (.:) = (.).(.) were an operator in base I'd probably consider it more idiomatic but currently I write it pointfully
08:33:19 <Pythonfant> Is there a lib that does pretty printing of nested data structures?
08:33:19 <mathk1> Kaidelong, ((Just .) . ) . (,,) sound a good solution?
08:33:40 <Kaidelong> mathk1: I just said the opposite, go ahead and define curryJust3
08:33:53 <Iceland_jack> mathk1: I would not use ((Just .) .) . (,,)
08:33:55 <mathk1> ok :)
08:34:09 <TheKing444> Why not use lens some how.
08:34:09 <Kaidelong> I am a little ambivalent
08:34:18 <Kaidelong> it's not actually that hard of a thing to understand
08:34:27 <Kaidelong> but I think the definition or an explicit lambda works best here
08:34:48 <mathk1> I agree
08:35:28 <Iceland_jack> Kaidelong: Maybe not to you in isolation, but maybe in a more complicated example it may slow you down and will definitely slow others down with no real benefit
08:35:47 <RyanGlScott> I can't get a custom cabal flag to work correctly for some reason. https://github.com/ku-fpg/blank-canvas/blob/master/examples/blank-canvas-examples.cabal
08:36:11 <RyanGlScott> I've tried "cabal configure -f -examples" and then "cabal install", but that only installs one executable instead of all of them.
08:36:11 <Iceland_jack> There are a bunch of ((→) r) instances that people have no problem understanding in isolation and then get horribly confused when they see it in my code
08:36:11 <augur> so
08:36:35 <Kaidelong> Iceland_jack: mm, what do you mean?
08:36:50 <Iceland_jack> for example (<*>) or (>>=)
08:36:54 <TheKing444> @pl \f x y -> f . x $ y y
08:36:54 <lambdabot> flip flip (join id) . ((.) .) . (.)
08:36:57 <Kaidelong> it's just an extension of the (f.).g idiom to another argument
08:37:04 <augur> when i try to do   `createDirectoryIfMissing False "~/Library/Application Support/AppName` i get an error that says "createDirectory: does not exist (No such file or directory)"
08:37:37 <Kaidelong> I guess if you start trying to do something like what TheKing just did it becomes a bit stupid
08:37:38 <TheKing444> @pl \x y z -> Just (x, y, z)
08:37:38 <lambdabot> ((Just .) .) . (,,)
08:37:53 <TheKing444> Or even better
08:37:58 <TheKing444> @pl \x y z -> Nothing
08:37:58 <lambdabot> const (const (const Nothing))
08:38:18 <ClaudiusMaximus> augur: it doesn't recursively create directories, moreover ~ doesn't get expanded (that's shell functionality)
08:38:40 <augur> ClaudiusMaximus: ah, so its not going through the OS's path resolution stuff
08:38:46 <augur> ok, thats going to make things trickier
08:38:52 <augur> ClaudiusMaximus: do you know if there's a way to do this?
08:38:59 <glguy> augur: http://hackage.haskell.org/package/directory-1.2.1.0/docs/System-Directory.html
08:39:25 <RyanGlScott> augur: getHomeDirectory might be useful.
08:39:29 <augur> ahhhhh
08:39:38 <augur> i hadnt scrolled down to look for that :)
08:40:40 <tech2> getAppUserDataDirectory possibly more so
08:40:56 <augur> getAppUserDataDirectory is unfortunately not quite right for mac OS
08:41:05 <augur> it does $HOME/.appName
08:41:11 <RyanGlScott> That's where OS X puts stuff? Weird.
08:41:16 <augur> but it really should do  $HOME/Library/Application\ Support
08:41:26 <tech2> agreed :(
08:41:36 <tech2> Raise a bug perhaps?
08:41:43 <RyanGlScott> Even Windows is more sensible. And that's saying something.
08:41:49 <augur> its not really a bug, just a spiritual difference
08:42:02 <augur> RyanGlScott: what?
08:42:28 <augur> RyanGlScott: the Windows location and the OS X location are almost the same
08:43:14 <RyanGlScott> augur: Oh wait, you're right
08:43:27 <RyanGlScott> augur: I think it's %HOME%/AppData
08:43:39 <RyanGlScott> augur: Er no,  %HOME%/AppData/Roaming
08:43:47 <augur> no, as i said, its $HOME/Library/Application\ Support
08:43:52 <augur> in OS X
08:44:04 <RyanGlScott> augur: I mean on Windows
08:44:11 <shlevy> johnw: ping
08:44:21 <augur> RyanGlScott: on windows its apparently   C:/Documents And Settings/user/Application Data/appName
08:44:43 <RyanGlScott> augur: ...maybe I'm lost here. What exactly are we trying to retrieve?
08:45:57 <augur> RyanGlScott: the location for app user data
08:46:24 <RyanGlScott> augur: Oh, whoops. That's what I get for joining a conversation halfway through.
08:46:29 <augur> :)
08:46:46 <RyanGlScott> So what is the OS X equivalent of ~/.cabal?
08:47:13 <augur> probably ~/.cabal
08:47:30 <augur> since its haskell, it probably just uses nix-y conventions
08:47:46 <merijn> RyanGlScott: ~/Library/Haskell/
08:47:48 <RyanGlScott> Hey, that's not as scary as I thought. In that case, Windows definitely reigns as the weirdest directory namer.
08:48:04 <merijn> RyanGlScott: Or rather, it depends on how you install
08:48:26 <augur> probably it SHOULD be something like ~/Library/Application\ Support/Haskell or ~/Library/Application\ Support/Cabal
08:48:31 <merijn> RyanGlScott: Platform follows OSX convention (i.e. the directory I just mentioned), manual installs like homebrew follow the nix default
08:48:42 <augur> oh, you know
08:48:48 <augur> i have a ~/Library/Haskell dir
08:48:51 <augur> so maybe merijn is right
08:49:20 <RyanGlScott> augur: Do you use the Haskell Platform by any chance?
08:49:24 <augur> yes
08:49:31 <RyanGlScott> Makes sense to me.
08:49:42 <augur> i dont want to make an installer for my app
08:49:45 <augur> im terrified of that
08:49:57 <augur> so im doing this support dir stuff in app
08:50:20 <augur> plus, i want my app to be minimalist in every way, including installation
08:50:27 <augur> it should be drag and drop
08:52:15 <RyanGlScott> Now I'm curious. What is the accepted way of making installers for Haskell programs? Would you just make a script that calls "runhaskell Setup configure" et al.?
08:52:48 <augur> i dont think haskell is really that well thought out, tbh
08:52:51 <TheKing444> ah, I believe cabal has a way to make executable packages
08:53:12 <adimit> Correct me if I'm wrong, but I don't think there's a way to 'promote' an Int term to a TypeNat (i.e. dependent type) with the DataKinds extension… right?
08:53:15 <RyanGlScott> I think augur wants a cabal-less installation, perhaps?
08:53:33 <augur> RyanGlScott: ideally, i just want to have an executable and thats that
08:53:50 <TheKing444> Then just use ghc to compile it to an executable.
08:53:53 <augur> yes i know :)
08:53:54 <TheKing444> ghc yourprogram.hs
08:53:56 <Pythonfant> I'm having some trouble with parsing html using (xml|http|html)conduit. The document generated by parseLBS contains the element I'm searching for but if I show the cursor generated by fromDocument it's no longer in there. The element I'm searching for is at the top http://lpaste.net/108034
08:54:04 <augur> TheKing444: there is no mystery there
08:54:18 <Pythonfant> I don't really know how to debug this as the output from show is pretty much unreadable
08:54:26 <TheKing444> If you want to make an installer, spread your files everywhere.
08:57:56 <ClaudiusMaximus> adimit: you can make something like  withNat :: Int -> (forall n . Nat n => Proxy n -> r) -> r  using RankNTypes, not sure how it translates to DataKinds
08:58:10 <RyanGlScott> augur: I'm trying to find examples of Haskell software that use executables for installation, but unfortunately, I can't find any (xmonad, Yi, etc.)
08:58:33 <augur> RyanGlScott: like i said, i _dont_ want an installer
08:59:21 <adimit> augur: just bundle the thing up, and if you need C-libs, then they'll have to be packaged up in your bundle, as well as linked relative to where your executable lives. The Haskell-side is easy, as it's statically linked, although it does want libgmp (and there are some systems that'll give you trouble.) On Mac, the Bundle can be made executable (somehow,) on Windows, you need an installer that puts your
08:59:23 <adimit> executable into the start menu etc.
08:59:38 <RyanGlScott> augur: Okay. What is it about cabal's executable feature that isn't sufficient?
08:59:51 <augur> RyanGlScott: cabal is awful
09:00:03 <adimit> RyanGlScott: end users don't want to install GHC-land to get your app.
09:00:14 <adimit> that was already a problem with XMonad.
09:00:27 <RyanGlScott> augur: If you're just distributing an executable, your users wouldn't need GHC installed.
09:00:30 <augur> adimit: im going to be wrapping this in a Cocoa UI and calling out to the haskell app, so
09:00:45 <augur> RyanGlScott: *sigh* i said that already like 20 minutes ago
09:00:59 <augur> i dont know who's problem you're trying to solve but its not mine
09:00:59 <RyanGlScott> augur: Sorry, I didn't join #haskell until recently.
09:01:15 <adimit> ClaudiusMaximus: hm, yeah, thanks :-)
09:01:51 <augur> RyanGlScott: i said it _to you_
09:01:55 <adimit> (I wanted to also store the resulting nat, but yeah, I think I'm just going the easy route of run-time error checking, here.)
09:01:59 <augur> anyway
09:02:13 <augur> adimit: #idris
09:02:13 <augur> =x
09:02:47 <adimit> augur: sunken cost, mate, sunken cost. No way I'm porting.
09:02:56 <augur> awful!
09:03:04 <augur> adimit: chu makin
09:03:39 <adimit> augur: same thing we talked about recently ;-)
09:03:50 <augur> oh your HPSG thing
09:03:58 <augur> adimit: hey did i tell you, i switched over to CG
09:04:21 <adimit> no way. you didn't tell me. Traitor to HPSG-kind.
09:04:36 <adimit> also, you probably mean CCG, CG ain't no good.
09:04:37 <augur> adimit: im not an HPSGer so thats ok ;)
09:04:40 <augur> adimit: no i mean CG
09:04:45 <augur> im not a fan of CCG
09:04:53 <adimit> really? I find it much less powerful…
09:05:10 <augur> i mean CG in a broad sense
09:05:15 <augur> which includes CCG
09:05:24 <adimit> erhm. but yeah. I was actually just thinking theory, and I'm sure parsers are hard to come by anyhow.
09:05:32 <augur> CCG is just a particular, thoroughly un-type-theoretic approach to CG
09:05:55 <adimit> it's been my dream to make some type theoretically sound variant of it.
09:06:00 <augur> also i dont need a lot of power
09:06:05 <adimit> yeah, I forgot.
09:06:08 <augur> adimit: oh its sound, its just not TT-ly
09:06:28 <adimit> well, of course it's sound. It wouldn't be a calculus.
09:06:34 <augur> adimit: TT pushes this hard line on what constitutes valid rules, and CCG just throws it out the window
09:06:44 <augur> there are no intro or elim rules in CCG, just combinators
09:07:14 <augur> CCG is an axiomatic approach to CG, rather than a TT approach, and there's really no way to en-TT-ify it
09:07:47 <adimit> yeah, but I do find it interesting. I think the combinators add a very interesting power to it.
09:07:55 <augur> maybe
09:08:05 <augur> i mean, they're mostly just lemmas
09:08:10 <augur> except the cross rules, i think
09:08:30 <augur> you might be able to finagle something, but i think to properly do that you need modalities like in TLG
09:09:54 <shlevy> If I'm doing queue <- atomically newTQueue, is there any reason not to just do queue <- newTQueueIO?
09:10:11 <augur> adimit: anyway, im just using CG as a substitute for CFG rules. im using cooper storage and a trace-y thing for movement
09:10:30 <augur> adimit: well, i have a rule that is actually vaguely like `hyp`, really. that'd be more accurate.
09:10:33 <shlevy> The documentation for the latter suggests it's specifically for unsafePerformIO/top-level TQueues is my only concern
09:10:48 <TheKing444> shlevy probably just something to do with unSafeCoerce, but otherwise not
09:10:57 <augur> adimit: and then i have a rule thats like ->I but uses a special function type that designates a filler-gap function
09:11:07 <TheKing444> oh, and I think using unsafePerformIO at the top level for that is a terrible idea
09:11:13 <shlevy> I agree :D
09:11:15 <shlevy> I'm not doing that
09:11:34 <TheKing444> (I wonder why they even suggest that.)
09:12:06 <shlevy> Hmm it uses newTVarIO under the hood
09:13:21 <shlevy> Which based on http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Conc-Sync.html#newTVarIO does not seem any less safe than newTVar
09:14:00 <thoughtpolice> sometimes creating a top level reference (IORef, MVar or TMVar) is useful, and you do need unsafePerformIO for that. atomically does not work inside unsafePerformIO because the runtime detects this as an error, so it's just treated slightly differently to allow it as IO (it uses State# under the hood)
09:14:22 <thoughtpolice> hence the IO versions. if you just do 'atomically $ newTQueue ...' or whatnot, yes, the -IO variant should be fine.
09:14:37 <TheKing444> And they are convenient.
09:14:54 <shlevy> thoughtpolice: cool, thanks
09:15:37 <shlevy> Hmmm MonadBaseControl IO seems like a heavy price to pay for lifted-base
09:16:16 <shlevy> I just want to e.g. forkIO, I don't need the state capture stuff
09:25:53 <adimit> augur: sounds interesting. Why'd you switch away?
09:26:02 <augur> adimit: simplicity
09:26:14 <adimit> yeah, HPSG tends to be bloaty.
09:26:32 <augur> adimit: its a lot easier and bug free to write some CG types + semantics than to fiddle with FSes
09:26:38 <augur> especially since the FSes arent typed
09:26:48 <adimit> augur: they *are* typed.
09:26:55 <augur> adimit: not in haskell they're not :)
09:27:02 * hackagebot snap 0.13.2.8 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.8 (DougBeardsley)
09:27:17 <adimit> well, that they are not, but you can do run-time type inference.
09:27:21 <augur> adimit: i mean, as a programmer, they're not typed. i dont get type errors on a sort-key mismath, etc
09:27:27 <augur> which is where ALL of my bugs were coming from
09:27:49 <adimit> interesting. I'm not getting any bugs in that department; then again, I've got a pretty extensive test coverage.
09:28:25 <adimit> and composition of FS and Formulae is tightly regulated via applicatives that check the structures and bail if something's wrong.
09:28:37 <adimit> which means I've been moving at a snail's pace. :-|
09:31:21 <adimit> (still not clear on how to do the parsing stuff. i.e. go from a sentence and principles to an actual FS. There are several options on the table…)
09:32:40 <augur> adimit: well, you could just build a tree with the ID schemas
09:32:57 <augur> and check the principles each time you use a schema
09:36:10 <adimit> any way I do this, I'm bound to run into a combinatorial problem, I think.
09:36:12 <adimit> (as the grammar grows.)
09:36:24 <augur> adimit: eh. yes.
09:36:29 <augur> but you only have like 6 ID schemas
09:36:34 <augur> so its bounded
09:36:49 <adimit> depends on the grammar. There are some constructionist ones with up to 23
09:37:08 <augur> and checking principles at every step of the way bounds it further because you block further parses as soon as theres a problem
09:37:28 <josephle> so, does anyone know if OS X Yosemite breaks ghc? I've learned my lesson with Mavericks.
09:37:57 <adimit> augur: I'll have to try it out.
09:40:09 <shlevy> What does this error mean? Non type-variable argument in the constraint: MonadBaseControl IO m
09:41:02 <glguy> It means that if you want to put a non-variable (IO) into your constraint, you need an extension
09:41:28 <glguy> Either FlexibleInstances when you're defining an instance or FlexibleContexts when you're writing a context
09:41:52 <glguy> Without that extension constraints can only be on type variables
09:42:00 <shlevy> Ah
09:42:10 <shlevy> OK thanks
09:57:07 * hackagebot equivalence 0.2.5 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.5 (PatrickBahr)
10:00:32 <ocharles> Hmm, anyone know if Sebastiaan Visser or James Harrison Fisher idle here?
10:00:38 <ocharles> or perhaps... does anyone here use Clay?
10:00:52 <ocharles> I'm wondering if Clay can generate CSS that fits in a HTML style attribute
10:01:02 <TheKing444> orcharles I did in kindergarden.
10:01:06 <btcNeverSleeps> I've written a little piece of code which finds the type of a poker hand (flush, straight, set, etc.). And I've got a few questions about it.  Here's the (incomplete) code (16 lines):    lpaste.net/108038
10:02:37 <btcNeverSleeps> when I pass a list (say [Int]) and I want to pattern match on the first two elements of the list, am I supposed to do it like I did?
10:03:07 <btcNeverSleeps> erf: last line should be "NO_PAIR", not "ONE_PAIR", but whatever
10:03:09 <Twey> btcNeverSleeps: Yes
10:03:10 <glguy> btcNeverSleeps: You can write    noStraightNoFlush [4,1] = FOUR_...
10:03:43 <Twey> Yes, if you know in advance how many elements you want your list to have, you can use the normal list syntax.  But if you want arbitrary-length lists starting with a given prefix, that's the way to do it.
10:04:05 <glguy> The way he did it specifies the final []
10:04:20 <glguy> If you want just to first two elements of a two or more element list you'd do:   x:y:_
10:04:36 <glguy> for matching a two element list you'd write  [x,y]
10:04:46 <Twey> btcNeverSleeps: (\x -> f x) is equivalent to f; we don't usually use ALL_CAPS for constructors (or anything).  Everything's a constant in Haskell.  ☺
10:04:55 <Twey> Indeed
10:04:55 <btcNeverSleeps> where would I write this?
10:05:09 <Twey> btcNeverSleeps: noStraightNoFlush [4, 1] = …
10:05:17 <Twey> btcNeverSleeps: noStraightNoFlush [4, 1] = FourOfAKind
10:05:45 <btcNeverSleeps> Twey: oh I see, excellent, will remove ALL_CAPS : )
10:05:49 <Twey> And likewise with noStraightNoFlush [2, 1, 1, 1] = OnePair and so forth
10:06:15 <btcNeverSleeps> but if I try that (say [4:1]) I get Couldn't match expected type `Int' with actual type `[t0]'
10:06:29 <Twey> btcNeverSleeps: Read again ☺  It's [4, 1], not [4:1]
10:06:45 <pjdelport> :t (:)
10:06:46 <lambdabot> a -> [a] -> [a]
10:07:07 <Twey> btcNeverSleeps: [4:1] is the single-element list whose element is the value 4:1.  But (:) requires a list as its second parameter, so you get a type error about that.
10:07:13 <glguy> btcNeverSleeps: http://lpaste.net/108038
10:07:25 <ocharles> TheKing444: :)
10:07:39 <btcNeverSleeps> glguy: thanks, shinier!
10:08:09 <btcNeverSleeps> ok that is sweet... (less $, more (), a bit Lisp'ier... But I come from Clojure so ; )
10:08:23 <Twey> btcNeverSleeps: Preferences differ on that.
10:08:30 <glguy> There's no achievement for using all the operators
10:08:55 * Twey would write sort . map snd $ freq ranks
10:09:00 <glguy> ouch
10:09:12 <glguy> if you're going for full operator, at least be consistent:   sort . map snd . freq $ ranks
10:09:23 <btcNeverSleeps> another question: my value function is using pattern guards (?) and then in the 'otherwise' case, does call another function (noStraightNoFlush)... Is there a way to mix both in a single function?
10:09:44 <glguy> if that thing was important enough to "pipeline", name it.    orderedFreqs = sort . map snd . freq
10:09:50 <glguy> and then use orderedFreqs ranks   where you needed it
10:10:07 <Twey> glguy: That's silly for the same reason as sort (map snd (freq (ranks)))
10:10:15 <Twey> But naming things is good, sure
10:11:15 <Twey> btcNeverSleeps: Those are just normal guards, not pattern guards (pattern guards look like this: f x | y ← g x = …)
10:11:22 <glguy> The argument for soup style is that you can use your mouse and copy paste whole nameable functions out of the pipeline
10:11:36 <glguy> so leaving freq on the right side of the $ is just as bad as all $s
10:11:37 <btcNeverSleeps> Twey: oh... (more stuff to read on)
10:12:15 <Twey> btcNeverSleeps: Don't worry about it until you need them
10:12:42 <Twey> glguy: I don't like the fixity of ($), is all, and live in hope that it will be changed :þ
10:14:50 <pjdelport> @remember glguy There's no achievement for using all the operators
10:14:50 <lambdabot> It is stored.
10:15:01 <n-dolio> Dots also look nicer than dollars.
10:15:41 <periodic> Pfft, that's like saying you prefer coins over bills.
10:15:48 <periodic> Everyone knows the $ is worth more than .
10:16:02 <Twey> btcNeverSleeps: There are a few ways.  You can use a case, like this: http://lpaste.net/108040
10:16:09 <periodic> And then if you can combine it with a few obscure operators for variation bonus.
10:17:12 <Twey> btcNeverSleeps: Uh, I mean this: http://lpaste.net/108040
10:17:30 <Twey> btcNeverSleeps: Personally I would prefer an auxiliary function, though.
10:19:29 <btcNeverSleeps> Twey: ah that is very interesting...
10:20:17 <moka_> hi, what's the correct way to deal with cabal reinstalls when installing a new package that could break others ? force ?
10:20:19 <btcNeverSleeps> Twey: you mean in this case the auxiliary function called "noStraightNoFlush" is easier to read than "nesting" a 'case' in the 'otherwise' block?  It's not necessarily that I want to do it: it's just to understand what can and what cannot be done
10:20:23 <Twey> btcNeverSleeps: You can also use real pattern guards, like this: http://lpaste.net/108038
10:20:37 <Twey> btcNeverSleeps: Yes, absolutely.  That's why I told you about it anyway :þ
10:21:06 <Twey> Uhh, wait, that last one is horribly wrong
10:22:04 <Twey> Oh wait, no it isn't.  Carry on.
10:22:08 <btcNeverSleeps> (the "take 2" isn't even needed)
10:22:09 * hackagebot base-prelude 0.1.2 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.2 (NikitaVolkov)
10:22:40 <glguy> It's too bad that package's module isn't named "AllTheThings"
10:22:42 <Twey> btcNeverSleeps: You could match against (4:1:_) and leave out the take 2.  But I think [4, 2] and the take 2 is nicer.
10:22:58 <Twey> glguy: Heheh.
10:23:13 <glguy> Just seems like "import AllTheThings" would be fun to see, maybe accompanied by an image macro
10:23:22 <Twey> Indeed
10:23:33 <Twey> SPJ would probably object, though
10:24:30 <joelteon> that sounds like a job for literal haskell
10:24:35 <joelteon> literate
10:24:46 <btcNeverSleeps> Twey: I like the version with pattern guards, will definitely have to read up on that
10:25:04 <Twey> btcNeverSleeps: It just lets you pattern-match on something that is not an argument to the function (in this case, nb).
10:25:28 <Twey> Yes, I like that version, too.
10:25:33 <btcNeverSleeps> to me it looks like pattern matching (as done in Haskell) allow for code way shorter (and more to the point) than in many other languages... I like Haskell so far.
10:25:53 <Twey> btcNeverSleeps: Pattern matching is certainly a thing I miss in other languages.
10:26:16 <btcNeverSleeps> Twey: Clojure as arguments destructuring but it feels simpler than what Haskell allows
10:26:23 <btcNeverSleeps> s/as/has/
10:27:55 <btcNeverSleeps> one last question (girlfriend is getting impatient for we have to leave for dinner ;)   :  when you want to use pattern guard to patter match, how do you typically "create" the thing you want to match on?   In a "where" clause?  Is that idiomatic Haskell?
10:29:52 <Twey> btcNeverSleeps: If it's short and cheap to compute (or not repeated), you can just put it right in the clause.  But if one of those things fails then you'll get a bit of computational or syntactic overhead from that, so it's wise to put it in a ‘where’ clause or similar.
10:30:00 <brycelane> I have a likely very simple question: in the Machines library, how does one concat two machines, or is that even possible?
10:30:17 <glguy> with ~> or <~
10:30:36 <glguy> depending on what "concatenate" means
10:30:45 <joelteon> brycelane, do you mean feed the output of one into the input of another?
10:30:51 <glguy> if you mean "one after the other" you can't
10:31:08 <brycelane> no, I mean I have two machines that produce a's, I want to fuze them.
10:31:26 <btcNeverSleeps> Twey, glguy: thanks a lot to everyone, ttyl
10:31:37 <Twey> btcNeverSleeps: Have a good dinner!
10:32:29 <glguy> brycelane: I put in a pull request for that behavior https://github.com/ekmett/machines/pull/24
10:32:36 <glguy> brycelane: but it's on hold
10:32:43 <shlevy> Does "WrenThornton" hang out here with some non-obvious nick?
10:34:03 <acowley> Is there a faster mirror to download GHC bindists from?
10:34:23 <joelteon> brycelane: what do you mean by fuse?
10:34:51 <glguy> a <> b would run a until it 'stopped' and then proceed running 'b'
10:34:54 <brycelane> I was thinking Monoid (I think its monoid, append elements to a collection behavior)
10:35:35 <joelteon> couldn't you use fanout for this?
10:35:45 <joelteon> glguy: isn't that Alternative?
10:35:47 <brycelane> glguy: why is it on hold?
10:36:56 <glguy> joelteon: No, alternative would imply Applicative, and machines aren't that, either
10:37:13 <acowley> I use a Monoid instance in my machines code
10:37:25 <glguy> me too
10:37:50 <brycelane> are other projects using Machines?
10:38:03 <joelteon> glguy: Plans are Alternative
10:38:05 <brycelane> I'm just learning haskell, but am interested as I use the scalaz-stream library
10:38:14 <Refried__> can haskell do anything clever with identical data structures (e.g. reuse them, even if they are created independently)?
10:38:26 <Refried__> like the way some languages do with strings
10:38:33 <glguy> joelteon: Yeah, but this is at the machine level
10:41:26 <acowley> Refried__: I don't think you can get a simple answer to that
10:42:09 <acowley> brycelane: I use it in a couple of my projects, but they're not really public things yet
10:44:05 <Javran1> @pl \i acc -> f i:acc
10:44:05 <lambdabot> (:) . f
10:44:42 <brycelane> acowley: how would you compare it with conduit? I believe that is the more popular construct at the moment.
10:46:45 <acowley> brycelane: I wouldn't as I've not used conduit for anything serious. I use machines because I think its design is interesting, while I'm wary of conduit because it strikes me as a bit over-engineered. That is at least somewhat an aesthetic critique, though.
10:49:51 <bgamari> tibell, tibbe?
10:49:59 <joelteon> conduit has done a lot regarding what to do with leftovers
10:50:07 <joelteon> it's a much more mature project than machines is at the moment
10:50:13 <carter> acowley: my s3 bucket for a mac build
10:50:13 <bgamari> acowley, no pipes for you?
10:50:18 <monochrom> type Tibbe = Tibell :)
10:50:25 <carter> acowley: i'mhappy to PM you a link
10:50:31 <bgamari> monochrom, thanks!
10:50:47 <carter> OS X  64bit and linux recent ubuntu 64bit only
10:50:58 <acowley> joelteon: Yes, that's certainly true
10:51:11 <acowley> carter: How does it differ from the official one on haskell.org?
10:51:21 <bgamari> tibell, It would be nice if changing the delimiter in cassava weren't so painful
10:51:24 <carter> acowley: i built this one, mark built the other
10:51:40 <bgamari> tibell, defaultEncodeOptions { encDelimiter = fromIntegral $ ord '\t' } is quite a mouthful
10:51:43 <monochrom> oh, tibbe is his irc nick name
10:51:47 <acowley> bgamari: No, but I'm sure it's great, too
10:51:48 <bgamari> Plus import Data.Char (ord)
10:52:19 <monochrom> interesting, he has changed irc nick to tibell as well?
10:52:45 <acowley> carter: So there's essence of carter sprinkled in yours? The nice thing about using the one from haskell.org is that when you hit a problem you can point there
10:52:49 <bgamari> acowley, I've been meaning to play around with machines for a while now
10:53:04 <carter> acowley: and who do you chat with more, mark or me?
10:53:08 <carter> wrt support story
10:53:11 <acowley> haha
10:53:14 <carter> :p
10:53:17 <acowley> I didn't mean that to sound so negative
10:53:27 <carter> if theres a  difference its a compiler bug
10:53:40 <acowley> I'm trying to track down a compiler bug atm
10:53:43 <carter> which one
10:53:46 <ReinH> carter, acowley: o/
10:53:50 <carter> ReinH: o/
10:54:08 <acowley> I guess I haven't named it yet. Is this like hurricanes or something? Bug Beatrice!
10:54:15 <ReinH> carter: such lambda, very jam. wow.
10:54:22 <carter> whats the phenomenology
10:54:35 <acowley> carter: But I'm using 7.8.2, so maybe it's already fixed in 7.8.3. If not, I'd like to say that it's not without complicating the story
10:54:45 <carter> SO many bugs were fixed for 7.8.3
10:54:46 <carter> sooo many
10:54:51 <carter> acowley: are you using stable names or sharing?
10:54:57 <acowley> "carter: Cannot continue after interface file error"
10:55:02 <carter> wat
10:55:02 <acowley> carter: no
10:55:06 <acowley> sorry
10:55:08 <carter> acowley: did you try cabal clean?
10:55:12 <acowley> your name shouldn't have been in the quot
10:55:17 <acowley> Yes
10:55:26 <acowley> It's really crazy
10:55:30 <carter> are you doing paralle ghc or just paralle cabal
10:55:35 <acowley> I have a package with a lib and an exe
10:55:37 <carter> drop the ghc-options=-j
10:55:39 <acowley> the exe depends on the lib
10:55:41 <carter> ok
10:55:45 <carter> whats your cabal file look like
10:55:48 <acowley> I start getting this error today
10:55:49 <acowley> hold on
10:55:54 <carter> and what cabal-install version
10:55:56 <carter> cabal --version
10:56:14 <acowley> So if rather than depend on the lib, I include the source dir, things work as long as one particular file in the lib gets recompiled
10:56:24 <acowley> If that file isn't changed, I get the interface file error
10:56:28 <acowley> If I touch it, it's fine.
10:56:30 <carter> acowley: whats the cabal file look like
10:56:36 <carter> and what cbal vesrion
10:56:50 <acowley> The cabal file is the lib and a test-suite
10:57:00 <carter> yes
10:57:03 <carter> i mean lpaste it
10:57:04 <carter> :)
10:57:06 <Pythonfant> sry for asking again, but I'm a bit lost: I'm having some trouble with xml-conduit not matching some elements in a document generated with html-conduit. If I print out the Document and do a grep all elements seem to be in it but is soon as I get a cursor using fromDocument and then try to match them a lot of elements seem to be missing. Also when I print the Cursor and do a grep there those elements are also
10:57:07 <acowley> cabal-install version 1.20.0.3, Cabal 1.20.0.1
10:57:08 <Pythonfant> not in there. Any idea what could be causing this? http://lpaste.net/108045
10:57:09 <carter> is it a custom setup.hs
10:57:13 <acowley> No
10:57:21 <carter> acowley: theres been some bug fixes in cabal
10:57:27 <enthropy> acowley: make the test-suite have a different flag so it always recompiles stuff
10:57:27 <carter> or was it cabal-install
10:57:33 <carter> oh yeah
10:57:34 <carter> i do that too
10:57:47 <enthropy> or I gues there's -fforce-recomp
10:58:38 <shlevy> Can a transaction that only writes tvars ever fail?
10:58:48 <acowley> enthropy: After putting it back so the test-suite depends on the lib?
10:59:04 <acowley> I don't want to recompile the lib so often as it takes a while
10:59:11 <enthropy> acowley: making the test-suite recompile the lib
10:59:26 <acowley> enthropy: That amounts to my current workaround, but it's a pain
10:59:41 <acowley> enthropy: The pain being the time, not the mechanism
11:01:12 <acowley> Anyway, the problem is an interaction of an associated type family, data kinds, and poly kinds
11:01:38 <acowley> As I know the code I added that started triggering the issue, but I haven't been able to build a small test case yet
11:01:52 <acowley> There may also be GNTD involved
11:01:57 <acowley> err, GND
11:02:18 <acowley> Well, ultimately, pretty much every extension is involved
11:02:52 <carter> acowley: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.8.3
11:03:22 <acowley> Yeah, I read those earlier looking for my issue
11:03:42 <carter> acowley: well, try 7.8.3 somewhere to check
11:03:47 <acowley> I didn't find it, but I figured I should try with 7.8.3 since some changes seem to have slipped into it without leaving a big paper trail
11:03:55 <acowley> I am
11:04:02 <acowley> but installing all my deps will take an hour or so
11:04:09 <carter> even with parallel builds?
11:04:11 <carter> ouch
11:04:11 <acowley> So I need to get it ready then get lunch
11:04:16 <enthropy> acowley: do you have orphan instances? Maybe it'll change if you arrange things to have or not have them?
11:04:17 <carter> ahhh
11:04:21 <acowley> No orphans
11:06:02 <shlevy> Is there a common function (a -> mb) -> [a] -> m [b]?
11:06:33 <shlevy> ah mapM
11:06:45 <shlevy> Ah
11:06:50 <shlevy> I didn't have a space between m and b
11:06:53 <shlevy> that's why hoogle didn't find it
11:06:57 <glguy> mapM only works on lists and only works with Monad, if you want the more general one it's Data.Traversable
11:07:32 <shlevy> glguy: ah, thanks
11:07:47 <shlevy> glguy: Is there a Traversable version of replicateM?
11:08:24 <ion> I don’t think Traversable has the capability for generating data structures out of thin air.
11:08:31 <shlevy> OK
11:08:38 <shlevy> I'll stick with lists then :)
11:08:39 <shlevy> Thanks
11:08:42 <joelteon> does haskell operate in thin air?
11:08:47 <joelteon> that's pretty cool
11:08:56 <dcoutts> @faq does haskell operate in thin air?
11:08:56 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
11:09:03 <dcoutts> oh damn, wrong command
11:09:54 <ion> Traversable can apply an Applicative action to all values in a preëxisting data structure and result in an identically shaped data structure.
11:10:30 <ReinH> ion: parametricity to the rescue!
11:10:36 <ReinH> :t traverse
11:10:37 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:11:07 <shlevy> If I'm doing mapM Control.Concurrent.Async.wait, amd I better off doing atomically . mapM Control.Concurrent.Async.waitSTM?
11:11:29 <shlevy> Hmm given the impl of wait I'm guessing yes
11:11:40 <ReinH> It can't construct an f or a t
11:11:50 <acowley> ReinH: How were the talks at LambdaJam?
11:11:56 <Ankhers> Would anyone be able to suggest a good, fast binary tree implementation?
11:12:08 <acowley> I don't really know anything about the conference other than a bunch of Haskellers were there
11:12:37 <ReinH> I only went to a few but they were generally good
11:12:48 <Athas> Ankhers: Data.Map? :-)
11:13:00 <ReinH> Conal gave a nice workshop on denotational design.
11:13:45 <ReinH> generally they seemed to center Haskell a bit, which was cool.
11:14:16 <carter> who organizes lambdajam?
11:14:29 <acowley> I should go to a Conal talk sometime
11:14:37 <Ankhers> Athas: I was kinda thinking about that. Thanks.
11:14:59 <ReinH> acowley: he's next up on the cast :)
11:15:12 <ReinH> am really excited about that one
11:15:19 <Twey> ReinH: Conal's coming to the HaskellCast?
11:15:26 <Twey> Any word on topic?
11:15:41 <acowley> ReinH: That's great!
11:15:52 * Twey is also excited
11:15:52 <ReinH> denotational design, frp, etc :)
11:16:04 <Twey> Awesome
11:16:08 <acowley> Push him on the problems with FRP implementations!
11:16:08 <ReinH> we wanted to record at LambdaJam but too busy
11:16:15 <ReinH> had some great chats though
11:16:42 <ReinH> acowley: I will!
11:16:47 <acowley> It's very frustrating reading so many FRP papers only to read anecdotal after-reports about, "Oh yeah, space leaks..." or what have you.
11:16:59 <acowley> Not that that necessarily applies to his work specifically, but the field in general
11:16:59 <Twey> acowley: I think Sodium is currently safe?
11:17:01 <ReinH> we can talk about Haskell's denotational problems too
11:17:14 <acowley> Sodium is much less ambitious as I understand it
11:17:22 <Pythonfant> ReinH: btw I just started listening to haskellcast a few days ago, thx for doing this, I'm really enjoying it (also to your cohost, I don't know his nick)
11:17:29 <Twey> And I think Banana's leaks are fixable, not fundamental
11:17:36 <Twey> Hm
11:17:39 <ReinH> acowley: he focuses on the denotational problems with frp, not the operational ones ;)
11:18:15 <mmachenry> Does anyone know where the (#) :: a -> (a -> b) -> b operator is defined? I have heard about it somewhere but it's really hard to Google and even Hoogle.
11:18:21 <acowley> ReinH: That's (by definition) only a partially satisfying answer :P
11:18:28 <acowley> mmachenry: lens has one
11:18:37 <ReinH> acowley: :p
11:18:54 <supki> mmachenry: diagrams
11:19:01 <Pythonfant> mmachenry: hayoo gave me this http://hackage.haskell.org/package/threepenny-gui-0.4.2.0/docs/Graphics-UI-Threepenny-Core.html#v:-35-
11:19:03 <ReinH> he has a restrictive definition if frp based on denotation, but this does lead to operational issues
11:19:07 <acowley> Oh wait, I'm wrong
11:19:15 <acowley> I read the type, not the name
11:19:27 <Pythonfant> mmachenry: diagrams uses this aswell
11:19:36 <ReinH> mmachenry: it's flip ($) in diagrams
11:19:41 <ReinH> lens calls it (&)
11:20:05 <mmachenry> ReinH: Yeah that's the one
11:20:06 <ReinH> it's the type of an unsaturated continuation ;)
11:20:15 <Twey> mmachenry: There's one in Threepenny, as well
11:20:31 <ReinH> well unsaturated CPS transform
11:20:48 <mmachenry> Makes sense, that's the guy who was giving the talk
11:21:14 <ReinH> acowley: mostly he defines frp as operating on continuous time.
11:21:30 <acowley> ReinH: But it's quite distressing to work so hard to simplify definitional properties only to create operational problems. I understand they are (or ought to be) orthogonal, but at some point I put on my engineer's hat and ask where the beef is.
11:21:54 <ReinH> no no, the better denotation comes with better operational semantics!
11:21:55 <acowley> ReinH: Yes, and it's interesting how many reactive approaches don't follow that avenue
11:22:16 <ReinH> continuous is simpler than discrete!
11:23:23 <carter> but most folks aren't doing physics simulations
11:23:27 <carter> they're doing games or guis
11:23:36 <ReinH> That's true
11:23:41 <ReinH> and yet
11:23:43 <acowley> Another vague thing I find interesting is that when you come across example FRP things, they look great at small scale, but once you start getting into more realistically sized applications it doesn't look very pretty
11:23:58 <ReinH> there's a difference between abstraction and representation.
11:24:05 <acowley> Indeed
11:24:06 <carter> i've had a few chats with gershom and ryan trinkle on that topic
11:24:15 <ReinH> c.f. Hughes ;)
11:24:22 <carter> so theres roughly two classes of semantics
11:24:29 <carter> "continuous domain modelling"
11:24:32 <ReinH> yeah I had some nice chats with sclv at LambdaJam
11:24:32 <Athas> acowley: I find that is often a problem with very opinionated design philosophies.
11:24:39 <ReinH> wicked smaht
11:24:55 <carter> and "composable low latency rewireable graphs of event streams"
11:25:20 <carter> i'm interested in FRP style things as a *sibling* to modeling DSLs
11:25:22 <carter> ok, lunch
11:25:45 <acowley> Athas: In my own work I find that it's a sign that there's the kernel of a good idea there, but I haven't really figured it out yet.
11:26:25 <acowley> But, and I think ReinH's comment hints at this, there's rather a lot of incidental complexity due to serializing things as textual code
11:27:14 <ReinH> transformations between discrete representations are ugly. very few isomorphisms, etc
11:27:18 * hackagebot heist 0.13.1.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1.2 (DougBeardsley)
11:28:09 <ReinH> computing in a continuous space and performing discretization lazily has benefits.
11:29:42 <rrradical> For a record "data Foo = Foo { a :: Int }", why isn't there a setter function automatically declared "setA :: Foo -> Int -> Foo"? It seems like an obvious tool that would enable many abstractions over records.
11:30:25 <rrradical> and a follow up-- to get that functionality, do I need to use template haskell or lenses? or is there an extension that provides it?
11:31:12 <acowley> rrradical: The answer to your second question is that you should use lens
11:31:15 <Twey> rrradical: Lens provides it
11:31:38 <Twey> rrradical: Yes, there are various inconveniences surrounding records.  Lens fixes some of them; Vinyl fixes some more
11:31:56 <acowley> But setters are a bit more complicated than most folks think at first
11:32:07 <acowley> e.g. changing the type of the record
11:33:20 <rrradical> acowley: I don't understand. What do you mean changing the type of the record?
11:33:40 <rrradical> Twey: I've never seen Vinyl. I'll check it out, thanks.
11:33:54 <mmachenry> ReinH: I can't see the code for Diagrams on Hackage and thus not the operator. This is the only package I've had this issue on.
11:33:54 <Twey> rrradical: data Foo a = Foo { bar :: a }
11:34:01 <acowley> rrradical: Suppose your Foo was Foo t = Foo { a :: t }
11:34:06 <mmachenry> Is it just FFI or something?
11:34:16 <acowley> rrradical: Now your setter is Foo t -> s -> Foo s
11:34:19 <ReinH> It's literally flip ($)
11:34:24 <acowley> rrradical: Now add other type parameters to the mix
11:34:25 <mmachenry> Oh yes I know.
11:34:29 <mmmm_> If you have a polymorphic AST, what tricks can you use to write polymorphic construct functions?
11:34:41 <mmachenry> I was hoping it was in some more importable place though.
11:34:55 <rrradical> acowley: Oh... I see. That is tough
11:35:20 <acowley> rrradical: Which is all the more reason to be impressed with how gracefully lens handles it!
11:35:27 <ReinH> mmachenry: you can define it in 9 characters :p
11:36:48 <acowley> > 9 < length "Fairbairn"
11:36:49 <lambdabot>  False
11:37:29 <rrradical> acowley: that's fair. I guess I should learn more about them.
11:37:53 <acowley> rrradical: Your criticism is totally valid, and shared by everyone
11:38:48 <Twey> rrradical: The reason it hasn't been fixed already is not that everybody thinks it's perfect, but that nobody can agree on the fine details of the alternatives :þ
11:39:12 <Twey> But I think Lens and Vinyl are becoming de facto standards, so maybe we'll see some language support for that sort of thing some day
11:39:52 <ski> mmmm_ : itym parametric AST
11:40:56 <rrradical> Twey: I see. is there a name for this sort of problem? I tried googling "haskell record set method" but didn't find much. I'd be interested to read more of the discussion
11:41:15 <mmmm_> ski: yes sorry
11:41:53 <ski> (polymorphic types are something different)
11:42:38 <k00mi> OverloadedRecordFields will bring some support for lenses
11:43:04 <Twey> rrradical: This isn't the only problem with records.  We also suffer from partial getters with sums of records, for example, which I think we'd really rather exclude
11:43:44 <Twey> rrradical: E.G. data Foo = Foo { bar :: Int } | Baz -- bar is now a partial function Foo -> Int
11:43:45 <Iceland_jack> Twey: That would break a lot of things though, a warning would be nicer (initially at least)
11:43:50 <Twey> Yeah
11:44:19 <Ankhers> I'm fairly certain I understand why I am getting this type error. I just don't know how to fix it. http://lpaste.net/108052 Any help would be appreciated.
11:44:42 <acowley> Record syntax for sum types is such a shame
11:45:26 <Iceland_jack> Ankhers: What do you want to do with the foldr?
11:45:39 <mmachenry> ReinH: Yes yes I know but I want to find it. Someone asked me where I'd seen it
11:45:46 <rrradical> oh, interesting. Yea I've never used a record in a sum type. I wonder how often that comes up
11:45:52 <Iceland_jack> Because 'foldr (\s -> (s, s))' isn't going to work
11:45:58 <Iceland_jack> @ty foldr (\s -> (s, s))
11:45:59 <lambdabot>     Couldn't match expected type ‘b -> b’ with actual type ‘(t, t)’
11:45:59 <lambdabot>     Relevant bindings include s :: t (bound at <interactive>:1:9)
11:45:59 <lambdabot>     In the expression: (s, s)
11:46:05 <ReinH> mmachenry: oh ok sorry
11:46:20 <Ankhers> Iceland_jack: I am trying to make a Map out of the file.
11:46:30 <Twey> Ankhers: The statements in a do-block must be an expression in the monad.  Your foldr isn't a monadic value (and you probably want to remember to give it the ‘zero’/‘initial’ argument).
11:46:38 <Iceland_jack> Ankhers: okay what are the keys?
11:46:47 <Iceland_jack> Do you want each line to be its own key?
11:46:48 <Ankhers> Iceland_jack: URLs
11:46:51 <Ankhers> yes.
11:46:55 <Iceland_jack> okay, then you can use map
11:47:08 <Iceland_jack> > map (\s -> (s, s)) ["hello", "world"]
11:47:09 <lambdabot>  [("hello","hello"),("world","world")]
11:47:25 <Iceland_jack> and then
11:47:25 <Iceland_jack> > M.fromList $ map (\s -> (s, s)) ["hello", "world"]
11:47:26 <lambdabot>  fromList [("hello","hello"),("world","world")]
11:47:36 <ski> > [(s,s) | s <- ["hello", "world"]]
11:47:38 <lambdabot>  [("hello","hello"),("world","world")]
11:47:43 <Iceland_jack> > fromList [ (s, s) | s <- ["hello", "world"] ]
11:47:44 <lambdabot>  Not in scope: ‘fromList’
11:47:45 <lambdabot>  Perhaps you meant one of these:
11:47:45 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
11:47:45 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
11:47:45 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
11:47:49 <Twey> Ankhers: If you just want to give it a name to use later, you can say ‘let foo = Map.fromList . map (\s -> (s, s)) $ lines file
11:47:52 <Iceland_jack> > S.fromList [ (s, s) | s <- ["hello", "world"] ]
11:47:53 <lambdabot>  fromList [("hello","hello"),("world","world")]
11:47:59 <ski> @botslack
11:47:59 <lambdabot> :)
11:48:10 <Iceland_jack> ah ski wrote it first :)
11:48:18 <Twey> ’
11:49:46 <merijn> Anyone have (or able to get) a copy of "Haskell Is Not Not ML" for me?
11:49:49 <Ankhers> Iceland_jack, Twey: http://lpaste.net/108053
11:50:04 <Iceland_jack> Ankhers: Now you need to use Twey's earlier suggestion :)
11:50:44 <Iceland_jack> since 'Map.fromList . map (\s -> (s, s)) $ lines file' has a pure type (Map String String) you can't use it directly in a do-block
11:50:45 <rola> http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/not-not-ml.pdf ?
11:51:05 <merijn> rola: Oh, hah, Google Scholar is failing me. Thanks!
11:51:25 <Iceland_jack> you'll need to write
11:51:25 <Iceland_jack>     reloadConfig = do
11:51:25 <Iceland_jack>       file <- readFile "..."
11:51:28 <Iceland_jack>       let configMap = Map.fromList . map (\s -> (s, s)) $ lines file
11:51:32 <Iceland_jack>       ...
11:51:55 <Iceland_jack> Ankhers: You can see it in the error message:
11:51:56 <Iceland_jack>     Expected type: IO String
11:51:56 <Iceland_jack>       Actual type: Map.Map String String
11:52:31 <Twey> Wonder why it wants an IO *String* specifically.
11:52:46 <Twey> Oh, I guess it just tried to match m with Map String
11:53:09 <Twey> That's a very slightly confusing error message
11:53:14 <Iceland_jack> Twey: that's right
11:53:23 <joelteon> I never have liked the wording of GHC's error messages
11:53:31 <Ankhers> Now, would it be possible to throw this map into a State?
11:53:32 <Iceland_jack> If the expression had been 'a' then it wouldn't have
11:53:49 <Iceland_jack> but ‘Just 'a'’ would unify with IO Char
11:54:07 <Twey> Ankhers: Is your do-block in a State monad?
11:54:37 <Twey> Iceland_jack: Right.  But it's confusing because it says it expects an IO String, when in fact it doesn't care about the String part.
11:54:53 <Iceland_jack> Yes it's silly behavior
11:55:03 <Ankhers> Twey: It currently has a type of IO (), so no.
11:55:26 <Twey> Ankhers: Okay.  You can't really just *put* something into State.  What you can do is *run some State actions* with that as your state.
11:55:37 <Twey> :t runState
11:55:37 <johnw> unless he's using ST
11:55:38 <lambdabot> State s a -> s -> (a, s)
11:55:47 <joelteon> well, you can use 'put'
11:56:11 <Twey> Ankhers: So you'd want to write: runState yourStateAction configMap
11:56:35 <Twey> Ankhers: Where yourStateAction is an action that expects this map to be in the state to start with
11:56:49 <Twey> Ankhers: Although, it seems quite likely that you don't need State at all.  What are you planning on using it for?
11:57:17 <Ankhers> Twey: I need to know whether a domain is in this whitelist elsewhere in the application.
11:57:36 <Twey> Ankhers: So what made you decide to use State?
11:58:09 <Ankhers> Well, I don't want to recreate the map upon every request.
11:58:15 <Twey> Ankhers: Is the list going to change?
11:58:21 <Ankhers> Yes.
11:58:32 <Twey> Ankhers: And it will only be used within the same thread?
11:58:59 <Ankhers> No. reloadConfg currently run asynchronously every couple minutes.
11:59:12 <Ankhers> This is an application built on Warp.
11:59:25 <Twey> Ankhers: If you're communicating the changes between threads, you're going to need to use a TVar or something.
11:59:38 <Twey> Otherwise you will only update the copy in your current thread.
11:59:46 <Ankhers> I did not know that.
12:00:08 <Twey> Ankhers: The State monad is just sugar for threading parameters through functions
12:00:35 <Twey> Ankhers: It *doesn't* give you imperative-style variables
12:01:43 <aupiff> is dumping the ghc core language no longer supported in ghc?
12:01:50 <aupiff> during compilation that is
12:02:38 <aupiff> this flag, for example: -fext-core, is there no currently working equivalent?
12:02:40 <Twey> Ankhers: Sorry, you probably want a Chan rather than a TVar.  You can duplicate those to pass one endpoint to each of your threads.
12:03:14 <shlevy> Why doesn't this unify?
12:03:21 <shlevy> Couldn't match type ‘b0 -> (b0 -> t1 -> m0 b0) -> m0 b0’ with ‘forall r. r -> (r -> a1 -> EitherT r m1 r) -> EitherT r m1 r’
12:03:58 <Ankhers> Twey: Thanks. I will look into that.
12:05:04 <Twey> shlevy: The forall, I assume.  You need something that will work for *all* types r, but you've given it something that only works for a particular b0 that is in scope.
12:05:58 <shlevy> Hmm... I think I'm confused abotu the meaning of forall at the top level
12:06:21 <Twey> shlevy: What extensions do you have on?
12:06:28 <shlevy> FlexibleContexts
12:06:37 <Twey> Hm.  Post code?
12:07:12 <shlevy> Already changed it :/
12:07:21 <shlevy> I was using a flip
12:07:23 <Twey> Ah
12:07:30 <shlevy> And am replacing with a lambda
12:08:54 <shlevy> Hmm interesting
12:09:07 <ski> @type let instantiate :: forall f a. (forall a. f a) -> f a; instantiate x = x in instantiate
12:09:08 <lambdabot> (forall a1. f a1) -> f a
12:09:22 <shlevy> I had to replace sourceQueue = source . go with sourceQueue q = source (go q)
12:09:42 <shlevy> where source is from simple-conduit (haddock is broken on hackage ATM)
12:10:04 <Twey> :t (.)
12:10:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:10:05 <shlevy> But it expects a function with the forall r stuff
12:10:12 <johnw> shlevy: hi
12:10:16 <shlevy> johnw: o/
12:10:20 <johnw> can you show me your code?
12:10:41 <johnw> yes
12:10:45 <johnw> composition will fail you sometimes
12:10:50 <johnw> adding explicit points is the right solution
12:10:54 <shlevy> OK
12:11:04 <johnw> it has happened to me on several occasions too
12:12:38 <ski> i wonder if there would be any problem with supporting deep polymorphic instantiation and generalization, at least inside `->'s
12:13:36 <mmmm_> ski: Functional dependencies were the answer
12:14:15 <ski> mmmm_ : i don't follow
12:14:42 <ski> @type let distribute :: forall f g a. (forall a. f a -> g a) -> (forall a. f a) -> g a; distribute f = f in distribute
12:14:43 <lambdabot>     Couldn't match type ‘f1 a1’ with ‘forall a2. f1 a2’
12:14:44 <lambdabot>     Expected type: (forall a. f1 a) -> g1 a1
12:14:44 <lambdabot>       Actual type: f1 a1 -> g1 a1
12:14:48 <ski> @type let distribute :: forall f g a. (forall a. f a -> g a) -> (forall a. f a) -> g a; distribute f x = f x in distribute
12:14:49 <lambdabot> (forall a1. f a1 -> g a1) -> (forall a1. f a1) -> g a
12:20:12 <n-dolio> ski: Yes, type classes are a problem.
12:22:22 <johnw> shlevy: wherever run into troubles with that hidden "forall", let me know.  That's still an open design question
12:22:35 <ski> hm, i imagine it can be, but i don't see the problem yet
12:22:41 <johnw> I once made it an explicit type parameter everywhere, but it seems to buy me nothing
12:22:48 <shlevy> johnw: Just a few points I had to add in
12:22:59 <shlevy> johnw: I'll show you what I'm working on shortly
12:23:04 <johnw> k
12:24:03 <stelleg> is there a way to run ghc with a command line argument as its program?
12:24:04 <n-dolio> ski: If you consider non-functions, then instantiating [forall a. Num a => a -> a] to [Int -> Int] is a problem because you have to get the Num Int dictionary down to the elements of the list, which requires much more complicated code generation.
12:24:23 <n-dolio> Then consider that you can encode lists with just functions.
12:24:41 <stelleg> e.g. runghc -c 'main = interact $ map ("/tmp" ++) . lines'
12:24:42 <ski> n-dolio : yeah, that's why i said "at least inside `->'s"
12:24:49 <ski> hm
12:25:19 <ski> oh, now i seen. it's obvious
12:25:24 <n-dolio> 'forall r. ((forall a. Num a => a -> a) -> r -> r) -> r -> r' is going to have the same problem.
12:25:24 <ski> s/seen/see/
12:25:42 <ski> because constraint removal isn't `O(0)'
12:25:58 <n-dolio> Daan Liejen invented a totally different dictionary passing scheme to get around this in a paper about adding constraints to MLF.
12:26:13 <ski> still, if it's only `forall', i think it could possibly work
12:26:35 <ski> n-dolio : interesting. reference/link ?
12:26:44 <n-dolio> But it's kind of easier there, because the above isn't a proper MLF type.
12:28:04 <n-dolio> ski: Qualified Types for MLF, I think.
12:29:23 <n-dolio> ski: The gist is that the MLF for the above is something like: forall r (alpha < forall a. Num a => a -> a). (alpha -> r -> r) -> r -> r
12:30:01 <n-dolio> And then all those bounded quantifiers turn into evidence of the instantiation.
12:30:20 <n-dolio> So all your tweaking happens on the outside, and you never really do any deep instantiation.
12:30:21 <frerich_> Is there a tool which can look at some Haskell code of a function doing IO and suggest (preferrably large) chunks of pure code to move out?
12:30:51 <n-dolio> It's kind of a Yoneda-y thing.
12:31:25 <ski> "Qualified types for MLF" by Daan Leijen,Andres Löh in 2005-09 at <http://research.microsoft.com/apps/pubs/default.aspx?id=65287>
12:31:37 <n-dolio> forall r alpha. (alpha -> forall a. Num a => a -> a) -> (alpha -> r -> r) -> r -> r
12:31:57 <n-dolio> Yes, that's the one.
12:32:22 <pjdelport> frerich_: Probably not an automated tool. In some trivial sense you can lift almost all of the embedded pure computation into helpers just by looking at the types, but it might not be any prettier than before.
12:32:52 <pjdelport> frerich_: So the challenge is more finding something that's extractible from IO and still makes sense to human eyes.
12:33:08 <pjdelport> (Writing stuff in applicative style rather than do notation can help a lot with this!)
12:33:08 <frerich_> pjdelport: Yeah, my idea was to look just at the types. It wouldn’t need to be perfect but it would be nice to at least have some ‘suggestions’ so that I can inspect the code manually.
12:33:23 <pjdelport> frerich_: You could paste some of the code for some general advice?
12:33:26 <ski> n-dolio : hm, i think i see
12:33:58 <n-dolio> So, to instantiate to Int -> Int, you only have to handle that thing at the front now, and don't have to do anything to the rest of the generated code.
12:34:21 <n-dolio> You've pulled all your polymorphism out to the front.
12:35:40 <frerich_> pjdelport: I didn’t actually have any particular code in mind, but something I *would* like to run it on might be this function: http://lpaste.net/108055 — it’s part of a compiler cache (much like ccache in case you know that) which tries to avoid invoking the real compiler by reusing cached compilation artefacts such as object files.
12:36:01 <mmirman> anybody know why OpenGLRaw might be installing for OpenGL version 2.1 on a modern mac with versions up to 4.1 available?
12:36:20 <pjdelport> frerich_: Good heavens!
12:36:21 <frerich_> pjdelport: I.e. it does a lot of IO like invoking the external compiler and accessing the cache on disk (which is basically a directory structure like “~/cache/<somehashsum>/myobjectfile.obj”)
12:36:39 <ski> hm, still missing something. i don't see how to write `(Int -> Int) -> (forall a. Num a => a -> a)' -- i must be confused
12:37:23 * hackagebot diff-parse 0.1.2 - A parser for diff file formats  http://hackage.haskell.org/package/diff-parse-0.1.2 (vengefulpickle)
12:37:24 <frerich_> pjdelport: Even determining the location of the cache (e.g. “~/cache”) uses IO since it considers an environment variable.
12:37:26 <n-dolio> Is that what you need?
12:37:55 <n-dolio> The instantiated version would be: forall r alpha. (alpha -> Int -> Int) -> (alpha -> r -> r) -> r -> r
12:38:00 <ski> it seems so, going from `forall r alpha. (alpha -> forall a. Num a => a -> a) -> (alpha -> r -> r) -> r -> r' to `forall r. ((Int -> Int) -> r -> r) -> r -> r'
12:38:17 <n-dolio> It's also possible that I got it backwards.
12:38:42 <ski> (and since writing `(Int -> Int) -> (forall a. Num a => a -> a)' i must be misunderstanding something)
12:38:47 <simcity2000> hey everyone, quick question: for projects with multiple modules, what exactly does Haskell do to look for an imported module?
12:38:51 <ski> (we, since writing that is impossible)
12:39:08 <johnw> simcity2000: it uses the include paths
12:39:15 <pjdelport> frerich_: For inherently IO stuff, it's actually fine to keep it as IO actions, but what you'd want to do is factor that big monolithic function into smaller IO actions.
12:39:16 <ski> (s/we/er/)
12:39:20 <johnw> by Haskell I assume you mean just ghc, and not cabal
12:39:28 <simcity2000> johnw: right, just ghc for now
12:39:31 <n-dolio> ski: I probably got it backwards.
12:39:32 <simcity2000> this is a private project
12:39:35 <johnw> simcity2000: the -i flag
12:39:47 <joelteon> Does anyone have an updated tutorial for vinyl?
12:39:54 <joelteon> The one on the blog is apparently for vinyl 0.1 or something like that
12:40:08 <carter> joelteon: ask acowley or jonesterling :)
12:40:12 <ski> n-dolio : `alpha < forall a. Num a => a -> a' suggests a conversion `(forall a. Num a => a -> a) -> alpha', but i don't see that that helps
12:40:19 <frerich_> pjdelport: Definately. The issue with factoring code into smaller IO actions is that it forces you to come up with a good name, and I often rather not factor it out at all than to assign a bad/misleading name to it which forces me to look up the definition
12:40:28 <n-dolio> ski: Maybe the MLF type is (alpha > forall a. Num a => a -> a)
12:40:47 * ski rederives `Yoneda', to make sure
12:40:52 <ski>   forall a b. (a -> b) -> (f a -> f b)
12:41:03 <ski>   forall a. f a -> forall b. (a -> b) -> f b
12:41:05 <pjdelport> frerich_: Even a not-so-good name is fine, if the type and interface is simpler. You can always keep the name semi-internal.
12:41:18 <simcity2000> johnw: so if I have a module Foo where all files for Foo are in a separate directory Foo/, I should do something like -iFoo?
12:41:19 <pjdelport> or locally in a where clause, even
12:41:34 <ski>   forall a. (Yoneda f a = forall b. (a -> b) -> f b)
12:41:40 <johnw> simcity2000: if you are improting Foo.Blah, then -i the directory containing the directory Foo
12:41:42 <ski> ah, now i see my error
12:41:47 <simcity2000> johnw: noted. thanks!
12:41:50 <frerich_> pjdelport: True, I shouldn’t forget that a suboptimal name is still complemented by a function signature.
12:42:02 <ski> i was getting the direction of `a -> b' in `Yoneda' wrong
12:42:45 <ski> so then `forall r alpha. ((forall a. Num a => a -> a) -> alpha) -> (alpha -> r -> r) -> r -> r' should work, i assume
12:43:03 <ski> (`alpha' occuring positively in `(alpha -> r -> r) -> r -> r')
12:43:39 <ski> interesting that it's still rank-3
12:43:50 <n-dolio> Well, that's not surprising, I think.
12:43:57 <augur> cripes ski
12:43:58 <n-dolio> Because you can't just infer MLF.
12:44:12 <ski> hm, makes sense, i suppose
12:44:16 <n-dolio> But, I think that kind of indicates that MLF is a technique for reducing rank-n to rank-3.
12:44:29 * ski nods
12:45:11 <pjdelport> frerich_: For that function, my first thought would be to split the two main branches out into top-level actions, because they're pretty important.
12:45:45 <n-dolio> Anyhow, does that make sense now? We need (forall a. Num a => a -> a) -> (Int -> Int) to do the instantiation?
12:45:58 <n-dolio> Because the polymorphic part is now in positive position?
12:46:17 <frerich_> pjdelport: Makes sense. ‘reuseCachedArtefacts’ vs. ‘generateAndStoreArtefacts’  maybe.
12:46:20 <n-dolio> Seems that way.
12:47:27 <n-dolio> But, you don't have to walk arbitrarily far into an unknown structure, which would involve doing all the eta expansion in the code generator that GHC makes you do by hand.
12:48:05 <frerich_> pjdelport: It’s a little sad that this (the largest Haskell project I ever did) is *very* IO heavy. :-}
12:48:40 * ski nods
12:48:49 <pjdelport> frerich_: Yup, that sounds reasonable.
12:49:13 <n-dolio> ski: This also handles going from (forall a. a -> a) to (forall a. Num a => a -> a), where you'd have to walk into a structure because you generated code that wasn't expecting a dictionary.
12:49:14 <ski> i wonder if there's some relation to `Not (Not (Not a)))' being iso to `Not a'
12:49:18 <pjdelport> frerich_: I think You'll have the greatest gains by packaging some of those types better.
12:50:30 <pjdelport> frerich_: For example, instead of working with low-level details like cacheDir everywhere, perhaps it would make more sense to define some CacheManager type, which wraps up that together with any other details relevant to caching.
12:50:39 <frerich_> pjdelport: FWIW, I tend to not use “local” functions (via let and where) because I like to test things in ghci and AFAIK such local functions are inaccessible. I think that in case the large number of global functions ever becomes an issue, I’ll rather split things into modules than to make definitions more local.
12:51:51 <pjdelport> frerich_: Similarly, you might want some type that packages everything need to lookup and store artefacts (hashSum, dstFiles, anything else) in a single value.
12:52:05 <pjdelport> some CacheKey type, perhaps
12:52:56 <shlevy> johnw: https://gist.github.com/shlevy/33e8483e247c99cd9f7f
12:53:06 <shlevy> johnw: Main thing there is cloneSource
12:53:15 <frerich_> pjdelport: Indeed. In fact, I already thought about generalizing that a bit such that you have a Cache where some key is mapped to some unstructured content. Which made me realise that this is what document-based DBs do. So I looked for whether I can just use something existing but there doesn’t seem to be something as simple as SQLite for document DBs (they always seem to require servers).
12:53:44 <shlevy> The 'clone' function will usually be "return" but if your 'a' itself contains Sources you may need to recursively clone
12:53:59 <johnw> shlevy: looking
12:54:07 <shlevy> And the TBMQueue version isn't fleshed out yet but is straighforward
12:54:19 <johnw> shlevy: You know I already have STM Queue stuff, right?
12:54:37 <shlevy> Not for closable ones
12:54:45 <shlevy> At least not that I saw
12:54:47 <johnw> ok, then it would be great to fold this in
12:55:14 <pjdelport> frerich_: There isn't really anything that prevents you from using SQLite for that :)
12:55:17 <shlevy> Is the purpose of cloneSource clear?
12:55:27 <johnw> yes
12:55:33 <johnw> it looks like you want to clone a source
12:55:34 <shlevy> Seems more general than zipSinks
12:55:49 <johnw> interesting!  you flipped the problem around
12:56:06 <johnw> i see that fanoutTMQueue looks familiar; that can't be generalized around zipSinks?
12:56:10 <shlevy> I needed to, zipSinks doesn't give me a way to properly handle nested sources
12:56:21 <johnw> this is great stuff
12:56:21 <shlevy> Probably, though it doesn't actually use any conduit stuff
12:56:34 <pjdelport> frerich_: In fact, this is not necessarily a bad use case for SQLite.
12:57:15 <johnw> shlevy: I see
12:57:17 <shlevy> johnw: Gave me an excuse to learn STM :)
12:57:30 <johnw> STM is awesome
12:57:41 <shlevy> Yeah
12:57:50 <shlevy> Working in MonadBaseControl IO is hard :P
12:57:56 <johnw> indeed it is
12:57:57 <shlevy> I just want to work in IO
12:58:07 <johnw> at least you can do it
12:58:09 <johnw> in real conduit you can't
12:58:10 <carter> shlevy: johnw  theres opportunities to do work to make STM awesomer
12:58:18 <johnw> carter: oh?
12:58:23 <frerich_> pjdelport: I don’t really need the “relational” part though. I just take the output generated y a C++ compiler (stdout/stderr and any files it produces) and associate that with a hash formed of all the things which influence the output (e.g. the preprocessed output, the compiler binary, the commandline). I then use the filesystem as a database, which in principle works quite nicely.
12:58:23 <carter> like
12:58:27 <carter> something between STM and MVar
12:58:35 <shlevy> Hm?
12:58:40 <shlevy> TMVar works well
12:58:44 <frerich_> pjdelport: Except that it forces me to do it all myself :-}
12:58:53 <carter> shlevy: they have very different semantics :)
12:59:02 <johnw> shlevy: is this code stable, can I tinker with it?  Or is it going to change dramatically in the next few mins?
12:59:03 <pjdelport> frerich_: The most general advice I'd give for that kind of example is to pay lots of attention to what your input and output types are: whenever you have a Haskell function that takes many little arguments, try to see if you can combine them into bigger, more semantically meaningful argument types.
12:59:29 <pjdelport> So for example, something like restoreArtefacts :: CacheManager -> CacheKey -> CacheResult
12:59:33 <shlevy> johnw: Tinker pelase :) This was a proof of concept for me
13:00:01 <shlevy> I figured once you saw the gist you might be able to come up with a cleaner way
13:00:16 <frerich_> pjdelport: Makes sense, maybe I forgot about that as I added features. I suppose that especially when trying to factor IO code out you end up with a pure function taking extra arguments (e.g. the value of some environment variable instead of fetching it itself) which increases the importance of thinking about good types.
13:00:16 <johnw> I just want to play, this may well be great as it is
13:00:18 <pjdelport> Is a lot more meaningful than restoreArtefacts :: FilePath -> String -> [String] -> IO (String, String)
13:00:43 <shlevy> johnw: I think in general we'll want the kind that uses a bounded queue
13:00:50 <pjdelport> (the previous one should be IO CacheResult, of course)
13:00:59 <shlevy> johnw: Since otherwise there's no backpressure
13:01:16 <MitchellSalad> hi, could someone please help me understand this strange type error? http://lpaste.net/108056
13:01:29 <johnw> shlevy: right, I tend to use those more anyway
13:01:49 <frerich_> pjdelport: I was thinking of ways to not having to explicitely specify the cache all the time (i.e. the ‘cache directory’ or the ‘CacheManager’ in your example). Maybe something like a state monad could be used to implicitely pass this around.
13:01:49 <shlevy> johnw: Also instead of the bounded queue we might want to just use a {T,}MVar Maybe a
13:02:03 <shlevy> johnw: If we think we'll mostly just want one element at a time
13:02:19 <pjdelport> frerich_: As another example, instead of this function manually having to deal with statsFile, that should be something that's encapsulated inside CacheManager
13:02:27 <carter> @hoogle ceil
13:02:29 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:02:57 <frerich_> pjdelport: Right, if one creates a dedicated type then the statistics management could be hidden in that.
13:03:08 <shlevy> But I figure the queue lets us have branches of varying speeds be more efficient (while the boundedness lets us put a limit on memory)
13:03:27 <pjdelport> frerich_: Instead, there should probably be modifyStatistics :: CacheManager -> [modifications] -> IO ()
13:03:42 <MitchellSalad> whoops gotta run, be back later
13:04:29 <frerich_> pjdelport: If I had a ‘Cache’ monad which would allow me to define actions action on a Cache, I could maybe even use that to define functions like ‘modifyStatistics :: [modifications] -> IO’ or so, i.e. which can access the internal monad state to avoid having to pass the cache around?
13:04:51 <pjdelport> frerich_: And there should be wrappers around that for recording hits and misses, which is what the invocation function should call.
13:07:01 <pjdelport> frerich_: Maybe.... it might be premature generalization, though.
13:08:42 <pjdelport> Using something like an explicit CacheManager type for the static configuration (e.g. cache directory and stats files and such) is probably fine.
13:09:21 <pjdelport> Where necessary, you could access that via Reader or State to avoid having to pass it around too much, but passing it explicitly may be fine.
13:09:25 <frerich_> pjdelport: Thanks a lot for your input, that’s a lot of food for thought. I now have a few ideas how to improve things :-)
13:09:32 <pjdelport> Cool. :)
13:10:32 <pjdelport> frerich_: The golden rule is that functions should have as few parameters as possible.
13:11:18 <pjdelport> frerich_: For example, the next point of attention would be that only the first part of that big function use effectiveArgs, parsedArgs, and ppCode
13:11:19 <eikke__> pjdelport: sml-style -> 1 tuple ;-)
13:13:40 <pjdelport> frerich_: So that's a good hint that they should be wrapped into something; perhaps a CompilerInvocation type, that contains everything needed to invoke a compiler.
13:13:49 <AncientPC> I don't understand the type error from this line: filter (\x -> head x /= '.') $ getDirectoryContents "./logs"
13:14:17 <frerich_> AncientPC: ‘getDirectoryContents’ doesn’t yield a list you can filter things from, it yields an IO action.
13:14:17 <AncientPC> http://lpaste.net/3332277546564714496
13:14:25 <pjdelport> frerich_: Then you might have just computeCacheKey :: CompilerInvocation -> CacheKey
13:14:30 <merijn> AncientPC: "getDirectoryContents" is (I'm guessing) an IO action and filter doesn't take IO actions as arguments
13:14:49 <AncientPC> frerich_: oh, how can I coerce it into a list of strings I can do regexes on?
13:15:09 <frerich_> pjdelport: Yeah and I only now realize that it’s pretty silly how this whole program is juggling with compiler artefacts all the time, and yet there is no type to catch this concept….
13:15:10 <pjdelport> frerich_: And then later on, also: invokeRealCompiler -> CompilerInvocation -> IO CacheResult
13:16:00 <frerich_> I bet there is some metric which considesr the numbers of types defined, the numbers of functions defined and the average number of arguments per function and then there’s a magic threshold...
13:16:07 <frerich_> “Use the types, Luke”
13:16:13 <pjdelport> frerich_: And then e.g. storeArtefacts :: CacheManager -> CacheResult -> IO ()
13:16:26 <pjdelport> instead of 5 different parameters
13:16:30 <monochrom> AncientPC: perhaps read my http://www.vex.net/~trebla/haskell/IO.xhtml
13:16:40 <merijn> AncientPC: You can't, you're probably wanting "fmap :: Functor f => (a -> b) -> f a -> f b", because IO is a functor, which makes it "fmap :: (a -> b) -> IO a -> IO b"
13:17:30 <pjdelport> frerich_: Used this way, you'd probably also have updateStatisticsMiss :: CacheManager -> CacheResult -> IO ()
13:17:44 <pjdelport> instead of that big in-place modifyStatistics call
13:17:57 <AncientPC> thx monochrom, merijn; I realize I'm going this the wrong way. I should be keeping my pure functions separated from IO.
13:18:01 <pjdelport> where updateStatisticsMiss would use accessors to extract the relevant fields of the cache result
13:18:27 <tsani> How light are forkIO threads? Are they comparable to Erlang?
13:18:38 <carter> tsani: pretty light
13:18:38 <shlevy> tsani: "very"
13:18:44 <pjdelport> (as well as getting the stats file from the CacheManager type, etc.)
13:19:01 <shlevy> tsani: I read somewhere that it should be fine to spawn thousands
13:20:07 <tsani> I'm thinking of writing something that would need to handle a lot of network connections, and that's typically what one would look to Erlang for, but I would definitely prefer to use Haskell instead :)
13:20:24 <tsani> If forkIO is fine for running thousands of threads, then that's perfect.
13:20:52 <johnw> forkIO can handle millions
13:21:48 <ski> AncientPC : bring your non-I/O stuff inside `IO'. don't attempt to do it the other way around ;)
13:22:09 <pjdelport> forkIO threads are probably lighter than Erlang processes
13:22:24 <AncientPC> ski: I always thought it was the other way around, otherwise you run into IO creep
13:22:47 <ski> AncientPC : of course you mostly delay bring it inside `IO' as long as possible
13:23:02 <ski> but at some point you have to
13:23:57 <pjdelport> tsani: For some numbers: http://www.serpentine.com/blog/2008/02/06/ghcs-performance-with-threads-is-impressive/
13:25:10 <pjdelport> So that's creating 175,000 threads in one second, sending a message through all of them in 0.09s, and using only 45MB memory.
13:25:29 <pjdelport> 354MB for 1.75 million threads :)
13:26:14 <tsani> pjdelport: that's truly incredible!
13:26:25 <TheKing444> It is over 9000!
13:26:33 <merijn> tsani: forkIO is pretty sweet, yeah :)
13:26:56 <pjdelport> tsani: They really are extremely light weight; you can think of them more as an evaluation thunk than something heavy like in other languages.
13:27:20 <TheKing444> Haskell's parallelism is nice too.
13:27:33 <pjdelport> (also, those numbers are old, and probably better nowadays)
13:28:14 <frerich_> More recent (and impressive) numbers are in the linked Trac ticket: https://ghc.haskell.org/trac/ghc/ticket/1589#comment:6
13:28:21 <splintax> is it possible to add "deriving Show" to all types during development without having to explicitly add it to everything?
13:28:39 <splintax> also, why doesn't every type derive Show by default? for performance / binary size reasons?
13:29:02 <sveit> i want to take a list [[a,b,c],[d,e],...] -> [[a,d,...],[a,e,...],[b,d,...],...] . i have a pretty ugly way of doing it now: foldM (\acc l -> l >>= return . (++) acc . return) [] . does someone have a better way off the top of their head?
13:29:24 <suOya_> use transpose
13:29:31 <ski> splintax : values for some types can't be `show'n
13:29:39 <suOya_> > transpose [[1,2,3],[5,6,7]]
13:29:41 <lambdabot>  [[1,5],[2,6],[3,7]]
13:29:52 <suOya_> nevermind
13:29:57 <suOya_> that's different
13:29:59 <pjdelport> splintax: You can only derive Show if all the parts are Show instances. You could suppress an automatic "deriving Show" if they aren't, but having it only sometimes magically derive a Show instance depending on the parts would be pretty weird and surprising.
13:30:11 <sveit> suOya_: it's a bit more complicated :)
13:30:23 <TheKing444> Also, what if you want your own show instance?
13:30:42 <pjdelport> sveit: do you want the Cartesian product?
13:30:48 <rwbarton> also you might not want Show, e.g. for data encapsulation
13:30:48 <ski> > sequence [[a,b,c],[d,e]]  -- sveit ?
13:30:50 <lambdabot>  [[a,d],[a,e],[b,d],[b,e],[c,d],[c,e]]
13:30:56 <utdemir> Hi. Noob messing with IO here. I have "data Directory = Directory { path :: String, contents :: [String] }". Now I want to create "getDirectory :: String -> IO Directory". But "getDirectoryContents" is "IO [String]" and I couldn't find a way to transfer that IO to Directory. Can you help me?
13:31:04 <shlevy> johnw: Ah forgot to mention, I'm not confident that fanout int hat way is the best thing to do here
13:31:22 <shlevy> johnw: But I think it gives us the most flexibility
13:31:44 <TheKing444> utdemir
13:31:50 <johnw> shlevy: ok, still looking
13:32:20 <splintax> ski, pjdelport, TheKing444, rwbarton: thanks, those are all good reasons not to do that by default. but is there really no way to set a pragma or ghc flag or something so that everything derives show (where possible, and where not inconsistent with explicit) during development?
13:32:31 <ski> utdemir : `liftM (\conts -> Directory { path = myPath, contents = conts }) getDirectoryContents'
13:32:43 <luite> in optparse-applicative is there a way to have a verbosity :: Int field, such that no flag -> verbosity = 1, -v -> verbosity = 2 -> -vN -> verbosity = N ?
13:32:51 <ski> utdemir : `do conts <- getDirectoryContents; return (Directory { path = myPath, contents = conts })'
13:32:51 <utdemir> :t liftM
13:32:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:33:07 <utdemir> ski, Thank you.
13:33:08 <ski> utdemir : `getDirectoryContents >>= \conts -> return (Directory { path = myPath, contents = conts }'
13:33:46 <ski> splintax : dunno, sorry
13:33:55 <pjdelport> utdemir: Or using Applicative style, just: Directory myPath <$> getDirectoryContents mypath
13:34:12 <utdemir> :t (<$>)
13:34:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:34:13 <ski> utdemir : `fmap' and `(<$>)' is the same as `liftM' here
13:34:36 <pjdelport> utdemir: It's basically application where the right side is in a Functor (IO, in this case)
13:34:40 <utdemir> ski, pjdelport So, I have to read Typeclassopedia again? Do you have more tutorials about them?
13:34:46 <ski> utdemir : as pjdelport noted, one can say `Directory myPath' instead of `\conts -> Directory { path = myPath, contents = conts }'
13:34:56 <ski> utdemir : read it for what ?
13:35:22 <utdemir> ski, I'm still losing a lot of time figuring out these transformations.
13:35:33 <ski> (utdemir : .. also, i forgot to pass a path to `getDirectoryContents' in my versions)
13:35:42 <Pythonfant> utdemir: maybe do syntax is a bit easier to understand: do conts <- getDirectoryContents; return Directory { path = myPath, contents=conts }
13:36:05 <Pythonfant> getDirectoryContens probably needs to take the filepath
13:36:24 <pjdelport> utdemir: Functor and Applicative are simpler than Monad, really.
13:36:26 <ski> utdemir : `fmap',`(<$>)',`liftA',`liftM' are all basically the same thing. (partly) for historical reasons, the two latter require `Applicative' respectively `Monad' instead of just `Functor'
13:37:02 <TheKing444> :t liftA
13:37:02 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:37:31 <pjdelport> utdemir: If you have the pure function: "Directory myPath $ contents", where contents :: [String]
13:37:37 <ski> utdemir : either way, what you wanted was to "lift" a function of type `[String] -> Directory' into a function of type `IO [String] -> IO Directory', so that it could be applied to `getDirectoryContents somePath :: IO [String]', getting an `IO Directory' back
13:37:45 <flebron> utdemir: Conceptually, what you wanted was to apply a transformation "under" a fuunctor.
13:38:12 <pjdelport> utdemir: Then to let contents be an IO [String], you just change the $ to a <$>, to get "Directory myPath <$> getDirectoryContents mypath"
13:38:14 <flebron> i.e. you have F X, you want F Y, and you have an X -> Y. That's done by lifting the X -> Y into F X -> F Y using fmap.
13:38:15 <ski> utdemir : in a sense, you pulled the function of type `[String] -> Directory' inside the `IO' layer, applying it to the value "inside"
13:38:44 <utdemir> ski, Now its clear :)
13:39:14 <ski> utdemir : more properly you added the function to the end of the `IO'-action, to be called on the result of executing the previous `IO'-action, *when* the new `IO'-action (later, if ever) gets executed
13:40:21 <ski> utdemir : remember that a value of type `IO [String]' doesn't contain a list of strings, it just a description of Input-Output interaction to do with the operating system to get hold of a list of strings, when those instructions are actually executed
13:40:25 <ski> @quote /bin/ls
13:40:26 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:40:28 <sveit> pjdelport: yes
13:40:31 <sveit> ski that looks good...
13:41:00 * flebron tends to have the image of Functors being containers of a type
13:41:20 <sveit> ski: actually that's exactly what i want. thanks!
13:41:35 <ski> sveit : thought so :)
13:41:45 <monochrom> utdemir: perhaps read my http://www.vex.net/~trebla/haskell/IO.xhtml
13:41:48 <ski> @type sequence
13:41:49 <lambdabot> Monad m => [m a] -> m [a]
13:41:54 <sleepomeno> what is the best package to dive into opengl with a nice interface?
13:43:00 <pjdelport> sveit: The list functor basically gives you that, yes.
13:43:32 <pjdelport> sveit: It's exactly the same as what happens when you say for example:
13:43:33 <pjdelport> > (,) <$> "abc" <*> [1,2,3]
13:43:34 <lambdabot>  [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
13:43:54 <utdemir> pjdelport, That looks scary.
13:44:08 <sveit> pjdelport: isn't it really the list monad that gives that?
13:44:15 <michaelt> sleepomeno: gloss has an excellent interface, but it doesn't count as
13:44:22 <michaelt> diving into opengh, splintax
13:44:27 <michaelt> grr
13:44:28 <pjdelport> sveit: "list monad" is just short for list monadic functor :)
13:44:46 <bgamari> If I have two monad transformers `n, m :: (* -> *) -> * -> *`, how can I express the type `\t->n (m t) :: (* -> *) -> * -> *`
13:44:49 <pjdelport> sveit: And in this case, you're actually not using any of the monadic functionally: only the Applicative functor functionality.
13:44:51 <michaelt> sleepomeno: pardon sentence fragments
13:45:02 <bgamari> Given that type synonyms can't be partially applied, they are out
13:45:09 * flebron thinks of Functor as "transparent object containers", applicatives as "transparent object containers + function container application", and monads as "flattenable containers". But that analogy can fail fast :p
13:45:20 <sveit> pjdelport: really? my follow-up question was what properties i was using. could i write sequence using just applicative combinators?
13:45:21 <pjdelport> flebron: No, that's great!
13:45:23 <bgamari> there's a name for this but I can't think of it
13:45:35 <flebron> Well it kind of dies when you get to monads like Cont.
13:45:55 <pjdelport> sveit: Yes: sequenceA = foldr (liftA2 (:)) (pure [])
13:46:26 <flebron> You can maaaaaaaaaybe think that (->) r is a container of something "indexed by r's", but for more specialized cases I give each functor/applicative/monad its own "personality", kind of with like the "computational context" description of monad.
13:46:28 <pjdelport> Note how similar that is to the list identity: foldr (:) []
13:46:43 <AncientPC> What's the deal with "missing dyn libraries" error? Google doesn't return anything useful. http://lpaste.net/8611712073350512640
13:46:58 <bgamari> I guess just Compose
13:47:31 <sveit> pjdelport: so why isn't sequence in applicative? that's kind of confusing
13:47:31 <pjdelport> So what sequenceA does, via that foldr, is almost literally to just lift the list constructors (:) and [] from "outside" the functor to "inside" the functor.
13:47:43 <johnw> shlevy: https://gist.github.com/1bfe92e0d8cbc45d6e52
13:47:59 <sveit> pjdelport: nevermind, just realized we luck out in this case since m = []
13:48:29 <pjdelport> sveit: It is, a bit. For whatever reason, they chose to define sequenceA in Traversable, which is a bit more generic than sequence in that it works for any traversable, not just lists.
13:48:42 <utdemir> flebron, I'm just starting to understand; but, for example, I don't know when to create a Functor or an Applicative or a Monad when writing a code. That analogies will help me a lot.
13:48:46 <bgamari> damn, but Compose m n isn't necessarily a monad for monads m,n
13:50:11 <johnw> shlevy: the only substantive change I made was exception propagation
13:50:20 <sveit> pjdelport: what is the intuition behind the list applicative? <*> applies each function on the left to each input on the right?
13:50:21 <flebron> utdemir: Well I see those 3 as interfaces, like "functor" is "Fmappable", monad is "joinable", things like that. So from that perspective one can think of when one's code can be better written as a series of fmaps or joins, or whatever, and say "h, so this type must implement the joinable interface", so you say that by writing "instance Monad MyType where..."
13:50:30 <pjdelport> flebron: The way i like to express it is to replace the mention of "container" with that of an opaque structure, with slots.
13:50:34 <johnw> shlevy: otherwise, our queue could suddenly die in ways we couldn't catch
13:50:53 <pjdelport> sveit: Pretty much, yes.
13:50:58 <shlevy> johnw: Looking...
13:51:47 <pjdelport> > [id, (+1), negate] <*> [10,20,30]
13:51:48 <lambdabot>  [10,20,30,11,21,31,-10,-20,-30]
13:52:32 <pjdelport> > [(+)] <*> [10,20,30] <*> [0,1,2,3]
13:52:34 <lambdabot>  [10,11,12,13,20,21,22,23,30,31,32,33]
13:52:37 <sveit> pjdelport: that sequenceA is clever. need to learn to come up with stuff like that
13:53:07 <johnw> sveit: whenever you have a (b c) and you want b (a c), and applicatives are involved, think of sequenceA
13:53:08 <trap_exit> do we have bidings for http://web.archiveorange.com/archive/v/nDNOvwZidoQwVF2HcjrU in haskell yet?
13:53:19 <trap_exit> I want http://www.texmacs.org/tmweb/home/welcome.en.html bindings in Haskell
13:53:25 <johnw> sveit: it becomes natural after a while to reach for that one
13:53:41 <trap_exit> has anyone followed up on http://web.archiveorange.com/archive/v/nDNOvwZidoQwVF2HcjrU ? Someone should start a kick starter for TeXmacs <-> Haskell. I will donate $10.00 to the effort
13:54:12 <shlevy> johnw: What's "link"?
13:54:33 <shlevy> Ah I see
13:54:39 <johnw> link says "any exceptions that happen in the spawned thread, re-raise them in the current thread"
13:54:49 <shlevy> Cool
13:55:02 <johnw> normally I use withAsync for that, but here we can't scope
13:55:12 <shlevy> Yeah
13:55:15 <johnw> concurrently implies nested withAsync calls + waitBoth
13:56:03 <shlevy> Any good way to reduce duplication between the bounded and unbounded versions?
13:56:26 <shlevy> > :t (<$)
13:56:27 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:56:46 <shlevy> :t (<$)
13:56:47 <lambdabot> Functor f => a -> f b -> f a
13:56:59 <johnw> shlevy: you could make a function that accepts close and write functions
13:58:59 <mmmm_> "Constraint is no smaller than the instance head" what does this mean?
13:59:03 <shlevy> the *IO versions of everything based on TVar is annoying
13:59:46 <johnw> mmmm_: it means your constraint does not reduce the scope of your instance; can you show the code?
14:01:30 <shlevy> johnw: Hmm I need to learn applicative/functor styles
14:01:41 <mmmm_> The problem is on line 42 johnw
14:01:43 <shlevy> Also didn't know there was a comma operator
14:01:43 <mmmm_> http://lpaste.net/108065
14:01:52 <shlevy> :t (,)
14:01:53 <lambdabot> a -> b -> (a, b)
14:01:56 <johnw> shlevy: there's (,,), (,,,), etc.
14:01:57 <shlevy> Cool
14:02:23 <shlevy> :t bimap
14:02:24 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
14:02:31 <johnw> bimap lets me map over both sides of a tuple
14:02:38 <johnw> join bimap f says to apply f to both sides
14:02:45 <ski> sveit : `sequence' was invented before `Applicative'
14:02:46 <johnw> so, (a, a) turns into (f a, f a)
14:02:52 <shlevy> Ah cool
14:03:11 <ski> @type join (a -> a -> b) -> (a -> b)
14:03:12 <lambdabot> parse error on input ‘->’
14:03:16 <ski> @type join :: (a -> a -> b) -> (a -> b)
14:03:17 <lambdabot> (a -> a -> b) -> a -> b
14:03:28 <ski> @type join
14:03:29 <lambdabot> Monad m => m (m a) -> m a
14:04:34 <shlevy> johnw: It doesn't really matter, but there's really no reason to spawn two threads when writing/closing in fanout
14:04:35 * joeyh is curious about michaelsalad's paste too (http://lpaste.net/108056) .. it seems to show a case where fmap and <$> are not exactly the same
14:04:49 <shlevy> johnw: we can just spawn one and run the other in the current thred
14:05:05 <johnw> shlevy: yeah, that's true
14:05:06 <joeyh> hmm, perhaps it's the composition that is making the type checker behave differently?
14:05:30 <pjdelport> sveit: Applicative lends itself to that kind of derivation.
14:05:37 <johnw> joeyh: this is exactly the same problem with existentials and composition that we were discussing before
14:05:44 <shlevy> johnw: shame withAsync cancels
14:07:27 <n-dolio> joeyh: Use of DB is hiding a higher-rank type.
14:07:52 <pjdelport> sveit: For example, if you didn't have sequence, you could derive it as follows: first, remember that <*> for lists does "combinatorial application", and then take a list construction that uses pure application, and replace the appropriate pure function applications with <*>
14:08:24 <n-dolio> And 'f . runDB $ x' is different than 'f (runDB x)' because of that.
14:08:31 <shlevy> johnw: Why *do* existentials cause that problem?
14:08:42 <n-dolio> Also these aren't existentials.
14:09:31 <johnw> n-dolio: is right
14:09:38 <johnw> sorry, lack of precision in terminology
14:09:43 <pjdelport> So, ["abc","123"] is actually just "abc" : ("123" : []), but because Applicative unfortunately does not apply to infix syntax, we first have to translate it to prefix application:
14:09:43 <pjdelport> >  let cons = (:); nil = [] in cons "abc" $ (cons "123" $ nil)
14:09:44 <lambdabot>  ["abc","123"]
14:10:21 <johnw> n-dolio: what is the root problem here?
14:11:07 <n-dolio> DB a = forall m. DBConstraint m => SqlPersistT m a
14:11:18 <shlevy> johnw: Looks good. So I guess I just need to flesh out the bounded version, add proper documentation, and remove the test code
14:11:45 <pjdelport> Now, if we want to treat "abc" and "123" as *choices* of the first and second element, and get all the possible combinations back, we just have to lift the constructors and values, and replace the appropriate applications with <*>:
14:11:45 <pjdelport> > let cons = fmap (:); nil = pure [] in cons "abc" <*> (cons "123" <*> nil)
14:11:46 <lambdabot>  ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
14:11:47 <n-dolio> So runDB :: DBConstraint m => (forall m'. DBConstraint m' => SqlPersistT m' a) -> m a
14:12:06 <johnw> shlevy: great!  I've added the stm-chans dependency to simple-conduit
14:12:23 <mmmm_> Did you get a chance to look johnw? or know where I can read about the problem?
14:12:28 <n-dolio> Which is a higher-rank type. And the type of (.) can't be instantiated to work with runDB.
14:12:52 <shlevy> johnw: Hmm there are a couple of behaviors we can have here... We can stop reading from the original Source when *any* channel blocks, or we can keep reading until all have blocked
14:13:06 <johnw> mmmm_: i did, looking for references for you
14:13:15 <pjdelport> And that works regardless of how many elements there are; every <*> adds another choice of values to the final Cartesian product:
14:13:15 <pjdelport> > let cons = fmap (:); nil = pure [] in cons "abc" <*> (cons "123" <*> (cons "xyz" <*> nil))
14:13:16 <lambdabot>  ["a1x","a1y","a1z","a2x","a2y","a2z","a3x","a3y","a3z","b1x","b1y","b1z","b2...
14:13:27 <johnw> n-dolio: ah, thank you
14:13:35 <shlevy> johnw: I'm not sure which behavior is appropriate really
14:13:55 <Exio> can i make a list with multiple "types" part of a typeclass?
14:14:23 <johnw> Exio: you can use data kinds to build a heterogeneous list, without needing type classes at all
14:14:30 <johnw> mmmm_: http://stackoverflow.com/questions/17863332/what-contraint-is-no-smaller-than-the-instance-head-means-and-how-to-solve-it
14:14:37 <shlevy> Ah, well there's an ordering problem... if one queue blocks before the other then we have to stage the intermediate values somewhere to ensure they are added in the right order once it unblocks
14:14:53 <johnw> shlevy: so we need a local buffer?
14:15:21 <mgoszcz2> Hi. Why does ':t return 3 >>= replicateM' work but fails when I specify what type return is meant to return?
14:15:21 <shlevy> johnw: Only if we allow one of the result sources to get ahead of the other
14:15:23 <johnw> shlevy: btw, once you drop down into MonadBaseControl IO, we can take advantage of some of the tricks in stm-conduit that have already solved parts of this problem
14:15:33 <joelteon> > sequence ["abc", "123", "xyz"]
14:15:34 <lambdabot>  ["a1x","a1y","a1z","a2x","a2y","a2z","a3x","a3y","a3z","b1x","b1y","b1z","b2...
14:15:50 <shlevy> johnw: Ah cool, will take a look
14:16:10 <johnw> specifically the local buffering trick
14:16:13 <pjdelport> And if you compare it again to the pure version:
14:16:14 <pjdelport> > let cons = (:); nil = [] in cons 'a' $ (cons '1' $ (cons 'x' $ nil))
14:16:15 <lambdabot>  "a1x"
14:16:27 <Exio> i mean, because it is a "main list" of roles, where every role will be part of a typeclass but be a different datatype (and more "roles" can be added in another typeclass)
14:16:58 <shlevy> johnw: I'm at the point where I think I basically know what all the options are but not sure which/how to expose them in a nice API :)
14:17:27 <Exio> http://www.haskell.org/haskellwiki/Heterogenous_collections just saw this
14:17:29 <johnw> shlevy: we could hammer it out through some use cases
14:17:34 <johnw> since I'm guessing you wrote these to use them
14:17:37 <shlevy> Yeah :)
14:18:08 <shlevy> So my main use case is an extension of the original idea that required zipSinks
14:18:42 <shlevy> When adding a directory to the nix store, I want to compute its hash at the same time as I copy it
14:19:12 <johnw> ah, yes
14:19:21 <shlevy> So I have a Source of ArchiveEntries, which can be a directory or a plain file or a symlink
14:19:22 <frerich_> Exio: In my experience, it often is the case that when you think you need a heterogenous list, you actually need a list of functions
14:19:24 <pjdelport> The final nice thing is that the above works for *any* applicative functor: So for example, instead of lists (choices), you can plonk IO actions in there: cons getLine <*> (cons getLine <*> (cons getLine <*> nil))
14:19:25 <sveit> pjdelport: that's great, thanks a lot for taking the time to go through tat
14:19:44 <shlevy> And the PlainFile constructor contains a Source inside of it
14:19:57 <johnw> shlevy: you know, the way you described it now sounds like it would be an applicative monadic fold over the directory contents
14:19:59 <shlevy> So we need the ability to specify the 'clone' function
14:20:12 <pjdelport> That's of course equivalent to sequenceA [getLine,getLine,getLine]
14:20:22 <shlevy> to properly give both streams the file content stream without reading it twice
14:20:32 <johnw> right
14:20:33 <shlevy> johnw: Hmm can you expand a bit?
14:20:49 <johnw> so, an applicative fold let's you compute one than one bit of information as the fold progresses
14:20:56 <johnw> this is the idea Tekmo's foldl package is based on
14:21:06 <shlevy> Aaah OK
14:21:13 <shlevy> Yes that sounds exactly right
14:21:15 <johnw> we're doing the exact same thing here, only with side-effects
14:21:38 <Exio> frerich_, i'm refactoring some code, and the case where i "need" this right now is this: "gamePlayers = [HumanPlayer X, IAPlayer O]"
14:21:43 <johnw> so I'm wondering if we can model it that way, without asynchronicity
14:21:47 <sveit> pjdelport: so in the description of sequenceA, when it says "evaluate each action in the structure from left to right", in the list case this action is running for each element of the list?
14:21:49 <johnw> and then plug the async back in after we get the model right
14:21:54 <shlevy> OK
14:21:58 <johnw> and then we'd have a general solution for a whole class of similar problems
14:22:01 <shlevy> Yeah
14:22:04 <Exio> HumanPlayer and IAPlayer where, before, in the same datatype
14:22:12 <shlevy> I guess I should check the foldl package?
14:22:18 <johnw> yeah, and I should too
14:22:27 <johnw> this may be the "right" way to solve what zipSinks is solving over in the conduit world
14:22:43 <johnw> only conduit didn't solve it this way because they aren't using folds
14:22:51 <frerich_> Exio: Why do you need to have that list? Maybe because you map a function over all the elements, and the function does something different on what kind of player it is?
14:23:05 <johnw> this is great connection, thanks shlevy, I will think about this more tonight
14:23:18 <shlevy> Cool thanks
14:23:21 <shlevy> I'll take a look too :)
14:24:14 <Exio> somehow, it is turn-based so it is "one-player-at-time", i map over it and call a function (in the typeclass definition) for every player
14:24:54 <shlevy> johnw: Hmm will there be a way to say "if we're in MonadIO/MonadBaseControl IO do this async, otherwise do it par"?
14:24:58 <Exio> the loop is player-agnostic, it just calls functions part of a typeclass
14:25:02 <shlevy> johnw: or something similar?
14:25:13 <Exio> "loop", map :P
14:25:34 <johnw> shlevy: good question; asynchronicity of any kind may be something we can inject with a combinator even
14:25:37 <mgoszcz2> Hi. Why does ':t return 3 >>= replicateM' work, but 'read <$> getLine >>= replicateM' fails?
14:25:47 <frerich_> Exio: I think this sounds a bit like the setup in http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ ...
14:25:53 <johnw> or by the choice of some Applicative wrapper
14:25:59 <shlevy> Ahh
14:26:01 <shlevy> OK I see
14:26:11 <shlevy> OK looking at the foldl library now :D
14:26:13 <Exio> frerich_, thought this was an antipattern, i'm just abusing typeclasses so i get used to their syntax
14:28:15 <T_X> hi there. I'm currently trying to use a State Monad, but couldn't quite figure out how to use in this small code snippet here: http://pastebin.com/eQnn5FtZ
14:28:37 <T_X> so I have these two event handlers for keypresses in a haskell-gtk program
14:28:47 <shlevy> johnw: Hmm do you know why there's a separate "extraction function" in this model of folds?
14:28:49 <T_X> and I'd like to share some common state between them
14:28:50 <danilo2> Hello! I've got a variable "a", which is a monad transformer. I would love to extract a type information out of it in such way, that I want to extract only first part of the type. I mean if "a" is "StateT a b c" I want to get a type "Proxy StateT". Is it possible? I think I would be able to do it using TH, but I would love to see a solution without th if there exist one :)
14:29:37 <shlevy> Hey there's already FoldM :D
14:29:44 <arancia> You can to use IORefs or MVars for this
14:29:49 <glguy> danilo2: write   myfun :: f a b c -> Proxy f ; myfun _ = Proxy  ?
14:29:50 <arancia> T_X: ^
14:30:20 <T_X> arancia: ah, okay. yeah, I had used MVars once before and been wondering whether I should use it here
14:30:30 <T_X> thought I had read somewhere that they might be evil :D
14:30:44 <arancia> Oh, how so?
14:30:59 <S11001001> danilo2: what's the kind of Proxy?
14:31:09 <danilo2> glguy: unfortunatelly it will work for StateT but not a non-parametrised monad transformer, like MaybeT
14:31:27 <dfeuer> @kind Proxy
14:31:28 <lambdabot> k -> *
14:31:31 <danilo2> S11001001: I do not know - it depends of the transformer itself
14:31:36 <rwbarton> it might be possible with a closed type family
14:31:43 <T_X> arancia: and $somehow wrapping the two handlers in some state monad would be impossible or just not nice to look at?
14:31:46 <danilo2> ahh , Proxy! Proxy is of kind *
14:31:48 <johnw> shlevy: yeah, he does that for a reason which I don't recall at this moment; I've talked to him about it before
14:31:59 <johnw> shlevy: gotta go for dinner now, but I'll come back and we can figure that out
14:32:17 <shlevy> OK :)
14:32:26 <johnw> shlevy: see Simple.hs, where I have conversion functions to/from his FoldM type; that may help
14:33:04 <johnw> (they are commented out right now to avoid the dependency)
14:33:24 <arancia> T_X: I think it's impossible, at least I spent some time trying to achive the same and finally failed :p
14:34:22 <mgoszcz2> Hello. Why ':t return 3 >>= replicateM' returns 'Monad m => m a -> m [a]' but 'read <$> getLine >>= replicateM' fails with "Expected type: Int -> IO b0 ctual type: Int -> m0 a0 -> m0 [a0]"?!
14:34:44 <T_X> arancia: ah, hehe :D
14:35:16 <T_X> arancia: thanks again! (I think you helped me out yesterday, too, suggesting to use cairo instead of plain gtk?)
14:35:31 <T_X> if so, using cairo worked like a charm, worked on first try :)
14:35:46 <arancia> Ah, the image scaling problem, right?
14:35:54 <T_X> exactly, yes
14:36:03 <arancia> Nice
14:36:32 <rwbarton> mgoszcz2: your "return 3 >>= replicateM" is using the reader >>=, not IO
14:36:53 <shlevy> johnw: Ah separating out the extraction function allows the Applicative instance to save combining until the very end
14:37:00 <rwbarton> because replicateM 3 is a function, not an IO action
14:38:51 <mgoszcz2> rwbarton: Yes but wouldn't it return IO a -> IO [a]
14:39:11 <TheKing444> :t replicateM 3
14:39:12 <lambdabot> Monad m => m a -> m [a]
14:39:53 <TheKing444> @let IOBind = (>>=) :: IO a -> (a -> IO b) -> IO b
14:39:54 <lambdabot>  .L.hs:146:1: Not in scope: data constructor ‘IOBind’
14:40:33 <TheKing444> @def ioBind = (>>=) :: IO a -> (a -> IO b) -> IO b
14:40:35 <lambdabot>  Defined.
14:40:46 <TheKing444> return 3 `ioBind` replicateM
14:40:57 <TheKing444> > return 3 `ioBind` replicateM
14:40:58 <lambdabot>  Couldn't match type ‘m0 a0 -> m0 [a0]’ with ‘GHC.Types.IO b’
14:40:59 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Types.IO b
14:40:59 <lambdabot>    Actual type: GHC.Types.Int -> m0 a0 -> m0 [a0]
14:42:15 <iasoon> Does anyone mind explaining why "fmap head . replicate 3 $ getLine" still reads three lines?
14:42:25 <iasoon> Thus is not lazily evaluated?
14:42:28 <TheKing444> I can!
14:42:40 <TheKing444> > fmap head . replicate 3 $ getLine
14:42:41 <lambdabot>  Couldn't match expected type ‘[b]’
14:42:41 <lambdabot>              with actual type ‘GHC.Types.IO GHC.Base.String’
14:42:54 <TheKing444> The reason is that it is invalid code to begin with.
14:43:06 <TheKing444> Wait, never mind
14:43:11 <TheKing444> uh, let's rewrite it a bit
14:43:18 <iasoon> forgot a sequence in between
14:43:20 <TheKing444> fmap (head . replicate 3) getLine
14:43:24 <rwbarton> did you mean replicateM?
14:43:30 <TheKing444> wait no
14:44:26 <iasoon> rwbarton: will replicateM be evaluated lazily?
14:44:33 <rwbarton> well...
14:44:39 <rwbarton> "evaluation" is irrelevant
14:44:40 <TheKing444> :t fmap head $ replicateM 3 getLine
14:44:41 <lambdabot> IO String
14:44:56 <rwbarton> replicateM 3 getLine is an action that, when executed, will execute getLine three times
14:44:59 <isomorpheous> :t (<$>)
14:44:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:45:04 <TheKing444> You see, haskell has lazy evaluation, not lazy execution.
14:45:07 <mgoszcz2> TheKing444: Any ideas with "return 3 >>= replicateM" problem?
14:45:15 <chrisdone> yo dawg i heard you liked development, so i loaded your ghc-server project's code inside ghc-server running inside ghci inside emacs
14:45:18 <pjdelport> mgoszcz2: What do you actually want that to do?
14:45:20 <iasoon> TheKing444: Ah, yes, of course.
14:45:40 <TheKing444> mgoczcz2, the bind is for the special function monad, which is weird
14:45:50 <TheKing444> :t ioBind
14:45:51 <lambdabot> IO a -> (a -> IO b) -> IO b
14:45:52 <iasoon> TheKing444: any idea on how a similar effect is achieved?
14:46:17 <iasoon> Like, when I want to find the first matching line in a file or something.
14:46:18 <TheKing444> iasoon, I have an idea
14:46:28 <TheKing444> wait, oh that
14:46:44 <rwbarton> danilo2: this somewhat works although it's not entirely satisfactory: http://lpaste.net/108066
14:46:51 <mgoszcz2> pjdelport: Return a function that will accapt an IO action and repeat it some number of times.
14:47:13 <mgoszcz2> pjdelport: The problem is the "number of times" is also in IO
14:47:51 <rwbarton> mgoszcz2, you just have your variable flow slightly wrong
14:47:55 <rwbarton> better to just write a lambda
14:49:23 <rwbarton> \act -> (read <$> getLine) >>= (`replicateM` act)  -- even this is overly contrived IMO
14:50:13 <TheKing444> iasoon, try iterateUntil
14:50:14 <TheKing444> https://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html#iterateUntil
14:50:43 <TheKing444> or untilJust
14:50:54 <jfischoff> is there an example out there of use the runBuilder method: https://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Builder-Extra.html#v:runBuilder to create a BufferWriter which is then used with a buffer to write to socket with the sendBufTo : https://hackage.haskell.org/package/network-2.5.0.0/docs/Network-Socket.html#v:sendBufTo
14:50:56 <pjdelport> mgoszcz2: You could say: replicatePrompted m = (`replicateM` m) =<< (read <$> getLine)
14:51:15 <iasoon> TheKing444: just realised I was really stupid, and was actually looking for hGetContents.
14:51:20 <jfischoff> It does not appear hard to write, but common enough I feel like some else must have already
14:51:22 <TheKing444> oh
14:51:24 <TheKing444> Okay
14:51:25 <iasoon> but thanks for the pointer, it's useful anyways :)
14:51:31 <ReinH> rwbarton: I think that would be more clear in do notation
14:51:32 <ReinH> o_O
14:51:35 <mgoszcz2> Ok. This is what I wanted to achive, but failed:
14:51:44 <rwbarton> ReinH, yes
14:51:59 <mgoszcz2> :t \a -> return 3 >>= \n -> replicateM n a
14:51:59 <lambdabot> Monad m => m a -> m [a]
14:52:25 <mgoszcz2> But I don't know why just "return 3 >>= replicateM" isn't enough
14:52:45 <mgoszcz2> After all..
14:52:56 <mgoszcz2> :t return 3 >>= replicateM
14:52:57 <S11001001> mgoszcz2: the a is inside the RHS of the >>=, not outside it
14:52:57 <lambdabot> Monad m => m a -> m [a]
14:53:13 <ReinH> Can we say: replicatePrompted ma = do { n <- read <$> getLine; replicateM n ma } ?
14:53:23 <rwbarton> mgoszcz2: again that is the reader monad ((->) Int)
14:53:31 <rwbarton> :t return 3 >>= (+)
14:53:32 <lambdabot> Num a => a -> a
14:54:22 <mgoszcz2> rwbarton: What do you mean?
14:54:45 <pjdelport> sveit: The whole "evaluate each action in the structure from left to right" isn't actually a very accurate intuition for functors in general.
14:54:55 <rwbarton> write out the types carefully
14:55:28 <pjdelport> sveit: It probably owes more to the legacy of IO, and of Haskell's Monad class unnecessarily forcing an evaluation from left to right (for hysterical raisins).
14:56:32 <mietek> Any thoughts on the current state of Haste vs Fay?
14:56:54 <pjdelport> sveit: For Applicative, it just means that the list is lifted into the functor with right-associated application of (:), just like lists already are. any ordering (or not) is completely up to the functor.
14:57:00 <mgoszcz2> rwbarton: But "return 3 >>= replicateM" and "\a -> return 3 >>= \n -> replicateM n a" _appear_ to have the same type
14:57:57 <luite> mietek: dunno, but i'd just go for a proper compiler instead ;)
14:58:06 <mietek> luite: which is what, GHCJS?
14:58:18 <rwbarton> mgoszcz2, by coincidence
14:58:24 <rwbarton> mgoszcz2, they are using different (>>=)
14:58:25 <mietek> I thought Haste was quite proper, using much of GHC
14:58:33 <luite> mietek: i guess i'm getting predictable :(
14:59:11 <mietek> luite: not at all; I knew of it, but my not-so-current impression of GHCJS is that it generates huge blobs of JS
14:59:18 <pjdelport> sveit: The default definition of (for example) IO as an applicative functor will evaluate the IO actions from left to right, but you can actually flip the order of any Applicative functor, using a newtype wrapper like http://lpaste.net/107551
14:59:26 <mgoszcz2> rwbarton: How can they be using different (>>=)?
14:59:44 <MP2E> mietek : as opposed to fay or haste? Isn't it all 'blobs' of JS after being compiled ? :P
14:59:44 <rwbarton> why not? it's overloaded
14:59:52 <rwbarton> they are using different 'return' too
15:00:31 <pjdelport> sveit: So with that wrapper, if you say: unRev $ sequenceA [Rev getLine, Rev getLine, Rev getLine]
15:00:32 <mietek> MP2E: I am going on other people's accounts, for instance:
15:00:37 <mietek> http://www.reddit.com/r/haskell/comments/1htqi2/announce_haste_the_haskell_to_js_compiler_is_now/cay3v6e
15:00:43 <mietek> "FWIW, last time I got it to build, minified GHCJS code was larger than minified Haste code by a factor of 200 or so, but both projects have changed quite a bit since then."
15:00:50 <pjdelport> then the actions will actually be executed from right to left.
15:01:02 <mgoszcz2> rwbarton: But shouldn't the different (>>=) and "return" behave the same?
15:01:05 <MP2E> wow sheesh 200 x factor
15:01:09 <pjdelport> (And there's no reason for IO to be left to right by default except convention.)
15:02:25 <mietek> MP2E: I think Chris' comments in that thread are interesting.
15:02:34 <mietek> luite: what do you say to them 1 year later?
15:03:02 <mietek> I'd just like to be able to write a React app in Haskell.
15:03:10 <luite> MP2E: it's kind of hard to compare in general. ghcjs uses more of the existing base lib, for example using the buffered IO things for putStrLn, and it also has a bigger static overhead, generated fast-apply patterns
15:03:53 <luite> MP2E: so if you choose a small app that also uses features like this, the difference will be much bigger
15:03:54 <mietek> I know of Shade, but it introduces a "typed tagless-final domain-specific syntax", which is impenetrable to me at first read.
15:04:06 <mietek> luite: s/MP2E/mietek/
15:04:33 <luite> mietek: oh MP2E responded to that 200x factor
15:04:53 <mgoszcz2> rwbarton?
15:05:09 <luite> if you minify and compress a simple program that does some console interaction but other than that does not use many libraries
15:05:29 <luite> the ghcjs result is about 60kB gzipped currently
15:05:42 <luite> including all required libs for the rts
15:06:00 <mietek> Right.
15:07:18 <luite> i'm sure haste and fay will be much smaller though. ghcjs code is cps transformed to get threading, tail call optimization and unlimited call depth for other calls
15:08:53 <luite> which adds some code overhead, and closure compiler is less effective optimizing it. i'm working on a better optimizer that should reduce the codede size and make the code faster, but it's a fairly invasive change, the intermediate language gets types, the dataflow engine has to be rewritten
15:08:57 <rwbarton> mgoszcz2: as I said before, write out the types carefully and see what happens
15:09:02 <rwbarton> better to do the computation yourself
15:09:42 <mgoszcz2> rwbarton: I don't know how I'm supposed to do it
15:09:58 <chrisdone> 60kb isn't too bad for modern desktop browsers
15:10:12 <hiptobecubic> what about purescript?
15:10:12 <systemfault> Haha, I feel so noob… spent 5 minutes wondering why I couldn’t use `ap`, I was importing Control.Applicative instead of Control.Monad :(
15:10:15 <chrisdone> that's probably just under a meg of javascript
15:10:29 <TheKing444> If my have 4 gig of ram, how big can Integer go before overflow?
15:10:30 <luite> mietek: and it'll also add an option to get code that is not completely cps transformed, which will be more comparable in size to haste, but might still be a little bigger since i don't want to switch how closures are handled
15:10:41 <luite> chrisdone: ~230kB uncompressed minified
15:10:48 <rwbarton> write out the types of (>>=) and replicateM and see what m is
15:11:20 <mietek> chrisdone: oh hi.  Thanks for that reddit summary.
15:11:22 <chrisdone> for comparison, the fp complete ide is 140kb compressed
15:11:23 <TheKing444> Do you have GHC 7.8 yet mgoszcz2?
15:11:26 <TheKing444> type holes may help
15:11:37 <TheKing444> And if not you can use FP complete.
15:11:41 <mietek> chrisdone: do you know what's the current state of Haste?
15:11:44 <chrisdone> so ghcjs as a base is half the size of an ide =p
15:12:08 <chrisdone> mietek: no, i need to sit down one weekend and try out all the latest offerings
15:12:22 <mietek> luite: I'm not convinced layering the RTS on top of whatever is already provided by the browser is the right approach for in-browser apps.
15:12:36 <mietek> luite: and I don't think there's any other reason to target JS.
15:13:03 <eacameron> is there a library that will let me parse and run Haskell in runtime?
15:13:09 <chrisdone> hiptobecubic: purescript is neato
15:13:25 <chrisdone> eacameron: hint can do that
15:13:41 <eacameron> chrisdone: so look at the src?
15:13:51 <chrisdone> eacameron: just use hint?
15:14:01 <eacameron> chrisdone: oh, I thougth you mean hlint
15:14:01 <chrisdone> it's a library
15:14:02 <mietek> chrisdone: have you seen http://haste-lang.org/icfp14.pdf ?
15:14:07 <mgoszcz2> TheKing444: Nope, I can try rwbarton: I'll try and get back to you
15:14:08 <TheKing444> I bet there is a library in Boston that is on the path of Boston marithon. Just stop running, go in, download ghc.
15:14:55 <TheKing444> :t (>>=) :: (r->a) -> (a->r->b) -> (r->b)
15:14:56 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
15:14:57 <genericpersona> lol
15:15:16 <luite> mietek: that might be true, but on the other hand some laziness related memory consumption issues are hard to solve if you map closures like fay/haste do. as far as i measured, the ghcjs approach is more predictable and was usually faster (long time ago though, i'll need to recheck)
15:15:18 <mietek> chrisdone: I thought it was interesting, but I'm suspicious they don't mention any failure modes.
15:15:19 <chrisdone> mietek: i think i read that when it was last posted. neat stuff
15:15:40 <TheKing444> :t return 3 :: (r->Int)
15:15:41 <lambdabot> r -> Int
15:15:50 <mietek> chrisdone: which is odd, considering they reference Cloud Haskell, and they should certainly be aware of http://armstrongonsoftware.blogspot.co.uk/2008/05/road-we-didnt-go-down.html
15:16:02 <solidus-river> hey all, how would i write something where i have an infinite list and i want ot take increasingly larger sets from the head of the list
15:16:09 <solidus-river> so if my possibilities are [1..]
15:16:12 <TheKing444> :t takes
15:16:13 <lambdabot>     Not in scope: ‘takes’
15:16:13 <lambdabot>     Perhaps you meant one of these:
15:16:13 <lambdabot>       ‘take’ (imported from Data.List),
15:16:19 <TheKing444> :t inits
15:16:20 <lambdabot> [a] -> [[a]]
15:16:23 <TheKing444> inits [1..]
15:16:24 <luite> mietek: and the additional advantage is that you can get a heap profile similar to what ghc can do, with ghcjs, with breakdown per cost centre, type, module etc
15:16:29 <TheKing444> > inits [1..]
15:16:30 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
15:16:43 <solidus-river> <3
15:17:02 <luite> mietek: with the other approach you can only get what the js profiler gives you, which might not be terribly informative. there'd be no way to do biographical profiling for example
15:17:04 <TheKing444> :info inits
15:17:18 <TheKing444> @src inits
15:17:18 <lambdabot> inits []     =  [[]]
15:17:18 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
15:19:02 <luite> mietek: so i tend to disagree about closures/heap object mapping. i do agree about threading though, that's a feature that will become optional after the optimizer change
15:19:46 <chrisdone> mietek: disclaimer: i'm not that interested in haskellish->javascript compilers, fay was just a yak i shaved so i could use it at work when everyone else sucked. now there're many choices and i've not done any fat client work other than at fp complete which is already using fay and won't be changing for a while. i've turned my attention to other things, the community's got the whole hs->js thing covered now
15:19:50 <mietek> luite: I wouldn't mind if only a strict dialect of Haskell was compilable to JS :)
15:20:22 <luite> mietek: that'd make code reuse basically impossible
15:20:27 <chrisdone> mietek: heh heh, i considered a strict haskell compiler to js once
15:20:38 <luite> you could share adt's perhaps, but that's about it
15:20:44 <mietek> Some people already mostly write strict Haskell
15:20:47 <chrisdone> luite: like purescript
15:21:19 <mietek> And there's also https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
15:21:29 <mietek> Quite fresh
15:22:00 <luite> mietek: yes, but that's all for specific modules, where it makes sense (although i'm a tad worried about overuse)
15:22:13 <chrisdone> i expect that's why fay had and now purescript has any appeal; light-weight. dumb, easy to trust
15:22:29 <mietek> chrisdone: yes.
15:22:30 <chrisdone> the thing about purescript is i like laziness =)
15:22:44 * hackagebot sai-shape-syb 0.2.2 - Obtain homogeneous values from arbitrary values, tramsforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.2.2 (AndrewSeniuk)
15:22:48 <luite> ghcjs can compile psc now out of the box :)
15:22:51 <chrisdone> but i think some extension is available for laziness
15:22:59 <solidus-river> what if i want to take a sequence and repeat it forever in a list
15:23:11 <solidus-river> like [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, ....]
15:23:20 <chrisdone> mietek: there's also idris
15:23:23 <luite> i found a rather hard to hit bug in the code generator a few days ago, that so far only psc hit
15:23:36 <mietek> chrisdone: I know! It's on my ever-growing list of things to play with.
15:23:40 <chrisdone> which is strict with lazy support, oh and a small thing called dependent types =)
15:23:41 <luite> so i'm thankful to them for stressing ghcjs :p
15:24:02 <mietek> chrisdone: but I do need something which could conceivably be used for production right now...
15:24:17 <mietek> Or at least, prototyping
15:24:27 <solidus-river> :t repeat
15:24:28 <lambdabot> a -> [a]
15:24:44 <mietek> Is purescript it?
15:24:46 <geekosaur> > cycle [1, 2, 3]
15:24:48 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
15:25:00 <geekosaur> solidus-river, ^^
15:25:00 <Tesseraction> :t cycle
15:25:01 <lambdabot> [a] -> [a]
15:25:05 <luite> i did some experiment with ghcjs earlier today, to make ffi syntax less noisy: https://github.com/ghcjs/ghcjs-ffiqq
15:25:07 <chrisdone> mietek: it seems to have a growing ecosystem, i'd bet on it
15:25:22 <solidus-river> :t combinations
15:25:23 <lambdabot> Not in scope: ‘combinations’
15:25:31 <Tesseraction> tempted to cycle [1 ..]
15:25:37 <benzrf> :t L.combinators
15:25:38 <lambdabot> Not in scope: ‘L.combinators’
15:25:40 <Tesseraction> guessing it just detects it'll run out of memory
15:25:40 <benzrf> :t L.combinations
15:25:41 <lambdabot> Not in scope: ‘L.combinations’
15:25:43 <benzrf> huh
15:26:06 <solidus-river> nest i want all possible combinations of a set wtih repititions :p
15:26:13 <triliyn> Cycling infinite list just yields the infinite list back I think
15:26:17 <chrisdone> mietek: i'm not sure why roy didn't take off in the same way in the haskell community
15:26:17 <benzrf> > replicateM 3 [1, 2, 3, 4, 5, 6, 7]
15:26:18 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,1,7],[1,2,1],[1,2,2],[1,...
15:26:26 <mgoszcz2> TheKing444: Ghc 7.8 likes it?! It accepts "let x = return 3 >>= replicateM :: IO Int -> IO [Int]" with no errors!
15:26:37 <solidus-river> interesting
15:26:38 <benzrf> oh thats permutations
15:26:38 <Tesseraction> solidus-river: so a... superset that also defies an axiom of a set?
15:26:42 <benzrf> :I
15:26:44 <chrisdone> mietek: but i guess it's because roy is just a researchy experiment
15:26:49 <luite> and since template haskell runs on javascript, you can potentially the library, run some code that inspects some objects and automatically generate bindings
15:26:53 <mietek> hmm
15:26:58 <chrisdone> mietek: purescript's got all this going on: https://github.com/purescript
15:27:01 <solidus-river> yeah, i kinda want replicateM but where order doesn't matter
15:27:06 <benzrf> purescript looks hella
15:27:13 <benzrf> the effect system looks cool as hell
15:27:17 <Tesseraction> hm
15:27:31 <Tesseraction> > cycle [1..]
15:27:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:27:40 <Tesseraction> interesting
15:27:43 <benzrf> row polymorphism looks gr8 for js interfacing as well
15:27:43 <frerich_> pjdelport: Turns out your ideas caused me to rewrite my entire program. Ahem.
15:27:44 <solidus-river> :t replicate
15:27:45 <lambdabot> Int -> a -> [a]
15:27:52 <triliyn> @src cycle
15:27:52 <lambdabot> cycle [] = undefined
15:27:52 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:27:59 <benzrf> bbl
15:28:05 <pjdelport> frerich_: Whoops. :) In a good way, I hope?
15:28:17 <Tesseraction> ah, that would explain it
15:28:28 <sm> chrisdone: what, is purescript taking over from fay ?
15:28:43 <mietek> SELL SELL SELL
15:28:49 <chrisdone> lol
15:29:09 <chrisdone> sm: i think the kind of people who like fay will like purescript for the same reasons
15:29:10 * sm is close to purchasing fay stock and didn't get that memo 
15:29:34 <frerich_> pjdelport: I think it’s promising. I started by creating a new module exposing the API for accessing a cache and the statistics. This isn’t used anywhere yet but it compiles and seems to work out quite well: http://lpaste.net/108067
15:30:36 <chrisdone> but i haven't tried to program in it. dunno what it's like
15:31:06 <frerich_> pjdelport: I only now realize that I forgot to provide ‘modification functions’ for the statistics...
15:31:07 <chrisdone> i did recommend a speed tweak tho =)
15:31:19 <luite> what tweak?
15:31:20 <pjdelport> frerich_: That seems promising!
15:31:42 <hdgarrood> I've been working on a web asset pipeline library for haskell
15:31:53 <hdgarrood> does that sound like the kind of thing anyone would be interested in using?
15:32:00 <pjdelport> frerich_: A lot of those functions could use some Applicative style, instead of do syntax :)
15:32:21 <chrisdone> luite: eh, it was using dictionaries instead of function Foo(){} objects, the speed difference is ridiculous
15:32:35 <dwcook> Tesseraction, for xs an infinite list (i.e., lacking a []), cycle xs = xs
15:32:38 <solidus-river> jesus i'm all up in lists today, i want to remove duplicate tuples from a list where the ordering of the tuple doesnt matter
15:32:44 <solidus-river> the only way i can think to do this  is with a fold
15:32:48 <frerich_> pjdelport: Really? Interesting! In a few cases they were so short that I first wrote them without o but just >>= — but then I decided that the result wasn’t any easier to read to me...
15:33:12 <mietek> https://github.com/purescript-contrib/purescript-react
15:33:13 <pjdelport> frerich_: For example: modifyStatistics cache modifiers = setStatistics cache . compose modifiers <$> getStatistics cache
15:33:23 <mietek> chrisdone: cheers.
15:33:25 <luite> chrisdone: do you have suggestions for syntax/features for this? https://github.com/ghcjs/ghcjs-ffiqq , it's supposed to bring ghcjs' ffi convenience closer to fay's. arguments are marshalled through the FromJSRef / ToJSRef classes
15:34:36 <frerich_> pjdelport: Let me digest that. That was exactly one of the functions which I first wrote without do, and the result was a lot more noise than using fmap...
15:34:49 <chrisdone> luite: looks handy =)
15:35:18 <mankyKitty> luite: very nice !
15:35:24 <luite> chrisdone: it's all normal haskell code, so a user could customize argument/return marshalling if the library exposed some bits for that
15:35:26 <pjdelport> frerich_: You can understand it exactly like: "setStatistics cache . compose modifiers $ getStatistics cache", if you imagine getStatistics cache were pure
15:35:26 <solidus-river> i want to filter a list based on the things already filtered in the list
15:36:24 <frerich_> pjdelport: Yeah (I used fmap / <$> quite extensively in other code), it just never occurred to me to do that. In particular, it never occurred to me todo ‘setStatistics cache . compose modifiers’
15:36:30 <pjdelport> frerich_: The <$> instead of $ just means it's the same function application, but against a functor (the result of an IO action, in this case) instead of a pure value.
15:37:10 <luite> mankyKitty: one issue is that it doesn't appear to be possible to get the return type automatically (through reification) from a TH Expression location
15:38:09 <luite> mankyKitty: so it always just uses fromJSRef, and it cannot enforce monomorphicity for example
15:38:19 <jophish> solidus-river, find some fixed point of filtering a list?
15:38:46 <mankyKitty> luite: but that's kind of to be expected though isn't it? since you're wandering off into the world of JS ? You lose the guarantees
15:38:52 <solidus-river> jophish: what does fixed point / point free mean?
15:39:15 <Chrastis> Hey guys
15:39:15 <jophish> :t fix
15:39:16 <lambdabot> (a -> a) -> a
15:39:17 <mankyKitty> luite: that said, I can just barely understand the problem.. so I'm sort of just throwing ideas out there :p
15:39:19 <luite> mankyKitty: it could do it if some type quoting was added though
15:39:26 <mankyKitty> ahhh
15:39:40 <jophish> solidus-river, probably not exactly what you want here though
15:40:06 <luite> mankyKitty: well the issue is that if you do this type of ffi call, for convenience you really want IO a, instead of IO (Maybe a) in general
15:40:15 <Chrastis> Is this a tech room?
15:40:19 <jophish> @pl foo a b c = a + b + c
15:40:19 <lambdabot> foo = ((+) .) . (+)
15:40:22 <Zekka> Chrastis: Yes, most ofu s are programmers
15:40:54 <luite> mankyKitty: so the conversion tends to happen with some default value or conversion, for integers you could return (x|0) if the foreign call return x
15:40:54 <frerich_> pjdelport: I suppose one could also use ‘setStatistics cache . compose modifiers =<< getStatistics cache’? I think I like that a bit better because it somehow suggests a data flow.
15:40:56 <Chrastis> Oh. Wanted to become one of those. Not smart enough
15:41:11 <Chrastis> OK then. Cheers
15:41:17 <luite> nick_named: which forces it to be a valid number within the 32 bit signed integer range (and not a NaN for example)
15:41:21 <luite> oops
15:41:21 <Zekka> Aw, it's not that hard to pick up
15:41:26 <luite> mankyKitty: ^ that was for you
15:41:59 <mankyKitty> luite: hehe, and yeah I can see how that would be a problem :(
15:42:03 <luite> mankyKitty: but if it's polymorphic, then you get different behaviours depending on the same return result, that could be a bit unexpected
15:42:28 <frerich_> pjdelport: Unless I did a mistake, ‘setStatistics cache . compose modifiers <$> getStatistics cache’ actually has type IO (IO ())
15:42:30 <luite> it'd still always give you valid haskell values out, but the risk of getting the default through the fallback is higher
15:42:49 <mankyKitty> luite: blerg :(
15:43:00 <mankyKitty> luite: wish I knew more so I could help out ><
15:44:20 <luite> mankyKitty: anyway i think it's already safer than haste's ffi, which uses eval at runtime, and stronger guarantees are not hard to add, the question is just how to present them to the user
15:44:43 <solidus-river> oh, aye, not waht i want
15:44:45 <dfeuer> It took me way too long to figure out why my first approach didn't work, but I finally got a fusable scanr using tuples, and the tuples unbox. So yay.
15:44:50 <solidus-river> i think i want nubBy
15:44:54 <dfeuer> NOW TIME TO GO OUTSIDE.
15:45:18 <mankyKitty> luite: so something like deciding on [js| 3 + a |Integer] etc etc
15:45:44 <dfeuer> solidus-river, there's a list somewhere of functions you should never use. nub is on that list, and nubBy should be there for the same reason.
15:46:14 <dfeuer> It's O(n^2). Unless you're sure your lists are *very* short, use something else.
15:46:38 <solidus-river> dfeuer: why?
15:46:50 <solidus-river> oh
15:46:52 <dfeuer> Because its only constraint is Eq.
15:46:58 <solidus-river> i dont know any way to form this that wouldn't be 0^n2
15:47:00 <solidus-river> er
15:47:03 <solidus-river> O(n^2)
15:47:11 <luite> mankyKitty: unfortunately that part is not controllable from within the QQ :)
15:47:13 <dfeuer> There isn't one unless you add another constraint like Ord or Hashable.
15:47:25 <luite> mankyKitty: only beween the | |
15:47:29 <dfeuer> Which you usually can.
15:47:49 <dfeuer> Because not many practical things are in Eq but neither orderable nor hashable.
15:48:10 <Zekka> dfeuer: So did someone write ordNub or something where I can readily use it?
15:48:16 <Zekka> (I guess I could just use Set.fromList)
15:48:20 <dfeuer> If there's no natural ordering, you can make something else and pass that to a function you write that takes one.
15:48:30 <luite> mankyKitty: an alternative could be $(js "3+`a" ''Integer)
15:48:36 <shachaf> Set.toAscList . Set.fromList loses the order, unfortunately.
15:48:47 <dfeuer> Zekka, to preserve laziness and amortized performance, you should do something a little different.
15:48:50 <dfeuer> Ideally.
15:48:56 <Zekka> shachaf: Yeah, although often I find when I'm using nub I don't care about order
15:49:18 <dfeuer> Stick them into a set one by one as you go, checking each before you take it.
15:49:20 <dibblego> there is an exercise in NICTA/course to write this function using filterM and State
15:49:25 <dfeuer> BYE.
15:49:27 <dfeuer> BYE>
15:49:53 <pjdelport> frerich_: Oh, right, yeah; in that case you'll want =<< instead of <$>
15:49:54 <shachaf> If you do, you can write something like ordNub :: Ord a => [a] -> [a]; ordNub = go Set.empty where { go s [] = []; go s (x:xs) | x `Set.elem` s = go xs | otherwise = x : go (Set.insert x s) xs }
15:50:28 <pjdelport> frerich_: =<< is like <$> with an implicit join, of course; or it's what you use when the function on the left of <$> results in a functor too. :)
15:50:44 <pjdelport> (and it often still reads nicer in applicative style than do syntax)
15:50:50 <shachaf> Unfortunately that trick won't work if you don't have an Ord instance.
15:50:54 <frerich_> pjdelport: Right, learned about the existance of =<< only a few hours ago and coincidentally now found a good use for it.
15:51:12 <shachaf> There isn't much in the way of data structures for things where you don't have an Ord instance.
15:51:28 <shachaf> You can use a newtype if it can be defined statically.
15:51:48 <shachaf> Or reflection! reflection is the solution to all problems.
15:52:27 <mankyKitty> luite: that makes sense, although with the QQ stuff as you have it on the readme it would be nice to avoid writing it all in strings
15:52:56 <mankyKitty> luite: working on some purescript stuff has really highlighted that for me.. :\
15:54:11 <pjdelport> frerich_: getStatistics will also probably make a nice pipeline
15:54:45 <mankyKitty> luite: I guess things like this might be a pain though: $(js "foo(`a)" ''Integer -> Double) or something similar.. actually that's not that bad either.. hrmm
15:54:54 <frerich_>  pjdelport: Really? The only other change I did was to condense clearCache to ‘getDirectoriesInDirectory (cacheDir cache) >>= mapM_ removeDirectoryRecursive’
15:54:56 <dolio> zq: Sorry for the slow reply. Yes, local imports make parsing harder, because imports can bring operators into scope that have to change the parse. So, if you were attempting to parse in one pass, the parser would have to coroutine out to load modules in the middle of parsing at arbitrary times, instead of knowing all the modules you need to check up front.
15:55:09 <Andrey_> Hello all! Could someone please help me out? I'm implementing a web socket server in Haskell using wai-websockets and I was wondering how would I identify each new visitor that connects to the server. Basically, I have an array of clients, and I need a way to remove them on socket close, etc.
15:55:41 <pjdelport> frerich_: Something like this: getStatistics (Cache _ statsFile _)  = default . parse . getContent <$> tryRead
15:55:47 <Rembane> Andrey_: Put them in a Map or Set.
15:55:58 <pjdelport> where those functions are essentially the ones you have below in the current version.
15:56:08 <darthdeus> if anyone dares to answer :P http://www.reddit.com/r/haskell/comments/2bn2il/are_functional_languages_or_specifically_ghc/
15:56:15 <dolio> zq: But it's pretty much impossible to parse Haskell straight in one pass anyway, because operators with different fixities can be defined at arbitrary points in the program.
15:56:24 <pjdelport> getContent = either (const B.empty) id; parse = Aeson.decode . BL.fromStrict; default = fromMaybe (Statistics 0 0 0 0 0 0 0 0 0)
15:56:26 <pjdelport> etc.
15:56:28 <luite> mankyKitty: it's just a syntactic difference, with the QQ it's also a string, passed to the quoter, but sometimes that's important :)
15:56:48 <luite> mankyKitty: it's possible to get the types of the arguments by reifying the nams
15:56:56 <Andrey_> Rembane: Thanks, I'll look into that
15:56:58 <mankyKitty> luite: ah okay..
15:57:32 <Rembane> Andrey_: No worries, good luck!
15:58:14 <mankyKitty> luite: that's delicious, will definitely have to give it a whirl :D
15:59:04 <frerich_> pjdelport: Indeed!
15:59:42 <frerich_> pjdelport: Now looking at my own pastebin to learn why I didn’t “see” that possibility myself
16:01:22 <frerich_> pjdelport: It’s quite pretty how “fromMaybe nullStats . parse . getContent <$> tryRead” (I adjusted your suggestion a bit) is actually fairly suggestive as to what’s going on
16:01:54 <pjdelport> frerich_: The general rule is that do syntax is often only really warranted if you have "x <- foo; ..." where x gets used multiple times in the remainder, and/or where you sequence multiple actions.
16:02:26 <pjdelport> frerich_: If you only use a binding once, and use lots of "let = ..." and "return $ ...", it's often a sign that do syntax is just being verbose. :)
16:02:48 <Andrey_> Rembane: If I where using some id (Int) as key, how would I increment it?
16:03:31 <frerich_> pjdelport: Interesting, that sounds like a nice rule of thumb.
16:04:02 <Rembane> Andrey_: Put it as an argument to the function which does all the saving of the clients.
16:08:23 <frerich_> pjdelport: I think I’ll have the ‘Cache’ module export a couple of lenses for the individual ‘Statistics’ fields such that clients can then use e.g. Data.Label.modify like ‘modifyStatistics cache [modify cacheSize (+1042), modify numCacheHits (+1)]’
16:10:18 <pjdelport> frerich_: Sounds nice.
16:11:00 <Andrey_> Rembane: So, would it make more sense to create a session in database and take its id instead? because I don't really see a way to pass the id to the function that does saving. My array of clients is actually mvar, and since I'm new to haskell and don't really feel how everything supposed to work together, messing with concurrency a little overwhelming :)
16:21:37 <rasfar> Andrey_, if you're free we can discuss your problem more (not sure i can help but will try).
16:22:29 <rasfar> If you're already using a DB to manage sessions, why also an MVar containing an array?
16:23:00 <mietek> It appears to me there are conflicting factions in the functional programming world.
16:23:16 <mietek> The single-coloners and the double-coloners.
16:23:58 <mietek> (Of course, they could also be called the double-coloners and the single-coloners.)
16:24:00 <Andrey_> rasfar: I'm not using database yet, but so far that seemed to me a solution, even though not the most optimal one. I don't really need to store sessions every time a visitor comes in. I only need them for a moment they are connected
16:24:18 <mietek> Is it some sort of Oxford vs Cambridge divide?
16:24:20 <mietek> Does anyone know?
16:24:39 <mietek> Or even, England vs Scotland?
16:24:50 <rasfar> Andrey_: okay, so are you concerned with generating unique IDs for keys in the array?
16:24:51 <Twey> mietek: There are only single-coloners and people who want compatibility with Haskell.  :þ
16:25:14 <Rembane> Andrey_: It would make sense to create a session in database and use that instead. It's a solution. :)
16:25:17 <mietek> Twey: ha!
16:25:34 <Rembane> Andrey_: Do you have any code to show?
16:25:35 <Andrey_> rasfar: yeah :) I just need some way to identify the user
16:25:53 <Twey> mietek: Nobody uses double colons in the theory — it's just a ‘mistake’ Haskell made, because they expected list consing to be more important (I think).
16:26:26 <rasfar> the :: is convenient for grepping type sigs
16:26:29 <Andrey_> rasfar: for now a small rewrite of wai-websokets example - https://github.com/yesodweb/wai/blob/master/wai-websockets/server.lhs
16:26:40 <joelteon> : would also be convenient
16:26:43 <mietek> Twey: it's just odd to see languages bootstrapped off Haskell using :
16:26:49 <joelteon> \<:\>
16:27:00 <rasfar> you'd see a lot of noise joelteon
16:27:12 <joelteon> well, that'd match on :
16:27:20 <joelteon> but not ::
16:27:26 <joelteon> or :::
16:27:41 <Andrey_> rasfar: there they are using usernames to identify them, but I'm going to create a connection every time a visitor comes in, and won't ask anything
16:27:44 <rasfar> i actually am not familiar with \< \>
16:27:51 <mietek> Andrey_: cool, why are you rewriting it?  I was hoping to use wai-websockets very soon
16:27:53 <joelteon> that's vim word boundaries
16:28:03 <joelteon> i guess you could just [^:]:[^:]
16:28:07 <Twey> mietek: After some time of reading papers/Agda, I feel weird using :: for typing
16:28:30 <rasfar> joelteon: I think this will still show all lines using list cons?
16:28:31 <Andrey_> rasfar: lol, I'm not rewriting the library. Only the example :D
16:28:37 <joelteon> rasfar: not if list cons is ::
16:28:47 <rasfar> ^mietek
16:29:09 <rasfar> oh i see
16:29:16 <mietek> Andrey_: sure, but is it for your own education?  Or did you fix something in it?
16:29:22 <Rembane> Andrey_: Can't you just use the client as the key in the set?
16:30:24 <mietek> Andrey_: interestingly, I've been thinking a bit about sessions IDs recently, and authentication + authorisation in general
16:30:25 <Andrey_> Rembane: I won't have any client to set, except for WS.Connection, but it seems it's not deriving Eq
16:30:42 <mietek> Andrey_: I'm sketching out a prototype on top of bare WAI/Warp right now; https://github.com/mietek/untitled-wai/blob/master/src/Auth.hs#L125
16:31:01 <mietek> Andrey_: it runs on Heroku + Heroku Postgres
16:31:33 <Rembane> Andrey_: Ach. What about using the port or the client's IP-address as key then?
16:31:37 <Rembane> Andrey_: Or the combination of them
16:34:48 <Andrey_> Rembane: I though about that, but would they uniquely identify? If I open my application from the same wifi or even browser, but different tabs?
16:35:20 <Andrey_> mietek: looks cool, i'll look into it more in case I decide to use db for sessions
16:35:52 <mietek> Using a DB from Haskell is still a pain
16:36:00 <rasfar> Andrey_: maybe the easiest thing is to add an MVar Int to your ServerState (if you have some kind of server state?)
16:36:07 <mietek> I'm not convinced by persistent, and even less convinced by esqueleto
16:36:24 <rasfar> Just increment if on each new connection
16:36:29 <rasfar> *it
16:37:29 <rasfar> or does that make sense? (i haven't looked at similar code for a couple months, much water under the bridge since)
16:37:31 <mietek> postgresql-orm looks promising, but it also looks like a research project
16:37:32 <Rembane> Andrey_: If you open it from the same machine multiple times, multiple ports will be used. One per connection.
16:37:43 <Rembane> Andrey_: Lets see if I can find a source on that.
16:38:01 <mietek> Andrey_: if you don't want to use a DB, do you want to have any sort of backing store? Then perhaps acid-state?
16:38:16 <mietek> Andrey_: otherwise, do you want to only have in-memory state? Then perhaps just STM?
16:38:16 <rasfar> Andrey_: rather I have a parameter of type MVar ServerState which gets passed around
16:38:21 <Rembane> Andrey_: Does this make sense? http://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket
16:38:35 <Andrey_> rasfar: sounds easy, but isn't it against the functional way? :)
16:38:38 <rasfar> and one of the fields is seqno :: Int
16:39:12 <rasfar> Andrey_: I don't think so; if you look for example at websockets package examples, they do this (that was my basis)
16:39:16 <Andrey_> mietek: I was thinking to look into acid-state, is it storing data in ram?
16:39:43 <mietek> The whole point of acid-state is that it's serializable with ACID guarantees
16:39:51 <mietek> So, not just in-memory
16:40:22 <mietek> If you are happy with just in-memory state, then Software Transactional Memory should be enough
16:40:38 <mietek> TVars are more composable than MVars
16:40:43 <Andrey_> Rembane: it does, it seem like it would be a way to go
16:40:50 <mietek> I'll refer you to http://chimera.labs.oreilly.com/books/1230000000929/index.html
16:40:57 <oatsadn> hi, i’m having trouble with an SDL app. i did “cabal init” and then edited build-depends to look like: “build-depends:       base >=4.6 && <4.7, SDL”. I’ve also done “cabal install SDL” and it says “Registering…  Installed SDL-0.6.5” but when I run runhaskell it says “Setup.hs: At least the following dependencies are missing: SDL -any” — what might i be missing?
16:41:45 <mietek> The disadvantage of using acid-state vs a mainstream DB like Postgres is that acid-state is its own little world
16:42:07 <mietek> This may or may not be a factor for you
16:42:24 <ReinH> xred
16:42:54 <Rembane> Andrey_: Cool. Good luck! :)
16:43:11 <Andrey_> mietek: thanks for the link, I'll look into that. I'm new to haskell so I'll probably go with whatever is easier to learn and more mature
16:43:43 <mietek> OK.  I think Simon's book is an excellent learning resource.
16:44:08 <rasfar> oatsadn: not using a sandbox?
16:45:36 <oatsadn> rasfar: i’m not sure what that is
16:46:00 <rasfar> then you're probably not using one :)
16:46:15 <rasfar> in which case i don't know what to suggest off hand
16:47:09 <oatsadn> rasfar: by sandbox do you mean local build of haskell platform?
16:47:18 <rasfar> you may need to install a C library if SDL is just bindings to the foreign lib, but I would have expected that to cause your SDL install to fail
16:47:42 <rasfar> oatsadn: sandbox is a relatively new feature of cabal
16:48:31 <rasfar> it builds all dependencies in the project dir, so it's easier to avoid version conflicts etc. ("cabal hell")
16:48:59 <rasfar> i think they're great, but this is not really addressing your problem
16:50:28 <rasfar> you have installed the (non-Haskell) libsdl...-dev package?
16:53:06 <acowley> Still getting an interface file error in 7.8.3  :(
16:53:19 <rasfar> anyway, I need to get back to work -- if you run cabal install -v you may find some clues as to what's going on
16:53:26 <oatsadn> rasfar: yes, that’s all there. i actually swapped out SDL in build depends for lists-extras (just to see if it’s SDL related). get the same kind of error for list-extras too
16:54:21 <oatsadn> i installed haskell from macports and ran cabal update cabal (cabal told me to do it). SDL is from macports as well
16:54:33 <Enigmagic> acowley: whats the issue?
16:54:54 <acowley> Enigmagic: Today I started getting this: <no location info>: Cannot continue after interface file error
16:55:02 <acowley> Enigmagic: With 7.8.2 and 7.8.3
16:55:12 <acowley> Enigmagic: I can avoid it by forcing recompilation of a particular file
16:55:42 <solidus-river> hmm
16:55:47 <solidus-river> i'm giving up
16:55:55 <solidus-river> is this even solvable? http://www.reddit.com/r/math/comments/2bgdai/solve_my_yard_olympics_round_robin/
16:56:09 <solidus-river> so far i have this http://lpaste.net/108068
16:56:18 <solidus-river> but i dont think you can actually solve that problem programatically
16:56:23 <Enigmagic> acowley: certainly have seen that before but it was more common back in the 7.0/7.2 era.. at least for me
16:56:34 <rasfar> oatsadn: you mention using "runhaskell" -- I don't use that... shouldn't you be trying "cabal configure" and "cabal build" in your project dir?
16:56:53 <acowley> Enigmagic: Any memories of how to treat it?
16:56:57 <solidus-river> btw, thats not my problem, friend picked it out and sent it my way as a brain teaser
16:57:34 <Enigmagic> acowley: yeah i used shake to figure out what to build instead of ghc ;-)
16:57:48 <oatsadn> rasfar: ah that was it!
16:58:07 <oatsadn> i saw runhaskell on some random blog i guess
16:58:16 <rasfar> great! / also if you have more than one version of GHC kicking around, you have to be careful of your path...
16:59:01 <rasfar> cabal will typically use the newest version, but not necessarily other tools...
16:59:08 <Enigmagic> acowley: does -v3/4/5 give you any additional details?
16:59:14 <oatsadn> rasfar: cool thanks for your help
16:59:21 <rasfar> you're welcome oatsadn
16:59:34 <acowley> Enigmagic: Additional details? Yes! Relevant ones? Not that I've found yet. :(
16:59:59 <acowley> I imagine it's something stupid, but the error message is pretty crappy
17:00:11 <AncientPC> Is there a ccache equivalent for cabal?
17:00:19 <Enigmagic> acowley: strace and look for the last .hi opened, dump it out with --show-iface and check its dependencies?
17:01:00 <Enigmagic> acowley: or you could even just try calling --show-iface on all the .hi's, maybe one is corrupted?
17:01:17 <acowley> Enigmagic: I keep cabal cleaning and rebuilding to no effect
17:01:22 <frerich_> AncientPC: Incidentally, I’m currently working on a ccache equivalent fir MSVC. I suppose that with some refactoring, it could be made to work with ghc, too
17:01:45 <acowley> Enigmagic: So I call ghc --show-iface SomeFile.hi?
17:01:50 <Enigmagic> acowley: yep
17:02:13 <acowley> okay, things are rebuilding at the moment so I'll give that a go in a minute
17:02:40 <AncientPC> frerich_++
17:02:58 <solidus-river> if you have a finite list, whats the easiest way to segment it into X equal-ish parts
17:03:15 <acowley> ?hackage split
17:03:15 <lambdabot> http://hackage.haskell.org/package/split
17:03:39 <acowley> I usually just define it where needed, though
17:06:14 <Enigmagic> solidus-river: take a peek at the examples in https://hackage.haskell.org/package/sbv
17:07:21 <solidus-river> i had no clue this problem was so hard to write, its wierd, i have a list of 45 elements, and i need to split them into as equal a grouping of 7 elements each as i can get
17:07:53 <Enigmagic> solidus-river: you can find a similar sort of problem solved using Z3's python bindings here http://math.stackexchange.com/a/453090
17:08:50 <mmachenry> Anyone know how to take a String and turn it into a Query for the Postgresql simple library? The docs just say that it's not a String to avoid inject bugs and to use overloaded strings. But I'm reading my queries from a file so overloaded strings doesn't work :(
17:12:14 <arityfn> can anyne tell me the font used in the github repository for vim2hs? I know, not haskell related.
17:13:25 <bms1> mmachenry: If a type a supports OverloadedStrings, then it has a function of type String -> a called "fromString"!
17:13:35 <spopejoy> greetings all! Question about Control.Monad.State.Lazy. It defines has  ‘state f = StateT (return . f)’. However the Monad instance has ‘return a = state $ \ s -> (a, s)’. Isn’t this a recursive definition? What am I missing? thanks!
17:13:42 <mmachenry> bms1: Ahhhh
17:14:13 <spopejoy> sorry about ‘defines has’. pick one or the other :)
17:14:49 <rasfar> mmachenry: also, the underlying type is ByteString, so if you're read String from a file, you should be able to use Data.ByteString.Char8.pack
17:15:05 <johnw> shlevy: ping
17:15:16 <rasfar> (but bms1's suggestion is better)
17:15:17 <mmachenry> Awesome, thanks, guys.
17:18:34 <solidus-river> i think i almost got it
17:18:42 <solidus-river> i need to add 1 to the first n elements of a list
17:18:49 <solidus-river> and i'm not sure how to form that
17:19:18 <solidus-river> nvm, got it
17:20:51 <TheKing444> @pl \x y z w -> z y w (x y) (y w)
17:20:51 <lambdabot> join . ((flip . (ap .)) .) . ap (flip . (flip .) . flip id)
17:22:35 <acowley> Enigmagic: The last .hi file opened is 4381 lines :(
17:23:11 <Enigmagic> acowley: but it parses ok i take it?
17:23:25 <acowley> I guess? I can run ghc --show-iface and nothing blows up
17:24:05 <Enigmagic> acowley: does this happen the first time you compile after cleaning or is it only on incremental builds?
17:24:11 <acowley> Also, I think that was the first time I've ever successfully used dtrace
17:24:27 <acowley> Enigmagic: So the workaround I was using earlier today with 7.8.2 is a bit of a mouthful:
17:24:34 <acowley> Enigmagic: I have a cabal file with a lib and a test-suite
17:24:45 <acowley> Enigmagic: The test-suite depends on the lib. When I run cabal test, I get this error.
17:25:12 <acowley> Enigmagic: If I instead include the lib source dir in the test-suite target, I could, earlier today, get the build to succeed by touching a particular source file before compiling
17:25:16 <rasfar> spopejoy: i don't know what version of what source file you're looking at (I see only imports in *.Lazy.hs in latest mtl, and in (latest) *Class.hs things are not quite as you describe.
17:25:24 <acowley> Enigmagic: If I didn't touch that file, I'd get the same error even with the source directory specified
17:25:42 <acowley> I'll check to see if that still works
17:25:46 <Enigmagic> acowley: any chance you can paste the output of the build?
17:26:00 <Enigmagic> i have an idea what's wrong
17:26:10 <acowley> Just the output from trying to run "cabal test"?
17:26:21 <Enigmagic> acowley: whatever you run from a clean build to get it to fail
17:26:40 <spopejoy> rasfar: I’m looking at source found via Hoogle, leading to http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-State-Lazy.html
17:26:44 <acowley> Enigmagic: Do you want verbosity flags?
17:26:56 <acowley> Because without them, it doesn't say very much
17:27:01 <Enigmagic> acowley: nope.. regular build output should be fine
17:27:07 <acowley> Okay
17:28:45 <acowley> (It takes a while)
17:29:00 <Enigmagic> no prob
17:29:10 <AncientPC> Is there a way to get an attribute from a list of records w/o using a lambda?
17:29:20 <AncientPC> list of attributes*
17:29:26 <johnw> AncientPC: lens?
17:29:35 <AncientPC> I'm not cool enough to understand lens
17:29:36 <acowley> Oh shoot, I didn't redirect stderr
17:29:46 <acowley> so the lovely error messages didn't get to my output file
17:29:58 <johnw> pretty much: records ^.. fieldAccessor
17:30:04 <AncientPC> johnw: thx
17:30:09 <johnw> where fieldAccessor was defined for you using makeLenses
17:30:23 <Enigmagic> wouldn't map work?
17:30:29 <johnw> map would need a lambda
17:30:41 <johnw> unless it's just a top-level accessor
17:30:48 <johnw> map fieldAccessor records
17:30:57 <johnw> would also work AncientPC, with a regular field accessor
17:31:14 <johnw> oh, I guess a lambda isn't necessary at all
17:31:17 <johnw> you're right, Enigmagic
17:32:08 <charlie> map { $_ => $_[0] } @_;
17:32:15 <charlie> whoops, that isn’t haskell!
17:32:19 <johnw> hahaha
17:32:20 <solidus-river> whats this warnign trying to tell me
17:32:22 <solidus-river> http://lpaste.net/new
17:32:29 <solidus-river> *warning
17:32:32 <rasfar> spopejoy, okay ... that's Contol.Monad.**Trans**.State.Lazy
17:32:36 <johnw> well, that warning is telling me you need to give me a proper lpaste link
17:33:02 * hackagebot RFC1751 0.2.0.0 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/RFC1751-0.2.0.0 (XenoGenesis)
17:33:08 <acowley> Enigmagic: http://lpaste.net/652386316578717696
17:33:12 <ReinH> johnw: o/
17:33:22 <solidus-river> :P
17:33:28 <solidus-river> http://lpaste.net/108069
17:33:49 <solidus-river> oh god, that error isn't formatted at all
17:34:01 <spopejoy> rasfar: right, sorry. StateT seems to be where the fundamental State functions are defined (state, return, >>=, etc)
17:34:22 <Enigmagic> acowley: not what i was thinking but does it work if you disable profiling?
17:34:34 <glguy> ?type floor
17:34:34 <lambdabot> (RealFrac a, Integral b) => a -> b
17:34:38 <glguy> ?type fromIntegral
17:34:39 <lambdabot> (Num b, Integral a) => a -> b
17:34:51 <glguy> spopejoy: GHC doesn't know what type you wanted it to use here: floor $ fromIntegral minimal_combinations / fromIntegral num_events
17:35:04 <glguy> ?type div
17:35:05 <lambdabot> Integral a => a -> a -> a
17:35:21 <solidus-river> so is it trying to hint that i want to use div?
17:35:42 <glguy> Oh, I'm addressing the wrong 's' nick
17:35:47 <danilo2> hello! what is the name of a library which would allow me to create a repl-like program (something like ghci)? I know there was a library for that but I cannot find any right now :(
17:35:56 <glguy> haskeline?
17:36:18 <glguy> readline is the C-library for that sort of stuff
17:37:00 <solidus-river> oh i get it
17:37:05 <solidus-river> thanks :)
17:38:21 <acowley> Enigmagic: No
17:38:52 <danilo2> glguy: hmm, it could be it! Thank you!
17:39:09 <spopejoy> my goal is to “inline” some simple State monad code all the way down to constructors and bare functions. To do this, I need the definitions of ‘state’ (opposite of ‘runState’) and/or return, but they seem to be defined in terms of each other.
17:39:17 <Enigmagic> acowley: damn well those are the easy things to look for :|
17:39:25 <rasfar> spopejoy: i haven't used monad transformer, someone else will probably help; but it seems like the missing factor is the runStateT, which is where demand will get placed on the recursive lazy bindings [?]
17:39:29 <acowley> Enigmagic: What are the hard things to look for?
17:39:45 <rasfar> *runState
17:40:13 <Enigmagic> acowley: usually if there was a checksum mismatch or something more common it would tell you..
17:40:14 <rasfar> i mean, nothing wrong with recursion; are you saying it looks like a circular definition?
17:40:33 <spopejoy> rasfar: yes, circular
17:40:38 <glguy> spopejoy: runState shouldn't mention the "state" function
17:40:46 <Enigmagic> acowley: seems unusual that it happens on the first compile though
17:41:03 <acowley> Enigmagic: That's when I list the lib as a dependency
17:41:32 <dwcook> spopejoy, what are you looking at, the methods of MonadState?
17:42:15 <dwcook> spopejoy, if so, look at the specific instance you're using instead of at the class.
17:43:00 <spopejoy> dwcook: my code is simply using ‘State Int Int’, (it’s the trivial incrementor example)
17:43:02 <acowley> Enigmagic: If the lib source is included in the test-suite, then the first compile works (and 176 unit tests pass!)
17:43:40 <glguy> spopejoy: Just look at the types: "state :: (s -> (a,s)) -> State s a", and then unfold the definition of State:   "state :: (s -> (s,a)) -> (s -> (s,a))"
17:44:00 <Enigmagic> acowley: if the source is included then it'll most likely only use the in-memory representation of the interface
17:44:14 <Enigmagic> acowley: where if you use the lib it'd have to load the header off disk..
17:44:49 <nezt> Can anyone link me to a good source of example programs that are simple enough to interpret after only reading LYAH
17:45:31 <spopejoy> glguy: where is the source of that for State? I can only find a definition of ‘state’ for StateT
17:45:43 <Enigmagic> acowley: since ghc can apparently parse the interface file, i wonder if something important is being discarded..
17:47:18 <spopejoy> :t state
17:47:19 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
17:47:36 <johnw> in the MonadState, all citizens must be effective
17:48:06 <acowley> Enigmagic: How can I get it to tell me more if that's the case?
17:48:24 <johnw> acowley: hi!  Are you coming to Hac Boston?
17:48:39 <ReinH> johnw: in MonadStte, computation performs you!
17:48:50 <TheKing444> @pl \x y z -> zipWith ($) [x, y, z] [1, (x, z), "Yolo World"]
17:48:50 <lambdabot> ap (flip . (liftM2 (zipWith id) .) . (. ((. return) . (:))) . (.) . (:)) (((1 :) .) . flip flip ["Yolo World"] . ((:) .) . (,))
17:48:52 <acowley> johnw: I haven't made plans yet. I take it you'll be there?
17:49:09 <johnw> I stared deep into the Monad, and became spell >>=
17:49:14 <johnw> acowley: yes!
17:49:18 <johnw> acowley: I would so love to see you again
17:49:31 <ReinH> acowley: please come to Hac Boston
17:49:34 <ReinH> I'll be there too
17:49:35 <TheKing444> @pl \f -> let a = f a in a
17:49:35 <lambdabot> fix
17:49:38 <acowley> Likewise! I'll try to make it happen!
17:49:43 <johnw> awesome
17:49:43 <ReinH> acowley: <3
17:49:51 <rasfar> wretched monad stuff... *leaves fuming*
17:50:07 <rasfar> \part #haskell "byenow"
17:50:08 <TheKing444> Hello, I need help breaking lambda bots point less operator. Can anyone help me?
17:50:19 <mmaruseacph2|umb> I was looking at the atendees page and was worried that there will be only so few people
17:50:21 <acowley> Enigmagic: Can you think why --show-iface would work and I'd get this error when it tries to use the .hi file?
17:50:31 <mmaruseacph2|umb> it seems that there will be more than those listed on http://www.haskell.org/haskellwiki/Hac_Boston/Attendees
17:50:35 <acowley> Enigmagic: It's almost certainly a kind variable, btw
17:50:40 <acowley> Enigmagic: Well, I shouldn't say that
17:50:54 <acowley> Enigmagic: The code I was writing when this started was very DataKind-driven
17:52:42 <Enigmagic> acowley: the error is thrown in a utility function https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcRnMonad.lhs#L1337
17:52:54 <Enigmagic> acowley: .. not super helpful
17:53:53 <spopejoy> Hmm. MonadState class defs have default implementations of ‘get’, ‘put’ and ‘state’, but they refer to each other, implying that instances will need to override at least one.
17:54:15 <Enigmagic> acowley: maybe https://ghc.haskell.org/trac/ghc/ticket/9263 ?
17:54:17 <acowley> Enigmagic: I guess it's nice to see the smoking gun even if we can't see who's pulling the trigger :P
17:54:56 <acowley> Enigmagic: That looks like it!
17:54:57 <spopejoy> The problem is finding which definition is in use …
17:55:20 <TheKing444> acowley, use traces
17:55:21 <acowley> Enigmagic: Except I saw it in 7.8.2
17:55:35 <acowley> TheKing444: I don't follow
17:56:29 <spopejoy> Let’s try this. A simple function ‘myState :: State Int Int’ is defined as ‘myState = return 1’. What does ‘return 1’ expand to?
17:56:33 <acowley> This doesn't seem like something I can avoid, though.
17:56:36 <acowley> Welllll
17:56:46 <acowley> I can be really dirty with the type family instance
17:56:58 <johnw> spopejoy: \s -> (1,s)
17:57:07 <johnw> oh, and a State constructor at the beginning
17:57:37 <TheKing444> @pl \f -> f (foldr $ id (iterate (.f) id)) 4)
17:57:37 <lambdabot> (line 1, column 41):
17:57:37 <lambdabot> unexpected ')'
17:57:37 <lambdabot> expecting variable, "(", operator or end of input
17:57:59 <TheKing444> @pl \f -> f ((foldr $ id (iterate (.f) id)) 4)
17:57:59 <lambdabot> ap id (flip foldr 4 . flip iterate id . flip (.))
17:58:02 <spopejoy> > let t = State (\s -> (1,s))
17:58:03 <lambdabot>  not an expression: ‘let t = State (\s -> (1,s))’
17:58:11 <TheKing444> use @def spopejoy
17:58:17 <shlevy> johnw: pong
17:58:22 <acowley> Actually this is going to murder my dependency sorting
17:58:37 <Enigmagic> acowley: or try on head to make sure it's actually fixed?
17:59:13 <johnw> shlevy: hey!
17:59:14 <acowley> Enigmagic: Yeah
17:59:43 <acowley> Enigmagic: It takes me forever to check against HEAD, though
17:59:55 <TheKing444> > forever take
17:59:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
17:59:56 <lambdabot>    arising from a use of ‘M81331123956698113274326.show_M81331123956698113274...
17:59:56 <lambdabot>  The type variable ‘b0’ is ambiguous
17:59:56 <lambdabot>  Note: there are several potential instances:
17:59:56 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:00:13 <spopejoy> @def t = State (\s -> (1,s))
18:00:13 <lambdabot>  .L.hs:147:5:
18:00:14 <lambdabot>      Not in scope: data constructor ‘State’
18:00:14 <lambdabot>      Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
18:00:18 <TheKing444> > forever take :: [Int[
18:00:19 <lambdabot>  <hint>:1:22:
18:00:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:00:26 <TheKing444> > forever take :: [Int]
18:00:27 <lambdabot>  Couldn't match expected type ‘[a0]’
18:00:27 <lambdabot>              with actual type ‘GHC.Types.Int -> [a1] -> [a1]’
18:00:35 <TheKing444> :t forever
18:00:36 <lambdabot> Monad m => m a -> m b
18:00:46 <spopejoy> So here we go. StateT is the desired constructor, not StateT
18:00:51 <spopejoy> sorry, not State
18:00:52 <TheKing444> > forever take :: Int -> Int
18:00:54 <lambdabot>  <Int -> Int>
18:00:55 <johnw> oops, sorry
18:01:01 <Enigmagic> acowley: the patch spj committed is huge so it's possible it fixed your issue even if it's not exactly the same as the bug richard filed
18:01:10 <ReinH> fyi you can /query lambdabot
18:01:13 <johnw> since it's just a type-wrapper, I compile it away in my head
18:01:35 <spopejoy> StateT’s source has the circular definitions of ‘state’ and ‘return’
18:02:52 <johnw> spopejoy: that other return may not be StateT's return
18:03:01 <johnw> it's probably the m's return
18:05:05 <TheKing444> @src return
18:05:05 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:05:21 <spopejoy> ouch lambdabot!
18:05:45 <TheKing444> @src join
18:05:46 <lambdabot> join x =  x >>= id
18:05:56 <TheKing444> @src fix
18:05:56 <lambdabot> fix f = let x = f x in x
18:06:05 <triliyn> @src [] return
18:06:06 <lambdabot> return x    = [x]
18:06:17 <triliyn> @src Maybe return
18:06:17 <lambdabot> return              = Just
18:06:44 <spopejoy> @src State return
18:06:44 <lambdabot> Source not found. Whoa.
18:07:08 <triliyn> @src StateT return
18:07:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:07:10 <spopejoy> @src state
18:07:10 <lambdabot> Source not found. My brain just exploded
18:07:23 <triliyn> Lambdabot's src command doesn't have everything
18:07:32 <triliyn> I'm not very good at predicting what it knows and what it doesn't
18:07:33 <TheKing444> curse you lambda bot
18:08:00 <TheKing444> @src lambdabot
18:08:01 <lambdabot> Source not found. I feel much better now.
18:08:25 <ReinH> johnw: can't we just pretend the newtype wrappers don't exist? makes everything easier
18:08:46 <TheKing444> @src Identity
18:08:46 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
18:08:48 <geekosaur> @src State
18:08:48 <lambdabot> Source not found. Are you typing with your feet?
18:08:51 <TheKing444> @src Just
18:08:51 <lambdabot> Source not found. Just try something else.
18:08:51 <geekosaur> @src StateT
18:08:51 <lambdabot> Source not found. You speak an infinite deal of nothing.
18:08:52 <geekosaur> bah
18:08:58 <geekosaur> @src Maybe
18:08:58 <lambdabot> data Maybe a = Nothing | Just a
18:09:03 <TheKing444> @src StateT Identity
18:09:03 <lambdabot> Source not found. You type like i drive.
18:09:16 <johnw> ReinH: Cont is certainly way clearer to understand that way
18:09:19 <TheKing444> @src fix id
18:09:19 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
18:09:22 <TheKing444> @src id
18:09:22 <lambdabot> id x = x
18:09:31 <TheKing444> @src ($)
18:09:32 <lambdabot> f $ x = f x
18:09:32 <ReinH> As flip ($)? ;)
18:09:41 <ReinH> Oh, time to put away my electronic devices I guess. Thanks, plane.
18:09:46 <geekosaur> the @src stuff is dumb, `fix id` won't work nor will `StateT Identity`
18:09:51 <Enigmagic> TheKing444: lambdabot also works via private messages.
18:10:02 <TheKing444> I am teaching the masses about lambdabots weaknesses.
18:10:18 <ReinH> I think people are aware...
18:10:19 <geekosaur> if you want source, use hoogle/hayoo
18:11:03 <spopejoy> And you’ll get back to StateT’s circular return/state defs, or StateMonad’s partial definitions, or… my kingdom for the source of State return
18:11:31 <educated_idiot> is there some trick to make it possible to Gen. newtype derive: newtype Inv s = Inv { runInv ∷ ReaderT s (Writer String) Bool } deriving (Monad, MonadReader s) ? I get eta-reduce errors.
18:11:46 <triliyn> State is just an alias for StateT Identity I think
18:12:24 <TheKing444> educated_idiot newtype deriving
18:12:55 <educated_idiot> TheKing444, that problem occurs with GeneralizedNewtypeDeriving
18:13:05 <TheKing444> oh
18:17:02 <Enigmagic> educated_idiot: newtype Inv s a = Inv { runInv :: ReaderT s (Writer String) a } deriving (Monad, MonadReader s)
18:17:15 <stolaruk> Will "replicateM 2 newEmtpyTMVarIO" give me two different TMVars?
18:17:30 <spopejoy> oh, now maybe i get it. State aliases StateT Identity … StateT’s “state” definition is “StateT (return . f)”. ‘return’ there must apply to Identity, not State.
18:18:38 <educated_idiot> Enigmagic: crazy! thanks
18:20:39 <spopejoy> @src Identity return
18:20:39 <lambdabot> return a = Identity a
18:21:16 <rwbarton> spopejoy, yes
18:23:24 <solidus-river> whats the easiest way to turn a module into an executable?
18:25:32 <solidus-river> i know how to build a project with cabal
18:25:41 <solidus-river> but is there a quick and dirty way for testing out a script?
18:25:48 <arancia> Do you mean a module with a main function?
18:25:56 <solidus-river> arancia: aye
18:26:06 <Cale> solidus-river: ghc myProgram.hs
18:26:17 <stolaruk> To test out a "script" just runghc or runhaskell
18:26:23 <Cale> Or you might want -O2 if efficiency matters at all
18:26:40 <solidus-river> efficiency does matter
18:27:44 <solidus-river> hmm that produced program.o and program.hi
18:27:49 <solidus-river> but i cant execute either of them
18:28:22 <triliyn> You might need to pass -o
18:28:25 <rwbarton> sometimes you need -main-is ModuleName
18:28:44 <triliyn> (and an output filename)
18:30:06 <solidus-river> this will be interesting, wonder if i'll get allocation problems
18:31:01 <solidus-river> hmm, process got killed, i guess i overflowed the heap?
18:31:17 <rwbarton> probably the OOM killer killed it
18:31:31 <solidus-river> any solution to that?
18:31:37 <rwbarton> buy more RAM
18:31:42 * solidus-river doesn't know what OOM means
18:31:46 <rwbarton> out of memory
18:31:47 <solidus-river> lol wat? i have 16 gigs
18:31:59 <rwbarton> ok, or use less RAM :)
18:32:12 <solidus-river> heh, not sure how to do that second one, the program is kinda a mess
18:32:23 <rwbarton> Try heap profiling
18:33:20 <solidus-river> hmm, this is the attempt http://lpaste.net/108074
18:33:27 <solidus-river> maybe theres somethign obvously inneficient with it
18:33:32 <solidus-river> i'm goign to try to read up on heap profiling
18:40:01 <solidus-river> thats probably a really convoluted program
18:40:53 <solidus-river> but it should terminate, and i'm suprised that permutations of a list of 45 tuples of ints and a list of ints 7 long eats through 16 gigs of ram
18:43:52 <dfeuer> I can't seem to find a way to get these Ints to unbox.  Just a simple  foo n = foldl' (+) (0::Int) $ scanr (+) 1 [1..n]  and I'm a-strugglin'. I tried with the (7.8.3) library versions of foldl' and scanr, a version of foldl' stolen from the bleeding edge along with my new fusable scanr, and other such combos. I never get the Ints unboxed, if I understand the Core right, with any combo.
18:45:52 <dfeuer> In the case of the fusable thingums, stuff fuses, which is good, but something is still in my way.
18:52:35 <dolio> Where's the scanr definition?
18:52:43 <TheKing444> @src scanr
18:52:43 <lambdabot> scanr _ q0 []     =  [q0]
18:52:43 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
18:52:43 <lambdabot>     where qs@(q:_) = scanr f q0 xs
18:52:49 <dolio> Not that one.
18:52:55 <TheKing444> @src scanr'
18:52:56 <lambdabot> Source not found. My pet ferret can type better than you!
18:53:12 <dolio> lambdabot isn't going to have what I want.
18:53:34 <dfeuer> Oh, hi dolio.
18:53:36 <dfeuer> No, it's not.
18:54:24 <arancia> What definition are you looking for?
18:54:33 <dolio> dfeuer's fusion one.
18:54:36 <dfeuer> dolio, it's in the (only) comment to https://ghc.haskell.org/trac/ghc/ticket/9355
18:55:31 <dolio> Oh, wait.
18:55:32 <dfeuer> (That one's written for ScopedTypeVariables, although I suspect the final version will end up not doing that.)
18:55:44 <dolio> Did you compile the foldl' from head _with_ head GHC?
18:55:59 <dolio> Because just using the head foldl won't do anything.
18:56:06 <dolio> You need an optimization that isn't in 7.8.
18:56:15 <dfeuer> Oh, right.
18:56:17 <dfeuer> BAH>
18:56:34 <dolio> Otherwise you'll just be building closures that might as well be a list.
18:57:16 <dfeuer> *sigh*
18:57:56 <dfeuer> I've been a little too stressed out....
18:58:36 <dfeuer> dolio, can you remind me how to update my HEAD to the latest?
18:58:40 <dfeuer> Not remind.
18:58:41 <dfeuer> Tell me.
18:58:45 <dfeuer> I haven't a gitty clue.
18:59:11 <dolio> Do you already have a checkout?
19:00:02 <dfeuer> Yes.
19:00:09 <dfeuer> I do.
19:00:35 <dolio> Then just 'git pull'
19:00:56 <dolio> Or do you have changes?
19:01:08 <dolio> If you have changes, I don't know the policy.
19:01:42 <dfeuer> I would like to scrap my changes for the moment.
19:02:06 <dolio> Are they commits? Or just working directory changes?
19:02:22 * johnw wonders about the transformative process by which n-dolio becomes dolio
19:02:40 <dolio> It's called, "going home from work."
19:02:48 <johnw> ahhh, that explains it!
19:02:52 <johnw> will you be at Hac Boston?
19:02:57 <dolio> Yes.
19:03:01 <johnw> excellent!
19:03:05 <dfeuer> dolio, just working directory changes.
19:03:16 <dfeuer> But later I will need to understand this git thing properly.
19:03:18 <dolio> Then you can git stash, probably.
19:03:31 <dfeuer> I just git hard reset or whatever.
19:03:33 <dfeuer> For now.
19:03:43 <dolio> Okay, that works, too.
19:04:33 <dfeuer> OK.
19:06:12 <blueclaude> What's the fastest way to get an ordered list of unique integers from a list of integers? Thankss
19:06:30 <TheKing444> :t sort . nub
19:06:31 <lambdabot> Ord a => [a] -> [a]
19:06:45 <dolio> That's not the fastest way. :)
19:06:50 <TheKing444> oh
19:06:56 <blueclaude> Definitely not the fastest
19:07:08 <TheKing444> :t toList . fromList
19:07:09 <lambdabot>     Not in scope: ‘toList’
19:07:09 <lambdabot>     Perhaps you meant one of these:
19:07:09 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
19:07:20 <blueclaude> Using Data.Set?
19:07:22 <TheKing444> :t S.toList . S.fromList
19:07:23 <lambdabot> Ord a => [a] -> [a]
19:07:26 <blueclaude> That’s what I’ve been using
19:07:33 <blueclaude> Is it the fastest, do you think?
19:07:39 <TheKing444> probably, but no sure
19:07:57 <dolio> I seem to recall that benchmarked faster than the one using sort way back.
19:08:02 <dolio> But you should probably test.
19:08:15 <dolio> Another possibility is: map head . group . sort
19:08:17 <TheKing444> you could also remake merge sort, where it deletes duplicates
19:08:35 <blueclaude> :t map head . group . sort
19:08:36 <lambdabot> Ord b => [b] -> [b]
19:08:48 <blueclaude> :t group
19:08:49 <lambdabot> Eq a => [a] -> [[a]]
19:09:09 <benzrf> > group [1, 2, 1, 4]
19:09:10 <lambdabot>  [[1],[2],[1],[4]]
19:09:12 <benzrf> mm
19:09:16 <DeadChannel> I just dropped in to tell you
19:09:17 <benzrf> > group $ sort [1, 2, 1, 4]
19:09:18 <lambdabot>  [[1,1],[2],[4]]
19:09:23 <DeadChannel> that you people are fucking brilliant
19:09:23 <benzrf> DeadChannel: oh?
19:09:26 <DeadChannel> https://gist.github.com/quchen/5280339
19:09:32 <DeadChannel> I laughed so hard
19:09:33 <benzrf> DeadChannel: :-)
19:09:41 <TheKing444> I would definitely recommend looking at merge sort algorithm, where you ignore duplicates.
19:09:41 <benzrf> i only wish id been there for that
19:09:48 <TheKing444> Will be nlog(n)
19:09:49 <blueclaude> Merge sort?
19:10:26 <TheKing444> yea, that is how fast merge sort is
19:10:38 <TheKing444> during the merge step, forget duplicates
19:10:44 <dolio> I think the sort in GHC is kind of large.
19:11:00 <dolio> It'll be annoying to replicate one that removes duplicates.
19:11:07 <TheKing444> not really
19:11:09 <benzrf> DeadChannel: do you do haskell?
19:11:16 <TheKing444> I don't means GHC's merge sort.
19:11:17 <dolio> You can try it, though.
19:11:23 <TheKing444> regular merge sort
19:11:53 <dfeuer> GHC's merge sort is definitely interesting.
19:11:55 <blueclaude> Just tried map head . group . sort, and its definitely a bit faster than S.toList . S.fromList
19:12:06 <dolio> Hmm.
19:12:15 <TheKing444> yeah, I think that will be n*log(n) as well.
19:13:02 <dolio> Yeah, it will.
19:13:19 <dolio> A modified sort might be faster, but it'll certainly be longer.
19:14:56 <dfeuer> This is very frustrating. It seems like I need to go spend a few hours/days learning git before I can hack on GHC libraries. Not in the moooood!
19:15:17 <dolio> And if it's not significantly longer, it might not be faster than the group . sort version.
19:16:29 <Cale> dfeuer: I know the feeling. Git is full of confusing and seemingly arbitrary design decisions.
19:16:53 <shlevy> johnw: BTW I thought about trying to rewrite Source around FoldM as an intellectual exercise but decided to take a nap this afternoon instead :D
19:16:53 <dfeuer> And GHC uses fancy stuff like submodules.
19:17:11 <johnw> shlevy: :)
19:17:35 <johnw> shlevy: I'd certainly be interested in what you discovered, and if it helps expressivity and/or speed
19:17:56 <johnw> i'm going to try the Either optimization we talked about now
19:18:23 <shlevy> johnw: Cool.
19:19:00 <shlevy> Does the Applicative instance for Source have the ame properties of Fold's/
19:19:00 <shlevy> ?
19:19:51 <johnw> I'm not sure
19:19:59 <johnw> I haven't studied FoldM enough to say
19:20:07 <johnw> I will though
19:25:04 <fread22282> does Profunctor replace Arrow?
19:26:16 <benzrf> fread22282: can you implement Arrow methods in terms of Profunctor?
19:26:46 <benzrf> fread22282: i dont think you can compose profunctors
19:26:48 <benzrf> err
19:26:51 <benzrf> profunctorial values
19:26:52 <benzrf> :i
19:28:38 <metaqix> stupid newbie question...
19:29:03 <metaqix> How do you do a putStrLn against a list of FilePaths?
19:29:16 <geekosaur> mapM_ ?
19:29:17 <benzrf> metaqix: well
19:29:23 <TheKing444> :t mapM_
19:29:24 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
19:29:28 <benzrf> geekosaur: i was gonna tutorialize
19:29:32 <TheKing444> :t mapM_ putStrLn
19:29:32 <lambdabot> [String] -> IO ()
19:29:33 <geekosaur> heh
19:29:45 <metaqix> benzrf
19:29:52 <benzrf> ?
19:29:55 <metaqix> would like the tutorial walkthrough.
19:30:01 <benzrf> :-)
19:30:08 <metaqix> :)
19:30:08 <benzrf> metaqix: ok, well
19:30:15 <geekosaur> I was gonna say, nothing stops you from doing it anyway
19:30:16 <benzrf> putStrLn makes an action from a string, right
19:30:21 <benzrf> geekosaur: :p
19:30:31 <metaqix> Yes
19:30:32 <geekosaur> but I do kinda expect the young guns to speak up faster than the old phartes :p
19:30:51 <benzrf> metaqix: if you have a list of strings, you can get a list of actions
19:31:01 <benzrf> metaqix: map, basic stuff
19:31:08 <benzrf> the key point is running a list of actions
19:31:15 <metaqix> I think I've done map successfully.
19:31:22 <benzrf> heh
19:31:26 <benzrf> :t sequence
19:31:27 <lambdabot> Monad m => [m a] -> m [a]
19:31:28 <metaqix> wasn't aware of the actions.
19:31:29 <benzrf> :t sequence_
19:31:29 <lambdabot> Monad m => [m a] -> m ()
19:31:49 <TheKing444> :t map putStrLn
19:31:50 <lambdabot> [String] -> [IO ()]
19:32:00 <TheKing444> :t map putStrLn >>> sequence_
19:32:01 <lambdabot> [String] -> IO ()
19:32:04 <benzrf> metaqix: sequence and sequence_ are functions that you can use for composing a list of actions
19:32:16 <benzrf> metaqix: the former collects the results, the latter ignores them
19:32:26 <benzrf> [m a] -> m [a]
19:32:29 <benzrf> specializes for IO to
19:32:35 <benzrf> [IO a] -> IO [a]
19:32:38 <benzrf> so if you have, say
19:32:43 <benzrf> [getLine, getLine, getLine]
19:32:47 <benzrf> that's [IO String]
19:32:53 <benzrf> sequence it and you get IO [String]
19:33:10 <TheKing444> > sequence [getLine, getLine, getLine]
19:33:12 <lambdabot>  <IO [[Char]]>
19:33:23 <TheKing444> @src String
19:33:23 <lambdabot> type String = [Char]
19:33:33 <benzrf> mapM and mapM_ are helper functions that map a function, then sequence
19:33:36 <benzrf> @src mapM
19:33:36 <lambdabot> mapM f as = sequence (map f as)
19:33:46 <benzrf> @src mapM_
19:33:46 <lambdabot> mapM_ f as = sequence_ (map f as)
19:34:03 <benzrf> metaqix: see if you can figure out how to write sequence yourself
19:34:38 <TheKing444> Here is a hint.
19:34:40 <TheKing444> @src sequence
19:34:41 <lambdabot> sequence []     = return []
19:34:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:34:41 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:34:43 <metaqix> not sure I'm getting it, but I think the gist of it is that I need to sequence the list before I'll be able to do a monolithic IO operation.
19:35:02 <benzrf> TheKing444: hey :[
19:35:02 <dibblego> https://github.com/NICTA/course/blob/master/src/Course/Applicative.hs#L84
19:35:23 <TheKing444> He still has to type it.
19:35:40 <benzrf> metaqix: sequence_ takes a list of actions and gives back an action that runs all of them, one after another
19:35:46 <benzrf> metaqix: it 'sequences' them
19:36:03 <benzrf> metaqix: sequence without a _ does the same, but the result of the new action is a list of the results of the steps
19:36:12 <metaqix> ok
19:36:19 <benzrf> which you want if your actions have results
19:36:28 <benzrf> [that you care about]
19:36:37 <benzrf> here, stare at the type again
19:36:39 <benzrf> :t sequence
19:36:40 <lambdabot> Monad m => [m a] -> m [a]
19:36:48 <Welkin2> :t black = 0 0 0
19:36:49 <lambdabot> parse error on input ‘=’
19:36:57 <Welkin2> :t 0 0 0
19:36:58 <lambdabot> (Num (a -> a1 -> t), Num a1, Num a) => t
19:37:02 <metaqix> ok, that gives me enough to work with for now.  Thanks!
19:37:18 <TheKing444> IO reperesents actions that return results. In haskell, you are only allowed to run one big action.
19:37:31 <TheKing444> sequence allows you to combine your actions into one big action.
19:37:38 <Welkin2> :t (0, 0, 0)
19:37:39 <lambdabot> (Num t2, Num t1, Num t) => (t, t1, t2)
19:37:49 <Welkin2> what would be a good way of encoding RGBA colors?
19:38:08 <Welkin2> when the functions take them as arguments r g b a
19:38:29 <TheKing444> data RGBA = RGBA {red :: Word8, blue :: Word8, green :: Word8, alpha :: Word8}
19:38:48 <TheKing444> Word8 is numbers from 0 to 255
19:39:21 <TheKing444> > [minBound .. maxBound] :: Word8
19:39:22 <lambdabot>  Couldn't match expected type ‘GHC.Word.Word8’
19:39:22 <lambdabot>              with actual type ‘[t0]’
19:39:35 <TheKing444> > [minBound .. maxBound] :: [Word8]
19:39:36 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:39:37 <Welkin2> how would I unpack that into 4 seperate variables?
19:39:50 <TheKing444> pattern matching
19:39:53 <blueclaude> what would be a quick way to find all products of two integers in a list [Int]
19:40:18 <Welkin2> well, the function already exists
19:40:22 <benzrf> @hoogle Enum e => [e]
19:40:24 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
19:40:24 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
19:40:24 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
19:40:27 <Welkin2> I'm just calling it through an api
19:40:35 <TheKing444> :t \x -> (*) <$> x <*> x
19:40:36 <lambdabot> (Applicative f, Num b) => f b -> f b
19:40:38 <benzrf> blueclaude: liftA2
19:41:05 <benzrf> blueclaude: remember, the applicative and monad instances for [] are cartesian-product-basd
19:41:08 <benzrf> *based
19:41:29 <benzrf> blueclaude: if you find yourself wanting to do something cartesian product-y, see if the applicative or monad interfaces for [] help
19:42:29 <blueclaude> benzrf: can you show me an example?
19:42:54 <dibblego> > liftA2 (+) [1,2,3] [30,40,50]
19:42:55 <lambdabot>  [31,41,51,32,42,52,33,43,53]
19:43:11 <blueclaude> Thanks dibblego
19:43:28 <dibblego> ! [1+30,1+40,1+50,2+30,2+40,2+50,3+30,3+40,3+50]
19:44:04 <benzrf> blueclaude: (<*>) on the list applicative is cartesian product, but applying the first item to the second
19:44:04 * bitemyapp squirrels away the example into dialogues.md
19:44:07 <benzrf> that is
19:44:33 <Welkin2> > join Just 4
19:44:34 <lambdabot>  Couldn't match type ‘a0 -> a’ with ‘Data.Maybe.Maybe a0’
19:44:34 <lambdabot>  Expected type: a0 -> a0 -> a
19:44:34 <lambdabot>    Actual type: a0 -> Data.Maybe.Maybe a0
19:44:41 <benzrf> > [(++"foo"), (++"bar")] <*> ["test", "othertest", "more"]
19:44:42 <lambdabot>  ["testfoo","othertestfoo","morefoo","testbar","othertestbar","morebar"]
19:44:44 <Welkin2> > join Just (Just 4)
19:44:45 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe a0 -> a’
19:44:46 <lambdabot>                with ‘Data.Maybe.Maybe (Data.Maybe.Maybe a0)’
19:44:46 <lambdabot>  Expected type: Data.Maybe.Maybe a0 -> Data.Maybe.Maybe a0 -> a
19:44:46 <lambdabot>    Actual type: Data.Maybe.Maybe a0
19:44:46 <lambdabot>                 -> Data.Maybe.Maybe (Data.Maybe.Maybe a0)
19:44:52 <dibblego> > join (Just (Just 4))
19:44:53 <lambdabot>  Just 4
19:45:02 <Welkin2> > join (Just 4)
19:45:04 <lambdabot>  No instance for (GHC.Show.Show a0)
19:45:04 <lambdabot>    arising from a use of ‘M7314323541562182058536.show_M7314323541562182058536’
19:45:04 <lambdabot>  The type variable ‘a0’ is ambiguous
19:45:04 <lambdabot>  Note: there are several potential instances:
19:45:04 <lambdabot>    instance [safe] GHC.Show.Show
19:45:17 <dibblego> > join (Just Nothing)
19:45:18 <Welkin2> > join (Just 4) :: Int
19:45:18 <lambdabot>  Nothing
19:45:19 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:45:19 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
19:45:29 <benzrf> Welkin2: um
19:45:30 <benzrf> :t join
19:45:31 <lambdabot> Monad m => m (m a) -> m a
19:45:41 <TheKing444> :t join . join
19:45:41 <bitemyapp> Welkin2: you need two 'm's
19:45:41 <lambdabot> Monad m => m (m (m a)) -> m a
19:45:43 <benzrf> Welkin2: think for a second
19:45:45 <Welkin2> benzrf: just checking
19:45:46 <benzrf> > join []
19:45:47 <lambdabot>  []
19:45:49 <benzrf> what would that do
19:45:56 <benzrf> if it were 'm a -> a'
19:46:02 <TheKing444> join is to monad has concat is to list
19:46:11 <benzrf> Welkin2: anyway, for your 'w a -> a' needs, pls see Comonad
19:46:29 <dibblego> Maybe is semicomonad, but not a comonad
19:46:51 <bitemyapp> dibblego: wait what, really?
19:46:54 <bitemyapp> I didn't know that.
19:46:55 <dibblego> yes
19:47:01 * bitemyapp looks up new word
19:47:22 <MP2E> extract and duplicate makes a comonad :>
19:47:25 <bitemyapp> dibblego: it's just extend?
19:47:26 <dibblego> @type fmap Just :: Maybe a -> Maybe (Maybe a)
19:47:27 <lambdabot> Maybe a -> Maybe (Maybe a)
19:47:34 * Welkin2 doesn't know about comonad yet
19:47:35 <dibblego> MP2E: and an identity
19:47:36 <bitemyapp> yes, yes it is.
19:47:37 <benzrf> blueclaude: just duplicate, you mean?
19:47:37 <benzrf> >:[
19:47:38 <bitemyapp> wow.
19:47:40 <bitemyapp> TIL
19:47:40 <benzrf> Welkin2
19:47:42 <bitemyapp> dibblego: thanks.
19:47:43 <Welkin2> I really need to get ghci working again
19:47:50 <benzrf> class Functor w => Comonad w where
19:47:53 <dibblego> bitemyapp: [] is also semicomonad but not comonad
19:47:54 <benzrf>   extract :: w a -> a
19:47:57 <TheKing444> :t unSafeCoerce
19:47:57 <lambdabot> Monad m => m a -> a
19:48:01 <benzrf>   duplicate :: w a -> w (w a)
19:48:05 <benzrf> it's monad but flipped
19:48:16 <benzrf> instead of return you have extract, and instead of join you have duplicate
19:48:22 <benzrf> or extend instead of binde
19:48:24 <benzrf> *bind
19:48:29 <Welkin2> interesting
19:48:46 <benzrf> Identity is both a monad AND a comonad!
19:48:50 <benzrf> ( ͡° ͜ʖ ͡°)
19:48:56 <TheKing444> Welkin2 just use unSafeCoerce
19:48:59 <TheKing444> :t unSafeCoerce
19:49:00 <lambdabot> Monad m => m a -> a
19:49:05 <dibblego> [] is a semimonad and semicomonad
19:49:06 <MP2E> and instead of 'bind m f = join $ fmap f m' you have 'extend w f = fmap f $ duplicate w' AFAIK :D
19:49:15 <dibblego> (though, each is unrelated)
19:49:24 <dibblego> er, cosemimonad
19:50:02 <bitemyapp> dibblego: cosemimonad and semicomonad?
19:50:13 <benzrf> > unSafeCoerce (Just 3) :: Int
19:50:13 <lpsmith> hmm, let's say I have a library that has a C dependency
19:50:14 <lambdabot>  *Exception: Prelude.undefined
19:50:15 <dibblego> bitemyapp: "semicomonad" is imprecise
19:50:17 <benzrf> mfw
19:50:31 <bitemyapp> benzrf: ...?
19:50:32 <lpsmith> And I want to statically link that dependency into that library
19:50:34 <edwardk> well, i think its just i tend to put the 'co' in front
19:50:50 <dibblego> edwardk: I think that is slightly more precise
19:50:55 <lpsmith> would anybody know how to do that?
19:51:05 <Welkin2> benzrf: what is mfw?
19:51:10 <TheKing444> Most people just use Cocomonads in production code.
19:51:14 <benzrf> my face when
19:51:18 <benzrf> it's a bad 4chan habit
19:51:22 <bitemyapp> benzrf: why is your face when?
19:51:23 <benzrf> it doesnt even mean anything anymore
19:51:26 <MP2E> Cocomonads? are those like coconuts?
19:51:32 <MP2E> or are they just monads :P
19:51:37 <Hodapp> are you suggesting cocomonads migrate?
19:51:38 <bitemyapp> MP2E: they're just monads.
19:51:41 <benzrf> MP2E: they're hard fuzzy things
19:51:43 <TheKing444> Both answers are right.
19:51:44 <MP2E> lmao
19:51:56 <Welkin2> cocomonads? or comonads?
19:52:04 <MP2E> comonads are what they are talking about :P
19:52:13 <MP2E> and cosemimonads
19:52:16 <TheKing444> Monads are like coconuts. They have stuff inside them, and you can use them to bind monkeys.
19:52:36 <TheKing444> They also isomorphic to nuts, since they are coconuts.
19:52:52 <TheKing444> So monads are like nuts.
19:53:04 <TheKing444> When you crack them, they have edible nuts inside.
19:53:32 <dibblego> @type let duplicate [] = []; duplicate x@(_:t) = x : duplicate t in duplicate
19:53:33 <lambdabot> [t] -> [[t]]
19:54:05 <benzrf> dibblego: extract, though
19:54:10 <dibblego> there isn't one
19:54:16 <dibblego> (there is for NonEmptyList)
19:54:17 <benzrf> my point
19:54:21 <dibblego> mine too
19:54:26 <dibblego> not all semigroups are monoids
19:54:27 <TheKing444> :t unSafeCoerce . unSafeCoerce
19:54:28 <lambdabot> (Monad m1, Monad m) => m1 (m c) -> c
19:56:13 <EvanR> :t unsafeCoerce
19:56:13 <lambdabot>     Not in scope: ‘unsafeCoerce’
19:56:14 <lambdabot>     Perhaps you meant ‘unSafeCoerce’ (line 147)
19:56:43 <TheKing444> :t unSafeCoerce
19:56:43 <lambdabot> Monad m => m a -> a
19:56:47 <TheKing444> :t extract
19:56:48 <lambdabot> (Monoid c, Monad m) => m c -> m Word8
19:57:31 <dibblego> extract :: Comonad f => f a -> a
19:57:57 <TheKing444> @type extract
19:57:58 <lambdabot> (Monoid c, Monad m) => m c -> m Word8
19:58:35 <blueclaude> Why is nub so slow?
19:58:41 <TheKing444> @src nub
19:58:41 <lambdabot> nub = nubBy (==)
19:58:51 <dolio> nub is n^2, because it can only use equality.
19:59:08 <blueclaude> I see. Thanks
19:59:13 <dolio> Well, that's not quite true.
19:59:15 <TheKing444> blueclaude probably because it is based on nubBy I am guessing
19:59:36 <dolio> It's O(n*k) where n is the number of elements you inspect, and k is the number of distinct elements in those n elemnts.
19:59:38 <dolio> Elements, even.
19:59:50 <TheKing444> @src nubBy
19:59:50 <lambdabot> nubBy eq []             =  []
19:59:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:59:57 <dolio> However, with a total order, you can do O(n*log k).
20:00:16 <blueclaude> And with all the same elements, it would be O(n)?
20:00:29 <dolio> Yeah.
20:00:45 <dolio> Oh, I said that wrong. n is the number of elements you demand from the original list by inspecting the output.
20:00:53 <gcganley> :t &&&
20:00:54 <lambdabot> parse error on input ‘&&&’
20:01:01 <TheKing444> :t (&&&)
20:01:02 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:01:06 <TheKing444> :t (>>>)
20:01:07 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
20:01:38 <gcganley> i saw that in random code and it kind of made my head explode
20:01:53 <TheKing444> XD
20:02:04 <TheKing444> It is basically function composition done right.
20:02:18 <TheKing444> :t (>>>) :: (a->b)->(b->c)->(a->c)
20:02:18 <lambdabot> (a -> b) -> (b -> c) -> a -> c
20:02:28 <TheKing444> doesn't that look better than the usual dot?
20:02:35 <dibblego> No.
20:02:43 <gcganley> i like my dot thoug :(
20:02:54 <TheKing444> This is English. We read left to right.
20:02:58 <gcganley> s/thoug/though
20:03:10 <TheKing444> I think it is because functions were invented in a right to left language.
20:03:21 <TheKing444> it should of been (x)f
20:03:22 <c_wraith> TheKing444: which is exactly why . is in the right order.  f(g(x)) == (f . g) x
20:03:40 <TheKing444> then function composition would have been f . g = x(g(f))
20:03:43 <dibblego> well, the reason it is exactly in the right order is because it is not English — it is something else
20:04:06 <dibblego> (.) is round. This is a watermelon.
20:04:10 <gcganley> is Arrow stuff about function composition?
20:04:13 <TheKing444> I mean f .g = ((x)g)f
20:04:25 <copumpkin> apply f to x
20:04:28 <dibblego> gcganley: No, arrows are quite useless actually. See profunctors for improvements.
20:04:28 <TheKing444> Arrows about about generalizing functions
20:04:29 --- mode: copumpkin set -o copumpkin
20:04:30 <gcganley> ive heard it and how its similar to monads but i dont really `get` it
20:05:21 <johnw> dibblego: hello!
20:05:29 <dibblego> johnw!!
20:05:43 <johnw> :)
20:05:48 <johnw> s'arvo
20:05:49 <gcganley> useless means there is no use for them, is that entirely true? in the sense that they are just a nice thought or they have highly specific uses not found in the every day
20:05:54 <gcganley> and hi
20:06:03 <dibblego> gcganley: there are almost zero use-cases for them
20:06:49 <gcganley> i'm a clojure guy and seeing someone implement arrows in clojure sorta blew my mind looking at the stc
20:06:56 <gcganley> s/stc/src
20:07:59 <gcganley> ls -A
20:08:01 <gcganley> opps
20:08:03 <gcganley> sorry
20:08:21 <dfeuer> If anyone wants to come over here and help me figure out enough of the git stuff to start hacking on GHC libs, I will provide pizza and beer and/or Dark 'n' Stormies.
20:08:38 <blueclaude> If anybody is interested in reviewing my haskell answer to a boring math problem: https://gist.github.com/hollingberry/728f9624750f10f56ebb
20:08:58 <zomg> dfeuer: `git clone url` `git checkout -b my-new-branch` hack away? =)
20:09:15 <dfeuer> zomg, what does git checkout -b my-new-branch mean?
20:09:22 <MitchellSalad> kinda cheated there with Data.Numbers.Primes, don't ya think
20:09:44 <dfeuer> I'm a total newbie to git without previous experience with related systems....
20:09:50 <zomg> dfeuer: cloning a repo gets you into the `master` branch, and then when you do `checkout -b foobar`, it creates a new branch based on the current branch called `foobar`
20:10:20 <dfeuer> The "current" branch being at the time the "master" branch?
20:10:25 <zomg> Yep
20:10:44 <dfeuer> OK, so then ... um ... I hack away some, and then what?
20:11:03 <gcganley> im trying to digup the tutorial that explained git to me really well
20:11:08 <benzrf> dfeuer: lrn2git
20:11:11 <zomg> You can use `git add -p` to interactively "stage" your changes
20:11:14 <benzrf> dfeuer: its not that hard
20:11:20 <zomg> then you just do `git commit`
20:11:22 <gcganley> dont get caught up on all the other stuff
20:11:26 <benzrf> dfeuer: you have a directed asymmetric graph of immutable commit values
20:11:33 <gcganley> just worry about clone, pull, and push
20:11:34 <benzrf> dfeuer: then you have mutable names that point to commits
20:11:44 <MitchellSalad> do git rm C:/system32
20:11:45 <benzrf> that's like 75% of git right there
20:11:57 <dfeuer> benzrf, that ... doesn't really help me.
20:12:10 <benzrf> dfeuer: checkout moves the mutable name HEAD to point to the argument
20:12:18 <gcganley> WitchellSalad: Who uses windows....
20:12:18 <MitchellSalad> you mean directed *acyclic* graph?
20:12:18 <zomg> Aye, you don't really need anything else than clone (copy repo), pull (get updates from main repo), push (send changes to main repo), add (stage changes), commit (commit changes)
20:12:19 <dibblego> blueclaude: (putStrLn $ show $ length primeProducts) -> (print . length $ primeProducts)
20:12:20 <benzrf> errrr
20:12:23 <benzrf> acyclic geez
20:12:26 <benzrf> not asymmetric
20:12:29 <dfeuer> MitchellSalad, that is unlikely to do anything on a non-Windows system....
20:12:30 <MitchellSalad> what a noob, lrn2git
20:12:35 <benzrf> ;-;
20:12:47 <benzrf> dfeuer: you know what a directed acyclic graph is, y/n?
20:12:55 <dfeuer> Yes.
20:13:04 <benzrf> dfeuer: commits form one of those.
20:13:11 <benzrf> commits point to their parents, back to the beginning of a repo
20:13:18 <benzrf> branches are really just mutable names that point to some commit
20:13:22 <MitchellSalad> dfeuer: i think git is a bit complicated to get a quick summary over IRC, you should google around a bit
20:13:25 <dfeuer> A "commit" is a "version"?
20:13:30 <dolio> What's the point of explaining how all this is implemented?
20:13:30 <benzrf> a commit is a snapshot of the repo
20:13:37 <dfeuer> OK....
20:13:43 <benzrf> dolio: because the implementation is how you use it
20:13:47 <MitchellSalad> i think benzrf is just trolling you
20:13:48 <dolio> That sucks.
20:13:50 <blueclaude> Reading a few chapters of http://git-scm.com/book helped me
20:14:07 <benzrf> dfeuer: the "current" commit is whatever the ref HEAD currently points to
20:14:10 <johnw> see http://newartisans.com/2008/04/git-from-the-bottom-up/ as well
20:14:12 <dfeuer> I think benzrf got the word "acyclic" wrong and confused the heck out of me.
20:14:13 <benzrf> dfeuer: git checkout just repoints HEAD
20:14:15 <johnw> if you want to understand how it works
20:14:28 <MitchellSalad> yeah, he definitely did get the work "acyclic" wrong, let's not forget
20:14:43 <zomg> I've never tried this, but github has an interactive git guide https://try.github.io/levels/1/challenges/1
20:14:51 <benzrf> dfeuer: so if you have some commit id, like 78a87b787e, then 'git checkout 78a87b787e' will point HEAD to that commit. and also copy the commit's state into your working director
20:14:53 <dfeuer> benzrf, so once I've "hacked away", and, say, fixed one bug, what do I do next?
20:15:01 <benzrf> dfeuer: save the current state as a new commit
20:15:10 <gcganley> there are some good youtube videos on it and some truely horrendous videos on it
20:15:30 <benzrf> use 'git add' to specify which changes should be saved in the next commit. if you just want to save every change, use 'git add -A'
20:15:40 <gcganley> git rm to remove it
20:15:44 <benzrf> then do 'git commit' to make a new commit as a child of your currently checked-out one
20:15:45 <gcganley> git status to check
20:15:59 <MitchellSalad> you guys should take this conversation over to #git :P
20:16:00 <gcganley> git status is a good friend to have
20:16:40 <dfeuer> MitchellSalad, you're a git.
20:17:01 <benzrf> dfeuer: ultimately branching is just having divergent chains of children from the same parent
20:17:04 <benzrf> in your graph
20:17:08 <johnw> yeah, #git is better
20:17:23 <gcganley> so about emacs
20:17:33 <benzrf> gcganley: i use vim
20:17:34 <benzrf> wanna argue
20:17:41 <gcganley> sure
20:17:44 <gcganley> i use both
20:17:51 <MitchellSalad> am i missing some joke here, did dfeuer really not know how to use git?
20:18:01 <dfeuer> I really do not know how to use git.
20:18:05 <MitchellSalad> oh
20:18:06 <dfeuer> I know, it's pathetic.
20:18:12 <gcganley> if i dont have emacs installed i use vi/vim for configureing system configureation files
20:18:16 <MitchellSalad> no, i just wasn't sure if you kept going on to be funny, or something
20:18:26 <benzrf> dfeuer: git's UI is a bit arcane
20:18:40 <gcganley> benzrf: and i started with vim and moved to emacs
20:18:40 <bitemyapp> benzrf: it culls the weak.
20:18:43 <johnw> really, off-topic chatter belongs off channel
20:18:44 <benzrf> dfeuer: but it really just boils down to managing a graph of snapshots and mutable pointers to snapshots
20:18:44 <dfeuer> If I don't have vim installed, I use emacs/edwin to edit system configuration files.
20:19:05 <gcganley> vi is always installed though
20:19:13 <pfn> why would you have emacs but not vim...
20:19:30 <dfeuer> If you're too close to MIT, I imagine that could happen.
20:19:35 <gcganley> what distro has emacs but not vim...
20:20:15 <johnw> benzrf: if you keep ignoring my request to take it off channel, you will be taken off channel
20:20:16 <zomg> Somehow this channel managed to make Git sound even more confusing than Git's own documentation
20:20:21 <zomg> Which do a quite wonderful job of it
20:20:28 <zomg> Linus is not a CLI API designer
20:20:28 <zomg> :D
20:21:39 <mayski> dfeuer: when I was learning git I found this helpful http://marklodato.github.io/visual-git-guide/index-en.html
20:23:00 <mayski> was easier to just see graphs and whatnot because I don't know nothin' bout no big learnin' words
20:23:10 <johnw> mayski: this is off topic
20:23:19 <mayski> yes sorry about that
20:23:21 <johnw> thank you
20:23:28 * hackagebot contravariant 0.6.1 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.6.1 (EdwardKmett)
20:28:22 <gcganley> can anyone point me to a good tutorial for haskell-mode?
20:29:16 <TheKing444> @pl fix
20:29:16 <lambdabot> fix
20:29:39 <copumpkin> @pl \fix -> fix
20:29:39 <lambdabot> id
20:30:40 <TheKing444> @pl \x f -> f . f . f .f . f . f . f . f . f $ x x x x x x x (x+x) (f x)
20:30:40 <lambdabot> ap (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (ap (.) (join (.))))))))) . ap ((.) . ap (join (join (join (join (join (join id)))))) (join (+))) (flip id)
20:30:54 <TheKing444> DX
20:31:08 <gcganley> says the man thats not a fan of dot
20:31:21 <MitchellSalad> gcganley: https://www.youtube.com/watch?v=-QMBVMMmaCU&list=PLlzKKtH5TyE-R-k86na3bLSNaKflFNRZr
20:31:33 <MitchellSalad> found here https://www.youtube.com/watch?v=-QMBVMMmaCU&list=PLlzKKtH5TyE-R-k86na3bLSNaKflFNRZr
20:31:34 <MitchellSalad> oops
20:31:39 <MitchellSalad> http://www.dohaskell.com/tag/Emacs !
20:32:18 <gcganley> so paredit sorta stuff but for haskell?
20:33:01 <MitchellSalad> i'm not sure what paredit is
20:33:28 <johnw> structured-haskell-mode is more like paredit for haskell
20:34:41 <gcganley> i used to program alot of clojure, a dialect of lisp. as you could imagine balancing and keeping all the parens and brakets straight got troublesome. some guy working on emacs lisp got tired of doing it by hand so he made paredit
20:35:32 <Refried__> acowley: is there a non-simple answer?
20:35:50 <Refried__> (consolidating memory for equal values)
20:37:28 <gcganley> :t take
20:37:29 <lambdabot> Int -> [a] -> [a]
20:37:49 <gcganley> :t span
20:37:50 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:39:01 <benzrf> > span (==10) [1..20]
20:39:02 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
20:39:09 <benzrf> ?
20:39:20 <benzrf> > break (==10) [1..20]
20:39:22 <lambdabot>  ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
20:39:43 <johnw> > span (< 10) [1..20]
20:39:44 <lambdabot>  ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
20:40:07 <benzrf> ah
20:42:31 <johnw> shlevy: switching away from Either bought nothing
20:43:17 <johnw> so, since EitherT is the most intuitive rendering, I think I'll stick with that for now
20:43:58 <haywood> [['h'], ['e'], ['y']]
20:44:17 * benzrf calls join on haywood 
20:44:22 <benzrf> errrrrrrrr
20:44:25 <benzrf> applies t
20:44:28 <benzrf> *applies to
20:44:31 <haywood> why does that evaluate to ["h", "e", "y"]
20:45:11 <Exio> '' != ""
20:45:22 <Exio> > join $ [['h'], ['e'], ['y']]
20:45:24 <lambdabot>  "hey"
20:45:25 <haywood> ;ohh
20:45:31 <Exio> > join $ [["h"], ["e"], ["y"]]
20:45:32 <lambdabot>  ["h","e","y"]
20:45:34 <haywood> "h" == ['h']
20:45:46 <johnw> join is concat for lists
20:46:04 <Exio> > join . join [["h"], ["e"], ["y"]]
20:46:06 <lambdabot>  Couldn't match expected type ‘a -> m (m a1)’
20:46:06 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
20:46:09 <Exio> hm
20:46:15 <Exio> > join $ join [["h"], ["e"], ["y"]]
20:46:16 <lambdabot>  "hey"
20:46:22 <haywood> map (\x -> [x]) (show 1234)
20:46:36 <haywood> wtf lambdabot
20:47:09 <Exio> > map (\x -> [x]) (show 1234)
20:47:10 <Exio> :P
20:47:10 <lambdabot>  ["1","2","3","4"]
20:47:16 <haywood> doh
20:47:21 <haywood>  map (\x -> [x]) (show 1234)
20:47:37 <haywood> > map (\x -> [x]) (show 1234)
20:47:38 <lambdabot>  ["1","2","3","4"]
20:48:28 <benzrf> map return (show 1234)
20:48:32 <benzrf> > map return (show 1234)
20:48:34 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Types.Char))
20:48:34 <lambdabot>    arising from a use of ‘M46007930689553659479615.show_M46007930689553659479...
20:48:34 <lambdabot>  The type variable ‘m0’ is ambiguous
20:48:34 <lambdabot>  Note: there are several potential instances:
20:48:34 <lambdabot>    instance [safe] GHC.Show.Show a =>
20:48:38 <benzrf> dang
20:48:44 <haywood> > split . show 1234
20:48:46 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
20:48:46 <lambdabot>                with ‘a -> Data.List.Split.Internals.Splitter a1’
20:48:46 <lambdabot>  Expected type: a -> Data.List.Split.Internals.Splitter a1
20:48:46 <lambdabot>    Actual type: GHC.Base.String
20:48:54 <haywood> > split $ show 1234
20:48:55 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’
20:48:56 <lambdabot>                with ‘Data.List.Split.Internals.Splitter a’
20:48:56 <lambdabot>  Expected type: Data.List.Split.Internals.Splitter a
20:48:56 <lambdabot>    Actual type: GHC.Base.String
20:49:25 <shlevy> johnw: Cool
20:49:27 <haywood> there has to be a better way to express \x -> [x]
20:49:38 <dibblego> haywood: return
20:49:45 <dwcook> haywood, (: []), return
20:49:56 <shlevy> johnw: Do you think it's because laziness is cheap or ghc is optimizing it away?
20:50:04 <dwcook> haywood, though the latter is more general
20:50:07 <Exio> > map (return :: [Char]) (show 1234)
20:50:09 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
20:50:09 <lambdabot>              with actual type ‘a0 -> m0 a0’Couldn't match expected type ‘GHC....
20:50:09 <lambdabot>              with actual type ‘[GHC.Types.Char]’
20:50:11 <Exio> hm
20:50:13 <Exio> ok
20:50:19 <dwcook> Exio, return :: a -> [a]
20:50:31 <dwcook> It's a function, not a list
20:50:39 <haywood> > return 'a'
20:50:40 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Types.Char))
20:50:40 <lambdabot>    arising from a use of ‘M24971522681340484329685.show_M24971522681340484329...
20:50:40 <lambdabot>  The type variable ‘m0’ is ambiguous
20:50:40 <lambdabot>  Note: there are several potential instances:
20:50:40 <lambdabot>    instance [safe] GHC.Show.Show a =>
20:50:42 <Exio> damn, i always forgot that
20:51:18 <dwcook> haywood, return has a more general type: (Monad m) => a -> m a. There it's just saying it doesn't know which m you want.
20:51:27 <dwcook> > return 'a' :: [Char]
20:51:29 <lambdabot>  "a"
20:51:34 <haywood> oh
20:51:39 <haywood> I only know return from IO
20:51:52 <haywood> I'm a haskell noob if you haven't noticed :/
20:51:56 <dwcook> Yeah, IO is another choice of m besides []
20:52:01 <dwcook> Don't worry, you'll pick it up
20:52:04 <haywood> working through cis194
20:52:07 <Exio> IO, [], Maybe...
20:52:14 <Exio> there are a lot of monads!
20:52:49 <Exio> > return 10 :: Maybe Int
20:52:50 <lambdabot>  Just 10
20:52:57 <haywood> oh
20:53:00 <haywood> I'm so dumb
20:53:07 <haywood> (:[]) makes perfect sense
20:53:14 <haywood> 'a':[]
20:53:17 <haywood> > 'a':[]
20:53:19 <lambdabot>  "a"
20:53:50 <dwcook> You're not dumb, you made the connection
20:54:08 <benzrf> :t split
20:54:09 <lambdabot> Splitter a -> [a] -> [[a]]
20:54:22 <Exio> @hoogle Splitter
20:54:24 <lambdabot> package splitter
20:54:28 <benzrf> haywood: return works for monads in general
20:54:43 <haywood> it just packages a value up
20:55:02 <benzrf> haywood: a monad being anything that implements correctly-typed and law-abiding versions of return and (>>=)
20:55:07 <benzrf> @where monad laws
20:55:07 <lambdabot> I know nothing about monad.
20:55:10 <benzrf> @where monadlaws
20:55:10 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
20:55:25 <benzrf> haywood: wait, do you know (>>=)
20:55:27 <joelteon> but since haskell can't prove the laws
20:55:29 <haywood> no
20:55:33 <benzrf> ah
20:55:36 <benzrf> haywood: do you know fmap?
20:55:38 <haywood> currently, I understand functors, and maybe / either
20:55:39 <haywood> ya
20:55:44 <benzrf> kk
20:55:48 <haywood> IO / future
20:55:49 <benzrf> haywood: how about applicatives
20:56:02 <haywood> ehhhh barely
20:56:03 <haywood> like lift?
20:56:07 <benzrf> well
20:56:22 <benzrf> imo a clearer version of applicative is in terms of (**) instead of in terms of (<*>)
20:56:24 <dwcook> haywood, "lift" is a colloquial term to describe what fmap does
20:56:35 <benzrf> (**) :: f a -> f b -> f (a, b)
20:56:40 <johnw> benzrf: why do you think that's clearer?
20:57:01 <benzrf> johnw: it more clearly illustrates that you're taking two functorial values and squishing them together
20:57:08 <johnw> ah
20:57:08 <benzrf> without adding the idea of somehow applying one to the other
20:57:13 <haywood> oh
20:57:29 <benzrf> so for example, you could write
20:57:30 <dwcook> With that (**) and fmap you can implement (<*>)
20:57:32 <haywood> is applicative like a function that un nests things in a compose?
20:57:38 <johnw> the main thing about applicative is that you get to work with two arguments in 'f', unlike either Functor or Monad
20:57:42 <benzrf> haywood: applicative is a typeclass like Functor
20:58:02 <carter>  applicatives are so fascinating
20:58:04 <haywood> ok, well I don't get it currently
20:58:05 <carter> and magic
20:58:11 <MP2E> they really are
20:58:12 <carter> master applicatives
20:58:26 <carter> they are like... one of the most powerful tools for building amazing libs
20:58:26 <MP2E> applicatives are a true gem of functional programming
20:58:30 * hackagebot dns 1.4.1 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.1 (KazuYamamoto)
20:58:39 <carter> they were only discovered in like 2008 ish?
20:58:48 <johnw> yes, applicatives can do a lot more than what most people use them for
20:58:58 <benzrf> applicatives are great
20:58:59 <johnw> see sclv's articles on applicative composition
20:59:09 <johnw> http://comonad.com/reader/2012/abstracting-with-applicatives/
20:59:21 <johnw> those 3 articles are worth reading once a month for a year until they sink in
20:59:21 <benzrf> i mean how often do you really use the power of monads that apps dont give you, outside of writing imperative-ish IO stuff
20:59:38 <johnw> in fact, I'm going to read them all again this week
20:59:39 <carter> data flow graphs with dynamic switching are monadic
21:00:09 <joelteon> things that involve conditionals?
21:00:31 <carter> switching more than conditionals
21:00:45 <benzrf> :t (**)
21:00:46 <lambdabot> Floating a => a -> a -> a
21:00:50 <benzrf> oh, already defined
21:00:50 <benzrf> bah
21:00:55 <benzrf> :t (<,>)
21:00:56 <lambdabot> parse error on input ‘,’
21:00:59 <benzrf> :\
21:01:05 <johnw> :t liftA2 (,)
21:01:05 <lambdabot> Applicative f => f a -> f b -> f (a, b)
21:01:08 <dibblego> fzip
21:01:14 <johnw> :t fzip
21:01:15 <lambdabot>     Not in scope: ‘fzip’
21:01:15 <lambdabot>     Perhaps you meant one of these:
21:01:15 <lambdabot>       ‘flip’ (imported from Data.Function),
21:01:16 <carter> if I gave you a function  evalAndYieldNewComputation:: M a -> (a-> M b)-> M b
21:01:16 <benzrf> dibblego: oh nice
21:01:19 <carter> what would you think it is?
21:01:23 <carter> o/ dibblego
21:01:32 <benzrf> haywood: check this out
21:01:37 <benzrf> haywood: wait, you know typeclasses right
21:01:59 <carter> joelteon: monadic bind is like doing Eval, then constructing a new AST based upon the result of Eval
21:02:01 <haywood> a little, like I read through the LYAH chapter
21:02:02 <dibblego> hi carter
21:02:05 <haywood> it was dense
21:02:06 <haywood> and long
21:02:11 <carter> lambda jam was jammy?
21:02:20 <benzrf> carter: it was jelly-y
21:02:21 <dibblego> carter: yeah rocked
21:02:24 <benzrf> which is like jammy
21:02:32 <carter> woot
21:02:42 <benzrf> @let class Functor f => Applicative' f where pure' :: a -> f a; fzip :: f a -> f b -> f (a, b)
21:02:44 <lambdabot>  Defined.
21:02:45 <benzrf> haywood: ^look @ this
21:03:07 <carter> i think one of the nicer ways to think about monads is  the Eval + return a New expression based upon the result of eval
21:03:09 <carter> perspective
21:03:12 <benzrf> haywood: it's equivalent in power to the real Applicative
21:03:32 <haywood> sorry buddy, I'm lost :D
21:03:39 <carter> benzrf: i don't understand it either :)
21:03:44 <haywood> hehe
21:03:50 <carter> :info Applicative
21:03:55 <haywood> I appreciate all the enthusiasm though!
21:04:04 * benzrf jumps up and down
21:04:08 <carter> haywood: learning haskell is like learning random insanely generic ideas
21:04:11 <carter> it takes effort
21:04:32 <carter> heck, it was years before  i really really understood how to embed computations in type class resolution
21:04:35 <carter> now I use it at parties
21:04:45 <haywood> ya, I'm a javascript programmer by day, and I've imported the ramda library, which allows you to program in a point free style
21:04:47 <dwcook> carter, I want to go to the kind of parties you go to
21:04:50 <MP2E> same
21:04:51 <haywood> and comes with maybe / io / future types
21:04:51 <MP2E> haha
21:04:52 <benzrf> carter: can i come to a party where people do that
21:04:56 <benzrf> dwcook: >:[
21:04:59 <MP2E> applicaparty
21:05:00 <benzrf> u beat me
21:05:05 <dwcook> benzrf, so did MP2E :)
21:05:06 <carter> i be ICFP will be like that
21:05:21 <carter> *bet
21:05:26 <carter> dibblego: will you icfp?
21:05:55 <Exio> abstract parties
21:05:58 <dibblego> carter: it is possible, but not definite at this moment
21:06:00 <carter> dibblego: ooo, with the help of some other folks, 7.10 will have an easy to use prefetch primop
21:06:03 <carter> no pressure
21:06:10 <carter> 7.8 pure prefetch turned out to be unusuable
21:06:15 <benzrf> prefetch?
21:06:33 <carter> "hardware, i will look at that memory location later, start loading it a wee bit before i look there"
21:07:12 <carter> if you can hint to the CPU where you'll read / write a teeny bit before you do that, you can pipeline away the memory latencies
21:07:32 <zereraz> hello people, Maybe is used when returning nothing right
21:07:54 <benzrf> zereraz: that or Either
21:08:04 <zereraz> ok
21:08:05 <carter> Just that Either way, Right on, I hope this answer Left thing clearer
21:08:08 <zereraz> thanks
21:08:12 <carter> *things
21:08:31 <benzrf> carter: ಠ_ಠ
21:08:41 <carter> I am here to PUN the FUN
21:08:46 <carter> FP
21:08:51 <carter> Fun Pun
21:12:49 <xinming_> Hi, Just for confirmation on learning haskell.
21:13:08 <xinming_> in monad  return >>= x >>= y
21:13:19 <johnw> return would need an argument there
21:13:21 <xinming_> Is this the same as something like.
21:13:27 <xinming_> bind(bind(return a, x), y);   ?
21:13:38 <xinming_> I mean  >>=   is an alias to bind
21:13:47 <xinming_> I just try to understand how monad worked.
21:13:54 <carter> :t (>>=)
21:13:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:13:56 <dibblego> where do you see the word bind?
21:14:19 <glguy> I think xinming_ is just asking how to parse the syntax
21:14:30 <xinming_> dibblego: I don't, Just a replacement name for the >>=
21:14:40 <benzrf> @where monadlaws
21:14:40 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
21:15:16 <xinming_> I try to understand how does the    return a >>= x >>= y converted.    for now, I know      return a >> x  is the same as   >>=(return a, x)
21:15:31 <xinming_> But what if we have more than one >>=
21:15:35 <glguy> (return a >>= x >>= y) is ((return a >>= x) >>= y)  is let bind = (>>=) in bind (bind (return a) x) y
21:15:40 <glguy> xinming_ : Is that what you're asking about?
21:15:44 <xinming_> return a >>= x    is the same as  >>=(return a, x);
21:15:56 <carter> lets look at the type for a moment
21:15:57 <xinming_> let me think
21:16:13 <[swift]> xinming_: are you asking about the associativity of >>=?
21:16:14 <xinming_> glguy: almost like that, But I still need more thinking about it.
21:16:20 <carter> xinming_: return a >>= x ======    x a
21:16:27 <carter> where x is some function
21:16:28 <glguy> You're writing function application like you would in C, but Haskell's is a bit different
21:16:29 <carter> right?
21:17:05 <zereraz> This is my current code http://lpaste.net/108080  .  I want to count till a number that user provides. count from 0 to that number, how do I put the termination condition on this recursion.
21:17:14 <xinming_> glguy: Yes, I try to understand how haskell transform a series function calls into other language I learnt.
21:17:32 <xinming_> carter: I understand this, I understand monads laws
21:17:43 <haywood> what does this error mean in GHCI ? No instance for (Show (a0 -> [[Char]]))
21:17:45 <carter> xinming_: cool :) i'm just being pedantic
21:18:08 <carter> xinming_: would you also like to learn how the compiler works? (fun !)
21:18:08 <[swift]> haywood: you're trying to 'show' a function
21:18:10 <benzrf> zereraz: whats the point of a
21:18:23 <carter> i wish we had show instances for finite domain functions
21:18:31 <[swift]> haywood: (which don't support being shown)
21:18:35 <zereraz> benzrf: I used to get error when sending just n
21:18:39 <haywood> let digits n = map (:[]) . show
21:18:46 <Cale> zereraz: There are still tabs in your source. What text editor are you using?
21:18:50 <xinming_> carter: I still didn't reach that level yet. Maybe need a long time to do so. :-)
21:18:57 <Exio> Monad laws come from http://en.wikipedia.org/wiki/Monoid, no?
21:18:58 <zereraz> Cale: sublime text 2
21:19:05 <carter> xinming_: the more you talk with people and get feedback, the faster it happens
21:19:13 <zereraz> Cale: aren't tabs good
21:19:34 <haywood> spaces not tabs
21:19:41 <Cale> no, you don't want physical tab characters in your source files, you want them replaced by spaces
21:19:47 <carter> soft tabs mode
21:19:47 <xinming_> [swift]: After raed those examples, I think I know >>= is left associativity.
21:19:49 <carter> FTW
21:19:56 <benzrf> Exio: no...
21:19:58 <benzrf> monads arent monoids
21:19:59 <Cale> https://www.sublimetext.com/docs/2/indentation.html
21:20:01 <zereraz> but my programs run
21:20:24 <slack1256> What is the default way to handle SIGTERM? Catch AsyncException in Control.Exceptions or use the `installHandlers' function from System.Posix.Signal?
21:20:30 <zereraz> ok I will make it transfer to spaces
21:20:40 <carter> st has a way to fix the spaces
21:20:41 <Cale> zereraz: Yeah, but there are lots of issues that tabs cause because they're rendered differently by different text editors, and they'll be treated by the compiler as aligning to the next multiple of 8 spaces
21:20:42 <Exio> hm
21:20:43 <[swift]> carter: i kinda wish that the prelude included a function more like toString() from other languages. i feel like what prevents a reasonable 'show' for functions is that you are supposed to be able to 'read' it
21:20:43 <carter> i use ST3
21:20:55 <carter> [swift]: in which sense?
21:20:57 <Cale> zereraz: and it matters in Haskell precisely which column things start in
21:21:03 <carter> whats a to string that we dont' currently show?
21:21:11 <carter> you mean "reander the constructors"
21:21:13 <zereraz> Cale: ok
21:21:14 <carter> *render
21:21:15 <carter> ?
21:21:22 <carter> like for a map data structure
21:21:23 <carter> ?
21:21:37 <zereraz> Cale: now how do I make a terminating condition
21:21:43 <[swift]> carter: i'm not sure i understand you, but i mean something like 'show', but with no expectation that you be able to 'read' it back and get the same value
21:21:46 <Cale> zereraz: Anyway, your actual question, how about adding a second parameter to the count function?
21:21:55 <carter> [swift]: oh, people do that ALL the time
21:21:57 <carter> i do :)
21:22:05 <Cale> zereraz: There's the maximum value, and then the current value you need to keep track of
21:22:05 <zereraz> Cale: damn it
21:22:09 <zereraz> thansk
21:22:12 <carter> for my matrix lib my default show is going to piss people off :)
21:22:21 <[swift]> carter: i know, i do too =) in theory you shouldn't, i guess (though i suppose if you don't support 'Read' it doesn't really matter)
21:22:21 <zereraz> Cale: It never occured to me
21:22:31 <benzrf> carter: is it lines of falling code
21:22:33 <carter> eh, i think its totally ok to break the contract
21:22:37 <carter> benzrf: ?
21:22:37 <zereraz> Cale: I am not used to this , thanks allot
21:22:41 <Cale> zereraz: no problem
21:22:53 <zereraz> 1 more thing do I need a?
21:23:16 <[swift]> carter: what i was thinking is that you break the contract, and i break the contract, but maybe the people deciding how 'show' should work for functions didn't want to break the contract
21:23:32 <carter> [swift]: you can totes write your own instances
21:23:44 <carter> [swift]: but you have to ahve a legal Enum
21:23:49 <carter> to print a function on a finite domain
21:23:56 <carter> heck, thatsnot even possible in most langauge
21:24:12 <joelteon> hi, can I use generics to traverse a haskell-src-exts Module and operate on all the Exps inside?
21:24:12 <benzrf> :t enumMax
21:24:14 <lambdabot> Not in scope: ‘enumMax’
21:24:14 <carter> theres no sane to string for functions in python or js or c++ or whatever
21:24:15 <benzrf> wait
21:24:27 <ldrancer> oh i thought this was micheal knight
21:24:28 <benzrf> @hoogle Enum e => e
21:24:29 <lambdabot> Prelude pred :: Enum a => a -> a
21:24:29 <lambdabot> Prelude succ :: Enum a => a -> a
21:24:29 <lambdabot> Prelude toEnum :: Enum a => Int -> a
21:24:42 <carter> benzrf: you need bounded + enum
21:24:47 <[swift]> carter: i'd prefer to print *something* useful for any function, which is difficult in Haskell
21:24:52 <benzrf> oh
21:24:55 <benzrf> @hoogle Bounded e => e
21:24:56 <carter> [swift]: you could totes
21:24:56 <lambdabot> Prelude maxBound :: Bounded a => a
21:24:56 <lambdabot> Prelude minBound :: Bounded a => a
21:24:56 <lambdabot> Prelude undefined :: a
21:24:59 <benzrf> :-o
21:24:59 <carter> but tis not very useful
21:25:00 <[swift]> carter: js does indeed have a toString for functions
21:25:06 <carter> [swift]: but does it WORK
21:25:16 <carter> last I checked, not usefully
21:25:22 <[swift]> carter: it gives you back their source code, which you can then eval, so i suppose it is theoretically useful
21:25:24 <carter> scheme prints <procedur 324324324>
21:25:31 <carter> kinda stuff
21:25:33 <carter> or at least racket does
21:25:41 <carter> [swift]: problem is that thats not true in general
21:25:41 <[swift]> carter: yeah, that is pretty useless
21:25:55 <carter> i'm sure it kinda works
21:26:06 <carter> but i promise you its history  that they don't just trash it
21:26:18 <carter> closures close
21:26:37 <carter> if you could actually print the source back out, ... well actually that cant work in general
21:26:51 <carter> ermmm
21:26:56 <[swift]> carter: it does work, although you're right that closures make eval'ing not very useful
21:27:59 <carter> well, i was thinking that to string on a  complicated  runtime closure may not give you a sane notion of "source"
21:28:13 <ldrancer> godamn
21:28:17 <haywood> how can I get rid of the n arg here?
21:28:17 <benzrf> @let instance (Bounded a, Enum a, Show a, Show b) => Show (a -> b) where show f = let {is = [minBound..maxBound]; format i o = show i ++ " -> " show o} in unlines (zipWith format is (map f is))
21:28:18 <lambdabot>  .L.hs:158:10:
21:28:18 <lambdabot>      Duplicate instance declarations:
21:28:18 <lambdabot>        instance [safe] (Bounded a, Enum a, Show a, Show b) =>
21:28:18 <lambdabot>                        Show (a -> b)
21:28:18 <lambdabot>          -- Defined at .L.hs:158:10
21:28:19 <haywood> toDigits n = map (:[]) $ show n
21:28:24 <benzrf> man!
21:28:24 <ldrancer> bitcoin people are spyware makers working for big companies trying to steal your money
21:28:25 <carter> [swift]: or at least, that sort of reflection will totally mess with JIT fun
21:28:28 <ruzu> herro friends; i was curious, are there any haskell based database systems? graph/document/relational/whatever?
21:28:40 <lfairy> ruzu: acid-state
21:28:41 <carter> ruzu: some yes, not many (yet)
21:28:57 <carter> ruzu: i've kinda got one, but just for matrices
21:29:06 <ldrancer> bitcoin channel just banned me for saying that
21:29:13 <ldrancer> and around 255 other people
21:29:23 <ldrancer> why dont you guys just write 0's
21:29:32 <carter> ldrancer: empathhies, but lets talk about haskell
21:29:33 <carter> :)
21:29:55 <lfairy> > let toDigits = map (:[]) . show in toDigits 12345
21:29:56 <lambdabot>  ["1","2","3","4","5"]
21:29:57 <ldrancer> fuck computers your not allowed to have one, bitcoin is going to rule the world
21:29:58 <carter> ruzu:  i've actually been planning out doing a high performance KV db in haskell based upon my matrix tech
21:30:21 <ldrancer> your programs arent nothing compared to fiat currencies in digital format
21:30:22 <carter> ldrancer: do you write gpu code for your bit coin mining?
21:30:27 <carter> or whatever
21:30:34 <ldrancer> what is that spyware?
21:30:44 <carter> haskell has some nice tools for writing doe to runon gpus
21:30:47 <ldrancer> seriously
21:30:54 <ldrancer> does?
21:30:57 <carter> gpus are great for making pretty 3 d graphics
21:30:57 <ldrancer> like deer?
21:31:00 <ruzu> i've been tinkering with haskell for a few days and it's still something of an enigma wrapped in a riddle, but i'm slowly starting to get into it.  it's so hard to de-imperatize :3
21:31:03 <lfairy> oh yes, accelerate is fascinating
21:31:06 <haywood> lfairy: what does 'in toDigits' do?
21:31:15 <haywood> i got an error trying to do what you did
21:31:17 <ldrancer> so my computer is a rhinocerous?  no its not
21:31:21 <haywood> but sans 'in toDigits...'
21:31:23 <lfairy> haywood: let ... in ... -- this declares a local variable
21:31:31 <swgillespie> ruzu: i saw on good quote on reddit today
21:31:36 <ldrancer> its a scam
21:31:39 <swgillespie> "i started learning haskell 6 years ago... I'll let you know when I finish"
21:31:39 <carter> dibblego: is ldrancer  being out of line?
21:31:40 <swgillespie> ^^
21:31:45 <ldrancer> bitspywre
21:31:45 <carter> swgillespie: :)
21:31:46 <haywood> is that a ghci only thing/
21:31:47 <dibblego> carter: yes
21:31:48 <ldrancer> im on compouter topic
21:31:59 <ldrancer> hmph
21:32:01 <haywood> in my file i can leave off the in
21:32:01 <carter> bring on the ops powers :)
21:32:02 <ldrancer> you dont understand nothing
21:32:12 <dibblego> ldrancer: this channel is for haskell discussion. Please take this discussion elsewhere.
21:32:29 <ldrancer> this is computers im on a computer
21:32:37 <ldrancer> and my bitcoin is more better than you
21:32:37 <dibblego> no, this is not computers
21:32:39 <ldrancer> im on topic
21:32:47 <ldrancer> what is it ? gambling?
21:32:51 <lfairy> haywood: http://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let
21:32:52 <dibblego> please take your discussion to #computerz
21:32:53 <carter> ldrancer: if you want to learn how to write software, we can help you
21:33:03 <carter> but otherwise, your current behavior aint ok
21:33:09 <dibblego> ldrancer: this is for haskell programming, not computers
21:33:21 <ldrancer> aint he sayz
21:33:25 <ldrancer> whats the difference
21:33:33 <benzrf> ldrancer: here, read this
21:33:33 <ldrancer> computer and haskell
21:33:35 <benzrf> @where lyah
21:33:35 <lambdabot> http://www.learnyouahaskell.com/
21:33:38 <zomg> I think this video is related to this discussion: https://www.youtube.com/watch?v=sCNrK-n68CM
21:33:41 <zomg> *cough*
21:33:52 <ldrancer> is it done on a computer or am i going to have to beat the living fuck out of all of you?
21:33:54 <dwcook> zomg, I had that going on my head in fact
21:33:58 <zomg> haha =)
21:33:59 <dwcook> s/on/in/
21:34:03 <benzrf> ldrancer: jesus youre a cruddy troll
21:34:13 <carter> its kinda cute
21:34:17 <ldrancer> if its on a computer, im on topoic and you guys dont know nothing.
21:34:18 <benzrf> ldrancer: tip: learn enough haskell to partially know what youre talking about
21:34:25 <benzrf> then try concern trolling
21:34:25 <dibblego> ldrancer: this will stop now, last warning
21:34:27 <benzrf> it's the next step
21:34:28 <ldrancer> im on a com;ptuer aint i?
21:34:35 <zomg> what's a comp;tuer
21:34:41 <ldrancer> aint?
21:34:45 <ldrancer> comp
21:34:55 <ldrancer> you cant ask that i just did
21:34:58 <ruzu> ldrancer: how did you get on irc? i'm curious :)
21:35:04 <ldrancer> using computers
21:35:06 <carter> you can design CPUS in haskell with Clash now i think
21:35:13 <ldrancer> a computer.
21:35:16 <carter> though i don't think Christian's done that yet
21:35:18 <ldrancer> yea im goign to design some food
21:35:25 <ldrancer> and some girl
21:35:28 <dibblego> ldrancer: ok good idea, bye
21:35:29 <ldrancer> see you losers later bye
21:35:35 <dibblego> bye
21:35:42 <AncientPC> What's the best way to map a function on all lines within a file?
21:35:48 <carter> AncientPC: lines
21:35:49 <carter> :t lines
21:35:51 <lambdabot> String -> [String]
21:35:51 <dibblego> \f -> map f . lines
21:36:05 <carter> zomg: that video is kinda soothing
21:36:14 <dwcook> > map reverse (lines "foo\nbar\nbaz")
21:36:15 <lambdabot>  ["oof","rab","zab"]
21:36:23 <dwcook> > unlines (map reverse (lines "foo\nbar\nbaz"))
21:36:25 <lambdabot>  "oof\nrab\nzab\n"
21:36:29 <mayski> oo clash looks nice
21:36:30 <slack1256> What is the default way to handle SIGTERM? Catch AsyncException in Control.Exceptions or use the `installHandlers' function from System.Posix.Signal?
21:36:31 <slack1256> [00:14] <zereraz> ok I will make it transfer to spaces
21:36:43 <slack1256> ups, I repasted more than what I intended
21:37:00 <slack1256> But the first line is valid, that is what I want to know :-)
21:37:22 <carter> dibblego: woah, no @ powers were needed!
21:37:32 <AncientPC> carter: I guess I'm actually looking for FilePath -> [String]
21:37:44 <carter> AncientPC: readFile  then lines :)
21:37:53 <carter> AncientPC: NB, use Data.Text instead plsease
21:37:54 <carter> you'll be happier
21:37:55 <AncientPC> withFile?
21:37:59 <AncientPC> NB?
21:38:02 <carter> note well
21:38:28 <supki> slack1256: you will need to install your own handler if you don't want the RTS to terminate your program on second ^C
21:38:36 <AncientPC> I'm trying to parse 6GB of log data...
21:38:47 <ruzu> one thing that bugs me (unless I misunderstand) is how random libraries use "official stdlib-looking" package naming, like Data.CSV.Conduit
21:38:54 <supki> slack1256: otherwise just catch UserInterrupt
21:39:37 <supki> oh wait
21:39:37 <ThisIsPie> Do you guys have any small project ideas for learning Haskell? I used it in the past for my Numerical Analysis class but now I'm doing web development (C#/Javascript). I can never come up with anything for a side project
21:40:04 <orion> ThisIsPie: You could play with happstack.
21:40:06 <carter> AncientPC: you may wanna do something incremetnal
21:40:09 <swgillespie> ThisIsPie: I'm pretty new to haskell too but the first thing I did was make a brainfuck interpreter
21:40:18 <carter> AncientPC: like an incremental get line
21:40:28 <slack1256> Oh, Okay. I still got a problem to which is the function that will Raise the UserInterrupt exception.
21:40:31 <dwcook> swgillespie, a classic first project, that
21:40:41 <swgillespie> it's a great project ^^
21:41:02 <dwcook> Eventually you'll be able to progress to Malbolge
21:41:06 <zomg> ThisIsPie: if you do web dev, perhaps it would be a fun idea to investigate some of the haskell web related DSLs, like Clay, Fay, Haste, and such
21:41:51 <ThisIsPie> I've never heard of any of these (except Brainfuck). Thanks for the pointers guys
21:42:07 <supki> slack1256: I don't think there's any special treatment for SIGTERM from the RTS, so custom handler should work
21:42:32 <slack1256> Nice, thanks supki custom handler it is!
21:42:58 <swgillespie> brainfuck is interesting because you can't take a c/c++ approach and allocate a chunk of memory and move a pointer around in it
21:43:06 <swgillespie> you get to lazily manipulate an infinite tape :)
21:44:34 <ThisIsPie> That sounds pretty cool but a Brainfuck interpreter may be out of my depth. Of course I'll never learn if I don't try
21:45:18 <swgillespie> ThisIsPie: this is great resource: https://github.com/quchen/articles/blob/master/write_yourself_a_brainfuck.md
21:45:48 <swgillespie> when I did it i used this as a loose reference for when i got stuck
21:46:27 <ThisIsPie> Thanks. Are red messages private or visible to all just in reply to a particular user?
21:49:04 <zereraz> I changed my indentation to space and made all tabs 2 spaces, I am still getting an error http://lpaste.net/108080
21:49:19 <zomg> ThisIsPie: all messages posted to the channel (eg. #haskell) are visible to all users on the channel. Private messages can be sent directly between users, but most irc clients will display them in their own window
21:49:31 <dwcook> zereraz, line 6 is indented too far I believe
21:49:42 <zereraz> too far?
21:49:45 <Cale> zereraz: your if/then/else expression is missing an else
21:49:47 <zereraz> 4 spaces
21:49:59 <rwbarton> also lines 7-11 are generally nonsense
21:49:59 <peddie> ThisIsPie: it's probably your client highlighting messages with your nickname in them
21:50:05 <zereraz> Cale: but the error I am getting is for mismatch brackets
21:50:08 <zereraz> I will add the else
21:50:21 <ThisIsPie> peddie: Ok, that makes sense.
21:50:24 <ThisIsPie> Thanks everybody
21:50:33 <Cale> zereraz: Also, the count is indented too far and (0 a) will be a type error.
21:50:35 <zereraz> rwbarton: what do you mean
21:50:38 <rwbarton> but yes, line 6 is supposed to be in the do block and not in the let
21:50:54 <dwcook> zereraz, though setting a to n isn't very useful since n is in scope where a would be used
21:50:57 <rwbarton> so it needs to be indented the same amount as the lines in the do block
21:51:10 <Cale> zereraz: In addition to that, your type signature for count is incorrect and should probably be something like  Int -> Int -> IO ()
21:51:25 <zereraz> yeah I added print later
21:51:29 <dwcook> zereraz, (count n+1) probably doesn't do what you think. I think you want count (n+1)
21:51:30 <Cale> zereraz: and the line  count m m = 0  will be a type error
21:51:37 <zereraz> ok , lots of problems, I'll fix and see if it works
21:51:46 <zereraz> Cale: why?
21:52:09 <Cale> Oh, also, print ((count n + 1) m) is several type errors at once
21:52:17 <zereraz> dwcook: I wanted count (n+1) m
21:52:22 <rwbarton> line 9 is fine though :)
21:52:33 <dwcook> zereraz, exactly
21:52:52 <Cale> zereraz: you probably want something like  do print n; count (n+1) m
21:53:16 <zereraz> ok , i'll fix everything
21:53:27 <zereraz> thanks everyone
21:54:03 <zereraz> and 1 more thing, in the else I want to end so I do return 0 right
21:54:14 <dwcook> zereraz, return doesn't make things end
21:54:23 <dwcook> It's not like the return in other languages
21:54:32 <zereraz> dwcook: wow , I didn't know that
21:54:43 <zereraz> dwcook: whats the difference
21:54:46 <dwcook> I daresay it's unrelated
21:55:08 <dwcook> zereraz, do you know what a typeclass is?
21:55:17 <ruzu> so, what's the over/under on writing a full dwarf fortress clone in haskell? :P
21:55:30 <dwcook> ruzu, that would be a formidable task in any language
21:55:53 <swgillespie> would anyone recommend any particular resources on arrows?
21:56:07 <zereraz> dwcook: type class are the bigger versions of types, like they are more general
21:56:22 <zereraz> like Num
21:56:26 <zereraz> I think
21:56:37 <dwcook> zereraz, hmm, saying it that way doesn't quite convince me you've got it
21:56:53 <Cale> zereraz: return v is an IO action which does nothing, but produces v as its result when executed
21:57:27 <dwcook> zereraz, let's leave that aside for now, but I'd suggest reviewing it later. What Cale said is accurate
21:57:59 <dwcook> zereraz, return is a little more general than that but suffice to say you most likely won't need it where you suggested
21:58:01 <zereraz> is v special here
21:58:11 <dwcook> No, v is any value whatsoever
21:58:19 <zereraz> oh ok
21:58:23 <zereraz> so it prints
21:58:26 <zereraz> what I return
21:58:30 <zereraz> as its IO?
21:58:39 <dwcook> No, printing would be doing "something"
21:58:46 <zereraz> do all IO get printed?
21:58:52 <AncientPC> carter: thx
21:58:54 <zereraz> ah
21:58:58 <zereraz> yes
21:59:01 <carter> AncientPC: so you basically do a fold
21:59:04 <zereraz> and can I return string
21:59:08 <carter> to incremental load and porcess
21:59:10 <carter> *proces
21:59:24 <dwcook> zereraz, let's phrase it this way: do { y <- return x ; f y } is exactly the same as do { f x }. Does that help?
22:00:03 <zereraz> even though I have used this <- , but I don't understand <-
22:00:12 <ruzu> as a hobby project i'm thinking about developing a "spacial database" (3d principally but ostensibly n-d) server; ideally serving a lot of concurrent query requests; is this a problem domain haskell would make sense in?
22:00:13 <zereraz> does it mean apply return x to y
22:00:38 <dwcook> zereraz, no, it means to bind the "result" of the computation return x to the variable y.
22:00:51 <dwcook> zereraz, as such it will be available later in the do block for manipulation.
22:01:07 <zereraz> what will be available?
22:01:12 <zereraz> the x
22:01:13 <dwcook> so if you have do { x <- someAction ; … } and someAction has type IO String, then x will be a String.
22:01:29 <dwcook> Make sense?
22:01:47 <zereraz> x will be string or has to eb
22:01:49 <zereraz> be*
22:02:01 <dwcook> I don't understand your question.
22:02:10 <zereraz> ok I didn't read the last line
22:02:16 <zereraz> ok got it
22:02:42 <zereraz> IO String when <- then they apply string
22:03:04 <dwcook> zereraz, anyway, normally writing do { y <- return x ; f y } is useless, you'd just write the other thing, do { f x }. I only wrote that to show you in what sense return "does nothing".
22:03:33 <zereraz> oh , that way yes, it is not terminating
22:03:37 <dwcook> zereraz, if you have any doubts please feel free to voice them.
22:03:48 <dwcook> Right, it doesn't terminate the computation as a whole
22:04:03 <zereraz> I will keep asking here, I'll first try to run my counting program
22:04:28 <zereraz> and 1 more thing, why is count m m =0 wrong
22:04:37 <dwcook> Out of curiosity, have you read any beginners' reading on Haskell?
22:04:39 <zereraz> I wanted it to be the terminating condition
22:05:10 <zereraz> dwcook: I am never able to just sit and read a book but I continiously read lots of haskell where ever I get it
22:05:10 <dwcook> zereraz, as a guess, are you trying to constrain those two arguments to have the same value? Well that'd be done a different way
22:05:24 <zereraz> dwcook: real world haskell and little bit of learnyouhaskell
22:05:30 <dwcook> count m n | m == n = 0
22:05:48 <zereraz> dwcook: I want the recursion to end when they have same values
22:05:54 <dwcook> That can be read "the count of m and n such that m is equal to n is 0"
22:05:56 <zereraz> dwcook: like when 0 reaches m
22:06:11 <zereraz> I know but I wanted to do it this way
22:06:23 <dwcook> You can't, parameters must have distinct identifiers
22:06:25 <zereraz> so you put | on the left side
22:06:30 <zereraz> why
22:06:52 <zereraz> I thought we'd have to use if else
22:07:09 <ruuns> hi :]
22:07:09 <dwcook> Function application doesn't do that sort of unification, it just assigns values to parameters, and that'd be like saying two different values have the same name.
22:07:22 <dwcook> two *potentially* different
22:07:41 <zereraz> ok but how can you do computation on left side
22:07:47 <dwcook> What do you mean?
22:07:56 <zereraz> you did | m==n
22:08:05 <zereraz> left of =
22:08:13 <zereraz> lhs of function
22:08:14 <dwcook> Ah, that's called a guard
22:08:25 <zereraz> I know its used in if else
22:08:28 <dwcook> That makes that particular case of the function fail if the guard is False
22:08:29 <zereraz> as alias I think
22:08:39 <dwcook> So it tries the next case if the guard is False
22:09:05 <zereraz> so we can evaluate any parameters on the left side
22:09:06 <dwcook> Hmm, not sure what you mean about if else. There is guard syntax for that but it's not standard.
22:09:09 <zereraz> using guard
22:09:22 <zereraz> yeah the guard syntax for if else
22:09:50 <dwcook> The guard does let you do an arbitrary computation to determine if you want to use that particular clause of the function
22:09:55 <zereraz> any other way of saying that parameters are same?
22:10:04 <zereraz> ok
22:10:14 <zereraz> only comparisons
22:10:18 <dwcook> I can't think of a way besides what I said that wouldn't just simplify to what I said
22:10:34 <dwcook> or be equivalent to
22:10:55 <zereraz> this is new to me, so I am not sure how it works but I will try this
22:11:22 <dwcook> Trying code out is one of the best ways to learn :)
22:11:45 <zereraz> dwcook: yeah, also do you know any video tutorials
22:12:00 <zereraz> why does haskell have almost no video tutorials
22:12:22 <ruzu> videos have too many side effects :3
22:12:28 <zereraz> haha
22:12:30 <ruzu> no video monad yet
22:12:33 <MP2E> haha
22:12:40 <MP2E> video.mnd ?
22:12:46 <MP2E> proven to be functionally pure!
22:12:47 <zereraz> I am used to learning with video tutorials
22:12:48 <ruuns> avoid popularity at all cost, ... no videos
22:13:04 <zereraz> haskell is getting quite popular
22:14:22 <swgillespie> I feel like a lot of people are getting tired of chasing down bugs that could be caught by stronger type systems
22:14:41 <swgillespie> and then oh! haskell! it catches all the dumb stuff I do!
22:16:07 <zereraz> can I write return Maybe?
22:16:23 <zereraz> ok I can't
22:16:29 <swgillespie> what do you want to do?
22:16:37 <zereraz> return nothing
22:16:48 <zereraz> count :: Int -> Int -> Maybe
22:16:52 <zereraz> my type signature
22:17:39 <dwcook> zereraz, that type's ill-formed
22:17:42 <swgillespie> just "Maybe" isn't a type like that
22:17:47 <dwcook> zereraz, you want to return an optional… what?
22:18:02 <swgillespie> you can have Maybe Int, which is either Nothing or Just (an integer), or Maybe [Char], but not just Maybe
22:18:05 <zereraz> dwcook: this return is in the end, like when counting is done
22:18:26 <zereraz> or I'll change Maybe to Int and return Int
22:18:31 <dwcook> zereraz, okay, fine, but what's the ultimate value? It'd be able to be Nothing or… what?
22:18:48 <dwcook> zereraz, or an Int?
22:18:57 <zereraz> ultimate value?
22:19:02 <zereraz> I am printing all numbers
22:19:03 <dwcook> The result, I should say
22:19:13 <dwcook> Not in that function you aren't
22:19:20 <dwcook> Oh I see
22:19:34 <dwcook> Well print has an IO type, so you need to reflect that in the result of the function
22:19:56 <dwcook> @type print
22:19:56 <lambdabot> Show a => a -> IO ()
22:19:58 <zereraz> the print is happening in the if statement
22:20:11 <zereraz> but what about the else, i.e when counting is done
22:20:26 <dwcook> Maybe describing what the function should do would help.
22:20:46 <zereraz> I'll try and come back
22:20:55 <zereraz> and then paste the current code
22:20:57 <dwcook> Okay.
22:22:15 <solidus-river> so how do i reason about the memory usage of this program or why its so slow?
22:22:23 <solidus-river> http://lpaste.net/108079
22:22:38 <solidus-river> i know its computationally intensive but i dont see why it should be memory intensive
22:22:58 <solidus-river> i mean its going to have to do all combinations of permutations of 7 elements and permutaions of 45 elements
22:23:05 <solidus-river> and that shoudl be slow but not memory intensive
22:23:34 <zereraz> ok not able to do it http://lpaste.net/108084
22:23:38 * hackagebot cab 0.2.11 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.11 (KazuYamamoto)
22:23:40 <AncientPC> I have two records with the same attribute name and so Haskell complains about ambiguous occurence. How do I fix that error?
22:24:19 <ruuns> all possible permutations of a 45 elements?
22:24:26 <ruuns> -a
22:24:42 <Cale> zereraz: (count (n+1) m) :: IO Int, while print wants a String as its argument
22:24:46 <solidus-river> so a list of elements 45 elements long, all those permutations
22:24:51 <solidus-river> but it shouldnt need all those in memory
22:25:02 <solidus-river> right now it kills itself outright
22:25:09 <Cale> zereraz: also, that guard is unnecessary if you're using the if/then/else
22:25:23 <solidus-river> so i'm clearly doing somethign wrong with laziness or could be better about thinking about it
22:25:28 <solidus-river> but the problem itself is well formed
22:25:31 <zereraz> Cale: yeah the guard is un necessary here
22:25:42 <zereraz> Cale: can I remove else?
22:25:46 <Cale> zereraz: No
22:25:47 <zereraz> and keep guard
22:26:01 <Cale> zereraz: Every 'if' must have both 'then' and 'else'
22:26:10 <Cale> zereraz: You can replace the 'if' with guards
22:26:27 <zereraz> Cale: ok, so what do I do about the print
22:26:35 <Cale> zereraz: Well, what do you want to print?
22:26:43 <zereraz> the numbers
22:26:44 <ruzu> does anyone have any experience with hblas or other math libs?
22:27:04 <Cale> Oh, sorry, I'm wrong, print doesn't want a String specifically, but anything in the class Show. A number would be okay, but an IO action isn't.
22:27:10 <dwcook> zereraz, in Haskell, "if" forms an expression. Every expression must have a value. That's why you have to have the else, because there has to be a value either way.
22:27:26 <Cale> zereraz: perhaps you want to print n ?
22:27:39 <zereraz> dwcook: understood
22:27:54 <zereraz> Cale: then what about recursion
22:27:56 <Cale> zereraz: count (0 a) isn't the same thing as count 0 a also
22:28:11 <zereraz> Cale: oh yeah
22:28:30 <Cale> zereraz: count (0 a) means "apply the function 0 to the value a, and apply count to the result of that"
22:28:43 <zereraz> Cale: got it
22:28:57 <Cale> But 0 isn't typically a function (unless you have an instance of Num for functions)
22:29:32 <zereraz> so what do I do about printing
22:29:45 <zereraz> shoud I print then do recursion
22:29:50 <Cale> zereraz: yes?
22:30:07 <Cale> I mean, it depends on what you want your program to do, but probably :)
22:30:22 <zereraz> it compiled :D
22:30:37 <zereraz> but did not work
22:30:44 <zereraz> it returned 0
22:31:07 <zereraz> new code http://lpaste.net/108084
22:32:20 <Cale> zereraz: Well, count 0 5 for instance, will check whether 5 <= 0
22:32:22 <AncientPC> This is a really dumb question, but how do I access attributes on a record?
22:32:25 <Cale> and so will take the 'else' case
22:32:29 <zereraz> damn
22:32:42 <zereraz> yeah I just caught that
22:32:42 <Cale> AncientPC: Use the field names as functions
22:32:43 <zereraz> thanks
22:33:11 <zereraz> it WORKED!!
22:34:05 <zereraz> thanks guys
22:34:05 <Cale> @let data Employee = Empl { emplName :: String, emplSalary :: Integer }
22:34:05 <lambdabot>  Defined.
22:34:05 <Cale> :t emplName
22:34:05 <lambdabot> Employee -> String
22:34:05 <Cale> :t emplSalary
22:34:05 <lambdabot> Employee -> Integer
22:34:05 <AncientPC> Cale: thanks!
22:34:05 <whyy> Introducing Haskell to People in my Company, Excited :)
22:34:05 <Cale> IHPCE
22:34:05 <AncientPC> whyy: I'm in the middle of doing a Haskell project for a company hackathon right now. :p
22:34:06 <Cale> @undefine
22:34:06 <lambdabot> Undefined.
22:34:20 <whyy> AncientPC: Awesome
22:35:07 <whyy> AncientPC: Thinking on same terms to start a Hackathon in my company too soon ...
22:35:34 <AncientPC> we should have brown bagged Haskell for a couple weeks though
22:35:54 <AncientPC> first few hours was walking a few people through ghci / cabal / cabal hell / cabal sandboxes / hoogle
22:37:28 <whyy> AncientPC: How to create interest in Haskell among People because most of them think Haskell is useless and an Academia Language .. Poor them ;-)
22:38:39 * hackagebot cab 0.2.12 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.12 (KazuYamamoto)
22:38:46 <systemfault> Haskell is too difficult for most people I’m beginning to think.
22:39:32 <zereraz> systemfault: it is difficult for me, It took me an hour with everyone's help to make a simple counter
22:39:32 <systemfault> (I love the language and I’m spending a lot of time to learn it properly.. it’s just tough.
22:40:33 <swgillespie> Haskell requires you to unlearn everything you know about programming, i think that's the real hard part
22:40:44 <swgillespie> when you come from an imperative background and see things like "return" it's easy to get confused
22:41:01 <systemfault> Haskell is closer to maths and therefore more abstract than the usual languages with procedures containing a series of statements
22:41:17 <systemfault> (My opinion… been learning haskell for about 2 weeks now)
22:41:54 <zereraz> I knew 1 year of imperative programming , I love haskell
22:42:15 <systemfault> zereraz: 15 years of OOP here…
22:42:26 <whyy> I started Haskell too about a month back and has already fallen in love with it
22:42:31 <zereraz> my discrete maths professor introduced me to haskell, I told him about functional programming and my interest in it, he told me to learn haskell
22:42:44 <systemfault> It’s my third attempt to learn it :)
22:42:48 <systemfault> I won’t give up this time.
22:43:02 <whyy> systemfault: Dont, I think it will be worth it
22:43:04 <whyy> :)
22:43:08 <zereraz> systemfault: wow still you will learn it much faster than me, because I have trouble in programming itself
22:43:27 <sgronblo> The best way to create interest in Haskell would be to create software using it and then write about how it made everything so awesome in some way.
22:43:29 <systemfault> zereraz: I have more to unlearn :P
22:43:46 <zereraz> systemfault: that is true, today itself I found out that return is not the same :P
22:43:49 <ruzu> big popular projects
22:44:14 <zereraz> I can't wait to be fluent is haskell
22:44:22 <zereraz> atleast average
22:44:23 <whyy> ruzu: Any Big Popular projects in production you can recall ?
22:44:26 <ruzu> like "oh that hot new nosql db was made in haskell?  imma learn haskell!"
22:44:39 <systemfault> Not sure anything known is written in Haskell :(
22:44:48 <ruzu> i'm a haskell newb myself :p
22:44:51 <ruzu> so i don't know
22:44:53 <ruzu> i know of xmonad
22:44:57 <MP2E> systemfault : I heard of xmonad long before I had heard of Haskell
22:45:01 <MP2E> but that's about it unfortunately
22:46:12 <ruzu> i remember first hearing of xmonad years ago, wondering, "wtf kind of name is that?"  now it makes perfect sense :)
22:46:15 <sgronblo> http://engineering.imvu.com/2014/03/24/what-its-like-to-use-haskell/ like this one for example, "Our little Haskell server was running on a pair of spare servers that were otherwise set for retirement, and despite this, each machine was handling about 20x as many requests as one of our high-spec PHP servers could manage." I think these kinds of arguments can persuade some people. Though you will find many other articles coming to the same conclusion about 
22:53:41 * hackagebot messagepack 0.1.0.0 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.1.0.0 (rodrigosetti)
22:57:41 <td123> is there a way to ensure the length of a string through types?
22:58:16 <td123> other than I guess making a constructor with n parameters?
22:58:53 <benzrf> td123: no
22:59:01 <benzrf> what's the use case?
22:59:31 <zwer> td123 are you asking about the String type or a custom type?
22:59:46 <td123> I guess the string type
23:01:00 <zwer> no way to have length guarantee with String since there's no length information in the type
23:01:03 <dwcook> It's possible to make a sequence type where the length is encoded in the type. Is that what you want? Bear in mind this has certain disadvantages as well
23:01:12 <td123> I'm creating a library to talk to APNs http://goo.gl/0tPRil and their protocol has a maximum string length, or a specific string length
23:02:50 <sgronblo> that sounds like dependent typing to me?
23:03:10 <dwcook> You don't need full dependent types for many uses of that
23:03:21 <dwcook> You might just need type nats
23:03:28 <sgronblo> type nats?
23:03:33 <dwcook> Type-level natural numbers
23:03:51 <dwcook> A naive way to do it would be: data Zero ; data Succ a
23:03:57 <sgronblo> that sounds a lot like those example of dependent typing ive seen
23:03:58 <swgillespie> peano numbers?
23:04:01 <dwcook> Then you can write Succ (Succ Zero), for example, as a type
23:04:01 <johnw> isn't it much easier to use nats at the kind level?
23:04:10 <johnw> I mean, DataKinds
23:04:15 <dwcook> Yes, I was about to mention that
23:04:22 <dwcook> DataKinds would be the real way to go if you wanted that
23:04:31 <johnw> they make statically determined "dependentish" types easy
23:04:35 <dwcook> I was merely demonstrating the concept
23:04:48 <limepod> what about a smart constructor? http://www.haskell.org/haskellwiki/Smart_constructors
23:05:48 <brut3> F# or haskell on windows?
23:06:05 <dwcook> limepod, I would probably discourage uses of error that can be avoided
23:06:38 <dwcook> Although, I suppose avoiding using error isn't a terminal value as sometimes the alternative is uglier
23:07:30 <td123> hmm, I might just through an error then :/
23:07:31 <benzrf> isnt a smart constructor just a function
23:07:42 <limepod> would maybe or either work better then?
23:08:27 <dwcook> td123, crashing the program based on input is usually a bad idea, I'd say
23:08:34 <brut3> I want to get into functional programming and everyone (.net crowd though, so biased) is recommending me F#. for some I am more partial to haskell. but would I be flowing against the stream here? is windows a second class platform for haskell?
23:08:43 <dwcook> td123, though if you absolutely can't proceed with malformed input, then perhaps
23:09:04 <sgronblo> SPJ runs windows?
23:09:11 <dwcook> brut3, it's less painful developing Haskell on non-Windows systems. However, Haskell does run on Windows.
23:09:18 <sgronblo> And Philip Wadler?
23:09:42 <swgillespie> If you want a haskell, f# is no substitute
23:09:48 <swgillespie> it can't handle higher kinded types at all
23:10:08 <dwcook> You mean types of kind besides *?
23:10:14 <swgillespie> sure, yeah
23:10:20 <swgillespie> the CLR can't handle it
23:10:23 <brut3> Is that a deal breaker? I have no clue what that means
23:10:34 <dwcook> brut3, well it disallows things like the Functor abstraction
23:10:35 <swgillespie> it means you can't do some of the more powerful abstractions that haskell can do
23:10:41 <td123> dwcook: ya, I mean, it's part of the protocol, either I error out or apple errors out for me :P
23:10:46 <sgronblo> does that mean a kind that takes many types to become a type?
23:11:23 <td123> dwcook: well hmm
23:11:48 <dwcook> sgronblo, in this context I believe it can be taken as "non-concrete types", a concrete type being one that is allowed to (and in Haskell must) contain values.
23:11:48 <td123> dwcook: actually you might be right, rather than crashing, I'll just return a failure type
23:12:05 <td123> dwcook: that would make more sense
23:12:09 <td123> dwcook: thanks :)
23:12:12 <dwcook> td123, sounds good
23:12:29 <dwcook> sgronblo, as an example: Maybe, [], Either
23:12:39 <dwcook> s/as an example/for example/
23:13:32 <dwcook> Hmm, it's late, I'm no longer sure what I'm saying makes sense. :P Good night everyone.
23:13:50 <brut3> it seems that haskell is more functional pure, right? brutal purity as John Carmack put it, and that seems interesting and completely different
23:14:07 <swgillespie> yes, that's true
23:14:21 <Cale> brut3: Yeah, expression evaluation in Haskell is pure
23:14:38 <swgillespie> in f# you can do a lot of the same stuff you can do in c#, like throwing exceptions, some nullable references, etc.
23:14:43 <swgillespie> things that generally aren't pure
23:14:48 <swgillespie> throwing/catching exceptions, i mean
23:15:41 <sgronblo> dwcook: f# cant do a simple Maybe?
23:15:54 <swgillespie> f# can do maybe, sort of
23:16:02 <swgillespie> the big problem with f# is that the CLR can't do unions at all
23:16:08 <sgronblo> I thought a kind was * -> *
23:16:16 <trap_exit> has anyone written a WYSIWYG math edito rin hasell yet?
23:16:21 <benzrf> sgronblo: thats the kind of Maybe, among other things
23:16:27 <benzrf> :k Mona
23:16:28 <lambdabot>     Not in scope: type constructor or class ‘Mona’
23:16:28 <benzrf> :k Monad
23:16:28 <lambdabot>     Perhaps you meant ‘Monad’ (imported from Control.Monad.Writer)
23:16:29 <lambdabot> (* -> *) -> Constraint
23:16:34 <sgronblo> So * -> * is one kind?
23:16:35 <swgillespie> f# can't do stuff of kind (* -> *) -> Constraint
23:16:43 <sgronblo> and * -> * -> * is another?
23:16:50 <benzrf> bbl
23:16:56 <benzrf> bye
23:17:01 <swgillespie> :k Maybe
23:17:01 <lambdabot> * -> *
23:17:04 <swgillespie> :k Either
23:17:05 <lambdabot> * -> * -> *
23:17:27 <sgronblo> So whats a higher-kinded type?
23:17:38 <sgronblo> higher than what?
23:17:45 <pyon> swgillespie: Does .NET even have a kind system?
23:17:55 <swgillespie> pyon: not really.
23:18:06 <swgillespie> they're basically interfaces
23:18:11 <Cale> @let data GenTree f a = Tip a | Branch (f (GenTree f a))
23:18:12 <lambdabot>  Defined.
23:18:16 <Cale> :k GenTree
23:18:16 <lambdabot> (* -> *) -> * -> *
23:18:30 <Cale> :k StateT
23:18:31 <lambdabot> * -> (* -> *) -> * -> *
23:18:32 <swgillespie> f# does an admirable job at creating a nice language on top of a constrained platform
23:18:47 <CARAM_> hey #haskell, what's up with the haskell platform? why was the last release early last year?
23:18:56 <trap_exit> is yi the only eitor written in haskell ?
23:19:06 <MP2E> trap_exit : no but it's probably the only active project
23:19:21 <MP2E> CARAM_: There's a release candidate for the new haskell platform that was released like a day ago
23:19:22 <trap_exit> hmm
23:19:24 <trap_exit> why did people abandone th eothe rprojects?
23:19:26 <MP2E> it'll be out in a few weeks
23:19:31 <glguy> Next HP release is in testing right now
23:20:06 <CARAM_> know if it will include ghc 7.8+?
23:20:19 <Cale> trap_exit: For a long time, yi was pretty abandoned as well, it seems like people have recently picked it up again
23:21:37 <ruuns> what's prefered way in haskell for c's sprintf/printf? :)
23:22:08 <Cale> ruuns: I usually just use some combination of show and concat/(++)
23:22:09 <Pythonfant> CARAM_: yep 7.8.3
23:22:15 <Cale> ruuns: But Text.Printf does exist
23:22:18 <trap_exit> show
23:22:30 <trap_exit> Cale: any intuition behind why people abandoned such projects?
23:22:46 <CARAM_> Pythonfant: cheers, thanks
23:22:49 <Cale> trap_exit: They had other projects or responsibilities?
23:23:35 <MP2E> From the looks of all of them, I'd prefer to use yi anyway :P
23:23:50 <trap_exit> Cale: you mean thins like family / making a living ?
23:23:52 <MP2E> Still using emacs but I'm gradually moving features over and messing with the config.
23:24:54 <MP2E> Well who can say why they actually quit? But putting it in perspective can give us some educated guesses. IDEs are complicated to write, they were doing it for free and probably they didn't have very large userbases
23:25:06 <MP2E> motivation can only last so long with no money and few users
23:25:52 <Cale> trap_exit: While the community has grown, there are only so many people working on Haskell code, so if the original maintainers move along to doing something else which interests them, it can be hard to expect people to instantly fill those gaps.
23:28:37 <Cale> Also, I suppose the text editors which already exist are pretty adequate at what they do in most cases.
23:28:49 <redtricycle> What's the recommended module to use for passing arguments command line?
23:28:50 <redtricycle> GetOpt?
23:28:55 <redtricycle> There are 3 main methods, I see
23:29:08 <MP2E> redtricycle : optparse-applicative or cmdtheline
23:29:12 <Cale> redtricycle: I've used that before, it's reasonably good.
23:29:33 <MP2E> I like optparse-applicative the most, personally :P
23:31:27 <redtricycle> Will take a  look at both, thanks Cale and MP2E
23:33:44 * hackagebot easy-file 0.2.0 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.2.0 (KazuYamamoto)
23:38:45 * hackagebot wai-logger 2.1.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.1.2 (KazuYamamoto)
23:56:20 <Guest21244> Guys I am in the middle way of finishing learn you haskell for great good
23:56:35 <jle`> Guest21244: congrats :D
23:56:43 <Guest21244> I see this is the only starting book
23:56:55 <Guest21244> Do you have any other suggestion
23:56:56 <jle`> the start of a wonderful journey :)
23:57:02 <jle`> of books after LYAH?
23:57:03 <Guest21244> :) thanks
23:57:24 <MP2E> a very wonderful journey
23:57:35 <MP2E> I've been compulsively reading haskell stuff for like 6 months, time has flown by
23:57:38 <MP2E> :D
23:57:52 <Guest21244> yeah I am already  afan of Haskell now :)
23:58:03 <jle`> Guest21244: hmmm.  my journey after LYAH involved lots of coding
23:58:04 <Pythonfant> Guest21244: I would recommend finding yourself something you want to accomplish and then read up on the things you didn't understand
23:58:06 <jle`> writing programs
23:58:13 <jle`> and then reading blog posts to learn how to do things
23:58:17 <jle`> papers and blog posts
23:58:20 <jle`> to fill in gaps...
23:58:31 <jle`> ...and don't worry if you run into anything you don't understand, just drop it :)  and pick it back up in a few months
23:59:04 <jle`> and then i read Simon Marlow's Parallel & Concurrent Haskell...which is a great book even if you aren't interested in concurrency or parallelism...because it teaches you how a Haskeller "thinks"
23:59:10 <Guest21244> So my primary objective is learn Haskell and its type system in depth
23:59:36 <jle`> Guest21244: best way is to just start progrmaming things
23:59:37 <Guest21244> yeah I am intrested in Concurrency
