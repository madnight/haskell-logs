00:03:22 * hackagebot mighttpd2 3.1.2 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.1.2 (KazuYamamoto)
00:07:56 * hackagebot linklater 1.0.0.3 - Write bots for your Slack account, and then go to sleep (because it's so easy and late at night)  http://hackage.haskell.org/package/linklater-1.0.0.3 (hao)
00:07:56 * hackagebot mighttpd2 3.1.2 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.1.2 (KazuYamamoto)
00:24:10 <serutsubi> I've got a very long line in my sourcecode (~140 chars) but I can't seem to split it. It is on this form: putStrLn "..."
00:24:47 <glguy_> You can split string literals across line s
00:24:49 <frerich> serutsubi: Try pasting it to http://lpaste.net/new/haskell so that people can see it
00:25:37 <glguy_> End one line with \ and start the literal on the next with \
00:26:10 <serutsubi> http://lpaste.net/5715042655545589760
00:26:41 <serutsubi> glguy_: It worked!
00:28:52 <serutsubi> Also, these lines are far above 80 characters, but splitting them would make it look like a mess. Any suggestions? http://lpaste.net/3085570849806221312
00:29:35 <_faern> Don't care so much about 80 characters wide is my suggestion
00:30:20 <serutsubi> _faern: It's a little bit annoying that I have to scroll sideways to see the whole line
00:30:37 <frerich> serutsubi: What's the difference between 'p' and 'pLn'? Both seem to write a newline at the end, right?
00:31:12 <serutsubi> frerich: Only pLn writes a newline, p doesn't because the string provided contains a newline
00:32:01 <_faern> serutsubi: Ok. I don't have a serious suggestion then. Only to get a larger screen.
00:33:06 <_faern> serutsubi: In the longest line it seems you have "words uptimedirty" four times. Put that exp in a let or something to make it shorter.
00:33:18 <serutsubi> _faern: Now I have a good excuse to buy one :)
00:33:32 <serutsubi> _faern: Ah, yes. I will do that, thanks
00:35:11 <frerich> serutsubi: You could also separate printing the field and the logo, like in http://lpaste.net/107936
00:36:30 <serutsubi> frerich: Awesome! I've been thinking about how to do that
00:37:07 <frerich> serutsubi: You'll end up with a "merged" list of strings which you could then dump via "putStr (unlines mergedList)" or so
00:41:20 <serutsubi> I will try that now. Why is it that I have to put let logo = ... inside main but only logo = ... outside it?
00:42:49 <frerich> serutsubi: It's a consequence of the fact that in 'main' you're probably using the 'do-notation'
00:44:45 <serutsubi> frerich: Why would the do-notation change this, I've always thought that let was ghci spesific
00:45:34 <frerich> serutsubi: When typing code in 'ghci', you're always using "do" notation. Imagine that ghci wrote the 'main = do' for you
00:49:28 <frerich> serutsubi: In 'do' notation, individual lines have a very specific meaning - they are chained via the '>>' or '>>=' functions, i.e. 'do { a; b }' is the same as 'a >> b'. And 'do { x <- a; ... }' is the same as 'a >>= \x -> ...'. The 'do' notation provides 'syntactic sugar' (which is also why translating do-notation to the '>>=' notation is called 'desugaring').
00:50:29 <frerich> serutsubi: In order to have new definitions, you use 'let' since writing 'do { a; let x = 2; b x }' desugars to 'a >> let x = 2 in b x'
00:52:17 <akegalj> i have some ghc arch related question so i'll try here: when i do "pacman -S ghc" pacman is pulling ghc-7.8. Now, i don't whant ghc-7.8 couse my projects are ghc7.6 related.
00:52:40 <akegalj> what i really need is to install xmond, but pacman is pulling ghc-7.8
00:53:01 <akegalj> can i somehow install xmonad with ghc.7.6
00:53:09 <frerich> serutsubi: After googling a bit, I think I didn't get that entirely right syntax-wise. I can recommend http://book.realworldhaskell.org/read/monads.html#monads.do on how 'do' blocks are desugared.
00:53:22 <allsystemsarego> akegalj, xmonad doesn't require ghc
00:53:40 <allsystemsarego> except if you need to build it yourself
00:53:53 <allsystemsarego> xmonad is a binary
00:54:23 <akegalj> hm.. but pacman is pulling ghc-7.8 binary too
00:54:31 <akegalj> when i do pacman -S xmonad
00:54:36 <allsystemsarego> that's weird
00:54:45 <serutsubi> frerich: Thanks!
00:55:07 <akegalj> and other binaries like haskell-data-* haskell-utf8 ...
00:56:32 <serutsubi> akegalj: Check if you can do: "pacman -S xmonad --ignore ghc"
00:57:28 <allsystemsarego> https://www.archlinux.org/packages/community/x86_64/xmonad/
00:57:34 <serutsubi> frerich: Do you know why I'm getting this error: http://lpaste.net/2308843778309357568. It is inside the "main = do"
00:57:43 <allsystemsarego> look at the file list for xmonad
00:58:02 <allsystemsarego> there's a bunch of *.hi files
00:58:14 <frerich> serutsubi: I see no error message.
00:58:34 <serutsubi> frerich: Oh, i forgot to say it is in the title of the paste
00:58:42 <frerich> Ah :-)
00:58:42 <allsystemsarego> so yeah, you need a container or VM to continue using 7.6
00:59:02 <frerich> serutsubi: In which line do you get the error?
00:59:11 <akegalj> allsystemsarego: so xmonad is binded to ghc-7.8?
00:59:22 <serutsubi> frerich: Line number 2
00:59:22 <allsystemsarego> akegalj, yup
00:59:29 <akegalj> allsystemsarego: oh well
01:00:56 <akegalj> allsystemsarego, serutsubi: thnx for help
01:01:14 <frerich> serutsubi: Seems like one may not have a newline after '='
01:01:35 <frerich> At least not for 'let'
01:02:46 <frerich> serutsubi: Ah, it's a little more tricky:
01:02:50 <serutsubi> frerich: It seems to work if i put everything on one line, but that one is extremely long
01:03:13 <frerich> serutsubi: It seems you *may* have a newline, but the '[' needs to be indented further than the 'f' of  'fields'
01:03:50 <frerich> This identation-specific stuff always trips me up..
01:03:54 <serutsubi> frerich: Yes, now it works!
01:04:09 <serutsubi> frerich: Thanks a lot, I've got to go now :/
01:04:31 <akegalj> allsystemsarego: you said VM or container for old ghc. Can you tell me more about container? Is it some kind of sandbox like hsenv?
01:10:11 <dfeuer> Are folds slower than hand-written recursive functions when no special optimizations kick in? I see a lot of functions in GHC-List that could be written as folds but aren't.
01:10:46 <dfeuer> Could be written so in an obvious way; aside from all the weird things.
01:15:14 <zereraz> hello everyone, can someone tell me what is wrong here http://hastebin.com/ucafamutek.coffee
01:16:43 <ghorn_> hi
01:16:59 <tdammers> zereraz: yes. It requires javascript. You'll have an easier time getting people to read your pastes if you use a service that doesn't.
01:17:16 <tdammers> zereraz: see the /topic for a suggestion ;)
01:17:29 <ghorn_> toBinar (n`div`2) is returning [Int], but you're then using : on that
01:17:38 <zereraz> tdammers: ok gonna use this http://lpaste.net/new/haskell
01:17:39 <ghorn_> [Int] : [Int] doesn't work
01:17:45 <ghorn_> it has to be Int : [Int]
01:18:05 * hackagebot MFlow 0.4.5.6 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.6 (AlbertoCorona)
01:18:24 <zereraz> ghorn_: how to do Int:[Int]
01:18:29 <zereraz> ghorn_: in the type?
01:18:44 <ghorn_> :t (:)
01:18:44 <lambdabot> a -> [a] -> [a]
01:19:12 <ghorn_> "2 : [4,5,6]" is ok, "[4,5,6] : 2" is not
01:19:15 <zereraz> oh so I am taking another [a] and then returning [a]
01:19:17 <tdammers> if you want to concatenate lists, use (++) or (<>), not (:)
01:19:34 <zereraz> so it will work if i use ++
01:19:41 <zereraz> the recursion is correct?
01:19:51 <tdammers> I don't know, I haven't read your code
01:20:22 <zereraz> I'll try and come back
01:20:27 <ghorn_> ++ will almost work, try it and see if you can understand the error message
01:20:47 <zereraz> not working, 1 sec
01:21:04 <zereraz> 1 more thing
01:21:19 <zereraz> should I do Int->[Int]->[Int]
01:21:26 <zereraz> or a->[a]->a[]
01:21:29 <zereraz> [a]*
01:21:45 <zereraz> http://lpaste.net/107942
01:21:58 <jle`> zereraz: if you do'nt do anything inty, you'll get better reuse if you let it be more polymorphic or general, normally :)
01:22:08 <jle`> if you do inty stuff with it then you'll need Int there of course
01:22:15 <jle`> (but what is even an Inty thing...?)
01:22:26 <zereraz> ok got it
01:22:30 <frerich> "Numy" would probably be more appropriate :)
01:22:36 <zereraz> lol
01:22:42 <ghorn_> you can try with type signature a -> [a] -> [a], and then GHC will tell you what you are missing
01:22:50 <ghorn_> "error: no instance Num a" or something
01:23:32 <zereraz> http://lpaste.net/107942
01:23:34 <zereraz> with error code
01:24:15 <tdammers> Int -> [Int] -> [Int] means "take an Int and a list-of-Int, and return an Int"
01:24:18 <zereraz> 1 more thing, if I wanted to use : then I could have just reversed the order
01:24:33 <tdammers> but the equations say "take an Int, and return a list-of-Int"
01:24:55 <zereraz> tdammers: [Int] won't this mean a list of Int's
01:25:03 <tdammers> yes
01:25:08 <jle`> toBinary 0 = []   -- this seems to say, take a number, and return a list
01:25:18 <jle`> but your type signature is Int -> [Int] -> [Int]
01:25:24 <jle`> which says take a number and a list, and return a list
01:25:38 <zereraz> jle`: my previous type was that only
01:25:46 <zereraz> Int->[Int]
01:26:04 <tdammers> and what does the compiler say about that?
01:26:11 <zereraz> lemme check
01:26:22 <zereraz> doing a->[a]
01:26:48 <kruchy> @pl len (x:y:rest) = sqrt ((fst y - fst x)**2 + (snd y - snd x)**2)
01:26:49 <lambdabot> len = ap ((`ap` tail) . (. head) . ((const . sqrt) .) . ap (ap . ((+) .) . flip flip 2 . ((**) .) . flip ((-) . fst) . fst) (flip flip 2 . ((**) .) . flip ((-) . snd) . snd) . head) tail
01:27:21 <zereraz> Couldn't match expected type `a' with actual type `[a]'
01:27:21 <zereraz>       `a' is a rigid type variable bound
01:28:54 <jle`> zereraz: the line number and the rest of the error message tends to help a lot ;)
01:29:12 <zereraz> jle`: I'll paste the whole thing
01:29:26 <zereraz> the type signature for toBinary :: a -> [a] at toBinary.hs:5:13
01:29:29 <zereraz> line no.
01:30:30 <zereraz> ok my bad
01:30:41 <zereraz> hs:7
01:31:02 <zereraz> http://lpaste.net/107942
01:31:05 <zereraz> with Int
01:34:27 <Tjr> @type (++)
01:34:28 <lambdabot> [a] -> [a] -> [a]
01:36:02 <Tjr> zereraz: line 7: ++ [ n`mod`2 ]
01:36:15 <zereraz> Tjr: square brackets?
01:36:23 <Tjr> yes
01:36:28 <zereraz> what does it do?
01:36:29 <Tjr> ++ wants a list
01:36:34 <zereraz> oh
01:36:38 <Tjr> n'mod'2 is an int
01:36:44 <Tjr> [ ] packages that int up into a list
01:37:36 <zereraz> it worked!! thanks, I should have thought about this
01:37:51 <Tjr> zereraz: you're welcome
01:38:18 <ghorn_> zereraz: here's another way to do it http://lpaste.net/107945
01:38:50 <zereraz> ghorn_: I was trying just that, thanks :D
01:38:56 <Tjr> ghorn_: next improvement: do it with foldl
01:39:03 <zereraz> and I did get an error :P
01:39:11 <zereraz> what does foldl do
01:39:15 <ghorn_> :t foldl
01:39:16 <lambdabot> (b -> a -> b) -> b -> [a] -> b
01:40:05 <zereraz> where would we use foldl there?
01:40:16 <Tjr> zereraz: http://learnyouahaskell.com/higher-order-functions#folds
01:40:16 <Tjr> zereraz short story, it's more special than plain recursion and therefore more readable
01:40:17 <ghorn_> I learned about fold and similar things from http://learnyouahaskell.com/higher-order-functions, if you haven't already checked it out
01:40:19 <ghorn_> haha
01:40:46 <zereraz> ghorn_: ok thanks, gonna go read and solve more problems
01:40:49 <zereraz> thanks everyone
01:41:19 <Tjr> Actually, iterate is probably more suitable than fold
01:42:51 <frerich> ghorn_: You could also define "toBinary' n = let (d, r) = n `divMod` 2 in r : toBinary d"
01:43:16 * Tjr agrees
01:43:53 <Tjr> And you could abstract it away from Int, to any instance of ( Integral n, Ord n) =>
01:44:19 <frerich> I don't see why you would need 'Ord'
01:44:55 <frerich> ...but you could use 'quotRem' instead of 'divMod' for a bit more efficiency.
01:45:28 <mr-> @let toBinary n = let (d, r) = n `divMod` 2 in r : toBinary d
01:45:29 <lambdabot>  .L.hs:153:1: Warning:
01:45:29 <lambdabot>      Pattern match(es) are overlapped
01:45:29 <lambdabot>      In an equation for ‘toBinary’: toBinary n = ...
01:45:29 <lambdabot>  
01:45:29 <lambdabot>  <no location info>:
01:45:33 <Tjr> The algo terminates because the unprocessed remainders keep gettign smaller. Therefore, it only makes sense on a data structure that has a comparison operator
01:45:39 <mr-> :t toBinary
01:45:40 <lambdabot> Integral a => a -> [a]
01:46:53 <frerich> Tjr: I'm pretty sure that any Integral is already a member of Ord
01:48:07 * Tjr ponders how to generalize this algorithm to a polynomial ring over a commutative ring with a valuation.
01:48:10 * hackagebot keystore 0.3.0.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.3.0.1 (ChrisDornan)
01:48:39 * Tjr realizes that's likely irrelevant to zereraz 
01:48:50 <frerich> I think an arguably more practical exercise might be to consider what to do about negative values ;-)
01:49:30 <Tjr> yeah, no big changes needed there :-)
01:50:27 <Tjr> to be fair, the result of zereraz's exercise, but set in a polynomial ring, is important enough to warrant a name: horner scheme.
02:01:04 <gfixler> I'm finding the LYAH chapter 9 section on kinds to be quite confusing
02:06:47 <BartAdv> i am playing with mflow, and I'm starting it in ghci with :main 8080 - it then enters the loop, so if I want to reload it I hit C-c C-c, but then I can't start it again (port is already bound to), seems like C-c and C-c is not graceful enough? what are other options to stop the execution in ghci?
02:18:13 <merijn> gfixler: Where is that section? (And what are you finding confusing?)
02:19:12 <Tjr> it's at the very end
02:19:53 <merijn> The very end seems to be exceptions?
02:20:12 <merijn> oh, wait
02:20:19 <merijn> kinds are in chapter 8
02:22:16 <gfixler> merijn: it's only in the online version, apparently
02:22:31 <gfixler> it's the whole end of the chapter, which is all on kinds
02:22:37 <gfixler> I actually mostly get kinds themselves
02:23:02 <gfixler> but not things that are going on in the value constructors used in the examples
02:23:17 <gfixler> merijn: they're in chapter 8 in the book, but chapter 9 online
02:23:31 <gfixler> and the section on kinds isn't in the physical book - it's all quite confusing
02:23:43 <gfixler> apparently chapter 1 online isn't in the actual book
02:23:52 <gfixler> so online's chapter 2 is book's chapter 1
02:24:39 <merijn> gfixler: I'm looking on the website and there they're in chapter 8 too?
02:24:58 <gfixler> oh, weird
02:25:05 <gfixler> merijn: you're right
02:25:45 <gfixler> double-confusion, sorry
02:25:46 <merijn> gfixler: You mean you don't get the "Frank" examples?
02:25:52 <gfixler> yes
02:26:16 <gfixler> various, small things
02:26:21 <merijn> Is it the record syntax that's confusing you?
02:26:42 <gfixler> it was, but I posted that 20+ minutes ago, it's been slowly resolving since then
02:26:53 <gfixler> frankField :: b a
02:27:02 <gfixler> I get that - b could be Just, a could be 7
02:27:12 <merijn> gfixler: Note that in "data Frank a b  = Frank {frankField :: b a} deriving (Show)" the *first* Frank is a TYPE constructor, but the *second* Frank is a DATA constructor
02:27:17 <gfixler> I found it odd that Frank a b was in the reverse order, though
02:27:27 <merijn> gfixler: Ah, but 'b' *can't* be Just
02:27:33 <gfixler> no?
02:27:36 <merijn> gfixler: 'b' is a TYPE, Just is a value
02:28:15 <merijn> "data Frank a b = ?" <- this defines a TYPE CONSTRUCTOR Frank, which takes two argument types, 'a' and 'b'
02:28:15 <gfixler> b isn't a type constructor?
02:28:22 * frerich read "frankenField" for a moment :-)
02:28:39 <gfixler> oh, wait
02:28:43 <merijn> gfixler: I'll drop record syntax for a bit, because it adds noise
02:28:49 <gfixler> yes, it does
02:28:57 <gfixler> I feel like the first example the book gave me was 5 things all at once
02:29:19 <tdammers> I like "Frank" much better than "foobar"
02:29:40 <merijn> "data Frank a b = MkFrank (b a)" <- this defines a DATA CONSTRUCTOR MkFrank which has 1 argument. Function/constructor arguments are *always* types with kind *
02:29:46 <gfixler> frankField :: b a
02:29:53 <gfixler> but those are 2 distinct things
02:29:54 <gfixler> right?
02:30:06 <merijn> gfixler: Therefore, we can conclude that "MkFrank :: b a -> Frank b a"
02:30:11 <merijn> gfixler: eh
02:30:23 <merijn> "MkFrank :: b a -> Frank a b" (typo, sorry)
02:30:36 <gfixler> I guess I was thinking of it like I need to give frankField, e.g., a 7 and a Just
02:30:38 <merijn> We know: "b a :: *"
02:30:44 <gfixler> and then we'd get a Frank Just 7
02:30:55 <merijn> gfixler: Just and 7 are values, not types
02:31:05 <gfixler> Just is a function, right?
02:31:14 <gfixler> and a value constructor
02:31:24 <merijn> gfixler: Hold on. Given that "b a :: *" we can conclude: "b :: * -> *" and "a :: *"
02:31:47 <merijn> gfixler: Now, can we think of any TYPES with those KINDS? Yes!
02:31:49 <frerich> tdammers: I think the officially endorsed realname alternatives to 'foo' and 'bar' are 'Alice' and 'Bob.
02:31:49 <merijn> :k Maybe
02:31:50 <lambdabot> * -> *
02:31:53 <merijn> :k Char
02:31:54 <lambdabot> *
02:32:13 <gfixler> ah ha
02:32:18 <tdammers> frerich: Alice and Bob are for crypto and communication
02:32:24 <merijn> gfixler: So, you could, for example, do "MkFrank (Just 'a') :: Frank Char Maybe"
02:33:10 <gfixler> MkFrank is throwing me off
02:33:33 * gfixler goes back to the MkFrank definition...
02:33:39 <merijn> gfixler: I actually prefer GADT syntax for data constructors in these examples. With that syntax you would write Frank as this:
02:33:40 <gfixler> ok
02:33:55 <merijn> "data Frank a b where MkFrank :: b a -> Frank a b"
02:34:26 <tdammers> https://en.wikipedia.org/wiki/Alice_and_Bob#Cast_of_characters
02:34:28 <gfixler> MkFrank (b a) was less scary
02:34:36 <kgadek> hi. I'm installing GHC 7.6.3 on Docker (fedora:20 image), and when running ./configure I'm getting:
02:34:37 <kgadek> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
02:34:38 <kgadek> configure: error: cannot determine current directory
02:34:39 <kgadek> …any ideas?
02:34:48 <merijn> gfixler: So MkFrank is a DATA constructor that takes a VALUE of TYPE "b a" and returns a value of TYPE "Frank a b"
02:35:16 <gfixler> merijn: is a DATA constructor the same as a value constructor?
02:35:20 <allsystemsarego> kgadek, yum install libgmp or similar?
02:35:40 <merijn> gfixler: Frank, however, is a TYPE constructor that takes two TYPES 'a' and 'b' and returns a TYPE "Frank a b" (which has kind *)
02:35:59 <kgadek> allsystemsarego: installed that via sources from https://gmplib.org/download/gmp/gmp-6.0.0a.tar.xz already
02:36:05 <merijn> gfixler: Yes, I just prefer the term "data constructor" :)
02:36:28 <gfixler> merijn: okay, I'm fine with either now
02:36:34 <allsystemsarego> kgadek, ls -l /usr/lib/libgmp*?
02:36:37 <merijn> gfixler: Note that the TYPE "Frank" does not need to have anything to do with the actual data inside
02:36:50 <gfixler> I want to go back to MkFrank (b a), and how the arguments are types with kind *
02:36:55 <merijn> gfixler: For example: "data Mark a b = MkMark Int"
02:37:05 <gfixler> where with kind * == is a concrete type
02:37:28 <merijn> gfixler: The answer why arguments must have kind * is fairly simple
02:37:33 <kgadek> allsystemsarego: hmr, no such file od directory, but ls usr/local/lib/libgmp* gives me some results
02:37:45 <merijn> gfixler: The language report doesn't allow you to define values that don't have kind *
02:37:55 <allsystemsarego> kgadek, what results?
02:38:09 <merijn> gfixler: Eh, actually, that's a confusing sentence, let me retry
02:38:19 * hackagebot ixset-typed 0.3 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-typed-0.3 (AndresLoeh)
02:38:21 * hackagebot references 0.1.0.0 - Generalization of lenses, folds and traversals for haskell  http://hackage.haskell.org/package/references-0.1.0.0 (lazac)
02:38:21 <gfixler> merijn: okay, though I feel like I've seen things of type (* -> *) in value constructors
02:38:27 <kgadek> allsystemsarego: https://gist.github.com/d1ebf31369aee5dc31f5
02:38:27 <allsystemsarego> the question mark wasn't part of the command, sorry
02:38:28 <merijn> gfixler: It's is impossible to create VALUES that have a TYPE that is not of kind *
02:38:37 <merijn> gfixler: Oh?
02:38:38 <gfixler> merijn: that i get
02:38:48 <gfixler> merijn: I'm sure I'm wrong that I've seen those
02:38:49 <frerich> The talk about record syntax reminds me - I recently had a case like http://lpaste.net/107948 where I wanted to bump a field of a value by one, and the field to bump depends on some other value. The code is somewhat ugly. I tried something like 'let field = longFieldName in x { field = field x + 1 }' but that didn't work either (since "field" is not a valid field name). I *suppose* lens would be an option here,
02:38:49 <frerich>  but I wonder whether there are other alternatives maybe?
02:39:16 <merijn> frerich: Lens is the alternative (or one of the other lens libraries)
02:39:36 <frerich> merijn: Yeah, my question was - are there *other* alternatives than lens :)
02:39:45 <allsystemsarego> kgadek, why have you not installed libgmp with yum?
02:40:09 <kgadek> allsystemsarego: well… "Package 1:gmp-5.1.2-2.fc20.x86_64 already installed and latest version"
02:40:14 <merijn> gfixler: If you explicitly annotate all kinds (you can do this in GHC/ghci too if you enable -XKindSignatures) you can write: "data Frank (a :: *) (b :: * -> *) = MkFrank (b a)"
02:40:25 <gfixler> I just realized that "Well, fields in ADTs are made to hold values" in the Frank examples is talking about algebraic data types
02:40:34 <gfixler> I've been thinking it meant abstract data types all the time
02:40:40 <gfixler> see? too much new all in one place
02:40:42 <merijn> gfixler: Ah :)
02:40:57 <gfixler> ADT is not used anywhere else, even when talking about abstract data types at the top of the chapter
02:41:25 <gfixler> I don't think the author gets how big of a leap all of the combinations of new things suddenly is, or I'm just slow :)
02:41:31 <merijn> gfixler: In haskell the way you create "abstract datatypes" is to just define an ADT and not export it's constructors
02:41:43 <merijn> (ADT meaning algebraic there)
02:41:45 <allsystemsarego> kgadek, it's probably best to start fresh, and install everything with yum, except ghc of course
02:42:09 <merijn> gfixler: I think it's a mix of both? You can usually get away with glossing over kinds for quite a while without running into trouble
02:42:47 <gfixler> merijn: can I go back to the "data Frank a b = MkFrank (b a)" example?
02:42:56 <gfixler> that seemed a nice, simple thing I could possibly grok soon
02:43:10 <merijn> gfixler: The main reason where kinds become relevant is when explaining why "Either a" is an instance of Monad, but "Either" is not (Either has kind * -> * -> * and Monad expects a type that has kind * -> *)
02:43:11 <kgadek> allsystemsarego: ok, no problem. I'll do that, but anyway that's the whole thing I'm doing: https://gist.github.com/c4d18b749d74eb8f6f9a nothing more, nothing less
02:43:18 <merijn> gfixler: Sure
02:43:43 <gfixler> something that I believe I'm wrong about, but which has been circling through my head
02:44:01 <gfixler> is that (b a) is function application, of b on a
02:44:12 <gfixler> but it's not, right? That's just a pair of two concrete types, that aren't necessarily related
02:44:27 <ski> it's application
02:44:43 <gfixler> ski: glad I asked then
02:44:50 <merijn> gfixler: An astute observation! Types behave a lot like functions, hence why kinds look like function type signatures!
02:45:01 <ski> `Either Int [Bool]' is `Either Int' applied to `[Bool]', e.g.
02:45:09 <gfixler> merijn: thanks, but I'm not quite sure how astute I'm being
02:45:15 <gfixler> I feel a bit like a random question generator currently
02:45:21 <ski> `Either Int' (and also `Either') is a type function
02:45:26 <ski> @kind Either Int
02:45:26 <merijn> gfixler: You can think of kind "* -> *" as a "type function" that takes a type of kind * and returns a new (different!) type of kind *
02:45:26 <lambdabot> * -> *
02:45:27 <ski> @kind Either
02:45:28 <lambdabot> * -> * -> *
02:45:36 <merijn> :k Maybe
02:45:37 <lambdabot> * -> *
02:45:40 <merijn> :k Bool
02:45:41 <lambdabot> *
02:45:45 <merijn> :k Maybe Bool
02:45:46 <lambdabot> *
02:45:48 <kgadek> allsystemsarego: okay, that's this: https://ghc.haskell.org/trac/ghc/ticket/7638
02:46:04 <gfixler> I actually think I've understood that part
02:46:25 <gfixler> what seems to be tripping me up is the swirl of a and b and pairs and data constructors and such
02:46:30 <allsystemsarego> kgadek, which fedora version are you using?
02:46:35 <kgadek> F 20
02:46:37 <merijn> gfixler: In fact, once you start messing with dependent types/haskell extensions you can even write actual type functions other than just type constructors (but ignore that for the rest)
02:46:41 <hyPiRion> gfixler: The trick for me was to replace the a's and b's with actual types
02:46:59 <gfixler> hyPiRion: right, I'm trying to get there with the MkFrank example
02:47:05 <kgadek> allsystemsarego: I'll try symlinking, hope that'll help
02:47:06 <gfixler> I want to replace the a and b with something tangible
02:47:16 <gfixler> i.e. concrete :)
02:47:19 <hyPiRion> e.g. Frank Int (Either String) -> MkFrank (Either String Int)
02:47:20 <merijn> gfixler: Like I said before, one can read "data Frank a b = MkFrank (b a)" as "data Frank a b where MkFrank :: b a -> Frank a b", that is, it defines two things at the same time
02:47:40 <merijn> gfixler: 1) A type constructor Frank of kind "* -> (* -> *) -> *"
02:47:42 <allsystemsarego> kgadek, yeah, symlinking works, but only as a "crutch" solution
02:47:51 <gfixler> hyPiRion: is that in the right order?
02:47:56 <merijn> 2) a DATA constructor of TYPE "b a -> Frank a b"
02:48:08 <ski> hyPiRion : that doesn't make much sense ..
02:48:28 <ski> (.. mixing types and values in the same expression)
02:48:29 <merijn> gfixler: Well, let's find out!
02:48:37 <hyPiRion> ski: yeah whoops.
02:48:46 <merijn> gfixler: If I write "Frank Int (Either Char)", what does the type of MkFrank become?
02:49:00 * hyPiRion leaves and grabs his morning coffee
02:49:14 <gfixler> merijn: I thought MkFrank is what became Frank, i.e. the former creates the latter
02:49:20 <merijn> Remember, "MkFrank :: b a -> Frank a b"
02:49:42 <merijn> gfixler: Right, so grab a pen and paper and start substituting variables in that type!
02:49:46 * gfixler is processing...
02:50:08 <merijn> gfixler: I gave you a concrete value for 'a' and 'b', you just need to fill them in the type and see what falls out
02:50:47 <kgadek> allsystemsarego: yeah, searching for solution right now. but as far as I can see there is no rpm providing that…
02:51:06 <gfixler> well, the thing that springs to mind, which is probably wrong, is that since the b and a reversee, then we have MkFrank getting (Either Char) and Int
02:51:23 <merijn> gfixler: What do you mean "and"?
02:51:28 <merijn> gfixler: There is no arrow
02:51:35 <gfixler> b a -> a b
02:51:53 <merijn> "(Either Char) Int -> Frank Int (Either Char)"
02:51:55 <gfixler> btw, this is specifically the thing that I'm falling down on
02:52:01 <gfixler> not * -> * -> * and all of that
02:52:11 <merijn> Which, after removing parenthesis is just
02:52:16 <merijn> "Either Char Int -> Frank Int (Either Char)"
02:52:34 <allsystemsarego> kgadek, try this when hunting for bizarre versions of packages: http://pkgs.org/
02:52:44 <merijn> gfixler: 'b' is, in this case, just a partially applied type constructor for Either
02:53:20 * gfixler processing... slowly...
02:53:38 <gfixler> I need to copy these into a text editor - there's too much noise
02:53:47 <merijn> "MkFrank :: Maybe Bool -> Frank Bool Maybe", "MkFrank :: Either Char Int -> Frank Int (Either Char)"
02:54:22 <merijn> "MkFrank :: [Int] -> Frank Int []" :)
02:54:26 <gfixler> I'm close to understanding this
02:54:31 <gfixler> not quite there, but getting very close
02:54:38 <gfixler> I appreciate the help, and the patience :)
02:55:22 <merijn> gfixler: Like I said before, the type arguments for Frank don't really have any direct relation to any potential values taken by the MkFrank constructor
02:55:48 <hyPiRion> gfixler: thanks for asking. Now I have no idea what this sorcery is and made me realise I don't really understand the type system at all.
02:55:50 <merijn> "data Mark a b = MkMark Int" "MkMark :: Int -> Mark Char Bool"
02:56:02 <gfixler> hyPiRion: I helped by hurting?
02:56:40 <hyPiRion> gfixler: hurting? No, now I realised I have something to learn :p
02:56:41 <gfixler> merijn: okay, so the inputs to the data constructor have no sway on the type constructed
02:56:54 <gfixler> hyPiRion: I helped by helping!
02:56:58 <merijn> hyPiRion: We just like type systems so much our type system has a type system! Except we call that one the "kind system"
02:57:42 <gfixler> merijn: I panicked on the drive home today, thinking "Wait... what if kinds has... 'varieties!?'"
02:57:54 <merijn> gfixler: They don't *necessarily* have sway on it, the entire thing needs to still typecheck. So in the Frank example the 'a' and 'b' are fixed by the value you pass to MkFrank, this relation is just not necessarily a direct one
02:57:56 <hyPiRion> merijn: Yeah, I've realised that. I just haven't comprehended what this actually means and how you can use it, I guess.
02:58:01 <merijn> gfixler: Kinds have sorts :p
02:58:09 <gfixler> NOOoooo!!!
02:58:20 <gfixler> when does it turn into turtles?
02:58:35 <merijn> gfixler: Don't worry, haskell supports only one sort and you can't write it in actual haskell code, so you can forget about them
02:58:44 <gfixler> merijn: I get the typecheck thing
02:59:20 <gfixler> merijn: that makes me feel like someone (SPJ?) thought "Ah ha! Another level!" and then ran into a dead end trying to make it happen.
02:59:23 <merijn> gfixler: Dependently typed languages actually have an infinite hierarchy of types, where "values have types, types have kinds, kinds have sort1, sort1s have sort2, etc."
02:59:48 <gfixler> hierarchy is a nightmare
03:00:01 <merijn> gfixler: It's just that haskell's type system doesn't really have a use for more levels, there are languages that use them, though
03:00:05 <gfixler> I've watched myself and everyone I've ever worked with completely screw up hierarchy
03:00:18 <gfixler> file hierarchies, code abstractions, JSON nestings
03:00:35 <merijn> gfixler: Ah, but our hierarchy has a sound formal basis, a proof why it's necessary and a proof of how you can safely automate it ;)
03:00:40 <hyPiRion> gfixler: but those hierarchies wasn't infinite, like this one I guess?
03:00:48 <gfixler> I've also noticed maybe 2 dozen times now that when I fix the layout of the hierarchy, based on deeper understanding, I can throw away up to 70% of the code
03:00:48 <hyPiRion> weren't*
03:01:07 <gfixler> so much code goes into dealing with levels and layers of things
03:01:11 <gfixler> extra, superfluous code
03:01:37 <merijn> gfixler: Actually, for typechecking it becomes easier because the general case of checking infinite levels is much more general than only checking a fixed number of levels :p
03:01:41 <gfixler> I realized I had a child/parent pairing backwards in a JSON file once, and fixing it obviated a 200 line module
03:01:56 <merijn> Anyway, I dunno if you still have questions, 'cause I'm about to run off to launch
03:01:59 <merijn> *lunch
03:02:01 <merijn> eh
03:02:05 <gfixler> oh, thought you were an astronaut
03:02:10 <gfixler> I think this helps a ton for the moment
03:02:14 <gfixler> super appreciated, too
03:02:36 <gfixler> helping someone with their haskell studies just before jumping in a rocket ship == hero
03:03:11 <gfixler> hyPiRion: not infinite, but we can make some awfully deep JSON files
03:03:15 <gfixler> I haven't been to the bottom of some of them
03:03:44 <hyPiRion> gfixler: or the rabbit holes some bugs create. Those are amazing
03:04:03 <gfixler> yep
03:05:13 <_0xAX> Hello all
03:05:30 <levi> Hello!
03:05:38 <gfixler> bittersweet moments, mixtures of elation, grokking just a bit more, and watching hundreds of lines of hard-won code evaporate, no longer needed, mixed with a feeling of dread, that none of us really has any idea what we're doing
03:05:56 <_0xAX> For example i have haskell library, can i pass function with module name to function from this library? Will application's function accessible from library?
03:07:44 <levi> Do you mean a module-qualified function being passed as a parameter to another function?
03:08:27 <gfixler> so if "MkFrank :: Either Char Int -> Frank Int (Either Char)"
03:09:03 <gfixler> what associates Either with Char?
03:09:11 <gfixler> function application?
03:09:19 <gfixler> type construction?
03:09:42 <gfixler> what makes that "(Either Char) Int"?
03:12:06 <BartAdv> I don;t want to confuse you more, but (at least in my case), dependently typed languages (Idris) helped understanding it, now I think of Either as a function from Type to Type to Type:)
03:13:07 <BartAdv> then if you can think of Type as any other value, same rules as with normal functions apply
03:13:14 <ski> gfixler : type function application
03:13:38 <gfixler> BartAdv: I somewhat understand that
03:14:05 <ski> and i suppose you can think of it as type construction as well, since `Either' is a type constructor
03:14:15 <gfixler> ski: yeah, that's where I was heading
03:14:25 <hyPiRion> I found another thing which now confuses me immensely
03:14:33 <hyPiRion> :t (0 "")
03:14:34 <gfixler> hyPiRion: uh oh, dominoes
03:14:34 <lambdabot> Num ([Char] -> t) => t
03:14:57 <_0xAX> levi: Hello, look i have self-written library, now i want to use it's library in application, in this application i have a module Module.Mod for example with 'foo' function, if i'll pass Module.Mod.foo to the librariy's function can i call it from there
03:15:02 <hyPiRion> no idea what in the world that is, or why it's even legal
03:15:11 * hyPiRion heads off to launch as well.
03:15:36 <ski> (that in particular means that if `Either a0 b0` is equal to `Either a1 b1', then `a0' is equal to `a1', and `b0' is equal to `b1' -- this is because `Either' is a type constructor, more specifically because it's injective)
03:15:37 <BartAdv> hah, that's cool, now I am wondering whether I should ponder the awesomness of this, or launch as well
03:15:38 <gfixler> hyPiRion: that makes no sense to me
03:16:14 <ski> hyPiRion : functions could possibly be treated as numbers
03:16:23 <levi> _0xAX: If I understand you correctly (which I'm not sure yet I do) then the answer is yes.
03:16:46 <ddrone> Hi. Is there a way to debug Parsec parser? I want to know what are the alternatives parser is using when parsing particular string
03:17:14 <Pythonfant> hyPiRion: it's the same as 0 "" so you apply 0 to "" the literal needs to be Num a so 0 is a function [Char] -> t and needs a num instance
03:17:18 <_0xAX> levi: thank you for the answer, lazy to test it, thought maybe somebody met something like this, anyway need to test
03:42:29 <killy9999> Fuuzetsu: you're responsible for haddock, right?
03:42:50 <killy9999> Fuuzetsu: do you have a set of benchmarks that allows to measure its performance?
03:43:50 <Fuuzetsu> No but 99% of computation seems to be done on the GHC side so if that gets slower then so will Haddock
03:44:28 <Fuuzetsu> there are validate perf numbers if that's of interest to you
03:45:39 <Fuuzetsu> I hope to fix the memory problem we have for next release though
03:47:08 <T_X> anyone familiar with the haskell gtk bindings? I'm trying to get a simple resize-to-screen-size working but wasn't successfull so far
03:47:43 <T_X> pixbufNewFromFileAt [...] works fine. but resizing thinks later doesn't
03:48:44 <T_X> "pixbufScale pb1 npb1 0 0 w h 0 0 0.5 0.5 InterpBilinear" results in a smaller picture but has two issues for me:
03:49:29 <T_X> the image is not centered anymore. nor is it aligned to the top left corner
03:49:52 <T_X> instead some pixels are cropped from the left and top sides
03:52:07 <T_X> and then it looks like the pixels of the last rectangle of the image are duplicated endlessly outwards. looks weird :)
04:02:36 <_0xAX> levi: you was right :) tested and it works
04:04:52 <killy9999> Fuuzetsu: thanks
04:16:37 <T_X> hm, going to try this approach, let's see whether that'll work out instead: https://stackoverflow.com/questions/5287622/haskell-gtk-double-buffering-with-primitives
04:27:14 <arancia> T_X: I'd try with Cairo: read an image from file, draw it on a surface and then scale the whole surface
04:50:43 <mp> hello, a simple question about persistent: I'd like to externalize query to external module, for example getPopularPosts = selectList [filters] [LimitTo 10, PostViews Desc] in such a way that it returns m [(Entity Post)]; how to properly define type of getPopularPosts?
04:55:40 <frerich> Is anybody aware of a database format (+ Haskell API) suitable for storing 'records' of data consisting of 1+ files and two strings? I rolled my own filesystem-based database for now which hashes things and then has one directory per hashsum within which all the files and the two strings are stored.
04:55:56 <Hodapp> 1+ files and two strings?
04:56:01 <Hodapp> that seems awfully specific
04:56:02 <frerich> It's simple, but I need to take care of atomic updates (currently done via lock files) and cache consistency myself.
04:56:27 <Hodapp> first thing I'd think of is SQLite.
04:57:31 <frerich> hodapp: To be more precise, I think I need something like a document-based DB where a 'document' consists of 1-5 files with an average total size of 1.5MB and then two strings with description text.
04:59:32 <Freinn> hi
04:59:53 <Freinn> I'm stating with Haskell and having some problems with examples in a book
04:59:59 <Freinn> compiling problems
05:00:50 <Freinn> hi?
05:00:50 <Freinn> xD
05:01:21 <frerich> Freinn: Well, you could proceed to paste whatever source code and compiler errors you're dealing with at lpaste.net :)
05:01:40 <alpounet> Freinn: just state your question directly :) you don't need to wait for someone to tell you you can elaborate. just paste your code as frerich suggests and the error you have
05:02:12 <Freinn> ok ty I will
05:02:35 <Freinn> http://lpaste.net/107949
05:05:12 <Freinn> edited
05:05:58 <Freinn> then, is this a good book to start?? Or maybe is best to follow CIS194??
05:06:20 <Freinn> the book was great but I had problems with understanding foldr and foldl
05:06:35 <Freinn> and now compiling problems with that sample code
05:07:17 <frerich> Freinn: Did you write 'item' yourself? If so, can you also give the definition of that function?
05:07:38 <Freinn> item :: Parser Char item = \inp -> case inp of                   [] -> []                   (x : xs) -> [(x , xs)]
05:07:51 <Freinn> sorry I will copy in the webpage
05:07:54 <Freinn> I edit
05:08:09 <killy9999> do we have a documentation of the simplifier somewhere on the wiki?
05:08:22 <killy9999> sorry, wrong channel
05:08:26 <Freinn> done
05:08:36 * hackagebot Spock 0.6.1.2 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.1.2 (AlexanderThiemann)
05:08:55 <frerich> Freinn: Did you write the Monad instance for Parser yourself?
05:10:18 <Freinn> all of them where examples on the book
05:10:27 <Freinn> Programming in Haskell
05:10:30 <Freinn> chapter 8
05:10:33 <Freinn> I copy all my code
05:10:35 <Freinn> I edit
05:11:00 <frerich> That's a pretty nice book IMHO.
05:11:27 <Freinn> is nice, but for a noob??
05:11:38 <Freinn> some parts are not so clear at least for me
05:11:41 <frerich> I think it's especially nice for somebody who never had any exposure to Haskell before.
05:11:49 <Freinn> xD
05:12:02 <frerich> At least I wish it would've been my first book.
05:12:16 <Freinn> you had problems understanding monads and foldr and foldl?
05:12:27 <Freinn> I did...xD
05:12:31 <frerich> Sure
05:18:22 <kvanb> They should teach folds as reduce to start off
05:18:24 <kvanb> in my opinion
05:18:33 <kvanb> it feels like a more natural way to reason *when* to use them
05:18:37 * hackagebot shakespeare 2.0.1.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.1.1 (MichaelSnoyman)
05:18:48 <kvanb> which is what you actually need to do ... reason when to use them, not when to use either one
05:19:00 <kvanb> should prettymuch never use foldl anyway
05:20:17 <Freinn> I know how to do (easy) things withouth them
05:20:26 <Freinn> and super easy ones with them
05:20:32 <frerich> kvanb: I suppose it didn't help that some exercises in RWH are actually easier when using foldl
05:20:34 <TheKing444> > 0
05:20:36 <lambdabot>  0
05:21:59 <frerich> kvanb: I remember there was an exercise early on about writing an 'asInt :: String -> Integer' function using a fold (but you got to choose which fold). I was quite irritated that they first talked about the issues with foldl only to then provide an exercise which is much easier if you use foldl.
05:22:22 <kvanb> why is it easier if you use foldl
05:23:08 <frerich> kvanb: because you don't have to reverse anything
05:24:09 <amf> with parsec, is there a way to condense a parser from the do notation something shorter line wise while yanking out fields im interested in?
05:25:01 <amf> i know all my fields are separated by spaces, but i need to extract the data
05:26:53 <mmmm> yes amf
05:27:12 <bergey> amf: The Parser type has an Applicative instance, so you can write `MyConstructor <$> subParser <*> anotherSubParser :: Parser MyType`
05:27:13 <quchen> amf: Applicative style?  MyData <$> foo <* space <*> bar <* space <*> baz
05:27:52 <quchen> That's equivalent to `do { x <- foo; space; y <- bar; space; z <- baz; return (MyData x y z) }`
05:28:56 <amf> thanks! haskell just keeps getting cooler and cooler
05:28:59 <bergey> quchen: needs parens around (foo <* space)
05:29:28 <mmmm> or you can do foo <* space *> bar iirc
05:29:43 <quchen> bergey: Does it?
05:30:13 <bergey> I think so.  <* and <*> have the same precedence, and I usually get type errors when I do that sort of thing without parens.
05:30:28 <quchen> :t \foo space bar baz -> (,,) <$> foo <* space <*> bar <* space <*> baz
05:30:29 <lambdabot> Applicative f => f a2 -> f b -> f a1 -> f a -> f (a2, a1, a)
05:30:31 <quchen> Looks right to me
05:30:38 <bergey> I start corrected
05:30:45 <bergey> s/start/stand/
05:31:08 <quchen> I think I know the error you're talking about though, sometimes you need parentheses in Applicative style. I don't remember when, but it happened to me as well.
05:31:37 <tdammers> mixing infixr and infixl operators?
05:32:19 <quchen> All the <...> operations are infixl4 though
05:32:54 <amf> is it then possible to reduce the applicative style using sepBy? (im going to have lines that have 70+ fields
05:33:05 <quchen> 70+ fields?!
05:34:02 <rmk_> Hey. Do you guys know of a matplotlib-style library usable in Haskell
05:34:08 <quchen> Well, if they're 70 fields that should all parse to the same type (in order to make a list of entries, for example) then sepBy is the way to go.
05:34:23 <quchen> Or one of the other "separation" family functions.
05:34:29 <frerich> If you have 70 fields separated by spaces, you could just use 'words'.
05:34:48 <amf> they are all very different and complex types
05:34:51 <quchen> frerich: That will just split the input, not parse the fields though.
05:35:32 <quchen> amf: Looks like you'll end up with a 70+ line parser.
05:35:58 <quchen> Usually I subdivide my data types into smaller chunks when I have lots of fields.
05:36:22 <quchen> So the individual parsers do maybe ten fields max, and then those parsers are combined into bigger ones.
05:37:16 <amf> i like that approach. certainly better than our 15k+ C code approach
05:37:31 <quchen> For a parser?
05:37:45 <amf> yes. thats only main() too
05:38:01 <quchen> 15k sloc main()?
05:38:01 <frerich> I really wonder what kind of data you're parsing...
05:38:33 <k00mi> rmk_: easyplot is good for fast and simple, plot is more sophisticated
05:38:34 <quchen> frerich: That open Microsoft XML format maybe
05:38:46 <frerich> quchen: :->
05:39:04 <amf> log data from a cdn company
05:39:39 <tdammers> still, 15k lines sounds like you're doing something wrong there
05:39:47 <tdammers> even in C
05:39:50 <frerich> amf: So each line is a log entry and then you have a data type 'data LogEntry = LogEntry <70+ fields here>'? :-}
05:40:25 <amf> which is why im teaching myself haskell / parsing to prototype better ways
05:41:27 <cin> 15k sloc main()? -- now you're thinking in C
05:41:49 <rmk_> k00mi: That looks like exactly what I am looking for. Many thanks
05:43:09 <amf> legacy + needing to parse petabytes of data a day + 10 or so line types that have anywhere from 2 to 70 fields will do that
05:43:40 * hackagebot tzdata 0.1.20140612.0 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20140612.0 (MihalyBarasz)
05:44:21 <quchen> The amount of data processed should in no way be correlated to the length of your main function (or any function, for that matter).
05:44:31 <quchen> I think you can stop that sentence after "legacy" :-þ
05:45:19 <frerich> amf: Maybe the structure of those '70 fields' lines can be exploited, e.g. it might be something like 'first field decides how many fields follow'?
05:46:04 <frerich> Or a certain order of fields is repeated (like "timestamp string number"), which you could factor out -- basically what quchen suggested?
05:46:15 <quchen> The proper(er) way to do this would be to write individual parsers for each of the possible fields (separate functions!), and then combine those to get a parser for different line shapes, and then combine that multiple times to get a parser for many many lines.
05:47:01 <quchen> Do you have an example line of such a log by the way?
05:47:08 <amf> quchen: thats my plan
05:47:28 <amf> quchen: not unless i want to break my nda
05:47:30 <quchen> Apache logfiles are kind of similar to what you're describing, but parsing that can be broken down into very small pieces.
05:48:21 <quchen> I'd rather not incriminate you over an IRC discussion amf ;-)
05:49:34 <Freinn> bb
05:49:53 <benzrf> amf: wait so
05:49:59 <benzrf> are you writing the parser in haskell
05:50:03 <benzrf> or just prototyping?
05:51:30 <amf> benzrf: prototyping + teaching myself hs
05:53:41 * hackagebot http-conduit-downloader 1.0.20 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.20 (VladimirShabanov)
06:07:11 <Jeanine21>  Here some videos. I hope you like them! http://j.mp/1kEo7j0
06:10:12 * frerich won't even bother clicking some scrambled URL about 'videos' by 'Jeanine21'
06:11:46 * friden agrees
06:14:58 <Hodapp> frerich: probably a wise choice, since it just links to www.hotxgirls.net.
06:18:45 * hackagebot casadi-bindings-core 1.9.0.5 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-1.9.0.5 (GregHorn)
06:18:47 * hackagebot casadi-bindings 1.9.0.5 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-1.9.0.5 (GregHorn)
06:33:47 * hackagebot Plot-ho-matic 0.4.0.0 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.4.0.0 (GregHorn)
06:38:13 <suppi> I need some help with cabal problems :(
06:38:22 <suppi> http://lpaste.net/3107084796258418688
06:39:28 <suppi> I just deleted haskell-platform and installed ghc 7.8.2 with:
06:39:29 <suppi> sudo apt-get install cabal-install-1.20 ghc-7.8.2 happy-1.19.3 alex-3.1.3
06:40:25 <benzrf> suppi: don't install cabal-install with apt-get
06:40:28 <benzrf> install it with cabal-install
06:40:44 <benzrf> suppi: don't ask me how to bootstrap it, if you don't know how that just means that you're not ready for haskell
06:40:56 <prooftechnique> :/
06:41:09 <benzrf> (hint: let is recursive)
06:41:25 <suppi> ... what?
06:41:28 <prooftechnique> I hope that's a joke
06:42:04 <frerich> Ah, fclabels is pretty sweet! Lightweight and useful!
06:42:11 <benzrf> suppi: ok fine the answer is:
06:42:18 <merijn> benzrf: That's not very constructive
06:42:26 <benzrf> let cabalInstall = cabalInstall "cabal-install"
06:42:35 <benzrf> simple
06:42:56 <benzrf> suppi: yes it's a joke :p
06:43:15 <suppi> not very funny I must say
06:43:34 <benzrf> it's funny to me :[
06:43:36 <merijn> suppi: What I usually do when installing on linux (keep in mind, I don't have admin rights or a package manager on those machines) is install GHC from the pre-built binaries on the GHC site and then build cabal from source and from there on do everything with cabal
06:43:58 <benzrf> ^is proably a good idea if you dont have root
06:44:03 <benzrf> suppi: that apt-get looks fine to me
06:44:17 <suppi> merijn, alright, thanks. I just followed the ubuntu getting started from here https://github.com/bitemyapp/learnhaskell
06:44:27 <benzrf> suppi: why not the Platform?
06:44:46 <mr-> suppi: it seems like the package is broken.
06:44:49 <merijn> suppi: To be honest, it just looks like the version of MonadCatchIO-mtl you're installing has a bug
06:44:56 <suppi> it comes with older cabal and ghc, didn't like using cabal-dev instead
06:45:00 <benzrf> merijn++
06:45:06 <suppi> merijn, that's what I thought :\
06:45:06 <merijn> suppi: or rather, doesn't support your version of GHC
06:45:16 <merijn> suppi: The good news is, it looks like it's fairly minor
06:45:18 <benzrf> suppi: have you tried installing a newer version of ghc
06:45:38 <suppi> benzrf, newer than 7.8.2?
06:45:41 <benzrf> oh
06:45:42 <benzrf> lol
06:46:13 * benzrf wishes his ghc was that new
06:46:19 <mr-> Weird.. extensible exceptions does export E.block and E.unblock
06:46:35 <mmmm> The problem is that MonadCatchIO-mtl doesn't work with ghc 7.8.2
06:47:10 <suppi> mmmm, so I need to install an older version of ghc in order to use it?
06:47:11 <merijn> suppi: Try installing monadcatchio-mtl version 3.1? It looks like that's rather different from 3.0.5, so maybe the bug was fixed (although maybe whatever you were trying to install doesn't work with that version yet)
06:47:28 <mr-> mmmm: do you know why? It's not using anything funky.
06:47:43 <suppi> merijn, i'll try that. thanks.
06:47:50 <SrPx> Is there any library to synchronise Haskell values between server and a web client? Ie, suppose I create an online game logic in Haskell. How do I send the info to the clients? Do I have to code the networking? It would be much better to determine that certain values are visible to the client...
06:48:04 <merijn> suppi: Well, the problem is that not everything on hackage supports the bleeding edge, it can take a while for ecosystems like happstack to catch up
06:48:13 <merijn> SrPx: Look into cloud haskell?
06:48:42 <SrPx> merijn: sure, thanks!
06:48:50 <benzrf> SrPx: there's things like mflow, but i doubt that that's what you want
06:49:12 <SrPx> I will take a look, thanks (:
06:53:08 <latk> Is there a problem with having a cabal file that defines two executables, one of which looks at the source of the other ? (e.g. as a test executable
06:53:09 <latk> )
06:53:13 <suppi> merijn, thanks for your advice, installing 3.1 fixed it :)
06:54:44 <suppi> thanks to everyone who tried to help
07:03:50 <hexagoxel> latk: i don't think so. i currently use two executables that contain the exact same set of modules (only difference are the flags). or do you mean something else by "looks at the source of the other"?
07:07:43 <latk> hexagoxel: No, that is what I mean. I'm struggling to get tests set up, to be honest, and just trying different things at this point.
07:08:09 <latk> Is it possible for an executable to have "exposed-modules" ? If not, how are you supposed to set up tests for an executable?
07:09:24 <alpounet> the test can import the modules used by your executable
07:09:36 <alpounet> and is itself an executable, just a special one
07:09:50 <latk> alpounet: Is there some special way that I have to do this? Currently it can't see them.
07:09:58 <merijn> latk: It isn't, the usual approach I would take is the following: Shove all your functionality in a library, have a shell executable that just calls out to your library and test the library?
07:10:15 <alpounet> latk: merijn just described the ideal (and easiest) approach
07:10:23 <latk> merijn: Yeah, this is the direction I seem to be being pushed :P
07:10:36 <latk> when the cabal wizard asked if it was an executable, I just said yes..
07:10:44 <alpounet> but you can also just really directly import modules from your executable in your test
07:10:57 <alpounet> just make sure the hs-source-dirs field of the test contains the directory of your executable's code
07:11:50 <alpounet> that also means your test will depend on a lot of the same libraries that your executable depends on, it's ugly etc but works. the best approach here is the one described by merijn though
07:12:34 <latk> alpounet: Hm, okay then. I suppose I will transition to lib + executable + tests
07:42:39 <Tjr> @let { x :: a; f :: (a -> b) -> b  ; f = ($ x) }
07:42:40 <lambdabot>  .L.hs:147:1:
07:42:40 <lambdabot>      The type signature for ‘x’ lacks an accompanying binding
07:42:40 <lambdabot>        (The type signature must be given where ‘x’ is declared)
07:43:22 <Tjr> @let { x :: a; makef :: a -> (a -> b) -> b  ; f x = ($ x) }
07:43:23 <lambdabot>  .L.hs:147:1:
07:43:23 <lambdabot>      The type signature for ‘x’ lacks an accompanying binding
07:43:23 <lambdabot>        (The type signature must be given where ‘x’ is declared)
07:43:23 <lambdabot>  
07:43:23 <lambdabot>  .L.hs:149:1:
07:45:05 <Tjr> @let {makef :: a -> (a -> b) -> b  ; makef x = ($ x) }
07:45:05 <Tjr> Suppose I know  f = makef x. How do I get the x back?
07:45:05 <lambdabot>  .L.hs:149:1:
07:45:05 <lambdabot>      Duplicate type signatures for ‘makef’
07:45:05 <lambdabot>      at .L.hs:147:1-5
07:45:05 <lambdabot>         .L.hs:149:1-5
07:45:11 <Tjr> @undefine
07:45:11 <lambdabot> Undefined.
07:45:35 * Tjr redefined.
07:46:02 <Tjr> So if I only have f, is there a way to get x back?
07:46:33 <hexagoxel> f id
07:46:46 <Tjr> hexagoxel: doesn't typecheck id:: a-> b
07:47:09 <pjdelport> a -> a is just a special case of a -> b
07:47:33 <Tjr> pjdelport: in my application, that's the uninteresting case
07:47:57 <hexagoxel> but you want x back, and x has type a
07:48:33 <zq> Tjr: there is no "un-app" operator, if that's what you have in mind
07:48:58 <zq> Tjr: why can't you just pass x? haskell is referentially transparent, you know
07:49:52 <quchen> > let f = ($ 3) in f id -- Looks good to me.
07:49:54 <lambdabot>  3
07:50:15 <ReinH> quchen: yay continuation passing
07:50:28 <Tjr> I'm trying to understand a certain monad that resembles continuations, and as an exercise I'm trying to figure out the >>= by myself
07:50:43 <quchen> ?check \x -> let f = ($ x) in f id == (x :: Int)
07:50:45 <lambdabot>  +++ OK, passed 100 tests.
07:50:52 <quchen> ReinH: Well, very small continuation
07:51:03 <ReinH> well yes
07:51:35 <quchen> > let f = return 3 in runCont f id
07:51:36 <quchen> :>
07:51:37 <lambdabot>  3
07:52:29 <ReinH> Cont is the same
07:53:06 <Tjr> http://lpaste.net/107962
07:53:37 <ReinH> Cont is literally flip ($) :p
07:53:58 * hackagebot udbus 0.2.1 - Small DBus implementation  http://hackage.haskell.org/package/udbus-0.2.1 (VincentHanquez)
07:53:59 <av> Hi everyone, I'm trying to make a cabal package for a FFI bindings that use a library shipped with the cabal package -- is that possible?  I'm at the point where I have to specify where the shared object is that I'm using through FFI (in normal ghc parameters, this would be "-Lsomething") and don't know what to do.
07:54:01 <quchen> Not literally, really. It's equivalent.
07:54:15 <quchen> "Literally" would be `Cont = ($)`.
07:54:24 <quchen> But I get your point.
07:54:50 <quchen> I could make the above example even more conty by using `cont`. Left as an exercise to the reader.
07:55:07 <Tjr> I'm trying to figure out why the >>= is defined the way it is. Note that a and VE w are "never" the same type, so zq's solution doesn't apply
07:55:35 <Tjr> as a stepping stone, I tried to find an inverse of return.
07:55:35 <ReinH> looks like codensity specialized at whatever VE is
07:56:41 <Tjr> m = return x
07:56:43 <Tjr> becomes
07:56:51 <Tjr> runEff m = ($x)
07:57:05 <Tjr> and somehow, I can't solve for the x
07:58:08 <ReinH> In ($m), the m is hidden away as part of the suspended computation. You can only get it out by passing the id continuation.
07:58:41 <ReinH> otherwise it's encapsulated by a function, and functions are opaque.
07:59:05 <b_jonas> oh, is this about Cont ?
07:59:21 <friden> I have a question about frameworks, more specificly how to design them. I'm used to program in java and there it's easy to make a jar that's running logic that calls methods like onEvent1, onEvent2 etc, and the developer using that framework can override these functions to code the wanted behavior into the program. How do i make something similar in haskell? As i can't override functions (or can i?) i have to either send them to the framwork as 
07:59:32 <friden> what is the recommended or most used tactic for this?
07:59:35 <Tjr> b_jonas: probably
08:00:00 <b_jonas> ok
08:00:29 <Tjr> http://okmij.org/ftp/Haskell/extensible/exteff.pdf
08:00:51 <zomg> friden: I'm not a big expert, but something I think could work is you could pass a data type containing your callbacks into the function or something
08:01:10 <Tjr> I'm stuck trying to understand the Eff monad on page 4
08:02:33 <friden> zomg: yeah that was one of my thought, but it seems kind of messy
08:02:42 <ReinH> friden: you don't need to define functions to be referenced later by name when you can construct and pass functions around first class.
08:03:33 <ReinH> The style you're referencing is used to get around a limitation that Haskell doesn't have, so it doesn't make sense to copy it.
08:04:24 <merijn> friden: Well, first off, why are you wanting to override functions? What is your actual use case?
08:05:49 <frerich> friden: What you describe sounds like callbacks, i.e. some code calls a function and provides a couple of callbacks which the function uses in its definition. You can do the same in Haskell by just passing a function as an argument.
08:06:26 <friden> merijn: my actual use case is me creating an IRC framework, and i want developers to use it and implement behavior for events like private messages, channel messages, pings, invites, joins etc
08:06:50 <friden> but i dont want the user to send callback functions for all of these when starting the framework
08:07:04 <friden> the user may only want to listen to joins and pings for example
08:07:22 <merijn> friden: Wouldn't it be nicer to use threads and Chan's?
08:07:23 <friden> and i dont want to have a function taking 30 callback functions as arguments xd
08:07:35 <friden> merijn: i use threads and chans already
08:07:56 <friden> but that is for the communication, all that is done. now i want to design the framweork to be useable for developers
08:08:00 <merijn> friden: You just write all events to a Chan and all callbacks are just functions of type "Chan a -> IO ()" (i.e. they just run in their own thread)
08:08:24 <merijn> So plugin developers can just listen to whichever event they want on the Chan
08:08:37 <friden> oh, you mean like that
08:09:11 <Exio> friden, get a datatype that contains all the callbacks?
08:09:16 <friden> so i add another layer of chans that is accessable to the developer, and i "broadcast" the events that i want them to be able to listen to, and gives them a copy the channel
08:09:20 <frerich> friden: alternatively, you could.. yeah, what Exio said.
08:09:27 <friden> then they can patternmatch the events they want to use?
08:10:27 <friden> oh, its a different way of thinking that im not used to doing java framweorks^^
08:10:41 <merijn> friden: Something along those lines, yeah
08:10:54 <friden> but i see what you mean, ill try that and come back if it totally breaks, thanks :)
08:11:19 <merijn> friden: dupChan creates a copy of an existing Chan (i.e. any write to the original channel will end up inside the Chan returned by dupChan too)
08:12:19 <friden> merijn: yeah i've done stuff with chans before, but thanks
08:12:58 <merijn> friden: Alternativelly, a plugin consists of "plugin <- IRCEvent -> IO ()" and then you have your code dupChan an event channel and do "forever $ do val <- readChan x; plugin val", or something like that
08:13:22 <merijn> (obviously, allowing plugins to run IO is horrifically unsafe if you don't trust the plugin, but I guess you knew that already)
08:14:10 <merijn> "plugin :: IRCEvent -> IO ()", even
08:14:55 <friden> merijn: yeah, i could do that too^^
08:15:02 <friden> maybe ill try both
08:44:00 <mr-> friden: another way to avoid 30 callback functions is to have only a couple of callback functions, but also callback types. (in principle, you could have one callback functions defined on a sum type of 30 summands)
08:44:52 <mr-> the user could then just define his function for all those he cares about and have a foo _ = Default as the last case
08:45:31 <monochrom> that is so like system calls :)
08:46:11 <mr-> (a balance between those two is probably something I would aim for)
08:58:45 <mr-> Heh.. singletons has great docs: Foldr k z a_1627849112 = Apply (Let_1627849117GoSym3 k z a_1627849112) a_1627849112
09:01:50 <Exio> how could i make a "reduced-IO" monad? (i'd want an 'IO monad' with just a few functions that need IO)
09:02:38 <c_wraith> Exio: newtype Reduce a = Reduced (IO a), don't export the constructor.
09:02:39 <cin> newtype RIO a = RIO { runRIO :: IO a } deriving (Functor,Monad)
09:07:36 <zereraz> hello everyone, is there a general way to iterate over a list?
09:08:07 <pjdelport> zereraz: map?
09:08:17 <JHaas> zereraz, use map
09:08:24 <zereraz> I know about map
09:08:26 <Exio> or filter, or fold(lr)... what do you want to do with the list?
09:08:33 <benzrf> Exio: you could also use free monads
09:08:38 <pjdelport> zereraz: There are a bunch of other approaches, depending on what kind of generality you want, exactly.
09:08:42 <zereraz> I want to implement filter using map
09:08:47 <khyperia> the "super duper general" way is probably a recursive patternmatch, as it allows you to do mostly everything, but you really should use a higher order function.
09:08:51 <benzrf> zereraz: good luck
09:08:52 <JHaas> then use filter
09:08:54 <zereraz> so is there a way to put an if condition in map?
09:08:56 <pjdelport> zereraz: For example Foldable / Traversable
09:09:03 <benzrf> zereraz: do you understand what map does
09:09:14 <JHaas> zereraz, use filter
09:09:19 <Exio> free monads? will check
09:09:21 <zereraz> I want to implement a filter
09:09:26 <zereraz> not use filter directly
09:09:43 <JHaas> zereraz, a code snippet may help
09:09:47 <allsystemsarego> @src filter
09:09:47 <lambdabot> filter _ []     = []
09:09:47 <lambdabot> filter p (x:xs)
09:09:47 <lambdabot>     | p x       = x : filter p xs
09:09:47 <lambdabot>     | otherwise = filter p xs
09:09:51 <JHaas> otherwise, I'd suggest filter
09:09:52 <pjdelport> zereraz: map transforms each element separately, but you can use foldr to implement several kinds of transformations.
09:10:04 <pjdelport> Why don't you want to use filter?
09:10:18 <monochrom> please be specific what you want accomplished.
09:10:21 <zereraz> because I want to know how to create one
09:10:24 <Exio> zereraz, if you want to implement filter, you can use a fold or the "recursive function"
09:10:38 <zereraz> 1 more thing
09:11:03 <rio> cin: what if i don't want to be a type?
09:11:04 <zereraz> in map does the map function apply the other function on list one at a time or at once
09:11:25 <zereraz> map function [1,2,3,4]
09:11:43 <c_wraith> zereraz: map is productive/lazy
09:11:50 <zereraz> i was trying like map (:[])[1,2,3,4]
09:11:51 <pjdelport> zereraz: map just applies the function structurally; which order things get evaluated in depends on which order you consume the result. (They might not get evaluated at all if you don't use them.)
09:11:59 <c_wraith> > map (*2) [1,2,undefined)
09:12:00 <lambdabot>  <hint>:1:24: parse error on input ‘)’
09:12:05 <c_wraith> > map (*2) [1,2,undefined]
09:12:07 <lambdabot>  [2,4,*Exception: Prelude.undefined
09:12:13 <c_wraith> > take 2 $ map (*2) [1,2,undefined]
09:12:14 <lambdabot>  [2,4]
09:12:25 <zereraz> ok so I won't be able to sequentially traverse through map
09:12:45 <c_wraith> I don't even know what you mean by that
09:12:55 <khyperia> zereraz, sounds like you're wanting a fold, but your terms are a bit weird.
09:13:15 <JHaas> fold or filter
09:13:19 <pjdelport> zereraz: If you want to learn how to implement map and filter generally, it's probably a good idea to look at how to implement both of them using both direct recursion and using foldr.
09:13:21 <zereraz> khyperia: I will look into what it does
09:13:32 <pjdelport> zereraz: Both map and filter are special cases of foldr
09:13:43 <zereraz> pjdelport: ok will do
09:14:26 <pjdelport> zereraz: You can think of foldr as "replacing the (:) and [] constructors" of the list.
09:14:53 <rpglover64> So I'm trying to write a function of type equivalent to "Foo -> Either (Either Bar Baz) Foo" (where Bar is the type of a negative result and Baz is the type of a positive result) and use it as a step function; that is, call it repeatedly with its output as its input until I get an answer. I seem to recall this as a pattern somewhere (to do with free monads or something, but I can't remember where).
09:15:01 <pjdelport> So as a starting point, consider that foldr (:) [] is an identity function for lists. (It just replaces (:) with (:), and [] with [].)
09:15:22 <pjdelport> Then, think of how you need to modify foldr (:) [] to get the behavior of map and filter, respectively.
09:16:11 <zereraz> ok thanks
09:16:27 <zereraz> foldr seems like traversing
09:16:32 <genericpersona> rpglover64: maybe unfold?
09:16:59 <monochrom> map f [1,2,3,4] = [f 1, f 2, f 3, f 4].
09:17:21 <zereraz> yeah
09:17:30 <allsystemsarego> > map f [1,2,3,4] :: {Expr]
09:17:30 <genericpersona> rpglover64: unfold p h t x | px = [] | otherwise = h x : unfold p h t (t x)
09:17:31 <lambdabot>  <hint>:1:21: parse error on input ‘Expr’
09:17:36 <allsystemsarego> > map f [1,2,3,4] :: [Expr]
09:17:37 <lambdabot>  [f 1,f 2,f 3,f 4]
09:17:49 <genericpersona> sorry, p x not px
09:17:51 <pjdelport> zereraz: foldr gives a very general way of structurally transforming a list.
09:18:11 <zereraz> we don't have loops in functional programming right?
09:18:33 <genericpersona> zereraz: there are loops but via recursion
09:18:37 <allsystemsarego> zereraz, only recursion that emulates loops
09:18:41 <pjdelport> zereraz: Generally speaking, loops are a special case of tail recursion. :)
09:18:47 <zereraz> yeah with recursion
09:19:09 <zereraz> pjdelport: tail recursion?
09:19:34 <genericpersona> zereraz: meaning you only need one stack frame at a time to evaluate the function
09:19:46 <rpglover64> genericpersona: I'm trying to remember the pattern of the data types...
09:20:18 <genericpersona> the function i gave you take a predicate p, a head function h, a tail function t and an accumulator value x
09:20:19 <pjdelport> zereraz: Tail recursion is when a function directly calls itself recursively (as opposed to structural recursion or indirect recursion).
09:20:28 <genericpersona> if p x is true, unfold stops
09:20:46 <zereraz> ok got it
09:20:47 <zereraz> thanks
09:20:50 <genericpersona> otherwise, you apply h x and cons it to the result of unfold with x replaced by t x
09:20:54 <genericpersona> it's a great pattern :)
09:21:06 <pjdelport> let loop ... = if condition then finalResult else loop ...
09:21:18 <zereraz> nice
09:21:21 <genericpersona> yeah, pretty much
09:21:28 <zereraz> still learning the basics
09:21:35 <zereraz> very interesting
09:22:13 <genericpersona> rpglover64: in Data.List there is also unfoldr which builds a list starting from a seed value
09:22:34 <genericpersona> rpglover64: you might also look at iterate
09:23:13 <genericpersona> iterate f = unfold (const False) id f
09:23:16 <rpglover64> genericpersona: I get how the unfold works; the question I'm trying to answer is not really "how do I solve this problem" but "which of the advanced haskell techniques I've read about is this an instance of"
09:23:29 <genericpersona> oh
09:24:05 <genericpersona> rpglover64: on haskell.org/hoogle you can search based on type signature
09:24:43 <rpglover64> genericpersona: I'm aware. I don't remember the exact types.
09:28:48 <nibblediz> Hi, is there any implementation of this? https://ghc.haskell.org/trac/ghc/wiki/PolymorphicDynamic
09:30:20 <pjdelport> rpglover64: The general name for that kind of function on algebraic data types is an anamorphism.
09:30:35 <pjdelport> rpglover64: foldr is the catamorphism for lists, and unfoldr is the anamorphism for lists.
09:33:08 <rpglover64> Thanks all.
09:45:08 <bmuk> Should I be doing every exercise in RWH or is it okay to skip them if I feel like I grasp the concepts?
09:46:27 <monochrom> that depends on how much time you can spend and how much certainty you want to ensure
09:46:48 <int3__> bmuk: I'm in favor of trying to build something difficult, then reviewing RWH / LYAH / etc whenever I get stuck
09:48:02 <bmuk> I feel like I've gotten rusty since I've spent a few months without programming. Around last christmas I felt like I understood everything up to the Reader, Writer and State monads
09:49:35 <bmuk> I guess I figured RWH would get me back up to speed, but some of the exercises seem less about haskell and more about math. For instance, given three points, determine if the line segments stay straight or turn right or left
09:50:03 <bmuk> I definitely had to look the math behind that one up, but the implementation part was pretty easy
09:50:09 <monochrom> wait til you get to the later chapters e.g. FFI
09:51:56 <bmuk> I'm sure FFI could get pretty challenging.
09:52:58 <bmuk> int3__: so you would be in favor of starting a project and only looking up what you need to know to complete it?
09:53:10 <cin> bmuk, that's how i learn
09:53:42 <cin> bmuk, it's stupidly inefficient, but you learn how you learn
09:54:22 <int3__> bmuk: yeah. well usually I'm more motivated to read the related books / papers from start to end after the project
09:54:24 <bmuk> cin, I am drawn to it though, because I have several projects I'm kind of putting off while going through RWH
09:54:56 <int3__> bmuk: also, I like overengineering my stuff, which means I end up reading a lot more than 'strictly necessary' to complete it
09:56:47 <iasoon> bmuk: I skipped that chapter because I don't do C. Is it worth checking out anyways?
09:58:03 <bmuk> iasoon: I haven't gotten there yet, but just because you don't want to use C to write a whole program doesn't mean you wouldn't benefit from being able to call C functions. Most systems level stuff you would have to call C functions I would think
09:58:49 <iasoon> bmuk: s/don't do C/did not have the need to call C functions up until now/
09:59:26 <bmuk> iasoon: and you might never have the need to. It just depends on what you're interested in.
09:59:52 <keep_learning> Hello everyone
09:59:56 <iasoon> Hey!
10:00:09 <iasoon> bmuk: True dat.
10:00:23 <keep_learning>  I am working on system where i don't have root permission.
10:00:33 <keep_learning> I am trying to install sbv package
10:00:52 <bmuk> I know Galois made an embeded filesystem in haskell, has anyone tried making a modern filesystem ala ZFS or BTRFS in haskell?
10:01:04 <keep_learning> when I am running cabal install sbv --dry-run -v
10:01:15 <keep_learning> In order, the following would be installed: sbv-3.1 (new package)
10:01:21 <cin> bmuk, learning haskell is like the ackermann function. first argument is the number of hours a day you have to spare, is the number of projects you have
10:01:40 <bmuk> cin++
10:01:54 <keep_learning> Data/SBV.hs:269:8:     Could not find module ‘Control.Concurrent.Async’     There are files missing in the ‘async-2.0.1.5’ package,     try running 'ghc-pkg check'.
10:01:56 <cin> bmuk, it's a total function so it *will* end, but sometimes you're not so sure =p
10:04:21 <keep_learning> but when I am running ghc-pkg check
10:04:31 <keep_learning> it shows lot of broken package http://lpaste.net/107970
10:04:55 <keep_learning> Could some one please tell me how to solve this problem ?
10:06:30 <bmuk> keep_learning: possibly try cabal update?
10:08:05 <shlevy> Hey, any idea why https://hackage.haskell.org/package/simple-conduit-0.5.0 doesn't have haddock? Building locally works fine
10:08:36 <keep_learning> bmuk: cabal update is not helping.
10:08:48 <savanni> keep_learning: in that state, I'd blow away the entire .cabal director, then ghc-pkg unregister every package and start over.
10:09:12 <cin> savanni, nuke from orbit?
10:09:16 * hackagebot tz 0.0.0.7 - Efficient time zone handling  http://hackage.haskell.org/package/tz-0.0.0.7 (MihalyBarasz)
10:09:18 * hackagebot bloxorz 0.1.2 - OpenGL Logic Game  http://hackage.haskell.org/package/bloxorz-0.1.2 (ViktorDevecseri)
10:09:27 <savanni> cin: nah.  Nuke from orbit involves fdisk. ;)
10:09:41 <savanni> This might be more... nuke by relativistic baseball.
10:10:03 <Pythonfant> shlevy: haddock building on hackage seems to be a bit broken atm
10:10:11 <Pythonfant> there are a lot of packages with no docs
10:10:46 <keep_learning> savanni: I should remove the whole .cabal directory ?
10:10:59 <keep_learning> and reinstall all the package
10:11:10 <savanni> keep_learning: I'm saying this because it looks corrupted and the easiest fix is to start with a clean slate.
10:11:13 <savanni> Although...
10:11:25 <savanni> You could probably just ghc-pkg unregister everything and start reinstalling without nuking .cabal.
10:11:45 <savanni> That would likely work and save you some bandwidth (which is always a concern for me)
10:11:58 <savanni> Or, even, you could unregister all of the packages and switch to a sandbox for your project.
10:12:17 <keep_learning> savanni: thanks you
10:13:12 <Exio> what is the 'easier' (or should i say "nicer") way to store a recursive datatype? (i'd want to avoid read/show)
10:13:40 <[swift]> Exio: to serialize it, you mean?
10:13:51 <Exio> yeah
10:13:57 <savanni> Exio: I don't think that there's a general solution.  I tend to use a json encoder for that.
10:14:14 <[swift]> Exio: if you want a binary serialization, take a look at the 'binary' package.
10:14:18 <savanni> But it does involve writing tedious code to make your data type jsonable or serializable or storable (depending on the module you use)
10:14:35 <Pythonfant> well you might be able to derive it with aeson
10:14:39 <[swift]> Exio: if you want text, i agree that 'aeson' is the way to go
10:14:40 <keep_learning> savanni: One more question.
10:15:03 <keep_learning> I can see ghc-pkg list gives me list of packages in  /opt/local/lib/ghc-7.8.3/package.conf.d
10:15:09 <Exio> i'll check, thanks
10:15:15 <keep_learning> and /home/mukesh/.ghc/x86_64-linux-7.8.3/package.conf.d
10:15:29 <savanni> keep_learning: Oh.  Yeah.  Don't unregister the system ones, just the ones in your home.
10:15:31 <keep_learning> I should unregister the packages in /home/mukesh/.ghc/x86_64-linux-7.8.3/package.conf.d ?
10:15:47 <keep_learning> savanni: Thank you
10:16:43 <Exio> it seems "binary" is exactly what I wanted, thanks!
10:17:08 <[swift]> =)
10:19:09 <shlevy> Pythonfant: Hmm any idea who to contact about that?
10:25:30 <cin> what's that cabal command to get around people's pointless upper bounds?
10:25:33 <pmade> Is there a way to access the current writer value in a writer monad?  I have a newtype over RWST and I'm writing a fail function for it and want to add the current writer log to the failure message.
10:25:37 <sm> --allow-newer
10:25:40 <shlevy> Is it worth looking into how to make my packages safe haskell?
10:25:41 <cin> sm, thanks
10:26:07 <shlevy> I'm not sure what safe haskell really is :D
10:26:29 <keep_learning> savanni: Some packages are shared between system and user
10:26:46 <keep_learning> should I unregister them also ?
10:29:05 <_0xAX> Hello all
10:30:26 <benzrf> hello
10:30:51 <savanni> keep_learning: please explain more?
10:33:38 <keep_learning> savanni: There is a package random-1.0.1.1 in both /opt/local/lib/ghc-7.8.3/package.conf.d and /home/mukesh/.ghc/x86_64-linux-7.8.3/package.conf.d
10:33:59 <keep_learning> highlighted in red color
10:34:00 <savanni> Remove the one you have locally.  It really shouldn't have installed both, though.
10:34:12 <savanni> highlighted in red?
10:34:23 <keep_learning> savanni: May be some sort of symbolic link ?
10:34:27 <keep_learning> shared
10:34:35 <keep_learning> between both
10:34:35 <savanni> *blink*
10:34:46 <savanni> Well.... erm... red would indicate something broken.
10:34:52 <savanni> But I've not seen that sort of thing before.
10:35:01 <keep_learning> savanni: Yes
10:35:08 <keep_learning> ghc-pkg check
10:35:16 <keep_learning> showing that it's broked
10:35:23 <keep_learning> *broken
10:35:30 <Pythonfant> shlevy: no sry
10:36:19 <savanni> Is there any further indication of in what way itis broken?
10:39:55 <keep_learning> savanni: http://lpaste.net/107971
10:40:29 <bmuk> Where can I learn more about cabal and cabal-dev? I always hear about "cabal hell" but I have thankfully never experienced it.
10:40:57 <keep_learning> bmuk: Lucky you :)
10:41:18 <bmuk> sorry keep_learning
10:41:20 <bmuk> lol
10:41:50 <savanni> keep_learning: that looks like a problem with regex-compat.  Unregister that and then keep trying.
10:42:10 <cepheus> is nix as good at combatting cabal hell as people say?
10:42:16 <savanni> Just out of curiosity, could you paste a listing of /home/murkesh/.cabal?
10:43:19 <keep_learning> savanni: Yes. I unregistered all the packages and now every thing looks great.
10:43:29 <keep_learning> hope now things will go smooth
10:43:29 <savanni> \o/!!!
10:43:37 <savanni> Now start trying to install things.  Or switch to a sandbox.
10:43:54 <savanni> bmuk: if you have cabal 1-18 or higher, you won't need cabal-dev.  Sandboxing is built in now.
10:44:29 <tanmaig> Hi all! Had a quick question with aeson lenses. The hackage page has docs for 'getters' https://hackage.haskell.org/package/lens-4.3/docs/Data-Aeson-Lens.html but are there any convenient setters?
10:45:01 <bmuk> is the preferred method of installing ghc and cabal through your distro's repos or as a tar from the site?
10:45:22 <RchrdB> savanni, I thought sandboxing was in 1.20?
10:45:49 <savanni> bmuk: I like to do it from the tar.  That way when things go really bad I can just nuke them.  And, I'm also hell-bent on staying on one of Ubuntu's LTS releases.
10:46:02 <savanni> RchrdB: No, pretty sure it's a 1.18 feature.
10:46:19 <RchrdB> savanni, oh cool, thanks for the correction.
10:46:25 <savanni> I'm *on* 1.20 now, but I think that was a requirement of ghc-7.8 or some such.
10:46:38 <savanni> Or maybe I just upgraded everything in haskell-land when I set up a new machine.
10:46:44 <bmuk> savanni: I'm on fedora 20, which isn't too far behind (ghc 7.6.3)
10:46:59 <ReinH> bmuk: distros are often out if date
10:47:45 <ReinH> compiling GHC and compiling/bootstrapping cabal have been pretty painless for me.
10:47:48 <savanni> Not that I advocate for doing every upgrade as it comes out!
10:48:22 <wooblydops> Hi, why do we have to explicitly list type classes, can't the compiler trivially figure those out itself?
10:48:25 <ReinH> bmuk: 7.8 is a significant update :)
10:49:00 <bmuk> Have we made it a requirement for every monad to be an instance of applicative yet?
10:49:02 <bmuk> or is that 7.10?
10:49:08 <savanni> 7.10
10:49:15 <savanni> At least, that's what the deprecation warnings tell me.
10:49:16 <pjdelport> wooblydops: The compiler can, and should.
10:49:31 <pjdelport> wooblydops: Are you referring to the monomorphism restriction? You can turn that off.
10:49:41 <benzrf> pjdelport: BUT SHOULD YOU
10:49:50 <pjdelport> benzrf: YES
10:50:19 <benzrf> cant that lead to improperly general types or some garbage
10:50:19 <wooblydops> pjdelport: I'm not sure, but I'd like to just have type classes inferred. Also, whenever I have an "untyped" definition it will complain it there's uses of type classes in there
10:51:13 <pjdelport> wooblydops: Can you give an example? And is that with the MR turned off?
10:51:37 <pjdelport> wooblydops: If this is in ghci, you probably want to do :set -XNoMonomorphismRestriction
10:51:38 <wooblydops> pjdelport: I think you're probably right about the monomorphism restriction... it's on
10:51:53 <pjdelport> wooblydops: You might want to put that in your ~/.ghci :)
10:52:05 <wooblydops> pjdelport: cool, thanks :)
10:53:00 <phaazon> hey
10:53:13 <phaazon> is there a function to search a list in a list?
10:53:22 <phaazon> I guess it’s possible with inits
10:53:30 <phaazon> but it might be inefficient
10:54:03 <phaazon> yeah it’s not even inits
10:54:07 <iasoon> phaazon: do you mean a sublist or a nested list?
10:54:12 <phaazon> sublist
10:54:14 <phaazon> like
10:54:14 <pjdelport> :t isInfixOf
10:54:15 <lambdabot> Eq a => [a] -> [a] -> Bool
10:54:17 <phaazon> oh
10:54:19 <phaazon> thank you
10:54:23 <phaazon> @hoogle isInfixOf
10:54:25 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
10:54:25 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
10:54:25 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
10:54:39 <wooblydops> pjdelport: actually there are the sorts of errors I get without a signature: https://gist.github.com/anonymous/1a02188baeade9b1bc7b
10:54:44 <phaazon> is there a way to get its index?
10:55:09 <phaazon> @src isInfixOf
10:55:09 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:55:33 <wooblydops> pjdelport: so it sounds like it's instantiating it to something new, instead of reusing the existing type variable
10:56:21 <rwbarton> wooblydops, can you post the relevant code too?
10:56:51 <wooblydops> rwbarton: yes, let me work on a minimal example
10:57:14 <pjdelport> phaazon: Not for lists, that i know of, though e.g. ByteString has findSubstring
10:57:51 <phaazon> ok
10:57:52 <phaazon> thank you
10:57:57 <phaazon> I guess Text might have it as well
10:58:09 <phaazon> it was just out of curiosity
10:58:14 <phaazon> I don’t need the index for my purpose
11:01:00 <wooblydops> rwbarton: pjdelport https://gist.github.com/anonymous/361ca7dd065ec76ae818
11:01:15 <wooblydops> rwbarton: pjdelport Just saying 'smap2 = smap' will make it barf
11:01:31 <wooblydops> So I explicitly have to type it
11:01:58 <wooblydops> not sure why the monomorphism restriction applies, since these are functions. THere would be no re-evaluation?
11:02:38 <rwbarton> that is an ordinary monomorphism restriction issue
11:02:50 <rwbarton> smap2 is a function but it's not syntatically defined by a function binding
11:03:17 <rwbarton> which is what is relevant to MR
11:03:23 <wooblydops> How do I syntactially define a function binding?
11:03:31 <rwbarton> f x [...] = ...
11:03:32 <wooblydops> oh yo umean f x = ...
11:03:34 <wooblydops> right ok
11:03:52 <wooblydops> The prupose of MR is to make sure evaluation happens only once, correct?
11:04:02 <lispy> wooblydops: pretty much
11:04:18 <wooblydops> Shouldn't it be apparent from the type that reevaluatino can't occur?
11:05:16 <cin> how do you make a Day of 2014-05-23 with Data.Time?
11:05:32 <rwbarton> wooblydops, no
11:05:51 <ski> wooblydops : only if you write an explicit type signature
11:05:54 <rwbarton> f = let e = expensive computation in \x -> ...
11:06:19 <cin> oh, fromGregorian
11:06:26 <Algebr> Is Int a keyword?
11:06:29 <cin> no
11:06:42 <lispy> wooblydops: look at the motivation in section 4.5.5: http://www.haskell.org/onlinereport/decls.html
11:06:52 <rwbarton> if f is generalized, then e will be recomputed every time an expression f x is evaluated
11:07:13 <wooblydops> rwbarton: ski lispy right, I see, ok, thanks
11:07:32 <lispy> > let { xs = [1..10]; len = genericLength xs } in (len, len)
11:07:34 <lambdabot>  (10,10)
11:08:00 <lispy> > let { xs = [1..10]; len = genericLength xs } in (len :: Int, len :: Float)
11:08:02 <lambdabot>  (10,10.0)
11:10:38 <lispy> "Laziness is a liar! The sneaksy, tricksy sharing lies to you!" -- Smeagol when asked about the Monomorphism Restriction
11:11:01 <wooblydops> Hah, nice one
11:14:40 <wooblydops> So a strict language the different typings of 'len' would have simply given a type error then? As in, 'len' is not generalizable?
11:15:32 <n-dolio> No, strict languages would have the same problem.
11:16:54 <n-dolio> It might be weirder, actually, since the implicit class parameter would cause len to not be immediately evaluated.
11:19:42 <ski> hm, actually i wonder how that's treated in MetaML
11:19:46 <n-dolio> Strict languages tend to add other things (that aren't necessarily tied to strictness) that cause them to completely rule out polymorphic values.
11:20:35 <ski> hm, i suppose it'd just be a value restriction violation ?
11:20:36 <n-dolio> Like, if you have side effects, you don't want them to happen more than once because something got generalized.
11:21:19 <n-dolio> Yeah, for MLs it'd be the value restriction.
11:21:32 <n-dolio> Unless MetaML doesn't have that.
11:22:54 <ski> iirc, it does
11:23:13 <ski> it also has a few more constraints on tyvars than equality constraints
11:23:17 <pyon> n-dolio: I thought the value restriction was there because otherwise the type system is not sound because of impurity.
11:23:23 <pyon> In mean ML's.
11:23:27 <n-dolio> Well, that's another reason. :)
11:23:44 <n-dolio> You don't have to worry about side effects unless you have classes, which MLs don't.
11:23:47 <ski> (orderable,numeric,liftable,showable. maybe one or two more)
11:23:53 <n-dolio> Polymorphism itself doesn't delay things.
11:24:50 <n-dolio> Or, some kind of thing that requires you to implicitly pass evidence.
11:24:58 <ski> hm, well. in the reference implementation of MetaML, polymorphism did delay stuff (type passing, as opposed to erasure)
11:25:15 <mitchty> out of curiosity is there an analog to this haskell news page (/r/haskell is a bit above my pay grade atm at times ) in english (my german is ok enough to read this but would be nice) http://www.linux-magazin.de/tags/view/Entwicklung/Haskell
11:25:21 <n-dolio> Yeah, if they have constraints like that, they might have to.
11:25:35 <ski> not sure how they handle that in OCaml (which is compiled, iirc), though i suspect they have erasure
11:25:41 <n-dolio> But, the value restriction would still be enough to get rid of any confusing stuff, I think.
11:25:51 <ski> er, in MetaOCaml, i mean
11:27:05 <n-dolio> You'd have to find an ML where they got rid of reference types and the value restriction to see what they did.
11:27:21 <n-dolio> But I can't name one.
11:28:06 <n-dolio> You could look at Scala, but I think they just have a value restriction, too.
11:28:22 <n-dolio> 'val' defined things aren't polymorphic, and 'def' defined things can be polymorphic, but are call-by-name anyway.
11:29:09 <stack> I would like to master monads , I would like some good book about them or video/paper/something, anything to advice from you masters :) ?
11:29:41 <int3__> vimscript is really the worst language ever
11:29:41 <n-dolio> And there's no inference comparable to type classes there anyway.
11:29:56 <markov_twain> stack: I don't understand monads, but this video helped: http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
11:30:06 <Pythonfant> stack: implement them yourself
11:30:14 <int3__> but I'm getting my syntax highlighting to a fairly nice place -- being able to distinguish data and type constructors in most places
11:30:26 <Pythonfant> stack: don't try to compare them to something else you already know
11:30:53 <Pythonfant> stack: you might want to try https://github.com/NICTA/course it helped me to really understand quite a few things including monads
11:31:02 <stack> markov_twain: yes that is a good video , I saw that and now I'm fascinated from erik mejer and brian Beckman :)
11:31:08 <bmuk> I'm looking into recreating my blog in haskell (right now I use ghost). What would be the best framework for this? I would like to be able to write posts in the admin portion of the site, but other than that it's mainly static web pages. http://54.88.92.146 is what I have right now. Yesod seems too featureful for what I need. Maybe something like snap or happstack?
11:32:06 <int3__> bmuk: there's hakyll
11:32:21 <josephle> stack: my advice is to just use Monads. I feel like with most "advanced" typeclasses mastery is just a matter of pattern recognition.
11:32:54 <bmuk> What are the benefits and drawbacks of each? Is there a wiki article on this/
11:32:54 <stack> Pythonfant: what is that?
11:33:11 <levi> bmuk: Hakyll is a static site generator, so it doesn't have a web interface at all really. Snap, Happstack, and Scotty are all reasonable choices if you want to roll-your-own blog engine.
11:33:28 <Pythonfant> stack: it's a course where you reimplement mostly standard library stuff yourself and then can check your solutions using automated tests
11:33:52 <stack> Pythonfant: seems cool
11:33:57 <bmuk> levi++
11:35:09 <bitemyapp> stack: https://github.com/bitemyapp/learnhaskell
11:35:20 <bitemyapp> stack: you are unlikely to succeed in completing the NICTA course solo without some prior learning.
11:35:39 <stack> bitemyapp: what kind of background does that need?
11:35:42 <bitemyapp> stack: NICTA course was designed for hands-on training with the assistance of an educator that knows Haskell well. It is, however, an excellent follow-up to a more basic introduction to Haskell.
11:35:48 <bitemyapp> stack: I made the guide. Follow the guide I just linked you
11:35:57 <stack> ok
11:36:11 <bitemyapp> stack: you can get further help in this channel or the one mentioned in the guide.
11:37:22 <stack> bitemyapp: ok thanks, anyway I was searching for some reference that could also be independent from what haskell does.
11:37:23 <bitemyapp> Pythonfant: try to avoid telling people that may not know any Haskell to dive into NICTA course.
11:37:38 <bitemyapp> stack: Haskell is the vehicle for learning FP. Follow the guide. Seriously.
11:38:15 <bitemyapp> stack: other approaches will often lie to you and waste a lot of time.
11:38:58 <stack> bitemyapp: yeah that is precisely the reason I asked that question in this channel :)
11:39:37 <keep_learning> Hello all
11:39:41 <bitemyapp> stack: I wasted many years not learning FP. I wrote the guide because I don't other people to lose half a decade++ like I did.
11:39:42 <stack> also monads are not haskell, so if there is some good material I would like to read that
11:39:45 <keep_learning> I am trying to install
11:39:49 <bitemyapp> stack: you want to just learn Haskell.
11:39:51 <stack> bitemyapp: ok
11:39:55 <bitemyapp> stack: you will be on the path to grokhood that way.
11:40:09 <bitemyapp> stack: also, stop fetishizing monads. They're just one algebraic structure among many.
11:40:12 <keep_learning> MissingH package
11:40:19 <bitemyapp> stack: you will be able to learn how they all fit together when you follow the guide.
11:40:34 <keep_learning> but it seems to break some package.
11:40:56 <pjdelport> forget monadic functors until last: Functors in general and Applicative functors are where the magic is at! :)
11:41:24 <bitemyapp> applicatives are cool as hell :)
11:42:15 <levi> keep_learning: Have you been using cabal sandboxes?
11:44:28 * hackagebot hlint 1.9.2 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.2 (NeilMitchell)
11:46:17 <stack> uh, cool https://www.edx.org/course/delftx/delftx-fp101x-introduction-functional-2126
11:47:03 <jle`> stack: scrolling back, i'm not sur ethat 'mastering monads' is a meaningful goal
11:47:21 <bitemyapp> stack: I talked to him yesterday morning. It begins this fall.
11:47:25 <jle`> stack: even if it made sense to master monads, setting out to 'learn monads' is probably not so useful or fruitful
11:47:29 <stack> bitemyapp: you cite valuable resources there, I'll follow that
11:47:31 <bitemyapp> stack: you can follow the guide until then.
11:47:57 <bitemyapp> Erik Meijer is quite a character.
11:49:01 <stack> jle`: that was partially a joke about me referring to "masters" in this channel, but yes the actual goal is to have some resource that was considered valuable in the field, and bitemyapp gave me some
11:49:11 <jle`> stack: hooray :D
11:49:34 <bitemyapp> There are gaps in the guide though. I'd like resources on GHC Core. /me winky_face.jpg at carter
11:49:45 <stack> bitemyapp: yes he is my week hero :)
11:49:50 <jle`> but yeah...the best way to set about understanding monads is just to forget about understanding monads and just use specfic types
11:49:58 <jle`> Maybe is useful.  List is useful.  IO is useful.  Either is useful
11:50:10 <jle`> they also have nice utility/helper functions on them
11:50:21 <suOya_> Maybe is the simplest useful monad to start out with
11:50:29 <bitemyapp> jle`: concrete examples can lead to false intuition, mislead.
11:50:41 <bitemyapp> jle`: I favor starting from types, then free objects, then concrete examples
11:50:50 <bitemyapp> cis194's demonstration is good for what it's trying to do.
11:51:12 <jle`> starting from the types of the monad methods, you mean?
11:51:32 <bitemyapp> jle`: ideally having already seen and understood weaker structures, yes.
11:51:46 <jle`> i guess what i'm suggesting isn't how to understand monads.  it's just how to practically do haskell
11:51:58 <jle`> you can be very productive with Maybe, using combinators from Monad
11:52:20 <jle`> and not even because they're from Monad
11:52:25 <jle`> but just because they're useful helper functions
11:52:36 <bitemyapp> jle`: right.
11:52:36 <jle`> i used maybe for about a month, using its helper functions
11:52:38 <jle`> it was nice
11:52:40 <suOya_> Yeah, types should be one's #1 priority when learning Haskell
11:52:56 <jle`> used IO...lists...all great types with very useful combinators for those specific types
11:53:02 <jle`> then one day i just saw the connection
11:53:03 <MP2E> The Typeclassopedia was my best friend for a while
11:53:04 <jle`> :|
11:53:28 <jle`> it didn't matter at all to me that my (Maybe a) -> (a -> Maybe b) -> (Maybe b) that i had been using for months was from Monad
11:53:30 <bitemyapp> jle`: it's fine, as long as you understood eventually. Concrete -> Abstract is harder than Abstract -> Concrete.
11:53:38 <c_wraith> Yeah...  If you learn types, monads are no big deal.  Focus on them, and monads are obvious.
11:53:42 <bitemyapp> intuiting the essence from a mess of unnecessary detail is hard.
11:53:43 <josephle> is there a way to build a new haskeller's intuition of what's in the typeclassopedia?
11:53:54 <hiptobecubic> bitemyapp, i'm not sure that's true really. It just looks true after you understand both
11:53:55 <carter> josephle: try to write stuff and see what happens
11:53:56 <josephle> it seems the current method is to bang head on keyboard until you grok it
11:53:58 <jle`> i don't think that the abstract is even an important concept to emphasize
11:54:02 <bitemyapp> josephle: https://github.com/bitemyapp/learnhaskell
11:54:02 <hiptobecubic> bitemyapp, building intuition from abstract definitions is really hard
11:54:11 <systemfault> josephle: Haha
11:54:12 <carter> o/ copumpkin  :)
11:54:16 <bitemyapp> hiptobecubic: that's why I do a progression
11:54:22 <monochrom> no, concrete -> abstract is easier.
11:54:22 <josephle> I already understand these things, but I'm wondering how to get a new haskeller into it
11:54:38 <bitemyapp> josephle: https://github.com/bitemyapp/learnhaskell
11:54:41 <carter> josephle: back in my day the trick was stare at a wall
11:54:48 <bitemyapp> josephle: I teach this stuff. I am linking the guide for a reason.
11:54:52 <carter> but back in my day applicative didn't even exist!
11:54:58 <carter> applicative is amazing
11:55:09 <josephle> bitemyapp: sorry, I misunderstood your intention the first time around :)
11:55:24 <bitemyapp> josephle: do they know basic Haskell?
11:55:42 <bitemyapp> josephle: ie, could they implement their own List + Data.List namespace?
11:56:27 <josephle> I think they would be able to, although my original question is hypothetical
11:57:54 <Pythonfant> bitemyapp: I didn't have the impression that he didn't knew any haskell, sry
11:58:11 <stack> I know really few
11:58:18 <carter> monads are the least interesting data flow abstraction
11:58:22 <stack> but that is not a problem
11:58:31 <carter> "this has to come after that in the data flow dependency graph"
11:58:57 <stack> carter: please provide a graph then :)
11:59:01 <carter> nope
11:59:11 <carter> graphs are harder to code than program text
11:59:26 <carter> every visual graph based programming language winds up being like wiring circuits
11:59:27 <carter> THOUGH
11:59:29 <carter> clash is kinda cool
11:59:31 * hackagebot Cabal 1.18.1.4 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.4 (JohanTibell)
11:59:50 <monochrom> I like wiring circuits
11:59:57 <oleo> lol
12:00:06 <suOya_> if it aint text it aint programming
12:00:06 <monochrom> I also drew flow charts back in the old days
12:00:08 <stack> carter: what do you consider more interesting as abstraction then?
12:00:28 <carter> applicatives are the ones that are hard to understand how epic they are
12:00:44 <carter> i really love how simon marlow was able to hammer home their magic via haxl
12:00:47 <MP2E> I agree, Applicatives are the typeclass that took me the longest to understand how they... Apply >_>
12:00:50 <bitemyapp> carter: yeh. That paper was a joy.
12:00:52 <MP2E> But now <3 Applicatives
12:00:54 <MP2E> I use them everywhere
12:01:01 <josephle> they occupy that strange space between functors and monads after all
12:01:03 <bitemyapp> MP2E: Apply a lá NICTA/course?
12:01:08 <carter> josephle: deeper than that!
12:01:17 <suOya_> MP2E: Any good resources to read on applicatives? I know the basics
12:01:17 <carter> they give you enough power to do effecty things
12:01:33 <carter> but enough structure that you can do instrospective optimizations that are impossible with monads
12:01:59 <stack> I feel ashamed how I never encountered those things studying in my life
12:02:14 <pjdelport> carter: They would be possible if Monad had a better interface, but alas.
12:02:16 <Enigmagic> applicatives are my favorite
12:02:22 <carter> pjdelport: nope
12:02:23 <carter> impossible
12:02:33 <carter> pjdelport: that better interface is use applicatives :)
12:02:41 <pjdelport> (Monad is just Applicative + join, of course.)
12:03:33 <MP2E> Well right, but Applicatives also can't 'alter' each other. You can combine a bunch of applicatives and they will all become one type, but each applicative action is in its own bubble, so to speak. They won't effect each other
12:03:36 <dfeuer> Any foldr/build gurus here? nomeata came up with a strict fusable scanl' that apparently gives very good results when used to implement inits, but it's not clear to me how to prove that it's safe to fuse.
12:03:42 <MP2E> So Applicatives can be auto parallelized and crazy stuff like taht :D
12:03:47 <pjdelport> carter: All monadic functors are already applicative functors: the applicative interface adds nothing that's better. :)
12:04:13 <pjdelport> carter: The reason that Haskell's Monad typeclass is hobbled isn't intrinsic to monads; it's just because of its bad choice of primitive methods.
12:04:14 <MP2E> pjdelport: but Monads imply that context is now important, aka a previous Monadic action can determine a future one
12:04:21 <MP2E> so the optimization potential is decreased dramatically
12:04:23 <carter> pjdelport: what altenrative api
12:04:31 <carter> do you claim
12:04:41 <pjdelport> MP2E: If you don't use join, then Monad *should* be entirely equivalent to Applicative.
12:05:02 <fread2282> suOya_: rewrite as much of your monad code ase you can using Applicative style (<$> and <*>)
12:05:16 <hiptobecubic> pjdelport, but how is it a monad if it has no join?
12:05:20 <pjdelport> (But it isn't in Haskell only because Monad chose to make >>= primitive and not ap.)
12:05:38 <carter> pjdelport: things could change for 7.10 or 7.12 with the right proposal
12:05:43 <carter> probably 7.12 more likely
12:05:45 <MP2E> suOya_ : I'm looking right now to see if any stand out, for me it was reading a few papers on it and trying to write applicatives myself. optparse-applicative helped a lot in showing me how useful they are with parsers
12:05:49 <pjdelport> carter: Yeah; that would be awesome.
12:05:53 <c_wraith> pjdelport: making ap primitive doesn't help.  There's no function to bridge the gap between ap and join neatly.
12:06:41 <suOya_> MP2E: when should one, ideally use applicatives over monads? When the sequential data flow is not required?
12:06:42 <MP2E> suOya_ : What really helped me was a series of posts by edwardk on comonad.com. It was a bit dense so I had to do a lot of side reading to make sure I understood everything, but it was very enlightening :)
12:06:46 <MP2E> http://comonad.com/reader/2012/abstracting-with-applicatives/
12:06:47 <pjdelport> c_wraith: What i'm saying is that if you only use return ap, then you are by definition only use Applicative functionality. (And if Monad made ap primitive, all Monad instances would have exactly and precisely the same optimization potential that Applicative has.)
12:06:57 <pjdelport> "only use return and ap", that is
12:07:00 <suOya_> thanks
12:07:13 <fread2282> suOya_: depends on style, but I use Applicative whenever I can because I think it looks nicer
12:07:15 <MP2E> Applicatives should almost always be used over Monads where they can be :)
12:07:29 <suOya_> "should" or "could"?
12:07:33 <bitemyapp> MP2E: Aye.
12:07:37 <bitemyapp> suOya_: depends!
12:07:42 <fread2282> do we have ApplicativeDo yet?
12:07:49 <bitemyapp> fread2282: 7.10 maybe?
12:07:55 <fread2282> cool
12:07:56 <c_wraith> MP2E: it's likely GHC 7.10 will do that conversion for you automatically in do syntax.
12:08:20 <carter> jah
12:08:29 <pjdelport> c_wraith: In other words, the problem with Monad in Haskell in particular is an artificial one, due to the choice of what is a class method and what isn't, and it's not anything fundamental with applicative versus monadic functors (because all the latter include the former).
12:08:38 <fread2282> suOya_: since ApplicativeDo is on it's way, it's more a question of style
12:09:41 <fread2282> unless you're using something that does important optimizations with Applicative like Haxl
12:09:48 <c_wraith> pjdelport: Well, there is a fundamental problem. If you want to start at Functor and go to Monad, you just add join.  If you want to start at Functor and go to Applicative?  You end up having repetitive functionality.  Same with starting at Applicative and going to Monad.
12:10:01 <pjdelport> In a perfect world, the definition of Monad would just be "class Applicative f => Monad f where join :: f (f a) -> f a" :)
12:10:06 <MP2E> Indeed :V
12:10:09 <suOya_> fread2282: What kind of optimizations does applicative have that monads don't? Parallelization?
12:10:11 <MP2E> and MonadFail would be a seperate typeclass
12:10:16 <c_wraith> pjdelport: join is too big for that.
12:10:30 <pjdelport> c_wraith: You have to add join to Applicative, not just to Functor.
12:10:33 <pjdelport> (to get Monad)
12:10:41 <fread2282> suOya_: depends on the Applicative
12:10:47 <fread2282> (and Monad)
12:10:56 <rwbarton> well in some sense join is "too big" to get from Functor to Monad too, since it is supposed to satisfy laws
12:11:28 <pjdelport> you need pure and <*> (or return and ap) in addition to join, to get from Functor to Monad.
12:11:45 <c_wraith> pjdelport: You're ignoring my point.  join is too big.
12:12:04 <MP2E> Does anyone else use djinn to write typeclass instances for them? :P I love abusing djinn to write out (<*>) for me
12:12:12 <pjdelport> c_wraith: I'm not sure i understand what you mean by "too big"
12:12:13 <c_wraith> pjdelport: Is there something smaller that can be provided to close the gap?  (with join + fmap, ap is redundant)
12:12:34 <monochrom> you just need join to go from Functor to Monad.
12:13:02 <monochrom> sorry, join and return.
12:13:22 <c_wraith> yeah, return is necessary, but that's not the important detail for this.
12:13:58 <pjdelport> c_wraith: ap isn't redundant, because join imposes a stricter ordering. That's precisely why Monad has the problems it has in Haskell, because the join in >>= "hardwires" a stricter ordering unnecessarily into the interface, which ap doesn't.
12:15:17 <c_wraith> pjdelport: That's irrelevant to the denotational question, though.
12:15:24 <dfeuer> pjdelport: I don't understand what you mean. >>= can be written in terms of join and fmap, right?
12:16:36 <c_wraith> pjdelport: you want to convince me that ap should be primitive in monad, find something to provide the rest of the functionality that doesn't allow you to implement ap but takes you from Applicative to Monad.
12:17:14 <stack> bitemyapp: where are you teaching(if that could be made public)?
12:17:16 <pjdelport> dfeuer: Yes, but >>= imposes a stricter ordering that ap doesn't. That's why Applicative lets you write code that behaves better than the corresponding Monad code.
12:17:31 <c_wraith> pjdelport: "better"?
12:17:32 <tac_> pjdelport: that doesn't sound right
12:17:34 <pjdelport> c_wraith: No, i was saying that ap should be (and is) primitive in Applicative
12:17:54 <tac_> pjdelport: the key difference is bind allows a _choice_ of action after the first.
12:18:04 <bitemyapp> stack: just informally. There's an IRC channel, I skype with people, I give talks/tutorials at meetups, one on one sessions as the opportunity arises.
12:18:09 <dfeuer> pjdelport: where is this "stricter" stuff coming from?
12:18:22 <pjdelport> tac_: Exactly. It's overpowered, in a sense, when you're using it to implement ap
12:18:28 <pjdelport> @src ap
12:18:28 <lambdabot> ap = liftM2 id
12:18:33 <pjdelport> @src liftM2
12:18:33 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:18:50 <dfeuer> Oh, I see what you mean now.
12:18:52 <pjdelport> With applicative, liftM2 f x y has greater freedom in how it wants to order x and y
12:18:57 <pjdelport> well, liftA2
12:19:01 <stack> bitemyapp: uh ok so where did you met meijer?
12:19:17 <pjdelport> or equivalently: f <*> x <*> y <*> z <*> ...
12:19:33 <pjdelport> Applicative itself does not impose any particular ordering on the parts.
12:20:00 <pjdelport> An instance can be left to right, right to left, or something else case by case; whatever works and satisfies the laws.
12:20:41 <pjdelport> However, the definition of ap in terms of bind (and the implied join), destroys that freedom.
12:21:13 <pjdelport> The definition of liftM2 is *forced* to choose a particular ordering above, which no instance can alter or change (because it's not part of the class)
12:22:20 <pjdelport> So do { x1 <- m1; x2 <- m2; return (f x1 x2) } gives you one hardwired ordering, do { x2 <- m2; x1 <- m1; return (f x1 x2) } gives you the other hardwired ordering.
12:22:45 <pjdelport> And neither hardwired ordering can actually do something more efficient for a particular instance, because they're blind to it.
12:22:55 <pjdelport> Making ap a method (as it is in Applicative) solves this.
12:25:56 <heath> does anyone have a link to s. peyton jones' talk entitled ~"erlang and haskell: growing up together"?
12:26:32 <bonobo123> hi, a Profunctor question:
12:26:44 <bonobo123> Profunctor has dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
12:27:13 <bonobo123> I’m looking for something that has similar dimap, but with type signature: dimap :: (a -> b) -> (b -> a) -> p b -> p a
12:27:42 <bonobo123> and the caveat is that lmap and rmap aren’t really possible
12:28:03 <supki> @hackage invariant
12:28:03 <lambdabot> http://hackage.haskell.org/package/invariant
12:28:13 <bonobo123> does this resemble any kind of defined structure?
12:28:26 <levi> heath: Do you mean slides for it, or a video, or...?
12:29:00 <bonobo123> yep, Invariant, thanks
12:29:54 <heath> levi: video
12:30:30 <bonobo123> inerestingly enough hoogle knows about package invariant, but is not able to find invmap
12:30:34 <bonobo123> thanks for help
12:30:45 <joelteon> yeah, hoogle doesn't index anything outside of the haskell platform
12:30:51 <joelteon> if you want to search *everything*, use hayoo
12:31:23 <n-dolio> You can turn extra packages on in your hoogle search, I think. But that'd require you to know the package that has what you're looking for.
12:31:46 <bonobo123> hayoo is down
12:32:37 <joelteon> that too
12:32:42 <joelteon> that's not helpful either
12:33:03 <parc> trying to understand CPS, if haskell didn't do tail call elimination can you get the same effect with continuations?
12:33:21 <n-dolio> No.
12:33:54 <n-dolio> Calling the continuations in the CPSed code would use more stack than the original direct style.
12:33:54 <parc> :(
12:34:18 <monochrom> heh
12:34:57 <pjdelport> Haskell doesn't have any explicit tail call elimination guarantee, does it?
12:35:21 <bitemyapp> pjdelport: it doesn't and it doesn't need it.
12:35:23 <monochrom> Haskell 2010 you mean? it doesn't even have a laziness guarantee
12:35:25 <n-dolio> I don't know. But it'd be a nightmare if tail calls used stack.
12:35:34 <c_wraith> In the language spec?  Well.  No.  In reality, it's basically required.
12:35:38 <pjdelport> monochrom: Right, i mean in that same sense.
12:35:46 <bitemyapp> c_wraith: laziness makes it irrelevant, no?
12:35:50 <c_wraith> bitemyapp: no
12:35:56 <geekosaur> haskell doesnt say anything about tail calls. in practice, when ghc calls a function, that function immediately returns a thunk; there is zero stack pressure
12:36:15 <geekosaur> and it generally CPS-es calls so they all behave similarly to imperative tail calls anyway
12:36:27 <pjdelport> If you expressed everything as pure graph reduction then tail call reduces to GC, doesn't it?
12:36:32 <levi> pjdelport: The paper on the spineless tagless g-machine gives a good overview of the operational semantics.
12:36:33 <bitemyapp> c_wraith: my point is that guarded recursion is more to the point.
12:36:35 <pjdelport> tail calls, even
12:37:17 <c_wraith> bitemyapp: it's preferable, but it doesn't mean there isn't tail recursion when guarded recursion doesn't work.
12:37:18 <geekosaur> the stack that matters with ghc is a pattern matching stack, and tail calls are irrelevant to it
12:38:19 <c_wraith> > let dumb 0 = () ; dumb n = dumb (n - 1) in dumb 10001
12:38:20 <lambdabot>  ()
12:38:23 <n-dolio> You could make an implementation in which function calls used stack, though. And that'd be bad.
12:38:51 <c_wraith> Evaluating that would use a stack if it weren't for tail call elimination.
12:38:52 <bitemyapp> c_wraith: that doesn't work because of TCO, but because of heap-allocated stacks, no?
12:38:59 <bitemyapp> > let dumb 0 = () ; dumb n = dumb (n - 1) in dumb 10001000
12:39:03 <lambdabot>  mueval-core: Time limit exceeded
12:39:06 <bitemyapp> > let dumb 0 = () ; dumb n = dumb (n - 1) in dumb 1000100
12:39:08 <lambdabot>  ()
12:39:19 <c_wraith> bitemyapp: you need to see a heap profile
12:39:41 <c_wraith> bitemyapp: if making the number bigger doesn't make it use more heap, then it's eliminating the tail calls.
12:40:08 <bitemyapp> c_wraith: http://www.reddit.com/comments/6xnk5/ive_got_two_weeks_of_vacation_coming_up_should_i/c055b9w
12:40:18 <bitemyapp> c_wraith: that comment is a good demonstration
12:40:54 <c_wraith> bitemyapp: and its conclusion is that tail calls are converted to jumps - you know, exactly what is called tail call elimination
12:41:46 <bitemyapp> c_wraith: yep
12:41:49 <bitemyapp> c_wraith: also: https://web.archive.org/web/20081202004249/http://www.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
12:42:17 <spott> Is there any way of checking two instances of a type and determining if they are referentially the same.  For example, I create a Mylist type, and create an instance of Mylist, and then use the length of that Mylist to create another Mylist.  Is there a way I can compare the lengths of the two "Mylist" instances without actually comparing the value of the lengths?
12:43:31 <jophish> spott, This sounds like a job for Dependent Type Man
12:43:58 <c_wraith> pjdelport: it's not guaranteed, but any implementation that doesn't eliminate tail calls is going to fail on a lot of real-world code.
12:44:15 <spott> jophish: is there a way of doing it in Haskell?
12:44:29 <pjdelport> spott: sameLength Nil Nil = True; sameLength (Cons _ xs) (Cons _ ys) = sameLength xs ys; sameLength _ _ = False
12:44:29 <pjdelport> spott: Like that?
12:44:48 <carter> spott: jophish  i use static sized lists ALL THE TIME
12:44:58 <carter> jophish: didn't i just show you my own haskell code for it yesterday
12:44:59 <carter> :)
12:45:12 <jophish> I was just about to refer you to carter :)
12:45:16 <spott> carter, pjdelport: These aren't "static sized lists"...
12:45:22 <carter> spott: i know
12:45:25 <carter> well
12:45:30 <spott> well, they are
12:45:34 <spott> just not compile time static
12:45:34 <levi> So, GHC does tail call optimization when it can, but it doesn't have "proper tail calls" in the sense that Scheme guarantees and which is formalized in this paper: http://www.cesura17.net/~will/professional/research/papers/tail.pdf
12:45:47 <carter> levi: i'd arguet that ghc DOES have tail calls
12:45:50 <carter> i've read the code
12:45:55 <carter> it looks like tail calls to me
12:46:11 <levi> carter: I know; but that's different than "proper tail calls" as that paper defines them.
12:46:15 <carter> what page
12:46:19 <carter> i wanna audit your claims
12:46:26 <pjdelport> spott: The function I gave just compares them for structural equality, without computing any numeric length.
12:46:52 <jle`> spott: i don't think you can have reference equality in haskell; i think you can get it to violate referential transparency
12:46:56 <carter> levi: where it is defined int hat paepr
12:46:57 <jle`> barring something unsafe
12:47:02 <pjdelport> (assuming something like data Mylist a = Nil | Cons a (Mylist a) )
12:47:04 <spott> pjdelport, but still requires walking through the list...
12:47:12 <carter> jle`: ®eference equality  is easy
12:47:17 <carter> reallyUnsafePointerequality
12:47:19 <carter> ghc has it
12:47:19 <ski> levi : can you clarify ?
12:47:27 <jle`> <jle`> barring something unsafe
12:47:29 <jle`> ;)
12:47:30 <levi> carter: Just look through the introductory bit; I think that should make it clear what's meant.
12:47:42 <carter> levi: yup, ghc has that
12:47:43 <dfeuer> Still looking for someone to help with a list fusion question.
12:47:43 <pjdelport> spott: Then you'd need to encode the lengths in the type (or in an extra field), yeah.
12:47:50 <pjdelport> spott: Arrays?
12:47:50 <jophish> spott, Would it be possible to package the length of the list with the list?
12:48:11 <carter> dfeuer: fusion rules that work well are really ahrd
12:48:20 <ski> levi : iiuc, "proper tail recursion" means that one can have an unbounded abount of active tail calls in bounded space
12:48:21 <jle`> pjdelport: i think he is asking not for a fast-length-checker, but for a way to compare list lengths through reference equality
12:48:37 <carter> ski: by the definition of that paper GHC / haskell has proper tail calls
12:48:47 <dfeuer> Carter, this isn't a rule question. It's a question of whether a certain function is safe for foldr/build fusion.
12:48:49 <jle`> as in...if these two variables point to the shame head (shared) in memory, they are equal
12:48:54 <spott> so, the list example is a toy example... meant to describe the system.  the real problem is sparsity patterns in sparse matrices...
12:49:10 <carter> spott: i implemented sparse CSR matrices last week
12:49:12 <carter> whats the goal
12:49:14 <pjdelport> jle`: He did specifically talk about allocating a new list with the same length as another. :)
12:49:17 <spott> jle` exactly
12:49:23 <jle`> pjdelport: he did, so it's a bit confusing :|
12:49:32 <pjdelport> s/he/they/
12:49:36 <carter> spott: whats your use case
12:49:43 <levi> carter: Hmm. I came to the opposite conclusion after my research in the GHC code and supporting documents, but I will check again.
12:49:46 <dfeuer> Specifically, it uses `seq` in the argument to build, and I don't know how to tell if it does so safely.
12:49:56 <jle`> pjdelport: i see.  yeah >_>.  it's a weird question
12:50:00 <carter> dfeuer: email thelist more :)
12:50:04 <ski> carter : i was thinking it had, which is why i'm asking levi to clarigy
12:50:04 <spott> carter: if you create a matrix with a sparse pattern, then copy that sparse pattern, then add the matrices, it shouldn't have to check sparsity pattern...
12:50:10 <ski> s/carigy/clarify/
12:50:13 <carter> spott: heh
12:50:14 <dfeuer> Fine.
12:50:22 <carter> spott: i've an easy solutin for that
12:50:33 <dfeuer> I assume you mean the libraries list, carter?
12:51:06 <spott> carter: really?!
12:51:07 <spott> do tell
12:51:51 <spott> carter:  are you cartazio?
12:51:55 <carter> dfeuer: yup
12:51:58 <levi> My understanding from the paper was that "proper tail calls" were less about the underlying mechanism and more about being able to reason about space usage from the form of the program text.
12:52:03 <carter> spott: i'm carter, tazio is my middle name
12:52:17 <spott> I've been looking through your numerics package...
12:52:18 <dino-> This talk of packaging the length in the data structure is making me think of the O(1) length function in Data.Sequence
12:52:48 <levi> And the idea of "proper tail calls" as a space-reasoning guarantee is not applicable to a non-strict language, because tail calls are no longer the only consideration for space usage.
12:53:29 <ski> levi : yes, it's not about underlying mechanism
12:53:39 <levi> I agree from studying GHC that it does optimize tail calls; I'm not trying to suggest that it doesn't or that it't unimportant that it does.
12:53:45 <carter> spott: its not quite ready for primetime use yet
12:53:55 <spott> carter: I'm aware of that
12:53:59 <carter> :)
12:54:03 <spott> I'm mostly trying to learn from it
12:54:09 <carter> spott: if you look at Numerical.Array.Layout
12:54:19 <ski> levi : e.g. MIT Scheme with debugging doesn't perform TCO in an ordinary sense, but still has "proper tail recursion"
12:54:22 <carter> you'll see all the sub modules that have the layout metadata
12:54:27 <ski> levi : and, iiuc, nor does Chicken
12:54:38 <carter> spott: thing is, for sparse matrix ops, you're always going to be rebuilding them
12:54:38 * hackagebot float-binstring 0.2 - C99 printf "%a" style formatting and parsing  http://hackage.haskell.org/package/float-binstring-0.2 (AntonNikishaev)
12:54:40 * hackagebot hp2any-graph 0.5.4.2 - Real-time heap graphing utility and profile stream server with a reusable graphing module.  http://hackage.haskell.org/package/hp2any-graph-0.5.4.2 (GergelyPatai)
12:54:56 <Philonous> How does cabal handle when an (Exposed) module could refer two multiple files? e.g. hs-source dirs: foo, bar and both foo/Foo.hs and bar/Foo.hs exist? Testing seems to indicate that the first one found will be taken, but is that really tha case?
12:55:00 <carter> spott: i'm still working out how to do the sparse builders correcty mind you
12:55:05 <bitemyapp> carter: https://github.com/bitemyapp/learnhaskell#ghc-core-and-performance-tuning
12:55:05 <levi> ski: Well, if they don't do that in those situations, then they have one of the other space complexity classes mentioned in the paper.
12:55:12 <bitemyapp> carter: section started, couldn't wait for you. Sorry.
12:55:17 <carter> bitemyapp: yay
12:55:39 <carter> spott: engineering sparse matrices well is a deep rabbit hole
12:55:49 <carter> spott: come join #numerical-haskell
12:55:52 <spott> carter: yea.... I'm aware of that...
12:55:55 <carter> (all are welcome to lurk and learn)
12:55:56 <carter> :)
12:56:01 <ski> (iiuc, MIT Scheme stores the last 100 or so calls, tail or not, in a table to be shown when debugging. since the table is bounded, it's still "proper tail recursion")
12:56:15 <shapr> @yow
12:56:16 <lambdabot> Look into my eyes and try to forget that you have a Macy's charge card!
12:56:21 <ski> @palomer
12:56:21 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
12:57:02 <levi> ski: Again, the point is not about the implementation details, but whether asymptotic space usage can be determined by analysis of the form of the program text.
12:57:18 <ski> levi : Chicken simply uses the C stack as if it were a heap, never "returning normally", only cleaning it up on GC
12:57:29 <ski> levi : i know
12:57:37 <carter> levi: you can always do that with a lazy language, its just the analysis is more subtle
12:57:55 <ski> (of course Haskell isn't a "lazy language" ;)
12:58:06 <shapr> it's just non-strict
12:58:06 <bitemyapp> c_wraith: I learned something new today, thanks :)
12:58:11 <bitemyapp> ski: call-by-need, yes?
12:58:13 <levi> carter: More to the point, it's not the *same* one that the Scheme and ML folks are talking about.
12:58:17 <bitemyapp> that's the more appropriate way to put it?
12:58:35 <carter> yes, different analysis
12:58:43 <carter> but not unanalyzable
12:58:45 <levi> Call-by-name is also allowed for Haskell, I believe.
12:58:51 <carter> it'd just be slow
12:59:15 <ski> bitemyapp : call-by-need is one allowed reduction strategy for Haskell
12:59:40 <levi> carter: Right. The paper is trying to define/formalize a specific form of analysis that is meant by the Scheme Report when it talks about "proper tail calls".
12:59:55 <carter> scheme proper tail calls
13:00:01 <carter> not every language proper tail calls
13:00:21 <ski> levi : hm, are you sure it says "proper tail calls" rather than "proper tail recursion" ?
13:01:04 <carter> i also think about these things at teh CMM level
13:01:15 <carter> and i'm comfortable saying CMM has proper tail calls by the scheme definition
13:01:33 <MP2E> I studied Cmm in GHC, and I like it a lot
13:01:39 <MP2E> I kinda wish I could program in it at times :P
13:01:44 <carter> MP2E: you can!
13:01:44 <levi> ski: Fairly sure; it's common to emphasize in the Scheme literature that not only recursive calls are subject to tail call optimization.
13:02:14 <carter> MP2E: its totallypossible write CMM and call it from haskell
13:02:33 <carter> MP2E: https://github.com/ekmett/rounded is an exotic example coauthored by copumpkin  and edwardk
13:02:40 <frerich_> Is there a nicer way to write ‘modifyMyData = loadMyData >> = saveMyData . modifyFn’?
13:03:13 <MP2E> wow neat
13:03:46 <levi> carter: Anyway, the only reason I brought it up is to illustrate the issues that are in play when a random person asks "does Haskell do tail call optimization?" An honest answer depends on what's actually being asked, I think, and so it will usually require a bit more discussion than typically happens.
13:03:54 <ruuns> Hey :)  Does there exists a module in the standard library / cabal that simple contains GHC's current Haskell Parser? (Thus everyone could construct abstract syntax tree for any haskell file)
13:03:59 <carter> levi: true
13:04:07 <MP2E> ruuns : you can use GHC itself, look up the GHC API :)
13:04:17 <dcoutts> ruuns: there's tow libraries, ghc itself and haskell-src-exts
13:04:39 <carter> but for the intro person it might be more accurate to say "yes, but the isssue you'll run into is not tail calls, but building large lazy expressions inyour accumulation parameters"
13:04:51 <dcoutts> ruuns: ghc-as-a-library is the real thing, but complicated, haskell-src-exts is a much simpler library to use
13:05:07 <carter> and takes less time (relatively)
13:05:09 <carter> to buid
13:05:54 <n-dolio> levi: It's certainly not clear to me from the beginning of that paper how GHC would not have proper tail recursion.
13:06:02 <ruuns> ahh great. i will check this :] thx
13:06:51 <ski> levi : i know, i just thought "proper tail recursion" was the technical term
13:07:05 <n-dolio> The inability to reason about space introduced by laziness would be due to heap allocation, and could be replicated in a strict language.
13:07:12 <n-dolio> Or, 'inability'.
13:08:27 <levi> n-dolio: Lazy evaluation means that, in the absence of strictness evaluation, the space cost of of program evaluation is no longer a lexically-scoped analysis.
13:08:59 <levi> s/strictness evaluation/strictness annotation/
13:09:53 <levi> Hmm. I should think about that; not entirely sure it's true as phrased.
13:10:50 <n-dolio> The last part of page 2 talks about space usage for _calls_ in a program that only makes tail calls.
13:11:13 <levi> n-dolio: The whole paper has a tacit assumption of strict semantics, though.
13:11:17 <n-dolio> And calls in GHC don't use space.
13:13:28 <n-dolio> Like, an exmaple where laziness uses more space would be something like: loop n = loop (n+1).
13:13:35 <n-dolio> But this is not using space for the calls.
13:13:48 <n-dolio> It is using space heap allocating thunks.
13:13:50 <levi> Anyway, I am not trying to argue that GHC doesn't do tail call optimization! I am saying that if someone understands "proper tail calls" as "I can reason about space usage the way I do in Scheme/ML, which was the point of putting tail call optimization guarantees in those languages" then you may be misled if told that GHC does tail call optimization without further discussion of what that means.
13:14:22 <levi> Furthermore, I see some people saying "Haskell doesn't do tail call optimization!" which is also misleading.
13:14:55 <n-dolio> And I can write a strict program like: loop n = loop (\() -> n() + 1) that will do arbitrary amounts of heap allocation even with proper tail recursion.
13:15:21 <pxqr> does any package provides Word4 datatype with corresponding Bounded, Bits, Num, etc instances
13:15:22 <pxqr> ?
13:15:46 <levi> If my point has not been made by now, there's no point in me arguing it any further, so I'm just going to drop out of the discussion now.
13:16:11 <n-dolio> Yes, certainly you can't reason exactly the same way as a strict language about everything.
13:17:05 <n-dolio> The commonality is that you don't need to worry about tail calls consuming space for some stack.
13:18:24 <pxqr> just found this one http://hackage.haskell.org/package/OddWord-1.0.0/docs/Data-Word-Odd.html
13:20:58 <frerich_> pxqr: Finally I have a proper type for my 19 bit numbers!
13:21:15 <pxqr> frerich_: ok :)
13:21:53 <pxqr> frerich_: i'm just experimenting with lfsr
13:23:52 <Enigmagic> pxqr: Word64 is in base in the Data.Word module
13:24:13 <Enigmagic> :t Data.Word.Word64
13:24:14 <lambdabot>     Not in scope: data constructor ‘Data.Word.Word64’
13:24:18 <Enigmagic> aww
13:24:34 <pxqr> but i need Word4
13:24:46 <Enigmagic> i read that as 64 :)
13:27:49 <serutsubi> Does it exist some kind of predefined module or function which parses arguments. I think my way of doing it is tedious and inefficient (getArgs and lots of case statements)
13:29:14 <pxqr> serutsubi: optparse-applicative
13:29:15 <silver_> there is arair
13:29:23 <silver_> afair*
13:31:03 <pxqr> serutsubi: base package has System.Console.GetOpt
13:33:50 <serutsubi> pxqr: Thanks, this is just what I was looking for!
13:54:22 <mmachenry> I am having some trouble figuring out how to get some code to be more idiomatic as well as behave properly in STM. My code is marching off to the right but the problem is it uses Maybe in the opposite way its monadic instance would help me with. http://lpaste.net/107978
13:54:59 <mmachenry> Also in that program, I want to block and wait for many queues but I have what is probably a CPU bound recursive loop which is probably very bad for STM but I don't quite know if that's true.
13:55:03 <c_wraith> mmachenry: yeah, using MaybeT would help you out
13:55:20 <c_wraith> mmachenry: wait, no
13:55:26 <mmachenry> c_wraith: … yeah :)
13:55:27 <c_wraith> mmachenry: that can actually be made one line
13:55:33 <mmachenry> Oh ?
13:55:46 <c_wraith> well, one *really ugly* line
13:56:12 <mmachenry> I see where you're going with the Maybe monad. I know how to use Maybe as a monad. But it's the opposite of the Maybe monad. I want to short circuit on Just, not Nothing.
13:57:12 <RchrdB> mmachenry, I have half a neuron that insists that maybe the MonadPlus instance for Maybe does what you want?
13:57:18 <ski> if it was just `Maybe', it'd be a matter of `mplus'
13:57:29 <c_wraith> eh, not so bad.  foldr1 (<|>) $ map (\f -> readTBQueue (f myqueue)) [ highPriorityQueue, mediumPriorityQueue, lowPriorityQueue ]
13:57:32 <c_wraith> mmachenry: ^
13:57:36 <monochrom> mmachenry: I think your job is better served by combining blocking read with orElse, instead of writing your own polling based on non-blocking read.
13:57:39 <c_wraith> mmachenry: they key is understanding how STM works
13:57:43 <c_wraith> *the
13:57:51 * ski forgets what `mplus' for `MaybeT' does exactly
13:58:12 <hpc> > "there's a tool for that"
13:58:13 <lambdabot>  "there's a tool for that"
13:58:20 <mmachenry> monochrom: Oh that sounds very promising, yes
13:58:28 <c_wraith> mmachenry: that's exactly what my example does
13:58:37 <mmachenry> I remember that from Simon Marlows book. I am going to reread this, one moment
13:58:40 <c_wraith> mmachenry: in STM, nothing "blocks".
13:58:59 <c_wraith> mmachenry: at least, not in the way you would think of.
13:59:06 <frerich_> Are there some best practices as to how determine/define version constraints in the ‘build-depends’ section of .cabal files? ‘cabal init’ came up with some defaults, but my gut feeling is that maybe I should just remove all constraints and wait until I (or somebody else) actually notices an issue with some package being too old or too new...
13:59:15 <dfeuer> Oddly enough, it seems there's no general agreement on what mplus is supposed to mean.
13:59:17 <quchen> ski: https://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Maybe.html#line-109
13:59:17 <mmachenry> c_wraith: How does readTBQueue always get a value and wait until it does?
13:59:31 <c_wraith> mmachenry: if there isn't a value available, it calls retry
13:59:45 <c_wraith> mmachenry: and what retry does is up to the STM machinery
13:59:51 <n-dolio> c_wraith: To recreate the original example, isn't foldr with 'retry' more appropriate?
13:59:51 <mmachenry> retry might be what I should do at the end of my function then, instead of recur
14:00:06 <c_wraith> n-dolio: that's implicit anyway
14:00:13 <quchen> ski: In other words, "do the same as Maybe without surprises".
14:00:18 <n-dolio> Oh.
14:00:27 <c_wraith> n-dolio: since if the left argument to <|> retries, the whole expression retries
14:00:49 <ski> mmachenry : looks like `mplus' in `MaybeT STM' would work, then (ty quchen)
14:01:11 <c_wraith> ski: that's way more work than is needed, though.  just using the calls that retry solves the problem
14:01:43 <mmachenry> Yes quite likely and also at the end retry I think is the solution to my second question, right?
14:01:54 <c_wraith> mmachenry: you don't need to do it manually
14:02:03 <mmachenry> Hm?
14:02:08 <c_wraith> mmachenry: if you use the non-try interface, the calls will retry for you
14:02:20 <c_wraith> mmachenry: you're completely missing out on STM already doing what you want
14:02:27 <c_wraith> mmachenry: you're trying to re-implement STM in STM
14:02:34 <monochrom> mmachenry: http://lpaste.net/107982
14:02:50 <mmachenry> c_wraith: Oh right if I were to do readTBQueue high orElse readTBQueue low that would work.
14:03:03 <RyanGlScott> Is there an easy way to get a newtype to have the exact same Show mechanics as its wrapped type using "deriving"?
14:03:04 <monochrom> yes
14:03:12 <RyanGlScott> XGeneralizedNewtypeDeriving doesn't do the trick
14:03:36 <mmachenry> Alright, orElse. I'm remember orElse now from the book. Going back to read that. Thanks so much guys. :)
14:03:44 <monochrom> readTBQueue contains its own retry.
14:03:44 <quchen> monochrom: "Yes"? Deriving adds the newtype constructor, no?
14:03:51 <i_am_neuron> Hi folks, newbie here. I'm implementing a primitive logging system within IO that I can switch on and off when needed, without changing anything in the code except the logMessage definition. I got as far as this: http://lpaste.net/107983
14:03:52 <ski> RyanGlScott : why do you want that ?
14:04:04 <dfeuer> RyanGlScott: Show is the special exception there. And no, I don't think you can do anything about that.
14:04:04 <monochrom> no, my "yes" is for using orElse
14:04:14 <rwbarton> forunately "deriving" show by hand is not very taxing
14:04:20 <Zekka> Hey guys, how would you react to seeing this definition?
14:04:28 <quchen> Oh. In that case, RyanGlScott: No, you cannot influence the way "deriving" works.
14:04:37 <Zekka> uniquePairs :: Eq a => [a] -> [(a, a)]; uniquePairs = nub . join (liftA2 (,))
14:04:42 <RyanGlScott> Ah, I was afraid of that. Oh well. I'll just do the gruntwork and manually make an instance for Show.
14:04:43 <i_am_neuron> In short, I was able to make my logging work within IO, but when I want to switch it off (there's a commented section in the code) and bring it into Identity monad, the rest of the code does not typecheck any more because of other uses of IO
14:04:45 <quchen> And since a newtype has a different type than what it wraps, its Show instance should represent that.
14:05:02 <quchen> Also note that Show is not for prettyprinting. https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
14:05:04 <ski> RyanGlScott : make sure to implement `showsPrec'
14:05:13 <i_am_neuron> I suspect, I need to lift Identity to IO or something similar. Any help here?
14:05:21 <RyanGlScott> ski: For what reason?
14:05:30 <ski> RyanGlScott : efficiency
14:06:11 <ski> RyanGlScott : something like `instance Show Wrapped where showsPrec p (Wrap x) = showsPrec p x', assuming `newtype Wrapped = Wrap Unwrapped'
14:06:52 <ski> RyanGlScott : however .. you still didn't answer my original question
14:07:02 <monochrom> i_am_neuron: getCurrentDirectory is IO-only
14:07:35 <RyanGlScott> ski: Ah, sorry. I probably should just be using a type synonym, although I'm slightly paranoid that users would manipulate the underlying data when they shouldn't.
14:08:10 <i_am_neuron> monochrom: Yep. I'm chaingin getCurrentDirectory (which is IO) with logMessgae (when it's IO) with zero problems. Any way to chain getCurrentDirectory with logMessage in Identity?
14:08:19 <RyanGlScott> ski: So I want to make the type "act" identically without being identical.
14:08:36 <RyanGlScott> ski: e.g., have show display the same contents.
14:08:38 <monochrom> no, Identity does not support getCurrentDirectory.
14:08:44 <i_am_neuron> monochrom: I.e. I'm fine with other IO in my program, but the IO of logging should be switchable. Is there a way to do this?
14:09:03 <ski> RyanGlScott : could you add more particulars detail ?
14:09:04 <monochrom> no, the class Logging does not support turning off logging
14:10:16 <monochrom> this an instance of: when you only have a nail, all you can think of is going in or getting out (i.e., you cannot think of going sideways)
14:10:57 <RyanGlScott> ski: It's a newtype where the underlying data is different depending on the OS you're using.
14:11:30 <ski> hm
14:11:34 <RyanGlScott> ski: So exposing the underlying data would probably create a lot of unportable code
14:11:52 <i_am_neuron> monochrom: Hmmm. Do you have any idea what this guy is talking about: http://stackoverflow.com/a/17303256/3894 ? I'm trying to follow his advice (though maybe he just gives bad advice)
14:11:53 <RyanGlScott> ski: At least, if users tried manipulating it
14:12:06 <monochrom> RyanGlScott: if you have "newtype X = Xtor Y", then you can write "instance Show X where showsPrec n (Xtor y) = showsPrec n y" and that's it
14:12:30 <ski> i hope you're only using the `Show' for debugging/experimenting in the interactor, and maybe as a simple serialization thing
14:12:48 <RyanGlScott> monochrom: That's right, although I wish I were clever enough to come up with a way to avoid that boilerplate.
14:13:24 <i_am_neuron> monochrom: Or maybe his advice only applicable to logging within non-IO functions?
14:13:25 <monochrom> "deriving Show" merely adds the "Xtor" string
14:13:40 <ski> (and possibly brackets)
14:13:57 <monochrom> this is an instance of: cannot please everyone
14:14:01 <RyanGlScott> monochrom: I guess it's really not that big of an issue. I'll just be content with that.
14:14:17 <monochrom> if Haskell requires "deriving Show" to add "Xtor", half of the users are unhappy
14:14:25 <monochrom> if Haskell requires "deriving Show" to omit "Xtor", the other half of the users are unhappy
14:15:07 <RyanGlScott> For curiosity's sake, is there a way to add your own "deriving" logic (without hacking the compiler itself)?
14:15:21 <monochrom> i_am_neuron: the advice assumes non-IO, yes
14:15:21 <quchen> The second half is misunderstanding Show.
14:15:43 <jle`> RyanGlScott: actually...yes, kinda :)  but it wouldn't be with a deriving keyword.
14:15:44 <quchen> Wait, I take that back.
14:15:52 <Hodapp> Dang, where did roconnor go? I wanted to ask him about his notion that people should learn Agda as a first language.
14:16:07 <jle`> RyanGlScott: there is a typeclass that you can derive that sort of reifies/makes accessible the structure of your data type
14:16:08 <kuyatzu> RyanGlScott: just make the instance Show by hand?
14:16:11 <quchen> That's a funny notion, Hodapp.
14:16:19 <i_am_neuron> monochrom: I was reading about monad transformers a bit -- they won't be helpful here, won't they?
14:16:23 <monochrom> I'm stating it very generously already. :) it's more like: 50.5% are unhappy for the first choice, 50.5% are unhappy for the second choice. because there is always 1% who are always unhappy. :)
14:16:28 <monochrom> no
14:16:29 <jle`> RyanGlScott: oh, did you mean a new 'deriving' for your own new typeclasses, or for Show/etc.?
14:17:00 <RyanGlScott> Something like "deriving MyShow", and also have "instance MyShow a => Show a where ..."
14:17:01 <quchen> monochrom: Could be even more than 1% given your numbers, since (not not happy) does not imply "happy" ;-)
14:17:10 <Hodapp> quchen: Maybe he'll return to answer for it.
14:17:46 <RyanGlScott> Where MyShow is a custom typeclass
14:18:05 <monochrom> GeneralizedDeriving may help
14:18:56 <RyanGlScott> I see only GeneralizedNewtypeDeriving, not GeneralizedDeriving...
14:19:18 <RyanGlScott> The former is nice, but not tweakable enough
14:19:36 <RyanGlScott> ...or maybe it would be. Let me experiment.
14:19:46 <monochrom> I misremembered. it is GeneralizedNewtypeDeriving
14:20:32 <quchen> With generics you can also make your own "deriving" things in a sense.
14:20:46 <quchen> But that's a little much given all you want is omit a constructor representation.
14:21:58 <RyanGlScott> quchen: Which "generics" are you referring to?
14:21:59 <i_am_neuron> monochrom: Is there an accepted standard way of doing logging without bringing in unnecessary IO?
14:22:11 <monochrom> I don't know
14:23:09 <quchen> RyanGlScott: GHC.Generics
14:23:15 <quchen> http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Generics.html
14:23:19 <i_am_neuron> monochrom: And if we stick to the definition in the code I shown, there's no way to transform between Identity and IO? I.e. this is a completely wrong direction, right?
14:23:47 <quchen> RyanGlScott: There's a good talk about it by Löh, but it's not really beginner stuff (but not super high level either).
14:23:57 <RyanGlScott> quchen: Ah, neato. That'll give me some reading/watching material for a while.
14:23:59 <quchen> So if you're just past LYAH it might be a little early.
14:24:26 <monochrom> your job is to stay with IO even after turning off logging, since you are doing getCurrentDirectory. it seems to me strange, then, to keep pressing the question "how do I log without IO". your job violates "without IO" to begin with.
14:25:28 <RyanGlScott> quchen: I asked since I've heard of a ton of different "generics" libraries (Stratego, SYB, KURE, uniplate, etc.)
14:25:31 <quchen> RyanGlScott: This is what I'm talking about: https://skillsmatter.com/skillscasts/3932-a-haskell-lecture-with-leading-expert-andres-loh
14:25:46 <quchen> RyanGlScott: I think SYB is what started the thing that became GHC.Generics eventually
14:26:02 <quchen> You can also check out his other talks, in particular the one about free monads
14:26:08 <quchen> He's quite a good presenter
14:26:35 <RyanGlScott> Thanks for the link! This looks enlightening.
14:27:06 <i_am_neuron> monochrom: Well, my question is more in the vein "How not to bring extra IO when logging is off". I'm happy for the work function to have signature "IO ()" because of getCurrentDirectory but also contain logMessage calls that actually do no IO
14:27:45 <i_am_neuron> monochrom: "also contain logMessage calls that actually do no IO" -- that was about the work function in the code
14:30:03 <monochrom> I don't know what logging libraries are available and what they do, but you should look for one that supports "turn off logging without changing type", as opposed to "turn off logging by changing type", since you cannot change type.
14:32:10 <i_am_neuron> monochrom: Oh, will this mean that non-IO function that will contain logging (like mkFilePath in my code) can only exist as IO ones?
14:32:42 <monochrom> I don't know
14:33:29 <i_am_neuron> monochrom: Cool, thanks anyways. Sorry if slightly stupid question
14:34:52 <quchen> i_am_neuron: It's not a stupid beginner question, but it's probably hard or hacky to do properly, and having it in IO no matter what is probably easier.
14:35:15 <RyanGlScott> Dumb question: how does ShowS allow for constant-time concatenation?
14:35:22 <quchen> RyanGlScott: Like DList
14:35:26 <joelteon> function composition
14:35:49 <i_am_neuron> quchen: Having everything in IO sort of defeats the purpose of significant part of typechecking, no?
14:35:50 <quchen> RyanGlScott: This might help, https://ocharles.org.uk/blog/posts/2012-12-14-24-days-of-hackage-dlist.html
14:35:53 <RyanGlScott> Right, I get that. But wouldn't that just delay several series of concatenations until the composed function is evaluated?
14:36:16 <quchen> i_am_neuron: Oh no don't put *everything* in IO, only the parts that might need it (i.e. the logging).
14:36:26 <ski> RyanGlScott : effectively, it right-associates calls to `(++)'
14:36:52 <pjdelport> RyanGlScott: http://www.haskell.org/haskellwiki/Difference_list
14:36:57 <quchen> A logging function with logging turned off is fine to still be in IO. IO isn't wrong per se, it's just something you should avoid when it's unnecessary. In your case, I think it's necessary.
14:37:07 <i_am_neuron> quchen: I'm actually experimenting with it (i.e. not doing it for my job), so I'm happy with hard or hacky way, just to make my way through it
14:37:45 <i_am_neuron> quchen: Most production systems log literally every action they make (with low priority), so 99% of functions will be IO then (because everything needs to be logged)
14:37:51 <ReinH> RyanGlScott: are you asking about diff lists?
14:38:02 <RyanGlScott> So for one-time usages of show, is ShowS any more efficient?
14:38:19 <joelteon> show *does* use shows
14:38:30 <ReinH> RyanGlScott: I just wrote about them: http://reinh.com/notes/posts/2014-07-16-diff-lists%2C-cont%2C-yoneda%2C-and-free-monad-optimizations.html
14:38:30 <RyanGlScott> At the end, you'll still need to resolve the function, which should take O(n) time.
14:38:34 <ski> RyanGlScott : `((..(a ++ b)..) ++ y) ++ z ' is worse than `a ++ (b ++ (..(y ++ z)..))'
14:38:52 <joelteon> I thought shows was linear time?
14:39:18 <RyanGlScott> joelteon: This claims otherwise http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:ShowS
14:39:22 <ReinH> RyanGlScott: short story: definition of function composition ensures right associativity.
14:39:27 <alphonse23_> why is haskell so slow?
14:39:29 <quchen> ShowS composition is constant time, ShowS->String conversion is linear.
14:39:30 <joelteon> Well hang on, now I'm confused
14:39:31 <quchen> alphonse23_: No.
14:39:32 <ski> RyanGlScott : `((..((a ++) . (b ++))..) . (y ++)) . (z ++)' isn't much different than `(a ++) . ((b ++) . (..((y ++) . (z ++))..))'
14:39:33 <ReinH> long story: read my post ;)
14:39:37 <joelteon> Ohh, ok
14:39:38 <alphonse23_> and why is GHCi 2gb big
14:39:40 <alphonse23_> that's huge
14:39:41 <monochrom> is haskell slow?
14:39:42 <joelteon> yeah, quchen knows what's going on
14:39:56 <RyanGlScott> ReinH: Oh, that does make sense, now that I think about it.
14:40:01 <alphonse23_> it is. It's generally slower than everything else
14:40:13 <monochrom> not in my experience
14:40:14 <ReinH> RyanGlScott: I prove it equationally :)
14:40:38 <joelteon> RyanGlScott: to clarify, concatenating 'shows' values is constant time, the conversion at the end isn't
14:40:47 <ski> alphonse23_ : Haskell is a programming languages. programming language in general are neither fast nor slow. a particular program in a programming language, executed with a particular implementation on a particular platform with particular input may be slow or otherwise
14:40:48 <alphonse23_> haskell is slow slow slow
14:40:52 <joelteon> but it's still better than concat'ing a bunch of 'show'n values
14:41:25 <RyanGlScott> So the trick is to make concatenation favor short lists on the left-hand side of (++)?
14:41:45 <joelteon> right
14:41:46 <alphonse23_> ski: well haskell is typically slower than most other programming languages that do that same thing. I think it's slow because of it's purity. It's a great concept and thing to think about, but it makes it so slow. Memory does speed things up you know.
14:41:47 <ReinH> No
14:41:53 <joelteon> wrong
14:41:59 <joelteon> okay, I'm going to stop contributing now :)
14:42:11 <ReinH> RyanGlScott: I could explain here but I would be repeating myself :) read the post!
14:42:17 <quchen> Slow because of purity, that's a new one
14:42:24 <ReinH> RyanGlScott: I'd love feedback too.
14:42:28 <joelteon> ReinH, if your messages were a difference list, repeating yourself would take constant time
14:42:29 <RyanGlScott> ReinH: That was my attempt at summarizing your blog post's example. Is it accurate?
14:42:45 <ReinH> Ahh. No. which means I was unclear...
14:43:22 <ReinH> it ensures one list on the left composed with (the rest of the lists) on the right.
14:43:28 <kludgy> i_am_neuron: Always be thinking in terms of creating rich enough typed datum that can be mapped to log output 'on the outside'. For large scale systems, there is usually a service (or many) that provide events. Logging is no more and no less than the act of transforming the evidence provided by raised events into some sort of new output. You may or may not have type information at this point
14:43:28 <kludgy> depending on the system, but at least within Hask you always have the types.
14:43:34 <ReinH> and so for that list on the right. and etc.
14:44:04 <joelteon> ++ is linear on the length of the left-hand list, isn't it?
14:44:13 <ReinH> yes
14:44:13 <quchen> ?src (++)
14:44:14 <lambdabot> []     ++ ys = ys
14:44:14 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:44:14 <lambdabot> -- OR
14:44:14 <lambdabot> xs ++ ys = foldr (:) ys xs
14:44:30 <ReinH> joelteon: look at where I show the evaluation.
14:45:22 <monochrom> if you intend to print the whole x++y, it does not matter whether x is shorter or longer than y.
14:45:56 <monochrom> but it matters whether you have (x0++x1)++x2... or x0++(x1++x2...)
14:47:07 <joshc> ReinH: feedback: the title is a bit misleading, it isn't obvious what the post has to do with Yoneda?
14:47:25 <RyanGlScott> That's seems to make sense. Although I have to wonder at what point you start noticing performance benefits from it.
14:47:28 <ReinH> joshc: it's incomplete
14:47:44 <quchen> Oh. Was about to remark that.
14:47:49 <ReinH> RyanGlScott: you get asymptotic improvement, which I also explain.
14:47:56 <quchen> Okay okay I've seen Endo get to the Yoneda part … end :-(
14:48:11 <ReinH> quchen: sorry. still writing it.
14:48:27 <ReinH> I told RyanGlScott about it because what I have is directly useful.
14:48:34 <quchen> I'm looking forward to reading it.
14:48:41 <ReinH> ok :)
14:48:47 <quchen> (I also linked the 24days post about DList somewhere above for him)
14:48:50 <RyanGlScott> ReinH: Okay, suppose I have a super-short data type like a MAC address. How could implementing showPrec instead of show be significantly better?
14:49:00 <monochrom> RyanGlScott: I noticed a big difference empirically when 1000 (++)'s were involved, when I helped someone speed up his code.
14:49:05 <ReinH> RyanGlScott: it wouldn't.
14:49:17 <monochrom> it was like 30 seconds vs 0.5 seconds
14:49:19 <ReinH> it's an *asymptotic* improvement
14:49:32 <RyanGlScott> Heh, I guess "1000s of (++)s" will be my new metric.
14:49:48 <quchen> Oodles of (++)
14:49:50 * hackagebot statistics 0.13.1.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.13.1.1 (BryanOSullivan)
14:50:45 <ReinH> Performance diverges as n (number of concats) gets larger
14:50:52 <b52> Could someone help me figuring out why Elm doesn't install in my sandbox? https://paste.xinu.at/BCDwD/
14:51:19 <joelteon> it's sort of n-squaredy
14:51:24 <ReinH> quchen: the Yoneda connection I'm getting to is that If CPS is flip ($), Yoneda is flip fmap
14:51:26 <josephle> remind me to use (<>) to deviously bypass your metric
14:52:01 <quchen> ReinH: I know the connection, but it doesn't come very intuitive to me. So I'm looking for an easy way in, which is where you come in :-)
14:52:09 <ReinH> So CPS is a Yoneda embedding.
14:52:16 <ReinH> quchen: ok I'll try :)
14:52:23 <jfischoff> b52: You might be running out of space in tmp
14:52:24 <quchen> CPS = Codensity Identity or something then?
14:52:35 <RyanGlScott> So you should shun show $ s1 ++ s2 ++ ... ++ sx in favor of showsPrec s1 . showsPrec s2 . ... . showsPrec sx (modulo operator precedence)?
14:52:52 <jfischoff> b52: something it up with your /tmp is my guess, maybe not space per say ...
14:53:27 <b52> hm, its a tmpfs partition of 1.5g, i thought that would be enough
14:53:55 <b52> is there a paramter to tell cabal to use a different temp directory?
14:54:01 <jfischoff> b52: http://stackoverflow.com/a/24154697
14:54:14 <ReinH> :t flip fmap
14:54:14 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:54:23 <ReinH> :t flip ($)
14:54:24 <lambdabot> b -> (b -> c) -> c
14:54:31 <ReinH> f ~ Identity
14:54:45 <monochrom> if I have merely x++y++z, I just write x++y++z, the computer will consider it x++(y++z) already because ++ is declared infixr
14:55:07 <monochrom> the real issue is when I recursively build a string
14:55:37 <monochrom> f n = f (n-1) ++ "x"  this is going to be bad
14:55:51 <RyanGlScott> monochrom: Ah, that would be bad.
14:55:52 <ReinH> quchen: so it's Yoneda specialized to Identity :)
14:56:08 <dvennink> What's the general naming convention for as-patterns? Say ...@(x:xs)? xxs@ feels like a list of lists. all@ feels out of place if you have multiple as-patterns.
14:56:14 <jfischoff> b52: according to the cabal github, that issue is fixed in cabal-install HEAD FWIW
14:56:21 <b52> jfischoff, I was explicitly setting LANG=C cause I had some issues with that
14:57:49 <RyanGlScott> monochrom: So how would you rewrite that with the dlist package?
14:57:59 <c_wraith> dvennink: those are pretty much the standard patterns, but no one will complain if you don't use either. It's not a strongly idiomatic area.
14:58:35 <quchen> RyanGlScott: You can see it yourself here: http://lpaste.net/107988
14:58:36 <monochrom> I don't even use dlist.
14:58:41 <quchen> The slow ones are much slower (surprise!)
14:58:57 <benzrf> :t (~)
14:58:58 <lambdabot> parse error on input ‘)’
14:59:00 <RyanGlScott> monochrom: What would you use then?
14:59:02 <benzrf> meh
14:59:09 <quchen> ~ is syntax, not an operator.
14:59:27 <monochrom> helper 0 = id; helper n = helper (n - 1) . ('x' :); f n = helper n ""
14:59:36 <c_wraith> RyanGlScott: newtype DList a = Dlist ([a] -> [a]) ...  It's easy to just not deal with the newtype.
15:00:12 <dvennink> c_wraith: Cheers.
15:00:29 <enthropy> dvennink: I think xxs @ (x:xs) is pretty common
15:00:54 <monochrom> I write "list@(h:t)"
15:01:15 <RyanGlScott> Thanks for the patient explanations. I'll try this out and try to grok it fully.
15:02:20 <benzrf> quchen: o rly
15:02:22 <benzrf> :k (~)
15:02:23 <lambdabot> k -> k -> Constraint
15:02:31 <benzrf> looks like an operator to me ;)
15:03:26 <kludgy> benzrf: I've seen this ~ before in error messages and a few other places as a type operator.. what does it actually mean?
15:03:34 <quchen> You were asking for its type, and the only thing on the value level with ~ is irrefutable patterns, and that's syntax.
15:03:38 <dvennink> I'll settle for xxs. It reads like the combination of x:xs, which it is. Thanks guys.
15:03:42 <MP2E> kludgy: type equality
15:03:44 <benzrf> kludgy: foo ~ bar is a constraint requiring that foo is bar
15:03:46 <ReinH> @google Kan extensions for program optimization
15:03:47 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
15:03:47 <lambdabot> Title: Kan Extensions for Program Optimisation Or: Art and Dan Explain an Old Trick
15:03:54 <kludgy> Ah cheers!
15:03:54 <ReinH> quchen: ^
15:04:01 <ReinH> if you're impatient ;)
15:04:03 <benzrf> a ~ b => a -> b is a fancy way of writing a -> a
15:04:21 <benzrf> speaking of which
15:04:25 <benzrf> types get linear patterns!
15:04:26 <benzrf> err
15:04:27 <benzrf> non linear
15:04:29 <quchen> ReinH: 39 pages is a lot for someone who is impatient. Errr I meant "thanks"
15:04:31 <kludgy> benzrf: Interesting. You wouldn't believe how hard the symbol is to search for online. :)
15:04:35 <ReinH> @where a novel representation of lists
15:04:36 <lambdabot> I know nothing about a.
15:04:47 <ReinH> @google a novel representation of lists
15:04:49 <lambdabot> http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/lists.pdf
15:04:49 <lambdabot> Title: A NOVEL REPRESENTATION OF LISTS AND ITS APPLICATION TO THE FUNCTION “ REVER...
15:04:51 <benzrf> if haskell already has non linear patterns, why not let us have them in value patterns as well
15:04:55 <benzrf> ;-;
15:05:04 * JHaas is away: let Away = { garbage_collect ;  idle_cycle ; sleep_mode }
15:05:12 <ReinH> Oh never mind
15:05:18 <monochrom> type is easier than value
15:05:19 <ReinH> quchen: :p
15:05:52 <monochrom> for example there is pervasive type equality but no pervasive value equality
15:06:17 <quchen> monochrom: What exactly is "~" on the type level? Is it similar to :~:, i.e. a constraint that requires a proof that both sides are equal?
15:06:32 <monochrom> I don't know
15:06:50 <quchen> Stop not knowing! You're my authorative source in here :-(
15:06:51 <monochrom> perhaps yes, but proofs of type equality in haskell are easy
15:08:04 <quchen> monochrom: Because type families are very simple equations?
15:08:20 <monochrom> I don't know
15:08:33 <quchen> ಠ_ಠ
15:08:49 <monochrom> I am not a type theorist. I have not even read HoTT.
15:08:57 <Zekka> :k (~)
15:08:57 <jfischoff> get out!
15:08:58 <lambdabot> k -> k -> Constraint
15:09:11 <enthropy> questions like "what exactly is x" are hard (impossible?) to answer
15:09:11 <Zekka> It's one of those!
15:09:23 <monochrom> so I don't even know why there is anything need proving to begin with. GHC infers types. end of story for me.
15:09:27 <jfischoff> monochrom is a type realist
15:09:32 <joelteon> what exactly is equality?
15:09:54 <monochrom> oh, I know what exactly equality is. I have thought that one through.
15:10:00 <rasfar> FTR, two pieces of misinformation I've dropped on the list and want to correct:  (1) Control.Exception.evaluate only forces to WHNF. (2) The way "Class =>" is implemented was not in the SOP paper, it was in the "Types Jim..." presentation where I saw it.
15:10:20 <kludgy> monochrom: But how do you know that you know? ;)
15:10:36 <monochrom> my answer is summarized at http://www.vex.net/~trebla/humour/tautologies.html #9
15:14:16 <ph88> is it possible to have something (variable? function?) react differently depending on which function is applied to it?
15:14:19 <josephle> joelteon: a whole lot of refls
15:14:25 <joelteon> oh, good
15:14:33 <joelteon> ph88, what are you trying to do
15:15:07 <ph88> im considering the possibilities to mimic an object
15:15:57 <monochrom> do you have two examples?
15:16:09 <ph88> what kind of examples ?
15:16:22 <rwbarton> preferably illuminating ones
15:16:23 <monochrom> concrete kind of examples
15:16:31 <joelteon> maybe in other languages?
15:16:38 <ruuns> can anyone recommend a good argument parser module?
15:16:39 <ruuns> :)
15:16:42 <joelteon> options
15:17:11 <frerich_> ruuns: I liked Neil Mitchell’s one.. CmdArgs was the name IIRC
15:17:14 <ph88> i'm thinking about it
15:17:20 <monochrom> or any kind of examples you already have
15:18:00 <monochrom> the point is if you don't even have something resembling an example, you're thinking nothingness.
15:18:18 <ph88> i'm definately thinking something :P
15:18:31 <Pythonfant> I'm getting an error when trying to install hakyll http://lpaste.net/107989
15:18:46 <Pythonfant> is there a way to get a more precise error message than exitfailure?
15:18:59 <joelteon> 9 is memory exhaustion, isn't it?
15:19:34 <ruuns> joelteon, frerich_: thx :]
15:19:43 <joelteon> uh, no problem
15:19:46 <monochrom> ruuns: I like optparse-applicative. I have a realistic example at https://github.com/treblacy/random-read
15:19:47 <rwbarton> most likely yes
15:20:15 <kludgy> ph88: Here's one thought on the general matter: It's all about functions and types. There are a number of esoteric tools, but one that I found easy to get started with was partially applying functions to match a common, useful signature. For instance: Foo -> Int -> Char and Bar -> Int -> Char can both be reduced to the same type of function 'Int -> Char' by applying just the first element.
15:20:16 <kludgy> Now you have a homogeneous function type for storage in lists, etc.
15:20:40 <kludgy> element = parameter sorry
15:20:52 <Pythonfant> joelteon: you seem to be right
15:21:00 <Pythonfant> it uses more than 10gb of ram
15:21:03 <joelteon> seen that too many times Pythonfant
15:21:09 <joelteon> I feel yourp ain
15:21:15 <rwbarton> that sounds a bit excessive
15:21:21 <ph88> ok i'm thinking more along the lines of how to model an oject graph of the domain with circular references
15:21:37 <Pythonfant> 10gb is really a lot
15:21:51 <kludgy> ph88: This sounds a lot like applied graph theory
15:22:02 <monochrom> then sometimes you just need several values referring to each other
15:22:50 <frerich_> ruuns: Here’s a real-life example of using CmdArgs: https://github.com/frerich/lambdacrawler/blob/master/src/Arguments.hs
15:22:58 <ph88> i'm gonna try a little bit of code
15:23:13 <ruuns> So much choice, hehe. thx
15:23:32 <monochrom> x = '0' : x  has a circular reference. but this is only one value.
15:23:35 <Enigmagic> ruuns: optparse-applicative gets my vote
15:23:53 <rwbarton> huh, pandoc-citeproc-0.3.1 does not even use -O2
15:24:19 <monochrom> x = '0' : y; y = '1' : x  is two values with circular references
15:24:49 <monochrom> you could have several records with some fields referring to each other, too
15:24:54 <Pythonfant> joelteon: I killed everything I didn't need so I've got around 15gb of free ram and tried it again and now I got a stack overflow
15:25:05 <joelteon> sounds sort of suspicious
15:25:09 <Pythonfant> yep
15:27:12 <Enigmagic> Pythonfant: what version of GHC?
15:27:18 <Pythonfant> 7.8.3
15:27:23 <Pythonfant> seems to be related to O2
15:28:04 <rwbarton> do you have -O2 set in cabal config?
15:28:18 <i_antr0g3n> liteirc.net is already in ownership 2 be used via teh network in question! linkers based on mass agreement, unmoderated channels uther than 4 true moderation issues, like flooding, is the goal. Enjoy the kline!
15:28:22 <Pythonfant> yep, I'm currently trying with -O1
15:28:56 <Enigmagic> i wouldn't be surprised if it only happens with -O2
15:29:19 <Pythonfant> hasn't yet finished building but ram usage is not climbing up so I guess that fixed it
15:29:30 <MP2E> O2 seems to have issues sometimes :V
15:29:36 <Pythonfant> http://www.haskell.org/pipermail/ghc-devs/2014-March/004363.html
15:29:48 <MP2E> with GHC 7.8.2 I tried building a bunch of packages with -O2 and I would often run out of memory
15:29:57 <joelteon> jesus, 450 modules?
15:29:58 <i_antr0g3n> liteirc.net is already in ownership 2 be used via teh network in question! linkers based on mass agreement, unmoderated channels uther than 4 true moderation issues, like flooding, is the goal. Enjoy the kline!
15:30:04 <MP2E> haskell-src-exts, alex, happy, regex-tdfa.. those all caused my memory to explode
15:30:09 <Pythonfant> built fine now
15:31:13 <rwbarton> probably SpecConstr
15:31:16 <i_antr0g3n> liteircnet@gmail.com
15:31:41 <MP2E> Pythonfant : I'm curious, try -O2 -fno-spec-constr
15:32:24 <i_antr0g3n> what freenode probably tried be it isn't. We need more active interaction. Freenode is for foss. Efnet is more skiddies and sluts. And anythink else large is innactive. Lookin 2 merge what is laready half of 12 1gig e servers to others - linkers are not required to do anything except be technically inclined. If you stay a linker is based upon mass agreement of current linkers. Lookin for unmoderated channels uther than for true moderation
15:33:04 <MP2E> wat
15:33:46 <MP2E> I have no idea what that guy was saying, but I have a feeling he didn't either
15:34:01 <joelteon> that's assuming it was a sentient human
15:34:04 <b52> :D
15:34:15 <MP2E> indeed
15:34:23 <benzrf> sluts?
15:35:52 <Pythonfant> MP2E: how can I pass this ghc option to cabal install?
15:36:34 <geekosaur> I understood what it was saying, but suspect whoever composed that has no concept of what it takes to maintain an IRC network
15:36:44 <geekosaur> "nice, so you want to recreate undernet"
15:37:20 <jfischoff> Pythonfant: ghc-options="-O2 -fno-spec-constr"
15:37:33 <jfischoff> err --ghc-options="-O2 -fno-spec-constr"
15:37:36 <MP2E> "I'll make my own network, with blackjack and hookers!.. actually screw the blackjack. Eh, screw the whole thing"
15:37:51 <geekosaur> "and somehow not having a clue about what you're getting into but being pure of *something* will make you not fall into the same trap as other IRC networks"
15:38:37 <Pythonfant> jfischoff: thx
15:39:56 <b52> jfischoff, it seems to compile now, thanks!
15:41:09 <kini> am I supposed to be seeing some colors at the bottom of this page? https://hackage.haskell.org/package/aeson/preferred
15:41:20 <kini> the text there seems to indicate yes, but I only see orange...
15:41:37 <Pythonfant> MP2E: you were right, it works with -fno-specs-constr
15:43:06 <geekosaur> looks like it's supposed to be setting link colors but isn't
15:43:15 <kludgy> MP2E: What is the current sort of pathology with SpecConstr? Is it hard to grasp?
15:43:33 <kludgy> (apologies I suppose this should be #ghc)
15:48:40 <int3__> would anyone be interested in a vim indent script that supported indenting 'where' by negative 2 spaces? (i.e. the style described by the tibbe / snap style guides)
15:56:23 <MP2E> kludgy : this paper explains it better than I can :) http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
15:56:44 <MP2E> thankfully it's rather short too hehe
15:58:19 <kludgy> MP2E: Nice thanks!
16:00:40 <vova> Please help. I have data Test = Test {some :: Maybe String, one :: Maybe Int} deriving (Show,Eq)
16:00:53 <vova> let a = Test {some=Nothing,one=Just 1}
16:01:42 <vova> How to check if there is any `Nothing` in a value 'a'?
16:04:15 <pjdelport> \(Test a b) -> isNothing a || isNothing b
16:04:40 <kludgy> vova: Hoogle can be helpful here: http://www.haskell.org/hoogle/?hoogle=Maybe+a+-%3E+Bool
16:04:53 <pjdelport> There are many other ways to approach it, though, depending on the context.
16:05:08 <ParahSailin_> @hoogle Maybe a -> Bool
16:05:10 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
16:05:10 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
16:05:10 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:07:21 <vova> So I need to get the type value from 'a' and check using some Maybe a -> Bool function. I see. But i have a very huge data with a lot type values.
16:08:31 <kludgy> vova: The 'a' in 'Maybe a -> Bool' is not the same as your 'a'. It's just a generic type variable that will work with any 'Maybe Xyz' type.
16:09:50 <vova> I know it. You might do not understand what i would like to get. I'm thinking how to do it in the best way
16:10:12 <kludgy> Ah apologies.
16:11:00 <ParahSailin_> vova: you're saying your actual type has a lot higher arity?
16:11:00 <vova> it's ok :)
16:12:22 <frerich_> Hrm, what do you call a function which determines whether a given request can be cached (and it optionally yields the reason why request cannot be cached)? ‘reasonWhyRequestCannotBeCached :: Request -> Maybe Reason’  is a bit lengthy :)
16:12:41 <joelteon> allowsCaching
16:12:43 <vova> My real type has a lot of type constructors. example data Some = Some {some:: Int, one:: Int ,.......  high :: Int}
16:13:08 <joelteon> wait, that's not a good name is it
16:13:17 <asfp``> How can I access the architecture name/identifier in a haskell program on ghc?
16:13:22 <frerich_> joelteon: A positive name has the downside that if you get ‘Nothing’ it means that caching is allowed :}
16:13:30 <frerich_> joelteon: Which seems a bit counter-intuitive.
16:13:32 <joelteon> deniesCaching
16:13:38 <ParahSailin_> vova: i bet the lens people have something for that
16:13:50 <enthropy> vova: add a deriving (Data)
16:14:21 <enthropy> @type null . listify (isNothing :: Maybe Int -> Bool)
16:14:22 <benzrf> vova: what do you need?
16:14:22 <lambdabot>     Not in scope: ‘listify’
16:14:22 <lambdabot>     Perhaps you meant one of these:
16:14:22 <lambdabot>       ‘listOf’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
16:14:32 <benzrf> :t listOf
16:14:33 <lambdabot> Gen a -> Gen [a]
16:15:21 <enthropy> @type null . Data.Generics.listify (isNothing :: Maybe Int -> Bool)
16:15:22 <lambdabot> Data a => a -> Bool
16:15:50 <triliyn> frerich_: if the reason is optional, maybe allowsCaching :: Request -> Either Reason Bool?
16:15:52 <benzrf> :t Data.Generics.listify
16:15:53 <lambdabot> (Typeable r, Data a) => (r -> Bool) -> a -> [r]
16:16:08 <frerich_> triliyn: I considered that, but I don’t like that you can have ‘Right False’
16:16:14 <benzrf> > Data.Generics.listify (==0) "foo"
16:16:15 <lambdabot>  Not in scope: ‘Data.Generics.listify’
16:16:20 <benzrf> pfft
16:16:28 <frerich_> triliyn: The ‘reason’ is optional in that if there’s no reason why the request cannot be cached then it can be cache
16:16:29 <frerich_> d.
16:16:30 <benzrf> what role does a play there
16:16:36 <triliyn> ah
16:16:36 <benzrf> :t Data.Generics.listify (==0) "foo"
16:16:37 <lambdabot> (Typeable r, Num r, Eq r) => [r]
16:16:52 <triliyn> Either Reason () is also kind of ugly I guess
16:17:39 <triliyn> You could define type and pattern synonyms for Either Reason () but that's a lot of extensions, which could conceivably be something you want to avoid
16:18:03 <triliyn> (actually I guess type synonyms are available without extensions)
16:18:55 <ReinH> What's the difference between Either a () and a Maybe a other than the lack of type class instances?
16:19:27 <benzrf> bbl
16:19:38 <enthropy> vova: I think to apply a query that is polymorphic like (Maybe a -> Bool) you probably need syb-with-class instead of syb
16:19:42 <benzrf> nothing, they're isomorphic
16:19:49 <benzrf> oh wait
16:19:52 <benzrf> functor instance differs
16:19:57 <benzrf> > fmap (+1) (Just 5)
16:19:59 <lambdabot>  Just 6
16:20:00 <benzrf> > fmap (+1) (Left 5)
16:20:01 <lambdabot>  Left 5
16:20:13 <benzrf> Either () a ~= Maybe a
16:20:26 <benzrf> bbl
16:20:33 <enthropy> ReinH: how do you write "Right undefined"?
16:21:44 <ReinH> enthropy: up to bottoms :p
16:24:05 <Baldwin123> Is there any de facto haskell equivalent for http://theburningmonk.com/2011/09/fsharp-pipe-forward-and-pipe-backward/ ?
16:24:43 <Zekka> Baldwin123: No, but & from Lens is fairly common (that is, for |>)
16:25:06 <Cale> Baldwin123: ($)
16:25:08 <Zekka> (<|) is ($)
16:25:24 <Zekka> Let's see, I think >> is >>> in Arrow, << is <<<, but more often .
16:25:27 <Baldwin123> Ah. right. I should clarify I was looking for |>, forward pipe.
16:26:02 <Zekka> er, wait, my mistake. >>> is in Category, same with <<<
16:26:51 <Cale> There's (.) as well
16:26:53 <Cale> :t (.)
16:26:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:27:03 <Zekka> Cale: Yeah, like I mentioned
16:27:06 <Baldwin123> (.) is >> in F#.
16:27:10 <Zekka> although I was lazy about parens so I might have been hard to parse
16:27:24 <Zekka> Baldwin123: Really? Pretty sure that's flip (>>)
16:27:41 <Zekka> or rather (<<)
16:27:54 <Baldwin123> (<|)
16:27:55 <Baldwin123> : (('a -> 'b) -> 'a -> 'b)
16:28:02 <Cale> For the most part, try to use (.) with perhaps one ($) somewhere near the end of the chain
16:28:05 <Zekka> That's ($), yes.
16:28:33 <Zekka> Haskell's very preferential towards (.) and ($) because they make chains of applications still look like chains of applications
16:28:56 <Zekka> compare f . g . h $ x to f (g (h x)) and then compare (h >> g >> f) x
16:29:03 <Baldwin123> Gah, sorry, wrong paste. Zekka.  >> has the same sig as (.)
16:29:14 <Baldwin123> but yeah, I see your point.
16:29:15 <Zekka> Baldwin123: Are you sure?
16:29:21 <Zekka> It seems to me it has the same sig as (flip (.))
16:29:34 <Baldwin123> (>>): ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
16:29:39 <Zekka> :t (.)
16:29:40 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:29:53 <Baldwin123> Ah, it's the ordering.
16:30:10 <Zekka> And like I said, the reason Haskellers like that is because it keeps the order the same as if you applied them the normal way
16:30:37 <Zekka> (don't worry, it's not hard to read when you get used to it)
16:30:53 <Baldwin123> There's also (<<), which might preserve the order, Zekka.
16:31:28 <Baldwin123> (<<): ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
16:31:33 <Zekka> Baldwin123: I'm pretty sure it does
16:31:40 <Zekka> pretty sure that one actually is the same operation
16:32:10 <Zekka> Now, of course, I lie and cheat because Haskell actually moderately favors the ordering in (>>) in a few cases
16:32:14 <ReinH> Do you want (<*) ?
16:32:29 <Baldwin123> :t (<*)
16:32:30 <lambdabot> Applicative f => f a -> f b -> f a
16:32:45 <Zekka> Both (=<<) and (>>=) are defined (which are basically variants of ($) for Monads), but (>>=) is the one in the typeclass
16:33:11 <Zekka> even though (>>=) doesn't preserve order the way I'm describing like (=<<) does
16:33:32 <Cale> (=<<) actually works better in conjunction with do-notation, ironically
16:33:53 <Zekka> Well, (=<<) is easier to read imho because it looks like (<$>) and ($)
16:34:06 <Cale> yeah
16:34:15 <Cale> Data is flowing in the correct direction :)
16:34:26 <Cale> x <- readFile =<< getLine
16:35:21 <Baldwin123> Thanks for the answers, chaps.
16:35:39 <AfC> What's the base version that corresponds to GHC 7.8.3?
16:36:31 <AfC> [is that even a thing?]
16:36:36 <ReinH> I'm convinced (>>=) wouldn't be used if it weren't for do notation ;)
16:36:51 <ReinH> Or at least far less than (=<<)
16:36:54 <Cale> I have 7.8.2 and base 4.7.0.0, and apparently 4.7.0.1 exists, so it's probably that
16:36:57 <Zekka> Yeah. Baldwin123 -- if you want to know why (>>=) is a thing, it's because it simplifies a rewriting rule for do-notation
16:36:59 <pjdelport> =<< ++
16:37:26 <Zekka> where do-notation is a special notation for code using monads to handle composition
16:37:34 <Zekka> a monad*
16:37:39 <Baldwin123> Somewhat humorously, I was actually looking for a more generally recognized form of |> for use in a logo.
16:37:46 <Cale> Well, (>>=) has the advantage (without do-notation), that usually its *second* argument is the long one
16:38:04 <Baldwin123> I'm not really a Haskeller, but I figured you chaps would be the ones to ask - you've got some of the best operators and syntax around.
16:38:39 <Zekka> Baldwin123: Yeah, unfortunately I cna't think of a super common one in Hsakell
16:38:45 <ReinH> Baldwin123: that's very gracious and I agree.
16:39:11 <Zekka> If there's not some specific meaning you're trying to convey you could explore the Applicative and Monad operators
16:39:31 <Zekka> (>>=) and (=<<) are pretty distinctive/recognizable
16:39:42 <Zekka> (*>) and (<*) don't mean the same thing at all but visually resemble (|>)
16:40:03 <Baldwin123> The meaning is pretty important
16:40:12 <Baldwin123> But thanks for the suggestions either way.
16:40:15 <Zekka> What kind of meaning are you trying to get across?
16:40:21 <Baldwin123> Looks like we might get away with function composition, actually.
16:40:32 <Zekka> or is it literally "we want something that expresses (|>)"?
16:40:55 <frerich__> “Looks like we might get away with function composition, actually.” sounds like it’s applicable to a helluva lot of problems in software engineering.
16:41:12 <Baldwin123> Tell me about it, frerich__. It's even working for graphic design.
16:41:23 <Zekka> (which might be the case if your logo is, I don't know, something like: Order >> Pack >> Ship, where you're describing something that's notionally one of application or composition)
16:42:44 <Hodapp> oh man, the number of times at my last job I had to deal with languages that don't like things like function composition.
16:43:03 <Hodapp> Let's just make a class for everything. Yeah, that should work.
16:43:18 <Zekka> I kind of see why it happens if you start with things that don't look very composable
16:43:25 <Zekka> i.e. Java + Java methods
16:43:58 <ruuns> hodapp: e.g. which languages? scala? :]
16:44:03 <Zekka> like, you can't really call anyone stupid for not thinking function composition was a good idea when you're dealing exclusively with possibly-overloaded functions from tuples to values
16:44:05 <Hodapp> ruuns: Java, C++.
16:44:20 <Zekka> It just comes from starting from a bad place
16:44:48 <Hodapp> Zekka: I call them stupid when they're reinventing function composition and not even knowing it, and they call themselves experts.
16:45:13 <Zekka> Hodapp: A lot of Java design patterns are reinventing very old things very badly
16:45:23 <Hodapp> Zekka: They learned that from the C++ folks, I think.
16:45:47 <ruuns> the famous book about patterns is exactly written c++ :3
16:46:08 <Hodapp> ruuns: Ah, the famous book with the subtitle, "A catalogue of reasons why your language is insufficient"?
16:46:08 <Zekka> http://en.wikipedia.org/wiki/Visitor_pattern <- hi what's a fold
16:46:17 <ruuns> though i don't know what kind of things the people from older languages like smalltalk came up in the past
16:46:34 <Zekka> Hodapp: I shouldn't ignore the C++ folks: I'm in a Java job now is most of the reason I gripe about Java specifically
16:46:37 <Exio> functional programming makes thinking about a problem way easier, because it is just a bunch of simple things combined together compared to all the "things" that the programmers need to do
16:47:10 <Hodapp> Exio: I'd be very interested to see solid evidence on any programming paradigm being better/worse, but sadly I think there's little beyond anecdotes now.
16:47:35 <Exio> Hodapp, if you can see design patterns easy to get, tell me
16:47:45 <Exio> they add a lot of boilerplate around 'simple' things
16:47:47 <Zekka> I don't think you can really prove a paradigm to be better or worse: you can argue it but I don't think you can prove it
16:48:08 <Hodapp> Zekka: There are empirical metrics you can use, however, very little testing has been done.
16:48:11 <Zekka> Like, you can't prove it to the standard you can prove that a sorting function has x worst case
16:48:22 <Hodapp> Zekka: One fellow who has attempted this is Les Hatton, and I also found... hold on while I dig up this link
16:48:23 <Cale> Hodapp: There's like, that one actual study done years ago which was quite favourable for FP, but not terribly meaningful statistically.
16:48:24 <pjdelport> Hodapp: If you take it as a given that the ultimate goals of good programming are all about modularity and composition, then it's hard to think of a better exemplar of modularity and composition than the FP paradigm.
16:48:24 <Exio> of course you can't
16:48:37 <pjdelport> "modularity and composition" is practically the definition of it.
16:48:40 <Zekka> but you can make arguments like "the clever thing your language does is actually a very simple case of a much cleverer thing"
16:49:10 <Hodapp> pjdelport: But, definitions like that are amenable to the same sort of handwaving that makes so many people treat OOP like the sacred paradigm, because objects.
16:49:20 <ruuns> hodapp: yep, and after that comes template-abused programming and boost :3
16:49:24 <Zekka> or "if you're so concerned about concern x then how come you haven't fixed problems yzq when we have"
16:49:26 <Cale> http://haskell.cs.yale.edu/wp-content/uploads/2011/03/HaskellVsAda-NSWC.pdf
16:49:35 <Hodapp> here we go. http://lambda-the-ultimate.org/node/4994
16:49:39 <Hodapp> Workshop on Evaluation and Usability of Programming Languages and Tools (PLATEAU)
16:49:44 <Zekka> Really I just tell my friends "That happens to be very easy to do in Haskell!" and hope they get the drift
16:50:50 <Hodapp> ruuns: Languages like Smalltalk and Self seemed to reserve objects and messaging for the bigger, mutable, more independent parts of a system, and not insist upon it for every tiny little detail and every tiny little data type.
16:51:23 <Hodapp> ruuns: Alan Kay at one point said (my bad paraphrasing) that he'd envisioned that objects were large and self-contained enough that they might have URLs.
16:51:47 <Zekka> Hodapp: What did he think about the smaller units of the problems objects could solve?
16:52:56 <Zekka> I feel like that's an interesting viewpoint because I'd argue that that's basically what State accomplishes
16:53:25 <Zekka> any mutable resource is uniquely identified by the composition of a certain chain of mutator functions
16:53:53 <Zekka> (or getter functions if you haven't turned getters and setters into the same kind of thing using i.e. lens)
16:54:04 <Hodapp> ruuns: The famous paper on Self ("Programming as experience") was also big on 'structural reification' which I remember being a principle that you didn't just use an object for any old thing, you used it for something that the user could actually see an interact with - something that was an actual *object*, in maintaining the illusion that the computer put forth
16:54:15 <Hodapp> s/see an/see and/
16:55:41 <ruuns> hodapp: absolutely true. ... best example all classes with get/setters without doing anything with that.
16:56:21 <Exio> isn't somehow the "point where FP shines" where you have a 'lot' of small functions that are easy to manage and easy to "compose together"?
16:56:42 <Zekka> Hodapp: I'd think this was a much ccooler philosophy, mind, if it told me very much about how to break up problems
16:56:51 <Hodapp> Zekka: I may be paraphrasing it badly.
16:57:12 <Zekka> if I'm implementing SHA, do all the objects involvd in generating a hash value need to be part of the UI?
16:57:19 <Zekka> That's obviously not what Kay means of course
16:57:29 <Zekka> because that would be ridiculous and really transparently so
16:57:36 <Hodapp> Zekka: I'd recommend grabbing the paper, "Programming as an Experience: The Inspiration for Self" from Randall Smith & David Ungar, and giving it a read.
16:57:36 <ruuns> hodapp: i guess many things would be there much easier if they could use function like data and are reusable. in Boost many things got easier if they simulate a function through simple objects ....
16:57:55 <ruuns> with the functional call operator
16:58:16 <Zekka> Hodapp: I'm a little busy right now (probably shouldn't even be IRCing!) but I'll keep it open in a tab
16:58:36 <ruuns> would be interesting to see how MVC-Architecture is modelled in a functional way where callbacks are just simple functions
16:58:36 <Zekka> because from what I hear Self was pretty cool but I don't kno wthat much about it
16:59:38 <Zekka> ruuns: I toyed with Angular earlier and it gave me the feeling that we need something more powerful to map communications between UI and model than simple functions
16:59:51 <Hodapp> Zekka: It's certainly from a different culture than things like Haskell, but I feel like it brought a great many innovations out of that context.
17:00:04 <Zekka> namely we need to deal with mappings where if something changes in the UI something else changes in the backend, but also vice versa -- callbacks are one-directional
17:00:20 <Zekka> I have a feeling there's a more general structure of which functions are a specific case that means that requirement though
17:00:41 <randen> Afc: GHC 7.8.3 uses base-4.7.0.1
17:02:24 <Hodapp> But, that's the form of OOP that I am more okay with. The form that says you should use a black-box RPC abstraction for almost every last bit of data in your system, and an obsession with an object's pedigree in some hierarchy, is the one I cannot stand.
17:03:05 <Zekka> Hodapp: How do you feel about "weird" typeclasses, like i.e. Profunctor?
17:03:37 <Zekka> Because I think Haskell uses very abstract objects to generalize to good effect: I think it's more than the objects in languages like Java are really inflexible and unpleasant to work with compared to the ones in Haskell
17:05:27 <Hodapp> Zekka: I don't know enough about them to say.
17:06:03 <ruuns> Zekka: i always thought MVC was designed for independance between UI and the model. It would be very bad if a change in UI would correspond to an additional change in model. But don't know exactly how it's in angular implemented :]
17:07:00 <ski> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
17:07:13 <ski> Hodapp,Zekka : ^ might be interesting, re OOP
17:07:32 <ruuns> In ruby they have replaced many objects through closures, which sometimes to lead to nicer solutions (visually on the code)
17:07:46 <Hodapp> Zekka: but I do recall a paper, "On data abstraction, revisited" (I think) which points out that objects as in OOP, and the abstract objects you talk about, end up in a very opposed state - because the latter is very amenable to all sorts of static analysis, and the former purposely delays so much stuff to runtime
17:07:57 <ski> Hodapp : hehee :)
17:09:23 <ski> the above paper compares and contrasts object-orientation with abstract data types
17:09:34 <Hodapp> yes, abstract data type is the term they used
17:10:32 <Hodapp> ruuns: I lost track of how many times at that last job they would make up a dozen classes whose sole purpose was to be a closure, to partially apply a function, or both.
17:10:33 <enthropy> is there some sensible reason for haddock to pretty print using -XExistentialQuantification syntax here http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html#t:SomeNat
17:11:08 <ski> the essence of the paper is more or less "ADTs are existentials, objects are closures"
17:11:23 <Hodapp> it's been awhile since I've read it
17:11:39 <ruuns> Hadapp: hehe, reinvented functional stuff
17:18:27 <ruuns> Does there actually exists a good book about functional designs of computer programs?
17:19:57 <ruuns> which is some kind equivalent like design patterns for OOP folk in the past
17:20:39 <ski> i'm not aware of one
17:21:08 <mwhit> ruuns: Not really, it something I've looked for.
17:21:35 <mwhit> and something i think is missing from the ecosystem
17:21:45 <mwhit> I've read a lot about haskell, and worked on a lot of toy programs
17:21:51 <ReinH> ruuns: Algebra of Programming and Pearls of Functional Algorithm Design, both by Richard Bird
17:21:58 <ski> there is a book, "Pearls of Functional Algorithm Design", by Richard Bird -- not quite the same thing, though
17:22:19 <mwhit> but consistently when I try and start a "real" application, I find that while I have a good grasp of what I *can* do, I have much less of a grasp how how to select from those what I *should* do
17:22:27 <ReinH> one subject to look into is program derivation
17:22:34 <mwhit> i.e. knowing in advance whether an abstraction is just introducing unneeded complexity, stuff like that
17:22:53 <mwhit> cool suggestions, I'll look into those
17:23:04 <ReinH> mwhit: conal's denotational design stuff might be of interest
17:23:08 <[swift]> ski: ReinH: i've been considering buying Pearls of Functional Algorithm Design for a while. worth buying?
17:23:10 <ReinH> to both of you on fact
17:23:19 <ReinH> [swift]: absolutely
17:23:25 <ski> [swift] : it's certainly interesting
17:23:51 <ski> and the Algebra book as well
17:23:54 <[swift]> nice. i'll have to pick it up
17:24:03 <mwhit> ReinH: thanks, I'll have a look
17:24:06 <[swift]> i had never heard of the Algebra book. the title sounds interesting, though
17:24:07 * ski has only checked it out from uni library
17:24:16 <ReinH> It's very interest
17:24:23 <ReinH> ing
17:24:35 <ski> the Algebra book is earlier, and has more material
17:25:04 <ski> "Algebra of Programming" is actually coauthored by Richard Bird and Oege de Moor
17:25:37 <ruuns> nice, currently bookmarked these titles.
17:25:38 <[swift]> heh, wow, Algebra of Programming is a lot more expensive =)
17:25:56 <[swift]> maybe that's one to get from the library
17:26:14 <Hodapp> hah
17:31:17 <platz> mwhit: some info on bird's book:  http://www.atamo.com/blog/how-to-read-pearls-by-richard-bird-1/
17:34:09 <Hodapp> I've been meaning to pick that book up.
17:34:33 <genericpersona> i have a copy of it
17:34:42 <genericpersona> seems pretty great
17:39:10 <phaazon> yeah!
17:39:14 <phaazon> finally made it!
17:39:15 <phaazon> http://phaazon.net/browse
17:39:20 <phaazon> my gallery
17:39:23 <phaazon> :)
17:39:29 <phaazon> happstack is so lovely :)
17:39:38 <ruuns> congratz :3
17:39:50 <Hafydd> Why do your links jump to the right when hovered?
17:40:23 <ruuns> highlighting the current selection propably ^^
17:40:32 <phaazon> yep
17:40:39 <Hafydd> Obviously, yes, but it looks awful and makes it hard to read.
17:40:54 <phaazon> at first font-siwe was made bigger
17:41:01 <phaazon> but it destroyed the whole layout :D
17:41:05 <phaazon> you think it’s wrong?
17:41:18 <phaazon> maybe I could reduce the gap yeah
17:41:26 <Hafydd> Yes. I wouldn't move the text at all.
17:41:33 <Hafydd> Just make it bold and change the colour, or something.
17:42:19 <phaazon> the colour is already changing
17:50:43 <manek> Hello! Is there any way in haskell to extend a module? I mean - there is a module Foo.Bar - I want to just add another method there without changing source code of the library, which provides the module.
17:51:20 <hpc> can you describe what you want at a higher level?
17:51:28 <dwcook> manek, import the module, re-export it along with the extra things.
17:52:00 <manek> dwcook: I can do that, but then the final user needs to import my module instead - I would love to keep the original module name
17:52:30 <dwcook> manek, are you sure this problem isn't overconstrained?
17:53:02 <dwcook> Try answering hpc's question
17:54:12 <manek> hpc: Ah, I didnt noticed you are asking me, I'm sorry. There is a module "Control.Monad.Morph" - I would love to add there a custom class and I would like not to change the name, because it is just nice
17:54:31 <AfC> randen: thanks
17:54:39 <dolio> No, you can't do it.
17:54:49 <dolio> And that's a good thing.
17:54:50 <Luonnon> Wouldn't that violate the open/closed principle?
17:55:42 <mwhit> you can't just surreptitiously replace a module from a different library; that would be super confusing and cause all kinds of problems
17:56:55 <[swift]> sounds like manek was envisioning something like extension methods in C#
17:57:45 <manek> Oh, ok :) I was just thinking that I can "extend", like [swift] tells the module somehow :) Thanks :)
17:58:10 * ski idly wonders whether manek has something like mixins in mind
17:58:58 <manek> ski: Hmm, something like that but for modules
17:59:55 <[swift]> in Haskell it seems like this is less necessary since you are always dealing with free functions
18:00:45 <Hodapp> open/closed = open for extension, closed for modification?
18:01:36 <ski> manek : like "Mixin Modules" by Dominic Duggan,Constantinos Sourelis in 1996 at <http://www.cs.cmu.edu/~rwh/courses/modules/papers/duggan-sourelis96/paper.pdf> ?
18:04:28 <manek> ski: for a fast look at the document - (I do not know ML) they are defining mixins for creating something like datatypes. But there are some paragraphs talking about modules. If modules there are the same as in Haskell - it oculd be what I'm talking about. I'm reading it further right now - I understand - there is no support for it in Haskell ?
18:05:04 <ski> manek : ML modules are more powerful than Haskell modules
18:05:59 <ski> if you haven't encountered ML modules yet, i recommend you look into them (as in SML and OCaml. the module system of F# is dumbed down, don't look at that)
18:06:53 <pyon> ski: The module system of F# is basically .NET assemblies, right? (Or does it have anything to offer beyond what C# and other .NET languages do?)
18:06:55 <zwer> from what I've heard they fullfil some of the roles of typeclasses in haskell. if so, can they do things haskell modules + typeclasses can't?
18:07:29 <ski> pyon : i don't know, but i suspect it's the former only
18:07:55 <ski> zwer : module functors
18:10:36 <pyon> zwer: (ML) modules are more powerful than type classes because modules are structurally typed. You do not need to anticipate what signatures you might want to match a module against.
18:11:25 <pyon> zwer: Whereas, with type classes, you have the "slight" problem that, if you want to add a base class to an existing type class, basically you need to rewrite all instances of the existing type class.
18:14:22 <c_wraith> conversely, the ML module system is no replacement for type classes. While they can each do similar things, the *way* in which they do them is really important. Type classes enable lightweight syntax that makes them trivial to use for things as small as Eq.  There's a reason ML doesn't use modules for Eq.
18:14:33 <manek> ski: Thank you! I definitely look at them. By the way - are there any plans to improve haskell modules? (I do  not know what I'm talking about right now, but If ML's are better, there is place to improve them)
18:14:55 <pjdelport> manek: http://plv.mpi-sws.org/backpack/
18:17:55 <zq> how to use imported type synonym as constructor
18:18:18 <mwhit> zq: type synonyms have no constructors
18:18:24 <mwhit> they're just synonyms
18:18:28 <trap_exit> they're just 'naked' aliases
18:18:36 <trap_exit> type Foo = Int
18:18:49 <trap_exit> it basically means "sed s/Foo/Int/" then compile
18:18:53 <trap_exit> afaik
18:18:54 <zq> mwhit: (how to use (type synonym as constructor))?
18:18:56 <trap_exit> correct me if I'm wrong
18:19:09 <zq> mwhit: (how to use ((imported type synonym) as constructor))*
18:19:18 <zq> it works fine if it isn't imported
18:19:36 <manek> pjdelport: Oh interesting! Thank you! I see there is some work in progress regarding backpck in haskell! that is very nice! :)
18:19:42 <trap_exit> zq: are you sure you don't wnat #lisp ?
18:20:15 <zq> trap_exit: (how to use $ (imported type synonym) as constructor)? better? :p
18:20:39 <mwhit> zq: I'm not really sure what you mean by using it as a constructor. If you have type Foo = Bar, you don't construct a Foo from a Bar, it's just another name for it
18:20:39 <trap_exit> zq: welcome to #haskell :-)
18:20:43 <mwhit> do you mean newtype?
18:20:45 <levi> manek: There are also vague plans in the ML camp for implementing something like type classes, though Backpack is being actively worked on so I suspect that'll be ready to use much sooner.
18:21:04 <trap_exit> zq: I think mwhit may be asking "can you show us a minimal example that does not compile" ?
18:21:11 <mwhit> ^^^
18:21:46 <zq> mwhit: okay, real world example. Data.Aeson defines type Object = Data.HashMap.Strict.HashMap k Value
18:22:21 <zq> import Data.Aeson, and you'd be good to go to pattern match on Object, eg f (Object obj) = ...
18:22:29 <trap_exit> zq: generally, when I ask questions in #haskell, I like to create  Main.hs, s.t. "ghc Main.hs" gives a compile error, then gist.github.com Main.hs
18:22:30 <benzrf> zq: uh
18:22:34 <mwhit> um
18:22:35 <zq> otoh import Data.Aeson (Object) don't work
18:22:35 <benzrf> zq: that's a data constructor
18:22:35 <geekosaur> er?
18:22:37 <mwhit> no you wouldn't
18:22:38 <trap_exit> this way, it gives people an example they can copy/paste -- and gets me responses faster
18:22:54 <zq> i wouldn't what
18:23:01 <mwhit> zq: when you pattern match on object there
18:23:11 <benzrf> zq: Object is a data constructor, not a type
18:23:11 <zq> ugh
18:23:11 <mwhit> zq: you are using the Object constructor of the datatype Value
18:23:14 <benzrf> at least, in your example
18:23:21 <mwhit> zq: totally separate from the Object type synonym
18:23:32 <zq> okay nvm, imported the wrong thing
18:23:39 <zq> gg, ty
18:24:13 <tac_> Can anyone explain why an SSL call would fail if I'm not compiling with -threaded
18:24:14 <tac_> ?
18:24:16 <tac_> just curious
18:24:34 <zq> for posterity, the confusion arose because Aeson defines both the type syn Object earlier and also a ParseValue ctor named Object
18:24:58 <zq> http://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson-Types.html
18:25:23 <trap_exit> besides Haste.App; is there any good eaxmple of writing client+server in Haskell, but using Client MOnad to denote it's client side, and Server monad to denote it's server side?
18:25:37 <manek> levi: I have to learn ML. By the way - is ML used anywhere right now? I'm talking about any - non academic usage
18:26:33 <tac_> also, is there a quick way to pad a Text on either side with spaces?
18:27:41 <tac_> manek: ML isn't really used afaik
18:27:45 <tac_> Ocaml is though
18:27:50 <tac_> (if ML = SML)
18:28:03 <Hodapp> tac_: what sort of stuff?
18:28:19 <tac_> Also, ML is easy peasy if you know Haskell. And Haskell is easy-ish if you know ML.
18:28:49 <manek> tac_: I really want to learn ML now :D
18:28:59 <ski> (by "ML" i mean the whole family, including SML,OCaml,F#,Alice ML,MetaOCaml,..)
18:29:16 <zq> f# is ml?
18:29:29 <tac_> manek: SML is kinda neat because it has a very terse formal spec. You could easily implement your own if you desired.
18:29:36 <tac_> F# is an ML
18:29:39 <tac_> Ocaml is an ML
18:29:41 <tac_> SML is an ML
18:29:49 <levi> manek: I don't know of any industrial use of SML. OCaml (and F#, which started as a "port" of OCaml) are used in industry.
18:29:53 <ski> zq : it's more or less a watered-down version of O'Caml for the .NET, with some things added
18:30:29 <mwhit> it's O'Caml to me from now on
18:30:37 <ruuns> Isn't ML used in some aircraft companies for programm verification?
18:31:15 <manek> ski: I do not think I would ever like F# (because of its .NET origins), but all the informations are very interesting- thank you very much! :)
18:33:32 <levi> ruuns: ML stands for 'meta language'; it was the tactic language for a proof assistant framework. So it's got a history of being used for verification tasks.
18:34:04 <levi> OCaml's primary function is to serve as the implementation language of Coq, too.
18:37:58 <tac_> ugg what does this mean?
18:38:00 <tac_>     Couldn't match expected type `text-0.11.3.1:Data.Text.Lazy.Builder.Internal.Builder'
18:38:00 <tac_>                 with actual type `Text'
18:38:24 <benzrf> tac_: means it couldnt match those 2 types
18:38:43 <tac_> ski: linguistically yes. but MS backing means you get a really nice IDE, which counts for a lot, I think
18:38:46 <tac_> Also, type providers are cool
18:39:02 <tac_> benzrf: obviously :[
18:39:21 <ski> tac_ : yes, some of the added stuff is interesting
18:39:23 <tac_> I'm calling left from Data.Text.Format, and it seems to be giving me some internal type rather than the advertised "Text" in the docs
18:39:39 <levi> tac_: You have incompatible types. Sometimes you'll have used a strict version of Text for one thing and a lazy version for another, and you get an error like that when you cross the streams.
18:40:02 <tac_> is that problem usually the fault of the library implementor?
18:40:17 <benzrf> levi: never cross the streams!
18:40:27 <tac_> and in those situations, what is the standard protocol for coercing to the type I need?
18:40:57 <levi> tac_: There are some strict-to-lazy and lazy-to-strict functions in Text; I can't remember the names off the top of my head.
18:42:06 <tac_> ack
18:42:12 <tac_> screw this. I'll just implement it myself :(
18:43:10 <tac_> > take 10 [1,2,3]
18:43:11 <lambdabot>  [1,2,3]
18:47:15 <levi> tac_: Lazy Text is just a steam of strict Text chunks; converting your Data.Text.Format chunks to lazy Text shouldn't be a big deal.
18:47:41 <tac_> It shouldn't be a deal at all, ideally
18:48:00 <tac_> either way, I need to do some work to get this done, and I've had issues with figuring out how to do those coercions in the past
18:48:13 <tac_> for a one-off function, it's not worth depending on an unreliable library
18:48:41 <levi> Just call 'fromStrict'
18:49:14 <cpa> guys, Data.Random drives me crazy. I'm trying to do a markov text generator but it generates sentences with words that are not always next to each other in the source text I use. Care to help? Code: http://lpaste.net/4147715261379641344 test.txt:http://lpaste.net/raw/4004174907431714816
18:50:00 <levi> tac_: Well, Text is not exactly an unreliable library, you just have to be aware that it's got two underlying implementations and various libraries will use one or the other depending on their use case.
18:50:08 <tac_> no, Text isn't
18:51:50 <levi> Data.Text.Format doesn't look particularly unreliable either.
18:52:20 <levi> This is just more or less the same issues as having multiple numeric types that you sometimes have to translate to a common type.
18:55:31 <tac_> errg.. how do you launch GHCI with cabal again?
18:55:35 <tac_> I thought there was a way to do it
18:55:43 <geekosaur> cabal repl?
18:56:18 <tac_> thanks
18:59:07 <gn0> hi all
19:02:24 <jle`> hi gn0
19:02:27 <jle`> nice article tac_
19:02:34 <tac_> article?
19:02:58 <jle`> oh wait that was tel
19:03:01 <jle`> sorry
19:03:04 <tac_> heh
19:03:05 <jle`> i still think you are an awesome person
19:03:07 <jle`> :)
19:03:31 <gn0> hi jle`
19:05:06 <tac_> :D
19:05:21 <tac_> I'll write an article so you can enjoy it just as much as you did this latest one, jle`
19:05:32 <jle`> :D
19:05:34 <gn0> tac_ what do you write about?
19:05:37 <jle`> more to read the better
19:05:43 <tac_> gn0: nothing yet.
19:05:49 <tac_> I have been meaning to set up a blog all summer
19:06:05 <tac_> I tried Yesod out and realized it wasn't quite what I wanted to spend my time on
19:06:16 <jle`> heh
19:07:07 <tac_> Too much template magic for my taste
19:07:07 <fuzzyhorns> ive struck out in the yesod channel, can anyone help me figure out a yesod test? http://stackoverflow.com/questions/24901117/getting-more-than-one-input-with-id-content-in-yesod-test-response
19:09:41 <gn0> tac_ I'll be happy to read stuff on my free time, so I can be a follower :)
19:11:00 <tac_> cabal repl is saving me so much time
19:11:08 <tac_> I don't know why I can never remember that command
19:11:56 <gn0> Oh, I knew I joined to ask something
19:13:12 <manek> By the way - I've got a crazy question - is it possible to convert Haskell to LLVM IR (using the LLVM backend) and then to JVM using LLJVM? :)
19:13:16 <gn0> here's my question.. as far as I know, Haskell doesn't have any for or while loops, so if you have to repeat you can do it with recursion. It's kind of a limitation when you work with big lists of data, specially if memory is a big constraint in your system. Is there any way to work that out?
19:14:12 <mzero> gn0: it isn't a limitation: Haskell compilers do tail call optimization -- it all ends up being a loop
19:14:47 <mzero> In fact, with "fusion" -- often sequence of looped steps that in other system would consume memory... can run in constant memory in Haskell
19:14:52 <ski> iteration is a special case of recursion
19:16:25 <fuzzyhorns> does anyone even use yesod, or yesod test? so far all the yesod folks i talk to dont do tests :/
19:16:26 <gn0> mzero, that brings me hope, thanks :)
19:16:30 <gn0> ski, I'll google that
19:16:52 <ski> gn0 : SICP goes into it
19:16:58 <ski> @where SICP
19:16:58 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
19:17:00 <mzero> so, for example....     main = interact $ unlines . map reverse . map (filter (not . isVowel)) . lines
19:17:09 <ski> the former two links
19:17:28 <gn0> thanks, ski, mzero
19:17:29 <mzero> this prints all input words, stripped fo vowels, and reversed.... and operats on as long an input as you care to give it.... in constant memory
19:18:06 <ski>   main = (interact . perLine) (reverse . filter (not . isVowel))
19:18:18 <gn0> mzero, in which kind of documentation you can get that info? compiler documentation or standard haskell manuals?
19:18:32 <mzero> standard haskell texts
19:18:41 <ski>   perLine = onLines . map
19:18:51 <ski>   onLines f = unlines . f lines
19:19:13 <mzero> not in the prelude, those
19:19:25 <gn0> oh, that's cool :D
19:19:37 <mzero> gn0: pretty much anyone with experience in other langauges comes up with the same question and worry
19:20:12 <ski> those are from conal's
19:20:13 <ski> @wiki Tangible Value#IO
19:20:13 <lambdabot> http://www.haskell.org/haskellwiki/Tangible_Value#IO
19:21:17 <benzrf> ski: do you mean onLines f = unlines . f . lines
19:21:28 <ski> benzrf : er, yes
19:22:00 <gn0> mzero I'm not that experienced but I like learning. It would just suck if that was a limitation
19:22:25 <levi> By the way, the fact that those run in constant space is due to lazy evaluation and guarded recursion, not just tail call optimization.
19:22:31 <benzrf> @let onLines f = unlines . f . lines; perLine = onLines . map
19:22:34 <lambdabot>  Defined.
19:22:38 <mzero> gn0: at this point, Haskell has proved itself production worthy in several domains....
19:22:48 <benzrf> > perLine reverse "hello world!\nthis is haskell!\nhaskell is pretty cool"
19:22:50 <lambdabot>  "!dlrow olleh\n!lleksah si siht\nlooc ytterp si lleksah\n"
19:23:03 <mzero> levi: true dat...
19:24:32 <gn0> mzero that's even better to know, I'm new to it but I find it really attractive
19:24:57 <mzero> welcome to the start of a long, fruitful adventure
19:25:20 * hackagebot tighttp 0.0.0.0 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.0 (YoshikuniJujo)
19:25:23 <gn0> levi, I'll get to it when I learn a bit more but thanks for the tip :)
19:25:30 <gn0> haha thanks
19:27:01 <xchen> Hi I have a question about <$>
19:27:15 <mwhit> shoot
19:27:27 <xchen> (*3) <$> (+)   what is the input of this thing?
19:27:54 <mwhit> :t (*3) <$> (+)
19:27:54 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
19:28:09 <xchen> OK then what should I write
19:28:19 <mwhit> it's using the functor instance of (->), which is probably not what you want there
19:28:27 <mwhit> since this requires a function that's an instance of Num
19:28:28 <xchen> ((*3) <$> (+))  3 4    doesn't work
19:28:36 <mwhit> which i don't think exists or is possible
19:28:54 <mwhit> is this something you read somewhere?
19:28:55 <haasn> mwhit: It's possible
19:29:08 <mwhit> well, maybe "possible" but still probably not what he wants
19:29:18 <haasn> I'm not sure what he wants
19:29:18 <xchen> No I just wonder  since (+) <$> (*3)  works
19:29:28 <haasn> xchen: What do you want?
19:29:35 <zq> is it possible to discover suitable version ranges of each cabal file dependency?
19:29:52 <xchen> I want to know what does (*3) <$> (+) means
19:30:06 <benzrf> xchen: it means fmap (*3) (+)
19:30:12 <benzrf> > fmap (*3) (+)
19:30:13 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:30:13 <lambdabot>    arising from a use of ‘M332778233411366137931514.show_M3327782334113661379...
19:30:13 <lambdabot>  The type variable ‘a0’ is ambiguous
19:30:13 <lambdabot>  Note: there are several potential instances:
19:30:13 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
19:30:21 <benzrf> we got a type error
19:30:29 <haasn> well, first of all we know that f <$> g is the same as f . g (for functions)
19:30:30 <xchen> then how do I feed this function
19:30:41 <haasn> so we're looking at (*3) . (+)
19:31:07 <haasn> Which per definition is \x -> (*3) ((+) x)
19:31:21 <haasn> = \x -> (\y -> x+y) * 3
19:31:36 <haasn> What this is equal to depends on how, or if we have a Num instance for functions
19:32:15 <haasn> There exists at least one sensible instance where fromInteger i = \_ -> fromInteger i and f * g = \x -> f x * g x
19:32:50 <xchen> If I want  (1+2) *3 then what should I write ?
19:33:31 <erisco> can <*> be pronouced "applicate" ?
19:33:40 <MP2E> I call it apply
19:33:46 <mwhit> i head "brackety-splat", i kinda like that one
19:33:52 <haasn> Given these definitions we have \x -> (*3) ((+) x) = \x -> (x+) * const 3 = \x y -> (x+) y * const 3 y = \x y -> (x+y)*3
19:34:06 <mwhit> and "brackety-cash" for <$>
19:34:06 <erisco> MP2E, I thought that might be confusing given "ap"
19:34:10 <haasn> > let f = (*3) <$> (+) in f 3 4
19:34:12 <lambdabot>  No instance for (GHC.Show.Show a0)
19:34:12 <lambdabot>    arising from a use of ‘M348754994830169347931576.show_M3487549948301693479...
19:34:12 <lambdabot>  The type variable ‘a0’ is ambiguous
19:34:12 <lambdabot>  Note: there are several potential instances:
19:34:12 <lambdabot>    instance [safe] GHC.Show.Show
19:34:18 <haasn> Oh, we don't have the instance in here it seems
19:35:14 <haasn> @let instance Num b => Num (a -> b) where fromInteger = const . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); (-) = liftA2 (-); negate = fmap negate; abs = fmap abs; signum = fmap signum
19:35:17 <lambdabot>  Defined.
19:35:22 <haasn> > let f = (*3) <$> (+) in f 1 2
19:35:23 <lambdabot>  9
19:35:25 <haasn> > (1+2)*3
19:35:26 <lambdabot>  9
19:35:59 <benzrf> > ((3 :: String -> Int) + (4 :: String -> Int)) "foo"
19:36:01 <lambdabot>  7
19:36:12 <mwhit> haasn: doesn't that Num assume the functions always return something with a Num instance? I don't understand how that works
19:37:05 <haasn> It doesn't just assume it, it requires it
19:37:07 <xchen> :hassn   it is the same as    let f = (*3) <$> (+) in f 1 2
19:37:32 <mwhit> haasn: oh I can't read. Thought this was just for ((->) a) in general
19:37:56 <xchen> GHCI says: No instance for  ......
19:38:18 <erisco> > pure 5 :: (Int,Int)
19:38:19 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:38:20 <lambdabot>    arising from a use of ‘Control.Applicative.pure’
19:38:47 <xchen> > let f = (*3) <$> (+) in f 1 2
19:38:48 <lambdabot>  9
19:39:00 <xchen> > (*3) <$> (+) 1 2
19:39:01 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
19:39:02 <lambdabot>    arising from a use of ‘M503270311922113290931735.show_M5032703119221132909...
19:39:02 <lambdabot>  The type variables ‘b0’, ‘f0’ are ambiguous
19:39:02 <lambdabot>  Note: there are several potential instances:
19:39:02 <lambdabot>    instance [safe] GHC.Show.Show a =>
19:39:13 <xchen> > ((*3) <$> (+)) 1 2
19:39:14 <lambdabot>  9
19:39:38 <xchen> My god,  My ghci doesn't work
19:41:40 <mwhit> xchen: no, you just don't have the Num instance that haasn just defined above
19:42:45 <haasn> > let f = 3*(+) in f 1 2
19:42:47 <lambdabot>  9
19:42:57 <benzrf> haasn: grose
19:44:21 <mwhit> > let f = 3+(+) in f 1 2
19:44:22 <lambdabot>  6
19:45:02 <Luke_> how do I pass a command line argument to the resulting binary in 'cabal test' or 'cabal bench'
19:47:18 <haasn> > let f = 2*sin + 5*cos in f pi
19:47:19 <lambdabot>  -5.0
19:59:39 <Athas> When defining a typeclass that has associated types (as per TypeFamilies), can I put class contraints on those associated types?
20:00:22 <rwbarton> yes
20:01:56 <Athas> How?
20:02:22 <rwbarton> just write the constraints you want as though they were superclasses of the class you are defining
20:02:32 <Athas> Oh, nice.
20:15:25 <educated_idiot> does "type Foo a =  a -> Bool" and "type Bar = Foo (String -> String)" in this case mean a function taking two arguments, or is Bar a function taking another function? I'd like to define it as a two argument taker, but it looks like that isn't possible
20:16:32 <jle`> educated_idiot: 'type' is more or less a type synonym in this case
20:16:37 <jle`> so you can expand out the synonyms
20:16:49 <jle`> so Bar would be equivalent to
20:16:56 <jle`> type Bar = Foo (String -> String)
20:17:13 <jle`> ==>  ((String -> String) -> Bool)
20:17:21 <educated_idiot> okay :(
20:17:25 <jle`> which is a function that takes a function and returns a Bool
20:17:53 <jle`> it depends on what you want, but why not type Bar = String -> Foo String ?
20:18:24 <jle`> which would be String -> (String -> Bool), which is String -> String -> Bool
20:18:34 <educated_idiot> jle`: correct, thanks
20:27:32 * ski idly wonders what educated_idiot is trying to do
20:31:46 <educated_idiot> ski: http://lpaste.net/108012
20:31:49 <educated_idiot> enjoy
20:37:32 <ski> educated_idiot : why not `runInvariants :: a -> [Inv a] -> Def Bool' or `runInvariants :: [Inv a] -> Inv a' ?
20:37:53 <tertl3-laptop> :t 21
20:37:53 <lambdabot> Num a => a
20:38:23 <tertl3-laptop> let a = 21
20:38:39 <tertl3-laptop> :t a
20:38:40 <lambdabot> Expr
20:38:43 <lispy> > let 1 + 1 = 3 in 1 + 1
20:38:44 <lambdabot>  3
20:38:50 <ski> @let twentyone = 21
20:38:52 <lambdabot>  Defined.
20:39:00 <tertl3-laptop> stahp
20:39:30 <tertl3-laptop> let b = a + 1
20:39:45 <ski> that doesn't affect lambdabot
20:39:55 <tertl3-laptop> why
20:40:10 <ski> because it doesn't start with `@' or `> '
20:40:19 <tertl3-laptop> @let b = a + 1 in b
20:40:19 <lambdabot>  Parse failed: Parse error: in
20:40:26 <tertl3-laptop> @let b = a + 1
20:40:27 <lambdabot>  Defined.
20:40:33 <ski> @type L.b
20:40:33 <lambdabot> Expr
20:40:34 <lispy> :t b
20:40:35 <lambdabot>     Ambiguous occurrence ‘b’
20:40:35 <lambdabot>     It could refer to either ‘L.b’,
20:40:35 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:159:1
20:40:37 <tertl3-laptop> :t b
20:40:38 <lambdabot>     Ambiguous occurrence ‘b’
20:40:38 <lambdabot>     It could refer to either ‘L.b’,
20:40:38 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:159:1
20:40:56 <ski> things you define for lambdabot gets defined in the module `L'
20:40:57 * lispy always forgets the L module
20:41:08 <tertl3-laptop> :l L
20:41:27 <ski> since lambdabot already knows of a different thing named `b' (as well as `a',`c',`d',...), it's not sure which you meant if you just say `b'
20:41:35 <tertl3-laptop> L.b
20:41:40 <ski> > L.b
20:41:41 <lambdabot>  a + 1
20:41:45 <tertl3-laptop> :t L.b
20:41:46 <lambdabot> Expr
20:41:59 <tertl3-laptop> L.b
20:42:05 <ski> that's using the `a :: Expr' that i mentioned lambdabot already knows
20:42:19 <educated_idiot> ski: your first one fixes it, the second I'm not sure about, it's still pretty chaotic
20:42:31 <ski> @let anotherB = twentyone + 1
20:42:32 <lambdabot>  Defined.
20:42:33 <tertl3-laptop> you broke the internet
20:42:41 <ski> > anotherB
20:42:42 <lambdabot>  22
20:42:44 <ski> @type anotherB
20:42:45 <lambdabot> Num a => a
20:42:57 <ski> @type (anotherB :: Integer)
20:42:58 <lambdabot> Integer
20:43:14 <ski> educated_idiot : in the second one, i just flipped the argument order
20:43:16 <tertl3-laptop> how is twntyone a number?
20:43:28 <ski> i defined it to be one ?
20:43:35 <ski> <ski> @let twentyone = 21
20:43:38 <ski> a bit up
20:43:42 <tertl3-laptop> oh
20:43:45 <tertl3-laptop> ok
20:44:17 <tertl3-laptop> @let ski = "noob"
20:44:18 <lambdabot>  Defined.
20:44:24 <tertl3-laptop> L.ski
20:44:36 <tertl3-laptop> :t ski
20:44:37 <lambdabot> [Char]
20:44:55 <tertl3-laptop> @printf ski
20:44:56 <lambdabot> ski
20:45:08 <tertl3-laptop> derp
20:45:28 * hackagebot hailgun 0.1.0.1 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.1.0.1 (RobertMassaioli)
20:46:01 <tertl3-laptop> what is the best haskell to javascript compilator?
20:46:29 <tertl3-laptop> ski
20:46:41 <tertl3-laptop> @L.ski
20:46:41 <lambdabot> Unknown command, try @list
20:46:44 <lispy> tertl3-laptop: my money is on ghcjs but none of them are ready for casual use.
20:46:57 <tertl3-laptop> ok
20:47:09 <tertl3-laptop> what about typescript?
20:47:17 <tertl3-laptop> is that one good?
20:47:57 <ski> tertl3-laptop :)
20:48:19 <tertl3-laptop> i was only kidding ski i hope u not mad
20:48:28 <ski> why would i be mad ?
20:48:36 <lispy> tertl3-laptop: your question about typescript reminded me of this: https://medium.com/cool-code-pal/the-hassle-of-haskell-a74862541dfb
20:48:42 <tertl3-laptop> idk
20:49:08 <tertl3-laptop> im looking at funscript
20:49:31 <tertl3-laptop> but i think it also suffers from those problems
20:50:52 <nisstyre> lispy: that's a parody right?
20:51:05 <lispy> nisstyre: I sure hope so
20:51:16 <tertl3-laptop> i saw that post,
20:51:30 <ski> educated_idiot : fixes what, btw ?
20:51:51 <tertl3-laptop> she is upset about that bug
20:52:02 <tertl3-laptop> its a dealbreaker
20:52:47 <educated_idiot> ski: you read my intent there, I wanted a Def Bool at the end
20:54:10 <ski> educated_idiot : i just thought it looked silly to not use the latter `a' argument
20:55:26 <educated_idiot> ski: it is, thanks
20:56:49 <ski> educated_idiot : instead of `Def Bool', perhaps it would be better to use `Maybe String' ?
20:58:33 <educated_idiot> ski: ya, I've toyed with that idea, I'm using bools out of practicality (Property conversion)
21:00:23 <benzrf> tertl3-laptop: its a parody stupid
21:00:41 <tertl3-laptop> oh
21:00:46 <tertl3-laptop> not funny
21:00:56 <tertl3-laptop> what was origianl post?
21:00:59 <benzrf> soz for stupid
21:01:05 <benzrf> tertl3-laptop: well, satire maybe
21:01:09 <educated_idiot> ski: I also got tangled up in trying to fit Maybe String into a monad like strategy for what I want, distinct invariants, easy documenting for failure
21:01:23 <tertl3-laptop> so this isnt a bug?
21:01:30 <benzrf> tertl3-laptop: you might consider it a bug
21:01:36 <benzrf> it parses ..- as an operator
21:01:40 <benzrf> like
21:01:42 <benzrf> [1+2]
21:01:43 <benzrf> or
21:01:45 <benzrf> [1..-2]
21:01:57 <tertl3-laptop> its a syntactical thing i know
21:01:58 <benzrf> tertl3-laptop: theres kind of a genre ive seen on medium of satirical poorly-written misinformed progamming articles
21:02:14 <tertl3-laptop> what is she satiring?
21:02:27 <benzrf> i dunno if its satiring anything in particular
21:02:43 <mwhit> poorly-written misinformed programming articles, i suspect
21:02:47 <benzrf> another example of this kind of thing https://medium.com/friendship-dot-js/the-prospects-of-css-on-the-backend-43dbc25cbd12
21:02:57 <tertl3-laptop> its making fun of people who find little things they dont like?
21:03:00 <dmj`> markov_twain: clever
21:03:00 <benzrf> ^one of my faves
21:04:17 <WraithM> loool That's excellent
21:04:25 <mwhit> i thought html5 + css3 is turing complete, though
21:04:41 <benzrf> WraithM: check out the other friendship.js stuff too
21:04:45 <benzrf> and jenn's other stuff ofc
21:04:56 <benzrf> https://medium.com/cool-code-pal/a-call-for-web-developers-to-deprecate-their-css-1f6430781393
21:05:43 <joelteon> I like the giant image that I have to scroll past to read the actual content
21:06:23 <mwhit> that's pretty much modern web design
21:06:43 <benzrf> joelteon: its medium
21:06:51 <joelteon> isn't that what i said
21:07:13 <benzrf> joelteon: do you really expect better than medium web design
21:07:15 <benzrf> ( ͡° ͜ʖ ͡°)
21:07:24 <joelteon> what are those characters?
21:07:49 <benzrf> https://s3.amazonaws.com/static.tumblr.com/2777e5e8be6760d6dfca26ff97792d13/nk2q1zv/Z5xmwh764/tumblr_static_how-to-draw-the-le-lenny-face-step-5_1_000000121417_4.jpeg
21:08:01 <joelteon> what does it mean?
21:08:05 <benzrf> i dont know anymore
21:08:12 <joelteon> why are you using it here?
21:08:46 <benzrf> i dunno, ive kinda started following up lame jokes with it
21:08:51 <ski> being weird is not reason enough ?
21:08:53 <benzrf> something about how it looks seems to work
21:10:11 <joelteon> fair enough
21:11:41 <zwer> benzrf it is not a parody. looking at her twitter she was annoyed by that behavior, and even more annoyed when someone called her "simple" when she was complaining about it.
21:12:55 <zwer> "he *literally* called me "simple" and gave no explanation so you can thank that asshole for making me write a css perverts post about it :D"
21:13:06 <zwer> so yeah, I think she believes she is ripping haskell a new one with that post. :)
21:13:19 <jennmoneydollars> no I don't actually
21:13:34 <jennmoneydollars> I have no problem with the language, I enjoy working with it
21:13:40 <glguy_> the ..- girl?
21:13:42 <joelteon> what are we arguing about here?
21:13:45 <benzrf> jennmoneydollars: oh hi
21:13:47 <mwhit> zwer, it definitely is, read any of her other posts
21:13:49 <jennmoneydollars> I'm a woman
21:14:06 <benzrf> i love css perverts :-D
21:14:07 <zwer> mwhit yeah, looks like I was mistaken
21:14:15 <benzrf> found it today via /r/programmingcirclejerk
21:14:26 <jennmoneydollars> thanks benzrf I appreciate it
21:20:15 <joelteon> jennmoneydollars, did you write that blog post?
21:20:18 <joelteon> sorry, I'm late to the party
21:20:22 <jennmoneydollars> yes
21:20:28 <joelteon> it's pretty funny
21:20:31 * hackagebot hailgun-send 0.1.0.0 - A program to send emails throught the Mailgun api.  http://hackage.haskell.org/package/hailgun-send-0.1.0.0 (RobertMassaioli)
21:20:32 <jennmoneydollars> all my medium posts are satire
21:20:46 <splintax> love your work
21:21:01 <jennmoneydollars> so, like, not hating on haskell. I write mostly about js and css anyway
21:21:09 <zomg> I was 50-50 on whether it was a joke... Past experiences :/
21:21:10 <splintax> i think you had me fooled for the first 70% of the first article i saw
21:21:11 <jennmoneydollars> splintax: thnx
21:21:47 <shlevy> Any pointers for getting started with concurrency in haskell? I already have experience with concurrency in imperative languages.
21:21:51 <jennmoneydollars> yeah I understand that it's easy to fall for it and that's whatever, but I try to make my bio's ridiculous enough to figure it out
21:22:09 <genzoon> how do I add 10 to all the elements i. [[Int]] ?
21:22:14 <genzoon> in
21:22:59 <benzrf> genzoon: map (map (+10))
21:23:04 <shlevy> map $ map ((+) 10)
21:23:12 <benzrf> shlevy: what kinda concurrency
21:23:25 <benzrf> primitive-level fork and lock stuff?
21:23:37 <benzrf> there's things like coroutines and pipes
21:23:43 <benzrf> if you want higher-level conc
21:23:43 <shlevy> benzrf: Yeah, just to understand what's going on under the hood
21:23:58 <genzoon> map map.. ok I could have thought of that myself
21:24:00 <shlevy> Ideally I'll never write anything directly with it :D
21:24:02 <benzrf> shlevy: @wiki Concurrency
21:24:09 <benzrf> @wiki Concurrency
21:24:09 <lambdabot> http://www.haskell.org/haskellwiki/Concurrency
21:24:17 <shlevy> *facepalm*
21:24:22 <shlevy> I should really learn to check the wiki
21:24:26 <shlevy> Sorry for the noise
21:24:43 <benzrf> for haddock pls refer to http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
21:27:04 <genzoon> :t map map (+10) [[1,2,3]]
21:27:05 <lambdabot>     Couldn't match expected type ‘[[t0]] -> t’
21:27:06 <lambdabot>                 with actual type ‘[[a0] -> [b0]]’
21:27:06 <lambdabot>     The function ‘map’ is applied to three arguments,
21:28:12 <benzrf> genzoon: look at what you are doing
21:28:26 <Exio> :t map (map (+10)) [[1,2],[3,4]]
21:28:27 <lambdabot> Num b => [[b]]
21:28:28 <genzoon> i dont quite get where i need parens and where i dont in cases like this.. I can usually guess it, or correct it on error, but i dont have firm understanding of it
21:28:47 <benzrf> genzoon: do you understand currying?
21:28:51 <shlevy> "Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages." there's never any use of OS threads with forkIO? How can even the best userspace scheduler take advantage of multiple cores?
21:29:19 <tac_> shlevy: I just read eerlier today it DOES use OS threads
21:29:20 <genzoon> benzrf: i think so
21:29:27 <tac_> but only in certain circumstances
21:29:35 <benzrf> forkOn docs say:
21:29:36 <benzrf> >Like forkIO, but lets you specify on which processor the thread should run. Unlike a forkIO thread, a thread created by forkOn will stay on the same processor for its entire lifetime (forkIO threads can migrate between processors according to the scheduling policy). forkOn is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.
21:29:38 <tac_> and one of those circumstances was to take advantage of multiple cores
21:29:48 <benzrf> genzoon: ok
21:29:59 <benzrf> try putting in the implicit parens to see how application will proceed
21:30:00 <benzrf> look at this:
21:30:04 <benzrf> map map (+1) [[1, 2, 3]
21:30:06 <benzrf> map map (+1) [[1, 2, 3]]]
21:30:07 <benzrf> ugh
21:30:09 <benzrf> map map (+1) [[1, 2, 3]]
21:30:10 <benzrf> ok
21:30:15 <benzrf> genzoon: try filling in the implied parens
21:30:21 <benzrf> remember, function app is left-associative
21:30:46 <genzoon> function app?
21:30:50 <glguy_> shlevy: You can use the threaded runtime in which case it uses a couple of OS threads to run your Haskell threads
21:31:00 <glguy_> shlevy: or the normal runtime that only uses one
21:31:03 <Zekka> genzoon: When you write "f x", you apply f to x
21:31:25 <glguy_> The flag to GHC is -threaded when linking your program
21:31:27 <genzoon> okay
21:31:49 <benzrf> app being short for application
21:31:52 <shlevy> glguy_ benzrf: Hmm it seems like then the documentation is misleading at least
21:31:53 <benzrf> function application
21:31:57 <benzrf> application of functions ot args
21:32:00 <benzrf> *to
21:32:06 <benzrf> shlevy: wouldnt know, havent used it
21:32:07 <genzoon> I still dont know the answer to that question
21:32:18 <benzrf> genzoon: let's say i have:
21:32:23 <benzrf> 1 / 2 / 3 / 4
21:32:30 <enthropy> glguy_: seems to be that it wants libpthread.so even without -threaded
21:32:32 <benzrf> genzoon: / must be either left or right-associative
21:32:34 <benzrf> that could be:
21:32:39 <benzrf> ((1 / 2) / 3) / 4
21:32:40 <benzrf> or
21:32:46 <benzrf> 1 / (2 / (3 / 4))
21:32:47 <benzrf> depending
21:32:50 <benzrf> those are not the same thing!
21:32:53 <benzrf> map map (+1) [[1, 2, 3]]
21:32:55 <genzoon> right
21:32:58 <benzrf> function application is left-associative
21:33:04 <benzrf> meaning the parens nest to the left
21:33:10 <benzrf> genzoon: add the implied parens, how does it look?
21:33:26 <benzrf> 11:32 < benzrf> meaning the parens nest to the left
21:33:36 <benzrf> by 'the parens' i mean the default implied ones when you dont specify
21:34:17 <genzoon> so (((map map) (+1) [[..]]) ?
21:34:39 <benzrf> you misplaced the last one
21:34:48 <benzrf> er
21:34:50 <benzrf> i mean left one ut
21:35:29 <benzrf> ((map map) (+1)) [[..]]
21:35:35 <benzrf> you're applying map to map
21:35:40 <genzoon> yeah I see it
21:35:42 <benzrf> then you're applying the result of that to (+1)
21:35:47 <benzrf> which will not type check
21:36:02 <benzrf> you want to apply map to `map (+1)'
21:36:44 <benzrf> map (map (+1)) is necessary so that the 2nd map doesnt get pulled in as an arg
21:37:14 <benzrf> much like 3 * (4 + 5) needing parens so that the 4 isnt bound to the * instead of the +
21:39:09 <genzoon> so imagined operator for function application is space?
21:39:38 <benzrf> yep
21:39:39 <genzoon> :t ( )
21:39:40 <lambdabot> ()
21:40:04 <benzrf> :t ($)
21:40:05 <lambdabot> (a -> b) -> a -> b
21:40:33 * hackagebot CBOR 0.1.0.1 - Encode/Decode values to/from CBOR  http://hackage.haskell.org/package/CBOR-0.1.0.1 (KyleMurphy)
21:40:36 <zereraz> hello people, myDropX n xs = if n <= 0 || null xs then xs else myDropX (n - 1) (tail xs)  in this the part after || , is it pattern matching?
21:41:37 <MP2E> null is a function that returns true is xs is null and false if it isn't
21:41:46 <MP2E> quite similar to pattern matching conceptually, but it is an ordinary function
21:41:56 <zereraz> oh
21:42:02 <zereraz> and || is OR
21:42:06 <MP2E> exactly!
21:42:14 <MP2E> also an ordinary function, thanks to laziness in Haskell :)
21:42:25 <genzoon> it is?
21:42:44 <MP2E> Indeed, haskell has strikingly few 'primitives' most things are regular functions
21:42:59 <zereraz> I just read that in real world haskell :D
21:43:04 <zereraz> Thanks
21:43:11 <benzrf> if..then..else is a primitive, but it doesnt need to be
21:43:13 <MP2E> @src (||)
21:43:13 <lambdabot> True  || _ =  True
21:43:13 <lambdabot> False || x =  x
21:43:15 <MP2E> :)
21:43:15 <benzrf> i could say:
21:43:28 <benzrf> ifFunc True t _ = t
21:43:34 <benzrf> ifFunc False _ e = e
21:43:37 <benzrf> and then
21:43:44 <benzrf> ifFunc (cond || othercond) 4 5
21:44:02 <benzrf> case is the primitive here
21:44:06 <zereraz> benzrf: what is t there
21:44:10 <pyon> For consistency with maybe and either, that function should be called bool. :-P
21:44:23 <ion> and have a different order of parameters
21:44:28 <zereraz> is it body of it?
21:44:30 <zereraz> if*
21:44:41 <genzoon> oh that is neat. why is if a primitive then and not a function?
21:44:57 <benzrf> genzoon: convenience of syntax, probably
21:44:58 <enthropy> there's a shortage of precedence levels
21:45:00 <benzrf> i dunno
21:45:11 <enthropy> war on parentheses
21:45:33 <benzrf> ifFunc (cond || othercond) 4 5
21:45:35 <benzrf> VS
21:45:40 <zereraz> what is the difference between primitive and inbuilt function
21:45:46 <benzrf> ifFunc cond || othercond then 4 else 5
21:45:50 <benzrf> no parens!!!!111
21:45:59 <benzrf> zereraz: primitive is a language-level feature
21:46:14 <benzrf> inbuilt function is a regular function that happens to be implemented in the compiler instead of in haskell
21:46:19 <genzoon> i actually find it easier to see what is going on at a glance in if function
21:46:24 <benzrf> or is part of the stdlib, maybe
21:46:25 <zereraz> why is it good to have less primitives? won't it be faster with primitives
21:46:32 <benzrf> zereraz: maybe
21:46:35 <benzrf> but it makes the language cleaner
21:46:43 <zereraz> benzrf: ok thanks
21:46:59 <zereraz> by language level you mean the compiler ?
21:47:13 <genzoon> reminds me of lisp (it cant be a function there, though)
21:47:16 <ion> In what way is the if-then-else primitive faster than the equivalent function?
21:47:52 <genzoon> no function call I guess?
21:48:10 <genzoon> but it could be inlined
21:48:44 <benzrf> zereraz: by language level i usually mean that it's part of the syntax
21:49:03 <benzrf> or is otherwise embedded into the language at a level beyond the stdlib
21:49:06 <zereraz> ok got it
21:49:17 <benzrf> for example, pointer dereferencing is a primitive in C
21:49:20 <genzoon> could case be non-primitive?
21:49:23 <zereraz> is prelude the stdlib of haskell?
21:49:28 <benzrf> genzoon: not that i can tell
21:49:39 <benzrf> zereraz: prelude is the default-imported module
21:49:51 <benzrf> zereraz: the stdlib is considerably larger, depending on how you define stdlib
21:50:13 <zereraz> ok
21:52:45 <systemfault> I was reading tutorials… was wondering why type holes wasn’t working for me :/ Seems that it requires a newer compiler than the one shipped with the haskell platform. Heh
21:52:57 <genzoon> it is cool how you can make simple syntactic extension in haskell with plain functions
21:53:41 <tertl3-laptop> @let e = 2.81
21:53:43 <lambdabot>  Defined.
21:53:53 <MP2E> there actually is no difference between a primitive and a regular function in haskell
21:53:56 <MP2E> functions are usually inlined
21:54:00 <MP2E> because there's little reason not to
21:54:15 <MP2E> also functions that can be turned into terse assembly outputs usually are
21:54:21 <MP2E> you'd be surprised at how well GHC optimized
21:54:24 <MP2E> optimizes*
21:54:27 <MP2E> it's pretty mind blowing at times
21:54:39 <MP2E> err I'm sorry I was a bit unclear
21:54:49 <MP2E> no difference between a primtive and a regular function *in terms of performance*
21:54:53 <enthropy> @src seq
21:54:54 <lambdabot> Source not found. Just try something else.
21:54:56 <MP2E> in terms of implementation of course there is a difference
21:55:11 <genzoon> was thinking about case as a function, wouldnt this work? caseFunc :: a -> [(a, b)] -> b
21:55:43 <enthropy> genzoon: http://hackage.haskell.org/package/first-class-patterns
21:55:50 <zwer> MP2E you can't pass syntax to higher order functions
21:56:08 <genzoon> ah so  it can be done
21:56:44 <benzrf> genzoon: well
21:56:46 <benzrf> how would you call it
21:57:05 <benzrf> genzoon: also, we have
21:57:09 <benzrf> :t lookup
21:57:10 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
21:57:20 <genzoon> case 10 [(10, "ten")]
21:57:28 <genzoon> we would need a default too
21:57:30 <enthropy> genzoon: it's not as nice though because the variable bound isn't in the same place as the constructor being matched on
21:57:33 <benzrf> genzoon: but what about
21:57:34 <genzoon> maybe Maybe
21:57:50 <benzrf> case [1, 2, 3] [(foo:bar, bar)]
21:58:08 <benzrf> foo and bar arent bound in the scope
21:58:26 <genzoon> uh right
21:58:56 <ion> I wonder if first-class-patterns could take advantage of prisms?
21:59:06 <dfeuer> @type sequence_
21:59:07 <lambdabot> Monad m => [m a] -> m ()
21:59:16 <dfeuer> @type mapM
21:59:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:59:33 <dfeuer> Hm.
21:59:53 <dfeuer> @src mapM
21:59:53 <lambdabot> mapM f as = sequence (map f as)
22:00:00 <dfeuer> @src sequence
22:00:00 <lambdabot> sequence []     = return []
22:00:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:00:00 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
22:00:44 <dfeuer> What's that OR about?
22:01:12 <Cale> dfeuer: Just another implementation
22:01:35 <Cale> dfeuer: The implementations in @src are just from a curated text file and don't necessarily match the implementations in GHC
22:01:43 <Cale> A lot of them are taken from the Report
22:01:43 <dfeuer> Ah.
22:01:53 <dfeuer> Ondrestood.
22:02:30 <dfeuer> Can you help me understand why sometimes translation to foldr/build fusable forms has to be reversed when things don't fuse?
22:02:42 <dfeuer> That seems to complicate matters greatly.
22:02:51 <Cale> The foldr implementation of sequence is interesting in that it highlights the way in which sequence is replacing list structure with program structure
22:03:08 <Cale> I'm not sure what you mean by reversed?
22:03:16 <dfeuer> @type liftM2
22:03:17 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:03:23 <enthropy> ion: looks like you can write   "toPattern :: Prism' a (Tuple vars) -> Pattern vars a"
22:04:02 <giogadi> howdy everybody
22:04:11 <Cale> hello!
22:04:20 <giogadi> got a question for y'all if you don't mind
22:04:25 <dfeuer> Cale, I mean there will typically be a basic form in hand-written recursion, then a rule that replaces that with a form designed to fuse, and then another rule to undo that later if it doesn't actually fuse.
22:04:47 <dfeuer> giogadi, questions and answers are reversed here, as on Jeopardy.
22:05:16 <giogadi> dfeuer: pretend there's a "flip $" in front of everything I say then
22:06:19 <Cale> giogadi: Go right ahead. Usually on IRC it's best just to ask your questions, because it's hard for people to know whether they'll be able to be helpful until the question has been asked (and lots more people are watching than speaking)
22:09:33 <giogadi> I have a data structure that accepts elements of types that must be instances of class Foo. I'm currently using elements of type Bar. I'd like each element to drag along more information of type Extra unrelated to the data structure, so I'd like to make some other type "data Combined a = Combined Bar Extra" an instance of class Foo
22:10:01 <giogadi> Can I make class instances that are type parameterized?
22:10:07 <genzoon> liftM2 type is cary looking
22:10:12 <genzoon> scary
22:10:15 <dfeuer> Cale, things like "mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
22:10:16 <Cale> dfeuer: Perhaps you should give an example of exactly what you mean, but a lot of the time these sorts of fusion involve introducing an operation to convert the lists or whatever into another stream representation on which fusion acts, and then back again into a list representation after the transformation, and it's the removal of adjacent toStream . fromStream pairs that actually makes things more efficient.
22:11:02 <Cale> and I suppose even in non-stream fusion cases, you want to avoid converting to that secondary representation if it's not going to buy you anything after all
22:11:19 <giogadi> Basically, I'd like to easily make instances of the class Foo of type "Combined Bar a" without having to explicitly define an instance for each type a
22:11:53 <zq> Cale: i finished writing my app with monad transformers :>
22:12:02 <giogadi> this has been hard to express...
22:12:05 <Cale> zq: Is it any better? :D
22:12:10 <zq> Cale: it's so modular and fast and shiny :D
22:12:26 <Cale> zq: Okay, so long as you're happy with it :)
22:12:48 <Cale> giogadi: Perhaps you should be more specific about what your program is?
22:13:02 <genzoon> good night
22:13:37 <Cale> giogadi: Perhaps it's possible to write an instance like   instance Foo a => Foo (Combined a)  ?
22:13:56 <giogadi> Cale: oh....that might actually be it! lemme think for a minute
22:15:37 <giogadi> Let me try another way to explain it
22:16:00 <Cale> What's the actual class you're working with and its operations?
22:16:15 <Cale> If you put some real code on lpaste.net or something, I can have a look
22:16:39 <zq> so
22:16:59 <zq> how come haskell doesn't allow imports within a local scope?
22:18:17 <dfeuer> Cale, I think I understand some of it a bit better now. At least for map and filter, the untranslations see to happen *if* the build isn't eaten (and therefore ends up inlined) *and* the foldr doesn't eat.
22:18:27 <dfeuer> *seem
22:18:43 <randen> systemfault: The next version of the Haskell Platform will have GHC 7.8.3
22:18:57 <augur> if i make an app with haskell, and i want there to be a library directory, is there a conventional way of handling this?
22:19:24 <systemfault> randen: Good to know :) Thank you
22:20:17 <giogadi> Cale: I have a data structure that only stores keys, with insert and isMember operations. The keys must be of a type of class Key. I'd like to augment the structure to also store data of arbitrary type a along with each key without changing the implementation of the data structure. I can do this by creating an instance for each individual type 'a' that I might use; but is there a more general way to do it?
22:20:19 <dfeuer> zq, very few languages do.
22:20:33 <zereraz> what is the difference between || and |?
22:20:43 <dfeuer> giogadi, that data structure is called a "set".
22:21:00 <dfeuer> And then that next one is called a "map"
22:21:00 <augur> i think normally this sort of thing is done by an installer, but is it necessary?
22:21:13 <zq> dfeuer: but why specifically does haskell not?
22:21:20 <augur> i feel like maybe one way is to just check at program startup for a library dir, and create it if its not there
22:21:38 <giogadi> dfeuer: right. my structure is homomorphically equivalent to that interface, but not quite a set or map
22:21:51 <giogadi> dfeuer: simpler this way than describing exactly what I'm doing
22:22:03 <giogadi> homomorphically -> isomorphically, oops
22:22:28 <Cale> giogadi: Make a key type which is polymorphic in the value type, and write an instance for that?
22:22:47 <dfeuer> zq, Haskell's so-called module system is something that was put together in a day or two because no one could agree on what sort of module system Haskell should have and they needed *something*. I think people are now starting to get a sense of how it might work in the future.
22:22:47 <Cale> giogadi: It's okay to have type variables in instance heads, the important thing is just to have *some* type constructor there
22:23:12 <giogadi> Cale: that was precisely my question but I didn't know how to express it. so you *can* have type variables there, got it
22:23:23 <giogadi> thanks, I'll go try it!!!
22:23:58 <augur> Cale: do you know? :O
22:24:17 <Cale> augur: I don't know if there's anything standard.
22:24:30 <augur> Cale: any suggestions?
22:24:43 <benzrf> g2g bbl
22:24:55 <benzrf> bye
22:25:00 <Cale> zereraz: || is an infix operator, | is punctuation (part of the syntax of guards and list comprehensions)
22:25:27 <zereraz> Cale: can | work as or
22:25:43 <Cale> zereraz: not really? It's a reserved symbol.
22:26:14 <zereraz> Cale: what does this mean data Bool = False | True
22:26:16 <Cale> When you're reading guards, it delimits the possible branches, and so it's kind of like "or"
22:26:24 <zereraz> are they not using it as OR
22:26:29 <Cale> oh, right, of course it also appears in the syntax of data declarations!
22:26:40 <Cale> Yes, they're roughly using it as "or" there
22:26:40 <augur> zereraz: "a Bool can be either False or True"
22:26:43 <dfeuer> Ah. That's also orish syntax. But it's not an operator. It's syntax.
22:26:50 <augur> its only an "or" in a spiritual sense
22:26:57 <Cale> It's just punctuation which separates the cases in the syntax
22:27:01 <zereraz> ok so not an or but works like on in this case
22:27:07 <zereraz> one*
22:27:11 <Cale> yeah
22:27:12 <dfeuer> Ehhhhhh.
22:27:17 <dfeuer> Grammatically.
22:27:20 <zereraz> ok thanks
22:27:22 <augur> zereraz: best not to think of it as "working one one" here, i feel
22:27:37 <Cale> It's not like there are other operators which could go in its place
22:27:44 <augur> this is one of those "or"s that's also an "and"
22:27:56 <zereraz> augur: thats funny
22:28:00 <augur> Cale: its strange, because if you use GADT notation, you want to say "and"
22:28:02 <zereraz> how
22:28:18 <augur> data Bool where { False :: Bool ; True :: Bool }
22:28:21 <augur> and you want to read this as
22:28:24 <zereraz> data Bool = False | True in here it can not be and right
22:28:28 <Cale> It depends on how you write the sentence which is describing the type :)
22:28:28 <augur> False is a Bool, and True is a Bool
22:28:43 <dfeuer> augur, there's no | there!
22:28:48 <augur> dfeuer: no thats true
22:28:58 <dfeuer> There's a ; , which is an "and".
22:29:00 <zereraz> ok I think I got it
22:29:08 <augur> dfeuer: but the "translation" into english uses an "and", and the meaning is the same
22:29:09 <zereraz> ; is an and?
22:29:13 <augur> zereraz: no!
22:29:16 <dfeuer> Well, grammatically.
22:29:20 <augur> ; just separates in-line lines
22:29:21 <Cale> zereraz: You're exhaustively listing the possible values of type Bool, and | is your delimiter
22:29:22 <dfeuer> Sort of.
22:29:24 <zereraz> ok only here
22:29:25 <Cale> | is like a comma here
22:29:36 <augur> Cale: more like a semicolon!
22:29:40 <dfeuer> I think this is not helpful.
22:29:42 <zereraz> interesting
22:29:42 <augur> oh woe is us
22:29:48 <augur> i agree, i doubt its helpful
22:29:51 <Cale> Yeah, let's drop this because it's a silly discussion
22:29:59 <zereraz> ok thanks
22:30:00 <augur> | is just punctuation, thats all
22:30:05 <dfeuer> In a let or where or GADT, a ; is sort of an "and". But in do notation it's entirely unrelated.
22:30:09 <Cale> zereraz: (unless you're actually still confused)
22:30:11 <dfeuer> Dropping.
22:30:17 <zereraz> not confused
22:30:34 <zereraz> I will get confused if you guys would have gone on :P
22:31:03 <zereraz> back to realworldhaskell
22:31:06 <augur> dont worry, we're confused too!
22:31:16 <dfeuer> I'm usually confused.
22:31:22 <Cale> zq, dfeuer: Anyway I was going to say, one of the reasons the Haskell module system is not too fancy is because at the time it was designed, there weren't likely to be many interesting papers to come out of that
22:31:37 <Cale> Other MLs had explored that design space quite a lot
22:32:05 <Cale> and so they put in something which felt like it struck a good balance between implementation difficulty and power to abstract things
22:32:17 <Exio> i have a datatype (Team) that takes "TeamA [Player]" and "TeamB [Player]", and Player is "Player Role Nick", and Role can be "RoleA" "RoleB" and "RoleC" while RoleA is TeamA-specific, RoleB is TeamB-Specific, and RoleC can be "used by both", how could i be sure (somehow using the type system) that a TeamA's list of player will NEVER have a RoleB?
22:32:32 <Cale> But it doesn't have all the features you might want to have if you're coming from something like O'Caml
22:32:35 <wereSheep> I have a cabal question. I bumped the lower bound of a dependency in my cabal file and now cabal install is refusing to install dependencies because an older version of the library is already installed.
22:32:51 <Exio> i think a small paste will explain this better
22:32:56 <wereSheep> I event tried '--upgrade-dependencies --force-reinstalls' but it still refuses to install
22:32:59 <Cale> also, if you start doing higher-order modules and stuff, you begin to step on the toes of type classes a bit
22:33:03 <dfeuer> Except ... different languages have very different module system needs! Like Schemes need to deal with interactions between modules and macros, and Haskell has interactions between modules and class stuff. And so on.
22:33:07 <Cale> (though not really so much)
22:33:22 <augur> Cale: i feel if they had just made modules a special case of records they'd be fine
22:33:28 <wereSheep> https://gist.github.com/wereHamster/fe90ce31d8487f555bec - I bumped the lower bound of aeson to 0.8.0.0
22:33:59 <dfeuer> There are definitely times where "there's more than one way to do it" gets to be a big problem because they're incompatible with each other.
22:34:05 <dfeuer> Higher-order modules vs. fancy types vs. classes.
22:34:15 <Cale> Exio: Perhaps by making Role be a GADTtype parameter
22:34:20 <Cale> oops, edit fail
22:34:39 <Cale> Exio: Perhaps by making Role be a GADT with a type parameter to say which team things must be used with
22:34:45 <Cale> e.g.
22:34:56 <isomorpheous> Hey, so, trying to compile my file, getting this shit http://sprunge.us/AWFG
22:35:11 <Cale> data Role a where RoleA :: Role A; RoleB :: Role B; RoleC :: Role t
22:35:13 <isomorpheous> what on earth does that mean?
22:35:44 <augur> Cale: ive thought about that for alternate type classe things
22:36:04 <augur> Cale: ive decided that the defaulting method is probably best
22:36:19 <augur> i think jonsterling had some good examples why the role-y approach to type classes is weird
22:36:24 <Cale> isomorpheous: how are you causing this build to happen?
22:36:31 <isomorpheous> Cale: "cabal build"
22:36:42 <isomorpheous> Cale: I've tried deleting dist/ , and re-building, nothing
22:36:48 <Cale> hmm
22:36:55 <Exio> hm, will try
22:38:32 <Cale> wereSheep: Perhaps include the package versions you want to use on the commandline with cabal install
22:38:50 <isomorpheous> Cale: all in the .cabal file
22:38:58 <wereSheep> Cale, isn't that the point of having a cabal file? They are already listed there
22:39:01 <isomorpheous> Cale: oh you weren't talking t ome
22:39:04 <Cale> wereSheep: oh, okay
22:39:08 <Exio> wouldn't "A" and "B" have to be type constructors though?
22:39:24 <Cale> wereSheep: well, I was thinking the versions of the indirect dependencies
22:39:32 <Cale> Exio: yes, they would
22:39:41 <Cale> Exio: Or you could use DataKinds
22:39:45 <rwbarton> isomorpheous: it might mean you left out Text.Flogger.JSON from other-modules:
22:39:45 <Cale> (if you want to be fancy)
22:39:52 <Cale> You could make them empty types though otherwise
22:39:57 <rwbarton> in the library stanza
22:40:03 <Exio> i'll check DataKinds
22:40:10 <isomorpheous> rwbarton: Text.Flogger exports Text.Flogger.JSON
22:40:42 <Cale> Exio: https://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html
22:40:46 <rwbarton> that's not relevant
22:40:49 <isomorpheous> rwbarton: op you were right!
22:40:52 <isomorpheous> rwbarton: thank you
22:41:02 <rwbarton> cabal only links the modules you list into a library
22:41:23 <rwbarton> (which is a little weird, it should at least be able to detect when you omitted some and give a more helpful message)
22:41:55 <Exio> seems like DataKinds is very useful
22:42:01 <isomorpheous> rwbarton: agree
22:42:05 <Exio> thanks, i think that is what i needed
22:42:14 * isomorpheous is too tired to work anymore
22:46:06 <dfeuer> I'm still totally stuck trying to figure out if these two expressions are equivalent. Part of the trouble is that I don't understand them well enough even on their own. The other trouble is that they seem ... hard to take apart.
22:47:15 <dfeuer> It's all a question of whether a certain application of seq in an argument to build is safe. I ... have no idea.
22:47:53 <zq> Cale: yeah um import could work the exact way it does now with the addition of local scope imports
22:50:10 <zq> Cale: right now it's just a mechanism of introducing symbols
22:50:26 <zq> Cale: which is orthogonal to lexical scope
22:50:50 <zq> i'm nott asking for first-class modules and all that snazz
23:02:26 <wereSheep> Cale: which indirect dependencies?
23:13:32 <dmj`> > 4 / 2 * 5
23:13:33 <lambdabot>  10.0
23:13:46 <dmj`> division comes before multiplication?
23:14:15 <splintax> left comes before right
23:14:20 <MP2E> @src (/)
23:14:20 <lambdabot> Source not found. stty: unknown mode: doofus
23:14:26 <MP2E> lulz
23:14:35 <MP2E> But yeah division and multiplication are the same level
23:14:38 <MP2E> just it goes left to right
23:16:19 <dolio> zq: It would make parsing easier, except that advantage gets thrown away.
23:16:30 <dmj`> gotcha
23:24:19 <l0cust> So, getting this error with optparse-applicative - http://ix.io/dy7
23:24:34 <dolio> I guess it still makes parsing easier in some sense.
23:25:14 <l0cust> Here's the file with main - http://lpaste.net/108014
23:27:49 <l0cust> The error is thrown in this file - https://hackage.haskell.org/package/optparse-applicative-0.9.0/docs/src/Options-Applicative-Builder.html
23:28:06 <l0cust> First function in the file
23:30:18 <wereSheep> where does cabal get the idea that lens 4.3 is a dependency of snap 0.13.2.8? cabal install --dry-run --constraint 'snap==0.13.2.8'
23:30:59 <wereSheep> on hackage as well as in the sources, snap.cabal has an upper bound on lens <4.2
23:31:18 <l0cust> hm
23:33:27 <glguy_> wereSheep: What package are you trying to install?
23:34:48 <wereSheep> glguy_: a private package. Ok, here's how to reproduce. Start with a clean sandbox and run: cabal install --dry-run --constraint 'aeson==0.8.0.0' 'snap==0.13.2.8'
23:34:58 <wereSheep> the message cabal gives is outright misleading
23:35:38 <glguy_> You can't use aeson-0.8.0.0 with lens from hackage directly
23:36:19 <glguy_> It works with that version but it came out after lens was last released
23:36:35 <glguy_> so the cabal file doesn't allow it
23:37:37 <wereSheep> well, lens-4.3 is *not* a dependency of snap-0.13.2.8. Still cabal claims that it is.
23:39:14 <bonobo123> hi, a contravariant question:
23:39:28 <glguy_> wereSheep: I don't know , but change your dep to aeson-0.7.0.6
23:39:33 <glguy_> and you'll be back in business
23:39:46 <bonobo123> I have data type X a b, and I have a function of type (b -> a) -> FieldDef a x -> FieldDef b x
23:39:51 <av> Hi everyone, I'm trying to make a cabal package for a FFI bindings that use a library shipped with the cabal package -- is that possible?  I'm at the point where I have to specify where the shared object is that I'm using through FFI (in normal ghc parameters, this would be "-Lsomething") and don't know what to do. Any ideas?
23:39:54 <bonobo123> This is almost contramap from Contravariant, but the pesky order of type parameters
23:39:58 <bonobo123> Is there a way to make X an instance of Contravariant?
23:40:19 <glguy_> bonobo123: You'll need a newtype wrapper to make it fit
23:40:47 <glguy_> Or possibly make it an instance of Profunctor if it's a Functor in its last argument
23:42:43 <bonobo123> glguy_: it is not a Functor in last argument
23:43:37 <glguy_> bonobo123: OK, then it won't admit an instance of either
23:44:32 <bonobo123> I do not think I can reverse the parameter order either as it is needed somewhere else
23:44:56 <glguy_> That's fine, you'll just have to use the function you wrote directly
23:45:08 <glguy_> instead of overloading the contramap name
23:50:48 * hackagebot keter 1.3.3 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.3 (MichaelSnoyman)
