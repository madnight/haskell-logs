00:00:13 <edwardk> and over the course of it, just watch them all ;)
00:00:29 <Abathurr> I need a billion dollar startup idea, any thoughts? Should be pretty simple.
00:01:01 <isomorpheous> Abathurr: i have a plan
00:01:35 <isomorpheous> Abathurr: You give me some money as a retainer, and you get two other people to join the company
00:02:06 <isomorpheous> You will get paid once you get those two other people, who will in turn get paid when they bring more people aboard
00:02:15 <isomorpheous> Abathurr: works like a charm
00:02:28 <Abathurr> IS this some kind of...illegal scheme!?
00:02:38 <kazagistar> noooooooo
00:02:48 <isomorpheous> Abathurr: not at all
00:02:57 <kazagistar> its like a... tree!
00:03:06 <isomorpheous> Abathurr: You will need to pay for your plane ticket to the Caymans though
00:03:08 <kazagistar> not like another triangular object at all
00:03:16 <isomorpheous> kazagistar: lol
00:05:01 <ReinH> edwardk: she's also incredibly charismatic, which helps.
00:05:08 <Abathurr> isomorpheous: Just don't ask me to deliver a package over the American border next time I go to Peru, and we have a dea
00:05:16 <isomorpheous> ooh
00:05:19 <Abathurr> edeal
00:05:19 <isomorpheous> Yeah, never mind
00:05:40 <edwardk> yeah she's very enthusiastic about the subject matter and that gets across clearly
00:05:57 <isomorpheous> edwardk: ah, what are you talking about
00:06:16 <isomorpheous> edwardk: I was too busy trying to get people to join my pyramid scheme
00:06:35 <edwardk> isomorpheous: https://www.youtube.com/watch?v=9fohXBj2UEI&list=PL0E91279846EC843E
00:06:59 <kazagistar> isomorpheous: no no no, you just have to have some kind of "product" and then you can sue people who call it a pyramid scheme for slander
00:07:21 <isomorpheous> edwardk: I can't understand her accent
00:07:31 <edwardk> it grows on you
00:07:58 <isomorpheous> edwardk: I'm sure
00:08:04 <kazagistar> "oh its a 10 min monad video" .... sees the sequence numbers "oh, OK"
00:08:19 <isomorpheous> edwardk: also a bit busy
00:08:27 <isomorpheous> edwardk: not looking at lectures about things I already know
00:08:36 <nezt> Does anyone here use haskell for web programming
00:08:40 <isomorpheous> nezt: me
00:08:54 <edwardk> isomorpheous: i'd challenge that pretty much anything she talks about she'll point out something you don't know going in ;)
00:09:01 <nezt> How does it compare to something like django? Not talking about the obvious language differences, just in general
00:09:11 <edwardk> i've learned something from pretty much every one of her videos
00:09:13 <isomorpheous> nezt: there's less stuff built in
00:09:26 <nezt> Any advantages?
00:09:37 <isomorpheous> nezt: but development time is a lot faster, because you don't spend nearly as much time debugging useless shit
00:09:43 <ReinH> nezt: well, one is a general purpose programming language. The other is a library.
00:09:47 <isomorpheous> nezt: like routing errors
00:09:50 <kazagistar> edwardk: plus, it starts talking about Algebra and Category pretty quickly, so it has some pretty... unusal knowlege prerequesites from a programmer perspective
00:10:04 <edwardk> kazagistar: they have videos that start earlier
00:10:09 <nezt> ReinH: well , i'm assuming he is using some web framework with Haskell. I guess that's a bad assumption
00:10:10 <ReinH> Haskell has such libraries, so perhaps it wold be better to talk about one of them, or to survey the two langauges' libraries, etc
00:10:11 <isomorpheous> edwardk: yeah, the only reason I understood is because I'm a math major
00:10:15 <edwardk> i pointed to monads because it was something haskellers "know"
00:10:35 <isomorpheous> nezt: There are 3 big web frameworks, and none of them are very good
00:11:03 <isomorpheous> nezt: I wrote my own from scratch. It's good, but not very flexible, so I don't suggest using it
00:11:22 <kazagistar> edwardk: does she have a "start point"?
00:11:23 <isomorpheous> nezt: 3 big haskell web frameworks
00:11:27 <nezt> isomorpheous : link? :) that's awesome
00:11:33 <ReinH> chrisdone has a list of the videos somewhere iirc
00:11:47 <isomorpheous> nezt: http://hackage.haskell.org/package/skell
00:11:52 <isomorpheous> It's nowhere near complete
00:11:59 <isomorpheous> nezt: It doesn't have things like form handling
00:12:00 <ReinH> Oh no, it's byorgey's
00:12:02 <edwardk> she doesn't, but brent compiled an ordered list: http://byorgey.wordpress.com/catsters-guide-2/
00:12:05 <isomorpheous> nezt: but i'm working on it
00:12:10 <ReinH> Yep that.
00:12:24 <isomorpheous> nezt: and hackage can't build the documentation for some reason
00:12:32 <ReinH> I knew it was a haskell cast guest, I just forgot which one ;)
00:12:38 <isomorpheous> nezt: hackage seems to be utterly incapable of doing so nowadays
00:12:46 <Abathurr> I am going to open a nude bar  called the Gaza Strip
00:12:54 <isomorpheous> Abathurr: brillian
00:12:58 <isomorpheous> *t
00:13:14 <kazagistar> "I didn't like the existing 3 frameworks, so I hacked togeather a new framework" <-- how all big frameworks are born
00:13:18 <Abathurr> Every thursday night those of Israeli descent get in free
00:13:23 <isomorpheous> kazagistar: lol
00:13:57 <edwardk> Abathurr: this probably belongs more in #haskell-blah rather than #haskell
00:14:09 <isomorpheous> edwardk: good point, ignored
00:14:28 <Abathurr> edwardk: My apologies
00:14:58 <isomorpheous> edwardk: nothing is more relevant than nude palestinian women
00:15:17 <edwardk> isomorpheous: definitely #haskell-blah
00:15:34 <isomorpheous> anyway
00:15:47 <isomorpheous> nezt: i'd love if you'd give it a shot - I really need to write better documentation
00:15:54 <isomorpheous> nezt: I don't want it to become Yesod
00:15:56 <isomorpheous> nezt: or rails
00:16:30 <kazagistar> edwardk: is "some course on category theory" a sufficient prerequesite for that list? I like the style of the teaching, even if my understanding is failing critically in some places
00:16:51 <edwardk> kazagistar: you could probably start cold if you wanted to
00:17:05 <edwardk> kazagistar: if you were willing to rewind enough and hit wikipedia when you get stuck
00:17:31 <isomorpheous> nezt: I would suggest looking through Happstack
00:18:17 <kazagistar> edwardk: cool, I guess I know what "object in a category" means at a some level, so that is a start
00:21:49 <kazagistar> maybe not, I dont quite have a grasp on "in the category of" so the examples arent clicking :/
00:22:44 <kazagistar> but wikipedia helps, you are totally right
00:22:53 <kazagistar> ill scrap it togeather :D
00:23:39 <Abathurr> WIkipediaing (WIkipeding?) anything related to haskell is like going down the rabbit hole
00:24:01 <Abathurr> You start with something simple and five hours later you cant even pronounce the name of the article you're reading
00:24:25 <kazagistar> thats true for math generally
00:24:52 <kazagistar> but once you get a very basic "foundation" in some area, it lets you build quite a bit on top of it
00:26:55 <kazagistar> like, a few hour primer on groups made most of the group theory pages accessible and quite readable
00:27:47 <ReinH> There's that and then there's nlab.
00:29:39 <Abathurr> ReinH: that's pretty much the epitome of inaccessible to me
00:29:50 <Abathurr> ReinH: at least for right now
00:30:33 <nezt> does anyone have a physical argument for why haskell is the future of programming
00:30:59 <kazagistar> nezt: I have no idea what a physical argument is, so not yet at least
00:31:15 <nschoe> kazagistar, was about to say the same thing ^^
00:31:18 <nezt> it's basically some bullshit i interject to get abstract responses
00:31:23 <nezt> a custom type
00:31:25 <ReinH> Abathurr: nlab is all about higher order category theory, which is still inaccessible for almost everyone on earth. :p
00:31:29 <bjornars> im sure someone has had a physical argument in a bar somewhere about wether or not haskell is the future of programming
00:31:32 <nschoe> nezt, this will most likely start a debate ^^
00:31:33 <ReinH> Including many who find CT accessible
00:32:18 <kazagistar> yeah, I am much too pacifistic to have a physical argument about programming languages
00:32:25 <nezt> bjornars: i lol'd irl
00:32:44 <kazagistar> I... chuckled irl?
00:32:58 <nezt> sorry i meant a quantum physical argument
00:33:43 <Abathurr> In my 'hood, driveby's are done by the OOP guys against the functional guys all the time
00:33:50 <Abathurr> It's sad, they come from broken homes
00:33:56 <nezt> LOL
00:34:10 <d3m1g0d-> displayResult :: Either String Int -> String
00:34:11 <d3m1g0d-> displayResult Right result = show result
00:34:11 <d3m1g0d-> displayResult Left err = err
00:34:14 <d3m1g0d-> why is this incorrect ?
00:34:34 <d3m1g0d-> Constructor "Right" should have 1 argument, but has been given none
00:34:48 <d3m1g0d-> how do I pattern match on Left or Right ?
00:35:07 <ReinH> d3m1g0d-: you need parens
00:35:11 <nezt> Which programming language is closer to making you a demigod upon mastering , Haskell or C? b/c that really answers the question
00:35:15 <ReinH> displayResult (Right result)
00:35:26 <ReinH> otherwise it is parsed as displayResult taking two arguments
00:35:46 <systemfault> nezt: C sucks for a lot of things…
00:36:01 <d3m1g0d-> ReinH: thank you , sir.
00:36:05 <nezt> let's put it all on the table :scientific computing, getting rich as fuck from software / web apps, 1337 haxxoring
00:36:08 <d3m1g0d-> systemfault: give me 2 reasons
00:36:08 <nezt> what is the best
00:36:14 <ReinH> d3m1g0d-: np
00:36:54 <kazagistar> Abathurr: you mean, they call the "run" method on a "driveby" object created from a "CarActivityFactory", with a "FPProgrammerTargeter" mixin?
00:37:18 <systemfault> d3m1g0d-: It sucks for anything dealing with strings. It sucks because of its weak typing (void *) everywhere. It sucks because it doesn’t support generic programming in any way.
00:37:47 <Abathurr> kazagistar: ahaha. You win, good show man.
00:37:54 <nezt> step 1) learn haskell    step 2) use limited human brain power plus haskell to develop nootropic drugs   step 3 ) take nootropic drugs to develop savant like ability        step 4 ) crack the genome and cure aging      step 5 ) go to mars before humanity blows itself up, and establish a religion based on the book dune
00:38:00 <ReinH> it doesn't provide any meaningful compile-time or run-time guarantees of program correctness or safety
00:38:13 <nezt> Can haskell be replaced with anything in that
00:39:04 <kazagistar> nezt: step (3) use savant like brain powers to actually learn haskell properly? :P
00:39:19 <chance> what is the --> arrow, cant find it on hoogle :<
00:39:32 <jle`> chance: where do you see it?
00:39:36 <chance> xmonad
00:39:46 <jle`> @hoogle (-->)
00:39:48 <lambdabot> No results found
00:39:53 <d3m1g0d-> systemfault: how old are you and how much experience do you have with C ?
00:39:57 <jle`> have you tried the xmonad docs?
00:40:15 <nezt> I'm just asking: are there any real, solid arguments for why more humans knowing Haskell will put us closer to curing aging and going to Mars
00:40:17 <systemfault> d3m1g0d-: 31, about 10 years of experience with C++
00:40:23 <ReinH> systemfault: a/s/l plz
00:40:44 <systemfault> 31/bot/irc
00:40:44 <kazagistar> chance: http://www.haskell.org/hoogle/?hoogle=%2Bxmonad+%28--%3E%29
00:40:48 <chance> jle`: been looking
00:40:52 <ReinH> well played
00:40:54 <Abathurr> Unfortunately, a lot of CS papers I read seem like filler.
00:41:08 <ReinH> Abathurr: you're reading the wrong papers then
00:41:31 <nezt> trust me this is the key : having a good base understanding of practically programming, mathematics, and sciences --> develop nootropic drugs --> cure aging --> mars
00:41:32 <ReinH> chance: they have an index
00:41:43 <nezt> practical
00:41:51 <kazagistar> Abathurr: read the ones the other ones cite a lot, and review papers, to start with
00:41:54 <chance> kazagistar: thanks
00:42:09 <kazagistar> chance: you have to +xmonad to add library stuff for xmonad
00:42:29 <nezt> We cure aging and get our asses to Mars before religion ends humanity, and then we establish our OWN Haskell based religion where everyone ritualistically performs sexual favors for the individual with the best prog skills
00:42:31 <d3m1g0d-> systemfault:  then what the hell are you talking about ? all those points are complete nonsense. How are you a 10 years of experience C++ developer and you have those understandings ?
00:42:34 <nezt> It will be a better Martian world
00:43:18 <nezt> We can establish a laser defense system eventually and shoot down anyone trying to enter our atmosphere from earth
00:43:26 <ReinH> I don't think "complete nonsense" means what you think it means.
00:44:04 <Abathurr> nezt: we'll program it in haskell, obv.
00:44:09 <nezt> Think about it, you can all be rich and important on Mars with no disease or genetic defects
00:44:26 <kazagistar> whatever
00:45:00 <kazagistar> I would rather have the no disease or genetic defects for everyone including the earth people
00:45:08 <kazagistar> your future sucks
00:45:18 <nezt> here's the problem though, they'll refuse for "religious reasons"
00:45:20 <d3m1g0d-> ReinH: this language is nowadays used in places with really limited resources. He is searching for higher level of abstraction in a place where it doesn't make any sense. It's like saying "I have wood carving, cuz I can't build a space shuttle with it"
00:45:32 <d3m1g0d-> *hate
00:45:41 <nezt> Absolutely, if they want exposure to technology, expose them for free
00:45:56 <nezt> Still think my future sucks?
00:46:01 <ReinH> d3m1g0d-: other languages can be used for embedded programming
00:46:25 <ReinH> And we're still writing kernels with C, last time I checked, which is no where near a "limited resource" environment.
00:46:57 <nezt> When two humans have sex the body doesn't rewrite all the code from scratch
00:47:16 <Abathurr> ReinH: Sort of off-topic, but do you know of any good resources to learn about writing a C compiler?
00:47:17 <nezt> conception is not low level programming
00:47:21 <ReinH> Rust is a good example of a language that works in many places that C works but is far less dangerous
00:47:25 <nschoe> ReinH, do you mean it is viable to write a Kernel in another language ?
00:47:30 <systemfault> d3m1g0d-: So, you think that C is the pinnacle of system programming languages? What about C++ or Rust?
00:47:37 <ReinH> Abathurr: I guess the dragon book is still good?
00:47:54 <Abathurr> ReinH: I'll look it up
00:47:55 <nezt> Please don't even write a recursive descent parser
00:47:59 <nezt> ever
00:48:08 <ReinH> nschoe: I mean that C is pretty obviously used for non-resource-constrained things
00:48:49 <nschoe> ReinH, yeah of course. Agreed. But is it like "a habit" that kernels are written in C or is it really performance-related ?
00:48:50 <kazagistar> I think C is the best kernel language because we have plenty of kernels that work pretty and dont really need another, and rewriting em would be pointless
00:48:50 <nezt> Use whatever language allows you to develop the latest and greatest social networking bullshit and invest those billions into curing aging and Mars, no?
00:49:00 <nschoe> ReinH, could we actually write a decent kernel in Haskell ?
00:49:05 <nezt> That's all we can do as the non uber rich proletariat
00:49:13 <ReinH> nschoe: at this point it's probably mostly inertia.
00:49:22 <ReinH> Haskell? Maybe not. Rust? Probably.
00:49:28 <nschoe> ReinH, that's what I thought.
00:49:30 <nschoe> Why not Haskell ?
00:49:38 <nschoe> I don't know Rust so I can't say.
00:50:07 <ReinH> I don't expect that non-strict evaluation would work well in that context, but maybe I'm wrong.
00:50:25 <nschoe> ReinH, can I ask you why not ?
00:50:40 <d3m1g0d-> it's treated as an environment with limited resources, doesn't matter that it's actually not.
00:51:16 <d3m1g0d-> systemfault:  what about them ? If you're writing embedded code on C++ you're most of time writing a pure C
00:51:42 <d3m1g0d-> you need control
00:52:20 <systemfault> And? How is “control” mutually exclusive with a non-shitty type system?
00:52:39 <ReinH> You know what's good at controlling how computers do things? Computers.
00:52:40 <nschoe> d3m1g0d-, actually maybe that now depends on what ressource-limited actually means, right ? I have just found and old hard drive from 1999 with a 1.99Gb capacity.
00:52:55 <nezt> what controls how computers control computers ?
00:53:02 <nezt> more computers
00:53:15 <kazagistar> well abstracted algorithms
00:53:32 <ReinH> There's a difference between being a good tool and being the *only* tool.
00:53:44 <ReinH> For a long time, C was definitely the latter. I'm not sure it's ever been the former.
00:53:53 <nezt> If that's such an obvious punchline then why not just Haskell out some well abstracted algorithm for the human brain
00:54:00 <d3m1g0d-> systemfault: I have no idea what you're talking about dude. Shitty type system ?
00:54:23 <systemfault> d3m1g0d-: C’s type system is crap. I don’t think anyone can argue with that.
00:54:25 <ReinH> nschoe: non-strict evaluation might make it tricky to reason about evaluation order, etc, which seems important.
00:54:32 <ReinH> C has a type system?
00:54:33 <ReinH> Huh.
00:54:51 <kazagistar> it has something it calls a type system
00:55:23 <d3m1g0d-> systemfault:  I can argue with that, I've seen how really experienced developers are performing explicit type casting of points, even though that's not in the language specification and the only reason that it works is cuz of how the compiler is implemented
00:55:30 <kazagistar> which is more like a type alias system over a really small set of types, and some random silent coersions
00:55:31 <d3m1g0d-> most of the time are just practices.
00:56:03 <d3m1g0d-> *bad practices
00:56:23 <nezt> I have a question: does consuming alcohol in moderation worsen programming skill
00:56:40 <ReinH> d3m1g0d-: so your argument that C has a good type system is that some programmers are able to some sort of typing *despite* the language?
00:56:44 <ReinH> Not a very good argument.
00:56:54 <kazagistar> d3m1g0d-: allowing shitty practices that are never useful indicated a bad type system, or at least, one that is failing its primary role
00:57:20 <ReinH> I don't see how any language with something like void * casting can be called a type safe language
00:57:38 <d3m1g0d-> nschoe:  That's not the point. The point is that  you treat the kernel as operating in an environment with limited resources. It's all about optimization.
00:58:15 <ReinH> I honestly think this is the first time I've heard someone try to defend C's type system.
00:58:42 <d3m1g0d-> kazagistar: yea, but then again - this is not a language which is usually used by morons. The assumption is not that you've graduated from a law school and then became a web developer and then somehow you're into embedded, right ?
00:58:48 <d3m1g0d-> people there usually know what they're doing
00:59:10 <nschoe> d3m1g0d-, yeah but that doesn't really mean anything : in that case nothing is unlimited, so everything is limited, all ressources are limited and it's always optimization. But that doesn't help the debate here. So I guess it really is about scale and order of magnitude.
00:59:33 <d3m1g0d-> nschoe: have you ever taken a class in Algorithms and Complexity ?
00:59:33 <ReinH> Hell, Guy Steele said that "C fundamentally has a corrupt type system". But I guess he doesn't know anything about C either.
00:59:49 <nezt> If intelligence is entirely genetic, do you tell someone with a low iq who desperately wants to improve humanity to learn haskell or python
00:59:53 <systemfault> Funnier to see someone defending C’s type system… on a Haskell channel
01:00:09 <nschoe> d3m1g0d-, try implementing a navigation system for a drone. It's not the same problem is you embed a RapPi or a uController in it. That's what I mean.
01:01:40 <augur_> nezt: you tell everyone to learn haskell
01:02:13 <ReinH> Let me be clear about this: a guy who was on the *standards committee* that established the ANSI C standard said that C has a "fundamentally corrupt type system"
01:02:21 <ReinH> So I'm just going to go with that.
01:02:22 <d3m1g0d-> This is like the debate "Linux vs Windows". Doesn't which way it goes, in the end of the day ( on a good day ) at most 2% of the market share ( on PCs ) use Linux, right ? Look at it this way : there is a reason why this language continues to be one of the most used ones.
01:02:23 <augur_> nezt: haskell helps everyone. if someone has an edge because they're some kind of supergenius, then it might not help them _as much_ but it will still help them
01:02:57 <ReinH> d3m1g0d-: yes, there's a reason
01:03:04 <kazagistar> d3m1g0d-: thats why povery is the state of most people too, because it is so superior to not starving
01:03:05 <ReinH> no, that reason doesn't have anything to do with whether it's type safe
01:03:52 <ReinH> So you're claiming that C is a superior language in the same way that Windows is a superior operating system.
01:03:53 <d3m1g0d-> i agree with that
01:03:54 <ReinH> Got it.
01:03:58 <kazagistar> d3m1g0d-: clearly, frequency is a perfect indicator of quality, and no other factors matter /s
01:04:17 <ReinH> I'm pretty sure this is an elaborate troll.
01:04:24 <ReinH> No one can actually believe that C has a good type system, right?
01:04:29 <d3m1g0d-> ReinH: it's all about the market. The market says that and you're and my opinions are irrelevant.
01:04:29 <Abathurr> d3mig0d: The fact that C is widely used is by no means a valid argument for it's superiority to anything
01:04:40 <ReinH> d3m1g0d-: The market says no such thing.
01:04:43 <d3m1g0d-> *your
01:04:48 <d3m1g0d-> 2% market share
01:04:52 <d3m1g0d-> is "unusable"
01:05:02 <kazagistar> ReinH: he isn't arguing about the type system at all, he is arguing something about markets, and totally missing a logical leap to the type system
01:05:06 <ReinH> That's not actually true.
01:05:14 <PatrickRobotham> I'm not sure that argument works.
01:05:17 <d3m1g0d-> It's not good, it's not even bad, it's unusable.
01:05:19 <ReinH> It doesn't work.
01:05:31 <ReinH> There's no implication here
01:05:31 <PatrickRobotham> I mean, corollas are more popular than ferrari sports cars right?
01:05:38 <PatrickRobotham> Which would you prefer to drive?
01:05:40 <ReinH> It doesn't follow at all
01:05:53 <augur_> is d3m1g0d- arguing that haskell sucks?
01:05:57 <PatrickRobotham> What's the phrase. Argumentum ad populum?
01:06:10 <kazagistar> I am sure it does not work, because instantiating the argument on different instances shows clear counterexamples.
01:06:23 <Abathurr> PatrickRobotham: yes exctly
01:06:27 <augur_> d3m1g0d- is making an evolutionary argument
01:06:31 <ReinH> There can be a multitude of reasons besides quality for market preference
01:06:43 <ReinH> Look at Beats headphones.
01:06:43 <augur_> C has out-competed Haskell, therefore it is fitter
01:07:06 <augur_> which is true, but the metric of fitness in evolution is not quality of output, type safety, or anything
01:07:17 <PatrickRobotham> Wow. I didn't know people actually thought that way.
01:07:22 <augur_> the metric in fitness is survival in a particular context and thats all it is
01:07:26 <d3m1g0d-> ReinH: no there aren't. The goal is the market share. Everything else is opinions.
01:07:27 <PatrickRobotham> d3m1g0d-: Is your favourite organism the flu virus?
01:07:41 <augur_> anyway, d3m1g0d- is trolling
01:07:41 <kazagistar> augur_: fitness metric changes, and populations dont always change at instantly to adapt to it
01:07:50 <PatrickRobotham> d3m1g0d-: I thought the goal of haskell was to create a common language for researchers of type theory.
01:07:51 <augur_> kazagistar: yep, hence why i said "in context"
01:07:53 <ReinH> d3m1g0d-: market share proves nothing other than market share
01:07:58 <augur_> someone just ping the mods and end the trolling
01:07:59 <augur_> @ops
01:07:59 <lambdabot> Maybe you meant: pl oeis docs
01:08:04 <augur_> :|
01:08:17 <d3m1g0d-> ReinH: no ... it proves success. it's the most objective criteria for success there is.
01:08:32 <Abathurr> why is the goal market share?
01:08:34 <ReinH> If you define success tautologically as market share, sure
01:08:36 <ReinH> otherwise, no
01:09:11 <kazagistar> d3m1g0d-: by what metric do you determine "most objective"? and "most" or "least" statement requires some clarification of metric
01:09:16 <ReinH> And last time I checked, languages don't have agency. They don't have goals.
01:09:59 <kvanb> languages have goals
01:10:00 <Abathurr> IF you want to argue about C's type system then market share has fuck-all to do with it
01:10:04 <kvanb> try and tell erlang it has no goal
01:10:19 <Abathurr> If you want to argue popularity, you may have a point
01:10:29 <kazagistar> people have goals, and people create languages
01:11:09 <kazagistar> if you wish to define "language goals" as "shared goals for the purpose of a language by the primary contributors" then maybe you can construct some kind of "language goals"
01:11:52 <ReinH> I'm trying to remember the last time a language creator listed "market share" as one of their goals.
01:12:27 <ReinH> Hmm.
01:12:42 <kazagistar> probably tongue and cheek references to "world domination"?
01:12:50 <augur_> tongue in cheek
01:13:01 <d3m1g0d-> cuz market share brings profits ( or "funds for development" if you 're a free software fan ). Imagine a world where Linux had 70% of the market share. Probably the big  software and hardware vendors would be behind the operating system, bypassing Windows. It would be a cool world, but will most probably never happen.
01:13:15 <kazagistar> augur_: my bad, thanks
01:13:23 <augur_> d3m1g0d-: you're gonna need to provide evidence for that
01:13:42 <Abathurr> Yes but what you're missing is that has nothing to do with how good the language is technically
01:13:52 <ReinH> d3m1g0d-: Do you have any other modes of argument besides "stating things without evidence in a very confident tone"?
01:14:08 <augur_> @op
01:14:08 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
01:14:10 <ReinH> Because this one is getting pretty boring.
01:14:11 <augur_> :|
01:14:22 <augur_> ?ops
01:14:22 <lambdabot> Maybe you meant: pl oeis docs
01:14:23 <augur_> ?op
01:14:24 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
01:14:25 <augur_> >_<
01:14:33 <ReinH> I'm going to bow out of this one.
01:14:49 <ReinH> I don't think it's been productive for at least 15 minutes or so
01:15:37 <d3m1g0d-> My intention was never to be productive, my intention is to explain that "10 years of C++" developer that he is just mediocre
01:15:45 <d3m1g0d-> talking complete nonsense
01:16:29 <augur_> explaining to a person that he's mediocre is a pretty mean thing to do
01:16:32 <jle`> what did i walk into
01:16:41 <kazagistar> d3m1g0d-: well, the telling happened, but I think the effect was inverted
01:16:41 * jle` walks out of room
01:16:46 <ReinH> d3m1g0d-: Ok, mission accomplished. You can stop now.
01:18:22 <kazagistar> does having a category imply that every morphism is unique? or unique up to isomorphism?
01:18:32 <augur_> no
01:18:46 <augur_> im not sure what you mean by "every morphism" in this context actually
01:19:07 <ReinH> kazagistar: it doesn't imply that there is only one morphism between any two objects
01:19:12 <kazagistar> I think they are arrows, the terminology in this video is a little awkward
01:19:23 <augur_> yes yes i meant, did you mean what ReinH just said?
01:19:32 <augur_> ie for all f, g : A -> B, f = g
01:19:53 <augur_> or did you mean something else, like for all f, g : A -> B, f and g can be "the same" but "distinct"?
01:20:49 <kazagistar> hmm, I guess that wouldn't make sense, but are they unique "up to isomorphism", where all the morphisms between two objects are considered isomorphic?
01:20:59 <augur_> the first is false, the second is either nonsensical, or for some expansion of "the same" and "distinct", can be true
01:21:14 <augur_> kazagistar: no definitely not
01:21:28 <ReinH> kazagistar: I'm not really sure what you're asking.
01:21:38 <jle`> isn't the second one like asking if 1 is the only 1
01:21:48 <jle`> and that anything equal to 1...has to be 1
01:21:49 <augur_> there is nothing in the definitions of CT where f, g : A -> B are always "isomorphic"
01:21:59 <augur_> jle`: yes and no
01:22:09 <augur_> jle`: so thats why i said its either nonsense or possibly true
01:22:10 <ReinH> jle`: well, "equality" is a bit of a problem for CT
01:22:10 <kazagistar> I am just trying to understand this proof in the videos edwardk linked that terminal objects are unique up to isomorphism
01:22:36 <augur_> jle`: its nonsense without clarification, false for some notion of same/distinct, but true for others
01:22:39 <jle`> isomorphic to eachother
01:22:42 <jle`> augur_: yes indeed :|
01:22:46 <augur_> kazagistar: link?
01:22:51 <augur_> kazagistar: ill watch and try to help you
01:22:52 <kazagistar> https://www.youtube.com/watch?v=9vhWpOVPlIE
01:22:57 <augur_> oh
01:22:59 <augur_> kazagistar: no no
01:23:16 <augur_> kazagistar: the definition of a terminal object gives you the uniqueness of the arrow!
01:23:34 <augur_> kazagistar: T is terminal iff forall X, there exists a unique f : X -> T
01:23:42 <augur_> kazagistar: thats the _definition_ of terminality
01:24:01 <augur_> kazagistar: so if T is terminal, and T' is terminal, then we know that there is a unique arrow T -> T', and a unique arrow T' -> T
01:24:11 <augur_> kazagistar: just by the definition of terminality
01:24:35 <kazagistar> ok, so then I am trying to figure out how the uniqueness comes in on the examples from the first video
01:24:37 <augur_> jle`: if you pick "the same" to mean "computationally equivalent", but "distinct" to mean "different algorithms"
01:24:49 <jle`> it's weird either way
01:24:49 <ReinH> What unique up to isomorphism means here is that if there are two objects in a category that are initial/terminal then it can be shown that they are isomorphic
01:24:51 <augur_> jle`: ie the extensional-intensional distinction, then yes, there are different things
01:24:59 <ReinH> so they are the same object up to isomorphism
01:25:18 <augur_> ReinH: lets watch the catsters video for context
01:25:23 <kazagistar> she gives examples like "in the category of sets, sets with a single item are terminal"
01:25:24 <augur_> also kazagistar lets take this to ##categorytheory
01:25:35 <kazagistar> ok
01:25:38 <ReinH> augur_: "terminal objects are unique up to isomorphism" is a pretty natural statement
01:25:44 <augur_> ReinH: yes thats true
01:25:57 <ReinH> At one point she goes on to prove this iirc
01:26:00 <augur_> kazagistar: two ##
01:26:07 <ReinH> by showing that any two such objects must be isomorphic
01:26:57 <Abathurr> wht is the meaning of unique here?
01:26:58 <augur_> ReinH: ##categorytheory!
01:27:06 <Abathurr> My understnding is very limited.
01:27:11 <augur_> Abathurr: EVER THE PHILOSOPHER, YOU
01:27:33 <Abathurr> augur_: heh :)
01:27:38 <augur_> L(
01:27:41 <augur_> ...
01:27:42 <augur_> :)
01:39:36 <jle`> lol my connect4 bot is funny.  a lot of times it'll force a win -- have a win in 2 different ways so you can't block it --- and then when you try to block one, it doesn't win...it drags it on by taking another 3 or 4 moves of continual forcing just because it can
01:42:10 <kvanb> jle`: interesting
01:42:16 <kvanb> is it open source
01:42:19 <bergmark> that's rude
01:42:21 <kvanb> minimax>
01:42:27 <kvanb> or whatever?
01:42:29 <jle`> it's just minimax w/ alphabeta
01:42:46 <jle`> um it's 'open source' but i'm mostly playing around with it for fun right now
01:42:58 <jle`> it's supposed to be a use case of my new library
01:43:13 <nschoe> jle`, and here we are : they started developping a counscious of their own ^^
01:43:30 <grohne> in MonadError, in what way can "catchError l r" be different from "l", if I am sure that throwError is never used?
01:44:02 <grohne> can fail somehow leak into a MonadError?
01:44:20 <jle`> nschoe: yup.  today connect 4, tomorrow the world
01:44:56 <nschoe> [creepy] I'd love that ^^ [/creepy]
01:46:37 <jle`> at first it was creepy that it told me it could force a win several moves in advance.  then i just felt really sad when it told me that *i* could force a win, but i couldn't find it after looking hard >_>
01:52:05 <nschoe> jle`, ah ! So now they are actually mocking us ? ^^
01:55:00 <jle`> indeed
01:56:11 <kipras> has anyone tried to do reactive programming in database?
01:57:27 <kipras> i.e. specifying some table fields as a result of some calculation of other fields, possibly including rows in relationships
02:06:55 <xificurC> >:i read
02:07:15 <xificurC> > :i read
02:07:16 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:07:29 <hyPiRion> :i read
02:07:54 <darthdeus> is there a way to uhm "suggest" a concrete type in place of a type "parameter" in a signature when using :t ? for example if I have   λ> :t fmap Right ...   :: Functor f => f a -> f (Either a1 a) and I'd like to say "show me the type signature with the functor f being IO", can I do that somehow?
02:07:57 <xificurC> > read "123"
02:07:59 <lambdabot>  *Exception: Prelude.read: no parse
02:08:04 <darthdeus> without giving it the whole type explicitly
02:08:10 <xificurC> ^ what gives?
02:08:15 <hyPiRion> xificurC: you forgot the output type
02:08:23 <darthdeus> :t fmap Right
02:08:24 <lambdabot> Functor f => f a -> f (Either a1 a)
02:08:31 <hyPiRion> > read "123" :: Int
02:08:32 <lambdabot>  123
02:08:41 <xificurC> hyPiRion: thanks
02:08:46 <darthdeus> I'm asking this mostly like for educational purposes to be able to show how the specific types fill in one at a time
02:09:08 <darthdeus> but doing it like this seems dumb
02:09:09 <darthdeus> :t fmap Right :: IO a -> IO (Either b a)
02:09:10 <lambdabot> IO a -> IO (Either b a)
02:09:28 <darthdeus> any thoughts? :(
02:10:23 <darthdeus> like the way I've been doing this is that I just type the type, and if it doesn't error I got it correctly, but it seems it could be possible to "build this up" the other way around
02:10:44 <int3__> any threepenny-gui users here? I'm looking to map a Behavior to a changing UI element, but 'sink' only handles attributes; is it possible to have an FRP binding that replaces elements as a Behavior changes?
02:11:08 <hyPiRion> darthdeus: you could type specify some of the input values perhaps?
02:11:10 <apples> :t fmap Right `asAppliedTo` (undefined :: IO a)
02:11:11 <lambdabot> IO a -> IO (Either a1 a)
02:11:33 <hyPiRion> :t fmap (Right :: Int -> Either x Int)
02:11:34 <lambdabot> Functor f => f Int -> f (Either x Int)
02:12:13 <darthdeus> apples: huh what's asAppliedTo?
02:12:41 <jle`> asAppliedTo :: (a -> b) -> a -> (a -> b)
02:12:41 <apples> darthdeus, just const
02:12:41 <darthdeus> hyPiRion: yeah but if the type is complicated I can't sometimes partially apply it
02:12:49 <jle`> it's a specialized const
02:13:14 <darthdeus> where is that from? I'm unable to google it
02:13:41 <jle`> it's just lambdabot
02:13:51 <jle`> but you really shouldn't be googling haskell functions/operators anyway :)
02:13:54 <jle`> hoogle or hayoo
02:14:20 <darthdeus> hayoo is down and hoogle doesn't find it :P
02:14:37 <darthdeus> but this seems to work
02:14:38 <darthdeus> let asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo = undefined
02:14:44 <Javran> How can I take the head / last of a Data.Sequence?
02:14:57 * hackagebot data-named 0.5.2 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.5.2 (JakubWaszczuk)
02:15:21 <jle`> Javran: do you really need head/last?
02:15:26 <jle`> is pattern matching adequate in your case?
02:18:33 <darthdeus> jle`: thought "asAppliedTo +lambdabot" would find it but no :(
02:19:10 <jle`> yeah, it's no in any libraries, really :/
02:19:18 <jle`> which is funny because asTypeOf is in Prelude
02:19:22 <Javran> jle`: umm... maybe dropWhileR and dropWhileL is sufficient
02:29:32 <solidus-river> how do i check if someting is an element of a tuple
02:31:08 <opqdonut> solidus-river: you compare it against the elements
02:31:09 <solidus-river> nvm, i think i'm looking for lookup
02:31:13 <opqdonut> oh, a list
02:31:14 <opqdonut> yeah
02:31:17 <jle`> solidus-river: what's best depends on the situation...but this sounds like it might be a bad use case for a tuple
02:31:26 <jle`> ah
02:31:35 <opqdonut> :t elem -- solidus-river, there's also this
02:31:36 <lambdabot> Eq a => a -> [a] -> Bool
02:31:43 <solidus-river> oh wait, no, i'm not looking for lookup
02:31:58 <solidus-river> yeah it could be a bad use case i'm doing something odd
02:32:04 <solidus-river> i'm trying to check for the minimum distance between two lines
02:32:20 <solidus-river> and i'm doing that by checking the minimum distance between each permutation of point and line
02:32:25 <sleepomeno> Does anyone know a tool which automatically runs my unit tests (through the cabal interface) whenever any of my source file changes? I'd like to have that tool running in a separate terminal window during development
02:32:42 <solidus-river> and now i'm trying ot check if the resulting lines first element is a member of the first line or the second line
02:32:47 <solidus-river> *to
02:33:26 <jle`> you can probably just pattern match
02:34:06 <pjdelport> sleepomeno: There are a bunch of generic console tools like that, like rerun
02:34:52 <pjdelport> sleepomeno: I haven't tried this Haskell one, but seems like it might fit the bill: http://hackage.haskell.org/package/Commando
02:35:55 <sleepomeno> thanks!
02:37:42 <mbrock> Javran: viewl and viewr?
02:45:19 <solidus-river> can you pattern match against a newtype?
02:46:38 <supki> sleepomeno: I use guard for that
02:46:42 <supki> it's ruby though
02:47:59 <sleepomeno> supki: what does your guardfile look like?
02:50:54 <supki> sleepomeno: something like that: http://lpaste.net/107696
02:51:12 <supki> I wrote the guard-haskell plugin, which integrates with hspec
02:52:14 <jle`> solidus-river: yes
02:52:25 <jle`> > let (Sum x) = Sum 6 in x
02:52:26 <lambdabot>  6
02:56:04 <solidus-river> but you can't pattern match against a type
02:56:30 <solidus-river> hmmm
02:56:44 <solidus-river> how do you get an Ordering?
02:56:54 <solidus-river> i figured that Integer would be a valid ordering
02:57:11 <quchen> Types and values are two very different things in Haskell.
02:57:21 <quchen> Ordering is a type, you cannot have it in value land.
02:57:42 <quchen> However, Ordering has *data constructors*, and those are what you can match against.
02:57:46 <quchen> ?src Ordering
02:57:47 <lambdabot> data Ordering = LT | EQ | GT
02:57:47 <solidus-river> are you familiar with the Linear library?
02:58:04 <quchen> Oh, maybe I came in too late.
02:58:11 <solidus-river> i have [V2 Double]
02:58:19 <solidus-river> and want to use minimumBy like
02:58:35 <solidus-river> minimumBy distanceA [V2 Double]
02:58:39 <kvelicka> Hi guys. Is there a way to have a function definition for a specific version of GHC? System.Exit has die in HEAD but not in 7.8.3
02:58:41 <sleepomeno> supki: i guess this works with sandboxes out of the box? cool
02:58:56 <solidus-river> oh, no wonter distanceA expects two points
02:59:13 <quchen> kvelicka: "die" was recently added. If you need it with an older GHC version, simply re-implement it, it's a very short one.
02:59:18 <jle`> comparing
02:59:33 <jle`> oh wait no
02:59:35 <jle`> nvm
02:59:50 <quchen> solidus-river: The explicit way to do it would be "case … of LT -> ...; GT -> ....."
03:00:00 * hackagebot saferoute 0.1.1.0 - A simple type-safe routing library.  http://hackage.haskell.org/package/saferoute-0.1.1.0 (pharpend)
03:00:20 <quchen> So you make the comparison, yielding a value of type Ordering, and then you match against LT/GT/EQ.
03:01:07 <quchen> jle`: comparing wasn't so bad.
03:01:28 <solidus-river> wow this is really messy
03:01:31 <solidus-river> maybe i'm forming it wrong
03:01:35 <kvelicka> I’m aware, but is there a way to only define it for 7.8.*? So that it wouldn’t need to be removed when a new version of GHC gets released?
03:02:04 <quchen> kvelicka: Possibility a) You can hide it from the import list and *always* define it yourself
03:02:09 <quchen> b) Use CPP
03:03:00 <solidus-river> ah
03:03:12 <solidus-river> minimumBy is (a -> a -> Ordering) -> [a] -> a
03:03:14 <solidus-river> and i want
03:03:24 <solidus-river> (a -> Ordering) -> [a] -> a
03:03:37 <quchen> You can't compare one element.
03:03:42 <quchen> That's what "a -> Ordering" does.
03:03:47 <quchen> "Which is bigger, this duck?"
03:04:03 <solidus-river> yeah so i guess i gotta mutate the list then zip them back to gether and take the snd of the tuple
03:04:06 <solidus-river> but thats messy
03:04:20 <solidus-river> oh i could do a comprehension
03:04:26 <quchen> So all you want is "minimumBy distanceA [V2 Double]"?
03:04:30 <quchen> Or is there more to it
03:04:44 <solidus-river> i have a list of lines denoted by a tuple of points
03:04:46 <supki> sleepomeno: yeah, it should find the sandbox automatically
03:04:57 <solidus-river> and i want to find shortest line in the list and return it
03:05:28 <quchen> So how do you compare the lengths of two lines?
03:05:48 <solidus-river> hmm, i see the problem
03:06:09 <solidus-river> this would be cleaner with a fold
03:06:21 <quchen> Not necessarily.
03:06:24 <kvelicka> quchen: I was going to go with a) but then in 7.8 it says “System.Exit doesn’t export die”, guess b) is what I’ll have to go with
03:06:43 <quchen> kvelicka: CPP is used a lot in this context so it's not too bad
03:07:06 <eikke__> snd $ minimumBy (compare `on` fst) $ map (\e -> (lengthFunction e, e)) lines
03:07:10 <eikke__> (OTOH)
03:07:24 <quchen> kvelicka: See here for an example: http://hackage.haskell.org/package/void-0.6.1/docs/src/Data-Void.html
03:07:49 <supki> sleepomeno: it's a bit hacky though; when I finish moving to cabal repl the dependency/sandbox resolution will improve
03:07:55 <quchen> kvelicka: GLASGOW_HASKELL >= 702 stands for "at least 7.2"
03:08:07 <quchen> The zero is there in case there's a .10 release.
03:08:13 <kvelicka> quchen:
03:08:22 <kvelicka> quchen: thanks!
03:09:13 <Beginner111> Hi all, I've got some basic idea of Haskell after trying to learn it for the 4th time. Is there any project that's suitable for beginners? I'm more of a learn-by-doing type of person. Thanks in advanced.
03:10:23 <quchen> Write Hangman. Write a small chat program. Write a Brainfuck interpreter.
03:10:40 <eikke__> Beginner111: depends on your interests & domain knowledge...
03:11:39 <solidus-river> an ordering of GT means the first argument is greater or the second argument is greater
03:11:56 <solidus-river> oh, nvm i can take my queue from >= <=
03:14:44 <quchen> a `compare` b ⇒ GT -- means a is greater than b.
03:15:01 * hackagebot saferoute 0.2.0.0 - A simple type-safe routing library.  http://hackage.haskell.org/package/saferoute-0.2.0.0 (pharpend)
03:17:39 <jle`> solidus-river: why don't you try it out? :)
03:17:44 <jle`> > compare 1 2
03:17:45 <lambdabot>  LT
03:19:44 <Beginner111> Thanks
03:20:02 <Beginner111> I mostly come from a kernel level programming background.
03:20:37 <Beginner111> Doesn't seem there's lots of things to do with haskell when it comes to kernel programming. :-)
03:20:53 <Beginner111> Anyway, I will check out what you guys just said.
03:21:31 <Beginner111> Thanks eikke__ and quchen
03:21:33 <Maxdamantus> There's an OS written mostly in GHC Haskell: House.
03:22:00 <Beginner111> Cool, then I should definitely check it out
03:23:55 <Beginner111> And House even has GUI!!
03:35:02 * hackagebot themplate 1.1 - themplate  http://hackage.haskell.org/package/themplate-1.1 (BennoFuenfstueck)
03:35:36 <ipuustin_> Hi! I've a question regarding reading data from socket.
03:36:05 <ipuustin_> I can read data using Network.Socket.ByteString.recv, but sometimes a file descriptor is sent over the socket.
03:36:27 <ipuustin_> I need to read that using Network.Socket.recvFd.
03:36:44 <ipuustin_> How do I know if the message will contain a fd?
03:37:02 <ipuustin_> If I call recvFd for normal data, I get a segfault.
03:43:06 <tavivictor> hy
03:43:24 <tavivictor> there is a channel where i can learn something on freenode?
03:45:03 * hackagebot polysoup 0.5.2 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.5.2 (JakubWaszczuk)
03:46:29 <tavivictor> boring
03:49:02 <solidus-river> aside from the lack of comments, anyone have style suggestions for this? http://lpaste.net/107698
03:52:59 <ClaudiusMaximus> solidus-river: using (==) for floating point values is a bit risky
03:53:25 <solidus-river> ClaudiusMaximus: how should i mitigate that?
03:56:09 <ClaudiusMaximus> solidus-river: i sometimes define an approximate equality, something like   abs (x - y) < eps  where eps is some small value, but which eps to choose (or whether to use different eps for different scales) is a bit domain specific
03:57:32 <Maxdamantus> Does it need a special case in that function?
03:57:49 * Maxdamantus hasn't completely understood it yet.
03:58:09 <Maxdamantus> Oh, right.
03:58:24 <Maxdamantus> It's where the length of the line is 0.
03:58:56 <ClaudiusMaximus> solidus-river: also your comparator = Data.Ord.comparing fst
04:02:52 <solidus-river> ClaudiusMaximus: Maxdamantus Thanks! :)
04:04:01 <Maxdamantus> I think you might be able to safely handle the == thing by using denom == 0 instead.
04:06:07 <Maxdamantus> (to simply make sure that you don't divide by 0)
04:06:58 <Maxdamantus> Though you can still end up with infinity.
04:08:48 <Maxdamantus> > let d = 1e-323 in (d == 0, 1/d)
04:08:50 <lambdabot>  (False,Infinity)
04:09:43 <Maxdamantus> Maybe you should just say: | isInfinite scale = (start, point)
04:12:52 <solidus-river> Maxdamantus: isInfinite wont complain about divide by 0?
04:13:20 <Maxdamantus> You can divide floating points by 0.
04:13:40 <Maxdamantus> Actually, you don't need that case.
04:13:52 <Maxdamantus> it's handled by: | scale > 1 = (end, point)
04:14:41 <Maxdamantus> > 1/0
04:14:43 <lambdabot>  Infinity
04:14:51 <Maxdamantus> > isInfinite (1/0)
04:14:52 <lambdabot>  True
04:15:10 <kvanb> I wish ghc could encode inf/nan
04:15:18 <kvanb> that kind of stuff doesn't get constant floated right now :C
04:15:29 <Maxdamantus> Maybe it's better to have the condition you have, in case you decide to use rationals.
04:15:34 <Maxdamantus> > 1/0 :: Rational
04:15:36 <lambdabot>  *Exception: Ratio has zero denominator
04:16:05 <Maxdamantus> it's just superfluous with floats.
04:17:14 <Maxdamantus> kvanb: so .. what does GHC do? Things like replace `6*3` with `18`?
04:17:27 <kvanb> (6 :: Double) + 3
04:17:31 <kvanb> does not get simplified.
04:17:44 <kvanb> 6 + 3 works fine.
04:17:50 <Maxdamantus> but not using IEEE-754 semantics?
04:17:56 <kvanb> Not at all.
04:18:09 <kvanb> It's really hard to implement especially for Inf/NaN and cross compiling
04:18:12 <kvanb> so nobody has done it yet.
04:18:37 <kvanb> and it's not just a little bit hard, it's actually grandious pain in the buttocks.
04:18:51 <Maxdamantus> So (1/10 + 2/10)*10 gets rewritten as 3?
04:19:10 <kvanb> as long as those are all Int or Integer, yes.
04:19:24 <Maxdamantus> as Float or Double.
04:19:25 <oakwhiz> kvanb: aren't there some architectures that just assume that 1/0 is 0
04:19:43 <kvanb> if any are Float or Double, it's like a brick wall
04:19:44 <Maxdamantus> > (1/10 + 2/10)*10
04:19:45 <lambdabot>  3.0000000000000004
04:19:47 <kvanb> things around them don't get reduced.
04:20:02 <Maxdamantus> Doesn't seem to be in ghci at least.
04:20:21 * kvanb facepalm. I was talking about core transform not evaluation.
04:20:31 <Maxdamantus> So if it is doing some sort of constant analysis there, it's using the IEEE-754 semantics.
04:20:37 <Maxdamantus> That's what I meant.
04:20:48 <kvanb> it's not doing any sort of constant analysis there
04:20:50 <Maxdamantus> I expect (1/10 + 2/10)*10 not to be 3.
04:20:51 <kvanb> ghci doesn't do optimisations
04:21:06 <kvanb> and how could you tell if it was anyway?
04:21:25 <kvanb> fire up ghc and put that in a hs file
04:21:26 <Maxdamantus> Hopefully, you can't tell.
04:21:31 <kvanb> then compile with -ddump-simpl
04:21:33 <Maxdamantus> I did. Same result.
04:21:49 <kvanb> then view the core and you'll see the floating point operations are not fused
04:22:27 <kvanb> I don't know why you think you'll be able to tell whether its fused or not by running the program ...
04:22:52 <kvanb> /s/fused/constant folded/
04:23:40 <Maxdamantus> Because you said it doesn't use the IEEE-754 semantics, but yet still tries to do some compile-time stuff.
04:24:12 <Maxdamantus> by: 23:15:58 < kvanb> 6 + 3 works fine.
04:24:20 <Maxdamantus> You just meant it works when it's not floating point?
04:24:30 <kvanb> yeah..
04:24:31 <Maxdamantus> So `(6 + 3) :: Double` isn't counted?
04:24:40 <kvanb> I thought that was implied because the one above had explicit :: Double
04:25:19 <Maxdamantus> but in a weird place.
04:38:24 <serutsubi> What is the difference between IO Bool and Bool?
04:38:40 <Cale> serutsubi: It's much like the difference between /bin/ls and a list of files
04:39:33 <Cale> serutsubi: a value of type IO Bool is an action which if carried out, can cause your computer to do anything your computer can do, before eventually perhaps resulting in a Bool when it ends
04:39:50 <Cale> serutsubi: a Bool is either the value False or the value True.
04:39:59 <serutsubi> Okay, so I've got this: isArch = doesFileExist "/etc/pacman.conf"
04:40:13 <serutsubi> that is of type IO Bool, right?
04:40:16 <Iceland_jack> serutsubi: Right
04:40:19 <Cale> Right, so isArch, being equal to that action, has type IO Bool
04:40:41 <Iceland_jack> @ty System.Directory.doesFileExist ""
04:40:41 <serutsubi> How can I use the result in guard or if statements?
04:40:42 <lambdabot> IO Bool
04:40:43 <Cale> if you execute isArch, you'll get a Bool result which indicates if the file presently exists
04:41:12 <Cale> You first have to execute the action, which you can do as part of another IO action (and eventually main)
04:41:27 <Iceland_jack> serutsubi: You can write it like this
04:41:27 <Iceland_jack>     foo = do
04:41:27 <Iceland_jack>       exists <- isArch
04:41:30 <Iceland_jack>       if exists
04:41:32 <Cale> main = do b <- isArch; ...
04:41:33 <Iceland_jack>         then ...
04:41:36 <Iceland_jack>         else ...
04:41:39 <Cale> right
04:41:46 <serutsubi> Oh!
04:41:58 <serutsubi> is (<-) like binding impure values to a variable?
04:41:59 <Iceland_jack> serutsubi: 'isArch' has type IO Bool, 'exists' has type Bool
04:42:09 <Iceland_jack> You can think of it like that
04:42:11 <Cale> serutsubi: v <- x means "execute the action x, and call its result v"
04:42:26 <serutsubi> The result is a IO Bool though?
04:42:31 <Cale> don't think of isArch as an "impure value"
04:42:39 <Cale> isArch is *nothing at all* like a Bool
04:42:50 <Iceland_jack> serutsubi: the result of what? 'exists' in my example and 'b' in Cale
04:42:55 <Iceland_jack> serutsubi: the result of what? 'exists' in my example and 'b' in Cale's example both have type Bool
04:42:55 <Cale> It's an action which you can carry out multiple times, and it may have different results each time
04:43:15 <Cale> the result will be a Bool
04:43:23 <serutsubi> So why is it not Maybe Bool?
04:43:30 <Cale> hm?
04:43:40 <Iceland_jack> serutsubi: Maybe Bool is completely different
04:43:45 <Cale> There are only three possible defined values of type Maybe Bool
04:43:50 <serutsubi> I'm so confused now -.-
04:43:51 <Cale> Nothing, Just False, and Just True
04:44:13 <Cale> None of those have anything to do with describing the action of checking whether a file exists, like isArch does
04:44:14 <serutsubi> But isArch can only return True or False, no?
04:44:31 <Cale> isArch is the action which each time you run it, checks whether a file exists
04:44:48 <Cale> I could do
04:45:03 <Cale> main = do b <- isArch; b' <- isArch; print (b == b')
04:45:14 <Cale> and it would be possible for this program to report False
04:45:22 <Cale> if the file was suddenly deleted or created
04:46:05 <Cale> (even though it would usually report True)
04:46:08 <serutsubi> Yep, so if I understand: isArch is an action and can therefore not be a Bool or any other non-IO type?
04:46:12 <Cale> right
04:46:14 <Iceland_jack> Yes
04:46:24 <Cale> It's a description of a bunch of stuff which can be done to produce a Bool result
04:46:34 <Iceland_jack> And you need to run/execute the action 'isArch' to get the actual Bool
04:46:39 <dibblego> (and since it is not a Bool, it cannot be said that it only returns True or False)
04:46:51 <serutsubi> So the result can be bound to a variable after execution
04:47:07 <Cale> yes, that's what the notation v <- x means
04:47:15 <Cale> it means "execute x, and call its result v"
04:47:25 <serutsubi> Wow, thanks guys! I finally understand :)
04:47:45 <Iceland_jack> serutsubi: Here is how you'd read/reverse/print a line from stdin to stdout
04:47:45 <Iceland_jack>     readPrint = do
04:47:45 <Iceland_jack>       line <- getLine
04:47:45 <Iceland_jack>       putStrLn (reverse line)
04:48:00 <Iceland_jack> 'getLine' has type 'IO String', but 'line' has type 'String'
04:48:14 <Iceland_jack> So for your intents and purposes you can think of '<-' as stripping the IO off the type
04:48:28 <serutsubi> Ah, I knew it looked very familiar
04:48:33 <Cale> but don't think of it that way, because that's the non-understanding way to think of it
04:48:58 <serutsubi> What is the actual definition of (<-)?
04:49:09 <dibblego> it is syntax for a regular function call
04:49:10 <Iceland_jack> serutsubi: it basically desugars into (>>=)
04:49:16 <Cale> Well, do-notation is recursively translated away in terms of an operation called (>>=)
04:49:20 <Cale> Specifically,
04:49:21 <Iceland_jack>     (>>=) :: IO a -> (a -> IO b) -> IO b
04:49:29 <Cale> do { x } = x  -- base case with only one statement
04:49:45 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
04:49:59 <Cale> do { v <- x ; <stmts> } = x >>= (\v -> do { <stmts> })
04:50:21 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
04:50:41 <Cale> and x >> y = x >>= (\k -> y)
04:50:46 <nschoe> ah ah Cale so *well* summed up ! I wish I had this explanation when I started Haskell and when I looked into "desugaring the do-notation" for the first time !
04:51:20 <Cale> (>>) is an operation for gluing actions together one after the other
04:51:30 <Cale> (>>) :: IO a -> IO b -> IO b
04:51:50 <Cale> The resulting action executes both, and has the result of the second as its result
04:51:59 <Iceland_jack> :t putStrLn "Hello" >> putChar ' ' >> putStrLn "World!"
04:52:00 <lambdabot> IO ()
04:52:09 <Cale> But we'd also like to have a primitive way to choose what to do next based on the result of the first action
04:52:13 <Iceland_jack> :t do putStrLn "Hello"; putChar ' '; putStrLn "World!"
04:52:14 <lambdabot> IO ()
04:52:22 <Cale> (>>=) :: IO a -> (a -> IO b) -> IO b
04:52:28 <serutsubi> Sorry, I'm a bit slow. I'm trying to understand the decomposition of the do-stuff still :/
04:52:51 <Cale> x >>= f is the action which first executes x, getting some result v, and then executes f v, returning its result
04:52:51 <Iceland_jack> serutsubi: Understanding what the do-notation desugars into isn't necessary for using it but it's good to keep in mind
04:53:15 <Cale> So x >>= f is equivalent to  do { v <- x; f v }
04:53:33 <Cale> But really the latter is defined in terms of the former
04:54:13 <aschie> hy there....anybody here sells roots?
04:54:15 <Cale> and for IO, this >>= operation is internal (and its implementation of the IO type in GHC is a bit of a hack and not very enlightening)
04:54:37 <Iceland_jack> Mostly to know that there is no magic going on, at least not with the syntax itself
04:55:08 <Cale> It's possible to implement the IO type in a nonmagical way, but GHC uses some magic
04:55:42 <Cale> (just because it's easier to make efficient in terms of its own implementation of things)
04:55:50 <Iceland_jack> Yes there is a heap of magic in IO itself, but the syntax isn't magic at all but rather regular function calls as Cale demonstrated nicely
04:55:56 <Cale> right
04:56:33 <serutsubi> I believe I understand most of what you've said now, so this was very enlightening!
04:57:01 <Cale> You can imagine that values of type IO t consist of a bunch of syntax for what to do, and that the runtime system has some kind of interpreter for that syntax, and main gets interpreted. That's not how it actually works, but it *could* work like that.
04:57:29 <Iceland_jack> serutsubi: If you're interested in understanding how all this works I recommend starting with (>>) since it's quite easy to get and write with, (>>=) can be more awkward to use
04:57:50 <Cale> So *evaluating* a value of type IO t just determines what that action is, and you need some separate process to actually carry it out.
04:58:16 <Cale> You can imagine that these two separate but interleaved processes are being carried out as Haskell programs run
04:58:30 <Cale> Evaluation, which is converting expressions to values (for purposes of pattern matching)
04:58:56 <Cale> and execution, which is carrying out the instructions described by IO action values (to make things actually happen, rather than just having your CPU get hot)
05:00:03 <Cale> When people say that Haskell is pure or referentially transparent, or that it has no side effects, they're talking about evaluation.
05:00:23 <serutsubi> I've learnt more haskell now then reading for hours! Running my bad haskell-code definitely results in a hot CPU.
05:00:55 <Iceland_jack> serutsubi: It's things like that that allow you to write the following function
05:00:55 <Iceland_jack>     forever action = do
05:00:55 <Iceland_jack>       action
05:00:55 <Iceland_jack>       forever action
05:00:58 <Cale> Execution is none of those things, but it's (mostly) separate from evaluation, so that evaluation can still be reasoned about nicely.
05:01:10 <Iceland_jack> (which could be rewritten as)
05:01:10 <Iceland_jack>     forever action = action >> forever action
05:01:11 <serutsubi> Because absolutely no side effects ever wouldn't be very helpful, right?
05:01:20 <Cale> right
05:01:35 <Cale> Well, it's almost wrong to call them *side* effects at this point
05:01:41 <Cale> IO actions exist to describe effects
05:02:20 <d3m1g0d-> so, hello again guys, how has Haskell been treating you today ?
05:02:26 <Cale> and executing them (hopefully!) has the effects which are described :)
05:03:12 <keko_> I thought this was some political discussion for a moment
05:03:15 <keko_> about the death penalty
05:04:27 <Iceland_jack> Gives another meaning to a HEC (Haskell Execution Context)
05:05:43 <serutsubi> Iceland_jack: What is HEC actually?
05:06:14 <Iceland_jack> It's basically one core
05:06:23 <serutsubi> CPU core?
05:06:25 <Iceland_jack> for talking about parallel execution
05:06:25 <Iceland_jack> yes
05:06:53 <serutsubi> Are haskell-programs by default running in more than one core?
05:07:21 <serutsubi> Or does one have to do some kind of magic?
05:08:01 <d3m1g0d-> Concurrent Haskell is the name given to GHC's concurrency extension. It is enabled by default, so no special flags are required
05:08:20 <quchen> Concurrency is not an extension.
05:08:21 <Iceland_jack> serutsubi: you need to link with '-threaded' if you want it to run in parallel and add some options to the run-time system
05:08:36 <d3m1g0d-> GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the -threaded, and run it with the RTS
05:08:43 <Hodapp> Cale: when does evaluation occur, relative to execution?
05:10:25 <Cale> Hodapp: Well, with my imaginary RTS, you might imagine that the executor needs to pattern match on main to work out which actions it's built up from (and eventually work its way down to I/O primitives), and pattern matching is what makes evaluation happen.
05:10:56 <ClaudiusMaximus> serutsubi: you have to annotate your program to get it to use multiple cores, like creating threads or sparks or using other libraries for parallelism like repa - there's no automagic parallelism (apart from maybe the garbage collection, though I'm not sure if parallel gc helps with a single threaded program)
05:11:53 <Cale> In the real implementation, it's actually not too far off from that, only the IO actions contain impure functions whose evaluation causes effects, and applying the function inside main to an argument and evaluating the result will trigger all the effects to begin to happen.
05:13:38 <Cale> (and various places along the way, the function on the right of a >>= will involve pattern matching which will trigger yet more evaluation, or functions which aren't already lambdas will be applied to arguments and need to be evaluated first)
05:17:12 <serutsubi> How to I run and display the result of a shell-command. I'm pretty sure it's somewhere in System.Process, but there are so many functions to choose from.
05:17:48 <Iceland_jack> serutsubi: readProcess is good
05:18:01 <Iceland_jack> readProcess "date" [] "" I think
05:18:14 <Iceland_jack> @ty System.Process.readProcess
05:18:14 <serutsubi> Thanks, I will try it now
05:18:15 <lambdabot> FilePath -> [String] -> String -> IO String
05:18:40 <Iceland_jack> it won't give you the exit code or stderr if it fails though
05:19:49 <serutsubi> Iceland_jack: Works beautifully, is there an easy way to get the error-code? It isn't crusial for what I'm doing though
05:20:03 <Iceland_jack> @ty System.Process.readProcessWithExitCode
05:20:04 <lambdabot> FilePath -> [String] -> String -> IO (GHC.IO.Exception.ExitCode, String, String)
05:20:05 <Iceland_jack> :)
05:20:17 <serutsubi> Superb
05:20:35 <Iceland_jack> where
05:20:35 <Iceland_jack>     ExitCode = ExitSuccess | ExitFailure Int
05:55:02 <xificurC> is there something to get the bits of an Int as a list?
05:56:39 <supki> > (4 :: Int) ^.. bits
05:56:40 <lambdabot>  [False,False,True,False,False,False,False,False,False,False,False,False,Fals...
05:57:16 <vanila> showIntAtBase
05:58:15 <vanila> > showIntAtBase 2 intToDigit 12
05:58:16 <lambdabot>  <[Char] -> [Char]>
05:58:19 <vanila> > showIntAtBase 2 intToDigit 12 ""
05:58:21 <lambdabot>  "1100"
05:58:23 <Iceland_jack> > showIntAtBase 2 intToDigit 255 ""
05:58:25 <lambdabot>  "11111111"
05:59:11 <xificurC> :i showIntAtBase
05:59:20 <quchen> There is no :i in Lambdabot
05:59:49 <xificurC> hm, what module holds showIntAtBase
05:59:57 <dv-> @hoogle showIntAtBase
05:59:57 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
06:08:51 <xificurC> why is this so difficult in every language, the number is stored as bits, why can one only access it as a string?
06:09:10 <Iceland_jack> You can access it as bits
06:09:17 <Iceland_jack> using Data.Bits
06:09:41 <xificurC> Iceland_jack: yes but one by one
06:11:07 <Iceland_jack> Are you talking about the representation or how to traverse it
06:11:31 <Iceland_jack> because you can do both in most languages
06:12:40 <haasn> > binary # 255
06:12:42 <lambdabot>  "11111111"
06:13:41 <haasn> > hex # 255 -- Numeric.Lens is my favorite must-have .ghci import
06:13:42 <lambdabot>  "ff"
06:14:11 <serutsubi> How do I run a piped command with readProcess. Like (pacman -Q | wc -l)?
06:14:16 <xificurC> Iceland_jack: traversing is fine
06:14:26 <haasn> > showIntAtBase 3 id 255
06:14:28 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘GHC.Types.Char’
06:14:28 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Types.Char
06:14:28 <lambdabot>    Actual type: GHC.Types.Int -> GHC.Types.Int
06:14:42 <haasn> Oh, poo, it requires Char
06:14:49 <haasn> (Makes sense, otherwise where would - go?)
06:15:23 <xificurC> haasn: some already wrote a working example with showIntAtBase
06:15:38 <haasn> xificurC: Yes but I wanted to see if you could get it as [1,1,0,0] instead of "1100"
06:15:45 <haasn> or [True,True,False,False]
06:15:53 <xificurC> haasn: i see
06:16:20 <piezoid> > let bitsToList a = map (testBit a) . enumFromTo 0 <$> bitSizeMaybe a in bitsToList (7 :: Word8)
06:16:21 <lambdabot>  Just [True,True,True,False,False,False,False,False,False]
06:16:51 <haasn> > (4::Int) & bits %~ not
06:16:52 <plhk_> > ((5 :: Int) .&. 3) ^.. bits
06:16:55 <lambdabot>  -5
06:16:57 <lambdabot>  Ambiguous occurrence ‘.&.’
06:16:59 <lambdabot>  It could refer to either ‘Data.Bits..&.’,
06:17:01 <lambdabot>                           imported from ‘Data.Bits’ at L.hs:57:1-16
06:17:02 <xificurC> holy cow
06:17:03 <lambdabot>                        or ‘Test.QuickCheck.Property..&.’,
06:17:05 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
06:18:11 <bernalex> conal: I don't think I understand LFP. why does f(x)=x have infinite FPs but no LFP? and why doesn't f(x)=x+1 have any FPs?
06:19:07 <FireFly> @ty (#)
06:19:08 <lambdabot> parse error on input ‘)’
06:19:12 <supki> > (7 :: Int) ^.. droppingWhile not (backwards bits)
06:19:14 <lambdabot>  [True,True,True]
06:19:16 <FireFly> ._.
06:19:33 <supki> @ty ( # )
06:19:34 <lambdabot> AReview s t a b -> b -> t
06:19:51 <FireFly> Aha
06:19:55 <FireFly> Review, is that a prism thingy?
06:19:57 <vanila> <xificurC> why is this so difficult in every language, the number is stored as bits, why can one only access it as a string?
06:20:02 <vanila> xificurC, you can use bitwise ops
06:20:16 <haasn> FireFly: yeah
06:21:10 <vanila> > map (12 Data.Bits..&.) [1,2,4,8,16]
06:21:12 <haasn> FireFly: Or in general anything that can be read backwards (like a backwards getter or isomorphism)
06:21:12 <lambdabot>  [0,0,4,8,0]
06:21:25 <xificurC> vanila: I'd expect what I asked for to be a common task but you end up coding it in every language
06:21:40 <vanila> I don't know what you mean
06:22:06 <plhk_> xificurC: which task?
06:22:08 <vanila> I hope what I said helped you
06:22:47 <xificurC> vanila: yes it did, I just dont know most of the things yet :) like ^.., <$> etc
06:22:51 <vanila> https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Bits.html
06:22:58 <vanila> here are all the low level bitwise operator things
06:24:29 <vanila> ^.., <$> <-- you don't need either of these
06:24:44 <xificurC> plhk_: to get your number as a <insert language specific container, list, array, ...> of bits
06:26:03 <xificurC> vanila: no it was in other suggestions, thanks
06:28:34 <xificurC> vanila: how would you generally generate a list like you did, [1,2,4,8,...]
06:28:53 <quchen> xificurC: If you're lost among the lens infix operators, this might be helpful: https://github.com/quchen/articles/blob/master/lens-infix-operators.md
06:28:54 <vanila> you could use the bit shifting ops on [1..]
06:29:56 <vanila> > map ((12 Data.Bits..&.) . shift 1) [0..]
06:29:58 <lambdabot>  [0,0,4,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
06:30:19 <vanila> there's also
06:30:20 <bennofs> xificurC: There is also the Control.Lens.Operators module, which lists all lens operators (useful for reference)
06:30:31 <vanila> > map (testBit 12) [0..]
06:30:32 <lambdabot>  [False,False,True,True,False,False,False,False,False,False,False,False,False...
06:31:01 <vanila> you could just use showIntAtBase though
06:33:31 <xificurC> vanila: thanks, a lot to grasp
06:36:34 <kvelicka> hello again guys. what does this line of code mean? case () of
06:40:20 <kvelicka> http://lpaste.net/107704 the
06:40:28 <kvelicka> that’s the context if it helps
06:41:48 <tech2> serutsubi: I haven't done so myself, but without pulling in an external library you could probably use System.Process.createProcess - otherwise you might want to look at things like shelly where someone's done the work for you :)
06:45:22 <serutsubi> tech2: Thanks, I will try that!
06:47:28 <quchen> Is the TypeRep for `Proxy a` the same as for `a`? I'm reading the source of Data.Typeable this way, specifically
06:47:28 <quchen> typeOf :: forall a. Typeable a => a -> TypeRep
06:47:29 <quchen> typeOf _ = typeRep (Proxy :: Proxy a)
06:47:39 <supki> kvelicka: it's a pattern match on () value emulating multiway if statement
06:48:03 <supki> kvelicka: a common idiom before -XMultiWayIf extension was introduced
06:48:04 <Trudko> Hmm there are more people here than on #php, #ruby or javascript interesting
06:48:31 <kvelicka> supki: is that something that’s not used anymore then?
06:49:03 <int3__> I'm having some trouble getting my applicatives / monads in the right order. basically I have values of `n (m a)` and I need to invoke my functions with `m (n a)`, where m is a Monad and n an Applicative... is there some law that determines whether I can swap them around?
06:49:29 <int3__> to be a little more specific, I'm working with threepenny-gui and the monad is UI while the applicative is Behavior
06:50:15 <quchen> int3__: sequenceA swaps things around.
06:50:22 <quchen> :t T.sequenceA
06:50:23 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
06:50:29 <Peaker> int3__: If you have:   m (n a)    you can only swap m and n if "m" is a Traversable
06:51:07 <Peaker> int3__: otherwise, you're "escaping" the monad which is of course impossible in general
06:52:07 <int3__> Peaker: ah okay. I don't think UI and Behavior are Traversable... I'm probably trying to do something that doesn't strictly make sense then. thanks!
06:52:51 <Peaker> int3__: If you have m (n a)  and you want to process the (n a) value, you can just use "fmap" or (>>=) ?
06:53:39 <int3__> Peaker: the problem I have is the other way around -- n (m a), and I want to process (n a)
06:55:46 <piezoid> dumb question: given an Iso' a b, how do I get Iso' (a, c) (b, c) ?
06:56:13 <int3__> Peaker: does that really violate any type laws? I'm not 'escaping' the monad, I'm trying to push more stuff into it...
06:57:06 <foggy> Hello all, I'm new, looking for some help with reading input into a list of Doubles, and I can get it to work with two separate functions: f1 xs = map read xs :: [Double]; f2 xs = f1 $ words xs, but I can't figure out how to compose into one function without type errors.
06:58:13 <frerich> piezoid: 'f (Iso' a b) c = Iso' (a, c) (b, c)' ? :)
06:59:11 <int3__> :t f xs = map read (words xs)
06:59:12 <lambdabot> parse error on input ‘=’
06:59:35 <int3__> :t map read . words
06:59:37 <lambdabot> Read b => String -> [b]
06:59:54 <int3__> foggy: ^
07:06:41 <tech2> serutsubi: any luck?
07:06:49 <foggy> Is it possible that map read . words won't work in ghci but will work when compiled? I keep getting Couldn't match type `String -> [String]' with `[Char]' error
07:08:02 <Pythonfant> foggy: that sounds like you forgot to put the argument in?
07:08:54 <Pythonfant> foggy: map read . words $ "123 234" :: [Int] works for me in ghci
07:10:26 <foggy> Ok, thanks all, I was omitting the $ operator.
07:11:35 <snyp> asks (+ (100::int))
07:11:45 <snyp> why does it give me errors in ghci?
07:12:05 <snyp> @asks (+ (100::int))
07:12:06 <lambdabot> Consider it noted.
07:12:15 <snyp> umm
07:13:36 <Pythonfant> foggy: without $ it shouldn't outside of ghci aswell
07:14:19 <int3__> snyp: what errors does it give you, and what result are you expecting?
07:15:11 <snyp> int3__, it should return a MonadReader value, right?
07:15:31 <snyp> @asks (+ (100::Int))
07:15:31 <lambdabot> Consider it noted.
07:15:35 <snyp> crap
07:15:57 <snyp> No instance for (MonadReader Int m0) arising from a use of ‘it’
07:15:57 <snyp>     The type variable ‘m0’ is ambiguous
07:15:57 <snyp>     Note: there are several potential instances:
07:15:57 <snyp>       instance MonadReader r' m =>
07:15:57 <snyp>                MonadReader r' (Control.Monad.Trans.Cont.ContT r m)
07:15:58 <snyp>         -- Defined in ‘Control.Monad.Reader.Class’
07:16:55 <foggy> Pythonfant: Ok thank you. Now I just need to figure out why the $ is needed, that's confusing me. It does work though, thanks again.
07:17:16 <Pythonfant> foggy: function application binds harder than .
07:17:43 <Pythonfant> so if you don't have the $, words gets applied to the String
07:18:01 <mzero> is the person having gcc 4.8 compile problems here? Edsko?
07:18:02 <Pythonfant> so you have something like map read . ["123", "234"]
07:18:10 <edsko> mzero: yup :)
07:18:16 <Pythonfant> now look at the type of (.)
07:18:19 <Pythonfant> :t (.)
07:18:19 <mzero> I just replied to your problem on cafe
07:18:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:18:22 <serutsubi> tech2: Nope, but I haven't looked very hard yet
07:18:30 <Pythonfant> you need a function on the right side
07:18:33 <mzero> you're using ports or brew to get gcc 4.8, right?
07:18:34 <Pythonfant> but you only have a string now
07:19:01 <serutsubi> Does anyone have time to give constructive critisism of my haskell archey clone? http://lpaste.net/831173010403622912
07:19:13 <edsko> mzero: yes, but brew explicitly does not install libiconv
07:19:20 <edsko> if you ask it to, it says "we use the system one"
07:19:29 <mzero> heh - well, clearly it lies!
07:19:49 <edsko> mzero: maybe :)
07:19:55 <edsko> mzero: clang would be fine for 7.8
07:19:56 <mzero> I am curious
07:19:57 <edsko> but not for 7.4
07:20:10 <mzero> you seem to have Xcode installed, but not the command line tools
07:20:14 <edsko> hm?
07:20:21 <foggy> Ok, I think I'm getting it now. I'm still getting to know the (.) operator.
07:20:44 <mzero> This is interesting in that seems to be looking into the SDK inside Xcode, rather than /usr/lib
07:21:18 <edsko> mzero: yeah, I don't know why that is
07:21:41 <mzero> edsko: does it build if you use Xcode's gcc (which is, of course, clang) -- and the ghc-clang-wrapper?
07:21:53 <edsko> ugh
07:22:07 <serutsubi> I did correct the stuff that lpaste suggested.
07:22:10 <mzero> that should work with ghc 7.4
07:22:13 <edsko> mzero: I will try tf this fails with 4.9
07:22:36 <mzero> the odd thing is, if they really used the system iconv... it wouldn't be looking for a .so
07:22:54 <mzero> it would be happy to accept the .dylib that is there - as /that/ is what Apple ships
07:23:13 <edsko> hmmm, nope, same error with gcc 4.9
07:23:14 <edsko> dammit
07:23:14 <haasn> serutsubi: Simply for clarity I would probably combine all those type signatures and write the lines together without spacing in between
07:23:23 <haasn> serutsubi: like getUser, getHostName, getKernel, .. :: IO String
07:23:28 <edsko> mzero: I odn't understand. I have the same setup on another machine and it works just fine
07:23:30 <haasn> getUser = ... \n getHostName = ...
07:23:51 <mzero> edsko - look on the other machine and see where libiconv is and what format it is in'
07:24:05 <edsko> mzero: I compared the output of 'file' and 'otool -L' and it's precisely the same
07:24:14 <mzero> and in the same location?
07:24:17 <edsko> yup
07:24:22 <edsko> the setups are almost identical
07:24:39 <edsko> the only difference, as far as I could tell, was gcc-4.8 vs gcc-4.9, but that doesn't seem to have made a difference
07:24:45 <serutsubi> haasn: Thanks, that will look much better :)
07:24:47 <mzero> hmmm.....
07:24:59 <steffen> Has someone an Idea how I can find all keys which do not occur as values from an IntMap? (or the other way around)?
07:25:39 <int3__> snyp: I'm actually not super familiar with MonadReader, but I think you're typing `asks it` into ghci, which tries to display the result by evaluating `show (ask it)`. the type of `ask it` is not yet fixed, so it is unclear which instance of `show` you mean to invoke. on the other hand `:t ask it` works fine, since you're not trying to call `show`.
07:25:43 <mzero> now I'm at a loss.... I've seen this with brew and iconv come up more than once... I've never seen a consistent work around
07:25:57 <mzero> is there a reason to avoid clang? you want the few percent speed boost?
07:26:09 <edsko> mzero: oh, no, not about performance at all
07:26:14 <haasn> steffen: keys m \\ values m -- ?
07:26:22 <haasn> naive approach; O(n²) but still works
07:26:23 <edsko> mzero: just wanted the least painful way
07:26:27 <int3__> snyp: `ask it 1` also works, since you're fixing the type with the argument `1`.
07:26:33 <edsko> mzero: and so far building with gcc has been fine, no bother at all
07:26:34 <edsko> until now :/
07:27:31 <snyp> int3__, aah
07:27:32 <steffen> haasn: thanks, makes a lot of sense, didn't think of that, its not very efficient but I can't figure a faster way out myself at the moment so i'll take it :)
07:28:13 <haasn> steffen: A faster way could be something like filter (m `hasKey`) (values m) -- or whatever those operations are called, if they exist
07:28:15 <haasn> n log n
07:28:30 <haasn> But note the danger of ignoring constant factors; lists can be fast if you have small ones
07:29:33 <steffen> haasn: thank you very much, I'll look into that
07:29:50 <edsko> mzero: what made you think I don't have the command line tools?
07:30:06 <mzero> ah - well, once installed, the ghc-clang-wrapper is a good citizen: it gets out of the way if you switch to gcc, and does stuff for clang
07:30:51 <mzero> edsko: usually the libs are opened fom /usr/lib, not from inside the SDK in Xcode, when complining with the command line tools
07:31:22 * edsko runs xcode-select --install just to see
07:31:33 <edsko> though I would have xpected a very different kind of error
07:32:08 <mzero> it is possible you could have them installed, but have env. vars set so that the SDK is the base for includes and libs
07:32:34 <edsko> I tried building with -L/usr/lib but that didn't seem to make a difference
07:33:01 <mzero> sigh...
07:33:17 <edsko> mzero: ok, no difference, same error after xcode-select --install
07:40:23 <Peaker> int3__: if you want to process the "a" in   "m (n a)", you can do so with monadic and applicative actions from m and n, but you just won't be able to interleave the actions from both
07:40:57 <Peaker> int3__: i.e: the "m" actions outputs can be used to select which "n" actions to use on "a". But the "n" action outputs cannot be used to choose "m" actions
07:43:34 <mzero> if m is Traversable, you can use sequence from Traversable to invert the order of application
07:44:22 <mzero> ... maybe kinda sorta?
07:45:47 <frerich> Is there a nice synonym for '(==) `on`"? Everytime I use "comparing" I wish there was something like that for testing for equality, too.
07:46:16 <frerich> Hm, maybe that's actually a good name. equality.
07:46:25 <frerich> 'groupBy equality' :)
07:47:15 <frerich> Hm no, that would be groupBy (==) already.
07:47:22 <frerich> 'equalityOf' maybe.
07:48:28 <AleksejsHome> Hi, is how do I join a [IO String] with separator?
07:48:58 <mzero> You have a list of actions -- do you want to run them ?
07:49:09 <frerich> AleksejsHome: Try (intercalate ',' `fmap` myAction)
07:49:17 <mzero> intercalate "," <$> sequence list-o-string-actions
07:49:42 <ClaudiusMaximus> frerich: equating is the name i use
07:50:26 <mzero> :t intercalate "," <$> sequence [ getLine, getLine, getLine ]
07:50:27 <lambdabot> IO [Char]
07:50:37 <yorick> Couldn't match type ‘a0’ with ‘a’  because type variable ‘a’ would escape its scope <-- why is any of this happening :/
07:50:42 <mzero> you need the sequence call in there
07:50:54 <vivekrahi> Hi all!
07:50:57 <frerich> mzero: Except that you have an '[IO String]', not a 'IO [String]'
07:51:18 <mzero> AleksejsHome: "how do I join a [IO String] "
07:51:32 <vivekrahi> Can someone tell me why cabal install package fails with Connection refused error while cabal update works fine?
07:51:33 <frerich> mzero: Oops, my fault. I'd like to retract my answer and claim the opposite. :)
07:51:43 <frerich> I'd like to blame it on the heat.
07:51:58 <frerich> ClaudiusMaximus : equating sounds good, I didn't know that it's an actual word...
07:55:23 <Exio> @src zipWith
07:55:23 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:55:23 <lambdabot> zipWith _ _      _      = []
07:56:43 <frerich> ClaudiusMaximus: 'equating' seems really neat, do you think it would make sense to suggest it for inclusion into the base package (e.g. into Data.Function)? If so, do you know what process is used to decide what goes and doesn't go into the base package? Should one file a ticket of some sort?
08:10:23 * hackagebot dfrac 0.1.1.0 - A package for precise decimal arithmatic using rationals.  http://hackage.haskell.org/package/dfrac-0.1.1.0 (georgerogers42)
08:20:24 * hackagebot dfrac 0.1.1.1 - A package for precise decimal arithmatic using rationals.  http://hackage.haskell.org/package/dfrac-0.1.1.1 (georgerogers42)
08:21:39 <vanila> "arithmatic"
08:21:41 <frerich> ClaudiusMaximus : I hope you don't mind me blaming you for the suggested name in https://ghc.haskell.org/trac/ghc/ticket/9330 :-)
08:25:25 * hackagebot dfrac 0.1.1.2 - A package for precise decimal arithmatic using rationals.  http://hackage.haskell.org/package/dfrac-0.1.1.2 (georgerogers42)
08:49:37 <danilo2> Hello! I want to use DataKinds in such way, that I will use True and False on the type level functions. Could somebody tell me how can I fix this simple typeclass to make it compile? http://lpaste.net/107705
08:53:50 <supki> danilo2: well,  args -> out  does not make sense
08:53:55 <supki> :k (->)
08:53:56 <lambdabot> * -> * -> *
08:54:00 <glguy_> danilo2: http://lpaste.net/107705
08:55:33 <glguy_> Like supki is saying, the function arrow -> has kind * -> * -> *
08:55:40 <glguy_> but out has kind Bool
08:55:49 <glguy_> so you can't have it on the right side of an arrow
08:56:16 <glguy_> Proxy has kind   i -> *
08:56:32 <glguy_> so you can put a Proxy out on the right side
09:04:55 <trap_exit> at the risk of premature optimization,
09:05:04 <trap_exit> is there something like http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html#v:openFile ... but uses Text rather than Strings ?
09:05:10 <trap_exit> I'm writing a progrma whose sole job is to output a bunch of text files
09:07:13 <pseudolio> openFile doesn't have anything to do with Strings or Text.
09:07:37 <pseudolio> Unless you mean that the file path is a string.
09:08:55 <Iceland_jack> trap_exit: Are you looking for something like
09:08:56 <Iceland_jack> @ty Data.Text.IO.readFile
09:08:56 <lambdabot> FilePath -> IO Data.Text.Internal.Text
09:09:40 <trap_exit> Iceland_jack: http://hackage.haskell.org/package/text-0.7/docs/Data-Text-IO.html indeed
09:09:42 <trap_exit> Iceland_jack ++
09:09:45 <Iceland_jack> as pseudolio mentions ‘openFile’ only gives you a handle, it doesn't determine how you read the content of the file
09:09:45 <Iceland_jack> @ty System.IO.openFile
09:09:46 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
09:10:22 <Iceland_jack> You can use
09:10:23 <Iceland_jack> @ty Data.Text.IO.hGetLine
09:10:23 <Iceland_jack> and
09:10:23 <lambdabot> GHC.IO.Handle.Types.Handle -> IO Data.Text.Internal.Text
09:10:24 <Iceland_jack>  
09:10:27 <Iceland_jack> @ty System.IO.hGetLine
09:10:28 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
09:10:31 <Iceland_jack> on the same handle
09:13:40 <danilo2> supki, glguy_ : Ah, ok, thank you! :)
09:15:52 <trap_exit> Iceland_jack: as a followup, how do I get a Handle ?
09:16:08 <trap_exit> oh
09:16:09 <trap_exit> openFile
09:16:10 <trap_exit> I'm retarded
09:17:10 <Kron> > let 1 + 1 = 3 in 1 + 1
09:17:11 <lambdabot>  3
09:19:41 <AleksejsHome> is it possible to @pl multiple lines with lambdabot?
09:20:18 <AleksejsHome> i mean
09:20:30 <AleksejsHome> > do print "sdfg"; print "qwer"
09:20:31 <lambdabot>  <IO ()>
09:20:38 <AleksejsHome> @pl do print "sdfg"; print "qwer"
09:20:38 <lambdabot> (line 1, column 16):
09:20:38 <lambdabot> unexpected ';'
09:20:38 <lambdabot> expecting variable, "(", operator or end of input
09:21:00 <FireFly> @pl \x -> do x; x
09:21:00 <lambdabot> (line 1, column 11):
09:21:00 <lambdabot> unexpected ';'
09:21:00 <lambdabot> expecting variable, "(", operator or end of input
09:21:03 <Iceland_jack> You can write
09:21:03 <Iceland_jack> @pl print a >> print b
09:21:03 <lambdabot> print a >> print b
09:21:04 <FireFly> hm, ah well
09:21:11 <dwcook> I think it doesn't recognize do expressions
09:21:15 <AleksejsHome> @pl do print "sdfg" >> print "qwer"
09:21:16 <lambdabot> do print "sdfg" >> print "qwer"
09:21:19 <dwcook> So desugar it first
09:21:28 <dwcook> @undo do print "sdfg"; print "qwer"
09:21:28 <lambdabot> print "sdfg" >> print "qwer"
09:21:33 <dwcook> And you can compose the commands
09:21:36 <FireFly>  think you can chain them somehow
09:21:39 <dwcook> @. pl undo do print "sdfg"; print "qwer"
09:21:39 <lambdabot> print "sdfg" >> print "qwer"
09:21:41 <Iceland_jack> AleksejsHome: There it interprets 'do' as a function
09:21:42 <FireFly> Ah
09:21:46 <dwcook> AleksejsHome: ^
09:21:57 <FireFly> @help @@
09:21:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:22:01 <AleksejsHome> dwcook: thanks!
09:22:02 <FireFly> @hlp @
09:22:02 <lambdabot>  @@ [args].
09:22:02 <lambdabot>  @@ executes plugin invocations in its arguments, parentheses can be used.
09:22:02 <lambdabot>  The commands are right associative.
09:22:02 <lambdabot>  For example:    @@ @pl @undo code
09:22:02 <lambdabot>  is the same as: @@ (@pl (@undo code))
09:22:09 <FireFly> oops, good thing it autocorrects typos
09:27:58 <Desheng> is there a site or blog somewhere where Kmett talks about what led him to design category-extras and ideas for their uses?
09:29:38 <glguy_> Category theory led him to write it and it's deprecated now, but he has a ton of blog posts online about various things he's implemented if you search for his name
09:29:54 <glguy_> most of it has split out into smaller, more focused packages
09:30:30 * hackagebot Hsmtlib 2.8.8.8 - Haskell library for easy interaction with SMT-LIB 2 compliant solvers.  http://hackage.haskell.org/package/Hsmtlib-2.8.8.8 (roger62)
09:30:32 * hackagebot Hsmtlib 0.2.0.6 - Haskell library for easy interaction with SMT-LIB 2 compliant solvers.  http://hackage.haskell.org/package/Hsmtlib-0.2.0.6 (roger62)
09:30:38 <Desheng> ok thanks
09:41:37 <conal> bernalex: still there?
09:41:46 <bernalex> conal: yep
09:42:02 <conal> "<bernalex> conal: I don't think I understand LFP. why does f(x)=x have infinite FPs but no LFP? and why doesn't f(x)=x+1 have any FPs?"
09:42:26 <conal> bernalex: it depends on what space x is drawn from.
09:43:02 <conal> bernalex: in the spaces we use in explaining programming languages,
09:43:16 <conal> bernalex: both have least fixed points.
09:43:59 <conal> bernalex: and the first f has many other fixed points.
09:44:50 <levi> Tricky stuff.
09:46:16 <ReinH> conal: hi
09:46:32 <conal> bernalex: do you know what "least" means in this setting?
09:46:35 <conal> ReinH: hi.
09:47:02 <ReinH> bernalex: also fyi http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Least_Fixed_Point
09:47:41 <bernalex> conal: it's according to set order. but I don't think I really get it, no.
09:47:51 <bernalex> ReinH: thanks
09:49:52 <conal> bernalex: there is a set interpretation, where less-than means "includes", so that bottom is the universe (note the reversal). but i think of it as information content, so that bottom means no information.
09:51:44 <conal> the notion of "strict" then has a simple precise definition: having bottom as a fixed point. (and hence the LFP, since bottom is the least value)
09:52:30 <bernalex> conal: strict as in strict evaluation?
09:53:18 <ReinH> bernalex: strict as in f is strict if f _|_ = _|_, presumably
09:53:27 <conal> bernalex: strict as in strict functions. maybe you're thinking of "eager evaluation"
09:53:28 * fxdgear waves at nuttycom 
09:53:37 <bernalex> conal: ah. yes, I were.
09:53:46 <{AS}> Hi, what is the correct way to cite Haskell?
09:53:47 <conal> bernalex: since strictness is denotational, while evaluation is operational.
09:53:53 <bernalex> conal: right.
09:54:08 <Profpatsch> So I just learned about the record problem that I can’t have any fields named the same.
09:54:40 <bernalex> conal: so what is the implication of the insight that a strict function has bottom as LFP?
09:54:44 <Profpatsch> I tried doing it like this: https://bigmac.caelum.uberspace.de/paste/Beehive.hs.html
09:55:11 <Profpatsch> Is there any better way to do it? Do I even need record syntax for these datatypes?
09:55:40 <ReinH> bernalex: the link refers to "least defined" fixed point
09:55:46 <conal> bernalex: for one thing, it tells us that functional languages with recursion rely on there being at least on non-strict function, even is so-called "strict" languages.
09:55:59 <bernalex> ReinH: I'm semi-busy -- I pulled it up in a new tab for later.
09:56:05 <conal> ... at least *one* non-strict ...
09:56:10 <monochrom> bernalex: a consequence is that \x->x and \x->x+1 etc have least fixed point ⊥
09:56:25 <ReinH> Profpatsch: that's what is usually done, but be aware that with data Foo a = Foo { unFoo :: a } | Bar { unBar :: a } that unFoo and unBar are partial functions
09:56:38 <Profpatsch> If I don’t have record syntax, how would I document which argument is which?
09:56:47 <ReinH> Profpatsch: which means that unFoo (Bar 1) = undefined and vice versa
09:57:31 <ReinH> Profpatsch: give them more revealing types?
09:58:00 <conal> bernalex: it also suggests why it's so important to be able to define other non-strict functions.
09:58:43 <Profpatsch> ReinH: Hm, I don’t know how I would split this up even further.
09:59:35 <Profpatsch> FilterOption for example has five fields, nothing to do about it.
09:59:42 <Profpatsch> But well, maybe that’s how it is.
09:59:44 <dwcook> Profpatsch: I've sometimes seen done the creation of some type synonyms purely for the purpose of documenting types. E.g., type BeeName = Text. It has its own benefits and drawbacks
10:00:21 <Profpatsch> dwcook: Hm, that’s a way of doing it. Is there a pro/con list somewhere?
10:00:50 <dwcook> Not that I know of, but off the top of my head: The benefit would be what I just said, the drawback is you'd need to check the docs or source to know what type it really is
10:01:02 <Iceland_jack> Profpatsch: You're only creating a synonym then, it doesn't 'help' you if you swap two arguments of different type synonyms
10:01:04 <dwcook> Or else check in ghci perhaps
10:01:43 <Profpatsch> Hm, okay!
10:01:48 <Iceland_jack> But it's very lightweight, the alternative is to use 'newtype' where the compiler does help you
10:01:58 <Profpatsch> How do you do it personally?
10:02:16 <dwcook> In my current project, I just prefix the record field names like you showed
10:02:31 <dwcook> If that becomes burdensome I'll try something else
10:02:35 <Iceland_jack> yeah this is somewhat orthogonal to the record issue
10:02:43 <Iceland_jack> which will get fixed in 7.10 afaik
10:02:51 <dwcook> Iceland_jack: What, specifically, is getting fixed?
10:03:16 <Iceland_jack> OverloadedRecordSyntax
10:03:19 <Desheng> :t read
10:03:20 <lambdabot> Read a => String -> a
10:03:24 <Profpatsch> Iceland_jack: Yeah, I read about that. Then I tried the ghc option and was sad to see we are still 7.8. :)
10:03:43 <Desheng> > read "4 8 15 16 23 42" :: [Int]
10:03:44 <lambdabot>  *Exception: Prelude.read: no parse
10:03:46 <Iceland_jack> Yeah the present is not as nice as the future :)
10:03:51 <dwcook> Neat.
10:03:52 <Desheng> aw
10:03:59 <Iceland_jack> > read "[4, 8, 15, 16, 23, 42]" :: [Int]
10:04:00 <lambdabot>  [4,8,15,16,23,42]
10:04:25 <Iceland_jack> > map read (words "4 8 15 16 23 42") :: [Int]
10:04:26 <lambdabot>  [4,8,15,16,23,42]
10:04:34 <Desheng> hey thanks
10:05:57 <ReinH> Profpatsch: you can also create typeclasses for shared names, like instance hasName where name :: Text.
10:06:11 <ReinH> This has the disadvantage that name can't be used to update the record
10:06:24 <ReinH> a typeclass for a *lens*, however, lets you do both
10:07:20 <dwcook> class HasName a where name :: Lens' Text a -- something like this
10:08:14 <Profpatsch> That’s a bit overboard. :)
10:09:08 <dwcook> I actually contemplated doing exactly that, but realized I didn't (yet) have a reason to want to speak of all things that had names as a group
10:09:33 <dwcook> It's still a possibility I'm open to should the need arise
10:09:36 <ReinH> Profpatsch: I don't know about that, I use it frequently
10:14:06 <bernalex> is there a function which does "return a >> b"?
10:15:06 <joelteon> what would be the point of that?
10:15:27 <glguy_> bernalex: That's just "b"
10:15:37 <joelteon> yeah, I'm thinking `id'
10:15:44 <Iceland_jack> 'flip const'?
10:15:54 <glguy_> That "HasName" pattern is pretty common and there is even a template haskell function for automating it: http://lpaste.net/107710
10:16:20 <bernalex> Iceland_jack: yeah I guess
10:17:30 <Iceland_jack> But given the monad laws must be the same as 'b'
10:17:30 <Iceland_jack>       return a >> b
10:17:30 <Iceland_jack>     = return a >>= \_ -> b
10:17:30 <Iceland_jack>     = (\_ -> b) a
10:17:33 <Iceland_jack>     = b
10:19:04 <serutsubi> I've cleaned up my code quite a bit now, do you have any suggestions for improvement?
10:19:07 <serutsubi> http://lpaste.net/831173010403622912
10:19:31 <bernalex> wait is there seriously no "<<"? why not? is there some limitation that forbids it?
10:20:33 <Iceland_jack> serutsubi: I think it looks pretty nice :) you can use library functions for things like 'echo $...' and 'cat ...' though
10:21:17 <pseudolio> bernalex: No, it just doesn't exist.
10:21:32 <pseudolio> Also people like to argue about what its definition should be.
10:21:33 <FireFly> Hh
10:21:37 <FireFly> @ty (<<)
10:21:38 <lambdabot>     Not in scope: ‘<<’
10:21:38 <lambdabot>     Perhaps you meant one of these:
10:21:38 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
10:21:46 <FireFly> Weird, I could've sworn I've seen it..
10:21:55 <Iceland_jack> ≪_≪
10:22:01 <FireFly> I guess my mind compensated from seeing >>= <<= >> or something
10:22:09 <bernalex> pseudolio: yeah I mean flip >> works fine
10:22:21 <Iceland_jack> FireFly: I don't blame you for getting mixed up with all those operators :)
10:22:35 <pseudolio> There's (<*), but it doesn't do what I'd expect (<<) to do.
10:22:52 <bernalex> pseudolio: definition would be straightforward
10:22:56 <serutsubi> Iceland_jack: Ah, forgot to remove the echobits, I used getEnv instead. How to I do the cat bit, like opening a regular file?
10:23:00 <bernalex> pseudolio: m << k = k >>= \_ -> m
10:23:11 <bernalex> right?
10:23:11 <Iceland_jack> serutsubi: You can use something like 'readFile ...'
10:23:11 <Iceland_jack> @ty readFile
10:23:12 <lambdabot> FilePath -> IO String
10:23:18 <pseudolio> bernalex: Yes.
10:23:24 <serutsubi> Iceland_jack: Btw, are you on a *nix system?
10:23:27 <Iceland_jack> Yes
10:23:47 <serutsubi> Iceland_jack: I'm trying to get the cpu name, from /proc/cpuinfo, but there is a lot of stuff there
10:23:49 <pseudolio> bernalex: Some people think it should be m << k = m >>= \r -> k >> return r
10:23:57 <pseudolio> Which is what <* is.
10:24:01 <bernalex> pseudolio: but why
10:24:07 <serutsubi> Iceland_jack: How do I separate the forth line from the rest? Is there an easy way?
10:24:28 <pseudolio> bernalex: Because sometimes you want that function.
10:24:44 <serutsubi> Iceland_jack: I meant the fifth line
10:24:45 <bernalex> pseudolio: but that function already exists
10:24:45 <dwcook> And you'll have it once AMP goes through
10:25:05 <pseudolio> Well, I don't agree with these people. I've just heard it.
10:25:11 <pseudolio> There's no accounting for taste.
10:25:31 <Iceland_jack> serutsubi: What do you mean by separating the fifth line
10:27:02 <serutsubi> Iceland_jack: If I read the file I get a massive string. I just want to get the cpuname which is on the fifth line in that cpuinfo file
10:27:08 <bernalex> pseudolio: hmmm. wouldn't, in actuality, flip (>>) be better still?
10:27:46 <ReinH> bernalex: the issue is that the behavior of (>>) is ambiguous
10:27:54 <bernalex> ReinH: how
10:27:59 <Iceland_jack> serutsubi: If you want the 5th line you can use
10:27:59 <Iceland_jack>     do cont <- readFile "/proc/cpuinfo"
10:27:59 <Iceland_jack>        ... lines cont !! 4 ...
10:28:06 <ReinH> there are multiple inhabitants that are reasonable implementations
10:28:22 <ReinH> do you want (<*) or flip (>>)?
10:28:26 <dwcook> flip const -- ;)
10:28:32 <Iceland_jack> > lines "a\nb\nc\nd\ne\nf" !! 4
10:28:33 <lambdabot>  "e"
10:28:38 <serutsubi> Iceland_jack: Aha, thanks again
10:28:40 <bernalex> ReinH: we've just agreed that I mean the latter.
10:28:42 <Iceland_jack> No prob :)
10:28:46 <Iceland_jack> > lines "a\nb\nc\nd\ne\nf" -- for completeness
10:28:48 <lambdabot>  ["a","b","c","d","e","f"]
10:28:50 <bernalex> ReinH: the former already exists.
10:29:01 <pseudolio> The use of 'x <* y' is 'execute x, then execute y, then return the result you got from x'.
10:29:05 <bernalex> ReinH: m << k = k >>= \_ -> m
10:29:38 <ReinH> I don't think the entire haskell community has agreed on that
10:29:50 <ReinH> unless that happened just now as well ;)
10:29:52 <bernalex> ReinH: <* already exists so I don't see the point
10:29:59 <bernalex> ReinH: it did, just don't tell anyone.
10:30:04 <ReinH> bernalex: return also already exists
10:30:12 <ReinH> not all monads are applicative, currently
10:30:28 <bernalex> ReinH: what do you mean wrt return already existing?
10:30:31 <bernalex> ReinH: pure?
10:30:36 <ReinH> yes
10:30:39 * hackagebot quickcheck-property-monad 0.2.3 - quickcheck-property-monad  http://hackage.haskell.org/package/quickcheck-property-monad-0.2.3 (BennoFuenfstueck)
10:30:52 <bernalex> ReinH: hold your breath -- AMP branch will be mergde soon. :-]
10:31:06 <ReinH> I'm looking forward to it
10:31:09 <bernalex> ReinH: fwiw "but it's already dumb!" is not a good argument in software development. ;-)
10:31:18 <ReinH> touche
10:31:32 <bernalex> ReinH: however the big problem with << presently would be that every instance would need to implement it.
10:32:09 <ReinH> why? there's a default impl in terms of (>>=) as you mentioned, just like (>>)
10:32:15 <bernalex> there is?
10:32:21 <ReinH> you just gave it, didn't you?
10:32:30 <napping> I can't see (<<) being anything but flip (>>)
10:32:41 <bernalex> ReinH: but instances of Monad implement this in GHC
10:32:54 <ReinH> implement what?
10:33:04 <bernalex> (Just _) >>  k      = k; Nothing  >>  _      = Nothing -- etc
10:33:20 <ReinH> Yes, sometimes
10:33:31 <bernalex> nearly always I think
10:33:41 <bernalex> however, I see they nearly always omit =<<
10:33:42 <napping>  What does that have to do with Applicative?
10:33:44 <bernalex> so sure
10:33:55 <ReinH> but the point is that they don't need to
10:34:21 <josephle> napping: I think some people want (<<) to be like Applicative's (<*) rather than flip (>>)
10:34:26 <bernalex> ReinH: I guess. but edwardk hates me for suggesting new operators all the time, so I don't think I will do it nonetheless.
10:35:02 <bernalex> I was allowed to implement & and <$!>, that's enough I guess. :-]
10:35:11 <bernalex> maybe I'll ask him about it on IRC whenever he gets back.
10:35:20 <napping> josephle: that's a horrible idea!
10:35:21 <bernalex> I wonder
10:35:26 <bernalex> > 5 & id
10:35:28 <lambdabot>  5
10:35:33 <bernalex> neat. :-]
10:35:43 <bernalex> @info (&)
10:35:44 <lambdabot> (&)
10:35:50 <bernalex> @src (&)
10:35:50 <lambdabot> Source not found. It can only be attributed to human error.
10:36:01 <napping> Unless they'd also like to redefine m =<< f = do x <- m; f x; return x
10:36:01 <bernalex> aw. I'm guessing lambdabot is using it from lens rather than ghc.
10:36:15 <josephle> if you keep this up, haskell is going to look like a long censored expletive
10:36:19 <yorick> :t flip ($)
10:36:20 <lambdabot> b -> (b -> c) -> c
10:36:35 <yorick> :t (&)
10:36:36 <lambdabot> a -> (a -> b) -> b
10:36:56 <FireFly> You mean it doesn't already?
10:37:03 <josephle> touche
10:37:05 <napping> (<*) will work on any Monad at least as soon as any new monad could make it in
10:37:13 <bernalex> yorick: that looks like my typesig from ghc
10:37:23 <napping> as soon as a new operator, I mean
10:37:24 <bernalex> but it can be the same in lens
10:37:26 <bernalex> IDR
10:37:41 <bernalex> ghc implementation is 'x & f = f x' at least
10:37:43 <napping> FireFly: no, =<< is just a flipped >>= as you might expect
10:38:02 <FireFly> That was about Haskell looking like someone cussing
10:38:18 <FireFly> @hoogle *@?!
10:38:19 <lambdabot> Parse error:
10:38:20 <lambdabot>   *
10:38:20 <lambdabot>    ^
10:38:24 <FireFly> @hoogle (*@?!)
10:38:24 <lambdabot> No results found
10:38:26 <FireFly> :(
10:38:34 <bernalex> dibs
10:39:40 <kazagistar> @hoogle (^@!?)
10:39:40 <lambdabot> No results found
10:39:53 <Iceland_jack> @hoogle (^@?!..^$)
10:39:54 <lambdabot> No results found
10:39:55 <Iceland_jack> Hm
10:40:04 <bernalex> f *@?! a = let a = a in f a
10:40:05 <kazagistar> they dont have Control.Lens.Operators I guess?
10:40:13 <kazagistar> probably so we cant do this?
10:40:30 <bernalex> kazagistar: pointless zipWith7 is kind of fun
10:40:36 <FireFly> > (^@..)
10:40:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable Data.Monoid.Endo)
10:40:37 <lambdabot>    arising from a use of ‘M449049596217350207616831.show_M4490495962173502076...
10:40:41 <FireFly> it's the snail
10:40:47 <bernalex> lol
10:40:53 <napping> rebuilding my sandbox with --enable-split-objs took a 20MB binary down to 4.3, compared with 0.8 or so -dynamic
10:40:54 <Iceland_jack> :t (:[])
10:40:55 <lambdabot> a -> [a]
10:41:09 <Profpatsch> How do I pattern-match on Record fields?
10:41:12 <kazagistar> :t (^@!?)
10:41:12 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
10:41:12 <lambdabot> Monad m => s -> IndexedActing i m (Leftmost (i, a)) s a -> m (Maybe (i, a))
10:41:17 <kazagistar> oh got it
10:41:33 <Profpatsch> I’ve got this now, but Bee -> and Chain -> are not valid.
10:41:33 <Iceland_jack> Profpatsch: You can do
10:41:33 <Iceland_jack>     foo Person{ name = name } = ...
10:41:36 <ReinH> Profpatsch: go (Foo a b c d ... z)
10:41:40 <bernalex> to paraphrase SPJ: all Haskel programs are essentially burble burble open angle bracket dollar sign close angle bracket burble burble, or some variant thereof
10:41:44 <ReinH> or you can use record syntax
10:42:10 <bernalex> to paraphrase SPJ: all Haskell programs are essentially burble burble open angle bracket dollar sign close angle bracket burble burble, or some variant thereof
10:42:18 <bernalex> double l even.
10:42:21 <ReinH> Profpatsch: records are still regular old data types under the hood
10:42:29 <FireFly> So basically, you write what you want Haskell to do in English, and then sprinkle some symbols in-between?
10:42:40 <yorick> lhs?
10:42:55 <platz> I've thought the advocation against ($) in favor of parens was interesting, there doesn't seem wholly blessed style
10:42:58 <laadidadidaa> what about buddabang buddaboom buddabeep dollar dollar hasker doo?
10:43:03 <Profpatsch> Iceland_jack: I don’t care for the contents, I just want to see whether it’s a Bee or a Chain.
10:43:18 <Profpatsch> Do I have to use (Bee _ _ _ _) -> then?
10:43:37 <laadidadidaa> might see (Wasp_____)...
10:43:44 <Iceland_jack> You can use {}
10:43:50 <Iceland_jack>     foo Bee{} = ...
10:43:50 <Profpatsch> Ah, that’s good.
10:43:53 <Iceland_jack> Empty record update
10:44:00 <laadidadidaa> sorry guys, bit unpredicatble today, i ll let u n peace
10:44:15 <yorick> I like livescripts a b c = a(b(c))
10:44:22 <Iceland_jack> This works for things that aren't 'defined' as records like
10:44:22 <Iceland_jack>     not True{}  = False{}
10:44:22 <Iceland_jack>     not False{} = True{}
10:44:37 <Iceland_jack> Which is pointless :)
10:44:42 <eikke__> > not True{}
10:44:43 <lambdabot>  False
10:45:05 <eikke__> > succ (1{})
10:45:06 <lambdabot>  <hint>:1:8: Empty record update of: 1
10:45:13 <Iceland_jack> Doesn't work for certain literals
10:45:17 <Iceland_jack> but
10:45:17 <Iceland_jack> @ty (:){}
10:45:18 <lambdabot> [a]
10:45:21 <Profpatsch> It’s just some kind of built-in TemplateHaskell, isn’t it?
10:45:21 <Iceland_jack> :)
10:45:27 <Iceland_jack> What is?
10:45:35 <Profpatsch> All of records.
10:45:37 <Twey> I find it a bit weird that  x <* y  is  x >>= \ x' → const x' <$> y  and not  const x =<< y
10:45:40 <Iceland_jack> not really
10:45:49 * Twey scratches his head.
10:45:50 <Profpatsch> It’s just syntactic sugar.
10:45:50 <Iceland_jack> It's just a part of Haskell
10:45:53 <eikke__> @src <*
10:45:53 <lambdabot> (<*) = liftA2 const
10:46:20 <eikke__> Twey: <* isnt defined by monad functoins since it doesnt have a monad constraint, only uses applicative stuff
10:46:49 <napping> Twey: it makes a lot of sense along with <*> and <$ and such
10:46:56 <Twey> Yes, I didn't mean to imply that it was.  But that equivalence seems counterintuitive to me given the operator name.
10:47:02 <Nik05> isnt it just << ?
10:47:09 <uealwq> Has anybody done this challenge? https://icpcarchive.ecs.baylor.edu/external/63/6344.pdf
10:47:18 <napping> applicatives don't let you change which effects you run, just run several and combine results
10:47:47 <napping> so not departing from the textual order for effects makes more sense
10:47:52 <Twey> napping: Because the execution order follows that of (<*>), you mean?
10:48:02 <Nik05> hm there is an (=<<) but not a (<<)
10:48:12 <napping> well, because you can't possibly have the effect in one depend on the result of the other
10:48:51 <napping> It's basically <*> to keep both results, or <* to keep the left
10:48:56 <Nik05> well that will be fixed when monads have <*
10:49:08 <Twey> Nik05: Right, that's what triggered the discussion :þ
10:49:15 <Nik05> :)
10:49:25 <Twey> Nik05: I would expect x << y to execute y first, then x — i.e. be flip (>>)
10:49:34 <Twey> Nik05: But x <* y actually executes x first
10:49:39 <napping> I think it doesn't play so nicely with the usual associativity, but *> runs both in order and keeps the right result
10:49:59 <napping> In other words, [<]\*[>] runs both in order, and gives you some choice of results
10:50:11 * Twey nods.
10:50:36 <Twey> But that means that (<*) is definitely not a substitute for (<<), even if all monads have it.
10:50:46 <Nik05> hm
10:50:55 <ReinH> Assuming you want (<<) to be flip (>>), they are different things
10:50:58 <Nik05> (>>) is like (*>)?
10:51:01 <napping> yes, certainly
10:51:19 <Twey> & it feels like there's a matrix here of which we have only two elements of four, then
10:51:19 <ReinH> Nik05: yes
10:51:25 <napping> making (<<) anything but flip (>>) would be crazy, with the precedent set by (=<<) and (>>=)
10:51:41 <Twey> *And* it bothers me that the execution order isn't clear from the type, but I think that's a deeper concern
10:52:15 <dwcook> Hmm, wouldn't it be clear with an indexed monad?
10:52:18 <napping> switching everything over to indexed monads is a different proposal entirely
10:52:23 <Twey> Indeed :þ
10:52:30 <Twey> Hm
10:52:32 <Twey> Indexed by what?
10:53:16 <dwcook> An "initial" type
10:53:32 <napping> well, indexed by an index that can be differnent "before" and "after
10:53:52 <napping> or with a monad, maybe some somehwhat fancier GADT thing that lets the result index depend on the result
10:53:57 <napping> like whether opening a file failed or something
10:54:05 <napping> but then the type will definitely say the order
10:54:19 <napping> m i j a -> (a -> m j k b) -> m i k b
10:54:26 <napping> (for a simple parameterized one)
10:54:51 <napping> I guess f i j a -> f j k b -> f i k a for (<*)
10:55:15 <Twey> So for completeness we should really have four functions, (<.*) (<*.) (.*>) (*.>) (to coin some silly names) with all the possibilities of execution order and returned result
10:55:25 <Twey> napping: Ah!
10:55:40 * hackagebot hcltest 0.3.3 - A testing library for command line applications.  http://hackage.haskell.org/package/hcltest-0.3.3 (BennoFuenfstueck)
10:56:28 <napping> I'm not sure how to make the types entirely smooth, because a useful indexed monad probably should let you have informative results which doesn't work with the simple two-parameter form you might prefer on applicatives
10:56:36 <Twey> napping: Well, no, that's not quite right, is it?  Because… right
10:56:40 <napping> then again, applicatives tend to have a less significant order
10:57:56 <napping> and =<< is mostly to let you write a pipeline of monadic operations in the same order (or sensibly intermixed) with function composition from .
10:58:09 <Twey> Aye
10:58:17 <napping> without any threading of results, I don't see why you wouldn't just use a fresh do line or >> to put an independent later operation later
10:58:28 <Twey> (I don't like the order of (.), either :þ)
10:58:35 <eacameron> I've heard some people recommend installing GHC and then using cabal sandboxes from there (instead of Haskell Platform). Is that better?
10:59:10 <napping> eacameron: I think the issue is that the platform installs things into the global package database, and then maybe even sandboxes don't save you from trouble with those packages
10:59:44 <FireFly> Twey: good thing we have >>>
11:00:21 <Twey> FireFly: That's long :þ
11:00:27 <eacameron> napping: how do I get cabal then? download prebuild bin?
11:00:29 <eacameron> *prebuilt
11:00:36 <Iceland_jack> let (≫) = (>>>)? :)
11:00:44 <Iceland_jack> since you can't define (;)
11:00:54 <FireFly> You're just looking for confusion, aren't you?
11:00:55 * Twey would rather function application had an operator and \ x → f (g x) were written ‘g f’
11:01:00 <Twey> Iceland_jack: Haha, cute
11:01:05 <Twey> Or (») perhaps
11:01:25 <napping> eacameron: the source tarball from here is easy enough: http://www.haskell.org/cabal/download.html
11:01:33 <Iceland_jack> Twey: I've used it in personal code, it looks beautiful
11:01:35 <Twey> Oh, I'm not allowed that.  Not symbolly enough.
11:02:04 <napping> it includes a bootstrap script that fetches and builds it's few dependencies, so you don't need to get anything manually
11:02:23 <FireFly> At least use ⋙ so people don't mix it up with (>>)
11:02:25 <Twey> Could go all OCaml on it and write (|>) = flip (.)
11:02:34 <napping> Haskell Platform is probably fine until you want to install things it doesn't provide
11:02:38 <Iceland_jack> yes (|>) looks very nice
11:02:53 <napping> and then I think you could manually unregister things from the global database
11:02:55 <Iceland_jack> > (:){}
11:02:57 <lambdabot>  [*Exception: <interactive>:3:1-5: Missing field in record construction
11:03:07 * Twey blinks.
11:03:12 <FireFly> f ▷ g
11:03:14 <Iceland_jack> > (:){{--}}
11:03:15 <lambdabot>  [*Exception: <interactive>:3:1-9: Missing field in record construction
11:03:43 <Twey> That's a marvellously unhelpful error :þ
11:03:48 <Iceland_jack> Indeed :)
11:03:50 <Iceland_jack> > null (:){{--}}
11:03:51 <lambdabot>  False
11:04:34 <bennofs> > Just{}
11:04:34 <Twey> I guess it just sticks in an ‘error’
11:04:35 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
11:04:38 <FireFly> > null (:) {}
11:04:39 <lambdabot>  False
11:04:42 <FireFly> Hrm
11:04:45 <FireFly> > {}
11:04:46 <lambdabot>  <hint>:1:1: parse error on input ‘{’
11:04:54 <FireFly> I don't see how that parses
11:04:56 <Iceland_jack> It's gold for Haskell obfuscation
11:05:11 <Twey> > null (undefined : undefined) -- FireFly
11:05:11 <Iceland_jack> FireFly: You can use record update syntax for (most) constructors
11:05:12 <lambdabot>  False
11:05:29 <FireFly> ah
11:05:31 <Twey> FireFly: The positions can't be named, of course, but that just means you get a bottom in them.
11:05:34 <bernalex> Profpatsch: ReinH: "edwark says no". :-P
11:05:37 <Iceland_jack> > (){}
11:05:38 <lambdabot>  ()
11:05:43 <ReinH> FireFly: I've used xs ◃ x for snoc
11:05:46 <bennofs> > (,){}
11:05:47 <lambdabot>  (*Exception: <interactive>:3:1-5: Missing field in record construction
11:05:50 <ReinH> bernalex: ?
11:06:00 <bernalex> ReinH: to adding <<. especially as flip >>.
11:06:13 <ReinH> heh
11:06:19 <Twey> Obviously it should be (.<<)
11:06:27 <FireFly> :P
11:06:31 <ReinH> ha
11:06:32 <bernalex> we need a -_o_-
11:06:47 <FireFly> well, -_∘_- would work
11:07:03 <Twey> Underscores in operators are a no
11:07:04 <Profpatsch> Argh, I can’t seem to get the IO Monad stuff working.
11:07:07 <FireFly> oh
11:07:08 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
11:07:12 <Iceland_jack> > let (-_∘_-) = undefined in undefined
11:07:13 <lambdabot>  <hint>:1:6: Parse error in pattern: - _ ∘ _ -
11:07:23 <Twey> I'm sure there's something in Unicode, though :þ
11:07:32 <Profpatsch> Where do I have to strategically place returns here to make it work? :)
11:07:36 <Iceland_jack> Twey: Don't be evil
11:07:43 <dwcook> Profpatsch: missing return before the tuples
11:07:52 <Profpatsch> dwcook: I had that
11:07:54 <dwcook> Profpatsch: You want IO ([Bee], [Chain]), not simply  ([Bee], [Chain])
11:08:01 <bernalex> a ⁻-⁰-⁻  b = fail "⁻-⁰-⁻"
11:08:36 <bernalex> > let a ⁻-⁰-⁻  b = fail "⁻-⁰-⁻"
11:08:37 <dwcook> Profpatsch: well the other thing is if you leave in those type annotations, be careful of the precedence. If you *just* throw "return" in front, it will be wrong
11:08:38 <lambdabot>  <hint>:1:9: lexical error at character '\8304'
11:08:53 <dwcook> Profpatsch: If you want the annotations, surround what they affect in parens if it's a function argument
11:09:01 <bernalex> ⁻-⁰-⁻
11:09:03 * bernalex goes back to work
11:09:04 <dwcook> So: return (([x], []) :: ([Bee], [Chain]))
11:09:11 <Profpatsch> dwcook: I can’t leave them out, right?
11:09:18 <Twey> Profpatsch: What's the type of Bee?
11:09:29 <dwcook> Profpatsch: afaict you can
11:09:30 <Twey> (it's probably not Bee)
11:09:51 <Profpatsch> Maybe my data definitions are just bad.
11:10:18 <willbuntu> I'm attempting some of the "Algorithm" category problems on HackerRank using Haskell. The very second one asks that given an input of a number of cases to follow, do whatever the problem asks that many times. That is something I can implement in C/++ or python, but how would I in Haskell? I know recursion is probably the answer, but how should I go about it?
11:10:30 <dwcook> Hmm, yeah, something is up with either your case expression or the things involved in it
11:10:38 <Profpatsch> dwcook: It’s still saying IO is missing
11:10:40 <dwcook> Profpatsch: Show how your types are defined
11:10:41 * hackagebot ghc-events-parallel 0.4.3.1 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.4.3.1 (JostBerthold)
11:10:41 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
11:10:44 <Iceland_jack> > coveredInBees icelandJack
11:10:45 <lambdabot>  True
11:11:00 <Profpatsch> dwcook: https://bigmac.caelum.uberspace.de/paste/Beehive.hs.html
11:11:01 <dwcook> Profpatsch: What is the actual error message?
11:11:22 <dwcook> Profpatsch: There's a problem, you're trying to match multiple types in the same case expression
11:11:26 <dv-> willbuntu: replicateM_ ?
11:11:27 <Twey> Profpatsch: There's no type that x could have such that x could be either a Bee or a Chain
11:11:35 <dwcook> What Twey said
11:11:45 <Profpatsch> dwcook: https://bigmac.caelum.uberspace.de/paste/%252Ascratch%252A.html
11:12:02 <Twey> Profpatsch: Only a Bee can be a Bee, and only a Chain can be a Chain
11:12:10 <ReinH> Well, it seems like there are a few issues.
11:12:43 <Profpatsch> Oh.
11:13:00 <Profpatsch> That seems about right.
11:13:23 <efm> hi, hacker news says you guys are super friendly
11:13:29 <Twey> efm: We try
11:13:35 <efm> https://news.ycombinator.com/item?id=7161236
11:13:37 <efm> :)
11:13:47 * efm will hang out here for a whiel
11:13:48 <efm> while
11:13:54 <ReinH> efm: nope, we hate you now go away
11:13:58 <efm> ha ReinH
11:14:10 <ReinH> efm: are you new to Haskell as well?
11:14:27 <efm> ReinH: I'm a newbie.
11:14:30 <Iceland_jack> Welcome efm
11:14:31 <ReinH> Then this might be fun:
11:14:33 <ReinH> @where lyah
11:14:33 <lambdabot> http://www.learnyouahaskell.com/
11:14:43 <Iceland_jack> Yes, read LYAH
11:14:44 <kini> Is there a way to make ghc not warn me about a particular unused import?
11:14:52 <efm> thanks Iceland_jack
11:14:59 <efm> thanks ReinH
11:15:00 <Iceland_jack> lambdabot can evaluate expressions for you if you prefix them with '> '
11:15:04 <napping> kini: just one particular import, without stuff in general?
11:15:07 <Iceland_jack> > 51 - 9
11:15:08 <bernalex> efm: also http://www.seas.upenn.edu/%7Ecis194/lectures.html
11:15:08 <kini> napping: right
11:15:09 <lambdabot>  42
11:15:20 <napping> huh, not easily. Use the import I guess?
11:15:41 <glguy_> kini: import Module ()
11:15:47 <efm> thanks bernalex
11:16:13 <napping> I think _ = <something from module> might do it?
11:17:20 <willbuntu> I'm attempting some of the "Algorithm" category problems on HackerRank using Haskell. The very second one asks that given an input of a number of cases to follow, do whatever the problem asks that many times. That is something I can implement in C/++ or python, but how would I in Haskell? I know recursion is probably the answer, but how should I go about it?
11:17:58 <Iceland_jack> willbuntu: Assuming you perform the same action for each case, you basically want to repeat an action n-times
11:18:04 <byorgey> willbuntu: see 'replicate' or 'replicateM'
11:18:05 <Iceland_jack> which you do with replicateM
11:18:10 <Iceland_jack> @ty replicateM
11:18:11 <lambdabot> Monad m => Int -> m a -> m [a]
11:18:33 <napping> or replicateM_ if you don't need to keep results
11:18:37 <napping> Int -> m a -> m ()
11:18:57 <Iceland_jack> Yeah, I assumed they wanted the results from each case
11:19:01 <glguy_> or write out the recursive version and understand better how "loops" in haskell work
11:19:06 <willbuntu> Iceland_jack: I hadn't heard of replicateM_, but I thought replicate was just for making lists of numbers/characters/strings/etc.?
11:19:15 <Iceland_jack> willbuntu: that's what replicate is for
11:19:38 <Iceland_jack> replicateM is similar but for 'actions'
11:19:50 <bernalex> > replicateM 5 $ putStrLn "test"
11:19:52 <lambdabot>  <IO [()]>
11:19:58 <Iceland_jack> so if you want to read three lines you can do
11:19:58 <Iceland_jack>     replicateM 3 getLine
11:20:06 <Iceland_jack> @ty getLine
11:20:06 <lambdabot> IO String
11:20:08 <Iceland_jack> @ty replicateM 3 getLine
11:20:09 <lambdabot> IO [String]
11:20:26 <bernalex> notice
11:20:30 <bernalex> :t replicate
11:20:30 <Profpatsch> My problem is: How would you represent a JSON file built like this: {bees: [<list of bees>], chains: [<list of chains>]}
11:20:30 <lambdabot> Int -> a -> [a]
11:20:32 <bernalex> :t replicateM
11:20:33 <lambdabot> Monad m => Int -> m a -> m [a]
11:20:35 <willbuntu> Thank you, that answers my question.
11:20:45 <Iceland_jack> np
11:20:53 <napping> willbuntu: you can also combine the plain list replicate with sequence
11:20:59 <Iceland_jack> @src replicateM
11:21:00 <lambdabot> replicateM n x = sequence (replicate n x)
11:21:13 <bernalex> @src replicate
11:21:13 <lambdabot> replicate n x = take n (repeat x)
11:21:21 <Iceland_jack> turtles all the way down
11:21:27 <willbuntu> Yup.
11:21:30 <Profpatsch> data Config = [Bee] [Chain] ?
11:21:42 <willbuntu> @ty sequence
11:21:43 <lambdabot> Monad m => [m a] -> m [a]
11:21:50 <Iceland_jack> Profpatsch: You'll need a value constructor
11:21:51 <Iceland_jack>     data Config = MkConfig [Bee] [Chain]
11:22:06 <willbuntu> @src sequence
11:22:06 <lambdabot> sequence []     = return []
11:22:06 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:22:06 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:22:06 <Profpatsch> Hm.
11:22:17 <bernalex> Iceland_jack: I just tweeted right now on another reason I dislike type & value constructors sharing the namespace.
11:22:30 <glguy_> willbuntu: It would look something like this written out: http://lpaste.net/107712
11:22:32 <bernalex> that's the reason I'm not working, like I should be doing. :-P
11:22:33 <Profpatsch> Ya, it’s confusing as hell.
11:22:36 <Iceland_jack> bernalex: oh?
11:22:43 <bernalex> Iceland_jack: newbies get super confused
11:22:45 <Iceland_jack> bernalex: I'm not sure what my excuse is for not working :)
11:22:50 <bernalex> Iceland_jack: "why can't I just f (IO a) = a?"
11:23:00 <Twey> Profpatsch: http://lpaste.net/7109354499147300864
11:23:12 <Twey> Profpatsch: Your problem is that you think they're mutually exclusive, and they're not.
11:23:13 <bernalex> I have adopted SPJ's mk-prefix, and use it *always* now.
11:23:14 <Iceland_jack> bernalex: yes, I always use Foo / mkFoo in examples for newcomers
11:23:26 <bernalex> Iceland_jack: I've taken to use it everywhere now
11:23:37 <willbuntu> glguy_: Thanks
11:23:50 <bernalex> I used to think that using the same name was cute/useful sometimes. but in the end, staring at old code, it just isn't worth it.
11:23:54 <Profpatsch> Twey: Ah, I think I still have to grok the power of pattern matching. :)
11:24:03 <kini> napping, glguy: the problem is actually that it's a duplicate import in some circumstances, but not others (because the code is being included variously into something that already has the import, or something that doesn't)
11:24:12 <kini> so I actually am using the import, it's just sometimes it's a redundant import
11:24:14 <Profpatsch> But I’m trying to restructure my types first, there are some wholes.
11:24:30 <bernalex> *twitch*
11:24:33 <kini> er, sorry. I guess I literally said "unused import" - I meant "redundant"
11:24:34 <bernalex> did you mean "holes"?
11:24:46 <Profpatsch> bernalex: Whoops. :)
11:24:48 <Twey> Oh, that needs an annotation, sorry
11:24:59 <Twey> Oh, well, no, it doesn't so long as you have your top-level type.
11:25:02 <glguy_> kini: Still working on happy-1.19.4 compat?
11:25:11 <bernalex> Profpatsch: can never be to sure with terminology and the GHC type laboratory. :-]
11:25:22 <Profpatsch> bernalex: I don’t normally write hole with w, but when I do it’s because I’m thinking about haskell data types. :P
11:25:30 <Twey> Profpatsch: It's just a pair.  The tricky bit is that those two instances of ‘decodeStrict contents’ are actually doing different things, because the expected return type is different.
11:25:41 * hackagebot ghc-events-parallel 0.5.0.0 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.5.0.0 (JostBerthold)
11:26:33 <kini> glguy_: not really "still", haha - I sort of stopped caring about it for a while, since cabal wasn't rebuilding that particular file
11:26:42 <kini> but then I did a cabal clean and saw the warning again so got reminded of it
11:27:36 <kini> oh well, I guess the answer to my earlier question is basically "no", so I guess I'll just disable redundant import warnings altogether in that file and be done with it
11:27:42 <kini> not worth thinking about any longer :)
11:28:02 <kini> it's just that I see warnings and have this instinctive urge to drop everything and fix them :P
11:28:18 <kini> probably a good habit but also a bad one at the same time
11:30:42 * hackagebot ghc-events-parallel 0.5.0.1 - Library and tool for parsing .eventlog files from parallel GHC  http://hackage.haskell.org/package/ghc-events-parallel-0.5.0.1 (JostBerthold)
11:31:39 <Tjr> What is Haskell' (with the trailing ' )?
11:31:52 <kini> another way to write "haskell prime"
11:32:05 <kini> afaik that was the code name for what eventually became the Haskell 2010 standard (?)
11:32:16 <kini> (back when Haskell '98 was the latest language standard)
11:32:40 <serutsubi> Tjr: https://ghc.haskell.org/trac/haskell-prime/
11:33:09 <kini> oh, it's still going! cool, when's the next Haskell language standard coming out? :P
11:34:07 <c_wraith> There's been no real work on a new standard, as far as I know.
11:34:22 <Tjr> Is it safe to say that Haskell' is a successor to Haskell ?
11:34:36 <glguy_> Haskell Prime is the outgoing process of developing the next version of the language
11:34:44 <donri> haskell prime is not 2010, it's more like "haskell+1" or as that page says, the ongoing process of making new standards
11:34:48 <donri> also see http://en.wikipedia.org/wiki/Prime_%28symbol%29
11:35:05 <c_wraith> It's at the awkward point where people would like to try to standardize a lot of what GHC supports, but other haskell implementations don't want to have to do even more to say they support the spec.
11:35:31 <bernalex> c_wraith: Haskell pretty much *is* GHC today.
11:35:32 <donri> perhaps we need to modularize the standard, like css3 ;)
11:35:51 <c_wraith> donri: it kind of is there already.
11:36:03 <donri> is it?
11:36:07 <c_wraith> Except that most GHC extensions documentation doesn't really add up to a full spec. :)
11:36:13 <c_wraith> *extensions'
11:36:21 <bernalex> I used to loathe GHC pragmas, and try to keep to a standard.
11:36:23 <donri> yeah no ghc extensions are not standards modules
11:36:24 <bernalex> aka I was being silly
11:36:41 <bernalex> the GHC type laboratory is just incredible.
11:37:13 <Tjr> ok, so the other compilers don't have GADT and all those goodies?
11:37:14 <donri> also i was thinking larger modules. like "haskell lite" (basically '98, maybe even stripped down further) etc up to some beast including all "good" ghc extensions
11:37:25 <donri> not individual extensions as modules :)
11:37:28 <c_wraith> Tjr: take a look at what JHC supports.
11:37:32 <bernalex> Tjr: *are* there even any other compilers still active that compile haskell 2010?
11:37:51 <donri> isn't uhc currently the most relevant ghc alternative
11:37:55 <int3___> i've asked this question a couple of different times already, but here's my most specific attempt: http://lpaste.net/107713
11:38:17 <int3___> could someone take a look and tell me whether the function i'm trying to define is even possible, without poking into the internals of UI / Behavior?
11:38:50 <donri> i don't think there's any compilers at all that comply with either 2010 or 98
11:39:27 <kini> what's ghc missing to comply with 2010?
11:39:44 <byorgey> kini: it's not *missing* anything, it just doesn't quite comply =)
11:40:01 <int3___> to elaborate a little more on my question: 'sink' is the FRP counterpart to 'set'. I know how to call 'set' on monadic values, and I'm trying to figure out how to do the same with 'sink'
11:40:09 <kini> byorgey: ok, then what's buggy about ghc's 2010 support? :P
11:40:15 <byorgey> kini: https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/bugs-and-infelicities.html
11:40:17 <c_wraith> GHC allows conflicting instances in a way that the spec forbids
11:40:21 <kini> ah
11:40:21 <c_wraith> Among other things
11:40:22 <trap_exit> haskell the greatest
11:40:22 <trap_exit> to the moon!
11:40:53 <luite> it's missing an Eq superclass for Num :)
11:40:54 <Profpatsch> Okay, now I’m going crazy: https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
11:41:03 <Profpatsch> Couldn't match type ‘ByteString’ with ‘IO ByteString’
11:41:15 <c_wraith> Profpatsch: do you know what that error message means?
11:41:18 <Profpatsch> Why? There is a return.
11:41:36 <c_wraith> Profpatsch: that's irrelevant to my question.
11:41:43 <Profpatsch> It should wrap Bee into IO, since I’m in an IO monad.
11:41:54 <Profpatsch> That’s how I understand it.
11:41:57 <trap_exit> the only possible thing
11:41:59 <trap_exit> that can make haskell greater
11:42:04 <trap_exit> is if laziness / strictness was exposited in types
11:42:16 <donri> int3___: i'm not sure you can escape Behavior there, you need bind2 to return something like Behavior (UI x)
11:42:34 <c_wraith> trap_exit: I'm not convinced that's a good thing.  Look at how Idris works, for instance.
11:42:35 <Profpatsch> c_wraith: Am I wrong?
11:42:50 <int3___> donri: `sink` is supposed to be the one doing the escaping of behavior
11:42:52 <trap_exit> c_wraith: I'd love to have Idris with Haskell's library + stability
11:43:19 <c_wraith> trap_exit: the problem is laziness is too much work, so it doesn't get used when it's a win.
11:43:38 <c_wraith> trap_exit: that's why laziness only works in practice if it's the default.
11:43:47 <byorgey> Profpatsch: that code looks fine to me.  You will have to give all the code as well as the entire error message.
11:43:56 <c_wraith> Profpatsch: the code you supply doesn't generate the error.
11:43:57 <glguy_> Profpatsch: The bug is on line 3
11:44:01 <byorgey> Profpatsch: in particular the error message has more information about exactly where the error occurred.
11:44:20 <byorgey> oh, haha, no argument to B.readFile
11:44:21 <donri> int3___: also (Behavior UI Element) is ill-kinded, you want (Behavior (UI Element))
11:44:33 <int3___> donri: yeah, that was a typo haha
11:44:36 <Iceland_jack> 'GHC: Read File' — which file
11:44:40 <Iceland_jack> 'ANY!'
11:44:46 <glguy_> I demand a file!
11:45:01 <Iceland_jack> Maybe Haskell' will be smart enough :)
11:45:31 <kini> not really related, but augustss has a nice post about laziness which I read recently and would like to share: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
11:45:38 <Iceland_jack> augustss++
11:45:54 <Profpatsch> byorgey: Hm, I thought I don’t have to specify an argument, because I can do it point free.
11:46:07 <Profpatsch> But now that I think of it, maybe it doesn’t work with do
11:46:35 <ReinH> kini: nice
11:46:37 <bitemyapp> if I write and teach Haskell in my free time but never get to use it at work, does that mean I am LARPing Haskell?
11:46:40 <kini> it could work with do - if you had a monad instance for a function type
11:46:41 <ReinH> kini: I'll add to my list
11:46:47 <donri> int3___: having trouble following your paste but anyway note that when you fmap bind sink you're working with the reader monad (Functor (e ->))
11:46:47 <bitemyapp> I think it means I am LARPing.
11:46:50 <kini> (I think)
11:47:09 <Profpatsch> byorgey: Ah, now it worked.
11:47:24 <Profpatsch> So no point free in `do`, only with >>= and friends.
11:48:00 <kini> point-free style isn't a language construct, it's just a consequence of what curried functions mean
11:48:04 <ReinH> bitemyapp: lol
11:48:10 <ReinH> bitemyapp: that's hilarious
11:48:16 <kini> so it seems a little uncomfortable to me to conclude that "point-free doesn't work with do" because that's not really the issue here, is it?
11:48:21 <donri> int3___: what if you fmap set on a behavior, is that something completely different?
11:49:23 <Profpatsch> kini: You are way too correct. :P
11:49:25 <donri> int3___: fmap set :: Behavior Element -> Behavior (UI x)  -- this is what i mean about not escaping Behavior
11:49:25 <int3___> donri: I updated my paste to hopefully be a bit more clear (cut out some of the crufty details): http://lpaste.net/107713
11:49:48 <Profpatsch> kini: Of course it depends on what the syntactic sugar stands for.
11:49:49 <int3___> donri: yeah, that would happen if I fmap'ed set
11:50:05 <int3___> donri: 'sink' sort of 'consumes' the Behavior action
11:50:13 <Profpatsch> Obviously not a function that can be curried with one argument in this case.
11:50:19 <ReinH> Profpatsch: it might help to go through the motions of "undoing" some do notation
11:50:37 <kini> Profpatsch: yes, there is also the issue that do notation is syntactic sugar, but I think that's a different point
11:50:45 <int3___> donri: unlike 'set', that is
11:50:45 <ReinH> @undo do { line <- getLine; putStrLn line }
11:50:45 <lambdabot> getLine >>= \ line -> putStrLn line
11:51:07 <Profpatsch> Oh, is that a feature of Lambdabot?
11:51:13 <Profpatsch> Or generally ghc(i)?
11:51:17 <ReinH> lambdabot
11:51:18 <kini> lambdabot, I believe
11:51:38 <ReinH> so you can write that pointfree as getLine >>= putStrLn, but I don't think that's what you're talking about
11:52:07 <kini> @undo do { contents <- B.readFile ; case decodeStrict contents of { Just x -> return x ; Nothing -> error "Couldn't parse File" } }
11:52:07 <lambdabot> B.readFile >>= \ contents -> case decodeStrict contents of { Just x -> return x; Nothing -> error "Couldn't parse File"}
11:52:40 <glguy_> Profpatsch: "pointless" code isn't necessarily something to aspire to in general
11:52:44 <ReinH> pointfree, generally, lets you reason about function composition and compose functions for later application.
11:52:53 <ReinH> pointful style lets you reason about function application
11:53:14 <Profpatsch> kini: Would using (=<<) make a difference?
11:53:18 <donri> int3___: i don't see any way to do what you want, if those types are true
11:53:18 <bernalex> sometimes abstraction is good, sometimes it isn't. and as a newbie haskeller you'll have a hard time deciding which is which. :-]
11:53:29 <bernalex> newbies tend to favour abstraction. but then again, so does SPJ.
11:53:29 <kini> I guess a syntactic way to think about point-free style is that you can only eta-reduce something when it appears in the form "f x = ( ... ) x", i.e. reduce it to just "f = ( ... )"
11:53:29 <kini> but if you have "f x = ( ... (x) ... )", you can't reduce that to "f = ( ... ... )" and just pluck the x out from the middle of the expression
11:53:33 <Profpatsch> bernalex: Yeah, in this case probably not.
11:53:40 <vanila> you can always eta expand point free code
11:53:47 <vanila> it's not easy to go back the other way
11:53:57 <int3___> donri: yeah, I guess I can't do it. thanks for having a look!
11:54:15 <bernalex> I assume you by eta expand mean eta-abstract? then yes that is an important point.
11:54:32 <kini> I've heard it called "eta expansion" as well
11:54:33 <donri> int3___: now if you have something more like, sink :: Behavior x -> UI x, you could compose that with "join" to get Behavior (UI x) -> UI x
11:54:35 <Profpatsch> So only use it for stuff that naturally works with partial application.
11:54:39 <vanila> bernalex, f . g . h eta-expands to \x -> f (g (h x))
11:54:51 <bernalex> vanila: I know how eta-abstraction works.
11:55:08 <vanila> I was addressing <bernalex> I assume you by eta expand mean eta-abstract? then yes that is an important point.
11:55:23 <bernalex> I don't see how. but moving on.
11:55:50 <ReinH> eta abstraction and eta expansion are both used
11:56:03 <bernalex> eta-reduced code is fantastic for making composition & partial application obvious. eta-abstracted code is nice and easy to figure out.
11:56:08 <ReinH> e.g., http://mlton.org/EtaExpansion
11:56:26 <bernalex> for a newbie add a b = a+b is a lot more friendly than add = (+)
11:56:37 <ReinH> bernalex: yep :) pointfree style is good for reasoning about composition; pointful style is good for reasoning about application
11:56:43 <jfischoff> Is there a library that lets you validate json, without building an intermediate data structure like Data.Aeson.Value?
11:56:56 <ReinH> reasoning about application seems to be easier at first
11:57:14 <bernalex> ReinH: which is why spj likes abstraction and edwardk likes reduction. :-P
11:57:19 <bernalex> see GHC v. Lens
11:57:21 <ReinH> bernalex: :)
11:57:29 <c_wraith> jfischoff: Does Aeson *really* build the intermediate structure, or is that optimized out?
11:57:30 <ReinH> bernalex: both are valid
11:57:47 <bernalex> ReinH: GHC is a lot about application, lens is a lot about abstraction. makes sense. :-]
11:57:51 <ReinH> bernalex: indeed
11:58:00 <bernalex> I would recommend newbies to not care about eta-reduction at all
11:58:06 <ReinH> bernalex: I just like that way of thinking about the two, which I learned from Bird
11:58:18 <bernalex> it comes naturally somewhere around the time they understand that "wow currying is amazing".
11:58:19 <jfischoff> c_wraith: it definitely builds it, and then I think the json validation libraries use the aeson Value type to perform validation
11:58:48 <bernalex> ReinH: still haven't learned bird or bird&wadler! have ordered it though, so it should be at my office when I get south in a month or so.
11:58:54 <bernalex> s/learned/read
11:59:08 <jfischoff> c_wraith: I would like to validate the ByteString, and then if it passes, send the ByteString to a data store. The Value type is hopefully not needed
11:59:10 <ReinH> bernalex: as a counterpoint, I found Bird's stuff relatively early on and the compositional style was a big deal for me
11:59:11 <int3___> donri: shouldn't composing your sink with join give UI (Behavior x) -> UI x?
11:59:33 <bernalex> ReinH: i come from C and C-ish stuff, so for me eta-abstracted code was a lot easier to read at first.
11:59:44 <ReinH> bernalex: he mentions it in http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X
12:00:03 <vanila> bernalex, the correct term is eta-expanded, no one says eta-abstracted
12:00:03 <ReinH> (pointful/pointfree reasoning)
12:00:07 <bernalex> ReinH: now, my company has its own prelude with .: etc :-P
12:00:07 <jfischoff> c_wraith: what I want is optimized parser combinators I think
12:00:14 <ReinH> vanila: the Haskell wiki says eta-abstracted
12:00:18 <ReinH> So that's not "no one"
12:00:26 <bernalex> vanila: eta-abstracted is very common. I've never heard anyone say beta-expanded, for instance.
12:00:33 <donri> int3___: don't think so?
12:00:43 <bernalex> nor aplha-expanded
12:00:56 <bernalex> alpha
12:01:04 <Profpatsch> So in the end it looked like this: https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html :)
12:01:36 <pseudolio> I've never heard anyone but you say "eta abstracted".
12:01:43 <donri> int3___: join . (sink :: Behavior (UI x) -> UI (UI x))  -- you follow?
12:01:49 <Profpatsch> I hope that one day I will be able to write that down without thinking about it. :)
12:02:20 <int3___> donri: right, got it now. thanks
12:02:35 <bernalex> pseudolio: I think I've seen eta-expanded somewhere, but eta-abstracted is what I've seen everywhere I can think of. and it makes sense since, again, I've literally never seen/heard anyone say beta-expanded or alpha-expanded. :-]
12:02:51 <byorgey> bernalex: no one says beta-expanded or alpha-expanded because they are not expansions.
12:02:56 <ReinH> http://www.haskell.org/haskellwiki/Eta_conversion
12:03:02 <pseudolio> Alpha is neither an expansion nor a reduction.
12:03:13 <pseudolio> Beta is typically a reduction.
12:03:31 <pseudolio> Beta expansion would be factoring out common subexpressions into an applied lambda.
12:04:19 <bernalex> hoops I meant lambda not alpha. no idea how I brainfarted that. :-]
12:04:54 <pseudolio> Lambda is not the name of an equivalence of terms.
12:04:59 <bernalex> alpha is just a conversion either way afaik
12:05:03 <davidfetter> you're still in the same alphabet, for what it's worth
12:05:08 <bernalex> davidfetter: :-]
12:05:33 <bernalex> pseudolio: sure that's a fair point
12:06:18 <bernalex> but there's lambda-abstraction & beta-abstraction, so to me eta-abstraction always made sense & I never questioned it. :-]
12:06:30 <pseudolio> No, there is no "beta abstraction".
12:06:31 <Denommus> I have a simple game made in helm that is rising the memory use too fast
12:06:36 <bernalex> pseudolio: sure there is
12:06:40 <Denommus> is there a way to call the garbage collector every step?
12:07:03 <bernalex> pseudolio: it's converting an exp to an application of lambda abstraction to an argument expression
12:07:22 <pseudolio> Who uses this terminology?
12:07:24 <vanila> there are lambda abstractions, e.g. \x -> m
12:07:37 <bernalex> pseudolio: probably Church, IDK :-]
12:07:42 <vanila> it's also just called an abstraction
12:07:56 <bernalex> pseudolio: http://dictionary.reference.com/browse/beta+abstraction first result when I searched for it
12:08:19 <vanila> but alpha,beta,eta are reductions (generally used to form equivalence relations)
12:08:23 <bernalex> and some PDFs on lambda calculus, as expected. :_]
12:08:29 <ReinH> As conclusive evidence, I would like to present the fact that "eta expansion" has twice as many google search results as "eta abstraction"
12:08:32 <bernalex> vanila: never heard "alpha reduction"
12:08:35 <ReinH> I believe this discussion is now over.
12:08:40 <ReinH> ;)
12:08:43 <bernalex> vanila: it's just a conversion
12:08:48 <bernalex> from what I learned
12:09:04 <bernalex> ReinH: I'm not objecting to the term "eta-expansion" at all. :-]
12:09:25 <ReinH> bernalex: also "twice as many" is not a very big margin
12:10:01 <ReinH> it's not a preponderance, which is incidentally one of my favorite words
12:10:02 <bernalex> ReinH: I'll continue to write eta-abstraction at least. :-]
12:10:33 <MP2E> hmm getting a type error that doesn't seem right to me
12:10:34 <ReinH> bernalex: you keep fixing those google search results ;)
12:10:35 <MP2E> http://lpaste.net/107716
12:10:39 <bernalex> ReinH: I like a related-ish word -- plethora. mostly because it's often used wrongly. :-]
12:11:55 <ReinH> MP2E: well, is it an instance of Integral?
12:12:33 <MP2E> oh crap, it's not as of 2.7.6
12:12:37 <MP2E> but it was in 2.7.5
12:12:46 <MP2E> huh. Well at least I know what the issue is, thanks :P
12:14:30 <ReinH> MP2E: :)
12:15:18 <ReinH> MP2E: I like to play a game where I pretend that GHC is smarter than me and I just assume it's right. ;)
12:16:13 <bernalex> ReinH: "I do my best to confuse GHC and it just laughs in my face. It hasn't even skipped a beat yet."
12:16:21 <ReinH> Also, "pretend"
12:16:27 <bernalex> said by the guy who wrote http://izbicki.me/blog/lens-you-an-applicative-for-great-haskell lol
12:16:38 <ReinH> heh
12:21:24 <brisbin> is it normal / ok / a good idea to add modules to basic and existing namespaces? i have an app that loads environment variables from .env (port of the dotenv gem) and i'd like the logic to live in System.Environment.{Parse,Load}. wanted to check before pushing to hackage
12:23:05 <bernalex> brisbin: I would frown but not die if I saw this.
12:23:32 <Denommus> does anyone use interactive-haskell-mode of Emacs with cabal?
12:23:46 <brisbin> bernalex: you think i should make up my own top-level for this specific library?
12:24:07 <Denommus> I don't understand how to use C-c C-l to load the dependency modules
12:24:17 <bernalex> brisbin: that's what I would do. but I'm not very experienced, so I think you should get another opinion too.
12:27:07 <brisbin> bernalex: looking through http://www.reddit.com/r/haskell/comments/1qrilm/packages_and_namespaces_naming_convention/ now, i think you're approach is winning
12:27:13 <brisbin> your*
12:27:32 <bernalex> brisbin: nice to know my tastebuds are working.
12:33:47 <Noitanigami> Are there any examples of loading framed data (video) other than HopenCV?
12:34:11 <Noitanigami> I am unable to get HopenCV to install, making it very difficult to trace the functions
12:35:48 * hackagebot load-env 0.0.1 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.0.1 (PatrickBrisbin)
12:44:03 <arielb1> does persistent-postgresql have a connection timeout?
12:44:11 <serutsubi> Is it possible to rewrite this not using the infix form? "map (`isInfixOf` x) ["strings", "for", "checking", "  "]"
12:44:49 <arielb1> `isInfixOf` x ~ flip isInfixOf x
12:44:54 <eikke__> serutsubi: flip
12:44:56 <bernalex> serutsubi: sure. use flip.
12:45:06 <bernalex> hm. a tad bit late there. :-]
12:45:17 <serutsubi> I've never heard of it, thanks
12:45:23 <bernalex> :t flip
12:45:23 <lambdabot> (a -> b -> c) -> b -> a -> c
12:45:48 <Iceland_jack> or
12:45:48 <Iceland_jack>     [ isInfixOf str x | str <- ["strings", "for", "checking", "  "] ]
12:45:48 <Iceland_jack> or
12:45:48 <Iceland_jack>     map (\str -> isInfixOf str x) ["strings", "for", "checking", "  "]
12:45:52 <bernalex> > (/) 4 2
12:45:53 <lambdabot>  2.0
12:45:54 <bernalex> > flip (/) 4 2
12:45:56 <lambdabot>  0.5
12:46:06 <Iceland_jack> > flip take "hello" 10
12:46:08 <lambdabot>  "hello"
12:46:13 <Iceland_jack> > (`take` "hello") 2
12:46:15 <lambdabot>  "he"
12:46:27 <donri> > 2 `take` "hello"
12:46:28 <lambdabot>  "he"
12:46:31 <bernalex> I don't like the lambda abstraction
12:46:37 <bernalex> but the list comprehension is nice
12:46:52 <Iceland_jack> The lambda abstraction is the only non-idiomatic one I'd say
12:46:55 <bernalex> anyway, serutsubi what's wrong with infix? it's cute I think. :-]
12:47:01 <serutsubi> I actually love to use lambdas a bit too much :/
12:47:15 <bernalex> I hated infix so much when I started haskell. C-damaged brain. :-]
12:47:26 <bernalex> also backticks require me to use the shift key on my layout :-P
12:47:29 <serutsubi> bernalex: Writing lots of bash-scripts have made me hate these ` with passion :(
12:47:30 <Iceland_jack> serutsubi: Well for simple things like
12:47:30 <Iceland_jack>     (\a -> a + 5)
12:47:30 <Iceland_jack> it's much nicer to write
12:47:30 <Iceland_jack>     (+ 5)
12:47:36 <arielb1> where does persistent-postgresql store a connection timeout?
12:47:46 <bernalex> Iceland_jack: sure, I was asking specific to the given example
12:47:56 <bernalex> oh
12:47:57 <jfeltz> is this a correct pre-proc for ghc 7.8.2? #if __GLASGOW_HASKELL__==782 ... #else ... #endif ?
12:48:08 <Iceland_jack> bernalex: oh it was meant for serutsubi
12:48:15 <bernalex> Iceland_jack: I got confused by serutsubi highlighting me. I read it as *you* highlighted me. then I misread what you wrote as well. >_<
12:48:21 <Iceland_jack> no prob!
12:48:28 <bernalex> serutsubi: don't use backticks in your bash!
12:48:34 <bernalex> serutsubi: but in haskell they're cute :-]
12:48:35 <Iceland_jack> Yes! Use $(...)!
12:48:42 <jfeltz> nevermind, i forgot I can github search this crap as well :P
12:48:56 <serutsubi> I always use $() in bash
12:48:57 <Iceland_jack> Maybe Haskell should use that instead of for TH
12:48:57 <Iceland_jack>     foo $(isInfixOf) bar
12:48:57 <Iceland_jack> (yuck)
12:49:01 <bernalex> $(..) nests and are much more easy to spot, & easier to syntax highlight. :-]
12:49:28 <bernalex> Iceland_jack: I don't think nesting should be a problem for haskell infix operators, I hope :-P
12:49:43 <serutsubi> So, there is no reason not to use them I guess. Other then my obsessive brain thinking I'm writing horrible bash
12:49:45 <Iceland_jack> I hope so too!
12:49:58 <Iceland_jack> That would be horrible
12:49:58 <Iceland_jack>     foo `flip take` bar
12:50:18 <bernalex> BTW, speaking of operators. what are operators in haskell? is the term only used for infix application of functions, or does it have a deeper meaning?
12:50:30 <donri> jfeltz: 708 and you usually want >=
12:50:30 <bernalex> sometimes I see " " mentioned as "the function application operator"
12:51:25 <monochrom> "operator" is a name coming from inferior programming languages where infix symbolic function names are built-in, alphabetic prefix function names are user-defined.
12:51:27 <joelteon> case (foo of)
12:51:30 <Iceland_jack> bernalex: Either an operator symbol like / or an accented ordinary function
12:51:55 <serutsubi> Also, is isInfixOf the best way to search through a long string looking for some string inside the long one?
12:52:17 <bernalex> Iceland_jack: isn't '/' also just an infix function at its heart?
12:52:26 <monochrom> yes
12:52:33 <jle`> serutsubi: presumably if your string is long, you'd be using text
12:52:35 <Iceland_jack> Sure, it only has some different syntactic rules
12:52:36 <monochrom> in SML and Haskell the bikeshed vanishes
12:52:39 <jle`> unless it's a stream
12:52:42 <donri> serutsubi: if you really need to work with a String, then yeah
12:52:43 <bernalex> right so " " being a function application operator is just rubbish?
12:52:44 <dwcook> Haskell isn't completely devoid of special infix syntax. :: for example.
12:52:55 <hughfdjackson> I ran into a bit of a wall with elm - in which (because there was no `bind` on a signal) there was no way to react to a signal by, say, aggregating the results of several http calls
12:53:07 <hughfdjackson> i take it this restriction still applies to arrowised + applicative FRP in haskell
12:53:10 <hughfdjackson> ?
12:53:25 <monochrom> > length"xxx"
12:53:26 <Iceland_jack> bernalex: You *can* view " " as being an operator, but it isn't at all
12:53:26 <lambdabot>  3
12:53:31 <serutsubi> jle`: It's not that long, maybe standard-length 20-40 lines
12:53:42 <monochrom> length"xxx" shows that you don't even have a " " operator
12:53:56 <Iceland_jack> Otherwise you could do 'f ` ` x' to mean 'f x'
12:54:03 <bernalex> Iceland_jack: right I see
12:54:20 <dwcook> hughfdjackson: Applicative lest you aggregate a bunch of results, just doesn't let you choose what to do next based on them
12:54:21 <bernalex> Iceland_jack: f $ x would have three operators by that terminology lol
12:54:22 <jle`> bernalex: i think it's mostly used off-hand as a sort of 'neat way to look at things' things
12:54:23 <dwcook> lets*
12:54:31 <Iceland_jack> monochrom: Maybe 'f<literal>' is sugar for 'f <literal>' using " " ;)
12:54:36 <jfeltz> donri: thanks, that seems to make things a little more difficult, as there are apparent GHC API changes between 7.82, and 7.8.3; that's the way it goes I guess?
12:54:38 <dwcook> hughfdjackson: Look at liftA2 (,) for example
12:54:40 <bernalex> "then we use the function application operator to apply the function application operator to the function application operator"
12:54:41 <monochrom> ha
12:54:48 <bernalex> jle`: yeah it's a simplification
12:54:52 <hughfdjackson> dwcook: ah - so i could choose to take the current value of ALL the signals as the result of the signal call..
12:55:01 <Iceland_jack> But yeah, there are two types of operators in Haskell and " " is neither
12:55:03 <hughfdjackson> :p butchered what i meant to say there, i think - but i hope you see my reasoning
12:55:19 <dwcook> hughfdjackson: afaict, though I haven't messed with FRP at all, I'm just telling you about what's possible with Applicative
12:55:28 <hughfdjackson> aha :)
12:55:36 <Iceland_jack> should write "␣" and (␣) if it were one
12:56:02 <monochrom> the grammar rule is simply fexp → [fexp] aexp. this is past tokenization. space is just there for tokenization.
12:56:14 <monochrom> (section 3.3)
12:56:22 <Iceland_jack> I wasn't arguing it seriously
12:57:46 <jle`> perhaps the "application operator" is abbutal
12:57:47 <serutsubi> What is the standard way of implementing a dictionary? I'm guessing touples
12:58:07 <jle`> serutsubi: well if we need a dictionary we usually use Data.Map or something like that
12:58:16 <monochrom> in the context of haskell tutorials, "the application operator" is probably figure of speech.
12:58:24 <jxf> Is the fact that "[-3..0] ⇒ [-3, -2, -1, 0]", but "[-6..-3] ⇒'not in scope' error" surprising?
12:58:38 <hughfdjackson> jxf: jenn schiffer send ya? :p
12:58:45 <arielb1> anyone here that understands persistent-postgresql?
12:58:54 <jxf> hughfdjackson: ?
12:58:59 <jxf> hughfdjackson: O
12:59:04 <Iceland_jack> jxf: because it interprets it as a module qualifiacation
12:59:05 <jxf> hughfdjackson: I'm doing a Haskell tutorial
12:59:06 <bernalex> monochrom: confusing since we actually have multiple application operators, $, $! and & at least
12:59:13 <Iceland_jack> > [-6..-3]
12:59:13 <augur_> aristid: beep
12:59:14 <lambdabot>  Not in scope: ‘..-’
12:59:14 <lambdabot>  Perhaps you meant ‘...’ (imported from Control.Lens)
12:59:15 <Iceland_jack> > [-6..(-3)]
12:59:16 <lambdabot>  [-6,-5,-4,-3]
12:59:16 <monochrom> jxf: [-6 .. -3]
12:59:19 <donri> jfeltz: really? well you can have cabal pass options to cpp depending on the exact ghc version
12:59:20 <hughfdjackson> jxf: ah - okay :D it's just there was an article about that recently
12:59:34 <jle`> jxf: slightly, but i don't expect any sort of clarity to come from not using .. in ranges
12:59:44 <jle`> er, as in, with spaces
13:00:06 <jxf> jle`: as in, stylistically, one should always use spaces?
13:00:21 <jxf> (to avoid the aforementioned Surprising Thing)
13:00:22 <Iceland_jack> jxf: it's perfectly fine to write something like [1..n]
13:00:27 <jfeltz> donri: ah, I'll look into that
13:00:30 <monochrom> you can define operators. you can call your operator "..-". therefore "..-" cannot be parsed as token ".." then token "-"
13:00:44 <jxf> monochrom: gotcha
13:00:48 <arielb1> let (..-) = (+) in [-2..-3]
13:00:55 <arielb1> ghcibot: let (..-) = (+) in [-2..-3]
13:01:02 <donri> jfeltz: uh or maybe i'm lying
13:01:23 <arielb1> lambdabot: let (..-) = (+) in [-2..-3]
13:01:59 <Iceland_jack> > let (..-) = (+) in [-2..-3]
13:02:01 <lambdabot>  [-5]
13:02:16 <donri> jfeltz: oh yeah you can do this with cabal: #if MIN_VERSION_base(x,y,z) assuming they ship with different versions of base
13:02:37 <donri> jfeltz: although if the problem is the ghc api that means you're linking ghc as a library so you should have MIN_VERSION_ghc
13:03:16 <jfeltz> donri: nice
13:03:36 <jxf> hughfdjackson: can you link me to the article you were talking about? I wouldn't mind reading more about it
13:04:10 <donri> jfeltz: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
13:04:25 <trap_exit> since show is slow, what should I use to convert Int -> Text?
13:04:28 <trap_exit> I want the fucking fastest Int -> Text converter
13:04:33 <trap_exit> s/fucking/friendly/
13:04:47 <trap_exit> I want the friendly fastest Int -> Text converter; I don't want to use Show
13:05:08 <donri> trap_exit: text-format
13:05:14 <trap_exit> http://www.haskell.org/hoogle/?hoogle=Int+-%3E+Text is not giving me what I want
13:05:14 <trap_exit> hmm
13:05:28 <trap_exit> whoa
13:05:40 <trap_exit> is this like a type-safe variant of fprintf("%d ... ", ... ) ?
13:05:50 * hackagebot edentv 4.4.0 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.4.0 (JostBerthold)
13:06:04 <trap_exit> how do I read this documentation: https://hackage.haskell.org/package/text-format
13:06:22 <donri> trap_exit: you may ignore all the formatting stuff, focus on .Buildable
13:06:24 <trap_exit> whoa, this is written by Brian O Sullivan
13:06:25 <trap_exit> author of RWH
13:06:31 <donri> author of text too :P
13:06:35 <Fuuzetsu> bos wrote a lot of stuff
13:06:37 <hughfdjackson> jxf: I'll link you - but it's a spoof - everything Jenn does is or comedy value only
13:06:41 <trap_exit> I bet this is blazingly fast.
13:06:49 <jxf> hughfdjackson: ah, ok :)
13:06:57 <donri> it uses some C or C++ library i think
13:07:04 <SrPx> I want to create a table of Haskell values, such as "foo = [1,2,3], bar = 7"... that table can be updated in runtime, say, "set foo = [1,2,3,4]"... and I want that table to be synched between the server, and web browser clients. How could that be possible? I don't know even where to start.
13:07:08 <trap_exit> donri: https://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Buildable.html <-- am I supposed to look at this and know how to use it? or am I reading the wrong docs?
13:07:09 <hughfdjackson> https://medium.com/cool-code-pal/the-hassle-of-haskell-a74862541dfb <- for the sake of completeness, here it is for a giggle
13:07:18 <jxf> hughfdjackson: ty :)
13:07:24 <donri> oh yeah http://hackage.haskell.org/package/double-conversion links C++
13:08:10 <donri> trap_exit: yeah well if you click Builder there you'd end up here: http://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-Lazy-Builder.html#t:Builder
13:08:34 <donri> trap_exit: from that you can figure out toLazyText . build :: Int -> Text  :)
13:08:36 <chrisdone> text-format isn't type-safe in the format string
13:08:49 <chrisdone> for a type-safe printf use this! http://hackage.haskell.org/package/formatting
13:08:58 <donri> i only use text-format for Buildable ;)
13:09:05 <chrisdone> see https://github.com/chrisdone/formatting for examples
13:09:15 <chrisdone> donri: formatting can render to a buildable too =p
13:09:28 <donri> although i guess in this case you can use Builder directly
13:10:02 <donri> trap_exit: http://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-Lazy-Builder-Int.html you can skip text-format, it only calls this for Ints anyway
13:10:02 <chrisdone> (formatting uses text-format, anyway, so it's like a type-safe printf layer )
13:10:09 <donri> chrisdone: nice :)
13:10:29 <trap_exit> donri : alright, slow down
13:10:47 <chrisdone> > format int 23
13:10:48 <chrisdone> "23"
13:10:49 <lambdabot>  Not in scope: ‘format’
13:10:49 <lambdabot>  Perhaps you meant ‘fromRat’ (imported from Numeric)
13:10:50 * hackagebot eros 0.5.3.1 - A text censorship library.  http://hackage.haskell.org/package/eros-0.5.3.1 (pharpend)
13:10:56 <trap_exit> docs are not writen in http://www.youtube.com/watch?v=6AOpomu9V6Q format yet
13:11:33 <donri> trap_exit: the TLDR is use Builder to efficiently generate text values, and then when done toLazyText to get a lazy Text out of the Builder
13:12:23 <donri> basically Builder is a difference list of text chunks on crack, and it has a lot of utilities for things like rendering numbers efficiently
13:12:51 <chrisdone> donri is trying to say that builders have efficient appending, and Text does not =p
13:15:35 <donri> efficient concatenation *and* library support using fast internals and ffi calls :)
13:20:51 * hackagebot eros 0.5.3.2 - A text censorship library.  http://hackage.haskell.org/package/eros-0.5.3.2 (pharpend)
13:23:57 <Denommus> how do I load a sandboxed cabal package in ghci?
13:24:11 <luite> cabal repl
13:25:05 <ion> k. http://hackage.haskell.org/package/eros-0.5.3.2/src/res/phraselists-pretty/
13:25:08 <Denommus> luite: thanks
13:25:32 <Denommus> luite: can Emacs use cabal repl instead of ghci anyhow?
13:25:51 * hackagebot fieldwise 0.1.0.0 - Provides Fieldwise typeclass for operations of fields of records treated as independent components.  http://hackage.haskell.org/package/fieldwise-0.1.0.0 (GracjanPolak)
13:26:08 <Fuuzetsu> (setq haskell-program-name "cabal repl")
13:26:14 <Iceland_jack> Denommus: you can do (setq haskell-program-name "<path to cabal>/cabal repl")
13:26:25 <Denommus> Iceland_jack: thanks!
13:30:51 * hackagebot load-env 0.0.2 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.0.2 (PatrickBrisbin)
13:31:26 <donri> ion: hackage now hosts "kiddie porn". the text string. in a json file.
13:31:49 <moghedrin> I was momentarily confused as to why people were typing lisp in the haskell channel. #vimuserproblems
13:33:11 <isomorpheous> moghedrin: vim sucks
13:34:01 <ion> isomorpheous: Perhaps you should the censorship library to censor attempts to start a flamewar on #haskell. :-P
13:34:16 <isomorpheous> ion: hm?
13:37:17 <isomorpheous> ion: what are you talking about?
13:37:24 <ion> Never mind
13:37:26 <isomorpheous> ion: I was merely stating a fact
13:43:51 <ReinH> isomorpheous: you were not.
13:44:02 <Fuuzetsu> is that a fact?
13:44:03 <Profpatsch> So now I have this function: https://bigmac.caelum.uberspace.de/paste/%2520%252Atemp%252A.html
13:44:19 <ReinH> Please don't troll.
13:44:30 <Profpatsch> But the case … of over .:? doesn’t work, because it returns a Parser (Maybe a)
13:44:43 <Profpatsch> The documentation is at http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html#g:14
13:45:15 <Profpatsch> Parser is nearly everything from Functor to MonadPlus, so maybe there is a way to use that?
13:45:19 <trap_exit> donri: alright, I'm about 1/rd the way there
13:45:20 <trap_exit> looking at http://hackage.haskell.org/package/text-0.11.1.10/docs/Data-Text-Lazy-Builder.html#t:Builder
13:45:32 <trap_exit> how do I go from Int -> Buildable and LazyText -> Text ?
13:45:47 <trap_exit> data Expr = EAlpha | EBeta | ECos Expr | ESin Expr | EInt Int | EFrac Expr Expr | EProd Expr Expr | EExp Expr Expr | EE expr_tex (EInt i) = Data.Text.Lazy.Builder.toLazyText i
13:45:56 <trap_exit> how do I define (expr_tex (EInt i))  ?
13:46:04 <isomorpheous> trap_exit: that's an old version of text
13:46:53 <yorick> @hoogle (Maybe (m a)) -> (m (Maybe a))
13:46:55 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
13:46:55 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:46:55 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
13:47:06 <trap_exit> isomorpheous: want to just give me the right answer so I can learn from it?
13:47:15 <Profpatsch> yorick: Oh!
13:47:30 <Profpatsch> But I guess it’s somehow doable with .!=
13:47:48 <yorick> Profpatsch: what? :D
13:48:22 <isomorpheous> trap_exit: for Lazy.Text -> Strict.Text, use Lazy.toStrict
13:48:27 <trap_exit> given https://hackage.haskell.org/package/text-0.7.2.1/docs/Data-Text-Lazy.html defines a Text ... how do I go from Data.Text.Lazy.Text to a regular Text ?
13:48:37 <Profpatsch> I thought about simply doing a pattern matching over Parser (Just x), but Parser doesn’t export its constructor.
13:48:41 <trap_exit> isomorpheous: how am I supposed ot find that?
13:48:47 <trap_exit> https://hackage.haskell.org/package/text-0.7.2.1/docs/Data-Text-Lazy.html doesnm't show toStrict
13:49:16 <isomorpheous> trap_exit: http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Lazy.html
13:49:23 <glguy> toChunks :: Text -> [Text] -- O(n) Convert a lazy Text into a list of strict Texts.
13:49:26 <isomorpheous> trap_exit: that's why you use up-to-date software
13:49:29 <glguy> if you're using this old version
13:49:31 <trap_exit> hmm
13:49:34 <trap_exit> I guess hte question is why am I keeping on getting old version of docs
13:49:39 <trap_exit> is google haskell unfriendly?
13:49:42 <isomorpheous> trap_exit: yep
13:49:47 <glguy> search is hard
13:49:58 <silasm> trap_exit: try using hoogle. We were actually discussing this recently.
13:50:19 <trap_exit> where can I invest in hoogle
13:50:20 <isomorpheous> trap_exit: hoogle is mildly less shitty than google
13:50:23 <trap_exit> I bet it's going ot hit $2k / share eventually
13:50:45 <silasm> hoogle also probably would have found you that function if you searched by type ;)
13:50:52 * hackagebot load-env 0.0.3 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.0.3 (PatrickBrisbin)
13:50:53 <trap_exit> when haskell dominates the world, it'll create hooglinaires
13:50:58 <isomorpheous> silasm: it wouldn't have
13:51:04 <isomorpheous> silasm: because they're both named text
13:51:10 <isomorpheous> @hoogle :: Text -> Text
13:51:10 <lambdabot> Data.Text copy :: Text -> Text
13:51:10 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
13:51:10 <lambdabot> Data.Text init :: Text -> Text
13:51:13 <isomorpheous> oh
13:51:17 <isomorpheous> Apparently it would
13:51:52 <isomorpheous> @hoogle Data.Text.Lazy.Internal.Text -> Data.Text.Internal.Text
13:51:52 <lambdabot> Parse error:
13:51:52 <lambdabot>   Data.Text.Lazy.Internal.Text -> Data.Text.Internal.Text
13:51:52 <lambdabot>        ^
13:51:54 <silasm> it doesn't search qualified names, though, that's a shame.
13:51:55 <isomorpheous> damn
13:52:07 <trap_exit> alright
13:52:10 <silasm> yeah same thing happens on the website.
13:52:11 <trap_exit> how do I use hoogle to pull up the docs for data.text.lazy ?
13:52:19 <isomorpheous> @hoogle package text
13:52:20 <lambdabot> No results found
13:52:21 <trap_exit> right now, I just type data.text.lazy into Google and get outdated docs
13:52:32 <trap_exit> @hoogle package data.text.lazy
13:52:32 <lambdabot> No results found
13:52:37 <trap_exit> @hoogle lazy
13:52:37 <lambdabot> GHC.Exts lazy :: a -> a
13:52:37 <lambdabot> Control.Monad.ST.Lazy lazyToStrictST :: ST s a -> ST s a
13:52:37 <lambdabot> package lazy-csv
13:52:58 <dwcook> trap_exit: The Hoogle command of lambdabot isn't very good. Go to Hoogle and type the name of the module in question and often you'll get results.
13:53:04 <dwcook> trap_exit: The web interface, I mean.
13:53:09 <isomorpheous> @hoogle text
13:53:09 <lambdabot> Data.Text.Internal text :: Array -> Int -> Int -> Text
13:53:09 <lambdabot> Language.Haskell.TH.PprLib text :: String -> Doc
13:53:09 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
13:53:29 <dwcook> trap_exit: However, it's better if you already know what package it's in, because then you can just bring it up on Hackage and read the module list there.
13:53:30 <isomorpheous> trap_exit: search for "text" on hoogle
13:53:35 <isomorpheous> trap_exit: it's like the third result
13:54:06 <silasm> if you use duckduckgo, hoogle is just a !h away :)
13:54:18 <trap_exit> isomorpheous: does that not sound counter-intuitive?
13:54:22 <trap_exit> to type "text" instead of "lazy text"
13:54:24 <trap_exit> and then read through the list
13:54:28 <dwcook> Huh, didn't know you could abbreviate it that far. I just always type !hoogle :P
13:54:29 <khyperia> also, trap_exit, if you delete the url up until the version number (so it reads http://hackage.haskell.org/package/text ), it takes you to the index page and you can select whatever version
13:54:42 <trap_exit> khyperia; ah, taht is suseful
13:54:50 <Profpatsch> In chromium, I use `h` as a search command, so hoogle’s always a `Ctrl+l h ` away. :)
13:55:05 <trap_exit> Profpatsch: how do I set that up for myself?
13:55:26 <Profpatsch> trap_exit: Right-click on the search bar, edit search engines
13:55:44 <Exio> @src foldr
13:55:44 <lambdabot> foldr f z []     = z
13:55:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:55:47 <Profpatsch> Then use http://www.haskell.org/hoogle/?hoogle=%s
13:57:10 <trap_exit> Profpatsch: you have been p[romoted to associate professor with tenure
13:57:51 <isomorpheous> trap_exit: does that mean that I'm no longer weekend professor?
13:58:32 <trap_exit> isomorpheous: you can be professor too if you tell me how to use Data.Text.Lazy.Builder.toLazyText  to convert a Int to a Lazy.Text
13:58:38 <Exio> @src foldr
13:58:38 <lambdabot> foldr f z []     = z
13:58:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:58:40 <Exio> er
13:58:43 <Exio> sorry
13:58:51 <ReinH> trap_exit: do you want decimal?
13:58:51 <isomorpheous> trap_exit: The easiest way off the top of my head is
13:59:08 <isomorpheous> trap_exit: pack . show
13:59:16 <trap_exit> ReinH: I want base 10. It's a Int, so there should be no decimal point.
13:59:24 <trap_exit> isomorpheous: show is slow, I want to aliv show
13:59:35 <ReinH> trap_exit: decimal means "decimal representation" not "decimal point"
13:59:44 <ReinH> decimal representation = base 10
13:59:54 <isomorpheous> @hoogle :: Int -> Text
13:59:54 <lambdabot> Data.Text drop :: Int -> Text -> Text
13:59:54 <lambdabot> Data.Text.Unsafe dropWord16 :: Int -> Text -> Text
13:59:54 <lambdabot> Data.Text replicate :: Int -> Text -> Text
14:00:11 <ReinH> trap_exit: http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Lazy-Builder-Int.html#v:decimal
14:01:30 <trap_exit> isomorpheous: you're fired;
14:01:38 <trap_exit> ReinH: you're promoted to chaired professor of http://hackage.haskell.org/package/text-1.1.1.3/docs/Data-Text-Lazy-Builder-Int.html#v:decimal
14:01:50 <ReinH> trap_exit: hahaha
14:01:53 <ReinH> I guess he wasn't tenure
14:02:24 <isomorpheous> trap_exit: Here you go - http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Builder.html#t:Builder
14:02:55 <trap_exit> isomorpheous: how does this work. I need Lazy -- are ByteString default lazy? :-)
14:04:14 <ReinH> trap_exit: do you want ByteString or Text?
14:04:15 <isomorpheous> trap_exit: You make a builder, then build that into a bytestring
14:04:25 <isomorpheous> trap_exit: it's cheap to go from Bytestring to text
14:04:37 <isomorpheous> @hoogle :: ByteString -> Text
14:04:37 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
14:04:37 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
14:04:37 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
14:04:51 <ReinH> Not really that cheap?
14:05:00 <trap_exit> I want Lazy.Text
14:05:01 <trap_exit> I got it to work
14:05:03 <ReinH> compared to using either's builder
14:05:04 <trap_exit> thanks everyone :-)
14:05:12 <isomorpheous> trap_exit: god
14:05:15 <isomorpheous> *good
14:08:06 <felixn> is there a string syntax parser for parsec that anyone knows about?  too lazy to implement it
14:08:21 <donri> trap_exit: so you first need decimal to go int -> builder then toLazyText to go builder -> lazy text then toStrict to go lazy -> strict :)
14:08:32 <trap_exit> donri: yep
14:08:43 <trap_exit> donri: I feel like a badass building this gigantic lazy text string
14:08:48 <trap_exit> donri: which doesn't get instantiated until it needs to be written out
14:08:56 <donri> trap_exit: (but it's usually better to redesign things so you can stay in Builder, if possible)
14:09:23 <trap_exit> donri: premature optimization; I need to finish this code first
14:09:39 <donri> the reason Builder is efficient is because toLazyText is not, and with Builder we can defer it and run it only once instead of on each step
14:11:13 <bernalex> is there an Int -> [Int]?
14:11:21 <bernalex> so given 1234, get back [1, 2, 3, 4]
14:11:54 <yorick> I have a function (a -> m (Maybe b)) and a m (Maybe a) value. can I get a better way to bind those than than my horrendous valb >>= \x -> join <$> (T.sequence $ liftM vala x)
14:12:39 <yorick> I mean, that should be possible, right?
14:13:00 <donri> bernalex: not hard to write. you can cheat with Show and Read or you can recurse decimally (my math sucks but divMod 10 something something, don't look at me)
14:13:04 <glguy> That's the bind for MaybeT
14:13:15 <bernalex> donri: not hard to write but wondering if it already exists nonetheless
14:13:48 <Pythonfant> bernalex: map digitToInt . show
14:14:02 <Pythonfant> bernalex: there's the digits package http://hackage.haskell.org/package/digits-0.2/docs/Data-Digits.html
14:14:11 <Profpatsch> When I use aeson to define JSON representations for datatypes, the compiler complains about „orphan instances“: http://i.imgur.com/VbGCPaJ.jpg
14:14:14 <bernalex> Pythonfant: ah that exists nice
14:14:15 <Denommus> does anyone have any idea if it's possible to have a call for the GC after each step in this code? http://paste.lisp.org/display/143189
14:14:18 <yorick>   x >>= f = MaybeT (runMaybeT x >>= maybe (return Nothing) (runMaybeT . f)) hmmm
14:14:50 <Profpatsch> But doesn’t it make sense to have a separate module where I define all JSON-related foo?
14:15:15 <felixn> https://gist.github.com/munro/c85d622929de414fb0e1 got it thanks!  string parser
14:15:22 <donri> Profpatsch: nah
14:15:37 <Profpatsch> Haskell Wiki says this is because neither the Class nor the Instance are defined in the same module.
14:15:54 <Profpatsch> donri: Nah not a problem or nah it doesn’t make sense?
14:16:10 <donri> Profpatsch: doesn't make sense :) because orphans. so yeah.
14:16:29 <glguy> :t \m f -> m >>= maybe (return Nothing) f
14:16:30 <lambdabot> Monad m => m (Maybe a) -> (a -> m (Maybe a1)) -> m (Maybe a1)
14:16:55 <Profpatsch> donri: I don’t see why I cannot define an instance in a separate Module.
14:17:23 <donri> Profpatsch: it's usually best to structure modules by what they define rather than by feature
14:17:38 <arancia> When GHC tells me "Could not find module `Data.Number.CReal': Perhaps you haven't installed the profiling libraries for package `numbers-2009.8.9'?" what should I do to enabled profiling for that library?
14:17:44 <Profpatsch> donri: So by datatypes that belong together?
14:17:58 <Profpatsch> With all their instances?
14:18:27 <donri> Profpatsch: oh you can just fine, but orphans are bad because they can lead to duplicate instances or getting different instances depending on imports (which can affect certain assumptions made e.g. by Set about Ord is the canonical example)
14:18:32 <monochrom> arancia: you may have to rebuild a lot of libs. http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
14:18:48 <Profpatsch> donri: Okay.
14:18:52 <donri> Profpatsch: yep and functions. that way your functions can access internals without having to export those too. haskell doesn't have "protected"
14:19:01 <arancia> monochrom: Oh noes!
14:19:10 <donri> well ok it kinda has due to cabal other-modules but yeah
14:19:16 <donri> it's a mess
14:20:14 <arancia> monochrom: Is there a way to enable profiling only for my own modules?
14:20:26 <streitdoni_> hey i want to use the 'div' function with 10 untill it isn'T possible anymore. How can i do this? E.g. 80324 `div` 10. Can i integrate a loop until the result is 8?
14:20:50 <monochrom> no, when building one lib with profiling, it requires other libs with profiling too
14:20:54 <johnw> you can check if x `mod` 10 = x
14:21:01 <johnw> if not, recurse
14:21:02 <streitdoni_> sorry wrom formulation
14:21:02 <donri> Profpatsch: so anyway orphan is just a warning and i think not even on by default (you might be using -Wall, which is usually good)
14:21:06 <arancia> :(
14:22:48 <streitdoni_> 80324 div 10 = ...  but i want to execute the function untill i get 8
14:22:52 <jle`> streitdoni_: you can use recursion
14:23:13 <monochrom> you have to define your own function
14:23:14 <streitdoni_> ok
14:23:24 <streitdoni_> recursion is one way
14:23:26 <streitdoni_> i try this
14:23:52 <jle`> streitdoni_: yeah.  remember the base case and the recursive call.
14:24:08 <jle`> you could also use unfoldr i think if you want to avoid explicit recursion
14:24:11 <monochrom> mono x y | x < y = x | otherwise = mono (x `div` y) y
14:24:12 <streitdoni_> ok i'll post i when it works...
14:25:17 <arancia> > until (< 10) (`div` 10) 80324   -- streitdoni_
14:25:18 <lambdabot>  8
14:25:31 <vanila> > iterate (`div` 10) 80324
14:25:32 <lambdabot>  [80324,8032,803,80,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:25:37 <jle`> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, y `div1 10)) 80324
14:25:39 <lambdabot>  <hint>:1:70: parse error on input ‘10’
14:25:40 <vanila> this applies the same function over and over again
14:25:45 <jle`> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, y `div` 10)) 80324
14:25:46 <lambdabot>  [80324 `mod` 10,y `div` 10 `mod` 10,y `div` 10 `mod` 10,y `div` 10 `mod` 10,...
14:25:51 <monochrom> @type until
14:25:52 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
14:25:58 <monochrom> hmm, where is until?
14:25:59 <phaskell> No symbol 'until' found anywhere.
14:26:00 <jle`> oh yeah...iterate and dropWhile might be the best choice
14:26:02 <monochrom> @hoogle until
14:26:02 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
14:26:09 <jle`> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, y `div` 10)) 80324 :: [Int]
14:26:10 <monochrom> nice.
14:26:10 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
14:26:11 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
14:26:46 <jle`> > head . dropWhile (>= 10) . iterate (`div` 10) $ 80324
14:26:47 <lambdabot>  8
14:29:59 <streitdoni_> how can i drop the element x from the list (x:xs)
14:30:24 <Kazagistar> streitdoni_: that would be xs
14:30:25 <streitdoni_> the problem is, that the element x is allready out of the list
14:30:45 <jle`> can you give an example of input and output?
14:31:00 <streitdoni_> [8,7,80.60]
14:31:11 <jle`> and what would that turn into?
14:31:15 <donri> :t tail
14:31:16 <lambdabot> [a] -> [a]
14:31:44 <monochrom> if you already have (x:xs), then just use xs
14:32:11 <jle`> > let (x:xs) = [1,2,3] in xs
14:32:12 <lambdabot>  [2,3]
14:32:43 <streitdoni_> of this list (x:xs) i check the elements recursice and the second one should be droped.but not the first one but with the syntax (x:xs) the first element is allready outside
14:33:20 <jle`> so the first element matching an item called `x` in a list called `xs` ?
14:33:32 <jle`> matching as in (==) ?
14:33:37 <streitdoni_> yes
14:33:41 <jle`> can you give us an example list and what the result would look like?
14:33:44 <streitdoni_> e.g. 8==8
14:33:45 <monochrom> I don't think I understand. do you mean you want to process [1,2,3,4] into [1,3,4]?
14:33:57 <jle`> [1,4,6,1,4,1] -> [4,6,4,1] ?
14:34:04 <trap_exit> donri: did you make the comment that Lazy must bey default
14:34:18 <donri> trap_exit: hm?
14:34:18 <jle`> ^^ do you have an example like that?  a sample input, and a sample output?
14:34:26 <streitdoni_> [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]
14:34:32 <streitdoni_> and the result should be [81, 832, 87]
14:34:33 <trap_exit> donri: someone made an arguemntat that for laziness to be useful
14:34:33 <trap_exit> it must be default
14:34:35 <trap_exit> since it otherwise takes too much work
14:34:42 <trap_exit> donri: was that person you?
14:34:51 <donri> don't think so
14:35:04 <trap_exit> donri: too bad, I was going to stay that person was a genius and I now agree with him/her
14:35:20 <donri> sounds a bit like edwardk
14:35:20 <monochrom> ok, looks like f (x:xs) | some_condition = x : f xs
14:35:22 <trap_exit> alright, must dig through logs to see who told me that insight
14:35:47 <monochrom> or rather, f (x:xs) | some_condition = x : f xs | otherwise = f xs
14:37:02 <monochrom> @let mono [] = []; mono (x:xs) | x==81 || x==823 || x==87 = x : mono xs | otherwise = mono xs
14:37:03 <lambdabot>  Defined.
14:37:12 <monochrom> > mono [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]
14:37:13 <lambdabot>  [81,87]
14:37:33 <monochrom> I made some typos. but you see the idea.
14:38:08 <Fuuzetsu> … | x `elem` [81, 823, 87]
14:38:32 <monochrom> well yeah I want to be elementary. (pun!)
14:38:46 <streitdoni_> many thanks for the solutions
14:44:52 <luite> is there a way to let cabal-install ignore the ~/.cabal/config file?
14:45:11 <Fuuzetsu> mv
14:45:16 <athan> `on` feels like a reversed `fmap`, but applied to tuples from (what I think is) something similar to... *goes out on a limb* the Yoneda lemma. Am I thinking right? Is there a more general interface, maybe even from the other direction, like `fmap`?
14:45:42 <benzrf> filter (`elem` [81, 823, 87])
14:45:54 <johnw> filter (== 8) $ map (read . head . show) $ [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]
14:45:57 <johnw> > filter (== 8) $ map (read . head . show) $ [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]
14:45:59 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
14:45:59 <lambdabot>  Expected type: a0 -> [GHC.Base.String]
14:45:59 <lambdabot>    Actual type: a0 -> GHC.Base.String
14:46:08 <johnw> > filter (== 8) $ map (read . (:[]) . head . show) $ [10, 28, 81, 302, 832, 488, 4378, 23, 34, 87]
14:46:10 <lambdabot>  [8,8,8]
14:46:14 <johnw> oops
14:46:20 <luite> Fuuzetsu: hehe yeah it has to be on the command line or with some env var. i'm using cabal-install in the ghcjs-boot program, which builds all the libs for the global ghcjs package db and requires specific locations for everything
14:46:45 <luite> Fuuzetsu: so far i think it overrides all important options, but cabal-install might add more in the future
14:46:51 <jle`> there's digitToInt per haps
14:47:10 <jle`> > digitToInt . head . show $ 8598451
14:47:11 <lambdabot>  8
14:47:26 <supki> luite: --config-file, I think
14:47:42 <supki> e.g. --config-file=/dev/null or whatever
14:48:37 <luite> supki: tnx, in retrospect i could've found that myself easily... is this a recent addition?
14:48:43 <donri> luite: "You can set the $CABAL_CONFIG, it acts like setting the "--config-file=..." option."  https://github.com/haskell/cabal/issues/680
14:49:25 <glguy> athan: http://lpaste.net/107722 if you bend things around like this you can make "on" the contravariant map operation
14:50:49 <athan> glguy: Thank you :)
14:50:55 * hackagebot taggy 0.1.1 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.1.1 (AlpMestanogullari)
14:55:31 <luite> i think the problem was that i only checked cabal install --help and not cabal --help
14:55:55 * hackagebot load-env 0.0.4 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.0.4 (PatrickBrisbin)
14:59:00 <streitdoni_> so there is my solution
14:59:01 <streitdoni_> select_8 :: [Integer] -> [Integer]
14:59:01 <streitdoni_> select_8 xs = [t| t<-xs, checkFor8 t]
14:59:01 <streitdoni_> checkFor8::Integer -> Bool
14:59:01 <streitdoni_> checkFor8 int
14:59:01 <streitdoni_> 		| int `div` 10 > 8 = checkFor8 (int `div` 10)
14:59:03 <streitdoni_> 		| int `div` 10 < 8 = False
14:59:05 <streitdoni_> 		| otherwise = True
15:02:55 <FreeFull> Since all Haskell implementation use laziness, does that mean no Haskell implementation is pure?
15:03:03 <FreeFull> Technically
15:03:22 <geekosaur> ???
15:05:36 <josephle> FreeFull: how does laziness preclude purity?
15:05:50 <FreeFull> josephle: It's a form of mutation
15:06:30 <Iceland_jack> FreeFull: You can have mutation happening in the background no problem, it's how it affects the semantics that matters
15:07:13 <vanila> FreeFull, The language itself is pure, the implementation has to use mutation
15:07:55 <vanila> FreeFull, being a pure language we have guarantees like x = y implies f x = f y
15:08:22 <geekosaur> "has to"? I thought it was just an optimization
15:08:54 <geekosaur> (one which is a lot safer *because* the semantics are pure)
15:09:02 <FreeFull> geekosaur: Is there a way to implement non-strictness without laziness?
15:09:07 <josephle> well, some operational models of laziness are impure, like the one found in Bob Harper's book iirc
15:09:08 <lucca> Just an optimization, technically.
15:09:27 <geekosaur> FreeFull, algol68 had call-by-need, which is laziness by another name
15:09:27 <lucca> In the same sense that numbers are technically not necessary either.  Not useful to discuss that tho
15:09:39 <jfischoff> FreeFull: yes
15:09:52 <Kazagistar> geekosaur: your "non optimized" version would recompute results instead of thunks, right?
15:09:54 <geekosaur> well, non-strict-ness
15:10:19 <geekosaur> Kazagistar, yes. I wasn't claiming it was a good idea, just that it's possible
15:10:23 <jle`> FreeFull: the haskell runtime relies on mutation to execute and evaluate haskell code, but...haskell itself is pure
15:10:31 <jle`> just like when you write down 1 + 1 = 2 on a chalkboard
15:10:40 <eacameron> how close is the nirvana fix to cabal dependency hell?
15:10:47 <Kazagistar> geekosaur: yeah, I gotcha, I was just verifying that I had understood it right
15:10:48 <jle`> you -- the runtime system -- are mutating the world --- your brain, the chalbkoard -- to solve the math problem
15:10:53 <jle`> but 1 + 1 is still a pure function
15:10:54 <abc56889_> What's the applicative version of (>=>) ?
15:11:09 <jle`> even though you used your brain and changed chemicals in your brain, and the chalkboard, in the process of evaluating it
15:11:20 <FreeFull> jle`: I don't question the pureness of the code you're interpreting/compiling, just of the implementation itself
15:11:29 <eacameron> I'm working with some haskell learners and the dependency hell is a tough obsticle
15:11:31 <jle`> abc56889_: what would it do?
15:11:52 <jle`> abc56889_: you can't have Applicative f => (a -> f b) -> (b -> f c) -> (a -> f c), if that's what you're asking
15:11:57 <zwer_a> :t (>=>)
15:11:58 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
15:12:25 <abc56889_> jle`: why? :(
15:12:39 <carter> that looks you actually can't write that
15:12:45 <carter> you need bind
15:12:47 <zwer_a> `(a -> m b) -> (b -> m c)' requires >>=
15:12:59 <jle`> abc56889_: one way to look at Monad is "a Functor that allows you to compose (a -> f b)'s"
15:13:02 <Kazagistar> eacameron: you should probably start with just some basic instructions about sandboxes early on? or do you mean something else?
15:13:23 <jle`> abc56889_: that's more or less equivalent to most other definitions of Monad
15:13:42 <jle`> abc56889_: being able to compose arbitrary (a -> f b) is pretty much what a monad distinctly offers
15:13:47 <eacameron> Kazagistar: that's what I'm doing, but it's a shame I have to tell them: You'll love Haskell. Rule 1 don't install anything
15:13:55 <abc56889_> jle`: TIL. thanks.
15:14:15 <jle`> abc56889_: as a practical reason...if you want to chain an arbitrary (b -> f c), you basically are saying "i can return any aribtrary f c, for the result b"
15:14:37 <jle`> abc56889_: for Applicative, you can't "decide" what 'f c' to return based on the result
15:14:45 <jle`> so...this might help give you an intuition
15:14:46 <mietek> Is there a good way to combine STM and database access?  For, say, using STM as a DB cache.
15:15:11 <mietek> It would be nice to be able to say "atomically $ do { stmStuff ; dbStuff }
15:15:13 <jle`> abc56889_: with Applicative and Functor, you can only "apply" a -> b's, or f (a -> b)'s, etc.
15:15:25 <jle`> abc56889_: you can never apply anything with an "f b" on the right hand side, with Applicative
15:15:25 <mietek> And have both occur as one transaction
15:15:41 <jle`> ...speaking loosely
15:15:41 <eacameron> mietek: STM doesn't allow any IO, so you're probably lost there
15:15:45 <abc56889_> jle`: nah, im just getting myself in trouble using point free style hehe
15:15:56 * hackagebot verilog 0.0.7 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.7 (TomHawkins)
15:16:20 <mietek> eacameron: there is unsafeIOToSTM.
15:16:31 <jle`> abc56889_: ok :)  just hope you can see the pattern to gain an intuition.  Functor allows you to apply (a -> b)'s...Applicative allows you to apply f (a -> b)'s...but if you want to do something (a -> f b) --- that is, the *return* is the type --- then you'll need Monad
15:16:44 <mietek> Using it would make sense if there was a hook executed when STM decides it's time to roll back the transaction, which then could be forwarded to the DB.
15:17:14 <abc56889_> jle`: baby steps ;)
15:17:21 <Kazagistar> eacameron: dunno, I tend to stick to sandbox-like things in all languages where I can (like virtual environments in python). Its a good development practice, to keep a canonical listing of dependencies as you develop, and usually, you don't need to to get to packages until you are a little way in anyways?
15:17:29 <jle`> abc56889_: mk :)
15:17:36 <abc56889_> thanks for your help
15:17:38 <jle`> np
15:18:03 <eacameron> mietek: "Beware: this is a highly dangerous thing to do." ;) I'm not sure that's a safe route. Perhaps you can build your own Monad that encapsulates both but doesn't mix them
15:19:06 <RchrdB> mietek, I remember that a few years back, unsafeIOToSTM used to be *really* safe for some complicated reason about exception handling. I'm not sure whether that's gone away.
15:19:27 <mietek> Perhaps it doesn't make sense to mix the two anyway.
15:19:35 <eacameron> mietek: How does AcidState do it?
15:19:36 <mietek> There should probably be a single source of truth.
15:20:51 <RchrdB> Ah, there it is.
15:21:00 <jle`> dmj` is our resident acidstate maintainer but he is offline
15:21:27 <eacameron> mietek: Yeah I see your point. Perhaps just a plain-old MVar would do the trick...
15:22:37 <RchrdB> mietek, the unsafety is mentioned here http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM and there is an example of one way in which it can go wrong written up here http://haskell.1045720.n5.nabble.com/GHC-2401-unsafeIOToSTM-hangs-with-64-bit-multicore-tp3167517p3167522.html
15:22:49 <mietek> Thanks, that's quite interesting.
15:22:58 <athan> glguy: Is there a general derivation of this, maybe in template haskell, for n-ary functions?
15:23:47 <RchrdB> mietek, oh, better interface to that discussion: here's the bug on GHC's bug tracker: https://ghc.haskell.org/trac/ghc/ticket/2401#comment:5
15:23:56 <mietek> Cheers.
15:23:59 <RchrdB> As you can see, it hasn't been touched even now.
15:24:10 <mietek> Yeah, there's probably a reason.
15:24:13 <mietek> ;)
15:24:30 <mietek> I am humbled by 6 year old bugs.
15:25:42 <lispy> Reading this C++ code makes me realize that we're really missing out on the visitor pattern.
15:26:05 <lispy> It looks really important judging by how many lines of code they dedicate to it
15:26:38 * lispy </facetious>
15:26:46 * raichoo1 snickers
15:27:39 <rasfar> Is it possible to use a class method (other than Data/Typeable) in a SYB traversal?
15:28:06 <RchrdB> mietek, I think that what you *actually* want might be achievable without trickery anyway? There isn't any reason why you can't do { result <- atomically { do get_from_cache; }; case result of { (Just x) -> return x; Nothing -> query_from_database; } } -- ?
15:28:46 * ion reads <http://en.wikipedia.org/wiki/Visitor_pattern#Motivation>… “so it’s like type classes?”
15:28:48 * ion ducks
15:28:51 <RchrdB> I mean, is there any reason why writing a cache that you access in atomic STM transactions then falling back to an *IO* action that checks the database doesn't do what you desire?
15:29:22 <rasfar> The only way I could get that to work is by building a hacked Data.Data bearing the extra class constraint.
15:30:03 <mietek> RchrdB: what about the write case?
15:31:31 <RchrdB> If you're trying to maintain atomicity while writing to two different data stores then you need to use a distributed commit protocol such as 2 phase commit.
15:31:40 <mietek> Yeah.
15:32:16 <RchrdB> Putting a cache in front of your DB at all is almost always a choice to prioritise speed over consistency.
15:34:21 <athan> Is there such a thing as a multicategory, like a multifunctor?
15:35:02 <athan> wait, nevermind
15:36:43 <int3___> I'm thinking of making some changes to a library that my project depends on. what's the standard way to manage this? I'm using cabal of course, and the library was originally installed from hackage
15:37:24 <Fuuzetsu> cabal unpack, hack, cabal install
15:37:35 <Fuuzetsu> alternatively add-source on the last step
15:37:55 <Fuuzetsu> send changes upstream
15:38:19 <int3___> Fuuzetsu: thanks!
15:53:50 <kini> I seem to be unable to build ghc 7.8.2 using ghc 7.8.3 - is this something I should have expected?
15:54:26 <johnw> kini: and the error is?
15:54:44 <kini> important part seems to be "ghc-7.8.3-4df3c15ee427e39c22a9b556627abafc is unusable due to missing or recursive dependencies"
15:55:05 <johnw> how about showing me everything
15:57:24 <Fuuzetsu> just wondering what your use-case for doing this is
15:58:03 <spott> What is the idiom for dealing with lists "two at a time".  the canonical example I can think of is a "difference" function that is the difference between every two elements
15:58:24 <rasfar> I've posted an lpaste:  http://lpaste.net/107723
15:58:26 <Fuuzetsu> spott: is zipWith what you need?
15:58:28 <rasfar> in case anyone can help
15:59:25 <spott> Fuuzetsu: not really.  the function that I'm thinking of would take [x1, x2, x3, x4] -> [f x1 x2, f x2 x3, f x3 x4]
15:59:34 <johnw> map (f $)
15:59:36 <johnw> oh, I see
15:59:39 <Fuuzetsu> no
15:59:52 <Fuuzetsu> spott: what happens on lists with odd number of elements?
16:00:07 <Fuuzetsu> maybe you want a list of pairs to begin with and then your problem goes away with uncurry and map
16:00:14 <spott> you  always get one element fewer than you put in
16:00:34 <spott> so how do I get from a list, to a list of pairs?
16:01:02 <Fuuzetsu> well, it depends which is why I asked what happens at odd length
16:01:09 <rasfar> zipWith (\ x y -> (x,y)) lst (tail lst)
16:01:24 <Fuuzetsu> an easy way is to simply pattern match on two head elements at a time
16:01:25 <spott> ah!
16:01:35 <rasfar> > zipWith (+) [1,2] [1,2,3]
16:01:38 <lambdabot>  [2,4]
16:01:53 <rasfar> > zipWith (+) [1,2,3] [1,2]
16:01:54 <lambdabot>  [2,4]
16:01:54 <kini> johnw: sorry, just a second
16:02:33 <spott> zipWith might be what I need... I just wasn't thinking that way
16:03:13 <rasfar> oops, the above doesn't work quite as you want
16:03:16 <rasfar> :t group
16:03:17 <lambdabot> Eq a => [a] -> [[a]]
16:03:22 <rasfar> nope
16:03:27 <rasfar> :t chunk
16:03:28 <lambdabot> Int -> [e] -> [[e]]
16:04:11 <rasfar> ack, my brain is elsewhere
16:04:36 <spott> > zipWith ((-) . flip) [1,2,3] (tail [1,2,3])
16:04:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
16:04:37 <lambdabot>    arising from a use of ‘M446743469662351597721328.show_M4467434696623515977...
16:04:37 <lambdabot>  The type variable ‘c0’ is ambiguous
16:04:37 <lambdabot>  Note: there are several potential instances:
16:04:37 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
16:04:52 <spott> nevermind...
16:05:03 <jle`> flip (-)
16:05:13 <spott> > zipWith (flip (-)) [1,2,3] (tail [1,2,3])
16:05:14 <lambdabot>  [1,1]
16:05:15 <jle`> also i suggest you use drop 1 instead of tail if you are working with non-infinite lists
16:05:23 <rasfar> anyone know if it is possible to use a class method (outside of Data and Typeable) with SYB?
16:05:29 <johnw> jle`: why?
16:05:34 <rasfar> (right -- drop 1 will never give an exception)
16:05:44 <jle`> johnw: it's total?
16:05:48 <johnw> > drop 1 []
16:05:49 <kini> johnw: https://gist.github.com/kini/e9b9cbd2284200acf393
16:05:50 <lambdabot>  []
16:05:51 <johnw> ah
16:06:04 <spott> > tail []
16:06:05 <lambdabot>  *Exception: Prelude.tail: empty list
16:06:23 <jle`> just as a precaution :)
16:06:30 <spott> thanks
16:06:41 <rasfar> np
16:06:43 <johnw> kini: you may want to try wiping out ~/.ghc before starting your build too
16:06:54 <johnw> though I've never attempted what you're doing
16:07:06 <johnw> make sure that "ghc -v" looks sane, before starting the build
16:07:53 <aristid> augur_: still here? you beeped me
16:08:19 <augur_> aristid: i think im going to rewrite my grammar to use categorial grammar instead of HPSG
16:08:32 <rasfar> jle`: you don't happen to know SYB... can you glance at http://lpaste.net/107723 ?
16:08:51 <jle`> rasfar: no experience with it, sorry :/
16:09:07 <augur_> aristid: im getting tired of the problems with sort errors etc and i think ill be able to handle the same things with a categorial approach
16:09:10 <rasfar> ok! thanks anyway. ... do you have a preferred generics lib?
16:09:47 <augur_> aristid: my maine worry is how im going to handle things like topicalization, and other movement-y things
16:09:54 <aristid> augur_: i'm sorry i'm quite tired right now
16:10:01 <augur_> aristid: k :p
16:10:07 <kini> johnw: cleaned out ~/.ghc , same result
16:10:15 <kini> what do you mean by `ghc -v` being "sane"?
16:11:04 <kini> `ghc -v` looks like this: https://gist.github.com/kini/e9b9cbd2284200acf393#file-ghc-v
16:19:05 <spott> anyone have any experience dealing with Data.Vector.Unboxed?
16:19:29 <rasfar> a little
16:19:30 <spott> specifically, is there a concat for a vector of lists?
16:20:08 <spott> sorry, a vector of vectors, and concat it?
16:20:48 <spott> I guess foldl' (++) on the vector of vectors?
16:21:11 <hiptobecubic> is (++) concat for vectors?
16:21:13 <rasfar> i'd need to check ... unboxed might be "frozen" or something, and require you to convert to mutable (not sure; checking)
16:21:56 <spott> concat works for lists of vectors... (++) works for vectors
16:22:22 <arancia> concatMap id?
16:23:00 <Fuuzetsu> isn't that just concat
16:23:29 <Fuuzetsu> :t concatMap id
16:23:30 <lambdabot> [[b]] -> [b]
16:23:31 <arancia> Where is concat?
16:23:32 <phaskell> No symbol 'concat' found anywhere.
16:23:38 <spott> :t Data.Vector.Unbox.concat
16:23:39 <lambdabot> Not in scope: ‘Data.Vector.Unbox.concat’
16:23:46 <Fuuzetsu> :t Data.Vector.Unbox.concat
16:23:46 <lambdabot> Not in scope: ‘Data.Vector.Unbox.concat’
16:23:47 <Fuuzetsu> :t Data.Vector.Unbox.concatMap
16:23:48 <lambdabot> Not in scope: ‘Data.Vector.Unbox.concatMap’
16:24:04 <spott> I'm very sorry, I have to run, thanks for the hlep
16:24:08 <spott> *help
16:24:09 <rasfar> bye
16:24:12 <Fuuzetsu> there are 5 concats in vector package
16:24:25 <Fuuzetsu> including https://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector-Unboxed.html#v:concat
16:24:27 <dwcook> spott: If there's a Foldable instance, use fold
16:24:41 <dwcook> Ah, or what Fuuzetsu said :)
16:25:01 <Fuuzetsu> it still doesn't love what they wanted because they have Vector (Vector a) not [Vector a]
16:25:18 <dwcook> Oh I see
16:25:43 <dwcook> Oh, Vector's a data family. That complicates things a little
16:26:22 <dwcook> Oh never mind, that might just be for unboxed vectors?
16:26:27 <rasfar> would it be cheap to go VU.toList vecofvecs, then you have a list of Vector
16:26:40 <rasfar> can you have an unboxed vector though?
16:26:48 <rasfar> (vector of unboxed vectors)
16:26:55 <dwcook> Ah there we go, Data.Vector.Vector does indeed have Foldable and Monoid. So fold should do the trick, I think.
16:27:10 <jle`> rasfar: if there is a Foldable instance, it would basically be doing that, i think
16:27:19 <jle`> :t F.concat
16:27:20 <lambdabot> Foldable t => t [a] -> [a]
16:27:29 <jle`> @src F.conca
16:27:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:27:30 <jle`> @src F.concat
16:27:30 <lambdabot> Source not found. My brain just exploded
16:27:33 <jle`> oh yeah
16:27:36 <rasfar> yeah. / but I kindof doubt you have have Data.Vector.Unboxed <vector>
16:29:16 <dfeuer> Any idea how this implementation of inits would compare to the one in base, performance-wise? http://codepad.org/S4jykeGJ
16:30:06 <rasfar> 404 not found, for me
16:30:20 <dfeuer> Err..
16:30:38 <dfeuer> Sorry, rasfar. http://codepad.org/S4jyqeGJ
16:31:59 <rasfar> I have no idea dfeuer, but it would be interesting to compare the generated Core
16:32:08 <khanage> i keep trashing my ghci session whenever i add a new package to my cabal file - is that neccesary?
16:32:14 <maggern> Hey guys, not sure which language to take a hack at next csharp or haskell, opinions?
16:32:33 <khanage> maggern: probably a biased audience?
16:32:47 <rasfar> maggern: what attracts you to programming? that will help recommend
16:33:18 <Axman6> C# is a pretty boring language AFAIR, not going to learn a lot there ;)
16:33:20 <dfeuer> I'm on Android right now, rasfar, so I can't even look at that.
16:34:43 <ReinH> maggern: you're in #haskell so it looks like you've already made your decision.
16:34:54 <ReinH> maggern: you have our permission to learn Haskell now. :)
16:35:12 <ReinH> maggern: this is a fun way to start
16:35:14 <ReinH> @where lyah
16:35:14 <lambdabot> http://www.learnyouahaskell.com/
16:41:53 <rasfar> dfeuer: if your implementation is correct, it's blazingly faster than the one in base, on my system (GHC 7.8.1, default options)
16:42:29 <rasfar> I'm timing it with  main = do evaluate $ length $ L.inits [(1::Int)..200000]
16:42:58 <dfeuer> Rasfar, did you do -O2? Also, how's it compare with something like sum . map length?
16:42:59 <rasfar> (oops, don't need the "do")
16:43:18 <dfeuer> What does evaluate do anyway?
16:44:01 <rasfar> forces the result the way putStr would, but you don't have to output a big thing
16:44:07 <dfeuer> I'm pretty sure it's correct, and as lazy as the base version, but you're more than welcome to double check.
16:44:14 <rasfar> it
16:44:31 <rasfar> 's in Control.Exception, I got to know it through ezyang's posts on space leaks
16:44:36 <dfeuer> And did you use -O2?
16:44:42 <rasfar> just getting there...
16:45:02 <dfeuer> *nod*. That might make them equal, but we'll see...
16:45:50 <dfeuer> But yeah, I'd love to see you evaluate without just taking the length of the spine as well. Maybe a deepSeq or a length of concat of that or something....
16:46:15 <Axman6> rasfar: perhaps something like length . contat . inits would be better, it ensures that each list actually gets produced
16:46:20 <Axman6> c*
16:46:31 <maggern> Yey, I love books
16:46:35 <stolaruk> Is there any reason to opt for "newtype" over "type" when you aren't writing a library and therefore don't have a need to "hide" the implementation of a given type?
16:46:41 <Axman6> deepSeq would probably also be good
16:46:42 <dfeuer> But yeah, I'd love to see you evaluate without just taking the length of the spine as well. Maybe a deepSeq or a length of concat of that or something.... There are various ways the thing could be used.
16:47:26 <Axman6> stolaruk: Newtype lets you write new type class instances for current types which is nice
16:47:27 <rasfar> putStrLn $ show $ sum $ map length $ inits' [(1::Int)..10000]  -- your inits
16:47:32 <dfeuer> Sorry to double up there. I meant to say a deepSeq of last(inits [1..big]) would be good too.
16:47:36 <Axman6> liker ZipList (I think)
16:47:38 <rasfar> 50005000
16:47:38 <rasfar> 7.912u 0.464s 0:08.44 99.1%     0+0k 0+2064io 0pf+0w
16:47:46 <stolaruk> Axman6: Ah yes like when you need a monoid of a number
16:47:55 <Axman6> yeah
16:48:02 <stolaruk> I forgot about that
16:48:27 <rasfar> oops extra show there / and for Data.List.inits:
16:48:30 <rasfar> 20.533u 0.572s 0:21.20 99.5%    0+0k 0+2040io 0pf+0w
16:48:48 <rasfar> you are still at least 2x faster :)
16:48:54 <rudi_s> Hi. What is the simplest way to load a file with a specific encoding, e.g. iso-latin or utf-8?
16:48:58 <rasfar> that is -O2 7.8.1 btw
16:49:27 <rudi_s> For utf-8 it seems like readFile works, but I'm not sure if that is by accident.
16:49:37 <dfeuer> Thanks, rasfar! I'll do some more tests when I get home, and if that holds up I'll file a bug report.
16:50:04 <dfeuer> Or maybe even go as far as to submit a patch, but that seems a wee bit hard.
16:50:07 <rasfar> cool; meanwhile I will try to understand your implementation... :)
16:50:52 <dfeuer> Let me know if you nee help. If I don't answer, @tell me.
16:51:01 <benzrf> stolaruk: also if you want to enforce non-mixing-up of stuff
16:51:18 <benzrf> stolaruk: i know some people e.g. use Weight and Time newtypes, or something
16:51:28 <stolaruk> benzrf: By giving it different names (and different types)
16:51:29 <benzrf> so that you dont mistakenly use a weight as a time
16:51:36 <stolaruk> yeah
16:51:38 <stolaruk> that's nice
16:51:42 <rasfar> dfeuer: ok! thx
16:51:48 <maggern> Well I want to develop for mobile, how's haskell capabilites there? :p
16:51:59 <benzrf> i had an idea the ther day
16:52:02 <stolaruk> maggern: You can write Haskell for iOS
16:52:19 <benzrf> some kind of tiny syntax for automatically casting values in and out of newtypes
16:52:27 <stolaruk> maggern: I don't think Droid is quite there yet
16:52:35 <maggern> I really love python, I'm starting to get java and objective-c up my throat now so considering switching to csharp and xamarin
16:52:53 <benzrf> like a preceding @ or something, i dunno
16:52:55 <maggern> Thought I'd stop by haskell first though :)
16:53:18 <stolaruk> maggern: U are interested in learning Haskell?
16:53:19 <benzrf> i.e. if i use '@foo' where foo is an int, it will automatically be wrapped in the newtype that the value would be inferred as
16:53:31 <benzrf> if inference produces no such expectation, it errors
16:53:41 <jle`> benzrf: i think there are some libraries (and lens) that allow that as just a function
16:53:44 <stolaruk> benzrf: Can't you just pattern match on the newtype constructor?
16:53:44 <jle`> wrap foo
16:53:44 <maggern> Well I've heard good stuff about it before
16:54:11 <jle`> wrap :: a -> newtype containing a based on inference
16:54:33 <stolaruk> maggern: Consider reading Learn You A Haskell
16:55:20 <benzrf> jle`: :-O
16:55:28 <jle`> benzrf: it's in the newtype package, and also lens
16:55:29 <benzrf> i would also like unwrapping pls
16:55:30 <benzrf> thx
16:55:33 <jle`> it has unwrap too
16:55:34 <benzrf> :t wrap
16:55:34 <lambdabot> Not in scope: ‘wrap’
16:55:39 <rasfar> dfeuer: one little detail -- there is a semantic difference; if you look at the docs for Data.List.inits, it is supposed to be
16:55:48 <jle`> those aren't the exact names, heh.
16:55:53 <rasfar> inits (undefined::[Int]) = [] : undefined
16:56:01 <benzrf> seriously though, some kind of 1-char syntax would be ideal for that
16:56:08 <rasfar> this is probably remediable, just thought I'd mention
16:56:13 <jle`> > view _Wrapped' 3 :: Sum Int
16:56:15 <lambdabot>  Couldn't match type ‘Control.Lens.Wrapped.Unwrapped a0’
16:56:15 <lambdabot>                with ‘Data.Monoid.Sum GHC.Types.Int’
16:56:15 <lambdabot>  The type variable ‘a0’ is ambiguous
16:56:15 <lambdabot>  Expected type: Control.Lens.Getter.Getting
16:56:15 <lambdabot>                   (Data.Monoid.Sum GHC.Types.Int) a0 (Data.Monoid.Sum GHC.Typ...
16:56:20 <benzrf> it could make working with type wrappers nonclunky enough to be worthwhile!
16:56:20 <jle`> > review _Wrapped' 3 :: Sum Int
16:56:21 <lambdabot>  Sum {getSum = 3}
16:56:29 <benzrf> :O
16:56:32 <benzrf> :t _Wrapped
16:56:33 <lambdabot> (Rewrapped t s, Rewrapped s t, Profunctor p, Functor f) => p (Unwrapped s) (f (Unwrapped t)) -> p s (f t)
16:56:38 <benzrf> :t _Wrapped'
16:56:39 <lambdabot> (Wrapped s, Profunctor p, Functor f) => p (Unwrapped s) (f (Unwrapped s)) -> p s (f s)
16:56:45 <jle`> i don't know the operator form of review
16:57:06 <jle`> > 3 ^? from _Wrapped'
16:57:08 <lambdabot>  No instance for (GHC.Show.Show t0)
16:57:08 <lambdabot>    arising from a use of ‘M17484298408112077021992.show_M17484298408112077021...
16:57:08 <lambdabot>  The type variable ‘t0’ is ambiguous
16:57:08 <lambdabot>  Note: there are several potential instances:
16:57:08 <lambdabot>    instance [safe] GHC.Show.Show
16:57:11 <jle`> > 3 ^? from _Wrapped' :: Sum Int
16:57:13 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Sum GHC.Types.Int’
16:57:13 <lambdabot>              with actual type ‘Data.Maybe.Maybe t0’
16:57:24 <zq> is it non-idiomatic to use fail?
16:57:39 <jle`> > 3 ^. from _Wrapped' :: Sum Int
16:57:40 <lambdabot>  Sum {getSum = 3}
16:57:55 <jle`> > Sum 3 ^. _Wrapped'
16:57:57 <lambdabot>  3
16:58:02 <lovesoda> hello. is this the right channel to get my editor (emacs) up and running with haskell?
16:58:06 <jle`> zq: it depends on the context, but usually yes
16:58:30 <jle`> lovesoda: ask away :)
16:58:33 <rasfar> oops, I forgot to use @tell
16:58:57 <maggern> stolaruk: I'm not really into books... my young mind tend to fall of the wagon reading books.. :/
16:58:59 <dfeuer> rasfar: I believe mine does that too. Try print $ head $ inits (undefined::[Int])
16:59:02 <jle`> :t review _Wrapped'
16:59:03 <lambdabot> (Wrapped t, MonadReader (Unwrapped t) m) => m t
16:59:26 <jle`> @let wrap = review _Wrapped'
16:59:27 <lambdabot>  Defined.
16:59:31 <jle`> > wrap 3 :: Sum Int
16:59:33 <lambdabot>  Sum {getSum = 3}
16:59:45 <jle`> > wrap True :: Any
16:59:47 <lambdabot>  Any {getAny = True}
17:00:04 <rasfar> I tried print $ inits (undefined::[Int]) and the difference is evident from that, but it's silly for me to discuss before I've digested your algorithm
17:00:23 <jle`> oh from _Wrapped' is _Unwrapped'
17:00:40 <dfeuer> rasfar, when I tried it, it gave me []. What did it give you?
17:01:06 <jle`> so you can use view _Unwrapped' instead of review _Wrapped'
17:01:25 <rasfar> actually maybe not -- I tried the Data.List one in ghci
17:01:48 <rasfar> it prints partial output before the exception, but the compiled version using print probably doesn't
17:01:50 <Kaidelong> with libraries like Lens, who needs languages?
17:01:55 <jle`> ...what is _Wrapped?
17:02:02 <jle`> > view _Unwrapped 3 :: Sum Int
17:02:04 <lambdabot>  Sum {getSum = 3}
17:02:06 <jle`> oh
17:02:13 <rasfar> so never mind -- you're ok then I expect
17:02:20 <jle`> what's the difference between _Unwrapped and _Unwrapped' then.  i do not know
17:02:25 <Kaidelong> (me, I'm wondering if there is any effort to properly sugar these libraries)
17:02:27 <dfeuer> Oh, sorry. rasfar, that's always going to be shady. You should take the head, then print. When errors happen they can muck with output buffering.
17:02:38 <Kaidelong> (like what happened for arrow)
17:02:51 <rasfar> right, i will remember that
17:02:56 <jle`> lens is its own synatic sugar :P
17:03:09 <Kaidelong> it's pretty unreadable
17:03:24 <jle`> and adding more syntax would make it more readable?
17:03:30 <Kaidelong> I think so, yes
17:03:39 <Kaidelong> that is afterall why I don't use lisp
17:03:52 <jle`> hm.  i think one of the reasons lens was written was so that we have accessors and modifiers be first class members of the language
17:03:57 <jle`> instead of syntax
17:04:07 <Kaidelong> the two aren't mutually exclusive
17:04:20 <Kaidelong> something can be syntactically special but also first class
17:04:51 <lovesoda> jle`: do I need to upgrade my emacs (23.3.1) or haskell-mode (2.8) to get structured-haskell-mode working? I am getting weird errors. basically nothing works if I have it enabled, not even typing text into emacs. let me try enabling it again so I can give exact error I am getting
17:05:02 <jle`> lovesoda: oh, i don't know anything about emacs, but you can ask people here :)
17:05:08 <jle`> Kaidelong: can you give an example>
17:05:11 <jle`> ?
17:05:30 <jle`> also, i'm not sure why view _Wrapped (Sum 3) == 3 is unreadable
17:05:32 <Kaidelong> jle`: haskell strings
17:05:32 <lovesoda> jle`: ok :)
17:05:43 <jle`> i'd prefer normal functions to syntax whenever possible
17:05:46 <jle`> > view _Wrapped (Sum 3)
17:05:48 <lambdabot>  3
17:06:06 <Kaidelong> well what does that mean
17:06:17 <jle`> it means view the wrapped value in Sum 3
17:06:20 <Kaidelong> is it something like 3.Wrapped(Sum)?
17:06:56 <jle`> it's just literally a function
17:07:01 <jle`> view _Wrapped :: Sum a -> a
17:07:18 <Kaidelong> @type view
17:07:19 <lambdabot> MonadReader s m => Getting a s a -> m a
17:08:03 <Kaidelong> wait doesn't this mean the result should be Identity 3 and not 3?
17:08:17 <jle`> i'm using the instance here
17:08:20 <jle`> er
17:08:22 <jle`> the (-.) instance
17:08:24 <jle`> ->
17:08:39 <jle`> Getting a s a -> (s -> a)
17:08:52 <jle`> "give me something that gets an a from s, and i'll give you a function (s -> a)"
17:09:01 <Kaidelong> oh I see
17:09:10 <Kaidelong> -> is trivially an instance of MonadReader
17:09:30 <Kaidelong> then you just use the right associativity of (->) and apply one extra argument to view
17:09:31 <jle`> well, s -> a is an instance of MonadReader s a
17:09:45 <jle`> but yeah
17:09:50 <jle`> i like leaving the parentheses in it though
17:09:51 <Kaidelong> it's the canonical instance of MonadReader
17:10:17 <jle`> thinking of (view _Wrapped) as returning a Sum a -> a
17:10:20 <Kaidelong> I guess that should have been more obvious
17:10:30 <isomorpheous> @src ($)
17:10:30 <lambdabot> f $ x = f x
17:10:31 <jle`> > (view _Wrapped) (Sum 3)
17:10:32 <lambdabot>  3
17:10:37 <Kaidelong> my mind just immediately goes "IdentityT" when I see that "MonadFoo" pattern
17:10:41 <jle`> ah
17:10:57 <isomorpheous> @src (.)
17:10:57 <lambdabot> (f . g) x = f (g x)
17:10:57 <lambdabot> NB: In lambdabot,  (.) = fmap
17:11:10 <jle`> yeah :)  i am not very happy with the overly polymorphic type signatures of a lot of the lens functions, they aren't really accessible without looking into it deeper
17:11:21 <jle`> it's not something a new lens person will immediately find intuitive
17:11:37 <Kaidelong> well the important thing about lens is how polymorphic it is
17:11:39 <jle`> so...i guess there is somewhere to improve somehow there
17:11:42 <jle`> yeah, exactly
17:11:45 <jle`> well
17:11:51 <jle`> maybe
17:11:58 <jle`> yeah
17:12:05 <Kaidelong> trying to make it more monomorphic for pedagogy would defeat the purpose of being able to keep using lens when working in contexts other than pure code
17:12:46 <jle`> what's missing is not less polymorphism but magic type signatures
17:12:57 <jle`> that specialize based on what the viewer is comfortable with/needs
17:14:07 <maggern> Is there any good haskell video tutorials out there?
17:14:40 <jle`> maggern: i like that chalmers video series
17:14:57 <benzrf> IdentityT is my favorite monad transformer!!!
17:14:58 <Kaidelong> but perhaps a separate pedagogic lens library with more monomorphism would be a worthy endeavour
17:14:58 <Kaidelong> kind of like helium vs haskell
17:14:58 <Kaidelong> the thing that most annoys me about haskell types is that they can leak information at least in the case of functional dependencies and expose things the programmer doesn't carry about
17:14:58 <Kaidelong> like you can end up with functions that do things like (Foo a b) => a -> a
17:15:10 <benzrf> :t (>>=) `asAppliedTo` Identity 3
17:15:11 <lambdabot> Num a => Identity a -> (a -> Identity b) -> Identity b
17:15:14 <jle`> there's also a couple of nice video tutorials on youtube if you aren't a fan of lectures
17:15:22 <Kaidelong> the programmer doesn't have to care about what b is, just the people implementing the Foo instance
17:15:42 <Kaidelong> but the programmer still gets forced to boggle over what a b is as he types it in
17:15:44 <jle`> maggern: http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
17:16:19 <jle`> i think error messages and related things can definitely leak abstractions, defeating the purpose of a lot of what the abstractions were meant to do in the first place
17:16:23 <benzrf> > view _Wrapped (Just 3)
17:16:24 <lambdabot>  Could not deduce (Control.Lens.Wrapped.Unwrapped
17:16:24 <lambdabot>                      (Data.Maybe.Maybe a0)
17:16:24 <lambdabot>                    ~ Control.Lens.Wrapped.Unwrapped (Data.Maybe.Maybe a))
17:16:24 <lambdabot>  from the context (Control.Lens.Wrapped.Rewrapped
17:16:24 <lambdabot>                      (Data.Maybe.Maybe a) (Data.Maybe.Maybe a),
17:16:30 <benzrf> er derp
17:16:33 <benzrf> > view _Wrapped (Sum 3)
17:16:34 <lambdabot>  3
17:16:36 <benzrf> this seems wrong
17:16:42 <jle`> Maybe is not a newtype ;)
17:16:50 <benzrf> indeed >_>
17:16:51 <jle`> > view _Unwrapped 3 :: Sum Int
17:16:52 <lambdabot>  Sum {getSum = 3}
17:17:24 <Kaidelong> I also think final definitions of data types are better than initial definitions for the same reasons, they're less likely to leak abstractions and better at hiding things, but haskell handles that pretty well, you don't have to export all your constructors and that goes a long way to getting some abstraction back
17:18:29 <Kaidelong> also I guess it's not clear how to do pattern matching on final definitions and pattern matching is neat
17:18:30 <jle`> a lot of libraries use abstraction-through-type-synonyms
17:18:46 <jle`> pipes and conduit use this to a large extent
17:18:47 <dfeuer> rasfar: another interesting exercise would be rewriting my implementation without the compositions and (:) sections, and replacing the outer map ($[]) with map reverse. I don't know how that would compare.
17:18:48 <jle`> lens too i think
17:19:13 <Kaidelong> it should be permitted to make type synonyms that require fewer polymorphic parameters on the left than on the right
17:19:35 <maggern> https://www.youtube.com/watch?v=iSmkqocn0oQ
17:19:45 <Kaidelong> they can be admitted in situations where functional dependencies resolve the ambiguity or where RankNTypes are allowed and your function really is completely polymorphic in the unlisted parameter
17:19:51 <dfeuer> I doubt the reversing would win, but it wouldn't hurt to check.
17:20:08 <Kaidelong> Foo a = Bar a b
17:20:11 <Kaidelong> should be allowed
17:20:18 <Kaidelong> type Foo a = Bar a b *
17:20:33 <Kaidelong> forall b. Bar a b
17:20:34 <Kaidelong> anyway
17:20:40 <jle`> well that is allowed, isn't it?
17:20:45 <Kaidelong> actually does RankNTypes let you do that?
17:20:47 <Kaidelong> maybe it already does
17:21:03 <jle`> yeah
17:21:28 <Kaidelong> mmm does RankNTypes completely subsume ExistentialQuantification?
17:21:32 <jle`> @let type NatTrans f g = forall a. f a -> g a
17:21:33 <lambdabot>  Defined.
17:21:40 <jle`> this is different from existential quantification
17:22:01 <jle`> type synonyms are more or less just...well..type synonyms
17:22:14 <rasfar> hi dfeuer, I'm just working it out -- I've got the types of all the pieces.  I like this kind of combinator code, but I am pretty slow at it and don't practise enough. this is a great exercise, thank you.
17:22:26 <jle`> so if you see f :: NatTrans x y -> z, it is just expanded into f :: (forall a. x a -> y a) -> z
17:22:30 <Kaidelong> a -> (forall b. C b) is equivalent to exists b. a -> C b, I thought?
17:22:49 <jle`> the latter is just RankNTypes
17:22:54 <jle`> the later f ::, that is
17:22:58 <rasfar> if i can make the change you suggested above, i'll know i "got it" heh
17:23:46 <jle`> i mean, i think it's similar to the concept, but it wouldn't need the extension, because it's pretty much just nothing more than RankNTypes
17:24:16 <Kaidelong> well I was wondering if ExistentialQuantification is even neccessary if you have RankNTypes
17:24:32 <jle`> not for this case, but for data types i think you need it
17:24:34 <Kaidelong> as in, if there's some mechanical translation you could make
17:24:44 <JoeyA> Is a Haskell Platform with GHC 7.8.3 going to be released soon?
17:25:11 <jle`> yeah, you need existential quantification for newtypes or data
17:25:18 <jle`> i don't think you can get around it
17:25:27 <jle`> that for GADTs
17:25:59 <Kaidelong> the need for GADTs just occured to me
17:33:38 <dfeuer> rasfar, I'm pretty terrible at it too. I put it together bit by bit and magically it worked.
17:34:33 <rasfar> it's very neat. i'm inlining the code for scanl to help reason about it, and I think I see how your non-reverse version works. i'm still puzzling over how to change it to the reverse version.
17:34:43 <rasfar> if you'd like to just spell it out, i can check the perf...
17:41:59 * rasfar is gone for 10-15 min.
17:43:17 <dfeuer> @tell rasfar I'll try it later. The idea is that instead of a function that prepends items, you can store a list of those items *backwards*.
17:43:17 <lambdabot> Consider it noted.
17:54:27 <rudi_s> Hi. I'm using NCurses and want to display a list of strings, each in one line. For this I have to call moveCursor 0 y, drawString l where y is the column and l the line. I could handle that with explicit recursion, but is there a more functional style to "iterate" over a list while keeping some state (the index) while in a monad (IO in this case)? Thanks.
17:54:43 <rudi_s> s/column/row/
17:55:28 <roboguy_> rudi_s: what about mapM?
17:55:39 <roboguy_> :t mapM
17:55:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:56:09 <rudi_s> roboguy_: But I still need the index in each loop.
17:56:17 <rudi_s> s/loop/iteration/
17:56:34 <roboguy_> how about
17:56:36 <roboguy_> :t zipWithM
17:56:37 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:56:51 <roboguy_> like zipWithM moveCursor [1..] yourList
17:57:01 <roboguy_> or [0..]
17:57:50 <RchrdB> rudi_s, are you always advancing by exactly one line or sometimes by multiple lines due to line-wrapping?
17:57:58 <rudi_s> roboguy_: Hm, that looks good, thanks. - But I'm curious, is there a general way to keep state or would I have to wrap the monad into e.g. the state monad.
17:58:09 <rudi_s> RchrdB: For now just one line, but could be more than one in the future.
17:58:20 <roboguy_> rudi_s: I'm not sure what you mean... a monad *is* the general way to keep state
17:58:36 <RchrdB> If you're always advancing by one exactly one line then zipping with the indices and then mapM_ is the nicest way of doing it.
17:58:42 <dwcook> rudi_s, you can "keep state" exactly the same way State "keeps state". State s a is nothing more than just s -> (a, s), really.
17:59:14 <rudi_s> roboguy_: Still a Haskell newbie, so I'm a little confused.
17:59:22 <dwcook> I think what roboguy_ said is misleading.
17:59:38 <roboguy_> actually, yeah now that I think about it, it probably is
17:59:39 <rudi_s> So if I need more complex state, I'd use the state monad to add state?
17:59:56 <RchrdB> StateT, with "get" and "put" actions is the least-painful way of running a simple piece of state like this.
18:00:03 <dwcook> rudi_s, you can use State, or you can do it yourself just by introducing a function parameter.
18:00:15 <rudi_s> RchrdB: Thank you, good to know.
18:00:19 <rudi_s> dwcook: Thanks.
18:00:20 <RchrdB> in more complicated scenarios, you can use an IORef.
18:00:40 <RchrdB> e.g. if the mutable state has a long lifetie.
18:00:58 <rudi_s> I'll use the zipWith solution for now, but will keep the other solutions in mind. Thank you all.
18:01:21 <dwcook> main = countLines 0 ; countLines n = do { putStrLn "You've written " ++ show n ++ " lines." ; getLine ; countLines (n + 1) } -- contrived example of "keeping state"
18:01:59 <dwcook> Woops, I messed up somewhere in there
18:02:12 <dwcook> Oh of course
18:02:26 <dwcook> main = countLines 0 ; countLines n = do { putStrLn ("You've written " ++ show n ++ " lines.") ; getLine ; countLines (n + 1) }
18:02:56 <dwcook> That can be run as-is and is an example of explicitly keeping track of "state" through a function parameter
18:03:46 <rudi_s> Thanks.
18:04:57 <rasfar> Is it possible to use a class method (other than Data/Typeable) in a SYB traversal? http://lpaste.net/107723
18:12:19 <RchrdB> rudi_s, a StateT version might look like: let countLines = do { n <- get; lift (putStrLn ("You've written " ++ show n ++ " lines.")); lift getLine; put (n + 1); countLines; } in runStateT countLines 0
18:13:08 <RchrdB> monad transformers are nice provided you don't mind having to write "lift" quite often.
18:14:56 <rudi_s> RchrdB: Thank you.
18:18:22 <Axman6> RchrdB: that can be written with a single lift
18:18:43 <dwcook> lift a >> lift b = lift (a >> b)
18:22:06 <Algebr`> anyone from haskell community as hopex?
18:22:09 <Algebr`> at*
18:25:08 <rasfar> @tell dfeuer if you mean:  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)
18:25:09 <lambdabot> Consider it noted.
18:25:37 <rasfar> @tell dfeuer: -- inits0 : 18.221u 0.320s 0:18.65 99.4%     0+0k 0+8io 0pf+0w
18:25:37 <lambdabot> Consider it noted.
18:25:38 <rasfar> -- inits1 :  7.448u 0.448s 0:08.00 98.5%     0+0k 0+2088io 0pf+0w
18:25:38 <rasfar> -- inits2 :  2.948u 0.196s 0:03.32 94.2%     0+0k 16+16io 1pf+0w
18:26:14 <rasfar> @tell dfeuer: so the reverse version appears even faster -- I wonder if I'm benchmarking this correctly at this point...
18:26:14 <lambdabot> Consider it noted.
18:28:56 <dfeuer> rasfar: something like that, anyway. Did you test it for correctness? It doesn't surprise me too much that it could be faster.
18:29:31 <rasfar> > let  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)  in  inits2 [1::Int .. 5]
18:29:32 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
18:29:48 <rasfar> that's as far as I got testing correctness :)
18:29:59 <rasfar> doing a larger test now
18:30:13 <dfeuer> Heh. You'll get there. Don't forget laziness tests.
18:30:27 <Exio> @src (++)
18:30:27 <lambdabot> []     ++ ys = ys
18:30:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:30:27 <lambdabot> -- OR
18:30:27 <lambdabot> xs ++ ys = foldr (:) ys xs
18:31:09 <rasfar> > let  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)  in  take 5 (inits2 [1::Int ..])
18:31:11 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
18:31:42 <rasfar> > let  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)  in  head (undefined::[Int])
18:31:43 <lambdabot>  *Exception: Prelude.undefined
18:32:14 <rasfar> > let  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)  in  head (inits2 (undefined::[Int]))
18:32:15 <lambdabot>  []
18:32:19 <rasfar> whew
18:34:18 <dfeuer> Heh.
18:36:06 <rasfar> -- For print $ sum $ map length $ inits1 [(1::Int)..20000]
18:36:06 <rasfar> --  inits0 : over two minutes...
18:36:06 <rasfar> --  inits1 : 21.449u 0.160s 0:21.71 99.4%    0+0k 0+0io 0pf+0w
18:36:06 <rasfar> --  inits2 : 9.904u 0.084s 0:10.03 99.5%     0+0k 0+0io 0pf+0w
18:36:17 <mietek> What exactly is fixIO used for?
18:36:47 <augur_> Lt fixIO
18:36:48 <augur_> ..
18:36:49 <rasfar> inits0 being the Data.List version ; inits1 being your list-of-functions version; and inits2 being the reverse version as per above
18:36:50 <mietek> I'm trying to understand https://github.com/haskell-distributed/distributed-process-simplelocalnet/blob/master/src/Control/Distributed/Process/Backend/SimpleLocalnet.hs#L179-L186
18:36:51 <benzrf> @http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/
18:36:51 <lambdabot> Unknown command, try @list
18:36:51 <augur_> :t fixIO
18:36:52 <lambdabot> Not in scope: ‘fixIO’
18:36:53 <benzrf> oops wrong link
18:37:01 <augur_> :(
18:37:04 <augur_> @hoogle fixIO
18:37:06 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
18:37:11 <benzrf> @let  inits2 xs = map reverse (scanl q [] xs) where q ls x = (x:ls)
18:37:12 <lambdabot>  Defined.
18:37:29 <augur_> > fixIO return
18:37:30 <lambdabot>  Not in scope: ‘fixIO’
18:37:35 <benzrf> @check \l -> False-- condition?
18:37:36 <mietek> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/System-IO.html#fixIO
18:37:36 <lambdabot>  <hint>:1:53:
18:37:37 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
18:37:40 <benzrf> @check \l -> False -- condition?
18:37:42 <lambdabot>  <hint>:1:54:
18:37:42 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
18:37:49 <benzrf> wot ever
18:38:34 <mietek> It's really confusing.
18:38:35 <dfeuer> rasfar, I'll try to figure out how to whip up some nice formal benchmarks when I get home. The big Haskell benchmarker, whatever it's called, has some special tricks to avoid compiler trickiness.
18:38:49 <dfeuer> (Starts with a C)
18:39:00 <mietek> Probably the one function which could really use a documentation comment.
18:39:47 <rasfar> Criterion?
18:39:56 <rasfar> (never used it yet personally)
18:40:30 <Kazagistar> @check \x -> False
18:40:32 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:40:32 <lambdabot>  ()
18:40:40 <rasfar> i used to rant about how Haskell was so slow, but this round I'm having zero problems with that once leaks get plugged
18:40:42 <dfeuer> Yeah, that! Criterion.Main.defaultmain
18:41:28 <flebron> Hey folks. What would you guys recommend for a CS person to understand categories? (Curiously this isn't for me, but someone asked me and I notice I don't remember where I learned it from anymore). I have Eugenia Cheng's catsters, Typeclassopedia for Haskell's case, Awodey's book & course on the oregon programming languages summer school, and some bartosz milewski's posts on haskell-category-theory-stuff.
18:41:30 <copumpkin> @check \xs -> reverse xs == xs
18:41:30 <flebron> Anything big/useful I'm missing?
18:41:32 <lambdabot>  +++ OK, passed 100 tests.
18:41:43 <rasfar> then again it's been so long since I coded anything in C that maybe just adapted my expectations
18:41:58 <flebron> Oh, and I'm recommending they come to ##haskell and ask questions, since that's definitely something I used.
18:42:26 <dfeuer> Flebron, look at the IRC logs from yesterday.
18:42:43 <dfeuer> Edwardk posted a link to a blog post he made about that.
18:42:47 <flebron> About this hour or so?
18:42:58 <flebron> Ah, cool. Figures ekmett would have something :p
18:43:15 <dfeuer> I don't remember! Just look for edwardk.*Category
18:43:39 <Kazagistar> flebron: so far, catsters is a struggle for me, because I am utterly unfamiliar with the example categories, but there is a "linear order" for catsters here http://byorgey.wordpress.com/catsters-guide-2/
18:43:41 <dfeuer> For the last 48 hours.
18:44:11 <flebron> Yeah I saw that order :) Thanks Kazagistar
18:44:52 <rasfar> flebron: we used this text in a grad course on CT, which seems to be freely available now: www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
18:45:58 <rasfar> (it's an introductory text which assumes no prior knowledge IIRC)
18:46:26 <Kazagistar> but yeah, it kinda sucks when the examples are "the empty space in the category of topological spaces" and "the disjunctive union of sets" and I have to go dig around to figure it out cause I dont know math :/
18:46:30 <copumpkin> their lecture notes are pretty good too
18:48:12 <flebron> copumpkin: http://synrc.com/publications/cat/Category%20Theory/General%20Theory/Barr,%20Wells.%20Category%20Theory.pdf ?
18:48:29 <copumpkin> yup
18:48:31 <Hodapp> free textbooks! I live free textbooks!
18:48:35 <Hodapp> sometimes I even read them!
18:48:42 <copumpkin> their TTT book is also pretty good, but fancier
18:48:49 <copumpkin> toposes triples and theories
18:48:51 <Kazagistar> and I guess since catagory theory is concerned with "classification", people with weak math backgrounds in general will not be able to make much of the things that are being classified?
18:49:31 <flebron> Well I think a usual problem is the lack of examples to form your intuition on. From the CS side, a lot of topological constructions will seem quite alien.
18:49:56 <flebron> Say, the germ construction of a colimit.
18:51:19 <Kazagistar> all of the courses I have found online have been really really difficult to follow because they might spit out five examples, and then I spend half an hour just to figure out what the simplest one means from wikipedia or something
18:52:26 <roboguy_> flebron: this isn't exactly category theory (entirely anyway), but I just got a copy of hott and it looks pretty interesting so far
18:53:41 <Hodapp> HoTT is on my list of things to read, but I have so much to try to understand first
18:54:26 <rasfar> I really need to know whether this is a dead end or not -- I worked on this all day yesterday
18:54:29 <rasfar> Is it possible to use a class method (other than Data/Typeable) in a SYB traversal? http://lpaste.net/107723
18:54:37 <Maxdamantus> is category theory the next metaphorical synonym with brain surgery and rocket science?
18:54:47 <rasfar> another day of that and i think i'll need medical attention
18:55:14 <trap_exit> Anyone feel that Haskell raise their IQ by atleast 80 points? I'm looking my Haskell code and thinking (1) there's no way I could write this in a language w/o Haskell's type system and (2) only a genius could write this simple Haskell program in a non-Haskell langauge
18:56:02 <rasfar> please folks with knowledge ... this is my only question for a while .....
18:57:19 <copumpkin> rasfar: if you have a fixed universe of things, yeah
18:57:23 <roboguy_> Kazagistar: disjoint union isn't so bad. and, for now, I just settle for a general idea of topological spaces as being "continuous spaces" with continuous maps between them (and that the idea of continuity is formed with a subset structure ultimately)
18:57:39 <trap_exit> rasfar: what's your question?
18:57:53 <rasfar> trap_exit: Is it possible to use a class method (other than Data/Typeable) in a SYB traversal? http://lpaste.net/107723
18:58:19 <rasfar> copumpkin: isn't a universe the space of all values in a type?
18:58:39 <roboguy_> rasfar: that's a type isn't it?
18:58:43 <Kazagistar> roboguy_: I mean, I can figure out disjoint union. But if I have no existing intuition about the properties of the examples, I struggle to build intuition about the abstraction
18:58:44 <rasfar> well i can look that up; what I should be asking you is, do you have a suggestion how you would do it?
18:58:56 <copumpkin> rasfar: I mean, a fixed collection of types you want to use
18:59:41 <rasfar> oh ... well, I have the base types including list tuple etc. covered, but was hoping to also write a GHC.Generics deriving class to back it
18:59:51 <roboguy_> Kazagistar: yeah, I run into that problem too. I keep coming back to it though (rewatching catsters videos and rereading parts of books) after some time as passed. It starts to make more sense. That's actually the way I first learned to program
18:59:53 <rasfar> (which i've basically done already)
18:59:55 <Kazagistar> roboguy_: the regular audience has presumably used disjoint unions, thought about them, written and seen the notation, and maybe even done a homework problem or proof related to them, or at least to one of the examples
19:00:08 <copumpkin> rasfar: then I wouldn't expect it to be possible
19:00:31 <copumpkin> rasfar: in a semi-fundamental way
19:00:32 <rasfar> its a shame. if i hack Data.Data and add my Foo constraint, it works
19:01:00 <rasfar> if there was some way to use a cast to tell GHC a value was an instance of a class...
19:01:11 <copumpkin> I'm thinking just in terms of how that would work
19:01:17 <copumpkin> and I don't know of any way it could work
19:01:23 <copumpkin> even if you could express the type of such a thing
19:01:28 <copumpkin> (just implementation-wise)
19:01:34 <roboguy_> Kazagistar: yeah. it can feel like trying to learn Hungarian from a Hungarian dictionary
19:01:36 <copumpkin> might be missing something
19:01:36 <rasfar> then I could drop the constraint on the function (test), and "cast" it only where it's really needed
19:02:11 <copumpkin> you're sort of asking it to do some of that dictionary resolution that happens at compile time, at runtime
19:02:43 <rasfar> yes, I guess I am (thank you very much for your comments copumpkin)
19:02:53 <Kazagistar> roboguy_: I guess the hope at the end of the tunnel is that everyone in Hungary does not even have a Hungarian dictionary when they learn their for their first time, and eventually them manage it
19:03:07 <rasfar> it strikes me as a fairly serious limitation
19:03:17 <roboguy_> Kazagistar: haha, yeah
19:03:23 <copumpkin> rasfar: really?
19:03:38 <copumpkin> rasfar: any concrete types you want, you can get out of the Typeable
19:03:39 <rasfar> to not be able to use any class methods with generics? yeah
19:04:15 <copumpkin> hm
19:04:17 <copumpkin> I dunno
19:04:20 <rasfar> see I absolutely need to be able to call the foo class method of Foo
19:04:39 <copumpkin> look at the new library generics-sop
19:04:41 <rasfar> I will try another generics library then
19:04:43 <copumpkin> that should support it
19:04:50 <copumpkin> and is a much more pleasant experience imo
19:05:09 <rasfar> i was thinking maybe SYB-with-Class (which is now in base I think?) might help, but doubtful
19:05:18 <rasfar> thanks for the tip, I will check generics-sop for sure
19:05:20 <copumpkin> (I might just think so because I reinvented the same thing independently)
19:05:29 <copumpkin> (but I do think it's the nicest generics approach I've seen yet)
19:05:57 <carlosgaldino> what's the fixity of `(:)`?
19:06:02 <rasfar> I have like 20 papers on generics and the comparisons of generics libs for Haskell, there's been a lot of work over the last 15 years whew!
19:06:05 <copumpkin> :i (;)
19:06:10 <copumpkin> :info (:)
19:06:19 <copumpkin> rasfar: this one just came out!
19:06:36 <copumpkin> carlosgaldino: infixr 5 :
19:06:43 <rasfar> when did you independently invent it?
19:06:43 <copumpkin> carlosgaldino: type :i (:) in ghci
19:06:49 <roboguy_> copumpkin: they really should add that to lambdabot
19:06:56 <rasfar> data [] a = ... | a : [a]       -- Defined in GHC.Types
19:06:57 <rasfar> infixr 5 :
19:07:21 <copumpkin> rasfar: over the past few months, then posted it to twitter, upon which someone said "that looks awfully similar to this work by so-and-so, who hadn't published it at that point"
19:07:24 <copumpkin> :)
19:07:33 <copumpkin> then they published it and it's indeed very similar
19:07:37 <carlosgaldino> copumpkin:thanks
19:07:37 <rasfar> zeitgeist
19:07:38 <copumpkin> they took it a lot farther than I did
19:10:15 * Hodapp sits down, tea in hand, to have another go at progressing in the "Hasochism" paper.
19:11:02 <rasfar> I see it uses TH, but this isn't the Template Your Boilerplate folks is it? (rhetorical; reading...)
19:17:23 <edwardk> dfeuer: i don't have a blog post on this stuff yet, but i did give a talk
19:22:39 <Algebr`> Playing with ocaml, with basically this example, ocaml didn't let me compile, but ghc compiles and gives a runtime exception, of course. Any flag I can do to prevent this? already using the :set -W. http://lpaste.net/107734
19:23:57 <roboguy_> Algebr`: what do you want it to do?
19:24:37 <benzrf> Algebr`: youre doing it wrong
19:24:51 <roboguy_> oh, do you want it to give a compile time error?
19:24:52 <benzrf> that's a sum type, the whole point is that the compiler doesnt know which branch of the sum you use
19:24:58 <benzrf> Algebr`: make them different types
19:25:44 <Algebr`> yes, I want a compile time error.
19:25:56 <roboguy_> yeah, they should probably be different types
19:26:45 <roboguy_> or you could probably use a phantom type parameter and a gadt
19:30:16 <SrPx> I think `Couldn't match expected type `[a0]' with actual type `Char'` should be replaced with something that clearly states what was the expected type and what was the actual type...
19:30:48 <RchrdB> SrPx, unfortunately, those are the expected and actual types.
19:31:18 <Maxdamantus> > [1, 2, 3] :: Char
19:31:20 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
19:31:20 <lambdabot>              with actual type ‘[t0]’
19:31:30 <Maxdamantus> > [1 :: Integer, 2, 3] :: Char
19:31:31 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
19:31:32 <lambdabot>              with actual type ‘[GHC.Integer.Type.Integer]’
19:31:33 <RchrdB> GHC has in that case gone looking for a Char and inferred a list of something, though it hasn't inferred a concrete type for what's in the list, so it's used a type variable to refer to the unknown.
19:31:53 <Maxdamantus> The `a0` is probably there because it's parametric.
19:32:05 <SrPx> Pardon, what I mean is that "with actual type" part always confuses me. I somehow read it as "that is the actual type it should have, you idiot"
19:32:28 <RchrdB> er
19:32:42 <geekosaur> vs. "expected"?
19:32:52 <SrPx> the phrase is not ambiguous
19:33:14 <Maxdamantus> in Idris, it just says it can't unify the two things.
19:33:38 <RchrdB> "actual type" is the one that it did infer, "expected type" is the type that it was expecting to infer.
19:33:40 * Maxdamantus doesn't know what "expected" and "actual" mean tbh
19:34:10 <SrPx> Maybe it is just me, it is just that something about that phrase makes me always have to consciously read it to understand what is what
19:34:32 <SrPx> Whereas with clang somehow I don't have to make that effort... format specifies type 'unsigned int' but the argument has type 'double'
19:34:38 <SrPx> but maybe it is a single experience then :P
19:35:15 <rasfar> I think the problem is more "expected" than "actual" -- who expects it? you or the compiler? it is "actual" which disambiguates that for me
19:35:44 <roboguy_> I still have to think about the phrasing sometimes too, actually
19:35:46 <SrPx> but actual is exactly what confuses me. what is the actual type, the type it should have, or the wrong type you gave it?
19:35:46 <Maxdamantus> > [1 :: Int, 2 :: Integer]
19:35:48 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:35:48 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
19:35:55 <Maxdamantus> > [1 :: Integer, 2 :: Int]
19:35:56 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
19:35:56 <lambdabot>              with actual type ‘GHC.Types.Int’
19:36:04 <Maxdamantus> Fun.
19:36:13 <Axman6> SrPx: it's the axctual type it has received. expected is what it expected to get
19:36:23 <roboguy_> > (1 :: Int) : ((2 :: Integer) : [])
19:36:25 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:36:25 <lambdabot>              with actual type ‘GHC.Integer.Type.Integer’
19:36:35 <roboguy_> Maxdamantus: I think it gets turned into that, essentially
19:36:41 <Maxdamantus> It seems like an internal issue to me.
19:36:54 <SrPx> to be fair, I'd pay to have it just say: `SHOULD BE TYPE: Int . YOU WROTE TYPE: Double. U DUMB. `
19:36:54 <Maxdamantus> There shouldn't be any formal meaning to the order.
19:37:17 <roboguy_> SrPx: well... it's not always that clear cut
19:37:36 <Axman6> expected type was: ... but the type provided was: ...
19:38:25 <roboguy_> yeah. I feel like the word "actual" is more the issue
19:38:36 <roboguy_> for me, at least
19:39:04 <Maxdamantus> > (undefined :: Int -> Double) (undefined :: Double)
19:39:05 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:39:06 <lambdabot>              with actual type ‘GHC.Types.Double’
19:39:12 <Maxdamantus> I imagine it simply comes down to that.
19:39:36 <SrPx> the "but" keyword in clang really helps a lot. "expected foo, but you used bar"
19:39:44 <roboguy_> > case (1 :: Int) of { 'a' -> undefined }
19:39:45 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:39:45 <lambdabot>              with actual type ‘GHC.Types.Char’
19:39:58 <Maxdamantus> it wants to call the type of the input to the function "expected" and the actual applicand "actual"
19:40:01 <rasfar> so "expected" is a typed hole (or so), and "actual" refers to a value?
19:40:55 <Maxdamantus> ie, the function there expects an int, but it's actually being given a double.
19:42:01 <rasfar> at least, i'm glad i'm not the only one who gets confused about that on occasion
19:42:02 <roboguy_> Maxdamantus: hmm, I'd expect "case" to work the same way (i.e., case x of ... being like calling a function with x as its argument) but it looks like it's the opposite
19:42:40 <Maxdamantus> roboguy_: maybe it's a bug.
19:42:50 <rasfar> but in the case example above, the error would be located on the 'a' I thing?
19:43:01 <rasfar> *think
19:43:47 <roboguy_> yeah, that's true
19:44:00 <Maxdamantus> Why?
19:44:08 <Maxdamantus> There shouldn't be any order to it.
19:44:23 <rasfar> this is part of the trickiness -- if the compiler decides to locate the error on the (1 :: Int) then "actual" and "expected" values will be swapped
19:44:24 <roboguy_> you're probably more likely to mess up one of the pattern matches than the thing your pattern matching on
19:45:15 <rasfar> there's a sort of precedence happening in the unifier (which, I just read on an SO question today, is a scary opqaue logic language...)
19:45:28 <Maxdamantus> > case undefined of { 'a' -> undefined; "a" -> undefined }
19:45:29 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
19:45:30 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:45:45 <roboguy_> rasfar: it's sort of like a prolog-type thing
19:45:51 <Maxdamantus> > case undefined of { "a" -> undefined; 'a' -> undefined }
19:45:52 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
19:45:52 <lambdabot>              with actual type ‘GHC.Types.Char’
19:46:06 <roboguy_> an ordering has to be decided at some point
19:46:15 <Maxdamantus> eh, that second one is obviously going to be flipped.
19:46:18 <rasfar> i just introduced my dad to prolog a couple days ago! :)
19:47:13 <mwhit> couldn't it just specify which expression corresponds to which instead of "expected' and "actual"? would be a lot clearer
19:47:14 <rasfar> Maxdamantus: yeah, but it's still interesting to see it -- who knows, maybe the order types are checked is based on types and not lexical flow!
19:47:26 <mwhit> and it has expression info below that already anyway
19:47:54 <Maxdamantus> mwhit: it doesn't necessarily correspond to a particular expression.
19:48:18 <carter> ghc does this when you compile though
19:48:31 <carter> telling you what the location was
19:48:37 <carter> and the source fragment
19:48:44 <Maxdamantus> > let a = "foo"; b = [1 :: Integer, 2, 3] in [a, b]
19:48:45 <lambdabot>  Couldn't match type ‘GHC.Integer.Type.Integer’
19:48:45 <lambdabot>                with ‘GHC.Types.Char’
19:48:45 <lambdabot>  Expected type: [GHC.Types.Char]
19:48:45 <lambdabot>    Actual type: [GHC.Integer.Type.Integer]
19:49:21 <rasfar> > let a = "foo"; b = [1 :: Integer, 2, 3] in [b, a]
19:49:22 <lambdabot>  Couldn't match type ‘GHC.Types.Char’
19:49:23 <lambdabot>                with ‘GHC.Integer.Type.Integer’
19:49:23 <lambdabot>  Expected type: [GHC.Integer.Type.Integer]
19:49:23 <lambdabot>    Actual type: [GHC.Types.Char]
19:49:27 <Maxdamantus> Mm. In that case it gave the upper unification which did correspond to particular expressions.
19:51:13 * hackagebot machinecell 1.2.0 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.2.0 (HidenoriAzuma)
19:51:18 <benzrf> hmm
19:51:50 <rasfar> sometimes the types match but the class constraints are different, and tracking down how constraints propagated can blur the expected/actual even more
19:52:07 <benzrf> :t fromEnum
19:52:08 <lambdabot> Enum a => a -> Int
19:52:24 <benzrf> :t \r i -> r !! fromEnum i
19:52:25 <lambdabot> Enum a1 => [a] -> a1 -> a
19:52:30 <benzrf> @pl \r i -> r !! fromEnum i
19:52:30 <lambdabot> (. fromEnum) . (!!)
19:52:34 <benzrf> ick
19:53:12 <benzrf> they say that (a -> b) is b^a
19:53:30 <benzrf> it can be in practice if a is an enum
19:53:31 <benzrf> :-D
19:53:44 <Kazagistar> haha @pl, for when you feel like maybe, just maybe, pointfree might be an elegant way to code, and want to have your hopes dashed
19:54:53 <benzrf> @remember Kazagistar haha @pl, for when you feel like maybe, just maybe, pointfree might be an elegant way to code, and want  to have your hopes dashed
19:54:54 <lambdabot> Done.
19:55:01 <benzrf> @forget Kazagistar haha @pl, for when you feel like maybe, just maybe, pointfree might be an elegant way to code, and want  to have your hopes dashed
19:55:02 <lambdabot> Done.
19:55:05 <benzrf> @remember Kazagistar haha @pl, for when you feel like maybe, just maybe, pointfree might be an elegant way to code, and want to have your hopes dashed
19:55:05 <lambdabot> I will never forget.
19:55:08 <benzrf> >spaces
19:55:15 <benzrf> i need t fix irssi
19:55:23 <rasfar> @lp (. fromEnum) . (!!)
19:55:23 <lambdabot> Maybe you meant: wn v slap rc pl let id help do bf @ ? .
19:55:50 <benzrf> @pl (. fromEnum) . (!!)
19:55:50 <lambdabot> (. fromEnum) . (!!)
19:55:56 <kristof> rasfar: What's the most efficient implementation of prolog these days?
19:56:12 <rasfar> lp = inverse of point-free
19:56:17 <Kazagistar> yay, I was remembered, that makes me a real person on #haskell
19:56:19 <benzrf> hha
19:56:20 <rasfar> is there a way to go the other way?
19:56:28 <Kazagistar> or is it only when I get quoted?
19:56:47 <Kazagistar> isn't there an @pf?
19:56:56 <Kazagistar> @pf (. fromEnum) . (!!)
19:56:56 <lambdabot> Maybe you meant: pl bf
19:56:57 <Axman6> unpl
19:57:01 <Kazagistar> ah
19:57:08 <rasfar> kristof: i really don't know, i've only seen it in a course on paradigms; but my dad's been into formal logic since longtime
19:57:08 <Kazagistar> @unpl (. fromEnum) . (!!)
19:57:08 <lambdabot> (\ d g -> d !! (fromEnum g))
19:57:12 <Axman6> @unpl (. fromEnum) . (!!)
19:57:12 <lambdabot> (\ d g -> d !! (fromEnum g))
19:57:19 <benzrf> @pl \f (a, b, c, d, e, f, g, h) -> f a b c d e f g h
19:57:19 <lambdabot> (line 1, column 11):
19:57:19 <lambdabot> unexpected "c"
19:57:19 <lambdabot> ambiguous use of a non associative operator
19:57:24 <benzrf> @pl \f (a, b, c, d, e, f, g, h) -> f a b c d e f g h
19:57:25 <lambdabot> (line 1, column 11):
19:57:25 <lambdabot> unexpected "c"
19:57:25 <lambdabot> ambiguous use of a non associative operator
19:57:26 <benzrf> dang
19:57:57 <Axman6> pl only knows about 2-tuples
19:58:07 <Kazagistar> soooo
19:58:13 <rasfar> oh! there is unpl, heh
19:58:24 <platz> lambdabot could end errors in parlimentary debate style w/ "Objection!"
19:58:40 <Kazagistar> @pl \f (a, (b, (c, (d, (e, (f, (g, h))))))) -> f a b c d e f g h
19:58:43 <lambdabot> const (ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (flip .) . ((ap .) .) . flip flip fst . (flip .) . (((.) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((ap .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .
19:58:43 <lambdabot> ) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . ((((const .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .)
19:58:43 <lambdabot>  .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((flip .) .) .) . ((flip .) .) . (flip .) . flip . flip id) id) id) fst) snd) fst) snd) fst . fst) snd)
19:58:43 <lambdabot> optimization suspended, use @pl-resume to continue.
19:58:47 <roboguy_> haha
19:58:51 <Kazagistar> oh god what did I do
19:58:58 <rasfar> @pl-resume
19:59:04 <lambdabot> const (ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . (flip .) . (((.) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((ap .) .) .) . flip flip fst . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
19:59:04 <lambdabot> ap .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . ((((const .) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) .
19:59:04 <lambdabot> ((((ap .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((flip .) .) .) . ((flip .) .) . (flip .) . flip . flip id . fst) snd)
19:59:04 <lambdabot> optimization suspended, use @pl-resume to continue.
19:59:17 <rasfar> it's the same
19:59:27 <rasfar> er, no it ain't sorry
19:59:33 <Kazagistar> I think I awoke zalgo?
19:59:44 <Kazagistar> @pl-resume
19:59:57 <lambdabot> const (ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . (flip .)) .) . ((((.) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .)
19:59:57 <lambdabot> .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . ((((const .) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .)
19:59:57 <lambdabot>  .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((flip .) .) .) . ((flip .) .) . (flip .) . flip . flip id . fst) snd)
19:59:57 <lambdabot> optimization suspended, use @pl-resume to continue.
20:00:27 <roboguy_> :t flip flip snd
20:00:28 <lambdabot> (a -> ((a1, b) -> b) -> c) -> a -> c
20:00:30 <rasfar> seems to be a glitch, it always starts at the same place
20:00:31 <Kazagistar> hmm, I guess it is finding incrementally better ways of writing it?
20:01:06 <Axman6> it's just huge I think
20:01:18 <Kazagistar> no, its an optimization, so I guess it writes it a simple way, and then it iterates ways to find one that is simpler
20:01:35 <rasfar> i think it's using entropy to generate impressive looking streams of symbols, knowing full well that no human will ever know the difference
20:01:38 <Kazagistar> so all of those work, but it hasn't convinced itself that it is the simplest one
20:01:44 <kristof> rasfar: I vaguely remember reading a Carl Hewitt paper that declared logic programming an intellectual dead-end
20:01:59 <kristof> That wassn't really relevant to anything, just though tit was interesting
20:02:05 <roboguy_> Kazagistar: that doesn't look like it's valid. I get an infinite type error
20:02:05 <Kazagistar> rasfar: seem as good a theory as any
20:02:12 <rasfar> well, if it works for GHC unification...
20:04:19 <benzrf> @unpl first
20:04:20 <lambdabot> first
20:04:23 <benzrf> lame
20:04:25 <benzrf> @unpl snd
20:04:26 <lambdabot> snd
20:04:30 <benzrf> @unpl snd . fst
20:04:30 <lambdabot> (\ c -> snd (fst c))
20:04:34 <benzrf> hmm
20:04:45 <benzrf> @unpl (>>= join replicate)
20:04:45 <lambdabot> (\ a -> a >>= (replicate >>= \ b -> b))
20:04:54 <benzrf> snrk
20:05:08 <Kazagistar> hmm, maybe we should start from something simpler and see where it fails?
20:05:16 <roboguy_> @unpl id
20:05:16 <lambdabot> (\ a -> a)
20:05:22 <Kazagistar> oooooh I see
20:05:26 <Javran> what's the function name equivalent to \f g -> first f >>> second g ?
20:05:35 <Kazagistar> f is the function AND in one of the tuples
20:05:47 <glguy> :t (***)
20:05:48 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:05:53 <benzrf> glguy: wrong type
20:05:56 <benzrf> oh wait nope
20:06:11 <Javran> (,) is an instance of arr
20:06:16 <benzrf> Javran: orly
20:06:18 <Kazagistar> @pl \f (a, (b, (c, (d, (e, (x, (g, h))))))) -> f a b c d e x g h
20:06:21 <lambdabot> flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . (flip .) . ((ap .) .) . flip (flip . (flip .) . (((.) .) .) . flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (
20:06:21 <lambdabot> flip . (flip .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
20:06:21 <lambdabot> flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((ap .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (((((((.) .) .) .) .) .) .)) fst) snd) fst) snd) fst) snd) fst) snd) fst) snd
20:06:21 <lambdabot> optimization suspended, use @pl-resume to continue.
20:06:32 <Javran> ....omg
20:06:41 <benzrf> > (1, "foo") C.. ("bar", [1, 2, 3])
20:06:43 <lambdabot>  No instance for (GHC.Num.Num [t0]) arising from the literal ‘1’No instance f...
20:06:43 <lambdabot>    arising from a use of ‘Control.Category..’No instance for (GHC.Num.Num t0)...
20:06:43 <lambdabot>  The type variable ‘t0’ is ambiguous
20:06:43 <lambdabot>  Note: there are several potential instances:
20:06:43 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
20:06:45 <roboguy_> Javran: an instance of arr?
20:07:00 <Javran> Arrow I meant
20:07:09 <benzrf> > (1::Int, "foo") C.. ("bar", [1, 2, 3]::[Int])
20:07:11 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
20:07:11 <lambdabot>              with actual type ‘[GHC.Types.Int]’
20:07:18 <benzrf> oh wrong direction derrr
20:07:22 <benzrf> > (1::Int, "foo") >>> ("bar", [1, 2, 3]::[Int])
20:07:23 <lambdabot>  No instance for (Control.Category.Category (,))
20:07:23 <lambdabot>    arising from a use of ‘Control.Category.>>>’
20:07:29 <benzrf> Javran: you lied!
20:07:54 <benzrf> what would id be anyway?
20:07:56 <Javran> > first (+1) (1,2)
20:07:56 <benzrf> or arr?
20:07:57 <lambdabot>  (2,2)
20:08:07 <roboguy_> Javran: hmm, I haven't seen that instance
20:08:11 <glguy> (,) isn't an Arrow, (->) is
20:08:13 <benzrf> Javran: yes, (->) is an instance of Arrow
20:08:28 <benzrf> :t firs
20:08:28 <lambdabot>     Not in scope: ‘firs’
20:08:29 <lambdabot>     Perhaps you meant one of these:
20:08:29 <lambdabot>       ‘first’ (imported from Control.Arrow),
20:08:30 <benzrf> :t first
20:08:31 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
20:08:40 <Kazagistar> roboguy_: that latest one typechecks just fine, and is still a monstrosity
20:09:15 <roboguy_> Kazagistar: hmm, interesting
20:09:33 <Javran> wait, maybe I was wrong
20:09:41 <roboguy_> yeah, (,) can't be an Arrrw
20:09:43 <roboguy_> *Arrow
20:10:01 <Javran> yep (->) should be an arrow but (,) does not
20:10:11 <rasfar> kristof: http://arxiv.org/abs/0904.3036 ?
20:10:27 <sveit> i have something that looks like "instance (C1 SomeType a b) => C2 SomeType2 a b where..." but haskell is asking for undecidableinstances. how "should" i solve this? is it 'ok' to use undecideable instances in this case?
20:10:51 <Kazagistar> roboguy_: it seems to be something like a worse case scenario for @pl, because I *think* there is a much easier pointfree form for that?
20:11:23 <roboguy_> there is an Adjunction (, r) (-> r), for what that's worth though
20:11:41 <roboguy_> pretend I put more parentheses there
20:11:53 <dolio> (,r) ⊣ (r ->)
20:11:58 <benzrf> Javran: there is no possible C.id for (,)
20:11:59 <benzrf> afaict
20:12:38 <roboguy_> Kazagistar: I wonder if it's one of those situations where it gets exponentially harder with the tuple depth
20:12:41 <rasfar> ghc RULES are equalities -- but it only every traverses left-to-right, correct? do people ever put the reverse rule in as well? it seems to me certain simplifications could not be arrived at otherwise.
20:13:01 <SrPx> from http://www.seas.upenn.edu/~cis194/lectures/03-rec-poly.html , "Other partial Prelude functions you should almost never use include tail, init, last, and (!!)" - why (!!) ? Is that an "use arrays if you want random access", or he is supposing there is a better way for random access on lists?
20:13:08 <benzrf> oh man
20:13:10 <benzrf> i just realized
20:13:13 <kristof> rasfar: I was actually talking about this paper: https://www.aaai.org/Papers/Workshops/2008/WS-08-14/WS08-14-003.pdf but he doesn't come to that conclusion at all so I must have been confused
20:13:15 <benzrf> type constructors get linear patterns
20:13:22 <rasfar> oh! haha
20:13:40 <kristof> I think this is a good paper anyway. I like survey papers :P
20:14:16 <rasfar> (re. GHC RULES pragmas, I suppose you'd want to have the reverse identity acting in a different pass to avoid cycles)
20:14:25 <trap_exit> jle`: yo
20:14:29 <trap_exit> jle`: ping
20:14:30 <roboguy_> SrPx: there isn't anything better in general for random access on lists, but (like you said) if you're needing a lot of random access you shouldn't use a list
20:14:43 <roboguy_> also, !! is partial
20:14:43 <dwcook> SrPx, (!!), much like head and tail, is partial.
20:14:50 <dwcook> And those others
20:15:02 <dwcook> > [1, 2, 3] !! 5
20:15:03 <lambdabot>  *Exception: Prelude.(!!): index too large
20:15:14 <SrPx> okay, I wonder why he'd say that and not mention arrays.
20:15:14 <trap_exit> is there a video tutorial
20:15:17 <rasfar> now that it's comparatively easy to track down the location of runtime exceptions, i'm more comfortable using partial functions like this
20:15:18 <trap_exit> I can watch on ghc.generics?
20:15:28 <trap_exit> i want to learn ghc.generics
20:15:29 <roboguy_> SrPx: he probably was referring it being partial
20:15:31 <trap_exit> teach me
20:15:34 <roboguy_> especially given the context
20:15:39 <SrPx> uh huh
20:16:13 <roboguy_> rasfar: it is? those partial functions never give error location information
20:16:25 <dolio> (!) is also partial.
20:16:30 <Kazagistar> SrPx: also, lists are not arrays, they are iterations, and usually, wanting to use !! means you are probably using lists in a "strange" way
20:16:32 <rasfar> comparing "drop 1" and "tail" -- sure drop 1 will never crash your program, but if it was a programmer logic error it's better to know than to have it silently "work"
20:16:45 <rasfar> roboguy_: using -xt
20:16:58 <roboguy_> dolio: true. if you are really adamant about avoiding partial functions and doing random access you would need dependent types
20:17:21 <dolio> You just need an array lookup that returns Maybe.
20:17:34 <Kazagistar> rasfar: you can always use safeTail or whatever its called
20:17:37 <dwcook> rasfar, if drop 1 does what you want, good. Otherwise, I'd suggest handling the case that the list is empty using a case expression.
20:17:40 <roboguy_> good point
20:18:18 <rasfar> dwcook: i'm just speaking hypothetically
20:18:28 <roboguy_> rasfar: I still prefer pattern matches. They always give error location info
20:18:36 <dwcook> rasfar, so am I
20:18:52 <roboguy_> > let (_:xs) = [] in xs
20:18:54 <lambdabot>  *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (_ ...
20:19:48 <rasfar> but i'm talking about accidental logic errors. sure i always /intend/ to write correct code, but for those cases where there's an error -- a runtime error is better than arbitrary semantics (as it were)
20:20:25 <rasfar> i do agree that pattern-matching is preferable (and the compiler will tell you if cases aren't covered, and even if there's overlaps!)
20:21:24 <dfeuer> Some of the comments are a bit outdated (because some things got into Data.List) but check out the utility-ht package on Hackage.
20:21:42 <dfeuer> It has some good stuff like viewL (elsewhere sometimes called uncons).
20:22:16 <dfeuer> That was for you, rasfar.
20:22:24 <rasfar> i suppose some of that has been subsumed by ViewPatterns (or are those in Haskell2010) -- yes, hello!
20:23:09 <rasfar> my interest in this particular discussion is pretty small, i'm just hooked on IRC -- I think I need to put it away now
20:23:19 <dfeuer> viewL is good for deconstructing a list in the Maybe monad.
20:23:33 <dfeuer> Hahaha.
20:23:46 <SrPx> Kazagistar: uh huh, thanks
20:23:55 <dfeuer> It is addictive, but sometimes very educational.
20:23:58 <dfeuer> I learned a lot yesterday.
20:24:16 <SrPx> while we are at it, do you guys use arrays a lot? more than lists, in general?
20:25:25 <rasfar> yeah ... no doubt / and thanks for pointing out utility-ht, I've never seen it before although the author is familiar.
20:26:17 <dfeuer> Rasfar, the author sent me the link today :)
20:26:51 <rasfar> in that case i guess ViewPatterns doesn't subsume it
20:27:43 <roboguy_> SrPx: I use vectors more than Int indexed arrays, but the only difference there (that I'm aware of) is that vector has a nicer interface
20:28:32 <roboguy_> I pretty much use lists unless I either need random access or if I need to store something in a very compact way
20:29:36 <Kazagistar> SrPx: The usual pattern is you have some kind of data store (array or vector or file or whatever), then you pull a list from it, process the list through some steps, and toss it into something not-list at the end (see previously) because usually the lists never end up existing in memory anyways
20:29:55 <SrPx> I see. By Int indexed arrays you mean Data.Array and by vector you mean Data.Vector right?
20:30:15 <Axman6> lists and arrays are used for very different problems
20:30:22 <SrPx> Kazagistar: hmm
20:30:29 <sveit> to generalize my question, when i define typeclass instances and ghc asks for an extension i generally blindly take it. does anyone know of a good resource that goes over the specifics of what's ok/not ok with different levels of extensions?
20:30:57 <kvanb> sveit: generally
20:31:02 <kvanb> Rank2 is ok, RankN is scary
20:31:07 <kvanb> and never take NoMonomorphism
20:31:34 <kvanb> syntaxial extensions like ViewPatterns you probably shouldn't use in world-facing code
20:31:50 <sveit> flexibleinstances? undecideableinstances?
20:31:57 <kvanb> undecidable is bad
20:31:59 <kvanb> idk about flexible
20:32:06 <kristof> roboguy_: I thought that was only the case for catamorphisms?
20:32:11 <Exio> @src foldl1
20:32:11 <lambdabot> foldl1 f (x:xs) = foldl f x xs
20:32:11 <lambdabot> foldl1 _ []     = undefined
20:32:17 <roboguy_> SrPx: yeah. Data.Array is a little more flexible because the index doesn't need to be Int
20:32:34 <kristof> Wrong person. Kazagistar ^ was for you.
20:32:35 <roboguy_> killy9999: ?
20:32:40 <roboguy_> I mean
20:32:41 <roboguy_> kristof: ?
20:32:42 <kvanb> I read a blog post about using undecidable instances to do some crazy mtl stuff without fundeps
20:32:50 <roboguy_> ooh
20:33:08 <roboguy_> kristof: fusion probably gets rid of that extra stuff too
20:33:13 <SrPx> roboguy_: Ah I see.
20:33:15 <SrPx> thanks
20:33:50 <roboguy_> SrPx: String is sort of a special case, I feel. I tend to only use it for small stuff and use either Text or ByteString for anything substantial
20:34:16 <Kazagistar> kristof: are you asking me about catamorphisms? cause my category theory is totally basic right now...
20:34:22 <Axman6> String is fine if you're not doing text processing per se
20:34:28 <sveit> ok. and another probably silly question, i often /want/ to do things like "instance C1 a b c where f :: a -> c ...(more code/functions)" but if a doesn't take b or c as a parameter this leads to problems. what is the particular mistake here?
20:34:32 <roboguy_> Kazagistar: a catamorphism is a fold followed by an unfold
20:34:44 <roboguy_> I mean, an unfold followed by a fold
20:35:02 <roboguy_> wait, no
20:35:05 <roboguy_> that's a hylomorphism
20:35:08 <dfeuer> SrPx: Okasaki and such would tell you that when you're designing your algorithm you should stick in a generic sequence type and then decide on the concrete representation once you know what operations you need to be efficient.
20:35:13 <roboguy_> a catamorphism generalizes a fold, I think
20:35:40 <SrPx> dfeuer: makes sense, but then you have to refactor?
20:35:42 <kvanb> sveit: I think I once solved something similar by having a type alias in my class
20:36:01 <kvanb> although I think that unwravelled a whole list of necessary extensions
20:36:11 <kvanb> theres also GADTs if they fit your use case maybe
20:36:28 <dfeuer> SrPx, you just design before you write (ideally) or if need be, yes, you can refactor.
20:36:57 <Axman6> SrPx: refactori9ng in Haskell is usually quite painless and mechanical
20:37:07 <dfeuer> But if you use nicely generic operations with an appropriate typeclass, you can refactor by changing a single line....
20:37:11 <kristof> Kazagistar: No, I was saying that lists aren't consed into existence only if you're using catamorphisms. If you process a non list data structure by creating its list equivalent first, and then make another data type out of that, I'm pretty sure the list-ness does not get compiled out.
20:37:40 <roboguy_> kristof: fusion takes care of that (sometimes)
20:37:59 <kristof> You know what? I was indeed thinking of hylomorphisms, thank you roboguy_.
20:38:11 <kvanb> don't all scans produce lists?
20:38:18 <kvanb> lists are not evil, they are quite fast.
20:38:20 <sveit> kvanb: thanks for the solutions, but in my case that is putting the cart before the horse :) i'd like to understand why haskell has problems with classes where i have something like "class C1 a b c where f :: a -> c ...". Couldn't haskell try to figure it out based on what i need "c" to be, or force me to decide later?
20:38:23 <Kazagistar> I thought list fusion *was* that
20:38:49 <kvanb> I'm not very good with type heavy stuff, sorry
20:38:56 <roboguy_> lists can be good or bad, depending on what you're doing. there's no one-size-fits-all solution
20:39:02 <kvanb> I write libraries, but in terms of types they are just composition or quite simple
20:39:11 <sveit> my point is that i should be able to say "class C1 a c where f :: a -> c" and then do "instance C1 a c1 were ...", "instance C1 a c2 where ..."
20:39:39 <roboguy_> sveit: have you tried a functional dependency?
20:39:49 <kvanb> why should you be able to do that, by the way?
20:39:51 <NemesisD> anyone use flycheck-haskell? im getting a supremely unhelpful error "configured syntax checker haskell-ghc cannot be used"
20:40:05 <kvanb> are you trying to express "if it happens to look like this then .."
20:40:12 <kvanb> if so, fundeps will help.
20:40:35 <dfeuer> Lists are generally bad as representations, unless you need a lot of tail sharing, but GHC has a ton of code to make lists not be represented as lists, so that can make certain kinds of list code very very fast...
20:40:52 <Kazagistar> sveit: there could be a instance C1 Int Int Int, and C1 Int Bool Int, and if you are using a function a -> c, it does not know which to use, since the b is ambiguous
20:41:10 <kvanb> dfeuer: lots of C programmers will tell you lists are crappy
20:41:18 <roboguy_> sveit: you can tell ghc that on of the parameters is determined by another using fundeps though
20:41:23 <kvanb> but that's not the case in Haskell
20:41:31 <kvanb> we have bump pointer heap allocations
20:41:42 <kvanb> our lists are just as efficient as their nested calls
20:41:44 <thinggg_> whats better Haskell or Java
20:41:49 <Axman6> lists are crappy for many things in Haskell too
20:41:54 <Axman6> thinggg_: yes
20:41:55 <kvanb> thinggg_: Have you seen Java?
20:41:56 <roboguy_> thinggg_: you're in #haskell, what do you think haha
20:42:04 <Kazagistar> kvanb: if you actually keep the list around in memory, it very well could be the same kind of crappy
20:42:14 <kvanb> ofcourse
20:42:19 <kvanb> they interact especially bad with garbage collectors
20:42:23 <kvanb> long lists of pointers ... yay
20:42:49 <Cale> thinggg_: Learn both and you tell us :D
20:42:53 <kvanb> but the rule with Haskell for performant reduction is basically generate as much crap as possible
20:42:58 <kvanb> or generate no crap at all
20:43:31 <sveit> i realize my 3-type variable example was bad. how about something like "class C1 a c where f :: a -> c" and define "instance C1 a c1 where..." and "instance C1 a c2 where..."? why is this bad? trying to learn Haskell types at a more rigorous level, thanks for the help
20:43:33 <kristof> kvanb: Heap allocation is slower than slow
20:43:36 <dfeuer> Wait, why would you ever want to generate as much as possible? Do you mean in cases where all the crap will be imaginary?
20:43:49 <kvanb> kristof: heap allocation is one branch in haskell that's predicted to mostly never occur
20:43:59 <kvanb> dfeuer: because the gc doesn't need to move crap
20:44:08 <kvanb> it just ignores it and lets it disappear
20:44:09 <roboguy_> dfeuer: ghc's garbage collector can actually do better when you generate a lot of garbage
20:44:17 <enthropy> @hackage convertible
20:44:17 <lambdabot> http://hackage.haskell.org/package/convertible
20:44:17 <dfeuer> ....
20:44:21 <kvanb> if you generate 1GB of garbage
20:44:22 <roboguy_> that's what the haskell wiki leads me to believe
20:44:24 <kvanb> and produce a 4 byte result
20:44:29 <Axman6> lots of short lived crap anyway right?
20:44:29 <kvanb> the gc moves the 4 byte result
20:44:35 <kvanb> and deallocates all the short lived 1GB of crap at once
20:44:39 <kvanb> (or, in iterations)
20:44:52 <dfeuer> Any time you're generating a lot of short-lived crap, your L1 cache is *wasted*.
20:45:03 <enthropy> sveit: you're reinventing something like that?
20:45:16 <kvanb> Not for reductions, no. The closest heap space will always be in L1
20:45:16 <kristof> kvanb: By slow, I meant allocating memory on the heap is slower than shoving it on your stack frame, nothing to do with garbage collection.
20:45:28 <kvanb> if you reference older stuff it's no longer short lived in a way
20:45:31 <Kazagistar> sveit: that one shouldn't be bad
20:45:46 <kvanb> kristof: that's not the case with haskell though
20:46:00 <Axman6> IIUC, GHC doesn't allocate any data on the stack, only continuations
20:46:04 <kvanb> haskell heap allocations are almost exactly as efficient as traditional stack allocations
20:46:13 <Axman6> hmm, that is probably wrong actually
20:46:14 <kristof> I'll believe you.
20:46:27 <kvanb> it allocates a large space, say 1mb
20:46:31 <kvanb> an allocation is basically
20:46:35 <kristof> Axman6: I don't understand how a continuation, or any other kind of functional reference, could live on the stack.
20:46:52 <kvanb> if (upto + size > end) { allocate another } else { upto += size; return upto }
20:47:01 <Axman6> kristof: it's just a pointer to the next thing to execute once you know what the current result is
20:47:21 <kvanb> these are batched together on function entry
20:47:23 <Cale> Continuations are what usually go on most stacks
20:47:28 <kvanb> so there's 1 branch at the top of allocating functions usually
20:47:32 <kvanb> and the rest is free stack-like space
20:47:37 <sveit> enthropy: not quite, this is a simplified example
20:47:54 <sveit> Kazagistar: thanks, that means i have a bug or typo somewhere, since that is a simplified example
20:48:04 <roboguy_> ah, here it is: http://www.haskell.org/haskellwiki/GHC/Memory_Management
20:48:18 <Kazagistar> sveit: I am not 100 % sure though
20:48:20 <kvanb> lots of high performance databases use bump-pointer arenas
20:48:25 <kvanb> to similar effect
20:48:37 <kvanb> we get it free here ;)
20:48:48 <Axman6> kristof: this might be useful: http://ezyang.com/jfp-ghc-rts-draft.pdf (it's a currently afaik stalled WIP but still very good)
20:49:40 <Axman6> Cale: huh, I guess that is true. Never really thought of it like that
20:49:57 <roboguy_> Axman6: complete with notes from Simon Marlowe?
20:50:22 <Axman6> yep
20:50:42 <Axman6> kristof, kvanb : if you haven';t seen it: http://www.well-typed.com/blog/94/
20:51:17 <carter> yeah, allocation is cheap
20:51:20 <carter> the cost is in collecting
20:51:51 <dfeuer> I saw that happen when I used a nice functional heap to implement a k-way merge—the GC wasn't doing too much, but the code ended up running slowly, and I realized I was probably pushing a bunch of crud through L1 that was keeping the stuff I wanted there from sticking around.
20:52:48 <dfeuer> I ended up doing better with a naive sort of merge that didn't allocate as much,
20:53:41 <kvanb> I should get in the habit of reading the cmm more
20:53:50 <kvanb> I only tend to look at stg
20:54:24 <dfeuer> Why should you do that, kvanb?
20:54:27 <sveit> thanks. so is there a canonical resource for learning the type system rigorously?
20:54:48 <dfeuer> sveit, yes, there is! It's actually called "the source"!
20:54:55 <dfeuer> And no, I'm not even joking.
20:55:23 <dfeuer> The official spec of the Glasgow Haskell type system is the source code of the GHC type checker.
20:55:42 <roboguy_> dfeuer: that's *definitely* not how I learned about the type system, haha
20:56:13 <Kazagistar> sveit: http://lpaste.net/107735
20:56:25 <dfeuer> roboguy_: I haven't learned it rigorously, but ... that's really it.
20:57:46 <roboguy_> dfeuer: yeah, I guess if you want to rigorously learn it... I almost never learn things that way though (I didn't learn about C++ from the ISO/IEC C++03 standard)
20:59:54 <dfeuer> I read something about that at some point. Basically, the Glasgow Haskell type system is too complicated to be able to explain to a human exactly when it will or will not be able to infer types. About the best that can be done is to give a lower bound on when type inference is guaranteed, and to give a more complete description on what can be typed with signatures.
21:00:03 <dfeuer> S/on/of
21:00:35 <Kazagistar> sveit: one thing that might help is realizing that typeclasses are something like a record of values, and the compiler picks which record to pass in depending on the types in can infer
21:01:26 <Kazagistar> dfeuer: pretty sure that is only for "arbitrary subset of extensions"?
21:03:24 <kvanb> dfeuer: because there are subtleties I would like to inspect
21:03:35 <kvanb> related to the cost of closures I use and stuff
21:03:45 <kvanb> whether I get tighter loops by passing as arguments
21:03:45 <kvanb> etc
21:03:51 <dfeuer> Dunno, Kazagistar. Even the Haskell Report seems to leave some things unspecified wrt dependency analysis.
21:04:15 <dfeuer> But I could be wrong about that.
21:06:06 <sveit> ok, this seems a bit more complicated than i first thought :)
21:06:36 <Kazagistar> sveit: this probably wont be helpful, but http://www.haskell.org/haskellwiki/Research_papers/Type_systems
21:07:03 <sveit> i guess i would mostly like to understand the theory so i can more systematically guide a decision to, for example, define a class as "class C1 a b where f :: a b -> ..." vs "class C1 a b where f :: a -> ...", and other 'subtelties' like that
21:08:15 <roboguy_> sveit: those are very different classes
21:09:01 <roboguy_> "a" has different kinds in those two examples
21:09:08 <sveit> roboguy_: yes i understand that
21:09:32 <sveit> roboguy_: my point is when designing a library i have choices like that presented to me at a very high level
21:09:41 <roboguy_> oh
21:10:45 <dfeuer> Good point, sveit. I think the most popular approach is to try one, get a lot of complaint from users, and then try it a different way.
21:10:49 <roboguy_> I guess it would depend on what sort of "naturality conditions" you want (i.e., when you want variables to be universally quantified)
21:12:14 <enthropy> if the only 'a' you get is applied to 'b' (as in the first C1) then I don't see any point in separating them out
21:12:59 <roboguy_> sveit: I doubt there's a general principle. I would say it's heavily dependent on the specific scenario
21:13:15 <sveit> enthropy: sure, but as a 'counter-point' from a design standpoint separating them out is slightly more generic
21:13:27 <sveit> enthropy: unforseen future use and all that
21:13:44 <roboguy_> "as generic as possible" is usually pretty good though. you can take advantage of parametricity more
21:14:01 <sveit> roboguy_, dfeuer: that was my fear, i guess getting this right will come from experience
21:14:10 <enthropy> class C1 a b where f :: a b -> a b -- is less general than    class C2 ab where f :: ab -> ab
21:14:42 <enthropy> since you could write  instance C1 a b => C2 (a b)
21:15:39 <sveit> enthropy: sorry, it's late and i had thought you meant you don't see a point in /not/ separating them.
21:15:48 <dfeuer> There seems to be some tension between making things nicely parametric and making them fast for special cases.
21:15:49 <sveit> enthropy: of course you are correct
21:16:01 <roboguy_> dfeuer: that's a good point
21:16:01 <Kazagistar> sveit: a very popular option to consider it to replace {C1 a b where f :: a -> b; g :: C1 a b => C2 a -> C3 b } (or whatever) with the typeclass-free form { g :: (a -> b) -> C2 a -> C3 b }
21:16:16 <roboguy_> dfeuer: SPECIALIZE can help a little here and there, but that is an issue
21:17:26 <dfeuer> roboguy_: I was referring to things like representing a vector of Bool or Char in a packed fashion.
21:17:46 <dfeuer> No amount of SPECIALIZE will do that.
21:17:54 <roboguy_> yeah, that's true
21:18:26 <roboguy_> some amount of type families might though
21:18:37 <dfeuer> You can fuck around with RULES (which is the approach arithmoi uses for some things) but that's a bit fragile.
21:19:06 <dfeuer> That seems to be so, roboguy_, but I don't understand them well enough yet.
21:19:20 <dfeuer> Better than I did two days ago, but not well enough.
21:19:23 <roboguy_> type family FastVector a { FastVector Bool = FastBoolVector; FastVector Char = FastCharVector; FastVector a = Vector a }
21:19:47 <roboguy_> dfeuer: they are type level functions. they take a type and result in another type
21:19:55 <dfeuer> Yes, that much I got.
21:20:22 <roboguy_> of course, the trick is making it so you can actually *do* something with that type haha
21:21:00 <Kazagistar> roboguy_: edward wrote a short paper worth about it to dfeuer on IRC around this time yesterday :P
21:21:25 <roboguy_> Kazagistar: ah, nice. wish I was there to read it
21:21:27 <dfeuer> Which is why I said I understand it better than two days ago ;-)
21:21:35 <MP2E> me too roboguy_
21:21:41 <MP2E> I still don't feel comfortable with Type Families, yet
21:21:48 <roboguy_> MP2E: type families are pretty cool
21:21:51 <dfeuer> roboguy_, MP2E, this channel is logged.
21:21:57 <MP2E> good point
21:22:02 <roboguy_> dfeuer: yeah, but I don't feel like looking for it yet. maybe later
21:22:46 <roboguy_> I have less experience with how they interact with type classes and with data families
21:22:54 <roboguy_> than just normal type families
21:22:55 <dfeuer> Any idea why #ghc is *not* logged?
21:23:03 <stolaruk> I just wrote some concurrent logging code. Yeah!
21:24:39 <dfeuer> Congrats, stolaruk.
21:24:43 <Kazagistar> it is right near the end of http://tunes.org/~nef/logs/haskell/14.07.17
21:24:47 <Kazagistar> enjoy :P
21:24:52 * dfeuer goes AFK.
21:25:31 <roboguy_> Kazagistar: thanks!
21:26:07 <Kazagistar> 21:43:ish
21:26:28 <Kazagistar> roboguy_:^^ ping
21:27:22 <Kazagistar> maybe 2 min earlier or something, dunno what the best context is
21:27:33 <roboguy_> ooh, polykinds too
21:27:53 <roboguy_> that's something I have almost no experience with. I have read a little about it though
21:28:21 <roboguy_> I tried to figure out indexed monads a while ago, but I didn't get too far
21:47:26 <jle`> > hi lambdabot
21:47:27 <lambdabot>  "Hi Justin"
21:47:41 <jle`> hm
21:48:13 <slack1256> I am temped to use the Reader monad with MVars as an environment. Any gotchas I should be aware of?
21:48:38 <jle`> slack1256: well...you can explicitly pass the MVar around
21:48:42 <jle`> as an argument
21:50:19 <slack1256> Well yeah, But I got at least 3 of them, some of them are used in each function.
21:50:27 <jle`> pack them up in a data type?
21:50:33 <slack1256> Yep
21:50:53 <jle`> i think any gotchas in the Reader monad with MVars would be the same as just passing it around explicitly
21:50:54 <slack1256> But my gut feeling is telling me I am breaking some runtime behaviour?
21:51:09 <slack1256> Mmm, well yeah.
21:51:17 <slack1256> Thinking that way feels more relaxing.
21:51:59 <benzrf> slack1256: just relax, man
21:52:04 <benzrf> functions, man
21:52:05 <jle`> Reader is unrolled to be explicit argument passing pretty much
21:52:06 <benzrf> they're like
21:52:08 <benzrf> so cool
21:52:09 <benzrf> dude
21:52:14 <slack1256> lol
21:52:41 <jle`> foo :: x -> Reader r a
21:52:49 <slack1256> I don't know the explicit category theory term but I know that (Reader r) is isomorphic to ((->) r)
21:52:51 <jle`> is just foo :: x -> r -> a
21:52:55 <jle`> like, newtype wise
21:52:58 <jle`> actually...
21:52:59 <slack1256> Yes I've checked the instances :-)
21:53:09 <jle`> no, he new implementation isn't like that
21:53:23 <jle`> so you might incurr some overhead with Identity?
21:53:39 <jle`> but in the old implementation it was newtype Reader r a = Reader (r -> a)
21:53:45 <jle`> and newtypes disappear at compile-time
21:53:49 <slack1256> Oh yeah, because Reader r = ReaderT r m
21:54:33 <slack1256> But you can still use the old semantics of Reader (r -> a) using the monad interface of ((->) r)
21:54:36 <jle`> so if you just had newtype Reader r a = Reader (r -> a), foo :: x -> Reader r a would be equivalent after compilation to foo :: x -> r -> a
21:54:48 <jle`> yeah, i'm just talking about representations after compilation
21:55:02 <slack1256> nice
21:55:59 <jle`> technically... newtype ReaderT r m a = ReaderT (r -> m a)
21:56:33 <jle`> and if m is Identity, ReaderT r Identity a should be equivalent after compilation to r -> a
21:56:40 <jle`> but i think there might be a cost for (>>=)
21:57:03 <jle`> oh but the point wasn't about cost
21:57:14 <jle`> it was about if there would be anything quirky with the behavior of MVars
21:57:21 <jle`> yeah, I don't think there would.
21:57:55 <slack1256> yeah because is basically the same behaviour as threading them as arguments
21:58:36 <jle`> ...as far as i can tell, yes
22:11:21 <picofish27> Hi. Bit of a newbie here. I just installed GHC and the latest version of cabal on Mac OS X.  I haven't installed explicitly installed any packages yet. When running "cabal install snap" I get an error "cabal: The following packages are likely to be broken by the reinstalls:" and it lists the HTTP-4000.2.17. I can do a --force-reinstalls flag, but I'm sort of confused about what this will do and really want to try to avoid creatin
22:11:22 <picofish27> problems for myself in the future. Any thoughts?
22:12:35 <slack1256> yep I've been there
22:13:25 <picofish27> Reading issue 3.3: http://www.haskell.org/haskellwiki/Cabal/Survival#Issue_.233_--_using_.27--force-reinstalls.27 ...
22:13:42 <slack1256> Turns out ghc/cabal mantain a global set of package and modules installes on your system, the ones shipped with the haskell plataform and the neccesaries conflict because they need different versions
22:13:44 <picofish27> Seems to suggest unregistering HTTP. Is this in general the best course of action
22:13:51 <picofish27> ?
22:14:02 <slack1256> If you have used linux you can think as different versions of libraries are neccesary.
22:14:35 <slack1256> My recomendation http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
22:14:44 <picofish27> Okay, thx slack1256
22:15:03 <slack1256> learn about the problem so you don't feel discoraged and what is the current solution :-)
22:15:07 <picofish27> Any big differences between "ghc-pkg unregister" and "cabal-uninstall"
22:15:14 <jle`> there's a cabal-uninstall?
22:15:25 <slack1256> well for starters there is a cabal uninstall
22:15:36 <ddellacosta> [n00b filter] why is this okay: let { k :: [a] -> Int; k l = length l } and this is okay: let { k :: [Int] -> Int; k l = succ $ head l }, but this is not: let { k :: [a] -> Int; k l = succ $ head l } ?
22:15:37 <jle`> there's a cabal uninstall?
22:15:46 <jle`> i must be so out of date
22:15:49 <picofish27> joe` see http://www.haskell.org/haskellwiki/Cabal/Survival#Issue_.233_--_using_.27--force-reinstalls.27 section 3.3
22:15:55 <picofish27> *jle`
22:15:58 <platz> it's on hackage i believe
22:16:00 <jle`> i've been using ghc-pkg unregister
22:16:02 <jle`> ah i see
22:16:34 <platz> but for some reason it always nukes my .cabal/lib
22:16:43 <jle`> ddellacosta: what happens?
22:16:50 <picofish27> $ cabal uninstall
22:16:51 <picofish27> cabal: unrecognised command: uninstall (try --help)
22:16:58 <picofish27> slack1256
22:17:00 <jle`> ddellacosta: i think the error message should help you?
22:17:00 <ddellacosta> jle`: "Couldn't match expected type ‘Int’ with actual type ‘a’" ...etc.
22:17:04 <jle`> ah
22:17:20 <ddellacosta> jle`: unfortunately, I don't understand what it's telling me.  Or rather, why it's telling me that. :-(
22:17:25 <slack1256> cabal mostly just install software, it doesn't administers it in a full sense, for that is ghc-pkg
22:17:39 <jle`> ddellacosta: do you see why this errors?
22:17:41 <platz> https://hackage.haskell.org/package/cabal-uninstall though I consider it a bit buggy
22:17:45 <ddellacosta> jle`: that is, why isn't Int an acceptable 'a'?
22:17:45 <jle`> f :: a -> Int; f x = x
22:17:55 <jle`> ^^ do you see why that can't work?
22:18:09 <jle`> what if i give f a Bool?
22:18:16 <ddellacosta> jle`: I don't, I'm sorry.  Which shows my lack of understanding of something basic.
22:18:24 <jle`> because f :: a -> Int, that means that f can take *any* type, and make an Int from it
22:18:30 <jle`> so i should be able to call f on a Bool
22:18:37 <jle`> or a list
22:18:45 <jle`> or a Double
22:18:50 <picofish27> plats looks like it just runs ghc-pkg unregister anyways https://github.com/plancalculus/cabal-uninstall/blob/master/cabal-uninstall.hs#L161
22:19:03 <picofish27> more or less anyways
22:19:04 <ddellacosta> jle`: so, this is fundamentally not type safe, is this the issue?  a -> anything ?
22:19:23 <jle`> ddellacosta: the idea is that when you use a type variable, you are supposed to be able to pass *any* type into it
22:19:26 <jle`> that's what f :: a -> Int means
22:19:33 <jle`> you can write an f :: a -> Int pretty fine
22:19:36 <jle`> f _ = 10
22:19:44 <jle`> but do you see why you can't do f x = x ?
22:19:53 <jle`> x can be *any* type
22:19:54 <platz> that removeDirectory command needs to go
22:20:21 <jle`> f :: a -> Int is a type signature that means "this function can take anything of any type, and return an Int"
22:20:30 <jle`> but f x = x clearly doesn't return an Int, if you give it a Bool
22:20:42 <ddellacosta> jle`: ooooh, I think the realization is dawning on me: right, you need to be able to pass anything in, so your function needs to be able to handle all those myriad ways that that could go.
22:20:58 <ddellacosta> jle`: so it's basically impossible to write that function, huh?
22:21:00 <jle`> f :: a -> Int actaully means something more powerful than i think people realize at first
22:21:02 <slack1256> ^ The awakening has begun
22:21:03 <jle`> ddellacosta: what function?
22:21:08 <jle`> you can write an f :: a -> Int just fine :)
22:21:11 <slack1256> ^ There is no way to stop it now
22:21:12 <jle`> i gave an example
22:21:15 <jle`> f _ = 10
22:21:19 <jle`> and here's another one!
22:21:21 <jle`> f _ = 11
22:21:24 <ddellacosta> jle`: right, but, defining that type signature and then building the function to match...?
22:21:33 <ddellacosta> slack1256: :-)
22:21:38 <jle`> f x = x is not a valid implementation of f :: a -> Int
22:21:40 <slack1256> ^ Oh god he got it :_)
22:21:54 <jle`> because x can be any type...but the function says it returns an Int
22:22:10 <ddellacosta> jle`: right, the signature is the problem, not a specific function, right?
22:22:30 <jle`> yeah, that type signature can be considered "too polymorphic"
22:22:51 <ddellacosta> jle`: gotcha, I'm getting it I think...great.  Thank you!
22:22:58 <jle`> the opposite case gets a lot of people, too
22:23:03 <jle`> f :: Int -> a
22:23:07 <jle`> f x = x
22:23:12 <jle`> do you see why that won't work?
22:23:30 <ddellacosta> jle`: that seems even "more impossible" than f :: a -> Int
22:23:38 <jle`> haha. exactly
22:23:44 <ddellacosta> jle`: if someone creates a new type tomorrow you're screwed
22:23:52 <jle`> this is actually something very powerful about haskell's type system
22:23:53 <ddellacosta> but I guess that's true in both circumstances
22:24:00 <jle`> there are some functions that are impossible to implement
22:24:06 <ddellacosta> yeah, that's kind of amazing, I really didn't get that until now
22:24:13 <jle`> f :: a -> b -> a      -- can you see that there is only one possible implementation?
22:24:20 <slack1256> ^ that
22:24:28 <jle`> f :: (b -> a) -> b
22:24:35 <jle`> can you see why there is no possible implementation of that?
22:24:42 <ddellacosta> jle`: I guess you have to return the a that comes in, no matter what, so it's a meaningless function (a -> b -> a)
22:24:47 <slack1256> you can write an type and the compiler can write the code for you (because there is only one possible implementation)
22:24:51 <jle`> ddellacosta: not meaningless, it's pretty useful :)
22:24:57 <ddellacosta> jle`: ah, okay
22:24:58 <jle`> f x = \_ -> x
22:25:10 <jle`> that's the only implementation
22:25:12 <ddellacosta> jle`: ah, right, I see how you could use that b
22:25:20 <jle`> it's actually so "only" that you can find it automatically
22:25:24 <jle`> @djinn a -> b -> a
22:25:24 <lambdabot> f a _ = a
22:25:34 <ddellacosta> wow
22:25:35 <jle`> djinn is a program where yuo give it a type signature and it finds a valid implementation
22:25:39 <ddellacosta> freaking amazing
22:25:43 <MP2E> djinn is so cool
22:25:48 <jle`> it's because haskell's polymorphic types give you so much power
22:25:51 <slack1256> @djing (a -> b) -> [a] -> [b]
22:25:51 <lambdabot> Error: Undefined type []
22:25:51 <MP2E> I just wish it handled RankNTypes, but for all I know that could be impossible :D
22:25:53 <jle`> in deduction
22:25:59 <ddellacosta> jle`: is that based on Wadler's "theorems for free?"
22:26:07 <slack1256> yep
22:26:29 <ddellacosta> slack1256: okay, thanks
22:26:36 <jle`> ddellacosta: you might also see that f :: (b -> a) -> b
22:26:40 <jle`> is an impossible thing to write
22:27:02 <ddellacosta> jle`: alright, so that is function composition, no?  the ()
22:27:13 <jle`> oh that's just a function
22:27:15 <ddellacosta> jle`: which means you can only get an 'a' out of that, never a b?
22:27:28 <jle`> f takes a function (b -> a) and returns an a
22:27:28 <ddellacosta> oh, I think I'm mistaken about that syntax then
22:27:37 <jle`> hm
22:27:45 <slack1256> @type ($)
22:27:46 <lambdabot> (a -> b) -> a -> b
22:27:46 <jle`> you can write an f :: (a -> b) -> a -> b
22:27:52 <glguy> slack1256: Free theorems are different than what djinn does afaik
22:27:59 <jle`> give it a function (a -> b), and an a, and you get b
22:28:15 <jle`> djinn is what you'd call a theorem prover
22:28:19 <jle`> free theorems are @free
22:28:27 <jle`> @free (a -> b) -> [a] -> [b]
22:28:27 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
22:28:41 <ddellacosta> jle`: right, I get it, (b -> a) is essentially the same as a -> b before "-> b," no?  Probably a really awkward way to put it
22:28:42 <jle`> um
22:28:43 <jle`> @free map
22:28:44 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
22:28:58 <slack1256> lambdabot please! don't embarrass us now!
22:29:01 <jle`> you see map's type signature is (a -> b) -> [a] -> [b]
22:29:09 <ddellacosta> yeah
22:29:16 <jle`> *from the type signature alone*, you can prove some things
22:29:42 <guy_with_a_cool_> hm...
22:29:49 <guy_with_a_cool_> seems like my hat's too big
22:29:58 <jle`> you can prove that if g . h = k . f, the map g . map h = map k . map f
22:30:11 <jle`> just from the type signature alone
22:30:24 <guy_with_a_hat> seems kinda bland
22:30:26 <ddellacosta> jle`: okay, I'm going to have to take some time to absorb that
22:30:28 <guy_with_a_hat> but I'll live
22:30:41 <ddellacosta> I have to go unfortunately
22:30:41 <jle`> any function implementation "polymorphic enough" to satisfy the type signature (a -> b) -> [a] -> [b]
22:30:46 <jle`> will necessarily have that property
22:30:49 <jle`> np :)
22:30:49 <ddellacosta> thanks everyone and especially jle` !
22:31:22 <jle`> @tell ddellacosta have a talk :) http://perl.plover.com/yak/CHI/
22:31:22 <lambdabot> Consider it noted.
22:31:43 <jle`> ddellacosta: have a talk :) http://perl.plover.com/yak/CHI/
22:32:30 <kvanb> lol
22:37:35 <picofish27> Any ideas on what's going on here? Still trying to install snap. https://gist.github.com/anonymous/7f06d81ac00ae206dc8a
22:37:45 <picofish27> Complaining about a missing symbol from parsec... but seems to be available
22:42:44 * dfeuer just discovered that without the Platform installed,  cabal install criterion  is not a short procedure.
22:43:16 <eevar> picofish27: have you tried building it in a sandbox? you could always run the binary from the sandbox' bin directory
22:44:22 <lfairy> picofish27: if you're getting linker errors, something is very wrong
22:44:25 <dfeuer> In fact, it seems for some reason to drag in a huge amount of stuff. hashable, blaze-builder, vector-algorithms, unordered-containers, monad-par, parsec, attoparsec, scientific, .......
22:44:54 <slack1256> dfeuer: I don't wish to be in your shoes, but try out the `-j' in cabal :-)
22:45:14 <picofish27> eevar: No idea. Pretty weird stuff. I literally just installed a fresh copy of ghc and the latest version of cabal-install and I got this when running "cabal install snap"
22:45:39 <dfeuer> Also, I got a weird error compiling Data.Vector.Algorithms.Common.  "Illegal equational constraint PrimState m ~ PrimState m (Use GADTs or TypeFamilies to permit this) ...."
22:45:46 <picofish27> lfairy: Any tips? I mean, yea. I agree that this seems pretty off, but I really don't know how to diagnosse
22:45:50 <eevar> try nuking .ghc and .cabal if you've reinstalled ghc/cabal
22:45:56 <eevar> and isntall cabal from source
22:47:38 <picofish27> eevar: Could I alternatively just install in sandbox?
22:47:56 <picofish27> eevar: Or do you think nuking + reinstall cabal from source is the better option?
22:47:58 <eevar> I guess. but I'd try to fix my cabal issues first
22:48:19 <picofish27> eevar: Fair enough, I'll just go with your suggestion
22:48:39 <eevar> install -j is your friend ;)
22:48:42 <picofish27> eevar: So, ghc-pkg unregister cabal after nuking .ghc and .cabal
22:49:28 <picofish27> eevar: mvmd sorry that doesn't really make sense
22:49:40 <picofish27> eevar: installed cabal-install at the sys level with brew
22:50:01 <lfairy> doesn't cabal come with ghc?
22:50:43 <eevar> eww, mac ;) - consider running linux in a vm :p
22:50:44 <picofish27> lfairy cabal-install comes with haskell platform but not ghc
22:50:54 <dfeuer> lfairy, I believe Cabal does, but not cabal-install. Except that the source code for cabal-install might actually be in the GHC tree. So it's kind of ... strange.
22:50:56 <picofish27> eevar: Do you have a recommendation for a vm?
22:51:03 <eevar> just joking there
22:51:12 <picofish27> eevar: Fair enough ahhaha
22:51:19 <picofish27> eevar: I am actually looking for a good vm though
22:51:26 * lfairy shrugs
22:51:39 <picofish27> eevar: And if this went more smoothly on another platform I'd be up for it...
22:52:26 <lfairy> picofish27: shot in the dark -- what does cabal --version say?
22:52:31 <picofish27> eevar: So i've nuked .ghc, .cabal, and uninstalled + installed cabal-install
22:52:41 <picofish27> $ cabal --version
22:52:41 <picofish27> cabal-install version 1.20.0.2
22:52:42 <picofish27> using version 1.20.0.0 of the Cabal library
22:52:48 <picofish27> $ ghci --version
22:52:48 <picofish27> The Glorious Glasgow Haskell Compilation System, version 7.6.3
22:53:06 <lfairy> okay, that's new enough
22:53:38 <picofish27> eevar: Alright... So... I suppose I'll just do cabal install snap
22:53:43 <picofish27> eevar: Although would you suggest a sandbox first?
22:53:58 <lfairy> yes, use a sandbox
22:54:04 <picofish27> ok
22:57:14 <dfeuer> Any idea why I keep having trouble compiling vector-algorithms with something pretty close to the latest GHC? I keep getting a type error about an illegal constraint. It doesn't matter if I try vector-algorithms or back a version to vector-algorithms-0.6.0.1. Can someone help me?
23:12:44 <picofish27> lfairy thx for help
23:12:52 <picofish27> eevar sandbox + nuking worked
23:12:53 <picofish27> thx
23:12:54 <picofish27> for help
23:13:56 <lfairy> picofish27: k :D
23:13:56 <glguy> dfeuer: vector-algorithms compiles without event with the latest libraries and GHC 7.8.3
23:14:14 <picofish27> lfairy, yea really thx man saved me a lot of trouble : )
23:14:30 <picofish27> lfairy or woman ... not sure of course
23:14:43 <dfeuer> glguy, I'm going to try the final 7.8.3 (I was a few days behind I think) but I'm not optimistic.
23:14:44 <picofish27> lfairy ...or other gender ; )
23:15:49 <jle`> one day i'll get around to installing 7.8.3
23:16:24 * hackagebot simple-pipe 0.0.0.0 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.0 (YoshikuniJujo)
23:16:35 <picofish27> Best text editor/IDE for writing haskell?
23:16:37 <dfeuer> jle`, I want to do some benchmarking of alternative implementations of Data.List.inits, and I don't really think anyone will be interested in how well they work on 7.6.3.
23:17:15 <dfeuer> picofish27, you can use ed, or sed, or Wordstar if you want to be fancy.
23:17:50 <picofish27> dfeur ah great, glad to hear you guys are comfortable with me writing with wordstar
23:17:57 <MP2E> lmao
23:18:15 <MP2E> http://xkcd.com/378/
23:18:19 <MP2E> obligatory editor comic
23:19:06 <picofish27> What do you guys use out of curiosity?
23:19:14 <ohhulloh> gotta love the C-x M-c M-butterfly
23:19:21 <dfeuer> I usually use vim, but I'm not very good at it.
23:19:39 <MP2E> I use emacs in evil mode to get vim style keybindings
23:21:23 <jle`> i wonder if aw randall munroe stopped idling here
23:21:30 <picofish27> MP2E why not just use vim?
23:22:01 <MP2E> picofish27 : because elisp is a much better configuration language than vimscript and overall I feel like emacs has more modes and features
23:22:29 <dfeuer> picofish27, some people are so strange that they like Emacs LISP. Others are willing to put up with the outdated/unmaintained edwin to be able to use MIT Scheme instead.
23:22:45 <MP2E> as I've said before, if vim had an emacs mode, I would have considered that :P
23:22:58 <MP2E> i don't love emacs lisp but I like it better than vimscript
23:23:03 <MP2E> it's a 'lesser of evils' situation
23:23:11 <picofish27> oh wow i have never heard of edwin
23:24:13 <dfeuer> Huh. edwin doesn't seem to be quite as outdated as I thought.
23:24:58 <MP2E> huh edwin looks cool
23:25:09 <MP2E> I still think if I were to switch it would be to Yi
23:25:15 <MP2E> ;P
23:25:44 <BenedictEggers> microsoft office
23:25:44 <enthropy> dfeuer: having an older ghc as a reference can help... it's not like every change they make is guaranteed to make things faster
23:26:01 <BenedictEggers> office word
23:26:10 <BenedictEggers> haskell_program.hs.docx
23:26:31 <dfeuer> enthropy, that may be, but I'd prefer to start with 7.8.3 if I can. If that turns out to be impossible, I'll start with 7.6.3.
23:28:46 <dfeuer> MP2E, what is Yi?
23:29:34 <MP2E> dfeuer: it's an extensible IDE in Haskell. Haskell is also the language used to configure it
23:29:37 <MP2E> http://www.haskell.org/haskellwiki/Yi
23:29:58 <dfeuer> Haskell? Why would anyone want to program in Haskell???
23:30:42 <dfeuer> It looks like my compiler was a little broken. Maybe some last-minute bug fix I missed.
23:31:04 <u-ou> omg I miss Haskell
23:31:07 <u-ou> :-(
23:31:11 <jle`> we just need to port the haskell runtime to vimscript
23:31:21 <jle`> and write a vimscript ghc backend
23:31:24 <dfeuer> I installed the binary and now vector-algorithms compiles.
23:31:27 <jle`> u-ou: come back :D
23:31:33 <u-ou> I always forget how to use it :}
23:31:44 * u-ou reads LYAH again
23:32:03 <dfeuer> jle`, I think a PHP backend would probably be more practical. Would you like to take charge of that project?
23:32:20 <jle`> hm let me check my schedule
23:32:29 * jle` sneaks out quietly
23:32:47 <MP2E> haha
23:33:05 <vincee> are typeclasses in haskell and scala mostly the same?
23:34:07 <dfeuer> Tell me ... why does criterion rely on parsec, attoparsec, and also aeson?
23:34:42 <joelteon> aeson relies on attoparsec
23:34:49 <picofish27> haskell requires mucho patience
23:35:15 <joelteon> criterion can generate JSON reports
23:35:23 <dfeuer> OK.
23:35:24 <joelteon> there are two reasons
23:35:27 <joelteon> parsec is...
23:35:43 <joelteon> I don't know about parsec. maybe it's to aid cabal in dependency resolution?
23:35:50 <joelteon> parsec is a platform package
23:36:10 <dfeuer> Yes, but the platform for 7.8 isn't out yet.
23:37:45 <joelteon> let me see what happens if I build criterion without parsec
23:40:23 <ohhulloh> i'm really loving haskell so far :) i just finished reading LYAH and i'm going through project euler atm. doing these problems is strangely gratifying when using haskell
23:40:26 <kvanb> uh
23:40:35 <kvanb> that might be for parsing previous reports?
23:42:52 <jle`> ohhulloh: :D
23:43:17 <dfeuer> How do I read the output from Criterion? What do things like mean: 116.5635 us, lb 115.7716 us, ub 118.9444 us, ci 0.950
23:43:17 <dfeuer>    mean ?
23:43:25 <jle`> ohhulloh: just be aware that project euler can only go so far in taking advantage/demonstrating how amazing haskell really is :)
23:46:40 <ohhulloh> jle`: haha, i'm well aware! i do game dev so after i get comfortable with the syntax of haskell i'm going to dive into the deep end and make a tetris clone or something. i expect I'll be here asking questions quite a bit
23:48:39 <jle`> ohhulloh: sounds like fun, please keep us updated :)
23:50:23 <dfeuer> ohhulloh, be warned that learning (enough of) Haskell's syntax is not much of a challenge; learning its type system is much trickier, and learning how to use it effectively will take time.
23:52:04 <ohhulloh> i'll keep that in mind, thanks!
23:54:24 <dfeuer> What is a JUnit report from Criterion?
23:55:35 <codygman> Is it true that Foldable/Traversable are prefereable to using lists as said here: http://www.haskell.org/haskellwiki/Foldable_and_Traversable
23:56:15 <dfeuer> codygman, it usually depends on what you're doing....
23:56:37 <Total_1mmersion> ohhulloh, when you get to game development, check out the Helm engine http://helm-engine.org/
23:58:01 <joelteon> helm is really cool, but damn does darwin suck for game dev
