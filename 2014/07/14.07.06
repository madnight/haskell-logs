00:01:31 <ddellacosta_> kvanb: how about here? https://www.refheap.com/f18ea2ed81665a85504de16a7
00:03:37 <dmwit> ddellacosta_: A couple thoughts, without having read the algorithm for understanding yet: 1. Several calls to (!!) suggests lists are not the right data structure. 2. Using Int and signaling failures with -1 is so C. Use Maybe Int instead, or better yet [Word].
00:04:11 <dmwit> (!!)/length are both real slow
00:04:40 <ddellacosta_> dmwit: great, thanks!  I had a suspicion that the -1 return value was not very idiomatic.  Yeah, and length is O(n) I saw, wasn't sure how to restructure that.  Probably a deeper conceptual thing I'm not getting yet.
00:05:26 <dmwit> I've never sat down and actually understood KMP, so I can't really offer *good* advice.
00:05:37 <dmwit> But I can offer bad advice, which is to use Array if you need random-access.
00:06:05 <ddellacosta_> dmwit: no, that's great--I'm less concerned with the specifics of KMP than how to use Haskell more effectively at this point
00:08:27 <ddellacosta_> is there an O(1) or (O lg n) way to find length of list in Haskell?  Or I guess array if that is more appropriate for random access
00:08:34 <pjdelport> ddellacosta_: You'll want Array for constant-time indexing.
00:09:00 <ddellacosta_> pjdelport: right, dmwit was saying that too.  Sound like I need to go read up on Array...
00:09:32 <dmwit> ddellacosta_: You can cook up a list-alike that has an O(1) length operation.
00:09:35 <pjdelport> ddellacosta_: http://www.haskell.org/haskellwiki/Arrays and http://www.haskell.org/tutorial/arrays.html might be useful.
00:09:50 <ddellacosta_> pjdelport: thanks, will check those out.
00:09:50 <dmwit> ddellacosta_: But there's no choice if you want to use the built-in lists.
00:09:56 <ddellacosta_> dmwit: gotcha, okay
00:10:03 <joelteon> there are very, very few benefits to using the built-in list type.
00:10:08 <dmwit> ddellacosta_: The basic idea is the one Okasaki taught us: data ListWithLength a = ListWithLength Int [a]
00:10:19 <joelteon> I can think of two things: easy access and constant-time prepend.
00:10:21 <ddellacosta_> joelteon: that's a bummer.  Why isn't it deprecated?
00:10:26 <ddellacosta_> ah, okay
00:10:30 <joelteon> it would break an incredible amount of code
00:10:38 <dmwit> joelteon: I don't think that's fair.
00:10:56 <dmwit> The non-determinism monad isn't easily done with Arrays, and infinite lists are often handy.
00:11:00 <ddellacosta_> dmwit: (gotcha, re: functional list length strategy)
00:11:02 <dmwit> [] is a great reified for-loop
00:11:13 <joelteon> Oh, that's right.
00:11:19 <joelteon> Okay, I eat my words.
00:11:41 <ddellacosta_> joelteon: well, you saying that helped me learn something new, so harm done. :-)
00:12:30 <dmwit> ddellacosta_: Also, I notice you're building up a list by appending to the end.
00:12:42 <dmwit> Generally you want to avoid that kind of thing, because it's slow.
00:12:53 <dmwit> Prepending, then reversing the list at the last second, will often be significantly faster.
00:13:15 <ddellacosta_> dmwit: ah, okay! good to know.  Although sounds like I'm going to need to use Array anyways, huh?
00:13:20 <dmwit> Of course that's not always possible, and maybe not here, since I notice you're indexing into it.
00:13:26 <ddellacosta_> yeah
00:13:39 <dmwit> ddellacosta_: Well, for building the list in the first place it's not clear Array is the way to go. Since resizing an Array is costly.
00:14:58 <ddellacosta_> dmwit: well, the only list I'll be building is the one for the KMP table, but I will have to frequently do lookup on that table
00:15:12 <ddellacosta_> dmwit: but I shouldn't have to resize it I don't think
00:15:16 * ddellacosta_ goes to review the code again
00:15:28 <dmwit> You resize 't' often in kmpTable.
00:16:03 <ddellacosta_> dmwit: right--but all I really need to do is append onto the end of it.  It should always end up being the length of p + 1 I believe
00:16:08 <dmwit> So what I'm suggesting is that you build it up as a list, then once you know the full size convert to Array for a one-time O(n) cost that gives you cheap indexing.
00:16:15 <ddellacosta_> dmwit: ah, gotcha!
00:16:15 <dmwit> Oh, always ends up being the same length?
00:16:19 <ddellacosta_> dmwit: yeah
00:16:43 <dmwit> Then you can probably get away with just making it an Array in the first place. Though initializing it will probably require abusing laziness significantly.
00:16:59 <pjdelport> ddellacosta_: Have you looked at https://hackage.haskell.org/package/KMP-0.1.0.2/docs/Data-Algorithms-KMP.html for comparison?
00:17:11 <ddellacosta_> dmwit: ah okay, will look into that.
00:17:15 <ddellacosta_> pjdelport: nope, not yet--great idea.
00:18:24 <ddellacosta_> pjdelport, dmwit, joelteon: thanks for all the feedback, it was *really* helpful
00:18:28 <pjdelport> ddellacosta_: There's also a ByteString version here: http://hackage.haskell.org/package/stringsearch-0.3.6.5/docs/src/Data-ByteString-Search-Internal-KnuthMorrisPratt.html
00:18:31 <dmwit> cheers!
00:19:36 <pjdelport> ddellacosta_: ByteStrings are pretty much what the name suggests: flat linear strings of bytes.
00:22:34 <zq> @pl either Just (const Nothing) . parseOnly p
00:22:34 <lambdabot> either Just (const Nothing) . parseOnly p
00:22:43 <zq> @pointful either Just (const Nothing) . parseOnly p
00:22:43 <lambdabot> (\ d -> either Just (\ _ -> Nothing) (parseOnly p d))
00:24:00 <petercommand> what does the @info of the lambdabot do?
00:24:10 <petercommand> @info blah
00:24:10 <lambdabot> blah
00:24:25 <petercommand> does it just repeat what I typed?
00:27:21 <dmwit> petercommand: No, it autocorrects to ?undo.
00:27:35 <dmwit> ?info do { foo; x <- bar; quux x foo }
00:27:36 <lambdabot> foo >> bar >>= \ x -> quux x foo
00:28:15 <dmwit> ?where faq
00:28:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:30:01 <petercommand> ?info blah
00:30:01 <lambdabot> blah
00:30:44 * hackagebot postgresql-simple-migration 0.1.1.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.1.0 (ameingast)
00:30:59 <petercommand> so prefixing it with either @ or ? has the same effect, right?
00:31:09 <dmwit> right
00:31:27 <petercommand> ok
00:31:27 <kvanb> ddellacosta_: use where
00:31:34 <zq> hm
00:31:40 <ddellacosta_> kvanb: where?
00:31:42 <kvanb> to take out common subexpressions
00:31:43 <kvanb> ie charIsMatch str idx p ppos
00:31:49 <zq> does it strike anyone odd that attoparsec.parseOnly returns Either String a?
00:32:10 <zq> the entire lib, all the combinators and such deal with BS
00:32:12 <ddellacosta_> kvanb: ah, thanks--that part was bugging me
00:32:22 <kvanb> also I see a lot of uses of !!
00:32:23 <ddellacosta_> kvanb: I actually tried using where there at first but couldn't get the syntax right
00:32:29 <kvanb> that's generally not a good thing in Haskell
00:32:39 <ddellacosta_> kvanb: yeah, it was commented previously that I should be using Array for random access
00:32:50 <kvanb> that would be a good idea
00:33:05 <kvanb> or, refactor the string search to be streaming
00:33:10 <kvanb> and have some kind of window
00:33:31 <ddellacosta_> kvanb: huh, I don't follow you with that one--which arg is that, p?
00:34:31 <dmwit> zq: But the error is text, not bytes.
00:34:53 <kvanb> ddellacosta_, sorry?
00:35:07 <c_wraith> :t const const
00:35:08 <lambdabot> b -> a -> b1 -> a
00:35:14 <ddellacosta_> kvanb: I just mean, I didn't get the streaming/window suggestion, sorry
00:35:18 <kvanb> oh, I had not considered how it was possible
00:35:27 <kvanb> I don't understand how the algorithm works
00:35:50 <ddellacosta_> kvanb: ah, okay.  Yeah, I don't know if that would work or not, would have to review
00:36:01 <kvanb> I just made the suggestion that often we avoid !! by delaying the need to do that check until it's at head
00:36:13 <kvanb> zippers are popular examples of this
00:36:16 <kvanb> kinda.
00:36:22 <zq> dmwit: blah, why didn't i see that
00:36:27 <zq> dmwit: thanks, christ
00:37:11 <ddellacosta_> kvanb: in any case, thanks for the feedback!
00:37:42 <dmwit> petercommand: Okay, I added a Q to the FAQ. =)
00:37:44 <dmwit> http://www.haskell.org/haskellwiki/FAQ#What_does_lambdabot.27s_.22info.22_command_do.3F
00:39:18 <petercommand> Q?
00:39:30 <jle`> is there a sort of superjoin for Either
00:39:46 <jle`> Either e1 (Either e2 x) -> Either e1 x
00:39:51 <jle`> or Either e2 x idk
00:39:59 <dmwit> petercommand: FAQ = Frequently Asked Questions
00:40:18 <petercommand> dmwit: oh..ok thx :)
00:40:44 <sipa> did you also add an A?
00:41:02 <dmwit> I did, but this time the A doesn't stand for the same thing as it does in FAQ. =)
00:41:32 <dmwit> jle`: How could there be?
00:41:50 <dmwit> (a + b + c) -> (a + c) -- and what if it's a b?
00:42:51 <jle`> oh yeah
00:43:10 <jle`> Either e1 (Either e2 x) -> Either (Either e1 e2) x
00:43:13 <jle`> ta da
00:43:25 <pavonia> Here is a small part of my code, that runs an external program and writes its output to a file: http://lpaste.net/107000  Now I'd like to return a value from the forkIO to the main process. What would be the best way to do that in this case?
00:43:39 <jle`> (a + (b + c)) -> ((a + b) + c)
00:43:44 <petercommand> :k Either e1 (Either e2 x)
00:43:45 <lambdabot> Not in scope: type variable ‘e1’
00:43:45 <lambdabot> Not in scope: type variable ‘e2’
00:43:45 <lambdabot> Not in scope: type variable ‘x’
00:43:56 <petercommand> :k Either a (Either b x)
00:43:57 <lambdabot> Not in scope: type variable ‘a’
00:43:57 <lambdabot> Not in scope: type variable ‘b’
00:43:57 <lambdabot> Not in scope: type variable ‘x’
00:44:01 <dmwit> I don't think it's named in any of the common libraries.
00:44:15 <jle`> i should call it
00:44:18 <jle`> reassociate
00:44:23 <dmwit> It's not hard to write. CT guys might call it alpha or something, but associator would be better.
00:44:30 <dmwit> Yep, reassociate would be a fine name.
00:44:48 <dmwit> :k forall a b x. Either a (Either b x)
00:44:49 <lambdabot> *
00:45:17 <dmwit> :t either (Left . Left) (either (Left . Right) Right)
00:45:18 <lambdabot> Either a (Either b1 b) -> Either (Either a b1) b
00:46:44 <jle`> let's have fun doing algebra on ADT's
00:46:46 <jle`> hm
00:46:50 <jle`> if only djinn recognized Either
00:47:02 <jle`> @djinn (a -> c) -> (b -> c) -> Either a b -> c
00:47:02 <lambdabot> f a b c =
00:47:02 <lambdabot>     case c of
00:47:02 <lambdabot>     Left d -> a d
00:47:02 <lambdabot>     Right e -> b e
00:47:06 <jle`> oh, it does
00:47:23 <jle`> @djinn Either a (Either b c) -> Either (Either a b) c
00:47:23 <lambdabot> f a =
00:47:23 <lambdabot>     case a of
00:47:23 <lambdabot>     Left b -> Left (Left b)
00:47:23 <lambdabot>     Right c -> case c of
00:47:23 <lambdabot>                Left d -> Left (Right d)
00:47:24 <pavonia> There are runInBoundThread and runInUnboundThread that allow to return a value from the passed action, but I don't know if these are the right functions here (and if so, which to use)
00:47:25 <lambdabot>                Right e -> Right e
00:47:44 <jle`> i luv u djinn
00:47:56 <jle`> @djinn (a, Either b c) -> Either (a, b) (a, c)
00:47:56 <lambdabot> f (a, b) =
00:47:56 <lambdabot>     case b of
00:47:56 <lambdabot>     Left c -> Left (a, c)
00:47:56 <lambdabot>     Right d -> Right (a, d)
00:47:57 <MP2E> djinn is amazing
00:48:10 <jle`> who knew ADT's were good at algebra
00:48:20 <johnw> the first letter did :)
00:48:26 <jle`> ;_
00:48:28 <jle`> ;)
00:48:38 <jle`> a * (b + c) = a * b + a * c
00:48:50 <jle`> if only i had had ADT's in elementary school
00:49:20 <dmwit> pavonia: Why not just an MVar?
00:49:45 <jomg> also: a ^ (b * c) = (a ^ b) ^ c
00:49:48 <dmwit> pavonia: (At the moment... why bother forking at all?)
00:50:00 <dmwit> pavonia: (I guess there must be some other code that makes it worthwhile.)
00:50:26 <MP2E> I like to cheat and use djinn to define instances of things for me :)
00:50:34 <MP2E> Don't feel like figuring out that Applicative? Make djinn do it!
00:50:44 <pavonia> dmwit: I thought about MVars but I'm not sure if that works well with the waitForProcess
00:51:18 <dmwit> What do you anticipate going wrong?
00:52:31 <jle`> jomg: what is (^) ?
00:52:32 <pavonia> Wouldn't I have two actions wait for a result, i.e. waitForProcess and readMVar?
00:52:38 <dmwit> jle`: (<-)
00:52:49 <jle`> oh yeah
00:52:54 <jle`> just like in sets huh
00:52:58 <dmwit> pavonia: Presumably takeMVar. But yes, so?
00:53:00 <matematikaadit> @djinn ((b, c) -> a) -> c -> b -> a
00:53:00 <lambdabot> f a b c = a (c, b)
00:53:07 <jomg> hmm, is there any way to make djinn work with lists?
00:53:25 <jomg> says "Undefined type: []"
00:53:45 <dmwit> ?help djinn
00:53:45 <lambdabot> djinn <type>.
00:53:45 <lambdabot> Generates Haskell code from a type.
00:53:45 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
00:54:01 <dmwit> ?djinn-add data List a = Nil | Cons a (List a)
00:54:02 <lambdabot> Error: Recursive types are not allowed: List
00:54:04 <MP2E> jomg: not afaik, because djinn doesn't support recursive types
00:54:05 <MP2E> yeah that
00:54:06 <dmwit> jle`: No.
00:54:15 <dmwit> uh
00:54:16 <jomg> oh, ok
00:54:21 <dmwit> jle`: Sorry, I meant that for jomg. =P
00:54:26 <jle`> :)
00:54:37 <MP2E> djinn doesn't support RankN types, recursive types, or primitive types
00:54:39 <dmwit> You also both hash to the same color here. Very confusing.
00:54:44 <pavonia> dmwit: Hhm, okay I will try that. Relating to the other question, how would you eliminate the forkIO?
00:54:44 <MP2E> soo it's not perfect, but it is nice
00:55:05 <dmwit> pavonia: I mean, there's no call for forkIO there. Since you're waiting on the pid, the code is sequential anyway.
00:56:05 <pavonia> The code is a bit dated, but I guess there was a reason for it, I don't recall though
00:56:18 <dmwit> Perhaps you expect applyLineFilters to be very expensive.
00:56:22 <dmwit> In that case it could make sense.
00:57:39 <jle`> perhaps if you use Maybe you an simulate lists to some extent... lists with 0 or 1 element
00:58:08 <dmwit> data ListLol a = Zero | One a | Two a a | Three a a a | Four a a a a | ...
00:58:24 <MP2E> jle`: that is what i do
00:58:32 <MP2E> it works rather well actually :P
00:59:42 <dmwit> foldrlol f z (Four a b c d) = a `f` (b `f` (c `f` (d `f` z)))
01:00:11 <gamegoblin> @pl \x -> mapM_ (f x)
01:00:11 <lambdabot> mapM_ . f
01:00:22 <jle`> data List3 a = Cons32 (List2 a) | Cons31 (List1 a) | Nil3
01:00:39 <gamegoblin> @pl \x y -> mapM_ (f x) y
01:00:39 <lambdabot> mapM_ . f
01:00:42 <jle`> er
01:00:47 <jle`> data List3 a = Cons32 a (List2 a) | Cons31 a (List1 a) | Nil3
01:00:56 <jle`> data List2 a = Cons21 a (List1 a) | Nil2
01:01:19 <jle`> data List1 a = Cons10 a | Nil1
01:01:41 <dmwit> I don't think that says what you want it to say.
01:02:21 <jle`> perhaps i'll play around with it until i find out why that is
01:02:57 <dmwit> How many ways are there to represent [0] :: List3 Int?
01:03:07 <pavonia> dmwit: Why would it matter if the filters are expensive?
01:03:24 <dmwit> pavonia: If the filters are expensive, they may run after the process has completed.
01:03:39 <dmwit> Hence they may still be running in parallel with stuff after the waitForProcess.
01:04:26 <pavonia> Ah, I see
01:04:29 <jle`> Cons32 0 Nil2, Cons31 0 Nil1
01:04:32 <jle`> hm
01:04:38 <jle`> ic
01:04:42 <jle`> how can i fix this?
01:04:47 <dmwit> jle`: Maybe just nix Cons31.
01:04:52 <jle`> only haave a Nil1 ?
01:04:56 <jle`> ah
01:07:31 <jle`> @let toList3 (x:xs) = Cons32 a (toList2 xs); toList3 [] = Nil3
01:07:31 <lambdabot>  .L.hs:161:20:
01:07:31 <lambdabot>      Not in scope: data constructor ‘Cons32’
01:07:31 <lambdabot>      Perhaps you meant one of these:
01:07:31 <lambdabot>        ‘Cons2’ (line 147), ‘Cons3’ (line 150),
01:07:31 <lambdabot>        ‘Const’ (imported from Control.Lens)
01:07:35 <jle`> oops
01:07:39 <jle`> @let toList3 (x:xs) = Cons3 a (toList2 xs); toList3 [] = Nil3
01:07:39 <lambdabot>  .L.hs:161:29:
01:07:40 <lambdabot>      Not in scope: ‘toList2’
01:07:40 <lambdabot>      Perhaps you meant one of these:
01:07:40 <lambdabot>        ‘toList3’ (line 161), ‘F.toList’ (imported from Data.Foldable),
01:07:41 <lambdabot>        ‘IS.toList’ (imported from Data.IntSet)
01:08:15 <jle`> @let toList2 (x:xs) = Cons2 x (listToMaybe xs); toList2 [] = Nil2
01:08:16 <lambdabot>  Defined.
01:08:34 <jle`> @let toList3 (x:xs) = Cons3 x (toList2 xs); toList3 [] = Nil3
01:08:35 <lambdabot>  Defined.
01:08:40 <jle`> > toList3 [1,2,3]
01:08:41 <lambdabot>  No instance for (GHC.Show.Show (L.List3 a0))
01:08:42 <lambdabot>    arising from a use of ‘M417575014514713689116473.show_M4175750145147136891...
01:08:42 <lambdabot>  The type variable ‘a0’ is ambiguous
01:08:42 <lambdabot>  Note: there are several potential instances:
01:08:42 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
01:08:54 <jle`> dangit >_>
01:10:13 <jle`> > toList3 [1,2,3]
01:10:14 <lambdabot>  Cons3 1 (Cons2 2 (Just 3))
01:10:18 <jle`> > toList3 [1..]
01:10:19 <lambdabot>  Cons3 1 (Cons2 2 (Just 3))
01:10:22 <jle`> > toList3 []
01:10:24 <lambdabot>  Nil3
01:10:27 <jle`> > toList3 [1]
01:10:29 <lambdabot>  Cons3 1 Nil2
01:10:37 <jle`> > toList3 [1,2]
01:10:39 <lambdabot>  Cons3 1 (Cons2 2 Nothing)
01:10:44 <jle`> so this should work wiht djinn right
01:11:41 * jle` tinkers
01:28:45 <gamegoblin> Is there a way to take an attoparsec parser and convert it to a `partial`
01:28:52 <gamegoblin> without giving it any input
01:29:04 <gamegoblin> basically extract the parse function from the Parser constructor and stick it inside the Partial constructor
01:29:07 <gamegoblin> they have the same type
01:31:44 <gfixler> I'm a little confused with a LYAH example here: http://learnyouahaskell.com/modules (ctrl+f "needle")
01:32:06 <gfixler> that search function - I don't understand 2 things about how (tails haystack) works
01:32:09 <gamegoblin> gfixler: What’s confusing you
01:32:25 <gfixler> I would think tails haystack is applied, and then it's just the rest of the list
01:32:37 <gfixler> and not reusable for each iteration of the fold
01:33:05 <gfixler> and also, I don't get how it finds a sublist that starts at the the first element, if we're starting by taking nlen from the tail of the haystack
01:33:10 <Pythonfant> foldl is applied on the rest of the list
01:33:13 <Pythonfant> not the complete list
01:33:23 <gfixler> oh
01:33:33 <Pythonfant> :t foldl
01:33:34 <lambdabot> (b -> a -> b) -> b -> [a] -> b
01:33:36 <gfixler> but isn't (tails haystack) going in as x?
01:33:49 <Pythonfant> it's going in as the [a]
01:33:59 <Pythonfant> @src foldl
01:33:59 <lambdabot> foldl f z []     = z
01:33:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:34:05 <gamegoblin> a particular index of tails haystack is going in as x
01:34:16 <gfixler> oh, wait
01:34:17 <Pythonfant> the (x:xs) is tails haystack
01:34:21 <Pythonfant> x is only the first element
01:34:22 <gfixler> I was thinking it was tail x
01:34:24 <gfixler> whoops
01:34:29 <gamegoblin> no worries
01:34:37 * gfixler is embarrassed
01:35:18 <gfixler> I've been staring at this one for awhile - thanks for offering to help, though
01:36:04 <gfixler> I thought chapter 6 was going to be light fare about importing modules, but it's the longest chapter yet, with dozens of functions discussed
02:09:06 <Welkin> has anyone actually used the sdl2 bindings for haskell?
02:09:45 <Welkin> it seems too low level using CStrings
02:10:06 <Welkin> I'm trying to get sdl1.2 bindings installed but keep getting an error
02:10:41 <Welkin> "Missing or bad header file SDL/SDL.h"
02:10:48 <Welkin> but it certainly exists
02:11:40 <l0cust> I am having a problem with ssl
02:11:51 <l0cust> Specifically with warp-tls
02:12:02 <l0cust> It doesn't seem to recognize the key
02:12:37 <l0cust> My app compiles just fine
02:12:52 <l0cust> But, when I try to load it in the browser, I get this error : "podium: no keys found"
02:13:09 <l0cust> Here's Main.hs - http://lpaste.net/107001
02:13:25 <l0cust> All the other stuff is on https://github.com/pharpend/podium
02:17:55 <xeno> so, I'm going through Beginning Haskell, and right now on the lens library... running the following : person2.lastName2 .~ "Kox" $ client2
02:18:21 <xeno> it was supposed to return a new client with the new last name, but it returns one with the original last name... how come?
02:21:58 <lfairy> l0cust: where are your keys stored?
02:22:06 <l0cust> in the keys/ directory
02:23:19 <lfairy> l0cust: is your current directory correct?
02:23:23 <l0cust> lfairy: yes
02:24:22 <lfairy> well, I'm stumped
02:48:29 <sshine> I'm trying to understand cabal packages... I did a reset, installed 'cabal-install', then 'xmonad xmonad-contrib', then 'rest-core rest-client rest-gen rest-types rest-wai'. the last of these warns that I'll break the HTTP-4000.something library. why is that?
02:52:01 <_0xAX> Hello All
02:52:36 <_0xAX> How to use WAI websockets with the last wai? everywhere examples with settingsIntercept but Network.Wai.Handler.Warp doesn't export it now
03:11:00 <Tjr> @src forever
03:11:00 <lambdabot> Source not found. Are you typing with your feet?
03:12:21 <Iceland_jack>     forever x = x >> forever x
03:12:53 <Tjr> I'm wondering how the compiler deduces the type signature from that defintion.
03:13:29 <Welkin> :t forever
03:13:30 <lambdabot> Monad m => m a -> m b
03:13:36 <dv-> > forever [16]
03:13:39 <Iceland_jack> @ty let a = a in a
03:13:40 <lambdabot> t
03:13:40 <lambdabot>  mueval-core: Time limit exceeded
03:14:07 <Welkin> @ty
03:14:08 <lambdabot> <no location info>: not an expression: ‘’
03:14:14 <Welkin> what is ty?
03:14:22 <Iceland_jack> Gets the type of an expression
03:14:24 <Iceland_jack> @ty 'a'
03:14:24 <lambdabot> Char
03:14:27 <Iceland_jack> same as :t
03:14:28 <Iceland_jack> :t 'a'
03:14:29 <lambdabot> Char
03:14:56 <sshine> :t flip flip flip
03:14:57 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
03:14:58 <Iceland_jack> Tjr: You may be interested in http://stackoverflow.com/a/1830251/165806
03:16:19 <ninja_code> anyone here actually managed to install ghc.js
03:16:20 <ninja_code> ?
03:16:33 <ninja_code> i've never seen anything so difficult to install
03:20:55 <sshine> bergmark: I tried by resetting my .ghc/.cabal. all I installed was: cabal-install, xmonad xmonad-contrib, rest-core rest-gen rest-client rest-stringmap rest-types rest-wai. now when I 'cabal build -v' your minimal example, I get the following error: https://gist.github.com/sshine/260513481d75de893b32
03:21:50 <Tjr> Iceland_jack: in that stackoverflow example, it seems counterintuitive to me that t3 != t4 is possible.
03:23:17 <Iceland_jack> It's counterintuitive that they have different types?
03:23:53 <Iceland_jack> Do you think this has a counterintuitive type:
03:23:53 <Iceland_jack>     foo :: [a] -> [b]
03:23:53 <Iceland_jack>     foo [] = []
03:23:53 <Iceland_jack> ?
03:24:50 <Iceland_jack> @ty (\[] -> []) :: [a] -> [b]
03:24:51 <lambdabot> [a] -> [b]
03:26:03 <Tjr> in that case, (foo = map head) would work to show that b=[a] is possible, hence a != b
03:26:45 <Iceland_jack> Why do you say 'foo = map head'?
03:26:50 <Tjr> however, I don't see how sorting things should change their type
03:27:02 <Iceland_jack> @ty map head
03:27:02 <lambdabot> [[b]] -> [b]
03:27:08 <Ainieco> hello
03:27:21 <Tjr> I'm saying "foo" because you said " foo :: [a] -> [b]"
03:27:33 <Iceland_jack> yes but foo and 'map head' have incompatible types
03:28:07 <Ainieco> i trying to understand what covariant and contravariant is. Is Applicative typeclass is a contravariant of Monad class(in perfect world)?
03:28:07 <Tjr> sure they are compatible, in the special case that b = [a]
03:28:29 <Iceland_jack> Yes but in general we don't show any relation between the input and the output
03:29:01 <Iceland_jack> You'
03:29:07 <Iceland_jack> You're right that this is the case
03:29:07 <Iceland_jack> @ty map head :: (a ~ [b]) => [a] -> [b]
03:29:08 <lambdabot> [[b]] -> [b]
03:29:08 <Tjr> if there is a relationship between the input and output types, the compiler generally finds it
03:29:26 <Tjr> so I'm wondering why it doesn't find it in case of the sort algorithm
03:30:26 <Ainieco> hello?
03:30:46 <Ainieco> does my question makes sense?
03:31:13 <Iceland_jack> Tjr: because there is no base case that links 'a' and 'b' together for mergesort
03:31:28 <Tjr> Ainieco: I can't tell, I've not covered the haskell version of co/contra yet
03:32:08 <Ainieco> Tjr: no problem
03:32:10 <gfixler> I want to double-check my understanding of precedence in the following...
03:32:18 <gfixler> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
03:32:18 <Tjr> Iceland_jack: can you think up an example of mergesort :: [a] -> [b] where a and b are truly different?
03:32:30 <gfixler> any isSpace would partially apply, then not would compose with that
03:32:34 <gfixler> then filter would partially apply on that
03:32:55 <gfixler> and groupBy would partially apply on the ((==) `on` isSpace)
03:33:03 <Iceland_jack> Tjr: You can't really express inequality in Haskell's type system
03:33:03 <gfixler> and then the filter and groupBy things would compose
03:33:12 <gfixler> and finally that would apply to the string after $?
03:33:35 <Iceland_jack> gfixler: Pretty much yes
03:33:38 <Ainieco> even if wiki pag(https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science) ) tries to present co/contravariance via OO exaples i think that it's still work with haskell
03:33:42 <Tjr> Iceland_jack: you can't express it in general, but you can tell if you've got an example
03:33:43 <jle`> i guess i do'nt really think of it as partial application in my head anymore
03:33:57 <jle`> i jsut see "filter p is a function on a list returning a list"
03:34:09 <jle`> and i see "groupBy p is a function on a list returning a list of lists"
03:34:19 <jle`> i think of (filter p) as an individual atomic unit
03:34:23 <Iceland_jack> Tjr: Sorry, I'm not completely sure what you're asking
03:34:24 <jle`> and (groupBy p) as an atomic unit s well
03:34:41 <Iceland_jack> (it is possible to express inequality using closed type families but digressions)
03:34:59 <jle`> i don't really see (filter p) as the filter function partially applied to p...i think of (filter p) is just literally the function that filters on that predicate
03:35:01 <Tjr> I'm asking for example types a and b, which are different, such that mergesort :: [a] -> [b] actually makes sense.
03:35:13 <Welkin> jle`, that is because it is
03:35:17 <Tjr> with the stackoverflow implementation
03:35:21 <jle`> oh, the above was directed at gfixler
03:35:34 <jle`> Welkin: yeah, just suggesting another interpretation that might make things clearer for gfixler :)
03:35:35 <gfixler> jle`, sure, just trying to make sure I know what sticks together
03:35:36 <Welkin> it's too much work to think about every function through partial application all the time
03:35:43 <gfixler> it all helps
03:35:43 <Iceland_jack> Tjr: Such that it actually sorts? No
03:35:49 <Ainieco> oh wait does covariance can be applied to langauges which are support subtyping only?
03:36:00 <Tjr> it actually sorts because that's what the stackoverflow implementation does
03:36:06 <gfixler> so really we're just looking at filter foo . groupBy bar $ "string"
03:36:15 <jle`> or even
03:36:18 <Ainieco> does haskell support subtyping via typeclasses?
03:36:20 <Iceland_jack> Tjr: Have you tried running the code?
03:36:35 <Iceland_jack> 'mergesort' applied to anything but the empty list hangs
03:36:42 <Ainieco> anyone?
03:36:43 <jle`> let filterfoo = filter foo; groupBybar = groupBy bar in filterfoo . groupBybar $ "string"
03:37:06 <Tjr> Iceland_jack: you mean, running the example code you gave me a few minutes ago?
03:37:18 <kazagistar> Ainieco: patience, be willing to wait a while if you want answers :)
03:38:18 <gfixler> jle`, I see - I was seeing all the distinct elements, but now I'm seeing it as two concepts with a few details per
03:38:24 <Welkin> Ainieco, you can make a type of instance of several type classes
03:38:30 <Welkin> an instance*
03:38:49 <Welkin> but there is no hierarchy
03:38:52 <Iceland_jack> Yes, the code from the StackOverflow question doesn't work for non-empty lists because it loops and that's why the return type is similar to 'forever'
03:39:01 <Iceland_jack> since 'forever' never returns
03:39:09 <Tjr> Iceland_jack: ghci gives me the same results as posted on stackoverflow. That includes the oddly missing constraint that a=b.
03:39:42 <jle`> gfixler: another step to push referential transparency a bit more, it's all equivalent to let filterfoo = filter foo; grouBybar = gorupBy bar; filterfoogroupBybar = filterfoo . groupBybar in filterfoogroupByBar "string" :)
03:39:53 <jle`> modulo typos
03:40:22 <Iceland_jack> I feel like we're talking past each other, I'm going for some coffee
03:40:40 <gfixler> jle`, nice, I like that
03:40:49 <kazagistar> Ainieco: http://stackoverflow.com/questions/9302739/covariance-contravariance-in-haskell does this answer work for you?
03:41:01 <jle`> it's as if haskell evaluation were just a string find-and-replace...
03:41:28 <gfixler> I do so love regexps
03:41:41 <Ainieco> kazagistar: yep
03:41:48 <Ainieco> thanks
03:43:57 <kazagistar> gfixler: its not exactly that kind of search and replace, because it still respects namespaces and such
03:44:50 <sinelaw> Peaker, yo
03:44:54 <gfixler> kazagistar, no worries. I don't actually think it's like regexps
03:47:46 <Tjr> Iceland_jack: (when you're back): I get it now. My error was that I didn't see that the base case "mergesort [a] = [a]" is missing in the stackoverflow code. This base case adds the expected constraint. In a way, the compiler warns about programming errors :-) Thanks for prodding me into the right direction.
03:49:16 <Iceland_jack> Tjr: I felt like I was giving rubbish suggestions :) good that it ended up making sense
03:50:27 <Tjr> @let let unforever a   = let a' = a >> a' in a'
03:50:27 <lambdabot>  Parse failed: Parse error: EOF
03:50:33 <Tjr> @let unforever a   = let a' = a >> a' in a'
03:50:35 <lambdabot>  Defined.
03:50:38 <Tjr> @ty unforever
03:50:38 <lambdabot> Monad m => m a -> m b
03:50:59 * Tjr ponders why the constraint a=b is missing.
03:51:56 <Iceland_jack> Well because
03:51:56 <Iceland_jack>       unforever a
03:51:56 <Iceland_jack>     = a >> a'
03:51:56 <Iceland_jack>     = a >> (a >> a')
03:51:59 <Iceland_jack>     = a >> (a >> (a >> ...))
03:52:08 <Iceland_jack> so it will never return
03:52:38 <MP2E> yeah so there isn't any result, m b is the monad over bottom, I'd assume
03:52:44 <MP2E> right? :S
03:53:05 <Tjr> i see it now, thanks
03:53:23 <maybefbi> does anyone know a plot library that can plot a list of data points on a window without strictly evaluating the entire list before updating the window?
03:53:51 <Tjr> @let forlong 1 a = a ; forlong n a = a >> (forlong (n-1) a)
03:53:52 <lambdabot>  Defined.
03:53:57 <Tjr> @ty forlong
03:53:58 <lambdabot> (Num a, Monad m, Eq a) => a -> m a1 -> m a1
03:54:25 <Iceland_jack> @let forlong' 1 a = a
03:54:26 <Tjr> so a1 = a1 is detected if the interation terminates.
03:54:26 <lambdabot>  Defined.
03:54:27 <Iceland_jack> @ty forlong'
03:54:28 <lambdabot> (Num a, Eq a) => a -> t -> t
03:54:47 <Iceland_jack> Tjr: It can still not terminate so it's not a termination checker
03:55:18 <Tjr> true. In this case, it terminates (if n >0), and that's what get the type inference working.
03:56:01 <Iceland_jack> for example
03:56:01 <Iceland_jack>     bar :: Int -> t -> t
03:56:01 <Iceland_jack>     bar 0 a = a
03:56:01 <Iceland_jack>     bar n a = bar n a
03:56:11 <Iceland_jack> will loop when the first argument is non-zero
03:56:27 <Iceland_jack> So it only takes a single case to 'constraint' the result type
03:57:37 <kazagistar> maybefbi: I am not sure what the benefit to that would be... slowly showing partial data as the results of a long computation trickle in or something?
03:58:11 <maybefbi> kazagistar, yeah
04:00:01 <kazagistar> maybefbi: you might just wanna to it explicitly, like drawing a graph for each X data points
04:00:27 <Iceland_jack> maybefbi: I think it's a cool idea, a kind of on-line graph plotting
04:01:14 <maybefbi> kazagistar, what GUI library can do updates on the screen from a list that hasn't been fully evaluated yet?
04:01:17 <kazagistar> maybefbi: the logic that most graph libraries function under afaik is that their result is supposed to be a single image file at the end, not an animation
04:01:29 <maybefbi> kazagistar, true
04:01:45 <maybefbi> Iceland_jack, i want online graph plotting to get a feeel for the data
04:03:37 <Pythonfant> maybefbi: let us no if you find something that sounds really cool
04:04:12 <maybefbi> Pythonfant, will do
04:05:31 <kazagistar> maybefbi: take every n'th item from the inits of the data stream, graph it, and then for each graph in the list run an event that sets in it the GUI, something like that
04:05:47 <kazagistar> maybefbi: of course, the devil is in the details, good luck
04:06:28 <maybefbi> ok
04:06:38 <kazagistar> inits is lazy, so it should all work
04:07:45 <kazagistar> the driving function (the "display multiple graphs in a row action") will request each graph, which will request more of the list, which will drive evaluation
04:28:28 <tremon> hi all, given this code: http://lpaste.net/107003 -- encodeUtf8 "string literal" is giving me "No instance for ([..]IsString [..]Text)"... but if I uncomment the Data.Aeson import line, the compile succeeds. What's Data.Aeson doing that I'm missing?
04:32:30 <kazagistar> tremon: probably importing the IsString instance for Text?
04:33:53 <tremon> ah yes. "import Data.Text (Text)" is enough to solve it
04:33:56 <tremon> thanks
04:43:02 <tremon> now for my real question, has anyone worked with Network.HTTP.respondHTTP? The code above compiles and starts fine, but no data is ever sent over the socket
04:43:08 <nikanda> Hi, I"m trying to understand least and greatest fixpoints. So if I have a complete lattice L (such that any subset has a join and meet in L), then the least fixed point is the meet of Fix(f) = {l | l = f(l) and l in L} . Now, is it true that this least fixed point does not have to be in Fix(f) itself, but only in L?
04:50:37 <Saizan> nikanda: the fixed point satisfies that equation, so it will be there
04:58:05 <tremon> nvm, found it. I realized I was using a forkFinally that ate any exception messages.
05:03:18 <Tjr> How do I use lambdabot to send somebody a message?
05:03:28 <Tjr> (@messages retrieves messages, but there's not hint how to send.)
05:03:35 <Tjr> s/not/no/
05:04:09 <Saizan> Tjr: @tell nick message
05:04:15 <Tjr> thanks
05:08:24 <nikanda> Saizan: what if I have only two fixed points, and their meet is not one of them?
05:13:52 <kvanb> what's an idiomatic way for a function to decide whether it wants to "proceed" or not?
05:14:21 <kvanb> I have a pipeline, and I want handlers to be able to tell the thing above "Please, let's move on in the Moore machine" or something like that.
05:14:44 <kvanb> monadic approach preferred to return values.
05:19:40 <kazagistar> kvanb: maybe a coroutine monad?
05:21:55 <Saizan> nikanda: that would make the set of fixed points in L not a complete lattice, which would break the knaster-tarski theorem
05:22:24 <kvanb> kazagistar: already using pipes
05:22:37 <kvanb> so I have like, a moore machine which looks similar to this
05:22:48 <kvanb> handshake >> authenticate >> session >> disconnect
05:23:03 <Saizan> nikanda: the proof of that theorem might help you find a more concrete answer
05:23:06 <kvanb> using ErrorT to quit out early
05:23:18 <Saizan> (i don't remember the details well enough)
05:23:29 <kvanb> oh actually, I just figured it out.
05:23:32 <kvanb> thanks kazagistar :P
05:24:45 <kazagistar> kvanb: well, ill count it as a win anyways, cause it puts me at 5/5 answered IRC questions this morning :D
05:24:56 <kvanb> hah
05:41:09 * hackagebot apiary 0.11.3 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.11.3 (HirotomoMoriwaki)
05:46:10 * hackagebot apiary-websockets 0.11.1 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.11.1 (HirotomoMoriwaki)
05:46:12 * hackagebot apiary-eventsource 0.11.3 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.11.3 (HirotomoMoriwaki)
05:47:18 * sshine is currently compiling Haskell packages by tilting his computer and using a cooling blowdryer so his laptop doesn't overheat.
05:49:31 <Qfwfq> Haha
05:52:50 <ion> sshine: My laptop has also developed cooling issues, i should open it and replace the thermal paste.
05:58:37 <sshine> ion, exactly my thought. only I need to buy some first.
05:58:45 <sshine> ion, and buy a screwdriver.
05:59:23 <sshine> well, at least I can say my computer goes from 40 to 90 celcius in 10 seconds :)
06:05:26 <matematikaadit> So when does Applicative firstly introduced?
06:06:27 <matematikaadit> Is it 2008 according to this paper http://www.soi.city.ac.uk/~ross/papers/Applicative.html
06:06:48 <peterhil> Trollinator: I think I'll try the HsQML for making GUIs...
06:08:34 <Jenna21>  You can find funny videos here. http://bit.ly/1ksAKKv
06:10:57 <donri> cool, it's so hard to find funny videos on the web
06:13:51 <sshine> haha
06:14:00 <peterhil> :-)
06:14:09 <Rizo_Isrof> Hello, haskell community! I am new to Haskell and am choosing a language for my next project – (a graph database + logic-based query interface). Would you recommend haskell for the job? Why not other languages like OCaml, Rust, D or even Idris?
06:21:57 <peterhil> Rizo_Isrof: I'm still learning Haskell, but yesterday I was suprised about the amount of useful looking packages on Hackage: http://hackage.haskell.org/packages/ There are even bindings for cypher. I'd definitely give it a try, especially if you know some ML based language already. Otherwise you might have some learning (and unlearning) to do. But one possible downside of using Haskell might be the difficulties of handling graphs and trees as da
06:21:57 <peterhil> ta structures in a pure functional language.
06:23:48 <peterhil> On the other hand, the Haskell's FFI is great, so implementing tree like datastructures in another language might be an option.
06:24:36 <MP2E> Rizo_Isrof : Why use Haskell? I would argue the code-power ratio is unmatched. The terse syntax combined with the very polished typeclasses, libraries and structures allow for very short and powerful code. Short code is maintainable code.
06:26:10 <wei2912> i wouldn't call regular expressions maintainable
06:26:34 <MP2E> good point, but regular expressions are more line noise than syntax
06:27:02 <wei2912> line noise?
06:27:12 <peterhil> Regexps have very terse syntax.
06:28:35 <MP2E> Well compare Haskell's readability to regexps
06:28:45 <MP2E> unless you've been staring at regexps all of your life, you will notice a huge difference.
06:29:40 * MP2E personally has a distaste for regexps
06:31:38 <wei2912> terse syntax is not always good
06:31:50 <MP2E> I never stated that
06:31:54 <wei2912> though
06:32:06 <wei2912> MP2E, ik, just mentioning that
06:32:38 <wei2912> i guess haskell can be powerful; i haven't used haskell or done any FP much
06:32:47 <donri> Rizo_Isrof: supposedly efficient pure graph databases are an unsolved problem, so you'd probably have to make it a mutable store. but haskell is also the world's finest imperative language, so
06:34:34 <peterhil> And interacting with the REST interfaces of Graph databases shouldn't be a problem, since I've understood there are good networking libraries available in Haskell.
06:35:09 <donri> i understood the project to be writing your own graph db
06:35:49 <peterhil> Oh, that'd be cool!
06:36:14 <peterhil> I have wondered why all the Graph databases except for Dex are implemented in Java...
06:38:05 <khanage> masochism/
06:38:07 <khanage> ?
06:38:09 <jkarni> how does one write a show instance for an Arrow ADT (http://lpaste.net/107008)? the middle type of the (>>>) constructor falls out, so you can’t really have a Show constraint on it…
06:41:32 <peterhil> Rizo_Isrof: Then these might be of interest: http://hackage.haskell.org/packages/#cat:Graphs http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
06:42:18 <rwbarton> jkarni, get rid of (Show a, Show b) =>
06:42:23 <kazagistar> jkarni: hmm, maybe I am not understanding... how do you expect to write a show instance for a function?
06:42:45 <rwbarton> but I doubt this will be too helpful anyways, yes
06:43:06 <jkarni> kazagistar: I’m not - just showing “<function>” in the “arr” constructor case
06:44:27 <rwbarton> since there is no way to get any a or b out of your Arr type, the (Show a, Show b) context is useless
06:45:17 <jkarni> rwbarton: aha! I should have thought of that
06:45:21 <jkarni> rwbarton: thanks
06:48:01 <peterhil> khanage: Quite possibly... :-)
06:50:40 <bhurt> http://pastebin.com/eq6eMtpZ
06:51:34 <bhurt> So when I try to compile that code, it says there is no instance of Foo Int.  I thought that the default implementation of foo would get derived.
06:51:40 <bhurt> What am I doing wrong?
06:52:01 <bhurt> This is ghc 7.8.2.
06:52:10 <rwbarton> you still need to write an instance declaration "instance Foo Int"
06:53:00 <rwbarton> you just don't need to define 'foo' therein
06:55:01 <Rizo_Isrof> MP2E: Short code was one of the first things I started to like in Haskell. I wrote some simple samples in OCaml and Haskell and Haskell code tands to look much more consice and clean. Mainy thanks to higher kinded polymorphism, whcih OCaml lacks.
06:57:14 <Rizo_Isrof> donri: given what you said, do you think OCaml (for not being entirely pure) would be a better feet for mutable graph algorithms?
06:59:10 <Rizo_Isrof> peterhil: thanks! this kind of articles are really helpful! I spend my life writing imperative code so learning to model the things the functional way is a challange for me.
07:02:30 <Rizo_Isrof> To give a little bit more context: its not just a graph database. I plan to create an ontology-based database. Of course it will be based on graphs but my idea is to start experimenting with a model for defining objects and relations. Think of it as a simplified version of RDF/Owl.
07:08:59 <peterhil> Rizo_Isrof: The books, that I've found good when learning Haskell are "Learn you a great Haskell" http://learnyouahaskell.com/ and "Real World Haskell" http://book.realworldhaskell.org/, both available online for free.
07:10:38 <peterhil> Especially the latter has helped me to get a hold on how to solve problems in the functional programming way.
07:10:44 <Rizo_Isrof> I know about them and have already ordered a copy of Real World Haskell (and Real World OCaml too By the way).
07:11:49 <Rizo_Isrof> I think writing functional code is the first part of the problem. Another and a more difficult one IMO is to model the domain of your problem the functional way: with adts and typeclasses.
07:15:42 <wz1000> Will xmonad run fine if i install it through cabal? I don't want to use ubuntu's packages as I'm running GHC 7.8 and having two versions of GHC on the same machine somehow screws something or the other up.
07:16:19 <MP2E> wz1000 : I'm running xmonad on cabal right now :) Just make sure your cabal path is in your $PATH
07:16:32 <MP2E> xmonad from cabal*
07:16:46 <wz1000> MP2E: Thanks. I'll try it out.
07:23:02 <muratamuu> ??
07:26:39 <ninja_code> is there anyway to get haskell to control a browser
07:26:47 <ninja_code> so I can hook haskell into browser events and modify the DOM ?
07:26:52 <ninja_code> I'm not asking for a Haskell -> Javascript compiler
07:27:02 <ninja_code> I want a Haskell binding to Chrome or a Haskell binding to Webkit / Safari / Firefox
07:27:04 <ninja_code> or something like that
07:27:51 <platz> ninja_code: http://www.haskell.org/haskellwiki/Threepenny-gui
07:27:52 <bennofs1> ninja_code: there is a webkitgtk[3] package on hackage IIRC. That doesn't allow integration with existing browsers though
07:28:35 <ninja_code> platz: damn, it's used in real products?
07:28:51 <platz> ninja_code: I'm not sure it's meant for that
07:29:14 <jedai> ninja_code: depends on what you call "real products"
07:29:21 <ninja_code> well
07:29:23 <ninja_code> I saw "torchlight"
07:29:26 <ninja_code> thought itwas real game
07:29:33 <ninja_code> but turns out, it's some tool for editing torchlight save files
07:29:42 <MP2E> haha
07:29:59 <jedai> ninja_code: it isn't used in professional application but some tools written with it are real, useful applications (not many mind you)
07:30:13 <Guest86083> hello
07:31:03 <jedai> ninja_code: anyway, threepenny is clearly at the "experimental" stage of development, everything change pretty rapidly
07:31:09 <ninja_code> yeah
07:31:51 <jedai> ninja_code: but I can at least say that it works and can be used practically with very little setup (much better than most heavyweight solutions this way)
07:32:18 <Guest86083> how can i hack?
07:32:33 <ninja_code> you need to train first
07:32:43 <ninja_code> by reading "real world haskell"
07:32:48 <Guest86083> train what?
07:32:51 <ninja_code> folllowed by CLRS "introduction to algorithms"
07:32:54 <Guest86083> what is this
07:32:57 <sipa> your h4ckz0r skills
07:33:01 <jedai> ninja_code: depending on your objective it can be perfectly appropriate, for instance for a pretty simple gui skin over some interesting pure code, for visualization or control
07:33:10 <ninja_code> jedai:
07:33:16 <ninja_code> I'm going to stick with haste
07:33:19 <ninja_code> even though it's not full ghc
07:33:21 <Guest86083> what is haskel
07:33:29 <sipa> a programming language
07:33:38 <Guest86083> used for?
07:33:45 <sipa> many things
07:33:49 <Guest86083> hacking?
07:33:49 <nexx> programming
07:34:01 <ninja_code> haskell is used to debug thinking
07:34:09 <khanage> ninja_code: +1
07:34:17 <ninja_code> when I think I understand something, I implement it in haskell, and the compiler finds all the bug in my thinking
07:34:31 <Guest86083> so how do i learn to hack
07:34:36 <jaykru> sigh
07:34:37 <pjdelport> @remember ninja_code haskell is used to debug thinking
07:34:37 <lambdabot> It is forever etched in my memory.
07:34:44 <Welkin> you do not "hack" in haskell
07:34:54 <ninja_code> what is haskell?
07:34:57 <bennofs1> Guest86083: read a book, like Learn You a haskell for great good
07:35:00 <bennofs1> @where lyah
07:35:00 <lambdabot> http://www.learnyouahaskell.com/
07:35:02 <ninja_code> lambdabot: what is haskell
07:35:05 <Welkin> you have to come up with a solid foundation
07:35:08 <zomg> baby don't hurt me
07:35:11 <sipa> Guest86083: learn to program, learn computer systems, learn security, ...
07:35:13 <bennofs1> Guest86083: That book is free to read online (see link above)
07:35:27 <Guest86083> thank you
07:35:32 <Welkin> "hacking" is what you do with javascript
07:35:37 <MP2E> lol
07:35:39 <jaykru> Guest86083: try reading The Art of Exploitation
07:35:41 <sipa> vbscript; please
07:35:47 <Welkin> if you mean security programming, that is different
07:35:50 <jaykru> Haskell is not what you're looking for.
07:35:58 <jaykru> I don't know how you got here?
07:36:15 <sipa> 'haskell' sounds like 'hack', i'm sure
07:36:22 <Welkin> hakyll
07:36:39 <jaykru> eh that was my assumption
07:36:43 <Guest86083> so why would i need to learn haskell?
07:36:51 <jaykru> You probably wouldn't.
07:36:54 <sipa> why do you learn math?
07:37:03 <ninja_code> you should
07:37:05 <platz> ninja_code: an approach based more on "automation" for things like testing would be using selenium/webdriver https://hackage.haskell.org/package/webdriver
07:37:08 <merijn> Learning how to hack in 2 simple steps: 1) spend years learning math, programming languages, operating systems, networking, security and exploits 2) realise that with the stuff you've learned it's much easier and much less work to build cool things and get paid tons of money then it is to hack things
07:37:16 <ninja_code> do you wnat to be a pure hacker, or a impure hacker?
07:37:25 <zomg> Can't help but feel like this is some sort of troll/script kiddie nonsense
07:37:26 <zomg> :P
07:37:35 <ninja_code> do you want to be a functional hacker, or a buggy hacker?
07:37:35 <jaykru> the skid marks
07:37:41 <jaykru> they burn
07:37:48 <Guest86083> programming is not hacking
07:37:57 <sipa> it's a prerequisite
07:38:04 <bennofs1> Guest86083: it's sometimes called hacking thou
07:38:09 <jaykru> depending of your definition of hacking
07:38:10 <MP2E> programming *is* hacking, hacking is the art of making something do something it was not originally intended for
07:38:13 <ninja_code> Guest86083: go read Knuth's TAOCP
07:38:21 <MP2E> what you are thinking of hacking is 'cracking', aka, breaking into security or systems
07:38:23 <sipa> Guest86083: you're welcome here if you have actual questions about the programming language haskell... but this channel is not about hacking
07:38:25 <Welkin> "hacking" is throwing code at a problem unti it goes away without a real understanding of how you made it work
07:38:29 <Guest86083> yes cracking
07:38:36 <Welkin> or utilizing bugs in a system to get something to work
07:38:38 <sipa> Guest86083: that's definitely offtopic here
07:38:43 <Guest86083> how do i learn cracking
07:38:47 <sipa> not here
07:38:48 <jaykru> Go to #crack
07:38:51 <Guest86083> not hacking sorry
07:38:55 <Guest86083> okay thanks
07:39:22 <ninja_code> there needs to be a command on IRC,
07:39:30 <Qfwfq> I'm pretty sure that's a heroin enthusiasts channel, jaykru. It's unfair to be so misleading.
07:39:31 <ninja_code> where /ignore nick not only ignores nick, but also all responses directed at nick :-)
07:39:36 <jedai> This channel is almost too tolerant... Though I really wonder how this guy found his way here...
07:39:48 <zomg> jedai: probably the channel list
07:39:51 <jaykru> Qfwfq It was probably mean :/
07:39:55 <zomg> ninja_code: Irssi has that feature I believe
07:40:00 <jaykru> Qfwfq although it's an empty channel
07:40:13 <jaykru> Qfwfq I'll just give him/her some books to read
07:40:24 <Qfwfq> :-)
07:40:49 <platz> the art of deception
07:41:12 <Qfwfq> There's little to say that Haskell can't be used for security programming, besides that the libraries and tooling don't really exist yet.
07:41:16 <jedai> What exactly go through the head of someone to go in a random channel (haskell has only 'ha' in common with hack) and ask how to do something illegal ?
07:41:32 <ninja_code> I think this was an opportunity for us
07:41:41 <ninja_code> to take some from the dark path to the light path of haskell
07:41:42 <ninja_code> and we failed
07:41:43 <Welkin> what is illegal about computer security?
07:42:01 <zomg> jedai: gotta start somewhere I guess :P and it's not illegal unless you do it without permission to someone else's machine
07:42:14 <zomg> machine and/or software
07:42:42 <jedai> Welkin: clearly this guy wasn't interested in computer security (or in hacking) but rather in other's computers _in_security (so cracking)
07:42:44 <Welkin> anyway, this is a great resource for learning computer security: https://engineering.purdue.edu/kak/compsec/Lectures.html
07:42:45 <Qfwfq> Well, unauthorised access to computer systems is illegal in most jurisdictions. But inconveniently accessing your own machine, or pentesting with permission is perfectly legitimate.
07:43:09 <jaykru> His goal is to "crack facebook webpages networks ect"
07:43:18 <jaykru> So at least in this case
07:43:18 <MP2E> rofl
07:43:20 <pjdelport> Qfwfq: Modulo the DMCA in the US. *duck*
07:43:24 <jaykru> the cracking was illegal
07:43:24 <ninja_code> stalk all the exes
07:43:36 <jedai> I don't think someone interested in computer security would start by asking how to learn cracking (and not even knowing the difference with hacking)
07:43:36 <zomg> yeah I'm not very surprised that was his goal =)
07:43:45 <Welkin> that must have been Guest86083
07:44:06 <MP2E> oh god Guest86083's power has become too much, what have we done?!?
07:44:10 <MP2E> all the facebooks will be hacked
07:44:12 <MP2E> all of them
07:44:23 <Qfwfq> pjdelport: Yeah, anti-circumvention is awful. It's poorly designed enough that it allows those outside of government to invent their own laws.
07:45:24 <ninja_code> consequences will never be the same again
07:45:36 <Qfwfq> Anyway, I was learning me an algebra. AFK.
07:45:48 <ninja_code> for great good!
07:45:55 <jaykru> he keeps on throwing out random security names and vocabulary incorrectly and I'm in hysterics
07:46:05 <int3__> @pl \f a b c -> f c
07:46:05 <lambdabot> const . const
07:46:08 <MP2E> i gotta see this :P
07:46:09 <pjdelport> That raises an interesting thought experiment: if you use a type system to enforce security / "protect" copyright, would unsafePerformIO / unsafeCoerce etc. be literally breaking the law?
07:46:15 <int3__> @pl (\f a b c -> f c)
07:46:15 <lambdabot> const . const
07:47:32 <int3__> @pl (\f a b c -> f b c a)
07:47:33 <lambdabot> flip . (flip .)
07:47:40 <khanage> pjdelport: only in the case where the law explictly states you much conform
07:48:04 <MP2E> 07:43 < Guest86083> what laungauge did kevin mitnick use to hack
07:48:04 <MP2E> 07:43 < jaykru> Spanish
07:48:10 <MP2E> too much/
07:48:11 <MP2E> haha
07:48:11 <khanage> pjdelport: it would be nice to lift those sins from just taste
07:48:13 <ninja_code> point-less codying style
07:48:15 <jaykru> I'm such an asshole xP
07:48:38 <jaykru> I mean I think he lived in Nevada for a while
07:48:51 <jaykru> So pretty close to a large Spanish speaking population
07:48:59 <jaykru> and in large part he used Social Engineering
07:49:08 <jaykru> Therefore I did not lie
07:49:18 <pjdelport> khanage: Right; i meant using them to circumvent the alleged protection, of course.
07:49:39 <Welkin> are you trolling him in #crack ?
07:50:06 <jaykru> Welkin eh kinda
07:50:22 <khanage> what do you call someone who has read a book on comonads?
07:50:30 <jaykru> Welkin I'm trying to be a bit helpful in between the lulz
07:50:33 <Welkin> sounds like a drug chat
07:50:49 <jaykru> Welkin I honestly thought it was going to be about crack
07:50:49 <khanage> a coauthor!
07:50:54 <Welkin> ChanServ is watching
07:50:58 <Welkin> always watching
07:50:59 <jaykru> lmfao
07:51:03 <kazagistar> khanage: well played
07:51:06 <jaykru> it's entirely empty
07:51:25 <khanage> kazagistar: :)
07:57:13 <khanage> @pl \e -> putStrLn $ "asdasd" ++ show e
07:57:13 <lambdabot> putStrLn . ("asdasd" ++) . show
07:58:22 <sm> morning all
07:59:09 <ocharles> Does anyone know how to use GHC profiling to only profile a single module
07:59:31 <ocharles> I.e, when I profile my web app, I see profiling of the internals of Snap - but I don't care about that/can't change the outcome there
08:00:20 <sm> is this the right way to do a cabal build and get profiling information from both the packages mentioned ? I get all 0's for the -lib package: hledger$ cabal install -p --enable-executable-profiling --ghc-options='-prof -fprof-auto' ./hledger-lib ./hledger
08:00:28 <sm> hey, snap
08:01:05 <bennofs> ocharles: set SCC manually or only enable -fprof-auto on some modules (via OPTIONS_GHC) ?
08:01:20 * hackagebot rest-gen 0.14.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14.1 (AdamBergmark)
08:01:41 <ocharles> Hmm
08:02:02 <ocharles> I'm doing ghc --make -prof -fprof-auto at the moment, i'll try it with options_ghc
08:03:49 <ocharles> Bah, doing -fprof-auto-exported in one module still shows all of Snap's stuff
08:03:56 <ocharles> I guess I'll have to hand-thread SCCs
08:08:39 <sm> if I understand it, installing everything with cabal install -p (or building with ghc -prof) includes the profiling support, and then building something with annotations enabled (eg -fprof-auto) activates the profiling in that something
08:09:13 <sm> so my command above, if it rebuilds hledger-lib and hledger, should report profiling info from just those packages and not the lower-level ones
08:09:23 <ocharles> I think it's because snap has "ghc-prof-options: -auto-all"
08:09:36 <ocharles> which means that I can't get rid of Snap's profiling
08:15:37 <mietek> What is the relation between GHC generics and SYB?
08:18:00 <ninja_code> i hav ea question
08:18:05 <ninja_code> it has been said: reafctoring with types is hard
08:18:09 <ninja_code> because you have to change many things
08:18:17 <ninja_code> now, however, I'm starting to think: refactoring with types is easy
08:18:20 <ninja_code> beacuse the compiler tels you all errors
08:18:36 <ninja_code> .... is this how people view haskell refactoring now?
08:18:53 <MP2E> it's definitely how I view it. Without the type system, refactoring is a nightmare imo
08:19:12 <MP2E> Take any C program. I hack it til it works, error by error, and then the executable is usually messed up in 5 or 6 different ways depending how large the refactor is
08:19:31 <MP2E> now I have to 'debug and chug'
08:19:38 <c_wraith> ninja_code: I absolutely believe haskell provides the most help maintaining code of any language I've worked with.
08:19:39 <MP2E> with haskell if it compiles, theres a high chance it works
08:19:44 <MP2E> a very high chance
08:19:49 <MP2E> it always astounds me still
08:19:50 <MP2E> hehe
08:20:00 <c_wraith> ninja_code: and much of that comes from the compiler telling me when I forgot to update something in a big change.
08:20:42 <ninja_code> c_wraith: yeah, I fee like, compared with clojure, I'm more willing to refacotr in haskell
08:20:47 <ninja_code> becuase I know that the compiler will catch my stupidity
08:20:56 <ninja_code> so I'm like "okay, I'm not afraid of fucking up"
08:21:20 <Hafydd> N.B. you can still fuck up
08:21:33 <MP2E> You can, but the ways that you can fuck up are constrained heavily
08:21:41 <MP2E> this makes finding the source of the problem all the easier :)
08:23:07 <benzrf> indeed
08:23:17 <Tjr> MP2E: that's called advertizement. (The fine print: try to make sense of at least compiler error message, at your choice.)
08:23:40 <Tjr> at least one
08:23:50 <Lutin`> k give me one
08:24:10 <Tjr> any
08:24:13 <Tjr> just pick one
08:24:19 <Tjr> whichever you find easiest
08:25:16 <c_wraith> I like ones where GHC complains that its brain exploded
08:25:19 <MP2E> I'll take reading an elaborate compiler message over plodding through code in the dark trying to figure out what state I screwed up any day
08:25:52 <MP2E> GHC's compiler messages are not that bad, especially compared to GCC's
08:25:54 <c_wraith> @let data Foo a where Foo :: Foo ()
08:25:55 <lambdabot>  Defined.
08:26:18 <c_wraith> > let Foo = Foo in ()
08:26:19 <lambdabot>  can't find file: L.hs
08:26:33 <c_wraith> > let Foo = Foo in ()
08:26:35 <lambdabot>  ()
08:26:39 <c_wraith> Hmm.  I'm bad at this.
08:26:42 <c_wraith> @undefine
08:26:42 <lambdabot> Undefined.
08:26:56 <MP2E> It's literally a choice between 'here's the problem, I'll explain it in an ornate way' vs 'welp the problem could be anywhere. Have fun!'
08:27:06 <c_wraith> @let data Foo a where Foo :: Int -> Foo Int
08:27:07 <lambdabot>  Defined.
08:27:20 <c_wraith> > let Foo x = Foo 5 in x
08:27:21 <lambdabot>  5
08:27:37 <c_wraith> Huh.  I could swear that used to make GHC's head explode.
08:27:46 <jmcarthur> huh
08:27:47 <jmcarthur> me too
08:28:09 <Tjr> so how is the data Foo ... declaration legal haskell in the first place?
08:28:19 <c_wraith> Tjr: GADT extension
08:28:37 <benzrf> hmmmmm
08:29:02 <benzrf> uit
08:30:01 <c_wraith> Tjr: It lets you indicate that constructors for a type can indicate the types they result in.
08:31:16 <c_wraith> Tjr: this lets you set up two-way restrictions - if you have a specific type, you know the allowed set of constructors is reduced.  If you have a specific constructor, you know the types more specifically.
08:32:16 <Lutin`> Hmm
08:32:23 <jmcarthur> c_wraith: i think the pattern is not introducing the type equality, so i'm thinking this didn't introduce any soundness issues. surprised i didn't hear about the change, though.
08:32:24 <Lutin`> @let data Bar a where Bar :: a -> Bar Int
08:32:25 <lambdabot>  .L.hs:153:1:
08:32:25 <lambdabot>      Multiple declarations of ‘Bar’
08:32:25 <lambdabot>      Declared at: .L.hs:150:1
08:32:25 <lambdabot>                   .L.hs:153:1
08:32:25 <lambdabot>  
08:32:40 <Lutin`> > let Bar x = Bar 'c' in x
08:32:41 <lambdabot>  My brain just exploded
08:32:41 <lambdabot>  I can't handle pattern bindings for existential or GADT data constructors.
08:32:41 <lambdabot>  Instead, use a case-expression, or do-notation, to unpack the constructor.
08:32:45 <Lutin`> There we go
08:33:04 <int-e> @ghc
08:33:04 <lambdabot> Bad eta expand
08:33:14 <MP2E> That's still pretty clear as what to do, even with an exploded brain!
08:33:23 * Tjr 's brain exploded.
08:33:58 <jmcarthur> why did that one explode ghc's brain but not c_wraith's?
08:34:07 <Lutin`> Bar :: a -> Bar Int
08:34:22 <c_wraith> because that one is existential, and mine wasn't
08:34:30 <MP2E> ah
08:34:55 <Lutin`> GHC can't just pick the int to go there
08:35:37 <c_wraith> Tjr: the most useful introduction to GADTs involves typed expressions.  Something like data Exp a where EInt :: Int -> Exp Int ; EBool :: Bool -> Exp Bool ; EIf :: Exp Bool -> Exp a -> Exp a -> Exp a
08:36:20 <pjdelport> http://en.wikibooks.org/wiki/Haskell/GADT / http://www.haskell.org/haskellwiki/GADTs_for_dummies
08:36:35 <Tjr> somehow, I've got at least 5 dangling right sides of "data foo = Constructor stuff"
08:40:36 <benzrf> Tjr: GADTs are just ADTs where you get to specify how the result type of a constructor is calculated from its arguments
08:41:23 <benzrf> Tjr: generally, parameters to a type constructor are either polymorphic or determined by the presence of an actual value of that type
08:41:29 <sm> faugh! finally a useful profile. Shouldn't --enable-executable-profiling and --ghc-options=-fprof-auto be the default when you do cabal install -p  ?
08:41:34 <benzrf> GADTs allow you to have a third option
08:41:52 <Tjr> that makes sense
08:42:16 <benzrf> @let data WhoWhere'dTheFunctionComeFrom t where WWTFCF :: a -> WhoWhere'dTheFunctionComeFrom (Int -> a)
08:42:17 <lambdabot>  Defined.
08:42:23 <benzrf> :t WWTFCF "foo"
08:42:24 <lambdabot> WhoWhere'dTheFunctionComeFrom (Int -> [Char])
08:42:31 <benzrf> ^there's no function or int in that vaue
08:42:33 <benzrf> *value
08:42:36 <Tjr> traditionally, constructor functions don't really "compute" anything anyway. They just stay there, the result gets called data type, and you can pattern match them
08:42:41 <benzrf> yeah
08:42:46 <benzrf> neither do GADTs
08:42:49 <benzrf> GADTs are all about types
08:43:14 <c_wraith> GADTs allow some greater degree of linking types to values
08:43:49 <benzrf> to be precise, the function of GADTs is to specify what type a fully-applied constructor will have based on its arguments
08:43:59 <aupo> Hi
08:44:02 <benzrf> instead of automatically deriving it from which types are placed in its fields
08:44:22 <Tjr> Ok, I'll keep that vague knowledge in the back of my head until I actually do need it for some problem.
08:44:25 <c_wraith> benzrf: doesn't need to be fully-applied, even
08:44:29 <aupo> Started building up a haskell dev platform, but ran into a problem trying to install the cgi package: "Module ‘Data.Typeable’ does not export ‘mkTyCon’"
08:44:29 <augur> ok, here's a question for the haskell elite
08:44:34 <aupo> Is this a known problem, any way around it?
08:44:43 <benzrf> @let WeirdGADT where Existential :: a -> WeirdGadt
08:44:43 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:44:45 <benzrf> @let WeirdGADT where Existential :: a -> WeirdGADT
08:44:45 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:44:52 <benzrf> @let data WeirdGADT where Existential :: a -> WeirdGADT
08:44:53 <c_wraith> aupo: that means the package hasn't been updated for GHC 7.8
08:44:53 <lambdabot>  Defined.
08:45:02 <benzrf> Tjr: notice that that's basically existential
08:45:13 <aupo> c_wraith: Aight; Only possibility to either downgrade or wait for an update?
08:45:14 <benzrf> i can do that becaues i get to write the type signature for the constructor
08:45:25 <benzrf> *because
08:45:32 <c_wraith> aupo: or fix it yourself.  It's pretty mechanical to fix those sorts of issues.
08:45:41 <aupo> c_wraith: Okay, thanks.
08:45:54 <augur> i need to represent a kind of graph (i believe a DAG) in such a way that i can "unify" two of them
08:46:31 <pjdelport> Define unify?
08:46:46 <Welkin> disjoint sets?
08:46:54 <Tjr> benzrf: thanks
08:47:03 <c_wraith> You have labeled nodes, you want the union of the sets of nodes and the sets of edges?
08:47:17 <benzrf> Tjr: one other use for GADTs is in things like machineslearn
08:47:18 <benzrf> *Machines
08:47:25 <benzrf> that basically let you specify types using values
08:47:38 <benzrf> Tjr: you know how you can use Left or Right to indicate which type you're using?
08:47:45 <Tjr> yes
08:47:49 <augur> pjdelport, c_wraith: i want to combine them so that they "overlap" appropriately
08:48:08 <benzrf> Tjr: when you have GADTs, it's possible to influence types elsewhere in an expression from a value in part of it
08:48:10 <c_wraith> augur: are your graphs always connected?
08:48:18 <Tjr> Although I haven't found any good guidelines how to name the errors that I put into the Left, without namespace pollution nor name collisions
08:48:28 <benzrf> Tjr: let me show you a boiled-down example of what machines does
08:48:35 <augur> that is to say, if two nodes are unified, the (labeled) edges are merged if they're compatible and it fails otherwise
08:48:37 <pjdelport> augur: What c_wraith said sounds like a solution.
08:48:46 <benzrf> well
08:48:49 <augur> c_wraith: yes, actually they're rooted DAGs
08:48:53 <benzrf> actually ,something quite different from machines
08:48:56 <benzrf> but the same kind of idea
08:49:02 <pjdelport> augur: It also reminds me of the C3 linearization algorithm, although that might be a more special case.
08:49:30 <benzrf> @let ValueIndicatingType t where AnInt :: ValueIndicatingType Int; AString :: ValueIndicatingType String
08:49:31 <lambdabot>  Parse failed: TemplateHaskell is not enabled
08:49:34 <c_wraith> augur: if you represent them as a list of edges, that turns your algorithm into merging those lists.  If I understand the problem right.
08:49:34 <Tjr> just to be clear,
08:49:34 <benzrf> bah
08:49:37 <benzrf> @let data ValueIndicatingType t where AnInt :: ValueIndicatingType Int; AString :: ValueIndicatingType String
08:49:38 <lambdabot>  Defined.
08:49:40 <Tjr> woops
08:49:42 <benzrf> Tjr: yea?
08:49:45 <augur> the problem is that the only representation of graphs i know of is requires shifting labels, etc. around
08:49:53 <benzrf> :t AString
08:49:54 <lambdabot> ValueIndicatingType String
08:49:56 <benzrf> :t AnInt
08:49:57 <lambdabot> ValueIndicatingType Int
08:50:07 <c_wraith> augur: I know at least 4 representations of graphs offhand. :P
08:50:31 <benzrf> @let data ValueHolder where Holder :: ValueIndicatingType t -> t -> ValueHolder
08:50:32 <lambdabot>  Defined.
08:50:35 <augur> c_wraith: in haskell? tell me!
08:50:42 <benzrf> Tjr: ok, do you follow those 2 definitions?
08:50:47 <c_wraith> augur: ok, are the nodes purely structural, or do they have identifiers?
08:50:55 <augur> c_wraith: identifiers
08:50:59 <Tjr> benzrf: yes, that's clear.
08:51:12 <benzrf> :t Holder AString "Foo"
08:51:12 <lambdabot> ValueHolder
08:51:18 <benzrf> :t Holder AnInt 3
08:51:18 <lambdabot> ValueHolder
08:51:23 <benzrf> this checks!
08:51:26 <Tjr> So far, I haven't felt the need for GADT, but I'm confident there is a good usage scenario.
08:51:32 <c_wraith> augur: in that case, you could represent the graph as a list of edges (source node, dest node, label)
08:51:32 <pjdelport> augur: Have you looked at http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html by the way?
08:51:35 <augur> c_wraith: its crucial that they can be shared. but the nodes are like records in that they have (unique) labelled edges out
08:51:39 <benzrf> i can indicate which type it should use with a sub value instead of a constructor
08:51:49 <benzrf> Tjr: this even works when you pull values back out
08:51:52 <benzrf> check it:
08:52:00 <Lutin`> augur: Adjacency lists and adjacency matrices are the two most common
08:52:08 <augur> pjdelport: yes, i just dread writing a graph type that requires my to manually shift variable names :(
08:52:14 <benzrf> @let processor (Holder AString s) = reverse s; processor (Holder AnInt i) = show i
08:52:15 <Lutin`> There's also incidence matrices
08:52:15 <lambdabot>  .L.hs:168:32:
08:52:15 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘[Char]’
08:52:15 <lambdabot>        ‘t’ is untouchable
08:52:15 <lambdabot>          inside the constraints (t1 ~ [Char])
08:52:15 <lambdabot>          bound by a pattern with constructor
08:52:19 <benzrf> yo what
08:52:23 <benzrf> since fucking when
08:52:27 <benzrf> i've done this before!
08:52:35 * benzrf punches lambdabot 
08:52:46 <benzrf> oh wait let me try something else
08:52:49 <benzrf> @undefine
08:52:49 <lambdabot> Undefined.
08:52:55 <benzrf> @let data ValueIndicatingType t where AnInt :: ValueIndicatingType Int; AString :: ValueIndicatingType String
08:52:56 <lambdabot>  Defined.
08:53:14 <benzrf> @let data ValueHolder t = Holder (ValueIndicatingType t) t
08:53:15 <lambdabot>  Defined.
08:53:18 <benzrf> there we go
08:53:24 <c_wraith> augur: when do you have to rename something?
08:53:24 <benzrf> now it shows up as a type parameter
08:53:27 <benzrf> allowing processor to be well-typed
08:53:28 <benzrf> :-)
08:53:34 <benzrf> @let processor (Holder AString s) = reverse s; processor (Holder AnInt i) = show i
08:53:35 <lambdabot>  .L.hs:155:32:
08:53:35 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘[Char]’
08:53:35 <lambdabot>        ‘t’ is untouchable
08:53:35 <lambdabot>          inside the constraints (t1 ~ [Char])
08:53:35 <lambdabot>          bound by a pattern with constructor
08:53:40 <benzrf> ok u know what screw yu
08:53:43 <Lutin`> rekt
08:53:50 <benzrf> Tjr: the point is that you CAN do that kind of thing
08:53:56 <benzrf> i just seem to have forgotten how ;-;
08:54:20 <augur> c_wraith: i need to have guids for the graphs nodes, but im using it in a way that generates new graphs from old graphs, so the graphs arent fixed ahead of time
08:54:20 <benzrf> Tjr: machines uses this to let you indicate which type of input you want next to the machine at the value level
08:54:25 <benzrf> while staying strongly typed
08:54:30 <benzrf> so you can do something like
08:54:36 <benzrf> v <- awaits L
08:54:37 <benzrf> v <- awaits R
08:54:40 <Lutin`> @let data ValueHolder2 t where Holder :: ValueIndicatingType t -> t -> ValueHolder2 t
08:54:41 <lambdabot>  .L.hs:154:9:
08:54:41 <lambdabot>      Multiple declarations of ‘Holder’
08:54:41 <lambdabot>      Declared at: .L.hs:151:22
08:54:41 <lambdabot>                   .L.hs:154:9
08:54:46 <Lutin`> @let data ValueHolder2 t where Holder2 :: ValueIndicatingType t -> t -> ValueHolder2 t
08:54:47 <lambdabot>  Defined.
08:54:54 <c_wraith> augur: wait - are nodes structural and just happen to have some attached name?  Or does the merging actually care about the names?
08:54:54 <benzrf> and in a plan for a Tee machine that can take Int or String, that will take in an Int then a String
08:55:02 <Lutin`> @let processor (Holder2 AString s) = reverse s; processor (Holder2 AnInt i) = show i
08:55:02 <lambdabot>  .L.hs:158:33:
08:55:02 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘[Char]’
08:55:02 <lambdabot>        ‘t’ is untouchable
08:55:02 <lambdabot>          inside the constraints (t1 ~ [Char])
08:55:02 <lambdabot>          bound by a pattern with constructor
08:55:07 <augur> c_wraith: basically its a parser that uses graph representations + unification, so each occurrence of a word requires a new occurrence of its graph
08:55:11 <Lutin`> rekt me too :(
08:55:37 <benzrf> Tjr: you could do that using a sum type that wraps both Int and String
08:55:47 <benzrf> but then you lose the ability to detect when you use the wrong one at compile type
08:55:50 <benzrf> *compile time
08:56:17 <benzrf> this way, you can indicate which type you want using a value, AND have just-as-strong compile-time guarantees
08:56:21 <benzrf> without typeclasses
08:56:24 <benzrf> it's pretty sweet
08:56:43 <c_wraith> augur: it sounds more like you're describing a structural graph that just happens to have names attached than a graph where nodes are uniquely described by their name.
08:56:54 <c_wraith> err, uniquely identified
08:56:56 <augur> c_wraith: i guess?
08:57:10 <augur> i dont know the distinction youre making now
08:57:22 <Tjr> Thinking a bit wider, does that mean you could use GADT to implement AVL balanced binary trees (not red-black trees), "functor" classes that actually enforce the functor laws, etc?
08:57:41 <benzrf> Tjr: i dont know about the latter
08:57:46 <c_wraith> augur: I mean that you're getting the shape of the graph from the parser, not from the set of names.
08:57:47 <benzrf> maybe the former, im not familiar
08:58:02 <benzrf> Tjr: more generally, dependent typing can probably accomplish both
08:58:10 <benzrf> GADTs are significantly weaker
08:58:16 <benzrf> but also fit into haskell better :-)
08:58:24 <Tjr> ok
08:58:35 <augur> c_wraith: well, you're getting the shape of the graph in part from the lexical items, and in part from these rules that get used
08:59:38 <Lutin`> You could have something like Graph = Map String Vertex; Vertex = [Edges]; Edge = (Vertex, Vertex)
08:59:50 <augur> i guess actually because of how this gets used, i could generate a new instance of the graph for each word as it comes into the parse, and then also generate new instances for the constructions...
09:00:19 <augur> and just keep a running max of edge GUIDs
09:00:22 <augur> er, node guids
09:00:59 <c_wraith> augur: at this point, I'm going to suggest looking into edwardk's bound library.  It's all about renaming things in expression trees.  But I haven't used it, and I'm getting cloudier on exactly what your task is. :)
09:00:59 <augur> oh but no, i need to unify pre-existing nodes, that wont work
09:01:07 <augur> nor will my old idea of cleaning on the fly
09:01:27 <augur> c_wraith: no bound is awful >_>
09:01:46 --- mode: ChanServ set +o Saizan
09:03:13 <Robly18> evening
09:03:47 <phaazon> why is void in Control.Monad whereas it should be in Data.Functor?
09:04:22 <geekosaur> because the intended usage was to allow explicitly throwing away monadic results?
09:04:51 <phaazon> geekosaur: is that a good reason?
09:05:03 <geekosaur> it's a historical reason
09:05:12 <geekosaur> "good" changes over time...
09:05:38 <phaazon> why not change it then, to make it more obvious
09:05:44 <kazagistar> phaazon: it seems like a fine reason, what is where is often arranged by usage, especially in the case of trivial helper functions
09:06:45 <jmcarthur> augur: why is bound awful?
09:06:51 <phaazon> I guess it’s something simple as (<$ ())
09:07:07 --- mode: Saizan set -o Saizan
09:07:18 <augur> jmcarthur: i just really dislike it. its confusing and hard to understand and debruijn indicates are a pain in the ass even when they're made easy like in bound
09:07:25 <phaazon> (<$) ()
09:07:35 <kazagistar> from the source: void = fmap (const ())
09:07:45 <Apocalisp> augur: What do you prefer?
09:07:50 <phaazon> yeah, what I said then
09:08:31 <bennofs> phaazon: would be (() <$) though
09:08:41 <phaazon> bennofs: that’s what I fixed :)
09:08:46 <phaazon> 18:05 < phaazon> (<$) ()
09:08:51 <bennofs> phaazon: ah, missed that, sry
09:08:57 <phaazon> :)
09:09:16 <phaazon> I love that operator and especially its applicative forms
09:09:24 <phaazon> (<*) and (*>)
09:09:28 <augur> Apocalisp: ive found doing manual naming of vars is actually easier, even tho that runs counter to what i said about not wanting to do renaming x3
09:09:56 <jmcarthur> interesting
09:09:57 <Apocalisp> augur: That sounds really painful
09:10:07 <augur> Apocalisp: nah, its really not
09:10:17 <Apocalisp> I was expecting you'd say HOAS or something like that
09:10:40 <jmcarthur> i have found hoas to be pretty painful in practice, at least for anything somewhat complicated
09:10:49 <jmcarthur> which is a shame, because i love it...
09:11:28 * hackagebot machines-io 0.0.0.1 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.0.0.1 (aloiscochard)
09:11:30 * hackagebot machines-process 0.0.0.1 - Process (system) utilities for the machines library  http://hackage.haskell.org/package/machines-process-0.0.0.1 (aloiscochard)
09:11:32 * hackagebot git-sanity 0.0.1 - A sanity checker for your git history.  http://hackage.haskell.org/package/git-sanity-0.0.1 (aloiscochard)
09:11:41 <Lutin`> augur: Maybe check out https://hackage.haskell.org/package/fgl-5.4.2.4
09:12:02 <jmcarthur> i'm always really happy with the result. it just takes a long time to get there.
09:12:57 <Tjr> jmcarthur: your comment still makes sense with hoas == Home Owner's AssociationS.
09:13:04 <jmcarthur> haha
09:14:06 <Tjr> I'm trying to understand http://bartoszmilewski.com/2013/12/21/understanding-free-monoids-and-universal-constructions/
09:14:23 <Tjr> Specifically, " But once you mapped a monoid into a set (its, so called, underlying set), you have forgotten its structure."
09:14:44 <Tjr> The guy defined a monoid as a singleton set with lots of morphisms mapping that singleton around
09:15:23 <Tjr> so the forgetful functor would map the monoid to a singleton set without any structure, and it would forget more than just the function composition laws.
09:15:27 <Tjr> What am I doing wrong?
09:16:58 <chandru_in> What does specifying the RTS -H option do, if it is not followed by any value?
09:17:21 <phaazon> isn’t there a way to put functional dependencies on instances as well?
09:17:30 <bennofs> phaazon: there isn't
09:17:32 <phaazon> in order to trick around the UndecidableInstances issues?
09:17:33 <phaazon> arf
09:17:37 <jmcarthur> chandru_in: it uses some built-in value that's more generous than the default. i don't remember what that value is
09:17:58 <chandru_in> jmcarthur, thanks
09:18:11 <phaazon> when I have | m -> w, if my monad is a transformer, I can’t write a proper instance
09:18:21 <phaazon> but if I could forward the functional dependency in the instance
09:18:22 <phaazon> I could
09:18:26 <phaazon> :)
09:18:38 <jmcarthur> chandru_in: i sometimes will randomly try -H just to see how much it changes performance. if it seems significant, i might play around with other values. i kind of like not having to choose one the first time though :)
09:21:02 <Guest28109> تحذير
09:21:02 <Guest28109> warning
09:21:02 <Guest28109>  you may be  watched
09:21:02 <Guest28109> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
09:21:02 <Guest28109> do usa&israel use the internet 2 collect informations,,can we call that spying??
09:21:02 <Guest28109> do they record&analyse everything we do on the internet,,can they harm you using these informations??
09:21:28 --- mode: ChanServ set +o jmcarthur
09:21:40 <wei2912> lol
09:21:44 <wei2912> that is a weird type of spam
09:21:45 --- mode: jmcarthur set +b *!*@197.121.122.177
09:22:04 --- mode: jmcarthur set -o jmcarthur
09:22:20 <MP2E> lol can they harm you using these informations
09:22:35 <augur> what a silly spammer
09:22:50 <augur> doesnt this guy know that all of this information has been public for over a year thanks to snowden? duhhhh
09:22:52 * Tjr is still waiting for: TheTitanic has quit (excess flood).
09:23:16 <Welkin> the first line is arabic for "warning"
09:23:42 <Tjr> augur: those guys give legit opponents of universal surveillance a bad rep.
09:23:54 <augur> lol
09:24:58 <_deepfire-laptop> well could be a psy-op, to discredit the idea
09:25:15 <kazagistar> its not really good at that either I think
09:25:16 <augur> to.. discredit the idea that the NSA is spying on everyone using facebook?
09:25:21 <anildigital> Any awesome book to learn Haskell?
09:25:31 <kazagistar> anildigital: LYAH
09:25:32 <anildigital> I am a Ruby developer.. have little idea about Clojure and Scala
09:25:46 <anildigital> kazagistar: thanks
09:26:00 <_deepfire-laptop> augur, mind you, it's clear to you -- some people are still sitting on the fence about it
09:26:04 <augur> i mean, we know they are for a fact, right. i work with people who collaborate with the NSA on social media NLP snooping
09:26:12 <augur> its pretty trivial stuff tbh
09:26:15 <augur> bit of a joke
09:26:19 <Javran> does nuts and coconuts look the same?
09:26:40 <kazagistar> anildigital: there are other good books for haskell too, but that one best matches the adjective "awesome" in tone, I think
09:27:13 <_deepfire-laptop> I like Real World Haskell
09:27:25 <Tjr> Javran: only in case of reflexive nuts.
09:27:52 <kazagistar> Real World Haskell is the book I would recommend if someone asked for a "solid" book I think
09:28:31 <Tjr> Javran: joke explanation http://en.wikipedia.org/wiki/Reflexive_space#Reflexive_Banach_spaces
09:29:59 <_deepfire-laptop> Is there a way to mmap a fd, not a FilePath?
09:30:12 <kazagistar> you want coconuts? http://en.wikipedia.org/wiki/Hairy_ball_theorem
09:30:25 <Javran> Tjr: oh I was about to ask that "reflexive" part.
09:30:41 <_deepfire-laptop> not much FilePath I have wrt. a recvFd-ed fd, whose file was unlink'd
09:32:43 <_deepfire-laptop> Do I have to FFI my way through -- uphill, waist-deep in the snow?
09:33:36 <donri> Rizo_Isrof: no, haskell is great for mutation
09:34:35 <Tjr> anildigital: In case you decide to study learn-you-a-haskell cover to cover,  I made an Anki flashcard deck to avoid forgetting it again.
09:34:38 <Tjr> anildigital: https://ankiweb.net/shared/info/1572953029
09:35:00 <anildigital> Tjr: thanks a lot :)
09:35:43 <jmcarthur> _deepfire-laptop: i'm going to make a wild guess that you do, or find an existing binding.
09:35:57 <jmcarthur> _deepfire-laptop: but the FFI isn't that scary, really :)
09:36:28 <Welkin> will running a cabal sandbox inside a sandbox cause problems?
09:36:29 <Rizo_Isrof> donri: Since I just can’t find any objective reasons to prefer one language instead of another I decided to try both Haskell and OCaml. I’ll implement in parallell two small versions of the core of my project and decide later.
09:37:44 <Rizo_Isrof> Can someone point some good readings about what is an idiomatic way to model data in Haskell (or in functional languages in general)?
09:38:43 <_deepfire-laptop> jmcarthur, well, I guess I'm going to find that out, then : -)
09:38:53 <monochrom> every functional programming book
09:39:41 <pjdelport> Rizo_Isrof: Are you comfortable with algebraic data types?
09:40:18 <donri> Rizo_Isrof: http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/  and  http://roscidus.com/blog/blog/2013/06/20/replacing-python-round-2/  was a thorough examination of options for replacing python including ocaml and haskell. he ended up choosing ocaml and IIRC the reasons against haskell were mostly misunderstandings
09:40:18 <donri> (although that in itself is a point against haskell: learning curve and lacking documentation)
09:40:47 <donri> (this wasn't in response to your new question)
09:40:52 <Welkin> I came to haskell from python as well
09:40:59 <Rizo_Isrof> monochrom: every functional programming (I read) book talks about functional way of programming – i.e., algorithmic part. But complex application architectures are almost never covered.
09:41:48 <donri> rwh and parconc are strsuctured around building complex systems from simple parts IIRC
09:41:56 <Welkin> Rizo_Isrof, LYAH introduces ways of modelling data
09:41:58 <pjdelport> Rizo_Isrof: Real World Haskell might cover some of that in more detail than your average tutorial: http://book.realworldhaskell.org/read/
09:41:59 <donri> @where books
09:41:59 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
09:42:18 <donri> @where parconc
09:42:18 <lambdabot> I know nothing about parconc.
09:42:21 <donri> :(
09:42:29 <monochrom> the "algorithmic part" also says how to model data.
09:42:39 <donri> @google parallel concurrent haskell marlow book
09:42:40 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
09:42:40 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
09:43:01 <pjdelport> Rizo_Isrof: Although the real lesson of functional programming is probably that there *shouldn't* be any difference between small-scale and large-scale architecture: the latter should just be the functional composition of the former.
09:43:02 <jmcarthur> donri: a lot of people try to learn new languages by naively porting programs first written in other languages. as you can imagine, this tends to not fare well for haskell. :(
09:43:04 <Rizo_Isrof> pjdelport: I am comfortable with ADTs but for example I still can’t understand when should I use ADTs, type classes, or modules. I come from more a OO background and don’t know yet how to survive without inheritance and patterns.
09:43:15 <monochrom> there is, logically, no such thing as "talk about algorithm without data" or "talk about data without algorithm"
09:43:16 <pjdelport> Rizo_Isrof: The essense of functional programming is all about modularity and composition.
09:43:44 <Welkin> wholemeal programming
09:43:52 <Welkin> creating a pipeline
09:43:56 <donri> jmcarthur: that worked well for me seeing as i started using haskell because i realized i was trying to write haskell code in python
09:44:03 <donri> ;)
09:44:05 <jmcarthur> Rizo_Isrof: we can say all sorts of things, but we can't replace experience. my suggestion is to just code a lot.
09:44:12 <Welkin> donri, haha
09:44:22 <pjdelport> Rizo_Isrof: They're pretty different things; just start with ADTs, first. You'll later naturally see when you need type classes for interface-like polymorphism.
09:44:24 <Welkin> that sounds like me
09:44:34 <Welkin> list comprehensions everywhere in python
09:44:35 <pjdelport> Rizo_Isrof: And modules are just about organizing code, and have little overlap with organizing data.
09:45:44 <donri> Welkin: i took it quite a bit further than that :)
09:46:32 <Welkin> I doubted the practicality of "purely functional" until I started actually using haskell
09:46:46 <donri> i actually tried to add static types, interfaces, enums to python (in python) and used immutable structures everywhere and what have you
09:47:08 <Welkin> I assume that is one of the major barriers imperative/oo programmers have
09:47:39 <Rizo_Isrof> Ok, so let me try to give you an example. I want to build a graph structure where each node has a different type of objects. With object-oriented programming you define a base class, the graph acts as a glue and a container and you define your generic algorithms to work with this skeleton. How I design this situation in Haskell?
09:47:40 <jmcarthur> i had been writing tons of purely functional code in D not too long before trying Haskell
09:48:21 <monochrom> imperative programming is purely functional in the non-I/O part. suppose the variables in scope are x,y,z. then "x := x + y" is the pure function \(x,y,z) -> (x+y, y, z).
09:48:24 <jmcarthur> The D folks had made a big deal of making strings immutable, and I experimented with making everything I could could immutable. Then I realized a lot of the functions I was writing then were "pure" and tried Haskell.
09:48:54 <donri> graphs are free categories but i'm not sure that's a useful observation for a database
09:48:57 <monochrom> non-I/O imperative programming is first-order functional programming
09:49:18 <Rizo_Isrof> donri: I code in python at my job and use generators, functools itertools for everythong. This works well with basic pipelines and data processing. For the architectural part I still  on classes/objects
09:51:20 <Welkin> wow, I actually got cabal build to work
09:51:30 <Welkin> maybe nested sandboxes is not a good idea
09:53:57 <pjdelport> Rizo_Isrof: In Haskell, your graph type will probably be some parametric type. http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html is an example of how you might approach the API.
09:56:10 <pxqr> is there an easy way to test whether Network.Socket.Socket descriptor is closed?
09:56:33 <Rizo_Isrof> do you know of any databases (or just data modeling apps) written in pure idiomatic haskell?
09:58:07 <_0xAX> Hello all, is there websockets support in scoty?
09:58:30 <_0xAX> Or in some another micro framework
10:01:14 <pjdelport> Rizo_Isrof: Haskell's non-strict / lazy semantics are *really* useful for working with complex data structures like that: it's like have Python generators everywhere, without any of the associated evaluation gotchas.
10:02:59 <Rizo_Isrof> pjdelport: you speak for my soul. Im starting to feeling frustrated with the limitations of the python’s partial lazyness, so to speak
10:03:13 <pjdelport> Rizo_Isrof: I'm also a Pythoneer, for the record. :)
10:03:14 <Rizo_Isrof> s/for my soul/to my soul/g
10:04:30 <pjdelport> Rizo_Isrof: In terms of databases and data management: http://www.haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces and http://www.haskell.org/haskellwiki/Web/Databases_and_Persistence
10:05:31 <pjdelport> Rizo_Isrof: There are both interfaces to common systems, and some unique Haskell-specific things, like Acid-State, which builds directly on the properties of purity and ADTs: http://acid-state.seize.it/
10:05:53 <Rizo_Isrof> I love python and its simplicity and hidden power. It gave me the tools to start exploring the edges of the functional programming but right now I just build my own language on top of it with type checkers and other strange extensions.
10:06:14 <haasn> Iceland_jack: re: not really being able to express inequality in the Haskell type system
10:06:46 <haasn> What about type family a ≠ b :: Constraint where a ≠ a = (1 ~ 0); a ≠ b = ()
10:07:00 <haasn> then you could have eg. f :: (a ≠ b) => [a] -> [b]
10:07:06 <haasn> but I'm not sure how that may or may not type check
10:07:09 <haasn> Or work as intended
10:08:56 <pjdelport> Rizo_Isrof: You'll probably love Haskell. :)
10:09:55 <Rizo_Isrof> I already like the feel of it :D
10:11:18 <Rizo_Isrof> pjdelport: donri: jmcarthur: Thanks for you comments and suggestions!
10:11:47 <pjdelport> Rizo_Isrof: Hang around, work through http://en.wikibooks.org/wiki/Haskell / http://www.haskell.org/haskellwiki/Tutorials , and ask questions!
10:13:42 <Rizo_Isrof> Thanks! I’ll be back with questions after intensive reading sessions! :P
10:15:58 <pjdelport> Rizo_Isrof: From a Pythoneer's perspective, try to grok how ADTs / data constructors match up with case expressions / pattern matching: that's the heart of what drives computation in Haskell.
10:16:35 <monochrom> I have an article on that. http://www.vex.net/~trebla/haskell/crossroad.xhtml
10:18:07 <pjdelport> monochrom: Hmm, that should probably mention that conditional branching is just a special case of case matching on Bool? :)
10:18:08 <Rizo_Isrof> I already have some ML background so I already missed ADTs and match statement in Python. I hate writing `elif (isinstancn(x, …)`!
10:18:54 <Rizo_Isrof> pjdelport: cool! that’s really nice observation!
10:19:24 <monochrom> No, that is beside the point.
10:20:09 <pjdelport> Rizo_Isrof: Ah, an important thing that Haskell adds over ML in that respect is non-strict/lazy evaluation: that lets you represent all kinds of processes as simple data structures, with lazy evaluation ensuring that only what you actually inspect gets evaluated.
10:20:52 <pjdelport> Rizo_Isrof: The canonical example is fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:22:26 <Rizo_Isrof> Just like iterators in python! This is really powerful and I just cant explain how elegant your example looks.
10:22:40 <MP2E> > take 10 $ fix $ scanl (+) 0 . (1:)
10:22:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
10:23:07 <MP2E> decidedly less elegant, but fun :D
10:23:21 <hpc> i like the zip`ap`tail version
10:24:12 <pjdelport> Rizo_Isrof: Another good example is how all the traversals in http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Graph.html#g:5 are just plain functions that returns trees / forests.
10:25:17 <pjdelport> Rizo_Isrof: You tend to never see things like explicit visitor patterns or things like that in Haskell, because you can just consume a potentially infinite data structure lazily instead.
10:25:52 <pjdelport> And it's not restricted to linear iteration, as the tree results show.
10:27:53 <Rizo_Isrof> I’ll have to explore how this commom problems are soved in haskell.
10:30:12 <Rizo_Isrof> This is really nice – http://dev.stephendiehl.com/hask/ – are those tips and references up to date?
10:30:52 <MP2E> yep they are
10:31:39 <Rizo_Isrof> thanks again for help! time to go now! ;)
10:31:45 <ReinH>  Rizo_Isrof yay! Come ask us if you have questions.
10:32:41 <Rizo_Isrof> I was tald once Haskell has a great community! I can confirme it now!
10:35:00 <__sebastian___> hi all, is there a constrained functor class? eg class ConstrainedFunctor m where {Con f :: GHC.Ext.Constraint ; map => Con f => (a -> a) -> f a -> f a}
10:53:39 <Ainieco> hello
10:54:50 <Ainieco> why Float is that bad?  http://www.haskell.org/haskellwiki/Performance/Floating_point in this article someone used "hang yourself" words and it really sounds that float is bad but why?
10:55:16 <Ainieco> they are saying that on 32bit it will take less memory than double but on 64 it will take the same
10:55:24 <Cale> Ainieco: Because operations on Doubles are just as fast, but more precise
10:56:09 <geekosaur> Float is usually faked; the hardware does operations at full precision and then truncates to the requested precision
10:56:30 <Ainieco> Cale: how is it more precise? IEEE 754 cannot be aplied to double?
10:56:45 <geekosaur> (x86 / x86_64 do this even for Double; the CPU uses an internal precision which is only storable in its internal registers)
10:56:46 <Cale> Ainieco: hm?
10:56:56 <Cale> Ainieco: Float and Double are both IEEE 754
10:56:59 <blast_hardcheese> What's the intuition behind `(flatten .) . map`? I can't seem to get my head around it
10:57:10 <Cale> Ainieco: The only difference is the number of bits used to represent the values
10:57:17 <MP2E> :t (flatten .) . map
10:57:18 <lambdabot>     Couldn't match type ‘[b]’ with ‘Tree a’
10:57:18 <lambdabot>     Expected type: (a1 -> b) -> [a1] -> Tree a
10:57:18 <lambdabot>       Actual type: (a1 -> b) -> [a1] -> [b]
10:57:19 <blast_hardcheese> I know it implements flatmap, but I had to use lambdabot to generate it
10:57:23 <jle`> __sebastian___: not yet in the standard libs, but there is talk about it possibly being integrated in a distant future
10:57:26 <pjdelport> IEEE 754 covers from 16 to 128-bit floats
10:57:39 <Cale> blast_hardcheese: I think it helps to think of the first (.) as fmap for functions
10:57:43 <Ainieco> Cale: but how is it more precise for same speed?
10:57:47 <jle`> blast_hardcheese: start with the definition of (.)
10:57:49 <hpc> @unpl (flatten .) . map
10:57:49 <lambdabot> (\ d g -> flatten (map d g))
10:57:56 <geekosaur> Ainieco, see what I just said
10:58:02 <geekosaur> [06 17:54] <geekosaur> Float is usually faked; the hardware does operations at full precision and then truncates to the requested precision
10:58:04 <hpc> the intuition is that it flattens the result of a map
10:58:10 <jle`> blast_hardcheese: f . g = \x -> f (g x)
10:58:12 <pjdelport> blast_hardcheese: It's better to pull that composition operator out: let (.:) = (.).(.) in flatter .: map
10:58:17 <geekosaur> it actually *wastes* time to use Float because it has to truncate
10:58:24 <geekosaur> at the CPU level
10:58:36 <geekosaur> which is why almost nobody uses `float` in C either
10:58:47 <__sebastian___> jle`: I think this is really misisng in the standard
10:58:48 <pjdelport> blast_hardcheese: That (.:) is like (.), except that the function on the right takes *two* (instead of just one) parameters before its result is passed to the left.
10:58:58 <hpc> not to mention that float has something like 10 bits of mantissa
10:58:59 <Ainieco> geekosaur: okay but i don't see hw is more precise, sorry i may be annoying, just wondering.
10:59:04 <jle`> blast_hardcheese: (flatten .) . map = \f -> (flatten . (map f))
10:59:06 <hpc> making it almost completely useless
10:59:06 <Ainieco> how is it*
10:59:07 <Adeon> :t (.).(.)
10:59:08 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:59:12 <Adeon> :t (.:)
10:59:12 <lambdabot>     Not in scope: ‘.:’
10:59:13 <lambdabot>     Perhaps you meant one of these:
10:59:13 <lambdabot>       ‘.’ (imported from Data.Function),
10:59:17 <geekosaur> the CPU always does calculations at full precision
10:59:20 <Cale> Ainieco: Double uses more bits to represent the mantissa and exponent
10:59:25 <rwbarton> Ainieco, Double is twice as many bits! of course it is more precise
10:59:26 <pjdelport> You can find a library version of (.:) and friends in http://hackage.haskell.org/package/composition
10:59:35 <jle`> blast_hardcheese: \f -> flatten . map f === \f -> \x -> flatten (map f x)
10:59:45 <Ainieco> rwbarton, Cale: Ah, got it! thankk you
10:59:47 <jle`> blast_hardcheese: \f -> x -> flatten (map f x)  == \f x -> flatten (map f x)
11:00:10 <geekosaur> it doesn't use different mechanisms to work with float vs. double; it just does a conversion step afterward. for double this just chops some bits off the end of the mantissa, but for float it also has to truncate the exponent to a single byte (from 2)
11:00:11 <blast_hardcheese> jle`: /OH/
11:00:18 <blast_hardcheese> That's tricky
11:00:22 <geekosaur> so float will be slower than double on modern CPUs
11:00:24 <rwbarton> the part about Float taking up 64 bits on a 64-bit system is because in GHC heap objects are always an integer number of words in size
11:00:38 <jle`> blast_hardcheese: you see it's not quite a useful/recommended idiom
11:00:50 <jle`> either use (.:) like people mentioned above, or also, feel free to keep a point
11:00:55 <jle`> \x -> flatten . map f
11:00:57 <geekosaur> but it only uses 32 of those 64 bits; it's just a detail of storage
11:01:01 <jle`> is sure readable to me
11:01:06 <rwbarton> right, the other 32 are wasted
11:01:08 <geekosaur> C's malloc does the same thing, it doesn't allocate exact sizes but powers of 2
11:01:15 <blast_hardcheese> jle`: Yeah, my solution was \x -> flatten . map f
11:01:33 <geekosaur> (on most systems)
11:01:33 <blast_hardcheese> but I figured understanding why (flatten .) . map worked in the first place would be insightful
11:01:35 <Ainieco> thank you guys for an explanation!
11:01:38 <blast_hardcheese> I need to play around with it on some paper
11:01:58 <jle`> blast_hardcheese: admittedly, not that much as you would hope :)  but it is fun to play around with.  just remember the deifnition of (.)
11:01:58 <geekosaur> and the minimum size is typically 2 CPU words
11:01:58 <blast_hardcheese> Thanks, jle`, pjdelport, and Cale
11:02:11 <geekosaur> (only one of which is returned to you; the other is used for housekeeping)
11:02:16 <isomorpheous> So, I had this issue earlier in the day. I generated some tls certificates, and Warp won't seem to recognize them.
11:02:34 <isomorpheous> Here is the source - https://github.com/pharpend/podium/tree/tls
11:02:37 <pjdelport> blast_hardcheese: Another way to define it: (f .: g) x y = f (g x y)
11:02:42 <Cale> blast_hardcheese: Are you already familiar with Functor and fmap?
11:02:56 <pjdelport> blast_hardcheese: Analagous to: (f . g) x = f (g x)
11:02:58 <blast_hardcheese> jle`: I'm still pretty green when it comes to Haskell, so I think anything helps at this point
11:03:01 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
11:03:23 <isomorpheous> Running 'cabal run'
11:03:30 <isomorpheous> works just fine
11:03:45 <Cale> If f = (->) e, then this becomes (a -> b) -> (e -> a) -> (e -> b), which if you look carefully, is the same type as function composition
11:03:47 <blast_hardcheese> Cale: I guess not?
11:03:52 <Cale> ah, okay
11:03:59 <isomorpheous> until I try to 'curl' the site, cabal outputs the error 'podium: no keys found'
11:04:08 <blast_hardcheese> I'm coming from Scala, so a lot of these concepts were glossed over
11:04:43 <Cale> So, in general, Functor is a class for data structures which have an operation for applying a function to all the "elements" of that data structure (of the type which the structure is parameterised by)
11:05:12 <Cale> For a more standard sort of example, if we have a Tree datatype like:
11:05:21 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
11:05:27 <blast_hardcheese> When I think of Functors I think of Maybe
11:05:30 <Cale> then we might write an instance of Functor like:
11:06:05 <Cale> instance Functor Tree where fmap f Tip = Tip; fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
11:06:17 <Cale> Maybe is another instance
11:06:31 <Cale> instance Functor Maybe where fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
11:06:52 <jle`> any type constructor f where you can meaningfuly turrn a (a -> b) into an f a -> f b is a Functor
11:06:55 <Cale> We can think of functions e -> a as being like "containers" indexed by elements of type e
11:06:58 <jle`> ...that's my intuition for it
11:07:30 <Cale> Like, imagine a big array of cells labelled with the elements of the type e, and f x in the cell labelled x
11:07:47 <Cale> (where f is our function of type e -> a)
11:08:14 <blast_hardcheese> Cale: Working through the tree fmap example now, thanks!
11:08:31 <Cale> So, in order to apply some function a -> b to all the elements of our container e -> a, we can effectively just compose the functions
11:08:37 <Cale> getting a function of type e -> b
11:08:51 <Cale> instance Functor ((->) e) where fmap f g = f . g
11:09:51 <Cale> Now, the reason this is a useful intuition to have about it for this example is that we're working with (flatten .)
11:10:04 <Cale> which is the same as  fmap flatten  for the function instance
11:10:28 <Cale> So, this is a function which will apply flatten to the *results* of another function.
11:11:02 <blast_hardcheese> Unfortunately, this is getting a bit overwhelming
11:11:32 <MP2E> :<
11:11:38 <Cale> Well, perhaps another approach to understanding is just to apply the thing to some arguments and see what happens:
11:11:42 <blast_hardcheese> I appreciate your explanations, I've copied them off and have started reading through them line by line
11:12:26 <Cale> ((flatten .) . map) f xs
11:12:43 <Cale> -> ((flatten .) (map f)) xs
11:12:53 <Cale> -> (flatten . map f) xs
11:13:03 <Cale> -> flatten (map f xs)
11:13:20 <blast_hardcheese> _that_ makes sense
11:13:37 <blast_hardcheese> and I can understand jle`'s point about it not being super critical ;)
11:14:07 <blast_hardcheese> Thanks, Cale!
11:14:13 <Cale> No problem :)
11:58:51 <monochrom> yikes, http://hackage.haskell.org/package/uu-options exists
12:02:11 <sm> where do I find how to do substitutions with the standard regex libs ?
12:15:11 <td123> I'm looking for a readCommand equivalant command for http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#v:readProcess
12:15:24 <td123> I've already tried hoogle, I figured I might ask here
12:15:26 <Noitanigami> what is the proper type declaration for an immutable array? The example "squares" in "A Gentle Introduction to Haskell, Version 98" (http://www.haskell.org/tutorial/arrays.html) doesn't work
12:17:00 <dv-> array (1,100) [(i, i*i) | i <- [1..100]] :: (IArray a e, Ix e, Num e, Enum e) => a e e
12:17:36 <Noitanigami> thank you
12:19:40 <Noitanigami> do you have a source you use to find these type signatures?
12:20:10 <dv-> yes, ghci
12:20:52 <dv-> or lambdabot
12:20:53 <dv-> :t array (1,100) [(i, i*i) | i <- [1..100]]
12:20:54 <lambdabot> (Ix e, Num e, Enum e) => Array e e
12:21:22 <rwbarton> in what way does the example squares not work?
12:21:33 <dv-> :t Data.Array.IArray.array (1,100) [(i, i*i) | i <- [1..100]]
12:21:34 <lambdabot> (Data.Array.Base.IArray a e, Ix e, Num e, Enum e) => a e e
12:21:56 <td123> if not, I'll probably just write my own read command, do you think it's worth opening a feature request for system.process?
12:25:46 <pjdelport> Noitanigami: There is a difference between importing Data.Array and Data.Array.IArray. The former is a concrete array type; the latter is an abstract interface.
12:25:59 <pjdelport> :t Data.Array.array
12:26:00 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
12:26:09 <pjdelport> :t Data.Array.IArray.array
12:26:10 <lambdabot> (Data.Array.Base.IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
12:26:32 <Noitanigami> thank you dv
12:26:44 <Noitanigami> thank you pjdelport for showing me this
12:26:49 <pjdelport> Noitanigami: So you'll generally want to import Data.Array, not Data.Array.IArray
12:27:48 <pjdelport> Noitanigami: You'll probably only want the latter if you want to do things like write a library that accepts *any* IArray, and you want users to be able to provide their own instance.
12:28:14 <pjdelport> (In other words, when you're not actually constructing the original arrays yourself.)
12:28:26 <pavonia> td123: Definitely. I had the same need and wrote my own version using runInteractiveCommand
12:28:48 <Noitanigami> pjdelport: This makes more sense. The documentation on the wiki wasn't very clear
12:36:52 <Kaidelong> I need a queue in IO with semantics kind of like MVar but instead of blocking on a put to a full one, add an element to the queue
12:37:05 <Kaidelong> do I need to implement this myself or does something like this exist?
12:37:21 <Kaidelong> also if I do need to implement this myself, should I use something other than Data.List (Data.Sequence maybe?)
12:38:53 <Kaidelong> actually come to think of it I don't really want MVar-like blocking after all
12:38:59 <tolt> http://hackage.haskell.org/package/stm-2.4/docs/Control-Concurrent-STM-TQueue.html
12:39:04 <tolt> Is that what you're looking for?
12:39:08 <rwbarton> how about Chan?
12:39:53 <Kaidelong> that looks about right
12:40:10 <Kaidelong> although now I'm wondering if that's the correct solution to my problem
12:40:15 <tolt> If you've never used STM before you might also want to look at http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-Conc.html#v:atomically
12:40:28 <Kaidelong> what I'm trying to deal with is connecting push-data to netwire which doesn't support push control flow at all
12:41:13 <Kaidelong> the only way I can think of to do this is to have callbacks write to a buffer
12:41:24 <Kaidelong> but tryPeekTQueue in a loop looks like it'd solve my problem
12:41:50 <Kaidelong> err tryReadTQueue
12:42:22 <tolt> don't forget http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Concurrent.html#v:yield if you're going to loop.
12:42:35 <tolt> (or threadDealy
12:42:38 <Kaidelong> I understand why netwire is pull only, it forces the constraint of having a single synchronous main thread controlling the application
12:42:42 <tolt> wow... (or threadDelay)
12:43:11 <Kaidelong> but it does seem a little bit disappointing in terms of what you expect from "reactive" programming
12:44:00 <Kaidelong> tolt: do I only need yield if I'm using STM with multiple threads?
12:44:21 <tolt> I was just saying that you should yield if you're going to have a loop with no threadDelay
12:44:30 <Kaidelong> the callback and the consumer are both going to be on the main thread, I think... if I understand how GLFW works
12:45:38 <Kaidelong> pollEvents >> render where pollEvents synchronously pushes stuff to the buffers
12:46:14 <Kaidelong> oh hmm well
12:46:40 <Kaidelong> I dunno if I'd want yield even in the concurrent case because I don't want to allow other threads to pre-empt the renderer in the middle of rendering a frame, do I?
12:46:50 <Kaidelong> I'd want the loop to make everything else block?
12:46:55 <Kaidelong> or am I not understanding something?
12:47:03 <tolt> Oh. You might not want to.
12:47:12 <tolt> It just allows for context-switching.
12:48:11 <tolt> But I have no idea about GLFW or anything like it.
12:49:45 <Kaidelong> I am actually wondering if I should allow this or not, my intuition is to render the frame atomically before passing control to another thread, so that the program state cannot change somehow in the middle of a refresh
12:50:24 <Kaidelong> OTOH it's probably pretty easy to come up with perfectly benign things to do concurrently while rendering a frame
12:50:53 <Kaidelong> like say reading a file from the disk
12:52:23 <Kaidelong> I guess I can use yield because the stuff coming in the channels are timestamped anyway
12:54:28 <rwbarton> your thread might yield any time it allocates on the heap also
12:54:33 <rwbarton> you don't really have control over when it yields
12:55:38 <rwbarton> yield just means "now would be a great time to run another thread"
12:56:01 <kazagistar> Kaidelong: john carmack himself suggested that having state be immutable and updates to state be pure function would be a good way to do multiprocessor-friendly game engines ;)
12:56:39 <tdammers> kazagistar: isn't that kind of a no-brainer in and by itself?
12:56:58 <kazagistar> tdammers: not if you look at the state of game engines today
12:57:43 <tdammers> kazagistar: well, it's not currently being done, at least not at the a-title level, but that's for other reasons
12:57:43 <Kaidelong> kazagistar: that's a bit orthogonal, I'll still have to solve the problem of how to turn callbacks into a buffer that can be pulled from
12:58:14 <tdammers> inertia, culture, availability of library, stubbornness, existing codebases, etc.
12:58:23 <Kaidelong> I think my implementation is somewhat agnostic over if the game state + transition is pure or not
12:58:38 <Kaidelong> but I am writing it assuming the game state transition is a pure function
12:58:43 <Kaidelong> Event -> State -> State
12:59:33 <kazagistar> hmm, that seem a bit course grained, because it kinda implies a lock on the full state
13:00:08 <Kaidelong> AFAICT that's exactly how netwire works
13:00:50 <Kaidelong> your network you assemble works like a big function passing a single value through back into itself with a central clock controlling it
13:01:23 <tdammers> as long as State is lazy, I don't really see huge problems
13:01:41 <tdammers> your state-updating function really only injects a thunk
13:02:36 <kazagistar> tdammers: and then... different threads can read different parts of the state and evaluate thunks in parallel?
13:03:25 <kazagistar> is there some sensible thunk locking mechanism for that?
13:03:28 <Kaidelong> I'd be nervous about having more than one thread working on the state record
13:04:59 <kazagistar> well, theoretically, if it is truly pure and immutable, then there would be no possible problems other then a risk of poor performance if too many lock on the same thunk or something... worst case no speedup
13:05:14 <Kaidelong> I think they shouldn't touch the State object used by the pure function that calculates the deltas, and the event buffer should just be on the main thread
13:06:16 <Kaidelong> the only real use I can imagine is loading assets for the renderer which can be seen as being a kind of "State -> Params -> IO ()"
13:08:11 <kazagistar> Kaidelong: I am thinking in general, not for a specific use case... if you have a complex enough system that processing State -> State transtions for each frame takes more CPU time then you have on a single core
13:08:57 <kazagistar> so I guess I should say I am thinking about that case :P
13:10:01 <Kaidelong> kazagistar: since the Event -> (State -> State) function is pure, par and pseq should be enough
13:10:53 <Kaidelong> you're not really looking to do any kind of concurrent IO
13:11:24 <Kaidelong> also this might have been Jon Carmack's actual point
13:11:28 <Kaidelong> although I haven't seen the lecture
13:12:26 <kazagistar> Kaidelong: something like that, rendering and state transition are already kept separate
13:12:31 <Kaidelong> but it's still "single-threaded" in a haskell sense because you're just sparking on the main thread rather than making a new thread with its own threadID then using something like STM to synchronize again
13:13:02 <Kaidelong> in fact semantically par is just flip const
13:13:05 <ClaudiusMaximus> kazagistar: par/pseq can parallelize thunks, ghc does locking as necessary (afaik it doesn't even need to lock, due to purity - slight chance of a thunk being evaluated more than once but the answer will always be the same)
13:13:40 <kazagistar> ClaudiusMaximus: yeah, ok, that makes sense
13:14:01 <benzrf> isnt it john carmack
13:14:12 <Kaidelong> is it?
13:14:28 <benzrf> i think so
13:14:36 <kazagistar> yeah
13:15:34 <kazagistar> and yeah, the renderer can be in a separate thread from the state transition pretty computation pretty easily, so you can start the state computation before the render is done
13:19:18 <seydar> i have multiple threads in a chat server. i would like them to update a running total of how many messages the users have sent since the chat was started. what variable should i use? i'm using Channels for communication
13:19:36 <shadowofq> hello,
13:19:40 <Kaidelong> oh having the pure state transition off of the main thread opens up a lot of possibilities
13:20:33 <Kaidelong> actually this solves a lot of problems
13:21:47 <Kaidelong> I can have a model "the main thread handles the callbacks and makes a queue for the game state thread, the game state thread overwrites an MVar with the pointer to the latest game state every time it calculates a new game state, main thread then reads that MVar to run the renderer"
13:22:17 <shadowofq> (newbie question) I defined a function to read Int32 from a ByteString like this "getInt32  = do\n  word <- getWord32le\n  return $ fromIntegral word\n". I tried to inline the definition in another function (instead of the outermost scope of the file) using let... in but I am getting a parse error on "word"
13:22:58 <shadowofq> I guess the "do" syntactic sugar has something to do with the error?
13:23:49 <int3__> @pl \f (a, b) (c, d) -> f a b
13:23:49 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . const . const) .)) .)
13:24:00 <zomg> shadowofq: it's possible you have incorrect indentation or something like that
13:24:07 <Cale> shadowofq: That sounds like maybe your indentation is wrong
13:24:12 <int3__> @pl \f (a, b) (c, d) -> f a c
13:24:12 <lambdabot> (`ap` snd) . (. fst) . (const .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .)
13:24:19 <Pythonfant> omfg
13:24:30 <ClaudiusMaximus> Kaidelong: wouldn't an IORef with its atomic operations be easier if you don't need/want blocking behaviour?
13:24:37 <Cale> shadowofq: Make sure there are no tab characters in your file and that the rest of the lines in the do-block line up with the first non-whitespace character after 'do'
13:25:05 <ClaudiusMaximus> Kaidelong: ah, the renderer could block if the state isn't updated?
13:25:26 <Cale> (in particular, the r in return needs to line up with the w in word)
13:26:42 <kazagistar> shadowofq: it might help if you show us how you inlined it
13:30:02 <kazagistar> shadowofq_: you might also consider replacing it with (fmap fromIntegral . getWord32le)
13:30:22 <kazagistar> er, rather
13:30:29 <kazagistar> (fmap fromIntegral getWord32le)
13:31:50 * hackagebot minesweeper 0.9.2.1 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.9.2.1 (PeterDivianszky)
13:32:50 <shadowofq_> @kazagistar: ah yes, it is more elegant :-) About the do notation inside a let ... in, what would be the correct indentation?
13:32:50 <lambdabot> Unknown command, try @list
13:35:00 <Cale> shadowofq_: 'let', 'do', 'of', and 'where' are the layout keywords. The first non-whitespace character following one of these sets the column that you must align subsequent lines to in order to continue the block. The first line which is shallower will close the block, and deeper lines will continue a previous line.
13:35:32 <Cale> shadowofq_: Generally, if things are siblings, they should start in the same column, and parents should start in a shallower column than children
13:35:52 <otis> I'm sure this is a common problem encountered by haskell newbies, but how should I approach keeping my datatypes "open". Here is an example from the problem I'm having: http://lpaste.net/107027
13:35:54 <quchen> @remember Cale  'let', 'do', 'of', and 'where' are the layout keywords. The first non-whitespace character following one of these sets the column that you must align subsequent lines to in order to continue the block. The first line which is shallower will close the block, and deeper lines will continue a previous line.
13:35:55 <lambdabot> I will never forget.
13:36:00 <quchen> I imagine this will be of use in the future.
13:36:20 <otis> I understand where my problem lies, but I'm not sure how to best design the program while keeping the set of available materials extensible
13:36:22 <kazagistar> quchen: how do you recall that?
13:36:31 <quchen>  @quote Cale layout -- Like this
13:37:11 <kazagistar> quchen: cool
13:37:26 <Cale> otis: Why not:  data Material = Mat { reflect :: Ray -> Vect3 -> Color }
13:37:47 <Cale> otis: and then define your materials as values of that type
13:38:33 <kazagistar> otis: the two strategies (which are very closely related) are passing in functions as part of your datatype, and defining your function in terms of a typeclass
13:38:41 <otis> Cale: I wouldnt be able to pattern match on material type then would i?
13:39:20 <Cale> otis: Well, no, but do you need to?
13:39:57 <Cale> otis: You could add other fields to the Mat constructor there to give you additional information.
13:40:23 <otis> Cale: Eh,  I suppose I dont __need__ to. As this is a trivial ray tracer implementation I am modeling the lights as spheres with an emissive material.
13:41:03 <Cale> Just figure out which operations are relevant on materials and define a material as consisting of an implementation of those operations
13:41:46 <shadowofq_> @Cale: oh yeah! I got it. Thanks for the explanation. It is perfect :-)
13:41:46 <lambdabot> Unknown command, try @list
13:42:19 <otis> But does that address the extensibility problem?
13:42:23 <Cale> yes
13:43:05 <Cale> Just define more values of that type
13:43:30 <kazagistar> otis: think of it like this... if before you defined an interface and then implemented methods, now you can just store the "methods" directly in a record
13:44:17 <otis> Sure, but all of them would need to be defined in the same file to make use of them all, correct?
13:44:23 <Cale> This is the heart of object oriented programming
13:44:40 <Cale> otis: Nope, you can always add more in future modules
13:44:53 <Cale> so long as you export the data constructor for the Material type
13:45:08 <otis> Okay, that is the part I'm not seeing... one sec, I'll make another lpaste
13:45:17 <kazagistar> otis: not at all, you define the "interface" record in one file, and then the "implementation" is where you construct that record
13:45:28 <tulcod> otis: i think the right way to think about type*classes* is that they provide a programming interface that just happens to look the same for many things. it provides a sort of operator overloading. type*classes* are not *clases* as in OOP.
13:45:41 <Cale> otis: Just to be clear, I'm advocating that you not use type classes here.
13:46:34 <augur> blegh. untyped graphs! fooey
13:46:57 <tulcod> otis: so Showable is a class which you specify for a given type a by implementing show::a -> String. but whenever you use "show" in a program, you can actually refer to the argument's show specifically - you already know its type
13:47:16 <tulcod> otis: so in that sense typeclasses are just a way to make your code look more homogeneous
13:47:17 <Cale> Classes in OOP languages tend to have this unfortunate property of tying the implementation of methods to the type of the objects, which subclassing is used as a way to sidestep. There's not much reason for that apart from the fact that it's how the earliest OO languages did it for performance reasons.
13:48:04 <platz> the way it was explained to me: records of fuctions vs typeclasses: In general, you use a class when you want a different type for each different behavior, and there's only one sane behavior choice for each type.
13:48:11 <Cale> But if you think carefully about it, the type of an object ought to characterise just which methods/messages it could respond to, and the thing which sets objects of the same type apart should be how those objects react to various methods or messages.
13:49:09 <platz> and if the behavior is not 1-to-1 with a type records are the way to go; more flexible but less obvious
13:49:33 <Cale> With that kind of perspective, it's easy to do OO-style extensionality in Haskell: just define a record type with fields for each of the "methods", and write functions to construct objects of that type. The parameters to those functions are like what some languages call "private members".
13:51:13 <monochrom> I think it was simpler than that, Cale. there was an arbitrary line drawn between data and procedures. data were mutable, therefore the data part were put into mutable entries and called fields. procedures were immutable, therefore the procedures part were put into immutable entries and called methods. In Haskell and Javascript, both can be mutable.
13:52:22 <Cale> monochrom: That's also a reasonable point. I was thinking of the whole vtables-for-efficiency thing, but yeah.
13:52:55 <monochrom> Cf. global data were mutable, global procedures were immutable.
13:52:59 <kazagistar> well, vtables are pretty close to how haskell does Typeclasses anyways
13:53:33 <Cale> kazagistar: type class instances can be constructed at runtime though
13:54:02 <Peaker> vtables in OO are simply put in the wrong place -- inside the object, rather than as an automatic extra parameter
13:54:11 <Cale> kazagistar: It's possible to write programs which use Show at an unbounded number of concrete types :)
13:54:26 <benzrf> god dammit
13:54:34 <otis> Well here is what I'm failing to understand, how could I achieve something like this? http://lpaste.net/107030
13:54:37 <benzrf> are there no decent, possible-to-install image processing libraries for haskell?!
13:54:42 <benzrf> mother fucker
13:55:13 <Cale> Peaker: Or worse, they're statically compiled and all that can exist in the object is a reference to a vtable which can't ever be constructed at runtime.
13:55:26 <monochrom> does http://hackage.haskell.org/package/JuicyPixels count?
13:56:13 <isaacd> If I want a cryptographically secure pseudo random number generator, what library do I use? I see crypto-api and crypto-random which conflictingly provide module Crypto.Random, plus others
13:56:45 <Cale> otis: I'm uncertain why you'd ever need to inspect it. If you really want to be able to do that, then you'll automatically be giving up on extensibility, because things will need to exhaustively match on the possible material types.
13:57:09 <Cale> otis: and when you write the code which does that, you won't know what future material types might have been defined
13:57:23 <benzrf> monochrom: i dunno
13:57:26 <benzrf> let me try it
13:57:45 <Cale> otis: This approach can be fine. The compiler can tell you where all the code is that needs to be updated when you change a data type
13:58:00 <Cale> otis: But I'm having a hard time seeing why you'd want to do that in this context.
13:58:18 <monochrom> "what is 'extensible'?" is not a philosophical question.
13:58:29 <mm_freak> benzrf: what do you want to do?
13:58:46 <otis> Cale: What part? The "ExtraMaterials" aspect, or being able to inspect the "Material Type"?
13:58:53 <kazagistar> otis: but if you have something that you wish to DO with the material type, then you can just include a way to do that action in an extendable way
13:58:56 <mm_freak> benzrf: i mostly use JuicyPixels and comonad/StoreT for image processing
13:59:04 <mm_freak> benzrf: usually together with repa
13:59:06 <Cale> otis: Being able to inspect the material type
13:59:14 <benzrf> just want to do some basic scaling and superposition
13:59:16 <Cale> otis: That's not a fundamental operation
13:59:42 <benzrf> or compositing, whatever the word is
13:59:43 <mm_freak> benzrf: scaling is easy, what kind of superposition?  blending?
13:59:48 <Cale> otis: Think about how the material type affects the rest of the program, and encode *those* things into the material instead.
13:59:57 <benzrf> just basic overlaying
14:00:07 <Cale> otis: i.e. things like that reflect function
14:00:13 <mm_freak> benzrf: i know no ready-made library to do this, but it's really easy to write the primitives
14:00:30 <benzrf> ew writing primitives :[
14:00:31 <Cale> otis: If you want a String materialName or something for display purposes, you could add something like that.
14:00:39 <kazagistar> otis: the question is "how do I inspect the material so I can do <this> with it", and the answer is "just include a way to do <this> with the extensible record"
14:01:02 <mm_freak> benzrf: load the image(s) using JuicyPixels, go from the basic array to Store (V2 Int), convert to Store (V2 Double) using the interpolation step of your choice
14:01:11 <Peaker> otis: do you know what an "initial encoding" or a "final encoding" is?
14:01:16 <otis> Cale: Well like I said earlier, I'm since this is a trivial ray tracer, I have modeled everything including lights as spheres. The only difference being the type of material a sphere has. To compute the shadows at a given pixel I want to first find all the lights in my scene.
14:01:38 <otis> So first thing I thought of doing was filtering based on material type
14:01:55 <otis> Peaker: No I do not
14:02:02 <Peaker> otis: initial encoding is one where your Material type is a big sum type remembering everything there is to know about the material. Then you can compute anything you want from that -- but it's not easily extensible..
14:02:23 <mm_freak> benzrf: then write a transform function:  transform :: (ComonadStore (V2 s) w, Fractional a, Fractional s) => M33 s -> Store (V2 s) a -> a
14:02:43 <Peaker> otis: A final encoding is one where you forget as much as possible about the material, but instead store the exact operations you need to do inside it, as a record.  This is extensible with new material types, but require a large change for adding new things you want to do with it
14:02:46 <mm_freak> benzrf: M33 as well as predefined scaling/rotation/translation matrices are in the 'linear' library
14:02:55 <otis> kazagistar: sorry I don't follow : O
14:03:09 <benzrf> blaaaah
14:03:33 <mm_freak> benzrf: this is just the general outline…  it's really easier than it sounds
14:03:37 <Peaker> otis: so either you describe the material itself (initial, easy for 3rd party to add new operations), or you describe everything you could possible do with it (final, easy for 3rd party to add new materials)
14:03:40 <monochrom> instead of "material", let's cut to the mustard: how much light it lets through, and how much light it bounces back. looks like just two numbers to me.
14:04:05 <mm_freak> benzrf: http://lpaste.net/106491
14:04:09 <Peaker> monochrom: if you really want to model materials, you probably want more than those 2 numbers eventually :)
14:04:20 <monochrom> the context is raytracing
14:04:25 <benzrf> mm_freak: what the fuck is this
14:04:39 <monochrom> make it 6 numbers if you say it has a colour
14:04:59 <mm_freak> benzrf: image transforms…
14:05:00 <Peaker> monochrom: don't materials have properties like light diffusion, spectral swallowing/reflections, etc?
14:05:04 <mm_freak> benzrf: using linear algebra
14:05:30 <monochrom> I forgot them. more numbers then.
14:05:31 <mm_freak> benzrf: 'transform' takes a matrix and an image and produces a transformed pixel
14:06:40 <mm_freak> benzrf: read "Store (V2 Int)" as "picture with integer coordinates"
14:07:04 <mm_freak> and "Store (V2 Double)" as "continuous picture"
14:07:29 <otis> Peaker: Im not sure I follow... would this be a final encoding?
14:07:29 <otis> http://lpaste.net/107031
14:07:42 <otis> sans type
14:07:44 <otis> typo
14:07:55 <Cale> otis: Possibly
14:08:05 <otis> ha
14:08:20 <otis> ok... Now im more confused... : )
14:08:23 <kazagistar> otis: you can't do "matching" on something extendable, and you wouldnt expect to in OOP either... you dont write code (unless it is horrible code) like "if (mat.getClass() == Emissive)..."  Instead, you just call a function on emissive... here, we pass around those functions explicitly, or via typeclasses
14:08:59 <Cale> otis: You might have an initial encoding like  data NumOp = Plus Int | Times Int
14:09:05 <otis> kazagistar: true
14:09:38 <otis> Cale: What about that makes it an initial encoding?
14:10:55 <otis> I mean I sorta understand how it is so... based on Peaker's explanation that is
14:11:05 <Peaker> otis: (Plus Int | Times Int) describes the data in a "transparent" way. You can look inside and see everything there is to know.  Then, there is:  data NumOp = NumOp { showOp :: String, applyOp :: Int -> Int }  which is the "final" encoding.  You don't know whether it was Plus or Times, but you can either show or apply it
14:11:08 <Cale> otis: Well, the idea is: among types which are capable of representing the thing we want to represent, this type will have a unique mapping to any other
14:11:19 <mm_freak> i think i should write an article on comonadic image processing
14:11:21 <Cale> (which preserves the representation)
14:11:38 <Peaker> otis: or maybe, if you're only interested in applying it, you forget how to show it in your final encoding
14:11:44 <Cale> otis: While with a "final encoding", any other representation will have a unique mapping to that representation
14:12:48 <Cale> i.e. it's easy to get functions *from* initial representations, and it's easy to get functions *to* final ones.
14:13:52 <otis> Cale: Just so I follow... Would an Int be an initial representation?
14:14:17 <Cale> otis: Well, there's always the question of *what* it's meant to be an initial representation of, but yeah
14:14:54 <otis> You mean, because an Int alone would be ambiguous?
14:15:33 <Cale> (I'm not sure I would have introduced these terms here, it's sort of hard to talk precisely about without a bunch of other material which is a big detour)
14:16:07 <kazagistar> otis: look at how "sort" works... in java, { static <T extends Comparable<? super T>> void sort(List<T> list) }, in haskell { sort :: Ord a => [a] -> [a] }... but the interesting part is in the "customization version", where  java does  { static <T> void sort(List<T> list, Comparator<? super T> c) } and haskell does { sortBy :: (a -> a -> Ordering) -> [a] -> [a] }
14:16:47 <Peaker> Cale: I mentioned it because I thought it was relevant -- he could describe his material as a sum type making adding operations easy, or as a record of operations, making adding new materials easy
14:17:07 <otis> Peaker: I understand that
14:17:07 <Peaker> I didn't mean to introduce it very formally, though :)
14:17:20 <Cale> Peaker: It *is* very relevant, it's just hard for beginners who can't be expected to know a bunch of category theory so we could make everything precise :)
14:17:22 <kazagistar> in java, the comparator is just a object wrapper around a comparison method, while in haskell we just pass the comparing function directly
14:17:39 <mm_freak> can i force ghci to interpret a file as literate haskell despite its .txt extension?
14:17:58 <otis> kazagistar: i'm following
14:18:47 <Cale> otis: The real thing to consider is that you always tend to have a choice between constructing a data type which exhaustively has cases for everything that you want to represent, e.g. one constructor for each material you have, with fields for the individual properties of that material. This is relatively inextensible, but it's very easy to write new functions to operate on these things, because you know what they all
14:18:47 <Cale> are, and can case on the constructor and take them apart.
14:19:07 <otis> Cale: Any material you'd point me to? A quick google search for "initial encoding" didn't turn up much
14:19:18 <Cale> otis: Or, there's the opposite option: collect up all the operations you would have written to act on materials, and define a material to be an implementation of those operations instead.
14:19:32 <Cale> This is highly extensible, it's easy to write new functions which construct materials like taht
14:19:34 <Cale> that*
14:19:40 <otis> Cale: Yeah I understand that much
14:19:49 <Cale> but if you want to extend the operations, that's harder then
14:20:09 <Cale> Those two approaches are pretty much what Peaker means by "initial" and "final" encoding respectively.
14:20:17 <otis> Oh yes, isn't this the "Expression Problem"?
14:20:21 <Cale> yes
14:20:42 <Cale> Solutions to the expression problem are always somewhat a matter of taste
14:20:53 <kazagistar> but extending the operations possible on all materials is not really possible without changing every single material
14:21:13 <Cale> Well, you can get extensibility in all directions, but it comes at a somewhat heavy cost.
14:21:44 <Cale> and you usually don't really want it -- you'd prefer that the type system is working to ensure that you've completely implemented things in some direction
14:22:27 <kazagistar> Material is a promise that you can use it everywhere that expects Material
14:23:01 <otis> kazagistar: sorry what is material in this context? A data type or a type class?
14:23:09 <otis> a datatype right?
14:23:19 <Cale> Yeah, I think so :)
14:23:21 <kazagistar> uh sure
14:23:40 <otis> ?
14:23:42 <kazagistar> ... I kinda stopped thinking of them as too much different other then taste when I realized they are almost the same thing
14:24:01 <monochrom> mm_freak: "ghci (or ghc) -x lhs g.txt". beware: "Causes all files following this option"
14:24:52 <kazagistar> otis: we can think of Material as a class in Java or something even if you like
14:24:59 <Cale> otis: But yeah, if I were writing a raytracer, I'd probably opt for one of these latter sorts of solutions, where you say that a material consists of those functions which express what the material does to a given ray -- probably a lot of the time involving recursively applying the raytracer to some rays.
14:25:45 <benzrf> hsmagick looks decent but it depends on C libraries and complains about them even when i have them installed
14:25:48 <benzrf> +.+
14:25:49 <kazagistar> you cannot extend "some" Materials to add functionality that others lack, and use that functionality from Material. All Materials have everything promised by Material, and when using Material, you use only those things
14:26:36 <benzrf> i have GraphicsMagick 1.3.18 but it says:
14:26:41 <benzrf> cabal: The pkg-config package 'GraphicsMagick' version >=1.3.3 is required but
14:26:49 <benzrf> it could not be found.
14:27:03 <kazagistar> so that might be a render method which does some IO, a toString method, etc
14:27:09 <Cale> otis: This sort of approach also makes it easy to write operations which combine Materials -- you can define a material whose 'reflect' applies the 'reflect' from two different materials to the given ray and combines the resulting colours somehow
14:27:38 <otis> Cale: So you'd abandon being able to inspect the "kind" of material then? At least to me, the "final encoding" approach seems to imply that being unwieldy if not impossible
14:28:19 <Cale> otis: Yeah, I wouldn't bother with that. If I needed to inspect the "kind" of material inside of a certain operation, I'd move that operation inside of the definition of what a Material is.
14:28:24 <kazagistar> otis: you never had the ability to inspect the kind of the material outside the implementation details related to that specific material
14:29:09 <Cale> (does that make sense?)
14:29:29 <kazagistar> not with proper OOP at least, inspecting type is a major code smell
14:30:07 <monochrom> alternatively, "inspecting" is an XY problem, so solve the X problem for real
14:30:29 <kazagistar> exactly
14:30:40 <monochrom> @quote monochrom river
14:30:40 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
14:30:40 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
14:30:41 <monochrom> :)
14:30:46 <kazagistar> thats a good way of putting it, assuming an understanding of XY problem
14:30:57 <otis> Well I think I understand : ) I'm just not sure how I'd do such a thing without running into the problems I've mentioned in my last lpaste
14:31:15 <kazagistar> monochrom: I like it :P
14:31:18 <otis> But there are easy ways to avoid the problem altogether
14:31:41 <mm_freak> monochrom: thanks!
14:32:11 <mm_freak> it's really only for articles, so that i can use .txt and still have LHS
14:33:14 <otis> Okay well I must go for a bit. Thanks for all the help
14:33:26 <isomorpheous> Hey, y'all
14:33:32 <isomorpheous> How's it goind
14:33:35 <isomorpheous> *going
14:34:09 <monochrom> ghc -x hs dennis.c guido.py gosling.java :)
14:34:28 <monochrom> hrm, not golsing!
14:34:37 <isomorpheous> Having a bit of a problem with Warp and ssl
14:34:44 <kazagistar> otis: just trust us for now when we say that extending by "pass in the functions you will need" rather then "data and methods" actually works really nicely and leads to a lot of reuse fairly well
14:35:03 <isomorpheous> my internet has decided to shit itself, so I can't seem to load any real data
14:35:39 <isomorpheous> So, I can't get an actual url to the code. The code is on https://github.com/pharpend/podium
14:35:39 <isomorpheous> Branch "tls"
14:35:41 <isomorpheous> I'm trying to figure out how to add tls
14:35:57 <isomorpheous> I can write code that compiles, and starts to run
14:36:54 <isomorpheous> However, when I query my app with 'curl https://localhost:8000', cabal prints 'podium: no keys found' to stderr
14:37:06 <isomorpheous> This is with warp, by the way
14:37:23 <monochrom> benzrf: do you have libgraphicsmagick1-dev ?
14:37:26 <isomorpheous> I think I'm doing some ssl stuff wrong
14:37:33 <isomorpheous> The paths to the various keys are correct
14:37:39 <otis> kazagistar: So lets say I wanted to parameterize a material I might have something that looks like "Mat { reflect :: Ray -> Color }" and then a smart constructor "emissive a b c = Mat (reflectEmissive a b c)"
14:38:44 <otis> That is what you are suggesting, correct?
14:39:47 <otis> Or something along those lines... : )
14:40:08 <kazagistar> otis: yep. Or the totally 100% equivalent version, which is to say "type Mat where reflect :: Ray -> Color" and then "instance Mat Emissive where reflect ... = ..."
14:40:36 <benzrf> monochrom: i think so
14:40:49 <benzrf> oh
14:40:51 <benzrf> no i dot
14:40:51 <benzrf> wtf
14:40:55 <monochrom> heh
14:40:58 <benzrf> i swear i installed it ;-;
14:41:09 <monochrom> a hacker uninstalled it :)
14:41:10 <kazagistar> otis: those are not just similar in functionality, the second is actually implemented as the first in the background of GHC, and thats actually how typeclasses work
14:41:15 <Tjr> Is there something like replicate which accepts abitrary Integral counts?
14:41:27 <monochrom> genericReplicate?
14:41:29 <benzrf> Tjr: convert to Integer
14:41:32 <benzrf> :t genericReplicate
14:41:33 <monochrom> @type genericReplicate
14:41:33 <lambdabot> Integral i => i -> a -> [a]
14:41:33 <lambdabot> Integral i => i -> a -> [a]
14:41:34 <benzrf> :t toInteger
14:41:35 <lambdabot> Integral a => a -> Integer
14:41:36 <benzrf> oh
14:41:51 <Tjr> monochrom: thanks
14:41:54 <monochrom> it may be slower
14:42:16 <Tjr> benzrf: that would fail silently if I had maxBound::Int counts.
14:42:23 <otis> kazagistar: haha, well thats what I started with : P
14:42:30 <otis> okay thanks. I must be going
14:43:16 <Tjr> > fromIntegral $ 1 + maxBound::Int
14:43:17 <lambdabot>  No instance for (GHC.Real.Integral s0)
14:43:18 <lambdabot>    arising from a use of ‘GHC.Real.fromIntegral’
14:43:18 <lambdabot>  The type variable ‘s0’ is ambiguous
14:43:18 <lambdabot>  Note: there are several potential instances:
14:43:18 <lambdabot>    instance GHC.Real.Integral GHC.Types.Int
14:43:29 <kazagistar> the generic version is probably only slower if not agressively inlined?
14:43:40 <Tjr> > fromIntegral $ 1 + (maxBound::Int)
14:43:41 <lambdabot>  -9223372036854775808
14:44:07 <Tjr> > 1 + (fromIntegral $ 0 + (maxBound::Int))
14:44:08 <lambdabot>  9223372036854775808
14:44:38 <Darwin226> Hey, can someone explain to me why haskell doesn't have compile time functions that would operate on type level and produce new types? I know that generic types are what I'm describing but it all seems very limited. Why isn't there some richer syntax that would let you describe arbitrary static type rules? Or did I just miss it?
14:45:11 <dv-> template haskell?
14:45:50 <k00mi> more like type families
14:46:03 <monochrom> "data X a = C1 Int | C2 Bool a | C3 Char (X a)" is a compile-time function that operate on type level and produce a new type.
14:46:56 * hackagebot keystore 0.2.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.2.0.0 (ChrisDornan)
14:47:07 <tremon> hi all, I'm trying to tie Network.WebSockets into a small Network.HTTP webserver. However, HTTP uses its own HandleStreams whereas WebSockets uses standard IO InputStreams. Am I missing something obvious, or I need to write the glue myself?
14:47:22 <monochrom> "user-added arbitrary static type rules" sounds unsafe. what if the user adds an unsound type system?
14:47:30 <Darwin226> monochrom: As I said, I'm aware that's the case but it seems very limited. When I checked out how type-safe vectors are done using GADTs it all seemed like a huge hack or at least like it's stretching the bounds
14:47:57 <mm_freak> is there a good term that unifies audio, image and video?
14:48:04 <monochrom> media
14:48:08 <Darwin226> monochrom: I don't see how that's a problem. He wrote the rules, they're broken, they don't work. Isn't that programming in a nutshell?
14:48:13 <monochrom> multimedia :)
14:48:18 <johnw> audimageo
14:48:27 <Rarrikins> audiovisual
14:48:42 <monochrom> did you remember the days of "multimedia PC"? :)
14:49:13 <mm_freak> multimedia seems fine
14:49:24 <Rarrikins> boo
14:49:25 <mm_freak> it's just for the title of my tutorial =)
14:49:32 <mm_freak> "Comonadic multimedia processing" sounds good
14:51:09 <kazagistar> mm_freak: seems to match the normal style of saying (1) what you are doing and (2) something category theory-ish to identify that you are doing it in haskell
14:52:07 <johnw> the first rule of category theory club is to state your identity
14:52:15 <monochrom> haha
14:52:31 <monochrom> @remember johnw the first rule of category theory club is to state your identity
14:52:31 <lambdabot> Done.
14:52:43 <mm_freak> kazagistar: no, this /is/ about the categorical abstraction
14:52:54 <mm_freak> i.e. how comonads improve your multimedia processing
14:54:00 <benzrf> ugh come ON hsmagick
14:54:00 <benzrf> ghc: malloc.c:2372: sysmalloc: Assertion `(old_top == (((mbinptr) (((char *) &((av)->bins[((1) - 1) * 2])) - __builtin_offsetof (struct malloc_chunk, fd)))) && old_size == 0) || ((unsigned long) (old_size) >= (unsigned long)((((__builtin_offsetof (struct malloc_chunk, fd_nextsize))+((2 *(sizeof(size_t))) - 1)) & ~((2 *(sizeof(size_t))) - 1))) && ((old_top)->size & 0x1) && ((unsigned long) old_end
14:54:06 <benzrf> & pagemask) == 0)' failed.
14:54:20 <benzrf> wtf is this garbage
14:54:33 <benzrf> and it segfaulted when i tried to read a jpg
14:54:59 <johnw> FFI code is awesome
14:55:18 * benzrf waves his hands in the air furiously
15:11:36 <darthdeus> how can I get a directory path from a FilePath to a file?
15:12:56 <pavonia> @hackage filepath
15:12:57 <lambdabot> http://hackage.haskell.org/package/filepath
15:13:33 <Tjr> I've got a silly problem
15:13:34 <Tjr> uniformProb = 1 / sides
15:13:40 <Tjr> gaa mispaste
15:13:58 <Tjr> @ty \sides -> ( 1/sides, [1..sides])
15:13:59 <lambdabot> (Fractional t, Enum t) => t -> (t, [t])
15:14:05 <darthdeus> pavonia: thanks
15:14:55 <Tjr> Now I want 1/sides to become a Rational if I stick in an Integer sides
15:15:07 <Tjr> However, ghci always turns it into a Double
15:15:36 <Tekmo> Isnt 1 / (sides :: Integer) a type error?
15:15:55 <Tjr> @ty \sides -> ( 1/(fromIntegral sides), [1..sides])
15:15:56 <lambdabot> (Integral t1, Fractional t) => t1 -> (t, [t1])
15:16:11 <Tekmo> :info Rational
15:16:16 <pavonia> You could make your function a type class function
15:16:16 <Tekmo> @info Rational
15:16:17 <lambdabot> Rational
15:16:53 <pavonia> :t \sides -> (1 % (fromIntegral sides), [1..sides])
15:16:53 <Tjr> @let testfunc sides = (1 / (fromIntegral sides), [1..sides])
15:16:54 <lambdabot> (Integral t, Integral a) => t -> (Ratio a, [t])
15:16:56 <lambdabot>  Defined.
15:17:03 <Tjr> @ty testfunc
15:17:04 <lambdabot> (Integral t1, Fractional t) => t1 -> (t, [t1])
15:17:17 <Tjr> @ty testfunc (2::Integer)
15:17:17 <lambdabot> Fractional t => (t, [Integer])
15:17:35 <monochrom> it is defaulting. use "default (Integer, Rational)" to default to Rational
15:18:34 <Tjr> monochrom: thanks. Good to know it's not a bug.
15:20:05 <Tjr> @let testfunc2 :: (Integral a, Rational b) => a -> (b,[a]) ; testfunc2 = testfunc
15:20:06 <lambdabot>  .L.hs:156:27:
15:20:06 <lambdabot>      ‘Rational’ is applied to too many type arguments
15:20:06 <lambdabot>      In the type signature for ‘testfunc2’:
15:20:06 <lambdabot>        testfunc2 :: (Integral a, Rational b) => a -> (b, [a])
15:20:46 <Tjr> shouldn't an explicit type signature override the defaults?
15:20:51 <Tekmo> Tjr: Note that `Rational` is a type not a type class
15:20:58 <Tekmo> Tjr: type Rational = Ratio Integer
15:21:17 <Tjr> @let testfunc2 :: (Integral a, Rational ~ b) => a -> (b,[a]) ; testfunc2 = testfunc
15:21:17 <lambdabot>  Parse failed: TypeFamilies is not enabled
15:21:42 <Tekmo> Tjr: That's the same thing as: (Integral a) => a -> (Rational, [a])
15:21:53 <Tjr> @let testfunc2 :: (Integral a) => a -> (Rational,[a]) ; testfunc2 = testfunc
15:21:54 <lambdabot>  Defined.
15:22:16 <Tjr> testfunc2 5
15:22:20 <Tjr> >testfunc2 5
15:23:03 <Tjr> lambdabot?
15:23:15 <Tjr> > testfunc2 5
15:23:17 <lambdabot>  can't find file: L.hs
15:23:34 <Tjr> What does that error message mean?
15:23:46 <Tekmo> I don't know
15:25:16 <kazagistar> Tjr: that means it cant find the file it stores all the defines in
15:25:19 <kazagistar> @undefine
15:25:20 <lambdabot> Undefined.
15:25:54 <kazagistar> @let map = "oh no!"
15:25:55 <lambdabot>  Defined.
15:26:09 <kazagistar> > map
15:26:10 <lambdabot>  Ambiguous occurrence ‘map’
15:26:10 <lambdabot>  It could refer to either ‘L.map’, defined at L.hs:146:1
15:26:10 <lambdabot>                        or ‘GHC.Base.map’,
15:26:10 <lambdabot>                           imported from ‘Data.List’ at L.hs:85:1-16
15:26:10 <lambdabot>                           (and originally defined in ‘base:GHC.Base’)
15:26:16 <kazagistar> >L.map
15:26:25 <kazagistar> > L.map
15:26:26 <lambdabot>  "oh no!"
15:26:31 <kazagistar> @undefine
15:26:31 <lambdabot> Undefined.
15:26:49 <Tjr> @undefine
15:26:49 <lambdabot> Undefined.
15:26:56 <Tjr> @let testfunc2 :: (Integral a) => a -> (Rational,[a]) ; testfunc2 = testfunc
15:26:57 <lambdabot>  .L.hs:148:13:
15:26:57 <lambdabot>      Not in scope: ‘testfunc’
15:26:57 <lambdabot>      Perhaps you meant ‘testfunc2’ (line 148)
15:27:29 <kazagistar> lambdabot pretty transparently just vomits all the lets into a single file which it then evals and uses to run subsequence commands
15:27:48 <Tjr> @undefine
15:27:49 <lambdabot> Undefined.
15:27:49 <Tjr> @let testfunc sides = (1 / (fromIntegral sides), [1..sides])
15:27:49 <Tjr> @let testfunc2 :: (Integral a) => a -> (Rational,[a]) ; testfunc2 = testfunc
15:27:50 <lambdabot>  Defined.
15:27:51 <lambdabot>  Defined.
15:27:57 <Tjr> > testfunc2 5
15:27:59 <lambdabot>  (1 % 5,[1,2,3,4,5])
15:28:17 <Tjr> ok, now it works.
15:28:23 <Tjr> Probably something timed out.
15:29:28 <Tjr> Does testfunc2 convert 1/5 to a Rational straight away, or does it round-trip it through Double?
15:29:47 <Tekmo> Straight away
15:29:54 <Tekmo> There is no way it could retrieve a `Rational` from a `Double`
15:30:30 <Tjr> The documentation says somewhere that when you convert a Float to a Double, the default is to round-trip it through Rational (which is very expensive)
15:31:00 <Tekmo> Yes, but it is not a `Float`
15:31:27 <Tjr> @ty testfunc 4
15:31:28 <lambdabot> (Integral t1, Fractional t) => (t, [t1])
15:31:36 <Tjr> > testfunc 4
15:31:39 <lambdabot>  (0.25,[1,2,3,4])
15:31:48 <Tjr> that looks a lot like a float or double.
15:31:58 <Tekmo> That's because it is a double
15:32:04 <johnw> hi Tekmo!
15:32:08 <Tekmo> johnw: Hi!
15:32:21 <Tekmo> @info Double
15:32:21 <lambdabot> Double
15:32:56 <Tjr> When does it become a double? On display only? Or earlier?
15:33:17 <Tjr> Or already when I divide by 4?
15:33:54 <Tekmo> Tjr: Let me use a simpler example
15:34:07 <mm_freak> Tjr: the conversion through Rational is what happens as a last-resort
15:34:08 <Tekmo> Tjr: Let's say you write: `1 / 4 :: Double`
15:34:21 <mm_freak> Tjr: compiler optimisations will most likely remove that step
15:34:30 <Tekmo> Tjr: When you write that, the compiler deduces that `1` and `4` are `Double`s
15:34:30 <Tjr> mm_freak: good to know
15:34:43 <Tekmo> Tjr: They start as `Double`s without any casting
15:34:57 <Tekmo> Tjr: Now if you write: `1 / 4 :: Ratio`
15:35:08 <Tekmo> Tjr: The compiler deduces that the `1` and `4` are `Ratio`s
15:35:10 <Tjr> Tekmo: I'm not writing Double anywhere in my code, it just magically appears
15:35:12 <mm_freak> Tjr: however, notice that those optimisations are triggered by RULES, so they will not work on newtype wrappers
15:35:33 <Tekmo> Tjr: The `Double` type is chosen at the last moment using what is known as "defaulting"
15:36:20 <mm_freak> Tjr: also literals are typically not affected by this…  at least for the predefined types they are more likely to start with the desired representation
15:36:26 <mm_freak> otherwise numeric code would be horribly slow
15:36:29 <Tekmo> Tjr: For numeric types Haskell will default types to `Double` or `Integer`
15:36:52 <Tekmo> Tjr: This is done at the very last minute if the type is still ambiguous after all type inference is complete
15:37:00 * hackagebot aur 1.0.0 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-1.0.0 (fosskers)
15:37:02 * hackagebot propellor 0.8.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.8.0 (JoeyHess)
15:37:44 <Tjr> ok, so the Double isn't visible to intermediate code.
15:37:54 <Tekmo> Tjr: That's right
15:38:00 <Tekmo> Tjr: There is no concept of intermediate type here
15:38:09 <Tekmo> Tjr: It's not like there are any type conversions going on here
15:38:30 <Tekmo> Tjr: The type is *starting* as a `Double`
15:39:18 <Tekmo> Tjr: The only thing defaulting does is pick a specific type
15:39:32 <Tekmo> Tjr: The compiler then works backwards from that type to figure out what the initial type must have been
15:40:04 <jmcarthur> (in the most general case it's actually starting as a Rational, but it's probably going to hard code it as a Double if it can tell that's how you'll be using it)
15:40:43 <Tekmo> Let me go back to my original explanation
15:40:59 <Tjr> ok, that point is clear now
15:41:06 <Tekmo> Alright
15:42:25 <jmcarthur> i think it's weird that the default for integers is Integer but the default for rationals is not Rational
15:42:55 <benzrf> :t Ratio
15:42:55 <lambdabot> Not in scope: data constructor ‘Ratio’
15:42:58 <benzrf> :k Ratio
15:42:58 <lambdabot> * -> *
15:43:00 <benzrf> hm
15:43:19 <jmcarthur> Rational = Ratio Integer
15:43:19 <benzrf> > "foo" % "bar"
15:43:21 <lambdabot>  No instance for (GHC.Real.Integral [GHC.Types.Char])
15:43:21 <lambdabot>    arising from a use of ‘GHC.Real.%’
15:43:24 <benzrf> :t (%)
15:43:25 <lambdabot> Integral a => a -> a -> Ratio a
15:43:27 <benzrf> ah
15:43:50 * benzrf tries to think of a pun involving integral parts of things
15:43:55 <jmcarthur> > 8 % 32
15:43:56 <lambdabot>  1 % 4
15:44:12 <monochrom> it was because the Republicans wanted Int,Double and the Democrats wanted Integer,Rational. they got into a Mexican stand-off. then they stroke a deal.
15:46:12 <Tjr> odd.
15:46:35 <Tjr> I've defined confolute, almostSurely, dist elsewhere.
15:46:45 <Tjr> This line is ok with count being an Integral:
15:46:46 <Tjr> nhD count sides = foldr convolute (almostSurely 0) $ Li.genericReplicate count \
15:46:46 <Tjr> dist
15:47:17 <Tjr> but if I set gReplicate = Li.genericRepliacate (globally)
15:47:43 <bms1> Tjr: The "dreaded monomorphism restriction"
15:47:59 <Tjr> and then do s/Li.genericReplicate/gReplicate/, then ghci claims nhD is only for Integral.
15:48:03 <bms1> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:48:04 <Tjr> err, Integer.
15:48:18 <Tjr> it's all in the same file. No exporting here.
15:51:45 <Tjr> bms1: thanks, "gReplicate n x = Li.genericReplicate n x" solves that problem.
15:51:59 * Tjr wishes the compiler would actually say monomorphism restriction.
15:56:51 <ddisqq> Hello
15:57:10 <ddisqq> Grep for > eh?
16:00:10 <ddisqq> Hi
16:00:57 <quchen> Hello.
16:05:33 <zq> .scroll end
16:10:31 <mm_freak> edwardk: wouldn't 'Store s' be a monad, if s is a monoid?
16:11:14 <mm_freak> seems to be just about the reader monad, but with "position updating"
16:13:27 <Guest22395> تحذير
16:13:27 <Guest22395> warning
16:13:27 <Guest22395>  you may be  watched
16:13:27 <Guest22395> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
16:13:27 <Guest22395> do usa&israel use the internet 2 collect informations,,can we call that spying??
16:13:27 <Guest22395> do they record&analyse everything we do on the internet,,can they harm you using these informations??
16:13:34 --- mode: ChanServ set +o geekosaur
16:13:41 --- mode: geekosaur set +b *!*pc@197.123.57.*
16:13:41 --- kick: Guest22395 was kicked by geekosaur (Guest22395)
16:14:08 --- mode: geekosaur set -o geekosaur
16:15:17 <jmcarthur> really? that spam is still going?
16:15:43 <systemfault> It’s always the same dude from egypt.. and he’s not even proxying himself…
16:15:45 <geekosaur> always and forever
16:16:24 <Cale> At least until the USA and Israel learn their lesson and stop spying :)
16:16:53 <Synchunk> I like the fact that that program sends so many messages that the server kills it :)
16:17:38 <orzo> i don't know what تحذير but the letters are pretty in my font
16:17:43 <orzo> means
16:17:50 <Synchunk> I think it means "Warning".
16:18:23 <Synchunk> But I can't copy and paste it into a translator because I don't have a mouse -_-
16:18:42 <systemfault> In the end… no matter if he’s right or not. Flooding it on IRC won’t change anything.
16:18:52 <orzo> google translate says warning
16:19:05 <HailSatan666> he should just use tor
16:19:26 <HailSatan666> probably is lol
16:20:10 <systemfault> Nope, just a random dude from egypt having electrons to waste.
16:21:04 <benzrf> :k Store
16:21:05 <lambdabot> Not in scope: type constructor or class ‘Store’
16:21:23 <Tjr> How do I handle "monads with restrictions"?
16:21:24 <benzrf> i always read Cofree sa Coffee
16:21:28 <benzrf> Tjr: what do you mean
16:21:54 <Tjr> instance Monad .... where return value = almostSurely value
16:22:13 <benzrf> :t almostSurely
16:22:14 <lambdabot> Not in scope: ‘almostSurely’
16:22:16 <benzrf> ?
16:22:32 <Tjr> except that almostSurely :: (Ord x ) => x -> MyMonad x
16:22:42 <benzrf> Tjr: cant do that
16:22:57 <Tjr> what's the best place to put this Ord constraint?
16:23:01 <benzrf> Tjr: you cant
16:23:20 <benzrf> there is no way to make almostSurely return for the stdlib Monad class
16:23:25 <benzrf> not without horrible hacks
16:23:51 <Tjr> wasn't there some alternative Monad with restrictions?
16:24:01 <Tjr> or is that a bad idea?
16:24:05 <benzrf> Tjr: probably a bad idea
16:24:24 <Tjr> (I can make the almostSurely function less powerful, but that's a bad idea form the algorithm point of view)
16:24:35 <Tjr> less powerful == no Ord constraint
16:24:47 <benzrf> Tjr: put the Ord on the other functions
16:24:52 <benzrf> not on almostSurely
16:24:59 <benzrf> that, or make return less powerful
16:25:20 <Tjr> In the actual example, it's >>= that needs the Ord constraint
16:25:40 <Tjr> where it's harder to get rid of
16:25:42 <benzrf> Tjr: cant do that
16:26:03 <benzrf> unless you use constraints on the constructor like some kind of crazy person
16:26:24 <benzrf> Tjr: does your bind follow the monad laws?
16:26:36 <benzrf> things that require an additional class often violate the monad laws
16:26:54 <Tjr> benzrf: yes, it does.
16:27:02 <kazagistar> isn't one of the most important bits of monads the fact that you can use monad transformers? can you still build those with constraints in a reasonable way?
16:27:04 * hackagebot simple 0.10.0.2 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.10.0.2 (AmitLevy)
16:27:21 <Tjr> http://hackage.haskell.org/package/rmonad --> how about that?
16:27:45 <Tjr> kazagistar: I'll get there eventually, for now I haven't looked into transformers
16:28:41 <benzrf> kazagistar: ...since when is that the most important part of a monad
16:28:57 <Cale> I honestly think that monad transformers are highly overrated
16:28:58 <benzrf> wow, my new laptop's screen can bend back past horizontal
16:28:59 <benzrf> holy sit
16:28:59 <kazagistar> benzrf: I said one of
16:29:02 <Tjr> "or use Control.RMonad.AsMonad with the embed and unEmbed combinators to use the normal Prelude monad operations. "
16:29:15 <Tjr> hmm, how do I find out what that means?
16:29:18 <benzrf> Tjr: this all sounds like a pretty bad idea to me
16:29:21 <benzrf> what's the monad?
16:29:24 <benzrf> something probablistic?
16:29:37 <Tjr> It's not like there is a link to documentation, or even the source code.
16:30:07 <kazagistar> I guess it was just an example of something library that actually consumes the general monad interface fully
16:30:29 <Tjr> yes, it's a probability distribution monad. I know there's already the probability package, but (a) it doesn't suit my needs, and (b) I'll roll my own form scratch as a learning opportunity
16:32:13 <shlevy> If I'm writing an FFI wrapper to a non-threadsafe library, is there any way I can mark the wrapper as not threadsafe? Or maybe I should use a dedicated request thread and queue things up inside the wrapper?
16:35:09 <askaza> hello, what is a kleisli arrow good for?
16:35:50 <quchen> putStrLn -- is a Kleisli arrow, it's good for printing things.
16:36:17 <benzrf> askaza: a kleisli arrow is good for turning an a into an m b
16:37:04 * hackagebot haroonga 0.1.3.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.3.0 (cosmo0920)
16:37:13 <quchen> Kleisli arrows in Haskell are functions of type "a -> m b", where m is an instance of Monad. That's it.
16:37:28 <quchen> Kleisli arrows are "good for" the same things ordinary functions are "good for".
16:37:32 <quchen> They do stuff.
16:37:57 <Tjr> Kleisli is pretty much a code word for monad. Nothing new to see here.
16:38:36 <systemfault> So, it only exists to make haskell more difficult to understand :P
16:39:04 <Tjr> systematik: "I don't want to explain it well, so clearly you must be stupid"
16:39:33 <quchen> Tjr: That tab completion went wrong, I think.
16:39:47 <Tjr> woops, sorry.
16:39:50 <Tjr> systematik: ^^
16:40:55 <Tjr> Assume I do "import qualified Control.RMonad as RM", and get RM.(>>=).
16:41:33 <quchen> (The syntax is (RM.>>=))
16:41:41 <Tjr> will my module be able to get rid of the RM. prefix on export, i.e. export my instance of  RM.>>= as >>= ?
16:41:54 <Tjr> quchen: thanks
16:42:19 <lfairy> shlevy: what's the library?
16:42:33 <mm_freak> Tjr: sometimes this type may be useful:  newtype Coll a = Coll { enumerate :: forall r. (Monoid r) -> (a -> r) -> r }
16:42:42 <mm_freak> Tjr: it's a monad
16:42:51 <mm_freak> toSet :: (Ord a) => Coll a -> Set a
16:43:23 <mm_freak> Tjr: RMonad is a nice idea, but integration is horribly expensive
16:43:23 <quchen> Is that some sort of CPS set?
16:43:38 <mm_freak> quchen: well, i wouldn't call it CPS
16:43:49 <quchen> Well something continuation-y then
16:44:10 <mm_freak> the idea is:  it's a function…  you pass it an enumerator and tell it that the result type is a monoid
16:44:10 <Tjr> CPS = child prot.... err, continuation passing style
16:44:13 <mm_freak> then it enumerates
16:44:36 <mm_freak> quchen: it's really not "continuation" in the literal sense…  it's "enumeration"
16:44:44 <benzrf> @rember Tjr CPS = child prot.... err, continuation passing style
16:44:44 <lambdabot> It is stored.
16:44:47 <mm_freak> in the same sense you wouldn't call map's argument a continuation
16:44:48 <shlevy> lfairy: libnixstore
16:44:57 <quchen> Ah, I see. It's an abstract set that hasn't been mapped to a monoid yet.
16:45:07 <quchen> Maybe closer to Store than to Cont, then.
16:45:08 <mm_freak> yeah…  a delayed collection
16:45:16 <mm_freak> indeed
16:45:23 <mm_freak> Coll is to Set what (->) is to Array
16:46:28 <mm_freak> you can get functor interface for many things that aren't functors by themselves by using this delaying trick
16:46:44 <mm_freak> repa does that, too, except in an awkward non-functor way =)
16:46:50 <quchen> Oh, Coll is not only a monad, but also a Monad?
16:46:55 <mm_freak> yes
16:47:24 <Tjr> I don't quite understand Coll.
16:47:28 <mm_freak> http://lpaste.net/102350
16:47:49 <jle`> is there any nice way to apply an (a -> b -> IO c) to an (IO a) and an (IO b) ?
16:47:52 <Tjr> what does enumeration have to do with monoid laws?
16:48:21 <jle`> i could do join (f <$> x <*> y) but that's a little silly
16:48:22 <mm_freak> jle`: join (liftM2 f c d)
16:48:37 <quchen> mm_freak: How much of that did you, how much did the typechecker write? :-x
16:49:09 <jle`> hm i can work with that.  i think i might just do it out doblock style actually
16:49:15 <mm_freak> Tjr: monoids capture enumeration, and you need it to write (>>=) and (<*>)
16:49:29 <mm_freak> quchen: all of it myself =)
16:49:43 <mm_freak> quchen: the types are easy enough to work out there
16:49:58 <benzrf> 07:43 < mm_freak> Coll is to Set what (->) is to Array
16:49:59 <quchen> Uhhmm okay, I guess we're on quite different levels then
16:50:03 <benzrf> i dont understand this
16:50:13 <mm_freak> benzrf: take unboxed vectors
16:50:28 <mm_freak> benzrf: Vu.map :: (Unbox a) => (a -> b) -> Vector a -> Vector b
16:50:35 <mm_freak> not a functor, because of the Unbox constraint
16:50:36 <benzrf> ok
16:50:41 <benzrf> i dont know what unbox is
16:50:48 * Tjr is still studying mm's lpaste
16:50:51 <benzrf> oh is that just that the type is unboxed
16:50:56 <mm_freak> yeah
16:50:59 <mm_freak> Int, Word, Char, etc.
16:51:06 <benzrf> lame!
16:51:10 <benzrf> mm_freak: you mean Int#
16:51:19 <mm_freak> not unboxed, but "unboxable"
16:51:28 <quchen> It's a typeclass and it's completely irrelevant to the point what it's good for.
16:51:33 <mm_freak> something that can have a compact memory representation
16:51:38 <mm_freak> compact and uniform, that is
16:51:40 <benzrf> @letlpaste 102350
16:51:42 <lambdabot>  Defined.
16:51:42 <mm_freak> i.e. not lists and not Integer
16:51:44 <benzrf> cool
16:51:53 <benzrf> wait what
16:51:55 <benzrf> > 3
16:51:57 <lambdabot>  3
16:52:04 <benzrf> it let a module def through?!
16:52:09 <benzrf> wat
16:52:15 <benzrf> :t main
16:52:16 <lambdabot> IO ()
16:52:18 <benzrf> o.o
16:52:35 <mm_freak> anyway, to get rid of that constraint notice how functions are just arrays, possibly infinitely long and possibly infinitely dense
16:52:49 <mm_freak> type MyVec a = Int -> a
16:53:00 <mm_freak> now you have a monad
16:53:05 <mm_freak> the reader monad over Int
16:53:09 <benzrf> do you mean arrays are functions?
16:53:15 <mm_freak> yes
16:53:17 <benzrf> kk
16:53:52 <Tjr> mm_freak: what's this forall keyword in your lpaste? The wiki link leads to /existential/ data types, but "exists" and "for all" are very different quantors.
16:53:52 <mm_freak> but arrays have some interesting features:  they don't occupy memory, can be dense, infinite and can even be faster than arrays
16:53:53 <nexion> what's a clean way to divide two Integers and return a Double?
16:54:02 <mm_freak> Tjr: it's a rank-2 type
16:54:14 <mm_freak> Tjr: you need the RankNTypes extension
16:54:17 <Tjr> a rank n type is a type with quantors in it
16:54:19 <benzrf> Tjr: forall used in the right way can act like exists
16:54:28 <mm_freak> Tjr: with rank-2 quantors
16:54:33 <Tjr> however, why would you want to mangle "forall" and "there exists" quantors?
16:54:40 <mm_freak> i.e. quantors in arguments
16:54:48 <Qfwfq> Tjr: The Haskell Wikibook explains this well, wherever that is.
16:54:49 <quchen> nexion: Converting them both to Double first would be the easiest solution.
16:54:54 <mm_freak> Tjr: it is not existential, it is indeed universal
16:55:15 <Tjr> http://www.haskell.org/haskellwiki/Keywords#forall
16:55:29 <mm_freak> Tjr: a value of type Coll a is a function of type '(a -> r) -> r', and it promises to work for every type r, as long as it's a monoid
16:55:31 <nexion> quchen: ty
16:55:33 <mm_freak> hence "for all"
16:55:57 <Tjr> this claims that "forall a. a-> (a-> Bool)" is a quantor of existance, i.e. it claimes there exists at leaste one a, which doesn't make sense
16:56:20 <askaza> ok thanks
16:56:38 <Tjr> how would the compiler know which a to take, if all you know is there exists at least one nondescript a
16:57:14 <mm_freak> Tjr: data Foo = forall a. MkFoo a (a -> Bool)
16:57:16 <matematikaadit> @letlpaste 106999
16:57:16 <lambdabot>  Parse failed: TypeFamilies is not enabled
16:57:18 <mm_freak> Tjr: this is an actual existential
16:57:19 <Tjr> why can't you simply write
16:57:23 <Tjr>  runColl ::  (Monoid r) => (a -> r) -> r
16:57:25 <mm_freak> Tjr: but what i wrote is different
16:57:45 <mm_freak> existential:  data Blah = forall a. Blah …
16:57:53 <mm_freak> universal:  data Blah = Blah (forall a. …)
16:58:41 <mm_freak> Tjr: here is a different way to look at it:
16:58:55 <mm_freak> toSet :: (forall r. (Monoid r) => (a -> r) -> r) -> Set a
16:59:13 <Tjr> I'd say the terms existential and universal are swapped, compared to their meaning in maths
16:59:20 <benzrf> hmmmmmmmm
16:59:20 <benzrf> wouldnt a function-as-a-set be like
16:59:20 <benzrf> uh
16:59:20 <benzrf> a -> Bool?
16:59:21 <mm_freak> pass it a function that works for every monoid r, then you get a Set back
16:59:44 <mm_freak> benzrf: depends on what you want to do, but yes, that would be an encoding of (sub-) sets
17:00:03 <benzrf> no, that doesnt cover all cases
17:00:04 <mm_freak> Tjr: no, they are not…  the only difference is that we represent existentials in terms of universals
17:00:28 <mm_freak> benzrf: it covers the case of computable sets
17:00:54 <mm_freak> which is pretty much all sets you will run across in computing =)
17:01:09 <benzrf> hmmmmm
17:01:15 <mm_freak> but it may be an inefficient encoding depending on your application
17:01:19 <benzrf> > True <> False
17:01:21 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
17:01:21 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
17:01:27 <benzrf> > Any True <> Any False
17:01:28 <lambdabot>  Any {getAny = True}
17:01:34 <Tjr> so why can't you write " runColl ::  (Monoid r) => (a -> r) -> r"?
17:01:38 <benzrf> mm_freak: includes :-O
17:01:43 <benzrf> *inclusion
17:01:56 <mm_freak> Tjr: because then r is free, so the compiler will complain
17:02:41 <mm_freak> Tjr: the type variables must be bound either by type arguments or by quantification
17:02:53 <Tjr> isn't every free variable bound by an implicit forall?
17:02:57 <mm_freak> no
17:03:02 <mm_freak> only in type signatures
17:03:24 <Tjr> e.g. "head :: [a] -> a" should work for any type a, therefore it's "head:: forall a. [a] -> a"
17:03:38 <mm_freak> try this:  type Id = a -> a
17:03:40 <mm_freak> not in scope: a
17:03:53 <Tjr> better yet  "forall a: head::  [a] -> a"
17:04:10 <mm_freak> either bind as argument:  type Endo a = a -> a
17:04:16 <mm_freak> or quantify:  type Id = forall a. a -> a
17:04:23 <benzrf> :t Coll
17:04:24 <lambdabot> (forall r. Monoid r => (a -> r) -> r) -> Coll a
17:04:46 <benzrf> :t foldmap
17:04:47 <lambdabot>     Not in scope: ‘foldmap’
17:04:47 <lambdabot>     Perhaps you meant one of these:
17:04:47 <lambdabot>       ‘foldMap’ (imported from Data.Foldable),
17:04:49 <benzrf> :t foldMap
17:04:50 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
17:04:58 <mm_freak> Tjr: and notice that Id and Endo are not the same thing…  you can represent Id in terms of Endo, but not vice versa
17:05:02 <mm_freak> succ :: Endo Int
17:05:06 <mm_freak> id :: Id
17:05:11 <benzrf> @let nats = Coll . foldMap ?? [1..]
17:05:11 <lambdabot>  Parse failed: Ambiguous infix expression
17:05:13 <benzrf> dang
17:05:19 <Tjr> what's Endo?
17:05:24 <mm_freak> Tjr: i defined it above
17:05:27 <mm_freak> type Endo a = a -> a
17:05:29 <benzrf> @let nats = Coll . flip foldMap [1..]
17:05:29 <lambdabot>  .L.hs:183:8:
17:05:30 <lambdabot>      Couldn't match type ‘b’ with ‘forall r. Monoid r => (a -> r) -> r’
17:05:30 <lambdabot>        ‘b’ is a rigid type variable bound by
17:05:30 <lambdabot>            the inferred type of nats :: (a1 -> b) -> Coll a at .L.hs:183:1
17:05:30 <lambdabot>      Expected type: b -> Coll a
17:05:35 <benzrf> bwah
17:05:56 <benzrf> ;t flip foldMap [1..]
17:06:06 <benzrf> :t flip foldMap [1..]
17:06:07 <lambdabot> (Monoid c, Num a, Enum a) => (a -> c) -> c
17:06:10 <benzrf> oh
17:06:17 <mm_freak> Tjr: an endo-function is a function from a type to itself, like Int -> Int
17:06:26 <benzrf> @let nats = Coll . flip foldMap ([1..] :: [Int])
17:06:27 <lambdabot>  .L.hs:183:8:
17:06:27 <lambdabot>      Couldn't match type ‘b’ with ‘forall r. Monoid r => (a -> r) -> r’
17:06:27 <lambdabot>        ‘b’ is a rigid type variable bound by
17:06:27 <lambdabot>            the inferred type of nats :: (Int -> b) -> Coll a at .L.hs:183:1
17:06:27 <lambdabot>      Expected type: b -> Coll a
17:06:30 <benzrf> aw
17:06:56 <benzrf> @let nats = Coll . (flip foldMap ([1..] :: [Int]) :: (forall r. Monoid r => (Int -> r) -> r))
17:06:57 <lambdabot>  .L.hs:184:5:
17:06:57 <lambdabot>      Couldn't match type ‘b’ with ‘forall r. Monoid r => (a -> r) -> r’
17:06:57 <lambdabot>        ‘b’ is a rigid type variable bound by
17:06:57 <lambdabot>            the inferred type of nats :: (Int -> b) -> Coll a at .L.hs:183:1
17:06:57 <lambdabot>      Expected type: b -> Coll a
17:06:59 <Tjr> I know the usage of endo-foo from maths.
17:07:02 <benzrf> what's wrong here
17:07:24 <Tjr> however, haskell seems to use quantifiers in a completely different way
17:07:34 <benzrf> :t flip foldMap ([1..] :: [Int])
17:07:35 <lambdabot> Monoid c => (Int -> c) -> c
17:07:46 <mm_freak> Tjr: no, it doesn't…  it uses them in exactly the same way as type theory
17:07:48 <benzrf> how is this not unifiable with (forall r. Monoid r => (Int -> r) -> r)
17:07:49 <benzrf> :\
17:08:03 <Tjr> in maths, if I write "f :: X -> Y, f(x) = y", then it stands for "forall x : f (x) = y"
17:08:16 <benzrf> oh wait crud im doing it all wrong
17:08:23 <Tjr> however, this forall is a universal quantifier, not an existential quantifier.
17:08:25 <benzrf> @let nats = Coll (flip foldMap ([1..] :: [Int]))
17:08:26 <lambdabot>  Defined.
17:08:30 <benzrf> there we go >.>
17:08:57 <mm_freak> Tjr: this is not what you write in haskell…  take the identity function
17:09:03 <Tjr> benzrf: I'm not sure if you're trying to show me something, but it's too fast for me to understand.
17:09:04 <mm_freak> id :: forall a. a -> a
17:09:20 <benzrf> :t S.synonym
17:09:21 <lambdabot> Not in scope: ‘S.synonym’
17:09:24 <benzrf> Tjr: no, im experimenting
17:09:24 <mm_freak> Tjr: this is a proposition:  for all a, a follows from a
17:09:26 <benzrf> ::p
17:09:27 <Tjr> why would you call that usage of "forall" existential?
17:09:32 <mm_freak> Tjr: and here is the proof:  id x = x
17:09:39 <mm_freak> Tjr: i never did that
17:09:40 <benzrf> :t Data.Set.singleton
17:09:41 <lambdabot> a -> Set a
17:09:43 <Tjr> the wiki does
17:09:46 <benzrf> oh
17:10:08 <benzrf> > runColl nats (Any . (==3))
17:10:09 <lambdabot>  Any {getAny = True}
17:10:11 <mm_freak> Tjr: it is a constructor that works for all types…  a universal constructor constructs existential values
17:10:20 <benzrf> laziness ftw
17:11:10 <Tjr> what's an existential value?
17:11:33 <mm_freak> Tjr: put differently:  if construction is universal, then pattern-matching is existential
17:11:33 <Tjr> I know how quantors work on true-false-valued expressions, but not on any other kind of value
17:12:01 <mm_freak> Tjr: MkFoo :: forall a. a -> (a -> Bool) -> Foo
17:12:27 <mm_freak> then:  unFoo :: MkFoo -> (∃ a. (a, a -> Bool))
17:12:44 <mm_freak> that's why you see a forall there, and not an exists
17:12:54 <mm_freak> uhm
17:12:59 <mm_freak> then:  unFoo :: Foo -> (∃ a. (a, a -> Bool))
17:13:26 <Tjr> you mean "not Foo", as in logical negation=
17:13:27 <Tjr> ?
17:13:40 <mm_freak> unFoo, not "not Foo"
17:13:46 <benzrf> @let data Foo = forall a. MkFoo a (a -> Bool)
17:13:47 <lambdabot>  Defined.
17:13:49 <benzrf> :t MkFoo
17:13:50 <lambdabot> a -> (a -> Bool) -> Foo
17:13:51 <mm_freak> not sure where you got the "not" from
17:13:59 <benzrf> :t \(MkFoo a af) -> (a, af)
17:14:00 <lambdabot>     Couldn't match expected type ‘t’ with actual type ‘(a, a -> Bool)’
17:14:00 <lambdabot>       because type variable ‘a’ would escape its scope
17:14:00 <lambdabot>     This (rigid, skolem) type variable is bound by
17:14:09 <Tjr> not is the only thing that swaps existance and forall
17:14:16 <benzrf> skolem?!
17:14:26 <mm_freak> Tjr: i'm not swapping anything at all
17:14:34 <mm_freak> forall and exists are dual to each other
17:15:14 <Tjr> maybe I'm completely dense.
17:15:23 <Tjr> Can you given an example from linear algebra?
17:15:28 <benzrf> :t \(MkFoo a af) -> af a
17:15:29 <lambdabot> Foo -> Bool
17:15:32 <Tjr> what foo and unfoo should be?
17:15:35 <benzrf> hmm
17:15:55 <mm_freak> Tjr: are you familiar with type theory?
17:15:56 <Tjr> (or an example form functional analysis, in case banach space duality is better suited)
17:15:59 <Tjr> no
17:16:07 <quchen> benzrf: May I suggest a private Lambdabot session for the testing? There's an interesting discussion going on between all those Lambdabot (error) lines.
17:16:16 <benzrf> sorry, :[
17:16:19 <mm_freak> Tjr: type theory is an alternative foundation to set theory…  this all comes from there
17:16:31 <benzrf> got carried away =.=
17:16:33 <Tjr> I know set theory, in the zermel-frankel sense
17:16:34 <benzrf> mm_freak: wait, realluZ?
17:16:36 <benzrf> &really
17:17:05 <mm_freak> Tjr: yeah, exactly…  and understanding type theory will help you draw the bridge between this, propositions and proofs
17:17:29 <mm_freak> Tjr: as a simple example the identity function proves that for all A, A follows from A
17:17:33 <mm_freak> id :: forall a. a -> a
17:17:40 <mm_freak> proof:  id x = x
17:17:42 <Tjr> hold on
17:17:47 <Tjr> a function proves nothing
17:17:51 <Tjr> it's just a triple
17:17:55 <Tjr> id : A -> B
17:18:05 <mm_freak> it does in type theory…  this is precisely the curry howard isomorphism
17:18:13 <kazagistar> Tjr: a function proves that if given its input, you can construct its output
17:18:14 <Tjr> is really id = (A,B,g) where g \subsetof A \tiems B
17:18:33 <mm_freak> Tjr: different example:  construct a total function with the following type:  forall a b. a -> b
17:18:35 <Tjr> essentially, g is the graph
17:18:50 <mm_freak> this is an absurd statement:  it is not the case that for all A and B, B follows from A
17:18:58 <mm_freak> and there is indeed no such (total!) function
17:19:31 <Tjr> it seemed very odd
17:20:23 <Tjr> or even impossbile (where I'm still using the defintion of a function as a triple of domain, realm, and graph)
17:21:01 <mm_freak> Tjr: that notion of function is too strong, because you can't represent quantification
17:21:20 <mm_freak> think of functions as lambdas in lambda calculus, a purely syntactic formalism
17:22:22 <Tjr> to me, lambda calculus is "whatever haskell would be on an infinite turing machine"
17:23:12 <mm_freak> Tjr: type theory extends lambda calculus to a fully fledged mathematical foundation with machine-checkable proofs
17:23:39 <mm_freak> Tjr: it's the underlying mathematical foundation of most modern proof assistants, which you use to prove theorems
17:23:53 <kazagistar> "given an input, I can follow these steps to give an output"
17:23:53 <kazagistar> "given these assumptions are true, I can use these theorems to build the truth of this theorem"
17:24:26 <mm_freak> Tjr: for example a few months ago a proved that set union and intersection together form two semirings, here is the code:  http://lpaste.net/101411
17:24:59 <mm_freak> (this is agda code)
17:25:06 <Tjr> [off-topic] During a committee meeting, I once suggested looking at automatic theorem provers to help reduce the workload of checking undergraduate maths students' homework. As it turns out, nobody uses those checkers because they are way too much work and encourage bad style.
17:25:46 <ctangent> ^ that agda link is way cool.
17:26:07 <mm_freak> Tjr: it /is/ too much work, but i disagree with the latter
17:26:39 <Tjr> symmetric difference as addition, and intersection as multiplication, will turn the power set into a ring. Is that what the agda code does?
17:26:56 * Tjr can't read agda.
17:27:03 * Tjr feels stupid.
17:27:04 <mm_freak> not a ring, but a semiring, and yes
17:27:36 <mm_freak> _≡_ is set equivalence…  following proves that it's indeed an equivalence relation
17:27:43 <Tjr> what do you call semiring?
17:27:51 <kazagistar> Tjr: Idris is slightly easier to read from a Haskell standpoint I think
17:28:13 <mm_freak> Tjr: ring sans additive inverse
17:28:24 <Welkin> that agda code looks more confusing as haskell did when I first started learning it
17:28:51 <Tjr> if you use symmetric difference, you get an actual inverse :-P
17:29:32 <mm_freak> Tjr: not sure what you mean by symmetric difference
17:30:14 <Tjr> symmetricdifference (A,B) = (A \\ B ) \cup (B \\ A)
17:31:10 <mm_freak> ah
17:31:44 <mm_freak> well, yeah, if you use integers you get a group, but if the problem specifies natural numbers…  you know…  the real world ;)
17:32:10 <Tjr> ;-)
17:34:28 <mm_freak> unfortunately it's not all gold…  i have yet to see a type theory representation of real numbers that i would agree to work with =)
17:34:48 <Tjr> do I need to read the agda code? It would take quite some time for me.
17:34:58 <mm_freak> you don't
17:35:08 <Tjr> back to the Foo and unFoo.
17:35:14 <mm_freak> Tjr: the types are most interesting, the terms are just proofs
17:35:42 <mm_freak> anyway, there is an alternative existential syntax in haskell that more clearly shows why 'forall' is used
17:35:58 <mm_freak> data Foo where MkFoo :: a -> (a -> Bool) -> Foo
17:36:03 <mm_freak> that's GADT syntax
17:36:30 <mm_freak> it clearly shows that MkFoo is universal in 'a', and thus pattern-matching on MkFoo must be existential
17:36:45 <mm_freak> s/on MkFoo/Foo/
17:37:28 <Tjr> pattern matching on Foo should give you a concrete instance of a. If that's what you mean by existential, then I concur.
17:37:52 <mm_freak> yeah
17:38:05 <quchen> mm_freak: Where does this "matching universal is existential" come from? I've never heard of it this way
17:38:27 <mm_freak> or put differently:  the Foo value itself selects the type, so when pattern matching you don't have control over which type you get
17:38:39 <mm_freak> quchen: type theory
17:38:43 <Tjr> I'd say the act of matching makes a existential, but a is still universal in the definition of Foo.
17:39:26 <quchen> mm_freak: Which part? :-)
17:39:35 <mm_freak> quchen: all of it =)
17:39:48 <quchen> Well that's not very helpful.
17:39:52 <mm_freak> Tjr: "existential" can be represented in terms of a sum type
17:40:06 <mm_freak> a tuple containing a type and a value of that type
17:40:07 <quchen> Does pattern matching correspond to a certain logical statement via CH?
17:40:11 <quchen> Something I might be familiar with?
17:40:16 <Tjr> "sum" is where I always got stuck
17:40:36 <Tjr> To me, the examples provided were always a (disjoint) set union, not a sum
17:40:38 <mm_freak> quchen: translate ADTs to church encoding, then pattern matching is just function application
17:40:51 <mm_freak> quchen: type theory itself doesn't have a notion of ADTs
17:40:55 <monochrom> pattern matching corresponds by CH to elimination rules in natural deduction. see my http://www.vex.net/~trebla/haskell/crossroad.xhtml
17:41:26 <mm_freak> Tjr: disjoint unions are sums
17:41:51 <mm_freak> Tjr: you can read "Either A B" as "A + B"
17:42:32 <Maxdamantus> |Either A B| = |A| + |B|
17:42:32 <Tjr> yeah, kind of curious notation. I noticed that in a few papers already
17:42:44 <Tjr> what are those absolute value signs?
17:42:55 <mm_freak> Tjr: if this confuses you, just think of the number of elements of that type
17:42:57 <Maxdamantus> Size of signs.
17:42:59 <mm_freak> Tjr: what Maxdamantus said
17:43:00 <gfixler> does Haskell have something for modeling value superpositions?
17:43:07 <Maxdamantus> |(A, B)| = |A|*|B|
17:43:26 <Tjr> if A and B have a nontrivial overlap, then you get |Either A B| < |A| + |B|
17:43:35 <Tjr> overlap == set intersection
17:43:45 <Maxdamantus> No, because Either values are tagged.
17:43:49 <mm_freak> Tjr: /disjoint/ unions…  there is a tag that tells them apart
17:43:51 <Maxdamantus> Left 4 is distinct from Right 4.
17:43:52 <mm_freak> Left and Right
17:43:58 <gfixler> i.e. foo could be a 2 or a 7, and we'll need to check both eventually, but for now let it just be the possibility of 2 or 7
17:44:26 <mm_freak> gfixler: not sure what you're asking
17:44:40 <gfixler> I think it's like Either, which I haven't used yet
17:44:41 <kazagistar> |Maybe A| = |A| + 1
17:44:58 <gfixler> e.g. so I could add up values that have multiple possible values
17:45:05 <monochrom> but Either is not value superposition. maybe type superposition
17:45:07 <gfixler> foo + bar, where foo can be a 2 or a 7, and bar is a 5
17:45:09 <mm_freak> kazagistar: that's a type error
17:45:17 <mm_freak> Maybe A = A + 1
17:45:34 <gfixler> yields two possible outcomes, 7 or 12
17:45:37 <Tjr> why 1
17:45:42 <mm_freak> Tjr: 1 = ()
17:45:46 <mm_freak> the type
17:45:54 <Tjr> wouldn't you say Maybe A = A + Nothing?
17:46:10 <mm_freak> Tjr: Nothing is not a type
17:46:20 <gfixler> it's sort of like permutations, I suppose
17:46:27 <mm_freak> Tjr: think of it this way:  Maybe ≃ Either ()
17:46:39 <mm_freak> Either () A = () + A = 1 + A
17:46:41 <gfixler> I was just thinking that Haskell seemed the kind of thing that would allow working abstractly with values that might be one of a number of possible values
17:46:47 <Maxdamantus> In Scala, `Nothing` is some bottom type, which has no values.
17:46:57 <Maxdamantus> I think.
17:47:04 <mm_freak> Tjr: and read "=" as "isomorphic to"
17:47:08 * Maxdamantus hasn't actually used Scala, other than its REPL.
17:47:27 <quchen> ≅   <- quchen's paste service
17:47:27 <Tjr> yes, the "isomorphic" is pretty important to somebody firmly rooted in set theory :-)
17:47:29 <mm_freak> gfixler: it seems wrong to use numbers there, and i still don't understand what you need
17:48:18 <gfixler> Haskell already has dual-possibility things, like Maybe and Either, to allow working without worrying about alternate states of things
17:48:18 <Tjr> I think gfixler was helpfully trying to explain the Either monad.
17:48:33 <Tjr> In any case,
17:48:53 <mm_freak> i think gfixler is asking something, and i'm trying to work out what =)
17:49:03 <gfixler> :)
17:49:17 <gfixler> If I want the value 37 from some foo + bar + baz, it could give me the results that would make that up, from the possibilities therein
17:49:26 <gfixler> collapse the waveform, if you will
17:49:34 <snyp> How can I have a single sandbox for multiple projects? symlink to cabal.sandbox.config?
17:49:40 <gfixler> foo + bar + baz could be 37 is we let foo be its 7, bar be its 12, etc
17:49:41 <benzrf> my compose key doesnt support ~= OR =~ for isomorphic
17:49:41 * benzrf weeps
17:49:45 <mm_freak> gfixler: sounds like you want to construct a list and take its first value
17:50:04 <snyp> (yes i come again with cabal questions)
17:50:12 <mm_freak> > [ (x,y) | x <- [0..99], y <- [0..99], x^2 + y^2 == 5 ]
17:50:14 <lambdabot>  [(1,2),(2,1)]
17:50:18 <mm_freak> gfixler: something like that?
17:50:42 <gfixler> mm_freak, maybe
17:50:45 <Tjr> mm_freak: so you've constructed an addtion (as disjointly-tagged set union) and an absolute value  on the "set" of all types.
17:51:20 <snyp> Anyone?
17:51:48 <Tjr> mm_freak: you've also generalized the definition of functions, which aren't triples of domain, image, graph, to something vague-but-useful involving quantors.
17:52:06 <mm_freak> Tjr: i haven't constructed an absolute value
17:52:15 <mm_freak> that's just a useful mental helper
17:52:43 <Tjr> I meant things like |(A, B)| = |A|*|B|
17:53:05 <mm_freak> yeah, something like that certainly exists, but i haven't constructed it here
17:53:15 <mm_freak> well, actually i'm not even sure whether it exists
17:53:18 <kazagistar> Tjr: type theory foundations do not start with axiomatic sets for a variety of reasons
17:53:49 <Tjr> kazagistar: I'm ignoring the difference between sets and classes for now, since anythign that fits into a computer is countable and therefore a set.
17:54:04 <monochrom> try to ignore set, too
17:54:34 <monochrom> afterall, set is as vague as function
17:55:10 <Tjr> monochrom: set feels well-defined to me because I've spend a decade using it.
17:55:21 <mm_freak> type theory has its own notion of sets, btw:  the agda standard library calls them Preds (as in predicates)
17:55:36 <kazagistar> is ([Int] -> [Int]) countable?
17:56:07 <dmwit> [Int] isn't even countable
17:56:12 <Tjr> kazagistar: it's still small enough to be a set, and if you insist on something computable, it's countable.
17:56:14 <dmwit> Or it's computable, depending how you define it. ;-)
17:56:16 <Maxdamantus> [Int] is countable.
17:56:25 <dmwit> [Int] is as good as Real. So not countable.
17:56:27 <Cale> Maxdamantus: [Bool] isn't countable
17:56:37 <monochrom> what is [Int] -> [Int]? I am serious.
17:56:38 <Maxdamantus> Of course it is.
17:56:42 <Tjr> mm_freak: Then you observed a duality between "construct a data type operation", which maps {strings of code} to {possible data types}, and the pattern matching operation, which goes fhe other way.
17:56:43 <Welkin> is a Char countable?
17:57:01 <dmwit> monochrom++
17:57:02 <snyp> Can I have a common sandbox for multiple projects like python's virtualenv?
17:57:04 <Cale> Maxdamantus: Infinite lists of booleans are essentially the same thing as real numbers
17:57:09 <Maxdamantus> Prelude Data.Count> take 10 $ allValues :: [[Bool]]
17:57:09 <Maxdamantus> [[],[False],[True],[False,False],[True,False],[False,True],[True,True],[False,False,False],[True,False,False],[False,True,False]]
17:57:14 <Tjr> mm_freak: this duality flips existential and universal quantors.
17:57:26 <dmwit> snyp: There are virtualhenv and hsenv packages. Dunno how well they work.
17:57:29 <Maxdamantus> Cale: oh, including infinite lists.
17:57:30 <Cale> Maxdamantus: You won't get any infinite lists that way, so it's not a complete enumeration.
17:57:30 <dmwit> snyp: They predate cabal sandboxes.
17:57:43 <snyp> i see.
17:57:51 <snyp> symlinking does not work..
17:57:54 <mm_freak> is the set of computable reals countable?
17:58:11 <snyp> cabal.sandbox.config -> common-sandbox/cabal.sandbox.config
17:58:23 <Cale> mm_freak: You can enumerate the programs which compute them, so yeah.
17:58:26 <snyp> .cabal-sandbox -> common-sandbox/.cabal-sandbox
17:58:29 <mm_freak> but even then ℕ^ℕ alone is uncountable
17:58:55 <mm_freak> Cale: then i'd say that in type theory [ℤ] is countable
17:58:59 <Maxdamantus> Though they should still be countable in Haskell.
17:59:03 <mm_freak> but [ℤ] → [ℤ] is not
17:59:18 <Maxdamantus> Since any realisable infinite list of bools has a program to generate them.
17:59:27 <Cale> mm_freak: Is that the type of finite lists?
17:59:38 <Cale> mm_freak: Or possibly infinite ones?
17:59:38 <kazagistar> yeah, I thought function was exponent
17:59:42 <mm_freak> Cale: in haskell it correponds to Colist
18:00:13 <Cale> Then I disagree, it's clearly uncountable.
18:00:21 <mm_freak> hmm
18:00:35 <mm_freak> true
18:00:40 <sipa> a^b is the set of functions from b to a
18:03:29 <kazagistar> why is [ℤ] not countable? in haskell, list is constrained by the fact that it must be constructed by a haskell program, which is countable, right?
18:03:58 <mm_freak> Tjr: anyway, it's not really flipping, but more the idea that "existentials are just tuples"
18:04:19 <mm_freak> Tjr: those tuples are a certain subset of the so-called dependent sums
18:04:23 <Tjr> kazagistar: because [\Z] refers to all \Z-valued lists, not just the computable ones.
18:04:44 <snyp> cabal sandbox init --sandbox ../.cabal-sandbox ... hmmmmmmmmmmmm
18:04:48 <mm_freak> kazagistar: you're thinking of individual programs, not the set of all programs
18:05:27 <Maxdamantus> Does the set of all programs include infinite programs?
18:05:40 <kazagistar> [\Z] in the haskell type signature is constrained to only apply to things that are built using the (:) type constructor
18:05:52 <Tjr> Maxdamantus: by convention, no
18:05:52 <monochrom> the set of all programs is still countable
18:06:10 <kazagistar> which is constrained to take types of kind Hask
18:06:16 <mm_freak> kazagistar: take a "smaller" type: [Bool]…  if [] = Colist, then this is isomorphic to an interval of your choice of the real numbers
18:06:53 <Tjr> Maxdamantus: any reasonable program would terminate after some finite time. In that time, it can read only a finite portion of the source code. Therefore it makes sense to demand that only finite programs are called programs.
18:07:58 <Maxdamantus> Tjr: you can easily model programs in Haskell that can be infinite.
18:08:11 <Maxdamantus> which are still useful.
18:08:49 <kazagistar> Tjr: right, but the program modeling the program is isomorphic to the program you are modeling, and is finite, right?
18:08:57 <Maxdamantus> The question was of Haskell programs.
18:09:11 <Maxdamantus> or something.
18:09:12 <monochrom> there are countably many Haskell programs, clearly.
18:09:15 <kazagistar> er, I meant that to Max
18:09:22 <pyon> You mean, programs that compute infinite objects?
18:09:25 <monochrom> each Haskell program has finite length, too. clearly.
18:10:03 <ninja_code> when writing haskell code, when i define functions, is the fundamentall question should be: what is the most important order for currying ?
18:10:10 <Maxdamantus> Is it clear because a Haskell compiler won't compile infinite programs?
18:10:20 <Maxdamantus> or because it's specified somewhere?
18:10:29 <monochrom> no, it is clear because Haskell 2010 requires it.
18:10:29 <mm_freak> ninja_code: if the function "map", put the thing that you map last
18:10:38 <mm_freak> ninja_code: blur :: Radius -> Picture -> Picture
18:10:51 <mm_freak> s/"map"/"maps"/
18:10:56 <monochrom> every CFG specifies a countable language of finite-length strings
18:11:23 <Tjr> mm_freak: the idea that "existentials are just tuples" -- let me guess what that means. The tuple contains the subexpression below the quantor, and an oracular value to tell the compiler which value of a satisfies the quantor. Right?
18:12:01 <Tjr> satisfies the universal quantor
18:12:10 <monochrom> there are, also, countably many Turing machines (each a finite relation) and countably many lambda terms (each a finite-length string)
18:12:15 <mm_freak> Tjr: there is no haskell construct that correponds to this…  a dependent sum is a tuple, where the type of the second component depends on the value of the first
18:12:36 <Tjr> ok, I'll accept that
18:12:47 <Tjr> and try to work witht hat
18:12:48 <mm_freak> Tjr: in this particular case the first component is a type, the second component is a value of that type
18:12:52 <monochrom> it is very unlikely that anyone intended Haskell to exceed Turing machines
18:13:12 <Maxdamantus> monochrom: do CFGs necessarily not specify languages of infinite-length strings?
18:13:21 <monochrom> correct
18:13:33 <Maxdamantus> S ::= 'a' S
18:13:55 <Maxdamantus> That would specify a countable language (the empty language) of finite-length strings.
18:14:01 <Tjr> Tying back to  runColl :: forall r. (Monoid r) => (a -> r) -> r --- where would the r gets its value from?
18:14:07 <monochrom> yes, it does
18:14:19 <mm_freak> Tjr: from the user of runColl
18:14:21 <Maxdamantus> But it also specifies a countable (singleton) language of infinite-length strings.
18:14:26 <mm_freak> Tjr: in this case toSet
18:14:46 <monochrom> that is outside the definition of CFL
18:15:01 <mm_freak> Tjr: since runColl promises to work for every monoid r, toSet selects r = Set a
18:15:14 <Maxdamantus> Okay, but it seems weird to say it's outside the definition of CFG.
18:15:19 <Maxdamantus> Dunno.
18:15:27 <monochrom> CFG is there solely for CFL
18:16:00 <Maxdamantus> under the interpretation where you're looking for finite strings.
18:16:03 <Tjr> which binary operation makes Set into a monoid here?
18:16:11 <mm_freak> Tjr: union
18:16:13 <monochrom> there is an implicit clause not usually highlighted, but it is there: "the smallest set of strings that satisfies the grammar"
18:16:27 <Maxdamantus> You can still say that "the set of finite strings matched by a CFG is a CFL", etc
18:16:56 <monochrom> equivalently: "every string must be generated by finitely many steps"
18:19:03 <Tjr>     fmap f (Coll g) = Coll (\k -> g (k . f))
18:20:01 <Tjr> f is ((a->r)->r) -> b
18:20:17 <mm_freak> Tjr: f :: a -> b
18:20:37 <mm_freak> g :: (Monoid r) => (a -> r) -> r
18:20:41 <Tjr> I thought f :: Coll a -> Coll b, from which I expanded the Coll a
18:20:53 <Tjr> err, forget that
18:21:03 <mm_freak> review the type signature of fmap =)
18:21:43 <kazagistar> there is an entirely different grammar for dealing with infinite strings
18:22:27 <Tjr> can I imagine g :: (a -> r) -> r, with the extra guarantee that r will always be a monoid?
18:22:49 <mm_freak> you could just imagine g :: (Monoid r) => (a -> r) -> r
18:22:50 <mm_freak> =)
18:23:00 <mm_freak> then you have that guarantee built in =)
18:23:01 * Tjr imagines the unimaginable.
18:23:26 <Maxdamantus> It's easy if you try.
18:23:30 <mm_freak> Tjr: think simple:  a collection is a function…  this function takes a "singleton" function as its argument
18:23:43 <mm_freak> Tjr: myCollection :: (Monoid r) => (a -> r) -> r
18:24:01 <Tjr> where did the singleton function come from?
18:24:05 <mm_freak> now you want to construct a collection of a single Int
18:24:21 <Tjr> For now, I'm checking the "." in k.f
18:24:34 <mm_freak> myColl :: (Monoid r) => (Int -> r) -> r
18:24:40 <mm_freak> myColl singleton = singleton 3
18:24:48 <mm_freak> this is a collection of a single value, 3
18:25:04 <mm_freak> now you want to have a collection of three values…  use the fact that the result type is a monoid
18:25:13 <mm_freak> myColl singleton = singleton 3 <> singleton 4 <> singleton 5
18:25:14 <mm_freak> that's it
18:25:19 <mm_freak> that's the basic idea
18:25:40 <mm_freak> now you can make this function generate an actual collection by giving it an actual singleton function
18:25:46 <mm_freak> myColl S.singleton :: Set Int
18:26:05 <mm_freak> all i did was to give this type a pretty name, first step:
18:26:16 <mm_freak> type Coll a = forall r. (Monoid r) => (a -> r) -> r
18:26:26 <mm_freak> and then i wrapped it in a newtype to give it all those instances
18:26:29 <mm_freak> newtype Coll a = …
18:26:36 * Tjr is way behind
18:26:47 <mm_freak> IRC backlogs are patient =)
18:26:53 <mm_freak> read it in your own speed
18:26:54 <Tjr> k is of type (a' -> r) -> r
18:27:08 <Tjr> f is (a -> b)
18:27:23 <mm_freak> "k" is just a convention…  you can rename it to "singleton", if you like
18:28:01 <Tjr> k . f is only possible if b = (a' -> r)
18:28:12 <Tjr> that doesn't make sense
18:28:32 <mm_freak> fmap f (Coll g)
18:28:45 <mm_freak> g is a collection of type:  (Monoid r) => (a -> r) -> r
18:28:48 <Tjr> fmap is what I'm trying to wrap my head around
18:28:49 <mm_freak> and f is of type a -> b
18:29:23 <Tjr> due to currying, f's b gets inserted into k
18:29:33 <mm_freak> such a collection you can think of as an enumerator…  you pass it a singleton function and it enumerates all its elements to it using Monoid for composition
18:29:45 <Tjr> since k fits inside Coll, it has to be k :: (a' -> r') -> r'
18:29:47 <mm_freak> the result value is another such collection
18:29:58 <mm_freak> fmap f (Coll g) = Coll (\singleton -> …)
18:30:16 <ssqq> How to define a function in new version? : sayMe = "one" --> is error on input "="
18:30:27 <mm_freak> this collection is the collection enumerated by 'g', but if 'f' appended to each value
18:30:33 <Tjr> collection, enumerator, singleton, Monoid are all above my head for now. First I need to understand what Coll is before I can draw connections to other stuff
18:31:43 <mm_freak> Tjr: collection = enumerator…  your final collection is of type 'r'
18:32:00 <Tjr> which letter in that fmap line is "enumerator"?
18:32:06 <mm_freak> a value of type Coll is a function that has a collection, but doesn't yet know how it should communicate that collection to you
18:32:30 <mm_freak> so, if it knows how to enumerate, it will happily enumerate its values to you
18:32:35 * Tjr is mired in the very basics.
18:33:20 <mm_freak> forget Coll for now
18:33:27 <kazagistar> well, I think it is starting to work for me
18:33:32 <mm_freak> think of the following value:
18:33:44 <mm_freak> myCollection :: (Monoid r) => r
18:33:52 <mm_freak> what can it be?
18:34:00 <Tjr> pretty much anything
18:34:05 <mm_freak> not at all!
18:34:09 <mm_freak> mempty, mempty <> mempty, mempty <> mempty <> mempty, …
18:34:14 <mm_freak> and those are all the same thing:  mempty
18:34:20 <mm_freak> because r is a monoid
18:34:21 <Tjr> not every monoid is generated by mempty
18:34:35 <mm_freak> yes, but myCollection has an implicit forall there
18:34:45 <mm_freak> it promises to work /for all/ monoids
18:34:51 <Tjr> what does the forall have to do with how large the monoid is?
18:35:08 <mm_freak> it's like the identity function
18:35:11 <mm_freak> id x = …?
18:35:16 <mm_freak> can you return anything other than x?
18:35:25 <mm_freak> (disregarding bottoms)
18:35:36 <Tjr> ah, so you're sayin gthat myCollection is trying to be every monoid at the same time, so it ends up being the intersection of them all?
18:36:13 <mm_freak> it's not trying to be every monoid…  it works for every monoid…  a "forall" is really like an implicit type argument
18:36:50 <mm_freak> return to id…  can you return anything other than x?  answer this question!
18:37:17 <Welkin> what if it fails?
18:37:27 <Tjr> no, id x can only be x, because you defined it as "id x = x"
18:37:35 <kazagistar> Welkin: he said "disregarding bottom
18:37:50 <mm_freak> Tjr: let's pretend that i haven't defined it yet, and let's call it f
18:37:55 <mm_freak> f :: forall a. a -> a
18:37:57 <mm_freak> f x = ?
18:38:01 <Tjr> note that the definition of id doesn't leverage any clever quantors
18:38:11 <Tjr> now to f ...
18:38:29 <Tjr> I'm tempted to say that f :: a -> a is the same thing
18:38:42 <Tjr> which boils down to f = id
18:38:57 <mm_freak> good…  now why is it that you can't return anything other than x?
18:39:08 <Tjr> intuition
18:39:13 <Tjr> I can't prove that
18:39:32 <kazagistar> type theory can :P
18:39:50 <bms1> Tjr: suppose you have data Void, where Void has no constructors...
18:39:56 <mm_freak> imagine you're a gatekeeper, and you promise that you will let everyone pass…  what do you know about the people that will come?
18:40:03 <Tjr> however, every set admits a well-ordering. Therefore, f can return a natural number (or infinity for the overshoot)
18:40:52 <mm_freak> there is a simple technical reason for why you can't return anything other than the argument
18:41:07 <mm_freak> and it's important to understand this reason
18:41:19 <Tjr> really, "a" ranges over everything inside some universe, and I presume that universe to be a set. Therefore, there is a mapping from that universe to the extended natural numbers. f has access to this mapping.
18:41:23 <bms1> Tjr: Only if you assume the axiom of choice! in classical logic
18:41:50 <Tjr> you can do without the axiom of choice as long as your objects can be constructed inductively.
18:41:51 <bms1> Tjr: what if you have an uninhabited type, like data Void
18:41:59 <mm_freak> Tjr: right now your set theory knowledge hinders you
18:42:10 <mm_freak> Tjr: try to think really really simple
18:42:18 <mm_freak> why can't you return anything other than x?
18:42:19 <Tjr> bms1: in that case, there is no a that you could feed f
18:42:59 <bms1> Tjr: Well, you're *supposing* you have a value of that type. So you have to use that (because there's no way you'll find a value elsewhere)!
18:43:11 <Tjr> the gatekeeper really knows nothing
18:43:21 <mm_freak> exactly!
18:43:27 <Tjr> but that#s not a proof
18:43:58 <mm_freak> if you are a function /for all/ 'a', then you know nothing about your argument other than that your result is of the same type
18:44:11 <mm_freak> so the only thing you can do is to return your argument
18:44:23 <Tjr> intuitively, that's clear
18:44:38 <Tjr> however, I'm a bit distrustful of intuition. it has led me to many a blunder.
18:44:52 <mm_freak> in this case it's safe to follow it
18:44:59 <Tjr> of course, I can simply accept that it's safe here
18:45:22 <mm_freak> it follows from a small and simple set of formal rules, which pretty much matches your intuition
18:46:02 <mm_freak> anyway, now myCollection is different
18:46:05 <Tjr> what about f :: (a -> r ) -> r
18:46:17 <mm_freak> we'll return to that
18:46:18 <Tjr> I bet that f can only return a
18:46:23 <mm_freak> it promises to work for every monoid r
18:46:43 <Tjr> or mzero
18:46:44 <kazagistar> there is a reason that the constructivisist, non-classical mathematical foundations of math are called "intuitionistic" :P
18:46:49 <mm_freak> myCollection :: forall r. (Monoid r) => r
18:46:59 <mm_freak> hehe
18:47:18 <mm_freak> Tjr: now you're just a value…  you may be a function, but you don't know that
18:47:24 <mm_freak> all you know is that you're a monoid
18:47:28 <Tjr> indeed.
18:47:31 <mm_freak> so you have an identity called mempty
18:47:36 <mm_freak> and you have composition (<>)
18:48:09 <mm_freak> even now you don't have enough information to construct an actual collection, because you can only compose mempty with itself, which by the monoid laws is again just mempty
18:48:18 <Tjr> when I first tried to derive the applicative laws from the monadic ones, the compiler told me I got (a-> b) -> b wher eI should have gotten a.
18:48:46 <mm_freak> so the last missing piece is that you expect your caller to tell you how to construct singletons
18:48:57 <mm_freak> myCollection :: forall r. (Monoid r) => (Int -> r) -> r
18:49:12 <mm_freak> apparently now you can construct a "singleton" value from an Int
18:49:26 <mm_freak> you don't know what the result will look like, but you have this function that you can apply
18:49:35 <mm_freak> myCollection sing = sing 1 <> sing 2 <> sing 3
18:50:14 <Tjr> somehow it doesn't feel right that f :: (a -> b) -> b should only be able to return b=mzero
18:50:25 <mm_freak> note, mzero ≠ mempty
18:50:34 <mm_freak> and your f has a different type
18:51:02 <mm_freak> your f doesn't even exist =)
18:51:54 <mm_freak> also "b = mzero" sounds a lot like you're confusing levels
18:52:01 <mm_freak> b is a type, mzero and mempty are values
18:52:29 <Tjr> yeah, I just don't know which symbol to type instead of =
18:52:38 <mm_freak> mempty :: b
18:52:40 <Tjr> maybe |-
18:52:49 <mm_freak> "::" = "of type"
18:53:02 <Tjr> why do you say that mzero != mempty?
18:53:12 <mm_freak> :t mzero
18:53:13 <lambdabot> MonadPlus m => m a
18:53:14 <mm_freak> :t mempty
18:53:15 <lambdabot> Monoid a => a
18:53:46 <Tjr> ok, you're regarding names without any isomorphisms rightnow
18:54:24 <Tjr> back to f :: Monoid r => (a -> r ) -> r
18:54:38 <mm_freak> do you understand myCollection so far?
18:54:58 <Tjr> is it safe to say that f has nothing to stuff inside (a->r) and therefore can't use that function in any way?
18:55:15 <mm_freak> yes
18:55:16 <Tjr> s/use/depend on/
18:55:21 <Tjr> ok, then it's clear
18:55:50 <Tjr> f :: Monoid r => (a -> r ) -> r -- can return some constant r \elem Monoid
18:56:11 <Tjr> f :: forall r. Monoid r => (a -> r ) -> r -- can only return mempty
18:56:37 <mm_freak> they are the same thing…  in standard haskell all type variables are bound
18:57:03 <mm_freak> you need an extension (ScopedTypeVariables) to allow free type variables
18:57:58 <Tjr> so f can only return mempty. (not sure about that extension)
18:58:02 <mm_freak> so "f :: (Monoid r) => (a -> r) -> r" is identical to "f :: forall a r. (Monoid r) => (a -> r) -> r"
18:58:08 <mm_freak> forget the extension for now
18:58:16 <mm_freak> yes, f can only be mempty
18:58:54 <Tjr> can you give an example where  "forall" is an existential quantor?
18:59:06 <mm_freak> no, because there is none =)
18:59:25 <bms1> Tjr: Well, when it's used inside a data constructor
18:59:29 <Tjr> ... except when pattern matching, which doesn't count here
18:59:43 <bms1> data Void = forall a. Void a
18:59:48 <mm_freak> also i really don't understand why you're constantly talking about existentials in the context of Coll…  Coll doesn't involve existential quantification at all!
18:59:58 <Tjr> http://www.haskell.org/haskellwiki/Keywords#forall
19:00:10 <Tjr> The wiki introduces "forall" as an existential quantor
19:00:16 <mm_freak> bms1: even then it's universal
19:00:50 <Tjr> now I know that that refers to pattern matching inside a constructor
19:01:04 <Tjr> but it's not at all obvious before you get told
19:01:13 <mm_freak> "existential type" = "type with universally quantified type variables that aren't arguments to the corresponding type constructor"
19:01:18 <bms1> woops, that should have been data Any = forall a. Any a
19:01:28 <mm_freak> which is to say:  "types for which pattern matching may be existential"
19:01:45 <bms1> xs :: [Any]; xs = [Any 1, Any 'c', Any "Hi!"]
19:02:04 <bms1> Any is isomorphic to Exists a. a
19:02:23 <Tjr> what's the point of a newtype Coll if all it can ever contain is "const mempty"?
19:02:37 <mm_freak> Tjr: that's not all it can contain
19:02:53 <Tjr> runColl :: forall r. (Monoid r) => (a -> r) -> r
19:03:04 <mm_freak> Tjr: you didn't answer my question…  do you understand myCollection and its constraints?
19:03:09 <Tjr> so runColl can only ever return mempty
19:03:18 <Tjr> yes, I understand myCollection now
19:03:26 <mm_freak> good
19:03:49 <mm_freak> and you also understand how myCollection can actually represent a collection of values and how you get an actual Set from it?
19:03:56 <Tjr> no
19:04:20 <mm_freak> notice that myCollection is only universally quantified over 'r', but not its item type
19:04:30 <mm_freak> myCollection :: (Monoid r) => (Int -> r) -> r
19:04:36 <mm_freak> myCollection sing = sing 1 <> sing 2 <> sing 3
19:05:02 <mm_freak> you could have a different collection, say a collection of strings
19:05:13 <mm_freak> strings :: (Monoid r) => (String -> r) -> r
19:05:19 <mm_freak> strings sing = sing "abc" <> sing "def"
19:05:30 <mm_freak> but they have in common that they are quantified over r
19:05:53 <mm_freak> when they are quantified over r, it means that you get to select r when /applying/ this function
19:06:00 <Tjr> so you're saying that myCollection can return different flavors of mempty?
19:06:10 <mm_freak> so you could apply it to 'singleton' from Data.Set
19:06:36 <mm_freak> myCollection S.singleton = S.singleton 1 <> S.singleton 2 <> S.singleton 3
19:06:42 <mm_freak> = S.fromList [1,2,3]}
19:06:50 <mm_freak> = S.fromList [1,2,3]
19:07:08 <mm_freak> clear so far?
19:07:16 <Tjr> no
19:07:18 <Tjr> myCollection sing = sing 1 <> sing 2 <> sing 3
19:07:21 <Tjr> I disagree
19:07:28 <mm_freak> with what?
19:07:55 <Tjr> myCollection sing = (\ x y -> emptry) sing = (\y -> mempty)
19:08:13 <mm_freak> what?
19:08:14 <Tjr> (\y -> mempty) != sing 1
19:08:35 <Tjr> myCollection = (\ x y -> mempty)
19:08:40 <systemfault> Noob question… coming from someone with very basic math knowledge. Why does haskell has so much operator overloading?
19:08:52 <mm_freak> that's not how i defined myCollection
19:09:07 <Tjr> myCollection :: (Monoid r) => (Int -> r) -> r
19:09:25 <Tjr> which implies myCollection = (\ x y -> mempty)
19:09:27 <mm_freak> systemfault: haskell has type classes in general, so you can "overload" anything
19:09:44 <lfairy> systemfault: operators are punctuation, not vocabulary
19:10:00 <lfairy> systemfault: the fact that you're mapping is less important than what you're mapping with
19:10:11 <systemfault> lfairy: I didn’t think of it that way, thank you
19:10:23 <mm_freak> systemfault: also haskell doesn't make a difference between functions and operators…  if you can have custom named functions, you can have custom symbolic functions ("operators")
19:10:45 <Tjr> systemfault: did you find some library, such as lenses, etc? Some authors love to overload.
19:11:11 <systemfault> Tjr: Still reading through LYAH and beginning RHW later tonight.
19:11:15 <mm_freak> the funny thing here is that in the lens library you won't find much operator overloading
19:11:23 <benzrf> overload
19:11:34 <mm_freak> also i really don't like the term "overloading"
19:11:42 <benzrf> yes lens is indeed overloaded w/ ops
19:11:46 <Tjr> lol
19:11:47 <Iceland_jack> Haskell doesn't really do overloading
19:12:08 <mm_freak> Tjr: i don't understand your implication
19:12:10 <Tjr> some of the older haskell docs sure overload the brains of newbies :-)
19:12:25 <Tjr> mm_freak: we established that myCollection can only ever return mempty.
19:12:28 <mm_freak> Tjr: and your compiler wouldn't either, because it's a type error ;)
19:12:32 <mm_freak> Tjr: no
19:12:44 <mm_freak> Tjr: i reused the name, sorry
19:12:49 <mm_freak> myColl1 :: (Monoid r) => r
19:12:52 <mm_freak> this one can only be mempty
19:13:00 * Tjr agrees 
19:13:04 <mm_freak> myColl2 :: (Monoid r) => (Int -> r) -> r
19:13:11 <mm_freak> this one can be more
19:13:18 * Tjr is confused.
19:13:42 <mm_freak> it receives a function that can construct an r from an Int
19:13:44 <Tjr> myColl3 :: (Monoid r) => (a -> r) -> r
19:13:49 <mm_freak> so naturally it can use this function
19:13:56 <mm_freak> myColl3 can again only be mempty
19:14:02 <mm_freak> because it doesn't know how to get an 'a'
19:14:05 <Tjr> ah, now I get it
19:14:31 <Tjr> ok, myColl2 can be more than just empty
19:14:32 <bms1> mm_freak: I don't get why for myColl2
19:14:39 <mm_freak> the final step is to apply myColl2 to an actual singleton function
19:14:46 <mm_freak> myColl2 S.singleton  -- from Data.Set
19:14:52 <bms1> By the same argument, isn't the only thing that the (Int -> r) can produce mempty?
19:15:17 <Tjr> bms1: once you know you're dealing with Int, you are allowed to stuff in 1::Int, 2::Int, etc.
19:15:29 <mm_freak> bms1: no…  the function is received as an argument…  the caller selects 'r', so they know everything about 'r'
19:15:52 <mm_freak> they can pass you a suitable function, for example S.singleton :: Int -> Set Int
19:15:57 <mm_freak> then r = Set Int
19:16:01 <bms1> Oh, yep!
19:16:58 <johnfn> hey guys, so i was digging through this handy library http://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html because I wanted whileM
19:17:12 <johnfn> and so whileM is whileM :: Monad m => m Bool -> m a -> m [a]
19:17:23 <johnfn> whats blowing my mind is the predicate m Bool
19:17:27 <mm_freak> the next step is to recognise this as a pattern and write a type alias for this kind of collection
19:17:38 <mm_freak> type Coll a = forall r. (Monoid r) => (a -> r) -> r
19:18:03 <mm_freak> at this point you need the RankNTypes extension
19:18:16 <mm_freak> myColl2 :: Coll Int
19:18:30 <mm_freak> because Coll Int = forall r. (Monoid r) => (Int -> r) -> r
19:19:05 <johnfn> i want to do something to ask the user if he wants to keep going with getLine, but i have no idea how to get a result out of the m a and into the function i’d pass in for m Bool
19:19:09 <mm_freak> the final step is to recognise that this is actually an instance of a range of type classes including Monad
19:19:29 <mm_freak> in order to write those instances simply wrap it up in a newtype
19:19:45 <mm_freak> newtype Coll a = Coll { enumerate :: forall r. (Monoid r) => (a -> r) -> r }
19:19:49 <mm_freak> and that's it
19:20:08 <Tjr> <interactive>:1:0: parse error on input `type'
19:20:21 <mm_freak> Tjr: :set -XRankNTypes
19:20:33 <johnfn> actually, let me just ask a more general question. what would be the most idiomatic way to ask the user for input until he types “stop”, all the while collecting the lines of what he typed in a list?
19:20:46 <Tjr> mm_freak: problem persists
19:20:52 <mm_freak> johnfn: this version of whileM assumes that you achieve communication between the two through the monad itself
19:20:58 <bms1> johnfn: putStrLn "Continue?" >> fmap (=='y') getChar :: IO Bool
19:21:06 <bms1> (to answer your first question there)
19:21:11 <Tjr> mm_freak: I'm using version 6.12.3 (newest that will run on my old mac)
19:21:23 <tacoshellmcgee> I heard haskell is being abandoned
19:21:33 <johnfn> mm_freak: ah, i see. is that possible with IO?
19:21:33 <benzrf> u need to turn off buffering on stdin for bms1 to work
19:21:42 <mm_freak> Tjr: oh, that version of GHC doesn't even allow you to define type aliases within a GHCi session
19:21:49 <Iceland_jack> tacoshellmcgee: In the meantime you can check out Learn You a Haskell :)
19:21:49 <Iceland_jack> @where lyah
19:21:49 <lambdabot> http://www.learnyouahaskell.com/
19:21:51 <mm_freak> johnfn: yes, though awkwardly
19:22:02 <mm_freak> johnfn: my recommendation is to use regular recursion
19:22:06 <johnfn> bms1: yeah, but how can i collect the results of getChar
19:22:18 <johnfn> ah darn
19:22:28 <johnfn> i was hoping for some uber awesome combinator hax ;-)
19:22:51 <bms1> putStrLn "Continue?" >> fmap (=="y") getLine :: IO Bool
19:23:00 <kazagistar> tacoshellmcgee: well, at least the 1300+ of us havent yet, so thats something at least
19:23:05 <mm_freak> johnfn: i've used haskell for ca. 6 years now, and i've never found use or even acknowledgement for the monad-loops package =)
19:23:07 <bms1> so we don't have the issue benzrf pointed out
19:23:17 <johnfn> mm_freak hehe aww
19:23:38 <gfixler> tacoshellmcgee, I thought haskell was growing - I was this year turned onto it by a friend who got into it last year
19:23:52 <johnfn> bms1: also, that only asks once (rather than repeatedly)
19:24:06 <bms1> johnfn: one at a time!
19:24:19 <johnfn> oh yeah
19:24:36 <bms1> johnfn: that would be the m Bool argument
19:24:52 <bms1> at each point in the while loop, ask if you want to continue
19:25:02 <mm_freak> johnfn: userRepeat c = do c; putStrLn "Continue?"; cont <- getChar; when (cont == 'y') (userRepeat c)
19:25:10 <Welkin> monad loops?
19:25:12 <mm_freak> 'when' is from Control.Monad
19:25:14 <Tjr> johnfn: you could take a look at the interact function
19:25:16 <sveit> does it make sense to "cache" computations done on a data structure in haskell as a field in the constructor, or should I just use the raw functions that do the calculation every time and expect ghc to do the caching/memoizing itself?
19:25:17 <johnfn> bms1: okay, but then how do i grab that input in the other function?
19:25:21 <Welkin> oh, `when`
19:25:28 <Welkin> I get annoyed when I see that in code
19:25:35 <Welkin> I see it all over the place in haskell sdl code...
19:25:37 <johnfn> Tjr: actually my question is a little more complicated because im reading a bunch of urls
19:25:44 <Welkin> it doesn't seem idiomatic
19:26:04 <bms1> johnfn: Oh... by not using whileM! look at what mm_freak wrote
19:26:13 <johnfn> hehe
19:26:31 <mm_freak> johnfn: my code is wrong…
19:26:41 <mm_freak> johnfn: userRepeat c = do c; putStrLn "Continue?"; cont <- getLine; when (cont == "y") (userRepeat c)
19:26:51 <mm_freak> that's more likely to do what you want =)
19:26:57 <johnfn> mm_freak: right, so then i just need to add another argument to gather all the conts
19:27:15 <mm_freak> why would you gather all the conts?
19:27:32 <johnfn> ok, so let me just describe my actual problem
19:27:40 <Tjr> mm_freak: in your myColl example, any structure with one special element would work, so you don't need the associativity and neutrality. Right?
19:27:46 * johnfn realizes that asking generalizations of questions just confuses people
19:27:50 <johnfn> mostly me
19:27:51 <johnfn> anyways
19:28:24 <johnfn> mm_freak: so what im doing is grabbing a bunch of paginated data, and i want to keep grabbing data and merging it all together until i get to a page that has no data on it
19:28:31 <mm_freak> Tjr: in most cases you need (<>) as well, unless you want to limit yourself to single-item collections
19:28:38 <orion> Hi. Is there anything like node.js but for Haskell?
19:28:48 <mm_freak> Tjr: and you want it to be a monoid to get some nice guarantees
19:28:52 <johnfn> but the only way i know ive hit the final page is if there’s no data left, there’s no way for me to query number of pages ahead of time
19:28:52 <Tjr> runColl :: (Monoid r) => (a -> r) -> r -- why does the compiler complain here?
19:28:53 <gamegoblin> orion: by node.js do you meant the server or the framework or what
19:29:02 <gamegoblin> orion: you might want to look at yesod or snap
19:29:11 <mm_freak> johnfn: oh, that sounds a lot like stream processing
19:29:33 <mm_freak> johnfn: see the pipes package
19:29:36 <orion> gamegoblin: the server
19:29:37 <johnfn> ah interesting, i’ve never heard of this
19:29:39 <johnfn> im reading it now
19:29:48 <gamegoblin> orion: take a look at yesod, snap, and wai
19:30:02 <orion> Thank you
19:30:21 <mm_freak> and happstack
19:30:54 <bms1> johnfn: collect = do { p <- getPage; if isNull p then return [] else fmap (p :) collect }
19:31:13 <bms1> that's how I'd do it (without needing to use any heavy machinery)
19:31:27 <bms1> (where you, of course, supply the getPage and isNull)
19:31:32 <mm_freak> bms1: that's a terrible way to do it
19:31:42 <bms1> blow the stack?
19:32:01 <bms1> why is that a bad way to do it?
19:32:04 <mm_freak> no, but it requires getPage to be some ugly mutably stateful thing
19:32:28 <bms1> mm_freak: I though getPage *was* some ugly mutably stateful thing?
19:33:05 <Tjr> mm_freak: you said that "forall r." in runColl keeps the compiler from complaining. I guess the complaint is because it doesn't know how to deal with r as long as its type isn't known. But that also applies to the version with forall.
19:33:28 <johnfn> getPage IS an ugly stateful thing
19:33:43 <johnfn> because its going out to some web api and requesting data
19:33:44 <mm_freak> bms1: it probably is in the sense of reading from a handle, but think of anything that doesn't just dump raw data from a file
19:34:08 <mm_freak> use pipes…  all it changes in that code is that "getPage" becomes "await"
19:34:48 <johnfn> mm, apparently before i use pipes i have to understand monad transformers
19:35:19 <johnfn> since i only sort of understand monads, that could take a little ;-)
19:35:33 <johnfn> bms1: whats “(p :)” from your code?
19:35:44 <mm_freak> johnfn: you aren't working directly in IO, but in some larger monad…  to embed an IO action, you have to liftIO it
19:36:06 <mm_freak> lines :: Producer String IO r
19:36:17 <mm_freak> lines = do line <- liftIO getLine; yield line; lines
19:36:32 <mm_freak> (or short:  forever (liftIO getLine >>= yield))
19:36:46 <johnfn> oh interesting
19:36:51 <johnfn> is yield anything like the python keyword
19:37:07 <mm_freak> it's a more powerful version of the python keyword =)
19:37:09 <Iceland_jack> johnfn: (p :) is a section with the operator (:)
19:37:15 <Iceland_jack> > ('a' :) " test"
19:37:16 <lambdabot>  "a test"
19:37:22 <Iceland_jack> > 'a' : " test"
19:37:23 <lambdabot>  can't find file: L.hs
19:37:25 <Iceland_jack> > 'a' : " test"
19:37:26 <lambdabot>  "a test"
19:37:26 <johnfn> Iceland_jack: oh right duh
19:37:28 <Iceland_jack> :)
19:37:31 <begriffs> How do I construct a dynamic query in postgresql-simple? I want to concatenate a sql string with some extra WHERE clauses (unkown at compile time) and make a query, but the library makes the Query type intentionally hard to build.
19:37:33 <johnfn> i didn’t recognize it with the space
19:37:57 <johnfn> (also the fact that my irc client was turning it into a happy face wasn’t helping)
19:38:04 <mm_freak> johnfn: pipes is python generators on steroids =)
19:38:15 <johnfn> sounds like fun hehe
19:38:52 <kazagistar> does pipes support "yield from"?
19:39:13 <mm_freak> kazagistar: what does it do?
19:39:24 <kazagistar> I guess I should explain that, 1 sec
19:39:39 <hiptobecubic> doesn't it just chain them, essentially?
19:40:32 <mm_freak> if that's the case, then the corresponding pipes code would be something like this:  await >>= f >>= yield
19:40:34 <hiptobecubic> like sticking  "while g: yield next(g)" in there?
19:40:43 * hiptobecubic might be wrong
19:40:51 <kazagistar> in python { yield from iter() } is the same as { for a in iter(): yield iter } but it optimizes in such a way that if you yield from N times recursively, it still has constant time complexity to yield each item from the chain
19:40:59 <kazagistar> er
19:41:08 <kazagistar>  { for a in iter(): yield a }
19:41:16 <mm_freak> kazagistar: yes
19:41:39 <mm_freak> pipes has Producer, Pipe and Consumer
19:42:36 <mm_freak> if you use only 'yield', you have a producer, only 'await' = Consumer, both = Pipe
19:43:03 <mm_freak> and if you use them in the same trivial way as the python code you just showed, then the pipe gets optimised away entirely
19:43:19 <Tjr> mm_freak: Thank you for all your time and effort, getting me to understand Collections!
19:43:45 <hiptobecubic> kazagistar, do you have an example of when this optimization would apply?
19:44:31 <mm_freak> hiptobecubic: probably when you have some kind of non-generator collection
19:44:55 <mm_freak> or when you have an imperative action
19:46:26 <kazagistar> so in python { def inorder(self):   if self.left: yield from self.left.inorder();  yield self.data;  if self.right: yield from self.right.inorder(); } will yield in constant time, even from the deepest part of the traversal
19:46:51 <hiptobecubic> kazagistar, ah you mean passing up the chain
19:47:15 <kazagistar> hiptobecubic: and then passing back when you finish yeah
19:48:36 <mm_freak> kazagistar: what does in constant time mean?  with respect to what?
19:48:38 <kazagistar> the generators in python 3 basically have a "hook" which defines its parent as a continution
19:48:42 <kazagistar> the height of the tree
19:49:22 <mm_freak> the traversal itself will cost, even if you use CPS
19:49:28 <gamegoblin> Is there a way to atomically modify an mvar with multiple producers? That is, put a lock on mvar, read value, modify value, write value, unlock mvar.
19:49:51 <parc> gamegoblin: that's really the point of STM i think
19:49:58 <kazagistar> mm_freak: sorry, it wont be constant, but... fast
19:50:00 <mm_freak> gamegoblin: if you use newMVar and never use takeMVar or putMVar, then you can use modifyMVar
19:50:17 <gamegoblin> mm_freak: modifyMvar says it’s not atomic for multiple producers
19:50:39 <mm_freak> gamegoblin: notice the constraint
19:50:53 <mm_freak> modifyMVar is atomic as long as the MVar is always full
19:50:54 <gamegoblin> mm_freak: why does that work?
19:51:11 <mm_freak> gamegoblin: but honestly i don't understand what you mean by "producer"
19:51:22 <gamegoblin> mm_freak: producer == anything that can write to the mvar
19:51:27 <rwbarton> if everybody takes before they put, then nobody can put while I have just taken
19:51:44 <parc> gamegoblin: STM has a function atomically :: STM a -> IO a (http://hackage.haskell.org/package/stm-2.1.1.2/docs/Control-Monad-STM.html)
19:51:55 <mm_freak> gamegoblin: if you're uncertain about fulfilling the constraint, use TVar rather than MVar
19:51:57 <kazagistar> "yield from" basically passes "control" of the generator to the other iterator, and stores itself as the continution for once the iterator is done
19:52:13 <mm_freak> kazagistar: ah, ok…  pipes does that implicitly
19:52:19 <mm_freak> it's regular coroutines
19:52:35 <kazagistar> mm_freak: regular coroutines does NOT do that, hmm
19:52:35 <gamegoblin> I think I understand why using only modify will work now
19:52:39 <rwbarton> MVar lets you do IO while you are "holding" the variable though (which is a double-edged sword)
19:53:39 <mm_freak> kazagistar: coroutines work that way: control is passed from one routine to the next
19:53:46 <mm_freak> in this case from the consumer to the producer
19:54:01 <kazagistar> mm_freak: right, but when you yield, does it yield directly to the parents parent?
19:54:31 <mm_freak> kazagistar: yielding = returning to the consumer
19:55:24 <kazagistar> right, but yield from from says "when the following coroutine yields, yield to MY parent instead, and then when all the items are done, continue"
19:56:43 <mm_freak> kazagistar: there is no haskell equivalent to that…  if you don't explicitly introduce a new level, everything happens on the same level
19:56:55 <mm_freak> in particular pipes doesn't even know that you are employing recursion
19:57:41 <kazagistar> I thought I was talking about introducing a new level?
19:58:33 <mm_freak> let me put it this way:  when you yield from a tree, the resulting compiled code is pretty much what you would have written without coroutines
19:58:46 <mm_freak> so this optimisation isn't necessary for pipes/haskell
19:59:32 <kazagistar> hmm
20:00:51 <kazagistar> I think I get what you are saying...
20:01:22 <mm_freak> pipes is really just a thin layer around regular functions…  await = passing control…  it's like you would have written the producer in place of the "await"
20:02:00 <mm_freak> correspondingly yield = passing control back, just like you would have written the remainder of the consumer in place of the "yield"
20:03:17 <parc> in terms of expressive power, how close to turing completeness can you get with just: \f g -> foldr1 f . unfoldr g
20:04:06 <parc> being the only loop/recursion type construct
20:04:07 <benzrf> mm_freak: pipes is just coroutines, yes
20:04:08 <mm_freak> parc: g could produce exactly one value using an arbitrary function
20:04:11 <benzrf> thats the point
20:04:21 <benzrf> actually, coroutine monad transformer
20:04:37 <shlevy> Writing an interpreter, does it make more sense for the Function constructor of the Value type to take a Value -> Value or to take the AST of the body and the variable binding(s)?
20:04:52 <benzrf> shlevy: latter, probably
20:05:01 <benzrf> well
20:05:09 <kazagistar> { inorder (Node data left right) = inorder left ++ [data] ++ inorder right } is one code I could write, but I could write ( inorder' (Node data left right) continue = inorder' left $ data : inorder' right cont } ... are these exactly the same, mm_freak?
20:05:11 <benzrf> hmm, interesting
20:05:24 <mm_freak> shlevy: depends on the language
20:05:36 <shlevy> mm_freak: nix ;)
20:06:05 <kazagistar> (where inorder tree = inorder' tree [])
20:06:09 <mm_freak> shlevy: Lambda :: Scope () Expr a -> Expr a
20:06:30 <shlevy> mm_freak: Context for that?
20:06:43 <mm_freak> shlevy: hmm?
20:06:44 <mm_freak> ah
20:06:51 <mm_freak> Scope is from the 'bound' library
20:07:04 <mm_freak> it introduces a locally nameless scope
20:07:05 <kazagistar> mm_freak: the first one is what a simple "yield" does, and the second is what "yield from" does
20:07:35 <shlevy> mm_freak: Ah OK. Why is Expr a type constructor?
20:07:52 <mm_freak> kazagistar: they are the same for pipes
20:08:05 <mm_freak> shlevy: its argument is the type of free names
20:08:19 <mm_freak> shlevy: search for "i'm not a number, i'm a free variable"
20:08:42 <shlevy> mm_freak: thanks
20:08:48 <shlevy> sorry first language impl :D
20:09:09 <mm_freak> shlevy: you get local type-safe de bruijn indices, and Expr itself becomes a substitution monad
20:09:14 <mm_freak> (>>=) = substitution
20:09:24 <kazagistar> mm_freak: you mean if instead of "list" I have "pipe"? pipes does the magic to optimize up to the level of the second?
20:09:36 <mm_freak> shlevy: most of it for free =)
20:09:49 <mm_freak> kazagistar: yes
20:10:12 <mm_freak> kazagistar: and it's not an optimisation
20:11:00 <mm_freak> kazagistar: that's what i'm saying:  pipes is an abstraction for passing control together with values
20:12:14 <mm_freak> kazagistar: i'm actually writing a similar abstraction myself, which allows this kind of performance in the context of delimited streams
20:12:19 <kazagistar> mm_freak: right, but the you can pass more or less often?
20:12:39 <mm_freak> kazagistar: i don't understand the question
20:13:04 <kazagistar> hmm, I guess that wasnt a question in my mind, but it might be wrong for some reason in the context of pipes
20:13:22 <mm_freak> it's defined this way
20:13:46 <mm_freak> you're saying something similar to:  "but what if a natural number is negative?!"
20:13:57 <mm_freak> it isn't =)
20:14:20 <gamegoblin> mm_freak: BUT WHAT IF?!?!
20:14:23 <gamegoblin> :P
20:14:44 <kazagistar> what I am asking about has nothing to do with "how its defined" or the semantics at all, but the implementation, afaik
20:15:23 <mm_freak> the implementation is the definition
20:16:53 <kazagistar> foldl
20:17:03 <kazagistar> sorry, misenter, 1 sec
20:18:45 <Javran> :t \f g x = getLine >> g x
20:18:46 <lambdabot> parse error on input ‘=’
20:18:59 <Javran> :t let f g x = getLine >> g x
20:19:00 <lambdabot> <no location info>: not an expression: ‘let f g x = getLine >> g x’
20:19:15 <kazagistar> foldl' (++) [] (map (\x->[x]) [1..1000]) =? foldl' (:) [] [1..1000]
20:19:19 <Javran> @pl f g x = getLine >> g x
20:19:19 <lambdabot> f = ((getLine >>) .)
20:19:30 <Desheng> what functions are used to construct a function with a signature like f :: (Word8,Word8) -> Word16 ?
20:19:50 <Javran> @hoogle f :: (Word8,Word8) -> Word16
20:19:52 <lambdabot> Data.Graph.Inductive.Graph ufold :: Graph gr => ((Context a b) -> c -> c) -> c -> gr a b -> c
20:19:52 <lambdabot> Data.Graph.Inductive.Query.DFS dfsWith' :: Graph gr => CFun a b c -> gr a b -> [c]
20:19:52 <lambdabot> Data.Graph.Inductive.Query.BFS bfsWith :: Graph gr => (Context a b -> c) -> Node -> gr a b -> [c]
20:20:01 <Javran> hmm..
20:20:19 <Desheng> I'm trying to write something like
20:20:22 <Javran> @hoogle Word8 -> Word8 -> Word16
20:20:23 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:20:23 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
20:20:23 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
20:20:47 <Desheng> c816le (a,b) = b*256 + a
20:21:02 <Desheng> but I have to manage the types as well
20:21:11 <Javran> use fromIntegral I guess
20:21:41 <Javran> :t (\ a b -> b * 256 + a) `on` fromIntegral
20:21:42 <lambdabot> (Num c, Integral a) => a -> a -> c
20:21:59 <shlevy> mm_freak: Looking through http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less , what's the :@ on the 3rd slide?
20:22:06 <Desheng> I got it to work with fromIntegral, thanks
20:22:21 <Desheng> this "on" function looks pretty exotic though, I gotta learn more about it
20:22:39 <maybefbi> will (!!) cause the evaluation of elements in the list previous indices to the one being queried?
20:23:29 <Desheng> whoa that is a clever function
20:23:31 <kazagistar> mm_freak: I really should just figure out exactly how pipes works and answer my own question
20:23:35 <Welkin> why would it?
20:23:44 <Javran> Desheng: Data.Function.on comes in handy when you want to do something like sorting a list of pairs
20:23:58 <kazagistar> @src on
20:23:58 <lambdabot> (*) `on` f = \x y -> f x * f y
20:24:10 <Welkin> :t f ( [a, b, c, d] !! 2) :: Expr
20:24:11 <lambdabot> Expr
20:24:28 <Javran> > sortBy (compare `on` snd) [(10,10), (1,5), (3,2)]
20:24:29 <lambdabot>  [(3,2),(1,5),(10,10)]
20:24:53 <Desheng> I like when @src gives you very-readable pseudocode :}
20:25:00 <Javran> Desheng: now that the comparison is done only using the `snd` part
20:25:01 <kazagistar> > [1, undefined, undefined, 3] !! 3
20:25:02 <lambdabot>  3
20:25:14 <kazagistar> maybefbi: ^^^
20:25:16 <kazagistar> so no
20:25:48 <Welkin> > f ( [a, b, c, d] !! 2) :: Expr
20:25:50 <lambdabot>  f c
20:26:04 <zq> shlevy: type constructor
20:26:09 <kazagistar> its a quick and dirty way to see if something was evaluated: put undefined there, and if it is evaluated, it crashes
20:26:17 <shlevy> zq: hm?
20:26:22 <zq> it's the same as if the author had written, (:@) Exp Exp
20:26:27 <shlevy> Oh!
20:26:30 <shlevy> :D
20:26:33 <zq> :p
20:26:40 <zq> haskell syntax is flexibadass like that
20:26:48 <zq> data constructor*
20:26:56 <zq> but you can define ty ctors like that too
20:28:35 <zq> like (:->) in ivory
20:28:42 <zq> which, btw, i still can't grok
20:29:00 <mm_freak> shlevy: most likely the application operator
20:29:07 <mm_freak> shlevy: f :@ x
20:29:09 <Hafydd> ;->
20:29:36 <shlevy> mm_freak: Yeah, I dind't realize you could define data ctors like that
20:31:01 <mm_freak> well, haskell is flexibadass =)
20:31:58 <mm_freak> interestingly when using TypeOperators you have to use "lower case" operators
20:32:14 <mm_freak> so you can't have pretty infix type variables anymore =/
20:32:32 <mm_freak> MyAT (>~) a b -> a >~ b
20:32:33 <zq> hey hey hey
20:32:37 <zq> cite your source
20:33:17 <mm_freak> that used to work, but now operators can't be type variables anymore
20:33:18 <Javran> functions of type a -> b, a -> a -> b, a -> a -> a -> b ... can really be instances of functors right?
20:33:30 <Javran> maybe even profunctors..
20:33:55 <mm_freak> Javran: the former is true
20:34:21 <mm_freak> the latter is not…  (->) is a profunctor, and the a -> b -> c = a -> (b -> c)
20:34:31 <mm_freak> so you can rmap a map
20:34:35 <Javran> mm_freak: is there a concept that captures this idea
20:34:43 <mm_freak> Javran: which idea?
20:34:59 <Javran> a -> b, a -> a -> b ... all of them are functors
20:35:04 <mm_freak> both of those instances are predefined
20:35:18 <dmwit_> Why isn't "[a] -> b" a good profunctor?
20:35:28 <mm_freak> what?
20:35:37 <mm_freak> a Profunctor is a * -> * -> *
20:35:50 <dmwit> type FunnyFunction a b = [a] -> b
20:35:59 <Javran> > (fmap show (++)) 10 20
20:35:59 <dmwit> Why isn't FunnyFunction a profunctor?
20:36:00 <lambdabot>  Couldn't match type ‘GHC.Base.String’ with ‘a1 -> t’
20:36:00 <lambdabot>  Expected type: [a0] -> a1 -> t
20:36:00 <lambdabot>    Actual type: [a0] -> GHC.Base.String
20:36:12 <mm_freak> dmwit: i think it is…
20:36:25 <dmwit> Okay. I think that is the spirit of Javran's question.
20:36:30 <benzrf> dmwit: its Also a Arrow
20:36:31 <dmwit> Though I could be wrong.
20:36:38 <benzrf> wait
20:36:48 <benzrf> i think its an arrow
20:37:06 <benzrf> nonempty is an arrow
20:37:13 <benzrf> *funnyfunction w/ nonempty i mean
20:37:16 <Javran> I've once make type BinFunc a b = a -> a -> b a profunctor
20:37:38 <benzrf> Javran: lmap would be on
20:37:49 <mm_freak> Javran: there is no easy instance-to-rule-them-all, if that's what you're asking
20:38:01 <benzrf> or rather flip on
20:38:10 <Javran> mm_freak: yeah, that's exactly what I'm asking
20:38:18 <mm_freak> 'a -> a -> c' is basically 'f (f c)'
20:38:27 <mm_freak> you can use Compose though
20:38:46 <mm_freak> Compose ((->) a) ((->) a) c ≃ a -> a -> c
20:38:46 <Javran> I see
20:39:18 <mm_freak> but that's going to get really awkward really quickly
20:39:32 <dmwit> Why don't you like [a] -> b?
20:39:50 <dmwit> It nicely encapsulates b, a -> b, a -> a -> b, a -> a -> a -> b, etc.
20:40:11 <mm_freak> i guess the function has indeed a static number of arguments
20:40:31 <dmwit> ...of course
20:40:35 <dmwit> My apologies.
20:40:38 <Javran> dmwit: but how can you convert a -> a -> b to [a] -> b or the other way around?
20:40:53 <dmwit> Javran: Well, the other way around is easy.
20:41:06 <dmwit> But (a -> a -> b) to ([a] -> b) isn't so hot. Lots of undefined.
20:41:23 <Javran> yeah..that is the problem
20:41:25 <dmwit> :t let f g a1 a2 = g [a1, a2] in f
20:41:26 <lambdabot> ([t1] -> t) -> t1 -> t1 -> t
20:41:50 <dmwit> Javran: Yep. Hence my apologies above. =P
20:41:54 <mm_freak> anyway, fmap . fmap isn't that bad
20:42:19 <mm_freak> it's F . F, so fmap . fmap is appropriate
20:42:19 <hiptobecubic> @pl fmap . fmap
20:42:19 <lambdabot> fmap . fmap
20:42:54 <Welkin> :t fmap . fmap
20:42:55 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:43:25 <Welkin> when would one have doubly nested functors?
20:43:30 <Welkin> monad transformers?
20:43:34 <mm_freak> Welkin: a -> a -> b
20:43:56 <hiptobecubic> [[a]]
20:43:59 <mm_freak> lists of lists, lists of maybes, IO of a list, …
20:44:07 <Welkin> okay
20:44:35 <Javran> > (map . map) (+20) [[1,2,3],[4]]
20:44:36 <lambdabot>  [[21,22,23],[24]]
20:44:49 <zq> "letmeB this (F you)" oh ekmett
20:45:06 <mm_freak> > (do x <- sin; y <- cos; return (x + y)) 15
20:45:08 <lambdabot>  -0.10940007270170449
20:45:42 <Javran> what..parentheses for do notation?
20:45:58 <mm_freak> Javran: around do notation
20:46:01 <benzrf> @let data (f :. g) a = Compose (f (g a))
20:46:01 <lambdabot>  Parse failed: Illegal data/newtype declaration
20:46:03 <benzrf> lame!
20:46:25 <Javran> isn't that braces?
20:46:36 <mm_freak> @let data (f . g) a = Compose (f (g a))
20:46:36 <lambdabot>  Parse failed: Parse error: .
20:46:48 <Javran> > {do a<-[1,2,3]; return a}
20:46:49 <lambdabot>  <hint>:1:1: parse error on input ‘{’
20:47:00 <mm_freak> Javran: no, why?  braces is for disabling layout
20:47:13 <rwbarton> do ... is an expression, so it can go in parentheses
20:47:44 <Javran> rwbarton: I see
20:47:45 <mm_freak> parentheses are for overriding precedence…  function application has the highest, so i need to use parentheses
20:47:50 <Welkin> hence usage of do $ ...
20:48:02 <mm_freak> Welkin: that's a syntax error
20:48:09 <Welkin> what?
20:48:22 <Javran> oh I see, reader monad isn't it?
20:48:35 <mm_freak> Javran: yes, the same thing you mentioned earlier =)
20:48:53 <Welkin> er
20:48:55 <Welkin> yes
20:49:05 <Welkin> I meant $ do ...
20:49:44 <mm_freak> alright…  enough shit shat…  see you =)
21:19:47 <maybefbi> kazagistar, thanks
21:43:13 <benzrf> :t sin
21:43:14 <lambdabot> Floating a => a -> a
21:43:17 <benzrf> > fix sin
21:43:21 <lambdabot>  mueval-core: Time limit exceeded
21:43:22 <benzrf> man
21:47:15 <Welkin> > (liftM . liftM) h $ m1 (m2 a) :: Expr
21:47:16 <lambdabot>  Not in scope: ‘m1’
21:47:16 <lambdabot>  Perhaps you meant one of these:
21:47:16 <lambdabot>    ‘m’ (imported from Debug.SimpleReflect),
21:47:16 <lambdabot>    ‘_1’ (imported from Control.Lens)Not in scope: ‘m2’
21:47:16 <lambdabot>  Perhaps you meant one of these:
21:47:31 <Welkin> > (liftM . liftM) h $ c (b a) :: Expr
21:47:32 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
21:47:33 <lambdabot>              with actual type ‘m0 (m1 r0)’Couldn't match expected type ‘t0 ->...
21:47:33 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
21:47:33 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
21:48:17 <Welkin> > liftM f (m a) :: Expr
21:48:18 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
21:48:18 <lambdabot>              with actual type ‘m0 r0’Couldn't match expected type ‘Debug.Simp...
21:48:18 <lambdabot>                                -> m0 a10’
21:48:18 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
21:48:33 <Welkin> > liftM f (Just 3) :: Expr
21:48:35 <lambdabot>  can't find file: L.hs
21:48:42 <Welkin> what
21:49:18 <Welkin> > liftM (+1) (Just 3)
21:49:20 <lambdabot>  Just 4
21:49:29 <Welkin> why do you break when I pass it as an Expr
21:50:22 <Welkin> > map f [1..3] :: Expr
21:50:24 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
21:50:24 <lambdabot>              with actual type ‘[b0]’
21:50:58 <Welkin> > foldr f 0 [1..5] :: Expr
21:50:59 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 0))))
21:51:30 <Welkin> > fmap f [1..5] :: Expr
21:51:31 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
21:51:32 <lambdabot>              with actual type ‘[b0]’
21:51:44 <augur> welo
21:51:46 <augur> welp
21:51:59 <augur> i now have a way of constructing (and drawing) the DAGs i need
21:52:01 <jle`> > fmap f [1..4] :: [Expr] -- Welkin
21:52:03 <lambdabot>  [f 1,f 2,f 3,f 4]
21:52:09 <Welkin> oh
21:52:10 <jle`> btw you can query lambdabot :)
21:52:16 <augur> while also making it look like im constructing "records"
21:52:28 <Welkin> query?
21:52:33 <Welkin> you mean private message?
21:52:48 <jle`> yeah; /query lambdabot etc
21:53:09 <johnw> bitemyapp: ping
21:54:37 <Welkin> > (liftM . liftM) h $ [[a]] :: [[Expr]]
21:54:39 <lambdabot>  [[h a]]
21:55:08 <Welkin> how do I get it to work with: (liftM . liftM) h $ c (b a) :: Expr
21:55:37 <Welkin> an arbitrary functor
21:55:57 <mzero> but, Expr in that second example is a double nested monad
21:56:08 <mzero> whereas it is in the first
21:56:35 <Welkin> yes
21:57:17 <jle`> what kind of output were you expecting to get?
21:57:20 <mzero> are you trying to change the shape of the input? from some doubly nested Monad or Functor ... to just a plain value?
21:57:27 <Welkin> no
21:57:47 <Welkin> I just want to see: c (b (h a))
21:58:35 <jle`> so h, b, and c are functions?
21:58:36 <mzero> I see, you just want to do this with Functor s not Monads?
21:58:39 <jle`> and a is a value?
21:58:54 <Welkin> c and b are functors (or monads)
21:58:56 <Welkin> a is a value
21:59:18 <mzero> so     (fmap . fmap) h $ c (b a) ::  C (B Expr)
21:59:34 <mzero> where    h :: A -> Expr
21:59:42 <mzero> and     c (b a) :: C (B A)
21:59:42 <jle`> um
21:59:49 <mzero> yes?
21:59:55 <jle`> Welkin: are you reasoning on the type level, or the data level
22:00:03 <bitemyapp> johnw: yes?
22:00:10 <jle`> because c and b aren't Functors
22:00:15 <jle`> they are data functions
22:00:34 <Welkin> how do I represent a functor in an Expr then?
22:00:36 <jle`> in the case of (liftM . liftM) h $ c (b a), whatever that means
22:00:49 <jle`> Expr can only show data, not types
22:00:57 <jle`> you can however use :t to show types
22:01:15 <jle`> hm. have you learned about the difference between data and types?
22:01:20 <Welkin> yes
22:01:22 <jle`> the difference between, say, Just, and Maybe?
22:01:26 <Welkin> yes
22:01:38 <jle`> you can't apply liftM to types
22:01:41 <jle`> liftM is a function on data
22:01:49 <jle`> :t liftM
22:01:50 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:02:08 <jle`> so you can't apply liftM on "a functor"...that's like applying it to Maybe
22:02:14 <Welkin> well
22:02:19 <Welkin> I guess I may have explained it wrong
22:02:22 <jle`> :t liftM Maybe
22:02:23 <lambdabot> Not in scope: data constructor ‘Maybe’
22:02:35 <Welkin> I know that the function works, but I just wanted to see its symbolic execution
22:03:01 <jle`> so what kind of meaningful thing would you expect to come from (liftM . liftM) h (c (b a)) ?
22:03:08 <jle`> h is... a function
22:03:16 <mzero> let's try this tactic:   what is the type of    c (b a)   ?
22:03:22 <Welkin> well, I didn't know how Expr worked
22:03:33 <mzero> ah - which Expr type is this?
22:03:33 <johnw> bitemyapp: just tweeted: I've proven that simple-conduit Sources are both proper Monads and Categories, using Coq!
22:03:43 <bitemyapp> johnw: RT'd, relinked the repo again.
22:04:00 <bitemyapp> johnw: I keep meaning to do SF, perhaps understanding the Coq in the repo could be a goal?
22:04:03 <Welkin> well, it's pretty much the same as [[Expr]]
22:04:09 <int3__> is there some nice combinator to convert a tuple (a, Maybe b) -> Maybe (a, b)? I have (\(a, b) -> ((,) a) <$> b) right now
22:04:12 <johnw> bitemyapp: I would just start with SF :)
22:04:25 <johnw> also, I've moved the Coq in the repo to its own repo
22:04:25 <Welkin> but not necessarily lists
22:04:27 <johnw> category-theory
22:04:32 <bitemyapp> bah humbug
22:04:41 <bitemyapp> so much to learn ;_;
22:05:04 <johnw> i just don't know if my code will be very illuminating
22:05:06 <jle`> > f x :: Expr
22:05:07 <lambdabot>  f x
22:05:17 <mzero> so if     c (b a) :: [[Expr]]     then    (liftM . liftM) h $ c (b a)  will also be  :: [[Expr]]
22:05:25 <Welkin> how do I specify an arbitrary data constructor?
22:05:31 <mzero> ditto for         (fmap . fmap) h $ c (b a)
22:05:53 <mzero> is your data type a Functor?
22:06:00 <johnw> bitemyapp: SF is unreasonably fun btw
22:06:02 <Welkin> yes
22:06:05 <johnw> once you get started, it is hard to stop
22:06:11 <Welkin> let's say, IO Just
22:06:22 <mzero> then you don't need to / can't  (!)        fmap will take care of it
22:06:46 <mzero> so if your data type is F   (is it nested?) then       if      c (b a) :: F (F Expr)
22:07:07 <mzero> then      (fmap . famp) h $ c (b a) :: F (F Expr)      (assuming h :: Expr -> Expr)
22:07:41 <xrz> Hi, how do I run snap handler inside some function, provided, that I've passed application state to that function already? I seem to be able to use runReaderT for db queries, but not for authentication handlers (e.g. createUser)
22:07:45 <mzero> Welkin: , so    c (b a)    is of type     IO (IO a)     and      h :: a -> Expr?
22:08:06 <mzero> fine, then you get      (fmap . fmap) h $ c (b a)  :: IO (IO Expr)
22:08:10 <johnw> bitemyapp: the next step is to prove that all its other instances, like MonadTrans, are law abiding.  Tekmo thought there might be a problem with using r -> EitherT r m r, rather than EitherT r m r -> EitherT r m r, which is what a version of Source based on LogicT would use
22:08:12 <mzero> :t (fmap. fmap)
22:08:13 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:08:37 <Welkin> > (liftM . liftM) h $ c (b a) :: IO (Just Expr)
22:08:39 <lambdabot>  Not in scope: type constructor or class ‘Just’
22:08:39 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
22:08:46 <Welkin> > (liftM . liftM) h $ c (b a) :: IO (Maybe Expr)
22:08:47 <bitemyapp> johnw: he really likes uniformity.
22:08:47 <lambdabot>  Couldn't match expected type ‘t0
22:08:47 <lambdabot>                                -> GHC.Types.IO (Data.Maybe.Maybe a10)’
22:08:47 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
22:08:47 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
22:09:06 <johnw> bitemyapp: I want to keep the type as simple as I can get away with, so I want to explore this ListT vs. LogicT difference
22:09:15 <Welkin> > (liftM . liftM) h $ IO (Just a) :: IO (Maybe Expr)
22:09:16 <lambdabot>  Not in scope: data constructor ‘IO’
22:09:16 <lambdabot>  Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
22:09:18 <johnw> I'd welcome your help in that, if you would like to
22:09:52 <mzero> Welkin: IO isn't a constructor
22:09:56 <mzero> you can't build IO values like that
22:10:02 <bitemyapp> johnw: I really am not equipped for that.
22:10:17 <bitemyapp> johnw: https://hackage.haskell.org/package/logict this LogicT?
22:10:18 <johnw> you could write the typeclasses if you wanted, that shouldn't be too much work
22:10:20 <johnw> yes
22:10:23 <Welkin> @src IO
22:10:23 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
22:10:35 <johnw> if you write the classes, i'll write the instances
22:10:50 <johnw> it means rooting around the Internet looking for all the documented laws for each type classes
22:11:08 <Welkin> > (liftM . liftM) h $ return (Just a) :: IO (Maybe Expr)
22:11:09 <bitemyapp> johnw: to replace…ListT on (r -> EitherT r m r) ?
22:11:09 <johnw> ah yes, I need to read this paper
22:11:10 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
22:11:10 <lambdabot>                     Debug.SimpleReflect.Expr.Expr)
22:11:10 <lambdabot>    arising from a use of ‘M852881167816078590631705.show_M8528811678160785906...
22:11:27 <johnw> so, ContT (r -> m r) a is a form of ListT m a
22:11:34 <johnw> and ContT (m r -> m r) a is LogicT m a
22:11:34 <Welkin> > (liftM . liftM) (+1) $ return (Just 3)
22:11:36 <lambdabot>  No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe r0)))
22:11:36 <lambdabot>    arising from a use of ‘M366614452915174723931717.show_M3666144529151747239...
22:11:36 <lambdabot>  The type variables ‘m0’, ‘r0’ are ambiguous
22:11:36 <lambdabot>  Note: there are several potential instances:
22:11:36 <lambdabot>    instance [safe] GHC.Show.Show a =>
22:11:38 <bitemyapp> I've gotta grab food, but when I get back, I'll take a look. I really can't promise anything, I'm very slow and you'll DIY before I could do anything.
22:11:44 <johnw> what I want to know is, what is the semantic difference
22:12:12 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: IO
22:12:14 <lambdabot>  Expecting one more argument to ‘GHC.Types.IO’
22:12:14 <lambdabot>  Expected a type, but ‘GHC.Types.IO’ has kind ‘* -> *’
22:12:18 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: IO Just
22:12:19 <lambdabot>  Not in scope: type constructor or class ‘Just’
22:12:19 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
22:12:23 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: IO Maybe
22:12:25 <lambdabot>  Expecting one more argument to ‘Data.Maybe.Maybe’
22:12:25 <lambdabot>  The first argument of ‘GHC.Types.IO’ should have kind ‘*’,
22:12:25 <lambdabot>    but ‘Data.Maybe.Maybe’ has kind ‘* -> *’
22:12:34 <johnw> s/ContT/Cont
22:12:45 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: IO Maybe Int
22:12:46 <lambdabot>  ‘GHC.Types.IO’ is applied to too many type arguments
22:12:54 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: IO (Maybe Int)
22:12:55 <lambdabot>  <IO (Maybe Int)>
22:13:04 <mzero> > (liftM . liftM) (*10) $ return (Just 5) :: IO (Maybe Int)
22:13:05 <lambdabot>  <IO (Maybe Int)>
22:13:06 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: Just (Maybe Int)
22:13:08 <lambdabot>  Not in scope: type constructor or class ‘Just’
22:13:08 <lambdabot>  A data constructor of that name is in scope; did you mean DataKinds?
22:13:13 <Welkin> > (liftM . liftM) (+1) $ return (Just 3) :: Maybe (Maybe Int)
22:13:15 <lambdabot>  Just (Just 4)
22:13:22 <Welkin> I keep doing that
22:13:28 <johnw> and if only one of them can be a law-abiding MonadTrans, which Tekmo implied
22:13:31 <mzero> > let q = (liftM . liftM) (*10) $ return (Just 5) :: IO (Maybe Int) in q >>= print
22:13:33 <lambdabot>  <IO ()>
22:13:38 <mange> int3__: try uncurry (fmap . (,))
22:13:40 <Welkin> lambdabot can't do IO
22:13:46 <mzero> sigh, poor lambdabot
22:13:52 <mzero> but either works in ghci
22:13:59 <Welkin> yes
22:14:10 <Welkin> I don't have to specify any types in ghci though
22:14:28 <int3__> mange: yeah, I got that from @pl. it's not really more elegant though, and actually takes more characters :P
22:15:49 <Welkin> playing with nested monads is interesting though
22:16:00 <Welkin> thanks for the help
22:16:13 <mzero> welcome
22:16:25 <Welkin> I also tried to derive many forms of the function (using >>= instead of liftM)
22:16:25 <mange> It seems to take less characters to me? I also generally try to avoid explicit lambda forms when I can.
22:22:22 <Vo1d> hi all
22:22:41 <mzero> evening, Vo1d
22:23:02 <Vo1d> I installed haskell from sources, when I use sudo cabal, then report :
22:23:11 <Vo1d> sudo: cabal: command not found
22:23:31 <mzero> when you say you installed from sources, you mean you installed the GHC compiler from GHC compiler sources?
22:23:44 <Vo1d> yes mzero
22:23:54 <mzero> ah, GHC doesn't come with the cabal command
22:24:04 <Welkin> install haskell platform
22:24:06 <mzero> (as an aside, why would you ever call cabal   sudo?)
22:24:08 <Vo1d> mzero cabal is installed
22:24:19 <mzero> where is it?
22:24:20 <phaskell> No symbol 'it' found anywhere.
22:24:24 <Vo1d> I installed haskell plattorm
22:24:36 <methou> looks like the dir where cabal resides isn't in the root's PATH.
22:24:41 <Vo1d> which cabal
22:24:41 <Vo1d> /opt/bin/cabal
22:25:01 <mzero> ah, well
22:25:03 <Welkin> what is your $path
22:25:07 <Vo1d> cabal update
22:25:14 <mzero> likely that root doesn't have /opt/bin  on root's PATH
22:25:16 <Vo1d> ~/.cabal/bin$ ls
22:25:16 <Vo1d> cabal
22:25:31 <mzero> which would be considered a security feature in most distributions
22:25:33 <Vo1d> my path
22:25:34 <Vo1d> echo $PATH
22:25:34 <Vo1d> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/bin
22:25:39 <mzero> but you ran it sudo
22:25:53 <Vo1d> yes mzero sudo cabal
22:25:55 <methou> sudo echo $PATH ?
22:26:13 <Vo1d> sudo echo $PATH
22:26:13 <Vo1d> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/bin
22:26:36 <mzero> (as an aside, you never need to run cabal sudo, because if you want cabal to do something global, that needs root privs.... cabal does all the work it can w/o sudo, and invokes sudo for you for just the final copy into place)
22:26:49 <Vo1d> I did ln -s /home/alfa/.cabal/bin  /opt/bin
22:27:24 <mzero> that command would put a symlink in /opt/bin called bin....
22:27:28 <genisage> I have a general question about the nicta course
22:27:30 <Vo1d> mzero global and user I configured in /opt enviroment
22:27:41 <Vo1d> mzero, ln -s
22:28:47 <Vo1d> I want that automatized and no copy from my ~/ at  /opt
22:29:48 <mzero> so, to recap, ls -l /opt/bin/cabal   gives you a symlink to  /home/alpha/.cabal/bin/cabal      and    ls -l /home/alpha/.cabal/bin/cabal shows a resonable executble there     and    which cabal     returns /opt/bin/cabal      .....    but    sudo cabal can't find it
22:29:56 <Vo1d> I think that is restriction of the distribution
22:30:01 <mzero> so... does just    cabal  (non sudo) work
22:30:47 <Vo1d> ls -l /opt/bin/ca*
22:30:48 <Vo1d> lrwxrwxrwx 1 root root      27 2014-07-06 22:57 /opt/bin/cabal -> /home/alfa/.cabal/bin/cabal
22:31:20 <Vo1d> mzero sudo cabal not working, it's normal?
22:31:34 <mzero> no
22:31:56 <mzero> ls -l  /home/alfa/.cabal/bin/cabal
22:31:57 <Vo1d> mzero, it is restriction of the distribucion ?
22:32:07 <mzero> no, I'm not even sure how it could be
22:32:15 <Vo1d> ls -l  /home/alfa/.cabal/bin/cabal
22:32:15 <Vo1d> -rwxr-xr-x 1 alfa alfa 8582500 2014-07-06 22:25 /home/alfa/.cabal/bin/cabal
22:32:19 <mzero> good
22:32:30 <mzero> and does just    cabal    work   (non sudo)?
22:32:48 <Vo1d> mzero, cabal working non sudo
22:32:57 <mzero> excellent - then this is a PATH issue with root
22:33:07 <Vo1d> cabal --version
22:33:07 <Vo1d> cabal-install version 1.20.0.3
22:33:08 <Vo1d> using version 1.20.0.1 of the Cabal library
22:33:08 <mzero> try     sudo env | grep PATH
22:33:25 <Vo1d> yeah!
22:33:26 <Vo1d> sudo env | grep PATH
22:33:26 <Vo1d> PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/X11R6/bin
22:33:35 <mzero> tada - notice no /opt/bin
22:33:48 <Vo1d> but I don't know where manipulate
22:33:57 <mzero> AH - but "restriction of the distribution" you meant the OS distribution, not the Haskell one!
22:33:58 <mzero> AH
22:34:16 <Vo1d> yes mzero, but where is the configuration file?
22:34:25 <Vo1d> I touch in /etc/environment
22:34:33 <mzero> where to change that is totally dependent on which OS you are running. Ubunutu? other Linux? BSD?
22:34:49 <Vo1d> mzero ubunt 10.04
22:34:56 <glosoli> You shouldn;
22:34:56 <Welkin> just sudo export /opt/bin:$PATH
22:35:03 <glosoli> You shouldn't change your /etc/environment in ubuntu
22:35:09 <glosoli> usually you prepend in ~/.bashrc
22:35:23 <mzero> Welkin: that won't carry over to the next sudo command
22:35:55 <mzero> Vo1d: you could edit ~root/.bashrc to add it
22:36:11 <mzero> BUT - why are you wanting to run sudo cabal?   You normally don't have to
22:36:27 <Vo1d> mzero, in / or in my /home?
22:36:36 <mzero> instead,  add
22:36:37 <mzero> root-cmd: sudo
22:36:43 <mzero> to your ~/.cabal/config file
22:36:55 <mzero> then, when you run     cabal --global install foo-bar
22:37:14 <mzero> it will do the download, unpack and compile all as you, and finally, just for the final install, do the sudo for you
22:37:29 <Vo1d> mzero, because I compile other program and it seek in /opt
22:37:40 <mzero> you don't need to do that as root
22:37:48 <mzero> use    cabal --global
22:38:02 <mzero> and add that line as I suggested to ~/.cabal/config
22:38:25 <Vo1d> mzero, ok I checked you tell me
22:39:15 <Welkin> Vo1d, why are you using such an old version of ubuntu anyway?
22:40:07 <Welkin> I think that version has only one year left of updates (assuming LTS)
22:40:17 <Vo1d> Welkin, because my pc is old and  its low power proccessing
22:40:21 <Welkin> less than that
22:40:45 <Welkin> use xubuntu or lubuntu
22:40:52 <Vo1d> Welkin, my pc not support new kernel it is very hardnes
22:41:22 <Vo1d> Welkin, not working for me, for that I use old ubuntu
22:46:37 <gamegoblin> Is there anything that goes Either a b -> Maybe b
22:46:46 <gamegoblin> That is, it converts Lefts to Nothings and Rights to Justs
22:47:23 <gamegoblin> mmm I suppose `either (const Nothing) Just myEither` ?
22:47:52 <jle`> yeah that's what i usually do
22:48:09 <jle`> i wonder if there is a better way
22:48:20 <startling> :t preview _Right
22:48:21 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
22:48:37 <jle`> oh hey `either` is the same as (|||) for (->)
22:48:42 <jle`> who would have known
22:48:46 <startling> :t (|||)
22:48:47 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
22:49:03 <startling> cute.
22:49:06 <jle`> :t (|||) `asAppliedTo` (undefined :: a -> b)
22:49:07 <lambdabot> (a -> b) -> (c -> b) -> Either a c -> b
22:49:24 <Iceland_jack> jle`: there is a function called ‘hush’
22:49:40 <Welkin> :t hush
22:49:41 <lambdabot> Not in scope: ‘hush’
22:49:51 <Iceland_jack> from Control.Error.Util, not part of base
22:49:52 <jle`> :t either
22:49:53 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
22:49:54 <Iceland_jack> http://hackage.haskell.org/package/errors-1.4.1/docs/Control-Error-Util.html
22:50:09 <Iceland_jack>     hush ∷ Either a b → Maybe b
22:50:09 <Iceland_jack>     note ∷ a → Maybe b → Either a b
22:50:54 <Iceland_jack> (most recent version of that library http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html)
22:51:11 <Iceland_jack> They should really be included in Data.{Maybe,Either}
22:52:11 <jle`> is that edwardk's domain
22:54:25 <mzero> well, I'd suspect that "hush" and "note" might be considered a bit too generic terms to be put in such a widely included library
22:54:29 <mzero> er, modules
22:54:41 <jle`> well, it'd be in base
22:55:09 <gamegoblin> also I don’t know why Data.Maybe has a fromJust, but Data.Either doesn’t have a fromRight or something
22:55:10 <mzero> adding "note" into those would surely cause tons of extant code to sprout warnings (at the very least) and break at the worst
22:55:30 <jle`> good point
22:55:39 <jle`> perhaps eitherToMaybe and maybeToEither are better names
22:55:47 <mzero> yes....
22:55:52 <jle`> to follow along with the trend of listToMaybe and maybeToList
22:56:25 <Welkin> you can just use those in your own personal library
22:56:30 <mzero> though, at that point....     either (const Nothing) Just         and   maybe (Left x) Right     seem somewhat clear
22:56:49 <jle`> Welkin: it's still a bit of friction when collaborating/having people read your code
22:58:07 <mzero> I often wish for the list destructor:        list z f as = case as of [] -> z ; _ -> f as
22:58:12 <johnw> the either package has those now
22:59:36 <mzero> and ditto for bool... though the "natural" form and consistent form are in conflict:      bool falseV trueV b = if b then trueV else falseV       whereas     if' trueV falseV b = if b then trueV else falseV
22:59:56 <Iceland_jack> there is a destructor function for bool since 7.8
22:59:57 <Iceland_jack> @ty bool
22:59:58 <lambdabot> a -> a -> Bool -> a
23:00:09 <Iceland_jack> > bool 'f' 't' False
23:00:10 <lambdabot>  'f'
23:00:31 <mzero> ah, the consistent way... which is actually often nicer in monadic code where this is desirable
23:01:30 <c_wraith> Iceland_jack: where's that exported?
23:01:40 <c_wraith> Is it in Prelude
23:01:41 <mzero>   doesFileExist f >>= bool (return "--missing--") $ do { c <- readFileContents f ; blah blah ; woof woof }
23:01:42 <c_wraith> ?
23:01:44 <Iceland_jack> Data.Bool
23:01:48 <c_wraith> ah, ok.
23:02:08 <c_wraith> mzero: wrong precedence between >>= and $
23:02:25 <mzero> ah, true dat
23:02:34 <Iceland_jack> mzero: 'blah blah' and 'woof woof' are also ill-typed :)
23:02:43 <Iceland_jack> @ty ?blah ?blah
23:02:44 <lambdabot>     Unbound implicit parameter (?blah::t0 -> t)
23:02:44 <lambdabot>       arising from a use of implicit parameter ‘?blah’
23:02:44 <lambdabot>     In the expression: ?blah
23:03:14 <c_wraith> :t const const
23:03:15 <lambdabot> b -> a -> b1 -> a
23:03:16 <mzero> Surely they are in the Nonsense monad
23:03:48 <Iceland_jack> c_wraith: fair enough :) polymorphism makes that joke invalid
23:03:50 <Iceland_jack> > id id
23:03:52 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:03:52 <lambdabot>    arising from a use of ‘M706670854563564601932612.show_M7066708545635646019...
23:03:52 <lambdabot>  The type variable ‘a0’ is ambiguous
23:03:52 <lambdabot>  Note: there are several potential instances:
23:03:52 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
23:03:59 <mzero> things like    const const    make me think back to days of writing Forth and coming up with arcane ways to fiddle the stack
23:03:59 <Iceland_jack> > (id id) a :: Expr
23:04:01 <lambdabot>  a
23:04:40 * hackagebot cake3 0.5.1.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.5.1.0 (SergeyMironov)
23:12:42 <gamegoblin> > (const const) 1 2 3
23:12:44 <lambdabot>  2
23:12:53 <gamegoblin> heh
23:13:19 <Welkin> :t const
23:13:20 <lambdabot> a -> b -> a
23:13:22 <Welkin> :t const const
23:13:27 <lambdabot> b -> a -> b1 -> a
23:13:32 <augur> so
23:13:34 <augur> i have a graph gluing algorithm :T
23:13:45 <pavonia> > (const const const) 1 2 3 4
23:13:47 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a1 -> t))
23:13:47 <lambdabot>    arising from the ambiguity check for ‘e_11234’
23:13:49 <lambdabot>  from the context (GHC.Num.Num (a -> a2 -> t),
23:13:51 <lambdabot>                    GHC.Num.Num a2,
23:13:55 <lambdabot>                    GHC.Num.Num a)
23:13:59 <gamegoblin> :t const const const
23:14:01 <mzero> > (const const const) 1 2
23:14:01 <Welkin> :t const const const
23:14:05 <lambdabot> a -> b -> a
23:14:07 <lambdabot> a -> b -> a
23:14:09 <lambdabot>  1
23:14:10 <Iceland_jack> you probably want (const (const const))
23:14:13 <Welkin> :t const . const . const
23:14:14 <lambdabot> a -> b -> b1 -> b2 -> a
23:14:25 <gamegoblin> This is getting hilariously dumb
23:14:27 <Iceland_jack> > (const (const const)) 1 2 3 4
23:14:28 <lambdabot>  3
23:14:51 <pavonia> > (const $ const $ const const) 1 2 3 4 5
23:14:52 <lambdabot>  4
23:14:54 <gamegoblin> :t const (const const)
23:14:54 <lambdabot> b -> b1 -> a -> b2 -> a
23:14:59 <Welkin> > const . const . const $ 1 2 3 4
23:15:00 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a1 -> a2 -> s))
23:15:00 <lambdabot>    arising from the ambiguity check for ‘e_11234’
23:15:00 <lambdabot>  from the context (GHC.Num.Num (a -> a3 -> a4 -> s),
23:15:00 <lambdabot>                    GHC.Num.Num a4,
23:15:00 <lambdabot>                    GHC.Num.Num a3,
23:15:11 <gamegoblin> > fix id 1
23:15:15 <lambdabot>  mueval-core: Time limit exceeded
23:15:19 <Welkin> > (const . const . const) 1 2 3 4
23:15:20 <lambdabot>  1
23:15:21 <Iceland_jack> :t (const (const const)) :: a → b → thisoneistheone → c → thisoneistheone
23:15:22 <lambdabot> a -> b -> thisoneistheone -> c -> thisoneistheone
23:15:36 <Welkin> > (const (const . const)) 1 2 3 4
23:15:37 <lambdabot>  2
23:15:42 <Welkin> > (const (const const)) 1 2 3 4
23:15:44 <lambdabot>  3
23:16:13 <Welkin> :t fix
23:16:13 <lambdabot> (a -> a) -> a
23:16:22 <Welkin> @src fix
23:16:22 <lambdabot> fix f = let x = f x in x
23:17:19 <Iceland_jack>     fix f = f (fix f)
23:17:19 <Iceland_jack> is a nicer definition (but less efficient)
23:18:50 <jle`> flip const is const id
23:18:52 <jle`> can't explain that
23:19:04 <lfairy> @pl \a b c d -> a
23:19:04 <lambdabot> const . const . const
23:19:09 <lfairy> @pl \a b c d -> b
23:19:09 <lambdabot> const (const . const)
23:19:16 <lfairy> hmph
23:19:24 <lfairy> @pl \a b c d -> c
23:19:24 <lambdabot> const (const const)
23:19:26 <lfairy> @pl \a b c d -> d
23:19:26 <lambdabot> const (const (const id))
23:20:15 <systemfault> How often do you need to deal with exceptions in Haskell? I’m reading about them and Either seems to be better for most cases :/
23:20:36 <mzero> alas, anytime you deal with Posix, you need to handle exceptions
23:20:39 <jle`> systemfault: exceptions are mainly used for things involving IO semantics
23:20:47 <Iceland_jack> systemfault: Either and exceptions are not the same, but you can turn exceptions into Either using 'try'
23:20:48 <Iceland_jack> @ty try
23:20:48 <mzero> but, in your own code, yes, I'd suggest stick with Either
23:20:49 <jle`> like disk reads
23:20:49 <lambdabot> Exception e => IO a -> IO (Either e a)
23:20:53 <jle`> asynchronous errors
23:21:03 <jle`> interrupts, etc.
23:21:15 <Iceland_jack> also you have a concept of asynchronous exceptions that you cannot model with Either at all
23:21:27 <jle`> the idea is that Exceptions and Either are different "things", semantically/meaningfully
23:21:46 <systemfault> I was seeing both as a way to deal with errors. :/
23:21:48 <MorpheusBeing> How would I get a random number in a specified range for helping gkids learn tables/division 0-12. I am trying to do this in haskell as mental exercise
23:21:58 <Iceland_jack> systemfault: They are, but they're still different things
23:22:01 <lfairy> stuff like catching Ctrl-C and thread termination can only be handled with exceptions
23:22:22 <jle`> systemfault: different "domains" of errors, per se.  they are really distinct pictures of what "error" can mean
23:22:23 <Iceland_jack> Like lfairy said, you certainly can't only use Either to deal with asynchronous exceptions
23:22:39 <jle`> one can think of Either as accounting for "partial"/non-total, pure functions
23:22:47 <jle`> errors like...divide by zero
23:22:51 <jle`> head on an empty list
23:23:12 <systemfault> Iceland_jack: Ah, I haven’t read about asynchronicity with Haskell yet… I don’t even know if Haskell has Promises/Futures or something similar.
23:23:14 <jle`> and you can think of Exception as a runtime mechanism
23:23:21 <Iceland_jack> systemfault: it does
23:23:22 <jle`> that you can take advantage of when writing IO ()
23:23:28 <jle`> ...i'm not sure if you've encountered IO yet
23:23:34 <jle`> or the semantics of what the IO type represents
23:23:37 <Iceland_jack> Haskell actually has a much nicer story for async exceptions than most languages because of the purity
23:23:51 <systemfault> Yeah, I’ve encountered IO and I think I understand how it works
23:24:04 <Iceland_jack> But 'Either' doesn't involve any side-effects, an exception does
23:24:06 <jle`> IO actions are "run" in a runtime
23:24:12 <jle`> runtime environment
23:24:39 <jle`> exceptions can be thought of as...tools the runtime environment gives you to deal with unexpected runtime/IO occurrences
23:24:42 <jle`> "unexpected"
23:24:54 <jle`> like, disk read errors (file not found)
23:24:57 <MP2E> unexpectedly expected
23:25:03 <jle`> expectedly unexpected perhaps
23:25:04 <Iceland_jack> MP2E: well put :)
23:25:09 <systemfault> I get it now, thanks :)
23:25:11 <jle`> or CTRL+C interrupts
23:25:30 <jle`> systemfault: yeah, one guideline is that Either perhaps takes the place of "filling out non-total/partial 'pure' functions"
23:25:44 <Iceland_jack> systemfault: When possible, you almost always want to prefer a pure way of handling things (something like Maybe, Either, ...)
23:25:45 <jle`> which is a very different sort of domain than disk errors, asynch errors, interrupts, etc.
23:26:00 <jle`> there is no reason why pure code (not in IO) should ever involve Exceptions
23:26:04 <jle`> (ideally)
23:26:13 <jle`> because Exceptions belong in the "world" of IO
23:26:16 <Iceland_jack> Not like in Python when it's idiomatic to catch an exception to check if parsing an integer from a string failed
23:26:26 <systemfault> Unrelated but… Anyone has something (book/tutorial) about type kinds, something not too “mathy”. LYAH has a few paragraphs on it but I don’t think I got it right.
23:26:44 <jle`> just play around with :k :)
23:26:44 <systemfault> I thought of rereading that chapter later… when I know more
23:26:54 <Iceland_jack> systemfault: In Haskell without extensions there really isn't much to stay
23:26:56 <Iceland_jack> *say
23:27:00 <Iceland_jack> @kind Int
23:27:01 <lambdabot> *
23:27:03 <Iceland_jack> @kind Bool
23:27:04 <lambdabot> *
23:27:10 <systemfault> @kind Either
23:27:11 <lambdabot> * -> * -> *
23:27:11 <Iceland_jack> * is the ‘type of types’
23:27:17 <systemfault> @kind Either Int
23:27:18 <lambdabot> * -> *
23:27:24 <systemfault> That’s what I “expect”
23:27:35 <MP2E> like systemfault : that may be useful :) What about kinds confuses you? They are a little abstract so they are a little difficult to get a 'hold' on. But essentially they are the 'type of types'. Or perhaps, better put as the 'generic shape of an object'
23:27:41 <MP2E> -like
23:27:50 <systemfault> Then later in the tutorial, the guy starts creating a Tofu typeclass and other nonesense
23:27:50 <MP2E> dunno how that got in there hehe
23:28:08 <jle`> systemfault: one thing the idea of kinds is helpful for is figuring out what "things" can go in a type signature
23:28:09 <Iceland_jack> systemfault: That isn't that great of an example
23:28:16 <jle`> for example, you can't have f :: a -> Maybe
23:28:22 <Iceland_jack> But systemfault, do you know Functors?
23:28:25 <jle`> that's a big wtf
23:28:39 <systemfault> Iceland_jack: Anything that can be mapped on, right?
23:28:46 <Iceland_jack> Something like that
23:28:58 <systemfault> @type fmap
23:28:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:29:00 <Iceland_jack> You know that IO, [], Maybe are Functors?
23:29:07 <systemfault> Iceland_jack: Yes, I got that
23:29:17 <Iceland_jack> Because you can do
23:29:17 <Iceland_jack>     (a -> b) -> IO a -> IO b
23:29:17 <Iceland_jack>     (a -> b) -> [] a -> [] b
23:29:17 <Iceland_jack>     (a -> b) -> Maybe a -> Maybe b
23:29:27 <Iceland_jack> systemfault: Well, can you make Int a Functor?
23:29:40 <systemfault> No because it’s a concrete type?
23:29:57 <Iceland_jack> Right, so functor expects something of this kind: '* -> *'
23:30:11 <jle`> (a -> b) -> Int a -> Int b  -- makes no sense
23:30:18 <systemfault> Iceland_jack: Where I get confused…
23:30:21 <systemfault> @kind Either
23:30:22 <lambdabot> * -> * -> *
23:30:23 <jle`> "kinds" give you the sort of framework for thinking "why"
23:30:29 <jle`> (a -> b) -> Either a -> Either b
23:30:29 <systemfault> So Either isn’t a functor? But
23:30:33 <Iceland_jack> systemfault: You can think of it being like functions
23:30:33 <systemfault> @kind Either Int
23:30:34 <lambdabot> * -> *
23:30:35 <systemfault> is?
23:30:39 <Iceland_jack> systemfault: that's right
23:30:39 <jle`> yop, Either is not a Functor
23:30:48 <jle`> because (a -> b) -> Either a -> Either b makes no sense
23:30:52 <jle`> but Either Int is!
23:30:59 <jle`> (a -> b) -> Either Int a -> Either Int b
23:31:02 <jle`> that makes perfect sense
23:31:17 <jle`> remember, the type is (a -> b) -> f a -> f b
23:31:22 <jle`> and you ask "what makes sense to go where 'f' is?"
23:31:24 <Iceland_jack>     Either     :: * -> * -> *   (can't be a Functor)
23:31:24 <Iceland_jack>     Either a   :: * -> *        (can be a Functor)
23:31:24 <Iceland_jack>     Either a b :: * -> *        (can't be a Functor)
23:31:34 <Iceland_jack> oops!
23:31:38 <Iceland_jack> the last one should have been *
23:31:49 <Iceland_jack> :kind forall a b. Either a b
23:31:54 <Iceland_jack> @kind forall a b. Either a b
23:31:55 <lambdabot> *
23:32:02 <systemfault> I haven’t learned about forall yet :/
23:32:08 <jle`> you can think of it as english
23:32:18 <Iceland_jack> there's nothing to learn about in this case
23:32:30 <jle`> it is exactly what you'd expect it to mean as if it were just an english comment in the code
23:32:38 <systemfault> Then what’s the point?
23:32:40 <Iceland_jack> systemfault: Just like
23:32:40 <Iceland_jack>     f :: A -> B
23:32:40 <Iceland_jack> is a function
23:32:44 <jle`> :k Either a b
23:32:45 <lambdabot> Not in scope: type variable ‘a’
23:32:45 <lambdabot> Not in scope: type variable ‘b’
23:32:46 <jle`> ^ that's the point
23:32:56 <MP2E> systemfault : It does more than a comment, it's just that the word very aptly says what it does :)
23:32:57 <Iceland_jack> 'Maybe' is a function
23:33:13 <Iceland_jack> (or you can think of it like that)
23:33:26 <systemfault> @kind forall a b. Either a b
23:33:27 <lambdabot> *
23:33:32 <systemfault> @kind Either a b
23:33:33 <lambdabot> Not in scope: type variable ‘a’
23:33:33 <lambdabot> Not in scope: type variable ‘b’
23:33:35 <jle`> :t (a, b)
23:33:36 <lambdabot> (Expr, Expr)
23:33:36 <systemfault> I see
23:33:39 <trap_exit> I propose a syntax extension to haskell
23:33:50 <jle`> oops
23:33:57 <Iceland_jack> So Functor tells you that its argument must be a 'function' that takes a single type (* -> *)
23:33:58 <Iceland_jack>     class Functor (f :: * -> *) where
23:33:58 <Iceland_jack>         fmap :: (a -> b) -> f a -> f b
23:34:06 <trap_exit> so I can do something like #(foo "hi" %1 "test" %2) --> (\x y -> foo "hi" x "test" y)
23:34:24 <Iceland_jack> trap_exit: (#) is a valid operator :)
23:34:28 <trap_exit> basically the # says "create a closure,
23:34:34 <systemfault> Iceland_jack: I’m just a bit confused about how Either a, being a functor can be useful to me
23:34:34 <trap_exit> then %1 and %2 repsent locations for lambda variables
23:34:46 <Iceland_jack> systemfault: Well that's a different question :)
23:35:01 <lithiumdeuteride> reminds me of #1, #2, etc. in Mathematica
23:35:03 <Iceland_jack> Are you asking why Functor is useful in general?
23:35:19 <lithiumdeuteride> aka 'slot 1', 'slot 2'
23:35:20 <trap_exit> lithiumdeuteride: yes, basically that
23:35:33 <systemfault> Iceland_jack: I have a vague idea of how they can be useful
23:36:14 <Iceland_jack> systemfault: They have a very deep importance but you can just think of it as a convenient accident that you can 'map' over many different things using the same function
23:36:26 <jle`> systemfault: you seem to understand that Either e a represents an `a` that might have errored, with an error type of e
23:36:29 <jle`> right?
23:36:36 <systemfault> Yes
23:36:39 <jle`> well
23:36:48 <jle`> let's say I have an Either e Int
23:37:01 <jle`> according to you, it should be as "useful" as a "normal" Int
23:37:12 <jle`> that is, it should be able to be used, semantically, as if it were just any other Int
23:37:19 <jle`> otherwise...it'd be pretty useless
23:37:30 <jle`> so i have a function f :: Int -> Bool
23:37:34 <jle`> i like my function
23:37:41 <jle`> but i want to be able to use it on an (Either e Int)
23:37:48 <jle`> normally, this would be bad news for me.
23:37:56 <jle`> because f doesn't take (Either e Int)
23:38:03 <systemfault> Yeah.. I would need to unwrap… apply the function… rewrap
23:38:06 <jle`> --- remember, you're imagining that Either e Int is "just a normal Int, that could have errored"
23:38:18 <jle`> well, fmap gives you a function (Int -> Bool) -> (Either e Int -> Either e Bool)
23:38:30 <jle`> it turns your (Int -> Bool) function into an (Either e Int -> Either e Bool) functino
23:38:47 <jle`> so now my useful f :: Int -> Bool can be used on my "errorful Int"....as if it were a normal Int
23:38:49 <killy9999> does anyone have a copy of "Term Rewriting Systems" by Klop that has correct Figures?
23:38:59 <killy9999> all PDFs I've found have missing figures :-/
23:39:05 <jle`> it basically makes the "errorful" abstraction...actually useful
23:39:23 <systemfault> jle`: Ah, that’ simple explained like that
23:39:27 <jle`> > fmap (> 0) (Right 4)
23:39:27 <mzero> oh deal... hscurses package is begining to bitrot
23:39:28 <lambdabot>  Right True
23:39:32 <jle`> > (> 0) (Right 4)
23:39:33 <lambdabot>  No instance for (GHC.Classes.Ord b0)
23:39:33 <lambdabot>    arising from a use of ‘GHC.Classes.>’
23:39:33 <lambdabot>  The type variable ‘b0’ is ambiguous
23:39:33 <lambdabot>  Note: there are several potential instances:
23:39:33 <lambdabot>    instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a)
23:39:37 <Iceland_jack> yes that's a good explanation jle`
23:39:37 <jle`> can't do that
23:39:45 <jle`> > fmap (> 0) (Left "error")
23:39:46 <lambdabot>  Left "error"
23:40:06 <jle`> ...this is the sort of intuition i apply to ever Functor, actually
23:40:14 <Iceland_jack> systemfault: Just to make sure to hammer this point in, when you have a Functor 'f = Either e fmap looks like this
23:40:14 <Iceland_jack>     fmap :: (a -> b) -> (Either e) a -> (Either e) b
23:40:41 <jle`> IO Int is "an object representing computer instructions that when executed produce an Int"
23:40:51 <jle`> that's nice and all...but I want to apply my f :: Int -> Bool function to it
23:40:57 <jle`> is my f useless?
23:41:03 <jle`> no!  fmap f :: IO Int -> IO Bool
23:41:10 <jle`> ...that's sort of how i understand functors
23:41:14 <Peaker> hey, do I need to add -rtsopts -with-rtsopts=-N to a program so it can make use of multicore?  Shouldn't it be the default?
23:41:28 <Iceland_jack> [Int] is a list of ints :) I want to apply my f :: Int -> Bool function to it,
23:41:28 <Iceland_jack>     fmap f :: [Int] -> [Bool]
23:41:29 <systemfault> jle`: I think i can build off an intuition from what you told me
23:41:31 <Iceland_jack> etc. etc.
23:41:32 <MP2E> > fmap (> 0) [1,-2,5,-4,2]
23:41:33 <lambdabot>  [True,False,True,False,True]
23:41:34 <Peaker> also, -rtsopts is a security issue -- so requiring it to make use of multicore is a really bad thing
23:41:52 <jle`> they let you treat contextful values as if they were normal values...making the abstraction seamless
23:41:58 <systemfault> jle`: And Monad are like functors with additional rules if I understand correctly.
23:42:06 <systemfault> So is Applicative
23:42:08 <Iceland_jack> systemfault: that's right
23:42:21 <jle`> systemfault: i don't mean to be self-promoting but i wrote a post elaborating on this intuition http://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad
23:42:22 <Iceland_jack> systemfault: Do you see why these are wrong?
23:42:22 <Iceland_jack>     fmap :: (a -> b) -> Either       a -> Either       b
23:42:22 <Iceland_jack>     fmap :: (a -> b) -> (Either e f) a -> (Either e f) b
23:42:34 <systemfault> jle`: I’ll read it for sure :)
23:42:50 <Iceland_jack> (where Either has kind '* -> * -> *', 'Either e f' has kind '*')
23:43:23 <systemfault> Iceland_jack: Your last one confuses me
23:43:41 <Iceland_jack> Okay, how come?
23:44:05 <Iceland_jack> Note that the second one is the only correct one:
23:44:05 <Iceland_jack>     fmap :: (a -> b) -> Either       a -> Either       b
23:44:05 <Iceland_jack>     fmap :: (a -> b) -> (Either e)   a -> (Either e)   b
23:44:05 <Iceland_jack>     fmap :: (a -> b) -> (Either e f) a -> (Either e f) b
23:44:39 <solidus-river> i'm confused YET again about netwire statefull wires :S
23:46:29 <systemfault> Iceland_jack: Wouldn’t the third one be like  fmap :: (a -> b) -> (Either e) f a -> (Either e) f b (I’m still a bit confused)
23:46:52 <Iceland_jack> systemfault: read the type of ‘fmap’ and replace every 'f' with 'Either e'
23:46:54 <Iceland_jack> @ty fmap
23:46:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:47:16 <systemfault> Ah
23:47:17 <Iceland_jack> also note that
23:47:18 <Iceland_jack>     (Either e) a = Either e a
23:47:24 <Iceland_jack> @ty fmap :: (a -> b) -> (Either e) a -> (Either e) b
23:47:25 <lambdabot> (a -> b) -> Either e a -> Either e b
23:47:54 <systemfault> I think I got it
23:47:59 <Iceland_jack> okay good :)
23:48:19 <Iceland_jack> So you get why 'Either' and 'Either e f' can't be Functors or Applicatives or Monads
23:48:40 <systemfault> Yes :)
23:48:41 <solidus-river> i'm still confused about creating a monad wtih state
23:48:43 <Iceland_jack> cool
23:48:55 <systemfault> Thank you so much Iceland_jack and jle` :)
23:49:02 <Iceland_jack> You're very welcome
23:49:09 <systemfault> Off for a few minutes to read jle` ’s article
23:49:30 <jle`> yw systemfault
23:49:42 <solidus-river> jle`: evenin :)
23:49:46 <jle`> hey :)
23:49:50 <solidus-river> jle`: so i've hit more pitfalls with the way i'm seeing netwire
23:50:02 <solidus-river> i was thinking i would just whip up a wire that has state AND a time delta
23:50:21 <solidus-river> but looking at it more carefully, it seems like i'd need to make up a new state monad with has time and my state and supply that as s
23:50:28 <solidus-river> if i didn't want the internal state to be of type a
23:50:44 <systemfault> And when we’re talking about higher-kinded types, does it means anything like Functor/Monad/Applicative or it’s totally something else?
23:51:13 <jle`> solidus-river: i'm nto sure what you are using this for
23:51:32 <solidus-river> let my try out a paste bin that makes sense
23:51:32 <jle`> you can do the same thing you did with the time-ignoring wire
23:52:14 <solidus-river> but what if i wanted time and state and a != to state != b
23:52:24 <solidus-river> it looks like MkGen expects the state to be of type a
23:52:33 <jle`> MkGen doesn't know anything about the state
23:52:33 <solidus-river> or s is the state
23:52:37 <jle`> the state is your recursive call
23:52:39 <jle`> remember
23:52:41 <solidus-river> right
23:53:02 <solidus-river> so i'd pas the state' in as s in the recursive call
23:53:07 <solidus-river> but i also want a time delta in there
23:53:11 <Iceland_jack> systemfault: there are higher kinded types, like Functor itself
23:53:14 <Iceland_jack> @kind Functor
23:53:15 <lambdabot> (* -> *) -> Constraint
23:53:16 <jle`> your time delta is the function
23:53:22 <jle`> that you give to MkGen
23:53:23 <solidus-river> so does that mean i now need to make a tuple of (state, dt)
23:53:25 <jle`> er, it's one of the arguments
23:54:11 <jle`> let's look at mkSF, to simplify things
23:54:30 <solidus-river> jle`: aye, but.. hmmm if i give that a time delta
23:54:38 <jle`> mkSF :: (t -> a -> (b, Wire a b)) -> Wire a b
23:54:42 <solidus-river> let me take a whack at it in lpaste and show you when my mind implotes
23:54:43 <jle`> ^ in a simplified wire type
23:54:44 * hackagebot authoring 0.3.4 - A library for writing papers  http://hackage.haskell.org/package/authoring-0.3.4 (TakayukiMuranushi)
23:54:54 <solidus-river> ok, but then t is the state
23:54:57 <solidus-river> but what if i wanted time as well
23:54:58 <jle`> no
23:55:00 <jle`> t is the time delta
23:55:07 <jle`> same as for the real mkSF
23:55:10 <solidus-river> then where is the state o_o
23:55:18 <jle`> it's in the recursive call
23:55:23 <jle`> okay, remember out countFrom?
23:55:26 <solidus-river> yeah
23:55:36 <solidus-river> this is what i get for leaving my house on the weekend
23:55:41 <solidus-river> i forgot a lot of the stuff we talked about
23:55:52 <solidus-river> or i remember it but its fuzzy
23:55:57 <jle`> countFrom i0 = mkSF (\_ _ -> (i0, countFrom i0 + 1))
23:56:27 <jle`> it's similar to the Stream examples i had in my Stream/Auto tutorial
23:56:50 <jle`> so countFrom 0 is a Wire that counts frm 0, 1, 2, 3 ... etc.
23:56:59 <jle`> countFrom 100 counts form 100, 101, 102, etc.
23:57:06 <jle`> er sorry, there should be parentheses there
23:57:12 <jle`> countFrom i0 = mkSF (\_ _ -> (i0, countFrom (i0 + 1)))
23:57:32 <efzee> exit
23:57:40 <jle`> which says "in the Wire, ignore the time delta and the input, and just return the "current count", i0, and the "next wire", countFrom (i0 + 1)
23:57:48 <solidus-river> so \_ _
23:57:52 <solidus-river> is \dt input
23:57:58 <jle`> if we do countFrom 0, that'd be "ignore the time delta and the input, and return (0, countFrom 1)
23:58:02 <solidus-river> so i0 is the state
23:58:03 <jle`> yes
23:58:08 <jle`> i0 is the "state"
23:58:15 <solidus-river> trixy hobbits!
23:58:20 <jle`> the wire itself doesn't know about the state
23:58:30 <solidus-river> i guess thats one of the really cool things about it
23:58:31 <MP2E> boil 'em mash 'em stick 'em in a stew
23:58:37 <Iceland_jack> systemfault: Also 'higher-order type operators', they're not as common as
23:58:37 <Iceland_jack>     *             (proper types: Bool, Bool -> Int, ...)
23:58:37 <Iceland_jack>     * -> *        (type operators: IO, Maybe, Either e, ...)
23:58:37 <Iceland_jack>     (* -> *) -> * (higher-order type operators: Fix, ...)
23:58:44 <jle`> yeah, i explained some of the interesting implications of this
23:58:51 <solidus-river> jle`: i did more readin gon arrow syntax and monad fix / recursion
23:58:58 <jle`> for example, you can even have a wire that has a state type that alternates dynamically
23:59:22 <zq> sup guys
23:59:25 <jle`> also, the more important thing is that the state is completely inaccessible
23:59:27 <jle`> to the outside world
23:59:30 <solidus-river> jle`: its turtles.. all the way down
23:59:34 <solidus-river> jle`: yeah, that part is really really cool
23:59:44 <jle`> there is no way to "extract the state" if a Wire a b, if all you have is the wire
