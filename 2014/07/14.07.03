00:02:53 <ninja_code> has anyone done (for learning purposes) implemented relational algebra in ahskell as a DSL?
00:03:48 <Lutin`> brrrrian: I would suggest using repa. I just rewrote your program using it and it's blazing fast
00:04:37 <kvanb> yeah repa is ridiculous
00:05:03 <kvanb> I remember seeing a chart in a use case where it was ~20x faster than using Vector in a certain use case
00:05:28 <Lutin`> tbh I thought something was wrong with the program
00:05:32 <Lutin`> Because it completed so fast
00:05:38 <kvanb> haha
00:08:42 * hackagebot benchmark-function 0.1.0.0 - Test the time it takes to run a haskell function  http://hackage.haskell.org/package/benchmark-function-0.1.0.0 (AlanHawkins)
00:08:42 * hackagebot despair 0.0.1 - Despair  http://hackage.haskell.org/package/despair-0.0.1 (Heather)
00:09:53 <kvanb> fyi people interested in benchmark-function may like criterion too
00:09:58 <kvanb> it generates html reports
00:10:31 <ivanm> well, it prints to the console by default
00:11:10 * ivanm isn't sure what the point of the despair package is
00:12:06 <kvanb> ivanm: it generates despair quotes
00:12:10 <kvanb> read the source code
00:12:31 <Lutin`> brrrrian: http://lpaste.net/106837
00:13:04 <Lutin`> @tell brrrrian http://lpaste.net/106837
00:13:04 <lambdabot> Consider it noted.
00:14:13 <Lutin`> It's just so simple
00:14:48 <Lutin`> and the parallelism seems to only be restricted in reading and writing the file
00:15:01 <ivanm> kvanb: yes, but why would you want it to do so
00:15:39 <kvanb> ivanm: to clutter hackage
00:15:59 <kvanb> so that when we run surveys of hackage properties, there is a slight error incurred by joke/useless packages
00:17:10 <kvanb> Lutin`: although, I suspect that could be avoided using pipes-concurrency
00:17:29 <kvanb> and running repa over chunks while 2 async threads read/write from buffers back into the file
00:19:15 <Lutin`> I mean it's still 366% on 4 cores and 282% on 3
00:22:37 <jle`> i feel like dimap should have its arguments reversed
00:22:52 <Lutin`> It's not the worst threadscope I've seen https://clbin.com/kLmX47.png
00:22:54 <jle`> for example, for the (->) instance of Profunctor
00:23:05 <jle`> dimap f g h is g . h . f
00:23:11 <jle`> which isn't to intuitive
00:23:21 <Lutin`> oh lol didn't know scrot would caputre both of my screens
00:23:37 <jle`> i would have expected dimap f g to be \h -> g . h . f
00:23:53 <Lutin`> wait
00:23:59 <Lutin`> Isn't that exactly what it is?
00:24:06 <Lutin`> based on what you just said
00:24:06 <jle`> er sorry
00:24:08 <jle`> i mean
00:24:13 <jle`> dimap f g to be \h -> f . h . g
00:24:17 <Lutin`> Ah
00:24:23 <jle`> because the f is on the left hand side and the g is on the right hand side
00:24:25 <jle`> of the composition
00:24:45 <jle`> in dimap's convention, the f is on the left hand side of "the type", and g is on the right hand side of "the type"
00:25:05 <jle`> so f affects the first type parameter and and g affecs the second parameter
00:25:12 <jle`> which makes sense i guess but whenever i actually write dimap
00:25:24 <jle`> i keep on thinking it to be the other way, when you actually type down the application
00:25:38 <jle`> dimap f g = \h -> g . h . f
00:25:40 <jle`> it gets switched :O
00:25:45 <jle`> weird.
00:28:01 <joelteon> is there a reason Data.Sequence doesn't export a toList function?
00:29:24 <Peaker> @type toList
00:29:25 <lambdabot>     Not in scope: ‘toList’
00:29:25 <lambdabot>     Perhaps you meant one of these:
00:29:25 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
00:29:29 <Peaker> @type F.toList
00:29:30 <lambdabot> Foldable t => t a -> [a]
00:29:38 <Peaker> joelteon: it's a Foldable instance
00:30:15 <kvanb> I sometimes wonder if it would be helpful for Hackage to display things when you hover classes
00:30:35 <Lutin`> jle`: To me it makes sense because I read `dimap f g` as dimap f then g
00:30:44 <Lutin`> So g.h.f makes sense
00:30:56 <jle`> but do yuo read g.h.f as "do g then h then f"?
00:31:00 <Lutin`> no
00:31:06 <Lutin`> g following h following f
00:31:08 <jle`> yeah, it just feels a little ad hoc
00:31:19 <jle`> nothing else in haskell works that way, except for (>>=)
00:31:38 <jle`> ad hoc and/or inconsistent with how haskell trains you to think
00:31:53 <joelteon> man, I wish qualified imports were default
00:31:57 <Peaker> well, the order of effects may be emphasized, vs. the data flow
00:32:20 <Peaker> joelteon: agreed, messed up namespaces is one of the horrible things in the Haskell community :(
00:32:42 <Lutin`> jle`: It's a real interesting issue, the composition operator
00:32:46 <kvanb> is there a way to change the name of an import
00:32:53 <kvanb> sometimes operators clash and its annoying
00:33:04 <jle`> kvanb: you can just alias/rename them
00:33:13 <kvanb> ie, can I alias <*> as <x>
00:33:16 <joelteon> no
00:33:19 <joelteon> not anymore
00:33:35 <jle`> you can't alias (<*>) as (<x>), but maybe as (<*~*>)
00:33:47 <jle`> (<*~*>) = (Control.Applicative.<*>)
00:33:50 <joelteon> but you'd have to do that yourself anyway
00:33:58 <joelteon> the renaming clause is long dead
00:34:13 <kvanb> the renaming clause sounds more like I had wanted
00:34:31 <joelteon> shouldn't be hard, just download GHC 6.12
00:34:38 <kvanb> lol
00:34:53 <kvanb> why was it removed
00:35:01 <joelteon> probably because it's not a very good idea
00:35:42 <Guest31002> Hey, Is there assignment operation in Haskell ? If not how is assigning a value to immutable variable done ? Thanks
00:35:52 <jle`> Peaker: i don't feel like dimap is such a case
00:35:56 <ivanm> Guest31002: monadically
00:36:00 <ivanm> typically either in IO or ST
00:36:03 <kvanb> to an immutable value
00:36:07 <ivanm> oh, wait, _immutable_
00:36:08 <kvanb> he probably means like
00:36:10 <ivanm> yeah, I missed the "im"
00:36:12 <jle`> Guest31002: Haskell doesn't have an assignment statement/ooperation
00:36:12 <kvanb> > let { x = 3 } in x
00:36:13 <lambdabot>  3
00:36:15 <jle`> geekosaur: it only has definitions
00:36:16 <Peaker> jle`: was talking about imports being unqualified by default
00:36:18 <jle`> er sorry, Guest50458
00:36:31 * ivanm shows himself out
00:36:38 <jle`> Guest50458: it only has definitions
00:36:43 <kvanb> does it work in lambdabot without braces ... probably not
00:36:46 <kvanb> > let x = 3 in x
00:36:47 <lambdabot>  3
00:36:51 <kvanb> Oh, it does.
00:37:07 <whyy> jle` : SO it has single assignment ?
00:37:07 <jle`> when you say x = 3, you aren't saying "assign x to 3".  you're saying "x is defined as 3...and every time you see x, you can replace it mentally/textually/with a 3"
00:37:25 <jle`> whyy: it's almost like you can run a sed command over your file, s/x/3/g
00:37:27 <kvanb> let f x = x + 4 in f 5
00:37:31 <kvanb> > let f x = x + 4 in f 5
00:37:32 <lambdabot>  9
00:37:36 <jle`> whyy: not assignment; definition
00:37:45 <jle`> assignment is an action; definition is...just how things are
00:38:01 <ivanm> hence using = makes more sense than it does in C, etc. ;-)
00:38:09 <jle`> you can't define x as 4, and then later define x as 7
00:38:17 <jle`> that's just crazy talk
00:38:28 <jle`> imagine reading a math text book and reading "we define pi as 3.141..."
00:38:35 <jle`> and then the next page saying "we define pi as 6.19454.."
00:38:52 <ivanm> jle`: well, if you ignore variable shadowing... ;-)
00:38:58 <jle`> pi is not an "immutable assignment", it's a definition
00:39:04 <jle`> ivanm: variable shadowing isn't mutation
00:39:06 <Peaker> Ok, just made a little test program that shows that even a WriterT without mappend-thunk-buildup (uses undefined in place of the writer) is a memory hog, in the program: runWriterT $ replicateM_ n (lift $ modifyIORef' i (+1))   (O(n) memory!  StateT is O(1) memory)
00:39:13 <jle`> but yeah, heh. it's a definition inside a smaller scope
00:39:21 <whyy> jle` : So defining is same as single assignment in layman terms ?
00:39:24 <ivanm> jle`: which was my poing :)
00:39:26 <ivanm> *point
00:39:34 <kvanb> Peaker: that's been known a long while
00:39:39 <kvanb> Gabriel offers alternatives I think
00:39:48 <jle`> whyy: not really, because "assignment" is an imperative act
00:39:51 <Peaker> kvanb: I read Gabriel complaining about mappend thunks
00:40:02 <jle`> if you have an immutable variable x in a program with assignments
00:40:05 <jle`> then you can't use x before it's assigned
00:40:12 <Peaker> kvanb: the problem is the pattern matching that needs to happen after the second bind
00:40:19 <jle`> you compute things...do this, do that...and then arrive at a value, which you "assign" to the immutable cell x
00:40:26 <jle`> *before* you assign x, you can't use x
00:40:42 <Peaker> kvanb: Perhaps transformers should implement WriterT in terms of StateT?
00:40:50 <jle`> x only makes sense *after* its assignment
00:40:54 <ivanm> whereas in Haskell, you can have a value defined in terms of itself! ;-)
00:40:56 <Peaker> because this is really problematic behavior
00:40:57 <jle`> but definition...there is no "before" or "after"
00:40:58 <kvanb> that could be one way of doing it
00:41:08 <jle`> "before" or "after" doesn't make any sense in the context of a definition
00:41:12 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
00:41:13 <lambdabot>  not an expression: ‘let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)’
00:41:14 <kvanb> although the "better" way of doing it honestly
00:41:17 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
00:41:17 <matematikaadit> whyy: assigment is like treating a variable like a box. you assign a value to a variable is like the variable get that value.
00:41:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:41:19 <kvanb> is to use pipes and yield values out
00:41:21 <Peaker> kvanb: WriterT is currently a timebomb in the standard library :(
00:41:34 <kvanb> the whole concept of WriterT is anti-haskel
00:41:39 <kvanb> Haskell is about streaming computation
00:41:42 <Peaker> kvanb: I disagree completely
00:41:43 <Gurkenglas> wwhy, defining x in haskell works like defining main in C, or Java
00:41:49 <Gurkenglas> *whyy
00:41:53 <Peaker> kvanb: that's a very narrow view of what Haskell is about
00:42:01 <Peaker> kvanb: I am using ParsecT over WriterT over IO
00:42:02 <kvanb> that's one of its strongest points, being lazy
00:42:05 <jle`> Gurkenglas, whyy: yeah, main isn't "assigned"; it's defined
00:42:37 <Peaker> kvanb: what benefit would a pipe have over just replacing my WriterT with StateT?
00:42:42 <Peaker> brb
00:42:47 <kvanb> you handle things you write immediately
00:43:01 <kvanb> so if your pipe writes to a file, you dump it out to the file straight away
00:43:29 <Gurkenglas> (So basically it's an assignment at compiletime/start of runtime?)
00:43:34 <kvanb> (and then it can be garbage collected)
00:43:42 <Lutin`> It's assigned in your text editor
00:43:44 <Lutin`> lol
00:43:50 <kvanb> Gurkenglas: it doesn't all happen at compile time
00:44:09 <kvanb> wait, who was the Guest
00:44:12 <kvanb> I'm disorientated.
00:44:16 <Lutin`> whyy
00:44:44 <Gurkenglas> That's cause I answered something and then asked something
00:45:23 <kvanb> Peaker: I wouldn't for example, want to use WriterT in my server for logging
00:45:35 <kvanb> I would *need* to use a Pipe, or it becomes an attack point.
00:45:51 <kazagistar> Gurkenglas: the declaring is done at compiletime, and is conceptually availible as soon as runtime starts. However, it might only be availible as a thunk until evaluated
00:45:59 <kvanb> that pipe could instantly write to stdout or a logfile ofcourse
00:47:57 <kazagistar> Gurkenglas: when haskellers say "substitution is identical", it still can impact runtime when executed on a machine
00:48:22 <kvanb> supercompilation by evaluation may be relevant
01:15:10 <MP2E> wow, when compiling happy with '-O2 -fllvm' with ghc 7.8.2 memory usage explodes to over 4GB, but if I compile it with '-O2 -fllvm -fno-spec-constr' it uses 400 MB
01:15:18 <MP2E> holy memory leak batman
01:17:44 <meditans> hi again.. so, as I said yesterday, I'm thinking about how to implement for haskell some editing facilities like agda-mode or idris-mode
01:18:56 <jle`> kazagistar: perhaps it is less about the execution on hardware and more about the semantics
01:18:56 <meditans> I think that, in part, a lack of more precise types can be substitute with some heuristics. For example, think how you would implement a filter function
01:19:26 <meditans> with the type filter :: (a -> Bool) -> [a] -> [a]
01:19:43 <ninja_code> does haskell have a type for efficient, ie.. not [Char] Strings ?
01:19:55 <Iceland_jack> Text
01:19:55 <ninja_code> does haskell have a type of String which is efficient (i.e. not [Char])
01:19:56 <Kinnison> There's Text
01:20:26 <ninja_code> thanks!
01:20:59 <meditans> or equivalent in other languages: the types involved don't guide you to a solution, while an heuristic like: use all the information avaiable in variables, with maybe the editor prompting you a choice for filter odd [1,2,3,4,5], may suffice
01:21:03 <tdammers> ninja_code: if you're working with *encoded* strings (that is, sequences of bytes rather than sequences of characters), ByteString is another option
01:21:30 <tdammers> ninja_code: you'll have to sort out character encodings yourself then though
01:21:30 <ninja_code> haskell is amazing
01:21:39 <ninja_code> every day --> haskell seems more awesome
01:21:42 <meditans> I'd like to know where I could discuss about a haskell implementation of this
01:22:56 <jle`> ninja_code: :D
01:23:17 <whyy> jle`: Thanks very much :) Need to explore more
01:23:37 <jle`> whyy: of course :) Gurkenglas had a good example with defining main in C/Java
01:23:42 <jle`> were you around to catch that?
01:25:05 <whyy> jle`: Actually sorry I had been to lunch, Just going through the conversations now
01:25:23 <jle`> ninja_code: were you the one who was doing the io+state monad?  i thought of another interesting idea;  you know how you do data MIO s a = s -> IO (a, s) ?  how hard would it be to parameterize over the IO/monad?  that is, data MM m s a = s -> m (a, s) ... ?
01:25:30 <jle`> ninja_code: could you do all the same things, but for arbitrary m?
01:25:58 <jle`> you could even do instance MonadIO (MM IO s) where ... to have a MonadIO instance
01:26:03 <Gurkenglas> whyy, or like, defining anything over there. Imagine haskell's "foo :: a foo = <...>" translates to "a foo() {return <...>;}" in Java, with lotsa optimization done by the compiler
01:26:19 <ninja_code> jle`: is this moving toward monad transformers?
01:27:25 <jle`> oh sorry, bacwards; data MM s m a = s -> m (a, s)
01:28:18 <jle`> and then you can write a liftTheM :: m a -> MM s m a, just like how you did liftIO :: IO a -> MIO s a
01:28:32 <jle`> and then instance MonadTrans (MM s) where ...
01:28:44 <jle`> ninja_code: it's not just moving towards; it's actually literally all a monad transformer is :)
01:28:56 <jle`> that's literally just the state monad transformer
01:29:08 <ninja_code> jle`: you should write a book on haskell
01:29:15 <jle`> instead of using your state+io, you paramterize IO to work over all m
01:29:18 <ninja_code> add to the list of existing monad tutorials
01:30:08 <jle`> haha.  i actually don't like monad tutorials.  i wouldn't call this a monad tutorial; i'd call it a tutorial on implementing useful convenience functions for a type...that happen to align with exiting typeclasses
01:30:52 <tdammers> "monad tutorial" sounds catchier though
01:31:21 <jle`> tdammers: hm true.  that explains a lot
01:31:39 <ninja_code> jle`: I have one more thing I need your help on
01:31:47 <ninja_code> jle`: can you write me a tutorial on how to implement a distributed log in haskell?
01:32:00 <jle`> distributed log?  and why me? :P
01:32:04 <jle`> i'm no expert on everything
01:32:11 <jle`> :)
01:32:22 <ninja_code> jle`: distributed log because I need a distributed log; you, because you're helpful and think in a rigorous manner
01:32:32 <ninja_code> whether you currently understand distributed log is irrelevant
01:33:19 <frerich> ninja_code: maybe you should first write a tutorial on what a distributed log is for jle`
01:33:29 <jle`> yes i would be happy to read it :)
01:33:38 <ninja_code> frerich, jle`: sure, give me 1 hour
01:34:00 <ninja_code> frerich, jle`: from someone more qualified than me: http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying
01:35:38 <frerich> ninja_code: I wasn't really serious, I just hoped that there's a two-minute explanation on what 'distributed logs' are. but skimming that linkedin article suggests that two minutes may not be enough...
01:36:18 * frerich assumes that if somebody wrote a tutorial on distributed logs, then that suggests he actually implemented them himself already in which case you could possibly skip the tutorial and just reuse the existing implementation.
01:36:51 <ninja_code> frerich: distributed logs consists of two parts "distributed" and "logs"
01:36:57 <ninja_code> the "logs" part means the ability to record events and view them later
01:37:04 <ninja_code> the "distributed" part involves doing this over more than one machine
01:37:09 <ninja_code> :-)
01:37:34 <frerich> ninja_code: Does that mean that the same recorded event is duplicated on multiple machines?
01:37:55 <ninja_code> frerich: great question!
01:37:58 <ninja_code> frerich: it depends. :-)
01:38:22 <ninja_code> frerich: any other clarifications ?
01:38:53 <frerich> ninja_code: what composes an 'event'? Assuming that it's some information fixed in time, how do you handle events generated by machines running in different time zones?
01:39:30 <ninja_code> frerich, I thikn of "event" is a json piece of data that consists of: machine_id, time_on_machine, actual_data
01:40:02 <frerich> ninja_code: is 'time_on_machine' the time where the event occurred or the time where the event is stored?
01:40:44 <ninja_code> frerich: I'd assume time on machine where event occured
01:41:17 <jle`> jjkj
01:41:21 <jle`> ~;
01:41:23 <frerich> ninja_code: So that means you can have many events with the exact same 'time_on_machine'?
01:41:29 <jle`> sorry
01:41:35 <jle`> connection going weird
01:41:43 <ninja_code> frerich: yes, but they
01:41:53 <ninja_code> they'd ahve differnet machine_ids
01:43:39 <solidus-river> jle`: been looking around and i still dont get how a wire can't have state inside  that isn't a or b
01:43:42 <solidus-river> and afternoon :)
01:43:56 <jle`> i'll give it a read and let you know if there's anything i have read that might help you :)  can't quite spend too much time to actually writing at the moment though, sorry
01:44:08 <jle`> solidus-river: did you read my stream/auto tutorial?
01:44:44 <solidus-river> aye
01:44:50 <solidus-river> but a mealy machine has state inside
01:44:59 <solidus-river> just state that only changes when it produces a new wire
01:45:12 <solidus-river> so why cant it have a statefull wire that takes a, produces b and the next state
01:45:16 <solidus-river> and have that state be some type c
01:46:22 <jle`> how about past10 :: Wire s e m Double Bool
01:46:29 <jle`> where it takes in a velocity
01:46:32 <jle`> you start from zero
01:46:41 <jle`> and the output is when the position passes 10
01:47:19 <jle`> past10 = proc vel -> do { pos <- integral 0 -< vel; returnA -< pos >= 10 }
01:47:25 <jle`> your state is your position
01:47:39 <jle`> in this case it is unfortunately the same time as your input
01:47:52 <solidus-river> but what if instead of that i wanted to associate an integer incriment with whether a boolean is true or not each frame
01:48:04 <jle`> remember, there are no frames in FRP
01:48:06 <solidus-river> so i wanted Wire s e m Bool Bool that outputs after 10 trues
01:48:19 <jle`> that wire would behave differently based on the framerate
01:48:20 <solidus-river> then what is a statefull wire?
01:48:29 <jle`> a stateful wire si an implementation detail ;)
01:48:51 <jle`> do you see why it would break FRP?
01:49:00 <solidus-river> i guess but i don't see how it cant exist
01:49:03 <solidus-river> from your definition of arrow
01:49:07 <solidus-river> or the definition of arrow
01:49:07 <jle`> it can exist
01:49:13 <jle`> but FRP is a concept with semantics
01:49:19 <solidus-river> just netwire doesn't support it?
01:49:26 <jle`> not netwire; frp
01:49:39 <solidus-river> so netwire does support it?
01:49:45 <jle`> i mean; frp doesn't support it
01:49:46 <solidus-river> i dont see how it would really break anything badly
01:50:02 <jle`> let's say your bool is whether or not it is in the interval [0,1)
01:50:04 <Peaker> kvanb: back: missed any answer you might have had :)
01:50:07 <jle`> er, your test
01:50:17 <jle`> and when the thing is "run", it adds to a counter if it is in [0,1)
01:50:31 <jle`> and the bool goes True after 5 trues
01:50:46 <jle`> now, run the wire with timestep 0.1
01:50:52 <jle`> position is independent of your framerate, remember
01:51:01 <jle`> and run the same wire with timestep 0.5
01:51:06 <jle`> you'll go to True at different times
01:51:16 <solidus-river> yeah but if the position is a function of time its fine
01:51:41 <jle`> the position won't change either way
01:51:49 <jle`> pos <- integral 0 -< 1
01:52:00 <jle`> will reach pos = 1 at exactly t = 1
01:52:05 <jle`> no matter what your timestep is
01:52:29 <solidus-river> so i need to compose more wires together to make this happen
01:52:39 <solidus-river> but i dont see why netwire wouln't support a wire with internal state
01:52:39 <jle`> pos <- integral 0 -< 2 will reach pos = 1 at exactly t = 0.5
01:52:44 <solidus-river> its usefull
01:52:50 <jle`> solidus-river: it does support a wire with internal state, but Haskell also has unsafePerformIO
01:52:58 <solidus-river> and it looks like it does
01:53:02 <jle`> if you think you need it, it is because you are approaching the problem from the wrong angle
01:53:08 <jle`> from a non-FRP mindset
01:53:12 <solidus-river> jle`: but what if i wanted to do it this way?
01:53:27 <solidus-river> like i just want to know how to get that to happen with netwire, regaurdless of the laws of frp
01:53:36 <solidus-river> i get that it could be wrong
01:53:37 <jle`> that's like saying "what if i wanted to implement foldl as unsafePerformIO, and using IORefs?"
01:53:43 <jle`> ah
01:53:50 <jle`> well yeah you'd use one of the mk_ functions
01:53:58 <jle`> but you wouldn't use it in a real program
01:54:15 <solidus-river> but what would the handoff of the initial state look like in that mK function
01:54:21 <solidus-river> its got a really odd type
01:54:37 <jle`> your state is in the recursive call
01:55:27 <jle`> let's make a bad wire fiveTrues :: Wire s e m Bool Bool, which is True after getting five Trues
01:55:39 <jle`> or better yet let's just make an easier one, countFrom
01:55:48 <jle`> countFrom :: Wire s e m () Int
01:55:52 <jle`> that counts from 0
01:55:55 <jle`> er, countFrom0
01:56:04 <solidus-river> :)
01:56:36 <jle`> countFrom0 = countFrom 0
01:56:38 <jle`> where
01:57:45 <jle`> countFrom n = mkPure (\_ _ -> (Right n, countFrom (n+1))
01:57:47 <jle`> there, that should do it
01:58:29 <solidus-river> cool! that makes sense
01:58:34 <solidus-river> but what you said earlier also makes sense
01:58:43 <jle`> mk
01:58:47 <jle`> the first parametr is the timestep
01:58:47 <solidus-river> is there a statefull wire that cannot be formed by composition of non statefull wires?
01:58:49 <jle`> the second is the input
01:59:44 <solidus-river> you could get that same wire from... integral 0 . for . 5
01:59:51 <solidus-river> or something similar
02:00:00 <jle`> you can't
02:00:09 <jle`> well
02:00:12 <jle`> integral 0  is a sateful wire
02:00:16 <jle`> just look at the implementation :)
02:00:28 <solidus-river> heh
02:00:35 <solidus-river> so why is using statefull wires bad?
02:00:45 <solidus-river> if your state is purely a function of time and another input
02:00:53 <solidus-river> well mainly a funciton of time modified by another input
02:01:00 <jle`> integral x0 = mkPure (\dt v -> let x = dt * v + x0 in (Right x0, integral x))
02:01:04 <jle`> do you see the difference?
02:01:22 <jle`> stateful wires aren't bad, but writing stateful wires yourself means you have to be very very careful about not letting the timestep leak
02:01:56 <jle`> unrestrained, arbitrary stateful wires can break FRP
02:02:15 <jle`> but if all you do is compose FRP-compliant functions
02:02:19 <jle`> you can't "exit"/break FRP
02:02:20 <jle`> you're safe
02:02:40 <solidus-river> ah, so i just need to think really hard before i do it :P
02:02:49 <jle`> yeah. and 99% of the time, you wo'nt need it
02:02:55 <jle`> ...if your goal is to stay in FRP
02:02:59 <solidus-river> but i mean, if everything i'm doing is a function of time i can represent it as composed wires
02:03:10 <solidus-river> or
02:03:12 <solidus-river> i think thats true
02:03:16 <jle`> you mostly use it for writing libraries/frameworks
02:03:23 <jle`> you almost never use it for actually making a program
02:04:12 <solidus-river> i dont get why there is a mkPure, mkPureN, mkSF, and mkSFN
02:04:26 <solidus-river> mkPure and mkSF seem to be =
02:04:40 <solidus-river> oh i get it SF never inhibits
02:04:54 <solidus-river> and N means state is not reliant on time
02:05:07 <solidus-river> but why have different constructors for those :?
02:05:42 <solidus-river> and then mkGen offers an entry point into the monad transformer stuff
02:06:08 <jack_rabbit> If someone wants to give me some input, I haven't looked at this in a while: https://github.com/knusbaum/Distributed-Haskell
02:06:11 <solidus-river> sorry for flood, everything started to make sense at once, it was exciting
02:06:59 <jle`> solidus-river: no problem :)
02:07:10 <jle`> solidus-river: yeah, a lot of it is for performance reasons, too
02:07:17 <jle`> you can implement a lot of them in terms of the other
02:07:35 <jle`> mkGenN i think is the most powerful one
02:07:41 <jle`> and you can write all of them in terms of mkGenN
02:07:49 <Anissa21>  Here some videos. I hope you like them! http://bitly.com/1mn6GWc
02:07:53 <jle`> functionally, at least
02:08:09 <jle`> but the underlying Wire type has different constructors for either one, to make running them more efficient
02:08:35 <jle`> sorry, mkGen, not mkGenN
02:08:57 <jle`> actually..can you see why you can't "actually" write mkPure in terms of mkGen? :)
02:09:15 <jle`> you "can", but it'd have a different type signature, which might actually effect if it's useful or not in certain situations
02:09:20 <solidus-river> yeah, and i could see how knowing some parts are unnnecissary to keep track of could lead to better efficiency and optimization
02:09:37 <solidus-river> jebus, thats crazy you can apply monad transforms to wires
02:09:53 <solidus-river> if you were worried abotu me making a stateful wire, wonder what you'd think of that craziness
02:09:56 <solidus-river> :P
02:10:10 <solidus-river> thats definitely far form pure frp land
02:10:44 <jle`> haha.  well the included wires and combinators should still preserve FRP for the most part over any transformed monad
02:10:50 <jle`> er, underlying monad
02:11:08 <jle`> but you really aren't supposed to use the underlying monad for the most part.  Reader is one thing people use it for
02:11:24 <jle`> IO is used for performance hacks
02:11:33 <jle`> but those break frp obviously unless you wrap it up real nice
02:11:53 <solidus-river> whats the difference between a State and IORef
02:11:57 <solidus-river> thats been bugging me for a while
02:12:05 <Iceland_jack> solidus-river: State is pure
02:12:33 <jle`> State s a is just a synonym for a function s -> (a, s)
02:12:38 <Iceland_jack> > execState (do modify (+2); get) 10
02:12:39 <solidus-river> so IORef isn't garunteed to be functionally pure?
02:12:39 <lambdabot>  12
02:12:50 <Iceland_jack> solidus-river: IORef has IO in the name :)
02:12:52 <jle`> solidus-river: IORef is like a pointer you can use in IO actions
02:13:25 <Iceland_jack> when you modify an IORef you can think of actually mutating a memory reference, which is an effect
02:13:31 <solidus-river> jle`: so is it used in wrapper libraries mostly to handle cvars?
02:13:35 <solidus-river> trying to think of what that would be good for
02:13:57 <jle`> it's very useful for imperative IO algorithms
02:14:25 <jle`> but remember it is fundamentally rooted in the idea of an IO action
02:14:28 <Iceland_jack> If you're using a single threaded application: IORef can be used for any kind of mutable state
02:15:07 <Iceland_jack> You can also use ST which gives you pretty much the same thing as IORef but with a pure result
02:15:15 <jle`> writeIORef ioref x :: IO (); it is an IO action that represents the act of "putting" the value x into the physical memory location on the computer ioref
02:15:32 <jle`> just like putStrLn, or getLn...they are IO actions that you can chain and stuff
02:15:35 <Iceland_jack> So if you're implementing an imperative algorithm like jle` mentioned you don't need to make it impure
02:16:00 <jle`> yeah most imperative algorithms have pure results overall
02:16:41 <Iceland_jack> And those that don't can still be worked on in the 'ST s' monad, not as nice but still not bad
02:17:30 <solidus-river> very cool
02:17:36 <jle`> ST s monad should run imperative algorithms with pure results, tho...the same ST s a will return the same a when run every time
02:17:55 <alpounet> there's a way to write 'type family Contains (elem :: *) (list :: [*]) :: Bool' without using a closed type family right?
02:17:58 <jle`> so runST can be considered a pure function just like runState
02:17:58 <Iceland_jack> yes absolutely
02:18:16 <Iceland_jack> but sometimes your logic for 'ST s' code is all over the place
02:18:20 <alpounet> looking for a ghc < 7.8 friendly version of my simple closed type family
02:18:33 <solidus-river> well, the last big hurdle i think for me is going to be understanding Arrow / arrowLoop / fix / rec
02:18:45 <solidus-river> is this the best resource for that? http://en.wikibooks.org/wiki/Haskell/Arrow_tutorial
02:18:49 <solidus-river> it looks like the best i've found so far
02:19:05 <jle`> that's my favorite tutorial for a useful Arrow instance
02:19:05 <solidus-river> Iceland_jack: is there performance advantages to runnign it with an IORef?
02:19:11 <Iceland_jack> not really
02:19:20 <jle`> but do you remember "learning monads"?
02:19:23 <jle`> you don't really "learn monads"
02:19:28 <jle`> you use useful instances until one day it clicks
02:19:43 <solidus-river> seems like it'd be the right call all thetime for thing stha tdon't need it to use ST then
02:19:47 <Iceland_jack> There are better things to focus your efforts on than arrows in modern Haskell imo
02:19:57 <solidus-river> jle`: yeah, i learned monads like 4 times before i learned them
02:20:01 <solidus-river> it took writing a couple programs
02:20:06 <solidus-river> but maybe i havent learned them
02:20:15 <solidus-river> i can use them
02:20:15 <jle`> if you haven't, that's no loss
02:20:20 <solidus-river> and make them most of the time
02:20:52 <int3__> is there a way to pattern-match multiple different values to the same thing? e.g. case x of Foo | Bar = 1; Baz = 2
02:21:00 <int3__> iirc there is something like that available in ML
02:21:02 <jle`> Iceland_jack: I think.....he is trying to learn netwire.  but yeah, in general, Arrows aren't really worth learning unless you are in a domain where you would use them.  small roi otherwise
02:21:28 <Iceland_jack> ah netwire, I should have caught up on the previous conversation
02:21:53 <solidus-river> well, i'm not really planning on using them with netwire except for one instance where i want to use rec
02:21:59 <solidus-river> and i think rec is much easier to read arrowized
02:22:07 <solidus-river> but then i realized i don't understand how rec works
02:22:14 <solidus-river> so i stopped and am looking to understand arrows :P
02:22:49 <yitz> solidus-river: arrows aren't all that popular nowadays. people mostly use applicative instead.
02:22:52 <jle`> solidus-river: it just lets your bindings depend on eachother :)
02:23:51 <solidus-river> jle`: i know, but how the heck does it do that! its magic!
02:23:59 <solidus-river> i want to know it enough to not have it be magic
02:24:05 <jle`> rec { let a = -x; v <- integral 0 -< a; x <- integral 1 -< v; returnA -< x }
02:24:09 <solidus-river> it seems like coming at it from the wire perspective is the easiest
02:24:12 <jle`> voila, a harmonic oscillator :)
02:24:39 <solidus-river> jle`: but how
02:24:44 <solidus-river> like that seems insane to me
02:24:54 <solidus-river> its like telling a computer the sky is what color i say it is, i say what color the sky is
02:25:00 <solidus-river> its not supposed to work :|
02:26:01 <solidus-river> jle`: so thats actually a really good example of what i dont understand about them
02:26:07 <solidus-river> jle`: that looks like it hsould continue forever
02:26:15 <solidus-river> how does it know when to return?
02:26:15 <hexagoxel> what is integral?
02:28:22 <kvanb> Peaker: ping?
02:28:43 <solidus-river> hexagoxel: integral is counts up with time from the start
02:28:51 <solidus-river> hexagoxel: its a wire from netwire
02:30:32 <int3__> also, is it possible to have a constant value field in a data type? like type Foo = Bar { x :: Int = 1 } | Baz { x :: Int = 2 }
02:30:35 <solidus-river> hexagoxel: so that wire equates to a signal that fluctuates between 0 and 1 harmonicly
02:30:52 <hexagoxel> ah FRP.Netwire.Move.integral, i see
02:30:53 <int3__> when I try something like that, GHC suggests -XDataKinds, but I'm not sure that is the right thing to do
02:30:55 <solidus-river> hexagoxel: i think in an exact sine wive
02:31:06 <solidus-river> *wave
02:31:15 <int3__> or should I just define some function getX that matches on the constructors and returns the appropriate value?
02:31:22 <solidus-river> if your unit circle has a radius of 1 second
02:31:22 <solidus-river> :P
02:32:28 <jle`> actually i did it wrong, it should be a = -0.5 * x; and it would be between -1 and 1
02:32:46 <solidus-river> unless i've become useless and should go to sleep, which i probably should go to bed
02:32:54 <jle`> it's a sine wave, yes
02:33:03 <solidus-river> but any insight on how it knows when to return on that?
02:33:10 <solidus-river> like how can it possibly pick a value for returnA
02:33:33 <solidus-river> x is forever unstable
02:33:46 <jle`> actually no :| it's been osmething i have been meaning to internalize/understandin intuitively too.  i just haven't had too much reason to care heh.
02:34:05 <jle`> if there is a <<loop>> i just add a delay somewhere
02:34:08 <jle`> sloppy, i know :)
02:34:41 <jle`> presumably it computes some sort of fix point; just like how you can make fix run a factorial
02:34:54 <solidus-river> heh, maybe in a week or so i can help transfer what i've managed to understand about it back to you and repay some netwire explaining :P
02:36:18 <hexagoxel> solidus-river: i think it depends on your arrow. you can write an arrow that will return just the first "iteration", and that can be used again to return the next iteration.
02:36:46 <jle`> hexagoxel: that doesn't work, because the first iteration depends on what it will compute; there's nothing to pull out of the air
02:37:49 <jle`> presumably it computes some sort of fixed point
02:38:00 <hexagoxel> does that example terminate?
02:38:01 <jle`> :t fix (\f x -> if x == 0 then 1 else x * f (x - 1))
02:38:02 <lambdabot> (Num a, Eq a) => a -> a
02:38:44 <solidus-river> the tie to fixed point helps a lot, the wikipedia page on it already seems to make things make more sense
02:38:45 <jle`> @src fix
02:38:46 <lambdabot> fix f = let x = f x in x
02:39:09 <solidus-river> gameplan is understand arrows, understand fixed point, understand rec
02:39:16 <jle`> fix basically applies a function to itself; it finds a fixed point of the function
02:39:25 <jle`> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 10
02:39:27 <lambdabot>  3628800
02:39:36 <jle`> the fixed point of that function is the factorial function
02:43:16 <solidus-river> interesting, fixed point makes it make sense but i'd like to dig into how the heck haskell is finding a fixed point for a rec, i guess it knows the possible inputs and outputs
02:43:23 <solidus-river> that seems like it owuld be very slow to figure out though
02:43:49 <Eduard_Munteanu> solidus-river: a rec?
02:43:56 <solidus-river> yeah
02:44:24 <Eduard_Munteanu> Haskell doesn't find fixed points, it merely builds a recursive term which happens to converge or not.
02:44:40 <solidus-river> Eduard_Munteanu: how does it know it will converge or not
02:44:45 <hexagoxel> it does not "iterate until nothing changes"
02:44:46 <Eduard_Munteanu> It doesn't.
02:44:51 <solidus-river> is that left up to the author to find out
02:44:52 <solidus-river> heh
02:44:53 <solidus-river> kk
02:45:53 <hexagoxel> solidus-river: just yesterday, i tried to figure some arrow/rec/let stuff out. to show one issue, i posted code https://gist.github.com/lspitzner/8825f03dca23981a2657. you may find that code useful.
02:46:08 <hexagoxel> it does not require on netwire
02:46:31 <hexagoxel> funny thing: the issue was just that it does not converge :)
02:46:35 <Saizan> Eduard_Munteanu, solidus-river: it always converges, but it might converge to a diverging value
02:46:36 <hexagoxel> but the commented function does
02:47:54 <Eduard_Munteanu> Saizan: in the same way as lim_{x -> inf} sin x always converges?
02:48:15 <Eduard_Munteanu> s/way/sense/
02:50:01 <solidus-river> when checking for convergence does it actually run the functions?
02:50:30 <Saizan> i just mean that bottom is a fair element of the semantics to converge to, it's just not very useful
02:50:44 <Eduard_Munteanu> Ah.
02:50:44 <Saizan> solidus-river: there's no convergence check
02:51:08 <solidus-river> Saizan: then how does it know when to return :P
02:51:13 <solidus-river> this is becoming a rec definition
02:51:20 <Saizan> solidus-river: laziness, man
02:51:26 <solidus-river> *pun intended*
02:51:45 <Saizan> solidus-river: if the input function stops looking at its argument then you won't need to unfold the recursion anymore
02:52:17 <Saizan> fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 10 <-- in the x == 0 case the f is unused
02:53:21 <solidus-river> Saizan: that makes a ton of sense
02:53:44 <solidus-river> so the harmonic oscilater earlier shown in a rec will actually <<loop>>
02:54:07 <solidus-river> unless the function that calls it looks for a specific value and then never calls it
02:54:19 <Saizan> i haven't seen that one
02:55:31 <solidus-river> well, that already makes a ton more sense. its late here though almost 3am and i've been up since 7
02:55:47 <hexagoxel> looking at the source of integral, i think it first returns the start value, only with a delay it uses the input value
02:56:27 <solidus-river> Saizan: jle` thanks for helping with more understanding, hopefully some day i can give back by helping out with some libs / binding
02:56:36 <solidus-river> hexagoxel: it will only give a value when asked a value
02:56:48 <Saizan> solidus-river: cheers
02:56:58 <solidus-river> hexagoxel: check out jle`'s post baout arrows or look at pipes / conduit
02:57:26 <solidus-river> cheers
02:57:35 <jle`> np solidus-river
02:58:28 <hexagoxel> solidus-river: but with "returnA -< x", you ask for x.
03:00:09 <hexagoxel> i do not think the harmonic oscilator will <<loop>>
03:02:20 <hexagoxel> because <integral> does not create an immediate dependency
03:02:44 <jle`> hexagoxel, solidus-river --- it does not loop
03:02:45 <jle`> just tried it now
03:02:59 * hexagoxel phew
03:03:44 <jle`> sho = proc _ -> do { rec { let a = -0.5 * x; v <- integral 0 -< x; x <- integral 1 -< v }; returnA -< x }
03:09:26 <kvanb> Peaker: ping
03:09:30 <jle`> http://i.imgur.com/LLoxy77.png for anyone interested
03:09:53 <jle`> i'm glad i didn't forget everything i learned in my undergrad
03:11:43 <hexagoxel> jle`: unused variable "a" ?
03:11:54 <jle`> oh sorry
03:11:58 <jle`> it should be v <- integral 0 -< a
03:12:35 <hexagoxel> ok :)
03:14:08 <ninja_code> what is the simplest http server I can create in haskell?
03:14:18 <ninja_code> something that's a complete dumbass, listens on port 80, and returns get queriesi
03:14:20 <ninja_code> and does nothing esle
03:14:53 <jle`> hexagoxel: http://lpaste.net/106840
03:14:59 <hseg> Hi. Just got my B.Sc., and I'm looking to study towards an M.Sc. Any suggestions on which university to go to? I'm geographically limited to Israel.
03:15:10 <tdammers> ninja_code: look into Warp, maybe?
03:15:24 <jle`> hseg: unless it has to do with haskell, maybe try #haskell-blah ?
03:15:27 <jle`> :)
03:15:28 <ninja_code> Stanford
03:15:29 <ninja_code> or Berkeley
03:15:35 <tdammers> ninja_code: although it depends on what aspects you want it to be simple
03:15:40 <hseg> #haskell-blah?
03:15:58 <tdammers> ninja_code: you can write a web server with Scotty using trivial amounts of code
03:16:10 <tdammers> but it'll do a bit more than just echo GET requests
03:16:26 <jle`> hseg: the channel where we hang out and talk about things not related to haskell :)
03:16:35 <hexagoxel> jle`: that looks almost identical to the thing i posted. but instead of a delay, you use integral.. hmm
03:16:42 <hseg> Oh. Never heard of it.
03:16:44 <ninja_code> tdammers: yay, I think this is exactly what I need. Thanks!
03:16:45 <tdammers> or you can write one from scratch, which is more work, but arguably "simpler" in that it will do exactly what you specified and absolutely nothing else
03:16:50 <jle`> hexagoxel: what delay?
03:17:02 <hseg> Can someone change the topic to add a reference to that?
03:17:05 <tdammers> but yeah, Scotty is probably as simple as it gets, pragmatically speaking
03:17:31 <hexagoxel> jle`: <init> in my post
03:17:42 <hseg> Thanks
03:19:04 <jle`> hexagoxel: the gist?
03:19:09 <hexagoxel> yes
03:19:19 <jle`> ah
03:20:03 <jle`> i don't see a delay?
03:21:06 <hexagoxel> init i = RecArrow $ \x -> (i, init x)
03:21:20 <hexagoxel> x is not immediately used, just forwarded to next iteration
03:21:36 <jle`> ah, and what does your thing output?
03:21:50 <hexagoxel> sin
03:23:25 <hexagoxel> well, the gist runs in its current form <<loop>>s
03:23:26 <jle`> that is interesting
03:23:28 <jle`> oh
03:23:36 <jle`> what makes it work?
03:26:52 <hexagoxel> jle`: making arrow less strict will prevent <<loop>>
03:26:59 <hexagoxel> i committed the fix: https://gist.github.com/lspitzner/8825f03dca23981a2657/revisions
03:27:19 <jle`> that's interesting
03:29:04 <hexagoxel> <init> breaks up the cyclic dependency, just like <integral> does.
03:30:09 <hexagoxel> btw the exact reason why my unfixed code <<loop>>s still eludes me (and why the out-commented version above works with the non-fixed arrow)
03:30:30 <hexagoxel> afk, lunch
03:36:51 <jle`> cheers :)
03:37:01 <jle`> i will indeed look into this more
03:48:59 * hackagebot despair 0.0.2 - Despair  http://hackage.haskell.org/package/despair-0.0.2 (Heather)
03:55:10 <k_bx> Hi everyone! Why was ErrorT deprecated in flavor of ExceptT? Is there an article or email you know about that explains this in simple but sufficient way?
04:00:08 <merijn> k_bx: I think it's just a bikeshedding change
04:00:27 <merijn> k_bx: i.e. the notion "Exceptional behaviour" was more accurate than "error behaviour"
04:01:07 <k_bx> merijn: I see. Thanks for explanation. I just upgraded few libs (with transformers and mtl, I guess) and have tons of deprecation warnings, but could never recall any explanation or announcement.
04:07:32 <supki> k_bx: ErrorT's Monad instance has an additional Error constraint which is annoying
04:07:50 <Ariana21>  Hi! I give you some videos. I hope you like! http://bitly.com/1z9Uso1
04:08:06 <ion> Why yes, everyone likes spam.
04:08:54 <supki> k_bx: so instead of fixing that another transformer was introduced which is exactly like EitherT except the name
04:09:20 <k_bx> I see. Also found "Why not ErrorT" in Gabriel's post http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
04:23:05 <danilo2> Hello! I think I found a bug in GHC but I would love to ask you on the beginning if I'm right here. Here is a very simple example using closed type families. The code contains 2 simmilar examples - the former works, later does not compile, but it should to: http://lpaste.net/106845
04:29:03 * hackagebot http-client 0.3.4 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.4 (MichaelSnoyman)
04:30:04 <ocharles> Anyone got any tips on taking the fix point of a modification of some text? I want to turn all sequences of "-----" into just "-". It seems that's easiest to express as taking the fix point of replacing "--" with "-"
04:30:14 <hexagoxel> danilo2: is that not exactly the case described in 6.2.1 in http://www.haskell.org/haskellwiki/Type_families (search for "family J a b")
04:30:38 <ocharles> I can do it with Data.Function.fix and checking for equality, but I was wondering what other options there are
04:31:51 <danilo2> hexagoxel: You are right, thank you very much! By the way, is anybody working on introducing inequality evidence into GHC? (solving this issue?)
04:39:57 <_0xAX> Hello All
04:40:12 <Geraldus> Hi pals! :)
04:40:15 <_0xAX> What are to use for building fast tcp client?
04:40:30 <_0xAX> I'm new in haskell, and found many different packages like network, Data.Conduit.Network and etc...
04:40:53 <Peaker> kvanb: pong
04:42:57 <osfameron> _0xAX: might be worth looking at what RWH has to say about it? http://book.realworldhaskell.org/read/sockets-and-syslog.html
04:43:30 <_0xAX> osfameron: thank you, now will look
04:44:11 <_0xAX> and yet another question is there tcp client library with ssl support, i found many libraries, but tcp and tcp over ssl are in different libraries
04:49:17 <slomo> _0xAX: http://hackage.haskell.org/package/connection-0.2.1 maybe? or you can build your own wrappers around Handles and e.g. Network.TLS
04:50:21 <_0xAX> slomo: thanks, seems that it is what i searched
05:00:34 <kvanb> Peaker: ping
05:00:35 <kvanb> lol
05:01:58 <bennofs> Is there something like `forkProcess` for windows?
05:04:33 <RichardB__> bennofs, I don't think so. Using forkProcess isn't really recommended on Unix either because calling fork() from multithreaded programs is pretty much always problematic, especially in GHC Haskell where it more or less completely upsets the run-time system.
05:05:15 <kuribas> Say I want to represent a polynomial of any degree.  Would a vector be more efficient than a list for coefficients?
05:05:40 <RichardB__> bennofs, I believe that the Cygwin project does have an implementation of fork() that works on Windows, but I don't think that it's particularly quick.
05:05:46 <Rembane> kuribas: What do you want to do with the coefficients? Access them by index?
05:06:32 <kuribas> Rembane: yes, and operations on polynomials, like addition and multiplication.
05:06:45 <RichardB__> bennofs, for what purpose do you want to use forkProcess at all, please? There is probably another, easier way to achieve whatever it is that you desire.
05:08:07 <Rembane> kuribas: I'd start with list and if performance is a problem change to Data.Vector
05:08:13 <kuribas> I had code that represented a bezier polynomial as a list, and used list functions for calculating a value.  This function was the bottleneck of my code.
05:08:34 <kuribas> So it seems that using list functions isn't appropriate for critical functions...
05:08:44 <kuribas> Performance wise I mean.
05:10:27 <bennofs> Rembane: I want to do have 2 threads, where on does a lot of GC and the other doesn't (=> the one that does less GC should have no/only small GC pauses)
05:10:44 <pjdelport> kuribas: Did you profile?
05:10:49 <kuribas> yes
05:11:39 <pjdelport> kuribas: Did you compare against a vector-based version?
05:11:43 <kuribas> no
05:12:14 <kuribas> I unrolled that function for my particular case (3th degree bezier)
05:13:52 <pjdelport> kuribas: How long are your polynomials? For short ones, lists probably shouldn't be a significant bottleneck. They should only get more significant when you're using them for long strings, and so on.
05:16:09 <kuribas> pjdelport: I used a polynomial for find certain curvature, and it would get upto degree 12
05:17:00 <kuribas> I think the bottleneck was that the list functions have overhead, instead of being fused by the compiler.
05:17:09 <pjdelport> kuribas: Are the lists all used / consumed in a streaming fashion? (That is, you're not using (!!) a lot?)
05:17:56 <kuribas> yes
05:18:39 <kuribas> pjdelport: for example (~*): https://github.com/kuribas/cubicbezier/blob/master/Math/BernsteinPoly.hs
05:19:08 * hackagebot text-ldap 0.1.1.0 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.0 (KeiHibino)
05:19:10 * hackagebot tidal 0.4.6 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.6 (AlexMcLean)
05:22:23 <kuribas> pjdelport: I'd probably need to unroll that if I want better performance.
05:23:41 <pjdelport> kuribas: Hmm, that ![Double] might not be doing what you think it does.
05:24:08 * hackagebot tidal-vis 0.1.5 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.5 (AlexMcLean)
05:24:14 <Lutin`> Is lambdabot broke? :[
05:24:17 <Lutin`> > 1 + 1
05:24:19 <pjdelport> kuribas: I think it only makes the outer (first) list constructor strict, not the rest of the list.
05:24:25 <Lutin`> Oh no..
05:24:52 <lambdabot>  2
05:25:10 <Lutin`> There we go
05:27:37 <kuribas> pjdelport: yes.  So an unboxed vector would be faster right?
05:27:38 <hexagoxel> lamdabot's just lazy
05:28:07 <kvanb> bennofs: the ghc runtime does not pause long enough for pauses to ever be an issue
05:28:27 <kvanb> generate a lot of junk and garbage collection will be instant
05:28:36 <kvanb> if you generate very little junk it could take longer
05:28:36 <kuribas> > length [1..]
05:28:40 <lambdabot>  mueval-core: Time limit exceeded
05:28:42 <pjdelport> kuribas: I'm afraid that math goes a bit over my head, so i'm not certain, but it's worth trying.
05:29:00 <bennofs> kvanb: I'm writing a bot for a game where I only have 2s to compute the result, and I have a big game tree, so I get ~300ms pauses somtimes, which is too much for my purposes
05:29:22 <kuribas> pjdelport: The math is easier when you see it on paper...
05:30:03 <kuribas> but yeah, I should profile it using vectors.
05:30:22 <pjdelport> kuribas: Do you have profiling output you can paste?
05:30:38 <kvanb> bennofs: what about manually running performGC?
05:30:57 <kuribas> no sorry
05:31:27 <kvanb> you could also tweak with runtime settings and turn off or make the automatic GC quite infrequent
05:31:40 <kvanb> (which would be fine as long as you trigger it manually)
05:33:04 <bennofs> kvanb: tried performGC, various RTS opts and gctune. The only way to make it work robustly was to use a separate process that only does the timing/move sending
05:33:45 <kvanb> I am seriously finding it hard to believe you're having GC pause issues with Haskell
05:34:09 * hackagebot sloane 1.8.2 - A command line interface to Sloane's On-Line Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/sloane-1.8.2 (AndersClaesson)
05:34:32 <bennofs> kvanb: I have a huge GameTree in memory
05:36:16 <bennofs> kvanb: even pauses ~200ms are too much
05:36:27 <kvanb> it should never be that high
05:36:40 <kvanb> people freak out on the issue tracker when it reaches 10ms times
05:37:02 <bennofs> it's only major GC that takes that long
05:37:36 <kvanb> ghc --version ?
05:37:45 <bennofs> kvanb: 7.6.3
05:38:01 <rwbarton> can you ship a second executable and createProcess that instead?
05:38:19 <kvanb> if it's not too much trouble, just *trying* 7.8 might be a good idea
05:38:30 <rwbarton> or even just createProcess a little python program or whatever
05:38:33 <kvanb> MANY runtime bugs and performance issues were fixed including many optimizations added
05:39:08 <bennofs> rwbarton: I could re-exec myself and pass some arguments. I think I'll do that if there is no better solution
05:39:28 <Lutin`> Why don't people use 7.8.2
05:39:30 <rwbarton> oh, that sounds sensible
05:40:16 <bennofs> Lutin`: because then I cannot use the binary packages provided by nixos
05:40:43 <Clint> Lutin`: because one of the ghc people said that 7.8 isn't ready yet
05:43:34 <mathk> hi is there a function to fold an array but inserting an object in between: e.g.  ["a", "b", "c"] -> "a,b,c"
05:44:23 <xnyhps> > intersperse ',' ["a", "b", "c"]
05:44:24 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
05:44:24 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
05:44:24 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
05:44:24 <lambdabot>              with actual type ‘[GHC.Types.Char]’
05:44:28 <hpc> :t intercalate
05:44:29 <lambdabot> [a] -> [[a]] -> [a]
05:44:42 <hpc> > intercalate "," ["yes", "no", "maybe"]
05:44:43 <lambdabot>  "yes,no,maybe"
05:44:53 <mathk> ah cool thanks
05:45:02 <Lutin`> > intersperse ',' "abc"
05:45:03 <lambdabot>  "a,b,c"
05:45:54 <mathk> > intercalate "," ["a"]
05:45:55 <lambdabot>  "a"
05:49:03 <hpc> intercalate = join . intersperse
05:50:59 <Lutin`> well almost
05:51:11 <Lutin`> since intersperse is a curried 2 arg function
05:51:14 <the_berserker> Is an implementation that fails silently when evaluate
05:51:33 <the_berserker> Is an implementation that fails silently when it evaluates bottom compliant?
05:52:10 <kvanb> out of interest, how does something fail silently in Haskell?
05:52:55 <the_berserker> kvanb: Giving a defined value to bottom, or defining undefined benavior
05:53:50 <Lutin`> bottom is defined as bottom
05:54:08 <Lutin`> and evaluating it should result in an error
05:54:15 <klao> @pl \x -> g <$> f x
05:54:15 <lambdabot> (g <$>) . f
05:54:36 <the_berserker> Lutin`: I mean for example evaluating to 2 when it should evaluate to bottom
05:54:58 <kvanb> klao: fmap g . f
05:54:59 <Lutin`> No that's wrong
05:55:27 <Lutin`> bottom inhabits all types
05:55:30 <Lutin`> 2 does not
05:55:39 <bennofs> kvanb:   Gen  1         4 colls,     0 par    7.13s    7.16s     1.7900s    4.8239s
05:55:47 <bennofs> 4.8s is max pause
05:56:00 <kvanb> .. heap size?
05:56:12 <bennofs> 1386 MB total memory in use, 55% GC time
05:56:20 <Lutin`> Oh jesus
05:56:23 <klao> kvanb: thanks :)
05:56:30 <kvanb> honestly sounds like a runtime bug
05:56:41 <klao> @pl \(a,b) -> g a <$> f a b
05:56:41 <lambdabot> uncurry (ap ((.) . (<$>) . g) f)
05:56:56 <bennofs> kvanb: that it spends 55% GC, or that it pauses ~4.8s?
05:57:09 <kvanb> both kind of mean the same thing
05:57:17 <the_berserker> Lutin`: Instead of crashing, picks an arbitrary value from a type in context and use it
05:57:19 <kvanb> there's a paralell collector you can use, I think. Let me check
05:57:36 <bennofs> kvanb: well, I copy a huge game tree of about the heap size each time I think
05:57:53 <Lutin`> the_berserker: That just sounds like a horribly unsafe thing to do
05:57:55 <kvanb> it shouldn't though
05:58:05 <kvanb> it should realize there is not enough junk and just not copy
05:58:15 <kvanb> or after 1-2 generations not try and collect it for *long* periods of time
06:00:30 <kvanb> bennofs: you know what would be a good idea maybe
06:00:34 <kvanb> talk to someone in #ghc about it
06:00:43 <the_berserker> Why `show (undefined :: ())` crashes the program instead of returning `"()"`? The compiler should know by the type that the only possible non-bottom value is `()`.
06:00:51 <kvanb> possibly rwbarton, I think
06:01:05 <the_berserker> I think that singleton types should not have bottom.
06:01:07 <kvanb> or even tibbe ?
06:02:00 <kvanb> a 4 second garbage collector I think would generally be considered a bug and they should be able to walk you through fixing it with flags or even it might provide some insight to them on a place they could optimise in an upcoming release or something.
06:02:20 <mathk> I have "instance ToJS String" and "instance ToJS a => ToJS [a]" conflicting
06:02:31 <bennofs> kvanb: I'll try GHC 7.8 first
06:02:39 <kvanb> that would be a safe bet
06:02:39 <mathk> but instance ToJS Char is not define.
06:02:47 <quchen> the_berserker: If () didn't have bottom, it would make all functions returning it strict, and sometimes that's not what you want. Also, it would be a counterintuitive special case in the grammar.
06:02:48 <kvanb> afk/brb
06:02:51 <mathk> why is it conflicting?
06:02:59 <quchen> Well, stricter at least.
06:03:11 <donri> mathk: type String = [Char]
06:03:43 <donri> which is a specialization of [a]
06:04:27 <mathk> but in my case a is constraint to be a ToJS
06:04:36 <mathk> so it can not be a Char
06:04:45 <the_berserker> quchen: Any function with return type () should be optimized to nothing by the compiler
06:04:53 <donri> constraints are not considered for instance resolution
06:05:12 <kvanb> bennofs: the other thing to consider is optimizing your data
06:05:16 <quchen> the_berserker: Like x `deepseq` ()?
06:05:27 <mathk> how can  workaround that?
06:05:27 <kvanb> firstly, is it fully strict
06:05:32 <kvanb> did you unpack it properly, etc.
06:05:41 <donri> also, ToJS a doesn't say "not Char" even if you don't have that instance
06:06:01 <bennofs> kvanb: it's not fully strict, intentionally. I don't want to keep the whole tree in memory, it would just be too much
06:06:31 <donri> mathk: either chose one of these two instances or you'll need a concrete string type
06:06:51 <donri> (it's technically possible to get what you tried to work but not recommended)
06:06:52 <kvanb> if its somewhat-1gb of small objects, the garbage collector could be doing a lot of thunk re-arrangement/housekeeping
06:07:07 <jkarni> quchen: Can you explain your comment about () not having bottom making functions strict?
06:07:29 <kvanb> (as you know thunks are linked lists and the garbage collector eventually squashes them)
06:07:37 <Denise21>  You can find funny videos here. http://bit.ly/1o4kZuu
06:07:54 <donri> @where ops
06:07:55 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:08:00 --- mode: ChanServ set +o dcoutts
06:08:12 --- mode: ChanServ set -o dcoutts
06:09:08 <geekosaur> idoru's mostly clobbering those on sight now...
06:10:01 <donri> mathk: also if you do want the string instance, i recommend a type equality constraint to help inference: instance (a ~ Char) => ToJS [a]
06:10:39 <mathk> good to know
06:10:41 <mathk> thanks
06:10:57 <donri> mathk: (TypeFamilies)
06:11:15 <donri> mathk: also, if you control the class you could do the trick used by Show with showList
06:11:22 <the_berserker> Is GHC not Haskell 2010-compliant by not supporting datatype contexts?
06:11:42 <donri> i thought they were removed in h2010
06:12:01 <donri> and i think there's an extension to control it in ghc
06:12:19 <donri> but ghc isn't quite 2010-compliant anyway
06:12:38 <the_berserker> donri: How?
06:13:13 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#vs-Haskell-defn
06:13:49 <Lutin`> donri: They're in 2010
06:14:04 <shergill> the_berserker: datatype contexts have been deprecated (of sorts?) and for good reason. there are other ways to accomplish analogous tasks
06:14:04 <Lutin`> topdecl -> ... | data [context =>] simpletype [= constrs] [deriving] | ...
06:14:26 <Lutin`> Not that I'm advocating their usage
06:14:30 <shergill> the_berserker: as an example us GADTs and provide context to the constructors
06:14:31 <donri> oh right it was n+k that got removed
06:14:38 <shergill> *use
06:15:47 <quchen> jkarni: Maybe strict wasn't the right word here. But if () didn't have ⊥, then you couldn't make thunks of type (): Everything of type () would always be fully evaluated (to ()). For example you could have a State Int () function that looks like `do { x <- get; put (2*x); return (longComputation x) }`. If you run that and you're only interested in the final state, you can ignore the longComputation part.
06:16:20 <donri> but surely default-language: Haskell2010 enables DatatypeContexts?
06:16:23 <quchen> But if () doesn't have ⊥ (i.e. cannot store thunks, is always a value in memory), the long computation has to be run regardless.
06:16:28 <quchen> Unless I'm wrong, that is.
06:18:16 <donri> personally i'm not convinced datatype contexts are always a misfeature; it seems people think so because they expect it to do something it doesn't (ie existential types)
06:18:23 <quchen> the_berserker: GHC is not H2010-compliant for other reasons: Num is required to have Eq and Show as parent classes, for example.
06:18:35 <quchen> Soon Applicative will be a superclass of Monad, which is also not H2010.
06:18:44 <the_berserker> quchen: I think `()` should not have a representation in memory at all and be nothing at runtime.
06:19:32 <quchen> Then you wouldn't be able to distinguish a thunk of type () from a value of type ().
06:19:50 <donri> datatype contexts don't give you any more type safety or any more expressive types, but they can ensure you always thread the expected context through and avoid debugging type errors down the line
06:20:38 <the_berserker> quchen: There is no need to do this. There is only one possible value anyway
06:20:42 <donri> on the other hand, they might cause confusing type errors because of this very requirement to thread a context through that you don't always need
06:20:45 <donri> shrug
06:20:59 <quchen> the_berserker: No. What's the value of   a `seq` ()?
06:21:23 <the_berserker> quchen: Never bottom, always `()`
06:21:30 <quchen> > undefined `seq` ()
06:21:31 <lambdabot>  *Exception: Prelude.undefined
06:21:34 <quchen> Bottom.
06:21:42 <donri> > undefined :: ()
06:21:43 <lambdabot>  *Exception: Prelude.undefined
06:22:43 <bernalex> have I've been dreaming, or is there a #haskell-infra or similar for haskell.org
06:22:56 <quchen> a `seq` () is bottom iff a is ().
06:23:05 <quchen> Eh, iff a is ⊥.
06:23:08 <mathk> donri, since it is will be used to build variading javascript function I have opt for a new datatype. data VariadicJSParam a =  VariadicJSParam { param :: [a] }
06:23:23 <mathk> variadic*
06:23:55 <mathk> cabal build
06:24:13 * hackagebot hxt-relaxng 9.1.5 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.5 (UweSchmidt)
06:24:36 <donri> mathk: that's often the best option. note that lists are homogeneous though
06:24:53 <donri> possibly you want [JSType] or something like that
06:24:53 <the_berserker> Why GHC developers not fix the typeclass mismatch with Haskell 2010?
06:25:02 <quchen> Which mismatch?
06:26:27 <the_berserker> quchen: That the Num typeclass has not Show and Eq as superclasses
06:27:26 <quchen> I don't think there was a good reason for not putting that in H2010. Maybe nobody noticed at the time.
06:27:30 <quchen> Also,
06:27:40 <quchen> @quote elliott interesting
06:27:40 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
06:28:45 <quchen> It'll most likely be changed in the next version of the Report though.
06:28:53 <quchen> GHC is kind of the spearhead of Haskell, after all.
06:29:07 <the_berserker> Why aren't all GHC extensions accepted in the standard?
06:29:22 <quchen> Lots of them are experimental.
06:29:28 <rwbarton> also, what purpose would that serve?
06:29:33 <dottedmag> quchen: what could prevent next Report from being even more conservative than H2010?
06:30:08 <quchen> dottedmag: There will probably be significant changes in the next revision, like Applicative=>Monad and Foldable/Traversable in Prelude.
06:30:34 <quchen> Small extensions like BangPatterns, MultiWayIf, LambdaCase also have a fair chance of being standardized.
06:31:18 <prophile> which extensions were standardised in H2010?
06:31:21 <the_berserker> What about things like MultiParamTypeClasses, RankNTypes, GADTs, TypeFamilies?
06:31:21 <prophile> (lazyquestion)
06:31:45 <quchen> Pattern guards
06:32:10 <the_berserker> prophile:  DoAndIfThenElse, PatternGuards, NoNPlusKPatterns
06:32:28 <prophile> k
06:32:31 <prophile> thanks
06:33:18 <quchen> The by far biggest change in H2010 is the FFI
06:33:29 <quchen> Well, not really a change, but an addition
06:39:35 <merijn> the_berserker: The main reason not to mandate RankNTypes, GADTs, etc. is that they are very hard and work intensive to implement and the committee doesn't want to hamstring alternative haskell compilers by making conforming to the standard too hard
06:40:36 <the_berserker> merijn: That would make a lot of GHC-dependent Haskell code portable
06:40:46 <lieven_> lol that's bonkers. the standard is there for the convenience of the users, not the implementers
06:41:58 <merijn> the_berserker: putting something in the report doesn't magically make it portable
06:42:36 <merijn> the_berserker: If we add something to the report and GHC is the only compiler to implement it you still have haskell that only works, the only difference is that by definition you now only have one compiler (GHC)
06:42:52 <merijn> the_berserker: Rather than having multiple haskell compilers and your code being "unportable" (i.e. GHC only)
06:43:10 <merijn> If you don't care about running on anything other than GHC, why worry about being "portable"?
06:43:46 <merijn> lieven_: Right, so you propose that we decide that none of the haskell compilers other than GHC are haskell compilers (because that's what adding these to the report means)?
06:43:52 <merijn> lieven_: Which problem does that solve?
06:44:05 <merijn> lieven_: And if you only care about GHC, why do you care about what the report says?
06:44:46 <bergey> IDK, shifting effort from library authors to compiler authors sounds good to me (as a selfish library author) =)
06:45:10 <merijn> bergey: again, as a library author, what stops you from saying "this is GHC only"?
06:45:17 <merijn> Tons of people do that, and no one minds
06:45:27 <lieven_> this is just another iteration of the common lisp/scheme debate. is it more important to have zillions of unmaintained toy implementations rather than have a complete language suitably for production work?
06:45:40 <quchen> We should put "include a function `terminates :: a -> Bool`" into the Report!
06:45:54 <bergey> merijn: Oh, I do.  I just feel vaguely embarassed about it sometimes.
06:46:29 <merijn> bergey: Why?
06:46:41 <merijn> lieven_: You have one, it's called GHC/haskell
06:47:10 <mattgreenrocks> I’m [slowly] writing a Python interpreter to get better at Haskell. For parsing, I’m considering Parsec. I know python’s grammar can be expressed by it (as it’s LL), but I’m curious if it’s the best choice.
06:47:21 <bergey> I'm curious how Haskell Report decisions are made, but I don't have any real opinion how they should be made.
06:47:27 <merijn> mattgreenrocks: "it depends"
06:47:35 <merijn> bergey: By lots of bikeshedding and arguing
06:48:18 <mattgreenrocks> I know there’s Happy as well, which is closer to yacc. Anything else to take a look at?
06:48:21 <merijn> mattgreenrocks: Parsec is probably the best documented atm and if you don't really care about squeezing the last bit of performance out of parsing it will work just fine
06:48:41 <bergey> Err, because strangers on the internet criticize authors of other, more popular, libraries for not being portable beyond GHC, and this informs my sense of Haskell community norms?
06:49:05 <merijn> bergey: Who does that? I've never seen that other than for some really core libraries like mtl, etc.
06:49:35 <etandel> is there life beyond GHC?
06:49:41 <mattgreenrocks> I do not; I’ll stick with Parsec then. Thanks merijn.
06:49:43 <bergey> Hmm.  I don't have a particular email in mind.  Maybe it's less common than I thought.
06:49:52 <merijn> mattgreenrocks: There's also attoparsec which is a more minimalist, efficient version of parsec which supports incremental parsing, but it doesn't have a transformer and is lacking a bunch of combinators
06:50:14 <mattgreenrocks> Yeah I looked at that, seems a bit smaller in scope to Parsec.
06:51:02 <tdammers> it also has even worse error reporting
06:53:09 <quchen> Even worse? Parsec isn't that bad I think
06:53:42 <quchen> Although you have to be careful where to put try and <?>.
06:55:44 <nomeata> Hi. When I have created a cabal sanbox, how do I actually run "ghc --make" to build a Foo.hs using the libraries from the sandbox?
06:56:02 <quchen> cabal exec ghc -- --make
06:56:30 <quchen> (-- ends Cabal's arguments, all the following will be passed to GHC. Also, --make is automatically enabled in GHC, no need to specify it.)
06:56:39 <nomeata> thx
06:57:18 <quchen> "cabal exec" launches a subshell with certain env variables set that point to the sandbox, that's what makes this thing work.
06:57:22 <_0xAX> I'm calling forkIO in main loop, what is the best practices to wait while it executes and only then finish main loop?
06:57:44 <quchen> Try "cabal exec env" to see the modified environment. There should be a path to your sandbox in there.
06:58:00 <allsystemsarego> _0xAX, use async/wait
06:58:01 <quchen> _0xAX: Use the `async` package if you want to wait for threads
06:58:12 <_0xAX> thank you
06:59:11 <quchen> jle`: Ping?
07:09:17 * hackagebot Hsmtlib 0.2.0.6 - Haskell library for easy interaction with SMT-LIB 2 compliant solvers.  http://hackage.haskell.org/package/Hsmtlib-0.2.0.6 (roger62)
07:09:20 * hackagebot geojson 1.2.0 - A thin GeoJSON Layer above the aeson library  http://hackage.haskell.org/package/geojson-1.2.0 (domdere)
07:09:22 * hackagebot yaml-rpc 1.0.3 - Simple library for network (HTTP REST-like) YAML RPC  http://hackage.haskell.org/package/yaml-rpc-1.0.3 (IlyaPortnov)
07:09:23 * hackagebot yaml-rpc-snap 1.0.3 - Snap server backend for yaml-rpc  http://hackage.haskell.org/package/yaml-rpc-snap-1.0.3 (IlyaPortnov)
07:19:36 <Lutin`> quchen: Probably asleep
07:19:40 <Lutin`> It's 7AM his time
07:20:12 <Lutin`> And he was probably up till 1 or 2 AM
07:44:35 <int3__> so I just stumbled on the Arrow library, and I was trying to do the equivalent of \(a, b) (c, d) -> (max a c, max b d) ... I started out with `max *** max`, but after applying it to e.g. (2, 3) I end up with a tuple of partially applied functions, instead of another arrow... which combinator will remedy this?
07:49:02 <ClaudiusMaximus> :t arr (uncurry max) *** arr (uncurry max)  -- i'd try something like this, int3__ ; arr lifts a function into your arrow, without arr you're using the (->) arrow instance
07:49:03 <lambdabot> (Arrow a, Ord c', Ord c) => a ((c, c), (c', c')) (c, c')
07:49:40 <int3__> ClaudiusMaximus: ahh, thanks!
07:51:42 <jkarni> ClaudiusMaximus: isn't that \(a,b) (c,d) -> (max a b, max b d) instead?
07:51:56 <jkarni> :t \(a,b) (c,d) -> (max a b, max b d)
07:51:57 <lambdabot> Ord t1 => (t1, t1) -> (t, t1) -> (t1, t1)
07:52:20 <jkarni> :t \(a,b) (c,d) -> (max a b, max c d)
07:52:21 <lambdabot> (Ord t1, Ord t) => (t, t) -> (t1, t1) -> (t, t1)
07:56:07 <int3__> ClaudiusMaximus jkarni: http://lpaste.net/106857
07:58:11 <jkarni> (curry f) (0,1) (2,3)
07:59:19 <jkarni> though again, f is doing a comparison within tuples rather than across them
07:59:21 <ClaudiusMaximus> int3__: in your paste, g uses f as a function when it's really an Arrow - if you do what jkarni says you're back to the (->) Arrow, so you might as well not be using the general arrow stuff
07:59:22 * hackagebot explicit-determinant 0.1.0.0 - explicit computation of determinant of small matrices  http://hackage.haskell.org/package/explicit-determinant-0.1.0.0 (JohannesWaldmann)
08:00:20 <jkarni> ClaudiusMaximus: agreed - though using functions *as* arrows, rather than lifting them *into* arrows, is often useful
08:00:38 <jkarni> ClaudiusMaximus: though then there's no need for "arr" in the definition of "f"
08:00:45 <int3__> I was just trying to work off http://stackoverflow.com/questions/9722689/haskell-how-to-map-a-tuple
08:01:14 <int3__> I think they're using the (->) Arrow there too, but the Control.Arrow combinators do seem convenient for some uses
08:06:39 <Lutin`> I think @pl stands for pointLESS
08:06:54 <Lutin`> @pl \(a,b) (c,d) -> (max a b, max c d)
08:06:54 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip max . (((.) . (.) . (,)) .) . max)
08:07:24 <michaelochurch> What is @pl?
08:07:36 <bergmark> flip flip woah
08:07:41 <michaelochurch> @pl \x -> x
08:07:41 <lambdabot> id
08:07:48 <michaelochurch> @pl \x y -> x
08:07:48 <lambdabot> const
08:07:54 <michaelochurch> point-free?
08:08:01 <CindyLinz> michaelochurch: translate to a point less style
08:08:03 <michaelochurch> \pl \ x y z -> x z (y z)
08:08:13 <Lutin`> @pl flip flip snd
08:08:13 <lambdabot> flip flip snd
08:08:18 <michaelochurch> @pl \ x y z -> x z (y z)
08:08:18 <lambdabot> ap
08:08:19 <Lutin`> :t flip flip snd
08:08:20 <lambdabot> (a -> ((a1, b) -> b) -> c) -> a -> c
08:08:27 <Lutin`> oh jeez
08:08:30 <michaelochurch> CindyLinz: cool
08:08:37 <michaelochurch> :t ap
08:08:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:09:12 <jle`> Lutin`: i never sleep :)
08:09:13 <michaelochurch> @pl \x -> x x
08:09:13 <lambdabot> join id
08:09:15 <jle`> well, i have moments.
08:09:29 <michaelochurch> really? it'll point-free something that isn't well-typed?
08:09:31 <michaelochurch> :t join
08:09:32 <lambdabot> Monad m => m (m a) -> m a
08:09:50 <Lutin`> jle`: lol
08:09:53 <jle`> michaelochurch: why isn't \x -> x x well typed? :)
08:09:56 <jle`> quchen is offline though
08:10:06 <michaelochurch> it's an infinite type
08:10:21 <jle`> oh yeah
08:10:23 <michaelochurch> solution to T = T -> T
08:10:25 <Lutin`> It's either infinite or bottom
08:10:26 <napping> that just means you need O'Caml to compile it ;)
08:10:36 <michaelochurch> napping: zing!
08:10:38 <jle`> welp, off
08:10:44 <Lutin`> :t join id
08:10:45 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
08:10:45 <lambdabot>     Expected type: a1 -> a1 -> a
08:10:45 <lambdabot>       Actual type: a1 -> a1
08:10:53 <michaelochurch> so I'm curious (although maybe this is not the place to ask)...
08:10:55 <napping> but I'd be surprised if pl bothers typing things at all
08:10:58 <michaelochurch> Haskell seems like a pretty neat language
08:11:14 <michaelochurch> and I know this is a crass question, but ... is there a job market in it?
08:11:28 <tdammers> michaelochurch: there is, but it's tiny
08:11:34 <michaelochurch> one of the things I am happy to see with Clojure is that it's finally starting to achieve usage
08:11:43 <matematikaadit> :t \(a,b) (c,d) -> (max a c, max b d)
08:11:44 <lambdabot> (Ord t1, Ord t) => (t, t1) -> (t, t1) -> (t, t1)
08:11:48 <michaelochurch> tdammers: do you see that changing?
08:11:56 <tdammers> idk
08:12:01 <michaelochurch> tdammers: maybe I'm a freak but I don't find Haskell *that* hard
08:12:10 <herrwolfe45> is most of the work that you see with both haskell and clojure highly specialized?
08:12:10 <tdammers> it's not that hard
08:12:15 <extraplanetary> if you're happy selling your soul to an investment banker, there seems to be demand there
08:12:28 <michaelochurch> herrwolfe: I don't know much about Haskell work
08:12:31 <tdammers> especially when you're already familiar with statically-typed FP
08:12:54 <michaelochurch> herrwolfe45: you can get yourself in the door at some places by selling Clojure as "magic that enables me to run circles around your CommodityJavaDrones"
08:12:57 <tdammers> the job market is mostly in finance, banking, insurance, trading, and other analysis-heavy industries
08:13:09 <tdammers> that, and a few startups
08:13:15 <michaelochurch> herrwolfe45: works until they start making you attend SCROTUM meetings that cost you 5 IQ points per minute
08:13:15 <matematikaadit> michaelochurch: someone said this "I'm not a mathy person, and I used to have a subconscious aversion to words like Haskell (I just assumed it was way above my IQ), but after giving it a fresh look about 6 months ago I realized how many great learning resources there are (books, blogs, and people) for idiots like me to learn, and I think I can do it."
08:13:22 <herrwolfe45> ha
08:13:29 <extraplanetary> besides finance, the other big economic locus in Haskell is research
08:13:42 <Lutin`> michaelochurch: That's the thing though. Clojure gets its foot in the door through java
08:13:45 <michaelochurch> herrwolfe45: Java is not evil. Java Shops, on the other hand....
08:13:58 <napping> michaelochurch: run ocaml -rectypes, type fun x -> x x;;, receive "('a -> 'b as 'a) -> 'b"
08:14:01 <herrwolfe45> yeah - I've noticed clojure being used in healthcare
08:14:16 <michaelochurch> Lutin`: Clojure is a fantastic language. Maybe the best dynamic language you can get a job in. But dynamic typing is _the absence of a feature_ IMO.
08:14:26 <herrwolfe45> i agree too, it seems like people are willing to make the jump because of the JVM
08:14:49 <extraplanetary> are Microsoft shops doing the same thing wrt F# and the CLR?
08:15:05 <Lutin`> F# is actually kind of nice
08:15:07 <michaelochurch> extraplanetary: is it possible to make decent $$ (average SF programmer, not hedge fund bonuses) in the research world?
08:15:24 <albeit> Using aeson, when encoding a datatype that has some (but not all) nullary constructors, is there a way for it to exclude the "contents" field for nullary constructors, but leave it in for non-nullary constructors?
08:15:46 <Lutin`> albeit: You could make it a Maybe field
08:16:00 <extraplanetary> michaelochurch: no idea, neither domain is anything I have much experience in
08:16:32 <albeit> Lutin`: So add in an extra Maybe field for all the non-nullary constructors?
08:16:42 <albeit> *for all the nullary constrcutors
08:17:11 <Lutin`> I was thinking make the content field Maybe c
08:17:22 <Lutin`> That would be the safest way to do it
08:17:52 <Lutin`> Either that or define a default value for the field
08:18:52 <albeit> Lutin`: So if I have Foo = Bar | Baz String, I would make it Foo = Bar | Baz (Maybe String), and enable omitNothing Fields? Wouldn't that still have a "contents" field for Bar?
08:23:02 <extraplanetary> http://lpaste.net/106821 - I was asking this yesterday but didn't get any replies. Why doesn't GHC unify that? Maybe is an injective type, so it should be able to, I'd thought
08:25:35 <rwbarton> extraplanetary: it works in 7.8
08:25:46 <rwbarton> and indeed it seems like a bug in 7.6
08:26:11 <extraplanetary> aha, thanks
08:26:23 * extraplanetary goes off and sets up a VM
08:32:06 <Lutin`> albeit: Could you lpaste and example JSON?
08:32:11 <Lutin`> I may be confused as to what you mean
08:33:51 <phaazon> hey, do you know a way to make a tagged AST (for instance being able to distingish an Int expression from a Bool one) with GADTs without discarding the possibility of making it a Functor and a Monad?
08:34:03 <Lutin`> albeit: You can use (.:?) for parsing a Maybe
08:34:15 <Lutin`> or combine it with (.!=) for supplying a default value
08:35:10 <albeit> Lutin`: Sure, here is the sample code http://lpaste.net/106861
08:35:22 <Lutin`> phaazon: Check out http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
08:35:44 <phaazon> yeah
08:35:47 <phaazon> I know free monads
08:35:57 <phaazon> but I’ve been told it’s slow
08:36:49 <phaazon> Lutin`: do you know the mtl alternative?
08:38:38 <Lutin`> albeit: One sec let me see if I can find a link
08:38:49 <Lutin`> phaazon: You could use phantom types, but it might be a little ugly
08:39:03 <Lutin`> And still wouldn't quite be a proper functor
08:39:26 * hackagebot haskell-docs 4.2.2 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.2 (ChrisDone)
08:39:43 <Lutin`> albeit: Sorry meant to say phaazon
08:40:16 <phaazon> Lutin`: :(
08:40:55 <Lutin`> I mean if you had `Expr a` you'd still be able to distinguish `Expr Int` from `Expr Bool`
08:42:53 <phaazon>  Lutin` yeah
08:42:54 <phaazon> actually
08:43:02 <phaazon> I have something like Expr l a
08:43:08 <phaazon> where l would be the Int or Bool
08:43:21 <phaazon> and a is the type used by variables
08:43:35 <phaazon> now, if I make an ADT like
08:44:19 <phaazon> data Expr :: * -> * where LitInt :: Int -> E Int a | LitBool :: Bool -> E Bool a | Foo :: E Int a -> E Bool a -> E (Int,Bool) a
08:44:24 <phaazon> how would I make that a Functor or a Monad?
08:45:18 <Lutin`> Well if you want a Functor you need something to construct a LitAnything
08:45:19 <extraplanetary> phaazon: you might want to try and structure it as a category instead
08:45:31 <phaazon> what do you mean extraplanetary?
08:46:39 <extraplanetary> e.g., data Expre :: * -> * -> * where LitInt :: Int -> E a Int; LitBool :: Bool -> E a Bool; Foo :: E a Int -> E a Bool -> E a (Int, Bool); Lifted :: (a -> b) -> E a b
08:47:21 <phaazon> what would be Lifted for?
08:47:26 <extraplanetary> then, if you have another constructor (Compose :: E b c -> E a b -> E a c), you can make a perfectly fine instance of Category for that
08:47:55 <jdnavarro> anyone knows a cabal project with grunt integration I can look up?
08:48:44 <extraplanetary> Lifted there is lifting functions from (->) a b to Expr a b
08:49:55 <phaazon> yeah so Lifted should be :: a -> b -> E a b, no?
08:50:18 <phaazon> oh, nevermind
08:50:22 <Lutin`> albeit: Do you know the version of aeson you're using?
08:50:24 <phaazon> I just don’t get the use of your stuff
08:50:46 <phaazon> E l a, l is a « literal » and a is for free variable
08:50:52 <phaazon> l -> a doesn’t make sense to me
08:51:17 <albeit> Lutin`: Yes, aeson-0.7.0.6
08:53:01 <Lutin`> albeit: Hmm, looking at the source I don't see such an option
08:53:18 <Lutin`> There's only allNullaryToStringTag
08:53:39 <Lutin`> which would mean you'd had to have a data type where all your nullary constructors live
08:54:11 <Lutin`> I'm not really sure why they add the contents irregardless of it being nullary..
08:54:31 <albeit> Lutin`: Yeah.. I was hoping there was some "anyNullaryToStringTag" type option hidden away somewhere
08:54:42 <Lutin`> doesn't look to be the case
08:56:27 <Lutin`> albeit: You could maybe report an issue on the GitHub repo
08:56:35 <Lutin`> With explanation of what you want to do
08:56:42 <Lutin`> Any maybe someone will write up a patch
08:57:46 <albeit> Or maybe I'll try! Might be a good learning experience
08:58:22 <Lutin`> It's in Data.Aeson.TH
08:58:24 <Lutin`> http://hackage.haskell.org/package/aeson-0.7.0.6/docs/src/Data-Aeson-TH.html
08:58:31 <Lutin`> under encodeSum
09:06:35 <MagneticDuck> "that moment when a package that is very important to your project breaks" #justhackagethings
09:06:41 <MagneticDuck> FTGL seems to be broken
09:06:55 <MagneticDuck> relies on an old version of Foreign
09:07:13 <MagneticDuck> ._.
09:07:26 <MagneticDuck> (old version of base, that is)
09:07:56 <Lutin`> MagneticDuck: Try ftgl-bytestring?
09:08:00 <MagneticDuck> hm
09:08:17 <Lutin`> It was at least updated last March 15th
09:08:22 <Lutin`> instead of 5 years ago lol
09:08:26 <MagneticDuck> it works
09:08:27 <MagneticDuck> ikr
09:09:05 <MagneticDuck> protip: so not start using packages that have been updated 5 years ago
09:09:19 <MagneticDuck> s/so/do
09:09:43 <Lutin`> lol that version number
09:09:45 <Lutin`> 1.333
09:10:29 <MagneticDuck> next update is 1.667
09:11:22 <MagneticDuck> oh well that sucks
09:11:36 <nexx> No update in 5 years doesn't mean that the package is bad
09:11:43 <minkowski> 1.666 would have broken the universe
09:12:13 <MagneticDuck> it seems since I last used the GLUT package, some of the low-level binding modules have fallen off the "exposed-modules" list and dived into the "other-modules" list
09:12:20 <MagneticDuck> 1) why would they do that >:(
09:12:34 <MagneticDuck> 2) I realllly need to use one of them, do I have to make my own version of GLUT with those modules exposed?
09:13:22 <Lutin`> nexx: When it relies on FFI, and existed before Haskell2010, the stability does come into question
09:16:08 <MagneticDuck> yo guys?
09:16:14 <MagneticDuck> anybody have any ideas for my problem?
09:16:43 <MagneticDuck> do I have to edit and install locally a modified GLUT package with stuff exposed?
09:16:52 <MagneticDuck> or is there some cool way of accessing hidden modules
09:23:45 <hiptobecubic> You can add them to your cool cabal file
09:25:18 <MagneticDuck> how so?
09:26:39 <hiptobecubic> Oh i missed the first part of your problem. Yeah I think you are boned. Email the maintainer and ask him why he hates his poor users so much?
09:27:00 <hiptobecubic> Or live dangerously. Fork and expose.
09:27:07 <MagneticDuck> yeah
09:31:48 <phaazon> ok, I changed my way of doing: now my AST is represented through a typeclass
09:31:56 <phaazon> it sounds handier
09:32:22 <phaazon> the AST is then a polymorphic value constrained by the typeclass
09:34:17 <bansua> Hi, I'm using some functions which return IO (Either String a), and I would like to sequence these things in a convenient 'do' notation. How can I do that? SHould I nest my do blocks?
09:34:49 <extraplanetary> bansua: are you familiar with monad transformers?
09:35:11 <tolt> bansua: Code would be helpful.
09:35:14 <bansua> extraplanetary: a little bit, yes. I was wondering if EitherT was applicable here, but I'm not fully sure how
09:35:45 <bansua> tolt: it's like do { a <- foo :: IO (Either String a) ; b <- bar :: IO (Either String a) ; ... }
09:37:54 <extraplanetary> bansua: EitherT (or ExceptT in transformers >= 4) will help. You'll want to use `runExceptT :: ExceptT a m b -> m (Either a b)` and `liftIO :: IO a -> ExceptT a IO b` to run/lift actions in/out of the new monad
09:39:08 <bansua> extraplanetary: ah yeah, that's it! thakns!
09:48:00 <camlorn> So. I've got a question, and am lacking the vocabulary to find the answer.  Why does this code fail to compile (I can provide errors, but they're long)?
09:48:00 <camlorn> listToTree:: (Ord a)=>[a]->Tree a
09:48:00 <camlorn> listToTree l = foldl (\v tr-> insert v tr) Tip l
09:48:34 <augur> :t foldl
09:48:34 <lambdabot> (b -> a -> b) -> b -> [a] -> b
09:48:46 <augur> camlorn: ^
09:50:00 <jle`> camlorn: feel free to use lpaste to post the errors :)
09:50:01 <rwbarton> well it depends on what order 'insert' takes its arguments in, but yeah the names 'v' and 'tr' are wrong anyways
09:50:30 <camlorn> I'm not sure what lpaste is.
09:50:38 <augur> @where lpaste
09:50:38 <lambdabot> http://lpaste.net/new/haskell
09:50:38 <jle`> @where lpaste
09:50:39 <lambdabot> http://lpaste.net/new/haskell
09:50:45 <augur> TOO SLOW JLE`
09:50:53 <camlorn> I'll post the code, and then I'd love to talk about why it's wrong.
09:51:02 <jle`> T.T
09:51:07 <pavonia> Paste the errors too
09:51:10 <augur> camlorn: foldl's function arg takes the recursive value first, not second like foldr
09:51:15 <augur> camlorn:
09:51:17 <augur> :t foldr
09:51:18 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:51:20 <augur> :t foldl
09:51:21 <lambdabot> (b -> a -> b) -> b -> [a] -> b
09:51:46 <jle`> is quchen online? I can't check on my Android client. I am perplexed by his ping.
09:51:56 <augur> nope
09:51:59 <augur> not in here anyway
09:52:13 <camlorn> Hang on, let me digest that signature for a sec.
09:52:13 <augur> my client says no on whois
09:52:17 <jle`> ah ty.
09:53:19 <camlorn> His is different from my ghci.
09:53:36 <augur> what?
09:53:57 <camlorn> In ghci, :t foldl gives foldl :: (a -> b -> a) -> a -> [b] -> a
09:54:10 <augur> same thing
09:54:14 <pjdelport> camlorn: That means you might want: listToTree l = foldl (\tr v -> insert v tr) Tip l
09:54:16 <augur> a and b are variables
09:54:25 <camlorn> The problem is that this is my let's dive right in moment and, consequently, I'm not sure how to read them or what differences are meaningful yet.
09:54:33 <pjdelport> (note 'tr' and 'v' are swapped)
09:54:34 <augur> aha
09:54:35 <sinelaw> what's the "fast correct way" to build up text? I'm using String with ++ and I'm guessing that it's slow? (memory doesn't seem to suffer in my case)
09:54:46 <augur> camlorn: perhaps you should avoid using folds until you're comfortable with haskell a bit more
09:55:14 <pjdelport> sinelaw: If efficiency is important, you probably want ByteString or Text.
09:55:23 <camlorn> Also, I'm intentionally not taking the shortcut of pretending that a->b->c->d is a funtion taking a b and c and returning a d, so that's complicating it.
09:55:53 <pjdelport> sinelaw: Both of them have a Builder monoid for composing strings efficiently.
09:56:06 <camlorn> Ah, but I'm comfortable with folds.  I've been in python for a year or so now, and I get what it's doing.  Just the type signatures are throwing me badly.
09:56:07 <sinelaw> ok thanks
09:56:12 <extraplanetary> the specific names of type variables don't matter (type variables start with a lower-case letter)
09:56:17 <augur> camlorn: ok, well
09:56:24 <augur> camlorn: foldl takes its recursive arg first
09:56:29 <augur> camlorn: you wrote the recursive arg second
09:56:41 <sinelaw> Another question: what's a reasonable module name for something that converts between two data formats? e.g. xml and json
09:56:53 <extraplanetary> so, e.g., `a -> b -> a` and `foo -> bar -> foo` and `b -> a -> b` are all the same function, but `Foo -> Bar -> Foo` is different to `Bar -> Foo -> Bar`
09:56:58 <pjdelport> camlorn: The letters have no inherent meaning; (a -> b -> a) -> a -> [b] -> a means precisely the same as (b -> a -> b) -> b -> [a] -> b
09:57:11 <sinelaw> Data.XML or Data.Json don't make sense
09:57:15 <camlorn> Yeah, like C++ templates.
09:57:23 <camlorn> Except probably not like C++ templates, heh.
09:57:31 <augur> no not like C++ templates
09:57:41 <augur> like the type vars in brackets
09:57:48 <extraplanetary> it's the the same in that alpha renaming is a thing
09:57:50 <augur> foldl<A,B> ...
09:57:52 <pjdelport> or (x -> y -> x) -> x -> [y] -> x, or for that matter (acc -> elem -> acc) -> acc -> [elem] -> acc
09:59:10 <pjdelport> camlorn: So the difference between foldr and foldl is only in the first two parameters to the function you give it: foldl has the accumulator on the left, while foldr has the accumulator on the right.
09:59:44 <camlorn> I have it from the type signature, kinda.  Or at least the intuition of how to get it from there.
10:00:03 <camlorn> Can i ask GHCI for the source of a function in the prelude?
10:00:17 <camlorn> I want to pull it up without going back to the haskell 98 report.
10:00:38 <camlorn> Foldl, that is.
10:00:55 <augur> camlorn: learn to use hoogle
10:00:57 <augur> hoogle is better
10:00:59 <augur> @where hoohle
10:00:59 <lambdabot> I know nothing about hoohle.
10:01:01 <augur> :|
10:01:02 <augur> @where hoogle
10:01:02 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:01:25 <augur> hoogle lets you search names as well as types
10:01:26 <augur> for instance:
10:01:38 <augur> @hoogle (a -> b -> b) -> b -> [a] -> b
10:01:40 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
10:01:40 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
10:01:40 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
10:03:24 <camlorn> I'm getting curl now.
10:03:53 <augur> what?
10:04:05 <camlorn> Hoogle needs to build its databases.
10:04:11 <augur> no no
10:04:13 <camlorn> And it's explicitly telling me that I need wget or curl installed. So.
10:04:14 <augur> i mean you can do that but
10:04:17 <augur> just use the website
10:04:20 <augur> @where hoogle
10:04:20 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:04:26 <camlorn> This is where I scare everyone.
10:04:34 <camlorn> I'm visually impaired. Command line is easier for this.
10:04:40 <augur> ahh ok
10:04:59 <augur> you curl your websites tho?
10:05:07 <augur> arent there cli browsers?
10:05:09 <phaazon> http://stackoverflow.com/questions/24559535/proper-tagged-ast
10:05:10 <camlorn> I mean, don't get me wrong. I can interact with websites fine, and for a large search it's actually quite possibly better because scrolling is a pain and I've got all sorts of quick keys for the internet (the entire keyboard in fact).  But to pull up one function, yeah.
10:05:14 <phaazon> if you guys have an idea… :(
10:05:42 <camlorn> No, no.  it's just that blindness breeds familiarity with command line tools and it's faster than opening Firefox.
10:06:05 <augur> camlorn: fair enough
10:06:25 <pjdelport> camlorn: So you're setting up Hoogle's GHCi integration?
10:06:30 <camlorn> I *prefer* firefox for a lot of stuff.  The screen readers are really modern and even respect some css these days.  if I was going to pull up 20 functions, yeah.  But for the source of just one? nah. Overkill.
10:06:45 <camlorn> Ooo, it's got integration?
10:07:07 <augur> camlorn: well part of it is that often there isnt just one function with the name in question
10:07:08 <extraplanetary> you may also want to look at a local installation of lambdabot, which can do hoogle queries and stuff like that
10:07:11 <augur> consider:
10:07:14 <augur> @hoogle foldr
10:07:14 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
10:07:14 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
10:07:14 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
10:07:25 <camlorn> But not from my shell, no?
10:07:29 <pjdelport> camlorn: Yeah, somewhat: http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
10:07:39 <augur> camlorn: and thats just the three that lambdabot shows
10:07:52 <extraplanetary> camlorn: iirc, yeah. I haven't used it in like a year but it's got a CLI interface
10:07:56 <pjdelport> camlorn: It does work from the shell too: you should have a "hoogle" command.
10:08:00 <camlorn> Yeah.
10:08:12 <augur> camlorn: hoogle proper lists something like 8 functions named "foldr"
10:08:18 <camlorn> But I'm not seeing the advantage of lambdabot, given that my shell is not an IRC client?
10:08:47 <augur> camlorn: oh no i dont mean to use lambdabot, its just convenient for in channel examples :)
10:08:52 <extraplanetary> camlorn: lambdabot's CLI thingy exposes its functions directly, no IRC needed
10:09:00 <camlorn> Hmm, I'll have to look.
10:09:08 <camlorn> I definitely have nonstandard use patterns, that's for sure.
10:09:11 <extraplanetary> anyway, back to your question. Your function listToTree has type `(Ord a) => [a] -> Tree a`, and its definition is `listToTree l = foldl (\ v tr -> insert v tr) Tip l`, right? And foldl has type `(a ->  b -> a) -> a -> [b] -> a`, and I'm assuming insert has type `(Ord a) => a -> Tree a -> Tree a`
10:09:45 <sinelaw> @hoogle Text -> Text
10:09:46 <lambdabot> Data.Text copy :: Text -> Text
10:09:46 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
10:09:46 <lambdabot> Data.Text init :: Text -> Text
10:09:53 <pjdelport> camlorn: You can also try GHCi On Acid, or GOA: http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
10:09:57 <augur> im sure that message is really easy to parse with a screen reader, extraplanetary :P
10:10:01 <sinelaw> @hoogle Text -> Text -> Text
10:10:01 <lambdabot> Data.Text append :: Text -> Text -> Text
10:10:02 <lambdabot> Data.Text.Lazy append :: Text -> Text -> Text
10:10:02 <lambdabot> Data.Text.Lazy.Internal Chunk ::    Text -> Text -> Text
10:10:04 <pjdelport> camlorn: That gives you a :source command, among other things.
10:10:06 <sinelaw> @hoogle Text -> String-> Text
10:10:06 <lambdabot> Debug.Trace trace :: String -> a -> a
10:10:06 <lambdabot> Data.Text.Lazy snoc :: Text -> Char -> Text
10:10:06 <lambdabot> Data.Text snoc :: Text -> Char -> Text
10:10:09 <augur> sinelaw: stop
10:10:14 <sinelaw> sorry :)
10:10:33 <augur> sinelaw: do that in a /msg or go to the website
10:10:50 <camlorn> You've got the type right, yeah.
10:11:12 <augur> camlorn: you just need to swap tr and l in your lambda's args
10:11:20 <augur> er, tr and v sorry
10:11:23 <camlorn> The code compiles now, and I do ahve some intuition of how I tell what foldl needs form the type signature-but you don't understand it until you can articulate it, so I probably don't understand it just yet.
10:11:36 <extraplanetary> so what GHC does is sees that l has type `[a_from_listToTree's_signature]`, and fills in the `[b]` in foldl's signature with that. Then, it notices that Tip has type `Tree a_from_listToTree's_signature`, and fills in the `a` in foldl's signature with -that-
10:12:17 <camlorn> Can I ask ghci to show me the steps in the type inference?
10:12:28 <augur> camlorn: the intuition is like this:   foldr op base [x,y,z] == x `op` (y `op` (z `op` base))
10:12:28 <camlorn> or see it in some way, at any rate.
10:12:38 <extraplanetary> camlorn: this means that GHC thinks that the function you're passing in to foldl has type `Tree a_blah -> a_blah -> Tree a_blah`, but insert has the arguments the other way around
10:12:45 <augur> camlorn: whereas   foldl op base [x,y,z] == ((base `op` x) `op` y) `op` z
10:13:32 <augur> camlorn: foldr is right associativity while foldl is left. the base arg is therefore either on the right, or the left, depending, and the recursive 'op's are either on the right or left spine of the application
10:14:44 <camlorn> I see the pattern now that I've done it.
10:15:20 <augur> faster than me. took me ages to properly grok fold :(
10:15:26 <extraplanetary> camlorn: I -think- the best way to single step through type unification would be to write the signatures in Prolog and single step through that
10:15:44 <camlorn> I'm not fully groking yet.
10:15:44 <augur> like, i honestly can say i didnt feel comfortable with fold until i real some papers on generic folds
10:15:46 <extraplanetary> but that sounds horrible and I don't know if any Prolog interpreters support single-stepping through unification anyway
10:16:02 <camlorn> But I've used python list comprehension a lot and all of the Pythonic funcitonal stuff.
10:16:03 <augur> i mean, years after learning about folds, right
10:16:14 <augur> it was brutal :(
10:16:28 <camlorn> And so my first thought is "put things from a list into something else", wel, fold.  Except that really I think of it as reduce still.
10:16:44 <augur> camlorn: actually the pattern turns out to be pretty simple
10:16:53 <camlorn> Ah the fun of language x cals thing y z, but language n cals it c...
10:17:01 <augur> camlorn: consider the definition of sum, using pattern matching:
10:17:03 <Lutin`> Well you can do things like
10:17:05 <augur> sum [] = 0
10:17:11 <augur> sum (x:xs) = x + sum xs
10:17:28 <Lutin`> foldl' S.insert S.empty xs
10:17:38 <Lutin`> Where S is Set
10:17:40 <athan> First time using haddock... on invocation, does it look for all source files to generate documentation? Or do I have to do my own src file folder traversals?
10:17:46 <pjdelport> camlorn: The type inference really just involves replacing each type variable with a more concrete type. In this case, because you have "listToTree:: (Ord a) => [a] -> Tree a", it just means the last type variable gets instantiated to be "Tree a", and the second-last to "(Ord a) => a"
10:17:48 <augur> camlorn: notice how the recursive use of 'sum' is applied to the tail of the list
10:18:03 <athan> I love folding now :)
10:18:10 <mzero> athan: if you have a .cabal file for your project - then just ask cabal to generate the haddock:   cabal haddock
10:18:14 <pjdelport> camlorn: So if you substitute those types into "foldl :: (a -> b -> a) -> a -> [b] -> a", you get: foldl :: (Ord a) => (Tree a -> a -> Tree a) -> Tree a -> [a] -> Tree a
10:18:30 <mzero> if you don't have a .cabal file for your project - it is probably easier to create .cabal file for it than figure out how to call haddock by hand!
10:18:41 <bansua> extraplanetary: hi, still have a problem using this. I have the following code: https://gist.github.com/anonymous/3d475a84b46e3bc4b68a . Now the problem is that the db' variable is of type Either String DB, and not of type DB. I want to return the last DB of several such statements
10:18:45 <camlorn> So haskell is just smart enough to know to leave the lambda for last?
10:18:55 <athan> mzero: O: By the power of grayskull!
10:18:57 <augur> camlorn: foldr represents a pattern match like that. only with the args flipped
10:19:07 <athan> mzero: Thank you :)
10:19:12 <mzero> :-)
10:19:25 <augur> camlorn: instead of writing sum like that, we could write   sum = foldr (\x rec -> x + rec) 0
10:19:26 <Lutin`> If you don't have a .cabal file, make one!
10:19:42 <Lutin`> cabal exec -- ghc ... gets tiring after a while lol
10:19:52 <augur> camlorn: the rec argument represents the recursively computed foldr (or in this case, the recursive sum, that is to say, `sum xs`)
10:20:01 <camlorn> Nod..
10:20:03 <pjdelport> camlorn: Yeah, there's no specific ordering to type inference. Wherever you constrain a type, the constraint will propagate naturally.
10:20:10 <bansua> extraplanetary: do I still need to explicitly sequence the inner Either monad?
10:20:18 <augur> camlorn: you could maybe even write   sum = foldr (\x sumxs -> x + sumxs) 0
10:20:23 <athan> camlorn: Something funny about foldr/foldl is how it generates the expression... try folding a list of numbers with (^) in each fold ;)
10:20:31 <camlorn> Augur: Is the l/r representative of where the fold starts, or which direction it moves?
10:20:37 <Lutin`> camlorn: This might help http://www.haskell.org/wikiupload/3/3e/Right-fold-transformation.png http://www.haskell.org/wikiupload/5/5a/Left-fold-transformation.png
10:20:49 <camlorn> Ah, alas. No.
10:21:04 <pjdelport> camlorn: The l and r just means left-associative and right-associative.
10:21:07 <camlorn> We don't have weakly godlike AI to  auto-describe images, yet.
10:21:11 <extraplanetary> bansua: IO (Either a b) /= ExceptT a IO b. You need to transform it
10:21:14 <augur> Lutin`: that wont help, dude. camlorn has a visual impairment, pics wont help
10:21:19 <Lutin`> Oh
10:21:21 <pjdelport> camlorn: There isn't necessarily a specific order of evaluation, due to the way Haskell works.
10:21:22 <Lutin`> Didn't know that
10:21:30 <camlorn> Augur: it's fine. Just wait until I use the I can see idiome.
10:21:40 <augur> camlorn: actually, foldl is a cheat. "foldr" is the fold for cons lists, "foldl" is the fold for snoc lists
10:21:57 <Lutin`> camlorn: You don't happen to live in Boca, do you?
10:22:03 <bansua> extraplanetary: yeah I can run it fine with runExceptT to get my IO (Either a b). THe trouble is that db :: Either String DB instead of db :: DB
10:22:06 <extraplanetary> bansua: I think `ExceptT :: IO (Either a b) -> ExceptT a IO b` is what you want (but I haven't checked the docs)
10:22:29 <camlorn> Augur: I think I need to find a long and technical explanation.  Alternatively, manage to finish flipping the "evaluation order does not exist" switch.
10:22:40 <Lutin`> camlorn: I go to FAU
10:22:51 <camlorn> Ah, so do I.
10:22:53 <bansua> extraplanetary: right, the liftIO does that for me, right?
10:22:59 <Lutin`> how funny
10:23:05 <camlorn> If you mean florida atlantic university, that is. You've probably seen/heard of me.
10:23:13 <Lutin`> I'm Sam Schlegel
10:23:15 <bansua> extraplanetary: or does that actually give me ExceptT a IO (Either String b) ?
10:23:16 <extraplanetary> bansua: no. `liftIO :: IO a -> ExceptT a IO b`. That takes an IO action that can't fail
10:23:27 <augur> camlorn: i'd be happy to try to explain. not right now, im going to grab something to eat, but in like an hour or two if you want
10:23:28 <Lutin`> small world haha
10:23:46 <extraplanetary> bansua: you have it exactly. To 'lift' functions which can fail, you need to use something else (which is specific to the transformer)
10:23:51 <augur> camlorn: or whenever!
10:23:57 <Lutin`> camlorn: We should get together and Haskell it up some time
10:23:58 <camlorn> Augur: It's going to be something I need to read.  You took me from "I understand this tool" to "I can use this tool", so...
10:24:31 <augur> camlorn: ill try to find resources that dont rely on visualizations
10:24:35 <pjdelport> camlorn: foldl (+) 0 [1..5] gives you: ((((0 + 1) + 2) + 3) + 4) + 5
10:25:08 <pjdelport> camlorn: while foldr (+) 0 [1..5] gives you: 1 + (2 + (3 + (4 + (5 + 0))))
10:25:28 <camlorn> Lutin`: Sure. I've been touching haskell for 15 minutes or so, only.  Considering writing a small interpreter in it, with the intent of extending it to a compiler, as I've heard that's a standard CS thing everywhere except FAU.
10:25:40 <Lutin`> Tell me about it...
10:26:11 <Lutin`> camlorn: So maybe it's better to start with how lists work in haskell
10:26:30 <pjdelport> camlorn: In terms of evaluation order, you can generally think of haskell as evaluating from the outside inwards, instead of from the inside outwards.
10:26:31 <bansua> extraplanetary: you mean I need some function from https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html ?
10:26:38 <extraplanetary> bansua: right
10:26:42 <bansua> don't really see anything relevant in there to sequence the Eithers
10:27:06 <Lutin`> A list [1,2,3] is represented as 1:2:3:[] where : is called the cons operator because it constructs list and [] is the empty list
10:27:17 <Black-Heaven> Hi all, I have some troubles with promoted datatypes: I try to have Natural at type level and then convert them back to value-level (http://pastebin.com/YyuKBjPc), but I fail. If you have any solution/explanation, please, share it. Thanks.
10:27:18 <bansua> extraplanetary: I thought the point of monad transformers was to sequence all the monads automatically?
10:27:20 <camlorn> Yeah. Singly linked, internally.
10:27:36 <Lutin`> So the : operator is right-associative
10:27:58 <pjdelport> camlorn: That's why you can actually think of the left-associative fold as evaluating from the right, in a sense, because the rightmost element (... + 5) is the outermost function application.
10:27:59 <camlorn> I've got a bit of a scala background, too.  The problem here is that I am naively assuming that foldl "does something in an order".  I'm getting the feeling that, no, it doesn't.
10:28:03 <Lutin`> meaning 1:2:[] = 1:(2:[]) as opposed to (1:2):[]
10:28:07 <augur> hmm. camlorn, how comfortable are you with algebrai data types?
10:28:23 <bansua> extraplanetary: I understand the automatic lifting part and things like liftIO in contrived examples using Reader/Writer/State
10:28:23 <merijn> Black-Heaven: Eh, this can't work
10:28:29 <extraplanetary> bansua: it really depends on what you mean by 'sequence'. Monad transformers are a way of composing monadic effects; the thing is that monads, in general, don't compose
10:28:31 <camlorn> Not at all. What subject are they a part of, and do we ahve a textbook in LaTeX? Heh.
10:28:36 <augur> camlorn: no no, all it does is associate the operator left, as opposed to right
10:28:44 <merijn> Black-Heaven: "natToInt :: n -> Int" <- n has kind Nat, but (->) can't have an argument of kind Nat
10:28:45 <augur> camlorn: eg (x+y)+z vs x+(y+z)
10:28:45 <pjdelport> camlorn: Conversely, the right-associative fold evaluates "from the left" in that sense, because the outermost application is (1 + ...)
10:28:57 <Lutin`> camlorn: I can look through my books I have, some are in PDF some are in EPUB
10:29:12 <merijn> Black-Heaven: "(->) :: * -> * -> *" (this is actually a lie, but that shouldn't matter for this situation)
10:29:32 <pjdelport> camlorn: That's why you can use foldr with infinite lists, but not foldl.
10:29:41 <bansua> extraplanetary: right, is there any documentation on how to understand how to compose them? Monad tranformers step by step doesn't help me understand these ones without rolling my own transformer
10:30:11 <camlorn> Let me be more clear.  I consider foldl and foldr to "eat" lists.
10:30:11 <allsystemsarego> @ty iterateM_
10:30:12 <lambdabot>     Not in scope: ‘iterateM_’
10:30:12 <lambdabot>     Perhaps you meant one of these:
10:30:12 <lambdabot>       ‘iterate’ (imported from Data.List),
10:30:41 <camlorn> Like, foldl startrs at the left and "eats" the elements until it gets to the right.  But I think this is inaccurate.
10:30:50 <augur> camlorn: sure, you can think of it like that
10:31:02 <extraplanetary> bansua: try with the 'ExceptT' constructor (constructor, not type). That's how you go from IO (Either a b) to ExceptT a IO b.
10:31:03 <merijn> Black-Heaven: Take a look at http://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-TypeLits.html
10:31:03 <camlorn> By my understanding, foldr is fine for infinite lists because you have to start this process at a finite point into the list, and it's going to head towards what I consider index 0 in my mental model.
10:31:33 <merijn> > foldr f z [a,b,c]
10:31:34 <lambdabot>  f a (f b (f c z))
10:31:40 <Lutin`> camlorn: The subtle point is while this is true, you're thinking of it from a strict evaluation order
10:31:44 <augur> camlorn: the function argument of folds is the "step" function -- how to get from the accumulated result so far, plus the current value, to the next accumulated result
10:31:47 <merijn> camlorn: Now imagine that 'f' only evaluates 'a' in the function
10:32:00 <merijn> camlorn: For example "True && x" never evaluates x
10:32:08 <merijn> > foldr (&&) z [a,b,c]
10:32:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
10:32:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
10:32:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
10:32:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
10:32:10 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
10:32:13 <merijn> hmmm
10:32:16 <augur> i wonder how many people are going to repeat the the same thing, pjdelport, merijn ...
10:32:20 <Lutin`> heh
10:32:29 <Black-Heaven> merijn: thanks
10:32:31 <augur> i wonder how many times we can show camlorn the result of evaluating a fold in-the-abstract...
10:32:39 <bansua> extraplanetary: aaah, that's it!
10:32:58 <augur> camlorn: yes, your intuition about consuming a list is correct
10:33:01 <bansua> extraplanetary: is it supposed to be that hard to figure out? :)
10:33:43 <augur> camlorn: these folds have two args, tho, right, an initial value, and a function to compute the next (version of) the result value
10:33:45 <extraplanetary> bansua: luckily enough, once you know the pattern it's easy to spot. You might think of 'monad transformers' as just being convenient newtypes to get a nicer Monad instance
10:34:09 <pjdelport> camlorn: A very useful insight to have is that foldr simply replaces the constructors of the list. That is, foldr (:) [] is the identity fold for lists.
10:34:12 <augur> camlorn: the function takes two args: the accumulated value, and the list element
10:35:06 <augur> pjdelport: thats the exact same thing you and merijn and i have said just with words...
10:35:23 <bansua> extraplanetary: they seem like a terrible idea though, having to implement every class for each monad transformer in order not to lift stuff all the time. Is there no better solution?
10:35:38 <pjdelport> augur: Nobody mentioned constructor replacement yet. :P
10:35:38 <camlorn> pjdelport: Huh. I actually got that.
10:36:21 <nadirs> > foldr f x [True, False, True] -- merijn: I often have troubles with simple-reflect too :P
10:36:22 <lambdabot>  f True (f False (f True x))
10:36:31 <pjdelport> camlorn: In other words, you can think of foldr as a structural transformation, rather than a process.
10:36:31 <augur> camlorn: the closest imperative analog is a for loop like so:
10:37:14 <extraplanetary> bansua: it's not a clean situation; there's some work on coming up with better ways to compose effects, but it's a hard problem. It also helps if you distinguish transformers from mtl. transformers is the collection of newtypes and functions for working on them; mtl is the collection of classes for automagically lifting effects through a stack of newtypes
10:37:15 <augur> camlorn:    var acc = z; for (x in xs) { acc = f(acc,x); }
10:37:29 <augur> camlorn: this is roughly like doing   foldl f z xs
10:37:39 <camlorn> Yeah. that's the model I'm working with it as.
10:38:01 <augur> camlorn: conversely, foldr is like this:    var acc = z; for (x in reverse(xs)) { acc = f(x,acc); }
10:38:26 <Lutin`> camlorn: Did you understand the replacing the constructors of the list?
10:38:38 <augur> camlorn: aside from traversal order differences, notice that the f argument swaps its arguments around
10:39:14 <extraplanetary> you can stick with pure transformers and avoid the quadratic blowup in instances, but you have to manually count the appropriate number of lifts. It's often helpful to use a newtype of your own around the stack of transformers, so that you only need one lift in 'user' code (with the appropriate MonadTrans instance)
10:39:41 <camlorn> Lutin`: Yes.
10:39:54 <koala_man> I have an analysis tool with a hundred independent checks to apply to a file. In Java/C# I would have a hundred different classes in a package. How should I do it in Haskell? It's currently a hundred functions in a single file, and it's getting unwieldy
10:40:14 <Black-Heaven> merijn: in fact i fall in trouble for doing NatToInt Z or NatToInt 'Z because Z has kind Nat, not *. I remember have doing something similar, but I can't either find it or reproduce it :/
10:42:06 <Lutin`> camlorn: So `foldr (:) []` being the identity makes sense yes?
10:42:21 <pjdelport> camlorn: The structural view of foldr is very handy. For example, starting with the identity fold, you can say: map f = foldr ((:) . f) []
10:42:42 <bennofs> koala_man: Maybe you can make a Check type that contains all that it necessary to characterize a check? Maybe you can even make a Monoid instance for Check then, so you can write check1 `mappend` check2 `mappend` check3 `... to combine multiple checks into a single Check that can then be applied to a file?
10:42:42 <camlorn> Lutin`: yes, but I think it is important for me to write it out with prefix notation myself, which I will do momentarily.
10:43:00 <Lutin`> camlorn: Alrighty
10:43:20 <Lutin`> Then chew on this after you write it down: foldl (:) [] = reverse
10:43:22 <pjdelport> camlorn: In other words, to implement map, you just "prepend" f to each element, but otherwise leave the structure unchanged.
10:43:27 <camlorn> Lutin`: Looking at that line, it is clear why it's an identity transformation; however, how I see it as such still probably remains inaccurate.
10:44:22 <camlorn> Lutin`: I have that without writing it; it's because foldl and foldr reverse the parameters to the function.  Writing it infix actually makes it clearer here.
10:45:16 <camlorn> Ah, wait. Come here, GHCI.
10:45:45 <bansua> extraplanetary: thanks, that's very helpful. I appreciate the problem, even if it seems a bit unwieldy at first
10:47:23 <extraplanetary> bansua: if you're interested in an alternative approach: Applicatives -do- compose generally. If your problem doesn't need the extra power Monads give you, you might consider trying with them (and Data.Functor.Compose)
10:48:39 <koala_man> bennofs: would I have a hundred different modules, each exporting one check? would I try to group them into a few modules by topic?
10:49:04 <bansua> extraplanetary: cool thanks, I'll have a think about how that fits into what I'm doing
10:49:05 <camlorn> Lutin`: You can't use foldl for reverse.  The first argument to cons can't be a list. Am I missing something?
10:49:08 <bennofs> koala_man: idk, that depends on the size of the checks
10:49:19 <Lutin`> camlorn: It flips the order of the arguments :)
10:49:25 <koala_man> bennofs: 5-100 lines each
10:49:33 <bansua> extraplanetary: for the the most troubling thing is proper error handling
10:50:26 <extraplanetary> koala_man: how much common structure is there to these checks? If you have literally hundreds, you might consider a DSL of some sort
10:50:42 <camlorn> Lutin`: Yeah, you can do it with flip.
10:50:54 <Lutin`> camlorn: Ah whoops forgot that
10:51:04 <Lutin`> camlorn: Yeah you have to use snoc instead of cons
10:52:40 <camlorn> All right.  Well, trees work.  Time to break them by explicitly not allowing Haskell to provide default Ord, Show, and Eq for me (i fact, let's see if I get Ord for free, heh).
10:59:51 <koala_man> can I have multiple files per module?
11:00:56 <merijn> koala_man: No, but you can reexport entire modules from another
11:01:29 <merijn> koala_man: So you can have MyApp.Module.Foo, MyApp.Module.Bar, MyApp.Module.Baz and reexport all of them from MyApp.Module
11:03:58 <mzero> although a more common idiom is    MyApp.Foo rexports from MyApp.Foo.Types, MyApp.Foo.Combintors, MyApp.Foo.Utilities, etc...
11:04:20 <phaazon> seriously I feel like crap; I can’t write my AST, I just fail
11:04:37 <phaazon> I’d like to be able to have tagged nodes, so GADT
11:04:49 <phaazon> but I can’t make it Monad
11:05:10 <phaazon> even don’t foresee the terrible stuff it’s gonna be to make it work with bound
11:10:07 <koala_man> would it be a bad idea two have a hundred small modules in a library and have the cabal file expose a single one that combines them all? the goal is to avoid big files and long recompiles
11:10:41 <koala_man>  http://www.reddit.com/r/toppkommentatorene/
11:10:41 <koala_man>  http://www.reddit.com/r/toppkommentatorene/
11:10:53 <koala_man> oops.
11:12:02 <koala_man> my new keyboard apparently has mouse click buttons next to Alt :|
11:13:02 <dwcook> phaazon, I don't think a GADT that is not definable as a regular ADT can have a valid Functor instance. Someone else can correct me if I'm wrong.
11:13:53 <phaazon> dwcook: well, my GADT has a Functor instance
11:14:08 <dwcook> phaazon, mind if I have a look?
11:14:12 <phaazon> yeah
11:14:19 <rwbarton> it could be GADT-y in the first arguments, but functorial in the last argument
11:14:21 <merijn> dwcook: Sure it can
11:14:23 <phaazon> http://stackoverflow.com/questions/24559535/proper-tagged-ast
11:14:31 <dwcook> rwbarton, ah, you're right
11:15:21 <phaazon> I’m not even sure it’s the “correct” way of tagging node
11:15:33 <phaazon> I’m trying again with a regular AST, no GADT
11:15:39 <rwbarton> phaazon, I think once you have this type indexing it's no longer a monad, but an indexed monad or maybe something stranger
11:16:03 <rwbarton> imagine "expression of type a with variables of type b"
11:16:25 <phaazon> rwbarton: yeah
11:16:35 <rwbarton> that is an indexed monad
11:16:47 <phaazon> so I can’t used bound
11:16:52 <phaazon> with such a GADT
11:17:30 <rwbarton> but you might want something even more general
11:17:40 <rwbarton> no reason why all the variables in an expression necessarily have the same type
11:19:43 * hackagebot haskell-token-utils 0.0.0.2 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.2 (AlanZimmerman)
11:23:22 <Laurine21>  Here some videos. I hope you like them! http://bit.ly/1j0MPvG
11:24:43 * hackagebot apiary 0.11.1 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.11.1 (HirotomoMoriwaki)
11:24:45 * hackagebot apiary 0.11.2 - Simple web framework inspired by scotty.  http://hackage.haskell.org/package/apiary-0.11.2 (HirotomoMoriwaki)
11:29:38 <stijlist> Hi everyone, I have an algebraic data types question:
11:30:22 <stijlist> I’m working on a project where the user interface has multiple modes and I’ve defined each mode as a part of an algebraic data type. So I have the rough equivalent of:
11:30:37 <stijlist> data Modes = Mode1 | Mode2 | Mode3
11:30:41 <stijlist> case mode where  Mode1 -- enable first mode etc.
11:31:02 <stijlist> However, I just realized that the user should be able to use both Mode1 and Mode3 at the same time, and I may add more modes that overlap with the ones that exist now. How do I communicate this to the type system?
11:31:35 <merijn> stijlist: [Mode]?
11:31:39 <stijlist> So can I have some kind of data type in which I enforce that the user can be in mode 1 and mode 3 at the same time, but not in mode 1 and mode 2 at the same time?
11:31:39 <Cale> stijlist: Perhaps use a Set or list of modes?
11:31:49 <merijn> Or do you mean "only some combinations are valid"?
11:31:55 <dmj`> stijlist: data User = User { userModes = S.Set Mode }
11:32:02 <stijlist> merijn: Exactly, only some combinations are valid
11:32:05 <mzero> it isn't clear that this *is* something you want to express in the type system
11:32:16 <Cale> stijlist: You could of course add constructors like Mode13 or something. It might be worth thinking more about what the modes actually mean and representing that instead.
11:32:20 <phaazon> stijlist: so you can combine two modes, but it might fail
11:32:26 <mzero> for example, is there code that can only be executed if the user is in a particular combination of modes?
11:32:32 <stijlist> precisely, yeah
11:32:57 <stijlist> Some code should only be executed if a user is in both 1 and 3
11:33:07 <stijlist> To allow for both to coexist
11:33:13 <stijlist> I totally understand if this isn't a type-level concern
11:33:25 <phaazon> a Set sounds correct to me
11:33:36 <stijlist> For some reason my intuition was telling me that there would be a way to enforce this
11:34:13 <stijlist> thanks all, I'll use the Set approach
11:34:18 <pjdelport> stijlist: How are the overlapping modes related, exactly? Can they be decomposed?
11:34:43 <dmj``> I have a library with some tests (main = verboseCheck testThing). When
11:34:44 <dmj``>        run with cabal test it doesn't print test results to stdout like
11:34:44 <dmj``>        running it in ghci does. How do I get cabal test to print verboseChecks
11:34:44 <dmj``>        output? Just says, "Test Passed <TestName>"
11:34:48 <dmj``> sorry
11:34:59 <stijlist> pjdelport: They are actually user interface modes; it's a touch interface that is designed to be used with both hands
11:35:16 <twelve_elephant> consider the type signature foo :: (Eq a) => a -> b
11:35:23 <pjdelport> stijlist: In other words, could you for example have something like Mode = Mode1 | Mode2 Bool, where the flag to Mode2 distinguishes between a submode or not?
11:35:37 <twelve_elephant> what is the name of the part "(Eq a) =>"
11:35:40 <phaazon> you could also go as newtype Mode = Mode Int, mode0 :: Mode, mode1 :: Mode… instance Monoid Mode where you do the combination yourself in there using bit shifts? :D
11:35:47 <twelve_elephant> ie, is this called something specific
11:36:01 <pjdelport> twelve_elephant: It's a type class constraint.
11:36:08 <twelve_elephant> pjdelport: Thanks
11:36:17 <merijn> Or more generally just "constraint"
11:36:21 <phaazon> yeah, constraint
11:36:36 <stijlist> phaazon: interesting
11:36:36 <merijn> Since you can now have non-typeclass constraints in GHC! :D
11:37:04 <stijlist> pjdelport: Mode 1 and 3 can exist independently of each other AND together, unfortunately
11:37:24 <phaazon> stijlist: I think the Set way is better, because you can still pattern match mode, and you can provide the function that combines / fetch modes into / from the set
11:37:24 <pjdelport> stijlist: What are the modes, actually?
11:38:00 <pjdelport> stijlist: It is worthwhile to see if you can encode the constraints into the type, but that may depend on knowing the details.
11:38:20 <gaze__> hey guys I could use some help trying to formalize some general computer sciencey stuff. Say I have a computer architecture in which the effect of an instruction is available some number of instructions later. Like, I set a register, and between now and the time that the register is set, looking at the register's contents is an error
11:38:34 <gaze__> but I should be able to do other things while the value of the register is being computed
11:39:47 <gaze__> what's a reasonable way to formalize these semantics?
11:40:19 <stijlist> pjdelport: For context, it's a live editor; the app is running and you're able to manipulate it. There's a 'manipulation' mode where your touches can move/grow/shrink elements (mode 1), there's a 'snapping' mode in which your motion is snapped to meaningful points on the screen, and there's a 'sublayer/zooming' mode once you've dragged a view on top of another so that you can lay out subviews with constraints based on their superv
11:40:36 <merijn> gaze__: I'm not sure this is what you're looking for, but the clash guys are working on a DSL for describing hardware in haskell
11:40:44 <pjdelport> stijlist: You got cut off at "...based on their superv"
11:40:52 <stijlist> pjdelport: and of course, there is a static mode in which you can simply use the application. currently denoted by the absence of modes
11:41:03 <merijn> gaze__: afaik they manage to simulate registers and chips like that already
11:41:05 <gaze__> merijn: I'm talking about a strictly software thing
11:41:06 <stijlist> pjdelport: it ended at 'superviews'
11:41:11 <gaze__> oh hmm
11:41:44 <merijn> gaze__: Like I said, I'm not sure it's what you want, but couldn't hurt to spend 5 minutes checking it out: http://clash.ewi.utwente.nl/ :)
11:42:04 <gaze__> merijn: Yeah absolutely
11:42:42 <dmj``> anyone know how to get cabal test to print quickcheck results to stdout instead of just saying, "Test passed <TestName>"
11:44:22 <pjdelport> stijlist: Perhaps in that case the best way to approach the two concurrent modes is something like a Mode Bool Bool option, where the two flags represent Mode1 and Mode3, or whatever the case is.
11:44:40 <dmj``> ahhh: cabal test --log=/dev/stdout
11:44:48 <pjdelport> stijlist: Then, you hide the raw Mode constructor, and expose a different one that checks that either one or both of the flags are set.
11:59:06 <stijlist_> pjdelport: OK, so this is what I'm thinking is the best sol'n:
11:59:17 <stijlist_> an algebraic data type describing the modes
11:59:44 <stijlist_> and my own monoid operator for combining modes, that disallows illegal states
12:00:14 <stijlist_> so that when i'm pattern matching on combined modes, I don't have to include illegal states in my patterns
12:00:20 <stijlist_> maybe that's the best i'll get
12:04:47 * hackagebot l-bfgs-b 0.1.0.1 - Bindings to L-BFGS-B, Fortran code for limited-memory quasi-Newton bound-constrained optimization  http://hackage.haskell.org/package/l-bfgs-b-0.1.0.1 (GardSpreemann)
12:07:53 <Stella21>  You can find funny videos here. http://j.mp/1j11tCG
12:08:13 --- mode: ChanServ set +o geekosaur
12:08:21 --- mode: geekosaur set +b *!*Stella21@95.141.20.*
12:08:22 --- kick: Stella21 was kicked by geekosaur (Stella21)
12:08:38 --- mode: geekosaur set -o geekosaur
12:24:13 <Exio4> what would be the syntatic sugar for something like "getLine >>= \x -> getLine >>= \y -> return (x,y)"?
12:24:55 <dv-> do {x <- getLine; y <- getLine; return (x,y) }
12:25:15 <pavonia> @help do
12:25:15 <lambdabot> do <expr>
12:25:15 <lambdabot> Translate Monad operators to do notation.
12:25:22 <Exio4> i was thinking about a "single-line" construct
12:25:38 <Exio4> having a m (a, b) out of (m a, m b) should be something not that weird
12:25:54 <zomg> You could probably use applicative
12:25:56 <joshc> in the applicative style, (,,) <$> getLine <*> getLine
12:25:58 <zomg> something like `(,) <$> getLine <*> getLine`
12:26:11 <joshc> woops, yeah, with the correct tuple constructor :)
12:26:19 <Exio4> didn't think about applicative, thanks!
12:26:37 <pavonia> There's also liftM2 (,) getLine getLine
12:28:26 <Exio4> thanks, i'll use liftM2
12:29:32 <corgifex> join (liftM2 (,)) getLine
12:29:40 <corgifex> @do join (liftM2 (,)) getLine
12:29:41 <lambdabot> join (liftM2 (,)) getLine
12:44:41 <mcsmash> might this be a place for noob-ish questions?
12:44:50 * hackagebot handle-like 0.1.0.0 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.1.0.0 (YoshikuniJujo)
12:45:04 <eikke__> mcsmash: sure
12:45:10 <merijn> mcsmash: This is the place for questions from noob-ish to phd difficulty :)
12:45:30 <mcsmash> I'm having a little trouble with my first program.
12:45:36 <mcsmash> so exceptionally noobish.
12:46:42 <Pythonfant> mcsmash: you need to be a little bit more precise if you want people to help you
12:47:05 <benzrf> mcsmash: its perfectly normal to suck a lot at haskell when you start out if you havent done FP before
12:47:14 <benzrf> its basically like learning to program all over again
12:48:18 <moghedrin> benzrf: But with more frustration ;D
12:48:19 <mcsmash> http://pastebin.com/7JGmtYU8
12:48:34 <mcsmash> There's the code and resulting output.
12:48:49 <moghedrin> Capitalize int ;D
12:48:56 <moghedrin> Should be Int
12:48:59 <mcsmash> oh bloody hell >_<
12:49:01 <mcsmash> lol
12:49:06 <hiptobecubic_> there are no tuples of cardinality 1 are there?
12:49:11 <mcsmash> adventures in new language land
12:49:29 <taktoa>  all types start with capital letters
12:49:38 <Pythonfant> hiptobecubic_: what would be the point of that?
12:49:42 <Pythonfant> it's just the element
12:49:45 <mcsmash> w00t
12:49:47 <mcsmash> that did it
12:49:51 * hackagebot yesod-fb 0.3.3 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.3.3 (FelipeLessa)
12:49:53 * hackagebot snap 0.13.2.8 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.8 (DougBeardsley)
12:49:55 * hackagebot yesod-auth-fb 1.6.3 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.3 (FelipeLessa)
12:50:54 <benzrf> hiptobecubic_: Identity is isomorphic to a 1-tuple
12:50:55 <benzrf> ;)
12:52:52 <k00mi> mcsmash: in general, concrete types (or type constructors) are capitalized and anything that isn't is a type variable
12:53:09 <k00mi> by syntax rule, not by convention
12:54:19 <systemfault> Emacs users, is there a way to evaluate haskell code in the current buffer. I’m still learning and it would help a lot :)
12:54:39 <systemfault> I have haskell-mode/ghc-mode installed
12:54:51 * hackagebot diagrams-qrcode 1.1.2 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.1.2 (FelipeLessa)
12:54:53 * hackagebot handle-like 0.1.0.1 - HandleLike class  http://hackage.haskell.org/package/handle-like-0.1.0.1 (YoshikuniJujo)
12:54:55 * hackagebot crypto-conduit 0.5.4 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.4 (FelipeLessa)
12:59:51 * hackagebot fb-persistent 0.3.3 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.3.3 (FelipeLessa)
13:00:29 <merijn> k00mi: The more I do haskell, the more I believe this rule to be genius
13:00:43 <merijn> Although TypeFamilies also having capital letters can be a bit confusing
13:11:44 * shapr boings happily
13:11:47 <n-dolio> The rules being different between the type and value level is unfortunate.
13:11:52 <shapr> Yay Haskell!
13:12:33 <shapr> n-dolio: but how would Oleg write any research papers otherwise?
13:12:39 <radix> shapr: oh, you're still around these parts! :)
13:12:47 <gilligan_> evening
13:12:50 <shapr> radix: whoa, long time no see! When did you get into Haskell?
13:13:19 <radix> shapr: I've gotten a bit more interested quite recently. finally actually understanding some of it :)
13:13:20 <shapr> radix: Yup, still vaguely active on #haskell
13:13:23 <n-dolio> I think he'd be okay if the rules for how names work were more consistent.
13:13:46 <radix> shapr: getting sick of the status-quo of stateful OO crap :)
13:13:50 <shapr> radix: hurrah! I think you'll enjoy learning Haskell. Whether or not you use it for lots of code, it stretches your brain in beneficial directions!
13:14:02 <shapr> Yeah, I don't use OO these days unless I must.
13:14:11 <isomorpheous> Why is it that #haskell is alive and well during the day time, but #archlinux is only active during the middle of the night?
13:14:31 <shapr> Haskell still has state-hiding abstractions, but they work differently from OO. And in my experience, the Haskell state-hiding abstractions are better.
13:14:39 <radix> shapr: definitely agreed
13:14:49 <shapr> radix: written any fun code in Haskell? Looking for any particular libraries?
13:14:52 <radix> shapr: to keep my sanity, I am doing more pure FP in python in my day job
13:15:00 <[swift]> isomorpheous: the timezones of channel regulars might be a factor
13:15:01 <benzrf> isomorpheous: because everyone in #archlinux is at school during  the day
13:15:02 <radix> shapr: I actually wrote a library called "effect" for isolating IO/state manipulation in python
13:15:04 <benzrf> ( ͡° ͜ʖ ͡°)
13:15:15 <moghedrin> benzrf: Lololol
13:15:28 <shapr> radix: That's how I got started with Haskell, I was writing pure FP-style Python without knowing what it was called, and Darius Bacon asked me why I was trying to write Haskell in Python ...
13:15:35 <radix> nice :)
13:15:37 <isomorpheous> benzrf: s/at school/employed
13:15:45 <benzrf> i found out haskell from a comment on a spiked math comic
13:15:54 <shapr> radix: mind you, that was some thirteen years ago
13:15:56 <benzrf> but then i didnt follow up on it
13:15:58 <radix> there are much better libraries in python for doing pure FP these days, especially some nice persistent data structures and stuff like that
13:15:59 <benzrf> until much later
13:16:22 <radix> but yeah, would rather be doing actual haskell :)
13:16:22 <isomorpheous> [swift]: Well, assuming the channels stick to their origins - #haskell is from Scotland, and #archlinux is from Canada
13:16:55 <shapr> radix: I like to say that Haskell has compile-time dynamic typing. In my opinion I get all the benefits of Python with all the benefits of C/Java/C++, and stuff I can't get in any of those flavors!
13:16:57 <isomorpheous> [swift]: I'm in the United States, so you would think that my schedule would be closer to the Canadians
13:17:11 <n-dolio> shapr isn't from Scotland.
13:17:20 <shapr> n-dolio: Why do you think that?
13:17:27 <n-dolio> isomorpheous just said so.
13:17:31 <shapr> oh, ok then.
13:17:44 <n-dolio> Or do you mean, why do I think you're not from Scotland.
13:17:51 <shapr> Sure, that's good too :-)
13:17:53 <[swift]> isomorpheous: could be. it also depends on the person. i know some europeans who like to stay up very late and are on IRC on more-or-less US time
13:18:13 <shapr> radix: Weren't you in Boston for awhile?
13:18:15 <isomorpheous> [swift]: I could understand that
13:18:21 <radix> shapr: yeah, but I've been in dallas for a while now
13:18:36 <radix> (with a brief stint in Providence as well)
13:18:48 <shapr> Ah, vaguely closer to where I live these days, Alabama
13:18:55 <radix> oh, I was just about to ask
13:19:12 <shapr> radix: Too bad, if you were still in Boston I would suggest buying lunch for edwardk and asking him about Haskell.
13:19:28 <radix> shapr: I think I met him once with you in boston
13:19:33 <n-dolio> Providence isn't that far from Boston.
13:19:39 <shapr> radix: I vaguely recall that
13:19:45 <radix> shapr: and I remember being super embarassed at my ignorance :)
13:19:53 * hackagebot codex 0.1.0.0 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.0 (aloiscochard)
13:19:53 <radix> (or maybe the embarrassment only happened now that I look back)
13:19:54 <shapr> eh, we all start at the beginning
13:20:10 <n-dolio> Close enough to go to Boston Haskell, probably.
13:20:32 <shapr> I'm goin to Hac Boston in October, yay!
13:20:37 <radix> n-dolio: yeah, I'm in dallas now. I wonder if there's something here
13:20:46 <radix> probably, there's a lot of people here.
13:20:56 <shapr> radix: I've heard of some Dallas Haskellers, but I don't know if there's an FP group. You could start one!
13:21:10 <radix> oh, and it's hard to google because there's a big street in the city called Haskell Ave
13:21:17 <shapr> hah
13:21:20 <n-dolio> I feel like there's a group somewhere in Texas. But Texas is so large that that might not matter.
13:21:28 <radix> yeah :)
13:21:31 <chrisdone> ion: can you add Control.Monad.Logic to lambdabot?
13:21:55 <chrisdone> LogicT is sweet
13:22:12 <shapr> radix: google finds scala and clojure meetups in Dallas
13:22:25 <radix> yeah, I've been meaning to go to the clojure one for a while, never got around to it yet.
13:23:13 <n-dolio> Also, I thought Hac Boston was in August.
13:23:29 <n-dolio> Did we change it?
13:23:33 <benzrf> chrisdone: since when is ion in charge
13:23:36 <benzrf> i thought it was int-e
13:23:40 <benzrf> are they the same person
13:23:41 <chrisdone> oh, int-e
13:23:46 <chrisdone> one of the i* people
13:24:13 <matematikaadit> @let import Control.Monad.Logic
13:24:16 <lambdabot>  Defined.
13:24:16 <shapr> @tell edwardk Is there a page for Hac Boston so I can make sure I don't get a plane flight a month before or after the actual date? :-P
13:24:16 <lambdabot> Consider it noted.
13:24:23 <chrisdone> matematikaadit: yatta!
13:24:30 <benzrf> shapr: hac boston is aug 1-3
13:24:35 <n-dolio> shapr: https://www.haskell.org/haskellwiki/Hac_Boston
13:24:39 <n-dolio> That looks up to date.
13:24:41 <benzrf> shapr: theres a Meetup page
13:24:45 <benzrf> http://www.meetup.com/Boston-Haskell/events/184294502/
13:24:46 <shapr> n-dolio: too easy, I could have just used Google >:-(
13:24:49 <matematikaadit> :t LogicT
13:24:50 <lambdabot> (forall r. (a -> m r -> m r) -> m r -> m r) -> LogicT m a
13:24:53 * hackagebot peyotls 0.0.0.13 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.13 (YoshikuniJujo)
13:24:54 <chrisdone> > observeAll (mplus (ifte (lnot mzero) (\x -> return 2) (return 2)) (return 7))
13:24:55 <lambdabot>  [2,7]
13:24:56 <shapr> golly, I REALLY could have used Google!
13:24:57 <chrisdone> \o/
13:25:32 <chrisdone> > observeAll (once (mplus (ifte mzero (\x -> return 1) (return 3)) (return 7)))
13:25:33 <lambdabot>  Ambiguous occurrence ‘once’
13:25:33 <lambdabot>  It could refer to either ‘Control.Monad.Logic.Class.once’,
13:25:33 <lambdabot>                           imported from ‘Control.Monad.Logic’ at L.hs:50:1-26
13:25:33 <lambdabot>                           (and originally defined in ‘logict-0.6.0.2:Control....
13:25:33 <lambdabot>                        or ‘Test.QuickCheck.Property.once’,
13:25:33 <kazagistar> hmm, interesting... is "once" the same as a prolog cut?
13:25:53 * benzrf should learn prolog
13:25:57 <n-dolio> kazagistar: Depends how you expect it to work.
13:26:03 <n-dolio> It's not a side effect like cut is.
13:26:14 <shapr> benzrf: I do like Prolog, though DataLog has the good stuff without the pain
13:26:22 <companion_cube> datalog isn't turing complete
13:26:39 <n-dolio> (Assuming my vague impression of what cut is is correct.)
13:26:57 <n-dolio> But it is used for similar things.
13:27:08 <shapr> Wow, lots of fun people going to Hac Boston!
13:27:11 * shapr is excited!
13:27:14 <thoughtpolice> mmmmm, Hac Boston
13:27:18 <shapr> chrisdone: Coming to Hac Boston?
13:27:42 <kazagistar> when I learned a bit of prolog, all I could think was that it would be useful as a DSL or library for specific kinds of work
13:27:46 <chrisdone> shapr: bawwston?
13:27:59 <chrisdone> when is that?
13:28:12 <shapr> chrisdone: Yeah, the home of MIT and Harvard and Tufts and MITRE and awesome things like tha!
13:28:15 <chrisdone> oh, august, too soon
13:28:20 <shapr> chrisdone: https://www.haskell.org/haskellwiki/Hac_Boston
13:28:21 <shapr> aww
13:28:34 <chrisdone> mgsloan is arriving at my place tomorrow
13:28:46 <chrisdone> we'll have the smallest and only haskell hackathon in italy ever
13:28:53 <shapr> I'll ask CosmicRa` if he's showing up, would be nice to get my Real World Haskell book signed by another author.
13:29:27 <chrisdone> kazagistar: yeah, i'm looking into logic libraries so i can implement a datalog engine
13:29:39 <benzrf> im totally comin to hac boston
13:29:44 <benzrf> i have nothing in particular to work on tho
13:29:47 <shapr> I wonder if dons will be there too?
13:29:55 <shapr> benzrf: You have time to find something to work on!
13:29:58 <chrisdone> maybe if there are sunsets to take pics of
13:30:47 <chrisdone> kazagistar: i have this big idea to make an interactive book generated from a datalog database
13:31:10 <chrisdone> no one thinks it's an awesome idea but me. but i'll show them! i'll show them all!
13:31:19 * chrisdone twiddles moustache ψ(｀∇´)ψ
13:31:32 <shapr> chrisdone: I believe you will show us all :-)
13:31:32 <kazagistar> hmm, a interactive book of what nature?
13:31:36 <Lutin`> chrisdone: Any reason you didn't add /step/:id to lpaste?
13:32:11 <chrisdone> lutin`: meaning what, there?
13:32:18 <chrisdone> shapr <3
13:32:38 <Lutin`> With hpaste you had the ability to step through the evaluation of certain functions
13:33:03 <Lutin`> Was  going to use that to explain to someone how something worked earlier but noticed it wasn't on lpaste
13:33:10 <chrisdone> kazagistar: the idea is that you write facts and rules out, and then the system generates descriptions of a topic and also generates exercise questions randomly (using the facts and rules in the db) that it can confirm simply by querying the user's answer
13:33:22 <bernalex> hello, lambdabot
13:33:26 <bernalex> shapr: works!
13:33:41 <shapr> w00t!
13:34:02 <kazagistar> chrisdone: the hard part of anything like that is not making the writing horrible for a human to read
13:34:05 <taktoa> hello, lambdabot
13:34:11 <kazagistar> well, a hard part at least
13:34:12 <chrisdone> kazagistar: enter attempto controlled english!
13:34:14 <chrisdone> http://hackage.haskell.org/package/ace
13:34:37 <chrisdone> (blog post about that here http://chrisdone.com/posts/attempto-controlled-english)
13:34:57 <kazagistar> is the blog post written using ACE? :P
13:34:58 <chrisdone> the idea would be you write the facts and rules and also display the facts in plain english, and accept answers in such a format
13:35:02 <chrisdone> not yet =p
13:35:16 <luite> chrisdone: is the description of the package ACE?
13:35:20 <benzrf> hmmm
13:35:34 <chrisdone> luite: it could be with some modifications
13:35:45 <benzrf> is there any way to be reasonably sure that a particular syntactic node that calls unsafePerformIO to get an IORef will return a new IORef each time that code is evaluated?
13:35:50 <chrisdone> there are ACE wikis out there
13:36:57 <kazagistar> Good luck
13:37:30 <chrisdone> kazagistar: e.g. if i'm teaching about simple politics to children, maybe i have facts like "Barack Obama lives in Washington D.C." and "James Cameron lives in London." those are two fine facts, and the system can now ask the student "Barack Obama lives where?"
13:37:44 <chrisdone> kazagistar: which is okay. but you can go one step more interesting:
13:38:01 <luite> also i want that datalog engine too :)
13:39:43 <chrisdone> Fact: Barack Obama is the head of state of The United States of America.
13:39:43 <chrisdone> Fact: The capital city of The United States of America is Washington D.C."
13:39:44 <chrisdone> Rule: The head of state of a country lives in the capitol city of that country. (this is a bit more informal than you'd write, i can show you the formal version if interested)
13:39:55 <chrisdone> *now* the system can ask "Barack Obama lives where?"
13:39:55 * hackagebot HaRe 0.7.2.4 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.4 (AlanZimmerman)
13:40:28 <chrisdone> and the system has only told the student, in the past, that Barack Obama is the president, and that heads of state live in the capital city, and they know the capital of the US
13:40:42 <chrisdone> so the system has made an inference (because it's been taught some rules), and the student has to make such an inference
13:40:53 <benbangert> whats the easiest way to write a tcp client for a binary protocol?
13:41:15 <Simone21>  Here some videos. I hope you like them! http://j.mp/1lXz4Nx
13:41:16 <chrisdone> because the student is smart. if the student answers correctly, or gives up, the system can explain the derivation steps
13:41:39 <benbangert> I mean which library in haskell makes it easiest, given that I have datatypes to serialize/deserialize as they go over the tcp connection
13:41:55 <chrisdone> but the student sitting next to them might see a differently generated question, like "Who lives in Washington D.C.?"
13:42:06 <chrisdone> luite: for Wolfgang? =)
13:42:31 --- mode: ChanServ set +o Cale
13:42:35 --- mode: Cale set +b *!*@95.141.20.196
13:42:35 --- kick: Simone21 was kicked by Cale (Simone21)
13:42:45 --- mode: Cale set -o Cale
13:42:55 <zomg> Lot of spam lately
13:43:03 <merijn> zomg: It comes in waves
13:43:11 <chrisdone> yeah, lpaste has been receiving lots of spam
13:43:19 <chrisdone> must be their time of year, like the mosquitos
13:44:55 * hackagebot llvm-general-pure 3.3.13.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.13.0 (BenjaminScarlet)
13:44:57 * hackagebot llvm-general-pure 3.4.4.0 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.4.0 (BenjaminScarlet)
13:44:59 * hackagebot llvm-general 3.3.13.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.13.0 (BenjaminScarlet)
13:45:02 * hackagebot llvm-general 3.4.4.0 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.4.0 (BenjaminScarlet)
13:48:05 <luite> chrisdone: well that would be fun too, but more to see whether a datalog fact base can be used instead of some frp insternal state, and see how it scales to distributed apps (where most of the queries in each app will only use local facts)
13:48:36 <chrisdone> ah
13:48:57 <chrisdone> another thing you can do is embed sublanguages into a datalog
13:49:08 <chrisdone> so you could make it understand haskell syntax and types
13:50:17 <chrisdone> e.g. the fact "sum x y = x + y is a program to compute x + y". x and y are datalog variables in the arg position and english text, and they all must unifiy
13:50:27 <chrisdone> then you can ask the user "what is a program to compute x + y?"
13:51:10 <chrisdone> alternatively, you can make the implementation opaque but use the "sum x y = x + y" as a quickcheck predicate
13:51:59 <chrisdone> so they write (\a b -> a+a+b-a) for "sum" and it still checks out
13:54:39 <chrisdone> also, if you wrote, say, a thousand facts about haskell, you could generate a graph from that, and the node with the most edges can be considered the first topic to cover, and groups of related topics can be generated as chapters
13:55:28 <athan> So here's something weird... has anyone made a network-capable ghci session? S.T. multiple people can affect a running environment at the same time? :o
13:55:33 <chrisdone> benbangert: use cereal or binary and network.socket
13:55:59 <chrisdone> athan: like lambdabot?
13:56:17 <benbangert> chrisdone: I saw network.socket, just didn't see how to link binary with it to parse my packets
13:56:54 <chrisdone> benbangert: here https://hackage.haskell.org/package/network-2.5.0.0/docs/Network-Socket-ByteString.html
13:57:12 <chrisdone> benbangert: that gives you bytestring-based socket actions, now you can use cereal or binary to generate/parse data
13:57:31 <Nik05> :info Monad
13:57:36 <alanz> luite: See http://boom.cs.berkeley.edu/ and references to dedalus, a distributed datalog
13:57:37 <athan> chrisdone: :O!
13:57:45 <chrisdone> athan: =o
13:57:48 <Nik05> fails the bot, is Monad already a functor?
13:58:03 <chrisdone> benbangert: conduit and pipes are also possible ways to work with sockets
13:58:19 <luite> athan: yeah that was the inspiration
13:58:32 <geekosaur> there is no :info in lambdabot
13:58:41 <luite> but i want haskell too :)
13:58:46 <geekosaur> Monad is not yet guaranteed to be Functor
13:58:57 <MP2E> it will be with GHC 7.10 <3
13:58:58 <geekosaur> but all valid Monad-s should be Functor-s
13:59:22 <geekosaur> (and if you find one that is not, report it as a bug because it *will* be a bug come 7.10)
13:59:36 <MP2E> Still makes me warm and fuzzy whenever I see 'Blah is an instance of Monad but not Applicative, this will become an error in GHC 7.10'
13:59:37 <Nik05> ah ok
13:59:42 <MP2E> hehe
13:59:42 <benbangert> chrisdone: ah, yea. I saw those, but was having trouble seeing how to combine them, since these packets have a header that indicates what type and the length of the body, so I don't know how long each message is going to be until I'm decoding it
14:00:10 <matematikaadit> @src Monad
14:00:10 <lambdabot> class  Monad m  where
14:00:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:00:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:00:10 <lambdabot>     return      :: a -> m a
14:00:10 <lambdabot>     fail        :: String -> m a
14:00:19 <matematikaadit> Nik05: ^
14:00:19 <benzrf> ew, fail
14:00:26 <athan> Is there a form of revision control that could be used in ghci? Something so we can `undo` and `redo`, change the data types in the environment, etc?
14:00:28 <benzrf> > fail "me"
14:00:29 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
14:00:30 <lambdabot>    arising from a use of ‘M872399779008392059227973.show_M8723997790083920592...
14:00:30 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
14:00:30 <lambdabot>  Note: there are several potential instances:
14:00:30 <lambdabot>    instance [safe] GHC.Show.Show a =>
14:00:49 <chrisdone> benbangert: that's okay, binary is a monad, so you can parse some of it and then use the result when you continue parsing
14:00:51 <MP2E> > fail "benzrf" :: String
14:00:53 <lambdabot>  ""
14:01:31 <chrisdone> @import Data.Binary.Get
14:01:31 <lambdabot> Unknown command, try @list
14:01:35 <chrisdone> @let import Data.Binary.Get
14:01:36 <lambdabot>  .L.hs:58:1:
14:01:37 <lambdabot>      Data.Binary.Get: Can't be safely imported!
14:01:37 <lambdabot>      The package (binary-0.7.1.0) the module resides in isn't trusted.
14:01:43 <chrisdone> D:
14:01:47 <Nik05> and when is ghc 7.10 coming out?
14:02:04 <chrisdone> athan: this supports many connections at once https://github.com/chrisdone/ghc-server
14:02:12 <MP2E> dunno, GHC 7.8.3 is scheduled soon and 7.8.4 should come out 'some time after summer' so I'm not sure if it's even planned that far out yet
14:02:31 <geekosaur> fiik. 7.8.1 took 6 months too long, 7.8.3 is a couple weeks overdue...
14:02:33 <Lutin`> omg finally applicative superclass of monad
14:02:34 <athan> luite: I think I just struck gold... but It's probably already mined and drenched in cyanide xD
14:02:58 <benzrf> Lutin`: \o/
14:03:16 <chrisdone> anyone else notice how funny it is that haddock doesn't support syntax highlighting of haskell?
14:03:23 <benbangert> chrisdone: oh, I think I need the runGetState, was mainly trying to see how to get the deserialized back *and* move forward in the bytestring
14:03:42 <extraplanetary> I sort of worry that 7.10 is too soon to be erroring out with AMP, considering that Debian and Ubuntu are both still on 7.6
14:03:58 <chrisdone> benbangert: use runGet?
14:04:08 <luite> alanz: whoops meant to reply to you
14:04:18 <Nik05> so what is going to happen with *> and >> ? will they remove >>?
14:04:29 <benbangert> chrisdone: well, if I need to read more data and add it to the existing bytes before I can rerun it...
14:04:37 <athan> chrisdone: My excitement is almost manifesting physically in space o.O (thank you)
14:04:55 <chrisdone> runGetOrFail (do i <- getWord8; bs <- forM_ [1..i] (getByteString 4); return bs)
14:05:13 <chrisdone> ^ this reads i strings of length 4, where i is specified in the input stream
14:05:38 <chrisdone> benbangert: you mean not all the bytestring is available at the time of parsing?
14:06:17 <MP2E> Nik05 : not sure, they >> will probably be set to be equivalent to *> in the interest of not breaking things
14:06:22 <benbangert> chrisdone: reading off a tcp socket, correct, if a message crosses the network buffer, part of it will be in the next read
14:06:23 <chrisdone> athan: lol. it's still experimental and i'm working on it, no official release yet. but simple REPL evaluation and loading files works, i can run it on my remote host and connect into it with emacs
14:06:29 <MP2E> Nik05 : Monad will have 'return = pure' for instance
14:06:35 <alanz> luite:?
14:06:55 <MP2E> Nik05 : also it's not perfectly clean yet, because Monad still needs return defined and it isn't defined in terms of 'join' which would be more correct, from a Category Theory perspective :)
14:06:56 <luite> chrisdone: oh you can tell mgsloan that yesterday i finally finished/pushed the stuff i was working on at budhac \o/
14:07:03 <chrisdone> benbangert: ah, i see. runGetState makes sense then. but there's also attoparsec
14:07:11 <chrisdone> luite: i'll tell him when he arrives =)
14:07:17 <Nik05> so then the only thing new in Monad is (=<<) ?
14:07:19 <phaazon> what do you think guys of representing an AST through a typeclass?
14:07:22 <Nik05> (and the fail)
14:07:27 <phaazon> instead of a type (data), I use a class
14:07:36 <MP2E> Nik05 : actually the only new thing in Monad is join and fail, but right now it's >>= and fail, yes
14:07:40 <luite> chrisdone: although he might've already seen it on ghc-devs
14:07:41 <phaazon> and each interpreters is an implementation of the typeclass
14:07:44 <chrisdone> benbangert: it supports incremental parsing out of the box http://hackage.haskell.org/package/attoparsec-0.12.1.0/docs/Data-Attoparsec-ByteString.html
14:07:52 <Nik05> MP2E what is join?
14:08:00 <MP2E> Nik05 : because 'm >>= f = join $ fmap f m'
14:08:13 <MP2E> Nik05 : join :: m (m a) -> m a
14:08:23 <MP2E> it collapses 2 layers into one
14:08:24 <Nik05> ah ok
14:08:34 <geekosaur> Nik05: think lists. fmap is map; join is concat
14:08:38 <MP2E> exactly
14:09:03 <chrisdone> benbangert: see the IResult stuff. you start with parse and then run feed repeatedly until you get either Done or Fail
14:09:40 <Lutin`> ugh
14:09:47 <Lutin`> I hate fail
14:09:52 <MP2E> yeah fail sucks :V
14:09:55 <benbangert> chrisdone: ah neat, the parseWith would even let me supply it the reading func...
14:10:02 <luite> alanz: oh i used the wrong name when i said that boom/dedalus/bloom was the reason i wanted this in haskell, edwardk mentioned it a few weeks ago
14:10:07 <MP2E> i can't wait for the day when Monad is just join :) though it's a long time coming, if it ever happens heh
14:10:12 <chrisdone> benbangert: yeah that's nice
14:11:05 <chrisdone> benbangert: probably hGetSome
14:11:08 <Nik05> i hate >>= too, really annoying that its inconsistent
14:11:13 <athan> chrisdone: I'll see what I can do to help, but I have a feeling that this could be really cool. I have a weird idea for a data type that does a good representation of heirarchical user groups... I have a feeling I'll be able to make a forum with this...
14:11:16 <athan> *passes out*
14:11:26 <chrisdone> or w/e the equivalent is in network-bytestring
14:11:39 <chrisdone> athan: lol
14:11:42 <alanz> luite: that was the reason I started looking too, got as far as https://github.com/alanz/hdedalus
14:11:45 <benbangert> chrisdone: sweet, this looks like it should work nicely, thanks!
14:11:59 <chrisdone> benbangert: welcome! learned something myself in the process =)
14:12:20 <phaazon> MP2E: Nik05 what are you talking about?
14:12:23 <Nik05> but ok i guess that >>= came from do notation
14:12:38 <MP2E> Nik05 : actually do notation came from >>=
14:12:46 <MP2E> and Monad just being defined by join wouldn't do away with bind
14:12:52 <MP2E> bind is the bread and butter of monads
14:12:58 <Nik05> phaazon that the class contains >>= as member and =<< is a function that flips the arguments of >>=
14:12:58 <MP2E> bind would just be defined in terms of join instead of vice versa
14:13:04 <chrisdone> athan: i don't have an opinion about the hare stuff, btw. i like that hare can be used as a library so i might use it from ghc-server eventually
14:13:09 <benzrf> MP2E: well yesr
14:13:10 <phaazon> Nik05: so?
14:13:15 <benzrf> but the class should be defined by join
14:13:23 <phaazon> why?
14:13:24 <Nik05> phaazon its inconsistent with Functors and Applicatives
14:13:41 <phaazon> Nik05: oh
14:13:48 <MP2E> benzrf : that's what I was saying :)
14:13:56 <MP2E> literally that's been my entire point
14:13:57 <phaazon> you mean fmap f x, A f <*> A x, but x >>= f
14:13:57 <phaazon> ok
14:14:00 <MP2E> I must be saying it wrong
14:14:01 <MP2E> heh
14:14:01 <alanz> chrisdone: glad to hear it, I want to offload the elisp side
14:14:04 <phaazon> is this really a problem? :D
14:14:06 <Nik05> yes phaazon
14:14:11 <phaazon> it’s a minor detail…
14:14:14 <Nik05> its inconsistent... :P
14:14:17 <phaazon> yeah, well
14:14:25 <phaazon> just as well head, tail and others are wrong
14:14:30 <Lutin`> MP2E: I think you mean, consists by join and bind where join is the minimal complete definition
14:14:34 <Lutin`> consists of*
14:14:36 <chrisdone> alanz: a guy made some simple refactoring operations with the stuff from hlint mixed with structured-haskell-mode, let me find the videos he made…
14:14:40 <Nik05> why arent those fixed?
14:14:52 <phaazon> Nik05: legacy sh*t, I guess
14:14:59 <Nik05> probably breakage of old code :P
14:15:00 <MP2E> Lutin` : yeah exactly :P
14:15:06 <Lutin`> We just need a nonempty list type
14:15:06 <phaazon> Nik05: yeah it’s stupid
14:15:12 <phaazon> it’s a poor argument
14:15:13 <chrisdone> alanz: e.g. here http://chrisdone.com/shm-refac.ogv
14:15:30 <Lutin`> phaazon: "doomed to succeed"
14:15:35 <chrisdone> alanz: so i think shm is a good "UI" for initating refactorings, at least as a starting point
14:15:40 <phaazon> we have a small community, we CAN absorb changes
14:15:44 <Nik05> but they also dont add a fixed head, tails, etc
14:16:09 <phaazon> Nik05: it’s because sometimes it’s more convenient using [a] -> a instead of [a] -> Maybe a, I guess
14:16:10 <luite> alanz: oh fun :) unfortunately i first have to get GHCJS released before i really have time to play with things like that
14:16:10 <Lutin`> and bind = join . fmap
14:16:17 <chrisdone> also here, but it's not that different to the other video http://chrisdone.com/refactor_test.ogv
14:16:18 <alanz> chrisdone: Thanks, will have a look. FYI I broke out haskell-token-utils to be a tool for hlint to manage changes, and preserve layout
14:17:27 <Lutin`> I guess I should try emacs
14:17:35 <MP2E> Lutin` : don't fmap's arguments need to be flipped
14:17:36 <Lutin`> I'm going to miss my vim commands though :[
14:17:37 <MP2E> ?
14:17:42 <MP2E> Lutin`: evil modeee :D
14:17:48 <alanz> chrisdone: I am also currently coaxing Martijn Schrage to resurrect proxima, with a view to using it with HaRe
14:17:48 <Lutin`> MP2E: oh, yeah
14:17:49 <MP2E> join the dark side, you can have your vim cake and eat it too
14:18:06 <chrisdone> alanz: yeah layout-preserving changes are hard
14:18:08 <Lutin`> I heard evil mode can be buggy
14:18:08 * MP2E uses emacs exclusively in evil mode and has no plans on changing to emacs' hand-breaking keybinds
14:18:17 <chrisdone> alanz: proxima?
14:18:34 <MP2E> I haven't seen any bugs but that doesn't mean they don't exist
14:18:38 <MP2E> hmm
14:18:45 <chrisdone> mgsloan wrote some refactorings for the fpco IDE and had to do some layout-preserving stuff, it's tricky
14:18:55 <alanz> chrisdone: http://www.cs.uu.nl/wiki/Proxima/WebHome
14:19:37 <alanz> I found http://www.cs.uu.nl/wiki/pub/Proxima/BuildingAnEditor/Thesis_Gerbo_Engles.pdf which refers to extending to HaRe
14:20:15 <chrisdone> alanz: ah, i like such WYSIWYM editors
14:21:06 <alanz> yes, but it offers different views of the doc, either as linear text or a tree, and structural editing. As far as I can tell :)
14:21:49 <chrisdone> nod
14:22:29 <alanz> Here is a description of what happens in haskell-token-utils https://github.com/alanz/HaRe/blob/master/docs/token-management.md
14:22:49 <alanz> And token management is very hard.
14:24:03 <chrisdone> alanz: there is also of course the social solution: make people like pretty printers
14:24:22 <alanz> that is the route to a tool that is never used
14:25:05 <chrisdone> alanz: unlike HaRe? =p
14:25:44 <alanz> yes, HaRe preserves layout
14:26:05 <chrisdone> i mean, people use HaRe?
14:26:13 <alanz> and is still in very early revival mode for GHC, so not much in it
14:26:57 <alanz> chrisdone:155 downloads in last 30 days.
14:26:59 <chrisdone> nod, so it would be a straw man to criticize HaRe for its usedness because it's not completed
14:27:15 <alanz> But the renaming is pretty solid.
14:27:59 <chrisdone> the fact is no one has written a sensible pretty printer tool for haskell yet
14:28:19 <alanz> And the editor integration is key, hence my mail earlier trying to get either you or Kazu to pick it up
14:28:24 <chrisdone> i won't dismiss it out of hand, especially when the benefits would be enormous
14:28:44 <alanz> I dont think a pretty printer would work, unless it is AI based somehow
14:30:36 <chrisdone> your lack of vision is duly noted
14:30:56 <alanz> :) It is about tools in the near future
14:31:23 <Peaker> I wonder why http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/18980 loads so slowly, even the google web cache version of it...
14:31:25 <chrisdone> how old is the HaRe project?
14:31:34 <chrisdone> some years now, right?
14:31:45 <alanz> But there are two different problems, one being pretty printer OR layout preservation, the other is refactoring the underlying AST
14:31:57 <chrisdone> again, you apply constraints to one solution but not to your own project =)
14:32:19 <chrisdone> alanz: sure
14:32:27 <alanz> chrisdone: The original goes back quite a way, I think to 2001 or so. I have only been on it for the last year or so
14:33:15 <chrisdone> peaker: will you use HaRe in lamdu? ;)
14:34:47 <chrisdone> Peaker: it doesn't load for me either
14:35:22 <chrisdone> Peaker: it seems like the head assets are not loading. so the page will wait around before rendering until they're loaded, which they seem to be not doing
14:35:41 <chrisdone> http://gmane.org/img/leftmenu.css ← for example
14:35:42 <Peaker> chrisdone: We want to implement refactorings directly on our saved structure format, which isn't precisely Haskell's AST. But we do intend on having nice structural modifications on code
14:36:18 <Peaker> chrisdone: couldn't browsers have some sane timeouts and start presenting the content without proper layout?
14:36:39 <chrisdone> peaker: sometimes i think there should be a yearly "haskell editor conference" where everyone gets together and shares their experiences, implementations and ideas
14:37:12 <chrisdone> Peaker: possibly. a hack is you can tap Esc and it cancels the assets and renders
14:37:39 <chrisdone> oh, huh
14:37:48 <chrisdone> that's *exactly* the page i was looking for the other day
14:37:57 <chrisdone> and i couldn't find it. so thanks for that
14:38:02 <Peaker> chrisdone: I just wasted hours debugging WriterT leakages
14:38:07 <chrisdone> =)
14:38:18 <alanz> chrisdone: I definitely think there is a place for some kind of underlying engine to do all the fancy stuff, your haskell-server or whatever it turns out to be
14:38:28 <Peaker> And I finally realized it's an inherent problem in the way the mappends are associated by WriterT
14:38:33 <alanz> but as a community project, not splinters everywhere
14:38:37 <chrisdone> johnw: that's the link i was trying to find that time about StateT being more efficient than writer http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/18980
14:38:57 <johnw> ah, nice, thanks
14:39:10 <Peaker> WriterT : StateT  is like:  foldr : foldl    in terms of memory use, in a (strict monad : strict operation)
14:39:14 <chrisdone> alanz: as long as the things are in library form i think people can build their own environments like they do with xmonad
14:39:21 <l0cust> Hey, so, question
14:39:27 <l0cust> I created a "capstone module"
14:39:41 <l0cust> If you've ever used Yesod, it's equivalent to Yesod's Import
14:39:43 <Peaker> WriterT as it stands, on top of strict monads, is basically always wrong/worse than StateT with strict state mappends
14:39:53 <chrisdone> alanz: e.g. my http://hackage.haskell.org/package/haskell-docs tool is librified so i'll be able to import it into ghc-server later, and also hare, and hlint, etc
14:40:00 <l0cust> I'm wondering how to get the haddock documentation to appear in the documentation for the capstone module
14:40:13 <l0cust> https://github.com/pharpend/eros
14:40:15 <l0cust> That's the repo
14:40:23 <l0cust> the capstone module is src/Text/Eros
14:40:41 <l0cust> It serves only as a proxy for other modules
14:40:59 <l0cust> I would like the documentation for functions in the sub modules to appear in the documentation for the capstone
14:41:36 <alanz> chrisdone: there is that, ghc-mod, buildwrapper, ...
14:41:55 <chrisdone> alanz: scion, hdevtools, shim, ghci
14:42:04 <alanz> but +1 on everything as a library.
14:42:05 <Peaker> chrisdone: Yearly conference could be nice, but expensive :)
14:42:13 <Peaker> chrisdone: (travel-wise, at least)
14:42:17 <chrisdone> peaker: we can all come to israel =p
14:42:20 <Peaker> chrisdone: haha
14:42:28 <alanz> Cape Town is nice
14:42:31 <chrisdone> i could stop by snoyberg's
14:42:36 <Peaker> chrisdone: we're going to the "Future Programming Workshop" in October
14:43:00 <chrisdone> peaker: nice
14:43:14 <Peaker> chrisdone: we're in the process of replacing our flexible but super-slow type system/inference with an extended version of Algorithm W which is much faster, solving a long-standing problem we had (while also losing some flexibility, for now)
14:43:14 <chrisdone> phil wadler'll be there
14:43:20 <Peaker> oh cool
14:43:40 <chrisdone> (i think: he's on the committee http://www.future-programming.org/call.html)
14:43:57 <chrisdone> peaker: neat, is it full system F?
14:44:11 <sclv> Peaker: what flexibility do you use?
14:44:14 <sclv> lose rather?
14:45:05 <chrisdone> alanz: there's also https://github.com/mvoidex/hsdev
14:45:26 <alanz> Peaker: I would love to see a feature in GHC that allows incremental type-checking, so that the source AST can be shared live with GHC and mutated
14:45:51 <alanz> chrisdone: I know, and a lot of wheels getting reinvented
14:45:53 <chrisdone> alanz: hehe, like the old InterLisp implementations in the 80s?
14:45:58 <Peaker> chrisdone, sclv: we had SystemF encoding (with explicit Pis) where we could infer Haskell-style types when Haskell would, but still allow for DT encodings/etc. But our algorithm sucked
14:46:33 <alanz> chrisdone:yep
14:46:52 <Peaker> chrisdone: the new algorithm is simply W + row polymorphism (+ polymorphic invariants in place of sums, probably, this isn't implemented yet)
14:48:04 <chrisdone> yay for row polymorphism
14:48:06 <Peaker> so the new one doesn't even have proper RankNTypes (GHC doesn't have proper RankNTypes either..)
14:48:42 <sclv> ah sure. yeah i could imagine full system f would be overkill for most uses unless you were generating v. serious proofs
14:49:13 <Peaker> sclv: we had a particularly slow algorithm, what we did is probably doable with reasonable performance if done better
14:49:44 <Peaker> we wanted it to allow backtracking -- so straightforward way is to do everything with persistent data structures, but I suspect this is a huge slowdown (may as well backtrack on mutable data)
14:51:08 <Peaker> having anonymous products and sums is really nice, in that you get on-the-spot precise types, without ceremoniously declaring them, but an unexpected difficulty is that suddenly higher-kinded types become problematic, since there's no longer a canonical type function for each sum/product
14:51:48 <Peaker> makes me wonder if having polymorphic variants (anonymous sums) is the reason ML dialects didn't go for higher-kinded types
15:00:59 <kini> as I understand it, if A is a newtype of B, then the newtype constructor A is a zero-cost-at-runtime inhabitant of B -> A. Is there a zero-cost-at-runtime inhabitant of A->B?
15:05:01 <popx> kini: coerce of Coercible. http://haddocks.fpcomplete.com/fp/7.7/20131212-1/ghc-prim/GHC-Prim.html#t:Coercible
15:05:11 <popx> if I understand correctly
15:05:23 <kini> yup, just found that, but it's giving me an odd error
15:05:58 <kini> "Could not coerce from ‘Int’ to ‘Nat’ because the constructor of ‘Nat’ is not imported" (here Nat is a newtype of Int)
15:06:09 <kini> I'm fairly sure that the Nat constructor has been imported to this module though
15:07:24 <kini> hmm. When I wrote "module Foo.Bar.Nat ( Nat )" in the module where I defined Nat, did that just export the type Nat and not the data constructor Nat?
15:07:32 <geekosaur> yes
15:07:38 <kini> how do I export both?
15:07:43 <geekosaur> export Nat(Nat) or Nat(..)
15:07:49 <kini> nice, thanks :)
15:07:49 <popx> Nat(..)?
15:07:51 <geekosaur> the latter form exports all constructors
15:08:03 <geekosaur> the former takes a list of constructors to export
15:08:32 <dwcook> The latter also exports all fields
15:26:04 <hseg> Hi. Does anyone know of a derivation of foldl as an instance of foldr?
15:26:30 <benzrf> hseg: huh?
15:26:52 <Nik05> its on the interwebs
15:27:03 <popx> this reddit thread (http://www.reddit.com/r/haskell/comments/29lc4f/learn_help_explaining_a_strange_use_of_foldr/) discusses and implementation of foldl using foldr
15:27:08 <popx> an*
15:27:43 <jmcarthur> hseg: it's not very complicated. basically you want the foldr to produce a function that takes the initial value for the accumulator and returns the final value of the accumulator
15:28:08 <jmcarthur> hseg: just follow the types from there, pretty much
15:28:59 <jmcarthur> hseg: foldl f init xs = foldr ? ? xs init
15:30:50 <quchen> jmcarthur: Even better: foldl f init xs = foldr _f _z xs init -- Typed holes!
15:32:40 <hseg> jmcarthur: I know how to implement it. What I'm looking for is *why* this is the correct implementation. Why can the catamorphism of a snoc-list be expressed as the catamorphism of a cons-list?
15:32:54 <tr55> Can you explain in a few sentences what monads are, why they are useful, one practical example, and what they can accomplish that C++ can't?
15:33:02 <lispy> kini: newtype wrappers can turn out to be more expensive than advirtized if they prevent a RULE from firing
15:33:20 <kini> hmm
15:33:39 <lispy> It's kind of a corner case. So don't worry about it.
15:33:53 <sipa> tr55: no
15:33:55 <moghedrin> tr55: Nope.
15:34:01 <lispy> It's more just something to be aware of if RULES are not firing.
15:34:05 <Lutin`> C++ can have monads
15:34:08 <kini> lispy: well, I'm not creating this newtype anyway :) just handling it
15:34:27 <lispy> Show me on the diagram where C++ can have natural transformations?
15:34:40 <moghedrin> tr55: In fact... http://bartoszmilewski.com/2011/07/11/monads-in-c/
15:34:44 <tr55> sipa, moghedrin, so monads are more like a concept i'll have to spend days/weeks/months learning, actually using myself to get a feel for them, and only then will i actually understand them?
15:34:48 <koala_man> I have a trivial program that just prints fib 32 for a trivial recursive fib. Why does it run in 1.5 seconds with +RTS -N1 but in 20 seconds with +RTS -N2? Why is there even a difference when I don't have any parallelism?
15:34:56 <sipa> tr55: forget monads
15:35:28 <lispy> C++ can have an abstraction that in Monad-like or Monad-inspired, but due to a gross lack of parametericity I think it's unfair to say C++ has monads.
15:35:29 <popx> tr55: monads are a mathematical construction, in haskell there are many different monads that have very different uses.
15:35:30 <sipa> tr55: they're not a goal you should aim for; just learn programming in haskell, and in particular how IO works
15:35:41 <sipa> tr55: at some point you'll get it
15:35:52 <moghedrin> tr55: What sipa said.
15:35:54 <Lutin`> lispy: Fair enough
15:36:05 <koala_man> oh, never mind. it was parallel gc. with -gq the difference all but disappears
15:36:13 <tr55> ok, so there really are no shortcuts. i really have to make an effort to learn this
15:36:15 <tr55> good to know
15:36:15 <tr55> thanks
15:36:36 <popx> Bartosz Milewski has many interesting posts on monads, functors etc in C++... http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/
15:37:07 <tr55> c++ is becoming pretty ugly imo
15:37:10 <tr55> haskell is plain beautiful
15:37:21 <mzero> gah - did folks know that cabal's dir layout changed radically from 1.16 to 1.18?
15:37:26 <systemfault> tr55: I think C++ is nicer than ever :/
15:38:07 <lispy> mzero: did it bite you somehow? I don't normally need to look in directories like dist
15:38:21 <mzero> not there - where it installs stuff
15:38:36 <mzero> well - you see, the platform on Mac comes with an uninstaller....
15:38:43 <mzero> now it can't find what 1.18 installs
15:38:52 <tr55> systemfault: yes actually c++11 was sweet
15:38:56 <tr55> tuples, lambdas,
15:38:58 <tr55> etc.
15:39:08 <mzero> and the platform itself tries to have a consistent install layout... and now it is inconsistent.... sigh
15:39:10 <lispy> mzero: destructive updates are hard :)
15:39:14 <moghedrin> popx: Aye. I think his blog posts and videos were what took me from vaguely understanding IO to actually "getting" what monads were.
15:40:14 <mzero> (just feeling beaten by spending a whole day writing the friggin shell script to find and enable installing or switching between GHC compilers.... and much of that work needs to be rethought now!)
15:40:24 <moghedrin> tr55: Lighter weight thread constructs.
15:40:29 <lispy> IMO, there are several separate (but related things): a) understanding Haskell abstractions like IO a, b) understanding Haskell's notion of Monad, c) understanding the categorial notion of monad.
15:40:30 <tr55> ok
15:40:32 <moghedrin> Biggest one for me.
15:40:37 <tr55> did't know about that one
15:40:40 <tr55> didn't
15:40:59 <lispy> I think it's perfectly reasonable to start at (a) and then move to (b) later. (c) is a good goal but not everyone will get there.
15:41:01 <tr55> moghedrin: but haskell makes threading/multicore more a breeze doesn't it
15:41:16 <kvanb> tr55: actually, monads are easy
15:41:20 <kvanb> what background do you come from?
15:41:23 <moghedrin> tr55: In my opinion, yes.
15:41:26 <tr55> moghedrin: cool
15:41:33 <kvanb> I was a C/C++ programmer and reverse engineer
15:41:54 <sipa> monads are just an abstraction, but it's likely not an abstraction for something you're familiar with
15:41:55 <tr55> kvanb: i come from basically the imperative world like everyone else basically. c, c++, php, whatever
15:41:58 <tr55> ok
15:42:10 <kvanb> okay, so basically, a good way to think of them is like this
15:42:18 <kvanb> and I pardon everyone else in the channel who is about to bite my head off
15:42:24 <Lutin`> tr55: Monads are just a unary type constructor, M, that defines for every underlying type, t, a corresponding monadic type M t. A unit function ,t -> M t, that maps a value to a value in the corresponding monadic type. We call it 'return'. And a binding operation of polymorphic type, (M t)->(t -> M u)->(M u), we use the infix function (>>=) to represent that. And these 3 must satisfy 3 properties: (return x)
15:42:27 <Lutin`> >>= f == f x, m >>= return == m, and (m >>= f) >>= g == m >>= (\x -> (f x >>= g))
15:42:46 <kvanb> You might want to add a particular behaviour to a program
15:43:00 <kvanb> like, an extra argument to every function so it can carry a state
15:43:14 <kvanb> But that's a pain in the ass.
15:43:16 <moghedrin> Lutin`: You're the worst sort of person ;P
15:43:20 <Lutin`> lol
15:43:27 <sipa> tr55: there are many instances of monads that are frequently used, but the important part is that they are useful without you realizing they're all specific cases of this concept of "monad" (in particular: maybe, list, io, ...)... learn to use them on themselves before you learn to generalize
15:43:31 <lispy> The nicest thing about monads in Haskell is that you can actually understand each one in isolation without needing to grasp the larger context.
15:43:38 <kvanb> a Monad is like a layer you can put your program inside that adds generic behaviour *for* you
15:43:53 <kvanb> and you can layer monads on top of other monads to create truly stunning mixes of behaviour
15:43:56 <Lutin`> moghedrin: Mathematicians tend to be :P
15:43:58 <kvanb> those are called transformers
15:44:22 <moghedrin> Lutin`: No argument there.
15:44:39 <Lutin`> http://xkcd.com/435/
15:44:46 <kvanb> You need not technically fully understand monads to use them
15:44:55 <kvanb> although most people recommend you do. But it's hard.
15:44:58 <systemfault> As a Haskell beginner, IMHO, what’s difficult with it is the number of things you need to learn before being able to do anything with it.
15:45:20 <kvanb> Some "cheat" rules are to just understand how they wrap/unwrap with return and bind
15:45:20 <kazagistar> tr55: monads are at about the same level of abstraction as "AbstractFactory" or something... honestly, you will just learn of a few examples of things that act a certain way, and you will get the pattern, and that will be that, nothing to worry about
15:45:23 <kvanb> ie,
15:45:24 <Nik05> first you read stuff, you are confused
15:45:33 <kvanb> > Just 3 >>= \x -> x
15:45:34 <moghedrin> systemfault: This.
15:45:34 <lambdabot>  No instance for (GHC.Show.Show b0)
15:45:34 <lambdabot>    arising from a use of ‘M486057321426087240629085.show_M4860573214260872406...
15:45:34 <lambdabot>  The type variable ‘b0’ is ambiguous
15:45:34 <lambdabot>  Note: there are several potential instances:
15:45:34 <lambdabot>    instance [safe] GHC.Show.Show
15:45:46 <kvanb> hmm. That didn't work.
15:45:48 <Nik05> you are more confused and then some bits seem to fall in place :P
15:45:58 <Lutin`> > (Just 3 >>= id) :: Integer
15:46:00 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
15:46:00 <lambdabot>              with actual type ‘Data.Maybe.Maybe b0’
15:46:07 <Lutin`> Whoops what am I doing
15:46:11 <Lutin`> > (Just 3 >>= id) :: Maybe Integer
15:46:12 <lambdabot>  No instance for (GHC.Num.Num
15:46:12 <lambdabot>                     (Data.Maybe.Maybe GHC.Integer.Type.Integer))
15:46:12 <lambdabot>    arising from the literal ‘3’
15:46:12 <kvanb> Lutin`: I would have thought that would totally work ...
15:46:18 <sipa> Just 3 >>= Just
15:46:19 <tr55> cool
15:46:23 <systemfault> It’s actually my third time I try to learn haskell :P I always ended quitting for non-haskell-related reasons (lack of time.. etc)
15:46:23 <Lutin`> Oh
15:46:39 <lispy> systemfault: I hope it sticks this time :)
15:46:46 <Lutin`> > ((Just 3) >>= id) :: Maybe Integer
15:46:47 <lambdabot>  No instance for (GHC.Num.Num
15:46:47 <lambdabot>                     (Data.Maybe.Maybe GHC.Integer.Type.Integer))
15:46:47 <lambdabot>    arising from the literal ‘3’
15:46:51 <kvanb> > Just 3 >> return
15:46:52 <sipa> id is not a monadic action
15:46:52 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe b’
15:46:53 <lambdabot>              with actual type ‘a1 -> m0 a1’
15:46:57 <kvanb> blah, typo
15:47:05 <Lutin`> What am I doing with my life
15:47:08 <sipa> oh, it is, but not of Maybe
15:47:15 <moghedrin> systemfault: Such is life.
15:47:16 <kvanb> I am the worst at this
15:47:17 <sipa> > Just 3 >>= Just
15:47:18 <lambdabot>  Just 3
15:47:24 <sipa> > Just 3 >>= cost Nothing
15:47:24 <kvanb> This guy is going ot have the worst impression
15:47:25 <lambdabot>  Not in scope: ‘cost’
15:47:25 <lambdabot>  Perhaps you meant one of these:
15:47:25 <lambdabot>    ‘const’ (imported from Data.Function),
15:47:25 <lambdabot>    ‘cos’ (imported from Prelude), ‘cosh’ (imported from Prelude)
15:47:27 <kvanb> I swear.
15:47:44 <Lutin`> I'm trying to IRC and play Dota 2 at the same time
15:47:48 <Lutin`> does not work well
15:47:55 <systemfault> lispy: Yeah :) But even with what I learned the other times… it still made me a better programmer because it showed me that side-effects are evil, and that for loops are useless when you have HOF like map/filter/reduce (fold)
15:48:03 <kvanb> I was actually searching on Dota 2 for people with names that match haskell typeclasses
15:48:21 <kvanb> I found a lot of people called things like functor, endofunctor and applicative with haskell cat pictures as dps
15:48:42 <systemfault> Haha
15:48:45 <kvanb> /s/pictures/memes/
15:48:58 <sipa> dps?
15:49:05 <lispy> systemfault: cool. "side-effects are evil" --> you can generalize this to "separation of concerns", BTW.
15:49:38 <systemfault> lispy: Never thought of it that way.
15:50:00 <systemfault> I do my best to have a good separation of concerns in my programs though.
15:50:08 <lispy> systemfault: I think separation of concerns is one of the most important (and sometimes subtle) design principles to develop
15:50:11 <kvanb> tr55: the other thing too though, is that you write less code using monads which implement stacks of generic behaviour
15:50:20 <kvanb> because most monads are basically macros
15:50:29 <yogurt_truck> systemfault: what did you expect to be able to do as soon as you started learning haskell?
15:50:30 <lispy> and it's only really important because we're humans
15:50:35 <kvanb> i.e. ErrorT which lets you write code that can fail at any point
15:50:40 <tr55> interesting
15:50:46 <kvanb> and just error out without putting if (...) { } or exceptions everywhere
15:50:49 <kvanb> like in regular imperative code
15:50:51 <kazagistar> "separate value and state"
15:50:58 <Lutin`> kvanb: I should make mine "Monoid in the Category of Endofunctors"
15:51:07 <kvanb> Lutin`: mine is fibonacci golfed
15:51:12 <systemfault> yogurt_truck: I don’t know… a small but working IRC client in less than a day
15:51:14 <moghedrin> It's funny - I remember HATING having to wrap all the file grabbing and input in the IO method. Now, I find that forcing me to seperate out my code in a sane way is my favorite feature of the langauge.
15:51:20 <systemfault> yogurt_truck: I was so wrong though.
15:51:27 <kini> rwbarton: thanks for fixing ghc #9012 :)
15:51:32 <kvanb> > Data.Function.fix $ scanl (+) 1 . (1:)
15:51:34 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
15:52:13 <yogurt_truck> systemfault: because there's no reason a newcomer can't be writing at least some command line utilities on day 1
15:52:16 <yogurt_truck> systemfault: right
15:52:25 <lfairy> > fix $ scanl (+) 0 . (1:)
15:52:27 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:52:34 <lfairy> I prefer starting at 0 :P
15:52:36 <yogurt_truck> systemfault: I take you you went the LYAH way?
15:52:40 <systemfault> yogurt_truck: Yes
15:52:46 <systemfault> yogurt_truck: Do you have another way?
15:52:57 <systemfault> yogurt_truck: I also bought RWH
15:52:59 * haasn didn't come into Haskell expecting anything
15:53:01 <haasn> Perhaps that is the best way
15:53:15 <yogurt_truck> systemfault: yes, LYAH to me is a perfect *second* book, not first
15:53:36 <systemfault> yogurt_truck: Can’t wait for you to tell me what is “the” starting book :)
15:53:40 <kvanb> RWH is hard and fast
15:53:48 <kvanb> LYAH first few chapters is better as an introduction
15:54:15 <kvanb> There's also this
15:54:16 <kvanb> http://www.haskell.org/haskellwiki/Haskell_Tutorial_for_C_Programmers
15:54:45 <haasn> I want the inverse of that
15:54:54 <kvanb> C for Haskell programmers?
15:54:56 <yogurt_truck> systemfault: I think for a very experienced programmer, with some notions of FP, RWH is the best first book. And for a newcomer who just has never been told about computing from the FP perspective (inductive reasoning, *real* separation of concerns, computation vs. executiong of effects, formal reasoning, etc) then I think Chakravarty and Keller's intro to computing is by far the best first book
15:54:58 <haasn> Exactly
15:55:06 <kvanb> C is easy
15:55:18 <lispy> haasn: I had to learn it for a course. I was like, "I already program in LISP, who needs these types..." Then one day the value of types hit and I was hooked :)
15:55:32 * haasn is not sure whether “Is C a monoid?” would be appropriate
15:55:43 <kvanb> in fact, unlike C++, C actually follows a handful of rules which can be reused over and over and over
15:55:53 <kvanb> which is why it has a religious following
15:55:57 <radix> kvanb: yeah... I tried finding a "C++ for programmers" book once, couldn't find any good ones
15:56:22 <Peaker> kvanb: C is in dire need of improvement in light of recent progress
15:56:28 <kazagistar> you still have an ugly bit around how type signatures are read, etc, but C is pretty easy overall
15:56:32 <kvanb> unlike a lot of languages I think you can actually "truly learn C"
15:56:32 <Peaker> s/recent//
15:56:33 <systemfault> yogurt_truck: Noted
15:56:41 <radix> every C++ book I've ever tried to read starts with "in 1983, bjarne stroustrup invented object-oriented programming, and birthed programming as we know it"
15:56:44 <haasn> lispy: I accidentally stumbled upon https://en.wikibooks.org/wiki/Haskell and couldn't stop reading, quickly found LYAH and just started reading
15:56:45 <dolio> Peaker: Heh.
15:56:51 <kvanb> Peaker: har, you're here
15:56:57 <kvanb> I shall not lecture you on Pipes vs Writer
15:57:00 <Peaker> kvanb: yeah, I am
15:57:11 <Peaker> kvanb: I don't think I need 6 type variables just yet :)
15:57:18 <Peaker> kvanb: type parameters, that is
15:57:23 <systemfault> yogurt_truck: Thank you
15:57:24 <kvanb> basically, the punchline is Pipes consumes the output instantly so it gets garbage collected
15:57:29 <kvanb> whereas Writer does not.
15:57:32 <Peaker> kvanb: StateT does the same
15:57:46 <Lutin`> kvanb: So does Strict WriterT
15:57:51 <kvanb> Not so much if you feed the output of Writer into something like stdout
15:58:13 <Peaker> the problem with WriterT is the way the mappends are associated, it requires holding a lot of subexpressions in memory simultaneously
15:58:34 <Peaker> if you associate them to the left via StateT, then you only need the most recent total in memory
15:58:48 <kazagistar> I like LYAH just because it is written in a fun way, its probably my favorite language book ever
15:59:03 <kvanb> kazagistar: the erlang one by the same author is fun too
15:59:08 <kvanb> but it takes the piss out of erlang at the same time
15:59:32 <kini> is there a way I can define my own `cabal` subcommand?
16:00:56 <haasn> When I say “C for Haskell programmers”, I mean “C taken rigorously” - I don't want to know how to write programs in C, I can do that by looking at C; I want to understand what the semantic value of C actually is, what's undefined behavior, what's defined behavior, what *exact* operational semantics things must represent. Sure, I could just read the C language standard, but I tried doing that and
16:00:58 <haasn> couldn't understand any of it because it isn't written as a structured introduction. I want to understand things in terms terminology or analogies a Haskell programmer would be familiar with
16:00:58 <kvanb> kini: probably not, but Setup.hs can do a lot of stuff
16:01:08 <kini> kvanb: aw.
16:01:29 <kvanb> kini: cabal has test/benchmark/clean and stuff like that though
16:01:33 <kini> I was hoping I could make a `cabal typecheck`
16:01:36 <kvanb> and you can add more stuff to "build" I think
16:01:45 <haasn> kvanb: “cabal repl”?
16:01:48 <haasn> kini*
16:01:55 <kvanb> yeah repl is what I was just thinking
16:01:58 <fozworth> i'm working on a library and want to know if it's reasonable to have lens as a dependency, since it has so many dependencies itself
16:02:04 <extraplanetary> in general, you can't typecheck without building (because of TH)
16:02:07 <kvanb> fozworth: lens-family-core
16:02:09 <kini> kvanb: yeah, I just got done hacking together a build hook for Happy and Alex :) https://github.com/simonmar/happy/pull/23
16:02:11 <Lutin`> kvanb: There's also cabal exec
16:02:24 <kini> haasn: as extraplanetary guessed, I wanted to avoid the overhead of building
16:02:32 <haasn> I wish I had a “type-check while treating all unbound names as holes”
16:02:46 <haasn> in case I don't want to install dependencies, but still want to type-check some code fragment I am writing internally
16:03:02 <kini> so I can basically do what I want by running `cabal install --ghc-option=-fno-code`
16:03:08 <fozworth> kvanb: thanks, i didn't know about that package. i'll check it out
16:03:13 <kazagistar> haasn: one of the heavily advertised advantages of haskell is the strong and rigorous theoretical underpinnings that are just hard to find elsewhere... if we provided that for C, we would lose that edge :P
16:03:14 <kvanb> haasn: I always have to resort to using undefined for that :/
16:03:16 <kini> I guess that probably breaks when TH is involved?
16:03:19 <haasn> kini: Right, I suggested repl only because by loading it interactively you're bypassing the optimization, code generation etc. stages
16:03:20 <kvanb> and then I open it up in repl
16:03:26 <haasn> since it just gets loaded into the interactive interpreter
16:03:36 <kini> haasn: but it still has to build dependencies doesn't it
16:03:49 <teakay> can anyone tell me why yesod doesnt allow different handlers for the same route but different http methods?
16:03:54 <haasn> If they're separate packages, I'd definitely think so
16:03:56 <kvanb> C doesn't really take you on a journey where you ever need to think about uhh
16:03:58 <yogurt_truck> systemfault: np
16:04:00 <jmcarthur> hseg: it's not really the catamorphism of a snoc list. if it was, you could evaluate the result from right to left without traversing the whole list :P
16:04:02 <haasn> If they're other modules in the same package, I'm not sure
16:04:12 <extraplanetary> fozworth: if you're -consuming- lenses, that's a tradeoff between dependency weight and convenience. You can define most lens-ish things for consumption by users without importing (much) code, though
16:04:21 <Lutin`> kini: Would ghc-mod work for you?
16:04:35 <fozworth> extraplanetary: unfortunately i'm creating lenses, not consuming them
16:04:44 <kvanb> well, basically, there's only a handful of exceptions related to things like the ++/-- operators and assignments
16:04:48 <kini> Lutin`: maybe, I haven't tried it
16:05:00 <fozworth> i explain my thought process here https://github.com/tfausak/strive/pull/48 (and the linked issue #44)
16:05:00 <extraplanetary> fozworth: then you don't need to depend on lens, unless you're using its TH helpers
16:05:09 <jmcarthur> hseg: what if you think of it like a foldMap that produces a value of type   Endo accumulator
16:05:39 <jmcarthur> hseg: i honstly don't know how to demonstrate some formal relationship between foldl and foldr, but i think the endo observation offers a lot of intuition
16:05:57 <hseg> jmcarthur: That is a useful way of thinking of it.
16:07:12 <hseg> jmcarthur: And in fact, you're technically correct in saying that foldl isn't the cata for snoc-lists. However, we *do* have: foldl = cata . cons2snoc
16:08:08 <hseg> And cons2snoc must either traverse the entire list or create a thunk that causes the cata to traverse the entire list
16:09:19 <extraplanetary> fozworth: you don't need to depend on lens to define lenses/traversals that will work with lens's combinators. The problem you have is that using the TH stuff to reduce boilerplate -does- require you to depend on lens
16:10:18 <fozworth> extraplanetary: i was afraid of that. i'd love to be able to avoid the lens library entirely, but fclabels didn't cut it and i don't (yet) want to write my own TH
16:10:26 <Peaker> extraplanetary: and it slows compilation to hell
16:10:38 <extraplanetary> fozworth: no need for TH if you can stand boilerplate
16:11:14 <fozworth> there would be an immense amount of it in my library due to all the types
16:11:28 <fozworth> i'd end up writing a perl/ruby/python script to generate the haskell
16:11:34 <fozworth> might as well use TH at that point, right?
16:11:38 <hseg> fozworth: You don't need to *write* TH, just *use* it.
16:11:56 <hseg> fozworth: Unless I misunderstand your case
16:12:39 <hseg> fozworth: But lenses can be autogenerated in most cases using TH functions from lens.
16:13:24 <extraplanetary> fozworth: what you might do is split out the lens stuff into another package, strive-lens, to keep the core package lightweight
16:13:40 <quchen> I'm looking for a compression library for short sentences. Zlib seems to work nicely, but it throws exceptions if the input is malformed. Is there a safer alternative?
16:14:07 <quchen> (Short sentence = 2-10 words, some special chars as separators)
16:14:38 <quchen> I can of course unsafePerformIO a catch block, but that's hardly ideal.
16:16:15 <felixn> hey, is there any articles about how IO is implemented in haskell?  seems like I would have to do lifts for all the different types of IO, like I do for different types of monads
16:16:48 <quchen> There is only one IO type (constructor), what do you mean?
16:16:53 <ReinH> felixn: "different types of IO"?
16:17:14 <quchen> Also, there is no IO implemented in Haskell. IO is implemented in implementations of Haskell. Are you asking how GHC implements IO, for example?
16:17:15 <felixn> ok maybe that doesn't make sense, I guess that's the problem >_<
16:17:18 <Hermit> felixn: MonadIO != IO
16:17:41 <ReinH> felixn: what problem are you having?
16:18:08 <fozworth> extraplanetary & hseg: http://lpaste.net/106884
16:18:27 <tr55> "systemfault: As a Haskell beginner, IMHO, what’s difficult with it is the number of things you need to learn before being able to do anything with it."
16:18:33 <tr55> systemfault: ^^
16:18:37 <tr55> I think I agree with you!
16:18:48 <tr55> I'm half-way through LYAH, and I still can't do a damn thing.
16:19:14 <mzero> main=putStrLn "Hello world."    -- what more do you need to know?  :-)
16:19:28 <etandel> IMHO as Haskell beginner, what's difficult is decoding ghc error messsages.
16:19:54 <mzero> ah, "crazy moon poetry" - so nice for the compiler to compose sonnets to you, isn't it?
16:20:15 <matematikaadit> how a haskell beginner see haskell error message https://cdn.mediacru.sh/p7RXz_iOocuK.png
16:20:36 <tr55> lol
16:20:45 <kazagistar> tr55: define "damn thing", I started writing an assembly-based virtual machine after reading like a third of LYAH :D
16:20:54 <tr55> oh
16:21:25 <kazagistar> er, assembly based means it ran something that looked like assembly code
16:21:30 <Hermit> felixn: how IO works is implementation specific. Also, there's no "different IOs", there's just one IO type. Roughly speaking, IO is just a simple data/newtype constructor and the accessor is not exported, then the code of the very primitives that use IO resides in the compiler RT and just wrap the result in IO. Does this make sense to you?
16:21:38 <etandel> matematikaadit: lol. mostly
16:22:07 <felixn> ReinH: Hermit: just trying to get lower level understanding of haskell, of how it builds up the IO type .. though I feel like I now just forgot everything I knew about monads
16:22:57 <ReinH> felixn: this is how IO works in Haskell http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
16:23:32 <quchen> ReinH: http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
16:23:33 <quchen> ;-)
16:23:39 <felixn> ReinH: haha thank you, that's not too far off from how I thought it worked
16:23:51 <ReinH> quchen: that's... the same link?
16:23:57 <extraplanetary> fozworth: more or less, yes. (You'd actually only define one class method to get a lens, and it'd have type `(Functor f) => (b -> f b) -> a -> f a`, but that's isomorphic to what you have there.)
16:23:59 <tr55> is haskell adoption growing exponentally right now like crazy?
16:24:03 <quchen> ReinH: Ohhhohhhhh. :-(
16:24:09 <ReinH> quchen: :p
16:24:12 <ReinH> quchen: great minds?
16:24:14 <quchen> ReinH: I thought you were posting something serious and I immediately had to respond with that.
16:24:21 <ReinH> quchen: lmao nice one
16:24:43 <fozworth> extraplanetary: i haven't yet grokked how to accomplish this with one class method, but i'm sure i'll get there :)
16:24:47 <benzrf> who pinged me
16:25:11 <benzrf> somebody pinged me o.o
16:25:12 <extraplanetary> fozworth: in fact, what you've written there is (isomorphic to) what Control.Lens.TH.makeFields would write
16:25:31 <hseg> fozworth: Do you want to give your users a lensy interface to use? If so, then you can either manually write the class, or use http://hackage.haskell.org/package/lens-4.2/docs/Control-Lens-TH.html#v:makeFields (it will also serve you well as inspiration). Otherwise, you can use OverloadedRecordFields (GHC 7.8+)
16:25:37 <moghedrin> tr55: I sure hope not ;D
16:25:47 <tr55> moghedrin: why not. more competition?
16:26:08 <moghedrin> tr55: Mostly I just won't feel quite as superior anymore.
16:26:10 <fozworth> hseg: is OverloadedRecordFields in 7.8? i thought it didn't make it. (regardless, i've been developing on 7.6 (HP))
16:26:15 <tr55> moghedrin: :D
16:26:30 <hseg> I thought it made it? Mea culpa.
16:26:34 <Cale> felixn: One can imagine that IO action values are syntactic descriptions of actions, and there's some sort of interpreter for them in the runtime which is decomposing the IO action main and carrying out the actions that it describes.
16:26:38 <tr55> LYAH was really the missing manual i think
16:26:38 <fozworth> extraplanetary: that's what i've started doing https://github.com/tfausak/strive/pull/48/files#diff-a395cea60bf205ee5b4ca93bc058eb77R11
16:26:41 <tr55> for mass adoption
16:26:54 <hiptobecubic> tr55, i really liked it. Although it wasn't finished when I went through it
16:27:37 <extraplanetary> fozworth: so, yeah. I think your best plan is to offer users lenses as part of a separate package, which they don't need to use if they're determined not to suck in the whole ekmettverse as a dependency
16:27:40 <Cale> felixn: That's not actually how it works in GHC though -- in GHC's implementation, they just use impure functions of a 0-byte wide parameter.
16:27:56 <Cale> @src IO
16:27:57 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:28:11 <Cale> newtype IO a
16:28:11 <Cale>   = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
16:28:11 <Cale>                   -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
16:28:15 <fozworth> extraplanetary: sounds like a plan. thanks for the help.
16:28:17 <kvanb> fozworth: you can do lenses without any lens dependencies
16:28:23 <kazagistar> I mean, thunks store a pointer to some machine code that evaluates it... for IO, there is nothing that restricts that machine code to be "pure"
16:28:26 <kvanb> by defining your own type aliases like pipes-binary does
16:28:35 <kvanb> they aren't solid types, just tuples and stuff
16:29:44 <Cale> It would be pretty cool if IO actions were actually values of some GADT, and we could take them apart again.
16:29:50 <felixn> Cale: that's close to what I was thinking, even poked at putStrLn ... I was trying to do an exercise of basically building fake IO inside of haskell
16:30:04 <fozworth> kvanb: i'll look into that. i don't think i grok lenses yet so it'll be good to look at another implementation
16:30:14 <Cale> (but compiling that efficiently would be much more challenging)
16:30:49 <felixn> Cale: someone in here showed me awhile back how you can peak at the data, it was neat!
16:30:51 <hseg> felixn: You mean something like http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ?
16:31:35 <matematikaadit> tr55: have you try the course mentioned in http://github.com/bitemyapp/learnhaskell
16:32:06 <felixn> my first step was to try and reimplement `putStrLn` and `>>` and `IO a` into something that spits out IO actions
16:32:13 <jle`> matematikaadit:
16:32:25 <tr55> matematikaadit: no, thanks, didn't know about that page
16:33:09 <Peaker> Cale: did more thinking about the WriterT memory leak issue we discussed -- the pattern match waiting on the stack is really a red herring. The way WriterT forms a tree of mappend operations, rather than a left fold inherently requires memory for all the subtree states, whereas StateT flattens the tree to the running total, similarly to foldl'
16:33:33 <Peaker> (nice to know it's an inherent issue, and not some sort of GHC particularity)
16:34:11 <Cale> Peaker: Ah, yeah, the tree of mappends has the same structure as the computation
16:34:37 <Cale> Peaker: So while it'll usually be right-leaning, it might lean to the left if you have a lot of left-recursion in your parser
16:35:57 <Peaker> Cale: in a strict monad, there's really no reason to use WriterT in its current form, similarly to how there's no reason to use foldr with a strict operation on a list
16:36:24 <Peaker> it does seem like WriterT will be replaced by some sort of StateT representation in a (hopefully near) future release
16:37:03 <matematikaadit> jle`: um... something wrong?
16:37:21 <jle`> matematikaadit: oh sorry, sent by accident :) my apologies
16:40:49 <benedikt> http://codepad.org/ksEyJE6P # i have some dependency problems, and I'm pretty much new to haskell.
16:43:19 <felixn> hseg: thanks man!  that's exactly it, there's a bunch of non trivial stuff in there ... had no idea about doing `data Cheat f = Cheat (f (Cheat f))`
16:43:56 <felixn> hseg: Toy a would be like IO a, right?
16:44:22 <zereraz> hello everyone, I am new to haskell and I have a small haskell doubt http://hastebin.com/apoyizunol.avrasm , I was trying take (quadruple1 2) [1,2,3,4,5,6,7,8,9] and I got the first 8 elements as it should have happened , but quadruple2 is not doing the same is it because it can only take 1 parameter?
16:44:32 <kini> benedikt: can we see your whole project, or at least the .cabal file?
16:45:02 <benedikt> kini: sure. but if it helps, its a spanking new yesod project
16:45:19 <benedikt> it probably has something to do with the fact i havent used mongodb before
16:45:22 <kini> never used yesod but I thought if I looked at your cabal file I might be able to help diagnose
16:45:30 <rwbarton> and are you running this cabal install command in a spanking new sandbox?
16:45:41 <benedikt> rwbarton: yep
16:45:44 <jle`> zereraz: hm the two quadruples should be doing the same thing, i think
16:45:49 <jle`> zereraz: is there a compile error?
16:46:00 <benedikt> kini: looking for the file
16:46:10 <rwbarton> it's weird then that there are apparently versions of SHA, aeson already installed into the sandbox
16:46:26 <kini> blowing away the sandbox and starting a new one often helps with dependency problems :P
16:46:47 <zereraz> jle`: normally they work fine for 1 argument, here the error is couldn't match type
16:47:22 <jle`> zereraz: can you paste the error?
16:47:28 <zereraz> jle`: 'Int' with actual type 'Integet -> Integer'
16:47:41 <benedikt> i ran "cabl sandbox init; cabal install yesod-platform yesod-bin; yesod init -bare; cabal install --dependencies-only --enable-tests" and the depency errors happen in the last line (cabal isntall)
16:47:57 <jle`> zereraz: on what line?
16:47:58 <zereraz> *Main> take quadruple2 [1,2,3,4,5,6,7,8,9]
16:47:59 <zereraz> <interactive>:3:6:
16:47:59 <zereraz>     Couldn't match expected type `Int'
16:48:00 <zereraz>                 with actual type `Integer -> Integer'
16:48:02 <zereraz>     In the first argument of `take', namely `quadruple2'
16:48:04 <zereraz>     In the expression: take quadruple2 [1, 2, 3, 4, ....]
16:48:06 <zereraz>     In an equation for `it': it = take quadruple2 [1, 2, 3, ....]
16:48:10 <rwbarton> benedikt, oh
16:48:15 <zereraz> I am using ghci
16:48:16 <kini> zereraz: you forgot the "8" after "take" :)
16:48:45 <jle`> zereraz: quadruple :: Int -> Int, so you can't appy it to a list
16:48:56 <jle`> you can use map to turn any Int -> Int into an [Int] -> [Int]
16:49:06 <zereraz> sorry wrong command , even then it does not work
16:49:09 <jle`> so you can do something like take 8 (map quadruple [1,2..])
16:49:14 <l0cust> Is there anything wrong with using `case' instead of `if'
16:49:16 <l0cust> ?
16:49:21 <zereraz> jle`: take (quadruple2 2) [1,2,3,4,5,6,7,8,9] does not work too
16:49:32 <jle`> zereraz: what is the error?
16:49:41 <kini> l0cust: case allows you to have non-exhaustive pattern match but if doesn't :P
16:49:59 <matematikaadit> @let double x = x + x
16:50:01 <lambdabot>  Defined.
16:50:01 <jle`> l0cust: case x of True -> ...; False -> ... ?
16:50:05 <kini> if you use if then you can be sure that as long as it typechecks, it's not going to crash, but case statements can typecheck but still crash
16:50:13 <zereraz> jle`:  I don't want to quadruple the list items, I want to take 8 with this like i did with quadruple1
16:50:25 <l0cust> jle`: almost
16:50:27 <jle`> zereraz: what is the error?
16:50:29 <l0cust> jle`: let me push the code
16:50:47 <zereraz> take (quadruple2 2) [1,2,3,4,5,6,7,8,9]
16:50:48 <zereraz> <interactive>:4:7:
16:50:49 <zereraz>     Couldn't match expected type `Int' with actual type `Integer'
16:50:50 <benedikt> kini: where is .cabal ..?
16:50:51 <zereraz>     In the return type of a call of `quadruple2'
16:50:53 <zereraz>     In the first argument of `take', namely `(quadruple2 2)'
16:50:55 <zereraz>     In the expression: take (quadruple2 2) [1, 2, 3, 4, ....]
16:50:56 <jle`> oh
16:51:04 <jle`> quadruple2 returns Integer but take takes Int
16:51:05 <jle`> :t take
16:51:06 <lambdabot> Int -> [a] -> [a]
16:51:11 <jle`> you want to turn off the monomorphism restriction
16:51:16 <jle`> or put a type signature for quadruple
16:51:20 <jle`> quadruple2 :: Int -> Int
16:51:26 <kini> oh, oops, jle` is right :)
16:51:29 <zereraz> what is the difference between Int and Integer?
16:51:30 <_2_Chloegurl_pre> hey
16:51:30 <jle`> or :set -XNoMonomorphismRestriction
16:51:31 <l0cust> jle`: https://github.com/pharpend/eros-client/blob/unstable/src/Main.hs , end of file
16:51:32 <jle`> on ghci
16:51:33 * kini shakes fist at monomorphism restriction
16:51:35 <jle`> zereraz: they are different types
16:51:36 <rwbarton> benedikt: the problem is that the first "cabal install yesod-platform yesod-bin" is bringing in newer versions of some libraries (since cabal doesn't have any reason not to at that point), which are incompatible with the .cabal file that ends up getting produced
16:51:42 <jle`> Int is a type, Integer is another
16:51:45 <jle`> :)
16:51:52 <jle`> Int usually represents a machine signed int
16:51:55 <jle`> Integer is unbounded
16:52:00 <zereraz> jle`: oh , thanks allot
16:52:02 <jle`> > maxBound Int
16:52:04 <lambdabot>  Not in scope: data constructor ‘Int’
16:52:04 <lambdabot>  Perhaps you meant one of these:
16:52:04 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
16:52:04 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
16:52:04 <benedikt> rwbarton: i see. should i run the commands in another order?
16:52:05 <jle`> er
16:52:08 <jle`> > maxBound :: Int
16:52:10 <lambdabot>  9223372036854775807
16:52:11 <jle`> > maxBound :: Integer
16:52:13 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
16:52:13 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
16:52:26 <jle`> Integer is like BigNum, if you come from Java
16:52:33 <rwbarton> benedikt: well you don't have much choice, because you need yesod-bin to run yesod init, and you need yesod init to create a .cabal file before you can cabal install --dependencies-only it :)
16:52:38 <jle`> or another "big unbounded integer library"
16:52:42 <zereraz> jle`: I am totally new to haskell , recently started. ok got it
16:52:52 <rwbarton> benedikt: I would instead install yesod-bin in a separate sandbox first
16:53:03 <jle`> zereraz: put {-# LANGUAGE NoMonomorphismRestriction -#} at the top of your file, if the ghci :set -XNoMonomorphismRestriction doesn't work (which it should)
16:53:14 <rwbarton> or in other words, cp the yesod binary out of your sandbox somewhere and then wipe it out
16:53:19 <jle`> zereraz: this is a known annoyance; in 7.8.2, this is the default behavior for GHCI :)
16:53:22 <benedikt> rwbarton: after running yesod init suggets i create the sanbox afterwards
16:53:24 <jle`> zereraz: the right one that is
16:53:34 <zereraz> jle`: ok thanks
16:53:35 <kvanb> jle` nmr is bad isnt it?
16:53:40 <benedikt> rwbarton: but i was follwing a tutorial that suggested creating the sandbox first
16:53:45 <jle`> kvanb: it's good in many circumstances
16:53:51 <jle`> the main times it is bad is on ghci
16:53:55 <kini> I should have known it would be the monomorphism restriction when I saw two functions defined, one with an argument on the left hand side of the equals sign and one without...
16:53:58 <jle`> zereraz: alternatively you can just put in the manual type signature
16:54:09 <jle`> zereraz: quadruple2 :: Int -> Int
16:54:12 <rwbarton> benedikt: well that might work, but it can't be guaranteed to as seen here
16:54:23 <jle`> zereraz: also, there is "fromIntegral", which is Int -> Integer
16:54:23 <benedikt> rwbarton: ill give it a try
16:54:39 <jle`> zereraz: so you can do take (fromIntegral (quadruple2 2)) [1..]
16:54:45 <jle`> but that's probably not a good solution ^_^
16:54:47 <carlosgaldino> what's the best library to work with aws? this one? https://github.com/aristidb/aws
16:54:49 <zereraz> jle`: I'll do the Int->Int one
16:55:09 <jle`> zereraz: mhm.  it's good practice to put type signatures on "top level" function definitions
16:55:22 <jle`> so i recommend you do it even with the monomorphism restriction off
16:55:32 <jle`> kvanb: oh nmr is bad normally, but good for ghci
16:55:37 <jle`> i read what you said backwards
16:56:01 <zereraz> jle`:I got error with ghci for the monomorphism line
16:56:08 <jle`> 7.8.2 only turns off the monomorphism restriction for ghci
16:56:15 <jle`> zereraz: what is the error?
16:56:23 <zereraz> quad.hs:1:14:
16:56:24 <zereraz>     Cannot parse LANGUAGE pragma
16:56:24 <zereraz>     Expecting comma-separated list of language options,
16:56:25 <zereraz>     each starting with a capital letter
16:56:27 <zereraz>       E.g. {-# LANGUAGE RecordPuns, Generics #-}
16:56:29 <zereraz> Failed, modules loaded: none.
16:56:42 <jle`> oh
16:56:50 <jle`> it should end in #-}, not -#}
16:56:59 <zereraz> ok
16:57:01 <jle`> my bad
16:57:08 <zereraz> no problem :)
16:57:15 <jle`> typically you shouldn't put this on top of source code files :)
16:57:32 <jle`> i guess i am overloading you with information
16:57:50 <zereraz> jle`: It worked! thanks
16:57:56 <jle`> hooray!
16:58:18 <zereraz> jle`: its good, I am now more excited to learn more
16:58:39 <zereraz> jle`: thanks again
16:58:52 <jle`> np!
16:59:44 <rwbarton> benedikt: also, it would be worth contacting the yesod people (#yesod) about this, since it seems like it would affect most everybody
16:59:58 <matematikaadit> jle`++
17:00:12 <jle`> is there a reverse strength?
17:00:26 <jle`> Funcor f => f (a, b) -> (a, f b) ?
17:00:31 <benedikt> rwbarton: am i correct in assuming that it has to do with mongodb?
17:00:35 <jle`> hm probably can't do it with Functor
17:01:21 <jle`> but i want a generic version of Maybe (a, b) -> (a, Maybe b).
17:01:27 <jle`> something cool and sleek
17:01:33 <rwbarton> benedikt: oh, well, hmm, in a sense
17:01:40 <rwbarton> benedikt: is that an option you can choose in 'yesod init'?
17:02:09 <benedikt> rwbarton: yes, i can choose between persistence backends (sqlite, mysql, postgres, mongo)
17:02:10 * rwbarton vaguely recalls there being a list of DB backends to choose among
17:02:13 <rwbarton> right
17:03:02 <rwbarton> it's the kind of thing that *could* happen with any dependency, but the fact that it is concretely happening here is because you are using mongodb, yes
17:03:09 <benedikt> ive also tried using sqlite and didnt get dependency errors
17:03:11 <rwbarton> if that makes sense
17:03:15 <benedikt> it does
17:03:15 <jle`> actually what i'm asking doesn't even make sense
17:03:22 * benedikt heads over to #yesod
17:03:49 * Iceland_jack bumps benedikt :)
17:04:11 * benedikt bumps Iceland_jack back
17:07:01 <qtest> what should I use if I want a fixed-length list?
17:07:20 <jle`> qtest: Vector?
17:07:20 <qtest> of 9 elements
17:07:22 <jle`> er, Array
17:07:35 <jle`> Array over Vector here
17:07:39 <jle`> oh do you wnat the length to be in the type?
17:07:54 <qtest> yes
17:09:17 <qtest> I found this, but I don't know if it's the recommended solution: http://hackage.haskell.org/package/fixed-vector
17:09:54 <carter> linear
17:09:55 <jle`> qtest: http://hackage.haskell.org/package/linear-1.10.1.1/docs/Linear-V.html might work for you
17:10:04 <carter> qtest: whats your use case?
17:10:06 <carter> oh
17:10:12 * hackagebot RSA 2.0.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.0.0 (AdamWick)
17:10:29 <qtest> carter: tic tac toe board!
17:11:26 <jle`> perhaps a 3x3 matrix might be helpful
17:11:40 <carter> so linear ftw
17:11:56 <benedikt> rwbarton: my guess is that i had installed yesod-bin outside of a sanbox and the sandbox is using that version
17:12:28 <jle`> V3 (V3 (Maybe Piece))
17:12:30 <jle`> http://hackage.haskell.org/package/linear-1.10.1.1/docs/Linear-V3.html
17:13:02 <pjdelport> qtest: Array with 2-tuple indexes is a good fit for a tic tac toe board.
17:13:24 <jle`> qtest: altneratively, V $(int 9) (Maybe Piece)
17:13:43 <extraplanetary> is there a general way to turn off roles in 7.8, or do I need to break out unsafeCoerce?
17:16:05 <jle`> hm. if i want my api to be able to take in a continuous chunk of indexable memory...and i never change the length...should I make it accept Vector or Array?
17:16:06 <rwbarton> you cannot turn them off... but what are you going to use unsafeCoerce on exactly?
17:16:24 <qtest> does the Array type encode the length in the type?
17:16:30 <Cale> qtest: yes
17:16:35 <Cale> Er
17:16:40 <Cale> qtest: Not in the *type*
17:17:14 <extraplanetary> rwbarton: I'm playing with recursion-schemes and getting bitten by #9123
17:17:16 <benzrf> qtest: that would require dependent typing
17:17:21 <extraplanetary> (at least I think it's #9123...)
17:17:24 <benzrf> qtest: or you could use type level nats but they suck
17:17:39 <Cale> qtest: The Array values themselves maintain the bounds, but that's runtime information.
17:17:40 <rwbarton> extraplanetary: that is about generalized newtype deriving, right?
17:17:53 <extraplanetary> rwbarton: yep
17:17:57 <qtest> benzrf: why do they suck?
17:18:12 <rwbarton> extraplanetary: oh, i see what you mean, write a manually "derived" instance using unsafeCoerce in the methods
17:18:19 <benzrf> they are super awkward and have abstruse error messages
17:18:23 <benzrf> or so im told
17:18:30 <benzrf> and they tend to require extns
17:18:56 <qtest> what's the difference between linear and fixed-vector?
17:25:14 * hackagebot ua-parser 0.5 - A library for parsing User-Agent strings, official Haskell port of ua-parser  http://hackage.haskell.org/package/ua-parser-0.5 (OzgunAtaman)
17:31:18 <Lutin`> oh my jesus
17:31:26 <Lutin`> I'm watching a video on evil-mode
17:31:43 <Lutin`> I was sold at live search/replace
17:32:11 <carter> this the emacs thingy?
17:32:21 <Lutin`> basically vim-mode for emacs
17:32:50 <johnfn> i maintain that evil mode is the best editor :)
17:33:06 <hiptobecubic> It's great if you don't actually know vim ;)
17:33:12 <Lutin`> I'm about to have a braingasm
17:33:37 <Lutin`> Here's the video if you need motivation https://www.youtube.com/watch?v=Uz_0i27wYbg
17:35:35 <kvanb> is it threadsafe for multiple forks to write to the same socket?
17:37:03 <hiptobecubic> Lutin`, i have a plugin for this live search/replace thing. It is seriously great. yes.
17:37:12 <dwcook> kvanb, not in the way I imagine you mean.
17:37:37 <dwcook> kvanb, what I've done before is use a Chan of some sort and a single dedicated thread for writing to a socket from the Chan
17:37:40 <kvanb> yeah, I just thought that through a bit
17:37:41 <rwbarton> it should be threadsafe, if you don't care what you actually send over the socket
17:37:44 <rwbarton> :)
17:37:44 <kvanb> and I realized it couldn't be
17:37:49 <AshyIsMe> when i tried evil mode i hit vim features that weren't implemented in the first couple minutes
17:38:01 <AshyIsMe> cant remember exactly what now but still it was annoying enough
17:38:07 <kvanb> dwcook: that's exactly what I just decided was going to be my solution :)
17:38:17 <kvanb> thanks
17:38:47 <rwbarton> maybe on a UDP socket it could make some sense
17:40:05 <kvanb> is waiting on tons of TChans a big deal?
17:40:17 <kvanb> is there some OS support for blocking on them or some kind of event system
17:40:31 <kvanb> or does it poll... the latter is kind of frighteningly unscalable-sounding
17:40:54 <dmwit> I would imagine reading from a TChan blocks if the TChan is empty.
17:41:03 <dmwit> Do you need to read from tons of TChans? Why not just one?
17:41:22 <kvanb> because I have one for the server broadcast messages (so that broadcasting is O(1))
17:41:29 <kvanb> and one for the client personal messages
17:41:58 <dmwit> two doesn't seem like "tons" to me
17:42:08 <kvanb> (and another from the socket)
17:42:21 <kvanb> but well, 500 clients by 3 TChans sounds like tons to me
17:42:36 <kvanb> I was just wondering if there's a "better way" ?
17:42:38 <dmwit> I believe I don't understand you.
17:42:41 <rwbarton> you skipped over the part where there was anything per client
17:43:07 <rwbarton> or wait, you mean you have 500 threads, each of which is waiting on a total of three TChans?
17:43:26 <kvanb> yeah, which actually means I should have 2000 forks
17:43:33 <dmwit> wait what
17:43:36 <kvanb> 1500 for the three tchans, and those fuse into a single one for the out socket
17:43:50 <rwbarton> I agree with dmwit.
17:44:29 <kvanb> that it doesnt sound like tons?
17:44:30 <dmwit> First of all: you should not need more than one thread per thread.
17:44:45 <rwbarton> can we abstract and say we have N producers and one consumer? then don't have N TChans (one per producer) which the consumer reads from all of, instead have one TChan which all the producers write to
17:44:47 <dmwit> That sounds ridiculous, especially given that you're *already* using STM, half of whose existence is owed to the need for (<|>).
17:46:08 <rwbarton> or is it that we have N producers and N consumers?
17:46:17 <kvanb> well, okay, what we have
17:46:32 <kvanb> is 1 server mailbox, for things like chat messages. That's the broadcast mailbox
17:46:38 <kvanb> 1 client socket for data from the client
17:46:46 <kvanb> and 1 client mailbox, for personal messages and stuff.
17:46:53 <kvanb> and 1 output socket to the client.
17:47:32 <kvanb> The client has a state, so these have to bottleneck into a single handler.
17:47:49 <rwbarton> okay
17:48:23 <kvanb> this isn't really a toy server. I'm building a server template for other people to write their servers on top of.
17:48:27 <kvanb> so I want to do it right (tm)
17:49:28 <kvanb> now, an easy approach is to have a single tchan the handler reads from and processes
17:49:30 <rwbarton> it sounds like maybe you want two threads per client? one that sits on the socket for data from the client and just feeds messages to a channel, and the other one handling everything else
17:49:55 <kvanb> everything else, via .. a monoid instance?
17:49:57 <rwbarton> since you can't wait on both a socket and TChan simultaneously
17:50:12 <rwbarton> just using STM and <|>
17:50:34 <kvanb> what if I had one thread for the handler  + stm <|>
17:50:40 <kvanb> and one for the socket that feeds into a TChan
17:50:45 <kvanb> then I could <|> all 3 in the handler
17:50:55 <rwbarton> right
17:51:05 <kvanb> that pleases me as an elegant solution.
17:52:35 <kvanb> should <|> be in order of least or most contention
17:52:37 <kvanb> or does it not matter?
18:00:44 <camlorn> So I've got another newbie question.  As an exercise, I'm trying to write a function that can count the number of nodes in a tree.  I've got it working for small and medium sized trees, but would expect to be able to get it to scale to very large ones (10 million nodes or greater) without a problem.  As I understand it, doing this recursively is creating problems because haskell holds off evaluating as long as it can, and I end up
18:00:44 <camlorn> with ten million thuncks on the stack.  can anyone help?
18:01:27 <dmwit> Yes, have you read about how to make your functions strict?
18:01:27 <Cale> camlorn: I can have a look
18:01:34 <mzero> sure - you just need to "force" the computation
18:02:01 <camlorn> Is there a way to simply say that a function needs to be strict?
18:02:14 <Cale> camlorn: There's bang patterns
18:02:21 <julianb> isn't it the same if you just set the length as a function parameter?
18:02:22 <Cale> But which tree type exactly?
18:02:29 <mzero> and you can use  $! to apply strictly
18:02:31 <camlorn> Binary search tree.
18:02:48 <camlorn> data Tree a = Tip | Node (Tree a) (Tree a)
18:03:04 <Cale> (a isn't used there)
18:03:13 <pjdelport> camlorn: You can look at foldl' versus foldl for an example of making a fold strict, to avoid the problem of excessive thunks.
18:03:43 <camlorn> Is there a tool to analyze this and see what's actually going on?
18:03:52 <mzero> there probably isn't a foldl in that counting code, though
18:04:50 <mzero> camlorn: did you observe a space leak, or are you just hypthosizing one?
18:05:06 <camlorn> Well, it says stack overflow.
18:05:13 <camlorn> Hang on and I'll paste this program somewhere.
18:05:15 <mzero> then, yes
18:05:21 <mzero> @where lpaste
18:05:21 <lambdabot> http://lpaste.net/new/haskell
18:05:36 <camlorn> Actually, half a sec, need to restart the IRC client. Something's going odd on my end.
18:07:40 <camlorn> This isn't the cleanest, but: http://lpaste.net/106887
18:07:57 <camlorn> the problem is in treeLength, which is the ugliest part because I've been refactoring to see what I can and can't get away with.
18:09:43 <Lutin`> Hey there camlorn
18:09:53 <dmwit> Style thing that probably won't affect runtime behavior: you don't need a helper. Just write that helper function as your top-level treeLength.
18:10:08 <extraplanetary> camlorn: you're seeing a stack overflow because it's not tail-recursive. Laziness and thunking isn't the culprit here (though you do still have a leak)
18:10:11 <camlorn> Lutin`: Hello again.
18:10:31 <dmwit> For your actual problem: perhaps "leftLength `seq` rightLength `seq` leftLength + rightLength + 1".
18:10:47 <camlorn> So the only fix is a tail-recursive algorithm, or understanding the fun with seq?
18:11:04 <dmwit> I'm not sure tail recursion is relevant here.
18:11:13 <dmwit> It generally isn't the property of interest in Haskell.
18:11:40 <mzero> well - I just pushed an annotation to your code
18:12:02 <mzero> you don't need the helper, and you don't need the parens around the arguments to calls
18:12:12 <mzero> and I think with bang patterns that'll work
18:12:16 <mzero> or you can use the seq version
18:12:40 <Cale> camlorn: you could do this: http://lpaste.net/106889
18:13:51 <kvanb> if i use a blocking stm operation like readTChan but then I use orElse (which is <|>) on other blocking operations
18:13:52 <Cale> The ! causes it to evaluate n as if there were a pattern to match
18:14:10 <kvanb> does it block on all the ones I queue up, like foo, bar, qux in (foo <|> bar <|> qux)
18:14:14 <kvanb> or does it block on foo.
18:14:23 <camlorn> What is size' Tip !n ?
18:14:51 <Cale> camlorn: Well, I just explained what the ! does
18:15:01 <camlorn> O. Wait. Heh. I missed the where.
18:15:07 <Cale> ah
18:15:14 <camlorn> I was trying to figure out what the crazy pattern was.
18:15:18 <camlorn> And it's not. So.
18:15:26 <pavonia> "treeLengthHelper(r)" is a strange notation
18:15:40 <dmwit> kvanb: The first one that can make progress will; if none can, it will block until one of them is written to.
18:15:55 <kvanb> excellent, thanks!
18:16:23 <camlorn> Okay, I think I see.
18:17:36 <gamegoblin> :t unsafeCoerce $ unsafePerformIO $ randomIO
18:17:37 <lambdabot> Not in scope: ‘unsafeCoerce’
18:17:37 <lambdabot> Not in scope: ‘unsafePerformIO’
18:18:33 <Cale> camlorn: see also my annotation: http://lpaste.net/106889
18:19:00 <Lutin`> Shouldn't you be able to do this in O(n) space where n is the depth of the tree?
18:19:28 <Cale> Lutin`: All these solutions will use that much space
18:19:47 <Lutin`> It's using more than that for me
18:19:54 <Cale> hmm
18:20:37 <Lutin`> Yeah I'm not sure why either
18:20:39 <Cale> How are you measuring the space usage?
18:20:43 <Lutin`> Let me try with optimizations
18:20:52 <Lutin`> Was measuring ghci space usage lol
18:21:09 <camlorn> I'm assuming id returns its argument?
18:21:13 <Cale> camlorn: yeah
18:21:18 <Cale> id x = x
18:21:20 <qtest> is there a generalization of uncurry that would allow me to apply a function to a tuple of multiple arguments?
18:21:22 <Cale> It's the identity function
18:21:36 <qtest> e.g., apply a three-argument function to (1,2,3)
18:21:43 <Cale> camlorn: That thing I did in flatten is a standard trick when you want to concatenate lots of lists
18:22:00 <qtest> not ((1,2),3)
18:22:01 <Cale> camlorn: Instead of [], you use id, instead of [x], you use (x:), and instead of (++) you use (.)
18:22:18 <camlorn> Cale:That's interesting.  I'll get how it works in about 5 minutes.
18:22:28 <Cale> Since (.) is constant time, this can reduce asymptotic complexity, and you end up with a function that you can apply to an empty list to obtain the list you wanted.
18:22:48 <Cale> i.e. instead of working with lists directly, you work with functions that add a bunch of elements to some list that they're given
18:23:13 <camlorn> It feels like a cons is missing.
18:23:30 <Lutin`> Cale: Ah yeah works fine with optimizations
18:23:50 <camlorn> Agh. I see.
18:24:27 <camlorn> flatten' l is a partially applied function expecting a list, so we give it one. And we only need one.
18:24:27 <pavonia> qtest: The tuple package has such functions
18:25:11 <Cale> camlorn: Yeah, flatten' t is the function which adds the elements of t to some list that it's given, so we give it the empty list to add them to
18:25:42 <camlorn> Cale: This is actively twisting my idea of programing. that was kind of the point, I suppose, but even so.
18:26:45 <Cale> I suppose it's important to mention that xs ++ ys takes O(length xs) steps to evaluate
18:27:24 <Cale> which is why we're doing this, to avoid the quadratic complexity that would come from leftward-leaning trees if we used (++) directly
18:31:37 <camlorn> Cale: I know about the evils fo long lists on teh left of ++.
18:31:55 <camlorn> Cale: I was in another window, patching in the strict pattern to see what I could see.
18:32:41 <Lutin`> Hmm
18:33:07 <camlorn> In the first version, why is n only strict in the first pattern?
18:37:33 <Lutin`> In this case GHC's strictness analyzer actually makes that bang pattern unnecessary
18:40:20 <camlorn> Cale: Actually, I'm starting to think that the problem with mine might possibly have also been unbalanced trees.
18:40:38 <Cale> Lutin`: Yeah, it's pretty good about things like that
18:40:55 <camlorn> Cale: When I use the bigTree function rather than my make a list of random numbers method, it works for the same number of nodes, or so it seems.
18:41:04 <tb01110100> :q
18:41:05 <Cale> camlorn: The reason I only put one ! is because that's enough to make it force the expression
18:41:06 <tb01110100> dammit
18:41:08 <Lutin`> lol
18:41:12 <Lutin`> tb01110100: I know that feel
18:41:24 <Lutin`> I do it in my terminal way too often
18:42:14 <Lutin`> camlorn: If you did it in the other pattern it would force the evaluation of the size of the right subtree
18:43:15 <camlorn> Lutin`: So what, doing it in the first one forces it at every Tip?
18:43:30 <Lutin`> Yep
18:45:31 <qtest> what is the recommended way of handling an argument error?
18:45:49 <camlorn> Wait. Okay. So when we return acc, what. We may not be returning a value, but a stack of thuncks?
18:46:25 <Lutin`> camlorn: Yep, you could be returning (((1+1)+1)+1)
18:46:43 <Cale> camlorn: Instead of thinking down at the level of thunks, I usually find it a bit more comfortable to think in terms of expressions (thunks are just a particular way to represent unevaluated expressions at runtime)
18:47:02 <Lutin`> But GHC's strictness analysis will normally pick up on things like that
18:47:07 <Lutin`> And go ahead and make it strict
18:47:16 <Cale> camlorn: When you pass some expression as an argument to a function, if that function doesn't pattern match on the argument, then it may remain unevaluated.
18:47:38 <Cale> camlorn: (Remember that lazy evaluation is outermost-first)
18:47:53 <qtest> I think my tic-tac-toe thing should be a monad
18:48:02 <qtest> so I can do move ...; move ...; move etc.
18:48:28 <Cale> camlorn: At some level (after a bunch of desugaring into a core language), the only reason that anything is ever evaluated is because some case expression wants to pattern match on it
18:48:55 <camlorn> Cale: I think I'm headed in the direction of at least looking at that.
18:49:22 <kazagistar> its generally better in my mind to not rely on strictenss analysis or optimizations I cannot guarentee or document
18:49:43 <camlorn> Cale: I'm following, somewhat, but wasn't expecting to deal with this so soon. Ah the fun of toy benchmark/learning programs.
18:49:48 <kazagistar> Cale: isn't seq not that, and just some magic?
18:50:33 <benzrf> :t seq
18:50:34 <lambdabot> a -> b -> b
18:50:44 <benzrf> :t curry snd
18:50:45 <lambdabot> a -> c -> c
18:50:50 <benzrf> totally the same B)
18:50:54 <dolio> Lutin`: I think you trust GHC's strictness analysis too much. :)
18:50:58 <benzrf> qtest: isit monadic?
18:51:05 <jle`> :t flip const
18:51:05 <benzrf> qtest: is it a monad?
18:51:05 <lambdabot> b -> c -> c
18:51:28 <camlorn> Yeah, i'm with Lutin`, if only because this hit me way earlier than it should have.
18:51:37 <meretrix> If I have "data Data = Data1{..} | Data2{..} | Data3{..}", is it possible to create a non-partial function that only operates on Data3{..} as if Data3 were a type?
18:52:23 <camlorn> O, wait.
18:52:46 <camlorn> I think I just mentally crosswired who is on which side of that statement.
18:52:54 <benzrf> meretrix: no
18:52:58 <Cale> kazagistar: Well, yeah, I suppose, because it can operate on functions, and perhaps the case expressions in core can't.
18:52:58 <jle`> :t const id
18:52:59 <lambdabot> b -> a -> a
18:53:00 <benzrf> that's what types are for
18:53:03 <Cale> (I'm not actually sure)
18:53:15 <benzrf> meretrix: this is probably an xy problem
18:53:17 <benzrf> what are you doing
18:54:01 <jle`> meretrix: depending on what you want, you might be able to "map over" Data3 with a function, and hat'd be okay...leaving the Data1 and Data2 scenarios unchanged
18:54:07 <meretrix> benzrf: I am trying to write functions that convert a library type with many constructors to my own types.
18:54:15 <jle`> but Data3 wouldn't be a type
18:54:33 <jle`> meretrix: you can "lift" a function on a Data3 to a Data
18:54:46 <jle`> data MyData3 = MyData3{..}
18:54:59 <jle`> toData :: (MyData3 -> MyData3) -> (Data -> Data)
18:55:07 <jle`> ...well, depending on what your situatio is
18:55:22 * hackagebot eros-client 0.5.0.0 - A command-line interface to the eros library.  http://hackage.haskell.org/package/eros-client-0.5.0.0 (pharpend)
18:56:22 <jle`> you might also look at Prisms from Lens, which can be thought of as a general solution to this problem
18:56:38 <qtest> benzrf: I don't know
18:56:53 <camlorn> Well, I'm done for now. Almost 8 hours is enough, I think.  Thanks for the help, everyone.
18:57:29 <benzrf> qtest: is it a Functor/
18:57:39 <benzrf> if it's not a Functor, it's definitely not a Monad
18:57:47 <benzrf> if it is a Functor, it might be a Monad
18:59:48 <extraplanetary> qtest: also consider Monoid if you want something do-like
19:02:04 <qtest> benzrf: ok, I don't think it's a functor
19:02:12 <benzrf> then it's not a Monad
19:02:15 <benzrf> sorry
19:02:20 <benzrf> it may be a monoid
19:02:27 <l0cust> How do I go about marking a package deprecated?
19:02:36 <l0cust> (one of my own packages)
19:02:37 <qtest> I just want to have a pipeline of transformations
19:03:07 <qtest> each move takes in a game state and creates a new game state
19:03:30 <extraplanetary> @hoogle Endo
19:03:32 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
19:03:32 <lambdabot> Data.Monoid newtype Endo a
19:03:32 <lambdabot> System.Posix.Terminal.ByteString EndOfFile :: ControlCharacter
19:05:38 <benzrf> endo ffile
19:07:14 <apples> qtest, you may be interested in free monads, where you could represent tic tac toe with something like data Game a = Move Who Where a | End
19:08:20 <Lutin`> dolio: I trust its strictness analysis with regards to left associative Integer addition ;)
19:09:18 <benzrf> apples: still not a monad!
19:09:25 <benzrf> or at least
19:09:28 <benzrf>  a very artificial monad
19:09:32 <benzrf> just stick with (<>)
19:09:38 <benzrf> its not so bad
19:09:45 <apples> benzrf, it's a functor, which can then be turned into a free monad
19:09:57 <benzrf> well its a very artificial functor
19:09:59 <benzrf> i rest my case
19:10:23 * hackagebot txtblk 0.2.0.1 - Deprecated in favor of eros.  http://hackage.haskell.org/package/txtblk-0.2.0.1 (pharpend)
19:10:27 <apples> this is how you normally construct DSLs with free monads though :S
19:10:48 <benzrf> maybe if you have something monadic
19:10:51 <extraplanetary> the next step here is to use an indexed monad to alternate turns in a type-safe way
19:11:22 <joelteon> can I not 'cabal freeze' with --enable-tests?
19:13:48 <benzrf> apples: i thought free monads were for modelling things which are actually monadic without any specific implementation?
19:14:01 <benzrf> not for turning nonmonadic things into monads for abusing do-notation
19:15:24 * hackagebot eros 0.5.1.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.5.1.0 (pharpend)
19:15:30 <apples> benzrf, the first example with Toy at http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html is done in a similar fashion
19:15:56 <Lutin`> Not the same due to `Output b next`
19:17:09 <apples> Lutin`, why does that matter?
19:17:29 <apples> b is fixed when it's made into a Functor
19:17:33 <Lutin`> Eh yeah
19:18:35 <benzrf> apples: yes, but thats a monadic structure already
19:18:39 <dolio> Lutin`: If you use Integer, GHC will fail you.
19:18:42 <Lutin`> Actually seems about the same
19:18:44 <benzrf> just with an abstract implementation
19:19:00 <benzrf> tictactoe moves are not monadic afaict
19:19:11 <Lutin`> dolio: Oh whoops, meant Int
19:19:16 <benzrf> wait what
19:19:17 <Lutin`> my fingers just kept going
19:19:20 <benzrf> this seems like an abuse :[
19:19:23 <apples> you can represent tic tac toe as a DSL though
19:19:33 <dolio> Yeah, it handles Int okay.
19:19:36 <benzrf> thats an abuse of do-notation >:[
19:19:44 <benzrf> just make it a monoid and use (<>)
19:21:22 <apples> i guess i'm not really getting the distinction you're making, it seems perfectly fine to me
19:21:41 <benzrf> :[
19:21:48 <benzrf> tic tac toe moves are not naturally functors
19:21:56 <Welkin> benzrf is comparing apples to oranges
19:22:13 <benzrf> >:o
19:23:30 <apples> do you think that a tic tac toe move can be modeled as an effect on some implicit game state?
19:25:46 <benzrf> monads != effects
19:26:00 <benzrf> tic tac toe moves are not functors
19:26:02 <benzrf> or rather
19:26:06 <benzrf> tic tac toe move is not a functor
19:26:19 <apples> okay, well, if you don't want to use free monads, that's your preference i guess
19:28:12 <zRecursive> Is there any real free things in the world ?
19:28:29 <qtest> look, I just want something that would let me write "start | move X 2 2 | move O 1 1" instead of "move (move (start) X 2 2) O 1 1"
19:29:05 <Welkin> use monads
19:29:15 <Welkin> and bind the calls together
19:29:42 <pqmodn_> or function composition: move X 2 2 . move O 1 1 $ start
19:29:44 <extraplanetary> qtest: move your state parameter to the final position and write `move O 1 1 . move X 2 2 . start`
19:30:50 <qtest> extraplanetary: no, I want things in left to right order
19:30:58 <jmcarthur> benzrf: free monads are for abusing do notation no more than putting items into lists are for abusing list syntax
19:31:04 <qtest> I think I can use a monad
19:31:23 <jmcarthur> benzrf: but just as much, actually
19:31:46 <qtest> I think I understand monads, finally
19:32:02 <jmcarthur> qtest: you probably don't, but it also doesn't matter
19:32:06 <jmcarthur> :)
19:32:22 <zRecursive> :t seq
19:32:23 <lambdabot> a -> b -> b
19:32:35 <jmcarthur> when once actually understands monads, it's more of a "neato" moment than anything truly insightful and groundbreaking
19:32:46 <pqmodn_> there's rarely a "finally" when it comes to understanding. you can always refine and deepen your understanding of monads
19:32:53 <pqmodn_> or, of anything
19:32:53 <jmcarthur> that is true
19:33:17 <kvanb> the better you understand monads, the less you will feel the need to write new ones.
19:33:19 <extraplanetary> qtest: there's also `Control.Category.>>>`, which is `flip (.)`
19:33:37 <jmcarthur> kvanb: well, or at least the less special you will feel it is when you make one
19:34:06 <kvanb> indeed, as there will most certainly be an equivalent transformer stack that's probably better :)
19:34:16 <jmcarthur> eh
19:34:31 <jmcarthur> transformers stacks are one of those things i have pretty much moved away from
19:34:40 <kvanb> they're not so bad with mtl
19:34:54 <jmcarthur> no, i just think they encourage a bad way of thinking
19:35:22 <possiblywrong> anyone know much about encoding infinite types? and could give me a few pointers. Basic idea => https://gist.github.com/possiblywrong/a54f1ef4cb79dc70d466
19:35:29 <jmcarthur> that so many things should be considered as effects at all
19:35:32 <apples> jmcarthur, what have you moved towards? curious
19:36:03 <jmcarthur> apples: nothing! or at least nothing i can put my finger on and name
19:36:09 <apples> ah
19:36:51 <jmcarthur> i just write code. maybe every once in a while an mtl-style transformer will make sense, but usually i think it's just noise introduced by some misguided notion that everything is an effect
19:37:33 <benzrf> qtest: make it a monoid
19:37:36 <qtest> jmcarthur: my understanding of monads is neither insightful nor neato
19:37:49 <jmcarthur> qtest: maybe you actually understand it then ;)
19:37:50 <benzrf> jmcarthur: uyes, i have nothing against free monads
19:37:59 <benzrf> i have something against using free monads as part of abusing do-notation
19:38:11 <qtest> it's "this is the structure, and the semantics are completely arbitrary"
19:38:12 <benzrf> qtest: monoids, man! monoids!
19:38:36 <jmcarthur> benzrf: applying Free to some functor doesn't just give you do notation. it actually produces something that means something a bit different from the functor.
19:38:41 <benzrf> yes, i know
19:38:45 <benzrf> but tic tac toe isnt a functor
19:38:47 <benzrf> is my point
19:38:51 <jmcarthur> ah, sure
19:39:01 <jmcarthur> a lot of people use Free the way i see a lot of people using mtl
19:39:05 <jmcarthur> arbitrarily
19:39:06 <benzrf> oh?
19:39:08 <benzrf> lol
19:39:22 <jmcarthur> qtest: i wouldn't really say that
19:39:49 <jmcarthur> qtest: monads have something (simple) to say about semantics (the laws)
19:40:47 <jmcarthur> and in fact i think those laws are more important than the types necessary just to express them. the real point is the laws.
19:41:08 <jmcarthur> in kind of a boring way
19:42:05 <jmcarthur> if the laws didn't matter, this would be a monad:     data Monad a where Return :: a -> Monad a; Bind :: Monad a -> (a -> Monad b) -> Monad b
19:42:37 <jmcarthur> but that doesn't actually satisfy *any* of the laws (if the structure is observable)
19:42:55 <qtest> the laws are structure to me
19:43:16 <pqmodn_> the types are compiler-checked laws. eg, one law of monoids is M * M is an element in M, which can be expressed as a type
19:43:53 <jmcarthur> pqmodn_: i think of that as being more like syntax. "I have the ability to construct an M from two other Ms"
19:44:13 <jmcarthur> it can, in fact, be written as a grammar
19:45:25 <qtest> benzrf: I don't really have any use for an identity element, though
19:46:21 <jmcarthur> benzrf: the thing i don't like about a lot of uses of Free is that they emphasize syntax over semantics
19:46:51 <jmcarthur> benzrf: i think that is what you are trying to say, too
19:46:51 <benzrf> qtest: then make a custom operator
19:46:56 <benzrf> you dont need a fancy type class
19:47:16 <jmcarthur> qtest: are you talking about monads or monoids here?
19:47:28 <benzrf> qtest: how are yo~u representing moves atm
19:47:37 <qtest> jmcarthur: monoids
19:47:46 <jmcarthur> qtest: because if you want something like a monoid but without an identity, there's always Semigroup (in some edwardk package somewhere)
19:48:19 <qtest> benzrf: functions
19:48:29 <pqmodn_> if you represent moves as a function from Board -> Board, the identity element is just "id". mappend is function composition
19:48:29 <benzrf> qtest: from board to board?
19:48:31 <jmcarthur> qtest: there's also something like a Monad but without return. i think edwardk just calls it Bind or something boring like that
19:48:44 <benzrf> no need for that though
19:48:53 <benzrf> qtest: if you use Endo, you already have a monoid
19:49:06 <benzrf> or you can just use .
19:49:07 <jmcarthur> a category, even! :D
19:49:29 <benzrf> qtest: simple
19:49:33 <jmcarthur> (more generally)
19:49:34 <benzrf> make the board the *last* argument
19:49:45 <pqmodn_> start :: Board
19:49:58 <qtest> that has already been suggested
19:50:01 <benzrf> qtest: then you can say 'move X 0 1 >>> move O 0 2'
19:50:02 <benzrf> etc
19:50:11 <benzrf> qtest: and?
19:50:29 <qtest> yes, I was looking at https://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Category.html
19:50:38 <benzrf> qtest: you dont even need Category
19:50:47 <benzrf> KISS
19:51:01 <qtest> I was told >>> is in category
19:51:04 <benzrf> if you wanna keep it super simple you could even just do something like
19:51:29 <benzrf> (|>) = flip (.)
19:51:31 <benzrf> no need for imports
19:51:35 <benzrf> then you can compose with
19:51:43 <benzrf> move X 0 1 |> move O 0 2
19:52:44 <qtest> I was about to say
19:52:59 <jmcarthur> ugh, |> is terrible
19:53:02 <qtest> there doesn't seem to be any value whatsoever in using any of these libraries and type classes
19:53:10 <jmcarthur> why would you give up the elegance of mere function composition?
19:53:18 <jmcarthur> (|>) is not flip (.)
19:53:27 <jmcarthur> at least not the one i'm used to...
19:53:38 <jmcarthur> it's flip ($), isn't it?
19:53:50 <jmcarthur> oh, you just mean defining that
19:53:59 <benzrf> :t (|>)
19:54:00 <jmcarthur> in F# and OCaml land, it's basically flip ($)
19:54:00 <lambdabot> Snoc s s a a => s -> a -> s
19:54:02 <benzrf> oh
19:54:05 <benzrf> did not know
19:54:14 <benzrf> yea i think ive seen that
19:54:19 <benzrf> i was just picking a random arrow-y operator
19:54:32 <benzrf> > 1 |> [1, 2, 3]
19:54:32 <qtest> is there anything at all that just maps to the very simple and basic and useful concept of applying actions in order?
19:54:33 <lambdabot>  No instance for (GHC.Show.Show a0)
19:54:34 <lambdabot>    arising from a use of ‘M578425592058839956531879.show_M5784255920588399565...
19:54:34 <lambdabot>  The type variable ‘a0’ is ambiguous
19:54:34 <lambdabot>  Note: there are several potential instances:
19:54:34 <lambdabot>    instance [safe] GHC.Show.Show
19:54:42 <benzrf> qtest: a list
19:54:44 <benzrf> or composition
19:54:45 <jmcarthur> qtest: []
19:54:53 <benzrf> qtest: composition
19:55:00 <benzrf> that is literally composition
19:55:11 <benzrf> monads are for when you need kleisli composition
19:55:15 <benzrf> but you only need regular composition
19:55:25 <jmcarthur> categories are all about sequencing. so are monoids. so are monads.
19:56:14 <qtest> why do monads use >>= and >>?
19:56:25 <benzrf> qtest: you mean those character sequences?
19:56:29 <qtest> I mean
19:56:34 <qtest> give me a second
19:56:39 <jmcarthur> because of hysterical raisins, really.
19:56:44 <jmcarthur> :t (<=<)
19:56:45 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:56:54 <jmcarthur> :t (>=>)
19:56:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:56:58 <jmcarthur> so nice!
19:57:00 <benzrf> fishy
19:57:18 * benzrf drops some (,) in the water for (>=>)
19:57:24 <qtest> instead of writing putStr "hello" >> putStr "world", why isn't it putStr "world" << putStr "hello"?
19:57:35 <benzrf> qtest: because of how people think
19:57:45 <qtest> right!
19:58:00 <qtest> which is why I don't want to put my moves in the opposite order just so I can use .
19:58:05 <benzrf> yeshuah:
19:58:07 <benzrf> *ues
19:58:09 <benzrf> ****yes
19:58:13 <qtest> so I guess flipping it was the right solution all along
19:58:16 <benzrf> so define some operator that's flip (.)
19:58:20 <jmcarthur> not only is there no (<<) to be the opposite of (>>), but there's (<*) to be the opposite of (*>) (which is the same as (>>)) but doesn't behave the way you just suggested ;)
19:58:21 <qtest> yeah
19:58:21 * benzrf whacks qtest with a stick
19:58:45 <qtest> but then someone who needs the same thing will use a different operator
19:58:49 <benzrf> so why *ISN'T* there a (<<) defined like (<*) but for Monad
19:59:05 <jmcarthur> i think because people would be too confused about what it does
19:59:18 <jmcarthur> i think the (<*) behavior makes more sense, really
19:59:18 <benzrf> i hate backward compatability
19:59:20 <benzrf> ugh
19:59:57 <jmcarthur> "still do the action in the same order, but return the result from the first one instead of the second one"
20:00:13 <qtest> this seems like a thing that should be in the libraries just to avoid ending up with twenty different symbols for the same thing
20:00:25 <jmcarthur> i think people put too much emphasis on syntax
20:00:29 <jmcarthur> it's really not so important
20:00:45 <jmcarthur> there are just better things to do with your life :)
20:00:54 <jle`> benzrf: it's not clear whether or not (<<) should be (<*) for flip (>>)
20:01:02 <benzrf> bah!
20:01:08 <benzrf> qtest: there's (>>>)
20:01:09 <jle`> oh it has already been said
20:01:26 <benzrf> and (->) has a Category instance
20:01:35 <benzrf> but youll get slightly more confusing type errors
20:01:38 <benzrf> :u
20:01:44 <jle`> qtest: you can do =<< to do that
20:01:47 <qtest> benzrf: do you mean I should use (>>>) as my symbol, or should I use the one from Category, after defining an instance?
20:01:56 <benzrf> qtest: there's already an instance
20:01:56 <qtest> oh, there is already an instance
20:02:04 <benzrf> > ((+1) >>> (*2)) 3
20:02:06 <lambdabot>  8
20:02:12 <koala_man> I just spent hours trying to parallelize a program just to discover that the virtual host is limited to less than one physical core, so it provides absolutely no speedup
20:02:17 <jle`> qtest: const (putStrLn "world") =<< putStrLn "hello"
20:02:19 <benzrf> koala_man: :{
20:02:21 <jmcarthur> i would just use (.). due to laziness, it *still* makes sense, usually, to think of evaluation as proceeding from left to right
20:02:40 <jle`> yeah, in haskell, if you chain using (.), evaluation is "driven" left to right
20:03:05 <jle`> take 10 . filter even . map (+1) $ [1..]
20:03:16 <jle`> to "start" calculating that, haskell asks take 10 what it needs
20:03:22 <jmcarthur> guess what runs first!
20:03:30 <jmcarthur> ($) is first
20:03:32 <jmcarthur> boring
20:03:33 <jle`> take 10 says it needs the first item by filter even
20:03:35 <jle`> jmcarthur: ok :P
20:03:46 <jle`> (take 10 . filter even . map (+1)) [1..]
20:03:48 <jle`> :D
20:03:53 <jmcarthur> then the leftmost (.)
20:04:11 <qtest> oh, I forgot
20:04:12 <jmcarthur> :P
20:04:15 <jle`> :P
20:04:16 <qtest> I still need a monad after all
20:04:19 <qtest> or something like that
20:04:30 <jmcarthur> you never need monads (or categories or monoids or anything like that)
20:04:30 <qtest> since I need to handle the situation where a move is illegal
20:04:33 <jmcarthur> they are just nice sometimes
20:04:43 <jle`> conceptually you cna think of take 10 "acting" first...haskell asks take 10 what it needs; it needs filter even
20:04:47 <qtest> ok, let's put it this way
20:04:50 <jle`> filter even says it needs the first result of map (+1)
20:04:55 <jle`> and map (+1) says it needs the first result of [1..]
20:05:04 <jle`> so the "boss"/the "chain" of evaluation begins at take 10
20:05:12 <qtest> if I use composition, I need each function to handle the Error case and pass it through
20:05:14 <jmcarthur> or, rather, you never need to explicitly think of the thing you are doing as monadic
20:05:22 <jmcarthur> (it may nonetheless form a monad somehow)
20:06:18 <pqmodn_> qtest: you could either make moves return the unchanged Board, or return Maybe Board where Nothing indicates the move was illegal. in that case, you can chain moves together using the Maybe monad
20:07:07 <qtest> yes, but I want to give the cause of the (first) failure, too
20:07:11 <qtest> but Either is not a monad, is it?
20:07:17 <jmcarthur> Either is a monad
20:07:29 <jmcarthur> > Left "foo" >> Right 5
20:07:29 <qtest> oh, then I'll just use Either
20:07:30 <lambdabot>  Left "foo"
20:07:41 <jle`> > Right 5 >> Right 6
20:07:42 <lambdabot>  Right 6
20:07:52 <jle`> >> Right 4 >> Left "foo" >> Right 6
20:07:58 <jle`> > Right 4 >> Left "foo" >> Right 6
20:08:00 <lambdabot>  Left "foo"
20:08:26 <pqmodn_> > Right 5 >>= return . (+1)
20:08:27 <lambdabot>  Right 6
20:09:04 <benzrf> qtest: Either Monadddd
20:09:16 <benzrf> pqmodn_: perhaps you mean
20:09:21 <benzrf> > fmap (+1) (Right 5)
20:09:23 <lambdabot>  Right 6
20:09:23 <jmcarthur> @check \a b c -> ((a :: Bool -> Either Bool Bool) >=> (b :: Bool -> Either Bool Bool)) >=> (c :: Bool -> Either Bool Bool)  ==  a >=> (b >=> c)
20:09:24 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool
20:09:25 <lambdabot>  -> Data.Either.Either GHC.Types.Bool GHC.Types.Bool’ with actual type ‘GHC.T...
20:09:27 <jmcarthur> fail
20:09:27 <benzrf> qtest: use (>=>)
20:09:30 <benzrf> :t (>=>)
20:09:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:09:39 <jmcarthur> @check \a b c -> (((a :: Bool -> Either Bool Bool) >=> (b :: Bool -> Either Bool Bool)) >=> (c :: Bool -> Either Bool Bool))  ==  (a >=> (b >=> c))
20:09:41 <qtest> benzrf: why not >>=?
20:09:41 <lambdabot>  No instance for (GHC.Classes.Eq
20:09:41 <lambdabot>  (GHC.Types.Bool -> Data.Either.Either GHC.Types.Bool GHC.Types.Bool)) arisin...
20:09:46 <jmcarthur> of course
20:09:47 <benzrf> qtest: (>>=) is point-ful
20:09:56 <jmcarthur> @check \a b c x -> (((a :: Bool -> Either Bool Bool) >=> (b :: Bool -> Either Bool Bool)) >=> (c :: Bool -> Either Bool Bool)) x  ==  (a >=> (b >=> c)) x
20:09:57 <lambdabot>  +++ OK, passed 100 tests.
20:10:01 <qtest> what
20:10:05 <benzrf> qtest: (>=>) is to (>>=) as (.) is to ($)
20:10:11 <qtest> hm
20:10:20 <qtest> but $ is better than .
20:10:25 <jmcarthur> no it's not!
20:10:26 <qtest> so I should use >>=
20:10:30 <jmcarthur> (.) is much better! :)
20:10:31 <benzrf> qtest: well, you want to compose, not apply
20:10:45 <jmcarthur> also the monad laws are nicer to express with (>=>) or (<=<)
20:10:51 <pqmodn_> benzrf: well, (>>= return . (+1)) :: Int -> Either e Int, where Int and (+1) stand for Board and some Board transformation
20:11:06 <jmcarthur> return <=< a = a    a <=< return = a   (a <=< b) <=< c = a <=< (b <=< c)
20:11:08 <benzrf> pqmodn_: you want fmap
20:11:20 <pqmodn_> benzrf: i don't want anything
20:11:28 <jmcarthur> note the similarity with (.) and id
20:11:40 <jmcarthur> or mappend and mempty
20:12:08 <benzrf> qtest: (>>=) is Kleisli application, (>=>) is Kleisli composition
20:12:10 <jle`> qtest: (.) is better than ($) :)
20:12:23 <qtest> Right start >>= move X 1 1 >>= move O 2 2
20:12:27 <qtest> I'm happy with this
20:12:32 <benzrf> qtest: yes
20:12:40 <benzrf> but what if you want to specify a series of moves without any board to start with
20:12:48 <benzrf> game = move X 1 1 >=> move O 2 2
20:12:59 <qtest> duly noted
20:13:01 <benzrf> Right start >>= game
20:13:26 <jmcarthur> return start. let's not overspecialize, if we're explicitly using Monad anyway!
20:13:48 <qtest> ok
20:13:50 <qtest> makes sense
20:14:00 <benzrf> jmcarthur: i was just echoing qtest's example :v
20:14:12 <benzrf> or actually
20:14:16 <benzrf> you could even do game start
20:14:21 * jmcarthur thinks    move 0 2 2 <=< move X 1 1 $ start    is pretty great
20:14:29 <benzrf> jmcarthur: fie
20:14:59 <benzrf> @let data Player = X | O
20:15:01 <lambdabot>  Defined.
20:15:18 <benzrf> @let type Board = [[Maybe Player]]
20:15:19 <lambdabot>  Defined.
20:16:21 <benzrf> hmmm
20:16:36 <benzrf> @hoogle Int -> a -> [a] -> [a]
20:16:37 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
20:16:38 <lambdabot> Data.IntMap.Strict findWithDefault :: a -> Key -> IntMap a -> a
20:16:38 <lambdabot> Data.IntMap.Lazy findWithDefault :: a -> Key -> IntMap a -> a
20:16:50 <benzrf> is there a []= equivalent in haskell :o
20:17:13 <qtest> is there a function that does the opposite of return?
20:17:21 <carter> unsafeCoerce
20:17:21 <benzrf> qtest: no, that's comonadic
20:17:24 <benzrf> qtest: why do you want that?
20:17:30 <benzrf> carter: -le eye roll-
20:17:40 <carter> oh
20:17:42 <carter> :t join
20:17:43 <lambdabot> Monad m => m (m a) -> m a
20:17:45 <pqmodn_> :t extract
20:17:46 <lambdabot> Not in scope: ‘extract’
20:17:55 <benzrf> Either is not Comonadic
20:18:01 <benzrf> :t set
20:18:02 <lambdabot> ASetter s t a b -> b -> s -> t
20:18:03 <carter> though if you get soemthing like IO IO a
20:18:05 <benzrf> meh
20:18:08 <carter> youshould wonder why you're a bad person
20:18:10 <carter> :)
20:18:27 <benzrf> :t (^=)
20:18:28 <lambdabot> (MonadState s m, Num a, Integral e) => ASetter' s a -> e -> m ()
20:18:53 <spaceships> looking for a good paper with examples of comonads
20:19:19 <benzrf> @let move p x y b | Nothing <- b !! x !! y = Right $ set (ix x . ix y) p b | otherwise = Left "Already played!"
20:19:20 <lambdabot>  Defined.
20:19:38 <benzrf> @let start = replicate 3 (replicate 3 Nothing)
20:19:40 <lambdabot>  Defined.
20:19:56 <benzrf> @let exampleGame = move X 1 1 >=> move O 2 2
20:19:57 <lambdabot>  .L.hs:166:20:
20:19:57 <lambdabot>      Couldn't match expected type ‘Maybe t’ with actual type ‘Player’
20:19:57 <lambdabot>      Relevant bindings include
20:19:57 <lambdabot>        exampleGame :: [[Maybe t]] -> Either [Char] [[Maybe t]]
20:19:57 <lambdabot>          (bound at .L.hs:166:1)
20:20:00 <benzrf> dang
20:20:02 <qtest> lol
20:20:06 <benzrf> :t X
20:20:07 <lambdabot> Player
20:20:09 <benzrf> ...
20:20:11 <benzrf> :t move
20:20:11 <qtest> want to see my program?
20:20:12 <lambdabot> Maybe t -> Int -> Int -> [[Maybe t]] -> Either [Char] [[Maybe t]]
20:20:17 <benzrf> shit i did it wrong
20:20:27 <benzrf> qtest: sure
20:20:35 <benzrf> qtest: lpaste it and i can import it
20:20:36 <benzrf> @undefine
20:20:36 <lambdabot> Undefined.
20:21:13 <qtest> http://lpaste.net/5936269853957554176
20:21:49 <benzrf> qtest: Cell is isomorphic to Maybe
20:22:01 <benzrf> but with fewer instances
20:22:08 <benzrf> ;)
20:22:28 <qtest> true
20:22:29 <benzrf> *to (Maybe Player)
20:22:33 <qtest> I'll use maybe
20:22:37 <benzrf> u dont need to
20:23:17 <benzrf> qtest: don't use fail!
20:23:25 <benzrf> fail is a terrible hack
20:23:28 <qtest> why
20:23:38 <qtest> what should I use?
20:23:40 <benzrf> it's 2generic
20:23:43 <benzrf> qtest: just use Left
20:23:57 <qtest> no, I like fail
20:24:05 <benzrf> you shouldnt like fail
20:24:17 <qtest> I was told to use return instead of Right
20:24:20 <benzrf> there could be a MonadFail class where i would be ok with it
20:24:28 <qtest> now I have to use Left instead of fail?
20:24:28 <benzrf> (MonadPlus is kind of like that)
20:24:38 <benzrf> qtest: there are times for genericism
20:24:41 <benzrf> fail is not one of TheMoonMaster
20:24:42 <benzrf> *them
20:24:52 <benzrf> qtest: btw, have you heard the good news about pattern guards
20:25:04 <benzrf> 1 sec let me show you
20:25:04 <TheMoonMaster> benzrf: wot
20:25:11 <benzrf> TheMoonMaster: them autocompletes to you
20:25:22 <TheMoonMaster> No way.
20:25:32 <qtest> I used to know pattern guards
20:25:33 <benzrf> :P
20:25:34 <qtest> but I forgot
20:26:04 <qtest> oh, actually it's something else from what I knew
20:26:11 <qtest> no, I never knew pattern guards
20:27:12 <benzrf> http://lpaste.net/106903
20:27:20 <benzrf> fyi, otherwise is True
20:27:29 <benzrf> you cant use it in case unless youre matching against booleans
20:27:32 <benzrf> use _ in a case
20:27:34 <benzrf> patterns, remember
20:28:18 <kvanb> to be honest, I dont see the hype over pattern synonyms
20:28:25 <kvanb> I think they will just be confusing/misfeatureful
20:28:44 <kvanb> kind of like operators not defined within typeclasses
20:29:02 <benzrf> operators not defined within typeclassing?
20:29:04 <benzrf> what do u mean
20:29:13 <kvanb> hasn't that ever annoyed you?
20:29:24 <benzrf> what kind of operator
20:29:31 <kvanb> It's like the worst thing when a package defines a ton of new operators that are not part of a typeclass
20:29:44 <kvanb> it's like "damnit. Now I have to go find out what these 15 symbols mean"
20:29:59 <benzrf> kvanb: ...
20:30:06 <benzrf> how is that somehow worse than ones IN a tyeclass
20:30:10 <coppro> ^
20:30:12 <benzrf> * typeclass
20:30:30 <kvanb> because a typeclass can be generalized for many things like it
20:30:53 <kvanb> so you learn it once, and you basically forever know what that symbol means in a given context
20:31:08 <benzrf> uh
20:31:16 <benzrf> i fail to see the distinction
20:31:28 <benzrf> you dont learn other operators once and know them
20:31:30 <benzrf> ?
20:32:05 <kvanb> what does <|> mean
20:32:21 <kazagistar> Alternative choice
20:32:39 <kvanb> so what does <-> mean
20:33:09 <kazagistar> no idea, never seen it
20:33:18 <kvanb> now wouldn't you be pissed if every package defined new operators that didn't correspond to something you've seen before
20:33:58 <kazagistar> ... did I walk into a argument about lens or something? cause I got no dog in that race
20:34:11 <kvanb> lol, don't worry. The argument fizzled.
20:34:12 <benzrf> kvanb: uh what
20:34:16 <benzrf> kvanb: that's nonsense
20:34:23 <benzrf> if a package defines a new typeclass that has an operator
20:34:25 <benzrf> that's ok
20:34:29 <benzrf> but if it's not in a typeclass
20:34:32 <benzrf> that's somehow different?
20:35:21 <benzrf> kvanb: what if (<->) *is* a typeclass operator
20:35:28 <benzrf> how is your previous argument suddenly invalid?
20:36:40 <kvanb> I lose.
20:37:01 <benzrf> \o/
20:37:31 <kazagistar> what I find annoying is when libraries use typeclass, but not the typeclass
20:38:11 <benzrf> ??
20:38:18 <kazagistar> like boxes using <> for horizontal concat
20:38:34 <kazagistar> just as a normal function
20:38:40 <kazagistar> Box -> Box -> Box
20:38:41 <benzrf> oh
20:38:42 <benzrf> that's pretty lame
20:39:01 <benzrf> yo qtest
20:39:04 <benzrf> @letlpaste 5936269853957554176
20:39:05 <lambdabot>  .L.hs:163:24:
20:39:05 <lambdabot>      Ambiguous occurrence ‘Result’
20:39:05 <lambdabot>      It could refer to either ‘L.Result’, defined at .L.hs:158:1
20:39:05 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Result’,
20:39:05 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
20:39:07 <Zekka> They just want you to qualify the names so you never forget how great their library is.
20:39:08 <benzrf> ooh
20:40:04 <heatsink> @check \f -> all f [1..10] ==> any f [1..10]
20:40:05 <lambdabot>  *** Gave up! Passed only 15 tests.
20:40:15 <kazagistar> Zekka: its an... ok library, just not one that is so useful in most cases
20:40:32 <Zekka> Think of it as source-code level product placement
20:40:41 <benzrf> (☞ﾟ∀ﾟ)☞
20:41:14 <rwbarton> to be fair boxes is much much older than <> as mappend
20:41:17 <kazagistar> paren bacon degrees forall degrees closeparen bacon
20:41:26 <benzrf> bacon?
20:41:34 <kazagistar> rwbarton: then I guess I take back my statement
20:41:39 <benzrf> thats a hand you boob
20:41:52 <kazagistar> pretttty sure its bacon
20:42:11 <kazagistar> or I have a shit font
20:43:17 <benzrf> your font blows
20:43:30 <benzrf> it's a pointing hand
20:43:38 <benzrf> like a sideways hovering-over-a-link cursor
20:44:29 <kazagistar> yeah, I pasted it somewhere else and blew it up
20:45:07 <benzrf> with some dynamite?
20:45:52 <kazagistar> apparently there IS a unicode bacon too, but my browser does not support it
20:45:55 <benzrf> huh
20:46:08 <benzrf> i generally use that emote as a sort of patronizing "LOL THATS FUNNY"
20:46:30 <benzrf> cuz im a dick
20:51:05 <Qfwfq> kvanb, benzrf: The 'metric' package defines (<->) as part of the Metric typeclass. "Distance."
20:52:17 <benzrf> cool
20:52:27 <benzrf> thats an Intuitive Operator right there
20:52:52 <kazagistar> heh, well, better then most
21:07:13 <johnw> edwardk: ping
21:07:24 * lispy waves
21:07:29 <johnw> heya lispy!
21:09:11 <lispy> does it make sense to have both cereal and binary these days?
21:09:19 <johnw> I wonder that too
21:09:20 <lispy> They have the same features, right?
21:09:28 <johnw> and edwardk has abstracted them in his bytes package
21:10:15 <lispy> As in, use bytes and then it doesn't matter if its cereal or binary under the hood?
21:10:20 <johnw> yeah
21:10:36 <lispy> Can that be used to give a migration path?
21:10:57 <lispy> (or is it just plain easier to switch to the other one?)
21:11:07 <johnw> I haven't used it yet
21:11:10 <johnw> but I'd like to
21:11:51 <lispy> I tend to use cereal because the maintainer sits next to me at work
21:12:03 <johnw> yeah, that can help
21:12:11 <lispy> I told him I was using it for something over the weekend and it he said, "Should I deprecate cereal?"
21:12:35 <lispy> so now I think I should switch my code to binary :)
21:13:06 <bms1> I actually recently switched from binary to cereal for a project...
21:13:13 <bms1> Cereal has proper parsing of IEEE floats
21:13:37 <lispy> bms1: ah, okay. I can pass that along.
21:14:50 <johnw> and cereal works really nicely with conduit
21:15:03 <johnw> it makes streaming objects across the wire almost trivial
21:15:19 <johnw> lispy: hey, I finally prove those applicative laws
21:23:09 <matt1> Hi, everyone. I'm trying to use Parsec to parse some numbers and I've run into a "No instance for" error
21:23:13 <matt1> here's the code:
21:23:18 <matt1> https://gist.githubusercontent.com/mr/f3612ee1445214cf186d/raw/a9591c47499eda377ee3bb0dae3459866d97fca5/parse.hs
21:23:47 <matt1> anyone know what I'm doing wrong? I'm a bit new to haskell, so I don't quite understand the error
21:23:57 <johnw> you can't combine digit <|> oneOf "..."
21:24:16 <johnw> that causes Num a to conflict with String
21:24:25 <johnw> (since there is no Num String)
21:24:54 <matt1> ah that explains what (Num String) means
21:25:28 <matt1> now let me think a moment because I'm sure I'll have another question in a second
21:25:47 <Cale> matt1: Yeah, Num is a typeclass that defines basic operations on numbers like (+) and (*) as well as a way to interpret integer literals called fromInteger
21:26:24 <matt1> thanks eveyone
21:26:35 <Cale> matt1: Any type could conceivably be made an instance of that class, but obviously it only really makes sense for some types, and String isn't one of those :)
21:27:20 <matt1> what would be a better option: replacing 'digit' with 'oneOf "1234567890"', or something else I've not thought of
21:27:49 <matt1> or some digit that returns a string
21:27:52 <matt1> if that exists
21:28:10 <Polytope> I want to use the Haskell package HaTeX to parse LaTeX, but I'm completely new to Haskell. I just need a program that reads LaTeX code from stdin and writes the abstract syntax tree to stdout. Can anyone help?
21:28:31 <Cale> :t digit
21:28:32 <lambdabot> Not in scope: ‘digit’
21:28:34 <Cale> er, right :)
21:28:44 <Cale> matt1: I'm pretty sure digit really is a Parser Char
21:29:03 <Cale> matt1: The problem is that show x is definitely a String, but  fst . head . readOct $ x  isn't
21:29:12 <platz> Polytope: start here http://learnyouahaskell.com/chapters
21:29:21 <Cale> matt1: Perhaps you wanted  read x ?
21:29:33 <Cale> matt1: But then parsePrefix wouldn't be a Parser String
21:30:38 <matt1> Cale: why isn't fst . head . readOct $ x necessarily a string?
21:30:50 <Cale> matt1: Well, it's some type of number
21:31:01 <matt1> Cale: oohhhhh
21:31:05 <matt1> Cale: duh
21:31:18 <Polytope> platz, I did start there, but I'm hoping that there is a solution that doesn't involve learning the entire language, since the rest of my code is in JavaScript.
21:32:40 <matt1> Cale: if I add 'show . ' in front of the whole thing it works, but that seems a bit round-a-bout
21:33:08 <Cale> matt1: Yeah, you're parsing the thing as a number and then turning it back into a String and then reading that again :P
21:33:54 <platz> Polytope: you might find more specific information to your use case here http://book.realworldhaskell.org/read/
21:34:16 <matt1> Cale: yeah I might have to think this through a little more
21:34:27 <matt1> Cale: thanks though!
21:35:07 <platz> Polytope: but generally Haskell isn't a language that is as forgiving of shortcuts to understanding as javascript
21:36:58 <Cale> Polytope: I don't know about LaTeX parsers, but there's Pandoc, which I think *might* be able to parse LaTeX, and it's written in Haskell
21:37:06 <Cale> Let me have a look
21:37:48 <kazagistar> pandoc does latex
21:38:02 <dfeuer> Oh my. Parsing LaTeX would involve parsing TeX, no?
21:38:08 <Cale> http://hackage.haskell.org/package/pandoc-1.12.4.2/docs/Text-Pandoc-Readers-LaTeX.html -- yeah, it can, though I think it parses it just enough to generate its internal representation, so it might not be what you're looking for.
21:38:23 <dfeuer> And I'm not sure TeX can actually be parsed, per se.
21:40:09 <kazagistar> pandoc is one of those tools that doesn't care about "theoretically unparsable" or whatever
21:40:23 <lispy> johnw: congrats!
21:41:07 <kazagistar> perl parsing is not decidable, but that doesn't stop them
21:41:15 <lispy> pandoc isn't a true latex parser
21:41:17 <dfeuer> kazagistar, I don't know the theory, and I'm not sure about the practice, but my impression of TeX's macro system from reading significant amounts of the TeXbook years ago was that it's very, very wild.
21:41:31 <Polytope> I was trying to use a parser written in JavaScript, but it was useless. It saw \begin{center}{\huge Hi!} and it thought that {\huge Hi!} was the second argument to \begin
21:41:41 <dfeuer> More like C preprocessor than like syntax-case.
21:41:51 <dfeuer> But I could be wrong.
21:42:15 <lispy> hevea is the closest I've seen to a reimplementation of latex
21:42:25 <benzrf> bye
21:42:42 <Polytope> but I'm off topic. I'll check out pandoc.
21:42:46 <kazagistar> Polytope: on one hand, haskell is one of the better languages for writing parsers and has awesome libraries for it... on the other hand, properly parsing tex might not be possible :P
21:43:37 <Cale> Polytope: You can see Pandoc's LaTeX parser here: http://hackage.haskell.org/package/pandoc-1.12.4.2/docs/src/Text-Pandoc-Readers-LaTeX.html#readLaTeX
21:43:58 <Cale> Polytope: It's pretty hacky with lots of special cases, looking for the things it knows how to represent.
21:45:15 <xpika> is it possible to have instance MyClass ([[a]]) ?
21:45:32 <lispy> I think with flexible instances
21:45:38 <Polytope> that's a good sign. the grammar for the javascript parser was fairly simple. simple = wrong.
21:45:59 <Cale> Polytope: Well, this is also wrong, but it might be a bit better.
21:46:08 <lfairy> xpika: if it doesn't overlap with anything else, then flexible instances yeah
21:46:17 <lispy> Polytope: what do you want the latex parser for?
21:46:30 <lispy> Polytope: hevea is in ocaml and their latex parser is very good
21:46:37 <lispy> So depending on your needs...
21:47:35 <Polytope> lispy: I want to render latex documents as interactive web pages
21:47:54 <lispy> Polytope: oh, hang on
21:48:27 <lispy> Polytope: have you seen latex2html? http://blog.codersbase.com/posts/2013-10-13-trying-out-latex2html5.html
21:49:00 <xpika> lispy: thanks
21:49:35 <lispy> Polytope: I started on something like that based on hevea. https://github.com/dagit/dagit.github.com.hevea
21:49:50 <Polytope> ah, I used latex2html in the 1990s
21:49:54 <lispy> Polytope: most of the 'magic' was in a shell script: https://github.com/dagit/dagit.github.com.hevea/blob/master/fixup-refs.sh
21:50:01 <Polytope> latex2html5 looks promising
21:50:30 <lispy> I'm really tempted to convert my blog to a series of pdfs
21:50:37 <lispy> Screw html :)
21:51:39 <lispy> the interactive diagrams that latex2html5 has are impressive
21:51:56 <slack1256> As somebody who knows nothing of Qt and Javascript, where should I start to use hsQml?
22:03:17 <int3__> kazagistar: I updated my anagrammer to use (>>=) throughout: https://github.com/int3/scrabble-solver/blob/master/Trie.hs
22:03:24 <int3__> it's quite a bit terser now
22:03:47 <johann> hey room! i am trying to get haskell-mode in emacs set up. when i try to go into interactive mode i am getting the following error--would appreciate some guidance!
22:03:49 <johann> haskell-process-start: cl-ecase failed: cabal-repl, (ghci quote cabal-ghci quote cabal-dev quote)
22:04:56 <lispy> johann: have you triedt the vim mode ;)
22:05:09 <lispy> (sorry, but seriously I can't help)
22:05:20 <johann> lispy: its all good :)
22:05:52 <lispy> johann: if I had to guess from that error message, maybe it's misconfigured in your init.el?
22:07:09 <johnw> since we're doing the AMP thing now, does it make any sense to insert Premonad between Applicative and Functor?
22:07:31 <Cale> Premonad?
22:07:50 <xpika> is it possible to create a functor instance for [[a]] ?
22:07:57 <johnw> Premonad m => a -> m a
22:08:16 <Cale> ah, pointed functor
22:08:20 <johnw> following the law: fmap f . pure = pure . f
22:08:27 <johnw> well, pointed with a law
22:09:12 <Cale> That law can't be violated, can it?
22:09:15 <johnw> i've been reading about them here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.138.4552
22:09:18 <Cale> (at least in Haskell)
22:09:55 <Alberte21>  Here some videos. I hope you like them! http://j.mp/VJF96v
22:09:55 <johnw> not if fmap is law-abiding
22:10:09 --- mode: ChanServ set +o Cale
22:10:09 <djahandarie> Yeah, it can't be violated if you have the functor law and parametricity, I think.
22:10:13 --- mode: Cale set +b *!*@79.141.160.64
22:10:14 --- kick: Alberte21 was kicked by Cale (Alberte21)
22:10:21 --- mode: Cale set -o Cale
22:10:21 <jle`> xpika: in theory, or in haskell?
22:10:42 <tyfighter> any idea how to fix line #5? http://www.codereview.cc/r/76YSn7rETe
22:11:06 <Cale> tyfighter: You don't have an = sign on that line
22:11:23 <jle`> tyfighter: it should be        | otherwise = ...
22:11:37 <tyfighter> I should use guards instead?
22:11:39 <platz> I cannot believe Chicago does not have a Haskell user group/meetup
22:11:40 <Cale> Or perhaps simply = in place of | ?
22:11:53 <jle`> yeah, that too
22:11:53 <tyfighter> (I’m new) :)
22:11:58 <jle`> but als you don't neven need guards i think
22:12:07 <tyfighter> ok
22:12:09 <jle`> oh
22:12:15 <jle`> nevermind you filter on negative numbers, sorry :)
22:12:38 <kazagistar> int3__: cool, that looks nice! I still have a feeling that there is a way to abstract most of the logic of those functions out, but I cant figure it out and it does not matter anyways
22:12:41 <jle`> you can use | otherwise =, or just use digitToInt n = ..., and that case will fire if the first guard doesn't catch it
22:13:06 <tyfighter> and “| otherwise” works without guards?
22:13:13 <Cale> tyfighter: It is a guard
22:13:20 <int3__> kazagistar: haha alright
22:13:29 <Cale> tyfighter: otherwise is a constant defined in the Prelude to be True
22:13:32 <Cale> > otherwise
22:13:33 <lambdabot>  True
22:13:42 <tyfighter> ok
22:13:44 <Cale> It's specifically designed for use with guards, because it reads a little nicer
22:14:26 <Cale> also, if you're using multiple guards, you don't need to repeat the digitToInt n bit
22:14:58 <Cale> er, toDigits n rather
22:15:05 <tyfighter> ok
22:15:45 <Cale> tyfighter: http://lpaste.net/106905
22:15:52 <tyfighter> looks like that’s working, now I guess it’s not liking diff between [Int] and [Integer]
22:16:00 <Cale> oh, yeah
22:16:07 <Cale> :t digitToInt
22:16:07 <lambdabot> Char -> Int
22:16:23 <Cale> map (fromIntegral . digitToInt)  perhaps
22:16:23 <tyfighter> Cale: cool, that’s what I have
22:16:38 <tyfighter> I need to look up diff between Int and Integer
22:16:42 <Polytope> dammit, latex2html5 doesn't really work either. :(
22:17:08 <Cale> Int is a machine integer, and is limited in size. Integer can be as large as your computer's memory will allow
22:17:19 <Cale> > maxBound :: Int
22:17:20 <lambdabot>  9223372036854775807
22:17:23 <Cale> > minBound :: Int
22:17:25 <lambdabot>  -9223372036854775808
22:17:30 <tyfighter> got it
22:17:32 <Cale> ^^ that's on a 64 bit machine
22:17:49 <wolfgang3> maxBound+1 :: Int
22:17:58 <Cale> > maxBound+1 :: Int
22:17:58 <wolfgang3> hmm how does lambdabot work?
22:17:59 <lambdabot>  -9223372036854775808
22:18:13 <wolfgang3> that was what I was expecting
22:18:15 <Cale> wolfgang3: You missed the "> " at the start of line
22:18:39 <zRecursive> > showHex (maxBound::Int) ""
22:18:41 <lambdabot>  "7fffffffffffffff"
22:19:04 <tyfighter> ok, so digitToInt is converting char -> int
22:19:12 <wolfgang3> > fix (1:)
22:19:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:19:45 <kvanb> > fix $ scanl (+) 0 . (1:)
22:19:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:20:03 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
22:20:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:20:14 <wolfgang3> curious as to how it handled unbounded outputs
22:20:17 <wolfgang3> now I know
22:20:21 <kvanb> someone has got to golf that
22:20:25 <kvanb> that primes is so verbose
22:20:38 <Cale> You can make it much shorter and slower
22:21:44 <Cale> > nubBy(((>1).).gcd)[2..]
22:21:46 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:21:54 <kvanb> oh lawd
22:21:56 <kvanb> really
22:22:03 <kvanb> I didn't expect it to be THAT short
22:22:08 <lispy> dat nubBy
22:23:07 <jle`> :t gcd
22:23:08 <lambdabot> Integral a => a -> a -> a
22:23:14 <jle`> where is that from? :o
22:23:17 <Cale> Prelude
22:23:22 <kvanb> interesting
22:23:27 <Pythonfant> GHC.Real
22:23:28 <kvanb> why is that much slower?
22:24:09 <Cale> Because it's computing lots of gcds which are expensive
22:24:17 <jle`> :t ((>1).).gcd
22:24:17 <lambdabot> Integral b => b -> b -> Bool
22:24:22 <Cale> @src nubBy
22:24:23 <lambdabot> nubBy eq []             =  []
22:24:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:24:36 <kazagistar> oh god, that nubBy is abusive and awesome
22:24:44 <jle`> @unpl ((>1).).gcd
22:24:44 <lambdabot> (\ e h -> (gcd e h) > 1)
22:24:48 <kvanb> why not just
22:24:52 <Cale> Those filters build up and each one is pretty expensive per-element
22:25:08 <kvanb> > filter (\x -> gcd x < 1) [1..]
22:25:09 <lambdabot>  No instance for (GHC.Show.Show a0)
22:25:09 <lambdabot>    arising from a use of ‘M75856734221680229191471.show_M75856734221680229191...
22:25:09 <lambdabot>  The type variable ‘a0’ is ambiguous
22:25:09 <lambdabot>  Note: there are several potential instances:
22:25:09 <lambdabot>    instance [safe] GHC.Show.Show
22:25:22 <Cale> You're not just doing trial division, but trial gcd with all the earlier primes
22:25:25 <Pythonfant> why have primes gcd > 1? and not == 1?
22:25:50 <lispy> Pythonfant: you save 1 character
22:25:56 <Pythonfant> ah nubby uses a not
22:26:22 <kmspriyatham> where is veryThick of Diagrams module defined?
22:26:35 <kvanb> :t filter
22:26:36 <lambdabot> (a -> Bool) -> [a] -> [a]
22:26:46 <kvanb> :t gcd
22:26:47 <lambdabot> Integral a => a -> a -> a
22:27:19 <Pythonfant> kmspriyatham: http://hackage.haskell.org/package/diagrams-lib-1.2.0.1/docs/src/Diagrams-TwoD-Attributes.html#veryThick that one?
22:27:26 <kvanb> :t filter (\x -> gcd x < 1) [1..]
22:27:27 <lambdabot> (Ord (a -> a), Num (a -> a), Integral a) => [a]
22:27:40 <kvanb> Oooh derp
22:28:25 <kmspriyatham> Pythonfant: I try to import that module, but ghc can't seem to find that module. Diagrams.Attributes is suggested instead
22:29:08 <Pythonfant> kmspriyatham: it seems to be in diagrams-lib not diagrams
22:29:20 <Pythonfant> but I haven't used it myself, I only did a quick hayoo search
22:32:04 <zRecursi`> :t (<*)
22:32:05 <lambdabot> Applicative f => f a -> f b -> f a
22:32:27 <zRecursi`> :t (<*>)
22:32:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:40:43 * hackagebot critbit 0.1.0.0 - Crit-bit maps and sets  http://hackage.haskell.org/package/critbit-0.1.0.0 (BryanOSullivan)
22:45:44 * hackagebot critbit 0.2.0.0 - Crit-bit maps and sets  http://hackage.haskell.org/package/critbit-0.2.0.0 (BryanOSullivan)
22:51:24 <johnfn> dumb question. i alway see people pattern matching on the first elem of a list, e.g x:xs. is it possible to match on the LAST somehow? like xs:x (except that’s totally wrong). or does it not exist because of efficiency?
22:52:47 <triliyn> johnfn: in standard haskell, you can't; pattern matching can only peel away constructors
22:52:51 <Cale> johnfn: Pretty much doesn't exist because it's a difficult operation on lists
22:52:58 <triliyn> But there is an extension called view patterns that will let you do that if you want
22:53:02 <johnfn> ah. both of those make sense
22:53:04 <lispy> not all lists have a last element
22:53:10 <Cale> ^^ and that ;)
22:53:12 <possiblywrong> johnfn: reverse xs case ...
22:53:19 <johnfn> lispy: oh yeah… that’s a really good point
22:53:38 <possiblywrong> you pay to get to the end
22:53:47 <johnfn> heh yeah.
22:53:55 <triliyn> But yes, looking at the last element is of course pretty expensive
22:54:25 <zRecursi`> "lazy" is another reason,
22:55:12 <johnfn> yeah, that all makes a lot of sense, thanks.
22:55:51 <alpounet> http://lpaste.net/6463405445192089600 -- I'm trying to find a ghc < 7.8 friendly way of defining a type-level 'elem', I found a trick by Oleg to do that (link in the paste) but I'm wondering whether there's another way. Can anyone think of something or should I really just use this trick if I want so support reasonably older ghcs?
22:57:31 <kazagistar> johnfn: most of the time, if you wanna pattern match on the last element, you probably just want a slightly different data structure
22:58:06 <johnfn> kazagistar: yeah - after thinking about my case, i just tweaked it so i could pattern match on the first thing instead
22:58:31 <alpounet> s/so/to/
23:10:46 * hackagebot peyotls 0.0.0.14 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.14 (YoshikuniJujo)
23:10:50 <xpika> just got  Exception: divide by zero. how can i get the line number?
23:12:38 <matematikaadit> > 1 / 0
23:12:40 <lambdabot>  Infinity
23:12:51 <Cale> > 1 `div` 0
23:12:53 <lambdabot>  *Exception: divide by zero
23:13:11 <zRecursi`> :t (/)
23:13:12 <lambdabot> Fractional a => a -> a -> a
23:13:13 <pavonia> > 1 `mod` 0
23:13:15 <lambdabot>  *Exception: divide by zero
23:13:20 <Cale> xpika: You might try compiling with profiling and running the program with +RTS -xc
23:14:13 <zRecursi`> Cale: What does "-xc" stand for ?
23:14:36 <Cale> I'm not sure, presumably eXCeptions
23:15:02 <zRecursi`> maybe
23:15:06 <Cale> It gets you a "stack trace" when an exception is thrown, consisting of cost-centres
23:15:52 <Cale> grepping for div and mod is probably easier
23:16:50 <Cale> > 1 / 0 :: Rational
23:16:52 <lambdabot>  *Exception: Ratio has zero denominator
23:16:59 <Cale> okay, so that one's different
23:18:10 <dfeuer> What's the point of `assuming` in the unamb package? assuming::Bool->a->a  assuming True a = a   assuming False a = undefined
23:19:17 <dfeuer> A number of other functions in that package use it, but I'm struggling to understand how it can do anything useful.
23:22:31 <jle`> dfeuer: what do the other functions use it for...?
23:22:34 <adas> just upgraded to ghc 7.8.2. can someone please tell me some of the interesting new features of this version?
23:22:56 <dfeuer> jle`, I haven't looked into it that far.
23:23:12 <jle`> dfeuer: it looks like an assertion
23:24:05 <adas> i did go through the 7.8.2 docs .. so I'm familiar with some of the new features. Just wanted the communities opinion about what they like most?
23:24:11 <dfeuer> jle`, yeah, but there are plain old assertions, and this gives just undefined, rather than any useful error message, so I'm vaguely guessing that this has some optimization purpose.
23:25:18 <dfeuer> adas, you just upgraded to 7.8.2, and 7.8.3 is expected to come out sometime around tomorrow. With, apparently, a whole lot of big bug fixes.
23:26:37 <dfeuer> There's only one bug left that's on the list to fix for 7.8.3: https://ghc.haskell.org/trac/ghc/query?status=!closed&milestone=7.8.3&order=priority
23:27:53 <adas> dfeuer: ill upgrade to 7.8.3 when it comes tomorrow. been using binary packages
23:28:59 <adas> some features i like .. multiway ifs. i know they've been around a few versions now..but just knew about them recently.
23:29:18 <dfeuer> I haven't read about a lot of new features, but I did note that 7.8.x is better than 7.6.x at avoiding conditional branches in arithmetic.
23:29:54 <dfeuer> Because they changed the types of ># and ==# and so on to give #Int instead of Bool.
23:30:00 <dfeuer> er... Int# instead of Bool.
23:30:13 <dfeuer> adas,  what is a multiway if?
23:30:31 <dfeuer> Is that like a LISP cond?
23:31:43 <adas> dfeuer: if | a < 10 -> <do something | a > 10 && a < 20 -> do soemthing | otherwise -> do something
23:31:47 <dfeuer> Ah. Yes, it is. With weird syntax.
23:31:49 <adas> more like guard syntax
23:32:22 <dfeuer> Yeah, it's guard syntax, but what it's implementing is just cond.
23:35:48 * hackagebot peyotls 0.0.0.15 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.15 (YoshikuniJujo)
23:37:40 <zRecursi`> `pkg search ghc` => ghc-7.6.3_4. It seems FreeBSD ghc maintainer is not so active
23:42:50 <kazagistar> zRecursi`: sounds like there is an unpaid job opening
23:44:52 <kazagistar> ... I dont know what the point of that comment was... sorry
23:45:48 * hackagebot peyotls 0.0.0.16 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.16 (YoshikuniJujo)
23:57:05 <zRecursi`> kazagistar: Did GHC team get paid ?
