00:43:40 <johnw> hmm, can it be proven that join . fmap f . fmap return = f?  Aka: (>>= f . return) = f
00:44:18 <johnw> join . fmap f . return is easy
00:44:32 <johnw> i'm wondering if there's a corresponding between these two forms, and monad law's 2 and 3
00:47:05 * hackagebot postgresql-simple-migration 0.1.3.0 - PostgreSQL Schema Migrations  http://hackage.haskell.org/package/postgresql-simple-migration-0.1.3.0 (ameingast)
00:47:12 <augur> is there a good tutorial on structuring haskell projects so they're not one giant blob?
00:47:26 <augur> i dont know how to use hierarchical dirs with module imports
00:47:46 <int3__> augur: http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project
00:48:08 <augur> \o/
00:48:10 <augur> thank you int3__
01:11:37 <PotatoGim> Hi
01:44:27 <xpika> is there a way to view  hpc results live?
01:51:15 <ketil> Sigh.  I can never remember - I'm trying to install a package, it pulls in some ancient version (of filepath, this time), which it doesn't depend on directly, and which fails to install. How can I figure out which package in the net of dependencies is causing the breakage?
01:52:11 * hackagebot connection 0.2.2 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.2 (VincentHanquez)
01:54:50 <quchen_> ketil: You can control output verbosity with -v[1-3]
01:55:17 <jle`> hi PotatoGim
01:55:19 <quchen_> I think 1 is default, 0 disables output
01:57:11 * hackagebot spoty 0.1.0.0 - Spotify web API wrapper  http://hackage.haskell.org/package/spoty-0.1.0.0 (DavidNilsson)
02:12:25 <jle`> fixed a bug i have been stuck on for literally like 12 hours :|
02:12:44 <sgronblo> congrats!
02:12:58 <sgronblo> what was it about?
02:13:21 <peterhil> I'm trying to wrap a C call in a ST monad, but don't get the results modified. Are there any good examples on how to do this? The function I'm trying to wrap is:
02:13:38 <peterhil> foreign import ccall unsafe "fft/fftsg_h.h rdft"
02:13:38 <peterhil>     -- void rdft(int n, int isgn, double *a);
02:13:39 <peterhil>     c_rdft :: Int -> Int -> Ptr CDouble -> IO ()
02:13:39 <peterhil> void rdft(int n, int isgn, double *a)
02:14:21 <jle`> sgronblo: instead of M.union, i used M.unionWith (<>)
02:14:26 <adimit> peterhil: just so I understand it correctly: you aren't trying to call it inside *just* the ST monad, right? C-calls have to be in IO (unless you use unsafe and know what you're doing.)
02:14:32 <jle`> whenever i tested it before, the "first" thing was always mempty
02:14:41 <jle`> so i didn't notice that I actually just wanted it to use/replace one over the other
02:14:44 <jle`> instead of appending them
02:14:49 <jle`> (from Data.Map)
02:14:59 <jle`> because in all my tests I always just fed in mempty
02:15:33 <jle`> ...maybe i should actually start doing property tests
02:15:48 <peterhil> adimit: Yes, I have another function, whose type is: rdft :: Integral a => FFTMode -> a -> V.Vector CDouble -> IO (V.Vector CDouble)
02:16:07 <peterhil> And I use thaw, withForeignPtr and freeze in there.
02:16:25 <peterhil> Then I try to call it with runST
02:21:33 <peterhil> The FFT function is from here: http://www.kurims.kyoto-u.ac.jp/~ooura/fft.html
02:27:06 <Javran> @hoogle Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:27:08 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:27:08 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
02:27:08 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
02:27:24 <Javran> so is there a "scanM" ?
02:28:04 <Javran> @hoogle (Monad m) => [a -> m a] -> a -> m [a]
02:28:05 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:28:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:28:05 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
02:28:23 <arancia> Maybe in monad-loops
02:34:34 <Flonk> How do I get the current script's filename in Haskell? `getArgs` won't tell me!
02:35:49 <quchen_> Flonk: getProgName.
02:36:13 <haasn> But see http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Environment.html
02:36:43 <Flonk> quchen_: Oh wow, how did I miss that? It's right after getArgs in the docs.
02:36:51 <Flonk> Well, it's still early in the morning
02:36:55 <Flonk> quchen_: Thanks! :)
02:37:21 * hackagebot creatur 5.6.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.0 (AmyDeBuitleir)
02:42:21 <ketil> quchen: I've run a bit of cabal with -v3, and as far as I can tell, it says what it selects, but not why.  What am I looking for?
02:44:32 <jle`> my minimax bot tells me that i can force a victory but i don't see it
02:44:53 <jle`> this is embarassing
02:45:52 <jle`> oh i see it now
02:46:19 <Black-Heaven> Hi all is there a clean way to enforce typeclass laws with doctest and quickcheck? I look for a way to declare properties at typeclass level and automatically run them at instance level. Thanks in advance.
02:48:29 <augur> somehow
02:48:43 <augur> unsafePerformIO.putStr  !=  trace
02:48:58 <augur> so that was a waste of time for me
02:49:16 <peterhil> adimit: I got it working now
02:49:30 <jle`> augur: i think you have to use seq to tie it to evaluating something
02:49:34 <augur> i did
02:49:41 <RchrdB> augur, I think trace is more like, trace x y = unsafePerformIO (hPutStrLn stderr x) `seq` y
02:49:49 <augur> oh thats right, isnt it
02:49:50 <augur> ugh
02:49:53 <augur> lmfao
02:49:56 <jle`> heh
02:50:22 <RchrdB> augur, also, hit stderr, not stdout, lest ye make unix sad by accidentally injecting debugging text into a pipeline. ;)
02:51:05 <augur> mm, nope, stillnot printing. oh well. unsafePerformIO is reliable! hrmph!
02:51:30 <mmmm> I have a 45 000 line String -> Record lookup table. What is the best way to represent this?
02:51:50 <augur> with Map, and probably use Text not String
02:53:27 <mmmm> I run out of memory whilst compiling occasionally
02:53:38 <mmmm> anything I can do about that?
02:53:49 <mmmm> or just suck it up and get a better laptop
02:54:22 <frerich> mmmm: How much memory do you have?
02:55:11 <mmmm> frerich: 2gb
02:55:30 <MP2E> mmmm : which GHC version are you using?
02:55:34 <mmmm> 7.8.2
02:55:42 <MP2E> ahh I recommend updating to 7.8.3
02:55:50 <MP2E> 7.8.2 exploded in memory for a lot of libraries/executables for me
02:55:56 <MP2E> 7.8.3 uses a much more reasonable amount of memory
02:56:06 <mmmm> oh really thanks
02:56:10 <MP2E> no problem :)
02:56:11 <mmmm> this would save me lots of headaches
02:56:20 <MP2E> I have 2GB myself
02:56:26 <MP2E> and I haven't went into swap once with 7.8.3 so far
02:56:30 <MP2E> and I've compiled a lot of stuff!
02:56:34 <MP2E> :D
03:07:25 * hackagebot monad-logger 0.3.7 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.7 (MichaelSnoyman)
03:12:26 * hackagebot parsers 0.12 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.12 (EdwardKmett)
03:13:19 <Dutchsmoker_> hey
03:14:50 <Dutchsmoker_> anyone around?
03:15:10 <johnw> some are
03:15:44 <Dutchsmoker_> i got a question
03:16:04 <Dutchsmoker_> im trying make find a service for the new peoplesign captcha
03:16:18 <Dutchsmoker_> the Recaptcha's arent a problem becuase there text based
03:16:37 <Dutchsmoker_> but the peoplesign captcha's are picturebased
03:16:42 <johnw> is that a Haskell question?
03:17:00 <Dutchsmoker_> its based op scripting
03:21:08 <Dutchsmoker_> johnw: why are there a shitload of people but no discussions going on?
03:21:26 <tdammers> Dutchsmoker_: this is IRC. Traffic volume fluctuates heavily
03:21:49 <Dutchsmoker_> oke im still new so sorry tdammers
03:22:03 <bennofs> johnw: you're still OP, btw
03:22:21 <bernalex> Dutchsmoker_: basically most people have a bunch of channels open in which they engage in what is known as "lurking".
03:22:50 <tdammers> I just keep my IRC client running 24/7, actually
03:22:56 <bernalex> Dutchsmoker_: so whenever they actually feel like it, they'll check out a channel. or whenever someone highlights them to tell them something.
03:23:07 <Dutchsmoker_> ahh oke
03:23:08 <bernalex> and yeah, a lot of us run IRC 24/7 in 50 channels or so.
03:23:21 <Dutchsmoker_> bernalex: how safe is IRC
03:23:26 <bernalex> Dutchsmoker_: in what regard?
03:23:38 <Dutchsmoker_> if i start a privite convo with u
03:23:42 <Dutchsmoker_> how private will it be?
03:23:45 <Dutchsmoker_> bernalex:
03:24:14 <MP2E> it's private unless someone is packet sniffing you I guess, I don't think the text is encrypted
03:24:15 <bernalex> Dutchsmoker_: less private than OTR, but more private than something like skype or other proprietary software that's monitored by a corporation which passes the conversation on to American agencies.
03:24:18 <MP2E> channels are publicly logged though
03:24:27 <bennofs>  MP2E not all though
03:24:35 <MP2E> yeah
03:24:44 --- mode: johnw set -o johnw
03:24:45 <johnw> thanks
03:24:46 <Dutchsmoker_> ahh oke thnx
03:25:08 <bernalex> Dutchsmoker_: so it's "private enough" but *not* encrypted.
03:25:10 <johnw> my connection to freenode uses TLS
03:25:24 <johnw> so they'd have to hijack the server, or just overflow a buffer somewhere ;)
03:25:32 <Dutchsmoker_> so bernalex MP2E does OTR work the same in most things?
03:25:37 <bernalex> Dutchsmoker_: a lot of us run what is called bitlbee, which is a way to use XMPP in the IRC client. that lets you use OTR (Off-The-Record chat), which is encrypted. that's nice for actually private conversations.
03:25:48 <bernalex> I don't know what mp2e is
03:25:53 <MP2E> I'm an MP2E
03:25:56 <MP2E> ;)
03:26:01 <Dutchsmoker_> haha i ment u ;)
03:26:03 <bernalex> oh lol
03:26:09 <Dutchsmoker_> oke thnx let me read soemthing about that
03:26:14 <bernalex> OTR is a way to encrypt XMPP chat
03:26:19 <johnw> he's the predecessor to MP2F
03:26:20 <bernalex> XMPP is a protocol that things like google chat use
03:26:22 <MP2E> hahah
03:26:40 <MP2E> actually the predecessor to MP3C and the sequel to MP
03:26:43 <MP2E> ;)
03:27:27 <MP2E> (Metroid Prime 2: Echoes, since I'm guessing there aren't a ton of gamers in here hehehe)
03:28:02 <bernalex> MP2E: went over to my browser and did oMP2E w! -- and got that game on wikipedia
03:28:54 <osfameron> ah, metroid prime is one of the only modern games I've played on a console rather than a phone.  It's rather more complicated than Candy Crush...
03:29:28 <MP2E> haha
03:29:41 <MP2E> in a year or two, you may even be able to play that on your phone, at the rate ARM CPUs are increasing in speed
03:30:04 <osfameron> I suspect it would be even more confusing on such a small form factor though
03:30:11 <MP2E> haha yeah
03:30:25 <bernalex> MP2E: mfw I tried putting scummvm on my nintendo ds and found out that it does not have enough RAM to run monkey island 3, when my several years old mobile phone *can* run monkey island 3...
03:30:39 <johnw> we're veering off the stated topic... :)
03:30:46 <MP2E> Indeed, a Nintendo DS is a 33mhz ARMv7 and a 66mhz ARMv9 with 4MB or RAM
03:30:47 <johnw> even though it was absolute silence otherwise
03:30:48 <MP2E> of*
03:30:52 <MP2E> very slow :(
03:30:55 <MP2E> even the 3DS is pretty bad
03:31:03 <MP2E> ~300mhz ARM11 which is ARMv6
03:31:15 <ddrone> Hi everyone. Is there a tool for Haskell which will take a module and visualize a graph of top-level definitions?
03:31:21 <RchrdB> MP2E, I remember seeing one first-person "Metroid" game which ran on the Nintendo DS, using the stylus to aim. The original NDS is *much* less powerful than even a Raspberry Pi, let alone a modern smartphone.
03:31:35 <johnw> this isn't the place for games discussion
03:31:46 <MP2E> sorry >_>
03:31:48 <johnw> n/p
03:31:54 <bennofs> you can continue the discussion on #haskell-blah ofc :)
03:32:04 <johnw> ddrone: shouldn't be hard to make one with the GHC API
03:32:17 <bennofs> ddrone: I think I once saw such a tool, let me see if I can find it
03:32:32 <Dutchsmoker_> bernalex: If i stand correctly i install bitlbee and i can join the channels normaly like i do now but when i start a private convo its not monitored
03:32:34 <Dutchsmoker_> ?
03:33:10 <tdammers> Dutchsmoker_: no, that's not how it works
03:33:13 <bernalex> Dutchsmoker_: oh, no, sorry. bitlbee is just a gateway for having XMPP as an IRC server. so you get a buffer, like you get with any IRC channel. in bitlbee you then add your XMPP account.
03:33:19 <bernalex> Dutchsmoker_: I seem to have terribly confused you! sorry
03:33:43 <ddrone> johnw: Do you have any recommendation on what will be the best entry point to dig into GHC API?
03:33:52 <bernalex> Dutchsmoker_: so to be clear: bitlbee is kind of like having pidgin, or google chat, or msn, or whatever as a buffer in your IRC client.
03:34:02 <Dutchsmoker_> haha bernalex dont worry im still a huge noob about this stuff but i find it intresting enough to learn ;)
03:34:14 <Dutchsmoker_> but it let u use somekind of proxy ?
03:34:27 <bennofs> ddrone: there is SourceGraph: https://hackage.haskell.org/package/SourceGraph
03:34:35 <bennofs> ddrone: maybe that already does what you want?
03:35:03 <ddrone> bennofs: Thanks, I'll look into it
03:35:42 <snyp> How to understand that >>= is associative?
03:35:55 <bernalex> Dutchsmoker_: basically you run a server (or use a public one), then connect to this server, and you get a buffer in your IRC client. in here you then use some commands to add your e.g. MSN or Facebook Messenger account. personally I have my own XMPP server too, and also use the Free Software Foundation's XMPP server, and Duck Duck Go's server. these servers are what is known as "federated servers". this
03:35:58 <bernalex> means that I, with my Duck Duck Go account, can connect to you even if you have Google Talk or something else entirely.
03:36:13 <ion> snyp: (a >=> b) >=> c = a >=> (b >=> c)
03:36:43 <Dutchsmoker_> ahh i get it now! thnx bernalex
03:36:49 <bennofs> snyp: The 'associativity' is easier to see if you use >=> which is defined as a >=> b = \x -> a x >>= b instead of >>=
03:37:22 <nexx> uhm google is going away from xmpp
03:37:41 <bennofs> syllogismos: then, (a >= b) >=> c = a >=> (b >=> c), as johnw points out
03:37:51 <johnw> I pointed that out?
03:37:54 <bennofs> ^^^ meant snyp
03:37:56 <ion> yes, i am you
03:38:02 <bennofs> johnw: oh, you got the same color as ion, sorry :)
03:38:04 <johnw> ah, ok
03:38:15 <johnw> i've been working with the monad laws for so long tonight, I thought I'd said it and forgotten
03:38:28 <bennofs> heh
03:39:12 * snyp understands nothing.  this will take some time...
03:39:25 <bennofs> :t >=>
03:39:25 <lambdabot> parse error on input ‘>=>’
03:39:29 <bennofs> :t (>=>)
03:39:30 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:40:52 <nexx> without >=>: (m >>=  \x -> f x) >>= \y -> g y == m >>= (\x -> f x  >>= \y -> g y)
03:40:53 <ion> > (permutations <=< subsequences) "hai"
03:40:54 <lambdabot>  ["","h","a","ha","ah","i","hi","ih","ai","ia","hai","ahi","iah","aih","iha",...
03:42:31 * hackagebot coroutine-object 0.3 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.3 (IanWooKim)
03:42:33 * hackagebot xournal-parser 0.5.0.3 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5.0.3 (IanWooKim)
03:42:34 <pjdelport> snyp: Another way to see the associativity is to observe that given m (m (m a)), you can join it in either order.
03:43:09 <pjdelport> snyp: In other words, join (join x)  ==  join (fmap join x)
03:44:05 <ion> m³ a
03:47:32 * hackagebot hoodle-types 0.3 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.3 (IanWooKim)
03:47:34 * hackagebot hoodle-builder 0.3 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.3 (IanWooKim)
03:47:36 * hackagebot hoodle-parser 0.3 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.3 (IanWooKim)
03:47:38 * hackagebot hoodle-render 0.4 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.4 (IanWooKim)
03:47:40 * hackagebot hoodle-core 0.14 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.14 (IanWooKim)
03:48:50 <int3__> hm, I am trying to install tasty-hunit and cabal is complaining
03:48:52 <int3__> `cabal: The following packages are likely to be broken by the reinstalls:`
03:49:00 <int3__> `haskell-platform-2013.2.0.0` (amongst others)
03:49:18 <int3__> is it time for me to switch from haskell-platform to direct ghc+cabal?
03:49:24 <int3__> (I'm on OS X)
03:50:13 <snyp> oh. i get it.. i was thinking in terms of types, not function evaluation. So I thought a => (b => c) is not possible as second arg of >>= is of type (x -> Maybe x) .. blah blah. nah i get it now.
03:50:23 <dcoutts> int3__: or use a sandbox
03:50:37 <int3__> dcoutts: I believe I'm using a sandbox... that's the other thing that's confusing me heh
03:50:46 <int3__> I did do the whole cabal sandbox init thing
03:50:58 <snyp> (thinking in terms of Maybe i.e)
03:51:01 <dcoutts> int3__: oh then it's fine. Yes within the sandbox haskell-platform will not be usable, but that;s ok.
03:51:16 <snyp> (x -> Maybe y) ...
03:51:20 <snyp> whatever.
03:51:32 <int3__> dcoutts: ah okay, thanks :)
03:51:36 <mmmm> sandboxes only shift the problem really
03:51:57 <snyp> haskell is easily the weirdest language ever.
03:52:42 * hackagebot hoodle-extra 0.1 - extra hoodle tools  http://hackage.haskell.org/package/hoodle-extra-0.1 (IanWooKim)
03:56:58 <RchrdB> snyp, there are weirder languages, like Malgole or Unlambda.
03:57:10 <dv-> and java
03:57:14 <MP2E> Intercal
03:57:34 * hackagebot hoodle 0.3 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.3 (IanWooKim)
03:58:17 <johnw> I hear J is pretty bizarre
03:58:22 <RchrdB> snyp, there are also useful languages like Idris or Agda which go even further down the route of "let's use type systems to increase our confidence that the progarms which we write will work".
03:59:02 <hpc> idris and agda don't exactly have useful standard libraries though
03:59:15 <hpc> you'll be limited in what you can practically do, especially with agda
03:59:19 <johnw> agda is working on a new stdlib
03:59:30 <johnw> one that Haskellers would mostly recognize, no less
04:03:54 <Dutchsmoker_> anyone plays the game called bootleggers.us?
04:04:10 <johnw> this isn't the place, Dutchsmoker_
04:04:59 <Dutchsmoker_> johnw: u know anyone other chanels for just chatting and get to know stuff about internet computers code etc?
04:05:21 <johnw> #emacs is pretty easygoing that way
04:05:23 <dv-> try #systemd
04:05:29 <Dutchsmoker_> oke thnx
04:16:04 <snyp> No I don't get it. bind is left associative as I can see it...  and this http://stackoverflow.com/questions/17843077/how-do-you-explain-the-associativity-of-the-bind-operator-in-this-haskell-expres sort of says something about lambdas.. someone explain.
04:16:49 <snyp> pls
04:19:27 <bernalex> my head is broken from imperative programming for a while. can someone help fix it?
04:19:39 <johnw> help you fix your brain?
04:19:47 <bjornars> bernalex: try tequila
04:19:56 <bernalex> given line #1 as v, and line 20 as w, and the inbetweens demonstrating how to get there, what would you do? http://lpaste.net/5763307612527394816
04:20:03 <johnw> snyp: the lambda thing means that X -> Y causes Y to range over the rest of the line
04:20:14 <johnw> you have to use parens around the lambda expression to reduce its scope
04:20:18 <bernalex> imperative way would be substituting strings blah blah v[i].charAt etc.
04:20:25 <bernalex> but how can I do this neatly functionally?
04:21:14 <johnw> you'd use one string to generate another string
04:21:31 <johnw> which feels like an awful thing to do imperatively, but in a language like Haskell works very well
04:21:44 <bernalex> johnw: I have line 1 as a var, and line 20 as a var. so I need a function that inserts one char from the var in line 20, into the var in line 1
04:21:58 <bernalex> so one char at the time to get to the goal in line 20 from the start in line 1
04:22:23 <johnw> write a function that takes as input two strings, and returns the next "step"
04:22:31 <johnw> then recursively feed this function its own result until the two strings match
04:22:41 <bernalex> yes that's where my head is refusing to cooperate
04:22:46 <johnw> ah
04:22:54 <johnw> heads are known to do that
04:22:58 <bernalex> I should note that I'm really doing this in elm, so I will use foldp (fold from the past) to do this one step at the time
04:23:09 <MP2E> snyp : That just says that if you make a lambda and you don't put it in parenthesis, it extends all the way to the right
04:23:13 <bernalex> but I like haskell more, so I always do algos in haskell first, heh
04:23:19 <MP2E> and can cause some crazy things to happen
04:23:39 <MP2E> this : ([1,2] >>= \n -> ['a', 'b']) >>= \ch -> return (n, ch)
04:23:47 <MP2E> becomes this : [1,2] >>= (\n -> ['a', 'b'] >>= \ch -> return (n, ch))
04:23:57 <MP2E> which is not what the author in stackoverflow had intended
04:24:03 <MP2E> parenthesis would have fixed this
04:24:03 <bernalex> I thought I could test it with scanr in haskell
04:24:34 <bernalex> johnw: oh yeah, so since I'm doing foldp, I want the function to take v & w and just return the next step, and then use it with folds.
04:24:48 <johnw> yeah, folds just abstraction the recursion I was referring
04:24:53 <johnw> abstract
04:24:59 <bernalex> but my imperative brain keeps talking to me about indices
04:25:07 <bernalex> and string substitution
04:25:08 <bernalex> make it stop!
04:25:21 <johnw> <insert yoda unlearning comment here>
04:25:48 <bernalex> f v w = -- brain says something about, don't you need a counter? >_<
04:26:14 <johnw> you don't if your function is "data driven"
04:26:35 <johnw> i.e., assume you don't know the context at all
04:26:42 <johnw> can you, given some pieces of input, generate the next step?
04:27:25 <bernalex> johnw: I'm not even sure if I can heh
04:29:11 <snyp> johnw: http://lambda-the-ultimate.org/node/2448 last answer says 'sort of associative' due to the lambda abstraction.. why are we introducing a lambda to make the whole right side of the first bind a function of type (x -> Maybe y)... I understand that even without the lambda, it would mean the same(coz k will be curried then), so is it just for making it easier to understand?
04:30:40 <snyp> johnw: http://lambda-the-ultimate.org/node/2448#comment-36779 sorry, not the last answer
04:34:07 <johnw> what are you grappling with at this moment?
04:34:50 <snyp> ok i get it now i think. in the case of right associativity the right side of bind is a partially applied function, that needs a value to give the result monad. the end result is same as left associative case. ok i get it. correct me if i am wrong.
04:36:20 <johnw> maybe you're confusing evaluation and execution
04:36:38 <pjdelport> snyp: That question is sort of muddled by the discussion of side-effects: in Haskell, there are no side effects, in particular when composing IO actions.
04:36:49 <johnw> the execution will always be "in order"; the evaluation need not be
04:37:19 <snyp> it's just a convention that we write m => (\x -> f x) , instead of just m => f , right?
04:37:35 <johnw> the two are "eta-convertible"
04:37:59 <johnw> i.e., you can use eta-conversion to go from f -> (\x -> f x), and vice-versa
04:38:49 <pjdelport> snyp: The lambda is only there because without it, it would actually parse as (\x -> (k >>= h) x), which is an entirely different thing.
04:38:57 <johnw> snyp: that page you linked said the same thing I just did:
04:39:01 <johnw> Like sigfpe states, it is an axiom about the associativity of the >= operator.
04:39:02 <johnw> This has nothing to do with execution order!
04:39:34 <bernalex> how do you give functions type sigs in ghci again? I swear I'll try to remember this time
04:40:02 <johnw> ghci> let f x = x + 1 :: Int -> Int
04:40:24 <pjdelport> bernalex: You can say > let foo :: Fnord; foo = ...
04:40:37 <bernalex> johnw: that's what I thought. must have some parens error or something
04:40:47 <pjdelport> (and add multiple cases for foo ... = ... like that)
04:40:53 <bernalex> pjdelport: ah, that's the syntax I forgot about!
04:40:56 <snyp> pjdelport: m => (k => h) also makes sense right?
04:40:57 <bernalex> thanks
04:41:27 <snyp> coz (k => h) is a curried function that requires 1 argument to get fixed
04:41:32 <pjdelport> snyp: you mean >>= instead of => ?
04:41:38 <snyp> oh.. yes
04:41:40 <snyp> sorry
04:41:57 <snyp> m >>= (k >>= h)
04:42:05 <johnw> that doesn't make sense
04:42:08 <johnw> m >=> (k >=> h) does
04:42:35 <johnw> or m >>= (\x -> k x >>= h) does
04:42:42 <bernalex> f :: [[Char]] -> [[Char]] -> [String] god damn that's confusing ghci -- pick one!
04:43:06 <pjdelport> snyp: Not quite, precisely because of the lambda thing I pointed out above.
04:43:37 <snyp> If that doesn't make sense, then how is >>= right associative?
04:44:51 <johnw> snyp: (m >>= k) >>= h = m >>= (\x -> k x >>= h)
04:45:04 <johnw> that's one of the monad laws
04:45:20 <johnw> you can rewrite it using >=> and it will appear more regular
04:45:21 <snyp> but you are introducing this lambda hack
04:45:32 <MP2E> lol lambda hack? what do you mean?
04:45:37 <nexx> :D
04:46:05 <MP2E> Use Kleisli Composition if you think the Lambda looks ugly, which incidentally is >=>
04:46:11 <bernalex> hm. is there no strict scanl/r?
04:47:08 <bernalex> also is there an "unimport" in ghci?
04:47:15 <snyp> ok i will need to learn about >=> in detail then, but till then, the rule is just a monad law to me, not an associative property of >>= .
04:47:48 <pjdelport> snyp: This might make it clearer:
04:47:48 <pjdelport> (m >>= \x -> k x) >>= \y -> h y
04:47:48 <pjdelport> m >>= (\x -> k x >>= \y -> h y)
04:48:25 <MP2E> @src (>=>)
04:48:25 <lambdabot> Source not found. Do you think like you type?
04:48:53 <pjdelport> snyp: In the usual statement, the "implied" lambdas are just simplified where possible.
04:49:35 <snyp> pjdelport: yes this makes sense
04:49:45 <pjdelport> snyp: In other words, in the first expression, both "\x -> k x" and and "\y -> h y" can be reduced simply to k and h without changing anything.
04:50:06 <snyp> yeah
04:50:12 <snyp> and the second one?
04:50:19 <pjdelport> But in the second case, only  (\y -> h y) can be reduced, because the body of the \x actually expands to the whole right
04:50:27 <nexx> snyp may I ask why it didn't made sense an hour ago?
04:50:42 <snyp> pjdelport: oooh
04:50:42 <pjdelport> snyp: In other words, the second case means: m >>= (\x -> (k x >>= \y -> h y))
04:50:47 <snyp> pjdelport: i see
04:51:45 <pjdelport> snyp: So it's not a case of the lambda being introduced. The lambda are all always "there", in the above sense.
04:52:12 <pjdelport> You just have to expand them all back in to see the symmetry more literally/visually.
04:53:51 <pjdelport> { m >>= (\x -> k x) } >>= (\y -> h y)
04:53:51 <pjdelport> m >>= ( \x -> (k x >>= (\y -> h y))
04:53:59 <snyp> aah.. i see. i sort of understand now. the lambda was kept to enforce our semantics.
04:54:08 <pjdelport> Sorry, pressed enter accidentally.
04:54:43 <pjdelport> That second one should be:
04:54:43 <pjdelport> m >>= { \x -> (k x >>= (\y -> h y)) }
04:55:45 <pjdelport> So that's the same thing with all the lambdas and parens explicit: the { and } also stand for ( ), but I visually distinguished them to show the grouping that means that >>= is associative.
04:56:41 <ahnfelt> q
04:56:42 <ahnfelt> \q
04:56:52 <ahnfelt> oops
04:56:52 <pjdelport> snyp: It can be simpler to understand the associativity in terms of join, though. (For me it is, at least.)
04:57:54 <snyp> ah. ok. i sort of fully get it now. i will need to learn about join. is that the <=> operator?
04:58:03 <pjdelport> :t join
04:58:04 <lambdabot> Monad m => m (m a) -> m a
04:58:20 <pjdelport> snyp: >>= is basically just fmap followed by join
04:59:02 <pjdelport> snyp: Join is the operator that composes a "nested" monadic value into a single monadic value.
04:59:22 <pjdelport> snyp: And it's really the heart of what defines a monad.
04:59:39 <pjdelport> snyp: For example, for IO, join is the thing that actually does sequencing.
05:00:47 <snyp> i see. how is >>= an fmap followed by join?
05:01:15 <Cale> snyp: x >>= f = join (fmap f x)
05:01:16 <quchen_> m >>= f = join (fmap f m)
05:02:13 <pjdelport> Or in more applicative-style syntax:  f =<< m  =  join (f <$> m)
05:02:20 <pjdelport> (where <$> is fmap)
05:02:51 <pjdelport> snyp: Do understand Functor / fmap?
05:03:12 <pjdelport> (That should be a requirement before learning Monad, and too many people skip it!)
05:09:22 <bernalex> anyone with lambdabot privileges here? shapr seems offline
05:13:17 <quchen_> bernalex: int-e is the current owner, I think.
05:13:38 <bernalex> int-e: make lambdabot join #plaimi please? I usually get shapr to do it whenever it ducks out
05:17:52 * hackagebot creatur 5.6.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.1 (AmyDeBuitleir)
05:23:38 <snyp> pjdelport: yeah i just read http://www.haskell.org/haskellwiki/Monads_as_containers . i understand >>= in terms of fmap and join now. thanks a lot for the help today.
05:26:57 <RchrdB> snyp, yay!
05:27:10 <johnw> now forget you ever saw the word "container" in reference to monads :)
05:28:20 <hexagoxel> bernalex: afaik, "import x" is ":m +x"; unimport would be ":m -x"
05:28:58 <pjdelport> snyp: Cool. So does what I said earlier about "join" being associative in a sense begin to make sense?
05:29:20 <tdammers> really, the only "containery" thing about Monad is that it takes a type argument
05:30:32 <pjdelport> Yeah... containers are one intuition, but not an especially enlightening one. Monads are containers only in the sense that *all* parameterized types are "containers".
05:31:01 <tdammers> exactly. And not all monads behave like containers in the strict sense anyway
05:31:20 <tdammers> even the list monad kind of stretches the container intuition
05:31:20 <johnw> oh?  what does the 'Const a' functor contain?
05:31:29 <bennofs> johnw: nothing
05:31:52 <ion> johnw: its joy
05:32:06 <tdammers> > [23, 42, 11] >>= const (return 1)
05:32:10 <lambdabot>  [1,1,1]
05:32:19 <Iceland_jack> > 1 <$ [23, 42, 11]
05:32:20 <lambdabot>  [1,1,1]
05:32:22 <tdammers> "contain" is kind of a useless intuition there
05:35:14 <johnw> containment implies there's a "thing" that exists and that "holds" something; but a Functor is a type constructor; it neither exists nor holds anything.  The type that it constructs may or may not hold something at runtime, so I find it a dubious intuition at best
05:35:56 <snyp> pjdelport: join just takes 1 argument and it's not an operator.. how can there be associativity?
05:36:07 <tdammers> "exists" is kind of a volatile notion in something as declarative as Haskell anyway :D
05:36:08 <johnw> snyp: you have to look at the types
05:36:15 <pjdelport> snyp: It's associative in a higher-level sense.
05:36:55 <snyp> (join (join boxes)) = (join . join) boxes ?
05:37:07 <snyp> that's trivial-ish.
05:37:10 <pjdelport> (That's also why talking about the associativity in terms of >>= and such can be confusing, because it mixes the levels, in a sense.)
05:37:21 <pjdelport> snyp: No, that's not it.
05:37:31 <snyp> o
05:37:56 * hackagebot machinecell 1.1.1 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-1.1.1 (HidenoriAzuma)
05:38:08 <pjdelport> snyp: It basically means that given multiple "nestings" of a monadic type, like: m (m (m a))
05:38:16 <johnw> in taking M (M (M A)) -> M A, we can do it by combining 1&2 and then 3, or 2&3 and then 1
05:38:23 <johnw> that's written: join . join = join . fmap join
05:38:35 <pjdelport> snyp: Then you can join them in any order, and get the same compound monadic value out.
05:39:07 <johnw> that's the first monad law (in terms of join)
05:39:26 <Iceland_jack> :t join . fmap join
05:39:27 <lambdabot> (Functor m, Monad m) => m (m (m a)) -> m a
05:39:27 <Iceland_jack> :t join . join
05:39:28 <lambdabot> Monad m => m (m (m a)) -> m a
05:42:43 <Algebr> Since there this String/Text divide, does this mean whenever working with text, one has to use Text specific functions? Is Text made up of Chars?
05:43:18 <Iceland_jack> Algebr: You shouldn't have to concern yourself with the actual representation of Text, but you can interface with it with Chars
05:43:47 <Iceland_jack> for example
05:43:47 <Iceland_jack> :t Data.Text.split
05:43:48 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
05:43:55 <Iceland_jack> works with a regular predicate on Char
05:44:13 <Algebr> nice, thanks
05:47:53 <bernalex> am I being stupid or what's how uh wat??? brain!!! cooperate!
05:47:57 * hackagebot varan 0.3 - Process mpileup output to identify significant differences  http://hackage.haskell.org/package/varan-0.3 (KetilMalde)
05:48:20 <bernalex> I want to do f a b -> f (f a b) b -> f (f (f a b) b) b etc.
05:48:56 <ion> For which f?
05:49:16 <bernalex> f :: [String] -> [String] -> [String]
05:50:21 <bernalex> a & b are [String]. so what I want to do is f a b then f (f a b) b then etc until the result of it is the same as b (takeWhile or whatever)
05:50:45 <snyp> pjdelport: i see. the book i am reading has joins in the next chapter. will continue the education. thanks.
05:50:52 <ion> > iterate (\a' -> f a' b) a
05:50:53 <lambdabot>  [a,f a b,f (f a b) b,f (f (f a b) b) b,f (f (f (f a b) b) b) b,f (f (f (f (f...
05:51:07 <bernalex> ion: that's the one. thanks.
05:51:30 * ion interpreted that as a type at first because of the ->s
05:51:50 <bernalex> yep I thought about it when it was too late :3 sorry
05:51:55 <pjdelport> snyp: A type like IO probably makes it easiest to see this. Imagine you had: IO (IO (IO a))
05:52:19 <pjdelport> Oh, nevermind then :)
05:52:58 * hackagebot cabal-debian 4.15 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.15 (DavidFox)
05:58:53 <adimit> what kind of lambdabot-magic is behind ion's iterate example there? It spits out a reduced form? Does λBot just reduce as far as it can WHNF, and then bails on the undefined symbols f, a?
05:59:05 <darthdeus> is there a way to turn off GC via RTS options?
05:59:12 <ion> @hackage simple-reflection  --adimit
05:59:12 <lambdabot> http://hackage.haskell.org/package/simple-reflection  --adimit
05:59:18 <ion> huh
05:59:33 <lavinia> @hackage simple-reflect
05:59:33 <lambdabot> http://hackage.haskell.org/package/simple-reflect
05:59:54 <lavinia> it's less magic than you may think: lambdabot simply predefines all one-letter variables
06:00:02 <lavinia> :t x
06:00:03 <lambdabot> Expr
06:00:38 <adimit> lavinia, ion, thanks. So they'e just predefined as Expr.
06:00:41 <adimit> > x
06:00:42 <lambdabot>  x
06:00:50 <lavinia> :t f
06:00:50 <pjdelport> > foldr f x [1..5]
06:00:51 <lambdabot> FromExpr a => a
06:00:52 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 x))))
06:00:57 <lavinia> f is a vararg function
06:00:59 <adimit> … ok. That explains it a bit :-)
06:01:17 <lavinia> > 1 + 1 :: Expr
06:01:18 <lambdabot>  1 + 1
06:01:23 <adimit> yes, with a fully polymorphic type.
06:02:08 <adimit> ok, I get it now. Nifty, it could come in handy to show people recursive structures.
06:02:51 <bernalex> thanks to whoever sent lambdabot into #plaimi!
06:03:02 <lavinia> it's awesome combined with deriv
06:03:07 <bernalex> int-e presumably? cheers!
06:05:01 <lavinia> http://hackage.haskell.org/package/numbers/docs/Data-Number-Dif.html
06:06:42 <cschneid> Is there a guide on what each major top-level package "means" -- I'm writing a library to talk to Graphite as a client, would that be Net.Graphite.Client?
06:06:49 <cschneid> seems like haskell discourages cutesy names
06:07:09 <cschneid> although you do have projects like Scotty, Yesod, Snap, etc, which are made-up names, not strictly utilitarian.
06:07:21 <lavinia> http://hackage.haskell.org/package/loli
06:33:04 * hackagebot cabal-install 1.18.0.5 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.5 (JohanTibell)
06:33:53 <systemfault> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot How do I know if it uses blocking or unblocking IO?
06:35:55 <copumpkin> systemfault: on the OS-level, almost all Haskell IO using non-blocking IO APIs
06:36:07 <copumpkin> systemfault: at the API level, almost all Haskell IO is blocking
06:36:12 <copumpkin> (in GHC)
06:37:26 <codygman> It is pretty straight-forward to get the cookiejar of a response with Wreq, but I'm confused at how I would get all the cookie names and values. Here is my sample code just getting the cookiejar: http://lpaste.net/107469
06:37:28 <tnks> copumpkin: do you tell which is which from the documentation?  Or is there a better way?
06:37:31 <Algebr> Haskell wiki books says this on do notation: "... In comparison, monadic code with explicit binds and lambdas is something of an acquired taste."
06:37:57 <Algebr> That's generous, the explicit binds and lambdas for anything more than 3 lambdas is hideuous
06:37:59 <copumpkin> tnks: it's not something you should have to care about at all. You have to go way out of your way to not get non-blocking OS-level primitives
06:38:11 <systemfault> copumpkin: So what behavior should I expect from the code I linked? It look API-related so it’s blocking?
06:38:26 <copumpkin> yeah, it's blocking
06:38:35 <copumpkin> if you ask for some data, it needs to provide that and it might not be there
06:38:51 <systemfault> I see
06:38:54 <systemfault> Thanks :)
06:39:12 <copumpkin> note that it doesn't come with the usual performance caveats you get with blocking IO and threads
06:39:23 <copumpkin> things usually work sensibly
06:40:14 <d3m1g0d-> > 1 + 1
06:40:15 <lambdabot>  2
06:40:16 <lavinia> Algebr: meh. the arrows point the other way, that's all
06:40:37 <d3m1g0d-> > negate . (* 3) $ 3
06:40:38 <lambdabot>  -9
06:41:01 <d3m1g0d-> >negate $ (*3) $ 3
06:41:17 <d3m1g0d-> > negate $ (*3) $ 3
06:41:17 <tnks> copumpkin: okay, so I think I understand what you're saying. . . a Haskeller should just think in terms of parallelism and concurrency, and GHC should optimize everything to non-blocking calls at the OS level?
06:41:18 <lambdabot>  -9
06:41:38 <d3m1g0d-> why is ?
06:41:42 <d3m1g0d-> negate . (* 3) $ 3
06:41:43 <d3m1g0d-> =
06:41:46 <d3m1g0d-> negate $ (*3) $ 3
06:41:51 <d3m1g0d-> i don't get function composition
06:42:03 <lavinia> d3m1g0d-: (f . g) x = f (g x)
06:42:35 <d3m1g0d-> actually correction, I don't get the difference between function composition and function application ($)
06:42:41 <lavinia> f $ x = f x
06:42:53 <d3m1g0d-> so ? Whats the difference in this exampole ?
06:42:54 <lavinia> $ takes a function and an argument (and returns a result)
06:43:00 <d3m1g0d-> both evaluate to -9
06:43:02 <lavinia> . takes two functions (and returns a combined function)
06:43:08 <lavinia> no difference here, obviously
06:43:11 <lavinia> just like 2 + 2 == 2 * 2
06:43:16 <staffehn> (f . g) $ x = f $ (g $ x)
06:43:17 <lavinia> but that doesn't mean + is the same as *
06:43:35 <staffehn> because (f . g) x = f ( g x)
06:43:47 <donri> i'm curious, what about haskell is it that makes a translation to non-blocking possible, even though network code is IO? why can't (?) your average imperative language do the same?
06:44:03 <tnks> copumpkin: sorry, I asked my question, but realized I have to take off. . . feel free to @tell me.
06:44:50 <d3m1g0d-> ok, thank you
06:45:47 <lavinia> hmm
06:46:25 <lavinia> if you replace the $ in your question by parens, you literally get "why is (negate . (* 3)) 3 the same as negate ((* 3) 3)?"
06:46:26 <augur> d3m1g0d-: composition and application are very distinct things
06:46:39 <lavinia> to which the answer is "because that's how . is defined"
06:46:44 <augur> d3m1g0d-: application takes a function and a value and puts the value through the function
06:47:20 <augur> deavid: eg, if your function is fac :: Int -> Int then applying fac to 5, ie fac 5, computes to 120
06:47:25 <augur> er, d3m1g0d- ^
06:47:51 <augur> d3m1g0d-: oh the other hand, composition chains functions, it plugs them together to form a new function
06:48:19 <augur> for instance, using    show :: Int -> String,   we can do  show . fac :: Int -> String
06:48:51 <lavinia> oh, another way to look at it: one version says "apply g to x, then apply f to the result of that (i.e. f (g x))"
06:48:53 <augur> show.fac is a _new_ function, which takes an Int in, computes the factorial, and then feeds that into show, returning the result of the show computation
06:49:10 <lavinia> the other version: "compose f and g into a single function, then apply that to x (i.e. (f . g) x)"
06:49:31 <staffehn> lavinia: It's interesting though that this holds for..
06:49:46 <augur> d3m1g0d-: you might not see the point from examples like this:   show.fac $ 5   which computes to the string "120"
06:49:52 <staffehn> lavinia: f . g . h . i . j . k $ x = f $ g $ h $ i $ j $ x
06:50:02 <lavinia> staffehn: why?
06:50:09 <d3m1g0d-> actually wait, this still doesnt make any sense.     f( g( z x )) x = f $ g $ z x = (f . g . z) x
06:50:17 <d3m1g0d-> they're almost equivalent
06:50:21 <lavinia> staffehn: it's just repeated application of the definition of (.)
06:50:22 <staffehn> lavinia: that in this case still it seems the (.) is the same as the ($)
06:50:23 <augur> d3m1g0d-: but consider instead this:   filter (even.fac) [0..]
06:50:39 <staffehn> lavinia: because the parens work out like that
06:50:42 <augur> d3m1g0d-: dont worry about $ for now
06:50:49 <d3m1g0d-> filter $ even $ fac [0..]
06:50:49 <d3m1g0d-> ?
06:50:53 <augur> d3m1g0d-: pretend $ doesnt exist
06:51:03 <augur> d3m1g0d-: nope! so like i said, even.fac is a _new_ function
06:51:46 <willbuntu> I want to find positive multiples of an integer less than another integer, and I don't understand - why can't I tell Haskell to test numbers forever until it reaches that other integer? It technically "works", but when the end of the list is reached, no closing bracket is printed in GHCi and the program hangs until I interrupt it.
06:51:48 <augur> d3m1g0d-: lets define   evenFac = even . fac
06:51:52 <lavinia> ... all of these are redundant uses of $
06:52:01 <willbuntu> http://lpaste.net/107471
06:52:03 <augur> d3m1g0d-: now, if we do   `evenFac 5`  it computes to True
06:52:06 <staffehn> lavinia: and appearently I missed the k.
06:52:12 <augur> because fac of 5 is 120, and 120 is even
06:52:18 <lavinia> i.e. ones that only use $ as a form of syntactic sugar to replace ( )
06:52:42 <augur> d3m1g0d-: does that make sense?
06:52:44 <lavinia> willbuntu: you didn't tell it to stop
06:52:53 <lavinia> willbuntu: the list never ends
06:53:03 <willbuntu> But the condition after the comma - that won't make it stop?
06:53:05 <d3m1g0d-> yes, but in actually code that doesn't make too much of a difference. So what if you created a new function?
06:53:12 <lavinia> willbuntu: no, that just filters out some elements of the list
06:53:22 <augur> d3m1g0d-: well, so now lets look at the filter example
06:53:31 <lavinia> willbuntu: but the list keeps generating and filtering elements, never producing anything
06:53:39 <willbuntu> So how do I make it stop - am I forced to lose generalization in favor of not using an infinite list?
06:53:56 <augur> d3m1g0d-: if we do   filter evenFac [0..]   we should get out the numbers whose factorials are even
06:54:06 <lavinia> willbuntu: takeWhile (\x -> x*4 <= 500) [1 ..]
06:54:07 <frerich> willbuntu: You can use "takeWhile (<= 500) [x*4 | x <- [1..]]"
06:54:09 <augur> mm.. let me define factorial for the example
06:54:23 <lavinia> oh, right. you have x*4 in the result again
06:54:25 <augur> @let fac n = foldl' (*) 1 [1..n]
06:54:27 <lambdabot>  Defined.
06:54:30 <augur> > fac 5
06:54:32 <lambdabot>  120
06:54:33 <augur> ok good
06:54:39 <augur> d3m1g0d-: so now:
06:54:54 <augur> > let evenFac = even.fac in filter evenFac [0..]
06:54:55 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
06:55:09 <willbuntu> lavinia, frerich: thanks
06:55:12 <augur> i guess every number except 0 and 1 has an even factorial!
06:55:30 <lavinia> how odd
06:55:37 <augur> d3m1g0d-: you see how this worked?
06:55:47 <d3m1g0d-> wait .... processing ...
06:56:25 <ajcoppa> :t even
06:56:26 <lambdabot> Integral a => a -> Bool
06:56:28 <frerich> augur: Your definition of 'fac' reminded me of that web page with a lot of
06:56:33 <augur> frerich: :)
06:56:43 <augur> frerich: i wouldve done the prod version but i dont know if prod(uct) is defined
06:56:44 <augur> :t prod
06:56:45 <lambdabot>     Not in scope: ‘prod’
06:56:46 <lambdabot>     Perhaps you meant ‘pred’ (imported from Prelude)
06:56:46 <frerich> augur: 'factorial' definitions with ever increasing complexities. Ultimately ending in 'product'
06:56:48 <augur> :t product
06:56:49 <lambdabot> Num a => [a] -> a
06:56:51 <frerich> augur: Ah heh :)
06:56:52 <augur> ah there we go
06:57:04 <pjdelport> augur: Every n >= 2 has a factorial divisible by 2, even n >= 3 has a factorial divisible by 3, etc. :)
06:57:06 <augur> frerich: going in a loop, actually! starting at product, ending at product. :D
06:57:11 <copumpkin> @tell tnks yeah, the goal is to give you a sensible concurrency model in which you can write straightforward sequential code that uses blocking calls and thousands of threads at very little cost. It uses fast non-blocking IO behind the scenes and so on, so you don't have to worry in 99% of cases
06:57:11 <lambdabot> Consider it noted.
06:57:25 <augur> pjdelport: yes, it was a rhetorical move :P
06:57:29 <frerich> augur: Really? Hah!
06:58:27 <augur> frerich: yeah. the point is to joke about how things get really complex when you're progressing into the realm of deeper understanding, graduate studies, etc. and how they vastly simplify again once you're a professor trying to teach the core concept
06:58:29 <augur> s
06:59:02 <pjdelport> http://www.willamette.edu/~fruehr/haskell/evolution.html ?
06:59:10 <augur> frerich: like, you want to be able to deploy rich, complex categorical interpretations when necessary, but default to justified, non-categorical intuitions like product [0..n]
06:59:13 <augur> pjdelport: yeah, thats the one
06:59:46 <RchrdB> augur, product [1..n]. You know why [0..n] won't do anything helpful for most (Num) types. =)
06:59:49 <augur> tho i recall it defining fac initially using product [0..n]
07:00:04 <augur> RchrdB: what?
07:00:55 <RchrdB> augur, product [0..n] = 0 * product [1..n] -- by the definitions of product and enumFromTo.
07:01:01 <frerich> Well if you start with '0 * ...' there's nowhere you can go...
07:01:05 <augur> oh whoops, i typoed :D
07:01:07 <RchrdB> augur, there is a small problem with the above ↑ as a definition of 'fac'. =D
07:01:18 <augur> luckily the definition i put into lambdabot is fine
07:01:27 <RchrdB> ;)
07:01:28 <augur> d3m1g0d-: so does that example make sense?
07:02:07 <d3m1g0d-> no, my mind is too polluted from the imperative programming
07:02:07 <d3m1g0d-> let evenFac = even.fac in filter evenFac [0..]
07:02:15 <d3m1g0d-> no idea why that works at all
07:02:29 <staffehn> d3m1g0d-: The ($) function is most oftenly used to omit parens (i.e. f $ g x = f (g x)). The (.) function on the other side is most oftenly used to omit lambda expressions for function application. If you take "filter (even.fac) [0..]" you mean "filter (\x -> even (fac x)) [0..]". If you on the other hand use (.) and directly apply the result liek in "f . g $ x" you have the lambda "(\y -> f (g y)) x" and can eta-reduce to "f (g x)" in which case
07:02:30 <staffehn> the (.) function was not really needed.
07:02:32 <augur> d3m1g0d-: ok lets use an example from JS
07:02:59 <augur> d3m1g0d-: function compose(f,g) { return function (x) { return f(g(x)); }; }
07:03:03 <augur> d3m1g0d-: yes?
07:03:14 <d3m1g0d-> yes
07:03:23 <augur> d3m1g0d-: in haskell you would instead write
07:03:31 <augur> compose f g = \x -> f (g x)
07:03:38 <augur> yes?
07:03:54 <Iceland_jack> or
07:03:54 <Iceland_jack>     (compose f g) x = f (g x)
07:03:59 <augur> Iceland_jack: shhhh
07:04:02 <augur> im getting there
07:04:03 <Iceland_jack> (oops sorry!)
07:04:15 <d3m1g0d-> yes
07:04:25 <augur> Iceland_jack: one step at a time, with as little changes as possible to maintain clarity
07:04:45 <augur> d3m1g0d-: in haskell, we can use . as an infix operator (unlike in JS) so:
07:04:52 <augur> f . g = \x -> f (g x)
07:05:25 <d3m1g0d-> ok, thank you sir
07:05:46 <augur> d3m1g0d-: so even.fac == \x -> even (fac x)
07:06:00 <augur> which is like   compose(even,fac) == function (x) { return even(fac(x)); }
07:06:20 <d3m1g0d-> I understand that they're completely different, but theoretically I can achieve the same result with the $ ?
07:06:28 <d3m1g0d-> not creating a new function
07:06:33 <d3m1g0d-> but rather achieve the same result ?
07:06:35 <augur> d3m1g0d-: no, lets not consider $ for now
07:06:40 <augur> d3m1g0d-: ill come back to in briefly
07:06:45 <augur> it*
07:06:56 <augur> d3m1g0d-: so does it make sense what's going on with
07:07:06 <augur> > filter (even.fac) [1..]
07:07:09 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
07:07:12 <augur> ?
07:07:33 <d3m1g0d-> ok ...
07:08:21 <augur> the JS analog is (roughly, since JS lacks range arrays):   [1..].filter(compose(even,fac))
07:08:41 <augur> JS's filter is a method on arrays, of course. not a function
07:08:43 <d3m1g0d-> i completely undestand that
07:08:50 <augur> you could define a filter function of course
07:08:55 <int3__> are double fmaps (fmap . fmap) considered a code smell? I seem to be doing that fairly often in my code
07:08:57 <augur> filter([1..], compose(even,fac))
07:09:18 <augur> d3m1g0d-: so,   filter (even.fac) [1..]
07:09:18 <int3__> for containers of Maybes, amongst other things
07:09:52 <augur> d3m1g0d-: no need to define a new variable `evenFac`. and it doesnt matter many chained things we do.   filter (foo.bar.baz.quux) [1..]
07:11:38 <d3m1g0d-> yes sir, i understand that and my life would be much easier if there was no $, but my question is in what situations I cant achieve the same result
07:11:51 <d3m1g0d-> if you give me such an example, it will be the actual information that i'm sseeking
07:11:54 <augur> d3m1g0d-: ok, so now lets talk aboue $
07:12:10 <augur> d3m1g0d-: $ is nothing more then the function application function
07:12:15 <augur> f $ x = f x
07:12:21 <d3m1g0d-> yes
07:12:28 <augur> eg in JS:   function apply(f,x) { return f(x); }
07:12:37 <augur> but, it has VERY low precedence
07:12:47 <donri> int3__: do you mean fmap f . fmap g as opposed to fmap (f . g)?
07:12:51 <kgadek> anybody here to talk about type theory? in particular: unification algorithm in Hindley Milner?
07:13:06 <augur> and its right associative, whereas normal application has MAXIMUM precedence and is left associative
07:13:11 <d3m1g0d-> i know that, sir
07:13:46 <staffehn> donri: He means (fmap (fmap f)) for example on [Maybe x]
07:13:47 <augur> d3m1g0d-: so this:   f $ g $ h $ x   ==   f (g (h x))
07:14:01 <augur> whereas this:   f g h x == ((f g) h) x
07:14:13 <d3m1g0d-> yes
07:14:29 <int3__> donri: no, (fmap . fmap) f xss
07:14:32 <d3m1g0d-> i undestand left and right associations
07:14:45 <int3__> donri: as opposed to... I don't know, some kind of better design, heh
07:14:46 <donri> :t fmap fmap fmap `asTypeOf` (fmap . fmap)
07:14:47 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:14:48 <augur> d3m1g0d-: $ is pretty noisy tho, so sometimes/often people will use . to compose a bunch of functions
07:14:48 <donri> mwahah
07:15:03 <augur> d3m1g0d-: so instead of writing this:   f $ g $ h $ x   they'll write   f.g.h $ x
07:15:04 <donri> int3__: not code smell IMO; it's what lens is based on for one
07:15:17 <d3m1g0d-> why is it considered to be noisy ?
07:15:23 <int3__> mm okay
07:15:51 <augur> d3m1g0d-: well, $ is big. as big as any other character, whereas . is tiny
07:16:05 <donri> (.) is friendlier to refactoring than ($)
07:16:30 <augur> d3m1g0d-: so   `f $ g $ h $ x`   is harder to read than `f.g.h $ x`   if you want to think about plugging functions together and then feeding a value in at the end
07:16:59 <d3m1g0d-> sir, since everything in the programming languages is a function, does that mean that function composition can always be replaced with function application in order to produce the same result
07:17:04 <d3m1g0d-> that was my primary question
07:17:05 <augur> d3m1g0d-: no!
07:17:11 <augur> d3m1g0d-: not everything is a function
07:17:14 <augur> FUNCTIONS are functions!
07:17:15 <donri> @where everything-is-a-function
07:17:15 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:17:18 <RchrdB> kgadek, IIRC there's a #haskell-in-depth channel for theory-heavy  stuff.
07:17:47 <int3__> http://conal.net/blog/posts/everything-is-a-function-in-haskell/ hur hur
07:17:52 <augur> i dont know who invented this "everything is a function" nonsense but its utterly bullshit
07:18:15 <donri> everything in haskell is a function in the same sense that everything is a list, ie. not.
07:18:17 <kgadek> RchrdB: oh yes, it exists indeed, thanks
07:18:29 <augur> there is no sense (except some silly joke-y math-y sense) which its true
07:18:34 <augur> its just absolutely false
07:18:45 <augur> d3m1g0d-: you can tell when something is a function because it has -> in its type
07:18:47 <augur> d3m1g0d-:
07:18:49 <augur> :t fac
07:18:50 <lambdabot> (Num a, Enum a) => a -> a
07:18:52 <d3m1g0d-> so lets try for the 700th time to ask ... can i always achieve the same thing with . as i can with $
07:18:52 <d3m1g0d-> ?
07:18:54 <augur> :t even
07:18:54 <lambdabot> Integral a => a -> Bool
07:18:59 <augur> :t 5
07:19:00 <lambdabot> Num a => a
07:19:01 <bjornars> d3m1g0d-: no
07:19:04 <augur> :t "a"
07:19:05 <lambdabot> [Char]
07:19:08 <d3m1g0d-> bjornars:  eaxmple please
07:19:10 <RchrdB> kgadek, I'm not telling you that you *shouldn't* talk about that here, just that I think you're more likely to get a good conversation about it if you start it there.
07:19:22 <donri> every function is a value but not every value is a function. function is but one of many types of values.
07:19:32 <augur> d3m1g0d-: no, because $ and . are very different things
07:19:36 <johnw> the empty set is not a function in any sense
07:19:40 <kgadek> RchrdB: I know :)
07:19:43 <augur> johnw: sure it is!
07:19:49 <augur> johnw: but lets not go there right now :)
07:19:52 <RchrdB> kgadek, btw, if you have a specific boggle, don't ask to ask ("does anyone here know about HM unification?") because in #haskell-in-depth, someone almost certainly will. Ask your question right off the bat and you're much more likely to pique someone's interest. =)
07:19:58 <d3m1g0d-> augur:  they are different but we can  always achieve the same result ?
07:20:01 <johnw> augur: oh?
07:20:04 <augur> d3m1g0d-: no
07:20:09 <d3m1g0d-> example
07:20:12 <augur> d3m1g0d-: fac $ 5 == fac 5 == 120
07:20:13 <bjornars> d3m1g0d-: mangle x = (*2) . (+4)
07:20:23 <bjornars> d3m1g0d-: mangle = (*2) . (+4)
07:20:25 <augur> d3m1g0d-: where is nothing you can do with . here
07:20:25 <bjornars> i mean
07:20:30 <augur> bjornars: leave it be
07:20:35 <donri> > map ($ 3) [(3+), (3*)]
07:20:36 <augur> d3m1g0d-: there**
07:20:37 <lambdabot>  [6,9]
07:20:45 <kgadek> RchrdB: I'll admit I wanted someone to tell me "go to chanell #X" ;)
07:21:02 <kgadek> because I feel that #haskell is not a perfect place for such questions
07:21:20 <augur> d3m1g0d-: does that make sense? there is no way to use . to combine fac and 5
07:21:36 <kgadek> ie. someone would answer but I feel it's not the chanell topic ; )
07:21:41 <donri> note the common style of a.b.c$x where that dollar can not be replaced by a dot to do the same thing
07:21:46 <augur> d3m1g0d-: you could introduce OTHER functions into the question, such as the identity function, but that would be a different thing
07:21:50 <staffehn> d3m1g0d-: The only reason why in "f . g . h $ x" and " f $ g $ h $ x" the . and $ appear to do the same is that you son't see the implicit parens from the precedence"
07:22:19 <staffehn> d3m1g0d-: really "f . g . h $ x" is "(f . (g . h)) $ x"
07:22:20 <augur> d3m1g0d-: in _certain_ situations you can swap $ and . but not in all situations
07:22:39 <staffehn> d3m1g0d-: and "f $ g $ h $ x" is "f $ (g $ (h $ x)"
07:22:41 <donri> (.) creates a function (as the composition of two other) and ($) applies a function (to an argument)
07:22:50 <augur> d3m1g0d-: and the reason its possible at all is determined entirely by the definitions of each
07:22:58 <augur> johnw: ok, yes, so
07:23:11 <augur> johnw: of course the empty set is a function, if you're into set-theoretic interpretations of functions, etc.
07:23:12 * hackagebot uhc-util 0.1.3.5 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.5 (AtzeDijkstra)
07:23:15 <d3m1g0d-> ok lets start with this
07:23:16 <d3m1g0d-> d3m1g0d-: mangle x = (*2) . (+4)
07:23:27 <d3m1g0d-> mangle x = (*2) $ (+4) $ x
07:23:27 <staffehn> d3m1g0d-: In all these situations you could omit the $ for parens so really "f . g . h $ x" is "(f . (g . h) x"
07:23:30 <augur> drop the x, but yes
07:23:30 <d3m1g0d-> absolutely equivallent result
07:23:44 <augur> deavid: yes
07:23:45 <staffehn> d3m1g0d-: and "f $ g $ h $ x" is "f (g (h x))"
07:23:48 <augur> grr, d3m1g0d-**
07:23:53 <augur> d3m1g0d-: but try this instead:
07:23:58 <augur> foo x = (+4) $ x
07:24:14 <augur> d3m1g0d-: you cant replace $ with . here at all
07:24:32 <augur> watch:
07:24:38 <augur> > (+4) . 5
07:24:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
07:24:40 <lambdabot>    arising from a use of ‘M18510366640919535824308.show_M18510366640919535824...
07:24:40 <lambdabot>  The type variable ‘a0’ is ambiguous
07:24:40 <lambdabot>  Note: there are several potential instances:
07:24:40 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:24:46 <augur> > (+4) $ 5
07:24:47 <lambdabot>  9
07:24:48 <donri> well you can, but it infers a different type :)
07:25:01 <augur> donri: yeah because lambdabot is awful
07:25:04 <augur> :P
07:25:05 <int3__> d3m1g0d-: for a slightly less trivial example, there's `f x = map ($ x) [(+1), (+2), (+3)]`
07:25:12 <donri> well not just lambdabot
07:26:46 <augur> donri: ahh right, its going to treat 5 generically as a num a not as an Int, say
07:26:52 <d3m1g0d-> x is not a function
07:26:56 <d3m1g0d-> we're talking in terms of functions
07:26:57 <augur> d3m1g0d-: right!
07:27:09 <augur> d3m1g0d-: so you cant compose x with something, because . _composes functions_!
07:27:31 <augur> d3m1g0d-: so if x is not a function, then f . x is nonsense!
07:27:43 <augur> its like doing   compose(f,5)   in javascript
07:27:46 <d3m1g0d-> its an argument ment
07:27:50 <d3m1g0d-> $ makess no sense here
07:28:00 <augur> ?
07:28:10 <d3m1g0d-> foo x = (+4) $ x
07:28:13 <d3m1g0d-> how does this make sense ?
07:28:13 <augur> $ of course can be used, because $ is just application
07:28:14 <staffehn> talking about the "f x = map ($ x) [(+1), (+2), (+3)]"?
07:28:20 <augur> deavid: because $ is just application!
07:28:33 <augur> damnit
07:28:35 <augur> d3m1g0d-: ^
07:28:40 <staffehn> d3m1g0d-: Try this....
07:28:43 <Iceland_jack> d3m1g0d-: Because (+4) is a function
07:28:54 <ajcoppa> :t (+4)
07:28:55 <lambdabot> Num a => a -> a
07:28:57 <augur> d3m1g0d-:
07:29:01 <augur> > (+4) 5
07:29:03 <lambdabot>  9
07:29:15 <staffehn> d3m1g0d-: In all the use cases we had so far you could omit all the "$"s by using just some parenthesis.
07:29:16 <d3m1g0d-> so ?
07:29:22 <augur> d3m1g0d-: so what?
07:29:35 <Iceland_jack> d3m1g0d-: If you understand
07:29:35 <Iceland_jack>     (+4) 5
07:29:35 <Iceland_jack> then you understand
07:29:35 <Iceland_jack>     (+4) $ 5
07:29:54 <donri> @src ($)
07:29:54 <lambdabot> f $ x = f x
07:29:57 <cschneid> I've got a 2 element DataPoint record that I'm trying to Aeson a FromJSON instance.  `data DataPoint = DataPoint Int Int`, the json is [1,2] for instance.  How do I get at the first & second elements of that array?
07:30:04 <Tjr> staffehn: in your map example, how does the $ in "($x)" know that x is supposed to be the argument, not the function?
07:30:08 <augur> d3m1g0d-: there's really nothing to not make sense. its DEFINITIONAL
07:30:20 <augur> d3m1g0d-: if i as you, "what is f $ x"? your answer should be "f x"
07:30:24 <d3m1g0d-> staffehn: I do undestand that you can omit parenthesis with $, what noone has provided so far is a sensible example, where you can't replace . with $ in order to produce the same result
07:30:25 <augur> d3m1g0d-: its just _defined_ to be that
07:30:28 <int3__> Tjr: because if it were a function, it'd be (x $)
07:30:31 <frerich> d3m1g0d-: I'm not sure I understand what you're asking. Are you asking what '$' is good for, why it was defined in the first place?
07:30:36 <augur> so (+4) $ x is DEFINITIONALLY (+4) x
07:30:59 <ajcoppa> Tjr: ($ x) lets x act as the second argument to ($), whereas (x $) would cause x to act as the first argument to ($)
07:31:01 <staffehn> d3m1g0d-: sure just the filter (even.fac) [0..] example
07:31:05 <Tjr> int3__: oh, I see. So my error was thinking map (($) x ) [somelist]
07:31:06 <augur> d3m1g0d-: ok lets show that example
07:31:12 <donri> > ((+a) b, (a+) b)
07:31:13 <lambdabot>  (b + a,a + b)
07:31:14 <augur> d3m1g0d-: consider:
07:31:21 <augur> > (even.fac) 5
07:31:23 <lambdabot>  True
07:31:26 <augur> d3m1g0d-: now consider:
07:31:31 <augur> > (even $ fac) 5
07:31:33 <lambdabot>  Couldn't match expected type ‘a1 -> t’
07:31:33 <lambdabot>              with actual type ‘GHC.Types.Bool’
07:31:47 <d3m1g0d-> > even $ fac $ 5
07:31:49 <lambdabot>  True
07:31:53 <augur> yes
07:32:16 <augur> d3m1g0d-: thats because  (even $ fac) 5  ==  (even $ fac) $ 5
07:32:29 <augur> d3m1g0d-: whereas   even $ fac $ 5 == even $ (fac $ 5)
07:32:36 <augur> d3m1g0d-: $ is right associative!!
07:32:44 <d3m1g0d-> I DO UNDERSTAND THAAT
07:32:48 <d3m1g0d-> what i need is an example
07:32:48 <augur> d3m1g0d-: apparently not
07:32:52 <augur> i just gave you one
07:32:54 <augur> d3m1g0d-: look.
07:33:13 * hackagebot htsn 0.1.0 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.1.0 (MichaelOrlitzky)
07:33:14 <xplat> d3m1g0d-: map (even . ord) "happy"
07:33:16 <augur> even $ fac $ 5   is not the same thing as   (even $ fac) 5
07:33:21 <augur> d3m1g0d-: do you understand why?
07:33:30 <xplat> > map (even . ord) "happy"
07:33:32 <lambdabot>  [True,False,True,True,False]
07:33:52 <d3m1g0d-> augur:  I FULLY undestand why that is , but still i can produce the sae result
07:33:56 <d3m1g0d-> with less paranthessies
07:34:05 <augur> d3m1g0d-: well sure, that might be true, but so what?
07:34:12 <augur> d3m1g0d-: you werent asking for a comparison with less parens
07:34:18 <Tjr> > map even . ord "happy"
07:34:19 <lambdabot>  Couldn't match expected type ‘a -> [a0]’
07:34:20 <lambdabot>              with actual type ‘GHC.Types.Int’Couldn't match expected type ‘GH...
07:34:20 <lambdabot>              with actual type ‘[GHC.Types.Char]’
07:34:22 <staffehn> d3m1g0d-: I stated half an hour ago: The ($) function is most oftenly used to omit parens (i.e. f $ g x = f (g x)). The (.) function on the other side is most oftenly used to omit lambda expressions for function application. If you take "filter (even.fac) [0..]" you mean "filter (\x -> even (fac x)) [0..]". If you on the other hand use (.) and directly apply the result liek in "f . g $ x" you have the lambda "(\y -> f (g y)) x" and can eta-reduce
07:34:22 <staffehn> to "f (g x)" in which case the (.) function was not really needed.
07:34:23 <augur> you were asking for a case where you cant swap $ for . and vice versa
07:34:36 <augur> d3m1g0d-: i gave you an example of cases for both directions of the swap
07:34:42 <staffehn> d3m1g0d-: Do you understand all that? Or where's your problem?
07:34:47 <augur> d3m1g0d-: parens be damned, i showed you want you wanted to see
07:35:00 <augur> d3m1g0d-: the fact that you can do it with less parens is irrelevant
07:35:23 <augur> johnw: beep
07:35:44 <int3__> d3m1g0d-: did you understand my `map` example? it's something that really can't be rewritten in terms of (.) and extra parens
07:35:44 <xplat> > filter (even . fac) "happy"
07:35:45 <d3m1g0d-> very very unconvincing examplanations
07:35:45 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Char)
07:35:46 <lambdabot>    arising from a use of ‘GHC.Real.even’No instance for (GHC.Num.Num GHC.Type...
07:35:46 <lambdabot>    arising from a use of ‘L.fac’
07:35:56 <augur> d3m1g0d-: unconvincing my ass
07:36:01 <xplat> > filter (even . ord) "happy"
07:36:02 <lambdabot>  "hpp"
07:36:15 <augur> d3m1g0d-: you dont like the examples, oh well
07:36:20 <augur> but they do exactly what you asked for
07:36:24 <frerich> d3m1g0d-: For what it's worth, in the very beginning of me learning Haskell, I was sometimes confused about when to use '.' and '$', too.
07:36:48 * Tjr agrees with frerich 
07:36:51 <int3__> augur: eh, the problem is that he doesn't know how to express his question precisely. no point raging on the same thing over and over. figuring out what the right question is is the hardest part
07:37:39 <augur> int3__: probably, but then he should figure out how to ask the question better, rather than being a dick when the answer he gets isnt what he wanted
07:38:14 <Tjr> augur: I've been on the other side of such debates, and it's easy to be a dick involuntarily.
07:38:51 <bjornars> how about this: yes d3m1g0d-, (.) and ($) are totally the same thing, and are always interchangable
07:38:51 <augur> Tjr: yes.
07:39:01 <johnw> augur: how is it a set-theoretic function?
07:39:22 <augur> johnw: a set theoretic function f : A -> B is left-total subset of A x B right?
07:39:24 <d3m1g0d-> how am I a dick ? you're explaining things that I already know. Since the beginning I was asking for an example in which $ and . differ and I can't achieve the same result by replacing them
07:39:37 <johnw> augur: sure
07:39:38 <augur> d3m1g0d-: i gave you examples that prove that they cant be interchanged
07:39:42 <int3__> d3m1g0d-: you need to be precise about 'differ'
07:39:45 <augur> d3m1g0d-: i gave you examples. fucking. examples.
07:39:46 <d3m1g0d-> congradulatiuons u gave me an example, where you cant replace one without the other and they differ in ( and )
07:40:02 <augur> d3m1g0d-: yes, so, therfore, you got what you wanted
07:40:06 <Tjr> augur, johnw: a set theoretic function f : A -> B is an ordered triple (A,B,G) where G is such a left-total subset of A x B
07:40:14 <frerich> d3m1g0d-: Consider "not $ True"  vs. "not . True"
07:40:24 <d3m1g0d-> frerich: dude that doesnt make any sense
07:40:28 <d3m1g0d-> we're talking in terms of functions
07:40:36 <d3m1g0d-> noone uses $ in terms of parameters
07:40:40 <d3m1g0d-> that doessnt make any sense
07:40:43 <augur> d3m1g0d-: what the fuck are you talking about
07:40:45 <Tjr> augur, johnw:  Many textbooks also demand that A is a non-empty set
07:40:47 <augur> of course it makes sense
07:40:56 <augur> johnw: so, take A = {}
07:40:57 <frerich> d3m1g0d-: What does "Talking in terms of parameters" mean?
07:41:07 <augur> johnw: then f : {} -> B is a subset of {} x B
07:41:34 <augur> johnw: since {} x B = {}, f must be {} too, since thats the only subset of {}
07:41:41 <augur> johnw: its left total, so everything checks out!
07:41:45 <d3m1g0d-> noone does that, function $ parameter
07:41:49 <d3m1g0d-> it doesnt make anys ense
07:41:54 <augur> d3m1g0d-: i do it all the time
07:41:58 <frerich> d3m1g0d-: Sure: For instance, in 'return $ Just something'.
07:42:05 <augur> d3m1g0d-: are you saying noone would WRITE that?
07:42:09 <d3m1g0d-> nononoonno no Just something
07:42:11 <d3m1g0d-> function $ parameter
07:42:19 <augur> or that it makes no sense as a program?
07:42:25 <frerich> d3m1g0d-: That's true, if you have 'f x' then there's no point to complicate that to 'f $ x'
07:42:35 <d3m1g0d-> ofc it doesnt make any sense, the fact that it's interpreted doesnt mean it makes ssense
07:42:49 <tippenein> function $ param1 $ function param2
07:42:59 <augur> d3m1g0d-: actually the fact that its interpreted is the most reasonably explanation of what sensible means, but ok
07:43:06 <augur> d3m1g0d-: why doesnt it make sense
07:43:07 <augur> elaborate
07:43:10 <d3m1g0d-> actually no its not
07:43:12 <augur> explain to us
07:43:15 <johnw> augur: ok, I buy it :)
07:43:18 <augur> johnw: :)
07:43:40 * frerich decides it's not so smart to get dragged into this and slowly scoots backwards to his hole in the wall...
07:43:44 <augur> johnw: and of course if you're talking about partial functions then {} is a function of any type, undefined everywhere
07:44:06 <Tjr> augur, johnw: FWIW, your example of "function inclusion" is known in mathematics as an ordering of partial functions. It's used in the proof of the Hahn-Banach separation theorem, for example.
07:45:21 <int3__> d3m1g0d-: the most precise formulation of your question I can think of is, is there an expression containing ($) that cannot be changed into one without ($) simply by adding (.)s, parens, and rearranging parameters? in that case `map ($ 5) [(+1), (+2), (+3)]` satisfies it
07:45:24 <d3m1g0d-> is there a fucking phd student here ?
07:45:30 <d3m1g0d-> i really cant deal with those guys that way
07:45:39 <int3__> okay, now you're being a dick.
07:46:39 <d3m1g0d-> No .... If i was a dick I would say something like "I can't believe that people like you won the cold war"
07:46:50 <d3m1g0d-> but I'm just asking for a PhD student
07:47:09 <Tjr> d3m1g0d-: what's your position in academia?
07:47:09 <augur> d3m1g0d-: maybe you should explain why f $ x doesnt make sense, how about that
07:50:51 <c_wraith> Huh.  Looking at Data.Monoid in base 4.7... Is there any reason the instance is Monoid (Proxy * s) instead of Monoid (Proxy k s)?
07:51:00 <Jefffrey> Hello
07:51:30 <c_wraith> hello Jefffrey.  How's haskell treating you?
07:51:32 <d3m1g0d->  .... and after that time wasted, I'm still no convinced that there are situations in which I can't replace function composition with function application.
07:51:49 <Jefffrey> c_wraith: Ok, I guess.
07:53:54 <Jefffrey> I was wondering: If I have `a >> b >> c` (3 IO actions) and `b` throws an exception (Control.Exception.throw), then `c` is not executed, right?
07:53:59 <osfameron> d3m1g0d-: please be polite.  but I suspect you're right -- after all there are turing complete languages that don't have (or facilitate) function composition
07:54:26 <tdammers> you can express composition by means of lambda and application
07:54:38 <tac_> Jefffrey: that should be right
07:54:40 <tdammers> so yes, you can always use application where you'd use composition
07:54:44 <tdammers> it's just crude
07:54:51 <augur> d3m1g0d-: fine, try the examples people showed you before.
07:54:54 <augur> d3m1g0d-: not the f $ x one
07:54:55 <d3m1g0d-> so my question , dear tdammers, is how do i stare polite
07:55:00 <d3m1g0d-> after these people wasted my time ?
07:55:07 <d3m1g0d-> *stay
07:55:08 <augur> d3m1g0d-: try   map ($ 5) [(+ 3), (* 3)]
07:55:18 <tdammers> idk, didn't follow the discussion, but I assume they were trying to tell you *something*
07:55:28 <augur> d3m1g0d-: you wasted your own time, and ours
07:55:34 <tac_> Jefffrey: This is actually explained by the great SPJ in his paper "The Awkward Squad". It lays out how exceptions are handled (at least theoretically) in Haskell's IO monad (among other things)
07:55:35 <tdammers> f . g is just way nicer than \x -> f (g x)
07:55:43 <augur> we were patient and gave you examples that did exactly what you were asking for
07:55:46 <bernalex> tac_: that's a great paper
07:55:48 <augur> repeatedly
07:56:02 <tac_> bernalex: SPJ has a way with writing great ones.
07:56:13 <augur> d3m1g0d-: if you cant explain what you consider "senseless" about writing f $ x, then we cant help you
07:56:20 <augur> no one knows what you mean anymore
07:56:33 <bernalex> tac_: pwadler too -- but they have interestingly different styles. which makes the co-authored papers real fun.
07:56:34 <lysergide___> Hi, is there an interest to learn Lisp if I know about Haskell?
07:56:44 <Iceland_jack> d3m1g0d-: Accusing others of wasting your time is not a good conversation starter, people here are not getting paid to answer questions
07:56:55 <bernalex> lysergide___: yes
07:57:09 <quchen> lysergide___: Implementing parts of Scheme is a popular exercise, if that counts.
07:57:10 <ion> lysergide: yes
07:57:11 <bernalex> lysergide___: lisp results in a kind of different revalation
07:57:18 <Jefffrey> tac_: You mean this: http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/?
07:57:37 <tac_> yep. that's the one
07:57:43 <lysergide___> quchen: What do you mean with implementing parts of Scheme?
07:57:56 <bernalex> lysergide___: there's a popular tutorial about writing a Scheme compiler in Haskell.
07:58:02 <c_wraith> Huh.  I have a bunch of suggestions for improvements to Data.Monoid.  Is libraries@ the only real place to suggest them?
07:58:10 <tdammers> @where scheme
07:58:10 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
07:58:11 <lysergide___> Oh that looks really great.
07:58:24 <lysergide___> Thank you !
07:58:25 <quchen> bernalex: It's only an interpreter, which makes it much easier.
07:58:49 <Tjr> c_wraith: I can't answer your question. But if you do find a place to post, would you mind sending me a pointer, please?
07:58:51 <bernalex> c_wraith: maybe #ghc, talk to edward kmett or other people you know on the commitee, etc.
07:59:22 <quchen> c_wraith: What's wrong with @libraries?
07:59:23 <tdammers> you can cheat yourself into a compiler by embedding the interpreter ;)
07:59:26 <edwardk> c_wraith: libraries@haskell.org is the usual place for suggested improvements
07:59:29 <bernalex> c_wraith: libraries list is mostly used for proposals. discussions are more at home in the café
07:59:36 <c_wraith> One of the suggestions is really dumb...  "compile it with PolyKinds enabled so the Proxy instance is more complete".
07:59:51 <c_wraith> But being really dumb makes it likely to be accepted!
08:00:09 <benzrf> lysergide___: why not try to do it without a tutorial?
08:00:14 <benzrf> it's WAY more fun
08:00:16 <benzrf> ( ͡° ͜ʖ ͡°)
08:00:16 <bernalex> c_wraith: if you have elquent proposals, libraries@h.o is the right place. see the archives for how they are generally written.
08:00:26 <bernalex> benzrf: uhm lysergide___ doesn't know scheme lol
08:00:29 <quchen> benzrf: Fun in the Dwarf Fortress sense maybe.
08:00:38 <benzrf> bernalex: oh
08:00:47 <benzrf> quchen: are you saying i'd like dwarf fortress
08:01:00 <benzrf> cuz i've written and rewritten a scheme about 3 times, each time after the last impl blew
08:01:05 <benzrf> and i have NEVER read that tutorial
08:01:09 <benzrf> （´＿｀）
08:01:11 <bernalex> benzrf: probably. it's real fun. too bad it's proprietary. perfect game to free. would have a lot of cool forks & mods.
08:01:22 <tdammers> yeah
08:01:27 <benzrf> bernalex: oh, it's prop?
08:01:30 <bernalex> benzrf: yeah =/
08:01:31 <benzrf> i didnt know ;-;
08:01:33 <tdammers> also, it's probably only proprietary out of ignorance
08:01:41 <benzrf> i kind of assumed it was free based on the fact that it's tileset-based
08:01:41 <benzrf> lo
08:01:43 <benzrf> *lol
08:01:54 <bernalex> tdammers: it's proprietary because the author doesn't want anyone to change it
08:02:01 <tdammers> yeah
08:02:03 <tdammers> ignorance
08:02:04 <bernalex> tdammers: sort of the "you wouldn't want people to modify mona lisa!!!" argument
08:02:05 <lysergide___> benzrf: I am not an expert in Haskell I believe the tutorial will really get me to a deeper understanding of Haskell, and I will learn Scheme too along the way.
08:02:15 <tdammers> ignorance or arrogance
08:02:20 <bernalex> tdammers: *very* common among game programmers
08:02:20 <benzrf> lysergide___: kk
08:02:24 <c_wraith> quchen: my problem with mailing lists is that I have a couple super-minor proposals that I'd like to make and follow through, but I don't want to follow all the discussion of other things on the list.  That is, list membership is too coarse of granularity.
08:02:34 <benzrf> lysergide___: scheme is just basically lisp if you know any basic lisp fyi
08:02:34 <tdammers> but I like to assume the best of people, so I'm going with ignorance
08:02:37 <bernalex> lysergide___: personally I recommend something like SICP
08:02:41 <shlevy> Can someone point me toa  good resource for starting with TH?
08:02:47 <tdammers> benzrf: scheme is a lisp
08:03:03 <benzrf> tdammers: yeah
08:03:05 <bernalex> shlevy: for what purpose?
08:03:07 <benzrf> 'swhat i meant
08:03:14 <c_wraith> Huh.  Is there a good resource for starting with TH?  I know I did things the *really* hard way for forever because I had no idea there were better ways.
08:03:21 <bernalex> shlevy: http://www.haskell.org/haskellwiki/Template_Haskell is quite general
08:03:30 <lysergide___> bernalex: Thank you.
08:03:36 <quchen> c_wraith: I see your point. However, there were quite a few of "suggestions 1-5, vote individually" threads open in the last months, I think yours might fit in there.
08:04:02 <lysergide___> I had no interest in programming anymore before I discovered haskell.
08:04:06 <benzrf> oh
08:04:07 <d3m1g0d-> augur: wow, actually this makes sense map ($ 5) [(*1),(*2)]
08:04:08 <benzrf> hah
08:04:12 <bernalex> edwardk: can you submit to libraries@h.o w/o subscribing?
08:04:15 <d3m1g0d-> i really can't do it with fuction composition
08:04:19 <bernalex> if so, c_wraith can submit & ask people to CC them
08:04:21 <d3m1g0d-> there, thank you sir. you're praised
08:04:30 <benzrf> lysergide___: scheme is simple
08:04:33 <shlevy> bernalex: want to see how hard it would be to generate a type-safe SQL AST given a schema definition
08:04:45 <benzrf> lysergide___: you usually have about 3 or 4 types of terms
08:04:52 <c_wraith> bernalex: spam probably goes way up when you don't have to subscribe. I wouldn't ask them to allow it if they don't already.
08:04:58 <bernalex> shlevy: OK I don't know any guide for that specifically. sorry! maybe someone else will though.
08:05:00 <benzrf> lysergide___: atoms, lists, sometimes numbers
08:05:02 <shlevy> bernalex: With the important point that the module creating the AST should have the option of not exporting the constructors of all terms
08:05:08 <Currier> I'm looking to get into functional reactive programming. I've been pointed towards the Rx framework, but ideally I'd prefer to work with haskell for this. Are there any good libraries for FRP?
08:05:32 <shlevy> bernalex: So I need some way to define the schema (needn't be able to be literally parse DDL, but somehow express that) and turn it into a set of AST types
08:05:32 <benzrf> lysergide___: an atom looks like "foo" [no quotes], a list looks like "(these are also terms)" [no commas]
08:05:38 <bernalex> Currier: reactive-banana is sort of state-of-the-art, no? and then there's wire
08:05:42 <c_wraith> bernalex: really, I'll subscribe.  I'm just complaining for a moment, but not vehemntly.
08:05:49 <augur> d3m1g0d-: ffs
08:05:49 <bernalex> c_wraith: *netwire
08:05:58 <bernalex> erm Currier ?
08:06:00 <bernalex> ^
08:06:01 <bernalex> GOD DAMN
08:06:04 <bernalex> TYPING HOW DO YOU EVEN
08:06:04 <benzrf> lysergide___: by default, a symbol on its own will be evaluated as a variable
08:06:06 <augur> d3m1g0d-: dont thank me, thank whoever it was who gave you that fucking example like 10 times before
08:06:06 <c_wraith> I think you got your (net)wires crossed. :)
08:06:15 <benzrf> lysergide___: so the expression "foo" will result in whatever foo is set to
08:06:18 <bernalex> c_wraith: it's not too high-traffic
08:06:22 <Currier> bernalex: Thanks, I'll have a look!
08:06:26 <benzrf> lysergide___: by default, a list on its own will be evaluated as function application
08:06:34 <bernalex> Currier: also maybe check out Elm since it's so easy to get started with
08:06:40 <int3__> lysergide___: if you can stand to parse obtuse english (or if you know french), Lisp In Small Pieces is a pretty wonderful book. it goes into all the gory implementation details, but gradually enough to not be too scary.
08:06:44 <bernalex> Currier: http://elm-lang.org/edit/examples/Intermediate/Mario.elm
08:06:50 <benzrf> lysergide___: so the expression "(foo bar baz)" will be evaluated as applying the function foo to the arguments bar and baz
08:06:56 <bernalex> Currier: it's an FRP lang implemented in haskell
08:07:01 <conal> Currier: btw, Rx isn't FRP, though often confused with FRP.
08:07:10 <shlevy> c_wraith: Any pointers for hard ways to avoid? :D
08:07:11 <bernalex> Rx is RP
08:07:17 <edwardk> bernalex: yes
08:07:21 <augur> d3m1g0d-: you and your crazy criteria for "sensible". no one has any clue what you mean. i hope you understand that.
08:07:30 <bernalex> c_wraith: see, you can post w/o subscribing
08:07:32 <Currier> bernalex: I've played with Elm a little bit, it was actually what initially sparced my interest in FRP
08:07:50 <benzrf> lysergide___: most lisps come with a few special forms like "quote", which let you control evaluation
08:07:51 <bernalex> Currier: note that there are very different forms of FRP. conal would be happy to tell you, I'm sure. ;-)
08:08:04 <bernalex> Currier: Evan's master thesis on the implementation of Elm talks a bit about it. worth a quick skim.
08:08:16 <benzrf> lysergide___: for example, "(quote (foo bar baz))" results in the list "(foo bar baz)", which is actually a list of atoms and not function application
08:08:20 <benzrf> lysergide___: no further evaluation
08:08:20 <c_wraith> shlevy: make sure you learn the details of how [| foo |] syntax (and the related bits) work.  They're huge time-savers as opposed to not using them.
08:08:49 <conal> Currier: the term "FRP" has gotten pretty diffuse in meaning, especially lately. see http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525
08:09:10 <shlevy> c_wraith: thanks!
08:09:31 <lysergide___> benzrf: I see !
08:09:37 <lysergide___> int3__: I am French so that will help ! Thanks
08:11:33 <Currier> conal: Thank you! That's a nice collection of papers to look at as well.
08:12:15 <conal> Currier: enjoy!
08:15:44 <c_wraith> whoa.  ConstraintKinds can make haddock's instance lists bizarre.  The instance list for Data.Monoid shows a bunch of things that are instances of Monoid....  and one thing Monoid is an instance of.
08:15:59 <tolt> has anyone seen http://hayoo2.fh-wedel.de/ ? The new Hayoo looks pretty nice!
08:16:15 <Tjr> I'm using RMonads (for something related to probabiltiy).
08:16:19 <c_wraith> It's kind of strange to think of a class as being an instance of something.
08:17:00 <Tjr> What are the issues to watch out for, in terms of integrating my library with other code? Are there good examples to learn from?
08:20:28 <MagneticDuck> hmm.
08:21:11 <MagneticDuck> anybody know a good project that a mildly-experienced (as in, never worked on a big project with other people but know stuff about haskell and can think straight) dude could help work on?
08:21:56 <shlevy> MagneticDuck: What're your interests?
08:22:09 <staffehn> tolt: wow, how long does this exist already?
08:22:16 <MagneticDuck> shlevy: math and stuff?
08:22:17 <MagneticDuck> :LD
08:22:20 <MagneticDuck> *:D
08:23:12 <etandel> MagneticDuck: GHC?
08:23:21 <danilo2> Hello! Could anyone explain to me, why all monad transformers in Haskell std lib are defined in such way, that for each transformer we get a type class (like MonadState) AND all instances for all other monads are defined by hand and not automatically? We can easly write something like this: http://lpaste.net/107473
08:25:14 <MagneticDuck> etandel: uh
08:25:42 <MagneticDuck> I don't know a lot about GHC and I doubt the little haskell theory I know would be sufficent to help them out
08:25:48 <MagneticDuck> looking for a simpler, fun project?
08:25:59 <MagneticDuck> I dunno xD
08:26:21 <quchen> danilo2: I think you can't write an instance for "MonadState s (t s m)" without extensions because of the duplicate s.
08:26:26 <Tjr> MagneticDuck: I've got this impression the numerics* support is pretty bad in haskell. (* careful consideration of rounding errors, etc)
08:26:56 <MagneticDuck> hm
08:27:13 <danilo2> quchen: Yes, you need to enable OverlappingInstances in the module where it is defined - why isnt it enabled in mtl by default?
08:27:21 <MagneticDuck> yeah that might be interesting
08:27:22 <shlevy> MagneticDuck: Well we're working on a reimplementation of the nix expression language in the hnix project
08:27:28 <Tjr> MagneticDuck: OTOH, numerics is the traditional bread and butter theme for mathematicians in industry. Therefore, I'd expect a good library to see some usage.
08:27:29 <MagneticDuck> nix?
08:27:55 <staffehn> danilo2: If you look at the instances for MonadState they use lift: http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#MonadState
08:28:10 <quchen> danilo2: That would make MTL GHC exclusive. (I'm not sure this is why we don't have the sort of autoderiving thing you mentioned, but that's what came up in my head.)
08:28:18 <staffehn> danielo2: but for example for MonadError they have special cases for the catch: http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-Error-Class.html#MonadError
08:28:25 <MagneticDuck> I'm no brilliant math PhD graduate or anything though <-- disclaimer
08:28:54 <shlevy> MagneticDuck: nix! http://nixos.org/nix/manual/#chap-writing-nix-expressions basically  untyped lambda calculus with some bells and whistles that make it really nice for declaring package descriptions
08:28:55 <quchen> MagneticDuck: Neither is Edwardk, who only got a master's if I recall correctly. Degrees are overrated.
08:29:16 <Tjr> who's edwardk?
08:29:19 <MagneticDuck> hackagebot: sounds fun
08:29:21 <MagneticDuck> Tjr: xD
08:29:31 <danilo2> quchen: Oh, then we should make mtl-ghc! This would be much easier to operate on. Look, now we have to define every instance by hand, but we can make compiler do this for us. Why have we to suffer from other compilers limitations
08:29:33 <MagneticDuck> edwardk, #haskell's guardian angel or something
08:29:35 <danilo2> quchen: ?
08:29:44 <MagneticDuck> he writes cool stuff a lot of the time
08:29:53 <danilo2> staffehn: I was not talking about lift, but about hand made instances
08:29:58 <quchen> danilo2: You'd still lose portability.
08:30:09 * Tjr doesn't remember names, especially no celebrity names.
08:30:12 <quchen> danilo2: But you're right, the current state is suboptimal.
08:30:18 <staffehn> danilo2: hand made because of the special cases
08:31:12 <danilo2> staffehn: special cases can be written using my "automatic instances" as well - OverlappingInstances will choose the most specific one
08:32:28 <staffehn> danilo2: Also I think it is the case that mtl and transformers are not the most modern state of research and I heared there are some alternatives that do manage the automatic derivation.
08:32:44 <danilo2> quchen: heh, that is strange :( I was always thinjking of Haskell as about a beautifull language, where everything is going in the "pure and beautifull" direction, but always when I look into mtl I'm scratching my head why it is so ugly. GHC is very powerfull, we should use this power. Most of the users are GHC-based. Additional, we could break portability with old libraries if new libraries will explicitly use mtl2 or somethingl 
08:33:01 <danilo2> staffehn: oh, do you know they names
08:33:04 <danilo2> staffehn: ?
08:33:39 <quchen> danilo2: Well, some consider transformers and lifting a weakness of Haskell.
08:33:52 <quchen> Maybe we just haven't found the nice solution for combining Monads.
08:34:12 <staffehn> danilo2: No, maybe someone else on this IRC does.
08:34:18 <danilo2> quchen: I know, but If you knwo Haskell better it is so easy to simplify it - look at this 2 liner - it defines MonadState for all transformers ever: http://lpaste.net/107473
08:34:27 <danilo2> staffehn: Ok, thank you :)
08:35:09 <bennofs> danilo2: there are alternatives to mtl, but they also have drawbacks. See: layers, extensible-effects
08:35:11 <c_wraith> danilo2: yes, it does..  And that's problematic.
08:35:11 <staffehn> danilo2: Also I believe OverlappingInstances is not a extension that is been used for the mtl library.
08:35:28 <c_wraith> danilo2: that means it overlaps *everything*, and that's decidedly inconvenient
08:35:46 <danilo2> c_wraith: unless you define anything more specific - is it wrong ?
08:36:12 <c_wraith> danilo2: among other things, it makes error messages very misleading.
08:36:15 <staffehn> danilo2: OverlappingInstances is a pretty unsafe Language extension
08:36:43 <danilo2> staffehn: why do you think so ?
08:36:49 <staffehn> danilo2: IIRC it is banned from SafeHaskel for that reason
08:37:22 <danilo2> c_wraith: hmm, I do not think in such simple case they would obscure the errors. I migh be wrng though
08:38:06 <staffehn> danilo2: here: https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/safe-haskell.html
08:38:16 <staffehn> danilo2: Semantic consistency — The safe language is strictly a subset of Haskell as implemented by GHC. Any expression that compiles in the safe language has the same meaning as it does when compiled in normal Haskell. In addition, in any module that imports a safe language module, expressions that compile both with and without the safe import have the same meaning in both cases. That is, importing a module using the safe language cannot change
08:38:17 <staffehn>  the meaning of existing code that isn't dependent on that module. So for example, there are some restrictions placed on the Overlapping Instances extension as it can violate this property.
08:38:18 <quchen> danilo2: It's also always dangerous to make something GHC-extension-only. What if the extension is deprecated? It'll be very hard to correct all the old code because there's so much of it. GHC extensions are *all* experimental, with different levels of "might become standard".
08:38:19 * hackagebot cabal2nix 1.65 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.65 (PeterSimons)
08:38:36 <c_wraith> danilo2: with that instance, if you try to use get with the type ReaderT Int IO Int, you'll get an error message that it couldn't find a MonadState instance for IO
08:38:53 <c_wraith> danilo2: that's an *incredibly* misleading error message
08:39:28 <hexagoxel> Double->Float, please.
08:39:52 <danilo2> c_wraith: I understand it :D
08:40:01 <danilo2> c_wraith: but of course you are right
08:40:17 <danilo2> c_wraith: I'm just thinking if it is possible to improve errors in such cases
08:40:25 <staffehn> danilo2: if you have any function like catch, that takes something monadiv as input you can't use lift but have to implement every lifting by hand
08:40:28 <c_wraith> danilo2: it may be, but it's pretty hard.
08:41:43 <k0ral> is putting integer-simple as a dependency to my package THE proper way to prevent people from building my package with a standard GHC that uses integer-gmp ?
08:42:36 <c_wraith> k0ral: it'd probably work, but no one would be happy about it. :P
08:43:16 <tolt> staffehn: Sorry, I guess I missed the notification. Hayoo has been around for a while but it hasn't looked this nice or worked as well (the interface. the results have always been spot on)
08:43:19 * hackagebot digestive-functors-scotty 0.2.0.2 - Scotty backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-scotty-0.2.0.2 (MartinsMacs)
08:44:02 <staffehn> tolt: I know hayoo, I asked about hayoo2
08:44:26 <hexagoxel> there must be something better than fromRational.toRational
08:44:32 <tolt> Ahh, I use hayoo every day and I just noticed the hayoo2 in the upper right area so probably pretty soon.
08:44:43 <tolt> *probably pretty recent
08:44:58 <k0ral> c_wraith: better prevent people from building it rather than let them crash just because integer-gmp isn't supported, don't you think ?
08:45:39 <shlevy> Is it possible to define a module that exports everything *except* a given finite list of definitions?
08:45:58 <staffehn> tolt: OK, I found "The new Hayoo is a rewrite on top of the Hunt search engine, the successor of Holumbus, which was started in 2013 by Ulf Sauer and Chris Reumann to improve and extend the existing Holumbus framework."
08:46:06 <staffehn> tolt: on https://github.com/hunt-framework/hayoo
08:46:29 <tolt> staffehn: That's awesome! We're going to have to set that up at work.
08:47:08 <tolt> I tried to get the old holumbus/hayoo running on a private server for when it was down but it was a pretty big pain.
08:53:20 * hackagebot HTF 0.12.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.0.0 (StefanWehr)
09:02:00 <shlevy> :o I didn't know there was a runIO :: IO a -> Q a
09:02:08 <shlevy> I assumed we were limited to pure computation
09:02:12 <shlevy> That's scary
09:02:51 <pjdelport> shlevy: That's part of Template Haskell.
09:03:04 <shlevy> Yeah I'm reading through the docs now
09:03:07 <shlevy> I just didn't expect that
09:03:09 <staffehn> shlevy: You can do IO during compilation. Like load a file for example.
09:03:13 <enthropy> it's really useful
09:03:39 <pjdelport> shlevy: You can of course just unsafePerformIO :: IO a -> a too
09:03:50 <shlevy> I suppose
09:03:59 <shlevy> I like to pretend unsafePerformIO doesn't exist :D
09:04:21 <tolt> runIO :: a -> Q a is a lot less scary than unsafePerformIO.
09:04:23 <shlevy> I figure I don't know enough about Haskell yet to know when it makes sense to break the rule
09:04:29 * enthropy thinks you can rely on    runIO a >> runIO b == runIO (a >> b)
09:04:31 <shlevy> tolt: Indeed
09:05:06 <tulcod> tolt: wait. isn't that just "return"?
09:05:21 <staffehn> shlevy: unsafePerformIO makes sense if you use IO for foreign calls for example but only do pure things
09:05:52 <shlevy> Mm fair enough
09:06:03 <shlevy> tulcod: I assumed given the name of the function tolt meant IO a -> Q a
09:06:05 <pjdelport> runIO isn't *really* any less dangerous than unsafePerformIO; it's just shifts the responsibility for ordering to the Q monad.
09:06:27 <tolt> hahaah sorry. Yeah, I mean IO a -> Q a
09:06:36 <MagneticDuck> https://nixos.org/nix/ looks cool.
09:09:16 <shlevy> MagneticDuck: ocharles blog post (https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html) seems to have gotten a lot of haskellers interested :)
09:10:08 <staffehn> shlevy: runIO isn't really unsafe, if you splice the Q a result it performs the IO at compiletime, if you use runQ, you can only execute it in the IO monad.
09:10:18 <shlevy> Yeah I know
09:10:20 <pjdelport> shlevy: Looking at the implementation, it runIO just defers to the overloaded qRunIO method of Quasi.
09:10:23 <shlevy> I wasn't saying it was unsafe, just surprising :)
09:10:56 <pjdelport> and Quasi only defines it for the instance Quasi IO, which yields it back as a normal IO action.
09:11:39 <shlevy> Usually you think of compilation as pure modulo temp files, if you treat the input and output file as streams
09:11:42 <shlevy> Or at least I do
09:11:52 <shlevy> Not that I don't see the utility
09:12:11 <pjdelport> So in the usual case, runIO :: IO a -> Q a actually just temporarily "hides" the IO type inside the Q.
09:12:36 <donri> it's basically a specialized liftIO
09:12:41 <tolt> If I wanted to extend on http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html for fun, does anyone have anything good to read about it?
09:12:43 <pjdelport> So unless you define another Quasi instance not in terms of IO, it's safe.
09:12:45 <MagneticDuck> hackagebot: that's a 404
09:12:46 <pjdelport> yeah
09:12:54 <MagneticDuck> ups never mind, corrupted link
09:12:59 <pjdelport> :t liftIO
09:13:00 <lambdabot> MonadIO m => IO a -> m a
09:13:01 <staffehn> shlevy: You can use the IO for specifying additional input files, that's still pretty much like normal compilation.
09:13:15 <shlevy> Yeah
09:13:31 <shlevy> Or you could, say, call out to a database to determine its schema
09:13:37 <shlevy> It's definitely useful
09:14:01 <tolt> MagneticDuck: I don't know if you use twitter but I made https://twitter.com/Hackage2Bot
09:14:02 <staffehn> staffehn: If you on the other hand if you make calls to randomRIO or something like that it's scary..
09:14:27 <staffehn> shlevy: If you on the other hand if you make calls to randomRIO or something like that it's scary..
09:14:42 <tolt> I use random numbers for all of my template haskell naming!
09:14:52 <MagneticDuck> hm, nixos
09:15:11 <staffehn> tolt: But isn't the Q monad mostly for creating new names?
09:15:22 <MagneticDuck> I wonder if I should start usin' that
09:16:31 <tolt> staffehn: Yeah. It was a joke. I was saying I would name things like resources1243148TestRoutes
09:16:37 <tolt> instance of resourcesTestRoutes
09:16:47 <staffehn> Hmm, I'm wondering how that works out if you use some IO in stdin and stdout with runIO.
09:16:54 <shlevy> MagneticDuck: I highly recommend it :)
09:17:02 <MagneticDuck> it sounds very nice
09:17:10 <shlevy> MagneticDuck: check out #nixos
09:17:13 <MagneticDuck> *reproducability* is a huge advantage
09:17:26 <donri> TH splices run at compile-time, it's no unsafePerformIO
09:18:08 <tulcod> it's unsafe if you consider the code as a program at compile-time
09:21:22 <donri> it's (currently not but for unrelated reasons) safe in the SafeHaskell sense but not in the planned SafeCompile sense
09:21:39 <pjdelport> It's unsafe in the sense of unsafePerformIO only if you provide and use an instance of Quasi that doesn't use IO (which would then be forced to implement qRunIO with unsafePerformIO, or error out).
09:22:08 <staffehn> donri: there's a thing called SafeCompile planned?
09:22:36 <donri> https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell/SafeCompilation
09:28:24 * hackagebot ini 0.2.2 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.2.2 (ChrisDone)
09:28:38 <int3__> weird. I am getting a 'tag (3) is outside of enumeration's range (0,1)' error, but I could swear that I wasn't dynamically calling 'toEnum' to create that Enum in any part of my code :/
09:34:00 <kqr> scotty seems to require a "LambdaCase" exstension, which the GHC of heroku doesn't have – does anyone know a way around this?
09:34:10 <int3__> oh, right, I found my bug. I knew that using tuples instead of proper data types everywhere was going to bite me in the ass sooner or later.
09:35:10 <adimit> int3__: it's Haskell. Making data types is cheap. Do it :-)
09:36:26 <Peaker> and toEnum/fromEnum are evil
09:37:00 <joshc> kqr: expand the LambaCases manually?
09:37:09 <joshc> use a newer ghc somehow?
09:39:24 <qwebirc1149> hey does anyone know how to replace this with type synonym: fn :: (Event a, Event b, Serialize a, Serialize b) => Int -> (a -> Bool) -> (b -> Bool) -> WF Stat IO (Maybe (Either a b))
09:40:10 <qwebirc1149> using type FILTER3 e = (Serialize e,Event e) => (e -> Bool)
09:41:53 <donri> qwebirc1149: since you probably don't want higher-rank types, you could use ConstraintKinds to make an alias for the context and a normal alias for the type
09:42:59 <qwebirc1149> is there no way to do something like fn :: Int -> FILTER3 e1 -> FILTER3 e2 -> WF Stat IO (Maybe (Either e1 e2))
09:43:36 <rwbarton> would you want to have to read code like that if there was a way to write that?
09:44:08 <cschneid> I have an aeson parser question: I want to parse   "[1, 2]" into a type `DataPoint Int Int`.  I can't figure out how to destructure it in the FromJSON block. Every example uses Object, and can't find a way to get into an Array
09:44:10 <rwbarton> it sure looks like a parametrically polymorphic function
09:45:02 <qwebirc1149> you mean if i used constraintkinds or Int -> FILTER3 e1 -> FILTER3 e2 -> WF Stat IO (Maybe (Either e1 e2)) ??
09:45:25 <rwbarton> what you wrote
09:45:43 <rwbarton> I don't think it is a good idea to hide the fact that there is a context at all
09:46:17 <enthropy> qwebirc1149: you can hid the context if you are willing to have FILTER3 be a GADT (but then there's an extra constructor to be added)
09:46:21 <donri> qwebirc1149: you'd probably be better off with something like, fn :: (Filterable a, Filterable b) => Int -> Predicate a -> Predicate b -> ...
09:47:04 <qwebirc1149> that does look good! thanks
09:47:29 <enthropy> data FILTER3 e where MkFilter :: (Event e, Serialize e) => (e -> Bool) -> FILTER3 e
09:47:50 <donri> type Filterable a = (Event a, Serializable a)  -- with {-# LANGUAGE ConstraintKinds #-}
09:48:03 <donri> type Predicate a = a -> Bool
09:48:26 <enthropy> but that's not so nice (since with that you have to write out the type signature for fn, since ghc shouldn't be able to infer one for you)
09:49:11 <kqr> joshc, i don't think any of those are alternatives, unfortunately. i hope that an older version of scotty works with my application and doesn't use lambdacase
09:50:10 <thevishy> right
09:50:25 <qwebirc1149> thanks again that helps
09:53:39 <shlevy> Is reading the original TH paper going to be confusing relative to current state of TH?
10:00:01 <int3__> I wish we could derive Enum instances for tuples automatically... getting it right is actually a little tricky
10:00:07 <int3__> off-by-one errors and all that
10:00:41 <Kneiva> is it possible to solve this kind of problems with core.logic? http://oi59.tinypic.com/s27ddw.jpg
10:01:01 <Kneiva> oops, wrong channel
10:02:14 <augur> Kneiva: tho it would be interesting to know if we could solve it in haskell in an elegant fashion!
10:02:14 <augur> :)
10:02:45 <Kneiva> true
10:07:55 <augur> 2g + y = b + 3r  ;  2b = g + y + r  ;  b + g = ??
10:08:11 <adimit> Is there any info on the SMT solver for type literals in GHC 7.10? I.e. can one already play with it?
10:08:13 <augur> of course, if you code this as a matrix, you can do matrix manipulations to solve it
10:08:46 <ReinH> augur: do it
10:09:12 <augur> let the rows be (r,y,g,b) -- (-3,1,2,1) and (-1,-1,-1,2)
10:10:19 <augur> or (-3,1,2,1) and (-2,-2,-2,4). so we have (-5,-1,0,5)
10:10:31 <augur> or, 5b = 5r + y
10:11:13 <augur> oh no i typoed D:
10:11:24 <augur> (-3,1,2,-1) :(
10:12:03 <ReinH> augur: :)
10:12:05 <augur> (-3,1,2,-1) and (-2,-2,-2,4) so (-5,-1,0,3) == 3b = 5r + y
10:12:35 <ReinH> augur: how does that work?
10:12:42 <augur> ReinH: how does what work?
10:12:49 <ReinH> augur: the thing you just did?
10:13:42 <augur> 2g + y = b + 3r   ===>   2g + y - b - 3r = 0   ===>   -3r + 1y + -2b + 2g = 0   ===>   (-3,1,-2,2)
10:13:55 <augur> more typos! im awful
10:14:20 <ReinH> hahaha
10:14:33 <augur> 2g + y = b + 3r   ===>   2g + y - b - 3r = 0   ===>   -3r + 1y + 2g + -b = 0   ===>   (-3,1,2,-1)
10:14:54 <ReinH> ah I missed the "let the rows be (r,y,g,b) part
10:14:57 <augur> you move everything to the left of = so its equal to 0, sort as you want, and take the coefficients
10:14:59 <augur> yeah
10:15:28 <int3__> range :: (Enum a, Bounded a) => Int
10:15:28 <int3__> range = fromEnum (maxBound :: a) - fromEnum (minBound :: a) + 1
10:15:31 <int3__> apparently I can't write this cutesy thing ^
10:15:48 <ReinH> > zipWith (+) [-3,1,2,-1] [-2,-2,-2,4]
10:15:50 <lambdabot>  [-5,-1,0,3]
10:16:03 <int3__> because 'a' doesn't get bound and all that. is there some extension that would allow it? I already have ScopedTypedVariables on
10:16:27 <ReinH> int3__: why would you want to write that?
10:16:32 <ReinH> just write range :: Int
10:17:04 <int3__> ReinH: then it wouldn't know which bounded enum it's a range over
10:17:12 <ReinH> ah I see
10:17:16 <augur> int3__: why not!
10:17:55 <n-dolio> int3__: Even if you could define range, it would be impossible to use.
10:18:29 <int3__> n-dolio: oh, hm, that's true. I was thinking of `range :: MyEnum` but that clearly doesn't typecheck.
10:18:32 <n-dolio> If you want to use scoped type variables, you have to explicitly quantify them, though.
10:18:47 <n-dolio> range :: forall a. ...
10:18:51 <Iceland_jack> it works with forall a.
10:19:16 <Iceland_jack>     range :: (Enum a, Bounded a) => a -> Int
10:19:16 <Iceland_jack> should be fine
10:19:30 <int3__> ah okay
10:20:07 <kini> so the newest version of Happy, namely 1.19.4, imports Control.Applicative into the parsers it generates
10:20:08 <kini> I have a .y file which already generates Control.Applicative in the boilerplate, so the duplicate import gives me compilation warnings
10:20:24 <kini> but if I remove my Control.Applicative import, then my .y file won't work with versions of Happy older than 1.19.4, which didn't import Control.Applicative
10:20:48 <carter> kini: cabal sdist will run happy automatically
10:21:30 <kini> carter: er, right... but I don't understand what that has to do with it...
10:21:44 <carter> kini: then your users don't need to have happy period
10:22:19 <kini> ah, I see your point
10:22:34 <kini> however that won't work if one clones the repository
10:22:42 <kini> (rather than downloading a tarball)
10:24:51 <kini> btw I don't think cabal sdist actually runs happy, it just collects the build artifacts produced by cabal build
10:24:55 <carter> nope
10:24:56 <carter> it does
10:24:58 <carter> :)
10:25:33 <kini> well... https://github.com/simonmar/happy/pull/23#issuecomment-47849437
10:26:37 <carter> :)
10:26:55 <carter> kini: look at how pandoc bundles its happy files
10:27:20 <int3__> Iceland_jack: http://lpaste.net/107478
10:27:23 <int3__> can't seem to get it to compile
10:28:42 <kini> carter: the pandoc repository doesn't contain any .y files
10:28:48 <carter> it used to
10:29:03 <joshc> int3__: perhaps you mean to put the typeclass constraints inside the forall a.
10:29:12 <Iceland_jack> int3__: it needs to appear before the constraints
10:29:29 <Iceland_jack>     range :: forall a. (Enum a, Bounded a) => a -> Int
10:29:35 <int3__> ahh okay. there wasn't an example about that in the docs. thanks ^_^
10:30:05 <kini> carter: I don't understand. Doesn't the shell transcript I linked show an example of cabal sdist not running happy?
10:30:17 <carter> kini: i don't have the time to play support today
10:30:19 <Iceland_jack> Probably not what you want though :)
10:30:20 <Iceland_jack>     range 'a'        = 1114112
10:30:20 <Iceland_jack>     range (5 :: Int) = 0
10:30:34 <carter> kini: if  you look at a pandoc release from a few months ago you'll see
10:30:55 <dfeuer> Are there QuickCheck tools for generating random Haskell code?
10:30:58 <carter> https://github.com/jgm/pandoc/tree/1.12.2/src/Text/Pandoc/Readers/Haddock
10:31:02 <carter> has it
10:31:05 <carter> i guess they removed it
10:32:35 <kini> carter: OK. I actually spent a bit of time a couple weeks ago looking into what cabal does with happy and alex since I was writing a pull request to happy to change its mechanism for shipping those autogenerated files
10:32:35 <kini> and what I thought I had learned while doing that seemed to contradict what you were saying so I was just trying to investigate
10:32:39 <kini> but I won't bother you anymore :)
10:33:03 <carter> kini: take a look at how cabal sdist fires on that version
10:33:28 <carter> https://github.com/jgm/pandoc/blob/1.12.2/pandoc.cabal#L296-L297
10:34:37 <kini> heh, cabal sdist doesn't even run successfully on that version
10:34:45 <kini> "setup: data/templates/default.html: does not exist"
10:34:51 <int3__> Iceland_jack: well the Int is overflowing, I guess. but for small bounded types it is indeed what I want
10:35:10 <statusfailed> I think I found a bug in pipes or pipes-bytestring, does anyone know who the author is? i forget his IRC username
10:35:34 <jfischoff> Tekmo
10:35:51 <saml> Tekmo not here
10:36:02 <statusfailed> that's the one, thanks
10:36:07 <kini> I think cabal sdist is intended to be run after cabal build -- likely cabal build generates that html file as well as running happy
10:36:10 <statusfailed> ok i'll open a github issue I guess
10:37:10 <kini> fwiw, cabal sdist doesn't run successfully on a clean checkout of master in that repo either (same error)
10:38:29 * hackagebot apiary 0.12.0 - Simple and type safe web framework that can be automatically generate API document.  http://hackage.haskell.org/package/apiary-0.12.0 (HirotomoMoriwaki)
10:38:31 * hackagebot apiary-logger 0.11.1 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.11.1 (HirotomoMoriwaki)
10:38:33 * hackagebot apiary-persistent 0.12.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.12.0 (HirotomoMoriwaki)
10:38:35 * hackagebot apiary-websockets 0.11.2 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.11.2 (HirotomoMoriwaki)
10:38:37 * hackagebot apiary-cookie 0.12.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.12.0 (HirotomoMoriwaki)
10:43:30 * hackagebot apiary-clientsession 0.11.1 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.11.1 (HirotomoMoriwaki)
10:43:32 * hackagebot apiary-authenticate 0.12.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.12.0 (HirotomoMoriwaki)
10:43:34 * hackagebot apiary-eventsource 0.11.4 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.11.4 (HirotomoMoriwaki)
10:43:36 * hackagebot apiary 0.12.1 - Simple and type safe web framework that can be automatically generate API document.  http://hackage.haskell.org/package/apiary-0.12.1 (HirotomoMoriwaki)
10:45:42 <darthdeus> anyone here using haskell-mode in emacs? I'm trying to find a way to turn off that "automatic import suggestions thingy"
10:48:44 <indn1234> Hi everyone.
10:50:59 <johnw> indn1234: hi
10:51:27 <indn1234> johnw: I have never seen these many people on a single chan.
10:52:19 <johnw> one big happy family
10:53:25 <indn1234> johnw: not much activity up in here, though.
10:54:12 <silasm> indn1234: not right now. It's pretty active at any given hour, but not constantly.
10:54:27 <indn1234> silasm: oh a'ight.
10:54:29 <silasm> if you have any questions, feel free to ask :)
10:54:42 <RchrdB> indn1234, it varies. Mostly it springs up when somebody asks around for a solution to a problem they have. =)
10:55:20 <indn1234> RchrdB: gotcha. Haskell isn't really my area, though... so I'mma bail.
10:55:23 <indn1234> Ciao.
10:59:23 <staffehn> Could somebody list a few good use cases for TH QuasiQuoters?
11:03:23 <trap_exit> if ! is like seq, is there somethign that's like deepseq ?
11:03:35 <trap_exit> for labeling the parts of a data def
11:04:45 <donri> maybe rebindable syntax and seq = deepseq :P
11:05:13 <pjdelport> does ! actually get desugared to seq?
11:05:14 <donri> but you probably don't want this as much as you think you do; deepseq can be expensive and you don't want to repeat it unnecessarily
11:05:38 <trap_exit> yeah
11:05:41 <trap_exit> since objects are immutable
11:05:53 <trap_exit> why can't objects ahve a tag t, saying "yo, this object ahs been deepseqed" already
11:06:02 <trap_exit> if we can repalce thunks with a value
11:06:11 <trap_exit> why can't values have a field saying whether it's been entirely deep-seqed
11:06:21 <luite_> donri: deepseq requires NFData, so I doubt that's possible
11:06:43 <donri> luite_: duno if syntax cares about types...
11:07:01 <donri> trap_exit: what about sharing, then?
11:07:04 <luite_> donri: yeah you migh be right, it's still wrong though ;)
11:07:11 <donri> luite_: very
11:07:30 <luite_> donri: but i have a deepseq that doen't require NFData!
11:07:41 <donri> \o?
11:07:42 <int3__> best practices question: If I am writing a function to pretty-print a data structure, and I don't care about having to load this data structure from text, should I write it as an instance of Show, or as a separate function altogether?
11:07:50 <donri> lol
11:08:29 <luite_> donri:  i wrote one for GHCJS to be used in codeworld
11:08:33 <silasm> int3__: Best practices, separate.
11:08:40 <donri> int3__: IMO Show should always be derived or implemented in the same manner; for custom pretty printing make a separate function or class or use the Pretty class
11:08:44 <luite_> donri: but it's even wrongerer though, it recursively pulls out thunks from a closure and forces them
11:09:16 <int3__> okay, thanks!
11:09:17 <donri> int3__: (though it's debatable whether the Pretty class is meant for such usage)
11:09:59 <donri> luite_: i guess in a way it's safer though; can't write a bad NFData instance to screw anything up?
11:10:45 <luite_> donri: sometimes the correct behaviour is to not force everything
11:11:04 <donri> depends what you're using it for i guess
11:11:20 <donri> it's a sledge hammer either way :)
11:12:34 <luite_> donri: for example edwardk's succinct data structures depend on some of the internal values being in various (well defined) states of unevaluatedness, otherwise the asymptotics don't hold
11:13:01 <staffehn> Where are the usecases of deepseq outside parallel evaluation strategies?
11:13:24 <donri> so then they should either not be NFData or you accept that deepseq blows the asymptotics?
11:14:05 <donri> staffehn: caching, benchmarking
11:14:10 <luite_> donri: i'm not sure either is an attractive option
11:14:30 <donri> sledge hammers are rarely about attractiveness :)
11:15:00 <luite_> donri: but i think that an automatically derived NFData could be useful as a default
11:15:24 <luite_> just deriving (NFData), or a default instance NFData MyData
11:15:56 <donri> you mean the default rnf implementation?
11:16:32 <luite_> yeah, why use a sledge hammer if you can have a laser guided rocket hammer instead?
11:17:03 <donri> staffehn: unit testing, to force bottoms
11:17:14 <donri> luite_: isn't that seq?
11:17:38 <donri> i guess seq is the scalpell
11:18:41 <staffehn> donri: right, forgot benchmarking .. how in unit testing?
11:20:01 <luite_> staffehn: i mostly use it when collecting a big result in steps
11:20:04 <donri> staffehn: also concurrency other than parallelism, to control which thread something evaluates in (mvars can hold thunks)
11:20:09 <RchrdB> trap_exit, I think I saw someone implement a wrapper that did that, once.
11:21:29 <RchrdB> trap_exit, data DontSeqMeTwice a = NotSeqdYet a | AlreadySeqd a, and { deepSeqOnce (NotSeqdYet x) = deepseq x (AlreadySeqd a); deepSeqOnce already = already; }
11:21:35 <donri> staffehn: for unit testing i mean to ensure that exceptions lurking in thunks get thrown, in case you need to test for that or whatever
11:21:38 <luite_> staffehn: and it could be useful for FRP, having internal FRP state accumulate bigger and bigger thunks is risky, and you don't know in advance how long it's going to take until someon looks at the result
11:21:50 <RchrdB> trap_exit, er, I had an x in the wrong place, but you get what I mean.
11:22:05 <luite_> RchrdB: it's different
11:22:13 <luite_> RchrdB: or you can do it in an easier way
11:22:26 <staffehn> donri: still trying to figure out how to use it in caching..
11:22:51 <RchrdB> luite_, oh wait, you could put it right there in the instance, couldn't you? Yes.
11:23:14 <donri> staffehn: in-memory caching; you want the cached value fully evaluated up front because the point of caching in the first place is to speed up later execution
11:24:18 <RchrdB> Anyway, I saw a blog post once where the author explained that they did approximately that in order to get around a performance performance with some code they were using that was over-enthusiastic about deepseq'ing the same value repeatedly.
11:24:37 <staffehn> donri: caching like in speculative computation
11:24:52 <staffehn> donri: OK, thanks
11:25:17 <luite_> data Once a = Once () a, once x = Once (rnf a) a, instance NFData Once where rnf (Once x _) = x
11:25:33 <RchrdB> luite_, ah, ta.
11:26:30 <RchrdB> luite_, yeah, that's much easier. =)
11:27:00 <staffehn> donri: Actually, about the FRP, I'm not so much into functional reactive programming, but for preventing accumulating thunks in a state isn't is most of the time enough to use `seq' and let the function on the state force thinks if needed?
11:27:24 <staffehn> *things
11:28:14 <luite_> RchrdB: edwardk said that he wanted it in deepseq (or at least i think in there) but i can't remember why it didn't make it
11:28:35 * hackagebot apiary 0.12.2 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.2 (HirotomoMoriwaki)
11:33:26 <trap_exit> what are the main disadvantages, if any, of that approach? rchrdB ?
11:33:28 <trap_exit> RchrdB: ^
11:33:36 * hackagebot apiary 0.12.3 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.3 (HirotomoMoriwaki)
11:33:38 * hackagebot NTRU 0.1.0.0 - NTRU Cryptographic Library  http://hackage.haskell.org/package/NTRU-0.1.0.0 (tlevine)
11:33:39 <trap_exit> that DontSeqMeTwice looks rather cute way to make it work
11:33:52 <RchrdB> trap_exit, it doesn't really work because the data doesn't flow in the right direction, I had it wrong.
11:34:02 <RchrdB> trap_exit, you want luite_'s "Once" definition instead.
11:35:16 <trap_exit> 11:25:17 <luite_> data Once a = Once () a, once x = Once (rnf a) a, instance NFData Once where rnf (Once x _) = x ?
11:35:23 <trap_exit> (I got disconected; firealarms going off in building)
11:36:11 <trap_exit> how oes Lute's solution work?
11:39:25 <staffehn> trap_exit: the rnf application gets put in a thunk and stored alongside the data. Now then a rnf call on the whole thing gets replaced by the cached application. If you call it the first time the think gets evaluated to () and the data gets deeply evaluated to RNF. On the second call you get the () result of the first call immidiately.
11:40:42 <trap_exit> this means that you NEVER use the Once constructor
11:40:52 <trap_exit> and only consturct objects via "once" the function right ?
11:41:04 <trap_exit> s/means/assumes/
11:41:08 <staffehn> staffehn: you should only use the smart constructor function once to construct the Once () x thing
11:41:20 <staffehn> trap_exit: ^
11:41:30 <trap_exit> staffehn: okay, all makes sense now; thanks!
11:41:46 <ifthenelse> I wrote some haskell code to calculate the weighted mean. I'm running into stack size overflows on huge lists. Can someone explain why and how to fix it? here is the code: https://gist.github.com/anonymous/47cf243db54e6556b648
11:42:13 <ifthenelse> oops. strictSum = foldl' (+) 0
11:43:02 <johnw> ifthenelse: even though you're using foldl', you are using tuples
11:43:19 <johnw> you should use the Pair type from the strict package
11:43:34 <ifthenelse> johnw: But it's strict, right? So it needs to be evaluated before the next acc calculation
11:43:37 * hackagebot yaml 0.8.8.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.8.4 (MichaelSnoyman)
11:43:42 <ifthenelse> Also, I tried bang patterns on the tuples and that did nothing
11:43:43 <johnw> no, it's not that strict
11:43:46 <johnw> it's only WHNF
11:43:53 <johnw> which for a tuple just means knowing that's a tuple
11:43:56 <johnw> not anything about what's inside
11:44:00 <ifthenelse> oh
11:44:01 <johnw> so your tuples contain thunks
11:44:01 <ifthenelse> wow
11:44:04 <ifthenelse> that's
11:44:06 <ifthenelse> wow
11:44:08 <ifthenelse> ok
11:44:20 <ifthenelse> but what if I need to use, say, Data.Map?
11:44:25 <johnw> a strict pair tuple, or using 'seq' in all the right places, would fix it
11:44:25 <ifthenelse> That needs tuples
11:44:34 <johnw> you'll need to seq in all the right places then
11:44:38 <johnw> or use bang patterns
11:44:39 <ifthenelse> hm
11:44:42 <ifthenelse> so
11:44:52 <RchrdB> Data.Map happens to be strict in the keys and in its internal structure.
11:44:55 <ifthenelse> I tried using weightSum (!acc, !0) (!x, !y) = (summed, 0)
11:44:57 <RchrdB> I... think.
11:44:58 <ifthenelse> but that did nothing
11:45:18 <johnw> hmm
11:45:33 <init> can you use bangpatterns in the type definition?
11:45:45 <johnw> how big is 'ws' btw?
11:45:50 <init> something like, function :: !Int -> Char
11:46:09 <johnw> because your division by strictSum is holding it in memory until the end
11:46:19 <johnw> no, you can't use bang patterns in types like that
11:46:30 <ifthenelse> johnw: Well I wanted to just see what was happenning, so for a test I just did weightedAverage [1,1..100000000] [3,4..10000000000]
11:46:33 <ifthenelse> in ghci
11:46:35 <johnw> you can use them at the outermost level of record member types
11:46:40 <johnw> yeah, so that's the problem
11:46:44 <ifthenelse> and it grew and grew so I stopped it due to an obvious leak
11:46:47 <johnw> you're creating a gigantic list in memory
11:47:05 <johnw> which won't be freed until the whole computation is over, strictness or no strictness
11:47:15 <ifthenelse> ok
11:47:23 <ifthenelse> well let me test the bang patterns on real data then
11:47:24 <johnw> in the strict case, it's because it can't execute the strictsum until the foldl' is done
11:47:26 <ifthenelse> no ghci or anything
11:47:34 <johnw> in the lazy case, it's because the two folds share the same data
11:48:09 <johnw> ifthenelse: you may want to switch to using the foldl library by Tekmo for this
11:48:38 <johnw> his prototypical example is pretty much the same overall shape as yours
11:48:53 <ifthenelse> johnw: But it's just two folds divided--I feel like I should be able to do it in normal haskell
11:49:07 <johnw> read the top of http://hackage.haskell.org/package/foldl-1.0.5/docs/Control-Foldl.html
11:49:26 <johnw> this library is written in regular Haskell
11:49:33 <johnw> so you can observe how it achieves the desired result
11:49:59 <ifthenelse> hm
11:51:00 <RchrdB> ifthenelse, er, why are you passing a 2-tuple to weightSum?
11:51:05 <johnw> the naïve approach fails hard in this case, though
11:51:19 <RchrdB> ifthenelse, weightSum (acc, 0) (...) = (..., 0)
11:51:23 <RchrdB> That 0 isn't being used.
11:51:29 <ifthenelse> RchrdB: Yeah
11:51:35 <RchrdB> Did you mean to accumulate the weights in the second part of that tuple?
11:51:36 <johnw> even without tuples, he'll still have the same memory exhaustion
11:51:39 <ifthenelse> but apparently the accumulator needs to be the same as the outcome
11:52:14 <ifthenelse> :t foldl'
11:52:15 <lambdabot> (b -> a -> b) -> b -> [a] -> b
11:52:19 <ifthenelse> wait
11:52:21 <ifthenelse> what
11:52:26 <ifthenelse> it didn't say that before
11:52:36 <ifthenelse> hold on
11:52:48 <ifthenelse> it gave me an error, saying it need (a -> a -> a)
11:52:50 <ifthenelse> what
11:53:51 <RchrdB> johnw, ifthenelse won't run into memory exhaustion if strictSum doesn't need to be called at all. :)
11:54:01 <johnw> ah, yes
11:54:31 <johnw> ifthenelse: the foldl library would produce the desired divisor during the computation of the other value, and then just divide two numbers at the end, effectively
11:55:00 <RchrdB> ifthenelse, er, I could show you a solution right now, by computing the sum of the weights as you go, or I could leave you to figure it out.
11:55:45 <RchrdB> depending on which you'd prefer (pedagogy vs. just getting it to work and understanding later)
11:56:00 <ifthenelse> ok weird, for some reason I was able to get rid of that placeholder tuple
11:56:19 <RchrdB> That's because you weren't using the snd member at all.
11:56:36 <RchrdB> You were just passing 0 to it and then checking that the value 0 was present on every iteration.
11:56:52 <ifthenelse> still taking up a ton of memory though, although that might be due to the big dataset
11:56:57 <ifthenelse> but not 16 gigs big, jeez
11:57:02 <johnw> lists are a bit expensive
11:57:09 <RchrdB> ifthenelse, No, your code should be able to run in constant memory.
11:57:22 <johnw> he hasn't removed the division by strictsum yet I don't think
11:57:30 <ifthenelse> no I havent
11:57:42 <RchrdB> It's possible to write a weightedAverage function that runs in constant space by summing the weights as you go, instead of calling strictsum at the end.
11:57:44 <johnw> you need a single traversal to cause the list to be elided
11:58:00 <johnw> then it will hardly use 1k
11:58:01 <RchrdB> Yeup. If you traverse the list only once then GHC can remove it for you.
11:58:05 <ifthenelse> maybe I should just do it the way RchrdB suggested, without folds
11:58:10 <johnw> a fold is fine
11:58:15 <ifthenelse> I mean
11:58:16 <RchrdB> a fold isn't the problem
11:58:23 <ifthenelse> calculate the sum of weights as I go
11:58:27 <RchrdB> yeup
11:58:33 <ifthenelse> oh
11:58:35 <ifthenelse> OH
11:58:37 <ifthenelse> i see
11:58:37 <RchrdB> The issue is that you want to perform *exactly one* fold. =)
11:58:40 <ifthenelse> then like fst / snd
11:58:45 <RchrdB> ifthenelse, yes! ^_^
11:58:45 <johnw> which is just what foldl is all about ;)
11:58:52 <johnw> (the package, not the function)
11:58:53 <ifthenelse> ah
11:59:07 <ReinH> the product of two monoids is a monoid :)
11:59:21 <ifthenelse> but I would still have a tuple, so I need bang patterns
11:59:31 <ReinH> or Pair
11:59:56 <zq> Cale: fyi, the grabmueller paper you linked me has a few problems
12:00:27 <RchrdB> ifthenelse, you can implement it with or without bang patterns; they're just a slightly nicer syntax for writing `seq` a couple of times.
12:00:41 <ifthenelse> yeah
12:00:56 <ifthenelse> do you recommend pair or bangs or seq?
12:01:00 <ifthenelse> for future reference
12:01:04 <johnw> i use all three
12:01:10 <johnw> depends on what you're going to end up doing
12:01:16 <ifthenelse> tuples have driven me nuts, because I always need to do calculations within them
12:01:17 <johnw> if it's a one-shot, seq
12:01:27 <johnw> if it's going to propagate everywhere, Pair
12:01:58 <RchrdB> Pair is the nicest approach if you have to separate Monoid instances.
12:02:11 <RchrdB> I usually use bang patterns because the desugaring is trivial but prettier.
12:02:20 <ifthenelse> mhm
12:02:55 <RchrdB> If I were doing Haskell for homework then I'd use `seq` in place of bang patterns simply on the off chance that maybe the TA marking the course hasn't seen bang patterns before or explicitly said "H98 only". ;)
12:03:08 <ifthenelse> ok, in ghci it just takes up 0.1% memory
12:03:16 <ifthenelse> it's not homework
12:03:19 <ifthenelse> so bangs are fine haha
12:03:42 <trap_exit> dumb question: how do I use deepseq-generics ?
12:03:51 <trap_exit> it's not clear to me what to do after "cabal install deepseq-generics"
12:04:04 <ifthenelse> unfortunately I'm getting huge memory footprints in the actual data, so I must be doing something bad somewhere else
12:04:29 <ifthenelse> uh
12:04:32 <ifthenelse> or I just didn't compile it
12:05:34 <staffehn> ifthenelse: in your linked code, what is the (0 :: Double) for that you pass through the whole computation?
12:05:58 <johnw> does anyone know if this type exists anywhere: https://gist.github.com/5c2d148a008b8d1a2345
12:06:18 <ifthenelse> staffehn: ghc was complaining that it would make everything an integer, I didn't want that
12:06:24 <ocharles> http://hydra.fynder.io/build/2022/nixlog/1/raw oof, upgrading to GHC 7.8.3 was not as painless as I'd hope
12:06:42 <ocharles> https://raw.githubusercontent.com/DigitalLogistics/metronome/master/src/Metronome/SocketIO/Types.hs?token=20878__eyJzY29wZSI6IlJhd0Jsb2I6RGlnaXRhbExvZ2lzdGljcy9tZXRyb25vbWUvbWFzdGVyL3NyYy9NZXRyb25vbWUvU29ja2V0SU8vVHlwZXMuaHMiLCJleHBpcmVzIjoxNDA1OTY5NDYyfQ%3D%3D--18f120a98651f70f07b32d91be262c7f9a594819 is the source in question...
12:07:08 <edwardk> luite_: i mostly just remembered mentioning it to JaffaCake, but i never made an issue for it, etc. so it just went away as a cute hack
12:07:09 <ocharles> shoot, goldfire isn't around
12:07:13 <staffehn> ifthenelse: I mean the 0s in "weightSum (acc, 0) (x, y) = (summed, 0)", why do you have them?
12:07:23 <RchrdB> ifthenelse, GHC was having to guess a type for that 0 (when you were passing it through without ever touching it) because it wasn't used anywhere as an input or output of the function, nor compared to or combined with any other number that would have caused a type to be inferred for it.
12:07:27 <edwardk> ocharles: yeah i have a fun ghc interface file bug to show him as well ;)
12:07:39 <ocharles> Can anyone make heads or tails of that error? It used to work on 7.8.2 + singletons 1.0 :/
12:08:03 <staffehn> ifthenelse: why wasn't is just "weightSum acc (x, y) = summed"?
12:08:16 <ifthenelse> RchrdB: Ah, well it's gone now, so there's not complaint
12:08:21 <edwardk> ocharles: missing scoped type variables or something?
12:08:37 <ifthenelse> staffehn: that was before I realized there was a typo and I didn't catch it
12:09:05 <ocharles> Shouldn't need them for what I'm doing here
12:09:21 <edwardk> the channel0    not being channel, when you have another thing named channel in scope would cause me to look and assume i didn't have it pinned down to the right selection
12:09:35 <ocharles> that's fine, because channel is rank-2
12:09:38 <edwardk> but i havent looked at the code, just your type error
12:09:40 <ocharles> ok :)
12:09:44 <ifthenelse> question with tuples--if I'm doing a map with (\(x, y) -> (x + 3, y + 4)) or whatever, does that not matter that it's within a tuple because it's a map, not a fold?
12:10:04 <ocharles> in the code just search for 'forAllSubscriptionChannels' - there's not a lot of code there
12:10:05 <supki> johnw: is it different from Identity?
12:10:08 <johnw> bah, that type fails the applicative laws, n/m
12:10:12 <edwardk> well
12:10:16 <edwardk> if you have
12:10:45 <staffehn> ifthenelse: map is lazy anyways
12:10:57 <johnw> namely it fails the homomorphism law: eta f <*> eta x = eta (f x)
12:10:59 <edwardk> er... Could not deduce (SingI channel0)      forAllSubscriptionChannels :: Applicative m =>   (forall (channel :: SubscriptionChannel). (SerializableChannel channel) => SSubscriptionChannel channel -> m r)
12:11:19 <ifthenelse> staffehn: So is foldl, right? That's what gives the stack overflow error
12:11:26 <ocharles> Right, but SingI channel0 should be coming from unpacking the Dict in witnessSerializable or whatever I called it
12:11:27 <ifthenelse> when it's too lazy
12:11:29 <edwardk> the forall (channel :: SubscriptionChannel). ... doesn't have a Singl channel => .. how can it ever concoct one?
12:11:49 <ocharles> you don't have to, because I've done the work for you by building you the necessary dictionary below
12:12:09 <edwardk> k
12:12:41 <edwardk> for allSubscriptionChannels $ \channel ->
12:12:41 <edwardk>     withSomeSing channel $ \sChannel ->
12:12:49 <edwardk> but when you get there, how do we know we have a dictionary?
12:13:03 <edwardk> withSomeSing channel is happening before you open the dictionary
12:13:07 <edwardk> not following
12:13:30 <ocharles> no, but if I have a SSubscriptionChannel then I can build the dictionary
12:13:31 <edwardk> sorry, going in blind here
12:13:34 <ocharles> or at least I could in 7.8.2
12:13:49 <ocharles> the next line should be bringing the constraint dictionary into "scope"
12:13:57 <ocharles> (the case witness... stuff)
12:14:22 <ocharles> I think it's the second error in that log is causing the problems though
12:20:43 <staffehn> ifthenelse: Right. Just a fold nests applications, a map dosn't, so foldl can yield a stack overflow because of too much lazyness while map doesn't.
12:38:41 * hackagebot webdriver 0.6 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6 (AdamCurtis)
12:48:01 <SimonB_> Hi, is there a way to lookahead more than one char using Attoparsec?
12:51:11 <Ainieco> hello
12:51:41 <Ainieco> http://lpaste.net/4937082885485101056 how can i fix that segfault?
12:55:30 <Ainieco> that happens when i'm trying to compile it with profiling enabled
13:03:21 <Peaker> What's the most efficient way to define a recursive algorithm processing a ByteString as if it were a list?  i.e: I have   foo :: String -> ... ; foo [] = ... ; foo (x:xs) = ...  and now the input is a ByteString.   A ByteString.foldr?
13:04:14 <napping> have you tried unpack?
13:05:02 <napping> It's a good producer
13:11:36 <statusfailed> Is there a ByteString version of Pipes.Prelude.stdinLn ?
13:14:49 <pjdelport> Peaker: Have you looked at the ByteString fold functions?
13:15:46 <Peaker> napping: I haven't benchmarked yet, was wondering if there's some established good practice
13:18:23 <napping> If you don't have benchmarks saying it's a performance problem, I'd suggest doing whatever is clear, and you can keep in mind the unpack is a good producer and the folds get at the bytes efficiently
13:18:42 <pjdelport> > BS.foldr (+) 0 $ BSC.pack "IBM"
13:18:44 <lambdabot>  216
13:19:05 <napping> BS.foldl' (+) 0 is to be much preferred, no?
13:19:38 <napping> well, really Bs.foldl' (\b a -> a + fromIntegral b) 0, unless you really want a sum wrapping at 256
13:20:39 <pjdelport> Right.
13:25:13 <ohgodwhy> @pl fmap (fmap sort) . fmap sequenceA . fmap . flip lookup
13:25:13 <lambdabot> fmap (fmap sort) . fmap sequenceA . fmap . flip lookup
13:25:24 <ohgodwhy> that's the best you can do?
13:25:27 <ohgodwhy> dammit
13:26:18 <HugoDaniel> fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap
13:26:49 <twanvl__> I don't think @pl knows about sequenceA and traversable
13:27:02 <twanvl__> they might help here
13:27:05 <twanvl__> not sure
13:27:21 <abc56889_> anyone recommend a monad for general application use (shared resources, config, logging etc)? do people use RWS?
13:27:37 <scriptdevil> abc56889_: Hakyll uses that IIRC
13:27:55 <ohgodwhy> fair enough
13:28:01 <scriptdevil> But I think I might be thinking of something else too. One sec.
13:28:40 <ohgodwhy> that code should be nuked anyway
13:28:42 * mzero remember’s that . is just fmap for (->) a ….
13:28:46 * hackagebot persistent-mongoDB 1.4.2.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.2.1 (GregWeber)
13:28:58 <mzero> HugoDaniel:  (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.) . (.)
13:29:25 <mzero> if, that is, we have an alternate universe where in the Prelude,   (.) = fmap
13:29:45 <mzero> which would allow funky things like    (*10) . [ 1.. 5 ]
13:29:55 <ohgodwhy> @pl fmap . fmap (uncurry (.) . bimap take drop) . fmap (fmap sort) . fmap sequenceA . fmap . flip lookup
13:29:55 <lambdabot> fmap . fmap (uncurry (.) . bimap take drop) . fmap (fmap sort) . fmap sequenceA . fmap . flip lookup
13:29:56 <ohgodwhy> hehe
13:31:39 <napping> ohgodwhy: what are you even trying to do?
13:31:40 <staffehn> mzero: the (.) = fmap wouldn't be compatible with the (.) of Arrows though.
13:31:52 <darthdeus> for anyone intrested in lenses, i wrote a small blog post :) http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html
13:32:20 <ohgodwhy> pointless expansion of a reasonable function
13:32:31 <napping> what's the reasonable function.
13:32:58 <napping> I can't quite tell from the @pl output, but it might be reasonably doable with lens
13:33:39 <napping> what fmap is that anyway?
13:33:44 <ohgodwhy> looks up a series of offsets in a trie and assembles a list of functions then builds a function that applies all of them of them to a single bytestring
13:34:00 <ohgodwhy> no reason for it be so generic, but I wanted to see where it went
13:34:21 <ohgodwhy> got stuck trying to get rid of those last parens and wanted to see what lambdabot did to it
13:34:35 <mzero> staffehn: would the (.) of Arrows be good enough to work for   (*10) . [ 1 .. 5 ] ?
13:34:47 <napping> doesn't it associate to \l -> fmap (fmap sort . sequenceA . flip lookup l)
13:34:58 <mzero> and really, who ever uses an Arrow other than (->), anyway?!?!!   (ducks…)
13:35:01 <Pythonfant> darthdeus: looks very interesting on a first glance will read throught it completely when I have time
13:35:27 <darthdeus> Pythonfant: hehe thanks :)
13:35:45 <Pythonfant> darthdeus: maybe it will finally make me understand the point of lenses :)
13:35:52 <ohgodwhy> maybe -- I was trying to completely eliminate all fixed points and parens
13:36:11 <ohgodwhy> well, back to work
13:36:23 <mzero> (To be fair… I’ve written exactly on Arrow instance my whole Haskell career… mostly as an excuse to use Arrow in something real…. But I bet it could have been something else.)
13:36:35 <darthdeus> Pythonfant: i finally understood only after I wrote this, took me a while to get it :)
13:36:37 <staffehn> mzero: just sayin' - they called it a generalized (.) first :P
13:36:37 <darthdeus> lenses are quite hard
13:36:47 <napping> traverse . flip lookup would do it
13:37:10 <napping> at least without the sorting
13:37:20 <Peaker> Pythonfant: It's really nice to make record fields and data constructors in Haskell more first-class
13:37:41 <mzero> ah… the Haskell operator land grab… :-)
13:37:43 <Peaker> Pythonfant: and solve the immutable-update problem in a way that leaves the convenience of imperative style: x.y.z += 1   in the dust :)
13:37:54 <scriptdevil> Peaker: Lenses?
13:38:03 <Peaker> scriptdevil: yeah
13:38:28 <staffehn> darthdeus: I've heared that there's something called "lens" in haskell once.. I'll read your post as an introduction then.
13:38:52 <Peaker> Being able to do stuff like:  sequenceOf (traverse . _3 . _Left) is simply awesome :)
13:39:37 <napping> it's traverseOf that's id, isn't it?
13:39:48 <scriptdevil> I (not a big user of Haskell), find it fairly straightforward as it is. What do you propose becomes more first-class?
13:39:53 <Peaker> Assuming you have a type like:   Tree (a, b, Either (IO c) d)   the above snippet will convert that to:  IO (Tree (a, b, Either c d))
13:40:18 <Peaker> scriptdevil: you mean you find fields/data constructors first-class without lenses?
13:40:48 <napping> scriptdevil: it's easy to access fields, or build with constructors
13:40:56 <napping> it's not so composable to go the other way
13:40:57 <darthdeus> staffehn: you might find lenses change the way you look at certain type of haskell problems :)
13:41:18 <napping> scriptdevil: like, r { x = r x + 10 } is kinda okay
13:41:20 <scriptdevil> Peaker: No, I use lenses. But the overhead is mainly import "Some Lens Lib"
13:41:35 <napping> r { pos = pos r { x = x (pos r) + 10 } } is getting ugly
13:41:36 <Peaker> scriptdevil: I mean that lens is nice because it makes data constructors/fields more first-class
13:41:48 <scriptdevil> Ok.
13:41:57 <Peaker> scriptdevil: a Lens is (sort of) a first-class record field. A Prism is (sort of) a first-class data constructor
13:42:11 <Zekka> Peaker: Good intuition!
13:42:26 <napping> scriptdevil: with lens you'd get something like r & pos . x +~ 10
13:42:41 <RyanGlScott> I'm having trouble building the network package on FreeBSD. Here's the output I'm given when ./configure fails: http://lpaste.net/107490
13:43:19 <staffehn> darthdeus: Oh, nice then I'll put it higher on my what-I-have-to-read-list ;)
13:46:30 <scriptdevil> Aaaah. The curse of having a VM with 512MB. cabal install cabal-install is thrashing.
13:48:31 <scriptdevil> are binary package-installs possible in Haskell? Assume I have two identical OS installs and I copy the .ghc and .cabal over from my server to my VM, would it work?
13:49:08 <napping> should work
13:49:41 <napping> I think only platform and any system shared libraries you linked against matter for that
13:49:57 <napping> By "platform" I mean architecture, like x86_64 or whatever
13:50:18 <scriptdevil> napping: Fedora 20, x86_64 on both.
13:50:45 <k00mi> scriptdevil: should work, I do that regularly
13:51:00 <scriptdevil> This implies I need to create a blank user on my laptop called "haskbuild" and keep that in sync with my VM
13:51:05 <scriptdevil> k00mi: Good to know.
13:51:42 <napping> I doubt the user name even matters, but keeping it blank for the package db is maybe a good idea
13:51:57 <michaelt> join #idris
13:52:01 <napping> you could probably also use a cabal sandbox with just a touch more trouble
13:52:12 <napping> michaelt: anything interesting going on there?
13:52:21 <michaelt> napping: don't know yet...
13:52:45 <napping> join commands people mistype into #haskell are often decent advice :)
13:53:42 <scriptdevil> napping: I use cabal-sandbox all the time. That is why I was doing cabal install cabal-install in the first place. Fedora 20 ships with 1.16.0
13:54:01 <zq> @pl \(x, y) -> (x, s y)
13:54:01 <lambdabot> second s
13:54:04 <zq> wow what
13:54:20 <michaelt> zq it's from Control.Arrow
13:54:55 <napping> scriptdevil: I mean rather than making a whole user just to cabal install package you want and copying .ghc, you can probably make a cabal sandbox where you install the packages you want, and copy it's package database as/into .ghc on the host
13:55:39 <napping> it would take a bit of poking around, but probably scale better than fresh users if you need several images
13:56:24 <scriptdevil> napping: Neat. That actually works?
13:56:27 <isomorpheous> Would one of you fine gentlemen be kind enough to explain when I should be using lazy text vs strict text?
13:57:41 <scriptdevil> isomorpheous: lazy if you aren't going to accumulate too many unevaluated thunks, I suppose.
13:58:10 <isomorpheous> scriptdevil: could you elaborate?
13:58:17 <napping> scriptdevil: I'm not entirely sure, but .cabal/share and .cabal-sandbox/share seem to have the same format
13:58:42 <scriptdevil> napping: Ok. I will try it out on a throwaway Vm
13:58:47 <napping> as do .cabal-sandbox/x86_64-linux-ghc-7.8.3-packages.conf.d and the user package database in .ghc/x86_64-linux-7.8.3/package.conf.d/
13:59:10 <napping> of course, if you want the packages installed into a sandbox in the VM rather than into the user database, you can almost certainly just copy the sandbox itself
14:03:07 <scriptdevil> isomorpheous: http://blog.ezyang.com/2010/08/strings-in-haskell/ might be good to read
14:03:24 <danilo2> hello! are there any other funny ghc extensions than "she" (https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/) ? I have discovered "she" today and started to wonder if there is something else interesting as well :)
14:03:26 <isomorpheous> scriptdevil: I've read that, but thank you
14:03:29 <codygman> On I new server I tried running my program and got: FailedConnectionException2 "example.com" 443 True getProtocolByName: does not exist (no such protocol name: tcp)
14:03:44 <scriptdevil> isomorpheous: Essentially, lazy doesn't require everything in memory. strict does. But if you have too many unevaluated thunks in memory, that overhead would be more than the actual string overhead.
14:04:33 <scriptdevil> I would say, start with lazy. There was a talk by some big Haskeller (I think bos) about profiling some application where he did the same transform after finding the thunk buildup.
14:04:50 <napping> Isn't that mostly an issue with a bunch of small strings?
14:05:14 <isomorpheous> my server is streaming, at most, 1MB of data with each request
14:05:17 <isomorpheous> So it's not a huge issue
14:05:21 <isomorpheous> I was just curious
14:05:23 <napping> You could build up thunks returning strict Text too
14:05:44 <isomorpheous> It might be an issue of 100MS vs 50MS
14:05:55 <Pythonfant> darthdeus: read it now, things are a lot clearer, although it will still take me some time and trying things out and getting used to them. thanks!
14:05:57 <isomorpheous> It's not an issue early on
14:06:05 <napping> If you are using much of a library, it's probably picking a type for you anyway
14:06:20 <isomorpheous> napping: aeson, I can use either
14:06:31 <isomorpheous> napping: aeson and warp
14:06:55 <isomorpheous> Warp uses lazy ByteStrings
14:07:10 <isomorpheous> Aeson can use pretty much anything
14:07:24 <scriptdevil> isomorpheous: Try it with Lazy and use the memory profiler.
14:07:32 <isomorpheous> alright
14:07:37 <napping> probably might as well use Lazy then, if you are starting from lazy bytestrings anyway
14:07:55 <Guest37858> currently trying to install haskell on osx
14:07:57 <Guest37858> running into this problem: Loading package base ... <command line>: can't load .so/.DLL for: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib (dlopen(/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib, 9): no suitable image found.  Did find:
14:08:06 <napping> lazy text is basically just [Text] of the strict text, plus functions for working on that
14:08:09 <Guest37858>  /Applicatins/Xcode.app/Contents/Developeer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/lib/libiconv.dylib: mach-o, but wrong filetype)
14:08:09 <Guest37858> can anyone help?
14:08:26 <Qfwfq> Guest37858: Did you.. actually type out that path?
14:08:41 <napping> no macs here
14:08:52 <napping> but I've heard there are packages of GHC that work okay
14:08:53 <scriptdevil> Qfwfq: Did the "Applicatins" give it away? :P
14:09:01 <napping> what are you trying to install?
14:09:05 <isomorpheous> Guest37858: ahhh why
14:09:06 <Qfwfq> scriptdevil: "Developeer", actually.
14:09:11 <scriptdevil> haha.
14:09:31 <napping> that sounds like a great name for some kind of marketing thing
14:09:46 <napping> "Join the DeveloPeer(tm) program now!"
14:10:06 <isomorpheous> napping: hahaha
14:10:09 <Qfwfq> Is that just a re-branding of pair programming?
14:10:35 <napping> Guest37858: http://ghcformacosx.github.io/
14:10:58 <napping> Guest37858: apparently nobody can help better than me just repeating hearsay, but I hear that's a nice package of ghc
14:11:12 <napping> something about being a Mac style app dir?
14:11:29 <napping> I assume you have Xcode installed?
14:11:50 <napping> that sounds like either a version issue or not having iconv installed
14:12:08 <int3__> I'm looking for a nice way to write tests in a pattern-matching style. something like `Foo _ 1 'a' @= f x`, where `_` means I don't care about the value of that field
14:12:17 <int3__> HUnit doesn
14:12:23 <int3__> *doesn't seem to provide anything like that
14:12:27 <Guest37858> xcode is installed
14:13:04 <Peaker> int3__: you could try to use actual pattern-matching and let it fail?
14:14:32 <int3__> Peaker: that's true, I suppose a case ... of ... _ -> False would work
14:15:01 <Peaker> 21.7% of my runtime is spent in my Binary instance for DiffTime or NominalDiffTime, which looks like: "get = fromRational <$> get"
14:15:18 <Peaker> What would be a nicer way to go without going through Rational?
14:16:50 <quchen> Is Carl Howells here?
14:17:11 <c_wraith> quchen: aye
14:17:56 <darthdeus> Pythonfant: here you're welcome, I'm glad you like it
14:17:59 <darthdeus> hehe*
14:18:07 <pjdelport> Peaker: Why are you going through Rational?
14:18:14 <pjdelport> What does the instance look like?
14:18:39 <Peaker> pjdelport: get = fromRational <$> get
14:18:50 * hackagebot connection 0.2.3 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.3 (VincentHanquez)
14:19:10 <Peaker> pjdelport: instance Binary NominalDiffTime where ...
14:19:24 <Peaker> pjdelport: now trying to multiply be 1e9 and truncate
14:19:26 <Peaker> pjdelport: instead
14:19:38 <benmachine> Peaker: looks like DiffTime is a Pico underneath
14:19:44 <napping> Peaker: it's specified to have a precision of 10^-12
14:19:49 <benmachine> even has rules to eliminate realToFrac between the two
14:20:42 <benmachine> should be easier to write an efficient binary instance for Pico, the constructor's exported
14:20:59 <Peaker> benmachine: cool, thanks
14:21:08 <napping> might be a touch tricky, it's a type synonym
14:21:09 <Peaker> Pico is exposed, so I can make a Binary instance, yay
14:22:33 <benmachine> napping: 'sfine, you can write an instance for Fixed a
14:22:46 <benmachine> don't even need constraints on a
14:22:58 <napping> Hmm, I suppose
14:23:32 <Peaker> benmachine: trying to make the Binary instance based on a standalone deriving Generic instance
14:23:39 <napping> I guess the type parameter doesn't really add to the problems you'll have if you serialize at one type and deserialize at another
14:23:50 <benmachine> napping: right :)
14:24:05 <benmachine> that lands you firmly in "already screwed" territory
14:26:44 <mzero> Guest37858: still there?
14:27:12 <Guest37858> merzo: yes
14:27:13 <Guest37858> mzero: yes
14:27:21 <mzero> are you using brew or macports?
14:27:53 <Guest37858> first tried to install with brew and then by downloading the zip file
14:28:08 <mzero> and - which distribution of Haskell are you trying to install (GHC src, GHC bindist, Haskell Platform, ghcformacosx, brew…?)
14:28:21 <Krenium> Can someone help me understand why this function doesn't terminate? eightify xs | length xs >= 8 = xs | otherwise = '0' : eightify xs
14:28:22 <mzero> zip file? you mean the GHC bindist?
14:28:42 <napping> Krenium: what happens on an empty list?
14:28:48 <Guest37858> the brew one and this one: https://www.haskell.org/platform/mac.html
14:28:58 <napping> Krenium: you'd probably rather have eightify ('0':xs)
14:29:11 <Krenium> the same that happens with any other list: an endless stream of 0's
14:29:12 <mzero> okay - that is an installer
14:29:38 <mzero> Guest37858: did you change your system gcc to be the one from brew (before trying to install Haskell)… as that is a complication
14:29:41 <napping> Krenium: it should return the input unchanged  if the string you give it is already long enough
14:29:44 <mzero> that shows up with lib iconv
14:30:01 <Pythonfant> Krenium: you probably want to match on (x:xs) and only use the xs
14:30:06 <Pythonfant> otherwise your list will never get shorter
14:30:12 <benmachine> Krenium: notice that your recursive call is passing exactly the same argument that it got passed
14:30:14 <Pythonfant> (don't forget the empty list in this case)
14:30:14 <Guest37858> not knowingly
14:30:17 <napping> Krenium: but you only recurse on (eightify xs), so the part you examine never gets longer
14:30:22 <mzero> Krenium: your recursive case calls eightify with the same argument as it got… it’ll recurse forever
14:30:33 <napping> Pythonfant: backwards, it's supposed to get longer
14:30:41 <mzero> Guest37858: what do you see when you run   gcc —version
14:31:02 <Peaker> Going through Pico instead of Rational (via realToFrac) only changed it from 21% runtime to 17% :(
14:31:07 <Guest37858> Jonass-MacBook-Pro:~ Jonas$ gcc -version
14:31:07 <Guest37858> clang: error: unknown argument: '-version' [-Wunused-command-line-argument-hard-error-in-future]
14:31:10 <benmachine> napping: depends which list you're talking about
14:31:10 <Guest37858> clang: note: this will be a hard error (cannot be downgraded to a warning) in the future
14:31:13 <Krenium> Ah.. thanks for the help
14:31:13 <Guest37858> clang: error: no input files
14:31:16 <benmachine> Peaker: :(
14:31:34 <Peaker> http://lpaste.net/107492 <-- still slow
14:31:35 <mzero> Guest37858: two dashes
14:31:44 <Pythonfant> napping: I guess I don't understand what eightify should actually do :)
14:31:48 <Peaker> I could try avoiding the Generic instance too, it might be slow
14:32:16 <mzero> I think what Krenium wanted was more of    | otherwise = eightify (‘0’ : xs)
14:32:20 <Guest37858> Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1
14:32:21 <Guest37858> Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)
14:32:21 <Guest37858> Target: x86_64-apple-darwin13.3.0
14:32:21 <Guest37858> Thread model: posix
14:32:32 <benmachine> mzero: yeah I agree that sounds more likely
14:32:34 <mzero> okay - that’s good, Guest37858 - you are using the standard Xcode compiler
14:32:37 <Krenium> What I wanted was if I pass in "1234" I get back "00001234"
14:32:52 <benmachine> Peaker: yeah I'd just have instance Binary (Fixed a) where get = MkFixed <$> get; put (MkFixed x) = put x
14:32:59 <Peaker> benmachine: yeah, trying that now
14:33:01 <napping> Peaker: it's just newtype Fixed a = MkFixed Integer
14:33:11 <mzero> Krenium: remember - when you recurse, the argument needs to be something different than just the original argument… or you recurse forever
14:33:16 <benmachine> but it might be that Binary Integer isn't fast
14:33:31 <napping> maybe also check to be sure it's actually eliminating the realToFrac
14:33:32 <Peaker> 17% -> 10% with this instance
14:33:32 <benmachine> Peaker: worst-case scenario, try http://hackage.haskell.org/package/thyme
14:33:54 <mzero> Guest - you’ve run the Haskell Platform installer? and you see the original error message when you run, what? ghci?
14:33:57 <benmachine> yeah I was going to suggest that too, I don't know how you do it though
14:34:03 <benmachine> -ddump-something-or-other
14:34:05 <Peaker> though now I see the other "get" (.prof file doesn't say from which instance!) is another 7%, so both together were previously even more expensive than I thought, now both cost 17% together
14:34:11 <Guest37858> yep
14:34:29 <Guest37858> mzero: yep
14:34:48 <napping> Peaker: is that a reasonable number?
14:34:59 <pjdelport> Krenium: You could say something like: eightify xs = replicate (8 - length xs) '0' ++ xs
14:35:05 <mzero> does   which ghci    point at /usr/bin/ghci?    and does     ls -l /usr/bin/ghc*  show symlinks into   /Library/Frameworks/GHC.framework
14:35:06 <mzero> ?
14:35:17 <Peaker> napping: don't think so.. I might be reading a lot of such values, but in C code, for instance, it would cost virtually nothing
14:35:23 <mzero> (Guest37858 - I’m thinking that your brew install attempt has left bad cruft around)
14:35:27 <Peaker> napping: it's a build system, and I'm profiling the empty build case
14:35:33 <napping> huh
14:35:45 <Peaker> napping: so I read, from my database, a lot of "execution logs" to see if they all match up the current file times
14:35:54 <napping> sounds like what thyme is for, if it's timestamps
14:36:14 <napping> also, you probably should try hardcoding the serialization at Int64
14:36:17 <Peaker> I'll try to use thyme, see if it's hard
14:36:21 <Guest37858> mzero: first one nope, second one yes
14:36:40 <napping> well, what precision do you actually have}
14:37:04 <mzero> okay - which ghci are you executing then?    alternatively, try running    /usr/bin/ghci   and see if that works
14:37:06 <napping> Remember Integer is maybe a bigint, I'm not sure that would be fast in C either
14:37:15 <Peaker> napping: System.Posix's mtimeHiRes
14:37:32 <Guest37858> merzo: yup, works
14:37:51 <Peaker> napping: http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Files-ByteString.html#v:modificationTimeHiRes
14:38:00 <Peaker> (unfortunately it returns it as "time" and not "thyme" :( )
14:38:02 <Guest37858> merzo: genius, how can I point the command to the right path?
14:38:15 <mzero> okay - what you have is a) stuff left over from the failed brew install attempt, b) that stuff is in some place (where   which ghci   leads), c) that stuff is in a directory that is on your PATH, and before   /usr/bin
14:38:50 <Peaker> converting between time and thyme is probably gonna cost me :(
14:39:09 <mzero> you can  delete the stuff that brew installed (in /usr/local/bin perhaps? but who knows where it stuck the other 1GB of files…)
14:39:29 <RchrdB> Peaker, get a herb garden and wait, and you will have converted time → thyme?
14:39:30 <Denommus> is it possible to make a LLVM front-end for a new language in Haskell?
14:39:48 <mzero> -or- if the directory is some thing llike   /opt/local/ghc   you could just delete that whole directory
14:39:54 <mzero> where does    which ghc     point?
14:39:55 <RchrdB> Denommus, should be! There are bindings for LLVM on Hackage.
14:40:03 <Denommus> RchrdB: cool :-D
14:40:17 <Guest37858> which ghc
14:40:17 <Guest37858> /usr/local/bin/ghc
14:40:34 <Guest37858> merzo: should I just remove this one?
14:40:43 <mzero> well, not yet
14:40:43 <Guest37858> mzero: should I just remove this one?
14:40:45 <Guest37858> ok
14:41:12 <mzero> you see, there are about a dozen commands that are part of ghc, and are hanging in /usr/local/bin  now — and you want to make sure you get all of them
14:41:22 <Ralith> Denommus: you mean write a program that converts some language to LLVM IR? of course
14:41:37 <mzero> so, first see if     ls -l  /usr/local/bin/ghc    is a symlink, and if so, note where it points (and tell us)
14:42:02 <Guest37858> /usr/local/bin/ghc -> ../Cellar/ghc/7.6.3_2/bin/ghc
14:42:26 <bitraten> how can i chain functions returning a Maybe value, inside another monad?
14:42:31 <Guest37858> mzero: how about brew remove haskell-package?
14:42:46 <mzero> er, sure!
14:42:51 <napping> bitraten: is that returning m (Maybe a), or Maybe a?
14:43:08 <mzero> Guest37858: that sounds good (I don’t know brew)
14:43:15 <napping> for that latter just use a local do or >>= or whatever, doesn't matter that other code nearby uses some other Monad
14:43:32 <Denommus> Ralith: I want to start making a new language, and I want to target the LLVM. Haskell seems an excelent choice for that
14:43:47 <Ralith> it is
14:43:59 <mzero> (brew doesn’t seem to play well with the standard Apple dev. tools and libs)
14:44:06 <bitraten> napping: https://gist.github.com/bitraten/ed3a7dec92b315c3aedd
14:44:09 <napping> bitraten: for the other, you might use MaybeT, or maybe just use explicit cases anyway, if you want to be explicit about which side effects happen when things fail at versiou points
14:44:11 <Ralith> Denommus: http://hackage.haskell.org/package/llvm-general-3.4.4.0
14:44:22 <Denommus> Ralith: thanks
14:44:39 <napping> oh, nothing to do there
14:44:47 <Guest37858> mzero: brew doesn't remember that it installed haskell
14:44:54 <napping> you're only doing one thing that returns a Maybe, then you want to check what you got
14:44:54 <mzero> oy!
14:45:14 <napping> or do you want to also show the 404 if the header failed?
14:45:22 <bitraten> napping: exactly
14:45:48 <mzero> well… delete   ../Cellar/ghc  (or ../Cellar/ghc/7.6.3_2) … then find and manually rm every symlink in /usr/local/bin that points into that dir
14:46:26 <mzero> you can probably find them all with something like    cd /usr/local/bin ; ls -l | grep Cellar/ghc
14:47:02 <mzero> (crazy brew… Y u no remember?!??)
14:49:28 <mzero> Sorry, Guest37858, that you had such a mess to have to clean up
14:49:37 <mzero> …and… did it work?
14:50:40 <napping> bitraten: I'm not sure runMaybeT (MaybeT (header "host") >>= MaybeT . loadUser) is a big improvement
14:51:15 <napping> I'd probably do let or404 = maybe show404 return
14:51:24 <Peaker> http://hackage.haskell.org/package/unix-2.7.0.1/docs/src/System-Posix-Files-Common.html#modificationTimeHiRes <-- line 364, ew
14:51:35 <HugoDaniel> (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=) . (>>=)
14:51:42 <napping> er, that's not quite right
14:52:08 <napping> well,  make "WebAction()" have a way to bail out of request processing and return a 404
14:52:13 <Guest37858> mzero: thanks, I removed all ghc aliases, but when I type ghci it gives me this: -bash: /usr/local/bin/ghci: No such file or directory
14:52:14 <napping> and convert the Maybe into that as you go
14:52:26 <Guest37858> it somehow does not look in /usr/bin/
14:52:38 <Qfwfq> rehash
14:53:01 <Ivan_> Hi. Has anyone here tried to install EclipseFP recently?
14:53:50 <Ivan_> It needs me to pre-install scion-browser and buildwrapper. Only problem is, once I've installed scion-browser, it doesn't let me install buildwrapper without re-installing scion.
14:54:11 <mzero> Guest37858: you need to tell bash to “rehash”
14:54:22 <mzero> run    hash
14:54:25 <Ivan_> I've been in cabal hell for a few hours now, just wondering if anyone had similar problems.
14:54:34 <mzero> that is, your shell is remembering the old lookup
14:55:36 <Peaker> I was trying to keep my codebase lens-free for beginner-friendliness, but it seems thyme only has lens-based interfaces :(
14:55:38 <Guest37858> mzero: same story
14:55:46 <mzero> try opening a new shell
14:56:32 <Guest37858> mzero: et voila!
14:56:37 <Guest37858> mzero: works...
14:56:38 <mzero> whew
14:56:43 <benmachine> I think the correct thing for rehashing is hash -r
14:56:46 <Guest37858> mzero: muchas gracias!
14:56:49 <mzero> welcome
14:56:55 <mzero> enjoy your journey into Haskell
14:57:22 <lesmon> Guest37858: Let me give you a present : 'à'
14:57:32 <Guest37858> thanks. starting with learnyouahaskell.com
14:57:37 <mzero> perfect
14:57:39 <Guest37858> lesmon: thanks ;-)
14:57:43 <mzero> that’s tons of fun
14:57:47 <lesmon> :)
14:57:59 <Guest37858> I like the drawings ;-)
14:58:14 <mzero> come back when you’re stuck … we’re a pretty friendly bunch with beginners
14:59:09 <napping> Peaker: how much do you need to use those values anyway?
14:59:32 <Guest37858> mzero: I think that's true! will do
14:59:41 <Pythonfant> I can only agree with mzero, it's amazing how patient and willing to help people here are
15:00:04 <Peaker> napping: which ones? the hi-res-mtimes?
15:00:13 <Peaker> napping: iterating hi-res mtimes of many many files is all I do in an empty build
15:00:21 <Peaker> (and comparing those to the values in a database)
15:00:38 <Peaker> How does one subtract Thyme's UTCTime's?
15:01:08 <quchen> And if people are rude wait 30 minutes for them to be scolded and replaced with nicer people.
15:01:15 <johnw> :)
15:01:37 <Peaker> ah, it's just hidden in a different module than Time
15:02:13 <Peaker> an empty build currently takes 1.7sec for doing nothing! that's pretty terrible as the object will grow a lot
15:03:29 <napping> Peaker: maybe you should see what shake calls
15:03:45 <johnw> Peaker: I think it's ^-^
15:04:26 <Peaker> johnw: I strive for an empty build to take around the same time as "git status" as they both have to do pretty much the same thing
15:04:50 <napping> Peaker: you should look for other bindings
15:04:57 <napping> or maybe try unsafeCoerce on the times you get
15:05:12 <napping> It's just an Integer of the raw stat result, multiplied by 1000
15:05:13 <RchrdB> mzero, Guest37858: btw, in bash it's "hash -r" to clear its cache of path lookups. :)
15:06:49 <Peaker> would realToFrac converting Data.Time's NominalDiffTime to Thyme's be expensive?
15:07:00 <napping> possibly
15:07:27 <napping> you'll have to check the core (or possibly simplifier logs) to see if it's rewritten away
15:07:55 <napping> Or maybe just make your own bindings, if you really want the high resolution time
15:10:56 <Peaker> well, trying to use Thyme whereever possible and I'll see what it does to my performance
15:11:07 <napping> isn't that kind of excessive resolution anyway?
15:11:51 <Peaker> napping: why?
15:12:00 <Peaker> I want to know if the file was modified, even by automated tools
15:12:06 <Peaker> the more resolution, the better
15:12:09 <napping> do all file systems even have that much resolution?
15:12:27 <Peaker> Nope, some have 1-second (!) resolution, which is useless
15:12:40 <Peaker> git, for example, just ignores mtimes on file systems that don't have the hiRes mtimes
15:12:49 <napping> If a directory is being constantly modified by automated tools, checking once probably isn't enough
15:13:09 <napping> at the very least, check performance with the low resolution mtime
15:13:31 <napping> Is it stat calls? allocating Integers? conversion?
15:13:54 <Peaker> napping: well, it was the Binary deserialization of the times from the database
15:14:01 <Peaker> now that I changed to Thyme, I'm not yet sure exactly what it is
15:14:13 <napping> oh, did that help?
15:14:28 <Peaker> nope, way slower now
15:14:33 <RchrdB> Peaker, I might be wrong, but from memory I think that the FAT filesystems have 2-second resolution in timestamps.
15:14:37 <napping> and how about just loading a vector of fixed-size integers?
15:14:44 <Peaker> RchrdB: yeah
15:15:46 <Peaker> napping: my db maps a command-line to its "execution log" which has the input content hashes. Aside from that, I have a cache mapping paths to their last known (mtime, content-hash)
15:16:55 <napping> Peaker: you should be able to just mmap like half of that
15:17:32 <Peaker> napping: how do I mmap stuff like that which includes file paths?
15:17:34 <Peaker> as keys?
15:17:38 <napping> split it up
15:17:49 <napping> parallel arrays rather than an array of hereogenous stuff
15:18:11 <Peaker> array indexes are ints, though, and not file paths?
15:18:14 <napping> sure
15:18:27 <napping> you'll still need to deserialize some variable-size stuff for the mapping from paths to indices
15:18:40 <napping> how many files do you have anyway?
15:19:38 <Peaker> Hmm.. probably thousands, it's a bit hard to inspect currently
15:19:48 <Peaker> (because I track all file accesses even from the system)
15:19:53 <Peaker> I could add some traces and count
15:20:46 <Peaker> but I'll reprofile after dumping Thyme and fixing the Binary orphan instances of Nominal/DiffTime
15:22:50 <Peaker> https://github.com/ElastiLotem/buildsome <-- src if you're interested.  profile: http://lpaste.net/107501
15:24:21 <Peaker> btw, Posix.fileExist "/etc/passwd/x" throws an exception instead of returning False :(
15:38:54 <alexherbo2> Hi
15:40:04 <gigamonkey> Due to unfortunate cargo culting, I've written my first Parsec based parser using the old Parsec 2 compatability API. Any pointers to docs that spell out the differences between that API and the shiny new Parsec 3 API?
15:40:27 <napping> Hmm, try changing the imports?
15:40:33 <quchen> gigamonkey: What does "simply import the new modules, fix compilation errors" do?
15:40:52 <napping> I didn't notice any big differences
15:41:02 <quchen> That's the usual approach to ripping the heart of your program out and replacing it with something else. It's very easy and kind of boring. :-)
15:41:25 <napping> maybe the parser type is now a type synonym over a fancier type and how you run it at the very top could use a little adjusting
15:41:45 <napping> but how you write parsers didn't change as far as I noticed.
15:45:35 <gigamonkey> Okay. Some errors on changing the imports but I can probably track them down. Thanks.
15:46:59 <dpwright> Is there any way to configure cabal to tweak the file extensions it will work with?  I want to write some literate haskell/markdown files with extension ".hs.md" or ".lhs.md", but right now the extension has to be ".lhs"
15:47:09 <dpwright> is that a cabal thing or a ghc thing?
15:47:47 <lesmon> oh, I finally pointed it out
15:48:10 <lesmon> I am highlighted by « haskell ». Gasp.
15:50:24 <Ankhers> I am using RabbitMQ. Is there anything I could do in order to save the connection between requests instead of having the overhead of creating the connection each time?
15:50:28 <dpwright> or even a haskell spec thing?
15:50:50 <Peaker> bah! ghc-7.6.3 did not export Data.Fixed's MkFixed constructor :(
15:51:29 <gigamonkey> Heh. That was stupidly trivial. Change the import; delete the old type signature; and add the suggeted -XNoMonomorphismRestriction
15:51:40 <zomg> Ankhers: uh, just open the connection and... reuse it?
15:52:34 <Algebr> Playing with ocaml, wondering why ghc can't spit out warnings about missing cases in pattern matching.
15:53:09 <napping> it just doesn't by default
15:53:27 <Algebr> napping: is there a -wall?
15:53:31 <napping> that too
15:53:57 <zq> Algebr: -fwarn-incomplete-patterns
15:54:00 <Ankhers> zomg: yes, but without passing the connection between functions, which I can't do when it is a separate request, I don't know how to save it.
15:54:02 <napping> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
15:54:02 <scriptdevil> Algebr: It can... -fwarn-incomplete-patterns
15:54:15 <Algebr> zq: how can I make ghci do that? Something in .ghci?
15:54:18 <zq> Algebr: https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/options-sanity.html
15:54:30 <zomg> Ankhers: you could stick it in a state, or use an mvar with a reader, or a variety of other similar approaches
15:54:55 <napping> Algebr: :set -W is the most direct
15:54:55 <zq> Algebr: in ghci? i normally stick flags i'm absolutely sure that i always want in the ghci wrapper script
16:02:08 <gecelerde> merhaba
16:09:00 <Vicky21>  You can find funny videos here. http://j.mp/1rcfoZz
16:09:18 <bitemyapp> shapr: ^^ ban?
16:14:24 <worldsayshi> So. What type does a feature have? type Feature = <insert code here>
16:16:09 <worldsayshi> Also: type Program = <insert code here>
16:18:45 <bms1> I have a Cabal library which depends on a C library, and I want to be able to read the C headers (i.e., "include/") for the library. It looks like I'll probably need that directory to be specified manually? Is there a good way to do this?
16:20:29 <spott> I'm running into a weird error, I'm working on creating a sparse matrix library, and so I'm declaring a matrix:  "data Sparse ord val = Sparse { values :: U.Unbox val, rowIndexes :: U.Unbox ord, colIndexes :: U.Unbox ord }"
16:20:50 <spott> but I keep getting the error: "Expected a type, but ‘U.Unbox val’ has kind ‘Constraint’"
16:21:10 <spott> what am I missing?
16:22:05 <spott> I have LANGUAGE MultiParamTypeClasses enabled for the matrix type class
16:22:11 <Peaker> Writing a Binary instance for Pico which is 7.6.3 compatible is difficult... :(
16:22:21 <Peaker> hitting all sorts of edge cases
16:31:44 <spott> nevermind, I figured it out...
16:33:03 <jehyt> تحذير
16:33:03 <jehyt> warning
16:33:03 <jehyt>  you may be  watched
16:33:03 <jehyt> do usa&israel use the internet(facebook,youtube,twitter, chat rooms ..ect)to spy??
16:33:03 <jehyt> do usa&israel use the internet 2 collect informations,,can we call that spying??
16:37:11 --- mode: ChanServ set +o johnw
16:37:11 --- mode: johnw set +b *!~awrbgh@197.195.131.203
16:37:12 --- kick: jehyt was kicked by johnw (Kicked)
16:37:12 --- mode: johnw set -o johnw
16:42:40 <Hilol123> Hi
16:43:16 <oleo> morning
16:43:46 <benzrf> oleo: 'morning'
16:43:49 <benzrf> where do you live, australia?
16:44:34 <benzrf> spott: obviously U.Unbox :: * -> Constraint
16:44:46 <benzrf> spott: pick something with kind * -> * next time
16:44:46 <benzrf> ;)
16:45:35 <spott> benzrf: yea, I realized that.  Unbox a is a class, not a type
16:45:59 <benzrf> spott: then why are you trying to use it where a type goes
16:46:13 <spott> benzrf: because I'm still learning... :)
16:47:19 <spott> I was trying to use it because I want an instance of that typeclass there...
16:47:50 <Hilol123> Hi
16:48:21 <jfischoff> hi Hilo123
16:48:26 <benzrf> spott: ok, but why would you try to accomplish that by putting the typeclass where the type goes?
16:48:33 <benzrf> spott: that's cargo-cult coding!
16:48:35 <benzrf> second time ive said that today
16:48:48 <benzrf> first time i used it (probably) right
16:48:52 <spott> I have no idea what "cargo-cult coding" is...
16:49:35 <spott> because I had yet to solidify what the difference is between typeclasses and types... I'm still working on that
16:50:17 <benzrf> spott: ah
16:50:29 <benzrf> spott: typeclasses are used in constraints
16:50:36 <btubbs> it helps me to think in terms of Rust's word for the concept, which is "traits"
16:50:42 <spott> I figured that out... :)
16:51:05 <Hilol123> !echo hi
16:51:08 <benzrf> spott: you can construct a type by doing
16:51:09 <benzrf> foo => bar
16:51:17 <benzrf> where foo :: Constraint and bar :: * or #
16:51:21 <benzrf> maybe just *
16:51:29 <benzrf> im not sure if # can have constraints on it?
16:51:40 <benzrf> spott: you could think of it like:
16:51:45 <benzrf> (=>) :: Constraint -> * -> *
16:52:03 <benzrf> except that i dont think (=>) is actually considered an operator at the type level the way (->) is
16:52:53 <spott> I think I have it right in my head now...
16:54:07 <Hilol123> !echo hi
16:54:08 <benzrf> spott: basically, if you have anything whose kind contains 'Constraint' in it on the rhs of a (=>), you're probably doing it wrong
16:54:25 <benzrf> unless you're doing super fancy stuff like:
16:54:47 <benzrf> data Constrained c = forall v. c v => v
16:54:50 <benzrf> err i mean
16:54:54 <Hilol123> !echo hi
16:54:55 <benzrf> data Constrained c = Constrained (forall v. c v => v)
16:55:01 <benzrf> also i think the syntax is off on that
16:56:44 <Hilol123> !echo hello
16:58:46 <Hilol123> !echo hi
16:58:46 <oBurnBoto> hi
16:58:46 <oBurnBoto>  hello
16:58:46 <oBurnBoto> hi
16:59:07 <Hilol123> !echo Hello, how are you?
16:59:08 <oBurnBoto> Hello, how are you?
16:59:28 <dagano> in a line like : data PointSupply a = PointSupply !Int (IM.IntMap (Link a))
16:59:31 <dagano> what is !Int ?
17:01:29 <bscarlet> A strict field
17:01:54 <TomNut> !echo faggot
17:02:12 <TomNut> !echo [hi]
17:02:24 <TomNut> Hi
17:02:33 <Hilol123> Hi
17:02:36 <bscarlet> i.e. it’s an Int that’s actually there if the PointSupply is there, as opposed to the usual thunk which would produce an Int if needed
17:02:40 <Hilol123> !echo hi
17:02:40 <oBurnBoto> hi
17:02:44 <TomNut> !echo [Hi]
17:02:44 <oBurnBoto> [Hi]
17:02:46 <TomNut> hi
17:02:49 <TomNut> Hi
17:02:51 <TomNut> Hii
17:02:53 <TomNut> Hiii
17:02:58 <TomNut> Hiiiiiiiiiiiii Burn
17:02:59 <Hilol123> !echo tom is bad
17:02:59 <oBurnBoto> tom is bad
17:03:05 --- mode: ChanServ set +o dolio
17:03:20 <Hilol123> !echo cool, right?
17:03:20 <oBurnBoto> cool, right?
17:03:37 <Hilol123> !echo tom where u go
17:03:37 <oBurnBoto> tom where u go
17:03:45 <TomNut> !echo Tom is cool
17:03:45 <oBurnBoto> Tom is cool
17:03:48 <TomNut> Ikr
17:04:05 <Hilol123> !echo i love the Haskell language
17:04:05 <oBurnBoto> i love the Haskell language
17:04:57 <Hilol123> !echo ok bye
17:04:57 <oBurnBoto> ok bye
17:05:11 <dolio> That's enough.
17:05:27 <MP2E> lmao
17:09:01 --- mode: ChanServ set -o dolio
17:11:37 <dagano> so basically a thunk is some placeholder in a call-by-name strategy that says "i'll get this later" ... how is it represented internally? as a full expression?
17:11:51 <dagano> s/.../?/
17:12:08 <Hilol123> !echo hi alex
17:12:08 <oBurnBoto> hi alex
17:12:09 <suOya_> I'll give you a good link... moment
17:12:15 <alexmack929> Hi
17:12:32 <suOya_> dagano: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
17:13:18 <dagano> suOya_: awesome! thank you
17:13:27 <suOya_> Great book also
17:13:50 <dagano> yeah it's a bit out of my league .. but i guess i'm working my way toward it
17:14:08 <HorrendousRex> Hello! I'm getting the  following error when I run "cabal tests" after adding a "test-suite tests" directive to my .cabal file: Warning: games.cabal: Unknown fields: default-extenstions (line 60)
17:14:09 <suOya_> Once you're comfortable with monads you can read the book
17:14:30 <HorrendousRex> I was trying to follow this page, from section 2.9.1: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:16:31 <hexagoxel_> HorrendousRex: extenstions->extensions
17:16:40 <HorrendousRex> Oh my.
17:16:45 <HorrendousRex> I even double checked. Thanks!
17:16:54 <staffehn> dagano: A unevaluated thunk contains a pointer to some code that will replace the thunk with the evaluated data.
17:19:07 * hackagebot word8 0.1.1 - Word8 library  http://hackage.haskell.org/package/word8-0.1.1 (KazuYamamoto)
17:22:17 <spott> is there a typeclass for indexed traversal?
17:28:40 <sshine> if functors exist between categories, and we always consider the category of types, aren't all Haskell functors endofunctors?
17:28:50 <Hilol123> Hi
17:29:42 <Hilol123> Hi
17:30:01 <sshine> Hi.
17:30:31 <Hilol123> =)
17:30:39 <Hilol123> !monologue
17:31:49 <Hilol123> Hi
17:32:59 <Hilol123> lol
17:33:05 <Hilol123> !monologue
17:33:06 <oBurnBoto> Hello, oBurnBoto here.
17:33:08 <oBurnBoto> Aren't trains really cool?
17:33:10 <oBurnBoto> They just go so fast...
17:33:20 <Hilol123> lol ok
17:33:24 <dfeuer> I'm missing something...  When I compile a very simple function,  rem256 x = x `rem` 256, using ghc -O2 -ddump-asm  (with or without llvm, ghc 7.6.3) I see that it uses idivq. Shouldn't it just use a bitwise AND?
17:33:30 <Hilol123> !echo hi
17:33:31 <oBurnBoto> hi
17:37:05 <mikeizbicki> dfeuer: ghc and llvm perform very little numeric optimizations
17:37:37 <mikeizbicki> the fast-math library on hackage implements rules pragmas that partially fix this problem
17:37:57 <mikeizbicki> there's currently no support for that particular rule, but I'd be happy to add it if it's useful for you
17:38:02 <mikeizbicki> it shouldn't be that hard I don't think
17:39:12 <spott> is there a typeclass for indexed traversal?
17:39:28 <spott> or is zipwith the idiom?
17:39:47 <spott> what about for more complicated structures?
17:39:59 <MP2E> spott : There are indexed lenses
17:40:08 <MP2E> I'd look at lens if you are traversing complicated structures
17:40:22 <spott> thanks
17:40:25 <spott> I'll look into it
17:41:54 <dfeuer> mikeizbicki, it would (presumably) be easy to add rules for the absurdly simple cases like that, but what about ones that may be less clear-cut, like mod 255?
17:43:57 <mikeizbicki> I don't think it would be too bad to replace all the mods with bitwise ands
17:44:14 <mikeizbicki> at the very least, template haskell could be used to get everything up to 10000 or so
17:46:42 <dfeuer> mikeizbicki, I'm not understanding you, and not just because I don't know the first thing about Template Haskell. Are you talking about huge powers of two for Integers?
17:49:37 <dfeuer> mikeizbicki, it looks like llvm does do something, once you actually invoke the correct GHC flag..... what it does looks a bit *weird* though.
17:50:47 <Zekka> @pl \x y -> x ++ "\n" ++ y
17:50:47 <lambdabot> (. ('\n' :)) . (++)
18:01:13 <dagano> i'm trying to understand folds more generally .. basically a fold is a transformation from one structure to another...no? ie you tear down one structure to produce another.
18:02:05 <dfeuer> dagano, more generally it's some sort of category-theoretic thingum.
18:02:07 <dagano> ie does it make sense to use a fold to transform a graph into its minimum spanning tree?
18:02:17 <peddie> dagano: https://en.wikipedia.org/wiki/Catamorphism
18:02:36 <platz> I thought I understood basic folds untill I found out about bouncy folds.
18:02:38 <danilo2> Hello! Is there a version of GHC somewhere, where can we try the -XOverloadedRecordFields extension ?
18:04:11 * hackagebot statistics 0.12.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.12.0.0 (BryanOSullivan)
18:04:22 <dfeuer> It usually makes sense to use a fold if you can. As for the category theory stuff, I have no clue.
18:05:54 <guesting> If I have a program that takes up 16 gigs of memory but in profiling "unstreamChunks/inner" takes up 56% allocation, is it my fault? Am I causing a space leak or is it Data.Text?
18:06:31 <guesting> The other largest % is 3%, so...
18:07:06 <copumpkin> guesting: hard to say with no context. Lots of people use Data.Text so it seems less likely that it's the library, but software can have bugs :)
18:07:14 <copumpkin> bos might have good suggestions to figure it out
18:07:29 <guesting> copumpkin: I've been using data.text forever and it's been fine
18:07:41 <copumpkin> what are you doing with it?
18:07:42 <platz> dfeuer: but it seems like production code avoids the fold util functions
18:07:44 <guesting> but I don't know what unstreamChunks does so
18:10:20 <dfeuer> platz, my vague understanding is that there are likely two things contributing to this: 1. some folds have only *very* recently been made to compile well. 2. Code written before that has not been changed.
18:10:34 <dfeuer> It also could be that people have written a lot of code defensively.
18:11:10 <platz> wow, I didn't know work was being done to optimize this - that's great news
18:18:04 <PotatoGim> Hi
18:19:31 <ReinH> Hi!
18:19:35 <dfeuer> Hello, PotatoGim. Can we apply you, or abstract you?
18:22:39 <dagano> is there any way to "stop" a fold prematurely? ie say I'm folding over some graph to produce disjoint clusters...and i want to stop when i have 3 clusters
18:23:04 <bitemyapp> take 10 $ foldr (+) 0 [1..]
18:23:06 <bitemyapp> > take 10 $ foldr (+) 0 [1..]
18:23:08 <lambdabot>  No instance for (GHC.Show.Show a0)
18:23:08 <lambdabot>    arising from a use of ‘M58800021151989981402453.show_M58800021151989981402...
18:23:08 <lambdabot>  The type variable ‘a0’ is ambiguous
18:23:08 <lambdabot>  Note: there are several potential instances:
18:23:08 <lambdabot>    instance [safe] GHC.Show.Show
18:23:14 <bitemyapp> wat
18:23:17 <platz> perhaps an unfold instead?
18:23:48 <PotatoGim> dfeuer: oh.. I can't understand that... :-S;
18:23:55 <dfeuer> > take 10 $ foldr (+) (0::Int) [1..]
18:23:56 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘GHC.Types.Int’
18:23:57 <jle`> bitemyapp: take 10 from an integer? ;)
18:24:06 <bitemyapp> OH RIGHT
18:24:16 <marchelzo_> how can I combine parsers in parsec? Like if I want to parse a digit followed by the characted k, what can I do instead of do {d <- digit; k <- char 'k'; return $ d:k:[]}?
18:24:17 <jle`> > foldr (||) False (repeat True)
18:24:18 <bitemyapp> damn. that's my cue to feck off.
18:24:18 <lambdabot>  True
18:24:37 <dfeuer> Ah, right.
18:25:03 <jle`> marchelzo_: is that not ok?
18:25:04 <dfeuer> >  foldr (+) (0::Int) $ take 10 [1..]
18:25:05 <lambdabot>  55
18:25:42 <marchelzo_> jle`: that specific case isn't bad, but can I combine them like that with some Applicative function or Monadic function?
18:26:27 <jle`> marchelzo_: you can use Applicative if none of the lines ever depend on anything above
18:26:39 <platz> dagano: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/base/Data-List.html#v:unfoldr
18:26:41 <jle`> > (:) <$> digit <*> char 'k' <*> pure []
18:26:42 <lambdabot>  Not in scope: ‘digit’
18:26:54 <jle`> that shouldn't have beeh a lambdabot thing...and also it's wrong heh.
18:27:23 <jle`> hm
18:27:49 <rola> what's the type signature ::Int for in that context?
18:27:58 <jle`> @pl \x y -> [x,y]
18:27:58 <lambdabot> (. return) . (:)
18:28:02 <benzrf> jle`: i think your're applying (:) to too many arguments
18:28:12 <jle`> benzrf: yea,h it doesn't work
18:28:17 <benzrf> maybe you mean:
18:28:30 <benzrf> (:) <$> (digit <* char 'k') <*> pure []
18:28:41 <benzrf> :t (<&>)
18:28:41 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:28:43 <jle`> benzrf: he wants the char tho
18:28:52 <benzrf> jle`: what?
18:28:53 <marchelzo_> (:) <$> digit <*> char 'k' <$> (:) pure [] does that work?
18:28:55 <benzrf> it's always k
18:29:02 <benzrf> marchelzo_: applicative style
18:29:13 <jle`> basically he wants liftA2 (\x y -> [x,y]) digit (char 'k')
18:29:14 <benzrf> marchelzo_: lrn2use it
18:29:20 <benzrf> jle`: then why not use that
18:29:24 <marchelzo_> benzrf: how do i into it
18:29:44 <benzrf> how about:
18:29:59 <jle`> marchelzo_: basically applicative style is: turn foo 4 2 6 into foo <$> Just 4 <*> Just 2 <*> Just 6
18:30:06 <benzrf> fmap (:"k") (digit <* char 'k')
18:30:08 <jle`> marchelzo_: you can use the liftA2
18:30:20 <benzrf> or how about:
18:30:26 <jle`> you can also use string
18:30:28 <jle`> hm
18:30:28 <benzrf> sequenceA [digit, char 'k']
18:30:35 <benzrf> ^most ellelegant way
18:30:38 <jle`> ah yeah, that's what sequence is for
18:30:40 * jle` feels silly
18:30:44 <benzrf> ;)
18:30:47 <jle`> you can just use sequence from Control.Monad
18:30:57 <benzrf> jle`: oh i was thinking we were doin applicative
18:31:21 <marchelzo_> benzrf: you are a wizard. I agree about sequence being more elegant but that fmap one is neat
18:31:22 <jle`> benzrf: he said either was fine :)
18:31:53 <benzrf> marchelzo_: fmap one is less instantly clear
18:31:56 <marchelzo_> Yeah I forgot about sequence.. I know there had to be some simple function that did exactly what I wanted
18:32:04 <marchelzo_> benzrf: I agree. I like it, though.
18:32:14 <benzrf> :-)
18:32:35 <benzrf> marchelzo_: dont forget about (<*) when composing parsers and actions
18:32:40 <benzrf> it's vry handy
18:32:42 <benzrf> :t (<*)
18:32:43 <lambdabot> Applicative f => f a -> f b -> f a
18:32:51 <marchelzo_> :t (<<)
18:32:52 <lambdabot>     Not in scope: ‘<<’
18:32:52 <lambdabot>     Perhaps you meant one of these:
18:32:52 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
18:32:59 <benzrf> marchelzo_: it's like (*>), but it keeps the result of the first one instead of the 2nd
18:33:05 <benzrf> marchelzo_: it still runs from left to right though
18:33:08 <benzrf> marchelzo_: so for example:
18:33:17 <benzrf> getLine <* putStrLn "OK"
18:33:25 <benzrf> ^this will get a line, then say OK, but result in the line
18:33:29 <benzrf> not in ()
18:33:38 <dfeuer> How the bleep do I install ghc 7.8.3 on Fedora 20?
18:33:56 <benzrf> marchelzo_: note that plain old 'foo <* bar = bar *> foo' runs them in reverse order
18:34:02 <benzrf> it's not the same as flipping the args
18:34:05 <marchelzo_> what about getLine `(flip (>>))` putStrLn "OK"
18:34:14 <benzrf> marchelzo_: that would put OK first
18:34:29 <benzrf> marchelzo_: (<*) is good for parsing suffixes without resulting in them
18:34:45 <marchelzo_> I see..
18:34:50 <benzrf> do {result <- a; b; return a} becomes a <* b
18:34:58 <jle`> marchelzo_: flip (>>) getLine (putStrLn "OK") is putStrLn "OK" >> getLine
18:34:59 <benzrf> oops i mean return result
18:35:15 <jle`> this is the reason why (<<) doesn't exist; is it flip (>>), or is it a monadic (<*) ?
18:35:38 <benzrf> jle`: cant you make the same argument about (<*) w.r.t. (*>)
18:35:41 <marchelzo_> benzrf: ok I am starting to see how useful that could be
18:36:21 <latro`a> benzrf, in just Applicative there's no ambiguity
18:36:26 <jle`> benzrf: yea
18:36:29 <jle`> oh
18:36:32 <jle`> i thought you said "you can't"
18:36:37 * jle` should calm down
18:37:02 <marchelzo_> benzrf: So are "putStrLn "OK" >> getLine" and "putStrLn "OK" *> getLine" the same?
18:37:11 <benzrf> latro`a: what? how so?
18:37:20 <benzrf> latro`a: (<*) could be flip (*>)
18:37:23 <benzrf> but it's not
18:37:32 <benzrf> how is that different from (<<) not being flip (>>)
18:37:36 <benzrf> marchelzo_: yes
18:38:00 <benzrf> marchelzo_: (*>) is denotationally equivalent to (>>) when (<*>) is the same as ap
18:38:08 <benzrf> which it generally should be, or your instances are wack
18:38:52 <marchelzo_> I have never seen ap.. is it just the prefix version of <*>?
18:39:09 <jle`> marchelzo_: it's the monad version
18:39:11 <benzrf> ap is (<*>) implemented in terms of (>>=)
18:39:11 <jle`> :t ap
18:39:12 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:39:15 * hackagebot streaming-commons 0.1.4 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.4 (MichaelSnoyman)
18:39:15 <jle`> @src ap
18:39:15 <lambdabot> ap = liftM2 id
18:39:18 <jle`> er
18:39:33 <jle`> ap mf mx = do { f <- mf; x <- mx; return (f x) }
18:39:59 <benzrf> marchelzo_: if that doesnt do the same thing as your (<*>) implementation then you're doing it wrong
18:40:20 <jle`> or more like, the Monad laws and the Applicative laws ensure that they are equivalent functionally
18:40:34 <marchelzo_> doing it wrong technically or is it just bad practice?
18:40:34 <jle`> so if you have lawful monads and applicatives, you don't have to worry
18:40:53 <jle`> doing it wrong as in...you have unlawful instances
18:41:03 <jle`> so your functions aren't usable for equational reasoning
18:41:03 <marchelzo_> But the compiler won't say anything?
18:41:12 <jle`> which is like...half of the advantages of typeclasses in the first place
18:41:17 <jle`> marchelzo_: yeah.  it's like if you defined a bad Eq
18:41:25 <marchelzo_> jle`: oh ok
18:41:35 <jle`> instance Eq () where () == () = False; () /= () = False
18:41:47 <jle`> i mean...yeah you can do that.  but...every time you see an equals sign...you really can't reason about what it could mean
18:41:55 <marchelzo_> jle`: right
18:42:34 <jle`> that's one of haskell's + typeclasses's great benefits actually, as you go through it more :)  you'll see it more and more
18:43:00 <jle`> but it only works if you have lawful instances
18:43:13 <jle`> ...which is kind of annoying, but...if we pretend everything is lawful, it works out :)
18:43:36 <marchelzo_> what exactly is a lawful instance?
18:43:50 <jle`> marchelzo_: an instance that follows certain laws for a given typeclass
18:44:08 <jle`> there are Monad laws and Applicative laws, right?
18:44:23 <jle`> we were able to use those laws to *prove* that ap == (<*>)
18:44:27 <marchelzo_> ok I see.
18:44:29 <jle`> even though, looking at the source of ap
18:44:35 <jle`> ap mf mx = do { f <- mf; x <- mx; return (f x) }
18:44:40 <benzrf> jle`: well
18:44:56 <jle`> so if your instances follow the laws, then you can prove mathematically that they say the same thing
18:45:01 <benzrf> technically speaking, it's possible to have law-abiding instances of (<*>) and (>>=) that result in ap /= (<*>)
18:45:15 <benzrf> @google error monad applicative instance
18:45:15 <lambdabot> http://hackage.haskell.org/package/category-extras-0.44.4/docs/src/Control-Monad-Either.html
18:45:16 <lambdabot> Title: src/Control/Monad/Either.hs
18:45:18 <benzrf> hmmm
18:45:30 <jle`> ah
18:45:43 <jle`> hm
18:45:46 <jle`> well
18:45:49 <jle`> not if return = pure
18:45:53 <jle`> ...i think
18:46:24 <marchelzo_> so if I did something like instance Ord Char where (>) x y = False; (<) x y = True; it would be unlawful?
18:46:24 <MP2E> when would return /= pure ?
18:46:32 <MP2E> I just took it for granted that they were always the same
18:46:37 <jle`> MP2E: well
18:46:49 <jle`> there is only one possible Functor instance for a given type, if one is possible
18:47:01 <jle`> and a lot of types only admit one monad instance
18:47:06 <jle`> but many types admit multiple Applicative instances
18:47:27 <jle`> for example you can have an Applicative instance for [] where pure x = repeat x
18:47:45 <benzrf> 09:44 < jle`> there is only one possible Functor instance for a given type, if one is possible
18:48:29 <MP2E> ahh that makes sense.
18:48:41 <MP2E> i forget that things can have multiple applicative instances
18:48:44 <benzrf> how is this proven?
18:49:15 * hackagebot conduit 1.1.7 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.1.7 (MichaelSnoyman)
18:49:17 * hackagebot conduit-extra 1.1.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.2 (MichaelSnoyman)
18:49:36 <dfeuer> How do I install GHC 7.8.3 somewhere in my home directory (7.6.3 is installed on the system) and make everything work?
18:49:39 <MP2E> benzrf: benzrf http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
18:49:43 <MP2E> whoops double highlight hehe
18:51:12 <jle`> hm
18:52:26 <jle`> benzrf, marchelzo_ okay, so i think i was a bit premature.  you can have a Monad instance and an Applicative instance for a type where pure = return and (<*>) for that specific instance  =/ ap
18:52:29 <jle`> i think went a bit overboard, sorry
18:52:39 <jle`> hope i didn't cause too much confusion by talking too fast :)
18:52:57 <benzrf> MP2E: ooh thats clever
18:53:10 * benzrf doesnt know shit about free theorems
18:53:23 <benzrf> jle`: i think you mean (/=)
18:53:36 <jle`> benzrf: that was supposed to be a smiley face :)
18:53:43 <MP2E> benzrf : a free theorem just means it's a theorem derived only from the generic properties of the typeclass, it doesn't imply anything beyond that it's a functor
18:53:44 <benzrf> oh
18:53:46 <benzrf> i parsed it as such
18:53:47 <benzrf> haha
18:53:55 <jle`> but! if you have  Monad instance, then return + ap for that Monad always forms a valid, lawful Applicative
18:53:59 <jle`> that must be what i was triyng to say :) yeah!
18:54:02 <MP2E> which is what we need to prove that there is only one functor for any given type, incidentally :)
18:54:55 <bb010g> dfeuer: You could try using the Nix package manager alongside whatever you have for isolation.
18:54:58 <bb010g> Are Arrows a special case of Semifunctor?
18:55:16 <cschneid> jle`: hey - reading your post about machines / stream/auto - just finished the first one, very well written - thanks for writing it up :)
18:55:44 <jle`> cschneid: thanks :)  let me know if you have any questions
18:56:05 <jle`> and you're welcome :)
18:56:15 <aupiff> can I get a link to those posts?
18:57:01 <SrPx> Hey guys, am I mistaken or here, "Right" and "Left" should be "Branch" and "Leaf"? http://o7.no/1sW2egW - http://en.wikipedia.org/wiki/Anamorphism (not confident enough to edit)
18:57:28 <MP2E> bb010g: I'm not actually familiar with semifunctors, but Arrows are monoids in the category of profunctors
18:57:32 <nexion> is it a good approach to deal with divisions by zero by letting them happen and then checking for infinity at the end of the calculations?
18:57:43 <nexion> (with Double)
18:57:52 <bb010g> MP2E: I have no idea what a profunctor is. o.o
18:58:18 <rkazak> bb010g: but you have google....
18:58:29 <dfeuer> srbaker, I don't see what Right and Left have to do with Branch and Leaf.
18:58:32 <dfeuer> Sorry...
18:58:35 <dfeuer> I meant SrPx.
18:58:56 <SrPx> I guess I still don't understand unfold then :(
18:59:15 <MP2E> bb010g: a profunctor is a bifunctor that is contravariant in it's first argument and covariant in it's second. Here's a better explanation : https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
18:59:44 <jle`> aupiff: series is http://blog.jle.im/entries/series/+intro-to-machines-and-arrows
19:02:47 <cschneid> jle`: a nitpick :)  -- "Just be sure to use the write imports" -- should be "right" I think. :)
19:03:13 <jle`> cschneid: :P
19:03:15 <jle`> thanks
19:04:49 <cschneid> jle`: ugh, so many links in your post. This is gonna take me a while to work through :)
19:04:54 <cschneid> wheee. Learning.
19:05:39 <jle`> boo learning, who needs that
19:07:20 <Ankhers> Could someone please point me in the direction of what my instance declaration should look like? http://lpaste.net/107507
19:07:50 <Ankhers> Or tell me if I am doing something horribly wrong?
19:08:15 <benzrf> Ankhers: why are you doing 'return ()'
19:08:18 <benzrf> that's a complete noop
19:08:31 <benzrf> :t put
19:08:31 <Ankhers> I thought it was, but wasn't 100%
19:08:32 <lambdabot> MonadState s m => s -> m ()
19:08:36 <benzrf> look ^
19:08:41 <benzrf> put results in an m ()
19:09:18 * hackagebot purescript 0.5.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.3 (PhilFreeman)
19:09:20 <Ankhers> Yes. I actually removed that from my code. I guess I forgot to remove it from the paste.
19:09:59 <enthropy> Ankhers: it's probably not helpful to write    instance MonadState (Connection, Channel) IO where get = readIORef someUnsafePerformIO'dIORef
19:11:05 <enthropy> something like that will make your code typecheck, but it might be a better idea to have rabbitConnection :: StateT (Connection, Channel) IO ()
19:11:44 <benzrf> Ankhers: why are you using rabbit WHEN YOU COULD BE USING ØMQ CMON LISTEN TO ME EVANGELIZE
19:12:19 <enthropy> or maybe it's just as simple to have    rabbitConnection :: IO (Connection, Channel)
19:12:50 <Exio4> is it possible to include a guard directly into the 'pattern'? something like f (x>0) = x+1
19:13:05 <Ankhers> http://lpaste.net/107508 That is what I had. I didn't have the return ().
19:13:17 <benzrf> Exio4:
19:13:20 <benzrf> f 0 = ...
19:13:22 <benzrf> f x = ...
19:13:23 <benzrf> ;)
19:13:53 <Exio4> uhm?
19:14:04 <benzrf> f 0 = ...
19:14:06 <benzrf> f x = x + 1
19:14:06 <Exio4> i don't want to take negatives!
19:14:11 <benzrf> oh
19:14:14 <Exio4> (and it was just an example)
19:14:16 <benzrf> why not use guards?
19:14:48 <enthropy> Ankhers: I've annotated one option
19:14:51 <Exio4> because the only thing i did in some cases was a single-case guard and then catch other cases with normal pattern matching
19:15:36 <benzrf> is that so awful
19:15:45 <benzrf> f x | x > 0 = x + 1
19:15:50 <benzrf> f (x > 0) = x + 1
19:15:53 <benzrf> barely longer
19:15:58 <Exio4> i know
19:16:08 <Exio4> but i found repeating a variable too weird in haskell
19:16:18 * benzrf shrugs
19:20:13 <bb010g> benzrf: You can write f (x > 0) = ...?
19:20:40 <benzrf> bb010g: no
19:20:47 <benzrf> i was contrasting with Exio4's hypothetical syntax
19:22:00 <Ankhers> When using the type signature by enthropy, I am getting other errors. http://lpaste.net/107511
19:22:02 <bb010g> Oh. A language extension that took urnary predicates like that would actually be nice. Kinda the same vein as view patterns.
19:22:19 <enthropy> Ankhers: you need lift in that case
19:22:53 <enthropy> to turn the (IO x) that the openConnection produces into a   StateT s IO x
19:23:38 <zq> :t forever
19:23:39 <lambdabot> Monad m => m a -> m b
19:27:05 <Ankhers> enthropy: I understand the reason for it. Unfortunately, I am at a loss of how to actually apply it. Can you suggest a tutorial or something?
19:27:15 <bb010g> Exio4: With view patterns, you could make a function ``gtZero x | x > 0 = x`` and then use ``f (gtZero -> x) = x + 1``.
19:27:43 <benzrf> bb010g: wait, view functions can be partial?
19:27:49 <Exio4> neat, didn't know about them
19:27:57 <benzrf> Exio4: i dont think that's how it works
19:28:03 <Exio4> thanks for the info, will look more about view patterns later :P
19:28:05 <bb010g> benzrf: I don't see why not. I haven't tried it.
19:28:05 <Exio4> ahm
19:28:11 <benzrf> Exio4: the idea is that you can apply a function to something nested in a match and match against the resultf
19:28:14 <benzrf> *result
19:28:16 <benzrf> for example
19:28:28 <bb010g> Trying it now
19:28:47 <benzrf> f (abs -> 3):xs = something
19:29:00 <benzrf> ^this will match [-3, 1, 6] or [3, 1, 6]
19:29:08 <benzrf> it applies abs before matching on the result
19:29:24 <benzrf> i dont think partial functions allow you to use them like guards, though
19:29:27 <benzrf> i could be wrong!
19:29:31 <bb010g> It works
19:29:36 <benzrf> bb010g: oh, neat
19:29:44 <benzrf> Exio4: there are also pattern guards
19:29:52 <bb010g> f 0 returns *** Exception: package.hs:40:1-20: Non-exhaustive patterns in function gtZero
19:29:53 <benzrf> which are sort of isomoprhic
19:29:56 <enthropy> Ankhers: the answer is at the bottom of http://lpaste.net/107508.
19:30:01 <benzrf> bb010g: yes, thats what i expected
19:30:32 <enthropy> as for a tutorial, I'm not sure. One idea is to look at the source and documentation in mtl/transformers
19:31:19 <Ankhers> enthropy: Sorry. I didn't realize that is what you meant when you said you annotated. Thank you for the help!
19:31:21 <enthropy> and when you run into language features like multiparameter type classes and functional dependencies, the ghc manual is pretty helpful there
19:31:45 <zq> > you
19:31:47 <lambdabot>  "poo"
19:31:50 <zq> ^ what is going on here
19:32:02 <bb010g> > let me = "awesome"
19:32:03 <lambdabot>  not an expression: ‘let me = "awesome"’
19:32:04 <bb010g> > me
19:32:06 <lambdabot>  Not in scope: ‘me’
19:32:06 <lambdabot>  Perhaps you meant one of these:
19:32:06 <lambdabot>    ‘m’ (imported from Debug.SimpleReflect),
19:32:06 <lambdabot>    ‘e’ (imported from Debug.SimpleReflect),
19:32:06 <lambdabot>    ‘re’ (imported from Control.Lens)
19:32:21 <bb010g> > me = "awesome"
19:32:22 <lambdabot>  <hint>:1:4: parse error on input ‘=’
19:32:31 <bb010g> > me <- return "awesome"
19:32:33 <lambdabot>  not an expression: ‘me <- return "awesome"’
19:32:38 <enthropy> @let me = "not so awsome"
19:32:39 <lambdabot>  Defined.
19:32:40 <enthropy> > me
19:32:42 <lambdabot>  "not so awsome"
19:32:45 <Iceland_jack> > you
19:32:47 <lambdabot>  "poo"
19:32:50 <Iceland_jack> hm what
19:33:12 <zq> doesn't work in ghci, thank god
19:39:53 <rkazak> any help on getting started with Haskell on OSX ?
19:39:54 <guesting> This code is untested, I just want to understand something http://pastebin.com/5pEu3cfV will that lead to a memory leak? It's in whnf, right (the outermost funciton is a data constructor)?
19:41:27 <staffehn> guesting: you should add a type declaration
19:42:07 <guesting> staffehn: Sorry, it was just a really quick put together
19:42:47 <staffehn> guesting: I assume you meant "f _ []     = []" for the first case
19:43:30 <guesting> staffehn: Yeah, sorry. I should just have tested it
19:43:47 <arancia> guesting: Where do you expect a memory leak?
19:44:00 <staffehn> guesting: then if you don't want to force it to be an Enum use "repeat x" instead of "[x,x..]"
19:44:33 <staffehn> guesting: or use "replicate 10 x" instead of the whole "take 10 (repeat x)"
19:45:36 <guesting> ah, this mass exodus and joining is clogging up everything!
19:45:37 <staffehn> guesting: about space leaks, you will get a resulting list of lists lazily, so there will be no memory leaks
19:46:24 <guesting> staffehn: This is NOT tail recursion, correct?
19:46:44 <staffehn> guesting: no, not tail recursion
19:47:53 <ReinH> guesting: GHC doesn't do anything special when evaluating tail recursive functions
19:47:55 <staffehn> guesting: but if you pattern-match on the result you just get two thunks, the first element being the unevaluated g and the rest of the list being the unevaluated recursive call
19:47:59 <ReinH> it isn't even aware that they are tail recursive
19:48:38 <Exio4> GHC doesn't do TCO? wth?
19:48:49 <dolio> Who said that?
19:48:54 <ReinH> Not me.
19:49:09 <dolio> Exactly.
19:49:19 <ReinH> GHC does TCO because it performs left-most outermost redex reduction
19:49:23 <ReinH> and "tail calls" are in that position
19:49:37 <ReinH> There is no code in GHC to detect tail calls.
19:49:41 <Exio4> i see
19:49:51 <dolio> All calls are tail calls.
19:49:54 <guesting> staffehn: But it's in whnf and the latter cons is in whnf--doesn't that build up unevaluated g's?
19:49:56 <ReinH> exactly
19:50:02 <dolio> So it makes sure they're optimized. :)
19:50:15 <ReinH> It optimizes these calls whether they are recursive or not
19:50:22 <ReinH> and recursive tail calls < all tail calls ;)
19:50:30 <dolio> Yeah.
19:50:38 <dolio> Languages that only optimize tail recursion are a pain.
19:51:11 <ReinH> @src foldl
19:51:11 <lambdabot> foldl f z []     = z
19:51:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:51:21 <ReinH> the recursive "call" to foldl is in left-most outermost position
19:51:21 <staffehn> guesting: If you just apply f like in f 3 [1..5] the whole thing will not be in whnf, but a thunk in the first place
19:51:29 <ReinH> the fact that it is recursive is not important
19:51:50 <ReinH> and "tail recursion" by itself isn't sufficient, you need strictness annotations as well, i.e., foldl'
19:52:07 <guesting> staffehn, true, but it's building, right?
19:52:15 <ReinH> SimonM calls it "corner position" but I haven't seen anyone else use that term?
19:52:27 <guesting> staffehn: Like in "foldl" a bit
19:52:44 <guesting> staffehn wait no, not like that
19:52:48 <staffehn> guesting: If you pattern match on the result though it evaluates into whnf, and that involves checkin the [] and 0 conditions and then either evaluating to [] or to (g : next)
19:53:12 <ReinH> That paste is more similar to foldr than foldl
19:53:17 <staffehn> guesting: It is not like a fold but rather like a map..
19:53:23 <guesting> yeah
19:53:31 <ReinH> f and foldr (:) both put (:) in left-most outermost position
19:53:45 <ReinH> staffehn: map *is* a fold
19:53:59 <guesting> staffehn: So what if it's not pattern matched and is instead guards?
19:54:05 <staffehn> ReinH: right, well...
19:54:17 <guesting> n == 0 and null xs and whatnot
19:54:28 <staffehn> guesting: It is not like foldl but like foldr
19:54:52 <ReinH> I'd hate to have the handle "fold" in #haskell o_O
19:54:57 <ReinH> fold: hai
19:55:07 <staffehn> guesting: then the guard will pattern match to access it.
19:55:27 <guesting> staffehn: What? Guards pattern match?
19:55:37 <guesting> oh
19:55:44 <guesting> you mean f n xs is the pattern match
19:55:50 <guesting> ?
19:56:12 <ReinH> @src null
19:56:12 <lambdabot> null []     = True
19:56:12 <lambdabot> null (_:_)  = False
19:56:24 <staffehn> guesting: A guard on a is just a function of type (a -> Bool), for a list its implementation will use patternmatching
19:56:25 <ReinH> guesting: how does a guard f xs | null xs = ... work without pattern matching?
19:56:46 <ReinH> null xs needs to evaluate xs enough to determine whether it is empty or not
19:56:49 <ReinH> this involves pattern matching
19:57:07 <guesting> n == 0 cannot possibly be pattern matching in any way though, right?
19:57:22 <coppro> it is
19:57:38 <guesting> that's impossible
19:57:39 <coppro> (==) will have an implementation for the specific number type
19:57:45 <guesting> there would need to be an infinite number
19:57:55 <ReinH> guesting: why?
19:57:56 <guesting> oh
19:57:59 <coppro> no. x == x = True; _ == _ = False
19:58:09 <guesting> wow
19:58:10 <guesting> im dumb
19:58:32 <ReinH> guesting: nope, you're just learning something new
19:58:33 <guesting> so...what ISNT pattern matching in haskell?
19:58:45 <coppro> admittedly, (==) is probably actually cheated by the compiler and implemented as a builtin
19:59:01 <coppro> but from a theretical standpoint, it's pattern matching
19:59:23 <coppro> guesting: template haskell. that's just voodoo
19:59:25 <coppro> :P
19:59:30 <guesting> haha
19:59:48 <kristof> Template haskell is just haskell for language constructs in a Q monad
19:59:49 <kristof> no big deal
20:00:11 <Polarina> kristof, you have not explained the Q monad.
20:00:30 <benzrf> the Q monad is a monad for Q
20:00:31 <staffehn> Nah, GHC's implementation of Numbers has nothing to do with template haskell
20:00:34 <kristof> Polarina: a monad for Q
20:00:35 <benzrf> ^fact
20:00:37 <kristof> Oh, someone beat me to it
20:01:39 <guesting> <staffehn> guesting: If you pattern match on the result though it evaluates into whnf, and that involves checkin the [] and 0 conditions and then either evaluating to [] or to (g : next) << so you are saying that g : next is NOT building thunks because it's being evaluated through the pattern match?
20:02:43 <staffehn> guesting: the (g : next) is actually a cons cell containing two thunks, namely g and next (in unevaluated state.
20:03:40 <staffehn> guesting: so if you don't use the first list entry g it will never be computed, if you don't use the rest of the list "next" if will never be computed.
20:04:13 <guesting> staffehn: But it IS being computed to check for []?
20:04:37 <ReinH> guesting: pattern matching is the engine that drives the evaluation of Haskell programs.
20:04:40 <ReinH> It's pretty much everywhere.
20:04:40 <guesting> staffehn: This fails in foldl because acc is never needed until the end, so there is no pattern match checking?
20:04:48 <guesting> is that right?
20:04:55 <ReinH> guesting: one sec
20:04:56 <ReinH> @where lazy
20:04:56 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
20:05:18 <ReinH> A few more relevant links
20:05:40 <staffehn> guesting: yes
20:05:48 <guesting> staffehn: YAY!
20:05:57 <ReinH> guesting: these all discuss lazy evaluation and foldl vs foldr in Haskell
20:05:58 <guesting> ReinH: I need to memorize that
20:06:24 <ReinH> I wrote two of them, mostly by borrowing from monochrom's
20:06:56 <staffehn> guesting: there is another mechanizm, the seq function, that will evaluate its first argument to whnf before returning the second argument.
20:07:21 <guesting> yeah
20:08:03 <staffehn> guesting: But pattern matching obviously evaluates to whnf before it can tell what constructor is used.
20:08:20 <guesting> yeah, so it's unnecessary here
20:10:13 <guesting> so, what would cause a HUGE increase in memory? Like, a constant slope hill in a profiling graph (and then it all remains at slope 0 after the huge climb until the end, never sinking)? How would I know if that's do to a memory leak or just because there's a big calculation?
20:11:19 <staffehn> guesting: It is kind of tricky sometimes, to make it short, but there are definately good examples (for bad things)..
20:11:48 <staffehn> guesting: I'm gonna think a few seconds..
20:12:54 <guesting> staffehn: It's tricky, because one of the big offenders is mappend in "foldr mappend mempty" which apparently takes up a bunch of memory. I just assume it's a data thing, not a me messing up thing
20:15:34 <jle`> get a list of all indices in a list
20:15:42 <jle`> > zipWith const [0..] [1,6,3,5,7,1,3]
20:15:44 <lambdabot>  [0,1,2,3,4,5,6]
20:15:45 <jle`> hehe
20:16:49 <jle`> > M.keys . M.fromList . zip [0..] $ [1,6,3,5,7,1,3]
20:16:51 <lambdabot>  [0,1,2,3,4,5,6]
20:16:53 <jle`> :|
20:17:33 <chrisdotcode> can anyone help me with a template-haskell error real quick? (a one liner)
20:19:10 <enthropy> chrisdotcode: sure
20:20:26 <chrisdotcode> enthropy: http://lpaste.net/107514
20:21:01 <chrisdotcode> basically, it's getting the element from a singleton element, and erroring otherwise
20:21:13 <chrisdotcode> but I'm getting errors, calling... the error function in TH, ironically
20:21:59 <enthropy> I guess the pretty printer forgot the leading '
20:22:16 <enthropy> 'GHC.Err.error
20:22:49 <chrisdotcode> ah, yes!
20:23:05 <chrisdotcode> it loads now
20:23:05 <chrisdotcode> (and works)
20:23:05 <chrisdotcode> where can I file a GHC bug report?
20:23:18 <enthropy> it's much nicer to use the [| |] quotes directly when you can
20:23:43 <chrisdotcode> enthropy: what do you mean? my only knowledge of TH is from this: http://www.slideshare.net/kizzx2/template-haskell-tutorial
20:23:52 <chrisdotcode> and I'm messing aroudn right now; any advice would be helpful :)
20:23:55 <staffehn> guesting: also problematic are as already stated, lazy accumulators, which build up nested thunks that can take up a lot more space than the result if for example an int
20:24:12 <staffehn> guesting: and so on.. as I said it can be tricky
20:24:35 <enthropy> chrisdotcode: list = [| \xs -> case xs of [x] -> x; _ -> error "Not enough values to convert" |]
20:25:42 --- mode: cameron.freenode.net set +o ChanServ
20:26:39 <chrisdotcode> enthropy: well that's much easier...
20:27:01 <chrisdotcode> but I'm about to potentially introduce some code that won't work with the QQ format
20:27:08 <chrisdotcode> but thanks for letting me know, that's super convenient
20:27:15 <enthropy> dunno how this advice of "use runQ to have GHC write the splice for you" gets justified
20:27:52 <guesting> staffehn: But the lazy accumulator would lead to a stack overflow, right? Not an increase in memory usage to a large extent.
20:27:57 <enthropy> chrisdotcode: well you can mix the quote brackets with the lowercase constructors
20:28:10 <guesting> well, that would be cut short by the overflow
20:28:24 <chrisdotcode> enthropy: do you have an example, please?
20:28:49 <enthropy>  do x <- newName "x"; lamE [varP x] [| 1 + $(varE x) |]
20:28:55 <Algebr> If i do cabal repl in a non sandboxed directory, then I'm just getting plain vanilla ghci, right?
20:29:05 <haywood> HOLA!
20:29:09 <enthropy> is just a long-winded way to write  [| \x -> 1 + x |]
20:29:59 <haywood> basic functional question. What's the idiomatic way to call 'union' on more than two lists?
20:30:12 <jmcarthur> :t union
20:30:13 <lambdabot> Eq a => [a] -> [a] -> [a]
20:30:19 <jmcarthur> didn't even know that function exists
20:30:24 <Algebr> :i union
20:30:27 <dmj`> Algebr: I think you get ghci no matter what, I think cabal repl just changes your package database to that of the sandbox. In the case of no sandbox it's probably your user global package database
20:30:28 <enthropy> @type foldr union []
20:30:29 <haywood> might be the same as intersect
20:30:29 <lambdabot> Eq a => [[a]] -> [a]
20:30:44 <chrisdotcode> enthropy: thanks a lot :)
20:30:57 <jmcarthur> :t foldMap Set.singleton
20:30:58 <lambdabot>     Not in scope: ‘Set.singleton’
20:30:58 <lambdabot>     Perhaps you meant one of these:
20:30:58 <lambdabot>       ‘Seq.singleton’ (imported from Data.Sequence),
20:31:03 <jmcarthur> :t foldMap S.singleton
20:31:04 <lambdabot> (Foldable t, Ord a) => t a -> S.Set a
20:35:29 <haywood> @type foldr union []
20:35:30 <lambdabot> Eq a => [[a]] -> [a]
20:35:43 <haywood> :(
20:35:58 <bb010g> :t union
20:35:59 <lambdabot> Eq a => [a] -> [a] -> [a]
20:36:53 <haywood> the rub is I'm using a javascript library that's influenced by haskell
20:37:09 <haywood> point free programming, but it's union fn only takes 2 lists
20:37:52 <haywood> it's auto curry'd
20:38:07 <haywood> I guess fold is part of the ideal solution
20:38:22 <jmcarthur> honestly i think lists are an inappropriate data structure for this operation
20:38:42 <jmcarthur> oh, not actually haskell
20:39:15 <haywood> yea, it's an array
20:39:17 <haywood> or vector?
20:40:15 <jmcarthur> eh, still not really appropriate, but what can you do?
20:50:02 <splintax> not appropriate, because you could have a situation where union myList [] != myList?
20:52:22 <Algebr> cabal's config is really sensitive to layout.
20:53:31 <marchelzo_> in Parsec is there a version of optional where instead of returning (), it returns the match if it's there or just an empty list if it's not
20:54:44 <bergmark> marchelzo_: `foo <|> return []`
20:55:17 <marchelzo_> bergmark: thanks. I was just thinking it was something like that but I forgot what the operator was.
20:58:35 <marchelzo_> bergmark: wait that consumes the character
20:59:42 <Welkin> use `try`
21:00:02 <marchelzo_> Welkin: how would I use it here
21:00:35 <marchelzo_> nvm I think I see
21:01:29 <bergmark> try to avoid backtracking if you can, it can lead to pretty confusing error messages
21:01:46 <jmcarthur> splintax: not appropriate because it's a set-like operation
21:02:11 <jmcarthur> splintax: and very inefficient
21:02:17 <marchelzo_> bergmark: what do you mean?
21:06:55 <marchelzo_> it doesn't even consume a character, I was mistaken.
21:08:01 <dfeuer> I wish -XScopedTypeVariables could be standard. It's such a pretty extension.
21:09:03 <carter> i wish GlasgowExtensions was a thing again
21:09:21 <dfeuer> Also -XOverloadedStrings (I'm not sure how I feel about overloaded literals in general, but if numeric literals are overloaded, string literals and character literals should be too. Speaking of which, is there an extension for overloaded character literals?)
21:10:08 <dfeuer> carter, how about limiting it to ObviouslyRightGlasgowExtensions?
21:10:09 <carter> :P
21:10:17 <carter> eh
21:10:25 <carter> -XAllTheThings
21:10:29 <dfeuer> :D
21:10:38 <carter> -XAllTheConfluentThings
21:10:45 <carter> are really the only two that matters
21:10:58 <dfeuer> carter, want to help me try to make isSquare from arithmoi faster? It does some things that make less sense than they should.
21:11:09 <carter> dfeuer: next weekend
21:11:37 <dfeuer> OK, carter.
21:11:51 <dfeuer> The most important part I don't know how to do well is write benchmarks.
21:11:57 <carter> criterion
21:11:58 <carter> use criterion
21:11:59 <carter> :)
21:12:02 <dfeuer> Yes, that much I know.
21:12:03 <carter> have you ever used criterion?
21:12:06 <carter> :)
21:12:12 <carter> arithmoi has zero benchmarks :(
21:12:13 <dfeuer> I've dabbled.
21:12:14 <marchelzo_> dfeuer: Is scoped type variables just the ability to put constraints on type variables and then avoid writing the same constraints in the same scope?
21:13:03 <dfeuer> marchelzo_, it's the ability to use an explicit forall to make the scope of a type variable that appears in the type of a function extend over its definition.
21:14:00 <dfeuer> It allows local functions to be given explicit type signatures in some cases where they otherwise couldn't be given them, and I think sometimes allows more good programs to be typed.
21:14:00 <marchelzo_> dfeuer: yeah that seems pretty useful and unobtrusive
21:14:33 <marchelzo_> dfeuer: why could they otherwise not be given them?
21:14:44 <dfeuer> carter, the trouble is that there are a *lot* of 64-bit integers out ther.
21:14:45 <dfeuer> there.
21:15:26 <carter> dfeuer: you just need to pick good represenatives
21:15:28 <dfeuer> So while Criterion seems to be very happy with the idea of "do this one thing a bunch of times", I need something different: do a huge sample of these different things.
21:15:31 <carter> why should i Care about isSquare
21:15:39 <carter> why
21:15:42 <dfeuer> Because it's fun?
21:15:45 <carter> no
21:15:48 <carter> ahhh
21:15:54 <carter> i mean
21:15:57 <carter> have you read hackers delight?
21:16:01 <carter> @google hackers delight
21:16:02 <lambdabot> http://www.hackersdelight.org/
21:16:02 <lambdabot> Title: Hacker's Delight
21:16:05 <dfeuer> No.
21:16:20 <carter> http://www.hackersdelight.org/hdcodetxt/isqrt.c.txt
21:16:24 <carter> integer square root
21:16:30 <carter> just compute the integer square root
21:16:34 <carter> then square again to check if the same
21:16:41 <suOya_> What's that book about?
21:16:41 <dfeuer> Ah, but that is a *mistake*
21:16:45 <suOya_> Bit manipulation?
21:17:15 <carter> hackers delight has all the bit fiddly tricks
21:17:16 <dfeuer> That's a mistake that arithmoi makes. Because a floating-point square root *approximation* is actually good enough for the job.
21:17:43 <suOya_> carter: is it heavy on math?
21:18:05 <carter> dfeuer: only if the number has < 54 bits right?
21:18:42 <carter> dfeuer: do you have benchmarks?
21:18:45 <carter> :)
21:19:12 <carter> i'm not going to believe any  micro perf claims that lack bencmarks
21:19:23 <corbindavenport> sup yall
21:19:24 <carter> dfeuer: i'd rather add integer simd support better to ghc
21:19:28 <dfeuer> carter, http://math.stackexchange.com/questions/237865/show-that-floating-point-sqrtx-cdot-x-geq-x-for-all-long-x
21:19:46 <carter> i believe the math
21:20:00 <carter> i don't believe the perf claim without easy to reproduce measurements
21:20:12 <carter> normal haskell ints are in the general purpose registers
21:20:18 <carter> floats are in SIMD regs
21:20:21 <dfeuer> Arithmoi has an integer square root function that uses floating point to approximate the square root,
21:20:33 <dfeuer> and then tests whether it's correct or whether it's necessary to subtract 1.
21:20:40 <xenocons> :h (a * b option) -> (a * c option)
21:20:45 <dfeuer> It then uses that integer square root function to implement isSquare.
21:20:59 <carter> ok
21:21:05 <carter> and no benchmarks
21:21:26 <carter> my stance on micro perf stuff is it needs benchmarks :)
21:21:32 <dfeuer> But based on what I linked to, the extra conditional branch and possible addition are entirely unnecessary.
21:21:40 <dfeuer> Right.
21:21:43 <carter> benchmarkssss :)
21:21:47 <dfeuer> That, carter, is why I would like you to help me
21:21:50 <dfeuer> write benchmarks.
21:21:52 <carter> :)
21:21:52 <carter> ok
21:21:56 <carter> well
21:22:03 <luite_> hmm
21:22:07 <carter> i kinda want to get some ghc patches underway
21:22:12 <carter> and finish numerical haskell alpha
21:22:25 <carter> ive an RFC to improve simd
21:22:34 <carter> and allow inline assembly
21:22:34 <dfeuer> The same benchmark will probably work for a lot of *other* number benchmarks!
21:22:41 <carter> why
21:22:56 <carter> i've enough neat things I want/ need to do
21:22:57 <carter> :)
21:23:13 <dfeuer> As a favor to an interested newbie?
21:23:24 <carter> i'm happy to be a resource
21:23:25 <dfeuer> Or
21:23:27 <dfeuer> for pizza.
21:23:43 <carter> dfeuer: i'm happy to be a resource
21:23:48 <dfeuer> If you live in my area I will buy you pizza. Otherwise, Chinese delivery. I don't believe in pizza delivery.
21:23:49 <carter> my code bandwidth is limited
21:23:56 <dfeuer> Oh, well that's plenty fine.
21:23:59 <dfeuer> Thanks :)
21:24:11 <der|> hello all
21:24:13 <carter> i've unlimited armchair info time
21:24:15 <Algebr> How can I control some config in the config created by cabal sandbox init?
21:24:18 <carter> its coding time thats expensive
21:24:21 <dfeuer> I was trying to write a Criterion benchmark for this (with only a vague idea of how Criterion works)
21:24:26 <carter> dfeuer: ohh
21:24:30 <carter> you shoudl look at examples
21:24:30 <Algebr> the sandbox init config says not to edit that file itself.
21:24:43 <dfeuer> and aside from all the "how does Criterion work" stuff, I also had issues with "how do you benchmark this".
21:24:56 <carter> dfeuer: pick representative samples
21:25:07 <dfeuer> Because if I give Criterion the function and the list and tell it to do its thing,
21:25:38 <dfeuer> then the list code won't fuse and there will be lots of silly spew into cache and excess GC.
21:25:46 <der|> In this code: `main = do test <- getLine; putStrLn test` I can't ++ IO String with String, how would I extract the String from the IO to be able to ++ it ? Thanks in advance for any help
21:25:51 <carter> dfeuer: dude
21:25:59 <carter> just have a representative example
21:26:01 <dfeuer> So your solution, carter, is to pick representative samples.
21:26:01 <carter> and do it 100 times
21:26:02 <dfeuer> OK.
21:26:09 <carter> and have a few different ones
21:26:23 <carter> or you could put that list in a where clause :)
21:26:29 <carter> that would be the easy way :)
21:26:33 <dfeuer> Well, there will generally be different examples that are important for different algorithms?
21:26:34 <dfeuer> .
21:26:44 <carter> dfeuer: idk
21:26:49 <carter> you'll be the expert soon
21:26:50 <carter> you can tlel me
21:26:53 <dfeuer> Well, the answer is yes.
21:27:12 <dfeuer> Because different algorithms reject different square candidates in different ordeers.
21:27:13 <dfeuer> orders.
21:27:50 <carter> cool
21:27:53 <dfeuer> So there will have to be a different weighting of different representatives depending on the algorithm.
21:28:02 <carter> or will it!
21:28:18 <carter> why do i care about isSquare
21:28:26 <carter> why does it require so much engineering time?
21:28:34 <dfeuer> Ah, you are trying to teach a lesson.
21:29:07 <dfeuer> It's a puzzle, perhaps. The arithmoi developers put a lot of code into it, and I think they did it wrong, so I want to see if I can do better.
21:29:23 <dfeuer> carter, another way to put it
21:29:30 <dfeuer> is that it's a great way to learn Criterion.
21:31:57 <der|> anybody willing to help a haskell newcommer with a rather simple question ?
21:32:06 <suOya_> go on
21:32:18 <der|> In this code: `main = do test <- getLine; putStrLn test` I can't ++ IO String with String, how would I extract the String from the IO to be able to ++ it ?
21:32:49 <suOya_> you have to do inside the main block
21:32:50 <carter> do unwrappedString <- ioString
21:33:41 <der|> isn’t that what I’m doing on `test <- getLine` ?
21:33:53 <dmj`> der|: print =<< (++newString) <$> getLine
21:34:11 <Algebr> that's a bit more advanced...
21:34:19 <dfeuer> Haskell Rule #1: you can't pull anything *out* of IO; you can only hook up IO actions to each other.
21:34:21 <der|> I can tell, I have seen >>= but not =<<
21:34:31 <suOya_> der|: it's >>= reversed
21:34:41 <der|> unbind ?
21:34:42 <dmj`> @src (=<<)
21:34:42 <lambdabot> f =<< x = x >>= f
21:34:47 <suOya_> no, arguments flipped
21:34:54 <carter> dfeuer: is the goal issquare
21:35:00 <carter> or nontrivial benchamrking?
21:35:14 <der|> ah true, I was doing :t =<<, got the type by doing :t (=<<)
21:35:26 <dmj`> der|: a <- do { str <- getLine; return (str ++ newString) }
21:35:29 <dfeuer> carter, no, the goal is not isSquare. I don't care about it any more than you do. It's non-trivial benchmarking, and getting some limited feel for how these numerical things work.
21:35:29 <suOya_> :t (=<<)
21:35:30 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:35:39 <carter> ahhh
21:35:52 <suOya_> :t (>>=)
21:35:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:36:05 <carter> dfeuer: well, i'll need LOTs of benchmarking help in a few more weeks
21:36:11 <der|> the inverse of bind, so it takes a monad value and gets the value
21:36:20 <dfeuer> (except inasmuch as Haskell deserves to have the fastest number theoretic functions of all programming languages)
21:36:24 <der|> very symbolic, I like it :)
21:36:26 <carter> lol
21:36:29 <suOya_> der|: no, it's just bind with the arguments flipped
21:36:41 <der|> suOya_: ah right, makes sense
21:36:46 <dfeuer> What're you working on, carter?
21:36:52 <carter> numerical haskell :)
21:36:56 <dfeuer> :D
21:37:00 <carter> the fight against fortran
21:37:12 * bitemyapp Star Wars intro begins scrolling up screen
21:37:20 <suOya_> der|: > getLine >>= print  ==== print =<< getLine
21:37:25 <dfeuer> We should not fight *against* FORTRAN, but with FORTRAN.
21:37:34 <dfeuer> How's GHC's FORTRAN FFI?
21:37:35 <carter> nope, fortran makes me sad
21:37:46 <carter> its just called C FFI, but everythings a pointer
21:37:50 <carter> @hackage hblas :)
21:37:51 <lambdabot> http://hackage.haskell.org/package/hblas :)
21:38:01 <carter> thats not the main pckages
21:38:10 <carter> just the ffi binding to compare against my own codes
21:38:25 <carter> or use when my stuff is too slow
21:38:42 <carter> https://github.com/wellposed/numerical is the main bit
21:38:53 <carter> still a lot of cleanup  i need to do before its human friendly
21:39:11 <bitemyapp> this reminds me that I need to get some more done with Geesthacht before mxavier gets a computer.
21:39:16 <dfeuer> I kid; I kid. I attempted to learn a little bit of FORTRAN years ago to muck around with an old FORTRAN program, but said program was completely impossible anyway--not only was its primary control structure the GOTO, but, even worse, the source code was completely filled with numerical literals, *none of which were explained*, sprinkled all through.
21:39:47 <carter> dfeuer: i'm working on sparse matrix support right now
21:39:50 <carter> which is pretty tricksy
21:40:05 <dfeuer> I ended up shoving some extra output onto it so I could process it with Perl.
21:40:25 <dfeuer> Yes, I would imagine that would be very tricksy.
21:40:57 <carter> i'm nearly done
21:41:25 <bb010g> Why are sparse matrices treated different than normal matrices?
21:41:33 <dfeuer> I must admit I have no idea how sparse matrix representations work.
21:41:35 <carter> bb010g: because they're subtle
21:41:50 <dfeuer> They must be like sparse vectors, except much more complicated.
21:41:55 <carter> yup
21:42:11 <dfeuer> Not that sparse vectors sound like a walk in the park.
21:42:14 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Layout/Sparse.lhs
21:42:22 <carter> sparse vectors are easy by contrast
21:42:25 <carter> thats WIP
21:42:37 <carter> currently busted 'cause i'm finishing writing things
21:43:00 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Layout/Sparse.lhs#L447-L528 being the relevant bit
21:43:02 <c_wraith> sparse matrices sound like something you'd want many different representations for, depending on *how* sparse they are.
21:43:06 <dfeuer> Some operations seem inherently troublesome, no? As in prone to making a sparse matrix not be sparse anymore?
21:43:08 <carter> YUP
21:43:11 <carter> c_wraith+++
21:43:17 <carter> dfeuer: yup
21:43:37 <carter> c_wraith: making it easy to add new sparse formats was a huge design constraint
21:43:51 <carter> dfeuer: matrix matrix product is the only thing thats red flaggy for sparse matrices
21:44:13 <dfeuer> Or iterated addition.
21:44:17 <carter> eh
21:44:25 <carter> thats less likely to ahpeppne
21:44:29 <dfeuer> Ah.
21:44:46 <dfeuer> So what do you *do* with them, if you can't multiply them together?
21:44:55 <carter> computer their factorization
21:45:03 <carter> and then do a fancy regression
21:45:23 <c_wraith> SVD is apparently a popular thing, but I haven't done linear algebra in so long that I can't remember why.
21:46:01 <carter> svd doesn't really make sense for sparse
21:46:13 <carter> though theres some related approximate things that people who are lying calls SVD
21:46:33 <carter> but computing matrix factorizations is where its at :)
21:47:00 <bb010g> carter: Is numerical Haskell consulting & coding your full time job?
21:47:10 <carter> i'm self employed yes
21:47:21 <carter> do a few other consulting projects
21:47:28 <carter> numerical haskell is my project
21:47:37 <carter> not really using it much yet in my client work
21:47:37 <bb010g> Awesome. :)
21:49:03 <snyp> Why is there Control.Monad module?
21:49:14 <suOya_> for some extra operators
21:49:18 <snyp> o
21:49:22 <octopuscabbage> okay how do i read a list of a custom defined type from standard input
21:49:43 <octopuscabbage> (it derives show)
21:49:49 <octopuscabbage> (i mean read)
21:49:57 <suOya_> replicateM n getLine
21:50:13 <suOya_> or wait no
21:50:15 <suOya_> nevermind
21:50:34 <octopuscabbage> is that not right?
21:50:44 <suOya_> depends how you want to read it
21:50:47 <der|> suOya_: why does this work: `main = do { str <- getLine; let newStr = str ++ "!!!"; putStrLn newStr }` and this does not: `main = do { str <- getLine; putStrLn str + "!!!" }`
21:51:15 <der|> If I use let, and then putStrLn it works fine, but it doens’t work if I place the operation directly on the putStrLn call
21:51:24 <suOya_> der|: because putStrLn str ++ "!!!" tries to do (putStrLn str) ++ "!!!"
21:51:32 <der|> ah
21:51:57 <der|> true, it takes 1 arg
21:52:01 <suOya_> der|: haskell is left-to-right associative by default
21:52:13 <suOya_> use this: putStrLn $ str ++ "!!!"
21:52:22 <der|> suOya_: getting used to it
21:52:37 <der|> it works! :)
21:52:50 <suOya_> congratz!
21:52:57 <der|> the $ is function application correct ?
21:53:15 <suOya_> yeah, it's simple: f $ g x = f (g x)
21:53:29 <suOya_> e.g. it evaluates everything on the right side first
21:54:28 <der|> yes, seen it quite a few times on the Learn you a haskell book
21:54:56 <der|> which is the most popular web framework in the haskell world ?
21:56:01 <suOya_> huh
21:56:13 <der|> I’m checking Yesod and Snap
21:56:13 <suOya_> LYAH is an introductory book to haskell
21:56:15 <suOya_> oh
21:56:24 <suOya_> yeah those are the famous ones
21:56:42 <der|> I’m getting my hands on it, liking it a lot but to be honest monads, monoids functors and all those things are making my brain feel tiny :)
21:57:01 <der|> it’s fun though
21:57:12 <dfeuer> $ is very convenient, but it has a little wrinkle that led to a rather odd special case in GHC's type checker.
21:57:23 <dfeuer> (odd, and intentionally undocumented)
21:57:28 <suOya_> what is that?
21:58:00 * der| also wants to know...
21:58:58 <dfeuer> suOya_, I don't really understand all the details, but apparently things like  runST $ blah   shouldn't actually work, because $ has to have an "impredicative" type that is generally not supported
21:59:20 <suOya_> okay
21:59:24 <suOya_> what is an impredicative type?
21:59:27 <dfeuer> So GHC has a magical special exception for ($) that no other function gets.
21:59:37 <isomorph1ous> cd src/dotfiles
21:59:39 * hackagebot flamethrower 0.0.3.1 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.3.1 (charmander)
21:59:43 <isomorph1ous> god dammit
21:59:44 <isomorph1ous> sorry
21:59:51 <dfeuer> suOya_, let me know when you understand it; maybe you can explain it to me.
21:59:59 <suOya_> alright!
22:01:00 <suOya_> I don't know much about GHC at all tbh
22:01:07 <suOya_> There is too much to haskell
22:01:15 <der|> overwhelming :)
22:01:33 <marchelzo_> in Parsec if I do parse (many1 (char 'a')) on "aab" I get "aa", but when I do (many1 (string "ab")) on "abababad" I get an error. Why is this? I would like to get just "ababab".
22:02:34 <bb010g> Why is Kleisli a newtype? I'm not sure why the operations in Control.Arrow couldn't just use normal Monad.
22:04:03 <bb010g> marchelzo_: many1 (char 'a') :: Stream s m Char => ParsecT s u m [Char]; but many1 (string "ab") :: Stream s m Char => ParsecT s u m [String]
22:04:03 <lithiumdeuteride> i once read someone complaining that Haskell made a mess of some mathematical concepts like sets, and that they should have consulted an actual mathematician
22:04:40 * hackagebot http-client 0.3.5 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.5 (MichaelSnoyman)
22:04:55 <lithiumdeuteride> is there anything to such complaints?  were there any mathematical blunders?
22:04:58 <bb010g> marchelzo_: many1, really, is Alternative f => f a -> f [a]
22:05:43 <marchelzo_> bb010g: I don't follow. many1 (string "ab") works on  "abababab"
22:05:57 <marchelzo_> even on "ababFF"
22:06:11 <marchelzo_> its only when there is a partial match at the end like "af" that it fails
22:06:48 <der|> suOya_: thanks for the help, much appreciated…
22:07:34 <bb010g> marchelzo_: Oh, sorry, misread.
22:08:14 <bb010g> Prelude Text.Parsec Text.Parsec.String> parse (many1 (string "ab")) "ghci" "abababd" in ghci gives Right ["ab","ab","ab"] for me.
22:08:32 <marchelzo_> bb010g: Yeah but instead of put ad
22:08:35 <marchelzo_> so "abababad"
22:08:48 <marchelzo_> instead of d*
22:09:09 <bb010g> Guessing because it fails in the middle of a parse instead of at the beginning
22:09:24 <marchelzo_> yeah. I really wish it didn't work like that, though :|
22:09:40 * hackagebot http-client-tls 0.2.2 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.2 (MichaelSnoyman)
22:09:42 * hackagebot http-conduit 2.1.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.3 (MichaelSnoyman)
22:12:07 <bb010g> marchelzo_: You may be able to do something along the lines of <* many anyChar, but you still need to stop the failure.
22:13:31 <orzo> suppose I have a certificate chain EE<-A<-B<-C<-D where EE is an end entity and <- means "was issued by".  I believe the RFC implies that if CRLC is a relevent CRL for revoking C, then CRLC<-D.  It seems likely but not certain that CRLB<-C and CRLA<-B and CRLEE<-A.  Does my understanding sound correct?
22:14:17 <orzo> assuming D is a trust anchor
22:14:45 <marchelzo_> bb010g: that is hard though. because it depends on the previous character / next character
22:16:07 <orzo> Can i assume that the "likely but not certain" fact is actually always true?
22:20:27 <orzo> the RFC says that the CRL must be ultimately validated by the same trust anchor tha the certificate it might revoke is.  Holding this condition for trust anchor but not for other certs seems to be the first time in all my study that a CA owner must act differently based on whether he expects his certificate to be an anchor or not.  Prior to that rule, the "trust anchor" decisions has alwyas been
22:20:33 <orzo> up to the relying party
22:21:04 <orzo> it seems wrong to break with that
22:25:06 <orzo> damnit, all this is to the wrong channel
22:25:44 <marchelzo_> orzo: haha
22:34:43 * hackagebot eros 0.5.3.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.5.3.0 (pharpend)
22:36:04 <brrrrian> is there a way to get the RTS -N value from a haskell program?
22:37:15 <c_wraith> yes
22:37:25 <brrrrian> GHC.Conc.numCapabilities
22:37:29 <brrrrian> damn
22:38:21 <c_wraith> or getNumCapabilities
22:38:42 <c_wraith> Which is more accurate in the face of setNumCapabilities, which means it can change at runtime.
22:40:26 <brrrrian> c_wraith: thx
22:47:33 <brrrrian> I want to do concurrent file access.. is the only way via mmap?
22:47:52 <brrrrian> e.g. mmap two regions of the file and process concurrently
22:51:53 <EvanR> brrrrian: you can have two fds open for the same file of course
22:56:08 <brrrrian> EvanR: open same file twice, seek to half-way pt on 2nd fd, and process both concurrently..?
22:56:45 <EvanR> sure if you want to
22:57:27 <brrrrian> EvanR: why would you ever need to do mmap then?
22:57:51 <EvanR> mmap is more flexible
22:58:07 <EvanR> as an interface
22:58:14 <EvanR> behind the scenes its all the same anyway
22:59:14 <brrrrian> I wrote some code to read file in as lazy bytestring, transform the data, and the write it back out to a different file.
22:59:32 <brrrrian> I tried to parallelize this using Control.Parallel.Strategies with little success
23:00:00 <lithiumdeuteride> the man they call brrrrian!
23:00:24 <brrrrian> e.g. tried to chunk the input into large chunks and then run parBuffer on it.. not getting the behavior I am expecting
23:00:37 <brrrrian> so I suspect that I need to just have multiple input streams and output streams
23:00:50 <brrrrian> with mmap or multiple fds
23:00:52 <tgeeky> is there a name (-morphism)? for the relationship between, say, 3 floating point values normalized to (0,1) and 3 bytes (0,255)? It's clearly not an isomorphism, as one has more potential values (the floats)? is it a homeomorphism? or something stronger?
23:01:08 <tgeeky> (this is, for example, to convert one representation of a Color to another)
23:01:46 <prophile> monomorphism maybe?
23:01:47 <EvanR> brrrrian: for one handle, the runtime system only lets one thread use it at a time
23:02:01 <prophile> it's the analogue of an injective function
23:02:03 <EvanR> i dont know about parallel haskell
23:02:44 <tgeeky> if it is a monomorphism, it would only be so in one direction? These two can't be one-to-one in both direction?
23:03:22 <brrrrian> EvanR: the runtime does not provide any locking around a handle such that multiple threads can use it..?
23:03:35 <EvanR> brrrrian: and of course if you are reading a file with one pass once, you cant speed this up with any parallel strategy
23:03:55 <EvanR> brrrrian: it does, multiple threads use it, one at a time
23:04:45 <brrrrian> EvanR: the transform work takes more time than the file IO... so I thought there could be a parallel speedup even with just one pass over the file (one input source).
23:04:46 * hackagebot interpolate 0.0.3 - String interpolation done right  http://hackage.haskell.org/package/interpolate-0.0.3 (SimonHengel)
23:05:16 <EvanR> brrrrian: once you read it from the file, you may be able to speed it up with something parallel
23:05:30 <EvanR> but the reading will not go any faster from one handle
23:05:40 <brrrrian> EvanR: e.g. read in a chunk, create a spark for that, some core processes that spark while other core continues to read in another chunk and create sparks, etc
23:05:54 <EvanR> sure
23:06:02 <EvanR> the reading is still serial though
23:06:10 <brrrrian> right
23:06:47 <EvanR> i doubt opening the file and seeking to get all the chunks in parallel would help
23:06:55 <EvanR> opening the file multiple times
23:07:06 <brrrrian> playing with chunk size and parBuffer num sparks and can't seem to get a speedup of over 1.2 for 2 cores
23:07:07 <EvanR> but mmap may make sense
23:07:29 <EvanR> 1.2 for the whole thing, or just the parallel part of the problem
23:08:00 <EvanR> try to benchmark the difference on the part after its all in memory
23:08:09 <EvanR> that can be paralleized
23:09:45 <brrrrian> well, what i meant by 1.2 is by just eyeballing the activity in threadscope.  I actually can't get a true speedup with any parallel implementation.. it's always 1.5x or way worse in total running time
23:10:02 <EvanR> its worse?
23:10:37 <brrrrian> I was thinking about pulling in entire file and then focusing on parallel part, but I really need to keep the lazy property
23:11:16 <brrrrian> I can use smaller data for time being, but my real data is huge when it's pulled in with bytestring... swapping hardcore
23:11:52 <EvanR> ah right
23:12:35 <EvanR> then yeah, each spark can be given a region of the file to read, and it opens the file, reads the region, and closes it. and heres where mmap might make more sense
23:13:15 <EvanR> then does whatever it needs with the bytestring and reports it to the master
23:13:45 <brrrrian> I've reduced the problem to something smaller.  Instead of reading in a file, I just generate garbage data via enumFromTo and write the data to a file.  Here it is if you're curious: http://lpaste.net/107519
23:15:04 <EvanR> now what, you are trying to output a large amount of random data?
23:15:18 <brrrrian> I am just faking the input, that's all
23:15:27 <brrrrian> with replicate
23:15:36 <EvanR> oh the computation is luma
23:16:31 <brrrrian> pixels is just a huge list of Word8 ... the result variable is just different ways of doing the work
23:16:32 <EvanR> so what youre trying to do is basically speed up a map with parallel computation
23:16:51 <brrrrian> EvanR: yeah, but it has to be lazy
23:16:55 <EvanR> i have heard that this probably wont work
23:17:47 <brrrrian> I believe my only option is to use parBuffer because I need lazy, but this is not performant.  So I tried to chunk the input stream before passing to parBuffer... and still not performant.
23:18:24 <EvanR> yeah basically you need to do a computation on a bunch of chunks, its independent, and so obviously parallel
23:19:12 <EvanR> one thing that would help, parallel or not, is to use unboxed vectors instead of lists for the data
23:19:27 <EvanR> it will be faster to recombine in the end
23:19:37 <brrrrian> It sucks that I can't reason about why chunking and passing to parBuffer is not performant.
23:19:37 <Welkin> what is up with cabal?
23:19:49 <Welkin> it uses the old version of cabal-install and ignores the new version
23:20:06 <Welkin> does it have to do with the new version I just installed being local and the old version being global?
23:20:06 <EvanR> in general i dont think parallelizing a map increases performance
23:20:07 <brrrrian> EvanR: is concat O(1) for vector..? Is that why you said that?
23:20:31 <EvanR> its not, but its way faster and takes less memory than lists
23:21:00 <EvanR> these are general performance tips
23:21:05 <brrrrian> EvanR: well I suspect it does if you don't care about laziness and your spark sizes of each element in the list is huge... but that's not the case here
23:21:31 <brrrrian> do you know where I can find information about how vector represents data in memory?
23:21:31 <EvanR> then you just wouldnt concat them
23:21:43 <EvanR> yeah, in the Vector library
23:21:57 <brrrrian> :)
23:26:39 <EvanR> brrrrian: it seems like your main issue is reading and doing the IO concurrently, in which case youd use threads and not parallel stuff
23:27:32 <EvanR> if you do this and pick N=2 with rts options you should see some performance boost as long as whatever recombination doesnt take too much work
23:27:52 <EvanR> and it will not load everything into memory at once
23:28:17 <EvanR> parallel seems to only be for pure computations
23:29:49 * hackagebot flamethrower 0.0.4.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.4.0 (charmander)
23:30:30 <brrrrian> I wonder if parallel would be performant as long as there are multiple IO inputs...
23:34:58 <oakwhiz> How is 3D volumetric data represented in Haskell?
23:35:33 <EvanR> brrrrian: parallel computation in haskell only applies to pure code, to handle multiple IOs concurrently you want to use threads, forkIO
23:37:35 <brrrrian> EvanR: pure code meaning not in IO () ?
23:37:41 <EvanR> right
23:38:51 <brrrrian> So I could lift the parallel code out of IO () and still try to do what I am doing...
23:38:56 <EvanR> to speed up a webservers handling of requests you would not use parallel, for example
23:39:41 <EvanR> thats what i originally suggested but you want to interleave the IO to avoid loading the entire data set into memory at once
23:40:14 <EvanR> so you need to use forkIO
23:40:42 <EvanR> pass the region to operate on to each worker thread when it is forked
23:42:55 <brrrrian> this is a dumb question, but if i read in a file with bytestring readFile which yeilds an IO Bytstring... there is no way to get that bytestring out of IO ?  I have to lift the computation that runs on the bytestring into IO ...?
23:43:17 <EvanR> no
23:43:43 <EvanR> you read the file with IO, but after that you have a normal value of type bytestring that can be passed to pure code
23:43:50 <Welkin> how do I get ghc-pkg to recognize cabal-1.20.0 and use it instead of the old cabal-1.14.0?
23:45:02 <EvanR> many of the operations on bytestrings in the bytestring library do not involve IO
23:45:11 <EvanR> as evident in the type
23:45:28 <EvanR> length :: ByteString -> Int, not IO Int
23:45:47 <brrrrian> EvanR: so if I operate in parallel in pure code, then I lose laziness?  I am wondering why you said that you originally suggested to do the work in paralle but I didn't want to do that...
23:46:20 <EvanR> you said the file is too big to load into memory all at once
23:46:43 <EvanR> but if you could, then you could try to parallelize your pure operation
23:47:13 <EvanR> but its too big, so operate on small chunks at a time with threads
23:47:22 <brrrrian> if I don't load into memory all at once, I benefit from laziness... are you saying it's not possible to do this in a pure way...?
23:47:42 <EvanR> when you say laziness, you are talking about lazy IO ?
23:48:10 <brrrrian> I think so yes.. not holding entire file in memory at once
23:49:19 <EvanR> lazy IO is tricky business
23:50:10 <Welkin> EvanR, do you know about ghc-pkg and cabal?
23:50:18 <EvanR> no not really
23:50:52 <brrrrian> so... contents <- readFile ; writeFile processInPureParallel contents
23:51:06 <brrrrian> processInPureParallel :: ByteString -> ByteString
23:51:23 <EvanR> brrrrian: but using threads to read small chunks, you are effectively doing lazy IO manually. getContents and readFile lazy are not really pure
23:51:28 <brrrrian> so the parallel code is pure... and it operates on lazy bytestring which comes from lazy IO ...
23:51:28 <EvanR> they are doing IO
23:51:58 <EvanR> i have no idea what happens when you use the parallel combinators on lazy IO bytestrings
23:52:26 <EvanR> you have tried it so it might not be satisfactory
23:53:07 <EvanR> im not surprised you have had trouble reasoning about the lazy IO behavior, its very weird ;)
23:53:49 <frerich> brrrrian
23:54:08 <frerich> darn. That name makes me think of the roman emperor in The Life Of Brian... can't get his voice out of my head.
23:54:51 * hackagebot apiary 0.12.4 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.12.4 (HirotomoMoriwaki)
23:56:45 <EvanR> brrrrian: i believe lazy bytestrings make sense when you are generating them from pure code (and possibly writing them to a handle), but when lazily reading a whole file, you run the same risks as hGetContents
23:57:34 <EvanR> your pure code can crash because it is implicitly doing IO to read some part of the file, which could fail
23:58:01 <EvanR> so i would think this makes parallel a bad use case
23:58:14 <EvanR> recommend forkIOs ;)
23:58:18 <EvanR> going to sleep
23:58:47 <brrrrian> EvanR: thanks for the help
23:58:50 <MP2E> frerich: always look on the brrrrriiiight side of life ;)
