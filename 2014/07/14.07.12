00:00:15 <mgomezch> jle`, int-e: worse, it eats memory exponentially.
00:09:53 <Shelley21>  Here some videos. I hope you like them! http://bit.ly/1qSx9eQ
00:10:01 <trap_exit> luite: still here?
00:10:06 <trap_exit> luite: in https://webproxy.vpnbook.com/browse.php?u=FaGIPzbJmDj3D%2FF2UlhCtsVpfZr4M%2B%2Biu6Moly%2BglPvTlsU%3D&b=0&f=norefer ... what does safe/unsafe mean in the contet of ghcjs ffi?
00:10:16 <trap_exit> luite: it seems to refer to async/sync
00:10:22 <trap_exit> luite: but I don't know why they're called safe/unsafe ... and why it matters
00:11:13 <luite> trap_exit: oh that has been changed
00:11:32 <trap_exit> luite: where is the up to date docs?
00:12:02 <trap_exit> luite: I'm not sure if I want to buy you a beer for writing ghcjs or throw a beer at you for ghcjs docs
00:12:46 <Pythonfant> trap_exit: you could do both
00:12:53 <luite> trap_exit: unsafe = if your imported js code throws an exception, it kills the haskell thread (other threads (forkIO) are still ok)
00:13:26 <trap_exit> luite: hmm, alright, where is the updated ffi docs?
00:13:26 <luite> trap_exit: safe means that the exception is raised in Haskell land as a JSException, you can catch it with the usual Control.Exception code
00:13:33 <trap_exit> luite: ah, understood
00:14:13 <trap_exit> luite: so in short, safe/unsafe has nothing to do with the content of the js function .. only how haskell handles exceptions ... unsafe = die, safe = throw haskell exception
00:14:21 <luite> trap_exit: interruptible means async, $c to continue the thread. when you've not called $c, the thread is interruptible (which means you can throwTo an async exception to the thread to abort the ffi call)
00:15:39 <luite> trap_exit: yeah. the reason that the names are still the same as with GHC is that it required fewer changes in the parser, and unsafe/safe/interruptible are actually fairly appropriate
00:15:40 <trap_exit> luite: noted ... where are the up to date ghcjs ffi examples ? :-)
00:15:53 <trap_exit> luite: i'm converting code over from haste, and I want to get it running in ghcjs :-)
00:16:00 <colordrops> Is this the right place for extreme beginner questions?
00:16:19 <pavonia> Sure
00:16:26 <jle`> colordrops: ask away :)
00:16:31 <trap_exit> colordrops: yes, haskell is very beginner friendly
00:16:41 <trap_exit> colordrops: I tried trolling here and now am using #haskell
00:16:55 <luite> trap_exit: we don't have much documentation yet, but the ghcjs-base package is a reasonable starting point, https://github.com/ghcjs/ghcjs-base/tree/master/GHCJS
00:17:00 <bitemyapp> does anyone here use EKG?
00:17:08 <colordrops> Great!  I'm learning about higher order functions, and am wondering if partial application and lambdas are completely interchangeable
00:17:34 <colordrops> e.g., how would I do this with a partial application: filter (\x -> x `mod` 2 == 0) [1, 2, 3, 4, 5, 6, 7, 8]
00:17:37 <luite> trap_exit: then some bindings should work: https://github.com/ghcjs/ghcjs-jquery , https://github.com/ghcjs/ghcjs-canvas
00:17:58 <bitemyapp> @pl filter (\x -> x `mod` 2 == 0) [1, 2, 3, 4, 5, 6, 7, 8]
00:17:58 <lambdabot> filter ((0 ==) . (`mod` 2)) [1, 2, 3, 4, 5, 6, 7, 8]
00:18:07 <bitemyapp> @pl filter (\x -> x `mod` 2 == 0)
00:18:07 <lambdabot> filter ((0 ==) . (`mod` 2))
00:18:11 <bitemyapp> good enough.
00:18:19 <trap_exit> thanks!
00:18:25 <trap_exit> luite: I wil study these
00:19:02 <colordrops> ah, I'm going through the "learnyouahaskell.com" tutorial and haven't yet encountered that dot operator.  that explains it
00:19:03 <colordrops> thanks!
00:19:22 <luite> trap_exit: the template haskell server code also has some ffi, but it's really low-level since ghcjs-prim is high up in the dependency graph, it doesn't have the ghcjs-base marshalling available https://github.com/ghcjs/ghcjs-prim/blob/master/GHCJS/Prim/TH/Eval.hs
00:19:44 <trap_exit> luite: oh, I'm just looking at JS ffi
00:19:57 <luite> trap_exit: that is JS FFI :)
00:20:28 <trap_exit> ah, I see
00:20:28 <luite> since it compiles template haskell to javascript
00:20:29 <trap_exit> and you need template haskel
00:20:32 <trap_exit> for all the iline madness
00:21:27 <trap_exit> okay okay
00:21:29 <luite> trap_exit: anyway, the ffi hasn't quite been finalized yet, in particular exporting haskell functions to JS is not quite finished
00:21:31 <trap_exit> magic, will study more
00:21:35 <trap_exit> need to run
00:21:46 <luite> trap_exit: so if you find something missing, just open a ticket
00:21:51 <trap_exit> thanks again for your help, luite
00:46:33 * hackagebot skell 0.0.0.0 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.0.0.0 (pharpend)
00:48:17 <zeeshan_> hi
00:50:26 <zeeshan_> http://lpaste.net/107378
00:50:46 <zeeshan_> getting error while trying to use if else if
00:51:19 <zeeshan_> can anybody help me
00:51:34 * hackagebot skell 0.0.1.0 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.0.1.0 (pharpend)
00:51:45 <pavonia> zeeshan_: Your second if is missing an else branch
00:51:56 <Profpatsch> If infixr binds x•(y•z) and infixl (x•y)•z, then what does infix do?!
00:52:08 <Profpatsch> Undefined? Random?
00:52:23 <pavonia> infix operators cannot be used in sequence
00:52:47 <zeeshan_> thanks
00:52:54 <pavonia> > 1 == 2 == True
00:52:56 <lambdabot>  Precedence parsing error
00:52:56 <lambdabot>      cannot mix ‘GHC.Classes.==’ [infix 4] and ‘GHC.Classes.==’ [infix 4] in ...
00:53:02 <Profpatsch> Ah, I see.
00:53:13 <Profpatsch> Makes sense. :)
00:53:25 <zeeshan_> panovia that was really fast response thank a ton :)
00:53:58 <pavonia> Yes, this is the Quickes Channel on Freenode™
00:54:04 <zeeshan_> :)
00:54:05 <pavonia> *Quickest
00:54:06 <zeeshan_> lol
00:54:17 <zeeshan_> that will make learning haskell faster
00:54:26 <zeeshan_> but its sure a very different lang
00:56:34 * hackagebot skell 0.0.1.1 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.0.1.1 (pharpend)
00:57:51 <Pythonfant> that was a quick update
01:01:57 <kurt21> I’m reading on Aeson. The standard (?) json library for Haskell. The code snippets from the main page aren’t working
01:02:04 <kurt21> From: http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html
01:02:10 <kurt21> decode "{\"foo\": 123}" :: Maybe Value
01:02:25 <kurt21>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
01:02:26 <kurt21>                 with actual type `[Char]'
01:03:02 <MP2E> that's an old aeson you're looking at. Newest is 0.7.0.6
01:03:06 <kurt21> After skimming more docs, I tried Data.ByteString.Char8.pack to convert a String to a ByteString… That still didn’t work
01:03:12 <MP2E> also you might need -XOverloadedStrings
01:03:57 <mbrock> a simple way to do deferred computations that compose applicatively in a particular way suitable for things like prefetching: http://www.reddit.com/r/haskell/comments/2ahwye/deferred_computations_using_compose_io_io_a/
01:05:11 <kurt21> good point. the code snippet is the same at the latest version of the package: http://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson.html
01:05:44 <mbrock> for me it is a nice example of how Haskell's IO values make IO programming very nice :)
01:06:37 * hackagebot skell 0.0.2.0 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.0.2.0 (pharpend)
01:07:01 <dario> someone may have had a little much on caffeine there.. ;)
01:07:29 <kurt21> ok, it works with -XOverloadedStrings… That seems hacky to require an option like that
01:17:03 <trap_exit> luite: how do I include an external *.js file
01:18:36 <AshyIsMe> ooh cabal install has the -j option for parallel builds
01:19:49 <jle`> i found a bug that slipped through the typechecker :/
01:19:52 * jle` shudders
01:21:38 * hackagebot sbv 3.1 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.1 (LeventErkok)
01:26:39 * hackagebot skell 0.0.2.1 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.0.2.1 (pharpend)
01:27:07 <jle`> is there a take from end?
01:27:13 <jle`> like reverse . take n . reverse ?
01:27:27 <jle`> @hoogle Int -> [a] -> [a]
01:27:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
01:27:29 <lambdabot> Data.List drop :: Int -> [a] -> [a]
01:27:29 <lambdabot> Prelude take :: Int -> [a] -> [a]
01:30:54 <pavonia> > (\n -> (!! n) . reverse . tails) 3 "abcdef"
01:30:55 <lambdabot>  "def"
01:30:55 <pjdelport> takeEnd n xs = drop (length xs - n) xs
01:31:12 <pjdelport> jle`: That's probably the most efficient possible implementation.
01:32:48 <jle`> ty ppl
01:51:41 * hackagebot skell 0.1.0.0 - An overly complex Haskell web framework.  http://hackage.haskell.org/package/skell-0.1.0.0 (pharpend)
02:06:54 <int3__> are there some examples of how to use the newtype package? I'm kind of confused about how to use `ala`.
02:10:03 <bennofs> :t ala
02:10:04 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
02:11:14 <bennofs> :t Control.Newtype.ala
02:11:15 <lambdabot> Not in scope: ‘Control.Newtype.ala’
02:14:28 <bennofs> > ala Sum foldMap [1,2,3,4] -- int3__
02:14:30 <lambdabot>  10
02:15:17 <bennofs> `ala n f` is u . f n, where u is the "inverse" (unpack) function to n
02:15:45 <bennofs> so ala Sum foldMap = getSum . foldMap Sum
02:15:55 <int3__> bennofs: ahh okay. thanks!
02:16:18 <bennofs> > ala
02:16:20 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
02:16:20 <lambdabot>                     (Control.Lens.Wrapped.Unwrapped t0))
02:16:20 <lambdabot>    arising from a use of ‘M62826992126798317076538.show_M62826992126798317076...
02:16:20 <lambdabot>  The type variable ‘t0’ is ambiguous
02:16:20 <lambdabot>  Note: there are several potential instances:
02:17:27 <bennofs> > ala' Sum foldMap (+1) [1,2,3,4]
02:17:28 <cstanfill> oh my
02:17:29 <lambdabot>  14
02:18:03 <bennofs> int3__: ala' is like ala, but alows you to compose a function with n before passing it to f. so ala' n f g = u . f (n . g)
02:19:01 <int3__> bennofs: got it
02:35:09 <ClaudiusMaximus> @free length
02:35:10 <lambdabot> length = length . $map f
02:47:43 <johnw> what does @free do?
02:47:57 <prophile> causes socialism
02:47:59 <johnw> gives you a free theorem for the function?
02:48:04 <prophile> yeah
02:48:41 <pjdelport> @free fix
02:48:42 <lambdabot> f . g = h . f => f (fix g) = fix h
02:50:16 <johnw> nice
02:50:23 <pjdelport> @free mapAccumL
02:50:24 <lambdabot> (forall x. $map_Pair f h . k x = p (f x) . g) => $map_Pair f ($map h) . mapAccumL k y = mapAccumL p (f y) . $map g
02:50:29 <pjdelport> good heavens
02:53:57 <pavonia> @help free
02:53:58 <lambdabot> free <ident>. Generate theorems for free
02:56:10 <pavonia> What are free theorems (in one sentence)?
02:56:44 <johnw> they are laws which must hold because the function can't do anything else
02:57:05 <johnw> they also assume that "undefined" is never used
02:57:11 <johnw> (in a Haskell context)
02:57:22 <quchen> "Derive properties of a function by looking at its type alone"
02:57:29 <johnw> further in a Haskell context, they may also assume non-strictness in some of the function's argument
02:57:34 <johnw> (or assume strictness)
02:57:58 <pavonia> Ah, makes sense
02:58:09 <johnw> "the laws implied by a function type"
02:58:19 <johnw> yeah, what quchen said
02:58:26 <pavonia> @free map
02:58:27 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
02:58:30 <quchen> @free reverse
02:58:31 <lambdabot> $map f . reverse = reverse . $map f
02:58:39 <johnw> @free (.)
02:58:39 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
02:58:45 <mgomezch> @free id
02:58:46 <quchen> "[a] -> [a] typed functions commute with mapping"
02:58:46 <lambdabot> f . id = id . f
02:58:55 <quchen> Commutate?
02:59:00 <quchen> Something like that.
02:59:03 <johnw> the functor laws are free theorems on fmap
02:59:21 <quchen> johnw: Both of them?
02:59:45 <quchen> The second one is, in absence of seq. https://github.com/quchen/articles/blob/master/second_functor_law.md
02:59:52 <quchen> But I've never heard that about the first one
02:59:53 <pavonia> Does @free generate a random theorem or a most general one or something else?
03:00:06 <johnw> I was thinking in terms of a total universe
03:00:29 <quchen> pavonia: I think (nontrivial) free theorems are unique
03:00:35 <Maxdamantus> instance Functor [] where fmap f = reverse . map f
03:00:43 <quchen> Maxdamantus: type error
03:00:49 <quchen> Oh wait no
03:00:57 <quchen> Jumped the gun a bit there ;-)
03:01:39 <quchen> pavonia: (Trivial free theorems are `a = a` etc, which is what you get for non-polymorphic values)
03:01:56 <johnw> quchen: you are right: http://lists.seas.upenn.edu/pipermail/types-list/2004/000110.html
03:02:47 <jle`> Maxdamantus: that's an unlawful instance, right?
03:03:15 <Maxdamantus> jle`: I'd hope so.
03:03:26 <Maxdamantus> jle`: but it will type.
03:03:37 <jle`> Maxdamantus: it is; just wondering what you were putting it up for :)
03:03:38 <quchen> But fmap id ≠ id.
03:03:39 <johnw> quchen: more good stuff: http://duplode.github.io/posts/what-does-fmap-preserve.html
03:03:41 <jle`> it does type unfortunately
03:03:41 <mgomezch> it doesn’t pass fmap id = id
03:03:44 <jle`> fmap id =/= id
03:04:03 <jle`> i think...if a Functor instance exists for a given type, it is unique
03:04:03 <quchen> johnw: I remember bookmarking that one, at least
03:04:10 <Maxdamantus> So 'fmap id' = 'id' isn't free.
03:04:15 <jle`> (a lawful instance)
03:04:28 <quchen> Maxdamantus: But can we use free theorems to add something there to correct the instance?  fmap f = reverse . map f . reverse! :-)
03:05:46 <Maxdamantus> quchen: I dunno. I'm trying to figure out what the free theorems are too.
03:05:59 <jle`> is the free theorem derived only from the type?
03:06:05 <jle`> in @free
03:06:24 <jle`> oh quchen just said so earlier
03:06:40 <jle`> is free theorem in this context associated with parametricity?
03:06:51 * hackagebot aws 0.9.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.9.1 (AristidBreitkreuz)
03:07:02 <johnw> jle`: yes
03:07:49 <quchen> Free theorems sum up all the rest what you can still do with something of a certain type.
03:08:00 <quchen> Parametricity disallows all the other things.
03:09:48 <Maxdamantus> So "free theorem" is just .. hmm.
03:10:36 <Maxdamantus> I'm not sure what's special the term in that email.
03:11:20 <Maxdamantus> It assumes particular axioms, rather than defining them, as the other laws might do.
03:11:49 <Maxdamantus> So why not just call the first law an axiom and the second a theorem?
03:12:11 <Maxdamantus> since you can prove it's true using Haskell's type system and the first law.
03:16:47 <quchen> Maxdamantus: And if there's no `seq`.
03:17:15 <quchen> fmap f x = f `seq` x `seq` (Identity . f . runIdentity) x -- satisfies first, but not second, Functor law
03:20:56 <Maxdamantus> O_o
03:21:07 * Maxdamantus fails to see why.
03:21:29 <augur> quchen: i too fail to see why
03:22:36 <Maxdamantus> did you actually mean 'seq x' there or 'seq (runIdentity x)'?
03:22:47 <Maxdamantus> (either way, I wouldn't see why)
03:23:56 <quchen> There is a proof, but I don't have it.
03:24:17 <quchen> (It's a couple of lines of manual evaluation.)
03:24:38 <jle`> quchen: which one are you calling the first?  fmap (f . g) = fmap f . fmap g ?
03:24:40 <Maxdamantus> It can be quchen's last thereom.
03:24:52 <quchen> jle`: fmap id
03:25:16 <Maxdamantus> in a few hundred years, someone will write a 200-page paper proving why.
03:26:53 * hackagebot HaMinitel 0.1.0.0 - An Haskell library to drive the french Minitel through a serial port  http://hackage.haskell.org/package/HaMinitel-0.1.0.0 (zigazou)
03:27:09 <jle`> if g is bottom and f ignores its parameter
03:27:33 <augur> jle`: oh, non-termination problems :p
03:27:41 <jle`> fmap (f . g) x is whatever f constantly puts out
03:27:45 <Maxdamantus> Then it wouldn't pass the first law.
03:27:46 <jle`> hm
03:27:48 <jle`> wait
03:27:56 <Maxdamantus> would it?
03:28:06 <quchen> jle`: Yeah it involves const and undefined, I think.
03:28:11 <quchen> I can't find my source anymore :-(
03:31:34 <jle`> (fmap f . fmap g) ix@(Identity x) = fmap f (fmap g ix) = f `seq` fmap g ix `seq` Identity (f x) = f `seq` (g `seq` ix `seq` Identity (g x)) `seq` Identity foutput
03:31:37 <jle`> hm
03:31:39 <jle`> no that still bottoms
03:32:26 <jle`> because g is still evaluated. hm.
03:32:31 * jle` shrugs
03:33:59 <quchen> I found a marvellous proof but this line is too narrow to contain it
03:34:02 <quchen> Gotta go bye
03:38:56 <jle`> oh he actually left
03:39:47 <rio> now it will take 200 years for anybody to recover a proof
03:41:50 <jle`> i half don't believe it's true
03:41:54 * hackagebot ekg 0.4.0.1 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.1 (JohanTibell)
03:55:04 <Maxdamantus> I think it should be easy to prove false (when taking into account non-termination)
03:55:33 <Maxdamantus> `fmap id undefined` doesn't terminate, but `id undefined` does.
03:55:49 <Maxdamantus> Actually, no.
03:56:05 <Maxdamantus> Those will both terminate/not terminate under the same conditions.
03:56:50 <Cale> :t fix
03:56:51 <lambdabot> (a -> a) -> a
03:56:54 <Cale> :t fix id
03:56:55 <lambdabot> a
03:57:28 <Maxdamantus> The `fmap id` function itself doesn't terminate when given `undefined`.
03:57:55 <Maxdamantus> But the `id` function itself does terminate when given `undefined`.
03:58:29 <merijn> Maxdamantus: "Fast and loose reasoning is morally correct!"
03:58:30 <Maxdamantus> Dunno if that counts as a difference.
03:58:41 <jle`> Maxdamantus: id bottom = bottom
03:58:59 <Maxdamantus> jle`: yes, but `id` can succesfully be applied to `bottom`
03:59:06 <Maxdamantus> jle`: evaluating the output will still not terminate.
03:59:13 <Maxdamantus> It's not actually noticable :\
03:59:39 <merijn> Maxdamantus: Here is the paper the argues that while that difference may count as a difference, it doesn't matter: http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html :p
03:59:52 <Maxdamantus> Indeed, not noticable.
04:00:10 <Maxdamantus> Oh, that's what you were referring to.
04:02:24 <jle`> Maxdamantus: seq only makes sense in terms of evaluation anyways, so i'm not sure what difference you are trying to suggest
04:02:49 <jle`> seq doesn't care when a function is "applied"
04:02:52 <Maxdamantus> jle`: `seq` is sometimes described as reducing the term to some sort of normal form.
04:03:17 <Maxdamantus> jle`: try imagining something like `seq` that doesn't reduce it to normalisation, but just does one step.
04:03:27 <Maxdamantus> where a single step might be application.
04:04:09 <Maxdamantus> jle`: you could do: id undefined `sseq` 4
04:05:06 <Maxdamantus> but not: fst undefined `sseq` 4
04:05:31 <Maxdamantus> in the first one, `id undefined` would turn into `undefined`
04:05:48 <Maxdamantus> in the second, `fst undefined` would fail to apply because the pattern match fails.
04:05:51 <Maxdamantus> @src fst
04:05:51 <lambdabot> fst (x,_) =  x
04:06:12 <jle`> why would the pattern match fail?
04:06:22 <jle`> undefined :: (a, a) in that case
04:06:32 <MiracleBlue> Hey folks, I'm a newb, professional JS dev who is fascinated with Haskell.  Quick question, I'm looking at downloading the development packages for OS X, is the 64 bit Haskell Platform for mac pretty much all I need to get started?
04:06:42 <Maxdamantus> Because patterns aren't handled lazily normally.
04:07:05 <Maxdamantus> > let f (a, b) c = c in f undefined 4
04:07:07 <lambdabot>  *Exception: Prelude.undefined
04:07:12 <Maxdamantus> > let f ~(a, b) c = c in f undefined 4
04:07:14 <lambdabot>  4
04:07:14 <systemfault> MiracleBlue: Yes :)
04:07:16 <jle`> hackagebot: more or less :)  there is a new HP coming out soon though, i think, just fyi
04:07:24 <MiracleBlue> systemfault: thank you :) let's see how I go
04:07:31 <MiracleBlue> I've not been this excited to learn a language in a very long time.
04:07:33 <jle`> but that shouldn't make a difference
04:07:44 <jle`> MiracleBlue: haha i know how you feel :)
04:07:58 <MiracleBlue> jle`: :D what language did you come from?  Or languages?
04:08:22 <systemfault> MiracleBlue: It’s hard, but don’t give up :) So many cool things in that language. (I’m still a beginner)
04:08:30 <MiracleBlue> I'm hoping to start by trying to replace some of my node.js programs with haskell, if I can get that far.
04:08:31 <jle`> MiracleBlue: before haskell i was ruby/c++
04:09:06 <jle`> MiracleBlue: what kind of programs?
04:09:12 <donri> @where web
04:09:12 <lambdabot> #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
04:09:25 <donri> those are the big web frameworks
04:09:49 <jle`> if you're doing web, i like sinatra :) it is very reminiscent of express in node.js/sinatra in ruby
04:09:53 <MiracleBlue> jle`: Just simple data processing, serving up files, responding with JSON, listening to some OS parameters like CPU usage etc and then responding to a request with the formatted data
04:09:55 <jle`> er
04:09:58 <systemfault> donri: Which one do you prefer?
04:09:58 <jle`> scotty, i mean
04:10:03 <donri> systemfault: happstack
04:10:15 <MiracleBlue> jle`: I've heard of scotty!  Definitely gonna look into that
04:10:38 <donri> happstack-lite is an interesting alternative to scotty
04:10:42 <jle`> Maxdamantus: so you're saying that there is a real difference, but they both end up as bottom in the end?
04:10:52 <MiracleBlue> Happstack, I'll have to look into that one too
04:11:59 <jle`> MiracleBlue: a fair warning though, prepare to feel like day 1 of learning programming :)  you might get frustrated if you can't do the things you can do in other languages after a week or a month of haskell...but remember the time when you had only been programming for a week or a month :)  and compare it to that instead
04:12:24 <jle`> some people go, "haskell is hard...i've been learning it for a week and i can't do (thing in x language that took me five years of learning programming to be able to do)"
04:12:30 <MiracleBlue> jle`: Sure, I will try to remember that.  I imagine it's vastly different from anything I've ever done before :)
04:12:46 <Maxdamantus> jle`: I'm saying there would be a real difference if there were a sense of evaluation to something other than whatever normal form `seq` evaluates to.
04:12:58 <jle`> Maxdamantus: ah
04:13:40 <donri> learning python for a rubyist is like learning spanish for an italian. haskell is chinese.
04:14:21 <Maxdamantus> I have a feeling Idris might encapsulate that sense.
04:14:22 <systemfault> Yeah… been studying haskell for a bit less than a week now. I still can’t do anything interesting with it.
04:14:35 <jle`> your italian intuition works to your advantage when learning spanish...but hurts you when learning chinese :)
04:14:39 <Maxdamantus> `id a` should evaluate to `a` in the unifier.
04:14:57 <MiracleBlue> I imagine learning Haskell for a JS guy will be like... going from grunts and stuff to cantonese or something
04:15:03 <donri> idris is ilaksh; agda is ithkuil :P
04:15:17 <donri> (those are constructed languages, some of the hardest to learn)
04:15:46 <Maxdamantus> haskil?
04:15:48 <jle`> MiracleBlue: nah.  js/python/ruby/etc. are all pretty much identical languages when you zoom back to a sufficient level
04:16:52 <Maxdamantus> Oh, they're actual conlangs.
04:17:09 <augur> donri: hahaha
04:20:01 <donri> ithkuil has 65 consonants and 17 vowels and 81 cases, among other lovely things
04:20:13 <jle`> Maxdamantus: got to run, but best of luck; #haskell is always here to help :)
04:20:16 <augur> donri: about as many vowels as english, as it happens
04:21:18 <augur> donri: check out ubykh
04:21:38 <augur> donri: like a dozen versions of the uvual plosive
04:22:40 <donri> cute
04:23:30 <augur> uvular**
04:24:35 <donri> ovary explosives
04:31:13 <mietek_> "Result signatures are no longer supported in pattern matches"
04:31:21 <mietek_> ScopedTypeSignatures don't help here
04:31:27 <mietek_> Why?
04:35:57 <donri> mietek_: ?
04:44:14 <jacobw> Hi, what do people use for writing that isn't Vim or Emacs? I've switched from Vim to Eclipse for Java, is there a similar obvious path for Haskell?
04:44:33 <syllogismos> fpcomplete
04:44:35 <augur> jacobw: i use textmate
04:44:36 <syllogismos> but its an online ide
04:45:06 <syllogismos> also I just saw some video saying  eclipse can be used as a Haskell ide
04:46:13 <jacobw> augur, unfortunately I'm a not a Mac OS user so I can't use Textmate :(
04:46:17 <syllogismos> I set up my vimrc such that it has almost all features of fpcomplete.. but then my computer crashed. and now I can't even install vundle on it
04:46:30 <jacobw> syllogismos, I've never heard of fpcomplete before, thanks.
04:46:47 <jacobw> vundle? Is it similar to pathogen.vim?
04:47:16 <augur> jacobw: buy a mac :)
04:47:16 <systemfault> I started using emacs for Haskell
04:47:47 <systemfault> I found it to be the best editor for Haskell
04:48:50 <jacobw> I'm one of the rare Linux users who prefers Windows to OS X
04:48:58 <jacobw> systemfault, thanks.
04:49:21 <jacobw> syllogismos, is this what you saw? https://eclipsefp.github.io/
04:49:35 <tazjin> What's the status of Leksah? I haven't looked at it in a while
04:50:35 <jacobw> http://leksah.org/news.html
04:50:53 <jacobw> The last release was in March 2012.
04:57:04 <silver> jacobw, http://www.sublimetext.com/
05:09:19 --- mode: cameron.freenode.net set +o ChanServ
05:28:50 <mietek_> donri: !
05:29:11 <mietek> donri:  action `catch` \_ :: IOException -> return ()
05:29:25 <mietek> donri: this is apparently illegal Haskell, and yet it seems to make perfect sense to me.
05:29:39 <MiracleBlue> Could someone point me to a quick "hello world" type tutorial?  I'm happy to google it but I thought I might ask the people who would know the best place to start :)
05:30:34 <syllogismos> learnyouahaskell
05:30:58 <syllogismos> its not really quick tutorial, but its a good starting point
05:31:07 <mietek> donri:  action `catch` \e -> { _ <- return (e :: IOException); return () }
05:31:07 <MiracleBlue> syllogismos: Thank you kindly, I've seen that floating about and have read a tiny bit into it
05:31:16 <MiracleBlue> But I guess I have yet to reach the meat
05:31:30 <mietek> donri: this is a workaround, but it'd be silly to require this sort of acrobatics
05:31:55 <SrPx> Is there a way to represent types anonymously? The same way `foo a b = a + b` is just a sugar for `foo = \a → \b → a + b
05:32:20 <lpsmith> hmm, when dealing with FFI, what's an appropriate type to represent an ssize_t  (signed size_t?)
05:32:31 <lpsmith> Does Int work?
05:32:37 <lpsmith> Or CInt?
05:34:12 <mietek> @hoogle a -> b -> b
05:34:15 <lambdabot> Prelude seq :: a -> b -> b
05:34:15 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
05:34:15 <lambdabot> GHC.Conc par :: a -> b -> b
05:36:20 <mietek> Ohh.
05:36:50 <mietek> Missing parentheses.
05:37:05 <mietek> donri:  action `catch` \(_ :: IOException) -> return ()
05:37:17 <mietek> donri: my mistake, sorry.  And thanks for being my duck.
05:37:44 <int-e> jle`: no, :t does not have any timeout currently, it invokes ghci directly rather than going via mueval (which is responsible for most of the @run timeout handling)
05:38:07 <int-e> jle`: you're right that this is less than ideal, thanks for the hint
05:39:24 <SrPx> If something is on "Data.**", does it mean it is an official library?
05:39:42 <syllogismos> I don't think so SrPx
05:40:06 <syllogismos> im not sure though
05:42:09 <SrPx> hmm okay
05:42:12 <SrPx> gtg, thanks!
05:45:50 <severb> Can anyone help me a bit? I've tried to improve a book example but I've got stuck http://lpaste.net/107386
05:49:13 <mbrock> severb: I think your last instance should be YesNo (Maybe a) without the YesNo a constraint, right?
05:50:03 <severb> mbrock: Hmm, but then I think "yesno (Just a) = yesno a" won't work
05:50:27 <mbrock> yeah, the instances overlap, right?
05:50:32 <severb> yes
05:50:58 <mbrock> you can do that with a compiler option, but it's generally best to avoid it
05:51:17 <severb> Is there a way to specify any type but one? Like a negation?
05:51:32 <severb> So they won't overlap anymore?
05:52:21 <mbrock> hmm, I don't think so
05:52:26 <severb> mbrock: Oh, I see what you're saying, I have a type in the last instance
05:53:27 <severb> So, is there a way to do this? Should I manually check for types inside the function body and pick an implementation?
05:53:31 <syllogismos> theres no need of Maybe constraint on the last instance?
05:53:46 <syllogismos> instance YesNo a where
05:54:25 <severb> I think that won't compile as it is
05:54:31 <severb> if I'm not mistaken
05:55:08 <mbrock> I think the only instances possible for YesNo a are const False and const True :)
05:56:47 <severb> I've updated the example to remove the typo
05:57:26 <mbrock> there are times when it's useful to have overlapping instances, but for this class, I'd say it makes sense to only have one or the other...
05:57:58 <severb> I see
05:58:37 <severb> when you have overlapping instances does it know which one to pick based on which one is most specific?
05:59:17 <mbrock> yeah, there's a set of rules based on some kind of specificity, I never learned exactly what it means but it's probably somewhat intuitive :P :)
05:59:36 <severb> hehe, anyway, thanks a lot
06:00:54 <mbrock> you could consider having two classes, like YesNo and YesNoDeep or something
06:01:08 <syllogismos> -- I want to make it a bit smarter like so
06:01:18 <syllogismos> does this make sense at all?
06:03:08 <mbrock> you could have instance (Foldable f, YesNoDeep a) => YesNoDeep (f a)
06:03:36 <mbrock> if you decide whether it should fold with AND or OR :)
06:03:51 <severb> oh, I see
06:04:08 <severb> syllogismos: I mean I wanted to fiddle with it to get a better understanding of how things work
06:05:16 <syllogismos> no Im asking if im making sense, like is that valid?
06:05:22 <mbrock> in Haskell, it's often emphasized that type classes should have well-defined semantics
06:06:04 <mbrock> things like YesOrNo, IsEmpty, Defaultable, etc, tend to be vague, like you sometimes have to guess what their instances will do
06:06:24 <mbrock> sometimes that's okay, for pragmatic purposes :)
06:08:39 <mbrock> (that's of course why YesNo is just a fun example and not a type class anyone actually uses!)
06:08:55 <severb> haha, I guess
06:09:26 <donri> :t (== mempty)
06:09:27 <lambdabot> (Monoid a, Eq a) => a -> Bool
06:09:34 <donri> sensible YesNo
06:10:48 <ph88> [x*2 | x <- [2..10]]   why is the input to the right of the pipe symbol ?
06:11:01 <donri> because math
06:11:39 <donri> https://en.wikipedia.org/wiki/Set-builder_notation
06:12:06 <ph88> i was thinking about linux pipes
06:12:41 <donri> those are more like >>=
06:13:28 <ph88> so ok as for my challange as haskell newbie i will not think of a little bit of code to find all the prime numbers between 0 and 100
06:14:52 <jacobw> Will not?
06:15:42 <ph88> will *
06:15:43 <ph88> lol
06:16:10 <ski> ph88 : if you want to, you could ponder computing a list of all prime numbers
06:18:07 <jacobw> ph88, have you done that exercise in other languages?
06:18:14 <MiracleBlue> It seems that almost every talk I find on Haskell has broken audio, broken video, or no slides, or all of the above :'(
06:22:03 <ph88> jacobw: one can use two loops for a simple solution
06:22:32 <trap_exit> luite: ping ping ping
06:23:02 <trap_exit> luite_: ping ping ping
06:23:17 <ph88> this doesnt work [x | x <- [1..100], x `mod` [1..100] == 0]
06:24:44 <ph88> no reason it should, just attempty #1
06:25:03 <ski> maybe you meant to use `<-' a second time ?
06:25:43 <kvanb> ph88: `mod` doesn't take a list
06:25:48 <ph88> noted
06:26:10 <ph88> what's <-  ?
06:26:33 <ski> you just used it in your list comprehension (attempt) above
06:26:36 <kvanb> > [x | n <- [1..100], q <- [1..100], n `mod` q == 0]
06:26:38 <lambdabot>  [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x...
06:26:43 <kvanb> woops
06:26:52 <kvanb> > [x | x <- [1..100], q <- [1..100], x `mod` q == 0]
06:26:54 <lambdabot>  can't find file: L.hs
06:27:05 <ph88> hey hey no spoilers :P
06:27:06 <ski> @botsmack
06:27:06 <lambdabot> :)
06:27:14 <ski> now try again
06:27:15 <kvanb> > [x | x <- [1..100], q <- [1..100], x `mod` q == 0]
06:27:17 <lambdabot>  [1,2,2,3,3,4,4,4,5,5,6,6,6,6,7,7,8,8,8,8,9,9,9,10,10,10,10,11,11,12,12,12,12...
06:27:21 <ski> in a list comprehension, `<pattern> <- <expression>' is known as a "generator"
06:27:45 <ski> > [(x,q) | x <- [1..100], q <- [1..100], x `mod` q == 0]
06:27:46 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,3),(4,1),(4,2),(4,4),(5,1),(5,5),(6,1),(6,2),(6,...
06:27:53 <ph88> ah generator ! thats perfect
06:28:03 <kvanb> beware ghc doesn't optimise generators well
06:28:32 <kvanb> write things you want to be fast as scans
06:28:42 <ski> ph88 : and if you just put an `<expression>' (which must then have type `Bool') in there, like  n `mod` q == 0  , then that's a "guard"
06:29:14 <ph88> and both the generator and the guard are a predicate ?
06:29:36 <kvanb> > [x | x <- [1..10]]
06:29:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:29:38 <ski> i'm not sure what you mean by "predicate" here
06:29:58 <kvanb> > [(x,y) | x <- [1..10], y <- [1..2]]
06:30:00 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7,...
06:30:24 <ski> > [28 | 2 < 3]
06:30:26 <lambdabot>  [28]
06:30:26 <kvanb> > [x | x <- [1..10], x < 5]
06:30:28 <lambdabot>  [1,2,3,4]
06:30:28 <ski> > [28 | 2 > 3]
06:30:30 <lambdabot>  []
06:30:45 <hellen_haskeller> is a scan slower than a fold because it does a little more to show its results?
06:30:48 <ph88> ski: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
06:31:04 <kvanb> @src scanr1
06:31:04 <lambdabot> scanr1 f []     = []
06:31:04 <lambdabot> scanr1 f [x]    = [x]
06:31:04 <lambdabot> scanr1 f (x:xs) = f x q : qs where qs@(q:_) = scanr1 f xs
06:31:19 <kvanb> It should not be slower than a fold
06:31:35 <hellen_haskeller> but it does more,no?
06:31:41 <ski> ph88 : ok, it seems they use "predicate" there as a synonym of "guard"
06:31:51 <kvanb> yeah, but a fold couldn't do it in one pass either
06:32:02 <ski> perhaps kvanb is thinking of fusion optimization of some kind
06:32:07 <kvanb> write fast fibonacci as a fold
06:32:08 <ph88> ok ski i never heard of guard but i know predicate
06:32:54 <hellen_haskeller> not heard of a guard?
06:33:12 <ph88> what's the not equal sign, opposite of == ?  i tried != and <>
06:33:33 <ski> > 2 /= 3
06:33:34 <lambdabot>  True
06:33:50 <ski> > [x | x <- [0 .. 9],x /= 3,x /= 8]
06:33:52 <lambdabot>  [0,1,2,4,5,6,7,9]
06:33:52 <kvanb> > scanl (*) 1 [2..]
06:33:53 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
06:33:59 <kvanb> > foldr (*) 1 [2..]
06:34:04 <lambdabot>  mueval-core: Time limit exceeded
06:34:05 <lambdabot>  mueval: ExitFailure 1
06:34:06 <trap_exit> luite_: I have a stupid stupid question -- how do I load an external *.js file ?
06:34:22 <ski> ph88 : <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11> describes list comprehensions
06:34:24 <kvanb> > foldr (*) 1 [2..]
06:34:29 <lambdabot>  mueval-core: Time limit exceeded
06:34:29 <lambdabot>  mueval: ExitFailure 1
06:34:48 <ski> kvanb : it's not terminating
06:35:03 <kvanb> shouldn't it be lazy
06:35:08 <kvanb> > foldl (*) [2..]
06:35:10 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
06:35:10 <lambdabot>    arising from a use of ‘M67425606680468918859914.show_M67425606680468918859...
06:35:10 <lambdabot>  The type variable ‘t0’ is ambiguous
06:35:10 <lambdabot>  Note: there are several potential instances:
06:35:10 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
06:35:13 <ph88> how do i deduplicate list ?
06:35:19 <kvanb> > foldl (*) 1 [2..]
06:35:24 <lambdabot>  mueval-core: Time limit exceeded
06:35:33 <kvanb> foldl definately won't terminate, but foldr should be streaming
06:35:47 <hellen_haskeller> some of this thread should go over to #haskell_beg
06:35:48 <ski> > nub "mississippi"
06:35:49 <lambdabot>  "misp"
06:36:03 <kvanb> > take 10 $ foldr (*) 1 [2..]
06:36:04 <hellen_haskeller> oops..ah, #haskell_beginner
06:36:04 <lambdabot>  No instance for (GHC.Show.Show a0)
06:36:04 <lambdabot>    arising from a use of ‘M5012419785641190299987.show_M5012419785641190299987’
06:36:04 <lambdabot>  The type variable ‘a0’ is ambiguous
06:36:05 <lambdabot>  Note: there are several potential instances:
06:36:07 <lambdabot>    instance [safe] GHC.Show.Show
06:36:08 <ski> kvanb : but `(*)' on `Integer' is strict
06:36:23 <kvanb> oh, it is?
06:36:39 <haasn> > 0 * undefined :: Integer
06:36:40 <lambdabot>  *Exception: Prelude.undefined
06:37:07 <ski> hellen_haskeller : neither of those channels currently exist
06:37:46 <ski> kvanb : the way you used `foldr', you get a single number as result (if it would terminate, i.e.), not a list
06:37:52 <hellen_haskeller> sorry, ah #haskell-beginners
06:37:56 <ph88> <interactive>:45:1: Not in scope: `nub'  ??
06:38:02 <kvanb> derp
06:38:10 <ski> @index nub
06:38:10 <lambdabot> Data.List
06:38:15 <ski> ph88 : `import' that
06:38:20 <kvanb> don't do repl at night on a public irc
06:38:24 <ph88> `import` Data.List ?
06:38:32 <ski> in a source file :
06:38:36 <ski>   import Data.List
06:38:44 <ski> in GHCi, either that, or
06:38:48 <ski>   :m + Data.List
06:38:57 <kvanb> :m - Data.List to kill it
06:38:59 <kvanb> I think
06:39:05 <ski> yep
06:39:21 <ski> (and `:m' is short for `:module', in case you wonder)
06:39:32 <kvanb> took me like 6 months to realize
06:39:35 <kvanb> import works in ghci
06:39:43 <ski> that's relatively recent
06:39:43 <kvanb> I just made the assumption it didn't and used :m for everything
06:40:07 <ski> a few years ago, no `import' in the interactor
06:40:28 <kvanb> ah
06:40:57 <hellen_haskeller> or at the very least, read chapters 1,2,3 and 8 of Learn you a Haskell for Great Good.
06:41:23 * ski thinks ph88 is probably reading chapter 3 atm
06:41:38 <ph88> im here http://learnyouahaskell.com/starting-out#im-a-list-comprehension
06:41:52 <kvanb> haskell needs more books
06:42:04 <ski> (er, sorry. got confused and got the `3' from somewhere else)
06:42:10 * haasn .oO( what would the inverse of “import” be? “export”? )
06:42:22 <kvanb> gabriel is going to write one
06:42:27 <kvanb> I'm looking forward to it
06:42:27 <ski> there's `foreign export' ..
06:44:04 <ski> "Foreign Declarations - Export Declarations" <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-140003.4>
06:44:41 <ph88> [(x, y) | x <- [1..4], y <- [1..x]]    how can i put a predicate not on every single occurance of x, but on all the combinations where x = 3 ?
06:44:54 <haasn> I guess the way to “cancel out” an import would be by overwriting it with an empty import or something; like import Data.List () in GHCi could be similar to (±orphans) :m -Data.List
06:45:06 <haasn> but unfortunately that does not seem to be the way it works
06:45:11 <cariveri> how to cabal upload as a candidate ?
06:45:13 <ph88> for example  here [(x, y) | x <- [1..4], y <- [1..x]]  show me all the combinations where the same x occurs 3 times
06:45:50 <haasn> (x /= 3 || predicate) ?
06:46:11 <haasn> x == 3 ==> predicate ?
06:46:44 <LeoTal> ph88: Do you mean [(x, y) | x <- [1..4], y <- [1..x], x==3] ?
06:46:55 * ski suspects not
06:46:57 <ph88> no
06:47:13 <ski> perhaps you can say what result you'd expect in this example ?
06:47:51 <ph88> [(x, y) | x <- [1..3], y <- [1..x]]      [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]    give me all groups where the same x occurs 3 times = [(3,1),(3,2),(3,3)]
06:48:11 <ph88> which is by coincidence also where x == 3  .. but i dont want to put it like this
06:48:28 <hellen_haskeller> kvanb: lyah is very comprehensive, although imho we could use a book that  holds the hands of imperative programmers
06:48:31 <ph88> what's ==> and || by the way ?
06:48:42 <Iceland_jack> (||) is logical or
06:48:42 <haasn> (||) is logical disjunction, “or”
06:48:46 <ski> `||' is "or", `&&' is "and"
06:48:58 <Iceland_jack> (==>) is just a function from a library
06:49:00 <ski> `==>' isn't defined in the `Prelude', but you could define it
06:49:09 <haasn> (==>) isn't an operator in standard haskell, but I took it to mean “logical implication”, meaning that if the left side is true then the right side is also true
06:49:21 <haasn> (as somewhat of a coincidence, this can be defined as (<=) in Haskell)
06:49:42 <haasn> or l ==> r = not l || r
06:49:47 <ph88> ok like in SQL i would just do COUNT(*)    GROUP BY
06:50:01 <ph88> HAVING value = 3
06:50:07 <ski> (that's one reason why i would prefer `<=' in Haskell was named `=<', like in e.g. Erlang and Prolog, instead)
06:50:15 <ph88> eh HAVING COUNT(*) = 3
06:50:57 <ski> hm, you want to keep those solutions where for each `x', there is exactly three `y' values ?
06:51:07 <ph88> yes
06:51:35 <haasn> ph88: If you want to “group by” values and so forth in list comprehensions, you need to move outside of the list comprehension itself (but there is a language extension, TransformListcomp, that enables those kinds of groupings and stuff similar to COUNT(*) in SQL)
06:51:46 <haasn> But in this specific case, you can also just check the length of [1..x] to see how many combinations there are
06:51:52 <haasn> Which, of course, is just x
06:52:08 <haasn> (or “max x 0” in general)
06:52:24 <ph88> max x 0  ??
06:52:29 <haasn> > max 3 0
06:52:30 <lambdabot>  3
06:52:32 <haasn> > max (-3) 0
06:52:34 <lambdabot>  0
06:52:46 <ph88> length [1,2,3]
06:52:46 <haasn> > (length [0..3], length [0..(-3)])
06:52:48 <lambdabot>  (4,0)
06:52:58 <ph88> > length [1,2,3]
06:52:58 <haasn> Err, [1..3]
06:52:59 <lambdabot>  3
06:53:07 <ph88> nice
06:53:48 <haasn> I guess the straightforward answer is “you can't simply do that the way you would in SQL, you have to think about it a bit”, or “don't do it all inside a list comprehension” or “TransformListComp”, take your pick?
06:54:06 <ski> > [(x,y) | x <- [1..5],y <- [1..x],x `mod` y == 0]
06:54:07 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,3),(4,1),(4,2),(4,4),(5,1),(5,5)]
06:54:11 <ski> > [(x,y) | x <- [1..5],let ys = [y | y <- [1..x],x `mod` y == 0],length ys == 3,y <- ys]
06:54:13 <lambdabot>  [(4,1),(4,2),(4,4)]
06:54:33 <ph88> so i was trying to find prime numbers
06:54:34 <ph88> > [(x, y, x `mod` y) | x <- [1..10], y <- [2..x-1]]
06:54:36 <lambdabot>  [(3,2,1),(4,2,0),(4,3,1),(5,2,1),(5,3,2),(5,4,1),(6,2,0),(6,3,0),(6,4,2),(6,...
06:54:46 <Iceland_jack> This sounds like an XY problem
06:55:07 <ph88> so then i think i take all groups of x where x `mod` y == 0 occurs 0 times
06:56:30 <ph88> ok so i take it haasn that it can not be done inside the list comprehension
06:56:36 <ph88> moving on ..
06:56:57 <haasn> What you just described, on the other hand, is a much easier problem if expressed in a different way
06:57:24 <haasn> > filter (\x -> x `mod` 3 == 0) [1..]
06:57:25 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
06:57:44 <haasn> > filter (\x -> x `mod` 3 /= 0) [1..]
06:57:45 <lambdabot>  [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40,...
06:58:19 <ph88> hey first i was doing <- as generator, and now you use ->
06:58:33 <Iceland_jack> ph88: that denotes an anonymous function
06:58:34 <haasn> <- and -> are mostly unrelated
06:58:37 <Iceland_jack> > (\x -> x + x) 10
06:58:38 <lambdabot>  20
06:58:52 <ph88> why the \ before x ?
06:59:02 <Iceland_jack> ph88: that's just the syntax
06:59:20 <Iceland_jack> if you squint it looks a bit like a lambda λ
06:59:27 <ph88> > (\x -> x*x) 16
06:59:28 <lambdabot>  256
06:59:36 <ph88> lol try
06:59:36 <haasn> > let f x = x*x in f 16
06:59:38 <lambdabot>  256
06:59:38 <Iceland_jack> > (\x -> x ++ "!") "Hello"
06:59:39 <lambdabot>  "Hello!"
06:59:47 <haasn> > (let f x = x*x in f) 16
06:59:48 <lambdabot>  256
06:59:53 <ph88> ah very cool
07:00:01 <haasn> this is literally how you desugar it
07:00:18 <Iceland_jack> > map (\str -> str ++ "!") ["hello", "world"]
07:00:19 <lambdabot>  ["hello!","world!"]
07:00:26 <Iceland_jack> > map (++ "!") ["hello", "world"]
07:00:27 <lambdabot>  ["hello!","world!"]
07:00:30 <ph88> i find the desugar variant more confusing, but ill keep it in mind
07:00:56 <haasn> Ah, I assumed “let x = y in z” was already familiar
07:01:21 <ph88> i know "let", but not "in"
07:01:30 <Iceland_jack> > let x = "hello" in x
07:01:32 <lambdabot>  "hello"
07:01:33 <Iceland_jack> > let x = "hello" in x ++ x
07:01:34 <lambdabot>  "hellohello"
07:01:37 <Iceland_jack> > let x = "hello" in x ++ x ++ x
07:01:38 <lambdabot>  "hellohellohello"
07:02:03 <haasn> ph88: “let” is overloaded, it appears in list comprehensions and do-notation without the “in”, but when used as an expression, the “let .. in” are part of the same syntactical construct - they can't exist without each other
07:02:36 <ph88> i see
07:02:59 <edisach> > \x -> x + x $ 10
07:03:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
07:03:01 <lambdabot>    arising from a use of ‘M153684383227567654210796.show_M1536843832275676542...
07:03:01 <lambdabot>  The type variable ‘t0’ is ambiguous
07:03:01 <lambdabot>  Note: there are several potential instances:
07:03:01 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
07:03:13 <haasn> “let x = y in z” just the same as z, except occurrences of ‘x’ inside ‘z’ refer to ‘y’
07:03:14 <haasn> for example
07:03:18 <haasn> > let x = 1 in x+x
07:03:19 <lambdabot>  2
07:04:16 <haasn> > (let x = 1 in x+x, x) -- note the scoping
07:04:18 <lambdabot>  (2,x)
07:04:28 <haasn> .. screw you SimpleReflection
07:04:37 <haasn> > (let foo = 1 in foo+foo, foo) -- note the scoping
07:04:38 <lambdabot>  Not in scope: ‘foo’
07:04:38 <lambdabot>  Perhaps you meant ‘T.for’ (imported from Data.Traversable)
07:05:00 <jacobw> let .. in?
07:05:32 <jacobw> > let x = x * 2 in x 2
07:05:34 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
07:05:34 <lambdabot>    arising from the ambiguity check for ‘e_122’
07:05:34 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
07:05:34 <lambdabot>    bound by the inferred type for ‘e_122’:
07:05:34 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
07:06:07 <ski> > [x | x <- [1 ..],x `mod` 3 /= 0]  -- ph88, another way to spell the `filter'
07:06:09 <lambdabot>  [1,2,4,5,7,8,10,11,13,14,16,17,19,20,22,23,25,26,28,29,31,32,34,35,37,38,40,...
07:07:02 <u-ou> > iterate id Nothing
07:07:04 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Not...
07:07:22 <cariveri> hey. can i somehow make package a candidate for upload instead of uploading at once?
07:07:59 <trap_exit> luite: when reading a number (from JS) back into Haskell -- are numbers Ints or Doubles?
07:08:17 <trap_exit> luite: I heard all JS numers all doubles, but I know for a fact that the number I'm reading back is integral
07:12:47 <ph88> can i pick one element from (1,2)  ?
07:13:05 <ph88> > [1,2] !! 0
07:13:06 <lambdabot>  1
07:13:12 <Iceland_jack> ph88: you can use fst/snd
07:15:07 <ski>   Prelude> :set -XTransformListComp
07:15:10 <ski>   Prelude> :m + GHC.Exts
07:15:19 <ski>   Prelude GHC.Exts> [(the x,y) | x <- [1..9],y <- [1..x],x `mod` y == 0,then group by x using groupWith,length y == 3]
07:15:26 <ski>   [(4,[1,2,4]),(9,[1,3,9])]
07:16:06 <ph88> over powered :P
07:16:12 <ski> ph88 : that's somewhat like "group by x having count(*) = 3', i think
07:16:46 <ski> <https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions>
07:18:35 <Guest14261> trap_exit: you should use a conversion which produces an integer and crashes if it isn't
07:18:48 <Guest14261> because you know it isnt
07:25:54 <haasn> ski: more like having count(y) = 3, but yes
07:26:18 <haasn> Also the “the” thing is somewhat of a kludge that isn't needed in SQL
07:26:32 <bollu> hey everyone, I've been reading about the Yoneda lemma, and from what I understand, it lets you map a category C into a Category S, where S is this "category of sets". But, I don't understand what a "hom functor" is. Help?
07:27:09 <steffen> How do I have to understand the '| m -> e' in this line : 'class Monad m => MonadError e m | m -> e where' ?
07:27:21 <Iceland_jack> steffen: Search for 'functional dependency'
07:27:29 <steffen> Iceland_jack: okay, thanks
07:27:46 <Iceland_jack> It basically means that 'e is uniquely determined by m'
07:28:04 <haasn> bollu: a (C-)Hom functor like Hom(X,-) is a functor taking every Y to the set of C-homs from X to Y
07:28:18 <haasn> Hom(X,-) : C -> Set
07:28:50 <bollu> haasn: and C-homs are?
07:29:15 <haasn> so for example in a category with f : A -> B, g : B -> C we have Hom(A,C) = {g.f} and Hom(A,B) = {f}
07:29:16 <Iceland_jack> bollu: Have you looked at any resources?
07:29:31 <Iceland_jack> Is something like https://en.wikipedia.org/wiki/Hom_functor helpful?
07:30:04 <haasn> bollu: hom is short for homomorphism, or just “morphism”; which is a fundamental component of categories
07:30:14 <Iceland_jack> If you're learning about the Yoneda lemma you should probably know about Hom functors first
07:30:15 <bollu> haasn: Iceland_jack I've been watching the youTube series, plus I've been waiting for a cateogyr theory book to arrive :)
07:30:45 <haasn> There's not just one “hom functor”, there's a hom functor for every category C, because every category has its own morphisms
07:30:45 <bollu> haasn: yes, I understand what a morphism is. Didn't know what C-Homs are
07:30:54 <haasn> I just called this “C-Hom” to be explicit about it
07:31:00 <haasn> A homomorphism in the category C
07:31:46 <Iceland_jack> ((->) r) is an example of a Hom functor
07:31:49 <haasn> Hom(A,B) is the subset of all homomorphisms that go from A to B
07:32:16 <bollu> haasn: ohh.
07:32:18 * hackagebot arguedit 0.1.0.0 - A computer assisted argumentation transcription and editing software.  http://hackage.haskell.org/package/arguedit-0.1.0.0 (hrazel)
07:32:47 <bollu> Iceland_jack: how so?
07:33:21 <Iceland_jack> bollu: If you look at the definition for Hom functors it fits the bill
07:33:28 <haasn> Iceland_jack: only if you squint
07:33:37 <haasn> Hom goes to Set, but ((->) r) goes to Hask again
07:33:48 <haasn> ((->) r) is an internal Hom
07:33:55 <Iceland_jack> Right but it's as close as you get in Haskell
07:34:29 <Iceland_jack> For f : A → B:
07:34:29 <Iceland_jack>     Hom(R, f) : Hom(R, A) → Hom(R, B)
07:34:30 <trap_exit> using tempalte haskell, is there a way I can have "fiju" expand to "foreign import javascript unsafe" ?
07:34:45 <trap_exit> somethign like "alias fiju = foreign import javascript unsafe"
07:34:50 <trap_exit> (via template haskell)
07:35:36 <bollu> haasn, Iceland_jack : looks like I have quite a bit to read. thanks for the pointers!
07:36:07 <haasn> bollu: What book are you getting?
07:36:22 <bollu> haasn: A first introduction to categories
07:36:44 <bollu> haasn: it's a good book right?
07:37:04 <haasn> Can't judge; I started with Pierce's category theory for computer scientists (or something like that)
07:37:17 <bollu> haasn: hm, okay
07:37:28 <haasn> But there are many books on the topic
07:37:32 <bollu> this one? http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
07:38:03 <haasn> This one http://books.google.se/books/about/Basic_Category_Theory_for_Computer_Scien.html?id=ezdeaHfpYPwC&redir_esc=y
07:38:30 <ski> haasn : yes, i'm not so happy with the translation introducing the need for `the'
07:39:33 <kvanb> woah, what
07:39:35 <kvanb> you can do that
07:39:36 <kvanb> https://hackage.haskell.org/package/stm-containers-0.1.2/docs/src/STMContainers-Map.html#Key
07:39:46 <haasn> ski: Right, but unfortunately it's a bit hard to figure out what to apply ‘the’ to if using something more complex like “group by (x, Op y)”
07:40:22 <haasn> Maybe a case could be made to auto-the all of the comprehension-bound variables that show up in the expression?
07:41:06 <haasn> Oh, but that breaks in an example like “group by fst x”
07:41:39 <haasn> Because in this case we group by pairs where the first element is identical but we still can distinguish them using the second element
07:42:29 <EvanR> trap_exit: urg by crash i did not mean segfault
07:42:44 <trap_exit> EvanR: wtf are you talking about?
07:44:04 <trap_exit> luite: what's a good example of doing callbacks in ghcjs? i.e. I want to pass a haskell function to a js function, so that the js can call the hs
07:44:27 <trap_exit> luite_: this is how the code would look like in haste: https://gist.github.com/anonymous/f98d27a4ccac49b1079d
07:47:19 * hackagebot fca 0.1.0.2 - Algo for Formal Concept Analysis  http://hackage.haskell.org/package/fca-0.1.0.2 (Rpr)
07:52:19 * hackagebot arguedit 0.1.0.1 - A computer assisted argumentation transcription and editing software.  http://hackage.haskell.org/package/arguedit-0.1.0.1 (hrazel)
07:54:53 <therp> ok I give up on hmatrix-gsl. Is there actually a proper way to install that package without running into gsl missing-cblas-library linking issues? INSTALL.md recommends --configure-options but since there is no configure script that is entirely a no-op, right?
07:55:02 <ph88> i use this to check if 2 is in list  2 `elem` [1,2,3]    how can i check if it's _not_ in list ?
07:55:24 <therp> (yes I can fiddle with hmatrix-gsl.cabal but I would prefer to report a bug if that's actually broken)
07:55:45 <ph88> 2 `elem` [1,2,3] == False   doesnt work
07:55:59 <cariveri> Hey. why would hackage not display the docs of my code? I created them with haddock successfully.
07:56:17 <ph88> not 2 `elem` [1,2,3]    also doesnt work
07:57:31 <Pythonfant> > not $ 2 `elem` [1,2,3]
07:57:33 <lambdabot>  False
07:57:40 <Pythonfant> > not $ 2 `elem [1,3]
07:57:41 <lambdabot>  <hint>:1:15: parse error on input ‘[’
07:57:47 <Pythonfant> > not $ 2 `elem` [1,3]
07:57:48 <lambdabot>  True
07:57:56 <Pythonfant> ph88: that seems to work
07:58:03 <ph88> cool, what's the $ for ?
07:58:09 <Pythonfant> :t not
07:58:10 <lambdabot> Bool -> Bool
07:58:13 <Pythonfant> not takes a boolean
07:58:18 <Pythonfant> but if you don't have the $
07:58:21 <Pythonfant> not gets the 2 first
07:58:37 <Pythonfant> the $ first evaluates everything on it's right before passing it to the function on the left
07:58:51 <ph88> aah ok
07:58:59 <ph88> could i use parenthesis as well ?
07:59:12 <Pythonfant> ofc
08:00:07 <ph88> cool
08:00:19 <ph88> ski: check this .. i finished my first challange :)
08:00:23 <ph88> > [a | a <- [2..100], not $ a `elem` [x | x <- [1..100], y <- [2..x-1], x `mod` y == 0]]
08:00:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
08:00:29 <EvanR> > fst $ (4,undefined)
08:00:30 <ph88> prime numbers :)
08:00:30 <therp> ph88: yes. $ has no other function than avoiding parenthesis. (there is also $! which does a bit more)
08:00:30 <lambdabot>  4
08:00:40 <EvanR> > (4,undefined)
08:00:42 <lambdabot>  (4,*Exception: Prelude.undefined
08:01:10 <EvanR> im not sure $ evaluates everything on the right first
08:01:41 <EvanR> > (const 4) $ undefined
08:01:43 <lambdabot>  4
08:01:55 <therp> EvanR: nope, it doesn't. good point
08:02:18 <therp> > (const 4) $! undefined
08:02:20 <lambdabot>  *Exception: Prelude.undefined
08:03:46 <Pythonfant> EvanR: yep, I didn't knew how to formulate it correctly
08:04:33 <Pythonfant> I guess it doesn't do anything with evaluation and just passes everything on the right as one argument into the function on the left
08:05:02 <EvanR> > error "function" $ error "arg"
08:05:03 <lambdabot>  *Exception: function
08:05:37 <EvanR> > error "function" $! error "arg"
08:05:38 <lambdabot>  *Exception: arg
08:06:04 <EvanR> :t undefined $ 4
08:06:05 <lambdabot> t
08:06:44 <EvanR> forall t. t
08:07:34 <EvanR> seems like that type should be Integer or Num a => a
08:07:37 <gigamonkey> Is Parsec still the state-of-the art for parsing in Haskell?
08:09:07 <EvanR> :t undefined
08:09:08 <lambdabot> a
08:09:17 <EvanR> :t 4
08:09:18 <lambdabot> Num a => a
08:12:22 * hackagebot esqueleto 1.4.4 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.4.4 (FelipeLessa)
08:15:29 <lambdablammo> > :t Just 4
08:15:30 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:15:54 <Iceland_jack> :t Just 5
08:15:55 <lambdabot> Num a => Maybe a
08:16:17 <lambdablammo> :t Just 6
08:16:18 <lambdabot> Num a => Maybe a
08:16:26 <lambdablammo> thx
08:16:41 <EvanR> :t 6.0
08:16:42 <lambdabot> Fractional a => a
08:18:03 <Jonas_> hi
08:19:55 <Guest44541> Can anybody tell me what a higher order stream is?
08:20:02 <Guest44541> Or what does a stream make a higher order stream?
08:23:03 <Jeanne-Kamikaze> Guest44541, from the wikipedia (nature, not haskell): "A stream of the first order is a stream which does not have any other recurring or perennial stream feeding into it. When two first-order streams come together, they form a second-order stream. When two second-order streams come together, they form a third-order stream."
08:23:28 <EvanR> haha
08:24:54 <Guest44541> quite interesting, thanks your for response
08:27:15 <Guest44541> I'
08:27:24 <Guest44541> I'll try to follow that intuition
08:27:29 <osa1_> is there a special name given to types with * -> * kind?
08:27:30 <bscarlet> Any cabal sandbox + emacs users got a good way to make jumping to the next error work? I want a hook of some sort to make cabal-install print an appropriately formatted message when it changes the working directory to build a different package.
08:27:35 <cariveri> hmm ok. seems no one knows :(
08:28:46 <Guest44541> although I was hoping to read a definition in the context of functional programming, just to be sure
08:30:51 <gigamonkey> Is there an  easy way to completely uninstall the Haskell Platform from OS X?
08:31:03 <EvanR> osa1_: type constructor maybe
08:31:08 <gigamonkey> I think my installation in borked and I want to uninstall and try again after updating my Xcode install.
08:33:55 <Jeanne-Kamikaze> Guest44541, this is somewhat more mathematical, and it has the same interpretation: http://en.wikipedia.org/wiki/Strahler_number
08:36:54 <Guest44541> I'll take a look at that, thanks
08:41:20 <ski> osa1_ : i don't think so
08:41:47 <ski> osa1_ : maybe you could call then "(strictly) first-order types" ..
08:42:39 <EvanR> parameterized type
08:42:41 <ski> Guest44541 : context ?
08:43:43 <ski> ph88 : good (btw, there's a `notElem')
08:43:51 <ph88> :) :)
08:43:54 <ski> ph88 : now make it return the list of all prime numbers
08:44:03 <ph88> return ??
08:44:07 <ski> evaluate to
08:44:14 <ph88> oh
08:44:28 <ski> all, as opposed to just those less than `100'
08:44:28 <ph88> its the same but then .. instead of ..100
08:44:44 <ski> try it ?
08:45:08 <ski> EvanR : that's wider
08:45:29 <Guest44541> ski: Elerea, trying to read the author's paper
08:45:31 <ph88> i think it will take too much time to computer all prime numbers
08:45:33 <ski> `Either' and `MaybeT' are parameterized
08:45:42 <ph88> so it would be nice to at least display intermediate results
08:45:59 <ph88> ye its not working obviously because its infinite time
08:46:02 <ski> Guest44541 : what's "Elerea" ? which author ?
08:46:30 <ski> ph88 : for each prime, if you do it right, there should be a finite time to find it
08:46:44 <Guest44541> An FRP library, "Eﬃcient and Compositional Higher-Order Streams" by patai (http://sgate.emt.bme.hu/documents/patai/publications/PataiWFLP2010.pdf)
08:47:23 <ski> hehe, a ligature
08:47:47 <ski> perhaps they mean a higher-order representation
08:48:04 <EvanR> ski: hmm. but isnt * -> * -> * = * -> (* -> *) a combination of two * -> * oh nevermind i guess not
08:48:24 <EvanR> thats second order
08:48:35 <ph88> ski: im not doing it right because in the inner loop i compute all the non-prime numbers .. then for each number i check if its not in that list ... so that means for each number im doing the same very heavy computation again
08:48:52 <ski> EvanR : *nod*, depends on how you define the order precisely
08:50:11 <ph88> ski: i dont know how else to solve this other then using state
08:50:44 <ski> ph88 : how about not computing the non-prime numbers ?
08:51:12 <ski> (btw, it's possible to do with an approach that computes the composite numbers as well .. that one is quite interesting, i think)
08:51:31 <Guest44541> ski: Maybe, I don't know. The more I read about functional programming, the more I realize what I don't know
08:51:52 <ph88> ski: the problem was more difficult then because i didnt know how to do GROUP BY with list comprehesion
08:52:15 <ski> Guest44541 : browsing the paper atm
08:52:23 <ph88> like filter reduce
08:52:25 * hackagebot ZipperAG 0.7 - An implementationg of Attribute Grammars using Functional Zippers  http://hackage.haskell.org/package/ZipperAG-0.7 (prmartins)
08:52:51 <ski> hm, that library sounds like it could be interesting
08:54:46 <ph88> ski: consider the divisions of 9, where 9/8 has a mod higher then 0 so it could be a prime, but then 9/3 has mod 0 so it proves its not a prime. So for the 9 you can filter on the proof it's possibly a prime and it's definately not a prime
08:55:39 <ph88> ski: then for 3 i can filter on the proof that it's possibly a prime, because on each occurence i can not look at the other results of divisions to determine if one of those has a mod 0
08:57:04 <ski> Guest44541 : btw, this appears to be an interesting paper :)
08:57:30 <ph88> ski: the criteria is X does not have a divisor Y that yield mod 0
08:57:43 <Guest44541> ski: glad that you find it interesting, it is indeed :) But I guess I have to do some background reading
08:57:55 <ski> Guest44541 : anyway, i think they just mean that they have combinators and constructions, operating on streams, where the former are higher-order
08:58:07 <ski> Guest44541 : like `map' and `filter' are higher-order functions
08:59:31 <edisach> > 10 $ \x -> x + x
08:59:32 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> t))
08:59:33 <lambdabot>    arising from the ambiguity check for ‘e_110’
08:59:33 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> t), GHC.Num.Num a)
08:59:33 <lambdabot>    bound by the inferred type for ‘e_110’:
08:59:33 <lambdabot>               (GHC.Num.Num ((a -> a) -> t), GHC.Num.Num a) => t
08:59:35 <ski> ph88 : ok
08:59:53 <int3__> (what is this paper? just curious)
08:59:54 <Guest44541> ski: Yes, that sounds reasonable, so it's really the higher-order operations which allow the manipulation/construction of "higher-order" streams
09:00:19 <int3__> (I just came into the channel)
09:01:03 <ski> <Guest44541> An FRP library, "Eﬃcient and Compositional Higher-Order Streams" by patai (http://sgate.emt.bme.hu/documents/patai/publications/PataiWFLP2010.pdf)
09:01:26 <EvanR> ha ligated fi
09:02:01 <ski> Guest44541 : the point being that the configuation of the "network" of streams isn't static (iow fixed at the outset), but can be "reconfigured" and set up dynamically, during (proper) run-time
09:02:12 <Guest44541> yes
09:02:14 <ski> "ffi"
09:02:46 <ski> > (\x -> x + x) 10  -- edisach ?
09:02:47 <lambdabot>  20
09:03:01 <ski> > ($ 10) $ \x -> x + x
09:03:03 <lambdabot>  20
09:03:20 <edisach> Ah, there ya go
09:03:22 <ski> @let properDivisors n = [d | d <- [2 .. n - 1],n `mod` d == 0]
09:03:24 <lambdabot>  Defined.
09:03:42 <ski> > map properDivisors [1 .. 9]
09:03:43 <lambdabot>  [[],[],[],[2],[],[2,3],[],[2,4],[3]]
09:03:54 <ski> ph88 : perhaps that could be useful ?
09:03:59 <Guest44541> ski: Thanks for taking a look at it, I'll keep on reading
09:04:28 <ski> Guest44541 : i've found that the best way to learn to read papers seems to be to attempt to read them :)
09:04:47 <ski> (and also to follow up references, possibly looking for earlier or more expository work)
09:07:44 <Guest44541> ski: Indeed :)
09:13:33 <Algebr> How does return know what Monad its in?
09:13:39 <ski> it's overloaded
09:13:53 <ski> so the same as `(+)' knows which kind of "numbers" it operates on
09:14:21 <Algebr> ah, thanks
09:14:27 <ski> the type system determines at compile-time which number/monad was meant
09:15:00 <ski> the only perhaps unusual part here is that with type class based overloading in Haskell, an operation can be overloaded on the return type (solely)
09:15:38 <ski> e.g. in Java, two overloaded methods must differ either in the number of arguments, or the types of those arguments. it can't only differ in the return type
09:16:03 <ski> iirc, Ada also has return-type overloading
09:16:51 <trap_exit> luite, luite_ : ping ping ping
09:17:05 <trap_exit> luite, luite_ : how does JSNumber / numbers work in ghcjs?
09:21:36 <glguy_> trap_exit: http://lmgtfy.com/?q=google.com
09:23:20 <trap_exit> glguy_ : I have spent the past 20 minutes searching through github ghcjs code. Have you used ghcjs / jsnumber conversion, or are you being an annoying idiot?
09:25:17 <glguy_> First thing that came up was luite's blog where he talks about how he does numbers
09:25:44 <luite_> trap_exit: yeah i'm not here all th time :)
09:26:04 <luite_> trap_exit: you can add extra js files by just adding them on the command line
09:26:26 <trap_exit> glguy_ : that blog is out of date and not related to current ffi (based on yesterday's logs, which I don't know if you were following)
09:26:40 <trap_exit> luite_ : oh, for that question .. I just ended up over writing index.html afte revery recompile
09:26:58 <trap_exit> luite_ : I forgot all the questions I asked you, but the only one that is yet unresolved is number conversion
09:26:58 <luite_> trap_exit: for callbacks see ghcjs-base GHCJS.Foreign
09:27:10 <trap_exit> luite_ : I got callbacks working too
09:27:12 <trap_exit> luite_ : except for the number part
09:27:14 <luite_> there is no good way to do static exports yet
09:27:29 <trap_exit>   s1 <- syncCallback AlwaysRetain False (putStrLn "fromCallback")    FFI.runCallback s1
09:27:33 <trap_exit> where FFI is a module I wrote myself
09:27:41 <luite_> trap_exit: usually you'd just use fromJSRef / toJSRef for numeric types
09:27:59 <ph88> ski: why does that properDivisors have many empty lists ?
09:28:11 <trap_exit> luite_ : is there sample code from this?
09:28:21 <ski> ph88 : because the respective numbers don't have any proper divisors ?
09:28:48 <trap_exit> I feel like there sis eomthing very simple that I am missing
09:28:51 <ph88> roger roger
09:28:58 <ski> ph88 : `4',`6',`8',`9' there have proper divisors
09:29:17 <ski> (those are the composite numbers between `1' and `9')
09:29:57 <luite_> trap_exit: the implementation is here, you use the fromJSRef / toJSRef methods to do the conversion, https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Marshal.hs
09:30:23 <trap_exit> yes,
09:30:24 <luite_> trap_exit: but it's in IO, it shoud have to be for numbers
09:30:37 <trap_exit> but we have data JSNumber_ , and JSNumber = JSRef JSNumber_
09:30:48 <trap_exit> so how do I get from JSNumber_ to Double or JSNumber_ to Int ?
09:31:14 <trap_exit> luite_ : reference: https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Types.hs
09:31:15 <luite_> trap_exit: that's just a tag, you can't have JSNumber_ values
09:31:27 <luite_> you convert a JSNumber to Double
09:32:39 <trap_exit> luite_: here's the concrete example I'm dealing with https://gist.github.com/anonymous/ca984952b2af724f5113
09:32:55 <trap_exit> I'm setting the key down hadnler, and I wnat to have a functino that has Bool -> Bool -> Bool -> Int -> IO ()
09:33:03 <trap_exit> where the first three = alt, ctr, shift, and the fourth = keycod
09:33:51 <ph88> ski: so your trick is to define n as a function parameter so you dont have to define the upper bound statically
09:33:51 <EvanR> :t floor
09:33:52 <lambdabot> (RealFrac a, Integral b) => a -> b
09:34:01 <EvanR> :t floor :: Double -> Int
09:34:02 <lambdabot> Double -> Int
09:34:43 <luite_> trap_exit: don't use IO For the second argument but a JSRef (more specifically a JSFun)
09:35:31 <luite_> trap_exit: and to convert an Int to a JSNumber you just use toJSRef
09:37:41 <trap_exit> luite_ : ah, I think I get toJSRef / fromJSRef now
09:38:26 <luite_> trap_exit: the problem is that they're in IO, since most JS values are mutable. i think it should probably be split in a class that doesn't require IO and one that does
09:38:39 <ph88> ski: i try to do it with an anonymous function like this    (\z -> z `notElem` [x | x <- [1..100], y <- [2..x-1], x `mod` y == 0]) [1..100]   but this doesnt have a return value, only true or false. How can i return something or nothing ?
09:40:58 <luite_> trap_exit: anyway i'm rather tired now, going to take a break. if you feel like experimenting with or want to improve the api, open some ticket on ghcjs-base, and see ghcjs ticket #194 for the current plan for better foreign exports
09:41:20 <trap_exit> luite_ : noted, thanks again for all your help
09:41:25 <trap_exit> luite_ : take care
09:41:43 <ski> ph88 : not sure what my "trick" was here, if anything
09:42:19 <ski> ph88 : you don't want to use `elem' or `notElem' on an infinite list. try to rethink your approach slightly
09:43:11 <luite_> trap_exit: there's also #ghcjs by the way, it's a bit quieter than here so if no one is around your messages don't scroll into oblivion as quickly
09:43:36 <trap_exit> luite_ : ah
09:47:09 <cariveri> hey. can please anyone tell me hwo to upload documentation to my hackage?
09:55:00 <ph88> ski: sorry i got disconnected ^^
09:55:40 <ph88> i was trying to do it with an anonymous function (\z -> if (z `notElem` [x | x <- [1..100], y <- [2..x-1], x `mod` y == 0]) then z) [1..100]
09:57:54 <ski> <ski> ph88 : not sure what my "trick" was here, if anything
09:57:56 <ski> <ski> ph88 : you don't want to use `elem' or `notElem' on an infinite list. try to rethink your approach slightly
09:58:16 <ph88> ok
10:02:02 <Algebr> Which one is more general? return or pure?
10:02:42 <ski> taken on their own, none
10:03:07 <Algebr> Is Monad a super type of Applicative?
10:03:09 <ski> however the `Applicative' abstraction is more general than `Monad'
10:03:13 <Algebr> oh
10:03:26 <ski> `Applicative' could be a super class (not type) of `Monad'
10:03:33 <ski> (and probably will be, soon)
10:03:47 <ski> conceptually, every Haskell monad is an applicative functor
10:04:14 <ski> one can just define `pure = return; (<*>) = ap', and the laws for `Applicative' then follows from the ones for `Monad'
10:04:22 <ski> @type ap
10:04:23 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:04:32 <ski> @src ap
10:04:32 <lambdabot> ap = liftM2 id
10:06:32 <Algebr> So everything that is tagged IO is sort of like its own complete imperative program?
10:06:49 <ski> yes
10:06:55 <ski> and they can be composed with each other
10:07:25 <c_wraith> Algebr: it's not just a tag, though.  It's really a different type.  Calling it a tag doesn't explain the difference between IO Int and IO (IO Int)
10:07:45 <Algebr> c_wraith: What would be more appropriate than tag?
10:07:54 <Algebr> ah, sorry, just reread your post
10:07:54 <c_wraith> Algebr: type
10:08:06 <nisstyre> or parametric type
10:08:40 <ski> a value of type `IO Int' (sometimes called an `IO'-action) can be thought of as a description of an imperative program that, when executed, will compute an `Int' as result
10:08:57 <ski> @quote /bin/ls
10:08:57 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
10:09:17 <Algebr> ski: and main is the sum of all imperative programs? or the one that composes them all?
10:09:31 <nisstyre> it's the entry point, same as C
10:09:34 <ski> not sure what you mean by "all" here
10:10:01 <ski> `main' is typically composed out of many small pieces, small "imperative programs" if you will
10:10:02 <Algebr> all IO stuff you do has to be done from within main, so its like a collection of your IO code
10:10:23 <ski> an `IO'-action will only be executed if it's made part of `main'
10:10:35 <ski> (or part of an `IO'-action entered in the interactor)
10:11:31 <ski> > length [putStrLn "a",putStrLn "b"]  -- here we just pass `IO'-actions around, they are not executed
10:11:32 <lambdabot>  2
10:12:27 <Algebr> ski: For them to be executed, they would have had to been done in the IO monad?
10:12:45 <ski> > sequence [getLine,(do putStrLn "hey"; getLine)]  -- this would compose an `IO'-action that, if executed, would execute the two actions in the list (in order)
10:12:46 <lambdabot>  <IO [[Char]]>
10:13:05 <ski> > sequence (reverse [getLine,(do putStrLn "hey"; getLine)])  -- this would then execute them in the opposite order
10:13:06 <lambdabot>  <IO [[Char]]>
10:13:18 <ski> however, lambdabot doesn't execute `IO'-actions (for safety reasons)
10:14:05 <ski> Algebr : you can only express I/O in the `IO' monad (or things built on it, or related to it)
10:14:34 <Algebr> ski: so there is only just 1 IO monad in a haskell program?
10:14:44 <ski> (not sure what you mean by "done in the IO monad")
10:14:56 <ski> monads are not values
10:14:56 <tommd> It's a shame the IO monad exists.  It is much harder to produce observable bugs without IO.
10:15:47 <ski> Algebr : `main' is not an "IO monad", it's a monadic action (an `IO'-action, specifically). `IO' (the type) itself (together with the definition of `return' and `(>>=)' for it, satisfying the laws) is the monad
10:16:17 <ski> Algebr : perhaps you already know this, i'm just making sure
10:16:32 <Algebr> I appreciate it, you say it so clearly.
10:17:11 <ski> there is never any "i get the monad as parameter" or "i return the monad"
10:17:44 <Algebr> ski: So typeclasses are not first class, just to be sure.
10:18:01 <ski> type classes exist at the same conceptual level as types do
10:18:15 <ski> neither are concrete things that can be passed around at run-time
10:18:32 <ski> `Monad' is a type class
10:18:40 <ski> `IO' is a type (a type function, specifically)
10:19:08 <nadirs> \q lambdabot
10:19:43 <ski> with some extensions, you can bind variables to type classes, so then they're arguably first-class. they still exist at the type level, not the value level, though
10:24:28 <Desheng> I installed wx from cabal and tried to run the "hello world" program in section 2 of this page: http://www.haskell.org/haskellwiki/WxHaskell/Quick_start
10:24:59 <Desheng> 2.hs: /home/octophore/.cabal/lib/wxcore-0.13.2.3/ghc-7.6.3/HSwxcore-0.13.2.3.o: unknown symbol `__dso_handle' <cr> 2.hs: 2.hs: unable to load package `wxcore-0.13.2.3'
10:26:01 <Desheng> is this a known issue with installing wx from cabal? are there additional options I need to use when installing WX or should I compile it from newer source
10:40:06 <Philonous> sort/sortBy are not guaranteed to be stable, are they?
10:41:33 <c_wraith> Philonous: they are
10:41:57 <c_wraith> err, maybe not in by the spec, but GHC will always use a stable implementation
10:42:03 <ReinH> Philonous: looks like it's a mergesort, so yes
10:42:12 <ReinH> sort = sortBy compare
10:42:42 <ReinH> c_wraith: the report prelude version is sortBy cmp = foldr (insertBy cmp) though o_O
10:42:55 <ReinH> But the report doesn't specify an algorithm?
10:43:18 <ReinH> Philonous: http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-List.html#sort
10:43:46 <ReinH> some interesting stuff in there actually
10:43:55 <ReinH> looks like it was a quicksort in 2002
10:43:59 <ReinH> neat
10:44:12 <c_wraith> actually, I think foldr (insertBy cmp) is stable, anyway.
10:44:58 <c_wraith> assuming insertBy puts it before the first thing it's equal to, that's stable
10:45:12 <SLi> Is it currently practical (using some package in hackage) to write code that using the type system requires two parameter lists/vectors/whatever you call them to have the same length?
10:45:46 <c_wraith> SLi: yes
10:45:55 <SLi> c_wraith: Which package should I look at?-)
10:46:00 <ReinH> c_wraith: it's stable, sure, it's just slow
10:46:39 <c_wraith> SLi: I have no idea.  I just know that it's been relatively easy to express that since GADTs were added to GHC.
10:46:45 <SLi> Ok.
10:46:53 <c_wraith> SLi: what properties do you actually want?  linked list or packed array?
10:47:04 <c_wraith> do you want arithmetic on the sizes?
10:48:27 <SLi> c_wraith: Yeah, I need some simple arithmetic on the sizes, so more linked-list style I guess (performance is probably not too important at this point). Like I want to be able to get the tail of a n-length list and get a n-1-length list.
10:48:41 <donri> how about https://github.com/ku-fpg/sized-types
10:49:11 <SLi> Maybe, I guess I'll take a look :)
10:49:40 <SLi> There's also fixed-list in hackage, no idea how good or practical it is.
10:50:06 <SLi> And fixed-vector.
10:50:42 <donri> and sized-vector... :P
10:50:45 <Philonous> c_wraith, Hmm, I'm not sure I can rely on that.
10:50:50 <c_wraith> I mean, since GADTs were added, sized lists have been trivial.  *someone* must have built a decent support library around them and put it on hackage, right?
10:50:53 <Philonous> c_wraith, ReinH thanks
10:53:02 <c_wraith> the GADT-sized list formulation even gets type-safe head and tail.
10:54:51 <Philonous> Heh, I can just rewrite (map head . groupBy ((==) `on` snd) . sortBy (compare `on` snd)) as nubBy ((==) `on` snd), and that _is_ stable
11:01:52 <bluebelle> I found a nice SO question here (http://stackoverflow.com/questions/24714801/instance-not-being-exported)
11:02:28 <bluebelle> Basically, why is MPTC not working for tuple parameters?
11:07:37 * hackagebot h-gpgme 0.1.0.0 -   http://hackage.haskell.org/package/h-gpgme-0.1.0.0 (rethab)
11:23:40 <adarq> hey, is it possible to have something like.. data Week = Monday | ... Sunday .. Then, I want to create WorkWeek and create an instance of Enum where: succ Friday = Monday etc.. Do I have to make WorkWeek a newtype and then define the instance?
11:24:27 <adarq> so for Week, succ Friday = Saturday, ... but for WorkWeek, succ Friday = Monday.. I want to use the same 'Week' data type but have different instances.. not sure how to go about that
11:25:02 <Iceland_jack> adarq: There are some options, if you really want 'succ Friday = Monday' then you can create a newtype wrapper
11:25:44 <Iceland_jack> you could also do something like this but I don't think you should really
11:25:45 <Iceland_jack>     data Week = Weekday Weekday
11:25:45 <Iceland_jack>               | Weekend Weekend
11:26:16 <adarq> ah.. ya I figure the newtype decl would be better
11:26:20 <adarq> ok going to go figure that out, thanks alot
11:26:23 <Iceland_jack> I probably wouldn't use a newtype at all
11:26:32 <Iceland_jack> I would probably create a special function for getting the next weekday
11:26:48 <Iceland_jack> since 'succ' doesn't cycle
11:26:51 <Iceland_jack> > succ True
11:26:52 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
11:27:04 <adarq> o
11:27:08 <adarq> ya
11:27:19 <Iceland_jack> You can then define pattern synonyms for pattern matching on weekends
11:27:29 <adarq> I guess maybe I just wanted to try and get better with type classes/instances
11:27:31 <adarq> ya
11:27:34 <Iceland_jack>     pattern Weekend day <- (isWeekend -> Just day)
11:28:07 <Iceland_jack> that way the way you deconstruct the values are independent of the actual representation
11:28:21 <quchen> If you want a cyclic Enum instance, make sure your type isn't Bounded as well (since "succ maxBound -> error" is an Enum law).
11:28:39 <adarq> ya I was going to attempt to make it circular
11:28:40 <Iceland_jack> yes, I just think succ is a bad use for this
11:28:55 <Iceland_jack> adarq: I wrote a post some time ago and it has a similar example https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
11:29:07 <Iceland_jack> Only with dates
11:29:07 <adarq> cool, checking it
11:29:39 <Iceland_jack>     data Date = Date { month :: Int, day :: Int }
11:29:40 <Iceland_jack> and matching on it with
11:29:40 <Iceland_jack>     pattern January day = Date { month = 1, day = day }
11:30:12 <Iceland_jack> so you can define something silly like
11:30:12 <Iceland_jack>     firstMonth January{} = True
11:30:12 <Iceland_jack>     firstMonth _         = False
11:31:39 <adarq> havn't heard of PatternSynonyms until now
11:31:39 <adarq> nice
11:32:01 <Iceland_jack> It's kind of the final 'abstraction' barrier :)
11:33:17 <adarq> ya this is powerful, nice!@#!@
11:33:37 <adarq> i need to stay more 'in tune' with the language extensions per ghc release
11:34:01 <Iceland_jack> PatternSynonyms tends to be overlooked, that's why I wrote the post
11:37:39 * hackagebot unicoder 0.4.0 - Make writing in unicode easy.  http://hackage.haskell.org/package/unicoder-0.4.0 (ZankokuOkuno)
11:40:43 <merijn> Can anyone tell me what the most accurate/up-to-date description of the STG used by GHC is?
11:41:05 <merijn> I already read the original STG paper, I just wanna know what was changed/extended since then
11:42:10 <steffen> can someone please explain to me how I can get this to work? I understand the errormessage but I don't know how I should do it differently http://pastebin.com/74fLniGX
11:42:36 <steffen> I even tried to set the 0 in Line 3 to Int via (0 :: Int)
11:42:54 <steffen> but it won't let me compare on the second elem of the tuple
11:43:23 <steffen> Ohh, you need import Data.Ord I forgot that in the paste
11:43:39 <steffen> and Data.List -.-
11:43:42 <Iceland_jack> steffen: the type there is wrong right?
11:44:03 <Iceland_jack> Do you want help fixing that definition or help rewriting it to something more idiomatic?
11:44:35 <steffen> Iceland_jack:  both :)
11:44:58 <steffen> I want to understand first, how I can compare two tupels
11:45:05 <Iceland_jack> you can just do it normally
11:45:10 <Iceland_jack> > (2, 'a') < (2, 'b')
11:45:11 <lambdabot>  True
11:45:17 <Iceland_jack> but you shouldn't have to do that
11:45:28 <steffen> hmm
11:45:38 <Iceland_jack> does this look helpful?
11:45:38 <Iceland_jack> > group (sort "112221")
11:45:40 <lambdabot>  ["111","222"]
11:45:58 <Iceland_jack> > [ (head x, length x) | x <- group (sort "112221") ]
11:45:58 <steffen> haha, yes xD
11:45:59 <lambdabot>  [('1',3),('2',3)]
11:46:28 <steffen> group is awesome!
11:46:32 <steffen> that makes it a lot easier
11:46:48 <Iceland_jack> there are more efficient data structures for storing that, but we can ignore that for now
11:47:08 <Iceland_jack> to look up frequency we can do
11:47:09 <Iceland_jack> > lookup '1' [ (head x, length x) | x <- group (sort "112221") ]
11:47:10 <lambdabot>  Just 3
11:47:35 <Iceland_jack> of course, if you want to sort by frequency this is not necessary since there is a simpler way
11:47:36 <steffen> well what if the elements of the List are not in Ord
11:47:48 <Iceland_jack> then it won't work
11:47:49 <bms1> > [ (head x, length x) | x <- GHC.Exts.groupWith id "112221" ]
11:47:50 <lambdabot>  Not in scope: ‘GHC.Exts.groupWith’
11:48:31 <Iceland_jack> steffen: I'm guessing you want to have the most seldomly occurring elements first?
11:48:37 <steffen> yes
11:48:52 <Iceland_jack> so
11:48:52 <Iceland_jack>       sortByFreq [1,3,3,2,2,3]
11:48:52 <Iceland_jack>     = [1,2,2,3,3,3]
11:49:08 <steffen> and then group
11:49:10 <Iceland_jack> well can you imagine how we could do that with
11:49:11 <Iceland_jack> > group (sort [1,3,3,2,2,3])
11:49:12 <lambdabot>  can't find file: L.hs
11:49:14 <Iceland_jack> > group (sort [1,3,3,2,2,3])
11:49:15 <lambdabot>  [[1],[2,2],[3,3,3]]
11:49:34 <steffen> yes, that makes it a lot easier! Thanks I'll play with that
11:49:41 <Iceland_jack> > sortBy (comparing length) (group (sort "112232422"))
11:49:42 <lambdabot>  ["3","4","11","22222"]
11:49:59 <Iceland_jack> Since the length of each sublist is equal to the frequency
11:50:05 <Iceland_jack> you can just sort by the length
11:50:10 <Iceland_jack> and then concatenate the list
11:50:13 <Iceland_jack> > concat $ sortBy (comparing length) (group (sort "112232422"))
11:50:15 <lambdabot>  "341122222"
11:50:43 <steffen> yes, thats sweet
11:51:02 <Iceland_jack> so there is no need to build a frequency table
11:51:12 <Iceland_jack> but you can do that if you want to practice that as well
11:51:43 <steffen> right, so maybe you could shine some light on the error message and how to fix it, in this code as well :) http://pastebin.com/pAkXfbfc
11:52:11 <steffen> I did not include Ord a on purpose
11:52:19 <Iceland_jack> Why is that?
11:52:31 <Iceland_jack> 'comparing' requires Ord
11:52:37 <Iceland_jack> so you have to include it
11:53:36 <steffen> yes, but if I compare only on the snd of the tuple which is Num (I also tried with Int) I would like it to work as well, and the funny thing is, if I add Ord a at the top, it still won't work on the tuple I think
11:53:39 <Iceland_jack> let GHCi infer the type for you and work from there
11:54:36 <Iceland_jack> If you're in doubt that's the way to go
11:54:51 <steffen> xD, thakns, I should have done that in the first place
11:55:26 <Iceland_jack> 'sortF' also returns a list of tuples, while your function claims to return a list of any type in Eq
11:55:35 <steffen> I see it
11:55:43 <steffen> thanks
11:55:47 <Iceland_jack> np
12:36:28 <zq> erf
12:36:30 <zq> anyone around?
12:37:11 <mzero> a few of us
12:37:17 <mzero> wuz up?
12:37:45 <zq> hm
12:38:19 <zq> why can't lambda bindings be polymorphic in hindley milner?
12:40:13 <mzero> ah - well, that is something I don't know
12:40:16 <mzero> they can in Haskell
12:40:27 <zq> only with -XRank{2,N}Types
12:40:32 <mzero> true
12:40:33 <mzero> right
12:40:38 <mzero> uhm, so - no idea
12:40:40 <zq> wait never mind
12:40:44 <zq> i think i get it
12:40:56 <zq> polymorphic bindings make type inf undecideable i think
12:41:05 <mzero> :t \n -> n + 3
12:41:06 <lambdabot> Num a => a -> a
12:41:13 <mzero> that looks type polymorphic to me
12:41:17 <zq> it's not
12:41:21 <merijn> zq: Rank{2,N}Types make inference undecidable, yes
12:41:25 <zq> the Num a constraint kills it
12:41:35 <zq> :t \f -> (f True, f 0)
12:41:36 <lambdabot>     No instance for (Num Bool) arising from the literal ‘0’
12:41:36 <lambdabot>     In the first argument of ‘f’, namely ‘0’
12:41:36 <lambdabot>     In the expression: f 0
12:41:51 <mzero> oh - yes, er
12:42:03 <mzero> the binding in the lambda - not the binding of the lambda itself
12:42:45 <mzero> sure - in your example, how would the compiler have any clue which of several possible constraints is the right one to put on f
12:42:49 <merijn> :t let foo :: (a -> a) -> (b, c) -> (b, c); foo f (x, y) = (f x, f y) in foo -- this should choke
12:42:50 <lambdabot>     Couldn't match expected type ‘b1’ with actual type ‘a1’
12:42:51 <lambdabot>       ‘a1’ is a rigid type variable bound by
12:42:51 <lambdabot>            the type signature for foo :: (a1 -> a1) -> (b1, c1) -> (b1, c1)
12:43:06 <merijn> :t let foo :: (forall a . a -> a) -> (b, c) -> (b, c); foo f (x, y) = (f x, f y) in foo -- does lambdabot have RankN?
12:43:07 <lambdabot> (forall a. a -> a) -> (b, c) -> (b, c)
12:43:12 <merijn> tere we go :)
12:44:33 <zq> i can't get precisely why let-generalization doesn't impinge on decidability, though
12:45:03 <zq> since let x = e0 in e1 almost == (\x -> e1) e0
12:46:45 <bennofs> Could anyone help me with this paste? http://lpaste.net/107397
12:46:52 <merijn> zq: That's a good question, I have no clue :)
12:46:54 <bennofs> I'm trying to use recursion-schemes' para combinator, but as it seems, I need to do a pattern match that is non-exhaustive
12:47:16 <merijn> zq: Maybe try the mailing list/SO, since it seems all the type theory people are out drinking :p
12:47:17 <bennofs> Also, are there any problems with my definition of gcata'? Why wasn't gcata defined this way in recursion-schemes?
12:49:48 <quchen> let p = e1 in e0  ===  case e1 of ~p -> e0  ===  (\v -> case v of ~p -> e0) e1
12:49:53 <quchen> And now I'm stuck.
12:50:10 * quchen doesn't know the evaluation rule for the next step.
12:54:06 <bergmark> quchen: did you look at http://www.haskell.org/onlinereport/exps.html#case-semantics ?
12:55:08 <quchen> bergmark: Yes
12:55:37 <merijn> zq: Was asking about typing/type inference, though
12:55:57 <merijn> err, s/: W/ w/
12:56:00 <zq> what's "~p"?
12:56:07 <merijn> zq: Lazy pattern match
12:56:23 <quchen> Irrefutable pattern. Always matches until the pattern bindings are used, at which point the pattern has to be forced.
12:57:14 <mzero> I don't think I've ever used an irrefutable pattern in a program
12:57:52 <quchen> mzero: The Naive State Monad instance is actually the strict one because of this, for example.
12:58:23 <dolio> Is it?
13:00:17 <quchen> dolio: Lazy:
13:00:18 <quchen> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-State-Lazy.html#line-188
13:00:22 <quchen> Strict:
13:00:23 <quchen> http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-State-Strict.html#line-185
13:01:07 <dolio> Why is using let instead of case less naive?
13:02:21 <quchen> Hm?
13:02:46 * hackagebot peyotls 0.0.0.24 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.0.0.24 (YoshikuniJujo)
13:02:48 <dolio> (m >>= f) s = case m s of (a, s') -> f a s' -- strict
13:03:08 <dolio> (m >>= f) s = let (a, s') = m s in f a s' -- lazy
13:03:50 <dolio> Many old examples use the latter definition, giving them lazy state.
13:04:15 <quchen> dolio: That won't work for a transformer though (which I've linked), will it?
13:04:34 <dolio> It won't work if you want to write it exactly the way it's written in those files.
13:04:47 <dolio> Neither of those files is "naive".
13:05:33 <quchen> I don't think the word "naive" is the interesting part here.
13:07:22 <dolio> (m >>= f) s = m s >>= \p -> case p of (a, s') -> f a s' -- strict transformer
13:07:46 <dolio> (m >>= f) s = m s >>= \p -> let (a, s') = p in f a s' -- lazy transformer
13:07:47 * hackagebot engine-io 1.0.0 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.0.0 (OliverCharles)
13:08:46 <quchen> And with "let p = e1 in e0  ===  case e1 of ~p -> e0" we end up with what's in the file.
13:09:25 <quchen> It's more a choice of "let" vs "~" that makes the difference here.
13:09:46 <quchen> Or better, no difference. It makes the code look a bit different ;-)
13:12:47 * hackagebot engine-io-snap 1.0.0 -   http://hackage.haskell.org/package/engine-io-snap-1.0.0 (OliverCharles)
13:14:22 <dolio> I just don't necessarily think it's correct to characterize the case version as the first one you'd come up with.
13:14:38 <dolio> Because the .Strict version is, if I remember correctly, a later addition to the library.
13:14:44 <quchen> OK.
13:22:50 * hackagebot scientific 0.3.3.0 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.0 (BasVanDijk)
13:38:22 <lambdafan> I'm trying to install system-filepath and get the following error "/usr/bin/ld: cannot find -lHStext-1.1.1.3-ghc7.8.3". Any ideas on why this is happening and how to fix?
13:42:30 <lambdafan> it seems I don't have HStext-1.1.1.3-ghc7.8.3 installed. I did install text, any idea where the problem lies?
13:42:56 <jle`> lambdafan: do you have the right ghc in path?
13:49:39 <lambdafan> jle: ah, I will check that
13:55:24 <lambdafan> jle` : I removed the old ghc, and re-installed text. I still get the same error
13:55:52 <lambdafan> jle`: I also made sure $HOME/.cabal/lib was in my $PATH
13:56:29 <bergmark> lib doesn't need to be in your path
13:58:09 <bergmark> lambdafan: did you try installing text+system-filepath in a sandbox?
13:58:27 <lambdafan> bergmark: good idea I will try that now
13:58:45 <bergmark> make sure to list text explicitly so it doesn't reuse the user installed one
14:02:43 <joof> Looking at glfw-b and in the data declarations types are often listed with a ! in front: !Int
14:02:46 <joof> what does that mean?
14:02:54 * hackagebot socket-io 1.0.0 -   http://hackage.haskell.org/package/socket-io-1.0.0 (OliverCharles)
14:03:00 <ski> strict data constructor argument
14:03:15 <ski> @src Complex
14:03:15 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:03:36 <ski> means `a :+ b' is strict in both `a' and `b'
14:04:01 <bergmark> ocharles: you should add a synopsis :3
14:04:50 <joof> thanks
14:12:42 <stolaruk> (TMVar newbie question) Could someone look over this simple and impractical example of using TMVar and let me know what improvements might be made?
14:12:49 <stolaruk> http://lpaste.net/107410
14:12:56 * hackagebot safe 0.3.6 - Library of safe (exception free) functions  http://hackage.haskell.org/package/safe-0.3.6 (NeilMitchell)
14:13:53 <stolaruk> It is doing what I expect it to do. Just want to know if I'm on the right track.
14:23:58 <jle`> any way to use guards in lambdas?
14:24:54 <geekosaur> not directly, but guards desugar to case anyway
14:25:07 <geekosaur> there's also lambdacase extension
14:26:36 <jle`> ah yeah, thanks.
14:37:46 <lambdafan> bergmark: Instlling in a sandbox seems to be working fine.
14:50:31 <albeit> Using msyql-simple, I am trying to extract a MySQL type of "Date", but every type I try in Haskell to extract it to says it is incompatible. How can I retrieve a Date field?
15:03:23 <ezl> i'm trying to install scotty with cabal and getting "Unsupported extension: LambdaCase" -- can someone point me in the right direction?
15:04:24 <jle`> ezl: what GHC are you using?
15:06:44 <ezl> jle`: 7.4.1
15:07:14 <ezl> (I should mention I'm super green.  just finished going through "learn me a haskell" and looking at a scotty tutorial online)
15:07:39 <jle`> ezl: how did you acquire it?
15:07:45 <MP2E> 7.4.1 is preeeeeetty old :V
15:07:52 <jle`> have you considered using the Haskell Platform?
15:08:05 <jle`> LambdaCase arrived in 7.6.1
15:08:06 <Iceland_jack> ezl: LambdaCase appeared around GHC 7.6 I think so your version is too old
15:08:28 <ezl> jle`: Iceland_jack: I see. Sounds like I need to upgrade that :)
15:08:39 <jle`> the haskell platform should give you 7.6.3 i believe :)
15:08:43 <Iceland_jack> It's a bit unfortunate though since it's purely a syntactic extension
15:09:18 <jle`> yeah, it's a shame...it really shouldn't matter
15:09:20 <jle`> sigh
15:09:31 <ezl> somebody (maybe me) should create a website so when people google for "Unsupported extension: LambdaCase"
15:09:42 <ezl> it says that 7.6.1 is what you need
15:09:43 <ezl> :)
15:10:02 <ezl> thanks for your fast help Iceland_jack and jle`
15:10:04 <Iceland_jack> ezl: if you're feeling adventurous you can remove the LambdaCase from the source
15:10:53 <jle`> ezl: it's actually the first google hit when you search for LambdaCase i think :)
15:11:08 <jle`> @google LambdaCase
15:11:10 <lambdabot> http://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/
15:11:10 <lambdabot> Title: Lambda-case and multi-way if added to GHC head (for 7.6.1) : haskell
15:11:13 <jle`> but don't let that discourage you from blogging about it :)
15:11:26 <kqr> which is the normal library if you want a head :: [a] -> Maybe a?
15:11:54 <jle`> kqr: base
15:12:04 <jle`> oh
15:12:10 <jle`> if you want to replace Prelude's head with that?
15:12:11 <Iceland_jack> @hoogle [a] -> Maybe a
15:12:11 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:12:12 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:12:12 <lambdabot> Prelude head :: [a] -> a
15:12:18 <Iceland_jack> kqr: Do you need a library? Is it possible to pattern match or use a different function to do the same
15:12:19 <Adeon> I thought multiwayif and lambdacase were way older than 7.6
15:12:31 <Iceland_jack> > listToMaybe [1,2,3,4]
15:12:32 <lambdabot>  Just 1
15:12:33 <Iceland_jack> > listToMaybe []
15:12:35 <lambdabot>  Nothing
15:13:46 <ezl> jle`: I did, the plain "LambdaCase" query got a bunch of results that I didn't know how to quickly interpret. "Unsupported extension: LambdaCase" returned this: https://i.imgur.com/efE60j6.png
15:13:48 <kqr> Iceland_jack, actually, i might just write my own function because i realised it's not quite head i want
15:13:50 <kqr> Iceland_jack, thanks!
15:14:35 <Iceland_jack> kqr: I'm interested in what you're doing, there might be an existing function that does what you what :)
15:14:43 <Iceland_jack> *want
15:14:58 <kqr> Iceland_jack, i want to check whether a list can be accurately represented with a Maybe
15:15:02 <ezl> jle`: i think newbs like me are probably afraid of reading a long post about the entire history of LambdaCase (and uncertain that it will resolve our problems, or concerned that we may not have enough context to understand it fully)
15:15:16 <kqr> Iceland_jack, or rather, if the list consists of one and only one element make it to a Just hd, otherwise Nothing
15:15:49 <Iceland_jack> kqr: Fair enough but I'm interesting in where you want to use that function, this might be an XY problem
15:15:58 <Iceland_jack> *interested
15:15:59 <kqr> Iceland_jack, ah right
15:16:52 <kqr> Iceland_jack, i query a database and get a list of rows back. i expect only one row during normal execution of my application – if it gives me less someone put in an incorrect id, if it gives me more the id is not unique which it should be according to the schema
15:17:19 <kqr> (maybe schema is the wrong word but you get what i mean, i think)
15:17:45 <jle`> ezl: huh that's funny.  on my google and the lambdabot google the first result is "LambdaCase added in 7.6.1"
15:18:00 <jle`> ezl: maybe google isn't too consistent a source
15:18:44 <nezt> haskell vs clojure
15:19:02 <Iceland_jack> kqr: It's not impossible that the library you're using has a function like that, but listToMaybe isn't a bad solution to that
15:19:27 <kqr> Iceland_jack, the problem with listtomaybe is that it'll just silently ignore a longer list
15:19:37 <Iceland_jack> Yes that's right
15:20:22 <kqr> but maybe that's not too bad anyway
15:20:26 <jle`> kqr: you can check for null (drop 1)
15:20:30 <kqr> the list can only be longer if an ID is reused
15:20:32 <jle`> hm.
15:20:40 <kqr> which the database should ensure it isn't
15:22:05 <albeit> Any recommendations for a package to do multivariate linear regressions?
15:22:10 <ezl> jle`: localization i guess.  for me the first 5 aren't that clear.
15:22:20 <jle`> > let f = liftA2 (*>) listToMaybe (guard . null . drop1) in f [1,2,3]
15:22:21 <lambdabot>  Not in scope: ‘drop1’
15:22:21 <lambdabot>  Perhaps you meant one of these:
15:22:21 <lambdabot>    ‘drop’ (imported from Data.List),
15:22:21 <lambdabot>    ‘Seq.drop’ (imported from Data.Sequence),
15:22:22 <lambdabot>    ‘BSLC.drop’ (imported from Data.ByteString.Lazy.Char8)
15:22:26 <jle`> > let f = liftA2 (*>) listToMaybe (guard . null . drop 1) in f [1,2,3]
15:22:27 <lambdabot>  Nothing
15:22:31 <jle`> > let f = liftA2 (*>) listToMaybe (guard . null . drop 1) in f [1]
15:22:32 <ezl> also, apparently this is my hint that i shouldn't be on ubuntu 12.04 anymore... since haskell-platform for 12.04 ships with 7.4.1 :)
15:22:33 <lambdabot>  Just ()
15:22:55 <jle`> oops it should be (<*) or flipped.
15:22:56 <kqr> Iceland_jack, in the end, i went with a "single :: e -> e -> [a] -> Either e a" which does a case analysis on the list
15:23:13 <kqr> Iceland_jack, i think that reflects my usage best
15:23:23 <jle`> ezl: ah :)  yeah that would do it.  also, ubuntu 12.04 is fine; you just shouldn't rely on your package managers for haskell stuff :)
15:23:45 <jle`> > let f = liftA2 (*>) (guard . null . drop 1) listToMaybe in f [1]
15:23:47 <lambdabot>  Just 1
15:23:50 <jle`> > let f = liftA2 (*>) (guard . null . drop 1) listToMaybe in f []
15:23:51 <lambdabot>  Nothing
15:24:09 <jle`> ...you probably shouldn't do that in real life
15:24:49 <kqr> ezl, install a newer haskell platform through cabal
15:24:57 <kqr> ezl, and if you need to, a newer ghc from sources
15:25:04 <kqr> ezl, i run ubuntu 12.04 and it's okay
15:25:22 <kqr> jle`, hehe, i'm still trying to understand how it works
15:25:53 <jle`> kqr: it's the same as f xs = guard (null (drop 1 xs)) >> listToMaybe xs, if that helps
15:26:09 <kqr> jle`, that does help, yeah
15:26:34 <kqr> jle`, you could substitute >> for *> in that implementation too, right?
15:26:54 <kqr> jle`, ah, right, the applicative instance is just Reader?
15:26:56 <jle`> kqr: you can, but guard is implemented in terms of Monad for historical reasons, and people are more used to seeing guard in the context of Monad
15:27:15 <kqr> jle`, (in the case of liftA2 anyway)
15:27:15 <ski> @type GHC.Exts.the
15:27:16 <lambdabot> Eq a => [a] -> a
15:27:53 <jle`> kqr: yeah, or well, (->) [a].  it runs both functions "in parallel" and then uses (*>) on the result.
15:28:01 <jle`> it's a bit confusing i guess cause it uses two different Applicative instances >_>
15:28:33 <jle`> there should probably be some liftA2 specialized for (->) a in Data.Function actually.  i mean, there's `on` and stuff
15:28:55 <jle`> but i guess why bother
15:29:24 <kqr> haha yeah, the two different instances really threw me for a loop
15:29:29 <kqr> it was way simpler than I at first thought
15:29:32 <jle`> yeah, should have used (>>), sorry :)
15:29:45 <jle`> i really wish there was a nicer way to do that though than liftA2
15:29:52 <kqr> idiom brackets? :(
15:29:59 <jle`> or ff <$> f <*> g
15:30:24 <jle`> f = (>>) <$> (guard . null . drop 1) <*> listToMaybe
15:30:26 <jle`> heh.
15:30:50 <kqr> i prefer the liftA* functions when it's an operator i'm lifting
15:31:02 <kqr> though you could drop the parens in that latter version if you really wanted to make it hard to parse at a glance
15:31:12 <jle`> a specialized `over` in Data.Function might help; over f g h x = f (g x) (h x).  a different name of course because lens owns over
15:31:27 <jle`> but over = liftA2
15:31:57 <kqr> yeah
15:32:06 <jle`> but we have ord and chr in Data.Char
15:32:13 <jle`> and we have map in Prelude
15:32:14 <kqr> i think idiom brackets would be the cleanest solution
15:32:19 <kqr> but it would also require more syntax
15:32:30 <jle`> the cleanest solution in this case might just be the pointful version
15:32:37 <kqr> or that, yeah
15:33:09 <jle`> but idk sometimes i dream.  this is a very common pattern ... f (g x) (h x).  if there was an idiomatic abstraction to handle it that is instantly readable to new people, i would be very happy
15:33:22 <jle`> for now i use liftA2
15:33:23 <kqr> but (| guard . null . drop 1 >> listToMaybe |) isn't too bad either, if only it worked
15:33:43 <jle`> i guess not :)
15:34:00 <jle`> but last thing we need is adding more syntax to haskell ;)
15:34:34 <Iceland_jack> jle`: I dunno, I would vote for something like idiom brackets
15:35:17 <kqr> since we have do notation already, i don't think the step to idiom brackets is too big
15:35:20 <jle`> i mean, the previous kerffuffle with ezl is a bit of a case in point isn't it?
15:35:24 <kqr> applicatives need more love
15:35:33 <jle`> and i have friends that say that haskell has way too much syntax
15:35:38 <pjdelport> idiom brackets would be awesome
15:35:55 <kqr> people who say haskell has way too much syntax usually don't know what they're talking about
15:35:56 <ezl> kqr: installed new ghc instead of a new haskell platform, now have 7.6! #smallvictories
15:36:08 <jle`> ezl: congrats :)
15:36:08 <kqr> they're really complaining about library-defined operators
15:36:09 <Guest44541> way too much syntax? compared to prolog or lisp :)?
15:36:21 <jle`> kqr: i think my friends usually mean syntax
15:36:44 <Zekka> Personally, I'm hoping we could get sugar along these lines: (!x + y) ==> x >>= \x' -> x + y
15:36:46 <Iceland_jack> jle`: Maybe a nice middle point would be to include [i| ... |] where 'i' acts as idiom brackets :) but invoking TH is a bit crazy for that
15:36:51 <kqr> jle`, then i'm impressed by your friends! mine tend to refer to things like ($) (.) and such
15:36:58 <Philonous> It's a shame liskell died
15:36:58 <Zekka> er, x >>= \x' -> x' + y
15:37:06 <ski> idiom brackets are too weak, imo
15:37:21 <kqr> ezl, yay!
15:37:25 <Zekka> I have a lot of friends who just endlessly complain that Haskell looks ugly to them, without saying too muchc specific
15:37:27 <ski> Philonous, *nod*
15:37:31 <kqr> ezl, with the platform you have you also got cabal
15:37:37 <kqr> ezl, cabal update && cabal install haskell-platform
15:37:40 * yogurt_truck loves idiom brackets
15:37:42 <kqr> ezl, and you get a newer version of that too!
15:38:02 <Zekka> With idiom brackets and the syntax I'm describing, I'm worried equational reasoning would be harder, mind
15:38:14 <jle`> haskell syntax is really only easy to bear if you learn it incrementally
15:38:22 <jle`> but if you step back and look at it all at once
15:38:24 <jle`> w o w
15:38:33 <kqr> it's not that bad
15:38:37 <Iceland_jack> Idris also has this relatively new syntax for lifting expressions? That would solve the awkward problem of using monadic values in case…of/if…then…else/...
15:38:40 <yogurt_truck> Zekka: that's just the unfamilliar==ugly/bad/silly/evil/etc kinda people. they are difficult to deal with.
15:38:42 <kqr> i tried to compile a minimum you need to create most of the standard libraries
15:38:43 <Zekka> I almost feel like it would be easiest to read Haskell if it had (function arg) application
15:38:45 <kqr> it was like 20 keywords
15:38:52 <Iceland_jack>     case !fileExists of
15:38:52 <Iceland_jack>       ...
15:38:54 <ski> Zekka : hehe, my monadic reflection idea is a bit like that ..
15:38:55 <Zekka> er, only that
15:39:01 <nezt> i don't think haskell's syntax alone is worse than other langs, just that we're used to other langs
15:39:02 <nezt> maybe i'm wrong
15:39:03 <Zekka> As opposed to infix operators, infix functions, etc.
15:39:03 <kqr> Zekka, as in no operators?
15:39:24 <kqr> Zekka, yeah, that's a big problem for beginners... but also a big benefit to more experienced users
15:39:25 <Zekka> kqr: Yeah, and eliminating a few things like comprehensions
15:39:32 <Zekka> It's a tradeoff really
15:39:39 <jle`> lambdacase, multiway if, proc notation
15:39:40 <ski> Zekka : you need a delimiting operator
15:39:54 <qwebirc58068> is there a safe way to get the type 'a' from a function (a->b) in order to run typeOf (proxy/tagged)?
15:39:55 <Zekka> there's kinds of things that are intuitively  easier to read using operators (code using associative functions, often), but the downside is that it's harder to do algebra on
15:40:15 <Zekka> there's a reason @pl is nontrivial
15:40:21 <jle`> pattern synonyms
15:40:24 <jle`> view patterns
15:40:34 <jle`> rankntypes
15:40:37 <kqr> jle`, aren't most of those ghc extensions?
15:40:42 <jle`> do rec
15:40:51 <jle`> kqr: yeah, i guess i mean, modern haskell syntax ;)
15:40:59 <jle`> which would be the case, if we were considering adding idiom brackets
15:41:04 <Zekka> I'd be curious about a Haskell alternative that not only does what I'm describing but requires you to hide caseof expressions and such behind functions so that having an obvious way to algebra about things is a basic requirement
15:41:18 <tgeeky> SHE has idiom brackets (though I don't like them much)
15:41:21 <Zekka> I think certain code would become very ugly but I think it would be very easy to make substitutions
15:41:32 <jle`> parallel list comprehensions, postfix operators, record puns, record wildcards
15:41:44 <Zekka> Maybe we just need to start programming our editors to automatically rewrite code in that form when we hit the right button
15:41:49 <ski> allowing `case' in patterns might be fun
15:41:54 <Zekka> IDE-only languages are pretty popular nowadays anyway
15:42:22 <ski> Zekka : i suppose you know Agda2 doesn't have `case'
15:42:27 <tgeeky> Zekka: yes; but then distributing source code is incomplete without attaching the IDE with it :(
15:42:39 <Zekka> so, you hit the right key combo and [x * y | x <- xs, y <- ys] -- presto, it's now (*) <$> xs <*> ys
15:42:42 <Zekka> ski: Actually, I didn't
15:42:48 <Zekka> I've only used Agda once or twice
15:42:51 <ski> (Agda1 did, though)
15:43:00 <Guest44541> hm, that's interesting
15:43:13 <Guest44541> zekka: maybe it would be nice to collect a list of these patterns?
15:43:16 <ski> Zekka : it has an interesting "extra argument matching" thing that you can use instead
15:43:18 <Zekka> tgeeky: Not necessarily: I mean, you can read Java without having Eclipse installed
15:43:22 <Zekka> It's just hard to refactor it
15:43:39 <Zekka> Guest44541: Haskell already has some rewrite rules of this kind built-in, I think: I think a nice starting point would be grabbing those
15:43:57 <Zekka> (stuff like do notation, sections, comprehensions, enumerations, etc.)
15:44:10 <ski> they're basically macros
15:44:19 <Zekka> Yeah, except you can't define your own
15:44:37 <Guest44541> zekka: that sounds cool. i think it would be nice for beginners (like me) to maybe have IDE support
15:44:40 <Zekka> So you'd basically just have macro expansion shortcuts for your IDE
15:44:44 <Guest44541> for refactorings
15:45:09 <Guest44541> this could probably make it also easier to dive into the more "abstract" concepts
15:45:23 <Zekka> I don't really like how thought-intensive it is to write relatively simple i.e. monadic code even though I like code that's easy to factor out
15:45:23 <Guest44541> to be honest, i would have never thought about the equivalence you mentioned
15:45:27 <kqr> Guest44541, have you checked out hlint?
15:45:28 <ski> macros should be hygienic, at least by default
15:45:34 <kqr> Guest44541, it tells you about some of those rewrites you can do
15:45:38 <Guest44541> cool
15:45:45 <gigamonkey> Anyone here know anything about this cabal issue https://github.com/haskell/cabal/issues/1836 ?
15:45:50 <ski> (though syntax parameters could perhaps be a viable alternative to some unhygiene)
15:45:51 <Guest44541> thanks for the hint, kqr
15:46:09 <Zekka> i.e. with my example abovem where (!x + y) becomes x >>= \x' -> x' + y, there's an obvious systematic conversion, but it's not idiomatic
15:46:16 <Zekka> The idiomatic thing to do is to partially apply (+)
15:46:17 <kqr> Guest44541, just cabal install hlint, and then run hlint yourcode.hs and it will throw loads of advice at you
15:46:20 <gigamonkey> Hmmm. Maybe I had an old ~/.cabal/ lying around.
15:46:23 <Zekka> which gets you x >>= (+y)
15:46:29 <Guest44541> I'll do that, thank you, kqr :)
15:46:33 <ski> Zekka : "idiomatic" in the sense of "applicative functor"
15:46:36 <Zekka> So writing code that's usually trivial quickly becomes a thought exercise
15:46:39 <Zekka> ski: No, not that sense
15:46:50 <ski> <ski> Zekka : you need a delimiting operator
15:46:50 <Zekka> Also, I just realized that my example doesn't make sense
15:46:58 <Zekka> it should be x <$> (+y)
15:47:06 <Zekka> er, (+y) <$> x
15:47:11 <kqr> yeah other way around
15:47:11 <Zekka> someone take away my Haskell license
15:47:20 <jle`> Zekka: you still have a few strikes left, don't worry
15:47:25 <kqr> you can keep your license
15:47:28 <ski> Zekka : that would be a side-effect
15:47:31 <kqr> the compiler is there to catch those kinds of mistakes anyway
15:47:39 <Zekka> But anyway, my point's that it shouldn't take that much algebra to write simple expressions, even though it shouldn't happen by magic
15:48:09 <Zekka> So I think that giving a simple, consistent way to mark 'I want you to handle functor/applicative/monadic side effects here' and have Haskell do the rewriting itself would generally be a good idea
15:48:18 <Zekka> because there's usually only one way to do it that makes sense and won't cheese off the typechecker
15:48:41 <kqr> i've said it before but i'll say it again: why have i only discovered monad transformers a few days ago!? they're frickin' amazing!
15:49:10 <ski> Zekka : i wouldn't be happy with any kind of search for it
15:49:24 <Zekka> ski: I can think of a few specific cases of ambiguity
15:49:42 <Zekka> i.e., if your function is a -> m b, how does Haskell know whether you want an m (m b) or an m b?
15:49:49 <ski> it doesn't
15:50:06 <Zekka> I think you could probably go a large part of the way by seeing what the rest of the code expects, but it's pretty dangerous to go with solutions that don't work in *all* cases
15:50:15 <ski> yes
15:50:26 <geardev> https://pastee.org/wunab
15:50:35 <geardev> What is wrong with line 4?
15:50:43 <geardev> I think line 3 is fine
15:50:58 <ski> Zekka : in my syntax, it's be something like `<{x} + y>' (concrete syntax not decided)
15:51:01 <Zekka> Guest44541: Try fmapping id over something
15:51:08 <Zekka> fmap id [1] == [1, 1]
15:51:09 <jle`> geardev: as in, compile errors?
15:51:16 <Zekka> So, fmap id xs /= xs
15:51:18 <Zekka> which is evil
15:51:24 <jle`> it's an unlawful Functor
15:51:25 <Zekka> ski: How does it deal with the case I'm describing?
15:51:26 <jle`> if that's what you're asking
15:51:37 <Zekka> Because I like the idea expressed by that notation
15:51:56 <kqr> geardev, a functor is not supposed to change the "shape" of the thing it's mapping over. so if you have a list of 5 elements, it should be a list of 5 elements when you've run fmap on it too
15:51:59 <ski> geardev : fails the functor laws
15:52:14 <Zekka> Basically, fmap id x should always equal x
15:52:15 <pjdelport> let (·) = (<*>) in f·x·y·z
15:52:24 <ski> Zekka : which case are you thinking about ?
15:52:29 <pjdelport> Maybe a better operator is all that's needed.
15:52:42 <kqr> geardev, this follows from the two "functor laws" (there's really only one, but it's often given in two forms to make it more clear what it means)
15:52:57 <Zekka> ski: Basically, I still feel like even though it limits the region of the code inw hich Haskell can do magic rewriting, I'm still not sure how Haskell would determine if the result should be m (m b) or m b
15:53:11 <Zekka> It seems like you still have to treat everything in those cases as overloaded to maybe produce a contextual value, maybe not, we don't know!
15:53:28 <kqr> geardev, the reason functors have laws is that it allows us to feel more safe when we think about our code. we can just assume that an fmap won't change the shape of a list, for example, which is useful when optimizing and refactoring a program
15:53:28 <jle`> sounds like swit's option chaining, it always collapses it down to m b
15:53:33 <ski> Zekka : no need to determine with my system. either the code is right, or it isn't. it doesn't try to guess what you meant
15:53:50 <Zekka> ski: Then I think there's something I don't understand about your system
15:53:58 <Zekka> Suppose f is a -> m b and x is m a
15:54:07 <Zekka> <f {x}>
15:54:24 <Zekka> How does it know whether to bind (getting m b) or fmap (getting m (m b))?
15:54:30 <merijn> Can anyone tell me what the most accurate/up-to-date description of the STG used by GHC is?
15:54:35 <ski> it doesn't
15:54:45 <ski> that would always correspond to `fmap'
15:55:04 <Zekka> Would <{f} {x}> correspond to <*>?
15:55:07 <ski> yes
15:55:33 <Zekka> Alright, and if you wanted to bind would you just write join <f {x}>?
15:55:36 <geardev> kqr, ski, jle`: oh i see, it's applying some function to the first element which prepends both results to the resulting list, changing the shape of of the thing being mapped over
15:55:39 <geardev> is this correct?
15:55:48 <ski> and `<let x = {m} in {f x}' would be equal to `do x <- m; f x'
15:55:57 <ski> er, `<let x = {m} in {f x}>'
15:56:18 <Zekka> It's less powerful than mine but it doesn't seem to introduc ambiguity, so it seems pretty alright I guess
15:56:27 <geardev> kqr, ski, jle`: so you mapped (+1) onto [1,2,3], that function really would return [2, 2, 3, 4] instead of the expected [2, 3, 4]
15:56:38 <Zekka> Why not <{f {x}}>?
15:56:42 <ski> Zekka : less powerful in which sense ?
15:56:43 <jle`> geardev: actually it would return [2,2,3,3,4,4]
15:56:59 <geardev> jle`: ah, i see
15:57:04 <Zekka> ski: It's actually equivalent -- you can express the same things -- but syntactically much more dense.
15:57:16 <geardev> kqr, ski, jle`: thank you for your responses
15:57:17 <jle`> geardev: but also, what being different than what you "expect" is one thing, but the deeper issue is that it doens't obey the Functor laws
15:57:28 <jle`> geardev: if you never saw fmap for list, you wouldn't know what to "expect"
15:57:29 <geardev> jle`: noted
15:57:36 <jle`> geardev: have you learned about Monad?
15:57:36 <Zekka> The reason you don't 'expect' that on a deeper level is the functor laws
15:57:53 <Zekka> basically, if your functor doesn't guarantee that fmap id x == x then it's evil
15:58:14 <ski> Zekka : `<{f {x}}>' would (by law) be equal to `f {x}' in my system, which doesn't make sense on its own (outside a `<...>')
15:58:23 <jle`> you might also one day be writing code that's parametric on all Functors, Functor f => .....  or you might want to "say general things" about the nature of all Functors
15:58:39 <jle`> but your ability to write parametric code, or make statements about how all Functors behave, is basedon the assumption that they are lawful functors
15:58:45 <Zekka> ski: Does it introduce ambiguity, though?
15:58:51 <Guest44541> geardev: where did you get that example? curios to see more of them, to solve them for myself
15:58:55 <jle`> it's like an Eq instance where everything is not equal to eachother
15:59:01 <jle`> including itself
15:59:23 <ski> geardev : we want `forall g f x. fmap g (fmap f x) = fmap (g . f) x'
15:59:26 <Zekka> You're right that it's an extension and not a natural consequence of your rules (which is pretty obvious -- there's no way to rewrite it without introducing monad operations), but offhand I don't see how nesting would introduce ambiguity
15:59:30 <jle`> you can "say things" about equality, and use functions that take advantage of equality (that is, they have type signatures Eq a => ..., and work over all Eq stuff
15:59:31 <geardev> Guest44541: http://www.haskell.org/haskellwiki/Typeclassopedia
15:59:33 <Zekka> so it seems like a reasonable extension
15:59:37 <Guest44541> thanks :)
15:59:37 <ski> Zekka : does what introduce ambiguity ?
15:59:39 <geardev> jle`: I have
15:59:46 <geardev> jle`: I have learned about monad
15:59:47 <Zekka> ski: Allowing <{f {x}}>
15:59:54 <jle`> geardev: but those functions that use Eq instances all are only "well behaved" if the Eq instances ar emeaningful
15:59:58 <ski> Zekka : in the way you're suggesting, i think it does
16:00:21 <jle`> for example, many functions using an Eq instance that are normalyl fine will start becoming completely unpredictable or wrong if given a not-so-meaningful Eq instance
16:00:25 <jle`> same for Functor
16:00:33 <Zekka> Hm, would it be because order of binding may not be guaranteed?
16:00:45 <ski> Zekka : it might be sensible to add a "level smashing" operation, but i think it would have to be different from my `{...}' reflection operator
16:01:00 <jle`> geardev: you can implement fmap in terms of bind and return; fmap f x = x >>= (\y -> return (f y))
16:01:08 <jle`> geardev: but for your Functor instance, this is not the case
16:01:09 <Zekka> i.e. <{f {getLine} {getLine}}> doesn't clearly indicate which getLine is evaluated first?
16:01:12 <jle`> fmap /= liftM
16:01:27 <jle`> @src liftM
16:01:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:01:51 <Zekka> ski: I'm thinking it might be better just to make people explicitly join
16:01:51 <jle`> i believe that for any lawful Monad, liftM should be identical to the lawful Functor instance
16:01:56 <jle`> so you can use them interchangeably
16:02:11 <jle`> that's because we can "say things" about the Functor instance
16:02:12 <ski> Zekka : maybe. though i like my `let' (and `case') translation
16:02:14 <Zekka> so it becomes <join (f {x})>
16:02:18 <jle`> but if you throw away the Functor laws...you can't really say anything anymore :)
16:02:25 <Zekka> It's a little less verbose and still gets the point across
16:02:41 <TheKing444> jle` including code optimization
16:02:49 <jle`> same for Applicative, liftA f x = pure f <*> x
16:03:04 <ski> Zekka : anyway, this is an idea i've pondered on and off for some years now :)
16:03:04 <jle`> liftA for lawful Applicatives should be identical in result to fmap
16:03:16 <jle`> and i think you can prove it using the Applicative laws
16:03:35 <TheKing444> > unsafePerformIO $ putStrLn "Yolo"
16:03:35 <jle`> yeah, you can
16:03:36 <lambdabot>  Not in scope: ‘unsafePerformIO’
16:03:45 <Zekka> ski: I've been doing a little drafting for a very syntactic Haskell-like language off-and-on without really expecting to write it, and syntax that does something along these lines is something I've been tossing around
16:03:46 <TheKing444> ah man, they did @undefine
16:03:50 <jle`> it's actually the first Applicative law heh
16:04:02 <Zekka> I may steal your idea in full
16:04:20 <ski> Zekka : iirc, the handling of lambdas is a bit subtle
16:04:44 <Zekka> "very syntactic" as in "introducing syntax for a lot of common usages so it's harder to do algebra on code, but it's more familiar and consistent"
16:04:50 <ski> Zekka : i'd like to extend the idea nicely to monad transformers, but that hasn't happened yet
16:05:11 * ski wants more algebra, not less
16:05:23 <Zekka> given that the way Haskell's nonuniform and you have to think a lot about things that are second-nature, I think, turn people away a lot
16:05:46 <TheKing444> Zekka, what is nonuniform?
16:06:05 <Zekka> TheKing444: Let's say I want to write effectful code
16:06:18 <jle`> geardev: you will eventually gain an intuition when using Functor :)  and the functor laws ensure that when you encounter a new Functor, your intuition still applies
16:06:19 <Zekka> I want a couple capabilities, expressed through monad transformers
16:06:23 <jle`> same for Eq, etc.
16:06:25 <ski> Zekka : lately i've been pondering a variant/spinoff where i name "structure levels" with variables
16:06:45 <TheKing444> And monad type classes.
16:06:50 <Zekka> There are a few common ways to do this that work basically as they expect, but let's say I've run up against a problem
16:06:51 <TheKing444> Those things are the way to go.
16:06:58 <Zekka> TheKing444: If I'm using MTL! What if I'm using mmorph?
16:07:04 <Zekka> Well, that's not actually the question at stake
16:07:24 <TheKing444> Oh, those are cool too.
16:07:34 <Zekka> I'll work a little with MTL though
16:07:46 <Zekka> So I'm using MTL's cool typeclasses for all kinds of fancy lifting and not really thinking too much about it
16:07:49 <ski> Zekka : so that i can say `sum (l0,sum (l1,n)) = sum (concat (l0,l1),n)' to express what is usually expressed like `sum . map sum = sum . concat'
16:08:01 <Zekka> All of a sudden I want to introduce another layer of State and -- oh no, the fundep won't let me!
16:08:09 <TheKing444> Ah
16:08:15 <Zekka> So all of a sudden I have a problem -- it's not insurmountable, and oftentimes it's not even that hard
16:08:29 <ski> Zekka : yeah, that's annoying
16:08:29 <TheKing444> yeah
16:08:34 <Zekka> But I mean that when writing Haskell you often come across interesting situations that require you to think very hard and the solution isn't always the same each time you encounter them
16:08:49 <Zekka> The problem Ski's solving is another example of this
16:08:57 <ski> it is ?
16:09:00 <Zekka> there are a *lot* of ways to tie loose ends together on values inside varying levels of context
16:09:16 <Zekka> There's also a lot of ways to basically say 'I want to compose these operations'
16:09:35 <Zekka> If you want to compose two effectful operations, for instance, you do it differently from composing a pure operation and an effectful one, and you  do that differently from composing the two in the other order
16:09:50 <ski> smarter effect handling that knows `State s0 . State s1 = State (s0,s1)' would be nice
16:10:03 <ski> i think with labelled effects, one could perhaps get that
16:10:12 <Zekka> I'd almost call these situations leaky abstractions, because they restrain you from thinking in terms as high-level as 'and now I want to compose these things'
16:10:18 <ski> (that's another thing i've been pondering on and off)
16:10:42 <Zekka> you can't *generally* compose two transformers, or two operations, without acknowledging lots of extra properties of them
16:11:16 <ski> but it's harder without something like functors or idioms or monads
16:11:32 <Zekka> And that's better than taking the standard imperative route of treating all effects and all operations as basically the same -- go ahead and compose them, we don't care if you launch missiles -- I think this has its own drawbacks
16:11:50 <ski> the extra stuff means that some algebraic manipulations (assuming a lean syntax) would fail
16:12:03 <zq> is there pointful form of record update?
16:12:12 <ski> part of the point of my syntax is to remind people of what refactorings are valid
16:12:33 <ski> zq : `myRec {x = newX}' ?
16:13:04 <Zekka> I think he wants a function \myRec newX -> myRec {x = newX}, without explicitly defining it
16:13:35 <ski> Zekka : another point is that with the standard imperative route, you basically assume a fixed order of layering of the effects. being explicit means you can be more flexible with that
16:13:54 <Zekka> ski: I think it's better to be explicit: I'm not arguing that I like the imperative route more
16:13:55 <ski> zq wanted something pointful, not something pointless
16:14:05 <zq> ski: uh, pointless, maybe?
16:14:11 <zq> i think i meant pointless
16:14:18 <Zekka> But I think that the way that Haskell is currently explicit about it is leaky
16:14:20 <zq> whichever is composable with (.)
16:14:33 <ski> Zekka : there's certainly something to be said for the imperative route .. but the basic problem is lack of control
16:14:56 <benzrf> i have no control
16:15:03 <Zekka> I think it's more useful to be able to say from a higher-level, more-abstract point of view "this is my layering of effects"
16:15:06 <Guest44541> or, well, the illusion of control ;)
16:15:08 <ski> one might say that imperative programming was invented to not have to keep track of the monadic layers explicitly
16:15:22 <ski> benzrf : but do you prompt ?
16:15:32 <Zekka> you shouldn't hve to micromanage lift . lift . lift when possible
16:15:46 <ski> right
16:15:54 <Zekka> I think MTL's a step in the right direction except that it has several leaks too, like in attempting to layer StateT
16:15:55 <ski> labelling effects could help there
16:16:14 <ski> and it could also help with commutive effects that commute (that being almost trivial)
16:16:14 <Zekka> So I'm not arguing that Haskell's *idea* is bad, because I think it's one of the strongest ideas in the language -- I'm arguing that the implementation is very annoying
16:16:25 <ski> s/commutive/commuting/
16:16:44 * ski nods
16:16:45 <Zekka> What's the buzzword? I don't think it's very DRY
16:17:01 <ski> buzzword for what ?
16:17:11 <Zekka> ski: For what bugs me about Haskell's current pattern
16:17:36 <ski> are you still talking about monad transformers ?
16:17:39 <Zekka> I feel like the way that you have to micromanage the details we've been talking about when there's often only one sane way to do it is not very DRY (Don't Repeat Yourself)
16:17:57 <Zekka> ski: I'm talking about monad transformers -- I'm also talking about working with contextual values
16:18:00 <Guest44541> thanks four your help guys, nice channel, see you again :)
16:18:11 <ski> often there's only one sane way. that's not the same as there being only one way
16:18:15 <ski> also, the "often" is a problem
16:18:20 <Zekka> You could argue that I'm talking about newtype transformers as well
16:18:39 <ski> we want to be able to rely on refactorings and stuff without having to check special cases and preconditions, if we can help it
16:18:47 <Zekka> er, newtype wrappers
16:19:30 <Zekka> ski: Just being clear -- do you agree that there's a problem here, even if there's not a clear path to solving it?
16:19:35 * ski has mixed feelings about `newtype' wrappers (as used to make differing instances for type classes)
16:19:52 <k00mi> Zekka: do you know about the extensible-effects stuff and related work? (I only read the last couple messages)
16:20:13 <ski> Zekka : problem where ? with managing multiple levels of monad transformers, sure
16:20:17 <Zekka> k00mi: When you say 'extensible effects', are you referring to the general problem of extensible effects or are you referring to a specific project dealing with them?
16:20:38 <benzrf> Zekka: oleg made something called that
16:20:54 <Zekka> ski: But also 'it takes a lot of thinking to i.e. combine possibly contextual functions and values'
16:21:06 <k00mi> Zekka: I'm talking about this: http://hackage.haskell.org/package/extensible-effects
16:21:22 <ski> Zekka : yeah, i think in some cases, that could perhaps be made simpler
16:21:24 <Zekka> there are cases like with monadic functions where just telling the computer to do it creates ambiguity -- there are cases like with functor and applicative where there's not really
16:21:38 <Zekka> ski: It's not really even from a 'can it be fixed' stance that I'm arguing but an 'is it annoying?' stance
16:21:43 <Zekka> because I'm not sure that it can be fixed
16:21:46 <Zekka> k00mi: No, I don't know about it.
16:21:49 <ski> (that's one thing i'm hoping my structure variable thing could perhaps help with)
16:22:38 <ski> Zekka : i think i'd have to see more specific cases to be able to tell whether they're annoying
16:24:00 <Zekka> ski: Well, get a piece of graph paper out and label the vertical axis 'a -> b' and the horizontal one 'a'. Split it halfway down and relabel the vertical axis 'a -> m b'
16:24:29 <Zekka> Then go down each side listing various depths inside a stack of an arbitrary Monad f
16:24:41 <Zekka> i.e. f (f (a -> b)) or f (a)
16:24:50 <staffehn_> k00mi: looks interesting, I like this IRC for giving me new stuff I can read about, thanks.
16:24:57 <Zekka> Then in each cell list ways of combining them, and the results you would get
16:25:30 <Zekka> There will be cases where it's impossible to combine them, cases where there are multiple ways, and casees where there's exactly one way
16:25:49 <Zekka> Most of those 'ways to combine them' (the goal of eventually getting a 'b') will be markedly different
16:26:48 <ski> staffehn_ : ooc, new to IRC ?
16:27:06 <Zekka> The issue to me is that I think you're dealing with a fairly small number of actual *meant* ways to combine them, but in each case you have to combine them a different way
16:27:07 <staffehn_> ski: kinda new
16:27:31 <ski> Zekka : in some cases one could apply `f . f -> f' or `f . g -> g . f', &c., should those be available
16:28:05 <phi__> Does anyone know why every class in Numeric Prelude is named C?
16:28:20 <glguy> Because the author intends it to be used with qualified imports
16:28:23 <phi__> It makes reading haddocks almost imposssible
16:28:28 <Zekka> Ideally your language would abstract around the ways your user *means* to combine things and let the user work that way, giving him a pretty consistent way to do it
16:28:38 <Zekka> which is what your <{}> extension would do
16:29:04 <Zekka> The problem of course is that you can't always actually do that
16:29:29 <Zekka> for arbitrary monads f and g, you can't write f (g a) -> (a -> (f (g b))) -> f (g b)
16:29:30 <phi__> glguy still in what senese Ring.C is better than Ring?
16:30:08 <TheKing444> Zekka, the thing is, you shouldn't need to be using monads for everything
16:30:20 <Welkin> of course you do!!
16:30:26 <Zekka> So you can't quite abstract around binding on the same level of generality you can abstract around fmapping
16:30:28 <Welkin> don't just apply functions! Use the identity monad!
16:30:38 <Zekka> TheKing444: I don't use monads for everything
16:30:44 <Zekka> but I offload as much as I possibly can into my types
16:31:07 <joelteon> with something like Idris, you could name your states, couldn't you?
16:31:21 <TheKing444> Of course, phantom types
16:31:27 <Zekka> Sorry, I hope I don't come off as rude/presumptuous here
16:31:33 <TheKing444> You could add phantom types to your monad type classes.
16:31:45 <TheKing444> YEAAAAAAAAAAAHHH
16:31:48 <joelteon> well, phantom types aren't a very nice solution
16:31:50 <Zekka> because I'm basically saying something pretty fundamental to Haskell really annoys me and I'm not posing a solution, but I'm trying to at least make a case for why it's annoying
16:31:59 <TheKing444> Like, you could "choose" which level you want to get state from.
16:32:04 <TheKing444> quite nicely
16:32:15 <Zekka> (disclaimer: I have written nontrivial code in Haskell, have worked in it for years, am not a massively confused newbie as far as I know)
16:32:16 <kvanb> if you need State, you should prettymuch always use State
16:32:20 <TheKing444> phanotom types aren't too bad, especially with this data kinds thing I here of
16:32:24 <kvanb> if you need recursion, you should always use recursion
16:32:26 <joelteon> kvanb: if you want to compose two States
16:32:34 <ski> phi__ : because the author is named Henning Thielemann ?
16:32:43 <joelteon> you should probably use State in both cases, but there's no way to do two layers nicely
16:32:46 <joelteon> not with mtl anyway
16:32:49 <kvanb> (but state is safer, it guarantees a number of performance characteristics if you don't know what you're doing)
16:33:01 <Welkin> you can't do StateT with State?
16:33:08 <TheKing444> but you could make a library that uses phantom types to allow you to "choose" your layer
16:33:11 <kvanb> State should just be StateT Identity
16:33:29 <TheKing444> (Which would even get removed by the compiler, so no runtime overhead.)
16:33:49 <joelteon> it is just StateT Identity
16:34:04 <TheKing444> it is a type synonym
16:34:17 <TheKing444> > :t undefined :: State String
16:34:18 <lambdabot>  <hint>:1:1: parse error on input ‘:’
16:34:26 <TheKing444> :t undefined :: State String
16:34:27 <lambdabot>     Expecting one more argument to ‘State String’
16:34:27 <lambdabot>     Expected a type, but ‘State String’ has kind ‘* -> *’
16:34:27 <lambdabot>     In an expression type signature: State String
16:34:28 <ski> (Zekka : i don't think anyone is doubting your Haskell qualifications)
16:34:36 <glguy> TheKing444: that's a kind error
16:34:37 <phi__> ski You have to elaborate, using C for classes and T for types is making me chase links all over the place
16:34:37 <TheKing444> :t undefined :: State String a
16:34:38 <lambdabot> State String a
16:34:49 <TheKing444> ah man, didn't expand the type synonym
16:34:53 <Zekka> ski: Sorry, I didn't want to come off as if I was flaunting my experience when I said that
16:34:58 <ski> phi__ : elaborate on why Henning is Henning ?
16:35:13 <Zekka> but I felt like I needed to given that I think it's something that has pissed off everyone I've shown the language to
16:35:14 <Welkin> :t State a b
16:35:15 <lambdabot>     Not in scope: data constructor ‘State’
16:35:15 <lambdabot>     Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
16:35:17 <SrPx> What is the fastest type I can use for hashing over Integer keys?
16:35:23 <ski> Zekka : you didn't, to me. i just didn't see anyone challenging you
16:35:26 <Welkin> :t undefined :: State a b
16:35:26 <lambdabot> State a b
16:35:41 <SrPx> By hashing I mean a hashmap.
16:35:57 <phi__> ski  no eleaborate on his rationale
16:35:59 <Zekka> ski: I was just worried I came off as someone who doesn't really know very much about the language but is very bothered by parts of it he doesn't really understand quite yet
16:36:13 <TheKing444> :t (undefined :: State a b) `asTypeOf` (undefined :: StateT Identity a b)
16:36:14 <lambdabot>     Expecting one more argument to ‘Identity’
16:36:14 <lambdabot>     The first argument of ‘StateT’ should have kind ‘*’,
16:36:14 <lambdabot>       but ‘Identity’ has kind ‘* -> *’
16:36:14 <ski> Welkin : you can't really get `StateT' from `State', no
16:36:18 <Zekka> because I think that's probably the demographic that complains about this the most
16:36:39 <joof> what are lenses?
16:36:51 <ski> phi__ : the tradition comes from ML. it's unfortunate that it (currently) isn't very compatible with Haddock
16:36:58 <Zekka> ski: You can totally get Identity from State, and then define StateT in terms of Identity (a ->), though
16:37:07 <ski> joof : you should ask edwardk
16:37:08 <Zekka> joof: They're composeable accessors
16:37:34 <sshine> joof, http://lens.github.io/
16:38:09 <sshine> :t asTypeOf
16:38:10 <lambdabot> a -> a -> a
16:38:18 <ski> phi__ : the idea is that typing stuff like `Data.Traversable.Traversable' is annoying
16:38:34 <joelteon> well, hang on a second
16:38:45 <joelteon> with State, you can just lift the state operations, can't you?
16:38:49 <ski> phi__ : so the "main type" (and also "main class") in a module would be named `t' (in Haskell, `T' and `C')
16:38:55 <sshine> joof, it's a TemplateHaskell-based library that lets you compose getters and setters for all kinds of typles and records including your own.
16:38:59 <joelteon> if you have two states, you can just lift get
16:39:15 <ski> phi__ : this can work well with module qualification
16:39:15 <Zekka> joelteon: Yeah, minding that that's not  how you'll be interfacing with everything else
16:39:22 <joelteon> it's not based on template haskell, it just has some TH utils to create lenses
16:39:25 <Zekka> if you're using mtl you have already liftIO, liftWriter, etc.
16:39:38 <joelteon> lens itself is based on van laarhoven lenses
16:39:42 <joelteon> I think that's what it's called
16:39:47 <Zekka> joelteon: Pretty sure you're right
16:40:03 <Zekka> Personally I'm tempted to start just manually defining MTL-style multi-lifts
16:40:05 <phi__> ski wouldn't I have to type Ring.function or more annoyingly `Ring.operator` or else have multiple import declarations?
16:40:18 <ski> joelteon : twanvl hasn't been around lately
16:40:19 <Zekka> But the downside is that if I do that my code is no longer (easily) polymorphic over the type of the transformer stack
16:40:21 <joelteon> liftState?
16:40:36 <Zekka> joelteon: Yes, but the issue is that due to internal easons, you can't derive liftState for multiple levels of State
16:40:43 <joelteon> well
16:40:56 <Zekka> it's a really annoying abstraction leak
16:41:04 <joelteon> is that because it's based on fundeps?
16:41:22 <Zekka> It's because of a fundep in MonadState that you can't take out for some reason I don't really remember the details of
16:41:35 <Zekka> but yeah, the superficial reason is that instantiating MonadState with two different state types will break a fundep
16:41:41 <joelteon> does monads-tf fix that or no?
16:41:41 <joof> I'm looking into it; but I'm still barely intermediate with haskell. So many interesting concepts
16:41:46 <ski> you need some way of determining which level you mean
16:41:49 <glguy> If you take out the fundep then you just have to specify more type signatures and it is more annoying to use
16:41:51 <Zekka> joelteon: I haven't used monads-tf
16:42:06 <Welkin> fundep is fundamental dependency? or function depth?
16:42:07 <joelteon> joof, I don't know if lens is good to look at if you're still a beginner
16:42:10 <joelteon> it's pretty complicated
16:42:11 <Zekka> Functional dependency
16:42:13 <joelteon> functional dependencies Welkin
16:42:15 <ski> if not an FD, you'd need either some phantomy stuff, or proper labels
16:42:17 <Zekka> The gist of lens is that you can write code liks this with it
16:42:17 <stepkut> is there term that means Parsing & Printing?
16:42:22 <Zekka> er, that is, the very concrete gist of it
16:42:29 <Zekka> not the abstract 'here are the objects you manipulate when using lens' gist
16:42:34 <Zekka> > (1, 2)^._1
16:42:36 <lambdabot>  1
16:42:42 <joelteon> I'm gonna go try monads-tf
16:42:43 <joof> aight, I just ran into them reading some code
16:42:44 <Zekka> > (1, 2) & _1 .~ 4
16:42:45 <ski> Zekka : using type families instead of FDs here wouldn't help, i think
16:42:46 <lambdabot>  (4,2)
16:42:46 <joelteon> and see what happens if I nest state
16:42:58 <Zekka> joof: So you can use the same functions to assign into your structures as to view them
16:43:09 <Zekka> You can also compose them
16:43:21 <Zekka> > ((1, 2), 3)^._1._1
16:43:23 <lambdabot>  1
16:43:28 <joof> right
16:43:32 <Zekka> > ((1, 2), 3) & _1._1 .~ 4
16:43:33 <lambdabot>  ((4,2),3)
16:43:50 <Zekka> And they're implemented with very normal functions that have an easy type to understand
16:43:58 <Zekka> :t _1
16:43:59 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
16:44:00 <ski> FSVO easy
16:44:00 <glguy> joelteon: monads-tf behaves the same way as the fundep implementation
16:44:04 <joelteon> oh, does it? :/
16:44:20 <Zekka> where Field1 s t a b describes the nuance of a thing that has at least one field -- in this case, a two-tuple
16:44:21 <glguy> It's just a straight-forward transformation of the fundep-based classes to their matching implementation with type families
16:44:25 <Zekka> :t _Just
16:44:26 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
16:44:38 <Zekka> well, that one's kind of scary actually
16:44:39 <joelteon> *is* there a way to fix nested state?
16:44:44 <Zekka> p is usually (->)
16:44:49 <glguy> joelteon: It's not broken
16:44:56 <Welkin> what about IORef?
16:44:58 * ski . o O ( "Eva, can I stab bats in a cave ?" )
16:45:02 <Zekka> so read that as (Applicative f) => a -> f b -> (Maybe a) -> f (Maybe b)
16:45:08 <glguy> joelteon: If you want to do it without the fundep, do it without the fun dep and specify your types when they are ambiguous
16:45:10 <Welkin> IORef (a, IORef b)
16:45:13 <joelteon> oh, ok
16:45:18 <Zekka> er
16:45:20 <joelteon> personally I've never used nested state
16:45:29 <ski> joelteon : labels ?
16:45:32 <Zekka> (Applicative f) => (a -> f b) -> ((Maybe a) -> f (Maybe b))
16:45:40 <joelteon> what about them?
16:45:45 <joof> Well nothing is 'easy' to understand at first unless it's like something you already know :P
16:46:05 <Zekka> joof: So _Just, which goes inside a Maybe, just turns fancy functions from a to b into functions from Maybe a to Maybe b
16:46:29 <Zekka> But because those functions are fancy, they can also look inside a structure instead of altering it
16:46:44 <Welkin> ski, is that a type declaration from lens?
16:46:53 <joelteon> ski: what about labels
16:46:54 <ski> Welkin : which ?
16:47:05 <ski> joelteon : "*is* there a way to fix nested state?"
16:47:09 <joelteon> oh ok
16:47:14 <joelteon> yeah, that sounds like it would work OK
16:47:14 <Zekka> Welkin: Do yoou mean me? I've been rambling about Lens types
16:47:14 <Welkin> Eva, can I stab bats in a cave
16:47:17 <joelteon> how to do labels?
16:47:28 <joelteon> I was trying to do that earlier with GHC.TypeLits.Symbol
16:47:32 <joof> hehe, yeah I got it zekka, thanks
16:47:35 <joelteon> but Haskell doesn't have dependent types
16:47:50 <joelteon> so I can't just do "foo" :: "foo"
16:47:52 <ski> Welkin : well, i was reminded of it because of the aforementioned type signature
16:47:53 <Zekka> joof: Parts of Lens get super tricky to understand but the basic concept is pretty simple
16:48:14 <jfischoff> every time I build cabal says “add-source dependencies have been updated” and reinstalls a bunch of crap. Only problem is that I have not touched the package it says has been modified. How do I work around this bug?
16:48:24 <Zekka> and if you don't get the very basic idea of how it works you can probably at least figure out how to use them
16:48:25 <quchen> Parts of my operating system are hard to understand too, but I can still use it
16:48:37 <quchen> Same with Lens
16:48:53 <Welkin> quchen, you run windows?
16:49:00 <jfischoff> my body is hard to understand but I can still use it ;)
16:49:07 <quchen> Welkin: No need for insultments! ;-)
16:49:19 <quchen> If the Lens operators confuse you I wrote a little overview, https://github.com/quchen/articles/blob/master/lens-infix-operators.md
16:49:20 <suOya_> Should I use lenses if all I want is better handling of record accessing and updating?
16:49:42 <joelteon> probably not
16:49:45 <joelteon> lens has many dependencies
16:49:53 <quchen> suOya_: You should do it manually once to realize that it's very awkward and then learn to use lenses.
16:49:54 <suOya_> Yeah, that's what scares me
16:50:07 <suOya_> quchen: I've done it manually and it's quite awkward yeah
16:50:12 <Welkin> is this a good tutorial for lens?
16:50:14 <Welkin> http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
16:50:14 <Zekka> I really dislike writing unlensy record code, so I usually just use lens
16:50:24 <joelteon> lens is a lot more than a fancy record viewer and updater
16:50:33 <Zekka> Welkin: IIRC it's a little handwavey but it's alright
16:50:42 <quchen> Single records are fine, but as soon as you've got nested types it quickly becomes weird to update things deep down.
16:50:51 <suOya_> yeah
16:51:16 <quchen> I think historically "record awkwardness" was one of the reason to develop lens.
16:51:29 <joelteon> but it quickly evolved into something much more helpful.
16:51:36 <quchen> Example?
16:51:50 <joelteon> I like prisms
16:51:58 <Zekka> By the way, traversals are cool from a theory standpoint and that article doesn't really get into it
16:52:04 <quchen> Oh. Well I cound those as lenses as well.
16:52:12 <quchen> They invented the term "optics" too late to stick ;-)
16:52:38 <glguy> I like the operations like "rewriteOf" where you get bottom-up rewriting of your tree-like type given a single traversal which visits one elements direct children
16:53:06 <joelteon> lens is cool for JSON traversal too
16:53:19 <glguy> along with the myriad of other operations that have been generalize to their "Of" versions
16:54:29 <quchen> But why is that "more than records"? It's still digging down and doing something.
16:54:45 <quchen> When people say "it's so much more" I expect some miracle, not "it's better than the most primitive implementation".
16:54:50 <joelteon> because there's no record update syntax for a nested JSON structure
16:54:51 <glguy> "digging down and doing something" describes most of programming in Haskell
16:54:58 <Zekka> quchen: Records give you getter functions and ugly non-function setters
16:55:07 <Zekka> getters and setters are not the same type of thing with records
16:55:12 <joelteon> it's "more than records" because records are a specific example of the general thing lens can do
16:55:24 <Zekka> Records don't give you multitarget accessors, as one example
16:56:01 <Zekka> Record operations are kind of hard and ugly to compose
16:56:06 <Zekka> you can compose getters, you can't really compose setters
16:56:14 <Zekka> if you want to pass record accessors around, you have to do it in pairs
16:56:18 <joof> It seems to be a much more general way to do such things. A single mental model for a larger number of concepts.
16:56:40 <joof> but I digress. It may be a day or two until I quite understand whats going on
16:59:18 <joof> and they are composable :P
17:00:07 <fread2282> someone help me https://gist.github.com/fread2281/65bf606f6963a1e12d4b (unknown symbol w/ aeson and lens on windows)
17:00:24 <Zekka> joof: As an exercise, try writing setters that go one, two, and three levels deep in a tuple structure
17:01:00 <Zekka> use a getter that looks like this: \(a, b) -> a, and setters that look like this \(_, b) x -> (x, b)
17:01:12 <Zekka> you'll quicckly realize why that's an advantage
17:01:30 <cjay_> are lenses here to stay, or will they be replaced by a language extension one day?
17:01:39 <Zekka> Oh, I've got to go, I may be back later
17:01:56 <Zekka> cjay: They don't seem to me like they really introduce that much functionality which would be better-captured by a language extension
17:02:06 <Zekka> but you might have to ask a lens pro about that
17:02:30 <Zekka> It would be nice if the templatehaskell parts were done by the language, I guess
17:02:31 <edwardk> cjay: it isn't obvious what that extension would be.
17:02:40 <EvanR> lens pro, v2. shareware $20
17:02:42 <quchen> Talk of the devil! Hello sir.
17:02:47 <MP2E> haha
17:02:48 <fread2282> cjay: hy use an extension when lenses work?
17:02:56 <joof> lol
17:02:56 <fread2282> s/hy/why/
17:03:11 <cjay> I'm just wondering because of their complicated type, I don't have a deep understanding of them yet
17:03:25 <edwardk> quchen: shh, they aren't supposed to know of my evil tendencies. makes it a lot easier to get folks to trade their soul for lenses if they don't know who they are dealing with ;)
17:03:36 <glguy> :t mapM
17:03:37 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:03:49 <suOya_> > fix error
17:03:50 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:04:01 <quchen> edwardk: Like Faust's Mephisto, you're offering a great package before taking people's souls.
17:04:30 <EvanR> haskell is very different from other programming language, for instance `fix error' has the opposite effect
17:04:55 <quchen> I think if we had better `type` inference Lens would be much more usable. Right now it's hiding its details out in the open.
17:04:56 <MP2E> my soul for an isomorphism!
17:04:56 <fread2282> lol
17:05:12 <quchen> So that would be my vote for "future things to have to replace lens", where "replace" means "hide better".
17:05:19 <cjay> fread2282: it feels a bit weird to have the ordinary record field names with the underscore, alongside the lens versions
17:05:41 <edwardk> not sure how you can avoid hiding its details in the open if you want composition of lens-_likes_ to work correctly
17:05:43 <Exio> is there any high order function that i could use for replacing this lambda "(\_ _ -> N)" ?
17:05:51 <glguy> cjay: The underscore convention is the default, but you can specify your own
17:06:09 <edwardk> i don't care about lenses per se. i care about traversals, and prisms, and isomorphisms and constructions of that sort
17:06:11 <quchen> edwardk: Sure, if only we knew.
17:06:19 <Exio> it takes two params and returns a constant (which is also a function, if it matters, but i don't think so)
17:06:21 <EvanR> @pl \_ _ -> 3
17:06:21 <lambdabot> const (const 3)
17:06:23 <blipped> http://lpaste.net/107415 <- I'm just curious about style and which of these is preferred? The 2nd is concise, but the first seems more clear.
17:06:41 <EvanR> @pl \_ _ n -> n
17:06:41 <lambdabot> const (const id)
17:06:44 <fread2282> cjay: true, but you can use declareLenses
17:06:51 <quchen> edwardk: Maybe we need something between type and newtype that has the advantages of both. Let's call it newdata.
17:06:51 <Welkin> :t curry
17:06:51 <edwardk> now, if you dig around through my hask project it shows we can build a form of lens that has a few fewer parts exposed. ironically despite working with MUCH crazier types the type errors are a bit nicer.
17:06:52 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:06:52 <Exio> thanks!
17:06:56 <glguy> quchen: People do just find being able to see the type of "mapM"
17:07:03 <Welkin> :t uncurry const
17:07:04 <lambdabot> (c, b) -> c
17:07:08 <glguy> find*
17:07:10 <glguy> fine*!
17:07:10 <Welkin> :t curry const
17:07:11 <lambdabot> a -> b -> b1 -> (a, b)
17:07:42 <zwer_n> :t curry fst
17:07:43 <lambdabot> c -> b -> c
17:07:46 <edwardk> quchen: part of what makes the type errors for lens hideous is that they look like p a (f b) -> p s (f t) -- you have both p and f in there that you didn't ask for.
17:07:57 <glguy> blipped: map (*2) (filter odd list)   -- is just fine
17:08:06 <edwardk> with the hask-style of lenses they become p a b -> p s t -- and their default action is to 'map' rather than traverse
17:08:15 <blipped> thanks glguy
17:08:20 <edwardk> so they become less scary to start with
17:08:20 <Welkin> now whenever I read words that are haskell keywords, I think of haskell
17:08:42 <Welkin> the magazine "Newtype" comes to mind
17:08:50 <quchen> edwardk: I always put in (->) for p/q and nothing for f, which usually works pretty well. I think the main problem is that things become very long quite quickly because of the many parameters (when they're specialized).
17:09:14 <edwardk> type Lens s t a b = forall p. Strong p => p a b -> p s t -- is actually pretty clean
17:09:40 <EvanR> :t Strong
17:09:40 <lambdabot> Not in scope: data constructor ‘Strong’
17:09:45 <EvanR> :info Strong
17:09:46 <edwardk> :t Data.Profunctor.Strong
17:09:46 <lambdabot>     Not in scope: data constructor ‘Data.Profunctor.Strong’
17:09:58 <edwardk> @let import Data.Profunctor
17:09:59 <lambdabot>  .L.hs:99:1:
17:09:59 <lambdabot>      Data.Profunctor: Can't be safely imported!
17:09:59 <lambdabot>      The package (profunctors-4.0.3) the module resides in isn't trusted.
17:10:03 <EvanR> profunctors, i should have known
17:10:04 <edwardk> bah
17:10:06 <edwardk> =)
17:10:08 <lfairy> what's a good name for this type? -- (a -> Maybe b) -> Hook a -> Hook b
17:10:18 <quchen> Shirley!
17:10:28 <edwardk> lfairy: 'filterMap'
17:10:36 <edwardk> is the common name I see for that sort of operation
17:10:53 <glguy> :t mapMaybe
17:10:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
17:11:00 <lfairy> edwardk: thanks. I guess that makes sense
17:12:28 <gamegoblin> Can I declare the type of variables in a do block, like ` do { x :: String <- getLine; } `
17:12:50 <Welkin> don't you need to wrap it in ()?
17:12:55 <Welkin> (x :: String)
17:12:58 <lfairy> gamegoblin: you can try it on the right-hand side, like this
17:13:01 <quchen> do { x <- getLine :: IO String }
17:13:03 <lfairy> getLine :: IO String
17:13:10 <lfairy> what quchen said
17:13:13 <gamegoblin> Gotcha. Didn’t quite know what the syntax was
17:13:21 <quchen> gamegoblin: Maybe with ScopedTypeVariables you can write what you said
17:13:32 <gamegoblin> quchen: that’s what GHC tells me when I try it
17:13:34 <quchen> Similar to how it allows you to write \(x :: String) -> …
17:13:50 <joelteon> > do { x :: String <- return "foo" }
17:13:51 <lambdabot>  The last statement in a 'do' block must be an expression
17:13:51 <lambdabot>    x :: String <- return "foo"
17:13:55 <joelteon> > do { x :: String <- return "foo"; return x }
17:13:56 <lambdabot>  No instance for (GHC.Show.Show (m0 GHC.Base.String))
17:13:56 <lambdabot>    arising from a use of ‘M47441320625099526521157.show_M47441320625099526521...
17:13:56 <lambdabot>  The type variable ‘m0’ is ambiguous
17:13:56 <lambdabot>  Note: there are several potential instances:
17:13:56 <lambdabot>    instance [safe] GHC.Show.Show a =>
17:13:58 <suOya_> > mapMaybe (\x -> if even x then Nothing else Just x) [1 .. 10]
17:14:00 <lambdabot>  [1,3,5,7,9]
17:14:02 <joelteon> oh, wow
17:14:05 <joelteon> you can do that
17:14:22 <EvanR> :t do { x :: String < return "foo"; return x }
17:14:23 <lambdabot>     Illegal literal in type (use DataKinds to enable): "foo"
17:14:35 <joelteon> missed a -
17:14:39 <EvanR> :t do { x :: String <- return "foo"; return x }
17:14:40 <lambdabot> Monad m => m String
17:14:55 <Welkin> > do { x <- getLine :: IO String }
17:14:56 <lambdabot>  The last statement in a 'do' block must be an expression
17:14:56 <lambdabot>    x <- getLine :: IO String
17:15:03 <joelteon> wow, that's gonna save me a lot of keystrokes
17:15:06 <suOya_> > replicateM 20 $ randomRIO (0, 1)
17:15:08 <lambdabot>  <IO [Integer]>
17:15:25 <quchen> I'm surprised you need types in monad blocks that often.
17:15:30 <quchen> I very rarely see them around.
17:15:36 <EvanR> me neither
17:15:56 <Welkin> joelteon, the mapMaybe?
17:16:22 <quchen> When using Exception it's often useful to have types in lambdas, but apart from that I don't recall using them regularly.
17:16:36 <EvanR> do { char x[] = "foo"; return x; } ;)
17:16:49 <ski> gamegoblin : you need pattern signatures for `do { x :: String <- getLine; }', as quchen said
17:16:57 <suOya_> > let x = 0:y; y = 1:x; z = 2:y in x
17:16:58 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
17:16:59 <gamegoblin> quchen: I was inserting type signatures to help debug
17:17:20 <suOya_> > let x = 0:y; y = 1:z; z = 2:x in x
17:17:22 <lambdabot>  [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1...
17:18:04 <Welkin> suOya_, what is the point of that?
17:18:37 <quchen> Showing that "let" allows recursive bindings in Haskell, presumably.
17:18:41 <suOya_> Yeah
17:18:42 <gamegoblin> Welkin: practicing tying the knot
17:18:55 <gamegoblin> circular linked lists
17:19:06 <stolaruk_> I was just about to ask a question, but "replicateM", mentioned above, turned out to be exactly what I was looking for! ;)
17:19:13 <Welkin> okay
17:19:49 <stolaruk_> :t [l1, l2, l3] <- replicateM 3 (atomically . newTVar $ 0)
17:19:50 <lambdabot> <no location info>:
17:19:50 <lambdabot>     not an expression: ‘[l1, l2, l3] <- replicateM 3 (atomically . newTVar $ 0)’
17:20:01 <suOya_> By the way if you have a bunch of hierarchical data types and functions defined in a text file, do you tend to put the most important definitions at the top or vice versa? Like main at top vs. main at bottom, et cetera
17:20:34 <stolaruk_> :t replicateM 3 (atomically . newTVar $ 0)
17:20:34 <lambdabot> Not in scope: ‘atomically’
17:20:35 <lambdabot> Not in scope: ‘newTVar’
17:20:42 <stolaruk_> boo
17:21:19 <ski> @type (replicateM 3 . Control.Concurrent.STM.atomically . Control.Concurrent.STM.newTVar) 0
17:21:20 <lambdabot> Num a => IO [GHC.Conc.Sync.TVar a]
17:21:28 <Welkin> I could probably spend over a year just reading haskell wiki
17:22:05 <ski> suOya_ : depends, i suppose
17:22:47 <Welkin> suOya_, you can separate them into modules
17:24:41 <stolaruk_> ski: Thx
17:25:53 <athan> what's a practical way of working with large text files, parsing and formatting, with `lines`, `split`, etc. in haskell? I've run into stack overflows before by just using Strings and loading the file, what are some good rules of thumb when working with large text files?
17:26:12 <Iceland_jack> Using Data.Text is a good start
17:26:48 <Iceland_jack> If the text file is large you may want the lazy version
17:27:08 <Welkin> large texts? Parsec?
17:28:41 <bergmark> athan: looking at a library like cassava is probably helpful
17:28:45 <athan> Iceland_jack: Yeah, I was wondering if I'd have to make some sort of conduit monstrosity just to reformat a SQL file haha
17:29:00 <athan> bergmark: I'll have to check it out :) Thanks!!!
17:29:26 <athan> Welkin: I'm not really needing to create an AST or anything, just some simple string manipulation, but I might as well venture. Thanks :)
17:29:38 <Iceland_jack> athan: it depends on how complicated the parsing is, if you just need to do some simple operation on each line then Text may suffice
17:30:54 <athan> Iceland_jack: That's basically it, thanks :) Why does String crap out under high stress? From the thunks? Or is it something more complex?
17:32:00 <Iceland_jack> It's not obvious that String should since it should take full advantage of laziness, of course if you do something like 'length content' and then process the rest you force the entire text into memory which kills laziness
17:32:05 <bitraten> hi, is there no FromJSON instance for ByteString in aeson?
17:32:33 <Iceland_jack> it's also possible that there are some strictness problems, maybe you're not being strict in what ever value you accumulate?
17:34:00 <athan> Ahhh, that explains a lot, I should've known. This was a while ago when I was more new to haskell, that makes more sense now. Thanks Iceland_jack
17:37:49 <kqr> why isn't there an average function in the prelude? :(
17:37:57 <Iceland_jack> Because it's trivial to define
17:38:00 <bergmark> bitraten: it was removed because bytestrings aren't encoding aware
17:38:01 <kqr> (average as in arithmetic mean)
17:38:14 * hackagebot definitive-base 1.2 - The base modules of the Definitive framework.  http://hackage.haskell.org/package/definitive-base-1.2 (MarcCoiffier)
17:41:25 <lfairy> bitraten: you should specify the encoding yourself, using e.g. decodeUtf8 from Data.Text.Encoding
17:43:15 * hackagebot definitive-reactive 1.0 - A simple Reactive library.  http://hackage.haskell.org/package/definitive-reactive-1.0 (MarcCoiffier)
17:43:17 * hackagebot definitive-graphics 1.2 - A definitive package allowing you to open windows, read image files and render text to be displayed or saved  http://hackage.haskell.org/package/definitive-graphics-1.2 (MarcCoiffier)
17:43:19 * hackagebot definitive-parser 1.2 - A parser combinator library for the Definitive framework  http://hackage.haskell.org/package/definitive-parser-1.2 (MarcCoiffier)
17:43:21 * hackagebot definitive-filesystem 1.2 - A library that enable you to interact with the filesystem in a definitive way.  http://hackage.haskell.org/package/definitive-filesystem-1.2 (MarcCoiffier)
17:43:33 <EvanR> chuckling at the bottom of the uncylopedia article on haskell
17:44:27 <EvanR> "As is usual in Haskell, what this does is obvious even to the uninitiated from the clear, elegant and concise type signature."
17:44:38 <bergmark> bitraten, lfairy: there is already an instance for Text which assumes UTF-8, and if that's incorrect you can newtype over Text to specify a custom encoding
17:45:05 <Iceland_jack> Text doesn't assume UTF-8
17:45:20 <bergmark> the aeson instances do
17:45:22 <Iceland_jack> are you talking about the instance?
17:45:22 <EvanR> you mean a text instance for json
17:47:11 <EvanR> is it possible to deactivate the occurs check, and thereby get infinite types
17:48:15 * hackagebot Grow 1.1 - A declarative make-like interpreter.  http://hackage.haskell.org/package/Grow-1.1 (MarcCoiffier)
17:54:39 <athan> Are there any tools for checking API change integrity / _necessary_ package version bounds? Or maybe even a package diff tool? I just want to see if I really need a high lower-bound on a few dependencies in my package, I'd hate to unnecessarily restrict, and at the same time, I feel like it would be nice to show when restriction _is_ necessary
17:55:11 <carter> athan: people have said "i'd pay for htat"
17:55:18 <carter> no such tool exists currently
17:55:22 <carter> and it'd be a bit of wokr to build one
17:55:25 <carter> though iut'd be great
17:55:27 <athan> carter: May the coding begin!!
17:55:42 <carter> by whom?
17:55:52 <athan> well, I was just gonna staple something together
17:55:57 <kvanb> whats the tool
17:56:01 <joof> :p
17:56:07 <carter> athan: that'd be cool
17:56:13 <athan> "api-validator"
17:56:21 <athan> :)
17:56:26 <carter> athan: how will you determine api subtyping? :)
17:56:42 <athan> donations would be well accepted, I'm homeless atm :P
17:56:52 <athan> carter: api subtyping?
17:57:07 <carter> athan: .... are you ok?
17:57:13 <athan> oh you mean such things like [String] <: [[a]]?
17:57:36 <athan> carter: Always okay :P (don't worry, I've got some feet under me haha)
17:58:10 <carter> so not literally homeless
17:58:13 <carter> phewf
17:58:17 <athan> carter: I think it's actually kinda cool, I'm gonna start a video blog series of me living out of my car
17:58:22 <athan> no I'm literally homeless hahaha
17:58:34 <carter> :(
17:58:43 <carter> where are you based?
17:58:47 <carter> work woes?
17:58:54 <athan> carter: It's not that bad though, I've almost got me resume and me portfolio up. I've just got to find a reliable shower :x
17:59:05 <joelteon> move to seattle
17:59:07 <athan> carter: Denver-ish (I'm 22 without a degree)
17:59:21 <carter> hrmmm
17:59:25 <athan> joelteon: I've been thinking of a destination, why seattle?
17:59:30 <joelteon> athan: free showers
17:59:35 <joelteon> sorry, maybe not good timing
17:59:36 <carter> athan: just spam all the tech places in denver
17:59:41 <athan> joelteon: Hahahahaha
17:59:51 <athan> carter: I will :) Thanks man
17:59:51 <Welkin> denver has a lot of startups
17:59:55 <carter> athan: please
17:59:58 <Welkin> and hipsters
18:00:03 <carter> worrying about income is shit
18:00:03 <athan> Welkin: A lot of judgemental ones, too :/
18:00:09 <Welkin> athan really?
18:00:12 <Welkin> why is that?
18:00:21 <Welkin> they won't interview you because of no degree?
18:00:25 <athan> Welkin: Well, I might not come off as a professional
18:00:29 <carter> athan: nope
18:00:30 <carter> they don
18:00:31 <carter> t  care
18:00:33 <Welkin> startups don't hire professionals
18:00:36 <carter> seriously
18:00:39 <Welkin> they hire weird people that get stuff done
18:00:41 <carter> doesnt' matter
18:00:44 <athan> hmm
18:00:56 <kvanb> <Welkin>	 they hire weird people that get stuff done
18:00:57 <carter> athan: i've been in the NYC tech scene for nearly 3 years
18:00:59 <kvanb> oh lawd ruby invasion
18:01:06 <carter> seriously, just spam the fuckers
18:01:10 <athan> carter: I was thinking of going to NYC :)
18:01:15 <carter> athan: get work first
18:01:16 <joelteon> go to Sunnyvale, CA
18:01:17 <carter> then move later
18:01:18 <joelteon> I'll get you a job
18:01:20 <athan> hahaha kvanb
18:01:20 <Welkin> elon musks commented on his Ops team: "They are really fucking weird, but they do their job very well"
18:01:23 <Welkin> or something like that
18:01:34 <carter> athan: i think joelteon  actually works with pretty cool people
18:01:37 <carter> and isn't at a startup
18:01:40 <athan> joelteon: o.o .... really??
18:01:42 <joelteon> I work with Enigmagic
18:01:47 <carter> they ARE COOL
18:01:51 <athan> hahaha
18:01:52 <carter> and they work on neat tech
18:01:57 <joelteon> well, by "with", I mean about 20 feet from
18:02:00 <joelteon> he's not on my team
18:02:16 <carter> if joelteon  said that to me i'd at least accept the free flight
18:02:39 <athan> I think my biggest fault is my lack of self confidence, under a form of personal oath, I feel like that's mainly the reason why I haven't gotten hired
18:02:51 <Welkin> athan most likely
18:02:53 <carter> athan: sooo heres a trick
18:03:05 <Welkin> lack of skills/experience is easy to solve
18:03:08 <MP2E> athan : :( I have that same problem
18:03:21 <kvanb> why don't you fix the shower problem first
18:03:26 <carter> when someone asks "do you know X"
18:03:27 <kvanb> by getting a non-office job
18:03:37 <Welkin> the interview goes two ways
18:03:42 <Welkin> you are interviewing them as well
18:03:42 <carter> say "less than I'd like, but I can probably pick it up in a week or so"
18:03:45 <Welkin> keep that in mind
18:03:46 <athan> MP2E: It's silly IMO - I feel like struggle is honesty
18:03:50 <carter> you can say that even if you don
18:03:52 <carter> t
18:03:54 <carter> know shit about X
18:03:59 <athan> hmm
18:04:11 <athan> yeah I've got a dead-end right now, subway, eat fresh xD
18:04:13 <joelteon> you can pick it up unless it's Haskell
18:04:17 <joelteon> complicated language
18:04:32 <athan> I'm making a crazy css compiler right now
18:04:42 <carter> athan: you don't have to show a finished project
18:04:43 <MP2E> If you can write a compiler, you can totally get hired!
18:04:45 <MP2E> :)
18:04:46 <carter> just describe what you'er working
18:04:48 <carter> plz
18:04:48 <athan> I'm just trying to make some crazy & useful projects, hopefully that'll get me a gig :P
18:04:49 <Welkin> joelteon, I wanted to find a job using haskell, but it looks like I may have to end up using clojure or ruby
18:04:52 <Welkin> or something related
18:04:52 <carter> no
18:04:54 <carter> interview now
18:04:56 <joelteon> ruby's not bad
18:04:59 <athan> carter: Well, a WWW compressor, basically
18:05:03 <carter> cool
18:05:09 <carter> athan: point being,. interview now
18:05:11 <carter> finish project later
18:05:14 <athan> you've got a tree of files, html tags of <links>, <scripts> etc
18:05:19 <carter> interviewing getys you jobs, not projects
18:05:20 <athan> it compresses them into a single file
18:05:21 <carter> overall
18:05:21 <athan> really easy
18:05:23 <carter> neat
18:05:33 <carter> i've some ideas for better web templates I wanna work on
18:05:37 <athan> carter: hmm... are you sure?
18:05:41 <carter> i think i have a way to make it easier to compose templates
18:05:42 <carter> athan: yes
18:05:50 <athan> carter: I'm working on a cardinal port for yesod right now :)
18:05:54 <Welkin> athan, this is the first rule of entrepreneurship: sell before you build
18:05:58 <carter> yes
18:06:09 <athan> carter: Dude we should pow-wow, I've got some ideas too :)
18:06:16 <athan> Welkin: But... but...
18:06:20 <athan> Welkin: D:
18:06:20 <MP2E> sell before you build.. interesting
18:06:33 <athan> Welkin: My soul... (jk)
18:06:35 <Welkin> if you don't know if the product will sell, don't waste your time building it
18:06:47 <athan> Hmm
18:06:55 <carter> athan: if you promise to spend the next 2 weeks interviewing and dont get at least one junior dev offer, i will wire you 50 dollars
18:07:03 <athan> so I've got to get good at communicating the purposes I _intend_ to fill
18:07:07 <carter> or something
18:07:33 <carter> athan: and be excited about their stack
18:07:52 <athan> carter: :D!!! Would you be willing to critique my resume? (once it's up?)
18:08:05 <carter> "woah, i don't know as much as I'd like about ___ , but i could get cracking with a week or so of spin up "
18:08:10 <Welkin> interviewing is a complicated process and it mostly ends up being an evaluation of how you'll "fit in" with the rest of the company
18:08:15 <Welkin> "only hire A players"
18:08:19 <carter> intead of "no, i dont know X"
18:08:32 <carter> Welkin:++
18:08:33 <athan> That's what I was feeling, I've worked at a few office-like startups, a help desk for one
18:08:38 <carter> interviewing is soo bs
18:08:46 <carter> athan: apply for all the junior dev roles
18:08:53 <carter> all of them
18:08:57 <athan> It was just really difficult for me to fit in because I was too honest about the ethic and quality of the products (even tohugh I improved them)
18:09:08 <kqr> "return $ if null row then 0 else head row" looks weird and i'm sure i'm missing something: how can i rewrite that more clearly?
18:09:21 <carter> http://careers.stackoverflow.com/jobs?searchTerm=&location=denver
18:09:31 <Welkin> athan, identify something they can do better and where their product/strategy fails
18:09:34 <carter> athan: BS the fuckers
18:09:38 <Welkin> don't be clueless about their product or company
18:09:54 <Iceland_jack> kqr: you can do
18:09:55 <Iceland_jack>     return $ row ++ [0]
18:10:02 <Iceland_jack> sorry
18:10:02 <Iceland_jack>     return $ head $ row ++ [0]
18:10:07 <carter> athan: http://careers.stackoverflow.com/jobs?searchTerm=&location=denver
18:10:23 <athan> Welkin: Hmm, that's a good strategy. Use my problem solving proactively for the company as example of my interest?
18:10:31 <kqr> Iceland_jack, not too bad
18:10:41 <kqr> Iceland_jack, i'll go with it, but i'm open to further suggestions
18:10:52 <carter> yes
18:10:55 <Welkin> athan, well, they don't have time to figure out where you fit in, so if youfigure out exactly how you can help them they will know you can work on your own without being micromanaged
18:10:58 <athan> carter: :) Alright, once I get my resume up, I'm going to set up a few bots to auto apply for me, to spam the hell out of every one xD
18:11:07 <carter> no
18:11:12 <athan> carter: Kidding!!!
18:11:15 <carter> just BS custom cover letters for 10 places
18:11:16 <carter> http://careers.stackoverflow.com/jobs?searchTerm=&location=denver
18:11:21 <athan> hmm okay
18:11:30 <carter> athan: pm me your current draft
18:11:45 <carter> dirty but ready is often better than polished and late
18:11:49 <carter> is a painful fact of business
18:11:54 <athan> Welkin: that's a great strategy, find my own niche
18:12:25 <athan> carter: okay here, one sec
18:12:40 <Iceland_jack> carter: and most things actually, bad news for perfectionists :)
18:12:50 <athan> carter: tell me about it :( I've shot myself in the foot too many times to not have learned that
18:12:51 <carter> yeah
18:12:52 <Iceland_jack> (business and)
18:13:00 <carter> i've been hosed by that
18:13:46 <Welkin> I worked on a product day and night for 9 months only to release it and *nobody gave a shit*
18:13:59 <Welkin> I had to take a few months off after that
18:14:43 <athan> Welkin: I did a job for a private client and didn't sleep for 5 days (emergency coding) just to not get paid :/
18:14:54 <MP2E> ouch :|
18:15:01 <carter> partly because people are terrible about communicating what they actually waht
18:15:09 <carter> athan: if they don't prepay, you don't hurry
18:15:28 <Welkin> athan, for consulting/freelance work it is typical to get paid 50% up front
18:15:30 <athan> carter: That's a good idea, it's hard to be demanding as a starving slave haha
18:15:34 <Welkin> that is how my friends do it any way
18:15:40 <athan> hmm, alright
18:15:51 <Iceland_jack> So many freelancers get screwed over
18:15:52 <MP2E> athan : you don't have to have anything to demand, you just have to look like you have something ;)
18:15:53 <carter> Welkin: that tends to work better for fixed work projects
18:15:57 <carter> yeah
18:16:00 <Iceland_jack> especially designers and artists
18:16:01 <athan> carter: I can't seem to find it right now, is there any way I could email it to you or something? (sorry for being a bug)
18:16:04 <carter> i've 4k in not being paid
18:16:05 <carter> sure
18:16:24 <athan> MP2E: Hm...
18:17:00 <athan> Iceland_jack: That was my earlier idea :/ (still working on an XML hamlet port, for SVG lovelyness + GSAP ;) )
18:17:12 <carter> athan: stop doing hobby work and collect some monies
18:17:14 <carter> you'll get more done
18:18:48 <carter> i should listen to this advice
18:18:54 <athan> carter: Alright, I'm gonna get to work. (hahahaha)
18:18:54 <carter> consluting sucks
18:18:59 <carter> as does consulting
18:19:00 <athan> :/
18:19:15 <athan> thank you guys for the support :) It really means a lot to me
18:19:23 <carter> athan: TAKE THEIR MONEY
18:19:27 <carter> k?
18:19:40 <carter> barter some tasteful engineering for some salary
18:19:41 <athan> carter: You got it ;)
18:19:52 <joof> heh, I get to have this fun pretty soon when I graduate
18:20:06 <joof> or well, sooner than that
18:23:01 <joof> carter: is stack overflow business good? I'd like to move out to Denver/Boulder, but our school doesn't really seem to know anything about jobs out there
18:23:21 <carter> joof: idk, talk with companies and compare how much money they give yoyu?
18:23:51 <Welkin> joof, investigate the startup community there
18:26:02 <joof> Welkin: yeah that was the plan; maybe learn some things about startups. Or grad school for machine learning stuff cause playing with NN is fun
18:26:55 <carter> joof: theres A LOT of people going into grad school for NN stuff right now
18:27:02 <carter> hot fields are good
18:27:04 <joof> which terrifies me
18:27:07 <carter> but too hot and you'll get burned
18:27:08 <joof> but maybe not
18:27:10 <Welkin> joof: http://www.builtincolorado.com/jobs#/jobs?f[]=im_job_categories%3A78
18:27:18 <carter> joof: come lurk on #numerical-haskell :)
18:27:18 <Welkin> don't do grad school...
18:27:26 <carter> i did grad school once
18:27:30 <carter> left me .....
18:27:38 <carter> not in as good a head space
18:27:50 <carter> i'm doing more science on my own time doing industrial stuff by day
18:27:53 <carter> than i would in grad school
18:28:25 <Perono> Trying to learn monads. Does this make sense? Could this be a valid program, if you implement a monad? main = print getResult (do { Start 0; Add 1; Add 2; return })
18:28:37 <Perono> missing a paren
18:28:51 <TheKing444> basically yes
18:28:59 <TheKing444> in fact, that is a free monad
18:29:30 <joof> Welkin: reasoning? research is kinda fun...
18:29:34 <fiddlerwoaroof> Wouldn't that be equivalent to (Start 0 >>= Add 1 >>= Add 2)?
18:29:38 <TheKing444> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
18:29:53 <Perono> TheKing444: thanks!
18:30:18 <Welkin> @tell athan Here is a place to start looking: http://www.builtincolorado.com/jobs#/jobs?f[]=im_job_categories%3A78
18:30:18 <lambdabot> Consider it noted.
18:30:33 <TheKing444> wait, also return needs something after it
18:30:37 <TheKing444> like return ()
18:32:27 <lfairy> Perono: what do the "Start" and "Add" operations do?
18:32:41 <TheKing444> With Free monads, this is irrelevant
18:32:50 <Perono> TheKing444: I'm confused, I'm trying to create a monad that has an internal state, and one operation. That operation should update the internal state, based on the previous state, and return something unrelated.
18:33:07 <Iceland_jack> Perono: State monad?
18:33:34 <Perono> Iceland_jack: I don't know? Will take a look
18:33:47 <TheKing444> your objects should be of type \previous_type -> (unrelated_date, new_data)
18:33:53 <fread2282> Perono: sounds like a newtyped state monad
18:33:59 <TheKing444> your objects should be of type \previous_type -> (unrelated_state, new_state)
18:34:15 <TheKing444> \previous_state -> (unrelated_date, new_state)
18:34:18 <TheKing444> there, that is good
18:34:26 <heatsink> Heh, this advice to BS in order to get hired
18:34:31 <Iceland_jack> @let add n = modify (+ n)
18:34:32 <lambdabot>  Defined.
18:34:40 <Iceland_jack> > runState (add 1 >> add 2) 0
18:34:42 <lambdabot>  ((),3)
18:34:51 <joof> hey it helps :p
18:34:52 <heatsink> In my "Intro to engineering class", there was an exercise where we list skills we would like to learn.  I put "learn how to BS" as one of the skills.  Instructor didn't like that.
18:35:00 <heatsink> Still haven't learned.
18:35:11 <Welkin> it's not about BSing
18:35:16 <Welkin> it's about being confident in yourself
18:36:00 <dwcook> You can perfectly serviceably do that just with a monoid, even, no monad required; that monoid is called composition of endomorphisms (e.g., function composition for functions of the form a -> a)
18:36:05 <heatsink> Being confident in yourself comes from being able to accurately evaluate your abilities.
18:36:19 <Iceland_jack> heatsink: Does it?
18:36:37 <Welkin> sure, you have to know your limits: where you excel and where you need help
18:36:44 <joof> I'm pretty sure its from being able to overevalueate your abilities in most cases
18:37:25 <joof> considering the more I learn, the less confident I am in anything
18:37:40 <heatsink> Read about the Dunnig-Kruger effect
18:37:49 <Welkin> unfortunately, many highly intelligent people with incredible skills suffer from imposter syndrome
18:37:50 <heatsink> *Dunning Kruger
18:37:58 <Welkin> heatsink, yes, I know about that
18:38:09 <Iceland_jack> heatsink: Doesn't that exactly support joof's point?
18:38:55 <heatsink> I think it supports my point.  Many people can't distingush skills they're good at from skills they're bad at.
18:39:25 <joof> I think you're right
18:39:27 <Iceland_jack> I actually think confidence has much less to do with ability than is being suggested
18:39:30 <Perono> I'm still a little confused... (do { bomb1 <- AddBomb 3 7; bomb2 <- AddBomb 1 9; DeleteBomb bomb1; return CountBomb; }) does this make sense?
18:39:45 <Welkin> however, people who tend to achieve their goals tend to overestimate their abilities and underestimate the challenges
18:39:53 <dwcook> Perono: not without context. What are the intended semantics?
18:39:59 <Welkin> such as "being stupid enough to try -- and succeeding"
18:40:09 <glguy> Perono: I don't really know what you're trying to do, but you probably don't want to use "return" there
18:40:15 <Welkin> will power plays a role
18:40:40 <Perono> dwcook: just imagine that the state is a map, AddBomb adds a bomb in a x y position and returns its id, DeleteBomb removes a bomb based on its id, and CountBomb returns the amount of bombs available
18:40:48 <heatsink> Welkin, one of the articles about the Dunning Kruger effect mentioned a guy who thought that lemon juice made you invisible to security cameras.  Willpower did not keep him out of jail.
18:40:56 <Welkin> haha
18:41:02 <Perono> is that possible using that syntax? I couldn't imagine how that could be done without passing a state to AddBomb et
18:41:58 <dwcook> Perono: What you wrote is, for the most part, sensible using the State Monad instance.
18:42:30 <dwcook> Perono: However instead of "return CountBomb" I suggest writing "CountBomb". And, for that matter, non-constructor identifiers cannot start with uppercase letters.
18:42:44 <Perono> Okay, I'll take a better look on the State Monad.
18:42:47 <Perono> dwcook: oh, okay.
18:42:55 <Perono> thanks, see you
18:43:34 <heatsink> As for myself, persistence is less about believing I'll succeed, as continuing even though I expect to fail.
18:44:31 <heatsink> And it seems like the most reliable way to discover my skills has been to notice when other people perform terribly by my standards.
18:45:29 <dwcook> Perono: by the way, you *do* pass a state, but it is not (necessarily) explicitly mentioned as you compose the state computations together. To actually run that computation, you'd use runState or something equivalent
18:45:33 <dwcook> @type runState
18:45:34 <lambdabot> State s a -> s -> (a, s)
18:46:44 <dwcook> (and that's where the state gets explicitly mentioned)
19:04:26 <EvanR> heatsink: your instructor was mad because he didn't learn how to bs either
19:04:36 <EvanR> and he knows youre right
19:40:22 <systemfault> Are there good tutorials to explain state/writer/reader monads and possibly how they’re actually useful.
19:40:51 <systemfault> If I have to define a special type + monad writer just to log stuff.. I just won’t do it.
19:40:58 <dwcook> systemfault: I don't know specifically of any tutorials but I can tell you that those three in particular are just wrappers for values of certain types
19:41:46 <dwcook> systemfault: State s a is just s -> (a, s), Writer m a is just (a, m) (iirc), Reader r a is just r -> a
19:41:49 <glguy> systemfault: There's no promise that they're useful
19:42:05 <glguy> They're simple types that admit implementations of the monad operations
19:42:21 <systemfault> Ah ok
19:42:44 <gipp> systemfault: if you don't need anything but plain text log messages, logging can just be Writer String, or Writer Text
19:43:12 <glguy> It's worth learning how they work, and sometime they can be handy to have
19:43:23 <gipp> it seems overly complex before you have your head wrapped around monads, but once you do that "special type + writer" is not as complex or cumbersome as it seems
19:43:37 <dwcook> With a Writer a good choice of type is often some sort of list
19:43:49 <gipp> err yeah list of the above I should say
19:43:50 <systemfault> I really want to understand them… and even when I’m done learning them, I still have transformers to learn, right?
19:44:11 <dwcook> Yeah, but the generalization of those to transformers is mostly straightforward
19:44:34 <dwcook> StateT s m a is s -> m (a, s) and ReaderT r m a is r -> m a
19:44:41 <dwcook> (I forget WriterT, never used it)
19:44:57 <dwcook> Oh, with the Monad m constraint of course
19:45:35 <gipp> a lot of people go about "learning monads" the wrong way. Just know the type signatures, and as you write code in a natural way, you're going to start seeing places where things like >>= would be useful, very organically
19:45:36 <dwcook> You can get back the non-transformers by setting m = Identity
19:45:43 <gipp> don't prematurely monad, basically
19:46:05 <dwcook> (and also adding in a runIdentity where appropriate)
19:46:06 <platz> I think I'd be afraid to use Writer except for the most trivial of use cases.  Something about having that memory just growing and growing..
19:46:09 <gipp> others have a different view im sure
19:46:57 <pjdelport> I don't know if this has already been mentioned, but first grok Functor, then Applicative, and only then Monad.
19:47:30 <benzrf> pjdelport++
19:47:35 <dwcook> systemfault: essentially the only reason we have these newtypes (that's how they're implemented) is because we can't write more than one Monad instance for things of certain forms
19:48:02 <systemfault> I see
19:48:32 <dwcook> And as some have said, you may or may not even find them useful
19:48:33 <pjdelport> Even if you already grok functors/monads in general, and want to learn how a new monadic type works: first understand how its Functor works, then its Applicative, then its Monad interface.
19:48:41 <dwcook> Though I'd say I've at least found StateT handy on one occasion
19:49:18 <glguy> > T.sequenceA [("a",1), ("b",2), ("c",3)]
19:49:19 <lambdabot>  ("abc",[1,2,3])
19:49:27 <benzrf> functors r ezier
19:49:29 <dwcook> systemfault: Is there a specific doubt you have?
19:49:48 <benzrf> glguy: ooh
19:50:08 <benzrf> :t unzip
19:50:09 <lambdabot> [(a, b)] -> ([a], [b])
19:50:13 <systemfault> dwcook: Not really, I’m at a point where… I just have to write code to gain some intuition
19:50:14 <Welkin> learning arrows helped me understand monads better
19:50:31 <dwcook> systemfault: sounds like a plan
19:50:34 <systemfault> dwcook: I’ve only been fiddling so far…
19:50:58 <benzrf> :t _1 %~ mconcat . unzip
19:50:59 <lambdabot>     Couldn't match type ‘([a0], [b1])’ with ‘[b0]’
19:50:59 <lambdabot>     Expected type: [(a0, b1)] -> [b0]
19:50:59 <lambdabot>       Actual type: [(a0, b1)] -> ([a0], [b1])
19:51:02 <benzrf> dang
19:51:12 <benzrf> :t _1 %~ mconcat
19:51:12 <gipp> systemfault: if you haven't, check out https://github.com/bitemyapp/learnhaskell
19:51:13 <lambdabot> (Field1 s t [b] b, Monoid b) => s -> t
19:51:17 <benzrf> hmm
19:51:22 <systemfault> :k WriterT
19:51:23 <lambdabot> * -> (* -> *) -> * -> *
19:51:27 <dwcook> systemfault: Here's an idea: Just as sort of a frivolous exercise, take any function you've implemented before and write it in terms of Reader.
19:51:28 <gipp> systemfault: the Yorgey course and NICTA course linked there, especially, have some great practice sets
19:51:29 <systemfault> Mind blown :(
19:51:32 <benzrf> :t _1 %~ mconcat . unzip
19:51:32 <Welkin> @quote benzrf 2
19:51:32 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
19:51:33 <lambdabot>     Couldn't match type ‘([a0], [b1])’ with ‘[b0]’
19:51:33 <lambdabot>     Expected type: [(a0, b1)] -> [b0]
19:51:33 <lambdabot>       Actual type: [(a0, b1)] -> ([a0], [b1])
19:51:39 <benzrf> how does that not work o.o
19:51:42 <Welkin> @quote benzrf2
19:51:42 <benzrf> o derp
19:51:42 <lambdabot> benzrf2 says: <benzrf> i dont know whats happening <benzrf> am i being trolled
19:51:51 <benzrf> :t (_1 %~ mconcat) . unzip
19:51:52 <lambdabot> Monoid a => [(a, b)] -> (a, [b])
19:52:01 <benzrf> Welkin: :{
19:52:10 <systemfault> gipp: Thanks :)
19:52:20 <benzrf> oh wait
19:52:26 <benzrf> :t first mconcat . unzip
19:52:27 <lambdabot> Monoid c => [(c, b)] -> (c, [b])
19:55:20 <glguy> > filterM (const [False..]) [1..3]
19:55:21 <lambdabot>  <hint>:1:24: parse error on input ‘]’
19:55:28 <glguy> > filterM (const [False.. ]) [1..3]
19:55:30 <lambdabot>  <hint>:1:25: parse error on input ‘]’
19:55:39 <glguy> > filterM (const [False .. ]) [1..3] -- last attempt
19:55:40 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
20:03:25 * hackagebot aur 1.1.0 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-1.1.0 (fosskers)
20:05:47 <carter> glguy: congrats btw :)
20:19:05 <EvanR> systemfault: just write code and if monad would make sense then use it, but personally that does not happen much. applicative is great though
20:20:21 <systemfault> EvanR: I really need to gain intuition…I was looking at http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and I wouldn’t have never thought of using a monad for the bot
20:20:26 <systemfault> Is it a good pattern?
20:20:58 <EvanR> maybe, to write the bots event handlers
20:21:06 <EvanR> the whole bot i do not know
20:21:57 <EvanR> but that would be a newtype or wrapper or something for IO
20:22:05 <EvanR> not a new kind of monad
20:22:49 <EvanR> i see a lot of "RWST over IO" pattern
20:23:03 <EvanR> but seems funny to me
20:24:57 <doovy> fmap (*3) Right 4
20:25:21 <doovy> fmap (*3) $ Right 4
20:25:31 <Welkin> why does that tutorial import Control.Arrow if it doesn't use anything from it?
20:25:53 <doovy> 2 + 2
20:26:07 <Welkin> doovy, use > 2 + 2
20:26:18 <EvanR> systemfault: insert into your list of things to research is FRP applied to network agents like servers and bots, food for though
20:26:24 <EvanR> t
20:26:27 <doovy> > 2 + 2
20:26:27 <Welkin> also, use /msg lambdabot > 2 + 2
20:26:28 <lambdabot>  4
20:26:48 <doovy> thx welkin
20:28:37 <EvanR> Welkin: thats annoying
20:30:12 <EvanR> reading this paper on type system for a dynamic language which seems geared towards easing dynamic programmers into static typing (with inferrence) http://ecee.colorado.edu/~siek/dls08igtlc.pdf
20:30:39 <Welkin> I came from dynamic typing (python) to haskell without any issues
20:32:40 <EvanR> it uses python as an example of a system which could benefit from it
20:32:58 <EvanR> in my case im researching this stuff for ruby, but its the same issue
20:33:40 <EvanR> constantly in my work i get runtime type errors (not always called such) from production code
20:34:07 <EvanR> at least i can run the syntax checker in ruby before runtime, but if only i could run the type checker
20:34:17 <EvanR> or read the type signatures of code im writing against
20:35:43 <systemfault> EvanR: Thank you
20:36:04 <benzrf> hey
20:36:11 <benzrf> has anybody here used the ircbot libra
20:36:14 <benzrf> *library
20:36:25 <benzrf> it looks handy but there's no docs, just the types
20:36:26 <Welkin> planning on writing a spam bot?
20:36:35 <benzrf> Welkin: of course!
20:36:35 <EvanR> this paper is funny in one spot, after going to great lengths to design it so obviously wrong programs do not type check... this is still allowed (seemingly on purpose)  \(f::Int->Bool->Int) (x::?) -> f x x
20:36:49 <EvanR> where ? is a "dynamic type"
20:37:12 <Welkin> why not just a?
20:37:19 <Welkin> polymorphic type
20:37:39 <EvanR> in the paper a type variable (not polymorphic) would cause it to be rejected by the checker
20:37:59 <EvanR> forall a. .. a .. stuff is not supported
20:38:21 <EvanR> leading to a funny example involving defining a map function which only worked with functions of type Int -> Int
20:38:37 <EvanR> Welkin: but the default is ? for parameters
20:38:53 <EvanR> still i cant imagine how such a function would make sense even in python or ruby
20:40:01 <EvanR> Welkin: youre right though, if the ? were a variable, in the paper, as in haskell, it would fail to check as it should
20:40:17 <EvanR> but its carefully design to check if you put a ?
20:40:19 <EvanR> >_<
20:40:34 <EvanR> almost certainly crashing at runtime
20:43:35 <gamegoblin> Is there an “isLeft” and “isRight” in base?
20:43:41 <EvanR> :t isLeft
20:43:42 <lambdabot> Either a b -> Bool
20:43:47 <gamegoblin> confirmed
20:43:49 <gamegoblin> thanks
20:45:31 <gamegoblin> @hoogle isLeft
20:45:33 <lambdabot> No results found
20:45:39 <gamegoblin> EvanR: ??
20:45:44 <EvanR> often in these papers there is lip service to dynamic languages, justifying their existence with some sort of "trade off benefit" vs modern functional languages with static types. and this is often "you are able to run the program immediately, even if it is wrong, for rapid prototyping"
20:46:10 <EvanR> which seems crazy to me, since i can do that by putting undefined and errors in my haskell code
20:46:15 <EvanR> and the thing crashes
20:46:18 <EvanR> as expected
20:46:29 <EvanR> gamegoblin: its in there, Data.Either
20:46:52 <gamegoblin> any idea why hoogle can’t find it?
20:47:17 <gamegoblin> I imported Data.Either and still no dice
20:47:17 <EvanR> @hoogle Either a b -> Bool
20:47:17 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
20:47:17 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
20:47:17 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
20:47:48 <platz> EvanR: but that doesn't address having to adjust types regarding data flow.  in dynamic langs is trivial to throw hunks of data through without having to think about them
20:48:08 <EvanR> gamegoblin: https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Either.html
20:48:16 <platz> i.e. mass of unspecified json
20:48:58 <EvanR> platz: if its text that is understood to have valid json and we dont care about it thats easy. but i am constantly crashing due to changes in the json data that i am actually processing
20:49:56 <EvanR> so i need to adjust my code to fit the invisible changes in schema
20:50:10 <platz> agreed - thats part of the tradeoff. speed to get up vs maintainability
20:50:12 <EvanR> dynamic is making that harder
20:50:23 <heatsink> I think the tradeoff is that people can make dynamic languages do what they want by trial and error, which is easier than learning to reason rigorously enough to satisfy a type system.
20:50:55 <EvanR> that makes sense
20:51:10 <heatsink> So lots of dynamic code exists and there's an incentive to fix it incrementally
20:51:42 <EvanR> but when i see dynamic code being written like that i stop everything to make sure it makes remote sense
20:51:48 <benzrf> stepkut ? stepcut ?
20:51:53 <benzrf> either of those nicks active?
20:51:57 <benzrf> @seen
20:51:57 <lambdabot> Say again?
20:51:59 <benzrf> meh
20:52:15 <stepcut> benzrf: you rang?
20:52:35 <EvanR> the testing craze is a symptom of people being disastisfied with the results of trial and error
20:52:39 <EvanR> maybe
20:52:44 <Welkin> TDD
20:52:54 <Welkin> a buzzword that makes me cringe
20:52:55 <benzrf> stepcut: i see u wrote the ircbot library
20:53:06 <benzrf> got any docs on how to use it -.-
20:53:12 <stepcut> benzrf: I did indeed -- I would love to rewrite it using pipes and netwire
20:53:19 <benzrf> Welkin: i feel like TDD could be a good thing in small amounts
20:53:20 <EvanR> type directed development ahh
20:53:20 <Welkin> netwire~
20:53:25 <benzrf> like if you write a few high level tests...
20:53:25 <stepcut> benzrf: sadly, no -- because I keep meaning to rewrite it ;)
20:53:30 <benzrf> stepcut: dang
20:53:32 <lfairy> benzrf: irc bots aren't hard to write, so feel free to build yours from scratch
20:53:39 <heatsink> test driven development?
20:53:43 <benzrf> thbbt
20:53:44 <pjdelport> If you view dynamic typing as moving the type system to the runtime, then TDD is sort of an attempt at moving the run-time type system back to compile time.
20:53:52 <benzrf> ha
20:53:56 <Welkin> yes benzrf http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:54:03 <Welkin> although that tutorial is not very good
20:54:21 <benzrf> pjdelport: in theory it's more than a type sysem
20:54:23 <benzrf> *system
20:54:29 <systemfault> lfairy: You’re the one who wrote the IRC bot on the wiki?
20:54:34 <EvanR> in theory its not about types at all
20:54:47 <pjdelport> benzrf: All tests are types, in a sufficiently strong type system. :)
20:55:05 <lfairy> systemfault: no... but I contributed about two lines :P
20:55:06 <Welkin> haha, it was written by don stewart
20:55:07 <benzrf> pfft
20:55:09 <EvanR> all tests, all specs, everything is a type !
20:55:17 <EvanR> type oriented programming
20:55:19 <platz> some say TDD is like double-entry accounting.  You write the code twice so that if one gets messed up the other complains
20:55:28 <systemfault> lfairy: Ah :)
20:55:39 <EvanR> yeah the write it three times or four to get more reliability
20:55:47 <systemfault> platz: Yup, that’s the argument Robert C Martin always uses
20:55:54 <EvanR> then you need error codes to reduce the redundancy
20:55:58 <benzrf> how does netwire differ from, say, banana
20:56:19 <pjdelport> platz: The same could be said for when you write explicit (non-inferred) type signatures.
20:56:19 <platz> I always thought it was an odd analogy though
20:56:26 <heatsink> Doesn't that violate DRY, platz?
20:56:35 <Welkin> benzrf, netwire is better for games/bots and banana is better for guis
20:56:44 <EvanR> pjdelport: except one is an order of magnitude smaller and easier
20:56:53 <Welkin> pjdelport, that is documentation
20:56:55 <systemfault> platz: I think it’s fair. The tests test the code… and the code tests the tests
20:57:04 <pjdelport> EvanR: Well, we already know that. :)
20:57:13 <platz> heatsink: duplication is far cheaper than choosing the wrong abstraction
20:57:16 <EvanR> systemfault: personally, i really hate rewriting all the tests during a refactor
20:57:32 <platz> although I'm not sure TDD will save you from choosing the wrong abstraction
20:57:34 <systemfault> EvanR: It sucks indeed…
20:57:34 <benzrf> Welkin: how so
20:57:45 <benzrf> i bothered to learn bananananana, now sell me on netwire pls
20:57:52 <Welkin> benzrf, no idea, I haven't looked into banana yet
20:58:10 <EvanR> systemfault: its a caveman way of solving the issue
20:58:10 <Welkin> I just got started on netwire
20:58:14 <systemfault> platz: TDD forces you to write testable code (In normal OOP/imperative languages at least…)
20:58:47 <gipp> testable doesn't necessarily mean the right abstraction/good design
20:58:50 <systemfault> platz: If you don’t use TDD then often, you wonder “how the hell am I going to test that?!”
20:58:53 <platz> I think it will be interesting to see how the TDD folks react to property-based testing when it finally filters down
20:59:17 <systemfault> gipp: I agree.
20:59:22 <platz> the mostly erlang guys tried to get the ruby rogues guys to do a property-based testing show, but I guess it didn't take
20:59:52 <systemfault> Don’t you think that TDD can be useful with Haskell?
21:00:08 <EvanR> haskell has testing frameworks, but i dont think its for the same purpose
21:01:05 <benzrf> Welkin: banananananananananananana seems pretty Standard Basic to me
21:01:14 <benzrf> doesnt seem particularly specialiezd for anything
21:01:40 <benzrf> i found http://www.reddit.com/r/haskell/comments/1qen2k/elerea_grapefruit_netwire_reactivebanana_sodium_a/ tho
21:02:18 <EvanR> systemfault: the craze is losing steam ;) http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html
21:02:36 <systemfault> EvanR: DHH is a clown though..
21:02:39 <gipp> systemfault: testing in Haskell works a little differently than in imperative languages. It's mostly property-based, and its most important use is enforcing typeclass laws (contracts). Most of what you test for in imperative languages can be tested automatically by GHC if you set up your types correctly
21:02:44 <cdk> @pl \a xs -> (:xs) <$> f a
21:02:44 <lambdabot> flip ((<$>) . flip (:)) . f
21:03:01 <gipp> at least that's how i use it
21:03:03 <benzrf> cdk: i cant even tell what you're doing here
21:03:09 <benzrf> oh i see
21:03:35 <systemfault> gipp: That’s nice, I didn’t know
21:03:38 <benzrf> how about, uh
21:03:41 <platz> systemfault: TDD requires spending lots of time doing it wrong first; even the experts say this
21:03:49 <benzrf> fmap (:xs) . f
21:03:51 <cdk> benzrf: it's the binary op for a foldrM, a -> [a] -> f [a]
21:04:05 <platz> but they seem better off for it having gone through the exercise
21:04:12 <systemfault> platz: But then… who gets everything right the first time?
21:04:20 <platz> I'm not claiming they are
21:04:20 <systemfault> platz: In software programming… impossible.
21:04:22 <benzrf> oic
21:04:48 <platz> haskell has plenty of testing frameworks
21:04:54 <benzrf> :t let f = undefined :: a -> b in (:) . f
21:04:54 <lambdabot> a -> [b] -> [b]
21:05:03 <benzrf> :t let f = undefined :: a -> b in fmap . (:) . f
21:05:04 <lambdabot> Functor f => a -> f [b] -> f [b]
21:05:05 <EvanR> if tdd is an elaborate cosmic trick to get people to reason about their code, it seems a costly way to go about this
21:05:19 <cdk> I feel like there should be a library function for this: F.foldrM (\a xs -> (:xs) <$> f a) [] :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f [b]
21:05:29 <benzrf> cdk: just write it out :-O
21:06:34 <platz> I think when haskellers talk about testing they are talking a lot about testing pure code - and when TDD folks (in the case of  DHH) talk about testing - since primarly what they build are web apps, they are talking about testing code interacting with messy external systems and system boundaries
21:06:57 <systemfault> platz: Yeah… but TDD isn’t about integration tests.
21:06:59 <platz> part of why the property testing stuff kind of falls on deaf ears i think
21:07:12 <EvanR> they probably are and personally i spend all my time testing the "pure" code
21:07:15 <EvanR> in ruby
21:07:18 <systemfault> platz: And DHH has probably only worked with trivial domains with pretty much no business rules.
21:07:19 <EvanR> since that is what is wrong
21:07:42 <SamB> what the heck is DHH
21:07:44 <systemfault> platz: The industry of finance… nutrition… for example have a ton of complex business rules
21:07:56 <systemfault> SamB: The Rails (RoR) guy
21:08:15 <glguy> ?type \f t -> traverse f (F.toList t)
21:08:16 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f [b]
21:08:34 <EvanR> business rules should be encoded into types
21:08:36 <MP2E> Ruby on Rails? psssh, try Intercal on Interstates!
21:08:41 <MP2E> [/joke]
21:08:45 <SamB> why are you guys even bothering to discuss the ruby on rails guy?
21:09:03 <systemfault> MP2E: Or COBOL on cogs
21:09:10 <SamB> screw Ruby on Rails, I want Snakes on a Plane!
21:09:15 <platz> intercal is such a good name
21:09:17 <Welkin> python
21:09:19 * BMeph prefers perl on pogosticks
21:09:25 <EvanR> haskell on a horse
21:09:37 <gipp> why can't the ad package differentiate monomorphic functions?
21:09:41 <gipp> at least it can't as far as i can tell
21:09:44 <gipp> for Double -> Double
21:09:45 <Welkin> cat in the hat
21:10:33 <SamB> funny that none of those jokes seem to take into account that the rails in question were supposed to be for modularity, not transportation ..
21:11:10 <EvanR> huh, you mean like train cars?
21:11:12 <gipp> @type diff
21:11:13 <lambdabot>     Not in scope: ‘diff’
21:11:14 <lambdabot>     Perhaps you meant ‘dff’ (imported from Data.Graph)
21:11:31 <glguy> gipp: Because it's not magic. The types that it works at allow it to track what operations the function is built out of so that it knows how to compute the derivative
21:11:46 <Welkin> someone should write a Dr. Suess-style tutorial on haskell called "The Cat in the Monad"
21:11:46 <glguy> You don't get to use arbitrary operations on Doubles
21:14:27 <EvanR> i want to research and figure out ways to represent the business specification with types
21:14:48 <EvanR> and the implications on reacting to changes in the spec
21:15:13 <EvanR> would be nice if a check said your code suddenly is wrong
21:16:38 <glguy> "sorry boss, can't launch the app yet, the proofs aren't implemented that show the code implements the business rules in the types"
21:16:46 <benzrf> :^)
21:18:22 <EvanR> yeah
21:18:52 <EvanR> instead of a damned continuous integration traffic light, its a "project proven to make sense" light
21:20:13 <EvanR> ideally it would be more of "good" or "bad" not "we don't know" which is usually the case
21:24:10 <EvanR> i just randomly saw a blog about f# which says that the type inference looks at the format code in the printf format string
21:24:27 <EvanR> head explode
21:25:50 <gipp> glguy: I'm not really sure what you mean by "operations the function is built out of", but eh. I'll just use finite differences
21:26:14 <glguy> gipp: ad doesn't use numerical approximations to find derivatives
21:28:01 <EvanR> :t \f -> f f
21:28:01 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t1 -> t
21:28:02 <lambdabot>     Relevant bindings include f :: t1 -> t (bound at <interactive>:1:2)
21:28:02 <lambdabot>     In the first argument of ‘f’, namely ‘f’
21:28:29 <EvanR> :t \f -> f >>= f
21:28:30 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
21:28:30 <lambdabot>     Expected type: a -> a -> b
21:28:30 <lambdabot>       Actual type: a -> a
21:35:44 <jmcarthur> :t \lam app -> lam (\f -> app f f)
21:35:45 <lambdabot> ((t2 -> t1) -> t) -> (t2 -> t2 -> t1) -> t
21:36:06 <EvanR> :t \x y -> x + y
21:36:07 <lambdabot> Num a => a -> a -> a
21:36:23 <jmcarthur> :t \lam -> lam (\f -> f >>= f)   -- not sure what i'm going to get here
21:36:24 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
21:36:24 <lambdabot>     Expected type: a -> a -> b
21:36:24 <lambdabot>       Actual type: a -> a
21:36:31 <jmcarthur> ah
21:36:47 <jmcarthur> :t \lam -> lam (\f -> f <*> f)   -- not sure what i'm going to get here either
21:36:48 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> b
21:36:48 <lambdabot>     Expected type: f a
21:36:48 <lambdabot>       Actual type: f (a -> b)
21:37:05 <jmcarthur> well, the first one turned out nicely at least
21:38:21 <EvanR> :t let p = (+) in p 1 2
21:38:22 <lambdabot> Num a => a
21:41:07 <jmcarthur> :t \lam app -> let s = lam $ \x -> lam $ \y -> lam $ \z -> x `app` z `app` (y `app` z); k = lam $ \x -> lam $ \y -> x in s `app` k `app` k
21:41:08 <lambdabot> ((t -> t) -> t) -> (t -> t -> t) -> t
21:43:16 <EvanR_> @pl \lam app -> let s = lam $ \x -> lam $ \y -> lam $ \z -> x `app` z `app` (y `app` z); k = lam $ \x -> lam $ \y -> x in s `app` k `app` k
21:43:18 <lambdabot> ap (ap . flip (flip . flip flip id . (ap .) . ((.) =<< (.))) . fix . const . ap id (. const)) (ap (.) (liftM2 (.) (.) ((. (flip =<< (((.) . ap) .) . ((.) =<< (.)))) . (.) . (.))))
21:43:43 <gipp> seems practical
21:44:59 <EvanR_> :t (. const)
21:45:01 <lambdabot> ((b -> a) -> c) -> a -> c
21:45:22 <jmcarthur> :t const . ($ id)
21:45:27 <lambdabot> ((a -> a) -> b) -> b1 -> b
21:46:02 <yzmtf2008> Why can fibs = scanl (+) 0 (1:fibs) generate the Fibonacci sequence?
21:46:37 <gipp> :t scanl
21:46:38 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
21:46:50 <glguy> ?src scanl
21:46:50 <lambdabot> scanl f q ls = q : case ls of
21:46:50 <lambdabot>     []   -> []
21:46:50 <lambdabot>     x:xs -> scanl f (f q x) xs
21:47:26 <jmcarthur> yzmtf2008: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+fibs+%3D+scanl+%28%2B%29+0+%281%3Afibs%29+in+fibs
21:47:39 <gipp> so looking there, the first element of the list is 1 (given by the definition)
21:47:57 <gipp> err rather
21:47:58 <glguy> > let fibs = scanl (+) 0 (1:fibs) in fibs
21:47:59 <lambdabot>  can't find file: L.hs
21:48:07 <MP2E> wut
21:48:12 <glguy> ?undefine
21:48:12 <lambdabot> Undefined.
21:48:13 <glguy> > let fibs = scanl (+) 0 (1:fibs) in fibs
21:48:15 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:49:07 <gipp> so scanl takes an "accumulator" (initially set to 0 by the second argument) and iterates over the list given by the third argument
21:49:19 <gipp> each iteration, it applies the function (+) to the accumulator and the next item in the list
21:49:31 <gipp> the first iteration is 0 + 1
21:49:58 <EvanR_> unfoldl seems like a more straightforward fib
21:50:07 <gipp> the subsequent ones are (fibs !! n - 1) + (fibs !! n)
21:50:24 <MP2E> EvanR_: it'd probably be more efficient too :P
21:51:28 <EvanR_> but this scanl is really funny
21:52:34 <gipp> @let scanlStep f q [] = []
21:52:36 <lambdabot>  Defined.
21:53:17 <gipp> eh forget it
21:54:06 <gipp> don't think he's here and that wasn't even a correct def
21:54:59 <EvanR_> fibs is boring, write the 20 character functional program to produce the primes ;)
21:55:00 <EvanR_> filter isPrime 1..
21:55:00 <EvanR_> haw haw
22:05:00 <platz> nubBy(\a b->a`mod`b==0)[2..]  too bad 27 chars
22:06:17 <EvanR_> > nubBy(\a b->a`mod`b==0)[2..]
22:06:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:06:35 <EvanR_> head explode
22:07:48 <EvanR_> @pl (\a b->a`mod`b==0)
22:07:48 <lambdabot> flip flip 0 . ((==) .) . mod
22:13:15 <EvanR_> (==0) .: mod
22:13:16 <EvanR_> (\a b->a`mod`b==0)
22:13:16 <EvanR_> saved 6 chars
22:13:16 <EvanR_> er (==0) :. mod
22:13:31 <lfairy> writing a procedure that reads lines is surprisingly hard
22:14:47 <EvanR_> > length "nubBy((==0):.mod)[2..]"
22:14:48 <lambdabot>  22
22:15:35 <EvanR_> > length "nubBy(zero:.mod)[2..]"
22:15:36 <lambdabot>  21
22:16:12 <EvanR_> lfairy: i remember doing it a lot in ghci with readContents, lines, map, etc
22:19:12 * hackagebot wordpass 0.4.2.0 - Dictionary-based password generator  http://hackage.haskell.org/package/wordpass-0.4.2.0 (MichalGajda)
22:23:41 <lfairy> EvanR_: oh, it's easy enough using Handles or lazy I/O
22:23:59 <lfairy> when the data comes in regular chunks though, it gets annoying
22:24:12 * hackagebot HsOpenSSL 0.10.5 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.5 (MasatakeDaimon)
22:25:25 <EvanR_> lfairy: yeah in this case the first brilliant idea i have is to dump your regular chunks into a (fake) file and read them using the handles which are so easy
22:25:32 <EvanR_> using the file system as a buffer
22:26:45 <EvanR_> and the file system interface as a library to read lines from a buffer
22:27:28 <EvanR_> anyway it still seems pretty hard for production quality since you dont want a malicious line to exhaust memory or freeze because it is so long
22:27:34 <lfairy> EvanR_: ah, I didn't explain myself too well
22:27:56 <lfairy> I'm writing a network application -- IRC bot, to be precise
22:28:12 <lfairy> it needs to read lines from a socket, which may or may not be encrypted
22:28:52 <EvanR_> yeah i would not expect that to be a basic thing to just throw together, but i would expect the whole layer to be available in a library already
22:29:16 <EvanR_> in varying levels of "do it all for you"
22:29:37 <lfairy> I know pipes has a line splitter... but bringing it all in just to read lines seems like overkill
22:30:02 <EvanR_> haha
22:30:33 <EvanR_> again, as you say its so easy, just set the handle to line buffering and read lines
22:30:49 <EvanR_> how complicated is how you look at it
22:31:44 <EvanR_> haskell is great for bitfiddling, and for skipping it all when you cant be arsed
22:35:50 <lfairy> tls doesn't give you a Handle though -- only recv and send functions :(
22:36:33 <lfairy> plus, iirc ByteString hGetLine splits on \n, not \r\n as specified by the protocol
22:36:43 <lfairy> feel free to correct me on that
22:37:08 <EvanR_> not sure about the details but yeah
22:37:16 <EvanR_> bitfiddlin
22:37:34 <EvanR_> still prefer it over doing it in C
22:37:40 <ReinH> So I'm not super happy with ZNC. I guess it's time to write an IRC proxy in Haskell.
22:42:02 <ddellacosta_> I'm trying to understand what general practices are re: using Haskell platform vs. downloading ghc.  It seems like the platform is well behind ghc itself, but I also don't know what the reasons are for using 7.8.x vs. 7.6.x...can anyone point me toward some docs?  The download pages themselves aren't super informative.
22:42:35 <jle`> ddellacosta_: it's only temporary, as they are getting things ready to transition to 7.8.x
22:42:42 <ReinH> ddellacosta_: The platform will be updated to 7.8 soon
22:42:43 <jle`> i think the alpha came out either today or soon
22:42:54 <ddellacosta_> jle`, ReinH: ah, okay, glad I asked
22:43:16 <ddellacosta_> is it safe to say that most users stick with platform, because of compilation pain?
22:43:18 <jle`> i think they were sorting out some problems with Windows?
22:43:46 <jle`> ddellacosta_: nobody actually really compiles GHC, even people who just use GHC w/o haskell platform.  usually only ghc developers compile ghc
22:43:48 <ddellacosta_> (or, re-compilation pain I guess I should have said)
22:44:08 <jle`> ...i actually don't know why people recommend the platform
22:44:11 <jle`> ...
22:44:11 <MP2E> I recompile GHC a lot
22:44:13 <ddellacosta_> jle`: that makes sense, but under what conditions would someone choose to use ghc vs. the platform?
22:44:17 <MP2E> but that's because I'm working on Android cross compilation
22:44:19 <MP2E> soo... >_>
22:44:22 <ReinH> jle`: whatever I commpiled GHC two weeks ago
22:44:27 <jle`> MP2E: ah, you count as a ghc developer ;)
22:44:33 <jle`> ReinH: wai?
22:44:38 <ddellacosta_> sorry, when I said re-compile I mean re-compile anything you write w/that version of ghc, not ghc itself
22:44:38 <ReinH> ddellacosta_: if you want to use a modern GHC
22:45:03 <EvanR_> ddellacosta_: ive always downloaded ghc and then the packages i want afterward with cabal
22:45:09 <EvanR_> no problems
22:45:19 <ReinH> Haskell Platform, as a curated system, will always be in a punctuated equilibrium with "out of date"
22:45:26 <jle`> yeah, that's what i do now too.  i wonder why people recommend it
22:45:27 <ReinH> every now and then it will update to current ghc
22:45:33 <ReinH> and then it will languish for months/years
22:45:54 <ddellacosta_> ReinH: what would motivate that though--is this because of recent optimizations, or etc.?  Sorry for the basic questions--I'm happy to rtfa if fa exists and someone can point me at it
22:45:58 <ReinH> EvanR_: yep, that + hsenv is what I do now
22:46:08 <ddellacosta_> EvanR_: gotcha, that's what I was curious about.
22:46:10 <ReinH> ddellacosta_: 7.8 has added some important new features, yes
22:46:15 <EvanR_> on the other hand haskell platform has a fancy pretty website with graphics
22:46:25 <EvanR_> web 2.0
22:46:25 <ddellacosta_> I guess I should just go review the changelogs to get a sense
22:46:31 <ReinH> ddellacosta_: https://www.haskell.org/ghc/docs/7.8.1-rc1/html/users_guide/release-7-8-1.html
22:46:32 * ddellacosta_ loves web 2.0, so hot
22:46:34 <jle`> ...why haskell platform?
22:46:39 * jle` wonders
22:46:50 <ReinH> EvanR_: :p
22:47:25 <jle`> is it because it contains cabal?
22:47:33 <ddellacosta_> ReinH, EvanR_, jle`: thanks for the help, this is useful as a relative newb
22:47:47 <lfairy> jle`: I think ghc is bundled with cabal, actually
22:47:56 <jle`> is it because of ghci?
22:48:00 <jle`> ghc comes with ghci too, right?
22:48:07 <jle`> hm...the profiler?
22:48:08 <EvanR_> yes
22:48:26 <jle`> then why the platform?
22:48:27 <EvanR_> haskell platform comes with opengl
22:48:51 <jle`> ah.  does it do special things to make it easier for cross platform opengl?
22:48:58 <ddellacosta_> EvanR_: I assume it's kind of challenging to get OpenGL going w/o platform?
22:48:58 <EvanR_> i doubt it
22:49:04 <ddellacosta_> er, or what jle` asked
22:49:08 <EvanR_> i never had a problem
22:49:12 * jle` shrugs
22:49:38 <jle`> why do you compile GHC, ReinH ?
22:49:39 * ddellacosta_ ponders scrapping his platform install and starting from 7.8.3
22:49:45 <gipp> jle` there's no compelling need for the platform for most use cases, it's purely for convenience AFAIK, but thta's sort of outweighed by the slowness of updates lately
22:49:51 <MP2E> ddellacosta_ : it wouldn't be a bad idea ;)
22:49:53 <ddellacosta_> er, 7.8.1 I guess
22:49:57 <MP2E> nooo 7.8.3
22:50:04 <MP2E> .1 and .2 are horribly bugged
22:50:22 <ddellacosta_> MP2E: oh, okay--7.8.3.  I thought I just had the numbering off for a sec
22:50:31 <ddellacosta_> good to know
22:50:39 <EvanR_> cabal install opengl
22:50:42 <EvanR_> heh
22:50:44 <MP2E> hehe ah no problem, I thought you preferred 7.8.1 for some reason :V but yeah, we like to 'pretend that one doesn't exist ;)'
22:50:49 <jle`> EvanR_: what OS are you on?
22:50:56 <ddellacosta_> MP2E: gotcha. :-)
22:51:01 <ReinH> λ ghc --version
22:51:01 <ReinH> The Glorious Glasgow Haskell Compilation System, version 7.8.2
22:51:02 <ReinH> :(
22:51:07 <MP2E> D:
22:51:07 <EvanR_> jle`: linux
22:51:12 <ReinH> MP2E: what are the .2 bugs?
22:51:14 <jle`> EvanR_: maybe that's why it's so easy for you ;)
22:51:35 <EvanR_> jle`: theres another trick... on osx i have not updated haskell in over a year
22:51:44 <EvanR_> but i originally installed the haskell platform
22:51:54 <MP2E> ReinH : There are multiple RTS segfaults fixed, a few TH bugs, segfaults with the typechecker, explosions in memory with various libraries and a ton of other issues :V It's like 80 issues fixed and maybe 60 of them I would call "high profile issues"
22:51:55 <EvanR_> not had a problem yet but im way out of day
22:52:02 <EvanR_> and i like it
22:52:11 <MP2E> but 7.8.3 is great so far
22:52:14 <MP2E> haven't had any problems :)
22:52:18 <jle`> i am having a blast with 7.8.3
22:52:24 <jle`> woo hoo ~
22:52:54 <EvanR_> type checker segfaults
22:52:55 <EvanR_> nice
22:53:06 <MP2E> yeah there were all kinds of fun things :(
22:53:21 <jle`> i think there are random bugs that come from bug fixes/improvements in the IO manager that show up if you try to compile 7.4.x etc. code though
22:53:28 <ReinH> MP2E: sounds like time to update :)
22:53:37 <MP2E> Indeed! :)
22:53:37 <blipped> What does it mean when you have "if p x then..." What does the 'p x' translate to as a boolean expression?
22:53:42 <jle`> that leverage the runtime environment heavily
22:53:57 <jle`> blipped: well, p is a function, and when applied to x, it yields a boolean
22:53:58 <EvanR_> i know its so hard writing the type checker code, with all those dangling pointers and array bounds ! ;)
22:54:32 <MP2E> jle` : Not everything is fixed as a result, darcs 2.8.4 is still bugged. Patches already exist upstream and you can get them for darcs 2.8.4 from the gentoo-haskell github repository
22:54:34 <jle`> > let equals3 = (== 3) in if equals3 4 then "i am three" else "i am not three"
22:54:36 <lambdabot>  "i am not three"
22:54:43 <jle`> > let equals3 = (== 3) in if equals3 3 then "i am three" else "i am not three"
22:54:44 <MP2E> but yeah sometimes it isn't GHC's fault
22:54:44 <lambdabot>  "i am three"
22:55:01 <blipped> ahh, ok, the rest of this code makes more sense then.
22:55:03 <blipped> thanks
22:55:09 <jle`> > let equals3 = (== 3) in equals3 5
22:55:11 <lambdabot>  False
22:55:17 <jle`> blipped: it is important to remember that the function has to return a Bool
22:55:22 <jle`> :t (== 3)
22:55:23 <lambdabot> (Num a, Eq a) => a -> Bool
22:55:53 <blipped> I was having trouble reading: filterAsFold p = foldr (\x l -> if p x then x : l else l) []
22:56:01 <blipped> but that clears it up.
22:56:03 <jle`> so it makes if/then/elses a bit less useful
22:56:10 <jle`> because it forces boolean blindness
22:56:17 <jle`> blipped: ah ok :)
23:02:44 <bb010g> I'm trying to do something akin to ``instance Ord t => Functor (\t -> S.Set t) where``, but there aren't type lambdas. How would I accomplish this?
23:03:44 <EvanR_> => Functor (Set t) right
23:04:31 <gipp> or Functor (t -> Set t), not sure what you're intending that notation to mean
23:04:34 <bb010g> EvanR_: Yes; I've got Data.Set qualified as S
23:04:59 <EvanR_> the result of applying the lambda would be Set t
23:05:43 <jle`> bb010g: you would do instance Functor Set; you can't constrain the parameter
23:05:47 <bb010g> I'm trying to make a Functor instance for Set, but I need the argument to Set to be an instance of Ord.
23:05:49 <jle`> what would the type signature of fmap be?
23:06:05 <gipp> bb010g: you can't
23:06:14 <jle`> the type of fmap implies that a Functor has to be able to contain *any* type
23:06:24 <jle`> because you have to be able to apply *any* (a -> b)
23:06:27 <jle`> :t fmap
23:06:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:06:30 <bb010g> jle`: Ord t => (a -> b) -> Set t -> Set t
23:06:42 <jle`> bb010g: really?
23:06:45 <EvanR_> well you can have Ord t => Functor t
23:06:54 <jle`> you apply an (a -> b) to a Set of t, to get a Set of t?
23:07:08 <jle`> how is that even useful?
23:07:24 <jle`> the only meaningful implementatio would be fmap _ = id
23:07:29 <jle`> (if that was the case)
23:07:35 <lfairy> Constant functor yay
23:07:55 <gipp> you can use MonoFunctor from mono-traversable i think
23:08:26 <jle`> bb010g: that doesn't unify with the type of fmap, either
23:08:41 <gipp> :t omap
23:08:42 <lambdabot>     Not in scope: ‘omap’
23:08:42 <lambdabot>     Perhaps you meant one of these:
23:08:42 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
23:09:19 <gipp> :t Data.MonoTraversable.omap
23:09:20 <lambdabot> Not in scope: ‘Data.MonoTraversable.omap’
23:09:24 <gipp> well, i tried
23:09:39 <gipp> https://hackage.haskell.org/package/mono-traversable-0.1.0.0/docs/Data-MonoTraversable.html
23:09:44 <jle`> you can also use a special Functor typeclass with a type family w/ constraint kinds
23:09:47 <jle`> i think
23:24:46 <gamegoblin> Off topic, but does anyone know what the terminology for a block of CSS is. That is, the “.myClass { somestyles }”
23:24:53 <gamegoblin> Is there a word that refers to that as a whole?
23:24:55 <gamegoblin> CSS block?
23:25:24 <gipp> a statement, or more specifically a rule-set
23:25:30 <gamegoblin> thanks
23:44:21 * hackagebot HsOpenSSL 0.11 - Partial OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.11 (MasatakeDaimon)
23:48:14 <jle`> bb010g: looking back i might have been a bit blunt, sorry :)
23:53:19 <dfeuer> Do any libraries support a masked shift as in Java? That is, a left/right shift that only looks at the 5 or 6 low-order bits of the shift amount and is apparently the native shift on typical hardware?
23:54:11 <dfeuer> Also, I see logical shift right in GHC.Prim, but I don't see such a thing in Data.Bits. Is it available somewhere for normal boxed use?
23:54:12 <dfeuer> ?
