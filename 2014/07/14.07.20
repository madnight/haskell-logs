00:00:08 <achernyak> such as applying it to head and tails works without an issue
00:00:38 <dfeuer> The [a] notation is a special syntax for list types. Whereas for *most* types you'd have something like Maybe a  or  Tree a,   for lists you get to write [a].
00:00:43 <dfeuer> Someone thought that was pretty.
00:00:44 <roboguy_> achernyak: we can take the type "t" to be "[a]". In fact, we can take it to be *any* type
00:01:05 <roboguy_> as long as all the ts match up
00:01:10 <jle`> achernyak: so this function takes a function ([a] -> b), and returns a new function ([a] -> Maybe b)
00:01:13 <jle`> if that makes sense
00:01:27 <achernyak> yes
00:02:09 <achernyak> except it can take it works on both ([a] -> a) and ([a] -> [a])
00:02:31 <achernyak> at least that's the ones it works on.
00:02:43 <roboguy_> achernyak: t is independent of a
00:03:31 <jle`> so here's your function: safeListFunc :: ([a] -> b) -> ([a] -> Maybe b)
00:03:36 <jle`> let's say you want to give it a function ([t] -> t)
00:03:42 <dfeuer> achernyak, FYI, a Haskell intro many people think has the best explanations is _Learn You a Haskell for Great Good!_ You can read it for free online. It definitely explains some things very well. I don't know about this particular thing.
00:03:42 <jle`> so
00:03:59 <jle`> in order to make ([t] -> t) "fit" with ([a] -> b) ...
00:04:02 <jle`> what does a have to be?
00:04:05 <jle`> what does b have to be?
00:04:40 <ohhulloh> +1 for learn you a haskell, finished reading it a few days ago, a solid read
00:04:50 <jle`> taking a simpler example, there is a common function id :: a -> a
00:04:52 <achernyak> Thanks, I understand that part. The part I don't understand is why does the type of safeListFunc :: ([b] -> a) -> [b] -> Maybe
00:05:00 <jle`> you can give id a Bool
00:05:13 <achernyak> works with functions that return both lists of element and single elements
00:05:29 <jle`> and you can make `a` "fit" into `Bool`, by setting a ~ Bool, so id :: Bool -> Bool, if you pass in a Bool
00:05:38 <jle`> this is what i'm trying to show
00:05:51 <jle`> so safeListFunc can take anything that "fits" into ([a] -> b)
00:06:03 <jle`> do you see why ([t] -> [t]) "fits" into that?
00:06:10 <jle`> look at them side-by-side
00:06:13 <achernyak> ah ok
00:06:13 <jle`> ([a] -> b)
00:06:17 <jle`> ([t] -> [t])
00:06:20 <jle`> what is a?
00:06:22 <jle`> what is b?
00:06:36 <achernyak> ah I didn't realize that b could hold another list
00:06:43 <achernyak> I thought that would need another function.
00:06:47 <roboguy_> incidentally, id is an example of a function that can take lists and non-lists
00:06:50 <achernyak> thank you so much for clearing that up@
00:07:02 <jle`> well... b can "represent" anything...a list or a Bool or a function
00:07:26 <jle`> in fact, you could even pass in flip map ;)
00:07:29 <jle`> :t flip map
00:07:30 <lambdabot> [a] -> (a -> b) -> [b]
00:07:33 <achernyak> It amazes me every day just how powerful haskell's type system is :)
00:07:58 <jle`> flip map :: [t] -> ((t -> u) -> [u])
00:08:05 <jle`> so that can unify with ([a] -> b)
00:08:14 <jle`> if a ~ t, and b ~ ((t -> u) -> [u])
00:08:23 <roboguy_> achernyak: oh man, wait until you learn about the other stuff! it's really amazing. just yesterday I was watching a talk were the speaker used haskell's type system to do stuff I wouldn't have expected would be possible
00:08:27 <roboguy_> *where
00:08:29 <johnw> achernyak: it has a great power-weight ratio
00:09:15 <johnw> and the stuff you can do with kinds these days is pretty impressive
00:10:00 <jle`> safeListFunc (flip map) :: [a] -> Maybe ((a -> b) -> [b]).  well.  admittedly not a very useful function, but.
00:10:15 <achernyak> yeah... I don't think I am even at a point where I realize just how concise and elegant haskell can be.
00:10:16 <jle`> haskell's type system still amazes me every day
00:10:44 <jle`> achernyak: there are some accessible examples you can read now even today, if you are at this point
00:10:48 <achernyak> but the flip map was a great example of just how robust it can be
00:11:00 <jle`> there's there's wadler's "theorems for free" paper
00:11:08 <achernyak> thanks for the very detailed answer fle'
00:11:10 <johnw> that paper should be read by everyone
00:11:20 <jle`> in which you can look at a function's type signature alone, and be able to deduce guaruntees about its behavior
00:11:22 <johnw> I just added a slide with a link to it in my talk :)
00:11:24 <jle`> just by the type signature
00:11:39 <roboguy_> johnw: I still need to read it. every time I start to, I get a bit put off by the old syntax and then I get distracted by something
00:12:00 <roboguy_> I have an idea of the *kind* of stuff it talks about, but I don't know how to find a free theorem
00:12:14 <jle`> there's also a few talks that show that type signatures in Haskell pretty much are analogous to propositions in logic, complete with disjunctions and conjunctions and everything
00:12:17 <achernyak> thanks guy there goes a reasonable bed time :)
00:12:40 <dfeuer> @free potato -> cannon -> [targets] -> ((potato, cannon, target) -> Double) -> [Double]
00:12:41 <lambdabot> Extra stuff at end of line
00:12:45 <johnw> roboguy_: try starting here: http://cubeoflambda.wordpress.com/2011/11/16/parametricity/
00:12:57 <jle`> i like this presentation http://perl.plover.com/classes/CHI/
00:13:16 <roboguy_> I don't think I've seen those two yet, thanks!
00:13:52 <dfeuer> @free f::potato -> cannon -> [targets] -> ((potato, cannon, target) -> Double) -> [Double]
00:13:52 <lambdabot> $map $id (f x y xs (q . $map_Triple g h p)) = f (g x) (h y) ($map k xs) q
00:13:56 <achernyak> definitely added to my list
00:14:11 <jle`> @free f :: [a] -> Maybe a
00:14:11 <lambdabot> $map_Maybe g . f = f . $map g
00:14:28 <jle`> that says that if you have a function g
00:14:37 <jle`> if you map the g over a list, and then apply your f :: [a] -> Maybe a to it
00:14:48 <jle`> it'll be the same if you apply your f :: [a] -> Maybe a to the list, and then map g over the Maybe
00:14:58 <jle`> and you can deduce this just by looking at the type signature
00:15:12 <jle`> there is no possible implementation with that type signature that would break that invariant
00:15:15 <achernyak> wow
00:15:20 <roboguy_> achernyak: when you get past type classes (and maybe a couple other things) you should definitely have a look at edward kmett's work. it's pretty amazing
00:15:39 <bitemyapp> carter: thanks, wish you were there!
00:15:47 <achernyak> I will definitely have to.
00:15:54 <jle`> this is the point where i dare you to try to write a function with the type signature [a] -> Maybe a, that breaks that invariant
00:16:40 <achernyak> Haskell started off as an evaluation for my company (which included me reading learn you a haskell), but now it turned into one of my hobbies. Which is why I am working through Real World Haskell.
00:16:57 <jle`> :)
00:32:43 <jg_> hi all, i'm having trouble writing a type signature for one of my functions that uses readerT : https://gist.github.com/jg/bf0dd9c8023cdb2dfd20 . Could someone explain what's this "Data.Functor.Identity.Identity (IO c)" ghci outputs for the type there?
00:35:33 <jle`> jg_: so Reader r is just a type synonym for ReaderT r Identity
00:35:38 <Enigmagic> :t Reader
00:35:39 <lambdabot>     Not in scope: data constructor ‘Reader’
00:35:39 <lambdabot>     Perhaps you meant ‘ReaderT’ (imported from Control.Monad.Reader)
00:35:48 <jle`> but Identity isn't imported, so it uses the fully qualified name
00:35:54 <jle`> Data.Functor.Identity.Identity
00:36:11 <jle`> as for the IO c
00:36:24 <jle`> in the context of Reader, return :: a -> Reader r a
00:36:38 <jle`> so you pass in bracket
00:36:40 <jle`> :t backet
00:36:41 <lambdabot>     Not in scope: ‘backet’
00:36:41 <lambdabot>     Perhaps you meant one of these:
00:36:41 <lambdabot>       ‘bracket’ (imported from Control.Exception),
00:36:45 <jle`> :t bracket
00:36:46 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:37:00 <jle`> bracket takes three arguments and returns IO c
00:37:10 <jle`> so return :: IO c -> Reader r (IO c)
00:37:57 <jle`> if you add `import Data.Functor.Identity` to your imports, you might find a less ugly error message
00:39:11 <jle`> oh it infers the whole thing is ReaderT Config Identity, because you use connectionUrl
00:40:23 <Enigmagic> jg_: are you looking for something more like this? https://gist.github.com/NathanHowell/8062519e4524bd2d7e30
00:50:41 <dfeuer> What's the difference in representation between  data Foo a = Foo {-# UNPACK #-} !Word [a]   and  data Foo a = Foo Word# [a]  ?  They generate rather different Core, but I haven't a clue.
00:51:38 <copumpkin> I wouldn't have expected there to be one, except for one doing more work around constructing and deconstructing the Word
00:51:53 <copumpkin> (just around the boundaries though; I'd expet the memory representation to be identical)
00:52:23 <dfeuer> Hmm. That's what I'd have thought too,
00:52:37 <dfeuer> and I'd have thought that in my code it would all end up being the same,
00:52:39 <dfeuer> but it's not.
00:52:53 <dfeuer> That said, I don't see any obvious performance difference.
00:53:30 <dfeuer> It's not the same in Core, that is. I don't know about in memory.
00:54:03 <copumpkin> show the diff perhaps?
00:54:08 <copumpkin> minus the confounding list?
00:54:22 <dfeuer> Go to sleep instead. Maybe look at it tomorrow or the next day!
00:55:49 <copumpkin> ok :)
00:56:43 <Enigmagic> good idea
00:58:02 <jg_> Enigmagic: compiler says it expects one more argument to m in 'connectionUrl :: Monad m => ReaderT m Config B.ByteString'
00:58:46 <jg_> liftIO makes sense, i was wondering why it works without it
01:02:14 <int3__> anyone here have experience with reactive-banana and/or threepenny?
01:03:53 <int3__> I'm trying to create a Behavior that accumulates Events, but the 'initial value' itself could change. so something like `accumB <variable initial value> eventStream`
01:04:46 <int3__> but fmapping accumB over a Behavior results in a `Behavior (Behavior a)`, and Behavior is not a monad, so I can't get back a `Behavior a`
01:07:34 <int3__> ah, dynamic event switching might be what i'm looking for... *reads blogposts*
01:23:09 <newbie|2> http://www.zdziarski.com/blog/wp-content/uploads/2014/07/iOS_Backdoors_Attack_Points_Surveillance_Mechanisms.pdf
01:23:22 <ZettaBlade> Every time I use java, I just go back to Haskell. *sigh*
01:28:10 <Toxmi> I've recently updated my arch (pacman -Syu) and got this warning/erros:
01:28:12 <Toxmi> https://gist.github.com/anonymous/75c2068c5662c8afb326
01:28:30 <Toxmi> hw, my xmonad/xmobar/pandoc...works I don't know what is happenning
01:56:48 <nadirs> Toxmi: are you using any particular repositories for those packages? (i.e. not extra, community, etc.)
01:59:55 * hackagebot eros 0.6.0.0 - A text censorship library.  http://hackage.haskell.org/package/eros-0.6.0.0 (pharpend)
02:04:00 <dv-> boo
02:05:52 <Toxmi> nadirs: no, I use extra....but previously I handled them outside pacman....it might be some problem e.g. I've cabal with slightly different versions in $HOME/.cabal and in /usr/bin
02:07:03 <Toxmi> I might go after a fresh install i.e. removing everything and install them from scratch using official arch packages
02:19:58 * hackagebot eros-http 0.6.0.0 - JSON HTTP interface to Eros.  http://hackage.haskell.org/package/eros-http-0.6.0.0 (pharpend)
02:27:05 <nadirs> Toxmi: that thing about cabal shouldn't be a problem, or, at least it isn't for me (I have a similar setup, using pacman's cabal to bootstrap a user local, more updated version of cabal)
02:32:47 <ph88> instead of   0 :+ (-4)   i would like to write   0 :- 4   how can i define this new operator?   i tried   (:-) a b = a :+ (-b)   parse error on input `='
02:33:56 <arancia> Operators can't start with a colon, I think
02:34:08 <supki> ph88: it's not possible to define operators starting with :, : is reserved for data constructors
02:39:25 <ph88> can i make a data constructor  :-  that turns   0 :- 4   into  0 :+ (-4)  ?
02:39:56 <Maxdamantus> ph88: not really.
02:40:23 <Maxdamantus> ph88: you wouldn't be able to match when the constructor operation isn't bijective.
02:41:01 <Maxdamantus> ph88: actually, are you sure what you're looking at is a constructor?
02:41:13 <ph88> no
02:41:32 <ph88> (:+) :: a -> a -> Complex a        i also wonder why there is only a here, because i put in two numbers
02:41:38 <ph88> "a"
02:42:51 <Maxdamantus> :t "foo" :+ "bar"
02:42:52 <lambdabot> Complex [Char]
02:44:19 <ph88> list of char ???
02:47:06 <Twey> ph88: There are two data parameters (see the a -> a ->) but only one type parameter (a is just a single type)..
02:48:22 <jle`> ph88: String is an alias for [Char]
02:48:48 <inthedryer> was merely searching for an active IRC channel in google, and for some reason this Haskell thing turns up, seems pretty cool
02:49:41 <inthedryer> I'm assuming there are a number of apologists here ready to enumerate the benefits of the language
02:50:01 <aksono> app = StateA ???? (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app) How can i set the ???? to the inner m?
02:51:56 <inthedryer> Holy shit, every other TCP transmission is a Dup Ack.
02:54:41 <Twey> Does anybody know how reactive-banana's Future is supposed to work?  I want to use reactimate to do some IO action when a Behavior changes, but as of reactive-banana-0.8 I get a Future Foo out of reactimate instead of a Foo
02:58:39 <Twey> Ah, I guess I wanted reactimate' (I was getting the Future from changes, rather)
03:00:01 * hackagebot eros-client 0.5.0.1 - DEPRECATED in favor of eros-http  http://hackage.haskell.org/package/eros-client-0.5.0.1 (pharpend)
03:02:39 <merijn> Anyone aware of abstract machine models (like STG) that account for both lazy and strict evaluation in the same language?
03:03:34 <Peaker> The SPECIALIZE pragma is such a PITA. Why can't I specialize via: m=SomeMonad rather than repeating the whole signature?
03:03:54 <Peaker> Added INLINE annotations to my whole module, cause it to take dozens of seconds to compile and then GHC's the impossible happened :(
03:04:21 <phaazon> hey, is there a way to put post values within happstack-server?
03:04:24 <Peaker> I add INLINE only because it's less PITA than SPECIALIZE
03:04:43 <merijn> Peaker: Large numbers of INLINE explode compile times and memory consumption
03:04:49 <Peaker> 33% faster that way
03:05:02 * hackagebot eros-http 0.6.0.1 - JSON HTTP interface to Eros.  http://hackage.haskell.org/package/eros-http-0.6.0.1 (pharpend)
03:05:06 <Peaker> definitely worth a dozen seconds or two of compile-time in a release build
03:05:56 <phaazon> I have a page called /upload, it checks the session (cookie) ; if the cookie is not there, it displays a form (login / password). you enter your credentials, and then it redirects to a page called /login ; now, if the cookie is there, it also redirects to the login page, which basically lookup the credentials sha3 hash in DB to check against
03:06:00 <Peaker> I wish there was a pragma to INLINE ALL THE THIGNS
03:06:13 <phaazon> but in the first case, the credentials are in post arguments
03:06:22 <phaazon> in the second, just cookie values
03:06:25 <phaazon> how could I unify that?
03:06:41 <phaazon> the single thing I see is to put the cookie values in the post
03:07:53 <aksono> phaazon: sorry, cannot help you, but have you tried #happs?
03:09:24 <phaazon> not yet, yeah.
03:09:25 <phaazon> thank you
03:10:03 * hackagebot gloss-banana 0.1.0.3 - An Interface for gloss in terms of a reactive-banana Behavior.  http://hackage.haskell.org/package/gloss-banana-0.1.0.3 (Twey)
03:10:45 <jle`> Peaker: i think binary size is also an issue
03:11:34 <Peaker> jle`: I think the priorities are nuts. 30% faster is worth it all. C++ does the right trade-off.  Specialize everything, blow up exe size, but expose inline opportunities, allow unboxing everything, etc
03:12:16 <Peaker> or at least we should have -Osize vs. -Operformance  to tell what we care about
03:20:50 <aksono> app = StateA ???? (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app) How can i set the ???? to the inner m?
03:24:45 <ph88> let N = 8    <interactive>:61:5: Not in scope: data constructor `N'   why can' t i assign this variable ?
03:25:04 * hackagebot hsexif 0.5.0.3 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.5.0.3 (EmmanuelTouzery)
03:25:27 <aksono> ph88: let n = 8
03:25:36 <ph88> that works
03:25:42 <ph88> why not capital ?
03:25:46 <aksono> uppercase is for datatyps or data constructors
03:25:58 <ph88> oh
03:26:15 <ph88> just for first letter? or no uppercase in variable names allowed ?
03:26:18 <aksono> like data S = MkS Int or something
03:26:26 <aksono> just the first
03:26:29 <ph88> ok
03:27:18 <aksono> that is why ghci tells you: Not in scope: data constructor `N'
03:28:09 <ph88> [j*2*pi*k | k <- [0..nL-1]]      Couldn't match expected type `Complex Double'                 with actual type `Integer'     In the second argument of `(*)', namely `k'
03:28:19 <ph88> when i type a number for k it works without a problem
03:28:40 <ph88> λ> j*2*pi*4 0.0 :+ 25.132741228718345
03:29:03 <Pythonfant> if I enable library profiling in .cabal/config I get http://lpaste.net/107780 when trying to compile, it seems to work but I guess this error shouldn't show up
03:29:31 <Maxdamantus> ph88: try fromInteger k
03:29:57 <ph88> oki
03:30:05 * hackagebot http-client 0.3.6 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.6 (MichaelSnoyman)
03:30:07 * hackagebot http-conduit 2.1.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4 (MichaelSnoyman)
03:30:14 <ph88> fromIntegral  maybe ?
03:31:06 <Maxdamantus> or that, yes.
03:31:15 <Maxdamantus> Depends what `nL` is.
03:31:52 <ph88> 8
03:31:52 <Hrumph> hi
03:32:01 <ph88> let nL = 8
03:32:12 <Maxdamantus> Then fromInteger would work.
03:32:29 <Maxdamantus> assuming you don't constrain the type in another way.
03:32:31 <Hrumph> i'm trying to work with existentials for the first time
03:32:46 <Hrumph> the following isn't compiling complaining about not in scope type variable a
03:32:50 <Hrumph> data QClassAble = forall a . QClass a =>  QCALeaf (Entity a) | QCANode (Entity a) [(Text , QClassAble)]
03:33:18 <merijn> Hrumph: Only the first constructor is existential, the second has no forall
03:33:53 <ph88> what's the difference between integral and integer ?
03:33:54 <merijn> Hrumph: Before you invest a lot of time into existentials, are you familiar with the existential antipattern?
03:33:59 <Hrumph> oh so can i use the forall again for the second constructor?
03:34:12 <Hrumph> merijn: never heard of that
03:34:14 <Maxdamantus> ph88: Integer is a type, Integral is a class.
03:34:14 <merijn> ph88: Integral is a typeclass for Integral values, Integer is a concrete type
03:34:21 <merijn> @where existential-antipattern
03:34:21 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
03:34:45 <merijn> Hrumph: The short summary of that blog is "most times when you think 'I want existentials' you probably don't"
03:34:50 <ph88> what can also be a part of the Integral typeclass next to Integer ?
03:35:02 <Maxdamantus> ph88: Int, Int32, Int16, etc
03:35:07 <ph88> existentials ?
03:35:13 <merijn> Word8, Word16, etc.
03:35:24 <ph88> oh that's good to know that haskell has support for different ints
03:35:40 <Hrumph> merijn: i know that i don't need them but i think its for the good this time
03:36:47 <merijn> Hrumph: Ok, I still recommend reading that blog post, since it covers alternative ways of doing things so if/when you have problems with existentials becoming to boilerplatey you know what else you could do
03:37:40 <phaazon> hm
03:37:44 <phaazon> The error was "SqlError {seState = "", seNativeError = -1, seErrorMsg = "In HDBC execute, received [SqlString \"phaazon\"] but expected 0 args."}"
03:37:53 <phaazon> what the hell does that mean? :D
03:38:16 <phaazon> the SQL query is
03:38:17 <phaazon>       rows <- quickQuery conn "select credPwd from Credentials where credName = '?'" [toSql loginInfo]
03:38:22 <merijn> ph88: The explicit coercions between haskell integer types can be a bit annoying, but if you ever spent a week hunting down a silent coercion bug in C you realise it's far less annoying than the alternative :p
03:38:37 <ph88> :P
03:38:43 <ph88> just getting started !
03:40:00 <phaazon> gonna try the strict version…
03:40:30 <ph88> when applying a function on a list how can i get the index ?
03:40:33 <phaazon> dammit, still nothing
03:40:48 <phaazon> ph88: f (zip [0..] yourList)
03:40:58 <merijn> ph88: Easiest way is probably zipping with [0..]
03:41:18 <ph88> o_O
03:41:23 <merijn> > zip [0..] ['a', 'b', 'c', 'd', 'e', 'f']
03:41:25 <lambdabot>  [((),'a')]
03:41:27 <ph88> ok i understand it ..,, but looks weird
03:41:28 <merijn> eh
03:41:33 <merijn> whut
03:41:42 <phaazon> or…
03:41:59 <merijn> Did some idiot provide a num instance for ()?!
03:42:04 <merijn> > 0 :: ()
03:42:05 <lambdabot>  ()
03:42:08 <merijn> ...
03:42:10 <MP2E> lolol
03:42:11 <merijn> I hate lambdabot
03:42:15 <MP2E> @undefine
03:42:15 <lambdabot> Undefined.
03:42:16 <ph88> can i zip it into a map instead of a tuple can call it index and value ?  or is that bad practice ?
03:42:22 <merijn> > zip [0..] ['a', 'b', 'c', 'd', 'e', 'f'] :: [(Int, Char)]
03:42:23 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
03:42:37 <merijn> > 0 :: ()
03:42:38 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal ‘0’
03:42:47 <merijn> > zip [0..] ['a', 'b', 'c', 'd', 'e', 'f']
03:42:48 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
03:42:53 <merijn> Right, all is well
03:42:54 <phaazon> > let l = "hey, ph88!" in l & imapped %@~ (,)
03:42:56 <lambdabot>  [(0,'h'),(1,'e'),(2,'y'),(3,','),(4,' '),(5,'p'),(6,'h'),(7,'8'),(8,'8'),(9,...
03:42:58 <phaazon> :)
03:43:08 <phaazon> (I love that (%@~) operator :D)
03:43:11 <merijn> ph88: I don't think lens line noises like that is very helpful for newbies
03:43:14 <merijn> errr
03:43:18 <merijn> s/ph88/phaazon
03:43:23 <phaazon> yeah, you’re right
03:43:29 <phaazon> just there to point out it exists though
03:43:39 <phaazon> the zip version is definitely a go for newcomers :)
03:44:07 <merijn> ph88: Well, you can use Map's fromList together with the zip approach to do that, yes
03:44:32 <merijn> :t M.fromList (zip [0..] ['a', 'b', 'c', 'd', 'e', 'f'])
03:44:33 <lambdabot> (Ord k, Num k, Enum k) => M.Map k Char
03:44:39 <merijn> eh
03:44:43 <merijn> Polymorphism!
03:44:45 <ph88> will it make the program slower ?
03:44:53 <merijn> :t M.fromList (zip [0..] ['a', 'b', 'c', 'd', 'e', 'f']) :: M.Map Int Char
03:44:53 <lambdabot> M.Map Int Char
03:45:08 <merijn> ph88: "It depends", what are you trying to do with the list? :)
03:45:09 <phaazon> ph88: a zip like that will be fast
03:45:45 <phaazon> > ['a'..'f']
03:45:46 <lambdabot>  "abcdef"
03:45:50 <ph88> i want to multiple the index with a number
03:46:30 <MP2E> > zipWith (*) [0..] [1,2,3,4,5]
03:46:32 <lambdabot>  [0,2,6,12,20]
03:47:53 <phaazon> zipWith (\i x -> (i*9,x)) [0..] "hey, ph88!"
03:47:57 <phaazon> > zipWith (\i x -> (i*9,x)) [0..] "hey, ph88!"
03:47:58 <lambdabot>  [(0,'h'),(9,'e'),(18,'y'),(27,','),(36,' '),(45,'p'),(54,'h'),(63,'8'),(72,'...
03:48:22 <phaazon> you can see zipWith in terms of zip where zip = zipWith (,)
03:48:22 <phaazon> :)
03:50:54 <rio> phaazon: that's zip in terms of zipWith ;)
03:51:31 <phaazon> yeah
03:51:36 <phaazon> all the thing around
03:51:36 <phaazon> :D
03:51:46 <aksono> app = StateA ???? (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app) -- How can i set ???? to the inner m?
03:52:02 <phaazon> « you may want to see zipWith as zip in terms of zipWith as stated by zip = zipWith (,) »
03:52:37 <phaazon> ok, I have a pretty weird issue with HDBC with the Sqlite3 backend
03:52:39 <phaazon> quickQuery' conn "SELECT * from Credentials where credName = '?'" [toSql ("phaazon" :: String)]
03:52:46 <phaazon> that errors to
03:52:52 <phaazon> *** Exception: SqlError {seState = "", seNativeError = -1, seErrorMsg = "In HDBC execute, received [SqlString \"phaazon\"] but expected 0 args."}
03:53:07 <phaazon> if I put my nick directly in the query
03:53:15 <phaazon> it doesn’t raise no exception
03:53:17 <phaazon> I don’t get it :D
03:58:46 <aksono> phaazon: maybe remove the ' around the '?'
04:00:33 <ph88> how can i put a list over several lines ?
04:00:40 <rio> phaazon: zipWith f l1 l2 = map (uncurry f) $ zip l1 l2
04:00:47 <ph88> it has long numbers and i rather have them below each other
04:00:53 <rio> phaazon: so thats zipWith in terms of zip ;)
04:03:18 <mmmm> ph88: Press enter?
04:03:19 <rio> @pl \f l1 l2 -> map (uncurry f) $ zip l1 l2
04:03:20 <lambdabot> (. zip) . (.) . map . uncurry
04:03:45 <aksono> ph88: http://lpaste.net/3347716575309332480 like this?
04:05:08 * hackagebot xml-conduit 1.2.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.1 (MichaelSnoyman)
04:05:39 <flan3002> Upon encountering cabal: Codec.Compression.Zlib: premature end of compressed stream, I read that removing all downloaded packages ($ rm -rf ~/.cabal/packages/hackage.haskell.org/*, followed by redownloading each of them solves it. The reason for this seem to be corrupted archive files, which is plausible, considering my awful connection, but shouldn't that be circumenvented via a hashsum?
04:05:52 <ph88> oh i had the number left from the = on the line below
04:07:10 <ph88> Import Data.Complex      main = do    it says Parse error: naked expression at top level    for the Import line
04:07:22 <ph88> hhmm proably dont even need this import
04:07:46 <ph88> eh no i do !
04:07:47 <benmachine> flan3002: perhaps it should, but regrettably it is not
04:08:27 <flan3002> benmachine: But isn't it a trivial™ thing to add for anyone familiar with cabals code?
04:09:00 <benmachine> flan3002: it's bery much achievable, but I guess the demand for it hasn't been too high
04:09:28 <flan3002> Hm, that's... annoying. Thank you, benmachine. :)
04:09:31 <benmachine> I've heard that someone's been working on cryptosigning packages, maybe that would solve the problem as a side effect
04:09:51 <benmachine> might be considered overkill though :P
04:12:44 <bergmark> ph88: Import -> import
04:13:47 <rio> how do you come up with "(. zip) . (.) . map . uncurry" from "\f l1 l2 -> map (uncurry f) $ zip l1 l2"? are you guys able to look at the pointfree version and tell what its doing?
04:14:06 <ph88> thx bergmark
04:14:20 <ph88> Couldn't match expected type `IO t0' with actual type `[b0]'     In the expression: main     whats this ?
04:14:52 <rio> @pl \f -> (l1 l2 -> map (uncurry f) $ zip l1 l2)
04:14:53 <lambdabot> (line 1, column 16):
04:14:53 <lambdabot> unexpected '>'
04:14:53 <lambdabot> expecting operator
04:14:57 <Axman6> rio: after a while you can figure it out, but generally pointfree code is often not something to aim for because it can make fur unreadable code
04:15:13 <Axman6> also, it's called pl in lambdabot because it is pointless
04:15:22 <rio> @pl \f -> (\l1 l2 -> map (uncurry f) $ zip l1 l2)
04:15:23 <lambdabot> (. zip) . (.) . map . uncurry
04:15:42 <Axman6> :t \f -> (\l1 l2 -> map (uncurry f) $ zip l1 l2)
04:15:43 <lambdabot> (a -> b1 -> b) -> [a] -> [b1] -> [b]
04:15:53 <Axman6> that's just zipWith by the way
04:15:56 <Axman6> :t zipWith
04:15:57 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
04:16:13 <rio> i know, that's why i'm looking at it
04:17:06 <rio> in pointed style it's easy to read, zip the lists, map uncurry f over it
04:17:21 <rio> in pointless style i look at it like o_O
04:17:49 <Axman6> try applying arguments one at a time:
04:18:31 <Axman6> (. zip) . (.) . map . uncurry $ f -> ((. zip) ((.) (map (uncurry f)))
04:19:08 <Axman6> ((. zip) ((.) (map (uncurry f))) -> ((.) (map (uncurry f)) . zip
04:19:32 <Axman6>  (((.) (map (uncurry f)) . zip) l1
04:19:59 <Axman6> bah, yeah it's not worth it, don't bother :P
04:20:16 <Axman6> it'll become clear with time, but it's certainly not obvious how it works
04:21:00 <rio> i guess it's thinks like foo . (.) . bar that really grind the gears
04:21:08 <rio> *things
04:22:31 <ph88> can anyone review my small program?  https://www.fpcomplete.com/project/52490/i93L7ljYEI
04:23:29 <cin> Axman6, i think if pointless programming was more useful people would develop better intuitions for it, but it's kind of awful in haskell with comparison to e.g. factor, so the brain optimizes/makes defenses to repel such stuff
04:23:40 <rio> @pl \l1 l2 -> map (uncurry f) $ zip l1 l2)
04:23:40 <lambdabot> (line 1, column 38):
04:23:40 <lambdabot> unexpected ')'
04:23:40 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
04:23:56 <cin> rio, paren
04:23:56 <rio> @pl \l1 l2 -> map (uncurry f) $ zip l1 l2
04:23:56 <lambdabot> zipWith f
04:24:08 <rio> he, that's cheating
04:24:10 <Axman6> "print sum map" looks very wrong
04:24:53 <Axman6> factor is necessarilly pointfree though right? that's kind of the point
04:26:25 <cin> Axman6, sure, so it naturally flows nicely
04:26:29 <Axman6> cin: also I don't feel that it really is powerful. it often makes for unclear code. there's certainly a lot people can do to make sure APIs are minimally pointfree (putting the most likely to change input last for a function etc.) but it isn't something one should persue more than that
04:26:57 <Axman6> cin: well, I'm not sure I agree, there's a lot of functions which exist just to move things into the right order
04:27:33 <cin> what do you disagree with? i'm pretty sure i agree with you and was adding to it
04:27:48 <Axman6> that it flows naturally
04:28:14 <Axman6> it's only "natural" because someone has written dup and uh.. under? and whatever else for you already
04:29:17 <Khanage> @ty dup
04:29:18 <lambdabot> Not in scope: ‘dup’
04:29:20 <Axman6> all of which are like flip and using ap and sectioned (.) etc
04:29:56 <friden> question, instead of a function and a list of things to apply the functon to, like map do, i want to have a list of functions, and a list of values, and then apply the functions on the values of corresponding index. it seems like there is a function for this in prelude, but i can't find it
04:30:04 <friden> i guess i dont know what im looking for exactly
04:30:19 <Hafydd> friden: zipWith ($)
04:30:25 <friden> but i need something like [(a -> b)] -> [a] -> [b]
04:30:46 <Hafydd> @ty zipWith ($)
04:30:47 <lambdabot> [b -> c] -> [b] -> [c]
04:31:06 <friden> oh, cool
04:31:24 <friden> so... $ "takes away" the first input to zipwith? :S
04:31:29 <friden> in this case?
04:31:49 <Hafydd> No, $ is the function that applies its left argument to its right argument, as a function.
04:32:34 <friden> oh god, it takes a while to wrap my head around this xD, i've used $ a lot but not like this xD
04:32:48 <friden> but thanks, ill use it and try to understand it^^
04:32:48 <rio> friden: f $ x = f x
04:32:54 <Hafydd> Oh, are you referring to the partial application of zipWith? Yes, I suppose you could say that.
04:33:07 <friden> rio: yeah, that i understand
04:33:24 <rio> friden: so zipWith ($) [f g ...] [x y ...] = [(f x) (g y) ...]
04:33:50 <cin> Axman6, have you read "Why Concatenative Programming Matters"? http://evincarofautumn.blogspot.it/2012/02/why-concatenative-programming-matters.html
04:34:21 <friden> awesome
04:34:26 <cin> Axman6, i think it demonstrated to me that Haskell's few functions for doing point-free programming aren't really anywhere near the convenience of Factor
04:34:30 <friden> rio: nice, thanks
04:35:10 * hackagebot HueAPI 0.2 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2 (SjoerdVisscher)
04:35:30 <cin> Axman6, whether applicative or concatenative is a better style is another debate -- but i think in factor point-free style is about as natural as applicative is in haskell
04:37:38 <hexagoxel> ph88: you probably want "print $ sum $ map ...", or with parenthesis, "print (sum (map ..))". (my "review" would be "that does not even compile" :D)
04:37:39 <phaazon> yeah!
04:37:41 <phaazon> http://phaazon.net/browse
04:37:44 <phaazon> oops
04:37:47 <phaazon> http://phaazon.net/
04:38:00 <phaazon> the authentication is now plainly functional
04:38:13 <phaazon> still needs a logout button :D
04:40:24 <Axman6> cin: https://github.com/leonidas/codeblog/blob/master/2012/2012-02-17-concatenative-haskell.md why perhaps concatenative programming doesn't matter so much (written in response to the article you liked)
04:47:07 <Axman6> @quote stack-calculator
04:47:07 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
04:49:27 <cin> Axman6, that's a neat article. it demonstrates you can embed concatenative programming in an applicative language. so what?
04:50:10 <cin> Axman6, i can do pure functional programming in python. perhaps functional programming doesn't matter so much
04:50:26 <Axman6> it probaaly doesn't
04:50:47 <cin> but the article demonstrates the issue, really
04:51:21 <cin> the author had to rewrite Prelude in a DSL
04:51:50 <cin> he couldn't just take existing Haskell and do concatenative programming
04:52:36 <Axman6> well no, there's no implicit stack, but I'm nut sure I see what point you're making
04:53:27 <cin> <Axman6> it's only "natural" because someone has written dup and uh.. under? and whatever else for you already
04:53:41 <cin> <cin> Axman6, i think it demonstrated to me that Haskell's few functions for doing point-free programming aren't really anywhere near the convenience of Factor
04:53:45 <cin> <cin> Axman6, whether applicative or concatenative is a better style is another debate -- but i think in factor point-free style is about as natural as applicative is in haskell
04:53:50 <cin> ^
04:54:12 <cin> it's only "natural" because the whole language is the DSL which the author of that post tried to embed into haskell
04:54:21 <Axman6> but it's also trivial to implement most of the functions necessary to make it easy, but it's not exacly something people have a huge need for
04:54:43 <cin> yes:
04:54:43 <cin> <cin> Axman6, whether applicative or concatenative is a better style is another debate
04:55:03 <cin> are you just trying to contradict anything i say because you don't like stack languages? ;)
04:55:12 * hackagebot hspec-expectations 0.6.0.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.6.0.1 (SimonHengel)
04:58:39 <Axman6> well, it seems to me from the above links that it's possible (and basically trivial) to get the advantages of concatenative programming (with type safety!) in Haskell, but almost certainly not as easy to go the other way. also I think it's all just syntax and it's not really important.
04:59:49 <cin> rewriting your whole prelude is trivial?
05:00:10 <cin> python programmers say the same thing about functional support in python
05:00:28 <Axman6> Haskell doesn't aim to be a concatenative language, so its prelude wasn't written as such... what's your point?
05:00:29 <cin> "it's easy to write pure code", "lambdas are just neat syntax" and it's just there to appease the functional programmers and doesn't matter
05:01:15 <Axman6> I'm quite confused at the moment...
05:01:25 <cin> Axman6, you seem to be arguing (1) that because you can implement on style inside another language, this is the same as having the language built upon that from scratch
05:01:34 <Axman6> not at all
05:01:44 <Axman6> but it is easy to do, if that's something you'd want
05:01:54 <cin> Axman6, and (2) that because such style hasn't "taken off" embedded in said language means it's a useles feature/triviality
05:02:21 <Axman6> my point is that syntax isn't really important
05:02:29 <danilo2> Hello! I've got a theoretical question - When I'm writing an instance and Haskell is able to infer all needed thngs (all the head variables, premises etc) based on the implementation, why there is no option to just skip writing the head, poremise etc? Of course It would not work always, but it would be simmilar to skiping the type of a function.
05:02:56 <cin> Axman6, uh huh
05:03:35 <aksono> app = StateA ???? (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app) -- How can i set ???? to the inner m?
05:04:07 <Axman6> what is StateA?
05:04:28 <aksono> http://lpaste.net/8131112620271861760  -- Axman6
05:04:47 <aksono> StateArrow with static metainformation
05:09:49 <zwer> lllllllllllllllllllllk;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
05:10:35 <Axman6> hi
05:10:46 <Axman6> oh cat overloard
05:13:07 <friden> what is the fastest way to create a list a, from list b, containing all elements of a execpt from one element at a known index?
05:13:20 <friden> i figure take and drop is slow if we have a large list?
05:13:59 <Axman6> :t delete
05:14:00 <lambdabot> Eq a => a -> [a] -> [a]
05:14:05 <Axman6> :t deleteAt
05:14:05 <lambdabot>     Not in scope: ‘deleteAt’
05:14:06 <lambdabot>     Perhaps you meant one of these:
05:14:06 <lambdabot>       ‘M.deleteAt’ (imported from Data.Map),
05:14:09 <Axman6> hmm
05:14:35 <cin> :t map snd . filter ((== 2) . fst) . zip [0..]
05:14:36 <lambdabot> [b] -> [b]
05:14:46 <cin> :t \i -> map snd . filter ((== i) . fst) . zip [0..]
05:14:47 <lambdabot> (Num b1, Eq b1, Enum b1) => b1 -> [b] -> [b]
05:15:27 <quchen> :t \n -> drop 1 . take (n-1)
05:15:27 <lambdabot> Int -> [a] -> [a]
05:15:37 <quchen> Hm wait that cuts off.
05:15:42 <cin> > let deleteAt i  = map snd . filter ((== i) . fst) . zip [0..] in dropAt 2 [1..5]
05:15:43 <lambdabot>  Not in scope: ‘dropAt’
05:15:43 <lambdabot>  Perhaps you meant one of these:
05:15:43 <lambdabot>    ‘drop’ (imported from Data.List),
05:15:43 <lambdabot>    ‘BSC.drop’ (imported from Data.ByteString.Char8),
05:15:43 <lambdabot>    ‘BSLC.drop’ (imported from Data.ByteString.Lazy.Char8)
05:15:44 <quchen> Anyway, combine those basic list functions.
05:15:49 <cin> > let deleteAt i  = map snd . filter ((== i) . fst) . zip [0..] in deleteAt 2 [1..5]
05:15:50 <lambdabot>  [3]
05:15:54 <cin> ah, duh
05:16:00 <cin> > let deleteAt i  = map snd . filter ((/= i) . fst) . zip [0..] in deleteAt 2 [1..5]
05:16:01 <lambdabot>  [1,2,4,5]
05:16:25 <Axman6> > let deleteAt n [] = []; deleteAt 0 (x:xs) = xs; deleteAt n (x:xs) = x : deleteAt (n-1) xs in deleteAt 3 "Hello, world!"
05:16:27 <lambdabot>  "Helo, world!"
05:16:48 <Pythonfant> > (\(a,b) -> a ++ b) . (splitAt 5) $ [1..20]
05:16:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
05:16:59 <quchen> > let deleteAt n xs = let (b,a) = splitAt n xs in b ++ drop 1 a in deleteAt 3 [0..10]
05:17:00 <lambdabot>  [0,1,2,4,5,6,7,8,9,10]
05:17:14 <friden> omg xD hahaha, 5 different replies xd
05:17:20 <friden> i love this channel xd
05:17:24 <Pythonfant> yeah I forgot the drop 1
05:17:27 <cin> > splitAt 3 [1..5] -- this doesn't drop the element
05:17:29 <lambdabot>  ([1,2,3],[4,5])
05:19:03 <cin> Axman6's is the most efficient, mine second, quchen's third
05:19:13 <Axman6> my version avoids traversing the list twice (splitAt's default implementation uses take and drop)
05:19:15 <cin> pick your poison
05:20:02 <friden> haha, then i'll pick axmans^^
05:20:15 * hackagebot scotty 0.8.2 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.8.2 (SimonHengel)
05:20:31 <cin> if you're doing many operations like this, a Vector might be a more appropriate type
05:20:58 <aksono> app = StateA ???? (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app) -- How can i set ???? to the inner m? -- http://lpaste.net/8131112620271861760
05:21:01 <Axman6> I'm not sure it would be better
05:21:23 <cin> Axman6, me neither, hence 'might', Argumentative6
05:21:37 <quchen> cin: Did you benchmark?
05:21:43 <Axman6> aksono: I don't think you can, it's not available to the outer StateA constructor
05:22:19 <Axman6> possibly could be done by tying the knot, but I don't think so
05:22:39 <cin> quchen, nope but i suspect an unboxed vector can be copied inside cache memory much faster than traversing and constructing a linked list across main memory
05:23:39 <aksono> Axman6: so i cannot have higher order arrows with static meta information?
05:23:56 <Axman6> I don't know what that means
05:24:38 <Axman6> aksono: but, why not just provide an initial m to app, and then give the new m to the recursive call to app?
05:24:54 <Axman6>  app m = StateA m (arr (\((StateA m f, x), s) -> (f, (x, s))) >>> app m)
05:25:06 <cin> Axman6, i think it's thrice traversing too
05:25:25 <Axman6> the (++) too, yes
05:25:33 <Axman6> though that should fuse nicely
05:25:42 <quchen> cin: I didn't see any unboxed vectors there. And they wouldn't be suitable for the function anyway, since they're stricter than boxed ones.
05:25:45 <aksono> Axman6: because it does not typecheck :(
05:25:52 <Axman6> but the take and drop bits can't be fused
05:25:59 <cin> quchen, unboxed vectors where?
05:26:19 <Axman6> aksono: you're going to need to say more than that to get some help :\
05:26:20 <quchen> "<cin> quchen, nope but i suspect an unboxed vector can be copied inside cache memory much faster" <- there
05:26:52 <cin> quchen, what are you talking about?
05:27:00 <quchen> Fotget about it.
05:27:10 <cin> <cin> if you're doing many operations like this, a Vector might be a more appropriate type
05:28:25 <aksono> http://lpaste.net/8131112620271861760 -- Axman6 here is the error
05:29:09 <Axman6> ah. yeah in that canse I'm not sure it's possible
05:30:45 <Axman6> case*
05:32:14 <aksono> ok thx, that would be unfortunate
05:48:01 <joshkirklin> is there a language extension that allows me to associate arbitrary data with an instance of a typeclass?
05:49:20 <Axman6> like what?
05:50:57 <joshkirklin> actually scrap that, I can do what I want without any extensions
06:01:43 <nawal> hey guys, quick question: I have played with bullet physics library in C before, and now I'm doing this in Haskell. I want to run the physics in its own thread, using forkIO, and run a server in the main thread (this server will be called upon to add and remove objects from the physics, and also keep track of other things.)  Since the bullet library is wrapped in the IO monad, I can't put it in STM to keep the physics updates
06:01:43 <nawal>  and the server actions on the physicw world atomic.
06:02:08 <kvanb> you actually want to use MVar for that
06:02:12 <nawal> I looked into FFIs, and it seems side effect has to stay in the IO monad
06:02:17 <kvanb> by the way, why does IO stop you from using stm?
06:02:46 <kvanb> :t atomically
06:02:47 <lambdabot> Not in scope: ‘atomically’
06:03:17 <kvanb> nawal: http://hackage.haskell.org/package/stm-2.2.0.1/docs/Control-Monad-STM.html#v:atomically
06:03:56 <nawal> kvanb, I have the opposite problem: the bullet physics library is wrapped in the IO monad
06:04:05 <nawal> so I can't call it from STM
06:04:16 <nawal> Having looked at MVar, it says " They are appropriate for building synchronization primitives and performing simple interthread communication; however they are very simple and susceptible to race conditions, deadlocks or uncaught exceptions. Do not use them if you need perform larger atomic operations such as reading from multiple variables: use STM instead."
06:04:21 <nawal> (the docs do)
06:04:40 <Axman6> kvanb: side effects can't be used within STM because they cannot be rolled back
06:04:48 <Axman6> well, IO cannot be rolled bacl
06:04:55 <kvanb> he should not be calling into bullet from his stm transaction though
06:05:19 <Axman6> right
06:05:23 <kvanb> I can't even think of a way to design it so what he says is a problem is a problem ..
06:05:35 <kvanb> so the issue actually eludes me ..
06:06:11 <kvanb> fwiw: your stm transactions should be as small as possible. That's vital for the performance of stm
06:06:12 <Axman6> nawal: you shou;dn't be doing very much within an STM transaction, definitely not much computation
06:06:13 <nawal> kvanb, I wanted to call bullet from an stm transaction so that the bullet world gets updated atomically, while another thread has a snapshot of the state of the bullet world that it tells other code about.
06:06:31 <nawal> Axman6, that makes sense. So MVar is the way to do?
06:06:35 <nawal> *to do it
06:06:36 <kvanb> do the computation in the bullet thread
06:06:42 <kvanb> then update the shared stm state atomically
06:06:44 <Axman6> well, not necessarilly
06:06:48 <nawal> ah I see
06:07:11 <kvanb> while you do something atomically, the other thread blocks
06:07:12 <nawal> right that makes more sense I thnk.
06:07:13 <nawal> thanks!
06:07:14 <kvanb> you may as well be using one thread.
06:07:28 <kvanb> (if it's waiting on the TVar, at least)
06:08:07 <Axman6> if you only have a single mutable variable, STM can be overkill; an IORef can get you the same atomicity in cases when it's the only thing changing using atomicModifyIORef
06:08:09 <nawal> yeah ok! So main thread will do bullet physics, store results (a list of positions and rotations) in a TVar atomically, and the other thread will read this list in and pass it on to the rest of the system
06:08:51 <nawal> thanks guys!
06:10:44 <asfp``> how do I write this function: (a -> Bool) -> a -> m a that I can use like so:  return 3 >>= guardish . (< 4) >>= further  so guardish returns mzero if the condition does not hold and applies the condition on the argument?
06:11:27 <kvanb> :t guard
06:11:27 <lambdabot> MonadPlus m => Bool -> m ()
06:11:46 <kvanb> your usage and your type don't match
06:12:10 <asfp``> kvanb: but how do I access the parameter?
06:12:31 <kvanb> guardish . (<4) is nothing like (a -> Bool)
06:12:48 <kvanb> the <4 part just means that guardish looks more like
06:12:55 <kvanb> guardish :: Bool -> m a
06:15:30 <Tjr> TIL Those scary Arrows are just morphisms, known from category theory.
06:15:55 <asfp``> I want (guardish (< 4)) :: a -> m a  and guardish p a = if (p a); then return a; else mzero
06:17:32 <merijn> asfp``: Isn't that just "guard . (<4)"?
06:17:40 <merijn> oh, no
06:17:48 <merijn> I guess that returns m ()
06:18:22 <Tjr> How does the category Hask make provisions for partial functions (e.g. head [])?
06:18:49 <merijn> Tjr: By having _|_ (bottom) which inhabits every type
06:18:50 <Tjr> Does exception handling fit into the Hask framework?
06:19:22 <merijn> Tjr: bottom is the value representing non-terminating/crashing (or exception throwing) computations
06:19:39 <Tjr> ok, exceptions are also modeled as undefined.
06:20:15 <Tjr> Since category theory wants the associative law for morphisms, how would you handle a lie algebra?
06:20:40 <Tjr> (or gyrovectors etc)
06:21:12 <merijn> No clue, I'm not familiar with lie algebras :)
06:21:34 <Tjr> ok, thanks :-)
06:22:13 <Tjr> On a whim I googled "do you even lift", and now I'm running down the rabbit hole with monad transformers and category theory.
06:22:23 <merijn> Tjr: If you're interested in exception handling, there is a paper that describes the semantics for haskell's imprecise exceptions
06:23:17 <Tjr> merijn: I'll take a glance and bookmark it, then save it for when I can't avoid exceptions
06:23:44 <merijn> because non-strictness and exceptions also result in weird interactions, such as "case 1 of 1 -> error "foo"; _ -> error "bar"" being allowed to result in 'error "bar"' happening at runtime
06:25:01 <Tjr> that looks like it should be a bug
06:25:03 <merijn> https://research.microsoft.com/en-us/um/people/simonpj/papers/imprecise-exn.htm
06:26:23 <Tjr> is that implemented in haskell?
06:27:41 <Tjr> i.e. do I need to worry about exceptions that "can't happen"?
06:30:35 <merijn> Tjr: See the top answer here: https://stackoverflow.com/questions/11070690/how-do-exceptions-in-haskell-work
06:30:39 <Tjr> From the paper: "The compiler, or the programmer, might want to improve performance by changing the program's evaluation order."
06:30:39 <Tjr> This nagging voice in the back of my head complains about just that, for monads and monad transformers.
06:30:39 <Tjr> Is there some way to stack monad transformers, and leave it up to the compiler to optimize their ordering?
06:32:14 <merijn> Tjr: No, because the resulting semantics depends on the ordering
06:32:36 <merijn> Tjr: You might be interested in extensible-effects/effects, which try to tackle just that problem
06:33:57 <Tjr> I've got this hunch that you'll squander a lot of freedom to optimize things, if you give in to the temptation to let >>= fix the order of function composition once and for all.
06:35:16 <merijn> Tjr: Programmers tend to prefer well-defines semantics over optimisation :p
06:36:59 <asfp``> merjin: Seems like   mfilter (> 4) . return is my guardish
06:37:34 <Tjr> The mathematica language approach is this: the interpreter is allowed to evaluate not just the outermost layer of an expression (as haskell does), but also inner layers. Lots of functions have builtin attributes to make that easier. For example, sums and products ignore the ordering of their arguments (and there's a flag for your functions to do the same).
06:38:24 * Tjr reads the effects-ordering paper
06:38:48 * Tjr has come down a deep rabbit hole, starting off of "do you even lift"
06:44:15 <joash> ignore *  JOINS CRAP
06:45:45 <hexagoxel> hmm, fmap'ing breaks sharing. can i prevent this somehow?
06:48:56 <hexagoxel> e.g. x = Leaf 1; y = BinNode x x; z = fmap show y (with the trivial functor instance)
06:50:06 <hexagoxel> y will share the leaf, but z will have two (equal) leafs.
06:53:10 <hexagoxel> also, show will be executed twice
06:54:59 <ion> You could use http://hackage.haskell.org/package/data-reify-0.6/docs/Data-Reify.html
06:56:35 <danilo2> Hello! I've got a datatype "data Arg (name :: Symbol) = Arg". Is there any nicer way of creating values of this type than ' let x = Arg :: Arg "test" '? I want to be able to write something like ' let x = arg "test" '. I know we can use TH here, but are there any alternatives?
06:57:06 <bms1> hexagoxel: An obvious but possibly not-great answer is to apply "show" before building the tree...
06:59:02 <phaazon> do you know a way to know the mime of a file?
06:59:11 <phaazon> I don’t want to deduce from extension
06:59:26 <timd> Where can I find an attoparsec URL parser? I found this: https://hackage.haskell.org/package/URLb , but it's marked as deprecated.
07:00:03 <ion> @hackage magic perhaps, phaazon
07:00:03 <lambdabot> http://hackage.haskell.org/package/magic perhaps, phaazon
07:00:34 <phaazon> thank you ion
07:02:33 <dfeuer> danilo2, why would you need ::Arg? And what is a Symbol? Is that a synonym for the synonym String?
07:03:06 <saep> Is there some way to turn off compiler warnings for this error: "No explicit method or default declaration for `Data.Binary.put'"? (I'm using the DervieGeneric pragma.)
07:04:41 <hexagoxel> bms1: yeh of course, but i'd like the fmap in this case.
07:04:58 <danilo2> dfeuer: DataKinds. https://hackage.haskell.org/package/base-4.7.0.0/docs/GHC-TypeLits.html
07:05:55 <dfeuer> Oh, I totally misread what you were doing.
07:06:02 <dfeuer> I shouldn't come to #haskell this early in the day.
07:06:05 <bms1> hexagoxel: Additionally, you could build it as a Tree (Int, String) and fmap snd
07:08:27 <hexagoxel> ion: thanks for the pointer, but i am too dumb atm to understand how to apply that. would the core idea of that approach be that somehow i add unique id's to the values in order to make sharing observable?
07:08:27 <jollygood> is there no way to make `Data = Foo | Bar deriving (Enum, Bounded)' part of a Random class automatically?
07:14:51 <hexagoxel> data MappableTree a = forall b . ((a -> b) -> Tree b)
07:15:01 <latk> Does anyone know if it is possible to get flycheck-hdevtools in emacs working with sandboxes  ?
07:16:50 <augur> Hrumph: that type wont work at all
07:16:56 <augur> er
07:16:59 <augur> hexagoxel: ^
07:22:30 <Tjr> How does "import" handle the diamond problem? For example, symbol "sym" is defined in module A. Modules B and C use and reexport "sym". If my code imports B and C, will ghc know that B's and C's sym are the same?
07:25:59 <phaazon> does ghc uses gcc in any point?
07:27:01 <geekosaur> only if you use the deprecated -fvia-C. and maybe for some FFI stubs?
07:27:28 <phaazon> geekosaur: a friend thinks it uses gcc’s preprocessor to precompile source
07:27:46 <bernalex> doesn't it?
07:28:00 <geekosaur> oh, that. going away, I think. only with the CPP language option
07:28:11 <bernalex> isn't the root of a bunch of problems that clang doesn't support some gcc options
07:28:23 <geekosaur> and it's being replaced by a custom preprocessor because using C's is kinda dumb
07:29:00 <bernalex> gcc has an option that means the build doesn't die every time it encounters a ' character that isn't immediately closed, because in a standard cpp it is reserved for characters only. something like that.
07:29:00 <geekosaur> (there is already hscpp, it has had license issues)
07:30:29 <phaazon> ok
07:30:38 <phaazon> so why is still there a gcc dependency?
07:30:39 <hexagoxel> augur: yeah true; what about "data MappableTree a = MappableTree (forall b . (a -> b) -> Tree b)"? that seems to work so far
07:30:53 <bernalex> phaazon: because we haven't managed to shake it yet.
07:31:11 <bernalex> afaik
07:31:15 <phaazon> ok
07:31:38 <bernalex> phaazon: ask #ghc
07:34:45 <geekosaur> isn't finally removing that a 7.10 thing, with a hackaround for clang in 7.8?
07:34:46 <Hrumph> so haskell doesn't compile to C before going to assembly?
07:34:51 <geekosaur> not any more
07:35:05 <Hrumph> what is the compilation process like?
07:35:08 <geekosaur> -fvia-C is still there but deprecated
07:36:10 <hpc> the preferred path nowadays is through LLVM i think?
07:36:13 <geekosaur> haskell -> core -> stg -> cmm -> LLVM or assembler depending on options, roughly
07:36:29 <geekosaur> -fasm is default. -fllvm can produce better code in some cases but much worse in others
07:36:52 <geekosaur> although it can also be useful for cross-compilation and is how embedded ARM builds are done for the most part
07:36:57 <phaazon> oh
07:37:01 <phaazon> I thought core == C--
07:37:05 <phaazon> I was wrong then!
07:37:12 <geekosaur> no, core is a sort of "austere Haskell"
07:37:16 <phaazon> yeah
07:37:24 <phaazon> I already saw a few core
07:37:33 <phaazon> it shows dictionnary passing!
07:37:45 <bernalex> phaazon: core is way different
07:37:49 <geekosaur> cmm is vaguely C-like but not C compatible
07:37:53 <bernalex> phaazon: try opening ghci and doing :set -ddump-simpl
07:38:05 <bernalex> cmm is a language for compilers.
07:38:17 <merijn> I wouldn't even call cmm "C-like"
07:38:49 <bernalex> haskell is compiled: haskell -> core -> stg -> cmm -> c/llvm/assembly
07:38:59 <bernalex> merijn: indeed not. it makes no sense. C is supposed to be human-readable.
07:39:12 <merijn> With assembly being the default of those 3 last options
07:39:15 <bernalex> cmm stands out in compiler targeting languages in being *plaintext*, but it is not human-readable.
07:39:49 <merijn> The main reason to keep C around is for bootstrapping ports to new architectures that don't yet have a haskell compiler
07:40:16 <merijn> And once GHC's cross-compilation features shape up even that should be redundant
07:40:39 <bernalex> it works well to my knowledge though, so I doubt it will be ripped out if it's sitting there happily.
07:40:45 <dagle> But the C code that ghc produces isn't super portable last time I checked.
07:40:54 <haasn> bernalex: Whoa, I never knew -ddump-simpl works in GHCi
07:41:42 <bernalex> haasn: -ddump-cmm, -ddump-llvm, -ddump-stg, -ddump-asm, -ddump-trace and so and so on
07:42:21 <bernalex> uhm
07:42:28 <dottedmag> So, cross-compilation in ghc will produce code for different architecture. What about different OS? Would that require a target cross-linker and other stuff?
07:42:29 <bernalex> I accidentally many words
07:42:40 <bernalex> haasn: those I posted there do *not* work. was my point.
07:43:15 <bernalex> at least not without some tricks that I am not yet familiar with. maybe they can be made work. that would be very cool.
07:43:50 <merijn> dottedmag: I'm not entirely sure what's needed for that, but GHC should already "just work" on any posix OS and windows, more exotic OSes will probably bring tons of other challenges anyway
07:44:19 <dottedmag> merijn: I was thinking of covering older Unices, which are PitA to work with natively.
07:44:22 <merijn> dagle: It isn't, it needs manual intervention after compilation to bootstrap on new architectures, yeah
07:44:46 <merijn> dagle: in other words, bootstrapping is a pain :)
07:45:22 <dagle> merijn: There was an ansi flag or something like that for ghc, to output ansi-c. It didn't change anything in output.
07:45:44 <dagle> I bet nobody found it sexy or fun to maintain.
07:50:32 <btcNeverSleeps> the type signature of Control.Monad.when is  Control.Monad.when :: Monad m => Bool -> m () -> m ()
07:51:06 <btcNeverSleeps> I've read that "Everything before the => symbol is called a class constraint"
07:51:32 <btcNeverSleeps> what is the class in that example?  m?   And the constraint is that "m" has to be a Monad?
07:51:49 <bennofs> btcNeverSleeps: the class refers to the 'Monad' type-class
07:52:10 <btcNeverSleeps> and the constraint applies to m right?
07:52:28 <bennofs> btcNeverSleeps: yeah, the constraint says: m has to be an instance of the type class Monad
07:53:08 <mmmm> How can I find where !! is causing an index error when I don't ever use it in my code
07:53:16 <btcNeverSleeps> bennofs: thanks a lot
07:54:13 <bennofs> @where stacktrace
07:54:13 <lambdabot> compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
07:54:23 <bennofs> mmmm: ^^ you could try that
07:55:34 <mmmm> if only I had profiling versions installed already!
07:55:57 <bennofs> mmmm: hmm, can you show your code?
07:56:56 <mmmm> It's over 500 lines and I suspect the error is in another library which is over 1000 lines
08:01:33 <merijn> btcNeverSleeps: I prefer to read "when :: Monad m => m () -> m ()" as "IF 'm' is an instance of Monad THEN when :: m () -> m ()" or something along those lines
08:02:47 <tsahyt> I need a sort of key/value store where the keys are unique. Much like [(a,b)] but there can only be one such pair in the list for every possible value of a. Is there a way to enforce such a constraint in the type system?
08:06:53 <btcNeverSleeps> merijn: ok but if 'm' is not an instance of Monad, then the type system won't allow me to use 'when' right?
08:10:42 <ion> hexagoxel: https://gist.github.com/ion1/ba7db8f617156dbd8f8e
08:16:37 <mmmm> btcNeverSleeps: no
08:18:30 <Algebr`> can lambdabot be generalized to other languages?
08:19:29 <merijn> btcNeverSleeps: Correct
08:19:58 <merijn> btcNeverSleeps: I guess the implicit "else-clause" I left out is: "ELSE type error"
08:20:18 <btcNeverSleeps> merijn: ok, I see what you mean
08:26:06 <hexagoxel> ion: ah, System.Mem.StableName. so there _is_ magic to observe sharing. very interesting, thanks.
08:28:37 <btcNeverSleeps> are really all type errors in Haskell detected at compile time?  Or can you do weird things similar to, say, a (bogus) forced cast in Java ("working" at compile but throwing a runtime ClassCastException)
08:28:52 <hpc> @hoogle unsafeCoerce
08:28:53 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:29:08 <hpc> it's possible, but you can tell immediately that it's not safe
08:29:25 <hpc> and it doesn't necessarily crash, you just get weird results
08:29:28 <btcNeverSleeps> that is great... But why would you want to do it?
08:29:46 <hpc> low-level optimizations
08:29:50 <btcNeverSleeps> gotcha
08:30:06 <hpc> bytestring uses it (or maybe unsafePerformIO, i forget)
08:33:49 <btcNeverSleeps> I noticed Haskell is very fast for doing big integers computation (like 2048 bits integer exp / mul / mod etc. for crypto algos), for it is using GMP under the hood.
08:33:52 <btcNeverSleeps> So it means all the functions used from GMP are guaranteed to be pure? What if there's some function which is not 100% pure? Like some "isProbablePrime" function whose output may not be 100% deterministic?
08:35:05 <hpc> btcNeverSleeps: i would have isProbablePrime :: Random Bool
08:36:17 <hpc> it then accepts the RNG of your choice, which can be a fixed seed (making it deterministic again, woo!) or something in IO
08:36:18 <btcNeverSleeps> hpc: ah that is interesting.
08:42:07 <EvanR_> gmp itself isnt too pure but its hidden
08:42:23 <EvanR_> you get a pure iterface to it
08:51:24 <flan3002> Can someone tell me how big cabal's package list? (In kb)
08:51:32 <flan3002> Approximately, of course.
08:54:12 <cehteh> $ls .cabal/packages/hackage.haskell.org/00-index.tar -lh
08:54:13 <cehteh> -rw-r--r-- 1 ct ct 128M Jun 10 11:55 .cabal/packages/hackage.haskell.org/00-index.tar
08:54:21 <cehteh> is that what you meant?
08:54:37 <haasn> btcNeverSleeps: hpc: unsafeCoerce is also sometimes needed if you want to express a function that you know is correct, but which Haskell's type system isn't powerful enough to check
08:54:48 <haasn> But that's very rare in practice
08:54:55 <flan3002> Whoa... Yes, 128M is too much... :/
08:55:20 <flan3002> Thank you though. :/
08:55:29 <btcNeverSleeps> haasn: as I'm beginning I take it I won't need it as of now (but I'll probably be using packages which are using it under the hood for performance reasons)
08:55:30 <haasn> flan3002: What are you trying to do?
08:56:29 <haasn> btcNeverSleeps: Best thing to do with unsafeCoerce is to forget it exists
08:56:42 <btcNeverSleeps> haasn: perfect!
08:57:11 <flan3002> haasn: I had that ZLib error and deleted all downloaded packages. And now, a simple $ cabal update never finishes... Which is why I asked. :)
08:57:24 <haasn> btcNeverSleeps: More in line with your original question, it's possible to defer type errors to the runtime using newer GHC and -fdefer-type-errors (or something like that); which can be useful if you're in the middle of a big refactor and you've fixed part of a project but haven't updated the rest (to make it type-check) yet
08:57:30 <haasn> But that's not usual behavior
08:58:41 <StoneToad> haasn: the new type hole feature is awesome with that
08:59:58 <hexagoxel> flan3002: the .tar.gz is ~7mb, though
09:00:10 <haasn> btcNeverSleeps: Apart from that, no, you won't get type errors at runtime. But you can get runtime exceptions at runtime, and those can be quite a big deal
09:00:13 <haasn> For example division by zero
09:00:19 <haasn> Or pattern matching failures
09:02:00 <EvanR> you can get type errors at runtime, with Dynamic ;)
09:02:22 <TheJhonny> Hope everyone is having a great weekend.  I've come with a question about arrows <-.  Do these arrows have different meanings in different statements? Like in list comprehensions?
09:02:24 <btcNeverSleeps> haasn: yup pattern matching failure I already got (forgot certain cases)
09:02:40 <EvanR> you can enable warnings in that case
09:03:39 <haasn> btcNeverSleeps: When beginning you may want to start off with -Wall; although that can be *quite* pedantic about the most harmless of things
09:03:42 <flan3002> hexagoxel: Well, that might even be doable, if I can be patient for the next half an hour... :/
09:04:04 <flan3002> hexagoxel: But of course, downloading all those packages will never succeed in time like that.
09:05:19 <haasn> (like ignoring a return value inside a monad action)
09:05:48 <btcNeverSleeps> how can I configure Emacs so that ghci / inferior-haskell-mode is using the "-Wall" option? (and -fwarn-tabs too)
09:06:18 <nadirs> TheJhonny: I think list comprehensions are additional syntactic sugar over do-notation. So right-to-left arrows (<-) in list comprehensions have akin meaning to those inside do-blocks
09:07:23 <TheJhonny> nadirs:  I've never heard of do-notation
09:08:22 <nadirs> TheJhonny: have you played around with monads?
09:08:58 <TheJhonny> no. I'm just started with functional programmming... I'm coming from Java
09:09:05 <monochrom> yes, <- means different things in different contexts
09:09:06 <TheJhonny> *starting
09:09:11 <bernalex> nadirs: list comprehensions are really monad comprehensions. list is a monad.
09:09:20 <nadirs> TheJhonny: my bad :)
09:09:24 <monochrom> but if you're learning list comprehension now, focus on list comprehension.
09:09:26 <bernalex> nadirs: you can use monad comprehensions with Just as well.
09:09:30 <bernalex> s/Just/Maybe
09:09:45 <bernalex> TheJhonny: yeah at your stage the answer is "don't worry about it" for now, really :-P
09:09:49 <nadirs> bernalex: though you need to enable a language extension, no?
09:09:53 <bernalex> nadirs: no
09:09:57 <bernalex> not afaik
09:10:05 <TheJhonny> bernalex: just go with the flow?
09:10:40 <monochrom> no. one thing at a time.
09:10:44 <TheJhonny> nadirs:  It's cool.  I'm just now reading learnyouahaskell and I came across list-comps.
09:10:50 <bernalex> TheJhonny: one thing at the time. :-] sufficed to say that, yes, they can have different meanings. none of which are difficult.
09:11:04 <monochrom> and Piaget's theory. concrete before abstraction. specific before general.
09:11:05 <bernalex> have you used python?
09:11:14 <monochrom> s/abstraction/abstract/
09:11:17 <bernalex> python have list comprehensions too. they're a bit uglier IMO but.
09:11:39 <sjoerd_visscher> bernalex: list comprehensions really are MonadPlus comprehensions, because you can use the comma to left of the pipe
09:11:41 <monochrom> they use more English
09:11:43 <EvanR> generalized abstract nonsense
09:11:47 <TheJhonny> IO
09:11:55 <bernalex> sjoerd_visscher: that's more specific yes. :-]
09:11:58 <TheJhonny> I've messed around with python, but nothing in depth
09:13:08 <bernalex> one interesting thing about list comprehensions for me is that I loved them when I started learning haskell, and used them a lot. nowadays I have to look up the syntax to get them right the few times I use them. >_<
09:13:38 <bernalex> > [x | x <- [1]] -- right?
09:13:40 <lambdabot>  [1]
09:13:42 <TheJhonny> They seem cool as hell.
09:13:51 <EvanR> meh
09:14:01 <monochrom> it's "pattern <- list", yeah
09:14:04 <EvanR> mere whizbangery ;)
09:14:11 <TheJhonny> lol
09:14:25 <nadirs> TheJhonny: returning to your original question, what are some cases where you have met arrows? so we can start from there
09:14:39 <monochrom> his "arrow" means <-
09:14:45 <bernalex> > [x | x <- Just 1]
09:14:46 <lambdabot>  Couldn't match expected type ‘[t]’
09:14:46 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
09:14:56 <bernalex> hm. IDR. -_o_-
09:14:57 <TheJhonny> right let me get one that confused me a bit.
09:15:08 <nadirs> monochrom: yeah, I think it's clear we're not talking about Arrow
09:15:15 <EvanR> Maybe(x | x <- Just 1) ;)
09:15:16 <TheJhonny>  let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
09:15:23 <TheJhonny>  [ [ x | x <- xs, even x ] | xs <- xxs]
09:15:43 <TheJhonny> outputs: [[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
09:15:58 <bernalex> sure. that seems right.
09:16:18 <TheJhonny> So it takes each element in xxs and puts it in xs
09:16:40 <maffa> why does arrow calculus disctinct between terms and commands?
09:16:43 <bernalex> and then it filters out the odd ones
09:17:02 <TheJhonny> I see.
09:17:20 <bernalex> try replacing even with a different predicate like odd
09:17:26 <bernalex> or (==2). :-]
09:17:29 <bernalex> G2G, dinner!
09:18:27 <TheJhonny> ha!  thats pretty cool
09:18:57 <TheJhonny> Hey guys I've gotta run.  But I'll most definitely be on later.  Thanks for all your help!
09:20:32 <nadirs> bernalex: at least in GHC 7.8.3 I need -XMonadComprehensions
09:21:36 <nadirs> are they adding it as default in 7.10? Maybe along with the Applicative-Functor/Monad reconciliation?
09:22:03 <nadirs> Or was it in 7.8 already? I need to look it up :P
09:23:55 <bernalex> nadirs: you are right. I guess I'm too much of a Glaswegian. :-]
09:24:25 <ph88> > map (\a b -> a) zip [0..] [4,5,6]
09:24:26 <lambdabot>  Couldn't match expected type ‘[t0] -> [t1] -> t’
09:24:27 <lambdabot>              with actual type ‘[t2 -> a0]’Couldn't match expected type ‘[a0]’
09:24:27 <lambdabot>              with actual type ‘[a1] -> [b0] -> [(a1, b0)]’
09:25:00 <ph88> how to read that error message ? i don't get it
09:25:16 <nadirs> :t (\a b -> a) -- ph88
09:25:17 <lambdabot> t1 -> t -> t1
09:25:18 <bernalex> nadirs: btw monad comprehensions are isomorphic to do-notation, but IDK if one is syntax sugar over the other.
09:26:04 <jg_> can i use a pure Reader inside of a ReaderT IO ?
09:26:07 <bernalex> ph88: when this happens, try reducing the expression, checking a little bit of it at the time.
09:26:11 <ph88> nadirs: ‘[t0] -> [t1] -> t’ and t1 -> t -> t1  looks the same  .. i think the lambda is not good
09:26:21 <nadirs> bernalex: that's how I understood it, though I wouldn't put a hand on fire
09:26:37 <ph88> > zip [0..] [4,5,6]
09:26:39 <lambdabot>  [(0,4),(1,5),(2,6)]
09:26:48 <ph88> so i want to map over those tuples
09:26:49 <bernalex> right
09:26:56 <bernalex> and :t zip [0..1] [4,5,6]
09:26:59 <bernalex> :t zip [0..1] [4,5,6]
09:27:00 <lambdabot> (Num b, Num a, Enum a) => [(a, b)]
09:27:05 <bernalex> so that's a list of tuples
09:27:07 <bernalex> :t map
09:27:08 <lambdabot> (a -> b) -> [a] -> [b]
09:27:14 <bernalex> :t (\a b -> a)
09:27:15 <lambdabot> t1 -> t -> t1
09:27:29 <bernalex> see here? your function doesn't take a tuple, but instead it takes two values
09:27:46 <bernalex> you want a function that's (t1, t) -> t1 -- not t1 -> t -> t1.
09:27:54 <jg_> example code here: https://gist.github.com/jg/48b188e9f0e99255f07e , i'd want to remove traces of IO in connectionUrl which shouldn't know anything about that
09:27:57 <ph88> :t (\(a,b) -> a)
09:27:58 <lambdabot> (t, t1) -> t
09:28:04 <bernalex> \o/
09:28:16 <bernalex> g2g dinner now. have fun. happy hacking!
09:28:17 <ph88> > map (\(a,b) -> a) zip [0..] [4,5,6]
09:28:19 <lambdabot>  Couldn't match expected type ‘[t1] -> [t2] -> t’
09:28:19 <lambdabot>              with actual type ‘[b0]’Couldn't match expected type ‘[(b0, t0)]’
09:28:19 <lambdabot>              with actual type ‘[a0] -> [b1] -> [(a0, b1)]’
09:28:22 <ph88> that's what i had at first
09:28:28 <bernalex> ph88: oh that's precedence
09:28:37 <bernalex> add parens around the zip stuff
09:28:45 <bernalex> map f (zip blah blah)
09:28:47 <bernalex> bye!
09:28:56 <ph88> oh no leaving :(
09:29:12 <nadirs> ph88: I can help :)
09:29:35 <ph88> rather then give a man some food tell him how to fish and read the error messages :P
09:30:42 <nadirs> ph88: I think the problem here is that the message is not telling you where to look at, it's like it's a step forward
09:30:47 <augur> hexagoxel: thats fine, sure
09:31:16 <ph88> why is there 2x  "with actual type" ?
09:31:22 <btcNeverSleeps> > map (\(a,b) -> a) $ zip [0..] [4,5,6]
09:31:23 <lambdabot>  [0,1,2]
09:31:42 <nadirs> ph88: the compiler expects ‘[t1] -> [t2] -> t’ because it's using all the arguments it can get for the map function
09:31:55 <hiptobecubic> Is there an agreed upon way to get packages that won't break each other yet? Stackage I guess?
09:32:07 <nadirs> ph88: so it's reading "map (\(a,b) -> a) zip [0..] [4,5,6]" as "(map (\(a,b) -> a) zip) [0..] [4,5,6]"
09:32:10 <nadirs> I think
09:32:23 <sjoerd_visscher> while compiling Hakyll I get: /var/folders/9_/sslwq5tj0t998rp5kmfp7qj00000gr/T/ghc35914_0/ghc35914_7.hscpp:339:42:
09:32:23 <sjoerd_visscher>     Not in scope: data constructor ‘Debounce’
09:32:50 <sjoerd_visscher> it seems Debounce comes from fsnotify, but reinstalling that doesn’t help
09:33:02 <ph88> what's b0 then ?
09:33:07 <nadirs> hiptobecubic: cabal sandbox?
09:34:20 <ph88> > 1 :+ 1
09:34:22 <lambdabot>  1 :+ 1
09:34:26 <ph88> o_O
09:34:38 <ph88> > :m Data.Complex
09:34:39 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:34:59 <ph88> > let e = exp 1
09:35:00 <lambdabot>  not an expression: ‘let e = exp 1’
09:35:05 <ph88> > e = exp 1
09:35:06 <lambdabot>  <hint>:1:3: parse error on input ‘=’
09:35:10 <fread2282> fmap (\a -> ("",a) [1,2,3,4]
09:35:13 <gipp> @let e = exp 1
09:35:15 <lambdabot>  Defined.
09:35:15 <fread2282> > fmap (\a -> ("",a) [1,2,3,4]
09:35:16 <lambdabot>  <hint>:1:29:
09:35:17 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:35:21 <ph88> thx
09:35:23 <fread2282> > fmap (\a -> ("",a)) [1,2,3,4]
09:35:25 <lambdabot>  [("",1),("",2),("",3),("",4)]
09:35:28 <fread2282> damn it
09:35:37 <ph88> > e^(0 :+ 1)
09:35:38 <lambdabot>  Ambiguous occurrence ‘e’
09:35:38 <lambdabot>  It could refer to either ‘L.e’, defined at L.hs:146:1
09:35:38 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.e’,
09:35:38 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
09:35:38 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:35:56 <ph88> gipp:  ??
09:36:22 <hexagoxel> > L.e^(0 :+ 1)
09:36:23 <lambdabot>  Could not deduce (GHC.Real.Integral (Data.Complex.Complex a0))
09:36:24 <lambdabot>    arising from a use of ‘GHC.Real.^’
09:36:24 <lambdabot>  from the context (GHC.Float.Floating a)
09:36:24 <lambdabot>    bound by the inferred type of it :: GHC.Float.Floating a => a
09:36:24 <lambdabot>    at Top level
09:36:38 <hexagoxel> the @ stuff gets put into module L, afaik
09:36:40 <ph88> ah yes this error i was looking for
09:36:55 <fread2282> what's the holes extension called?
09:37:04 <hexagoxel> (or @let only)
09:37:17 <ph88> what's this ... Could not deduce ...
09:37:36 <nadirs> ph88: about the previous "map (\(a,b) -> a) zip [0..] [4,5,6]", it seems you get a better message if you ask for the type like so
09:37:39 <nadirs> :t map (\(a,b) -> a) zip [0..] [4,5,6]
09:37:40 <lambdabot>     Couldn't match expected type ‘[t1] -> [t2] -> t’
09:37:40 <lambdabot>                 with actual type ‘[b0]’
09:37:40 <lambdabot>     The function ‘map’ is applied to four arguments,
09:38:03 <ph88> nice one nadirs
09:38:10 <gipp> > L.e^^(0 :+ 1)
09:38:11 <lambdabot>  Could not deduce (GHC.Real.Integral (Data.Complex.Complex a0))
09:38:12 <lambdabot>    arising from a use of ‘GHC.Real.^^’
09:38:12 <lambdabot>  from the context (GHC.Float.Floating a)
09:38:12 <lambdabot>    bound by the inferred type of it :: GHC.Float.Floating a => a
09:38:12 <lambdabot>    at Top level
09:38:17 <ph88> do you know about that error too ?
09:38:34 <gipp> never used complex in haskell, actually
09:39:07 <ph88> i'm trying to make euler' s formula in e notation
09:39:45 <gipp> > phase pi e
09:39:45 <monochrom> cos x :+ sin x
09:39:46 <lambdabot>  Ambiguous occurrence ‘e’
09:39:46 <lambdabot>  It could refer to either ‘L.e’, defined at L.hs:146:1
09:39:46 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.e’,
09:39:46 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
09:39:46 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:39:54 <gipp> > phase pi L.e
09:39:55 <lambdabot>  Could not deduce (GHC.Float.RealFloat (a0 -> t))
09:39:55 <lambdabot>    arising from the ambiguity check for ‘e_1’
09:39:55 <lambdabot>  from the context (GHC.Float.RealFloat (a -> t),
09:39:55 <lambdabot>                    GHC.Float.Floating a)
09:39:56 <lambdabot>    bound by the inferred type for ‘e_1’:
09:40:04 <gipp> :t pi
09:40:05 <lambdabot> Floating a => a
09:40:21 <gipp> :t L.e
09:40:22 <lambdabot> Floating a => a
09:40:39 <gipp> oh i can't read type signatures
09:40:42 <gipp> nevermind
09:40:45 <gipp> :t phase
09:40:46 <lambdabot> RealFloat a => Complex a -> a
09:40:47 <ph88> me neither :P
09:41:14 <nadirs> let's try checking one piece at a time
09:41:19 <nadirs> :t L.e
09:41:20 <lambdabot> Floating a => a
09:41:24 <gipp> > mkPolar pi L.e
09:41:26 <lambdabot>  (-2.864296568723392) :+ 1.290507484476073
09:41:28 <fread2282> > ((L.e^^(0 :+ 1)) :: Complex Integer)
09:41:29 <nadirs> :t (^^)
09:41:30 <lambdabot>  can't find file: L.hs
09:41:31 <lambdabot> (Integral b, Fractional a) => a -> b -> a
09:41:33 <gipp> > mkPolar L.e pi
09:41:35 <lambdabot>  (-2.718281828459045) :+ 3.328935140402784e-16
09:41:36 <nadirs> :t (0 :+ 1)
09:41:37 <lambdabot> Num a => Complex a
09:41:48 <ph88> it's not about e, this also doesn't work  2 ^ (2 :+ 3)
09:42:04 <vanila> > 2 -** (2 :+ 3)
09:42:05 <lambdabot>  Not in scope: ‘-**’
09:42:05 <lambdabot>  Perhaps you meant one of these:
09:42:05 <lambdabot>    ‘**’ (imported from Prelude), ‘***’ (imported from Control.Arrow)
09:42:07 <fread2282> > ((L.e^^(0 :+ 1)) :: Complex Integer)
09:42:08 <vanila> > 2 ** (2 :+ 3)
09:42:08 <lambdabot>  No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
09:42:08 <lambdabot>    arising from a use of ‘GHC.Real.^^’No instance for (GHC.Num.Num a0) arisin...
09:42:08 <lambdabot>  The type variable ‘a0’ is ambiguous
09:42:09 <lambdabot>  Note: there are several potential instances:
09:42:11 <lambdabot>  (-1.947977671863125) :+ 3.493620327099486
09:42:12 <vanila> oh weird
09:42:13 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
09:42:27 <monochrom> ^ wants the second argument to be Integral. complex numbers are not Integral. use **
09:42:31 <fread2282> > ((L.e^^(0 :+ 1)) :: Complex Float)
09:42:32 <lambdabot>  can't find file: L.hs
09:42:36 <nadirs> ph88: (^^) expects a Fractional instance but L.e is a Floating instance. Might it be the issue?
09:42:41 * ph88 gets graphical calculater 
09:42:52 <ph88> nadirs: no idea, im just new to haskell
09:42:57 <monochrom> ^^ also wants the second argument to be Integral
09:42:58 <hexagoxel> fread2282: "man ghc | grep hole" -> -fno-warn-typed-holes -fwarn-typed-holes
09:43:29 <nadirs> monochrom: bingo!
09:43:32 <nadirs> > L.e^^2
09:43:34 <lambdabot>  can't find file: L.hs
09:43:46 <nadirs> > L.e ^^ 2
09:43:48 <lambdabot>  7.3890560989306495
09:44:17 <gipp> > L.e ** ((0 :+ 1) * pi)
09:44:19 <lambdabot>  (-1.0) :+ 1.2246467991473532e-16
09:44:19 <vanila> > 2**(1 :+ 3)
09:44:23 <lambdabot>  (-0.9739888359315625) :+ 1.746810163549743
09:44:25 <gipp> there you go
09:44:30 <vanila> > 2**(2 :+ 3)
09:44:31 <lambdabot>  (-1.947977671863125) :+ 3.493620327099486
09:44:34 <vanila> > 2 ** (2 :+ 3)
09:44:36 <lambdabot>  can't find file: L.hs
09:44:38 <vanila> why
09:45:54 <ph88> i don't understand, why does it work now  ??
09:46:03 <nadirs> :t (**)
09:46:04 <lambdabot> Floating a => a -> a -> a
09:46:11 <nadirs> :t (^^)
09:46:12 <lambdabot> (Integral b, Fractional a) => a -> b -> a
09:46:23 <ph88> but both are to the power of ?
09:46:26 <gipp> yes
09:46:28 <gipp> also
09:46:31 <gipp> :t (^)
09:46:32 <lambdabot> (Num a, Integral b) => a -> b -> a
09:46:46 <vanila> maybe someone @let (**)
09:47:15 <ph88> this works for me now 2 ** (2 :+ 3)
09:47:45 <ph88> e ** (2 :+ 3)    Couldn't match expected type `Double' with actual type `Complex a0'     In the second argument of `(**)', namely `(2 :+ 3)'
09:48:14 <ph88> this is strange because e is also a number
09:48:23 <vanila> :T e
09:48:24 <vanila> :t e
09:48:25 <lambdabot>     Ambiguous occurrence ‘e’
09:48:25 <lambdabot>     It could refer to either ‘L.e’,
09:48:25 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:146:1
09:48:30 <vanila> exp 1
09:48:33 <ph88> :t e   is double here
09:48:34 <lambdabot>     Ambiguous occurrence ‘e’
09:48:34 <lambdabot>     It could refer to either ‘L.e’,
09:48:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:146:1
09:48:37 <ph88> > :t exp 1
09:48:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:48:42 <vanila> > let e = exp 1 in e ** (2 :+ 3)
09:48:46 <lambdabot>  (-7.315110094901103) :+ 1.0427436562359045
09:49:22 <ph88> hey but i need to use e more then once :P
09:49:47 <glguy_> > exp (2 :+ 3)
09:49:48 <lambdabot>  (-7.315110094901103) :+ 1.0427436562359045
09:49:59 <hexagoxel> ph88: then explicitly give it a type you want it to have
09:50:30 <ph88> what would be a good type for it ?
09:51:19 <hexagoxel> > _e ** (2 :+ 3)
09:51:20 <lambdabot>  Found hole ‘_e’ with type: Data.Complex.Complex a
09:51:21 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:51:21 <lambdabot>             the inferred type of it :: Data.Complex.Complex a at Top level
09:51:22 <ph88> hey nice one glguy_
09:52:21 <_2_latty13> hey
09:52:31 <_2_latty13> :D
09:54:08 <gvr> @pl findIndex (isPrefixOf (reverse needle)) (tails (reverse haystack))
09:54:08 <lambdabot> findIndex (isPrefixOf (reverse needle)) (tails (reverse haystack))
09:54:37 <hexagoxel> when L.e above had the wrong type, monomorphismrestriction was at work, right?
09:55:16 <gvr> @pl \haystack needle -> findIndex (isPrefixOf (reverse needle)) (tails (reverse haystack))
09:55:17 <lambdabot> flip (findIndex . isPrefixOf . reverse) . tails . reverse
09:56:08 <gvr> \needle haystack -> findIndex (isPrefixOf (reverse needle)) (tails (reverse haystack))
09:56:19 <gvr> @pl \needle haystack -> findIndex (isPrefixOf (reverse needle)) (tails (reverse haystack))
09:56:19 <lambdabot> (. (tails . reverse)) . findIndex . isPrefixOf . reverse
09:57:09 <bernalex> ph88: did you get the associativity thing or are you still confused?
09:57:35 <bernalex> ph88: basically f g x = (f g) x, not f (g x). that's the problem.
09:57:47 <ph88> no i didn't get that
09:57:56 <ph88> i'm close to the solution of my program though
09:58:03 <bernalex> ph88: map f g a = ((map f) g) a
09:58:14 <bernalex> ph88: but what you really want is (map f (g a))
09:58:35 <bernalex> so you need parens to make it explicit -- map f (g a)
09:58:44 <bernalex> or you can use '$', map f $ g a
09:58:48 <bernalex> :t ($)
09:58:49 <lambdabot> (a -> b) -> a -> b
09:59:12 <bernalex> it's just a way to hack precedence. f $ g x = f (g x). so it lets you omit parens.
09:59:38 <ph88> i used $
09:59:57 <ph88> bernalex: can you review my program ? it's almost done i think
10:00:05 <bernalex> sure. if it's short enough. :-]
10:01:57 <seydar> so i got the parallel and concurrent programming book per the recommendation of this channel
10:02:22 <seydar> and i'm trying to install the sample, but when i run "cabal install --only-dependencies", it complains that it's an unknown command
10:02:37 <glguy_> You probably need a newer version of cabal-install
10:02:40 <seydar> and i have a "parconc-examples.cabal" file, but how do i make use of it?
10:02:45 <bernalex> "cabal install cabal-install" or whatever
10:03:13 <ph88> actually it will take a bit longer to finish, but this is what i have so far https://www.fpcomplete.com/project/52542/JUfmLKMB2W
10:03:56 <bernalex> ph88: please use a pastebin like https://lpaste.net
10:04:26 <ph88> oki
10:04:31 <bernalex> uhm http://lpaste.net -- maybe it doesn't have ssl
10:05:28 <ph88> bernalex: http://lpaste.net/3751977451467571200
10:05:34 <seydar> bernalex: dammit, i'm getting syntax errors when it tries to install HTTP-4000 as a dependency. i'm using ghc 7.6.1
10:05:47 <Purity> Hey could I ask something about my code?
10:05:53 <bernalex> seydar: I'm not a cabal guy, sorry. what distro/os/whatever are you on?
10:06:00 <bernalex> Purity: that's kind of what we do here. :-]
10:06:18 <seydar> bernalex: mac os 10.9,
10:06:33 <bernalex> seydar: ouch. :-P maybe stick around & hope some mac guys come.
10:06:41 <Johanne21>  Here some videos. I hope you like them! http://bitly.com/1nX4LqS
10:06:43 <bernalex> ph88: why is your entire program in a do block? o-O
10:06:48 <bernalex> !ops
10:06:55 <mzero> seydar: are you getting errors only on the haddock step?
10:06:57 <bernalex> oh. we don't have that.
10:07:09 <mzero> and do you have clang as the system compiler (gcc --version will tell you)
10:07:14 <Purity> I'm a beginner to functional programming
10:07:33 <Purity> I just want to know is there a better way to do some code I wrote
10:07:49 <mzero> Purity: put the code in lpaste, and then folks here will be happy to talk about it
10:07:52 <mzero> @where lpaste
10:07:52 <lambdabot> http://lpaste.net/new/haskell
10:08:09 <bernalex> ph88: OK so this has some issues.
10:08:45 <mzero> seydar: ?
10:08:48 <seydar> mzero: cabal install cabal-install is the thing that fails, and it looks like it's failing on the haddock part. how can i disable the haddock stuff?
10:08:48 <bernalex> ph88: first of, let's make it compile and run
10:08:50 <ph88> bernalex: why? i don' t know why ... i just know i have to use main to start running the program
10:09:13 <mzero> seydar: do you have the ghc-clang-wrapper installed in /usr/bin?
10:09:29 <bernalex> ph88: I annotated your code. that means you'll see another paste at http://lpaste.net/3751977451467571200
10:09:46 <bernalex> ph88: first of I got rid of the do. you don't need it. :-] second of, I added a "print".
10:09:48 <bernalex> :t mian
10:09:49 <lambdabot>     Not in scope: ‘mian’
10:09:49 <lambdabot>     Perhaps you meant ‘min’ (imported from Data.Ord)
10:09:50 <bernalex> erm
10:09:52 <bernalex> :t main
10:09:53 <lambdabot>     Not in scope: ‘main’
10:09:53 <lambdabot>     Perhaps you meant ‘min’ (imported from Data.Ord)
10:09:54 <gipp> ph88: main is for IO actions necessary for your program. Since right now it's jsut a simple, hard-coded calculation, the only real IO action you'd want is printing the results
10:09:59 <bernalex> oh drat, lambdabot doesn't have that.
10:10:02 <Purity> http://lpaste.net/107788
10:10:08 <gipp> so main should probably just call the (pure) function to run your caluclation, then print the result
10:10:11 <bernalex> ph88: yes so like gipp said. main is :: IO ()
10:10:26 <seydar> mzero: no, should i? how can i get it?
10:10:27 <bernalex> ph88: so main needs you to use a function that delivers IO ()
10:10:30 <bernalex> :t print
10:10:30 <lambdabot> Show a => a -> IO ()
10:10:37 <ph88> bernalex: why do you use in before print ?
10:10:52 <bernalex> ph88: that's how let works outside of do-notation. let e in e
10:10:54 <mzero> seydar - does anything else compile?
10:11:01 <bernalex> > let a = 1 in a
10:11:02 <lambdabot>  1
10:11:23 <mzero> seydar: the wrapper (fix for 10.9) is here: http://www.haskell.org/platform/mac.html
10:11:29 <bernalex> > let a = 1; b = 2; in a+b
10:11:30 <lambdabot>  3
10:11:32 <mzero> about mid-page
10:11:35 <bernalex> ph88: do you see how that works?
10:11:36 <ph88> bernalex: it works without "in"  here
10:11:40 <seydar> mzero: i mean, ghc works for my basic stuff. i wrote a chat server and that worked perfectly
10:11:46 <bernalex> ph88: because you did not remove the "do"
10:12:14 <mzero> seydar: what system compiler do you have? does "clang" appear in the output of "gcc --version"?
10:12:19 <flan3002> haasn: I have the download running since 18:06 now. It hasn't finished yet...
10:12:21 <ph88> ok all my let i have to change those
10:12:33 <ph88> why is   no do + in   better then do + let ?
10:12:36 <bernalex> ph88: why do you let e = ...? you don't ever use e.
10:12:47 <seydar> mzero: yep, using clang
10:12:54 <ph88> i thought i needed it at first, but i have to remove that line now
10:13:17 <mzero> okay - but you don't have ghc-clang-wrapper in /usr/bin? if not, grab it from that page: run it - it'll will tell you what to do!
10:13:17 <bernalex> ph88: well, do doesn't make sense here. do is syntax sugar which is used for e.g. monadic code. you only have a single let ... in ... expression in your code, so you do not need to chain anything together.
10:13:45 <ph88> oki
10:13:46 <mzero> (but basically, you put it in /usr/bin, and then run it sudo once to fix up your ghc compiler settings file)
10:14:01 <ph88> i've been called for supper, back online soon ! thx for the help bernalex
10:14:06 <bernalex> ph88: next up -- in haskell you typically minimise the IO code. so in an IO function like main, you only really want to use IO.
10:14:18 <ph88> o/
10:14:30 <bernalex> ph88: have fun
10:14:33 <ph88> i will read it again what you said when i get back
10:14:34 <ph88> byee
10:14:52 <seydar> mzero: i install stuff often in ~/local and ~/local/bin, so i'm gonna put it there. if this is a bad idea, lemme know
10:15:26 <mzero> seydar: you can put the script anywhere you like
10:15:35 <mzero> but it may not fix up the settings file correctly ---
10:15:44 <mzero> if you know where the compiler settings file is, you can check it
10:15:55 <mzero> actually, the script should tell you where it "fixed up" the settings file
10:15:58 <Purity> http://lpaste.net/107788 <- is this how a fib function should be done?
10:16:02 <mzero> what you want is for ghc to think the compiler is this script
10:16:19 <mzero> it will add the extra arguments during compilation that ghc doesn't know to add for clang
10:16:28 <Pythonfant> sorry for asking again but I didn't receive a response earlier: when enabling librar-profiling in ~/.cabal/config I get “<no location info>: Warning: Couldn't figure out linker information!” when trying to compile (even if I don't use -prof for the actual file) if I disable library-profiling (and rebuild all the libs) this error disappears
10:16:42 <Pythonfant> s/error/warning/
10:18:21 <monochrom> Purity: no, this is very inefficient, I'm referring to a++[z].
10:19:11 <Purity> monochrom: I don't really know how to get past that
10:19:30 <mwhit> Purity: in haskell, you generally add to the FRONT of lists, not the back
10:19:37 <mwhit> prepending with (:) is O(1)
10:19:44 <mwhit> (++) is O(n) in the first argument
10:20:13 <seydar> mzero: excellent, thank you
10:20:20 <mzero> welcome
10:20:24 <Purity> Oh I see because it has to iterate through the whole list
10:20:27 <Cale> Pythonfant: Hmm, this is on Linux?
10:20:31 <mzero> next version of Haskell Platform will take care of all this for you on install
10:20:33 <Pythonfant> Cale: yes
10:20:36 <Pythonfant> arch 64bit
10:20:43 <Pythonfant> ghc 7.8.3
10:20:59 <Pythonfant> it seems to work despite the warning but it looks a bit strange
10:21:00 <mwhit> Purity, yep. also, there's no memoization here -- you're recalculating the entire sequqence every time the function is called
10:21:17 <mwhit> here's a "cute" one you can think about for a bit
10:21:18 <Cale> Do you have your LANG environment variable set?
10:21:29 <mwhit> @let fibs = scanl (+) 0 (1:fibs)
10:21:31 <lambdabot>  Defined.
10:21:31 <Cale> (to something interesting)
10:21:31 <Pythonfant> yes
10:21:32 <mwhit> >fibs
10:21:38 <Pythonfant> Cale: de_DE.UTF-8
10:21:39 <mwhit> > fibs
10:21:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:21:43 <Pythonfant> let me try unsetting it
10:21:47 <Cale> https://ghc.haskell.org/trac/ghc/ticket/8825
10:21:49 <maffa> what is the difference between a term and a command in arrow calculus?
10:22:08 <bernalex> mwhit: that's one of my favourite ways to get fibs. :-]
10:22:14 <Cale> If you set LANG=C the problem might go away
10:22:33 <bernalex> mwhit: all sequences of numbers should just be infinite lists that you can take from. so nice to work with. :-]
10:22:45 <seydar> goddammit cabal is a bitch and a half to get working right
10:23:10 <mwhit> seydar: where did you install from originally? brew? haskell platform?
10:23:44 <bernalex> > let f = 0 : 1 : zipWith (+) f (tail f) in f
10:23:45 <Cale> maffa: By arrow calculus, are you talking about the peculiar lambda calculus extension from http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf ?
10:23:46 <mzero> wasn't the platform....
10:23:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:24:08 <maffa> Cale: yes
10:24:28 <Pythonfant> Cale: thx that seems to be the same bug I have
10:24:39 <monochrom> Purity: http://lpaste.net/107794
10:25:10 <bernalex> http://ghcformacosx.github.io/ is supposedly nice for mac users, according to the only mac user I know who's used it.
10:25:21 <dfeuer> Ick. I just figured out why Henning Thienemann wrote such a nasty looking viewR (AKA unsnoc):
10:25:21 <dfeuer> viewR :: [a] -> Maybe ([a], a)
10:25:22 <dfeuer> viewR =
10:25:22 <dfeuer>    foldr (\x -> Just . forcePair . maybe ([],x) (mapFst (x:))) Nothing
10:25:34 <mzero> bernalex: it is a different option... but there are pros and cons
10:25:47 <dagano> where is the code paste page?
10:26:00 <dfeuer> He must have done it like that, I imagine, to ensure that it is a good consumer for foldr/build fusion.
10:26:13 <Purity> monochbom: so fibs creates an infinite list of all Fibonacci numbers?
10:26:33 <dfeuer> But ... so gross.
10:26:33 <seydar> mwhit: ehhh i can't quite remember. i didn't use brew though
10:26:52 <seydar> mwhit: brew was giving me trouble so i just did it by hand
10:26:54 <monochrom> what fibs? I'm just posting fib and fib'
10:27:07 <seydar> god dammit should i just reinstall ghc again
10:27:15 <Purity> monochrom: the scanl version
10:27:16 <mwhit> Purity: bernalex and my definitions for fibs did, yes
10:27:19 <monochrom> then yes
10:27:30 <Purity> oops wrong person
10:27:48 <maffa> Cale: from what i see the difference is purely technical, since commands have two environements in their type judgment
10:27:48 <monochrom> but I'd prefer focusing on your version first. one thing at a time.
10:28:05 <Cale> maffa: Well, they're in separate (but mutually recursive) syntactic categories. Ordinary lambda calculus only has terms. There's a new sort of term λ* x. Q, where Q is a command
10:28:05 <_ashbreeze_> !fojteach Cat Schield - [Las Vegas Nights 01] - At Odds with the Heiress [SD-2279].mobi
10:28:17 <Cale> maffa: and then some ways to form commands
10:28:21 <monochrom> #haskell answerers have the tendency of getting carried away, and I firmly resist it.
10:28:27 <_ashbreeze_> !pondering Cat Schield - [Las Vegas Nights 01] - At Odds With the Heiress [SD-2279] (mobi).rar
10:28:31 <Purity> lol
10:28:51 <_ashbreeze_> oops... wrong list!
10:29:17 <dagano> can someone look at the following : http://lpaste.net/107795   ?
10:29:32 <dagano> i have a question about folds and the persistence of data structures across a fold
10:30:53 <Cale> maffa: But the only things which count as commands are those three sorts that are listed in Figure 3
10:31:39 <monochrom> if you're into the businees of using "meaningful" type synonyms (which I'm not into), you may as well have "type Vertex = Int; type Src = Vertex; type Tgt = Vertex; type Weight = Int" so that Edge is not simply (Int, Int, Int)
10:31:46 <Cale> The dot, the brackets, and let
10:32:12 <mwhit> dagano: ConMap seems like it should probably be an actual Map, since that's how you're using it. You wouldn't need so many ugly partial functions
10:34:23 <Purity> I see where I went wrong anyway with appending to the end of the list. Does Haskell actually pass the list to a function or does it pass lists by reference?
10:34:26 <dagano> mwhit: yeah i agree..intmap would be ideal here.
10:34:41 <mwhit> in fact an intmap of Sets, not lists, since you're only using elem as far as i can see
10:34:42 <Cale> Purity: Pretty much everything is a pointer to code anyhow
10:35:07 <maffa> Cale: ok and why is it not higher order? Like L \bullet M is not able to apply arrows that are yielded by arrows?
10:35:21 <mwhit> dagano: anyway, sorry, what was your fold question
10:35:34 <Purity> Cale: so there is little overhead when a large list is passed to a function?
10:35:40 <Cale> maffa: I suspect it's because Arrows aren't higher-order
10:35:45 <maffa> Cale: or differently put: what is the difference between L\bullet M and L \star M
10:36:06 <Cale> Purity: Well, remember that expressions are evaluated outermost-first, so the list may not even be evaluated yet.
10:36:13 <Cale> Purity: It might be an unevaluated expression
10:36:18 <dagano> mwhit: in the fold, I use the unit of the cluster list to be "every node is alone in its own cluster" ... over the course of the fold, the fold takes one more edge from the graph and 'updates' the ConMap. i guess my question is, is this update function going to persist for each edge of the graph in the fold?
10:36:31 <dagano> (that is an ugly, messy question .. but it's all i have)
10:36:34 <maffa> Cale: yes that i think too, but i don't know how they restricted it with their typing rules or whatever
10:36:38 <Purity> Cale: Due to Haskell's laziness?
10:37:09 <dagano> s/is the update function/is the data structure that the update function intends to update/
10:37:22 <Cale> Purity: Yes, that's what lazy evaluation is: outermost-first evaluation, plus sharing (bound variables are evaluated at most once while they remain in scope, and work done to evaluate them is shared between occurrences)
10:39:28 <Purity> Cale: could you give an example of outermost-first eval?
10:39:34 <Cale> Sure!
10:39:54 <Cale> So, let's consider the function double x = x + x, and the expression double (double 5)
10:40:07 <Cale> Under strict (innermost-first) evaluation, you'd evaluate it like:
10:40:22 <Cale> double (double 5) -> double (5 + 5) -> double 10 -> 10 + 10 -> 20
10:40:45 <Cale> Under plain outermost-first evaluation, this would become
10:41:12 <Cale> double (double 5) -> (double 5) + (double 5) -> (5 + 5) + (double 5) -> 10 + (double 5) -> 10 + (5 + 5) -> 10 + 10 -> 20
10:41:24 <dagano> another question : IntMap : i know i can union two intmaps ... but within one intmap, can i union two (key,val) pairs s.t. u((k1,v1),(k2,v2)) = (k1,(union v1 v2)) ? efficiently?
10:41:47 <Cale> Note that we repeated the work of computing double 5 because the parameter x occurred twice in the body of double, which was unfortunate
10:41:58 <_0xAX> Hi all
10:42:19 <_0xAX> What's the standard way to store configuration of haskell application? json, yaml, something else?
10:42:20 <luite> bitemyapp: i don't have a twitter account
10:42:23 <Cale> However, outermost-first evaluation has the advantage that sometimes you might not need to compute an argument to a function in order to determine some or all of the result.
10:42:55 <tommd> _0xAX: I don't think there is a "standard".  There are several packages for text configuration parsing (ex: configurator) and I have used JSON in the past.
10:43:09 <Purity> Cale: could also prevent large time consuming functions being evaluated if it doesn't have to be
10:43:15 <Cale> Lazy evaluation gets the best of both worlds by ensuring that parameters are evaluated at most once and work is shared. I'll represent this with let/in syntax:
10:43:19 <Cale> double (double 5)
10:43:31 <Cale> -> let x = double 5 in x + x  -- note we still evaluated the outermost double first
10:43:33 <_0xAX> tommd: thanks, i'm thinking about json too, but thought maybe there is more preferable way for this
10:43:42 <Cale> -> let x = 5 + 5 in x + x
10:43:42 <_0xAX> will look on configurator
10:43:44 <mwhit> Purity: correct. that's what allowed us to build out the infinite lists earlier without getting into an infinite loop
10:43:45 <Cale> -> let x = 10 in x + x
10:43:49 <Cale> -> 10 + 10
10:43:50 <Cale> -> 20
10:44:28 <Purity> Makes sense
10:44:35 <Cale> Purity: The tricky part is just that we need some runtime representation for expressions
10:45:06 <Purity> Cale: All types are known at runtime are they not?
10:45:12 <joelteon> no
10:45:16 <joelteon> no types are known at runtime
10:45:19 <Cale> Runtime implementation mechanisms for expressions tend to be referred to as thunks (though I tend to avoid this word unless I'm specifically talking about the details of the implementation)
10:45:34 <Cale> Types are erased by the compiler
10:45:40 <Cale> (at least in Haskell)
10:46:23 <Cale> But that's another thing -- even without worrying about types, how do we pass something like (double 5) along as an argument to double without evaluating it?
10:46:39 <mwhit> dagano: Afraid I'm not really the best person to ask about performance questions like that. From my limited intuition, it doesn't look like there would be too much copying involved in your code
10:46:45 <mwhit> dagano: but why not run a profile and see?
10:48:03 <Purity> Cale: nothing is evaluated until it is forced to?
10:48:08 <Cale> right
10:48:14 <Cale> The solution in GHC is to use pointers to code as a representation for possibly-not-yet-evaluated values.
10:48:21 <Cale> When it comes time to pattern match on the value (and so which constructor it was built with needs to be determined), this code is entered
10:48:40 <Cale> The first thing it does is to set the pointer to point at something which will throw an exception (detecting an infinite loop)
10:48:48 <Cale> then it computes the value of the expression (somehow)
10:49:11 <Cale> then it sets the pointer to point at a short piece of code which will immediately return the already-computed result (for next time)
10:49:18 <Cale> and it returns the computed result
10:49:50 <Purity> I see
10:50:09 <Cale> Note: this is just if you're interested and to give some idea of how you might implement it, understanding things at this level is rarely necessary
10:50:20 <Cale> I mostly think at the level of just rewriting expressions
10:52:26 <Purity> Cale: Doesn't hurt to know how something works
10:52:37 <Cale> There are a bunch of other ways you could implement this sort of thing as well -- using a boolean flag to decide whether the thing is evaluated or not is perhaps even more obvious, but it turns out that having a separate boolean flag is not as efficient as just always using a single pointer to code
10:53:24 <dagano> mwhit: i'm actually less intesested in the performance .. can you answer the general question about persistence? that's my main confusion...thanks
10:53:57 <Cale> and then there are various ways to implement evaluators which do graph rewriting
10:54:24 <Purity> Sounds a little complicated for me at the moment
10:54:31 <Cale> Purity: Another advantage to this uniformity of representation is that it also gives you polymorphism
10:54:33 <wilcov> I've got an beginner question. In the haskell book on the page 'more_about_lists' (http://en.wikibooks.org/wiki/Haskell/More_about_lists) there is a piece of code on currying, however it does not seem to work whatever i try. Can somebody see if they can find the error? applyToIntegers :: (Integer -> Integer) -> [Integer] -> [Integer]
10:54:35 <wilcov> applyToIntegers _ [] = []
10:54:37 <wilcov> applyToIntegers f (n:ns) = (f n) : applyToIntegers f ns
10:54:47 <Cale> Purity: for example, length :: [a] -> Int only needs to be compiled once
10:54:54 <mwhit> dagano: everything is immutable in haskell unless you do some very funky things. as long as a reference exists, it will refer to exactly the same data
10:55:41 <Cale> Purity: Since all values take the same amount of space in memory, the same code can be used regardless of the type of elements of the list
10:55:51 <Cale> and this even extends to  map :: (a -> b) -> [a] -> [b]
10:56:20 <Cale> Well, "same amount" in that they're pointers to some code :)
10:56:30 <Cale> They might indirectly take much more space of course
10:57:03 <Purity> Makes sense to me, I come from a C background so Haskell is quite different for me
10:57:15 <dagano> mwhit: so in my code, the foldl is basically a left-associative, "iterative" transformation from graph -> conmap ?
10:57:19 <Cale> wilcov: What error are you getting?
10:58:53 <aloiscochard> I have a piece of code, where if I replace `span` with `break`, the behavior is not the opposite O_o
10:59:07 <mwhit> dagano: Yes. I should also say that foldl should very rarely be used. Should probably use either foldl' or foldr instead. See http://www.haskell.org/haskellwiki/Fold
10:59:10 <mwhit> first section
10:59:41 <Cale> @src break
10:59:41 <lambdabot> break p =  span (not . p)
11:00:23 <aloiscochard> Cale: which is why I'm really puzzled by this
11:00:44 <Cale> aloiscochard: Is floating point arithmetic involved?
11:01:03 <Cale> Well, even then...
11:01:07 <Cale> hm
11:01:21 <mwhit> aloisocchard: is there a simple example to demonstrate?
11:01:26 <Cale> Yeah, I don't see how that could be the case. You should always be able to replace break p with span (not . p) :)
11:01:45 <maffa> Cale: Sorry to bother you again. From my understanding is the arrow L in L\bullet M a term. This is because classical arrows don't have a way to apply a arrow that is yielded by another arrow. In L\star M the arrow L is a command, because higher order arrows have app. So if L were a command in L\bullet M i could  write something like (L\bullet M)\bullet N and the resulting arrow of (L\bullet M) has to be applied to N, which is not pos
11:01:57 <aloiscochard> mwhit: it's here, if you git clone that should build https://github.com/aloiscochard/velox/commit/cc9300b85636759830c06efc85e75db318b192a8#diff-37b7cdea2926c935f5e75fb4764a41f1R53
11:02:18 <aloiscochard> mwhit, Cale: let me double check one more time to be sure, before looking into it
11:02:27 <Cale> maffa: What's \star ?
11:02:36 <Cale> maffa: I don't see it in the paper.
11:02:54 <maffa> Cale: Chapter 6 the hiher order application
11:03:11 <maffa> Cale: in the other papers they call it \star instead of \bullet again
11:03:20 <Cale> Maybe I have a different version of the paper from you
11:03:52 <wilcov> Cale: the second part of the code is multiplyList :: Integer -> [Integer] -> [Integer]     multiplyList = applyToIntegers (*)   but when i load the file in ghci it gives two errors:   Couldn't match type ‘[Integer]’ with ‘Integer’
11:03:54 <wilcov>     Expected type: Integer -> [Integer] -> [Integer]
11:03:56 <wilcov>       Actual type: [Integer] -> [Integer]
11:03:58 <wilcov>     Possible cause: ‘applyToIntegers’ is applied to too many arguments
11:04:00 <wilcov>     In the expression: applyToIntegers (*)
11:04:02 <wilcov>     In an equation for ‘multiplyList’:
11:04:04 <wilcov>         multiplyList = applyToIntegers (*)
11:04:28 <maffa> Cale: In your linked paper it is in chaper 3, here (http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf) it is in chapter 5
11:04:28 <wilcov> and  Couldn't match type ‘Integer -> Integer’ with ‘Integer’
11:04:30 <wilcov>     Expected type: Integer -> Integer
11:04:32 <wilcov>       Actual type: Integer -> Integer -> Integer
11:04:34 <wilcov>     Probable cause: ‘(*)’ is applied to too few arguments
11:04:34 <Cale> wilcov: Yeah, *that* is a type error
11:04:36 <wilcov>     In the first argument of ‘applyToIntegers’, namely ‘(*)’
11:04:38 <wilcov>     In the expression: applyToIntegers (*)
11:04:40 <wilcov> (sorry for flooding the channel)
11:04:45 <Cale> also please use lpaste.net
11:04:59 <wilcov> Cale: sorry, i will from now on
11:05:13 <Cale> But yeah, applyToIntegers takes a function Integer -> Integer as its first argument
11:05:17 <Cale> (*) does not have that type
11:05:37 <aloiscochard> mwhit: Cale: ok, I confirm after careful checking, I have put the output of print in comment: https://github.com/aloiscochard/velox/commit/5c51837539e3c82f0641383153c4871e47b0bc5d#diff-37b7cdea2926c935f5e75fb4764a41f1R53
11:05:49 * hackagebot haskell-token-utils 0.0.0.4 - Utilities to tie up tokens to an AST  http://hackage.haskell.org/package/haskell-token-utils-0.0.0.4 (AlanZimmerman)
11:05:53 <aloiscochard> unfortunately it's not isolate
11:06:04 <aloiscochard> I might have time later for that.. for now I'll use break instead of span
11:06:53 <Cale> aloiscochard: I don't think I see the problem?
11:07:12 <aloiscochard> Cale: haha, so maybe I don't understand the difference between both function :-s
11:07:23 <aloiscochard> Cale: I would have expected to have the content of the tuple swapped, simply
11:07:34 <maffa> Cale: sorry in your paper http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf it is chapter 6 "Additional Structure" written also as \bullet instead of \star
11:07:34 <aloiscochard> but in one case, one of the list is empty
11:07:40 <Cale> nah, it's that the sense of the condition is inverted
11:07:55 <Cale> > span isAlpha "hello world"
11:07:56 <aloiscochard> ahaaaaa
11:07:57 <lambdabot>  ("hello"," world")
11:08:00 <Cale> > break isAlpha "hello world"
11:08:01 <lambdabot>  ("","hello world")
11:08:07 <Cale> > break isAlpha "    hello world"
11:08:09 <lambdabot>  ("    ","hello world")
11:08:20 <aloiscochard> Cale: make sense, would be ridiculous to have variant just to swap now that I think about it!
11:08:24 <aloiscochard> thanks a lot :)
11:09:27 <wilcov> Cale: So in short the wikibooks code of multiplyList is simply wrong?
11:09:30 <dfeuer> Why is it that the profiler shows that  print $ last [1..(10000000::Int)]  (ten million) allocates 800000368 (800 million) bytes?
11:11:17 <c_wraith> dfeuer: apparently last isn't a good consumer.  Or you're not compiling with optimizations.
11:12:34 <c_wraith> dfeuer: actually, the implicit enumFromTo is going to allocate on every generated cell, regardless of whether last is a good consumer - it allocates a thunk representing the Int that gets thrown out.
11:14:02 <c_wraith> I really hope Int's Enum instance generates values strictly, or that'll get ugly.
11:17:06 <dfeuer> I'm compiling with optimizations. c_wraith, why does it need to allocate that thunk? If last were a good consumer, it would presumably unbox the Ints once the fusion was complete, no?
11:17:39 <c_wraith> dfeuer: All I can say is look at the core, I guess.
11:18:44 <dfeuer> c_wraith, I'm not good enough to understand most of it.
11:19:00 <dfeuer> But it seems to include a call to GHC's last.
11:19:02 <dolio> last is not a foldr.
11:19:19 <c_wraith> oh.  Right, last as a foldr doesn't work too nicely
11:19:31 <c_wraith> Though, in 7.10...
11:19:41 <mwhit> @src last
11:19:41 <lambdabot> last [x]    = x
11:19:41 <lambdabot> last (_:xs) = last xs
11:19:41 <lambdabot> last []     = undefined
11:19:46 <c_wraith> Last can be a foldl, and foldl is a foldr in 7.10
11:20:07 <otis> How should STArrays be used? For instance, does it make sense to use nested STArrays to have a mutable multidimensional matrix?
11:20:34 <c_wraith> otis: you could do it that way, though the MArray interface lets you use a pair as an index if you want the whole thing to be one block of memory
11:21:49 <otis> c_wraith: ah interesting, lemme try that
11:23:05 <c_wraith> otis: you can also look at Repa, potentially. It's a package for performing automatic parallelization on lots of functions on regular multidimensional arrays
11:23:19 <c_wraith> @hackage repa
11:23:19 <lambdabot> http://hackage.haskell.org/package/repa
11:23:57 <c_wraith> It's a little more complicated than STArray, but that's necessary to make the nice properties it has work. :)
11:25:51 * hackagebot HaRe 0.7.2.6 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.2.6 (AlanZimmerman)
11:27:56 <dfeuer> last does work as a foldr, and using a trick I just learned from Henning Thiemann's code, I wrote a version of last using foldr that, plugged into that line, allocates half as much as GHC's last.
11:28:25 <otis> c_wraith: Yeah I've been briefly acquainted with repa, but I'm just trying to learn a bit about using the various kinds of mutability provided in haskell
11:28:29 <dfeuer> It ends up being a little slower though, in that trivial test. I imagine it might be better in a more serious one.
11:29:05 <c_wraith> dfeuer: using the higher-order foldr trick that's the same way foldl will be implemented in GHC 7.10? :)
11:29:11 <mwhit> @pl (\a b -> f a `fmap` g a b)
11:29:11 <lambdabot> ap ((.) . fmap . f) g
11:29:33 <mwhit> i'll pass
11:29:51 <mwhit> @pl (\a -> f `fmap` g a)
11:29:51 <lambdabot> (f `fmap`) . g
11:30:30 <dolio> Before GHC 7.10, implementing foldl as foldr is not a good idea.
11:30:37 <dolio> And similar.
11:31:02 <dolio> Making it work well requires optimizations that don't exist in released versions of GHC.
11:32:09 <c_wraith> when it does work well, last = foldl (flip const) (error "Prelude.last: empty list")
11:32:51 <c_wraith> ..  Assuming the simplifier actually reduces that to good code.  I'm told that eta contraction is actually bad for performance in a lot of cases.
11:33:35 <dolio> The inliner doesn't inline things that aren't as saturated as their definition, if that's what you mean.
11:33:36 <Cale> Power cable wiggled itself loose from heating on one of my hard drives and took my machine down :P
11:34:00 <mwhit> does anyone know of a vim plugin that allows basic refactoring stuff e.g. project-wide type renaming?
11:34:18 <Cale> maffa: anyway, yeah, having to use ArrowApply to do higher order stuff makes sense
11:45:41 <otis> Is there any function that would take "(1, Just 2)" and return "Just (1, 2)"? I've tried hoogling for "(Functor f, Monad m) => f (m a) -> m (f a)" but have come up short. I could easily write it but I'm curious to see whether it exists
11:47:42 <supki> > T.sequence (1, Just 2)
11:47:43 <lambdabot>  Just (1,2)
11:48:33 <supki> @hoogle f (g a) -> g (f a)
11:48:33 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:48:33 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
11:48:33 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
11:49:14 <otis> T.sequence?
11:49:22 <mwhit> Traversable
11:49:24 <otis> Traversable?
11:49:25 <otis> yah
11:49:28 <otis> hmm
11:49:31 <otis> i thought i tried that...
11:49:50 <benjwadams> Hi, a new book regarding haskell data analysis has recently hit the market  -- http://www.packtpub.com/haskell-data-analysis-cookbook/book     I do a lot of data analysis in my day to day work usually with python and was curious if anyone had read this book and would recommend it
11:50:21 <genericpersona> benjwadams: i just got it in the mail :)
11:50:26 <benjwadams> Real World Haskell had some decent examples, but didn't really cover enough use cases for me
11:50:29 <genericpersona> i'll have to get back to you on that
11:50:44 <benjwadams> any initial impressions?
11:50:47 <mwhit> benjwadams: I bought a copy. Haven't flipped too much through it yet, but it looks pretty solid. Nothing extremely advanced, but covers a lot of recipes for basic things
11:50:49 <genericpersona> benjwadams: it seems the only way is to just start a project yourself
11:50:53 <mwhit> i also do a lot of python analysis
11:51:06 <genericpersona> benjwadams: the table of contents look impressive
11:51:06 <mwhit> i don't think haskell is ready for that kind of exploratory work yet
11:51:10 <mwhit> hopefully someday
11:51:14 <genericpersona> but i'll have to see how accurate the examples are
11:51:14 <mwhit> maybe this book will prove me wrong
11:51:26 <genericpersona> i've had mixed experience w/ code examples in recent books
11:51:34 <carter> mwhit: idk how good that book is
11:51:43 <benjwadams> I guess diving into another question:  When might using haskell be advantageous over python for data processing/slicing, etc
11:51:44 <carter> (like, its super intro cookbooky)
11:52:02 <zomg> Packt :\
11:52:03 <genericpersona> benjwadams: there's a recipe for reading IRC chat room messages :)
11:52:04 <carter> benjwadams: when a few more libs folksa re working are released in the coming month
11:52:05 <mwhit> carter: yeah, that was my impression. but considering there's absolutely zip out there right now otherwise, i'll take what i can get
11:52:22 <carter> those who like data analysis/ applied math, #numerical-haskell is a nice channel :)
11:52:25 <Cale> benjwadams: Haskell is much more capable when it comes to concurrency and parallelism, for one
11:52:28 <zomg> My experience with Packt published books is very mixed... They have some good ones, but the majority are a bit low quality.
11:52:30 <genericpersona> carter: good tip
11:52:38 <mwhit> carter: what libs are those?
11:52:42 <carter> :)
11:52:45 <zomg> But tbh i get the feeling a haskell book and on a topic like that might be one of the good ones =)
11:53:03 <benjwadams> it's just so recent i can't really find many reviews
11:53:04 <carter> zomg: ... it was written by an undergrad though
11:53:08 <genericpersona> hopefully it has a lot of good small code samples that you can build on
11:53:14 <carter> (a smart undergrad, but an undergrad)
11:53:20 <genericpersona> nothing wrong with thta
11:53:27 <genericpersona> if he knows he shit i'll read it :)
11:53:28 <benjwadams> I was an undergrad once too
11:53:32 <genericpersona> s/he/his
11:54:11 <genericpersona> what's a good haskell configuration file library?
11:54:18 <benjwadams> I did look at some packt books in the past and ... ehh...
11:54:31 <benjwadams> not nearly as good as oreilly
11:55:20 <zomg> Yeah they are either a hit or miss. They're not *bad*, but the quality is not great... Lots of typos, mistakes in code samples, etc.
11:56:11 <benjwadams> well, in this case they're on github as well, so in theory anything that ends up in the errata should be fixed
11:56:20 <benjwadams> for the code samples at least
11:58:11 <gbwey> hi everyone: i have an odd question: a user enters a query using this format eg (r 1 filta <*> (r 2 filtb <|> r 3 filtc))  but I would prefer something like (filta <*> (filtb <|> filtc))
11:58:39 <gbwey> is there a way to do something like this using state and reader applicative
11:59:00 <pjdelport> gbwey: What's r?
11:59:27 <pjdelport> And what kind of structure does filt* create?
11:59:39 <gbwey> r is a fixed function that essentially runs Concurrently from async
11:59:55 <pjdelport> Are the 1, 2, 3, ... just incremental counters?
12:00:00 <gbwey> exactly
12:00:30 <gbwey> so each time a filter appears the state increments by one
12:01:34 <gbwey> so I guess i am trying to convert from one Applicative instance to a Concurrently Applicative
12:01:46 <pjdelport> If the filter functor is also foldable / traversable, you could probably do something like that r N application in a separate second pass.
12:03:37 <gbwey> thats an great idea
12:05:55 <gbwey> would i also need to define an applicative for filter?
12:06:43 <kgadek> hi. I'm setting up a CI to test against multiple GHC+cabal versions. For GHC, I did `./configure --prefix=BLAH && make install` and everything's fine. But what about cabal? It installs in ~/.cabal, will install everything into that and I don't see any option to pass to change that.
12:07:26 <kgadek> what would be the best way to solve this? Of course, different system users would work but that would be… well, quite heavy
12:08:49 <carter> kgadek: https://github.com/hvr/multi-ghc-travis :)
12:09:08 <carter> kgadek: also the pkg dbs are different for different ghc versions
12:09:24 <carter> its pretty safe to use recent cabal with the full range fo supported ghc versions
12:11:55 <BluBoyHD> hi
12:12:20 <BluBoyHD> !list
12:12:21 <monochrom> BluBoyHD: http://okmij.org/ftp
12:14:57 <Profpatsch> What do I do when hackage has no docs for yesod-core?
12:15:07 <fread2282> is there anything that makes dealing with many-argument datatypes easier?
12:15:35 <Profpatsch> I tried looking into hosting my own local hackage-server, but with cabal dependency hell it’s pretty much impossible to set this up alongside other projects.
12:15:48 <dwcook> fread2282, what are you finding hard about it?
12:15:53 <dwcook> (or relatively hard)
12:15:57 <Profpatsch> Are there any other tools to read the html docs?
12:16:38 <fread2282> dwcook: changing the number of arguments and having to update it in lots of places
12:17:05 <Profpatsch> Oh, wait!
12:17:09 <dwcook> fread2282, record syntax might help
12:17:19 <dwcook> fread2282, also record wildcards for decomposing parameters of that type
12:17:26 <Profpatsch> I already built the docs with cabal install, and they are linked wonderfully.
12:17:36 <Profpatsch> No need for a hackage server, I see.
12:18:01 <dwcook> fread2282, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
12:18:04 <fread2282> dwcook: type-level records? that would be cool
12:18:26 <dwcook> fread2282, that's not what I'm talking about. I'm not even sure what a type-level record would be
12:18:29 <fread2282> although idk how ti would work or help
12:18:59 <fread2282> dwcook: the painful part is updating all of the types
12:19:27 <fread2282> when say I change a 3-arg type to a 4-arg one
12:19:47 <mmmm> Is it possible to have type synonyms with typeclass constraints?
12:20:56 <fread2282> (I mean many type arguments)
12:21:59 <bitemyapp> luite: it's fine I linked the repo.
12:22:49 <mwhit> mmm: with RankNTypes I can write "type Test a = (Num a) => [a]", and with FlexibleContexts I can make instances of it, but I can still write instances of Test String
12:22:52 <mwhit> so no
12:23:55 <mmmm> so I have to go and change all my type signatures by hand
12:23:57 <mmmm> ?
12:24:17 <mwhit> uh beats me
12:24:20 <mwhit> what are you trying to do
12:25:19 <dwcook> fread2282, could you show an example before-and-after? Though it's possible you could use type synonyms to help
12:25:58 <Profpatsch> Does someone use Yesod?
12:26:24 <mmmm> I am refactoring a module and all the type signatures are too specific ie Reader s a rather than (Monad m) => ReaderT s m a
12:26:28 <luite> bitemyapp: k tnx :)
12:26:42 <fread2282> dwcook: data Expr m t a => data Expr l w t a and I don't think synonyms will help (expr is an AST)
12:27:05 <dwcook> mmmm, you can use this: generalize m = return . runIdentity
12:27:12 <fread2282> I guess dependant types would help some
12:27:20 <funfunctor> hi
12:27:30 <dwcook> mmmm, woops, forget the parameter
12:27:34 <dwcook> generalize = return . runIdentity
12:27:50 <dwcook> @type return . runIdentity
12:27:51 <lambdabot> Monad m => Identity b -> m b
12:27:52 <fread2282> maybe TFs?
12:28:11 <dwcook> mmmm, check out the mmorph package, where I got that from, for other handy functions
12:28:13 <funfunctor> now we have a parser library (parsec) which is fantastic. However, do we have some kind of writer library, that given some AST we can 'write out' into some language?
12:28:14 <dwcook> @hackage mmorph
12:28:14 <lambdabot> http://hackage.haskell.org/package/mmorph
12:28:24 <mmmm> thanks dwcook
12:28:42 <funfunctor> I would like to take some abstract tree and write out some fairly basic Ada
12:29:13 <fread2282> funfunctor: the system for supporting arbitrary ASTs would be complex, but there's the language-* packages that define their own ASTs and parsers
12:29:22 <fread2282> (usually)
12:29:28 <fread2282> s/the/a/
12:29:55 <dwcook> mmmm, ah, hoist generalize will take Reader s a onto (Monad m) => ReaderT s m a, I forgot about that other step
12:30:20 <funfunctor> fread2282: sorry could you point me to that?
12:30:24 <dwcook> mmmm, you could also do it in a less general way if you don't want to import mmorph, but the general idea is here
12:30:25 <fread2282> doesn't look tike there's a language-ada package
12:30:39 <fread2282> funfunctor: so no we do not
12:30:54 <funfunctor> fread2282: I was assuming no Ada however at least something to get started
12:32:24 <fread2282> funfunctor: language-c maybe? http://hackage.haskell.org/package/language-c
12:32:25 <Profpatsch> Maybe someone here knows about strange Yesod linking errors? https://bigmac.caelum.uberspace.de/paste/BeeList.hs.html
12:32:26 <funfunctor> fread2282: basically I am trying to write a devicetree parser and take that information to make a static dispatcher for the correct drivers
12:33:04 <funfunctor> fread2282: that's great thank you!
12:33:06 <fread2282> funfunctor: having one AST/input that gives you quality output in multiple languages isn't a trivial problem
12:33:35 <fread2282> (and probably not worth the effort)
12:33:44 <funfunctor> fread2282: I'm very very aware. This is a very very restricted subset
12:34:15 <funfunctor> fread2282: essentially we take one syntax sugar into another
12:35:50 <zq> is there a way to get ghc to realize that Functor m => Monad m?
12:35:52 <funfunctor> fread2282: basically 'key : value' into the equiv in Ada. In fact it would not be unlike taking some JSON and packing it into some Haskell GADT's
12:36:07 <zq> something like LANGUAGE AssumeAMP
12:37:39 <dwcook> zq, not yet, but soon
12:39:09 <dwcook> zq, I guess until then you could simply have spurious Functor constraints. Would that be a problem?
12:39:21 <quchen> What would be the benefit of that extension?
12:39:23 <zq> dwcook: how do you mean?
12:39:32 <dwcook> zq, (Functor m, Monad m) => …
12:39:41 <zq> dwcook: yeah that's what i'm doing right now
12:39:46 <zq> dwcook: all because i used fmap
12:39:49 <quchen> I can see how having the constraint that way is useful, but an extension is not really the right place for that
12:40:28 <dwcook> zq, also keep in mind that liftM is the same as fmap except it has a Monad constraint rather than Functor
12:40:34 <dwcook> @type liftM
12:40:35 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
12:40:35 <dwcook> @type fmap
12:40:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:40:55 <zq> oh cool, thanks
12:41:19 <dwcook> Just beware of the times when you use liftM but happened to only need Functor, not Monad
12:41:32 <dwcook> or only Applicative
12:41:33 <Pythonfant> as soon as the monad applicative proposal will be into ghc (7.10) liftM is basically useless, right?
12:41:45 <dwcook> Pythonfant, other than for backwards compatibility, I believe so.
12:42:16 <bb010g>  Along with ap
12:42:31 <dwcook> Pythonfant, I take that back
12:42:37 <dwcook> Pythonfant, liftM is a sane definition for fmap
12:43:14 <dwcook> Pythonfant, you can use it to avoid having to put any work into defining the Functor instance if you know you have a Monad one
12:43:56 <dwcook> instance Functor Foo where { fmap = liftM } ; instance Applicative Foo where { pure = return ; (<*>) = ap } instance Monad Foo where …
12:44:04 <dwcook> (You could also set fmap = liftA)
12:44:20 <bb010g> But for m
12:44:48 <dwcook> bb010g, what do you mean?
12:44:53 <bb010g> (Sorry, iPad keyboard)
12:44:53 <zq> `each` should be added to base or somewhere
12:45:01 <zq> where each = flip map
12:45:06 <bb010g> Never mind
12:45:17 <dibblego> it is in Control.Lens, which is pretty much "base dunrite"
12:46:16 <zq> @hoogle [a] -> (a -> b) -> [b]
12:46:17 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:46:17 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
12:46:17 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
12:46:27 <dibblego> @typ (&)
12:46:28 <lambdabot> a -> (a -> b) -> b
12:46:38 <zq> that's not each
12:46:45 <dibblego> @typ (.&.)
12:46:46 <lambdabot>     Ambiguous occurrence ‘.&.’
12:46:46 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
12:46:46 <lambdabot>                              imported from ‘Data.Bits’ at /home/lambda/.lambdabot/State/L.hs:57:1-16
12:46:52 <dibblego> I forget the name
12:47:00 <supki> :t (<&>)
12:47:01 <lambdabot> Functor f => f a -> (a -> b) -> f b
12:47:07 <EvanR> dunno about calling this "each"
12:47:26 <dibblego> thanks supki
12:47:31 <zq> thanks supki
12:47:39 <dwcook> Yeah, calling it "each" would invoke sort of a collection metaphor, which is certainly not true of all Functors
12:47:40 <Pythonfant> dwcook: but if applicative is a superclass of monad you shouldn't need to provide a functor instance, right?
12:47:48 <zq> ugh
12:48:06 <zq> i defined each = flip map, where Prelude.map is defined over collections
12:48:07 <dwcook> Pythonfant, you still need instances for Functor and for Applicative.
12:48:40 <EvanR> map = fmap
12:49:02 <dwcook> That'd be a rationalization, I think. map is indeed less general than fmap
12:49:08 <dwcook> So, yeah, sorry zq
12:49:52 <zq> EvanR: no, map is an instantiantion of fmap
12:50:03 <zq> instntiiton*
12:50:07 <zq> whatever
12:50:08 <EvanR> in real life
12:50:20 <EvanR> but if map = fmap it would all be the same
12:50:24 <dwcook> Pythonfant, by the way, you can also derive a Functor instance with the DeriveFunctor extension, so that's one less step.
12:50:59 * hackagebot texmath 0.6.7 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.7 (JohnMacFarlane)
12:51:40 <dwcook> Does anyone happen to know if it's true that you can derive a Functor instance using that extension iff there is a valid Functor instance?
12:52:06 <dwcook> I.e., is there any valid Functor instance it can't derive, and is there any way to make it generate an invalid Functor instance?
12:53:57 <mmmm> dwcook: Thanks, that worked a treat
12:54:00 <glguy_> data D a b where
12:54:00 <glguy_>   C1 :: D Int b
12:54:00 <glguy_>   C2 :: b -> D Char b
12:54:12 <glguy_> You can't derive a Functor instance for that but you can write one
12:54:51 <glguy_> error:  Can't make a derived instance of ‘Functor (D a)’: Constructor ‘C1’ must not have existential arguments In the data declaration for ‘D’
12:54:56 <dwcook> glguy_, ah, neat
12:55:07 <Pythonfant> dwcook: there seems to be some ideas floating around on implementing default superclasses which would eliminate the need for defining functor and applicative completely if you have a monad instance https://ghc.haskell.org/trac/ghc/wiki/IntrinsicSuperclasses
12:55:26 <Pythonfant> I thought this was already done but obviously I'm wrong
12:55:59 <dwcook> Pythonfant, cool, I haven't seen anything like that, thanks for the link
12:56:00 <int3__> how do I set cabal's --show-details=streaming to be the default behavior? I've tried putting it in my cabal.config file as well as my project's cabal file and it doesn't seem to get recognized as a valid option
12:57:26 <Jaxan> glguy_: can you write a functor instance for that? what does it do on C2?
12:57:46 <Jaxan> oh wait
12:57:46 <glguy_> fmap f (C2 x) - C2 (f x)
12:57:52 <hiptobecubic> if i want to cabal install a library with options, how would I?
12:58:00 <Jaxan> yeah, gadts where some time ago, glguy_ thanks!
12:58:03 <hiptobecubic> I also don't know the name of the option
12:58:13 <dwcook> glguy_, typo s/-/=/
12:58:40 <glguy_> dwcook: don't worry, I'm not actually running code in this IRC session
12:59:00 <dwcook> Yeah, just caught me off guard for a moment so I thought others might be as well :P
13:02:17 <Profpatsch> Hm, how do I construct a list from some contants I define in a where clause?
13:02:29 <c_wraith> use a list literal?
13:02:30 <glguy_> [constant1, constant2]
13:02:41 <Profpatsch> Oh, too much lisp. :)
13:02:47 <Profpatsch> I forgot the commas.
13:03:04 <c_wraith> still syntactically valid, but it treats them as function calls. :)
13:03:13 <Profpatsch> That was the problem, yeah.
13:04:33 <hoppypops> Hi, I'm using MVector which uses the RealWorld type. I want to provide a signature for my function, where can I import the RealWorld type from?
13:05:57 <Cheery> what does deterministic context-free grammar mean?
13:07:58 <kgadek> carter: thanks, I'll look at that. // sorry for *long* no-response, I was offline for quite a while
13:08:10 <carter> i don't remember what i said
13:08:11 <carter> :)
13:08:12 <int3__> hoppypops: load your program into ghci, then type :t yourFunctionName. I believe it should give you the fully qualified type name
13:08:56 <kgadek> carter: yeah, that was indeed *quite* a while :)
13:10:47 <Tjr> How do I learn to write a good library, i.e. what do I need other than good coding?
13:11:18 <Profpatsch> Is there a way to tell the hoogle command to search all packages?
13:11:40 <Jaxan> Tjr: relevance of the library ;)
13:11:41 <platz> Tjr: I believe this is a difficult question that there isn't any good guidance on
13:11:48 <dwcook> Tjr, write good documentation
13:11:58 <dwcook> That's the main complaint I have about most packages I see
13:12:28 <dwcook> Of course what constitutes "good documentation" is an entire problem itself
13:12:39 <Tjr> Jaxan: by extension, that means "find out how people in this field are doing things right now"
13:12:46 <Tjr> platz: I know :-(
13:13:06 <Tjr> dwcook: I'm one of the complainers. Sadly, that doesn't make my documentation good.
13:13:19 <platz> agree with documentation.. also perhaps some notion of thinking aobut what your "API" will be - as opposed to having all your internal functionality hanging out without any separation forcing others to wade through
13:13:36 <hoppypops> int3__: it's a bit chicken/egg, I can't write a ocrrect function that returns a value without providing a signature. I can't provide a signature without understanding the type
13:14:16 <Purity> Hi all, I was wondering how would I create a PrimeNumber typeclass that overrides the 'succ' function to get the next prime number?
13:14:30 <Iceland_jack> Tjr: The vast majority of uses tend to center around a handful of functions, so try to identify a few 'main' idioms and key functions and document them extensively
13:15:02 <dwcook> Purity, why a typeclass? Let's start with something basic. Is a list of primes insufficient for your purposes, and if so, why?
13:15:05 <mwhit> Purity: that wouldn't be a typeclass
13:15:05 <Tjr> Iceland_jack: good point.
13:15:17 <int3__> @hoogle RealWorld
13:15:17 <lambdabot> Control.Monad.ST data RealWorld :: *
13:15:17 <lambdabot> Control.Monad.ST.Lazy data RealWorld :: *
13:15:17 <lambdabot> package acme-realworld
13:15:27 <int3__> hoppypops: ^
13:15:31 <c_wraith> Purity: you don't do that with a type class.  You do that with a type.
13:15:50 <c_wraith> Purity: You'd do something like newtype PrimeNumber = PrimeNumber Int
13:15:54 <Purity> Sorry, wasn't sure of the term. A list of primes would be fine but I was just trying to think of how I would do it with a type
13:15:55 <Iceland_jack> Tjr: It's also nice to emphasize those examples if you choose to document every function/type/... by putting them at the top of their modules and by putting an example in the .cabal file description
13:16:23 <c_wraith> Purity: and then you'd write an Enum instance for that type whose instance only returns primes
13:16:23 <Iceland_jack> That way users can get the basics of your library without digging through the modules
13:16:53 <hoppypops> int3__: thanks, I found that. It seems the type is not exported though
13:17:13 <Purity> c_wraith: I see, I'll give it a try and I'll come back with what I write.
13:17:45 <dwcook> That'd be interesting. I guess you'd skip making a Num instance and things because most of those operations aren't closed under primeness
13:18:18 <Tjr> Summary, how to write a good library: (1) find out the target audience's needs, (2) have good taste, including the API, (3) document all of it a bit, (4) document the most common use cases extensively, with examples, and in an easy-to-find location, e.g. in the .cabal file description (5) be a marketing genius
13:18:43 <mwhit> Purity: There are lots of simple ways of making a list of the primes, but most of them will be quite inefficient for large ones. Writing an *efficient* primes list is a less trivial problem
13:18:51 <Tjr> anything else?
13:19:13 <mwhit> Purity: see this for some good implementations and discussion: http://www.haskell.org/haskellwiki/Prime_numbers
13:19:18 <Purity> mwhit: I can create a list of primes, I'm just experimenting more than anything
13:20:32 <kgadek> carter: that script ( https://github.com/hvr/multi-ghc-travis ) is okay but requires constant un-/install cycles, while I'd like to get ALL of them at once. The idea for now is to symlink .cabal directory and change the symlink when I'd like to use different cabal… but that does not allow me to have multiple simultaneous builds. Or to chroot it (probably best solution)
13:20:47 <carter> kgadek: read more closely
13:20:54 <carter> the way it works allows things to run in tandem
13:21:01 * hackagebot hsexif 0.6.0.0 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.6.0.0 (EmmanuelTouzery)
13:21:06 <carter> its not done that way in travis
13:21:09 <carter> but it could be
13:21:46 <kgadek> oh okay, my bad :<
13:22:02 <carter> its a good starting point of something kinda like what you want though
13:22:06 <dspies> How do I specify infix operator precedence with TypeOperators?
13:22:08 <carter> i agree it's not out of th box
13:22:22 <carter> dspies: infxl/infxr op $somenumber
13:22:24 <carter> ?
13:22:34 <dspies> thanks
13:25:00 <dspies> carter: I'm just getting ParseError
13:25:17 <carter> @lpaste or no one will help you :)
13:25:18 <lambdabot> Haskell pastebin: http://lpaste.net/
13:25:21 <dspies> carter: Where can I find information on TypeOperators, google isn't bringing up anything useful
13:25:31 <carter> @lpaste what your'e trying to do
13:25:31 <lambdabot> Haskell pastebin: http://lpaste.net/
13:25:38 <carter> or no one can help you
13:26:02 <carter> otherwise your question has the specificify of "my computer doesn't work" :)
13:26:10 <carter> and then i have to ask "is it plugged in"
13:26:12 <carter> metaphorically :)
13:26:57 <carter> so share teh code + the errors so folks can help
13:27:21 <Tjr> is there some way to browse the complete collection of @remember / @quote gems?
13:27:25 <dspies> carter: http://lpaste.net/107799
13:27:40 <carter> dspies: thats not the full module
13:27:42 <carter> whats the full module
13:27:53 <carter> you need {-# LANGUAGE TypeOperators #-}
13:28:01 <carter> and no dollar sign
13:28:13 <carter> twas a metavariable :)
13:28:24 <mmmm> Is "value <$ f" considered more idiomatic than "f >> return value" or "f *> return value" ?
13:28:53 <dspies> carter: Ok, so how does it distinguish between normal infix declarations and TypeOperators infix declarations?
13:29:05 <carter> dspies: idk, read the compiler source?
13:29:14 <carter> did you try my suggestions?
13:30:01 <carter> g2g
13:30:03 <dspies> carter: Yes, it compiles but that's not the point.  How do I declare that both the type operator and the constructor are infixl 9?
13:30:27 <carter> i think you did :)
13:30:32 <carter> did you test it?
13:30:44 <dspies> carter: I'm not asking whether I did, I'm asking what the general rule is
13:30:56 <carter> decalre the fixity
13:31:05 <carter> thats all there is to it
13:31:09 <dspies> carter: So an operator has one precedence regardless of whether it's used on types or on data
13:31:11 <dspies> ?
13:31:13 <carter> no
13:31:17 <carter> well
13:31:22 <carter> test it :)
13:31:31 <carter> honestly i don't know how that works
13:31:34 <carter> try writing some examples
13:31:47 <dspies> carter: But that's what I hopped on this channel to ask in the first place
13:31:48 <carter> use the ' prefix notation to get one or the other
13:31:55 <carter> dspies: you know the ' prefix?
13:31:57 <dwcook> I think I recall reading that if you have a type and a value operator of the same name, the fixity declaration applies to both. I might be misremembering though.
13:32:00 <dwcook> Ohhh.
13:32:05 <dspies> carter: what's the ' prefix notation?
13:32:16 <mwhit_> https://ghc.haskell.org/trac/ghc/ticket/6027
13:32:21 <mwhit_> they are always the same
13:32:36 <dspies> mwhit_: Thank you
13:32:52 <carter> Distinguishing between types and constructors
13:32:57 <carter> http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/promotion.html#Distinguishing-between-types-and-constructors
13:32:59 <carter> read that
13:33:00 <carter> :)
13:33:40 <carter> wrt the type vs value name space, i THINK that addresses your question
13:33:42 <carter> i might be wrong
13:33:45 <carter> but G2G
13:33:47 <carter> so cant help more
13:40:17 <trap_exit> in a haskell module, is there a way to control the list of functions taht the module exports ?
13:40:38 <int3__> trap_exit: module Foo (Exported1, ...) where
13:41:24 <int3__> trap_exit: http://en.wikibooks.org/wiki/Haskell/Modules#Exporting
13:41:26 <trap_exit> int3__ : thanks!
13:42:29 <mm_freak_> hi there
13:43:03 <mm_freak_> given a data structure like a monoid product:  data A = A String Text
13:43:39 <nolrai_66> Hey, so does anyone have a good summery of the +/- for Elm vs GHCJS vs Diagrams for making a simple 2d shooter?
13:43:39 <mm_freak_> is there something that is /between/ a lens and a prism?  the Text part is always there, and it's sufficient to construct an A by using 'mempty' for the String part
13:44:17 <mm_freak_> i can probably write a type for that thing, but does it have a name?
13:44:38 <glguy_> mm_freak_: You can make a "Review" for the construction direction
13:44:53 <glguy_> but you can't make any sort of lawful optic for that field in general like that
13:45:06 <glguy_> because you'd lose the value on the roundtrip and fail the laws
13:45:46 <glguy_> So you could have one: Lens' A String, and one Review' A String
13:46:33 <mm_freak_> hmm, i see
13:46:35 <mm_freak_> thanks
13:46:37 <joof> nolrai_66: http://www.haskell.org/haskellwiki/The_JavaScript_Problem is the best I got for you
13:47:00 <nolrai_66> joof: thanks
13:47:03 <glguy_> The law in particular is: Second, if you can extract a value a using a Prism l from a value s, then the value s is completely described by l and a: If preview l s ≡ Just a then review l a ≡ s
13:47:19 <joof> I'd say check out what necessary libraries each supports?
13:47:25 <bergey> nolrai_66: I haven't used Elm.  I think it's probably the easiest to get started with, and the shortest time to get something on the screen.
13:47:54 <mm_freak_> glguy_: i interpret what you wrote as a sort of constructor-injectivity law
13:48:22 <joof> I like elm's time-traveling-debugger, but I've never used the language seriously
13:48:32 <mm_freak_> glguy_: i.e. a prism corresponds to a virtual injective constructor, correct?
13:48:47 <nolrai_66> bergey: Yeah, I have something writen up in elm already. I'm just worried that as I get bigger I'll start to feel its limitations.  Not having type classes scares me.
13:49:26 <bergey> We haven't put much time into making Diagrams fast, so I expect redrawing several times a second will be a problem.  And the main Backends focus on file output, rather than drawing to the screen.  (I should probably admit that I'm not maintaining the OpenGL backend, at least until I can rewrite for WebGL.)
13:49:53 <bergey> nolrai_66: That's pretty much why I use Diagrams and GHCJS, and haven't tried Elm :)
13:49:55 <glguy_> So you're saying:  review _P x ~ review _P y ==> x ~ y
13:50:44 <mm_freak_> glguy_: ok, but then what i'm looking for is not a prism anyway
13:51:03 * hackagebot amazon-emailer-client-snap 0.1.1.1 - Client library for amazon-emailer daemon  http://hackage.haskell.org/package/amazon-emailer-client-snap-0.1.1.1 (DanielPatterson)
13:52:02 <bergey> GHCJS and HTML canvas (and optional FRP library) seems like a nice way to go.  GHCJS is very new, and not easy to build yet, but luite (the author) is very quick about fixing things.  There aren't many bindings to JS libraries yet.  I'm hoping to add some soon.
13:52:41 <nolrai_66> bergey: Do you mean using Diagrams /or/ GHCJS or can one use Diagrams with GHCJS?
13:52:49 <mm_freak> glguy_: ok, but then what i'm looking for is not a prism anyway
13:53:57 <bergey> I meant one or the other.  You can use them together.  See: https://github.com/ghcjs/diagrams-ghcjs  http://paste.hskll.org/
13:54:25 <bergey> The second URL is the pastebin where Diagrams code you enter is compiled to JS and returned to the browser.
13:55:20 <bergey> It's currently using an old version of Diagrams (~ August of last year).  I'm working on updating it in the next few weeks.
13:55:31 <nick_named> Does the dual function to intersperse exist in Prelude/Data.List?
13:56:28 <mm_freak> anyway, i'll just use separate definitions
13:56:30 <mm_freak> thanks!
13:56:41 <sevak> hi people, I'm trying exercise 5 (tower of hanoi), and the 3 step algorithm it provides seems too simple, and I'm not sure how to start.. I've tried a flash game to try to map it out http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
13:57:31 <monochrom> exercise 5 from which book?
13:57:49 <sevak> in the pdf I linked to
13:58:07 <luite> yep, diagrams and ghcjs have been improved much since http://paste.hskll.org/ was published
13:58:13 <sevak> oh hey monochrom I think you've helped me in the past
13:58:46 <BMeph> nick_named: I doubt it; that sounds more like a Data.List.Split thing. :)
14:00:09 <raschwell> Did anyone from here do live programming in haskell?
14:00:16 <joof> sevak: that's the solution. it's even on wikipedia :P http://en.wikipedia.org/wiki/Tower_of_Hanoi#Recursive_solution
14:00:35 <nick_named> BMeph: Thanks, its weird that intersperse is in Data.List but split isn't
14:00:43 <monochrom> it is meant to be simple, as in: you just output a list of "moves", you don't even worry about showing animations
14:01:39 <luite> bergey: i wrote some deployment docs a few days ago, you might want to use incremental linking for the pastebin, load most of the diagrams library code from a static location, see https://github.com/ghcjs/ghcjs/wiki/Deployment
14:01:49 <monochrom> step 1 "move n-1 discs from a to c using b as temp" is simply a recursive call. similarly step 3.
14:01:49 <sevak> joof: I guess I don't want the full solution, want to figure out at least some of it on my own..
14:02:13 <monochrom> your real work is step 2 as well as concatenating 3 lists
14:02:35 <nick_named> sevak: The 3 steps is the full solution psuedocode.
14:02:36 <monochrom> and the base case.
14:02:58 <luite> bergey: that also greatly speeds up recompilation time, so then you could add some preview/save thing so users can make their code work first before finally publishing :)
14:03:03 <orion> Hi. Would it be correct to describe a Monad this way?: "a unit of computation which, when evaluated, can only return a value of a specific type"
14:03:09 <nolrai_66> bergey: installing GHCJS's requirements now...
14:03:40 <nolrai_66> orion: no. But what you mean by that is sort of right.
14:03:49 <mwhit> orion: i guess that's not *incorrect* (nitpicking over terminology aside), but it doesnt really tell you much
14:04:10 <joof> sevak: well you need to translate it to code. the base case is n=1, wikipedia has a slightly more in-depth explanation if you care for it
14:04:12 <bergey> luite: Yes, incremental loading seems like a good idea.  Though I have lots of "it doesn't compile" to fix before I start worrying about page load times :)
14:04:18 <bennofs> is there something which when evaluated can return a value of an *unspecific* type in haskell?
14:04:23 <monochrom> orion: I think it describes a mono-type value and has nothing to do with Monad.
14:05:19 <mwhit> orion: the best way to describe monad is:
14:05:23 <mwhit> :t (>>=)
14:05:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:05:24 <mwhit> :t return
14:05:25 <lambdabot> Monad m => a -> m a
14:05:36 <bennofs> don't forget the laws :)
14:05:36 <monochrom> a mono-type value means for example you declare "x :: Int; x = 34^34" so when you evaluate x you get a value of a specific type, Int.
14:05:41 <mwhit> and laws, yes
14:05:43 <nolrai_66> mwhit: IO fails under that description..at least if you define "return" to mean more then just the return function. (which is not the right name. It should be wrap.)
14:06:09 <fread2282> nolrai_66: huh? no...
14:06:11 <mwhit> uh what?
14:06:19 <mwhit> how would i define return to mean something other than itself
14:06:19 <luite> bergey: minifying the rts / library for incremental links with closure compiler can also be done, but it will require a small bit of scripting to make it work, i'll add a tool for that later when i have some time for that
14:06:58 <sevak> hmm ok, it seems like my confusion is that sometimes in the process of step 1, I need to move one off of C and maybe use A as temp storage before n-1 has moved... if that makes sense
14:07:17 <nolrai_66> mwhit: you cant (type safely) ever extract a value from IO.
14:07:32 <fread2282> nolrai_66: yea you can...
14:07:38 <monochrom> you just use recursion for step 1. with clever choice of parameters.
14:07:39 <fread2282> unsafePerformIO
14:07:42 <mwhit> mwhit: what does that have to do with what i said
14:07:43 <mwhit> haha
14:07:47 <mwhit> i mean nolrai_66
14:07:54 <fread2282> if you preserve the invariants, it's perfectly safe
14:08:00 <nolrai_66> So saying a IO computation "returns a value" is a little...
14:08:02 <Algebr`> I'm trying to convert a list of string, with duplicates, into a Data.Map s.t. the keys are the string and the values are the frequency counts of the strings in the initial list of strings. What would be a smart approach?
14:08:13 <sevak> ok thanks guys I'll try it out
14:08:13 <bennofs> fread2282: focus on *type safe*. of course you can always unsafeCoerce :)
14:08:14 <fread2282> nolrai_66: but IO is just State RealWorld
14:08:31 <nolrai_66> fread2282: unsafePerformIO is unsafe..
14:08:45 <bergey> luite: Cool.  I'm also hoping to find time to write some library bindings soonish.  Any JS bindings you'd particularly like to see?
14:08:49 <monochrom> State RealWorld is only one way to implement IO and not the most informative way
14:09:11 <fread2282> unsafePerformIO is typesafe, it just has problems if you/GHC run it at the wrong place
14:09:16 <monochrom> in fact, only one small part in one way to implement IO
14:09:29 <luite> bergey: (you have to generate a list of all public ghcjs exposed symbols so they don't get renamed, and all non-public symbols should be wrapped in a function scope so they can be renamed to short names without polluting the global namespace)
14:09:37 <fread2282> IO makes sure that that never happens
14:09:40 <dmj`> Algebr`: use insertWith (+)
14:09:47 <dmj`> @typ Data.Map.insertWith (+)
14:09:48 <lambdabot> (Ord k, Num a) => k -> a -> M.Map k a -> M.Map k a
14:10:00 <bennofs> fread2282: you can implement unsafeCoerce with unsafePerformIO, fyi
14:10:02 <monochrom> people look at the internal code "State RealWorld -> (a, State RealWorld)" and they think they know what's going on. they don't.
14:10:27 <nolrai_66> from the docs: "It is less well known that unsafePerformIO is not type safe."
14:10:35 <bergey> Yeah, that makes sense.  Does that mean that right now the non-public symbols are in the global namespace?  I guess that's harmless, since they have names only a compiler could love.
14:10:48 <cgroza> I have a small question. How many times will the list be traversed by the function? http://lpaste.net/107803
14:10:57 <cgroza> in main
14:11:05 <Valeria21>  Here some videos. I hope you like them! http://j.mp/1sBRo2k
14:11:07 <luite> bergey: someone has already written react bindings, that seems to be the most requested one. i'd personally like to see some d3 and mathbox bindings for interactive/moving graphics. diagrams is fun, but not particularly performant for realtime/interactive things yet (in particular when compiled to JS)
14:11:25 <mwhit> fread2282: "typesafe unless you run it in the wrong place" is a valid definition of "not typesafe"
14:11:36 <monochrom> for starters, the RealWorld type is phantom and does not even have any value. nothing in the generated code represents any RealWorld value. there is no such thing.
14:11:50 <nolrai_66> I need fast Many to few collision checking for my thing..
14:13:24 <bergey> luite: Good, D3 seems easy, and I'll bet lots of people would like to have it.  I definitely want to try out the React binding.  I suspect React will be nicer to combine with FRP, and just more like idiomatic Haskell in general.
14:13:24 <phaskell> D3: [nagios-master] Use nginx instead of apache. - https://phabricator.haskell.org/D3
14:13:26 <quchen> cgroza: That depends a lot on what you mean with "traverse". The list will be walked from left to right once, but each (:) constructor might be looked at multiple times. And then there's fusion, which may reduce the redundant (:) evaluations.
14:13:38 <bergey> luite: I hadn't seen mathbox before.  Thanks for the tip.
14:13:45 <quchen> For example, the map and the filter will probably be fused to a single function.
14:14:05 <fread2282> but unsafePerformIO is a perfectly safe way to implement >>=, right?
14:14:19 <monochrom> cgroza: which list are you referring to? there are 4. however, each is traversed at most once.
14:14:31 <bergey> luite: Three.js would also be pretty easy, but it's pretty imperative, so it may feel weird to use from Haskell.
14:14:37 <bitemyapp> monochrom: the real world doesn't exist.
14:14:43 <bitemyapp> spooky.gif
14:14:45 <cgroza> monochrom, the one in main [1 ... ten milion]
14:14:59 <monochrom> at most once.
14:15:22 <cgroza> quechen: so that means i do not lose efficiency by using a list in this case?
14:15:35 <quchen> fread2282: No, IO is not State Realworld, it's abstract. GHC chooses to implement it using primitives called State# and RealWorld, but that's besides the point.
14:15:47 <ruuns> @valeria21 what's actually phabricator? :]
14:15:47 <lambdabot> Unknown command, try @list
14:16:27 <luite> bergey: the react binding uses StableName comparison to quickly see whether data has changed (stable names are pretty cheap with GHCJS), but i suspect the idea should be taken further to fully exploit immutability and sharing
14:16:52 <monochrom> unsafePerformIO does not help implementing >>= at all.
14:18:32 <luite> bergey: for example if you update some Data.Map and most of the nodes are shared, it should be able to skip over all unchanged entries quickly (using the balanced tree structure instead of checking all mappings)
14:18:33 <bergey> luite: Oh, that's great.  I didn't know it did anything with StableName.  I saw your GSOC proposal around exploiting immutibility for faster VDOM diffs.  But I figure step 1: make some cool examples using GHCJS, step 2: attract more people to work on libraries. :)
14:19:09 <quchen> monochrom: Re "there is no RealWorld", would you say it's less there than Void even? Or can I see it as a sort of Void#?
14:19:45 <monochrom> I guess yes. I don't want to think too much about it.
14:19:54 <luite> bergey: yeah, the person who's doing that project is now taking a bit of a different approach, but other people couldn't wait, apparently :)
14:20:19 <bergey> luite: hehe :)
14:21:33 <bergey> luite: Back to WebGL for a moment, I've enjoyed using the vinyl-gl library.  How insane is it to compile vinyl with GHCJS?  (vinyl is like HList; extensible records)
14:21:37 <luite> bergey: and i think a general solution can only work if there's some observable traveral class where at every node there's a check whether a subtree has been seen before
14:23:30 <luite> but that will take some work. the sharing is lost the moment you render the Data.Map -> HTML
14:23:48 <luite> so the incrementalness has to be in that function, not after
14:24:26 <luite> bergey: shouldn't be crazy at all, but if it does some low level rts tricks to make it fast, some adjustments might be needed
14:25:37 <Tiktalik> Hi.
14:25:52 <bergey> Ah, I see.  And that means observable-traversal instances for whatever types are passed in as props?
14:26:06 * hackagebot github-backup 1.20140720 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20140720 (JoeyHess)
14:26:18 <luite> bergey: template haskell works well now, so deriving instances shouldn't be a problem (it's run on node.js, i want to take the same approach for ghcjsi, but there i also want to give users the option to use a browser instead, so ghcjsi can directly add things to the document)
14:26:41 <bergey> I think vinyl just uses lots of GHC kind magic, not RTS stuff.  But I could be wrong.
14:26:58 <luite> GHC frontend magic is no prob at all
14:28:33 <bergey> Oh, great.  This all sounds very promising!
14:31:27 <nolrai_66> luite: I just got cabal hell problems following the directions in the ghcjs README..
14:31:52 <luite> bergey: then it compiles each TH expression individually, sends it to the js runtime and retrieves the result
14:31:55 <luite> oosp
14:32:03 <luite> bergey: GHCJS uses this small runner script to run TH. first it sends the RTS and the code to serialize TH results and to talk to GHCJS for reification queries https://github.com/ghcjs/ghcjs/blob/master/lib/etc/thrunner.js
14:32:07 <luite> bergey: then it compiles each TH expression individually, sends it to the js runtime and retrieves the result
14:32:15 <luite> bergey: for interactive haskell, ghcjsi, exactly the same approach can be used, with the haskell session running in a js engine, ghcjs compiling and sending each expression to it
14:33:19 <luite> nolrai_66: oh you're not running GHC 7.8.2 are you? bergey mentioned yesterday that the haddock-internal package on there does not compile with 7.8.2, only 7.8.3
14:33:31 <luite> nolrai_66: and i haven't fixed it yet
14:34:10 <nolrai_66> woah I am all the way back at 7.6.* yikes.
14:35:34 <nolrai_66> Okay this is a dumb question but I haven't been using Haskell in a while..how do I upgrade to the latest ghc again?
14:35:45 <luite> yeah you really need 7.8 for GHCJS since it depends on improvements to cross compilation and some specific changes to support GHCJS (foreign import javascript and some patches to allow programs that use GHC as a library to have more control over how things are compiled)
14:35:49 <bergey> luite: I'm going to have to reread that a few times before I understand. :)
14:36:54 <bergey> nolrai_66: Windows?  Debian?  In general: http://www.haskell.org/ghc/download_ghc_7_8_3
14:38:22 <luite> bergey: it means that incremental linking is cool! (since it's the same feature used here, first send some base set of code to the javascript engine, then keep compiling more code on demand and insert the result (including dependencies) in the session)
14:38:46 <bergey> nolrai_66: On debian / ubuntu / &c, consider this ppa: https://launchpad.net/~hvr/+archive/ubuntu/ghc
14:39:08 <luite> nolrai_66: oh i hope you're not on windows, since i haven't finished fixing the build there yet
14:40:01 <luite> i need to do that soon, since i'm finishing the cabal support patch, and that needs to be tested on windows before it can be reviewed by the cabal devs
14:40:41 <Sornaensis> has anyone here done TLS stuff with haskell before
14:41:59 <slomo> Sornaensis: as in thread local storage? or transport layer security?
14:42:00 <nolrai_66> nope, using a ubuntu virtual machine for programing.
14:42:21 <luite> nolrai_66: join #ghcjs if you have questions later
14:42:33 <nolrai_66> Okay I will!
14:42:35 <nolrai_66> Thanks!
14:43:29 <Sornaensis> slomo: the latter
14:43:35 <luite> uh i didn't min lave #haskell:)
14:43:38 <luite> mean
14:45:57 <slomo> Sornaensis: there are a few options then... there are bindings for openssl and gnutls, and then there's the tls package. the latter is quite simple to use
14:53:34 <maffa> in arrow calculus the L in L \bullet M (arrow application) cannot contain free variables of the second context \Delta. This is meant to make sure L isn't the result of another arrow. Why? (http://homepages.inf.ed.ac.uk/wadler/papers/arrows-jfp/arrows-jfp.pdf Figure 3 has the typing rules)
14:54:37 <maffa> Why can L not be yielded by another arrow this way?
15:06:24 <monochrom> maffa: IIRC if you allowed it, you get monad.
15:06:25 <hiptobecubic> I'm not sure what's going on here. Is it that strict-concurrency doesn't work with ghc 7.8? http://vpaste.net/sCe3n
15:06:44 <monochrom> or rather, you get the monad calculus.
15:08:37 <maffa> monochrom: yes, i mean more technically...like why does excluding free vars in \Delta ensure that this arrow wasn't yielded by another arrow.
15:08:48 <danilo2> Hello! When I'm using my custom preprocessor in GHC then If I get any compilation error, the compiler tells me that the eror is in a file in a tmp direcotry with some random name. Is there any way to get know which file was that in reality?
15:09:08 <monochrom> ah, then I forgot
15:10:42 <pjdelport> danilo2: Does your preprocessor insert LINE pragmas?
15:10:50 <glguy_> hiptobecubic: That package was last updated in 2010 and if it's not building it's likely that base as moved on
15:11:11 <hiptobecubic> recent hakyll depends on it.. i'll ask them i guess
15:11:38 <pjdelport> danilo2: You can use those to point GHC at the the file and line of the preprocessor's input, instead of the temporary file.
15:12:19 <pjdelport> danilo2: It looks like: {-# LINE 42 "Foo.vhs" #-}
15:15:52 <orion> On a high level, are most Haskell applications describable in terms of the "Hask" category? What parts of the language fall outside this description?
15:18:36 <benmachine> orion: often Hask is used to denote a category that is not exactly Haskell but close to it
15:19:06 <benmachine> for example, Void isn't a true initial object, because it's inhabited by bottom
15:19:15 <benmachine> so sometimes when people say Hask they mean Haskell-without-bottoms
15:19:32 <benmachine> or the subcategory of total Haskell functions, perhaps
15:19:55 <rasfar> orion: you mean at the architectural level? i'd guess most laws would not hold at that scale, unless you designed specifically for that
15:20:08 <orion> interesting
15:21:59 <danilo2> pjdelport: hmm, interesting! I have to read about it! These preprocessors map strictly to the same lines as the input file, but maybe this pragma will help, thank you! :)
15:23:55 <rasfar> i guess i misunderstood, excuse me; you're at a meta remove
15:27:15 <trap_exit> is there a negate function in Haskell? (a -> Bool) -> a -> Bool
15:27:24 <trap_exit> I think what it does is easily gussable
15:27:36 <trap_exit> hmm, I thin it's called (not . )
15:30:35 <orion> Is it right to say that * represents all possible types, and hence, * is essentially the Hask category?
15:35:20 <quchen> * is the kind of types. "* represents all possible types" is similar to "forall a. a represents all possible values", which isn't quite right.
15:35:35 <sveit> using multiparamtypeclasses, i am wondering how to have something like "class (Cb b) => C1 a b where { f :: a -> b; g :: a -> Int; g = fb . f }" where Cb provides a function fb :: b -> Int? right now i get an ambiguous type error.
15:35:53 <sveit> i'd rather not have a take 'b' as a parameter
15:36:05 <rasfar> orion: i presume you've seen http://stackoverflow.com/questions/17380379/where-do-values-fit-in-category-of-hask but I'm finding it quite enlightening...
15:36:44 <rasfar> (not that you're asking about values specifically, but that real applications are mostly value-centric)
15:36:49 <roboguy_> orion: * represents all types that have values
15:36:57 <EvanR> :k Maybe
15:36:58 <lambdabot> * -> *
15:37:13 <orion> rasfar: I Am reading through http://en.wikibooks.org/wiki/Haskell/Category_theory
15:37:33 <glguy_> sveit: The compiler will never be able to determine which instance to use when you try to call 'g'
15:37:39 <rasfar> okay; i have that open also
15:37:40 <roboguy_> all types that aren't in * are uninhabited by values
15:37:45 <glguy_> because the type 'b' is not mentioned in 'g's type
15:38:23 <jomg> yea, maybe a fundep would do it
15:38:55 <sveit> i don't want the fundep
15:38:59 <sveit> that's part of the point
15:39:08 <EvanR> :k Maybe a
15:39:09 <lambdabot> Not in scope: type variable ‘a’
15:39:11 <glguy_> sveit: Then you have to split your type class in half
15:39:12 <monochrom> use ScopedTypeVariables so you get to say "it's b"
15:39:18 <EvanR> :k forall a. Maybe a
15:39:19 <lambdabot> *
15:39:44 <orion> What's an example of a type without a value?
15:39:51 <EvanR> Maybe
15:40:16 <sveit> monochrom: that's exactly what i wanted to do probably, i was just going to say i was basically trying "g = fb . (f :: a -> b)", but that' doesn't seem to work either
15:40:41 <glguy_> sveit: You can't have a class member that doesn't mention types which are not constrained by fundeps
15:41:14 <orion> :k Maybe
15:41:15 <lambdabot> * -> *
15:41:47 <orion> Would it be incorrect to call Maybe an "incomplete" type?
15:41:59 <EvanR> so Maybe a has type * where a has kind *
15:42:22 <EvanR> er
15:42:25 <roboguy_> orion: hmm, I've not really heard that terminology before
15:42:26 <EvanR> so Maybe a has kind * where a has kind *
15:42:46 <EvanR> :k Void
15:42:47 <lambdabot> Not in scope: type constructor or class ‘Void’
15:42:53 <monochrom> add ScopedTypeVariables. then (f :: a -> b) does it. I've just tried.
15:42:58 <roboguy_> orion: it's a type that happens to be a type constructor (which is a certain kind of type function)
15:43:06 <quchen> Void :: *
15:43:16 <roboguy_> similar to how functions are values, but we're talking about stuff at the type level
15:43:32 <jomg> monochrom: but can you apply g then?
15:43:46 <rasfar> wow, "incomplete" doesn't appear a single time in HoTT
15:43:59 <monochrom> I don't know
15:44:34 <monochrom> I guess not.
15:44:42 <sveit> glguy_, monochrom: i see what you are saying
15:44:50 <sveit> any chance of getting around this or am i stuck?
15:44:57 <glguy_> We're saying different things
15:45:07 <sveit> yes, and i understand both of you :)
15:45:18 <monochrom> perhaps "g :: a -> Int" belongs to another class, one that is just about "a".
15:45:27 <glguy_> now we're saying the same things :)
15:45:36 <sveit> monochrom: thing is, it needs information about b
15:45:56 <glguy_> sveit: Then add a parameter that mentions 'b', like Proxy b or similar
15:46:15 <sveit> i guess i could also define it outside of the typeclass as f . fb if i wanted, right?
15:46:29 <sveit> sorry, fb . f ***
15:46:51 <jomg> sveit: it probably still wouldn't know which b to use
15:47:09 <glguy_> Well, it'd use whichever b you fixed it to use in that case or you'd have to take a proxy parameter :)
15:47:28 <EvanR> so Void has kind * according to the previous definition because of bottom. but is there some kind of type level bottom with kind * -> *
15:47:35 <monochrom> it is very strange that something of type "a->Int" depends on an unknown type not mentioned in "a->Int"
15:47:41 <orion> Syntactically speaking, on this line of code, what is 'm'?: class Functor m => Monad m where
15:47:57 <EvanR> a type variable
15:47:58 <rasfar> a type parameter?
15:48:04 <glguy_> sveit: It's hard to give you very good advice because we don't know what it is you're trying to do
15:48:16 <monochrom> orion: m is a type variable. its kind is *->*. you may also say "type constructor"
15:49:17 <roboguy_> EvanR: probably the uninhabited type family of kind * -> *
15:49:52 <maffa> arr ( \p -> e2 ) >>> e1 why is this only meaningful if e1 contains no variables defined in p?
15:50:11 <roboguy_> actually, wait that might not work
15:50:25 <monochrom> sveit: there are two cases. Case 1: for every "a", there is only one correct "b". then this is functional dependency. Case 2: user of g has freedom to choose what type for b. then this require "b" to appear in g's type, for example "Proxy b -> a -> Int"
15:50:30 <rasfar> it's a type variable, but more specifically a type parameter, right?
15:51:00 <rasfar> (referring to orion's question, not sveit's)
15:51:02 <hiptobecubic> how do you specify flags in a cabal file?
15:51:15 <hiptobecubic> like my project depends on package foo with flag -fbanana
15:51:22 <glguy_> nope
15:51:28 <hiptobecubic> "failed to parse cabal file" is a pretty worthless error
15:51:33 <roboguy_> rasfar: in that particular context, it is a parameter of Functor and then a parameter of Monad
15:51:40 <roboguy_> in general, it is a type variable
15:51:51 <rasfar> right, thx
15:51:52 <glguy_> You can't depend on a flag being set or not in a package
15:52:26 <hiptobecubic> i see
15:52:35 <rasfar> hiptobecubic: it would be nice though; for example if you use Snap and want -fopenssl, i don't know how to build that in one shot
15:52:41 <hiptobecubic> right
15:52:46 <hiptobecubic> i want hakyll +watchserver
15:52:57 <glguy_> It's basically a bug in the upstream package if they hide stuff unless you add a flag
15:53:10 <rasfar> yeah
15:53:48 <rasfar> i guess if it wasn't for distribution, you could use your own version with the flag default changed in the hakyll.cabal
15:54:02 <hiptobecubic> how do you unregister a package in a cabal sandbox?
15:54:22 <rasfar> ghc-pkg --package-db=<path-to-sandbox> ...
15:54:24 <glguy_> cabal hc-pkg --- is like ghc-pkg but for sandboxes and stuff
15:54:34 <hiptobecubic> thanks
15:54:35 <rasfar> oh thanks for that glguy_ haha
15:54:55 <hiptobecubic> glguy_, cabal hc-pkg unrecognized :(
15:55:39 <glguy_> err: cabal sandbox hc-pkg
15:55:40 <rasfar> yeah i don't see it for 1.20.0.3 either
15:56:04 <roboguy_> EvanR: hmm I doubt a type level bottom would have kind * -> *
15:56:05 <rasfar> ah yeah there it is
15:57:58 <sjouke> will someone speak on why classical inheritance isn't much of a feature in modern software design?
15:58:01 <roboguy_> I wonder if there's a way to export a kind created with DataKinds without exporting the type...
15:58:07 <roboguy_> I have a feeling there isn't
15:58:50 <EvanR> roboguy_: it would contradict the definition of * given above
15:58:55 <roboguy_> EvanR: ?
15:58:59 <EvanR> so now im thinking there arent any
15:59:02 <roboguy_> oh
15:59:08 <roboguy_> well, it wouldn't have kind * -> *
15:59:10 <rasfar> cabal exec -- ghc-pkg unregister works too (in sandbox), fwiw
15:59:14 <roboguy_> it might have a kind VoidKind
15:59:48 <roboguy_> but there would probably need to be a way to export the new kind VoidKind without exporting the associated type, and I suspect that's not possible
16:00:08 <EvanR> so bottom inhabits every type but not every kind
16:00:22 <EvanR> alternatively bottom inhabits only * types
16:00:47 <orion> hm
16:01:47 <quchen> I thought there was no TypeVoid in Haskell because typechecking is decidable? Or in what domain are we here
16:01:56 <solidus-river> can you use deriving for classes that you make?
16:02:30 <orion> Maybe is a subcategory of Hask, am I right.
16:02:30 <solidus-river> i have a calss that could easily be a utility function within another class but i want to use the type system to help distinguish instances of each type and enforce some rules around what types are used in what ways
16:02:35 <rasfar> sjouke: to see why specifically in Haskell, I could recommend Simon Peyton-Jones' presentation "Classes Jim But Not As We Know Them"
16:02:45 <roboguy_> EvanR, quchen: what about something like this? http://lpaste.net/107805
16:03:35 <rasfar> solidus-river: no, a person would write instances by hand or use a generics library for that
16:03:42 <quchen> Isn't that TypeAbsurd, roboguy_?
16:04:16 <roboguy_> hmm, yeah
16:04:20 <quchen> Ah no, TypeAbsurd would be family business, no?
16:04:56 <roboguy_> well... it's still a type constructor, so it is also a type function in some sense. but you can never make a * type out of it
16:05:07 <abc56889_> Is there a spiffy way to do `flip fmap` ?
16:05:15 <quchen> <&> from Lens
16:05:16 <solidus-river> the deeper i get into the hask the less i want to write thigns in other languages
16:05:17 <benmachine> orion: Maybe is not a category, so can't be a subcategory of anything
16:05:29 <solidus-river> i really hope haste can work some miracles with this code base and put out some nice javascript
16:05:37 <EvanR> roboguy_: type void, but not a type bottom
16:05:42 <abc56889_> solidus-river: ruined my career lol
16:05:59 <solidus-river> abc56889_: ? learning haskell did?
16:06:10 <abc56889_> ya
16:06:32 <Sornaensis> why are there two Crypto.Random modules
16:06:34 <roboguy_> benmachine: well, you could probably find some way to make a category out of Maybe (probably a couple), but not an instance of Category
16:06:51 <solidus-river> abc56889_: in waht way? joking or seriouse
16:07:23 <roboguy_> EvanR: right. I bet you could find a type bottom if you turn on UndecidableInstances though
16:07:24 <benmachine> roboguy_: you could perhaps find some way of making a category that involved Maybe in its construction, but it's sufficiently non-obvious that I don't think it's clear what someone is referring to when they use Maybe as a category
16:07:31 <EvanR> roboguy_: ah right
16:07:37 <Sornaensis> how do I hide one package from another with cabal
16:08:08 <benmachine> roboguy_: the best I can come up with is the image of Maybe is a category, but I don't think I'd ever call that category Maybe
16:08:11 <roboguy_> benmachine: Maybes form a monoid which is a well known degenerate category
16:08:13 <abc56889_> solidus-river: sort of tongue in cheek. but i have a hard time motivating myself to write serious programs in dynamic languages these days. anyway this is a bit OTT
16:08:44 <solidus-river> aye, kk, was just courious if somehow pepole lost interest because you started posting about haskell etc
16:08:47 <abc56889_> quchen: lightning reactions tehre I didnt even realise you were answering my question! thanks
16:08:47 <benmachine> roboguy_: oh, I guess that's another way, but even then it's unclear because in fact the monoid is Maybe a for each a
16:08:59 <roboguy_> not only that, Maybes turn semigroups into monoids, which is an important property of it
16:09:03 <sjouke> rasfar: does he even address this question?
16:09:16 <solidus-river> yeah, i'm fixing a tangled mess of a javascript program at work and for sanitie's sake i've been chipping away at some haskell stuff at home
16:09:19 <solidus-river> types are great
16:09:37 <solidus-river> no one at my work thinks so.. so i spend 60% of my time finding out what somethigns supposed to be or wants as an argument
16:09:46 <roboguy_> so there
16:09:52 <benmachine> you need to pick an a or else say what you mean by not picking one
16:09:54 <roboguy_> 's probably a semifunctor there too
16:09:55 <rasfar> sjouke: he explains the decisions about the class system in Haskell, which is somewhat at odds with classical inheritance, so yes.
16:09:59 <roboguy_> benmachine: true
16:10:09 <solidus-river> good comments would solve that, but... they also don't like those
16:10:16 <abc56889_> solidus-river: the type safetype and robustness you get as default in haksell makes writing tests for python code seem like a big fat waste of itme
16:10:29 <EvanR> solidus-river: im trying to write a program to auto detect the types for ruby, i was wondering if it would be possible for javascript
16:10:33 <abc56889_> time that you could spend fighting with cabal dependencies lol
16:10:35 <sjouke> rasfar: i've seen it before, it doesn't address my question in a way that makes sense, and i was hoping for a more direct answer
16:10:53 <rasfar> that's fine
16:10:53 <solidus-river> EvanR: maybe? i don't know thats quite a hell hole to throw yourself into
16:11:06 <EvanR> solidus-river: haha
16:11:15 <solidus-river> EvanR: my reaction to a big javascript program is either comment a lot and use objects as namespaces, the more the better, wtih closures for private instanced data
16:11:25 <solidus-river> EvanR: or maybe... write it in haskell and compile with haste?
16:11:30 <solidus-river> ^ experimenting with that last one
16:11:31 <roboguy_> sjouke: it seems to me that the question is, when is classical inheritance a more natural (or in some way well defined way, better) way to express a problem?
16:11:31 <luite> solidus-river: you cannot derive arbitrary classes, but sometimes deriving GHC.Generics.Generic can give you an instance that can be used to make an implementation for your own class (using default signatures you'd just say: instance MyClass MyType)
16:12:21 <solidus-river> luite: interesting, so if you leave off the where clause it will try to figure it out?
16:12:54 <roboguy_> benmachine: I think you could express that kind of polymorphism as a natural transformation from Identity into Maybe, but I'm not categorically inclined enough (yet) to say for sure
16:13:38 <EvanR> solidus-river: from what i can see in js codebases, there usually isnt much structure to even ask about
16:13:47 <benmachine> roboguy_: there's a link between polymorphism and natural transformations, but it doesn't answer the question of "what are the objects of the Maybe category"
16:13:49 <sjouke> roboguy_: i heard someone present an argument that oop in practice doesn't really allow for modularity
16:13:56 <sjouke> roboguy_: i'm looking for an argument against oop
16:14:06 <Sornaensis> hello
16:14:17 <Sornaensis> what do you do if two packages have a module name collision
16:14:20 <luite> solidus-river: the Generic instances tend to be somewat heavy though, they account for most of the code size in the TH runner code for GHCJS: https://github.com/ghcjs/ghcjs-prim/blob/master/GHCJS/Prim/TH/Types.hs (it has quite a few)
16:14:22 <Sornaensis> and you need both of the packages...
16:14:28 <EvanR> sjouke: its hard to get two people to agree on what oop even is
16:14:40 <EvanR> so for the sake of argument this step is often skipped
16:14:49 <roboguy_> sjouke: oh. I'd be interested to hear about that actually. You can do a sort of oop in haskell, but it is pretty different from what a lot of people are familiar with as "oop". it's a lot like prototype-based oop
16:15:09 <roboguy_> (which is unrelated to haskell type classes, incidentally
16:15:13 <luite> solidus-river: you need a default signature, all the 'instance Binary SomeTemplateHaskellType' in GHCJS.Prim.TH.Types work because of the default sig here: http://hackage.haskell.org/package/binary-0.7.2.1/docs/src/Data-Binary-Class.html#line-97
16:15:26 <solidus-river> EvanR: you can wrangle in js through good namespace encapsulation through closures, you can even get private variables / methods out of it
16:15:44 <benmachine> Sornaensis: there are some solutions, but they're pretty icky. are you sure you need both packages?
16:15:49 <Sornaensis> yes
16:15:50 <solidus-river> EvanR: check out the skillet pattern if your curiouse
16:15:52 <roboguy_> sjouke: one thing to keep in mind is that the terminology difference can confuse things
16:15:55 <benmachine> Sornaensis: which packages are they?
16:15:58 <Sornaensis> crypto-random and crypto-api
16:15:59 <EvanR> solidus-river: yes i do this in js, but if no one else does its not too helpful
16:15:59 <roboguy_> although, you're probably aware of that if you've seen the spj talk
16:16:05 <solidus-river> aye
16:16:10 <sjouke> i think the argument went something like: ~"oop in practice adds unnecessary complexity"
16:16:38 <Hodapp> unnecessary complexity adds: jobs.
16:16:43 <EvanR> lol
16:16:55 <EvanR> and wastes money
16:17:05 <Hodapp> and if jobs are a necessary thing...
16:17:05 <pyon> sjouke: In principle, a module should be capable of exporting as many abstract types as necessary, while internally being able to use the implementation details of all of them. A Java/C#-style abstract class or interface is a limited version of this, where a module exports a single abstract type.
16:17:08 <sjouke> EvanR: re:smalltalk versus the common way of writing oo code (python, ruby, e.g.)?
16:17:12 <Hodapp> then how can you really call the complexity unnecessary?
16:17:21 <benmachine> Sornaensis: hmm. usually there's a better way to do it (like complain to the package authors that their packages don't work together) but the unpleasant way is using PackageImports
16:17:49 <EvanR> sjouke: smalltalk, python, ruby you have at least three different things now
16:17:52 <benmachine> Sornaensis: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#packageimports
16:18:00 <luite> solidus-river: but the code for this approach is definitely heavier than if you write a custom template haskell deriver for everything. fortunately for this code it's not a problem, since this code is only run on a local node.js when GHCJS needs to evaluate Template Haskell, it never ends up in the browser (well, unless you import that module for whatever reason)
16:18:17 <luite> solidus-river: so i went for convenience :)
16:18:45 <roboguy_> benmachine: right. I'm sure that's doable but I'd have to think about it
16:18:58 <pyon> sjouke: Another problem is that adding one more interface to a bunch of classes requires recompiling all of these classes, whereas a ML-style signature can be ascribed to any module as long as the module's contents are compatible, even if the signature was defined after the module itself.
16:18:59 <solidus-river> luite: interesting, did you compare ghcjs to haste? i've heard haste produced much faster / smaller code, but i dont know if thats still true
16:19:15 <benmachine> roboguy_: I think "the Maybe category" is just too vague
16:19:25 <roboguy_> benmachine: maybe. haha
16:19:25 <Sornaensis> benmachine: thanks
16:20:03 <roboguy_> benmachine: what if we see the Maybe type constructor as an endofunctor on Hask that identifies a subcategory?
16:20:20 <benmachine> roboguy_: right, that's the image-of-Maybe that I referred to earlier
16:20:25 <roboguy_> ahhh, ok that makes sense
16:20:32 <benmachine> roboguy_: the problem is not finding an answer, the problem is finding only one :P
16:20:37 <roboguy_> haha, yeah
16:22:35 <Hodapp> pyon: what do you mean by an ML-style signature?
16:22:47 <levi> sjouke: Could you elaborate on what you mean by "classical inheritance"?
16:23:39 <roboguy_> actually, is that Maybe endofunctor a automorphism?
16:24:01 <levi> sjouke: I have a couple of things that might answer your question, depending on what you mean.
16:24:02 <pyon> Hodapp: A ML signature specifies the contents of a module, it can be thought as the "type" of a module.
16:24:31 <Hodapp> pyon: what comprises it?
16:24:31 <pyon> Hodapp: Errr, I mean, a ML signature specifies the parts of a module that are visible from outside.
16:24:51 <Hodapp> okay, that's a bit different :)
16:25:20 <sjouke> levi: i'm referencing the typical way of creating clases and instantiating them with objects using languages i'm familiar with (python, ruby)
16:25:29 <pyon> Hodapp: A bunch of types (datatypes, transparent type synonyms and abstract/opaque types) and a bunch of values (only their types are specified).
16:25:52 <luite> solidus-river: haste is not always faster is the only thing i know. a few months ago someone posted some haste program on reddit and the same program compiled with ghcjs was about twice as fast
16:25:56 <luite> solidus-river: but anton ekblad responded that he had other samples where performance was hugely in favour of haste, which is very well possible, since haste does not do full tall-call optimization and it converts some calls into loops, something that ghcjs cannot yet do
16:25:57 <pyon> Oh, and exceptions.
16:26:51 <roboguy_> sjouke: hmm, that doesn't necessarily involve inheritance though
16:26:52 <levi> sjouke: Well, one problem with it is that it combines two things: First is the creation of a new type as subtype of another, and the second is inheritance of implementation.
16:27:30 <roboguy_> sjouke: without inheritance, there's actually a pretty direct correspondence between that and something in haskell (that's used pretty often)
16:28:09 <levi> sjouke: The two don't *have* to go together. Subtyping is a very reasonable thing to have in a language, but implementation inheritance is troublesome.
16:28:35 <Hodapp> levi: what do you mean 'implementation inheritance'?
16:29:03 <roboguy_> levi: I'm not totally sure what you mean by implementation inheritance, but I'd suspect that that's easier than subtyping in haskell
16:29:05 <EvanR> sjouke: i think for a while people have been suspicious of normal inheritance, instead recommending using "aggregation" to share functionality, but now we have the wonderful world of mixins to make it even more confusing
16:29:26 <Sornaensis> benmachine: I can't seem to get PackageImports to work properly
16:29:35 <levi> Hodapp: Subclasses inherit the behavior of their superclasses without having to provide their own implementation.
16:29:45 <Hodapp> levi: right.
16:30:17 <benmachine> Sornaensis: what goes wrong?
16:30:30 <luite> solidus-river: i'm working on a new optimizer based on a different intermediate language (with more type info) that will make it easier to add rewrite rules for this kind of thing in GHCJS, in the current design it would be too ad hoc
16:31:13 <pyon> Hodapp: The problem with implementation inheritance, at least the way I see things, is that it is all too easy to define things the type checker thinks are subtypes, but in actuality do not respect the Liskov substitution principle.
16:31:20 <Sornaensis> benmachine: well I'm using a cabal file to build this and when I added PackageImports to the extensions section it just says that package-qualified imports are not enabled
16:31:39 <benmachine> Sornaensis: to extensions: or other-extensions: ?
16:31:39 <levi> It's troublesome in that it breaks the encapsulation properties of objects. A subclass that depends on the current implementation of a superclass can break when the superclass changes even if the superclass's external interface remains the same.
16:32:13 <benmachine> Sornaensis: regardless, try adding {-# LANGUAGE PackageImports #-} to the top of the file in which you use them
16:32:23 <luite> solidus-river: and that should also rduce code size and give ghcjs an option to produce non-threaded code, more similar to fay and haste, too. it's not ready yet though, the goal is to have a working implementation around ICFP
16:32:47 <Hodapp> levi: ahh, so it introduces a coupling to the implementation?
16:33:04 <Sornaensis> benmachine: okay that worked, thank you
16:33:42 <levi> If you watch Liskov's Turing Award lecture, she remains skeptical of the implementation inheritance portion of OOP, despite now having her name attached to a widely cited principle in the OOP camp.
16:34:04 <EvanR> pyon: why is liskov substitution only ever a topic when discussing oop stuff
16:34:21 <levi> The OOP camp came up with it.
16:34:22 <luite> solidus-river: wrt code size, if you follow the deployment wiki instructions for GHCJS, simple programs will currently be around ~60kB compressed, including the RTS and all libraries that it requires
16:34:32 <pyon> EvanR: Um, AFAIK, Liskov's substitution principle is a statement about subtyping in general, not just subtyping via inheritance.
16:35:03 <pyon> EvanR: And the principle itself is very reasonable -- any property that holds for a supertype must hold for any subtype of it.
16:35:12 <TheKing444> How does one get ghc-7.8.3 to work with cabal and to see my packages?
16:35:26 <levi> The other problem with OOP inheritance is with subtyping. It's not a problem in itself, but it doesn't interact well if you also want to have parametric polymorphism and full type inference.
16:35:31 <pyon> Errr, I mean for any instance of a supertype and any instance of a subtype.c
16:35:37 <wting> I don't understand why cabal failed to install unix-compat, there's no error message: http://lpaste.net/2523285817451872256
16:35:53 <pyon> levi: Inheritance also interacts badly with concurrency.
16:35:54 <luite> solidus-river: i'm not quite satisfied with that yet though, and more duplicate code can be removed, metadata can be packed more efficiently
16:36:25 <dcoutts> TheKing444: each compiler version has an independent set of libraries
16:36:49 <TheKing444> how do I get "a" cabal to work with ghc7.8.3
16:36:53 <levi> pyon: I'm not certain what you mean specifically, but I suspect that would be a corollary of the coupling problems that it introduces.
16:37:08 <dcoutts> TheKing444: of installed libs I mean. So you have to install the libs you want for that ghc version
16:37:08 <Hodapp> pyon: what about inheritance interferes with concurrency?
16:37:23 <TheKing444> how do I tell cabal to install it for ghc7.8.3
16:38:11 <EvanR> its interesting to me that the principle is concerned with 'behavior' of types
16:38:12 <dcoutts> TheKing444: if it's the default ghc on your $PATH then it'll do it by default, otherwise you can use the -w flag to tell it the name of the ghc you want it to use
16:38:37 <dcoutts> TheKing444: e.g. the 'ghc' on my path is an older version, but I also have 'ghc-7.8.3' on my path
16:38:55 <dcoutts> TheKing444: so I can select that using cabal install -w ghc-7.8.3
16:38:56 <TheKing444> cabal: The program ghc version >=6.4 is required but the version of ghc-7.8.3
16:38:56 <TheKing444> could not be determined.
16:39:25 <dcoutts> TheKing444: sounds like it's borked, see what you get when you run ghc --version yourself
16:39:29 <EvanR> it has an imperative notion attached, it seems to me
16:39:40 <EvanR> the type does something
16:39:43 <EvanR> to somethings
16:39:51 <TheKing444> $ ./ghc-7.8.3 --version
16:39:52 <TheKing444> The Glorious Glasgow Haskell Compilation System, version 7.8.3
16:40:23 <dcoutts> TheKing444: is that on your path? that's a local exe
16:40:37 <TheKing444> its a local exe for now
16:40:48 <dcoutts> then you should use -w ./ghc-7.8.3
16:40:55 <roboguy_> EvanR: hmm, I wonder if there'd be some way to generalize that
16:41:04 <TheKing444> okay
16:41:16 <TheKing444> hurray!
16:41:45 <TheKing444> And I got an error.
16:41:49 <levi> EvanR: Well, objects are sort of the dual construction to ADTs. You don't know anything about the data representation, but you do have a dictionary of functions that know how to operate on that data.
16:42:18 <EvanR> you can look at it that way
16:42:36 <pyon> Hodapp: Say you have a abstract class Foo that has some implemented methods n (not all methods are abstract). These implemented methods must preserve certain invariants in a concurrent context. The inheritance anomaly is the observed phenomenon that, when you declare a class Bar that inherits from Foo, then Bar ends up having to reimplement the logic by which Foo preserves those invariants.
16:42:46 <pyon> those concurrent* invariants
16:42:46 <EvanR> but in real life objects end up being mutable or doing some IO when you activate their interfaces
16:43:00 <EvanR> to me seems like it throws the whole analysis under the bus
16:43:38 <levi> The same could be said of any impure language.
16:44:10 <roboguy_> I wonder if you could say something about subtypes preserving some specific categorical structure
16:44:16 <EvanR> in scala or whatever that supports all this, im always wondering what they mean by "type"
16:44:25 <pyon> EvanR: I do not see why objects need to be intrinsically mutable, not even in practice. Say you have a File object. It is conceivable that writing to this File "consumes" this File and returns a new File object.
16:44:32 <EvanR> is a type a set of values
16:44:43 <EvanR> and operation for this type are functions on this domain
16:44:46 <TheKing444> theking@ChrisLaptopUbuntu1304:/opt/ghc/7.8.3/bin$ cabal install -w ./ghc text-1.1.1.3
16:44:46 <TheKing444> Resolving dependencies...
16:44:46 <TheKing444> Configuring text-1.1.1.3...
16:44:47 <TheKing444> cabal: At least the following dependencies are missing:
16:44:47 <TheKing444> array ==0.5.0.0,
16:44:47 <TheKing444> base ==4.7.0.1,
16:44:47 <TheKing444> bytestring ==0.10.4.0,
16:44:48 <TheKing444> deepseq ==1.3.0.2,
16:44:48 <TheKing444> ghc-prim ==0.3.1.0,
16:44:49 <TheKing444> integer-gmp ==0.5.1.0
16:44:49 <TheKing444> Failed to install text-1.1.1.3
16:44:50 <TheKing444> cabal: Error: some packages failed to install:
16:44:50 <TheKing444> text-1.1.1.3 failed during the configure step. The exception was:
16:44:51 <TheKing444> ExitFailure 1
16:44:54 <EvanR> i doubt it
16:44:57 <glguy> bad TheKing444
16:45:05 <companion_cube> ocaml has structural subtyping and functional objects
16:45:06 <roboguy_> TheKing444: you should use a paste site
16:45:19 <EvanR> pyon: not in real life
16:45:19 <companion_cube> so you can do objects with a nice type system and without side effects
16:45:21 <levi> TheKing444: See the topic for a pastebin to put error messages and the linke in.
16:45:28 <levi> s/linke/like
16:45:36 <Hodapp> pyon: "observed" phenomenon?
16:45:48 <Hodapp> pyon: so in some sense it's not really known why it is?
16:45:57 <dcoutts> TheKing444: oh, you may need to tell cabal where to find ghc-pkg
16:45:58 <zereraz> hello everyone, I am new to haskell and have a small problem with the type system, I am confused with strings and [Char]
16:45:59 <zereraz> http://hastebin.com/jifivikeze.coffee
16:46:00 <roboguy_> linke is fancier because it has silent letters
16:46:07 <TheKing444> how?
16:46:10 <EvanR> companion_cube: i havent looked into ocaml much, but im wondering what the benefit of doing functional programming that way is
16:46:18 <TheKing444> dcoutss how?
16:46:25 <companion_cube> EvanR: you mean with objects?
16:46:26 <TheKing444> *docutts
16:46:29 <EvanR> companion_cube: yeah
16:46:42 <companion_cube> they are only a part of the language, most people don't use them much
16:46:46 <EvanR> heh
16:46:49 <companion_cube> the point is mostly late binding
16:46:51 <zereraz> anyone?
16:46:58 <EvanR> late binding?
16:47:16 <roboguy_> someday someone really needs to write an exposition on the relationship between oop, inheritance and programming in haskell (and haskell-like languages)
16:47:19 <Pythonfant> zereraz: what's confusing you?
16:47:20 * benmachine seconds the "most OCaml people are indifferent to objects" motion
16:47:27 <dcoutts> TheKing444: see cabal configure --help
16:47:29 <zereraz> Pythonfant:  like are they same
16:47:29 <TheKing444> http://lpaste.net/107808
16:47:34 <Pythonfant> zereraz: they are
16:47:43 <Pythonfant> String is defined as type String = [Char]
16:47:46 <zereraz> Pythonfant: then why do I get an error here http://hastebin.com/jifivikeze.coffee
16:47:47 <Pythonfant> that's only an alias
16:47:55 <companion_cube> EvanR: resolution of which code is actually executed during runtime
16:48:08 <zereraz> I typecasted because I got error
16:48:24 <EvanR> companion_cube: so... dispatch
16:48:25 <companion_cube> the other interest is providing several implementations of a single interface
16:48:32 <companion_cube> yeah, dynamic dispatch
16:48:32 <dcoutts> TheKing444: you apparently already have (a probably broken) 7.8.3 on your path, and if it ends up getting the ghc-pkg from that one then it'll be inconsistent
16:48:40 <benmachine> zereraz: your main problem is you are trying to use checkInStr in between its arguments
16:48:44 <benmachine> instead of before them
16:48:52 <benmachine> you can do that but you need to use special syntax to do so
16:49:03 <zereraz> oh
16:49:08 <zereraz> I just need a `
16:49:12 <roboguy_> zereraz: haskell doesn't have type casting
16:49:15 <benmachine> well, you need one on both ends
16:49:23 <roboguy_> (not really, anyway. and definitely not like that)
16:49:25 <orion> Does there exist any profilers for Haskell code to help determine when strictness can help your program use less memory (among other things)?
16:49:28 <zereraz> roboguy_: then what do we do when we do ::type
16:49:35 <benmachine> but even that won't solve your problem, you'll need to add print or something to actually do something with the Bool
16:49:38 <roboguy_> zereraz: that's when you need to make a type more specific
16:49:40 <TheKing444> dcoutts Got the same error with --witch-hc-pkg ./ghc-pkg
16:49:55 <roboguy_> zereraz: it doesn't cast anything, it's usually to turn a general type into a more specific oen
16:49:56 <roboguy_> *one
16:50:04 <levi> orion: GHC has profilers built into it!
16:50:12 <zereraz> roboguy_: so its just used to be specific
16:50:23 <roboguy_> zereraz: pretty much, yeah
16:50:23 <zereraz> 1 more doubt
16:50:28 <levi> orion: Both for checking memory use as well as execution time.
16:50:37 <TheKing444> *with
16:50:38 <zereraz> how do I remove characters from string
16:50:43 <roboguy_> zereraz: also, you should *always* give type signatures for top-level definitions. it makes errors *way* easier to read
16:50:45 <benmachine> zereraz: which ones?
16:50:57 <roboguy_> zereraz: (including main)
16:50:57 <luite> orion: GHC has heap profiling, you can use it if you install your program with --enable-executable-profiling and have installed all dependencies with --enable-library-profiling
16:51:01 <dcoutts> TheKing444: ok, not sure then, -v3 output might enlighten us
16:51:29 <dcoutts> TheKing444: but it's some kind of inconsistency between what cabal-install sees and what the Setup.hs configure is seeing
16:51:31 <benmachine> zereraz: you can remove the first few characters, or all but the first few characters, or the characters matching or not matching some choosing function
16:51:37 <TheKing444> cabal --version
16:51:37 <TheKing444> cabal-install version 1.16.0.2
16:51:37 <TheKing444> using version 1.16.0 of the Cabal library
16:51:43 <TheKing444> how should I install ghc-7.8.3
16:51:44 <TheKing444> ?
16:51:47 <benmachine> zereraz: or remove characters by index, or...
16:51:47 <zereraz> benmachine: I want to remove those matching
16:51:56 <benmachine> zereraz: ok, you want to look at filter
16:51:58 <benmachine> :t filter
16:51:59 <lambdabot> (a -> Bool) -> [a] -> [a]
16:52:07 <dcoutts> TheKing444: note that that's too old to use with 7.8.3
16:52:07 <orion> levi: You're saying that GHC will make things strict where possible/helpful without any intervention on my part?
16:52:07 <luite> orion: it also gives you stack traces for exceptions, since they use the same instrumentation (GHCJS will get heap profiling soon, stack traces already work)
16:52:16 <TheKing444> oh
16:52:26 <TheKing444> is there an update to date haskell platform or something?
16:52:42 <roboguy_> TheKing444: you can use cabal to update cabal
16:52:44 <dcoutts> TheKing444: it'll be out soonish, once everything is stable
16:52:54 <benmachine> for example, "filter (\c -> c /= 'a') str" removes all 'a' characters from str
16:52:58 <zereraz> benmachine: so I do filter and my function
16:53:04 <TheKing444> okay
16:53:04 <levi> orion: Well, it will do *some* of that when you turn optimization on. But mostly I meant there's a profiler that will help you find what needs to be strict to reduce memory usage.
16:53:05 <roboguy_> TheKing444: cabal install cabal-install
16:53:11 <luite> orion: GHC already does some of that automatically when optimizing, but there's no automatic thing to generat strictness hints for the user
16:53:13 <TheKing444> I did that.
16:53:14 <dcoutts> TheKing444: if you don't really need 7.8.x then it's easier to stick to the stable platform
16:53:21 <benmachine> zereraz: maybe. depends what you mean by "matching"
16:53:30 <zereraz> benmachine: /= is not equals right
16:53:34 <benmachine> zereraz: right
16:53:35 <dcoutts> TheKing444: as roboguy_ says, you can install a new cabal-install using your existing ghc
16:53:38 <khanage> hey all, i have a question about cabal. I'm trying to use test-suite + test-framework, and i've bundled everything up in an executable. It seems I now need to create a library that the test-suite can reference. My question is, do I simply move everything into the library and leave my "Main.hs" as the only inhabitant of the exe? What approach does #haskell take?
16:53:42 <roboguy_> TheKing444: it didn't work?
16:53:43 <benmachine> zereraz: the function in filter says which elements to keep
16:53:59 <roboguy_> TheKing444: did you run cabal update first?
16:54:10 <dcoutts> khanage: you don't have to move it into the lib
16:54:12 <zereraz> benmachine: I am sorry but can you explain again
16:54:26 <zereraz> benmachine: I understood the concept of filter
16:54:30 <levi> orion: If you haven't looked through it yet, the GHC User's Guide has a lot of information about compiler options, including how to enable profiling and read the output.
16:54:38 <khanage> dcoutts: just expose the appropriate modules?
16:54:54 <khanage> dcoutts: or have i missed something?
16:55:12 <benmachine> zereraz: you said you wanted to remove matching elements, what does matching mean?
16:55:16 <dcoutts> khanage: you've got two choices: have your test suite depend on the library in your package (in which case it can only use the public interfaces) or it can use the source modules directly (in which case it can access all the modules)
16:55:23 <orion> levi: thank you
16:55:35 <zereraz> benmachine: ok I got that, now I want to keep at certain index
16:55:49 <zereraz> benmachine: like not remove from all
16:55:52 <khanage> dcoutts: ahh, so just add src to hs-source-dirs
16:56:00 <dcoutts> khanage: right
16:56:01 <zereraz> benmachine: I could use take
16:56:05 <khanage> dcoutts: right, that makes sense in this case, cheers!
16:56:12 <benmachine> zereraz: I don't understand, could you give an example?
16:56:27 <zereraz> benmachine: I don't want to remove the first 'a'
16:56:36 <zereraz> benmachine: but I want to remove the rest of a's
16:56:38 <benmachine> zereraz: ah, hmm
16:56:53 <zereraz> benmachine: I need to give index what not to remove and then remove the rest
16:57:07 <zereraz> benmachine: I could use take to give  a certain portion of str
16:57:21 <benmachine> zereraz: are you aware of span/break?
16:57:29 <zereraz> benmachine: I will look into them
16:57:36 <zereraz> was not aware
16:57:52 <zereraz> benmachine: will they solve my problem?
16:57:58 <rasfar> zereraz: is this an exercise or are you trying to write a parser?
16:57:59 <benmachine> they might help
16:58:12 <zereraz> rasfar: its a question
16:58:16 <Sornaensis> benmachine: now ghc is telling me that this module belongs to a different package even though I am specifying another package with the same module name > _<
16:58:21 <rasfar> like, a homework question?
16:58:22 <zereraz> rasfar: I have decided to learn haskell by solving questions
16:58:26 <rasfar> oh i see
16:58:29 <zereraz> rasfar: no
16:58:41 <rasfar> do you have a list of indices not to remove?
16:58:50 <benmachine> Sornaensis: I dunno, sorry
16:58:58 <zereraz> the real question is to remove the duplicates of a character
16:59:05 <zereraz> like aabc should be abc
16:59:12 <zereraz> aabbcc should be abc
16:59:15 <rasfar> the duplicates don't have to be contiguous?
16:59:22 <Sornaensis> how does anyone do TLS with haskell if these two packages are in conflict?
16:59:24 <zereraz> I don't think so
16:59:25 <Sornaensis> I don't understand...
16:59:26 <zereraz> no
16:59:43 <zereraz> I am a beginner and have spend hours on this silly problem
16:59:48 <rasfar> it's a bit tricky
16:59:51 <EvanR> > nub "aabbcc"
16:59:53 <lambdabot>  "abc"
16:59:54 <benmachine> Sornaensis: yeah, it surprises me too, maybe look at some example code, maybe most people only use one or the other
16:59:54 <EvanR> hehe
16:59:57 <rasfar> i would almost use a sort on pairs
17:00:03 <zereraz> at first I did not understand how to take inputs
17:00:06 <benmachine> zereraz: I think I would recommend a recursive solution
17:00:24 <rasfar> (pairs so can get back the original order once you compact the sorted)
17:00:34 <zereraz> benmachine: won't recursive be tough
17:00:40 <zereraz> I was thinking
17:00:46 <benmachine> zereraz: nah, recursion isn't too hard
17:00:55 <EvanR> the problem is not defined enough right
17:00:56 <zereraz> send the string and a character
17:01:01 <monochrom> recursion is no tougher than programming
17:01:06 <roboguy_> I think of recursive calls as "using the function as though it already works", if that makes sense
17:01:06 <zereraz> then check if its in it using elem
17:01:07 <EvanR> "remove all but one of each kind of character"
17:01:09 <EvanR> which one
17:01:26 <benmachine> EvanR: the first one
17:01:28 <EvanR> ok
17:01:37 <roboguy_> if you have a recursive call that uses a the function as though it already works, it usually does work
17:01:38 <benmachine> or whatever
17:01:44 <benmachine> let's not get stuck on details at this stage
17:01:46 <EvanR> "remove whatever" ;0
17:02:05 <rasfar> map fst $ sortBy snd $ nub $ sortBy fst $ zip string [1,2..]  -- something like this
17:02:12 <zereraz> so I could use filter and remove if the character is in the string
17:02:14 <EvanR> you might as well say it doesnt matter what order the result ends up in then
17:02:32 <monochrom> I think it's instructive to study how nub does it
17:02:45 <zereraz> so is my approach fine?
17:02:46 <benmachine> zereraz: I think it's important to be able to write recursive functions if you need to
17:02:49 <roboguy_> rasfar: it looks more like the question is how to implement something like nub
17:02:50 <rasfar> @src nub
17:02:50 <lambdabot> nub = nubBy (==)
17:02:56 <zereraz> benmachine: I will practice
17:03:01 <rasfar> @src nubBy
17:03:02 <lambdabot> nubBy eq []             =  []
17:03:02 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:03:14 <zereraz> what does nub do
17:03:20 <solidus-river> luite: awesome info :) i'll have to experiment, if thats the case then the only thing that i don't like ghcjs for as much as haste is interop with javascript, I havent done a lot of readin gon it yet but haste seems to make it easier to expose parts of your program as a library for native js to call or give input to as well as it seems easier to call out to other js libraries
17:03:21 <rasfar> oh so i'm nub-nubbing in the above, whoops!
17:03:22 <EvanR> > nub "aabbcc"
17:03:22 <Exio> removes duplicated
17:03:23 <lambdabot>  "abc"
17:03:24 <roboguy_> zereraz: it removes all duplicates from a list
17:03:29 <benmachine> zereraz: basically nub does what you are trying to do
17:03:34 <zereraz> what
17:03:38 <zereraz> lol
17:03:41 <zereraz> I spent hours
17:03:41 <rasfar> > nub "abcabc"
17:03:42 <benmachine> > nub "aaabbcc"
17:03:43 <lambdabot>  can't find file: L.hs
17:03:43 <lambdabot>  "abc"
17:03:51 <solidus-river> but i could also be very wrong on that
17:03:53 <rasfar> > nub "abcabc"
17:03:54 <lambdabot>  "abc"
17:03:59 <benmachine> zereraz: re-implementing functions taht already exist is a great way to learn
17:04:00 <solidus-river> the info comparing them isn't very large
17:04:02 <zereraz> then what is the point of the question
17:04:03 <roboguy_> zereraz: it's good to try to figure it out yourself though
17:04:18 <roboguy_> zereraz: well, by that argument, what's the point of basically anything?
17:04:18 <benmachine> zereraz: it's much easier to understand how things work if you know how to do them yourself
17:04:18 <zereraz> yeah I did learn allot of haskell (basic stuff)
17:04:28 <zereraz> Agreed!
17:04:30 <solidus-river> and i think haste / fay's method isn't as type safe for foreign calls
17:04:34 <EvanR> if the question is "write a compiler" the answer isnt to give gcc
17:04:37 <roboguy_> zereraz: it is very important to know how to make a function like nub
17:04:38 <zereraz> Thanks allot everyone
17:04:54 <Exio> i normally end implementing the functions by myself for _actually_ understanding them
17:04:56 <zereraz> roboguy_: yeah I agree
17:05:01 <zereraz> thanks again
17:05:30 <Exio> (implementing and obviously, using the library version)
17:11:47 <zereraz> Couldn't match expected type `IO b0' with actual type `Bool'
17:11:47 <zereraz>     In the return type of a call of `checkInStr'
17:11:48 <zereraz>     In a stmt of a 'do' block: checkInStr 'a' str
17:11:48 <zereraz>     In the expression:
17:11:50 <zereraz>       do { str <- getLine;
17:11:52 <zereraz>            checkInStr 'a' str }
17:11:54 <zereraz> my program is not working,
17:11:57 <zereraz> http://hastebin.com/ebesagawal.coffee
17:11:59 <luite> solidus-river: yeah haste has a convenient ffi "function" which is not really possible to implement in a way that is safe enough to my liking, unless you restrict the argument to string literals (so you add new syntax to the language, this is wat fay does) or you evaluate the pattern at compile time using template haskell. so i'm not too keen on directly copying the approach, but a TH-based one with good static guarantees would be a reasonable option, it'd look mo
17:12:18 <roboguy_> zereraz: what do you want it to do?
17:12:34 <zereraz> oh
17:12:47 <zereraz> If i did print
17:12:52 <roboguy_> yeah, that would work
17:13:03 <zereraz> its the thing about actions right
17:13:09 <mwhit> yep
17:13:13 <zereraz> thanks
17:13:20 <mwhit> but you can't do anything with the value afterward that way
17:13:21 <roboguy_> yeah. checkInString doesn't give you an IO action
17:13:28 <mwhit> to do that, you need to "wrap" it into an IO action using return
17:13:38 <zereraz> how do I do that
17:13:41 <roboguy_> or a function like print
17:13:42 <zereraz> I tried return
17:13:50 <roboguy_> you probably just want to use print
17:13:59 <zereraz> print does not work
17:13:59 <mwhit> ^^^
17:14:07 <mwhit> what is the type signature of your function?
17:14:08 <roboguy_> zereraz: what is the line of code?
17:14:29 <zereraz> 1 sec
17:14:32 <zereraz> I made a mistake
17:14:51 <solidus-river> luite: whats the current route to calling js from a ghcjs program or calling into a ghcjs program from js
17:15:06 <zereraz> it Worked!!
17:15:13 <zereraz> yay first haskell program
17:15:15 <zereraz> !!!
17:15:21 <zereraz> that does something
17:15:22 <roboguy_> congratulations!
17:15:28 <zereraz> I love haskell!
17:15:31 <mwhit> haha
17:15:34 <mwhit> glad to hear it
17:15:43 <zereraz> thanks allot!!
17:16:00 <mwhit> zereraz: are you working from a book or class or anything?
17:16:04 <mwhit> or just playing around
17:16:49 <solidus-river> zereraz: congrats!
17:17:02 * solidus-river makes a celebratory shot of espresso
17:17:04 <zereraz> mwhit: no class, learning from anywhere
17:17:12 <zereraz> mwhit: reading here and there
17:17:35 <zereraz> mwhit: watch any youtube video I can find on haskell
17:17:39 <zereraz> watching*
17:17:41 <luite> solidus-river: exposing haskell code as a library to js is indeed missing. you can do it currently, but it requires the somewhat awkward to use syncCallback/asyncCallback to create a callback that you can pass to JS, or doing everything manually, using h$run, h$runSync, h$ap from the RTS, requiring too much knowledge of internals to be generally useful
17:18:17 <roboguy_> zereraz: using a bunch of sources worked well for me. that's how I learned about a lot of stuff (including haskell programming)
17:18:19 <mwhit> zereraz: Nice. If you're interested, probably the best first 2 resources are http://learnyouahaskell.com/ (free ebook) and then after that http://www.seas.upenn.edu/~cis194/lectures.html (UPenn intro haskell course)
17:18:49 <zereraz> mwhit: I found these a few days back :D
17:18:54 <mwhit> cool
17:19:08 <zereraz> but I am not just playing around, I mean I have a goal
17:19:15 <zereraz> I want to learn functional programming
17:19:32 <zereraz> I am not a good programmer
17:19:34 <mwhit> haha well sure, that's why we're all here
17:20:03 <zereraz> also I think this learning by solving is a more solid approach
17:20:14 <mwhit> probably true
17:20:17 <zereraz> I read and watched haskell videos
17:20:28 <mwhit> there's also #haskell-beginners, btw
17:20:42 <zereraz> mwhit: I should be there , Thanks!
17:20:54 <zereraz> 1 question
17:21:07 <zereraz> is haskell good for AI and machine learning
17:21:28 <zereraz> Like if I first learn haskell and then learn machine learning using haskell
17:21:52 <zereraz> I read online about how parallelism of functional programs are needed for AI
17:22:11 <luite> solidus-river: the main problem is that i don't really know how to let the user export things to JS in a way that's convenient enough and safe. there are some restrictions in types of functions that can be exported (polymorphic functions with constraints require that the correct dictionary is passed in, or need a wrapper that only accepts one or a few known types)
17:22:44 <platz> the constraint on good machine learning isn't the language, it's quality libraries written by researchers/stats people.  So far haskell is behind other languages like python and R in this regard.
17:23:03 <mwhit> ^^^ this
17:23:05 <platz> even Java has a suprising number of machine learning libs
17:23:20 <mwhit> numerical haskell in general is a very active area right now, but it's still immature
17:23:30 <luite> solidus-river: someone else askd the same thing a few weeks ago, and the current plan is in the last reply of this: https://github.com/ghcjs/ghcjs/issues/194
17:23:31 <mwhit> i'm working on a neural network library on the side, but it's nothing like usable yet
17:23:34 <zereraz> what is the reason for lack of libraries
17:23:43 <zereraz> less people?
17:23:48 <mwhit> zereraz: pretty much
17:23:50 <athan> zereraz: I think the learning curve of haskell
17:24:08 <mwhit> zereraz: haskell is a very old language, but you have to keep in mind that until pretty recently it was almost entirely used by language researchers
17:24:11 <zereraz> athan: its not that easy yeah
17:24:28 <zereraz> mwhit: yeah it predates java and pythoon
17:24:37 <zereraz> python*
17:25:04 <athan> zereraz: I know there has been stat work by the financial people, you could probably staple something up
17:25:12 <zereraz> athan: nice
17:25:14 <roboguy_> mwhit: it's interesting when people talk about haskell being a new language. I mean, relative to some it is, but generally...
17:25:32 <pharaun> and haskell isn't all that old compared to some other more commonly used languages
17:25:45 <pharaun> (c?, fortran?, lisp?)
17:26:05 <EvanR> the average age of a lisp-y implementation
17:26:10 <roboguy_> pharaun: do fortran and lisp still count as commonly used?
17:26:10 <platz> when were typeclasses added
17:26:11 <EvanR> four days ;)
17:26:26 <pharaun> roboguy_: number crunching, and in science/etc yes
17:26:27 <roboguy_> (not to say lisp is irrelevant, but I'm not sure it's used that much these days)
17:26:37 <pharaun> and lisp - emacs and "clojure" i guess
17:26:39 <mwhit> sure, but compared to other languages used a lot in machine learning (older than python, around the same age as r)
17:26:46 <roboguy_> pharaun: oh, good point
17:26:57 <mwhit> fortran is definitely still used in scientific computing
17:27:05 <platz> Haskell is old, but thinking of it before there were even monads and just Request/Response it seems like almost another language
17:27:11 <zereraz> so 1 last thing before I go back to coding, I am reading articles/references/official material little bits of books and videos. I am going to start solving small problems too so any thing important that I should do that people who learn haskell do?
17:27:13 <mwhit> i've written electronic structure code in fortran
17:27:16 <pharaun> for ex some of the science libraries are still in fortran (blas iirc) etc
17:27:22 <roboguy_> I've never used fortran actually. I've used a pretty good variety of languages too...
17:27:48 <solidus-river> luite: thanks for the link to the github issue, i'lld efinnitley follow it, i'm planning on trying ot export what i'm currently working on to javascript by way of haste and or ghcjs and see what they end up looking like :)
17:28:50 <rasfar> Scheme is still taught in preference to Haskell in some schools. So thousands are being introduced to Scheme/lisp every year, but I don't know if that counts as use.
17:28:53 <pharaun> also there's probably not much "greenfield" cobol apps being developed but there's still very large installation of cobol codes floating around as well
17:29:11 <doomlord_1> is haskell moving at all r..e records (when i last tried haskell, i ran into the business about not being able to share struct field names which throws me a little, as silly as it sounds)
17:29:17 <mwhit> zereraz: Remember one other important thing: There's lots and lots of very esoteric theoretical stuff you're going to run into when learning haskell. Keep in mind that for the most part, this stuff is *optional* and there's no reason to be intimidated by it
17:29:17 <roboguy_> rasfar: yeah, I used racket last semester. they teach a haskell version of that course at my school too
17:29:35 <roboguy_> I would have preferred that, but the racket one is the one they offered that semester
17:29:39 <mwhit> doomlord_1: I seem to remember hearing that particular issue is being solved somehow in 7.10
17:29:40 <platz> Dr. Racket is a halfway decent editor
17:29:52 <platz> liked the error lines that point to the error
17:29:55 <doomlord_1> wow -really?
17:30:04 <pharaun> mwhit: oh they are finally making aa move on records issue?
17:30:05 <zereraz> mwhit: ok I won't be intimated. basically category theory right?
17:30:09 <roboguy_> platz: it can be kinda laggy, but other than that it's pretty good
17:30:11 <mwhit> zereraz: that's the big one, yeah
17:30:14 <bergey> https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
17:30:14 <Iceland_jack> doomlord_1:
17:30:15 <Iceland_jack> @google overloaded record syntax
17:30:15 <lambdabot> http://www.well-typed.com/blog/84/
17:30:15 <lambdabot> Title: Well-Typed - The Haskell Consultants: Overloaded record fields for GHC
17:30:18 <rasfar> i see. choice is nice. i tried to suggest haskell would be more suitable, but it was indicated distinctly that it was impossible...
17:30:56 <pharaun> :O
17:31:05 <zereraz> ok thanks again everyone bye
17:31:12 <roboguy_> zereraz: yeah, you don't need to know about category theory. Even if you use the stuff that was inspired by category theory (like the Functor, Applicative and Monad classes), you still don't need to know it (but it is cool)
17:31:12 <pharaun> now i want to tell 7.10 to hurry up and be here :p
17:31:27 <levi> roboguy_: Racket's a pretty cool language, so I wouldn't feel too bad about it. :)
17:31:38 <EvanR> doomlord_1: you essentially want to put different records in their own module so you can use the field name functions equalified
17:31:45 <Exio> just fwiw, a nice "programming-language" course focusing in functional programming, https://www.coursera.org/course/proglang
17:31:49 <zereraz> robbert: I won't now, but I am interested :D
17:31:50 <roboguy_> levi: oh definitely. as dynamically typed languages go, it's cool
17:32:08 <zereraz> roboguy_: : I won't now, but I am interested :D
17:32:10 <doomlord_1> EvanR, i realise you could work around it , but tht
17:32:23 <roboguy_> levi: a lot of the other students were dragging their feet with it, but I don't think they realized the advantages over the stuff their familiar with
17:32:26 <Exio> i took it, it was amazing, would recommend :P
17:32:26 <doomlord_1> but that always felt un-natural to me (coming from C family)
17:32:42 <levi> roboguy_: It's got Typed Racket in there as well, as well as a lazy-by-default version.
17:32:44 <platz> proglang was an awesome course
17:33:03 <roboguy_> levi: I've never used typed racket, but I've always thought that was an interesting idea
17:33:17 <Exio> platz, nice to know someone here took it too! :P
17:33:32 <levi> roboguy_: They've also got a nice language for writing documentation (Scribble) and one for working on operational semantics of programming languages (Redex).
17:33:44 <roboguy_> it's always so tempting to give a lecture to the other students on the advantages of different kinds of programming techniques haha
17:33:50 <roboguy_> (and langauges)
17:33:52 <roboguy_> *languages
17:33:54 <luite> solidus-river: suggestions are definitely welcome there. i mostly see ghcjs from a compiler developer point of view and that makes it sometimes harder to see what's useful for users (and is also one of the reasons i ignored exporting things to js for too long, since i know how the RTS works i could always construct the haskell heap object manually and run it if needed)
17:33:55 <EvanR> doomlord_1: right, in C the field name is used in a context where the compiler can know which struct type you mean
17:33:55 <platz> Exio: too bad it only had one session... I want to reccomend it to folks but can't
17:34:01 <pharaun> i've been tempted into trying out racket
17:34:12 <roboguy_> levi: I'm not familiar with Redex, but Scribble's nice
17:34:28 <EvanR> doomlord_1: on the other hand, C has no qualified imports so you have to put namespace_ on the front of everything anyway
17:34:33 <levi> Yeah, I always find it a shame when people don't look for the advantages in other languages because of familiarity with something else.
17:34:37 <roboguy_> pharaun: it's a nice scheme implementation
17:35:18 <doomlord_1> EvanR i'm a C++ user mostly, i just sumarise saying my view of PL's is biased by the C family
17:35:43 <roboguy_> doomlord_1: I used to be like that (years of C++ experience), but now I'm more biased towards haskell
17:35:52 <solidus-river> luite: well i'm not sure how helpfull this input will be because I don't really know much about compilers. But the main exciting thing to me about ghcjs is I work at a company thats starting to seriously look into larger webgl based programs
17:36:17 <solidus-river> and when tasked with creating a whole engine or renderer in js you don't want to, but the idea of making one in haskell and exporting it as a lib that our front-end devs could use is really awesome
17:36:19 <doomlord_1> basic->asm->C->C++ -> (tried some other things)->(dabbling with Rust)
17:36:49 <levi> roboguy_: I'm not sure if you've seen PL papers with the sequent-style inference rules for type systems and evaluation rules for semantics, but the Redex language basically allows you to draft that stuff and directly execute it, then dump LaTeX for it when you've debugged it.
17:36:55 <pharaun> roboguy_: yeah i've been working on my own tiny scheme interpreter, and i've been wanting ot try out racket to incorporate its ideas into mine
17:36:58 <zomg> solidus-river: I wonder if ghcjs can achieve the necessary levels of optimization you'd need for any non-trivial webgl stuff..
17:37:01 <glguy> doomlord_1: Someone's working on an extension for overloading record fields. Generally it isn't a major issue. One thing people do now is to create a typeclass to share a named "lens" which they implement an instance for each type that has that logical field
17:37:15 <solidus-river> and so far the only haskell -> js compilers that come close to that are ghcjs and haste, ghcjs looks like its a much better implimentation / mapping from haskell to js
17:37:15 <EvanR> doomlord_1: in haskell, the same thing arises when you want to use a particular function called map or filter or elem, each module may have its own version of this and its a good thing they dont have to call it array_map, tree_map etc to be unique with every other library on the planet
17:37:26 <solidus-river> zomg: me too, i'm writing a test program using netwire to try it out
17:37:34 <roboguy_> levi: ah, cool. actually, I just started HoTT so I'm seeing some of that kind of thing
17:37:51 <roboguy_> pharaun: nice. scheme interpreters are fun. I'm working on and off on a Forth compiler
17:38:04 <orion> http://www.haskellhott.com/ <-- funeral home
17:38:10 <solidus-river> zomg: end goal is rendering animated unreal models in webgl using a lib built in haskell
17:38:13 <pharaun> roboguy_: nice, its one heck of a way to learn a language :)
17:38:14 <doomlord_1> after using rust  ..... haskell typeclasses will probably feel a bit less alien
17:38:19 <pharaun> never used lispy languages before
17:38:20 <zomg> solidus-river: prob depends on the type of apps you'd write... games might not be doable because of the performance implications, but something that's less performance critical might be entirely feasible
17:38:21 <roboguy_> forth feels kinda like the opposite of lisp, in some sense
17:38:31 <solidus-river> er, unreal 3
17:38:34 <roboguy_> pharaun: oh, definitely
17:38:39 <pharaun> and then i was like hrm wait, this sounds like the prefect usecase for scheme and went on and started implementing one haha
17:38:44 <platz> <- fear of concatenative languages
17:39:08 <Exio> platz, an awesome course, but yeah, that is sad
17:39:26 <levi> Factor is a fun language, if you want something a bit higher-level than Forth.
17:39:36 <redtricycle> I canuse :t in GHCI, how do I print the type to screen not in GHCI?
17:39:40 <redtricycle> :t variablename
17:39:40 <lambdabot> Not in scope: ‘variablename’
17:39:45 <redtricycle> print $ :t $ var?
17:39:51 <roboguy_> platz: I don't have much forth experience, but it's an interesting change in the thought process to try and make a compiler (and write forth code in it). I've noticed it helps to write a lot of comments about what happens to the stack in a given line of code
17:40:19 <platz> roboguy_: I assume you've seen this http://www.greenarraychips.com/
17:40:20 <mwhit> redtricycle: types are not known at runtime
17:40:21 <luite> solidus-river: performance will be an issue then, and probably require some attention because js engines don't deal with high allocation rates as well as the GHC runtime (this is the same in all pure languages, not only haskell)
17:40:21 <roboguy_> I pretty much *have* to do that to debug something
17:40:26 <pharaun> gonna have try out forth one of these days
17:40:29 <pharaun> i keep on hearing about it
17:40:42 <redtricycle> So I can't do...import Prelude
17:40:43 <redtricycle> and use :t
17:40:57 <roboguy_> platz: I've glanced at it, but I haven't looked too much into it yet. it looks like it could be cool though
17:41:02 <mwhit> anything in ghci that starts with a : is not haskell code
17:41:03 <platz> roboguy_: I can see the value in that.  Part of the reason I was interested in haskell was for it's mind-bending abilities
17:41:36 <glguy> If you want a nice environment to learn about concatenative languages, I recommend Factor
17:41:36 <platz> it had a bit of buzz yeah
17:41:37 <zomg> luite, solidus-river, if he only wants to render the models and perhaps do some minor fx with glsl or such, I think it's not going to be a huge deal since it just has to tell webgl to render a thing, which in small doses is pretty fast
17:42:03 <roboguy_> platz: I probably wouldn't write something big in forth mind you, but a change in thinking is always fun. also, I could see writing some code that *needs* to be close to the hardware in it (like embedded system stuff)
17:42:31 <luite> solidus-river: we did make sure that unboxed values, unboxed tuples and unboxed arrays never allocate any memory, so if you use for example a mutable array and the GHC optimizer can unbox most things, it should run pretty fast
17:42:32 <roboguy_> I've actually never used Factor. I should probably give it a shot, considering my compiler project
17:42:36 <platz> agree with the changes in thinking
17:42:44 <ruuns> hey roboguy :) are you involved in robotics?
17:42:49 <levi> On the subject of bare-metal Forth, I recently came across a Forth ported to run on the bare-metal Raspberry Pi.
17:42:58 <luite> solidus-river: but if you have lots of garbage then it will be the main slowdown
17:43:02 <roboguy_> ruuns: I'm not really /involved/, but I'm interested in it!
17:43:25 <solidus-river> luite: thats good info, if i'm interpreting that right it equates to me wanting to force strict evaluation of my types whenever possible
17:43:26 <roboguy_> levi: that's actually exactly what I've been thinking of doing!
17:43:28 <Exio> i found coding an interpreter and implementing core-libraries with it a nice way to learn haskell, like "write yourself a toy language in 48 hours" :P
17:43:34 <ruuns> ah, i only asked because i have worked for 2,5 years in a robotic institute :3
17:43:42 <roboguy_> ruuns: wow, that sounds cool!
17:44:14 <ruuns> mainly involved with robotic frameworks used in space and auvs (autonomous underwater vehicles) :3
17:44:15 <roboguy_> I was really into robots as a kid and I never stopped wanting to get into it
17:44:18 <solidus-river> luite: there shouldn't be, or i'm trying to stop there from being, i'm not too sure what something like netwire gets compiled down into in core, ie is it smart enough to reuse a single chunk of memory for all iterations of a wire or does it allocate a new chunk each run
17:44:25 <roboguy_> ruuns: nice!
17:45:05 <luite> solidus-river: for the inner loop, creating lots of thunks could indeed become problematic. if the inner loop is some ST or IO action that manipulates an unboxed array (like STUArray, vector or repa) it could be fine
17:45:18 <pharaun> heh same as roboguy_
17:45:25 <pharaun> always wanted to get into robotics, never did
17:45:37 <roboguy_> that's actually what lead me to computer programming
17:45:42 <platz> electronics is a bit unforgiving
17:45:45 <gfixler> same as pharaun and roboguy_, but I've toyed a bit
17:45:47 <ruuns> i can truly say:  wrting soft-realtime, correct code with high productiviy is an awful nightmare :-D
17:45:56 <gfixler> I motorized my lamp to move around based on mouse movements
17:45:56 <pharaun> been meaning to try to pick up an arudino or rpi
17:46:02 <pharaun> and get back into electronics again
17:46:18 <pharaun> i have a ton of things i want to build but i just never got back
17:46:19 <platz> the debugger is.. your oscilloscope
17:46:21 <gfixler> and I motorized an etch-a-sketch to draw the things I drew in Flash through a tiny, custom file format
17:46:52 <ruuns> don't want to count the nights in debugging where my code segfaults due to several reasons (hardware, software, bindings between different languages)
17:46:52 <gfixler> I used BASIC Stamps and PIC microchips
17:47:26 <gfixler> platz: I didn't have an oscilloscope, so my debugging was mostly looking around at a pile of electronics and wondering where the problem could be
17:47:57 <ruuns> but it's the best domain to impress people without any knowledge in computer science :3
17:48:03 <platz> This comment is amazing https://news.ycombinator.com/item?id=6657105 "The Moment"
17:48:17 <luite> solidus-river: yeah GHC does not reuse a single chunk (heap object) when some value is repeatedly updated. only when it can be unboxed completely, allocation can be removed by passing the data around as unboxed tuples
17:48:19 <gfixler> when nothing would happen, it could be in my code, in the dev tool, in the wire running to the chip, in the chip, in the circuits, ...
17:48:26 <roboguy_> yeah, I got into programming because, as a 13 year old (or so) at the time, it was easier to get immediate feedback and figure out what's wrong with something compared to making circuits
17:48:53 <roboguy_> I still wonder about circuits though. someday I need to get back into that
17:49:10 <roboguy_> maybe do some BEAM robotics to totally get away from hardcoded, programmed stuff
17:49:11 <platz> almost took an EE course on Edx
17:49:21 <solidus-river> luite: does GHC doe stream fusion on Lits now or does that still need some type dancing
17:49:25 <dagano> i have an 'IntMap [Int]' and i want some operation that combines two (k,[v]) so I have the union of [v1] and [v2] and some arbitrary key (either k1 or k2). can someone give me a recommendation?
17:49:26 <solidus-river> *do
17:49:44 <solidus-river> *do, *lists
17:49:55 <roboguy_> ruuns: sounds challenging
17:49:57 <ruuns> it's very hard to control these different layers (low-level embedded, middle-layer for control loops, high-level for planning and mission design)
17:50:14 <roboguy_> but also kinda like an interesting puzzle
17:51:18 <luite> solidus-river: there is an optimization that allows some allocation to be avoided (let-no-escape, if you want more info, ezyang has written a blog post about it). neither ghcjs nor haste use that info though (i'm not sure if it's useful for haste, but it would definitely avoid an allocation with ghcjs), for ghcjs since that's because in the current optimizer it's really tricky to implment, and with the new optimizer it will be really easy, so it's not worth the ef
17:52:03 <ruuns> ya it is :) it's always a real drama in front of a demonstration because so many things could fail :D that's my reason to look into haskell for writing correct code with a pleasant performance
17:52:51 <luite> solidus-river: yeah there's some list fusion, and also of course fusion for vectors, if GHC can optimize out intermediate results in core, then those allocations are gone
17:52:57 <redtricycle> What's a Haskell way of handling a struct?
17:53:01 <redtricycle> I have a new data entry
17:53:03 <redtricycle> that is...
17:53:11 <roboguy_> redtricycle: a data definition
17:53:14 <ruuns> hope for myself to program someday one of these air drones and writing some mapping/localization algorithm on it. :]
17:53:16 <redtricycle> data Network = Network String String String String
17:53:18 <redtricycle> But it's all Strings
17:53:30 <redtricycle> is there a way to say "this string is for the name" and "this string is for the description"?
17:53:35 <mwhit> two ways
17:53:39 <mwhit> one is a simple type alias
17:53:43 <mwhit> type Name = String
17:53:51 <mwhit> that's purely for readability
17:54:01 <levi> ruuns: http://smaccmpilot.org/
17:54:09 <roboguy_> redtricycle: one option is data Network = Network { networkName :: String, networkDescription :: String, ... }
17:54:23 <redtricycle> ahh...
17:54:30 <redtricycle> And how about when I use this in functions?
17:54:33 <redtricycle> for example
17:54:45 <redtricycle> transaction (Network networkName _ _ _ _) = ...
17:54:48 <roboguy_> redtricycle: it's called record syntax
17:54:53 <redtricycle> Is there a way to not need to include all the excluded variables?
17:54:57 <redtricycle> or a better way of passing the data definition?
17:55:05 <ruuns> levi: great, didn't know that project :]
17:55:06 <roboguy_> redtricycle: it defines functions networkName :: Network -> String etc
17:55:22 <roboguy_> redtricycle: and also you can do something like someNetworkValue { networkName = someNewName }
17:55:45 <zereraz_> hello people, I am printing a string using print now I want to print it without the double quotes, how to do that?
17:55:54 <roboguy_> redtricycle: it can sometimes get a little messy, but that's where something called lenses (can) come into play but that's a bit more of an advanced topic
17:56:01 <mwhit> zereraz_: putStrLn
17:56:09 <redtricycle> roboguy_: thanks, i think a good enough start for me to clean up this code
17:56:10 <zereraz_> mwhit: ok thanks
17:56:11 <dwcook> redtricycle, Network {..} -- requires WildcardPatterns, I think it's called
17:56:27 <rasfar> transaction network | networkName network == "Bruhaha"  = ...
17:56:30 <roboguy_> redtricycle: but yeah, the keyword to lookup for more info on that kind of thing is "haskell record syntax"
17:56:51 <roboguy_> (and, someday, lenses. but probably not today)
17:56:52 <redtricycle> gotcha
17:57:16 <luite> solidus-river: be aware that haste sneakily passes -O2 to the GHC API btw, GHCJS uses the GHC default (no optimization)
17:57:22 <mwhit> roboguy_: was that intended as "you're not ready for lenses yet", or "lenses aren't ready yet?"
17:57:36 <roboguy_> mwhit: more "you're probably not ready for lenses yet"
17:57:40 <mwhit> gotcha
17:57:46 <dwcook> redtricycle, RecordWildCards is the extension I was thinking of, but probably just using the networkName function or whatnot is better
17:57:47 <roboguy_> I just realized the ambiguity after I said it, haha
17:57:54 <dwcook> s/is better/works fine/
17:58:03 <redtricycle> dwcook: i'll add that to my "to-study" list
18:03:31 <bitemyapp> redtricycle: use newtype.
18:10:55 <trap_exit> is there a way in haskell to write a 'cartesian product'? i.e. [[1, 2, 3], [4, 5], [6 7 8]] -> [ [1, 4, 6], [1, 4, 7], [1, 4, 8], [1, 5, 6], [1, 5, 7], [1, 5, 8], [2, 4, 6], ... ] i.e. it has type [[a]] --> [[a]] and it takes all combaintions of an element from each [a]
18:11:11 <Lorette21>  Here some videos. I hope you like them! http://j.mp/1k7sg1g
18:11:25 <rasfar> @tell dfeuer http://lpaste.net/107812 Core for the three (GHC 7.8.1) might be of interest
18:11:26 <lambdabot> Consider it noted.
18:12:05 <platz> there some wierd connection between CPS and Church Representation "05:13 < mm_freak_> the rules are:  take a continuation argument and be fully polymorphic on the result type"
18:13:00 <platz> or maybe just being polymorphic on a result type comes up a lot
18:16:16 <bergey> trap_exit: That is the definition of the Applicative instance on [].  So for any function (I've picked the tuple functions) you can write:
18:16:22 <bergey> > (,) <$> [1,2,3] <*> [4,5] :: [(Int, Int)]
18:16:24 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:16:31 <mwhit> > sequence [[1,2], [3,4], [5,6]]
18:16:31 <bergey> > (,,) <$> [1,2,3] <*> [4,5] <*> [6,7,8] :: [(Int, Int,Int)]
18:16:32 <lambdabot>  can't find file: L.hs
18:16:32 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
18:16:48 <bergey> mwhit: Ah, nice, thanks.
18:17:01 <mwhit> bergey: wait, which one didn't work
18:17:02 <mwhit> > sequence [[1,2], [3,4], [5,6]]
18:17:04 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
18:17:06 <mwhit> oh there we go
18:17:10 <trap_exit> oh shit
18:17:11 <trap_exit> sequence?
18:17:14 <trap_exit> this is impressive
18:17:17 <trap_exit> s/shit/magic/
18:17:18 <mwhit> @src sequence
18:17:18 <lambdabot> sequence []     = return []
18:17:18 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:17:18 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:17:41 <trap_exit> I like magic
18:17:43 <trap_exit> well, real magic
18:21:32 * hackagebot stm-conduit 2.5.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.5.1 (ClarkGaebel)
18:23:29 <Cale> It's just sequence doing what sequence always does: running each of the actions in the list and collecting a list of the results. In the list monad, "running" a list means picking an element from it in all possible ways, so you end up with all the ways of picking one element from each list.
18:23:41 <Cale> More tricks:
18:23:50 <Cale> > filterM (const [True, False]) [1,2,3]
18:23:51 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:24:08 <Cale> "for each element of the list, regardless of what it is, keep it, or throw it away"
18:25:55 <johnw> i find it easier to comprehend filterM by writing it out in do notation using 'guard'
18:26:27 <rasfar> interesting. i guess the order of the result lists depends on the representation of a list?
18:26:27 <Cale> > filterM (\x -> if even x then [True, False] else return True) [1,2,3]
18:26:29 <lambdabot>  [[1,2,3],[1,3]]
18:26:35 <Cale> > filterM (\x -> if even x then [True, False] else return True) [1,2,3,4]
18:26:36 <lambdabot>  [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
18:26:43 <Cale> > filterM (\x -> if even x then [True, False] else return False) [1,2,3,4]
18:26:45 <lambdabot>  [[2,4],[2],[4],[]]
18:27:30 <Cale> The order of the resulting lists has to do with the order in which the choices are made
18:27:47 <Cale> You'll notice here:
18:27:50 <Cale> > filterM (const [True, False]) [1,2,3]
18:27:51 <lambdabot>  can't find file: L.hs
18:27:53 <Cale> > filterM (const [True, False]) [1,2,3]
18:27:54 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:28:08 <Cale> The first half of the lists contain 1, and the second half don't
18:28:35 <rasfar> i see it's choosing [T,T,T], [T,T,F], [T,F,T], [T,F,F] ...
18:28:46 <Cale> Yeah, similar to
18:28:53 <Cale> > replicateM 3 [True, False]
18:28:55 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
18:29:17 <ruuns> > 1 + 1
18:29:18 <lambdabot>  2
18:29:25 <ruuns> cool :)
18:29:37 <Cale> :)
18:29:48 <rasfar> ack! i'd need to desugar it and give it a think ... too much diversion for the moment
18:29:49 <ruuns> first time here :D
18:30:12 <Cale> ruuns: Feel free to ask lots of questions about Haskell :)
18:31:02 <ruuns> ju :) thx
18:32:31 <rasfar> asking on behalf of another, as i may have derailed the question yesterday: will GHC UNPACK pragma still work if the constructor contains other fields with polymorphic type?
18:32:58 <rasfar> the example was data a = {-# UNPACK #-} !Int [a]
18:33:34 <rasfar> guess i could try reading the core... gulp
18:33:46 <Cale> yeah, it only applies to the immediately adjacent field anyway iirc
18:34:46 <rasfar> yep that's true, but there were no examples on the wiki (or the GHC user guide) with polymorphism
18:35:48 <rasfar> * data Foo a = Foo {-# UNPACK ...  --oops
18:36:11 <Cale> You can't unpack a polymorphic field, because that doesn't make sense
18:36:39 <Cale> The boxing is what allows for polymorphism and lazy evaluation, so you give up both of those things when unpacking.
18:36:59 <rasfar> yeah not that, just wondering if UNPACK and parametric polymorphism were compatible (even when on different fields)
18:37:33 <rasfar> don't see why not; but don't really know
18:37:36 <Cale> UNPACK only applies to the field immediately following it
18:38:19 <Cale> The other fields can be polymorphic
18:38:32 <rasfar> yeah i understand that, but the question was more in the spirit of whether the presence of a polymorphic field would interact unfavourably with UNPACK on a strict Int field / okay
18:40:03 <rasfar> Cale: what interests you most these days?
18:41:32 <Cale> Probably homotopy type theory :)
18:42:25 <rasfar> Oh yeah? I scanned the whole HoTT last night. I have met half the people involved, which is funny to me as I know so little of the field.
18:43:35 <rasfar> Was it in reading that pub that you got the idea for the alternative topologisation?
18:45:30 <rasfar> semidecidable types as open I think it was
18:45:39 <Cale> oh, no, that was from...
18:45:51 <Cale> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
18:46:19 <rasfar> oh. thx for the link
18:47:44 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ -- see also :)
18:49:53 <btcNeverSleeps> every monad is a functor, so I can use the Maybe monad to test this at the repl:
18:49:55 <btcNeverSleeps> > fmap (\x -> x) [Just 1, Nothing, Just 2]
18:49:56 <lambdabot>  [Just 1,Nothing,Just 2]
18:50:02 <btcNeverSleeps> but
18:50:08 <btcNeverSleeps> > fmap (\x -> x + 1) [Just 1, Nothing, Just 2]
18:50:09 <lambdabot>  No instance for (GHC.Show.Show a0)
18:50:09 <lambdabot>    arising from a use of ‘M33789590060627117065046.show_M33789590060627117065...
18:50:09 <lambdabot>  The type variable ‘a0’ is ambiguous
18:50:09 <lambdabot>  Note: there are several potential instances:
18:50:09 <lambdabot>    instance [safe] GHC.Show.Show
18:50:41 <Cale> > fmap (\x -> x + 1) [Just 1, Nothing, Just 2] :: [Maybe Integer]
18:50:43 <lambdabot>  No instance for (GHC.Num.Num
18:50:43 <lambdabot>                     (Data.Maybe.Maybe GHC.Integer.Type.Integer))
18:50:43 <lambdabot>    arising from a use of ‘GHC.Num.+’
18:51:01 <Cale> ^^ this might help see what the problem is better
18:51:17 <Cale> You're trying to add 1 to e.g. Just 1
18:51:25 <btcNeverSleeps> oh ok wait
18:51:33 <trap_exit> sort
18:51:44 <Cale> > map (fmap (\x -> x + 1)) [Just 1, Nothing, Just 2]
18:51:45 <lambdabot>  [Just 2,Nothing,Just 3]
18:52:51 <Cale> > fmap (fmap (\x -> x + 1)) [Just 1, Nothing, Just 2] -- or indeed, you can use the Functor instance for lists as well
18:52:52 <lambdabot>  [Just 2,Nothing,Just 3]
18:53:11 <Cale> > (fmap . fmap) (\x -> x + 1) [Just 1, Nothing, Just 2] -- and it's possible to write it like this
18:53:12 <lambdabot>  [Just 2,Nothing,Just 3]
18:53:21 <rasfar> that's the one haha
18:53:42 <Cale> :t fmap . fmap
18:53:43 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:54:33 <rasfar> @hoogle (a -> b) -> f (f1 a) -> f (f1 b)
18:54:35 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
18:54:35 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
18:54:35 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
18:55:20 <rasfar> (trying to ferret out a named function)
18:55:25 <dagano> i wanna use typeholes .. do i have to update ghci from my 2 yr old download?
18:56:19 <johnw> you need 7.8 to use typed holes
18:56:30 <btcNeverSleeps> fmap is a (higher-order) function whose "first" argument is a function which has the type (a -> b), is that correct?
18:56:32 <johnw> they are on by default, just use _ in place of an expression
18:56:35 <btcNeverSleeps> :t fmap
18:56:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:56:41 <johnw> yes
18:56:41 <Cale> btcNeverSleeps: yes
18:56:43 <dagano> tx .. i'll go find out how to upgrade ghci
18:56:46 <btcNeverSleeps> ok but then...
18:57:17 <btcNeverSleeps> how comes that that function which has the type (a -> b) is then the 'f' in   ... -> f a -> f b?   (is it?)
18:57:32 <Cale> no
18:57:36 <btcNeverSleeps> ah
18:57:39 <Cale> f refers to the functor itself
18:57:43 <Cale> not to that function argument
18:57:50 <Cale> e.g. f might be Maybe
18:58:05 <Cale> In which case the type of fmap specialises to  (a -> b) -> Maybe a -> Maybe b
18:58:16 <Cale> Or it might be [] (the list type constructor)
18:58:22 <btcNeverSleeps> ok f is the monad in my case
18:58:29 <Cale> in which case you'd get (a -> b) -> [a] -> [b]
18:58:45 <Cale> It needn't actually be a monad, but yes
18:58:45 <btcNeverSleeps> is the list type constructor a functor?
18:58:50 <Cale> yes
18:59:00 <mwhit> well the type is
18:59:01 <Cale> instance Functor [] where fmap = map
18:59:04 <btcNeverSleeps> can I check that at the repl?
18:59:09 <dagano> is there any way to stop a fold prematurely?
18:59:09 <Cale> :info Functor
18:59:12 <btcNeverSleeps> (I mean, that [] is a functor)
18:59:14 <Cale> will get you a list
18:59:41 <mwhit> dagano: take the part of the list you want before you fold?
19:00:06 <Cale> dagano: For a foldr, simply don't use the second argument of the function you provide
19:00:23 <Cale> > foldr (\x y -> if x > 50 then x else y) 0 [1..]
19:00:24 <lambdabot>  51
19:00:58 <dagano> mwhit: tis unclear what I'll need because the fold is the main computation building up some other data structure..when some condition about this 'other data structure' holds...i want to peek at the original list i was folding. do i need state?
19:00:59 <mwhit> ^^^ better, depending on what you want to do. won't traverse the list twice
19:01:38 <Cale> dagano: you could pair each element of the original list with the whole original list
19:01:55 <Cale> > (\xs -> map ((,) xs) xs) [1..10]
19:01:56 <lambdabot>  [([1,2,3,4,5,6,7,8,9,10],1),([1,2,3,4,5,6,7,8,9,10],2),([1,2,3,4,5,6,7,8,9,1...
19:02:02 <rasfar> > fmap ((<$>) Just) [Right 3,Left "seven"]
19:02:03 <lambdabot>  [Right (Just 3),Left "seven"]
19:02:31 <Cale> dagano: Or depending on what part of it you need, tails might be what you're looking for:
19:02:34 <Cale> > tails [1..10]
19:02:36 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
19:02:41 <dagano> Cale: i see where you're going...that is a helpful idea.
19:03:10 <dagano>  > foldl' (\x y -> if x > 50 then x else y) 0 [1..]
19:03:26 <Cale> foldl and foldl' can never work on an infinite list
19:03:30 <Cale> @src foldl
19:03:30 <lambdabot> foldl f z []     = z
19:03:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:03:37 <dagano> oh yeah right
19:03:46 <Cale> ^^ foldl does nothing but greedily apply itself to new arguments until it finds the end of the list
19:03:51 <Cale> @src foldr
19:03:51 <lambdabot> foldr f z []     = z
19:03:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:04:01 <Cale> ^^ foldr passes control to f in the recursive case
19:06:00 <Cale> (and only if f pattern matches on its second argument does the recursive evaluation of foldr happen)
19:07:17 <btcNeverSleeps> gettting back to my (broken) example:
19:07:19 <btcNeverSleeps> > fmap (\x -> x + 1) [Just 2, Nothing]
19:07:20 <lambdabot>  No instance for (GHC.Show.Show a0)
19:07:20 <lambdabot>    arising from a use of ‘M5659280924158358515359.show_M5659280924158358515359’
19:07:20 <lambdabot>  The type variable ‘a0’ is ambiguous
19:07:20 <lambdabot>  Note: there are several potential instances:
19:07:20 <lambdabot>    instance [safe] GHC.Show.Show
19:07:45 <btcNeverSleeps> x is the entire list?
19:08:05 <arancia> x ist a single element of the list
19:08:08 <arancia> *is
19:09:50 <mwhit> > fmap (fmap (\x -> x + 1)) [Just 2, Nothing]
19:09:51 <lambdabot>  [Just 3,Nothing]
19:10:24 <EvanR> when in doubt use more fmaps
19:10:45 <btcNeverSleeps> EvanR: : )
19:10:58 <ReinH> Hmm. Is there a way to quiet lambdabot's output for type holes a bit?
19:11:00 <mwhit> here both [] and Maybe are functors, have to go inside both
19:11:12 <ReinH> > fmap _f [Just "foo", Nothing]
19:11:13 <lambdabot>  Found hole ‘_f’ with type: Data.Maybe.Maybe [GHC.Types.Char] -> b
19:11:14 <lambdabot>  Where: ‘b’ is a rigid type variable bound by
19:11:14 <lambdabot>             the inferred type of it :: [b] at Top level
19:11:47 <btcNeverSleeps> mwhit: yes, I didn't understand that [] was a functor too, so I was really all lost.  Now things are a bit clearer.
19:12:59 <EvanR> > (+1) <*> [1, 2, 3, 4, 5]
19:13:00 <lambdabot>  Couldn't match expected type ‘[a0 -> b]’
19:13:00 <lambdabot>              with actual type ‘a1 -> a1’
19:13:17 <EvanR> > [(+1)] <*> [1, 2, 3, 4, 5]
19:13:19 <lambdabot>  [2,3,4,5,6]
19:13:25 <EvanR> > [(+1),(+2)] <*> [1, 2, 3, 4, 5]
19:13:27 <lambdabot>  [2,3,4,5,6,3,4,5,6,7]
19:14:32 <rasfar> > fmap ((<$>) Just) [Right 3,Left "seven"]  -- what's going on here?
19:14:33 <lambdabot>  [Right (Just 3),Left "seven"]
19:14:46 <Iceland_jack> @src (<$>)
19:14:46 <lambdabot> f <$> a = fmap f a
19:14:47 <mwhit> rasfar: Either a b is only a functor w.r.t b
19:14:57 <rasfar> I see!
19:14:59 <mwhit> fmap f Left foo does nothing
19:15:23 <rasfar> @src Either  -- if possible
19:15:23 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:15:38 <mwhit> haha what
19:15:49 <EvanR> @info Either
19:15:49 <lambdabot> Either
19:16:15 <rasfar> @src Either
19:16:15 <lambdabot> Source not found. You speak an infinite deal of nothing.
19:16:30 <rasfar> tell me something i don't know
19:16:35 <mwhit> why can't lambdabot do :info anyway
19:16:45 <EvanR> @info Functor
19:16:46 <lambdabot> Functor
19:16:52 <btcNeverSleeps> :t (map (fmap (\x -> x + 1)) [Just 2, Nothing, Just 3])
19:16:53 <lambdabot> Num b => [Maybe b]
19:17:12 <btcNeverSleeps> why is it showing "Num b => [Maybe b]" and not "Num a => [Maybe a]" ?
19:17:45 <rasfar> data  Either a b  =  Left a | Right b
19:17:45 <rasfar>   deriving (Eq, Ord, Read, Show, Typeable)
19:17:45 <rasfar> instance Functor (Either a) where
19:17:45 <rasfar>     fmap _ (Left x) = Left x
19:17:45 <rasfar>     fmap f (Right y) = Right (f y)
19:18:19 <mwhit> btcNeverSleeps: I'm not sure how ghc assigns type variable names sometimes. Possibly the x in the lambda is being given "a"? it doesn't matter anyway
19:18:49 <EvanR> i demand an alpha conversion!
19:18:56 <mwhit> :t fmap (fmap succ) [Just 2, Nothing, Just 3]
19:18:57 <lambdabot> (Num b, Enum b) => [Maybe b]
19:19:01 <mwhit> guess not
19:25:47 <mwhit> why is having an incomplete typeclass instance only a warning? seems like that should be an error
19:27:02 <rasfar> do the default methods fire for the missing bits?
19:28:09 <Cale> mwhit: I guess it was considered similar to incomplete record constructions or incomplete pattern matches
19:28:41 <mwhit> rasfar: even for methods with no default
19:28:44 <mwhit> Cale: yeah, i suppose
19:30:23 <btcNeverSleeps> I'm still a bit "stuck" mentally.  This works:
19:30:25 <btcNeverSleeps> > fmap succ $ Just 2
19:30:27 <lambdabot>  Just 3
19:30:28 <btcNeverSleeps> and this too:
19:30:35 <btcNeverSleeps> > map (fmap succ) $ [Just 2, Nothing]
19:30:38 <lambdabot>  [Just 3,Nothing]
19:30:43 <btcNeverSleeps> and I'm ok with that
19:30:56 <btcNeverSleeps> however I don't understand why this fails:
19:31:13 <btcNeverSleeps> fmap succ [Just 2, Nothing, Just 3]
19:31:18 <btcNeverSleeps> because
19:31:19 <btcNeverSleeps> :t fmap
19:31:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:31:28 <mwhit> right
19:31:33 <mwhit> and what's f in the last example?
19:31:49 <btcNeverSleeps> the list functor
19:31:52 <mwhit> right
19:32:03 <mwhit> and since the argument you're giving it is [Maybe Int]
19:32:13 <mwhit> that makes our "a" = Maybe Int
19:32:24 <mwhit> the signature for functor says then
19:32:30 <mwhit> that the function you're giving it
19:32:34 <mwhit> must take Maybe Ints
19:32:38 <mwhit> but succ does not
19:32:44 <btcNeverSleeps> oooh
19:32:57 <arancia> > succ (Just 2)
19:32:58 <lambdabot>  No instance for (GHC.Show.Show a0)
19:32:58 <lambdabot>    arising from a use of ‘M15602271014886172585766.show_M15602271014886172585...
19:32:58 <lambdabot>  The type variable ‘a0’ is ambiguous
19:32:58 <lambdabot>  Note: there are several potential instances:
19:32:58 <lambdabot>    instance [safe] GHC.Show.Show
19:33:02 <mwhit> :t succ
19:33:03 <lambdabot> Enum a => a -> a
19:33:05 <mwhit> :t fmap succ
19:33:06 <lambdabot> (Functor f, Enum b) => f b -> f b
19:33:43 <arancia> > fmap isJust [Just 2, Nothing, Just 3]
19:33:45 <lambdabot>  [True,False,True]
19:35:12 <btcNeverSleeps> :t isJust
19:35:12 <rasfar> that's such an awful error message, yeesh
19:35:13 <lambdabot> Maybe a -> Bool
19:36:03 <btcNeverSleeps> thanks a lot to all: this is really cool and looks insanely powerful
19:36:34 <mwhit> btcNeverSleeps: No prob. Functor is the weakest one, too, haha
19:36:41 <EvanR> haha insanely powerful
19:37:11 <EvanR> i wish this is what features were like when people expect insanely powerful
19:37:20 <EvanR> usually means unsafe and incomprehensible too
19:40:10 <Gurkenglas> >fmap (fmap succ) [Just 2, Nothing, Just 3]
19:40:14 <Gurkenglas> > fmap (fmap succ) [Just 2, Nothing, Just 3]
19:40:15 <lambdabot>  [Just 3,Nothing,Just 4]
19:41:06 <augur> > (fmap.fmap) succ [Just 2, Nothing, Just 3]
19:41:07 <lambdabot>  [Just 3,Nothing,Just 4]
19:41:27 <btcNeverSleeps> :t map
19:41:28 <lambdabot> (a -> b) -> [a] -> [b]
19:41:42 <btcNeverSleeps> > (map.fmap) succ [Just 2, Nothing, Just 3]
19:41:44 <lambdabot>  [Just 3,Nothing,Just 4]
19:42:05 <augur> worth keeping in mind: if you have f (g a) where f and g are functors, fmap.fmap is the composite fmap
19:42:10 <mwhit> map is just an fmap that only works on lists; it basically only exists for historical reasons, fmap can replace it in every case
19:42:22 <btcNeverSleeps> I find that last map.fmap less mind-boggling than the fmap.fmap
19:42:49 <augur> type Compose f g a = f (g a)   ;   instance (Functor f, Functor g) => Functor (Compose f g) where fmap = fmap.fmap
19:43:02 <augur> barring problems with defining Compose in this fashion
19:43:15 <augur> btcNeverSleeps: why
19:43:16 <augur> ??
19:43:22 <augur> fmap for lists is just map
19:43:27 <Gurkenglas> ((fmap::(Int->Int)->[Int]->[Int]).fmap)  succ [Just 2, Nothing, Just 3]
19:43:29 <augur> fmap for maybe is just mapMaybe
19:43:29 <augur> etc
19:43:30 <Gurkenglas> > ((fmap::(Int->Int)->[Int]->[Int]).fmap)  succ [Just 2, Nothing, Just 3]
19:43:31 <lambdabot>  Couldn't match type ‘f0 b0’ with ‘GHC.Types.Int’
19:43:31 <lambdabot>  Expected type: (b0 -> b0) -> GHC.Types.Int -> GHC.Types.Int
19:43:31 <lambdabot>    Actual type: (b0 -> b0) -> f0 b0 -> f0 b0Couldn't match expected type ‘GHC...
19:43:31 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
19:43:31 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’Couldn't match expected ty...
19:43:40 <augur> fmap is just the "one name to rule them all" thing
19:44:14 <mwhit> Gurkenglas: the left-hand fmap is the one that's mapping over the Maybes
19:44:42 <Gurkenglas> Oh right, fail.
19:44:43 <dibblego> mapMaybe is not quite the same as fmap
19:44:51 <augur> :t mapMaybe
19:44:52 <lambdabot> (a -> Maybe b) -> [a] -> [b]
19:44:59 <Gurkenglas> > ((fmap::(a->a)->[a]->[a]).fmap)  succ [Just 2, Nothing, Just 3]
19:45:00 <augur> oh, woops
19:45:01 <lambdabot>  [Just 3,Nothing,Just 4]
19:45:05 <augur> obviously i dont mean THAT map maybe
19:45:13 <augur> @hoogle (a -> b) -> Maybe a -> Maybe b
19:45:13 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:45:13 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
19:45:13 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:45:15 <btcNeverSleeps> regarding fmap which can always always be used instead of map, which is there for historical reason, is there something similar with fold?
19:45:21 <augur> awful
19:45:30 <Gurkenglas> Writing map is the same as writing (fmap::(a->a)->[a]->[a]), and btc likes that additional information
19:45:40 <mwhit> btcNeverSleeps: yes, Data.Foldable has more generic folds that could replace the ones in Prelude
19:45:43 <rasfar> and gmap to rule the fmaps! :)
19:45:52 <btcNeverSleeps> mwhit: great, that is very interesting
19:45:53 <Gurkenglas> :t gmap
19:45:54 <lambdabot>     Not in scope: ‘gmap’
19:45:54 <lambdabot>     Perhaps you meant one of these:
19:45:54 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
19:45:59 <Cale> Gurkenglas: you mean (fmap :: (a -> b) -> [a] -> [b])
19:46:30 <Gurkenglas> Right, blame it on me being sleepy
19:46:31 <augur> fmap.fmap.fmap.... is a beautiful thing
19:46:38 <augur> keep it in mind when learning about lenses
19:46:41 <augur> ~fyi~
19:46:56 <rasfar> Gurkenglas: gmap is discussed http://www.haskell.org/pipermail/haskell-cafe/2014-January/111995.html
19:47:08 <btcNeverSleeps> I said it looked less mind-boggling to understand because I'm used to Clojure's map and Haskell's map seems to act a bit like Clojure's map, while fmap doesn't.  So with map.fmap there's only one function which I'm not familiar with ; )
19:47:22 <augur> btcNeverSleeps: fmap is a generalization of map
19:47:30 <augur> btcNeverSleeps: map :: (a -> b) -> [a] -> [b]
19:47:42 <augur> btcNeverSleeps: better to write it like this:    map :: (a -> b) -> List a -> List b
19:47:56 <augur> btcNeverSleeps: but then, why `List'??   fmap :: (a -> b) -> f a -> f b
19:48:08 <augur> same thing, but abstracting over `List'!
19:48:25 <johnw> i have issues with saying fmap is a generalization of map
19:48:32 <augur> johnw: why?
19:48:40 <augur> johnw: its literally true
19:48:44 <johnw> fmap lifts 'f' into the domain of the Functor
19:48:51 <augur> map is a particular instance of fmap
19:48:52 <johnw> yeah, but mapping implies something more akin to a container
19:48:52 <btcNeverSleeps> a generalization which work over any functor and list are just one type of functor!?
19:49:02 <augur> johnw: no.. fmap doesnt lift f at all. it presupposes f is a funtor
19:49:10 <johnw> i mean, the f passed fmap
19:49:21 <johnw> fmap f = a function within the codomain (sorry) of the functor
19:49:22 <haasn> btcNeverSleeps: correct
19:49:22 <augur> btcNeverSleeps: "functor" is just a way of saying "supports a mapping operation"
19:49:36 <augur> btcNeverSleeps: so of course "fmap" works for for any functor!
19:49:59 <johnw> yeah, I don't agree with "functor is just a way of saying supports a mapping operation"
19:50:01 <johnw> but oh well
19:50:05 <augur> btcNeverSleeps: its tautological. "to be a functor" just means "to have a map-like function"
19:50:15 <haasn> johnw: personally I disagree with “mapping implies container”
19:50:18 <haasn> I don't really see it that way
19:50:20 <augur> johnw: you can disagree but the definition of "functor" says otherwise
19:50:28 <johnw> haasn: how do you see ti?
19:50:40 <ddellacosta> I thought part of the definition of a functor (category theory) is that it maps a category to another, while preserving identity?
19:50:41 <johnw> people talk as though fmap does the working of "mapping"
19:50:41 <augur> johnw: for `f` to be a functor _just is_ to have a map-like function
19:50:49 <dibblego> there are many ways of seeing it, lifts (a -> b) to (f a -> f b) is one
19:50:50 <augur> johnw: that is _literally_ the definition
19:50:51 <mwhit> johnw: It is definitely true that it's a generalization. "Map" is just a name, it can't have any effect on the mathematical properties of the function
19:50:53 <johnw> it's the particular *instance* of Functor which does the mapping
19:50:55 <johnw> not fmap per se
19:51:05 <augur> ddellacosta: yes, and `map` is one instance of this :)
19:51:59 <haasn> johnw: I'd almost say I see mapping as any sort of “lift” that preserves composition/identity
19:52:16 <johnw> haasn: ok, maybe I'm mistaking the concept of 'mapping' then
19:52:31 <haasn> johnw: I'm not sure if there's anything to “mistake”
19:52:33 <mwhit> it's just a name
19:52:35 <johnw> from my imperative background, I know that this point kept me from better understanding functors for a really long time
19:52:35 <mwhit> the name is irrelevant
19:53:02 <haasn> the only really formal definition of a “map” I know is that of a function between sets from mathematics
19:53:10 <dibblego> (a -> b) -> (t -> a) -> (t -> a) is also a specialisation of fmap
19:53:16 <augur> "map" is just a way of taking operations on elements to operations of lists of elements
19:53:18 <dibblego> (a -> b) -> (t -> a) -> (t -> b) is also a specialisation of fmap
19:53:26 <johnw> i.e., I prefer to read fmap f xs as (fmap f) xs, where fmap f selects a mapping function
19:53:26 <haasn> (among other pesky things like “those things that are supposed to help you find the right turn to take”)
19:53:28 <dibblego> lift0 :: a -> f a
19:53:36 <augur> "fmap" at functor `f` is jus a way of taking operations on elements to operations on `f`'s of elements
19:53:40 <dibblego> lift1 :: (a -> b) -> f a -> f b
19:53:41 <rasfar> in topology "map" = "continuous function"
19:53:45 <johnw> so rather than fmap doing any mapping, it is picking a mapping
19:53:46 <mwhit> johnw that's perfectly correct, yes
19:53:50 <mwhit> err
19:53:51 <johnw> mwhit: ok :)
19:53:52 <mwhit> the part before that
19:54:01 <haasn> johnw: Now, those, I see as equivalent :)
19:54:05 <augur> johnw: thats an issue with type classes
19:54:11 <augur> johnw: not the concept of functorial mapping
19:54:11 <johnw> yeah, this could just be my background then, carry on
19:54:17 <haasn> johnw: Depends on how strong your intuition for currying is
19:54:39 <haasn> I don't perceive a semantic difference between mapping something over something and returning a mapping function
19:54:40 <johnw> haasn: I didn't know what currying was when I encountered Functor the first time
19:54:42 <augur> so dibblego, did you ragequit twitter?
19:54:50 <btcNeverSleeps> dibblego: dibblego!!! You still around!  I remember JTiger from 2004 or so!
19:54:51 <dibblego> augur: no
19:54:57 <dibblego> btcNeverSleeps :)
19:55:17 <augur> dibblego: did you quit twitter at all?
19:55:24 <dibblego> augur: yes
19:55:31 <augur> dibblego: may i ask why?
19:55:34 <johnw> augur: how do you explain "mapping" for the Const functor?  In that case, 'fmap f' selects the identity function
19:55:40 <dibblego> augur: because it is a waste of time
19:55:50 <mwhit> johnw: you just answered your own question
19:55:58 <johnw> mwhit: how so?
19:56:09 <augur> johnw: identities can be maps :)
19:56:10 <johnw> ah, because I'm mapping f to identity?
19:56:13 <johnw> ah, ok
19:56:22 <johnw> there is mapping f, and then there is "mapping" f over xs
19:56:31 <mwhit> johnw: you're getting too caught up on the word mapping. the word mapping is arbitrary
19:56:37 <mwhit> it could just as easily be called lift
19:56:52 <johnw> if it were called lift, then what would augur's explanation sound like?
19:56:55 <dibblego> lift0 would be consistent
19:57:03 <mwhit> exactly the same, but with the word "map" replaced with "lift"
19:57:04 <johnw> well, it is called liftM in one context at laest
19:57:06 <dibblego> er lift1
19:57:12 <levi> rasfar: I think the topological sense of "map" can be applied to the idea of functors, but I couldn't give you an exact explanation of it.
19:57:17 <augur> johnw: to be a map means to take the elements of the specified type to corresponding elements given by the mapping function
19:57:28 <augur> johnw: the fact that Const's have no such elements is irrelevant
19:57:41 <haasn> An interesting way to look at things is to consider what we're doing to the type system as well; with the actual values being a side not for now - in the type system, fmap (f :: a -> b) transforms the ‘a’ in Const x a to ‘b’ in Const x b; we're mapping over the type parameter
19:57:43 <dibblego> (t ->) also doesn't have elements (kind of)
19:57:47 <augur> johnw: Const a b has no b elements, so sure, the map for Const a b does what it says
19:57:47 <rasfar> hi levi; well, i'm just starting to read about type theory in HoTT (which I'm sure you know of)
19:57:49 <johnw> so fmap f xs maps f to a function that maps xs to some xs'?
19:57:57 <augur> johnw: it takes all none of the b's to c's
19:58:12 <levi> rasfar: Ah, well, it's probably fresher in your mind than it is in mine.
19:58:13 <augur> johnw: just like `map` apply to the empty list takes all none of the a's to b's
19:58:21 <rasfar> two days ago I thought "universe" was "space of all values in a type" ... which is a "type" actually, so you see where I'm at heh
19:58:33 <augur> johnw: it does what it says on the tin!
19:59:44 <augur> johnw: lets take a special case
19:59:55 <augur> johnw: suppose we define   data SillyList a = Nil
20:00:05 <augur> johnw: just like List, except only with the Nil constructor
20:00:06 <augur> no cons
20:00:19 <augur> now:   mapSillyList :: (a -> b) -> SillyList a -> SillyList b
20:00:25 <augur> mapSillyList f Nil = Nil
20:00:27 <haasn> I think (x -> a) is a much more interesting type to build intuition for than Const x a
20:00:32 <augur> this is just map for lists, but without the cons case
20:00:33 <johnw> yeah, that's just Const () basically
20:00:42 <augur> johnw: surely this is _merely_ a special case of normal map, right?
20:00:53 <augur> it really is a mapping function, just for a silly sort of list
20:00:55 <johnw> what I mean is, there are two "maps" happening here, aren't there?
20:01:00 <johnw> f is being mapped, and xs is being mapped
20:01:05 <augur> what?
20:01:08 <augur> i dont follow
20:01:17 <johnw> fmap f maps f : a -> b to f a -> f b
20:01:19 <haasn> johnw: There are also two function applications happening here
20:01:22 <augur> johnw: noooooo
20:01:26 <johnw> f a -> f b maps fa to f b
20:01:29 <augur> johnw: ive never heard anyone describe it like that
20:01:34 <haasn> augur: I think it makes sense
20:01:42 * hackagebot uxadt 0.0.13.0 - Universal (cross-language) extensible representation for algebraic data type instances.  http://hackage.haskell.org/package/uxadt-0.0.13.0 (AndreiLapets)
20:01:43 <mwhit> johnw: you are conflating two different usages of the word "map" here
20:01:52 <dibblego> johnw: it is lifting, not mapping
20:01:52 <augur> johnw: its sooort of technically correct, but its not what people usually mean in my experience
20:01:57 <johnw> it's exactly this conflation that was my initial point :)
20:02:02 <mwhit> johnw: not least because different people are using the word differently in this conversation
20:02:15 <rasfar> johnw: that's what I think of as the "lift" but yeah, I think of it like that too
20:02:15 <haasn> johnw: I spy three maps happening here
20:02:17 <mwhit> johnw: "map", as used in fmap, means "to lift a function into a functor context"
20:02:20 <gaze__> Say I have a functor "data TreeF a = Branch a a | Leaf" if at some point in my program I have a TreeF (Either b c), are there any automatically derivable instances that will let me send TreeF (Right a) -> Right (TreeF a) and TreeF (Left a) -> Left a
20:02:23 <mwhit> johnw: this usage of it is arbitrary
20:02:37 <dibblego> lift0 :: a -> f a; lift1 :: (a -> b) -> (f a -> f b); lift2 :: (a -> b -> c) -> f a -> f b -> f c. lift0 is often called return or pure and lift1 is often called fmap, (<$>) or liftM
20:02:38 <mwhit> johnw: the other usage is saying that a function "maps" values from its codomain to its domain
20:02:39 <johnw> mwhit: sure, I think 'lift' is a better word to use too
20:02:49 <augur> johnw: so the main problem with that view, ok
20:02:54 <augur> johnw: is that it doesnt work for all `f`
20:02:58 <haasn> johnw: “f :: a -> b” is being mapped to some “f' :: f a -> f b”; “xs :: f a” is being mapped to some “xs' :: f b” and ‘f’ is being mapped over elements of ‘xs’
20:02:59 <mwhit> johnw: so basically we're just arguing over semantics
20:03:16 <mwhit> johnw: the original point, that fmap generalizes map, is not a semantic point
20:03:19 <augur> johnw: that is to say, haskell's fmap is _not_ doing anything to "lift" `f` or whatever
20:03:25 <mwhit> johnw: it is a mathematically precise statement, which is true
20:03:39 <dibblego> augur: I think when someone has said to "lift f", then mean the function f not the type constructor
20:03:45 <johnw> augur: you mean, modulo type class instance resolution?
20:03:49 <augur> johnw: remember that haskell's fmap is just a fancy way of letting you the programming refer to different functions
20:03:55 <augur> johnw: well but type classes are important here, ok
20:04:03 <augur> johnw: haskell's fmap is a cheat
20:04:17 <augur> johnw: fmap is really just a projection function that accesses a field in a record
20:04:20 <dibblego> the expression (fmap f) lifts f :: (a → b) using Functor k to :: (k a -> k b)
20:04:35 <augur> johnw: there is no actual thing called "fmap" which magically does what you say
20:04:35 <mwhit> augur: that seems like a point about implementation, not definition
20:04:41 <augur> mwhit: no its crucial
20:04:47 <johnw> augur: right
20:04:48 <haasn> “fmap” maps a type to a specific map-mapping map function
20:04:51 <augur> johnw: the idea of `fmap` is a fiction
20:04:54 <johnw> I don't mean to say that "fmap" exists on its own
20:05:09 <johnw> in the same way that "fmap" never maps over lists :)
20:05:14 <augur> johnw: the point is that there are all of these different things -- map for lists, map-for-maybe, map-for-trees, etc -- which have the same basic shape
20:05:25 <augur> (a -> b) -> f a -> f b   for some particular f in question
20:05:43 <augur> `fmap` is just a convenient way of refering to _all_ of them in one fell swoop
20:06:08 <augur> to say "fmap" is really just to say "you know, that map-like thing for the particular type we're talking about"
20:06:22 <haasn> johnw: I wonder if “fmap” is something like a functor from Hask to the category of endofunctors on Hask
20:06:33 <augur> whenever you read "fmap" you should always thing "that map-like thing for this particular type"
20:06:35 <johnw> haasn: hmm
20:06:46 <haasn> Wait, no, that doesn't seem to make a lot of sense
20:06:46 <rasfar> the one that's selected depends on the type of the second argument, and requires an instance of Functor for that type to exist
20:06:47 <augur> you should never think that "fmap" is something unto itself
20:06:57 <haasn> I'm trying to capture the behavior of “mapping a type in Hask to a specific functor”
20:06:58 <augur> haasn: no, "fmap" is nothing
20:07:02 <augur> pretend it doesnt exist
20:07:08 <levi> You know, this whole discussion wouldn't have happened if they had left 'map' as the Functor method instead of renaming it fmap.
20:07:20 <augur> seriously
20:07:23 <augur> "fmap" is not a thing
20:07:38 <augur> its literally just a fancy way of saying "fst"
20:07:49 <augur> thats all that "fmap" is, truly
20:07:51 <johnw> although, 'fmap' doesn't refer to anything either; rather fmap + some 'f'
20:08:05 <johnw> obvious, but just wanted to point that out
20:08:08 <haasn> Now that does not make a lot of sense to me
20:08:13 <rasfar> fmap is a class method; maybe more attention to the class/instance aspect is needed here -- or am i missing the point?
20:08:23 <augur> johnw: fmap + some 'f' is just a way of refering to that-mappy-thing-for-f
20:08:29 <ddellacosta> augur: sorry, where does the "fst" notation come from?  I think I missed that point in the conversation
20:08:39 <levi> I haven't followed this closely, but someone is making mountains out of molehills. I dunno who.
20:08:49 <augur> deavid: secretly, this type:   Functor f => ...   is really this type:   Functor f -> ...
20:08:52 <augur> er, ddellacosta^
20:09:14 <johnw> rasfar: as a newbie, I came away with the idea that functors are about mapping over data structures, when really it's about lifting functions, so that *those functions* can map over data structures
20:09:25 <mwhit> johnw: those are the same thing
20:09:26 <augur> ddellacosta: Functor f is secretly not a "type class" but actually just a data decl   data Functor f = MkFunctor { fmap :: (a -> b) -> f a -> f b }
20:09:31 <johnw> yeah, I know *now* that they are the same thing
20:09:35 <johnw> but it took me many months to see that
20:09:44 <dibblego> forall a b. ^^
20:09:48 <augur> ddellacosta: but this is secretly just a boring pair type   ((a -> b) -> f a -> f b, ())
20:09:49 <ddellacosta> augur: sorry to be dense, still not sure what "fst" is -- is that an acronym?  Sorry, super n00b question probably.
20:09:57 <augur> ddellacosta: fst :: (a,b) -> a
20:10:01 <augur> projects the first element out of a pair
20:10:02 <ddere> :t fst
20:10:02 <lambdabot> (a, b) -> a
20:10:09 <haasn> johnw: Then did you run into the same issues when trying to understand how the monad instance for (->) x worked?
20:10:15 <johnw> oh heck yes
20:10:34 <ddellacosta> augur, ddere: ah okay, thank you.  I have a very imbalanced understanding of Haskell now--I know a fair bit about Functors at this point, and little about the standard lib!
20:10:38 <johnw> in fact, that conflation of ideas hurt me in many ways, which is why I make the point now
20:10:50 <haasn> If the problem is not contained to fmap, perhaps the solution lies not in debating the terminology of fmap
20:10:52 <johnw> but I admit it's a fine distinction, and may not relate to others' experience
20:11:01 <augur> ddellacosta: its a fact about type classes, really. not the stdlib
20:11:02 <johnw> haasn: how would you state it more generally?
20:11:18 <mwhit> yeah the discussion was originally supposed to be about the mathematical relationship between fmap and map
20:11:24 <ddellacosta> augur: oh yeah--but I didn't know the fst function so that I could even get your broader point, is all
20:11:27 <mwhit> but somehow we got on the implementation relationship
20:11:31 <augur> ddellacosta: ahh ok
20:11:34 <mwhit> which is an entirely separate thing
20:12:10 * EvanR scratches head at Functor == fst
20:12:24 <augur> EvanR: no no
20:12:29 <augur> EvanR: not Functor == fst
20:12:33 <augur> EvanR: fmap == fst
20:12:36 <ddellacosta> fmap
20:12:37 <ddellacosta> right
20:12:44 <johnw> mwhit: if I drew the categorical diagrams, 'f' and 'fmap f' are different arrows, and it's the latter which maps between lists, for example
20:13:01 <mwhit> johnw: again, two different usages of "map"
20:13:12 <johnw> can you clarify?
20:13:15 <augur> EvanR: the Functor type class is a trivial tuple type that the type checker will resolve for you. trivial in that its a boring tuple ((forall a b. (a -> b) -> f a -> f b),())
20:13:22 <rasfar> augur: what you say about Functor not really being a typeclass -- that's true of all the typeclasses though right?
20:13:30 <mwhit> johnw: "mapping between lists" just means a function [a] -> [a]
20:13:33 <rasfar> it's just desugaring
20:13:34 <augur> rasfar: Functor is a typeclass
20:13:40 <johnw> mwhit: yes
20:13:41 <rasfar> yes of course
20:13:51 <mwhit> johnw: "mapping over a functor" means (a->b) -> f a -> f b
20:13:54 <rasfar> but the => becomes -> thing, that's how classes are implemented, right?
20:13:58 <augur> rasfar: but my point about fmap is that the function fmap itself is not doing magic itself
20:14:01 <mwhit> johnw: that they share a name is coincidence
20:14:02 <EvanR> how did you go from MkFunctor { fmap :: (a->b) -> a -> b } to fst :: (a,b) -> a
20:14:20 <augur> rasfar: and what we (johnw) shouldnt confuse the fmap function for the general pattern of "being a mapping"
20:14:22 <rasfar> (i just read about this yesterday in the SOP paper)
20:14:22 <johnw> mwhit: I don't think I've encountered the terminology "mapping over a functor"
20:14:34 <johnw> augur: yay! :)
20:14:39 <augur> johnw's description of fmap as a thing which does yadda yadda is false
20:14:46 <augur> its missing the point about fmap entirely
20:14:49 <johnw> augur: which description was false?
20:15:01 <augur> johnw: "fmap maps `f`'s to ..."
20:15:07 <johnw> how was that false?
20:15:14 <johnw> fmap f maps f : a -> b to f a -> f b
20:15:22 <augur> johnw: false
20:15:24 <johnw> umm
20:15:24 <dibblego> *lifts*
20:15:33 <augur> dibblego: false
20:15:35 <johnw> categorically, also maps
20:15:36 <augur> dibblego: it doesnt even lift
20:15:36 <dibblego> No.
20:15:40 <dibblego> yes it is lift1
20:15:44 <levi> Oh geez, people.
20:15:47 <augur> dibblego: fmap does no such lifting
20:15:49 <dibblego> just like return is lift0
20:15:55 <johnw> how is (a -> b) -> (f a -> f b) not a mapping?
20:15:58 <dibblego> does liftA2 do lifting?
20:15:58 <augur> the only function that fmap performs is to project out a _predefined_ mapping function
20:16:01 <EvanR> lost
20:16:04 <mwhit> augur: You are talking about how it is implemented. EVERYONE ELSE is talking about functors as a mathematical construct
20:16:08 <augur> mwhit: no
20:16:14 <dibblego> does liftA2 do lifting?
20:16:19 <augur> mwhit: everyone else is not talking about the mathematical construction
20:16:19 <johnw> mwhit++
20:16:24 <augur> mwhit: there is no "fmap" in category theory
20:16:32 <dibblego> does liftA2 do lifting?
20:16:34 <rasfar> i really think this is a classic case where it's simplest to describe it as class/instances
20:16:39 <augur> dibblego: no.
20:16:42 <EvanR> does liftA2 even lift
20:16:43 <augur> demonstrably so.
20:16:54 <dibblego> well, at least you are consistent
20:17:01 <augur> liftA2, like fmap, is a fiction that projects out pre-defined elements
20:17:16 <haasn> mwhit: w.r.t to what you said before; wouldn't it be more accurate to say some Functor f maps ‘a’ to ‘f a’ and ‘g :: a -> b’ to ‘g' :: a -> b”? f itself being a map from * to *
20:17:22 <augur> if you think fmap, or liftA2, has ANY action on `f`'s then you would be hard pressed to explain why its not defined for non-functorial f's
20:17:26 <augur> or non applicative f's
20:17:37 <augur> fmap/liftA2 PRESUPPOSE the existence of the relevant operations
20:17:39 <augur> they do not LIFT anything
20:17:54 <augur> if fmap LIFTED things, then it would work for arbitrary f's
20:17:55 <johnw> augur: hmm.. I see your point there
20:17:55 <augur> it does NOT
20:18:08 <mwhit> saying it "lifts into a functorial context" presupposes the existence of that functorial context
20:18:11 <augur> fmap merely takes what you ALREADY DEFINED and gives you access to it under a common name
20:18:13 <mwhit> it is not an incorrect thing to say
20:18:24 <augur> mwhit: no thats not what lifting is understood to mean in common parlance
20:18:29 <rasfar> which is class/instances
20:18:35 <haasn> augur: Perhaps it would be best if you don't use the same variable for f the Functor and f the function
20:18:36 <augur> mwhit: to "lift" something is to take an arbitrary something and add more functionality to it
20:18:46 <haasn> fmap clearly is defined for any possible function that has the correct type signature
20:18:59 <EvanR> :t lift
20:19:00 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
20:19:04 <augur> haasn: yes, that was my point about fmap acting as a projector
20:19:05 <rasfar> which (fmap f) does -- provided the instance exists
20:19:19 <haasn> And from what I can tell, johnw was talking about “fmap” mapping f the *function* to fmap f the function
20:19:21 <augur> johnw: im glad you see my point :)
20:19:25 <EvanR> this lift function presupposes you have a monadtrans
20:19:27 <johnw> haasn: yes
20:19:34 <augur> johnw: fmap does not map functors `F` to (a -> b) -> F a -> F b
20:19:36 <haasn> not f the functor
20:19:48 <johnw> augur: I meant 'f' the function passed to fmap
20:19:55 <mwhit> ok, this is a bunch of people using 3 different words in 8 different ways
20:19:56 <johnw> yeah, I guess we confused that point
20:20:04 <augur> johnw: well, it might be said to make _functors_ F, actually, since that presupposes yadda yadda
20:20:04 <johnw> 'f' at type scope and 'f' at variable scope
20:20:08 <augur> johnw: it doesnt map arbitrary F's
20:20:16 <johnw> right
20:20:19 <haasn> this also explains why augur was going on about Functor f => really being Functor f ->; when that was not relevant to johnw's argument
20:20:25 <mwhit> ^^^
20:20:34 <johnw> I think we may have reached consensus!
20:20:40 <mwhit> the question was literally whether fmap generalizes map
20:20:47 <augur> johnw: the point about fmap being a generalized map is that the _concept_ of functorial mapping is just the concept of list-mapping, but generalized
20:20:50 <haasn> Let's use “m” for the type parameter
20:20:52 * haasn ducks
20:20:57 <ddellacosta> I do think that the common convention to use f for both the function and the functor in the sig is really horrible, how did that happen?
20:21:08 <augur> johnw: generalized in the sense that the type of the one is a generalization of the type of the other
20:21:09 <haasn> ddellacosta: (f)unction and (f)unctor
20:21:21 <johnw> augur: ok, that last sentence feels like it's merging two ideas; I'm trying to picture it in terms of a category diagram, but cannot
20:21:23 <ddellacosta> haasn: yeah, I get that...haha
20:21:24 <maybefbi> if there are two functions that do the same thing in haskell. and if one is smaller than the other in the number of characters used, then is the smaller function better in terms of software engineering?
20:21:25 <haasn> ddellacosta: No real deep meaning there
20:21:36 <johnw> augur: can you draw "fmap is a generalized map" for me?
20:21:48 <ddellacosta> haasn: what I mean is, why didn't someone immediately decide that it was a bad idea?  That's all...a digression though. Carry on. :-)
20:21:48 <mwhit> johnw: that is not a category diagram
20:21:50 <augur> johnw: no, there is no categorical concept that corresponds to "fmap" afaik
20:21:51 <haasn> ddellacosta: We just tend to pick “f”​ for functions, and we tend to pick the first letter of type class names for type class parameters (Monoid m, Monad m, Num n, Functor f, etc)
20:22:00 <augur> johnw: maybe there is, but ive never encountered it
20:22:11 <augur> johnw: and the reason is that haskell's "fmap" is a convenience, not a mathematical concept
20:22:14 <johnw> augur: isn't it the morphism mapping "part" of the functor F from C -> D?
20:22:25 <haasn> Oh, although Num is defined as (Eq a, Show a) => Num a
20:22:26 <augur> johnw: i dont know what you mean
20:22:38 <haasn> .. and Monoid as Monoid a
20:22:46 <haasn> I guess maybe we only use different parameters when “a” is already taken
20:22:51 <augur> johnw: in CT, there is no "fmap", there is only "mapTheFIHaveInMind"
20:22:51 <haasn> eg. for fmap :: (a -> b)
20:22:54 <haasn> -> ...
20:23:05 <glguy_> A categorical functor maps the objects and arrows from one category to another. Fmap is that mapping for the arrows
20:23:05 <augur> johnw: ie there is only "mapList", "mapTree", "mapWhatever", ...
20:23:20 <augur> johnw: there is no single thing in CT which corresponds to haskell's "fmap" function
20:23:26 <augur> glguy_: no
20:23:31 <haasn> johnw: I'd personally say the morphism mapping is the *only* part of the functor
20:23:34 <augur> glguy_: fmap-for-that-functor is the mapping for the arrows
20:23:36 <haasn> johnw: the object mapping is just baggage
20:23:53 <augur> glguy_: but HASKELLS FMAP has no commonly used correspondent in CT because haskell's "fmap" is a convenience
20:24:06 <haasn> I think of objects in CT like types in programming languages; we only really care about the values - the types are just there to differentiate
20:24:07 <mwhit> augur: all of which is totally irrelevant to the original question
20:24:08 <EvanR> what is a functor, really
20:24:12 <EvanR> i finally get functors
20:24:15 <augur> mwhit: its completely and utterly relevant
20:24:20 <johnw> so, if I have two categories, C and D, and an F between them, F takes obj in C to F(C), and hom sets Hom(A,B) in C to F(Hom(A,B)).  This latter is what fmap expresses, no?
20:24:28 <augur> johnw: no
20:24:33 <mwhit> the original question wasn't really even a CT question
20:24:40 <augur> johnw: the latter is what fmap-when-instantiated-at-f=F expresses
20:24:43 <johnw> mwhit: it's my framework for trying to understand this mathematically
20:24:48 <augur> johnw: REMEMBER:
20:24:49 <augur> :t fmap
20:24:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:24:54 <johnw> mwhit: I guess what I meant by "diagram" was just a picture
20:25:10 <augur> johnw: HASKELLS FMAP is NOT the functorial mapping for any particular functor!
20:25:17 <johnw> augur: hmmm
20:25:26 <augur> johnw: it is a PROJECTOR that takes a proof-of-functoriality and GIVES YOU the functorial mapping for that functor
20:25:35 <johnw> augur: so you're saying I have to choose the F to complete the picture?
20:25:36 <augur> johnw:
20:25:43 <augur> :t fmap :: (a -> b) -> [a] -> [b]
20:25:43 <lambdabot> (a -> b) -> [a] -> [b]
20:25:50 <johnw> and once I've chosen the F, fmap evaporates?
20:26:03 <augur> johnw: i am saying that `fmap` in haskell is NOT the same thing as a functorial map
20:26:10 <johnw> because of its polymorphism?
20:26:15 <augur> johnw: because it is a projector
20:26:22 <haasn> So what about (fmap :: (a -> b) -> f a -> f b) with -XScopedTypeVariables
20:26:35 <glguy_> He's just quibbling over fmap being the overloaded name for those operations
20:26:41 <johnw> augur: ok, I buy that; thanks for taking all that time to clarify
20:26:46 <augur> glguy_: its not a quibble tho
20:26:49 <mwhit> yes it is
20:26:49 <augur> glguy_: its crucially important
20:27:01 <haasn> Importance is subjective
20:27:08 <haasn> Maybe it's important to somebody trying to fit it into category theory
20:27:10 <augur> glguy_: because if you say you understand map for lists, then map for other things is a conceptual analogy of a trivial sort
20:27:13 <rasfar> how is this not simply class-and-instances ?? *shrugs*
20:27:22 <johnw> haasn: well, that's just what I'm trying to do, so yeah
20:27:39 <glguy_> OK augur
20:27:39 <augur> glguy_: thats why the map for Const REALLY IS a mapping, despite johnw's protests
20:27:50 <johnw> I didn't protest!
20:27:56 <augur> johnw: you said it wasnt a mapping!
20:28:00 <johnw> I said it mapped any function to identity
20:28:32 <mwhit> this argument has been about 90% miscommunication, so i wouldn't worry about it
20:28:33 <augur> johnw: it happens to do that, incidentally, as a result of what `Const` is defined as, yes
20:28:38 <johnw> yeah
20:28:44 <johnw> mwhit: fair enough :)
20:28:49 <augur> johnw: but it is still a mapping of the same sort that list's map function is
20:28:54 <augur> it does PRECISELY what it claims to do
20:29:05 <augur> mapConst :: (b -> c) -> Const a b -> Const a c
20:29:09 <augur> it does EXACTLY what it claims
20:29:10 <EvanR> the word map is so overloaded in general
20:29:13 <mzero> my  it's getting loud in here
20:29:13 <augur> it transforms all b's into c's
20:29:15 <johnw> when I first heard the word mapping, I read it as "I would write a for loop to do that"
20:29:16 <EvanR> its a terrible word to be precise with
20:29:22 <augur> the fact that there happen to be NO b's is tangential
20:29:40 <johnw> augur: yeah, I think we're cool now
20:29:47 <johnw> identity maps anything to itself
20:29:57 <augur> johnw: that it's an identity is tangential
20:30:01 <haasn> How many “maps” do you count in “fmap fmap fmap”?
20:30:10 <johnw> haasn: at least 9
20:30:11 <augur> haasn: none!
20:30:16 <johnw> haha
20:30:20 <haasn> So we still have something to argue about
20:30:21 <johnw> i was kidding
20:30:23 <EvanR> there are four lights
20:30:24 <augur> there are demonstrable no "s"s in "fmap fmap fmap"!
20:30:31 <johnw> EvanR: star trek fan!
20:30:36 <mwhit> how many maps would an fmap map if an fmap could map maps?
20:30:39 <augur> Babylon 5 did torture better
20:30:40 <augur> sorry
20:30:58 <haasn> mwhit: Precisely one!
20:31:04 <augur> haasn: definitely false
20:31:09 <mwhit> oh my god
20:31:11 <haasn> Precisely all of them!
20:31:12 <augur> it would map as many maps as exist
20:31:13 <johnw> well, this discussion is highly relevant to something I'm presenting on Tuesday
20:31:18 <johnw> so I very much appreciate the struggle for clarity
20:31:18 <augur> haasn: yes! better answer
20:31:19 <augur> :)
20:31:27 <haasn> augur: I was thinking along the lines of “the one you give it”
20:31:43 <augur> haasn: "one" and "the one you give it" are definitely not the same thing
20:31:46 <trap_exit> does haskell have a builtin to get uniques out of a sorted list?
20:31:50 <trap_exit> I guessued uniq
20:31:54 <trap_exit> but I can not find such a function :-(
20:31:58 <johnw> even if we had multiple meanings for 'f' and 'map'
20:31:59 <augur> trap_exit: import Data.List ; nub
20:32:07 <haasn> augur: How many maps did an fmap map if an fmap mapped a map
20:32:12 <mzero> trap_exit:  map head . group
20:32:15 <EvanR> trap_exit: more efficient
20:32:15 <trap_exit> what does nub stand for?
20:32:16 <augur> i still have no clue what "nub" means
20:32:17 <EvanR> would be that
20:32:17 <johnw> trap_exit: in practice you may want to use Data.Set
20:32:19 <mzero> if it really is sorted
20:32:23 <johnw> nub is very expensive
20:32:24 <mzero> nub is for when it isn't sorted
20:32:36 <mwhit> nub means nub
20:32:37 <augur> haasn: thats a different question
20:32:49 <mwhit> nub is a word
20:32:50 <EvanR> nub does precisely what it claims to
20:32:59 <mzero> > map head . group $ sort "now is the time for all good zorks to come to the aid of their planet"
20:33:01 <lambdabot>  " acdefghiklmnoprstwz"
20:33:02 <johnw> nub is a word meaning "essence or central part"
20:33:05 <augur> haasn: and i can give you formal derivations of the semantics of both questions in no fewer than three syntactic theories, if you want!
20:33:08 <haasn> trap_exit: From the base haddocks: “(The name nub means `essence'.)”
20:33:13 <haasn> The more you know!
20:33:21 <augur> haasn: ~linguist~
20:33:39 <gfixler> can anyone answer a question for me about this fmap thing?
20:33:43 <mwhit> no
20:33:44 <haasn> augur: But do you know a syntactic theory that doesn't require knowing the syntactic theory to understand? Or is that a contradiction?
20:33:49 <johnw> gfixler: that all depends on how much time you have
20:33:59 <augur> haasn: that is a contradiction
20:34:06 <gfixler> johnw: I would prefer it if 17 people answered at once - is that possible?
20:34:06 <mzero> gfixler: are you asking a practical question about using fmap in a Haskell program... or a question about category theory
20:34:06 <augur> haasn: but a synthetic one, not an analytic one
20:34:07 <trap_exit> augur, mzero, EvanR, johnw, haasn: noted, thanks!
20:34:12 <haasn> (How many ways are there to parse that question?)
20:34:16 <johnw> gfixler: throw in the word monad at least twice
20:34:22 <haasn> (I count at least 3)
20:34:25 <gfixler> johnw: no problem
20:34:34 <augur> haasn: 3? goodness, do tell
20:34:38 <augur> haasn: i can only get one parse
20:36:10 <augur> there's something kind of odd about it, due to the weird sort of parasitic gap thing going on with the purpose clause
20:36:36 <haasn> Perhaps parse is the wrong word, but rather interpretation. “knowing the syntactic theory” as in “having heard of it”, “knowing the syntactic theory” as in “understanding it, with or without knowledge of its name/existence”; and I thought I got an extra parse that sort of meant *you* have to know it for me to understand, but I guess I take that one back now that I look at it more closely
20:36:39 <solidus-river> how do you provide default implimentations of some functions of a class in terms of other functions in the class
20:36:49 <solidus-river> I have a class with 6 functions required per instance
20:36:58 <mwhit> solidus-river: just write the default instance in the class declaration
20:36:59 <augur> haasn: ahh yes that would just be some kind of lexical polysemy
20:37:05 <solidus-river> and i realized that 2 of them can be implimented in terms of the other 4 most of the time
20:37:20 <augur> haasn: not a different parse, but a difference sense of "know"
20:37:38 <solidus-river> well, all of the time, but sometimes custom optimizations might be desired to the last 2 functions
20:37:38 <haasn> “nub: The essence or core of an issue, argument etc. ‘What do you think is the nub of the problem?’”
20:37:53 <augur> haasn: plausibly, you could argue that those are difference words, and therefore constitute (trivially) different parses
20:38:02 <augur> different*
20:38:18 <solidus-river> mwhit: is it possible to write the default implimentation in a seperate place and reference it in the class declaration or does it need to be written in the class declaration itself
20:38:50 <mwhit> you ought to be able to, sure
20:38:52 <haasn> augur: I'd argue they are most certainly not different words. Perhaps they are in some language that is not english, but which represents english (like a colored syntax tree in which they might have different colors); but they are the same word in written english which is represented by a series of characters and nothing else
20:39:04 <EvanR> you can of course use other functions in a class def
20:39:12 <mzero> solidus-river: you can defined it elsewhere with some long name and then in the class def     memberFoo = theLongAndWindingNameOfMemberFooGenericlyImpelementedElsewhere
20:39:16 <haasn> It's up to the interpreter to transform it into a language in which “know” and “know” are different words
20:39:23 <augur> haasn: i think there's some argument to be made for two senses of "know" but im not sure those are the two
20:39:25 <haasn> English needs smart interpreters.
20:39:38 <solidus-river> mzero: heh, i see you have some opinion about where it should be defined
20:39:47 <solidus-river> :P
20:39:51 <augur> haasn: eg consider "Do you know John?" vs. "Do you know who danced the Macarena?"
20:39:55 <mzero> :-0
20:40:23 <augur> haasn: in the first sense, "know" means something like "to be acquainted with", while in the second sense, it means something like "have the answer to"
20:40:31 <johnw> wait, somebody knows me?
20:40:32 <mzero> no, really, if the generic implemetnation is more than two lines, I'd do that : I'd define   genericMemberFoo later in the module, and reference it    memberFoo = genericMemberFoo
20:40:42 <solidus-river> mzero: mwhit thanks :)
20:40:46 <augur> haasn: to "know" John means to be acquainted with john, but to know who danced the macarena is to be able to answer "John danced the macarena"
20:41:05 <augur> haasn: and you can know who danced the macarena without knowing the person who danced the macarena
20:41:11 <solidus-river> i've noticed another wierd thing, people say that order of definitoin doesnt matter but in my modules if i define a method after its referred to in the instance declaration it says its undefined
20:41:20 <augur> haasn: ie, you might be able to answer "yes, it was john", without being acquainted with john
20:41:23 <solidus-river> this has only come up in modules that use TemplateHaskell though so i'm not sure if its a side effect of that
20:41:38 <augur> haasn: in _that_ case it seems plausible to say its two different words that happen to sound the same
20:41:43 <mwhit> salidus-river: it is
20:41:55 <mwhit> solidus-river*
20:42:22 <mwhit> i usually try to keep any use of TH to its own module for that reason
20:42:41 <mwhit> when possible
20:43:58 <augur> haasn: it would be interest to see if there is a single common semantics that can make sense of both of these tho
20:44:02 <enthropy> solidus-river: that situation probably gives you mutually recursive modules
20:44:04 <mzero> do we need #haskell-semiotics ???
20:44:21 <mzero> or #haskell-hermenutics-of-quantum-gravity ????
20:44:24 <augur> mzero: semiotics s bogs :P
20:44:29 <augur> is bogus*
20:44:29 <haasn> augur: I'm not sure about my grammar here, can “Do you know who danced the Macarena” be understood the same as “Do you know (the person) who danced the Macarena”?
20:44:42 <augur> haasn: not in my dialect
20:44:50 <haasn> I don't think so either
20:44:51 <EvanR> usually the discussion in here is interesting if off topic ;)
20:44:56 <mzero> no - really, this has gone a bit off topic
20:45:07 <mzero> and we have a channel for tha
20:45:07 * haasn goes afk to watch some stuff
20:45:19 <augur> haasn: there might be some dialects where it works, but, to me, it means nothing more than "can you answer the question 'who danced the Macarena'"
20:45:32 <augur> haasn: some stuff = HCF?
20:45:49 <mzero> ...for that #haskell-overflow
20:46:09 <augur> mzero: overflow? not blah?
20:46:09 <augur> :P
20:46:26 <augur> how optimistic -- this is haskell, but too much so!
20:47:26 <solidus-river> enthropy: where i define the default implimentation for a class method in terms of the class itself?
20:47:42 <solidus-river> or the template haskell requiring ordering
20:47:50 <mzero> (oy - now #irc crashes)
20:47:54 <mzero> #haskell-blah, sure
20:48:11 <mzero> can anyone compile texmath-0.6.7 with ghc 7.8.3?
20:48:13 <augur> mzero: denotational semantics belongs in #haskell!
20:48:26 <mzero> begs to differ
20:48:40 <mzero> but... it's a big room
20:50:02 <kazagistar> problem with side discussions is that often people don't want to post their more directly relevant quesions until it is quiet enough in the room
20:50:11 <orion> When I follow these instructions, http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ -- I get the following output: "Exit code: ExitFailure 138" and GHC leaves a core dump. Does anyone know what could be going wrong?
20:50:34 <glguy_> Solidus: template Haskell imposes an ordering before and after the splice
20:54:52 <pharaun> kazagistar: hence haskell-blah :p
20:56:37 <johnw> I do not dance the Macarena
20:58:36 <kazagistar> pharaun: hence the dozens of freenode rooms with haskell in the name haha
21:16:49 * hackagebot Network-NineP 0.2.0 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.2.0 (SergeyAlirzaev)
21:36:44 <orion> If you use a lot of ADTs in your code, is it a mark of shoddy programming?
21:36:51 <vanila> opposite
21:36:56 <jle`> orion: algebraic data types?
21:36:58 <jle`> no, it's good
21:37:02 <jle`> :)
21:37:11 <jle`> abstract data types?
21:37:22 <eazar001> datatypes?
21:37:28 <eazar001> make sure they have good purpose
21:37:35 <eazar001> if they are there just for show, then yes it is shoddy
21:37:38 <eazar001> otherwise, no
21:37:52 <jle`> using data Piece = X | O
21:37:58 <jle`> is probably better than type Piece = Bool
21:38:25 <eazar001> naturally
21:38:37 <orion> Besides writing large amounts of impure code, what other things should a novice try to avoid?
21:38:51 <jle`> orion: avoid explicit recursion whenever possible
21:39:04 <vanila> there's nothing wrong with explicit recursion
21:39:05 <jle`> prefer higher order functions if there are any available
21:39:05 <joelteon> putting anything in the IO monad that doesn't need to be there
21:39:23 <eazar001> loading *everything* into memory
21:39:31 <eazar001> stream and be as lazy as possible
21:39:58 <eazar001> oh yea, not using Text
21:39:59 <jle`> vanila: nothing wrong with explicit recursion where it is appropriate...but for someone new, it is nice to encourage them to look for zipWith, foldr, map, etc. instead of reaching for explicit recursion right away
21:40:19 <haasn> orion: Type classes
21:40:23 <vanila> ah good point
21:40:26 <jle`> for most cases of explicit recursion a new person might encounter, there is *usually* a higher order function available
21:40:32 <haasn> By that I mean inventing new ones
21:40:39 <jle`> explicit recursion usually means more bugs and less compiler guarantees
21:40:44 <jle`> more opportunities for bugs
21:40:47 <platz> learn about Data.List.Split before doing something crazy
21:41:12 <JeroldHaas> I'd like to get into Haskell programming but am confused about IDE's. I like Vim but not sure how Vim likes Haskell. also, what's the best Haskell compiler for Win8?
21:41:27 <haasn> The best “IDE” for Haskell is GHCi
21:41:28 <mwhit> the only haskell compiler that matters is ghc
21:41:32 <eazar001> JeroldHaas: Leksah is pretty nice
21:41:47 <haasn> I use vim to write haskell but my vim has no knowledge of haskell other than how to highlight syntax
21:41:49 <jle`> i use vim for all my haskell stuff and...it's been adequate
21:41:49 <JeroldHaas> ghci, got it. ok with windows?
21:41:56 <jle`> i use it to highlight type errors and warnings
21:41:56 <trap_exit> in OSX, iwhat is the easiest way to do screen poking in an IO() monad? (I want to say, move mouse to location X + Y, simulate a click)
21:41:59 <jle`> and integrate with ghc in that way
21:42:11 <eazar001> JeroldHaas: there are packages out there that support vim + haskell, syntax highlighting etc.
21:42:16 <Exio> i'm using windows (right now!) and i use ghci in a terminal + leksah
21:42:32 <eazar001> leksah is great for projects
21:42:34 <jle`> but i do'nt think there is inherently anything about vim that makes it particularly haskell-friendly that can't be found in other fully featured text editors/ide's
21:42:42 <mwhit> JeroldHaas: as far as vim plugins: ghcmod-vim, neco-ghc should have most of what you'd want
21:43:17 <JeroldHaas> would prefer project support above simple text editing. does leksah have vim emulation?
21:43:18 <mwhit> combined with syntastic, youcompleteme, etc
21:43:23 <[swift]> emacs also provides a very good haskell experience
21:43:37 <jle`> my project management is just ctrl+p + cabal
21:43:54 <JeroldHaas> thx [swift] but I'm a bit allergic to emacs ;)
21:43:57 <mwhit> JeroldHaas: ghcmod-vim integrates well with cabal and sandboxes, project management is no trouble
21:44:18 <eazar001> JeroldHaas: leksah is nothing like vim, but is perfect for project support, and solid development
21:44:18 <platz> some people just use sublime text
21:44:27 <vanila> [swift], im a long time emacs user and I havea lot of trouble with haskell mode :S
21:44:37 <vanila> can i have the relevant part of your .emacs or something?
21:44:57 <JeroldHaas> thanks all, I'll look into these options you've provided
21:45:00 <[swift]> JeroldHaas: i can understand =) i use them both
21:45:17 <mwhit> i'm very, very happy with vim as a nearly complete ide for haskell. code completion/project management/syntax checking/type checking all right there
21:45:27 <[swift]> vanila: yeah, it's actually on github, though i warn you: it's full of stuff you may not want
21:45:34 <[swift]> vanila: but you might find it useful as a starting point
21:45:39 <vanila> that's fine! I can just take the bits i like
21:46:59 <[swift]> vanila: (actually looking at this i realize that it's kinda out of date, but i'm not on the right computer right now to update the repo, alas)
21:47:01 <[swift]> vanila: https://github.com/sethfowler/dot-emacs
21:47:07 <vanila> thanks a lot :)
21:48:11 <[swift]> mwhit: what do you use for project management in vim, out of curiosity?
21:48:21 <hiptobecubic> who does project management in vim?
21:48:31 <mwhit> [swift]: depends on what you mean by "project management", i guess
21:48:39 <JeroldHaas> I didn't want to start a vim vs emacs war
21:48:43 <mwhit> i guess now that i think about it that's a fairly vague term
21:48:45 <[swift]> mwhit: i was wondering what *you* meant =)
21:49:12 <[swift]> in emacs i use projectile, but in vim the closest thing i have to that is command-t (sort of like jle` mentioned with ctrl-p)
21:49:14 <vanila> JeroldHaas, don't worry there is no war, it's fine
21:49:37 <jle`> i'm happy with vim, everyone is happy with everything...the take home point should be that haskell works well with everything :)
21:49:45 <jle`> no matter what you pick
21:49:46 <hiptobecubic> or nothing
21:49:47 <JeroldHaas> I've been on the net long enough to know about the emacs vs vim wars ;)
21:49:48 <jle`> haskell++
21:50:06 <jle`> three cheers for haskell, the ultimate winner
21:50:07 <[swift]> pretty much. i work with haskell in both emacs and vim and it's a good experience in both
21:50:08 <jle`> :3
21:50:22 <mwhit> [swift]: looking at projectile, most of that is covered by NERDTree, vim-ack, and command-t
21:50:54 <hiptobecubic> fugitive and ctrlp are all i ever use to get around in a project
21:50:59 <hiptobecubic> sometimes nerdtree if i'm totally lost
21:51:07 <mwhit> then fugitive of course for source control
21:51:15 <mwhit> which i've recently discovered i love
21:51:18 <hiptobecubic> <3 :Ggrep
21:51:19 <[swift]> mwhit: to be honest the main thing i use projectile for is to remember my compilation commands for different projects
21:51:30 <jle`> i installed fugitive and nerdtree etc. but i don't really use anything other than ctrl+p.  and a buffer manager of course
21:51:38 <[swift]> i've gotten a bit addicted to that
21:51:50 <[swift]> fugitive is the best. emacs still doesn't have anything as good =\
21:51:51 <mwhit> tbh i have command-t but i never use it
21:51:55 <mwhit> i just don't have the habit
21:52:09 <hiptobecubic> fugitive and git timelapse are both totally sexy
21:52:12 <mwhit> maybe if my projects were larger
21:52:12 <jle`> oh i use a lot of those auto completor things
21:52:14 <[swift]> some of the code bases i work on are so large that ctrl-p is unusable
21:52:25 <hiptobecubic> [swift], after indexing?
21:52:30 <[swift]> hiptobecubic: yup
21:52:32 <jle`> so if i define something on one file of my project, and it's in-scope, it'll auto-complete on other files
21:52:34 <hiptobecubic> with fuzzy search? impossibru
21:52:40 <ddellacosta> jle`: thanks for the link, btw. :-)  Checking it out now.
21:52:40 * [swift] shrugs
21:52:50 <hiptobecubic> [swift], how many files are we talking here?
21:52:50 <[swift]> possibly it's gotten better in newer versions. i made the decisions years ago
21:52:57 <platz> would like to learn magit more but my head can only memorize so many commands
21:53:07 <hiptobecubic> [swift], oh. yes your experience like out of date then.
21:53:11 <hiptobecubic> is likely*
21:53:16 <hiptobecubic> me english
21:53:36 <[swift]> quite possibly
21:54:31 <[swift]> the indexing thing is extremely irritating though. it annoys me in command-t too
21:54:41 <[swift]> i tend to close and reopen vim a lot
21:54:56 <ReinH> You can get a lot done with :e **/
21:55:26 <ReinH> which wil tab-complete to match files and dirs that match the glob
21:56:23 <[swift]> ReinH: nifty, never thought of using it that way. thanks
21:56:38 <EvanR> if you have several buffers open :b foo<tab> will let you switch easier, if you dont have global markers set
21:57:01 <ReinH> I have it mapped to <Leader>e in normal mode and I map <Leader>e to **/ in command mode so I can also use it with :sp and :vsp
21:57:09 <ReinH> Of course I use emacs now, but still
21:57:16 <hiptobecubic> in git projects it's pretty instantaneous
21:57:23 <hiptobecubic> just uses git ls-files it hink
21:57:24 <[swift]> i personally use command-t's buffer switching mode. ctrl-p has a similar feature (i originally switched to ctrl-p because it had that, before command-t added it)
21:57:25 <hiptobecubic> i think*
21:57:43 <hiptobecubic> is hdevtools a dead project?
21:57:49 <ReinH> You can also do your own fuzzy matches with :e **/*foo*bar* ;)
21:57:57 <ReinH> hiptobecubic: I thought it was just updated recently
21:57:59 <mwhit> hiptobecubic: yes
21:57:59 <EvanR> whats command-t, is that emacs
21:58:05 <mwhit> hiptobecubic: use ghc-mod
21:58:08 <hiptobecubic> :( is there a good replacement?
21:58:08 <[swift]> hiptobecubic: i'm starting to worry that it is. the author isn't very responsive to github issues =\
21:58:19 <ReinH> Hmm maybe it is
21:58:21 <ReinH> :/
21:58:22 <ReinH> shame
21:58:23 <hiptobecubic> ghc-mod is (was?) way slow by comparison
21:58:33 <platz> ReinH: Do you use Inf-Haskell or run an actuall shell for ghci?
21:58:34 <[swift]> someone should just fork hdevtools
21:58:37 <hiptobecubic> people are still making PRs for hdevtools
21:58:39 <joelteon> hdevtools and ghc-mod do the same thing
21:58:44 <joelteon> hdevtools just saves its work
21:58:46 <ReinH> platz: I use haskell-mode, yeah
21:58:48 <ReinH> Sometimes I run a shell though
21:58:49 <[swift]> there are patches for the currently compatibility issues it has already posted to github as pull requests, i believe
21:58:54 <mwhit> eh don't have much direct experience with hdevtools, but ghc-mod seems fine to me
21:59:23 <platz> ReinH: ah - so close for me but for the lack of tab-completion in ghci
21:59:37 <jle`> no tab completion in ghci?
21:59:43 <ReinH> hmm
21:59:56 <jle`> oh, i should read the context
22:00:29 <hiptobecubic> looks like schell's fork is winning currently
22:00:32 <hiptobecubic> https://github.com/bitc/hdevtools/network
22:00:34 <platz> it's due to the way emacs runs all shells in it's special shell modes
22:01:19 <joelteon> Dec 3, 2013
22:01:21 <platz> but alternativey if you switch languages a lot, it's nice that all repls then have the same keybindings
22:05:51 <hiptobecubic> is there a way to have your cabal sandbox just copy the libraries it wants from the system environment if they are already there? rather than build them again
22:06:45 <hiptobecubic> schell's fork here builds: https://github.com/schell/hdevtools/tree/cabal-support-ghc7.8
22:06:49 <hiptobecubic> Just FYI
22:08:04 <hiptobecubic> Has anyone tried building anything with QML+HsQML
22:08:49 <hiptobecubic> On the one hand, it looks actually achievable. On the other, dynamically generated GUI's from pseudo-javascript just feels *wrong* and fragile.
22:11:03 <jle`> hm
22:11:30 <jle`> why would anybody ever use State s instead of StateT s m
22:11:49 <hiptobecubic> because they don't need other monads?
22:11:49 <vanila> well it's the state monad..
22:12:08 <jle`> well State s is just StateT s Identity
22:12:14 <jle`> i guess i sohuld be asking
22:12:18 <ddere> jle`: why not (MonadState s m)?
22:12:27 <jle`> why would anybody write their functions for State s instead of StateT s m
22:12:30 <jle`> ddere: probably even better :)
22:12:49 <jle`> writing functions over StateT s m or MonadState s m will still let you be able to use them as State s
22:12:55 <tejing1> prelude's undefined matches any type, right?
22:12:55 <enthropy> maybe it's code from before mtl-2?
22:12:56 <jle`> because they are parameterized over all m
22:13:08 <jle`> enthropy: oh no i'm thinking about design decisions for the future
22:13:20 <jle`> tejing1: yes, and any exception does as well
22:13:27 <tejing1> k, thanks
22:14:05 <jle`> tejing1: people use it to "fill in the blanks"..."hole based programming"...to get the typechecker to be happy and worry about other parts for now
22:15:18 <jle`> Monad m => StateT s m a should give you everything that State s a does, and more...you can use it "inside" another State s a without requiring any lifting...and it doesn't "let you use" any specific underlying monad, like IO
22:15:23 <ddere> jle`: I would agree, i would only use (State s) as the base monad for a transformer stack, if it happened to be the base, though i find that to be quite rare
22:15:24 <jle`> so you can just toss it into any StateT s IO a
22:15:29 <tejing1> I wanted to know if this definition would really work right:
22:15:29 <tejing1> statefulmap :: (c -> a -> (b,c)) -> c -> [a] -> [b]
22:15:30 <tejing1> statefulmap f i = map fst . tail . scanl (\x y -> f $ snd x) (undefined,i)
22:15:40 <jle`> if you really wanted your stack to be "in StateT s IO", and have some parts be "pure only"
22:15:44 <dfeuer> I seem to remember there being a package sort of like Data.Bits but all in ternary. But I can't find it on Hackage under acme, or anywhere else. Is it possible it was for some language other than Haskell, or does anyone know what I'm talking about?
22:15:53 <jle`> some people have done things in State s a and have written a State s a -> StateT s IO a function
22:16:20 <jle`> but if you just leave it as Monad m => StateT s m a...you don't have to do that
22:16:22 <jle`> the lifting is free
22:16:39 <jle`> and you have all the "guaruntees" that you would presumably be getting from usting State s a
22:16:45 <jle`> (the inability to do IO/access the underlying monad)
22:16:51 <jle`> s/usting/using
22:17:30 <jle`> ...this gets rid of an entire class of use cases for Tekmo's mmorph, doesn't it?
22:17:41 <jle`> sorry gabriel
22:17:56 <ddere> jle`: with (MonadState s m) => your lifting would be even "free-er" if you added more transformers to the stack
22:17:59 <mwhit> tejing1: it looks like f should take 2 arguments, but you're only giving it 1
22:18:08 <jle`> ddere: yeah, it's freer...but that's only for mtl :)
22:18:13 <ddere> ;)
22:18:44 <tejing1> mwhit: oops. that should be "f (snd x) y" lol
22:18:59 <mwhit> > tail [undefined, 1, 2]
22:19:00 <lambdabot>  [1,2]
22:19:05 <mwhit> yeah, it should work then
22:19:25 <tejing1> cool
22:19:50 <jle`> although i think mmorph is for when you get a State s a that you can't control...you get things in the form of State s a, and you don't have the option of asking the person who gave it to you to parameterize it over all monads
22:20:25 <Walther> mmorph - massive multiplayer online role playing haskell? :P
22:20:37 <jle`> Walther: yes that :)
22:20:42 <jle`> or in some contexts, monad morphisms
22:20:43 <mwhit> isn't that what we're doing now?
22:20:58 <Walther> hehe
22:22:20 <pingu> I am not great with these lenses, does anyone know if it is possible to extract a filtered portion of a traversible, then stick back in a modified version (of the same length, same order, but different values)?
22:22:24 <pingu> overFiltered :: (a -> Bool) -> ([a] -> [a]) -> [a] -> [a]
22:22:28 <pingu> something like that? ^^
22:22:31 <pingu> is that even possible?
22:22:45 <edwardk> pingu: 'it is possible' -- but the result isn't technically a legal traversal
22:22:52 <mwhit> oh snap
22:22:57 <mwhit> edwardk out of nowhere
22:23:11 <edwardk> > over (traverse.filtered even) (*2) [1..10]
22:23:12 <glguy> It's fine as long as you put in values that preserve the predicate you filtered with, though
22:23:12 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
22:23:24 <edwardk> that is legal because we maintained the 'even' invariant
22:23:42 <edwardk> but if i had done something like subtracted 1 from the even entries, then the predicate wouldn't match on the second visit
22:23:58 <pingu> edwardk: I'd like to 'bunch up' the filtered array is all. I want to pass it off to a monadic action as a batch.
22:24:01 <edwardk> and you would fail the 'over l f . over l g = over l (f . g)' setter law
22:24:21 <redtricycle> How do I show a Data.Time Day->IO?
22:24:25 <redtricycle> print $ fromGregorian a
22:24:28 <redtricycle> errors
22:24:34 <redtricycle> err
22:24:37 <jle`> redtricycle: what is the error? :)
22:24:41 <edwardk> you can also use 'partsOf' to gather the targets in one pass so you can write back with an action after you change it
22:24:49 <edwardk> :t partsOf (traverse.filtered even)
22:24:50 <lambdabot> (Traversable t, Functor f, Integral b) => LensLike f (t b) (t b) [b] [b]
22:24:53 <redtricycle> aCouldn't match expected type "IO Day" with actual type Day jle`
22:24:58 <ddere> hehe
22:24:59 <edwardk> now you can just pass that your monadic action
22:25:02 <redtricycle> a<- fromGregorian 2009 12 31
22:25:09 <edwardk> :t \f -> partsOf (traverse.filtered even) f
22:25:09 <redtricycle> print $ showGregorian a
22:25:09 <lambdabot> (Traversable t, Functor f, Integral b) => ([b] -> f [b]) -> t b -> f (t b)
22:25:25 <jle`> redtricycle: what is the type of fromGregorian?
22:25:33 <pingu> edwardk: so given that partsOf gathered my targets, then I modify my targets, how do I 'set' those targets?
22:25:41 <hiptobecubic> I feel like lenses are really a different language altogether. It's like learning C++ from an old book and then having someone tell you to use Boost.
22:25:46 <edwardk> pingu: see \f -> partsOf (traverse.filtered even) f
22:25:55 <jle`> redtricycle: and what is the type of showGregorian?
22:25:57 <pingu> edwardk: okay, thanks. I'll look into that.
22:26:05 <redtricycle> fromGregorian :: Integer -> Int -> Int -> Day
22:26:06 <redtricycle> time Data.Time.Calendar
22:26:08 <edwardk> f is the monadic action you want to run that takes in a list and spits out a list of the same length
22:26:13 <edwardk> then it'll put them back in where you want
22:26:15 <ddere> :t partsOf
22:26:16 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
22:26:23 <redtricycle> showGregorian :: Day -> String
22:26:23 <redtricycle> time Data.Time.Calendar
22:26:28 <jle`> redtricycle: so when you're in a do block
22:26:36 <jle`> for IO
22:26:39 <jle`> when you see something like:
22:26:42 <jle`> x <- foo
22:26:52 <vanila> is there a paper on this modern lens stuf?
22:26:53 <jle`> it means that foo :: IO a, and x is bound to the result of that value
22:26:57 <jle`> that `a`
22:27:03 <jle`> so if foo :: IO a, x :: a
22:27:04 <edwardk> xs^.partsOf foo    = xs^..foo     but you can write back to partsOf.. it gathers all the targets of a traversal and makes a lens to the list of targets where you agree not to change the length of the list
22:27:20 <edwardk> vanila: there are talks, videos, blog posts, a few papers, etc.
22:27:23 <jle`> redtricycle: in your case, you are doing a <- something, where something :: Day
22:27:41 <edwardk> vanila: i tend not to bother publishing as i'd rather write more code, but i try to give talks on it fairly regularly
22:27:44 <mwhit> hiptobecubic: that's been exactly my experience. Lenses are simple enough, but traversals and folds still bend my brain sometimes
22:27:46 <jle`> redtricycle: you don't need to "bind any value inside an IO action"
22:28:12 <jle`> redtricycle: if something :: IO Day, then a <- foo would work...`a` would be the `Day` returned by the `IO Day`
22:28:20 <jle`> redtricycle: what you are looking for is just a normal let binding
22:28:24 <bitemyapp> edwardk: that time consuming eh?
22:28:36 <jle`> instead of a <- fromGregorian 2009 12 30, you can just do let a = fromGregorian 2009 12 30
22:28:49 <redtricycle> Ah..so I can do this
22:28:58 <redtricycle> print $ addDays 1 $ fromGregorian 2009 12 31
22:29:06 <pingu> edwardk: this partsOf traversal is so much awesome, thanks!
22:29:12 <edwardk> bitemyapp: well, academics get optimized for paper production, people 'in industry' get optimized for solving some particular work problem, so someone has to get optimized for just building all the libraries. ;)
22:29:17 <jle`> redtricycle: yes you can...although using lots of $'s like that is generally discouraged
22:29:18 <vanila> hmm i would rather read a paper but what is the best talk to learn about it?
22:29:24 <redtricycle> How can I refactor it?
22:29:31 <redtricycle> When I refactor, I need to use <- in a do
22:29:41 <redtricycle> Or...I assumed I did
22:30:09 <edwardk> i'll probably ramp down some of the talks and obligations to get more code done next year
22:30:15 <jle`> you can do print $ addDays 1 (fromGregorian 2009 12 31)... or, as i like, print . addDays 1 $ fromGregorian 2009 12 31
22:30:32 <jle`> redtricycle: so the difference between <- and let is
22:30:47 <jle`> if you have an `IO a`, and you want to "use" the `a`, then you have to use <-
22:30:58 <jle`> if you have an `a`...and you want to "use" that exact `a`...you use a let binding
22:31:31 <jle`> maybe i should say "name for later usage" instead of "use"
22:32:44 <jle`> or just "name"
22:34:03 <shlevy> Is there a good way to represent bitfields in haskell?
22:34:10 <redtricycle> thanks jle` , writing this down
22:34:44 <shlevy> A record of Bools I guess
22:35:16 <jle`> redtricycle: no problem :)  this might seem "arbitrary" for now, but when you learn more haskell, you'll see that it's a part of a much deeper design.  also, it forces you to be explicit about your types...no implicit conversions:)
22:35:28 <jfischoff> what happens when you create a Handle to Socket and then use hSetPosn to rewind the Handle? Will the call succeed?
22:35:32 <solidus-river> can you use gaurds inside a case statement / what does that look like
22:35:45 <jle`> case x of
22:35:53 <jle`>     Just y | y < 1 -> ...
22:36:10 <solidus-river> thanks :)
22:36:28 <jle`> i am reminded of the new swift option types, which "auto joins" everything whenever possible
22:36:36 <bitemyapp> this isn't on topic, but I feel like this is a good audience for this question. Has anybody seen a tree-of-knowledge-esque website that tells you the prerequisites and hours required to learn something like, say, linear regression?
22:36:36 <jle`> as a contrast to this type safety
22:36:44 <bitemyapp> I ran into a site like this once but forgot to bookmark it.
22:37:02 <bitemyapp> jle`: dare I ask what auto-join is?
22:37:19 <redtricycle> bitemyapp: khan academy? lists pre-reqs for the courses
22:37:28 <jle`> well the syntax for "chaining maybe" is "act like fmap when you chain an (a -> b), and act like bind when you chain an (a -> Maybe b)"
22:37:31 <jle`> and you can't pick which one
22:37:59 <jle`> so if you try to "fmap" an (a -> Maybe b) onto a Maybe a, you'll always get a Maybe b, and you'll never get a Maybe (Maybe a)
22:38:02 <jle`> er, Maybe (Maybe b)
22:38:11 <jle`> ...not that we normally use Maybe (Maybe b)'s
22:38:11 <bitemyapp> redtricycle: nope, found it.
22:38:15 <bitemyapp> redtricycle: http://metacademy.org/graphs/concepts/logistic_regression
22:38:15 <solidus-river> bitemyapp: khanacademny
22:38:27 <jle`> but sometimes we like Monad m => m (m a)
22:38:36 <bitemyapp> solidus-river: no, what I just linked.
22:38:38 <solidus-river> oh nice, didn't know about metacademy
22:38:49 <bitemyapp> my finding it again was due to a weird coincidence
22:38:50 <isomorpheous> question
22:39:07 <isomorpheous> Why were n+k patterns banned in 2010?
22:39:21 <redtricycle> bitemyapp: that's pretty neat
22:39:44 <jle`> they're weiiiiirrrddd
22:40:05 <edwardk> bitemyapp: "Metacademy is a "just-in-time" learning resource." ಠ_ಠ
22:40:22 <splintax> bitemyapp: neat. needs a monad tutorial though
22:40:56 <edwardk> isomorpheous: because they required lots of weird conditions that 'felt wrong' in the language
22:41:20 <bitemyapp> edwardk: laughed pretty hard at your reaction - I needed a way to map out what I was missing.
22:41:26 <bitemyapp> which is nearly everything
22:41:30 <edwardk> isomorpheous: they used a notion of equality tied to the way they worked, they bound unification variables that couldn't be negative, etc.
22:41:38 <edwardk> fair nuff =)
22:41:57 <isomorpheous> ah
22:41:58 * hackagebot hsnsq 0.1.1.0 - Haskell NSQ client.  http://hackage.haskell.org/package/hsnsq-0.1.1.0 (PaulBerens)
22:42:06 <vanila> what does that mean, about a unification variable being negative?
22:42:11 <vanila> ohh negative numbers
22:42:16 <vanila> nevermind
22:42:51 <edwardk> I just tend to believe that just-in-time learning is a terrible mode in which to work. If you don't know what you don't know then you can't go learn it when you need it. You have no idea it is out there! It doesn't matter how fast you are going if you are going in the wrong direction.
22:43:20 <edwardk> I'm all for easily accessible piecemeal educational resources, but that branding makes me sad
22:43:39 <bitemyapp> edwardk: I'm not a fan of believing learning is something you just dip your toe into periodically either
22:43:43 <bitemyapp> edwardk: but I gotta take what I can get.
22:43:50 <edwardk> but this is probably #haskell-blah material =)
22:44:00 <bitemyapp> Yes.
22:44:04 <bitemyapp> Sorry all for the distraction.
22:44:15 <edwardk> heh i was the one who launched into diatribe mode ;)
22:44:24 <joelteon> Surely learn-on-demand is in the spirit of Haskell
22:44:30 <jle`> :P
22:44:40 <jle`> obligatory CCC reference required here
22:44:46 <joelteon> I know absolutely everything, it's just that people haven't forced most of the thunks.
22:45:07 <edwardk> joelteon: if you know all the things that are out there that you can hold the thunk to force it. if you don't know that a thing exists you have no reference to the thunk to force
22:45:08 <jle`> http://ro-che.info/ccc/11
22:46:02 <joelteon> holy shit, what's wrong with their eyeballs?
22:48:20 <dfeuer> edwardk, do you happen to know if the new all-singing all-dancing list fusion code for 7.9 will make last a good consumer? It seems a tad absurd that it's not one right now.
22:49:12 <johnw> learn-by-need
22:50:24 <edwardk> joelteon: dfeuer: not sure. ask joachim breitner perhaps?
22:50:55 <dfeuer> Not sure who/how.
22:56:06 <haasn> learn-by-osmosis
22:57:28 <dfeuer> learn-by-doing
23:00:16 <dfeuer> @learn Haskell
23:00:17 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
23:00:32 <solidus-river> can haskell handel circular imports as long as the circle of imports spans more than 2 files
23:00:38 <solidus-river> *handle
23:00:51 <dfeuer> I was about to remind you that Handel is dead.
23:00:55 <haasn> Haskell can handle circular imports in general
23:01:18 <solidus-river> dfeuer: :P
23:01:39 <haasn> GHC isn't so good about it, I believe you can in fact construct situations in which it's impossible to patch the circular import using only .hs-boot files
23:01:57 <lamer14059110540> Does haskell play well with Hadoop?
23:03:41 <dfeuer> lamer14059110540, http://vimeo.com/90189610
23:05:22 <shlevy> Is there a good way to choose between a separate constructor vs a Bool field?
23:06:03 <jle`> shlevy: bool is usually a bad idea unless you actually want to represent a boolean
23:06:23 <shlevy> jle`: Can you give an example?
23:06:40 <jle`> a good and bad example?
23:06:41 <shlevy> I guess, like, in a language impl
23:06:51 <jle`> oh
23:06:59 <shlevy> A good example of when to use a Bool field
23:07:09 <jle`> you mean havinga nother constructor in your ADT, vs taking on a bool field
23:07:12 <shlevy> Yes
23:07:14 <shlevy> Sorry :)
23:07:19 <jle`> no, you were clear
23:07:35 <jle`> if you do choose to add a field, you might consider adding a field that isn't Bool either
23:08:08 <jle`> your own custom bool-like type
23:08:16 <jle`> i try to avoid introducing new constructors if you "duplicate" fields
23:08:37 <jle`> if your two constructors have the same multiple fields, except a different name, you might try to refactor
23:08:53 <shlevy> jle`: Ah that's nice
23:09:12 <shlevy> jle`: data ExecutableMode = Executable | NotExecutable
23:09:29 <shlevy> jle`: no duplication, no needing to read the docs to find out what "true" means
23:09:46 <jle`> yeah, it's usually preferred to use a custom data type over a Bool
23:09:57 <jle`> unless it's something a little trivial...
23:10:13 <jle`> or you actually mean to represent a Boolean value, semantically
23:10:30 <shlevy> Right
23:12:01 * hackagebot trifecta 1.4.3 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4.3 (EdwardKmett)
23:12:30 <jle`> (looking at my code, i do use one-off bools every once in a while, so i guess the answer really depends on the situation)
23:13:06 <enthropy> type IsExecutable = Bool
23:13:23 <jle`> yeah, there's the in-between route
23:13:50 <jle`> also a lot of situations where I had thought of as needing a bool ended up being Maybe or Either
23:16:49 <redtricycle> How can I get the "Locale" module?  Cabal suggests it's in haskell98, but I get conflicts with multiple Preludes
23:17:17 <redtricycle> trying to do this: http://stackoverflow.com/questions/4174372/haskell-date-parsing-and-formatting
23:21:00 <Enigmagic> redtricycle: you might be looking for the old-locale package, which now mostly lives System.Locale: http://hackage.haskell.org/package/old-locale-1.0.0.6/docs/System-Locale.html
23:21:10 <lamer14059110540> dfeuer: thank you. have you used it before?
23:21:39 <redtricycle> gotcha, thanks Enigmagic
23:21:40 <Enigmagic> redtricycle: and though it's called old-locale, i don't think it has actually been superceded yet ;-)
23:34:36 <gamegoblin> So I can’t help but feel that Data.Time is kind of overcomplicated...
23:35:22 <Walther> time is a bit complicated. Oftentimes, it feels like going really quickly, other times really slowly. Also there are some people adding some extra seconds every now and then, and entire days even
23:35:46 <carter> time is so complciated you need to read history books to understand it
23:35:58 <gamegoblin> Just compared to over language’s standard time libraries, at least
23:35:59 <carter> and time zones CHANGE
23:36:15 <carter> standard time libs all lie
23:36:24 <glguy> time doesn't get simpler when you use another language, it's still the same time
23:36:48 <carter> yeah
23:36:49 <gamegoblin> Of course not, but the interface to the library changes
23:36:56 <Enigmagic> gamegoblin: there are various libraries trying to make something better.
23:37:19 <gamegoblin> I saw the datetime package “datetime-0.1: Utilities to make Data.Time.* easier to use.”
23:37:28 <gamegoblin> which It hink speaks volumes about Data.Time ;)
23:37:38 <gamegoblin> I think*
23:37:59 <Enigmagic> gamegoblin: indeed ;-)
23:38:00 <carter> i'm reading the haddocks for time rightnow
23:38:06 <carter> it looks pretty well documented :)
23:38:33 <carter> verbose
23:38:36 <gamegoblin> Well documented /= good and easy to use
23:38:39 <carter> :)
23:38:42 <carter> whats easy about time?
23:39:35 <gamegoblin> What’s hard about “get the number of seconds since the unix epoch in an int”
23:40:36 <vanila> I just googled data.time and on the first page is "Hackage: datetime: Utilities to make Data.Time.* easier to use."
23:40:49 <vanila> so you'renot the only one who finds it hard
23:42:04 <glguy> gamegoblin: If that's all you want to know: fmap floor getPOSIXTime
23:43:27 <Enigmagic> most or all of the larger shops using haskell have built their own time library
23:44:06 <lamer14059110540> what does a time library do?
23:44:06 <glguy> We just use the normal time library at work
23:44:48 <vanila> lamer14059110540, functions for handling, processing dates and times, timezones etc
23:45:01 <Enigmagic> glguy: would you consider your company a large haskell shop?
23:45:03 <gamegoblin> glguy: Won’t I also need to fromIntegral that?
23:45:05 <lamer14059110540> what is lacking in haskell?
23:45:24 <glguy> gamegoblin: No
23:45:32 <lamer14059110540> *time library
23:45:34 <Enigmagic> (internal polling)
23:45:35 <glguy> Enigmagic: Galois. I don't know what you call large
23:45:37 <gamegoblin> :t floor
23:45:41 <lambdabot> (RealFrac a, Integral b) => a -> b
23:45:56 <gamegoblin> ah
23:46:33 <gamegoblin> That feels weird.
23:46:58 <Enigmagic> glguy: well.. a lot of galois packages seem to be more research than production
23:47:01 <gamegoblin> It seems bizarre to me that such a common function in C et al isn’t a built in
23:47:24 <glguy> Enigmagic: Then we're doing our job. We're a research company
23:47:27 <Enigmagic> glguy: not that there is anything wrong with that ;-) but i know of 6 or 7 full time rewrites.
23:48:41 <dfeuer> no, lamer14059110540. Google!
23:48:59 <lamer14059110540> :(
23:49:18 <dmj`> Enigmagic: what packages have you written?
23:50:12 <tac_> What is the syntax for an UNUSED pragma?
23:50:17 <tac_> I have a sudden need for one in my code
23:50:29 <tac_> {-# UNUSED #-} isn't it, is it?
23:50:34 <Enigmagic> dmj`: we never open sourced our time library, i hacked around on some other ideas that someone else is toying with https://github.com/time-cube/time-cube
23:51:10 <Enigmagic> dmj`: i've written a handful of other packages on hackage..
23:52:11 <dmj`> Enigmagic: cool, do you work for alpha heavy?
23:52:42 <Enigmagic> dmj`: you could say that, sure
23:56:27 <dmj`> Enigmagic: very cool, I use the time library, but don't do anything fancy
23:58:56 <pingu> with lenses, is there a 'monadic' version of over?
23:59:03 <Enigmagic> dmj`: just depends on what your problem is. time solves some problems, but is ill suited to others. it just seems that most of the commercial users are solving different problems than what the time library was built for.
23:59:04 <edwardk> yes, the lens itself
23:59:22 <edwardk> you can also use mapMOf if it makes you feel better
23:59:29 <edwardk> :t _2 putStrLn
23:59:29 <lambdabot> Field2 s t String () => s -> IO t
23:59:36 <edwardk> :t both putStrLn
23:59:37 <lambdabot> Data.Bitraversable.Bitraversable r => r String String -> IO (r () ())
23:59:38 <pingu> edwardk: oh, I never would have gotten that.
23:59:43 <pingu> thanks
23:59:46 <edwardk> :t mapOf both putStrLn
23:59:47 <lambdabot> Data.Bitraversable.Bitraversable r => r String String -> r (IO ()) (IO ())
23:59:51 <edwardk> :t mapOf_ both putStrLn
23:59:52 <lambdabot>     Not in scope: ‘mapOf_’
23:59:52 <lambdabot>     Perhaps you meant one of these:
23:59:52 <lambdabot>       ‘mapMOf_’ (imported from Control.Lens),
23:59:56 <edwardk> :t mapMOf_ both putStrLn
23:59:57 <lambdabot> Data.Bitraversable.Bitraversable r => r String String -> IO ()
